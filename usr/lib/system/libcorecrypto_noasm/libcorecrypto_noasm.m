void *ccmode_factory_cfb8_decrypt(void *result, void *a2)
{
  *result = ((*a2 + 7) & 0xFFFFFFFFFFFFFFF8) + ((2 * a2[1] + 14) & 0xFFFFFFFFFFFFFFF0) + 8;
  result[1] = 1;
  result[2] = ccmode_cfb8_init;
  result[3] = ccmode_cfb8_decrypt;
  result[4] = a2;
  return result;
}

uint64_t cckyber_ntt_forward(uint64_t result)
{
  int v1 = 7;
  do
  {
    unsigned int v2 = 0;
    unsigned int v3 = 0x80u >> v1;
    int v4 = 2 << v1;
    unsigned int v5 = 1 << v1;
    do
    {
      if (v2 < v2 + (1 << v1))
      {
        unint64_t v6 = v5 - (unint64_t)v2;
        int v7 = cckyber_zetas[v3];
        unsigned int v8 = v5;
        v9 = (__int16 *)(result + 2 * v2);
        do
        {
          int v10 = 3329 * ((v7 * *(__int16 *)(result + 2 * v8)) >> 16) + 26632;
          __int16 v11 = *v9;
          *(_WORD *)(result + 2 * v8) = *v9 - HIWORD(v10);
          *v9++ = v11 + HIWORD(v10);
          ++v8;
          --v6;
        }
        while (v6);
      }
      ++v3;
      v2 += v4;
      v5 += v4;
    }
    while (v2 < 0x100);
    --v1;
  }
  while (v1);
  return result;
}

uint64_t cckyber_ntt_inverse(uint64_t result)
{
  for (int i = 1; i != 7; ++i)
  {
    unint64_t v2 = 0;
    uint64_t v3 = (1 << i);
    unsigned int v4 = 0x80u >> (i - 1);
    uint64_t v5 = result + 2 * v3;
    do
    {
      int v6 = cckyber_zetas[--v4];
      unint64_t v7 = v2;
      do
      {
        __int16 v8 = *(_WORD *)(result + 2 * v7);
        __int16 v9 = *(_WORD *)(v5 + 2 * v7);
        *(_WORD *)(result + 2 * v7) = (3329 * ((1290168 * (__int16)(v9 + v8)) >> 16) + 26632) >> 16;
        *(_WORD *)(v5 + 2 * v7++) = (3329 * ((v6 * (__int16)(v9 - v8)) >> 16) + 26632) >> 16;
      }
      while (v7 < v2 + v3);
      v2 += (2 << i);
    }
    while (v2 < 0x100);
  }
  uint64_t v10 = 0;
  int32x4_t v11 = vdupq_n_s32(0x912FE89F);
  int32x4_t v12 = vdupq_n_s32(0xD01u);
  int32x4_t v13 = vdupq_n_s32(0x6808u);
  int32x4_t v14 = vdupq_n_s32(0x94921C25);
  do
  {
    v15 = (int16x8_t *)(result + v10);
    int16x8_t v16 = *(int16x8_t *)(result + v10);
    int16x8_t v17 = *(int16x8_t *)(result + v10 + 256);
    int16x8_t v18 = vaddq_s16(v17, v16);
    int16x8_t *v15 = vaddhn_high_s32(vaddhn_s32(vmulq_s32(vshrq_n_s32(vmulq_s32(vmovl_s16(*(int16x4_t *)v18.i8), v11), 0x10uLL), v12), v13), vmulq_s32(vshrq_n_s32(vmulq_s32(vmovl_high_s16(v18), v11), 0x10uLL), v12), v13);
    int16x8_t v19 = vsubq_s16(v17, v16);
    v15[16] = vaddhn_high_s32(vaddhn_s32(vmulq_s32(vshrq_n_s32(vmulq_s32(vmovl_s16(*(int16x4_t *)v19.i8), v14), 0x10uLL), v12), v13), vmulq_s32(vshrq_n_s32(vmulq_s32(vmovl_high_s16(v19), v14), 0x10uLL), v12), v13);
    v10 += 16;
  }
  while (v10 != 256);
  return result;
}

uint64_t cckyber_ntt_basemul(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = a3 + 4;
  uint64_t v5 = a2 + 4;
  int v6 = &dword_2373AB140;
  do
  {
    int v7 = *v6++;
    __int16 v8 = (_WORD *)(result + v3);
    int v9 = 1806234369 * *(__int16 *)(v5 + v3 - 2);
    int v10 = *(__int16 *)(v5 + v3 - 4);
    unsigned int v11 = (3329 * ((((3329 * ((v9 * *(__int16 *)(v4 + v3 - 2)) >> 16) + 26632) >> 16) * v7) >> 16) + 26632) >> 16;
    *__int16 v8 = v11;
    v10 *= 1806234369;
    *__int16 v8 = v11 + ((3329 * ((v10 * *(__int16 *)(v4 + v3 - 4)) >> 16) + 26632) >> 16);
    int v12 = 3329 * ((v10 * *(__int16 *)(v4 + v3 - 2)) >> 16) + 26632;
    v8[1] = HIWORD(v12);
    v8[1] = ((3329 * ((v9 * *(__int16 *)(v4 + v3 - 4)) >> 16) + 26632) >> 16) + HIWORD(v12);
    int v13 = 1806234369 * *(__int16 *)(v5 + v3 + 2);
    int v14 = 1806234369 * *(__int16 *)(v5 + v3);
    unsigned int v15 = (3329 * (-(v7 * ((3329 * ((v13 * *(__int16 *)(v4 + v3 + 2)) >> 16) + 26632) >> 16)) >> 16)
                       + 26632) >> 16;
    v8[2] = v15;
    v8[2] = v15 + ((3329 * ((v14 * *(__int16 *)(v4 + v3)) >> 16) + 26632) >> 16);
    int v16 = 3329 * ((v14 * *(__int16 *)(v4 + v3 + 2)) >> 16) + 26632;
    v8[3] = HIWORD(v16);
    v8[3] = ((3329 * ((v13 * *(__int16 *)(v4 + v3)) >> 16) + 26632) >> 16) + HIWORD(v16);
    v3 += 8;
  }
  while (v3 != 512);
  return result;
}

void *cccast_ecb_decrypt_mode()
{
  return &cccast_eay_ecb_decrypt_mode;
}

void *cccast_ecb_encrypt_mode()
{
  return &cccast_eay_ecb_encrypt_mode;
}

void *cccast_cbc_encrypt_mode()
{
  return cbc_cast_encrypt;
}

void *cccast_cbc_decrypt_mode()
{
  return cbc_cast_decrypt;
}

void *cccast_cfb_encrypt_mode()
{
  return cfb_cast_encrypt;
}

void *cccast_cfb_decrypt_mode()
{
  return cfb_cast_decrypt;
}

void *cccast_cfb8_encrypt_mode()
{
  return cfb8_cast_encrypt;
}

void *cccast_cfb8_decrypt_mode()
{
  return cfb8_cast_decrypt;
}

void *cccast_ctr_crypt_mode()
{
  return ctr_cast;
}

void *cccast_ofb_crypt_mode()
{
  return ofb_cast;
}

uint64_t ccec_compact_import_pub_size(uint64_t a1)
{
  if (a1 <= 31)
  {
    if (a1 == 24) {
      return 192;
    }
    if (a1 == 28) {
      return 224;
    }
  }
  else
  {
    switch(a1)
    {
      case ' ':
        return 256;
      case '0':
        return 384;
      case 'B':
        return 521;
    }
  }
  return 0;
}

uint64_t ccec_compact_import_pub_ws(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned __int8 *a4, uint64_t **a5)
{
  uint64_t v8 = *(void *)(a1 + 16);
  *a5 = a2;
  int v9 = a5 + 2;
  uint64_t result = ccec_import_affine_point_ws(a1, a2, 4, a3, a4, (uint64_t *)a5 + 2);
  if (!result)
  {
    ccn_seti(*a2, &v9[2 * **a5], 1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 3 * *a2);
    uint64_t result = ccec_validate_point_and_projectify_ws(a1, a2, v11, (uint64_t)(a5 + 2));
  }
  *(void *)(a1 + 16) = v8;
  return result;
}

uint64_t ccec_compact_import_pub(uint64_t *a1, uint64_t a2, unsigned __int8 *a3, uint64_t **a4)
{
  uint64_t v8 = cc_malloc_clear(160 * *a1);
  uint64_t v9 = 20 * *a1;
  v12[0] = v8;
  v12[1] = v9;
  v12[2] = 0;
  v12[3] = cc_ws_alloc;
  int v13 = cc_ws_free;
  if (!v8) {
    return 4294967283;
  }
  uint64_t v10 = ccec_compact_import_pub_ws((uint64_t)v12, a1, a2, a3, a4);
  v13((uint64_t)v12);
  return v10;
}

uint64_t ccecdh_generate_key_ws(uint64_t a1, unint64_t *a2, uint64_t (**a3)(void, uint64_t, unint64_t *), unint64_t **a4)
{
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t result = ccec_generate_key_internal_fips_ws(a1, a2, a3, a4);
  if (!result)
  {
    if (ccecdh_pairwise_consistency_check_ws(a1, a4, 0, a3)) {
      uint64_t result = 4294967278;
    }
    else {
      uint64_t result = 0;
    }
  }
  *(void *)(a1 + 16) = v7;
  return result;
}

uint64_t ccecdh_generate_key(unint64_t *a1, uint64_t (**a2)(void, uint64_t, unint64_t *), unint64_t **a3)
{
  BOOL v16 = timingsafe_enable_if_supported();
  unint64_t v6 = *a1;
  uint64_t v7 = sizeof_struct_cche_galois_key();
  unint64_t v8 = sizeof_struct_ccpolyzp_po2cyc();
  v14[0] = cc_malloc_clear(8 * ((v7 + v8 + 4 * v6 * v8 - 1) / v8 - v6 + 32 * v6));
  unint64_t v9 = *a1;
  uint64_t v10 = sizeof_struct_cche_galois_key();
  unint64_t v11 = sizeof_struct_ccpolyzp_po2cyc();
  v14[1] = (v10 + v11 + 4 * v9 * v11 - 1) / v11 - v9 + 32 * v9;
  v14[2] = 0;
  v14[3] = cc_ws_alloc;
  unsigned int v15 = cc_ws_free;
  if (v14[0])
  {
    uint64_t key_ws = ccecdh_generate_key_ws((uint64_t)v14, a1, a2, a3);
    v15((uint64_t)v14);
  }
  else
  {
    uint64_t key_ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return key_ws;
}

uint64_t cch2c_hash_to_base_sae_ws(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t v25 = *MEMORY[0x263EF8C08];
  qmemcpy(v21, "SAE Hash to Element u", sizeof(v21));
  char v22 = a7 + 49;
  __int16 v23 = 20512;
  char v24 = a7 + 49;
  memset(v20, 0, 255);
  uint64_t v12 = (*(uint64_t (**)(void))(a2 + 16))();
  uint64_t v13 = cczp_n(v12);
  uint64_t v14 = *(void *)(a1 + 16);
  uint64_t v15 = 2 * v13;
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 2 * v13);
  int16x8_t v17 = (uint64_t *)(*(uint64_t (**)(void))(a2 + 24))();
  if (cchkdf_extract_internal(v17, a3, a4, a5, a6, (uint64_t)v20)
    || cchkdf_expand_internal((rsize_t *)v17, *v17, (uint64_t)v20, 25, (uint64_t)v21, *(unsigned int *)(a2 + 8), (uint64_t)v20)|| ccn_read_uint_internal(v15, v16, *(unsigned int *)(a2 + 8), v20))
  {
    uint64_t result = 4294967289;
  }
  else
  {
    cczp_mod_ws(a1, v12);
    uint64_t result = 0;
  }
  *(void *)(a1 + 16) = v14;
  return result;
}

uint64_t cch2c_hash_to_base_rfc_ws(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, unint64_t a5, uint64_t a6, char a7)
{
  uint64_t v24 = *MEMORY[0x263EF8C08];
  qmemcpy(v20, "H2C", sizeof(v20));
  char v21 = a7;
  char v22 = 1;
  memset(v23, 0, sizeof(v23));
  uint64_t v12 = (*(uint64_t (**)(void))(a2 + 16))();
  uint64_t v13 = cczp_n(v12);
  uint64_t v19 = *(void *)(a1 + 16);
  uint64_t v14 = 2 * v13;
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 2 * v13);
  uint64_t v16 = (*(uint64_t (**)(void))(a2 + 24))();
  if (a5 > 0xFF
    || (int16x8_t v17 = (uint64_t *)v16,
        __memcpy_chk(),
        cchkdf_extract_internal(v17, a3, a4, a5 + 1, (uint64_t)v23, (uint64_t)v23))
    || cchkdf_expand_internal((rsize_t *)v17, *v17, (uint64_t)v23, 5, (uint64_t)v20, *(unsigned int *)(a2 + 8), (uint64_t)v23)|| ccn_read_uint_internal(v14, v15, *(unsigned int *)(a2 + 8), v23))
  {
    uint64_t result = 4294967289;
  }
  else
  {
    cczp_mod_ws(a1, v12);
    uint64_t result = 0;
  }
  *(void *)(a1 + 16) = v19;
  return result;
}

uint64_t cch2c_hash_to_base_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t cczp_inv_field_ws(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = cczp_n(a2);
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8);
  unint64_t v11 = (unint64_t *)cczp_prime(a2);
  if (ccn_sub1(v8, v10, v11, 2uLL)) {
    uint64_t result = 0xFFFFFFFFLL;
  }
  else {
    uint64_t result = cczp_power_fast_ws(a1, a2, a3, a4, (uint64_t)v10);
  }
  *(void *)(a1 + 16) = v9;
  return result;
}

uint64_t ccec_generate_key_legacy(uint64_t *a1, uint64_t (**a2)(void, size_t, void *), unint64_t **a3)
{
  BOOL v21 = timingsafe_enable_if_supported();
  uint64_t v6 = *a1;
  memset(v20, 0, sizeof(v20));
  v19[0] = ccsha256_di();
  v19[1] = 0;
  uint64_t v18 = 0;
  memset(v17, 0, sizeof(v17));
  ccdrbg_factory_nisthmac(v17, (uint64_t)v19);
  uint64_t v7 = 27 * v6;
  if (27 * v6 <= (unint64_t)(49 * v6)) {
    uint64_t v7 = 49 * v6;
  }
  uint64_t v8 = v7 + v6;
  v14[0] = cc_malloc_clear((*(void *)&v17[0] + 8 * (v7 + v6) + 7) & 0xFFFFFFFFFFFFFFF8);
  v14[1] = v8 + ((unint64_t)(*(void *)&v17[0] + 7) >> 3);
  v14[2] = 0;
  uint64_t v15 = cc_ws_alloc;
  uint64_t v16 = cc_ws_free;
  if (v14[0])
  {
    uint64_t key_internal_legacy_ws = ccec_generate_key_internal_legacy_ws((uint64_t)v14, a1, a2, a3);
    if (key_internal_legacy_ws
      || (uint64_t v10 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))v15(v14, (unint64_t)(*(void *)&v17[0] + 7) >> 3), v11 = v15(v14, v6), key_internal_legacy_ws = (*a2)(a2, 8 * v6, (void *)v11), key_internal_legacy_ws)|| (key_internal_legacy_ws = ccdrbg_init_internal((uint64_t)v17), key_internal_legacy_ws)|| (key_internal_legacy_ws = ccrng_drbg_init_withdrbg((uint64_t (**)(uint64_t, uint64_t, uint64_t))v20, (uint64_t (*)(uint64_t, uint64_t, uint64_t))v17, v10), key_internal_legacy_ws))
    {
      uint64_t v12 = key_internal_legacy_ws;
    }
    else if (ccec_pairwise_consistency_check_ws((uint64_t)v14, a3, v20))
    {
      uint64_t v12 = 4294967278;
    }
    else
    {
      ccdrbg_done((uint64_t)v17, (uint64_t)v10);
      uint64_t v12 = 0;
    }
    v16((uint64_t)v14);
  }
  else
  {
    uint64_t v12 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v21);
  return v12;
}

uint64_t ccdh_copy_gp(uint64_t *a1, const void *a2)
{
  uint64_t v4 = *a1;
  if (v4 != ccdh_gp_n(a2)) {
    return 4294967243;
  }
  uint64_t v5 = ccdh_gp_n(a2);
  size_t v6 = ccdh_gp_size(8 * v5);
  memcpy(a1, a2, v6);
  return 0;
}

uint64_t ccz_expmod(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v30 = timingsafe_enable_if_supported();
  uint64_t v8 = ccz_n(a4);
  uint64_t v9 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v10 = sizeof_struct_ccpolyzp_po2cyc();
  v26[0] = cc_malloc_clear(8 * ((v9 + v10 - 1) / v10 + 13 * v8) + 8);
  uint64_t v11 = ccz_n(a4);
  uint64_t v12 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v13 = sizeof_struct_ccpolyzp_po2cyc();
  v26[1] = (v12 + v13 - 1) / v13 + 13 * v11 + 1;
  uint64_t v27 = 0;
  v28 = cc_ws_alloc;
  v29 = cc_ws_free;
  if (v26[0])
  {
    uint64_t v14 = ccz_n(a4);
    ccz_set_capacity(a1, v14);
    uint64_t v15 = (void *)cc_ws_alloc(v26, 2 * v14 + 4);
    void *v15 = v14;
    ccn_set(v14, v15 + 3, *(void **)(a4 + 24));
    uint64_t inited = cczp_init_ws((uint64_t)v26, v15);
    if (inited)
    {
      uint64_t v22 = inited;
    }
    else
    {
      int16x8_t v17 = (uint64_t *)v28(v26, v14);
      unint64_t v18 = ccz_n(a2);
      unint64_t v19 = ccz_n(a4);
      uint64_t v20 = ccz_n(a2);
      uint64_t v21 = v20;
      if (v18 >= v19)
      {
        cczp_modn_ws((uint64_t)v26, v15, v17, v20, *(char **)(a2 + 24));
      }
      else
      {
        if (v20) {
          ccn_set(v20, v17, *(void **)(a2 + 24));
        }
        ccn_zero(v14 - v21, &v17[v21]);
      }
      uint64_t v23 = ccz_bitlen((void *)a3);
      uint64_t v22 = cczp_power_ws((uint64_t)v26, (uint64_t)v15, *(void **)(a1 + 24), v17, v23, *(void **)(a3 + 24));
      if (!v22)
      {
        unint64_t v24 = ccn_n(v14, *(void *)(a1 + 24));
        ccz_set_n((void *)a1, v24);
      }
    }
    uint64_t v27 = 0;
    v29((uint64_t)v26);
  }
  else
  {
    uint64_t v22 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v30);
  return v22;
}

uint64_t ccss_shamir_share_generator_generate_share(uint64_t *a1, unsigned int a2, uint64_t a3)
{
  char v6 = 0;
  char v20 = 0;
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    if ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) & 0x1000000) != 0)
    {
      char v6 = 0;
    }
    else
    {
      __asm { MSR             DIT, #1 }
      char v6 = 1;
    }
  }
  char v20 = v6;
  if (!a2) {
    goto LABEL_8;
  }
  uint64_t v12 = ccss_shamir_consistent_primes(*a1, *(void *)a3);
  if (v12)
  {
    uint64_t v17 = v12;
    goto LABEL_10;
  }
  uint64_t v19 = a2;
  uint64_t v13 = ccss_shamir_prime_of((uint64_t)a1);
  uint64_t v14 = cczp_n(v13);
  uint64_t v15 = ccss_shamir_prime_of((uint64_t)a1);
  uint64_t v16 = cczp_prime(v15);
  if ((ccn_cmpn_internal(1, &v19, v14, v16) & 0x80000000) != 0)
  {
    ccss_shamir_evaluate_poly_to_buffer((uint64_t)a1, a2, (char *)(a3 + 16));
    uint64_t v17 = 0;
    *(_DWORD *)(a3 + 8) = a2;
  }
  else
  {
LABEL_8:
    uint64_t v17 = 4294967165;
  }
LABEL_10:
  cc_disable_dit(&v20);
  return v17;
}

uint64_t ccecies_decrypt_gcm_composite(unint64_t **a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, rsize_t a8, uint64_t a9, unsigned __int8 *a10, uint64_t a11)
{
  BOOL v30 = timingsafe_enable_if_supported();
  uint64_t v17 = *a1;
  unint64_t v18 = **a1;
  uint64_t v19 = sizeof_struct_cche_galois_key();
  unint64_t v20 = sizeof_struct_ccpolyzp_po2cyc();
  v28[0] = cc_malloc_clear(8 * ((v19 + v20 + 3 * v18 * v20 - 1) / v20 + 30 * v18));
  unint64_t v21 = *v17;
  uint64_t v22 = sizeof_struct_cche_galois_key();
  unint64_t v23 = sizeof_struct_ccpolyzp_po2cyc();
  v28[1] = (v22 + v23 + 3 * v21 * v23 - 1) / v23 + 30 * v21;
  v28[2] = 0;
  v28[3] = cc_ws_alloc;
  v29 = cc_ws_free;
  if (v28[0])
  {
    uint64_t v24 = ccecies_decrypt_gcm_composite_ws((uint64_t)v28, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
    v29((uint64_t)v28);
  }
  else
  {
    uint64_t v24 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v30);
  return v24;
}

uint64_t ccecies_decrypt_gcm_composite_ws(uint64_t a1, unint64_t **a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, rsize_t a9, uint64_t a10, unsigned __int8 *a11, uint64_t a12)
{
  uint64_t v16 = (uint64_t *)*a2;
  unint64_t v17 = **a2;
  uint64_t v28 = *(void *)(a1 + 16);
  unint64_t v18 = (uint64_t **)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, (24 * v17 + 23) >> 3);
  uint64_t v19 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v17);
  size_t v29 = (unint64_t)(cczp_bitlen((uint64_t)v16) + 7) >> 3;
  unint64_t v20 = ccecies_pub_key_size_cp((uint64_t)v16, a3);
  uint64_t v21 = ccecies_import_eph_pub_ws(a1, v16, a3, v20, a11, v18);
  if (v21
    || (uint64_t v21 = ccecdh_compute_shared_secret_ws(a1, a2, (unint64_t **)v18, &v29, v19, *(uint64_t (***)(void, uint64_t, unint64_t *))(a3 + 8)), v21))
  {
    uint64_t v22 = v21;
    goto LABEL_4;
  }
  uint64_t v22 = ccecies_decrypt_gcm_from_shared_secret_composite((uint64_t)v16, a3, v29, v19, a9, (uint64_t)a11, a10, a12, a5, a6, a7, a8, a4);
  if (v22) {
LABEL_4:
  }
    cc_clear(a9, a4);
  *(void *)(a1 + 16) = v28;
  return v22;
}

uint64_t ccecies_decrypt_gcm(uint64_t *a1, uint64_t a2, unint64_t a3, unsigned __int8 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, rsize_t *a9, void *a10)
{
  BOOL v33 = timingsafe_enable_if_supported();
  unint64_t v15 = ccecies_pub_key_size(a1, a2);
  uint64_t v16 = (uint64_t *)*a1;
  uint64_t v17 = *(void *)*a1;
  uint64_t v18 = sizeof_struct_cche_galois_key();
  unint64_t v19 = sizeof_struct_ccpolyzp_po2cyc();
  v31[0] = cc_malloc_clear(8 * ((v18 + v19 + 3 * v17 * v19 - 1) / v19 + 30 * v17));
  uint64_t v20 = *v16;
  uint64_t v21 = sizeof_struct_cche_galois_key();
  unint64_t v22 = sizeof_struct_ccpolyzp_po2cyc();
  v31[1] = (v21 + v22 + 3 * v20 * v22 - 1) / v22 + 30 * v20;
  v31[2] = 0;
  v31[3] = cc_ws_alloc;
  v32 = cc_ws_free;
  if (!v31[0])
  {
    uint64_t v25 = 4294967283;
    goto LABEL_7;
  }
  rsize_t v23 = ccecies_decrypt_gcm_plaintext_size(a1, a2, a3);
  if (!v23 || (rsize_t v24 = v23, v23 > *a9))
  {
    v26 = cc_ws_free;
    uint64_t v25 = 4294967289;
    goto LABEL_9;
  }
  uint64_t v25 = ccecies_decrypt_gcm_composite_ws((uint64_t)v31, (unint64_t **)a1, a2, a10, a5, a6, a7, a8, v23, (uint64_t)&a4[v15], a4, (uint64_t)&a4[v15 + v23]);
  v26 = v32;
  if (v25)
  {
LABEL_9:
    v26((uint64_t)v31);
    cc_clear(*a9, a10);
    goto LABEL_7;
  }
  *a9 = v24;
  v26((uint64_t)v31);
LABEL_7:
  cc_disable_dit_with_sb((unsigned int *)&v33);
  return v25;
}

uint64_t ccmode_siv_auth(uint64_t a1, unint64_t a2, char *a3)
{
  uint64_t v8 = *MEMORY[0x263EF8C08];
  if (*(void *)(*(void *)(*(void *)a1 + 56) + 8) != 16) {
    return 4294967226;
  }
  if (!a2) {
    return 0;
  }
  cccmac_sl_test_xor(a1 + 88, (char *)(a1 + 88));
  cccmac_one_shot_generate_internal(*(void **)(*(void *)a1 + 56), *(void *)(a1 + 8) >> 1, a1 + 24, a2, a3, 0x10uLL, &v7);
  uint64_t result = 0;
  *(int8x16_t *)(a1 + 88) = veorq_s8(v7, *(int8x16_t *)(a1 + 88));
  *(void *)(a1 + 16) = 4;
  return result;
}

uint64_t ccmode_siv_auth_finalize(uint64_t a1, unint64_t a2, char *a3, void *a4)
{
  uint64_t v20 = *MEMORY[0x263EF8C08];
  uint64_t v5 = *(void **)(*(void *)a1 + 56);
  if (v5[1] != 16)
  {
    uint64_t result = 4294967226;
    goto LABEL_11;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (v6 == 4 || v6 == 2)
  {
    if (a2)
    {
      if (a2 >= 0x10)
      {
        v18[1] = v18;
        MEMORY[0x270FA53B0](a1, a2, a3, a4);
        uint64_t v12 = (char *)&v18[-2 * v11];
        cccmac_init_internal(v5, (uint64_t)v12, *(void *)(a1 + 8) >> 1, a1 + 24);
        __memcpy_chk();
        *(int8x16_t *)((char *)&__s + a2 - (a2 & 0xFFFFFFFFFFFFFFF0)) = veorq_s8(*(int8x16_t *)(a1 + 88), *(int8x16_t *)&a3[a2 - 16]);
        cccmac_update_internal(v12, (a2 & 0xFFFFFFFFFFFFFFF0) - 16, a3);
        cccmac_update_internal(v12, a2 - ((a2 & 0xFFFFFFFFFFFFFFF0) - 16), __s.i8);
        cccmac_final_generate_internal(v12, 0x10uLL, a4);
        cc_clear(v5[1] + *v5 + 80, v12);
LABEL_18:
        uint64_t result = 0;
        uint64_t v14 = 5;
        goto LABEL_19;
      }
    }
    else if (v6 == 2)
    {
      cc_clear(0x10uLL, &__s);
      __s.i8[15] = 1;
      unint64_t v15 = *(void **)(*(void *)a1 + 56);
      uint64_t v16 = *(void *)(a1 + 8) >> 1;
      uint64_t v17 = a1 + 24;
LABEL_17:
      cccmac_one_shot_generate_internal(v15, v16, v17, 0x10uLL, __s.i8, 0x10uLL, a4);
      goto LABEL_18;
    }
    cccmac_sl_test_xor(a1 + 88, (char *)(a1 + 88));
    __memcpy_chk();
    __s.i8[a2] = 0x80;
    if (a2 <= 0xE) {
      bzero(&__s.i8[a2 + 1], 15 - a2);
    }
    int8x16_t __s = veorq_s8(*(int8x16_t *)(a1 + 88), __s);
    uint64_t v16 = *(void *)(a1 + 8) >> 1;
    uint64_t v17 = a1 + 24;
    unint64_t v15 = v5;
    goto LABEL_17;
  }
  uint64_t result = 4294967228;
LABEL_11:
  uint64_t v14 = 255;
LABEL_19:
  *(void *)(a1 + 16) = v14;
  return result;
}

double ccmode_factory_siv_encrypt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)&double result = 104;
  *(_OWORD *)a1 = xmmword_2373AB2A0;
  *(void *)(a1 + 16) = ccmode_siv_init;
  *(void *)(a1 + 24) = ccmode_siv_auth;
  *(void *)(a1 + 32) = ccmode_siv_auth;
  *(void *)(a1 + 40) = ccmode_siv_encrypt;
  *(void *)(a1 + 48) = ccmode_siv_reset;
  *(void *)(a1 + 56) = a2;
  *(void *)(a1 + 64) = a3;
  return result;
}

uint64_t ccec_diversify_pub_twin(uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t (**a5)(void, uint64_t, unint64_t *))
{
  BOOL v31 = timingsafe_enable_if_supported();
  uint64_t v10 = *a1;
  unint64_t v11 = 23 * *a1;
  unint64_t v12 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v13 = (v12 + 127) / v12 + 4 * v10 + 3;
  if (v11 > v13) {
    unint64_t v13 = v11;
  }
  uint64_t v14 = cc_malloc_clear(8 * (v13 + 11 * v10));
  v27[0] = v14;
  uint64_t v15 = *a1;
  unint64_t v16 = 23 * *a1;
  unint64_t v17 = sizeof_struct_ccpolyzp_po2cyc();
  uint64_t v18 = 3 * v15;
  unint64_t v19 = 4 * v15 + (v17 + 127) / v17 + 3;
  if (v16 > v19) {
    unint64_t v19 = v16;
  }
  v27[1] = v19 + 11 * v15;
  uint64_t v28 = 0;
  size_t v29 = cc_ws_alloc;
  BOOL v30 = cc_ws_free;
  if (v14)
  {
    uint64_t v20 = (char *)cc_ws_alloc(v27, v15);
    uint64_t v21 = (char *)v29(v27, v15);
    uint64_t v22 = v29(v27, 3 * v15);
    uint64_t v23 = v29(v27, 3 * v15);
    uint64_t v24 = v29(v27, v18);
    uint64_t v25 = ccec_validate_point_and_projectify_ws((uint64_t)v27, a1, v23, a2 + 16);
    if (!v25)
    {
      uint64_t v25 = ccec_projectify_ws((uint64_t)v27, (uint64_t)a1);
      if (!v25)
      {
        uint64_t v25 = ccec_diversify_twin_scalars_ws((uint64_t)v27, a1, v20, v21, a3, a4);
        if (!v25)
        {
          uint64_t v25 = ccec_mult_blinded_ws((uint64_t)v27, (unint64_t *)a1, v24, (uint64_t)v20, v23, a5);
          if (!v25)
          {
            uint64_t v25 = ccec_mult_blinded_ws((uint64_t)v27, (unint64_t *)a1, v23, (uint64_t)v21, v22, a5);
            if (!v25)
            {
              ccec_full_add_ws((uint64_t)v27, (uint64_t)a1);
              uint64_t v25 = ccec_affinify_ws((uint64_t)v27, (uint64_t)a1);
            }
          }
        }
      }
    }
    uint64_t v28 = 0;
    v30((uint64_t)v27);
  }
  else
  {
    uint64_t v25 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v31);
  return v25;
}

uint64_t ccpolyzp_po2cyc_block_rng_init(uint64_t a1)
{
  *(void *)a1 = generate;
  *(void *)(a1 + 64) = ccaes_ctr_crypt_mode();
  *(void *)(a1 + 72) = 16;
  *(_DWORD *)(a1 + 80) = 1;
  *(void *)(a1 + 88) = 0;
  ccdrbg_factory_nistctr((void *)(a1 + 8), a1 + 64);
  if (*(void *)(a1 + 8) > 0x58uLL) {
    return 0xFFFFFFFFLL;
  }
  *(void *)(a1 + 184) = 4096;

  return ccdrbg_init_internal(a1 + 8);
}

uint64_t generate(uint64_t a1, unint64_t a2, char *__dst)
{
  if (!a2) {
    return 0;
  }
  unint64_t v6 = 0;
  uint64_t v7 = a1 + 96;
  uint64_t v8 = a1 + 192;
  unint64_t v9 = *(void *)(a1 + 184);
  while (v9 + a2 - v6 > 0xFFF)
  {
    if (v9 > 0xFFF)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void))(a1 + 32))(v7, 4096, v8, 0, 0);
      unint64_t v9 = 0;
      if (result) {
        return result;
      }
    }
    else
    {
      unint64_t v10 = 4096 - v9;
      memcpy(__dst, (const void *)(v8 + v9), 4096 - v9);
      __dst += v10;
      v6 += v10;
      unint64_t v9 = *(void *)(a1 + 184) + v10;
    }
    *(void *)(a1 + 184) = v9;
    if (v6 >= a2) {
      return 0;
    }
  }
  memcpy(__dst, (const void *)(v8 + v9), a2 - v6);
  uint64_t result = 0;
  *(void *)(a1 + 184) += a2 - v6;
  return result;
}

uint64_t sizeof_struct_ccpolyzp_po2cyc_block_rng_state()
{
  return 4288;
}

uint64_t CCPOLYZP_PO2CYC_RANDOM_UNIFORM_WORKSPACE_N(unint64_t a1)
{
  uint64_t v1 = 1024;
  if (a1 < 0x400) {
    uint64_t v1 = a1;
  }
  return 2 * v1;
}

uint64_t ccpolyzp_po2cyc_random_uniform_ws(uint64_t a1, unsigned int **a2, uint64_t (**a3)(void, uint64_t, uint64_t))
{
  unsigned int v5 = **a2;
  unsigned int v4 = (*a2)[1];
  if (v5 >= 0x400) {
    unsigned int v6 = 1024;
  }
  else {
    unsigned int v6 = **a2;
  }
  uint64_t v28 = *(void *)(a1 + 16);
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 2 * v6);
  unsigned int v30 = v4;
  if (v4)
  {
    uint64_t v8 = v7;
    unsigned int v9 = 0;
    unint64_t v10 = *a2;
    do
    {
      unsigned int v11 = v10[1] - 1;
      unint64_t v12 = v10;
      if (v11 > v9)
      {
        unint64_t v12 = v10;
        do
        {
          unint64_t v12 = (unsigned int *)*((void *)v12 + 14);
          --v11;
        }
        while (v11 > v9);
      }
      if (v5)
      {
        for (unsigned int i = 0; i != v5; ++i)
        {
          if (!(i % v6))
          {
            uint64_t result = (*a3)(a3, 16 * v6, v8);
            if (result) {
              return result;
            }
            unint64_t v10 = *a2;
          }
          uint64_t v15 = (unint64_t *)(v8 + 16 * (i % v6));
          unint64_t v17 = *v15;
          unint64_t v16 = v15[1];
          unint64_t v18 = *((void *)v12 + 4);
          uint64_t v19 = (v18 * (unsigned __int128)v17) >> 64;
          uint64_t v20 = (v18 * (unsigned __int128)v16) >> 64;
          uint64_t v21 = v18 * v16;
          BOOL v22 = __CFADD__(v19, v21);
          uint64_t v23 = v19 + v21;
          uint64_t v24 = v22;
          uint64_t v25 = v24
              + __CFADD__(*((void *)v12 + 5) * v17, v23)
              + v20
              + *((void *)v12 + 5) * v16
              + ((*((unint64_t *)v12 + 5) * (unsigned __int128)v17) >> 64);
          uint64_t v26 = *((void *)v12 + 2);
          uint64_t v27 = (unsigned int *)(v17 - v25 * v26);
          if ((uint64_t)v27 - v26 >= 0) {
            uint64_t v27 = (unsigned int *)((char *)v27 - v26);
          }
          (&a2[i + 1])[v9 * *v10] = v27;
        }
      }
      ++v9;
    }
    while (v9 != v30);
  }
  uint64_t result = 0;
  *(void *)(a1 + 16) = v28;
  return result;
}

unint64_t CCPOLYZP_PO2CYC_RANDOM_TERNARY_WORKSPACE_N(unint64_t a1)
{
  uint64_t v1 = 1024;
  if (a1 < 0x400) {
    uint64_t v1 = a1;
  }
  return ((unint64_t)(96 * v1 + 63) >> 6) + 6;
}

uint64_t ccpolyzp_po2cyc_random_ternary_ws(uint64_t a1, unsigned int **a2, uint64_t (**a3)(void, uint64_t, uint64_t))
{
  uint64_t v31 = *MEMORY[0x263EF8C08];
  unsigned int v6 = **a2;
  uint64_t v7 = (*a2)[1];
  if (v6 >= 0x400) {
    uint64_t v8 = 1024;
  }
  else {
    uint64_t v8 = v6;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, (96 * (unint64_t)v8 + 63) >> 6);
  cc_clear(0x10uLL, &__dst);
  long long v27 = 0u;
  long long v28 = 0u;
  long long v26 = 0u;
  uint64_t result = ccrns_modulus_init_ws(a1, (unint64_t *)&v26, 3);
  if (!result)
  {
    if (v6)
    {
      unsigned int v12 = 0;
      while (1)
      {
        if (!(v12 % v8))
        {
          uint64_t result = (*a3)(a3, 4 * (v8 + 2 * v8), v10);
          if (result) {
            break;
          }
        }
        ccn_set(2, &__dst, (void *)(v10 + 12 * (v12 % v8)));
        uint64_t v30 = v30;
        if (v7)
        {
          unint64_t v13 = 0;
          BOOL v14 = __CFADD__(((unint64_t)v27 * (unsigned __int128)__dst) >> 64, v27 * v30);
          uint64_t v15 = __dst
              - (v14
               + __CFADD__(*((void *)&v27 + 1) * __dst, (__PAIR128__(v30, __dst) * (unint64_t)v27) >> 64)+ ((v27 * (unsigned __int128)v30) >> 64)+ ((*((unint64_t *)&v27 + 1) * (unsigned __int128)__dst) >> 64))* v26;
          if (v15 - (uint64_t)v26 >= 0) {
            uint64_t v16 = v15 - v26;
          }
          else {
            uint64_t v16 = __dst
          }
                - (v14
                 + __CFADD__(*((void *)&v27 + 1) * __dst, (__PAIR128__(v30, __dst) * (unint64_t)v27) >> 64)+ ((v27 * (unsigned __int128)v30) >> 64)+ ((*((unint64_t *)&v27 + 1) * (unsigned __int128)__dst) >> 64))* v26;
          unint64_t v17 = *a2;
          unsigned int v18 = **a2;
          unsigned int v19 = (*a2)[1];
          unint64_t v20 = v19 - 1;
          uint64_t v21 = v16 - 1;
          unsigned int v22 = v19 - 2;
          do
          {
            uint64_t v23 = v17;
            if (v13 < v20)
            {
              unsigned int v24 = v22;
              uint64_t v23 = v17;
              do
                uint64_t v23 = (unsigned int *)*((void *)v23 + 14);
              while (v13 < v24--);
            }
            (&a2[v12 + 1])[v18 * v13++] = (unsigned int *)((*((void *)v23 + 2) & (v21 >> 63)) + v21);
          }
          while (v13 != v7);
        }
        if (++v12 == v6) {
          goto LABEL_23;
        }
      }
    }
    else
    {
LABEL_23:
      uint64_t result = 0;
      *(void *)(a1 + 16) = v9;
    }
  }
  return result;
}

unint64_t CCPOLYZP_PO2CYC_RANDOM_CBD_WORKSPACE_N(unint64_t a1)
{
  uint64_t v1 = 1024;
  if (a1 < 0x400) {
    uint64_t v1 = a1;
  }
  return (unint64_t)(48 * v1 + 63) >> 6;
}

uint64_t ccpolyzp_po2cyc_random_cbd_ws(uint64_t a1, unsigned int **a2, uint64_t (**a3)(void, uint64_t, const double *), int a4)
{
  if (a4) {
    return 4294967289;
  }
  unsigned int v8 = **a2;
  uint64_t v9 = (*a2)[1];
  if (v8 >= 0x400) {
    uint64_t v10 = 1024;
  }
  else {
    uint64_t v10 = v8;
  }
  uint64_t v27 = *(void *)(a1 + 16);
  uint64_t v11 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, (48 * (unint64_t)v10 + 63) >> 6);
  if (v8)
  {
    unsigned int v12 = (const double *)v11;
    unsigned int v13 = 0;
    BOOL v14 = (const double *)v11;
    while (1)
    {
      if (!(v13 % v10))
      {
        uint64_t result = (*a3)(a3, 2 * (v10 + 2 * v10), v12);
        BOOL v14 = v12;
        if (result) {
          break;
        }
      }
      if (v9)
      {
        unint64_t v15 = 0;
        int8x16_t v16 = (int8x16_t)vld1q_dup_f64(v14);
        int64x2_t v17 = (int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(vandq_s8(v16, (int8x16_t)xmmword_2373AB2B0)))));
        unsigned int v18 = *a2;
        unsigned int v19 = **a2;
        unsigned int v20 = (*a2)[1];
        unint64_t v21 = v20 - 1;
        uint64_t v22 = vsubq_s64(v17, vdupq_laneq_s64(v17, 1)).u64[0];
        unsigned int v23 = v20 - 2;
        do
        {
          unsigned int v24 = v18;
          if (v15 < v21)
          {
            unsigned int v25 = v23;
            unsigned int v24 = v18;
            do
              unsigned int v24 = (unsigned int *)*((void *)v24 + 14);
            while (v15 < v25--);
          }
          (&a2[v13 + 1])[v19 * v15++] = (unsigned int *)((*((void *)v24 + 2) & (v22 >> 63)) + v22);
        }
        while (v15 != v9);
      }
      BOOL v14 = (const double *)((char *)v14 + 6);
      if (++v13 == v8) {
        goto LABEL_18;
      }
    }
  }
  else
  {
LABEL_18:
    uint64_t result = 0;
    *(void *)(a1 + 16) = v27;
  }
  return result;
}

uint64_t ccss_shamir_init_share_poly(uint64_t result, int *a2)
{
  int v2 = *a2;
  *(void *)uint64_t result = a2 + 2;
  *(_DWORD *)(result + 8) = v2 - 1;
  return result;
}

unint64_t ccecies_encrypt_gcm_ciphertext_size(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = ccecies_pub_key_size_cp(*a1, a2);
  if (result) {
    result += a3 + *(unsigned int *)(a2 + 28);
  }
  return result;
}

uint64_t sha1_compress(int *a1, uint64_t a2, unsigned int *a3)
{
  int v3 = a1[3];
  int v4 = a1[4];
  int v5 = a1[1];
  int v6 = a1[2];
  int v7 = *a1;
  do
  {
    int v547 = v3;
    int v548 = v5;
    int v546 = v6;
    int v543 = v4;
    uint64_t v544 = a2;
    v545 = a3;
    HIDWORD(v9) = v7;
    LODWORD(v9) = v7;
    int v8 = v9 >> 27;
    int v10 = v3 & ~v5;
    unsigned int v11 = bswap32(*a3);
    int v12 = v6 & v548;
    HIDWORD(v9) = v548;
    LODWORD(v9) = v548;
    int v13 = v9 >> 2;
    int v14 = v12 | v10;
    unsigned int v15 = bswap32(a3[1]);
    unsigned int v16 = v4 + 1518500249 + v8 + v14 + v11;
    HIDWORD(v9) = v16;
    LODWORD(v9) = v16;
    int v17 = v9 >> 27;
    HIDWORD(v9) = v7;
    LODWORD(v9) = v7;
    int v18 = v9 >> 2;
    int v542 = v7;
    int v19 = v16 & __ROR4__(v7, 2);
    unsigned int v20 = v547 + 1518500249 + (v7 & __ROR4__(v548, 2) | v546 & ~v7) + v15 + v17;
    HIDWORD(v9) = v20;
    LODWORD(v9) = v20;
    int v21 = v9 >> 27;
    HIDWORD(v9) = v16;
    LODWORD(v9) = v16;
    int v22 = v9 >> 2;
    unsigned int v23 = bswap32(a3[2]);
    unsigned int v24 = bswap32(a3[3]);
    unint64_t v26 = __PAIR64__(v20, __ROR4__(v16, 2));
    int v25 = v20 & v26;
    LODWORD(v26) = v20;
    int v27 = v26 >> 2;
    unsigned int v28 = v546 + 1518500249 + v23 + (v19 | v13 & ~v16) + v21;
    HIDWORD(v26) = v28;
    LODWORD(v26) = v28;
    int v29 = v26 >> 27;
    unint64_t v31 = __PAIR64__(v28, __ROR4__(v20, 2));
    int v30 = v28 & v31;
    unsigned int v539 = bswap32(a3[4]);
    LODWORD(v31) = v28;
    int v32 = v31 >> 2;
    unsigned int v33 = v13 + 1518500249 + v24 + (v25 | v18 & ~v20) + v29;
    HIDWORD(v31) = v33;
    LODWORD(v31) = v33;
    unsigned int v34 = v18 + 1518500249 + v539 + (v30 | v22 & ~v28) + (v31 >> 27);
    HIDWORD(v31) = v34;
    LODWORD(v31) = v34;
    int v35 = v31 >> 27;
    unint64_t v37 = __PAIR64__(v33, __ROR4__(v28, 2));
    int v36 = v33 & v37;
    LODWORD(v37) = v33;
    int v38 = v37 >> 2;
    unint64_t v40 = __PAIR64__(v34, __ROR4__(v33, 2));
    int v39 = v34 & v40;
    unsigned int v41 = bswap32(a3[5]);
    int v42 = v36 | v27 & ~v33;
    LODWORD(v40) = v34;
    int v43 = v40 >> 2;
    int v44 = v22 + 1518500249 + v41 + v42 + v35;
    HIDWORD(v40) = v44;
    LODWORD(v40) = v44;
    int v45 = v40 >> 27;
    unsigned int v529 = bswap32(a3[6]);
    HIDWORD(v40) = v44;
    LODWORD(v40) = v44;
    int v46 = v40 >> 2;
    unsigned int v47 = v27 + 1518500249 + v529 + (v39 | v32 & ~v34) + v45;
    HIDWORD(v40) = v47;
    LODWORD(v40) = v47;
    int v48 = v40 >> 27;
    unint64_t v49 = __PAIR64__(v47, __ROR4__(v34, 2));
    unsigned int v535 = bswap32(a3[7]);
    int v50 = v44 & v49 | v38 & ~v44;
    LODWORD(v49) = v47;
    int v51 = v49 >> 2;
    unsigned int v52 = v32 + 1518500249 + v535 + v50 + v48;
    HIDWORD(v49) = v52;
    LODWORD(v49) = v52;
    int v53 = v49 >> 27;
    unint64_t v55 = __PAIR64__(v52, __ROR4__(v47, 2));
    int v54 = v52 & v55;
    LODWORD(v55) = v52;
    int v56 = v55 >> 2;
    unsigned int v57 = bswap32(a3[8]);
    unsigned int v58 = v38 + 1518500249 + v57 + (v47 & __ROR4__(v44, 2) | v43 & ~v47) + v53;
    unsigned int v59 = bswap32(a3[13]);
    HIDWORD(v55) = v58;
    LODWORD(v55) = v58;
    int v60 = v55 >> 27;
    HIDWORD(v55) = v23 ^ v11 ^ v57 ^ v59;
    LODWORD(v55) = HIDWORD(v55);
    int v61 = v55 >> 31;
    int v62 = HIDWORD(v55);
    int v517 = HIDWORD(v55);
    unint64_t v64 = __PAIR64__(v58, __ROR4__(v52, 2));
    int v63 = v58 & v64;
    unsigned int v65 = bswap32(a3[9]);
    int v66 = v54 | v46 & ~v52;
    LODWORD(v64) = v58;
    int v67 = v64 >> 2;
    int v68 = v43 + 1518500249 + v65 + v66 + v60;
    HIDWORD(v64) = v68;
    LODWORD(v64) = v68;
    int v69 = v64 >> 27;
    unsigned int v70 = bswap32(a3[10]);
    HIDWORD(v64) = v68;
    LODWORD(v64) = v68;
    int v71 = v64 >> 2;
    unsigned int v72 = v46 + 1518500249 + v70 + (v63 | v51 & ~v58) + v69;
    HIDWORD(v64) = v72;
    LODWORD(v64) = v72;
    int v73 = v64 >> 27;
    unint64_t v74 = __PAIR64__(v72, __ROR4__(v58, 2));
    unsigned int v75 = bswap32(a3[11]);
    int v76 = v68 & v74 | v56 & ~v68;
    LODWORD(v74) = v72;
    int v77 = v74 >> 2;
    unsigned int v78 = v51 + 1518500249 + v75 + v76 + v73;
    HIDWORD(v74) = v78;
    LODWORD(v74) = v78;
    int v79 = v74 >> 27;
    unint64_t v80 = __PAIR64__(v78, __ROR4__(v68, 2));
    int v81 = v72 & v80 | v67 & ~v72;
    LODWORD(v80) = v78;
    int v82 = v80 >> 2;
    unsigned int v523 = bswap32(a3[12]);
    unsigned int v83 = v56 + 1518500249 + v523 + v81 + v79;
    HIDWORD(v80) = v83;
    LODWORD(v80) = v83;
    int v84 = v80 >> 27;
    int v85 = v78 & __ROR4__(v72, 2);
    unsigned int v86 = a3[15];
    unsigned int v87 = bswap32(a3[14]);
    int v88 = v71 & ~v78;
    unint64_t v90 = __PAIR64__(v83, __ROR4__(v78, 2));
    int v89 = v83 & v90;
    int v91 = v67 + 1518500249 + v59 + (v85 | v88);
    LODWORD(v90) = v83;
    int v92 = v90 >> 2;
    int v93 = v91 + v84;
    int v94 = v24 ^ v15 ^ v65 ^ v87;
    HIDWORD(v90) = v93;
    LODWORD(v90) = v93;
    int v95 = v90 >> 27;
    HIDWORD(v90) = v94;
    LODWORD(v90) = v94;
    int v96 = v94;
    int v518 = v94;
    int v526 = v90 >> 31;
    HIDWORD(v90) = v93;
    LODWORD(v90) = v93;
    int v97 = v90 >> 2;
    int v98 = v71 + 1518500249 + v87 + (v89 | v77 & ~v83) + v95;
    HIDWORD(v90) = v98;
    LODWORD(v90) = v98;
    int v99 = v90 >> 27;
    unsigned int v100 = bswap32(v86);
    int v101 = v539 ^ v23 ^ v70 ^ v100;
    unint64_t v103 = __PAIR64__(v101, __ROR4__(v93, 2));
    int v102 = v98 & v103;
    LODWORD(v103) = v101;
    int v520 = v103 >> 31;
    int v104 = v93 & __ROR4__(v83, 2) | v82 & ~v93;
    HIDWORD(v103) = v98;
    LODWORD(v103) = v98;
    int v105 = v103 >> 2;
    unsigned int v106 = v77 + 1518500249 + v100 + v104 + v99;
    HIDWORD(v103) = v106;
    LODWORD(v103) = v106;
    int v107 = v103 >> 27;
    unint64_t v109 = __PAIR64__(v106, __ROR4__(v98, 2));
    int v108 = v106 & v109;
    LODWORD(v109) = v106;
    int v110 = v109 >> 2;
    unsigned int v111 = v82 + v61 + 1518500249 + (v102 | v92 & ~v98) + v107;
    HIDWORD(v109) = v111;
    LODWORD(v109) = v111;
    int v112 = v109 >> 27;
    LODWORD(v109) = v41 ^ v24 ^ v75 ^ __ROR4__(v62, 31);
    int v113 = v109;
    HIDWORD(v109) = v109;
    int v114 = v109 >> 31;
    int v115 = v111 & __ROR4__(v106, 2);
    unint64_t v117 = __PAIR64__(v111, __ROR4__(v96, 31));
    int v116 = v529 ^ v539 ^ v523 ^ v117;
    LODWORD(v117) = v111;
    int v118 = v117 >> 2;
    unsigned int v119 = v92 + v526 + 1518500249 + (v108 | v97 & ~v106) + v112;
    HIDWORD(v117) = v119;
    LODWORD(v117) = v119;
    int v120 = v117 >> 27;
    HIDWORD(v117) = v116;
    LODWORD(v117) = v116;
    int v532 = v117 >> 31;
    int v121 = v535 ^ v41 ^ v59 ^ __ROR4__(v101, 31);
    unint64_t v123 = __PAIR64__(v119, __ROR4__(v111, 2));
    int v122 = v119 & v123;
    LODWORD(v123) = v119;
    int v124 = v123 >> 2;
    int v125 = v97 + v520 + 1518500249 + (v115 | v105 & ~v111) + v120;
    int v126 = v122 | v110 & ~v119;
    HIDWORD(v123) = v125;
    LODWORD(v123) = v125;
    int v127 = v123 >> 27;
    HIDWORD(v123) = v121;
    LODWORD(v123) = v121;
    int v519 = v123 >> 31;
    int v128 = v114 + 1518500249 + v105;
    HIDWORD(v123) = v125;
    LODWORD(v123) = v125;
    int v129 = v123 >> 2;
    int v130 = v128 + v126 + v127;
    HIDWORD(v123) = v130;
    LODWORD(v123) = v130;
    int v131 = v123 >> 27;
    unsigned int v132 = v57;
    int v133 = v57 ^ v529 ^ v87;
    HIDWORD(v123) = v130;
    LODWORD(v123) = v130;
    int v134 = v123 >> 2;
    LODWORD(v123) = v133 ^ __ROR4__(v113, 31);
    int v135 = v123;
    HIDWORD(v123) = v123;
    int v136 = v123 >> 31;
    int v137 = v134 ^ __ROR4__(v125, 2);
    unsigned int v138 = v532 + 1859775393 + v110 + (v124 ^ __ROR4__(v111, 2) ^ v125) + v131;
    HIDWORD(v123) = v138;
    LODWORD(v123) = v138;
    int v139 = v123 >> 27;
    unint64_t v141 = __PAIR64__(v138, __ROR4__(v116, 31));
    int v140 = v65 ^ v535 ^ v100 ^ v141;
    LODWORD(v141) = v138;
    int v142 = v141 >> 2;
    unsigned int v143 = v519 + 1859775393 + v118 + (v129 ^ __ROR4__(v119, 2) ^ v130) + v139;
    HIDWORD(v141) = v140;
    LODWORD(v141) = v140;
    int v536 = v141 >> 31;
    unint64_t v145 = __PAIR64__(v143, __ROR4__(v130, 2));
    int v144 = v142 ^ v145;
    int v146 = v136 + 1859775393 + v124 + (v137 ^ v138);
    LODWORD(v145) = v143;
    int v147 = v145 >> 27;
    HIDWORD(v145) = v143;
    LODWORD(v145) = v143;
    int v148 = v145 >> 2;
    unsigned int v150 = v146 + v147;
    LODWORD(v145) = v70 ^ v132 ^ __ROR4__(v517, 31) ^ __ROR4__(v121, 31);
    int v149 = v145;
    HIDWORD(v145) = v145;
    int v521 = v145 >> 31;
    int v151 = v536 + 1859775393 + v129 + (v144 ^ v143);
    HIDWORD(v145) = v150;
    LODWORD(v145) = v150;
    int v152 = v145 >> 27;
    unint64_t v154 = __PAIR64__(v150, __ROR4__(v138, 2));
    int v153 = v148 ^ v154;
    unsigned int v155 = v151 + v152;
    int v156 = v521 + 1859775393 + v134;
    LODWORD(v154) = v150;
    int v157 = v154 >> 2;
    unint64_t v159 = __PAIR64__(v155, __ROR4__(v518, 31));
    int v158 = v75 ^ v65 ^ v159;
    LODWORD(v159) = v155;
    int v160 = v156 + (v153 ^ v150) + (v159 >> 27);
    LODWORD(v159) = v158 ^ __ROR4__(v135, 31);
    int v161 = v159;
    HIDWORD(v159) = v159;
    int v162 = v159 >> 31;
    unint64_t v163 = __PAIR64__(v155, __ROR4__(v143, 2));
    int v164 = v157 ^ v163 ^ v155;
    int v165 = v162 + 1859775393 + v142;
    LODWORD(v163) = v155;
    int v166 = v163 >> 2;
    LODWORD(v163) = v523 ^ v70 ^ __ROR4__(v101, 31) ^ __ROR4__(v140, 31);
    int v167 = v163;
    HIDWORD(v163) = v163;
    int v540 = v163 >> 31;
    HIDWORD(v163) = v160;
    LODWORD(v163) = v160;
    unsigned int v168 = v165 + v164 + (v163 >> 27);
    unint64_t v170 = __PAIR64__(v168, __ROR4__(v150, 2));
    int v169 = v166 ^ v170;
    LODWORD(v170) = v168;
    unsigned int v172 = v540 + 1859775393 + v148 + (v169 ^ v160) + (v170 >> 27);
    LODWORD(v170) = v59 ^ v75 ^ __ROR4__(v113, 31) ^ __ROR4__(v149, 31);
    int v171 = v170;
    HIDWORD(v170) = v170;
    int v173 = v170 >> 31;
    HIDWORD(v170) = v160;
    LODWORD(v170) = v160;
    int v174 = v170 >> 2;
    unint64_t v175 = __PAIR64__(v172, __ROR4__(v155, 2));
    int v176 = v173 + 1859775393 + v157 + (v174 ^ v175 ^ v168);
    LODWORD(v175) = v172;
    unsigned int v177 = v176 + (v175 >> 27);
    LODWORD(v175) = v87 ^ v523 ^ __ROR4__(v116, 31) ^ __ROR4__(v161, 31);
    int v178 = v175;
    HIDWORD(v175) = v175;
    int v179 = (v175 >> 31) + 1859775393 + v166;
    HIDWORD(v175) = v168;
    LODWORD(v175) = v168;
    int v180 = v175 >> 2;
    unint64_t v181 = __PAIR64__(v177, __ROR4__(v160, 2));
    int v182 = v179 + (v180 ^ v181 ^ v172);
    LODWORD(v181) = v177;
    int v183 = v100 ^ v59 ^ __ROR4__(v121, 31) ^ __ROR4__(v167, 31);
    unsigned int v184 = v182 + (v181 >> 27);
    HIDWORD(v181) = v183;
    LODWORD(v181) = v183;
    int v530 = v181 >> 31;
    int v185 = v530 + 1859775393 + v174;
    HIDWORD(v181) = v172;
    LODWORD(v181) = v172;
    int v186 = v181 >> 2;
    unint64_t v187 = __PAIR64__(v184, __ROR4__(v168, 2));
    int v188 = v185 + (v186 ^ v187 ^ v177);
    LODWORD(v187) = v184;
    unsigned int v189 = v188 + (v187 >> 27);
    int v190 = v87 ^ __ROR4__(v517, 31) ^ __ROR4__(v135, 31) ^ __ROR4__(v171, 31);
    HIDWORD(v187) = v190;
    LODWORD(v187) = v190;
    int v191 = v187 >> 31;
    HIDWORD(v187) = v177;
    LODWORD(v187) = v177;
    int v192 = v187 >> 2;
    int v193 = v191 + 1859775393 + v180 + (v192 ^ __ROR4__(v172, 2) ^ v184);
    unint64_t v195 = __PAIR64__(v189, __ROR4__(v518, 31));
    int v194 = v100 ^ v195;
    LODWORD(v195) = v189;
    int v196 = v194 ^ __ROR4__(v140, 31) ^ __ROR4__(v178, 31);
    unsigned int v197 = v193 + (v195 >> 27);
    HIDWORD(v195) = v196;
    LODWORD(v195) = v196;
    int v198 = (v195 >> 31) + 1859775393 + v186;
    HIDWORD(v195) = v184;
    LODWORD(v195) = v184;
    int v199 = v195 >> 2;
    unint64_t v200 = __PAIR64__(v197, __ROR4__(v177, 2));
    int v201 = v198 + (v199 ^ v200 ^ v189);
    LODWORD(v200) = v197;
    unsigned int v202 = v201 + (v200 >> 27);
    LODWORD(v200) = v520 ^ __ROR4__(v517, 31) ^ __ROR4__(v149, 31) ^ __ROR4__(v183, 31);
    int v203 = v200;
    HIDWORD(v200) = v200;
    int v524 = v200 >> 31;
    HIDWORD(v200) = v189;
    LODWORD(v200) = v189;
    int v204 = v200 >> 2;
    unint64_t v205 = __PAIR64__(v202, __ROR4__(v184, 2));
    int v206 = v524 + 1859775393 + v192 + (v204 ^ v205 ^ v197);
    LODWORD(v205) = v202;
    int v207 = v526 ^ __ROR4__(v113, 31) ^ __ROR4__(v161, 31) ^ __ROR4__(v190, 31);
    unsigned int v208 = v206 + (v205 >> 27);
    HIDWORD(v205) = v207;
    LODWORD(v205) = v207;
    int v209 = v205 >> 31;
    HIDWORD(v205) = v197;
    LODWORD(v205) = v197;
    int v210 = v205 >> 2;
    unint64_t v211 = __PAIR64__(v208, __ROR4__(v189, 2));
    int v212 = v209 + 1859775393 + v199 + (v210 ^ v211 ^ v202);
    LODWORD(v211) = v208;
    unsigned int v213 = v212 + (v211 >> 27);
    LODWORD(v211) = v520 ^ __ROR4__(v116, 31) ^ __ROR4__(v167, 31) ^ __ROR4__(v196, 31);
    int v214 = v211;
    HIDWORD(v211) = v211;
    int v215 = (v211 >> 31) + 1859775393 + v204;
    HIDWORD(v211) = v202;
    LODWORD(v211) = v202;
    int v216 = v211 >> 2;
    unint64_t v217 = __PAIR64__(v213, __ROR4__(v197, 2));
    int v218 = v215 + (v216 ^ v217 ^ v208);
    LODWORD(v217) = v213;
    int v219 = v519 ^ __ROR4__(v113, 31) ^ __ROR4__(v171, 31) ^ __ROR4__(v203, 31);
    unsigned int v220 = v218 + (v217 >> 27);
    HIDWORD(v217) = v219;
    LODWORD(v217) = v219;
    int v527 = v217 >> 31;
    int v221 = v527 + 1859775393 + v210;
    HIDWORD(v217) = v208;
    LODWORD(v217) = v208;
    int v222 = v217 >> 2;
    unint64_t v223 = __PAIR64__(v220, __ROR4__(v202, 2));
    int v224 = v221 + (v222 ^ v223 ^ v213);
    LODWORD(v223) = v220;
    unsigned int v225 = v224 + (v223 >> 27);
    int v226 = v532 ^ __ROR4__(v135, 31) ^ __ROR4__(v178, 31) ^ __ROR4__(v207, 31);
    HIDWORD(v223) = v226;
    LODWORD(v223) = v226;
    int v227 = v223 >> 31;
    HIDWORD(v223) = v213;
    LODWORD(v223) = v213;
    int v228 = v223 >> 2;
    int v229 = v227 + 1859775393 + v216 + (v228 ^ __ROR4__(v208, 2) ^ v220);
    unint64_t v231 = __PAIR64__(v225, __ROR4__(v140, 31));
    int v230 = v519 ^ v231;
    LODWORD(v231) = v225;
    int v232 = v231 >> 27;
    int v234 = v229 + v232;
    LODWORD(v231) = v230 ^ __ROR4__(v183, 31) ^ __ROR4__(v214, 31);
    int v233 = v231;
    HIDWORD(v231) = v231;
    int v235 = (v231 >> 31) + 1859775393 + v222;
    HIDWORD(v231) = v220;
    LODWORD(v231) = v220;
    int v236 = v231 >> 2;
    unint64_t v237 = __PAIR64__(v229 + v232, __ROR4__(v213, 2));
    int v238 = v235 + (v236 ^ v237 ^ v225);
    LODWORD(v237) = v229 + v232;
    unsigned int v239 = v238 + (v237 >> 27);
    LODWORD(v237) = v521 ^ __ROR4__(v135, 31) ^ __ROR4__(v190, 31) ^ __ROR4__(v219, 31);
    int v240 = v237;
    HIDWORD(v237) = v237;
    int v533 = v237 >> 31;
    HIDWORD(v237) = v225;
    LODWORD(v237) = v225;
    int v241 = v237 >> 2;
    unint64_t v242 = __PAIR64__(v239, __ROR4__(v220, 2));
    int v243 = v533 + 1859775393 + v228 + (v241 ^ v242 ^ v234);
    LODWORD(v242) = v239;
    unsigned int v245 = v243 + (v242 >> 27);
    LODWORD(v242) = v536 ^ __ROR4__(v161, 31) ^ __ROR4__(v196, 31) ^ __ROR4__(v226, 31);
    int v244 = v242;
    HIDWORD(v242) = v242;
    int v246 = v242 >> 31;
    HIDWORD(v242) = v234;
    LODWORD(v242) = v234;
    int v247 = v242 >> 2;
    unint64_t v248 = __PAIR64__(v245, __ROR4__(v225, 2));
    int v249 = v246 + 1859775393 + v236 + (v247 ^ v248 ^ v239);
    LODWORD(v248) = v245;
    unsigned int v250 = v249 + (v248 >> 27);
    int v251 = v521 ^ __ROR4__(v167, 31) ^ __ROR4__(v203, 31) ^ __ROR4__(v233, 31);
    unint64_t v252 = __PAIR64__(v251, __ROR4__(v239, 2));
    int v253 = (v245 | __ROR4__(v239, 2)) & __ROR4__(v234, 2) | v245 & v252;
    LODWORD(v252) = v251;
    int v254 = (v252 >> 31) - 1894007588;
    HIDWORD(v252) = v239;
    LODWORD(v252) = v239;
    int v255 = v252 >> 2;
    int v256 = v254 + v241;
    unint64_t v258 = __PAIR64__(v250, __ROR4__(v207, 31));
    int v257 = v173 ^ __ROR4__(v161, 31) ^ v258;
    LODWORD(v258) = v250;
    int v259 = v258 >> 27;
    int v260 = v257 ^ __ROR4__(v240, 31);
    unint64_t v262 = __PAIR64__(v260, __ROR4__(v239, 2));
    int v261 = (v250 | __ROR4__(v245, 2)) & v262;
    LODWORD(v262) = v260;
    int v537 = v262 >> 31;
    unsigned int v263 = v256 + v253 + v259;
    unint64_t v264 = __PAIR64__(v263, __ROR4__(v245, 2));
    int v265 = v261 | v250 & v264;
    LODWORD(v264) = v263;
    int v266 = v537 - 1894007588 + v247 + v265;
    int v267 = v540 ^ __ROR4__(v178, 31) ^ __ROR4__(v214, 31) ^ __ROR4__(v244, 31);
    int v268 = v266 + (v264 >> 27);
    unint64_t v269 = __PAIR64__(v267, __ROR4__(v245, 2));
    int v270 = (v263 | __ROR4__(v250, 2)) & v269 | v263 & __ROR4__(v250, 2);
    LODWORD(v269) = v267;
    int v271 = v269 >> 31;
    HIDWORD(v269) = v245;
    LODWORD(v269) = v245;
    int v272 = v269 >> 2;
    HIDWORD(v269) = v268;
    LODWORD(v269) = v268;
    int v273 = v271 - 1894007588 + v255 + v270 + (v269 >> 27);
    int v274 = v173 ^ __ROR4__(v183, 31) ^ __ROR4__(v219, 31) ^ __ROR4__(v251, 31);
    unint64_t v275 = __PAIR64__(v274, __ROR4__(v250, 2));
    int v276 = (v268 | __ROR4__(v263, 2)) & v275 | v268 & __ROR4__(v263, 2);
    LODWORD(v275) = v274;
    int v277 = v275 >> 31;
    HIDWORD(v275) = v250;
    LODWORD(v275) = v250;
    int v278 = v275 >> 2;
    int v279 = v277 - 1894007588 + v272;
    HIDWORD(v275) = v273;
    LODWORD(v275) = v273;
    int v280 = v275 >> 27;
    LODWORD(v275) = v191 ^ __ROR4__(v178, 31) ^ __ROR4__(v226, 31) ^ __ROR4__(v260, 31);
    int v281 = v275;
    HIDWORD(v275) = v275;
    int v541 = v275 >> 31;
    int v282 = v279 + v276 + v280;
    unint64_t v283 = __PAIR64__(v263, __ROR4__(v263, 2));
    int v284 = (v273 | __ROR4__(v268, 2)) & v283 | v273 & __ROR4__(v268, 2);
    LODWORD(v283) = v263;
    int v285 = v283 >> 2;
    HIDWORD(v283) = v282;
    LODWORD(v283) = v282;
    int v286 = v541 - 1894007588 + v278 + v284 + (v283 >> 27);
    int v287 = v530 ^ __ROR4__(v196, 31) ^ __ROR4__(v233, 31) ^ __ROR4__(v267, 31);
    unint64_t v288 = __PAIR64__(v287, __ROR4__(v268, 2));
    int v289 = (v282 | __ROR4__(v273, 2)) & v288 | v282 & __ROR4__(v273, 2);
    LODWORD(v288) = v287;
    int v522 = v288 >> 31;
    HIDWORD(v288) = v268;
    LODWORD(v288) = v268;
    int v290 = v288 >> 2;
    HIDWORD(v288) = v286;
    LODWORD(v288) = v286;
    unsigned int v291 = v522 - 1894007588 + v285 + v289 + (v288 >> 27);
    HIDWORD(v288) = v273;
    LODWORD(v288) = v273;
    int v292 = v288 >> 2;
    int v293 = v191 ^ __ROR4__(v203, 31) ^ __ROR4__(v240, 31) ^ __ROR4__(v274, 31);
    unint64_t v294 = __PAIR64__(v293, __ROR4__(v282, 2));
    int v295 = (v286 | __ROR4__(v282, 2)) & __ROR4__(v273, 2) | v286 & v294;
    LODWORD(v294) = v293;
    int v296 = (v294 >> 31) - 1894007588;
    HIDWORD(v294) = v282;
    LODWORD(v294) = v282;
    int v297 = v294 >> 2;
    int v298 = v296 + v290;
    unint64_t v300 = __PAIR64__(v291, __ROR4__(v244, 31));
    int v299 = v209 ^ __ROR4__(v196, 31) ^ v300;
    LODWORD(v300) = v291;
    int v301 = v300 >> 27;
    int v302 = v298 + v295;
    int v303 = v299 ^ __ROR4__(v281, 31);
    unint64_t v305 = __PAIR64__(v303, __ROR4__(v282, 2));
    int v304 = (v291 | __ROR4__(v286, 2)) & v305;
    LODWORD(v305) = v303;
    int v531 = v305 >> 31;
    unsigned int v306 = v302 + v301;
    unint64_t v307 = __PAIR64__(v302 + v301, __ROR4__(v286, 2));
    int v308 = v304 | v291 & v307;
    LODWORD(v307) = v306;
    int v309 = v524 ^ __ROR4__(v214, 31) ^ __ROR4__(v251, 31) ^ __ROR4__(v287, 31);
    int v310 = v531 - 1894007588 + v292 + v308 + (v307 >> 27);
    unint64_t v311 = __PAIR64__(v309, __ROR4__(v286, 2));
    int v312 = (v306 | __ROR4__(v291, 2)) & v311 | v306 & __ROR4__(v291, 2);
    LODWORD(v311) = v309;
    int v313 = v311 >> 31;
    int v314 = v313 - 1894007588 + v297;
    HIDWORD(v311) = v286;
    LODWORD(v311) = v286;
    int v315 = v311 >> 2;
    HIDWORD(v311) = v310;
    LODWORD(v311) = v310;
    int v316 = v314 + v312 + (v311 >> 27);
    int v317 = v209 ^ __ROR4__(v219, 31) ^ __ROR4__(v260, 31) ^ __ROR4__(v293, 31);
    unint64_t v318 = __PAIR64__(v317, __ROR4__(v291, 2));
    int v319 = (v310 | __ROR4__(v306, 2)) & v318 | v310 & __ROR4__(v306, 2);
    LODWORD(v318) = v317;
    int v320 = v318 >> 31;
    HIDWORD(v318) = v291;
    LODWORD(v318) = v291;
    int v321 = v318 >> 2;
    int v322 = v320 - 1894007588 + v315;
    HIDWORD(v318) = v316;
    LODWORD(v318) = v316;
    int v323 = v318 >> 27;
    int v324 = v227;
    LODWORD(v318) = v227 ^ __ROR4__(v214, 31) ^ __ROR4__(v267, 31) ^ __ROR4__(v303, 31);
    int v325 = v318;
    HIDWORD(v318) = v318;
    int v525 = v318 >> 31;
    int v326 = v322 + v319 + v323;
    unint64_t v327 = __PAIR64__(v306, __ROR4__(v306, 2));
    int v328 = (v316 | __ROR4__(v310, 2)) & v327 | v316 & __ROR4__(v310, 2);
    LODWORD(v327) = v306;
    int v329 = v327 >> 2;
    HIDWORD(v327) = v326;
    LODWORD(v327) = v326;
    int v330 = v525 - 1894007588 + v321 + v328 + (v327 >> 27);
    int v331 = v527 ^ __ROR4__(v233, 31) ^ __ROR4__(v274, 31) ^ __ROR4__(v309, 31);
    unint64_t v332 = __PAIR64__(v331, __ROR4__(v310, 2));
    int v333 = (v326 | __ROR4__(v316, 2)) & v332 | v326 & __ROR4__(v316, 2);
    LODWORD(v332) = v331;
    int v334 = v332 >> 31;
    HIDWORD(v332) = v310;
    LODWORD(v332) = v310;
    int v335 = v332 >> 2;
    HIDWORD(v332) = v330;
    LODWORD(v332) = v330;
    unsigned int v336 = v334 - 1894007588 + v329 + v333 + (v332 >> 27);
    HIDWORD(v332) = v316;
    LODWORD(v332) = v316;
    int v337 = v332 >> 2;
    int v338 = v324 ^ __ROR4__(v240, 31) ^ __ROR4__(v281, 31) ^ __ROR4__(v317, 31);
    unint64_t v339 = __PAIR64__(v338, __ROR4__(v326, 2));
    int v340 = (v330 | __ROR4__(v326, 2)) & __ROR4__(v316, 2) | v330 & v339;
    LODWORD(v339) = v338;
    int v341 = (v339 >> 31) - 1894007588;
    HIDWORD(v339) = v326;
    LODWORD(v339) = v326;
    int v342 = v339 >> 2;
    int v343 = v341 + v335;
    unint64_t v345 = __PAIR64__(v336, __ROR4__(v287, 31));
    int v344 = v246 ^ __ROR4__(v233, 31) ^ v345;
    LODWORD(v345) = v336;
    int v346 = v345 >> 27;
    int v347 = v344 ^ __ROR4__(v325, 31);
    unint64_t v349 = __PAIR64__(v347, __ROR4__(v326, 2));
    int v348 = (v336 | __ROR4__(v330, 2)) & v349;
    LODWORD(v349) = v347;
    int v528 = v349 >> 31;
    unsigned int v350 = v343 + v340 + v346;
    unint64_t v351 = __PAIR64__(v350, __ROR4__(v330, 2));
    int v352 = v348 | v336 & v351;
    LODWORD(v351) = v350;
    int v353 = v533 ^ __ROR4__(v251, 31) ^ __ROR4__(v293, 31) ^ __ROR4__(v331, 31);
    int v354 = v528 - 1894007588 + v337 + v352 + (v351 >> 27);
    unint64_t v355 = __PAIR64__(v353, __ROR4__(v330, 2));
    int v356 = (v350 | __ROR4__(v336, 2)) & v355 | v350 & __ROR4__(v336, 2);
    LODWORD(v355) = v353;
    int v357 = v355 >> 31;
    HIDWORD(v355) = v330;
    LODWORD(v355) = v330;
    int v358 = v355 >> 2;
    HIDWORD(v355) = v354;
    LODWORD(v355) = v354;
    int v359 = v357 - 1894007588 + v342 + v356 + (v355 >> 27);
    int v360 = v246 ^ __ROR4__(v260, 31) ^ __ROR4__(v303, 31) ^ __ROR4__(v338, 31);
    unint64_t v361 = __PAIR64__(v360, __ROR4__(v336, 2));
    int v362 = (v354 | __ROR4__(v350, 2)) & v361 | v354 & __ROR4__(v350, 2);
    LODWORD(v361) = v360;
    int v363 = v361 >> 31;
    HIDWORD(v361) = v336;
    LODWORD(v361) = v336;
    int v364 = v361 >> 2;
    int v365 = v363 - 1894007588 + v358;
    HIDWORD(v361) = v359;
    LODWORD(v361) = v359;
    int v366 = v361 >> 27;
    LODWORD(v361) = v271 ^ __ROR4__(v251, 31) ^ __ROR4__(v309, 31) ^ __ROR4__(v347, 31);
    int v367 = v361;
    HIDWORD(v361) = v361;
    int v534 = v361 >> 31;
    int v368 = v365 + v362 + v366;
    unint64_t v369 = __PAIR64__(v350, __ROR4__(v350, 2));
    int v370 = (v359 | __ROR4__(v354, 2)) & v369 | v359 & __ROR4__(v354, 2);
    LODWORD(v369) = v350;
    int v371 = v369 >> 2;
    HIDWORD(v369) = v368;
    LODWORD(v369) = v368;
    int v372 = v534 - 1894007588 + v364 + v370 + (v369 >> 27);
    int v373 = v537 ^ __ROR4__(v274, 31) ^ __ROR4__(v317, 31) ^ __ROR4__(v353, 31);
    unint64_t v374 = __PAIR64__(v373, __ROR4__(v354, 2));
    int v375 = (v368 | __ROR4__(v359, 2)) & v374 | v368 & __ROR4__(v359, 2);
    LODWORD(v374) = v373;
    int v376 = v374 >> 31;
    HIDWORD(v374) = v354;
    LODWORD(v374) = v354;
    int v377 = v374 >> 2;
    HIDWORD(v374) = v372;
    LODWORD(v374) = v372;
    unsigned int v378 = v376 - 1894007588 + v371 + v375 + (v374 >> 27);
    HIDWORD(v374) = v359;
    LODWORD(v374) = v359;
    int v379 = v374 >> 2;
    int v380 = v271 ^ __ROR4__(v281, 31) ^ __ROR4__(v325, 31) ^ __ROR4__(v360, 31);
    unint64_t v381 = __PAIR64__(v380, __ROR4__(v368, 2));
    int v382 = (v372 | __ROR4__(v368, 2)) & __ROR4__(v359, 2) | v372 & v381;
    LODWORD(v381) = v380;
    int v383 = (v381 >> 31) - 1894007588;
    HIDWORD(v381) = v368;
    LODWORD(v381) = v368;
    int v384 = v381 >> 2;
    unint64_t v386 = __PAIR64__(v378, __ROR4__(v331, 31));
    int v385 = v522 ^ __ROR4__(v274, 31) ^ v386;
    LODWORD(v386) = v378;
    int v387 = v386 >> 27;
    int v388 = v385 ^ __ROR4__(v367, 31);
    unint64_t v390 = __PAIR64__(v388, __ROR4__(v368, 2));
    int v389 = (v378 | __ROR4__(v372, 2)) & v390;
    LODWORD(v390) = v388;
    int v538 = v390 >> 31;
    int v391 = v383 + v377 + v382 + v387;
    LODWORD(v390) = v541 ^ __ROR4__(v293, 31) ^ __ROR4__(v338, 31) ^ __ROR4__(v373, 31);
    int v392 = v390;
    HIDWORD(v390) = v390;
    int v393 = v390 >> 31;
    HIDWORD(v390) = v391;
    LODWORD(v390) = v391;
    unsigned int v394 = v538 - 1894007588 + v379 + (v389 | v378 & __ROR4__(v372, 2)) + (v390 >> 27);
    HIDWORD(v390) = v378;
    LODWORD(v390) = v378;
    int v395 = v390 >> 2;
    unint64_t v397 = __PAIR64__(v394, __ROR4__(v303, 31));
    int v396 = v522 ^ v397;
    LODWORD(v397) = v394;
    unsigned int v398 = v393 - 899497514 + v384 + (v395 ^ __ROR4__(v372, 2) ^ v391) + (v397 >> 27);
    int v399 = v396 ^ __ROR4__(v347, 31) ^ __ROR4__(v380, 31);
    HIDWORD(v397) = v399;
    LODWORD(v397) = v399;
    int v400 = v397 >> 31;
    HIDWORD(v397) = v372;
    LODWORD(v397) = v372;
    int v401 = v400 - 899497514 + (v397 >> 2);
    HIDWORD(v397) = v391;
    LODWORD(v397) = v391;
    int v402 = v397 >> 2;
    unint64_t v403 = __PAIR64__(v398, __ROR4__(v378, 2));
    int v404 = v401 + (v402 ^ v403 ^ v394);
    LODWORD(v403) = v398;
    unsigned int v405 = v404 + (v403 >> 27);
    LODWORD(v403) = v313 ^ __ROR4__(v293, 31) ^ __ROR4__(v353, 31) ^ __ROR4__(v388, 31);
    int v406 = v403;
    HIDWORD(v403) = v403;
    int v407 = v403 >> 31;
    HIDWORD(v403) = v394;
    LODWORD(v403) = v394;
    int v408 = v403 >> 2;
    unint64_t v409 = __PAIR64__(v405, __ROR4__(v391, 2));
    int v410 = v407 - 899497514 + v395 + (v408 ^ v409 ^ v398);
    LODWORD(v409) = v405;
    unsigned int v411 = v410 + (v409 >> 27);
    LODWORD(v409) = v531 ^ __ROR4__(v317, 31) ^ __ROR4__(v360, 31) ^ __ROR4__(v392, 31);
    int v412 = v409;
    HIDWORD(v409) = v409;
    unsigned int v413 = v409 >> 31;
    HIDWORD(v409) = v398;
    LODWORD(v409) = v398;
    int v414 = v409 >> 2;
    unint64_t v416 = __PAIR64__(v411, __ROR4__(v325, 31));
    int v415 = v313 ^ v416;
    LODWORD(v416) = v411;
    unsigned int v417 = v413 - 899497514 + v402 + (v414 ^ __ROR4__(v394, 2) ^ v405) + (v416 >> 27);
    int v418 = v415 ^ __ROR4__(v367, 31) ^ __ROR4__(v399, 31);
    HIDWORD(v416) = v418;
    LODWORD(v416) = v418;
    int v419 = (v416 >> 31) - 899497514;
    HIDWORD(v416) = v405;
    LODWORD(v416) = v405;
    int v420 = v416 >> 2;
    unint64_t v421 = __PAIR64__(v417, __ROR4__(v398, 2));
    int v422 = v419 + v408 + (v420 ^ v421 ^ v411);
    LODWORD(v421) = v417;
    int v423 = v421 >> 27;
    unint64_t v425 = __PAIR64__(v411, __ROR4__(v373, 31));
    int v424 = v334 ^ __ROR4__(v317, 31) ^ v425;
    LODWORD(v425) = v411;
    int v426 = v425 >> 2;
    int v428 = v422 + v423;
    LODWORD(v425) = v424 ^ __ROR4__(v406, 31);
    int v427 = v425;
    HIDWORD(v425) = v425;
    int v429 = (v425 >> 31) - 899497514 + v414;
    HIDWORD(v425) = v428;
    LODWORD(v425) = v428;
    unsigned int v430 = v429 + (v426 ^ __ROR4__(v405, 2) ^ v417) + (v425 >> 27);
    int v431 = v525 ^ __ROR4__(v338, 31) ^ __ROR4__(v380, 31) ^ __ROR4__(v412, 31);
    HIDWORD(v425) = v431;
    LODWORD(v425) = v431;
    int v432 = (v425 >> 31) - 899497514;
    HIDWORD(v425) = v417;
    LODWORD(v425) = v417;
    int v433 = v425 >> 2;
    unint64_t v434 = __PAIR64__(v430, __ROR4__(v411, 2));
    int v435 = v432 + v420 + (v433 ^ v434 ^ v428);
    LODWORD(v434) = v430;
    unsigned int v436 = v435 + (v434 >> 27);
    int v437 = v334 ^ __ROR4__(v347, 31) ^ __ROR4__(v388, 31) ^ __ROR4__(v418, 31);
    HIDWORD(v434) = v437;
    LODWORD(v434) = v437;
    int v438 = (v434 >> 31) - 899497514 + v426;
    HIDWORD(v434) = v428;
    LODWORD(v434) = v428;
    int v439 = v434 >> 2;
    unint64_t v440 = __PAIR64__(v436, __ROR4__(v417, 2));
    int v441 = v438 + (v439 ^ v440 ^ v430);
    LODWORD(v440) = v436;
    int v442 = v357 ^ __ROR4__(v338, 31) ^ __ROR4__(v392, 31);
    unsigned int v443 = v441 + (v440 >> 27);
    LODWORD(v440) = v442 ^ __ROR4__(v427, 31);
    int v444 = v440;
    HIDWORD(v440) = v440;
    int v445 = (v440 >> 31) - 899497514;
    HIDWORD(v440) = v430;
    LODWORD(v440) = v430;
    int v446 = v440 >> 2;
    unint64_t v447 = __PAIR64__(v443, __ROR4__(v428, 2));
    int v448 = v445 + v433 + (v446 ^ v447 ^ v436);
    LODWORD(v447) = v443;
    unsigned int v449 = v448 + (v447 >> 27);
    LODWORD(v447) = v528 ^ __ROR4__(v360, 31) ^ __ROR4__(v399, 31) ^ __ROR4__(v431, 31);
    int v450 = v447;
    HIDWORD(v447) = v447;
    int v451 = (v447 >> 31) - 899497514 + v439;
    HIDWORD(v447) = v436;
    LODWORD(v447) = v436;
    int v452 = v447 >> 2;
    unint64_t v453 = __PAIR64__(v449, __ROR4__(v430, 2));
    int v454 = v451 + (v452 ^ v453 ^ v443);
    LODWORD(v453) = v449;
    int v455 = v357 ^ __ROR4__(v367, 31) ^ __ROR4__(v406, 31);
    unsigned int v456 = v454 + (v453 >> 27);
    LODWORD(v453) = v455 ^ __ROR4__(v437, 31);
    int v457 = v453;
    HIDWORD(v453) = v453;
    int v458 = (v453 >> 31) - 899497514;
    HIDWORD(v453) = v443;
    LODWORD(v453) = v443;
    int v459 = v453 >> 2;
    unint64_t v460 = __PAIR64__(v456, __ROR4__(v436, 2));
    int v461 = v458 + v446 + (v459 ^ v460 ^ v449);
    LODWORD(v460) = v456;
    int v462 = v460 >> 27;
    unint64_t v464 = __PAIR64__(v449, __ROR4__(v412, 31));
    int v463 = v376 ^ __ROR4__(v360, 31) ^ v464;
    LODWORD(v464) = v449;
    int v465 = v464 >> 2;
    int v466 = v463 ^ __ROR4__(v444, 31);
    int v467 = v461 + v462;
    HIDWORD(v464) = v466;
    LODWORD(v464) = v466;
    int v468 = (v464 >> 31) - 899497514 + v452;
    HIDWORD(v464) = v467;
    LODWORD(v464) = v467;
    unsigned int v469 = v468 + (v465 ^ __ROR4__(v443, 2) ^ v456) + (v464 >> 27);
    LODWORD(v464) = v534 ^ __ROR4__(v380, 31) ^ __ROR4__(v418, 31) ^ __ROR4__(v450, 31);
    int v470 = v464;
    HIDWORD(v464) = v464;
    int v471 = (v464 >> 31) - 899497514;
    HIDWORD(v464) = v456;
    LODWORD(v464) = v456;
    int v472 = v464 >> 2;
    unint64_t v473 = __PAIR64__(v469, __ROR4__(v449, 2));
    int v474 = v471 + v459 + (v472 ^ v473 ^ v467);
    LODWORD(v473) = v469;
    unsigned int v475 = v474 + (v473 >> 27);
    int v476 = v376 ^ __ROR4__(v388, 31) ^ __ROR4__(v427, 31) ^ __ROR4__(v457, 31);
    HIDWORD(v473) = v476;
    LODWORD(v473) = v476;
    int v477 = (v473 >> 31) - 899497514 + v465;
    HIDWORD(v473) = v467;
    LODWORD(v473) = v467;
    int v478 = v473 >> 2;
    unint64_t v479 = __PAIR64__(v475, __ROR4__(v456, 2));
    int v480 = v477 + (v478 ^ v479 ^ v469);
    LODWORD(v479) = v475;
    int v481 = v393 ^ __ROR4__(v380, 31) ^ __ROR4__(v431, 31);
    unsigned int v482 = v480 + (v479 >> 27);
    int v483 = v481 ^ __ROR4__(v466, 31);
    HIDWORD(v479) = v483;
    LODWORD(v479) = v483;
    int v484 = (v479 >> 31) - 899497514;
    HIDWORD(v479) = v469;
    LODWORD(v479) = v469;
    int v485 = v479 >> 2;
    unint64_t v486 = __PAIR64__(v482, __ROR4__(v467, 2));
    int v487 = v484 + v472 + (v485 ^ v486 ^ v475);
    LODWORD(v486) = v482;
    unsigned int v488 = v487 + (v486 >> 27);
    int v489 = v538 ^ __ROR4__(v399, 31) ^ __ROR4__(v437, 31) ^ __ROR4__(v470, 31);
    HIDWORD(v486) = v489;
    LODWORD(v486) = v489;
    int v490 = (v486 >> 31) - 899497514 + v478;
    HIDWORD(v486) = v475;
    LODWORD(v486) = v475;
    int v491 = v486 >> 2;
    unint64_t v493 = __PAIR64__(v488, __ROR4__(v444, 31));
    int v492 = v393 ^ __ROR4__(v406, 31) ^ v493;
    LODWORD(v493) = v488;
    unsigned int v494 = v490 + (v491 ^ __ROR4__(v469, 2) ^ v482) + (v493 >> 27);
    int v495 = v492 ^ __ROR4__(v476, 31);
    HIDWORD(v493) = v495;
    LODWORD(v493) = v495;
    int v496 = (v493 >> 31) - 899497514;
    HIDWORD(v493) = v482;
    LODWORD(v493) = v482;
    int v497 = v493 >> 2;
    unint64_t v498 = __PAIR64__(v494, __ROR4__(v475, 2));
    int v499 = v496 + v485 + (v497 ^ v498 ^ v488);
    LODWORD(v498) = v494;
    unsigned int v500 = v499 + (v498 >> 27);
    uint64_t result = v413 ^ __ROR4__(v399, 31);
    LODWORD(v498) = result ^ __ROR4__(v450, 31) ^ __ROR4__(v483, 31);
    HIDWORD(v498) = v498;
    int v502 = (v498 >> 31) - 899497514 + v491;
    HIDWORD(v498) = v488;
    LODWORD(v498) = v488;
    int v503 = v498 >> 2;
    unint64_t v505 = __PAIR64__(v500, __ROR4__(v457, 31));
    int v504 = v407 ^ __ROR4__(v418, 31) ^ v505;
    LODWORD(v505) = v500;
    unsigned int v506 = v502 + (v503 ^ __ROR4__(v482, 2) ^ v494) + (v505 >> 27);
    LODWORD(v505) = v504 ^ __ROR4__(v489, 31);
    HIDWORD(v505) = v505;
    int v507 = (v505 >> 31) - 899497514;
    HIDWORD(v505) = v494;
    LODWORD(v505) = v494;
    int v508 = v505 >> 2;
    unint64_t v509 = __PAIR64__(v506, __ROR4__(v488, 2));
    int v510 = v507 + v497 + (v508 ^ v509 ^ v500);
    LODWORD(v509) = v506;
    unsigned int v511 = v510 + (v509 >> 27);
    LODWORD(v509) = v413 ^ __ROR4__(v427, 31) ^ __ROR4__(v466, 31) ^ __ROR4__(v495, 31);
    HIDWORD(v509) = v509;
    int v512 = v542 - 899497514 + (v509 >> 31) + v503;
    HIDWORD(v509) = v500;
    LODWORD(v509) = v500;
    int v513 = v509 >> 2;
    unint64_t v514 = __PAIR64__(v511, __ROR4__(v494, 2));
    int v515 = v512 + (v513 ^ v514 ^ v506);
    int v5 = v511 + v548;
    LODWORD(v514) = v511;
    int v7 = v515 + (v514 >> 27);
    HIDWORD(v514) = v506;
    LODWORD(v514) = v506;
    int v6 = (v514 >> 2) + v546;
    int v4 = v508 + v543;
    int v3 = v513 + v547;
    *a1 = v7;
    a1[1] = v511 + v548;
    a1[2] = v6;
    a1[3] = v513 + v547;
    a1[4] = v4;
    a3 = v545 + 16;
    a2 = v544 - 1;
  }
  while (v544 != 1);
  return result;
}

double ccmode_factory_xts_encrypt(int64x2_t *a1, void *a2, uint64_t a3)
{
  uint64_t v3 = a2[1];
  v4.i64[0] = 2 * *a2;
  v4.i64[1] = v3;
  *a1 = vaddq_s64((int64x2_t)vandq_s8((int8x16_t)vaddq_s64(v4, (int64x2_t)xmmword_2373AB2C0), (int8x16_t)xmmword_2373AB2D0), (int64x2_t)xmmword_2373AB2E0);
  a1[1].i64[0] = v3;
  a1[1].i64[1] = (uint64_t)ccmode_xts_init;
  a1[2].i64[0] = (uint64_t)ccmode_xts_key_sched;
  a1[2].i64[1] = (uint64_t)ccmode_xts_set_tweak;
  a1[3].i64[0] = (uint64_t)ccmode_xts_crypt;
  a1[3].i64[1] = (uint64_t)a2;
  a1[4].i64[0] = a3;
  *(void *)&double result = 21;
  a1[4].i64[1] = 21;
  return result;
}

void *ccsigma_mfi_info()
{
  return &mfi_info;
}

double mfi_info_init(uint64_t a1)
{
  int v2 = ccec_cp_256();
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = mfi_kex_ctx;
  *(void *)(a1 + 16) = mfi_peer_kex_ctx;
  unint64_t v3 = ((unint64_t)(cczp_bitlen((uint64_t)v2) + 7) >> 2) & 0x3FFFFFFFFFFFFFFELL;
  *(void *)(a1 + 24) = v2;
  *(void *)(a1 + 32) = ccsha256_di();
  *(void *)(a1 + 40) = v3;
  *(void *)(a1 + 48) = mfi_sign_ctx;
  *(void *)(a1 + 56) = mfi_peer_sign_ctx;
  *(void *)(a1 + 64) = 14;
  *(void *)(a1 + 72) = &mfi_session_keys_info;
  *(void *)(a1 + 80) = 200;
  *(void *)(a1 + 88) = mfi_session_keys_buffer;
  *(void *)(a1 + 96) = mfi_session_keys_derive;
  *(void *)(a1 + 104) = 16;
  *(void *)(a1 + 112) = mfi_mac_compute;
  *(void *)&double result = 9;
  *(_OWORD *)(a1 + 120) = xmmword_2373AB300;
  *(void *)(a1 + 136) = mfi_sigma_compute_mac_and_digest;
  *(void *)(a1 + 144) = 16;
  *(void *)(a1 + 152) = mfi_aead_seal;
  *(void *)(a1 + 160) = mfi_aead_open;
  *(void *)(a1 + 168) = mfi_aead_next_iv;
  *(void *)(a1 + 176) = mfi_clear;
  return result;
}

void *ccsigma_mfi_nvm_info()
{
  qword_268918310 = (uint64_t)&mfi_nvm_session_keys_info;
  unk_268918318 = 144;
  return &mfi_nvm_info;
}

uint64_t mfi_kex_ctx(uint64_t a1)
{
  return a1 + 32;
}

uint64_t mfi_peer_kex_ctx(uint64_t a1)
{
  return a1 + 176;
}

uint64_t mfi_sign_ctx(uint64_t a1)
{
  return a1 + 288;
}

uint64_t mfi_peer_sign_ctx(uint64_t a1)
{
  return a1 + 432;
}

uint64_t mfi_session_keys_buffer(uint64_t a1)
{
  return a1 + 544;
}

uint64_t mfi_session_keys_derive(uint64_t **a1, unint64_t a2, char *a3, size_t a4, const void *a5)
{
  uint64_t v28 = *MEMORY[0x263EF8C08];
  int v10 = *a1;
  unint64_t v11 = ccec_compressed_x962_export_pub_size(**a1);
  size_t v12 = a4 + 2 * v11 + v10[28];
  if (v12 > 0x100) {
    return 4294967289;
  }
  unint64_t v13 = v11;
  int v14 = ccaes_cbc_encrypt_mode();
  uint64_t result = cccmac_one_shot_generate_internal(v14, v10[24], v10[23], a2, a3, 0x10uLL, v26);
  if (!result)
  {
    uint64_t v16 = v10[28];
    __memcpy_chk();
    int v17 = &v27[v16];
    uint64_t inited = (uint64_t *)ccsigma_kex_init_ctx((uint64_t)a1);
    uint64_t result = ccec_compressed_x962_export_pub(inited, v17);
    if (!result)
    {
      int v19 = &v17[v13];
      unsigned int v20 = (uint64_t *)ccsigma_kex_resp_ctx((uint64_t)a1);
      uint64_t result = ccec_compressed_x962_export_pub(v20, v19);
      if (!result)
      {
        memcpy(&v19[v13], a5, a4);
        int v21 = ccaes_cbc_encrypt_mode();
        unsigned int v23 = (const void *)v10[25];
        size_t v22 = v10[26];
        rsize_t v24 = v10[10];
        int v25 = (char *)((uint64_t (*)(uint64_t **))v10[11])(a1);
        return ccnistkdf_ctr_cmac_internal(v21, 0x20u, 16, (uint64_t)v26, v22, v23, v12, v27, v24, 4uLL, v25);
      }
    }
  }
  return result;
}

uint64_t mfi_mac_compute(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, char *a5, void *a6)
{
  size_t v12 = ccaes_cbc_encrypt_mode();
  size_t v13 = *(void *)(*(void *)a1 + 104);

  return cccmac_one_shot_generate_internal(v12, a2, a3, a4, a5, v13, a6);
}

uint64_t mfi_sigma_compute_mac_and_digest(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int v8 = a2;
  uint64_t v22 = *MEMORY[0x263EF8C08];
  uint64_t v10 = *a1;
  uint64_t v11 = *(void *)(*a1 + 32);
  MEMORY[0x270FA53B0](a1, a2, a3, a4);
  size_t v13 = &v19[-v12];
  ccdigest_init_internal(v11, &v19[-v12]);
  ccdigest_update_internal((unint64_t *)v11, v13, *(void *)(v10 + 240), *(char **)(v10 + 232));
  unint64_t v14 = ccec_compressed_x962_export_pub_size(*(void *)v10);
  if (v14 > 0x21) {
    return 4294967291;
  }
  size_t v15 = v14;
  uint64_t inited = (uint64_t *)ccsigma_kex_init_ctx((uint64_t)a1);
  ccec_compressed_x962_export_pub(inited, __src);
  ccdigest_update_internal((unint64_t *)v11, v13, v15, __src);
  int v17 = (uint64_t *)ccsigma_kex_resp_ctx((uint64_t)a1);
  ccec_compressed_x962_export_pub(v17, __src);
  ccdigest_update_internal((unint64_t *)v11, v13, v15, __src);
  uint64_t result = ccsigma_compute_mac_internal(a1, *(void *)(v10 + 8 * v8 + 120), a3, a4, (uint64_t)v20);
  if (!result)
  {
    ccdigest_update_internal((unint64_t *)v11, v13, *(void *)(v10 + 104), v20);
    (*(void (**)(uint64_t, void *, uint64_t))(v11 + 56))(v11, v13, a5);
    return 0;
  }
  return result;
}

uint64_t mfi_aead_seal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v18 = ccaes_ccm_encrypt_mode();
  return ccccm_one_shot_internal((uint64_t)v18, a2, a3, a4, a5, a8, a9, a10, a6, a7, *(void *)(*(void *)a1 + 144), a11);
}

uint64_t mfi_aead_open(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char *a11)
{
  uint64_t v23 = *MEMORY[0x263EF8C08];
  unint64_t v11 = *(void *)(*(void *)a1 + 144);
  if (v11 > 0x10) {
    return 4294967291;
  }
  unsigned int v20 = ccaes_ccm_decrypt_mode();
  uint64_t result = ccccm_one_shot_internal((uint64_t)v20, a2, a3, a4, a5, a8, a9, a10, a6, a7, v11, (uint64_t)v22);
  if (!result)
  {
    if (cc_cmp_safe_internal(*(void *)(*(void *)a1 + 144), a11, v22)) {
      return 4294967294;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t mfi_aead_next_iv(unint64_t a1, uint64_t a2)
{
  return inc_uint(a2, a1);
}

uint64_t mfi_clear(void *__s)
{
  return cc_clear(0x2F0uLL, __s);
}

uint64_t ccnistkdf_ctr_cmac_fixed(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, char *a6, rsize_t a7, char *a8)
{
  BOOL v18 = timingsafe_enable_if_supported();
  uint64_t v16 = ccnistkdf_ctr_cmac_fixed_internal(a1, a2, a3, a4, a5, a6, a7, a8);
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return v16;
}

uint64_t ccnistkdf_ctr_cmac_fixed_internal(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, char *a6, rsize_t a7, char *a8)
{
  uint64_t v40 = *MEMORY[0x263EF8C08];
  if (!a7) {
    return 4294967289;
  }
  unsigned int v9 = a2;
  rsize_t v11 = a1[1];
  rsize_t v12 = a7 / v11;
  if (a7 % v11) {
    rsize_t v13 = v12 + 1;
  }
  else {
    rsize_t v13 = a7 / v11;
  }
  HIDWORD(v14) = a2;
  LODWORD(v14) = (a2 << 24) - 0x8000000;
  uint64_t result = 4294967289;
  if ((v14 >> 27) <= 3u && !(v13 >> a2))
  {
    if (a3)
    {
      if (a4)
      {
        uint64_t v16 = a8;
        if (a8)
        {
          rsize_t v35 = v13;
          rsize_t v36 = a7 % v11;
          unint64_t v37 = &v34;
          unint64_t v19 = (v11 + *a1 + 159) / 0x50;
          uint64_t v20 = MEMORY[0x270FA53B0](4294967289, a2, a3, a4);
          uint64_t v22 = &v34 - 2 * v21;
          MEMORY[0x270FA53B0](v20, v23, v24, v25);
          int v27 = &v34 - 2 * v26;
          int v38 = v28;
          cccmac_init_internal(v28, (uint64_t)v22, v29, v30);
          unint64_t v34 = v19;
          if (v11 <= a7)
          {
            size_t v31 = 80 * v19;
            LODWORD(v19) = 1;
            do
            {
              memcpy(v27, v22, v31);
              PRF_EVAL((char *)v27, v9, v19, a5, a6, v16);
              unint64_t v19 = (v19 + 1);
              v16 += v11;
            }
            while (v12 >= v19);
          }
          size_t v32 = v36;
          if (v36)
          {
            memcpy(v27, v22, 80 * v34);
            PRF_EVAL((char *)v27, v9, v35, a5, a6, __src);
            memcpy(v16, __src, v32);
          }
          cc_clear(v11, __src);
          unsigned int v33 = v38;
          cc_clear(v33[1] + *v33 + 80, v22);
          cc_clear(v33[1] + *v33 + 80, v27);
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t ccnistkdf_ctr_cmac_internal(void *a1, unsigned int a2, uint64_t a3, uint64_t a4, size_t a5, const void *a6, size_t a7, const void *a8, rsize_t a9, size_t a10, char *a11)
{
  size_t v18 = a5 + a7 + a10;
  v27[0] = cc_malloc_clear((v18 + 8) & 0xFFFFFFFFFFFFFFF8);
  v27[1] = (v18 + 8) >> 3;
  void v27[2] = 0;
  v27[3] = cc_ws_alloc;
  uint64_t v28 = cc_ws_free;
  if (!v27[0]) {
    return 4294967283;
  }
  uint64_t v25 = a3;
  unint64_t v19 = (char *)cc_ws_alloc(v27, (v18 + 8) >> 3);
  uint64_t v20 = 4294967289;
  if (a10 <= 4 && !((8 * a9) >> (8 * a10)))
  {
    uint64_t v21 = v19;
    unint64_t v22 = v18 + 1;
    if (a5 && a6) {
      memcpy(v19, a6, a5);
    }
    uint64_t v23 = &v21[a5];
    v21[a5] = 0;
    if (a7 && a8) {
      memcpy(v23 + 1, a8, a7);
    }
    unsigned int __src = bswap32(8 * a9) >> (-8 * a10);
    memcpy(&v23[a7 + 1], &__src, a10);
    uint64_t v20 = ccnistkdf_ctr_cmac_fixed_internal(a1, a2, v25, a4, v22, v21, a9, a11);
  }
  v28((uint64_t)v27);
  return v20;
}

uint64_t ccnistkdf_ctr_cmac(void *a1, unsigned int a2, uint64_t a3, uint64_t a4, size_t a5, const void *a6, size_t a7, const void *a8, rsize_t a9, size_t a10, char *a11)
{
  BOOL v21 = timingsafe_enable_if_supported();
  uint64_t v19 = ccnistkdf_ctr_cmac_internal(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
  cc_disable_dit_with_sb((unsigned int *)&v21);
  return v19;
}

uint64_t PRF_EVAL(char *a1, unsigned int a2, int a3, unint64_t a4, char *a5, void *a6)
{
  unint64_t __src = HIBYTE(a3);
  BYTE1(__src) = BYTE2(a3);
  BYTE2(__src) = BYTE1(a3);
  BYTE3(__src) = a3;
  __src >>= 8 * (4 - (a2 >> 3));
  cccmac_update_internal(a1, a2 >> 3, (char *)&__src);
  cccmac_update_internal(a1, a4, a5);
  return cccmac_final_generate_internal(a1, *(void *)(*((void *)a1 + 8) + 8), a6);
}

uint64_t cche_param_ctx_supports_simd_encoding(uint64_t a1)
{
  BOOL v4 = timingsafe_enable_if_supported();
  uint64_t v2 = *((unsigned __int8 *)cche_param_ctx_plaintext_ctx(a1) + 8);
  cc_disable_dit_with_sb((unsigned int *)&v4);
  return v2;
}

uint64_t cche_encode_poly_uint64(unsigned int **a1, uint64_t a2, unsigned int a3, unint64_t *a4)
{
  BOOL v19 = timingsafe_enable_if_supported();
  unsigned int v8 = cche_param_ctx_plaintext_ctx(a2);
  *a1 = v8;
  unsigned int v9 = *v8;
  if (*v8 < a3)
  {
LABEL_11:
    uint64_t v17 = 4294967289;
    goto LABEL_10;
  }
  unint64_t v10 = cche_param_ctx_plaintext_modulus(a2);
  if (a3)
  {
    rsize_t v11 = (unint64_t *)(a1 + 1);
    uint64_t v12 = a3;
    do
    {
      unint64_t v14 = *a4++;
      unint64_t v13 = v14;
      if (v14 >= v10) {
        goto LABEL_11;
      }
      *v11++ = v13;
    }
    while (--v12);
  }
  if (v9 > a3)
  {
    unint64_t v15 = a3;
    uint64_t v16 = &a1[a3 + 1];
    do
    {
      ccn_seti(1, v16, 0);
      ++v15;
      ++v16;
    }
    while (v15 < **a1);
  }
  uint64_t v17 = 0;
LABEL_10:
  cc_disable_dit_with_sb((unsigned int *)&v19);
  return v17;
}

uint64_t cche_encode_simd_uint64(unsigned int **a1, uint64_t a2, unsigned int a3, unsigned int **a4)
{
  BOOL v25 = timingsafe_enable_if_supported();
  unsigned int v8 = cche_param_ctx_plaintext_ctx(a2);
  *a1 = v8;
  if (*v8 < a3)
  {
LABEL_13:
    uint64_t v23 = 4294967289;
    goto LABEL_14;
  }
  unint64_t v9 = cche_param_ctx_plaintext_modulus(a2);
  unint64_t v10 = cche_param_ctx_plaintext_ctx(a2);
  unsigned int v11 = cche_param_ctx_polynomial_degree(a2);
  unint64_t v12 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
  if (v11 >= 0x80) {
    uint64_t v13 = 128;
  }
  else {
    uint64_t v13 = v11;
  }
  unint64_t v14 = ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v13 + v11;
  if (a3)
  {
    unint64_t v15 = &v10[4 * v14 + 12 + 2 * v12];
    uint64_t v16 = a3;
    do
    {
      unsigned int v17 = *v15++;
      a1[v17 + 1] = *a4;
      unint64_t v18 = (unint64_t)*a4++;
      if (v18 >= v9) {
        goto LABEL_13;
      }
    }
    while (--v16);
  }
  if (**a1 > a3)
  {
    uint64_t v19 = a3;
    uint64_t v20 = &v10[4 * v14 + 2 * v12];
    uint64_t v21 = v19 + 12;
    do
    {
      ccn_seti(1, &a1[v20[v21] + 1], 0);
      unint64_t v22 = v21 - 11;
      ++v21;
    }
    while (v22 < **a1);
  }
  uint64_t v23 = ccpolyzp_po2cyc_inv_ntt(a1);
LABEL_14:
  cc_disable_dit_with_sb((unsigned int *)&v25);
  return v23;
}

uint64_t cche_encode_simd_int64(unsigned int **a1, uint64_t a2, unsigned int a3, uint64_t *a4)
{
  BOOL v26 = timingsafe_enable_if_supported();
  unsigned int v8 = cche_param_ctx_plaintext_ctx(a2);
  *a1 = v8;
  if (*v8 < a3)
  {
LABEL_17:
    uint64_t v22 = 4294967289;
    goto LABEL_16;
  }
  uint64_t v9 = *((void *)v8 + 2);
  BOOL v25 = cche_param_ctx_plaintext_ctx(a2);
  unsigned int v10 = cche_param_ctx_polynomial_degree(a2);
  unint64_t v24 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
  if (v10 >= 0x80) {
    uint64_t v11 = 128;
  }
  else {
    uint64_t v11 = v10;
  }
  unint64_t v12 = ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v11 + v10;
  if (a3)
  {
    uint64_t v13 = &v25[4 * v12 + 12 + 2 * v24];
    uint64_t v14 = a3;
    do
    {
      uint64_t v16 = *a4++;
      uint64_t v15 = v16;
      if (v16 > (v9 - 1) >> 1 || v15 < -(v9 >> 1)) {
        goto LABEL_17;
      }
      uint64_t v18 = ccpolyzp_po2cyc_centered_to_rem(v15, v9);
      unsigned int v19 = *v13++;
      a1[v19 + 1] = (unsigned int *)v18;
    }
    while (--v14);
  }
  if (**a1 > a3)
  {
    uint64_t v20 = a3 + 12;
    do
    {
      ccn_seti(1, &a1[v25[4 * v12 + 2 * v24 + v20] + 1], 0);
      unint64_t v21 = v20 - 11;
      ++v20;
    }
    while (v21 < **a1);
  }
  uint64_t v22 = ccpolyzp_po2cyc_inv_ntt(a1);
LABEL_16:
  cc_disable_dit_with_sb((unsigned int *)&v26);
  return v22;
}

uint64_t cche_encode_simd_reduced_int64(unsigned int **a1, uint64_t a2, unsigned int a3, uint64_t *a4)
{
  BOOL v28 = timingsafe_enable_if_supported();
  unsigned int v8 = cche_param_ctx_plaintext_ctx(a2);
  *a1 = v8;
  if (*v8 < a3)
  {
LABEL_17:
    uint64_t v26 = 4294967289;
    goto LABEL_16;
  }
  uint64_t v9 = cche_param_ctx_plaintext_ctx(a2);
  unsigned int v10 = v9[1];
  while (--v10)
    uint64_t v9 = (unsigned int *)*((void *)v9 + 14);
  uint64_t v11 = cche_param_ctx_plaintext_ctx(a2);
  unsigned int v12 = cche_param_ctx_polynomial_degree(a2);
  unint64_t v13 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
  if (v12 >= 0x80) {
    uint64_t v14 = 128;
  }
  else {
    uint64_t v14 = v12;
  }
  unint64_t v15 = ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v14 + v12;
  if (a3)
  {
    uint64_t v16 = (unint64_t *)(v9 + 4);
    unsigned int v17 = &v11[4 * v15 + 12 + 2 * v13];
    uint64_t v18 = a3;
    do
    {
      uint64_t v19 = *a4++;
      unint64_t v20 = ccpolyzp_po2cyc_int_to_rem(v19, v16);
      if (v20 > *v16) {
        goto LABEL_17;
      }
      unsigned int v21 = *v17++;
      a1[v21 + 1] = (unsigned int *)v20;
    }
    while (--v18);
  }
  if (**a1 > a3)
  {
    uint64_t v22 = a3;
    uint64_t v23 = &v11[4 * v15 + 2 * v13];
    uint64_t v24 = v22 + 12;
    do
    {
      ccn_seti(1, &a1[v23[v24] + 1], 0);
      unint64_t v25 = v24 - 11;
      ++v24;
    }
    while (v25 < **a1);
  }
  uint64_t v26 = ccpolyzp_po2cyc_inv_ntt(a1);
LABEL_16:
  cc_disable_dit_with_sb((unsigned int *)&v28);
  return v26;
}

uint64_t cche_decode_poly_uint64(unsigned int a1, uint64_t a2, void *a3)
{
  BOOL v12 = timingsafe_enable_if_supported();
  if (*(_DWORD *)*a3 < a1)
  {
    uint64_t v10 = 4294967289;
  }
  else if (a1)
  {
    unint64_t v6 = *(void *)(*a3 + 16);
    unint64_t v7 = a3[1];
    if (v7 >= v6)
    {
      uint64_t v10 = 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t v8 = 0;
      do
      {
        uint64_t v9 = v8;
        *(void *)(a2 + 8 * v8) = v7;
        if (a1 - 1 == v8) {
          break;
        }
        unint64_t v7 = a3[v8++ + 2];
      }
      while (v7 < v6);
      if (v9 + 1 >= (unint64_t)a1) {
        uint64_t v10 = 0;
      }
      else {
        uint64_t v10 = 0xFFFFFFFFLL;
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t cche_decode_simd_uint64_ws(uint64_t a1, uint64_t a2, unsigned int a3, unint64_t *a4, unsigned int **a5)
{
  int v5 = *a5;
  unsigned int v6 = **a5;
  if (v6 < a3) {
    return 4294967289;
  }
  uint64_t v12 = *(void *)(a1 + 16);
  unint64_t v13 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 24);
  uint64_t v14 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v15 = (void *)v13(a1, v5[1] * v6 + ((unint64_t)(v14 + 7) >> 3));
  uint64_t v16 = *a5;
  uint64_t v17 = sizeof_struct_ccpolyzp_po2cyc();
  memmove(v15, a5, (v17 + 8 * v16[1] * *v16 + 7) & 0xFFFFFFFFFFFFFFF8);
  uint64_t result = ccpolyzp_po2cyc_fwd_ntt((unsigned int **)v15);
  if (!result)
  {
    unint64_t v19 = *((void *)*a5 + 2);
    unint64_t v20 = cche_param_ctx_plaintext_ctx(a2);
    unsigned int v21 = cche_param_ctx_polynomial_degree(a2);
    uint64_t v22 = sizeof_struct_ccpolyzp_po2cyc_ctx();
    if (v21 >= 0x80) {
      uint64_t v23 = 128;
    }
    else {
      uint64_t v23 = v21;
    }
    uint64_t v24 = sizeof_struct_ccrns_mul_modulus();
    if (a3)
    {
      unint64_t v25 = &v20[4 * ((unint64_t)(v24 + 7) >> 3) * v23 + 12 + 4 * v21 + 2 * ((unint64_t)(v22 + 7) >> 3)];
      uint64_t v26 = a3;
      while (1)
      {
        unsigned int v27 = *v25++;
        unint64_t v28 = *((void *)v15 + v27 + 1);
        if (v28 >= v19) {
          break;
        }
        *a4++ = v28;
        if (!--v26) {
          goto LABEL_10;
        }
      }
      uint64_t result = 0xFFFFFFFFLL;
    }
    else
    {
LABEL_10:
      uint64_t result = 0;
    }
  }
  *(void *)(a1 + 16) = v12;
  return result;
}

uint64_t cche_decode_simd_uint64(uint64_t a1, unsigned int a2, unint64_t *a3, unsigned int **a4)
{
  BOOL v17 = timingsafe_enable_if_supported();
  uint64_t v8 = *a4;
  unsigned int v9 = **a4;
  unsigned int v10 = (*a4)[1];
  uint64_t v11 = sizeof_struct_ccpolyzp_po2cyc();
  v15[0] = cc_malloc_clear((v11 + 8 * v10 * v9 + 7) & 0xFFFFFFFFFFFFFFF8);
  unsigned int v12 = *v8;
  LODWORD(v8) = v8[1];
  v15[1] = v8 * v12 + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3);
  v15[2] = 0;
  v15[3] = cc_ws_alloc;
  uint64_t v16 = cc_ws_free;
  if (v15[0])
  {
    uint64_t v13 = cche_decode_simd_uint64_ws((uint64_t)v15, a1, a2, a3, a4);
    v16((uint64_t)v15);
  }
  else
  {
    uint64_t v13 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v17);
  return v13;
}

uint64_t cche_decode_simd_int64_ws(uint64_t a1, uint64_t a2, unsigned int a3, unint64_t *a4, unsigned int **a5)
{
  unsigned int v6 = (uint64_t *)a4;
  LODWORD(v7) = a3;
  uint64_t result = cche_decode_simd_uint64_ws(a1, a2, a3, a4, a5);
  if (!result)
  {
    if (v7)
    {
      uint64_t v9 = *((void *)*a5 + 2);
      uint64_t v7 = v7;
      while (1)
      {
        int64_t v10 = ccpolyzp_po2cyc_rem_to_centered(*v6, v9);
        if (v10 > (v9 - 1) >> 1 || v10 < -(v9 >> 1)) {
          break;
        }
        *v6++ = v10;
        if (!--v7) {
          return 0;
        }
      }
      return 0xFFFFFFFFLL;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t cche_decode_simd_int64(uint64_t a1, unsigned int a2, unint64_t *a3, unsigned int **a4)
{
  BOOL v17 = timingsafe_enable_if_supported();
  uint64_t v8 = *a4;
  unsigned int v9 = **a4;
  unsigned int v10 = (*a4)[1];
  uint64_t v11 = sizeof_struct_ccpolyzp_po2cyc();
  v15[0] = cc_malloc_clear((v11 + 8 * v10 * v9 + 7) & 0xFFFFFFFFFFFFFFF8);
  unsigned int v12 = *v8;
  LODWORD(v8) = v8[1];
  v15[1] = v8 * v12 + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3);
  v15[2] = 0;
  v15[3] = cc_ws_alloc;
  uint64_t v16 = cc_ws_free;
  if (v15[0])
  {
    uint64_t v13 = cche_decode_simd_int64_ws((uint64_t)v15, a1, a2, a3, a4);
    v16((uint64_t)v15);
  }
  else
  {
    uint64_t v13 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v17);
  return v13;
}

uint64_t cche_dcrt_plaintext_encode_ws(uint64_t a1, unsigned int **a2, uint64_t a3, uint64_t a4)
{
  v21[1] = *MEMORY[0x263EF8C08];
  BOOL v4 = *(unsigned int **)(a4 + 8);
  unsigned int v5 = *v4;
  uint64_t v6 = v4[1];
  *a2 = v4;
  if (v6)
  {
    uint64_t v8 = 0;
    BOOL v17 = (uint64_t *)(a3 + 8);
    uint64_t v18 = a4 + 32;
    uint64_t v16 = a2 + 1;
    unsigned int v9 = (unint64_t *)(a4 + 24);
    do
    {
      if (v5)
      {
        unsigned int v10 = (uint64_t *)(v18 + 8 * *(unsigned int *)(*(void *)(a4 + 8) + 4) + 8 * v8);
        uint64_t v11 = v17;
        unsigned int v12 = (uint64_t *)&v16[**a2 * v8];
        unsigned int v13 = v5;
        do
        {
          char v14 = ccn_sub_ws(a1, 1, v21, v11, v9);
          ccn_add_ws(a1, 1, v21, v11, v10);
          ccn_mux(1, v14, v12++, v11++, v21);
          --v13;
        }
        while (v13);
      }
      ++v8;
    }
    while (v8 != v6);
  }
  return ccpolyzp_po2cyc_fwd_ntt(a2);
}

uint64_t cche_dcrt_plaintext_encode(unsigned int **a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  BOOL v24 = timingsafe_enable_if_supported();
  if (cche_param_ctx_ciphertext_ctx_nmoduli(a3) < a4)
  {
    uint64_t v20 = 4294967289;
  }
  else
  {
    uint64_t v8 = *cche_param_ctx_plaintext_ctx(a3);
    unsigned int v9 = cche_param_ctx_plaintext_ctx(a3);
    unsigned int v10 = cche_param_ctx_polynomial_degree(a3);
    unint64_t v11 = sizeof_struct_ccpolyzp_po2cyc_ctx() + 7;
    if (v10 >= 0x80) {
      uint64_t v12 = 128;
    }
    else {
      uint64_t v12 = v10;
    }
    unint64_t v13 = ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v12 + v10;
    uint64_t v14 = (4 * v8 + 7) & 0x7FFFFFFF8;
    uint64_t v15 = cche_param_ctx_chain_const(a3);
    uint64_t v16 = cche_decrypt_ctx_nof_n((unsigned int *)(v15 + 8));
    uint64_t v17 = v16;
    if (a4 < 2)
    {
      uint64_t v19 = (uint64_t)&v9[4 * v13 + 12 + 2 * (v11 >> 3) + 2 * v16] + v14;
    }
    else
    {
      uint64_t v18 = sizeof_struct_cche_cipher_plain_ctx();
      uint64_t v19 = (uint64_t)&v9[4 * (((a4 - 3) * (unint64_t)(a4 - 2)) >> 1) + 16 + 4 * v13 + 2 * v17]
          + v14
          + (v11 & 0xFFFFFFFFFFFFFFF8)
          + ((v18 + 7) & 0xFFFFFFFFFFFFFFF8)
          + (((v18 + 7) & 0xFFFFFFFFFFFFFFF8) + 32) * (a4 - 2);
    }
    v22[1] = 0;
    v22[2] = 0;
    v22[0] = cc_malloc_clear(0);
    v22[3] = cc_ws_alloc;
    uint64_t v23 = cc_ws_free;
    if (v22[0])
    {
      uint64_t v20 = cche_dcrt_plaintext_encode_ws((uint64_t)v22, a1, a2, v19);
      v23((uint64_t)v22);
    }
    else
    {
      uint64_t v20 = 4294967283;
    }
  }
  cc_disable_dit_with_sb((unsigned int *)&v24);
  return v20;
}

uint64_t ccascon_ascon128a_encrypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  BOOL v20 = timingsafe_enable_if_supported();
  memset(v19, 0, sizeof(v19));
  (*(void (**)(_OWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(v19, a6, a7, a8, a9);
  uint64_t v17 = (*(uint64_t (**)(_OWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 32))(v19, a2, a3, a4, a5, a9);
  cc_disable_dit_with_sb((unsigned int *)&v20);
  return v17;
}

uint64_t ccascon_ascon128a_decrypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  BOOL v20 = timingsafe_enable_if_supported();
  memset(v19, 0, sizeof(v19));
  (*(void (**)(_OWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(v19, a6, a7, a8, a9);
  uint64_t v17 = (*(uint64_t (**)(_OWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 40))(v19, a2, a3, a4, a5, a9);
  cc_disable_dit_with_sb((unsigned int *)&v20);
  return v17;
}

uint64_t ccascon_ascon128a_ref_init(unint64_t *a1, unint64_t a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t v8 = 0;
  unint64_t v9 = bswap64(*a5);
  unint64_t v10 = bswap64(a5[1]);
  unint64_t v11 = bswap64(*a4);
  unint64_t v12 = bswap64(a4[1]);
  unint64_t v13 = 0x80800C0800000000;
  unint64_t v14 = v9;
  unint64_t v15 = v10;
  do
  {
    unint64_t v16 = v15 ^ ROUND_CONSTANTS[v8];
    unint64_t v17 = v12 ^ v13;
    unint64_t v18 = v12 ^ v11;
    unint64_t v19 = v16 ^ v14;
    unint64_t v20 = v16 & ~v14 ^ v17;
    unint64_t v21 = v11 & ~v19 ^ v14;
    unint64_t v22 = v14 & ~v17 ^ v12 ^ v11;
    unint64_t v23 = v12 & ~v11;
    unint64_t v24 = v17 & ~v18 ^ v11 ^ v19 ^ v23;
    unint64_t v13 = __ROR8__(v20 ^ v22, 19) ^ __ROR8__(v20 ^ v22, 28) ^ v20 ^ v22;
    unint64_t v14 = __ROR8__(v21 ^ v20, 61) ^ __ROR8__(v21 ^ v20, 39) ^ v21 ^ v20;
    unint64_t v15 = v19 ^ v23 ^ ~(__ROR8__(v19 ^ ~v23, 1) ^ __ROR8__(v19 ^ ~v23, 6));
    unint64_t v11 = __ROR8__(v24, 10) ^ __ROR8__(v24, 17) ^ v24;
    unint64_t v12 = __ROR8__(v22, 7) ^ __ROR8__(v22, 41) ^ v22;
    ++v8;
  }
  while (v8 != 12);
  *a1 = v13;
  a1[1] = v14;
  a1[2] = v15;
  a1[3] = v11 ^ v9;
  unint64_t v25 = v12 ^ v10;
  a1[4] = v25;
  a1[5] = 0;
  if (a2)
  {
    ccascon_ascon128a_ref_accumulate_encrypt(a1, 0, a2, a3);
    ccascon_ascon128a_ref_pad((uint64_t)a1);
    uint64_t v26 = 0;
    unint64_t v27 = a1[3];
    unint64_t v25 = a1[4];
    unint64_t v28 = a1[1];
    unint64_t v29 = a1[2];
    unint64_t v30 = *a1;
    do
    {
      unint64_t v31 = v29 ^ ROUND_CONSTANTS[v26 + 4];
      unint64_t v32 = v25 ^ v30;
      unint64_t v33 = v25 ^ v27;
      unint64_t v34 = v31 ^ v28;
      unint64_t v35 = v31 & ~v28 ^ v32;
      unint64_t v36 = v27 & ~v34 ^ v28;
      unint64_t v37 = v28 & ~v32 ^ v25 ^ v27;
      unint64_t v38 = v25 & ~v27;
      unint64_t v39 = v32 & ~v33 ^ v27 ^ v34 ^ v38;
      unint64_t v30 = __ROR8__(v35 ^ v37, 19) ^ __ROR8__(v35 ^ v37, 28) ^ v35 ^ v37;
      unint64_t v28 = __ROR8__(v36 ^ v35, 61) ^ __ROR8__(v36 ^ v35, 39) ^ v36 ^ v35;
      unint64_t v29 = v34 ^ v38 ^ ~(__ROR8__(v34 ^ ~v38, 1) ^ __ROR8__(v34 ^ ~v38, 6));
      unint64_t v27 = __ROR8__(v39, 10) ^ __ROR8__(v39, 17) ^ v39;
      unint64_t v25 = __ROR8__(v37, 7) ^ __ROR8__(v37, 41) ^ v37;
      ++v26;
    }
    while (v26 != 8);
    a1[2] = v29;
    a1[3] = v27;
    *a1 = v30;
    a1[1] = v28;
  }
  a1[4] = v25 ^ 1;
  return 0;
}

uint64_t ccascon_ascon128a_ref_encrypt(unint64_t *a1, void *a2, uint64_t a3, unint64_t a4, unint64_t *a5, unint64_t *a6)
{
  return 0;
}

unint64_t ccascon_ascon128a_ref_decrypt(int8x8_t *a1, void *a2, char *a3, unint64_t a4, unint64_t *a5, unint64_t *a6)
{
  uint64_t v13 = *MEMORY[0x263EF8C08];
  ccascon_ascon128a_ref_accumulate_decrypt(a1, a2, a4, a5);
  ccascon_ascon128a_ref_pad((uint64_t)a1);
  ccascon_ascon128a_ref_finalize((unint64_t *)a1, (uint64_t)v12, a6);
  unint64_t result = cc_cmp_safe_internal(16, a3, v12);
  if (result)
  {
    if (a2)
    {
      if (a4) {
        cc_clear(a4, a2);
      }
    }
    cc_clear(8uLL, a1);
    return 4294967294;
  }
  return result;
}

void *ccascon_ascon128a()
{
  return &ccascon_ascon128a_ref;
}

uint64_t ccmode_cbc_init(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  *a2 = v2;
  return (*(uint64_t (**)(void))(v2 + 16))();
}

uint64_t fipspost_post_indicator()
{
  BOOL v351 = fips_allowed("fipspost_post_integrity", 0);
  uint64_t v0 = 8;
  do
  {
    unint64_t v1 = v0 + 8;
    unsigned int v349 = fips_allowed_mode_("ccaes_ecb_encrypt_mode", v0 + 8);
    unsigned int v347 = fips_allowed_mode_("ccaes_ecb_decrypt_mode", v0 + 8);
    unsigned int v345 = fips_allowed_mode_("ccaes_cbc_encrypt_mode", v0 + 8);
    unsigned int v343 = fips_allowed_mode_("ccaes_cbc_decrypt_mode", v0 + 8);
    unsigned int v341 = fips_allowed_mode_("ccaes_ccm_encrypt_mode", v0 + 8);
    unsigned int v339 = fips_allowed_mode_("ccaes_ccm_decrypt_mode", v0 + 8);
    unsigned int v337 = fips_allowed_mode_("ccaes_cfb8_encrypt_mode", v0 + 8);
    unsigned int v2 = fips_allowed_mode_("ccaes_cfb8_decrypt_mode", v0 + 8);
    unsigned int v3 = fips_allowed_mode_("ccaes_cfb_encrypt_mode", v0 + 8);
    unsigned int v4 = fips_allowed_mode_("ccaes_cfb_decrypt_mode", v0 + 8);
    unsigned int v5 = fips_allowed_mode_("ccaes_ofb_crypt_mode", v0 + 8);
    unsigned int v6 = fips_allowed_mode_("ccaes_ctr_crypt_mode", v0 + 8);
    unsigned int v7 = fips_allowed_mode_("ccaes_gcm_encrypt_mode", v0 + 8);
    unsigned int v8 = fips_allowed_mode_("ccaes_gcm_decrypt_mode", v0 + 8);
    unsigned int v9 = fips_allowed_mode_("ccwrap_auth_encrypt_withiv", v0 + 8);
    unsigned int v10 = v349 & v351 & v347 & v345 & v343 & v341 & v339 & v337 & v2 & v3 & v4 & v5 & v6 & v7 & v8 & v9 & fips_allowed_mode_("ccwrap_auth_decrypt_withiv", v0 + 8);
    if (v0 != 16)
    {
      unsigned int v11 = fips_allowed_mode_("ccpad_cts1_encrypt", v0 + 8);
      unsigned int v12 = fips_allowed_mode_("ccpad_cts1_decrypt", v0 + 8);
      unsigned int v13 = fips_allowed_mode_("ccpad_cts2_encrypt", v0 + 8);
      unsigned int v14 = fips_allowed_mode_("ccpad_cts2_decrypt", v0 + 8);
      unsigned int v15 = fips_allowed_mode_("ccpad_cts3_encrypt", v1);
      unsigned int v16 = fips_allowed_mode_("ccpad_cts3_decrypt", v1);
      unsigned int v17 = fips_allowed_mode_("ccaes_xts_encrypt_mode", v1);
      v10 &= v11 & v12 & v13 & v14 & v15 & v16 & v17 & fips_allowed_mode_("ccaes_xts_decrypt_mode", v1);
    }
    BOOL v351 = v10;
    uint64_t v0 = v1;
  }
  while (v1 < 0x19);
  BOOL v350 = fips_allowed_drbg_("ccdrbg_init", "ccdrbg_factory_nistctr", "CCAES_KEY_SIZE_128");
  BOOL v348 = fips_allowed_drbg_("ccdrbg_reseed", "ccdrbg_factory_nistctr", "CCAES_KEY_SIZE_128");
  BOOL v346 = fips_allowed_drbg_("ccdrbg_generate", "ccdrbg_factory_nistctr", "CCAES_KEY_SIZE_128");
  BOOL v344 = fips_allowed_drbg_("ccdrbg_done", "ccdrbg_factory_nistctr", "CCAES_KEY_SIZE_128");
  BOOL v342 = fips_allowed_drbg_("ccdrbg_init", "ccdrbg_factory_nistctr", "CCAES_KEY_SIZE_256");
  BOOL v340 = fips_allowed_drbg_("ccdrbg_reseed", "ccdrbg_factory_nistctr", "CCAES_KEY_SIZE_256");
  BOOL v338 = fips_allowed_drbg_("ccdrbg_generate", "ccdrbg_factory_nistctr", "CCAES_KEY_SIZE_256");
  BOOL v335 = fips_allowed_drbg_("ccdrbg_done", "ccdrbg_factory_nistctr", "CCAES_KEY_SIZE_256");
  BOOL v333 = fips_allowed_drbg_("ccdrbg_init", "ccdrbg_factory_nisthmac", "ccsha1_di");
  BOOL v331 = fips_allowed_drbg_("ccdrbg_reseed", "ccdrbg_factory_nisthmac", "ccsha1_di");
  BOOL v330 = fips_allowed_drbg_("ccdrbg_generate", "ccdrbg_factory_nisthmac", "ccsha1_di");
  BOOL v329 = fips_allowed_drbg_("ccdrbg_done", "ccdrbg_factory_nisthmac", "ccsha1_di");
  BOOL v328 = !fips_allowed_drbg_("ccdrbg_init", "ccdrbg_factory_nisthmac", "ccsha224_di");
  BOOL v324 = fips_allowed_drbg_("ccdrbg_reseed", "ccdrbg_factory_nisthmac", "ccsha224_di");
  BOOL v336 = fips_allowed_drbg_("ccdrbg_generate", "ccdrbg_factory_nisthmac", "ccsha224_di");
  BOOL v334 = fips_allowed_drbg_("ccdrbg_done", "ccdrbg_factory_nisthmac", "ccsha224_di");
  BOOL v332 = fips_allowed_drbg_("ccdrbg_init", "ccdrbg_factory_nisthmac", "ccsha256_di");
  BOOL v321 = fips_allowed_drbg_("ccdrbg_reseed", "ccdrbg_factory_nisthmac", "ccsha256_di");
  BOOL v320 = fips_allowed_drbg_("ccdrbg_generate", "ccdrbg_factory_nisthmac", "ccsha256_di");
  BOOL v319 = fips_allowed_drbg_("ccdrbg_done", "ccdrbg_factory_nisthmac", "ccsha256_di");
  BOOL v327 = fips_allowed_drbg_("ccdrbg_init", "ccdrbg_factory_nisthmac", "ccsha384_di");
  BOOL v326 = fips_allowed_drbg_("ccdrbg_reseed", "ccdrbg_factory_nisthmac", "ccsha384_di");
  BOOL v325 = fips_allowed_drbg_("ccdrbg_generate", "ccdrbg_factory_nisthmac", "ccsha384_di");
  BOOL v323 = fips_allowed_drbg_("ccdrbg_done", "ccdrbg_factory_nisthmac", "ccsha384_di");
  BOOL v322 = fips_allowed_drbg_("ccdrbg_init", "ccdrbg_factory_nisthmac", "ccsha512_di");
  BOOL v318 = fips_allowed_drbg_("ccdrbg_reseed", "ccdrbg_factory_nisthmac", "ccsha512_di");
  BOOL v317 = fips_allowed_drbg_("ccdrbg_generate", "ccdrbg_factory_nisthmac", "ccsha512_di");
  BOOL v316 = fips_allowed_drbg_("ccdrbg_done", "ccdrbg_factory_nisthmac", "ccsha512_di");
  BOOL v315 = fips_allowed("ccec_generate_key_fips", "ccec_cp_224");
  BOOL v314 = fips_allowed("ccec_generate_key_fips", "ccec_cp_256");
  BOOL v313 = fips_allowed("ccec_generate_key_fips", "ccec_cp_384");
  BOOL v312 = fips_allowed("ccec_generate_key_fips", "ccec_cp_521");
  BOOL v311 = fips_allowed("ccec_make_priv", "ccec_cp_224");
  BOOL v310 = fips_allowed("ccec_make_priv", "ccec_cp_256");
  BOOL v309 = fips_allowed("ccec_make_priv", "ccec_cp_384");
  BOOL v308 = fips_allowed("ccec_make_priv", "ccec_cp_521");
  BOOL v307 = fips_allowed("ccec_make_pub", "ccec_cp_224");
  BOOL v306 = fips_allowed("ccec_make_pub", "ccec_cp_256");
  BOOL v305 = fips_allowed("ccec_make_pub", "ccec_cp_384");
  BOOL v304 = fips_allowed("ccec_make_pub", "ccec_cp_521");
  BOOL v303 = fips_allowed("ccec_sign_msg", "ccec_cp_224");
  BOOL v302 = fips_allowed("ccec_sign_msg", "ccec_cp_256");
  BOOL v301 = fips_allowed("ccec_sign_msg", "ccec_cp_384");
  BOOL v300 = fips_allowed("ccec_sign_msg", "ccec_cp_521");
  BOOL v299 = fips_allowed("ccec_verify_msg", "ccec_cp_192");
  BOOL v298 = fips_allowed("ccec_verify_msg", "ccec_cp_224");
  BOOL v297 = fips_allowed("ccec_verify_msg", "ccec_cp_256");
  BOOL v296 = fips_allowed("ccec_verify_msg", "ccec_cp_384");
  BOOL v295 = fips_allowed("ccec_verify_msg", "ccec_cp_521");
  BOOL v294 = fips_allowed("ccec_validate_pub", "ccec_cp_192");
  BOOL v293 = fips_allowed("ccec_validate_pub", "ccec_cp_224");
  BOOL v292 = fips_allowed("ccec_validate_pub", "ccec_cp_256");
  BOOL v291 = fips_allowed("ccec_validate_pub", "ccec_cp_384");
  BOOL v290 = fips_allowed("ccec_validate_pub", "ccec_cp_521");
  BOOL v289 = fips_allowed("cchmac", "ccsha1_di");
  BOOL v288 = fips_allowed("cchmac", "ccsha224_di");
  BOOL v287 = fips_allowed("cchmac", "ccsha256_di");
  BOOL v286 = fips_allowed("cchmac", "ccsha384_di");
  BOOL v285 = fips_allowed("cchmac", "ccsha512_di");
  BOOL v284 = fips_allowed("cchmac", "ccsha512_256_di");
  BOOL v283 = fips_allowed("cchmac", "ccsha3_224_di");
  BOOL v282 = fips_allowed("cchmac", "ccsha3_256_di");
  BOOL v281 = fips_allowed("cchmac", "ccsha3_384_di");
  BOOL v280 = fips_allowed("cchmac", "ccsha3_512_di");
  BOOL v279 = fips_allowed("ccdh_gp_rfc3526group14", 0);
  BOOL v278 = fips_allowed("ccdh_gp_rfc3526group15", 0);
  BOOL v277 = fips_allowed("ccdh_gp_rfc3526group16", 0);
  BOOL v276 = fips_allowed("ccdh_gp_rfc3526group17", 0);
  BOOL v275 = fips_allowed("ccdh_gp_rfc3526group18", 0);
  BOOL v274 = fips_allowed("ccdh_generate_key", "2048");
  BOOL v273 = fips_allowed("ccdh_generate_key", "3072");
  BOOL v272 = fips_allowed("ccdh_generate_key", "4096");
  BOOL v271 = fips_allowed("ccdh_generate_key", "6144");
  BOOL v270 = fips_allowed("ccdh_generate_key", "8192");
  BOOL v269 = fips_allowed("ccdh_import_pub", "2048");
  BOOL v268 = fips_allowed("ccdh_import_pub", "3072");
  BOOL v267 = fips_allowed("ccdh_import_pub", "4096");
  BOOL v266 = fips_allowed("ccdh_import_pub", "6144");
  BOOL v265 = fips_allowed("ccdh_import_pub", "8192");
  BOOL v264 = fips_allowed("ccdh_import_priv", "2048");
  BOOL v263 = fips_allowed("ccdh_import_priv", "3072");
  BOOL v262 = fips_allowed("ccdh_import_priv", "4096");
  BOOL v261 = fips_allowed("ccdh_import_priv", "6144");
  BOOL v260 = fips_allowed("ccdh_import_priv", "8192");
  BOOL v259 = fips_allowed("ccdh_compute_shared_secret", "2048");
  BOOL v258 = fips_allowed("ccdh_compute_shared_secret", "3072");
  BOOL v257 = fips_allowed("ccdh_compute_shared_secret", "4096");
  BOOL v256 = fips_allowed("ccdh_compute_shared_secret", "6144");
  BOOL v255 = fips_allowed("ccdh_compute_shared_secret", "8192");
  BOOL v254 = fips_allowed("ccecdh_compute_shared_secret", "ccec_cp_224");
  BOOL v253 = fips_allowed("ccecdh_compute_shared_secret", "ccec_cp_256");
  BOOL v252 = fips_allowed("ccecdh_compute_shared_secret", "ccec_cp_384");
  BOOL v251 = fips_allowed("ccecdh_compute_shared_secret", "ccec_cp_521");
  BOOL v250 = fips_allowed("ccecdh_generate_key", "ccec_cp_224");
  BOOL v249 = fips_allowed("ccecdh_generate_key", "ccec_cp_256");
  BOOL v248 = fips_allowed("ccecdh_generate_key", "ccec_cp_384");
  BOOL v247 = fips_allowed("ccecdh_generate_key", "ccec_cp_521");
  BOOL v246 = fips_allowed("ccnistkdf_ctr_cmac", "16");
  BOOL v245 = fips_allowed("ccnistkdf_ctr_cmac", "24");
  BOOL v244 = fips_allowed("ccnistkdf_ctr_cmac", "32");
  BOOL v243 = fips_allowed("ccnistkdf_ctr_cmac_fixed", "16");
  BOOL v242 = fips_allowed("ccnistkdf_ctr_cmac_fixed", "24");
  BOOL v241 = fips_allowed("ccnistkdf_ctr_cmac_fixed", "32");
  BOOL v240 = fips_allowed("ccnistkdf_ctr_hmac", "ccsha1_di");
  BOOL v239 = fips_allowed("ccnistkdf_ctr_hmac", "ccsha224_di");
  BOOL v238 = fips_allowed("ccnistkdf_ctr_hmac", "ccsha256_di");
  BOOL v237 = fips_allowed("ccnistkdf_ctr_hmac", "ccsha384_di");
  BOOL v236 = fips_allowed("ccnistkdf_ctr_hmac", "ccsha512_di");
  BOOL v235 = fips_allowed("ccnistkdf_ctr_hmac", "ccsha512_256_di");
  BOOL v234 = fips_allowed("ccnistkdf_ctr_hmac", "ccsha3_224_di");
  BOOL v233 = fips_allowed("ccnistkdf_ctr_hmac", "ccsha3_256_di");
  BOOL v231 = fips_allowed("ccnistkdf_ctr_hmac", "ccsha3_384_di");
  BOOL v229 = fips_allowed("ccnistkdf_ctr_hmac", "ccsha3_512_di");
  BOOL v226 = fips_allowed("ccnistkdf_ctr_hmac_fixed", "ccsha1_di");
  BOOL v224 = fips_allowed("ccnistkdf_ctr_hmac_fixed", "ccsha224_di");
  BOOL v222 = fips_allowed("ccnistkdf_ctr_hmac_fixed", "ccsha256_di");
  BOOL v219 = fips_allowed("ccnistkdf_ctr_hmac_fixed", "ccsha384_di");
  BOOL v217 = fips_allowed("ccnistkdf_ctr_hmac_fixed", "ccsha512_di");
  BOOL v216 = fips_allowed("ccnistkdf_ctr_hmac_fixed", "ccsha512_256_di");
  BOOL v215 = fips_allowed("ccnistkdf_ctr_hmac_fixed", "ccsha3_224_di");
  BOOL v214 = fips_allowed("ccnistkdf_ctr_hmac_fixed", "ccsha3_256_di");
  BOOL v212 = fips_allowed("ccnistkdf_ctr_hmac_fixed", "ccsha3_384_di");
  BOOL v211 = fips_allowed("ccnistkdf_ctr_hmac_fixed", "ccsha3_512_di");
  BOOL v210 = fips_allowed("ccpbkdf2_hmac", "ccsha1_di");
  BOOL v213 = fips_allowed("ccpbkdf2_hmac", "ccsha224_di");
  BOOL v232 = fips_allowed("ccpbkdf2_hmac", "ccsha256_di");
  BOOL v230 = fips_allowed("ccpbkdf2_hmac", "ccsha384_di");
  BOOL v228 = fips_allowed("ccpbkdf2_hmac", "ccsha512_di");
  BOOL v227 = fips_allowed("ccpbkdf2_hmac", "ccsha512_256_di");
  BOOL v225 = fips_allowed("ccpbkdf2_hmac", "ccsha3_224_di");
  BOOL v223 = fips_allowed("ccpbkdf2_hmac", "ccsha3_256_di");
  BOOL v221 = fips_allowed("ccpbkdf2_hmac", "ccsha3_384_di");
  BOOL v220 = fips_allowed("ccpbkdf2_hmac", "ccsha3_512_di");
  BOOL v218 = fips_allowed("cchkdf", "ccsha1_di");
  BOOL v209 = fips_allowed("cchkdf", "ccsha224_di");
  BOOL v208 = fips_allowed("cchkdf", "ccsha256_di");
  BOOL v207 = fips_allowed("cchkdf", "ccsha384_di");
  BOOL v206 = fips_allowed("cchkdf", "ccsha512_di");
  BOOL v205 = fips_allowed("cchkdf", "ccsha512_256_di");
  BOOL v204 = fips_allowed("cchkdf", "ccsha3_224_di");
  BOOL v203 = fips_allowed("cchkdf", "ccsha3_256_di");
  BOOL v202 = fips_allowed("cchkdf", "ccsha3_384_di");
  BOOL v201 = fips_allowed("cchkdf", "ccsha3_512_di");
  BOOL v200 = !fips_allowed("ccmd5_di", 0);
  BOOL v199 = fips_allowed("ccsha1_di", 0);
  BOOL v198 = fips_allowed("ccsha224_di", 0);
  BOOL v197 = fips_allowed("ccsha256_di", 0);
  BOOL v196 = fips_allowed("ccsha384_di", 0);
  BOOL v195 = fips_allowed("ccsha512_di", 0);
  BOOL v194 = fips_allowed("ccsha512_256_di", 0);
  BOOL v193 = fips_allowed("ccsha3_224_di", 0);
  BOOL v192 = fips_allowed("ccsha3_256_di", 0);
  BOOL v191 = fips_allowed("ccsha3_384_di", 0);
  BOOL v190 = fips_allowed("ccsha3_512_di", 0);
  BOOL v189 = fips_allowed("ccshake128_xi", 0);
  BOOL v188 = fips_allowed("ccshake256_xi", 0);
  BOOL v185 = !fips_allowed("ccrng_uniform", 0);
  BOOL v182 = fips_allowed("ccrsa_verify_pss_msg", "1024");
  BOOL v180 = fips_allowed("ccrsa_verify_pss_msg", "2048");
  BOOL v178 = fips_allowed("ccrsa_verify_pss_msg", "3072");
  BOOL v175 = fips_allowed("ccrsa_verify_pss_msg", "4096");
  BOOL v171 = fips_allowed("ccrsa_verify_pkcs1v15_msg", "1024");
  BOOL v170 = fips_allowed("ccrsa_verify_pkcs1v15_msg", "2048");
  BOOL v168 = fips_allowed("ccrsa_verify_pkcs1v15_msg", "3072");
  BOOL v166 = fips_allowed("ccrsa_verify_pkcs1v15_msg", "4096");
  BOOL v163 = fips_allowed("ccrsa_generate_fips186_key", "2048");
  BOOL v161 = fips_allowed("ccrsa_generate_fips186_key", "3072");
  BOOL v159 = fips_allowed("ccrsa_generate_fips186_key", "4096");
  BOOL v157 = fips_allowed("ccrsa_sign_pss_msg", "2048");
  BOOL v154 = fips_allowed("ccrsa_sign_pss_msg", "3072");
  BOOL v152 = fips_allowed("ccrsa_sign_pss_msg", "4096");
  BOOL v150 = fips_allowed("ccrsa_sign_pkcs1v15_msg", "2048");
  BOOL v148 = fips_allowed("ccrsa_sign_pkcs1v15_msg", "3072");
  BOOL v146 = fips_allowed("ccrsa_sign_pkcs1v15_msg", "4096");
  BOOL v143 = !fips_allowed("ccrsa_encrypt_oaep", "2048");
  BOOL v173 = fips_allowed("ccrsa_encrypt_oaep", "3072");
  BOOL v187 = fips_allowed("ccrsa_encrypt_oaep", "4096");
  BOOL v186 = fips_allowed("ccrsa_decrypt_oaep", "2048");
  BOOL v184 = fips_allowed("ccrsa_decrypt_oaep", "3072");
  BOOL v183 = fips_allowed("ccrsa_decrypt_oaep", "4096");
  BOOL v181 = fips_allowed("ccansikdf_x963", "ccsha1_di");
  BOOL v179 = fips_allowed("ccansikdf_x963", "ccsha224_di");
  BOOL v177 = fips_allowed("ccansikdf_x963", "ccsha256_di");
  BOOL v176 = fips_allowed("ccansikdf_x963", "ccsha384_di");
  BOOL v174 = fips_allowed("ccansikdf_x963", "ccsha512_di");
  BOOL v172 = fips_allowed("ccansikdf_x963", "ccsha512_256_di");
  unsigned int v169 = fips_allowed_mode_("ccblowfish_ecb_decrypt_mode", 16);
  unsigned int v167 = fips_allowed_mode_("ccblowfish_ecb_encrypt_mode", 16);
  unsigned int v165 = fips_allowed_mode_("ccblowfish_cbc_decrypt_mode", 16);
  unsigned int v164 = fips_allowed_mode_("ccblowfish_cbc_encrypt_mode", 16);
  unsigned int v162 = fips_allowed_mode_("ccblowfish_cfb_decrypt_mode", 16);
  unsigned int v160 = fips_allowed_mode_("ccblowfish_cfb_encrypt_mode", 16);
  unsigned int v158 = fips_allowed_mode_("ccblowfish_cfb8_decrypt_mode", 16);
  unsigned int v156 = fips_allowed_mode_("ccblowfish_cfb8_encrypt_mode", 16);
  unsigned int v155 = fips_allowed_mode_("ccblowfish_ctr_crypt_mode", 16);
  unsigned int v153 = fips_allowed_mode_("ccblowfish_ofb_crypt_mode", 16);
  unsigned int v151 = fips_allowed_mode_("cccast_ecb_decrypt_mode", 16);
  unsigned int v149 = fips_allowed_mode_("cccast_ecb_encrypt_mode", 16);
  unsigned int v147 = fips_allowed_mode_("cccast_cbc_decrypt_mode", 16);
  unsigned int v145 = fips_allowed_mode_("cccast_cbc_encrypt_mode", 16);
  unsigned int v144 = fips_allowed_mode_("cccast_cfb_decrypt_mode", 16);
  unsigned int v142 = fips_allowed_mode_("cccast_cfb_encrypt_mode", 16);
  unsigned int v141 = fips_allowed_mode_("cccast_cfb8_decrypt_mode", 16);
  unsigned int v140 = fips_allowed_mode_("cccast_cfb8_encrypt_mode", 16);
  unsigned int v139 = fips_allowed_mode_("cccast_ctr_crypt_mode", 16);
  unsigned int v138 = fips_allowed_mode_("cccast_ofb_crypt_mode", 16);
  unsigned int v137 = fips_allowed_mode_("ccdes3_ecb_decrypt_mode", 16);
  unsigned int v136 = fips_allowed_mode_("ccdes3_ecb_encrypt_mode", 16);
  unsigned int v135 = fips_allowed_mode_("ccdes3_cbc_decrypt_mode", 16);
  unsigned int v134 = fips_allowed_mode_("ccdes3_cbc_encrypt_mode", 16);
  unsigned int v133 = fips_allowed_mode_("ccdes3_cfb_decrypt_mode", 16);
  unsigned int v132 = fips_allowed_mode_("ccdes3_cfb_encrypt_mode", 16);
  unsigned int v131 = fips_allowed_mode_("ccdes3_cfb8_decrypt_mode", 16);
  unsigned int v130 = fips_allowed_mode_("ccdes3_cfb8_encrypt_mode", 16);
  unsigned int v129 = fips_allowed_mode_("ccdes3_ctr_crypt_mode", 16);
  unsigned int v128 = fips_allowed_mode_("ccdes3_ofb_crypt_mode", 16);
  BOOL v127 = fips_allowed("ccdh_compute_shared_secret", "ccsrp_gp_rfc5054_2048");
  BOOL v126 = fips_allowed("ccdh_gp_apple768", 0);
  BOOL v125 = fips_allowed("ccdh_gp_rfc2409group02", 0);
  BOOL v124 = fips_allowed("ccdh_gp_rfc2409group05", 0);
  BOOL v123 = fips_allowed("ccdh_gp_rfc5114_MODP_1024_160", 0);
  BOOL v122 = fips_allowed("ccdh_gp_rfc5114_MODP_2048_224", 0);
  BOOL v121 = fips_allowed("ccdh_gp_rfc5114_MODP_2048_256", 0);
  BOOL v120 = fips_allowed("ccec_sign", "ccec_cp_224");
  BOOL v119 = fips_allowed("ccec_sign", "ccec_cp_256");
  BOOL v118 = fips_allowed("ccec_sign", "ccec_cp_384");
  BOOL v117 = fips_allowed("ccec_sign", "ccec_cp_521");
  BOOL v116 = fips_allowed("ccec_verify", "ccec_cp_192");
  BOOL v115 = fips_allowed("ccec_verify", "ccec_cp_224");
  BOOL v114 = fips_allowed("ccec_verify", "ccec_cp_256");
  BOOL v113 = fips_allowed("ccec_verify", "ccec_cp_384");
  BOOL v112 = fips_allowed("ccec_verify", "ccec_cp_521");
  BOOL v111 = fips_allowed("ccec_verify_strict", "ccec_cp_256");
  BOOL v110 = fips_allowed("ccec_verify_strict", "ccec_cp_384");
  BOOL v109 = fips_allowed("ccec_verify_strict", "ccec_cp_521");
  BOOL v108 = fips_allowed("ccec_rfc6637_kdf", "ccec_cp_256");
  BOOL v107 = fips_allowed("ccec_rfc6637_kdf", "ccec_cp_384");
  BOOL v106 = fips_allowed("ccec_rfc6637_kdf", "ccec_cp_521");
  BOOL v105 = fips_allowed("ccec_rfc6637_wrap_key", "ccec_cp_256");
  BOOL v104 = fips_allowed("ccec_rfc6637_wrap_key", "ccec_cp_384");
  BOOL v103 = fips_allowed("ccec_rfc6637_wrap_key", "ccec_cp_521");
  BOOL v102 = fips_allowed("ccec_rfc6637_unwrap_key", "ccec_cp_256");
  BOOL v101 = fips_allowed("ccec_rfc6637_unwrap_key", "ccec_cp_384");
  BOOL v100 = fips_allowed("ccec_rfc6637_unwrap_key", "ccec_cp_521");
  BOOL v99 = fips_allowed("ccecies_encrypt_gcm", 0);
  BOOL v98 = fips_allowed("ccecies_decrypt_gcm", 0);
  BOOL v97 = fips_allowed("cced25519_make_key_pair", 0);
  BOOL v96 = fips_allowed("cced25519_sign", 0);
  BOOL v95 = fips_allowed("cced25519_verify", 0);
  BOOL v94 = fips_allowed("cch2c", "ccec_cp_256");
  BOOL v93 = fips_allowed("cch2c", "ccec_cp_384");
  BOOL v92 = fips_allowed("cch2c", "ccec_cp_521");
  BOOL v91 = fips_allowed("cchpke", 0);
  BOOL v90 = fips_allowed("cchpke_kem_x25519_generate_key_pair", 0);
  BOOL v89 = fips_allowed("cchpke_kem_x25519_public_key", 0);
  BOOL v88 = fips_allowed("cchpke_kem_generate_key_pair", 0);
  BOOL v87 = fips_allowed("cchpke_initiator_encrypt", 0);
  BOOL v86 = fips_allowed("cchpke_responder_decrypt", 0);
  BOOL v85 = fips_allowed("cchpke_export_secret", 0);
  BOOL v84 = fips_allowed("cchkdf", 0);
  fips_allowed("ccpbkdf2_hmac", "ccsha1_di");
  fips_allowed("ccpbkdf2_hmac", "ccsha224_di");
  fips_allowed("ccpbkdf2_hmac", "ccsha256_di");
  fips_allowed("ccpbkdf2_hmac", "ccsha384_di");
  fips_allowed("ccpbkdf2_hmac", "ccsha512_di");
  fips_allowed("ccpbkdf2_hmac", "ccsha512_256_di");
  fips_allowed("ccpbkdf2_hmac", "ccsha3_224_di");
  fips_allowed("ccpbkdf2_hmac", "ccsha3_256_di");
  fips_allowed("ccpbkdf2_hmac", "ccsha3_384_di");
  fips_allowed("ccpbkdf2_hmac", "ccsha3_512_di");
  BOOL v83 = fips_allowed("ccmd2_di", 0);
  BOOL v82 = fips_allowed("ccmd4_di", 0);
  unsigned int v81 = fips_allowed_mode_("ccrc2_ecb_decrypt_mode", 16);
  unsigned int v80 = fips_allowed_mode_("ccrc2_ecb_encrypt_mode", 16);
  unsigned int v79 = fips_allowed_mode_("ccrc2_cbc_decrypt_mode", 16);
  unsigned int v78 = fips_allowed_mode_("ccrc2_cbc_encrypt_mode", 16);
  unsigned int v77 = fips_allowed_mode_("ccrc2_cfb_decrypt_mode", 16);
  unsigned int v76 = fips_allowed_mode_("ccrc2_cfb_encrypt_mode", 16);
  unsigned int v75 = fips_allowed_mode_("ccrc2_cfb8_decrypt_mode", 16);
  unsigned int v74 = fips_allowed_mode_("ccrc2_cfb8_encrypt_mode", 16);
  unsigned int v73 = fips_allowed_mode_("ccrc2_ctr_crypt_mode", 16);
  unsigned int v72 = fips_allowed_mode_("ccrc2_ofb_crypt_mode", 16);
  BOOL v71 = fips_allowed("ccrc4", 0);
  BOOL v70 = fips_allowed("ccrmd160_di", 0);
  BOOL v69 = fips_allowed("ccrsa_verify_pss_digest", "1024");
  BOOL v68 = fips_allowed("ccrsa_verify_pss_digest", "2048");
  BOOL v67 = fips_allowed("ccrsa_verify_pss_digest", "3072");
  BOOL v66 = fips_allowed("ccrsa_verify_pss_digest", "4096");
  BOOL v65 = fips_allowed("ccrsa_verify_pkcs1v15_digest", "1024");
  BOOL v64 = fips_allowed("ccrsa_verify_pkcs1v15_digest", "2048");
  BOOL v63 = fips_allowed("ccrsa_verify_pkcs1v15_digest", "3072");
  BOOL v62 = fips_allowed("ccrsa_verify_pkcs1v15_digest", "4096");
  BOOL v61 = fips_allowed("ccrsa_encrypt_oaep", "1024");
  BOOL v60 = fips_allowed("ccrsa_decrypt_oaep", "1024");
  BOOL v59 = fips_allowed("ccrsa_sign_pss", "2048");
  BOOL v58 = fips_allowed("ccrsa_sign_pss", "3072");
  BOOL v57 = fips_allowed("ccrsa_sign_pss", "4096");
  BOOL v56 = fips_allowed("ccrsa_sign_pkcs1v15", "2048");
  BOOL v55 = fips_allowed("ccrsa_sign_pkcs1v15", "3072");
  BOOL v54 = fips_allowed("ccrsa_sign_pkcs1v15", "4096");
  BOOL v53 = fips_allowed("ccsae_init", 0);
  BOOL v52 = fips_allowed("ccsae_init_p256_sha256", 0);
  BOOL v51 = fips_allowed("ccsae_ctr_hmac_fixed", 0);
  BOOL v50 = fips_allowed("ccsae_get_keys", 0);
  BOOL v49 = fips_allowed("ccscrypt", 0);
  BOOL v48 = fips_allowed("ccsigma_init", 0);
  BOOL v47 = fips_allowed("ccsigma_sign", 0);
  BOOL v46 = fips_allowed("ccsigma_verify", 0);
  BOOL v45 = fips_allowed("ccsigma_seal", 0);
  BOOL v44 = fips_allowed("ccspake_kex_generate", 0);
  BOOL v43 = fips_allowed("ccspake_mac_hkdf_cmac_aes128_sha256", 0);
  BOOL v42 = fips_allowed("ccspake_mac_hkdf_hmac_compute", 0);
  BOOL v41 = fips_allowed("ccspake_cp_256", 0);
  BOOL v40 = fips_allowed("ccspake_cp_384", 0);
  BOOL v39 = fips_allowed("ccspake_cp_521", 0);
  BOOL v38 = fips_allowed("ccspake_mac_hkdf_hmac_sha256", 0);
  BOOL v37 = fips_allowed("ccspake_mac_hkdf_hmac_sha512", 0);
  BOOL v18 = fips_allowed("ccspake_kex_process", 0);
  BOOL v19 = fips_allowed("ccspake_kex_generate", 0);
  BOOL v20 = fips_allowed("ccspake_mac_hkdf_derive", 0);
  BOOL v21 = fips_allowed("ccss_shamir_parameters_init", 0);
  BOOL v22 = fips_allowed("ccss_shamir_share_generator_init", 0);
  BOOL v23 = fips_allowed("ccss_shamir_share_generator_generate_share", 0);
  BOOL v24 = fips_allowed("NULL", 0);
  BOOL v25 = fips_allowed("NULL", "42");
  unsigned int v26 = fips_allowed_mode_("ccaes_ecb_encrypt_mode", 12);
  unsigned int v27 = fips_allowed_mode_("ccdes3_ecb_encrypt_mode", 42);
  unsigned int v28 = fips_allowed_mode_("ccdes_ecb_encrypt_mode", 12);
  int v29 = v350 && v348 && v346 && v344 && v342 && v340 && v338 && v335 && v333 && v331 && v330 && v329 && v328;
  if (v324) {
    int v29 = 0;
  }
  if (v336) {
    int v29 = 0;
  }
  int v30 = v29 & v332;
  if (v334) {
    int v30 = 0;
  }
  int v31 = v30 & (v321 && v320 && v319);
  if (v327) {
    int v31 = 0;
  }
  if (v326) {
    int v31 = 0;
  }
  if (v325) {
    int v31 = 0;
  }
  int v32 = v31 & v322;
  if (v323) {
    int v32 = 0;
  }
  int v33 = v32 & (v318
            && v317
            && v316
            && v315
            && v314
            && v313
            && v312
            && v311
            && v310
            && v309
            && v308
            && v307
            && v306
            && v305
            && v304
            && v303) & (v302
                     && v301
                     && v300
                     && v299
                     && v298
                     && v297
                     && v296
                     && v295
                     && v294
                     && v293
                     && v292
                     && v291
                     && v290
                     && v289
                     && v288
                     && v287
                     && v286) & (v285
                              && v284
                              && v283
                              && v282
                              && v281
                              && v280
                              && v279
                              && v278
                              && v277
                              && v276
                              && v275
                              && v274
                              && v273
                              && v272
                              && v271
                              && v270
                              && v269
                              && v268) & (v267
                                       && v266
                                       && v265
                                       && v264
                                       && v263
                                       && v262
                                       && v261
                                       && v260
                                       && v259
                                       && v258
                                       && v257
                                       && v256
                                       && v255
                                       && v254
                                       && v253
                                       && v252
                                       && v251
                                       && v250
                                       && v249) & (v248
                                                && v247
                                                && v246
                                                && v245
                                                && v244
                                                && v243
                                                && v242
                                                && v241
                                                && v240
                                                && v239
                                                && v238
                                                && v237
                                                && v236
                                                && v235
                                                && v234
                                                && v233
                                                && v231
                                                && v229
                                                && v226
                                                && v224) & (v222
                                                         && v219
                                                         && v217
                                                         && v216
                                                         && v215
                                                         && v214
                                                         && v212
                                                         && v211
                                                         && v210);
  if (!v213) {
    int v33 = 0;
  }
  if (!v232) {
    int v33 = 0;
  }
  if (!v230) {
    int v33 = 0;
  }
  if (!v228) {
    int v33 = 0;
  }
  if (!v227) {
    int v33 = 0;
  }
  if (!v225) {
    int v33 = 0;
  }
  if (!v223) {
    int v33 = 0;
  }
  if (!v221) {
    int v33 = 0;
  }
  int v34 = v33 & v218;
  if (!v220) {
    int v34 = 0;
  }
  int v35 = v34 & (v209
            && v208
            && v207
            && v206
            && v205
            && v204
            && v203
            && v202
            && v201
            && v199
            && v200
            && v198
            && v197
            && v196
            && v195
            && v194
            && v193
            && v192
            && v191
            && v190
            && v189
            && v188
            && v182
            && v185
            && v180
            && v178
            && v175
            && v171
            && v170
            && v168
            && v166
            && v163) & (v161 && v159 && v157 && v154 && v152 && v150 && v148 && v146 && v143);
  if (v173) {
    int v35 = 0;
  }
  if (v187) {
    int v35 = 0;
  }
  if (v186) {
    int v35 = 0;
  }
  if (v184) {
    int v35 = 0;
  }
  if (v183) {
    int v35 = 0;
  }
  if (v181) {
    int v35 = 0;
  }
  if (v179) {
    int v35 = 0;
  }
  if (v177) {
    int v35 = 0;
  }
  if (v176) {
    int v35 = 0;
  }
  if (v174) {
    int v35 = 0;
  }
  if (v172) {
    int v35 = 0;
  }
  if (v169) {
    int v35 = 0;
  }
  if (v167) {
    int v35 = 0;
  }
  if (v165) {
    int v35 = 0;
  }
  if (v164) {
    int v35 = 0;
  }
  if (v162) {
    int v35 = 0;
  }
  if (v160) {
    int v35 = 0;
  }
  if (v158) {
    int v35 = 0;
  }
  if (v156) {
    int v35 = 0;
  }
  if (v155) {
    int v35 = 0;
  }
  if (v153) {
    int v35 = 0;
  }
  if (v151) {
    int v35 = 0;
  }
  if (v149) {
    int v35 = 0;
  }
  if (v147) {
    int v35 = 0;
  }
  if (v145) {
    int v35 = 0;
  }
  if (v144) {
    int v35 = 0;
  }
  if (v142) {
    int v35 = 0;
  }
  if (v141) {
    int v35 = 0;
  }
  if (v140) {
    int v35 = 0;
  }
  if (v139) {
    int v35 = 0;
  }
  if (v138) {
    int v35 = 0;
  }
  if (v137) {
    int v35 = 0;
  }
  if (v136) {
    int v35 = 0;
  }
  if (v135) {
    int v35 = 0;
  }
  if (v134) {
    int v35 = 0;
  }
  if (v133) {
    int v35 = 0;
  }
  if (v132) {
    int v35 = 0;
  }
  if (v131) {
    int v35 = 0;
  }
  if (v130) {
    int v35 = 0;
  }
  if (v129) {
    int v35 = 0;
  }
  if (v128) {
    int v35 = 0;
  }
  if (v127) {
    int v35 = 0;
  }
  if (v126) {
    int v35 = 0;
  }
  if (v125) {
    int v35 = 0;
  }
  if (v124) {
    int v35 = 0;
  }
  if (v123) {
    int v35 = 0;
  }
  if (v122) {
    int v35 = 0;
  }
  if (v121) {
    int v35 = 0;
  }
  if (v120) {
    int v35 = 0;
  }
  if (v119) {
    int v35 = 0;
  }
  if (v118) {
    int v35 = 0;
  }
  if (v117) {
    int v35 = 0;
  }
  if (v116) {
    int v35 = 0;
  }
  if (v115) {
    int v35 = 0;
  }
  if (v114) {
    int v35 = 0;
  }
  if (v113) {
    int v35 = 0;
  }
  if (v112) {
    int v35 = 0;
  }
  if (v111) {
    int v35 = 0;
  }
  if (v110) {
    int v35 = 0;
  }
  if (v109) {
    int v35 = 0;
  }
  if (v108) {
    int v35 = 0;
  }
  if (v107) {
    int v35 = 0;
  }
  if (v106) {
    int v35 = 0;
  }
  if (v105) {
    int v35 = 0;
  }
  if (v104) {
    int v35 = 0;
  }
  if (v103) {
    int v35 = 0;
  }
  if (v102) {
    int v35 = 0;
  }
  if (v101) {
    int v35 = 0;
  }
  if (v100) {
    int v35 = 0;
  }
  if (v99) {
    int v35 = 0;
  }
  if (v98) {
    int v35 = 0;
  }
  if (v97) {
    int v35 = 0;
  }
  if (v96) {
    int v35 = 0;
  }
  if (v95) {
    int v35 = 0;
  }
  if (v94) {
    int v35 = 0;
  }
  if (v93) {
    int v35 = 0;
  }
  if (v92) {
    int v35 = 0;
  }
  if (v91) {
    int v35 = 0;
  }
  if (v90) {
    int v35 = 0;
  }
  if (v89) {
    int v35 = 0;
  }
  if (v88) {
    int v35 = 0;
  }
  if (v87) {
    int v35 = 0;
  }
  if (v86) {
    int v35 = 0;
  }
  if (v85) {
    int v35 = 0;
  }
  if (v84) {
    int v35 = 0;
  }
  if (v83) {
    int v35 = 0;
  }
  if (v82) {
    int v35 = 0;
  }
  if (v81) {
    int v35 = 0;
  }
  if (v80) {
    int v35 = 0;
  }
  if (v79) {
    int v35 = 0;
  }
  if (v78) {
    int v35 = 0;
  }
  if (v77) {
    int v35 = 0;
  }
  if (v76) {
    int v35 = 0;
  }
  if (v75) {
    int v35 = 0;
  }
  if (v74) {
    int v35 = 0;
  }
  if (v73) {
    int v35 = 0;
  }
  if (v72) {
    int v35 = 0;
  }
  if (v71) {
    int v35 = 0;
  }
  if (v70) {
    int v35 = 0;
  }
  if (v69) {
    int v35 = 0;
  }
  if (v68) {
    int v35 = 0;
  }
  if (v67) {
    int v35 = 0;
  }
  if (v66) {
    int v35 = 0;
  }
  if (v65) {
    int v35 = 0;
  }
  if (v64) {
    int v35 = 0;
  }
  if (v63) {
    int v35 = 0;
  }
  if (v62) {
    int v35 = 0;
  }
  if (v61) {
    int v35 = 0;
  }
  if (v60) {
    int v35 = 0;
  }
  if (v59) {
    int v35 = 0;
  }
  if (v58) {
    int v35 = 0;
  }
  if (v57) {
    int v35 = 0;
  }
  if (v56) {
    int v35 = 0;
  }
  if (v55) {
    int v35 = 0;
  }
  if (v54) {
    int v35 = 0;
  }
  if (v53) {
    int v35 = 0;
  }
  if (v52) {
    int v35 = 0;
  }
  if (v51) {
    int v35 = 0;
  }
  if (v50) {
    int v35 = 0;
  }
  if (v49) {
    int v35 = 0;
  }
  if (v48) {
    int v35 = 0;
  }
  if (v47) {
    int v35 = 0;
  }
  if (v46) {
    int v35 = 0;
  }
  if (v45) {
    int v35 = 0;
  }
  if (v44) {
    int v35 = 0;
  }
  if (v43) {
    int v35 = 0;
  }
  if (v42) {
    int v35 = 0;
  }
  if (v41) {
    int v35 = 0;
  }
  if (v40) {
    int v35 = 0;
  }
  if (v39) {
    int v35 = 0;
  }
  if (v38) {
    int v35 = 0;
  }
  if (v37) {
    int v35 = 0;
  }
  if (v18) {
    int v35 = 0;
  }
  if (v19) {
    int v35 = 0;
  }
  if (v20) {
    int v35 = 0;
  }
  if (v21) {
    int v35 = 0;
  }
  if (v22) {
    int v35 = 0;
  }
  if (v23) {
    int v35 = 0;
  }
  if (v24) {
    int v35 = 0;
  }
  if (v25) {
    int v35 = 0;
  }
  if (v26) {
    int v35 = 0;
  }
  if (v27) {
    int v35 = 0;
  }
  if (v28) {
    int v35 = 0;
  }
  if ((v35 & v351) != 0) {
    return 0;
  }
  else {
    return 4294967224;
  }
}

uint64_t ccentropy_get_seed_internal(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t ccentropy_get_seed(uint64_t (***a1)(void, uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t v6 = (**a1)(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return v6;
}

uint64_t ccentropy_add_entropy_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  if (a5) {
    *a5 = 0;
  }
  unsigned int v5 = *(uint64_t (**)(void))(*(void *)a1 + 8);
  if (v5) {
    return v5();
  }
  else {
    return 4294967123;
  }
}

uint64_t ccentropy_add_entropy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  BOOL v13 = timingsafe_enable_if_supported();
  if (a5) {
    *a5 = 0;
  }
  unsigned int v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *))(*(void *)a1 + 8);
  if (v10) {
    uint64_t v11 = v10(a1, a2, a3, a4, a5);
  }
  else {
    uint64_t v11 = 4294967123;
  }
  cc_disable_dit_with_sb((unsigned int *)&v13);
  return v11;
}

uint64_t ccentropy_reset(uint64_t a1)
{
  unint64_t v1 = *(uint64_t (**)(void))(*(void *)a1 + 16);
  if (v1) {
    return v1();
  }
  else {
    return 4294967123;
  }
}

void *ccsrp_gp_rfc5054_2048()
{
  return &_ccsrp_gp_rfc5054_2048;
}

void *ccec_cp_521()
{
  return &ccec_cp521;
}

uint64_t ccn_mod_521_ws(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v14[9] = *MEMORY[0x263EF8C08];
  ccn_shift_right(9, (uint64_t)v12, (unint64_t *)(a4 + 64), 9uLL);
  v13 += *(void *)(a4 + 64) & 0x1FFLL;
  uint64_t v8 = ccn_add_ws(a1, 8, v12, v12, (uint64_t *)a4);
  v13 += v8;
  unsigned int v9 = (unint64_t *)cczp_prime(a2);
  char v10 = ccn_sub_ws(a1, 9, v14, v12, v9);
  return ccn_mux(9, v10, a3, v12, v14);
}

void *ccaes_ecb_decrypt_mode()
{
  return &ccaes_ltc_ecb_decrypt_mode;
}

size_t ccpad_pkcs7_encrypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v16 = timingsafe_enable_if_supported();
  unint64_t v12 = *(void *)(a1 + 8);
  size_t v13 = (v12 - 1) & a4;
  size_t v14 = a4 - v13;
  (*(void (**)(uint64_t, uint64_t, size_t, uint64_t, uint64_t))(a1 + 24))(a2, a3, (a4 - v13) / v12, a5, a6);
  memcpy((void *)(a6 + v14), (const void *)(a5 + v14), v13);
  memset((void *)(a6 + a4), v12 - v13, v12 - v13);
  (*(void (**)(uint64_t, uint64_t, uint64_t, size_t, size_t))(a1 + 24))(a2, a3, 1, a6 + v14, a6 + v14);
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return a4 - v13 + v12;
}

uint64_t ccder_sizeof_implicit_octet_string(uint64_t a1, unint64_t a2, unint64_t *a3)
{
  unint64_t v4 = ccn_write_uint_size_public_value(a2, a3);

  return ccder_sizeof(a1, v4);
}

void *ccmode_factory_cfb8_encrypt(void *result, void *a2)
{
  *unint64_t result = ((*a2 + 7) & 0xFFFFFFFFFFFFFFF8) + ((2 * a2[1] + 14) & 0xFFFFFFFFFFFFFFF0) + 8;
  result[1] = 1;
  result[2] = ccmode_cfb8_init;
  result[3] = ccmode_cfb8_encrypt;
  result[4] = a2;
  return result;
}

uint64_t ccrng_pbkdf2_prng_init(char *a1, unint64_t a2, uint64_t a3, uint64_t a4, size_t a5, char *a6, unint64_t a7)
{
  BOOL v17 = timingsafe_enable_if_supported();
  if (a2 <= 0x1000)
  {
    *(void *)a1 = ccrng_pbkdf2_prng_generate;
    *((void *)a1 + 1) = a2;
    unsigned int v15 = (unint64_t *)ccsha256_di();
    uint64_t v14 = ccpbkdf2_hmac_internal(v15, a3, a4, a5, a6, a7, *((void *)a1 + 1), &a1[-*((void *)a1 + 1) + 4112]);
  }
  else
  {
    *((void *)a1 + 1) = 0;
    uint64_t v14 = 4294967289;
  }
  cc_disable_dit_with_sb((unsigned int *)&v17);
  return v14;
}

uint64_t ccrng_pbkdf2_prng_generate(uint64_t a1, size_t __n, void *__dst)
{
  size_t v3 = *(void *)(a1 + 8);
  if (v3 < __n) {
    return 4294967286;
  }
  memcpy(__dst, (const void *)(a1 - v3 + 4112), __n);
  uint64_t result = 0;
  *(void *)(a1 + 8) -= __n;
  return result;
}

uint64_t ccn_cond_neg(uint64_t a1, char a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t result = ccn_mux_next_mask();
  uint64_t v9 = __ROR8__(0x5555555555555555, a2 | (2 * result));
  if (a1)
  {
    BOOL v10 = 1;
    do
    {
      uint64_t v12 = *a4++;
      uint64_t v11 = v12;
      BOOL v13 = v10 + ~v12;
      BOOL v10 = __CFADD__(v10, ~v12);
      uint64_t v14 = v11 ^ v13;
      uint64_t v15 = v11 ^ result;
      *a3 = v15;
      *a3++ = v14 & v9 ^ v14 & 0x5555555555555555 ^ v15 ^ result;
      --a1;
    }
    while (a1);
  }
  return result;
}

uint64_t cchkdf_extract_internal(uint64_t *a1, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = *MEMORY[0x263EF8C08];
  memset(v7, 0, sizeof(v7));
  if (!a2)
  {
    a2 = *a1;
    a3 = v7;
  }
  cchmac_internal((uint64_t)a1, a2, (uint64_t)a3, a4, a5, a6);
  return 0;
}

uint64_t cchkdf_extract(uint64_t *a1, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v15 = *MEMORY[0x263EF8C08];
  BOOL v13 = timingsafe_enable_if_supported();
  memset(v14, 0, sizeof(v14));
  if (!a2)
  {
    a2 = *a1;
    a3 = v14;
  }
  cchmac_internal((uint64_t)a1, a2, (uint64_t)a3, a4, a5, a6);
  cc_disable_dit_with_sb((unsigned int *)&v13);
  return 0;
}

uint64_t cchkdf_expand_internal(rsize_t *a1, rsize_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v30 = a5;
  uint64_t v31 = a7;
  uint64_t v34 = *MEMORY[0x263EF8C08];
  rsize_t v8 = *a1;
  uint64_t result = 4294967289;
  if (v8 <= a2)
  {
    unint64_t v10 = a6 + v8 - 1;
    unint64_t v11 = v10 / v8;
    if (v10 / v8 <= 0xFF)
    {
      uint64_t v28 = (uint64_t)&v28;
      uint64_t v29 = a6;
      uint64_t v13 = MEMORY[0x270FA53B0](4294967289, a2, a2, a3);
      uint64_t v15 = (char *)&v28 - v14;
      MEMORY[0x270FA53B0](v13, v16, v17, v18);
      BOOL v20 = (char *)&v28 - v19;
      cchmac_init_internal((uint64_t)a1, (uint64_t *)((char *)&v28 - v19), v21, v22);
      if (v8 <= v10)
      {
        uint64_t v23 = 0;
        uint64_t v24 = 0;
        rsize_t v25 = 0;
        if (v11 <= 1) {
          uint64_t v26 = 1;
        }
        else {
          uint64_t v26 = v10 / v8;
        }
        do
        {
          memcpy(v15, v20, ((a1[1] + a1[2] + 19) & 0xFFFFFFFFFFFFFFF8) + a1[1]);
          cchmac_update_internal(a1, v15, v25, __src);
          cchmac_update_internal(a1, v15, a4, v30);
          char v32 = v23 + 1;
          cchmac_update_internal(a1, v15, 1, &v32);
          cchmac_final_internal((uint64_t)a1, v15, (uint64_t)__src);
          if (v11 - 1 == v23) {
            size_t v27 = v29 - v24;
          }
          else {
            size_t v27 = *a1;
          }
          memcpy((void *)(v31 + v24), __src, v27);
          rsize_t v25 = *a1;
          v24 += *a1;
          ++v23;
        }
        while (v26 != v23);
      }
      cc_clear(((a1[1] + a1[2] + 19) & 0xFFFFFFFFFFFFFFF8) + a1[1], v20);
      cc_clear(((a1[1] + a1[2] + 19) & 0xFFFFFFFFFFFFFFF8) + a1[1], v15);
      cc_clear(*a1, __src);
      return 0;
    }
  }
  return result;
}

uint64_t cchkdf_expand(rsize_t *a1, rsize_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  BOOL v16 = timingsafe_enable_if_supported();
  uint64_t v14 = cchkdf_expand_internal(a1, a2, a3, a4, a5, a6, a7);
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v14;
}

uint64_t cchkdf_internal(rsize_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, _OWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v13 = a4;
  uint64_t v19 = *MEMORY[0x263EF8C08];
  memset(v18, 0, sizeof(v18));
  if (!a4)
  {
    uint64_t v13 = *a1;
    a5 = v18;
  }
  cchmac_internal((uint64_t)a1, v13, (uint64_t)a5, a2, a3, (uint64_t)v17);
  uint64_t v15 = cchkdf_expand_internal(a1, *a1, (uint64_t)v17, a6, a7, a8, a9);
  cc_clear(*a1, v17);
  return v15;
}

uint64_t cchkdf(rsize_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, _OWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  BOOL v19 = timingsafe_enable_if_supported();
  uint64_t v17 = cchkdf_internal(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  cc_disable_dit_with_sb((unsigned int *)&v19);
  return v17;
}

BOOL ccwrap_argsvalid(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ((a3 | a2) & 7) == 0
      && *(void *)(a1 + 8) == 16
      && a2 + 8 == a3
      && (unint64_t)(a2 - 16) < 0xFFF8;
}

uint64_t ccn_shift_left(uint64_t result, void *a2, unint64_t *a3, unint64_t a4)
{
  if (result)
  {
    unint64_t v4 = a3[result - 1];
    if (result == 1)
    {
      unint64_t v8 = *a3;
    }
    else
    {
      unint64_t v5 = ((a4 | HIDWORD(a4)) + 0xFFFFFFFF) >> 32;
      uint64_t v6 = -(uint64_t)v5;
      char v7 = v5 - a4 + 63;
      do
      {
        unint64_t v8 = a3[result - 2];
        a2[--result] = (v8 >> v7) & v6 | (v4 << a4);
        unint64_t v4 = v8;
      }
      while (result != 1);
    }
    *a2 = v8 << a4;
  }
  return result;
}

uint64_t ccspake_prover_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, unint64_t a7, uint64_t a8, uint64_t a9)
{
  BOOL v19 = timingsafe_enable_if_supported();
  uint64_t inited = ccspake_prover_init_internal(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  cc_disable_dit_with_sb((unsigned int *)&v19);
  return inited;
}

uint64_t ccspake_prover_init_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, unint64_t a7, uint64_t a8, uint64_t a9)
{
  rsize_t v16 = ccspake_sizeof_ctx(a2);
  cc_clear(v16, (void *)a1);
  if (*(_DWORD *)a2) {
    return 4294967289;
  }
  unint64_t v18 = ccspake_sizeof_w(a2);
  uint64_t result = 4294967289;
  if (a5 <= 0x14 && v18 == a7)
  {
    *(void *)a1 = a2;
    *(void *)(a1 + 8) = a3;
    *(void *)(a1 + 16) = a4;
    *(void *)(a1 + 32) = a5;
    *(unsigned char *)(a1 + 24) = 1;
    *(unsigned char *)(a1 + 60) = CCSPAKE_STATE_INIT;
    if (a5) {
      uint64_t result = __memcpy_chk();
    }
    BOOL v19 = (void *)(*(uint64_t (**)(uint64_t))(a2 + 8))(result);
    (*(void (**)(void))(*(void *)a1 + 8))();
    uint64_t result = ccec_generate_scalar_fips_extrabits(v19, a7, a8, (char *)(a1 + 336));
    if (!result)
    {
      BOOL v20 = (void *)(*(uint64_t (**)(void))(*(void *)a1 + 8))();
      uint64_t result = ccec_generate_scalar_fips_extrabits(v19, a7, a9, (char *)(a1 + 336 + 8 * *v20));
      if (!result)
      {
        ccspake_transcript_init(a1);
        return 0;
      }
    }
  }
  return result;
}

uint64_t ccspake_prover_initialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, char *a6, size_t a7, char *a8, size_t a9, char *a10, unint64_t a11, uint64_t a12, uint64_t a13)
{
  BOOL v28 = timingsafe_enable_if_supported();
  if (!*(_DWORD *)a2)
  {
    if (!((unint64_t)a8 | (unint64_t)a10))
    {
      uint64_t inited = ccspake_prover_init_internal(a1, a2, a3, a4, a5, (uint64_t)a6, a11, a12, a13);
LABEL_10:
      uint64_t v24 = inited;
      goto LABEL_11;
    }
LABEL_8:
    uint64_t v24 = 4294967289;
    goto LABEL_11;
  }
  if (!a5 || ccspake_sizeof_w(a2) != a11) {
    goto LABEL_8;
  }
  rsize_t v19 = ccspake_sizeof_ctx(a2);
  uint64_t v20 = cc_clear(v19, (void *)a1);
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a4;
  *(void *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 24) = 1;
  *(unsigned char *)(a1 + 60) = CCSPAKE_STATE_INIT;
  uint64_t v21 = *(void *)(*(uint64_t (**)(uint64_t))(a2 + 8))(v20);
  (*(void (**)(void))(*(void *)a1 + 8))();
  uint64_t inited = ccn_read_uint_internal(v21, a1 + 336, a11, a12);
  if (inited) {
    goto LABEL_10;
  }
  uint64_t v23 = (void *)(*(uint64_t (**)(void))(*(void *)a1 + 8))();
  uint64_t inited = ccn_read_uint_internal(v21, a1 + 336 + 8 * *v23, a11, a13);
  if (inited) {
    goto LABEL_10;
  }
  ccspake_transcript_init(a1);
  ccspake_transcript_begin(a1, a5, a6, a7, a8, a9, a10);
  uint64_t v24 = 0;
LABEL_11:
  cc_disable_dit_with_sb((unsigned int *)&v28);
  return v24;
}

uint64_t ccspake_verifier_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, unint64_t a7, uint64_t a8, uint64_t a9)
{
  BOOL v31 = timingsafe_enable_if_supported();
  rsize_t v16 = (uint64_t *)(*(uint64_t (**)(void))(a2 + 8))();
  uint64_t v17 = *v16;
  uint64_t v18 = sizeof_struct_cche_galois_key();
  unint64_t v19 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v20 = 20 * v17;
  if (20 * v17 <= 4 * v17 + (v19 + 127) / v19 + 3) {
    unint64_t v20 = 4 * v17 + (v19 + 127) / v19 + 3;
  }
  uint64_t v21 = cc_malloc_clear(8 * (v20 + (v18 + v19 + v19 * 3 * v17 - 1) / v19));
  v29[0] = v21;
  uint64_t v22 = *v16;
  uint64_t v23 = sizeof_struct_cche_galois_key();
  unint64_t v24 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v25 = 20 * v22;
  if (20 * v22 <= 4 * v22 + (v24 + 127) / v24 + 3) {
    unint64_t v25 = 4 * v22 + (v24 + 127) / v24 + 3;
  }
  v29[1] = v25 + (v23 + v24 + v24 * 3 * v22 - 1) / v24;
  v29[2] = 0;
  v29[3] = cc_ws_alloc;
  uint64_t v30 = cc_ws_free;
  if (v21)
  {
    uint64_t inited = ccspake_verifier_init_ws((uint64_t)v29, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    v30((uint64_t)v29);
  }
  else
  {
    uint64_t inited = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v31);
  return inited;
}

uint64_t ccspake_verifier_init_ws(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, unint64_t a8, uint64_t a9, uint64_t a10)
{
  rsize_t v17 = ccspake_sizeof_ctx(a3);
  cc_clear(v17, (void *)a2);
  if (*(_DWORD *)a3 || ccspake_sizeof_w(a3) != a8) {
    return 4294967289;
  }
  unint64_t v18 = ccspake_sizeof_point(a3);
  uint64_t result = 4294967289;
  if (a6 <= 0x14 && v18 == a10)
  {
    unint64_t v20 = (uint64_t *)(*(uint64_t (**)(uint64_t))(a3 + 8))(4294967289);
    uint64_t v24 = *(void *)(a1 + 16);
    uint64_t v21 = (uint64_t **)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, (unint64_t)(24 * *v20 + 23) >> 3);
    uint64_t v22 = v21;
    *uint64_t v21 = v20;
    *(void *)a2 = a3;
    *(void *)(a2 + 8) = a4;
    *(void *)(a2 + 16) = a5;
    *(void *)(a2 + 32) = a6;
    *(unsigned char *)(a2 + 24) = 0;
    *(unsigned char *)(a2 + 60) = CCSPAKE_STATE_INIT;
    if (a6) {
      uint64_t v21 = (uint64_t **)__memcpy_chk();
    }
    (*(void (**)(uint64_t **))(a3 + 8))(v21);
    uint64_t result = ccec_generate_scalar_fips_extrabits_ws(a1, v20, a8, a9, (char *)(a2 + 336));
    if (!result)
    {
      uint64_t result = ccspake_import_pub_ws(a1);
      if (!result)
      {
        uint64_t v23 = (void *)(*(uint64_t (**)(void))(*(void *)a2 + 8))();
        ccspake_store_pub_key(v22, (char *)(a2 + 336 + 8 * *v23));
        ccspake_transcript_init(a2);
        uint64_t result = 0;
      }
    }
    *(void *)(a1 + 16) = v24;
  }
  return result;
}

uint64_t ccspake_verifier_initialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, size_t a5, char *a6, size_t a7, char *a8, size_t a9, char *a10, unint64_t a11, uint64_t a12, uint64_t a13)
{
  v44[0] = timingsafe_enable_if_supported();
  unint64_t v20 = (uint64_t *)(*(uint64_t (**)(void))(a2 + 8))();
  uint64_t v21 = *v20;
  uint64_t v22 = sizeof_struct_cche_galois_key();
  unint64_t v23 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v24 = 4 * v21 + (v23 + 127) / v23 + 3;
  if (20 * v21 > v24) {
    unint64_t v24 = 20 * v21;
  }
  unint64_t v25 = cc_malloc_clear(8 * v24 + 16 * ((v22 + v23 + v23 * 3 * v21 - 1) / v23));
  v40[0] = v25;
  uint64_t v26 = *v20;
  uint64_t v27 = sizeof_struct_cche_galois_key();
  unint64_t v28 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v29 = 4 * v26 + (v28 + 127) / v28 + 3;
  if (20 * v26 > v29) {
    unint64_t v29 = 20 * v26;
  }
  v40[1] = v29 + 2 * ((v27 + v28 + v28 * 3 * v26 - 1) / v28);
  uint64_t v41 = 0;
  BOOL v42 = cc_ws_alloc;
  BOOL v43 = cc_ws_free;
  if (v25)
  {
    if (*(_DWORD *)a2)
    {
      if (a5 && ccspake_sizeof_point(a2) == a13 && ccspake_sizeof_w(a2) == a11)
      {
        rsize_t v30 = ccspake_sizeof_ctx(a2);
        uint64_t v31 = cc_clear(v30, (void *)a1);
        BOOL v37 = (uint64_t *)(*(uint64_t (**)(uint64_t))(a2 + 8))(v31);
        uint64_t v38 = *v37;
        unint64_t v36 = (uint64_t **)cc_ws_alloc(v40, (unint64_t)(24 * *v37 + 23) >> 3);
        *unint64_t v36 = v37;
        *(void *)a1 = a2;
        *(void *)(a1 + 8) = a3;
        *(void *)(a1 + 16) = a4;
        *(void *)(a1 + 32) = 0;
        *(unsigned char *)(a1 + 24) = 0;
        *(unsigned char *)(a1 + 60) = CCSPAKE_STATE_INIT;
        (*(void (**)(void))(a2 + 8))();
        uint64_t uint_internal = ccn_read_uint_internal(v38, a1 + 336, a11, a12);
        if (uint_internal || (uint64_t uint_internal = ccspake_import_pub_ws((uint64_t)v40), uint_internal))
        {
          uint64_t inited = uint_internal;
        }
        else
        {
          int v33 = (void *)(*(uint64_t (**)(void))(*(void *)a1 + 8))();
          ccspake_store_pub_key(v36, (char *)(a1 + 336 + 8 * *v33));
          ccspake_transcript_init(a1);
          ccspake_transcript_begin(a1, a5, a6, a7, a8, a9, a10);
          uint64_t inited = 0;
        }
        uint64_t v41 = 0;
        goto LABEL_18;
      }
    }
    else if (!((unint64_t)a8 | (unint64_t)a10))
    {
      uint64_t inited = ccspake_verifier_init_ws((uint64_t)v40, a1, a2, a3, a4, a5, (uint64_t)a6, a11, a12, a13);
      goto LABEL_18;
    }
    uint64_t inited = 4294967289;
LABEL_18:
    v43((uint64_t)v40);
    goto LABEL_19;
  }
  uint64_t inited = 4294967283;
LABEL_19:
  cc_disable_dit_with_sb((unsigned int *)v44);
  return inited;
}

uint64_t ccecies_encrypt_gcm_encrypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v25 = *MEMORY[0x263EF8C08];
  uint64_t v8 = *(void *)(a1 + 16);
  if (*(_DWORD *)(v8 + 8) != 4073947) {
    return 4294967291;
  }
  uint64_t v23 = a8;
  unint64_t v24 = &v22;
  uint64_t v15 = a2 + *(unsigned int *)(a1 + 24);
  MEMORY[0x270FA53B0](a1, a2, a3, a2);
  rsize_t v17 = (char *)&v22 - v16;
  int inited = ccgcm_init_internal(v8);
  int v19 = ccgcm_set_iv_internal(v8, (uint64_t)v17, 16, v15) | inited;
  if (a3 && a4) {
    v19 |= ccgcm_aad_internal(v8, (uint64_t)v17, a3, a4);
  }
  uint64_t v20 = ccgcm_update_internal(v8, (uint64_t)v17, a5, a6, a7) | v19;
  if (!v20) {
    uint64_t v20 = ccgcm_finalize_internal(v8, (uint64_t)v17, *(unsigned int *)(a1 + 28), v23);
  }
  cc_clear(*(void *)v8, v17);
  return v20;
}

unint64_t ccec_export_affine_point_size(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 1:
    case 2:
      unint64_t result = ((unint64_t)(cczp_bitlen(a1) + 7) >> 2) | 1;
      break;
    case 3:
      unint64_t result = ccec_compressed_x962_export_pub_size(a1);
      break;
    case 4:
      unint64_t result = (unint64_t)(cczp_bitlen(a1) + 7) >> 3;
      break;
    default:
      unint64_t result = 0;
      break;
  }
  return result;
}

uint64_t ccec_export_affine_point_public_value(unint64_t *a1, int a2, unint64_t *a3, unint64_t *a4, char *a5)
{
  unint64_t v10 = ccec_export_affine_point_size((uint64_t)a1, a2);
  if (!v10) {
    return 4294967289;
  }
  if (*a4 < v10) {
    return 4294967133;
  }
  *a4 = v10;
  unsigned int v11 = a2 - 1;
  if ((a2 - 1) <= 2) {
    *a5 = 0x20604u >> (8 * v11);
  }
  unint64_t v12 = *a1;
  if (a2 == 4) {
    uint64_t v13 = a5;
  }
  else {
    uint64_t v13 = a5 + 1;
  }
  uint64_t v14 = cczp_bitlen((uint64_t)a1);
  if ((ccn_write_uint_padded_ct_internal(v12, a3, (unint64_t)(v14 + 7) >> 3, v13) & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  if (v11 <= 1)
  {
    uint64_t v15 = &v13[(unint64_t)(cczp_bitlen((uint64_t)a1) + 7) >> 3];
    uint64_t v16 = &a3[*a1];
    uint64_t v17 = cczp_bitlen((uint64_t)a1);
    if ((ccn_write_uint_padded_ct_internal(v12, v16, (unint64_t)(v17 + 7) >> 3, v15) & 0x80000000) != 0) {
      return 0xFFFFFFFFLL;
    }
  }
  uint64_t result = 0;
  if ((a2 & 0xFFFFFFFE) == 2) {
    *a5 |= a3[*a1] & 1;
  }
  return result;
}

uint64_t ccec_export_affine_point(unint64_t *a1, int a2, unint64_t *a3, unint64_t *a4, char *a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = ccec_export_affine_point_public_value(a1, a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t CC_CAST_set_key(uint64_t result, unint64_t a2, unsigned __int8 *a3)
{
  uint64_t v94 = *MEMORY[0x263EF8C08];
  long long v90 = 0u;
  long long v91 = 0u;
  long long v92 = 0u;
  long long v93 = 0u;
  unint64_t v3 = 16;
  if (a2 < 0x10) {
    unint64_t v3 = a2;
  }
  if (v3)
  {
    unint64_t v4 = &v90;
    unint64_t v5 = v3;
    do
    {
      int v6 = *a3++;
      *(_DWORD *)unint64_t v4 = v6;
      unint64_t v4 = (long long *)((char *)v4 + 4);
      --v5;
    }
    while (v5);
    BOOL v7 = v3 < 0xB;
  }
  else
  {
    BOOL v7 = 1;
  }
  int v8 = v90;
  int v9 = DWORD1(v90) << 16;
  *(_DWORD *)(result + 128) = v7;
  unsigned int v10 = v9 | (v8 << 24) | (DWORD2(v90) << 8) | HIDWORD(v90);
  unsigned int v11 = (DWORD1(v91) << 16) | (v91 << 24) | (DWORD2(v91) << 8) | HIDWORD(v91);
  int v12 = DWORD1(v92);
  int v13 = DWORD2(v92);
  int v14 = HIDWORD(v92);
  unsigned int v15 = (DWORD1(v92) << 16) | (v92 << 24) | (DWORD2(v92) << 8) | HIDWORD(v92);
  unsigned int v16 = v93;
  int v17 = DWORD1(v93);
  int v18 = DWORD2(v93);
  unsigned int v19 = (DWORD1(v93) << 16) | (v93 << 24) | (DWORD2(v93) << 8) | HIDWORD(v93);
  int v20 = CC_CAST_S_table5[HIDWORD(v93)];
  uint64_t v21 = (int *)v89;
  int v22 = CC_CAST_S_table6[v92];
  do
  {
    unsigned int v23 = CC_CAST_S_table4[v17] ^ v10 ^ v20 ^ CC_CAST_S_table6[v16] ^ CC_CAST_S_table7[v18] ^ v22;
    int v24 = CC_CAST_S_table6[BYTE2(v23)];
    int v25 = v23;
    unsigned int v26 = CC_CAST_S_table4[HIBYTE(v23)] ^ v15 ^ CC_CAST_S_table5[BYTE1(v23)] ^ CC_CAST_S_table7[v23] ^ CC_CAST_S_table7[v13] ^ v24;
    int v27 = CC_CAST_S_table7[HIBYTE(v26)];
    int v28 = CC_CAST_S_table5[BYTE1(v26)] ^ CC_CAST_S_table6[BYTE2(v26)];
    unsigned int v29 = v19 ^ CC_CAST_S_table4[v12] ^ CC_CAST_S_table4[v26] ^ v28 ^ v27;
    int v30 = CC_CAST_S_table4[BYTE1(v29)];
    int v31 = CC_CAST_S_table5[BYTE2(v29)];
    unsigned int v32 = v11 ^ CC_CAST_S_table6[v29] ^ CC_CAST_S_table7[HIBYTE(v29)] ^ CC_CAST_S_table5[v14] ^ v30 ^ v31;
    int v33 = CC_CAST_S_table7[BYTE1(v26)];
    int v34 = v28 ^ v27 ^ CC_CAST_S_table5[v29] ^ v30;
    int v35 = CC_CAST_S_table6[v23];
    int v36 = CC_CAST_S_table7[BYTE1(v23)];
    int v37 = CC_CAST_S_table6[BYTE2(v29)];
    *uint64_t v21 = CC_CAST_S_table4[HIBYTE(v29)] ^ CC_CAST_S_table6[v26] ^ CC_CAST_S_table4[BYTE1(v23)] ^ v31 ^ v33;
    v21[1] = v34;
    unsigned int v38 = CC_CAST_S_table4[BYTE2(v26)] ^ CC_CAST_S_table5[v26] ^ CC_CAST_S_table6[HIBYTE(v26)] ^ CC_CAST_S_table6[HIBYTE(v23)] ^ v33 ^ v29;
    int v39 = (LOBYTE(CC_CAST_S_table4[BYTE2(v26)]) ^ LOBYTE(CC_CAST_S_table5[v26]) ^ LOBYTE(CC_CAST_S_table6[HIBYTE(v26)]) ^ LOBYTE(CC_CAST_S_table6[HIBYTE(v23)]) ^ v33 ^ v29);
    int v40 = CC_CAST_S_table5[BYTE1(v38)];
    unsigned int v41 = CC_CAST_S_table4[HIBYTE(v38)] ^ CC_CAST_S_table6[BYTE2(v38)] ^ CC_CAST_S_table7[v39] ^ v23 ^ v36 ^ v40;
    int v42 = CC_CAST_S_table5[BYTE1(v41)] ^ CC_CAST_S_table4[v41];
    int v43 = CC_CAST_S_table4[BYTE1(v32)] ^ CC_CAST_S_table5[v32] ^ CC_CAST_S_table7[HIBYTE(v23)] ^ CC_CAST_S_table7[HIBYTE(v32)] ^ v24;
    unsigned int v44 = CC_CAST_S_table6[BYTE2(v41)] ^ CC_CAST_S_table7[HIBYTE(v41)] ^ CC_CAST_S_table4[BYTE2(v23)] ^ v26 ^ v42;
    int v45 = v44;
    int v46 = BYTE2(v44);
    int v47 = CC_CAST_S_table7[HIBYTE(v44)];
    unsigned int v48 = CC_CAST_S_table4[BYTE1(v44)] ^ CC_CAST_S_table5[BYTE2(v44)] ^ CC_CAST_S_table6[v44] ^ v47 ^ CC_CAST_S_table5[v25] ^ v32;
    int v49 = (LOBYTE(CC_CAST_S_table4[BYTE1(v44)]) ^ LOBYTE(CC_CAST_S_table5[BYTE2(v44)]) ^ LOBYTE(CC_CAST_S_table6[v44]) ^ v47 ^ LOBYTE(CC_CAST_S_table5[v25]) ^ v32);
    int v50 = CC_CAST_S_table4[v39];
    uint64_t v21[2] = CC_CAST_S_table5[BYTE2(v32)] ^ CC_CAST_S_table4[HIBYTE(v32)] ^ v35 ^ v37 ^ v36;
    v21[3] = v43;
    int v51 = CC_CAST_S_table6[HIBYTE(v48)];
    int v52 = CC_CAST_S_table6[HIBYTE(v44)];
    int v53 = v50 ^ CC_CAST_S_table4[HIBYTE(v44)] ^ v40 ^ CC_CAST_S_table7[BYTE2(v48)];
    int v54 = CC_CAST_S_table5[HIBYTE(v38)] ^ CC_CAST_S_table4[BYTE2(v38)] ^ CC_CAST_S_table6[BYTE1(v48)];
    int v55 = CC_CAST_S_table7[v49] ^ CC_CAST_S_table5[BYTE2(v48)];
    int v56 = CC_CAST_S_table5[HIBYTE(v41)] ^ CC_CAST_S_table4[BYTE2(v41)] ^ CC_CAST_S_table6[BYTE1(v44)] ^ CC_CAST_S_table7[v44] ^ CC_CAST_S_table7[v41];
    v21[6] = CC_CAST_S_table7[BYTE2(v44)] ^ CC_CAST_S_table6[v39] ^ v42 ^ v52;
    v21[7] = v56;
    int v57 = CC_CAST_S_table4[BYTE2(v48)] ^ CC_CAST_S_table5[v49];
    int v58 = CC_CAST_S_table7[BYTE1(v48)] ^ v38;
    v21[4] = v53 ^ v51;
    v21[5] = v54 ^ v55;
    unsigned int v59 = v57 ^ v58 ^ v51 ^ v52;
    int v60 = CC_CAST_S_table5[BYTE1(v59)];
    int v61 = v59;
    unsigned int v62 = CC_CAST_S_table4[HIBYTE(v59)] ^ CC_CAST_S_table6[BYTE2(v59)] ^ CC_CAST_S_table7[v59] ^ CC_CAST_S_table7[BYTE1(v44)] ^ v44 ^ v60;
    int v63 = CC_CAST_S_table5[BYTE1(v62)] ^ CC_CAST_S_table4[v62];
    unsigned int v64 = CC_CAST_S_table6[BYTE2(v62)] ^ CC_CAST_S_table7[HIBYTE(v62)] ^ CC_CAST_S_table4[v46] ^ v48 ^ v63;
    unsigned int v65 = CC_CAST_S_table4[BYTE1(v64)] ^ CC_CAST_S_table5[BYTE2(v64)] ^ CC_CAST_S_table6[v64] ^ CC_CAST_S_table7[HIBYTE(v64)] ^ CC_CAST_S_table5[v45] ^ v41;
    int v66 = CC_CAST_S_table4[BYTE2(v62)];
    int v67 = CC_CAST_S_table4[BYTE2(v59)];
    int v68 = CC_CAST_S_table7[BYTE1(v62)];
    int v69 = CC_CAST_S_table5[HIBYTE(v62)] ^ CC_CAST_S_table6[BYTE1(v64)] ^ CC_CAST_S_table7[v64] ^ v66 ^ v68;
    unsigned int v10 = CC_CAST_S_table5[v62] ^ CC_CAST_S_table6[HIBYTE(v62)] ^ CC_CAST_S_table6[HIBYTE(v59)] ^ v66 ^ v68 ^ v64;
    int v70 = CC_CAST_S_table6[BYTE2(v10)];
    int v71 = CC_CAST_S_table4[v59] ^ CC_CAST_S_table6[HIBYTE(v65)] ^ CC_CAST_S_table7[BYTE2(v65)] ^ CC_CAST_S_table4[BYTE2(v64)];
    unsigned int v11 = CC_CAST_S_table4[HIBYTE(v10)] ^ CC_CAST_S_table5[BYTE1(v10)] ^ CC_CAST_S_table7[v10] ^ CC_CAST_S_table7[BYTE1(v59)] ^ v59 ^ v70;
    int v72 = (LOBYTE(CC_CAST_S_table4[HIBYTE(v10)]) ^ LOBYTE(CC_CAST_S_table5[BYTE1(v10)]) ^ LOBYTE(CC_CAST_S_table7[v10]) ^ LOBYTE(CC_CAST_S_table7[BYTE1(v59)]) ^ v59 ^ v70);
    int v73 = CC_CAST_S_table5[HIBYTE(v59)] ^ CC_CAST_S_table6[BYTE1(v65)] ^ CC_CAST_S_table7[v65] ^ CC_CAST_S_table5[HIBYTE(v65)];
    int v74 = CC_CAST_S_table4[(LOBYTE(CC_CAST_S_table4[HIBYTE(v10)]) ^ LOBYTE(CC_CAST_S_table5[BYTE1(v10)]) ^ LOBYTE(CC_CAST_S_table7[v10]) ^ LOBYTE(CC_CAST_S_table7[BYTE1(v59)]) ^ v59 ^ v70)];
    v21[10] = CC_CAST_S_table6[HIBYTE(v64)] ^ CC_CAST_S_table7[BYTE2(v64)] ^ CC_CAST_S_table6[BYTE1(v59)] ^ v63;
    v21[11] = v69;
    int v75 = v71 ^ v60;
    int v76 = CC_CAST_S_table6[BYTE2(v11)];
    int v77 = CC_CAST_S_table7[HIBYTE(v11)];
    int v78 = v74 ^ CC_CAST_S_table5[BYTE1(v11)] ^ v76 ^ v77;
    v21[8] = v75;
    v21[9] = v73 ^ v67;
    unsigned int v15 = v78 ^ v62 ^ v67;
    int v14 = (v78 ^ v62 ^ v67);
    int v13 = BYTE1(v15);
    int v79 = CC_CAST_S_table4[BYTE1(v15)];
    int v12 = BYTE2(v15);
    int v80 = CC_CAST_S_table5[v61] ^ v65;
    int v81 = CC_CAST_S_table5[BYTE2(v15)];
    unsigned int v19 = CC_CAST_S_table6[v14] ^ CC_CAST_S_table7[HIBYTE(v15)] ^ v80 ^ v79 ^ v81;
    int v82 = CC_CAST_S_table4[HIBYTE(v15)] ^ CC_CAST_S_table6[v72] ^ CC_CAST_S_table7[BYTE1(v11)] ^ CC_CAST_S_table4[v10] ^ v81;
    int v18 = BYTE1(v19);
    int v17 = BYTE2(v19);
    int v83 = CC_CAST_S_table5[v14] ^ CC_CAST_S_table5[v72] ^ v76 ^ v77 ^ v79;
    unsigned int v16 = HIBYTE(v19);
    v21[12] = v82;
    v21[13] = v83;
    int v20 = CC_CAST_S_table5[v19];
    int v22 = CC_CAST_S_table6[HIBYTE(v15)];
    int v84 = CC_CAST_S_table4[BYTE1(v19)] ^ CC_CAST_S_table7[HIBYTE(v10)] ^ CC_CAST_S_table7[BYTE2(v19)] ^ v20 ^ v70;
    v21[14] = CC_CAST_S_table5[BYTE2(v19)] ^ CC_CAST_S_table4[HIBYTE(v19)] ^ CC_CAST_S_table6[v10] ^ CC_CAST_S_table7[BYTE1(v10)] ^ v22;
    v21[15] = v84;
    BOOL v85 = v21 == (int *)v89;
    v21 += 16;
  }
  while (v85);
  uint64_t v86 = 0;
  v87.i64[0] = 0x1000000010;
  v87.i64[1] = 0x1000000010;
  v88.i64[0] = 0x1F0000001FLL;
  v88.i64[1] = 0x1F0000001FLL;
  do
  {
    v95.val[0] = *(float32x4_t *)&v89[v86];
    v95.val[1] = (float32x4_t)vandq_s8((int8x16_t)vaddq_s32(*(int32x4_t *)&v89[v86 + 64], v87), v88);
    vst2q_f32((float *)result, v95);
    result += 32;
    v86 += 16;
  }
  while (v86 != 64);
  return result;
}

void *ccec_cp_x25519_opt()
{
  return &ccec_cp25519_opt_params;
}

void *ccaes_ccm_decrypt_mode()
{
  uint64_t v0 = ccaes_ecb_encrypt_mode();
  ccmode_factory_ccm_decrypt((uint64_t)&ccm_decrypt_info, v0);
  return &ccm_decrypt_info;
}

uint64_t ccrsa_oaep_decode_parameter_ws(uint64_t a1, uint64_t *a2, size_t *a3, void *a4, uint64_t a5, unint64_t *a6, size_t a7, char *a8)
{
  uint64_t v40 = *MEMORY[0x263EF8C08];
  uint64_t v15 = *a2;
  unint64_t v16 = a5 - 1;
  unint64_t v17 = ccrsa_n_from_size(a5);
  ccn_swap(v17, a6);
  uint64_t v18 = ccrsa_block_start(a5, a6, 0);
  if (v16 < ((2 * *a2) | 1uLL)) {
    return 4294967272;
  }
  int v20 = (unsigned __int8 *)v18;
  size_t v21 = v16 - v15;
  unint64_t v22 = (v16 - v15 + 7) >> 3;
  uint64_t v32 = *(void *)(a1 + 16);
  unsigned int v23 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v22);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v22);
  ccdigest_internal((uint64_t)a2, a7, a8, (uint64_t)__s);
  uint64_t v25 = *a2;
  __memcpy_chk();
  memcpy(v23, &v20[v25 + 1], v21);
  ccmgf_internal((uint64_t)a2, *a2, (uint64_t)v37, v21, (char *)v23);
  ccn_xor((unint64_t)(*a2 + 7) >> 3, (uint64_t)v38, (uint64_t)v38, (uint64_t)v37);
  ccmgf_internal((uint64_t)a2, v21, v24, *a2, v38);
  ccn_xor(v22, (uint64_t)v23, (uint64_t)v23, v24);
  int v34 = ((unint64_t)*v20 + 0xFFFFFFFF) >> 32;
  int v35 = v34 | cc_cmp_safe_internal(*a2, __s, (char *)v23);
  unint64_t v26 = *a2;
  if (*a2 >= v21)
  {
    unint64_t v27 = 0;
    int v28 = 1;
  }
  else
  {
    unint64_t v27 = 0;
    int v28 = 1;
    do
    {
      uint64_t v29 = v23[v26];
      unint64_t v27 = v27 & (v28 - 1) | v26 & -v28;
      v28 &= ((v29 ^ 1uLL) + 0xFFFFFFFF) >> 32;
      v35 |= v28 & ((unint64_t)(v29 + 0xFFFFFFFFLL) >> 32);
      ++v26;
    }
    while (v26 < v21);
  }
  unsigned int v36 = v35 | v28;
  if (!v36)
  {
    size_t v30 = v21 + ~v27;
    if (*a3 < v30)
    {
      int v31 = -23;
LABEL_14:
      unsigned int v36 = v31;
      goto LABEL_15;
    }
    memcpy(a4, &v23[v27 + 1], v30);
    *a3 = v30;
  }
  if (v36)
  {
    int v31 = -27;
    goto LABEL_14;
  }
LABEL_15:
  cc_clear(0x40uLL, __s);
  cc_clear(0x40uLL, v38);
  cc_clear(0x40uLL, v37);
  *(void *)(a1 + 16) = v32;
  return v36;
}

uint64_t ccrsa_oaep_decode_parameter(uint64_t *a1, size_t *a2, void *a3, uint64_t a4, unint64_t *a5, size_t a6, char *a7)
{
  BOOL v19 = timingsafe_enable_if_supported();
  unint64_t v14 = ((unint64_t)(a4 + ~*a1 + 7) >> 2) & 0x3FFFFFFFFFFFFFFELL;
  v17[0] = cc_malloc_clear(8 * v14);
  v17[1] = v14;
  v17[2] = 0;
  _OWORD v17[3] = cc_ws_alloc;
  uint64_t v18 = cc_ws_free;
  if (v17[0])
  {
    uint64_t v15 = ccrsa_oaep_decode_parameter_ws((uint64_t)v17, a1, a2, a3, a4, a5, a6, a7);
    v18((uint64_t)v17);
  }
  else
  {
    uint64_t v15 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v19);
  return v15;
}

unsigned __int8 *ccder_decode_rsa_pub_n(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unint64_t v3 = 0;
  unint64_t v4 = a2;
  uint64_t result = ccder_decode_constructed_tl(0x2000000000000010, &v4, a1, a2);
  if (result)
  {
    if (ccder_decode_uint_n(&v3, result, v4)) {
      return (unsigned __int8 *)v3;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t ccss_shamir_share_bag_add_share(uint64_t a1, uint64_t a2)
{
  char v4 = 0;
  char v16 = 0;
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    if ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) & 0x1000000) != 0)
    {
      char v4 = 0;
    }
    else
    {
      __asm { MSR             DIT, #1 }
      char v4 = 1;
    }
  }
  char v16 = v4;
  unsigned int v10 = *(_DWORD *)(a1 + 8);
  if (v10 >= **(_DWORD **)a1)
  {
    uint64_t v14 = 4294967170;
  }
  else if (v10)
  {
    unsigned int v11 = 0;
    while (1)
    {
      int v12 = *(_DWORD *)(a2 + 8);
      if (v12 == ccss_shamir_share_bag_copy_ith_share_x(a1, v11)) {
        break;
      }
      ++v11;
      unsigned int v13 = *(_DWORD *)(a1 + 8);
      if (v11 >= v13) {
        goto LABEL_13;
      }
    }
    uint64_t v14 = 4294967169;
  }
  else
  {
    unsigned int v13 = 0;
LABEL_13:
    uint64_t v14 = ccss_shamir_share_bag_set_ith_share((void *)a1, v13, a2);
    if (!v14) {
      ++*(_DWORD *)(a1 + 8);
    }
  }
  cc_disable_dit(&v16);
  return v14;
}

uint64_t fipspost_post_ffdh(char a1)
{
  uint64_t v42 = *MEMORY[0x263EF8C08];
  unsigned int v2 = ccdh_gp_rfc3526group14();
  uint64_t v3 = ccdh_ccn_size(v2);
  uint64_t v4 = sizeof_struct_cche_galois_key();
  unint64_t v5 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v6 = (v4 + v5 - 1) / v5;
  uint64_t v7 = CCDH_POWER_BLINDED_WORKSPACE_N(v3);
  v32[0] = cc_malloc_clear(8 * (v6 + 2 * v3 + v7));
  uint64_t v8 = ccdh_ccn_size(v2);
  uint64_t v9 = sizeof_struct_cche_galois_key();
  unint64_t v10 = sizeof_struct_ccpolyzp_po2cyc();
  v32[1] = (v9 + v10 - 1) / v10 + 2 * v8 + CCDH_POWER_BLINDED_WORKSPACE_N(v8);
  uint64_t v33 = 0;
  int v34 = cc_ws_alloc;
  int v35 = cc_ws_free;
  if (!v32[0]) {
    return 4294967283;
  }
  v38[12] = xmmword_2373AD534;
  v38[13] = unk_2373AD544;
  v38[14] = xmmword_2373AD554;
  v38[15] = unk_2373AD564;
  v38[8] = xmmword_2373AD4F4;
  v38[9] = unk_2373AD504;
  v38[10] = xmmword_2373AD514;
  v38[11] = unk_2373AD524;
  v38[4] = xmmword_2373AD4B4;
  v38[5] = unk_2373AD4C4;
  v38[6] = xmmword_2373AD4D4;
  v38[7] = unk_2373AD4E4;
  v38[0] = xmmword_2373AD474;
  v38[1] = unk_2373AD484;
  v38[2] = xmmword_2373AD494;
  v38[3] = unk_2373AD4A4;
  v37[12] = xmmword_2373AD634;
  v37[13] = unk_2373AD644;
  v37[14] = xmmword_2373AD654;
  v37[15] = unk_2373AD664;
  v37[8] = xmmword_2373AD5F4;
  v37[9] = unk_2373AD604;
  v37[10] = xmmword_2373AD614;
  v37[11] = unk_2373AD624;
  v37[4] = xmmword_2373AD5B4;
  v37[5] = unk_2373AD5C4;
  v37[6] = xmmword_2373AD5D4;
  v37[7] = unk_2373AD5E4;
  v37[0] = xmmword_2373AD574;
  v37[1] = unk_2373AD584;
  v37[2] = xmmword_2373AD594;
  v37[3] = unk_2373AD5A4;
  uint64_t v11 = ccdh_ccn_size(v2);
  int v12 = (void *)cc_ws_alloc(v32, 2 * v11 + 2);
  if (ccdh_import_full((uint64_t)v2, 256, (uint64_t)v38, 0x100uLL, (unsigned __int8 *)v37, v12))
  {
    uint64_t v13 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccdh_import_full\n", v13, "fipspost_post_ffdh", 226);
    uint64_t v14 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v15 = ccdh_gp_rfc3526group14();
    uint64_t v16 = (uint64_t)v15;
    v41[12] = xmmword_2373AD734;
    v41[13] = unk_2373AD744;
    v41[14] = xmmword_2373AD754;
    v41[15] = unk_2373AD764;
    v41[8] = xmmword_2373AD6F4;
    v41[9] = unk_2373AD704;
    v41[10] = xmmword_2373AD714;
    v41[11] = unk_2373AD724;
    v41[4] = xmmword_2373AD6B4;
    v41[5] = unk_2373AD6C4;
    v41[6] = xmmword_2373AD6D4;
    v41[7] = unk_2373AD6E4;
    v41[0] = xmmword_2373AD674;
    v41[1] = unk_2373AD684;
    v41[2] = xmmword_2373AD694;
    v41[3] = unk_2373AD6A4;
    __s2[12] = xmmword_2373AD834;
    __s2[13] = unk_2373AD844;
    __s2[14] = xmmword_2373AD854;
    __s2[15] = unk_2373AD864;
    __s2[8] = xmmword_2373AD7F4;
    __s2[9] = unk_2373AD804;
    __s2[10] = xmmword_2373AD814;
    __s2[11] = unk_2373AD824;
    __s2[4] = xmmword_2373AD7B4;
    __s2[5] = unk_2373AD7C4;
    __s2[6] = xmmword_2373AD7D4;
    __s2[7] = unk_2373AD7E4;
    __s2[0] = xmmword_2373AD774;
    __s2[1] = unk_2373AD784;
    __s2[2] = xmmword_2373AD794;
    __s2[3] = unk_2373AD7A4;
    if ((a1 & 0x10) != 0) {
      LOBYTE(__s2[0]) = -98;
    }
    unint64_t v36 = 256;
    uint64_t v17 = ccdh_ccn_size(v15);
    uint64_t v18 = v33;
    BOOL v19 = (void *)v34(v32, v17 + 2);
    if (ccdh_import_pub(v16, 0x100uLL, (unsigned __int8 *)v41, v19))
    {
      uint64_t v20 = mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccdh_import_pub\n", v20, "fipspost_post_ffdh_ws", 93);
      uint64_t v14 = 4294967224;
    }
    else
    {
      uint64_t v21 = ccdh_compute_shared_secret_ws((uint64_t)v32, v12, v19, &v36, (uint64_t)__s1, (uint64_t (**)(void, uint64_t, uint64_t *))&ccrng_zero);
      if (v21)
      {
        uint64_t v14 = v21;
        uint64_t v22 = mach_absolute_time();
        printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccdh_compute_shared_secret\n", v22, "fipspost_post_ffdh_ws", 101);
      }
      else if (!memcmp(__s1, __s2, 0x100uLL) && v36 == 256)
      {
        uint64_t v14 = 0;
      }
      else
      {
        uint64_t v23 = mach_absolute_time();
        printf("FIPSPOST_USER [%llu] %s:%d: FAILED: memcmp\n", v23, "fipspost_post_ffdh_ws", 106);
        uint64_t v14 = 4294967221;
      }
    }
    uint64_t v33 = v18;
    if ((a1 & 0x10) != 0)
    {
      uint64_t v24 = ccdh_gp_rfc3526group14();
      uint64_t v25 = v33;
      BOOL v26 = ccdh_pairwise_consistency_check_ws((uint64_t)v32, v24, (uint64_t (**)(void, uint64_t, uint64_t *))&ccrng_zero, v12);
      mach_absolute_time();
      if (v26) {
        printf("FIPSPOST_USER [%llu] %s:%d: [PCT] CCDH_PAIRWISE_CONSISTENCY: expected SUCCESS\n");
      }
      else {
        printf("FIPSPOST_USER [%llu] %s:%d: FAILED: [PCT] CCDH_PAIRWISE_CONSISTENCY: unexpected FAILURE\n");
      }
      uint64_t v27 = ccdh_gp_n(*v12);
      v12[v27 + 2] ^= 1uLL;
      BOOL v28 = ccdh_pairwise_consistency_check_ws((uint64_t)v32, v24, (uint64_t (**)(void, uint64_t, uint64_t *))&ccrng_zero, v12);
      uint64_t v29 = mach_absolute_time();
      if (v28)
      {
        printf("FIPSPOST_USER [%llu] %s:%d: FAILED: [PCT] CCDH_PAIRWISE_CONSISTENCY: Unexpected SUCCESS\n", v29, "fipspost_post_ffdh_pairwise_ws", 145);
        int v30 = -1;
      }
      else
      {
        printf("FIPSPOST_USER [%llu] %s:%d: [PCT] CCDH_PAIRWISE_CONSISTENCY: FORCEFAIL\n", v29, "fipspost_post_ffdh_pairwise_ws", 142);
        int v30 = 0;
      }
      uint64_t v33 = v25;
      uint64_t v14 = v30 | v14;
    }
  }
  v35((uint64_t)v32);
  return v14;
}

uint64_t ccmode_siv_hmac_temp_key_gen(rsize_t *a1, void *a2, long long *a3)
{
  uint64_t v16 = *MEMORY[0x263EF8C08];
  uint64_t v3 = *(void *)(*a1 + 64);
  if (*(void *)(v3 + 16) != 16) {
    return 4294967226;
  }
  long long v15 = *a3;
  HIBYTE(v15) &= ~0x80u;
  cc_clear(a1[1], __s);
  uint64_t v6 = ccctr_one_shot_internal(v3, a1[1] >> 1, (uint64_t)(a1 + 8), (uint64_t)&v15, a1[1], (uint64_t)__s, (uint64_t)&v12);
  *a2 = v12;
  if (a1[1] >= 0x20)
  {
    rsize_t v7 = 0;
    uint64_t v8 = a2 + 1;
    uint64_t v9 = &v13;
    do
    {
      uint64_t v10 = *v9;
      v9 += 2;
      *uint64_t v8 = v10;
      v8 += 2;
      ++v7;
    }
    while (v7 < a1[1] >> 5);
  }
  cc_clear(0x10uLL, &v15);
  return v6;
}

uint64_t ccz_random_bits(void *a1, uint64_t a2, uint64_t (**a3)(void, unint64_t, uint64_t))
{
  BOOL v9 = timingsafe_enable_if_supported();
  ccz_set_sign((uint64_t)a1, 1);
  ccz_set_capacity((uint64_t)a1, (unint64_t)(a2 + 63) >> 6);
  uint64_t v6 = ccn_random_bits(a2, a1[3], a3);
  unint64_t v7 = ccn_n((unint64_t)(a2 + 63) >> 6, a1[3]);
  ccz_set_n(a1, v7);
  cc_disable_dit_with_sb((unsigned int *)&v9);
  return v6;
}

uint64_t ccder_blob_encode_tl(uint64_t *a1, unint64_t a2, unint64_t a3)
{
  uint64_t result = ccder_blob_encode_len(a1, a3);
  if (result)
  {
    return ccder_blob_encode_tag(a1, a2);
  }
  return result;
}

uint64_t AccelerateCrypto_SHA3_keccak(uint64_t *a1)
{
  uint64_t result = *a1;
  uint64_t v3 = a1[1];
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  uint64_t v7 = a1[5];
  uint64_t v8 = a1[6];
  uint64_t v9 = a1[7];
  uint64_t v10 = a1[8];
  uint64_t v11 = a1[9];
  uint64_t v12 = a1[10];
  uint64_t v13 = a1[11];
  uint64_t v14 = a1[12];
  uint64_t v15 = a1[13];
  uint64_t v16 = a1[14];
  uint64_t v17 = a1[15];
  uint64_t v18 = a1[16];
  uint64_t v19 = a1[17];
  uint64_t v21 = a1[18];
  uint64_t v20 = a1[19];
  uint64_t v22 = a1[20];
  uint64_t v23 = a1[21];
  uint64_t v24 = a1[22];
  uint64_t v25 = a1[23];
  uint64_t v26 = a1[24];
  int v69 = a1;
  uint64_t v70 = 0;
  int v77 = &unk_2373AD878;
  do
  {
    uint64_t v71 = result;
    uint64_t v72 = v3;
    uint64_t v74 = v4;
    uint64_t v75 = v5;
    uint64_t v76 = v6;
    uint64_t v27 = result ^ v7 ^ v12 ^ v17 ^ v22;
    uint64_t v28 = v3 ^ v8 ^ v13 ^ v18 ^ v23;
    uint64_t v29 = v4 ^ v9 ^ v14 ^ v19 ^ v24;
    uint64_t v30 = v5 ^ v10 ^ v15 ^ v21 ^ v25;
    uint64_t v31 = v6 ^ v11 ^ v16 ^ v20 ^ v26;
    uint64_t v32 = v31 ^ __ROR8__(v28, 63);
    uint64_t v33 = v27 ^ __ROR8__(v29, 63);
    uint64_t v34 = v28 ^ __ROR8__(v30, 63);
    uint64_t v35 = v29 ^ __ROR8__(v31, 63);
    uint64_t v36 = v30 ^ __ROR8__(v27, 63);
    uint64_t v73 = __ROR8__(v72 ^ v33, 63);
    uint64_t v37 = __ROR8__(v8 ^ v33, 20);
    uint64_t v38 = __ROR8__(v11 ^ v36, 44);
    uint64_t v39 = __ROR8__(v24 ^ v34, 3);
    uint64_t v40 = __ROR8__(v16 ^ v36, 25);
    uint64_t v41 = __ROR8__(v22 ^ v32, 46);
    uint64_t v42 = __ROR8__(v74 ^ v34, 2);
    uint64_t v43 = __ROR8__(v14 ^ v34, 21);
    uint64_t v44 = __ROR8__(v15 ^ v35, 39);
    uint64_t v45 = __ROR8__(v20 ^ v36, 56);
    uint64_t v46 = __ROR8__(v25 ^ v35, 8);
    uint64_t v47 = __ROR8__(v17 ^ v32, 23);
    uint64_t v48 = __ROR8__(v76 ^ v36, 37);
    uint64_t v49 = __ROR8__(v26 ^ v36, 50);
    uint64_t v50 = __ROR8__(v23 ^ v33, 62);
    uint64_t v51 = __ROR8__(v10 ^ v35, 9);
    uint64_t v52 = __ROR8__(v18 ^ v33, 19);
    uint64_t v53 = __ROR8__(v7 ^ v32, 28);
    uint64_t v54 = __ROR8__(v75 ^ v35, 36);
    uint64_t v55 = __ROR8__(v21 ^ v35, 43);
    uint64_t v56 = __ROR8__(v19 ^ v34, 49);
    uint64_t v57 = __ROR8__(v13 ^ v33, 54);
    uint64_t v58 = __ROR8__(v9 ^ v34, 58);
    uint64_t v59 = __ROR8__(v12 ^ v32, 61);
    uint64_t v60 = v37 & ~(v71 ^ v32);
    uint64_t v61 = v71 ^ v32 ^ v43 & ~v37;
    uint64_t v3 = v37 ^ v55 & ~v43;
    uint64_t v4 = v43 ^ v49 & ~v55;
    uint64_t v5 = v55 ^ (v71 ^ v32) & ~v49;
    uint64_t v6 = v49 ^ v60;
    uint64_t result = v61 ^ *v77++;
    uint64_t v62 = v54 & ~v39;
    uint64_t v63 = v38 & ~v54;
    uint64_t v7 = v54 ^ v59 & ~v38;
    uint64_t v8 = v38 ^ v52 & ~v59;
    uint64_t v9 = v59 ^ v39 & ~v52;
    uint64_t v10 = v52 ^ v62;
    uint64_t v11 = v39 ^ v63;
    uint64_t v64 = v58 & ~v73;
    uint64_t v12 = v73 ^ v44 & ~v58;
    uint64_t v13 = v58 ^ v45 & ~v44;
    uint64_t v14 = v44 ^ v41 & ~v45;
    uint64_t v15 = v45 ^ v73 & ~v41;
    uint64_t v16 = v41 ^ v64;
    uint64_t v65 = v48 & ~v46;
    uint64_t v66 = v53 & ~v48;
    uint64_t v17 = v48 ^ v57 & ~v53;
    uint64_t v18 = v53 ^ v56 & ~v57;
    uint64_t v19 = v57 ^ v46 & ~v56;
    uint64_t v21 = v56 ^ v65;
    uint64_t v20 = v46 ^ v66;
    uint64_t v67 = v42 & ~v50;
    uint64_t v68 = v51 & ~v42;
    uint64_t v22 = v42 ^ v40 & ~v51;
    uint64_t v23 = v51 ^ v47 & ~v40;
    uint64_t v24 = v40 ^ v50 & ~v47;
    uint64_t v25 = v47 ^ v67;
    uint64_t v26 = v50 ^ v68;
    v70 += 8;
  }
  while (v70 != 192);
  *int v69 = result;
  v69[1] = v3;
  v69[2] = v4;
  v69[3] = v5;
  v69[4] = v6;
  v69[5] = v7;
  v69[6] = v8;
  v69[7] = v9;
  v69[8] = v10;
  v69[9] = v11;
  v69[10] = v12;
  v69[11] = v13;
  v69[12] = v14;
  v69[13] = v15;
  v69[14] = v16;
  v69[15] = v17;
  v69[16] = v18;
  v69[17] = v19;
  v69[18] = v21;
  v69[19] = v20;
  v69[20] = v22;
  v69[21] = v23;
  v69[22] = v24;
  v69[23] = v25;
  v69[24] = v26;
  return result;
}

uint64_t ccz_free(uint64_t a1)
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 && *(void *)(v2 + 24) && ccz_capacity(a1))
  {
    uint64_t v3 = *(uint64_t **)(a1 + 8);
    uint64_t v4 = (void (*)(uint64_t, uint64_t, void))v3[3];
    uint64_t v5 = *v3;
    uint64_t v6 = ccz_capacity(a1);
    v4(v5, v6, *(void *)(a1 + 24));
  }
  return cc_disable_dit_with_sb((unsigned int *)&v8);
}

BOOL ccdh_pairwise_consistency_check_ws(uint64_t a1, void *a2, uint64_t (**a3)(void, uint64_t, uint64_t *), void *a4)
{
  unint64_t v8 = cczp_n((uint64_t)a2);
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v22 = (unint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v8);
  uint64_t v10 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 2 * v8 + 2);
  uint64_t v11 = (void *)((uint64_t (*)(void))ccdh_ctx_public)();
  ccdh_ctx_init((uint64_t)a2, v11);
  uint64_t v12 = (uint64_t)&v10[ccdh_gp_n(*v10) + 2];
  ccn_set(1, (void *)v12, &REF_X);
  ccn_zero(v8 - 1, (void *)(v12 + 8));
  uint64_t v13 = (void *)ccdh_gp_g(a2);
  uint64_t v14 = ccdh_gp_n(*v10);
  if (cczp_power_fast_ws(a1, (uint64_t)a2, v10 + 2, v13, (uint64_t)&v10[v14 + 2])) {
    goto LABEL_6;
  }
  uint64_t v23 = v9;
  rsize_t v15 = ccdh_ccn_size(a2);
  uint64_t v16 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v8);
  uint64_t v17 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v8);
  cc_clear(v15, v16);
  cc_clear(v15, v17);
  rsize_t v24 = v15;
  uint64_t v18 = (void *)ccdh_ctx_public(v10);
  if (ccdh_compute_shared_secret_ws(a1, a4, v18, &v24, (uint64_t)v16, a3))
  {
    BOOL result = 0;
    uint64_t v9 = v23;
    goto LABEL_7;
  }
  uint64_t v19 = ccdh_gp_n(*v10);
  uint64_t v9 = v23;
  if (cczp_power_fast_ws(a1, (uint64_t)a2, v22, a4 + 2, (uint64_t)&v10[v19 + 2])
    || (unint64_t v20 = ccn_write_uint_size_public_value(v8, v22),
        ccn_write_uint_padded_internal(v8, v22, v20, (char *)v17),
        v24 != v20))
  {
LABEL_6:
    BOOL result = 0;
  }
  else
  {
    BOOL result = cc_cmp_safe_internal(v20, (char *)v16, (char *)v17) == 0;
  }
LABEL_7:
  *(void *)(a1 + 16) = v9;
  return result;
}

uint64_t ccecies_import_eph_pub_ws(uint64_t a1, uint64_t *a2, uint64_t a3, unint64_t a4, unsigned __int8 *a5, uint64_t **a6)
{
  int v11 = *(_DWORD *)(a3 + 32);
  uint64_t v12 = *(void *)(a1 + 16);
  if ((v11 & 2) != 0)
  {
    unint64_t v14 = ((unint64_t)(cczp_bitlen((uint64_t)a2) + 7) >> 2) | 1;
    if (v14 <= a4)
    {
      uint64_t result = ccec_x963_import_pub_ws(a1, a2, v14, a5, a6);
      goto LABEL_8;
    }
LABEL_9:
    uint64_t result = 4294967289;
    goto LABEL_8;
  }
  if ((v11 & 4) != 0)
  {
    unint64_t v15 = (unint64_t)(cczp_bitlen((uint64_t)a2) + 7) >> 3;
    if (v15 <= a4)
    {
      uint64_t result = ccec_compact_import_pub_ws(a1, a2, v15, a5, a6);
      goto LABEL_8;
    }
    goto LABEL_9;
  }
  uint64_t result = 4294967291;
LABEL_8:
  *(void *)(a1 + 16) = v12;
  return result;
}

uint64_t ccecies_import_eph_pub(uint64_t *a1, uint64_t a2, unint64_t a3, unsigned __int8 *a4, uint64_t **a5)
{
  BOOL v16 = timingsafe_enable_if_supported();
  uint64_t v10 = cc_malloc_clear(160 * *a1);
  uint64_t v11 = 20 * *a1;
  v14[0] = v10;
  v14[1] = v11;
  v14[2] = 0;
  void v14[3] = cc_ws_alloc;
  unint64_t v15 = cc_ws_free;
  if (v10)
  {
    uint64_t v12 = ccecies_import_eph_pub_ws((uint64_t)v14, a1, a2, a3, a4, a5);
    v15((uint64_t)v14);
  }
  else
  {
    uint64_t v12 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v12;
}

uint64_t ccsha3_256_c_compress(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return cckeccak_absorb_blocks(a1, 0x88uLL, a2, a3, cckeccak_f1600_c);
}

uint64_t ccsha3_256_c_final(unint64_t *a1, uint64_t a2, void *a3)
{
  return ccsha3_final(a1, a2, a3, cckeccak_f1600_c);
}

void *ccsha3_256_di()
{
  return &ccsha3_256_c_di;
}

uint64_t fipspost_post_rsa_sig(char a1)
{
  uint64_t v37 = *MEMORY[0x263EF8C08];
  __s[0] = 32;
  if (ccrsa_import_priv((unint64_t *)__s, 1189, fipspost_post_rsa_test_key)) {
    return 4294967224;
  }
  uint64_t v32 = 256;
  uint64_t v3 = ccsha256_di();
  if (ccrsa_sign_pkcs1v15_msg_blinded((uint64_t (**)(void, uint64_t, uint64_t))&ccrng_zero, (unint64_t *)__s, (uint64_t)v3, 0x100uLL, MESSAGE, (unint64_t *)&v32, (char *)v35))
  {
    uint64_t v4 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccrsa_sign_pkcs1v15\n", v4, "fipspost_post_rsa_sign", 77);
    int v5 = a1 & 0x10;
    int v6 = -72;
  }
  else
  {
    int v5 = a1 & 0x10;
    if ((a1 & 0x10) != 0) {
      uint64_t v7 = (char *)&unk_2373ADEEE;
    }
    else {
      uint64_t v7 = (char *)&unk_2373ADFF0;
    }
    if (cc_cmp_safe(v32, (char *)v35, v7))
    {
      uint64_t v8 = mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: sig != expected signature\n", v8, "fipspost_post_rsa_sign", 84);
      int v6 = -75;
    }
    else
    {
      int v6 = 0;
    }
  }
  uint64_t v9 = (unint64_t *)ccrsa_ctx_public(__s);
  uint64_t v10 = ccsha256_di();
  if (v5) {
    uint64_t v11 = &unk_2373ADEEE;
  }
  else {
    uint64_t v11 = &unk_2373ADFF0;
  }
  if (ccrsa_verify_pkcs1v15_msg(v9, (uint64_t)v10, 0x100uLL, MESSAGE, 0x100uLL, (uint64_t)v11, 0))
  {
    uint64_t v12 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccrsa_verify_pkcs1v15\n", v12, "fipspost_post_rsa_verify", 98);
    int v13 = -75;
  }
  else
  {
    int v13 = 0;
  }
  uint64_t v2 = v13 | v6;
  if (v5)
  {
    uint64_t v14 = sizeof_struct_ccrns_mul_modulus();
    unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
    unint64_t v16 = (v14 + v15 - 1) / v15 + 2817;
    unint64_t v17 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(0x100uLL);
    if (v16 <= v17) {
      unint64_t v18 = v17;
    }
    else {
      unint64_t v18 = v16;
    }
    uint64_t v19 = cc_malloc_clear(8 * v18 + 14336);
    v35[0] = v19;
    uint64_t v20 = sizeof_struct_ccrns_mul_modulus();
    unint64_t v21 = sizeof_struct_ccpolyzp_po2cyc();
    unint64_t v22 = (v20 + v21 - 1) / v21 + 2817;
    unint64_t v23 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(0x100uLL);
    if (v22 <= v23) {
      unint64_t v24 = v23;
    }
    else {
      unint64_t v24 = v22;
    }
    v35[1] = v24 + 1792;
    v35[2] = 0;
    v35[3] = cc_ws_alloc;
    uint64_t v36 = cc_ws_free;
    if (v19)
    {
      ccrsa_pairwise_consistency_check_ws((uint64_t)v35, __s, (uint64_t (**)(void, uint64_t, uint64_t))&ccrng_zero);
      int v26 = v25;
      mach_absolute_time();
      if (v26) {
        printf("FIPSPOST_USER [%llu] %s:%d: FAILED: [PCT] CCRSA_PAIRWISE_CONSISTENCY: unexpected FAILURE\n");
      }
      else {
        printf("FIPSPOST_USER [%llu] %s:%d: [PCT] CCRSA_PAIRWISE_CONSISTENCY: expected SUCCESS\n");
      }
      ccn_add1(__s[0], v34, v34, 1);
      ccrsa_pairwise_consistency_check_ws((uint64_t)v35, __s, (uint64_t (**)(void, uint64_t, uint64_t))&ccrng_zero);
      int v29 = v28;
      uint64_t v30 = mach_absolute_time();
      if (v29)
      {
        printf("FIPSPOST_USER [%llu] %s:%d: [PCT] CCRSA_PAIRWISE_CONSISTENCY: FORCEFAIL\n", v30, "fipspost_post_rsa_pairwise", 130);
        int v27 = 0;
      }
      else
      {
        printf("FIPSPOST_USER [%llu] %s:%d: FAILED: [PCT] CCRSA_PAIRWISE_CONSISTENCY: unexpected SUCCESS\n", v30, "fipspost_post_rsa_pairwise", 133);
        int v27 = -1;
      }
      v36((uint64_t)v35);
    }
    else
    {
      int v27 = -13;
    }
    uint64_t v2 = v27 | v2;
  }
  cc_clear(0x830uLL, __s);
  return v2;
}

uint64_t cche_encrypt_params_get(unsigned int a1)
{
  if (a1 > 0x10) {
    return 0;
  }
  else {
    return (uint64_t)*(&off_264CD1E58 + (int)a1);
  }
}

uint64_t cche_encryption_params_plaintext_modulus(unsigned int a1)
{
  return *(void *)(cche_encrypt_params_get(a1) + 8);
}

uint64_t cche_encryption_params_polynomial_degree(unsigned int a1)
{
  return *(unsigned int *)(cche_encrypt_params_get(a1) + 16);
}

uint64_t cche_encryption_params_coefficient_nmoduli(unsigned int a1)
{
  return *(unsigned int *)(cche_encrypt_params_get(a1) + 28);
}

uint64_t cche_encryption_params_coefficient_moduli(unint64_t a1, void *a2, unsigned int a3)
{
  uint64_t result = cche_encrypt_params_get(a3);
  unint64_t v6 = *(unsigned int *)(result + 28);
  if (v6 >= a1) {
    unint64_t v6 = a1;
  }
  if (v6)
  {
    uint64_t v7 = (uint64_t *)(result + 32);
    do
    {
      uint64_t v8 = *v7++;
      *a2++ = v8;
      --v6;
    }
    while (v6);
  }
  return result;
}

BOOL cche_encrypt_params_eq(unsigned int *a1, unsigned int *a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t v4 = a1[7];
  if (v4 != a2[7]) {
    return 0;
  }
  uint64_t v5 = sizeof_struct_cche_cipher_plain_ctx();
  unint64_t v6 = sizeof_struct_ccpolyzp_po2cyc();
  return memcmp(a1, a2, 8 * ((v5 + 8 * v4 + v6 - 1) / v6)) == 0;
}

uint64_t cccfb_context_size(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t cccfb_block_size(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t cccfb_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 16))(a1, a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t cccfb_update(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t cccfb_one_shot(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v24 = *MEMORY[0x263EF8C08];
  BOOL v14 = timingsafe_enable_if_supported();
  BOOL v23 = v14;
  MEMORY[0x270FA53B0](v14, v15, v16, v17);
  uint64_t v19 = &v22[-v18];
  uint64_t v20 = (*(uint64_t (**)(uint64_t, unsigned char *, uint64_t, uint64_t, uint64_t))(a1 + 16))(a1, &v22[-v18], a2, a3, a4);
  if (!v20) {
    uint64_t v20 = (*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(a1 + 24))(v19, a5, a6, a7);
  }
  cc_clear(*(void *)a1, v19);
  cc_disable_dit_with_sb((unsigned int *)&v23);
  return v20;
}

uint64_t ccblowfish_ltc_setup(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = 0;
  unsigned int v6 = 0;
  v19[1] = *MEMORY[0x263EF8C08];
  do
  {
    int v7 = 0;
    int v8 = 4;
    do
    {
      int v7 = *(unsigned __int8 *)(a4 + v6) | (v7 << 8);
      if (v6 + 1 == a3) {
        unsigned int v6 = 0;
      }
      else {
        ++v6;
      }
      --v8;
    }
    while (v8);
    a2[v5 + 1024] = ORIG_P[v5] ^ v7;
    ++v5;
  }
  while (v5 != 18);
  for (uint64_t i = 0; i != 1024; i += 256)
    memcpy(&a2[i], (char *)&ORIG_S + i * 4, 0x400uLL);
  unint64_t v10 = 0;
  v19[0] = 0;
  do
  {
    ccblowfish_ltc_ecb_encrypt(a2, 1, (unsigned int *)v19, v19);
    unsigned int v11 = HIDWORD(v19[0]);
    a2[v10 + 1024] = bswap32(v19[0]);
    a2[v10 + 1025] = bswap32(v11);
    BOOL v12 = v10 >= 0x10;
    v10 += 2;
  }
  while (!v12);
  uint64_t v13 = 0;
  BOOL v14 = a2;
  do
  {
    unint64_t v15 = 0;
    do
    {
      ccblowfish_ltc_ecb_encrypt(a2, 1, (unsigned int *)v19, v19);
      uint64_t v16 = &v14[v15];
      unsigned int v17 = bswap32(HIDWORD(v19[0]));
      *uint64_t v16 = bswap32(v19[0]);
      v16[1] = v17;
      BOOL v12 = v15 >= 0xFE;
      v15 += 2;
    }
    while (!v12);
    ++v13;
    v14 += 256;
  }
  while (v13 != 4);
  return 0;
}

uint64_t ccblowfish_ltc_ecb_encrypt(_DWORD *a1, uint64_t a2, unsigned int *a3, unsigned char *a4)
{
  for (; a2; --a2)
  {
    int v4 = bswap32(*a3);
    unsigned int v5 = bswap32(a3[1]);
    unint64_t v6 = -4;
    int v7 = a1 + 1027;
    do
    {
      unsigned int v8 = *(v7 - 3) ^ v4;
      unsigned int v9 = *(v7 - 2) ^ v5 ^ (((a1[BYTE2(v8) + 256] + a1[HIBYTE(v8)]) ^ a1[BYTE1(v8) + 512])
                           + a1[v8 + 768]);
      unsigned int v10 = *(v7 - 1) ^ v8 ^ (((a1[BYTE2(v9) + 256] + a1[HIBYTE(v9)]) ^ a1[BYTE1(v9) + 512])
                            + a1[v9 + 768]);
      int v11 = *v7;
      v7 += 4;
      unsigned int v5 = v11 ^ v9 ^ (((a1[BYTE2(v10) + 256] + a1[HIBYTE(v10)]) ^ a1[BYTE1(v10) + 512]) + a1[v10 + 768]);
      int v4 = (((a1[BYTE2(v5) + 256] + a1[HIBYTE(v5)]) ^ a1[BYTE1(v5) + 512]) + a1[v5 + 768]) ^ v10;
      v6 += 4;
    }
    while (v6 < 0xC);
    int v12 = a1[1041] ^ v5;
    int v13 = a1[1040] ^ v4;
    *a4 = HIBYTE(v12);
    a4[1] = BYTE2(v12);
    a4[2] = BYTE1(v12);
    a4[3] = v12;
    a4[4] = HIBYTE(v13);
    a4[5] = BYTE2(v13);
    a4[6] = BYTE1(v13);
    a4[7] = v13;
    a3 += 2;
    a4 += 8;
  }
  return 0;
}

uint64_t ccsrp_generate_K_from_S_ws(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v41 = *MEMORY[0x263EF8C08];
  int v6 = (*(_DWORD *)(a2 + 24) >> 3) & 7;
  switch(v6)
  {
    case 2:
      uint64_t v37 = ccdh_gp_n(*(void *)(a2 + 8));
      unsigned int v8 = *(uint64_t **)a2;
      unint64_t v9 = ccdh_gp_n(*(void *)(a2 + 8));
      uint64_t v39 = *(void *)(a1 + 16);
      uint64_t v10 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v9);
      int v11 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, (v9 + 1) >> 1);
      int v12 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, (v9 + 1) >> 1);
      uint64_t v38 = (uint64_t)v8;
      uint64_t v13 = *v8;
      BOOL v14 = (char *)(a2 + 32 * v37 + v13 + 32);
      unint64_t v15 = ccn_write_uint_size_public_value(v9, a3);
      ccn_write_uint_internal(v9, a3, v15, v10);
      unint64_t v16 = v15 >> 1;
      if (v15 >= 2)
      {
        unint64_t v17 = v16 - 1;
        if (v16 <= 1) {
          uint64_t v18 = 1;
        }
        else {
          uint64_t v18 = v15 >> 1;
        }
        uint64_t v19 = &v12[v17];
        uint64_t v20 = &v11[v17];
        unint64_t v21 = (char *)((v15 & 1) + v10 + 1);
        do
        {
          *v20-- = *v21;
          *v19-- = *(v21 - 1);
          v21 += 2;
          --v18;
        }
        while (v18);
      }
      ccdigest_internal(v38, v15 >> 1, v11, (uint64_t)v40);
      ccdigest_internal(v38, v15 >> 1, v12, (uint64_t)v14);
      if (v13)
      {
        unint64_t v22 = (unsigned char *)(a2 + 32 * v37 + 33);
        BOOL v23 = v40;
        do
        {
          char v24 = *v23++;
          *(v22 - 1) = v24;
          char v25 = *v14++;
          *unint64_t v22 = v25;
          v22 += 2;
          --v13;
        }
        while (v13);
      }
      *(void *)(a1 + 16) = v39;
      goto LABEL_16;
    case 1:
      uint64_t v26 = a2 + 32 * ccdh_gp_n(*(void *)(a2 + 8)) + 32;
      int v27 = *(uint64_t **)a2;
      uint64_t v28 = ccdh_gp_n(*(void *)(a2 + 8));
      uint64_t v29 = *(void *)(a1 + 16);
      uint64_t v30 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v28);
      unint64_t v31 = ccdh_gp_n(*(void *)(a2 + 8));
      uint64_t v32 = ccdh_gp_n(*(void *)(a2 + 8));
      int v33 = ccn_write_uint_padded_ct_internal(v31, a3, 8 * v32, v30);
      uint64_t v34 = 2 * *v27;
      uint64_t v35 = ccdh_gp_n(*(void *)(a2 + 8));
      uint64_t result = ccmgf_internal((uint64_t)v27, v34, v26, 8 * v35 - v33, &v30[v33]);
      *(void *)(a1 + 16) = v29;
      if (result) {
        return result;
      }
      goto LABEL_16;
    case 0:
      uint64_t v7 = ccdh_gp_n(*(void *)(a2 + 8));
      ccsrp_digest_ccn_ws(a1, (uint64_t *)a2, a3, a2 + 32 * v7 + 32, (*(_DWORD *)(a2 + 24) >> 9) & 1);
LABEL_16:
      uint64_t result = 0;
      *(_DWORD *)(a2 + 24) |= 4u;
      return result;
  }
  return 4294967239;
}

unint64_t md5_compress(unint64_t result, uint64_t a2, _DWORD *a3)
{
  BOOL v85 = (_DWORD *)result;
  if (a2)
  {
    int v3 = *(_DWORD *)result;
    int v4 = *(_DWORD *)(result + 4);
    int v5 = *(_DWORD *)(result + 8);
    int v6 = *(_DWORD *)(result + 12);
    do
    {
      int v7 = a3[1];
      uint64_t result = a3[2];
      int v8 = a3[3];
      int v10 = a3[4];
      int v9 = a3[5];
      int v11 = a3[6];
      int v12 = a3[7];
      int v13 = a3[8];
      int v14 = a3[9];
      int v15 = a3[10];
      int v16 = a3[11];
      int v17 = a3[12];
      int v18 = a3[13];
      int v20 = a3[14];
      int v19 = a3[15];
      HIDWORD(v21) = v3 + (v5 & v4 | v6 & ~v4) - 680876936 + *a3;
      LODWORD(v21) = HIDWORD(v21);
      int v22 = (v21 >> 25) + v4;
      HIDWORD(v21) = v6 + v7 - 389564586 + (v4 & v22 | v5 & ~v22);
      LODWORD(v21) = HIDWORD(v21);
      int v23 = (v21 >> 20) + v22;
      HIDWORD(v21) = v5 + result + 606105819 + (v22 & v23 | v4 & ~v23);
      LODWORD(v21) = HIDWORD(v21);
      int v24 = (v21 >> 15) + v23;
      HIDWORD(v21) = v4 + v8 - 1044525330 + (v23 & v24 | v22 & ~v24);
      LODWORD(v21) = HIDWORD(v21);
      int v25 = (v21 >> 10) + v24;
      HIDWORD(v21) = v10 + v22 - 176418897 + (v24 & v25 | v23 & ~v25);
      LODWORD(v21) = HIDWORD(v21);
      int v26 = (v21 >> 25) + v25;
      HIDWORD(v21) = v9 + v23 + 1200080426 + (v25 & v26 | v24 & ~v26);
      LODWORD(v21) = HIDWORD(v21);
      int v27 = (v21 >> 20) + v26;
      HIDWORD(v21) = v11 + v24 - 1473231341 + (v26 & v27 | v25 & ~v27);
      LODWORD(v21) = HIDWORD(v21);
      int v28 = (v21 >> 15) + v27;
      HIDWORD(v21) = v12 + v25 - 45705983 + (v27 & v28 | v26 & ~v28);
      LODWORD(v21) = HIDWORD(v21);
      int v29 = (v21 >> 10) + v28;
      HIDWORD(v21) = v13 + v26 + 1770035416 + (v28 & v29 | v27 & ~v29);
      LODWORD(v21) = HIDWORD(v21);
      int v30 = (v21 >> 25) + v29;
      HIDWORD(v21) = v14 + v27 - 1958414417 + (v29 & v30 | v28 & ~v30);
      LODWORD(v21) = HIDWORD(v21);
      int v31 = (v21 >> 20) + v30;
      HIDWORD(v21) = v15 + v28 - 42063 + (v30 & v31 | v29 & ~v31);
      LODWORD(v21) = HIDWORD(v21);
      int v32 = (v21 >> 15) + v31;
      HIDWORD(v21) = v16 + v29 - 1990404162 + (v31 & v32 | v30 & ~v32);
      LODWORD(v21) = HIDWORD(v21);
      int v33 = (v21 >> 10) + v32;
      HIDWORD(v21) = v17 + v30 + 1804603682 + (v32 & v33 | v31 & ~v33);
      LODWORD(v21) = HIDWORD(v21);
      int v34 = (v21 >> 25) + v33;
      HIDWORD(v21) = v18 + v31 - 40341101 + (v33 & v34 | v32 & ~v34);
      LODWORD(v21) = HIDWORD(v21);
      int v35 = (v21 >> 20) + v34;
      HIDWORD(v21) = v20 + v32 - 1502002290 + (v34 & v35 | v33 & ~v35);
      LODWORD(v21) = HIDWORD(v21);
      int v36 = (v21 >> 15) + v35;
      HIDWORD(v21) = v19 + v33 + 1236535329 + (v35 & v36 | v34 & ~v36);
      LODWORD(v21) = HIDWORD(v21);
      int v37 = (v21 >> 10) + v36;
      HIDWORD(v21) = v7 + v34 - 165796510 + (v37 & v35 | v36 & ~v35);
      LODWORD(v21) = HIDWORD(v21);
      int v38 = (v21 >> 27) + v37;
      HIDWORD(v21) = v11 + v35 - 1069501632 + (v38 & v36 | v37 & ~v36);
      LODWORD(v21) = HIDWORD(v21);
      int v39 = (v21 >> 23) + v38;
      HIDWORD(v21) = v16 + v36 + 643717713 + (v39 & v37 | v38 & ~v37);
      LODWORD(v21) = HIDWORD(v21);
      int v40 = (v21 >> 18) + v39;
      HIDWORD(v21) = *a3 + v37 - 373897302 + (v40 & v38 | v39 & ~v38);
      LODWORD(v21) = HIDWORD(v21);
      int v41 = (v21 >> 12) + v40;
      HIDWORD(v21) = v9 + v38 - 701558691 + (v41 & v39 | v40 & ~v39);
      LODWORD(v21) = HIDWORD(v21);
      int v42 = (v21 >> 27) + v41;
      HIDWORD(v21) = v15 + v39 + 38016083 + (v42 & v40 | v41 & ~v40);
      LODWORD(v21) = HIDWORD(v21);
      int v43 = (v21 >> 23) + v42;
      HIDWORD(v21) = v19 + v40 - 660478335 + (v43 & v41 | v42 & ~v41);
      LODWORD(v21) = HIDWORD(v21);
      int v44 = (v21 >> 18) + v43;
      HIDWORD(v21) = v10 + v41 - 405537848 + (v44 & v42 | v43 & ~v42);
      LODWORD(v21) = HIDWORD(v21);
      int v45 = (v21 >> 12) + v44;
      HIDWORD(v21) = v14 + v42 + 568446438 + (v45 & v43 | v44 & ~v43);
      LODWORD(v21) = HIDWORD(v21);
      int v46 = (v21 >> 27) + v45;
      HIDWORD(v21) = v20 + v43 - 1019803690 + (v46 & v44 | v45 & ~v44);
      LODWORD(v21) = HIDWORD(v21);
      int v47 = (v21 >> 23) + v46;
      HIDWORD(v21) = v8 + v44 - 187363961 + (v47 & v45 | v46 & ~v45);
      LODWORD(v21) = HIDWORD(v21);
      int v48 = (v21 >> 18) + v47;
      HIDWORD(v21) = v13 + v45 + 1163531501 + (v48 & v46 | v47 & ~v46);
      LODWORD(v21) = HIDWORD(v21);
      int v49 = (v21 >> 12) + v48;
      HIDWORD(v21) = v18 + v46 - 1444681467 + (v49 & v47 | v48 & ~v47);
      LODWORD(v21) = HIDWORD(v21);
      int v50 = (v21 >> 27) + v49;
      HIDWORD(v21) = result + v47 - 51403784 + (v50 & v48 | v49 & ~v48);
      LODWORD(v21) = HIDWORD(v21);
      int v51 = (v21 >> 23) + v50;
      HIDWORD(v21) = v12 + v48 + 1735328473 + (v51 & v49 | v50 & ~v49);
      LODWORD(v21) = HIDWORD(v21);
      int v52 = (v21 >> 18) + v51;
      HIDWORD(v21) = v17 + v49 - 1926607734 + ((v52 ^ v51) & v50 ^ v51);
      LODWORD(v21) = HIDWORD(v21);
      int v53 = (v21 >> 12) + v52;
      HIDWORD(v21) = v9 + v50 - 378558 + (v52 ^ v51 ^ v53);
      LODWORD(v21) = HIDWORD(v21);
      int v54 = (v21 >> 28) + v53;
      HIDWORD(v21) = v13 + v51 - 2022574463 + (v53 ^ v52 ^ v54);
      LODWORD(v21) = HIDWORD(v21);
      int v55 = (v21 >> 21) + v54;
      HIDWORD(v21) = v16 + v52 + 1839030562 + (v54 ^ v53 ^ v55);
      LODWORD(v21) = HIDWORD(v21);
      int v56 = (v21 >> 16) + v55;
      HIDWORD(v21) = v20 + v53 - 35309556 + (v55 ^ v54 ^ v56);
      LODWORD(v21) = HIDWORD(v21);
      int v57 = (v21 >> 9) + v56;
      HIDWORD(v21) = v7 + v54 - 1530992060 + (v56 ^ v55 ^ v57);
      LODWORD(v21) = HIDWORD(v21);
      int v58 = (v21 >> 28) + v57;
      HIDWORD(v21) = v10 + v55 + 1272893353 + (v57 ^ v56 ^ v58);
      LODWORD(v21) = HIDWORD(v21);
      int v59 = (v21 >> 21) + v58;
      HIDWORD(v21) = v12 + v56 - 155497632 + (v58 ^ v57 ^ v59);
      LODWORD(v21) = HIDWORD(v21);
      int v60 = (v21 >> 16) + v59;
      HIDWORD(v21) = v15 + v57 - 1094730640 + (v59 ^ v58 ^ v60);
      LODWORD(v21) = HIDWORD(v21);
      int v61 = (v21 >> 9) + v60;
      HIDWORD(v21) = v18 + v58 + 681279174 + (v60 ^ v59 ^ v61);
      LODWORD(v21) = HIDWORD(v21);
      int v62 = (v21 >> 28) + v61;
      HIDWORD(v21) = *a3 + v59 - 358537222 + (v61 ^ v60 ^ v62);
      LODWORD(v21) = HIDWORD(v21);
      int v63 = (v21 >> 21) + v62;
      HIDWORD(v21) = v8 + v60 - 722521979 + (v62 ^ v61 ^ v63);
      LODWORD(v21) = HIDWORD(v21);
      int v64 = (v21 >> 16) + v63;
      HIDWORD(v21) = v11 + v61 + 76029189 + (v63 ^ v62 ^ v64);
      LODWORD(v21) = HIDWORD(v21);
      int v65 = (v21 >> 9) + v64;
      HIDWORD(v21) = v14 + v62 - 640364487 + (v64 ^ v63 ^ v65);
      LODWORD(v21) = HIDWORD(v21);
      int v66 = (v21 >> 28) + v65;
      HIDWORD(v21) = v17 + v63 - 421815835 + (v65 ^ v64 ^ v66);
      LODWORD(v21) = HIDWORD(v21);
      int v67 = (v21 >> 21) + v66;
      HIDWORD(v21) = v19 + v64 + 530742520 + (v66 ^ v65 ^ v67);
      LODWORD(v21) = HIDWORD(v21);
      int v68 = (v21 >> 16) + v67;
      HIDWORD(v21) = result + v65 - 995338651 + (v67 ^ v66 ^ v68);
      LODWORD(v21) = HIDWORD(v21);
      int v69 = (v21 >> 9) + v68;
      HIDWORD(v21) = *a3 + v66 - 198630844 + ((v69 | ~v67) ^ v68);
      LODWORD(v21) = HIDWORD(v21);
      int v70 = (v21 >> 26) + v69;
      HIDWORD(v21) = v12 + v67 + 1126891415 + ((v70 | ~v68) ^ v69);
      LODWORD(v21) = HIDWORD(v21);
      int v71 = (v21 >> 22) + v70;
      HIDWORD(v21) = v20 + v68 - 1416354905 + ((v71 | ~v69) ^ v70);
      LODWORD(v21) = HIDWORD(v21);
      int v72 = (v21 >> 17) + v71;
      HIDWORD(v21) = v9 + v69 - 57434055 + ((v72 | ~v70) ^ v71);
      LODWORD(v21) = HIDWORD(v21);
      int v73 = (v21 >> 11) + v72;
      HIDWORD(v21) = v17 + v70 + 1700485571 + ((v73 | ~v71) ^ v72);
      LODWORD(v21) = HIDWORD(v21);
      int v74 = (v21 >> 26) + v73;
      HIDWORD(v21) = v8 + v71 - 1894986606 + ((v74 | ~v72) ^ v73);
      LODWORD(v21) = HIDWORD(v21);
      int v75 = (v21 >> 22) + v74;
      HIDWORD(v21) = v15 + v72 - 1051523 + ((v75 | ~v73) ^ v74);
      LODWORD(v21) = HIDWORD(v21);
      int v76 = (v21 >> 17) + v75;
      HIDWORD(v21) = v7 + v73 - 2054922799 + ((v76 | ~v74) ^ v75);
      LODWORD(v21) = HIDWORD(v21);
      int v77 = (v21 >> 11) + v76;
      HIDWORD(v21) = v13 + v74 + 1873313359 + ((v77 | ~v75) ^ v76);
      LODWORD(v21) = HIDWORD(v21);
      int v78 = (v21 >> 26) + v77;
      HIDWORD(v21) = v19 + v75 - 30611744 + ((v78 | ~v76) ^ v77);
      LODWORD(v21) = HIDWORD(v21);
      int v79 = (v21 >> 22) + v78;
      HIDWORD(v21) = v11 + v76 - 1560198380 + ((v79 | ~v77) ^ v78);
      LODWORD(v21) = HIDWORD(v21);
      int v80 = (v21 >> 17) + v79;
      HIDWORD(v21) = v18 + v77 + 1309151649 + ((v80 | ~v78) ^ v79);
      LODWORD(v21) = HIDWORD(v21);
      int v81 = (v21 >> 11) + v80;
      HIDWORD(v21) = v10 + v78 - 145523070 + ((v81 | ~v79) ^ v80);
      LODWORD(v21) = HIDWORD(v21);
      int v82 = (v21 >> 26) + v81;
      HIDWORD(v21) = v16 + v79 - 1120210379 + ((v82 | ~v80) ^ v81);
      LODWORD(v21) = HIDWORD(v21);
      int v83 = (v21 >> 22) + v82;
      HIDWORD(v21) = result + v80 + 718787259 + ((v83 | ~v81) ^ v82);
      LODWORD(v21) = HIDWORD(v21);
      int v84 = (v21 >> 17) + v83;
      v3 += v82;
      HIDWORD(v21) = v14 + v81 - 343485551 + ((v84 | ~v82) ^ v83);
      LODWORD(v21) = HIDWORD(v21);
      v4 += v84 + (v21 >> 11);
      v5 += v84;
      v6 += v83;
      *BOOL v85 = v3;
      v85[1] = v4;
      v85[2] = v5;
      v85[3] = v6;
      a3 += 16;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t ccrng_ecfips_test_init(void *a1, uint64_t a2, uint64_t a3)
{
  BOOL v7 = timingsafe_enable_if_supported();
  *a1 = ecfips_test_generate;
  a1[1] = a3;
  a1[2] = a2;
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return 0;
}

uint64_t ecfips_test_generate(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  if (!*(void *)(a1 + 16)) {
    return 4294967291;
  }
  if (a2)
  {
    uint64_t v3 = 0;
    LOWORD(v4) = -1;
    do
    {
      __int16 v5 = v4
         + *(unsigned __int8 *)(*(void *)(a1 + 8)
                              + (unint64_t)(--v3 + *(void *)(a1 + 16)) % *(void *)(a1 + 16));
      *a3++ = v5;
      int v4 = v5 >> 15;
    }
    while (-a2 != v3);
  }
  return 0;
}

void *ccdh_gp_rfc5114_MODP_2048_256()
{
  return &_ccdh_gp_rfc5114_MODP_2048_256;
}

uint64_t ccz_bit(uint64_t a1, unint64_t a2)
{
  BOOL v6 = timingsafe_enable_if_supported();
  uint64_t v4 = 0;
  if (ccz_n(a1) > a2 >> 6) {
    uint64_t v4 = (*(void *)(*(void *)(a1 + 24) + 8 * (a2 >> 6)) >> a2) & 1;
  }
  cc_disable_dit_with_sb((unsigned int *)&v6);
  return v4;
}

uint64_t ccrng_rsafips_test_init(uint64_t (**a1)(uint64_t a1, unint64_t a2, char *a3), uint64_t (*a2)(uint64_t a1, unint64_t a2, char *a3), uint64_t (*a3)(uint64_t a1, unint64_t a2, char *a3), uint64_t (*a4)(uint64_t a1, unint64_t a2, char *a3), uint64_t (*a5)(uint64_t a1, unint64_t a2, char *a3), uint64_t (*a6)(uint64_t a1, unint64_t a2, char *a3), uint64_t (*a7)(uint64_t a1, unint64_t a2, char *a3))
{
  BOOL v15 = timingsafe_enable_if_supported();
  *a1 = ccrng_rsafips_test_generate;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = a2;
  a1[5] = a3;
  a1[6] = a4;
  a1[7] = a5;
  a1[8] = a6;
  a1[9] = a7;
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return 0;
}

uint64_t ccrng_rsafips_test_generate(uint64_t a1, unint64_t a2, char *a3)
{
  do
  {
    uint64_t v5 = a1;
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6 == 2)
    {
      BOOL v7 = (const void **)(a1 + 72);
      int v8 = (uint64_t *)(a1 + 64);
    }
    else if (v6 == 1)
    {
      BOOL v7 = (const void **)(a1 + 56);
      int v8 = (uint64_t *)(a1 + 48);
    }
    else
    {
      if (v6)
      {
        int v9 = *(const void **)(a1 + 72);
        goto LABEL_10;
      }
      BOOL v7 = (const void **)(a1 + 40);
      int v8 = (uint64_t *)(a1 + 32);
    }
    a1 = *v8;
    int v9 = *v7;
    if (*v8) {
      break;
    }
LABEL_10:
    a1 = *(void *)(v5 + 24);
  }
  while (a1);
  unint64_t v10 = ccn_bitlen_internal(a1, v9) + 7;
  if (a2 < v10 >> 3) {
    return 4294967291;
  }
  unint64_t v12 = v10 >> 3;
  memcpy(a3, v9, v10 >> 3);
  cc_clear(a2 - v12, &a3[v12]);
  uint64_t result = 0;
  ++*(void *)(v5 + 16);
  return result;
}

uint64_t ccrng_rsafips_test_set_next(uint64_t a1, uint64_t a2)
{
  BOOL v5 = timingsafe_enable_if_supported();
  *(void *)(a1 + 24) = a2;
  return cc_disable_dit_with_sb((unsigned int *)&v5);
}

uint64_t ccsrp_generate_client_pubkey_ws(uint64_t a1, uint64_t *a2)
{
  BOOL v5 = (void *)a2[1];
  uint64_t v4 = (uint64_t (**)(void, uint64_t, uint64_t *))a2[2];
  uint64_t v6 = a2 + 4;
  ccdh_gp_n(v5);
  BOOL v7 = (void *)ccdh_gp_g((void *)a2[1]);
  unint64_t private_key_bitlen = ccdh_generate_private_key_bitlen((void *)a2[1]);
  uint64_t v9 = ccdh_gp_n(a2[1]);
  uint64_t v10 = ccdh_gp_n(a2[1]);
  if (ccn_bitlen_internal(v9, &v6[v10]) > private_key_bitlen) {
    unint64_t private_key_bitlen = cczp_bitlen(a2[1]);
  }
  uint64_t v11 = (uint64_t)&v6[ccdh_gp_n(a2[1])];

  return ccdh_power_blinded_ws(a1, v4, v5, v6, v7, private_key_bitlen, v11);
}

uint64_t ccsrp_generate_client_S_ws(uint64_t a1, uint64_t **a2, uint64_t *a3, uint64_t a4, unint64_t *a5, unint64_t *a6)
{
  uint64_t v10 = ccdh_gp_n(a2[1]);
  uint64_t v32 = *(void *)(a1 + 16);
  uint64_t v11 = (char *)(*(uint64_t (**)(uint64_t))(a1 + 24))(a1);
  unint64_t v12 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10);
  uint64_t v31 = (uint64_t)a5;
  ccn_mul_ws(a1, v10, v11, a6, a5);
  int v13 = a2 + 4;
  uint64_t v14 = ccdh_gp_n(a2[1]);
  uint64_t v29 = ccn_add_ws(a1, v10, v11, (uint64_t *)&a2[v14 + 4], (uint64_t *)v11);
  uint64_t v15 = **a2;
  uint64_t v16 = 4;
  if ((a2[3] & 0x1C0) == 0) {
    uint64_t v16 = **a2;
  }
  unint64_t v17 = 8 * (v16 + v15);
  unint64_t private_key_bitlen = ccdh_generate_private_key_bitlen(a2[1]);
  uint64_t v19 = ccdh_gp_n(a2[1]);
  uint64_t v20 = ccdh_gp_n(a2[1]);
  if (ccn_bitlen_internal(v19, &v13[v20]) > private_key_bitlen) {
    unint64_t private_key_bitlen = cczp_bitlen((uint64_t)a2[1]);
  }
  if (v17 <= private_key_bitlen)
  {
    unint64_t v17 = ccdh_generate_private_key_bitlen(a2[1]);
    uint64_t v21 = ccdh_gp_n(a2[1]);
    uint64_t v22 = ccdh_gp_n(a2[1]);
    if (ccn_bitlen_internal(v21, &v13[v22]) > v17) {
      unint64_t v17 = cczp_bitlen((uint64_t)a2[1]);
    }
  }
  unint64_t v23 = v17 + 1;
  if (v23 >= cczp_bitlen((uint64_t)a2[1]))
  {
    ccn_add1_ws(a1, v10, &v11[8 * v10], (uint64_t *)&v11[8 * v10], v29);
    int v24 = (unint64_t *)ccdh_gp_prime(a2[1]);
    ccn_sub1(v10, v12, v24, 1uLL);
    ccn_divmod_ws(a1, 2 * v10, (uint64_t)v11, 0, 0, v10, v11, v12);
    unint64_t v23 = cczp_bitlen((uint64_t)a2[1]);
  }
  int v26 = a2[1];
  int v25 = a2[2];
  int v27 = (void *)ccdh_gp_g(v26);
  uint64_t result = ccdh_power_blinded_ws(a1, (uint64_t (**)(void, uint64_t, uint64_t *))v25, v26, (uint64_t *)v12, v27, 8 * v15, v31);
  if (!result)
  {
    if (((_WORD)a2[3] & 0x1C0) == 0) {
      cczp_mul_ws(a1, (uint64_t)a2[1]);
    }
    cczp_sub_ws(a1, (uint64_t)a2[1]);
    uint64_t result = ccdh_power_blinded_ws(a1, (uint64_t (**)(void, uint64_t, uint64_t *))a2[2], a2[1], a3, v12, v23, (uint64_t)v11);
  }
  *(void *)(a1 + 16) = v32;
  return result;
}

uint64_t ccsrp_client_start_authentication(void *a1, uint64_t (**a2)(void, unint64_t, uint64_t), char *a3)
{
  BOOL v19 = timingsafe_enable_if_supported();
  uint64_t v6 = ccdh_gp_n(a1[1]);
  uint64_t v7 = CCDH_POWER_BLINDED_WORKSPACE_N(v6);
  v15[0] = cc_malloc_clear(8 * v7);
  v15[1] = CCDH_POWER_BLINDED_WORKSPACE_N(v6);
  uint64_t v16 = 0;
  unint64_t v17 = cc_ws_alloc;
  int v18 = cc_ws_free;
  if (v15[0])
  {
    int v8 = (void *)a1[1];
    uint64_t v9 = ccdh_gp_n(v8);
    private_uint64_t key_ws = ccdh_generate_private_key_ws((uint64_t)v15, v8, &a1[v9 + 4], a2);
    if (private_key_ws
      || (private_uint64_t key_ws = ccsrp_generate_client_pubkey_ws((uint64_t)v15, a1), private_key_ws))
    {
      uint64_t v13 = private_key_ws;
    }
    else
    {
      ccdh_gp_n(a1[1]);
      unint64_t v11 = ccdh_gp_n(a1[1]);
      uint64_t v12 = ccdh_gp_n(a1[1]);
      ccn_write_uint_padded_ct_internal(v11, a1 + 4, 8 * v12, a3);
      uint64_t v13 = 0;
    }
    uint64_t v16 = 0;
    v18((uint64_t)v15);
  }
  else
  {
    uint64_t v13 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v19);
  return v13;
}

uint64_t ccsrp_client_process_challenge(uint64_t a1, char *a2, size_t a3, char *a4, size_t a5, char *a6, uint64_t a7, void *a8)
{
  BOOL v45 = timingsafe_enable_if_supported();
  uint64_t v16 = ccdh_gp_n(*(void *)(a1 + 8));
  uint64_t v17 = CCDH_POWER_BLINDED_WORKSPACE_N(v16);
  v41[0] = cc_malloc_clear(8 * (v17 + 8 * v16));
  v41[1] = CCDH_POWER_BLINDED_WORKSPACE_N(v16) + 8 * v16;
  uint64_t v42 = 0;
  int v43 = cc_ws_alloc;
  int v44 = cc_ws_free;
  if (v41[0])
  {
    size_t v37 = a3;
    int v38 = a4;
    int v39 = a6;
    size_t v40 = a5;
    unint64_t __dst = a8;
    uint64_t v18 = ccdh_gp_n(*(void *)(a1 + 8));
    uint64_t v36 = ccdh_gp_n(*(void *)(a1 + 8));
    BOOL v19 = (unint64_t *)cc_ws_alloc(v41, v18);
    uint64_t v20 = (unint64_t *)v43(v41, v18);
    uint64_t v21 = (unint64_t *)v43(v41, v18);
    uint64_t v22 = v43(v41, v18);
    uint64_t v23 = v43(v41, v18);
    uint64_t v24 = **(void **)a1;
    if (cczp_bitlen(*(void *)(a1 + 8)) < (unint64_t)(8 * v24))
    {
      uint64_t K_from_S_ws = 4294967239;
LABEL_13:
      v44((uint64_t)v41);
      goto LABEL_14;
    }
    uint64_t v26 = ccdh_gp_n(*(void *)(a1 + 8));
    uint64_t v27 = ccdh_gp_n(*(void *)(a1 + 8));
    uint64_t uint_internal = ccn_read_uint_internal(v26, v19, 8 * v27, a7);
    if (!uint_internal)
    {
      cczp_mod_ws((uint64_t)v41, *(void *)(a1 + 8));
      if (!ccn_n(v18, v23)
        || (uint64_t v29 = a1 + 32,
            ccdh_gp_n(*(void *)(a1 + 8)),
            ccsrp_generate_u_ws((uint64_t)v41, (uint64_t *)a1, (uint64_t)v20, (unint64_t *)(a1 + 32), v19),
            cczp_mod_ws((uint64_t)v41, *(void *)(a1 + 8)),
            !ccn_n(v18, v23)))
      {
        uint64_t K_from_S_ws = 4294967238;
        goto LABEL_12;
      }
      uint64_t uint_internal = ccsrp_generate_x(a1, (uint64_t)v21, a2, v40, v39, v37, v38);
      if (!uint_internal)
      {
        int v30 = (uint64_t *)(v29 + 24 * v36);
        ccsrp_generate_k_ws((uint64_t)v41, a1, v22);
        uint64_t uint_internal = ccsrp_generate_client_S_ws((uint64_t)v41, (uint64_t **)a1, v30, v22, v21, v20);
        if (!uint_internal)
        {
          uint64_t K_from_S_ws = ccsrp_generate_K_from_S_ws((uint64_t)v41, a1, (unint64_t *)v30);
          if (!K_from_S_ws)
          {
            ccdh_gp_n(*(void *)(a1 + 8));
            ccsrp_generate_M_ws((uint64_t)v41, (size_t **)a1, a2, v40, v39, (unint64_t *)(a1 + 32), v19);
            ccdh_gp_n(*(void *)(a1 + 8));
            ccsrp_generate_H_AMK_ws((uint64_t)v41, a1, (unint64_t *)(a1 + 32), v31);
            uint64_t v32 = (const void *)(v29 + 32 * ccdh_gp_n(*(void *)(a1 + 8)) + 2 * **(void **)a1);
            size_t v33 = ccsrp_sizeof_M_HAMK(*(void *)a1);
            memcpy(__dst, v32, v33);
          }
          goto LABEL_12;
        }
      }
    }
    uint64_t K_from_S_ws = uint_internal;
LABEL_12:
    uint64_t v42 = 0;
    goto LABEL_13;
  }
  uint64_t K_from_S_ws = 4294967283;
LABEL_14:
  cc_disable_dit_with_sb((unsigned int *)&v45);
  return K_from_S_ws;
}

uint64_t ccsrp_client_verify_session(uint64_t a1, char *a2)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v4 = ccsrp_sizeof_M_HAMK(*(void *)a1);
  uint64_t v5 = ccdh_gp_n(*(void *)(a1 + 8));
  int v6 = cc_cmp_safe_internal(v4, (char *)(a1 + 32 * v5 + 3 * **(void **)a1 + 32), a2);
  unsigned int v7 = *(_DWORD *)(a1 + 24);
  if (v6) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = (v7 >> 2) & 1;
  }
  *(_DWORD *)(a1 + 24) = v7 & 0xFFFFFFFE | v8;
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

BOOL cche_param_ctx_eq(unsigned int *a1, unsigned int *a2)
{
  return a1 == a2 || cche_encrypt_params_eq(a1, a2);
}

uint64_t cche_param_ctx_init_ws(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  if ((*a3 - 1) <= 1)
  {
    uint64_t v5 = a3[7];
    if (v5)
    {
      int v6 = (unint64_t *)(a3 + 8);
      uint64_t v7 = a3[7];
      while (1)
      {
        unint64_t v8 = *v6++;
        if (*((void *)a3 + 1) >= v8) {
          break;
        }
        if (!--v7) {
          goto LABEL_6;
        }
      }
    }
    else
    {
LABEL_6:
      if (cche_ciphertext_fresh_npolys() == 2)
      {
        uint64_t v9 = 0;
        unsigned int v10 = 63 - __clz(*((void *)a3 + 4));
        char v11 = 1;
        while (a3[v9 + 5] <= v10)
        {
          char v12 = v11;
          char v11 = 0;
          uint64_t v9 = 1;
          if ((v12 & 1) == 0)
          {
            v59[0] = a3[4];
            v59[1] = v5;
            v58[0] = v59[0];
            v58[1] = 1;
            uint64_t v13 = sizeof_struct_cche_cipher_plain_ctx();
            unint64_t v14 = sizeof_struct_ccpolyzp_po2cyc();
            memcpy(a2, a3, 8 * ((v13 + 8 * v5 + v14 - 1) / v14));
            uint64_t v15 = a2[7];
            uint64_t v16 = sizeof_struct_cche_cipher_plain_ctx();
            unint64_t v17 = sizeof_struct_ccpolyzp_po2cyc();
            uint64_t v18 = &a2[2 * ((v16 + 8 * v15 + v17 - 1) / v17)];
            uint64_t result = ccpolyzp_po2cyc_ctx_chain_init_ws(a1, v18, v59, (uint64_t *)a3 + 4);
            if (result) {
              return result;
            }
            if (*((unsigned char *)v18 + 16))
            {
              uint64_t v20 = cche_param_ctx_plaintext_ctx((uint64_t)a2);
              uint64_t result = ccpolyzp_po2cyc_ctx_init_ws(a1, v20, v58, (uint64_t *)a3 + 1, 0);
              if (!result)
              {
                unint64_t v21 = *cche_param_ctx_plaintext_ctx((uint64_t)a2);
                uint64_t v22 = cche_param_ctx_plaintext_ctx((uint64_t)a2);
                uint64_t v23 = a2[4];
                uint64_t v24 = sizeof_struct_ccpolyzp_po2cyc_ctx();
                if (v23 >= 0x80) {
                  uint64_t v25 = 128;
                }
                else {
                  uint64_t v25 = v23;
                }
                uint64_t v26 = sizeof_struct_ccrns_mul_modulus();
                if (v21 >= 2)
                {
                  uint64_t v27 = &v22[4 * v23
                           + 12
                           + 4 * ((unint64_t)(v26 + 7) >> 3) * v25
                           + 2 * ((unint64_t)(v24 + 7) >> 3)];
                  unsigned int v28 = __clz(v21) + 1;
                  int v29 = 1;
                  unint64_t v30 = v21 >> 1;
                  do
                  {
                    *uint64_t v27 = __rbit32((v29 - 1) >> 1) >> v28;
                    v27[v21 >> 1] = __rbit32((2 * v21 + ~v29) >> 1) >> v28;
                    int v29 = (3 * v29) & (2 * v21 - 1);
                    ++v27;
                    --v30;
                  }
                  while (v30);
                  uint64_t v23 = a2[4];
                  if (v23 >= 0x80) {
                    uint64_t v25 = 128;
                  }
                  else {
                    uint64_t v25 = v23;
                  }
                }
                uint64_t v31 = cche_param_ctx_plaintext_ctx((uint64_t)a2);
                uint64_t v32 = *v31;
                unint64_t v33 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
                uint64_t v34 = sizeof_struct_ccrns_mul_modulus();
                uint64_t result = cche_decrypt_ctx_init_ws(a1, (uint64_t *)((char *)&v31[4 * v23+ 12+ 4 * ((unint64_t)(v34 + 7) >> 3) * v25+ 2 * v33]+ ((4 * v32 + 7) & 0x7FFFFFFF8)), (uint64_t)a2);
                if (!result)
                {
                  if (a3[7])
                  {
                    int v55 = v18 + 2;
                    int v56 = v18;
                    unsigned int v35 = 1;
                    for (int i = -1; ; --i)
                    {
                      size_t v37 = cche_param_ctx_plaintext_ctx((uint64_t)a2);
                      uint64_t v38 = *v37;
                      uint64_t v39 = a2[4];
                      unint64_t v40 = sizeof_struct_ccpolyzp_po2cyc_ctx() + 7;
                      uint64_t v41 = v39 >= 0x80 ? 128 : v39;
                      uint64_t v42 = v39 + ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v41;
                      uint64_t v43 = (4 * v38 + 7) & 0x7FFFFFFF8;
                      uint64_t v44 = a2[7];
                      uint64_t v45 = sizeof_struct_cche_cipher_plain_ctx();
                      unint64_t v46 = sizeof_struct_ccpolyzp_po2cyc();
                      uint64_t v47 = cche_decrypt_ctx_nof_n(&a2[2 * ((v45 + 8 * v44 + v46 - 1) / v46) + 2]);
                      uint64_t v48 = v47;
                      if (v35 < 2)
                      {
                        uint64_t v50 = (uint64_t)&v37[4 * v42 + 12 + 2 * (v40 >> 3) + 2 * v47] + v43;
                      }
                      else
                      {
                        uint64_t v49 = sizeof_struct_cche_cipher_plain_ctx();
                        uint64_t v50 = (uint64_t)&v37[4 * (((v35 - 3) * (unint64_t)(v35 - 2)) >> 1)
                                          + 16
                                          + 4 * v42
                                          + 2 * v48]
                            + (v40 & 0xFFFFFFFFFFFFFFF8)
                            + v43
                            + ((v49 + 7) & 0xFFFFFFFFFFFFFFF8)
                            + (((v49 + 7) & 0xFFFFFFFFFFFFFFF8) + 32) * (v35 - 2);
                      }
                      uint64_t v51 = *v56;
                      unint64_t v52 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
                      uint64_t v53 = v51 >= 0x80 ? 128 : v51;
                      uint64_t v54 = sizeof_struct_ccrns_mul_modulus();
                      uint64_t result = cche_cipher_plain_ctx_init_ws(a1, v50, (uint64_t)a2, (uint64_t)&v55[2* (v52 + 2 * (v51 + ((unint64_t)(v54 + 7) >> 3) * v53) + 6)* (i + v56[1])]);
                      if (result) {
                        break;
                      }
                      if (++v35 > a3[7]) {
                        return 0;
                      }
                    }
                  }
                  else
                  {
                    return 0;
                  }
                }
              }
              return result;
            }
            return 4294967289;
          }
        }
      }
    }
  }
  return 4294967289;
}

unsigned int *cche_param_ctx_plaintext_ctx(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 28);
  uint64_t v3 = sizeof_struct_cche_cipher_plain_ctx();
  unint64_t v4 = sizeof_struct_ccpolyzp_po2cyc();
  uint64_t v5 = (unsigned int *)(a1 + 8 * ((v4 - 1 + v3 + 8 * v2) / v4));
  uint64_t v6 = sizeof_struct_ccpolyzp_po2cyc();
  uint64_t v8 = *v5;
  uint64_t v7 = v5[1];
  unint64_t v9 = (v4 - 1 + v6) / v4;
  unint64_t v10 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
  if (v8 >= 0x80) {
    uint64_t v11 = 128;
  }
  else {
    uint64_t v11 = v8;
  }
  return &v5[2 * v9
           + 2 * (v10 + 2 * (v8 + ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v11) + 6) * v7];
}

unint64_t CCHE_PARAM_CTX_INIT_WORKSPACE_N(uint64_t a1)
{
  uint64_t v2 = sizeof_struct_cche_cipher_plain_ctx();
  unint64_t v3 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v4 = (8 * a1 + v2 + v3 - 1) / v3;
  unint64_t v5 = CCHE_DECRYPT_CTX_INIT_WORKSPACE_N(a1);
  unint64_t v6 = CCHE_CIPHER_PLAIN_CTX_INIT_WORKSPACE_N(a1);
  if (v5 <= v6) {
    unint64_t v7 = v6;
  }
  else {
    unint64_t v7 = v5;
  }
  return v7 + v4;
}

uint64_t cche_param_ctx_init(unsigned int *a1, int a2, unsigned int a3)
{
  BOOL v20 = timingsafe_enable_if_supported();
  uint64_t v6 = cche_encrypt_params_get(a3);
  if (v6)
  {
    unint64_t v7 = (unsigned int *)v6;
    unint64_t v8 = CCHE_PARAM_CTX_INIT_WORKSPACE_N(*(unsigned int *)(v6 + 28));
    v18[0] = cc_malloc_clear(8 * v8);
    uint64_t v9 = v7[7];
    v18[1] = CCHE_PARAM_CTX_INIT_WORKSPACE_N(v9);
    void v18[2] = 0;
    v18[3] = cc_ws_alloc;
    BOOL v19 = cc_ws_free;
    if (v18[0])
    {
      uint64_t v10 = sizeof_struct_cche_cipher_plain_ctx();
      unint64_t v11 = sizeof_struct_ccpolyzp_po2cyc();
      char v12 = (_DWORD *)cc_ws_alloc(v18, (v10 + 8 * v9 + v11 - 1) / v11);
      uint64_t v13 = v7[7];
      uint64_t v14 = sizeof_struct_cche_cipher_plain_ctx();
      unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
      memcpy(v12, v7, 8 * ((v14 + 8 * v13 + v15 - 1) / v15));
      *char v12 = a2;
      uint64_t inited = cche_param_ctx_init_ws((uint64_t)v18, a1, v12);
      v19((uint64_t)v18);
    }
    else
    {
      uint64_t inited = 4294967283;
    }
  }
  else
  {
    uint64_t inited = 4294967289;
  }
  cc_disable_dit_with_sb((unsigned int *)&v20);
  return inited;
}

unint64_t cche_param_ctx_nof_n(uint64_t a1)
{
  uint64_t v3 = *(unsigned int *)(a1 + 28);
  unsigned int v15 = *(_DWORD *)(a1 + 16);
  uint64_t v2 = v15;
  unsigned int v16 = v3;
  uint64_t v4 = sizeof_struct_cche_cipher_plain_ctx();
  unint64_t v5 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v6 = (v5 - 1 + 8 * v3 + v4) / v5;
  unint64_t v7 = (v5 - 1 + sizeof_struct_ccpolyzp_po2cyc()) / v5;
  unint64_t v8 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
  if (v15 >= 0x80) {
    uint64_t v9 = 128;
  }
  else {
    uint64_t v9 = v15;
  }
  unint64_t v10 = v8 + 2 * (v15 + ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v9) + 6;
  unint64_t v11 = v6 + ((unint64_t)(4 * v2 + 7) >> 3) + v7 + cche_decrypt_ctx_nof_n(&v15) + v10 + v10 * v3;
  unsigned int v12 = *(_DWORD *)(a1 + 28);
  if (v12)
  {
    for (unsigned int i = 1; i <= v12; ++i)
    {
      unsigned int v16 = i;
      v11 += 2 * i + ((unint64_t)(sizeof_struct_cche_cipher_plain_ctx() + 7) >> 3);
    }
  }
  return v11;
}

uint64_t cche_param_ctx_chain_const(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 28);
  uint64_t v3 = sizeof_struct_cche_cipher_plain_ctx();
  unint64_t v4 = sizeof_struct_ccpolyzp_po2cyc();
  return a1 + 8 * ((v3 + 8 * v2 + v4 - 1) / v4);
}

uint64_t cche_param_ctx_sizeof(unsigned int a1)
{
  uint64_t result = cche_encrypt_params_get(a1);
  if (result)
  {
    unint64_t v2 = cche_param_ctx_nof_n(result);
    return sizeof_struct_ccpolyzp_po2cyc() * v2;
  }
  return result;
}

uint64_t cche_param_ctx_he_scheme(unsigned int *a1)
{
  return *a1;
}

uint64_t cche_param_ctx_plaintext_modulus(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t cche_param_ctx_polynomial_degree(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t cche_param_ctx_key_ctx_nmoduli(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 28);
  uint64_t v3 = sizeof_struct_cche_cipher_plain_ctx();
  unint64_t v4 = sizeof_struct_ccpolyzp_po2cyc();
  return *(unsigned int *)(a1 + 8 * ((v3 + 8 * v2 + v4 - 1) / v4) + 12);
}

uint64_t cche_param_ctx_ciphertext_ctx_nmoduli(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 28);
  uint64_t v3 = sizeof_struct_cche_cipher_plain_ctx();
  unint64_t v4 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v5 = (unsigned int *)(a1 + 8 * ((v3 + 8 * v2 + v4 - 1) / v4));
  unint64_t v6 = v5 + 2;
  if (v5[1] >= 2)
  {
    uint64_t v7 = *v5;
    unint64_t v8 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
    if (v7 >= 0x80) {
      uint64_t v9 = 128;
    }
    else {
      uint64_t v9 = v7;
    }
    v6 += 4 * v7 + 4 * ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v9 + 2 * v8 + 12;
  }
  return v6[1];
}

uint64_t cche_param_ctx_coefficient_moduli(uint64_t a1)
{
  BOOL v3 = timingsafe_enable_if_supported();
  cc_disable_dit_with_sb((unsigned int *)&v3);
  return a1 + 32;
}

uint64_t cche_param_ctx_key_ctx_poly_nbytes(uint64_t a1)
{
  BOOL v7 = timingsafe_enable_if_supported();
  uint64_t v2 = *(unsigned int *)(a1 + 28);
  uint64_t v3 = sizeof_struct_cche_cipher_plain_ctx();
  unint64_t v4 = sizeof_struct_ccpolyzp_po2cyc();
  uint64_t v5 = ccpolyzp_po2cyc_serialize_poly_nbytes((unsigned int *)(a1 + 8 * ((v3 + 8 * v2 + v4 - 1) / v4) + 8), 0);
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return v5;
}

uint64_t cche_param_ctx_plaintext_modulus_inverse_ws(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  v12[1] = *MEMORY[0x263EF8C08];
  BOOL v7 = cche_param_ctx_plaintext_ctx(a3);
  unsigned int v8 = v7[1];
  while (--v8)
    BOOL v7 = (unsigned int *)*((void *)v7 + 14);
  uint64_t v9 = (uint64_t)(v7 + 30);
  v12[0] = a4;
  cczp_modn_ws(a1, (void *)v7 + 15, v12, 1, (char *)v12);
  uint64_t result = cczp_inv_ws(a1, v9);
  if (!result) {
    *a2 = v11;
  }
  return result;
}

uint64_t cche_param_ctx_plaintext_modulus_inverse(void *a1, uint64_t a2, uint64_t a3)
{
  BOOL v12 = timingsafe_enable_if_supported();
  unsigned int v8 = cc_malloc_clear(0x48uLL);
  long long v9 = xmmword_2373AF500;
  unint64_t v10 = cc_ws_alloc;
  uint64_t v11 = cc_ws_free;
  if (v8)
  {
    uint64_t v6 = cche_param_ctx_plaintext_modulus_inverse_ws((uint64_t)&v8, a1, a2, a3);
    v11((uint64_t)&v8);
  }
  else
  {
    uint64_t v6 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v6;
}

uint64_t ccecdh_compute_shared_secret_ws(uint64_t a1, unint64_t **a2, unint64_t **a3, unint64_t *a4, char *a5, uint64_t (**a6)(void, uint64_t, unint64_t *))
{
  uint64_t v11 = *a2;
  uint64_t v21 = *(void *)(a1 + 16);
  uint64_t v12 = 3 * **a2;
  uint64_t v13 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  uint64_t v14 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  unint64_t v15 = *a4;
  *a4 = 0;
  unint64_t v16 = ccn_write_uint_size_public_value(*v11, v11 + 3);
  if (v15 < v16
    || *a2 != *a3
    || (unint64_t v17 = v16,
        ccec_validate_point_and_projectify_ws(a1, (uint64_t *)v11, (uint64_t)v14, (uint64_t)(a3 + 2)))
    || ccec_validate_scalar(v11, (uint64_t)&a2[3 * **a2 + 2])
    || ccec_mult_blinded_ws(a1, v11, (uint64_t)v13, (uint64_t)&a2[3 * **a2 + 2], (uint64_t)v14, a6)
    || !ccec_is_point_projective_ws(a1, v11)
    || ccec_affinify_x_only_ws(a1, v11, (uint64_t)v13, (uint64_t)v13))
  {
    uint64_t v18 = 0xFFFFFFFFLL;
  }
  else
  {
    ccn_write_uint_padded_ct_internal(*v11, v13, v17, a5);
    uint64_t v18 = 0;
    *a4 = v17;
  }
  cc_clear(24 * *v11, v13);
  cc_clear(24 * *v11, v14);
  *(void *)(a1 + 16) = v21;
  return v18;
}

uint64_t ccecdh_compute_shared_secret(unint64_t **a1, unint64_t **a2, unint64_t *a3, char *a4, uint64_t (**a5)(void, uint64_t, unint64_t *))
{
  BOOL v15 = timingsafe_enable_if_supported();
  unint64_t v10 = *a1;
  v13[0] = cc_malloc_clear(232 * **a1);
  v13[1] = 29 * *v10;
  v13[2] = 0;
  v13[3] = cc_ws_alloc;
  uint64_t v14 = cc_ws_free;
  if (v13[0])
  {
    uint64_t v11 = ccecdh_compute_shared_secret_ws((uint64_t)v13, a1, a2, a3, a4, a5);
    v14((uint64_t)v13);
  }
  else
  {
    uint64_t v11 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v11;
}

uint64_t (**ccec_projectify_jacobian_ws(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t (**a5)(void, unint64_t, uint64_t)))(void, unint64_t, uint64_t)
{
  uint64_t v5 = a5;
  uint64_t v9 = *(void *)(a1 + 16);
  if (a5)
  {
    uint64_t v10 = cczp_bitlen((uint64_t)a2);
    uint64_t v5 = (uint64_t (**)(void, unint64_t, uint64_t))ccn_random_bits(v10 - 1, a3 + 16 * *a2, v5);
    ccn_set_bit(a3 + 16 * *a2, v10 - 2, 1);
    cczp_sqr_ws(a1, (uint64_t)a2);
    cczp_mul_ws(a1, (uint64_t)a2);
    cczp_mul_ws(a1, (uint64_t)a2);
    cczp_mul_ws(a1, (uint64_t)a2);
  }
  else
  {
    ccn_seti(*a2, (void *)(a3 + 16 * *a2), 1);
    cczp_to_ws(a1, (uint64_t)a2);
  }
  cczp_to_ws(a1, (uint64_t)a2);
  cczp_to_ws(a1, (uint64_t)a2);
  *(void *)(a1 + 16) = v9;
  return v5;
}

uint64_t ccec_projectify_homogeneous_ws(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t (**a5)(void, unint64_t, uint64_t))
{
  uint64_t v9 = cczp_n((uint64_t)a2);
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = (char *)(a3 + 16 * *a2);
  cczp_to_ws(a1, (uint64_t)a2);
  cczp_to_ws(a1, (uint64_t)a2);
  if (!a5)
  {
    ccn_seti(v9, v11, 1);
    cczp_to_ws(a1, (uint64_t)a2);
    goto LABEL_5;
  }
  uint64_t result = cczp_generate_non_zero_element_ws(a1, (uint64_t)a2, a5, v11);
  if (!result)
  {
    cczp_mul_ws(a1, (uint64_t)a2);
    cczp_mul_ws(a1, (uint64_t)a2);
LABEL_5:
    uint64_t result = 0;
  }
  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t ccec_projectify_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 72))();
}

uint64_t ccec_projectify(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v16 = timingsafe_enable_if_supported();
  uint64_t v8 = *a1;
  unint64_t v9 = sizeof_struct_ccpolyzp_po2cyc();
  v14[0] = cc_malloc_clear(8 * (5 * v8 + (v9 + 7) / v9) + 24);
  uint64_t v10 = *a1;
  unint64_t v11 = sizeof_struct_ccpolyzp_po2cyc();
  v14[1] = 5 * v10 + (v11 + 7) / v11 + 3;
  v14[2] = 0;
  void v14[3] = cc_ws_alloc;
  BOOL v15 = cc_ws_free;
  if (v14[0])
  {
    uint64_t v12 = (*(uint64_t (**)(void *, uint64_t *, uint64_t, uint64_t, uint64_t))(a1[2] + 72))(v14, a1, a2, a3, a4);
    v15((uint64_t)v14);
  }
  else
  {
    uint64_t v12 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v12;
}

unsigned __int8 *ccder_decode_rsa_priv_ws(uint64_t a1, unint64_t *a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  unint64_t v52 = a4;
  unint64_t v6 = *a2;
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = ccder_decode_constructed_tl(0x2000000000000010, &v52, a3, a4);
  uint64_t v51 = 0;
  unint64_t v9 = ccder_decode_uint(1uLL, &v51, v8, v52);
  if (v9) {
    BOOL v10 = v51 == 0;
  }
  else {
    BOOL v10 = 0;
  }
  if (!v10) {
    goto LABEL_17;
  }
  unint64_t v11 = ccder_decode_uint(v6, a2 + 3, v9, v52);
  uint64_t v12 = ccder_decode_uint(v6, &a2[2 * *a2 + 4], v11, v52);
  uint64_t result = ccder_decode_uint(v6, &a2[3 * *a2 + 4], v12, v52);
  if (result)
  {
    uint64_t v14 = result;
    if (cczp_init_ws(a1, a2)) {
      goto LABEL_17;
    }
    unint64_t v15 = (((32 * v6) & 0x7FFFFFFFFFFFFFC0) + 64) >> 6;
    BOOL v16 = (void *)ccrsa_ctx_private_zp(a2);
    uint64_t result = ccder_decode_uint(v15, v16 + 3, v14, v52);
    if (!result) {
      goto LABEL_16;
    }
    unint64_t v17 = result;
    uint64_t v18 = cczp_prime((uint64_t)v16);
    *BOOL v16 = (unint64_t)(ccn_bitlen_internal(v15, v18) + 63) >> 6;
    if (cczp_init_ws(a1, v16)) {
      goto LABEL_17;
    }
    uint64_t v19 = ccrsa_ctx_private_zp(a2);
    uint64_t v20 = v19 + 16 * *(void *)ccrsa_ctx_private_zp(a2);
    uint64_t result = ccder_decode_uint(v15, (void *)(v20 + 56), v17, v52);
    if (!result) {
      goto LABEL_16;
    }
    uint64_t v21 = result;
    uint64_t v22 = v20 + 32;
    uint64_t v23 = cczp_prime(v20 + 32);
    *(void *)(v20 + 32) = (unint64_t)(ccn_bitlen_internal(v15, v23) + 63) >> 6;
    if (cczp_init_ws(a1, (void *)(v20 + 32))
      || (unint64_t v24 = cczp_bitlen((uint64_t)v16), v24 < cczp_bitlen(v20 + 32)))
    {
LABEL_17:
      uint64_t result = 0;
      goto LABEL_16;
    }
    uint64_t v48 = v21;
    uint64_t v50 = v7;
    uint64_t v25 = cczp_n((uint64_t)v16);
    uint64_t v26 = (unint64_t *)cczp_prime((uint64_t)v16);
    uint64_t v27 = cczp_n(v20 + 32);
    uint64_t v28 = cczp_prime(v20 + 32);
    uint64_t v49 = *(void *)(a1 + 16);
    int v29 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v25 + 1);
    v29[v25] = v26[v25 - 1] >> 63;
    ccn_shift_left(v25, v29, v26, 1uLL);
    int v30 = ccn_cmpn_internal(v25 + 1, v29, v27, v28);
    *(void *)(a1 + 16) = v49;
    if (v30 ^ 1u | ((unint64_t)v30 >> 32))
    {
      uint64_t result = 0;
    }
    else
    {
      unint64_t v31 = cczp_n((uint64_t)v16);
      uint64_t v32 = ccrsa_ctx_private_zp(a2);
      uint64_t v33 = v32 + 16 * *(void *)ccrsa_ctx_private_zp(a2);
      uint64_t v34 = (void *)ccrsa_ctx_private_zp(a2);
      unsigned int v35 = ccder_decode_uint(v31, (void *)(v33 + 16 * *v34 + 64), v48, v52);
      unint64_t v36 = cczp_n(v22);
      uint64_t v37 = ccrsa_ctx_private_zp(a2);
      uint64_t v38 = v37 + 16 * *(void *)ccrsa_ctx_private_zp(a2);
      uint64_t v39 = v38 + 16 * *(void *)ccrsa_ctx_private_zp(a2);
      unint64_t v40 = (void *)ccrsa_ctx_private_zp(a2);
      uint64_t v41 = ccder_decode_uint(v36, (void *)(v39 + 8 * *v40 + 64), v35, v52);
      unint64_t v42 = cczp_n((uint64_t)v16);
      uint64_t v43 = ccrsa_ctx_private_zp(a2);
      uint64_t v44 = v43 + 16 * *(void *)ccrsa_ctx_private_zp(a2);
      uint64_t v45 = v44 + 16 * *(void *)ccrsa_ctx_private_zp(a2);
      uint64_t v46 = v45 + 8 * *(void *)ccrsa_ctx_private_zp(a2);
      uint64_t v47 = (void *)ccrsa_ctx_private_zp(a2);
      uint64_t result = ccder_decode_uint(v42, (void *)(v46 + 8 * *v47 + 64), v41, v52);
    }
    uint64_t v7 = v50;
  }
LABEL_16:
  *(void *)(a1 + 16) = v7;
  return result;
}

unsigned __int8 *ccder_decode_rsa_priv_internal(unint64_t *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unint64_t v6 = cc_malloc_clear(40 * *a1 + 24);
  uint64_t v7 = 5 * *a1 + 3;
  v10[0] = v6;
  v10[1] = v7;
  v10[2] = 0;
  v10[3] = cc_ws_alloc;
  unint64_t v11 = cc_ws_free;
  if (!v6) {
    return 0;
  }
  uint64_t v8 = ccder_decode_rsa_priv_ws((uint64_t)v10, a1, a2, a3);
  v11((uint64_t)v10);
  return v8;
}

unsigned __int8 *ccder_decode_rsa_priv(unint64_t *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  unint64_t v6 = ccder_decode_rsa_priv_internal(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return v6;
}

uint64_t cchpke_kem_generate_key_pair(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 16) + 48))(a2, a3, a4, a5, a6);
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v12;
}

uint64_t cchpke_params_sizeof_kem_enc(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 8);
}

uint64_t cchpke_params_sizeof_kem_shared_secret(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 16);
}

uint64_t cchpke_params_sizeof_kem_pk(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 24);
}

uint64_t cchpke_params_sizeof_kem_pk_marshalled(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 32);
}

uint64_t cchpke_params_sizeof_kem_sk(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 40);
}

uint64_t cchpke_params_sizeof_kdf_hash(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 8);
}

uint64_t cchpke_params_sizeof_aead_key(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 8);
}

uint64_t cchpke_params_sizeof_aead_tag(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 16);
}

uint64_t cchpke_params_sizeof_aead_nonce(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 24);
}

_UNKNOWN **cchpke_params_x25519_AESGCM128_HKDF_SHA256()
{
  return &cchpke_params_x25519_AESGCM128_HKDF_SHA256_params;
}

uint64_t cchpke_initiator_setup_deterministic(uint64_t *__s, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, size_t a10, const void *a11, uint64_t a12, uint64_t a13)
{
  uint64_t v27 = *MEMORY[0x263EF8C08];
  if (a10 > 0x40 || *(void *)(*(void *)(a2 + 16) + 8) != a12) {
    return 4294967289;
  }
  cc_clear(0x60uLL, __s);
  *int8x16_t __s = a2;
  uint64_t v22 = *(void *)(a2 + 16);
  uint64_t v23 = *(void *)(v22 + 8);
  uint64_t v24 = *(void *)(v22 + 16);
  if (a4 && a5 && a6 && a7) {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t))(v22 + 88))(a2, a4, a5, a6, a7, a8, a9, v24, v26, v23, a13);
  }
  else {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t))(v22 + 80))(a2, a3, a8, a9, v24, v26, v23, a13);
  }
  if (!result) {
    return cchpke_encryption_context_init(a2, (uint64_t)(__s + 1), *(void *)(*(void *)(a2 + 16) + 16), v26, a10, a11);
  }
  return result;
}

uint64_t cchpke_encryption_context_init(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, size_t a5, const void *a6)
{
  uint64_t v17 = *MEMORY[0x263EF8C08];
  uint64_t v12 = *(void *)(*(void *)a1 + 8);
  char v15 = 0;
  uint64_t result = cchpke_labeled_extract((unsigned __int16 **)a1, 0, 0, 0, 0xBuLL, &HPKE_PSK_ID_LABEL, 0, 0, (uint64_t)v16);
  if (!result)
  {
    uint64_t result = cchpke_labeled_extract((unsigned __int16 **)a1, 0, 0, 0, 9uLL, &HPKE_INFO_LABEL, a5, a6, (uint64_t)&v16[*(void *)(*(void *)a1 + 8)]);
    if (!result)
    {
      uint64_t result = cchpke_labeled_extract((unsigned __int16 **)a1, 0, a3, a4, 6uLL, &HPKE_SECRET_LABEL, 0, 0, (uint64_t)v14);
      if (!result)
      {
        uint64_t result = cchpke_labeled_expand((unsigned __int16 **)a1, 0, *(void *)(*(void *)a1 + 8), (uint64_t)v14, 3uLL, &HPKE_KEY_LABEL, (2 * v12) | 1, &v15, *(void *)(*(void *)(a1 + 8) + 8), a2);
        if (!result)
        {
          uint64_t result = cchpke_labeled_expand((unsigned __int16 **)a1, 0, *(void *)(*(void *)a1 + 8), (uint64_t)v14, 0xAuLL, &HPKE_NONCE_LABEL, (2 * v12) | 1, &v15, *(void *)(*(void *)(a1 + 8) + 24), a2 + 32);
          if (!result) {
            return cchpke_labeled_expand((unsigned __int16 **)a1, 0, *(void *)(*(void *)a1 + 8), (uint64_t)v14, 3uLL, &HPKE_EXP_LABEL, (2 * v12) | 1, &v15, *(void *)(*(void *)a1 + 8), a2 + 48);
          }
        }
      }
    }
  }
  return result;
}

uint64_t cchpke_initiator_setup(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, size_t a6, const void *a7, uint64_t a8, uint64_t a9)
{
  BOOL v19 = timingsafe_enable_if_supported();
  uint64_t v17 = cchpke_initiator_setup_deterministic(a1, a2, a3, 0, 0, 0, 0, a4, a5, a6, a7, a8, a9);
  cc_disable_dit_with_sb((unsigned int *)&v19);
  return v17;
}

uint64_t cchpke_responder_setup(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, size_t a5, const void *a6, uint64_t a7, uint64_t a8)
{
  BOOL v18 = timingsafe_enable_if_supported();
  uint64_t v16 = cchpke_responder_setup_internal(a1, a2, a3, a4, a5, a6, a7, a8);
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return v16;
}

uint64_t cchpke_responder_setup_internal(uint64_t *__s, uint64_t a2, uint64_t a3, uint64_t a4, size_t a5, const void *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v17 = *MEMORY[0x263EF8C08];
  uint64_t result = 4294967289;
  if (a5 <= 0x40 && *(void *)(*(void *)(a2 + 16) + 8) == a7)
  {
    cc_clear(0x60uLL, __s);
    *int8x16_t __s = a2;
    uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, void, _OWORD *))(*(void *)(a2 + 16) + 96))(a2, *(void *)(*(void *)(a2 + 16) + 8), a8, a3, a4, *(void *)(*(void *)(a2 + 16) + 16), v16);
    if (!result) {
      return cchpke_encryption_context_init(a2, (uint64_t)(__s + 1), *(void *)(*(void *)(a2 + 16) + 16), v16, a5, a6);
    }
  }
  return result;
}

uint64_t cchpke_initiator_encrypt(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v18 = timingsafe_enable_if_supported();
  uint64_t v16 = cchpke_initiator_encrypt_internal(a1, a2, a3, a4, a5, a6, a7, a8);
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return v16;
}

uint64_t cchpke_initiator_encrypt_internal(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v22 = *MEMORY[0x263EF8C08];
  uint64_t v16 = (uint64_t)(a1 + 1);
  uint64_t v15 = *a1;
  uint64_t v17 = *(void *)(v15 + 8);
  size_t v18 = *(void *)(v17 + 24);
  uint64_t result = cchpke_nonce(v15, v16, v18, v21);
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t, size_t, char *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v17 + 32))(*(void *)(v17 + 8), v16, v18, v21, a2, a3, a4, a5, a6, a7, a8);
    if (!result) {
      ++a1[11];
    }
  }
  return result;
}

uint64_t cchpke_responder_decrypt(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v18 = timingsafe_enable_if_supported();
  uint64_t v16 = cchpke_responder_decrypt_internal(a1, a2, a3, a4, a5, a6, a7, a8);
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return v16;
}

uint64_t cchpke_responder_decrypt_internal(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v22 = *MEMORY[0x263EF8C08];
  uint64_t v16 = (uint64_t)(a1 + 1);
  uint64_t v15 = *a1;
  uint64_t v17 = *(void *)(v15 + 8);
  size_t v18 = *(void *)(v17 + 24);
  uint64_t result = cchpke_nonce(v15, v16, v18, v21);
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t, size_t, char *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v17 + 40))(*(void *)(v17 + 8), v16, v18, v21, a2, a3, a4, a5, a8, a6, a7);
    if (!result) {
      ++a1[11];
    }
  }
  return result;
}

uint64_t cchpke_initiator_seal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, size_t a5, const void *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  uint64_t v27 = *MEMORY[0x263EF8C08];
  BOOL v25 = timingsafe_enable_if_supported();
  memset(__s, 0, sizeof(__s));
  uint64_t v23 = cchpke_initiator_setup_deterministic((uint64_t *)__s, a1, a2, 0, 0, 0, 0, a3, a4, a5, a6, a14, a15);
  if (!v23)
  {
    uint64_t v23 = cchpke_initiator_encrypt_internal((uint64_t *)__s, a7, a8, a9, a10, a11, a12, a13);
    cc_clear(0x60uLL, __s);
  }
  cc_disable_dit_with_sb((unsigned int *)&v25);
  return v23;
}

uint64_t cchpke_responder_open(uint64_t a1, uint64_t a2, uint64_t a3, size_t a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v26 = *MEMORY[0x263EF8C08];
  BOOL v24 = timingsafe_enable_if_supported();
  memset(__s, 0, sizeof(__s));
  uint64_t v22 = cchpke_responder_setup_internal((uint64_t *)__s, a1, a2, a3, a4, a5, a12, a13);
  if (!v22)
  {
    uint64_t v22 = cchpke_responder_decrypt_internal((uint64_t *)__s, a6, a7, a8, a9, a10, a11, a14);
    cc_clear(0x60uLL, __s);
  }
  cc_disable_dit_with_sb((unsigned int *)&v24);
  return v22;
}

uint64_t cchpke_responder_export(unsigned __int16 ***a1, size_t a2, const void *a3, unint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  if (a2 > 0x40) {
    uint64_t v10 = 4294967289;
  }
  else {
    uint64_t v10 = cchpke_labeled_expand(*a1, 0, *((void *)**a1 + 1), (uint64_t)(a1 + 7), 3uLL, &HPKE_SEC_LABEL, a2, a3, a4, a5);
  }
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t cchpke_initiator_export(unsigned __int16 ***a1, size_t a2, const void *a3, unint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  if (a2 > 0x40) {
    uint64_t v10 = 4294967289;
  }
  else {
    uint64_t v10 = cchpke_labeled_expand(*a1, 0, *((void *)**a1 + 1), (uint64_t)(a1 + 7), 3uLL, &HPKE_SEC_LABEL, a2, a3, a4, a5);
  }
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t cchpke_kdf_hkdf_sha256_hash(size_t a1, char *a2, uint64_t a3)
{
  unint64_t v6 = ccsha256_di();

  return ccdigest_internal((uint64_t)v6, a1, a2, a3);
}

uint64_t cchpke_aead_aesgcm128_seal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  BOOL v19 = ccaes_gcm_encrypt_mode();
  return ccgcm_one_shot_internal((uint64_t)v19, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t cchpke_aead_aesgcm128_open(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  BOOL v19 = ccaes_gcm_decrypt_mode();
  return ccgcm_one_shot_internal((uint64_t)v19, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

double cchpke_kem_x25519_generate_key_pair(uint64_t (**a1)(void, uint64_t, void *), uint64_t a2, _OWORD *a3, uint64_t a4, _OWORD *a5)
{
  uint64_t v14 = *MEMORY[0x263EF8C08];
  if (a2 == 32 && a4 == 32)
  {
    long long v12 = 0u;
    long long v13 = 0u;
    long long v10 = 0u;
    long long v11 = 0u;
    if (!cccurve25519_make_key_pair_internal(a1, (char *)&v10, (uint64_t)&v12))
    {
      long long v8 = v13;
      *a3 = v12;
      a3[1] = v8;
      double result = *(double *)&v10;
      long long v9 = v11;
      *a5 = v10;
      a5[1] = v9;
    }
  }
  return result;
}

uint64_t cchpke_kem_x25519_serialize(uint64_t a1, _OWORD *a2, _OWORD *a3)
{
  if (a1 != 32) {
    return 4294967289;
  }
  uint64_t result = 0;
  long long v4 = a2[1];
  *a3 = *a2;
  a3[1] = v4;
  return result;
}

uint64_t cchpke_kem_x25519_deserialize(uint64_t a1, _OWORD *a2, _OWORD *a3)
{
  if (a1 != 32) {
    return 4294967289;
  }
  uint64_t result = 0;
  long long v4 = a2[1];
  *a3 = *a2;
  a3[1] = v4;
  return result;
}

uint64_t cchpke_kem_x25519_public_key(uint64_t a1, long long *a2, uint64_t a3, char *a4)
{
  if (a1 == 32 && a3 == 32) {
    return cccurve25519_make_pub_internal(a4, a2);
  }
  else {
    return 4294967289;
  }
}

void cchpke_kem_x25519_encap(uint64_t a1, uint64_t (**a2)(void, uint64_t, void *), uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, _OWORD *a8)
{
  uint64_t v15 = *MEMORY[0x263EF8C08];
  if (a3 == 32 && a5 == 32 && a7 == 32)
  {
    cchpke_kem_x25519_generate_key_pair(a2, 32, v14, 32, v13);
    if (!v12) {
      cchpke_kem_x25519_encap_deterministic(a1, 32, v14, 32, v13, 32, a4, 32, a6, 32, a8);
    }
  }
}

uint64_t cchpke_kem_x25519_encap_deterministic(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, _OWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, _OWORD *a11)
{
  uint64_t v20 = *MEMORY[0x263EF8C08];
  uint64_t result = 4294967289;
  if ((unint64_t)(a10 + 32) <= 0x40 && a4 == 32 && a2 == 32 && a6 == 32 && a8 == 32 && a10 == 32)
  {
    memset(v19, 0, sizeof(v19));
    uint64_t result = cccurve25519_assumes_dit_internal((char *)v19, a3, (uint64_t *)a7);
    if (!result)
    {
      long long v15 = a5[1];
      *a11 = *a5;
      a11[1] = v15;
      long long v16 = a11[1];
      v18[0] = *a11;
      v18[1] = v16;
      long long v17 = *(_OWORD *)(a7 + 16);
      void v18[2] = *(_OWORD *)a7;
      v18[3] = v17;
      return cchpke_extract_and_expand(a1, v19, v18, a9);
    }
  }
  return result;
}

uint64_t cchpke_kem_x25519_decap(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, long long *a5, uint64_t a6, void *a7)
{
  uint64_t v19 = *MEMORY[0x263EF8C08];
  uint64_t result = 4294967289;
  if (a4 == 32 && a2 == 32 && a6 == 32)
  {
    long long v12 = a3[1];
    v18[0] = *a3;
    v18[1] = v12;
    long long v16 = 0u;
    long long v17 = 0u;
    uint64_t result = cccurve25519_make_pub_internal((char *)&v16, a5);
    if (!result)
    {
      long long v13 = a3[1];
      v15[0] = *a3;
      v15[1] = v13;
      void v15[2] = v16;
      v15[3] = v17;
      memset(v14, 0, sizeof(v14));
      uint64_t result = cccurve25519_assumes_dit_internal((char *)v14, a5, (uint64_t *)v18);
      if (!result) {
        return cchpke_extract_and_expand(a1, v14, v15, a7);
      }
    }
  }
  return result;
}

uint64_t cchpke_extract_and_expand(uint64_t a1, const void *a2, const void *a3, void *a4)
{
  uint64_t v11 = *MEMORY[0x263EF8C08];
  uint64_t v7 = cchpke_labeled_extract((unsigned __int16 **)a1, 1, 0, 0, 7uLL, &HPKE_EAE_LABEL, 0x20uLL, a2, (uint64_t)__s);
  if (v7) {
    return v7;
  }
  uint64_t v8 = cchpke_labeled_expand((unsigned __int16 **)a1, 1, *(void *)(*(void *)a1 + 8), (uint64_t)__s, 0xDuLL, &HPKE_SHARED_SECRET_LABEL, 0x40uLL, a3, *(void *)(*(void *)(a1 + 16) + 16), (uint64_t)a4);
  if (v8) {
    cc_clear(*(void *)(*(void *)(a1 + 16) + 16), a4);
  }
  cc_clear(0x20uLL, __s);
  return v8;
}

uint64_t cchpke_labeled_extract(unsigned __int16 **a1, int a2, uint64_t a3, _OWORD *a4, size_t a5, const void *a6, size_t a7, const void *a8, uint64_t a9)
{
  *(void *)&v22[85] = *MEMORY[0x263EF8C08];
  qmemcpy(__s, "HPKE-v1", sizeof(__s));
  uint64_t v16 = cchpke_suite_id(a1, a2, (uint64_t)v22) + 7;
  memcpy(&__s[v16], a6, a5);
  long long v17 = memcpy(&__s[v16 + a5], a8, a7);
  size_t v18 = (uint64_t *)(*((uint64_t (**)(void *))*a1 + 3))(v17);
  uint64_t internal = cchkdf_extract_internal(v18, a3, a4, v16 + a5 + a7, (uint64_t)__s, a9);
  cc_clear(0x5CuLL, __s);
  return internal;
}

uint64_t cchpke_labeled_expand(unsigned __int16 **a1, int a2, rsize_t a3, uint64_t a4, size_t a5, const void *a6, size_t a7, const void *a8, unint64_t a9, uint64_t a10)
{
  *(void *)&v25[89] = *MEMORY[0x263EF8C08];
  if (a9 >> 16) {
    return 4294967289;
  }
  __int16 __s = bswap32(a9) >> 16;
  qmemcpy(v24, "HPKE-v1", sizeof(v24));
  uint64_t v17 = cchpke_suite_id(a1, a2, (uint64_t)v25) + 9;
  memcpy(&v24[v17 - 2], a6, a5);
  size_t v18 = v17 + a5;
  uint64_t v19 = memcpy(&v24[v18 - 2], a8, a7);
  uint64_t v20 = (rsize_t *)(*((uint64_t (**)(void *))*a1 + 3))(v19);
  uint64_t v21 = cchkdf_expand_internal(v20, a3, a4, v18 + a7, (uint64_t)&__s, a9, a10);
  cc_clear(0x61uLL, &__s);
  return v21;
}

uint64_t cchpke_suite_id(unsigned __int16 **a1, int a2, uint64_t a3)
{
  unsigned int v3 = bswap32(*a1[2]) >> 16;
  if (a2)
  {
    *(unsigned char *)(a3 + 2) = 77;
    *(_WORD *)a3 = 17739;
    uint64_t result = 5;
    uint64_t v5 = 3;
  }
  else
  {
    unsigned int v6 = bswap32(*a1[1]);
    unsigned int v7 = **a1;
    *(_WORD *)(a3 + 4) = v3;
    unsigned int v3 = HIWORD(v6);
    *(_DWORD *)a3 = 1162563656;
    *(_WORD *)(a3 + 6) = bswap32(v7) >> 16;
    uint64_t result = 10;
    uint64_t v5 = 8;
  }
  *(_WORD *)(a3 + v5) = v3;
  return result;
}

uint64_t cchpke_nonce(uint64_t a1, uint64_t a2, size_t a3, char *a4)
{
  if (*(void *)(*(void *)(a1 + 8) + 24) != a3) {
    return 4294967289;
  }
  bzero(a4, a3);
  *(void *)&a4[*(void *)(*(void *)(a1 + 8) + 24) - 8] = bswap64(*(void *)(a2 + 80));
  if (*(void *)(*(void *)(a1 + 8) + 24))
  {
    unint64_t v7 = 0;
    do
    {
      a4[v7] ^= *(unsigned char *)(a2 + 32 + v7);
      ++v7;
    }
    while (v7 < *(void *)(*(void *)(a1 + 8) + 24));
  }
  return 0;
}

uint64_t ccrsa_generate_key_internal_ws(uint64_t a1, unint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t (**a6)(void, unint64_t, uint64_t), uint64_t (**a7)(void, unint64_t, uint64_t))
{
  if (a2 > 0x2000) {
    return 4294967273;
  }
  unint64_t v13 = a2 >> 1;
  unint64_t v14 = (a2 >> 1) + 1;
  unint64_t v15 = a2 - v14;
  unint64_t v16 = (a2 + 63) >> 6;
  uint64_t v29 = *(void *)(a1 + 16);
  *a3 = v16;
  uint64_t v17 = (void *)ccrsa_ctx_public(a3);
  *(void *)ccrsa_ctx_private_zp(a3) = (v13 + 64) >> 6;
  uint64_t v18 = ccrsa_ctx_private_zp(a3);
  *(void *)(v18 + 16 * *(void *)ccrsa_ctx_private_zp(a3) + 32) = (v15 + 63) >> 6;
  uint64_t v19 = v17 + 3;
  uint64_t result = ccn_read_uint_internal(v16, &v17[2 * *v17 + 4], a4, a5);
  if (!result)
  {
    uint64_t v20 = &v19[2 * *v17];
    char v22 = *((unsigned char *)v20 + 8);
    uint64_t v21 = v20 + 1;
    if ((v22 & 1) != 0 && (unint64_t)ccn_bitlen_internal(v16, v21) >= 2)
    {
      uint64_t v23 = (void *)ccrsa_ctx_private_zp(a3);
      uint64_t v24 = ccrsa_ctx_private_zp(a3);
      uint64_t v25 = *(void *)ccrsa_ctx_private_zp(a3);
      uint64_t result = ccrsa_generate_prime_ws(a1, v14, v23 + 3, &v19[2 * *v17 + 1], a6, a7);
      if (!result)
      {
        uint64_t result = cczp_init_ws(a1, v23);
        if (!result)
        {
          uint64_t v26 = v24 + 16 * v25;
          uint64_t result = ccrsa_generate_prime_ws(a1, v15, (void *)(v26 + 56), &v19[2 * *v17 + 1], a6, a7);
          if (!result)
          {
            uint64_t result = cczp_init_ws(a1, (void *)(v26 + 32));
            if (!result)
            {
              uint64_t result = ccrsa_crt_makekey_ws(a1, a3);
              if (!result)
              {
                ccrsa_pairwise_consistency_check_ws(a1, a3, (uint64_t (**)(void, uint64_t, uint64_t))a6);
                if (v27) {
                  uint64_t result = 4294967259;
                }
                else {
                  uint64_t result = 0;
                }
              }
            }
          }
        }
      }
    }
    else
    {
      uint64_t result = 4294967273;
    }
  }
  *(void *)(a1 + 16) = v29;
  return result;
}

uint64_t ccrsa_generate_key_internal(unint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t (**a5)(void, unint64_t, uint64_t), uint64_t (**a6)(void, unint64_t, uint64_t))
{
  unint64_t v10 = a1 + 63;
  unint64_t v11 = (a1 + 63) >> 6;
  uint64_t v12 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v13 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v14 = (v12 + v13 - 1) / v13;
  uint64_t v15 = 11 * v11 + 1;
  unint64_t v16 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(v11);
  if (v14 + v15 <= v16) {
    unint64_t v17 = v16;
  }
  else {
    unint64_t v17 = v14 + v15;
  }
  uint64_t v18 = 8 * v11 - (v10 >> 6);
  unint64_t v19 = v17 + v18;
  uint64_t v20 = 21 * v11 + 2;
  if (v19 <= v14 + v20) {
    unint64_t v19 = v14 + v20;
  }
  uint64_t v21 = cc_malloc_clear(8 * v19);
  v33[0] = v21;
  uint64_t v22 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v23 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v24 = (v22 + v23 - 1) / v23;
  unint64_t v25 = v24 + v15;
  unint64_t v26 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(v11);
  if (v25 <= v26) {
    unint64_t v27 = v26;
  }
  else {
    unint64_t v27 = v25;
  }
  unint64_t v28 = v27 + v18;
  if (v28 <= v24 + v20) {
    unint64_t v28 = v24 + v20;
  }
  v33[1] = v28;
  v33[2] = 0;
  v33[3] = cc_ws_alloc;
  uint64_t v34 = cc_ws_free;
  if (!v21) {
    return 4294967283;
  }
  uint64_t key_internal_ws = ccrsa_generate_key_internal_ws((uint64_t)v33, a1, a2, a3, a4, a5, a6);
  v34((uint64_t)v33);
  return key_internal_ws;
}

uint64_t ccrsa_make_priv(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  BOOL v45 = timingsafe_enable_if_supported();
  unint64_t v14 = *a1 + (*a1 & 0xFFFFFFFFFFFFFFFELL) + 9 * *a1 + 4;
  v41[0] = cc_malloc_clear(8 * v14);
  v41[1] = v14;
  uint64_t v42 = 0;
  uint64_t v43 = cc_ws_alloc;
  uint64_t v44 = cc_ws_free;
  if (v41[0])
  {
    uint64_t v39 = a3;
    uint64_t v40 = a2;
    unint64_t v15 = *a1;
    uint64_t v16 = (*a1 >> 1) + 1;
    unint64_t v17 = (uint64_t *)cc_ws_alloc(v41, v16);
    uint64_t v18 = a5;
    unint64_t v19 = (uint64_t *)v43(v41, v16);
    uint64_t v20 = (void *)v43(v41, v15);
    if (!ccn_read_uint_internal(v16, v17, a4, v18)
      && !ccn_read_uint_internal(v16, v19, a6, a7)
      && !ccn_read_uint_internal(v15, v20, v40, v39))
    {
      unint64_t v21 = ccn_n(v15, (uint64_t)v20);
      if (v21)
      {
        uint64_t v22 = v21;
        if (ccn_n(v21, (uint64_t)v20) > 1 || *v20 >= 2uLL)
        {
          int v23 = ccn_cmp_internal(v16, v17, v19);
          if (v23)
          {
            ccn_cond_swap(v16, v23 < 0, v17, v19);
            uint64_t v24 = ccn_bitlen_internal(v16, v17);
            uint64_t v25 = ccn_bitlen_internal(v16, v19);
            if ((unint64_t)(v24 - v25) > 2)
            {
              uint64_t v37 = 4294967257;
              goto LABEL_17;
            }
            if (v25 + v24 <= v15 << 6)
            {
              unint64_t v26 = (unint64_t)(v24 + 63) >> 6;
              unint64_t v27 = (unint64_t)(v25 + 63) >> 6;
              *(void *)ccrsa_ctx_private_zp(a1) = v26;
              uint64_t v28 = ccrsa_ctx_private_zp(a1);
              ccn_set(v26, (void *)(v28 + 24), v17);
              uint64_t v29 = ccrsa_ctx_private_zp(a1);
              *(void *)(v29 + 16 * *(void *)ccrsa_ctx_private_zp(a1) + 32) = v27;
              uint64_t v30 = ccrsa_ctx_private_zp(a1);
              unint64_t v31 = (void *)ccrsa_ctx_private_zp(a1);
              ccn_set(v27, (void *)(v30 + 16 * *v31 + 56), v19);
              uint64_t v32 = &a1[2 * *a1 + 4];
              ccn_set(v22, v32, v20);
              ccn_zero(v15 - v22, &v32[v22]);
              uint64_t v42 = 0;
              uint64_t v33 = (void *)ccrsa_ctx_private_zp(a1);
              uint64_t inited = cczp_init_ws((uint64_t)v41, v33);
              if (!inited)
              {
                uint64_t v35 = ccrsa_ctx_private_zp(a1);
                unint64_t v36 = (void *)ccrsa_ctx_private_zp(a1);
                uint64_t inited = cczp_init_ws((uint64_t)v41, (void *)(v35 + 16 * *v36 + 32));
                if (!inited) {
                  uint64_t inited = ccrsa_crt_makekey_ws((uint64_t)v41, a1);
                }
              }
              uint64_t v37 = inited;
              goto LABEL_17;
            }
          }
        }
      }
    }
    uint64_t v37 = 4294967273;
LABEL_17:
    uint64_t v42 = 0;
    v44((uint64_t)v41);
    goto LABEL_18;
  }
  uint64_t v37 = 4294967283;
LABEL_18:
  cc_disable_dit_with_sb((unsigned int *)&v45);
  return v37;
}

void *ccaes_gcm_decrypt_mode()
{
  uint64_t v0 = ccaes_ecb_encrypt_mode();
  ccmode_factory_gcm_decrypt(gcm_decrypt, v0);
  return gcm_decrypt;
}

uint64_t ccrsa_verify_pkcs1v15(unint64_t *a1, uint64_t a2, unint64_t a3, char *a4, unint64_t a5, uint64_t a6, unsigned char *a7)
{
  v25[2] = *MEMORY[0x263EF8C08];
  BOOL v24 = timingsafe_enable_if_supported();
  *a7 = 0;
  unint64_t v13 = *a1;
  uint64_t v14 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
  v22[0] = cc_malloc_clear(8 * ((v14 + v15 - 1) / v15 + 13 * v13) + 8);
  unint64_t v16 = *a1;
  uint64_t v17 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v18 = sizeof_struct_ccpolyzp_po2cyc();
  v22[1] = (v17 + v18 - 1) / v18 + 13 * v16 + 1;
  v22[2] = 0;
  v22[3] = cc_ws_alloc;
  int v23 = cc_ws_free;
  if (v22[0])
  {
    v25[0] = 0;
    v25[1] = 0;
    uint64_t v19 = ccrsa_verify_pkcs1v15_internal_ws((uint64_t)v22, a1, a2, a3, a4, a5, a6, 0, (unsigned __int8 *)v25);
    v23((uint64_t)v22);
    if (v19)
    {
      if (v19 == -146) {
        uint64_t v19 = 0;
      }
      else {
        uint64_t v19 = v19;
      }
    }
    else
    {
      *a7 = 1;
    }
  }
  else
  {
    uint64_t v19 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v24);
  return v19;
}

double ccrsa_verify_pkcs1v15_digest_ws(uint64_t a1, unint64_t *a2, uint64_t a3, unint64_t a4, char *a5, unint64_t a6, uint64_t a7, void *a8)
{
  uint64_t v11 = *MEMORY[0x263EF8C08];
  if (a8)
  {
    *a8 = 0;
    a8[1] = 0;
  }
  long long v10 = 0uLL;
  ccrsa_verify_pkcs1v15_internal_ws(a1, a2, a3, a4, a5, a6, a7, 0, (unsigned __int8 *)&v10);
  if (a8)
  {
    double result = *(double *)&v10;
    *(_OWORD *)a8 = v10;
  }
  return result;
}

uint64_t ccrsa_verify_pkcs1v15_digest(unint64_t *a1, uint64_t a2, unint64_t a3, char *a4, unint64_t a5, uint64_t a6, void *a7)
{
  BOOL v26 = timingsafe_enable_if_supported();
  unint64_t v13 = *a1;
  uint64_t v14 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
  v24[0] = cc_malloc_clear(8 * ((v14 + v15 - 1) / v15 + 13 * v13) + 8);
  unint64_t v16 = *a1;
  uint64_t v17 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v18 = sizeof_struct_ccpolyzp_po2cyc();
  v24[1] = (v17 + v18 - 1) / v18 + 13 * v16 + 1;
  v24[2] = 0;
  v24[3] = cc_ws_alloc;
  uint64_t v25 = cc_ws_free;
  if (v24[0])
  {
    double v19 = ccrsa_verify_pkcs1v15_digest_ws((uint64_t)v24, a1, a2, a3, a4, a5, a6, a7);
    uint64_t v21 = v20;
    ((void (*)(void *, double))v25)(v24, v19);
  }
  else
  {
    uint64_t v21 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v26);
  return v21;
}

double ccrsa_verify_pkcs1v15_msg_ws(uint64_t a1, unint64_t *a2, uint64_t a3, size_t a4, char *a5, unint64_t a6, uint64_t a7, void *a8)
{
  uint64_t v16 = *MEMORY[0x263EF8C08];
  ccdigest_internal(a3, a4, a5, (uint64_t)v15);
  return ccrsa_verify_pkcs1v15_digest_ws(a1, a2, *(void *)(a3 + 32), *(void *)a3, v15, a6, a7, a8);
}

uint64_t ccrsa_verify_pkcs1v15_msg(unint64_t *a1, uint64_t a2, size_t a3, char *a4, unint64_t a5, uint64_t a6, void *a7)
{
  uint64_t v28 = *MEMORY[0x263EF8C08];
  BOOL v26 = timingsafe_enable_if_supported();
  unint64_t v13 = *a1;
  uint64_t v14 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
  v24[0] = cc_malloc_clear(8 * ((v14 + v15 - 1) / v15 + 13 * v13) + 8);
  unint64_t v16 = *a1;
  uint64_t v17 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v18 = sizeof_struct_ccpolyzp_po2cyc();
  v24[1] = (v17 + v18 - 1) / v18 + 13 * v16 + 1;
  v24[2] = 0;
  v24[3] = cc_ws_alloc;
  uint64_t v25 = cc_ws_free;
  if (v24[0])
  {
    ccdigest_internal(a2, a3, a4, (uint64_t)v27);
    double v19 = ccrsa_verify_pkcs1v15_digest_ws((uint64_t)v24, a1, *(void *)(a2 + 32), *(void *)a2, v27, a5, a6, a7);
    uint64_t v21 = v20;
    ((void (*)(void *, double))v25)(v24, v19);
  }
  else
  {
    uint64_t v21 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v26);
  return v21;
}

uint64_t ccapsic_client_generate_match_response(uint64_t a1, unint64_t **a2, unint64_t **a3)
{
  BOOL v17 = timingsafe_enable_if_supported();
  unsigned int v6 = *(unint64_t **)a1;
  unint64_t v7 = *(uint64_t (***)(void, uint64_t, unint64_t *))(a1 + 8);
  unint64_t v8 = **(void **)a1;
  unint64_t v9 = 23 * v8;
  if (23 * v8 <= 11 * v8) {
    unint64_t v9 = 11 * v8;
  }
  if (v9 <= v8) {
    unint64_t v10 = **(void **)a1;
  }
  else {
    unint64_t v10 = v9;
  }
  v15[0] = cc_malloc_clear(8 * v10);
  v15[1] = v10;
  void v15[2] = 0;
  v15[3] = cc_ws_alloc;
  unint64_t v16 = cc_ws_free;
  if (v15[0])
  {
    if (*a2 == v6 && *a3 == v6)
    {
      uint64_t v11 = a1 + 192;
      uint64_t scalar_fips_retry_ws = ccec_generate_scalar_fips_retry_ws((uint64_t)v15, v6, (uint64_t (**)(void, unint64_t, void *))v7, (void *)(a1 + 192));
      if (scalar_fips_retry_ws
        || (uint64_t scalar_fips_retry_ws = ccec_mult_blinded_ws((uint64_t)v15, v6, (uint64_t)(a2 + 2), a1 + 192, v11 + 16 * v8, v7), scalar_fips_retry_ws)|| (uint64_t scalar_fips_retry_ws = ccec_mult_blinded_ws((uint64_t)v15, v6, (uint64_t)(a3 + 2), a1 + 192, v11 + 16 * v8 + 24 * v8, v7), scalar_fips_retry_ws)|| (uint64_t scalar_fips_retry_ws = ccec_affinify_ws((uint64_t)v15, (uint64_t)v6), scalar_fips_retry_ws))
      {
        uint64_t v13 = scalar_fips_retry_ws;
      }
      else
      {
        uint64_t v13 = ccec_affinify_ws((uint64_t)v15, (uint64_t)v6);
        if (!v13)
        {
          ccn_seti(*v6, &a3[2 * **a3 + 2], 1);
          ccn_seti(*v6, &a2[2 * **a2 + 2], 1);
        }
      }
    }
    else
    {
      uint64_t v13 = 4294967289;
    }
    v16((uint64_t)v15);
  }
  else
  {
    uint64_t v13 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v17);
  return v13;
}

uint64_t ccmode_ofb_init(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *__src)
{
  uint64_t v8 = *(void *)(a1 + 32);
  *a2 = v8;
  unint64_t v9 = a2 + 2;
  memcpy(a2 + 2, __src, *(void *)(v8 + 8));
  unint64_t v10 = *(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(v8 + 16);
  a2[1] = *(void *)(v8 + 8);
  uint64_t v11 = (char *)v9 + ((*(void *)(v8 + 8) + 7) & 0xFFFFFFFFFFFFFFF8);

  return v10(v8, v11, a3, a4);
}

double ccmode_factory_gcm_decrypt(void *a1, void *a2)
{
  *a1 = ((*a2 + 7) & 0xFFFFFFFFFFFFFFF8) + 5 * ((a2[1] + 7) & 0xFFFFFFFFFFFFFFF8) + 128;
  *(void *)&double result = 78647;
  a1[1] = 78647;
  a1[2] = 1;
  a1[3] = ccmode_gcm_init;
  a1[4] = ccmode_gcm_set_iv;
  a1[5] = ccmode_gcm_aad;
  a1[6] = ccmode_gcm_decrypt;
  a1[7] = ccmode_gcm_finalize;
  a1[8] = ccmode_gcm_reset;
  a1[9] = a2;
  return result;
}

uint64_t ccmode_cfb8_decrypt(unsigned char *a1, uint64_t a2, char *a3, unsigned char *a4)
{
  if (a2)
  {
    uint64_t v6 = a2;
    unint64_t v7 = a1 + 8;
    uint64_t v8 = *(void *)a1;
    unint64_t v9 = (unint64_t)(*(void *)(*(void *)a1 + 8) + 7) >> 3;
    uint64_t v10 = (uint64_t)&a1[16 * v9 + 8];
    uint64_t v11 = (uint64_t)&a1[8 * v9 + 8];
    do
    {
      --v6;
      memmove((void *)v11, (const void *)(v11 + 1), *(void *)(v8 + 8) - 1);
      char v12 = *a3++;
      *(unsigned char *)(*(void *)(v8 + 8) + v11 - 1) = v12;
      *a4++ = *v7 ^ v12;
      (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *))(v8 + 24))(v10, 1, v11, v7);
    }
    while (v6);
  }
  return 0;
}

uint64_t ccpad_cts1_encrypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  uint64_t v19 = *MEMORY[0x263EF8C08];
  BOOL v17 = timingsafe_enable_if_supported();
  size_t v12 = *(void *)(a1 + 8);
  unint64_t v13 = (a4 - 1) / v12;
  if (v13 >= 2)
  {
    uint64_t v15 = (v13 - 1) * v12;
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a2, a3);
    uint64_t v14 = a4 - v15;
    a5 += v15;
    a6 += v15;
  }
  else
  {
    uint64_t v14 = a4;
  }
  if (v14 == 2 * v12)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, char *))(a1 + 24))(a2, a3, 2, a5, a6);
  }
  else
  {
    __memcpy_chk();
    cc_clear(v12 - (v14 - v12), &__src[v14]);
    (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *))(a1 + 24))(a2, a3, 2, __src, __src);
    memmove(a6, __src, v14 - v12);
    memmove(&a6[v14 - v12], &__src[v12], v12);
  }
  cc_disable_dit_with_sb((unsigned int *)&v17);
  return a4;
}

unint64_t ccpad_pkcs7_decode_internal(uint64_t a1, uint64_t a2)
{
  return ((((*(unsigned __int8 *)(a1 + a2 - 1) + ~(_BYTE)a1) | (256
                                                                               - *(unsigned __int8 *)(a1 + a2 - 1))) >> 8)
        - 1) & (unint64_t)*(unsigned __int8 *)(a1 + a2 - 1);
}

uint64_t ccpad_pkcs7_decode(uint64_t a1, uint64_t a2)
{
  BOOL v6 = timingsafe_enable_if_supported();
  uint64_t v4 = ((((*(unsigned __int8 *)(a1 + a2 - 1) + ~(_BYTE)a1) | (256
                                                                             - *(unsigned __int8 *)(a1 + a2 - 1))) >> 8)
      - 1) & *(unsigned __int8 *)(a1 + a2 - 1);
  cc_disable_dit_with_sb((unsigned int *)&v6);
  return v4;
}

uint64_t ccmode_siv_hmac_init(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  *a2 = a1;
  if (a3 > 0x40) {
    return 4294967226;
  }
  uint64_t result = 4294967226;
  if (a3 - 32 <= 0x20 && ((1 << (a3 - 32)) & 0x100010001) != 0)
  {
    unint64_t v7 = *(unint64_t **)(a1 + 56);
    if (a3 >> 1 <= v7[1])
    {
      if (*v7 >= a5)
      {
        if (a5 >= 0x14)
        {
          if (*(void *)(*(void *)(a1 + 64) + 16) == 16)
          {
            a2[1] = a3;
            __memcpy_chk();
            __memcpy_chk();
            a2[2] = a5;
            return ccmode_siv_hmac_reset((uint64_t)a2);
          }
        }
        else
        {
          return 4294967195;
        }
      }
      else
      {
        return 4294967196;
      }
    }
  }
  return result;
}

void *ccdes3_ecb_decrypt_mode()
{
  return &ccdes3_ltc_ecb_decrypt_mode;
}

void *ccdh_gp_rfc3526group18()
{
  return &_ccdh_gp_rfc3526group18;
}

uint64_t fipspost_post_aes_ccm(char a1)
{
  uint64_t v31 = *MEMORY[0x263EF8C08];
  long long v30 = *(_OWORD *)"@ABCDEFGHIJKLMNO";
  *(_DWORD *)((char *)v22 + 3) = 370480147;
  v22[0] = 319951120;
  uint64_t v29 = 0x706050403020100;
  int v21 = 1526817393;
  int v20 = 589439264;
  if ((a1 & 0x10) != 0) {
    uint64_t v2 = "\x01M\xAC%]";
  }
  else {
    uint64_t v2 = "M\xAC%]";
  }
  int v18 = 0;
  unsigned int v3 = ccaes_ccm_decrypt_mode();
  if (ccccm_one_shot((uint64_t)v3, 16, (uint64_t)&v30, 7, (uint64_t)v22, 4, (uint64_t)&v21, (uint64_t)v19, 8, (uint64_t)&v29, 4, (uint64_t)&v18))
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccccm_one_shot AEAD decrypt authentication\n");
    return 4294967223;
  }
  if (cc_cmp_safe(4, (char *)&v18, v2))
  {
    uint64_t v4 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccccm_one_shot AEAD decrypt authentication\n", v4, "fipspost_post_aes_ccm", 61);
    uint64_t v5 = 4294967221;
  }
  else
  {
    uint64_t v5 = 0;
  }
  if (cc_cmp_safe(4, v19, (char *)&v20))
  {
    uint64_t v6 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccccm_one_shot AEAD decrypt decryption\n", v6, "fipspost_post_aes_ccm", 65);
    uint64_t v5 = 4294967221;
  }
  if (ccccm_one_shot_decrypt((uint64_t)v3, 16, (uint64_t)&v30, 7, (uint64_t)v22, 4, (uint64_t)&v21, (uint64_t)v19, 8, (uint64_t)&v29, 4, v2))
  {
    uint64_t v7 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccccm_one_shot AEAD decrypt authentication\n", v7, "fipspost_post_aes_ccm", 75);
    uint64_t v5 = 4294967221;
  }
  if (cc_cmp_safe(4, v19, (char *)&v20))
  {
    uint64_t v8 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccccm_one_shot AEAD decrypt decryption\n", v8, "fipspost_post_aes_ccm", 79);
    uint64_t v5 = 4294967221;
  }
  long long v28 = *(_OWORD *)"@ABCDEFGHIJKLMNO";
  uint64_t v27 = 0x1716151413121110;
  long long v25 = xmmword_2373AF5A0;
  long long v26 = *(_OWORD *)"";
  long long v24 = xmmword_2373AF5B0;
  if ((a1 & 0x10) != 0) {
    unint64_t v9 = "\x01\x1F\xC6\x4F\xBF\xAC\xCD\x1F\xC6\x4F\xBF\xAC\xCDFIPSPOST_USER [%llu] %s:%d: FAILED: ccccm_one_shot encrypt "
  }
         "authentication\n";
  else {
    unint64_t v9 = "\x1F\xC6\x4F\xBF\xAC\xCDFIPSPOST_USER [%llu] %s:%d: FAILED: ccccm_one_shot encrypt authentication\n";
  }
  __int16 v17 = 0;
  int v16 = 0;
  uint64_t v10 = ccaes_ccm_encrypt_mode();
  if (ccccm_one_shot((uint64_t)v10, 16, (uint64_t)&v28, 8, (uint64_t)&v27, 16, (uint64_t)&v24, (uint64_t)v23, 16, (uint64_t)&v26, 6, (uint64_t)&v16))goto LABEL_24; {
  if (cc_cmp_safe(6, (char *)&v16, v9))
  }
  {
    uint64_t v11 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccccm_one_shot encrypt authentication\n", v11, "fipspost_post_aes_ccm", 121);
    uint64_t v5 = v5 | 0xFFFFFFB5;
  }
  if (cc_cmp_safe(16, v23, (char *)&v25))
  {
    uint64_t v12 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccccm_one_shot encrypt encryption\n", v12, "fipspost_post_aes_ccm", 125);
    uint64_t v5 = v5 | 0xFFFFFFB5;
  }
  if (ccccm_one_shot_encrypt((uint64_t)v10, 16, (uint64_t)&v28, 8, (uint64_t)&v27, 16, (uint64_t)&v24, (uint64_t)v23, 16, (uint64_t)&v26, 6, (uint64_t)&v16))
  {
LABEL_24:
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccccm_one_shot encrypt authentication\n");
    return 4294967223;
  }
  if (cc_cmp_safe(6, (char *)&v16, v9))
  {
    uint64_t v14 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccccm_one_shot encrypt authentication\n", v14, "fipspost_post_aes_ccm", 140);
    uint64_t v5 = v5 | 0xFFFFFFB5;
  }
  if (cc_cmp_safe(16, v23, (char *)&v25))
  {
    uint64_t v15 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccccm_one_shot encrypt encryption\n", v15, "fipspost_post_aes_ccm", 144);
    return v5 | 0xFFFFFFB5;
  }
  return v5;
}

uint64_t cccast_setup(uint64_t a1, uint64_t a2, unint64_t a3, unsigned __int8 *a4)
{
  return 0;
}

unint64_t ccn_write_uint_size_public_value(unint64_t a1, unint64_t *a2)
{
  return (ccn_bitlen_public_value(a1, a2) + 7) >> 3;
}

unint64_t ccn_write_uint_size(unint64_t a1, unint64_t *a2)
{
  BOOL v6 = timingsafe_enable_if_supported();
  unint64_t v4 = (ccn_bitlen_public_value(a1, a2) + 7) >> 3;
  cc_disable_dit_with_sb((unsigned int *)&v6);
  return v4;
}

uint64_t ccn_write_uint_padded_ct_internal(unint64_t a1, unint64_t *a2, unint64_t a3, char *__s)
{
  if (a3 > 0x7FFFFFFE) {
    return 4294967289;
  }
  unint64_t v6 = 8 * a1;
  if (8 * a1 > 0x7FFFFFFE) {
    return 4294967289;
  }
  uint64_t v7 = __s;
  unint64_t v8 = a3;
  unint64_t v10 = a3 - v6;
  if (a3 <= v6)
  {
    LODWORD(v10) = 0;
  }
  else
  {
    cc_clear(a3 - v6, __s);
    v7 += v10;
    unint64_t v8 = v6;
  }
  unint64_t v11 = ccn_bitlen_public_value(a1, a2);
  if (v8 < (v11 + 7) >> 3) {
    return 4294967289;
  }
  uint64_t result = v10 + v8 - ((v11 + 7) >> 3);
  if (v8 < 8)
  {
    unint64_t v12 = 0;
  }
  else
  {
    unint64_t v12 = ((v8 - 8) >> 3) + 1;
    unint64_t v13 = a2;
    unint64_t v14 = v12;
    do
    {
      unint64_t v15 = *v13++;
      *(void *)&v7[v8 - 8] = bswap64(v15);
      v8 -= 8;
      --v14;
    }
    while (v14);
  }
  if (v8)
  {
    unint64_t v16 = a2[v12];
    __int16 v17 = &v7[v8 - 1];
    do
    {
      *v17-- = v16;
      v16 >>= 8;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t ccn_write_uint_padded_ct(unint64_t a1, unint64_t *a2, unint64_t a3, char *a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = ccn_write_uint_padded_ct_internal(a1, a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

unint64_t ccn_write_uint_public_value(unint64_t a1, unint64_t *a2, unint64_t a3, uint64_t a4)
{
  unint64_t result = ccn_bitlen_public_value(a1, a2);
  unint64_t v9 = (result + 7) >> 3;
  if (v9 >= a3) {
    unint64_t v10 = a3;
  }
  else {
    unint64_t v10 = (result + 7) >> 3;
  }
  uint64_t v11 = a4 + v10;
  unint64_t v12 = v9 - v10;
  unint64_t v13 = v12 >> 3;
  unint64_t v14 = v12 & 7;
  unint64_t v15 = a2[v12 >> 3] >> (8 * (v12 & 7u));
  if (v10 >= 8)
  {
    do
    {
      unint64_t v16 = v10 - 8;
      unint64_t v17 = v14 - 8;
      do
      {
        *(unsigned char *)--uint64_t v11 = v15;
        v15 >>= 8;
      }
      while (!__CFADD__(v17++, 1));
      if (v13 + 1 < a1) {
        unint64_t v15 = a2[++v13];
      }
      unint64_t v10 = v16 + v14;
      unint64_t v14 = 0;
    }
    while (v10 > 7);
  }
  if (v10)
  {
    uint64_t v19 = (unsigned char *)(v11 - 1);
    do
    {
      *v19-- = v15;
      v15 >>= 8;
      --v10;
    }
    while (v10);
  }
  return result;
}

uint64_t ccn_write_uint(unint64_t a1, unint64_t *a2, unint64_t a3, uint64_t a4)
{
  BOOL v9 = timingsafe_enable_if_supported();
  ccn_write_uint_public_value(a1, a2, a3, a4);
  return cc_disable_dit_with_sb((unsigned int *)&v9);
}

unint64_t CCPOLYZP_PO2CYC_CTX_WORKSPACE_N(unsigned int a1)
{
  unint64_t v2 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
  if (a1 >= 0x80) {
    uint64_t v3 = 128;
  }
  else {
    uint64_t v3 = a1;
  }
  return v2 + 2 * (((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v3 + a1) + 6;
}

BOOL ccpolyzp_po2cyc_ctx_eq(uint64_t a1, _DWORD *a2)
{
  if ((_DWORD *)a1 == a2) {
    return 1;
  }
  if (*(_DWORD *)a1 == *a2)
  {
    unsigned int v2 = *(_DWORD *)(a1 + 4);
    if (v2 == a2[1])
    {
      if (v2)
      {
        BOOL v3 = 0;
        unsigned int v4 = 0;
        unsigned int v5 = v2 - 1;
        uint64_t v6 = 0x40000000u >> __clz(*(_DWORD *)a1);
        while (1)
        {
          unsigned int v7 = v2 - 1;
          uint64_t v8 = a1;
          if (v5 <= v4) {
            break;
          }
          do
          {
            uint64_t v8 = *(void *)(v8 + 112);
            --v7;
          }
          while (v7 > v4);
          uint64_t v9 = *(void *)(v8 + 16);
          if (v5 <= v4) {
            goto LABEL_13;
          }
          unsigned int v10 = v2 - 1;
          uint64_t v11 = a2;
          do
          {
            uint64_t v11 = (_DWORD *)*((void *)v11 + 14);
            --v10;
          }
          while (v10 > v4);
LABEL_14:
          if (v9 != *((void *)v11 + 2)) {
            return v3;
          }
          if (*(unsigned char *)(a1 + 8))
          {
            unsigned int v12 = v2 - 1;
            uint64_t v13 = a1;
            if (v5 <= v4)
            {
              uint64_t v14 = *(void *)(a1 + 168 + 8 * v6);
            }
            else
            {
              do
              {
                uint64_t v13 = *(void *)(v13 + 112);
                --v12;
              }
              while (v12 > v4);
              uint64_t v14 = *(void *)(v13 + 8 * v6 + 168);
              if (v5 > v4)
              {
                unsigned int v15 = v2 - 1;
                unint64_t v16 = a2;
                do
                {
                  unint64_t v16 = (_DWORD *)*((void *)v16 + 14);
                  --v15;
                }
                while (v15 > v4);
LABEL_24:
                if (v14 != *(void *)&v16[2 * v6 + 42]) {
                  return v3;
                }
                goto LABEL_25;
              }
            }
            unint64_t v16 = a2;
            goto LABEL_24;
          }
LABEL_25:
          BOOL v3 = ++v4 >= v2;
          if (v4 == v2) {
            return v3;
          }
        }
        uint64_t v9 = *(void *)(a1 + 16);
LABEL_13:
        uint64_t v11 = a2;
        goto LABEL_14;
      }
      return 1;
    }
  }
  return 0;
}

unint64_t CCPOLYZP_PO2CYC_CTX_INIT_WORKSPACE_N(uint64_t a1)
{
  uint64_t v2 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v3 = sizeof_struct_ccpolyzp_po2cyc();
  if (5 * a1 + 3 <= (unint64_t)(10 * a1)) {
    unint64_t v4 = 10 * a1;
  }
  else {
    unint64_t v4 = 5 * a1 + 3;
  }
  if (v4 <= (v2 + v3 - 1) / v3 + 19 * a1 + 2) {
    return (v2 + v3 - 1) / v3 + 19 * a1 + 2;
  }
  else {
    return v4;
  }
}

uint64_t ccpolyzp_po2cyc_ctx_init_ws(uint64_t a1, unsigned int *a2, unsigned int *a3, uint64_t *a4, uint64_t a5)
{
  v100[1] = *MEMORY[0x263EF8C08];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8((int8x8_t)*a3);
  v5.i16[0] = vaddlv_u8(v5);
  if (*a3 > 0x100000 || v5.i32[0] != 1) {
    return 4294967289;
  }
  unsigned int v7 = a3[1];
  if (v7 - 1 > 9 || !a5 && v7 != 1) {
    return 4294967289;
  }
  uint64_t v11 = *(void *)a3;
  *(void *)a2 = *(void *)a3;
  *((void *)a2 + 14) = a5;
  unsigned int v12 = a3[1];
  if (v12)
  {
    uint64_t v13 = 0;
    while (1)
    {
      uint64_t v14 = a4[v13];
      if (v14 < 0) {
        return 4294967289;
      }
      uint64_t v15 = v13;
      unint64_t v16 = a4;
      if (v13) {
        break;
      }
LABEL_15:
      if (++v13 == v12) {
        goto LABEL_16;
      }
    }
    while (1)
    {
      uint64_t v17 = *v16++;
      if (v14 == v17) {
        return 4294967289;
      }
      if (!--v15) {
        goto LABEL_15;
      }
    }
  }
LABEL_16:
  uint64_t v18 = v12 - 1;
  LODWORD(v11) = HIDWORD(v11) - 1;
  uint64_t v19 = a2;
  if (HIDWORD(v11) - 1 > v18)
  {
    uint64_t v19 = a2;
    do
    {
      uint64_t v19 = (unsigned int *)*((void *)v19 + 14);
      LODWORD(v11) = v11 - 1;
    }
    while (v11 > v18);
  }
  uint64_t result = ccpolyzp_po2cyc_modulus_to_cczp_ws(a1, (void *)v19 + 15, a4[v18]);
  if (!result)
  {
    BOOL v89 = (uint64_t *)(a2 + 4);
    uint64_t result = ccrns_modulus_init_ws(a1, (unint64_t *)a2 + 2, a4[v18]);
    if (!result)
    {
      unsigned int v21 = a2[1];
      *((unsigned char *)a2 + 8) = 1;
      if (v21)
      {
        unsigned int v22 = 0;
        uint64_t v23 = *a2;
        BOOL v25 = (v23 & (v23 - 1)) != 0 || v23 == 0 || v23 >= 0x100001;
        int v26 = !v25;
        char v27 = 1;
        do
        {
          long long v28 = a2;
          if (v21 - 1 > v22)
          {
            unsigned int v29 = v21 - 1;
            long long v28 = a2;
            do
            {
              long long v28 = (unsigned int *)*((void *)v28 + 14);
              --v29;
            }
            while (v29 > v22);
          }
          if (v26) {
            BOOL v30 = *((void *)v28 + 2) % (2 * (unint64_t)*a2) == 1;
          }
          else {
            BOOL v30 = 0;
          }
          if (v27) {
            char v27 = v30;
          }
          else {
            char v27 = 0;
          }
          ++v22;
        }
        while (v22 != v21);
        *((unsigned char *)a2 + 8) = v27;
        if ((v27 & 1) == 0) {
          return 0;
        }
      }
      else
      {
        uint64_t v23 = *a2;
      }
      uint64_t v31 = v23 >= 0x80 ? 128 : v23;
      uint64_t v32 = sizeof_struct_ccrns_mul_modulus();
      unint64_t v34 = (2 * v23);
      uint64_t result = 4294967289;
      if (v34 < 0x100001)
      {
        v33.i32[0] = 2 * v23;
        uint8x8_t v35 = (uint8x8_t)vcnt_s8(v33);
        v35.i16[0] = vaddlv_u8(v35);
        if (v35.i32[0] == 1)
        {
          uint64_t v36 = (uint64_t)(a2 + 30);
          uint64_t v37 = a2 + 42;
          uint64_t v38 = &a2[2 * v23 + 42 + 2 * ((unint64_t)(v32 + 7) >> 3) * v31];
          uint64_t v87 = (uint64_t)&a2[2 * v23 + 42];
          int8x16_t v88 = &v38[2 * v23];
          uint64_t v39 = (unsigned __int8 *)cczp_prime((uint64_t)(a2 + 30));
          *(void *)&long long v94 = 0;
          ccn_read_uint_public_value(1uLL, &v94, 8uLL, v39);
          uint64_t v40 = 0;
          uint64_t v41 = bswap64(v94);
          while (*(void *)((char *)&predefined_min_primitive_roots + v40 + 8) != v34
               || *(void *)((char *)&predefined_min_primitive_roots + v40) != v41)
          {
            v40 += 24;
            if (v40 == 600)
            {
              if ((v41 - 1) % v34) {
                return 4294967289;
              }
              ccn_seti(1, &__dst, 1);
              unsigned int v90 = -1;
              uint64_t v42 = (unsigned __int8 *)cczp_prime((uint64_t)(a2 + 30));
              *(void *)&long long v94 = 0;
              ccn_read_uint_public_value(1uLL, &v94, 8uLL, v42);
              unint64_t v43 = bswap64(v94) - 1;
              if (v43 % v34) {
                return 4294967289;
              }
              unint64_t v99 = v43 / v34;
              uint64_t v44 = ccrng(&v90);
              uint64_t result = v90;
              if (!v90)
              {
                uint64_t v45 = v23 & 0x7FFFFFFF;
                int v46 = 665;
                while (1)
                {
                  uint64_t result = cczp_generate_random_element_ws(a1, (void *)a2 + 15, (uint64_t (**)(void, unint64_t, uint64_t))v44, &__src);
                  unsigned int v90 = result;
                  if (result) {
                    return result;
                  }
                  cczp_power_ws(a1, (uint64_t)(a2 + 30), &__src, &__src, 64, &v99);
                  if (ccn_n(1uLL, (uint64_t)&__src))
                  {
                    uint64_t v91 = v45;
                    uint64_t v47 = (unsigned __int8 *)cczp_prime((uint64_t)(a2 + 30));
                    *(void *)&long long v94 = 0;
                    ccn_read_uint_public_value(1uLL, &v94, 8uLL, v47);
                    v100[0] = bswap64(v94) - 1;
                    cczp_power_ws(a1, (uint64_t)(a2 + 30), &v94, &__src, 64, &v91);
                    if (!ccn_cmp_internal(1, &v94, v100)) {
                      break;
                    }
                  }
                  if (!--v46)
                  {
                    uint64_t result = v90;
                    if (v90) {
                      return result;
                    }
                    goto LABEL_66;
                  }
                }
                ccn_set(1, &__dst, &__src);
LABEL_66:
                unint64_t v49 = __dst;
                long long v95 = 0u;
                long long v96 = 0u;
                long long v94 = 0u;
                uint64_t result = ccrns_modulus_init_var_time_ws(a1, (unint64_t *)&v94, v41);
                if (result) {
                  return result;
                }
                unint64_t v50 = (v49 * (unsigned __int128)v49) >> 64;
                BOOL v51 = __CFADD__((v49 * v49 * (unsigned __int128)(unint64_t)v95) >> 64, v50 * v95);
                uint64_t v52 = v49 * v49
                    - (v51
                     + __CFADD__(v49 * v49 * *((void *)&v95 + 1), (v49 * (unsigned __int128)v49 * (unint64_t)v95) >> 64)+ ((v50 * (unsigned __int128)(unint64_t)v95) >> 64)+ *((void *)&v95 + 1) * v50+ ((v49 * v49 * (unsigned __int128)*((unint64_t *)&v95 + 1)) >> 64))* v94;
                unint64_t v53 = v52 - (uint64_t)v94 >= 0
                    ? v52 - (uint64_t)v94
                    : v49 * v49
                    - (v51
                     + __CFADD__(v49 * v49 * *((void *)&v95 + 1), (v49 * (unsigned __int128)v49 * (unint64_t)v95) >> 64)+ ((v50 * (unsigned __int128)(unint64_t)v95) >> 64)+ *((void *)&v95 + 1) * v50+ ((v49 * v49 * (unsigned __int128)*((unint64_t *)&v95 + 1)) >> 64))* v94;
                uint64_t v91 = 0;
                uint64_t v92 = 0;
                unint64_t v93 = 0;
                uint64_t result = ccrns_mul_modulus_init_ws(a1, &v91, v41, v53);
                if (result) {
                  return result;
                }
                if (v45 <= 1) {
                  int v54 = 1;
                }
                else {
                  int v54 = v45;
                }
                unint64_t v48 = v49;
                do
                {
                  if (v49 < v48) {
                    unint64_t v48 = v49;
                  }
                  uint64_t v55 = v49 * v92 - v91 * ((v49 * (unsigned __int128)v93) >> 64);
                  if (v55 - v91 >= 0) {
                    unint64_t v49 = v55 - v91;
                  }
                  else {
                    unint64_t v49 = v49 * v92 - v91 * ((v49 * (unsigned __int128)v93) >> 64);
                  }
                  --v54;
                }
                while (v54);
                goto LABEL_84;
              }
              return result;
            }
          }
          unint64_t v48 = *(void *)((char *)&predefined_min_primitive_roots + v40 + 16);
LABEL_84:
          v100[0] = v48;
          long long v94 = 0uLL;
          *(void *)&long long v95 = 0;
          uint64_t result = ccrns_mul_modulus_init_var_time_ws(a1, (uint64_t *)&v94, *v89, v48);
          if (!result)
          {
            uint64_t result = cczp_inv_field_ws(a1, (uint64_t)(a2 + 30), &v99, v100);
            if (!result)
            {
              uint64_t v92 = 0;
              unint64_t v93 = 0;
              uint64_t v91 = 0;
              uint64_t result = ccrns_mul_modulus_init_var_time_ws(a1, &v91, *v89, v99);
              if (!result)
              {
                *((void *)a2 + 21) = 1;
                unsigned int v56 = *a2;
                if (*a2 <= 1)
                {
                  *(void *)uint64_t v38 = 1;
                }
                else
                {
                  unsigned int v57 = 0;
                  unsigned int v58 = __clz(v56) + 1;
                  unsigned int v59 = 1;
                  do
                  {
                    unsigned int v60 = __rbit32(v59) >> v58;
                    unint64_t v61 = *((void *)&v94 + 1) * *(void *)&v37[2 * v57]
                        - v94 * (((unint64_t)v95 * (unsigned __int128)*(unint64_t *)&v37[2 * v57]) >> 64);
                    if ((uint64_t)(v61 - v94) >= 0) {
                      unint64_t v62 = v61 - v94;
                    }
                    else {
                      unint64_t v62 = v61;
                    }
                    *(void *)&v37[2 * v60] = v62;
                    if (v56 >= 0x80) {
                      unsigned int v63 = 128;
                    }
                    else {
                      unsigned int v63 = v56;
                    }
                    if (v60 < v63)
                    {
                      uint64_t result = ccrns_mul_modulus_init_var_time_ws(a1, (uint64_t *)(v87 + 24 * v60), *v89, v62);
                      if (result) {
                        return result;
                      }
                      unsigned int v56 = *a2;
                    }
                    ++v59;
                    unsigned int v57 = v60;
                  }
                  while (v59 < v56);
                  *(void *)uint64_t v38 = 1;
                  if (v56 >= 2)
                  {
                    unsigned int v64 = 0;
LABEL_101:
                    if (v56 >= 2)
                    {
                      if (v56 >> 1 <= 1) {
                        int v65 = 1;
                      }
                      else {
                        int v65 = v56 >> 1;
                      }
                      unsigned int v66 = v56 >> 1;
                      while (1)
                      {
                        unint64_t v67 = *(void *)&v38[2 * v64];
                        unsigned int v64 = __rbit32(v66) >> v58;
                        unint64_t v68 = v92 * v67 - v91 * ((v93 * (unsigned __int128)v67) >> 64);
                        if ((uint64_t)(v68 - v91) >= 0) {
                          unint64_t v69 = v68 - v91;
                        }
                        else {
                          unint64_t v69 = v68;
                        }
                        *(void *)&v38[2 * v64] = v69;
                        unsigned int v70 = *a2 - 128;
                        if (*a2 < 0x80) {
                          unsigned int v70 = 0;
                        }
                        if (v64 >= v70)
                        {
                          uint64_t result = ccrns_mul_modulus_init_var_time_ws(a1, (uint64_t *)&v88[6 * *a2 + 6 * ~v64], *v89, v69);
                          if (result) {
                            return result;
                          }
                        }
                        ++v66;
                        if (!--v65)
                        {
                          BOOL v25 = v56 >= 4;
                          v56 >>= 1;
                          if (v25) {
                            goto LABEL_101;
                          }
                          break;
                        }
                      }
                    }
                    unsigned int v56 = *a2;
                    uint64_t v36 = (uint64_t)(a2 + 30);
                  }
                }
                uint64_t v71 = *((void *)a2 + 2);
                uint64_t v72 = v56 - v71 * ((*((unint64_t *)a2 + 3) * (unsigned __int128)v56) >> 64);
                uint64_t v73 = v72 - v71;
                if (v73 >= 0) {
                  uint64_t v72 = v73;
                }
                uint64_t __src = v72;
                unint64_t __dst = v56;
                uint64_t result = cczp_inv_field_ws(a1, v36, &__dst, &__src);
                if (!result)
                {
                  unint64_t v74 = __dst;
                  uint64_t result = ccrns_mul_modulus_init_var_time_ws(a1, (uint64_t *)a2 + 11, *((void *)a2 + 2), __dst);
                  if (!result)
                  {
                    unint64_t v75 = *(void *)&v38[2 * *a2 - 2];
                    unint64_t v76 = v75 * v74;
                    unint64_t v77 = (v75 * (unsigned __int128)v74) >> 64;
                    unint64_t v78 = *((void *)a2 + 4);
                    uint64_t v79 = (v76 * (unsigned __int128)v78) >> 64;
                    uint64_t v80 = (v77 * (unsigned __int128)v78) >> 64;
                    uint64_t v81 = v77 * v78;
                    BOOL v25 = __CFADD__(v79, v81);
                    uint64_t v82 = v79 + v81;
                    uint64_t v83 = v25;
                    uint64_t v84 = *((void *)a2 + 2);
                    unint64_t v85 = v76
                        - (v83
                         + __CFADD__(v76 * *((void *)a2 + 5), v82)
                         + v80
                         + *((void *)a2 + 5) * v77
                         + ((v76 * (unsigned __int128)*((unint64_t *)a2 + 5)) >> 64))
                        * v84;
                    if ((uint64_t)(v85 - v84) >= 0) {
                      unint64_t v86 = v85 - v84;
                    }
                    else {
                      unint64_t v86 = v85;
                    }
                    return ccrns_mul_modulus_init_var_time_ws(a1, (uint64_t *)a2 + 8, v84, v86);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t ccpolyzp_po2cyc_ctx_chain_init_ws(uint64_t a1, unsigned int *a2, unsigned int *a3, uint64_t *a4)
{
  uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)*a3);
  v4.i16[0] = vaddlv_u8(v4);
  BOOL v5 = *a3 <= 0x100000 && v4.i32[0] == 1;
  if (!v5 || !a3[1]) {
    return 4294967289;
  }
  *(void *)a2 = *(void *)a3;
  if (!a3[1]) {
    return 0;
  }
  uint64_t v9 = 0;
  unsigned int v10 = a2 + 2;
  unsigned int v11 = 1;
  for (int i = -1; ; --i)
  {
    v19[0] = *a3;
    v19[1] = v11;
    uint64_t v13 = *a2;
    unint64_t v14 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
    uint64_t v15 = v13 >= 0x80 ? 128 : v13;
    unint64_t v16 = &v10[2
             * (v14 + 2 * (v13 + ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v15) + 6)
             * (i + a2[1])];
    uint64_t result = ccpolyzp_po2cyc_ctx_init_ws(a1, v16, v19, a4, v9);
    if (result) {
      break;
    }
    ++v11;
    uint64_t v9 = (uint64_t)v16;
    if (v11 > a3[1]) {
      return 0;
    }
  }
  return result;
}

uint64_t CCPOLYZP_PO2CYC_CTX_Q_PROD_WORKSPACE_N(uint64_t result)
{
  return result;
}

void *ccpolyzp_po2cyc_ctx_q_prod_ws(uint64_t a1, char *__dst, uint64_t a3)
{
  uint64_t v6 = *(unsigned int *)(a3 + 4);
  uint64_t v7 = a3;
  int v8 = v6 - 1;
  if (v6 != 1)
  {
    uint64_t v7 = a3;
    do
    {
      uint64_t v7 = *(void *)(v7 + 112);
      --v8;
    }
    while (v8);
  }
  uint64_t v9 = *(void *)(a1 + 16);
  ccn_set(1, __dst, (void *)(v7 + 144));
  ccn_zero(v6 - 1, __dst + 8);
  uint64_t result = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  LODWORD(v11) = *(_DWORD *)(a3 + 4);
  if (v11 >= 2)
  {
    unsigned int v12 = result;
    unint64_t v13 = 1;
    do
    {
      uint64_t v14 = a3;
      if (v13 < (v11 - 1))
      {
        unsigned int v15 = v11 - 2;
        uint64_t v14 = a3;
        do
          uint64_t v14 = *(void *)(v14 + 112);
        while (v13 < v15--);
      }
      ccn_muln(v13++, v12, (unint64_t *)__dst, 1uLL, (unint64_t *)(v14 + 144));
      uint64_t result = ccn_set(v13, __dst, v12);
      unint64_t v11 = *(unsigned int *)(a3 + 4);
    }
    while (v13 < v11);
  }
  *(void *)(a1 + 16) = v9;
  return result;
}

unsigned char *ccss_shamir_share_bag_init(uint64_t a1, uint64_t a2)
{
  char v2 = 0;
  char v9 = 0;
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    if ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) & 0x1000000) != 0)
    {
      char v2 = 0;
    }
    else
    {
      __asm { MSR             DIT, #1 }
      char v2 = 1;
    }
  }
  char v9 = v2;
  *(void *)a1 = a2;
  *(_DWORD *)(a1 + 8) = 0;
  return cc_disable_dit(&v9);
}

void *ccdh_gp_rfc3526group14()
{
  return &_ccdh_gp_rfc3526group14;
}

uint64_t ccpbkdf2_hmac_internal(unint64_t *a1, uint64_t a2, uint64_t a3, size_t a4, char *a5, unint64_t a6, unint64_t a7, char *a8)
{
  uint64_t v26 = *MEMORY[0x263EF8C08];
  if ((a7 / *a1) >> 32) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v24 = (uint64_t)&v24;
  uint64_t v15 = MEMORY[0x270FA53B0](a1, a2, a2, a3);
  uint64_t v17 = &__s[-v16 - 8];
  cchmac_init_internal(v15, &__s[-v16 - 8], v18, v19);
  __memcpy_chk();
  size_t v20 = *a1;
  unint64_t v21 = a7 / *a1;
  size_t v22 = a7 % *a1;
  if (*a1 <= a7)
  {
    unint64_t v23 = 1;
    do
    {
      F(a1, v17, __s, a4, a5, a6, v23++, v20, a8);
      a8 += v20;
    }
    while (v23 <= v21);
  }
  else
  {
    LODWORD(v23) = 1;
  }
  if (v22) {
    F(a1, v17, __s, a4, a5, a6, v23, v22, a8);
  }
  cc_clear(((a1[1] + a1[2] + 19) & 0xFFFFFFFFFFFFFFF8) + a1[1], v17);
  cc_clear((a1[1] + 7) & 0xFFFFFFFFFFFFFFF8, __s);
  return 0;
}

uint64_t F(unint64_t *a1, void *a2, void *__src, size_t a4, char *a5, unint64_t a6, unsigned int a7, size_t a8, char *a9)
{
  size_t v15 = a1[1];
  uint64_t v16 = (char *)(a2 + 1);
  uint64_t v17 = (char *)a2 + v15 + 8;
  memcpy(a2 + 1, __src, v15);
  unint64_t v19 = a1[1];
  unint64_t v18 = a1[2];
  *a2 = 8 * v18;
  *(_DWORD *)((char *)a2 + v19 + v18 + 8) = 0;
  ccdigest_update_internal(a1, a2, a4, a5);
  unsigned int v26 = bswap32(a7);
  ccdigest_update_internal(a1, a2, 4uLL, (char *)&v26);
  cchmac_final_internal((uint64_t)a1, a2, (uint64_t)v17);
  uint64_t result = (uint64_t)memcpy(a9, v17, a8);
  if (a6 >= 2)
  {
    unint64_t v21 = 2;
    do
    {
      memcpy(v16, __src, a1[1]);
      unint64_t v22 = a1[2];
      *a2 = 8 * v22;
      *(_DWORD *)&v16[a1[1] + v22] = *a1;
      uint64_t result = cchmac_final_internal((uint64_t)a1, a2, (uint64_t)v17);
      if (a8)
      {
        size_t v23 = a8;
        do
        {
          a9[v23 - 1] ^= *((unsigned char *)a2 + v15 + v23 + 7);
          --v23;
        }
        while (v23);
      }
      ++v21;
    }
    while (v21 <= a6);
  }
  return result;
}

uint64_t ccpbkdf2_hmac(unint64_t *a1, uint64_t a2, uint64_t a3, size_t a4, char *a5, unint64_t a6, unint64_t a7, char *a8)
{
  BOOL v18 = timingsafe_enable_if_supported();
  uint64_t v16 = ccpbkdf2_hmac_internal(a1, a2, a3, a4, a5, a6, a7, a8);
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return v16;
}

uint64_t ccdh_import_full(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unsigned __int8 *a5, void *a6)
{
  BOOL v20 = timingsafe_enable_if_supported();
  unsigned int v12 = (void *)ccdh_ctx_public(a6);
  ccdh_ctx_init(a1, v12);
  uint64_t v13 = (uint64_t)&a6[ccdh_gp_n(*a6) + 2];
  uint64_t v14 = ccdh_gp_n(a1);
  if (ccn_read_uint_internal(v14, v13, a2, a3))
  {
    uint64_t v15 = 4294967244;
  }
  else
  {
    uint64_t v16 = ccdh_gp_n(a1);
    uint64_t v17 = cczp_prime(a1);
    if ((ccn_cmp_internal(v16, v13, v17) & 0x80000000) != 0)
    {
      BOOL v18 = (void *)ccdh_ctx_public(a6);
      uint64_t v15 = ccdh_import_pub(a1, a4, a5, v18);
    }
    else
    {
      uint64_t v15 = 4294967247;
    }
  }
  cc_disable_dit_with_sb((unsigned int *)&v20);
  return v15;
}

uint64_t ccder_sizeof_integer(unint64_t a1, unint64_t *a2)
{
  return ccder_sizeof_implicit_integer(2, a1, a2);
}

uint64_t ccec_rfc6637_kdf(uint64_t a1, char *a2, uint64_t a3, size_t a4, char *a5, size_t a6, char *a7, uint64_t a8)
{
  v20[1] = *MEMORY[0x263EF8C08];
  uint64_t v16 = MEMORY[0x270FA53B0](a1, a2, a3, a4);
  BOOL v18 = (void *)((char *)v20 - v17);
  ccdigest_init_internal(v16, (void *)((char *)v20 - v17));
  ccdigest_update_internal((unint64_t *)a1, v18, 4uLL, byte_2373AF81F);
  ccdigest_update_internal((unint64_t *)a1, v18, a4, a5);
  ccdigest_update_internal((unint64_t *)a1, v18, 1uLL, *(char **)a2);
  ccdigest_update_internal((unint64_t *)a1, v18, **(unsigned __int8 **)a2, (char *)(*(void *)a2 + 1));
  ccdigest_update_internal((unint64_t *)a1, v18, 1uLL, a2 + 8);
  ccdigest_update_internal((unint64_t *)a1, v18, 2uLL, "\x03\x01");
  ccdigest_update_internal((unint64_t *)a1, v18, 1uLL, (char *)(a3 + 8));
  ccdigest_update_internal((unint64_t *)a1, v18, 1uLL, (char *)(a3 + 24));
  ccdigest_update_internal((unint64_t *)a1, v18, 0x14uLL, "Anonymous Sender    ");
  ccdigest_update_internal((unint64_t *)a1, v18, a6, a7);
  (*(void (**)(uint64_t, void *, uint64_t))(a1 + 56))(a1, v18, a8);
  return cc_clear(*(void *)(a1 + 8) + *(void *)(a1 + 16) + 12, v18);
}

uint64_t ccn_gcd_ws(uint64_t a1, unint64_t a2, uint64_t *a3, uint64_t a4, void *a5, uint64_t a6, void *a7)
{
  uint64_t v13 = a6 + a4;
  uint64_t v47 = *(void *)(a1 + 16);
  uint64_t v14 = (uint64_t *)(*(uint64_t (**)(void))(a1 + 24))();
  uint64_t v15 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, a2);
  unint64_t v49 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, a2);
  if (a4) {
    ccn_set(a4, v14, a5);
  }
  uint64_t v16 = v13 << 6;
  ccn_zero(a2 - a4, &v14[a4]);
  if (a6) {
    ccn_set(a6, v15, a7);
  }
  ccn_zero(a2 - a6, &v15[a6]);
  if ((v16 | 0x1E) == 0x1E)
  {
    uint64_t v17 = 0;
  }
  else
  {
    uint64_t v18 = 0;
    uint64_t v17 = 0;
    unint64_t v48 = a2 - 1;
    do
    {
      uint64_t v19 = v14[v48];
      uint64_t v20 = v15[v48];
      if (a2 >= 2)
      {
        unint64_t v21 = a2 - 2;
        do
        {
          char v22 = __clz(v20 | v19 | 1);
          char v23 = (((v20 | v19) >> 63) - v22 + 64) & -(uint64_t)(((v20 | v19 | ((v20 | (unint64_t)v19) >> 32))
                                                             + 0xFFFFFFFF) >> 32);
          uint64_t v19 = ((unint64_t)v14[v21] >> v23) | (v19 << v22);
          uint64_t v20 = ((unint64_t)v15[v21--] >> v23) | (v20 << v22);
        }
        while (v21 < a2);
      }
      unint64_t v24 = 0;
      unint64_t v25 = 0;
      unint64_t v26 = v19 & 0xFFFFFFFF80000000 | *v14 & 0x7FFFFFFF;
      unint64_t v27 = v20 & 0xFFFFFFFF80000000 | *v15 & 0x7FFFFFFF;
      uint64_t v28 = 31;
      unint64_t v29 = 0x80000000;
      unint64_t v30 = 0x80000000;
      do
      {
        unint64_t v31 = v27 & v26;
        unint64_t v32 = ((v27 - v26) ^ v27 | v27 ^ v26) ^ v27;
        uint64_t v33 = (v32 & 0x8000000000000000) == 0;
        uint64_t v34 = -(uint64_t)(v27 & v26 & (v32 >> 63));
        unint64_t v35 = v26 - (v27 & v34);
        unint64_t v36 = v30 - (v25 & v34);
        unint64_t v37 = v24 - (v29 & v34);
        uint64_t v38 = -(uint64_t)(v33 & v31);
        unint64_t v39 = v27 - (v35 & v38);
        v17 += ((v39 | v35) & 1) == 0;
        char v40 = (v35 & 1) == 0;
        LOBYTE(v33) = (v39 & 1) == 0;
        unint64_t v26 = v35 >> v40;
        unint64_t v30 = (v36 >> v40) | v36 & 0x8000000000000000;
        unint64_t v24 = (v37 >> v40) | v37 & 0x8000000000000000;
        unint64_t v27 = v39 >> v33;
        unint64_t v25 = ((v25 - (v36 & v38)) >> v33) | (v25 - (v36 & v38)) & 0x8000000000000000;
        unint64_t v29 = ((v29 - (v37 & v38)) >> v33) | (v29 - (v37 & v38)) & 0x8000000000000000;
        --v28;
      }
      while (v28);
      ccn_gcd_update_ws(a1, a2, v49, v14, v30, v15, v24);
      ccn_gcd_update_ws(a1, a2, v15, v14, v25, v15, v29);
      ccn_set(a2, v14, v49);
      ++v18;
    }
    while (v18 != (v16 | 0x1EuLL) / 0x1F);
  }
  for (int i = a3; a2; --a2)
  {
    uint64_t v43 = *v14++;
    uint64_t v42 = v43;
    uint64_t v44 = *v15++;
    *i++ = v44 | v42;
  }
  *(void *)(a1 + 16) = v47;
  return v17;
}

void *ccn_gcd_update_ws(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5, void *a6, uint64_t a7)
{
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v13 = a2 + 1;
  uint64_t v14 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, a2 + 1);
  uint64_t v15 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v13);
  if (a2) {
    ccn_set(a2, v14, a4);
  }
  ccn_zero(1, &v14[8 * a2]);
  ccn_cond_neg(v13, a5 < 0, (uint64_t *)v14, (uint64_t *)v14);
  if (a2) {
    ccn_set(a2, v15, a6);
  }
  ccn_zero(1, &v15[8 * a2]);
  ccn_cond_neg(v13, a7 < 0, (uint64_t *)v15, (uint64_t *)v15);
  ccn_mul1(v13, v14, (unint64_t *)v14, (a5 ^ (a5 >> 63)) + ((unint64_t)a5 >> 63));
  ccn_addmul1(v13, (unint64_t *)v14, (unint64_t *)v15, (a7 ^ (a7 >> 63)) + ((unint64_t)a7 >> 63));
  ccn_cond_neg(v13, *(uint64_t *)&v14[8 * a2] < 0, (uint64_t *)v14, (uint64_t *)v14);
  ccn_shift_right(v13, (uint64_t)v14, (unint64_t *)v14, 0x1FuLL);
  uint64_t result = ccn_set(a2, a3, v14);
  *(void *)(a1 + 16) = v18;
  return result;
}

uint64_t ccaes_ecb_encrypt(_DWORD *a1, uint64_t a2, _DWORD *a3, int *a4)
{
  if (a2)
  {
    while (1)
    {
      unsigned int v4 = *a1 ^ *a3;
      unsigned int v5 = a1[1] ^ a3[1];
      unsigned int v6 = a1[2] ^ a3[2];
      unsigned int v7 = a1[3] ^ a3[3];
      int v8 = a1 + 6;
      for (int i = (a1[60] >> 5) - 1; ; --i)
      {
        unsigned int v10 = TE1[BYTE1(v5)] ^ TE0[v4] ^ TE2[BYTE2(v6)] ^ TE3[HIBYTE(v7)] ^ *(v8 - 2);
        unsigned int v11 = TE1[BYTE1(v6)] ^ TE0[v5] ^ TE2[BYTE2(v7)] ^ TE3[HIBYTE(v4)] ^ *(v8 - 1);
        unsigned int v12 = TE1[BYTE1(v7)] ^ TE0[v6] ^ TE2[BYTE2(v4)] ^ TE3[HIBYTE(v5)] ^ *v8;
        unsigned int v13 = TE1[BYTE1(v4)] ^ TE0[v7] ^ TE2[BYTE2(v5)] ^ TE3[HIBYTE(v6)] ^ v8[1];
        if (!i) {
          break;
        }
        unsigned int v4 = TE1[BYTE1(v11)] ^ TE0[v10] ^ TE2[BYTE2(v12)] ^ TE3[HIBYTE(v13)] ^ v8[2];
        unsigned int v5 = TE1[BYTE1(v12)] ^ TE0[v11] ^ TE2[BYTE2(v13)] ^ TE3[HIBYTE(v10)] ^ v8[3];
        int v14 = v8[4];
        int v15 = v8[5];
        v8 += 8;
        unsigned int v6 = TE1[BYTE1(v13)] ^ TE0[v12] ^ TE2[BYTE2(v10)] ^ TE3[HIBYTE(v11)] ^ v14;
        unsigned int v7 = TE1[BYTE1(v10)] ^ TE0[v13] ^ TE2[BYTE2(v11)] ^ TE3[HIBYTE(v12)] ^ v15;
      }
      uint64_t v16 = &a1[8 * ((a1[60] >> 5) - 1)];
      *a4 = Te4_2[BYTE1(v11)] ^ Te4_3[v10] ^ Te4_1[BYTE2(v12)] ^ Te4_0[HIBYTE(v13)] ^ v16[8];
      a4[1] = Te4_2[BYTE1(v12)] ^ Te4_3[v11] ^ Te4_1[BYTE2(v13)] ^ Te4_0[HIBYTE(v10)] ^ v16[9];
      a4[2] = Te4_2[BYTE1(v13)] ^ Te4_3[v12] ^ Te4_1[BYTE2(v10)] ^ Te4_0[HIBYTE(v11)] ^ v16[10];
      a4[3] = Te4_2[BYTE1(v10)] ^ Te4_3[v13] ^ Te4_1[BYTE2(v11)] ^ Te4_0[HIBYTE(v12)] ^ v16[11];
      if (!--a2) {
        break;
      }
      a3 += 4;
      a4 += 4;
    }
  }
  return 0;
}

uint64_t ccder_blob_encode_implicit_octet_string(uint64_t *a1, unint64_t a2, unint64_t a3, unint64_t *a4)
{
  unsigned int v11 = 0;
  uint64_t v12 = 0;
  unint64_t v8 = ccn_write_uint_size_public_value(a3, a4);
  uint64_t v9 = ccder_blob_reserve_tl(a1, a2, v8, &v11);
  if (v9) {
    ccn_write_int_public_value(a3, a4, v12 - (void)v11, v11);
  }
  return v9;
}

uint64_t ccmode_siv_init(uint64_t a1, void *a2, unint64_t a3)
{
  *a2 = a1;
  if (a3 > 0x40) {
    return 4294967226;
  }
  if (a3 - 32 > 0x20) {
    return 4294967226;
  }
  if (((1 << (a3 - 32)) & 0x100010001) == 0) {
    return 4294967226;
  }
  a2[1] = a3;
  if (*(void *)(*(void *)(a1 + 56) + 8) != 16) {
    return 4294967226;
  }
  __memcpy_chk();
  __memcpy_chk();

  return ccmode_siv_reset(a2);
}

void *ccaes_ofb_crypt_mode()
{
  uint64_t v0 = ccaes_ecb_encrypt_mode();
  ccmode_factory_ofb_crypt(ofb_crypt, v0);
  return ofb_crypt;
}

uint64_t *ccrng_prng(_DWORD *a1)
{
  BOOL v3 = timingsafe_enable_if_supported();
  if (ccrng_prng_init_pred != -1)
  {
    _os_once();
    if (!a1) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  if (a1) {
LABEL_3:
  }
    *a1 = 0;
LABEL_4:
  cc_disable_dit_with_sb((unsigned int *)&v3);
  return &rng_ctx;
}

uint64_t init()
{
  uint64_t result = ccrng_process_init((uint64_t)&process_rng_ctx, (uint64_t (*)(void))get_time_nsec, (uint64_t (**)(void, uint64_t, unsigned char *))&ccrng_getentropy);
  if (result) {
    cc_abort();
  }
  rng_ctx = (uint64_t)generate_0;
  return result;
}

uint64_t *ccrng(_DWORD *a1)
{
  return &rng_ctx;
}

uint64_t ccrng_trng(_DWORD *a1)
{
  BOOL v3 = timingsafe_enable_if_supported();
  if (a1) {
    *a1 = -173;
  }
  cc_disable_dit_with_sb((unsigned int *)&v3);
  return 0;
}

uint64_t ccrng_atfork_prepare()
{
  uint64_t result = ccrng_process_atfork_prepare((os_unfair_lock_s *)process_rng_ctx);
  if (result) {
    cc_abort();
  }
  return result;
}

uint64_t ccrng_atfork_parent()
{
  uint64_t result = ccrng_process_atfork_parent((os_unfair_lock_s *)process_rng_ctx);
  if (result) {
    cc_abort();
  }
  return result;
}

uint64_t ccrng_atfork_child()
{
  uint64_t result = ccrng_process_atfork_child((uint64_t)process_rng_ctx);
  if (result) {
    cc_abort();
  }
  return result;
}

__uint64_t get_time_nsec()
{
  return clock_gettime_nsec_np(_CLOCK_MONOTONIC);
}

uint64_t generate_0()
{
  uint64_t result = process_rng_ctx();
  if (result) {
    cc_abort();
  }
  return result;
}

uint64_t ccspake_mac_hkdf_derive(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8C08];
  unint64_t v8 = (rsize_t *)(**(uint64_t (***)(void))(a1 + 8))();
  uint64_t v9 = *(void *)(a1 + 32);
  int v16 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  long long v13 = KDF_LABEL_CK;
  if (**(_DWORD **)a1) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = v9 == 0;
  }
  if (v10)
  {
    uint64_t v11 = 16;
  }
  else
  {
    __memcpy_chk();
    uint64_t v11 = v9 + 16;
  }
  return cchkdf_internal(v8, a2, a3, 0, 0, v11, (uint64_t)&v13, 2 * *(void *)(*(void *)(a1 + 8) + 16), a4);
}

uint64_t ccspake_mac_compute(unsigned __int8 *a1, uint64_t a2, uint64_t a3)
{
  BOOL v13 = timingsafe_enable_if_supported();
  int v6 = a1[60];
  if (v6 == CCSPAKE_STATE_KEX_BOTH || v6 == CCSPAKE_STATE_MAC_VERIFY)
  {
    int v8 = a1[24];
    uint64_t v9 = (unint64_t *)&a1[48 * *(void *)(*(uint64_t (**)(void))(*(void *)a1 + 8))() + 336];
    BOOL v10 = (void *)(*(uint64_t (**)(void))(*(void *)a1 + 8))();
    uint64_t v11 = ccspake_mac_compute_internal((uint64_t *)a1, (uint64_t)(a1 + 272), v8, v9, (unint64_t *)&a1[56 * *v10 + 336], a2, a3);
    if (!v11) {
      a1[60] |= CCSPAKE_STATE_MAC_GENERATE;
    }
  }
  else
  {
    uint64_t v11 = 4294967210;
  }
  cc_disable_dit_with_sb((unsigned int *)&v13);
  return v11;
}

uint64_t ccspake_mac_compute_internal(uint64_t *a1, uint64_t a2, int a3, unint64_t *a4, unint64_t *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v34 = *MEMORY[0x263EF8C08];
  unint64_t v13 = *(void *)(*(uint64_t (**)(void))a1[1])();
  uint64_t v14 = (unint64_t *)(*(uint64_t (**)(void))(*a1 + 8))();
  uint64_t v15 = cczp_bitlen((uint64_t)v14);
  unint64_t v16 = *v14;
  unint64_t v17 = v13 >> 1;
  if (*(_DWORD *)*a1) {
    unint64_t v18 = v13;
  }
  else {
    unint64_t v18 = v13 >> 1;
  }
  uint64_t v19 = (*(uint64_t (**)(uint64_t *, unint64_t, uint64_t, unsigned char *))(a1[1] + 32))(a1, v18, a2, __s);
  if (!v19)
  {
    unint64_t v20 = v15 + 7;
    unint64_t v21 = (unint64_t)(v15 + 7) >> 3;
    uint64_t v28 = a7;
    int v22 = *(_DWORD *)*a1 != 0;
    int v32 = 0;
    memset(v31, 0, sizeof(v31));
    char v30 = 4;
    ccn_write_uint_padded_internal(v16, a4, v21, (char *)v31);
    ccn_write_uint_padded_internal(v16, a5, v21, (char *)v31 + (v20 >> 3));
    if (*(_DWORD *)*a1) {
      unint64_t v23 = *(void *)(a1[1] + 16);
    }
    else {
      unint64_t v23 = v17;
    }
    if (v22 != a3) {
      unint64_t v24 = v23;
    }
    else {
      unint64_t v24 = 0;
    }
    unint64_t v25 = &__s[v24];
    unint64_t v26 = ccspake_sizeof_point(*a1);
    uint64_t v19 = (*(uint64_t (**)(uint64_t *, unint64_t, unsigned char *, unint64_t, char *, uint64_t, uint64_t))(a1[1] + 40))(a1, v23, v25, v26, &v30, a6, v28);
    cc_clear(0x80uLL, __s);
  }
  return v19;
}

uint64_t ccspake_mac_verify_and_get_session_key(int **a1, unint64_t a2, char *a3, uint64_t a4, void *a5)
{
  uint64_t v25 = *MEMORY[0x263EF8C08];
  BOOL v23 = timingsafe_enable_if_supported();
  int v10 = *((unsigned __int8 *)a1 + 60);
  if (v10 != CCSPAKE_STATE_KEX_BOTH && v10 != CCSPAKE_STATE_MAC_GENERATE)
  {
    uint64_t v15 = 4294967210;
    goto LABEL_25;
  }
  uint64_t v12 = (rsize_t *)(*(uint64_t (**)(void))a1[1])();
  unint64_t v13 = v12;
  int v14 = **a1;
  if (v14 != 1)
  {
    if (v14)
    {
      if (a2 > 0x40)
      {
        uint64_t v15 = 4294967289;
        goto LABEL_25;
      }
    }
    else
    {
      uint64_t v15 = 4294967289;
      if (a2 > 0x40 || *v12 >> 1 != a4) {
        goto LABEL_25;
      }
    }
LABEL_16:
    rsize_t v22 = *v12;
    BOOL v16 = *((unsigned char *)a1 + 24) == 0;
    unint64_t v17 = (unint64_t *)&a1[4 * *(void *)(*((uint64_t (**)(void))*a1 + 1))() + 42];
    unint64_t v18 = (void *)(*((uint64_t (**)(void))*a1 + 1))();
    uint64_t v15 = ccspake_mac_compute_internal((uint64_t *)a1, (uint64_t)(a1 + 34), v16, v17, (unint64_t *)&a1[5 * *v18 + 42], a2, (uint64_t)__s);
    if (!v15)
    {
      if (cc_cmp_safe_internal(a2, a3, __s))
      {
        uint64_t v15 = 4294967294;
      }
      else
      {
        int v19 = **a1;
        if (v19 == 1)
        {
          uint64_t v20 = cchkdf_internal(v13, *v13, (uint64_t)(a1 + 34), 0, 0, 9, (uint64_t)"SharedKey", a4, (uint64_t)a5);
          if (v20)
          {
            uint64_t v15 = v20;
            goto LABEL_24;
          }
        }
        else if (!v19)
        {
          memcpy(a5, (char *)a1 + (v22 >> 1) + 272, v22 >> 1);
        }
        uint64_t v15 = 0;
        *((unsigned char *)a1 + 60) |= CCSPAKE_STATE_MAC_VERIFY;
      }
    }
LABEL_24:
    cc_clear(0x40uLL, __s);
    goto LABEL_25;
  }
  uint64_t v15 = 4294967289;
  if (a2 <= 0x40 && a4) {
    goto LABEL_16;
  }
LABEL_25:
  cc_disable_dit_with_sb((unsigned int *)&v23);
  return v15;
}

uint64_t ccn_muln(uint64_t a1, void *a2, unint64_t *a3, unint64_t a4, unint64_t *a5)
{
  uint64_t result = ccn_mul1(a1, a2, a3, *a5);
  a2[a1] = result;
  if (a4 >= 2)
  {
    unint64_t v11 = a4 - 1;
    uint64_t v12 = a2 + 1;
    unint64_t v13 = a5 + 1;
    do
    {
      unint64_t v14 = *v13++;
      uint64_t result = ccn_addmul1(a1, v12, a3, v14);
      v12[a1] = result;
      ++v12;
      --v11;
    }
    while (v11);
  }
  return result;
}

uint64_t ccpost_vector_list(uint64_t result, uint64_t a2)
{
  if (*(void *)(result + 16))
  {
    uint64_t v3 = result;
    unint64_t v4 = 0;
    do
      uint64_t result = ccpost_internal(*(void *)(*(void *)(v3 + 8) + 8 * v4++), a2);
    while (v4 < *(void *)(v3 + 16));
  }
  return result;
}

uint64_t cczp_modn_ws(uint64_t a1, void *a2, uint64_t *a3, uint64_t a4, char *a5)
{
  unint64_t v10 = cczp_n((uint64_t)a2);
  unint64_t v11 = v10;
  if ((a4 - 1) / v10 <= 1) {
    unint64_t v12 = 1;
  }
  else {
    unint64_t v12 = (a4 - 1) / v10;
  }
  uint64_t v17 = a4;
  uint64_t v18 = *(void *)(a1 + 16);
  unint64_t v13 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 2 * v10);
  int v19 = a5;
  ccn_set(v11, v13, a5);
  unint64_t v14 = v12 - 1;
  if (v12 != 1)
  {
    uint64_t v15 = &v19[8 * v11];
    do
    {
      ccn_set(v11, &v13[8 * v11], v15);
      cczp_mm_redc_ws(a1, a2, (uint64_t *)v13, (uint64_t *)v13);
      v15 += 8 * v11;
      --v14;
    }
    while (v14);
  }
  if (v17 != v12 * v11) {
    ccn_set(v17 - v12 * v11, &v13[8 * v11], &v19[8 * v12 * v11]);
  }
  ccn_zero(v11 - (v17 - v12 * v11), &v13[8 * v11 + 8 * (v17 - v12 * v11)]);
  cczp_mm_redc_ws(a1, a2, a3, (uint64_t *)v13);
  do
  {
    ccn_mul_ws(a1, v11, v13, (unint64_t *)a3, &a2[*a2 + 4]);
    uint64_t result = cczp_mm_redc_ws(a1, a2, a3, (uint64_t *)v13);
    --v12;
  }
  while (v12);
  *(void *)(a1 + 16) = v18;
  return result;
}

uint64_t cczp_mod_default_ws(uint64_t a1, void *a2, uint64_t *a3, char *a4)
{
  uint64_t v8 = 2 * cczp_n((uint64_t)a2);

  return cczp_modn_ws(a1, a2, a3, v8, a4);
}

uint64_t cczp_mod_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 32))();
}

uint64_t cczp_mod(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v13 = timingsafe_enable_if_supported();
  uint64_t v6 = cczp_n(a1);
  v9[0] = cc_malloc_clear(16 * v6);
  v9[1] = 2 * cczp_n(a1);
  uint64_t v10 = 0;
  unint64_t v11 = cc_ws_alloc;
  unint64_t v12 = cc_ws_free;
  if (v9[0])
  {
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 16) + 32))(v9, a1, a2, a3);
    uint64_t v10 = 0;
    v12((uint64_t)v9);
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v7 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v13);
  return v7;
}

uint64_t ccaes_gladman_cbc_encrypt_init(uint64_t a1, int *a2, uint64_t a3, int *a4)
{
  if (a3 > 127)
  {
    if (a3 != 128 && a3 != 256 && a3 != 192) {
      return 4294967289;
    }
LABEL_8:
    uint64_t result = ccaes_gladman_encrypt_key(a4, a3, a2);
    a2[65] = 1;
    return result;
  }
  if ((unint64_t)a3 <= 0x20 && ((1 << a3) & 0x101010000) != 0) {
    goto LABEL_8;
  }
  return 4294967289;
}

uint64_t ccn_invmod_ws(uint64_t a1, unint64_t a2, void *__s, unint64_t a4, _DWORD *a5, void *a6)
{
  uint64_t v8 = a2 - a4;
  if (a2 >= a4
    && ccn_n(a4, (uint64_t)a5)
    && a2
    && ((unint64_t v12 = ccn_n(a2, (uint64_t)a6), v13 = *a6, v12 > 1) || v13 > 1)
    && ((v13 | *a5) & 1) != 0)
  {
    unint64_t v15 = (a4 + a2) << 6;
    uint64_t v39 = *(void *)(a1 + 16);
    unint64_t __dst = __s;
    BOOL v16 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, a2);
    uint64_t v17 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, a2);
    if (a4) {
      ccn_set(a4, v16, a5);
    }
    ccn_zero(v8, &v16[a4]);
    ccn_set(a2, v17, a6);
    uint64_t v18 = a1;
    int v19 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, a2);
    uint64_t v20 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(v18 + 24))(v18, a2);
    __sa = (_DWORD *)(*(uint64_t (**)(uint64_t, unint64_t))(v18 + 24))(v18, a2);
    uint64_t v47 = a6;
    unint64_t v50 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(v18 + 24))(v18, a2);
    uint64_t v43 = v19;
    ccn_seti(a2, v19, 1);
    cc_clear(8 * a2, v20);
    cc_clear(8 * a2, __sa);
    ccn_seti(a2, v50, 1);
    int v46 = (unint64_t *)a5;
    unint64_t v21 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(v18 + 24))(v18, a2);
    uint64_t v41 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(v18 + 24))(v18, a2);
    if (v15)
    {
      unint64_t v49 = (uint64_t *)v20;
      BOOL v51 = v17;
      uint64_t v52 = v16;
      do
      {
        unint64_t v45 = v15;
        int v22 = *(_DWORD *)v16 & *(_DWORD *)v17 & 1;
        char v23 = ccn_subn(a2, v21, v51, a4, (unint64_t *)v16);
        char v24 = v22 & ~v23;
        ccn_mux(a2, v24, v51, v21, v51);
        ccn_sub_ws(a1, a4, v21, v52, (unint64_t *)v51);
        char v25 = v22 & v23;
        ccn_mux(a4, v25, v52, v21, v52);
        unint64_t v27 = (uint64_t *)__sa;
        unint64_t v26 = v43;
        LOBYTE(v22) = ccn_add_ws(a1, a2, v21, v43, (uint64_t *)__sa);
        LOBYTE(v22) = ccn_sub_ws(a1, a2, v41, v21, v47) & (v22 ^ 1);
        ccn_mux(a2, v22, v21, v21, v41);
        ccn_mux(a2, v25, v26, v21, v26);
        ccn_mux(a2, v24, v27, v21, v27);
        ccn_add_ws(a1, a4, v21, v49, v50);
        ccn_sub_ws(a1, a4, v41, v21, v46);
        ccn_mux(a4, v22, v21, v21, v41);
        ccn_mux(a4, v25, v49, v21, v49);
        ccn_mux(a4, v24, v50, v21, v50);
        BOOL v28 = (*(_DWORD *)v52 & 1) == 0;
        BOOL v29 = (*(_DWORD *)v51 & 1) == 0;
        uint64_t v30 = (*(_DWORD *)v49 | *(_DWORD *)v43);
        uint64_t v44 = (*(_DWORD *)v50 | *__sa);
        ccn_cond_shift_right(a4, (*(_DWORD *)v52 & 1) == 0, (uint64_t)v52, (uint64_t)v52, 1);
        uint64_t v31 = v30 & v28;
        unint64_t v32 = ccn_cond_add(a2, v31, v26, v26, (uint64_t *)v47);
        ccn_cond_shift_right_carry(a2, v28, (uint64_t)v26, (uint64_t)v26, 1, v32);
        uint64_t v33 = v31;
        uint64_t v17 = v51;
        unint64_t v34 = ccn_cond_add(a4, v33, v49, v49, (uint64_t *)v46);
        ccn_cond_shift_right_carry(a4, v28, (uint64_t)v49, (uint64_t)v49, 1, v34);
        ccn_cond_shift_right(a2, v29, (uint64_t)v17, (uint64_t)v17, 1);
        unint64_t v35 = ccn_cond_add(a2, v44 & v29, v27, v27, (uint64_t *)v47);
        unint64_t v36 = v50;
        ccn_cond_shift_right_carry(a2, v29, (uint64_t)__sa, (uint64_t)__sa, 1, v35);
        unint64_t v37 = ccn_cond_add(a4, v44 & v29, v36, v36, (uint64_t *)v46);
        char v38 = v29;
        BOOL v16 = v52;
        ccn_cond_shift_right_carry(a4, v38, (uint64_t)v36, (uint64_t)v36, 1, v37);
        unint64_t v15 = v45 - 1;
      }
      while (v45 != 1);
    }
    if (ccn_n(a2, (uint64_t)v16) == 1 && *v16 == 1)
    {
      ccn_set(a2, __dst, v43);
      uint64_t result = 0;
    }
    else
    {
      cc_clear(8 * a2, __dst);
      uint64_t result = 4294967289;
    }
    *(void *)(a1 + 16) = v39;
  }
  else
  {
    cc_clear(8 * a2, __s);
    return 4294967289;
  }
  return result;
}

unint64_t *ccn_mul_ws(uint64_t a1, unint64_t a2, char *a3, unint64_t *a4, unint64_t *a5)
{
  return ccn_mul(a2, a3, a4, a5);
}

unint64_t *ccn_mul(unint64_t a1, char *a2, unint64_t *a3, unint64_t *a4)
{
  unint64_t v7 = a1;
  uint64_t result = (unint64_t *)ccn_zero(2 * a1, a2);
  unint64_t v9 = 0;
  if (v7 != 1)
  {
    do
    {
      unint64_t v10 = a4[1];
      unint64_t v11 = &a2[8 * v9];
      unint64_t v12 = *(void *)v11;
      if (v7)
      {
        unint64_t v13 = 0;
        uint64_t v14 = 0;
        uint64_t v15 = 0;
        unint64_t v16 = 0;
        unint64_t v17 = *a4;
        unint64_t v18 = v7;
        uint64_t result = a3;
        do
        {
          int v19 = v11;
          uint64_t v20 = v13 * v10;
          uint64_t v21 = (v13 * (unsigned __int128)v10) >> 64;
          unint64_t v22 = *result++;
          unint64_t v13 = v22;
          uint64_t v23 = (v22 * (unsigned __int128)v17) >> 64;
          uint64_t v24 = v22 * v17;
          unint64_t v26 = v14 + v15 + v12;
          uint64_t v25 = (__PAIR128__(v16 + __CFADD__(v14, v15), v14 + v15) + v12) >> 64;
          unint64_t v27 = v26 + v20;
          if (__CFADD__(v26, v20)) {
            ++v25;
          }
          unint64_t v28 = v27 + v24;
          if (__CFADD__(v27, v24)) {
            uint64_t v29 = v25 + 1;
          }
          else {
            uint64_t v29 = v25;
          }
          uint64_t v15 = v29 + v23;
          unint64_t v16 = __CFADD__(v29, v23);
          unint64_t v30 = *((void *)v11 + 1);
          v11 += 8;
          unint64_t v12 = v30;
          *(void *)int v19 = v28;
          uint64_t v14 = v21;
          --v18;
        }
        while (v18);
        BOOL v31 = __CFADD__(v21, v15);
        unint64_t v32 = v21 + v15;
        if (v31) {
          ++v16;
        }
      }
      else
      {
        unint64_t v13 = 0;
        unint64_t v32 = 0;
        unint64_t v16 = 0;
      }
      a4 += 2;
      *(_OWORD *)unint64_t v11 = __PAIR128__(v16, v32) + v12 + v10 * (unsigned __int128)v13;
      v9 += 2;
    }
    while (v9 < v7 - 1);
  }
  if (v9 < v7)
  {
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    unint64_t v35 = *a4;
    unint64_t v36 = &a2[8 * v9];
    do
    {
      unint64_t v37 = *a3++;
      unint64_t v38 = (v37 * (unsigned __int128)v35) >> 64;
      unint64_t v39 = v37 * v35;
      BOOL v31 = __CFADD__(v33, *(void *)v36);
      unint64_t v40 = v33 + *(void *)v36;
      if (v31) {
        uint64_t v34 = 1;
      }
      unint64_t v41 = v40 + v39;
      uint64_t v33 = (__PAIR128__(v34, v40) + __PAIR128__(v38, v39)) >> 64;
      *(void *)unint64_t v36 = v41;
      v36 += 8;
      uint64_t v34 = 0;
      --v7;
    }
    while (v7);
    *(void *)unint64_t v36 = v33;
  }
  return result;
}

uint64_t ccmode_siv_encrypt(uint64_t a1, unint64_t a2, char *a3, char *a4)
{
  uint64_t v12 = *MEMORY[0x263EF8C08];
  if (*(void *)(*(void *)(*(void *)a1 + 56) + 8) != 16) {
    return 4294967226;
  }
  uint64_t v8 = *(void *)(*(void *)a1 + 64);
  if (a3 - 16 < a4 && &a3[a2] > a4) {
    return 4294967191;
  }
  uint64_t v9 = ccmode_siv_auth_finalize(a1, a2, a3, &v11);
  if (!v9)
  {
    if (*(void *)(a1 + 16) == 5)
    {
      *(_OWORD *)(a1 + 88) = v11;
      *(unsigned char *)(a1 + 96) &= ~0x80u;
      *(unsigned char *)(a1 + 100) &= ~0x80u;
      uint64_t v9 = ccctr_one_shot_internal(v8, *(void *)(a1 + 8) >> 1, a1 + 56, a1 + 88, a2, (uint64_t)a3, (uint64_t)(a4 + 16));
      *(_OWORD *)a4 = v11;
      if (v9) {
        cc_clear(a2 + 16, a4);
      }
    }
    else
    {
      return 4294967228;
    }
  }
  return v9;
}

uint64_t ccn_div_exact_ws(uint64_t a1, unint64_t a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t v21 = *(void *)(a1 + 16);
  uint64_t v8 = (unint64_t *)(*(uint64_t (**)(void))(a1 + 24))();
  uint64_t v9 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, a2);
  unint64_t v18 = ccn_trailing_zeros(a2, (uint64_t)a5);
  ccn_shift_right_multi(a2, (uint64_t)v8, a5, v18);
  unint64_t v10 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, a2);
  cc_clear(8 * a2, v10);
  uint64_t v11 = (2 - ((3 * *v8) ^ 2) * *v8) * ((3 * *v8) ^ 2);
  uint64_t v12 = (2 - (2 - v11 * *v8) * v11 * *v8) * (2 - v11 * *v8) * v11;
  *unint64_t v10 = (2 - v12 * *v8) * v12;
  unint64_t v13 = __clz(a2);
  if (v13 == 63)
  {
    uint64_t v14 = 1;
  }
  else
  {
    unint64_t v15 = 63 - v13;
    uint64_t v14 = 1;
    do
    {
      ccn_mul_ws(a1, v14, v9, v8, v10);
      ccn_mul_lo(v14, (unint64_t *)v9, &v8[v14], v10);
      ccn_add_ws(a1, v14, v9, (uint64_t *)v9, (uint64_t *)&v9[8 * v14]);
      ccn_neg(v14, (uint64_t *)&v9[8 * v14], v10);
      ccn_mul_lo(v14, &v10[v14], (unint64_t *)&v9[8 * v14], (unint64_t *)v9);
      uint64_t v14 = (a2 - 1 + (1 << v15)) >> v15;
      --v15;
    }
    while (v15);
  }
  cc_clear(8 * a2, v9);
  ccn_mul_lo(v14, (unint64_t *)v9, a4, v10);
  unint64_t v16 = (uint64_t *)a3;
  ccn_mul_lo(a2, a3, v8, (unint64_t *)v9);
  ccn_sub_ws(a1, a2, v8, (uint64_t *)a4, a3);
  ccn_mul_lo(a2, a3, v10, v8);
  ccn_add_ws(a1, a2, v16, v16, (uint64_t *)v9);
  uint64_t result = ccn_shift_right_multi(a2, (uint64_t)v16, (unint64_t *)v16, v18);
  *(void *)(a1 + 16) = v21;
  return result;
}

uint64_t ccn_mul_lo(uint64_t a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t v6 = a2;
  uint64_t v7 = a1;
  for (uint64_t result = cc_clear(8 * a1, a2); v7; --v7)
  {
    unint64_t v9 = *a3++;
    uint64_t result = ccn_addmul1(v7, v6++, a4, v9);
  }
  return result;
}

uint64_t ccec_generate_blinding_keys(unint64_t *a1, uint64_t (**a2)(void, uint64_t, unint64_t *), unint64_t **a3, unint64_t **a4)
{
  BOOL v25 = timingsafe_enable_if_supported();
  unint64_t v8 = *a1;
  uint64_t v9 = sizeof_struct_cche_galois_key();
  unint64_t v10 = sizeof_struct_ccpolyzp_po2cyc();
  v21[0] = cc_malloc_clear((v8 << 8) + 8 * ((v9 + v10 + 3 * v8 * v10 - 1) / v10));
  unint64_t v11 = *a1;
  uint64_t v12 = sizeof_struct_cche_galois_key();
  unint64_t v13 = sizeof_struct_ccpolyzp_po2cyc();
  v21[1] = (v12 + v13 + v13 * 3 * v11 - 1) / v13 + 32 * v11;
  uint64_t v22 = 0;
  uint64_t v23 = cc_ws_alloc;
  uint64_t v24 = cc_ws_free;
  if (!v21[0])
  {
    uint64_t v18 = 4294967283;
    goto LABEL_15;
  }
  *a3 = a1;
  *a4 = a1;
  uint64_t v20 = cc_ws_alloc(v21, (24 * v11 + 23) >> 3);
  uint64_t v14 = v23(v21, 3 * v11);
  unint64_t v15 = a3 + 2;
  uint64_t scalar_fips_retry_ws = ccec_generate_scalar_fips_retry_ws((uint64_t)v21, a1, (uint64_t (**)(void, unint64_t, void *))a2, &a3[3 * **a3 + 2]);
  if (scalar_fips_retry_ws) {
    goto LABEL_16;
  }
  unint64_t v17 = a4 + 2;
  uint64_t scalar_fips_retry_ws = cczp_inv_ws((uint64_t)v21, (uint64_t)&a1[5 * *a1 + 4]);
  if (scalar_fips_retry_ws
    || (uint64_t scalar_fips_retry_ws = ccec_projectify_ws((uint64_t)v21, (uint64_t)a1), scalar_fips_retry_ws)
    || (uint64_t scalar_fips_retry_ws = ccec_mult_blinded_ws((uint64_t)v21, a1, (uint64_t)(a3 + 2), (uint64_t)&v15[3 * **a3], v14, a2), scalar_fips_retry_ws)|| (uint64_t scalar_fips_retry_ws = ccec_mult_blinded_ws((uint64_t)v21, a1, (uint64_t)(a4 + 2), (uint64_t)&v17[3 * **a4], v14, a2), scalar_fips_retry_ws)|| (uint64_t scalar_fips_retry_ws = ccec_affinify_ws((uint64_t)v21, (uint64_t)a1), scalar_fips_retry_ws)|| (uint64_t scalar_fips_retry_ws = ccec_affinify_ws((uint64_t)v21, (uint64_t)a1), scalar_fips_retry_ws)|| (uint64_t scalar_fips_retry_ws = ccec_blinding_op_ws((uint64_t)v21, a2, (uint64_t)&v15[3 * **a3], (uint64_t **)a4), scalar_fips_retry_ws))
  {
LABEL_16:
    uint64_t v18 = scalar_fips_retry_ws;
LABEL_12:
    cc_clear((32 * *a1) | 0x10, a3);
    cc_clear((32 * *a1) | 0x10, a4);
    goto LABEL_13;
  }
  if (ccn_cmp_internal(v11, v20 + 16, &a1[2 * *a1 + 4 + *a1]))
  {
    uint64_t v18 = 0;
    goto LABEL_13;
  }
  uint64_t v18 = ccec_blinding_op_ws((uint64_t)v21, a2, (uint64_t)&v17[3 * **a4], (uint64_t **)a3);
  if (v18) {
    goto LABEL_12;
  }
LABEL_13:
  uint64_t v22 = 0;
  v24((uint64_t)v21);
LABEL_15:
  cc_disable_dit_with_sb((unsigned int *)&v25);
  return v18;
}

uint64_t ccec_blind(uint64_t (**a1)(void, uint64_t, unint64_t *), void **a2, uint64_t **a3)
{
  BOOL v11 = timingsafe_enable_if_supported();
  uint64_t v6 = *a3;
  v9[0] = cc_malloc_clear(232 * **a3);
  v9[1] = 29 * *v6;
  void v9[2] = 0;
  v9[3] = cc_ws_alloc;
  unint64_t v10 = cc_ws_free;
  if (v9[0])
  {
    uint64_t v7 = ccec_blinding_op_ws((uint64_t)v9, a1, (uint64_t)&a2[3 * **a2 + 2], a3);
    v10((uint64_t)v9);
  }
  else
  {
    uint64_t v7 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v11);
  return v7;
}

uint64_t ccec_blinding_op_ws(uint64_t a1, uint64_t (**a2)(void, uint64_t, unint64_t *), uint64_t a3, uint64_t **a4)
{
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v9 = (uint64_t)(a4 + 2);
  unint64_t v8 = *a4;
  uint64_t v10 = 3 * **a4;
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10);
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10);
  uint64_t result = ccec_validate_point_and_projectify_ws(a1, v8, v11, v9);
  if (!result)
  {
    uint64_t result = ccec_mult_blinded_ws(a1, (unint64_t *)v8, v12, a3, v11, a2);
    if (!result) {
      uint64_t result = ccec_affinify_ws(a1, (uint64_t)v8);
    }
  }
  *(void *)(a1 + 16) = v7;
  return result;
}

uint64_t ccec_unblind(uint64_t (**a1)(void, uint64_t, unint64_t *), void **a2, uint64_t **a3)
{
  BOOL v11 = timingsafe_enable_if_supported();
  uint64_t v6 = *a3;
  v9[0] = cc_malloc_clear(232 * **a3);
  v9[1] = 29 * *v6;
  void v9[2] = 0;
  v9[3] = cc_ws_alloc;
  uint64_t v10 = cc_ws_free;
  if (v9[0])
  {
    uint64_t v7 = ccec_blinding_op_ws((uint64_t)v9, a1, (uint64_t)&a2[3 * **a2 + 2], a3);
    v10((uint64_t)v9);
  }
  else
  {
    uint64_t v7 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v11);
  return v7;
}

uint64_t ccrsabssa_blind_message(uint64_t a1, unint64_t *a2, char *a3, size_t a4, char *a5, uint64_t a6, char *a7, unint64_t a8, uint64_t (**a9)(void, unint64_t, uint64_t))
{
  uint64_t v50 = *MEMORY[0x263EF8C08];
  BOOL v47 = timingsafe_enable_if_supported();
  unint64_t v16 = *a2;
  uint64_t v17 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v18 = sizeof_struct_ccpolyzp_po2cyc();
  v43[0] = cc_malloc_clear(8 * ((v17 + v18 - 1) / v18 + 16 * v16) + 8);
  unint64_t v19 = *a2;
  uint64_t v20 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v21 = sizeof_struct_ccpolyzp_po2cyc();
  v43[1] = (v20 + v21 - 1) / v21 + 16 * v19 + 1;
  uint64_t v44 = 0;
  unint64_t v45 = cc_ws_alloc;
  int v46 = cc_ws_free;
  if (v43[0])
  {
    if (ccrsa_pubkeylength(a2) == *(void *)a1)
    {
      unint64_t v40 = a5;
      uint64_t v22 = (size_t *)(*(uint64_t (**)(void))(a1 + 8))();
      uint64_t v23 = ccrsa_pubkeylength(a2);
      unint64_t v24 = (unint64_t)(v23 + 7) >> 3;
      uint64_t v25 = 4294967289;
      unint64_t v26 = cc_ws_free;
      if (v24 != a6 || v24 != a8) {
        goto LABEL_15;
      }
      uint64_t v27 = v23;
      ccdigest_internal((uint64_t)v22, a4, a3, (uint64_t)v49);
      uint64_t v28 = (*a9)(a9, *(void *)(a1 + 16), (uint64_t)v48);
      if (v28)
      {
        uint64_t v25 = v28;
        goto LABEL_14;
      }
      unint64_t v29 = v27 - 1;
      unint64_t v30 = *a2;
      uint64_t v41 = v44;
      BOOL v31 = (unint64_t *)v45(v43, *a2);
      v31[v30 - 1] = 0;
      *BOOL v31 = 0;
      unint64_t v32 = (unsigned __int8 *)&v31[v30] - ((unint64_t)(v27 + 6) >> 3);
      uint64_t non_zero_element_ws = ccrsa_emsa_pss_encode_internal((uint64_t)v22, (uint64_t)v22, *(void *)(a1 + 16), v48, *v22, v49, v29, v32);
      if (non_zero_element_ws) {
        goto LABEL_19;
      }
      if (ccrsa_emsa_pss_decode_ws((uint64_t)v43, (uint64_t)v22, (uint64_t)v22, *(void *)(a1 + 16), *v22, v49, v29, v32))
      {
        uint64_t v25 = 0xFFFFFFFFLL;
        goto LABEL_13;
      }
      ccn_swap(v30, v31);
      uint64_t v34 = (char *)v45(v43, v30);
      uint64_t non_zero_element_ws = cczp_generate_non_zero_element_ws((uint64_t)v43, (uint64_t)a2, a9, v34);
      if (non_zero_element_ws
        || (unint64_t v35 = (unint64_t *)v45(v43, v30),
            uint64_t non_zero_element_ws = cczp_inv_ws((uint64_t)v43, (uint64_t)a2),
            non_zero_element_ws)
        || (unint64_t v36 = (uint64_t *)v45(v43, v30),
            uint64_t non_zero_element_ws = ccrsa_pub_crypt_ws((uint64_t)v43, a2, v36, (unint64_t *)v34),
            non_zero_element_ws)
        || (unint64_t v37 = (unint64_t *)v45(v43, v30),
            cczp_mul_ws((uint64_t)v43, (uint64_t)a2),
            uint64_t non_zero_element_ws = ccn_write_uint_padded_ct_internal(v30, v37, a8, a7),
            (non_zero_element_ws & 0x80000000) != 0))
      {
LABEL_19:
        uint64_t v25 = non_zero_element_ws;
      }
      else
      {
        int v38 = ccn_write_uint_padded_ct_internal(v30, v35, a8, v40);
        uint64_t v25 = v38 & (v38 >> 31);
      }
LABEL_13:
      uint64_t v44 = v41;
LABEL_14:
      unint64_t v26 = v46;
LABEL_15:
      v26((uint64_t)v43);
      goto LABEL_18;
    }
    uint64_t v25 = 4294967289;
    cc_ws_free((uint64_t)v43);
  }
  else
  {
    uint64_t v25 = 4294967283;
  }
LABEL_18:
  cc_disable_dit_with_sb((unsigned int *)&v47);
  return v25;
}

uint64_t ccrsabssa_unblind_signature(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, char *a7, size_t a8, char *a9, uint64_t a10)
{
  BOOL v39 = timingsafe_enable_if_supported();
  uint64_t v17 = *a2;
  uint64_t v18 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v19 = sizeof_struct_ccpolyzp_po2cyc();
  v35[0] = cc_malloc_clear(8 * ((v18 + v19 - 1) / v19 + 16 * v17) + 8);
  uint64_t v20 = *a2;
  uint64_t v21 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v22 = sizeof_struct_ccpolyzp_po2cyc();
  v35[1] = (v21 + v22 - 1) / v22 + 16 * v20 + 1;
  uint64_t v36 = 0;
  unint64_t v37 = cc_ws_alloc;
  int v38 = cc_ws_free;
  if (v35[0])
  {
    if (ccrsa_pubkeylength(a2) == *(void *)a1)
    {
      uint64_t v33 = a7;
      unint64_t v23 = (unint64_t)(ccrsa_pubkeylength(a2) + 7) >> 3;
      uint64_t v24 = 4294967289;
      uint64_t v25 = cc_ws_free;
      if (v23 != a10 || v23 != a4 || v23 != a6) {
        goto LABEL_14;
      }
      unint64_t v26 = *a2;
      uint64_t v27 = cc_ws_alloc(v35, *a2);
      uint64_t uint_internal = ccn_read_uint_internal(v26, v27, a4, a3);
      if (!uint_internal)
      {
        uint64_t v29 = v37(v35, v26);
        uint64_t uint_internal = ccn_read_uint_internal(v26, v29, a6, a5);
        if (!uint_internal)
        {
          unint64_t v30 = (unint64_t *)v37(v35, v26);
          cczp_mul_ws((uint64_t)v35, (uint64_t)a2);
          uint64_t uint_internal = ccn_write_uint_padded_ct_internal(v26, v30, a6, a9);
          if ((uint_internal & 0x80000000) == 0)
          {
            if (ccrsa_pubkeylength(a2) != *(void *)a1 || a10 != (unint64_t)(ccrsa_pubkeylength(a2) + 7) >> 3) {
              goto LABEL_13;
            }
            BOOL v31 = (size_t *)(*(uint64_t (**)(void))(a1 + 8))();
            uint64_t uint_internal = ccrsa_verify_pss_msg_ws((uint64_t)v35, (unint64_t *)a2, v31, (uint64_t)v31, a8, v33, a10, (uint64_t)a9, *(void *)(a1 + 16), 0);
          }
        }
      }
      uint64_t v24 = uint_internal;
LABEL_13:
      uint64_t v36 = 0;
      uint64_t v25 = v38;
LABEL_14:
      v25((uint64_t)v35);
      goto LABEL_17;
    }
    uint64_t v24 = 4294967289;
    cc_ws_free((uint64_t)v35);
  }
  else
  {
    uint64_t v24 = 4294967283;
  }
LABEL_17:
  cc_disable_dit_with_sb((unsigned int *)&v39);
  return v24;
}

uint64_t ccrsabssa_sign_blinded_message(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4, char *a5, unint64_t a6, uint64_t (**a7)(void, uint64_t, uint64_t))
{
  BOOL v42 = timingsafe_enable_if_supported();
  unint64_t v13 = *a2;
  uint64_t v14 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v16 = (v14 + v15 - 1) / v15 + 11 * v13;
  unint64_t v17 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(v13);
  if (v16 + 1 > v17) {
    unint64_t v18 = v16 + 1;
  }
  else {
    unint64_t v18 = v17;
  }
  unint64_t v19 = cc_malloc_clear(32 * v13 + 8 * v18);
  v38[0] = v19;
  unint64_t v20 = *a2;
  uint64_t v21 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v22 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v23 = (v21 + v22 - 1) / v22 + 11 * v20;
  unint64_t v24 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(v20);
  if (v23 + 1 > v24) {
    unint64_t v25 = v23 + 1;
  }
  else {
    unint64_t v25 = v24;
  }
  v38[1] = v25 + 4 * v20;
  uint64_t v39 = 0;
  unint64_t v40 = cc_ws_alloc;
  uint64_t v41 = cc_ws_free;
  if (v19)
  {
    uint64_t v26 = ccrsa_ctx_public(a2);
    if (ccrsa_pubkeylength(v26) == *a1)
    {
      uint64_t v27 = ccrsa_ctx_public(a2);
      unint64_t v28 = (unint64_t)(ccrsa_pubkeylength(v27) + 7) >> 3;
      uint64_t v29 = 4294967289;
      unint64_t v30 = cc_ws_free;
      if (v28 != a6 || v28 != a4) {
        goto LABEL_16;
      }
      unint64_t v31 = *a2;
      unint64_t v32 = (uint64_t *)cc_ws_alloc(v38, *a2);
      uint64_t v33 = (void *)v40(v38, v31);
      uint64_t uint_internal = ccn_read_uint_internal(v31, v33, a4, a3);
      if (!uint_internal)
      {
        if (ccn_cmp_internal(v31, a2 + 3, v33) != 1)
        {
LABEL_15:
          uint64_t v39 = 0;
          unint64_t v30 = v41;
LABEL_16:
          v30((uint64_t)v38);
          goto LABEL_19;
        }
        uint64_t uint_internal = ccrsa_priv_crypt_blinded_ws((uint64_t)v38, a7, a2, v32, v33);
        if (!uint_internal)
        {
          int v35 = ccn_write_uint_padded_ct_internal(v31, (unint64_t *)v32, a6, a5);
          uint64_t v29 = v35 & (v35 >> 31);
          goto LABEL_15;
        }
      }
      uint64_t v29 = uint_internal;
      goto LABEL_15;
    }
    uint64_t v29 = 4294967289;
    cc_ws_free((uint64_t)v38);
  }
  else
  {
    uint64_t v29 = 4294967283;
  }
LABEL_19:
  cc_disable_dit_with_sb((unsigned int *)&v42);
  return v29;
}

uint64_t ccrsa_encrypt_oaep_ws(uint64_t a1, unint64_t *a2, size_t *a3, uint64_t (**a4)(void, size_t, char *), unint64_t *a5, char *a6, size_t a7, const void *a8, size_t a9, char *a10)
{
  unint64_t v18 = ccrsa_block_size(a2);
  uint64_t result = 4294967268;
  if (v18)
  {
    unint64_t v20 = *a2;
    if (*a2)
    {
      unint64_t v24 = a6;
      if (ccn_n(v20, (uint64_t)(a2 + 3)) > 1 || a2[3] >= 2)
      {
        if (*a5 >= v18)
        {
          uint64_t v23 = *(void *)(a1 + 16);
          uint64_t v21 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v20);
          cc_clear(8 * v20, v21);
          *a5 = v18;
          uint64_t result = ccrsa_oaep_encode_parameter_ws(a1, a3, a4, v18, v21, a7, a8, a9, a10);
          if (!result)
          {
            uint64_t result = ccrsa_pub_crypt_ws(a1, a2, (uint64_t *)v21, (unint64_t *)v21);
            if (!result)
            {
              int v22 = ccn_write_uint_padded_ct(v20, (unint64_t *)v21, v18, v24);
              uint64_t result = v22 & (v22 >> 31);
            }
          }
          *(void *)(a1 + 16) = v23;
        }
        else
        {
          return 4294967273;
        }
      }
      else
      {
        return 4294967268;
      }
    }
  }
  return result;
}

uint64_t ccrsa_encrypt_oaep(unint64_t *a1, size_t *a2, uint64_t (**a3)(void, size_t, char *), unint64_t *a4, char *a5, size_t a6, const void *a7, size_t a8, char *a9)
{
  BOOL v27 = timingsafe_enable_if_supported();
  unint64_t v15 = *a1;
  uint64_t v16 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v17 = sizeof_struct_ccpolyzp_po2cyc();
  v25[0] = cc_malloc_clear(8 * ((v16 + v17 - 1) / v17 + 12 * v15) + 8);
  unint64_t v18 = *a1;
  uint64_t v19 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v20 = sizeof_struct_ccpolyzp_po2cyc();
  v25[1] = (v19 + v20 - 1) / v20 + 12 * v18 + 1;
  v25[2] = 0;
  void v25[3] = cc_ws_alloc;
  uint64_t v26 = cc_ws_free;
  if (v25[0])
  {
    uint64_t v21 = ccrsa_encrypt_oaep_ws((uint64_t)v25, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    v26((uint64_t)v25);
  }
  else
  {
    uint64_t v21 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v27);
  return v21;
}

uint64_t ccascon_ascon128a_ref_pad(uint64_t result)
{
  unint64_t v1 = *(void *)(result + 40);
  char v2 = 56;
  if (v1 > 7) {
    char v2 = 120;
  }
  *(void *)(result + 8 * (v1 > 7)) ^= 128 << (v2 - 8 * v1);
  return result;
}

unint64_t *ccascon_ascon128a_ref_accumulate_encrypt(unint64_t *result, void *a2, unint64_t a3, unint64_t *a4)
{
  if (a3 >= 0x10)
  {
    unint64_t v5 = *result;
    unint64_t v4 = result[1];
    do
    {
      v5 ^= bswap64(*a4);
      *uint64_t result = v5;
      v4 ^= bswap64(a4[1]);
      result[1] = v4;
      if (a2)
      {
        *a2 = bswap64(v5);
        a2[1] = bswap64(result[1]);
        a2 += 2;
        unint64_t v5 = *result;
        unint64_t v4 = result[1];
      }
      uint64_t v6 = 0;
      a4 += 2;
      a3 -= 16;
      unint64_t v7 = result[3];
      unint64_t v8 = result[4];
      unint64_t v9 = result[2];
      do
      {
        unint64_t v10 = v9 ^ ROUND_CONSTANTS_0[v6 + 4];
        unint64_t v11 = v8 ^ v5;
        unint64_t v12 = v8 ^ v7;
        unint64_t v13 = v10 ^ v4;
        unint64_t v14 = v10 & ~v4 ^ v11;
        unint64_t v15 = v7 & ~v13 ^ v4;
        unint64_t v16 = v4 & ~v11 ^ v8 ^ v7;
        unint64_t v17 = v8 & ~v7;
        unint64_t v18 = v11 & ~v12;
        uint64_t v19 = v13 ^ v17;
        unint64_t v20 = v18 ^ v7;
        uint64_t v21 = v13 ^ ~v17;
        uint64_t v22 = v20 ^ v13 ^ v17;
        unint64_t v5 = __ROR8__(v14 ^ v16, 19) ^ __ROR8__(v14 ^ v16, 28) ^ v14 ^ v16;
        unint64_t v4 = __ROR8__(v15 ^ v14, 61) ^ __ROR8__(v15 ^ v14, 39) ^ v15 ^ v14;
        unint64_t v9 = v19 ^ ~(__ROR8__(v21, 1) ^ __ROR8__(v21, 6));
        unint64_t v7 = __ROR8__(v22, 10) ^ __ROR8__(v22, 17) ^ v22;
        unint64_t v8 = __ROR8__(v16, 7) ^ __ROR8__(v16, 41) ^ v16;
        ++v6;
      }
      while (v6 != 8);
      result[3] = v7;
      result[4] = v8;
      result[1] = v4;
      result[2] = v9;
      *uint64_t result = v5;
    }
    while (a3 > 0xF);
  }
  if (a3 < 8)
  {
    if (a3)
    {
      uint64_t v38 = 0;
      uint64_t v39 = 56;
      unint64_t v40 = a3;
      do
      {
        unsigned int v41 = *(unsigned __int8 *)a4;
        a4 = (unint64_t *)((char *)a4 + 1);
        v38 |= (unint64_t)v41 << v39;
        v39 -= 8;
        --v40;
      }
      while (v40);
      unint64_t v42 = *result ^ v38;
      *uint64_t result = v42;
      if (a2)
      {
        uint64x2_t v43 = (uint64x2_t)vdupq_n_s64(a3 - 1);
        uint64_t v44 = (char *)a2 + 1;
        int64x2_t v45 = (int64x2_t)xmmword_2373AF940;
        uint64_t v46 = 56;
        int64x2_t v47 = vdupq_n_s64(2uLL);
        do
        {
          int32x2_t v48 = vmovn_s64((int64x2_t)vcgeq_u64(v43, (uint64x2_t)v45));
          if (v48.i8[0]) {
            *(v44 - 1) = v42 >> v46;
          }
          if (v48.i8[4]) {
            *uint64_t v44 = v42 >> (v46 - 8);
          }
          int64x2_t v45 = vaddq_s64(v45, v47);
          v46 -= 16;
          v44 += 2;
        }
        while (16 * (((unint64_t)(a3 + 1) >> 1) & 0xF) + v46 != 56);
      }
    }
  }
  else
  {
    unint64_t v24 = *a4;
    uint64_t v23 = (unsigned __int8 *)(a4 + 1);
    unint64_t v25 = bswap64(v24) ^ *result;
    *uint64_t result = v25;
    uint64_t v26 = 0;
    if (a3 != 8)
    {
      uint64_t v27 = 56;
      unint64_t v28 = a3 - 8;
      do
      {
        unsigned int v29 = *v23++;
        v26 |= (unint64_t)v29 << v27;
        v27 -= 8;
        --v28;
      }
      while (v28);
    }
    result[1] ^= v26;
    if (a2)
    {
      *a2 = bswap64(v25);
      if (a3 != 8)
      {
        unint64_t v30 = result[1];
        unint64_t v31 = (a3 - 7) & 0xFFFFFFFFFFFFFFFELL;
        uint64x2_t v32 = (uint64x2_t)vdupq_n_s64(a3 - 9);
        int64x2_t v33 = (int64x2_t)xmmword_2373AF940;
        uint64_t v34 = (char *)a2 + 9;
        char v35 = 56;
        int64x2_t v36 = vdupq_n_s64(2uLL);
        do
        {
          int32x2_t v37 = vmovn_s64((int64x2_t)vcgeq_u64(v32, (uint64x2_t)v33));
          if (v37.i8[0]) {
            *(v34 - 1) = v30 >> v35;
          }
          if (v37.i8[4]) {
            *uint64_t v34 = v30 >> (v35 - 8);
          }
          int64x2_t v33 = vaddq_s64(v33, v36);
          v35 -= 16;
          v34 += 2;
          v31 -= 2;
        }
        while (v31);
      }
    }
  }
  result[5] = a3;
  return result;
}

int8x8_t *ccascon_ascon128a_ref_accumulate_decrypt(int8x8_t *result, void *a2, unint64_t a3, unint64_t *a4)
{
  if (a3 >= 0x10)
  {
    do
    {
      unint64_t v4 = bswap64(*a4);
      unint64_t v5 = bswap64(a4[1]);
      if (a2)
      {
        *a2 = bswap64(*(void *)result ^ v4);
        a2[1] = bswap64(*(void *)&result[1] ^ v5);
        a2 += 2;
      }
      uint64_t v6 = 0;
      a4 += 2;
      a3 -= 16;
      int8x8_t v7 = result[3];
      unint64_t v8 = (unint64_t)result[4];
      int8x8_t v9 = result[2];
      do
      {
        uint64_t v10 = *(void *)&v9 ^ ROUND_CONSTANTS_0[v6 + 4];
        unint64_t v11 = v8 ^ v4;
        unint64_t v12 = v8 ^ *(void *)&v7;
        unint64_t v13 = v10 ^ v5;
        unint64_t v14 = v10 & ~v5 ^ v11;
        unint64_t v15 = *(void *)&v7 & ~v13 ^ v5;
        unint64_t v16 = v5 & ~v11 ^ v8 ^ *(void *)&v7;
        unint64_t v17 = v8 & ~*(void *)&v7;
        unint64_t v18 = v11 & ~v12;
        unint64_t v19 = v13 ^ v17;
        unint64_t v20 = v18 ^ *(void *)&v7;
        unint64_t v21 = v13 ^ ~v17;
        unint64_t v22 = v20 ^ v13 ^ v17;
        unint64_t v4 = __ROR8__(v14 ^ v16, 19) ^ __ROR8__(v14 ^ v16, 28) ^ v14 ^ v16;
        unint64_t v5 = __ROR8__(v15 ^ v14, 61) ^ __ROR8__(v15 ^ v14, 39) ^ v15 ^ v14;
        int8x8_t v9 = (int8x8_t)(v19 ^ ~(__ROR8__(v21, 1) ^ __ROR8__(v21, 6)));
        int8x8_t v7 = (int8x8_t)(__ROR8__(v22, 10) ^ __ROR8__(v22, 17) ^ v22);
        unint64_t v8 = __ROR8__(v16, 7) ^ __ROR8__(v16, 41) ^ v16;
        ++v6;
      }
      while (v6 != 8);
      result[3] = v7;
      result[4] = (int8x8_t)v8;
      result[1] = (int8x8_t)v5;
      result[2] = v9;
      *uint64_t result = (int8x8_t)v4;
    }
    while (a3 > 0xF);
  }
  if (a3 >= 8)
  {
    unint64_t v24 = *a4;
    uint64_t v23 = (unsigned __int8 *)(a4 + 1);
    unint64_t v25 = bswap64(v24);
    uint64_t v26 = 0;
    if (a3 != 8)
    {
      uint64_t v27 = 56;
      unint64_t v28 = a3 - 8;
      do
      {
        unsigned int v29 = *v23++;
        v26 |= (unint64_t)v29 << v27;
        v27 -= 8;
        --v28;
      }
      while (v28);
    }
    if (a2)
    {
      *a2 = bswap64(*(void *)result ^ v25);
      unint64_t v30 = result + 1;
      int8x8_t v31 = result[1];
      if (a3 == 8)
      {
        *uint64_t result = (int8x8_t)v25;
LABEL_40:
        *unint64_t v30 = (int8x8_t)(*(void *)&v31 | v26);
        goto LABEL_41;
      }
      unint64_t v32 = *(void *)&v31 ^ v26;
      unint64_t v33 = (a3 - 7) & 0xFFFFFFFFFFFFFFFELL;
      uint64x2_t v34 = (uint64x2_t)vdupq_n_s64(a3 - 9);
      int64x2_t v35 = (int64x2_t)xmmword_2373AF940;
      int64x2_t v36 = (char *)a2 + 9;
      char v37 = 56;
      int64x2_t v38 = vdupq_n_s64(2uLL);
      do
      {
        int32x2_t v39 = vmovn_s64((int64x2_t)vcgeq_u64(v34, (uint64x2_t)v35));
        if (v39.i8[0]) {
          *(v36 - 1) = v32 >> v37;
        }
        if (v39.i8[4]) {
          *int64x2_t v36 = v32 >> (v37 - 8);
        }
        int64x2_t v35 = vaddq_s64(v35, v38);
        v37 -= 16;
        v36 += 2;
        v33 -= 2;
      }
      while (v33);
    }
    *uint64_t result = (int8x8_t)v25;
    unint64_t v30 = result + 1;
    int8x8_t v31 = result[1];
    if (a3 != 8)
    {
      unint64_t v40 = (a3 - 7) & 0xFFFFFFFFFFFFFFFELL;
      uint64x2_t v41 = (uint64x2_t)vdupq_n_s64(a3 - 9);
      v42.i64[1] = -1;
      *(int8x8_t *)v42.i8 = result[1];
      int64x2_t v43 = (int64x2_t)xmmword_2373AF940;
      int64x2_t v44 = vdupq_n_s64(0x38uLL);
      v45.i64[0] = 255;
      v45.i64[1] = 255;
      int64x2_t v46 = vdupq_n_s64(2uLL);
      do
      {
        int8x16_t v47 = v42;
        uint64x2_t v48 = (uint64x2_t)v43;
        int8x16_t v42 = vbicq_s8(v42, (int8x16_t)vshlq_u64(v45, (uint64x2_t)vsubq_s64(v44, vshlq_n_s64(v43, 3uLL))));
        int64x2_t v43 = vaddq_s64(v43, v46);
        v40 -= 2;
      }
      while (v40);
      int8x16_t v49 = vbslq_s8((int8x16_t)vcgtq_u64(v48, v41), v47, v42);
      int8x8_t v31 = vand_s8(*(int8x8_t *)v49.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v49, v49, 8uLL));
    }
    goto LABEL_40;
  }
  uint64_t v50 = 0;
  if (a3)
  {
    uint64_t v51 = 56;
    unint64_t v52 = a3;
    do
    {
      unsigned int v53 = *(unsigned __int8 *)a4;
      a4 = (unint64_t *)((char *)a4 + 1);
      v50 |= (unint64_t)v53 << v51;
      v51 -= 8;
      --v52;
    }
    while (v52);
    uint64_t v54 = (uint64_t)*result;
    if (a2)
    {
      unint64_t v55 = v54 ^ v50;
      uint64x2_t v56 = (uint64x2_t)vdupq_n_s64(a3 - 1);
      unsigned int v57 = (char *)a2 + 1;
      int64x2_t v58 = (int64x2_t)xmmword_2373AF940;
      uint64_t v59 = 56;
      int64x2_t v60 = vdupq_n_s64(2uLL);
      do
      {
        int32x2_t v61 = vmovn_s64((int64x2_t)vcgeq_u64(v56, (uint64x2_t)v58));
        if (v61.i8[0]) {
          *(v57 - 1) = v55 >> v59;
        }
        if (v61.i8[4]) {
          *unsigned int v57 = v55 >> (v59 - 8);
        }
        int64x2_t v58 = vaddq_s64(v58, v60);
        v59 -= 16;
        v57 += 2;
      }
      while (16 * (((unint64_t)(a3 + 1) >> 1) & 0xF) + v59 != 56);
      uint64_t v54 = (uint64_t)*result;
    }
    uint64x2_t v62 = (uint64x2_t)vdupq_n_s64(a3 - 1);
    uint64_t v63 = ((_BYTE)a3 + 1) & 0x1E;
    v64.i64[1] = -1;
    v64.i64[0] = v54;
    int64x2_t v65 = (int64x2_t)xmmword_2373AF940;
    int64x2_t v66 = vdupq_n_s64(0x38uLL);
    v67.i64[0] = 255;
    v67.i64[1] = 255;
    int64x2_t v68 = vdupq_n_s64(2uLL);
    do
    {
      int8x16_t v69 = v64;
      uint64x2_t v70 = (uint64x2_t)v65;
      int8x16_t v64 = vbicq_s8(v64, (int8x16_t)vshlq_u64(v67, (uint64x2_t)vsubq_s64(v66, vshlq_n_s64(v65, 3uLL))));
      int64x2_t v65 = vaddq_s64(v65, v68);
      v63 -= 2;
    }
    while (v63);
    int8x16_t v71 = vbslq_s8((int8x16_t)vcgtq_u64(v70, v62), v69, v64);
    int8x8_t v72 = vand_s8(*(int8x8_t *)v71.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v71, v71, 8uLL));
  }
  else
  {
    int8x8_t v72 = *result;
  }
  *uint64_t result = (int8x8_t)(*(void *)&v72 | v50);
LABEL_41:
  result[5] = (int8x8_t)a3;
  return result;
}

unint64_t *ccascon_ascon128a_ref_finalize(unint64_t *result, uint64_t a2, unint64_t *a3)
{
  uint64_t v3 = 0;
  unint64_t v4 = bswap64(*a3);
  unint64_t v5 = bswap64(a3[1]);
  unint64_t v6 = result[2] ^ v4;
  unint64_t v7 = result[3] ^ v5;
  unint64_t v8 = result[4];
  unint64_t v10 = *result;
  unint64_t v9 = result[1];
  do
  {
    unint64_t v11 = v6 ^ ROUND_CONSTANTS_0[v3];
    uint64_t v12 = v8 ^ v10;
    unint64_t v13 = v8 ^ v7;
    unint64_t v14 = v11 ^ v9;
    unint64_t v15 = v11 & ~v9 ^ v12;
    unint64_t v16 = v7 & ~v14 ^ v9;
    unint64_t v17 = v9 & ~v12 ^ v8 ^ v7;
    unint64_t v18 = v8 & ~v7;
    unint64_t v19 = v12 & ~v13 ^ v7 ^ v14 ^ v18;
    unint64_t v10 = __ROR8__(v15 ^ v17, 19) ^ __ROR8__(v15 ^ v17, 28) ^ v15 ^ v17;
    unint64_t v9 = __ROR8__(v16 ^ v15, 61) ^ __ROR8__(v16 ^ v15, 39) ^ v16 ^ v15;
    unint64_t v6 = v14 ^ v18 ^ ~(__ROR8__(v14 ^ ~v18, 1) ^ __ROR8__(v14 ^ ~v18, 6));
    unint64_t v7 = __ROR8__(v19, 10) ^ __ROR8__(v19, 17) ^ v19;
    unint64_t v8 = __ROR8__(v17, 7) ^ __ROR8__(v17, 41) ^ v17;
    ++v3;
  }
  while (v3 != 12);
  *uint64_t result = v10;
  result[1] = v9;
  unint64_t v20 = v7 ^ v4;
  result[2] = v6;
  result[3] = v20;
  result[4] = v8 ^ v5;
  *(unsigned char *)a2 = HIBYTE(v20);
  *(unsigned char *)(a2 + 1) = BYTE6(v20);
  *(unsigned char *)(a2 + 2) = BYTE5(v20);
  *(unsigned char *)(a2 + 3) = BYTE4(v20);
  *(unsigned char *)(a2 + 4) = BYTE3(v20);
  *(unsigned char *)(a2 + 5) = BYTE2(v20);
  *(unsigned char *)(a2 + 6) = BYTE1(v20);
  *(unsigned char *)(a2 + 7) = v20;
  *(void *)(a2 + 8) = bswap64(result[4]);
  return result;
}

unint64_t cczp_negate(uint64_t a1, uint64_t *a2, unint64_t *a3)
{
  uint64_t v6 = cczp_n(a1);
  BOOL v7 = ccn_n(v6, (uint64_t)a3) != 0;
  unint64_t v8 = (uint64_t *)cczp_prime(a1);

  return ccn_cond_rsub(v6, v7, a2, a3, v8);
}

unint64_t cczp_cond_negate(uint64_t a1, unsigned __int8 a2, uint64_t *a3, unint64_t *a4)
{
  uint64_t v8 = cczp_n(a1);
  uint64_t v9 = (ccn_n(v8, (uint64_t)a4) != 0) & a2;
  unint64_t v10 = (uint64_t *)cczp_prime(a1);

  return ccn_cond_rsub(v8, v9, a3, a4, v10);
}

uint64_t ccmode_ctr_crypt(void *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  unint64_t v6 = *(void *)(*a1 + 8);
  if (v6 >= 8) {
    unint64_t v7 = 8;
  }
  else {
    unint64_t v7 = *(void *)(*a1 + 8);
  }
  if (a2)
  {
    unint64_t v10 = a2;
    unint64_t v11 = a1 + 2;
    unint64_t v12 = (v6 + 7) >> 3;
    uint64_t v13 = (uint64_t)&a1[2 * v12 + 2];
    uint64_t v14 = (uint64_t)&a1[v12 + 2];
    unint64_t v15 = (char *)a1 + 15;
    do
    {
      uint64_t v16 = *(void *)(v5 + 8);
      if (v4 == v16)
      {
        (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(v5 + 24))(v13, 1, v14, v11);
        inc_uint(v14 - v7 + *(void *)(v5 + 8), v7);
        uint64_t v4 = 0;
        uint64_t v16 = *(void *)(v5 + 8);
      }
      unint64_t v17 = v16 - v4;
      if (v10 < v17) {
        unint64_t v17 = v10;
      }
      if (v17)
      {
        unint64_t v18 = v17;
        do
        {
          *(unsigned char *)(a4 - 1 + v18) = v15[v4 + v18] ^ *(unsigned char *)(a3 - 1 + v18);
          --v18;
        }
        while (v18);
      }
      a3 += v17;
      a4 += v17;
      v4 += v17;
      v10 -= v17;
    }
    while (v10);
  }
  a1[1] = v4;
  return 0;
}

void *cced448_full_add_ws(uint64_t a1, void *a2, char *a3)
{
  uint64_t v6 = cczp_n((uint64_t)a2);
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = 4 * v6;
  uint64_t v9 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 4 * v6);
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8);
  cced25519_to_ed25519_point_ws(a1, (uint64_t)a2);
  cced25519_to_ed25519_point_ws(a1, (uint64_t)a2);
  cced448_add_points_unified_ws(a1, (uint64_t)a2, v9, v10, v9, 4);
  uint64_t result = cced25519_from_ed25519_point_ws(a1, a2, a3, (char *)v9);
  *(void *)(a1 + 16) = v7;
  return result;
}

uint64_t ccwrap_wrapped_size(uint64_t a1)
{
  return a1 + 8;
}

BOOL ccder_blob_encode_oid(void *a1, const void *a2)
{
  unint64_t v4 = ccoid_size((uint64_t)a2);

  return ccder_blob_encode_body(a1, v4, a2);
}

uint64_t ccaes_unwind_with_ecb(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v10[1] = *MEMORY[0x263EF8C08];
  rsize_t v6 = (*(void *)a1 + 15) & 0xFFFFFFFFFFFFFFF0;
  MEMORY[0x270FA53B0](a1, a2, a3, a3);
  if (v7 == 32 && *(void *)(a1 + 32))
  {
    uint64_t inited = ccecb_init_internal(a1);
    if (!inited)
    {
      (*(void (**)(char *, uint64_t, uint64_t))(a1 + 32))((char *)v10 - v6, 14, a4);
      (*(void (**)(char *, uint64_t, uint64_t))(a1 + 32))((char *)v10 - v6, 13, a4 + 16);
    }
  }
  else
  {
    uint64_t inited = 4294967226;
  }
  cc_clear(v6, (char *)v10 - v6);
  return inited;
}

uint64_t ccaes_unwind(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t v6 = ccaes_unwind_with_ecb((uint64_t)&ccaes_ltc_ecb_encrypt_mode, a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return v6;
}

uint64_t ccentropy_list_init(void *a1, uint64_t a2, uint64_t a3)
{
  BOOL v7 = timingsafe_enable_if_supported();
  *a1 = &entropy_list_info;
  a1[1] = a3;
  a1[2] = a2;
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return 0;
}

uint64_t ccentropy_list_get_seed(uint64_t a1, rsize_t a2, void *a3)
{
  if (!*(void *)(a1 + 16))
  {
    uint64_t v8 = 0xFFFFFFFFLL;
LABEL_9:
    cc_clear(a2, a3);
    return v8;
  }
  uint64_t v6 = 0;
  while (1)
  {
    seed_uint64_t internal = ccentropy_get_seed_internal(*(uint64_t (****)(void))(*(void *)(a1 + 8) + 8 * v6));
    if (seed_internal != -10) {
      break;
    }
    if ((unint64_t)++v6 >= *(void *)(a1 + 16))
    {
      uint64_t v8 = 4294967286;
      goto LABEL_9;
    }
  }
  uint64_t v8 = seed_internal;
  if (seed_internal) {
    goto LABEL_9;
  }
  return v8;
}

uint64_t ccec_export_pub(uint64_t *a1, char *a2)
{
  uint64_t v3 = (unint64_t *)(a1 + 2);
  unint64_t v4 = (unint64_t *)*a1;
  unint64_t v6 = ((unint64_t)(cczp_bitlen(*a1) + 7) >> 2) | 1;
  return ccec_export_affine_point_public_value(v4, 1, v3, &v6, a2);
}

uint64_t ccec_x963_import_pub_size(uint64_t a1)
{
  if (a1 <= 64)
  {
    if (a1 == 49) {
      return 192;
    }
    if (a1 == 57) {
      return 224;
    }
  }
  else
  {
    switch(a1)
    {
      case 65:
        return 256;
      case 97:
        return 384;
      case 133:
        return 521;
    }
  }
  return 0;
}

uint64_t ccec_x963_import_pub_ws(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned __int8 *a4, uint64_t **a5)
{
  if (!a3) {
    return 4294967289;
  }
  if (a3 == 1)
  {
    int v10 = *a4;
    if (!*a4) {
      return 4294967136;
    }
  }
  else
  {
    int v10 = *a4;
  }
  unsigned int v12 = v10 - 2;
  if (v12 > 5 || ((0x37u >> v12) & 1) == 0) {
    return 4294967289;
  }
  int v13 = dword_2373AF95C[(char)v12];
  uint64_t v14 = *(void *)(a1 + 16);
  *a5 = a2;
  uint64_t result = ccec_import_affine_point_ws(a1, a2, v13, a3, a4, (uint64_t *)a5 + 2);
  if (!result)
  {
    ccn_seti(*a2, &a5[2 * **a5 + 2], 1);
    uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 3 * *a2);
    uint64_t result = ccec_validate_point_and_projectify_ws(a1, a2, v15, (uint64_t)(a5 + 2));
  }
  *(void *)(a1 + 16) = v14;
  return result;
}

uint64_t ccec_x963_import_pub(uint64_t *a1, uint64_t a2, unsigned __int8 *a3, uint64_t **a4)
{
  uint64_t v8 = cc_malloc_clear(160 * *a1);
  uint64_t v9 = 20 * *a1;
  v12[0] = v8;
  v12[1] = v9;
  uint64_t v12[2] = 0;
  v12[3] = cc_ws_alloc;
  int v13 = cc_ws_free;
  if (!v8) {
    return 4294967283;
  }
  uint64_t v10 = ccec_x963_import_pub_ws((uint64_t)v12, a1, a2, a3, a4);
  v13((uint64_t)v12);
  return v10;
}

void *ccmode_factory_cbc_decrypt(void *result, void *a2)
{
  uint64_t v2 = a2[1];
  *uint64_t result = ((v2 + 7) & 0xFFFFFFFFFFFFFFF8) + ((*a2 + 7) & 0xFFFFFFFFFFFFFFF8) + 8;
  result[1] = v2;
  result[2] = ccmode_cbc_init;
  result[3] = ccmode_cbc_decrypt;
  result[4] = a2;
  return result;
}

double ccmode_factory_siv_hmac_encrypt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)&double result = 600;
  *(_OWORD *)a1 = xmmword_2373AF980;
  *(void *)(a1 + 16) = ccmode_siv_hmac_init;
  *(void *)(a1 + 24) = ccmode_siv_hmac_nonce;
  *(void *)(a1 + 32) = ccmode_siv_hmac_auth;
  *(void *)(a1 + 40) = ccmode_siv_hmac_encrypt;
  *(void *)(a1 + 48) = ccmode_siv_hmac_reset;
  *(void *)(a1 + 56) = a2;
  *(void *)(a1 + 64) = a3;
  return result;
}

uint64_t ccec_compact_transform_key_ws(uint64_t a1, uint64_t **a2)
{
  unint64_t v4 = a2 + 2;
  uint64_t v3 = *a2;
  uint64_t v5 = **a2;
  unint64_t v6 = (unint64_t *)&a2[v5 + 2];
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v5);
  cczp_negate((uint64_t)v3, v8, v6);
  uint64_t result = ccn_cmp_internal(v5, v8, v6);
  if ((result & 0x80000000) != 0)
  {
    ccn_set(v5, v6, v8);
    uint64_t v10 = (uint64_t *)cczp_prime((uint64_t)&v3[5 * *v3 + 4]);
    uint64_t result = ccn_sub_ws(a1, v5, &v4[3 * v5], v10, (unint64_t *)&v4[3 * v5]);
  }
  *(void *)(a1 + 16) = v7;
  return result;
}

uint64_t ccec_compact_transform_key(uint64_t **a1)
{
  BOOL v7 = timingsafe_enable_if_supported();
  uint64_t v2 = *a1;
  v5[0] = cc_malloc_clear(8 * **a1);
  v5[1] = *v2;
  v5[2] = 0;
  v5[3] = cc_ws_alloc;
  unint64_t v6 = cc_ws_free;
  if (v5[0])
  {
    ccec_compact_transform_key_ws((uint64_t)v5, a1);
    v6((uint64_t)v5);
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v3 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return v3;
}

uint64_t ccec_compact_generate_key(unint64_t *a1, uint64_t (**a2)(void, uint64_t, unint64_t *), unint64_t **a3)
{
  BOOL v15 = timingsafe_enable_if_supported();
  unint64_t v6 = cc_malloc_clear(392 * *a1);
  uint64_t v7 = 49 * *a1;
  v11[0] = v6;
  v11[1] = v7;
  uint64_t v12 = 0;
  int v13 = cc_ws_alloc;
  uint64_t v14 = cc_ws_free;
  if (v6)
  {
    uint64_t key_internal_fips_ws = ccec_generate_key_internal_fips_ws((uint64_t)v11, a1, a2, a3);
    if (key_internal_fips_ws)
    {
      uint64_t v9 = key_internal_fips_ws;
    }
    else
    {
      ccec_compact_transform_key_ws((uint64_t)v11, (uint64_t **)a3);
      if (ccec_pairwise_consistency_check_ws((uint64_t)v11, a3, (uint64_t (**)(void, unint64_t, void *))a2))uint64_t v9 = 4294967278; {
      else
      }
        uint64_t v9 = 0;
    }
    uint64_t v12 = 0;
    v14((uint64_t)v11);
  }
  else
  {
    uint64_t v9 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v9;
}

uint64_t ccec_compact_generate_key_init(unint64_t *a1, uint64_t (**a2)(void, uint64_t, unint64_t *), uint64_t a3)
{
  BOOL v14 = timingsafe_enable_if_supported();
  unint64_t v6 = cc_malloc_clear(216 * *a1);
  uint64_t v7 = 27 * *a1;
  v12[0] = v6;
  v12[1] = v7;
  uint64_t v12[2] = 0;
  v12[3] = cc_ws_alloc;
  int v13 = cc_ws_free;
  if (v6)
  {
    *(unsigned char *)(a3 + 8) = 0;
    unint64_t v8 = *a1;
    *(void *)a3 = *a1;
    uint64_t v9 = a3 + 16 * v8;
    *(void *)(v9 + 16) = a1;
    uint64_t key_internal_fips_ws = ccec_generate_key_internal_fips_ws((uint64_t)v12, a1, a2, (unint64_t **)(v9 + 16));
    if (!key_internal_fips_ws) {
      *(unsigned char *)(a3 + 8) = 1;
    }
    v13((uint64_t)v12);
  }
  else
  {
    uint64_t key_internal_fips_ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return key_internal_fips_ws;
}

uint64_t ccec_compact_generate_key_step(uint64_t (**a1)(void, unint64_t, void *), uint64_t a2, void *a3)
{
  BOOL v15 = timingsafe_enable_if_supported();
  unint64_t v6 = cc_malloc_clear(360 * *(void *)a2);
  uint64_t v7 = *(void *)a2;
  uint64_t v8 = 45 * *(void *)a2;
  v13[0] = v6;
  v13[1] = v8;
  _OWORD v13[2] = 0;
  v13[3] = cc_ws_alloc;
  BOOL v14 = cc_ws_free;
  if (v6)
  {
    *a3 = 0;
    int v9 = *(unsigned __int8 *)(a2 + 8);
    if (v9 == 3)
    {
      uint64_t ws = ccec_compact_generate_key_checkverify_and_extract_ws((uint64_t)v13, a2, a3);
    }
    else
    {
      if (v9 != 2)
      {
        if (v9 == 1)
        {
          ccec_compact_transform_key_ws((uint64_t)v13, (uint64_t **)(a2 + 16 * v7 + 16));
          uint64_t v10 = 0;
          *(unsigned char *)(a2 + 8) = 2;
        }
        else
        {
          uint64_t v10 = 4294967289;
        }
        goto LABEL_11;
      }
      uint64_t ws = ccec_compact_generate_key_checksign_ws((uint64_t)v13, a1, a2);
    }
    uint64_t v10 = ws;
LABEL_11:
    v14((uint64_t)v13);
    goto LABEL_12;
  }
  uint64_t v10 = 4294967283;
LABEL_12:
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v10;
}

uint64_t fipspost_post(int a1, char *a2)
{
  uint64_t v4 = mach_absolute_time();
  uint64_t v5 = mach_absolute_time();
  unint64_t v6 = cc_module_id(0);
  printf("FIPSPOST_USER [%llu] %s:%d: [FIPSPOST][Module-ID] %s\n", v5, "fipspost_post", 154, (const char *)v6);
  uint64_t result = 0;
  if ((a1 & 4) != 0) {
    return result;
  }
  uint64_t v8 = mach_absolute_time();
  int v9 = fipspost_post_hmac(a1);
  uint64_t v10 = mach_absolute_time();
  uint64_t v11 = v10;
  if (v9)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_hmac: %d\n", v10, "fipspost_post", 162, v9);
    unsigned int v12 = v9 - 1000;
    if ((a1 & 0x40) == 0)
    {
LABEL_4:
      uint64_t v13 = mach_absolute_time();
      int v14 = fipspost_post_integrity(a1, a2);
      uint64_t v15 = mach_absolute_time();
      uint64_t v16 = v15;
      if (v14)
      {
        printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_integrity: %d\n", v15, "fipspost_post", 166, v14);
        if (!v12) {
          unsigned int v12 = v14 - 2000;
        }
      }
      else
      {
        uint64_t v21 = mach_absolute_time();
        mach_timebase_info info = 0;
        mach_timebase_info(&info);
        LODWORD(v23) = info.denom;
        LODWORD(v22) = info.numer;
        printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_integrity\n", v21, "fipspost_post", 166, ((double)(v16 - v13) * (double)v22 / (double)v23 / 1000000.0));
      }
      int v20 = -3000;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v17 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v19) = info.denom;
    LODWORD(v18) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_hmac\n", v17, "fipspost_post", 162, ((double)(v11 - v8) * (double)v18 / (double)v19 / 1000000.0));
    unsigned int v12 = 0;
    if ((a1 & 0x40) == 0) {
      goto LABEL_4;
    }
  }
  int v20 = -2000;
LABEL_12:
  uint64_t v24 = mach_absolute_time();
  int v25 = fipspost_post_indicator();
  uint64_t v26 = mach_absolute_time();
  uint64_t v27 = v26;
  if (v25)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_indicator: %d\n", v26, "fipspost_post", 170, v25);
    if (!v12) {
      unsigned int v12 = v25 + v20;
    }
  }
  else
  {
    uint64_t v28 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v30) = info.denom;
    LODWORD(v29) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_indicator\n", v28, "fipspost_post", 170, ((double)(v27 - v24) * (double)v29 / (double)v30 / 1000000.0));
  }
  uint64_t v31 = mach_absolute_time();
  int v32 = fipspost_post_aes_ecb(a1);
  uint64_t v33 = mach_absolute_time();
  uint64_t v34 = v33;
  if (v32)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_aes_ecb: %d\n", v33, "fipspost_post", 171, v32);
    if (!v12) {
      unsigned int v12 = v20 + v32 - 1000;
    }
  }
  else
  {
    uint64_t v35 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v37) = info.denom;
    LODWORD(v36) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_aes_ecb\n", v35, "fipspost_post", 171, ((double)(v34 - v31) * (double)v36 / (double)v37 / 1000000.0));
  }
  uint64_t v38 = mach_absolute_time();
  int v39 = fipspost_post_aes_cbc(a1);
  uint64_t v40 = mach_absolute_time();
  uint64_t v41 = v40;
  if (v39)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_aes_cbc: %d\n", v40, "fipspost_post", 172, v39);
    if (!v12) {
      unsigned int v12 = v20 + v39 - 2000;
    }
  }
  else
  {
    uint64_t v42 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v44) = info.denom;
    LODWORD(v43) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_aes_cbc\n", v42, "fipspost_post", 172, ((double)(v41 - v38) * (double)v43 / (double)v44 / 1000000.0));
  }
  uint64_t v45 = mach_absolute_time();
  int v46 = fipspost_post_rsa_sig(a1);
  uint64_t v47 = mach_absolute_time();
  uint64_t v48 = v47;
  if (v46)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_rsa_sig: %d\n", v47, "fipspost_post", 173, v46);
    if (!v12) {
      unsigned int v12 = v20 + v46 - 3000;
    }
  }
  else
  {
    uint64_t v49 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v51) = info.denom;
    LODWORD(v50) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_rsa_sig\n", v49, "fipspost_post", 173, ((double)(v48 - v45) * (double)v50 / (double)v51 / 1000000.0));
  }
  uint64_t v52 = mach_absolute_time();
  int v53 = fipspost_post_ecdsa(a1);
  uint64_t v54 = mach_absolute_time();
  uint64_t v55 = v54;
  if (v53)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_ecdsa: %d\n", v54, "fipspost_post", 174, v53);
    if (!v12) {
      unsigned int v12 = v20 + v53 - 4000;
    }
  }
  else
  {
    uint64_t v56 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v58) = info.denom;
    LODWORD(v57) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_ecdsa\n", v56, "fipspost_post", 174, ((double)(v55 - v52) * (double)v57 / (double)v58 / 1000000.0));
  }
  uint64_t v59 = mach_absolute_time();
  int v60 = fipspost_post_ecdh(a1);
  uint64_t v61 = mach_absolute_time();
  uint64_t v62 = v61;
  if (v60)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_ecdh: %d\n", v61, "fipspost_post", 175, v60);
    if (!v12) {
      unsigned int v12 = v20 + v60 - 5000;
    }
  }
  else
  {
    uint64_t v63 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v65) = info.denom;
    LODWORD(v64) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_ecdh\n", v63, "fipspost_post", 175, ((double)(v62 - v59) * (double)v64 / (double)v65 / 1000000.0));
  }
  uint64_t v66 = mach_absolute_time();
  int v67 = fipspost_post_aes_ccm(a1);
  uint64_t v68 = mach_absolute_time();
  uint64_t v69 = v68;
  if (v67)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_aes_ccm: %d\n", v68, "fipspost_post", 176, v67);
    if (!v12) {
      unsigned int v12 = v20 + v67 - 6000;
    }
  }
  else
  {
    uint64_t v70 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v72) = info.denom;
    LODWORD(v71) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_aes_ccm\n", v70, "fipspost_post", 176, ((double)(v69 - v66) * (double)v71 / (double)v72 / 1000000.0));
  }
  uint64_t v73 = mach_absolute_time();
  int v74 = fipspost_post_aes_cmac(a1);
  uint64_t v75 = mach_absolute_time();
  uint64_t v76 = v75;
  if (v74)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_aes_cmac: %d\n", v75, "fipspost_post", 177, v74);
    if (!v12) {
      unsigned int v12 = v20 + v74 - 7000;
    }
  }
  else
  {
    uint64_t v77 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v79) = info.denom;
    LODWORD(v78) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_aes_cmac\n", v77, "fipspost_post", 177, ((double)(v76 - v73) * (double)v78 / (double)v79 / 1000000.0));
  }
  uint64_t v80 = mach_absolute_time();
  int v81 = fipspost_post_hkdf(a1);
  uint64_t v82 = mach_absolute_time();
  uint64_t v83 = v82;
  if (v81)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_hkdf: %d\n", v82, "fipspost_post", 178, v81);
    if (!v12) {
      unsigned int v12 = v20 + v81 - 8000;
    }
  }
  else
  {
    uint64_t v84 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v86) = info.denom;
    LODWORD(v85) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_hkdf\n", v84, "fipspost_post", 178, ((double)(v83 - v80) * (double)v85 / (double)v86 / 1000000.0));
  }
  uint64_t v87 = mach_absolute_time();
  int v88 = fipspost_post_pbkdf(a1);
  uint64_t v89 = mach_absolute_time();
  uint64_t v90 = v89;
  if (v88)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_pbkdf: %d\n", v89, "fipspost_post", 179, v88);
    if (!v12) {
      unsigned int v12 = v20 + v88 - 9000;
    }
  }
  else
  {
    uint64_t v91 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v93) = info.denom;
    LODWORD(v92) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_pbkdf\n", v91, "fipspost_post", 179, ((double)(v90 - v87) * (double)v92 / (double)v93 / 1000000.0));
  }
  uint64_t v94 = mach_absolute_time();
  int v95 = fipspost_post_drbg_hmac(a1);
  uint64_t v96 = mach_absolute_time();
  uint64_t v97 = v96;
  if (v95)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_drbg_hmac: %d\n", v96, "fipspost_post", 180, v95);
    if (!v12) {
      unsigned int v12 = v20 + v95 - 10000;
    }
  }
  else
  {
    uint64_t v98 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v100) = info.denom;
    LODWORD(v99) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_drbg_hmac\n", v98, "fipspost_post", 180, ((double)(v97 - v94) * (double)v99 / (double)v100 / 1000000.0));
  }
  uint64_t v101 = mach_absolute_time();
  int v102 = fipspost_post_kdf_ctr(a1);
  uint64_t v103 = mach_absolute_time();
  uint64_t v104 = v103;
  if (v102)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_kdf_ctr: %d\n", v103, "fipspost_post", 182, v102);
    if (!v12) {
      unsigned int v12 = v20 + v102 - 11000;
    }
  }
  else
  {
    uint64_t v105 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v107) = info.denom;
    LODWORD(v106) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_kdf_ctr\n", v105, "fipspost_post", 182, ((double)(v104 - v101) * (double)v106 / (double)v107 / 1000000.0));
  }
  uint64_t v108 = mach_absolute_time();
  int v109 = fipspost_post_kdf_ctr_cmac(a1);
  uint64_t v110 = mach_absolute_time();
  uint64_t v111 = v110;
  if (v109)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_kdf_ctr_cmac: %d\n", v110, "fipspost_post", 183, v109);
    if (!v12) {
      unsigned int v12 = v20 + v109 - 12000;
    }
  }
  else
  {
    uint64_t v112 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v114) = info.denom;
    LODWORD(v113) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_kdf_ctr_cmac\n", v112, "fipspost_post", 183, ((double)(v111 - v108) * (double)v113 / (double)v114 / 1000000.0));
  }
  uint64_t v115 = mach_absolute_time();
  int v116 = fipspost_post_aes_gcm(a1);
  uint64_t v117 = mach_absolute_time();
  uint64_t v118 = v117;
  if (v116)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_aes_gcm: %d\n", v117, "fipspost_post", 184, v116);
    if (!v12) {
      unsigned int v12 = v20 + v116 - 13000;
    }
  }
  else
  {
    uint64_t v119 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v121) = info.denom;
    LODWORD(v120) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_aes_gcm\n", v119, "fipspost_post", 184, ((double)(v118 - v115) * (double)v120 / (double)v121 / 1000000.0));
  }
  uint64_t v122 = mach_absolute_time();
  int v123 = fipspost_post_aes_xts(a1);
  uint64_t v124 = mach_absolute_time();
  uint64_t v125 = v124;
  if (v123)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_aes_xts: %d\n", v124, "fipspost_post", 185, v123);
    if (!v12) {
      unsigned int v12 = v20 + v123 - 14000;
    }
  }
  else
  {
    uint64_t v126 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v128) = info.denom;
    LODWORD(v127) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_aes_xts\n", v126, "fipspost_post", 185, ((double)(v125 - v122) * (double)v127 / (double)v128 / 1000000.0));
  }
  uint64_t v129 = mach_absolute_time();
  int v130 = fipspost_post_tdes_ecb(a1);
  uint64_t v131 = mach_absolute_time();
  uint64_t v132 = v131;
  if (v130)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_tdes_ecb: %d\n", v131, "fipspost_post", 186, v130);
    if (!v12) {
      unsigned int v12 = v20 + v130 - 15000;
    }
  }
  else
  {
    uint64_t v133 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v135) = info.denom;
    LODWORD(v134) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_tdes_ecb\n", v133, "fipspost_post", 186, ((double)(v132 - v129) * (double)v134 / (double)v135 / 1000000.0));
  }
  uint64_t v136 = mach_absolute_time();
  int v137 = fipspost_post_drbg_ctr(a1);
  uint64_t v138 = mach_absolute_time();
  uint64_t v139 = v138;
  if (v137)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_drbg_ctr: %d\n", v138, "fipspost_post", 187, v137);
    if (!v12) {
      unsigned int v12 = v20 + v137 - 16000;
    }
  }
  else
  {
    uint64_t v140 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v142) = info.denom;
    LODWORD(v141) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_drbg_ctr\n", v140, "fipspost_post", 187, ((double)(v139 - v136) * (double)v141 / (double)v142 / 1000000.0));
  }
  uint64_t v143 = mach_absolute_time();
  int v144 = fipspost_post_ffdh(a1);
  uint64_t v145 = mach_absolute_time();
  uint64_t v146 = v145;
  if (v144)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_ffdh: %d\n", v145, "fipspost_post", 189, v144);
    if (!v12) {
      unsigned int v12 = v20 + v144 - 17000;
    }
  }
  else
  {
    uint64_t v147 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v149) = info.denom;
    LODWORD(v148) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_ffdh\n", v147, "fipspost_post", 189, ((double)(v146 - v143) * (double)v148 / (double)v149 / 1000000.0));
  }
  uint64_t v150 = mach_absolute_time();
  int v151 = fipspost_post_rsa_enc_dec(a1);
  uint64_t v152 = mach_absolute_time();
  uint64_t v153 = v152;
  if (v151)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_rsa_enc_dec: %d\n", v152, "fipspost_post", 190, v151);
    if (!v12) {
      unsigned int v12 = v20 + v151 - 18000;
    }
  }
  else
  {
    uint64_t v154 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v156) = info.denom;
    LODWORD(v155) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_rsa_enc_dec\n", v154, "fipspost_post", 190, ((double)(v153 - v150) * (double)v155 / (double)v156 / 1000000.0));
  }
  uint64_t v157 = mach_absolute_time();
  int v158 = fipspost_post_shake(a1);
  uint64_t v159 = mach_absolute_time();
  uint64_t v160 = v159;
  if (v158)
  {
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_shake: %d\n", v159, "fipspost_post", 191, v158);
    if (!v12) {
      unsigned int v12 = v20 + v158 - 19000;
    }
  }
  else
  {
    uint64_t v161 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v163) = info.denom;
    LODWORD(v162) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: PASSED: (%u ms) - fipspost_post_shake\n", v161, "fipspost_post", 191, ((double)(v160 - v157) * (double)v162 / (double)v163 / 1000000.0));
  }
  uint64_t v164 = mach_absolute_time();
  if (!v12)
  {
    uint64_t v165 = v164;
    uint64_t v166 = mach_absolute_time();
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    LODWORD(v168) = info.denom;
    LODWORD(v167) = info.numer;
    printf("FIPSPOST_USER [%llu] %s:%d: all tests PASSED (%u ms)\n", v166, "fipspost_post", 211, ((double)(v165 - v4) * (double)v167 / (double)v168 / 1000000.0));
  }
  if ((a1 & 0x100) != 0) {
    return 0;
  }
  else {
    return v12;
  }
}

void *ccdh_gp_rfc3526group17()
{
  return &_ccdh_gp_rfc3526group17;
}

uint64_t ccz_lsl(uint64_t a1, uint64_t a2, unint64_t a3)
{
  BOOL v19 = timingsafe_enable_if_supported();
  int v6 = ccz_sign(a2);
  ccz_set_sign(a1, v6);
  uint64_t v7 = ccz_n(a2);
  ccz_set_capacity(a1, v7 + ((a3 + 63) >> 6));
  unint64_t v8 = a3 >> 6;
  unint64_t v9 = a3 & 0x3F;
  uint64_t v10 = (void *)(*(void *)(a1 + 24) + 8 * (a3 >> 6));
  uint64_t v11 = *(const void **)(a2 + 24);
  uint64_t v12 = ccz_n(a2);
  memmove(v10, v11, 8 * v12);
  uint64_t v13 = ccz_n(a2);
  ccz_set_n((void *)a1, v13 + (a3 >> 6));
  ccn_zero(a3 >> 6, *(void **)(a1 + 24));
  if ((a3 & 0x3F) != 0)
  {
    uint64_t v14 = *(void *)(a1 + 24);
    *(void *)(v14 + 8 * ccz_n(a1)) = 0;
    uint64_t v15 = ccz_n(a1);
    ccn_shift_left(v15 - v8 + 1, (void *)(*(void *)(a1 + 24) + 8 * v8), (unint64_t *)(*(void *)(a1 + 24) + 8 * v8), v9);
    uint64_t v16 = ccz_n(a1);
    unint64_t v17 = ccn_n(v16 + 1, *(void *)(a1 + 24));
    ccz_set_n((void *)a1, v17);
  }
  return cc_disable_dit_with_sb((unsigned int *)&v19);
}

uint64_t ccec_x963_export(int a1, char *a2, uint64_t *a3)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v6 = ccec_export_pub(a3, a2);
  uint64_t v7 = v6;
  if (a1 && !v6)
  {
    uint64_t v8 = *a3;
    unint64_t v9 = *(void *)*a3;
    unint64_t v10 = (unint64_t)(cczp_bitlen(*a3 + 40 * v9 + 32) + 7) >> 3;
    uint64_t v11 = cczp_bitlen(v8);
    int v12 = ccn_write_uint_padded_ct_internal(v9, (unint64_t *)&a3[3 * v9 + 2], v10, &a2[((unint64_t)(v11 + 7) >> 2) | 1]);
    uint64_t v7 = v12 & (v12 >> 31);
  }
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v7;
}

uint64_t ccec_make_pub(uint64_t a1, unint64_t a2, unsigned __int8 *a3, unint64_t a4, unsigned __int8 *a5, uint64_t a6)
{
  BOOL v17 = timingsafe_enable_if_supported();
  if (a4)
  {
    cp = (unint64_t *)ccec_get_cp(a1);
    if (!cp
      || (uint64_t v13 = (uint64_t *)cp,
          *(void *)a6 = cp,
          uint64_t v14 = a6 + 16,
          ccn_read_uint_public_value(*cp, (void *)(a6 + 16), a2, a3))
      || ccn_read_uint_public_value(*v13, (void *)(v14 + 8 * **(void **)a6), a4, a5))
    {
      uint64_t v15 = 0xFFFFFFFFLL;
    }
    else
    {
      ccn_seti(*v13, (void *)(v14 + 16 * **(void **)a6), 1);
      uint64_t v15 = 0;
    }
  }
  else
  {
    uint64_t v15 = 4294967289;
  }
  cc_disable_dit_with_sb((unsigned int *)&v17);
  return v15;
}

uint64_t ccrsa_recover_priv(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t (**a8)(void, unint64_t, uint64_t))
{
  BOOL v74 = timingsafe_enable_if_supported();
  unint64_t v14 = (unint64_t)(a2 + 7) >> 3;
  uint64_t v15 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v16 = sizeof_struct_ccpolyzp_po2cyc();
  uint64_t v17 = (20 * v14) | 1;
  v70[0] = cc_malloc_clear(8 * ((v15 + v16 - 1) / v16 + v17));
  uint64_t v18 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v19 = sizeof_struct_ccpolyzp_po2cyc();
  v70[1] = (v18 + v19 - 1) / v19 + v17;
  uint64_t v71 = 0;
  unint64_t v72 = cc_ws_alloc;
  uint64_t v73 = cc_ws_free;
  if (!v70[0])
  {
    uint64_t inited = 4294967283;
    goto LABEL_9;
  }
  *a1 = v14;
  int v20 = (unsigned char *)cc_ws_alloc(v70, (unint64_t)(a2 + 7) >> 3);
  uint64_t v21 = v72(v70, (unint64_t)(a2 + 7) >> 3);
  unint64_t v22 = (void *)v72(v70, (unint64_t)(a2 + 7) >> 3);
  if (!ccn_read_uint_internal((unint64_t)(a2 + 7) >> 3, v20, a2, a3))
  {
    unint64_t v64 = (unint64_t *)v21;
    unint64_t v65 = (char *)(a1 + 3);
    if (*v20)
    {
      uint64_t v23 = (uint64_t)&v65[16 * v14 + 8];
      if (!ccn_read_uint_internal((unint64_t)(a2 + 7) >> 3, v23, a4, a5)
        && !ccn_read_uint_internal((unint64_t)(a2 + 7) >> 3, v21, a6, a7))
      {
        ccn_set((unint64_t)(a2 + 7) >> 3, v65, v20);
        uint64_t inited = cczp_init_ws((uint64_t)v70, a1);
        if (inited) {
          goto LABEL_7;
        }
        unint64_t v58 = v20;
        uint64_t v26 = cczp_n((uint64_t)a1);
        uint64_t v59 = v71;
        unint64_t __dst = (void *)v72(v70, v26);
        uint64_t v63 = (char *)v72(v70, v26);
        uint64_t v27 = (void *)v72(v70, 2 * v26);
        uint64_t v69 = (void *)v72(v70, v26);
        unint64_t v28 = ccn_n(v26, v23);
        unint64_t v29 = (void *)v72(v70, 2 * v26 + 4);
        uint64_t v62 = a1;
        cczp_mm_init_copy(v29, a1);
        unint64_t v60 = v28 + v26;
        cc_clear(8 * (v28 + v26), v27);
        if (v28)
        {
          uint64_t v30 = 0;
          unsigned int v31 = 1;
          do
          {
            uint64_t v32 = ccn_addmul1(v26, &v27[v30], v64, *(void *)(v23 + 8 * v30));
            uint64_t v33 = v30 + v26;
            uint64_t v30 = v31;
            BOOL v34 = v28 > v31++;
            v27[v33] = v32;
          }
          while (v34);
        }
        if ((*v27 & 1) == 0)
        {
LABEL_15:
          uint64_t inited = 4294967273;
LABEL_16:
          cczp_from_ws((uint64_t)v70, (uint64_t)v29);
          goto LABEL_7;
        }
        *v27 &= ~1uLL;
        unint64_t v35 = ccn_trailing_zeros(v60, (uint64_t)v27);
        ccn_shift_right_multi(v60, (uint64_t)v27, v27, v35);
        unint64_t v36 = (void *)cczp_prime((uint64_t)a1);
        ccn_set(v26, __dst, v36);
        *__dst &= ~1uLL;
        cczp_to_ws((uint64_t)v70, (uint64_t)v29);
        ccn_seti(v26, v69, 1);
        cczp_to_ws((uint64_t)v70, (uint64_t)v29);
        int v37 = 0;
        uint64_t v61 = v60 << 6;
        while (1)
        {
          uint64_t non_zero_element_ws = cczp_generate_non_zero_element_ws((uint64_t)v70, (uint64_t)a1, a8, v63);
          if (non_zero_element_ws)
          {
            uint64_t inited = non_zero_element_ws;
            goto LABEL_16;
          }
          uint64_t v39 = cczp_power_ws((uint64_t)v70, (uint64_t)v29, v22, v63, v61, v27);
          if (v39)
          {
            uint64_t inited = v39;
            goto LABEL_16;
          }
          if (ccn_cmp_internal(v26, v22, v69))
          {
            int v40 = ccn_cmp_internal(v26, __dst, v22);
            if (v35)
            {
              if (v40) {
                break;
              }
            }
          }
LABEL_27:
          if (++v37 == 100) {
            goto LABEL_15;
          }
        }
        unsigned int v41 = 1;
        while (1)
        {
          cczp_sqr_ws((uint64_t)v70, (uint64_t)v29);
          if (!ccn_cmp_internal(v26, v63, v69)) {
            break;
          }
          if (ccn_cmp_internal(v26, __dst, v63))
          {
            ccn_set(v26, v22, v63);
            BOOL v34 = v35 > v41++;
            if (v34) {
              continue;
            }
          }
          goto LABEL_27;
        }
        cczp_from_ws((uint64_t)v70, (uint64_t)v29);
        uint64_t v71 = v59;
        unint64_t v42 = *a1;
        unint64_t v43 = (unint64_t *)v72(v70, *a1);
        unint64_t v44 = (unint64_t *)v72(v70, v42);
        ccn_sub1(v42, v43, (unint64_t *)v22, 1uLL);
        uint64_t v45 = (void *)cczp_prime((uint64_t)a1);
        unint64_t v46 = ccn_n(v42, (uint64_t)v43);
        if (!ccn_gcd_ws((uint64_t)v70, v42, (uint64_t *)v43, v42, v45, v46, v43))
        {
          uint64_t v47 = (unint64_t *)cczp_prime((uint64_t)a1);
          ccn_div_exact_ws((uint64_t)v70, v42, v44, v47, v43);
          int v48 = ccn_cmp_internal(v42, v43, v44);
          if (v48)
          {
            ccn_cond_swap(v42, v48 < 0, (uint64_t *)v43, (uint64_t *)v44);
            uint64_t v49 = (void *)ccrsa_ctx_private_zp(a1);
            *uint64_t v49 = ccn_n(v42, (uint64_t)v43);
            uint64_t v50 = cczp_n((uint64_t)v49);
            ccn_set(v50, v49 + 3, v43);
            uint64_t inited = cczp_init_ws((uint64_t)v70, v49);
            if (!inited)
            {
              uint64_t v51 = ccrsa_ctx_private_zp(v62);
              uint64_t v52 = v51 + 16 * *(void *)ccrsa_ctx_private_zp(v62);
              *(void *)(v52 + 32) = ccn_n(v42, (uint64_t)v44);
              int v53 = (void *)(v52 + 32);
              uint64_t v54 = cczp_n((uint64_t)v53);
              ccn_set(v54, v53 + 3, v44);
              uint64_t inited = cczp_init_ws((uint64_t)v70, v53);
              if (!inited)
              {
                uint64_t v55 = cczp_bitlen((uint64_t)v49);
                if ((unint64_t)(v55 - cczp_bitlen((uint64_t)v53)) > 2) {
                  goto LABEL_6;
                }
                uint64_t v71 = v59;
                uint64_t inited = ccrsa_crt_makekey_ws((uint64_t)v70, v62);
                if (!inited)
                {
                  uint64_t v56 = cczp_prime((uint64_t)v62);
                  int v57 = ccn_cmp_internal(v14, v58, v56);
                  if (ccn_cmp_internal(v14, v64, &v65[24 * *v62 + 8]) | v57) {
                    uint64_t inited = 4294967273;
                  }
                  else {
                    uint64_t inited = 0;
                  }
                }
              }
            }
            goto LABEL_7;
          }
        }
      }
    }
  }
LABEL_6:
  uint64_t inited = 4294967273;
LABEL_7:
  uint64_t v71 = 0;
  v73((uint64_t)v70);
LABEL_9:
  cc_disable_dit_with_sb((unsigned int *)&v74);
  return inited;
}

uint64_t ccz_is_negative(uint64_t a1)
{
  BOOL v3 = timingsafe_enable_if_supported();
  LODWORD(a1) = ccz_sign(a1);
  cc_disable_dit_with_sb((unsigned int *)&v3);
  return a1 >> 31;
}

uint64_t ccaes_ecb_encrypt_init(uint64_t a1, int *a2, uint64_t a3, int *a4)
{
  if (a3 > 127)
  {
    if (a3 != 128 && a3 != 256 && a3 != 192) {
      return 4294967289;
    }
    return ccaes_ltc_init(a4, a3, a2);
  }
  if ((unint64_t)a3 <= 0x20 && ((1 << a3) & 0x101010000) != 0) {
    return ccaes_ltc_init(a4, a3, a2);
  }
  return 4294967289;
}

uint64_t ccaes_ltc_init(int *a1, signed int a2, int *a3)
{
  uint64_t v3 = 4294967289;
  if (a2 > 127)
  {
    if (a2 != 128 && a2 != 256 && a2 != 192) {
      return v3;
    }
  }
  else if ((unint64_t)a2 > 0x20 || ((1 << a2) & 0x101010000) == 0)
  {
    return v3;
  }
  if (a2 <= 0x7F) {
    int v4 = a2;
  }
  else {
    int v4 = (unint64_t)(a2 + 7) >> 3;
  }
  int v5 = ((4 * v4) & 0x7FFFFFE0) + 96;
  uint64_t v6 = a3 + 61;
  a3[121] = v5;
  a3[60] = v5;
  int v7 = *a1;
  *a3 = *a1;
  unsigned int v8 = a1[1];
  a3[1] = v8;
  unsigned int v9 = a1[2];
  a3[2] = v9;
  unsigned int v10 = a1[3];
  a3[3] = v10;
  if (v4 == 24)
  {
    uint64_t v24 = 0;
    a3[4] = a1[4];
    unsigned int v25 = a1[5];
    a3[5] = v25;
    uint64_t v26 = (unsigned int *)(a3 + 11);
    uint64_t v13 = 52;
    while (1)
    {
      v7 ^= Te4_3[BYTE1(v25)] ^ Te4_2[BYTE2(v25)] ^ Te4_1[HIBYTE(v25)] ^ Te4_0[v25] ^ rcon[v24];
      v8 ^= v7;
      *(v26 - 5) = v7;
      *(v26 - 4) = v8;
      v9 ^= v8;
      v10 ^= v9;
      *(v26 - 3) = v9;
      *(v26 - 2) = v10;
      if (v24 == 7) {
        break;
      }
      int v27 = *(v26 - 7) ^ v10;
      v25 ^= v27;
      *(v26 - 1) = v27;
      *uint64_t v26 = v25;
      v26 += 6;
      ++v24;
    }
  }
  else if (v4 == 16)
  {
    uint64_t v11 = 0;
    int v12 = a3 + 4;
    uint64_t v13 = 44;
    do
    {
      unint64_t v14 = *(v12 - 1);
      v7 ^= Te4_3[BYTE1(v14)] ^ Te4_2[BYTE2(v14)] ^ *(_DWORD *)((char *)Te4_1 + ((v14 >> 22) & 0x3FC)) ^ Te4_0[*(v12 - 1)] ^ rcon[v11];
      int v15 = *(v12 - 2);
      int v16 = *(v12 - 3) ^ v7;
      *int v12 = v7;
      v12[1] = v16;
      int v17 = v15 ^ v16;
      uint64_t v12[2] = v17;
      v12[3] = v17 ^ v14;
      ++v11;
      v12 += 4;
    }
    while (v11 != 10);
  }
  else
  {
    uint64_t v28 = 0;
    a3[4] = a1[4];
    a3[5] = a1[5];
    a3[6] = a1[6];
    unsigned int v29 = a1[7];
    a3[7] = v29;
    uint64_t v30 = a3 + 8;
    uint64_t v13 = 60;
    while (1)
    {
      v7 ^= Te4_3[BYTE1(v29)] ^ Te4_2[BYTE2(v29)] ^ Te4_1[HIBYTE(v29)] ^ Te4_0[v29] ^ rcon[v28];
      v8 ^= v7;
      *uint64_t v30 = v7;
      v30[1] = v8;
      v9 ^= v8;
      v10 ^= v9;
      v30[2] = v9;
      v30[3] = v10;
      if (v28 == 6) {
        break;
      }
      HIDWORD(v31) = v10;
      LODWORD(v31) = v10;
      int v32 = Te4_3[((unsigned __int16)(v31 >> 24) >> 8)] ^ *(v30 - 4) ^ Te4_2[((v31 >> 24) >> 16)] ^ Te4_1[(v31 >> 24) >> 24] ^ Te4_0[HIBYTE(v10)];
      int v33 = *(v30 - 3) ^ v32;
      v30[4] = v32;
      v30[5] = v33;
      int v34 = *(v30 - 2) ^ v33;
      v29 ^= v34;
      v30[6] = v34;
      v30[7] = v29;
      v30 += 8;
      ++v28;
    }
  }
  uint64_t v18 = &a3[v13];
  long long v20 = *((_OWORD *)v18 - 1);
  unint64_t v19 = v18 - 4;
  *(_OWORD *)(a3 + 61) = v20;
  if (a3[121] >= 0x20)
  {
    unsigned int v21 = 1;
    do
    {
      unsigned int v22 = *(v19 - 4);
      v19 -= 4;
      v6[4] = Tks1[BYTE1(v22)] ^ Tks0[v22] ^ Tks2[BYTE2(v22)] ^ *(_DWORD *)((char *)&Tks3
                                                                                           + (((unint64_t)v22 >> 22) & 0x3FC));
      v6 += 4;
      v6[1] = Tks1[BYTE1(v19[1])] ^ Tks0[v19[1]] ^ Tks2[BYTE2(v19[1])] ^ *(_DWORD *)((char *)&Tks3 + (((unint64_t)v19[1] >> 22) & 0x3FC));
      v6[2] = Tks1[BYTE1(v19[2])] ^ Tks0[v19[2]] ^ Tks2[BYTE2(v19[2])] ^ *(_DWORD *)((char *)&Tks3 + (((unint64_t)v19[2] >> 22) & 0x3FC));
      v6[3] = Tks1[BYTE1(v19[3])] ^ Tks0[v19[3]] ^ Tks2[BYTE2(v19[3])] ^ *(_DWORD *)((char *)&Tks3 + (((unint64_t)v19[3] >> 22) & 0x3FC));
      ++v21;
    }
    while (v21 < a3[121] >> 4);
  }
  uint64_t v3 = 0;
  v6[4] = *(v19 - 4);
  v6[5] = *(v19 - 3);
  v6[6] = *(v19 - 2);
  v6[7] = *(v19 - 1);
  return v3;
}

uint64_t ccaes_ecb_decrypt_init(uint64_t a1, int *a2, uint64_t a3, int *a4)
{
  if (a3 > 127)
  {
    if (a3 != 128 && a3 != 256 && a3 != 192) {
      return 4294967289;
    }
    return ccaes_ltc_init(a4, a3, a2);
  }
  if ((unint64_t)a3 <= 0x20 && ((1 << a3) & 0x101010000) != 0) {
    return ccaes_ltc_init(a4, a3, a2);
  }
  return 4294967289;
}

__n128 ccaes_ecb_encrypt_roundkey(uint64_t a1, int a2, __n128 *a3)
{
  __n128 result = *(__n128 *)(a1 + 4 * (4 * a2));
  *a3 = result;
  return result;
}

uint64_t ccrsa_emsa_pss_decode_canary_out_ws(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, size_t a5, char *a6, uint64_t a7, unsigned __int8 *a8, void *a9)
{
  uint64_t v54 = *MEMORY[0x263EF8C08];
  *a9 = 0;
  a9[1] = 0;
  if (*(void *)a2 != a5) {
    return 4294967270;
  }
  int v9 = a7;
  unint64_t v11 = (unint64_t)(a7 + 7) >> 3;
  size_t v12 = a5 + a4;
  if (v11 < a5 + a4 + 2) {
    return 4294967270;
  }
  uint64_t v47 = a6;
  size_t v48 = a4;
  uint64_t v50 = *(void *)(a1 + 16);
  uint64_t v51 = a1;
  int v17 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, (unint64_t)(a7 + 63) >> 6);
  int v46 = a8[v11 - 1] ^ 0xBC;
  int v18 = -v9 & 7;
  int v19 = (-256 >> v18) & *a8;
  uint64_t v20 = v11 + ~a5;
  uint64_t v49 = (char *)&a8[v20];
  uint64_t v21 = ccmgf_internal(a3, v20, (uint64_t)v17, a5, (char *)&a8[v20]);
  int v25 = v21 | v19 | v46;
  unsigned int v26 = *v17 & (0xFFu >> v18);
  *v17 &= 0xFFu >> v18;
  unint64_t v27 = v11 - 2 - v12;
  if (v11 - 2 != v12)
  {
    if (v27 <= 1) {
      unint64_t v27 = 1;
    }
    uint64_t v28 = a8;
    unsigned int v29 = v17;
    unint64_t v30 = v27;
    do
    {
      int v32 = *v28++;
      int v31 = v32;
      int v33 = *v29++;
      v25 |= v33 ^ v31;
      --v30;
    }
    while (v30);
    unsigned int v26 = v17[v27];
  }
  size_t v34 = v48;
  int v35 = a8[v27] ^ v26;
  if (v48)
  {
    unint64_t v36 = v27 + 1;
    int v37 = v17;
    size_t v38 = v48;
    do
    {
      *int v37 = v37[v36] ^ a8[v36];
      ++v37;
      ++a8;
      --v38;
    }
    while (v38);
  }
  int v39 = v35 ^ 1;
  uint64_t __src = 0;
  MEMORY[0x270FA53B0](v21, v22, v23, v24);
  unsigned int v41 = &v45[-v40];
  ccdigest_init_internal(a2, &v45[-v40]);
  ccdigest_update_internal((unint64_t *)a2, v41, 8uLL, (char *)&__src);
  ccdigest_update_internal((unint64_t *)a2, v41, a5, v47);
  if (v34) {
    ccdigest_update_internal((unint64_t *)a2, v41, v34, v17);
  }
  (*(void (**)(uint64_t, void *, char *))(a2 + 56))(a2, v41, v53);
  cc_clear(*(void *)(a2 + 8) + *(void *)(a2 + 16) + 12, v41);
  unint64_t v42 = v49;
  unsigned int v43 = cc_cmp_safe_internal(a5, v53, v49);
  unint64_t v13 = -(((v25 | v39 | v43 | ((unint64_t)(int)(v25 | v39 | v43) >> 32)) + 0xFFFFFFFF) >> 32) & 0xFFFFFFE6;
  cc_fault_canary_set((uint64_t)a9, (uint64_t)&CCRSA_PSS_FAULT_CANARY, a5, (uint64_t)v42, (uint64_t)v53);
  *(void *)(v51 + 16) = v50;
  return v13;
}

uint64_t ccrsa_emsa_pss_decode_ws(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, size_t a5, char *a6, uint64_t a7, unsigned __int8 *a8)
{
  void v9[2] = *MEMORY[0x263EF8C08];
  v9[0] = 0xAAAAAAAAAAAAAAAALL;
  v9[1] = 0xAAAAAAAAAAAAAAAALL;
  return ccrsa_emsa_pss_decode_canary_out_ws(a1, a2, a3, a4, a5, a6, a7, a8, v9);
}

uint64_t ccrsa_emsa_pss_decode(uint64_t a1, uint64_t a2, uint64_t a3, size_t a4, char *a5, uint64_t a6, unsigned __int8 *a7)
{
  unsigned int v19[2] = *MEMORY[0x263EF8C08];
  BOOL v18 = timingsafe_enable_if_supported();
  v16[0] = cc_malloc_clear(8 * ((unint64_t)(a6 + 63) >> 6));
  v16[1] = (unint64_t)(a6 + 63) >> 6;
  _OWORD v16[2] = 0;
  v16[3] = cc_ws_alloc;
  int v17 = cc_ws_free;
  if (v16[0])
  {
    v19[0] = 0xAAAAAAAAAAAAAAAALL;
    v19[1] = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v14 = ccrsa_emsa_pss_decode_canary_out_ws((uint64_t)v16, a1, a2, a3, a4, a5, a6, a7, v19);
    v17((uint64_t)v16);
  }
  else
  {
    uint64_t v14 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return v14;
}

uint64_t ccder_blob_decode_sequence_tl_strict(unsigned __int8 **a1, unsigned __int8 **a2)
{
  return ccder_blob_decode_range_strict(a1, 0x2000000000000010, a2);
}

uint64_t ccder_blob_decode_sequence_tl(unsigned __int8 **a1, unsigned __int8 **a2)
{
  return ccder_blob_decode_range(a1, 0x2000000000000010, a2);
}

uint64_t ccss_sizeof_generator(unsigned int *a1)
{
  return 8 * cczp_n((uint64_t)(a1 + 2)) * *a1 + 16;
}

uint64_t ccss_sizeof_share(uint64_t a1)
{
  return 8 * cczp_n(a1 + 8) + 16;
}

unint64_t ccss_sizeof_parameters(uint64_t a1)
{
  return ((2 * a1 + 14) & 0xFFFFFFFFFFFFFFF0) + 48;
}

uint64_t ccss_sizeof_share_bag(unsigned int *a1)
{
  uint64_t v1 = *a1;
  return 8 * (v1 + v1 * cczp_n((uint64_t)(a1 + 2))) + 16;
}

uint64_t ccss_shamir_poly_coefficient(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 8) < a2) {
    cc_abort();
  }
  return a1 + 8 * **(void **)a1 * a2 + 16;
}

uint64_t ccss_shamir_prime_of(uint64_t a1)
{
  return *(void *)a1;
}

unsigned char *ccss_shamir_share_init(void *a1, uint64_t a2)
{
  char v2 = 0;
  char v9 = 0;
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    if ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) & 0x1000000) != 0)
    {
      char v2 = 0;
    }
    else
    {
      __asm { MSR             DIT, #1 }
      char v2 = 1;
    }
  }
  char v9 = v2;
  *a1 = a2 + 8;
  return cc_disable_dit(&v9);
}

uint64_t ccss_shamir_consistent_primes(uint64_t a1, uint64_t a2)
{
  if (a2 == a1) {
    return 0;
  }
  uint64_t v4 = cczp_n(a2);
  uint64_t v5 = cczp_prime(a2);
  uint64_t v6 = cczp_n(a1);
  uint64_t v7 = cczp_prime(a1);
  if (!ccn_cmpn_internal(v4, v5, v6, v7)) {
    return 0;
  }
  else {
    return 4294967166;
  }
}

BOOL csss_shamir_share_bag_can_recover_secret(uint64_t a1)
{
  char v1 = 0;
  char v9 = 0;
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    if ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) & 0x1000000) != 0)
    {
      char v1 = 0;
    }
    else
    {
      __asm { MSR             DIT, #1 }
      char v1 = 1;
    }
  }
  char v9 = v1;
  BOOL v7 = *(_DWORD *)(a1 + 8) >= **(_DWORD **)a1;
  cc_disable_dit(&v9);
  return v7;
}

uint64_t ccss_shamir_parameters_init(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  char v6 = 0;
  char v17 = 0;
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    if ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) & 0x1000000) != 0)
    {
      char v6 = 0;
    }
    else
    {
      __asm { MSR             DIT, #1 }
      char v6 = 1;
    }
  }
  char v17 = v6;
  if (a4 >= 2)
  {
    unint64_t v13 = (unint64_t)(a2 + 7) >> 3;
    *(void *)(a1 + 8) = v13;
    uint64_t uint_internal = ccn_read_uint_internal(v13, a1 + 32, a2, a3);
    if (!uint_internal)
    {
      uint64_t uint_internal = cczp_init((void *)(a1 + 8));
      if (!uint_internal)
      {
        uint64_t v16 = a4;
        uint64_t v14 = cczp_prime(a1 + 8);
        if ((ccn_cmpn_internal(1, &v16, v13, v14) & 0x80000000) != 0)
        {
          uint64_t uint_internal = 0;
          *(_DWORD *)a1 = a4;
        }
        else
        {
          uint64_t uint_internal = 4294967168;
        }
      }
    }
  }
  else
  {
    uint64_t uint_internal = 4294967171;
  }
  cc_disable_dit(&v17);
  return uint_internal;
}

uint64_t ccss_shamir_parameters_maximum_secret_length(uint64_t a1)
{
  char v1 = 0;
  char v9 = 0;
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    if ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) & 0x1000000) != 0)
    {
      char v1 = 0;
    }
    else
    {
      __asm { MSR             DIT, #1 }
      char v1 = 1;
    }
  }
  char v9 = v1;
  uint64_t v7 = 8 * cczp_n(a1 + 8) - 1;
  cc_disable_dit(&v9);
  return v7;
}

uint64_t ccec_add_normalized_ws(uint64_t a1, unint64_t *a2, void *a3, uint64_t a4, uint64_t a5, int a6)
{
  unint64_t v9 = *a2;
  uint64_t v14 = *(void *)(a1 + 16);
  uint64_t v10 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, *a2);
  uint64_t v11 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v9);
  (*(void (**)(uint64_t, unint64_t))(a1 + 24))(a1, v9);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  if (a6) {
    cczp_add_ws(a1, (uint64_t)a2);
  }
  else {
    cczp_sub_ws(a1, (uint64_t)a2);
  }
  if (ccn_n(v9, v10) || ccn_n(v9, v11))
  {
    if (ccn_n(v9, v10) || !ccn_n(v9, v11))
    {
      cczp_add_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      cczp_add_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_sqr_ws(a1, (uint64_t)a2);
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_sqr_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      uint64_t result = cczp_div2_ws(a1, (uint64_t)a2, &a3[v9], &a3[v9]);
    }
    else
    {
      ccn_seti(v9, a3, 1);
      cczp_to_ws(a1, (uint64_t)a2);
      ccn_set(v9, &a3[v9], a3);
      uint64_t result = cc_clear(8 * v9, &a3[2 * v9]);
    }
  }
  else
  {
    uint64_t result = ccec_double_ws(a1, a2);
  }
  *(void *)(a1 + 16) = v14;
  return result;
}

uint64_t ccec_full_add_normalized_ws(uint64_t a1, unint64_t *a2, char *a3, uint64_t a4, char *a5)
{
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = *a2;
  if (ccec_is_point_at_infinity(a2, a4))
  {
    ccn_set(v11, a3, a5);
    ccn_set(v11, &a3[8 * *a2], &a5[8 * *a2]);
    uint64_t result = (uint64_t)ccn_set(v11, &a3[16 * *a2], &a5[16 * *a2]);
  }
  else
  {
    uint64_t result = ccec_add_normalized_ws(a1, a2, a3, a4, (uint64_t)a5, 0);
  }
  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t ccec_full_add_default_ws(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = cczp_n((uint64_t)a2);
  uint64_t v16 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  ccec_map_to_homogeneous_ws(a1, (uint64_t)a2);
  ccec_map_to_homogeneous_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  uint64_t v7 = cczp_n((uint64_t)a2);
  uint64_t v8 = *a2;
  unint64_t v9 = &a3[*a2];
  uint64_t v10 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v7);
  uint64_t v11 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v7);
  ccn_set(v7, v10, v9);
  cczp_from_ws(a1, (uint64_t)a2);
  BOOL v12 = ccn_n(v7, (uint64_t)v11) == 1 && *v11 == 1;
  uint64_t v13 = (uint64_t)&a3[2 * v8];
  if (ccn_n(v7, (uint64_t)a3)) {
    BOOL v12 = 0;
  }
  char v14 = v12 & (ccn_n(v7, v13) == 0);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  ccn_mux(v7, v14, a3, (uint64_t *)v10, a3);
  uint64_t result = ccn_mux(v7, v14, v9, (uint64_t *)v10, v9);
  *(void *)(a1 + 16) = v16;
  return result;
}

uint64_t ccec_map_to_homogeneous_ws(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = cczp_n(a2);
  uint64_t v5 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  cczp_mul_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  uint64_t result = cczp_mul_ws(a1, a2);
  *(void *)(a1 + 16) = v5;
  return result;
}

uint64_t ccec_full_add_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 88))();
}

uint64_t ccec_full_add(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v8 = cc_malloc_clear(120 * *a1);
  uint64_t v9 = 15 * *a1;
  v12[0] = v8;
  v12[1] = v9;
  uint64_t v12[2] = 0;
  v12[3] = cc_ws_alloc;
  uint64_t v13 = cc_ws_free;
  if (v8)
  {
    (*(void (**)(void *, void *, uint64_t, uint64_t, uint64_t))(a1[2] + 88))(v12, a1, a2, a3, a4);
    v13((uint64_t)v12);
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v10;
}

uint64_t ccaes_gladman_cbc_decrypt_init(uint64_t a1, int *a2, uint64_t a3, int *a4)
{
  if (a3 > 127)
  {
    if (a3 != 128 && a3 != 256 && a3 != 192) {
      return 4294967289;
    }
LABEL_8:
    uint64_t result = ccaes_gladman_decrypt_key(a4, a3, a2);
    a2[65] = 1;
    return result;
  }
  if ((unint64_t)a3 <= 0x20 && ((1 << a3) & 0x101010000) != 0) {
    goto LABEL_8;
  }
  return 4294967289;
}

unint64_t ccdh_gp_size(uint64_t a1)
{
  return ((4 * a1 + 28) & 0xFFFFFFFFFFFFFFE0) + 40;
}

uint64_t ccrc2_ltc_setup(uint64_t a1, int8x16_t *a2, unint64_t a3)
{
  uint64_t v18 = *MEMORY[0x263EF8C08];
  char v17 = 0;
  memset(v16, 0, sizeof(v16));
  if (a3 - 129 < 0xFFFFFFFFFFFFFF80) {
    return 4294967289;
  }
  __memcpy_chk();
  if (a3 > 0x7F)
  {
    unint64_t v7 = 0;
LABEL_9:
    char v9 = *((unsigned char *)v16 + v7);
    uint64_t v10 = 128;
    if (a3 > 0x80) {
      uint64_t v10 = a3;
    }
    do
    {
      char v9 = PITABLE[(*((unsigned char *)v16 + v10) ^ v9)];
      *((unsigned char *)v16 + v10-- - a3) = v9;
    }
    while (v10 - a3 < 0x80);
    goto LABEL_12;
  }
  uint64_t v6 = 0;
  unint64_t v7 = 128 - a3;
  char v8 = *((unsigned char *)v16 + a3 - 1);
  do
  {
    char v8 = PITABLE[(*((unsigned char *)v16 + v6) + v8)];
    *((unsigned char *)v16 + a3 + v6++) = v8;
  }
  while (a3 + v6 != 128);
  if (a3) {
    goto LABEL_9;
  }
LABEL_12:
  for (uint64_t i = 0; i != 8; i += 2)
  {
    BOOL v12 = (const char *)&v16[i];
    int8x16x2_t v19 = vld2q_s8(v12);
    uint16x8_t v13 = vmovl_u8(*(uint8x8_t *)v19.val[1].i8);
    uint16x8_t v14 = vmovl_high_u8((uint8x16_t)v19.val[1]);
    uint16x8_t v15 = vmovl_high_u8((uint8x16_t)v19.val[0]);
    v19.val[0] = (int8x16_t)vmovl_u8(*(uint8x8_t *)v19.val[0].i8);
    a2[2] = vorrq_s8((int8x16_t)vshll_n_u16(*(uint16x4_t *)v14.i8, 8uLL), (int8x16_t)vmovl_u16(*(uint16x4_t *)v15.i8));
    a2[3] = vorrq_s8((int8x16_t)vshll_high_n_u16(v14, 8uLL), (int8x16_t)vmovl_high_u16(v15));
    *a2 = vorrq_s8((int8x16_t)vshll_n_u16(*(uint16x4_t *)v13.i8, 8uLL), (int8x16_t)vmovl_u16(*(uint16x4_t *)v19.val[0].i8));
    a2[1] = vorrq_s8((int8x16_t)vshll_high_n_u16(v13, 8uLL), (int8x16_t)vmovl_high_u16((uint16x8_t)v19.val[0]));
    a2 += 4;
  }
  cc_clear(0x81uLL, v16);
  return 0;
}

uint64_t cczp_init_ws(uint64_t a1, void *a2)
{
  uint64_t v4 = (unsigned char *)cczp_prime((uint64_t)a2);
  unint64_t v5 = cczp_n((uint64_t)a2);
  if ((*v4 & 1) == 0 || ccn_n(v5, (uint64_t)v4) == 1 && *(void *)v4 < 3uLL) {
    return 4294967289;
  }
  a2[2] = cczp_default_funcs;
  unint64_t v7 = cczp_n((uint64_t)a2);
  char v8 = (unint64_t *)cczp_prime((uint64_t)a2);
  a2[1] = ccn_bitlen_public_value(v7, v8);
  uint64_t v9 = (2 - ((3 * *(void *)v4) ^ 2) * *(void *)v4) * ((3 * *(void *)v4) ^ 2);
  uint64_t v10 = (2 - (2 - v9 * *(void *)v4) * v9 * *(void *)v4) * (2 - v9 * *(void *)v4) * v9;
  a2[*a2 + 3] = (v10 * *(void *)v4 - 2) * v10;
  uint64_t v11 = cczp_n((uint64_t)a2);
  uint64_t v12 = *(void *)(a1 + 16);
  uint16x8_t v13 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 2 * v11);
  memset(&v13[v11], 255, 8 * v11);
  uint16x8_t v14 = (uint64_t *)cczp_prime((uint64_t)a2);
  ccn_neg(v11, v13, v14);
  uint16x8_t v15 = (char *)&a2[*a2 + 4];
  uint64_t v16 = (unint64_t *)cczp_prime((uint64_t)a2);
  ccn_divmod_ws(a1, 2 * v11, (uint64_t)v13, 0, 0, v11, v15, v16);
  uint64_t result = 0;
  *(void *)(a1 + 16) = v12;
  return result;
}

uint64_t cczp_init(void *a1)
{
  uint64_t v2 = cczp_n((uint64_t)a1);
  v5[0] = cc_malloc_clear(40 * v2 + 24);
  v5[1] = 5 * cczp_n((uint64_t)a1) + 3;
  v5[2] = 0;
  v5[3] = cc_ws_alloc;
  uint64_t v6 = cc_ws_free;
  if (!v5[0]) {
    return 4294967283;
  }
  uint64_t inited = cczp_init_ws((uint64_t)v5, a1);
  v6((uint64_t)v5);
  return inited;
}

int64x2_t *ccaes_xts_decrypt_mode()
{
  uint64_t v0 = ccaes_ecb_decrypt_mode();
  char v1 = ccaes_ecb_encrypt_mode();
  ccmode_factory_xts_decrypt(xts_decrypt, v0, (uint64_t)v1);
  return xts_decrypt;
}

uint64_t ccder_sizeof_implicit_integer(uint64_t a1, unint64_t a2, unint64_t *a3)
{
  unint64_t v4 = ccn_write_int_size_public_value(a2, a3);

  return ccder_sizeof(a1, v4);
}

size_t ccec_plprint(uint64_t *a1, const char *a2, uint64_t a3)
{
  unint64_t v5 = (FILE **)MEMORY[0x263EF8C10];
  fprintf((FILE *)*MEMORY[0x263EF8C10], "%s { x -> ", a2);
  ccn_print(*a1, a3);
  fwrite(", y -> ", 7uLL, 1uLL, *v5);
  ccn_print(*a1, a3 + 8 * *a1);
  fwrite(", z -> ", 7uLL, 1uLL, *v5);
  ccn_print(*a1, a3 + 16 * *a1);
  uint64_t v6 = *v5;

  return fwrite("}\n", 2uLL, 1uLL, v6);
}

uint64_t ccec_print_full_key(const char *a1, uint64_t **a2)
{
  BOOL v6 = timingsafe_enable_if_supported();
  unint64_t v4 = (FILE **)MEMORY[0x263EF8C10];
  fprintf((FILE *)*MEMORY[0x263EF8C10], "full key %s { \n", a1);
  ccec_plprint(*a2, "pubkey:", (uint64_t)(a2 + 2));
  fwrite("priv: {", 7uLL, 1uLL, *v4);
  ccn_print(**a2, (uint64_t)&a2[3 * **a2 + 2]);
  fwrite("}\n", 2uLL, 1uLL, *v4);
  return cc_disable_dit_with_sb((unsigned int *)&v6);
}

uint64_t ccec_print_public_key(const char *a1, uint64_t **a2)
{
  BOOL v5 = timingsafe_enable_if_supported();
  fwrite("public key ", 0xBuLL, 1uLL, (FILE *)*MEMORY[0x263EF8C10]);
  ccec_plprint(*a2, a1, (uint64_t)(a2 + 2));
  return cc_disable_dit_with_sb((unsigned int *)&v5);
}

uint64_t ccmode_cfb_init(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *__src)
{
  uint64_t v8 = *(void *)(a1 + 32);
  *a2 = v8;
  size_t v9 = *(void *)(v8 + 8);
  uint64_t v10 = (char *)a2 + ((v9 + 7) & 0xFFFFFFFFFFFFFFF8);
  if (__src) {
    memcpy(v10 + 16, __src, v9);
  }
  else {
    cc_clear(*(void *)(v8 + 8), v10 + 16);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t))(v8 + 16))(v8, (unint64_t)a2 + ((2 * *(void *)(*a2 + 8) + 14) & 0xFFFFFFFFFFFFFFF0) + 16, a3, a4);
  a2[1] = *(void *)(v8 + 8);
  return result;
}

uint64_t (**ccspake_mac_hkdf_cmac_aes128_sha256())()
{
  return ccspake_mac_hkdf_cmac_aes128_sha256_decl;
}

uint64_t ccspake_mac_hkdf_cmac_compute(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, char *a5, size_t a6, void *a7)
{
  uint64_t v7 = *(void *)(a1 + 8);
  if (*(void *)(v7 + 24) != a6) {
    return 4294967289;
  }
  uint16x8_t v14 = (void *)(*(uint64_t (**)(void))(v7 + 8))();

  return cccmac_one_shot_generate_internal(v14, a2, a3, a4, a5, a6, a7);
}

uint64_t ccz_mulmod(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  BOOL v9 = timingsafe_enable_if_supported();
  ccz_mul((uint64_t)a1, a2, a3);
  ccz_mod((uint64_t)a1, a1, a4);
  return cc_disable_dit_with_sb((unsigned int *)&v9);
}

BOOL ccoid_equal(uint64_t a1, uint64_t a2)
{
  BOOL v10 = timingsafe_enable_if_supported();
  if (a1 | a2)
  {
    BOOL v4 = 0;
    if (a1 && a2)
    {
      uint64_t v5 = *(unsigned __int8 *)(a1 + 1);
      if (v5 == *(unsigned __int8 *)(a2 + 1))
      {
        size_t v6 = v5 + 2;
        uint64_t v7 = (const void *)ccoid_payload(a1);
        uint64_t v8 = (const void *)ccoid_payload(a2);
        BOOL v4 = memcmp(v7, v8, v6) == 0;
      }
      else
      {
        BOOL v4 = 0;
      }
    }
  }
  else
  {
    BOOL v4 = 1;
  }
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v4;
}

uint64_t ccoid_size(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 1) + 2;
}

uint64_t ccec_generate_key_internal_fips_ws(uint64_t a1, unint64_t *a2, uint64_t (**a3)(void, uint64_t, unint64_t *), unint64_t **a4)
{
  unint64_t v8 = *a2;
  *a4 = a2;
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v8);
  uint64_t v11 = cczp_bitlen((uint64_t)a2);
  uint64_t result = (*a3)(a3, ((unint64_t)(v11 + 62) >> 3) & 0x1FFFFFFFFFFFFFF8, (unint64_t *)v10);
  if (!result)
  {
    uint64_t result = ccec_generate_scalar_fips_retry_ws(a1, a2, (uint64_t (**)(void, unint64_t, void *))a3, &a4[3 * **a4 + 2]);
    if (!result) {
      uint64_t result = ccec_make_pub_from_priv_ws(a1, a2, a3, (uint64_t)&a4[3 * **a4 + 2], 0, a4);
    }
  }
  *(void *)(a1 + 16) = v9;
  return result;
}

void *ccspake_cp_521()
{
  return &ccspake_cp521;
}

void *ccspake_cp_521_rfc()
{
  return &ccspake_cp521_rfc;
}

uint64_t ccpad_xts_encrypt(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v20 = *MEMORY[0x263EF8C08];
  BOOL v17 = timingsafe_enable_if_supported();
  uint64_t v12 = a4 & 0xF;
  if ((a4 & 0xF) != 0)
  {
    unint64_t v13 = a4 & 0xFFFFFFFFFFFFFFF0;
    (*(void (**)(uint64_t, uint64_t, unint64_t, uint64_t, uint64_t))(a1 + 48))(a2, a3, (a4 >> 4) - 1, a5, a6);
    (*(void (**)(uint64_t, uint64_t, uint64_t, unint64_t, unsigned char *))(a1 + 48))(a2, a3, 1, a5 + (a4 & 0xFFFFFFFFFFFFFFF0) - 16, v19);
    uint64_t v14 = 0;
    do
    {
      v18[v14] = *(unsigned char *)(a5 + v13 + v14);
      *(unsigned char *)(a6 + v13 + v14) = v19[v14];
      ++v14;
    }
    while (v12 != v14);
    uint64_t v15 = a6 + v13 - 16;
    if ((unint64_t)(v14 - 1) <= 0xE) {
      memcpy(&v18[v12], &v19[v12], 16 - v12);
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *, uint64_t))(a1 + 48))(a2, a3, 1, v18, v15);
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t, unint64_t, uint64_t, uint64_t))(a1 + 48))(a2, a3, a4 >> 4, a5, a6);
  }
  return cc_disable_dit_with_sb((unsigned int *)&v17);
}

uint64_t ccrsa_verify_pss_digest(unint64_t *a1, void *a2, uint64_t a3, size_t a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  BOOL v27 = timingsafe_enable_if_supported();
  unint64_t v15 = *a1;
  uint64_t v16 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v17 = sizeof_struct_ccpolyzp_po2cyc();
  v25[0] = cc_malloc_clear(8 * ((v16 + v17 - 1) / v17 + 13 * v15) + 8);
  unint64_t v18 = *a1;
  uint64_t v19 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v20 = sizeof_struct_ccpolyzp_po2cyc();
  v25[1] = (v19 + v20 - 1) / v20 + 13 * v18 + 1;
  v25[2] = 0;
  void v25[3] = cc_ws_alloc;
  unsigned int v26 = cc_ws_free;
  if (v25[0])
  {
    uint64_t v21 = ccrsa_verify_pss_digest_ws((uint64_t)v25, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    v26((uint64_t)v25);
  }
  else
  {
    uint64_t v21 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v27);
  return v21;
}

uint64_t ccrsa_verify_pss_digest_ws(uint64_t a1, unint64_t *a2, void *a3, uint64_t a4, size_t a5, char *a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  uint64_t v32 = *MEMORY[0x263EF8C08];
  if (a10)
  {
    *a10 = 0;
    a10[1] = 0;
  }
  long long v31 = 0uLL;
  uint64_t v18 = cczp_bitlen((uint64_t)a2);
  unint64_t v19 = v18 + 7;
  if (a7 != (unint64_t)(v18 + 7) >> 3) {
    return 4294967273;
  }
  uint64_t v20 = v18;
  uint64_t result = 4294967273;
  if (*a3 == a5)
  {
    uint64_t v29 = a4;
    uint64_t v22 = *a2;
    if (8 * *a2 - ((unint64_t)(v20 + 6) >> 3) <= 8)
    {
      if (v19 >= 8)
      {
        unint64_t v25 = 8 * *a2 - ((unint64_t)(v20 + 6) >> 3);
        unsigned int v26 = a6;
        uint64_t v23 = *(void *)(a1 + 16);
        uint64_t v28 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v22);
        BOOL v27 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v22);
        cc_clear(8 * (*(void *)(a1 + 16) - v23), (void *)(*(void *)a1 + 8 * v23));
        if (ccn_read_uint_internal(v22, v28, a7, a8))
        {
          unsigned int v30 = -23;
        }
        else
        {
          unsigned int v30 = ccrsa_pub_crypt_ws(a1, a2, v27, v28);
          if (!v30)
          {
            ccn_swap(v22, (unint64_t *)v27);
            int v24 = ccrsa_emsa_pss_decode_canary_out_ws(a1, (uint64_t)a3, v29, a9, a5, v26, v20 - 1, (unsigned __int8 *)v27 + v25, &v31);
            unsigned int v30 = v24 ^ 0x3A ^ BYTE8(v31) ^ BYTE4(v31) ^ BYTE3(v31) ^ BYTE13(v31) ^ HIBYTE(v31) ^ BYTE10(v31) ^ BYTE1(v31) ^ BYTE11(v31) ^ BYTE14(v31) ^ BYTE6(v31) ^ BYTE2(v31) ^ BYTE9(v31) ^ BYTE12(v31) ^ v31 ^ BYTE7(v31) ^ BYTE5(v31);
            if (a10) {
              *(_OWORD *)a10 = v31;
            }
          }
        }
        *(void *)(a1 + 16) = v23;
        return v30;
      }
      else
      {
        return 4294967268;
      }
    }
  }
  return result;
}

uint64_t ccrsa_verify_pss_msg_ws(uint64_t a1, unint64_t *a2, size_t *a3, uint64_t a4, size_t a5, char *a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  uint64_t v18 = *MEMORY[0x263EF8C08];
  ccdigest_internal((uint64_t)a3, a5, a6, (uint64_t)v17);
  return ccrsa_verify_pss_digest_ws(a1, a2, a3, a4, *a3, v17, a7, a8, a9, a10);
}

uint64_t ccrsa_verify_pss_msg(unint64_t *a1, size_t *a2, uint64_t a3, size_t a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  uint64_t v29 = *MEMORY[0x263EF8C08];
  BOOL v27 = timingsafe_enable_if_supported();
  unint64_t v15 = *a1;
  uint64_t v16 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v17 = sizeof_struct_ccpolyzp_po2cyc();
  v25[0] = cc_malloc_clear(8 * ((v16 + v17 - 1) / v17 + 13 * v15) + 8);
  unint64_t v18 = *a1;
  uint64_t v19 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v20 = sizeof_struct_ccpolyzp_po2cyc();
  v25[1] = (v19 + v20 - 1) / v20 + 13 * v18 + 1;
  v25[2] = 0;
  void v25[3] = cc_ws_alloc;
  unsigned int v26 = cc_ws_free;
  if (v25[0])
  {
    ccdigest_internal((uint64_t)a2, a4, a5, (uint64_t)v28);
    uint64_t v21 = ccrsa_verify_pss_digest_ws((uint64_t)v25, a1, a2, a3, *a2, v28, a6, a7, a8, a9);
    v26((uint64_t)v25);
  }
  else
  {
    uint64_t v21 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v27);
  return v21;
}

uint64_t ccmode_gcm_reset(uint64_t a1)
{
  *(_DWORD *)(a1 + 84) = 0;
  *(_WORD *)(a1 + 80) = 1;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  return 0;
}

uint64_t ccsrp_generate_k_ws(uint64_t a1, uint64_t a2, uint64_t a3)
{
  size_t v6 = (unint64_t *)ccdh_gp_prime(*(void *)(a2 + 8));
  uint64_t v7 = (unint64_t *)ccdh_gp_g(*(void **)(a2 + 8));
  int v8 = (*(_DWORD *)(a2 + 24) >> 9) & 1;

  return ccsrp_digest_ccn_ccn_ws(a1, (uint64_t *)a2, a3, v6, v7, 0, v8);
}

uint64_t ccsrp_generate_u_ws(uint64_t a1, uint64_t *a2, uint64_t a3, unint64_t *a4, unint64_t *a5)
{
  unsigned int v5 = *((_DWORD *)a2 + 6);
  if ((v5 & 0x1C0) != 0)
  {
    a4 = 0;
    rsize_t v6 = 4;
  }
  else
  {
    rsize_t v6 = *(void *)*a2;
  }
  return ccsrp_digest_ccn_ccn_ws(a1, a2, a3, a4, a5, v6, (v5 >> 9) & 1);
}

void *ccaes_cfb8_decrypt_mode()
{
  uint64_t v0 = ccaes_ecb_encrypt_mode();
  ccmode_factory_cfb8_decrypt(cfb8_aes_decrypt, v0);
  return cfb8_aes_decrypt;
}

uint64_t ccmode_xts_key_sched(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *(void *)(a1 + 56);
  uint64_t v9 = *(void *)(a1 + 64);
  *a2 = v8;
  a2[1] = v9;
  uint64_t v10 = a2 + 2;
  (*(void (**)(uint64_t, void *))(v8 + 16))(v8, a2 + 2);
  uint64_t v11 = *(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(v9 + 16);
  uint64_t v12 = (char *)v10 + ((*(void *)*a2 + 7) & 0xFFFFFFFFFFFFFFF8);

  return v11(v8, v12, a3, a5);
}

uint64_t ccmode_siv_hmac_auth_backend(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v9 = *MEMORY[0x263EF8C08];
  cchmac_update_internal(*(void *)(*(void *)a1 + 56), a1 + 96, a2, a3);
  v8[0] = HIBYTE(a2);
  v8[1] = BYTE6(a2);
  v8[2] = BYTE5(a2);
  v8[3] = BYTE4(a2);
  v8[4] = BYTE3(a2);
  v8[5] = BYTE2(a2);
  v8[6] = BYTE1(a2);
  v8[7] = a2;
  v8[8] = a4;
  return cchmac_update_internal(*(void *)(*(void *)a1 + 56), a1 + 96, 9, v8);
}

uint64_t ccmode_siv_hmac_auth(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3 != 4 && v3 != 2) {
    return 4294967228;
  }
  if (!a2) {
    return 4294967193;
  }
  ccmode_siv_hmac_auth_backend(a1, a2, a3, 65);
  uint64_t result = 0;
  *(void *)(a1 + 24) = 4;
  return result;
}

uint64_t ccmode_siv_hmac_auth_finalize(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v14 = *MEMORY[0x263EF8C08];
  unsigned int v5 = *(rsize_t **)(*a1 + 56);
  rsize_t v6 = *v5;
  unint64_t v7 = a1[3];
  if (v7 > 6 || ((1 << v7) & 0x54) == 0)
  {
    cc_clear(*v5, __src);
    a1[3] = 255;
    return 4294967228;
  }
  else
  {
    size_t v10 = a1[2];
    if (a2 || v7 != 2)
    {
      ccmode_siv_hmac_auth_backend((uint64_t)a1, a2, a3, 80);
      cchmac_final_internal(*(void *)(*a1 + 56), a1 + 12, (uint64_t)__src);
    }
    else
    {
      v13[0] = 67305985;
      cchmac_internal((uint64_t)v5, a1[1] >> 1, (uint64_t)(a1 + 4), 4, (uint64_t)v13, (uint64_t)__src);
    }
    memcpy(a4, __src, v10);
    a1[3] = 5;
    cc_clear(v6, __src);
    return 0;
  }
}

uint64_t ccmode_xts_set_tweak(uint64_t a1, void *a2, uint64_t a3)
{
  *a2 = 0;
  return (*(uint64_t (**)(unint64_t, uint64_t, uint64_t, void *))(*(void *)(a1 + 8) + 24))(a1 + ((**(void **)a1 + 7) & 0xFFFFFFFFFFFFFFF8) + 16, 1, a3, a2 + 1);
}

uint64_t cced448_add_points_unified_ws(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, char a6)
{
  uint64_t v12 = cczp_n(a2);
  uint64_t v13 = *(void *)(a1 + 16);
  ccn_set(4 * v12, a3, a5);
  cczp_n(a2);
  uint64_t v14 = *(void *)(a1 + 16);
  cczp_mul_ws(a1, a2);
  *(void *)(a1 + 16) = v14;
  uint64_t result = cced448_add_points_unified_cached_ws(a1, a2, (uint64_t)a3, a4, (uint64_t)a3, a6);
  *(void *)(a1 + 16) = v13;
  return result;
}

uint64_t cced448_add_points_unified_cached_ws(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  uint64_t v10 = cczp_n(a2);
  uint64_t v12 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10);
  cczp_mul_ws(a1, a2);
  if ((a6 & 2) != 0) {
    ccn_set(v10, (void *)(a3 + 24 * v10), (void *)(a4 + 24 * v10));
  }
  else {
    cczp_mul_ws(a1, a2);
  }
  cczp_mul_ws(a1, a2);
  cczp_add_ws(a1, a2);
  if (a6) {
    cczp_sub_ws(a1, a2);
  }
  else {
    cczp_add_ws(a1, a2);
  }
  cczp_mul_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  if (a6)
  {
    cczp_add_ws(a1, a2);
    cczp_sub_ws(a1, a2);
    cczp_add_ws(a1, a2);
    cczp_sub_ws(a1, a2);
    cczp_add_ws(a1, a2);
  }
  else
  {
    cczp_sub_ws(a1, a2);
    cczp_sub_ws(a1, a2);
    cczp_sub_ws(a1, a2);
    cczp_add_ws(a1, a2);
    cczp_sub_ws(a1, a2);
  }
  cczp_mul_ws(a1, a2);
  if ((a6 & 4) == 0) {
    cczp_mul_ws(a1, a2);
  }
  cczp_mul_ws(a1, a2);
  uint64_t result = cczp_mul_ws(a1, a2);
  *(void *)(a1 + 16) = v12;
  return result;
}

uint64_t cced448_scalar_mult_ws(uint64_t a1, void *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = cczp_n((uint64_t)a2);
  uint64_t v10 = (void *)(a6 + 16 * *a2);
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v11 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 4 * v9);
  uint64_t v12 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 4 * v9);
  cc_clear(8 * v9, v11);
  cc_clear(8 * v9, &v11[16 * v9]);
  ccn_set(v9, &v11[8 * v9], v10);
  ccn_set(v9, &v11[24 * v9], v10);
  cced25519_to_ed25519_point_ws(a1, (uint64_t)a2);
  if (a5)
  {
    char v13 = 0;
    unint64_t v14 = a5 - 1;
    do
    {
      unint64_t v24 = v14;
      uint64_t v22 = (*(void *)(a4 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v14) & 1;
      ccn_cond_swap(28, v22 ^ v13, (uint64_t *)v11, v12);
      uint64_t v15 = cczp_n((uint64_t)a2);
      uint64_t v21 = *(void *)(a1 + 16);
      (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v15);
      (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v15);
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      cczp_add_ws(a1, (uint64_t)a2);
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_add_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      cczp_add_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      cczp_add_ws(a1, (uint64_t)a2);
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_mul_ws(a1, (uint64_t)a2);
      *(void *)(a1 + 16) = v21;
      cced448_dbl_point_ws(a1, (uint64_t)a2);
      char v16 = v22;
      unint64_t v14 = v24 - 1;
      char v13 = v22;
    }
    while (v24);
  }
  else
  {
    char v16 = 0;
  }
  ccn_mux(28, v16, (uint64_t *)v11, v12, (uint64_t *)v11);
  cced25519_from_ed25519_point_ws(a1, a2, a3, v11);
  *(void *)(a1 + 16) = v18;
  return 0;
}

uint64_t cced448_dbl_point_ws(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = cczp_n(a2);
  uint64_t v6 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  cczp_sqr_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  cczp_add_ws(a1, a2);
  cczp_add_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  cczp_sub_ws(a1, a2);
  cczp_sub_ws(a1, a2);
  cczp_add_ws(a1, a2);
  cczp_sub_ws(a1, a2);
  cczp_sub_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  uint64_t result = cczp_mul_ws(a1, a2);
  *(void *)(a1 + 16) = v6;
  return result;
}

uint64_t cced448_scalar_mult_base_masked_ws(uint64_t a1, unint64_t *a2, uint64_t (**a3)(void, uint64_t, unint64_t *), uint64_t a4, uint64_t a5)
{
  uint64_t v10 = cczp_n((uint64_t)a2);
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 3 * v10);
  uint64_t result = ccec_projectify_ws(a1, (uint64_t)a2);
  if (!result) {
    uint64_t result = ccec_mult_blinded_ws(a1, a2, a4, a5, v12, a3);
  }
  *(void *)(a1 + 16) = v11;
  return result;
}

void *cced448_double_scalar_mult_ws(uint64_t a1, void *a2, char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v27 = *MEMORY[0x263EF8C08];
  uint64_t v7 = cczp_n((uint64_t)a2);
  uint64_t v23 = *(void *)(a1 + 16);
  uint64_t v8 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 4 * v7);
  uint64_t v9 = 32 * v7;
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 32 * v7);
  cced25519_to_ed25519_point_ws(a1, (uint64_t)a2);
  cczp_n((uint64_t)a2);
  uint64_t v11 = *(void *)(a1 + 16);
  cczp_mul_ws(a1, (uint64_t)a2);
  *(void *)(a1 + 16) = v11;
  cced448_dbl_point_ws(a1, (uint64_t)a2);
  uint64_t v12 = 7;
  uint64_t v13 = v10;
  do
  {
    uint64_t v14 = v13 + v9;
    cced448_add_points_unified_cached_ws(a1, (uint64_t)a2, v13 + v9, (uint64_t)v8, v13, 0);
    cczp_n((uint64_t)a2);
    uint64_t v15 = *(void *)(a1 + 16);
    cczp_mul_ws(a1, (uint64_t)a2);
    *(void *)(a1 + 16) = v15;
    uint64_t v13 = v14;
    --v12;
  }
  while (v12);
  cc_clear(8 * v7, v8);
  cc_clear(8 * v7, &v8[16 * v7]);
  ccn_seti(v7, &v8[8 * v7], 1);
  ccn_seti(v7, &v8[24 * v7], 1);
  ccn_recode_ssw(v7, a4, 4, (uint64_t)v26);
  ccn_recode_ssw(v7, a5, 4, (uint64_t)v25);
  uint64_t v16 = 447;
  do
  {
    int v17 = v26[v16];
    int v18 = v25[v16--];
  }
  while (!(v18 | v17));
  if (v16 != -2)
  {
    uint64_t v19 = v16 + 1;
    do
    {
      cced448_dbl_point_ws(a1, (uint64_t)a2);
      cced448_add_precomputed_point_ws(a1, (uint64_t)a2, (uint64_t)v8, (char)v25[v19], 4, v10, 0);
      cced448_add_precomputed_point_ws(a1, (uint64_t)a2, (uint64_t)v8, (char)v26[v19--], 3, (uint64_t)&CCED448_PRECOMPUTED_BASES, 6);
    }
    while (v19 != -1);
  }
  uint64_t result = cced25519_from_ed25519_point_ws(a1, a2, a3, v8);
  *(void *)(a1 + 16) = v23;
  return result;
}

uint64_t cced448_add_precomputed_point_ws(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t result = cczp_n(a2);
  if (a4 >= 0) {
    LOBYTE(v15) = a4;
  }
  else {
    int v15 = -a4;
  }
  if ((char)v15 >= 1)
  {
    return cced448_add_points_unified_cached_ws(a1, a2, a3, a3, a6 + 8 * (v15 >> 1) * a5 * result, a7 | ((a4 & 0x80) >> 7));
  }
  return result;
}

uint64_t ccder_blob_decode_bitstring(unsigned __int8 **a1, uint64_t a2, unint64_t *a3)
{
  uint64_t result = ccder_blob_decode_range(a1, 3, (unsigned __int8 **)a2);
  if (result)
  {
    *a3 = 0;
    uint64_t v6 = *(unsigned __int8 **)a2;
    uint64_t v7 = *(void *)(a2 + 8);
    if (v7 != *(void *)a2)
    {
      unint64_t v8 = 8 * (~(unint64_t)v6 + v7);
      unint64_t v9 = *v6;
      BOOL v10 = v8 >= v9;
      unint64_t v11 = v8 - v9;
      if (v10) {
        *a3 = v11;
      }
      *(void *)a2 = v6 + 1;
    }
  }
  return result;
}

uint64_t ccss_shamir_generate_random_poly_ws(uint64_t a1, uint64_t a2, uint64_t (**a3)(void, unint64_t, uint64_t))
{
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(_DWORD *)(a2 + 8))
  {
    unsigned int v7 = 0;
    while (1)
    {
      unint64_t v8 = *(void **)a2;
      unint64_t v9 = (uint64_t *)ccss_shamir_poly_coefficient(a2, v7);
      uint64_t result = cczp_generate_random_element_ws(a1, v8, a3, v9);
      if (result) {
        break;
      }
      ++v7;
      unsigned int v11 = *(_DWORD *)(a2 + 8);
      if (v7 >= v11) {
        goto LABEL_7;
      }
    }
  }
  else
  {
    unsigned int v11 = 0;
LABEL_7:
    uint64_t v12 = *(void *)a2;
    uint64_t v13 = (char *)ccss_shamir_poly_coefficient(a2, v11);
    uint64_t result = cczp_generate_non_zero_element_ws(a1, v12, a3, v13);
  }
  *(void *)(a1 + 16) = v6;
  return result;
}

void *ccsha512_di()
{
  return &ccsha512_ltc_di;
}

void *ccn_set(uint64_t a1, void *__dst, void *__src)
{
  return memmove(__dst, __src, 8 * a1);
}

uint64_t ccdh_generate_key(void *a1, uint64_t (**a2)(void, uint64_t, uint64_t *), void *a3)
{
  BOOL v26 = timingsafe_enable_if_supported();
  uint64_t v6 = ccdh_gp_n(a1);
  uint64_t v7 = sizeof_struct_cche_galois_key();
  unint64_t v8 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v9 = (v7 + v8 - 1) / v8;
  uint64_t v10 = CCDH_POWER_BLINDED_WORKSPACE_N(v6);
  v22[0] = cc_malloc_clear(8 * (v9 + 6 * v6 + v10));
  uint64_t v11 = ccdh_gp_n(a1);
  uint64_t v12 = sizeof_struct_cche_galois_key();
  unint64_t v13 = sizeof_struct_ccpolyzp_po2cyc();
  v22[1] = (v12 + v13 - 1) / v13 + 6 * v11 + CCDH_POWER_BLINDED_WORKSPACE_N(v11);
  uint64_t v23 = 0;
  unint64_t v24 = cc_ws_alloc;
  unint64_t v25 = cc_ws_free;
  if (v22[0])
  {
    uint64_t v14 = (void *)ccdh_ctx_public(a3);
    ccdh_ctx_init((uint64_t)a1, v14);
    int v15 = (unint64_t *)ccdh_gp_g(a1);
    uint64_t v16 = &a3[ccdh_gp_n(*a3) + 2];
    private_uint64_t key_ws = ccdh_generate_private_key_ws((uint64_t)v22, a1, v16, (uint64_t (**)(void, unint64_t, uint64_t))a2);
    if (private_key_ws
      || (unint64_t private_key_bitlen = ccdh_generate_private_key_bitlen(a1),
          private_uint64_t key_ws = cczp_mm_power_ws((uint64_t)v22, a1, a3 + 2, v15, private_key_bitlen, v16),
          private_key_ws)
      || (uint64_t v19 = (void *)ccdh_ctx_public(a3),
          private_uint64_t key_ws = ccdh_check_pub_ws((uint64_t)v22, a1, v19),
          private_key_ws))
    {
      uint64_t v20 = private_key_ws;
    }
    else if (ccdh_pairwise_consistency_check_ws((uint64_t)v22, a1, a2, a3))
    {
      uint64_t v20 = 0;
    }
    else
    {
      uint64_t v20 = 4294967242;
    }
    uint64_t v23 = 0;
    v25((uint64_t)v22);
  }
  else
  {
    uint64_t v20 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v26);
  return v20;
}

void *ccaes_cbc_encrypt_mode()
{
  return &ccaes_gladman_cbc_encrypt_mode;
}

uint64_t ccec_diversify_twin_scalars_ws(uint64_t a1, void *a2, char *a3, char *a4, unint64_t a5, uint64_t a6)
{
  uint64_t v12 = ccec_diversify_min_entropy_len(a2);
  uint64_t result = 4294967289;
  if ((a5 & 1) == 0 && 2 * v12 <= a5)
  {
    unint64_t v14 = a5 >> 1;
    uint64_t result = ccec_generate_scalar_fips_extrabits_ws(a1, a2, v14, a6, a3);
    if (!result)
    {
      return ccec_generate_scalar_fips_extrabits_ws(a1, a2, v14, a6 + v14, a4);
    }
  }
  return result;
}

void *ccec_cp_x448_opt()
{
  return &ccec_x448_opt_params;
}

BOOL ccrsa_export_pub(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return ccder_encode_rsa_pub(a1, a3, a3 + a2) != a3;
}

uint64_t ccapsic_server_encode_element_ws(uint64_t a1, unint64_t **a2, void **a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = **a2;
  uint64_t result = cch2c_ws(a1, (uint64_t)a2[2], (uint64_t)a2[3]);
  if (!result)
  {
    uint64_t result = ccec_projectify_ws(a1, (uint64_t)v6);
    if (!result)
    {
      uint64_t result = ccec_mult_blinded_ws(a1, v6, (uint64_t)(a3 + 2), (uint64_t)&(&a2[12 * **a2 + 24])[2 * **a2], (uint64_t)&(&a2[6 * v7 + 24])[2 * v7], (uint64_t (**)(void, uint64_t, unint64_t *))a2[1]);
      if (!result)
      {
        uint64_t result = ccec_affinify_ws(a1, (uint64_t)v6);
        if (!result)
        {
          ccn_seti(*v6, &a3[2 * **a3 + 2], 1);
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t ccapsic_server_encode_element(unint64_t **a1, void **a2)
{
  BOOL v15 = timingsafe_enable_if_supported();
  uint64_t v4 = *a1;
  unint64_t v5 = **a1;
  uint64_t v6 = sizeof_struct_cche_galois_key();
  unint64_t v7 = sizeof_struct_ccpolyzp_po2cyc();
  v13[0] = cc_malloc_clear(144 * v5 + 16 * ((v6 + v7 + 3 * v5 * v7 - 1) / v7 + v5));
  unint64_t v8 = *v4;
  uint64_t v9 = sizeof_struct_cche_galois_key();
  unint64_t v10 = sizeof_struct_ccpolyzp_po2cyc();
  v13[1] = 18 * v8 + 2 * ((v9 + v10 + 3 * v8 * v10 - 1) / v10 + v8);
  _OWORD v13[2] = 0;
  int v13[3] = cc_ws_alloc;
  unint64_t v14 = cc_ws_free;
  if (v13[0])
  {
    uint64_t v11 = ccapsic_server_encode_element_ws((uint64_t)v13, a1, a2);
    v14((uint64_t)v13);
  }
  else
  {
    uint64_t v11 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v11;
}

uint64_t cchmac_final_internal(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = a2 + 1;
  (*(void (**)(void))(a1 + 56))();
  size_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(void *)(a1 + 16);
  *(_DWORD *)((char *)a2 + v7 + v8 + 8) = *(void *)a1;
  *a2 = 8 * v8;
  memcpy(v6, (char *)a2 + ((v7 + v8 + 19) & 0xFFFFFFFFFFFFFFF8), v7);
  uint64_t v9 = *(uint64_t (**)(uint64_t, void *, uint64_t))(a1 + 56);

  return v9(a1, a2, a3);
}

uint64_t cchmac_final(uint64_t a1, void *a2, uint64_t a3)
{
  BOOL v7 = timingsafe_enable_if_supported();
  cchmac_final_internal(a1, a2, a3);
  return cc_disable_dit_with_sb((unsigned int *)&v7);
}

BOOL ccz_is_one(uint64_t a1)
{
  BOOL v5 = timingsafe_enable_if_supported();
  unint64_t v2 = ccz_n(a1);
  BOOL v3 = 0;
  if (ccn_n(v2, *(void *)(a1 + 24)) == 1) {
    BOOL v3 = **(void **)(a1 + 24) == 1;
  }
  cc_disable_dit_with_sb((unsigned int *)&v5);
  return v3;
}

uint64_t ccmode_cfb_decrypt(void *a1, uint64_t a2, char *a3, unsigned char *a4)
{
  uint64_t v5 = a1[1];
  if (a2)
  {
    uint64_t v8 = a2;
    uint64_t v9 = *a1;
    unint64_t v10 = (unint64_t)(*(void *)(*a1 + 8) + 7) >> 3;
    uint64_t v11 = a1 + 2;
    uint64_t v12 = (uint64_t)&a1[2 * v10 + 2];
    uint64_t v13 = (uint64_t)&a1[v10 + 2];
    do
    {
      if (v5 == *(void *)(v9 + 8))
      {
        (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(v9 + 24))(v12, 1, v13, a1 + 2);
        uint64_t v5 = 0;
      }
      *(unsigned char *)(v13 + v5) = *a3;
      char v14 = *a3++;
      uint64_t v15 = v5 + 1;
      *a4++ = *((unsigned char *)v11 + v5++) ^ v14;
      --v8;
    }
    while (v8);
  }
  else
  {
    uint64_t v15 = a1[1];
  }
  a1[1] = v15;
  return 0;
}

uint64_t cccurve25519_internal(uint64_t a1, char *a2, long long *a3, uint64_t *a4, uint64_t (**a5)(void, uint64_t, void *))
{
  uint64_t v50 = *MEMORY[0x263EF8C08];
  unint64_t v42 = cc_malloc_clear(0x200uLL);
  long long v43 = xmmword_2373B4870;
  unint64_t v44 = (uint64_t (*)(void **, uint64_t))cc_ws_alloc;
  uint64_t v45 = cc_ws_free;
  if (!v42) {
    return 4294967283;
  }
  uint64_t v10 = cczp_n(a1);
  uint64_t v11 = (void *)cc_ws_alloc(&v42, v10);
  uint64_t v12 = v44(&v42, v10);
  unint64_t __dst = (char *)v44(&v42, v10);
  unsigned int v41 = (void *)v44(&v42, v10);
  uint64_t v13 = v44(&v42, v10);
  char v14 = (uint64_t *)v44(&v42, v10);
  uint64_t v15 = (*a5)(a5, 32, v11);
  if (v15 || (v39 = (void *)v12, uint64_t v15 = (*a5)(a5, 32, (void *)v12), v15))
  {
    uint64_t v32 = v15;
  }
  else
  {
    unint64_t v36 = (uint64_t *)v13;
    size_t v38 = a2;
    uint64_t v46 = 0;
    (*a5)(a5, 8, &v46);
    ccn_mux_seed_mask(v46);
    long long v16 = a3[1];
    long long __src = *a3;
    long long v49 = v16;
    LOBYTE(__src) = __src & 0xF8;
    HIBYTE(v49) = HIBYTE(v16) & 0x3F | 0x40;
    if (v10)
    {
      memcpy(__dst, &__src, 8 * v10);
      int v17 = v41;
      uint64_t v18 = v10;
      do
      {
        uint64_t v19 = *a4++;
        *v17++ = v19;
        --v18;
      }
      while (v18);
    }
    uint64_t v37 = v10;
    ccn_set_bit((uint64_t)v41, 0xFFuLL, 0);
    cczp_to_ws((uint64_t)&v42, a1);
    cczp_mul_ws((uint64_t)&v42, a1);
    uint64_t v20 = cczp_n(a1);
    uint64_t v35 = *((void *)&v43 + 1);
    uint64_t v21 = (char *)v44(&v42, 2 * v20);
    uint64_t v22 = &v21[8 * v20];
    uint64_t v23 = (char *)v44(&v42, 2 * v20);
    unint64_t v24 = &v23[8 * v20];
    v44(&v42, v20);
    unint64_t v25 = (unint64_t *)v44(&v42, v20);
    cc_clear(8 * v20, v24);
    ccn_set(v20, v22, v11);
    ccn_set(v20, v21, v41);
    rsize_t __n = v20;
    ccn_set(v20, v23, v39);
    char v26 = 0;
    for (unint64_t i = 254; i != -1; --i)
    {
      char v28 = v26;
      char v26 = (*(void *)&__dst[(i >> 3) & 0x1FFFFFFFFFFFFFF8] >> i) & 1;
      ccn_cond_swap(8, v26 ^ v28, (uint64_t *)v21, (uint64_t *)v23);
      cczp_sub_ws((uint64_t)&v42, a1);
      cczp_sub_ws((uint64_t)&v42, a1);
      cczp_add_ws((uint64_t)&v42, a1);
      cczp_add_ws((uint64_t)&v42, a1);
      cczp_mul_ws((uint64_t)&v42, a1);
      cczp_mul_ws((uint64_t)&v42, a1);
      cczp_sqr_ws((uint64_t)&v42, a1);
      cczp_sqr_ws((uint64_t)&v42, a1);
      cczp_add_ws((uint64_t)&v42, a1);
      cczp_sub_ws((uint64_t)&v42, a1);
      cczp_mul_ws((uint64_t)&v42, a1);
      cczp_sub_ws((uint64_t)&v42, a1);
      cczp_sqr_ws((uint64_t)&v42, a1);
      ccec25519_mul121666_ws((uint64_t)&v42, a1, v22, v25);
      cczp_sqr_ws((uint64_t)&v42, a1);
      cczp_mul_ws((uint64_t)&v42, a1);
      cczp_add_ws((uint64_t)&v42, a1);
      cczp_mul_ws((uint64_t)&v42, a1);
      cczp_mul_ws((uint64_t)&v42, a1);
    }
    ccn_mux(__n, v26, v36, (uint64_t *)v21, (uint64_t *)v23);
    ccn_mux(__n, v26, v14, (uint64_t *)v22, (uint64_t *)v24);
    *((void *)&v43 + 1) = v35;
    cczp_inv_ws((uint64_t)&v42, a1);
    cczp_mul_ws((uint64_t)&v42, a1);
    cczp_from_ws((uint64_t)&v42, a1);
    uint64_t v29 = v37;
    if (v37)
    {
      unsigned int v30 = v38 + 3;
      do
      {
        uint64_t v31 = *v14++;
        *(void *)(v30 - 3) = v31;
        v30 += 8;
        --v29;
      }
      while (v29);
    }
    memset(v47, 0, sizeof(v47));
    if (cc_cmp_safe_internal(32, v38, (char *)v47)) {
      uint64_t v32 = 0;
    }
    else {
      uint64_t v32 = 4294967289;
    }
  }
  *((void *)&v43 + 1) = 0;
  v45((uint64_t)&v42);
  return v32;
}

uint64_t cccurve25519_with_rng(uint64_t (**a1)(void, uint64_t, void *), char *a2, long long *a3, uint64_t *a4)
{
  BOOL v11 = timingsafe_enable_if_supported();
  uint64_t v8 = ccec_cp_x25519();
  uint64_t v9 = cccurve25519_internal(v8, a2, a3, a4, a1);
  cc_disable_dit_with_sb((unsigned int *)&v11);
  return v9;
}

uint64_t cccurve25519_assumes_dit_internal(char *a1, long long *a2, uint64_t *a3)
{
  uint64_t v6 = ccrng(0);
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  BOOL v7 = v6;
  uint64_t v8 = ccec_cp_x25519();

  return cccurve25519_internal(v8, a1, a2, a3, (uint64_t (**)(void, uint64_t, void *))v7);
}

uint64_t cccurve25519(char *a1, long long *a2, uint64_t *a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t v6 = cccurve25519_assumes_dit_internal(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return v6;
}

uint64_t cccurve25519_make_priv(uint64_t (**a1)(void, uint64_t, unsigned char *), unsigned char *a2)
{
  BOOL v6 = timingsafe_enable_if_supported();
  uint64_t v4 = (*a1)(a1, 32, a2);
  if (!v4)
  {
    *a2 &= 0xF8u;
    a2[31] = a2[31] & 0x3F | 0x40;
  }
  cc_disable_dit_with_sb((unsigned int *)&v6);
  return v4;
}

uint64_t cccurve25519_make_pub_with_rng(uint64_t (**a1)(void, uint64_t, void *), char *a2, long long *a3)
{
  BOOL v9 = timingsafe_enable_if_supported();
  uint64_t v6 = ccec_cp_x25519();
  uint64_t v7 = cccurve25519_internal(v6, a2, a3, kX25519BasePoint, a1);
  cc_disable_dit_with_sb((unsigned int *)&v9);
  return v7;
}

uint64_t cccurve25519_make_pub_internal(char *a1, long long *a2)
{
  uint64_t v4 = ccrng(0);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = v4;
  uint64_t v6 = ccec_cp_x25519();

  return cccurve25519_internal(v6, a1, a2, kX25519BasePoint, (uint64_t (**)(void, uint64_t, void *))v5);
}

uint64_t cccurve25519_make_pub(char *a1, long long *a2)
{
  BOOL v6 = timingsafe_enable_if_supported();
  pub_uint64_t internal = cccurve25519_make_pub_internal(a1, a2);
  cc_disable_dit_with_sb((unsigned int *)&v6);
  return pub_internal;
}

uint64_t cccurve25519_make_key_pair_internal(uint64_t (**a1)(void, uint64_t, void *), char *a2, uint64_t a3)
{
  uint64_t result = ((uint64_t (*)(uint64_t (**)(void, uint64_t, void *), uint64_t))*a1)(a1, 32);
  if (!result)
  {
    *(unsigned char *)a3 &= 0xF8u;
    *(unsigned char *)(a3 + 31) = *(unsigned char *)(a3 + 31) & 0x3F | 0x40;
    uint64_t v7 = ccec_cp_x25519();
    return cccurve25519_internal(v7, a2, (long long *)a3, kX25519BasePoint, a1);
  }
  return result;
}

uint64_t cccurve25519_make_key_pair(uint64_t (**a1)(void, uint64_t, void *), char *a2, uint64_t a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  key_pair_uint64_t internal = cccurve25519_make_key_pair_internal(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return key_pair_internal;
}

uint64_t ccdh_export_pub(void *a1, char *a2)
{
  BOOL v7 = timingsafe_enable_if_supported();
  unint64_t v4 = ccdh_export_pub_size((void **)a1);
  unint64_t v5 = ccdh_gp_n(*a1);
  ccn_write_uint_padded_ct_internal(v5, a1 + 2, v4, a2);
  return cc_disable_dit_with_sb((unsigned int *)&v7);
}

uint64_t CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(unint64_t a1)
{
  uint64_t v2 = (a1 >> 1) + 2;
  unint64_t v3 = 5 * v2 + 3;
  uint64_t v4 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v5 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v6 = 2 * v2;
  unint64_t v7 = (v4 + v5 - 1) / v5 + 12 * v2 + 1;
  unint64_t v8 = 2 * a1;
  unint64_t v9 = 4 * v2;
  if (2 * a1 <= 4 * v2) {
    unint64_t v10 = 4 * v2;
  }
  else {
    unint64_t v10 = 2 * a1;
  }
  if (v10 <= 2 * v2) {
    unint64_t v10 = 2 * v2;
  }
  if (v3 <= v7) {
    uint64_t v11 = (v4 + v5 - 1) / v5 + 12 * v2 + 1;
  }
  else {
    uint64_t v11 = 5 * v2 + 3;
  }
  if (v8 <= v9) {
    unint64_t v12 = 4 * v2;
  }
  else {
    unint64_t v12 = 2 * a1;
  }
  if (v6 > v12) {
    unint64_t v12 = 2 * v2;
  }
  if (v6 <= v9) {
    uint64_t v13 = 4 * v2;
  }
  else {
    uint64_t v13 = 2 * v2;
  }
  if (v6 <= v8) {
    unint64_t v6 = 2 * a1;
  }
  if (v8 <= v9) {
    unint64_t v6 = v13;
  }
  if (v3 <= v12) {
    uint64_t v14 = (v4 + v5 - 1) / v5 + 12 * v2 + 1;
  }
  else {
    uint64_t v14 = 5 * v2 + 3;
  }
  if (v3 > v12) {
    unint64_t v6 = v14;
  }
  if (v7 <= v10) {
    unint64_t v15 = v6;
  }
  else {
    unint64_t v15 = v11;
  }
  return v15 - v2 + 8 * v2 + 11;
}

uint64_t ccrsa_priv_crypt_blinded_ws(uint64_t a1, uint64_t (**a2)(void, uint64_t, uint64_t), uint64_t *a3, uint64_t *a4, void *a5)
{
  uint64_t v10 = *a3;
  uint64_t v11 = ccrsa_ctx_private_zp(a3);
  uint64_t v12 = cczp_n(v11);
  uint64_t v13 = ccrsa_ctx_private_zp(a3);
  uint64_t v14 = (void *)ccrsa_ctx_private_zp(a3);
  uint64_t v15 = cczp_n(v13 + 16 * *v14 + 32);
  uint64_t v16 = ccrsa_ctx_private_zp(a3);
  uint64_t v17 = v16 + 16 * *(void *)ccrsa_ctx_private_zp(a3);
  uint64_t v18 = (void *)ccrsa_ctx_private_zp(a3);
  if ((unint64_t)ccn_bitlen_internal(v12, v17 + 16 * *v18 + 64) < 2) {
    return 4294967268;
  }
  uint64_t v19 = ccrsa_ctx_private_zp(a3);
  uint64_t v20 = v19 + 16 * *(void *)ccrsa_ctx_private_zp(a3);
  uint64_t v21 = v20 + 16 * *(void *)ccrsa_ctx_private_zp(a3);
  uint64_t v22 = (void *)ccrsa_ctx_private_zp(a3);
  if ((unint64_t)ccn_bitlen_internal(v15, v21 + 8 * *v22 + 64) < 2) {
    return 4294967268;
  }
  uint64_t v23 = a3 + 3;
  if ((unint64_t)ccn_bitlen_internal(v10, &a3[2 * *a3 + 4]) < 2) {
    return 4294967268;
  }
  if ((ccn_cmp_internal(v10, a5, a3 + 3) & 0x80000000) == 0) {
    return 4294967273;
  }
  uint64_t v73 = a4;
  uint64_t v71 = *(void *)(a1 + 16);
  uint64_t v69 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10);
  uint64_t v70 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10);
  ccn_set(v10, v70, a5);
  uint64_t v78 = ccrsa_ctx_private_zp(a3);
  uint64_t v26 = ccrsa_ctx_private_zp(a3);
  uint64_t v81 = v26 + 16 * *(void *)ccrsa_ctx_private_zp(a3) + 32;
  uint64_t v61 = ccrsa_ctx_private_zp(a3);
  uint64_t v60 = *(void *)ccrsa_ctx_private_zp(a3);
  uint64_t v59 = *(void *)ccrsa_ctx_private_zp(a3);
  uint64_t v66 = ccrsa_ctx_private_zp(a3);
  uint64_t v65 = *(void *)ccrsa_ctx_private_zp(a3);
  uint64_t v64 = *(void *)ccrsa_ctx_private_zp(a3);
  uint64_t v63 = *(void *)ccrsa_ctx_private_zp(a3);
  uint64_t v58 = ccrsa_ctx_private_zp(a3);
  uint64_t v57 = *(void *)ccrsa_ctx_private_zp(a3);
  uint64_t v56 = *(void *)ccrsa_ctx_private_zp(a3);
  uint64_t v55 = *(void *)ccrsa_ctx_private_zp(a3);
  uint64_t v54 = *(void *)ccrsa_ctx_private_zp(a3);
  unint64_t v79 = cczp_n(v81);
  unint64_t v27 = cczp_n(v78);
  uint64_t v68 = *(void *)(a1 + 16);
  uint64_t v28 = 2 * (v27 + 1);
  uint64_t v29 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v28);
  uint64_t v75 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v27 + 1);
  uint64_t v80 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v27 + 1);
  unint64_t v72 = v27 + 1;
  BOOL v74 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v27 + 1);
  uint64_t v76 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 7);
  uint64_t v62 = v28;
  uint64_t v82 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v28 + 4);
  unint64_t v30 = cczp_bitlen(v78);
  int v31 = -28;
  if (v30 >= cczp_bitlen(v81) && v27 >= v79)
  {
    int v32 = (*a2)(a2, 56, v76);
    if (v32
      || (ccn_mux_seed_mask(*(void *)(v76 + 48)),
          *uint64_t v82 = v79 + 1,
          int v33 = (unint64_t *)cczp_prime(v81),
          v82[v79 + 3] = ccn_mul1(v79, v82 + 3, v33, *(void *)v76 & 0xFFFFFFFELL | 1),
          (int v32 = cczp_init_ws(a1, v82)) != 0))
    {
      int v31 = v32;
      uint64_t v23 = a3 + 3;
    }
    else
    {
      uint64_t v34 = cczp_n((uint64_t)a3);
      uint64_t v35 = (void *)cczp_prime(v81);
      if (v79) {
        ccn_set(v79, v29, v35);
      }
      ccn_zero(v34 - v79 + 1, &v29[v79]);
      ccn_set_bit((uint64_t)v29, 0, 0);
      ccn_set(v79, v75, (void *)(v66 + 16 * v65 + 16 * v64 + 8 * v63 + 64));
      int v67 = &v75[v79];
      *int v67 = ccn_addmul1(v79, v75, v29, *(unsigned int *)(v76 + 8));
      unint64_t v36 = (unint64_t *)cczp_prime(v81);
      v29[v79] = ccn_mul1(v79, v29, v36, *(unsigned int *)(v76 + 16));
      uint64_t v37 = cczp_n((uint64_t)a3) + 1;
      uint64_t v38 = cczp_n((uint64_t)a3);
      ccn_addn(v37, v29, v29, v38, (uint64_t *)a5);
      uint64_t v39 = cczp_n((uint64_t)a3);
      cczp_modn_ws(a1, v82, v29, v39 + 1, (char *)v29);
      uint64_t v40 = cczp_bitlen(v81);
      cczp_mm_power_ws(a1, v82, v74, v29, v40 + 32, v75);
      *uint64_t v82 = v72;
      unsigned int v41 = (unint64_t *)cczp_prime(v78);
      v82[v27 + 3] = ccn_mul1(v27, v82 + 3, v41, *(void *)(v76 + 24) & 0xFFFFFFFELL | 1);
      int inited = cczp_init_ws(a1, v82);
      if (inited)
      {
        int v31 = inited;
        uint64_t v23 = a3 + 3;
      }
      else
      {
        uint64_t v43 = cczp_n((uint64_t)a3);
        unint64_t v44 = (void *)cczp_prime(v78);
        uint64_t v23 = a3 + 3;
        if (v27) {
          ccn_set(v27, v29, v44);
        }
        ccn_zero(v43 - v27 + 1, &v29[v27]);
        ccn_set_bit((uint64_t)v29, 0, 0);
        ccn_set(v27, v75, (void *)(v61 + 16 * v60 + 16 * v59 + 64));
        v75[v27] = ccn_addmul1(v27, v75, v29, *(unsigned int *)(v76 + 32));
        uint64_t v45 = (unint64_t *)cczp_prime(v78);
        uint64_t v46 = ccn_mul1(v27, v29, v45, *(unsigned int *)(v76 + 40));
        uint64_t v77 = &v29[v27];
        *uint64_t v77 = v46;
        uint64_t v47 = cczp_n((uint64_t)a3) + 1;
        uint64_t v48 = cczp_n((uint64_t)a3);
        ccn_addn(v47, v29, v29, v48, (uint64_t *)a5);
        uint64_t v49 = cczp_n((uint64_t)a3);
        cczp_modn_ws(a1, v82, v29, v49 + 1, (char *)v29);
        uint64_t v50 = cczp_bitlen(v78);
        cczp_mm_power_ws(a1, v82, v80, v29, v50 + 32, v75);
        uint64_t v51 = (void *)cczp_prime((uint64_t)v82);
        if (v27 != -1) {
          ccn_set(v72, v29, v51);
        }
        ccn_zero(2, &v29[v72]);
        ccn_shift_left_multi(v27 + 3, v29, v29, 0x21uLL);
        ccn_addn(v27 + 3, v29, v29, v72, v80);
        ccn_subn(v27 + 3, v29, v29, v79 + 1, (unint64_t *)v74);
        cczp_modn_ws(a1, v82, v80, v27 + 3, (char *)v29);
        if (v27) {
          ccn_set(v27, v29, (void *)(v58 + 16 * v57 + 16 * v56 + 8 * v55 + 8 * v54 + 64));
        }
        ccn_zero(1, v77);
        cczp_mul_ws(a1, (uint64_t)v82);
        uint64_t v52 = (void *)cczp_prime(v81);
        if (v79) {
          ccn_set(v79, v75, v52);
        }
        ccn_zero(v72 - v79, v67);
        ccn_mul_ws(a1, v72, (char *)v29, v75, (unint64_t *)v80);
        ccn_addn(v62, v29, v29, v79 + 1, v74);
        cczp_modn_ws(a1, a3, v73, v62, (char *)v29);
        int v31 = 0;
      }
    }
  }
  *(void *)(a1 + 16) = v68;
  cczp_mm_power_fast_ws(a1, a3, v69, (unint64_t *)v73, (uint64_t)&v23[2 * *a3 + 1]);
  unsigned int v53 = ccn_cmp_internal(v10, v69, v70);
  unint64_t v24 = ((((v31 | ((unint64_t)v31 >> 32)) + 0xFFFFFFFF) >> 32) - 1) & 0xFFFFFFE5 & -(((v53 | ((unint64_t)(int)v53 >> 32)) + 0xFFFFFFFF) >> 32) | v31;
  memset(v70, 170, 8 * v10);
  ccn_mux(v10, ((v24 | ((unint64_t)(int)v24 >> 32)) + 0xFFFFFFFF) >> 32, v73, (uint64_t *)v70, v73);
  *(void *)(a1 + 16) = v71;
  return v24;
}

void *ccdes3_ecb_encrypt_mode()
{
  return &ccdes3_ltc_ecb_encrypt_mode;
}

uint64_t ccapsic_server_determine_intersection(unint64_t **a1, unsigned char *a2, void **a3, void **a4)
{
  BOOL v25 = timingsafe_enable_if_supported();
  unint64_t v7 = *a1;
  unint64_t v8 = **a1;
  unint64_t v9 = sizeof_struct_ccpolyzp_po2cyc();
  uint64_t v10 = 5 * v8 + 3;
  unint64_t v11 = v10 + (v9 + 7) / v9;
  unint64_t v12 = 23 * v8;
  unint64_t v13 = 11 * v8;
  if (v11 <= 23 * v8)
  {
    unint64_t v11 = 23 * v8;
    if (v12 > v13) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  if (v11 <= v13) {
LABEL_5:
  }
    unint64_t v11 = 11 * v8;
LABEL_6:
  uint64_t v14 = cc_malloc_clear(8 * v11);
  v23[0] = v14;
  unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v16 = (v15 + 7) / v15 + v10;
  if (v16 <= v12)
  {
    if (v12 > v13) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  unint64_t v12 = (v15 + 7) / v15 + v10;
  if (v16 <= v13) {
LABEL_10:
  }
    unint64_t v12 = 11 * v8;
LABEL_11:
  v23[1] = v12;
  v23[2] = 0;
  v23[3] = cc_ws_alloc;
  unint64_t v24 = cc_ws_free;
  if (v14)
  {
    if (ccec_projectify_ws((uint64_t)v23, (uint64_t)v7)
      || ccec_mult_blinded_ws((uint64_t)v23, v7, (uint64_t)(a3 + 2), (uint64_t)&(&a1[12 * **a1 + 24])[2 * **a1], (uint64_t)&(&a1[6 * v8 + 24])[2 * v8], (uint64_t (**)(void, uint64_t, unint64_t *))a1[1]))
    {
      uint64_t v20 = 0;
    }
    else
    {
      uint64_t v17 = ccec_affinify_ws((uint64_t)v23, (uint64_t)v7);
      if (v17)
      {
        uint64_t v20 = v17;
      }
      else
      {
        unsigned int v18 = ccn_cmp_internal(v8, a3 + 2, a4 + 2);
        int v19 = ccn_cmp_internal(v8, &a3[**a3 + 2], &a4[**a4 + 2]);
        uint64_t v20 = 0;
        *a2 = (((v19 | v18 | ((unint64_t)(int)(v19 | v18) >> 32)) + 0xFFFFFFFF) >> 32) ^ 1;
      }
    }
    v24((uint64_t)v23);
  }
  else
  {
    uint64_t v20 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v25);
  return v20;
}

uint64_t cced25519_make_pub_internal(void *a1, void (**a2)(void, uint64_t, int8x16_t *), uint64_t a3, char *a4)
{
  uint64_t v10 = *MEMORY[0x263EF8C08];
  if (*a1 != 64) {
    return 4294967289;
  }
  ccdigest_internal((uint64_t)a1, 0x20uLL, a4, (uint64_t)&__s);
  __s.i8[0] &= 0xF8u;
  char v9 = v9 & 0x3F | 0x40;
  memset(v7, 0, sizeof(v7));
  ge_scalarmult_base_masked((uint64_t)v7, &__s, a2);
  ge_p3_tobytes(a3, (int *)v7);
  cc_clear(0x40uLL, &__s);
  return 0;
}

uint64_t cced25519_make_pub(void *a1, uint64_t a2, char *a3)
{
  BOOL v9 = timingsafe_enable_if_supported();
  unint64_t v6 = ccrng(0);
  if (v6) {
    pub_uint64_t internal = cced25519_make_pub_internal(a1, (void (**)(void, uint64_t, int8x16_t *))v6, a2, a3);
  }
  else {
    pub_uint64_t internal = 0xFFFFFFFFLL;
  }
  cc_disable_dit_with_sb((unsigned int *)&v9);
  return pub_internal;
}

uint64_t cced25519_make_pub_with_rng(void *a1, void (**a2)(void, uint64_t, int8x16_t *), uint64_t a3, char *a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  pub_uint64_t internal = cced25519_make_pub_internal(a1, a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return pub_internal;
}

uint64_t cced25519_make_key_pair(void *a1, void (**a2)(void, uint64_t, int8x16_t *), uint64_t a3, char *a4)
{
  BOOL v11 = timingsafe_enable_if_supported();
  pub_uint64_t internal = ((uint64_t (*)(void, uint64_t, char *))*a2)(a2, 32, a4);
  if (!pub_internal) {
    pub_uint64_t internal = cced25519_make_pub_internal(a1, a2, a3, a4);
  }
  uint64_t v9 = pub_internal;
  cc_disable_dit_with_sb((unsigned int *)&v11);
  return v9;
}

uint64_t ccec_import_affine_point_ws(uint64_t a1, void *a2, int a3, uint64_t a4, unsigned __int8 *a5, uint64_t *a6)
{
  if (!a4) {
    return 4294967289;
  }
  unint64_t v11 = *a2;
  if (a4 == 1 && !*a5) {
    return 4294967136;
  }
  switch(a3)
  {
    case 4:
      uint64_t v12 = 4294967124;
      if (a4 != (unint64_t)(cczp_bitlen((uint64_t)a2) + 7) >> 3) {
        return v12;
      }
      goto LABEL_20;
    case 1:
      if ((((unint64_t)(cczp_bitlen((uint64_t)a2) + 7) >> 2) | 1) != a4) {
        return 4294967126;
      }
      uint64_t v12 = 4294967126;
      if (*a5 != 4) {
        return v12;
      }
LABEL_20:
      uint64_t v14 = *(void *)(a1 + 16);
      unint64_t v15 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v11);
      if (a3 == 4) {
        unint64_t v16 = a5;
      }
      else {
        unint64_t v16 = a5 + 1;
      }
      uint64_t v17 = cczp_bitlen((uint64_t)a2);
      uint64_t uint_public_value = ccn_read_uint_public_value(v11, a6, (unint64_t)(v17 + 7) >> 3, v16);
      if (uint_public_value) {
        goto LABEL_38;
      }
      if (ccn_cmp_public_value(v11, a6, a2 + 3) == -1)
      {
        if ((a3 - 3) <= 1)
        {
          uint64_t uint_public_value = ccec_affine_point_from_x_ws(a1, a2, (uint64_t)a6, (uint64_t)a6);
          if (!uint_public_value)
          {
            cczp_negate((uint64_t)a2, v15, (unint64_t *)&a6[*a2]);
            int v19 = &a6[*a2];
            if (a3 == 4) {
              unsigned int v20 = ccn_cmp_public_value(v11, v15, v19) >> 31;
            }
            else {
              LOBYTE(v20) = (*v19 & 1) != (*a5 & 1);
            }
            ccn_mux(v11, v20, v19, v15, v19);
            goto LABEL_35;
          }
LABEL_38:
          uint64_t v12 = uint_public_value;
          goto LABEL_36;
        }
        uint64_t v21 = &a5[((unint64_t)(cczp_bitlen((uint64_t)a2) + 7) >> 3) + 1];
        uint64_t v22 = &a6[*a2];
        uint64_t v23 = cczp_bitlen((uint64_t)a2);
        uint64_t v12 = ccn_read_uint_public_value(v11, v22, (unint64_t)(v23 + 7) >> 3, v21);
        if (!v12)
        {
          if (a3 != 2 || (a6[*a2] & 1) == (*a5 & 1))
          {
LABEL_35:
            uint64_t v12 = 0;
            goto LABEL_36;
          }
          uint64_t v12 = 4294967125;
        }
      }
LABEL_36:
      *(void *)(a1 + 16) = v14;
      return v12;
    case 2:
      if ((((unint64_t)(cczp_bitlen((uint64_t)a2) + 7) >> 2) | 1) != a4) {
        return 4294967125;
      }
      unsigned int v13 = *a5 - 8;
      uint64_t v12 = 4294967125;
      goto LABEL_19;
  }
  if (a3 != 3) {
    return 4294967289;
  }
  if (ccec_compressed_x962_export_pub_size((uint64_t)a2) != a4) {
    return 4294967135;
  }
  unsigned int v13 = *a5 - 4;
  uint64_t v12 = 4294967135;
LABEL_19:
  if (v13 >= 0xFFFFFFFE) {
    goto LABEL_20;
  }
  return v12;
}

uint64_t ccec_import_affine_point(void *a1, int a2, uint64_t a3, unsigned __int8 *a4, uint64_t *a5)
{
  BOOL v15 = timingsafe_enable_if_supported();
  uint64_t v10 = 17 * *a1;
  v13[0] = cc_malloc_clear(136 * *a1);
  v13[1] = v10;
  _OWORD v13[2] = 0;
  int v13[3] = cc_ws_alloc;
  uint64_t v14 = cc_ws_free;
  if (v13[0])
  {
    uint64_t v11 = ccec_import_affine_point_ws((uint64_t)v13, a1, a2, a3, a4, a5);
    v14((uint64_t)v13);
  }
  else
  {
    uint64_t v11 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v11;
}

void *cced25519_full_add_ws(uint64_t a1, void *a2, char *a3)
{
  uint64_t v6 = cczp_n((uint64_t)a2);
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = 4 * v6;
  uint64_t v9 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 4 * v6);
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8);
  cced25519_to_ed25519_point_ws(a1, (uint64_t)a2);
  cced25519_to_ed25519_point_ws(a1, (uint64_t)a2);
  cced25519_add_points_unified_ws(a1, (uint64_t)a2, v9, v10, v9, 4);
  uint64_t result = cced25519_from_ed25519_point_ws(a1, a2, a3, (char *)v9);
  *(void *)(a1 + 16) = v7;
  return result;
}

uint64_t ccn_shift_right_multi(uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t a4)
{
  uint64_t result = ccn_shift_right(a1, a2, a3, a4 & 0x3F);
  if (a1)
  {
    uint64_t v8 = 0;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v8;
      do
      {
        v9 |= ((((v10 ^ (v8 + (a4 >> 6)) | ((v10 ^ (v8 + (a4 >> 6))) >> 32))
               + 0xFFFFFFFF) >> 32)
             - 1) & *(void *)(a2 + 8 * v10);
        ++v10;
      }
      while (a1 != v10);
      *(void *)(a2 + 8 * v8++) = v9;
    }
    while (v8 != a1);
  }
  return result;
}

unint64_t ccwrap_auth_decrypt(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t *a4, size_t *a5, char *a6)
{
  BOOL v14 = timingsafe_enable_if_supported();
  unint64_t v15 = 0xA6A6A6A6A6A6A6A6;
  unint64_t v12 = ccwrap_auth_decrypt_withiv_internal(a1, a2, a3, a4, a5, a6, (char *)&v15);
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v12;
}

unint64_t ccz_write_int_size(uint64_t a1)
{
  BOOL v5 = timingsafe_enable_if_supported();
  unint64_t v2 = ccz_n(a1);
  unint64_t v3 = ccn_write_int_size(v2, *(unint64_t **)(a1 + 24));
  cc_disable_dit_with_sb((unsigned int *)&v5);
  return v3;
}

uint64_t ccz_write_int(uint64_t a1, unint64_t a2, unsigned char *a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  unint64_t v6 = ccz_n(a1);
  ccn_write_int(v6, *(unint64_t **)(a1 + 24), a2, a3);
  return cc_disable_dit_with_sb((unsigned int *)&v8);
}

unint64_t md4_compress(unint64_t result, uint64_t a2, _DWORD *a3)
{
  int v137 = (_DWORD *)result;
  if (a2)
  {
    int v3 = *(_DWORD *)result;
    int v4 = *(_DWORD *)(result + 4);
    int v5 = *(_DWORD *)(result + 8);
    int v6 = *(_DWORD *)(result + 12);
    do
    {
      uint64_t v141 = a2;
      int v7 = a3[1];
      int v8 = a3[2];
      int v9 = a3[4];
      int v10 = a3[6];
      int v139 = a3[7];
      unsigned int v140 = a3[3];
      HIDWORD(v12) = (v5 & v4 | v6 & ~v4) + v3 + *a3;
      LODWORD(v12) = HIDWORD(v12);
      int v11 = v12 >> 29;
      int v14 = a3[8];
      int v13 = a3[9];
      LODWORD(v12) = v7 + v6 + (v4 & __ROR4__(HIDWORD(v12), 29) | v5 & ~__ROR4__(HIDWORD(v12), 29));
      HIDWORD(v12) = v12;
      int v15 = v12 >> 25;
      int v16 = v8 + v5 + (v11 & __ROR4__(v12, 25) | v4 & ~__ROR4__(v12, 25));
      int v17 = v11 & ~__ROR4__(v16, 21);
      unint64_t v19 = __PAIR64__(v16, __ROR4__(v16, 21));
      int v18 = v15 & v19;
      LODWORD(v19) = v16;
      int v20 = v19 >> 21;
      HIDWORD(v19) = v140 + v4 + (v18 | v17);
      LODWORD(v19) = HIDWORD(v19);
      int v21 = v19 >> 13;
      LODWORD(v19) = v9 + v11 + (v20 & __ROR4__(HIDWORD(v19), 13) | v15 & ~__ROR4__(HIDWORD(v19), 13));
      HIDWORD(v19) = v19;
      int v22 = v19 >> 29;
      int v138 = a3[5];
      int v24 = a3[10];
      int v23 = a3[11];
      HIDWORD(v19) = v15 + v138 + (v21 & __ROR4__(v19, 29) | v20 & ~__ROR4__(v19, 29));
      LODWORD(v19) = HIDWORD(v19);
      int v25 = v19 >> 25;
      int v26 = v20 + v10 + (v22 & __ROR4__(HIDWORD(v19), 25) | v21 & ~__ROR4__(HIDWORD(v19), 25));
      unint64_t v28 = __PAIR64__(v26, __ROR4__(v26, 21));
      int v27 = v25 & v28;
      LODWORD(v28) = v26;
      int v29 = v28 >> 21;
      HIDWORD(v28) = v21 + v139 + (v27 | v22 & ~__ROR4__(v26, 21));
      LODWORD(v28) = HIDWORD(v28);
      int v30 = v28 >> 13;
      LODWORD(v28) = v22 + v14 + (v29 & __ROR4__(HIDWORD(v28), 13) | v25 & ~__ROR4__(HIDWORD(v28), 13));
      HIDWORD(v28) = v28;
      int v31 = v28 >> 29;
      int v33 = a3[12];
      int v32 = a3[13];
      HIDWORD(v28) = v25 + v13 + (v30 & __ROR4__(v28, 29) | v29 & ~__ROR4__(v28, 29));
      LODWORD(v28) = HIDWORD(v28);
      int v34 = v28 >> 25;
      int v35 = v29 + v24 + (v31 & __ROR4__(HIDWORD(v28), 25) | v30 & ~__ROR4__(HIDWORD(v28), 25));
      int v36 = v31 & ~__ROR4__(v35, 21);
      unint64_t v38 = __PAIR64__(v35, __ROR4__(v35, 21));
      int v37 = v34 & v38;
      LODWORD(v38) = v35;
      int v39 = v38 >> 21;
      HIDWORD(v38) = v30 + v23 + (v37 | v36);
      LODWORD(v38) = HIDWORD(v38);
      int v40 = v38 >> 13;
      LODWORD(v38) = v31 + v33 + (v39 & __ROR4__(HIDWORD(v38), 13) | v34 & ~__ROR4__(HIDWORD(v38), 13));
      HIDWORD(v38) = v38;
      int v41 = v38 >> 29;
      int v42 = v34 + v32;
      int v43 = a3[14];
      int v44 = a3[15];
      int v45 = v42 + (v40 & __ROR4__(v38, 29) | v39 & ~__ROR4__(v38, 29));
      HIDWORD(v38) = v45;
      LODWORD(v38) = v45;
      int v46 = v38 >> 25;
      int v47 = v39 + v43 + (v41 & __ROR4__(v45, 25) | v40 & ~__ROR4__(v45, 25));
      int v48 = v40 + v44 + (v46 & __ROR4__(v47, 21) | v41 & ~__ROR4__(v47, 21));
      HIDWORD(v38) = v48;
      LODWORD(v38) = v48;
      int v49 = v38 >> 13;
      LODWORD(v38) = *a3 + 1518500249 + v41 + ((v49 | __ROR4__(v47, 21)) & __ROR4__(v45, 25) | v49 & __ROR4__(v47, 21));
      int v50 = v38;
      HIDWORD(v38) = v38;
      int v51 = v38 >> 29;
      int v52 = v9 + 1518500249 + v46 + ((v51 | __ROR4__(v48, 13)) & __ROR4__(v47, 21) | v51 & __ROR4__(v48, 13));
      HIDWORD(v38) = v52;
      LODWORD(v38) = v52;
      int v53 = v38 >> 27;
      unint64_t v55 = __PAIR64__(v47, __ROR4__(v50, 29));
      int v54 = v53 | v55;
      LODWORD(v55) = v47;
      int v56 = v14 + 1518500249 + (v55 >> 21) + (v54 & __ROR4__(v48, 13) | v53 & __ROR4__(v50, 29));
      HIDWORD(v55) = v56;
      LODWORD(v55) = v56;
      int v57 = v55 >> 23;
      int v58 = v33 + 1518500249 + v49 + ((v57 | __ROR4__(v52, 27)) & __ROR4__(v50, 29) | v57 & __ROR4__(v52, 27));
      HIDWORD(v55) = v58;
      LODWORD(v55) = v58;
      int v59 = v55 >> 19;
      int v60 = v7 + 1518500249 + v51 + ((v59 | __ROR4__(v56, 23)) & __ROR4__(v52, 27) | v59 & __ROR4__(v56, 23));
      HIDWORD(v55) = v60;
      LODWORD(v55) = v60;
      int v61 = v55 >> 29;
      int v62 = v138 + 1518500249 + v53 + ((v61 | __ROR4__(v58, 19)) & __ROR4__(v56, 23) | v61 & __ROR4__(v58, 19));
      HIDWORD(v55) = v62;
      LODWORD(v55) = v62;
      int v63 = v55 >> 27;
      int v64 = v13 + 1518500249 + v57 + ((v63 | __ROR4__(v60, 29)) & __ROR4__(v58, 19) | v63 & __ROR4__(v60, 29));
      HIDWORD(v55) = v64;
      LODWORD(v55) = v64;
      int v65 = v55 >> 23;
      int v66 = v32 + 1518500249 + v59 + ((v65 | __ROR4__(v62, 27)) & __ROR4__(v60, 29) | v65 & __ROR4__(v62, 27));
      HIDWORD(v55) = v66;
      LODWORD(v55) = v66;
      int v67 = v55 >> 19;
      int v68 = v8 + 1518500249 + v61 + ((v67 | __ROR4__(v64, 23)) & __ROR4__(v62, 27) | v67 & __ROR4__(v64, 23));
      HIDWORD(v55) = v68;
      LODWORD(v55) = v68;
      int v69 = v55 >> 29;
      int v70 = v10 + 1518500249 + v63 + ((v69 | __ROR4__(v66, 19)) & __ROR4__(v64, 23) | v69 & __ROR4__(v66, 19));
      HIDWORD(v55) = v70;
      LODWORD(v55) = v70;
      int v71 = v55 >> 27;
      int v72 = v24 + 1518500249 + v65 + ((v71 | __ROR4__(v68, 29)) & __ROR4__(v66, 19) | v71 & __ROR4__(v68, 29));
      HIDWORD(v55) = v72;
      LODWORD(v55) = v72;
      int v73 = v55 >> 23;
      int v74 = v43 + 1518500249 + v67 + ((v73 | __ROR4__(v70, 27)) & __ROR4__(v68, 29) | v73 & __ROR4__(v70, 27));
      HIDWORD(v55) = v74;
      LODWORD(v55) = v74;
      int v75 = v55 >> 19;
      uint64_t result = v140;
      int v76 = v140 + 1518500249 + v69 + ((v75 | __ROR4__(v72, 23)) & __ROR4__(v70, 27) | v75 & __ROR4__(v72, 23));
      HIDWORD(v55) = v76;
      LODWORD(v55) = v76;
      int v77 = v55 >> 29;
      int v78 = v139 + 1518500249 + v71 + ((v77 | __ROR4__(v74, 19)) & __ROR4__(v72, 23) | v77 & __ROR4__(v74, 19));
      HIDWORD(v55) = v78;
      LODWORD(v55) = v78;
      int v79 = v55 >> 27;
      int v80 = v23 + 1518500249 + v73 + ((v79 | __ROR4__(v76, 29)) & __ROR4__(v74, 19) | v79 & __ROR4__(v76, 29));
      HIDWORD(v55) = v80;
      LODWORD(v55) = v80;
      int v81 = v55 >> 23;
      int v82 = v44 + 1518500249 + v75 + ((v81 | __ROR4__(v78, 27)) & __ROR4__(v76, 29) | v81 & __ROR4__(v78, 27));
      HIDWORD(v55) = v82;
      LODWORD(v55) = v82;
      int v83 = v55 >> 19;
      int v84 = v83 ^ __ROR4__(v80, 23);
      int v85 = *a3 + 1859775393 + v77 + (v84 ^ __ROR4__(v78, 27));
      unint64_t v86 = __PAIR64__(v85, __ROR4__(v85, 29));
      unsigned int v87 = v14 + 1859775393 + v79 + (v84 ^ v86);
      int v88 = v9 + 1859775393 + v81;
      LODWORD(v86) = v85;
      int v89 = v86 >> 29;
      unint64_t v90 = __PAIR64__(v87, __ROR4__(v87, 23));
      unsigned int v91 = v88 + (v89 ^ __ROR4__(v82, 19) ^ v90);
      int v92 = v8 + 1859775393 + v89;
      LODWORD(v90) = v87;
      int v93 = v90 >> 23;
      unint64_t v94 = __PAIR64__(v91, __ROR4__(v91, 21));
      unsigned int v95 = v33 + 1859775393 + v83 + (v93 ^ __ROR4__(v85, 29) ^ v94);
      LODWORD(v94) = v91;
      int v96 = v94 >> 21;
      unint64_t v97 = __PAIR64__(v95, __ROR4__(v95, 17));
      unsigned int v98 = v92 + (v96 ^ __ROR4__(v87, 23) ^ v97);
      int v99 = v24 + 1859775393 + v93;
      LODWORD(v97) = v95;
      int v100 = v97 >> 17;
      unint64_t v101 = __PAIR64__(v98, __ROR4__(v98, 29));
      unsigned int v102 = v99 + (v100 ^ __ROR4__(v91, 21) ^ v101);
      int v103 = v10 + 1859775393 + v96;
      LODWORD(v101) = v98;
      int v104 = v101 >> 29;
      unint64_t v105 = __PAIR64__(v102, __ROR4__(v102, 23));
      unsigned int v106 = v103 + (v104 ^ __ROR4__(v95, 17) ^ v105);
      LODWORD(v105) = v102;
      int v107 = v105 >> 23;
      unint64_t v108 = __PAIR64__(v106, __ROR4__(v106, 21));
      unsigned int v109 = v43 + 1859775393 + v100 + (v107 ^ __ROR4__(v98, 29) ^ v108);
      LODWORD(v108) = v106;
      int v110 = v108 >> 21;
      unint64_t v111 = __PAIR64__(v109, __ROR4__(v109, 17));
      unsigned int v112 = v7 + 1859775393 + v104 + (v110 ^ __ROR4__(v102, 23) ^ v111);
      LODWORD(v111) = v109;
      int v113 = v111 >> 17;
      unint64_t v114 = __PAIR64__(v112, __ROR4__(v112, 29));
      unsigned int v115 = v13 + 1859775393 + v107 + (v113 ^ __ROR4__(v106, 21) ^ v114);
      LODWORD(v114) = v112;
      int v116 = v114 >> 29;
      unint64_t v117 = __PAIR64__(v115, __ROR4__(v115, 23));
      unsigned int v118 = v138 + 1859775393 + v110 + (v116 ^ __ROR4__(v109, 17) ^ v117);
      int v119 = v32 + 1859775393 + v113;
      LODWORD(v117) = v115;
      int v120 = v117 >> 23;
      unint64_t v121 = __PAIR64__(v118, __ROR4__(v118, 21));
      unsigned int v122 = v119 + (v120 ^ __ROR4__(v112, 29) ^ v121);
      LODWORD(v121) = v118;
      int v123 = v121 >> 21;
      unint64_t v124 = __PAIR64__(v122, __ROR4__(v122, 17));
      unsigned int v125 = v140 + 1859775393 + v116 + (v123 ^ __ROR4__(v115, 23) ^ v124);
      int v126 = v23 + 1859775393 + v120;
      LODWORD(v124) = v122;
      int v127 = v124 >> 17;
      unint64_t v128 = __PAIR64__(v125, __ROR4__(v125, 29));
      unsigned int v129 = v126 + (v127 ^ __ROR4__(v118, 21) ^ v128);
      int v130 = v139 + 1859775393 + v123;
      LODWORD(v128) = v125;
      int v131 = v128 >> 29;
      unint64_t v132 = __PAIR64__(v129, __ROR4__(v129, 23));
      unsigned int v133 = v130 + (v131 ^ __ROR4__(v122, 17) ^ v132);
      LODWORD(v132) = v129;
      int v134 = v132 >> 23;
      unint64_t v135 = __PAIR64__(v133, __ROR4__(v133, 21));
      int v136 = v44 + 1859775393 + v127 + (v134 ^ __ROR4__(v125, 29) ^ v135);
      LODWORD(v135) = v133;
      v3 += v131;
      v5 += v135 >> 21;
      v6 += v134;
      HIDWORD(v135) = v136;
      LODWORD(v135) = v136;
      v4 += v135 >> 17;
      *int v137 = v3;
      v137[1] = v4;
      v137[2] = v5;
      v137[3] = v6;
      a3 += 16;
      a2 = v141 - 1;
    }
    while (v141 != 1);
  }
  return result;
}

uint64_t CCDH_POWER_BLINDED_WORKSPACE_N(uint64_t a1)
{
  unint64_t v1 = 2 * (a1 + 1);
  unint64_t v2 = v1;
  unint64_t v3 = 5 * (a1 + 1) + 3;
  unint64_t v4 = 12 * (a1 + 1);
  unint64_t v5 = 4 * (a1 + 1);
  if (v5 <= v1) {
    unint64_t v6 = 2 * (a1 + 1);
  }
  else {
    unint64_t v6 = 4 * (a1 + 1);
  }
  if (v6 <= 12 * (a1 + 1)) {
    unint64_t v6 = 12 * (a1 + 1);
  }
  if (v3 <= v6)
  {
    if (v5 <= v1) {
      goto LABEL_22;
    }
    if (v4 <= v5) {
      unint64_t v7 = 4 * (a1 + 1);
    }
    else {
      unint64_t v7 = 12 * (a1 + 1);
    }
    if (v1 > v7) {
      return a1 + v1 + v2 + 5;
    }
LABEL_15:
    if (v4 <= v5) {
      unint64_t v2 = 4 * (a1 + 1);
    }
    else {
      unint64_t v2 = 12 * (a1 + 1);
    }
    if (v3 > v2)
    {
      unint64_t v2 = 5 * (a1 + 1) + 3;
      return a1 + v1 + v2 + 5;
    }
    if (v5 > v1) {
      return a1 + v1 + v2 + 5;
    }
    goto LABEL_26;
  }
  if (v1 > v3) {
    return a1 + v1 + v2 + 5;
  }
  if (v5 > v1) {
    goto LABEL_15;
  }
LABEL_22:
  if (v4 <= v1) {
    unint64_t v8 = 2 * (a1 + 1);
  }
  else {
    unint64_t v8 = 12 * (a1 + 1);
  }
  unint64_t v2 = 5 * (a1 + 1) + 3;
  if (v3 <= v8)
  {
LABEL_26:
    if (v4 <= v1) {
      unint64_t v2 = 2 * (a1 + 1);
    }
    else {
      unint64_t v2 = 12 * (a1 + 1);
    }
  }
  return a1 + v1 + v2 + 5;
}

uint64_t ccdh_power_blinded_ws(uint64_t a1, uint64_t (**a2)(void, uint64_t, uint64_t *), void *a3, uint64_t *a4, void *a5, unint64_t a6, uint64_t a7)
{
  uint64_t v28 = *MEMORY[0x263EF8C08];
  unint64_t v12 = ccdh_gp_n(a3);
  uint64_t v13 = v12 + 1;
  uint64_t v24 = *(void *)(a1 + 16);
  int v14 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v12 + 1);
  int v15 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 2 * (v12 + 1) + 4);
  uint64_t *v15 = v12 + 1;
  if ((a6 + 63) >> 6 <= v12
    && (int v16 = v15, v17 = ccdh_gp_prime(a3), (ccn_cmp_internal(v12, a5, v17) & 0x80000000) != 0)
    && (uint64_t v18 = ccdh_gp_prime(a3), (ccn_cmpn_internal((a6 + 63) >> 6, a7, v12, v18) & 0x80000000) != 0))
  {
    uint64_t result = (*a2)(a2, 16, &v26);
    if (!result)
    {
      ccn_mux_seed_mask(v26);
      v26 |= 0x80000001uLL;
      int v20 = (unint64_t *)ccdh_gp_prime(a3);
      v16[v12 + 3] = ccn_mul1(v12, v16 + 3, v20, v26);
      int v21 = (void *)cczp_prime((uint64_t)v16);
      uint64_t result = cczp_mm_init_ws(a1, v16, v13, v21);
      if (!result)
      {
        ccn_set(v12, v14, a5);
        int v22 = (unint64_t *)ccdh_gp_prime(a3);
        *((void *)v14 + v12) = ccn_addmul1(v12, (unint64_t *)v14, v22, v27);
        cczp_modn_ws(a1, v16, (uint64_t *)v14, v13, (char *)v14);
        cczp_to_ws(a1, (uint64_t)v16);
        uint64_t result = cczp_power_blinded_ws(a1, (uint64_t)v16, v14, v14, a6, a7, (uint64_t (**)(void, unint64_t, uint64_t))a2);
        if (!result)
        {
          cczp_from_ws(a1, (uint64_t)v16);
          cczp_modn_ws(a1, a3, a4, v13, (char *)v14);
          uint64_t result = 0;
        }
      }
    }
  }
  else
  {
    uint64_t result = 4294967289;
  }
  *(void *)(a1 + 16) = v24;
  return result;
}

uint64_t ccec_rfc6637_unwrap_key(unint64_t **a1, unint64_t *a2, void *a3, char a4, unsigned char *a5, char *a6, uint64_t (**a7)(void), char *a8, unint64_t a9, unsigned __int8 *a10)
{
  BOOL v29 = timingsafe_enable_if_supported();
  int v16 = *a1;
  unint64_t v17 = **a1;
  uint64_t v18 = sizeof_struct_cche_galois_key();
  unint64_t v19 = sizeof_struct_ccpolyzp_po2cyc();
  v27[0] = cc_malloc_clear(8 * ((v18 + v19 + 3 * v19 * v17 - 1) / v19 + 30 * v17 + v19 * v17) + 16 * v19 * v17 + 720);
  unint64_t v20 = *v16;
  uint64_t v21 = sizeof_struct_cche_galois_key();
  unint64_t v22 = sizeof_struct_ccpolyzp_po2cyc();
  v27[1] = (v21 + v22 + 3 * v22 * v20 - 1) / v22 + 30 * v20 + v22 * v20 + 2 * v22 * v20 + 90;
  void v27[2] = 0;
  v27[3] = cc_ws_alloc;
  uint64_t v28 = cc_ws_free;
  if (v27[0])
  {
    uint64_t v23 = ccec_rfc6637_unwrap_key_ws((uint64_t)v27, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
    v28((uint64_t)v27);
  }
  else
  {
    uint64_t v23 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v29);
  return v23;
}

uint64_t ccec_rfc6637_unwrap_key_ws(uint64_t a1, unint64_t **a2, unint64_t *a3, void *a4, char a5, unsigned char *a6, char *a7, uint64_t (**a8)(void), char *a9, unint64_t a10, unsigned __int8 *a11)
{
  uint64_t v70 = *MEMORY[0x263EF8C08];
  unint64_t v19 = (rsize_t *)(*((uint64_t (**)(void))*a8 + 2))();
  if (a10 < 5 || *v19 < *((void *)*a8 + 4)) {
    return 4294967289;
  }
  int v64 = a6;
  int v65 = a3;
  unint64_t v21 = ((unint64_t)__rev16(*(unsigned __int16 *)a11) + 7) >> 3;
  if (v21 > a10 - 3) {
    return 4294967289;
  }
  unint64_t v22 = v19;
  unint64_t v23 = v21 + 3 + a11[v21 + 2];
  if ((a5 & 2) != 0)
  {
    if (v23 > a10) {
      return 4294967289;
    }
LABEL_12:
    uint64_t v56 = a11[v21 + 2];
    unint64_t v59 = v21 + 3;
    int v60 = a4;
    uint64_t v26 = (uint64_t *)*a2;
    unint64_t v27 = **a2;
    uint64_t v58 = a8[1]();
    uint64_t v28 = ccecb_context_size(v58);
    int v63 = &v55;
    MEMORY[0x270FA53B0](v28, v29, v30, v31);
    int v57 = (char *)&v55 - v32;
    uint64_t v62 = *(void *)(a1 + 16);
    int v61 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v27);
    int v33 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 24);
    uint64_t v55 = 24 * v27;
    int v34 = (uint64_t *)v33(a1, (24 * v27 + 23) >> 3);
    *int v34 = (uint64_t)v26;
    if ((((unint64_t)(cczp_bitlen((uint64_t)v26) + 7) >> 2) | 1) == v21)
    {
      uint64_t v35 = ccec_import_pub_ws(a1, v26, v21, a11 + 2, v34);
    }
    else
    {
      if ((a5 & 1) == 0 || v21 > (unint64_t)(cczp_bitlen(*v34) + 7) >> 3)
      {
        unint64_t v24 = 4294967289;
        goto LABEL_31;
      }
      uint64_t v35 = ccec_compact_import_pub_ws(a1, v26, v21, a11 + 2, (uint64_t **)v34);
    }
    unint64_t v24 = v35;
    if (!v35)
    {
      size_t v68 = (unint64_t)(cczp_bitlen((uint64_t)v26) + 7) >> 3;
      int v36 = v61;
      uint64_t v37 = ccecdh_compute_shared_secret_ws(a1, a2, (unint64_t **)v34, &v68, v61, 0);
      if (v37)
      {
        unint64_t v24 = v37;
        goto LABEL_31;
      }
      unint64_t v38 = v56;
      ccec_rfc6637_kdf((uint64_t)v22, a7, (uint64_t)*a8, v68, v36, 0x14uLL, a9, (uint64_t)__s);
      int v40 = v57;
      uint64_t v39 = v58;
      ccecb_init_internal(v58);
      cc_clear(*v22, __s);
      uint64_t v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v55 + 90);
      unint64_t v66 = 0xA6A6A6A6A6A6A6A6;
      size_t v67 = v38;
      unint64_t v24 = ccwrap_auth_decrypt_withiv_internal(v39, (uint64_t)v40, v38, (uint64_t *)&a11[v59], &v67, (char *)v41, (char *)&v66);
      rsize_t v42 = ccecb_context_size(v39);
      cc_clear(v42, v40);
      int v43 = v60;
      if (!v24)
      {
        size_t v44 = v67;
        if (v67 - 1 >= v38 - 1
          || (int v45 = v65,
              *int v64 = *(unsigned char *)v41,
              int v46 = (unsigned char *)(v41 + v44 - 1),
              unint64_t v47 = *v46,
              size_t v48 = v44 - 3,
              unint64_t v49 = v48 - v47,
              v48 < v47))
        {
LABEL_32:
          unint64_t v24 = 4294967294;
          goto LABEL_31;
        }
        if (*v46)
        {
          uint64_t v50 = *v46;
          do
          {
            int v51 = *v46--;
            if (v51 != v47) {
              goto LABEL_32;
            }
          }
          while (--v50);
        }
        if (*v45 < v49)
        {
          unint64_t v24 = 4294967133;
          goto LABEL_31;
        }
        *int v45 = v49;
        int v52 = v45;
        unsigned int v53 = pgp_key_checksum(v49, (unsigned __int8 *)(v41 + 1));
        size_t v54 = *v52 + v41;
        if (*(unsigned __int8 *)(v54 + 1) != v53 >> 8 || *(unsigned __int8 *)(v54 + 2) != v53) {
          goto LABEL_32;
        }
        memcpy(v43, (const void *)(v41 + 1), *v52);
        unint64_t v24 = 0;
      }
    }
LABEL_31:
    *(void *)(a1 + 16) = v62;
    return v24;
  }
  if (v23 == a10) {
    goto LABEL_12;
  }
  return 4294967289;
}

unint64_t ccec_scalar_fips_extrabits_min_entropy_len(void *a1)
{
  return (unint64_t)(cczp_bitlen((uint64_t)&a1[5 * *a1 + 4]) + 71) >> 3;
}

uint64_t ccec_generate_scalar_fips_extrabits_ws(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, char *a5)
{
  int v10 = a2 + 4;
  uint64_t v11 = (uint64_t)&a2[5 * *a2 + 4];
  uint64_t v12 = cczp_n(v11);
  uint64_t v13 = *(void *)(a1 + 16);
  if (a3 < (unint64_t)(cczp_bitlen((uint64_t)&v10[5 * *a2]) + 71) >> 3)
  {
    uint64_t result = 4294967276;
  }
  else if (a3 > 0x80)
  {
    uint64_t result = 4294967289;
  }
  else
  {
    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 16);
    int v15 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
    int v16 = (void *)cczp_prime(v11);
    ccn_set(v12, v15, v16);
    *v15 &= ~1uLL;
    uint64_t result = ccn_read_uint_internal(16, v14, a3, a4);
    if (!result)
    {
      ccn_divmod_ws(a1, (a3 + 7) >> 3, v14, 0, 0, v12, a5, v15);
      ccn_add1_ws(a1, v12, a5, (uint64_t *)a5, 1);
      uint64_t result = 0;
    }
  }
  *(void *)(a1 + 16) = v13;
  return result;
}

uint64_t ccec_generate_scalar_fips_extrabits(void *a1, unint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v8 = (uint64_t)&a1[5 * *a1 + 4];
  uint64_t v9 = cczp_n(v8);
  unint64_t v10 = sizeof_struct_ccpolyzp_po2cyc();
  v15[0] = cc_malloc_clear(8 * ((v10 + 127) / v10 + 4 * v9) + 24);
  uint64_t v11 = cczp_n(v8);
  unint64_t v12 = sizeof_struct_ccpolyzp_po2cyc();
  v15[1] = (v12 + 127) / v12 + 4 * v11 + 3;
  void v15[2] = 0;
  v15[3] = cc_ws_alloc;
  int v16 = cc_ws_free;
  if (!v15[0]) {
    return 4294967283;
  }
  scalar_fips_extrabits_uint64_t ws = ccec_generate_scalar_fips_extrabits_ws((uint64_t)v15, a1, a2, a3, a4);
  v16((uint64_t)v15);
  return scalar_fips_extrabits_ws;
}

uint64_t ccmode_cfb8_encrypt(unsigned char *a1, uint64_t a2, char *a3, unsigned char *a4)
{
  if (a2)
  {
    uint64_t v6 = a2;
    unint64_t v7 = a1 + 8;
    uint64_t v8 = *(void *)a1;
    unint64_t v9 = (unint64_t)(*(void *)(*(void *)a1 + 8) + 7) >> 3;
    uint64_t v10 = (uint64_t)&a1[16 * v9 + 8];
    uint64_t v11 = (uint64_t)&a1[8 * v9 + 8];
    do
    {
      --v6;
      memmove((void *)v11, (const void *)(v11 + 1), *(void *)(v8 + 8) - 1);
      char v12 = *a3++;
      char v13 = v12 ^ *v7;
      *a4++ = v13;
      *(unsigned char *)(*(void *)(v8 + 8) + v11 - 1) = v13;
      (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *))(v8 + 24))(v10, 1, v11, v7);
    }
    while (v6);
  }
  return 0;
}

uint64_t ccn_shift_left_multi(unint64_t a1, void *a2, unint64_t *a3, unint64_t a4)
{
  uint64_t result = ccn_shift_left(a1, a2, a3, a4 & 0x3F);
  if (a1)
  {
    unint64_t v8 = a1 - 1;
    unint64_t v9 = a1;
    do
    {
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      do
      {
        v10 |= ((((v11 ^ (v8 - (a4 >> 6)) | ((v11 ^ (v8 - (a4 >> 6))) >> 32))
                + 0xFFFFFFFF) >> 32)
              - 1) & a2[v11];
        ++v11;
      }
      while (v9 != v11);
      a2[v8--] = v10;
      --v9;
    }
    while (v8 < a1);
  }
  return result;
}

uint64_t cche_secret_key_generate_ws(uint64_t a1, unsigned int **a2, uint64_t a3, uint64_t (**a4)(void, uint64_t, uint64_t))
{
  *a2 = (unsigned int *)(cche_param_ctx_chain_const(a3) + 8);
  uint64_t result = ccpolyzp_po2cyc_random_ternary_ws(a1, a2, a4);
  if (!result)
  {
    return ccpolyzp_po2cyc_fwd_ntt(a2);
  }
  return result;
}

uint64_t cche_secret_key_generate(unsigned int **a1, uint64_t a2, uint64_t (**a3)(void, uint64_t, uint64_t))
{
  BOOL v13 = timingsafe_enable_if_supported();
  unsigned int v6 = cche_param_ctx_polynomial_degree(a2);
  unint64_t v7 = CCPOLYZP_PO2CYC_RANDOM_TERNARY_WORKSPACE_N(v6);
  v11[0] = cc_malloc_clear(8 * v7);
  unsigned int v8 = cche_param_ctx_polynomial_degree(a2);
  v11[1] = CCPOLYZP_PO2CYC_RANDOM_TERNARY_WORKSPACE_N(v8);
  void v11[2] = 0;
  v11[3] = cc_ws_alloc;
  char v12 = cc_ws_free;
  if (v11[0])
  {
    uint64_t ws = cche_secret_key_generate_ws((uint64_t)v11, a1, a2, a3);
    v12((uint64_t)v11);
  }
  else
  {
    uint64_t ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v13);
  return ws;
}

uint64_t cche_secret_key_generate_from_seed_ws(uint64_t a1, unsigned int **a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 16);
  unint64_t v7 = (uint64_t (**)(void, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 536);
  uint64_t result = ccpolyzp_po2cyc_block_rng_init((uint64_t)v7);
  if (!result) {
    uint64_t result = cche_secret_key_generate_ws(a1, a2, a3, v7);
  }
  *(void *)(a1 + 16) = v6;
  return result;
}

uint64_t cche_secret_key_generate_from_seed(unsigned int **a1, uint64_t a2)
{
  BOOL v16 = timingsafe_enable_if_supported();
  unint64_t v4 = cche_param_ctx_polynomial_degree(a2);
  uint64_t v5 = sizeof_struct_ccpolyzp_po2cyc_block_rng_state();
  unint64_t v6 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v7 = (v5 + v6 - 1) / v6;
  unint64_t v8 = CCPOLYZP_PO2CYC_RANDOM_TERNARY_WORKSPACE_N(v4);
  v14[0] = cc_malloc_clear(8 * (v8 + v7));
  unint64_t v9 = cche_param_ctx_polynomial_degree(a2);
  uint64_t v10 = sizeof_struct_ccpolyzp_po2cyc_block_rng_state();
  unint64_t v11 = sizeof_struct_ccpolyzp_po2cyc();
  v14[1] = CCPOLYZP_PO2CYC_RANDOM_TERNARY_WORKSPACE_N(v9) + (v10 + v11 - 1) / v11;
  _OWORD v14[2] = 0;
  void v14[3] = cc_ws_alloc;
  int v15 = cc_ws_free;
  if (v14[0])
  {
    uint64_t v12 = cche_secret_key_generate_from_seed_ws((uint64_t)v14, a1, a2);
    v15((uint64_t)v14);
  }
  else
  {
    uint64_t v12 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v12;
}

uint64_t ltc_rc2_ecb_decrypt(uint64_t a1, uint64_t a2, unsigned __int16 *a3, _WORD *a4)
{
  for (; a2; --a2)
  {
    unsigned int v4 = a3[3];
    unsigned int v5 = a3[2];
    unsigned int v6 = a3[1];
    unint64_t v7 = (_DWORD *)(a1 + 252);
    uint64_t v8 = 16;
    unsigned int v9 = *a3;
    do
    {
      if (v8 == 11 || v8 == 5)
      {
        char v11 = v4 - *(_DWORD *)(a1 + 4 * (v5 & 0x3F));
        unsigned int v4 = (unsigned __int16)(v4 - *(_DWORD *)(a1 + 4 * (v5 & 0x3F)));
        unsigned int v5 = (unsigned __int16)(v5 - *(_DWORD *)(a1 + 4 * (v6 & 0x3F)));
        unsigned int v6 = (unsigned __int16)(v6 - *(_DWORD *)(a1 + 4 * (v9 & 0x3F)));
        unsigned int v9 = (unsigned __int16)(v9 - *(_DWORD *)(a1 + 4 * (v11 & 0x3F)));
      }
      int v12 = ((v4 << 11) | (v4 >> 5)) - (v6 & v5 | v9 & ~v5) - *v7;
      unsigned int v4 = (unsigned __int16)((((_WORD)v4 << 11) | (v4 >> 5)) - (v6 & v5 | v9 & ~(_WORD)v5) - *(_WORD *)v7);
      int v13 = ((v5 << 13) | (v5 >> 3)) - ((v9 & v6) + *(v7 - 1)) - (v12 & ~v6);
      unsigned int v5 = (unsigned __int16)((((_WORD)v5 << 13) | (v5 >> 3)) - ((v9 & v6) + *((_WORD *)v7 - 2)) - (v12 & ~(_WORD)v6));
      int v14 = *(v7 - 3);
      int v15 = ((v6 << 14) | (v6 >> 2)) - (*(v7 - 2) + (v12 & v9)) - (v13 & ~v9);
      unsigned int v6 = (unsigned __int16)((((_WORD)v6 << 14) | (v6 >> 2)) - (*((_WORD *)v7 - 4) + (v12 & v9)) - (v13 & ~(_WORD)v9));
      int v16 = ((v9 << 15) | (v9 >> 1)) - v14 - (v15 & ~v4 | v13 & v12);
      unsigned int v9 = (unsigned __int16)((((_WORD)v9 << 15) | (v9 >> 1)) - v14 - (v15 & ~(_WORD)v4 | v13 & v12));
      v7 -= 4;
      --v8;
    }
    while (v8);
    *a4 = v16;
    a4[1] = v15;
    a4[2] = v13;
    a3 += 4;
    a4[3] = v12;
    a4 += 4;
  }
  return 0;
}

uint64_t ccec_rfc6637_wrap_key_diversified(uint64_t a1, uint64_t *a2, _WORD *a3, uint64_t a4, char a5, size_t a6, unsigned __int8 *a7, char *a8, uint64_t (**a9)(void), char *a10, uint64_t (**a11)(void, uint64_t, unint64_t *))
{
  BOOL v38 = timingsafe_enable_if_supported();
  uint64_t v18 = (uint64_t *)*a2;
  uint64_t v19 = *(void *)*a2;
  uint64_t v20 = sizeof_struct_cche_galois_key();
  unint64_t v21 = sizeof_struct_ccpolyzp_po2cyc();
  v34[0] = cc_malloc_clear(248 * v19 + 16 * ((v20 + v21 + 4 * v19 * v21 - 1) / v21));
  uint64_t v22 = *v18;
  uint64_t v23 = sizeof_struct_cche_galois_key();
  unint64_t v24 = sizeof_struct_ccpolyzp_po2cyc();
  v34[1] = 31 * v22 + 2 * ((v23 + v24 + 4 * v22 * v24 - 1) / v24);
  uint64_t v35 = 0;
  int v36 = cc_ws_alloc;
  uint64_t v37 = cc_ws_free;
  if (v34[0])
  {
    char v32 = a5;
    int v25 = (unint64_t *)*a2;
    uint64_t v26 = (unint64_t **)cc_ws_alloc(v34, (4 * (*(void *)*a2 & 0x7FFFFFFFFFFFFFFLL)) | 2);
    uint64_t v27 = v35;
    *uint64_t v26 = v25;
    uint64_t scalar_fips_retry_ws = ccec_generate_scalar_fips_retry_ws((uint64_t)v34, v25, (uint64_t (**)(void, unint64_t, void *))a11, &v26[3 * *v25 + 2]);
    if (!scalar_fips_retry_ws)
    {
      uint64_t v29 = a1 + 16;
      uint64_t scalar_fips_retry_ws = ccec_make_pub_from_priv_ws((uint64_t)v34, v25, a11, (uint64_t)&v26[3 * **v26 + 2], v29, v26);
      if (!scalar_fips_retry_ws)
      {
        if (ccecdh_pairwise_consistency_check_ws((uint64_t)v34, v26, v29, a11))
        {
          uint64_t v30 = 4294967278;
LABEL_9:
          uint64_t v35 = 0;
          v37((uint64_t)v34);
          goto LABEL_10;
        }
        uint64_t v35 = v27;
        uint64_t scalar_fips_retry_ws = ccec_rfc6637_wrap_core_ws((uint64_t)v34, a2, v26, a3, a4, v32, a6, a7, a8, a9, a10, a11);
      }
    }
    uint64_t v30 = scalar_fips_retry_ws;
    goto LABEL_9;
  }
  uint64_t v30 = 4294967283;
LABEL_10:
  cc_disable_dit_with_sb((unsigned int *)&v38);
  return v30;
}

uint64_t cczp_prime(uint64_t a1)
{
  return a1 + 24;
}

uint64_t ccec_get_pubkey_components(uint64_t *a1, uint64_t *a2, uint64_t a3, unint64_t *a4, uint64_t a5, unint64_t *a6)
{
  int v12 = (unint64_t *)(a1 + 2);
  unint64_t v13 = *(void *)*a1;
  unint64_t v14 = ccn_write_uint_size_public_value(v13, (unint64_t *)a1 + 2);
  if (v14 > *a4) {
    return 0xFFFFFFFFLL;
  }
  *a4 = v14;
  ccn_write_uint_public_value(v13, v12, v14, a3);
  int v15 = (unint64_t *)*a1;
  unint64_t v16 = ccn_write_uint_size_public_value(v13, &v12[*(void *)*a1]);
  if (v16 > *a6) {
    return 0xFFFFFFFFLL;
  }
  *a6 = v16;
  ccn_write_uint_public_value(v13, &v12[*v15], v16, a5);
  uint64_t v18 = cczp_bitlen(*a1);
  uint64_t result = 0;
  *a2 = v18;
  return result;
}

uint64_t ccrsa_eme_pkcs1v15_encode_internal(uint64_t (**a1)(void, size_t, char *), unint64_t a2, _WORD *a3, size_t a4, void *a5)
{
  uint64_t v21 = *MEMORY[0x263EF8C08];
  unint64_t v10 = ccrsa_n_from_size(a2);
  char v11 = (char *)ccrsa_block_start(a2, a3, 1);
  if (v11 > (char *)a3) {
    bzero(a3, v11 - (char *)a3);
  }
  uint64_t v12 = 4294967273;
  if (a2 >= 0xB)
  {
    uint64_t v19 = a5;
    if (a2 - 11 >= a4)
    {
      unint64_t v13 = v11 + 2;
      unint64_t v14 = a2 - a4;
      size_t v15 = a2 - a4 - 3;
      unint64_t v16 = *a1;
      if (v15 > 0xB)
      {
        uint64_t v12 = v16(a1, v15, v11 + 2);
        if (v12) {
          return v12;
        }
      }
      else
      {
        uint64_t v12 = v16(a1, 12, __src);
        memcpy(v11 + 2, __src, v15);
        cc_clear(v15, __src);
        if (v12) {
          return v12;
        }
      }
      if (v15)
      {
        for (uint64_t i = 0; i != v15; ++i)
        {
          while (!*((unsigned char *)v13 + i))
          {
            uint64_t v12 = (*a1)(a1, 12, __src);
            *((unsigned char *)v13 + i) = __src[0];
            cc_clear(1uLL, __src);
            if (v12) {
              return v12;
            }
          }
        }
      }
      *(_WORD *)char v11 = 512;
      v11[v14 - 1] = 0;
      memcpy(&v11[v14], v19, a4);
      ccn_swap(v10, (unint64_t *)a3);
      return 0;
    }
  }
  return v12;
}

uint64_t ccrsa_eme_pkcs1v15_encode(uint64_t (**a1)(void, size_t, char *), unint64_t a2, _WORD *a3, size_t a4, void *a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = ccrsa_eme_pkcs1v15_encode_internal(a1, a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

unint64_t ccec_signature_r_s_size(uint64_t *a1)
{
  return (unint64_t)(cczp_bitlen(*a1) + 7) >> 3;
}

uint64_t fipspost_post_ecdsa(int a1)
{
  uint64_t v89 = *MEMORY[0x263EF8C08];
  unint64_t v2 = (uint64_t *)ccec_cp_521();
  uint64_t v3 = *v2;
  uint64_t v4 = sizeof_struct_cche_galois_key();
  unint64_t v5 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v6 = (v5 - 1 + v4 + 3 * v3 * v5) / v5 + 47 * v3;
  unint64_t v7 = (v5 - 1 + 4 * v3 * v5 + sizeof_struct_cche_galois_key()) / v5 + 49 * v3;
  if (v6 > v7) {
    unint64_t v7 = v6;
  }
  uint64_t v8 = cc_malloc_clear(8 * v7);
  v80[0] = v8;
  uint64_t v9 = *v2;
  uint64_t v10 = sizeof_struct_cche_galois_key();
  unint64_t v11 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v12 = (v11 - 1 + v10 + 3 * v9 * v11) / v11 + 47 * v9;
  unint64_t v13 = (v11 - 1 + 4 * v9 * v11 + sizeof_struct_cche_galois_key()) / v11 + 49 * v9;
  if (v12 > v13) {
    unint64_t v13 = v12;
  }
  v80[1] = v13;
  uint64_t v81 = 0;
  int v82 = cc_ws_alloc;
  int v83 = cc_ws_free;
  if (!v8) {
    return 4294967283;
  }
  uint64_t v14 = 0;
  char v75 = a1;
  uint64_t v63 = (uint64_t)(a1 << 27) >> 31;
  size_t v15 = (uint64_t *)&unk_26EA47490;
  while (1)
  {
    uint64_t v78 = v14;
    unint64_t v16 = (uint64_t *)((uint64_t (*)(void))*(v15 - 6))();
    unint64_t v17 = (unint64_t *)((uint64_t (*)(void))*(v15 - 5))();
    uint64_t v18 = cczp_bitlen((uint64_t)v16);
    unint64_t v66 = *v17;
    uint64_t v68 = v18;
    uint64_t v19 = (char *)*(v15 - 3);
    unint64_t v76 = *(v15 - 2);
    uint64_t v21 = (unsigned __int8 *)*(v15 - 1);
    uint64_t v20 = *v15;
    uint64_t v22 = v15[1];
    size_t v23 = v15[2];
    unint64_t v24 = (const void *)v15[3];
    uint64_t v70 = (const void *)v15[5];
    size_t v72 = v15[4];
    memset(v85, 0, sizeof(v85));
    uint64_t v25 = cczp_bitlen((uint64_t)v16);
    unint64_t v64 = *v17;
    uint64_t v65 = v25;
    uint64_t v74 = v81;
    uint64_t v26 = (uint64_t **)v82(v80, (4 * (*v16 & 0x7FFFFFFFFFFFFFFLL)) | 2);
    *uint64_t v26 = v16;
    if (ccec_x963_import_priv_ws((uint64_t)v80, v16, v76, v21, v26))
    {
      mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccec_x963_import_priv (P-%zu/SHA-%zu): %d\n");
LABEL_19:
      uint64_t v28 = v78;
      uint64_t v29 = v74;
      goto LABEL_21;
    }
    ccrng_ecfips_test_init(v85, v20 + v63, v22);
    uint64_t v84 = 141;
    int v27 = ccec_sign_msg_ws((uint64_t)v80, v26, v17, 0x80uLL, v19, (unint64_t *)&v84, (uint64_t)v88, v85);
    if (v27)
    {
      int v31 = v27;
      uint64_t v32 = mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccec_sign_msg (P-%zu/SHA-%zu): %d\n", v32, "fipspost_post_ecdsa_sign_ws", 78, v65, 8 * v64, v31);
      uint64_t v28 = v78;
      goto LABEL_22;
    }
    if (ccec_extract_rs_ws((uint64_t)v80, (uint64_t *)v26, v84, v88, __s1, v86))
    {
      mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccec_extract_rs (P-%zu/SHA-%zu): %d\n");
      goto LABEL_19;
    }
    if (memcmp(__s1, v24, v23))
    {
      mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ECDSA_P%zu_SHA%zu KAT (r)\n");
      goto LABEL_19;
    }
    uint64_t v28 = v78;
    uint64_t v29 = v74;
    if (memcmp(v86, v70, v72)) {
      break;
    }
    uint64_t v81 = v74;
    uint64_t v14 = v78 + 1;
    v15 += 12;
    if (v78 == 3)
    {
      int v67 = 0;
      goto LABEL_23;
    }
  }
  uint64_t v33 = mach_absolute_time();
  printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ECDSA_P%zu_SHA%zu KAT (s)\n", v33, "fipspost_post_ecdsa_sign_ws", 101, v65, 8 * v64);
LABEL_21:
  uint64_t v81 = v29;
LABEL_22:
  uint64_t v34 = mach_absolute_time();
  printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ECDSA_P%zu_SHA%zu_SIG KAT #%zu\n", v34, "fipspost_post_ecdsa_kat_sign_ws", 153, v68, 8 * v66, v28);
  int v67 = -75;
LABEL_23:
  uint64_t v35 = 0;
  uint64_t v81 = 0;
  int v36 = (uint64_t *)&unk_26EA47600;
  while (1)
  {
    uint64_t v79 = v35;
    uint64_t v37 = (uint64_t *)((uint64_t (*)(void))*(v36 - 4))();
    BOOL v38 = (unint64_t *)((uint64_t (*)(void))*(v36 - 3))();
    uint64_t v39 = cczp_bitlen((uint64_t)v37);
    unint64_t v71 = *v38;
    uint64_t v73 = v39;
    int v40 = (char *)*(v36 - 1);
    uint64_t v41 = *v36;
    int v43 = (unsigned __int8 *)v36[1];
    uint64_t v42 = v36[2];
    uint64_t v69 = cczp_bitlen((uint64_t)v37);
    unint64_t v44 = *v38;
    uint64_t v77 = v81;
    int v45 = (uint64_t **)v82(v80, (unint64_t)(24 * *v37 + 23) >> 3);
    *int v45 = v37;
    int v46 = ccec_x963_import_pub_ws((uint64_t)v80, v37, v41, v43, v45);
    if (v46)
    {
      int v50 = v46;
      uint64_t v51 = mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccec_x963_import_pub (P-%zu/SHA-%zu): %d\n", v51, "fipspost_post_ecdsa_verify_ws", 187, v69, 8 * v44, v50);
      char v47 = v75;
      goto LABEL_32;
    }
    __memcpy_chk();
    char v47 = v75;
    if ((v75 & 0x10) != 0) {
      v88[0] ^= 0x5Au;
    }
    int v48 = ccec_verify_msg_ws((uint64_t)v80, (unint64_t **)v45, v38, 0x80uLL, v40, v42, v88, 0);
    if (v48) {
      break;
    }
    uint64_t v81 = v77;
    uint64_t v35 = v79 + 1;
    v36 += 8;
    if (v79 == 3)
    {
      int v49 = 0;
      char v47 = v75;
      goto LABEL_33;
    }
  }
  int v52 = v48;
  uint64_t v53 = mach_absolute_time();
  printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccec_verify_msg (P-%zu/SHA-%zu): %d\n", v53, "fipspost_post_ecdsa_verify_ws", 200, v69, 8 * v44, v52);
LABEL_32:
  uint64_t v81 = v77;
  uint64_t v54 = mach_absolute_time();
  printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ECDSA_P%zu_SHA%zu_VER KAT #%zu\n", v54, "fipspost_post_ecdsa_kat_verify_ws", 245, v73, 8 * v71, v79);
  int v49 = -75;
LABEL_33:
  uint64_t v81 = 0;
  uint64_t v30 = v49 | v67;
  if ((v47 & 0x10) != 0)
  {
    uint64_t v55 = (uint64_t *)ccec_cp_224();
    uint64_t v56 = v82(v80, (4 * (*v55 & 0x7FFFFFFFFFFFFFFLL)) | 2);
    *(void *)uint64_t v56 = v55;
    if (ccec_x963_import_priv_ws((uint64_t)v80, v55, 0x55uLL, byte_2373B48E0, (uint64_t **)v56))
    {
      uint64_t v57 = mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccec_x963_import_priv\n", v57, "fipspost_post_ecdsa_pairwise_ws", 277);
      int v58 = -72;
    }
    else
    {
      int v59 = ccec_pairwise_consistency_check_ws((uint64_t)v80, (unint64_t **)v56, (uint64_t (**)(void, unint64_t, void *))&ccrng_zero);
      mach_absolute_time();
      if (v59) {
        printf("FIPSPOST_USER [%llu] %s:%d: FAILED: [PCT] CCEC_PAIRWISE_CONSISTENCY: unexpected FAILURE\n");
      }
      else {
        printf("FIPSPOST_USER [%llu] %s:%d: [PCT] CCEC_PAIRWISE_CONSISTENCY: expected SUCCESS\n");
      }
      *(void *)(v56 + 24) ^= 1uLL;
      int v60 = ccec_pairwise_consistency_check_ws((uint64_t)v80, (unint64_t **)v56, (uint64_t (**)(void, unint64_t, void *))&ccrng_zero);
      uint64_t v61 = mach_absolute_time();
      if (v60)
      {
        printf("FIPSPOST_USER [%llu] %s:%d: [PCT] CCEC_PAIRWISE_CONSISTENCY: FORCEFAIL\n", v61, "fipspost_post_ecdsa_pairwise_ws", 295);
        int v58 = 0;
      }
      else
      {
        printf("FIPSPOST_USER [%llu] %s:%d: FAILED: [PCT] CCEC_PAIRWISE_CONSISTENCY: unexpected SUCCESS\n", v61, "fipspost_post_ecdsa_pairwise_ws", 298);
        int v58 = -1;
      }
    }
    uint64_t v81 = 0;
    uint64_t v30 = v58 | v30;
  }
  v83((uint64_t)v80);
  return v30;
}

uint64_t ccder_blob_decode_uint_n(unsigned __int8 **a1, unint64_t *a2)
{
  unint64_t v5 = 0;
  unint64_t v6 = 0;
  uint64_t result = ccder_blob_decode_range(a1, 2, (unsigned __int8 **)&v5);
  if (result)
  {
    uint64_t v4 = (unsigned __int8 *)v5;
    if (v5 != (char *)v6 && (*v5 & 0x80000000) == 0)
    {
      if (*v5) {
        goto LABEL_5;
      }
      uint64_t v4 = (unsigned __int8 *)(v5 + 1);
      if (v5 + 1 == (char *)v6)
      {
        uint64_t v4 = v6;
        goto LABEL_5;
      }
      if ((char)*v4 < 0)
      {
LABEL_5:
        *a2 = (unint64_t)(v6 - v4 + 7) >> 3;
        return 1;
      }
    }
    return 0;
  }
  return result;
}

void *ccaes_cfb_decrypt_mode()
{
  uint64_t v0 = ccaes_ecb_encrypt_mode();
  ccmode_factory_cfb_decrypt(cfb_decrypt, v0);
  return cfb_decrypt;
}

uint64_t ccmode_siv_hmac_decrypt(rsize_t *a1, unint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v22 = *MEMORY[0x263EF8C08];
  uint64_t v4 = *(void *)(*a1 + 64);
  if (*(void *)(v4 + 16) != 16) {
    return 4294967226;
  }
  unint64_t v6 = a1[3];
  BOOL v7 = v6 > 6;
  uint64_t v8 = (1 << v6) & 0x54;
  if (v7 || v8 == 0) {
    return 4294967228;
  }
  rsize_t v10 = a1[2];
  rsize_t v11 = a2 - v10;
  if (a2 < v10) {
    return 4294967229;
  }
  __memcpy_chk();
  long long v19 = v21[0];
  if (ccmode_siv_hmac_temp_key_gen(a1, v18, &v19)
    || (BYTE8(v19) &= ~0x80u,
        BYTE12(v19) &= ~0x80u,
        int v15 = ccctr_one_shot_internal(v4, a1[1] >> 1, (uint64_t)v18, (uint64_t)&v19, v11, a3 + v10, (uint64_t)a4),
        int v16 = ccmode_siv_hmac_auth_finalize(a1, v11, (uint64_t)a4, __s),
        v16 | cc_cmp_safe_internal(v10, __s, (char *)v21) | v15))
  {
    cc_clear(v11, a4);
    cc_clear(v10, __s);
    ccmode_siv_hmac_reset((uint64_t)a1);
    uint64_t v12 = 4294967192;
  }
  else
  {
    uint64_t v12 = 0;
  }
  cc_clear(a1[1] >> 1, v18);
  return v12;
}

uint64_t ccckg_contributor_commit(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v34 = *MEMORY[0x263EF8C08];
  BOOL v32 = timingsafe_enable_if_supported();
  uint64_t v6 = ccckg_ctx_di(a1);
  BOOL v7 = (unint64_t *)ccckg_ctx_cp(a1);
  uint64_t v8 = v7 + 4;
  unint64_t v9 = *v7;
  MEMORY[0x270FA53B0](v7, v10, v11, v12);
  uint64_t v14 = (uint64_t *)((char *)&v27 - v13);
  if (*(unsigned char *)(a1 + 32))
  {
    uint64_t scalar_fips_retry_ws = 4294967210;
  }
  else
  {
    uint64_t v29 = a3;
    uint64_t v16 = cczp_n((uint64_t)&v8[5 * v9]);
    unint64_t v17 = cc_malloc_clear(8 * v16);
    v30[0] = v17;
    v30[1] = cczp_n((uint64_t)&v8[5 * v9]);
    v30[2] = 0;
    v30[3] = cc_ws_alloc;
    int v31 = cc_ws_free;
    if (v17)
    {
      if (ccckg_sizeof_commitment((uint64_t)v7, v6) == a2)
      {
        uint64_t v18 = a1 + 40;
        uint64_t scalar_fips_retry_ws = ccec_generate_scalar_fips_retry_ws((uint64_t)v30, v7, *(uint64_t (***)(void, unint64_t, void *))(a1 + 24), (void *)(a1 + 40));
        if (!scalar_fips_retry_ws)
        {
          long long v19 = *(uint64_t (***)(void, unint64_t, uint64_t))(a1 + 24);
          uint64_t v28 = *v19;
          unint64_t v20 = *(void *)v6;
          uint64_t v21 = (void *)ccckg_ctx_cp(a1);
          uint64_t scalar_fips_retry_ws = v28(v19, v20, v18 + 8 * *v21);
          if (!scalar_fips_retry_ws)
          {
            uint64_t v22 = cczp_bitlen((uint64_t)&v8[5 * *v7]);
            ccn_write_uint_padded_internal(v9, (unint64_t *)(a1 + 40), (unint64_t)(v22 + 7) >> 3, __src);
            ccdigest_init_internal(v6, v14);
            uint64_t v23 = cczp_bitlen((uint64_t)&v8[5 * *v7]);
            ccdigest_update_internal((unint64_t *)v6, v14, (unint64_t)(v23 + 7) >> 3, __src);
            size_t v24 = *(void *)v6;
            uint64_t v25 = (void *)ccckg_ctx_cp(a1);
            ccdigest_update_internal((unint64_t *)v6, v14, v24, (char *)(v18 + 8 * *v25));
            (*(void (**)(uint64_t, void *, uint64_t))(v6 + 56))(v6, v14, v29);
            cc_clear(*(void *)(v6 + 8) + *(void *)(v6 + 16) + 12, v14);
            uint64_t scalar_fips_retry_ws = 0;
            *(unsigned char *)(a1 + 32) = 1;
          }
        }
      }
      else
      {
        uint64_t scalar_fips_retry_ws = 4294967289;
      }
      v31((uint64_t)v30);
      cc_clear(0x42uLL, __src);
    }
    else
    {
      uint64_t scalar_fips_retry_ws = 4294967283;
    }
  }
  cc_disable_dit_with_sb((unsigned int *)&v32);
  return scalar_fips_retry_ws;
}

uint64_t ccckg_contributor_finish_derive_p_ws(uint64_t a1, uint64_t a2, unsigned char *a3, uint64_t a4, uint64_t (**a5)(void, uint64_t, unint64_t *))
{
  unint64_t v9 = (uint64_t *)ccckg_ctx_cp(a2);
  if (*a3 != 4) {
    return 4294967289;
  }
  uint64_t v10 = v9;
  uint64_t v11 = *v9;
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 3 * *v9);
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 3 * v11);
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 3 * v11);
  int v15 = (uint64_t **)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, (unint64_t)(24 * v11 + 23) >> 3);
  uint64_t *v15 = v10;
  uint64_t v16 = cczp_bitlen((uint64_t)v10);
  uint64_t result = ccec_raw_import_pub(v10, ((unint64_t)(v16 + 7) >> 2) & 0x3FFFFFFFFFFFFFFELL, a3 + 1, v15);
  if (!result)
  {
    uint64_t result = ccec_validate_point_and_projectify_ws(a1, v10, v12, (uint64_t)(v15 + 2));
    if (!result)
    {
      uint64_t result = ccec_projectify_ws(a1, (uint64_t)v10);
      if (!result)
      {
        uint64_t result = ccec_mult_blinded_ws(a1, (unint64_t *)v10, v13, a2 + 40, v14, a5);
        if (!result)
        {
          ccec_full_add_ws(a1, (uint64_t)v10);
          uint64_t result = ccec_affinify_ws(a1, (uint64_t)v10);
        }
      }
    }
  }
  *(void *)(a1 + 16) = v18;
  return result;
}

uint64_t ccckg_contributor_finish(uint64_t a1, uint64_t a2, unsigned char *a3, uint64_t a4, char *a5, void *a6, uint64_t a7, char *a8)
{
  BOOL v40 = timingsafe_enable_if_supported();
  int v15 = (uint64_t *)ccckg_ctx_cp(a1);
  uint64_t v16 = *v15;
  uint64_t v17 = sizeof_struct_cche_galois_key();
  unint64_t v18 = sizeof_struct_ccpolyzp_po2cyc();
  v36[0] = cc_malloc_clear((v16 << 8) + 8 * ((v17 + v18 + 3 * v16 * v18 - 1) / v18));
  uint64_t v19 = *v15;
  uint64_t v20 = sizeof_struct_cche_galois_key();
  unint64_t v21 = sizeof_struct_ccpolyzp_po2cyc();
  v36[1] = (v20 + v21 + 3 * v19 * v21 - 1) / v21 + 32 * v19;
  uint64_t v37 = 0;
  BOOL v38 = cc_ws_alloc;
  uint64_t v39 = cc_ws_free;
  if (v36[0])
  {
    uint64_t v22 = (size_t *)ccckg_ctx_di(a1);
    uint64_t v23 = *(uint64_t (***)(void, uint64_t, unint64_t *))(a1 + 24);
    size_t v24 = (unint64_t *)ccckg_ctx_cp(a1);
    if (*(unsigned char *)(a1 + 32) == 1)
    {
      uint64_t v25 = v24;
      if ((unint64_t *)*a6 == v24
        && (unint64_t v34 = *v24, ccckg_sizeof_share((uint64_t)v24, v22) == a2)
        && ccckg_sizeof_opening(v25, v22) == a4
        && *a3 == 4)
      {
        uint64_t v26 = ccckg_contributor_finish_derive_p_ws((uint64_t)v36, a1, a3, (uint64_t)a6, v23);
        if (v26)
        {
          uint64_t v29 = v26;
        }
        else
        {
          uint64_t v27 = a1 + 40 + 8 * *(void *)ccckg_ctx_cp(a1);
          uint64_t v28 = cczp_bitlen((uint64_t)v25);
          uint64_t v29 = ccckg_derive_sk(a1, a6 + 2, v27, (uint64_t)&a3[((unint64_t)(v28 + 7) >> 2) | 1], a7, a8);
          if (!v29)
          {
            uint64_t v30 = cczp_bitlen((uint64_t)&v25[5 * *v25 + 4]);
            ccn_write_uint_padded_internal(v34, (unint64_t *)(a1 + 40), (unint64_t)(v30 + 7) >> 3, a5);
            int v31 = &a5[(unint64_t)(cczp_bitlen((uint64_t)&v25[5 * *v25 + 4]) + 7) >> 3];
            BOOL v32 = (void *)ccckg_ctx_cp(a1);
            memcpy(v31, (const void *)(a1 + 40 + 8 * *v32), *v22);
            *(unsigned char *)(a1 + 32) = 3;
          }
        }
        uint64_t v37 = 0;
        v39((uint64_t)v36);
      }
      else
      {
        uint64_t v29 = 4294967289;
        cc_ws_free((uint64_t)v36);
      }
    }
    else
    {
      uint64_t v29 = 4294967210;
      cc_ws_free((uint64_t)v36);
    }
  }
  else
  {
    uint64_t v29 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v40);
  return v29;
}

uint64_t ccsae_sizeof_kck()
{
  return 32;
}

uint64_t ccsae_sizeof_kck_h2c(uint64_t a1)
{
  return **(void **)(a1 + 16);
}

uint64_t ccsae_sizeof_kck_internal(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 28);
  if (v1 == 2) {
    return **(void **)(a1 + 16);
  }
  if (v1 == 1) {
    return 32;
  }
  return 0;
}

uint64_t ccsae_get_keys(unint64_t **a1, void *a2, _OWORD *a3, _OWORD *a4)
{
  BOOL v24 = timingsafe_enable_if_supported();
  uint64_t v8 = *a1;
  v20[0] = cc_malloc_clear(24 * **a1);
  v20[1] = 3 * *v8;
  uint64_t v21 = 0;
  uint64_t v22 = cc_ws_alloc;
  uint64_t v23 = cc_ws_free;
  if (v20[0])
  {
    if (*((unsigned __int8 *)a1 + 24) >= CCSAE_STATE_COMMIT_BOTH)
    {
      uint64_t v10 = *a1;
      unint64_t v11 = **a1;
      unint64_t v12 = (unint64_t)(cczp_bitlen((uint64_t)*a1) + 7) >> 3;
      uint64_t v13 = (uint64_t)&v10[5 * *v10 + 4];
      uint64_t v14 = (unint64_t *)cc_ws_alloc(v20, v11);
      int v15 = (char *)v22(v20, v11);
      cczp_add_ws((uint64_t)v20, v13);
      ccn_write_uint_padded_internal(v11, v14, v12, v15);
      int v16 = *((_DWORD *)a1 + 7);
      if (v16 == 2)
      {
        size_t v17 = *a1[2];
      }
      else if (v16 == 1)
      {
        size_t v17 = 32;
      }
      else
      {
        size_t v17 = 0;
      }
      memcpy(a2, a1 + 6, v17);
      uint64_t v9 = 0;
      long long v18 = *((_OWORD *)a1 + 8);
      *a3 = *((_OWORD *)a1 + 7);
      a3[1] = v18;
      *a4 = *(_OWORD *)v15;
      uint64_t v21 = 0;
      v23((uint64_t)v20);
    }
    else
    {
      uint64_t v9 = 4294967210;
      cc_ws_free((uint64_t)v20);
    }
  }
  else
  {
    uint64_t v9 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v24);
  return v9;
}

uint64_t ccckg2_owner_generate_share(uint64_t a1, size_t a2, const void *a3, uint64_t a4, char *a5, uint64_t (**a6)(void, uint64_t, unint64_t *))
{
  BOOL v37 = timingsafe_enable_if_supported();
  unint64_t v12 = (uint64_t *)ccckg2_ctx_cp(a1);
  uint64_t v13 = *v12;
  uint64_t v14 = sizeof_struct_cche_galois_key();
  unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
  v33[0] = cc_malloc_clear(392 * v13 + 16 * ((v14 + v15 + 4 * v13 * v15 - 1) / v15));
  uint64_t v16 = *v12;
  uint64_t v17 = sizeof_struct_cche_galois_key();
  unint64_t v18 = sizeof_struct_ccpolyzp_po2cyc();
  v33[1] = 49 * v16 + 2 * ((v17 + v18 + 4 * v16 * v18 - 1) / v18);
  uint64_t v34 = 0;
  uint64_t v35 = cc_ws_alloc;
  int v36 = cc_ws_free;
  if (v33[0])
  {
    uint64_t v19 = (void *)ccckg2_ctx_di(a1);
    uint64_t v20 = (unint64_t *)ccckg2_ctx_cp(a1);
    if (*(unsigned char *)(a1 + 32))
    {
      uint64_t v21 = 4294967210;
      cc_ws_free((uint64_t)v33);
    }
    else if (*v19 == a2 {
           && (uint64_t v22 = v20,
    }
               uint64_t v23 = *v20,
               (((unint64_t)(cczp_bitlen((uint64_t)v20) + 7) >> 1) & 0x7FFFFFFFFFFFFFFCLL | 2) == a4))
    {
      uint64_t v32 = v23;
      BOOL v24 = (unint64_t **)cc_ws_alloc(v33, (4 * (v23 & 0x7FFFFFFFFFFFFFFLL)) | 2);
      *BOOL v24 = v22;
      uint64_t v25 = (uint64_t *)v35(v33, (4 * (v23 & 0x7FFFFFFFFFFFFFFLL)) | 2);
      *uint64_t v25 = (uint64_t)v22;
      uint64_t v26 = (void *)ccckg2_ctx_cp(a1);
      uint64_t v27 = (void *)ccckg2_ctx_cp(a1);
      memcpy((void *)(a1 + 40 + 8 * *v27 + 8 * *v26), a3, a2);
      key_fips_uint64_t ws = ccec_generate_key_fips_ws((uint64_t)v33, v22, a6, v24);
      if (key_fips_ws
        || (ccn_set(v32, (void *)(a1 + 40), &v24[3 * **v24 + 2]),
            key_fips_uint64_t ws = ccec_generate_key_fips_ws((uint64_t)v33, v22, a6, (unint64_t **)v25),
            key_fips_ws)
        || (uint64_t v29 = (void *)ccckg2_ctx_cp(a1),
            ccn_set(v32, (void *)(a1 + 40 + 8 * *v29), &v25[3 * *(void *)*v25 + 2]),
            key_fips_uint64_t ws = ccec_export_pub((uint64_t *)v24, a5),
            key_fips_ws))
      {
        uint64_t v21 = key_fips_ws;
      }
      else
      {
        uint64_t v30 = cczp_bitlen((uint64_t)v22);
        uint64_t v21 = ccec_export_pub(v25, &a5[((unint64_t)(v30 + 7) >> 2) | 1]);
        if (!v21) {
          *(unsigned char *)(a1 + 32) = 2;
        }
      }
      uint64_t v34 = 0;
      v36((uint64_t)v33);
    }
    else
    {
      uint64_t v21 = 4294967289;
      cc_ws_free((uint64_t)v33);
    }
  }
  else
  {
    uint64_t v21 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v37);
  return v21;
}

uint64_t ccckg2_owner_finish(uint64_t a1, size_t a2, char *a3, unint64_t **a4, uint64_t a5, char *a6, uint64_t (**a7)(void, uint64_t, unint64_t *))
{
  uint64_t v28 = *MEMORY[0x263EF8C08];
  BOOL v26 = timingsafe_enable_if_supported();
  uint64_t v14 = (uint64_t *)ccckg2_ctx_di(a1);
  unint64_t v15 = (unint64_t *)ccckg2_ctx_cp(a1);
  if (*(unsigned char *)(a1 + 32) == 2)
  {
    uint64_t v16 = v15;
    if (*a4 == v15
      && (uint64_t v25 = a6,
          unint64_t v17 = cczp_bitlen((uint64_t)&v15[5 * *v15 + 4]) + 7,
          (((unint64_t)(cczp_bitlen((uint64_t)v16) + 7) >> 2) | 1) + (v17 >> 3) == a2))
    {
      ccdigest_internal((uint64_t)v14, a2, a3, (uint64_t)__s);
      uint64_t v18 = *v14;
      uint64_t v19 = (void *)ccckg2_ctx_cp(a1);
      uint64_t v20 = (void *)ccckg2_ctx_cp(a1);
      if (cc_cmp_safe_internal(v18, __s, (char *)(a1 + 8 * *v20 + 8 * *v19 + 40)))
      {
        uint64_t v21 = 4294967294;
      }
      else
      {
        uint64_t v23 = ccckg_owner_finish_derive_p(a1, (uint64_t)a3, a4, a7);
        if (v23)
        {
          uint64_t v21 = v23;
        }
        else
        {
          uint64_t v24 = cczp_bitlen((uint64_t)&v16[5 * *v16 + 4]);
          uint64_t v21 = ccckg2_derive_sk(a1, &a3[(unint64_t)(v24 + 7) >> 3], (uint64_t)a4, a5, v25, a7);
          if (!v21) {
            *(unsigned char *)(a1 + 32) = 3;
          }
        }
      }
      cc_clear(0x40uLL, __s);
    }
    else
    {
      uint64_t v21 = 4294967289;
    }
  }
  else
  {
    uint64_t v21 = 4294967210;
  }
  cc_disable_dit_with_sb((unsigned int *)&v26);
  return v21;
}

uint64_t fipspost_post_kdf_ctr_cmac(char a1)
{
  uint64_t v24 = *MEMORY[0x263EF8C08];
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  unint64_t v2 = ccaes_cbc_encrypt_mode();
  if (ccnistkdf_ctr_cmac_fixed(v2, 32, 16, (uint64_t)"\xC1\x0B\x15.\x8C\x97\xB7~\x18pN\x0F\v\x05", 0x3CuLL, byte_2373B4E45, 0x10uLL, (char *)&v22))
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccnistkdf_ctr_cmac_fixed (AES128): %d\n");
    return 4294967224;
  }
  uint64_t v3 = "\x01&\xFA\xF6\x19\x08\xAD\x9E0\\\"\x1D\xB5?";
  if ((a1 & 0x10) == 0) {
    uint64_t v3 = "&\xFA\xF6\x19\x08\xAD\x9E0\\\"\x1D\xB5?";
  }
  uint64_t v5 = *(void *)v3;
  uint64_t v4 = *((void *)v3 + 1);
  if (v5 == v22 && v4 == v23)
  {
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v7 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed CMAC_AES128 KAT\n", v7, "fipspost_post_kdf_ctr_cmac", 69);
    uint64_t v8 = 4294967221;
  }
  long long v20 = 0u;
  long long v21 = 0u;
  uint64_t v9 = ccaes_cbc_encrypt_mode();
  if (ccnistkdf_ctr_cmac_fixed(v9, 24, 32, (uint64_t)"Mq\x922\x80\xFBJ\x11\xB2_\x9DX\xD6\x77\x04\xD8\xF8\xBB-d\xE6\xF3\xDE2\xE4\x60\x1E\xFC", 0x3CuLL, "\xE2\x7B\x8F5\v\xC1\x36\r\xDC\x47l\xB0\xCA\xE8\x86\xF0\x16\x1D\xA2.\xE8\x15\x9C3\x0FTZ\xF1\xD7\x82\xA0\xF0\xAA\xCC\x3C=\xE6\x21\x58\a\x16\x1D\xF0\x93\x36\xD4p\xB5\xB4\xDB\x1C\xC0\xCEs\xED\x1D\x3E\xA2C\x80", 0x20uLL, (char *)&v20))
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccnistkdf_ctr_cmac_fixed (AES256): %d\n");
    return 4294967224;
  }
  unint64_t v11 = "\x01\xB5\xB2\xBBg_\xE7\xB0\x4AR4\v\xD5\xCF$\x8DRX\xA1\xF87\xDA\xD7G\xEE\x8A\x4E\x90F\b\xA8\x97}";
  if ((a1 & 0x10) == 0) {
    unint64_t v11 = "\xB5\xB2\xBBg_\xE7\xB0\x4AR4\v\xD5\xCF$\x8DRX\xA1\xF87\xDA\xD7G\xEE\x8A\x4E\x90F\b\xA8\x97}";
  }
  uint64_t v12 = *(void *)v11;
  uint64_t v13 = *((void *)v11 + 1);
  uint64_t v15 = *((void *)v11 + 2);
  uint64_t v14 = *((void *)v11 + 3);
  if (v12 != (void)v20 || v13 != *((void *)&v20 + 1) || v15 != (void)v21 || v14 != *((void *)&v21 + 1))
  {
    uint64_t v19 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed CMAC_AES256 KAT\n", v19, "fipspost_post_kdf_ctr_cmac", 122);
    return 4294967221;
  }
  return v8;
}

uint64_t ccn_mux(uint64_t result, char a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  unint64_t v5 = state ^ (state << 13) ^ ((state ^ (unint64_t)(state << 13)) >> 7);
  uint64_t v6 = v5 ^ (v5 << 17);
  state = v6;
  for (uint64_t i = __ROR8__(0x5555555555555555, a2 | (2 * v6)); result; --result)
  {
    uint64_t v9 = *a4++;
    uint64_t v8 = v9;
    uint64_t v10 = *a5++;
    *a3 = v10 ^ v6;
    *a3++ = (v10 ^ v8) & 0x5555555555555555 ^ v10 ^ v6 ^ (v10 ^ v8) & i ^ v6;
  }
  return result;
}

uint64_t ccn_mux_next_mask()
{
  unint64_t v0 = state ^ (state << 13) ^ ((state ^ (unint64_t)(state << 13)) >> 7);
  uint64_t result = v0 ^ (v0 << 17);
  state = result;
  return result;
}

uint64_t ccn_mux_seed_mask(uint64_t result)
{
  state ^= result;
  return result;
}

unint64_t cche_galois_key_nof_n(uint64_t a1, unsigned int a2)
{
  unint64_t v4 = ((unint64_t)(sizeof_struct_cche_galois_key() + 7) >> 3) + ((4 * (unint64_t)a2 + 7) >> 3);
  int v5 = cche_param_ctx_key_ctx_nmoduli(a1);
  if ((v5 - 1) <= 1) {
    int v6 = 1;
  }
  else {
    int v6 = v5 - 1;
  }
  int v7 = cche_param_ctx_polynomial_degree(a1);
  uint64_t v8 = v6 * a2;
  unsigned int v9 = cche_ciphertext_fresh_npolys();
  uint64_t v10 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v11 = sizeof_struct_ccpolyzp_po2cyc();
  return v4
       + ((v10 + v11 - 1) / v11
        + ((v7 * v5) + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3)) * v9)
       * v8;
}

uint64_t cche_galois_key_ciphertext(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  uint64_t v7 = cche_param_ctx_chain_const(*(void *)a1);
  int v8 = *(_DWORD *)(v7 + 12);
  int v9 = v8 - 1;
  if ((v8 - 1) <= 1) {
    int v9 = 1;
  }
  uint64_t v10 = a1 + ((4 * v6 + 7) & 0x7FFFFFFF8);
  uint64_t v11 = (v9 * a2);
  unsigned int v12 = cche_ciphertext_fresh_npolys();
  uint64_t v13 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v14 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v15 = (v13 + v14 - 1) / v14
      + ((*(_DWORD *)(v7 + 8) * v8) + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3))
      * v12;
  return v10 + 8 * v15 * v11 + 8 * v15 * a3 + 16;
}

uint64_t cche_galois_key_generate_ws(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned int **a5, uint64_t a6, int a7, uint64_t a8, uint64_t (**a9)(void, uint64_t, uint64_t))
{
  if (a3)
  {
    uint64_t v11 = a6;
    int v14 = cche_param_ctx_ciphertext_ctx_nmoduli(a6);
    int v15 = v14;
    if (!a7 || cche_rng_seed_sizeof() * (v14 * a3) == a7)
    {
      uint64_t v16 = 0;
      *(void *)a2 = v11;
      *(_DWORD *)(a2 + 8) = a3;
      while (!v16)
      {
LABEL_9:
        if (++v16 == a3)
        {
          unsigned int v18 = 0;
          uint64_t v61 = a8;
          unint64_t v64 = (unsigned int *)v11;
          uint64_t v60 = a4;
          int v58 = v15;
          int v59 = a3;
          while (1)
          {
            uint64_t v19 = a8 ? a8 + cche_rng_seed_sizeof() * v18 * v15 : 0;
            unsigned int v20 = *(_DWORD *)(a4 + 4 * v18);
            uint64_t v21 = cche_param_ctx_chain_const(v11);
            if (*(_DWORD *)(v21 + 12) < 2u) {
              return 4294967289;
            }
            uint64_t v22 = v21;
            unsigned int v23 = cche_param_ctx_polynomial_degree(v11);
            uint64_t result = 4294967289;
            if (v23 > 0x100000) {
              return result;
            }
            v24.i32[0] = v23;
            uint8x8_t v26 = (uint8x8_t)vcnt_s8(v24);
            v26.i16[0] = vaddlv_u8(v26);
            if (v26.i32[0] != 1 || v20 < 2 || (v20 & 1) == 0 || 2 * v23 <= v20 || *(_DWORD *)(a2 + 8) <= v18) {
              return result;
            }
            int v66 = v18;
            *(_DWORD *)(a2 + 16 + 4 * v18) = v20;
            uint64_t v27 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 24);
            uint64_t v62 = *(void *)(a1 + 16);
            uint64_t v28 = sizeof_struct_ccpolyzp_po2cyc();
            uint64_t v29 = (uint64_t *)v27(a1, (*(_DWORD *)(v22 + 12) * *(_DWORD *)(v22 + 8))+ ((unint64_t)(v28 + 7) >> 3));
            *uint64_t v29 = (uint64_t)*a5;
            uint64_t result = ccpolyzp_po2cyc_eval_apply_galois(v29, a5, v20);
            if (result) {
              goto LABEL_47;
            }
            uint64_t v63 = (*(_DWORD *)(v22 + 12) - 1);
            if (*(_DWORD *)(v22 + 12) != 1)
            {
              unint64_t v30 = 0;
              uint64_t v31 = v23;
              while (1)
              {
                unint64_t v32 = (*(_DWORD *)(v22 + 12) - 1);
                uint64_t v33 = (void *)(v22 + 8);
                if (v30 < v32)
                {
                  uint64_t v33 = (void *)(v22 + 8);
                  do
                  {
                    uint64_t v33 = (void *)v33[14];
                    LODWORD(v32) = v32 - 1;
                  }
                  while (v32 > v30);
                }
                uint64_t v34 = cche_galois_key_ciphertext(a2, v66, v30);
                unsigned int v35 = *(_DWORD *)(v22 + 12);
                uint64_t v36 = v19 ? v19 + cche_rng_seed_sizeof() * v30 : 0;
                uint64_t result = cche_encrypt_zero_symmetric_eval_ws(a1, v34, v64, (uint64_t *)a5, v35, v36, a9);
                if (result) {
                  break;
                }
                uint64_t v37 = v33[2];
                uint64_t v38 = *(void *)(v22 + 24)
                    - v37 * (((unint64_t)v33[3] * (unsigned __int128)*(unint64_t *)(v22 + 24)) >> 64);
                uint64_t v39 = v38 - v37;
                if (v39 >= 0) {
                  uint64_t v38 = v39;
                }
                uint64_t v40 = v34 + 32;
                unsigned int v41 = *(_DWORD *)*v29 * v30;
                unsigned int v42 = **(_DWORD **)(v34 + 24) * v30;
                uint64_t v43 = v31;
                do
                {
                  uint64_t v44 = v29[v41 + 1];
                  unint64_t v45 = ((unint64_t)v44 * (unsigned __int128)(unint64_t)v38) >> 64;
                  uint64_t v46 = v44 * v38;
                  unint64_t v47 = v33[4];
                  uint64_t v48 = ((unint64_t)v46 * (unsigned __int128)v47) >> 64;
                  uint64_t v49 = (v45 * (unsigned __int128)v47) >> 64;
                  uint64_t v50 = v45 * v47;
                  BOOL v51 = __CFADD__(v48, v50);
                  uint64_t v52 = v48 + v50;
                  uint64_t v53 = v51;
                  uint64_t v54 = v53
                      + __CFADD__(v46 * v33[5], v52)
                      + v49
                      + v33[5] * v45
                      + (((unint64_t)v46 * (unsigned __int128)(unint64_t)v33[5]) >> 64);
                  uint64_t v55 = v33[2];
                  uint64_t v56 = v46 - v54 * v55;
                  if (v56 - v55 >= 0) {
                    v56 -= v55;
                  }
                  uint64_t v57 = v56 + *(void *)(v40 + 8 * v42);
                  if (v57 - v55 >= 0) {
                    v57 -= v55;
                  }
                  *(void *)(v40 + 8 * v42) = v57;
                  ++v41;
                  ++v42;
                  --v43;
                }
                while (v43);
                if (++v30 == v63) {
                  goto LABEL_43;
                }
              }
LABEL_47:
              *(void *)(a1 + 16) = v62;
              return result;
            }
LABEL_43:
            *(void *)(a1 + 16) = v62;
            unsigned int v18 = v66 + 1;
            int v15 = v58;
            a4 = v60;
            a8 = v61;
            uint64_t v11 = (uint64_t)v64;
            if (v66 + 1 == v59) {
              return 0;
            }
          }
        }
      }
      uint64_t v17 = 0;
      while (*(_DWORD *)(a4 + 4 * v17) != *(_DWORD *)(a4 + 4 * v16))
      {
        if (v16 == ++v17) {
          goto LABEL_9;
        }
      }
    }
  }
  return 4294967289;
}

uint64_t cche_galois_key_generate(uint64_t a1, int a2, uint64_t a3, unsigned int **a4, uint64_t a5, int a6, uint64_t a7, uint64_t (**a8)(void, uint64_t, uint64_t))
{
  BOOL v28 = timingsafe_enable_if_supported();
  unsigned int v14 = cche_param_ctx_key_ctx_nmoduli(a5);
  unsigned int v15 = cche_param_ctx_polynomial_degree(a5);
  uint64_t v16 = v15;
  unint64_t v17 = CCPOLYZP_PO2CYC_WORKSPACE_N(v15, v14);
  uint64_t v18 = CCHE_ENCRYPT_ZERO_SYMMETRIC_EVAL_WORKSPACE_N(v16, v14);
  v26[0] = cc_malloc_clear(8 * (v18 + v17));
  unsigned int v19 = cche_param_ctx_polynomial_degree(a5);
  uint64_t v20 = v19;
  unint64_t v21 = CCPOLYZP_PO2CYC_WORKSPACE_N(v19, v14);
  v26[1] = CCHE_ENCRYPT_ZERO_SYMMETRIC_EVAL_WORKSPACE_N(v20, v14) + v21;
  _OWORD v26[2] = 0;
  v26[3] = cc_ws_alloc;
  uint64_t v27 = cc_ws_free;
  if (v26[0])
  {
    uint64_t ws = cche_galois_key_generate_ws((uint64_t)v26, a1, a2, a3, a4, a5, a6, a7, a8);
    v27((uint64_t)v26);
  }
  else
  {
    uint64_t ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v28);
  return ws;
}

uint64_t cche_galois_key_save_ws(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = cche_param_ctx_chain_const(*(void *)a4);
  int v9 = *(_DWORD *)(a4 + 8);
  int v10 = *(_DWORD *)(v8 + 12) - 1;
  uint64_t v11 = ccpolyzp_po2cyc_serialize_poly_nbytes((unsigned int *)(v8 + 8), 0);
  if (v11 * (v10 * v9) != a2) {
    return 4294967289;
  }
  if (!v9) {
    return 0;
  }
  uint64_t v12 = v11;
  int v13 = 0;
  while (!v10)
  {
LABEL_8:
    if (++v13 == v9) {
      return 0;
    }
  }
  unsigned int v14 = 0;
  while (1)
  {
    uint64_t v15 = cche_galois_key_ciphertext(a4, v13, v14);
    uint64_t result = ccpolyzp_po2cyc_serialize_poly_ws(a1, v12, a3, 0, (unsigned int **)(v15 + 24));
    if (result) {
      return result;
    }
    a3 += v12;
    if (v10 == ++v14) {
      goto LABEL_8;
    }
  }
}

uint64_t cche_galois_key_save(int a1, uint64_t a2, uint64_t *a3)
{
  BOOL v13 = timingsafe_enable_if_supported();
  unsigned int v6 = cche_param_ctx_polynomial_degree(*a3);
  uint64_t v7 = CCPOLYZP_PO2CYC_SERIALIZE_POLY_WORKSPACE_N(v6);
  v11[0] = cc_malloc_clear(8 * v7);
  unsigned int v8 = cche_param_ctx_polynomial_degree(*a3);
  v11[1] = CCPOLYZP_PO2CYC_SERIALIZE_POLY_WORKSPACE_N(v8);
  void v11[2] = 0;
  v11[3] = cc_ws_alloc;
  uint64_t v12 = cc_ws_free;
  if (v11[0])
  {
    uint64_t v9 = cche_galois_key_save_ws((uint64_t)v11, a1, a2, (uint64_t)a3);
    v12((uint64_t)v11);
  }
  else
  {
    uint64_t v9 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v13);
  return v9;
}

uint64_t cche_galois_key_load_ws(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, int a8, uint64_t a9)
{
  if (a3)
  {
    uint64_t v12 = a5;
    uint64_t v15 = cche_param_ctx_chain_const(a5);
    int v16 = *(_DWORD *)(v15 + 12) - 1;
    uint64_t v17 = ccpolyzp_po2cyc_serialize_poly_nbytes((unsigned int *)(v15 + 8), 0);
    uint64_t v18 = cche_rng_seed_sizeof();
    uint64_t v19 = (v16 * a3);
    uint64_t v20 = v17 * v19;
    uint64_t v56 = v18;
    uint64_t v21 = v18 * v19;
    if (v20 == a6 && v21 == a8)
    {
      uint64_t v23 = 0;
      *(void *)a2 = v12;
      *(_DWORD *)(a2 + 8) = a3;
      while (!v23)
      {
LABEL_12:
        if (++v23 == a3)
        {
          uint64_t v47 = v17;
          int v48 = v16;
          uint64_t v49 = a7;
          unsigned int v25 = 0;
          uint64_t v51 = a4;
          int v50 = a3;
          while (1)
          {
            unsigned int v26 = *(_DWORD *)(a4 + 4 * v25);
            uint64_t v27 = cche_param_ctx_chain_const(v12);
            if (*(_DWORD *)(v27 + 12) < 2u) {
              return 4294967289;
            }
            uint64_t v28 = v27;
            unsigned int v29 = cche_param_ctx_polynomial_degree(v12);
            uint64_t result = 4294967289;
            if (v29 > 0x100000) {
              return result;
            }
            v30.i32[0] = v29;
            uint8x8_t v32 = (uint8x8_t)vcnt_s8(v30);
            v32.i16[0] = vaddlv_u8(v32);
            if (v32.i32[0] != 1) {
              return result;
            }
            if (v26 < 2) {
              return result;
            }
            if ((v26 & 1) == 0) {
              return result;
            }
            if (2 * v29 <= v26) {
              return result;
            }
            int v33 = v25;
            if (*(_DWORD *)(a2 + 8) <= v25) {
              return result;
            }
            uint64_t v34 = (_DWORD *)(v28 + 8);
            uint64_t v35 = ccpolyzp_po2cyc_serialize_poly_nbytes((unsigned int *)(v28 + 8), 0);
            *(_DWORD *)(a2 + 16 + 4 * v25) = v26;
            int v55 = *(_DWORD *)(v28 + 12) - 1;
            if (*(_DWORD *)(v28 + 12) != 1)
            {
              unsigned int v36 = 0;
              uint64_t v37 = v25 * v48;
              uint64_t v38 = v49 + v47 * v37;
              uint64_t v39 = a9 + v56 * v37;
              int v52 = v25;
              uint64_t v53 = v35;
              do
              {
                uint64_t v40 = cche_galois_key_ciphertext(a2, v33, v36);
                unsigned int v41 = cche_ciphertext_fresh_npolys();
                uint64_t v42 = v12;
                *(void *)uint64_t v40 = v12;
                *(_DWORD *)(v40 + 8) = v41;
                *(void *)(v40 + 16) = 1;
                *(void *)(v40 + 24) = v34;
                uint64_t v43 = (_DWORD **)(v40 + 24);
                if (v41 >= 2)
                {
                  uint64_t v44 = v41;
                  for (uint64_t i = 1; i != v44; ++i)
                  {
                    uint64_t v46 = *v43;
                    v43[((v46[1] * *v46) + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3))
                      * i] = v34;
                  }
                }
                uint64_t result = cche_deserialize_seeded_ciphertext_eval_ws(a1, v40, v53, v38);
                if (result) {
                  return result;
                }
                v38 += v53;
                v39 += v56;
                ++v36;
                uint64_t v12 = v42;
                int v33 = v52;
              }
              while (v36 != v55);
            }
            unsigned int v25 = v33 + 1;
            a4 = v51;
            if (v33 + 1 == v50) {
              return 0;
            }
          }
        }
      }
      uint64_t v24 = 0;
      while (*(_DWORD *)(a4 + 4 * v24) != *(_DWORD *)(a4 + 4 * v23))
      {
        if (v23 == ++v24) {
          goto LABEL_12;
        }
      }
    }
  }
  return 4294967289;
}

uint64_t cche_galois_key_load(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, int a7, uint64_t a8)
{
  BOOL v23 = timingsafe_enable_if_supported();
  unsigned int v16 = cche_param_ctx_polynomial_degree(a4);
  unint64_t v17 = CCHE_DESERIALIZE_SEEDED_CIPHERTEXT_EVAL_WORKSPACE_N(v16);
  v21[0] = cc_malloc_clear(8 * v17);
  unsigned int v18 = cche_param_ctx_polynomial_degree(a4);
  v21[1] = CCHE_DESERIALIZE_SEEDED_CIPHERTEXT_EVAL_WORKSPACE_N(v18);
  void v21[2] = 0;
  v21[3] = cc_ws_alloc;
  uint64_t v22 = cc_ws_free;
  if (v21[0])
  {
    uint64_t ws = cche_galois_key_load_ws((uint64_t)v21, a1, a2, a3, a4, a5, a6, a7, a8);
    v22((uint64_t)v21);
  }
  else
  {
    uint64_t ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v23);
  return ws;
}

unint64_t CCHE_CIPHERTEXT_GALOIS_KEY_SWITCH_WORKSPACE_N(uint64_t a1, int a2)
{
  unsigned int v4 = cche_ciphertext_fresh_npolys();
  uint64_t v5 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v6 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v7 = (v5 + v6 - 1) / v6;
  unint64_t v8 = sizeof_struct_ccpolyzp_po2cyc() + 7;
  unint64_t v9 = sizeof_struct_ccpolyzp_po2cyc_ctx() + 7;
  if (a1 >= 0x80) {
    uint64_t v10 = 128;
  }
  else {
    uint64_t v10 = a1;
  }
  unint64_t v11 = ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v10 + a1;
  return v7
       + a1
       + (v8 >> 3)
       + (v9 >> 3)
       + CCHE_CIPHERTEXT_MOD_SWITCH_DOWN_WORKSPACE_N(a1, a2)
       + ((a2 * a1) + 2 * a1 + (v8 >> 3)) * v4
       + 2 * v11
       + 6;
}

uint64_t cche_ciphertext_apply_galois_ws(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  unint64_t v5 = *(unsigned int *)(a5 + 8);
  if (!v5) {
    return 4294967289;
  }
  if (*(_DWORD *)(a5 + 16) != a4)
  {
    unint64_t v12 = 0;
    while (v5 - 1 != v12)
    {
      int v13 = *(_DWORD *)(a5 + 20 + 4 * v12++);
      if (v13 == a4)
      {
        BOOL v11 = v12 < v5;
        goto LABEL_8;
      }
    }
    return 4294967289;
  }
  BOOL v11 = 1;
LABEL_8:
  uint64_t result = 4294967289;
  if (a2 != a3 && v11)
  {
    if (*(_DWORD *)(a3 + 8))
    {
      uint64_t v15 = 0;
      unsigned int v16 = (_DWORD **)(a3 + 24);
      uint64_t v17 = a2 + 24;
      while (1)
      {
        unsigned int v18 = *v16;
        uint64_t v19 = sizeof_struct_ccpolyzp_po2cyc();
        uint64_t result = ccpolyzp_po2cyc_coeff_apply_galois((uint64_t *)(v17+ 8* ((*(_DWORD *)(*(void *)v17 + 4) * **(_DWORD **)v17)+ ((unint64_t)(v19 + 7) >> 3))* v15), &v16[((v18[1] * *v18) + ((unint64_t)(v19 + 7) >> 3)) * v15], a4);
        if (result) {
          break;
        }
        if (++v15 >= (unint64_t)*(unsigned int *)(a3 + 8)) {
          goto LABEL_14;
        }
      }
    }
    else
    {
LABEL_14:
      return cche_ciphertext_galois_key_switch_ws(a1, a2, a4, a5);
    }
  }
  return result;
}

uint64_t cche_ciphertext_galois_key_switch_ws(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  v113[2] = *MEMORY[0x263EF8C08];
  unint64_t v4 = *(unsigned int *)(a4 + 8);
  if (v4)
  {
    if (*(_DWORD *)(a4 + 16) != a3)
    {
      unint64_t v7 = 0;
      while (v4 - 1 != v7)
      {
        int v8 = *(_DWORD *)(a4 + 20 + 4 * v7++);
        if (v8 == a3)
        {
          if (v7 >= v4) {
            return 4294967289;
          }
          goto LABEL_7;
        }
      }
      return 4294967289;
    }
LABEL_7:
    int v9 = *(_DWORD *)(a2 + 8);
    if (v9 == cche_ciphertext_fresh_npolys())
    {
      uint64_t v93 = *(void *)(a1 + 16);
      uint64_t v10 = cche_param_ctx_chain_const(*(void *)a4);
      int v11 = *(_DWORD *)(v10 + 12);
      unsigned int v98 = (int **)(a2 + 24);
      int v103 = *(_DWORD *)(*(void *)(a2 + 24) + 4);
      unint64_t v12 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 24);
      unsigned int v13 = cche_ciphertext_fresh_npolys();
      uint64_t v14 = sizeof_struct_ccrns_mul_modulus();
      unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
      uint64_t v16 = sizeof_struct_ccpolyzp_po2cyc();
      uint64_t v102 = v10;
      uint64_t v17 = (unsigned int *)(v10 + 8);
      int v101 = v11;
      uint64_t v18 = v12(a1, (v14 + v15 - 1) / v15+ ((*(_DWORD *)(v10 + 8) * v11) + ((unint64_t)(v16 + 7) >> 3)) * v13);
      uint64_t v99 = a4;
      uint64_t v19 = *(void *)a4;
      unsigned int v20 = cche_ciphertext_fresh_npolys();
      *(void *)uint64_t v18 = v19;
      *(_DWORD *)(v18 + 8) = v20;
      *(void *)(v18 + 16) = 1;
      uint64_t v92 = v18;
      *(void *)(v18 + 24) = v17;
      uint64_t v21 = (_DWORD **)(v18 + 24);
      if (v20 >= 2)
      {
        uint64_t v22 = v20;
        for (uint64_t i = 1; i != v22; ++i)
        {
          uint64_t v24 = *v21;
          v21[((v24[1] * *v24) + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3)) * i] = v17;
        }
      }
      int v96 = v21;
      int v104 = v17;
      uint64_t v25 = *v17;
      unsigned int v26 = *(int **)(a2 + 24);
      uint64_t v27 = sizeof_struct_ccpolyzp_po2cyc();
      int v28 = *v26;
      int v29 = v26[1];
      uint64_t v106 = *(unsigned int *)(a2 + 8);
      uint64_t v30 = (2 * v25 * v106);
      uint64_t v31 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v30);
      uint8x8_t v32 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 24);
      uint64_t v33 = sizeof_struct_ccpolyzp_po2cyc();
      unint64_t v105 = (unsigned int **)v32(a1, v25 + ((unint64_t)(v33 + 7) >> 3));
      uint64_t v34 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 24);
      unint64_t v35 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
      if (v25 >= 0x80) {
        uint64_t v36 = 128;
      }
      else {
        uint64_t v36 = v25;
      }
      uint64_t v37 = sizeof_struct_ccrns_mul_modulus();
      uint64_t v112 = v25;
      unint64_t __dst = (_DWORD *)v34(a1, v35 + 2 * (v25 + ((unint64_t)(v37 + 7) >> 3) * v36) + 6);
      uint64_t v38 = v102;
      if (v101)
      {
        unsigned int v39 = 0;
        int v40 = v101 - 1;
        unsigned int v41 = (void *)(v102 + 24);
        rsize_t v42 = 8 * v30;
        unint64_t v94 = &(&v98[v29 * v28])[(unint64_t)(v27 + 7) >> 3];
        unsigned int v95 = v94 + 1;
        uint64_t v91 = 8 * v30;
        int v100 = 2 * v112;
        while (1)
        {
          unsigned int v43 = *(_DWORD *)(v38 + 12) - 1;
          if (v39 == v40) {
            int v44 = *(_DWORD *)(v38 + 12) - 1;
          }
          else {
            int v44 = v39;
          }
          int v110 = v44;
          unint64_t v45 = v104;
          if (v43 > v39)
          {
            unsigned int v46 = *(_DWORD *)(v38 + 12) - 1;
            uint64_t v47 = v104;
            do
            {
              uint64_t v47 = (void *)v47[14];
              --v46;
            }
            while (v46 > v39);
            unint64_t v45 = v104;
            do
            {
              unint64_t v45 = (void *)v45[14];
              --v43;
            }
            while (v43 > v39);
            unsigned int v41 = v47 + 2;
          }
          uint64_t v48 = *(unsigned int *)v45;
          unint64_t v49 = (sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) & 0xFFFFFFFFFFFFFFF8;
          uint64_t v50 = v48 >= 0x80 ? 128 : v48;
          size_t v51 = v49 + 16 * (v48 + ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v50) + 48;
          memmove(__dst, v45, v51);
          __dst[1] = 1;
          *((void *)__dst + 14) = 0;
          ccpolyzp_po2cyc_init_zero(v105, __dst);
          cc_clear(v42, v31);
          if (v103) {
            break;
          }
LABEL_50:
          if (v106)
          {
            int v67 = 0;
            uint64_t v68 = 0;
            uint64_t v69 = (*(_DWORD *)(*v96 + 4) * *(_DWORD *)*v96);
            do
            {
              if (v112)
              {
                uint64_t v70 = (_DWORD **)&v96[(v69 + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3)) * v68];
                size_t v72 = *v70;
                unint64_t v71 = v70 + 1;
                unsigned int v73 = v39 * *v72;
                uint64_t v74 = v112;
                int v75 = v67;
                do
                {
                  unint64_t v76 = &v31[8 * v75];
                  unint64_t v78 = *(void *)v76;
                  unint64_t v77 = *((void *)v76 + 1);
                  unint64_t v79 = v41[2];
                  uint64_t v80 = (v79 * (unsigned __int128)v78) >> 64;
                  uint64_t v81 = (v79 * (unsigned __int128)v77) >> 64;
                  uint64_t v82 = v79 * v77;
                  BOOL v83 = __CFADD__(v80, v82);
                  uint64_t v84 = v80 + v82;
                  uint64_t v85 = v83;
                  unint64_t v86 = (_DWORD *)(v78
                                 - (v85
                                  + __CFADD__(v41[3] * v78, v84)
                                  + v81
                                  + v41[3] * v77
                                  + (((unint64_t)v41[3] * (unsigned __int128)v78) >> 64))
                                 * *v41);
                  if ((uint64_t)v86 - *v41 >= 0) {
                    unint64_t v86 = (_DWORD *)((char *)v86 - *v41);
                  }
                  v71[v73++] = v86;
                  v75 += 2;
                  --v74;
                }
                while (v74);
              }
              ++v68;
              v67 += v100;
            }
            while (v68 != v106);
          }
          ++v39;
          int v40 = v101 - 1;
          rsize_t v42 = v91;
          unsigned int v41 = (void *)(v102 + 24);
          if (v39 == v101) {
            goto LABEL_62;
          }
        }
        unsigned int v52 = 0;
        while (1)
        {
          unsigned int v53 = *(_DWORD *)(v38 + 12) - 1;
          uint64_t v54 = v104;
          if (v53 > v52)
          {
            uint64_t v54 = v104;
            do
            {
              uint64_t v54 = (void *)v54[14];
              --v53;
            }
            while (v53 > v52);
          }
          uint64_t v55 = cche_galois_key_ciphertext(v99, 0, v52);
          if (v54[2] <= *v41)
          {
            memcpy(v105 + 1, &v95[**v94 * v52], 8 * v112);
          }
          else if (v112)
          {
            unsigned int v56 = **v94 * v52;
            uint64_t v57 = v112;
            int v58 = v105 + 1;
            do
            {
              int v59 = (char *)v95[v56]
                  - *v41 * (((unint64_t)v41[1] * (unsigned __int128)(unint64_t)v95[v56]) >> 64);
              if ((uint64_t)&v59[-*v41] >= 0) {
                v59 -= *v41;
              }
              *v58++ = v59;
              ++v56;
              --v57;
            }
            while (v57);
          }
          if (ccpolyzp_po2cyc_fwd_ntt(v105)) {
            break;
          }
          if (v106)
          {
            int v109 = 0;
            uint64_t v108 = 0;
            int v107 = (_DWORD **)(v55 + 24);
            while (1)
            {
              uint64_t v60 = *v107;
              uint64_t v61 = sizeof_struct_ccpolyzp_po2cyc();
              if (v112) {
                break;
              }
LABEL_48:
              v109 += v100;
              if (++v108 == v106) {
                goto LABEL_49;
              }
            }
            uint64_t v62 = 0;
            uint64_t v63 = &v107[((v60[1] * *v60) + ((unint64_t)(v61 + 7) >> 3)) * v108];
            int v64 = v109;
            uint64_t v65 = (unint64_t *)(v105 + 1);
            while (1)
            {
              int v66 = (unint64_t *)&v63[(v62 + **v63 * v110) + 1];
              v113[0] = 0;
              v113[1] = 0;
              ccn_mul(1uLL, (char *)v113, v66, v65);
              if (ccn_add_ws(a1, 2, &v31[8 * v64], (uint64_t *)&v31[8 * v64], v113)) {
                return 0xFFFFFFFFLL;
              }
              ++v62;
              ++v65;
              v64 += 2;
              if (v112 == v62) {
                goto LABEL_48;
              }
            }
          }
LABEL_49:
          ++v52;
          uint64_t v38 = v102;
          if (v52 == v103) {
            goto LABEL_50;
          }
        }
      }
      else
      {
LABEL_62:
        uint64_t result = cche_ciphertext_inv_ntt_internal(v92);
        if (result) {
          goto LABEL_66;
        }
        uint64_t result = cche_ciphertext_mod_switch_down_ws(a1, v92);
        if (result) {
          goto LABEL_66;
        }
        ccpolyzp_po2cyc_coeff_add(v98, (uint64_t)v98, v96);
        int v88 = *v98;
        uint64_t v89 = sizeof_struct_ccpolyzp_po2cyc();
        unint64_t v90 = &v96[(*(_DWORD *)(*v96 + 4) * *(_DWORD *)*v96) + ((unint64_t)(v89 + 7) >> 3)];
        memmove(&(&v98[v88[1] * *v88])[(unint64_t)(v89 + 7) >> 3], v90, (v89 + 7 + 8 * (*(_DWORD *)(*v90 + 4) * *(_DWORD *)*v90)) & 0xFFFFFFFFFFFFFFF8);
      }
      uint64_t result = 0;
LABEL_66:
      *(void *)(a1 + 16) = v93;
      return result;
    }
  }
  return 4294967289;
}

uint64_t cche_ciphertext_apply_galois(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v8 = cche_param_ctx_chain_const(*a4);
  unint64_t v9 = CCHE_CIPHERTEXT_GALOIS_KEY_SWITCH_WORKSPACE_N(*(unsigned int *)(v8 + 8), *(_DWORD *)(v8 + 12) + 1);
  v12[0] = cc_malloc_clear(8 * v9);
  v12[1] = CCHE_CIPHERTEXT_GALOIS_KEY_SWITCH_WORKSPACE_N(*(unsigned int *)(v8 + 8), *(_DWORD *)(v8 + 12) + 1);
  uint64_t v12[2] = 0;
  v12[3] = cc_ws_alloc;
  unsigned int v13 = cc_ws_free;
  if (v12[0])
  {
    uint64_t v10 = cche_ciphertext_apply_galois_ws((uint64_t)v12, a1, a2, a3, (uint64_t)a4);
    v13((uint64_t)v12);
  }
  else
  {
    uint64_t v10 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v10;
}

uint64_t cche_ciphertext_galois_elt_rotate_rows_left(_DWORD *a1, int a2, unsigned __int32 a3)
{
  BOOL v9 = timingsafe_enable_if_supported();
  uint64_t v7 = cche_galois_elt_from_step(a1, a2, a3, v6);
  cc_disable_dit_with_sb((unsigned int *)&v9);
  return v7;
}

uint64_t cche_galois_elt_from_step(_DWORD *a1, int a2, unsigned __int32 a3, int8x8_t a4)
{
  a4.i32[0] = a3;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(a4);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.i32[0] != 1) {
    return 4294967289;
  }
  unsigned int v5 = a2 >= 0 ? a2 : -a2;
  if (v5 >= a3 >> 1) {
    return 4294967289;
  }
  uint64_t v6 = 2 * a3 - 1;
  int v7 = v5 & v6;
  int v8 = (a3 >> 1) - v7;
  if (a2 >= 0) {
    int v8 = v7;
  }
  if (v8)
  {
    unint64_t v9 = 1;
    while (is_mul_ok(v9, 3uLL))
    {
      unint64_t v9 = (3 * v9) & v6;
      if (!--v8) {
        goto LABEL_14;
      }
    }
    return 0xFFFFFFFFLL;
  }
  else
  {
    LODWORD(v9) = 1;
LABEL_14:
    uint64_t v10 = 0;
    *a1 = v9;
  }
  return v10;
}

uint64_t cche_ciphertext_galois_elt_rotate_rows_right(_DWORD *a1, int a2, unsigned __int32 a3)
{
  BOOL v9 = timingsafe_enable_if_supported();
  uint64_t v7 = cche_galois_elt_from_step(a1, -a2, a3, v6);
  cc_disable_dit_with_sb((unsigned int *)&v9);
  return v7;
}

uint64_t cche_ciphertext_galois_elt_swap_columns(_DWORD *a1, __int32 a2)
{
  BOOL v8 = timingsafe_enable_if_supported();
  v4.i32[0] = a2;
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.i32[0] == 1)
  {
    uint64_t v6 = 0;
    *a1 = 2 * a2 - 1;
  }
  else
  {
    uint64_t v6 = 4294967289;
  }
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return v6;
}

uint64_t ccz_zero(void *a1)
{
  BOOL v3 = timingsafe_enable_if_supported();
  ccz_set_sign((uint64_t)a1, 1);
  ccz_set_n(a1, 0);
  return cc_disable_dit_with_sb((unsigned int *)&v3);
}

uint64_t ccmode_ccm_reset(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 64) = 1;
  return 0;
}

uint64_t ccn_set_bit(uint64_t result, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = 1 << a2;
  uint64_t v4 = (a2 >> 3) & 0x1FFFFFFFFFFFFFF8;
  if (a3) {
    uint64_t v5 = *(void *)(result + v4) | v3;
  }
  else {
    uint64_t v5 = *(void *)(result + v4) & ~v3;
  }
  *(void *)(result + v4) = v5;
  return result;
}

uint64_t ccn_write_uint_padded_internal(unint64_t a1, unint64_t *a2, unint64_t a3, char *a4)
{
  LODWORD(result) = ccn_write_uint_padded_ct_internal(a1, a2, a3, a4);
  if ((result & 0x80000000) == 0) {
    return result;
  }
  ccn_write_uint_internal(a1, a2, a3, a4);
  return 0;
}

uint64_t ccn_write_uint_padded(unint64_t a1, unint64_t *a2, unint64_t a3, char *a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = ccn_write_uint_padded_internal(a1, a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccn_zero(uint64_t a1, void *a2)
{
  return cc_clear(8 * a1, a2);
}

uint64_t ccn_seti(uint64_t a1, void *a2, uint64_t a3)
{
  *a2 = a3;
  return cc_clear(8 * a1 - 8, a2 + 1);
}

uint64_t ccn_swap(uint64_t result, unint64_t *a2)
{
  for (uint64_t i = &a2[result - 1]; a2 < i; --i)
  {
    unint64_t v3 = bswap64(*a2);
    *a2++ = bswap64(*i);
    *uint64_t i = v3;
  }
  if (result) {
    *a2 = bswap64(*a2);
  }
  return result;
}

uint64_t ccn_xor(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
    *(void *)(a2 - 8 + 8 * result) = *(void *)(a4 - 8 + 8 * result) ^ *(void *)(a3 - 8 + 8 * result);
  return result;
}

uint64_t cced25519_add_points_unified_ws(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, char a6)
{
  uint64_t v12 = cczp_n(a2);
  uint64_t v13 = *(void *)(a1 + 16);
  ccn_set(4 * v12, a3, a5);
  cced25519_point_to_cached_ws(a1, a2);
  uint64_t result = cced25519_add_points_unified_cached_ws(a1, a2, (uint64_t)a3, a4, (uint64_t)a3, a6);
  *(void *)(a1 + 16) = v13;
  return result;
}

uint64_t cced25519_point_to_cached_ws(uint64_t a1, uint64_t a2)
{
  cczp_n(a2);
  uint64_t v4 = *(void *)(a1 + 16);
  cczp_mul_ws(a1, a2);
  uint64_t result = cczp_add_ws(a1, a2);
  *(void *)(a1 + 16) = v4;
  return result;
}

uint64_t cced25519_add_points_unified_cached_ws(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  uint64_t v11 = cczp_n(a2);
  uint64_t v14 = *(void *)(a1 + 16);
  uint64_t v12 = (void *)(a3 + 24 * v11);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v11);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v11);
  if ((a6 & 2) != 0) {
    ccn_set(v11, v12, (void *)(a4 + 24 * v11));
  }
  else {
    cczp_mul_ws(a1, a2);
  }
  cczp_sub_ws(a1, a2);
  if (a6) {
    cczp_add_ws(a1, a2);
  }
  else {
    cczp_sub_ws(a1, a2);
  }
  cczp_mul_ws(a1, a2);
  cczp_add_ws(a1, a2);
  if (a6) {
    cczp_sub_ws(a1, a2);
  }
  else {
    cczp_add_ws(a1, a2);
  }
  cczp_mul_ws(a1, a2);
  cczp_sub_ws(a1, a2);
  cczp_add_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  cczp_add_ws(a1, a2);
  if ((a6 & 1) == 0)
  {
    cczp_sub_ws(a1, a2);
    cczp_add_ws(a1, a2);
    if ((a6 & 4) != 0) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  cczp_add_ws(a1, a2);
  cczp_sub_ws(a1, a2);
  if ((a6 & 4) == 0) {
LABEL_14:
  }
    cczp_mul_ws(a1, a2);
LABEL_15:
  cczp_mul_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  uint64_t result = cczp_mul_ws(a1, a2);
  *(void *)(a1 + 16) = v14;
  return result;
}

void cced25519_scalar_mult_ws()
{
}

uint64_t sub_237359C28()
{
  return 0xFFFFFFFFLL;
}

void *cced25519_double_scalar_mult_ws(uint64_t a1, void *a2, char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v25 = *MEMORY[0x263EF8C08];
  uint64_t v9 = cczp_n((uint64_t)a2);
  uint64_t v21 = *(void *)(a1 + 16);
  BOOL v10 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 4 * v9);
  uint64_t v11 = 32 * v9;
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 32 * v9);
  cced25519_to_ed25519_point_ws(a1, (uint64_t)a2);
  cced25519_point_to_cached_ws(a1, (uint64_t)a2);
  cced25519_dbl_point_ws(a1, (uint64_t)a2);
  uint64_t v13 = 7;
  uint64_t v14 = v12;
  do
  {
    uint64_t v15 = v14 + v11;
    cced25519_add_points_unified_cached_ws(a1, (uint64_t)a2, v14 + v11, (uint64_t)v10, v14, 0);
    cced25519_point_to_cached_ws(a1, (uint64_t)a2);
    uint64_t v14 = v15;
    --v13;
  }
  while (v13);
  cc_clear(8 * v9, v10);
  cc_clear(8 * v9, &v10[16 * v9]);
  ccn_seti(v9, &v10[8 * v9], 1);
  ccn_seti(v9, &v10[24 * v9], 1);
  ccn_recode_ssw(v9, a4, 4, (uint64_t)v24);
  ccn_recode_ssw(v9, a5, 4, (uint64_t)v23);
  uint64_t v16 = 255;
  do
  {
    int v17 = v24[v16];
    int v18 = v23[v16--];
  }
  while (!(v18 | v17));
  if (v16 != -2)
  {
    uint64_t v19 = v16 + 1;
    do
    {
      cced25519_dbl_point_ws(a1, (uint64_t)a2);
      cced25519_add_precomputed_point_ws(a1, (uint64_t)a2, (uint64_t)v10, (char)v23[v19], 4, v12, 0);
      cced25519_add_precomputed_point_ws(a1, (uint64_t)a2, (uint64_t)v10, (char)v24[v19--], 3, (uint64_t)&CCED25519_PRECOMPUTED_BASES, 6);
    }
    while (v19 != -1);
  }
  uint64_t result = cced25519_from_ed25519_point_ws(a1, a2, a3, v10);
  *(void *)(a1 + 16) = v21;
  return result;
}

uint64_t cced25519_dbl_point_ws(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = cczp_n(a2);
  uint64_t v6 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  cczp_add_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  cczp_add_ws(a1, a2);
  cczp_sub_ws(a1, a2);
  cczp_sub_ws(a1, a2);
  cczp_add_ws(a1, a2);
  cczp_add_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  uint64_t result = cczp_mul_ws(a1, a2);
  *(void *)(a1 + 16) = v6;
  return result;
}

uint64_t cced25519_add_precomputed_point_ws(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t result = cczp_n(a2);
  if (a4 >= 0) {
    LOBYTE(v15) = a4;
  }
  else {
    int v15 = -a4;
  }
  if ((char)v15 >= 1)
  {
    return cced25519_add_points_unified_cached_ws(a1, a2, a3, a3, a6 + 8 * (v15 >> 1) * a5 * result, a7 | ((a4 & 0x80) >> 7));
  }
  return result;
}

unint64_t ccdh_ramp_gp_exponent(unint64_t result, uint64_t *a2)
{
  if (!result || (unint64_t v3 = result, (result = ccdh_gp_l(a2)) == 0))
  {
    uint64_t v9 = 0;
    uint64_t v7 = *a2;
    uint64_t v8 = (uint64_t)&a2[*a2 + 3];
    goto LABEL_9;
  }
  unint64_t v4 = ccdh_gp_l(a2);
  uint64_t v5 = a2 + 3;
  if (v4 <= v3) {
    unint64_t v6 = v3;
  }
  else {
    unint64_t v6 = v4;
  }
  v5[*a2 + 1 + *a2 + *a2 + *a2] = v6;
  uint64_t result = ccdh_gp_l(a2);
  if (result <= 0x9F)
  {
    uint64_t v7 = *a2;
    uint64_t v8 = (uint64_t)&v5[*a2];
    uint64_t v9 = 160;
LABEL_9:
    *(void *)(v8 + 8 * v7 + 8 * v7 + 8 * v7 + 8) = v9;
  }
  return result;
}

unint64_t ccec_compressed_x962_export_pub_size(uint64_t a1)
{
  return ((unint64_t)(cczp_bitlen(a1) + 7) >> 3) + 1;
}

uint64_t ccec_compressed_x962_export_pub(uint64_t *a1, char *a2)
{
  unint64_t v3 = (unint64_t *)(a1 + 2);
  unint64_t v4 = (unint64_t *)*a1;
  unint64_t v6 = ((unint64_t)(cczp_bitlen(*a1) + 7) >> 3) + 1;
  return ccec_export_affine_point_public_value(v4, 3, v3, &v6, a2);
}

uint64_t ccmode_siv_hmac_encrypt(rsize_t *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v15 = *MEMORY[0x263EF8C08];
  uint64_t v4 = *(void *)(*a1 + 64);
  if (*(void *)(v4 + 16) != 16) {
    return 4294967226;
  }
  rsize_t v9 = a1[2];
  uint64_t v10 = ccmode_siv_hmac_auth_finalize(a1, a2, a3, __src);
  if (!v10)
  {
    long long v13 = __src[0];
    uint64_t v10 = ccmode_siv_hmac_temp_key_gen(a1, v12, &v13);
    if (v10
      || (BYTE8(v13) &= ~0x80u,
          BYTE12(v13) &= ~0x80u,
          uint64_t v10 = ccctr_one_shot_internal(v4, a1[1] >> 1, (uint64_t)v12, (uint64_t)&v13, a2, a3, (uint64_t)a4 + v9),
          v10))
    {
      cc_clear(v9 + a2, a4);
      cc_clear(v9, __src);
      ccmode_siv_hmac_reset((uint64_t)a1);
    }
    else
    {
      memcpy(a4, __src, v9);
    }
    cc_clear(a1[1] >> 1, v12);
  }
  return v10;
}

uint64_t ccec_double_ws(uint64_t a1, void *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, void))(a1 + 24))(a1, *a2);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  uint64_t result = cczp_sub_ws(a1, (uint64_t)a2);
  *(void *)(a1 + 16) = v5;
  return result;
}

unint64_t ccz_trailing_zeros(uint64_t a1)
{
  BOOL v5 = timingsafe_enable_if_supported();
  unint64_t v2 = ccz_n(a1);
  unint64_t v3 = ccn_trailing_zeros(v2, *(void *)(a1 + 24));
  cc_disable_dit_with_sb((unsigned int *)&v5);
  return v3;
}

void *ccmode_factory_ctr_crypt(void *result, void *a2)
{
  uint64_t v2 = a2[1];
  *uint64_t result = ((2 * v2 + 14) & 0xFFFFFFFFFFFFFFF0) + ((*a2 + 7) & 0xFFFFFFFFFFFFFFF8) + 16;
  result[1] = 1;
  result[2] = v2;
  result[3] = ccmode_ctr_init;
  result[4] = ccmode_ctr_setctr;
  result[5] = ccmode_ctr_crypt;
  result[6] = a2;
  return result;
}

uint64_t sizeof_struct_ccpolyzp_po2cyc()
{
  return 8;
}

uint64_t sizeof_struct_ccpolyzp_po2cyc_base_convert()
{
  return 96;
}

uint64_t sizeof_struct_ccpolyzp_po2cyc_ctx()
{
  return 120;
}

uint64_t sizeof_struct_ccrns_mul_modulus()
{
  return 24;
}

void *ccshake256_xi()
{
  return &ccxof_shake256_c_xi;
}

uint64_t ccshake256_c_absorb(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  return cckeccak_absorb_blocks(a2, *(void *)(a1 + 8), a3, a4, cckeccak_f1600_c);
}

uint64_t ccshake256_c_absorb_last(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t *a4)
{
  return cckeccak_absorb_and_pad(a2, *(void *)(a1 + 8), a3, a4, 0x1Fu, cckeccak_f1600_c);
}

uint64_t ccshake256_c_squeeze(uint64_t a1, uint64_t a2, unint64_t a3, void *a4)
{
  return cckeccak_squeeze(a2, *(void *)(a1 + 8), a3, a4, cckeccak_f1600_c);
}

uint64_t ccdh_lookup_gp(unint64_t a1, uint64_t *a2, unint64_t a3, uint64_t *a4)
{
  v15[25] = *MEMORY[0x263EF8C08];
  v15[0] = ccdh_gp_apple768();
  v15[1] = ccdh_gp_rfc2409group02();
  void v15[2] = ccdh_gp_rfc5114_MODP_1024_160();
  v15[3] = ccdh_gp_rfc5114_MODP_2048_224();
  void v15[4] = ccdh_gp_rfc5114_MODP_2048_256();
  v15[5] = ccdh_gp_rfc3526group05();
  v15[6] = ccdh_gp_rfc3526group14();
  v15[7] = ccdh_gp_rfc3526group15();
  v15[8] = ccdh_gp_rfc3526group16();
  v15[9] = ccdh_gp_rfc3526group17();
  v15[10] = ccdh_gp_rfc3526group18();
  v15[11] = ccsrp_gp_rfc5054_1024();
  v15[12] = ccsrp_gp_rfc5054_2048();
  v15[13] = ccsrp_gp_rfc5054_3072();
  v15[14] = ccsrp_gp_rfc5054_4096();
  v15[15] = ccsrp_gp_rfc5054_8192();
  v15[16] = ccdh_gp_rfc5114_MODP_1024_160();
  v15[17] = ccdh_gp_rfc5114_MODP_2048_224();
  v15[18] = ccdh_gp_rfc5114_MODP_2048_256();
  v15[19] = ccdh_gp_rfc3526group05();
  v15[20] = ccdh_gp_rfc3526group14();
  v15[21] = ccdh_gp_rfc3526group15();
  v15[22] = ccdh_gp_rfc3526group16();
  v15[23] = ccdh_gp_rfc3526group17();
  uint64_t v8 = 0;
  v15[24] = ccdh_gp_rfc3526group18();
  while (1)
  {
    uint64_t v9 = v15[v8];
    unint64_t v10 = ccn_n(a1, (uint64_t)a2);
    uint64_t v11 = v9 + 24;
    if (!ccn_cmpn_public_value(v10, a2, *(void *)v9, (uint64_t *)(v9 + 24)))
    {
      unint64_t v12 = ccn_n(a3, (uint64_t)a4);
      unint64_t v13 = ccn_n(*(void *)v9, v11 + 8 * *(void *)v9 + 8 * *(void *)v9 + 8);
      if (!ccn_cmpn_public_value(v12, a4, v13, (uint64_t *)(v11 + 8 * *(void *)v9 + 8 * *(void *)v9 + 8)))break; {
    }
      }
    if (++v8 == 25) {
      return 0;
    }
  }
  return v9;
}

uint64_t ccder_blob_decode_seqii_strict(unsigned __int8 **a1, unint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t result = ccder_blob_decode_sequence_tl_strict(a1, &v8);
  if (result)
  {
    uint64_t result = ccder_blob_decode_uint_strict(&v8, a2, a3);
    if (result)
    {
      uint64_t result = ccder_blob_decode_uint_strict(&v8, a2, a4);
      if (result) {
        return v8 == v9;
      }
    }
  }
  return result;
}

uint64_t ccder_blob_decode_seqii(unsigned __int8 **a1, unint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t result = ccder_blob_decode_sequence_tl(a1, &v8);
  if (result)
  {
    uint64_t result = ccder_blob_decode_uint(&v8, a2, a3);
    if (result)
    {
      uint64_t result = ccder_blob_decode_uint(&v8, a2, a4);
      if (result) {
        return v8 == v9;
      }
    }
  }
  return result;
}

uint64_t ccpolyzp_po2cyc_fwd_ntt(unsigned int **a1)
{
  int v1 = *a1;
  uint64_t v63 = **a1;
  if (*((unsigned char *)*a1 + 8)) {
    BOOL v2 = **a1 >= 3;
  }
  else {
    BOOL v2 = 0;
  }
  if (!v2) {
    return 4294967289;
  }
  unsigned int v3 = v1[1];
  if (v3)
  {
    int v4 = 0;
    unint64_t v5 = 0;
    int v59 = *a1;
    unint64_t v60 = v3 - 1;
    uint64_t v57 = a1 + 1;
    uint64_t v58 = v1[1];
    if (v63 >= 0x80) {
      unsigned int v6 = 128;
    }
    else {
      unsigned int v6 = **a1;
    }
    uint64_t v55 = v1 + 4;
    unsigned int v56 = v3 - 2;
    do
    {
      if (v5 >= v60)
      {
        uint64_t v11 = v55;
        uint64_t v8 = v1;
        uint64_t v15 = v1;
        uint64_t v16 = v1;
        if (*v55 >> 62) {
          return 4294967289;
        }
      }
      else
      {
        unsigned int v7 = v56;
        uint64_t v8 = v1;
        do
        {
          uint64_t v8 = (unsigned int *)*((void *)v8 + 14);
          BOOL v2 = v5 >= v7--;
        }
        while (!v2);
        unsigned int v9 = v56;
        unint64_t v10 = v1;
        do
        {
          unint64_t v10 = (unsigned int *)*((void *)v10 + 14);
          BOOL v2 = v5 >= v9--;
        }
        while (!v2);
        unint64_t v12 = *((void *)v10 + 2);
        uint64_t v11 = v10 + 4;
        if (v12 >> 62) {
          return 4294967289;
        }
        if (v5 >= v60)
        {
          uint64_t v15 = v1;
          uint64_t v16 = v1;
        }
        else
        {
          unsigned int v13 = v56;
          unsigned int v14 = v56;
          uint64_t v15 = v1;
          do
          {
            uint64_t v15 = (unsigned int *)*((void *)v15 + 14);
            BOOL v2 = v5 >= v14--;
          }
          while (!v2);
          uint64_t v16 = v1;
          do
          {
            uint64_t v16 = (unsigned int *)*((void *)v16 + 14);
            BOOL v2 = v5 >= v13--;
          }
          while (!v2);
        }
      }
      unint64_t v61 = v5;
      int v62 = v4;
      int v17 = v15 + 42;
      uint64_t v18 = (uint64_t)&v16[2 * v63 + 42];
      uint64_t v19 = (uint64_t *)&v57[(v63 * v5)];
      unsigned int v20 = &v57[v4];
      unsigned int v21 = 1;
      unsigned int v22 = v63;
      do
      {
        unsigned int v23 = v22 >> 1;
        if (v21)
        {
          uint64_t v24 = 0;
          unsigned int v25 = 0;
          unsigned int v26 = v22 & 0xFFFFFFFE;
          unsigned int v27 = v22 >> 1;
          do
          {
            int v28 = (uint64_t *)&v20[v25];
            unint64_t v29 = v27 - (unint64_t)v25;
            uint64_t v30 = v21 + v24;
            unsigned int v31 = 2 * v24 * v23;
            unsigned int v32 = v23 + v31;
            if (v30 >= v6)
            {
              if (v31 < v32)
              {
                unsigned int v38 = v27;
                do
                {
                  uint64_t v39 = *v28;
                  uint64_t v40 = v19[v38];
                  uint64_t v41 = *((void *)v8 + 2);
                  if (*v28 - 2 * v41 >= 0) {
                    uint64_t v39 = *v28 - 2 * v41;
                  }
                  unint64_t v42 = *(void *)&v17[2 * v30];
                  unint64_t v43 = (v42 * (unsigned __int128)(unint64_t)v40) >> 64;
                  uint64_t v44 = v42 * v40;
                  unint64_t v45 = *((void *)v8 + 4);
                  uint64_t v46 = ((unint64_t)v44 * (unsigned __int128)v45) >> 64;
                  uint64_t v47 = (v43 * (unsigned __int128)v45) >> 64;
                  uint64_t v48 = v43 * v45;
                  BOOL v2 = __CFADD__(v46, v48);
                  uint64_t v49 = v46 + v48;
                  uint64_t v50 = v2;
                  uint64_t v51 = v44
                      - (v50
                       + __CFADD__(v44 * *((void *)v8 + 5), v49)
                       + v47
                       + *((void *)v8 + 5) * v43
                       + (((unint64_t)v44 * (unsigned __int128)*((unint64_t *)v8 + 5)) >> 64))
                      * v41;
                  *v28++ = v51 + v39;
                  v19[v38++] = v39 + 2 * v41 - v51;
                  --v29;
                }
                while (v29);
              }
            }
            else if (v31 < v32)
            {
              uint64_t v33 = (uint64_t *)(v18 + 24 * v30);
              unsigned int v34 = v27;
              do
              {
                uint64_t v35 = *v28;
                uint64_t v36 = *v33;
                if (*v28 - 2 * *v33 >= 0) {
                  uint64_t v35 = *v28 - 2 * *v33;
                }
                uint64_t v37 = v33[1] * v19[v34]
                    - v36 * (((unint64_t)v33[2] * (unsigned __int128)(unint64_t)v19[v34]) >> 64);
                *v28++ = v37 + v35;
                v19[v34++] = v35 + 2 * v36 - v37;
                --v29;
              }
              while (v29);
            }
            ++v24;
            v25 += v26;
            v27 += v26;
          }
          while (v24 != v21);
        }
        v21 *= 2;
        unsigned int v22 = v23;
      }
      while (v21 < v63);
      int v52 = v63;
      do
      {
        uint64_t v53 = *v19;
        if (*v19 - 2 * *v11 >= 0) {
          uint64_t v53 = *v19 - 2 * *v11;
        }
        if (v53 - *v11 >= 0) {
          v53 -= *v11;
        }
        *v19++ = v53;
        --v52;
      }
      while (v52);
      ++v5;
      int v4 = v62 + v63;
      int v1 = v59;
    }
    while (v61 + 1 != v58);
  }
  return 0;
}

uint64_t ccpolyzp_po2cyc_inv_ntt(unsigned int **a1)
{
  int v1 = *a1;
  uint64_t v79 = **a1;
  if (*((unsigned char *)*a1 + 8)) {
    BOOL v2 = **a1 >= 3;
  }
  else {
    BOOL v2 = 0;
  }
  if (!v2) {
    return 4294967289;
  }
  int v3 = v1[1];
  if (v3)
  {
    unint64_t v4 = 0;
    uint64_t v70 = v1 + 4;
    unint64_t v5 = (v3 - 1);
    if (v79 >= 0x80) {
      uint64_t v6 = 128;
    }
    else {
      uint64_t v6 = v79;
    }
    unint64_t v77 = a1 + 1;
    int v78 = 0;
    uint64_t v74 = *a1;
    uint64_t v69 = v6;
    unsigned int v7 = v79 - v6;
    unsigned int v8 = v3 - 2;
    unint64_t v72 = (v3 - 1);
    uint64_t v73 = v1[1];
    unsigned int v71 = v3 - 2;
    do
    {
      if (v4 >= v5)
      {
        uint64_t v11 = v70;
        unsigned int v14 = v1;
        if ((*v70 & 0x8000000000000000) != 0) {
          return 4294967289;
        }
      }
      else
      {
        unsigned int v9 = v8;
        unint64_t v10 = v1;
        do
        {
          unint64_t v10 = (_DWORD *)*((void *)v10 + 14);
          BOOL v2 = v4 >= v9--;
        }
        while (!v2);
        uint64_t v12 = *((void *)v10 + 2);
        uint64_t v11 = v10 + 4;
        if (v12 < 0) {
          return 4294967289;
        }
        unsigned int v13 = v8;
        unsigned int v14 = v1;
        do
        {
          unsigned int v14 = (_DWORD *)*((void *)v14 + 14);
          BOOL v2 = v4 >= v13--;
        }
        while (!v2);
      }
      uint64_t v15 = sizeof_struct_ccrns_mul_modulus();
      uint64_t v16 = v1;
      if (v4 < v5)
      {
        unsigned int v17 = v8;
        uint64_t v16 = v1;
        do
        {
          uint64_t v16 = (_DWORD *)*((void *)v16 + 14);
          BOOL v2 = v4 >= v17--;
        }
        while (!v2);
      }
      unint64_t v76 = v4;
      int v75 = v79 * v4;
      uint64_t v18 = &v77[(v79 * v4)];
      if (v79 >= 4)
      {
        unint64_t v19 = ((unint64_t)(v15 + 7) >> 3) * v69;
        uint64_t v20 = (uint64_t)&v14[2 * v79 + 2 * v19];
        uint64_t v21 = (uint64_t)&v16[2 * v79 + 2 * v19 + 2 * v79];
        uint64_t v22 = v20 + 168;
        uint64_t v23 = v21 + 168;
        int v24 = 1;
        unsigned int v25 = v79 >> 1;
        unsigned int v26 = 1;
        do
        {
          unsigned int v27 = 0;
          int v28 = 0;
          int v29 = 2 * v24;
          if (v25 <= 1) {
            int v30 = 1;
          }
          else {
            int v30 = v25;
          }
          unsigned int v31 = v24;
          do
          {
            unsigned int v32 = &(&v77[v78])[v27];
            unint64_t v33 = v31 - (unint64_t)v27;
            unsigned int v34 = 2 * v28 * v24;
            if (v26 >= v7)
            {
              if (v34 < v34 + v24)
              {
                uint64_t v49 = (void *)(v23 + 24 * (v79 + ~v26));
                unsigned int v50 = v31;
                do
                {
                  uint64_t v51 = v18[v50];
                  uint64_t v52 = (char *)*v32 - (char *)v51 + 2 * *v49;
                  uint64_t v53 = (unsigned int *)((char *)*v32 + (void)v51);
                  if ((uint64_t)v53 - 2 * *v49 >= 0) {
                    uint64_t v53 = (unsigned int *)((char *)v53 - 2 * *v49);
                  }
                  uint64_t v54 = (unsigned int *)(v49[1] * v52
                                       - *v49
                                       * (((unint64_t)v52 * (unsigned __int128)(unint64_t)v49[2]) >> 64));
                  *v32++ = v53;
                  v18[v50++] = v54;
                  --v33;
                }
                while (v33);
              }
            }
            else if (v34 < v34 + v24)
            {
              unsigned int v35 = v31;
              do
              {
                uint64_t v36 = v18[v35];
                unint64_t v37 = *(void *)(v22 + 8 * v26);
                uint64_t v38 = (char *)*v32 - (char *)v36 + 2 * *v11;
                uint64_t v39 = (unsigned int *)((char *)*v32 + (void)v36);
                if ((uint64_t)v39 - 2 * *v11 >= 0) {
                  uint64_t v39 = (unsigned int *)((char *)v39 - 2 * *v11);
                }
                uint64_t v40 = v38 * v37;
                unint64_t v41 = ((unint64_t)v38 * (unsigned __int128)v37) >> 64;
                unint64_t v42 = v11[2];
                uint64_t v43 = ((unint64_t)v40 * (unsigned __int128)v42) >> 64;
                uint64_t v44 = (v41 * (unsigned __int128)v42) >> 64;
                uint64_t v45 = v41 * v42;
                BOOL v2 = __CFADD__(v43, v45);
                uint64_t v46 = v43 + v45;
                uint64_t v47 = v2;
                uint64_t v48 = (unsigned int *)(v40
                                     - (v47
                                      + __CFADD__(v40 * v11[3], v46)
                                      + v44
                                      + v11[3] * v41
                                      + (((unint64_t)v40 * (unsigned __int128)(unint64_t)v11[3]) >> 64))
                                     * *v11);
                *v32++ = v39;
                v18[v35++] = v48;
                --v33;
              }
              while (v33);
            }
            ++v28;
            ++v26;
            v27 += v29;
            v31 += v29;
          }
          while (v28 != v30);
          v24 *= 2;
          BOOL v55 = v25 > 3;
          v25 >>= 1;
        }
        while (v55);
      }
      int v1 = v74;
      unsigned int v56 = v74;
      uint64_t v57 = v74;
      unint64_t v5 = v72;
      unsigned int v8 = v71;
      if (v76 < v72)
      {
        unsigned int v58 = v71;
        unsigned int v56 = v74;
        do
        {
          unsigned int v56 = (void *)v56[14];
          BOOL v2 = v76 >= v58--;
        }
        while (!v2);
        unsigned int v59 = v71;
        uint64_t v57 = v74;
        do
        {
          uint64_t v57 = (void *)v57[14];
          BOOL v2 = v76 >= v59--;
        }
        while (!v2);
      }
      unint64_t v60 = &(&v77[v75])[v79 >> 1];
      unsigned int v61 = v79 >> 1;
      do
      {
        unint64_t v62 = (unint64_t)*v18 + (void)*v60;
        if ((uint64_t)(v62 - 2 * *v11) >= 0) {
          v62 -= 2 * *v11;
        }
        uint64_t v64 = v57[11];
        uint64_t v65 = (unsigned int *)(v62 * v57[12] - v64 * ((v62 * (unsigned __int128)(unint64_t)v57[13]) >> 64));
        if ((uint64_t)v65 - v64 >= 0) {
          uint64_t v65 = (unsigned int *)((char *)v65 - v64);
        }
        uint64_t v66 = v56[8];
        uint64_t v63 = (char *)*v18 - (char *)*v60 + 2 * *v11;
        int v67 = (unsigned int *)(v56[9] * v63
                             - v66 * (((unint64_t)v56[10] * (unsigned __int128)(unint64_t)v63) >> 64));
        if ((uint64_t)v67 - v66 >= 0) {
          int v67 = (unsigned int *)((char *)v67 - v66);
        }
        *v18++ = v65;
        *v60++ = v67;
        --v61;
      }
      while (v61);
      unint64_t v4 = v76 + 1;
      v78 += v79;
    }
    while (v76 + 1 != v73);
  }
  return 0;
}

uint64_t ccrsa_is_valid_prime_ws(uint64_t a1, unint64_t a2, void *a3, uint64_t a4, void *a5, unint64_t a6, uint64_t (**a7)(void, unint64_t, uint64_t))
{
  uint64_t v14 = *(void *)(a1 + 16);
  uint64_t v15 = (void *)(*(uint64_t (**)(void))(a1 + 24))();
  ccn_set(a2, v15, a3);
  *v15 &= ~1uLL;
  uint64_t v16 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, a2);
  if (!ccn_gcd_ws(a1, a2, v16, a2, v15, a4, a5) && ccn_n(a2, (uint64_t)v16) == 1 && *v16 == 1) {
    uint64_t result = ccprime_rabin_miller_ws(a1, a2, (unint64_t *)a3, a6, a7);
  }
  else {
    uint64_t result = 0;
  }
  *(void *)(a1 + 16) = v14;
  return result;
}

uint64_t cckyber_kem_keypair_coins(unsigned int *a1, void *a2, uint64_t a3, char *a4, _OWORD *a5)
{
  uint64_t v9 = cckyber_indcpa_keypair(a1, (uint64_t)a2, a3, a4);
  if (!v9)
  {
    memcpy((void *)(a3 + 384 * *a1), a2, (384 * *a1) | 0x20);
    cckyber_hash_h((384 * *a1) | 0x20, (char *)a2, a3 + ((((384 * *a1) | 0x20) + 384 * *a1) | 0x40) - 64);
    long long v10 = a5[1];
    uint64_t v11 = a3 + ((768 * *a1) | 0x60);
    *(_OWORD *)(v11 - 32) = *a5;
    *(_OWORD *)(v11 - 16) = v10;
  }
  return v9;
}

uint64_t cckyber_kem_keypair(unsigned int *a1, void *a2, uint64_t a3, uint64_t (**a4)(void, uint64_t, char *))
{
  uint64_t v12 = *MEMORY[0x263EF8C08];
  uint64_t v7 = (*a4)(a4, 64, __s);
  if (!v7) {
    uint64_t v7 = cckyber_kem_keypair_coins(a1, a2, a3, __s, &v11);
  }
  uint64_t v8 = v7;
  cc_clear(0x40uLL, __s);
  return v8;
}

uint64_t cckyber_kem_encapsulate_msg(unsigned int *a1, char *a2, uint64_t a3, _OWORD *a4, long long *a5)
{
  uint64_t v17 = *MEMORY[0x263EF8C08];
  long long v10 = a5[1];
  long long v14 = *a5;
  long long v15 = v10;
  cckyber_hash_h((384 * *a1) | 0x20, a2, (uint64_t)v16);
  cckyber_hash_g(0x40uLL, (char *)&v14, (uint64_t)&v14);
  uint64_t v11 = cckyber_indcpa_encrypt(a1, a2, (uint64_t)a5, v16, a3);
  if (!v11)
  {
    long long v12 = v15;
    *a4 = v14;
    a4[1] = v12;
  }
  cc_clear(0x40uLL, &v14);
  return v11;
}

uint64_t cckyber_kem_encapsulate(unsigned int *a1, char *a2, uint64_t a3, _OWORD *a4, uint64_t (**a5)(void, uint64_t, long long *))
{
  uint64_t v13 = *MEMORY[0x263EF8C08];
  uint64_t v9 = (*a5)(a5, 32, __s);
  if (v9) {
    return v9;
  }
  uint64_t v10 = cckyber_kem_encapsulate_msg(a1, a2, a3, a4, __s);
  cc_clear(0x20uLL, __s);
  return v10;
}

uint64_t cckyber_kem_decapsulate(unsigned int *a1, uint64_t a2, char *a3, char *a4)
{
  uint64_t v28 = *MEMORY[0x263EF8C08];
  uint64_t v8 = *a1;
  unint64_t v9 = sizeof_struct_ccpolyzp_po2cyc();
  v19[0] = cc_malloc_clear(8* ((v9 + 511) / v9+ (8 * v9 + 2816 * v8 + 1279) / (8 * v9)+ 2 * ((v9 + 511) / v9)+ 4 * ((v9 - 1 + (v8 << 9)) / v9)+ (v9 - 1 + (v8 << 9) * v8) / v9+ (v9 + 384 * v8 + 31) / v9));
  uint64_t v10 = *a1;
  unint64_t v11 = sizeof_struct_ccpolyzp_po2cyc();
  v19[1] = (v11 + 511) / v11
         + (8 * v11 + 2816 * v10 + 1279) / (8 * v11)
         + 2 * ((v11 + 511) / v11)
         + 4 * ((v11 - 1 + (v10 << 9)) / v11)
         + (v11 - 1 + (v10 << 9) * v10) / v11
         + (v11 + 384 * v10 + 31) / v11;
  uint64_t v20 = 0;
  uint64_t v21 = cc_ws_alloc;
  uint64_t v22 = cc_ws_free;
  if (!v19[0]) {
    return 4294967283;
  }
  long long v12 = (char *)(a2 + (384 * v10));
  cckyber_indcpa_decrypt_ws((uint64_t)v19, a1, a2, (uint64_t)a3, (uint64_t)__s);
  uint64_t v13 = a2 + ((768 * *a1) | 0x60);
  long long v14 = *(_OWORD *)(v13 - 48);
  long long v24 = *(_OWORD *)(v13 - 64);
  long long v25 = v14;
  cckyber_hash_g(0x40uLL, __s, (uint64_t)v26);
  long long v15 = (char *)v21(v19, (2816 * (unint64_t)v10 + 1343) >> 6);
  uint64_t v16 = cckyber_indcpa_encrypt_ws((uint64_t)v19, a1, v12, (uint64_t)__s, v27, (uint64_t)v15);
  char v17 = cc_cmp_safe_internal(32 * (a1[1] + *a1 * a1[2]), a3, v15);
  cckyber_rkprf((char *)(a2 + ((768 * *a1) | 0x60) - 32), 32 * (a1[1] + a1[2] * *a1), a3, a4);
  ccn_mux(4, v17, (uint64_t *)a4, (uint64_t *)a4, v26);
  uint64_t v20 = 0;
  cc_clear(0x40uLL, __s);
  cc_clear(0x40uLL, v26);
  v22((uint64_t)v19);
  return v16;
}

uint64_t ccder_encode_rsa_pub(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = a1 + 3;
  unint64_t v6 = *a1;
  uint64_t v7 = ccder_encode_integer(*a1, &a1[2 * *a1 + 4], a2, a3);
  uint64_t v8 = ccder_encode_integer(v6, v5, a2, v7);

  return ccder_encode_constructed_tl(0x2000000000000010uLL, a3, a2, v8);
}

uint64_t ccrng_process_init(uint64_t a1, uint64_t (*a2)(void), uint64_t (**a3)(void, uint64_t, unsigned char *))
{
  uint64_t v14 = *MEMORY[0x263EF8C08];
  uint64_t v6 = a1 + 128;
  ccrng_schedule_timer_init(a1 + 128, a2, 5000000000);
  ccrng_schedule_atomic_flag_init(a1 + 168);
  ccrng_schedule_tree_init(a1 + 96, v6, a1 + 168);
  uint64_t result = cc_lock_init((_DWORD *)(a1 + 208));
  if (!result)
  {
    uint64_t result = ccentropy_rng_init((void *)(a1 + 192), (uint64_t)a3);
    if (!result)
    {
      uint64_t v8 = ccaes_cbc_encrypt_mode();
      uint64_t result = ccdrbg_df_bc_init_internal((void *)(a1 + 224), v8, 0x20uLL);
      if (!result)
      {
        unint64_t v9 = ccaes_ctr_crypt_mode();
        long long v10 = xmmword_2373B5190;
        DWORD2(v10) = 1;
        uint64_t v11 = a1 + 224;
        ccdrbg_factory_nistctr((void *)(a1 + 768), (uint64_t)&v9);
        uint64_t result = (*a3)(a3, 32, v13);
        if (!result)
        {
          a2();
          strcpy(v12, "corecrypto process rng");
          uint64_t result = ccdrbg_init_internal(a1 + 768);
          if (!result)
          {
            uint64_t result = ccrng_crypto_init((void *)(a1 + 8), a1 + 192, a1 + 96, a1 + 208, a1 + 768, a1 + 824, 4096, 0x20uLL, 256, a1 + 2104);
            if (!result) {
              *(void *)a1 = generate_1;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t generate_1(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a1 + 8);
}

uint64_t ccrng_process_atfork_prepare(os_unfair_lock_s *a1)
{
  return 0;
}

uint64_t ccrng_process_atfork_parent(os_unfair_lock_s *a1)
{
  return 0;
}

uint64_t ccrng_process_atfork_child(uint64_t a1)
{
  return cc_lock_init((_DWORD *)(a1 + 208));
}

BOOL ccn_divides1(uint64_t a1, unint64_t *a2, unint64_t a3)
{
  unint64_t v3 = 0;
  if (a1)
  {
    uint64_t v4 = (2 - ((3 * a3) ^ 2) * a3) * ((3 * a3) ^ 2);
    uint64_t v5 = (2 - (2 - v4 * a3) * v4 * a3) * (2 - v4 * a3) * v4;
    uint64_t v6 = (2 - v5 * a3) * v5;
    do
    {
      unint64_t v7 = *a2++;
      unint64_t v3 = ((v6 * (v7 - v3) + ((unint64_t)((v7 - __PAIR128__(v7, v3)) >> 64) >> 63)) * (unsigned __int128)a3) >> 64;
      --a1;
    }
    while (a1);
  }
  return (v3 | HIDWORD(v3)) == 0;
}

uint64_t ccpad_pkcs7_ecb_decrypt(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v13 = timingsafe_enable_if_supported();
  unint64_t v10 = *(void *)(a1 + 8);
  (*(void (**)(uint64_t, unint64_t, uint64_t, uint64_t))(a1 + 24))(a2, a3 / v10, a4, a5);
  uint64_t v11 = a3 - ccpad_pkcs7_decode_internal(v10, a5 + (a3 / v10 - 1) * v10);
  cc_disable_dit_with_sb((unsigned int *)&v13);
  return v11;
}

uint64_t ccrsa_priv_crypt_ws(uint64_t a1, uint64_t *a2, uint64_t *a3, void *a4)
{
  uint64_t v8 = ccrng(0);
  if (!v8) {
    return 0xFFFFFFFFLL;
  }

  return ccrsa_priv_crypt_blinded_ws(a1, (uint64_t (**)(void, uint64_t, uint64_t))v8, a2, a3, a4);
}

uint64_t ccrsa_priv_crypt(uint64_t *a1, uint64_t *a2, void *a3)
{
  BOOL v23 = timingsafe_enable_if_supported();
  unint64_t v6 = *a1;
  uint64_t v7 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v8 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v9 = (v7 + v8 - 1) / v8 + 11 * v6;
  unint64_t v10 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(v6);
  if (v9 + 1 > v10) {
    unint64_t v11 = v9 + 1;
  }
  else {
    unint64_t v11 = v10;
  }
  long long v12 = cc_malloc_clear(8 * v11 + 16 * v6);
  v21[0] = v12;
  unint64_t v13 = *a1;
  uint64_t v14 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v16 = (v14 + v15 - 1) / v15 + 11 * v13;
  unint64_t v17 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(v13);
  if (v16 + 1 > v17) {
    unint64_t v18 = v16 + 1;
  }
  else {
    unint64_t v18 = v17;
  }
  v21[1] = v18 + 2 * v13;
  void v21[2] = 0;
  v21[3] = cc_ws_alloc;
  uint64_t v22 = cc_ws_free;
  if (v12)
  {
    uint64_t v19 = ccrsa_priv_crypt_ws((uint64_t)v21, a1, a2, a3);
    v22((uint64_t)v21);
  }
  else
  {
    uint64_t v19 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v23);
  return v19;
}

uint64_t ccn_mul1(uint64_t a1, void *a2, unint64_t *a3, unint64_t a4)
{
  for (uint64_t i = 0; a1; --a1)
  {
    unint64_t v5 = *a3++;
    uint64_t v6 = (v5 * (unsigned __int128)a4) >> 64;
    uint64_t v7 = v5 * a4 + i;
    if (__CFADD__(v5 * a4, i)) {
      uint64_t i = v6 + 1;
    }
    else {
      uint64_t i = v6;
    }
    *a2++ = v7;
  }
  return i;
}

uint64_t ccdigest_internal(uint64_t a1, size_t a2, char *a3, uint64_t a4)
{
  v12[1] = *MEMORY[0x263EF8C08];
  uint64_t v8 = MEMORY[0x270FA53B0](a1, a2, a3, a4);
  unint64_t v10 = (void *)((char *)v12 - v9);
  ccdigest_init_internal(v8, (void *)((char *)v12 - v9));
  ccdigest_update_internal((unint64_t *)a1, v10, a2, a3);
  (*(void (**)(uint64_t, void *, uint64_t))(a1 + 56))(a1, v10, a4);
  return cc_clear(*(void *)(a1 + 8) + *(void *)(a1 + 16) + 12, v10);
}

uint64_t ccdigest(uint64_t a1, size_t a2, char *a3, uint64_t a4)
{
  BOOL v9 = timingsafe_enable_if_supported();
  ccdigest_internal(a1, a2, a3, a4);
  return cc_disable_dit_with_sb((unsigned int *)&v9);
}

uint64_t ccrsa_decrypt_eme_pkcs1v15_blinded_ws(uint64_t a1, uint64_t (**a2)(void, uint64_t, uint64_t), uint64_t *a3, rsize_t *a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14 = (unint64_t *)ccrsa_ctx_public(a3);
  unint64_t v15 = ccrsa_block_size(v14);
  if (*a4 < v15) {
    return 4294967273;
  }
  size_t v17 = v15;
  uint64_t v18 = *a3;
  *a4 = v15;
  uint64_t v20 = *(void *)(a1 + 16);
  uint64_t v19 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v18);
  if (ccn_read_uint_internal(v18, v19, a6, a7))
  {
    uint64_t result = 4294967273;
  }
  else
  {
    uint64_t result = ccrsa_priv_crypt_blinded_ws(a1, a2, a3, v19, v19);
    if (!result) {
      uint64_t result = ccrsa_eme_pkcs1v15_decode_safe_ws(a1, a3, a4, a5, v17, (unint64_t *)v19);
    }
  }
  *(void *)(a1 + 16) = v20;
  return result;
}

uint64_t cchmac_update(unint64_t *a1, void *a2, size_t a3, char *a4)
{
  BOOL v9 = timingsafe_enable_if_supported();
  ccdigest_update_internal(a1, a2, a3, a4);
  return cc_disable_dit_with_sb((unsigned int *)&v9);
}

uint64_t ccsigma_init(uint64_t a1, uint64_t a2, int a3, uint64_t (**a4)(void, uint64_t, unint64_t *))
{
  BOOL v14 = timingsafe_enable_if_supported();
  *(void *)a2 = a1;
  *(_DWORD *)(a2 + 8) = a3;
  uint64_t v8 = (unint64_t **)(*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
  v12[0] = cc_malloc_clear(392 * **(void **)a1);
  BOOL v9 = *(unint64_t **)a1;
  v12[1] = 49 * **(void **)a1;
  void v12[2] = 0;
  v12[3] = cc_ws_alloc;
  unint64_t v13 = cc_ws_free;
  if (v12[0])
  {
    key_fips_uint64_t ws = ccec_generate_key_fips_ws((uint64_t)v12, v9, a4, v8);
    v13((uint64_t)v12);
  }
  else
  {
    key_fips_uint64_t ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return key_fips_ws;
}

uint64_t ccsigma_import_signing_key(void *a1, unint64_t a2, unsigned __int8 *a3)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v6 = (uint64_t **)(*(uint64_t (**)(void *))(*a1 + 48))(a1);
  uint64_t v7 = 20 * **(void **)(*a1 + 24);
  v10[0] = cc_malloc_clear(160 * **(void **)(*a1 + 24));
  v10[1] = v7;
  void v10[2] = 0;
  v10[3] = cc_ws_alloc;
  unint64_t v11 = cc_ws_free;
  if (v10[0])
  {
    uint64_t v8 = ccec_x963_import_priv_ws((uint64_t)v10, *(uint64_t **)(*a1 + 24), a2, a3, v6);
    v11((uint64_t)v10);
    if (!v8)
    {
      a1[2] = ccsigma_sign_internal;
      a1[3] = a1;
    }
  }
  else
  {
    uint64_t v8 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v8;
}

uint64_t ccsigma_set_signing_function(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = a3;
  return 0;
}

uint64_t ccsigma_sign_internal(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t *a4, char *a5, uint64_t (**a6)(void, unint64_t, void *))
{
  BOOL v12 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
  unint64_t v13 = (void *)*v12;
  v18[0] = cc_malloc_clear(280 * *(void *)*v12);
  v18[1] = 35 * *v13;
  _OWORD v18[2] = 0;
  v18[3] = cc_ws_alloc;
  uint64_t v19 = cc_ws_free;
  if (!v18[0]) {
    return 4294967283;
  }
  unint64_t v14 = *(void *)(*(void *)a1 + 40);
  if (*a4 < v14)
  {
    uint64_t v16 = 4294967289;
    cc_ws_free((uint64_t)v18);
  }
  else
  {
    *a4 = v14;
    unint64_t v15 = ccec_signature_r_s_size(v12);
    uint64_t v16 = ccec_sign_composite_ws((uint64_t)v18, (unint64_t **)v12, a2, a3, a5, &a5[v15], a6);
    v19((uint64_t)v18);
  }
  return v16;
}

uint64_t ccsigma_import_peer_verification_key(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  BOOL v9 = timingsafe_enable_if_supported();
  uint64_t v6 = (uint64_t **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
  uint64_t v7 = ccec_x963_import_pub(*(uint64_t **)(*(void *)a1 + 24), a2, a3, v6);
  cc_disable_dit_with_sb((unsigned int *)&v9);
  return v7;
}

uint64_t ccsigma_export_key_share(uint64_t **a1, rsize_t *a2, char *a3)
{
  BOOL v11 = timingsafe_enable_if_supported();
  unint64_t v6 = ccec_compressed_x962_export_pub_size(**a1);
  rsize_t v7 = *a2;
  if (*a2 < v6)
  {
    uint64_t v9 = 4294967289;
    goto LABEL_4;
  }
  *a2 = v6;
  uint64_t v8 = (uint64_t *)((uint64_t (*)(uint64_t **))(*a1)[1])(a1);
  uint64_t v9 = ccec_compressed_x962_export_pub(v8, a3);
  if (v9)
  {
    rsize_t v7 = *a2;
LABEL_4:
    cc_clear(v7, a3);
  }
  cc_disable_dit_with_sb((unsigned int *)&v11);
  return v9;
}

uint64_t ccsigma_import_peer_key_share(uint64_t ***a1, uint64_t a2, unsigned __int8 *a3)
{
  BOOL v9 = timingsafe_enable_if_supported();
  unint64_t v6 = (uint64_t **)((uint64_t (*)(uint64_t ***))(*a1)[2])(a1);
  uint64_t v7 = ccec_compressed_x962_import_pub(**a1, a2, a3, v6);
  cc_disable_dit_with_sb((unsigned int *)&v9);
  return v7;
}

BOOL ccsigma_peer_role(uint64_t a1)
{
  return *(_DWORD *)(a1 + 8) == 0;
}

uint64_t ccsigma_kex_init_ctx(uint64_t a1)
{
  uint64_t v1 = 16;
  if (!*(_DWORD *)(a1 + 8)) {
    uint64_t v1 = 8;
  }
  return (*(uint64_t (**)(void))(*(void *)a1 + v1))();
}

uint64_t ccsigma_kex_resp_ctx(uint64_t a1)
{
  uint64_t v1 = 16;
  if (*(_DWORD *)(a1 + 8) == 1) {
    uint64_t v1 = 8;
  }
  return (*(uint64_t (**)(void))(*(void *)a1 + v1))();
}

uint64_t ccsigma_derive_session_keys(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t (**a4)(void, uint64_t, unint64_t *))
{
  uint64_t v20 = *MEMORY[0x263EF8C08];
  BOOL v18 = timingsafe_enable_if_supported();
  uint64_t v8 = *a1;
  uint64_t v9 = cczp_bitlen(**a1);
  unint64_t v17 = (unint64_t)(v9 + 7) >> 3;
  if ((unint64_t)(v9 + 7) <= 0x107)
  {
    BOOL v11 = (unint64_t **)((uint64_t (*)(uint64_t **))v8[1])(a1);
    BOOL v12 = (unint64_t **)((uint64_t (*)(uint64_t **))(*a1)[2])(a1);
    unint64_t v13 = *v11;
    v15[0] = cc_malloc_clear(232 * **v11);
    v15[1] = 29 * *v13;
    void v15[2] = 0;
    v15[3] = cc_ws_alloc;
    uint64_t v16 = cc_ws_free;
    if (v15[0])
    {
      uint64_t v10 = ccecdh_compute_shared_secret_ws((uint64_t)v15, v11, v12, &v17, v19, a4);
      v16((uint64_t)v15);
      if (!v10) {
        uint64_t v10 = ((uint64_t (*)(uint64_t **, unint64_t, char *, uint64_t, uint64_t))v8[12])(a1, v17, v19, a2, a3);
      }
    }
    else
    {
      uint64_t v10 = 4294967283;
    }
  }
  else
  {
    uint64_t v10 = 4294967291;
  }
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return v10;
}

uint64_t ccsigma_compute_mac_internal(uint64_t *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a1;
  if (*(void *)(*a1 + 64) <= a2) {
    return 4294967289;
  }
  uint64_t v10 = 0;
  if (a2)
  {
    BOOL v11 = *(uint64_t **)(v5 + 72);
    unint64_t v12 = a2;
    do
    {
      uint64_t v13 = *v11++;
      v10 += v13;
      --v12;
    }
    while (v12);
  }
  uint64_t v14 = *(void *)(*(void *)(v5 + 72) + 8 * a2);
  uint64_t v15 = (*(uint64_t (**)(uint64_t *))(v5 + 88))(a1) + v10;
  uint64_t v16 = *(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*a1 + 112);

  return v16(a1, v14, v15, a3, a4, a5);
}

uint64_t ccsigma_compute_mac(uint64_t *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = ccsigma_compute_mac_internal(a1, a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccsigma_sign(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x263EF8C08];
  BOOL v15 = timingsafe_enable_if_supported();
  unint64_t v10 = **(void **)(*(void *)a1 + 32);
  if (v10 > 0x40)
  {
    uint64_t v12 = 4294967291;
  }
  else
  {
    uint64_t v11 = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, unsigned char *))(*(void *)a1 + 136))(a1, *(unsigned int *)(a1 + 8), a3, a4, v16);
    if (!v11)
    {
      uint64_t v14 = *(void *)(*(void *)a1 + 40);
      uint64_t v11 = (*(uint64_t (**)(void, unint64_t, unsigned char *, uint64_t *, uint64_t, uint64_t))(a1 + 16))(*(void *)(a1 + 24), v10, v16, &v14, a2, a5);
    }
    uint64_t v12 = v11;
  }
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v12;
}

uint64_t ccsigma_verify(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v18 = *MEMORY[0x263EF8C08];
  BOOL v16 = timingsafe_enable_if_supported();
  uint64_t v8 = (uint64_t *)(*(uint64_t (**)(_DWORD *))(*(void *)a1 + 56))(a1);
  v14[0] = cc_malloc_clear(376 * *(void *)*v8);
  v14[1] = 47 * *(void *)*v8;
  _OWORD v14[2] = 0;
  void v14[3] = cc_ws_alloc;
  BOOL v15 = cc_ws_free;
  if (v14[0])
  {
    unint64_t v9 = **(void **)(*(void *)a1 + 32);
    if (v9 > 0x40)
    {
      uint64_t v12 = 4294967291;
    }
    else
    {
      uint64_t v10 = (*(uint64_t (**)(_DWORD *, BOOL, uint64_t, uint64_t, unsigned char *))(*(void *)a1 + 136))(a1, a1[2] == 0, a3, a4, v17);
      if (!v10)
      {
        unint64_t v11 = ccec_signature_r_s_size(v8);
        uint64_t v10 = ccec_verify_composite_digest_ws((uint64_t)v14, v8, v9, (uint64_t)v17, a2, a2 + v11, 0);
      }
      uint64_t v12 = v10;
    }
    v15((uint64_t)v14);
  }
  else
  {
    uint64_t v12 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v12;
}

uint64_t ccsigma_seal(uint64_t *a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  BOOL v34 = timingsafe_enable_if_supported();
  uint64_t v17 = *a1;
  if (*(void *)(*a1 + 64) <= a2) {
    goto LABEL_12;
  }
  uint64_t v18 = 0;
  if (a2)
  {
    uint64_t v19 = *(uint64_t **)(v17 + 72);
    unint64_t v20 = a2;
    do
    {
      uint64_t v21 = *v19++;
      v18 += v21;
      --v20;
    }
    while (v20);
  }
  uint64_t v22 = *(void *)(*(void *)(v17 + 72) + 8 * a2);
  uint64_t v23 = (*(uint64_t (**)(uint64_t *))(v17 + 88))(a1);
  uint64_t v24 = *a1;
  if (*(void *)(*a1 + 64) <= a3)
  {
LABEL_12:
    uint64_t v32 = 4294967289;
  }
  else
  {
    uint64_t v25 = v23 + v18;
    uint64_t v26 = 0;
    if (a3)
    {
      unsigned int v27 = *(uint64_t **)(v24 + 72);
      unint64_t v28 = a3;
      do
      {
        uint64_t v29 = *v27++;
        v26 += v29;
        --v28;
      }
      while (v28);
    }
    uint64_t v30 = *(void *)(*(void *)(v24 + 72) + 8 * a3);
    uint64_t v31 = (*(uint64_t (**)(uint64_t *))(v24 + 88))(a1) + v26;
    uint64_t v32 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*a1 + 152))(a1, v22, v25, v30, v31, a4, a5, a6, a7, a8, a9);
    if (!v32) {
      (*(void (**)(uint64_t, uint64_t))(*a1 + 168))(v30, v31);
    }
  }
  cc_disable_dit_with_sb((unsigned int *)&v34);
  return v32;
}

uint64_t ccsigma_open(uint64_t *a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v36 = *MEMORY[0x263EF8C08];
  BOOL v34 = timingsafe_enable_if_supported();
  uint64_t v16 = *a1;
  if (*(void *)(*a1 + 144) > 0x10uLL)
  {
    uint64_t v31 = 4294967291;
  }
  else
  {
    if (*(void *)(v16 + 64) <= a2) {
      goto LABEL_13;
    }
    uint64_t v17 = 0;
    if (a2)
    {
      uint64_t v18 = *(uint64_t **)(v16 + 72);
      unint64_t v19 = a2;
      do
      {
        uint64_t v20 = *v18++;
        v17 += v20;
        --v19;
      }
      while (v19);
    }
    uint64_t v21 = *(void *)(*(void *)(v16 + 72) + 8 * a2);
    uint64_t v22 = (*(uint64_t (**)(uint64_t *))(v16 + 88))(a1);
    uint64_t v23 = *a1;
    if (*(void *)(*a1 + 64) <= a3)
    {
LABEL_13:
      uint64_t v31 = 4294967289;
    }
    else
    {
      uint64_t v33 = a5;
      uint64_t v24 = v22 + v17;
      uint64_t v25 = 0;
      if (a3)
      {
        uint64_t v26 = *(uint64_t **)(v23 + 72);
        unint64_t v27 = a3;
        do
        {
          uint64_t v28 = *v26++;
          v25 += v28;
          --v27;
        }
        while (v27);
      }
      uint64_t v29 = *(void *)(*(void *)(v23 + 72) + 8 * a3);
      uint64_t v30 = (*(uint64_t (**)(uint64_t *))(v23 + 88))(a1) + v25;
      __memcpy_chk();
      uint64_t v31 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *))(*a1 + 160))(a1, v21, v24, v29, v30, a4, v33, a6, a7, a8, v35);
      if (!v31) {
        (*(void (**)(uint64_t, uint64_t))(*a1 + 168))(v29, v30);
      }
    }
  }
  cc_disable_dit_with_sb((unsigned int *)&v34);
  return v31;
}

uint64_t ccsigma_clear_key(uint64_t *a1, unint64_t a2)
{
  BOOL v13 = timingsafe_enable_if_supported();
  uint64_t v4 = *a1;
  if (*(void *)(*a1 + 64) <= a2)
  {
    uint64_t v11 = 4294967289;
  }
  else
  {
    uint64_t v5 = 0;
    if (a2)
    {
      unint64_t v6 = *(uint64_t **)(v4 + 72);
      unint64_t v7 = a2;
      do
      {
        uint64_t v8 = *v6++;
        v5 += v8;
        --v7;
      }
      while (v7);
    }
    rsize_t v9 = *(void *)(*(void *)(v4 + 72) + 8 * a2);
    uint64_t v10 = (*(uint64_t (**)(uint64_t *))(v4 + 88))(a1);
    cc_clear(v9, (void *)(v10 + v5));
    uint64_t v11 = 0;
  }
  cc_disable_dit_with_sb((unsigned int *)&v13);
  return v11;
}

uint64_t ccsigma_clear(uint64_t a1)
{
  BOOL v3 = timingsafe_enable_if_supported();
  (*(void (**)(uint64_t))(*(void *)a1 + 176))(a1);
  return cc_disable_dit_with_sb((unsigned int *)&v3);
}

uint64_t ccder_blob_reserve_tl(uint64_t *a1, unint64_t a2, unint64_t a3, void *a4)
{
  long long v9 = 0uLL;
  *a4 = 0;
  a4[1] = 0;
  uint64_t result = ccder_blob_reserve(a1, a3, &v9);
  if (result)
  {
    uint64_t result = ccder_blob_encode_tl(a1, a2, a3);
    if (result)
    {
      *(_OWORD *)a4 = v9;
      return 1;
    }
  }
  return result;
}

uint64_t cced25519_sign_with_rng_internal(uint64_t a1, void (**a2)(void, uint64_t, int8x16_t *), char *a3, size_t a4, char *a5, uint64_t a6, char *a7)
{
  uint64_t v23 = *MEMORY[0x263EF8C08];
  uint64_t result = ((uint64_t (*)(void, uint64_t, char *))*a2)(a2, 32, v22);
  if (!result)
  {
    long long v20 = 0u;
    long long v21 = 0u;
    BOOL v15 = ccsha512_di();
    uint64_t result = cced25519_make_pub_internal(v15, a2, (uint64_t)&v20, a7);
    if (!result)
    {
      if (*(void *)a6 == (void)v20
        && *(void *)(a6 + 8) == *((void *)&v20 + 1)
        && *(void *)(a6 + 16) == (void)v21
        && *(void *)(a6 + 24) == *((void *)&v21 + 1))
      {
        return cced25519_sign_internal(a1, a2, a3, a4, a5, (char *)a6, a7, v22);
      }
      else
      {
        unint64_t v19 = cc_log_default();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
          cced25519_sign_with_rng_internal_cold_1(v19);
        }
        cc_clear(0x40uLL, a3);
        return 4294967289;
      }
    }
  }
  return result;
}

uint64_t cced25519_sign_internal(uint64_t a1, void (**a2)(void, uint64_t, int8x16_t *), char *a3, size_t a4, char *a5, char *a6, char *a7, char *a8)
{
  uint64_t v30 = *MEMORY[0x263EF8C08];
  if (*(void *)a1 != 64 || *(void *)(a1 + 16) != 128) {
    return 4294967289;
  }
  uint64_t v23 = a6;
  memset(v24, 0, sizeof(v24));
  uint64_t v14 = ccdigest_internal(a1, 0x20uLL, a7, (uint64_t)__s);
  LOBYTE(__s[0]) &= 0xF8u;
  char v28 = v28 & 0x3F | 0x40;
  MEMORY[0x270FA53B0](v14, v15, v16, v17);
  unint64_t v19 = (uint64_t *)((char *)&v22 - v18);
  ccdigest_init_internal(a1, (uint64_t *)((char *)&v22 - v18));
  if (a8)
  {
    memset(__src, 0, sizeof(__src));
    ccdigest_update_internal((unint64_t *)a1, v19, 0x20uLL, a8);
    ccdigest_update_internal((unint64_t *)a1, v19, 0x40uLL, __src[0].i8);
    ccdigest_update_internal((unint64_t *)a1, v19, 0x20uLL, v29);
    if (*(_DWORD *)((char *)v19 + *(void *)(a1 + 8) + *(void *)(a1 + 16) + 8)) {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ccdigest_update_internal((unint64_t *)a1, v19, 0x20uLL, v29);
  }
  ccdigest_update_internal((unint64_t *)a1, v19, a4, a5);
  (*(void (**)(uint64_t, void *, int8x16_t *))(a1 + 56))(a1, v19, __src);
  cc_clear(*(void *)(a1 + 8) + *(void *)(a1 + 16) + 12, v19);
  sc_reduce((unsigned __int16 *)__src);
  uint64_t v20 = ge_scalarmult_base_masked((uint64_t)v24, __src, a2);
  if (!v20)
  {
    ge_p3_tobytes((uint64_t)a3, (int *)v24);
    ccdigest_init_internal(a1, v19);
    ccdigest_update_internal((unint64_t *)a1, v19, 0x20uLL, a3);
    ccdigest_update_internal((unint64_t *)a1, v19, 0x20uLL, v23);
    ccdigest_update_internal((unint64_t *)a1, v19, a4, a5);
    (*(void (**)(uint64_t, void *, unsigned __int16 *))(a1 + 56))(a1, v19, v25);
    cc_clear(*(void *)(a1 + 8) + *(void *)(a1 + 16) + 12, v19);
    sc_reduce(v25);
    sc_muladd(a3 + 32, v25, __s, (unsigned __int16 *)__src);
  }
  cc_clear(0x40uLL, __s);
  return v20;
}

uint64_t cced25519_sign_with_rng(uint64_t a1, void (**a2)(void, uint64_t, int8x16_t *), char *a3, size_t a4, char *a5, uint64_t a6, char *a7)
{
  BOOL v16 = timingsafe_enable_if_supported();
  uint64_t v14 = cced25519_sign_with_rng_internal(a1, a2, a3, a4, a5, a6, a7);
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v14;
}

uint64_t cced25519_sign(uint64_t a1, char *a2, size_t a3, char *a4, uint64_t a5, char *a6)
{
  BOOL v15 = timingsafe_enable_if_supported();
  uint64_t v12 = ccrng(0);
  if (v12) {
    uint64_t v13 = cced25519_sign_with_rng_internal(a1, (void (**)(void, uint64_t, int8x16_t *))v12, a2, a3, a4, a5, a6);
  }
  else {
    uint64_t v13 = 0xFFFFFFFFLL;
  }
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v13;
}

void *cczp_to_default_ws(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v6 = cczp_n(a2);

  return ccn_set(v6, a3, a4);
}

uint64_t cczp_to_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 56))();
}

uint64_t ccpad_cts2_decrypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v28 = *MEMORY[0x263EF8C08];
  BOOL v24 = timingsafe_enable_if_supported();
  unint64_t v12 = *(void *)(a1 + 8);
  unint64_t v13 = (a4 - 1) / v12;
  if (v13 >= 2)
  {
    uint64_t v15 = (v13 - 1) * v12;
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a2, a3);
    uint64_t v14 = a4 - v15;
    a5 += v15;
    a6 += v15;
  }
  else
  {
    uint64_t v14 = a4;
  }
  if (2 * v12 == v14)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(a2, a3, 2, a5, a6);
  }
  else
  {
    uint64_t v16 = v14 - v12;
    __memcpy_chk();
    __memcpy_chk();
    ecb_from_cbc(a1, a2, (uint64_t)v25, (uint64_t)v27);
    if (v14 - v12 < v12) {
      memcpy(&v26[v16], &v27[v16], 2 * v12 - v14);
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *, uint64_t))(a1 + 24))(a2, a3, 1, v26, a6);
    if (v14 != v12)
    {
      uint64_t v17 = (unsigned char *)(a6 + v12);
      uint64_t v18 = v27;
      unint64_t v19 = v26;
      do
      {
        char v21 = *v19++;
        char v20 = v21;
        char v22 = *v18++;
        *v17++ = v22 ^ v20;
        --v16;
      }
      while (v16);
    }
  }
  cc_disable_dit_with_sb((unsigned int *)&v24);
  return a4;
}

uint64_t ecb_from_cbc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v13[1] = *MEMORY[0x263EF8C08];
  rsize_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = MEMORY[0x270FA53B0](a1, a2, a3, a4);
  uint64_t v11 = (char *)v13 - v10;
  cccbc_set_iv_internal(v9, (char *)v13 - v10, 0);
  cccbc_update_internal(a1, a2, (uint64_t)v11, 1, a3, a4);
  return cc_clear(v8, v11);
}

uint64_t ccrsa_verify_pkcs1v15_internal_ws(uint64_t a1, unint64_t *a2, uint64_t a3, unint64_t a4, char *a5, unint64_t a6, uint64_t a7, int a8, unsigned __int8 *a9)
{
  *(void *)a9 = 0;
  *((void *)a9 + 1) = 0;
  uint64_t v16 = a2 + 3;
  unint64_t v17 = *a2;
  unint64_t v18 = ccn_write_uint_size_public_value(*a2, a2 + 3);
  BOOL v19 = v18 >= a6;
  if (a8 != 2110636126) {
    BOOL v19 = v18 == a6;
  }
  if (v19)
  {
    uint64_t v26 = a3;
    unint64_t v27 = a5;
    uint64_t v20 = *(void *)(a1 + 16);
    char v21 = (unint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v17);
    char v22 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v17);
    cc_clear(8 * (*(void *)(a1 + 16) - v20), (void *)(*(void *)a1 + 8 * v20));
    unint64_t v23 = ccn_write_uint_size_public_value(v17, v16);
    if (ccn_read_uint_internal(v17, v21, a6, a7))
    {
      int v24 = -23;
    }
    else
    {
      unsigned int v29 = ccrsa_pub_crypt_ws(a1, a2, v22, v21);
      if (v29)
      {
LABEL_9:
        *(void *)(a1 + 16) = v20;
        return v29;
      }
      ccn_swap(v17, (unint64_t *)v22);
      if (ccrsa_emsa_pkcs1v15_verify_canary_out(v23, (unsigned char *)&v22[v17] - v23, a4, v27, v26, a9)) {
        int v24 = -146;
      }
      else {
        int v24 = a9[8] ^ a9[4] ^ a9[3] ^ a9[13] ^ 0x89 ^ a9[15] ^ a9[10] ^ a9[1] ^ a9[11] ^ a9[14] ^ a9[6] ^ a9[2] ^ a9[9] ^ a9[12] ^ *a9 ^ a9[7] ^ a9[5];
      }
    }
    unsigned int v29 = v24;
    goto LABEL_9;
  }
  return 4294967273;
}

uint64_t ccrsa_verify_pkcs1v15_internal(unint64_t *a1, uint64_t a2, unint64_t a3, char *a4, unint64_t a5, uint64_t a6, int a7, unsigned __int8 *a8)
{
  unint64_t v14 = *a1;
  uint64_t v15 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v16 = sizeof_struct_ccpolyzp_po2cyc();
  v24[0] = cc_malloc_clear(8 * ((v15 + v16 - 1) / v16 + 13 * v14) + 8);
  unint64_t v17 = *a1;
  uint64_t v18 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v19 = sizeof_struct_ccpolyzp_po2cyc();
  v24[1] = (v18 + v19 - 1) / v19 + 13 * v17 + 1;
  v24[2] = 0;
  v24[3] = cc_ws_alloc;
  uint64_t v25 = cc_ws_free;
  if (!v24[0]) {
    return 4294967283;
  }
  uint64_t v20 = ccrsa_verify_pkcs1v15_internal_ws((uint64_t)v24, a1, a2, a3, a4, a5, a6, a7, a8);
  v25((uint64_t)v24);
  return v20;
}

uint64_t ccapsic_client_check_intersect_response_ws(uint64_t a1, uint64_t **a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t **a7)
{
  unint64_t v7 = *a2;
  if (*a7 != *a2 || (uint64_t *)*a3 != v7 || (uint64_t *)*a4 != v7) {
    return 4294967289;
  }
  uint64_t v12 = (uint64_t)(a2 + 24);
  uint64_t v13 = *v7;
  unint64_t v14 = a2[1];
  uint64_t result = ccec_generate_scalar_fips_retry_ws(a1, v7, (uint64_t (**)(void, unint64_t, void *))v14, a2 + 24);
  if (result) {
    return result;
  }
  unint64_t v23 = (void *)(v12 + 8 * v13);
  uint64_t result = ccec_generate_scalar_fips_retry_ws(a1, v7, (uint64_t (**)(void, unint64_t, void *))v14, v23);
  if (result) {
    return result;
  }
  uint64_t result = cch2c_ws(a1, (uint64_t)a2[2], (uint64_t)a2[3]);
  if (result) {
    return result;
  }
  int v24 = (void **)a3;
  uint64_t v16 = 3 * v13;
  unint64_t v17 = *a2;
  uint64_t v18 = **a2;
  if (!ccn_cmp_internal(3 * v13, v12 + 16 * v18 + 72 * v18, a7 + 2)) {
    return 4294967289;
  }
  unint64_t v19 = (char *)(v24 + 2);
  if (!ccn_cmp_internal(3 * v13, &v17[2 * v18 + 4 + v18], v24 + 2)) {
    return 4294967289;
  }
  uint64_t v20 = (char *)(a4 + 2);
  uint64_t result = ccec_projectify_ws(a1, (uint64_t)v7);
  if (!result)
  {
    char v21 = (char *)(v12 + 16 * v13);
    uint64_t v22 = (uint64_t)&v21[48 * v13];
    uint64_t result = ccec_projectify_ws(a1, (uint64_t)v7);
    if (!result)
    {
      uint64_t result = ccec_twin_mult_ws(a1, v7, v19, v12, (uint64_t)v20, (uint64_t)v23, v21);
      if (!result)
      {
        uint64_t result = ccec_twin_mult_ws(a1, v7, v20, v12, v22, (uint64_t)v23, &v21[8 * v16]);
        if (!result)
        {
          uint64_t result = ccec_affinify_ws(a1, (uint64_t)v7);
          if (!result)
          {
            uint64_t result = ccec_affinify_ws(a1, (uint64_t)v7);
            if (!result)
            {
              ccn_seti(*v7, &v20[16 * *(void *)*a4], 1);
              ccn_seti(*v7, &v19[16 * **v24], 1);
              return 0;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t ccapsic_client_check_intersect_response(uint64_t **a1, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t **a6)
{
  BOOL v26 = timingsafe_enable_if_supported();
  uint64_t v12 = *a1;
  uint64_t v13 = **a1;
  uint64_t v14 = sizeof_struct_cche_galois_key();
  unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v16 = 18 * v13 + 2 * ((v14 + v15 + 3 * v13 * v15 - 1) / v15 + v13);
  if (v16 <= 33 * v13) {
    unint64_t v16 = 33 * v13;
  }
  unint64_t v17 = cc_malloc_clear(8 * v16);
  v24[0] = v17;
  uint64_t v18 = *v12;
  uint64_t v19 = sizeof_struct_cche_galois_key();
  unint64_t v20 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v21 = 18 * v18 + 2 * ((v19 + v20 + 3 * v18 * v20 - 1) / v20 + v18);
  if (v21 <= 33 * v18) {
    unint64_t v21 = 33 * v18;
  }
  v24[1] = v21;
  v24[2] = 0;
  v24[3] = cc_ws_alloc;
  uint64_t v25 = cc_ws_free;
  if (v17)
  {
    uint64_t v22 = ccapsic_client_check_intersect_response_ws((uint64_t)v24, a1, a2, a3, a4, a5, a6);
    v25((uint64_t)v24);
  }
  else
  {
    uint64_t v22 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v26);
  return v22;
}

size_t ccpad_pkcs7_ecb_encrypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v14 = timingsafe_enable_if_supported();
  unint64_t v10 = *(void *)(a1 + 8);
  size_t v11 = (v10 - 1) & a3;
  size_t v12 = a3 - v11;
  (*(void (**)(uint64_t, size_t, uint64_t, uint64_t))(a1 + 24))(a2, (a3 - v11) / v10, a4, a5);
  memcpy((void *)(a5 + v12), (const void *)(a4 + v12), v11);
  memset((void *)(a5 + a3), v10 - v11, v10 - v11);
  (*(void (**)(uint64_t, uint64_t, size_t, size_t))(a1 + 24))(a2, 1, a5 + v12, a5 + v12);
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return a3 - v11 + v10;
}

void *ccdh_gp_apple768()
{
  return &_ccdh_gp_apple768;
}

_DWORD **cche_mul_poly_sk(_DWORD **result, unsigned int **a2, _DWORD **a3)
{
  BOOL v3 = *a2;
  unsigned int v4 = (*a2)[1];
  if (v4)
  {
    int v5 = 0;
    unsigned int v6 = 0;
    uint64_t v7 = *v3;
    rsize_t v8 = a2 + 1;
    do
    {
      uint64_t v9 = v3;
      if (v4 - 1 > v6)
      {
        unsigned int v10 = v4 - 1;
        uint64_t v9 = v3;
        do
        {
          uint64_t v9 = (void *)v9[14];
          --v10;
        }
        while (v10 > v6);
      }
      if (v7)
      {
        unsigned int v11 = **a3 * v6;
        unsigned int v12 = **result * v6;
        uint64_t v13 = v7;
        int v14 = v5;
        do
        {
          unint64_t v15 = (unint64_t)v8[v14];
          unint64_t v16 = (unint64_t)a3[v11 + 1];
          unint64_t v17 = (v16 * (unsigned __int128)v15) >> 64;
          uint64_t v18 = v16 * v15;
          unint64_t v19 = v9[4];
          uint64_t v20 = ((unint64_t)v18 * (unsigned __int128)v19) >> 64;
          uint64_t v21 = (v17 * (unsigned __int128)v19) >> 64;
          uint64_t v22 = v17 * v19;
          BOOL v23 = __CFADD__(v20, v22);
          uint64_t v24 = v20 + v22;
          uint64_t v25 = v23;
          uint64_t v26 = v25
              + __CFADD__(v18 * v9[5], v24)
              + v21
              + v9[5] * v17
              + (((unint64_t)v18 * (unsigned __int128)(unint64_t)v9[5]) >> 64);
          uint64_t v27 = v9[2];
          uint64_t v28 = (_DWORD *)(v18 - v26 * v27);
          if ((uint64_t)v28 - v27 >= 0) {
            uint64_t v28 = (_DWORD *)((char *)v28 - v27);
          }
          result[v12 + 1] = v28;
          ++v11;
          ++v14;
          ++v12;
          --v13;
        }
        while (v13);
      }
      ++v6;
      v5 += v7;
    }
    while (v6 != v4);
  }
  return result;
}

uint64_t cced25519_to_ed25519_point_ws(uint64_t a1, uint64_t a2)
{
  cczp_n(a2);
  uint64_t v4 = *(void *)(a1 + 16);
  cczp_mul_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  uint64_t result = cczp_sqr_ws(a1, a2);
  *(void *)(a1 + 16) = v4;
  return result;
}

void *cced25519_from_ed25519_point_ws(uint64_t a1, void *a2, char *a3, char *a4)
{
  uint64_t v7 = cczp_n((uint64_t)a2);
  ccn_set(v7, a3, a4);
  ccn_set(v7, &a3[8 * *a2], &a4[8 * v7]);
  rsize_t v8 = &a3[16 * *a2];

  return ccn_set(v7, v8, &a4[24 * v7]);
}

uint64_t cced25519_hash_to_scalar_ws(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t *a4, size_t a5, char *a6, size_t a7, char *a8, size_t a9, char *a10)
{
  uint64_t v31 = a8;
  unsigned int v35 = a4;
  uint64_t v37 = *MEMORY[0x263EF8C08];
  uint64_t v32 = *a2;
  uint64_t v16 = cczp_n((uint64_t)a2);
  uint64_t v34 = *(void *)(a1 + 16);
  uint64_t v17 = 2 * v16;
  uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 2 * v16);
  uint64_t v33 = &v29;
  MEMORY[0x270FA53B0](v30, v18, v19, v20);
  uint64_t v22 = (uint64_t *)((char *)&v29 - v21);
  ccdigest_init_internal(a3, (uint64_t *)((char *)&v29 - v21));
  ccdigest_update_internal((unint64_t *)a3, v22, a5, a6);
  ccdigest_update_internal((unint64_t *)a3, v22, a7, v31);
  ccdigest_update_internal((unint64_t *)a3, v22, a9, a10);
  (*(void (**)(uint64_t, void *, unsigned char *))(a3 + 56))(a3, v22, __s);
  cc_clear(*(void *)(a3 + 8) + *(void *)(a3 + 16) + 12, v22);
  BOOL v23 = (char *)v30;
  if (v17)
  {
    uint64_t v24 = (uint64_t *)__s;
    uint64_t v25 = (void *)v30;
    uint64_t v26 = v17;
    do
    {
      uint64_t v27 = *v24++;
      *v25++ = v27;
      --v26;
    }
    while (v26);
  }
  cczp_modn_ws(a1, &a2[5 * v32 + 4], v35, v17, v23);
  uint64_t result = cc_clear(0x40uLL, __s);
  *(void *)(a1 + 16) = v34;
  return result;
}

uint64_t ccz_divmod(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  BOOL v33 = timingsafe_enable_if_supported();
  if (!ccz_is_zero((uint64_t)a4))
  {
    uint64_t v8 = ccz_n((uint64_t)a3);
    uint64_t v9 = a3[3];
    uint64_t v10 = ccz_n((uint64_t)a4);
    if ((ccn_cmpn_internal(v8, v9, v10, a4[3]) & 0x80000000) != 0)
    {
      if (a2) {
        ccz_set(a2, (uint64_t)a3);
      }
      if (a1) {
        ccz_zero((void *)a1);
      }
    }
    else
    {
      long long v31 = 0u;
      *(_OWORD *)long long __src = 0u;
      memset(v30, 0, sizeof(v30));
      memset(v29, 0, sizeof(v29));
      long long v27 = 0u;
      *(_OWORD *)uint64_t v28 = 0u;
      ccz_init(a3[1], (uint64_t)v29);
      ccz_init(a3[1], (uint64_t)&v27);
      ccz_init(a3[1], (uint64_t)&v31);
      ccz_init(a3[1], (uint64_t)v30);
      uint64_t v11 = ccz_bitlen(a3);
      uint64_t v12 = ccz_bitlen(a4);
      ccz_seti((uint64_t)v29, 1);
      ccz_lsl((uint64_t)v29, (uint64_t)v29, v11 - v12);
      ccz_set((uint64_t)&v31, (uint64_t)a3);
      ccz_set_sign((uint64_t)&v31, 1);
      ccz_lsl((uint64_t)v30, (uint64_t)a4, v11 - v12);
      ccz_set_sign((uint64_t)v30, 1);
      for (uint64_t i = v12 - v11; ; ++i)
      {
        if ((ccz_cmp((uint64_t)&v31, (uint64_t)v30) & 0x80000000) == 0)
        {
          ccz_sub(&v31, (uint64_t)&v31, (uint64_t)v30);
          ccz_add(&v27, (uint64_t)&v27, (uint64_t)v29);
        }
        if (!i) {
          break;
        }
        ccz_lsr(v30, (uint64_t)v30, 1uLL);
        ccz_lsr(v29, (uint64_t)v29, 1uLL);
      }
      int v14 = ccz_sign((uint64_t)a3);
      int v15 = ccz_sign((uint64_t)a4);
      if (a2)
      {
        unint64_t v16 = ccz_n((uint64_t)&v31);
        ccz_set_capacity(a2, v16);
        uint64_t v17 = ccz_n((uint64_t)&v31);
        ccz_set_n((void *)a2, v17);
        uint64_t v18 = ccz_n(a2);
        ccn_set(v18, *(void **)(a2 + 24), __src[1]);
        if (ccz_is_zero(a2)) {
          int v19 = 1;
        }
        else {
          int v19 = v14;
        }
        ccz_set_sign(a2, v19);
      }
      if (a1)
      {
        unint64_t v20 = ccz_n((uint64_t)&v27);
        ccz_set_capacity(a1, v20);
        uint64_t v21 = ccz_n((uint64_t)&v27);
        ccz_set_n((void *)a1, v21);
        uint64_t v22 = ccz_n(a1);
        ccn_set(v22, *(void **)(a1 + 24), v28[1]);
        BOOL is_zero = ccz_is_zero(a1);
        if (v14 == v15 || is_zero) {
          int v25 = 1;
        }
        else {
          int v25 = -1;
        }
        ccz_set_sign(a1, v25);
      }
      ccz_free((uint64_t)v29);
      ccz_free((uint64_t)&v27);
      ccz_free((uint64_t)&v31);
      ccz_free((uint64_t)v30);
    }
  }
  return cc_disable_dit_with_sb((unsigned int *)&v33);
}

uint64_t ccss_shamir_generate_share_poly_ws(uint64_t a1, uint64_t *a2, uint64_t (**a3)(void, unint64_t, uint64_t), unint64_t a4, uint64_t a5, int a6)
{
  if (!ccss_shamir_secret_one_byte_smaller_than_prime(*a2, a4) && !a6) {
    return 4294967176;
  }
  uint64_t result = ccss_shamir_generate_random_poly_ws(a1, (uint64_t)a2, a3);
  if (!result)
  {
    uint64_t v13 = *a2;
    return ccss_encode_string_into_value_smaller_than_prime(v13, a2 + 2, a4, a5);
  }
  return result;
}

uint64_t ccrng_zero_generate(int a1, size_t a2, void *a3)
{
  return 0;
}

uint64_t ccec_diversify_pub(uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t (**a5)(void, uint64_t, unint64_t *), unint64_t **a6, unint64_t **a7)
{
  BOOL v31 = timingsafe_enable_if_supported();
  uint64_t v14 = *a1;
  unint64_t v15 = 26 * *a1;
  unint64_t v16 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v17 = (v16 + 127) / v16 + 4 * v14 + 3;
  if (v15 > v17) {
    unint64_t v17 = v15;
  }
  uint64_t v18 = cc_malloc_clear(8 * (v17 + v14));
  v27[0] = v18;
  uint64_t v19 = *a1;
  unint64_t v20 = 26 * *a1;
  unint64_t v21 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v22 = (v21 + 127) / v21 + 4 * v19 + 3;
  if (v20 > v22) {
    unint64_t v22 = v20;
  }
  v27[1] = v22 + v19;
  uint64_t v28 = 0;
  uint64_t v29 = cc_ws_alloc;
  uint64_t v30 = cc_ws_free;
  if (v18)
  {
    BOOL v23 = (char *)cc_ws_alloc(v27, v19);
    scalar_fips_extrabits_uint64_t ws = ccec_generate_scalar_fips_extrabits_ws((uint64_t)v27, a1, a3, a4, v23);
    if (!scalar_fips_extrabits_ws)
    {
      scalar_fips_extrabits_uint64_t ws = ccec_make_pub_from_priv_ws((uint64_t)v27, (unint64_t *)a1, a5, (uint64_t)v23, 0, a6);
      if (!scalar_fips_extrabits_ws) {
        scalar_fips_extrabits_uint64_t ws = ccec_make_pub_from_priv_ws((uint64_t)v27, (unint64_t *)a1, a5, (uint64_t)v23, a2 + 16, a7);
      }
    }
    uint64_t v25 = scalar_fips_extrabits_ws;
    uint64_t v28 = 0;
    v30((uint64_t)v27);
  }
  else
  {
    uint64_t v25 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v31);
  return v25;
}

uint64_t ccn_shift_right(uint64_t result, uint64_t a2, unint64_t *a3, unint64_t a4)
{
  if (result)
  {
    unint64_t v4 = *a3;
    uint64_t v5 = 0;
    if (result == 1)
    {
      unint64_t v6 = *a3;
    }
    else
    {
      unint64_t v7 = ((a4 | HIDWORD(a4)) + 0xFFFFFFFF) >> 32;
      uint64_t v8 = -(uint64_t)v7;
      char v9 = v7 - a4 + 63;
      do
      {
        unint64_t v6 = a3[v5 + 1];
        *(void *)(a2 + 8 * v5++) = (v6 << v9) & v8 | (v4 >> a4);
        unint64_t v4 = v6;
      }
      while (result - 1 != v5);
    }
    *(void *)(a2 + 8 * v5) = v6 >> a4;
  }
  return result;
}

double ccvrf_factory_irtfdraft03(uint64_t a1, void *a2)
{
  if (*a2 == *(void *)ccsha512_di())
  {
    long long v5 = unk_26EA47740;
    *(_OWORD *)(a1 + 32) = xmmword_26EA47730;
    *(_OWORD *)(a1 + 48) = v5;
    *(_OWORD *)(a1 + 64) = xmmword_26EA47750;
    *(uint64_t (**)())(a1 + 80) = off_26EA47760[0];
    double result = *(double *)&_vrf_irtf_ed25519_draft03;
    long long v6 = unk_26EA47720;
    *(_OWORD *)a1 = _vrf_irtf_ed25519_draft03;
    *(_OWORD *)(a1 + 16) = v6;
    *(void *)(a1 + 40) = a2;
  }
  return result;
}

double ccvrf_factory_irtfdraft03_default(uint64_t a1)
{
  BOOL v2 = ccsha512_di();
  if (*v2 == *(void *)ccsha512_di())
  {
    long long v4 = unk_26EA47740;
    *(_OWORD *)(a1 + 32) = xmmword_26EA47730;
    *(_OWORD *)(a1 + 48) = v4;
    *(_OWORD *)(a1 + 64) = xmmword_26EA47750;
    *(uint64_t (**)())(a1 + 80) = off_26EA47760[0];
    double result = *(double *)&_vrf_irtf_ed25519_draft03;
    long long v5 = unk_26EA47720;
    *(_OWORD *)a1 = _vrf_irtf_ed25519_draft03;
    *(_OWORD *)(a1 + 16) = v5;
    *(void *)(a1 + 40) = v2;
  }
  return result;
}

uint64_t ccvrf_sizeof_proof(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t ccvrf_sizeof_hash(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t ccvrf_sizeof_public_key(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t ccvrf_sizeof_secret_key(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t ccec_generate_key(unint64_t *a1, uint64_t (**a2)(void, uint64_t, unint64_t *), unint64_t **a3)
{
  BOOL v12 = timingsafe_enable_if_supported();
  long long v6 = cc_malloc_clear(392 * *a1);
  uint64_t v7 = 49 * *a1;
  v10[0] = v6;
  v10[1] = v7;
  void v10[2] = 0;
  v10[3] = cc_ws_alloc;
  uint64_t v11 = cc_ws_free;
  if (v6)
  {
    key_fips_uint64_t ws = ccec_generate_key_fips_ws((uint64_t)v10, a1, a2, a3);
    cc_try_abort_if (key_fips_ws == -18);
    v11((uint64_t)v10);
  }
  else
  {
    key_fips_uint64_t ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return key_fips_ws;
}

unsigned __int8 *ccder_decode_rsa_priv_n(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v7 = a2;
  unint64_t v5 = 0;
  uint64_t v6 = 0;
  double result = ccder_decode_constructed_tl(0x2000000000000010, &v7, a1, a2);
  if (result)
  {
    BOOL v3 = ccder_decode_uint(1uLL, &v6, result, v7);
    if (v3) {
      BOOL v4 = v6 == 0;
    }
    else {
      BOOL v4 = 0;
    }
    if (v4)
    {
      if (ccder_decode_uint_n(&v5, v3, v7)) {
        return (unsigned __int8 *)v5;
      }
      else {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t ccder_blob_encode_len(uint64_t *a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    return 0;
  }
  uint64_t v3 = *a1;
  unint64_t v2 = a1[1];
  if (a2 > 0x7F)
  {
    if (a2 > 0xFF)
    {
      if (a2 >> 16)
      {
        if (a2 >> 24)
        {
          if (v3 + 5 <= v2)
          {
            *(unsigned char *)(v2 - 5) = -124;
            unint64_t v4 = v2 - 5;
            *(_DWORD *)(v4 + 1) = bswap32(a2);
            goto LABEL_17;
          }
        }
        else if (v3 + 4 <= v2)
        {
          *(unsigned char *)(v2 - 4) = -125;
          unint64_t v4 = v2 - 4;
          *(_WORD *)(v4 + 2) = bswap32(a2) >> 16;
          *(unsigned char *)(v4 + 1) = BYTE2(a2);
          goto LABEL_17;
        }
      }
      else if (v3 + 3 <= v2)
      {
        *(unsigned char *)(v2 - 3) = -126;
        unint64_t v4 = v2 - 3;
        *(_WORD *)(v4 + 1) = bswap32(a2) >> 16;
        goto LABEL_17;
      }
    }
    else if (v3 + 2 <= v2)
    {
      *(unsigned char *)(v2 - 2) = -127;
      unint64_t v4 = v2 - 2;
      *(unsigned char *)(v4 + 1) = a2;
      goto LABEL_17;
    }
    return 0;
  }
  if (v3 + 1 > v2) {
    return 0;
  }
  *(unsigned char *)(v2 - 1) = a2;
  unint64_t v4 = v2 - 1;
LABEL_17:
  *a1 = v3;
  a1[1] = v4;
  return 1;
}

uint64_t ccec_der_export_diversified_pub_size(uint64_t *a1, uint64_t *a2, char a3)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v6 = cczp_bitlen(*a2);
  if ((a3 & 4) != 0)
  {
    uint64_t v7 = ccder_sizeof_raw_octet_string((unint64_t)(v6 + 7) >> 3);
    unint64_t v8 = (unint64_t)(cczp_bitlen(*a1) + 7) >> 3;
  }
  else
  {
    uint64_t v7 = ccder_sizeof_raw_octet_string(((unint64_t)(v6 + 7) >> 2) | 1);
    unint64_t v8 = ((unint64_t)(cczp_bitlen(*a1) + 7) >> 2) | 1;
  }
  uint64_t v9 = ccder_sizeof_raw_octet_string(v8);
  uint64_t v10 = ccder_sizeof(0x2000000000000010, v9 + v7);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccec_der_export_diversified_pub(uint64_t *a1, uint64_t *a2, char a3, uint64_t a4, uint64_t a5)
{
  BOOL v27 = timingsafe_enable_if_supported();
  uint64_t v10 = (void *)*a2;
  v23[0] = cc_malloc_clear((32 * *(void *)*a2) | 0x10);
  v23[1] = (4 * *v10) | 2;
  uint64_t v24 = 0;
  uint64_t v25 = cc_ws_alloc;
  uint64_t v26 = cc_ws_free;
  if (v23[0])
  {
    uint64_t v11 = *(void *)*a2;
    uint64_t v12 = cczp_bitlen(*a2);
    uint64_t v13 = cczp_bitlen(*a2);
    uint64_t v14 = (2 * v11) | 1;
    unint64_t v15 = (char *)cc_ws_alloc(v23, v14);
    unint64_t v16 = (char *)v25(v23, v14);
    if ((a3 & 4) != 0)
    {
      if (!ccec_compact_export_pub(v15, a2) && !ccec_compact_export_pub(v16, a1))
      {
        unint64_t v17 = (unint64_t)(v12 + 7) >> 3;
        goto LABEL_10;
      }
    }
    else if (!ccec_export_pub(a2, v15) && !ccec_export_pub(a1, v16))
    {
      unint64_t v17 = ((unint64_t)(v13 + 7) >> 2) | 1;
LABEL_10:
      uint64_t v19 = a5 + a4;
      uint64_t v20 = ccder_encode_raw_octet_string(v17, (uint64_t)v15, a5, v19);
      uint64_t v21 = ccder_encode_raw_octet_string(v17, (uint64_t)v16, a5, v20);
      uint64_t v18 = ccder_encode_constructed_tl(0x2000000000000010uLL, v19, a5, v21);
      uint64_t v24 = 0;
LABEL_11:
      v26((uint64_t)v23);
      goto LABEL_12;
    }
    uint64_t v18 = 0;
    goto LABEL_11;
  }
  uint64_t v18 = 0;
LABEL_12:
  cc_disable_dit_with_sb((unsigned int *)&v27);
  return v18;
}

uint64_t ccec_get_fullkey_components(uint64_t *a1, uint64_t *a2, uint64_t a3, unint64_t *a4, uint64_t a5, unint64_t *a6, uint64_t a7, unint64_t *a8)
{
  BOOL v23 = timingsafe_enable_if_supported();
  unint64_t v16 = *(void *)*a1;
  if (ccec_get_pubkey_components(a1, a2, a3, a4, a5, a6)
    || (uint64_t v19 = (void *)*a1,
        unint64_t v17 = a1 + 2,
        uint64_t v18 = v19,
        unint64_t v20 = ccn_write_uint_size_public_value(v16, (unint64_t *)&v17[3 * *v19]),
        v20 > *a8))
  {
    uint64_t v21 = 0xFFFFFFFFLL;
  }
  else
  {
    *a8 = v20;
    ccn_write_uint_internal(v16, &v17[3 * *v18], v20, a7);
    uint64_t v21 = 0;
  }
  cc_disable_dit_with_sb((unsigned int *)&v23);
  return v21;
}

void *ccmode_factory_cbc_encrypt(void *result, void *a2)
{
  uint64_t v2 = a2[1];
  *double result = ((v2 + 7) & 0xFFFFFFFFFFFFFFF8) + ((*a2 + 7) & 0xFFFFFFFFFFFFFFF8) + 8;
  result[1] = v2;
  result[2] = ccmode_cbc_init;
  result[3] = ccmode_cbc_encrypt;
  result[4] = a2;
  return result;
}

uint64_t ccdes_ltc_setup(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  if (a3 != 8) {
    return 0xFFFFFFFFLL;
  }
  deskey(a4, 0, a2);
  deskey(a4, 1, a2 + 8);
  return 0;
}

uint64_t ccec_generate_scalar_fips_retry_ws(uint64_t a1, void *a2, uint64_t (**a3)(void, unint64_t, void *), void *a4)
{
  unint64_t v8 = a2 + 4;
  uint64_t v9 = (uint64_t)&a2[5 * *a2 + 4];
  uint64_t v10 = cczp_n(v9);
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10);
  uint64_t v13 = (void *)cczp_prime(v9);
  ccn_set(v10, v12, v13);
  *v12 &= ~1uLL;
  uint64_t v14 = 100;
  while (1)
  {
    uint64_t v15 = cczp_bitlen((uint64_t)&v8[5 * *a2]);
    uint64_t result = ccn_random_bits_fips(v15, a4, a3);
    if (result) {
      break;
    }
    if ((ccn_cmp_internal(v10, a4, v12) & 0x80000000) != 0)
    {
      ccn_add1_ws(a1, v10, a4, a4, 1);
      uint64_t result = 0;
      break;
    }
    if (!--v14)
    {
      uint64_t result = 4294967281;
      break;
    }
  }
  *(void *)(a1 + 16) = v11;
  return result;
}

uint64_t ccec_generate_scalar_fips_retry(void *a1, uint64_t (**a2)(void, unint64_t, void *), void *a3)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v6 = (uint64_t)&a1[5 * *a1 + 4];
  uint64_t v7 = cczp_n(v6);
  v10[0] = cc_malloc_clear(8 * v7);
  v10[1] = cczp_n(v6);
  void v10[2] = 0;
  v10[3] = cc_ws_alloc;
  uint64_t v11 = cc_ws_free;
  if (v10[0])
  {
    uint64_t scalar_fips_retry_ws = ccec_generate_scalar_fips_retry_ws((uint64_t)v10, a1, a2, a3);
    v11((uint64_t)v10);
  }
  else
  {
    uint64_t scalar_fips_retry_ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return scalar_fips_retry_ws;
}

uint64_t ccec_sign_msg_ws(uint64_t a1, uint64_t **a2, unint64_t *a3, size_t a4, char *a5, unint64_t *a6, uint64_t a7, uint64_t (**a8)(void, unint64_t, void *))
{
  uint64_t v16 = *MEMORY[0x263EF8C08];
  ccdigest_internal((uint64_t)a3, a4, a5, (uint64_t)v15);
  return ccec_sign_ws(a1, a2, *a3, (uint64_t)v15, a6, a7, a8);
}

uint64_t ccec_sign_ws(uint64_t a1, uint64_t **a2, unint64_t a3, uint64_t a4, unint64_t *a5, uint64_t a6, uint64_t (**a7)(void, unint64_t, void *))
{
  uint64_t v14 = **a2;
  uint64_t v15 = *(void *)(a1 + 16);
  uint64_t v16 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v14);
  unint64_t v17 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v14);
  uint64_t result = ccec_sign_internal_ws(a1, a2, a3, a4, v16, v17, a7);
  if (!result)
  {
    uint64_t v19 = *a2;
    unint64_t v20 = **a2;
    uint64_t v21 = ccder_sizeof_integer(v20, v16);
    uint64_t v22 = ccder_sizeof_integer(v20, (unint64_t *)v17);
    unint64_t v23 = ccder_sizeof(0x2000000000000010, v22 + v21);
    unint64_t v24 = *a5;
    *a5 = v23;
    if (v24 >= v23)
    {
      uint64_t v25 = a6 + v23;
      unint64_t v26 = *v19;
      uint64_t v27 = ccder_encode_integer(*v19, (unint64_t *)v17, a6, a6 + v23);
      uint64_t v28 = ccder_encode_integer(v26, v16, a6, v27);
      ccder_encode_constructed_tl(0x2000000000000010uLL, v25, a6, v28);
      uint64_t result = 0;
    }
    else
    {
      uint64_t result = 4294967133;
    }
  }
  *(void *)(a1 + 16) = v15;
  return result;
}

uint64_t ccec_sign_msg(uint64_t **a1, unint64_t *a2, size_t a3, char *a4, unint64_t *a5, uint64_t a6, uint64_t (**a7)(void, unint64_t, void *))
{
  uint64_t v21 = *MEMORY[0x263EF8C08];
  BOOL v19 = timingsafe_enable_if_supported();
  uint64_t v14 = *a1;
  v17[0] = cc_malloc_clear(280 * **a1);
  v17[1] = 35 * *v14;
  v17[2] = 0;
  _OWORD v17[3] = cc_ws_alloc;
  uint64_t v18 = cc_ws_free;
  if (v17[0])
  {
    ccdigest_internal((uint64_t)a2, a3, a4, (uint64_t)v20);
    uint64_t v15 = ccec_sign_ws((uint64_t)v17, a1, *a2, (uint64_t)v20, a5, a6, a7);
    v18((uint64_t)v17);
  }
  else
  {
    uint64_t v15 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v19);
  return v15;
}

uint64_t ccec_sign(uint64_t **a1, unint64_t a2, uint64_t a3, unint64_t *a4, uint64_t a5, uint64_t (**a6)(void, unint64_t, void *))
{
  BOOL v17 = timingsafe_enable_if_supported();
  BOOL v12 = *a1;
  v15[0] = cc_malloc_clear(280 * **a1);
  v15[1] = 35 * *v12;
  void v15[2] = 0;
  v15[3] = cc_ws_alloc;
  uint64_t v16 = cc_ws_free;
  if (v15[0])
  {
    uint64_t v13 = ccec_sign_ws((uint64_t)v15, a1, a2, a3, a4, a5, a6);
    v16((uint64_t)v15);
  }
  else
  {
    uint64_t v13 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v17);
  return v13;
}

uint64_t ccder_sizeof_raw_octet_string(uint64_t a1)
{
  return ccder_sizeof_implicit_raw_octet_string(4, a1);
}

uint64_t cch2c_encode_to_curve_ro_ws(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  uint64_t v10 = (void *)(*(uint64_t (**)(void))(a2 + 16))();
  uint64_t v11 = *v10;
  uint64_t v14 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, void))(a1 + 24))(a1, *v10);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v11);
  unint64_t v12 = (unint64_t)(24 * v11 + 23) >> 3;
  (*(void (**)(uint64_t, unint64_t))(a1 + 24))(a1, v12);
  (*(void (**)(uint64_t, unint64_t))(a1 + 24))(a1, v12);
  *a7 = v10;
  uint64_t result = cch2c_hash_to_base_ws(a1, a2);
  if (!result)
  {
    uint64_t result = cch2c_hash_to_base_ws(a1, a2);
    if (!result)
    {
      uint64_t result = cch2c_map_to_curve_ws(a1, a2);
      if (!result)
      {
        uint64_t result = ccec_projectify_ws(a1, (uint64_t)v10);
        if (!result)
        {
          uint64_t result = cch2c_map_to_curve_ws(a1, a2);
          if (!result)
          {
            uint64_t result = ccec_projectify_ws(a1, (uint64_t)v10);
            if (!result)
            {
              ccec_full_add_ws(a1, (uint64_t)v10);
              uint64_t result = ccec_affinify_ws(a1, (uint64_t)v10);
              if (!result) {
                uint64_t result = (*(uint64_t (**)(uint64_t, void *))(a2 + 48))(a2, a7);
              }
            }
          }
        }
      }
    }
  }
  *(void *)(a1 + 16) = v14;
  return result;
}

uint64_t cch2c_encode_to_curve_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

uint64_t ccec_sign_internal_inner_ws(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8, uint64_t a9, uint64_t (**a10)(void, uint64_t, unint64_t *))
{
  unint64_t v15 = *a2;
  uint64_t v22 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, unint64_t))(a1 + 24))(a1, *a2);
  uint64_t v16 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 3 * v15);
  uint64_t result = ccec_mult_blinded_ws(a1, a2, (uint64_t)v16, a5, a6, a10);
  if (!result)
  {
    uint64_t result = ccec_affinify_x_only_ws(a1, a2, (uint64_t)v16, (uint64_t)v16);
    if (!result)
    {
      uint64_t v18 = (uint64_t)&a2[5 * v15 + 4];
      BOOL v19 = (unint64_t *)cczp_prime(v18);
      uint64_t v20 = ccn_sub_ws(a1, v15, a8, v16, v19);
      uint64_t v21 = (uint64_t *)cczp_prime(v18);
      ccn_cond_add(v15, v20, a8, a8, v21);
      if (ccn_n(v15, (uint64_t)a8))
      {
        cczp_mul_ws(a1, v18);
        cczp_mul_ws(a1, v18);
        cczp_mul_ws(a1, v18);
        cczp_mul_ws(a1, v18);
        cczp_add_ws(a1, v18);
        uint64_t result = cczp_inv_ws(a1, v18);
        if (!result)
        {
          cczp_mul_ws(a1, v18);
          if (ccn_n(v15, a9)) {
            uint64_t result = 0;
          }
          else {
            uint64_t result = 4294967131;
          }
        }
      }
      else
      {
        uint64_t result = 4294967131;
      }
    }
  }
  *(void *)(a1 + 16) = v22;
  return result;
}

uint64_t ccec_sign_internal_ws(uint64_t a1, uint64_t **a2, unint64_t a3, uint64_t a4, void *a5, void *a6, uint64_t (**a7)(void, unint64_t, void *))
{
  uint64_t v11 = (unint64_t *)*a2;
  uint64_t v13 = (uint64_t)(*a2 + 4);
  uint64_t v12 = **a2;
  if (a3 <= 0xF)
  {
    BOOL v31 = cc_log_default();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT)) {
      ccec_sign_internal_ws_cold_1(a3, v31);
    }
  }
  uint64_t v35 = *(void *)(a1 + 16);
  uint64_t v14 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  uint64_t v39 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 3 * v12);
  uint64_t uint_internal = ccec_projectify_ws(a1, (uint64_t)v11);
  if (uint_internal) {
    goto LABEL_20;
  }
  uint64_t v32 = a7;
  uint64_t v37 = (void *)v15;
  uint64_t v17 = **a2;
  uint64_t v18 = cczp_bitlen(v13 + 40 * *v11);
  BOOL v19 = a2;
  unint64_t v20 = v18;
  unint64_t v21 = (unint64_t)(v18 + 7) >> 3 >= a3 ? a3 : (unint64_t)(v18 + 7) >> 3;
  uint64_t uint_internal = ccn_read_uint_internal(v12, v14, v21, a4);
  if ((uint_internal & 0x80000000) != 0)
  {
LABEL_20:
    uint64_t v29 = uint_internal;
    unint64_t v24 = a5;
  }
  else
  {
    uint64_t v22 = (uint64_t)&v19[3 * v17 + 2];
    if (v20 < 8 * a3) {
      ccn_shift_right(v12, (uint64_t)v14, v14, -(int)v20 & 7);
    }
    unint64_t v23 = (unint64_t *)cczp_prime(v13 + 40 * v12);
    unint64_t v24 = a5;
    char v25 = ccn_sub_ws(a1, v12, a5, (uint64_t *)v14, v23);
    ccn_mux(v12, v25, (uint64_t *)v14, (uint64_t *)v14, a5);
    uint64_t scalar_fips_retry_ws = ccec_validate_scalar(v11, v22);
    if (!scalar_fips_retry_ws)
    {
      int v27 = 10;
      while (1)
      {
        uint64_t scalar_fips_retry_ws = ccec_generate_scalar_fips_retry_ws(a1, v11, v32, v39);
        if (scalar_fips_retry_ws) {
          break;
        }
        uint64_t scalar_fips_retry_ws = ccec_generate_scalar_fips_retry_ws(a1, v11, v32, v37);
        if (scalar_fips_retry_ws) {
          break;
        }
        uint64_t v28 = ccec_sign_internal_inner_ws(a1, v11, (uint64_t)v14, v22, (uint64_t)v39, v36, (uint64_t)v37, a5, (uint64_t)a6, (uint64_t (**)(void, uint64_t, unint64_t *))v32);
        uint64_t v29 = v28;
        if (!v28) {
          goto LABEL_18;
        }
        if (v28 != -165) {
          goto LABEL_17;
        }
        if (!--v27) {
          cc_try_abort();
        }
      }
    }
    uint64_t v29 = scalar_fips_retry_ws;
  }
LABEL_17:
  cc_clear(8 * v12, v24);
  cc_clear(8 * v12, a6);
LABEL_18:
  *(void *)(a1 + 16) = v35;
  return v29;
}

uint64_t ccmode_ccm_crypt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3)
  {
    uint64_t v9 = result;
    uint64_t v10 = 0;
    unint64_t v11 = *(void *)(*(void *)result + 8);
    uint64_t v12 = *(void *)(a2 + 80);
    uint64_t v19 = (v11 + ~v12);
    uint64_t v13 = result + 8;
    uint64_t v14 = a2 + 48;
    unint64_t v15 = *(unsigned int *)(a2 + 68);
    uint64_t v16 = a2 + v12;
    do
    {
      if (!v15)
      {
        uint64_t v17 = v19;
        do
        {
          if ((int)v17 < 1) {
            break;
          }
          __int16 v18 = (*(unsigned char *)(v16 + v17--))++ + 1;
        }
        while ((v18 & 0x100) != 0);
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v9 + 24))(v13, 1, a2, v14);
        unint64_t v15 = *(unsigned int *)(a2 + 68);
      }
      *(unsigned char *)(a5 + v10) = *(unsigned char *)(a2 + v15 + 48) ^ *(unsigned char *)(a4 + v10);
      unint64_t v15 = (*(_DWORD *)(a2 + 68) + 1) % v11;
      *(_DWORD *)(a2 + 68) = v15;
      ++v10;
    }
    while (v10 != a3);
  }
  return result;
}

uint64_t ccmode_ccm_encrypt(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  int v10 = *(_DWORD *)(a2 + 64);
  if (v10 == 5)
  {
    BOOL v11 = 0;
LABEL_5:
    ccmode_ccm_macdata(a1, a2, v11, a3, a4);
    ccmode_ccm_crypt(a1, a2, a3, a4, a5);
    return 0;
  }
  if (v10 == 4)
  {
    BOOL v11 = *(_DWORD *)(a2 + 72) != 0;
    *(_DWORD *)(a2 + 64) = 5;
    goto LABEL_5;
  }
  return 4294967228;
}

uint64_t ccss_shamir_evaluate_poly_to_buffer(uint64_t a1, unsigned int a2, char *a3)
{
  v14[0] = cc_malloc_clear(**(void **)a1 << 6);
  uint64_t v6 = *(uint64_t **)a1;
  uint64_t v7 = **(void **)a1;
  v14[1] = 8 * v7;
  uint64_t v15 = 0;
  uint64_t v16 = cc_ws_alloc;
  uint64_t v17 = cc_ws_free;
  if (!v14[0]) {
    return 4294967283;
  }
  unint64_t v8 = (void *)cc_ws_alloc(v14, v7);
  uint64_t v9 = (void *)v16(v14, v7);
  v16(v14, v7);
  int v10 = (void *)v16(v14, v7);
  ccn_seti(v7, v8, a2);
  ccn_seti(v7, v9, a2);
  BOOL v11 = (void *)ccss_shamir_poly_coefficient(a1, 0);
  ccn_set(v7, v10, v11);
  if (*(_DWORD *)(a1 + 8))
  {
    unsigned int v12 = 1;
    do
    {
      ccss_shamir_poly_coefficient(a1, v12);
      cczp_mul_ws((uint64_t)v14, (uint64_t)v6);
      cczp_add_ws((uint64_t)v14, (uint64_t)v6);
      cczp_mul_ws((uint64_t)v14, (uint64_t)v6);
      ++v12;
    }
    while (v12 <= *(_DWORD *)(a1 + 8));
  }
  if (v7) {
    ccn_set(v7, a3, v10);
  }
  ccn_zero(0, &a3[8 * v7]);
  uint64_t v15 = 0;
  v17((uint64_t)v14);
  return 0;
}

void ccvrf_irtf_ed25519_verify(uint64_t a1, uint64_t a2, char *a3, size_t a4, uint64_t a5)
{
  uint64_t v25 = *MEMORY[0x263EF8C08];
  if (!ge_has_small_order(a2))
  {
    memset(v12, 0, sizeof(v12));
    if (!ccvrf_irtf_ed25519_string_to_point((int *)v12, a2))
    {
      memset(v24, 0, sizeof(v24));
      memset(v23, 0, sizeof(v23));
      memset(v22, 0, sizeof(v22));
      v21[0] = 0;
      v21[1] = 0;
      memset(v19, 0, sizeof(v19));
      memset(v18, 0, sizeof(v18));
      memset(v17, 0, sizeof(v17));
      memset(v16, 0, sizeof(v16));
      memset(v15, 0, sizeof(v15));
      memset(v14, 0, sizeof(v14));
      memset(v13, 0, sizeof(v13));
      ccvrf_irtf_ed25519_decode_proof(a5, (int *)v18, v23, (uint64_t)v22);
      if (!v10)
      {
        size_t v11 = *(void *)(a1 + 32);
        bzero((char *)v23 + (v11 >> 1), v11 >> 1);
        bzero((char *)v22 + v11, v11);
        sc_reduce((unsigned __int16 *)v22);
        ccvrf_irtf_ed25519_hash2curve_elligator2(*(void *)(a1 + 40), (uint64_t)v12, a3, a4, (uint64_t)v24);
        ge_frombytes_vartime((int *)v19, (uint64_t)v24);
        ge_scalarmult(v15, v23, (uint64_t)v12);
        ge_p3_to_cached((uint64_t)v13, (uint64_t)v15);
        ge_scalarmult_base(v15, v22);
        ge_sub((int *)v14, (uint64_t)v15, (int *)v13);
        ge_p1p1_to_p3(v17, (int *)v14);
        ge_scalarmult(v15, v23, (uint64_t)v18);
        ge_p3_to_cached((uint64_t)v13, (uint64_t)v15);
        ge_scalarmult(v15, v22, (uint64_t)v19);
        ge_sub((int *)v14, (uint64_t)v15, (int *)v13);
        ge_p1p1_to_p3(v16, (int *)v14);
        v20[0] = (int *)v19;
        v20[1] = (int *)v18;
        void v20[2] = (int *)v17;
        unsigned char v20[3] = (int *)v16;
        ccvrf_irtf_ed25519_hash_points(a1, v20, 4, v21);
        cc_cmp_safe_internal(*(void *)(a1 + 32) >> 1, v23[0].i8, (char *)v21);
      }
    }
  }
}

uint64_t ccvrf_verify(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  BOOL v16 = timingsafe_enable_if_supported();
  if (ccvrf_sizeof_public_key(a1) == a2 && ccvrf_sizeof_proof(a1) == a6) {
    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 72))(a1, a3, a5, a4, a7);
  }
  else {
    uint64_t v14 = 4294967289;
  }
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v14;
}

void *ccsrp_gp_rfc5054_1024()
{
  return &_ccsrp_gp_rfc5054_1024;
}

double ccmode_factory_ccm_encrypt(uint64_t a1, void *a2)
{
  *(void *)a1 = ((a2[1] + 7) & 0xFFFFFFFFFFFFFFF8) + ((*a2 + 7) & 0xFFFFFFFFFFFFFFF8) + 8;
  *(void *)&double result = 96;
  *(_OWORD *)(a1 + 8) = xmmword_2373B5210;
  *(void *)(a1 + 24) = ccmode_ccm_init;
  *(void *)(a1 + 32) = ccmode_ccm_set_iv;
  *(void *)(a1 + 40) = ccmode_ccm_cbcmac;
  *(void *)(a1 + 48) = ccmode_ccm_encrypt;
  *(void *)(a1 + 56) = ccmode_ccm_finalize;
  *(void *)(a1 + 64) = ccmode_ccm_reset;
  *(void *)(a1 + 72) = a2;
  *(unsigned char *)(a1 + 80) = 1;
  *(_DWORD *)(a1 + 81) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  return result;
}

uint64_t ccder_blob_decode_range(unsigned __int8 **a1, uint64_t a2, unsigned __int8 **a3)
{
  unint64_t v8 = 0;
  uint64_t result = ccder_blob_decode_tl_internal(a1, a2, &v8, 0);
  if (result)
  {
    uint64_t v6 = *a1;
    uint64_t v7 = &(*a1)[v8];
    *a1 = v7;
    *a3 = v6;
    a3[1] = v7;
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
  return result;
}

uint64_t ccder_blob_decode_range_strict(unsigned __int8 **a1, uint64_t a2, unsigned __int8 **a3)
{
  unint64_t v8 = 0;
  uint64_t result = ccder_blob_decode_tl_internal(a1, a2, &v8, 1);
  if (result)
  {
    uint64_t v6 = *a1;
    uint64_t v7 = &(*a1)[v8];
    *a1 = v7;
    *a3 = v6;
    a3[1] = v7;
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
  return result;
}

unsigned int *cckyber_polyvec_encode(unsigned int *result, uint64_t a2, uint64_t a3)
{
  if (*result)
  {
    unint64_t v5 = result;
    int v6 = 0;
    int v7 = 0;
    unint64_t v8 = 0;
    do
    {
      uint64_t result = (unsigned int *)cckyber_poly_encode(a2 + (v6 & 0xFFFFFF80), a3 + 2 * (v7 & 0xFFFFFF00));
      ++v8;
      v7 += 256;
      v6 += 384;
    }
    while (v8 < *v5);
  }
  return result;
}

unsigned int *cckyber_polyvec_decode(unsigned int *result, uint64_t a2, uint64_t a3)
{
  if (*result)
  {
    unint64_t v5 = result;
    int v6 = 0;
    int v7 = 0;
    unint64_t v8 = 0;
    do
    {
      uint64_t result = (unsigned int *)cckyber_poly_decode(a2 + 2 * (v6 & 0xFFFFFF00), a3 + (v7 & 0xFFFFFF80));
      ++v8;
      v7 += 384;
      v6 += 256;
    }
    while (v8 < *v5);
  }
  return result;
}

unsigned int *cckyber_polyvec_compress(unsigned int *result, uint64_t a2, uint64_t a3)
{
  if (*result)
  {
    unint64_t v5 = (uint64_t (**)(uint64_t, uint64_t))result;
    unsigned int v6 = 0;
    int v7 = 0;
    unint64_t v8 = 0;
    int v9 = 32 * (result[2] & 0xFFFFFF);
    do
    {
      uint64_t result = (unsigned int *)v5[4](a2 + v6, a3 + 2 * (v7 & 0xFFFFFF00));
      ++v8;
      v7 += 256;
      v6 += v9;
    }
    while (v8 < *(unsigned int *)v5);
  }
  return result;
}

unsigned int *cckyber_polyvec_decompress(unsigned int *result, uint64_t a2, uint64_t a3)
{
  if (*result)
  {
    unint64_t v5 = (uint64_t (**)(uint64_t, uint64_t))result;
    unsigned int v6 = 0;
    int v7 = 0;
    unint64_t v8 = 0;
    int v9 = 32 * (result[2] & 0xFFFFFF);
    do
    {
      uint64_t result = (unsigned int *)v5[5](a2 + 2 * (v7 & 0xFFFFFF00), a3 + v6);
      ++v8;
      v7 += 256;
      v6 += v9;
    }
    while (v8 < *(unsigned int *)v5);
  }
  return result;
}

unsigned int *cckyber_polyvec_add(unsigned int *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*result)
  {
    int v7 = result;
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    do
    {
      uint64_t result = (unsigned int *)cckyber_poly_add(a2 + ((2 * v8) & 0x1FFFFFE00), a3 + ((2 * v8) & 0x1FFFFFE00), a4 + ((2 * v8) & 0x1FFFFFE00));
      ++v9;
      v8 += 256;
    }
    while (v9 < *v7);
  }
  return result;
}

unsigned int *cckyber_polyvec_reduce(unsigned int *result, uint64_t a2)
{
  if (*result)
  {
    uint64_t v3 = result;
    int v4 = 0;
    unint64_t v5 = 0;
    do
    {
      uint64_t result = (unsigned int *)cckyber_poly_reduce(a2 + 2 * (v4 & 0xFFFFFF00));
      ++v5;
      v4 += 256;
    }
    while (v5 < *v3);
  }
  return result;
}

unsigned int *cckyber_polyvec_ntt_forward(unsigned int *result, uint64_t a2)
{
  if (*result)
  {
    uint64_t v3 = result;
    int v4 = 0;
    unint64_t v5 = 0;
    do
    {
      uint64_t result = (unsigned int *)cckyber_ntt_forward(a2 + 2 * (v4 & 0xFFFFFF00));
      ++v5;
      v4 += 256;
    }
    while (v5 < *v3);
  }
  return result;
}

uint64_t cckyber_polyvec_basemul(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = *MEMORY[0x263EF8C08];
  uint64_t result = cckyber_ntt_basemul(a2, a3, a4);
  if (*a1 >= 2u)
  {
    unint64_t v9 = 1;
    uint64_t v10 = 256;
    do
    {
      cckyber_ntt_basemul((uint64_t)v11, a3 + ((2 * v10) & 0x1FFFFFE00), a4 + ((2 * v10) & 0x1FFFFFE00));
      uint64_t result = cckyber_poly_add(a2, a2, (uint64_t)v11);
      ++v9;
      v10 += 256;
    }
    while (v9 < *a1);
  }
  return result;
}

uint64_t cczp_div2_ws(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v7 = cczp_n(a2);
  uint64_t v8 = *a4 & 1;
  unint64_t v9 = (uint64_t *)cczp_prime(a2);
  uint64_t v10 = ccn_cond_add(v7, v8, a3, a4, v9);
  uint64_t result = ccn_shift_right(v7, (uint64_t)a3, (unint64_t *)a3, 1uLL);
  a3[v7 - 1] |= v10 << 63;
  return result;
}

uint64_t ccmode_ccm_set_iv(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unint64_t a7)
{
  if (*(void *)(*(void *)a1 + 8) != 16) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a2 + 64) = 1;
  cc_clear(0x10uLL, (void *)(a2 + 48));
  *(_DWORD *)(a2 + 68) = 0;
  if ((unint64_t)(a5 - 17) < 0xFFFFFFFFFFFFFFF3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if ((a5 & 1) == 0)
  {
    unint64_t v14 = 15 - a3;
    if (6 - a3 >= 0xFFFFFFFFFFFFFFF9 && a3 >= 7 && a3 <= 0xD)
    {
      BOOL v15 = v14 >= 8 || a7 >> (8 * v14) == 0;
      BOOL v16 = !v15;
      if (!HIDWORD(a6) && !v16)
      {
        *(unsigned char *)(a2 + 16) = (((4 * a5) & 0xF8) - 8) | ((a6 != 0) << 6) | (14 - a3);
        *(void *)(a2 + 80) = a3;
        *(void *)(a2 + 88) = a5;
        uint64_t v17 = (unsigned char *)(a2 + 17);
        __memcpy_chk();
        __int16 v18 = (unsigned char *)(a2 + 31);
        unint64_t v19 = 15 - a3;
        do
        {
          *v18-- = a7;
          a7 >>= 8;
          --v19;
        }
        while (v19);
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 24))(a1 + 8, 1, a2 + 16, a2 + 16);
        *(unsigned char *)a2 = 14 - a3;
        __memcpy_chk();
        cc_clear(15 - a3, (void *)(a2 + 1 + a3));
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 24))(a1 + 8, 1, a2, a2 + 32);
        if (a6)
        {
          if (a6 >> 8 > 0xFE)
          {
            v22.i32[1] = -1;
            int16x8_t v23 = (int16x8_t)vshlq_u64((uint64x2_t)vdupq_n_s64(a6), (uint64x2_t)xmmword_2373B5220);
            *(int32x2_t *)v23.i8 = vmovn_s64((int64x2_t)v23);
            v22.i32[0] = *(_DWORD *)(a2 + 16);
            v24.i32[0] = 16646399;
            v24.i16[2] = v23.i16[0];
            v24.i16[3] = v23.i16[2];
            *(int8x8_t *)v23.i8 = veor_s8((int8x8_t)*(_OWORD *)&vmovl_u8(v22), v24);
            *(_DWORD *)(a2 + 16) = vmovn_s16(v23).u32[0];
            *(unsigned char *)(a2 + 20) ^= BYTE1(a6);
            uint64_t v17 = (unsigned char *)(a2 + 21);
            int v20 = 6;
          }
          else
          {
            *(unsigned char *)(a2 + 16) ^= BYTE1(a6);
            int v20 = 2;
          }
          *v17 ^= a6;
          int v21 = 4;
        }
        else
        {
          int v20 = 0;
          int v21 = 5;
        }
        uint64_t result = 0;
        *(_DWORD *)(a2 + 72) = v20;
        *(_DWORD *)(a2 + 64) = v21;
      }
    }
  }
  return result;
}

__n128 ccmode_gcm_gf_mult_64(unint64_t *a1, unint64_t *a2, __n128 *a3)
{
  uint64_t v21 = 0;
  unint64_t v22 = 0;
  uint64_t v19 = 0;
  unint64_t v20 = 0;
  uint64_t v17 = 0;
  unint64_t v18 = 0;
  uint64_t v4 = bswap64(a1[1]);
  uint64_t v5 = bswap64(*a1);
  uint64_t v6 = bswap64(a2[1]);
  uint64_t v7 = bswap64(*a2);
  bmul64(v4, v6, &v21, &v22);
  bmul64(v5, v7, &v17, &v18);
  bmul64(v5 ^ v4, v7 ^ v6, &v19, &v20);
  *((void *)&v9 + 1) = v17;
  *(void *)&long long v9 = v18 ^ v21 ^ v17 ^ v19;
  uint64_t v8 = v9 >> 63;
  *((void *)&v9 + 1) = v9;
  *(void *)&long long v9 = v18 ^ v20 ^ v22 ^ v21;
  uint64_t v10 = v9 >> 63;
  *((void *)&v9 + 1) = v9;
  *(void *)&long long v9 = v22;
  uint64_t v11 = v9 >> 63;
  *((void *)&v9 + 1) = v22 >> 63;
  *(void *)&long long v9 = 2 * v22;
  uint64_t v12 = v9 >> 1;
  *((void *)&v9 + 1) = v11;
  *(void *)&long long v9 = 2 * v22;
  uint64_t v13 = v9 >> 2;
  *((void *)&v9 + 1) = v11;
  *(void *)&long long v9 = 2 * v22;
  unint64_t v14 = v8 ^ (((v22 << 63) ^ (v22 << 58) ^ v11) >> 2) ^ (((v22 << 63) ^ (v22 << 58) ^ v11) >> 1) ^ (((v22 << 63) ^ (v22 << 58) ^ v11) >> 7) ^ (v22 << 63) ^ (v22 << 58) ^ v11;
  uint64_t v15 = v10 ^ v13 ^ v12 ^ (v9 >> 7) ^ (2 * v22);
  result.n128_u8[0] = HIBYTE(v14);
  result.n128_u8[1] = BYTE6(v14);
  result.n128_u8[2] = BYTE5(v14);
  result.n128_u8[3] = BYTE4(v14);
  result.n128_u8[4] = BYTE3(v14);
  result.n128_u8[5] = BYTE2(v14);
  result.n128_u8[6] = BYTE1(v14);
  result.n128_u8[7] = v14;
  result.n128_u8[8] = HIBYTE(v15);
  result.n128_u8[9] = BYTE6(v15);
  result.n128_u8[10] = BYTE5(v15);
  result.n128_u8[11] = BYTE4(v15);
  result.n128_u8[12] = BYTE3(v15);
  result.n128_u8[13] = BYTE2(v15);
  result.n128_u8[14] = BYTE1(v15);
  result.n128_u8[15] = v15;
  *a3 = result;
  return result;
}

unint64_t bmul64(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4)
{
  uint64_t v4 = a1 & 0x1084210842108421;
  uint64_t v5 = a2 & 0x1084210842108421;
  uint64_t v6 = (a2 & 0x1084210842108421) * (a1 & 0x1084210842108421);
  uint64_t v7 = a1 & 0x2108421084210842;
  uint64_t v8 = a2 & 0x842108421084210;
  uint64_t v9 = (a2 & 0x842108421084210) * (a1 & 0x2108421084210842);
  uint64_t v10 = a1 & 0x4210842108421084;
  unint64_t v11 = a2 & 0x8421084210842108;
  unint64_t v12 = (a2 & 0x8421084210842108) * (a1 & 0x4210842108421084);
  uint64_t v13 = a2 & 0x2108421084210842;
  uint64_t v14 = a2 & 0x4210842108421084;
  unint64_t v15 = a1 & 0x8421084210842108;
  uint64_t v16 = a1 & 0x842108421084210;
  unint64_t v17 = (((a2 & 0x4210842108421084) * (a1 & 0x1084210842108421)) ^ ((a2 & 0x2108421084210842)
                                                                      * (a1 & 0x2108421084210842)) ^ ((a2 & 0x1084210842108421) * (a1 & 0x4210842108421084)) ^ ((a2 & 0x842108421084210) * (a1 & 0x8421084210842108)) ^ ((a2 & 0x8421084210842108) * (a1 & 0x842108421084210))) & 0x4210842108421084;
  uint64_t v18 = ((((a2 & 0x1084210842108421) * (unsigned __int128)(a1 & 0x1084210842108421)) >> 64) ^ (((a2 & 0x842108421084210)
                                                                                                  * (unsigned __int128)(a1 & 0x2108421084210842)) >> 64) ^ (((a2 & 0x8421084210842108) * (unsigned __int128)(a1 & 0x4210842108421084)) >> 64) ^ (((unint64_t)v14 * (unsigned __int128)v15) >> 64) ^ (((unint64_t)v13 * (unsigned __int128)(unint64_t)v16) >> 64)) & 0x2108421084210842 | ((((unint64_t)v13 * (unsigned __int128)(a1 & 0x1084210842108421)) >> 64) ^ (((a2 & 0x1084210842108421) * (unsigned __int128)(a1 & 0x2108421084210842)) >> 64) ^ (((a2 & 0x842108421084210) * (unsigned __int128)(a1 & 0x4210842108421084)) >> 64) ^ (((a2 & 0x8421084210842108) * (unsigned __int128)v15) >> 64) ^ (((unint64_t)v14 * (unsigned __int128)(unint64_t)v16) >> 64)) & 0x4210842108421084 | ((((unint64_t)v14 * (unsigned __int128)(unint64_t)v4) >> 64) ^ (((unint64_t)v13 * (unsigned __int128)(unint64_t)v7) >> 64) ^ (((unint64_t)v5 * (unsigned __int128)(unint64_t)v10) >> 64) ^ (((unint64_t)v8 * (unsigned __int128)v15) >> 64) ^ ((v11 * (unsigned __int128)(unint64_t)v16) >> 64)) & 0x421084210842108 | (((v11 * (unsigned __int128)(unint64_t)v4) >> 64) ^ (((unint64_t)v14 * (unsigned __int128)(unint64_t)v7) >> 64) ^ (((unint64_t)v13 * (unsigned __int128)(unint64_t)v10) >> 64) ^ (((unint64_t)v5 * (unsigned __int128)v15) >> 64) ^ (((unint64_t)v8 * (unsigned __int128)(unint64_t)v16) >> 64)) & 0x842108421084210;
  unint64_t result = (v6 ^ v9 ^ v12 ^ (v14 * (a1 & 0x8421084210842108)) ^ (v13 * (a1 & 0x842108421084210))) & 0x1084210842108421 | ((v13 * (a1 & 0x1084210842108421)) ^ (v5 * (a1 & 0x2108421084210842)) ^ (v8 * (a1 & 0x4210842108421084)) ^ (v11 * (a1 & 0x8421084210842108)) ^ (v14 * (a1 & 0x842108421084210))) & 0x2108421084210842 | v17 | ((v11 * (a1 & 0x1084210842108421)) ^ (v14 * (a1 & 0x2108421084210842)) ^ (v13 * (a1 & 0x4210842108421084)) ^ (v5 * (a1 & 0x8421084210842108)) ^ (v8 * (a1 & 0x842108421084210))) & 0x8421084210842108;
  *a3 = v18 | ((((unint64_t)v8 * (unsigned __int128)(unint64_t)v4) >> 64) ^ ((v11
                                                                                          * (unsigned __int128)(unint64_t)v7) >> 64) ^ (((unint64_t)v14 * (unsigned __int128)(unint64_t)v10) >> 64) ^ (((unint64_t)v13 * (unsigned __int128)v15) >> 64) ^ (((unint64_t)v5 * (unsigned __int128)(unint64_t)v16) >> 64)) & 0x1084210842108421;
  *a4 = result | ((v8 * v4) ^ (v11 * v7) ^ (v14 * v10) ^ (v13 * v15) ^ (v5 * v16)) & 0x842108421084210;
  return result;
}

void cc_try_abort()
{
}

uint64_t cc_try_abort_if (uint64_t result)
{
  if (result) {
    cc_abort();
  }
  return result;
}

uint64_t ccz_sign(uint64_t a1)
{
  return (*(int *)(a1 + 16) >> 31) | 1u;
}

uint64_t ccz_n(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t ccz_capacity(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 16);
  if (v1 >= 0) {
    return v1;
  }
  else {
    return -v1;
  }
}

uint64_t ccz_set_sign(uint64_t result, int a2)
{
  int v2 = *(_DWORD *)(result + 16);
  if (((v2 >> 31) | 1) != a2) {
    *(_DWORD *)(result + 16) = -v2;
  }
  return result;
}

void *ccz_set_n(void *result, uint64_t a2)
{
  *unint64_t result = a2;
  return result;
}

uint64_t ccz_set_capacity(uint64_t result, unint64_t a2)
{
  int v2 = *(_DWORD *)(result + 16);
  if (v2 >= 0) {
    unint64_t v3 = v2;
  }
  else {
    unint64_t v3 = -v2;
  }
  if (*(void *)(result + 24)) {
    BOOL v4 = v3 >= a2;
  }
  else {
    BOOL v4 = 0;
  }
  if (!v4)
  {
    uint64_t v5 = result;
    unint64_t v6 = (a2 & 0xFFFFFFFFFFFFFFE0) + 64;
    uint64_t v7 = *(uint64_t **)(result + 8);
    uint64_t v8 = *v7;
    if (v2) {
      unint64_t result = ((uint64_t (*)(uint64_t, unint64_t))v7[2])(v8, 8 * v3);
    }
    else {
      unint64_t result = ((uint64_t (*)(uint64_t, unint64_t))v7[1])(v8, 8 * v6);
    }
    if (*(int *)(v5 + 16) >= 0) {
      int v9 = v6;
    }
    else {
      int v9 = -(int)v6;
    }
    *(_DWORD *)(v5 + 16) = v9;
    *(void *)(v5 + 24) = result;
  }
  return result;
}

uint64_t ccn_p256_to_ws(uint64_t a1, uint64_t a2)
{
  return cczp_mul_ws(a1, a2);
}

void *ccec_cp_256()
{
  return &ccec_cp256_c;
}

uint64_t ccn_p256_mul_ws(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t v10 = *(void *)(a1 + 16);
  unint64_t v11 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 8);
  ccn_mul_ws(a1, 4uLL, v11, a4, a5);
  uint64_t result = ccn_p256_redc_ws(a1, a2, a3, (uint64_t *)v11);
  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t ccn_p256_sqr_ws(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t *a4)
{
  uint64_t v8 = *(void *)(a1 + 16);
  int v9 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 8);
  ccn_sqr_ws(a1, 4uLL, v9, a4);
  uint64_t result = ccn_p256_redc_ws(a1, a2, a3, v9);
  *(void *)(a1 + 16) = v8;
  return result;
}

uint64_t ccn_p256_from_ws(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 8);
  ccn_set(4, (void *)v9, a4);
  ccn_zero(4, (void *)(v9 + 32));
  uint64_t result = ccn_p256_redc_ws(a1, a2, a3, (uint64_t *)v9);
  *(void *)(a1 + 16) = v8;
  return result;
}

uint64_t ccn_p256_redc_ws(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8 = 0;
  uint64_t v9 = a4[2];
  do
  {
    uint64_t v10 = &a4[v8];
    unint64_t v11 = a4[v8];
    uint64_t v12 = a4[v8 + 1];
    unsigned long long v14 = __PAIR128__(v9, v12) + (v11 << 32);
    unint64_t v13 = HIDWORD(v11) + *((void *)&v14 + 1);
    uint64_t v15 = __CFADD__(__CFADD__(v12, v11 << 32), v9) | __CFADD__(HIDWORD(v11), *((void *)&v14 + 1));
    uint64_t v17 = v15 - 0xFFFFFFFF * v11 + a4[v8 + 3];
    uint64_t v16 = (__PAIR128__(__CFADD__(v15, 0xFFFFFFFF00000001 * v11) + ((v11 * (unsigned __int128)0xFFFFFFFF00000001) >> 64), v15 - 0xFFFFFFFF * v11)+ (unint64_t)a4[v8 + 3]) >> 64;
    uint64_t v9 = v17;
    void v10[2] = v13;
    v10[3] = v17;
    *uint64_t v10 = v16;
    v10[1] = v14;
    ++v8;
  }
  while (v8 != 4);
  char v18 = ccn_add_ws(a1, 4, a4 + 4, a4 + 4, a4);
  uint64_t v19 = (unint64_t *)cczp_prime(a2);
  char v20 = ccn_sub_ws(a1, 4, a4, a4 + 4, v19) ^ v18;

  return ccn_mux(4, v20, a3, a4 + 4, a4);
}

unint64_t ccz_write_uint_size(uint64_t a1)
{
  BOOL v5 = timingsafe_enable_if_supported();
  unint64_t v2 = ccz_n(a1);
  unint64_t v3 = ccn_write_uint_size_public_value(v2, *(unint64_t **)(a1 + 24));
  cc_disable_dit_with_sb((unsigned int *)&v5);
  return v3;
}

uint64_t ccz_write_uint(uint64_t a1, unint64_t a2, char *a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  unint64_t v6 = ccz_n(a1);
  ccn_write_uint_padded_internal(v6, *(unint64_t **)(a1 + 24), a2, a3);
  return cc_disable_dit_with_sb((unsigned int *)&v8);
}

uint64_t ccdrbg_must_reseed(uint64_t a1, uint64_t a2)
{
  BOOL v6 = timingsafe_enable_if_supported();
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(a1 + 48))(a2);
  cc_disable_dit_with_sb((unsigned int *)&v6);
  return v4;
}

uint64_t ccdrbg_init_internal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 8))();
}

uint64_t ccdrbg_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v18 = timingsafe_enable_if_supported();
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, a2, a3, a4, a5, a6, a7, a8);
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return v16;
}

uint64_t ccdrbg_reseed_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 16))(a2, a3, a4, a5, a6);
}

uint64_t ccdrbg_reseed(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 16))(a2, a3, a4, a5, a6);
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v12;
}

uint64_t ccdrbg_generate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(a2, a3, a4, a5, a6);
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v12;
}

uint64_t ccdrbg_done(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 32))(a2);
}

uint64_t ccdrbg_context_size(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t ccnistkdf_ctr_hmac_fixed(unint64_t *a1, size_t a2, uint64_t a3, size_t a4, char *a5, rsize_t a6, char *a7)
{
  uint64_t v36 = *MEMORY[0x263EF8C08];
  BOOL v14 = timingsafe_enable_if_supported();
  BOOL v33 = v14;
  if (a6 && ((rsize_t v17 = *a1, v18 = a6 / *a1, (v19 = a6 % *a1) == 0) ? (v20 = a6 / *a1) : (v20 = v18 + 1), !HIDWORD(v20)))
  {
    uint64_t v23 = a3;
    uint64_t v21 = 4294967289;
    if (a2 && v23 && a7)
    {
      unint64_t v30 = v20;
      size_t v31 = v19;
      uint64_t v32 = &v29;
      MEMORY[0x270FA53B0](v14, v15, v16, v23);
      uint64_t v25 = (uint64_t *)((char *)&v29 - v24);
      cchmac_init_internal((uint64_t)a1, (uint64_t *)((char *)&v29 - v24), a2, v26);
      __memcpy_chk();
      if (v17 <= a6)
      {
        unint64_t v27 = 1;
        do
        {
          F_0(a1, v25, v34, v27++, a4, a5, (uint64_t)a7);
          a7 += v17;
        }
        while (v27 <= v18);
      }
      size_t v28 = v31;
      if (v31)
      {
        F_0(a1, v25, v34, v30, a4, a5, (uint64_t)__src);
        memcpy(a7, __src, v28);
      }
      cc_clear(v17, __src);
      cc_clear(((a1[1] + a1[2] + 19) & 0xFFFFFFFFFFFFFFF8) + a1[1], v25);
      cc_clear(a1[1], v34);
      uint64_t v21 = 0;
    }
  }
  else
  {
    uint64_t v21 = 4294967289;
  }
  cc_disable_dit_with_sb((unsigned int *)&v33);
  return v21;
}

uint64_t F_0(unint64_t *a1, void *a2, void *__src, unsigned int a4, size_t a5, char *a6, uint64_t a7)
{
  memcpy(a2 + 1, __src, a1[1]);
  unint64_t v14 = a1[1];
  unint64_t v13 = a1[2];
  *a2 = 8 * v13;
  *(_DWORD *)((char *)a2 + v14 + v13 + 8) = 0;
  unsigned int __srca = bswap32(a4);
  ccdigest_update_internal(a1, a2, 4uLL, (char *)&__srca);
  ccdigest_update_internal(a1, a2, a5, a6);
  return cchmac_final_internal((uint64_t)a1, a2, a7);
}

uint64_t ccnistkdf_ctr_hmac(unint64_t *a1, size_t a2, uint64_t a3, size_t a4, const void *a5, size_t a6, const void *a7, rsize_t a8, char *a9)
{
  BOOL v27 = timingsafe_enable_if_supported();
  unint64_t v17 = a6 + a4 + 12;
  uint64_t v18 = v17 >> 3;
  v25[0] = cc_malloc_clear(v17 & 0xFFFFFFFFFFFFFFF8);
  v25[1] = v18;
  v25[2] = 0;
  void v25[3] = cc_ws_alloc;
  unint64_t v26 = cc_ws_free;
  if (v25[0])
  {
    unint64_t v19 = (char *)cc_ws_alloc(v25, v18);
    if ((a8 & 0x1FFFFFFFE0000000) != 0)
    {
      uint64_t v20 = 4294967289;
    }
    else
    {
      uint64_t v21 = v19;
      size_t v22 = a6 + a4 + 5;
      if (a4 && a5) {
        memcpy(v19, a5, a4);
      }
      uint64_t v23 = &v21[a4];
      *uint64_t v23 = 0;
      if (a6 && a7) {
        memcpy(v23 + 1, a7, a6);
      }
      *(_DWORD *)&v23[a6 + 1] = (a8 << 11) & 0xFF0000 | (a8 << 27) | (a8 >> 5) & 0xFF00 | (a8 >> 21);
      uint64_t v20 = ccnistkdf_ctr_hmac_fixed(a1, a2, a3, v22, v21, a8, a9);
    }
    v26((uint64_t)v25);
  }
  else
  {
    uint64_t v20 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v27);
  return v20;
}

uint64_t ltc_rc2_ecb_encrypt(uint64_t a1, uint64_t a2, unsigned __int16 *a3, _WORD *a4)
{
  for (; a2; --a2)
  {
    uint64_t v4 = 0;
    unsigned int v5 = a3[3];
    unsigned int v6 = a3[2];
    unsigned int v7 = a3[1];
    BOOL v8 = (_DWORD *)(a1 + 8);
    int v9 = *a3;
    do
    {
      unsigned int v10 = (v7 & ~v5 | v6 & v5) + v9 + *(v8 - 2);
      int v9 = (v10 >> 15) & 1 | (2 * (unsigned __int16)v10);
      int v11 = *(v8 - 1) + v7 + (v6 & ~v9) + (v9 & v5);
      unsigned int v7 = ((unsigned __int16)v11 >> 14) & 0xFFFC0003 | (4 * (unsigned __int16)v11);
      int v12 = *v8 + v6 + (v5 & ~v7) + (v7 & v9);
      unsigned int v6 = ((unsigned __int16)v12 >> 13) & 0xFFF80007 | (8 * (unsigned __int16)v12);
      unsigned int v5 = ((unsigned __int16)(v8[1] + v5 + (v9 & ~(_WORD)v6) + (v6 & v7)) >> 11) & 0xFFE0001F | (32
                                                                                                * (unsigned __int16)(v8[1] + v5 + (v9 & ~(_WORD)v6) + (v6 & v7)));
      if (v4 == 10 || v4 == 4)
      {
        char v13 = *(_DWORD *)(a1 + 4 * (v5 & 0x3F)) + v9;
        int v9 = (unsigned __int16)(*(_DWORD *)(a1 + 4 * (v5 & 0x3F)) + v9);
        unsigned __int16 v14 = *(_DWORD *)(a1 + 4 * (v13 & 0x3F)) + v7;
        unsigned int v7 = v14;
        unsigned __int16 v15 = *(_DWORD *)(a1 + 4 * (v14 & 0x3F)) + v6;
        unsigned int v6 = v15;
        unsigned int v5 = (unsigned __int16)(*(_DWORD *)(a1 + 4 * (v15 & 0x3F)) + v5);
      }
      v8 += 4;
      ++v4;
    }
    while (v4 != 16);
    *a4 = v9;
    a4[1] = v7;
    a4[2] = v6;
    a3 += 4;
    a4[3] = v5;
    a4 += 4;
  }
  return 0;
}

uint64_t ccss_encode_string_into_value_smaller_than_prime(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = cczp_n(a1);
  uint64_t v9 = cczp_prime(a1);
  uint64_t uint_internal = ccn_read_uint_internal(v8, a2, a3, a4);
  if (uint_internal)
  {
    uint64_t v11 = uint_internal;
LABEL_7:
    cc_clear(8 * v8, a2);
    return v11;
  }
  if ((ccn_cmp_internal(v8, a2, v9) & 0x80000000) == 0)
  {
    uint64_t v11 = 4294967176;
    goto LABEL_7;
  }
  return 0;
}

BOOL ccss_shamir_secret_one_byte_smaller_than_prime(uint64_t a1, unint64_t a2)
{
  return a2 < (unint64_t)(cczp_bitlen(a1) + 7) >> 3;
}

uint64_t cczp_is_quadratic_residue_ws(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = cczp_n(a2);
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  uint64_t v9 = (void *)cczp_prime(a2);
  ccn_set(v6, v8, v9);
  *v8 &= ~1uLL;
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  ccn_shift_right(v6, v10, v8, 1uLL);
  uint64_t v11 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  unsigned int v12 = cczp_power_fast_ws(a1, a2, v11, a3, v10);
  cczp_from_ws(a1, a2);
  BOOL v13 = ccn_n(v6, (uint64_t)v11) == 1 && *v11 == 1;
  uint64_t result = v13 & ~(((v12 | ((unint64_t)(int)v12 >> 32)) + 0xFFFFFFFF) >> 32);
  *(void *)(a1 + 16) = v7;
  return result;
}

BOOL ccz_is_prime(uint64_t a1, unsigned int a2)
{
  BOOL v9 = timingsafe_enable_if_supported();
  uint64_t v4 = ccrng(0);
  if (v4)
  {
    unsigned int v5 = v4;
    unint64_t v6 = ccz_n(a1);
    BOOL v7 = ccprime_rabin_miller(v6, *(unint64_t **)(a1 + 24), a2, (uint64_t (**)(void, unint64_t, uint64_t))v5) == 1;
  }
  else
  {
    BOOL v7 = 0;
  }
  cc_disable_dit_with_sb((unsigned int *)&v9);
  return v7;
}

uint64_t ccder_sizeof_implicit_uint64(uint64_t a1, unint64_t a2)
{
  v3[1] = *MEMORY[0x263EF8C08];
  v3[0] = a2;
  return ccder_sizeof_implicit_integer(a1, 1uLL, v3);
}

uint64_t ccder_blob_decode_tag(unsigned __int8 **a1, unint64_t *a2)
{
  unint64_t v2 = *a1;
  unint64_t v3 = (unint64_t)a1[1];
  if (*a1) {
    BOOL v4 = (unint64_t)v2 >= v3;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return 0;
  }
  unsigned int v8 = *v2;
  unint64_t v6 = v2 + 1;
  unint64_t v7 = v8;
  unint64_t v9 = v8 & 0x1F;
  if (v9 == 31)
  {
    unint64_t v9 = 0;
    while (1)
    {
      uint64_t v5 = 0;
      if ((unint64_t)v6 >= v3) {
        break;
      }
      unint64_t v10 = v9;
      if (v9 >> 57) {
        break;
      }
      char v11 = *v6++;
      unint64_t v9 = v11 & 0x7F | (v9 << 7);
      if ((v11 & 0x80) == 0)
      {
        if (v10 >> 54) {
          return 0;
        }
        goto LABEL_13;
      }
    }
  }
  else
  {
LABEL_13:
    *a2 = v9 | (v7 >> 5 << 61);
    *a1 = v6;
    return 1;
  }
  return v5;
}

uint64_t cc_atfork_parent()
{
  BOOL v1 = timingsafe_enable_if_supported();
  ccrng_atfork_parent();
  return cc_disable_dit_with_sb((unsigned int *)&v1);
}

uint64_t ccckg_owner_generate_share(uint64_t a1, size_t a2, const void *a3, uint64_t a4, char *a5)
{
  BOOL v38 = timingsafe_enable_if_supported();
  unint64_t v10 = (uint64_t *)ccckg_ctx_cp(a1);
  uint64_t v11 = *v10;
  uint64_t v12 = sizeof_struct_cche_galois_key();
  unint64_t v13 = sizeof_struct_ccpolyzp_po2cyc();
  v34[0] = cc_malloc_clear(8 * ((v12 + v13 + 4 * v11 * v13 - 1) / v13 + 49 * v11));
  uint64_t v14 = *v10;
  uint64_t v15 = sizeof_struct_cche_galois_key();
  unint64_t v16 = sizeof_struct_ccpolyzp_po2cyc();
  v34[1] = (v15 + v16 + 4 * v14 * v16 - 1) / v16 + 49 * v14;
  uint64_t v35 = 0;
  uint64_t v36 = cc_ws_alloc;
  uint64_t v37 = cc_ws_free;
  if (v34[0])
  {
    unint64_t v17 = (size_t *)ccckg_ctx_di(a1);
    uint64_t v18 = (uint64_t *)ccckg_ctx_cp(a1);
    if (*(unsigned char *)(a1 + 32))
    {
      uint64_t v19 = 4294967210;
      cc_ws_free((uint64_t)v34);
    }
    else
    {
      uint64_t v20 = (unint64_t *)v18;
      uint64_t v21 = *v18;
      if (ccckg_sizeof_commitment((uint64_t)v18, (uint64_t)v17) == a2 && ccckg_sizeof_share((uint64_t)v20, v17) == a4)
      {
        size_t v22 = (unint64_t **)cc_ws_alloc(v34, (4 * (v21 & 0x7FFFFFFFFFFFFFFLL)) | 2);
        *size_t v22 = v20;
        uint64_t v23 = (void *)ccckg_ctx_di(a1);
        uint64_t v24 = (void *)ccckg_ctx_cp(a1);
        uint64_t v25 = a1 + 40;
        memcpy((void *)(a1 + 40 + 8 * *v24 + ((*v23 + 7) & 0xFFFFFFFFFFFFFFF8)), a3, a2);
        key_fips_uint64_t ws = ccec_generate_key_fips_ws((uint64_t)v34, v20, *(uint64_t (***)(void, uint64_t, unint64_t *))(a1 + 24), v22);
        if (key_fips_ws
          || (BOOL v27 = *(uint64_t (***)(void, size_t, uint64_t))(a1 + 24),
              size_t v28 = *v27,
              size_t v29 = *v17,
              unint64_t v30 = (void *)ccckg_ctx_cp(a1),
              key_fips_uint64_t ws = v28(v27, v29, v25 + 8 * *v30),
              key_fips_ws))
        {
          uint64_t v19 = key_fips_ws;
        }
        else
        {
          ccn_set(v21, (void *)(a1 + 40), &v22[3 * **v22 + 2]);
          uint64_t v19 = ccec_export_pub((uint64_t *)v22, a5);
          if (!v19)
          {
            size_t v31 = &a5[((unint64_t)(cczp_bitlen((uint64_t)*v22) + 7) >> 2) | 1];
            uint64_t v32 = (void *)ccckg_ctx_cp(a1);
            memcpy(v31, (const void *)(v25 + 8 * *v32), *v17);
            *(unsigned char *)(a1 + 32) = 2;
          }
        }
        uint64_t v35 = 0;
        v37((uint64_t)v34);
      }
      else
      {
        uint64_t v19 = 4294967289;
        cc_ws_free((uint64_t)v34);
      }
    }
  }
  else
  {
    uint64_t v19 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v38);
  return v19;
}

uint64_t ccckg_owner_finish_derive_p(uint64_t a1, uint64_t a2, unint64_t **a3, uint64_t (**a4)(void, uint64_t, unint64_t *))
{
  unint64_t v7 = (unint64_t *)ccckg_ctx_cp(a1);
  unint64_t v8 = *v7;
  unint64_t v9 = v7 + 4;
  unint64_t v10 = cczp_n((uint64_t)&v7[5 * *v7 + 4]);
  unint64_t v11 = 26 * *v7;
  if (v10 > v11) {
    unint64_t v11 = cczp_n((uint64_t)&v9[5 * *v7]);
  }
  uint64_t v12 = cc_malloc_clear(8 * v11);
  v19[0] = v12;
  unint64_t v13 = cczp_n((uint64_t)&v9[5 * *v7]);
  unint64_t v14 = 26 * *v7;
  if (v13 > v14) {
    unint64_t v14 = cczp_n((uint64_t)&v9[5 * *v7]);
  }
  v19[1] = v14;
  void v19[2] = 0;
  void v19[3] = cc_ws_alloc;
  uint64_t v20 = cc_ws_free;
  if (!v12) {
    return 4294967283;
  }
  uint64_t v15 = (uint64_t)&a3[3 * **a3 + 2];
  uint64_t v16 = cczp_bitlen((uint64_t)&v9[5 * *v7]);
  ccn_read_uint_internal(v8, v15, (unint64_t)(v16 + 7) >> 3, a2);
  if (ccec_validate_scalar(v7, (uint64_t)&a3[3 * **a3 + 2]))
  {
    pub_from_priv_uint64_t ws = 4294967289;
    cc_ws_free((uint64_t)v19);
  }
  else
  {
    cczp_add_ws((uint64_t)v19, (uint64_t)&v9[5 * *v7]);
    pub_from_priv_uint64_t ws = ccec_make_pub_from_priv_ws((uint64_t)v19, v7, a4, (uint64_t)&a3[3 * **a3 + 2], 0, a3);
    v20((uint64_t)v19);
  }
  return pub_from_priv_ws;
}

uint64_t ccckg_owner_finish(uint64_t a1, size_t a2, char *a3, uint64_t a4, uint64_t a5, char *a6)
{
  uint64_t v25 = *MEMORY[0x263EF8C08];
  BOOL v23 = timingsafe_enable_if_supported();
  uint64_t v12 = (uint64_t *)ccckg_ctx_di(a1);
  unint64_t v13 = (void *)ccckg_ctx_cp(a1);
  if (*(unsigned char *)(a1 + 32) == 2)
  {
    unint64_t v14 = v13;
    if (*(void **)a4 == v13 && ccckg_sizeof_opening(v13, v12) == a2)
    {
      ccdigest_internal((uint64_t)v12, a2, a3, (uint64_t)__s);
      uint64_t v15 = *v12;
      uint64_t v16 = (void *)ccckg_ctx_di(a1);
      unint64_t v17 = (void *)ccckg_ctx_cp(a1);
      if (cc_cmp_safe_internal(v15, __s, (char *)(a1 + 40 + 8 * *v17 + ((*v16 + 7) & 0xFFFFFFFFFFFFFFF8))))
      {
        uint64_t v18 = 4294967294;
      }
      else
      {
        uint64_t v20 = ccckg_owner_finish_derive_p(a1, (uint64_t)a3, (unint64_t **)a4, *(uint64_t (***)(void, uint64_t, unint64_t *))(a1 + 24));
        if (v20)
        {
          uint64_t v18 = v20;
        }
        else
        {
          uint64_t v21 = (uint64_t)&a3[(unint64_t)(cczp_bitlen((uint64_t)&v14[5 * *v14 + 4]) + 7) >> 3];
          size_t v22 = (void *)ccckg_ctx_cp(a1);
          uint64_t v18 = ccckg_derive_sk(a1, (unint64_t *)(a4 + 16), v21, a1 + 40 + 8 * *v22, a5, a6);
          if (!v18) {
            *(unsigned char *)(a1 + 32) = 3;
          }
        }
      }
      cc_clear(0x40uLL, __s);
    }
    else
    {
      uint64_t v18 = 4294967289;
    }
  }
  else
  {
    uint64_t v18 = 4294967210;
  }
  cc_disable_dit_with_sb((unsigned int *)&v23);
  return v18;
}

BOOL ccec_validate_pub(uint64_t **a1)
{
  BOOL v19 = timingsafe_enable_if_supported();
  unint64_t v2 = *a1;
  uint64_t v3 = **a1;
  unint64_t v4 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v5 = 5 * v3 + (v4 + 7) / v4 + 3;
  if (v5 <= 7 * v3) {
    unint64_t v5 = 7 * v3;
  }
  unint64_t v6 = cc_malloc_clear(8 * (v5 + 3 * v3));
  v15[0] = v6;
  uint64_t v7 = *v2;
  unint64_t v8 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v9 = 5 * v7 + (v8 + 7) / v8 + 3;
  if (v9 <= 7 * v7) {
    unint64_t v9 = 7 * v7;
  }
  v15[1] = v9 + 3 * v7;
  uint64_t v16 = 0;
  unint64_t v17 = cc_ws_alloc;
  uint64_t v18 = cc_ws_free;
  if (v6)
  {
    unint64_t v10 = *a1;
    uint64_t v11 = cc_ws_alloc(v15, 3 * **a1);
    int v12 = ccec_validate_point_and_projectify_ws((uint64_t)v15, v10, v11, (uint64_t)(a1 + 2));
    uint64_t v16 = 0;
    v18((uint64_t)v15);
    BOOL v13 = v12 == 0;
  }
  else
  {
    BOOL v13 = 0;
  }
  cc_disable_dit_with_sb((unsigned int *)&v19);
  return v13;
}

uint64_t ccpad_cts3_decrypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v28 = *MEMORY[0x263EF8C08];
  BOOL v25 = timingsafe_enable_if_supported();
  unint64_t v11 = *(void *)(a1 + 8);
  int v12 = &v26[v11];
  unint64_t v13 = (a4 - 1) / v11;
  if (v13 >= 2)
  {
    uint64_t v15 = (v13 - 1) * v11;
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a2, a3);
    uint64_t v14 = a4 - v15;
    a6 += v15;
  }
  else
  {
    uint64_t v14 = a4;
  }
  __memcpy_chk();
  if (2 * v11 == v14)
  {
    for (uint64_t i = 0; i != v11; ++i)
    {
      char v17 = v26[i];
      v26[i] = v12[i];
      v12[i] = v17;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *, uint64_t))(a1 + 24))(a2, a3, 2, v26, a6);
  }
  else
  {
    uint64_t v18 = v14 - v11;
    ecb_from_cbc_0(a1, a2, (uint64_t)v26, (uint64_t)v27);
    if (v14 - v11 < v11) {
      memcpy(&v26[v14], &v27[v18], 2 * v11 - v14);
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *, uint64_t))(a1 + 24))(a2, a3, 1, &v26[v11], a6);
    if (v14 != v11)
    {
      BOOL v19 = (unsigned char *)(a6 + v11);
      uint64_t v20 = v27;
      do
      {
        char v22 = *v12++;
        char v21 = v22;
        char v23 = *v20++;
        *v19++ = v23 ^ v21;
        --v18;
      }
      while (v18);
    }
  }
  cc_disable_dit_with_sb((unsigned int *)&v25);
  return a4;
}

uint64_t ecb_from_cbc_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v13[1] = *MEMORY[0x263EF8C08];
  rsize_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = MEMORY[0x270FA53B0](a1, a2, a3, a4);
  unint64_t v11 = (char *)v13 - v10;
  cccbc_set_iv_internal(v9, (char *)v13 - v10, 0);
  cccbc_update_internal(a1, a2, (uint64_t)v11, 1, a3, a4);
  return cc_clear(v8, v11);
}

uint64_t ccrsa_generate_prime_ws(uint64_t a1, unint64_t a2, void *a3, void *a4, uint64_t (**a5)(void, unint64_t, uint64_t), uint64_t (**a6)(void, unint64_t, uint64_t))
{
  unint64_t v6 = a2 + 63;
  if (a2 + 63 < 0x40) {
    return 4294967289;
  }
  unint64_t v14 = v6 >> 6;
  unint64_t v15 = ccn_n(v6 >> 6, (uint64_t)a4);
  uint64_t v17 = *(void *)(a1 + 16);
  while (1)
  {
    uint64_t result = ccn_random_bits(a2, (uint64_t)a3, a5);
    if (result) {
      break;
    }
    ccn_set_bit((uint64_t)a3, a2 - 1, 1);
    ccn_set_bit((uint64_t)a3, a2 - 2, 1);
    ccn_set_bit((uint64_t)a3, 0, 1);
    unint64_t v16 = ccrsa_num_mr_iterations(a2);
    LODWORD(result) = ccrsa_is_valid_prime_ws(a1, v14, a3, v15, a4, v16, a6);
    if (result == 1 || (result & 0x80000000) != 0)
    {
      if (result == 1) {
        uint64_t result = 0;
      }
      else {
        uint64_t result = result;
      }
      break;
    }
  }
  *(void *)(a1 + 16) = v17;
  return result;
}

uint64_t ccrsa_get_pubkey_components(unint64_t *a1, uint64_t a2, unint64_t *a3, uint64_t a4, unint64_t *a5)
{
  uint64_t v10 = a1 + 3;
  unint64_t v11 = *a1;
  unint64_t v12 = ccn_write_uint_size_public_value(*a1, a1 + 3);
  if (v12 > *a3) {
    return 0xFFFFFFFFLL;
  }
  *a3 = v12;
  ccn_write_uint_public_value(v11, v10, v12, a2);
  unint64_t v13 = *a1;
  unint64_t v14 = &v10[2 * v13 + 1];
  unint64_t v15 = ccn_write_uint_size_public_value(v13, v14);
  if (v15 > *a5) {
    return 0xFFFFFFFFLL;
  }
  *a5 = v15;
  ccn_write_uint_public_value(v13, v14, v15, a4);
  return 0;
}

uint64_t ccpad_pkcs7_decrypt(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v15 = timingsafe_enable_if_supported();
  unint64_t v12 = *(void *)(a1 + 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t, uint64_t, uint64_t))(a1 + 24))(a2, a3, a4 / v12, a5, a6);
  uint64_t v13 = a4 - ccpad_pkcs7_decode_internal(v12, a6 + (a4 / v12 - 1) * v12);
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v13;
}

uint64_t ccaes_gladman_encrypt_key128(int *a1, int *a2)
{
  int v2 = *a1;
  *a2 = *a1;
  int v3 = a1[1];
  a2[1] = v3;
  int v4 = a1[2];
  a2[2] = v4;
  unint64_t v5 = a1[3];
  a2[3] = v5;
  int v6 = t_fl[BYTE1(v5)] ^ t_fl[BYTE2(v5) + 256] ^ *(_DWORD *)((char *)&t_fl[512] + ((v5 >> 22) & 0x3FC)) ^ t_fl[v5 + 768] ^ 1 ^ v2;
  a2[4] = v6;
  a2[5] = v6 ^ v3;
  int v7 = v6 ^ v3 ^ v4;
  a2[6] = v7;
  a2[7] = v7 ^ v5;
  int v8 = t_fl[((v7 ^ v5) >> 16) + 256] ^ t_fl[((unsigned __int16)(v7 ^ v5) >> 8)] ^ t_fl[((v7 ^ v5) >> 24) + 512] ^ t_fl[(v7 ^ v5) + 768] ^ 2;
  int v9 = v8 ^ v6;
  int v10 = v8 ^ v3;
  a2[8] = v9;
  a2[9] = v10;
  a2[10] = v10 ^ v7;
  a2[11] = v10 ^ v5;
  int v11 = t_fl[((unsigned __int16)(v10 ^ v5) >> 8)] ^ t_fl[((v10 ^ v5) >> 16)
                                                                        + 256] ^ t_fl[((v10 ^ v5) >> 24)
                                                                                    + 512] ^ t_fl[(v10 ^ v5)
                                                                                                + 768] ^ v9 ^ 4;
  a2[12] = v11;
  a2[13] = v11 ^ v10;
  int v12 = v11 ^ v7;
  unsigned int v13 = v12 ^ v10 ^ v5;
  a2[14] = v12;
  a2[15] = v13;
  int v14 = t_fl[BYTE2(v13) + 256] ^ t_fl[BYTE1(v13)] ^ t_fl[HIBYTE(v13) + 512] ^ t_fl[(v12 ^ v10 ^ v5)
                                                                                 + 768] ^ 8;
  int v15 = v14 ^ v11;
  int v16 = v14 ^ v10;
  a2[16] = v15;
  a2[17] = v16;
  LODWORD(v5) = v14 ^ v5;
  a2[18] = v16 ^ v12;
  a2[19] = v5;
  int v17 = t_fl[BYTE1(v5)] ^ t_fl[BYTE2(v5) + 256] ^ t_fl[BYTE3(v5) + 512] ^ t_fl[v5 + 768] ^ v15 ^ 0x10;
  a2[20] = v17;
  a2[21] = v17 ^ v16;
  int v18 = v17 ^ v12;
  a2[22] = v18;
  a2[23] = v18 ^ v5;
  int v19 = t_fl[((v18 ^ v5) >> 16) + 256] ^ t_fl[((unsigned __int16)(v18 ^ v5) >> 8)] ^ t_fl[((v18 ^ v5) >> 24) + 512] ^ t_fl[(v18 ^ v5) + 768] ^ 0x20;
  int v20 = v19 ^ v17;
  int v21 = v19 ^ v16;
  a2[24] = v20;
  a2[25] = v21;
  a2[26] = v21 ^ v18;
  a2[27] = v21 ^ v5;
  int v22 = t_fl[((unsigned __int16)(v21 ^ v5) >> 8)] ^ t_fl[((v21 ^ v5) >> 16)
                                                                        + 256] ^ t_fl[((v21 ^ v5) >> 24)
                                                                                    + 512] ^ t_fl[(v21 ^ v5)
                                                                                                + 768] ^ v20 ^ 0x40;
  a2[28] = v22;
  a2[29] = v22 ^ v21;
  int v23 = v22 ^ v18;
  unsigned int v24 = v23 ^ v21 ^ v5;
  a2[30] = v23;
  a2[31] = v24;
  int v25 = t_fl[BYTE2(v24) + 256] ^ t_fl[BYTE1(v24)] ^ t_fl[HIBYTE(v24) + 512] ^ t_fl[(v23 ^ v21 ^ v5)
                                                                                 + 768] ^ 0x80;
  int v26 = v25 ^ v22;
  int v27 = v25 ^ v21;
  a2[32] = v26;
  a2[33] = v27;
  LODWORD(v5) = v25 ^ v5;
  a2[34] = v27 ^ v23;
  a2[35] = v5;
  int v28 = t_fl[BYTE1(v5)] ^ t_fl[BYTE2(v5) + 256] ^ t_fl[BYTE3(v5) + 512] ^ t_fl[v5 + 768] ^ v26 ^ 0x1B;
  a2[36] = v28;
  a2[37] = v28 ^ v27;
  int v29 = v28 ^ v23;
  a2[38] = v29;
  a2[39] = v29 ^ v5;
  uint64_t result = ((v29 ^ v5) >> 16);
  int v31 = t_fl[result + 256] ^ t_fl[((unsigned __int16)(v29 ^ v5) >> 8)] ^ t_fl[((v29 ^ v5) >> 24)
                                                                                             + 512] ^ t_fl[(v29 ^ v5) + 768] ^ 0x36;
  int v32 = v31 ^ v28;
  int v33 = v31 ^ v27;
  a2[40] = v32;
  a2[41] = v33;
  a2[42] = v33 ^ v29;
  a2[43] = v33 ^ v5;
  a2[60] = 10;
  return result;
}

uint64_t ccaes_gladman_encrypt_key192(int *a1, int *a2)
{
  int v2 = *a1;
  *a2 = *a1;
  int v3 = a1[1];
  a2[1] = v3;
  int v4 = a1[2];
  a2[2] = v4;
  int v5 = a1[3];
  a2[3] = v5;
  int v6 = a1[4];
  a2[4] = v6;
  unint64_t v7 = a1[5];
  a2[5] = v7;
  int v8 = t_fl[BYTE1(v7)] ^ t_fl[BYTE2(v7) + 256] ^ *(_DWORD *)((char *)&t_fl[512] + ((v7 >> 22) & 0x3FC)) ^ t_fl[v7 + 768] ^ 1 ^ v2;
  a2[6] = v8;
  a2[7] = v8 ^ v3;
  int v9 = v8 ^ v3 ^ v4;
  a2[8] = v9;
  a2[9] = v9 ^ v5;
  int v10 = v9 ^ v5 ^ v6;
  a2[10] = v10;
  a2[11] = v10 ^ v7;
  int v11 = t_fl[((v10 ^ v7) >> 16) + 256] ^ t_fl[((unsigned __int16)(v10 ^ v7) >> 8)] ^ t_fl[((v10 ^ v7) >> 24) + 512] ^ t_fl[(v10 ^ v7) + 768] ^ 2;
  int v12 = v11 ^ v8;
  int v13 = v11 ^ v3;
  a2[12] = v12;
  a2[13] = v13;
  a2[14] = v13 ^ v9;
  a2[15] = v13 ^ v5;
  unsigned int v14 = v13 ^ v5 ^ v7;
  a2[16] = v13 ^ v5 ^ v10;
  a2[17] = v14;
  LODWORD(v7) = t_fl[((unsigned __int16)(v13 ^ v5 ^ v7) >> 8)] ^ t_fl[BYTE2(v14) + 256] ^ t_fl[HIBYTE(v14) + 512] ^ t_fl[(v13 ^ v5 ^ v7) + 768] ^ v12 ^ 4;
  a2[18] = v7;
  a2[19] = v7 ^ v13;
  int v15 = v7 ^ v9;
  a2[20] = v15;
  a2[21] = v15 ^ v13 ^ v5;
  unsigned int v16 = v15 ^ v10 ^ v14;
  a2[22] = v15 ^ v10;
  a2[23] = v16;
  int v17 = t_fl[BYTE2(v16) + 256] ^ t_fl[BYTE1(v16)] ^ t_fl[HIBYTE(v16) + 512] ^ t_fl[(v15 ^ v10 ^ v14)
                                                                                 + 768] ^ 8;
  LODWORD(v7) = v17 ^ v7;
  int v18 = v17 ^ v13;
  a2[24] = v7;
  a2[25] = v18;
  int v19 = v17 ^ v5;
  a2[26] = v18 ^ v15;
  a2[27] = v19;
  a2[28] = v19 ^ v15 ^ v10;
  a2[29] = v19 ^ v14;
  LODWORD(v7) = t_fl[((unsigned __int16)(v19 ^ v14) >> 8)] ^ t_fl[((v19 ^ v14) >> 16)
                                                                                 + 256] ^ t_fl[((v19 ^ v14) >> 24) + 512] ^ t_fl[(v19 ^ v14) + 768] ^ v7 ^ 0x10;
  a2[30] = v7;
  a2[31] = v7 ^ v18;
  int v20 = v7 ^ v15;
  a2[32] = v20;
  a2[33] = v20 ^ v19;
  int v21 = v7 ^ v10;
  unsigned int v22 = v21 ^ v19 ^ v14;
  a2[34] = v21;
  a2[35] = v22;
  int v23 = t_fl[BYTE2(v22) + 256] ^ t_fl[BYTE1(v22)] ^ t_fl[HIBYTE(v22) + 512] ^ t_fl[(v21 ^ v19 ^ v14)
                                                                                 + 768] ^ 0x20;
  LODWORD(v7) = v23 ^ v7;
  uint64_t result = v23 ^ v18;
  a2[36] = v7;
  a2[37] = result;
  a2[38] = result ^ v20;
  a2[39] = result ^ v19;
  unsigned int v25 = result ^ v14;
  a2[40] = result ^ v19 ^ v21;
  a2[41] = v25;
  LODWORD(v7) = t_fl[BYTE1(v25)] ^ t_fl[BYTE2(v25) + 256] ^ t_fl[HIBYTE(v25) + 512] ^ t_fl[v25 + 768] ^ v7 ^ 0x40;
  a2[42] = v7;
  a2[43] = v7 ^ result;
  int v26 = v7 ^ v20;
  a2[44] = v26;
  a2[45] = v26 ^ result ^ v19;
  int v27 = v26 ^ v21;
  unsigned int v28 = v27 ^ v25;
  a2[46] = v27;
  a2[47] = v28;
  int v29 = t_fl[BYTE2(v28) + 256] ^ t_fl[BYTE1(v28)] ^ t_fl[HIBYTE(v28) + 512] ^ t_fl[v28 + 768] ^ 0x80;
  a2[48] = v29 ^ v7;
  a2[49] = v29 ^ result;
  a2[50] = v29 ^ result ^ v26;
  a2[51] = v29 ^ v19;
  a2[60] = 12;
  return result;
}

uint64_t ccaes_gladman_encrypt_key256(int *a1, int *a2)
{
  int v2 = *a1;
  *a2 = *a1;
  int v3 = a1[1];
  a2[1] = v3;
  int v4 = a1[2];
  a2[2] = v4;
  unsigned int v5 = a1[3];
  a2[3] = v5;
  int v6 = a1[4];
  a2[4] = v6;
  int v7 = a1[5];
  a2[5] = v7;
  int v8 = a1[6];
  a2[6] = v8;
  unint64_t v9 = a1[7];
  a2[7] = v9;
  int v10 = t_fl[BYTE1(v9)] ^ t_fl[BYTE2(v9) + 256] ^ *(_DWORD *)((char *)&t_fl[512] + ((v9 >> 22) & 0x3FC)) ^ t_fl[v9 + 768] ^ 1 ^ v2;
  a2[8] = v10;
  a2[9] = v10 ^ v3;
  int v11 = v10 ^ v3 ^ v4;
  a2[10] = v11;
  a2[11] = v11 ^ v5;
  int v12 = t_fl[(v11 ^ v5)] ^ t_fl[((unsigned __int16)(v11 ^ v5) >> 8) + 256] ^ t_fl[((v11 ^ v5) >> 16) + 512] ^ t_fl[((v11 ^ v5) >> 24) + 768] ^ v6;
  a2[12] = v12;
  a2[13] = v12 ^ v7;
  int v13 = v12 ^ v7 ^ v8;
  a2[14] = v13;
  a2[15] = v13 ^ v9;
  int v14 = t_fl[((v13 ^ v9) >> 16) + 256] ^ t_fl[((unsigned __int16)(v13 ^ v9) >> 8)] ^ t_fl[((v13 ^ v9) >> 24) + 512] ^ t_fl[(v13 ^ v9) + 768] ^ 2;
  int v15 = v14 ^ v10;
  int v16 = v14 ^ v3;
  a2[16] = v14 ^ v10;
  a2[17] = v16;
  a2[18] = v16 ^ v11;
  a2[19] = v16 ^ v5;
  int v17 = t_fl[((unsigned __int16)(v16 ^ v5) >> 8) + 256] ^ t_fl[(v16 ^ v5)] ^ t_fl[((v16 ^ v5) >> 16) + 512] ^ t_fl[((v16 ^ v5) >> 24) + 768];
  int v18 = v17 ^ v12;
  int v19 = v17 ^ v7;
  a2[20] = v18;
  a2[21] = v19;
  a2[22] = v19 ^ v13;
  a2[23] = v19 ^ v9;
  int v20 = t_fl[((unsigned __int16)(v19 ^ v9) >> 8)] ^ t_fl[((v19 ^ v9) >> 16)
                                                                        + 256] ^ t_fl[((v19 ^ v9) >> 24)
                                                                                    + 512] ^ t_fl[(v19 ^ v9)
                                                                                                + 768] ^ v15 ^ 4;
  a2[24] = v20;
  a2[25] = v20 ^ v16;
  int v21 = v20 ^ v11;
  unsigned int v22 = v21 ^ v16 ^ v5;
  a2[26] = v21;
  a2[27] = v22;
  int v23 = t_fl[(v21 ^ v16 ^ v5)] ^ t_fl[BYTE1(v22) + 256] ^ t_fl[BYTE2(v22) + 512] ^ t_fl[HIBYTE(v22) + 768] ^ v18;
  a2[28] = v23;
  a2[29] = v23 ^ v19;
  int v24 = v23 ^ v13;
  unsigned int v25 = v24 ^ v19 ^ v9;
  a2[30] = v24;
  a2[31] = v25;
  int v26 = t_fl[BYTE2(v25) + 256] ^ t_fl[BYTE1(v25)] ^ t_fl[HIBYTE(v25) + 512] ^ t_fl[(v24 ^ v19 ^ v9)
                                                                                 + 768] ^ 8;
  int v27 = v26 ^ v20;
  int v28 = v26 ^ v16;
  a2[32] = v27;
  a2[33] = v28;
  unsigned int v29 = v26 ^ v5;
  a2[34] = v28 ^ v21;
  a2[35] = v29;
  int v30 = t_fl[BYTE1(v29) + 256] ^ t_fl[v29] ^ t_fl[BYTE2(v29) + 512] ^ t_fl[HIBYTE(v29) + 768];
  int v31 = v30 ^ v23;
  int v32 = v30 ^ v19;
  a2[36] = v31;
  a2[37] = v32;
  LODWORD(v9) = v30 ^ v9;
  a2[38] = v32 ^ v24;
  a2[39] = v9;
  int v33 = t_fl[BYTE1(v9)] ^ t_fl[BYTE2(v9) + 256] ^ t_fl[BYTE3(v9) + 512] ^ t_fl[v9 + 768] ^ v27 ^ 0x10;
  a2[40] = v33;
  a2[41] = v33 ^ v28;
  int v34 = v33 ^ v21;
  a2[42] = v34;
  a2[43] = v34 ^ v29;
  int v35 = t_fl[(v34 ^ v29)] ^ t_fl[((unsigned __int16)(v34 ^ v29) >> 8) + 256] ^ t_fl[((v34 ^ v29) >> 16) + 512] ^ t_fl[((v34 ^ v29) >> 24) + 768] ^ v31;
  a2[44] = v35;
  a2[45] = v35 ^ v32;
  int v36 = v35 ^ v24;
  a2[46] = v36;
  a2[47] = v36 ^ v9;
  int v37 = t_fl[((v36 ^ v9) >> 16) + 256] ^ t_fl[((unsigned __int16)(v36 ^ v9) >> 8)] ^ t_fl[((v36 ^ v9) >> 24) + 512] ^ t_fl[(v36 ^ v9) + 768] ^ 0x20;
  int v38 = v37 ^ v33;
  int v39 = v37 ^ v28;
  a2[48] = v38;
  a2[49] = v39;
  unsigned int v40 = v39 ^ v29;
  a2[50] = v39 ^ v34;
  a2[51] = v40;
  int v41 = t_fl[BYTE1(v40) + 256] ^ t_fl[v40] ^ t_fl[BYTE2(v40) + 512] ^ t_fl[HIBYTE(v40) + 768];
  int v42 = v41 ^ v32;
  a2[52] = v41 ^ v35;
  a2[53] = v42;
  uint64_t result = v42 ^ v36;
  LODWORD(v9) = v42 ^ v9;
  a2[54] = result;
  a2[55] = v9;
  int v44 = t_fl[BYTE1(v9)] ^ t_fl[BYTE2(v9) + 256] ^ t_fl[BYTE3(v9) + 512] ^ t_fl[v9 + 768] ^ v38 ^ 0x40;
  a2[56] = v44;
  a2[57] = v44 ^ v39;
  int v45 = v44 ^ v34;
  a2[58] = v45;
  a2[59] = v45 ^ v40;
  a2[60] = 14;
  return result;
}

uint64_t ccaes_gladman_encrypt_key(int *a1, uint64_t a2, int *a3)
{
  uint64_t v3 = 4294967289;
  if (a2 <= 127)
  {
    if (a2 != 16)
    {
      if (a2 != 24)
      {
        if (a2 != 32) {
          return v3;
        }
        goto LABEL_10;
      }
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  switch(a2)
  {
    case 256:
LABEL_10:
      ccaes_gladman_encrypt_key256(a1, a3);
      return 0;
    case 192:
LABEL_11:
      ccaes_gladman_encrypt_key192(a1, a3);
      return 0;
    case 128:
LABEL_9:
      ccaes_gladman_encrypt_key128(a1, a3);
      return 0;
  }
  return v3;
}

uint64_t ccaes_gladman_decrypt_key128(unsigned int *a1, unsigned int *a2)
{
  unsigned int v2 = *a1;
  *a2 = *a1;
  unsigned int v3 = a1[1];
  a2[1] = v3;
  unsigned int v4 = a1[2];
  a2[2] = v4;
  unint64_t v5 = a1[3];
  a2[3] = v5;
  int v6 = v5 ^ v3;
  int v7 = t_fl[BYTE2(v5) + 256] ^ t_fl[BYTE1(v5)] ^ *(_DWORD *)((char *)&t_fl[512] + ((v5 >> 22) & 0x3FC)) ^ t_fl[v5 + 768] ^ 1;
  int v8 = v5 ^ v3 ^ v2 ^ v4;
  int v9 = t_im[((unsigned __int16)(v7 ^ v2) >> 8) + 256] ^ t_im[(v7 ^ v2)] ^ t_im[((v7 ^ v2) >> 16) + 512] ^ t_im[((v7 ^ v2) >> 24) + 768];
  a2[4] = v9;
  unsigned int v10 = v7 ^ v2 ^ v3;
  unsigned int v11 = v8 ^ v7;
  int v12 = t_im[BYTE1(v10) + 256] ^ t_im[v10] ^ t_im[BYTE2(v10) + 512] ^ t_im[HIBYTE(v10) + 768];
  a2[5] = v12;
  unsigned int v13 = v10 ^ v4;
  int v14 = t_im[BYTE1(v13) + 256] ^ t_im[v13] ^ t_im[BYTE2(v13) + 512] ^ t_im[HIBYTE(v13) + 768];
  a2[6] = v14;
  int v15 = t_im[((unsigned __int16)(v13 ^ v5) >> 8) + 256] ^ t_im[(v13 ^ v5)] ^ t_im[((v13 ^ v5) >> 16) + 512] ^ t_im[((v13 ^ v5) >> 24) + 768];
  a2[7] = v15;
  unsigned int v16 = t_fl[BYTE2(v11) + 256] ^ t_fl[BYTE1(v11)] ^ t_fl[HIBYTE(v11) + 512] ^ t_fl[v11 + 768] ^ 2;
  unsigned int v17 = v6 ^ v16;
  int v18 = t_im[(LOBYTE(t_fl[BYTE2(v11) + 256]) ^ LOBYTE(t_fl[BYTE1(v11)]) ^ LOBYTE(t_fl[HIBYTE(v11) + 512]) ^ LOBYTE(t_fl[v11 + 768])) ^ 2] ^ t_im[BYTE1(v16) + 256] ^ t_im[BYTE2(v16) + 512] ^ t_im[HIBYTE(v16) + 768] ^ v9;
  a2[8] = v18;
  a2[9] = v18 ^ v12;
  int v19 = v18 ^ v12 ^ v14;
  a2[10] = v19;
  a2[11] = v19 ^ v15;
  unsigned int v20 = t_fl[BYTE2(v17) + 256] ^ t_fl[BYTE1(v17)] ^ t_fl[HIBYTE(v17) + 512] ^ t_fl[v17 + 768] ^ 4;
  unsigned int v21 = v5 ^ v4 ^ v20;
  int v22 = t_im[BYTE1(v20) + 256] ^ t_im[(LOBYTE(t_fl[BYTE2(v17) + 256]) ^ LOBYTE(t_fl[BYTE1(v17)]) ^ LOBYTE(t_fl[HIBYTE(v17) + 512]) ^ LOBYTE(t_fl[v17 + 768])) ^ 4] ^ t_im[BYTE2(v20) + 512] ^ t_im[HIBYTE(v20) + 768];
  int v23 = v22 ^ v18;
  int v24 = v22 ^ v12;
  a2[12] = v23;
  a2[13] = v22 ^ v12;
  a2[14] = v22 ^ v12 ^ v19;
  a2[15] = v22 ^ v12 ^ v15;
  unsigned int v25 = t_fl[BYTE2(v21) + 256] ^ t_fl[BYTE1(v21)] ^ t_fl[HIBYTE(v21) + 512] ^ t_fl[v21 + 768] ^ 8;
  unsigned int v26 = v25 ^ v5;
  LODWORD(v5) = t_im[(LOBYTE(t_fl[BYTE2(v21) + 256]) ^ LOBYTE(t_fl[BYTE1(v21)]) ^ LOBYTE(t_fl[HIBYTE(v21) + 512]) ^ LOBYTE(t_fl[v21 + 768])) ^ 8] ^ t_im[BYTE1(v25) + 256] ^ t_im[BYTE2(v25) + 512] ^ t_im[HIBYTE(v25) + 768] ^ v23;
  a2[16] = v5;
  a2[17] = v5 ^ v24;
  unsigned int v27 = v5 ^ v19;
  a2[18] = v27;
  a2[19] = v27 ^ v24 ^ v15;
  unsigned int v28 = t_fl[BYTE2(v26) + 256] ^ t_fl[BYTE1(v26)] ^ t_fl[HIBYTE(v26) + 512] ^ t_fl[v26 + 768] ^ 0x10;
  unsigned int v29 = v28 ^ v11;
  int v30 = t_im[BYTE1(v28) + 256] ^ t_im[(LOBYTE(t_fl[BYTE2(v26) + 256]) ^ LOBYTE(t_fl[BYTE1(v26)]) ^ LOBYTE(t_fl[HIBYTE(v26) + 512]) ^ LOBYTE(t_fl[v26 + 768])) ^ 0x10] ^ t_im[BYTE2(v28) + 512] ^ t_im[HIBYTE(v28) + 768];
  int v31 = v30 ^ v5;
  int v32 = v30 ^ v24;
  a2[20] = v30 ^ v5;
  a2[21] = v32;
  LODWORD(v5) = v30 ^ v15;
  a2[22] = v32 ^ v27;
  a2[23] = v30 ^ v15;
  unsigned int v33 = t_fl[BYTE2(v29) + 256] ^ t_fl[BYTE1(v29)] ^ t_fl[HIBYTE(v29) + 512] ^ t_fl[v29 + 768] ^ 0x20;
  uint64_t result = v33 ^ v17;
  int v35 = t_im[(LOBYTE(t_fl[BYTE2(v29) + 256]) ^ LOBYTE(t_fl[BYTE1(v29)]) ^ LOBYTE(t_fl[HIBYTE(v29) + 512]) ^ LOBYTE(t_fl[v29 + 768])) ^ 0x20] ^ t_im[BYTE1(v33) + 256] ^ t_im[BYTE2(v33) + 512] ^ t_im[HIBYTE(v33) + 768] ^ v31;
  a2[24] = v35;
  a2[25] = v35 ^ v32;
  int v36 = v35 ^ v27;
  a2[26] = v35 ^ v27;
  a2[27] = v35 ^ v27 ^ v5;
  unsigned int v37 = t_fl[BYTE2(result) + 256] ^ t_fl[BYTE1(result)] ^ t_fl[BYTE3(result) + 512] ^ t_fl[result + 768] ^ 0x40;
  unsigned int v38 = v37 ^ v21;
  int v39 = t_im[BYTE1(v37) + 256] ^ t_im[(LOBYTE(t_fl[BYTE2(result) + 256]) ^ LOBYTE(t_fl[BYTE1(result)]) ^ LOBYTE(t_fl[BYTE3(result) + 512]) ^ LOBYTE(t_fl[result + 768])) ^ 0x40] ^ t_im[BYTE2(v37) + 512] ^ t_im[HIBYTE(v37) + 768];
  int v40 = v39 ^ v35;
  int v41 = v39 ^ v32;
  a2[28] = v40;
  a2[29] = v39 ^ v32;
  a2[30] = v39 ^ v32 ^ v36;
  a2[31] = v39 ^ v32 ^ v5;
  unsigned int v42 = t_fl[BYTE2(v38) + 256] ^ t_fl[BYTE1(v38)] ^ t_fl[HIBYTE(v38) + 512] ^ t_fl[v38 + 768] ^ 0x80;
  unsigned int v43 = v42 ^ v26;
  int v44 = t_im[(LOBYTE(t_fl[BYTE2(v38) + 256]) ^ LOBYTE(t_fl[BYTE1(v38)]) ^ LOBYTE(t_fl[HIBYTE(v38) + 512]) ^ LOBYTE(t_fl[v38 + 768])) ^ 0x80] ^ t_im[BYTE1(v42) + 256] ^ t_im[BYTE2(v42) + 512] ^ t_im[HIBYTE(v42) + 768] ^ v40;
  a2[32] = v44;
  a2[33] = v44 ^ v41;
  int v45 = v44 ^ v36;
  a2[34] = v45;
  a2[35] = v45 ^ v41 ^ v5;
  unsigned int v46 = t_fl[BYTE2(v43) + 256] ^ t_fl[BYTE1(v43)] ^ t_fl[HIBYTE(v43) + 512] ^ t_fl[v43 + 768] ^ 0x1B;
  unsigned int v47 = v46 ^ v29;
  int v48 = t_im[BYTE1(v46) + 256] ^ t_im[(LOBYTE(t_fl[BYTE2(v43) + 256]) ^ LOBYTE(t_fl[BYTE1(v43)]) ^ LOBYTE(t_fl[HIBYTE(v43) + 512]) ^ LOBYTE(t_fl[v43 + 768])) ^ 0x1B] ^ t_im[BYTE2(v46) + 512] ^ t_im[HIBYTE(v46) + 768];
  a2[36] = v48 ^ v44;
  a2[37] = v48 ^ v41;
  a2[38] = v48 ^ v41 ^ v45;
  a2[39] = v48 ^ v5;
  unsigned int v49 = t_fl[BYTE1(v47)] ^ t_fl[BYTE2(v47) + 256] ^ t_fl[HIBYTE(v47) + 512] ^ t_fl[v47 + 768] ^ result ^ 0x36;
  a2[40] = v43 ^ v38 ^ v49 ^ v47;
  a2[41] = v49 ^ v43;
  a2[42] = v49 ^ v47;
  a2[43] = v49;
  a2[60] = 10;
  return result;
}

uint64_t ccaes_gladman_decrypt_key192(int *a1, int *a2)
{
  int v2 = *a1;
  *a2 = *a1;
  int v3 = a1[1];
  a2[1] = v3;
  int v4 = a1[2];
  a2[2] = v4;
  int v5 = a1[3];
  a2[3] = v5;
  unint64_t v7 = a1[4];
  unint64_t v6 = a1[5];
  a2[4] = t_im[BYTE1(v7) + 256] ^ t_im[v7] ^ t_im[BYTE2(v7) + 512] ^ *(_DWORD *)((char *)&t_im[768]
                                                                                                + ((v7 >> 22) & 0x3FC));
  uint64_t v8 = (v6 >> 22) & 0x3FC;
  a2[5] = t_im[BYTE1(v6) + 256] ^ t_im[v6] ^ t_im[BYTE2(v6) + 512] ^ *(_DWORD *)((char *)&t_im[768] + v8);
  unsigned int v9 = t_fl[BYTE1(v6)] ^ t_fl[BYTE2(v6) + 256] ^ *(_DWORD *)((char *)&t_fl[512] + v8) ^ t_fl[v6 + 768] ^ 1 ^ v2;
  int v10 = t_im[BYTE1(v9) + 256] ^ t_im[v9] ^ t_im[BYTE2(v9) + 512] ^ t_im[HIBYTE(v9) + 768];
  a2[6] = v10;
  int v11 = t_im[((unsigned __int16)(v9 ^ v3) >> 8) + 256] ^ t_im[(v9 ^ v3)] ^ t_im[((v9 ^ v3) >> 16) + 512] ^ t_im[((v9 ^ v3) >> 24) + 768];
  a2[7] = v11;
  unsigned int v12 = v9 ^ v3 ^ v4;
  int v13 = t_im[BYTE1(v12) + 256] ^ t_im[(v9 ^ v3 ^ v4)] ^ t_im[BYTE2(v12) + 512] ^ t_im[HIBYTE(v12) + 768];
  a2[8] = v13;
  int v14 = t_im[((unsigned __int16)(v12 ^ v5) >> 8) + 256] ^ t_im[(v12 ^ v5)] ^ t_im[((v12 ^ v5) >> 16) + 512] ^ t_im[((v12 ^ v5) >> 24) + 768];
  a2[9] = v14;
  LODWORD(v7) = v12 ^ v5 ^ v7;
  int v15 = t_im[BYTE1(v7) + 256] ^ t_im[v7] ^ t_im[BYTE2(v7) + 512] ^ t_im[BYTE3(v7) + 768];
  a2[10] = v15;
  unsigned int v16 = (v7 ^ v6) >> 24;
  int v17 = t_im[((unsigned __int16)(v7 ^ v6) >> 8) + 256] ^ t_im[(v7 ^ v6)] ^ t_im[((v7 ^ v6) >> 16) + 512] ^ t_im[v16 + 768];
  a2[11] = v17;
  unsigned int v18 = t_fl[((v7 ^ v6) >> 16) + 256] ^ t_fl[((unsigned __int16)(v7 ^ v6) >> 8)] ^ t_fl[v16 + 512] ^ t_fl[(v7 ^ v6) + 768] ^ 2;
  int v19 = v18 ^ v9;
  int v20 = t_im[v18] ^ t_im[BYTE1(v18) + 256] ^ t_im[BYTE2(v18) + 512] ^ t_im[HIBYTE(v18) + 768] ^ v10;
  int v21 = v18 ^ v3;
  a2[12] = v20;
  a2[13] = v20 ^ v11;
  int v22 = v20 ^ v11 ^ v13;
  a2[14] = v22;
  a2[15] = v22 ^ v14;
  int v23 = v22 ^ v14 ^ v15;
  unsigned int v24 = v6 ^ v5 ^ v21;
  a2[16] = v23;
  a2[17] = v23 ^ v17;
  LODWORD(v6) = t_fl[BYTE2(v24) + 256] ^ t_fl[((unsigned __int16)(v6 ^ v5 ^ v21) >> 8)] ^ t_fl[HIBYTE(v24) + 512] ^ t_fl[(v6 ^ v5 ^ v21) + 768] ^ 4;
  int v25 = v19 ^ v6;
  LODWORD(v6) = t_im[BYTE1(v6) + 256] ^ t_im[v6] ^ t_im[BYTE2(v6) + 512] ^ t_im[BYTE3(v6) + 768];
  int v26 = v6 ^ v20;
  int v27 = v6 ^ v11;
  a2[18] = v6 ^ v20;
  a2[19] = v27;
  int v28 = v25 ^ v12;
  a2[20] = v27 ^ v22;
  a2[21] = v27 ^ v14;
  uint64_t result = v27 ^ v14 ^ v17;
  a2[22] = v27 ^ v14 ^ v23;
  a2[23] = result;
  unsigned int v30 = t_fl[((v24 ^ v7 ^ v28) >> 16) + 256] ^ t_fl[((unsigned __int16)(v24 ^ v7 ^ v28) >> 8)] ^ t_fl[((v24 ^ v7 ^ v28) >> 24) + 512] ^ t_fl[(v24 ^ v7 ^ v28) + 768] ^ 8;
  int v31 = t_im[(LOBYTE(t_fl[((v24 ^ v7 ^ v28) >> 16) + 256]) ^ LOBYTE(t_fl[((unsigned __int16)(v24 ^ v7 ^ v28) >> 8)]) ^ LOBYTE(t_fl[((v24 ^ v7 ^ v28) >> 24) + 512]) ^ LOBYTE(t_fl[(v24 ^ v7 ^ v28) + 768])) ^ 8] ^ t_im[BYTE1(v30) + 256] ^ t_im[BYTE2(v30) + 512] ^ t_im[HIBYTE(v30) + 768] ^ v26;
  int v32 = v30 ^ v21;
  a2[24] = v31;
  a2[25] = v31 ^ v27;
  int v33 = v31 ^ v22;
  int v34 = v30 ^ v5;
  a2[26] = v33;
  a2[27] = v33 ^ v27 ^ v14;
  a2[28] = v33 ^ v23;
  a2[29] = v33 ^ v23 ^ result;
  unsigned int v35 = t_fl[((v34 ^ v24) >> 16) + 256] ^ t_fl[((unsigned __int16)(v34 ^ v24) >> 8)] ^ t_fl[((v34 ^ v24) >> 24) + 512] ^ t_fl[(v34 ^ v24) + 768] ^ 0x10;
  int v36 = v30 ^ v25 ^ v35;
  int v37 = t_im[BYTE1(v35) + 256] ^ t_im[(LOBYTE(t_fl[((v34 ^ v24) >> 16) + 256]) ^ LOBYTE(t_fl[((unsigned __int16)(v34 ^ v24) >> 8)]) ^ LOBYTE(t_fl[((v34 ^ v24) >> 24) + 512]) ^ LOBYTE(t_fl[(v34 ^ v24) + 768])) ^ 0x10] ^ t_im[BYTE2(v35) + 512] ^ t_im[HIBYTE(v35) + 768];
  int v38 = v37 ^ v31;
  int v39 = v37 ^ v27;
  a2[30] = v38;
  a2[31] = v39;
  int v40 = v37 ^ v14;
  a2[32] = v39 ^ v33;
  a2[33] = v40;
  LODWORD(v7) = v36 ^ v7;
  a2[34] = v40 ^ v33 ^ v23;
  a2[35] = v40 ^ result;
  int v41 = v36 ^ v28;
  unsigned int v42 = t_fl[((v7 ^ v34 ^ v24) >> 16) + 256] ^ t_fl[((unsigned __int16)(v7 ^ v34 ^ v24) >> 8)] ^ t_fl[((v7 ^ v34 ^ v24) >> 24) + 512] ^ t_fl[(v7 ^ v34 ^ v24) + 768] ^ 0x20;
  int v43 = t_im[(LOBYTE(t_fl[((v7 ^ v34 ^ v24) >> 16) + 256]) ^ LOBYTE(t_fl[((unsigned __int16)(v7 ^ v34 ^ v24) >> 8)]) ^ LOBYTE(t_fl[((v7 ^ v34 ^ v24) >> 24) + 512]) ^ LOBYTE(t_fl[(v7 ^ v34 ^ v24) + 768])) ^ 0x20] ^ t_im[BYTE1(v42) + 256] ^ t_im[BYTE2(v42) + 512] ^ t_im[HIBYTE(v42) + 768] ^ v38;
  int v44 = v32 ^ v42;
  a2[36] = v43;
  a2[37] = v43 ^ v39;
  int v45 = v43 ^ v33;
  a2[38] = v45;
  a2[39] = v45 ^ v40;
  int v46 = v43 ^ v23;
  unsigned int v47 = v44 ^ v24;
  a2[40] = v46;
  a2[41] = v46 ^ v40 ^ result;
  unsigned int v48 = t_fl[BYTE2(v47) + 256] ^ t_fl[BYTE1(v47)] ^ t_fl[HIBYTE(v47) + 512] ^ t_fl[v47 + 768] ^ 0x40;
  int v49 = v42 ^ v36 ^ v48;
  int v50 = t_im[BYTE1(v48) + 256] ^ t_im[(LOBYTE(t_fl[BYTE2(v47) + 256]) ^ LOBYTE(t_fl[BYTE1(v47)]) ^ LOBYTE(t_fl[HIBYTE(v47) + 512]) ^ LOBYTE(t_fl[v47 + 768])) ^ 0x40] ^ t_im[BYTE2(v48) + 512] ^ t_im[HIBYTE(v48) + 768];
  int v51 = v50 ^ v43;
  int v52 = v50 ^ v39;
  a2[42] = v51;
  a2[43] = v52;
  a2[44] = v52 ^ v45;
  a2[45] = v52 ^ v40;
  a2[46] = v52 ^ v40 ^ v46;
  a2[47] = v52 ^ result;
  int v53 = t_fl[((v47 ^ v7 ^ v41 ^ v49) >> 16) + 256] ^ t_fl[((unsigned __int16)(v47 ^ v7 ^ v41 ^ v49) >> 8)] ^ t_fl[((v47 ^ v7 ^ v41 ^ v49) >> 24) + 512] ^ t_fl[(v47 ^ v7 ^ v41 ^ v49) + 768] ^ 0x80;
  a2[48] = v53 ^ v49;
  a2[49] = v53 ^ v44;
  a2[50] = v53 ^ v44 ^ v41 ^ v49;
  a2[51] = v53 ^ v34;
  a2[60] = 12;
  return result;
}

uint64_t ccaes_gladman_decrypt_key256(int *a1, int *a2)
{
  int v2 = *a1;
  *a2 = *a1;
  int v3 = a1[1];
  a2[1] = v3;
  int v4 = v3;
  int v60 = v3;
  int v5 = a1[2];
  a2[2] = v5;
  int v6 = a1[3];
  a2[3] = v6;
  unint64_t v7 = a1[4];
  unint64_t v8 = a1[5];
  unint64_t v9 = a1[6];
  unint64_t v10 = a1[7];
  a2[4] = t_im[BYTE1(v7) + 256] ^ t_im[a1[4]] ^ t_im[BYTE2(v7) + 512] ^ *(_DWORD *)((char *)&t_im[768] + ((v7 >> 22) & 0x3FC));
  a2[5] = t_im[BYTE1(v8) + 256] ^ t_im[v8] ^ t_im[BYTE2(v8) + 512] ^ *(_DWORD *)((char *)&t_im[768]
                                                                                                + ((v8 >> 22) & 0x3FC));
  a2[6] = t_im[BYTE1(v9) + 256] ^ t_im[v9] ^ t_im[BYTE2(v9) + 512] ^ *(_DWORD *)((char *)&t_im[768]
                                                                                                + ((v9 >> 22) & 0x3FC));
  int v65 = v10;
  uint64_t v11 = (v10 >> 22) & 0x3FC;
  a2[7] = t_im[BYTE1(v10) + 256] ^ t_im[v10] ^ t_im[BYTE2(v10) + 512] ^ *(_DWORD *)((char *)&t_im[768] + v11);
  unsigned int v12 = t_fl[BYTE1(v10)] ^ t_fl[BYTE2(v10) + 256] ^ *(_DWORD *)((char *)&t_fl[512] + v11) ^ t_fl[v10
                                                                                               + 768] ^ 1 ^ v2;
  int v13 = t_im[BYTE1(v12) + 256] ^ t_im[v12] ^ t_im[BYTE2(v12) + 512] ^ t_im[HIBYTE(v12) + 768];
  a2[8] = v13;
  int v63 = t_im[((unsigned __int16)(v12 ^ v4) >> 8) + 256] ^ t_im[(v12 ^ v4)] ^ t_im[((v12 ^ v4) >> 16) + 512] ^ t_im[((v12 ^ v4) >> 24) + 768];
  a2[9] = v63;
  unsigned int v14 = v12 ^ v4 ^ v5;
  int v15 = t_im[BYTE1(v14) + 256] ^ t_im[v14] ^ t_im[BYTE2(v14) + 512] ^ t_im[HIBYTE(v14) + 768];
  a2[10] = v15;
  int v57 = v6;
  unsigned int v16 = (v14 ^ v6) >> 24;
  int v62 = t_im[((unsigned __int16)(v14 ^ v6) >> 8) + 256] ^ t_im[(v14 ^ v6)] ^ t_im[((v14 ^ v6) >> 16) + 512] ^ t_im[v16 + 768];
  a2[11] = v62;
  unsigned int v17 = t_fl[(v14 ^ v6)] ^ t_fl[((unsigned __int16)(v14 ^ v6) >> 8) + 256] ^ t_fl[((v14 ^ v6) >> 16) + 512] ^ t_fl[v16 + 768] ^ v7;
  LODWORD(v11) = t_im[BYTE1(v17) + 256] ^ t_im[(LOBYTE(t_fl[(v14 ^ v6)]) ^ LOBYTE(t_fl[((unsigned __int16)(v14 ^ v6) >> 8) + 256]) ^ LOBYTE(t_fl[((v14 ^ v6) >> 16) + 512]) ^ LOBYTE(t_fl[v16 + 768]) ^ v7)] ^ t_im[BYTE2(v17) + 512] ^ t_im[HIBYTE(v17) + 768];
  a2[12] = v11;
  LODWORD(v7) = v17 ^ v8;
  int v18 = t_im[((unsigned __int16)(v17 ^ v8) >> 8) + 256] ^ t_im[(v17 ^ v8)] ^ t_im[((v17 ^ v8) >> 16) + 512] ^ t_im[((v17 ^ v8) >> 24) + 768];
  a2[13] = v18;
  int v55 = v18;
  int v19 = t_im[((unsigned __int16)(v7 ^ v9) >> 8) + 256] ^ t_im[(v7 ^ v9)] ^ t_im[((v7 ^ v9) >> 16) + 512] ^ t_im[((v7 ^ v9) >> 24) + 768];
  a2[14] = v19;
  unsigned int v59 = v17 ^ v8 ^ v9 ^ v10;
  int v64 = t_im[BYTE1(v59) + 256] ^ t_im[(v17 ^ v8 ^ v9 ^ v10)] ^ t_im[BYTE2(v59) + 512] ^ t_im[HIBYTE(v59) + 768];
  a2[15] = v64;
  unsigned int v20 = t_fl[BYTE2(v59) + 256] ^ t_fl[BYTE1(v59)] ^ t_fl[HIBYTE(v59) + 512] ^ t_fl[(v17 ^ v8 ^ v9 ^ v10)
                                                                                 + 768] ^ 2;
  int v21 = t_im[v20] ^ t_im[BYTE1(v20) + 256] ^ t_im[BYTE2(v20) + 512] ^ t_im[HIBYTE(v20) + 768] ^ v13;
  int v61 = v20 ^ v60;
  a2[16] = v21;
  a2[17] = v21 ^ v63;
  unsigned int v22 = v61 ^ v6;
  int v56 = v21 ^ v63 ^ v15;
  a2[18] = v56;
  a2[19] = v56 ^ v62;
  int v23 = t_fl[(v61 ^ v6)];
  unsigned int v24 = t_fl[BYTE1(v22) + 256] ^ v23 ^ t_fl[BYTE2(v22) + 512] ^ t_fl[HIBYTE(v22) + 768];
  int v25 = t_im[(LOBYTE(t_fl[BYTE1(v22) + 256]) ^ v23 ^ LOBYTE(t_fl[BYTE2(v22) + 512]) ^ LOBYTE(t_fl[HIBYTE(v22) + 768]))] ^ t_im[BYTE1(v24) + 256] ^ t_im[BYTE2(v24) + 512] ^ t_im[HIBYTE(v24) + 768] ^ v11;
  a2[20] = v25;
  a2[21] = v25 ^ v18;
  int v26 = v25 ^ v18 ^ v19;
  a2[22] = v26;
  a2[23] = v26 ^ v64;
  unsigned int v58 = v24 ^ v8 ^ v10;
  LODWORD(v10) = t_fl[BYTE2(v58) + 256] ^ t_fl[BYTE1(v58)] ^ t_fl[HIBYTE(v58) + 512] ^ t_fl[v58 + 768] ^ 4;
  int v27 = v20 ^ v12 ^ v10;
  LODWORD(v10) = t_im[BYTE1(v10) + 256] ^ t_im[v10] ^ t_im[BYTE2(v10) + 512] ^ t_im[BYTE3(v10) + 768];
  int v28 = v10 ^ v21;
  int v29 = v10 ^ v63;
  a2[25] = v10 ^ v63;
  a2[26] = v10 ^ v63 ^ v56;
  a2[24] = v10 ^ v21;
  int v30 = v27 ^ v14;
  a2[27] = v10 ^ v63 ^ v62;
  LODWORD(v10) = t_fl[((unsigned __int16)(v27 ^ v14 ^ v22) >> 8) + 256] ^ t_fl[(v27 ^ v14 ^ v22)] ^ t_fl[((v30 ^ v22) >> 16) + 512] ^ t_fl[((v30 ^ v22) >> 24) + 768];
  int v31 = v24 ^ v17;
  int v32 = t_im[BYTE1(v10) + 256] ^ t_im[(LOBYTE(t_fl[((unsigned __int16)(v27 ^ v14 ^ v22) >> 8)
                                                                  + 256]) ^ LOBYTE(t_fl[(v27 ^ v14 ^ v22)]) ^ LOBYTE(t_fl[((v30 ^ v22) >> 16) + 512]) ^ LOBYTE(t_fl[((v30 ^ v22) >> 24) + 768]))] ^ t_im[BYTE2(v10) + 512] ^ t_im[BYTE3(v10) + 768];
  int v33 = v32 ^ v25;
  int v34 = v32 ^ v55;
  a2[28] = v33;
  a2[29] = v32 ^ v55;
  LODWORD(v10) = v31 ^ v7 ^ v9 ^ v58 ^ v10;
  int v35 = v32 ^ v55 ^ v64;
  a2[30] = v32 ^ v55 ^ v26;
  a2[31] = v35;
  unsigned int v36 = t_fl[BYTE2(v10) + 256] ^ t_fl[BYTE1(v10)] ^ t_fl[BYTE3(v10) + 512] ^ t_fl[v10 + 768] ^ 8;
  int v37 = t_im[(LOBYTE(t_fl[BYTE2(v10) + 256]) ^ LOBYTE(t_fl[BYTE1(v10)]) ^ LOBYTE(t_fl[BYTE3(v10) + 512]) ^ LOBYTE(t_fl[v10 + 768])) ^ 8] ^ t_im[BYTE1(v36) + 256] ^ t_im[BYTE2(v36) + 512] ^ t_im[HIBYTE(v36) + 768] ^ v28;
  a2[32] = v37;
  a2[33] = v37 ^ v29;
  unsigned int v38 = v36 ^ v57;
  a2[34] = v37 ^ v56;
  a2[35] = v37 ^ v56 ^ v29 ^ v62;
  LODWORD(v10) = t_fl[((unsigned __int16)(v36 ^ v57) >> 8) + 256] ^ t_fl[(v36 ^ v57)] ^ t_fl[((v36 ^ v57) >> 16) + 512] ^ t_fl[((v36 ^ v57) >> 24) + 768];
  int v39 = t_im[(LOBYTE(t_fl[BYTE1(v38) + 256]) ^ LOBYTE(t_fl[v38]) ^ LOBYTE(t_fl[BYTE2(v38) + 512]) ^ LOBYTE(t_fl[HIBYTE(v38) + 768]))] ^ t_im[BYTE1(v10) + 256] ^ t_im[BYTE2(v10) + 512] ^ t_im[BYTE3(v10) + 768] ^ v33;
  a2[36] = v39;
  a2[37] = v39 ^ v34;
  int v40 = v39 ^ v26;
  unsigned int v41 = v10 ^ v65;
  a2[38] = v39 ^ v26;
  a2[39] = v39 ^ v26 ^ v35;
  LODWORD(v10) = t_fl[((v10 ^ v65) >> 16) + 256] ^ t_fl[((unsigned __int16)(v10 ^ v65) >> 8)] ^ t_fl[((v10 ^ v65) >> 24) + 512] ^ t_fl[(v10 ^ v65) + 768] ^ 0x10;
  uint64_t result = v36 ^ v27 ^ v10;
  LODWORD(v10) = t_im[BYTE1(v10) + 256] ^ t_im[(LOBYTE(t_fl[BYTE2(v41) + 256]) ^ LOBYTE(t_fl[BYTE1(v41)]) ^ LOBYTE(t_fl[HIBYTE(v41) + 512]) ^ LOBYTE(t_fl[v41 + 768])) ^ 0x10] ^ t_im[BYTE2(v10) + 512] ^ t_im[BYTE3(v10) + 768];
  int v43 = v10 ^ v37;
  LODWORD(v8) = v10 ^ v29;
  a2[40] = v10 ^ v37;
  a2[41] = v10 ^ v29;
  int v44 = v10 ^ v29 ^ v37 ^ v56;
  LODWORD(v10) = v10 ^ v62;
  a2[42] = v44;
  a2[43] = v10;
  unsigned int v45 = t_fl[((unsigned __int16)(v38 ^ v30 ^ result) >> 8) + 256] ^ t_fl[(v38 ^ v30 ^ result)] ^ t_fl[((v38 ^ v30 ^ result) >> 16) + 512] ^ t_fl[((v38 ^ v30 ^ result) >> 24) + 768];
  int v46 = t_im[BYTE1(v45) + 256] ^ t_im[(LOBYTE(t_fl[((unsigned __int16)(v38 ^ v30 ^ result) >> 8)
                                                                  + 256]) ^ LOBYTE(t_fl[(v38 ^ v30 ^ result)]) ^ LOBYTE(t_fl[((v38 ^ v30 ^ result) >> 16) + 512]) ^ LOBYTE(t_fl[((v38 ^ v30 ^ result) >> 24) + 768]))] ^ t_im[BYTE2(v45) + 512] ^ t_im[HIBYTE(v45) + 768];
  int v47 = v46 ^ v39;
  int v48 = v46 ^ v34;
  a2[44] = v47;
  a2[45] = v48;
  LODWORD(v7) = v59 ^ v45;
  a2[46] = v48 ^ v40;
  a2[47] = v46 ^ v64;
  unsigned int v49 = t_fl[((v59 ^ v45) >> 16) + 256] ^ t_fl[((unsigned __int16)(v59 ^ v45) >> 8)] ^ t_fl[((v59 ^ v45) >> 24) + 512] ^ t_fl[(v59 ^ v45) + 768] ^ 0x20;
  int v50 = t_im[(LOBYTE(t_fl[BYTE2(v7) + 256]) ^ LOBYTE(t_fl[BYTE1(v7)]) ^ LOBYTE(t_fl[BYTE3(v7) + 512]) ^ LOBYTE(t_fl[v7 + 768])) ^ 0x20] ^ t_im[BYTE1(v49) + 256] ^ t_im[BYTE2(v49) + 512] ^ t_im[HIBYTE(v49) + 768] ^ v43;
  a2[48] = v50;
  a2[49] = v50 ^ v8;
  LODWORD(v8) = v36 ^ v61 ^ v49;
  int v51 = v50 ^ v37 ^ v56;
  unsigned int v52 = v8 ^ v36 ^ v57;
  a2[50] = v51;
  a2[51] = v51 ^ v10;
  LODWORD(v7) = t_fl[HIBYTE(v52) + 768];
  LODWORD(v10) = t_fl[((unsigned __int16)(v36 ^ v61 ^ v49 ^ v36 ^ v57) >> 8) + 256] ^ t_fl[(v36 ^ v61 ^ v49 ^ v36 ^ v57)] ^ t_fl[BYTE2(v52) + 512] ^ v7;
  int v53 = t_im[(LOBYTE(t_fl[BYTE1(v52) + 256]) ^ LOBYTE(t_fl[v52]) ^ LOBYTE(t_fl[BYTE2(v52) + 512]) ^ v7)] ^ t_im[BYTE1(v10) + 256] ^ t_im[BYTE2(v10) + 512] ^ t_im[BYTE3(v10) + 768] ^ v47;
  a2[52] = v53;
  a2[53] = v53 ^ v48;
  int v54 = v53 ^ v40;
  a2[54] = v54;
  a2[55] = v54 ^ v46 ^ v64;
  LODWORD(v10) = t_fl[((unsigned __int16)(v58 ^ v10) >> 8)] ^ t_fl[((v58 ^ v10) >> 16)
                                                                                  + 256] ^ t_fl[((v58 ^ v10) >> 24)
                                                                                              + 512] ^ t_fl[(v58 ^ v10) + 768] ^ v49 ^ 0x40;
  a2[56] = v10 ^ result;
  a2[57] = v10 ^ result ^ v8;
  a2[58] = v10 ^ v30;
  a2[59] = v10 ^ v30 ^ v52;
  a2[60] = 14;
  return result;
}

uint64_t ccaes_gladman_decrypt_key(int *a1, uint64_t a2, int *a3)
{
  uint64_t v3 = 4294967289;
  if (a2 <= 127)
  {
    if (a2 != 16)
    {
      if (a2 != 24)
      {
        if (a2 != 32) {
          return v3;
        }
        goto LABEL_10;
      }
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  switch(a2)
  {
    case 256:
LABEL_10:
      ccaes_gladman_decrypt_key256(a1, a3);
      return 0;
    case 192:
LABEL_11:
      ccaes_gladman_decrypt_key192(a1, a3);
      return 0;
    case 128:
LABEL_9:
      ccaes_gladman_decrypt_key128((unsigned int *)a1, (unsigned int *)a3);
      return 0;
  }
  return v3;
}

void *ccaes_ctr_crypt_mode()
{
  unint64_t v0 = ccaes_ecb_encrypt_mode();
  ccmode_factory_ctr_crypt(ctr_crypt, v0);
  return ctr_crypt;
}

void *ccdrbg_factory_nistctr(void *result, uint64_t a2)
{
  *uint64_t result = 88;
  result[1] = init_0;
  result[3] = generate_2;
  result[2] = reseed;
  result[4] = done;
  result[5] = a2;
  result[6] = must_reseed;
  return result;
}

uint64_t init_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, uint64_t a8)
{
  uint64_t v28 = *MEMORY[0x263EF8C08];
  unsigned int v12 = *(uint64_t **)(a1 + 40);
  cc_clear(0x58uLL, (void *)a2);
  uint64_t v18 = *v12;
  rsize_t v19 = v12[1];
  *(void *)(a2 + 56) = *v12;
  *(void *)(a2 + 64) = v19;
  *(_DWORD *)(a2 + 72) = *((_DWORD *)v12 + 4);
  uint64_t v20 = v12[3];
  *(void *)(a2 + 80) = v20;
  if (v19 >= 0x21 || *(void *)(v18 + 16) != 16) {
    cc_try_abort();
  }
  if (!v20)
  {
    if (v19 + 16 >= a7 && v19 + 16 == a3)
    {
      __memcpy_chk();
      for (; a7; --a7)
        __s[a7 - 1] ^= *(unsigned char *)(a8 - 1 + a7);
      goto LABEL_8;
    }
    uint64_t v21 = 4294967233;
LABEL_16:
    cc_clear(0x20uLL, (void *)a2);
    cc_clear(0x10uLL, (void *)(a2 + 32));
    uint64_t v23 = -1;
    goto LABEL_9;
  }
  uint64_t v21 = 4294967233;
  if ((unint64_t)(a3 - 65537) < 0xFFFFFFFFFFFF000FLL || a7 > 0x10000) {
    goto LABEL_16;
  }
  uint64_t v22 = derive(a2, __s, 3u, v13, v14, v15, v16, v17, a3);
  if (v22)
  {
    uint64_t v21 = v22;
    goto LABEL_16;
  }
  rsize_t v19 = *(void *)(a2 + 64);
LABEL_8:
  cc_clear(v19, (void *)a2);
  cc_clear(0x10uLL, (void *)(a2 + 32));
  update(a2, (uint64_t)__s);
  uint64_t v21 = 0;
  uint64_t v23 = 1;
LABEL_9:
  *(void *)(a2 + 48) = v23;
  cc_clear(0x30uLL, __s);
  return v21;
}

uint64_t generate_2(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v29 = *MEMORY[0x263EF8C08];
  uint64_t v8 = ccctr_context_size(*(void *)(a1 + 56));
  MEMORY[0x270FA53B0](v8, v9, v10, v11);
  uint64_t v18 = &v27[-v17 - 8];
  if (a2 > 0x10000) {
    goto LABEL_22;
  }
  if (*(_DWORD *)(a1 + 72) && *(void *)(a1 + 48) > 0x1000000000000uLL)
  {
    uint64_t v20 = 4294967234;
    goto LABEL_21;
  }
  if (!a4) {
    goto LABEL_12;
  }
  if (*(void *)(a1 + 80))
  {
    if (a4 <= 0x10000)
    {
      uint64_t v19 = derive(a1, __s, 1u, v12, v13, v14, v15, v16, a4);
      if (v19)
      {
        uint64_t v20 = v19;
        goto LABEL_21;
      }
      goto LABEL_11;
    }
LABEL_22:
    uint64_t v20 = 4294967233;
    goto LABEL_21;
  }
  if (*(void *)(a1 + 64) + 16 < a4) {
    goto LABEL_22;
  }
  cc_clear(0x30uLL, __s);
  __memcpy_chk();
LABEL_11:
  update(a1, (uint64_t)__s);
LABEL_12:
  uint64_t v26 = (uint64_t)&v26;
  inc_uint(a1 + 40, 8uLL);
  ccctr_init_internal(*(void *)(a1 + 56));
  for (uint64_t i = -(int)a2 & 0xFLL; a2; a2 -= v22)
  {
    if (a2 >= 0x80) {
      uint64_t v22 = 128;
    }
    else {
      uint64_t v22 = a2;
    }
    ccctr_update_internal(*(void *)(a1 + 56), (uint64_t)v18, v22, (uint64_t)&zeros, a3);
    a3 += v22;
  }
  ccctr_update_internal(*(void *)(a1 + 56), (uint64_t)v18, i, (uint64_t)&zeros, (uint64_t)v27);
  cc_clear(i, v27);
  if (a4) {
    uint64_t v23 = __s;
  }
  else {
    uint64_t v23 = &zeros;
  }
  update_with_ctr(a1, (uint64_t)v18, (uint64_t)v23);
  rsize_t v24 = ccctr_context_size(*(void *)(a1 + 56));
  cc_clear(v24, v18);
  uint64_t v20 = 0;
  ++*(void *)(a1 + 48);
LABEL_21:
  cc_clear(0x30uLL, __s);
  return v20;
}

uint64_t reseed(void *a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9 = a4;
  uint64_t v18 = *MEMORY[0x263EF8C08];
  if (!a1[10])
  {
    unint64_t v14 = a1[8] + 16;
    if (v14 < a4 || v14 != a2) {
      return 4294967233;
    }
    __memcpy_chk();
    for (; v9; --v9)
      __s[v9 - 1] ^= *(unsigned char *)(a5 - 1 + v9);
    goto LABEL_6;
  }
  uint64_t v11 = 4294967233;
  if (a2 <= 0x10000 && a4 <= 0x10000 && *(void *)(a1[7] + 16) <= a2)
  {
    uint64_t v12 = derive((uint64_t)a1, __s, 2u, a4, a5, a6, a7, a8, a2);
    if (v12)
    {
      uint64_t v11 = v12;
      goto LABEL_7;
    }
LABEL_6:
    update((uint64_t)a1, (uint64_t)__s);
    uint64_t v11 = 0;
    a1[6] = 1;
LABEL_7:
    cc_clear(a1[8] + 16, __s);
  }
  return v11;
}

uint64_t done(char *__s)
{
  cc_clear(0x20uLL, __s);
  uint64_t result = cc_clear(0x10uLL, __s + 32);
  *((void *)__s + 6) = -1;
  return result;
}

BOOL must_reseed(uint64_t a1)
{
  return *(_DWORD *)(a1 + 72) && *(void *)(a1 + 48) > 0x1000000000000uLL;
}

uint64_t derive(uint64_t a1, void *a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  v17[5] = *MEMORY[0x263EF8C08];
  uint64_t v15 = &a9;
  if (a3)
  {
    uint64_t v10 = a3;
    uint64_t v11 = v17;
    uint64_t v12 = a3;
    do
    {
      uint64_t v13 = v15;
      *uint64_t v11 = *v15;
      v15 += 2;
      *(v11 - 1) = v13[1];
      v11 += 2;
      --v12;
    }
    while (v12);
  }
  else
  {
    uint64_t v10 = 0;
  }
  return ccdrbg_df_derive_keys(*(uint64_t (***)(void))(a1 + 80), v10, (uint64_t)v16, *(void *)(a1 + 64) + 16, a2);
}

uint64_t update(uint64_t a1, uint64_t a2)
{
  v12[1] = *MEMORY[0x263EF8C08];
  uint64_t v4 = ccctr_context_size(*(void *)(a1 + 56));
  MEMORY[0x270FA53B0](v4, v5, v6, v7);
  unint64_t v9 = (char *)v12 - v8;
  inc_uint(a1 + 40, 8uLL);
  ccctr_init_internal(*(void *)(a1 + 56));
  update_with_ctr(a1, (uint64_t)v9, a2);
  rsize_t v10 = ccctr_context_size(*(void *)(a1 + 56));
  return cc_clear(v10, v9);
}

uint64_t update_with_ctr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  ccctr_update_internal(*(void *)(a1 + 56), a2, *(void *)(a1 + 64), a3, a1);
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = a3 + *(void *)(a1 + 64);

  return ccctr_update_internal(v6, a2, 16, v7, a1 + 32);
}

uint64_t ccrsa_get_fullkey_components(unint64_t *a1, uint64_t a2, unint64_t *a3, uint64_t a4, unint64_t *a5, uint64_t a6, unint64_t *a7, uint64_t a8, unint64_t *a9)
{
  BOOL v35 = timingsafe_enable_if_supported();
  unint64_t v16 = *a1;
  uint64_t v17 = ccrsa_ctx_private_zp(a1);
  unint64_t v18 = cczp_n(v17);
  uint64_t v19 = ccrsa_ctx_private_zp(a1);
  uint64_t v20 = (unint64_t *)cczp_prime(v19);
  unint64_t v21 = ccn_write_uint_size_public_value(v18, v20);
  if (v21 > *a7) {
    goto LABEL_5;
  }
  *a7 = v21;
  ccn_write_uint_internal(v18, v20, v21, a6);
  uint64_t v22 = ccrsa_ctx_private_zp(a1);
  uint64_t v23 = (void *)ccrsa_ctx_private_zp(a1);
  unint64_t v24 = cczp_n(v22 + 16 * *v23 + 32);
  uint64_t v25 = ccrsa_ctx_private_zp(a1);
  uint64_t v26 = (void *)ccrsa_ctx_private_zp(a1);
  int v27 = (unint64_t *)cczp_prime(v25 + 16 * *v26 + 32);
  unint64_t v28 = ccn_write_uint_size_public_value(v24, v27);
  if (v28 > *a9) {
    goto LABEL_5;
  }
  *a9 = v28;
  ccn_write_uint_internal(v24, v27, v28, a8);
  unint64_t v29 = ccn_write_uint_size_public_value(v16, a1 + 3);
  if (v29 <= *a3
    && (*a3 = v29,
        ccn_write_uint_internal(v16, a1 + 3, v29, a2),
        int v30 = &a1[3 * *a1 + 4],
        unint64_t v31 = ccn_write_uint_size_public_value(v16, v30),
        v31 <= *a5))
  {
    *a5 = v31;
    ccn_write_uint_internal(v16, v30, v31, a4);
    uint64_t v32 = 0;
  }
  else
  {
LABEL_5:
    uint64_t v32 = 0xFFFFFFFFLL;
  }
  cc_disable_dit_with_sb((unsigned int *)&v35);
  return v32;
}

uint64_t ccrsa_emsa_pkcs1v15_verify_canary_out(unint64_t a1, unsigned char *a2, unint64_t a3, char *a4, uint64_t a5, void *a6)
{
  *a6 = 0;
  a6[1] = 0;
  if (a5)
  {
    uint64_t v9 = *(unsigned __int8 *)(a5 + 1);
    uint64_t v10 = a3 + v9 + 10;
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = a3;
  }
  if (v10 + 11 > a1) {
    return 4294967273;
  }
  uint64_t v12 = a2 + 2;
  char v13 = a2[1] ^ 1 | *a2;
  if (a1 - v10 != 3)
  {
    uint64_t v14 = v10 - a1 + 3;
    do
    {
      char v15 = *v12++;
      v13 |= ~v15;
    }
    while (!__CFADD__(v14++, 1));
    uint64_t v12 = &a2[~v10 + a1];
  }
  uint64_t v17 = v12 + 1;
  char v18 = *v12 | v13;
  if (a5)
  {
    char v19 = v12[1] ^ 0x30;
    char v20 = v12[2] ^ (v10 - 2);
    char v21 = v12[3] ^ 0x30;
    uint64_t v22 = v12 + 5;
    char v23 = v12[4] ^ (v9 + 4);
    uint64_t v24 = v9 + 2;
    char v25 = cc_cmp_safe_internal(v9 + 2, v12 + 5, (char *)a5);
    uint64_t v26 = &v22[v24];
    char v27 = v22[v24] ^ 5;
    char v28 = v22[v24 + 1];
    char v29 = v22[v24 + 2] ^ 4;
    uint64_t v17 = &v22[v24 + 4];
    v18 |= v19 | v20 | v21 | v23 | v25 | v27 | v28 | v29 | v26[3] ^ a3;
  }
  cc_fault_canary_set((uint64_t)a6, (uint64_t)&CCRSA_PKCS1_FAULT_CANARY, a3, (uint64_t)a4, (uint64_t)v17);
  return (v18 | cc_cmp_safe_internal(a3, v17, a4));
}

uint64_t ccrsa_emsa_pkcs1v15_verify(unint64_t a1, unsigned char *a2, unint64_t a3, char *a4, uint64_t a5)
{
  void v13[2] = *MEMORY[0x263EF8C08];
  BOOL v12 = timingsafe_enable_if_supported();
  v13[0] = 0xAAAAAAAAAAAAAAAALL;
  v13[1] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v10 = ccrsa_emsa_pkcs1v15_verify_canary_out(a1, a2, a3, a4, a5, v13);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccentropy_rng_init(void *a1, uint64_t a2)
{
  BOOL v5 = timingsafe_enable_if_supported();
  *a1 = &entropy_rng_info;
  a1[1] = a2;
  cc_disable_dit_with_sb((unsigned int *)&v5);
  return 0;
}

uint64_t ccentropy_rng_get_seed(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 8))();
}

uint64_t ccrng_crypto_generate(uint64_t a1, rsize_t a2, char *a3)
{
  uint64_t v30 = *MEMORY[0x263EF8C08];
  if (!a2) {
    return 0;
  }
  rsize_t v6 = a2;
  uint64_t v7 = a3;
  while (1)
  {
    uint64_t v8 = *(os_unfair_lock_s **)(a1 + 24);
    if (v8)
    {
      os_unfair_lock_lock(v8);
      uint64_t v9 = *(const os_unfair_lock **)(a1 + 24);
      if (v9) {
        os_unfair_lock_assert_owner(v9);
      }
    }
    rsize_t v10 = *(void *)(a1 + 56);
    int v11 = ccrng_schedule_read(*(void *)(a1 + 16));
    if (v11 == 1) {
      goto LABEL_13;
    }
    int v12 = v11;
    uint64_t seed = ccentropy_get_seed(*(uint64_t (****)(void, uint64_t, uint64_t))(a1 + 8), v10, (uint64_t)__s);
    if (seed == -10) {
      break;
    }
    uint64_t v14 = seed;
    if (seed) {
      goto LABEL_40;
    }
    uint64_t v15 = drbg_reseed((void *)a1, v10, (uint64_t)__s, 0, 0);
    if (v15)
    {
      uint64_t v14 = v15;
LABEL_40:
      cc_clear(v10, __s);
      goto LABEL_36;
    }
    ccrng_schedule_notify_reseed(*(unsigned char **)(a1 + 16));
    cc_clear(v10, __s);
LABEL_13:
    if (v6 >= *(void *)(a1 + 48)) {
      unint64_t v16 = *(void *)(a1 + 48);
    }
    else {
      unint64_t v16 = v6;
    }
    uint64_t v17 = *(const os_unfair_lock **)(a1 + 24);
    if (v17) {
      os_unfair_lock_assert_owner(v17);
    }
    if (a2 <= 0xB && (unint64_t v18 = *(void *)(a1 + 64), v18 >= v16))
    {
      uint64_t v21 = *(void *)(a1 + 72);
      uint64_t v22 = *(void *)(a1 + 80);
      char v23 = (void *)(v21 + v22);
      uint64_t v24 = v21 + v18;
      unint64_t v25 = v24 - (v21 + v22);
      if (v25 >= v16) {
        size_t v26 = v16;
      }
      else {
        size_t v26 = v24 - (v21 + v22);
      }
      memcpy(v7, (const void *)(v21 + v22), v26);
      cc_clear(v26, v23);
      *(void *)(a1 + 80) += v26;
      if (v25 < v16)
      {
        uint64_t v19 = drbg_generate((void *)a1, *(void *)(a1 + 64), *(void *)(a1 + 72));
        if (v19)
        {
LABEL_41:
          uint64_t v14 = v19;
          goto LABEL_36;
        }
        memcpy(&v7[v26], *(const void **)(a1 + 72), v16 - v26);
        cc_clear(v16 - v26, *(void **)(a1 + 72));
        *(void *)(a1 + 80) = v16 - v26;
      }
    }
    else
    {
      uint64_t v19 = drbg_generate((void *)a1, v16, (uint64_t)v7);
      if (v19) {
        goto LABEL_41;
      }
    }
    char v20 = *(os_unfair_lock_s **)(a1 + 24);
    if (v20) {
      os_unfair_lock_unlock(v20);
    }
    v7 += v16;
    v6 -= v16;
    if (!v6) {
      return 0;
    }
  }
  if (v12 == 2) {
    goto LABEL_13;
  }
  if (v12 == 3) {
    uint64_t v14 = 4294967134;
  }
  else {
    uint64_t v14 = 0xFFFFFFFFLL;
  }
LABEL_36:
  char v28 = *(os_unfair_lock_s **)(a1 + 24);
  if (v28) {
    os_unfair_lock_unlock(v28);
  }
  cc_clear(a2, a3);
  return v14;
}

uint64_t drbg_reseed(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  rsize_t v10 = (const os_unfair_lock *)a1[3];
  if (v10) {
    os_unfair_lock_assert_owner(v10);
  }
  uint64_t result = ccdrbg_reseed(a1[4], a1[5], a2, a3, a4, a5);
  if (!result) {
    a1[10] = a1[8];
  }
  return result;
}

uint64_t ccrng_crypto_init(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a8 > 0x40) {
    return 4294967291;
  }
  uint64_t result = 0;
  *a1 = generate_3;
  a1[1] = a2;
  a1[2] = a3;
  a1[3] = a4;
  a1[4] = a5;
  a1[5] = a6;
  a1[6] = a7;
  a1[7] = a8;
  a1[8] = a9;
  a1[9] = a10;
  a1[10] = a9;
  return result;
}

uint64_t drbg_generate(void *a1, uint64_t a2, uint64_t a3)
{
  rsize_t v6 = (const os_unfair_lock *)a1[3];
  if (v6) {
    os_unfair_lock_assert_owner(v6);
  }
  uint64_t v7 = a1[4];
  uint64_t v8 = a1[5];

  return ccdrbg_generate(v7, v8, a2, a3, 0, 0);
}

uint64_t sizeof_struct_cche_cipher_plain_ctx()
{
  return 32;
}

uint64_t sizeof_struct_cche_galois_key()
{
  return 16;
}

uint64_t cche_secret_key_sizeof(uint64_t a1)
{
  uint64_t v1 = cche_param_ctx_chain_const(a1);
  unint64_t v2 = (*(_DWORD *)(v1 + 12) * *(_DWORD *)(v1 + 8))
     + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3);
  return v2 * sizeof_struct_ccpolyzp_po2cyc();
}

unint64_t cche_ciphertext_sizeof(uint64_t a1, int a2, unsigned int a3)
{
  BOOL v5 = (unsigned int *)cche_param_ctx_chain_const(a1);
  uint64_t v6 = *v5;
  unint64_t v7 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
  if (v6 >= 0x80) {
    uint64_t v8 = 128;
  }
  else {
    uint64_t v8 = v6;
  }
  uint64_t v9 = &v5[2
         * (v7 + 2 * (v6 + ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v8) + 6)
         * (v5[1] - a2)];
  unint64_t v10 = sizeof_struct_ccpolyzp_po2cyc();
  return 8 * ((v10 + 23) / v10 + (v9[3] * v9[2] + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3)) * a3);
}

unint64_t cche_plaintext_sizeof(uint64_t a1)
{
  uint64_t v1 = cche_param_ctx_plaintext_ctx(a1);
  return (sizeof_struct_ccpolyzp_po2cyc() + 8 * v1[1] * *v1 + 7) & 0xFFFFFFFFFFFFFFF8;
}

unint64_t cche_dcrt_plaintext_sizeof(uint64_t a1, int a2)
{
  int v3 = cche_param_ctx_polynomial_degree(a1);
  return (sizeof_struct_ccpolyzp_po2cyc() + 8 * (v3 * a2) + 7) & 0xFFFFFFFFFFFFFFF8;
}

uint64_t cche_rng_seed_sizeof()
{
  return 32;
}

unint64_t cche_galois_key_sizeof(uint64_t a1, unsigned int a2)
{
  return 8 * cche_galois_key_nof_n(a1, a2);
}

unint64_t cche_relin_key_sizeof(uint64_t a1)
{
  return 8 * cche_relin_key_nof_n(a1);
}

uint64_t ccz_cmpi(uint64_t a1, unsigned int a2)
{
  v8[1] = *MEMORY[0x263EF8C08];
  BOOL v7 = timingsafe_enable_if_supported();
  v8[0] = a2;
  v6[0] = ccn_n(1uLL, (uint64_t)v8);
  v6[1] = 0;
  v6[2] = 1;
  v6[3] = v8;
  uint64_t v4 = ccz_cmp(a1, (uint64_t)v6);
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return v4;
}

uint64_t ccec_validate_point_and_projectify_ws(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *a2;
  uint64_t v9 = cczp_prime((uint64_t)a2);
  if ((int)ccn_cmp_internal(v8, v9, a4) < 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = *a2;
  uint64_t v11 = a4 + 8 * *a2;
  uint64_t v12 = cczp_prime((uint64_t)a2);
  if ((int)ccn_cmp_internal(v10, v12, v11) < 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = ccec_projectify_ws(a1, (uint64_t)a2);
  if (!result)
  {
    if (ccec_is_point_ws(a1, a2, a3)) {
      return 0;
    }
    else {
      return 4294967289;
    }
  }
  return result;
}

void *ccmode_factory_cfb_decrypt(void *result, void *a2)
{
  *uint64_t result = ((2 * a2[1] + 14) & 0xFFFFFFFFFFFFFFF0) + ((*a2 + 7) & 0xFFFFFFFFFFFFFFF8) + 16;
  result[1] = 1;
  result[2] = ccmode_cfb_init;
  result[3] = ccmode_cfb_decrypt;
  result[4] = a2;
  return result;
}

void *ccsrp_gp_rfc5054_3072()
{
  return &_ccsrp_gp_rfc5054_3072;
}

uint64_t ccmode_cbc_encrypt(uint64_t *a1, char *a2, uint64_t a3, uint64_t a4, char *a5)
{
  if (a3)
  {
    uint64_t v6 = a3;
    uint64_t v8 = a1 + 1;
    uint64_t v9 = *a1;
    size_t v10 = *(void *)(*a1 + 8);
    for (uint64_t i = a2; ; uint64_t i = v12)
    {
      uint64_t v12 = a5;
      if (v10)
      {
        char v13 = i - 1;
        do
        {
          a5[v10 - 1] = v13[v10] ^ *(unsigned char *)(a4 - 1 + v10);
          --v10;
        }
        while (v10);
      }
      (*(void (**)(uint64_t *, uint64_t, char *, char *))(v9 + 24))(v8, 1, a5, a5);
      size_t v10 = *(void *)(v9 + 8);
      if (!--v6) {
        break;
      }
      a4 += v10;
      a5 = &v12[v10];
    }
    memcpy(a2, v12, v10);
  }
  return 0;
}

uint64_t ltc_des_ecb_decrypt(uint64_t a1, uint64_t a2, unsigned int *a3, _DWORD *a4)
{
  uint64_t v14 = *MEMORY[0x263EF8C08];
  if (a2)
  {
    uint64_t v6 = a2;
    uint64_t v7 = a1 + 128;
    do
    {
      --v6;
      unsigned int v8 = *a3;
      unsigned int v9 = a3[1];
      a3 += 2;
      unsigned int v12 = bswap32(v8);
      unsigned int v13 = bswap32(v9);
      desfunc(&v12, v7);
      unsigned int v10 = bswap32(v13);
      *a4 = bswap32(v12);
      a4[1] = v10;
      a4 += 2;
    }
    while (v6);
  }
  return 0;
}

uint64_t ccmode_ccm_finalize(uint64_t a1, uint64_t a2, void *__dst)
{
  if (*(_DWORD *)(a2 + 64) == 1) {
    return 4294967228;
  }
  if (*(_DWORD *)(a2 + 72)) {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 24))(a1 + 8, 1, a2 + 16, a2 + 16);
  }
  for (uint64_t i = *(void *)(*(void *)a1 + 8); i; --i)
    *(unsigned char *)(a2 + i + 31) ^= *(unsigned char *)(a2 + i + 15);
  memcpy(__dst, (const void *)(a2 + 32), *(void *)(a2 + 88));
  return 0;
}

void *ccaes_cfb8_encrypt_mode()
{
  unint64_t v0 = ccaes_ecb_encrypt_mode();
  ccmode_factory_cfb8_encrypt(cfb8_aes_encrypt, v0);
  return cfb8_aes_encrypt;
}

uint64_t ccmode_cfb8_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *__src)
{
  uint64_t v8 = *(void *)(a1 + 32);
  *(void *)a2 = v8;
  size_t v9 = *(void *)(v8 + 8);
  size_t v10 = a2 + ((v9 + 7) & 0xFFFFFFFFFFFFFFF8);
  size_t v11 = v10 + 8;
  if (__src) {
    memcpy((void *)(v10 + 8), __src, v9);
  }
  else {
    cc_clear(*(void *)(v8 + 8), (void *)(v10 + 8));
  }
  uint64_t v12 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t))(v8 + 16))(v8, a2 + 8 + ((2 * *(void *)(*(void *)a2 + 8) + 14) & 0xFFFFFFFFFFFFFFF0), a3, a4);
  (*(void (**)(unint64_t, uint64_t, size_t, uint64_t))(v8 + 24))(a2 + 8 + ((2 * *(void *)(*(void *)a2 + 8) + 14) & 0xFFFFFFFFFFFFFFF0), 1, v11, a2 + 8);
  return v12;
}

uint64_t cche_crt_composer_init_ws(uint64_t a1, unint64_t *a2, unint64_t a3, uint64_t a4)
{
  v20[1] = *MEMORY[0x263EF8C08];
  *a2 = a3;
  if (a3)
  {
    unint64_t v8 = 0;
    size_t v9 = a2 + 8;
    unsigned int v10 = 1;
    unint64_t v11 = 1;
    do
    {
      unint64_t v12 = sizeof_struct_ccpolyzp_po2cyc();
      unsigned int v13 = &v9[((v12 + 15) / v12 + 6) * v8];
      *unsigned int v13 = *(void *)(a4 + 8 * v8);
      unint64_t v14 = *(void *)(a4 + 8 * v8);
      if (!is_mul_ok(v14, v11)) {
        return 0xFFFFFFFFLL;
      }
      uint64_t result = ccpolyzp_po2cyc_modulus_to_cczp_ws(a1, v13 + 2, v14);
      if (result) {
        return result;
      }
      v11 *= v14;
      unint64_t v8 = v10++;
    }
    while (v8 < a3);
    uint64_t result = ccpolyzp_po2cyc_modulus_to_cczp_ws(a1, a2 + 2, v11);
    if (!result)
    {
      uint64_t v16 = 0;
      a2[1] = v11;
      while (1)
      {
        unint64_t v17 = sizeof_struct_ccpolyzp_po2cyc();
        unint64_t v18 = &v9[((v17 + 15) / v17 + 6) * v16];
        v20[0] = v11 / *(void *)(a4 + 8 * v16);
        cczp_modn_ws(a1, v18 + 2, &v19, 1, (char *)v20);
        uint64_t result = cczp_inv_ws(a1, (uint64_t)(v18 + 2));
        if (result) {
          break;
        }
        cczp_mul_ws(a1, (uint64_t)(a2 + 2));
        if (a3 <= ++v16) {
          return 0;
        }
      }
    }
  }
  else
  {
    uint64_t result = ccpolyzp_po2cyc_modulus_to_cczp_ws(a1, a2 + 2, 1uLL);
    if (!result) {
      a2[1] = 1;
    }
  }
  return result;
}

uint64_t cche_crt_composer_compose_ws(uint64_t a1, unint64_t *a2, uint64_t a3, void *__dst, uint64_t *__src)
{
  BOOL v5 = __src;
  if (*a2 == 1)
  {
    memcpy(__dst, __src, 8 * a3);
    return 0;
  }
  else
  {
    uint64_t v11 = *(void *)cczp_prime((uint64_t)(a2 + 2));
    long long v31 = 0u;
    long long v32 = 0u;
    long long v30 = 0u;
    unsigned int inited = ccrns_modulus_init_var_time_ws(a1, (unint64_t *)&v30, v11);
    if (inited) {
      BOOL v12 = 1;
    }
    else {
      BOOL v12 = a3 == 0;
    }
    if (!v12)
    {
      uint64_t v13 = 0;
      uint64_t v14 = 8 * a3;
      uint64_t v28 = a3;
      char v29 = __dst;
      do
      {
        if (*a2)
        {
          unint64_t v15 = 0;
          uint64_t v16 = 0;
          unint64_t v17 = v5;
          do
          {
            unint64_t v18 = sizeof_struct_ccpolyzp_po2cyc();
            uint64_t v19 = (uint64_t *)&a2[((v18 + 15) / v18 + 6) * v15 + 8];
            uint64_t v20 = ccpolyzp_po2cyc_centered_to_rem(*v17, *v19);
            uint64_t v21 = v19[1];
            uint64_t v22 = v21 * v20;
            unint64_t v23 = ((unint64_t)v21 * (unsigned __int128)(unint64_t)v20) >> 64;
            BOOL v24 = __CFADD__(((unint64_t)v22 * (unsigned __int128)(unint64_t)v31) >> 64, v23 * v31);
            uint64_t v25 = v22
                - (v24
                 + __CFADD__(v22 * *((void *)&v31 + 1), (__PAIR128__(v23, v22) * (unint64_t)v31) >> 64)
                 + ((v23 * (unsigned __int128)(unint64_t)v31) >> 64)
                 + *((void *)&v31 + 1) * v23
                 + (((unint64_t)v22 * (unsigned __int128)*((unint64_t *)&v31 + 1)) >> 64))
                * v30;
            if (v25 - (uint64_t)v30 >= 0) {
              v25 -= v30;
            }
            uint64_t v26 = v25 + v16;
            if (v26 - v11 >= 0) {
              uint64_t v16 = v26 - v11;
            }
            else {
              uint64_t v16 = v26;
            }
            ++v15;
            unint64_t v17 = (uint64_t *)((char *)v17 + v14);
          }
          while (v15 < *a2);
        }
        else
        {
          uint64_t v16 = 0;
        }
        v29[v13++] = ccpolyzp_po2cyc_rem_to_centered(v16, a2[1]);
        ++v5;
      }
      while (v13 != v28);
    }
    return inited;
  }
}

uint64_t cche_crt_compose_ws(uint64_t a1, uint64_t a2, void *a3, uint64_t *a4, unint64_t a5, uint64_t a6)
{
  uint64_t v13 = *(void *)(a1 + 16);
  BOOL v12 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 24);
  uint64_t v14 = a5;
  unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
  uint64_t v16 = (unint64_t *)v12(a1, (v15 + 15) / v15 + 6 + ((v15 + 15) / v15 + 6) * v14);
  uint64_t result = cche_crt_composer_init_ws(a1, v16, a5, a6);
  if (!result) {
    uint64_t result = cche_crt_composer_compose_ws(a1, v16, a2, a3, a4);
  }
  *(void *)(a1 + 16) = v13;
  return result;
}

uint64_t cche_crt_compose(uint64_t a1, void *a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  BOOL v17 = timingsafe_enable_if_supported();
  unint64_t v10 = sizeof_struct_ccpolyzp_po2cyc();
  uint64_t v11 = a4 + 1;
  v15[0] = cc_malloc_clear(8 * v11 * ((v10 + 15) / v10 + 6) + 72);
  unint64_t v12 = sizeof_struct_ccpolyzp_po2cyc();
  v15[1] = ((v12 + 15) / v12 + 6) * v11 + 9;
  void v15[2] = 0;
  v15[3] = cc_ws_alloc;
  uint64_t v16 = cc_ws_free;
  if (v15[0])
  {
    uint64_t v13 = cche_crt_compose_ws((uint64_t)v15, a1, a2, a3, a4, a5);
    v16((uint64_t)v15);
  }
  else
  {
    uint64_t v13 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v17);
  return v13;
}

uint64_t ccmode_siv_reset(void *a1)
{
  v4[2] = *MEMORY[0x263EF8C08];
  unint64_t v2 = *(void **)(*a1 + 56);
  if (v2[1] != 16) {
    return 4294967226;
  }
  v4[0] = 0;
  v4[1] = 0;
  cccmac_one_shot_generate_internal(v2, a1[1] >> 1, (uint64_t)(a1 + 3), 0x10uLL, (char *)v4, 0x10uLL, a1 + 11);
  uint64_t result = 0;
  a1[2] = 2;
  return result;
}

uint64_t ccsha3_384_c_compress(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return cckeccak_absorb_blocks(a1, 0x68uLL, a2, a3, cckeccak_f1600_c);
}

uint64_t ccsha3_384_c_final(unint64_t *a1, uint64_t a2, void *a3)
{
  return ccsha3_final(a1, a2, a3, cckeccak_f1600_c);
}

void *ccsha3_384_di()
{
  return &ccsha3_384_c_di;
}

uint64_t fipspost_post_shake(char a1)
{
  uint64_t v16 = *MEMORY[0x263EF8C08];
  v15[0] = xmmword_2373BA2E8;
  v15[1] = unk_2373BA2F8;
  v14[0] = xmmword_2373BA308;
  v14[1] = unk_2373BA318;
  v13[0] = xmmword_2373BA328;
  v13[1] = unk_2373BA338;
  v12[0] = xmmword_2373BA348;
  v12[1] = unk_2373BA358;
  unint64_t v9 = 0xA3A3A3A3A3A3A3A3;
  *(void *)&long long v1 = 0xA3A3A3A3A3A3A3A3;
  *((void *)&v1 + 1) = 0xA3A3A3A3A3A3A3A3;
  v8[10] = v1;
  v8[11] = v1;
  v8[8] = v1;
  unsigned char v8[9] = v1;
  v8[6] = v1;
  v8[7] = v1;
  v8[4] = v1;
  v8[5] = v1;
  void v8[2] = v1;
  v8[3] = v1;
  v8[0] = v1;
  v8[1] = v1;
  if ((a1 & 0x10) != 0)
  {
    LOBYTE(v15[0]) = 66;
    LOBYTE(v14[0]) = -86;
    LOBYTE(v13[0]) = 69;
    LOBYTE(v12[0]) = 107;
  }
  ccshake128(0, (char *)v8, 0x200uLL, v10);
  if (cc_cmp_safe(32, v11, (char *)v15))
  {
    uint64_t v2 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: SHAKE128, 0-bit message failed\n", v2, "fipspost_post_shake", 62);
    uint64_t v3 = 4294967221;
  }
  else
  {
    uint64_t v3 = 0;
  }
  ccshake256(0, (char *)v8, 0x200uLL, v10);
  if (cc_cmp_safe(32, v11, (char *)v14))
  {
    uint64_t v4 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: SHAKE256, 0-bit message failed\n", v4, "fipspost_post_shake", 68);
    uint64_t v3 = 4294967221;
  }
  ccshake128(0xC8uLL, (char *)v8, 0x200uLL, v10);
  if (cc_cmp_safe(32, v11, (char *)v13))
  {
    uint64_t v5 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: SHAKE128, 1600-bit message failed\n", v5, "fipspost_post_shake", 74);
    uint64_t v3 = 4294967221;
  }
  ccshake256(0xC8uLL, (char *)v8, 0x200uLL, v10);
  if (cc_cmp_safe(32, v11, (char *)v12))
  {
    uint64_t v6 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: SHAKE256, 1600-bit message failed\n", v6, "fipspost_post_shake", 80);
    return 4294967221;
  }
  return v3;
}

uint64_t ccvrf_irtf_ed25519_hash2curve_elligator2(uint64_t a1, uint64_t a2, char *a3, size_t a4, uint64_t a5)
{
  uint64_t v22 = *MEMORY[0x263EF8C08];
  char __src = 4;
  char v17 = 1;
  uint64_t v9 = ccvrf_irtf_ed25519_point_to_string(v21, a2);
  MEMORY[0x270FA53B0](v9, v10, v11, v12);
  uint64_t v14 = &v16[-v13];
  ccdigest_init_internal(a1, &v16[-v13]);
  ccdigest_update_internal((unint64_t *)a1, v14, 1uLL, &__src);
  ccdigest_update_internal((unint64_t *)a1, v14, 1uLL, &v17);
  ccdigest_update_internal((unint64_t *)a1, v14, 0x20uLL, v21);
  ccdigest_update_internal((unint64_t *)a1, v14, a4, a3);
  (*(void (**)(uint64_t, void *, long long *))(a1 + 56))(a1, v14, &v19);
  v20 &= ~0x80u;
  return ge_from_uniform(a5, &v19);
}

uint64_t ccmode_gcm_encrypt(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a1 + 96);
  ccmode_gcm_aad_finalize(a1);
  if (*(_WORD *)(a1 + 80) != 3) {
    return 4294967228;
  }
  uint64_t v9 = *(void *)(a1 + 96);
  uint64_t result = 4294967229;
  if (!__CFADD__(v9, a2) && v9 + a2 <= 0xFFFFFFFE0)
  {
    unsigned int v11 = v8 & 0xF;
    if ((v8 & 0xF) != 0)
    {
      uint64_t v12 = 16 - v11;
      if (a2 < v12)
      {
LABEL_18:
        if (!a2) {
          return 0;
        }
        uint64_t v18 = v11;
        uint64_t v19 = a4 - 1;
        uint64_t v20 = a1 + v11 + 63;
        unint64_t v21 = a2;
        do
        {
          *(unsigned char *)(v19 + v21) = *(unsigned char *)(v20 + v21) ^ *(unsigned char *)(a3 - 1 + v21);
          --v21;
        }
        while (v21);
        uint64_t v22 = v18 + a1 + 15;
        unint64_t v23 = a2;
        do
        {
          *(unsigned char *)(v22 + v23) ^= *(unsigned char *)(v19 + v23);
          --v23;
        }
        while (v23);
        uint64_t result = 0;
        *(void *)(a1 + 96) += a2;
        return result;
      }
      uint64_t v13 = a4 - 1;
      uint64_t v14 = 16 - v11;
      do
      {
        *(unsigned char *)(v13 + v14) = *(unsigned char *)((v8 & 0xF) + a1 + 63 + v14) ^ *(unsigned char *)(a3 - 1 + v14);
        --v14;
      }
      while (v14);
      uint64_t v15 = 16 - v11;
      do
      {
        *(unsigned char *)((v8 & 0xF) + a1 + 15 + v15) ^= *(unsigned char *)(v13 + v15);
        --v15;
      }
      while (v15);
      ccmode_gcm_mult_h(a1, a1 + 16);
      a2 -= v12;
      a3 += v12;
      a4 += v12;
      *(void *)(a1 + 96) += v12;
      ccmode_gcm_update_pad(a1);
    }
    if (a2 >= 0x10)
    {
      do
      {
        for (uint64_t i = 0; i != -16; --i)
          *(unsigned char *)(a4 + i + 15) = *(unsigned char *)(a1 + i + 79) ^ *(unsigned char *)(a3 + i + 15);
        for (uint64_t j = 0; j != -16; --j)
          *(unsigned char *)(a1 + j + 31) ^= *(unsigned char *)(a4 + j + 15);
        ccmode_gcm_mult_h(a1, a1 + 16);
        a2 -= 16;
        a3 += 16;
        a4 += 16;
        *(void *)(a1 + 96) += 16;
        ccmode_gcm_update_pad(a1);
      }
      while (a2 > 0xF);
    }
    unsigned int v11 = 0;
    goto LABEL_18;
  }
  return result;
}

uint64_t ccec_mult_blinded_ws(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (**a6)(void, uint64_t, unint64_t *))
{
  v17[1] = *MEMORY[0x263EF8C08];
  unint64_t v10 = *a2;
  unint64_t v11 = ccn_bitlen_internal(*a2, a4);
  if (v11 > cczp_bitlen((uint64_t)a2)) {
    return 4294967289;
  }
  v17[0] = 1;
  if (a6)
  {
    uint64_t result = (*a6)(a6, 8, v17);
    if (result) {
      return result;
    }
    unint64_t v13 = v17[0] | 0x80000000;
  }
  else
  {
    unint64_t v13 = 2147483649;
  }
  v17[0] = v13;
  uint64_t v14 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, unint64_t))(a1 + 24))(a1, 3 * v10);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v10);
  ccn_mux_seed_mask(v17[0]);
  v17[0] = LODWORD(v17[0]);
  uint64_t result = ccec_mult_ws(a1, (uint64_t)a2);
  if (!result)
  {
    ccn_divmod_ws(a1, v10, a4, v10, v15, 1uLL, v16, v17);
    cczp_bitlen((uint64_t)a2);
    uint64_t result = ccec_mult_ws(a1, (uint64_t)a2);
    if (!result)
    {
      uint64_t result = ccec_mult_ws(a1, (uint64_t)a2);
      if (!result)
      {
        ccec_full_add_ws(a1, (uint64_t)a2);
        uint64_t result = 0;
      }
    }
  }
  *(void *)(a1 + 16) = v14;
  return result;
}

uint64_t ccec_mult_blinded(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (**a5)(void, uint64_t, unint64_t *))
{
  BOOL v16 = timingsafe_enable_if_supported();
  unint64_t v10 = cc_malloc_clear(184 * *a1);
  uint64_t v11 = 23 * *a1;
  v14[0] = v10;
  v14[1] = v11;
  _OWORD v14[2] = 0;
  void v14[3] = cc_ws_alloc;
  uint64_t v15 = cc_ws_free;
  if (v10)
  {
    uint64_t v12 = ccec_mult_blinded_ws((uint64_t)v14, a1, a2, a3, a4, a5);
    v15((uint64_t)v14);
  }
  else
  {
    uint64_t v12 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v12;
}

uint64_t ccn_cmp_public_value(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  if (a1)
  {
    unint64_t v3 = 0;
    uint64_t v4 = 0;
    do
    {
      unint64_t v6 = *a2++;
      unint64_t v5 = v6;
      uint64_t v8 = *a3++;
      uint64_t v7 = v8;
      if (v8 != v5)
      {
        unint64_t v3 = v5;
        uint64_t v4 = v7;
      }
      --a1;
    }
    while (a1);
  }
  else
  {
    uint64_t v4 = 0;
    unint64_t v3 = 0;
  }
  return (v3 != v4) - (((((v3 - v4) ^ v3 | v3 ^ v4) ^ v3) >> 62) & 2);
}

uint64_t ccn_cmp(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t v6 = ccn_cmp_public_value(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return v6;
}

unint64_t ccsae_verify_confirmation(void *a1, uint64_t a2, char *a3)
{
  BOOL v11 = timingsafe_enable_if_supported();
  uint64_t v6 = (void *)*a1;
  v9[0] = cc_malloc_clear(8 * *(void *)*a1);
  v9[1] = *v6;
  void v9[2] = 0;
  void v9[3] = cc_ws_alloc;
  unint64_t v10 = cc_ws_free;
  if (v9[0])
  {
    unint64_t v7 = ccsae_verify_confirmation_ws((uint64_t)v9, (uint64_t)a1, a2, a3);
    v10((uint64_t)v9);
  }
  else
  {
    unint64_t v7 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v11);
  return v7;
}

unint64_t ccsae_verify_confirmation_ws(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v25 = *MEMORY[0x263EF8C08];
  int v4 = *(unsigned __int8 *)(a2 + 24);
  if (v4 != CCSAE_STATE_COMMIT_BOTH && v4 != CCSAE_STATE_CONFIRMATION_GENERATED) {
    return 4294967210;
  }
  unint64_t v10 = **(void **)a2;
  uint64_t v11 = cczp_bitlen(*(void *)a2);
  uint64_t v23 = (uint64_t)&v23;
  unint64_t v12 = (unint64_t)(v11 + 7) >> 3;
  unint64_t v13 = *(uint64_t **)(a2 + 16);
  MEMORY[0x270FA53B0](v11, v14, v15, v16);
  uint64_t v18 = &v24[-v17 - 8];
  uint64_t v19 = *(void *)(a1 + 16);
  uint64_t v20 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v10);
  size_t v21 = ccsae_sizeof_kck_internal(a2);
  cchmac_init_internal((uint64_t)v13, v18, v21, (char *)(a2 + 48));
  cchmac_update_internal(v13, v18, 2, a3);
  ccn_write_uint_padded_internal(v10, (unint64_t *)(a2 + 144 + 16 * **(void **)a2), v12, v20);
  cchmac_update_internal(v13, v18, v12, v20);
  ccn_write_uint_padded_internal(v10, (unint64_t *)(a2 + 144 + 56 * **(void **)a2), v12, v20);
  cchmac_update_internal(v13, v18, v12, v20);
  ccn_write_uint_padded_internal(v10, (unint64_t *)(a2 + 144 + (**(void **)a2 << 6)), v12, v20);
  cchmac_update_internal(v13, v18, v12, v20);
  ccn_write_uint_padded_internal(v10, (unint64_t *)(a2 + 144 + 24 * **(void **)a2), v12, v20);
  cchmac_update_internal(v13, v18, v12, v20);
  ccn_write_uint_padded_internal(v10, (unint64_t *)(a2 + 144 + 40 * **(void **)a2), v12, v20);
  cchmac_update_internal(v13, v18, v12, v20);
  ccn_write_uint_padded_internal(v10, (unint64_t *)(a2 + 144 + 48 * **(void **)a2), v12, v20);
  cchmac_update_internal(v13, v18, v12, v20);
  cchmac_final_internal((uint64_t)v13, v18, (uint64_t)v24);
  cc_clear(((v13[1] + v13[2] + 19) & 0xFFFFFFFFFFFFFFF8) + v13[1], v18);
  *(unsigned char *)(a2 + 24) |= CCSAE_STATE_CONFIRMATION_VERIFIED;
  *(void *)(a1 + 16) = v19;
  return cc_cmp_safe_internal(*v13, v24, a4);
}

uint64_t ccdh_compute_shared_secret_ws(uint64_t a1, void *a2, void *a3, unint64_t *a4, uint64_t a5, uint64_t (**a6)(void, uint64_t, uint64_t *))
{
  unint64_t v12 = (void *)*a2;
  unint64_t v13 = ccdh_gp_n(*a2);
  if (*a4 < (unint64_t)(cczp_bitlen((uint64_t)v12) + 7) >> 3) {
    return 4294967244;
  }
  uint64_t v15 = *(void *)(a1 + 16);
  uint64_t v16 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v13);
  uint64_t result = ccdh_check_pub_ws(a1, v12, a3);
  if (!result)
  {
    uint64_t v20 = a5;
    unint64_t v17 = cczp_bitlen((uint64_t)v12);
    uint64_t v18 = ccdh_gp_n(*a2);
    uint64_t result = ccdh_power_blinded_ws(a1, a6, v12, v16, a3 + 2, v17, (uint64_t)&a2[v18 + 2]);
    if (!result)
    {
      if (ccdh_valid_shared_secret(v13, v16, (uint64_t)v12))
      {
        unint64_t v19 = ccn_write_uint_size_public_value(v13, (unint64_t *)v16);
        *a4 = v19;
        ccn_write_uint_internal(v13, v16, v19, v20);
        uint64_t result = 0;
      }
      else
      {
        *a4 = 0;
        uint64_t result = 4294967244;
      }
    }
  }
  *(void *)(a1 + 16) = v15;
  return result;
}

uint64_t ccdh_compute_shared_secret(void *a1, void *a2, unint64_t *a3, uint64_t a4, uint64_t (**a5)(void, uint64_t, uint64_t *))
{
  BOOL v18 = timingsafe_enable_if_supported();
  uint64_t v10 = *a1;
  uint64_t v11 = ccdh_gp_n(*a1);
  uint64_t v12 = CCDH_POWER_BLINDED_WORKSPACE_N(v11);
  v16[0] = cc_malloc_clear(8 * (v12 + v11));
  uint64_t v13 = ccdh_gp_n(v10);
  v16[1] = CCDH_POWER_BLINDED_WORKSPACE_N(v13) + v13;
  _OWORD v16[2] = 0;
  v16[3] = cc_ws_alloc;
  unint64_t v17 = cc_ws_free;
  if (v16[0])
  {
    uint64_t v14 = ccdh_compute_shared_secret_ws((uint64_t)v16, a1, a2, a3, a4, a5);
    v17((uint64_t)v16);
  }
  else
  {
    uint64_t v14 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return v14;
}

uint64_t ccn_sub_ws(uint64_t a1, uint64_t a2, void *a3, uint64_t *a4, unint64_t *a5)
{
  if (!a2) {
    return 0;
  }
  uint64_t v5 = 0;
  do
  {
    uint64_t v7 = *a4++;
    uint64_t v6 = v7;
    unint64_t v9 = *a5++;
    unint64_t v8 = v9;
    BOOL v10 = __CFADD__(v5, v6);
    unint64_t v11 = v5 + v6;
    if (v10) {
      ++v5;
    }
    unsigned long long v12 = __PAIR128__(v5, v11) - v8;
    *a3++ = v12;
    uint64_t v5 = *((uint64_t *)&v12 + 1) >> 63;
    --a2;
  }
  while (a2);
  return *((void *)&v12 + 1) >> 63;
}

uint64_t ccn_sub(uint64_t a1, void *a2, uint64_t *a3, unint64_t *a4)
{
  BOOL v20 = timingsafe_enable_if_supported();
  v18[0] = xmmword_26EA47890;
  v18[1] = unk_26EA478A0;
  unint64_t v19 = off_26EA478B0;
  if (a1)
  {
    uint64_t v8 = 0;
    do
    {
      uint64_t v10 = *a3++;
      uint64_t v9 = v10;
      unint64_t v12 = *a4++;
      unint64_t v11 = v12;
      BOOL v13 = __CFADD__(v8, v9);
      unint64_t v14 = v8 + v9;
      if (v13) {
        ++v8;
      }
      unsigned long long v15 = __PAIR128__(v8, v14) - v11;
      *a2++ = v15;
      uint64_t v8 = *((uint64_t *)&v15 + 1) >> 63;
      --a1;
    }
    while (a1);
    uint64_t v16 = *((void *)&v15 + 1) >> 63;
  }
  else
  {
    uint64_t v16 = 0;
  }
  cc_ws_free_null(v18);
  cc_disable_dit_with_sb((unsigned int *)&v20);
  return v16;
}

uint64_t ccz_set_bit(void *a1, unint64_t a2, unsigned int a3)
{
  BOOL v10 = timingsafe_enable_if_supported();
  if (ccz_n((uint64_t)a1) <= a2 >> 6)
  {
    ccz_set_capacity((uint64_t)a1, (a2 >> 6) + 1);
    uint64_t v6 = (a2 >> 6) + 1 - ccz_n((uint64_t)a1);
    uint64_t v7 = a1[3];
    uint64_t v8 = ccz_n((uint64_t)a1);
    ccn_zero(v6, (void *)(v7 + 8 * v8));
    ccz_set_n(a1, (a2 >> 6) + 1);
  }
  ccn_set_bit(a1[3], a2, a3);
  return cc_disable_dit_with_sb((unsigned int *)&v10);
}

uint64_t ccder_sizeof_octet_string(unint64_t a1, unint64_t *a2)
{
  return ccder_sizeof_implicit_octet_string(4, a1, a2);
}

uint64_t ccn_abs(uint64_t a1, uint64_t *a2, uint64_t *a3, unint64_t *a4)
{
  uint64_t v6 = ccn_sub_ws(0, a1, a2, a3, a4);
  ccn_cond_neg(a1, v6, a2, a2);
  return v6;
}

uint64_t CCPOLYZP_PO2CYC_BASE_CONVERT_INIT_WORKSPACE_N(unsigned int a1)
{
  return 2 * a1 + 10;
}

uint64_t ccpolyzp_po2cyc_base_convert_init_ws(uint64_t a1, uint64_t *a2, char *a3, _DWORD *a4)
{
  v115[1] = *MEMORY[0x263EF8C08];
  if (*(_DWORD *)a3 != *a4) {
    return 4294967289;
  }
  int v4 = a4;
  uint64_t v5 = a3;
  uint64_t v6 = a2;
  *a2 = (uint64_t)a3;
  a2[1] = (uint64_t)a4;
  uint64_t v8 = *((unsigned int *)a3 + 1);
  int v109 = a4[1];
  uint64_t v104 = *(void *)(a1 + 16);
  uint64_t v9 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8 + 1);
  uint64_t v108 = a1;
  unint64_t v105 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8 + 1);
  int v107 = v4;
  uint64_t v110 = v8;
  if (v8)
  {
    uint64_t v10 = 0;
    uint64_t v106 = v6 + 12;
    while (1)
    {
      uint64_t v11 = v10;
      ccn_seti(v110, v9, 1);
      unint64_t v12 = 0;
      ++v10;
      do
      {
        uint64_t v13 = v10;
        if (v12 != v11)
        {
          unint64_t v14 = (*((_DWORD *)v5 + 1) - 1);
          unsigned long long v15 = v5;
          if (v12 < v14)
          {
            unsigned long long v15 = v5;
            do
            {
              unsigned long long v15 = (char *)*((void *)v15 + 14);
              LODWORD(v14) = v14 - 1;
            }
            while (v14 > v12);
          }
          uint64_t v13 = v12 + 1;
          ccn_muln(v12 + 1, v105, v9, 1uLL, (unint64_t *)v15 + 18);
          ccn_set(v13, v9, v105);
        }
        unint64_t v12 = v13;
      }
      while (v13 != v110);
      if (v109) {
        break;
      }
LABEL_20:
      if (v10 == v110) {
        goto LABEL_21;
      }
    }
    unsigned int v16 = 0;
    while (1)
    {
      uint64_t v17 = v10;
      BOOL v18 = v5;
      unsigned int v19 = v4[1] - 1;
      BOOL v20 = v4;
      size_t v21 = v4;
      if (v19 > v16)
      {
        unsigned int v22 = v4[1] - 1;
        BOOL v20 = v4;
        do
        {
          BOOL v20 = (_DWORD *)*((void *)v20 + 14);
          --v22;
        }
        while (v22 > v16);
        size_t v21 = v4;
        do
        {
          size_t v21 = (_DWORD *)*((void *)v21 + 14);
          --v19;
        }
        while (v19 > v16);
      }
      uint64_t v23 = v20 + 30;
      uint64_t v24 = *((void *)v21 + 2);
      uint64_t v25 = v6;
      uint64_t v26 = v11 + *(_DWORD *)(*v6 + 4) * v16;
      char v27 = &v106[((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v26];
      v115[0] = 0;
      cczp_modn_ws(v108, v23, v115, v110, (char *)v9);
      int v4 = v107;
      uint64_t v28 = v27;
      uint64_t v6 = v25;
      uint64_t v5 = v18;
      if (ccrns_mul_modulus_init_ws(v108, v28, v24, v115[0])) {
        break;
      }
      uint64_t v10 = v17;
      if (++v16 == v109) {
        goto LABEL_20;
      }
    }
  }
LABEL_21:
  *(void *)(v108 + 16) = v104;
  uint64_t v29 = *v6;
  uint64_t v30 = *(unsigned int *)(*v6 + 4);
  if (!v30)
  {
LABEL_45:
    uint64_t v57 = v6[1];
    int v58 = *(_DWORD *)(v57 + 4);
    while (--v58)
      uint64_t v57 = *(void *)(v57 + 112);
    int v59 = *(_DWORD *)(*v6 + 4);
    uint64_t v60 = *(void *)(v57 + 16);
    if (v59)
    {
      unsigned int v61 = 0;
      unint64_t v62 = *(void *)(v57 + 32);
      unint64_t v63 = *(void *)(v57 + 40);
      unint64_t v64 = 1;
      int v65 = v107;
      do
      {
        uint64_t v66 = *v6;
        if (v59 - 1 > v61)
        {
          unsigned int v67 = v59 - 1;
          uint64_t v66 = *v6;
          do
          {
            uint64_t v66 = *(void *)(v66 + 112);
            --v67;
          }
          while (v67 > v61);
        }
        unint64_t v68 = *(void *)(v66 + 16);
        unint64_t v69 = v68 * v64;
        unint64_t v70 = (v68 * (unsigned __int128)v64) >> 64;
        BOOL v71 = __CFADD__((v69 * (unsigned __int128)v62) >> 64, v70 * v62);
        unint64_t v72 = v69
            - (v71
             + __CFADD__(v69 * v63, (__PAIR128__(v70, v69) * v62) >> 64)
             + ((v70 * (unsigned __int128)v62) >> 64)
             + v63 * v70
             + ((v69 * (unsigned __int128)v63) >> 64))
            * v60;
        if ((uint64_t)(v72 - v60) >= 0) {
          unint64_t v64 = v72 - v60;
        }
        else {
          unint64_t v64 = v72;
        }
        ++v61;
      }
      while (v61 != v59);
    }
    else
    {
      unint64_t v64 = 1;
      int v65 = v107;
    }
    uint64_t result = ccrns_mul_modulus_init_ws(v108, v6 + 2, v60, v64);
    if (result) {
      return result;
    }
    int v73 = *((_DWORD *)v5 + 1);
    if (!v73)
    {
LABEL_70:
      unint64_t v114 = 0x1FFFFFFFFFFFFFFFLL;
      unint64_t v77 = v65;
      int v78 = v65[1] - 1;
      if (v65[1] != 1)
      {
        unint64_t v77 = v65;
        do
        {
          unint64_t v77 = (void *)v77[14];
          --v78;
        }
        while (v78);
      }
      cczp_modn_ws(v108, v77 + 15, v6 + 5, 1, (char *)&v114);
      uint64_t result = cczp_inv_field_ws(v108, (uint64_t)(v77 + 15), v6 + 6, v6 + 5);
      if (!result)
      {
        uint64_t result = ccpolyzp_po2cyc_base_convert_neg_q_inv_mod_t_ws(v108, v6 + 7, v6, 0);
        if (!result)
        {
          if (v65[1] < 2u
            || (uint64_t result = ccpolyzp_po2cyc_base_convert_neg_q_inv_mod_t_ws(v108, v6 + 8, v6, 1u), !result))
          {
            cczp_modn_ws(v108, v77 + 15, (uint64_t *)&v113, 1, v5 + 144);
            uint64_t result = cczp_inv_field_ws(v108, (uint64_t)(v77 + 15), &v113, &v113);
            if (!result)
            {
              uint64_t v79 = (unsigned __int8 *)cczp_prime((uint64_t)(v77 + 15));
              v115[0] = 0;
              ccn_read_uint_public_value(1uLL, v115, 8uLL, v79);
              uint64_t result = ccrns_mul_modulus_init_var_time_ws(v108, v6 + 9, bswap64(v115[0]), v113);
              if (!result)
              {
                LODWORD(v80) = *((_DWORD *)v5 + 1) - 1;
                if (*((_DWORD *)v5 + 1) == 1)
                {
LABEL_94:
                  ccn_mul_ws(v108, 1uLL, v112, v77 + 18, &v114);
                  LODWORD(v97) = *((_DWORD *)v5 + 1);
                  if (v97)
                  {
                    unint64_t v98 = 0;
                    do
                    {
                      uint64_t v99 = v5;
                      if (v98 < (v97 - 1))
                      {
                        unsigned int v100 = v97 - 2;
                        uint64_t v99 = v5;
                        do
                        {
                          uint64_t v99 = (char *)*((void *)v99 + 14);
                          BOOL v43 = v98 >= v100--;
                        }
                        while (!v43);
                      }
                      cczp_modn_ws(v108, (void *)v99 + 15, &v111, 2, v112);
                      uint64_t v101 = v111;
                      uint64_t v102 = *v6;
                      uint64_t v103 = sizeof_struct_ccrns_mul_modulus();
                      v6[((unint64_t)(v103 + 7) >> 3)
                       * (*(_DWORD *)(v6[1] + 4) * *(_DWORD *)(v102 + 4))
                       + 12
                       + ((unint64_t)(v103 + 7) >> 3) * *(unsigned int *)(v102 + 4)
                       + v98++] = v101;
                      unint64_t v97 = *((unsigned int *)v5 + 1);
                    }
                    while (v98 < v97);
                  }
                  return 0;
                }
                else
                {
                  unint64_t v81 = 0;
                  unint64_t v82 = *((void *)v5 + 2);
                  BOOL v83 = v6 + 12;
                  while (1)
                  {
                    unsigned int v84 = v80 - 1;
                    unsigned int v85 = v84;
                    unint64_t v86 = v5;
                    do
                    {
                      unint64_t v86 = (char *)*((void *)v86 + 14);
                      BOOL v43 = v81 >= v85--;
                    }
                    while (!v43);
                    unsigned int v87 = v5;
                    do
                    {
                      unsigned int v87 = (char *)*((void *)v87 + 14);
                      BOOL v43 = v81 >= v84--;
                    }
                    while (!v43);
                    uint64_t v88 = *v6;
                    uint64_t v89 = sizeof_struct_ccrns_mul_modulus();
                    unint64_t v90 = &v83[((unint64_t)(v89 + 7) >> 3)
                             * (*(_DWORD *)(v6[1] + 4) * *(_DWORD *)(v88 + 4))
                             + ((unint64_t)(v89 + 7) >> 3) * *(unsigned int *)(v88 + 4)
                             + *(unsigned int *)(v88 + 4)
                             + ((unint64_t)(v89 + 7) >> 3) * v81];
                    uint64_t v91 = *((void *)v87 + 2);
                    uint64_t v92 = v82 - v91 * ((*((unint64_t *)v87 + 3) * (unsigned __int128)v82) >> 64);
                    unint64_t v93 = v92 - v91 >= 0
                        ? v92 - v91
                        : v82 - v91 * ((*((unint64_t *)v87 + 3) * (unsigned __int128)v82) >> 64);
                    uint64_t result = ccrns_mul_modulus_init_var_time_ws(v108, v90, v91, v93);
                    if (result) {
                      break;
                    }
                    v115[0] = v93;
                    uint64_t result = cczp_inv_field_ws(v108, (uint64_t)(v86 + 120), v115, v115);
                    if (result) {
                      break;
                    }
                    unint64_t v94 = v115[0];
                    uint64_t v95 = *v6;
                    unint64_t v96 = (unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3;
                    uint64_t result = ccrns_mul_modulus_init_var_time_ws(v108, &v83[v96 * (*(_DWORD *)(v6[1] + 4) * *(_DWORD *)(v95 + 4))+ v96 * *(unsigned int *)(v95 + 4)+ *(unsigned int *)(v95 + 4)+ v96 * (*(_DWORD *)(v95 + 4) - 1)+ v96 * v81], *((void *)v87 + 2), v94);
                    if (result) {
                      break;
                    }
                    ++v81;
                    unint64_t v80 = (*((_DWORD *)v5 + 1) - 1);
                    if (v81 >= v80) {
                      goto LABEL_94;
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
    unsigned int v74 = 0;
    while (1)
    {
      int v75 = v5;
      if (v73 - 1 > v74)
      {
        unsigned int v76 = v73 - 1;
        int v75 = v5;
        do
        {
          int v75 = (char *)*((void *)v75 + 14);
          --v76;
        }
        while (v76 > v74);
      }
      if (*((void *)v75 + 2) == 0x1FFFFFFFFFFFFFFFLL) {
        return 4294967289;
      }
      if (++v74 == v73) {
        goto LABEL_70;
      }
    }
  }
  unint64_t v31 = 0;
  while (1)
  {
    int v32 = *(_DWORD *)(v29 + 4);
    unint64_t v33 = (v32 - 1);
    uint64_t v34 = v29;
    BOOL v35 = (void *)v29;
    if (v31 < v33)
    {
      unsigned int v36 = v32 - 1;
      uint64_t v34 = v29;
      do
      {
        uint64_t v34 = *(void *)(v34 + 112);
        --v36;
      }
      while (v36 > v31);
      unsigned int v37 = v32 - 1;
      BOOL v35 = (void *)v29;
      do
      {
        BOOL v35 = (void *)v35[14];
        --v37;
      }
      while (v37 > v31);
    }
    unint64_t v38 = 0;
    unsigned int v39 = v32 - 2;
    uint64_t v40 = 1;
    do
    {
      if (v31 != v38)
      {
        uint64_t v41 = v29;
        if (v38 < v33)
        {
          unsigned int v42 = v39;
          uint64_t v41 = v29;
          do
          {
            uint64_t v41 = *(void *)(v41 + 112);
            BOOL v43 = v38 >= v42--;
          }
          while (!v43);
        }
        uint64_t v44 = v35[2];
        unint64_t v45 = *(void *)(v41 + 16)
            - v44 * (((unint64_t)v35[3] * (unsigned __int128)*(unint64_t *)(v41 + 16)) >> 64);
        if ((uint64_t)(v45 - v44) >= 0) {
          v45 -= v44;
        }
        uint64_t v46 = v45 * v40;
        unint64_t v47 = (v45 * (unsigned __int128)(unint64_t)v40) >> 64;
        unint64_t v48 = v35[4];
        uint64_t v49 = ((unint64_t)v46 * (unsigned __int128)v48) >> 64;
        uint64_t v50 = (v47 * (unsigned __int128)v48) >> 64;
        uint64_t v51 = v47 * v48;
        BOOL v43 = __CFADD__(v49, v51);
        uint64_t v52 = v49 + v51;
        uint64_t v53 = v43;
        uint64_t v40 = v46
            - (v53
             + __CFADD__(v46 * v35[5], v52)
             + v50
             + v35[5] * v47
             + (((unint64_t)v46 * (unsigned __int128)(unint64_t)v35[5]) >> 64))
            * v44;
        if (v40 - v44 >= 0) {
          v40 -= v44;
        }
      }
      ++v38;
    }
    while (v38 != v30);
    v115[0] = v40;
    uint64_t result = cczp_inv_field_ws(v108, v34 + 120, v115, v115);
    if (result) {
      return result;
    }
    uint64_t v55 = *v6;
    uint64_t v56 = sizeof_struct_ccrns_mul_modulus();
    uint64_t result = ccrns_mul_modulus_init_var_time_ws(v108, &v6[((unint64_t)(v56 + 7) >> 3) * (*(_DWORD *)(v6[1] + 4) * *(_DWORD *)(v55 + 4))+ 12+ ((unint64_t)(v56 + 7) >> 3) * v31], v35[2], v115[0]);
    if (result) {
      return result;
    }
    if (++v31 == v30) {
      goto LABEL_45;
    }
  }
}

uint64_t ccpolyzp_po2cyc_base_convert_neg_q_inv_mod_t_ws(uint64_t a1, void *a2, uint64_t *a3, unsigned int a4)
{
  v17[1] = *MEMORY[0x263EF8C08];
  uint64_t v7 = *a3;
  uint64_t v6 = a3[1];
  int v8 = *(_DWORD *)(v6 + 4);
  while (--v8 > a4)
    uint64_t v6 = *(void *)(v6 + 112);
  uint64_t v9 = (void *)(v6 + 120);
  ccn_seti(1, a2, 1);
  unsigned int v10 = *(_DWORD *)(v7 + 4);
  if (v10)
  {
    for (unsigned int i = 0; i < v10; ++i)
    {
      unsigned int v12 = v10 - 1;
      uint64_t v13 = v7;
      if (v12 > i)
      {
        uint64_t v13 = v7;
        do
        {
          uint64_t v13 = *(void *)(v13 + 112);
          --v12;
        }
        while (v12 > i);
      }
      unint64_t v14 = (char *)cczp_prime(v13 + 120);
      cczp_modn_ws(a1, v9, v17, 1, v14);
      cczp_mul_ws(a1, (uint64_t)v9);
      unsigned int v10 = *(_DWORD *)(v7 + 4);
    }
  }
  uint64_t v15 = cczp_inv_field_ws(a1, (uint64_t)v9, a2, a2);
  if (!v15) {
    cczp_negate((uint64_t)v9, a2, a2);
  }
  return v15;
}

uint64_t ccpolyzp_po2cyc_base_convert_poly_ws(uint64_t a1, uint64_t *a2, uint64_t *a3, void *a4)
{
  uint64_t v51 = *MEMORY[0x263EF8C08];
  uint64_t v7 = (unsigned int *)*a3;
  if (!ccpolyzp_po2cyc_ctx_eq(*a3, (_DWORD *)*a4)) {
    return 4294967289;
  }
  uint64_t v8 = *a2;
  if (!ccpolyzp_po2cyc_ctx_eq(*a2, (_DWORD *)a4[1])) {
    return 4294967289;
  }
  unsigned int v9 = *v7;
  if (!*v7) {
    return 0;
  }
  int v10 = 0;
  uint64_t v11 = a2 + 1;
  unsigned int v12 = *(_DWORD *)(v8 + 4);
  unsigned int v13 = v12;
  uint64_t v43 = v8;
  uint64_t v44 = a2;
  unsigned int v42 = a2 + 1;
  while (!v13)
  {
LABEL_26:
    if (++v10 >= v9) {
      return 0;
    }
  }
  unsigned int v14 = 0;
  while (1)
  {
    unsigned int v15 = v13 - 1;
    unsigned int v16 = (void *)v8;
    if (v13 - 1 > v14)
    {
      unsigned int v16 = (void *)v8;
      do
      {
        unsigned int v16 = (void *)v16[14];
        --v15;
      }
      while (v15 > v14);
    }
    uint64_t v49 = 0;
    unint64_t v50 = 0;
    if (v7[1]) {
      break;
    }
    unint64_t v30 = 0;
    uint64_t v29 = 0;
LABEL_19:
    unint64_t v31 = v16[4];
    uint64_t v32 = (v31 * (unsigned __int128)(unint64_t)v29) >> 64;
    uint64_t v33 = v31 * v30;
    uint64_t v34 = (v31 * (unsigned __int128)v30) >> 64;
    BOOL v35 = __CFADD__(v32, v33);
    uint64_t v36 = v32 + v33;
    uint64_t v37 = v35;
    uint64_t v38 = v37
        + __CFADD__(v16[5] * v29, v36)
        + v34
        + v16[5] * v30
        + (((unint64_t)v16[5] * (unsigned __int128)(unint64_t)v29) >> 64);
    uint64_t v39 = v16[2];
    uint64_t v40 = v29 - v38 * v39;
    if (v40 - v39 >= 0) {
      v40 -= v39;
    }
    v11[v10 + *(_DWORD *)*a2 * v14++] = v40;
    unsigned int v13 = v12;
    if (v14 >= v12)
    {
      unsigned int v9 = *v7;
      unsigned int v13 = v12;
      goto LABEL_26;
    }
  }
  uint64_t v17 = 0;
  while (1)
  {
    int v18 = *(_DWORD *)(*a4 + 4);
    unint64_t v19 = (unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3;
    unint64_t v20 = v19 * (v17 + v14 * v18);
    uint64_t v21 = a3[(v10 + *(_DWORD *)*a3 * v17) + 1];
    unsigned int v22 = &a4[v19 * (*(_DWORD *)(a4[1] + 4) * v18) + 12 + v19 * v17];
    uint64_t v23 = v22[1];
    uint64_t v24 = ((unint64_t)v22[2] * (unsigned __int128)(unint64_t)v21) >> 64;
    uint64_t v25 = *v22;
    uint64_t v26 = v23 * v21 - v25 * v24;
    uint64_t v27 = v26 - v25;
    unint64_t v28 = v27 >= 0 ? v27 : v26;
    unint64_t v47 = a4[v20 + 13];
    unint64_t v48 = v28;
    ccn_mul_ws(a1, 1uLL, (char *)v46, &v48, &v47);
    if (ccn_add_ws(a1, 2, &v49, &v49, v46)) {
      return 0xFFFFFFFFLL;
    }
    if (++v17 >= (unint64_t)v7[1])
    {
      uint64_t v29 = v49;
      unint64_t v30 = v50;
      uint64_t v8 = v43;
      a2 = v44;
      unsigned int v12 = *(_DWORD *)(v43 + 4);
      uint64_t v11 = v42;
      goto LABEL_19;
    }
  }
}

uint64_t CCPOLYZP_PO2CYC_BASE_CONVERT_EXACT_POLY_WORKSPACE_N(uint64_t a1)
{
  return a1 & 0x1FFFFFFFFFFFFFFFLL;
}

uint64_t ccpolyzp_po2cyc_base_convert_exact_poly_ws(uint64_t a1, uint64_t *a2, uint64_t *a3, void *a4)
{
  uint64_t v7 = (unsigned int *)*a3;
  if (!ccpolyzp_po2cyc_ctx_eq(*a3, (_DWORD *)*a4)) {
    return 4294967289;
  }
  uint64_t v8 = *a2;
  uint64_t v9 = a4[1];
  int v10 = *(_DWORD *)(v9 + 4);
  while (--v10)
    uint64_t v9 = *(void *)(v9 + 112);
  if (!ccpolyzp_po2cyc_ctx_eq(*a2, (_DWORD *)v9)) {
    return 4294967289;
  }
  int v11 = *(_DWORD *)(v8 + 4) - 1;
  if (*(_DWORD *)(v8 + 4) != 1)
  {
    do
    {
      uint64_t v8 = *(void *)(v8 + 112);
      --v11;
    }
    while (v11);
  }
  uint64_t v12 = *v7;
  uint64_t v38 = *(void *)(a1 + 16);
  unsigned int v13 = (double *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  cc_clear(8 * v12, v13);
  uint64_t v14 = *v7;
  uint64_t v15 = v7[1];
  if (v15)
  {
    unint64_t v16 = 0;
    uint64_t v39 = (*(_DWORD *)(a4[1] + 4) * *(_DWORD *)(*a4 + 4));
    do
    {
      uint64_t v17 = v7;
      if (v16 < (v15 - 1))
      {
        unsigned int v18 = v15 - 2;
        uint64_t v17 = v7;
        do
          uint64_t v17 = (unsigned int *)*((void *)v17 + 14);
        while (v16 < v18--);
      }
      uint64_t v20 = sizeof_struct_ccrns_mul_modulus();
      if (v14)
      {
        unint64_t v21 = (unint64_t)(v20 + 7) >> 3;
        unsigned int v22 = &a4[v21 * v16 + 12];
        uint64_t v23 = a2 + 1;
        uint64_t v24 = &v22[v21 * v39];
        unsigned int v25 = *(_DWORD *)*a3 * v16;
        uint64_t v26 = v14;
        uint64_t v27 = v13;
        do
        {
          unint64_t v28 = v24[1] * a3[v25 + 1]
              - *v24 * (((unint64_t)v24[2] * (unsigned __int128)(unint64_t)a3[v25 + 1]) >> 64);
          if ((uint64_t)(v28 - *v24) >= 0) {
            v28 -= *v24;
          }
          *uint64_t v27 = *v27 + (double)v28 / (double)*((unint64_t *)v17 + 2);
          uint64_t v29 = v28 * v22[1] - *v22 * ((v28 * (unsigned __int128)(unint64_t)v22[2]) >> 64);
          if (v29 - *v22 >= 0) {
            v29 -= *v22;
          }
          if (v16) {
            uint64_t v30 = *v23;
          }
          else {
            uint64_t v30 = 0;
          }
          uint64_t v31 = *(void *)(v8 + 16);
          uint64_t v32 = v30 + v29;
          if (v32 - v31 >= 0) {
            v32 -= v31;
          }
          *v23++ = v32;
          ++v27;
          ++v25;
          --v26;
        }
        while (v26);
      }
      ++v16;
    }
    while (v16 != v15);
  }
  if (v14)
  {
    uint64_t v33 = a2 + 1;
    do
    {
      double v34 = *v13++;
      uint64_t v35 = a4[2];
      uint64_t v36 = a4[3] * (unint64_t)(v34 + 0.5)
          - v35 * (((unint64_t)(v34 + 0.5) * (unsigned __int128)(unint64_t)a4[4]) >> 64);
      if (v36 - v35 >= 0) {
        v36 -= v35;
      }
      *uint64_t v33 = (*(void *)(v8 + 16) & ((*v33 - v36) >> 63)) + *v33 - v36;
      ++v33;
      --v14;
    }
    while (v14);
  }
  uint64_t result = 0;
  *(void *)(a1 + 16) = v38;
  return result;
}

unint64_t CCPOLYZP_PO2CYC_BASE_CONVERT_DIVIDE_AND_ROUND_WORKSPACE_N(int a1, int a2)
{
  return (2 * a1)
       + (unint64_t)(a2 * a1)
       + 2 * ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3)
       + 18;
}

uint64_t ccpolyzp_po2cyc_base_convert_divide_and_round_ws(uint64_t a1, _DWORD **a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v41 = *MEMORY[0x263EF8C08];
  if (!ccpolyzp_po2cyc_ctx_eq(*a3, (_DWORD *)*a4)) {
    return 4294967289;
  }
  uint64_t v8 = *a2;
  if ((*a2)[1] != 1) {
    return 4294967289;
  }
  uint64_t v9 = a4[1];
  int v10 = *(_DWORD *)(v9 + 4);
  if (v10 == 1) {
    return 4294967289;
  }
  int v11 = 1;
  uint64_t v12 = a4[1];
  do
  {
    uint64_t v12 = *(void *)(v12 + 112);
    ++v11;
  }
  while (v10 != v11);
  uint64_t v13 = 4294967289;
  if (v10 == 2
    && *((void *)v8 + 2) == *(void *)(v12 + 16)
    && *(void *)(*(void *)(v9 + 112) + 16) != 0x1FFFFFFFFFFFFFFFLL
    && *(void *)(v9 + 16) == 0x1FFFFFFFFFFFFFFFLL)
  {
    uint64_t v15 = *(void *)(a1 + 16);
    uint64_t v14 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 24);
    unint64_t v16 = (_DWORD *)*a3;
    uint64_t v17 = sizeof_struct_ccpolyzp_po2cyc();
    unsigned int v18 = (void *)v14(a1, (v16[1] * *v16) + ((unint64_t)(v17 + 7) >> 3));
    unint64_t v19 = (_DWORD *)*a3;
    uint64_t v20 = sizeof_struct_ccpolyzp_po2cyc();
    memmove(v18, a3, (v20 + 8 * (v19[1] * *v19) + 7) & 0xFFFFFFFFFFFFFFF8);
    uint64_t v21 = *a4;
    uint64_t v22 = sizeof_struct_ccrns_mul_modulus();
    ccpolyzp_po2cyc_coeff_scalar_mul_ws(a1, (_DWORD **)v18, (unsigned int **)a3, (uint64_t)&a4[((unint64_t)(v22 + 7) >> 3) * (*(_DWORD *)(a4[1] + 4) * *(_DWORD *)(v21 + 4))+ 12+ ((unint64_t)(v22 + 7) >> 3) * *(unsigned int *)(v21 + 4)]);
    LODWORD(v21) = *(_DWORD *)*a3;
    uint64_t v23 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 24);
    uint64_t v24 = sizeof_struct_ccpolyzp_po2cyc();
    unsigned int v25 = (uint64_t *)v23(a1, (2 * v21) + ((unint64_t)(v24 + 7) >> 3));
    ccpolyzp_po2cyc_init_zero(v25, (_DWORD *)a4[1]);
    uint64_t v13 = ccpolyzp_po2cyc_base_convert_poly_ws(a1, v25, (uint64_t *)v18, a4);
    if (!v13)
    {
      long long v40 = *(_OWORD *)(a4 + 7);
      ccpolyzp_po2cyc_coeff_scalar_mul_ws(a1, (_DWORD **)v25, (unsigned int **)v25, (uint64_t)&v40);
      uint64_t v26 = *(unsigned int *)*a3;
      if (v26)
      {
        unint64_t v28 = (int *)*v25;
        uint64_t v27 = v25 + 1;
        int v29 = *v28;
        uint64_t v30 = a2 + 1;
        uint64_t v31 = v27;
        do
        {
          uint64_t v33 = *v31++;
          uint64_t v32 = v33;
          unint64_t v34 = v27[v29];
          uint64_t v35 = *((void *)v8 + 2);
          uint64_t v36 = v34 - v35 * ((*((unint64_t *)v8 + 3) * (unsigned __int128)v34) >> 64);
          if (v36 - v35 >= 0) {
            v36 -= v35;
          }
          uint64_t v37 = v32
              - (((v35 & ((v36 - a4[5]) >> 63)) + v36 - a4[5]) & ((uint64_t)(0xFFFFFFFFFFFFFFELL - v34) >> 63) | v36 & (((0xFFFFFFFFFFFFFFELL - v34) >> 63) - 1));
          *v30++ = (v35 & (v37 >> 63)) + v37;
          ++v29;
          --v26;
        }
        while (v26);
      }
      uint64_t v39 = a4[6];
      ccpolyzp_po2cyc_coeff_scalar_mul_ws(a1, a2, a2, (uint64_t)&v39);
    }
    *(void *)(a1 + 16) = v15;
  }
  return v13;
}

unint64_t CCPOLYZP_PO2CYC_BASE_CONVERT_MOD_T_DIVIDE_AND_ROUND_Q_LAST_WORKSPACE_N(unsigned int a1, int a2)
{
  unint64_t v3 = CCPOLYZP_PO2CYC_WORKSPACE_N(a1, a2 - 1);
  unint64_t v4 = CCPOLYZP_PO2CYC_WORKSPACE_N(a1, 1);
  unint64_t v5 = CCPOLYZP_PO2CYC_CTX_WORKSPACE_N(a1);
  unint64_t v6 = CCPOLYZP_PO2CYC_CTX_INIT_WORKSPACE_N(1);
  if (v6 <= v4) {
    unint64_t v7 = v4;
  }
  else {
    unint64_t v7 = v6;
  }
  return v4 + v3 + v5 + v7;
}

uint64_t ccpolyzp_po2cyc_base_convert_mod_t_divide_and_round_q_last_ws(uint64_t a1, uint64_t *a2, void *a3)
{
  unint64_t v6 = (unsigned int *)*a2;
  unint64_t v7 = *(unsigned int **)(*a2 + 112);
  if (!ccpolyzp_po2cyc_ctx_eq(*a2, (_DWORD *)*a3) || !*((void *)v6 + 14)) {
    return 4294967289;
  }
  uint64_t v74 = *(void *)(a1 + 16);
  int v75 = a2;
  uint64_t v8 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 24);
  uint64_t v9 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v82 = (unsigned int **)v8(a1, v7[1] * *v7 + ((unint64_t)(v9 + 7) >> 3));
  *unint64_t v82 = v7;
  uint64_t v10 = a3[1];
  int v11 = *(_DWORD *)(v10 + 4);
  while (--v11)
    uint64_t v10 = *(void *)(v10 + 112);
  unsigned int v84 = *v6;
  int v85 = 1;
  uint64_t v12 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 24);
  uint64_t v13 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t __dst = (void *)v12(a1, v84 + ((unint64_t)(v13 + 7) >> 3));
  uint64_t v14 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 24);
  uint64_t v15 = *v6;
  unint64_t v16 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
  if (v15 >= 0x80) {
    uint64_t v17 = 128;
  }
  else {
    uint64_t v17 = v15;
  }
  uint64_t v18 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v19 = (unsigned int *)v14(a1, v16 + 2 * (v15 + ((unint64_t)(v18 + 7) >> 3) * v17) + 6);
  uint64_t v83 = *((void *)v6 + 2);
  uint64_t result = ccpolyzp_po2cyc_ctx_init_ws(a1, v19, &v84, &v83, 0);
  if (!result)
  {
    uint64_t v21 = v75 + 1;
    unsigned int v76 = v7;
    uint64_t v22 = &v75[*(_DWORD *)*v75 * v7[1] + 1];
    uint64_t v23 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 24);
    uint64_t v24 = sizeof_struct_ccpolyzp_po2cyc();
    unsigned int v25 = (unsigned int **)v23(a1, v85 * v84 + ((unint64_t)(v24 + 7) >> 3));
    uint64_t result = ccpolyzp_po2cyc_init(v25, v19, v22);
    if (!result)
    {
      uint64_t result = ccpolyzp_po2cyc_inv_ntt(v25);
      if (!result)
      {
        uint64_t v73 = a1;
        uint64_t v26 = *v25;
        size_t v27 = (sizeof_struct_ccpolyzp_po2cyc() + 8 * v26[1] * *v26 + 7) & 0xFFFFFFFFFFFFFFF8;
        memmove(__dst, v25, v27);
        uint64_t v28 = v84;
        if (v84)
        {
          int v29 = __dst + 1;
          do
          {
            uint64_t v30 = *(void *)(v10 + 16);
            uint64_t v31 = *v29 - v30 * ((*(unint64_t *)(v10 + 24) * (unsigned __int128)(unint64_t)*v29) >> 64);
            if (v31 - v30 >= 0) {
              v31 -= v30;
            }
            uint64_t v32 = a3[9];
            uint64_t v33 = (v30 - v31) * a3[10]
                - v32 * (((unint64_t)(v30 - v31) * (unsigned __int128)(unint64_t)a3[11]) >> 64);
            if (v33 - v32 >= 0) {
              v33 -= v32;
            }
            *v29++ = v33;
            --v28;
          }
          while (v28);
        }
        uint64_t v34 = v76[1];
        if (v34)
        {
          unint64_t v35 = 0;
          unsigned int v36 = v6[1];
          unint64_t v37 = v36 - 1;
          uint64_t v38 = *(unsigned int *)(*a3 + 4);
          uint64_t v81 = (*(_DWORD *)(a3[1] + 4) * v38);
          uint64_t v39 = *v76;
          int v78 = (unint64_t *)(v25 + 1);
          __dsta = __dst + 1;
          unsigned int v77 = v36 - 2;
          do
          {
            long long v40 = v6;
            if (v35 < v37)
            {
              unsigned int v41 = v77;
              long long v40 = v6;
              do
                long long v40 = (void *)v40[14];
              while (v35 < v41--);
            }
            uint64_t v43 = sizeof_struct_ccrns_mul_modulus();
            if (v39)
            {
              uint64_t v44 = &a3[((unint64_t)(v43 + 7) >> 3) * v81
                      + 12
                      + ((unint64_t)(v43 + 7) >> 3) * v38
                      + v38
                      + ((unint64_t)(v43 + 7) >> 3) * v35];
              unsigned int v45 = **v82 * v35;
              uint64_t v46 = v39;
              unint64_t v47 = v78;
              unint64_t v48 = __dsta;
              do
              {
                unint64_t v49 = *v48++;
                uint64_t v51 = v40[2];
                unint64_t v50 = v40[3];
                unint64_t v52 = v49 - v51 * ((v50 * (unsigned __int128)v49) >> 64);
                if ((uint64_t)(v52 - v51) >= 0) {
                  v52 -= v51;
                }
                uint64_t v53 = v52 * v44[1] - *v44 * ((v52 * (unsigned __int128)(unint64_t)v44[2]) >> 64);
                unint64_t v55 = *v47++;
                unint64_t v54 = v55;
                uint64_t v56 = (v55 * (unsigned __int128)v50) >> 64;
                if (v53 - *v44 >= 0) {
                  v53 -= *v44;
                }
                unint64_t v57 = v54 - v51 * v56;
                if ((uint64_t)(v57 - v51) >= 0) {
                  v57 -= v51;
                }
                int v58 = (unsigned int *)(v53 + v57);
                if ((uint64_t)v58 - v51 >= 0) {
                  int v58 = (unsigned int *)((char *)v58 - v51);
                }
                v82[++v45] = v58;
                --v46;
              }
              while (v46);
            }
            ++v35;
          }
          while (v35 != v34);
        }
        uint64_t result = ccpolyzp_po2cyc_fwd_ntt(v82);
        if (!result)
        {
          uint64_t v59 = v76[1];
          if (v59)
          {
            uint64_t v60 = 0;
            unsigned int v61 = a3 + 12;
            uint64_t v62 = a3[1];
            uint64_t v63 = *(unsigned int *)(*a3 + 4);
            uint64_t v64 = (*(_DWORD *)(v62 + 4) * v63);
            uint64_t v65 = *v76;
            do
            {
              uint64_t v66 = sizeof_struct_ccrns_mul_modulus();
              if (v65)
              {
                unsigned int v67 = &v61[((unint64_t)(v66 + 7) >> 3) * v64
                         + ((unint64_t)(v66 + 7) >> 3) * v63
                         + v63
                         + ((unint64_t)(v66 + 7) >> 3) * (v63 - 1)
                         + ((unint64_t)(v66 + 7) >> 3) * v60];
                unsigned int v68 = **v82 * v60;
                int v69 = *(_DWORD *)*v75 * v60;
                uint64_t v70 = v65;
                do
                {
                  uint64_t v71 = v21[v69] - (void)v82[v68 + 1];
                  uint64_t v72 = ((*v67 & (v71 >> 63)) + v71) * v67[1]
                      - *v67
                      * ((((*v67 & (unint64_t)(v71 >> 63)) + v71) * (unsigned __int128)(unint64_t)v67[2]) >> 64);
                  if (v72 - *v67 >= 0) {
                    v72 -= *v67;
                  }
                  v21[v69] = v72;
                  ++v68;
                  ++v69;
                  --v70;
                }
                while (v70);
              }
              ++v60;
            }
            while (v60 != v59);
          }
          uint64_t result = 0;
          *int v75 = *(void *)(*v75 + 112);
        }
        a1 = v73;
      }
    }
  }
  *(void *)(a1 + 16) = v74;
  return result;
}

uint64_t ccz_add(void *a1, uint64_t a2, uint64_t a3)
{
  BOOL v15 = timingsafe_enable_if_supported();
  unint64_t v6 = ccz_n(a2);
  unint64_t v7 = ccz_n(a3);
  int v8 = ccz_sign(a2);
  if (v8 == ccz_sign(a3))
  {
    int v9 = ccz_sign(a2);
    ccz_set_sign((uint64_t)a1, v9);
    if (v6 >= v7)
    {
      unint64_t v10 = v6 + 1;
      ccz_set_capacity((uint64_t)a1, v6 + 1);
      *(void *)(a1[3] + 8 * v6) = ccn_addn(v6, (void *)a1[3], *(uint64_t **)(a2 + 24), v7, *(uint64_t **)(a3 + 24));
    }
    else
    {
      unint64_t v10 = v7 + 1;
      ccz_set_capacity((uint64_t)a1, v7 + 1);
      *(void *)(a1[3] + 8 * v7) = ccn_addn(v7, (void *)a1[3], *(uint64_t **)(a3 + 24), v6, *(uint64_t **)(a2 + 24));
    }
    unint64_t v6 = v10;
  }
  else if ((ccn_cmpn_internal(v6, *(void *)(a2 + 24), v7, *(void *)(a3 + 24)) & 0x80000000) != 0)
  {
    int v12 = ccz_sign(a3);
    ccz_set_sign((uint64_t)a1, v12);
    ccz_set_capacity((uint64_t)a1, v7);
    ccn_subn(v7, (void *)a1[3], *(uint64_t **)(a3 + 24), v6, *(unint64_t **)(a2 + 24));
    unint64_t v6 = v7;
  }
  else
  {
    int v11 = ccz_sign(a2);
    ccz_set_sign((uint64_t)a1, v11);
    ccz_set_capacity((uint64_t)a1, v6);
    ccn_subn(v6, (void *)a1[3], *(uint64_t **)(a2 + 24), v7, *(unint64_t **)(a3 + 24));
  }
  unint64_t v13 = ccn_n(v6, a1[3]);
  ccz_set_n(a1, v13);
  return cc_disable_dit_with_sb((unsigned int *)&v15);
}

uint64_t fipspost_post_hmac(char a1)
{
  uint64_t v23 = *MEMORY[0x263EF8C08];
  uint64_t v2 = ccsha1_di();
  unint64_t v3 = ccsha256_di();
  unint64_t v4 = ccsha512_di();
  unint64_t v5 = ccsha512_256_di();
  unint64_t v6 = ccsha3_224_di();
  unint64_t v7 = ccsha3_256_di();
  int v8 = ccsha3_384_di();
  int v9 = ccsha3_512_di();
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  int v12 = "\x01\xEE\xD8\x1B\x811*\x16\xFA\x1E\x98\x05\xE1\xD7\x84D[\xFF\x8C\xBE\x95\xEB\x4A\x36\x034\x97:\xE0\x72\x9E'P\xB4"
  memset(v22, 0, sizeof(v22));
  if ((a1 & 0x10) == 0) {
    int v12 = "\xEE\xD8\x1B\x811*\x16\xFA\x1E\x98\x05\xE1\xD7\x84D[\xFF\x8C\xBE\x95\xEB\x4A\x36\x034\x97:\xE0\x72\x9E'P\xB4"
  }
  v21[0] = v2;
  v21[1] = 50;
  unint64_t v13 = "\x01\xF3\xD9\x84\x1Cx.\x1D\xC8\x4D_\xBD\x95#h;\x8D)\xD1\xD5\x85-:tR\x0482:-_\x19\xA9\xB1\xA0-%M\x84\x97]\xCE\x60j\xBCe\xBD";
  void v21[2] = v12;
  v21[3] = 128;
  void v21[4] = "\xF0\x6B\xB4\x5B\xD0\x60X'\x82L\xD0\x4D\xA7[hz\x86\xC9\x39\xEF\xAF\xF9\xF1\x32\xDD\xC1\xD7\x04!\b\t\x94=\x94\b"
           "\xF2\x4E\x1D\x77\xA6 B\x19\r8U\x0F\xE0\xE4\x22yr\xFC\xB0\x8F.\x0E\xE3\xF8\x2C\xA6\xAB3\x02\xCC\x7B7\xDD\xCF\xFD"
           "V\xD0\x41\x04gkC\xC2\x24\x90\x03;\x82\xF9\x1F?\x9B\x01O\x10A\a\x9A^\b\xDE\xD1\xC7\xE62Aq;y\x10'\x8F\x81\x9C"
           "!\xFFQ\ruU\x9B\x85Hn\xDC\x62\x10";
  v21[5] = 20;
  v21[6] = "\x88n\xAEp\xF3\x6B\xD3\x80^\xEB\x12\x74\xB3$\x8F\xCC\xF5\xE1\x5B\x80";
  v21[7] = "sha1";
        "\x1EW\xBEF\xA5\r\xF5\xCE\xC1\xE0N\x93D&QK\x19\xEF\x61\x1F\xD7\x45\xED\x0D\x95\xB2\xEA\x8B\x01\x03\x80m\xACL\x03\b"
        "\xA8,&\x98URk\xDF\x78@\xDE\x0F\x8DO\x03\xEA\x5F\xF4\r(\xD5\x41P\x19\x0F\xAF\xF9\x8B\xB1\x1A\xFD\xEEb7\xF2\xC2\x3C"
        "\xCE\xC1\xE0N\x93D&QK\x19\xEF\x61\x1F\xD7\x45\xED\x0D\x95\xB2\xEA\x8B\x01\x03\x80m\xACL\x03\b\xA8,&\x98URk\xDF\x78"
        "@\xDE\x0F\x8DO\x03\xEA\x5F\xF4\r(\xD5\x41P\x19\x0F\xAF\xF9\x8B\xB1\x1A\xFD\xEE\x14zF\xD6\x7E\xEF\x0B\x5E\x9F\x99"
        "$\n"
        "\xF4\xD3\x14\xA30MX\x02\xD6\x54\x9Aw\x06T'k\x97\x9B\xA3Cg_\xFC\x88\xEF\x03\x9CE\x1B\x96\xE3\xB1\x58\x9D\xD4\x0E\xEE"
        "\x12\x0E\xAC\xFE\x031aT\xE7\x1A\x2A\xB3\xDD\x3A\x06\xAD\x86\xBDA\xEE\x29\xE0\xF6\xB7\x56\x03\xC9\xFF\x1C5\x90\xBB"
        "\xF2\xD8\x71\xFA\x86wi\xF3\x2A\x34\x75B\x19\x0F1i\xC1\x8A@\x1C\xFD\xAC\x9A\rs\xB3\x88~\xAF\x8F\x87\b\xBA\xB3\x8E"
        "\xD7\xE0\xC9W\x05\xBFK|\xC8\xEA\xCA\x32A\x88@\xAE\xDE\x68\xE7\xCD\x62\x1EC\x8FmaX;Ea\xFC\xA5G\x19\x04\xBDy\"\x89"
        "Y\xA3\x90\x86L\x8Ap\xA50i\xDA\x41r\xCA\x34\xC0\xEAIn\x12\x8D\u0378\xC3\x01secret-key\x13\x13";
  v21[8] = v3;
  v21[9] = 50;
  BOOL v15 = "\x01secret-key\x13\x13";
  if ((a1 & 0x10) == 0) {
    unint64_t v13 = "\xF3\xD9\x84\x1Cx.\x1D\xC8\x4D_\xBD\x95#h;\x8D)\xD1\xD5\x85-:tR\x0482:-_\x19\xA9\xB1\xA0-%M\x84\x97]\xCE\x60j\xBCe\xBD";
  }
  v21[10] = v13;
  v21[11] = 128;
  char v21[12] = &unk_2373BA368;
  v21[13] = 32;
  v21[14] = "\xC1\xCC\xF9\x1E\x8E\xA5\x8A\x16uk\xE8\xE4\x08\xF3\x08\xC9\xE1\x02\xEA\xE3\x54O\xB66\xDB\x18)4\x80\xAE\xD1\xE1";
  v21[15] = "sha256";
  if ((a1 & 0x10) == 0) {
  v21[16] = v4;
  }
  v21[17] = 110;
  v21[18] = v14;
  v21[19] = 128;
  if ((a1 & 0x10) == 0) {
    BOOL v15 = "secret-key\x13\x13";
  }
  v21[20] = "\x94\x14zF\xD6\x7E\xEF\x0B\x5E\x9F\x99$\n\xF4\xD3\x14\xA30MX\x02\xD6\x54\x9Aw\x06T'k\x97\x9B\xA3Cg_\xFC\x88\xEF\x03\x9CE\x1B\x96\xE3\xB1\x58\x9D\xD4\x0E\xEE\x12\x0E\xAC\xFE\x031aT\xE7\x1A\x2A\xB3\xDD\x3A\x06\xAD\x86\xBDA\xEE\x29\xE0\xF6\xB7\x56\x03\xC9\xFF\x1C5\x90\xBB\xF2\xD8\x71\xFA\x86wi\xF3\x2A\x34\x75B\x19\x0F1i\xC1\x8A@\x1C\xFD\xAC\x9A\rs\xB3\x88~\xAF\x8F\x87\b\xBA\xB3\x8E\xD7\xE0\xC9W\x05\xBFK|\xC8\xEA\xCA\x32A\x88@\xAE\xDE\x68\xE7\xCD\x62\x1EC\x8FmaX;Ea\xFC\xA5G\x19\x04\xBDy\"\x89Y\xA3\x90\x86L\x8Ap\xA50i\xDA\x41r\xCA\x34\xC0\xEAIn\x12\x8D\u0378\xC3\x01secret-key\x13\x13";
  unsigned char v21[21] = 64;
  v21[22] = "W\x05\xBFK|\xC8\xEA\xCA\x32A\x88@\xAE\xDE\x68\xE7\xCD\x62\x1EC\x8FmaX;Ea\xFC\xA5G\x19\x04\xBDy\"\x89Y\xA3\x90\x86L\x8Ap\xA50i\xDA\x41r\xCA\x34\xC0\xEAIn\x12\x8D\u0378\xC3\x01secret-key\x13\x13";
  v21[23] = "sha512";
  if ((a1 & 0x10) != 0) {
    unint64_t v16 = "\x01secret-key";
  }
  else {
    unint64_t v16 = "secret-key";
  }
  v21[24] = v5;
  v21[25] = 10;
  if ((a1 & 0x10) != 0) {
    uint64_t v17 = "\x01value to digest";
  }
  else {
    uint64_t v17 = "value to digest";
  }
  v21[26] = v15;
  v21[27] = 15;
  v21[28] = "value to digest";
  v21[29] = 32;
  v21[31] = "sha512/256";
  char v21[32] = v6;
  v21[33] = 10;
  v21[34] = v16;
  v21[35] = 15;
  v21[36] = v17;
  v21[37] = 28;
  v21[38] = &unk_2373BA3E9;
  v21[39] = "sha3_224";
  v21[40] = v7;
  v21[41] = 10;
  v21[42] = v16;
  v21[43] = 15;
  v21[44] = v17;
  v21[45] = 32;
  v21[46] = "\xE6\x5B\x43\x9A-\x0F\xE2\xC4\x15KUO\xE9\x96\x2A\x9A\x1E\xCE\x26\x84eB\xB3\xED\x8F\xCB\x16\xF3\x67\xC8\xDE\x41"
            "x\xB5\xFA\xF0\x52\xAB\x3E@\x9Fq\x15E\x95\n"
            "D\f\x8B\xFFv1\xFA\x0F\xE5\xD6\x1B\xC4\xCA_\xF9\xCE\x14\xE4\x52\x6E]|\x1D_\x9Dc\"\x12b~";
  v21[47] = "sha3_256";
  v21[48] = v8;
  v21[49] = 10;
  v21[50] = v16;
  v21[51] = 15;
  v21[52] = v17;
  v21[53] = 48;
  v21[54] = "\xDE\x41x\xB5\xFA\xF0\x52\xAB\x3E@\x9Fq\x15E\x95\nD\f\x8B\xFFv1\xFA\x0F\xE5\xD6\x1B\xC4\xCA_\xF9\xCE\x14\xE4\x52\x6E]|\x1D_\x9Dc\"\x12b~";
  v21[55] = "sha3_384";
  v21[56] = v9;
  v21[57] = 10;
  v21[58] = v16;
  v21[59] = 15;
  v21[60] = v17;
  v21[61] = 64;
  v21[62] = "\xEB\x10\xD9e\x80\xBF\x8E\xEE\xE5\x46\r^X7\xF5\x55\x57\x09\x01\x139\xB96\xA6{u7\x7F]\x18\xAE\xDB\xF7\x92\xB5"
            "\xA6\xF4\xA8\x53\x7B@\xD5\x5E\xC5\x0C\x8D}[I4\xC3\x04\xCC\xEB\xF6\x15\x26\x4B+v\x16\xB9\xBF\x1A";
  v21[63] = "sha3_512";
  do
  {
    uint64_t v18 = &v21[v10];
    cchmac(v21[v10], v21[v10 + 1], v21[v10 + 2], v21[v10 + 3], v21[v10 + 4], (uint64_t)v22);
    if (cc_cmp_safe(v18[5], (char *)v22, (char *)v18[6]))
    {
      uint64_t v19 = mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: digest: %s\n", v19, "fipspost_post_hmac", 235, (const char *)v18[7]);
      uint64_t v11 = 4294967221;
    }
    v10 += 8;
  }
  while (v10 != 64);
  return v11;
}

uint64_t ccder_blob_encode_body_tl(uint64_t *a1, unint64_t a2, unint64_t a3, const void *a4)
{
  uint64_t result = ccder_blob_encode_body(a1, a3, a4);
  if (result)
  {
    return ccder_blob_encode_tl(a1, a2, a3);
  }
  return result;
}

uint64_t cced448_sign_internal(unint64_t *a1, char *a2, unint64_t a3, char *a4, char *a5, char *a6, uint64_t (**a7)(void, uint64_t, char *))
{
  uint64_t v22 = *MEMORY[0x263EF8C08];
  uint64_t v14 = (*a7)(a7, 57, (char *)v21);
  if (v14) {
    return v14;
  }
  uint64_t v17 = cc_malloc_clear(0x700uLL);
  long long v18 = xmmword_2373BA410;
  uint64_t v19 = cc_ws_alloc;
  uint64_t v20 = cc_ws_free;
  if (!v17) {
    return 4294967283;
  }
  uint64_t v15 = cced448_sign_ws((uint64_t)&v17, a1, a2, a3, a4, a5, a6, (char *)v21, (uint64_t (**)(void, uint64_t, unint64_t *))a7);
  v20((uint64_t)&v17);
  return v15;
}

uint64_t cced448_sign_ws(uint64_t a1, unint64_t *a2, char *a3, unint64_t a4, char *a5, char *a6, char *a7, char *a8, uint64_t (**a9)(void, uint64_t, unint64_t *))
{
  uint64_t v42 = *MEMORY[0x263EF8C08];
  unint64_t v35 = *a2;
  uint64_t v13 = cczp_n((uint64_t)a2);
  uint64_t v36 = *(void *)(a1 + 16);
  uint64_t v14 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v13);
  uint64_t v15 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v13);
  uint64_t v33 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v13);
  unint64_t v16 = (unsigned char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 3 * v13);
  memset(__s, 0, 126);
  ccshake256(0x39uLL, a7, 0x72uLL, (char *)__s);
  LOBYTE(__s[0]) &= 0xFCu;
  BYTE7(__s[3]) |= 0x80u;
  if (v13)
  {
    uint64_t v17 = (uint64_t *)__s;
    long long v18 = v14;
    uint64_t v19 = v13;
    do
    {
      uint64_t v20 = *v17++;
      *v18++ = v20;
      --v19;
    }
    while (v19);
  }
  uint64_t v21 = cced448_scalar_mult_base_masked_ws(a1, a2, a9, (uint64_t)v16, (uint64_t)v14);
  if (v21) {
    goto LABEL_24;
  }
  uint64_t v21 = ccec_affinify_ws(a1, (uint64_t)a2);
  if (v21) {
    goto LABEL_24;
  }
  uint64_t v22 = 0;
  uint64_t v23 = (uint64_t)&a2[5 * v35 + 4];
  uint64_t v24 = &v16[8 * *a2];
  do
  {
    *(void *)&v40[v22] = *(void *)&v24[v22];
    v22 += 8;
  }
  while (v22 != 56);
  v40[56] = *v16 << 7;
  if (cc_cmp_safe_internal(57, a6, v40))
  {
    uint64_t v31 = 4294967289;
    goto LABEL_23;
  }
  unint64_t v25 = a8 ? 57 : 0;
  unint64_t v26 = a8 ? 69 : 57;
  cced448_shake_to_scalar_ws(a1, (uint64_t *)a2, v15, v25, a8, v26, (char *)&__s[3] + 9, a4, a5);
  uint64_t v21 = cced448_scalar_mult_base_masked_ws(a1, a2, a9, (uint64_t)v16, (uint64_t)v15);
  if (v21 || (uint64_t v21 = ccec_affinify_ws(a1, (uint64_t)a2), v21))
  {
LABEL_24:
    uint64_t v31 = v21;
  }
  else
  {
    uint64_t v27 = 0;
    uint64_t v28 = &v16[8 * *a2];
    do
    {
      *(void *)&a3[v27] = *(void *)&v28[v27];
      v27 += 8;
    }
    while (v27 != 56);
    a3[56] = *v16 << 7;
    cced448_shake_to_scalar_ws(a1, (uint64_t *)a2, v33, 0x39uLL, a3, 0x39uLL, a6, a4, a5);
    cczp_mul_ws(a1, v23);
    cczp_add_ws(a1, v23);
    if (v13)
    {
      int v29 = a3 + 64;
      do
      {
        uint64_t v30 = *v14++;
        *(void *)(v29 - 7) = v30;
        v29 += 8;
        --v13;
      }
      while (v13);
    }
    uint64_t v31 = 0;
    a3[113] = 0;
  }
LABEL_23:
  cc_clear(0x7EuLL, __s);
  *(void *)(a1 + 16) = v36;
  return v31;
}

uint64_t cced448_sign(uint64_t (**a1)(void, uint64_t, char *), char *a2, unint64_t a3, char *a4, char *a5, char *a6)
{
  BOOL v15 = timingsafe_enable_if_supported();
  int v12 = (unint64_t *)ccec_cp_ed448();
  uint64_t v13 = cced448_sign_internal(v12, a2, a3, a4, a5, a6, a1);
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v13;
}

uint64_t ccz_set(uint64_t a1, uint64_t a2)
{
  BOOL v9 = timingsafe_enable_if_supported();
  if (a1 != a2)
  {
    int v4 = ccz_sign(a2);
    ccz_set_sign(a1, v4);
    unint64_t v5 = ccz_n(a2);
    ccz_set_capacity(a1, v5);
    uint64_t v6 = ccz_n(a2);
    ccz_set_n((void *)a1, v6);
    uint64_t v7 = ccz_n(a2);
    ccn_set(v7, *(void **)(a1 + 24), *(void **)(a2 + 24));
  }
  return cc_disable_dit_with_sb((unsigned int *)&v9);
}

unint64_t ccwrap_unwrapped_size(unint64_t a1)
{
  if (a1 >= 8) {
    return a1 - 8;
  }
  else {
    return 0;
  }
}

uint64_t cckyber_poly_compress_d1(uint64_t result, uint64_t a2)
{
  for (uint64_t i = 0; i != 32; ++i)
  {
    uint64_t v3 = 0;
    int v4 = 0;
    *(unsigned char *)(result + i) = 0;
    do
    {
      v4 |= (((1290168
             * (unint64_t)(((int)((((*(__int16 *)(a2 + 2 * v3) >> 15) & 0xD01)
                                                      + *(__int16 *)(a2 + 2 * v3)) << 16) >> 15)
                                              + 1664)) >> 32) & 1) << v3;
      *(unsigned char *)(result + i) = v4;
      ++v3;
    }
    while (v3 != 8);
    a2 += 16;
  }
  return result;
}

unsigned char *cckyber_poly_compress_d4(unsigned char *result, uint64_t a2)
{
  for (uint64_t i = 0; i != 128; ++i)
  {
    uint64_t v3 = 0;
    char v4 = 1;
    do
    {
      char v5 = v4;
      unsigned int v6 = *(__int16 *)(a2 + 2 * (v3 | (2 * i)));
      *(_WORD *)&v7[2 * v3] = ((1290168
                              * (unint64_t)(((int)((((v6 >> 15) & 0xD01) + v6) << 16) >> 12) + 1664)) >> 32) & 0xF;
      uint64_t v3 = 1;
      char v4 = 0;
    }
    while ((v5 & 1) != 0);
    *result++ = v7[0] & 0xF | (16 * v7[2]);
  }
  return result;
}

uint64_t cckyber_poly_compress_d5(uint64_t result, int16x8_t *a2)
{
  uint64_t v2 = 0;
  int8x16_t v3 = (int8x16_t)vdupq_n_s16(0xD01u);
  uint64x2_t v4 = (uint64x2_t)vdupq_n_s64(0x680uLL);
  int8x16_t v5 = (int8x16_t)vdupq_n_s64(0xFFFFFFE0uLL);
  uint32x2_t v6 = (uint32x2_t)vdup_n_s32(0x13AFB8u);
  v7.i64[0] = 0x1F001F001F001FLL;
  v7.i64[1] = 0x1F001F001F001FLL;
  do
  {
    int16x8_t v8 = *a2++;
    int16x8_t v9 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vcltzq_s16(v8), v3), v8);
    int8x16_t v10 = (int8x16_t)vmovl_s16(*(int16x4_t *)v9.i8);
    int8x16_t v11 = (int8x16_t)vmovl_high_s16(v9);
    int v12 = (unsigned char *)(result + v2);
    int8x16_t v13 = (int8x16_t)vuzp1q_s16((int16x8_t)vuzp2q_s32((int32x4_t)vmull_u32((uint32x2_t)vmovn_s64((int64x2_t)vandq_s8((int8x16_t)vaddw_u32(v4, (uint32x2_t)vshl_n_s32(*(int32x2_t *)v10.i8, 5uLL)), v5)), v6), (int32x4_t)vmull_u32((uint32x2_t)vmovn_s64((int64x2_t)vandq_s8((int8x16_t)vaddw_u32(v4, (uint32x2_t)vshl_n_s32((int32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 8uLL), 5uLL)), v5)), v6)), (int16x8_t)vuzp2q_s32((int32x4_t)vmull_u32((uint32x2_t)vmovn_s64((int64x2_t)vandq_s8((int8x16_t)vaddw_u32(
                                                                                                 v4,
                                                                                                 (uint32x2_t)vshl_n_s32(*(int32x2_t *)v11.i8, 5uLL)),
                                                                                    v5)),
                                                 v6),
                                    (int32x4_t)vmull_u32((uint32x2_t)vmovn_s64((int64x2_t)vandq_s8((int8x16_t)vaddw_u32(v4, (uint32x2_t)vshl_n_s32((int32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 8uLL), 5uLL)), v5)), v6)));
    int8x16_t v14 = vandq_s8(v13, v7);
    *int v12 = v14.i8[0] | (32 * v14.i8[2]);
    _OWORD v12[2] = (16 * v14.i8[8]) | (v14.u16[3] >> 1);
    v12[1] = (4 * v14.i8[4]) | (v14.u16[1] >> 3) | (v14.i8[6] << 7);
    v12[3] = (2 * v14.i8[10]) | (v14.u16[4] >> 4) | (v14.i8[12] << 6);
    void v12[4] = (8 * v13.i8[14]) | (v14.u16[6] >> 2);
    v2 += 5;
  }
  while (v2 != 160);
  return result;
}

uint64_t cckyber_poly_compress_d10(uint64_t result, int16x4_t *a2)
{
  uint64_t v2 = 0;
  int8x8_t v3 = (int8x8_t)vdup_n_s16(0xD01u);
  uint64x2_t v4 = (uint64x2_t)vdupq_n_s64(0x680uLL);
  int8x16_t v5 = (int8x16_t)vdupq_n_s64(0xFFFFFE80uLL);
  uint32x2_t v6 = (uint32x2_t)vdup_n_s32(0x13AFB8u);
  do
  {
    int16x4_t v7 = *a2++;
    int8x16_t v8 = (int8x16_t)vmovl_s16(vadd_s16((int16x4_t)vand_s8((int8x8_t)vcltz_s16(v7), v3), v7));
    int16x8_t v9 = (unsigned char *)(result + v2);
    v8.i64[0] = *(void *)&vmovn_s32(vuzp2q_s32((int32x4_t)vmull_u32((uint32x2_t)vmovn_s64((int64x2_t)vandq_s8((int8x16_t)vaddw_u32(v4, (uint32x2_t)vshl_n_s32(*(int32x2_t *)v8.i8, 0xAuLL)), v5)), v6), (int32x4_t)vmull_u32((uint32x2_t)vmovn_s64((int64x2_t)vandq_s8((int8x16_t)vaddw_u32(v4, (uint32x2_t)vshl_n_s32((int32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL), 0xAuLL)), v5)), v6))) & 0x3FF03FF03FF03FFLL;
    unsigned char *v9 = v8.i8[0];
    v9[1] = (4 * v8.i8[2]) | v8.i8[1];
    void v9[2] = (16 * v8.i8[4]) | (v8.u16[1] >> 6);
    void v9[3] = (v8.i8[6] << 6) | (v8.u16[2] >> 4);
    void v9[4] = v8.u16[3] >> 2;
    v2 += 5;
  }
  while (v2 != 320);
  return result;
}

uint64_t cckyber_poly_compress_d11(uint64_t result, int16x8_t *a2)
{
  uint64_t v2 = 0;
  int8x16_t v3 = (int8x16_t)vdupq_n_s16(0xD01u);
  uint32x2_t v4 = (uint32x2_t)vdup_n_s32(0x13AFB8u);
  int64x2_t v5 = vdupq_n_s64(0x7FF62C00uLL);
  do
  {
    int16x8_t v6 = *a2++;
    int16x8_t v7 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vcltzq_s16(v6), v3), v6);
    int8x16_t v8 = (int8x16_t)vmovl_s16(*(int16x4_t *)v7.i8);
    int8x16_t v9 = (int8x16_t)vmovl_high_s16(v7);
    unsigned long long v10 = *(_OWORD *)&vuzp1q_s16((int16x8_t)vaddhn_high_s64(vaddhn_s64((int64x2_t)vmull_u32((uint32x2_t)vshl_n_s32(*(int32x2_t *)v8.i8, 0xBuLL), v4), v5), (int64x2_t)vmull_u32((uint32x2_t)vshl_n_s32((int32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL), 0xBuLL), v4), v5), (int16x8_t)vaddhn_high_s64(vaddhn_s64((int64x2_t)vmull_u32((uint32x2_t)vshl_n_s32(*(int32x2_t *)v9.i8, 0xBuLL), v4), v5), (int64x2_t)vmull_u32((uint32x2_t)vshl_n_s32((int32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL), 0xBuLL), v4),
                                     v5)) & __PAIR128__(0x7FF07FF07FF07FFLL, 0x7FF07FF07FF07FFLL);
    int8x16_t v11 = (unsigned char *)(result + v2);
    *int8x16_t v11 = v10;
    v11[3] = WORD2(v10) >> 2;
    void v11[4] = (2 * BYTE6(v10)) | ((WORD2(v10) & 0x400) != 0);
    v11[1] = (8 * BYTE2(v10)) | BYTE1(v10);
    void v11[2] = (BYTE4(v10) << 6) | (WORD1(v10) >> 5);
    v11[7] = WORD5(v10) >> 1;
    v11[5] = (16 * BYTE8(v10)) | (WORD3(v10) >> 7);
    v11[8] = (4 * BYTE12(v10)) | (WORD5(v10) >> 9) & 3;
    v11[6] = (BYTE10(v10) << 7) | (WORD4(v10) >> 4);
    v11[9] = (32 * BYTE14(v10)) | (WORD6(v10) >> 6);
    v11[10] = HIWORD(v10) >> 3;
    v2 += 11;
  }
  while (v2 != 352);
  return result;
}

_WORD *cckyber_poly_decompress_d1(_WORD *result, uint64_t a2)
{
  for (uint64_t i = 0; i != 32; ++i)
  {
    for (int j = 0; j != 8; ++j)
      *result++ = (3329 * ((*(unsigned __int8 *)(a2 + i) >> j) & 1u) + 1) >> 1;
  }
  return result;
}

_WORD *cckyber_poly_decompress_d4(_WORD *result, uint64_t a2)
{
  for (uint64_t i = 0; i != 128; ++i)
  {
    *uint64_t result = (3329 * (*(unsigned char *)(a2 + i) & 0xFu) + 8) >> 4;
    result[1] = (3329 * (*(unsigned char *)(a2 + i) >> 4) + 8) >> 4;
    result += 2;
  }
  return result;
}

_WORD *cckyber_poly_decompress_d5(_WORD *result, uint64_t a2)
{
  uint64_t v2 = 0;
  uint64_t v10 = *MEMORY[0x263EF8C08];
  do
  {
    uint64_t v3 = 0;
    uint32x2_t v4 = (unsigned char *)(a2 + 5 * v2);
    v9[0] = *v4;
    unsigned int v5 = v4[1];
    HIDWORD(v6) = v5;
    LODWORD(v6) = v9[0] << 24;
    v9[1] = v6 >> 29;
    void v9[2] = v5 >> 2;
    int v7 = v4[2];
    HIDWORD(v6) = v7;
    LODWORD(v6) = v5 << 24;
    void v9[3] = v6 >> 31;
    unsigned int v8 = v4[3];
    HIDWORD(v6) = v8;
    LODWORD(v6) = v7 << 24;
    void v9[4] = v6 >> 28;
    v9[5] = v8 >> 1;
    HIDWORD(v6) = v4[4];
    LODWORD(v6) = v8 << 24;
    v9[6] = v6 >> 30;
    v9[7] = HIDWORD(v6) >> 3;
    do
      *result++ = (3329 * (v9[v3++] & 0x1Fu) + 16) >> 5;
    while (v3 != 8);
    ++v2;
  }
  while (v2 != 32);
  return result;
}

uint64_t cckyber_poly_decompress_d10(uint64_t result, uint64_t a2)
{
  uint64_t v2 = 0;
  uint64_t v11 = *MEMORY[0x263EF8C08];
  do
  {
    uint64_t v3 = 0;
    uint32x2_t v4 = (unsigned __int8 *)(a2 + 5 * v2);
    unsigned int v5 = v4[1];
    v10[0] = *v4 | (unsigned __int16)((_WORD)v5 << 8);
    unsigned int v6 = v5 >> 2;
    unsigned int v7 = v4[2];
    v10[1] = v6 | ((_WORD)v7 << 6);
    unsigned int v8 = v7 >> 4;
    unsigned int v9 = v4[3];
    void v10[2] = v8 | (16 * v9);
    v10[3] = (v9 >> 6) | (4 * v4[4]);
    do
    {
      *(_WORD *)(result + v3 * 2) = (3329 * (v10[v3] & 0x3FFu) + 512) >> 10;
      ++v3;
    }
    while (v3 != 4);
    ++v2;
    result += 8;
  }
  while (v2 != 64);
  return result;
}

uint64_t cckyber_poly_decompress_d11(uint64_t result, uint64_t a2)
{
  uint64_t v2 = 0;
  uint64_t v17 = *MEMORY[0x263EF8C08];
  do
  {
    uint64_t v3 = 0;
    uint32x2_t v4 = (unsigned __int8 *)(a2 + 11 * v2);
    unsigned int v5 = v4[1];
    v16[0] = *v4 | (unsigned __int16)((_WORD)v5 << 8);
    unsigned int v6 = v5 >> 3;
    unsigned int v7 = v4[2];
    v16[1] = v6 | (32 * v7);
    LOWORD(v6) = (v7 >> 6) | (4 * v4[3]);
    unsigned int v8 = v4[4];
    _OWORD v16[2] = v6 | ((_WORD)v8 << 10);
    unsigned int v9 = v8 >> 1;
    unsigned int v10 = v4[5];
    v16[3] = v9 | ((_WORD)v10 << 7);
    unsigned int v11 = v10 >> 4;
    unsigned int v12 = v4[6];
    void v16[4] = v11 | (16 * v12);
    LOWORD(v11) = (v12 >> 7) | (2 * v4[7]);
    unsigned int v13 = v4[8];
    v16[5] = v11 | ((_WORD)v13 << 9);
    unsigned int v14 = v13 >> 2;
    unsigned int v15 = v4[9];
    unsigned char v16[6] = v14 | ((_WORD)v15 << 6);
    v16[7] = (v15 >> 5) | (8 * v4[10]);
    do
    {
      *(_WORD *)(result + v3 * 2) = (3329 * (v16[v3] & 0x7FFu) + 1024) >> 11;
      ++v3;
    }
    while (v3 != 8);
    ++v2;
    result += 16;
  }
  while (v2 != 32);
  return result;
}

uint64_t ccsae_verify_commitment(unint64_t **a1, uint64_t a2)
{
  uint64_t v30 = *MEMORY[0x263EF8C08];
  BOOL v28 = timingsafe_enable_if_supported();
  uint32x2_t v4 = *a1;
  v24[0] = cc_malloc_clear(288 * **a1);
  v24[1] = 36 * *v4;
  uint64_t v25 = 0;
  unint64_t v26 = cc_ws_alloc;
  uint64_t v27 = cc_ws_free;
  if (!v24[0])
  {
    uint64_t v18 = 4294967283;
    goto LABEL_19;
  }
  if (*((unsigned __int8 *)a1 + 24) != CCSAE_STATE_COMMIT_GENERATED)
  {
    uint64_t v18 = 4294967210;
    cc_ws_free((uint64_t)v24);
    goto LABEL_19;
  }
  unsigned int v5 = a1[1];
  uint64_t v23 = (uint64_t)a1[2];
  unsigned int v6 = *a1;
  unint64_t v7 = **a1;
  unint64_t v8 = (unint64_t)(cczp_bitlen((uint64_t)*a1) + 7) >> 3;
  uint64_t v20 = (unint64_t *)cc_ws_alloc(v24, v7);
  uint64_t v9 = v26(v24, 3 * v7);
  uint64_t v22 = v26(v24, 3 * v7);
  uint64_t v21 = v26(v24, 3 * v7);
  unsigned int v10 = (unint64_t *)v26(v24, 3 * v7);
  unsigned int v11 = a1 + 18;
  ccn_read_uint_internal(v7, &a1[2 * **a1 + 18], v8, a2);
  uint64_t v12 = a2 + v8;
  ccn_read_uint_internal(v7, &a1[7 * **a1 + 18], v8, v12);
  ccn_read_uint_internal(v7, &a1[8 * **a1 + 18], v8, v12 + v8);
  if (ccn_n(v7, (uint64_t)&a1[2 * **a1 + 18]) == 1 && v11[2 * **a1] == (void *)1) {
    goto LABEL_21;
  }
  uint64_t v13 = ccec_validate_scalar(v6, (uint64_t)&v11[2 * **a1]);
  if (!v13)
  {
    unint64_t v14 = **a1;
    if (ccn_cmp_internal(v7, &v11[2 * v14], &v11[3 * v14])
      && ccn_cmp_internal(v7, &v11[7 * v14], &v11[5 * v14])
      && ccn_cmp_internal(v7, &v11[8 * v14], &v11[6 * v14]))
    {
      uint64_t v13 = ccec_validate_point_and_projectify_ws((uint64_t)v24, (uint64_t *)v6, v22, (uint64_t)&v11[7 * v14]);
      if (!v13)
      {
        uint64_t v13 = ccec_projectify_ws((uint64_t)v24, (uint64_t)v6);
        if (!v13)
        {
          uint64_t v13 = ccec_mult_blinded_ws((uint64_t)v24, v6, v21, (uint64_t)&v11[2 * **a1], v9, (uint64_t (**)(void, uint64_t, unint64_t *))v5);
          if (!v13)
          {
            ccec_full_add_ws((uint64_t)v24, (uint64_t)v6);
            uint64_t v13 = ccec_mult_blinded_ws((uint64_t)v24, v6, (uint64_t)v10, (uint64_t)&v11[4 * **a1], v9, (uint64_t (**)(void, uint64_t, unint64_t *))v5);
            if (!v13)
            {
              uint64_t v13 = ccec_affinify_ws((uint64_t)v24, (uint64_t)v6);
              if (!v13)
              {
                uint64_t v15 = (uint64_t)&v6[5 * v7 + 4];
                unint64_t v16 = v6;
                uint64_t v17 = (rsize_t *)v23;
                ccsae_generate_keyseed_ws((uint64_t)v24, v16, v23, v10, (uint64_t)__s);
                cczp_add_ws((uint64_t)v24, v15);
                uint64_t v18 = ccsae_gen_keys_ws((uint64_t)v24, (uint64_t)a1, __s, v20);
                if (!v18) {
                  *((unsigned char *)a1 + 24) |= CCSAE_STATE_COMMIT_VERIFIED;
                }
                goto LABEL_16;
              }
            }
          }
        }
      }
      goto LABEL_20;
    }
LABEL_21:
    uint64_t v18 = 4294967289;
    goto LABEL_22;
  }
LABEL_20:
  uint64_t v18 = v13;
LABEL_22:
  uint64_t v17 = (rsize_t *)v23;
LABEL_16:
  cc_clear(*v17, __s);
  uint64_t v25 = 0;
  v27((uint64_t)v24);
LABEL_19:
  cc_disable_dit_with_sb((unsigned int *)&v28);
  return v18;
}

uint64_t ccsae_generate_keyseed_ws(uint64_t a1, unint64_t *a2, uint64_t a3, unint64_t *a4, uint64_t a5)
{
  uint64_t v21 = *MEMORY[0x263EF8C08];
  unint64_t v9 = *a2;
  unint64_t v10 = (unint64_t)(cczp_bitlen((uint64_t)a2) + 7) >> 3;
  memset(v20, 0, sizeof(v20));
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v9);
  uint64_t v13 = ccn_write_uint_padded_internal(v9, a4, v10, v12);
  MEMORY[0x270FA53B0](v13, v14, v15, v16);
  uint64_t v18 = (void *)((char *)v20 - v17);
  cchmac_init_internal(a3, (_OWORD *)((char *)v20 - v17), 0x20uLL, (char *)v20);
  cchmac_update_internal(a3, v18, v10, v12);
  cchmac_final_internal(a3, v18, a5);
  uint64_t result = cc_clear(((*(void *)(a3 + 8) + *(void *)(a3 + 16) + 19) & 0xFFFFFFFFFFFFFFF8) + *(void *)(a3 + 8), v18);
  *(void *)(a1 + 16) = v11;
  return result;
}

uint64_t ccn_random_bits(uint64_t a1, uint64_t a2, uint64_t (**a3)(void, unint64_t, uint64_t))
{
  char v4 = a1;
  unint64_t v5 = (unint64_t)(a1 + 63) >> 6;
  uint64_t result = (*a3)(a3, 8 * v5, a2);
  if (!result) {
    *(void *)(a2 + 8 * v5 - 8) &= 0xFFFFFFFFFFFFFFFFLL >> -(((((unint64_t)(v4 & 0x3F) + 0xFFFFFFFF) >> 32) - 1) & 0x40 | v4 & 0x3F);
  }
  return result;
}

uint64_t ccn_random_bits_fips(uint64_t a1, void *a2, uint64_t (**a3)(void, unint64_t, void *))
{
  char v4 = a1;
  uint64_t v10 = *MEMORY[0x263EF8C08];
  unint64_t v5 = (unint64_t)(a1 + 63) >> 6;
  unsigned int v6 = *a3;
  if ((unint64_t)(a1 + 63) > 0x7F)
  {
    uint64_t v7 = v6(a3, 8 * v5, a2);
  }
  else
  {
    uint64_t v7 = v6(a3, 12uLL, __src);
    memcpy(a2, __src, 8 * v5);
    cc_clear(8 * v5, __src);
  }
  if (!v7) {
    *((void *)a2 + v5 - 1) &= 0xFFFFFFFFFFFFFFFFLL >> -(((((unint64_t)(v4 & 0x3F) + 0xFFFFFFFF) >> 32) - 1) & 0x40 | v4 & 0x3F);
  }
  return v7;
}

uint64_t ccchacha20_init(uint64_t a1, _DWORD *a2)
{
  BOOL v5 = timingsafe_enable_if_supported();
  *(_OWORD *)a1 = xmmword_2373BA420;
  *(_DWORD *)(a1 + 16) = *a2;
  *(_DWORD *)(a1 + 20) = a2[1];
  *(_DWORD *)(a1 + 24) = a2[2];
  *(_DWORD *)(a1 + 28) = a2[3];
  *(_DWORD *)(a1 + 32) = a2[4];
  *(_DWORD *)(a1 + 36) = a2[5];
  *(_DWORD *)(a1 + 40) = a2[6];
  *(void *)(a1 + 44) = a2[7];
  *(void *)(a1 + 128) = 0;
  cc_disable_dit_with_sb((unsigned int *)&v5);
  return 0;
}

uint64_t ccchacha20_reset(uint64_t a1)
{
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)(a1 + 128) = 0;
  return 0;
}

uint64_t ccchacha20_setnonce(_DWORD *a1, _DWORD *a2)
{
  BOOL v5 = timingsafe_enable_if_supported();
  a1[13] = *a2;
  a1[14] = a2[1];
  a1[15] = a2[2];
  cc_disable_dit_with_sb((unsigned int *)&v5);
  return 0;
}

uint64_t ccchacha20_setcounter(uint64_t a1, int a2)
{
  BOOL v5 = timingsafe_enable_if_supported();
  *(_DWORD *)(a1 + 48) = a2;
  cc_disable_dit_with_sb((unsigned int *)&v5);
  return 0;
}

uint64_t ccchacha20_update(int32x4_t *a1, unint64_t a2, int8x16_t *a3, int8x16_t *a4)
{
  BOOL v9 = timingsafe_enable_if_supported();
  ccchacha20_update_internal(a1, a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v9);
  return 0;
}

int32x4_t *ccchacha20_update_internal(int32x4_t *result, unint64_t a2, int8x16_t *a3, int8x16_t *a4)
{
  char v4 = a4;
  BOOL v5 = a3;
  unint64_t v6 = a2;
  uint64_t v7 = result;
  uint64_t v8 = result[8].i64[0];
  if (v8)
  {
    unint64_t v9 = 64 - v8;
    if (64 - v8 >= a2) {
      unint64_t v9 = a2;
    }
    if (v9)
    {
      uint64_t v10 = (uint64_t)&result[3].i64[1] + v8 + 7;
      unint64_t v11 = v9;
      do
      {
        a4[-1].i8[v11 + 15] = *(unsigned char *)(v10 + v11) ^ a3[-1].i8[v11 + 15];
        --v11;
      }
      while (v11);
      uint64_t v8 = result[8].i64[0];
    }
    BOOL v5 = (int8x16_t *)((char *)a3 + v9);
    unint64_t v6 = a2 - v9;
    char v4 = (int8x16_t *)((char *)a4 + v9);
    result[8].i64[0] = ((_WORD)v8 + (_WORD)v9) & 0x1FF;
  }
  if (v6 >= 0x40)
  {
    uint64_t result = _ccchacha20_xor(result, v6 & 0xFFFFFFFFFFFFFFC0, v4, v5);
    BOOL v5 = (int8x16_t *)((char *)v5 + (v6 & 0xFFFFFFFFFFFFFFC0));
    char v4 = (int8x16_t *)((char *)v4 + (v6 & 0xFFFFFFFFFFFFFFC0));
    v6 &= 0x3Fu;
  }
  if (v6)
  {
    uint64_t result = _ccchacha20_xor(v7, 0x40uLL, (int8x16_t *)&v7[4], kZero64);
    unint64_t v12 = v6;
    do
    {
      v4[-1].i8[v12 + 15] = v7[3].i8[v12 + 15] ^ v5[-1].i8[v12 + 15];
      --v12;
    }
    while (v12);
    v7[8].i64[0] = v6;
  }
  return result;
}

uint64_t ccchacha20_final(void *a1)
{
  BOOL v3 = timingsafe_enable_if_supported();
  cc_clear(0x88uLL, a1);
  cc_disable_dit_with_sb((unsigned int *)&v3);
  return 0;
}

uint64_t ccchacha20(int32x4_t *a1, uint64_t *a2, int a3, unint64_t a4, int8x16_t *a5, int8x16_t *a6)
{
  uint64_t v25 = *MEMORY[0x263EF8C08];
  BOOL v15 = timingsafe_enable_if_supported();
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  int32x4_t v12 = *a1;
  int32x4_t v13 = a1[1];
  __s[0] = (int32x4_t)xmmword_2373BA420;
  __s[1] = v12;
  long long __s[2] = v13;
  uint64_t v24 = 0;
  uint64_t v18 = *a2;
  int v19 = *((_DWORD *)a2 + 2);
  int v17 = a3;
  _ccchacha20_xor(__s, a4, a6, a5);
  cc_clear(0x88uLL, __s);
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return 0;
}

int32x4_t *_ccchacha20_xor(int32x4_t *result, unint64_t a2, int8x16_t *a3, int8x16_t *a4)
{
  uint64_t v200 = *MEMORY[0x263EF8C08];
  int32x4_t v5 = result[1];
  int32x4_t v4 = result[2];
  int32x4_t v6 = result[3];
  if (a2 >= 0xC0)
  {
    uint64_t v7 = 0;
    unint64_t v8 = a2 / 0xC0;
    do
    {
      int32x4_t v9 = vaddq_s32(v6, (int32x4_t)xmmword_2373BA430);
      __int32 v11 = result[1].i32[0];
      __int32 v10 = result[1].i32[1];
      __int32 v12 = result[1].i32[2];
      __int32 v13 = result[1].i32[3];
      __int32 v14 = result[2].i32[0];
      __int32 v15 = result[2].i32[1];
      __int32 v16 = result[2].i32[2];
      __int32 v17 = result[2].i32[3];
      int v18 = 3 * v7 + 2;
      __int32 v19 = result[3].i32[1];
      int v20 = result[3].i32[0] + v18;
      uint64_t v21 = -10;
      int v22 = 1634760805;
      int v23 = 857760878;
      int v24 = 2036477234;
      int v25 = 1797285236;
      int32x4_t v26 = (int32x4_t)xmmword_2373BA420;
      int32x4_t v27 = v5;
      int32x4_t v28 = v4;
      int32x4_t v29 = v6;
      int32x4_t v30 = (int32x4_t)xmmword_2373BA420;
      int32x4_t v31 = v5;
      int32x4_t v32 = v4;
      int32x4_t v33 = v9;
      __int32 v35 = result[3].i32[2];
      __int32 v34 = result[3].i32[3];
      do
      {
        int32x4_t v36 = vaddq_s32(v26, v27);
        int32x4_t v37 = (int32x4_t)vrev32q_s16((int16x8_t)veorq_s8((int8x16_t)v36, (int8x16_t)v29));
        int32x4_t v38 = vaddq_s32(v28, v37);
        int32x4_t v39 = (int32x4_t)veorq_s8((int8x16_t)v38, (int8x16_t)v27);
        int32x4_t v40 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v39, 0xCuLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v39, 0x14uLL));
        int32x4_t v41 = vaddq_s32(v40, v36);
        int32x4_t v42 = (int32x4_t)veorq_s8((int8x16_t)v41, (int8x16_t)v37);
        int32x4_t v43 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v42, 8uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v42, 0x18uLL));
        int8x16_t v44 = (int8x16_t)vaddq_s32(v43, v38);
        int32x4_t v45 = (int32x4_t)veorq_s8(v44, (int8x16_t)v40);
        int8x16_t v46 = vorrq_s8((int8x16_t)vshlq_n_s32(v45, 7uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v45, 0x19uLL));
        int32x4_t v47 = (int32x4_t)vextq_s8(v46, v46, 4uLL);
        int32x4_t v48 = vaddq_s32(v47, v41);
        int32x4_t v49 = (int32x4_t)vrev32q_s16((int16x8_t)veorq_s8((int8x16_t)v48, vextq_s8((int8x16_t)v43, (int8x16_t)v43, 0xCuLL)));
        int32x4_t v50 = vaddq_s32((int32x4_t)vextq_s8(v44, v44, 8uLL), v49);
        int32x4_t v51 = (int32x4_t)veorq_s8((int8x16_t)v50, (int8x16_t)v47);
        int32x4_t v52 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v51, 0xCuLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v51, 0x14uLL));
        int32x4_t v26 = vaddq_s32(v52, v48);
        int32x4_t v53 = (int32x4_t)veorq_s8((int8x16_t)v26, (int8x16_t)v49);
        int32x4_t v54 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v53, 8uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v53, 0x18uLL));
        int8x16_t v55 = (int8x16_t)vaddq_s32(v54, v50);
        int32x4_t v56 = (int32x4_t)veorq_s8(v55, (int8x16_t)v52);
        int8x16_t v57 = vorrq_s8((int8x16_t)vshlq_n_s32(v56, 7uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v56, 0x19uLL));
        int32x4_t v27 = (int32x4_t)vextq_s8(v57, v57, 0xCuLL);
        int32x4_t v28 = (int32x4_t)vextq_s8(v55, v55, 8uLL);
        int32x4_t v29 = (int32x4_t)vextq_s8((int8x16_t)v54, (int8x16_t)v54, 4uLL);
        int32x4_t v58 = vaddq_s32(v30, v31);
        int32x4_t v59 = (int32x4_t)vrev32q_s16((int16x8_t)veorq_s8((int8x16_t)v58, (int8x16_t)v33));
        int32x4_t v60 = vaddq_s32(v32, v59);
        __int32 v61 = v22 + v11;
        int v62 = (v22 + v11) ^ v20;
        HIDWORD(v63) = v62;
        LODWORD(v63) = v62;
        int v64 = (v63 >> 16) + v14;
        int v65 = v64 ^ v11;
        HIDWORD(v63) = v65;
        LODWORD(v63) = v65;
        int32x4_t v66 = (int32x4_t)veorq_s8((int8x16_t)v60, (int8x16_t)v31);
        int v67 = (v63 >> 20) + v61;
        LODWORD(v63) = v67 ^ __ROR4__(v62, 16);
        int v68 = v63;
        HIDWORD(v63) = v63;
        int v69 = (v63 >> 24) + v64;
        LODWORD(v63) = v69 ^ __ROR4__(v65, 20);
        int v70 = v63;
        HIDWORD(v63) = v63;
        int v71 = v63 >> 25;
        __int32 v72 = v23 + v10;
        int v73 = (v23 + v10) ^ v19;
        HIDWORD(v63) = v73;
        LODWORD(v63) = v73;
        int32x4_t v74 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v66, 0xCuLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v66, 0x14uLL));
        int v75 = (v63 >> 16) + v15;
        int v76 = v75 ^ v10;
        HIDWORD(v63) = v76;
        LODWORD(v63) = v76;
        int32x4_t v77 = vaddq_s32(v74, v58);
        int v78 = (v63 >> 20) + v72;
        LODWORD(v63) = v78 ^ __ROR4__(v73, 16);
        int v79 = v63;
        HIDWORD(v63) = v63;
        int32x4_t v80 = (int32x4_t)veorq_s8((int8x16_t)v77, (int8x16_t)v59);
        int v81 = (v63 >> 24) + v75;
        LODWORD(v63) = v81 ^ __ROR4__(v76, 20);
        int v82 = v63;
        HIDWORD(v63) = v63;
        int v83 = v63 >> 25;
        __int32 v84 = v24 + v12;
        int v85 = (v24 + v12) ^ v35;
        HIDWORD(v63) = v85;
        LODWORD(v63) = v85;
        int v86 = (v63 >> 16) + v16;
        int v87 = v86 ^ v12;
        HIDWORD(v63) = v87;
        LODWORD(v63) = v87;
        int32x4_t v88 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v80, 8uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v80, 0x18uLL));
        int v89 = (v63 >> 20) + v84;
        LODWORD(v63) = v89 ^ __ROR4__(v85, 16);
        int v90 = v63;
        HIDWORD(v63) = v63;
        int8x16_t v91 = (int8x16_t)vaddq_s32(v88, v60);
        int v92 = (v63 >> 24) + v86;
        LODWORD(v63) = v92 ^ __ROR4__(v87, 20);
        int v93 = v63;
        HIDWORD(v63) = v63;
        int v94 = v63 >> 25;
        int32x4_t v95 = (int32x4_t)veorq_s8(v91, (int8x16_t)v74);
        __int32 v96 = v25 + v13;
        int v97 = v96 ^ v34;
        HIDWORD(v63) = v97;
        LODWORD(v63) = v97;
        int8x16_t v98 = vorrq_s8((int8x16_t)vshlq_n_s32(v95, 7uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v95, 0x19uLL));
        int v99 = (v63 >> 16) + v17;
        int v100 = v99 ^ v13;
        HIDWORD(v63) = v99 ^ v13;
        LODWORD(v63) = v99 ^ v13;
        int32x4_t v101 = (int32x4_t)vextq_s8(v98, v98, 4uLL);
        int v102 = (v63 >> 20) + v96;
        int32x4_t v104 = vaddq_s32(v101, v77);
        int32x4_t v105 = (int32x4_t)vrev32q_s16((int16x8_t)veorq_s8((int8x16_t)v104, vextq_s8((int8x16_t)v88, (int8x16_t)v88, 0xCuLL)));
        LODWORD(v63) = v102 ^ __ROR4__(v97, 16);
        int v103 = v63;
        HIDWORD(v63) = v63;
        int32x4_t v106 = vaddq_s32((int32x4_t)vextq_s8(v91, v91, 8uLL), v105);
        int32x4_t v107 = (int32x4_t)veorq_s8((int8x16_t)v106, (int8x16_t)v101);
        int v108 = (v63 >> 24) + v99;
        int32x4_t v110 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v107, 0xCuLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v107, 0x14uLL));
        LODWORD(v63) = v108 ^ __ROR4__(v100, 20);
        int v109 = v63;
        HIDWORD(v63) = v63;
        int v111 = v63 >> 25;
        int32x4_t v30 = vaddq_s32(v110, v104);
        int32x4_t v112 = (int32x4_t)veorq_s8((int8x16_t)v30, (int8x16_t)v105);
        int v113 = v83 + v67;
        int32x4_t v115 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v112, 8uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v112, 0x18uLL));
        int8x16_t v116 = (int8x16_t)vaddq_s32(v115, v106);
        int32x4_t v117 = (int32x4_t)veorq_s8(v116, (int8x16_t)v110);
        LODWORD(v63) = v113 ^ __ROR4__(v103, 24);
        int v114 = v63;
        HIDWORD(v63) = v63;
        int8x16_t v118 = vorrq_s8((int8x16_t)vshlq_n_s32(v117, 7uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v117, 0x19uLL));
        int v119 = (v63 >> 16) + v92;
        int32x4_t v31 = (int32x4_t)vextq_s8(v118, v118, 0xCuLL);
        int32x4_t v32 = (int32x4_t)vextq_s8(v116, v116, 8uLL);
        LODWORD(v63) = v119 ^ __ROR4__(v82, 25);
        int v120 = v63;
        HIDWORD(v63) = v63;
        int v22 = (v63 >> 20) + v113;
        LODWORD(v63) = v22 ^ __ROR4__(v114, 16);
        HIDWORD(v63) = v63;
        __int32 v34 = v63 >> 24;
        __int32 v16 = v34 + v119;
        LODWORD(v63) = v16 ^ __ROR4__(v120, 20);
        HIDWORD(v63) = v63;
        __int32 v10 = v63 >> 25;
        LODWORD(v63) = (v94 + v78) ^ __ROR4__(v68, 24);
        int v121 = v63;
        HIDWORD(v63) = v63;
        int v122 = (v63 >> 16) + v108;
        LODWORD(v63) = v122 ^ __ROR4__(v93, 25);
        int v123 = v63;
        HIDWORD(v63) = v63;
        int v23 = (v63 >> 20) + v94 + v78;
        LODWORD(v63) = v23 ^ __ROR4__(v121, 16);
        HIDWORD(v63) = v63;
        int v20 = v63 >> 24;
        __int32 v17 = v20 + v122;
        LODWORD(v63) = (v20 + v122) ^ __ROR4__(v123, 20);
        HIDWORD(v63) = v63;
        __int32 v12 = v63 >> 25;
        int v124 = v111 + v89;
        LODWORD(v63) = (v111 + v89) ^ __ROR4__(v79, 24);
        int v125 = v63;
        HIDWORD(v63) = v63;
        int v126 = (v63 >> 16) + v69;
        LODWORD(v63) = v126 ^ __ROR4__(v109, 25);
        int v127 = v63;
        HIDWORD(v63) = v63;
        int v24 = (v63 >> 20) + v124;
        LODWORD(v63) = v24 ^ __ROR4__(v125, 16);
        HIDWORD(v63) = v63;
        __int32 v19 = v63 >> 24;
        __int32 v14 = v19 + v126;
        LODWORD(v63) = (v19 + v126) ^ __ROR4__(v127, 20);
        HIDWORD(v63) = v63;
        __int32 v13 = v63 >> 25;
        int v128 = v71 + v102;
        LODWORD(v63) = v128 ^ __ROR4__(v90, 24);
        int v129 = v63;
        HIDWORD(v63) = v63;
        int v130 = (v63 >> 16) + v81;
        LODWORD(v63) = v130 ^ __ROR4__(v70, 25);
        int v131 = v63;
        HIDWORD(v63) = v63;
        int v25 = (v63 >> 20) + v128;
        LODWORD(v63) = v25 ^ __ROR4__(v129, 16);
        HIDWORD(v63) = v63;
        __int32 v35 = v63 >> 24;
        int32x4_t v33 = (int32x4_t)vextq_s8((int8x16_t)v115, (int8x16_t)v115, 4uLL);
        __int32 v15 = v35 + v130;
        LODWORD(v63) = (v35 + v130) ^ __ROR4__(v131, 20);
        HIDWORD(v63) = v63;
        __int32 v11 = v63 >> 25;
        BOOL v132 = __CFADD__(v21++, 1);
      }
      while (!v132);
      *a3 = veorq_s8(*a4, (int8x16_t)vaddq_s32(v26, (int32x4_t)xmmword_2373BA420));
      a3[1] = veorq_s8(a4[1], (int8x16_t)vaddq_s32(v27, v5));
      a3[2] = veorq_s8(a4[2], (int8x16_t)vaddq_s32(v28, v4));
      a3[3] = veorq_s8(a4[3], (int8x16_t)vaddq_s32(v29, v6));
      a3[4] = veorq_s8(a4[4], (int8x16_t)vaddq_s32(v30, (int32x4_t)xmmword_2373BA420));
      a3[5] = veorq_s8(a4[5], (int8x16_t)vaddq_s32(v31, v5));
      a3[6] = veorq_s8(a4[6], (int8x16_t)vaddq_s32(v32, v4));
      a3[7] = veorq_s8(a4[7], (int8x16_t)vaddq_s32(v33, v9));
      a3[8].i32[0] = a4[8].i32[0] ^ (v22 + 1634760805);
      a3[8].i32[1] = a4[8].i32[1] ^ (v23 + 857760878);
      a3[8].i32[2] = a4[8].i32[2] ^ (v24 + 2036477234);
      a3[8].i32[3] = a4[8].i32[3] ^ (v25 + 1797285236);
      a3[9].i32[0] = (result[1].i32[0] + v11) ^ a4[9].i32[0];
      a3[9].i32[1] = (result[1].i32[1] + v10) ^ a4[9].i32[1];
      a3[9].i32[2] = (result[1].i32[2] + v12) ^ a4[9].i32[2];
      a3[9].i32[3] = (result[1].i32[3] + v13) ^ a4[9].i32[3];
      a3[10].i32[0] = (result[2].i32[0] + v14) ^ a4[10].i32[0];
      a3[10].i32[1] = (result[2].i32[1] + v15) ^ a4[10].i32[1];
      a3[10].i32[2] = (result[2].i32[2] + v16) ^ a4[10].i32[2];
      a3[10].i32[3] = (result[2].i32[3] + v17) ^ a4[10].i32[3];
      a3[11].i32[0] = (v20 + v18 + result[3].i32[0]) ^ a4[11].i32[0];
      a3[11].i32[1] = (result[3].i32[1] + v19) ^ a4[11].i32[1];
      a3[11].i32[2] = (result[3].i32[2] + v35) ^ a4[11].i32[2];
      a3[11].i32[3] = (result[3].i32[3] + v34) ^ a4[11].i32[3];
      int32x4_t v6 = vaddq_s32(v6, (int32x4_t)xmmword_2373BA440);
      a4 += 12;
      a3 += 12;
      ++v7;
    }
    while (v7 != v8);
  }
  if (a2 % 0xC0 >= 0x40)
  {
    unint64_t v134 = (a2 % 0xC0) >> 6;
    unsigned int v133 = (int32x4_t *)&t_im[838];
    do
    {
      uint64_t v135 = -10;
      int32x4_t v136 = (int32x4_t)xmmword_2373BA420;
      int32x4_t v137 = v5;
      int32x4_t v138 = v4;
      int32x4_t v139 = v6;
      do
      {
        int32x4_t v140 = vaddq_s32(v136, v137);
        int32x4_t v141 = (int32x4_t)vrev32q_s16((int16x8_t)veorq_s8((int8x16_t)v140, (int8x16_t)v139));
        int32x4_t v142 = vaddq_s32(v138, v141);
        int32x4_t v143 = (int32x4_t)veorq_s8((int8x16_t)v142, (int8x16_t)v137);
        int32x4_t v144 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v143, 0xCuLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v143, 0x14uLL));
        int32x4_t v145 = vaddq_s32(v144, v140);
        int32x4_t v146 = (int32x4_t)veorq_s8((int8x16_t)v145, (int8x16_t)v141);
        int32x4_t v147 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v146, 8uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v146, 0x18uLL));
        int8x16_t v148 = (int8x16_t)vaddq_s32(v147, v142);
        int32x4_t v149 = (int32x4_t)veorq_s8(v148, (int8x16_t)v144);
        int8x16_t v150 = vorrq_s8((int8x16_t)vshlq_n_s32(v149, 7uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v149, 0x19uLL));
        int32x4_t v151 = (int32x4_t)vextq_s8(v150, v150, 4uLL);
        int32x4_t v152 = vaddq_s32(v151, v145);
        int32x4_t v153 = (int32x4_t)vrev32q_s16((int16x8_t)veorq_s8((int8x16_t)v152, vextq_s8((int8x16_t)v147, (int8x16_t)v147, 0xCuLL)));
        int32x4_t v154 = vaddq_s32((int32x4_t)vextq_s8(v148, v148, 8uLL), v153);
        int32x4_t v155 = (int32x4_t)veorq_s8((int8x16_t)v154, (int8x16_t)v151);
        int32x4_t v156 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v155, 0xCuLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v155, 0x14uLL));
        int32x4_t v136 = vaddq_s32(v156, v152);
        int32x4_t v157 = (int32x4_t)veorq_s8((int8x16_t)v136, (int8x16_t)v153);
        int32x4_t v158 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v157, 8uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v157, 0x18uLL));
        int8x16_t v159 = (int8x16_t)vaddq_s32(v158, v154);
        int32x4_t v160 = (int32x4_t)veorq_s8(v159, (int8x16_t)v156);
        int8x16_t v161 = vorrq_s8((int8x16_t)vshlq_n_s32(v160, 7uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v160, 0x19uLL));
        int32x4_t v137 = (int32x4_t)vextq_s8(v161, v161, 0xCuLL);
        int32x4_t v138 = (int32x4_t)vextq_s8(v159, v159, 8uLL);
        int32x4_t v139 = (int32x4_t)vextq_s8((int8x16_t)v158, (int8x16_t)v158, 4uLL);
        BOOL v132 = __CFADD__(v135++, 1);
      }
      while (!v132);
      *a3 = veorq_s8(*a4, (int8x16_t)vaddq_s32(v136, (int32x4_t)xmmword_2373BA420));
      a3[1] = veorq_s8(a4[1], (int8x16_t)vaddq_s32(v137, v5));
      a3[2] = veorq_s8(a4[2], (int8x16_t)vaddq_s32(v138, v4));
      a3[3] = veorq_s8(a4[3], (int8x16_t)vaddq_s32(v139, v6));
      int32x4_t v6 = vaddq_s32(v6, (int32x4_t)xmmword_2373BA430);
      a4 += 4;
      a3 += 4;
      --v134;
    }
    while (v134);
  }
  else
  {
    unsigned int v133 = (int32x4_t *)(t_im + 3352);
  }
  unint64_t v162 = a2 & 0x3F;
  if ((a2 & 0x3F) != 0)
  {
    int32x4_t v163 = v133[66];
    uint64_t v164 = -10;
    int32x4_t v165 = v5;
    int32x4_t v166 = v4;
    int32x4_t v167 = v6;
    do
    {
      int32x4_t v168 = vaddq_s32(v163, v165);
      int32x4_t v169 = (int32x4_t)vrev32q_s16((int16x8_t)veorq_s8((int8x16_t)v168, (int8x16_t)v167));
      int32x4_t v170 = vaddq_s32(v166, v169);
      int32x4_t v171 = (int32x4_t)veorq_s8((int8x16_t)v170, (int8x16_t)v165);
      int32x4_t v172 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v171, 0xCuLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v171, 0x14uLL));
      int32x4_t v173 = vaddq_s32(v172, v168);
      int32x4_t v174 = (int32x4_t)veorq_s8((int8x16_t)v173, (int8x16_t)v169);
      int32x4_t v175 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v174, 8uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v174, 0x18uLL));
      int8x16_t v176 = (int8x16_t)vaddq_s32(v175, v170);
      int32x4_t v177 = (int32x4_t)veorq_s8(v176, (int8x16_t)v172);
      int8x16_t v178 = vorrq_s8((int8x16_t)vshlq_n_s32(v177, 7uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v177, 0x19uLL));
      int32x4_t v179 = (int32x4_t)vextq_s8(v178, v178, 4uLL);
      int32x4_t v180 = vaddq_s32(v179, v173);
      int32x4_t v181 = (int32x4_t)vrev32q_s16((int16x8_t)veorq_s8((int8x16_t)v180, vextq_s8((int8x16_t)v175, (int8x16_t)v175, 0xCuLL)));
      int32x4_t v182 = vaddq_s32((int32x4_t)vextq_s8(v176, v176, 8uLL), v181);
      int32x4_t v183 = (int32x4_t)veorq_s8((int8x16_t)v182, (int8x16_t)v179);
      int32x4_t v184 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v183, 0xCuLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v183, 0x14uLL));
      int32x4_t v163 = vaddq_s32(v184, v180);
      int32x4_t v185 = (int32x4_t)veorq_s8((int8x16_t)v163, (int8x16_t)v181);
      int32x4_t v186 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v185, 8uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v185, 0x18uLL));
      int8x16_t v187 = (int8x16_t)vaddq_s32(v186, v182);
      int32x4_t v188 = (int32x4_t)veorq_s8(v187, (int8x16_t)v184);
      int8x16_t v189 = vorrq_s8((int8x16_t)vshlq_n_s32(v188, 7uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v188, 0x19uLL));
      int32x4_t v165 = (int32x4_t)vextq_s8(v189, v189, 0xCuLL);
      int32x4_t v166 = (int32x4_t)vextq_s8(v187, v187, 8uLL);
      int32x4_t v167 = (int32x4_t)vextq_s8((int8x16_t)v186, (int8x16_t)v186, 4uLL);
      BOOL v132 = __CFADD__(v164++, 1);
    }
    while (!v132);
    if (v162 < 0x10)
    {
      v199[0] = vaddq_s32(v163, v133[66]);
    }
    else
    {
      *a3 = veorq_s8(*a4, (int8x16_t)vaddq_s32(v163, v133[66]));
      if (v162 < 0x20)
      {
        v199[1] = vaddq_s32(v165, v5);
      }
      else
      {
        a3[1] = veorq_s8(a4[1], (int8x16_t)vaddq_s32(v165, v5));
        if (v162 < 0x30)
        {
          v199[2] = vaddq_s32(v166, v4);
        }
        else
        {
          a3[2] = veorq_s8(a4[2], (int8x16_t)vaddq_s32(v166, v4));
          v199[3] = vaddq_s32(v167, v6);
        }
      }
    }
    unint64_t v190 = a2 & 0x30;
    unint64_t v191 = v162 - v190;
    if (v162 > v190)
    {
      BOOL v192 = &a3->i8[v190];
      BOOL v193 = (char *)v199 + v190;
      BOOL v194 = &a4->i8[v190];
      do
      {
        char v196 = *v194++;
        char v195 = v196;
        char v197 = *v193++;
        *v192++ = v197 ^ v195;
        --v191;
      }
      while (v191);
    }
  }
  result[3].i32[0] = v6.i32[0];
  return result;
}

uint64_t ccpoly1305_init(uint64_t a1, uint64_t a2)
{
  BOOL v5 = timingsafe_enable_if_supported();
  ccpoly1305_init_internal(a1, a2);
  cc_disable_dit_with_sb((unsigned int *)&v5);
  return 0;
}

uint64_t ccpoly1305_init_internal(uint64_t result, uint64_t a2)
{
  uint64_t v2 = 0;
  unsigned int v3 = *(_DWORD *)(a2 + 4);
  unsigned int v4 = *(_DWORD *)(a2 + 8);
  unsigned int v5 = *(_DWORD *)(a2 + 12);
  int v6 = (*(void *)a2 >> 26) & 0x3FFFF03;
  *(_DWORD *)uint64_t result = *(_DWORD *)a2 & 0x3FFFFFF;
  *(_DWORD *)(result + 4) = v6;
  int v7 = (__PAIR64__(v4, v3) >> 20) & 0x3FFC0FF;
  unint64_t v8 = (__PAIR64__(v5, v4) >> 14) & 0x3F03FFF;
  *(_DWORD *)(result + 8) = v7;
  *(_DWORD *)(result + 12) = v8;
  int v9 = (v5 >> 8) & 0xFFFFF;
  *(_DWORD *)(result + 16) = v9;
  *(_DWORD *)(result + 20) = 5 * v6;
  *(_DWORD *)(result + 24) = 5 * v7;
  *(_DWORD *)(result + 28) = 5 * v8;
  *(_DWORD *)(result + 32) = 5 * v9;
  *(void *)(result + 72) = 0;
  *(void *)(result + 44) = 0;
  *(void *)(result + 36) = 0;
  *(_DWORD *)(result + 52) = 0;
  do
  {
    *(unsigned char *)(result + 80 + v2) = *(unsigned char *)(a2 + 16 + v2);
    ++v2;
  }
  while (v2 != 16);
  return result;
}

uint64_t ccpoly1305_update(unsigned int *a1, unint64_t a2, unsigned int *a3)
{
  BOOL v7 = timingsafe_enable_if_supported();
  ccpoly1305_update_internal(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return 0;
}

unsigned int *ccpoly1305_update_internal(unsigned int *result, unint64_t a2, unsigned int *a3)
{
  unsigned int v3 = a3;
  unint64_t v4 = a2;
  unsigned int v5 = result;
  uint64_t v6 = *((void *)result + 9);
  if (v6)
  {
    unint64_t v7 = 16 - v6;
    if (16 - v6 >= a2) {
      unint64_t v7 = a2;
    }
    if (v7)
    {
      unint64_t v8 = result + 14;
      int v9 = a3;
      unint64_t v10 = v7;
      do
      {
        char v11 = *(unsigned char *)v9;
        int v9 = (unsigned int *)((char *)v9 + 1);
        *((unsigned char *)v8 + *((void *)result + 9)) = v11;
        unint64_t v8 = (unsigned int *)((char *)v8 + 1);
        --v10;
      }
      while (v10);
      uint64_t v6 = *((void *)result + 9);
    }
    uint64_t v12 = v6 + v7;
    *((void *)result + 9) = v12;
    unint64_t v4 = a2 - v7;
    unsigned int v3 = (unsigned int *)((char *)a3 + v7);
    if (v12 == 16)
    {
      uint64_t result = _ccpoly1305_update(result, 0x10uLL, result + 14);
      *((void *)v5 + 9) = 0;
    }
  }
  if (v4 >= 0x10)
  {
    uint64_t result = _ccpoly1305_update(v5, v4 & 0xFFFFFFFFFFFFFFF0, v3);
    unsigned int v3 = (unsigned int *)((char *)v3 + (v4 & 0xFFFFFFFFFFFFFFF0));
    v4 &= 0xFu;
  }
  if (v4)
  {
    for (uint64_t i = 0; i != v4; ++i)
      *((unsigned char *)v5 + i + 56) = *((unsigned char *)v3 + i);
    *((void *)v5 + 9) = v4;
  }
  return result;
}

uint64_t ccpoly1305_final(uint64_t a1, uint64_t a2)
{
  BOOL v5 = timingsafe_enable_if_supported();
  ccpoly1305_final_internal(a1, a2);
  cc_disable_dit_with_sb((unsigned int *)&v5);
  return 0;
}

uint64_t ccpoly1305_final_internal(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 72);
  if (v4) {
    _ccpoly1305_update((unsigned int *)a1, v4, (unsigned int *)(a1 + 56));
  }
  unsigned int v5 = *(_DWORD *)(a1 + 36);
  int v6 = v5 & 0x3FFFFFF;
  unsigned int v7 = *(_DWORD *)(a1 + 40) + (v5 >> 26);
  int v8 = v7 & 0x3FFFFFF;
  unsigned int v9 = *(_DWORD *)(a1 + 44) + (v7 >> 26);
  int v10 = v9 & 0x3FFFFFF;
  unsigned int v11 = *(_DWORD *)(a1 + 48) + (v9 >> 26);
  int v12 = v11 & 0x3FFFFFF;
  unsigned int v13 = *(_DWORD *)(a1 + 52) + (v11 >> 26);
  unsigned int v14 = 5 * (v13 >> 26) + v6;
  unsigned int v15 = v8 + ((v14 + 5) >> 26);
  unsigned int v16 = v10 + (v15 >> 26);
  unsigned int v17 = v12 + (v16 >> 26);
  signed int v18 = (v13 | 0xFC000000) + (v17 >> 26);
  uint64_t result = (v18 >> 31) - 1;
  int v20 = v14 & (v18 >> 31) | result & 0x3FFFFFF & (v14 + 5);
  unsigned int v21 = v8 & (v18 >> 31) | result & 0x3FFFFFF & v15;
  *(_DWORD *)(a1 + 36) = v20;
  *(_DWORD *)(a1 + 40) = v21;
  unsigned int v22 = v10 & (v18 >> 31) | result & 0x3FFFFFF & v16;
  unsigned int v23 = v12 & (v18 >> 31) | result & 0x3FFFFFF & v17;
  *(_DWORD *)(a1 + 44) = v22;
  *(_DWORD *)(a1 + 48) = v23;
  int v24 = result & v18 | v13 & (v18 >> 31) & 0x3FFFFFF;
  *(_DWORD *)(a1 + 52) = v24;
  int v25 = v20 | (v21 << 26);
  int v26 = *(_DWORD *)(a1 + 80);
  uint64_t v27 = *(unsigned int *)(a1 + 84);
  uint64_t v28 = (v21 >> 6) | (v22 << 20);
  uint64_t v29 = *(unsigned int *)(a1 + 92);
  unint64_t v30 = ((v22 >> 12) | (v23 << 14)) + (unint64_t)*(unsigned int *)(a1 + 88);
  *(_DWORD *)a2 = v25 + v26;
  unint64_t v31 = v27 + __CFADD__(v25, v26) + v28;
  *(unsigned char *)(a2 + 7) = BYTE3(v31);
  *(unsigned char *)(a2 + 6) = BYTE2(v31);
  *(_WORD *)(a2 + 4) = v31;
  unint64_t v32 = v30 + HIDWORD(v31);
  *(unsigned char *)(a2 + 11) = BYTE3(v32);
  *(unsigned char *)(a2 + 10) = BYTE2(v32);
  *(_WORD *)(a2 + 8) = v32;
  unint64_t v33 = ((v23 >> 18) | (v24 << 8)) + v29 + HIDWORD(v32);
  *(unsigned char *)(a2 + 15) = BYTE3(v33);
  *(unsigned char *)(a2 + 14) = BYTE2(v33);
  *(_WORD *)(a2 + 12) = v33;
  return result;
}

uint64_t ccpoly1305(uint64_t a1, unint64_t a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8C08];
  BOOL v9 = timingsafe_enable_if_supported();
  memset(v10, 0, sizeof(v10));
  ccpoly1305_init_internal((uint64_t)v10, a1);
  ccpoly1305_update_internal((unsigned int *)v10, a2, a3);
  ccpoly1305_final_internal((uint64_t)v10, a4);
  cc_disable_dit_with_sb((unsigned int *)&v9);
  return 0;
}

void *ccchacha20poly1305_info()
{
  return &ccchacha20poly1305_info_default;
}

uint64_t ccchacha20poly1305_init(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  BOOL v6 = timingsafe_enable_if_supported();
  ccchacha20poly1305_init_internal(a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v6);
  return 0;
}

double ccchacha20poly1305_init_internal(uint64_t a1, _DWORD *a2)
{
  double result = 1.99237483e-62;
  *(_OWORD *)a1 = xmmword_2373BA420;
  *(_DWORD *)(a1 + 16) = *a2;
  *(_DWORD *)(a1 + 20) = a2[1];
  *(_DWORD *)(a1 + 24) = a2[2];
  *(_DWORD *)(a1 + 28) = a2[3];
  *(_DWORD *)(a1 + 32) = a2[4];
  *(_DWORD *)(a1 + 36) = a2[5];
  *(_DWORD *)(a1 + 40) = a2[6];
  unsigned int v3 = a2[7];
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0;
  *(unsigned char *)(a1 + 248) = 1;
  *(void *)(a1 + 44) = v3;
  *(void *)(a1 + 128) = 0;
  return result;
}

uint64_t ccchacha20poly1305_reset(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 232) = 0;
  *(void *)(a2 + 240) = 0;
  *(unsigned char *)(a2 + 248) = 1;
  *(_DWORD *)(a2 + 48) = 0;
  *(void *)(a2 + 128) = 0;
  return 0;
}

uint64_t ccchacha20poly1305_setnonce(uint64_t a1, int32x4_t *a2, __int32 *a3)
{
  BOOL v7 = timingsafe_enable_if_supported();
  uint64_t v5 = ccchacha20poly1305_setnonce_internal(a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return v5;
}

uint64_t ccchacha20poly1305_setnonce_internal(int32x4_t *a1, __int32 *a2)
{
  uint64_t v5 = *MEMORY[0x263EF8C08];
  if (a1[15].i8[8] != 1) {
    return 1;
  }
  a1[3].i32[1] = *a2;
  a1[3].i32[2] = a2[1];
  a1[3].i32[3] = a2[2];
  _ccchacha20_xor(a1, 0x40uLL, v4, kZero64);
  ccpoly1305_init_internal((uint64_t)&a1[8].i64[1], (uint64_t)v4);
  uint64_t result = 0;
  a1[15].i8[8] = 2;
  return result;
}

uint64_t ccchacha20poly1305_incnonce()
{
  BOOL v1 = timingsafe_enable_if_supported();
  cc_disable_dit_with_sb((unsigned int *)&v1);
  return 1;
}

uint64_t ccchacha20poly1305_aad(uint64_t a1, uint64_t a2, unint64_t a3, unsigned int *a4)
{
  BOOL v9 = timingsafe_enable_if_supported();
  if (*(unsigned char *)(a2 + 248) == 2)
  {
    ccpoly1305_update_internal((unsigned int *)(a2 + 136), a3, a4);
    uint64_t v7 = 0;
    *(void *)(a2 + 232) += a3;
  }
  else
  {
    uint64_t v7 = 1;
  }
  cc_disable_dit_with_sb((unsigned int *)&v9);
  return v7;
}

uint64_t ccchacha20poly1305_encrypt(uint64_t a1, int32x4_t *a2, unint64_t a3, int8x16_t *a4, int8x16_t *a5)
{
  BOOL v11 = timingsafe_enable_if_supported();
  uint64_t v9 = ccchacha20poly1305_encrypt_internal(a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v11);
  return v9;
}

uint64_t ccchacha20poly1305_encrypt_internal(int32x4_t *a1, unint64_t a2, int8x16_t *a3, int8x16_t *a4)
{
  int v8 = a1[15].u8[8];
  if (v8 != 3)
  {
    if (v8 != 2) {
      return 1;
    }
    ccpoly1305_update_internal(&a1[8].u32[2], -a1[14].i32[2] & 0xFLL, (unsigned int *)kZero64);
    a1[15].i8[8] = 3;
  }
  uint64_t v9 = a1[15].i64[0];
  uint64_t result = 1;
  if (!__CFADD__(v9, a2) && v9 + a2 <= 0x3FFFFFFFC0)
  {
    ccchacha20_update_internal(a1, a2, a3, a4);
    ccpoly1305_update_internal(&a1[8].u32[2], a2, (unsigned int *)a4);
    uint64_t result = 0;
    a1[15].i64[0] += a2;
  }
  return result;
}

uint64_t ccchacha20poly1305_decrypt(uint64_t a1, int32x4_t *a2, unint64_t a3, int8x16_t *a4, int8x16_t *a5)
{
  BOOL v11 = timingsafe_enable_if_supported();
  uint64_t v9 = ccchacha20poly1305_decrypt_internal(a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v11);
  return v9;
}

uint64_t ccchacha20poly1305_decrypt_internal(int32x4_t *a1, unint64_t a2, int8x16_t *a3, int8x16_t *a4)
{
  int v8 = a1[15].u8[8];
  if (v8 != 4)
  {
    if (v8 != 2) {
      return 1;
    }
    ccpoly1305_update_internal(&a1[8].u32[2], -a1[14].i32[2] & 0xFLL, (unsigned int *)kZero64);
    a1[15].i8[8] = 4;
  }
  uint64_t v9 = a1[15].i64[0];
  uint64_t result = 1;
  if (!__CFADD__(v9, a2) && v9 + a2 <= 0x3FFFFFFFC0)
  {
    ccpoly1305_update_internal(&a1[8].u32[2], a2, (unsigned int *)a3);
    ccchacha20_update_internal(a1, a2, a3, a4);
    uint64_t result = 0;
    a1[15].i64[0] += a2;
  }
  return result;
}

uint64_t ccchacha20poly1305_finalize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v7 = timingsafe_enable_if_supported();
  uint64_t v5 = ccchacha20poly1305_finalize_internal(a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return v5;
}

uint64_t ccchacha20poly1305_finalize_internal(uint64_t a1, uint64_t a2)
{
  v6[1] = *MEMORY[0x263EF8C08];
  int v4 = *(unsigned __int8 *)(a1 + 248);
  if (v4 != 3)
  {
    if (v4 != 2) {
      return 1;
    }
    ccpoly1305_update_internal((unsigned int *)(a1 + 136), -*(_DWORD *)(a1 + 232) & 0xFLL, (unsigned int *)kZero64);
    *(unsigned char *)(a1 + 248) = 3;
  }
  ccpoly1305_update_internal((unsigned int *)(a1 + 136), -*(_DWORD *)(a1 + 240) & 0xFLL, (unsigned int *)kZero64);
  v6[0] = *(void *)(a1 + 232);
  ccpoly1305_update_internal((unsigned int *)(a1 + 136), 8uLL, (unsigned int *)v6);
  v6[0] = *(void *)(a1 + 240);
  ccpoly1305_update_internal((unsigned int *)(a1 + 136), 8uLL, (unsigned int *)v6);
  ccpoly1305_final_internal(a1 + 136, a2);
  uint64_t result = 0;
  *(unsigned char *)(a1 + 248) = 5;
  return result;
}

uint64_t ccchacha20poly1305_verify(uint64_t a1, uint64_t a2, char *a3)
{
  BOOL v7 = timingsafe_enable_if_supported();
  uint64_t v5 = ccchacha20poly1305_verify_internal(a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return v5;
}

uint64_t ccchacha20poly1305_verify_internal(uint64_t a1, char *a2)
{
  v7[1] = *MEMORY[0x263EF8C08];
  int v4 = *(unsigned __int8 *)(a1 + 248);
  if (v4 != 4)
  {
    if (v4 != 2) {
      return 1;
    }
    ccpoly1305_update_internal((unsigned int *)(a1 + 136), -*(_DWORD *)(a1 + 232) & 0xFLL, (unsigned int *)kZero64);
    *(unsigned char *)(a1 + 248) = 4;
  }
  ccpoly1305_update_internal((unsigned int *)(a1 + 136), -*(_DWORD *)(a1 + 240) & 0xFLL, (unsigned int *)kZero64);
  v7[0] = *(void *)(a1 + 232);
  ccpoly1305_update_internal((unsigned int *)(a1 + 136), 8uLL, (unsigned int *)v7);
  v7[0] = *(void *)(a1 + 240);
  ccpoly1305_update_internal((unsigned int *)(a1 + 136), 8uLL, (unsigned int *)v7);
  ccpoly1305_final_internal(a1 + 136, (uint64_t)v6);
  *(unsigned char *)(a1 + 248) = 5;
  if (cc_cmp_safe_internal(16, v6, a2)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t ccchacha20poly1305_encrypt_oneshot(uint64_t a1, int32x4_t *a2, __int32 *a3, unint64_t a4, unsigned int *a5, unint64_t a6, int8x16_t *a7, int8x16_t *a8, uint64_t a9)
{
  uint64_t v24 = *MEMORY[0x263EF8C08];
  BOOL v19 = timingsafe_enable_if_supported();
  int32x4_t v16 = *a2;
  int32x4_t v17 = a2[1];
  __s[0] = (int32x4_t)xmmword_2373BA420;
  __s[1] = v16;
  uint64_t v21 = 0;
  long long v23 = 0u;
  long long __s[2] = v17;
  memset(&__s[3], 0, 176);
  uint64_t v22 = 0;
  *(void *)&long long v23 = 0;
  BYTE8(v23) = 1;
  ccchacha20poly1305_setnonce_internal(__s, a3);
  if (BYTE8(v23) == 2)
  {
    ccpoly1305_update_internal(&__s[8].u32[2], a4, a5);
    v22 += a4;
  }
  ccchacha20poly1305_encrypt_internal(__s, a6, a7, a8);
  ccchacha20poly1305_finalize_internal((uint64_t)__s, a9);
  cc_clear(0x88uLL, __s);
  cc_disable_dit_with_sb((unsigned int *)&v19);
  return 0;
}

uint64_t ccchacha20poly1305_decrypt_oneshot(uint64_t a1, int32x4_t *a2, __int32 *a3, unint64_t a4, unsigned int *a5, unint64_t a6, int8x16_t *a7, int8x16_t *a8, char *a9)
{
  uint64_t v25 = *MEMORY[0x263EF8C08];
  BOOL v20 = timingsafe_enable_if_supported();
  int32x4_t v16 = *a2;
  int32x4_t v17 = a2[1];
  __s[0] = (int32x4_t)xmmword_2373BA420;
  __s[1] = v16;
  uint64_t v22 = 0;
  long long v24 = 0u;
  long long __s[2] = v17;
  memset(&__s[3], 0, 176);
  uint64_t v23 = 0;
  *(void *)&long long v24 = 0;
  BYTE8(v24) = 1;
  ccchacha20poly1305_setnonce_internal(__s, a3);
  if (BYTE8(v24) == 2)
  {
    ccpoly1305_update_internal(&__s[8].u32[2], a4, a5);
    v23 += a4;
  }
  ccchacha20poly1305_decrypt_internal(__s, a6, a7, a8);
  uint64_t v18 = ccchacha20poly1305_verify_internal((uint64_t)__s, a9);
  cc_clear(0x88uLL, __s);
  cc_disable_dit_with_sb((unsigned int *)&v20);
  return v18;
}

unsigned int *_ccpoly1305_update(unsigned int *result, unint64_t a2, unsigned int *a3)
{
  int v4 = result;
  uint64_t v40 = *MEMORY[0x263EF8C08];
  if (a2 < 0x10) {
    goto LABEL_5;
  }
  unsigned int v5 = result[9];
  unsigned int v6 = result[10];
  unsigned int v7 = result[11];
  unsigned int v8 = result[12];
  unsigned int v9 = result[13];
LABEL_3:
  uint64_t v10 = *a3;
  uint64_t v11 = a3[1];
  uint64_t v12 = a3[2];
  uint64_t v13 = a3[3];
  a3 += 4;
  a2 -= 16;
  unsigned int v14 = v5 + (v10 & 0x3FFFFFF);
  unsigned int v15 = (((v10 | (unint64_t)(v11 << 32)) >> 26) & 0x3FFFFFF) + v6;
  v4[9] = v14;
  v4[10] = v15;
  unsigned int v16 = (((v11 | (unint64_t)(v12 << 32)) >> 20) & 0x3FFFFFF) + v7;
  unsigned int v17 = v8 + (((v12 | (unint64_t)(v13 << 32)) >> 14) & 0x3FFFFFF);
  v4[11] = v16;
  v4[12] = v17;
  unsigned int v18 = v9 + (v13 >> 8) + 0x1000000;
  for (v4[13] = v18; ; unsigned int v18 = v4[13] + (v39 >> 8))
  {
    unsigned int v19 = v4[1];
    unsigned int v21 = v4[7];
    unsigned int v20 = v4[8];
    unsigned int v22 = v4[6];
    unsigned int v24 = v4[3];
    unsigned int v23 = v4[4];
    unint64_t v25 = *v4 * (unint64_t)v14
        + v20 * (unint64_t)v15
        + v21 * (unint64_t)v16
        + v22 * (unint64_t)v17
        + v4[5] * (unint64_t)v18;
    unsigned int v26 = v4[2];
    unint64_t v27 = *v4 * (unint64_t)v18;
    int v28 = v25 & 0x3FFFFFF;
    unint64_t v29 = *v4 * (unint64_t)v15
        + v20 * (unint64_t)v16
        + v21 * (unint64_t)v17
        + v22 * (unint64_t)v18
        + v19 * (unint64_t)v14
        + (v25 >> 26);
    unsigned int v6 = v29 & 0x3FFFFFF;
    uint64_t result = (unsigned int *)(*v4 * (unint64_t)v16 + v20 * (unint64_t)v17);
    unint64_t v30 = (unint64_t)result
        + v21 * (unint64_t)v18
        + v19 * (unint64_t)v15
        + v26 * (unint64_t)v14
        + (v29 >> 26);
    unsigned int v7 = v30 & 0x3FFFFFF;
    unint64_t v31 = *v4 * (unint64_t)v17
        + v20 * (unint64_t)v18
        + v19 * (unint64_t)v16
        + v26 * (unint64_t)v15
        + v24 * (unint64_t)v14
        + (v30 >> 26);
    unsigned int v8 = v31 & 0x3FFFFFF;
    v4[11] = v30 & 0x3FFFFFF;
    v4[12] = v31 & 0x3FFFFFF;
    unint64_t v32 = v27
        + v19 * (unint64_t)v17
        + v26 * (unint64_t)v16
        + v24 * (unint64_t)v15
        + v23 * (unint64_t)v14
        + (v31 >> 26);
    unsigned int v9 = v32 & 0x3FFFFFF;
    v4[13] = v32 & 0x3FFFFFF;
    unsigned int v5 = 5 * (v32 >> 26) + v28;
    v4[9] = v5;
    v4[10] = v6;
    if (a2 > 0xF) {
      goto LABEL_3;
    }
LABEL_5:
    if (!a2) {
      break;
    }
    for (uint64_t i = 0; i != a2; ++i)
      *((unsigned char *)&v36 + i) = *((unsigned char *)a3 + i);
    *((unsigned char *)&v36 + a2) = 1;
    if ((unint64_t)(i - 1) <= 0xD)
    {
      __int32 v34 = (char *)&v36 + i + 1;
      unint64_t v35 = 14 - a2;
      if (a2 > 0xE) {
        unint64_t v35 = 0;
      }
      bzero(v34, v35 + 1);
    }
    a2 = 0;
    unsigned int v14 = v4[9] + (v36 & 0x3FFFFFF);
    unsigned int v15 = (((v36 | ((unint64_t)v37 << 32)) >> 26) & 0x3FFFFFF) + v4[10];
    unsigned int v16 = (((v37 | ((unint64_t)v38 << 32)) >> 20) & 0x3FFFFFF) + v4[11];
    unsigned int v17 = v4[12] + (((v38 | ((unint64_t)v39 << 32)) >> 14) & 0x3FFFFFF);
  }
  return result;
}

uint64_t ccvrf_irtf_ed25519_derive_scalar_internal(uint64_t a1, char *a2, void *a3, void *a4)
{
  uint64_t v10 = *MEMORY[0x263EF8C08];
  ccdigest_internal(*(void *)(a1 + 40), *(void *)(a1 + 32), a2, (uint64_t)__src);
  __src[0] &= 0xF8u;
  char v9 = v9 & 0x3F | 0x40;
  memcpy(a3, __src, *(void *)(a1 + 32));
  memcpy(a4, &__src[*(void *)(a1 + 32)], *(void *)(a1 + 32));
  cc_clear(0x40uLL, __src);
  return 0;
}

uint64_t ccvrf_irtf_ed25519_derive_public_key_internal(uint64_t a1, char *a2, _DWORD *a3)
{
  uint64_t v7 = *MEMORY[0x263EF8C08];
  ccdigest_internal(*(void *)(a1 + 40), *(void *)(a1 + 32), a2, (uint64_t)&__s);
  __s.i8[0] &= 0xF8u;
  char v6 = v6 & 0x3F | 0x40;
  ge_scalarmult_base(a3, &__s);
  cc_clear(0x40uLL, &__s);
  return 0;
}

uint64_t ccvrf_irtf_ed25519_derive_public_key(uint64_t a1, char *a2, uint64_t a3)
{
  memset(v5, 0, sizeof(v5));
  ccvrf_irtf_ed25519_derive_public_key_internal(a1, a2, v5);
  ge_p3_tobytes(a3, (int *)v5);
  return 0;
}

uint64_t ccvrf_derive_public_key(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  if (ccvrf_sizeof_secret_key(a1) == a2 && ccvrf_sizeof_public_key(a1) == a4) {
    uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56))(a1, a3, a5);
  }
  else {
    uint64_t v10 = 4294967289;
  }
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccsae_generate_confirmation(void *a1, uint64_t a2, uint64_t a3)
{
  BOOL v11 = timingsafe_enable_if_supported();
  char v6 = (void *)*a1;
  v9[0] = cc_malloc_clear(8 * *(void *)*a1);
  v9[1] = *v6;
  void v9[2] = 0;
  void v9[3] = cc_ws_alloc;
  uint64_t v10 = cc_ws_free;
  if (v9[0])
  {
    confirmation_uint64_t ws = ccsae_generate_confirmation_ws((uint64_t)v9, (uint64_t)a1, a2, a3);
    v10((uint64_t)v9);
  }
  else
  {
    confirmation_uint64_t ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v11);
  return confirmation_ws;
}

uint64_t ccsae_generate_confirmation_ws(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v23[1] = *MEMORY[0x263EF8C08];
  int v4 = *(unsigned __int8 *)(a2 + 24);
  if (v4 != CCSAE_STATE_COMMIT_BOTH && v4 != CCSAE_STATE_CONFIRMATION_VERIFIED) {
    return 4294967210;
  }
  unint64_t v10 = **(void **)a2;
  uint64_t v11 = cczp_bitlen(*(void *)a2);
  v23[0] = v23;
  unint64_t v12 = (unint64_t)(v11 + 7) >> 3;
  uint64_t v13 = *(void *)(a2 + 16);
  MEMORY[0x270FA53B0](v11, v14, v15, v16);
  unsigned int v18 = (void *)((char *)v23 - v17);
  uint64_t v19 = *(void *)(a1 + 16);
  unsigned int v20 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v10);
  size_t v21 = ccsae_sizeof_kck_internal(a2);
  cchmac_init_internal(v13, v18, v21, (char *)(a2 + 48));
  cchmac_update_internal(v13, v18, 2, a3);
  ccn_write_uint_padded_internal(v10, (unint64_t *)(a2 + 144 + 24 * **(void **)a2), v12, v20);
  cchmac_update_internal(v13, v18, v12, v20);
  ccn_write_uint_padded_internal(v10, (unint64_t *)(a2 + 144 + 40 * **(void **)a2), v12, v20);
  cchmac_update_internal(v13, v18, v12, v20);
  ccn_write_uint_padded_internal(v10, (unint64_t *)(a2 + 144 + 48 * **(void **)a2), v12, v20);
  cchmac_update_internal(v13, v18, v12, v20);
  ccn_write_uint_padded_internal(v10, (unint64_t *)(a2 + 144 + 16 * **(void **)a2), v12, v20);
  cchmac_update_internal(v13, v18, v12, v20);
  ccn_write_uint_padded_internal(v10, (unint64_t *)(a2 + 144 + 56 * **(void **)a2), v12, v20);
  cchmac_update_internal(v13, v18, v12, v20);
  ccn_write_uint_padded_internal(v10, (unint64_t *)(a2 + 144 + (**(void **)a2 << 6)), v12, v20);
  cchmac_update_internal(v13, v18, v12, v20);
  cchmac_final_internal(v13, v18, a4);
  cc_clear(((*(void *)(v13 + 8) + *(void *)(v13 + 16) + 19) & 0xFFFFFFFFFFFFFFF8) + *(void *)(v13 + 8), v18);
  *(unsigned char *)(a2 + 24) |= CCSAE_STATE_CONFIRMATION_GENERATED;
  *(void *)(a1 + 16) = v19;
  return 0;
}

uint64_t ccrsa_pub_crypt_ws(uint64_t a1, unint64_t *a2, uint64_t *a3, unint64_t *a4)
{
  unsigned int v8 = a2 + 3;
  unint64_t v9 = *a2;
  unint64_t v10 = ccn_bitlen_internal(*a2, &a2[2 * *a2 + 4]);
  if (v9) {
    BOOL v11 = v10 >= 2;
  }
  else {
    BOOL v11 = 0;
  }
  if (!v11 || ccn_n(v9, (uint64_t)v8) <= 1 && *v8 < 2uLL) {
    return 4294967268;
  }
  uint64_t v13 = (uint64_t)&v8[2 * *a2 + 1];

  return cczp_mm_power_fast_ws(a1, a2, a3, a4, v13);
}

uint64_t ccrsa_pub_crypt(unint64_t *a1, uint64_t *a2, unint64_t *a3)
{
  BOOL v16 = timingsafe_enable_if_supported();
  unint64_t v6 = *a1;
  uint64_t v7 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v8 = sizeof_struct_ccpolyzp_po2cyc();
  v14[0] = cc_malloc_clear(8 * ((v7 + v8 - 1) / v8 + 11 * v6) + 8);
  unint64_t v9 = *a1;
  uint64_t v10 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v11 = sizeof_struct_ccpolyzp_po2cyc();
  v14[1] = (v10 + v11 - 1) / v11 + 11 * v9 + 1;
  _OWORD v14[2] = 0;
  void v14[3] = cc_ws_alloc;
  uint64_t v15 = cc_ws_free;
  if (v14[0])
  {
    uint64_t v12 = ccrsa_pub_crypt_ws((uint64_t)v14, a1, a2, a3);
    v15((uint64_t)v14);
  }
  else
  {
    uint64_t v12 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v12;
}

uint64_t fipspost_post_integrity(char a1, char *a2)
{
  uint64_t v11 = *MEMORY[0x263EF8C08];
  if (fipspost_get_hmac(a2, __s, 0))
  {
    uint64_t v3 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: could not create the hash\n", v3, "fipspost_post_integrity", 27);
    uint64_t v4 = 4294967224;
  }
  else
  {
    if ((a1 & 0x10) != 0) {
      __s[0] ^= 1u;
    }
    if (cc_cmp_safe(32, __s, fipspost_precalc_hmac))
    {
      uint64_t v5 = mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: MAC generated: ", v5, "fipspost_post_integrity", 37);
      for (uint64_t i = 0; i != 32; ++i)
        printf("%02X", __s[i]);
      putchar(10);
      uint64_t v7 = mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d:   In variable: ", v7, "fipspost_post_integrity", 38);
      for (uint64_t j = 0; j != 32; ++j)
        printf("%02X", fipspost_precalc_hmac[j]);
      putchar(10);
      uint64_t v4 = 4294967222;
    }
    else
    {
      uint64_t v4 = 0;
    }
  }
  cc_clear(0x20uLL, __s);
  return v4;
}

void *cc_malloc_clear(size_t a1)
{
  uint64_t v2 = malloc_type_malloc(a1, 0xCB3BED47uLL);
  uint64_t v3 = v2;
  if (v2) {
    bzero(v2, a1);
  }
  return v3;
}

uint64_t cc_ws_alloc(void *a1, uint64_t a2)
{
  unint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  uint64_t v4 = *a1 + 8 * v2;
  unint64_t v5 = v2 + a2;
  a1[2] = v5;
  cc_try_abort_if (v5 > v3);
  return v4;
}

void cc_ws_free(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
}

void *eay_RC4_set_key(void *result, uint64_t a2, uint64_t a3)
{
  int32x4_t v3 = (int32x4_t)xmmword_2373BA4A0;
  uint64_t v4 = result + 1;
  uint64_t v5 = 1;
  v6.i64[0] = 0x400000004;
  v6.i64[1] = 0x400000004;
  do
  {
    *(int32x4_t *)&result[v5] = v3;
    int32x4_t v3 = vaddq_s32(v3, v6);
    v5 += 2;
  }
  while (v5 != 129);
  unint64_t v7 = 0;
  unsigned __int8 v8 = 0;
  unsigned int v9 = 0;
  *uint64_t result = 0;
  do
  {
    uint64_t v10 = &result[v7];
    int v11 = v10[2];
    unsigned __int8 v12 = v11 + v8 + *(unsigned char *)(a3 + v9);
    if (v9 + 1 == a2) {
      unsigned int v13 = 0;
    }
    else {
      unsigned int v13 = v9 + 1;
    }
    void v10[2] = *((_DWORD *)v4 + v12);
    *((_DWORD *)v4 + v12) = v11;
    int v14 = v10[3];
    unsigned __int8 v15 = v14 + v12 + *(unsigned char *)(a3 + v13);
    if (v13 + 1 == a2) {
      unsigned int v16 = 0;
    }
    else {
      unsigned int v16 = v13 + 1;
    }
    v10[3] = *((_DWORD *)v4 + v15);
    *((_DWORD *)v4 + v15) = v14;
    int v17 = v10[4];
    unsigned __int8 v18 = v17 + v15 + *(unsigned char *)(a3 + v16);
    if (v16 + 1 == a2) {
      unsigned int v19 = 0;
    }
    else {
      unsigned int v19 = v16 + 1;
    }
    _WORD v10[4] = *((_DWORD *)v4 + v18);
    *((_DWORD *)v4 + v18) = v17;
    int v20 = v10[5];
    unsigned __int8 v21 = *(unsigned char *)(a3 + v19) + v20 + v18;
    unsigned __int8 v8 = v21;
    if (v19 + 1 == a2) {
      unsigned int v9 = 0;
    }
    else {
      unsigned int v9 = v19 + 1;
    }
    v10[5] = *((_DWORD *)v4 + v21);
    *((_DWORD *)v4 + v21) = v20;
    BOOL v22 = v7 >= 126;
    v7 += 2;
  }
  while (!v22);
  return result;
}

int *eay_RC4(int *result, unint64_t a2, char *a3, unsigned char *a4)
{
  int v4 = *result;
  int v5 = result[1];
  int32x4_t v6 = result + 2;
  unint64_t v7 = a2 >> 3;
  if ((a2 >> 3))
  {
    do
    {
      int v8 = v6[(v4 + 1)];
      unsigned __int8 v9 = v8 + v5;
      int v10 = v6[v9];
      v6[(v4 + 1)] = v10;
      v6[v9] = v8;
      *a4 = *a3 ^ v6[(v10 + v8)];
      int v11 = v6[(v4 + 2)];
      unsigned __int8 v12 = v11 + v9;
      int v13 = v6[v12];
      v6[(v4 + 2)] = v13;
      v6[v12] = v11;
      a4[1] = a3[1] ^ v6[(v13 + v11)];
      int v14 = v6[(v4 + 3)];
      unsigned __int8 v15 = v14 + v12;
      int v16 = v6[v15];
      v6[(v4 + 3)] = v16;
      v6[v15] = v14;
      a4[2] = a3[2] ^ v6[(v16 + v14)];
      int v17 = v6[(v4 + 4)];
      unsigned __int8 v18 = v17 + v15;
      int v19 = v6[v18];
      v6[(v4 + 4)] = v19;
      v6[v18] = v17;
      a4[3] = a3[3] ^ v6[(v19 + v17)];
      int v20 = v6[(v4 + 5)];
      unsigned __int8 v21 = v20 + v18;
      int v22 = v6[v21];
      v6[(v4 + 5)] = v22;
      v6[v21] = v20;
      a4[4] = a3[4] ^ v6[(v22 + v20)];
      int v23 = v6[(v4 + 6)];
      unsigned __int8 v24 = v23 + v21;
      int v25 = v6[v24];
      v6[(v4 + 6)] = v25;
      v6[v24] = v23;
      a4[5] = a3[5] ^ v6[(v25 + v23)];
      int v26 = v6[(v4 + 7)];
      unsigned __int8 v27 = v26 + v24;
      int v28 = v6[v27];
      v6[(v4 + 7)] = v28;
      v6[v27] = v26;
      a4[6] = a3[6] ^ v6[(v28 + v26)];
      int v4 = (v4 + 8);
      int v29 = v6[v4];
      int v5 = (v29 + v27);
      int v30 = v6[v5];
      v6[v4] = v30;
      v6[v5] = v29;
      int v31 = v6[(v30 + v29)];
      unint64_t v32 = a3 + 8;
      a4[7] = a3[7] ^ v31;
      a4 += 8;
      a3 += 8;
      LODWORD(v7) = v7 - 1;
    }
    while (v7);
    a3 = v32;
  }
  int v33 = a2 & 7;
  if ((a2 & 7) != 0)
  {
    do
    {
      int v4 = (v4 + 1);
      int v34 = v6[v4];
      int v5 = (v34 + v5);
      int v35 = v6[v5];
      v6[v4] = v35;
      v6[v5] = v34;
      char v36 = *a3++;
      *a4++ = v36 ^ v6[(v35 + v34)];
      --v33;
    }
    while (v33);
  }
  *uint64_t result = v4;
  result[1] = v5;
  return result;
}

uint64_t cccfb8_context_size(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t cccfb8_block_size(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t cccfb8_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 16))(a1, a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t cccfb8_update(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t cccfb8_one_shot(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v24 = *MEMORY[0x263EF8C08];
  BOOL v14 = timingsafe_enable_if_supported();
  BOOL v23 = v14;
  MEMORY[0x270FA53B0](v14, v15, v16, v17);
  int v19 = &v22[-v18];
  uint64_t v20 = (*(uint64_t (**)(uint64_t, unsigned char *, uint64_t, uint64_t, uint64_t))(a1 + 16))(a1, &v22[-v18], a2, a3, a4);
  if (!v20) {
    uint64_t v20 = (*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(a1 + 24))(v19, a5, a6, a7);
  }
  cc_clear(*(void *)a1, v19);
  cc_disable_dit_with_sb((unsigned int *)&v23);
  return v20;
}

unint64_t cclr_block_nbytes(uint64_t a1)
{
  return (unint64_t)(*(void *)(a1 + 8) + 7) >> 3;
}

uint64_t cclr_aes_init(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  a1[3] = a2;
  a1[4] = a3;
  uint64_t v10 = 4294967289;
  if ((unint64_t)(a4 - 129) >= 0xFFFFFFFFFFFFFF80
    && (a4 & 7) == 0
    && (unint64_t)(a5 - 11) >= 0xFFFFFFFFFFFFFFF9)
  {
    uint64_t v10 = 0;
    *a1 = &cclr_aes_info;
    a1[1] = a4;
    a1[2] = a5;
  }
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t cclr_encrypt_block(uint64_t a1, rsize_t a2, char *a3, uint64_t a4)
{
  uint64_t v14 = *MEMORY[0x263EF8C08];
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v8 = *(void *)(a1 + 16);
  if ((unint64_t)(v8 - 11) < 0xFFFFFFFFFFFFFFF9)
  {
    uint64_t v10 = 4294967289;
  }
  else
  {
    uint64_t v9 = 0;
    do
    {
      v13[v9] = v9;
      ++v9;
    }
    while (v8 != v9);
    uint64_t v10 = cclr_permute(a1, a2, a3, a4, (uint64_t)v13);
  }
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t cclr_permute(uint64_t a1, rsize_t a2, char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v39 = a5;
  *(void *)((char *)&v46[1] + 6) = *MEMORY[0x263EF8C08];
  unint64_t v7 = *(void *)(a1 + 8);
  if (a2 != (v7 + 7) >> 3)
  {
    uint64_t v28 = 4294967289;
LABEL_27:
    cc_clear(a2, a3);
    goto LABEL_28;
  }
  __s[0] = *(void *)(a1 + 8);
  uint64_t v38 = *(void *)(a1 + 16);
  __s[1] = v38;
  v46[0] = 0;
  *(void *)((char *)v46 + 6) = 0;
  uint64_t __src = 0;
  long long v42 = 0u;
  long long v43 = 0u;
  unint64_t v10 = v7 >> 1;
  unint64_t __src_8 = ((v7 >> 1) + 7) >> 3;
  uint64_t v11 = (v7 >> 1) & 7;
  LOBYTE(v42) = -1 << v11;
  __memcpy_chk();
  unint64_t v12 = v7 + 1;
  unint64_t v37 = v7 >> 4;
  *((unsigned char *)&__src + __src_8 - 1) &= v42;
  *(void *)&long long v43 = (((v7 + 1) >> 1) + 7) >> 3;
  size_t v13 = a2 - (v7 >> 4);
  if (v11)
  {
    if (v13 != 1)
    {
      uint64_t v14 = (unsigned __int8 *)(a4 + v37 + 1);
      int v15 = *(unsigned __int8 *)(a4 + v37);
      size_t v16 = v13 - 1;
      uint64_t v17 = (char *)&v42 + 8;
      do
      {
        int v18 = *v14++;
        *v17++ = (unsigned __int16)((v18 | (v15 << 8)) << (v10 & 7)) >> 8;
        int v15 = v18;
        --v16;
      }
      while (v16);
    }
    *((unsigned char *)&v42 + v13 + 7) = *(unsigned __int8 *)(a4 + (v7 >> 4) + v13 - 1) << v11;
  }
  else
  {
    __memcpy_chk();
  }
  uint64_t v19 = v38;
  char v36 = v10;
  BYTE8(v43) = -1 << ((v12 >> 1) & 7);
  *((unsigned char *)&v42 + v43 + 7) &= -1 << ((v12 >> 1) & 7);
  if (v38)
  {
    uint64_t v35 = v11;
    uint64_t v20 = 0;
    while (1)
    {
      unsigned int v21 = *(unsigned char *)(v39 + v20) & 1;
      LOBYTE(v46[0]) = *(unsigned char *)(v39 + v20);
      __memcpy_chk();
      uint64_t v22 = (**(uint64_t (***)(uint64_t, unsigned char *, unsigned char *))a1)(a1, v44, __s);
      if (v22) {
        break;
      }
      BOOL v23 = &__src + 3 * v21;
      uint64_t v26 = v23[1];
      uint64_t v24 = v23 + 1;
      uint64_t v25 = v26;
      if (v26)
      {
        do
        {
          *((unsigned char *)&v39 + 24 * v21 + v25 + 7) ^= v44[v25 - 1];
          --v25;
        }
        while (v25);
        uint64_t v27 = *v24;
      }
      else
      {
        uint64_t v27 = 0;
      }
      *((unsigned char *)&__src + 24 * v21 + v27 - 1) &= *((unsigned char *)&v42 + 24 * v21);
      if ((unint64_t)++v20 >= *(void *)(a1 + 16))
      {
        uint64_t v28 = 0;
        uint64_t v19 = v38;
        uint64_t v11 = v35;
        goto LABEL_18;
      }
    }
    uint64_t v28 = v22;
    goto LABEL_27;
  }
  uint64_t v28 = 4294967289;
LABEL_18:
  size_t v29 = __src_8 - 1;
  a3[__src_8 - 1] = 0;
  int v30 = &a3[v37];
  if (v11)
  {
    if (v13 != 1)
    {
      unsigned __int8 v31 = *((unsigned char *)&v42 + v13 + 7);
      unint64_t v32 = &a3[a2 - 1];
      do
      {
        int v33 = *((unsigned __int8 *)&v42 + v13 + 6);
        *v32-- = (v31 | (v33 << 8)) >> (v36 & 7);
        --v13;
        unsigned __int8 v31 = v33;
      }
      while (v13 != 1);
    }
    *int v30 = BYTE8(v42) >> v11;
  }
  else
  {
    memcpy(v30, (char *)&v42 + 8, v13);
  }
  memcpy(a3, &__src, v29);
  a3[v29] |= *((unsigned char *)&__src + v29);
  if (!v19) {
    goto LABEL_27;
  }
  uint64_t v28 = 0;
LABEL_28:
  cc_clear(0x30uLL, &__src);
  cc_clear(0x10uLL, __s);
  cc_clear(0x10uLL, v44);
  return v28;
}

uint64_t cclr_decrypt_block(uint64_t a1, rsize_t a2, char *a3, uint64_t a4)
{
  uint64_t v19 = *MEMORY[0x263EF8C08];
  BOOL v17 = timingsafe_enable_if_supported();
  uint64_t v8 = *(void *)(a1 + 16);
  if ((unint64_t)(v8 - 11) < 0xFFFFFFFFFFFFFFF9)
  {
    uint64_t v15 = 4294967289;
  }
  else
  {
    uint64_t v9 = 0;
    char v10 = v8 - 1;
    int64x2_t v11 = (int64x2_t)xmmword_2373AF940;
    uint64x2_t v12 = (uint64x2_t)vdupq_n_s64(v8 - 1);
    int64x2_t v13 = vdupq_n_s64(2uLL);
    do
    {
      int32x2_t v14 = vmovn_s64((int64x2_t)vcgeq_u64(v12, (uint64x2_t)v11));
      if (v14.i8[0]) {
        v18[v9] = v10;
      }
      if (v14.i8[4]) {
        v18[v9 + 1] = v8 + (v9 ^ 0xFE);
      }
      v9 += 2;
      int64x2_t v11 = vaddq_s64(v11, v13);
      v10 -= 2;
    }
    while (((v8 + 1) & 0xFFFFFFFFFFFFFFFELL) != v9);
    uint64_t v15 = cclr_permute(a1, a2, a3, a4, (uint64_t)v18);
  }
  cc_disable_dit_with_sb((unsigned int *)&v17);
  return v15;
}

uint64_t cclr_aes_prf_eval(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ccecb_update_internal(*(void *)(a1 + 24), *(void *)(a1 + 32), 1, a3, a2);
}

unint64_t ccspake_sizeof_w(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(a1 + 8))();
  int32x4_t v3 = (void *)(*(uint64_t (**)(void))(a1 + 8))();
  uint64_t v4 = cczp_bitlen(v2 + 40 * *v3 + 32);
  if (*(_DWORD *)a1) {
    return (unint64_t)(v4 + 7) >> 3;
  }
  else {
    return ((unint64_t)(v4 + 7) >> 3) + 8;
  }
}

unint64_t ccspake_sizeof_point(uint64_t a1)
{
  uint64_t v1 = (*(uint64_t (**)(void))(a1 + 8))();
  return ((unint64_t)(cczp_bitlen(v1) + 7) >> 2) | 1;
}

uint64_t ccspake_sizeof_ctx(uint64_t a1)
{
  return (*(void *)(*(uint64_t (**)(void))(a1 + 8))() << 6) + 336;
}

uint64_t ccspake_reduce_w(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, char *a5)
{
  BOOL v37 = timingsafe_enable_if_supported();
  char v10 = (uint64_t *)(*(uint64_t (**)(void))(a1 + 8))();
  uint64_t v11 = *v10;
  unint64_t v12 = sizeof_struct_ccpolyzp_po2cyc();
  v33[0] = cc_malloc_clear(8 * (5 * v11 + (v12 + 127) / v12) + 24);
  uint64_t v13 = *v10;
  unint64_t v14 = sizeof_struct_ccpolyzp_po2cyc();
  v33[1] = 5 * v13 + (v14 + 127) / v14 + 3;
  uint64_t v34 = 0;
  uint64_t v35 = cc_ws_alloc;
  char v36 = cc_ws_free;
  if (v33[0])
  {
    if (*(_DWORD *)a1
      && ((uint64_t v18 = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8))(v14, v15, v16, v17),
           uint64_t v22 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8))(v18, v19, v20, v21),
           uint64_t v23 = cczp_bitlen(v18 + 40 * *v22 + 32),
           *(_DWORD *)a1)
        ? (unint64_t v27 = (unint64_t)(v23 + 7) >> 3)
        : (unint64_t v27 = ((unint64_t)(v23 + 7) >> 3) + 8),
          v27 == a4))
    {
      uint64_t v28 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8))(v23, v24, v25, v26);
      unint64_t v29 = *v28;
      int v30 = (char *)cc_ws_alloc(v33, *v28);
      scalar_fips_extrabits_uint64_t ws = ccec_generate_scalar_fips_extrabits_ws((uint64_t)v33, v28, a2, a3, v30);
      if (!scalar_fips_extrabits_ws) {
        ccn_write_uint_padded_ct_internal(v29, (unint64_t *)v30, a4, a5);
      }
      uint64_t v34 = 0;
      v36((uint64_t)v33);
    }
    else
    {
      scalar_fips_extrabits_uint64_t ws = 4294967289;
      cc_ws_free((uint64_t)v33);
    }
  }
  else
  {
    scalar_fips_extrabits_uint64_t ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v37);
  return scalar_fips_extrabits_ws;
}

uint64_t ccspake_generate_L(uint64_t a1, unint64_t a2, char *a3, uint64_t a4, char *a5, uint64_t (**a6)(void, uint64_t, unint64_t *))
{
  BOOL v44 = timingsafe_enable_if_supported();
  unint64_t v12 = (uint64_t *)(*(uint64_t (**)(void))(a1 + 8))();
  uint64_t v13 = *v12;
  uint64_t v14 = sizeof_struct_cche_galois_key();
  unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
  v40[0] = cc_malloc_clear(8 * ((v14 + v15 + 4 * v13 * v15 - 1) / v15 + 50 * v13));
  uint64_t v16 = *v12;
  uint64_t v17 = sizeof_struct_cche_galois_key();
  unint64_t v18 = sizeof_struct_ccpolyzp_po2cyc();
  v40[1] = (v17 + v18 + 4 * v16 * v18 - 1) / v18 + 50 * v16;
  uint64_t v41 = 0;
  long long v42 = cc_ws_alloc;
  long long v43 = cc_ws_free;
  if (!v40[0])
  {
    uint64_t v38 = 4294967283;
    goto LABEL_15;
  }
  uint64_t v21 = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(a1 + 8))(v18, v19, v20);
  uint64_t v24 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 8))(v21, v22, v23);
  uint64_t v25 = cczp_bitlen(v21 + 40 * *v24 + 32);
  if (*(_DWORD *)a1) {
    unint64_t v28 = (unint64_t)(v25 + 7) >> 3;
  }
  else {
    unint64_t v28 = ((unint64_t)(v25 + 7) >> 3) + 8;
  }
  if (v28 != a2
    || (uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 8))(v25, v26, v27),
        uint64_t v30 = cczp_bitlen(v29),
        (((unint64_t)(v30 + 7) >> 2) | 1) != a4))
  {
    uint64_t v38 = 4294967289;
    cc_ws_free((uint64_t)v40);
    goto LABEL_15;
  }
  int v33 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 8))(v30, v31, v32);
  uint64_t v34 = *v33;
  uint64_t v35 = cc_ws_alloc(v40, *v33);
  char v36 = (unint64_t **)v42(v40, (4 * (v34 & 0x7FFFFFFFFFFFFFFLL)) | 2);
  *char v36 = (unint64_t *)v33;
  if (*(_DWORD *)a1)
  {
    uint64_t uint_internal = ccn_read_uint_internal(v34, v35, a2, a3);
    if (uint_internal) {
      goto LABEL_11;
    }
    uint64_t uint_internal = ccec_make_pub_from_priv_ws((uint64_t)v40, (unint64_t *)v33, a6, v35, 0, v36);
    if (uint_internal) {
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t uint_internal = ccec_generate_key_deterministic_ws((uint64_t)v40, (unint64_t *)v33, a2, a3, a6, 1, v36);
    if (uint_internal) {
      goto LABEL_11;
    }
  }
  uint64_t uint_internal = ccec_export_pub((uint64_t *)v36, a5);
LABEL_11:
  uint64_t v38 = uint_internal;
  uint64_t v41 = 0;
  v43((uint64_t)v40);
LABEL_15:
  cc_disable_dit_with_sb((unsigned int *)&v44);
  return v38;
}

uint64_t ccspake_cmp_pub_key(uint64_t **a1, uint64_t a2)
{
  int32x4_t v3 = a1 + 2;
  uint64_t v4 = **a1;
  int v5 = ccn_cmp_internal(v4, a2, a1 + 2);
  return ccn_cmp_internal(v4, a2 + 8 * v4, &v3[v4]) | v5;
}

void *ccspake_store_pub_key(uint64_t **a1, char *a2)
{
  uint64_t v4 = **a1;
  int v5 = a1 + 2;
  ccn_set(v4, a2, a1 + 2);
  int32x4_t v6 = &v5[**a1];

  return ccn_set(v4, &a2[8 * v4], v6);
}

uint64_t ccspake_import_pub_ws(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t result = ccec_import_pub_ws();
  *(void *)(a1 + 16) = v2;
  return result;
}

void *ccaes_gcm_encrypt_mode()
{
  unint64_t v0 = ccaes_ecb_encrypt_mode();
  ccmode_factory_gcm_encrypt(gcm_encrypt, v0);
  return gcm_encrypt;
}

unsigned __int8 *ccder_decode_rsa_pub(unint64_t *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v9 = a3;
  unint64_t v4 = *a1;
  int v5 = ccder_decode_constructed_tl(0x2000000000000010, &v9, a2, a3);
  int32x4_t v6 = ccder_decode_uint(v4, a1 + 3, v5, v9);
  uint64_t result = ccder_decode_uint(v4, &a1[2 * *a1 + 4], v6, v9);
  if (result)
  {
    uint64_t v8 = result;
    if (cczp_init(a1)) {
      return 0;
    }
    else {
      return v8;
    }
  }
  return result;
}

uint64_t ccecies_encrypt_gcm_composite(unint64_t **a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  BOOL v30 = timingsafe_enable_if_supported();
  unint64_t v18 = *a1;
  unint64_t v19 = **a1;
  uint64_t v20 = sizeof_struct_cche_galois_key();
  unint64_t v21 = sizeof_struct_ccpolyzp_po2cyc();
  v28[0] = cc_malloc_clear((v19 << 8) + 16 * ((v20 + v21 + 4 * v19 * v21 - 1) / v21));
  unint64_t v22 = *v18;
  uint64_t v23 = sizeof_struct_cche_galois_key();
  unint64_t v24 = sizeof_struct_ccpolyzp_po2cyc();
  v28[1] = 32 * v22 + 2 * ((v23 + v24 + 4 * v22 * v24 - 1) / v24);
  v28[2] = 0;
  v28[3] = cc_ws_alloc;
  uint64_t v29 = cc_ws_free;
  if (v28[0])
  {
    uint64_t v25 = ccecies_encrypt_gcm_composite_ws((uint64_t)v28, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
    v29((uint64_t)v28);
  }
  else
  {
    uint64_t v25 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v30);
  return v25;
}

uint64_t ccecies_encrypt_gcm_composite_ws(uint64_t a1, unint64_t **a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  unint64_t v19 = *a2;
  unint64_t v20 = **a2;
  uint64_t v25 = *(void *)(a1 + 16);
  unint64_t v21 = (unint64_t **)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, (4 * (v20 & 0x7FFFFFFFFFFFFFFLL)) | 2);
  size_t v26 = (unint64_t)(cczp_bitlen((uint64_t)v19) + 7) >> 3;
  unint64_t v22 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v20);
  uint64_t result = ccecdh_generate_key_ws(a1, v19, *(uint64_t (***)(void, uint64_t, unint64_t *))(a3 + 8), v21);
  if (!result)
  {
    uint64_t result = ccecdh_compute_shared_secret_ws(a1, v21, a2, &v26, v22, *(uint64_t (***)(void, uint64_t, unint64_t *))(a3 + 8));
    if (!result) {
      uint64_t result = ccecies_encrypt_gcm_from_shared_secret_composite(a2, a3, (uint64_t *)v21, v26, v22, a7, a8, a9, a10, a11, a12, a4, a5, a6);
    }
  }
  *(void *)(a1 + 16) = v25;
  return result;
}

uint64_t ccecies_encrypt_gcm(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, rsize_t *a9, char *a10)
{
  BOOL v34 = timingsafe_enable_if_supported();
  uint64_t v17 = (uint64_t *)*a1;
  uint64_t v18 = *(void *)*a1;
  uint64_t v19 = sizeof_struct_cche_galois_key();
  unint64_t v20 = sizeof_struct_ccpolyzp_po2cyc();
  v32[0] = cc_malloc_clear((v18 << 8) + 16 * ((v19 + v20 + 4 * v18 * v20 - 1) / v20));
  uint64_t v21 = *v17;
  uint64_t v22 = sizeof_struct_cche_galois_key();
  unint64_t v23 = sizeof_struct_ccpolyzp_po2cyc();
  v32[1] = 32 * v21 + 2 * ((v22 + v23 + 4 * v21 * v23 - 1) / v23);
  void v32[2] = 0;
  v32[3] = cc_ws_alloc;
  int v33 = cc_ws_free;
  if (!v32[0])
  {
    uint64_t v27 = 4294967283;
    goto LABEL_6;
  }
  uint64_t v30 = a4;
  unint64_t v24 = ccecies_pub_key_size(a1, a2);
  unint64_t v25 = ccecies_encrypt_gcm_ciphertext_size(a1, a2, a3);
  if (v25 > *a9)
  {
    unint64_t v28 = cc_ws_free;
    uint64_t v27 = 4294967289;
    goto LABEL_8;
  }
  rsize_t v26 = v25;
  uint64_t v27 = ccecies_encrypt_gcm_composite_ws((uint64_t)v32, (unint64_t **)a1, a2, a10, (uint64_t)&a10[v24], (uint64_t)&a10[v24 + a3], a3, v30, a5, a6, a7, a8);
  unint64_t v28 = v33;
  if (v27)
  {
LABEL_8:
    v28((uint64_t)v32);
    cc_clear(*a9, a10);
    goto LABEL_6;
  }
  *a9 = v26;
  v28((uint64_t)v32);
LABEL_6:
  cc_disable_dit_with_sb((unsigned int *)&v34);
  return v27;
}

unsigned __int8 *ccder_decode_rsa_pub_x509_n(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v5 = a2;
  uint64_t result = ccder_decode_constructed_tl(0x2000000000000010, &v5, a1, a2);
  if (result)
  {
    unint64_t v7 = v5;
    int32x4_t v6 = 0;
    int32x4_t v3 = ccder_decode_constructed_tl(0x2000000000000010, &v7, result, v5);
    if (v3 && (unint64_t v4 = ccder_decode_oid(&v6, v3, v7)) != 0)
    {
      uint64_t result = ccder_decode_constructed_tl(5, &v7, v4, v7);
      if (result)
      {
        unint64_t v7 = v5;
        uint64_t result = ccder_decode_constructed_tl(3, &v7, result, v5);
        if (result)
        {
          if (result < v7 && !*result) {
            ++result;
          }
          return ccder_decode_rsa_pub_n(result, v7);
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t ccz_addi(void *a1, uint64_t a2, unsigned int a3)
{
  v9[1] = *MEMORY[0x263EF8C08];
  BOOL v8 = timingsafe_enable_if_supported();
  v9[0] = a3;
  v7[0] = ccn_n(1uLL, (uint64_t)v9);
  v7[1] = 0;
  void v7[2] = 1;
  v7[3] = v9;
  ccz_add(a1, a2, (uint64_t)v7);
  return cc_disable_dit_with_sb((unsigned int *)&v8);
}

uint64_t ccrsa_decrypt_eme_pkcs1v15(uint64_t *a1, rsize_t *a2, void *a3, uint64_t a4, uint64_t a5)
{
  BOOL v28 = timingsafe_enable_if_supported();
  unint64_t v10 = *a1;
  uint64_t v11 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v12 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v13 = (v11 + v12 - 1) / v12 + 11 * v10;
  unint64_t v14 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(v10);
  if (v13 + 1 > v14) {
    unint64_t v15 = v13 + 1;
  }
  else {
    unint64_t v15 = v14;
  }
  uint64_t v16 = cc_malloc_clear(8 * (v15 + 3 * v10));
  v26[0] = v16;
  unint64_t v17 = *a1;
  uint64_t v18 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v19 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v20 = (v18 + v19 - 1) / v19 + 11 * v17;
  unint64_t v21 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(v17);
  if (v20 + 1 > v21) {
    unint64_t v22 = v20 + 1;
  }
  else {
    unint64_t v22 = v21;
  }
  v26[1] = v22 + 3 * v17;
  _OWORD v26[2] = 0;
  v26[3] = cc_ws_alloc;
  uint64_t v27 = cc_ws_free;
  if (v16)
  {
    unint64_t v23 = ccrng(0);
    if (v23)
    {
      uint64_t v24 = ccrsa_decrypt_eme_pkcs1v15_blinded_ws((uint64_t)v26, (uint64_t (**)(void, uint64_t, uint64_t))v23, a1, a2, a3, a4, a5);
      v27((uint64_t)v26);
    }
    else
    {
      uint64_t v24 = 0xFFFFFFFFLL;
      cc_ws_free((uint64_t)v26);
    }
  }
  else
  {
    uint64_t v24 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v28);
  return v24;
}

uint64_t cced448_make_pub(uint64_t (**a1)(void, uint64_t, unint64_t *), uint64_t a2, char *a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  pub_uint64_t internal = cced448_make_pub_internal(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return pub_internal;
}

uint64_t cced448_make_pub_internal(uint64_t (**a1)(void, uint64_t, unint64_t *), uint64_t a2, char *a3)
{
  uint64_t v24 = *MEMORY[0x263EF8C08];
  int32x4_t v6 = (unint64_t *)ccec_cp_ed448();
  uint64_t v18 = cc_malloc_clear(0x690uLL);
  long long v19 = xmmword_2373BA4C0;
  unint64_t v20 = (uint64_t (*)(void **, uint64_t))cc_ws_alloc;
  unint64_t v21 = cc_ws_free;
  if (!v18) {
    return 4294967283;
  }
  uint64_t v7 = cczp_n((uint64_t)v6);
  uint64_t v8 = cc_ws_alloc(&v18, v7);
  uint64_t v9 = (unsigned char *)v20(&v18, 3 * v7);
  ccshake256(0x39uLL, a3, 0x72uLL, __s);
  __s[0] &= 0xFCu;
  v23 |= 0x80u;
  if (v7)
  {
    unint64_t v10 = __s;
    uint64_t v11 = (void *)v8;
    do
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
      --v7;
    }
    while (v7);
  }
  uint64_t v13 = cced448_scalar_mult_base_masked_ws((uint64_t)&v18, v6, a1, (uint64_t)v9, v8);
  if (v13 || (uint64_t v13 = ccec_affinify_ws((uint64_t)&v18, (uint64_t)v6), v13))
  {
    uint64_t v16 = v13;
  }
  else
  {
    uint64_t v14 = 0;
    unint64_t v15 = &v9[8 * *v6];
    do
    {
      *(void *)(a2 + v14) = *(void *)&v15[v14];
      v14 += 8;
    }
    while (v14 != 56);
    uint64_t v16 = 0;
    *(unsigned char *)(a2 + 56) = *v9 << 7;
  }
  cc_clear(0x72uLL, __s);
  *((void *)&v19 + 1) = 0;
  v21((uint64_t)&v18);
  return v16;
}

uint64_t cced448_make_key_pair(uint64_t (**a1)(void, uint64_t, char *), uint64_t a2, char *a3)
{
  BOOL v9 = timingsafe_enable_if_supported();
  pub_uint64_t internal = (*a1)(a1, 57, a3);
  if (!pub_internal) {
    pub_uint64_t internal = cced448_make_pub_internal((uint64_t (**)(void, uint64_t, unint64_t *))a1, a2, a3);
  }
  uint64_t v7 = pub_internal;
  cc_disable_dit_with_sb((unsigned int *)&v9);
  return v7;
}

uint64_t cced448_shake_to_scalar_ws(uint64_t a1, uint64_t *a2, uint64_t *a3, unint64_t a4, char *a5, unint64_t a6, char *a7, unint64_t a8, char *a9)
{
  uint64_t v28 = *MEMORY[0x263EF8C08];
  unint64_t v15 = ccshake256_xi();
  uint64_t v22 = *a2;
  uint64_t v16 = cczp_n((uint64_t)a2);
  uint64_t v23 = *(void *)(a1 + 16);
  uint64_t v17 = (2 * v16) | 1;
  uint64_t v18 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v17);
  uint64_t v27 = 0;
  memset(__s, 0, sizeof(__s));
  ccxof_init((uint64_t)v15, __dst);
  ccxof_absorb(v15, (char *)__dst, 0xAuLL, "SigEd448");
  ccxof_absorb(v15, (char *)__dst, a4, a5);
  ccxof_absorb(v15, (char *)__dst, a6, a7);
  ccxof_absorb(v15, (char *)__dst, a8, a9);
  ccxof_squeeze(v15, __dst, 0x72uLL, (char *)__s);
  cc_clear(0x158uLL, __dst);
  for (uint64_t i = 0; i != v17; ++i)
    *(void *)&v18[8 * i] = *((void *)__s + i);
  cczp_modn_ws(a1, &a2[5 * v22 + 4], a3, v17, v18);
  uint64_t result = cc_clear(0x78uLL, __s);
  *(void *)(a1 + 16) = v23;
  return result;
}

uint64_t cchmac_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v16[1] = *MEMORY[0x263EF8C08];
  uint64_t v10 = MEMORY[0x270FA53B0]();
  uint64_t v12 = (void *)((char *)v16 - v11);
  cchmac_init_internal(v10, (void *)((char *)v16 - v11), v13, v14);
  cchmac_update_internal(a1, v12, a4, a5);
  cchmac_final_internal(a1, v12, a6);
  return cc_clear(((*(void *)(a1 + 8) + *(void *)(a1 + 16) + 19) & 0xFFFFFFFFFFFFFFF8) + *(void *)(a1 + 8), v12);
}

uint64_t cchmac(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v13 = timingsafe_enable_if_supported();
  cchmac_internal(a1, a2, a3, a4, a5, a6);
  return cc_disable_dit_with_sb((unsigned int *)&v13);
}

uint64_t ccder_blob_encode_tag(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  unint64_t v4 = a2 & 0x1FFFFFFFFFFFFFFFLL;
  if ((a2 & 0x1FFFFFFFFFFFFFFFLL) > 0x1E)
  {
    if (v4 <= 0x7F)
    {
      if ((unint64_t)(v2 - v3) < 2) {
        return 0;
      }
      *(unsigned char *)(v2 - 1) = a2;
      int32x4_t v6 = (unsigned char *)(v2 - 1);
LABEL_18:
      *(v6 - 1) = HIBYTE(a2) | 0x1F;
      int v5 = v6 - 1;
      goto LABEL_19;
    }
    if (v4 >> 14)
    {
      if (v4 >> 21)
      {
        unint64_t v9 = v2 - v3;
        if (v4 >> 28)
        {
          if (v9 < 6) {
            return 0;
          }
          uint64x2_t v11 = (uint64x2_t)vdupq_n_s64(a2);
          int16x8_t v12 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v11, (uint64x2_t)xmmword_2373BA530), (int32x4_t)vshlq_u64(v11, (uint64x2_t)xmmword_2373BA520));
          v12.i64[0] = *(void *)&vmovn_s32((int32x4_t)v12) | 0x80008000800080;
          *(_DWORD *)(v2 - 5) = vmovn_s16(v12).u32[0];
          int32x4_t v6 = (unsigned char *)(v2 - 5);
          void v6[4] = a2 & 0x7F;
          goto LABEL_18;
        }
        if (v9 < 5) {
          return 0;
        }
        *(unsigned char *)(v2 - 4) = (a2 >> 21) | 0x80;
        int32x4_t v6 = (unsigned char *)(v2 - 4);
        v6[3] = a2 & 0x7F;
        void v6[2] = (a2 >> 7) | 0x80;
        unsigned int v8 = a2 >> 14;
      }
      else
      {
        if ((unint64_t)(v2 - v3) < 4) {
          return 0;
        }
        *(unsigned char *)(v2 - 3) = (a2 >> 14) | 0x80;
        int32x4_t v6 = (unsigned char *)(v2 - 3);
        void v6[2] = a2 & 0x7F;
        unsigned int v8 = a2 >> 7;
      }
      char v7 = v8 | 0x80;
    }
    else
    {
      if ((unint64_t)(v2 - v3) < 3) {
        return 0;
      }
      char v7 = a2 & 0x7F;
      *(unsigned char *)(v2 - 2) = (a2 >> 7) | 0x80;
      int32x4_t v6 = (unsigned char *)(v2 - 2);
    }
    v6[1] = v7;
    goto LABEL_18;
  }
  if (v2 != v3)
  {
    *(unsigned char *)(v2 - 1) = HIBYTE(a2) & 0xE0 | a2;
    int v5 = (unsigned char *)(v2 - 1);
LABEL_19:
    *a1 = v3;
    a1[1] = (uint64_t)v5;
    return 1;
  }
  return 0;
}

uint64_t fipspost_get_hmac(char *a1, _OWORD *a2, unint64_t a3)
{
  uint64_t v44 = *MEMORY[0x263EF8C08];
  uint64_t result = (uint64_t)ccsha256_di();
  char v41 = 0;
  if (a3)
  {
    unint64_t v10 = (unint64_t)&a1[a3];
    BOOL v11 = __CFADD__(a1, a3);
    uint64_t result = 4294967224;
    if (a3 < 0x28 || v11) {
      return result;
    }
  }
  else
  {
    unint64_t v10 = 0;
  }
  if (*(_DWORD *)a1 == -17958194)
  {
    uint64_t v38 = a2;
    int16x8_t v12 = a1 + 28;
  }
  else
  {
    if (*(_DWORD *)a1 != -17958193) {
      return 4294967223;
    }
    uint64_t v38 = a2;
    int16x8_t v12 = a1 + 32;
  }
  uint64_t v40 = v12;
  uint64_t v39 = &v36;
  int v13 = *((_DWORD *)a1 + 4);
  long long v42 = 0u;
  long long v43 = 0u;
  MEMORY[0x270FA53B0](result, v7, v8, v9);
  char v36 = (void **)((char *)&v36 - v14);
  BOOL v37 = v15;
  cchmac_init((uint64_t)v15, (void **)((char *)&v36 - v14), 1uLL, &v41);
  if (v13)
  {
    int v16 = 0;
    uint64_t v17 = v40;
    while (1)
    {
      BOOL v18 = (unint64_t)(v17 + 56) <= v10 || v10 == 0;
      if (!v18 || v17 < a1) {
        break;
      }
      if (!strncmp("__TEXT", v17 + 8, 6uLL) || !strncmp("__TEXT_EXEC", v17 + 8, 0xBuLL))
      {
        if (*(_DWORD *)v40 == 1)
        {
          int v24 = *((_DWORD *)v17 + 12);
          if (v24)
          {
            unint64_t v25 = (unint64_t)(v17 + 124);
            do
            {
              BOOL v26 = v25 <= v10 || v10 == 0;
              uint64_t result = 4294967224;
              if (!v26 || v17 + 56 < a1) {
                return result;
              }
              if (!strcmp((const char *)(v25 - 68), "__text")
                && (!strcmp((const char *)(v25 - 52), "__TEXT") || !strcmp((const char *)(v25 - 52), "__TEXT_EXEC")))
              {
                size_t v28 = *(unsigned int *)(v25 - 32);
                uint64_t v29 = &a1[*(unsigned int *)(v25 - 28)];
LABEL_62:
                if (((unint64_t)&v29[v28] <= v10 || v10 == 0) && &v29[v28 - 1] >= a1)
                {
                  int v33 = v36;
                  uint64_t v32 = v37;
                  cchmac_update(v37, v36, v28, v29);
                  cchmac_final((uint64_t)v32, v33, (uint64_t)&v42);
                  uint64_t result = 0;
                  long long v34 = v43;
                  uint64_t v35 = v38;
                  *uint64_t v38 = v42;
                  v35[1] = v34;
                  return result;
                }
                return 4294967224;
              }
              v25 += 68;
            }
            while (--v24);
          }
        }
        else if (*(_DWORD *)v40 == 25)
        {
          unint64_t v20 = (unint64_t)(v17 + 72);
          int v21 = *((_DWORD *)v17 + 16);
          if (v10 && v20 > v10) {
            return 4294967224;
          }
          if (v21)
          {
            unint64_t v22 = (unint64_t)(v17 + 152);
            do
            {
              BOOL v23 = v22 <= v10 || v10 == 0;
              uint64_t result = 4294967224;
              if (!v23 || v20 < (unint64_t)a1) {
                return result;
              }
              if (!strcmp((const char *)(v22 - 80), "__text")
                && (!strcmp((const char *)(v22 - 64), "__TEXT") || !strcmp((const char *)(v22 - 64), "__TEXT_EXEC")))
              {
                uint64_t v29 = &a1[*(unsigned int *)(v22 - 32)];
                size_t v28 = *(void *)(v22 - 40);
                goto LABEL_62;
              }
              v22 += 80;
            }
            while (--v21);
          }
        }
      }
      ++v16;
      v17 += *((unsigned int *)v17 + 1);
      if (v16 == v13) {
        goto LABEL_55;
      }
    }
  }
  else
  {
LABEL_55:
    uint64_t v27 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: could not create the hash\n", v27, "fipspost_get_hmac", 251);
  }
  return 4294967224;
}

uint64_t fipspost_post_ecdh(char a1)
{
  uint64_t v34 = *MEMORY[0x263EF8C08];
  uint64_t v2 = (uint64_t *)ccec_cp_256();
  uint64_t v3 = *v2;
  uint64_t v4 = sizeof_struct_cche_galois_key();
  unint64_t v5 = sizeof_struct_ccpolyzp_po2cyc();
  uint64_t v6 = sizeof_struct_cche_galois_key();
  v22[0] = cc_malloc_clear(8 * ((v5 - 1 + v4 + 4 * v5 * v3) / v5 + 29 * v3 + (3 * v5 * v3 + v5 - 1 + v6) / v5));
  uint64_t v7 = *v2;
  uint64_t v8 = sizeof_struct_cche_galois_key();
  unint64_t v9 = sizeof_struct_ccpolyzp_po2cyc();
  v22[1] = (v9 - 1 + v8 + 4 * v9 * v7) / v9 + 29 * v7 + (3 * v9 * v7 + v9 - 1 + sizeof_struct_cche_galois_key()) / v9;
  uint64_t v23 = 0;
  int v24 = cc_ws_alloc;
  unint64_t v25 = cc_ws_free;
  if (v22[0])
  {
    v33[0] = xmmword_2373BA540;
    v33[1] = unk_2373BA550;
    v32[0] = xmmword_2373BA560;
    v32[1] = unk_2373BA570;
    v31[0] = xmmword_2373BA580;
    v31[1] = unk_2373BA590;
    v30[0] = xmmword_2373BA5A0;
    v30[1] = unk_2373BA5B0;
    v29[0] = xmmword_2373BA5C0;
    v29[1] = unk_2373BA5D0;
    long long v27 = 0u;
    long long v28 = 0u;
    unint64_t v26 = 32;
    uint64_t v10 = cczp_bitlen((uint64_t)v2);
    BOOL v11 = (unint64_t **)cc_ws_alloc(v22, (4 * (v7 & 0x7FFFFFFFFFFFFFFLL)) | 2);
    int16x8_t v12 = (unint64_t **)v24(v22, (unint64_t)(24 * v7 + 23) >> 3);
    if (ccec_make_priv(v10, 32, (uint64_t)v30, 32, (uint64_t)v29, 32, (uint64_t)v31, (uint64_t **)v11))
    {
      uint64_t v13 = mach_absolute_time();
      uint64_t v14 = 4294967224;
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: result: %d\n", v13, "fipspost_post_ecdh_ws", 85, -72);
    }
    else
    {
      if (ccec_make_pub(v10, 0x20uLL, (unsigned __int8 *)v33, 0x20uLL, (unsigned __int8 *)v32, (uint64_t)v12))
      {
        uint64_t v15 = mach_absolute_time();
        uint64_t v14 = 4294967224;
        int v16 = 93;
      }
      else
      {
        if (!ccecdh_compute_shared_secret_ws((uint64_t)v22, v11, v12, &v26, (char *)&v27, (uint64_t (**)(void, uint64_t, unint64_t *))&ccrng_zero))
        {
          if ((a1 & 0x10) != 0) {
            LOBYTE(v27) = v27 ^ 1;
          }
          if ((void)v27 == 0x1FF20641062FC46
            && *((void *)&v27 + 1) == 0x252DDDFB34A4542ELL
            && (void)v28 == 0x681E56602085C5CCLL
            && *((void *)&v28 + 1) == 0x7BBD978977D70D04)
          {
            uint64_t v14 = 0;
          }
          else
          {
            uint64_t v21 = mach_absolute_time();
            printf("FIPSPOST_USER [%llu] %s:%d: FAILED: memcmp\n", v21, "fipspost_post_ecdh_ws", 114);
            uint64_t v14 = 4294967221;
          }
          goto LABEL_10;
        }
        uint64_t v15 = mach_absolute_time();
        uint64_t v14 = 4294967224;
        int v16 = 103;
      }
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: result: %d\n", v15, "fipspost_post_ecdh_ws", v16, -72);
    }
LABEL_10:
    uint64_t v23 = 0;
    v25((uint64_t)v22);
    return v14;
  }
  return 4294967283;
}

uint64_t ccn_addmul1(uint64_t a1, unint64_t *a2, unint64_t *a3, unint64_t a4)
{
  for (uint64_t i = 0; a1; --a1)
  {
    unint64_t v5 = *a3++;
    unint64_t v6 = (v5 * (unsigned __int128)a4) >> 64;
    unint64_t v7 = v5 * a4;
    BOOL v8 = __CFADD__(*a2, i);
    unint64_t v9 = *a2 + i;
    uint64_t v10 = v8;
    unint64_t v11 = v9 + v7;
    uint64_t i = (__PAIR128__(v10, v9) + __PAIR128__(v6, v7)) >> 64;
    *a2++ = v11;
  }
  return i;
}

void *ccsha384_di()
{
  return &ccsha384_ltc_di;
}

uint64_t cczp_add_default_ws(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = cczp_n(a2);
  int16x8_t v12 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v11);
  LOBYTE(a5) = ccn_add_ws(a1, v11, a3, a4, a5);
  uint64_t v13 = (unint64_t *)cczp_prime(a2);
  char v14 = ccn_sub_ws(a1, v11, v12, a3, v13);
  uint64_t result = ccn_mux(v11, v14 ^ 1u | a5, a3, v12, a3);
  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t cczp_add_ws(uint64_t a1, uint64_t a2)
{
  return (**(uint64_t (***)(void))(a2 + 16))();
}

uint64_t cczp_add(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v13 = timingsafe_enable_if_supported();
  uint64_t v8 = cczp_n(a1);
  v11[0] = cc_malloc_clear(8 * v8);
  v11[1] = cczp_n(a1);
  void v11[2] = 0;
  v11[3] = cc_ws_alloc;
  int16x8_t v12 = cc_ws_free;
  if (v11[0])
  {
    (**(void (***)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 16))(v11, a1, a2, a3, a4);
    v12((uint64_t)v11);
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v9 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v13);
  return v9;
}

uint64_t ccrns_modulus_init_ws(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return ccrns_modulus_init_helper_ws(a1, a2, a3, 0);
}

uint64_t ccrns_modulus_init_helper_ws(uint64_t a1, unint64_t *a2, uint64_t a3, int a4)
{
  v19[1] = *MEMORY[0x263EF8C08];
  if (a3 < 2) {
    return 4294967289;
  }
  *a2 = a3;
  v19[0] = a3;
  if (a4 == 1)
  {
    a2[1] = __udivti3();
    goto LABEL_7;
  }
  if (!a4)
  {
    uint64_t v7 = ccrns_modulus_compute_mod_factor_ws(a1, 1u, a2 + 1, 1uLL, a3);
    if (v7) {
      return v7;
    }
LABEL_7:
    uint64_t v7 = ccrns_modulus_compute_mod_factor_ws(a1, 2u, a2 + 2, 1uLL, a3);
    if (v7) {
      return v7;
    }
  }
  unint64_t v8 = *a2;
  BOOL v10 = (*a2 & (*a2 - 1)) != 0 || v8 == 0;
  long long v17 = xmmword_2373BA5E0;
  uint64_t v18 = 0;
  ccn_shift_left_multi(3uLL, &v17, (unint64_t *)&v17, v10 - __clz(v8) + 63 + 128);
  ccn_divmod_ws(a1, 3, (uint64_t)&v17, 3uLL, (uint64_t)__src, 1uLL, (char *)&v15, v19);
  uint64_t v11 = 0xFFFFFFFFLL;
  if (!ccn_add1_ws(a1, 3, __src, __src, ((v15 | HIDWORD(v15)) + 0xFFFFFFFF) >> 32))
  {
    uint64_t v14 = 0;
    long long v13 = xmmword_2373BA5E0;
    ccn_shift_left_multi(3uLL, &v13, (unint64_t *)&v13, 0x80uLL);
    if (ccn_sub_ws(a1, 3, __src, __src, (unint64_t *)&v13))
    {
      return 0xFFFFFFFFLL;
    }
    else
    {
      ccn_set(2, a2 + 4, __src);
      return 0;
    }
  }
  return v11;
}

uint64_t ccrns_modulus_init_var_time_ws(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return ccrns_modulus_init_helper_ws(a1, a2, a3, 1);
}

uint64_t ccrns_mul_modulus_init_ws(uint64_t a1, uint64_t *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4 = 4294967289;
  if (a3 >= 2 && a4 < a3)
  {
    *a2 = a3;
    a2[1] = a4;
    ccrns_modulus_compute_mod_factor_ws(a1, 1u, a2 + 2, a4, a3);
    return 0;
  }
  return v4;
}

uint64_t ccrns_modulus_compute_mod_factor_ws(uint64_t a1, unsigned int a2, void *a3, unint64_t a4, uint64_t a5)
{
  v14[1] = *MEMORY[0x263EF8C08];
  if (a5 < 2) {
    return 4294967289;
  }
  unint64_t v13 = a4;
  v14[0] = a5;
  long long v11 = xmmword_2373BA5E0;
  uint64_t v12 = 0;
  ccn_shift_left_multi(3uLL, &v11, (unint64_t *)&v11, a2 << 6);
  ccn_muln(3, v10, (unint64_t *)&v11, 1uLL, &v13);
  ccn_divmod_ws(a1, 4, (uint64_t)v10, 3uLL, (uint64_t)v9, 1uLL, 0, v14);
  if (a2) {
    memcpy(a3, v9, 8 * a2);
  }
  return 0;
}

uint64_t ccrns_mul_modulus_init_var_time_ws(uint64_t a1, uint64_t *a2, uint64_t a3, unint64_t a4)
{
  uint64_t result = 4294967289;
  if (a3 >= 2 && a4 < a3)
  {
    *a2 = a3;
    a2[1] = a4;
    uint64_t v6 = __udivti3();
    uint64_t result = 0;
    a2[2] = v6;
  }
  return result;
}

void *ccpolyzp_po2cyc_scalar_divmod_ws(uint64_t a1, void *a2, unint64_t *a3, unint64_t *a4)
{
  unint64_t v14[2] = *MEMORY[0x263EF8C08];
  ccn_mul_ws(a1, 2uLL, v13, a3, a4 + 4);
  ccn_sub_ws(a1, 2, __src, (uint64_t *)a3, (unint64_t *)v14);
  ccn_shift_right(2, (uint64_t)__src, (unint64_t *)__src, 1uLL);
  ccn_add_ws(a1, 2, __src, __src, v14);
  unint64_t v8 = *a4;
  BOOL v10 = (*a4 & (*a4 - 1)) != 0 || v8 == 0;
  ccn_shift_right_multi(2, (uint64_t)__src, (unint64_t *)__src, v10 - __clz(v8) + 63 - 1);
  return ccn_set(1, a2, __src);
}

unint64_t ccpolyzp_po2cyc_rem_to_centered(uint64_t a1, uint64_t a2)
{
  return (((((unint64_t)(a2 - 1) >> 1) - a1) >> 63) - 1) & a1 | (a1 - a2) & ((uint64_t)(((unint64_t)(a2 - 1) >> 1)
                                                                                            - a1) >> 63);
}

uint64_t ccpolyzp_po2cyc_centered_to_rem(uint64_t a1, uint64_t a2)
{
  return (a2 + a1) & (a1 >> 63) | (((unint64_t)a1 >> 63) - 1) & a1;
}

uint64_t ccpolyzp_po2cyc_int_to_rem(uint64_t a1, void *a2)
{
  uint64_t v2 = ((unint64_t)a1 >> 63) - 1;
  uint64_t v3 = v2 & a1 | -a1 & (a1 >> 63);
  unint64_t v4 = v3 - *a2 * (((unint64_t)a2[1] * (unsigned __int128)(unint64_t)v3) >> 64);
  if ((uint64_t)(v4 - *a2) >= 0) {
    v4 -= *a2;
  }
  return (*a2 - v4) & -(uint64_t)(((v4 | HIDWORD(v4)) + 0xFFFFFFFF) >> 32) & (a1 >> 63) | v4 & v2;
}

uint64_t ccn_print(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v2 = a2 - 8;
    uint64_t v3 = (FILE **)MEMORY[0x263EF8C10];
    do
    {
      uint64_t v4 = result - 1;
      fprintf(*v3, "%.016llx", *(void *)(v2 + 8 * result));
      uint64_t result = v4;
    }
    while (v4);
  }
  return result;
}

size_t ccn_lprint(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = a1;
  unint64_t v5 = (FILE **)MEMORY[0x263EF8C10];
  fprintf((FILE *)*MEMORY[0x263EF8C10], "%s { %zu, ", a2, a1);
  for (; v4; --v4)
    fprintf(*v5, "%.016llx", *(void *)(a3 - 8 + 8 * v4));
  uint64_t v6 = *v5;

  return fwrite("}\n", 2uLL, 1uLL, v6);
}

uint64_t ccmode_gcm_mult_h(uint64_t a1, uint64_t a2)
{
  return ccmode_gcm_gf_mult(a1, a2, a2);
}

uint64_t cccmac_init_internal(void *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t __src[2] = *MEMORY[0x263EF8C08];
  uint64_t result = 4294967289;
  if (a3 <= 0x20 && ((1 << a3) & 0x101010000) != 0)
  {
    uint64_t v9 = a2 + 72;
    ccecb_init_internal((uint64_t)a1);
    __src[0] = 0;
    __src[1] = 0;
    cccbc_set_iv_internal((uint64_t)a1, (void *)(v9 + *a1), __src);
    *(void *)(a2 + 56) = 0;
    *(void *)(a2 + 64) = a1;
    *(void *)(a2 + 48) = 0;
    return cccmac_generate_subkeys((uint64_t)a1, a3, a4, (char *)a2, a2 + 16);
  }
  return result;
}

uint64_t cccmac_init(void *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t inited = cccmac_init_internal(a1, a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return inited;
}

uint64_t ccec_compute_key(unint64_t **a1, unint64_t **a2, unint64_t *a3, char *a4)
{
  BOOL v13 = timingsafe_enable_if_supported();
  unint64_t v8 = *a1;
  v11[0] = cc_malloc_clear(232 * **a1);
  v11[1] = 29 * *v8;
  void v11[2] = 0;
  v11[3] = cc_ws_alloc;
  uint64_t v12 = cc_ws_free;
  if (v11[0])
  {
    uint64_t v9 = ccecdh_compute_shared_secret_ws((uint64_t)v11, a1, a2, a3, a4, 0);
    v12((uint64_t)v11);
  }
  else
  {
    uint64_t v9 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v13);
  return v9;
}

uint64_t ccmode_gcm_finalize(int8x16_t *a1, size_t a2, char *a3)
{
  uint64_t v12 = *MEMORY[0x263EF8C08];
  ccmode_gcm_aad_finalize((uint64_t)a1);
  if (a1[5].i16[0] != 3) {
    return 4294967228;
  }
  unint64_t v6 = a1[6].u64[0];
  if ((v6 & 0xF) != 0)
  {
    ccmode_gcm_mult_h((uint64_t)a1, (uint64_t)a1[1].i64);
    unint64_t v6 = a1[6].u64[0];
  }
  unint64_t v7 = a1[5].u64[1];
  a1[4].i8[0] = v7 >> 53;
  a1[4].i8[1] = v7 >> 45;
  a1[4].i8[2] = v7 >> 37;
  a1[4].i8[3] = v7 >> 29;
  a1[4].i8[4] = v7 >> 21;
  a1[4].i8[5] = v7 >> 13;
  a1[4].i8[6] = v7 >> 5;
  a1[4].i8[7] = 8 * v7;
  a1[4].i8[8] = v6 >> 53;
  a1[4].i8[9] = v6 >> 45;
  a1[4].i8[10] = v6 >> 37;
  a1[4].i8[11] = v6 >> 29;
  a1[4].i8[12] = v6 >> 21;
  a1[4].i8[13] = v6 >> 13;
  a1[4].i8[14] = v6 >> 5;
  a1[4].i8[15] = 8 * v6;
  a1[1] = veorq_s8(a1[4], a1[1]);
  ccmode_gcm_mult_h((uint64_t)a1, (uint64_t)a1[1].i64);
  (*(void (**)(uint64_t, uint64_t, int8x16_t *, int8x16_t *))(a1[6].i64[1] + 24))(a1[7].i64[0], 1, a1 + 3, a1 + 4);
  int8x16_t v11 = veorq_s8(a1[4], a1[1]);
  if (a2 >= 0x10) {
    a2 = 16;
  }
  if (a1[7].i32[2] == 78647)
  {
    unsigned int v8 = cc_cmp_safe_internal(a2, v11.i8, a3);
    unint64_t v9 = -(((v8 | ((unint64_t)(int)v8 >> 32)) + 0xFFFFFFFF) >> 32) & 0xFFFFFFBB;
  }
  else
  {
    unint64_t v9 = 0;
  }
  memcpy(a3, &v11, a2);
  a1[5].i16[0] = 4;
  return v9;
}

uint64_t ccdh_init_gp_from_bytes(uint64_t *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  BOOL v52 = timingsafe_enable_if_supported();
  uint64_t v16 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v17 = sizeof_struct_ccpolyzp_po2cyc();
  uint64_t v18 = (20 * a2) | 2;
  v48[0] = cc_malloc_clear(8 * ((v16 + v17 - 1) / v17 + v18));
  uint64_t v19 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v20 = sizeof_struct_ccpolyzp_po2cyc();
  v48[1] = (v19 + v20 - 1) / v20 + v18;
  uint64_t v49 = 0;
  int32x4_t v50 = cc_ws_alloc;
  int32x4_t v51 = cc_ws_free;
  if (!v48[0])
  {
    uint64_t v29 = 4294967283;
    goto LABEL_32;
  }
  uint64_t v21 = a1 + 3;
  uint64_t uint_internal = ccn_read_uint_internal(a2, a1 + 3, a3, a4);
  if (!uint_internal)
  {
    uint64_t v23 = ccdh_gp_prime(a1);
    unint64_t v24 = ccn_n(a2, v23);
    *a1 = v24;
    uint64_t uint_internal = ccn_read_uint_internal(v24, &v21[v24 + 1 + v24], a5, a6);
    if (!uint_internal)
    {
      unint64_t v25 = (uint64_t *)ccdh_gp_prime(a1);
      unint64_t v26 = (uint64_t *)ccdh_gp_g(a1);
      long long v27 = (const void *)ccdh_lookup_gp(v24, v25, v24, v26);
      if (v27)
      {
        ccdh_copy_gp(a1, v27);
        uint64_t v28 = ccdh_gp_l(a1);
        uint64_t v29 = 0;
        uint64_t v30 = cc_ws_free;
        if (a9 && !v28)
        {
          uint64_t v29 = 0;
          uint64_t v31 = 160;
          if (a9 > 0xA0) {
            uint64_t v31 = a9;
          }
          v21[*a1 + 1 + *a1 + *a1 + *a1] = v31;
          goto LABEL_10;
        }
LABEL_31:
        v30((uint64_t)v48);
        goto LABEL_32;
      }
      uint64_t v32 = ccrng(0);
      if (!v32)
      {
        uint64_t v29 = 0xFFFFFFFFLL;
        cc_ws_free((uint64_t)v48);
        goto LABEL_32;
      }
      int v33 = v32;
      uint64_t v34 = (unint64_t *)ccdh_gp_prime(a1);
      uint64_t v35 = ccprime_rabin_miller_ws((uint64_t)v48, v24, v34, 5uLL, (uint64_t (**)(void, unint64_t, uint64_t))v33);
      uint64_t v29 = v35;
      if ((v35 & 0x80000000) == 0)
      {
        if (v35 != 1)
        {
          uint64_t v29 = 4294967130;
          goto LABEL_30;
        }
        char v36 = &v21[*a1 + 1 + *a1 + *a1];
        v36[*a1] = 0;
        if (!a8)
        {
          ccn_zero(v24, v36);
          if (a9)
          {
            uint64_t v40 = 160;
            if (a9 > 0xA0) {
              uint64_t v40 = a9;
            }
            v21[*a1 + 1 + *a1 + *a1 + *a1] = v40;
          }
          if ((*(unsigned char *)ccdh_gp_prime(a1) & 1) == 0)
          {
            uint64_t v29 = 4294967289;
            goto LABEL_30;
          }
          uint64_t v41 = v49;
          uint64_t v42 = ccdh_gp_n(a1);
          long long v43 = (unint64_t *)v50(v48, v42);
          uint64_t v44 = (unint64_t *)ccdh_gp_prime(a1);
          ccn_shift_right(v42, (uint64_t)v43, v44, 1uLL);
          uint64_t v45 = ccprime_rabin_miller_ws((uint64_t)v48, v42, v43, 5uLL, (uint64_t (**)(void, unint64_t, uint64_t))v33);
          uint64_t v29 = v45;
          uint64_t v49 = v41;
          if ((v45 & 0x80000000) != 0) {
            goto LABEL_30;
          }
          if (v45 != 1)
          {
            uint64_t v29 = 4294967128;
            goto LABEL_30;
          }
LABEL_28:
          uint64_t inited = cczp_init_ws((uint64_t)v48, a1);
          goto LABEL_29;
        }
        uint64_t inited = ccn_read_uint_internal(v24, v36, a7, a8);
        if (inited)
        {
LABEL_29:
          uint64_t v29 = inited;
          goto LABEL_30;
        }
        uint64_t v38 = (unint64_t *)ccdh_gp_order(a1);
        uint64_t v39 = ccprime_rabin_miller_ws((uint64_t)v48, v24, v38, 5uLL, (uint64_t (**)(void, unint64_t, uint64_t))v33);
        uint64_t v29 = v39;
        if ((v39 & 0x80000000) == 0)
        {
          if (v39 != 1)
          {
            uint64_t v29 = 4294967129;
            goto LABEL_30;
          }
          goto LABEL_28;
        }
      }
LABEL_30:
      uint64_t v49 = 0;
      uint64_t v30 = v51;
      goto LABEL_31;
    }
  }
  uint64_t v29 = uint_internal;
LABEL_10:
  cc_ws_free((uint64_t)v48);
LABEL_32:
  cc_disable_dit_with_sb((unsigned int *)&v52);
  return v29;
}

uint64_t ccrsa_emsa_pss_encode_internal(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, size_t a5, char *a6, unint64_t a7, unsigned char *a8)
{
  __src[1] = *MEMORY[0x263EF8C08];
  unint64_t v8 = (a7 + 7) >> 3;
  size_t v9 = a5 + a3;
  if (8 * (a5 + a3) + 9 > a7 || v8 < a5 + a3 + 2) {
    return 4294967271;
  }
  uint64_t v16 = a4;
  size_t v17 = a3;
  uint64_t v30 = a2;
  unint64_t v31 = a7 + 7;
  uint64_t v32 = &v27;
  __src[0] = 0;
  size_t v28 = ~a5;
  uint64_t v29 = &a8[v8 + ~a5];
  uint64_t v19 = MEMORY[0x270FA53B0](a1, a2, a3, a4);
  uint64_t v21 = (uint64_t *)((char *)&v27 - v20);
  ccdigest_init_internal(v19, (uint64_t *)((char *)&v27 - v20));
  ccdigest_update_internal((unint64_t *)a1, v21, 8uLL, (char *)__src);
  ccdigest_update_internal((unint64_t *)a1, v21, a5, a6);
  if (v17) {
    ccdigest_update_internal((unint64_t *)a1, v21, v17, v16);
  }
  unint64_t v22 = v29;
  (*(void (**)(uint64_t, void *, char *))(a1 + 56))(a1, v21, v29);
  cc_clear(*(void *)(a1 + 8) + *(void *)(a1 + 16) + 12, v21);
  LODWORD(result) = ccmgf_internal(v30, v8 + v28, (uint64_t)a8, a5, v22);
  a8[v8 - v9 - 2] ^= 1u;
  if (v17)
  {
    uint64_t v23 = &a8[~v9 + v8];
    do
    {
      char v24 = *v16++;
      *v23++ ^= v24;
      --v17;
    }
    while (v17);
  }
  unint64_t v25 = (v31 & 0xFFFFFFFFFFFFFFF8) - a7;
  if (v25 >= 8) {
    uint64_t result = 0xFFFFFFFFLL;
  }
  else {
    uint64_t result = result;
  }
  if (v25 >= 8) {
    char v26 = -1;
  }
  else {
    char v26 = 0xFFu >> v25;
  }
  *a8 &= v26;
  a8[v8 - 1] = -68;
  return result;
}

uint64_t ccrsa_emsa_pss_encode(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, size_t a5, char *a6, unint64_t a7, unsigned char *a8)
{
  BOOL v18 = timingsafe_enable_if_supported();
  uint64_t v16 = ccrsa_emsa_pss_encode_internal(a1, a2, a3, a4, a5, a6, a7, a8);
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return v16;
}

uint64_t ccsrp_generate_v_ws(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = *(void **)(a2 + 8);
  unint64_t v7 = 8 * **(void **)a2;
  unint64_t v8 = *(uint64_t (***)(void, uint64_t, uint64_t *))(a2 + 16);
  size_t v9 = (uint64_t *)(a2 + 16 * ccdh_gp_n(v6) + 32);
  BOOL v10 = (void *)ccdh_gp_g(*(void **)(a2 + 8));

  return ccdh_power_blinded_ws(a1, v8, v6, v9, v10, v7, a3);
}

uint64_t ccsrp_generate_verifier(uint64_t a1, char *a2, size_t a3, char *a4, size_t a5, char *a6, char *a7)
{
  BOOL v16 = timingsafe_enable_if_supported();
  verifier_uint64_t internal = ccsrp_generate_verifier_internal(a1, a2, a3, a4, a5, a6, a7);
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return verifier_internal;
}

uint64_t ccsrp_generate_verifier_internal(uint64_t a1, char *a2, size_t a3, char *a4, size_t a5, char *a6, char *a7)
{
  uint64_t v14 = ccdh_gp_n(*(void *)(a1 + 8));
  uint64_t v15 = CCDH_POWER_BLINDED_WORKSPACE_N(v14);
  v25[0] = cc_malloc_clear(8 * (v15 + v14));
  v25[1] = CCDH_POWER_BLINDED_WORKSPACE_N(v14) + v14;
  uint64_t v26 = 0;
  uint64_t v27 = cc_ws_alloc;
  size_t v28 = cc_ws_free;
  if (!v25[0]) {
    return 4294967283;
  }
  uint64_t v16 = ccdh_gp_n(*(void *)(a1 + 8));
  size_t v17 = (void *)cc_ws_alloc(v25, v16);
  uint64_t v18 = ccdh_gp_n(*(void *)(a1 + 8));
  v16 *= 8;
  cc_clear(v16, (void *)(a1 + 32 + 16 * v18));
  cc_clear(v16, v17);
  uint64_t x = ccsrp_generate_x(a1, (uint64_t)v17, a2, a5, a6, a3, a4);
  if (x || (uint64_t x = ccsrp_generate_v_ws((uint64_t)v25, a1, (uint64_t)v17), x))
  {
    uint64_t v23 = x;
  }
  else
  {
    uint64_t v20 = (unint64_t *)(a1 + 32 + 16 * ccdh_gp_n(*(void *)(a1 + 8)));
    unint64_t v21 = ccdh_gp_n(*(void *)(a1 + 8));
    uint64_t v22 = ccdh_gp_n(*(void *)(a1 + 8));
    ccn_write_uint_padded_ct_internal(v21, v20, 8 * v22, a7);
    uint64_t v23 = 0;
  }
  uint64_t v26 = 0;
  v28((uint64_t)v25);
  return v23;
}

uint64_t ccsrp_generate_salt_and_verification(uint64_t a1, uint64_t (**a2)(void, size_t, char *), char *a3, size_t a4, char *a5, size_t a6, char *a7, char *a8)
{
  BOOL v18 = timingsafe_enable_if_supported();
  verifier_uint64_t internal = (*a2)(a2, a6, a7);
  if (!verifier_internal) {
    verifier_uint64_t internal = ccsrp_generate_verifier_internal(a1, a3, a4, a5, a6, a7, a8);
  }
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return verifier_internal;
}

BOOL ccdh_valid_shared_secret(unint64_t a1, uint64_t *a2, uint64_t a3)
{
  unint64_t v6 = a1 - 1;
  uint64_t v7 = ccdh_gp_prime(a3);
  int v8 = ccn_cmp_internal(v6, v7 + 8, a2 + 1);
  uint64_t v9 = *a2;
  BOOL v10 = (_DWORD *)ccdh_gp_prime(a3);
  if (!a1) {
    return 0;
  }
  unint64_t v11 = (*v10 - 1) ^ v9 | v8 | (((*(void *)v10 - 1) ^ v9 | (unint64_t)v8) >> 32);
  if (ccn_n(a1, (uint64_t)a2) > 1) {
    return v11 != 0;
  }
  BOOL result = 0;
  if ((unint64_t)*a2 >= 2 && v11) {
    return 1;
  }
  return result;
}

uint64_t ccvrf_irtf_ed25519_prove(uint64_t a1, char *a2, char *a3, size_t a4, _OWORD *a5)
{
  int v8 = a2;
  uint64_t v25 = *MEMORY[0x263EF8C08];
  memset(v12, 0, sizeof(v12));
  int v10 = ccvrf_irtf_ed25519_derive_scalar_internal(a1, a2, v18, v17);
  LODWORD(v8) = ccvrf_irtf_ed25519_derive_public_key_internal(a1, v8, v12);
  memset(v24, 0, sizeof(v24));
  memset(__s, 0, sizeof(__s));
  long long v21 = 0u;
  long long v22 = 0u;
  memset(v20, 0, sizeof(v20));
  memset(v16, 0, sizeof(v16));
  memset(v15, 0, sizeof(v15));
  memset(v14, 0, sizeof(v14));
  memset(v13, 0, sizeof(v13));
  ccvrf_irtf_ed25519_hash2curve_elligator2(*(void *)(a1 + 40), (uint64_t)v12, a3, a4, (uint64_t)v24);
  ge_frombytes_vartime((int *)v16, (uint64_t)v24);
  ge_scalarmult(v15, v18, (uint64_t)v16);
  ccvrf_irtf_nonce_generation(*(void *)(a1 + 40), __s, v17, (char *)v24);
  ge_scalarmult_base(v14, __s);
  ge_scalarmult(v13, __s, (uint64_t)v16);
  v19[0] = (int *)v16;
  v19[1] = (int *)v15;
  unint64_t v19[2] = (int *)v14;
  void v19[3] = (int *)v13;
  ccvrf_irtf_ed25519_hash_points(a1, v19, 4, &v21);
  cc_clear(0x10uLL, &v22);
  sc_muladd(v20, (unsigned __int16 *)&v21, (unsigned __int16 *)v18, (unsigned __int16 *)__s);
  ccvrf_irtf_ed25519_encode_proof((int *)v15, &v21, v20, a5);
  cc_clear(0x20uLL, __s);
  cc_clear(0x20uLL, v24);
  cc_clear(0x20uLL, &v21);
  cc_clear(0xA0uLL, v16);
  cc_clear(0xA0uLL, v15);
  cc_clear(0xA0uLL, v14);
  cc_clear(0xA0uLL, v13);
  cc_clear(0x20uLL, v18);
  cc_clear(0x20uLL, v17);
  cc_clear(0xA0uLL, v12);
  return v8 | v10;
}

uint64_t ccvrf_prove(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  BOOL v16 = timingsafe_enable_if_supported();
  if (ccvrf_sizeof_secret_key(a1) == a2 && ccvrf_sizeof_proof(a1) == a6) {
    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 64))(a1, a3, a5, a4, a7);
  }
  else {
    uint64_t v14 = 4294967289;
  }
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v14;
}

uint64_t ccvrf_irtf_nonce_generation(uint64_t a1, _OWORD *a2, char *a3, char *a4)
{
  uint64_t v15 = *MEMORY[0x263EF8C08];
  uint64_t v8 = MEMORY[0x270FA53B0](a1, a2, a3, a4);
  int v10 = (uint64_t *)((char *)&v13 - v9);
  ccdigest_init_internal(v8, (uint64_t *)((char *)&v13 - v9));
  ccdigest_update_internal((unint64_t *)a1, v10, 0x20uLL, a3);
  ccdigest_update_internal((unint64_t *)a1, v10, 0x20uLL, a4);
  (*(void (**)(uint64_t, void *, _OWORD *))(a1 + 56))(a1, v10, __s);
  sc_reduce((unsigned __int16 *)__s);
  long long v11 = __s[1];
  *a2 = __s[0];
  a2[1] = v11;
  cc_clear(0x40uLL, __s);
  return cc_clear(*(void *)(a1 + 8) + *(void *)(a1 + 16) + 12, v10);
}

BOOL ccn_add1_ws(uint64_t a1, uint64_t a2, void *a3, uint64_t *a4, BOOL a5)
{
  for (BOOL result = a5; a2; --a2)
  {
    uint64_t v6 = *a4++;
    uint64_t v7 = result + v6;
    BOOL result = __CFADD__(result, v6);
    *a3++ = v7;
  }
  return result;
}

BOOL ccn_add1(uint64_t a1, void *a2, uint64_t *a3, BOOL a4)
{
  BOOL v13 = timingsafe_enable_if_supported();
  v11[0] = xmmword_26EA478D8;
  v11[1] = *(_OWORD *)algn_26EA478E8;
  for (uint64_t i = off_26EA478F8[0]; a1; --a1)
  {
    uint64_t v8 = *a3++;
    uint64_t v9 = a4 + v8;
    a4 = __CFADD__(a4, v8);
    *a2++ = v9;
  }
  cc_ws_free_null(v11);
  cc_disable_dit_with_sb((unsigned int *)&v13);
  return a4;
}

uint64_t ccmode_ctr_setctr(int a1, void *a2, void *__src)
{
  uint64_t v3 = *a2;
  a2[1] = *(void *)(*a2 + 8);
  memcpy((char *)a2 + ((*(void *)(v3 + 8) + 7) & 0xFFFFFFFFFFFFFFF8) + 16, __src, *(void *)(v3 + 8));
  return 0;
}

uint64_t ccrsa_eme_pkcs1v15_decode_safe_ws(uint64_t a1, void *a2, rsize_t *a3, void *a4, size_t a5, unint64_t *a6)
{
  uint64_t v16 = *MEMORY[0x263EF8C08];
  uint64_t v12 = ccsha256_di();
  ccdigest_internal((uint64_t)v12, 8 * *a2, (char *)&a2[3 * *a2 + 4], (uint64_t)__s);
  uint64_t v13 = ccrsa_eme_pkcs1v15_decode_internal_ws(a1, (uint64_t)__s, a3, a4, a5, a6);
  cc_clear(0x20uLL, __s);
  return v13;
}

uint64_t ccrsa_eme_pkcs1v15_decode_internal_ws(uint64_t a1, uint64_t a2, rsize_t *a3, void *a4, size_t a5, unint64_t *a6)
{
  uint64_t v44 = *MEMORY[0x263EF8C08];
  uint64_t v6 = 4294967273;
  if (a5 < 0xB || *a3 < a5) {
    return v6;
  }
  rsize_t v29 = a5 - 11;
  uint64_t v12 = *(void *)(a1 + 16);
  unint64_t v13 = ccrsa_n_from_size(a5);
  ccn_swap(v13, a6);
  uint64_t v14 = (char *)ccrsa_block_start(a5, a6, 0);
  size_t v28 = (unint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v13);
  unint64_t v35 = 0;
  uint64_t v40 = 0;
  memset(v39, 0, sizeof(v39));
  v38[1] = 0;
  v38[0] = ccsha256_di();
  ccdrbg_factory_nisthmac(v39, (uint64_t)v38);
  uint64_t v15 = ccsha256_di();
  ccdigest_internal((uint64_t)v15, a5, v14, (uint64_t)__s);
  strcpy(v42, "ccrsa_eme_pkcs1v15_decode_generate_random");
  memset(v41, 0, sizeof(v41));
  uint64_t inited = ccdrbg_init_internal((uint64_t)v39);
  if (inited
    || (memset(v37, 0, sizeof(v37)),
        uint64_t inited = ccrng_drbg_init_withdrbg((uint64_t (**)(uint64_t, uint64_t, uint64_t))v37, (uint64_t (*)(uint64_t, uint64_t, uint64_t))v39, (uint64_t (*)(uint64_t, uint64_t, uint64_t))v41), inited)|| (uint64_t inited = v37[0](v37, v29, v28), inited))
  {
    uint64_t v6 = inited;
    goto LABEL_16;
  }
  unint64_t v36 = 0;
  uint64_t v6 = ccrng_uniform_internal(v37, a5 - 10, &v36);
  if (v6)
  {
LABEL_16:
    uint64_t v17 = 0;
    goto LABEL_8;
  }
  uint64_t v17 = v36;
  unint64_t v35 = v36;
LABEL_8:
  cc_clear(0x20uLL, __s);
  cc_clear(8uLL, &v36);
  ccdrbg_done((uint64_t)v39, (uint64_t)v41);
  if (v6)
  {
    cc_clear(v29, v28);
    cc_clear(8uLL, &v35);
  }
  else
  {
    unint64_t v26 = v13;
    uint64_t v27 = v12;
    uint64_t v18 = 0;
    unint64_t v19 = ((v14[1] ^ 2 | (unint64_t)*v14) + 0xFFFFFFFF) >> 32;
    int v20 = 1;
    uint64_t v21 = 2;
    do
    {
      unint64_t v22 = ((unint64_t)v14[v21] + 0xFFFFFFFF) >> 32;
      uint64_t v18 = v18 & (v20 - 1) | v21 & -v20;
      uint64_t v33 = v18;
      v20 &= v22;
      char v32 = v20;
      ++v21;
    }
    while (a5 != v21);
    size_t v31 = ~v18 + a5;
    uint64_t v30 = v18 - 2;
    unsigned int v23 = (((((unint64_t)(v18 - 2) >> 3) | ((unint64_t)(v18 - 2) >> 35)) + 0xFFFFFFFF) >> 32) ^ 1 | v20 | v19;
    unsigned int v34 = v23;
    uint64_t v24 = v18 + 1;
    cc_clear(*a3, a4);
    *(void *)&v41[0] = *a3;
    ccrsa_xor_varlen((uint64_t *)v41, (uint64_t)a4, v23, v29, v17, (unsigned __int8 *)v28);
    *(void *)&v39[0] = *a3;
    ccrsa_xor_varlen((uint64_t *)v39, (uint64_t)a4, v23 ^ 1, a5, v24, (unsigned __int8 *)v14);
    *a3 = v39[0] & (v23 - 1) | (unint64_t)(v41[0] & -v23);
    cc_clear(8uLL, v41);
    cc_clear(8uLL, v39);
    unint64_t v13 = v26;
    uint64_t v12 = v27;
  }
  ccn_swap(v13, a6);
  cc_clear(8uLL, &v35);
  cc_clear(4uLL, &v34);
  cc_clear(8uLL, &v33);
  cc_clear(1uLL, &v32);
  cc_clear(8uLL, &v31);
  cc_clear(8uLL, &v30);
  *(void *)(a1 + 16) = v12;
  return v6;
}

uint64_t ccrsa_eme_pkcs1v15_decode_safe(uint64_t *a1, rsize_t *a2, void *a3, size_t a4, unint64_t *a5)
{
  BOOL v16 = timingsafe_enable_if_supported();
  int v10 = cc_malloc_clear(8 * *a1);
  uint64_t v11 = *a1;
  v14[0] = v10;
  v14[1] = v11;
  unint64_t v14[2] = 0;
  uint64_t v14[3] = cc_ws_alloc;
  uint64_t v15 = cc_ws_free;
  if (v10)
  {
    uint64_t v12 = ccrsa_eme_pkcs1v15_decode_safe_ws((uint64_t)v14, a1, a2, a3, a4, a5);
    v15((uint64_t)v14);
  }
  else
  {
    uint64_t v12 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v12;
}

uint64_t ccrsa_eme_pkcs1v15_decode(rsize_t *a1, void *a2, size_t a3, unint64_t *a4)
{
  BOOL v15 = timingsafe_enable_if_supported();
  unint64_t v8 = ccrsa_n_from_size(a3);
  v13[0] = cc_malloc_clear(8 * v8);
  v13[1] = v8;
  _OWORD v13[2] = 0;
  void v13[3] = cc_ws_alloc;
  uint64_t v14 = cc_ws_free;
  if (!v13[0])
  {
    uint64_t v10 = 4294967283;
    goto LABEL_9;
  }
  unsigned int v12 = 0;
  if ((ccrsa_eme_pkcs1v15_decode_entropy_init & 1) == 0)
  {
    uint64_t v9 = ccrng(&v12);
    if (!v9) {
      goto LABEL_7;
    }
    unsigned int v12 = ((uint64_t (*)(uint64_t *, uint64_t, void *))*v9)(v9, 32, &ccrsa_eme_pkcs1v15_decode_entropy);
    if (v12) {
      goto LABEL_7;
    }
    ccrsa_eme_pkcs1v15_decode_entropy_init = 1;
  }
  unsigned int v12 = ccrsa_eme_pkcs1v15_decode_internal_ws((uint64_t)v13, (uint64_t)&ccrsa_eme_pkcs1v15_decode_entropy, a1, a2, a3, a4);
LABEL_7:
  v14((uint64_t)v13);
  uint64_t v10 = v12;
LABEL_9:
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v10;
}

uint64_t *ccrsa_xor_varlen(uint64_t *result, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, unsigned __int8 *a6)
{
  if (*result)
  {
    unint64_t v6 = 0;
    uint64_t v7 = -a5;
    do
    {
      int v8 = 0;
      if (a4)
      {
        uint64_t v9 = a6;
        unint64_t v10 = v7;
        uint64_t v11 = a4;
        do
        {
          int v12 = *v9++;
          v8 ^= v12 & -a3 & ((((v10 | HIDWORD(v10)) + 0xFFFFFFFF) >> 32) - 1);
          ++v10;
          --v11;
        }
        while (v11);
      }
      *(unsigned char *)(a2 + v6++) ^= v8;
      uint64_t v13 = *result;
      --v7;
    }
    while (v6 < *result);
  }
  else
  {
    uint64_t v13 = 0;
  }
  *BOOL result = v13 & (a3 - 1) | (a4 - a5) & -(uint64_t)a3;
  return result;
}

uint64_t ccckg_ctx_cp(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t ccckg_ctx_di(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

unint64_t ccckg_sizeof_ctx(void *a1, void *a2)
{
  return ((2 * *a2 + 14) & 0xFFFFFFFFFFFFFFF0) + 8 * *a1 + 40;
}

uint64_t ccckg_sizeof_commitment(uint64_t a1, uint64_t a2)
{
  return *(void *)a2;
}

unint64_t ccckg_sizeof_share(uint64_t a1, void *a2)
{
  return (((unint64_t)(cczp_bitlen(a1) + 7) >> 2) | 1) + *a2;
}

unint64_t ccckg_sizeof_opening(void *a1, void *a2)
{
  return *a2 + ((unint64_t)(cczp_bitlen((uint64_t)&a1[5 * *a1 + 4]) + 7) >> 3);
}

uint64_t ccckg_init(_DWORD *__s, void *a2, void *a3, uint64_t a4)
{
  *int8x16_t __s = 1;
  *((void *)__s + 1) = a2;
  *((void *)__s + 2) = a3;
  *((void *)__s + 3) = a4;
  *((unsigned char *)__s + 32) = 0;
  return 0;
}

uint64_t ccckg_derive_sk(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  uint64_t v22 = *MEMORY[0x263EF8C08];
  int v12 = *(unint64_t **)(a1 + 8);
  uint64_t v11 = *(unint64_t **)(a1 + 16);
  unint64_t v13 = *v12;
  uint64_t v14 = cczp_bitlen((uint64_t)v12);
  ccn_write_uint_padded_internal(v13, a2, (unint64_t)(v14 + 7) >> 3, v21);
  uint64_t v17 = a3;
  unint64_t v18 = *v11;
  uint64_t v19 = a4;
  unint64_t v20 = v18;
  uint64_t v15 = cczp_bitlen((uint64_t)v12);
  return ccansikdf_x963_iovec(v11, (unint64_t)(v15 + 7) >> 3, v21, 2, (uint64_t)&v17, a5, a6);
}

uint64_t ccsrp_generate_x(uint64_t a1, uint64_t a2, char *a3, size_t a4, char *a5, size_t a6, char *a7)
{
  uint64_t v24 = *MEMORY[0x263EF8C08];
  uint64_t v14 = *(void *)a1;
  MEMORY[0x270FA53B0](a1, a2, a3, a4);
  BOOL v16 = &__src[-v15 - 8];
  ccdigest_init_internal(v14, &__src[-v15 - 8]);
  if ((*(unsigned char *)(a1 + 24) & 2) == 0)
  {
    size_t v17 = strlen(a3);
    ccdigest_update_internal((unint64_t *)v14, v16, v17, a3);
  }
  ccdigest_update_internal((unint64_t *)v14, v16, 1uLL, ":");
  ccdigest_update_internal((unint64_t *)v14, v16, a6, a7);
  (*(void (**)(uint64_t, char *, char *))(v14 + 56))(v14, v16, __src);
  ccdigest_init_internal(v14, v16);
  ccdigest_update_internal((unint64_t *)v14, v16, a4, a5);
  ccdigest_update_internal((unint64_t *)v14, v16, *(void *)v14, __src);
  (*(void (**)(uint64_t, char *, char *))(v14 + 56))(v14, v16, __src);
  unint64_t v18 = *(void *)v14;
  uint64_t v19 = ccdh_gp_n(*(void *)(a1 + 8));
  uint64_t uint_internal = ccn_read_uint_internal(v19, a2, v18, __src);
  cc_clear(*(void *)v14, __src);
  cc_clear(*(void *)(v14 + 8) + *(void *)(v14 + 16) + 12, v16);
  return uint_internal;
}

unint64_t ccecies_pub_key_size(uint64_t *a1, uint64_t a2)
{
  return ccecies_pub_key_size_cp(*a1, a2);
}

unint64_t ccecies_pub_key_size_cp(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 32);
  if ((v2 & 2) != 0) {
    return ((unint64_t)(cczp_bitlen(a1) + 7) >> 2) | 1;
  }
  if ((v2 & 4) != 0) {
    return (unint64_t)(cczp_bitlen(a1) + 7) >> 3;
  }
  return 0;
}

unint64_t CCHE_CIPHER_PLAIN_CTX_INIT_WORKSPACE_N(uint64_t a1)
{
  if (3 * (unint64_t)a1 + 3 <= 2 * (unint64_t)a1) {
    uint64_t v1 = 2 * a1;
  }
  else {
    uint64_t v1 = 3 * a1 + 3;
  }
  uint64_t v2 = a1;
  if (a1) {
    unint64_t v3 = v1;
  }
  else {
    unint64_t v3 = 3;
  }
  unint64_t v4 = CCPOLYZP_PO2CYC_CTX_Q_PROD_WORKSPACE_N(a1);
  if (v4 <= v3) {
    unint64_t v5 = v3;
  }
  else {
    unint64_t v5 = v4;
  }
  return v5 + 2 * v2;
}

uint64_t cche_cipher_plain_ctx_init_ws(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v18[1] = *MEMORY[0x263EF8C08];
  unint64_t v8 = *(unsigned int *)(a4 + 4);
  *(void *)a2 = a3;
  *(void *)(a2 + 8) = a4;
  uint64_t v9 = *(void *)(a1 + 16);
  unint64_t v10 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v8);
  ccpolyzp_po2cyc_ctx_q_prod_ws(a1, v10, a4);
  v18[0] = cche_param_ctx_plaintext_modulus(a3);
  uint64_t v11 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v8);
  ccn_divmod_ws(a1, v8, (uint64_t)v10, v8, (uint64_t)v11, 1uLL, (char *)(a2 + 16), v18);
  *(void *)(a2 + 24) = (unint64_t)(cche_param_ctx_plaintext_modulus(a3) + 1) >> 1;
  if (v8)
  {
    unsigned int v12 = 0;
    unint64_t v13 = (uint64_t *)(a2 + 32);
    uint64_t v14 = (void *)(a2 + 32 + 8 * *(unsigned int *)(*(void *)(a2 + 8) + 4));
    while (1)
    {
      unsigned int v15 = *(_DWORD *)(a4 + 4) - 1;
      BOOL v16 = (void *)a4;
      if (v15 > v12)
      {
        BOOL v16 = (void *)a4;
        do
        {
          BOOL v16 = (void *)v16[14];
          --v15;
        }
        while (v15 > v12);
      }
      cczp_modn_ws(a1, v16 + 15, v13, v8, v11);
      if (ccn_sub_ws(a1, 1, v14, v16 + 18, v18)) {
        break;
      }
      ++v13;
      ++v14;
      if (++v12 == v8) {
        goto LABEL_8;
      }
    }
    uint64_t result = 0xFFFFFFFFLL;
  }
  else
  {
LABEL_8:
    uint64_t result = 0;
  }
  *(void *)(a1 + 16) = v9;
  return result;
}

uint64_t ccder_blob_encode_uint64(uint64_t *a1, unint64_t a2)
{
  return ccder_blob_encode_implicit_uint64(a1, 2uLL, a2);
}

uint64_t ccdigest_final_64be(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v22[1] = *MEMORY[0x263EF8C08];
  uint64_t v7 = *(void *)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 16);
  uint64_t v8 = a2 + v7 + 8;
  if (v6 <= *(unsigned int *)(v8 + v6)) {
    *(_DWORD *)(v8 + v6) = 0;
  }
  MEMORY[0x270FA53B0](a1, a2, a3, a4);
  unint64_t v10 = (void *)((char *)v22 - v9);
  memcpy((char *)v22 - v9, v12, v11 + 12);
  unint64_t v13 = (char *)v10 + v7;
  uint64_t v14 = (uint64_t)v10 + v7 + 8;
  unsigned int v15 = (char *)(v14 + v6);
  uint64_t v16 = *(unsigned int *)(v14 + v6);
  *v10 += (8 * v16);
  *(_DWORD *)(v14 + v6) = v16 + 1;
  *(unsigned char *)(v14 + v16) = 0x80;
  unint64_t v17 = *(unsigned int *)(v14 + v6);
  if (v17 < 0x39)
  {
    if (v17 == 56) {
      goto LABEL_9;
    }
  }
  else
  {
    if (v17 <= 0x3F)
    {
      do
      {
        *(_DWORD *)unsigned int v15 = v17 + 1;
        *(unsigned char *)(v14 + v17) = 0;
        unint64_t v17 = *(unsigned int *)v15;
      }
      while (v17 < 0x40);
    }
    (*(void (**)(unint64_t *, uint64_t))(a1 + 48))(v10 + 1, 1);
    unint64_t v17 = 0;
    unint64_t v13 = (char *)v10 + *(void *)(a1 + 8);
    uint64_t v14 = (uint64_t)(v13 + 8);
    unsigned int v15 = &v13[*(void *)(a1 + 16) + 8];
    *(_DWORD *)unsigned int v15 = 0;
  }
  do
  {
    *(_DWORD *)unsigned int v15 = v17 + 1;
    *(unsigned char *)(v14 + v17) = 0;
    unint64_t v17 = *(unsigned int *)v15;
  }
  while (v17 < 0x38);
LABEL_9:
  *((void *)v13 + 8) = bswap64(*v10);
  (*(void (**)(unint64_t *, uint64_t))(a1 + 48))(v10 + 1, 1);
  if (*(void *)a1 >= 4uLL)
  {
    unsigned int v18 = 0;
    unint64_t v19 = 0;
    unsigned int v20 = 1;
    do
    {
      *(_DWORD *)(a3 + v18) = bswap32(*((_DWORD *)v10 + v19 + 2));
      unint64_t v19 = v20++;
      v18 += 4;
    }
    while (v19 < *(void *)a1 >> 2);
  }
  return cc_clear(*(void *)(a1 + 8) + *(void *)(a1 + 16) + 12, v10);
}

uint64_t ccecb_context_size(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t ccecb_block_size(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t ccecb_init_internal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

uint64_t ccecb_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 16))(a1, a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccecb_update_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(a2, a3, a4, a5);
}

uint64_t ccecb_update(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccecb_one_shot_explicit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  BOOL v16 = timingsafe_enable_if_supported();
  uint64_t v14 = ccecb_one_shot_explicit_internal(a1, a2, a3, a4, a5, a6, a7);
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v14;
}

uint64_t ccecb_one_shot_explicit_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v18[1] = *MEMORY[0x263EF8C08];
  if (*(void *)(a1 + 8) != a3) {
    return 4294967289;
  }
  uint64_t v11 = MEMORY[0x270FA53B0](a1, a2, a3, a4);
  unint64_t v13 = (char *)v18 - v12;
  uint64_t v16 = (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(v11 + 16))(v11, (char *)v18 - v12, v15, v14);
  if (!v16) {
    uint64_t v16 = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(a1 + 24))(v13, a4, a6, a7);
  }
  cc_clear(*(void *)a1, v13);
  return v16;
}

uint64_t ccecb_one_shot(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v12 = ccecb_one_shot_explicit_internal(a1, a2, *(void *)(a1 + 8), a4, a3, a5, a6);
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v12;
}

uint64_t ccckg2_contributor_commit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (**a4)(void, uint64_t, unint64_t *))
{
  BOOL v19 = timingsafe_enable_if_supported();
  uint64_t v8 = (uint64_t *)ccckg2_ctx_cp(a1);
  uint64_t v9 = *v8;
  uint64_t v10 = sizeof_struct_cche_galois_key();
  unint64_t v11 = sizeof_struct_ccpolyzp_po2cyc();
  v17[0] = cc_malloc_clear(8 * ((v10 + v11 + 4 * v9 * v11 - 1) / v11 + 49 * v9));
  uint64_t v12 = *v8;
  uint64_t v13 = sizeof_struct_cche_galois_key();
  unint64_t v14 = sizeof_struct_ccpolyzp_po2cyc();
  v17[1] = (v13 + v14 + 4 * v12 * v14 - 1) / v14 + 49 * v12;
  uint64_t v17[2] = 0;
  _OWORD v17[3] = cc_ws_alloc;
  unsigned int v18 = cc_ws_free;
  if (v17[0])
  {
    uint64_t v15 = ccckg2_contributor_commit_ws((uint64_t)v17, a1, a2, a3, a4);
    v18((uint64_t)v17);
  }
  else
  {
    uint64_t v15 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v19);
  return v15;
}

uint64_t ccckg2_contributor_commit_ws(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (**a5)(void, uint64_t, unint64_t *))
{
  uint64_t v32 = *MEMORY[0x263EF8C08];
  uint64_t v10 = ccckg2_ctx_di(a2);
  unint64_t v11 = (unint64_t *)ccckg2_ctx_cp(a2);
  unint64_t v12 = *v11;
  MEMORY[0x270FA53B0](v11, v13, v14, v15);
  unint64_t v17 = (uint64_t *)((char *)&v29 - v16);
  if (*(unsigned char *)(a2 + 32)) {
    return 4294967210;
  }
  if (*(_DWORD *)a2 != 2 || *(void *)v10 != a3) {
    return 4294967289;
  }
  uint64_t v30 = *(void *)(a1 + 16);
  BOOL v19 = (unint64_t **)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, (4 * (v12 & 0x7FFFFFFFFFFFFFFLL)) | 2);
  *BOOL v19 = v11;
  uint64_t v20 = a2 + 40;
  uint64_t result = ccec_generate_scalar_fips_retry_ws(a1, v11, (uint64_t (**)(void, unint64_t, void *))a5, (void *)(a2 + 40));
  if (!result)
  {
    uint64_t result = ccec_generate_key_fips_ws(a1, v11, a5, v19);
    if (!result)
    {
      uint64_t v21 = (void *)ccckg2_ctx_cp(a2);
      ccn_set(v12, (void *)(v20 + 8 * *v21), &v19[3 * **v19 + 2]);
      uint64_t v22 = (void *)ccckg2_ctx_cp(a2);
      unsigned int v23 = (void *)ccckg2_ctx_cp(a2);
      uint64_t result = ccec_export_pub((uint64_t *)v19, (char *)(v20 + 8 * *v23 + 8 * *v22));
      if (!result)
      {
        uint64_t v24 = cczp_bitlen((uint64_t)&v11[5 * *v11 + 4]);
        ccn_write_uint_padded_internal(v12, (unint64_t *)(a2 + 40), (unint64_t)(v24 + 7) >> 3, __src);
        ccdigest_init_internal(v10, v17);
        uint64_t v25 = cczp_bitlen((uint64_t)&v11[5 * *v11 + 4]);
        ccdigest_update_internal((unint64_t *)v10, v17, (unint64_t)(v25 + 7) >> 3, __src);
        size_t v26 = ((unint64_t)(cczp_bitlen((uint64_t)*v19) + 7) >> 2) | 1;
        uint64_t v27 = (void *)ccckg2_ctx_cp(a2);
        size_t v28 = (void *)ccckg2_ctx_cp(a2);
        ccdigest_update_internal((unint64_t *)v10, v17, v26, (char *)(v20 + 8 * *v28 + 8 * *v27));
        (*(void (**)(uint64_t, void *, uint64_t))(v10 + 56))(v10, v17, a4);
        cc_clear(*(void *)(v10 + 8) + *(void *)(v10 + 16) + 12, v17);
        uint64_t result = 0;
        *(unsigned char *)(a2 + 32) = 1;
      }
    }
  }
  *(void *)(a1 + 16) = v30;
  return result;
}

uint64_t ccckg2_contributor_finish(uint64_t a1, uint64_t a2, unsigned char *a3, uint64_t a4, char *a5, void *a6, uint64_t a7, char *a8, uint64_t (**a9)(void, uint64_t, unint64_t *))
{
  BOOL v43 = timingsafe_enable_if_supported();
  uint64_t v16 = (uint64_t *)ccckg2_ctx_cp(a1);
  uint64_t v17 = *v16;
  uint64_t v18 = sizeof_struct_cche_galois_key();
  unint64_t v19 = sizeof_struct_ccpolyzp_po2cyc();
  v39[0] = cc_malloc_clear((v17 << 8) + 8 * ((v18 + v19 + 3 * v17 * v19 - 1) / v19));
  uint64_t v20 = *v16;
  uint64_t v21 = sizeof_struct_cche_galois_key();
  unint64_t v22 = sizeof_struct_ccpolyzp_po2cyc();
  v39[1] = (v21 + v22 + 3 * v20 * v22 - 1) / v22 + 32 * v20;
  uint64_t v40 = 0;
  uint64_t v41 = cc_ws_alloc;
  uint64_t v42 = cc_ws_free;
  if (v39[0])
  {
    unsigned int v23 = (void *)ccckg2_ctx_cp(a1);
    if (*(unsigned char *)(a1 + 32) == 1)
    {
      if (*(_DWORD *)a1 == 2
        && (uint64_t v24 = v23, (void *)*a6 == v23)
        && (unint64_t v25 = *v23, (((unint64_t)(cczp_bitlen((uint64_t)v23) + 7) >> 1) & 0x7FFFFFFFFFFFFFFCLL | 2) == a2)
        && (unint64_t v37 = v25,
            size_t v26 = v24 + 4,
            unint64_t v27 = cczp_bitlen((uint64_t)&v24[5 * *v24 + 4]) + 7,
            (((unint64_t)(cczp_bitlen((uint64_t)v24) + 7) >> 2) | 1) + (v27 >> 3) == a4))
      {
        uint64_t v28 = ccckg_contributor_finish_derive_p_ws((uint64_t)v39, a1, a3, (uint64_t)a6, a9);
        if (v28)
        {
          uint64_t v30 = v28;
        }
        else
        {
          uint64_t v29 = cczp_bitlen((uint64_t)v24);
          uint64_t v30 = ccckg2_derive_sk_ws((uint64_t)v39, a1, &a3[((unint64_t)(v29 + 7) >> 2) | 1], (uint64_t)a6, a7, a8, a9);
          if (!v30)
          {
            uint64_t v31 = cczp_bitlen((uint64_t)&v26[5 * *v24]);
            ccn_write_uint_padded_internal(v37, (unint64_t *)(a1 + 40), (unint64_t)(v31 + 7) >> 3, a5);
            uint64_t v32 = &a5[(unint64_t)(cczp_bitlen((uint64_t)&v26[5 * *v24]) + 7) >> 3];
            uint64_t v33 = (void *)ccckg2_ctx_cp(a1);
            unsigned int v34 = (const void *)(a1 + 40 + 8 * *(void *)ccckg2_ctx_cp(a1) + 8 * *v33);
            uint64_t v35 = cczp_bitlen((uint64_t)v24);
            memcpy(v32, v34, ((unint64_t)(v35 + 7) >> 2) | 1);
            *(unsigned char *)(a1 + 32) = 3;
          }
        }
        uint64_t v40 = 0;
        v42((uint64_t)v39);
      }
      else
      {
        uint64_t v30 = 4294967289;
        cc_ws_free((uint64_t)v39);
      }
    }
    else
    {
      uint64_t v30 = 4294967210;
      cc_ws_free((uint64_t)v39);
    }
  }
  else
  {
    uint64_t v30 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v43);
  return v30;
}

unint64_t ccn_bitlen_public_value(unint64_t result, unint64_t *a2)
{
  if (result)
  {
    unint64_t v2 = result;
    uint64_t result = 0;
    uint64_t v3 = 64;
    do
    {
      unint64_t v4 = *a2++;
      uint64_t result = ((((v4 | HIDWORD(v4)) + 0xFFFFFFFF) >> 32) - 1) & result | (v3 - __clz(v4 | 1)) & -(uint64_t)(((v4 | HIDWORD(v4)) + 0xFFFFFFFF) >> 32);
      v3 += 64;
      --v2;
    }
    while (v2);
  }
  return result;
}

unint64_t ccn_bitlen(unint64_t a1, unint64_t *a2)
{
  BOOL v6 = timingsafe_enable_if_supported();
  unint64_t v4 = ccn_bitlen_public_value(a1, a2);
  cc_disable_dit_with_sb((unsigned int *)&v6);
  return v4;
}

uint64_t ccofb_context_size(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t ccofb_block_size(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t ccofb_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 16))(a1, a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccofb_update(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccofb_one_shot(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v24 = *MEMORY[0x263EF8C08];
  BOOL v14 = timingsafe_enable_if_supported();
  BOOL v23 = v14;
  MEMORY[0x270FA53B0](v14, v15, v16, v17);
  unint64_t v19 = &v22[-v18];
  uint64_t v20 = (*(uint64_t (**)(uint64_t, unsigned char *, uint64_t, uint64_t, uint64_t))(a1 + 16))(a1, &v22[-v18], a2, a3, a4);
  if (!v20) {
    uint64_t v20 = (*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(a1 + 24))(v19, a5, a6, a7);
  }
  cc_clear(*(void *)a1, v19);
  cc_disable_dit_with_sb((unsigned int *)&v23);
  return v20;
}

uint64_t cczp_inv_default_ws(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v6 = a2;
  unint64_t v8 = cczp_n(a2);
  uint64_t v9 = cczp_prime(v6);
  if ((ccn_cmp_internal(v8, a4, v9) & 0x80000000) == 0) {
    return 4294967289;
  }
  uint64_t v46 = *(void *)(a1 + 16);
  int8x16_t __s = a3;
  unint64_t v11 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v8);
  BOOL v12 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v8);
  cczp_from_ws(a1, v6);
  uint64_t v13 = (void *)cczp_prime(v6);
  ccn_set(v8, v12, v13);
  BOOL v14 = (unint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v8);
  uint64_t v15 = (unint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v8);
  int32x4_t v53 = v14;
  ccn_seti(v8, v14, 1);
  uint64_t __n = 8 * v8;
  int32x4_t v54 = v15;
  cc_clear(8 * v8, v15);
  BOOL v52 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v8);
  unint64_t v16 = (v8 << 7) | 0x1E;
  if (v16 != 30)
  {
    uint64_t v17 = 0;
    unint64_t v49 = v8 - 1;
    unint64_t v50 = v16 / 0x1F;
    unint64_t v48 = v8 - 2;
    int32x4_t v51 = (void *)v6;
    uint64_t v56 = v8;
    do
    {
      uint64_t v18 = v11[v49];
      uint64_t v19 = v12[v49];
      uint64_t v55 = v17;
      if (v8 >= 2)
      {
        unint64_t v20 = v48;
        do
        {
          char v21 = __clz(v19 | v18 | 1);
          char v22 = (((v19 | v18) >> 63) - v21 + 64) & -(uint64_t)(((v19 | v18 | ((v19 | (unint64_t)v18) >> 32))
                                                             + 0xFFFFFFFF) >> 32);
          uint64_t v18 = (v11[v20] >> v22) | (v18 << v21);
          uint64_t v19 = (v12[v20--] >> v22) | (v19 << v21);
        }
        while (v20 < v8);
      }
      unint64_t v23 = 0;
      uint64_t v24 = 0;
      unint64_t v25 = v18 & 0xFFFFFFFF80000000 | *v11 & 0x7FFFFFFFLL;
      unint64_t v26 = v19 & 0xFFFFFFFF80000000 | *v12 & 0x7FFFFFFFLL;
      uint64_t v27 = 31;
      uint64_t v28 = 0x80000000;
      unint64_t v29 = 0x80000000;
      do
      {
        unint64_t v30 = v25 & 1;
        unint64_t v31 = v25 >> !(v25 & 1);
        unint64_t v32 = v31 ^ v26;
        unint64_t v33 = v25 & ((((v31 - v26) ^ v31 | v31 ^ v26) ^ v31) >> 63);
        uint64_t v34 = -(uint64_t)v33;
        unint64_t v35 = v26 & -(uint64_t)v33--;
        unint64_t v36 = v33 & v31 | v35;
        unint64_t v26 = v32 ^ v36;
        unint64_t v37 = v33 & v29 | v24 & v34;
        v24 ^= v29 ^ v37;
        unint64_t v38 = v33 & v23 | v28 & v34;
        v28 ^= v23 ^ v38;
        unint64_t v25 = (v36 - (v26 & -(uint64_t)v30)) >> v30;
        unint64_t v29 = (v37 - (v24 & -(uint64_t)v30)) & 0x8000000000000000 | ((v37 - (v24 & -(uint64_t)v30)) >> 1);
        unint64_t v23 = (v38 - (v28 & -(uint64_t)v30)) & 0x8000000000000000 | ((v38 - (v28 & -(uint64_t)v30)) >> 1);
        --v27;
      }
      while (v27);
      uint64_t v39 = a1;
      uint64_t updated = cczp_inv_update_ws(a1, v8, v52, v11, (v37 - (v24 & -(uint64_t)v30)) & 0x8000000000000000 | ((v37 - (v24 & -(uint64_t)v30)) >> 1), v12, (v38 - (v28 & -(uint64_t)v30)) & 0x8000000000000000 | ((v38 - (v28 & -(uint64_t)v30)) >> 1));
      uint64_t v41 = cczp_inv_update_ws(v39, v56, v12, v11, v24, v12, v28);
      ccn_set(v56, v11, v52);
      uint64_t v42 = updated - 1;
      uint64_t v43 = -updated;
      a1 = v39;
      uint64_t v44 = v42 & v23 | v43 & -(uint64_t)v23;
      uint64_t v6 = (uint64_t)v51;
      unint64_t v8 = v56;
      cczp_inv_update_redc_ws(v39, v51, v52, v53, v42 & v29 | v43 & -(uint64_t)v29, v54, v44);
      cczp_inv_update_redc_ws(v39, v51, v54, v53, (v41 - 1) & v24 | -v41 & -v24, v54, (v41 - 1) & v28 | -v41 & -v28);
      ccn_set(v56, v53, v52);
      uint64_t v17 = v55 + 1;
    }
    while (v55 + 1 != v50);
  }
  if (ccn_n(v8, (uint64_t)v12) == 1 && *v12 == 1)
  {
    cczp_to_ws(a1, v6);
    uint64_t result = 0;
  }
  else
  {
    cc_clear(__n, __s);
    uint64_t result = 4294967289;
  }
  *(void *)(a1 + 16) = v46;
  return result;
}

uint64_t cczp_inv_update_ws(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5, void *a6, uint64_t a7)
{
  uint64_t v19 = *(void *)(a1 + 16);
  uint64_t v13 = a2 + 1;
  BOOL v14 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, a2 + 1);
  uint64_t v15 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v13);
  if (a2) {
    ccn_set(a2, v14, a4);
  }
  ccn_zero(1, &v14[8 * a2]);
  ccn_cond_neg(v13, a5 < 0, (uint64_t *)v14, (uint64_t *)v14);
  if (a2) {
    ccn_set(a2, v15, a6);
  }
  ccn_zero(1, &v15[8 * a2]);
  ccn_cond_neg(v13, a7 < 0, (uint64_t *)v15, (uint64_t *)v15);
  ccn_mul1(v13, v14, (unint64_t *)v14, (a5 ^ (a5 >> 63)) + ((unint64_t)a5 >> 63));
  ccn_addmul1(v13, (unint64_t *)v14, (unint64_t *)v15, (a7 ^ (a7 >> 63)) + ((unint64_t)a7 >> 63));
  uint64_t v16 = *(void *)&v14[8 * a2] >> 63;
  ccn_cond_neg(v13, *(uint64_t *)&v14[8 * a2] < 0, (uint64_t *)v14, (uint64_t *)v14);
  ccn_shift_right(v13, (uint64_t)v14, (unint64_t *)v14, 0x1FuLL);
  ccn_set(a2, a3, v14);
  *(void *)(a1 + 16) = v19;
  return v16;
}

uint64_t cczp_inv_update_redc_ws(uint64_t a1, void *a2, void *a3, unint64_t *a4, uint64_t a5, unint64_t *a6, uint64_t a7)
{
  uint64_t v12 = cczp_n((uint64_t)a2);
  uint64_t v21 = *(void *)(a1 + 16);
  uint64_t v13 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12 + 1);
  BOOL v14 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  cczp_cond_negate((uint64_t)a2, a5 < 0, v13, a4);
  cczp_cond_negate((uint64_t)a2, a7 < 0, v14, a6);
  v13[v12] = ccn_mul1(v12, v13, (unint64_t *)v13, (a5 ^ (a5 >> 63)) + ((unint64_t)a5 >> 63));
  v13[v12] += ccn_addmul1(v12, (unint64_t *)v13, (unint64_t *)v14, (a7 ^ (a7 >> 63)) + ((unint64_t)a7 >> 63));
  uint64_t v15 = (unint64_t *)cczp_prime((uint64_t)a2);
  v13[v12] += ccn_addmul1(v12, (unint64_t *)v13, v15, (LODWORD(a2[*a2 + 3]) * *(_DWORD *)v13) & 0x7FFFFFFF);
  ccn_shift_right(v12 + 1, (uint64_t)v13, (unint64_t *)v13, 0x1FuLL);
  ccn_set(v12, a3, v13);
  uint64_t v16 = (unint64_t *)cczp_prime((uint64_t)a2);
  char v17 = ccn_subn(v12 + 1, v13, v13, v12, v16);
  uint64_t result = ccn_mux(v12, v17, (uint64_t *)a3, (uint64_t *)a3, v13);
  *(void *)(a1 + 16) = v21;
  return result;
}

uint64_t cczp_inv_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 40))();
}

uint64_t cczp_inv(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v11 = timingsafe_enable_if_supported();
  uint64_t v6 = cczp_n(a1);
  v9[0] = cc_malloc_clear(72 * v6);
  v9[1] = 9 * cczp_n(a1);
  void v9[2] = 0;
  void v9[3] = cc_ws_alloc;
  uint64_t v10 = cc_ws_free;
  if (v9[0])
  {
    uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 16) + 40))(v9, a1, a2, a3);
    v10((uint64_t)v9);
  }
  else
  {
    uint64_t v7 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v11);
  return v7;
}

uint64_t ccdh_import_priv(void *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  BOOL v29 = timingsafe_enable_if_supported();
  uint64_t v8 = ccdh_gp_n(a1);
  uint64_t v9 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v10 = sizeof_struct_ccpolyzp_po2cyc();
  v25[0] = cc_malloc_clear(8 * ((v9 + v10 - 1) / v10 + 12 * v8) + 8);
  uint64_t v11 = ccdh_gp_n(a1);
  uint64_t v12 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v13 = sizeof_struct_ccpolyzp_po2cyc();
  v25[1] = (v12 + v13 - 1) / v13 + 12 * v11 + 1;
  uint64_t v26 = 0;
  uint64_t v27 = cc_ws_alloc;
  uint64_t v28 = cc_ws_free;
  if (v25[0])
  {
    uint64_t v14 = ccdh_gp_n(a1);
    uint64_t v15 = (unint64_t *)ccdh_gp_g(a1);
    uint64_t v16 = (void *)ccdh_ctx_public(a4);
    ccdh_ctx_init((uint64_t)a1, v16);
    uint64_t v18 = *a4;
    char v17 = a4 + 2;
    uint64_t v19 = &v17[ccdh_gp_n(v18)];
    if (ccn_read_uint_internal(v14, v19, a2, a3))
    {
      unint64_t v20 = cc_ws_free;
      uint64_t v21 = 4294967244;
    }
    else
    {
      uint64_t v22 = cczp_prime((uint64_t)a1);
      if ((ccn_cmp_internal(v14, v19, v22) & 0x80000000) != 0)
      {
        uint64_t v23 = cczp_bitlen((uint64_t)a1);
        if (cczp_mm_power_ws((uint64_t)v25, a1, v17, v15, v23, v19)) {
          uint64_t v21 = 4294967250;
        }
        else {
          uint64_t v21 = 0;
        }
        unint64_t v20 = v28;
      }
      else
      {
        unint64_t v20 = cc_ws_free;
        uint64_t v21 = 4294967247;
      }
    }
    uint64_t v26 = 0;
    v20((uint64_t)v25);
  }
  else
  {
    uint64_t v21 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v29);
  return v21;
}

uint64_t ccpolyzp_po2cyc_bytes_to_coeffs(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  unint64_t v6 = a5 - a6;
  if (a5 <= a6 || a3 != (v6 * a1 + 7) >> 3 && (v6 + 8 * a3 - 1) / v6 != a1) {
    return 4294967289;
  }
  if (a3)
  {
    uint64_t v7 = 0;
    unsigned int v8 = 0;
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    unint64_t v11 = a5 - a6;
    do
    {
      unsigned int v12 = *(unsigned __int8 *)(a4 + v7);
      unint64_t v13 = 8;
      do
      {
        if (!v11)
        {
          *(void *)(a2 + 8 * v10++) = v9 << a6;
          unint64_t v11 = a5 - a6;
          uint64_t v9 = 0;
        }
        if (v11 >= v13) {
          unint64_t v14 = v13;
        }
        else {
          unint64_t v14 = v11;
        }
        uint64_t v9 = (v9 << v14) | (v12 >> (8 - v14));
        unsigned int v12 = (v12 << v14);
        v11 -= v14;
        v13 -= v14;
      }
      while (v13);
      uint64_t v7 = ++v8;
    }
    while (v8 < a3);
  }
  else
  {
    unint64_t v10 = 0;
    uint64_t v9 = 0;
    LOBYTE(v11) = a5 - a6;
  }
  if (v10 >= a1) {
    return 0;
  }
  uint64_t result = 0;
  *(void *)(a2 + 8 * v10) = v9 << (v11 + a6);
  return result;
}

uint64_t ccpolyzp_po2cyc_coeffs_to_bytes(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  unint64_t v6 = a5 - a6;
  if (a5 <= a6 || a1 != (v6 * a3 + 7) >> 3 && (v6 + 8 * a1 - 1) / v6 != a3) {
    return 4294967289;
  }
  if (a3)
  {
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    unsigned int v9 = 0;
    LODWORD(v10) = 0;
    unint64_t v11 = 8;
    do
    {
      unint64_t v12 = *(void *)(a4 + 8 * v7) >> a6;
      unint64_t v13 = a5 - a6;
      do
      {
        if (!v11)
        {
          *(unsigned char *)(a2 + v8) = v10;
          uint64_t v10 = 0;
          if (v8 + 1 == a1) {
            return v10;
          }
          unint64_t v11 = 8;
          ++v8;
        }
        if (v13 >= v11) {
          unint64_t v14 = v11;
        }
        else {
          unint64_t v14 = v13;
        }
        v11 -= v14;
        unint64_t v15 = v13 - v14;
        int v16 = (v10 << v14) | (v12 >> (v13 - v14)) & (0xFFFFFFFFFFFFFFFFLL >> -(char)v13);
        LODWORD(v10) = v16;
        unint64_t v13 = v15;
      }
      while (v15);
      uint64_t v7 = ++v9;
    }
    while (v9 < a3);
    int v17 = v16;
  }
  else
  {
    int v17 = 0;
    unint64_t v8 = 0;
    LOBYTE(v11) = 8;
  }
  uint64_t v10 = 0;
  if (v8 < a1) {
    *(unsigned char *)(a2 + v8) = v17 << v11;
  }
  return v10;
}

uint64_t ccpolyzp_po2cyc_serialize_poly_nbytes(unsigned int *a1, unsigned int a2)
{
  unsigned int v2 = a1[1];
  if (!v2) {
    return 0;
  }
  unsigned int v4 = 0;
  uint64_t result = 0;
  do
  {
    unint64_t v6 = a1;
    if (v2 - 1 > v4)
    {
      unsigned int v7 = v2 - 1;
      unint64_t v6 = a1;
      do
      {
        unint64_t v6 = (unsigned int *)*((void *)v6 + 14);
        --v7;
      }
      while (v7 > v4);
    }
    result += ((64 - a2 - __clz(*((void *)v6 + 2))) * *a1 + 7) >> 3;
    ++v4;
  }
  while (v4 != v2);
  return result;
}

uint64_t ccpolyzp_po2cyc_serialize_poly_ws(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int **a5)
{
  unint64_t v8 = *a5;
  unint64_t v9 = **a5;
  unsigned int v10 = (*a5)[1];
  if (ccpolyzp_po2cyc_serialize_poly_nbytes(*a5, a4) != a2 || a4 && v10 != 1) {
    return 4294967289;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v9);
  if (v10)
  {
    uint64_t v13 = v12;
    unsigned int v14 = 0;
    while (1)
    {
      if (v9)
      {
        unsigned int v15 = **a5 * v14;
        unint64_t v16 = v9;
        int v17 = (void *)v13;
        do
        {
          *v17++ = a5[++v15];
          --v16;
        }
        while (v16);
      }
      unsigned int v18 = v8[1] - 1;
      uint64_t v19 = v8;
      if (v18 > v14)
      {
        uint64_t v19 = v8;
        do
        {
          uint64_t v19 = (unsigned int *)*((void *)v19 + 14);
          --v18;
        }
        while (v18 > v14);
      }
      unint64_t v20 = 64 - __clz(*((void *)v19 + 2));
      if (v20 <= a4) {
        return 4294967289;
      }
      unint64_t v21 = ((v20 - a4) * v9 + 7) >> 3;
      uint64_t result = ccpolyzp_po2cyc_coeffs_to_bytes(v21, a3, v9, v13, v20, a4);
      if (result) {
        goto LABEL_18;
      }
      a3 += v21;
      if (++v14 == v10)
      {
        uint64_t result = 0;
        goto LABEL_18;
      }
    }
  }
  uint64_t result = 0;
LABEL_18:
  *(void *)(a1 + 16) = v11;
  return result;
}

uint64_t ccpolyzp_po2cyc_deserialize_poly_ws(uint64_t a1, unsigned int **a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  unint64_t v8 = *a2;
  unint64_t v9 = **a2;
  unsigned int v10 = (*a2)[1];
  if (ccpolyzp_po2cyc_serialize_poly_nbytes(*a2, a3) != a4 || a3 && v10 != 1) {
    return 4294967289;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v9);
  if (v10)
  {
    uint64_t v13 = v12;
    unsigned int v14 = 0;
    while (1)
    {
      unsigned int v15 = v8[1] - 1;
      unint64_t v16 = v8;
      if (v15 > v14)
      {
        unint64_t v16 = v8;
        do
        {
          unint64_t v16 = (unsigned int *)*((void *)v16 + 14);
          --v15;
        }
        while (v15 > v14);
      }
      unint64_t v17 = 64 - __clz(*((void *)v16 + 2));
      if (v17 <= a3) {
        return 4294967289;
      }
      unint64_t v18 = ((v17 - a3) * v9 + 7) >> 3;
      uint64_t result = ccpolyzp_po2cyc_bytes_to_coeffs(v9, v13, v18, a5, v17, a3);
      if (result) {
        goto LABEL_18;
      }
      if (v9)
      {
        unsigned int v20 = **a2 * v14;
        unint64_t v21 = v9;
        uint64_t v22 = (unsigned int **)v13;
        do
        {
          uint64_t v23 = *v22++;
          a2[++v20] = v23;
          --v21;
        }
        while (v21);
      }
      a5 += v18;
      if (++v14 == v10)
      {
        uint64_t result = 0;
        goto LABEL_18;
      }
    }
  }
  uint64_t result = 0;
LABEL_18:
  *(void *)(a1 + 16) = v11;
  return result;
}

uint64_t cczp_power_fast_ws(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5)
{
  uint64_t v10 = cczp_n(a2);
  uint64_t v11 = ccn_bitlen_internal(v10, a5);
  if (v11)
  {
    uint64_t v12 = v11;
    uint64_t v17 = *(void *)(a1 + 16);
    uint64_t v13 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 3 * v10);
    ccn_set(v10, v13, a4);
    cczp_sqr_ws(a1, a2);
    cczp_mul_ws(a1, a2);
    uint64_t v14 = (*(void *)(a5 + (((unint64_t)(v12 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v12 - 1)) & 1;
    if ((v12 & 1) == 0) {
      uint64_t v14 = (*(void *)(a5 + (((unint64_t)(v12 - 2) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v12 - 2)) & 1 | (2 * v14);
    }
    ccn_set(v10, a3, &v13[8 * (v14 - 1) * v10]);
    if ((v12 | 0xFFFFFFFFFFFFFFFELL) + v12)
    {
      unint64_t v15 = v12 + (v12 | 0xFFFFFFFFFFFFFFFELL) - 1;
      do
      {
        cczp_sqr_ws(a1, a2);
        cczp_sqr_ws(a1, a2);
        if ((*(void *)(a5 + (((v15 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v15 - 1)) & 1 | (2 * ((*(void *)(a5 + ((v15 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v15) & 1))) {
          cczp_mul_ws(a1, a2);
        }
        v15 -= 2;
      }
      while (v15 != -1);
    }
    *(void *)(a1 + 16) = v17;
  }
  else
  {
    ccn_seti(v10, a3, 1);
    cczp_to_ws(a1, a2);
  }
  return 0;
}

uint64_t cchmac_init_internal(uint64_t a1, void *a2, size_t a3, char *a4)
{
  size_t v5 = a3;
  if (*(void *)(a1 + 16) >= a3)
  {
    if (a3)
    {
      for (uint64_t i = 0; i != a3; ++i)
        *((unsigned char *)a2 + *(void *)(a1 + 8) + i + 8) = a4[i] ^ 0x5C;
    }
  }
  else
  {
    ccdigest_init_internal(a1, a2);
    ccdigest_update_internal((unint64_t *)a1, a2, v5, a4);
    (*(void (**)(uint64_t, void *, uint64_t))(a1 + 56))(a1, a2, (uint64_t)a2 + *(void *)(a1 + 8) + 8);
    size_t v5 = *(void *)a1;
    if (*(void *)a1)
    {
      uint64_t v8 = 0;
      do
        *((unsigned char *)a2 + *(void *)(a1 + 8) + v8++ + 8) ^= 0x5Cu;
      while (v5 != v8);
    }
  }
  unint64_t v10 = *(void *)(a1 + 16);
  if (v10 > v5)
  {
    memset((char *)a2 + v5 + *(void *)(a1 + 8) + 8, 92, v10 - v5);
    unint64_t v10 = *(void *)(a1 + 16);
  }
  memcpy((char *)a2 + ((*(void *)(a1 + 8) + v10 + 19) & 0xFFFFFFFFFFFFFFF8), *(const void **)(a1 + 40), *(void *)(a1 + 8));
  (*(void (**)(unint64_t, uint64_t, uint64_t))(a1 + 48))((unint64_t)a2 + ((*(void *)(a1 + 8) + *(void *)(a1 + 16) + 19) & 0xFFFFFFFFFFFFFFF8), 1, (uint64_t)a2 + *(void *)(a1 + 8) + 8);
  if (*(void *)(a1 + 16))
  {
    unint64_t v11 = 0;
    do
      *((unsigned char *)a2 + *(void *)(a1 + 8) + v11++ + 8) ^= 0x6Au;
    while (v11 < *(void *)(a1 + 16));
  }
  memcpy(a2 + 1, *(const void **)(a1 + 40), *(void *)(a1 + 8));
  uint64_t result = (*(uint64_t (**)(void *, uint64_t, uint64_t))(a1 + 48))(a2 + 1, 1, (uint64_t)a2 + *(void *)(a1 + 8) + 8);
  uint64_t v13 = *(void *)(a1 + 16);
  *(_DWORD *)((char *)a2 + *(void *)(a1 + 8) + v13 + 8) = 0;
  *a2 = 8 * v13;
  return result;
}

uint64_t cchmac_init(uint64_t a1, void *a2, size_t a3, char *a4)
{
  BOOL v9 = timingsafe_enable_if_supported();
  cchmac_init_internal(a1, a2, a3, a4);
  return cc_disable_dit_with_sb((unsigned int *)&v9);
}

uint64_t ccz_sub(void *a1, uint64_t a2, uint64_t a3)
{
  BOOL v15 = timingsafe_enable_if_supported();
  unint64_t v6 = ccz_n(a2);
  unint64_t v7 = ccz_n(a3);
  int v8 = ccz_sign(a2);
  if (v8 == ccz_sign(a3))
  {
    int v9 = ccn_cmpn_internal(v6, *(void *)(a2 + 24), v7, *(void *)(a3 + 24));
    int v10 = ccz_sign(a2);
    if (v9 < 0)
    {
      ccz_set_sign((uint64_t)a1, -v10);
      ccz_set_capacity((uint64_t)a1, v7);
      ccn_subn(v7, (void *)a1[3], *(uint64_t **)(a3 + 24), v6, *(unint64_t **)(a2 + 24));
      unint64_t v6 = v7;
    }
    else
    {
      ccz_set_sign((uint64_t)a1, v10);
      ccz_set_capacity((uint64_t)a1, v6);
      ccn_subn(v6, (void *)a1[3], *(uint64_t **)(a2 + 24), v7, *(unint64_t **)(a3 + 24));
    }
  }
  else
  {
    int v11 = ccz_sign(a2);
    ccz_set_sign((uint64_t)a1, v11);
    if (v6 >= v7)
    {
      unint64_t v12 = v6 + 1;
      ccz_set_capacity((uint64_t)a1, v6 + 1);
      *(void *)(a1[3] + 8 * v6) = ccn_addn(v6, (void *)a1[3], *(uint64_t **)(a2 + 24), v7, *(uint64_t **)(a3 + 24));
    }
    else
    {
      unint64_t v12 = v7 + 1;
      ccz_set_capacity((uint64_t)a1, v7 + 1);
      *(void *)(a1[3] + 8 * v7) = ccn_addn(v7, (void *)a1[3], *(uint64_t **)(a3 + 24), v6, *(uint64_t **)(a2 + 24));
    }
    unint64_t v6 = v12;
  }
  unint64_t v13 = ccn_n(v6, a1[3]);
  ccz_set_n(a1, v13);
  return cc_disable_dit_with_sb((unsigned int *)&v15);
}

uint64_t ccn_p384_to_ws(uint64_t a1, uint64_t a2)
{
  return cczp_mul_ws(a1, a2);
}

void *ccec_cp_384()
{
  return &ccec_cp384_c;
}

uint64_t ccn_p384_mul_ws(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t v10 = *(void *)(a1 + 16);
  int v11 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 12);
  ccn_mul_ws(a1, 6uLL, v11, a4, a5);
  uint64_t result = ccn_p384_redc_ws(a1, a2, a3, (uint64_t *)v11);
  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t ccn_p384_sqr_ws(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t *a4)
{
  uint64_t v8 = *(void *)(a1 + 16);
  int v9 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 12);
  ccn_sqr_ws(a1, 6uLL, v9, a4);
  uint64_t result = ccn_p384_redc_ws(a1, a2, a3, v9);
  *(void *)(a1 + 16) = v8;
  return result;
}

uint64_t ccn_p384_from_ws(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 12);
  ccn_set(6, (void *)v9, a4);
  ccn_zero(6, (void *)(v9 + 48));
  uint64_t result = ccn_p384_redc_ws(a1, a2, a3, (uint64_t *)v9);
  *(void *)(a1 + 16) = v8;
  return result;
}

uint64_t ccn_p384_redc_ws(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8 = 0;
  uint64_t v9 = a4[4];
  do
  {
    uint64_t v10 = &a4[v8];
    uint64_t v11 = a4[v8];
    uint64_t v12 = a4[v8 + 1];
    uint64_t v13 = 0x100000001 * v11;
    uint64_t v14 = ((unint64_t)(0x100000001 * v11) * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
    uint64_t v15 = -v11;
    uint64_t v16 = ((unint64_t)(0x100000001 * v11) * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
    unint64_t v17 = 0xFFFFFFFEFFFFFFFFLL * v11;
    uint64_t v18 = ((unint64_t)(0x100000001 * v11) * (unsigned __int128)0xFFFFFFFF00000000) >> 64;
    BOOL v19 = __CFADD__(0xFFFFFFFF00000000 * v11, v12);
    unint64_t v20 = 0xFFFFFFFF00000000 * v11 + v12;
    if (v19) {
      ++v18;
    }
    BOOL v19 = __CFADD__(__CFADD__(v15, v11), v20);
    uint64_t v21 = __CFADD__(v15, v11) + v20;
    v19 |= __CFADD__(v14, v21);
    v21 += v14;
    if (v19) {
      uint64_t v22 = v18 + 1;
    }
    else {
      uint64_t v22 = v18;
    }
    uint64_t v23 = ((unint64_t)v13 * (unsigned __int128)0xFFFFFFFFFFFFFFFELL) >> 64;
    uint64_t v24 = -2 * v13;
    uint64_t v25 = v10[2];
    uint64_t v26 = v10[3];
    BOOL v19 = __CFADD__(v24, v25);
    uint64_t v27 = v24 + v25;
    if (v19) {
      ++v23;
    }
    BOOL v19 = __CFADD__(v27, v22);
    uint64_t v28 = v27 + v22;
    if (v19) {
      uint64_t v29 = v23 + 1;
    }
    else {
      uint64_t v29 = v23;
    }
    unint64_t v30 = v17 + v26;
    if (__CFADD__(v17, v26)) {
      uint64_t v31 = v16 + 1;
    }
    else {
      uint64_t v31 = v16;
    }
    BOOL v19 = __CFADD__(v30, v29);
    uint64_t v32 = v30 + v29;
    if (v19) {
      uint64_t v33 = v31 + 1;
    }
    else {
      uint64_t v33 = v31;
    }
    void v10[2] = v28;
    v10[3] = v32;
    BOOL v19 = __CFADD__(v17, v9);
    unint64_t v34 = v17 + v9;
    if (v19) {
      uint64_t v35 = v16 + 1;
    }
    else {
      uint64_t v35 = v16;
    }
    uint64_t v36 = v34 + v33;
    if (__CFADD__(v34, v33)) {
      uint64_t v37 = v35 + 1;
    }
    else {
      uint64_t v37 = v35;
    }
    uint64_t v38 = v10[5];
    BOOL v19 = __CFADD__(v17, v38);
    unint64_t v39 = v17 + v38;
    if (v19) {
      uint64_t v40 = v16 + 1;
    }
    else {
      uint64_t v40 = v16;
    }
    BOOL v19 = __CFADD__(v39, v37);
    uint64_t v9 = v39 + v37;
    if (v19) {
      uint64_t v41 = v40 + 1;
    }
    else {
      uint64_t v41 = v40;
    }
    void v10[4] = v36;
    v10[5] = v9;
    *uint64_t v10 = v41;
    v10[1] = v21;
    ++v8;
  }
  while (v8 != 6);
  char v42 = ccn_add_ws(a1, 6, a4 + 6, a4 + 6, a4);
  uint64_t v43 = (unint64_t *)cczp_prime(a2);
  char v44 = ccn_sub_ws(a1, 6, a4, a4 + 6, v43) ^ v42;

  return ccn_mux(6, v44, a3, a4 + 6, a4);
}

uint64_t cckyber_poly_getnoise(uint64_t a1, char *a2, char a3)
{
  uint64_t v6 = *MEMORY[0x263EF8C08];
  cckyber_prf(a2, a3, v5);
  return cckyber_sample_cbd_eta2(a1, (uint64_t)v5);
}

uint64_t cckyber_poly_encode(uint64_t result, uint64_t a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = (unsigned char *)(result + 2);
  do
  {
    unsigned int v4 = ((*(__int16 *)(a2 + v2) >> 15) & 0xD01) + *(__int16 *)(a2 + v2);
    unsigned int v5 = ((*(__int16 *)(a2 + v2 + 2) >> 15) & 0xD01) + *(__int16 *)(a2 + v2 + 2);
    *(v3 - 2) = v4;
    *(v3 - 1) = (16 * v5) | BYTE1(v4);
    *uint64_t v3 = v5 >> 4;
    v3 += 3;
    v2 += 4;
  }
  while (v2 != 512);
  return result;
}

uint64_t cckyber_poly_decode(uint64_t result, uint64_t a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = (unsigned __int8 *)(a2 + 2);
  do
  {
    unsigned int v4 = *(v3 - 1);
    unsigned int v5 = *(v3 - 2) | ((v4 & 0xF) << 8);
    int v6 = *v3;
    v3 += 3;
    unsigned int v7 = (v4 >> 4) | (16 * v6);
    if (v5 >= 0xD01) {
      LOWORD(v5) = v5 - 3329;
    }
    *(_WORD *)(result + v2) = v5;
    if (v7 >= 0xD01) {
      __int16 v8 = v7 - 3329;
    }
    else {
      __int16 v8 = v7;
    }
    *(_WORD *)(result + v2 + 2) = v8;
    v2 += 4;
  }
  while (v2 != 512);
  return result;
}

uint64_t cckyber_poly_compress(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 16))(a2, a3);
}

uint64_t cckyber_poly_decompress(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a2, a3);
}

uint64_t cckyber_poly_add(uint64_t result, uint64_t a2, uint64_t a3)
{
  for (uint64_t i = 0; i != 512; i += 2)
    *(_WORD *)(result + i) = *(_WORD *)(a3 + i) + *(_WORD *)(a2 + i);
  return result;
}

uint64_t cckyber_poly_sub(uint64_t result, uint64_t a2, uint64_t a3)
{
  for (uint64_t i = 0; i != 512; i += 2)
    *(_WORD *)(result + i) = *(_WORD *)(a2 + i) - *(_WORD *)(a3 + i);
  return result;
}

uint64_t cckyber_poly_reduce(uint64_t result)
{
  uint64_t v1 = 0;
  int32x4_t v2 = vdupq_n_s32(0x13AFB8u);
  int32x4_t v3 = vdupq_n_s32(0xD01u);
  int32x4_t v4 = vdupq_n_s32(0x6808u);
  do
  {
    *(int16x8_t *)(result + v1) = vaddhn_high_s32(vaddhn_s32(vmulq_s32(vshrq_n_s32(vmulq_s32(vmovl_s16(*(int16x4_t *)(result + v1)), v2), 0x10uLL), v3), v4), vmulq_s32(vshrq_n_s32(vmulq_s32(vmovl_high_s16(*(int16x8_t *)(result + v1)), v2), 0x10uLL), v3), v4);
    v1 += 16;
  }
  while (v1 != 512);
  return result;
}

uint64_t cckyber_poly_toplant(uint64_t result)
{
  uint64_t v1 = 0;
  int32x4_t v2 = vdupq_n_s32(0x97F44FAC);
  int32x4_t v3 = vdupq_n_s32(0xD01u);
  int32x4_t v4 = vdupq_n_s32(0x6808u);
  do
  {
    *(int16x8_t *)(result + v1) = vaddhn_high_s32(vaddhn_s32(vmulq_s32(vshrq_n_s32(vmulq_s32(vmovl_s16(*(int16x4_t *)(result + v1)), v2), 0x10uLL), v3), v4), vmulq_s32(vshrq_n_s32(vmulq_s32(vmovl_high_s16(*(int16x8_t *)(result + v1)), v2), 0x10uLL), v3), v4);
    v1 += 16;
  }
  while (v1 != 512);
  return result;
}

BOOL ccec_is_point_projective_ws(uint64_t a1, void *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, void))(a1 + 24))(a1, *a2);
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  BOOL result = ccn_cmp_internal(v4, v7, v6) == 0;
  *(void *)(a1 + 16) = v5;
  return result;
}

BOOL ccec_is_point_at_infinity(unint64_t *a1, uint64_t a2)
{
  return ccn_n(*a1, a2 + 16 * *a1) == 0;
}

uint64_t fipspost_post_pbkdf(char a1)
{
  uint64_t v41 = *MEMORY[0x263EF8C08];
  memset(__s2, 0, 143);
  int32x4_t v2 = (unint64_t *)ccsha1_di();
  if (ccpbkdf2_hmac(v2, 88, (uint64_t)"roAhfqRBzTqHATLXmmLLiQIyBUchpmcqrXWMWoztGqWZrEbqIZFKWphBFbGkoJmnRaqDXZaYMreSUJhWTLypGstb", 0x15uLL, "\x0E\xDD\x678\x1F}\x97?#\xACpC\x1C\xBF\xD0\x54P0\x93", 0x371uLL, 0x8FuLL, (char *)__s2))
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccpbkdf2_hmac (SHA-1): %d\n");
    return 4294967224;
  }
  if ((a1 & 0x10) != 0) {
    uint64_t v4 = "\x01%\xE7\x18\xC0u=S\x0E\xFE\"\xBB0\xB3\xD8\x65\xC5\x33\xED\x7A\xC4\xF90)\x130\xF5\x03\x46\x0DFi\xB0x\xFC0Y"
  }
         "Vs\n"
         "\\4p\x99\xAEe\x8B<.\v\xC8\x5D\x92\xEE\x26\x5B\x8CH\x8E\xAA\xC0\xB1>v\xA9Q\x1F\xB0\x85\\\x9A\xD5\x29[c\x03|\n"
         "\xF8\x15\x05\xC0\xCF\x89\xC6\xEAG\x90\xED\xC3\x9E\x80\xD6\x18/\x82\xF3\x42\x50\x9Az\xCF\x76R\x0F\x97\x1C\xEA\x63"
         "\x4D\x8C#\xAA\xE1\xEA\xC2@%\x9F\xB4\xCE\x5F|^:\xF2\x88\x18\x32\xA9CZ";
  else {
    uint64_t v4 = "%\xE7\x18\xC0u=S\x0E\xFE\"\xBB0\xB3\xD8\x65\xC5\x33\xED\x7A\xC4\xF90)\x130\xF5\x03\x46\x0DFi\xB0x\xFC0YVs\n"
  }
         "\\4p\x99\xAEe\x8B<.\v\xC8\x5D\x92\xEE\x26\x5B\x8CH\x8E\xAA\xC0\xB1>v\xA9Q\x1F\xB0\x85\\\x9A\xD5\x29[c\x03|\n"
         "\xF8\x15\x05\xC0\xCF\x89\xC6\xEAG\x90\xED\xC3\x9E\x80\xD6\x18/\x82\xF3\x42\x50\x9Az\xCF\x76R\x0F\x97\x1C\xEA\x63"
         "\x4D\x8C#\xAA\xE1\xEA\xC2@%\x9F\xB4\xCE\x5F|^:\xF2\x88\x18\x32\xA9CZ";
  if (!memcmp(v4, __s2, 0x8FuLL))
  {
    char v39 = 0;
    memset(v38, 0, sizeof(v38));
    uint64_t v5 = (unint64_t *)ccsha256_di();
    if (ccpbkdf2_hmac(v5, 34, (uint64_t)"PpKpAmtfcDCPtAtwRMnHBueaQklIgpzLiH", 0x1CuLL, "\x8B\x81\xB8F\xFC{}ivwoo\x1Be\xBF\xB9M\x92+fI-\\L\x8C\x82", 0x300uLL, 0x41uLL, (char *)v38))
    {
      mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccpbkdf2_hmac (SHA-256): %d\n");
      return 4294967224;
    }
    if ((a1 & 0x10) != 0) {
      uint64_t v6 = "\x01p\xCC\x73\x87%\xA7\x13g\x1C\xE2\xA3\x632\x86\x9C9\x14\xC5\x21*\xB9t\x93RM~*\xD5\x2C\x03J\xA2\xFD\a\xF1\x01"
    }
           "\x5B\x23E\x84q\xA4\x9E\xB72\xBB\xA9\xB0F\xB3\xF8\xF5\x90\x7C\xCF\x96\x9C\\v\xF7\x22\xFB\xBB";
    else {
      uint64_t v6 = "p\xCC\x73\x87%\xA7\x13g\x1C\xE2\xA3\x632\x86\x9C9\x14\xC5\x21*\xB9t\x93RM~*\xD5\x2C\x03J\xA2\xFD\a\xF1\x01\x5B"
    }
           "\x23E\x84q\xA4\x9E\xB72\xBB\xA9\xB0F\xB3\xF8\xF5\x90\x7C\xCF\x96\x9C\\v\xF7\x22\xFB\xBB";
    if (!memcmp(v6, v38, 0x41uLL))
    {
      memset(v37, 0, 319);
      uint64_t v7 = (unint64_t *)ccsha512_di();
      if (ccpbkdf2_hmac(v7, 17, (uint64_t)"SeiPcvDyiAvRsPPKX", 0x1CuLL, "\x1C\x1A+Ib\x97\xDE\x6D\xED\xAA\xE8~\xB2z\x04\b\x04\x9C\x13\xE8\xD2\x37\x03\x81\a\xD3\xCC\xA8", 0x244uLL, 0x13FuLL, (char *)v37))
      {
        mach_absolute_time();
        printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccpbkdf2_hmac (SHA-512): %d\n");
        return 4294967224;
      }
      if ((a1 & 0x10) != 0) {
        __int16 v8 = "\x01+\xAC\xA7o;\xB3t\xAE.\"\x15N\xAF\xC3\x0C\x97\x86\xC1\xD1[\xDD\x42\xCE\x65\xA5\xBD\a\xA1\xFAN\xAAI\bh\x1F"
      }
             "~\x19\xCA\x3F(\xA8\x95\x8D\xD9\xCD\x7F\xEC\xDB\xF2\r\x8Dq\xF2\x0A"
             "\x23\x0Cr\x15\x8AE\xA1\xB0\xEC\x7F\x49\xF8\x9B\xFE\xD0\x31'+Izt{\b:Vhi\x9D\xE0\x10\x71\xDD\xE4/\a/\x0E]*4"
             "\x98\x17\x11\b\x85-0\xF9P\x8B\x1913!T\xBE\\\x97\x03\x11\x0F\xE1\xFB\x4B\x7Fo\xC1\xB6\f\xDA\x25\xEB\xC2\xE5"
             "\xEC\x23\xCE.D#\xC7\xFE\xD6\xE2\xA5)=\xA8\xAF]3\xAD. \xE5\x9E\xDD/\x1E\xB7\xDD\xE4\x81\x1B\t\xB2s5\xE5\xFE\x31"
             "8\xED\x5E\xC8~\xC3\x54\xADO\xE7\x07\x82\x10\x9Brb\xBF\x14\x1F\x0F\n"
             "\xAE\x14r\xFF\xB6i\bCPT\xE1\xF6\x9B\xA1ne\x81\x96\xF5\xBE\x6D\x0F\x94\x91\xE5\x4C\x11\xCA\x0F\xAFx\xCE\x09"
             "*\xD0\x1C\xE9\x66\x1A\xAD\xA0\xC4\x4B\xD2\x6B\xFA\xB7u\xC4\x66|\xC8\xFE\xDE\xC2\xF9\xD8\x23\xC1\x4B\xDC\x49"
             "\xE9\x26\x08\xB4\xB4\xC3\x20\xC5\x63Wf(W\x89\xC7\x7B.\x13\xB9\xC8\xEA]5c\xDF\x20\x12l\x1B\xA1\\\x94Y\x19z\xA6"
             "\b\xB0\xF0\x46\xDC\x44\xAA/U]\x89\x8A\xE6\x4B\xAA\xDE\x1A\xB9#";
      else {
        __int16 v8 = "+\xAC\xA7o;\xB3t\xAE.\"\x15N\xAF\xC3\x0C\x97\x86\xC1\xD1[\xDD\x42\xCE\x65\xA5\xBD\a\xA1\xFAN\xAAI\bh\x1F~\x19"
      }
             "\xCA\x3F(\xA8\x95\x8D\xD9\xCD\x7F\xEC\xDB\xF2\r\x8Dq\xF2\x0A"
             "\x23\x0Cr\x15\x8AE\xA1\xB0\xEC\x7F\x49\xF8\x9B\xFE\xD0\x31'+Izt{\b:Vhi\x9D\xE0\x10\x71\xDD\xE4/\a/\x0E]*4"
             "\x98\x17\x11\b\x85-0\xF9P\x8B\x1913!T\xBE\\\x97\x03\x11\x0F\xE1\xFB\x4B\x7Fo\xC1\xB6\f\xDA\x25\xEB\xC2\xE5"
             "\xEC\x23\xCE.D#\xC7\xFE\xD6\xE2\xA5)=\xA8\xAF]3\xAD. \xE5\x9E\xDD/\x1E\xB7\xDD\xE4\x81\x1B\t\xB2s5\xE5\xFE\x31"
             "8\xED\x5E\xC8~\xC3\x54\xADO\xE7\x07\x82\x10\x9Brb\xBF\x14\x1F\x0F\n"
             "\xAE\x14r\xFF\xB6i\bCPT\xE1\xF6\x9B\xA1ne\x81\x96\xF5\xBE\x6D\x0F\x94\x91\xE5\x4C\x11\xCA\x0F\xAFx\xCE\x09"
             "*\xD0\x1C\xE9\x66\x1A\xAD\xA0\xC4\x4B\xD2\x6B\xFA\xB7u\xC4\x66|\xC8\xFE\xDE\xC2\xF9\xD8\x23\xC1\x4B\xDC\x49"
             "\xE9\x26\x08\xB4\xB4\xC3\x20\xC5\x63Wf(W\x89\xC7\x7B.\x13\xB9\xC8\xEA]5c\xDF\x20\x12l\x1B\xA1\\\x94Y\x19z\xA6"
             "\b\xB0\xF0\x46\xDC\x44\xAA/U]\x89\x8A\xE6\x4B\xAA\xDE\x1A\xB9#";
      if (!memcmp(v8, v37, 0x13FuLL))
      {
        if ((a1 & 0x10) != 0) {
          uint64_t v9 = "\x01\xE1\x6F\xDB\x97\xD0\xD9\xE8\x91\xC4\xE0\x1A\xE95\xBF=Z@\x83\x87/\xD9\x06\x98;\x84\x03o\xAE>\x0F\xA0f";
        }
        else {
          uint64_t v9 = "\xE1\x6F\xDB\x97\xD0\xD9\xE8\x91\xC4\xE0\x1A\xE95\xBF=Z@\x83\x87/\xD9\x06\x98;\x84\x03o\xAE>\x0F\xA0f";
        }
        if ((a1 & 0x10) != 0) {
          uint64_t v10 = "\x01Z\xBC\x17C\xA8J\xE3\xDA\xAA\xF0\x70\x4B\xA6\xFF\xC9\x33{\x1F\x99\x14\xF7\xFA\xFC\x3F>o~\t\xEF\xD5\x31\x96";
        }
        else {
          uint64_t v10 = "Z\xBC\x17C\xA8J\xE3\xDA\xAA\xF0\x70\x4B\xA6\xFF\xC9\x33{\x1F\x99\x14\xF7\xFA\xFC\x3F>o~\t\xEF\xD5\x31\x96";
        }
        if ((a1 & 0x10) != 0) {
          uint64_t v11 = "\x01\x96\xBA\x8C\x13%\xBE~\x7Flb\x97*[\xB5\xCE\xD4\xFF\x8F[\xA8\xAAez)\xAA\xC5\x23|";
        }
        else {
          uint64_t v11 = "\x96\xBA\x8C\x13%\xBE~\x7Flb\x97*[\xB5\xCE\xD4\xFF\x8F[\xA8\xAAez)\xAA\xC5\x23|";
        }
        uint64_t v12 = (unint64_t *)ccsha3_224_di();
        if (ccpbkdf2_hmac(v12, 88, (uint64_t)"roAhfqRBzTqHATLXmmLLiQIyBUchpmcqrXWMWoztGqWZrEbqIZFKWphBFbGkoJmnRaqDXZaYMreSUJhWTLypGstb", 0x15uLL, "\x0E\xDD\x678\x1F}\x97?#\xACpC\x1C\xBF\xD0\x54P0\x93", 0x3E8uLL, 0x20uLL, (char *)&v33))
        {
          mach_absolute_time();
          printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccpbkdf2_hmac (SHA3-224): %d\n");
          return 4294967224;
        }
        uint64_t v13 = "\x01\x16\xD1\x47C\x97\xE5\x2A\x54GD\xB6\xEC\x78\xB3r\x9As\xA0\x16<\x1F)}4[n\xD3\x51\xC5\x5C\xAC\xD3\x16\xD1"
              "\x47C\x97\xE5\x2A\x54GD\xB6\xEC\x78\xB3r\x9As\xA0\x16<\x1F)}4[n\xD3\x51\xC5\x5C\xAC\xD3\x01\xE1\x6F\xDB\x97"
              "\xD0\xD9\xE8\x91\xC4\xE0\x1A\xE95\xBF=Z@\x83\x87/\xD9\x06\x98;\x84\x03o\xAE>\x0F\xA0f";
        if ((a1 & 0x10) == 0) {
          uint64_t v13 = "\x16\xD1\x47C\x97\xE5\x2A\x54GD\xB6\xEC\x78\xB3r\x9As\xA0\x16<\x1F)}4[n\xD3\x51\xC5\x5C\xAC\xD3\x01\xE1\x6F\xDB\x97\xD0\xD9\xE8\x91\xC4\xE0\x1A\xE95\xBF=Z@\x83\x87/\xD9\x06\x98;\x84\x03o\xAE>\x0F\xA0f";
        }
        uint64_t v14 = *(void *)v13;
        uint64_t v15 = *((void *)v13 + 1);
        uint64_t v17 = *((void *)v13 + 2);
        uint64_t v16 = *((void *)v13 + 3);
        if (v14 == v33 && v15 == v34 && v17 == v35 && v16 == v36)
        {
          uint64_t v21 = (unint64_t *)ccsha3_256_di();
          if (ccpbkdf2_hmac(v21, 88, (uint64_t)"roAhfqRBzTqHATLXmmLLiQIyBUchpmcqrXWMWoztGqWZrEbqIZFKWphBFbGkoJmnRaqDXZaYMreSUJhWTLypGstb", 0x15uLL, "\x0E\xDD\x678\x1F}\x97?#\xACpC\x1C\xBF\xD0\x54P0\x93", 0x3E8uLL, 0x20uLL, (char *)&v33))
          {
            mach_absolute_time();
            printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccpbkdf2_hmac (SHA3-256): %d\n");
            return 4294967224;
          }
          if (*(void *)v9 == v33
            && *((void *)v9 + 1) == v34
            && *((void *)v9 + 2) == v35
            && *((void *)v9 + 3) == v36)
          {
            uint64_t v25 = (unint64_t *)ccsha3_384_di();
            if (ccpbkdf2_hmac(v25, 88, (uint64_t)"roAhfqRBzTqHATLXmmLLiQIyBUchpmcqrXWMWoztGqWZrEbqIZFKWphBFbGkoJmnRaqDXZaYMreSUJhWTLypGstb", 0x15uLL, "\x0E\xDD\x678\x1F}\x97?#\xACpC\x1C\xBF\xD0\x54P0\x93", 0x3E8uLL, 0x20uLL, (char *)&v33))
            {
              mach_absolute_time();
              printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccpbkdf2_hmac (SHA3-384): %d\n");
              return 4294967224;
            }
            if (*(void *)v10 == v33
              && *((void *)v10 + 1) == v34
              && *((void *)v10 + 2) == v35
              && *((void *)v10 + 3) == v36)
            {
              uint64_t v29 = (unint64_t *)ccsha3_512_di();
              if (ccpbkdf2_hmac(v29, 88, (uint64_t)"roAhfqRBzTqHATLXmmLLiQIyBUchpmcqrXWMWoztGqWZrEbqIZFKWphBFbGkoJmnRaqDXZaYMreSUJhWTLypGstb", 0x15uLL, "\x0E\xDD\x678\x1F}\x97?#\xACpC\x1C\xBF\xD0\x54P0\x93", 0x3E8uLL, 0x20uLL, (char *)&v33))
              {
                mach_absolute_time();
                printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccpbkdf2_hmac (SHA3-512): %d\n");
                return 4294967224;
              }
              if (*(void *)v11 == v33
                && *((void *)v11 + 1) == v34
                && *((void *)v11 + 2) == v35
                && *((void *)v11 + 3) == v36)
              {
                return 0;
              }
              mach_absolute_time();
              printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed PBKDF_SHA3_512 KAT\n");
            }
            else
            {
              mach_absolute_time();
              printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed PBKDF_SHA3_384 KAT\n");
            }
          }
          else
          {
            mach_absolute_time();
            printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed PBKDF_SHA3_256 KAT\n");
          }
        }
        else
        {
          mach_absolute_time();
          printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed PBKDF_SHA3_224 KAT\n");
        }
      }
      else
      {
        mach_absolute_time();
        printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed PBKDF_SHA512 KAT\n");
      }
    }
    else
    {
      mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed PBKDF_SHA2 KAT\n");
    }
  }
  else
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed PBKDF_SHA1 KAT\n");
  }
  return 4294967221;
}

uint64_t ccecies_decrypt_gcm_setup(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, int a6)
{
  BOOL v18 = timingsafe_enable_if_supported();
  *(void *)a1 = a2;
  *(void *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 28) = a5;
  *(_DWORD *)(a1 + 32) = a6;
  *(_DWORD *)(a1 + 24) = a4;
  uint64_t v12 = ccrng(0);
  *(void *)(a1 + 8) = v12;
  if (v12)
  {
    if ((a5 - 17) >= 0xFFFFFFFB) {
      int v13 = 0;
    }
    else {
      int v13 = -5;
    }
    if (((1 << a4) & 0x101010000) != 0) {
      int v14 = v13;
    }
    else {
      int v14 = -5;
    }
    if (a4 <= 0x20) {
      unsigned int v15 = v14;
    }
    else {
      unsigned int v15 = -5;
    }
    if (*(_DWORD *)(a3 + 8) == 78647) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = 4294967291;
    }
  }
  else
  {
    uint64_t v16 = 0xFFFFFFFFLL;
  }
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return v16;
}

uint64_t ccder_encode_rsa_priv_size(unint64_t *a1)
{
  int32x4_t v2 = a1 + 3;
  unint64_t v3 = *a1;
  unint64_t v43 = 0;
  uint64_t v4 = ccder_sizeof_integer(1uLL, &v43);
  uint64_t v5 = ccder_sizeof_integer(v3, v2) + v4;
  uint64_t v6 = v5 + ccder_sizeof_integer(v3, &v2[2 * v3 + 1]);
  uint64_t v7 = ccder_sizeof_integer(v3, &v2[3 * v3 + 1]);
  uint64_t v8 = ccrsa_ctx_private_zp(a1);
  unint64_t v9 = cczp_n(v8);
  uint64_t v10 = ccrsa_ctx_private_zp(a1);
  uint64_t v11 = (unint64_t *)cczp_prime(v10);
  uint64_t v12 = v6 + ccder_sizeof_integer(v9, v11);
  uint64_t v13 = ccrsa_ctx_private_zp(a1);
  int v14 = (void *)ccrsa_ctx_private_zp(a1);
  unint64_t v15 = cczp_n(v13 + 16 * *v14 + 32);
  uint64_t v16 = ccrsa_ctx_private_zp(a1);
  uint64_t v17 = (void *)ccrsa_ctx_private_zp(a1);
  BOOL v18 = (unint64_t *)cczp_prime(v16 + 16 * *v17 + 32);
  uint64_t v19 = v12 + ccder_sizeof_integer(v15, v18) + v7;
  uint64_t v20 = ccrsa_ctx_private_zp(a1);
  unint64_t v21 = cczp_n(v20);
  uint64_t v22 = ccrsa_ctx_private_zp(a1);
  uint64_t v23 = v22 + 16 * *(void *)ccrsa_ctx_private_zp(a1);
  uint64_t v24 = (void *)ccrsa_ctx_private_zp(a1);
  uint64_t v25 = v19 + ccder_sizeof_integer(v21, (unint64_t *)(v23 + 16 * *v24 + 64));
  uint64_t v26 = ccrsa_ctx_private_zp(a1);
  uint64_t v27 = (void *)ccrsa_ctx_private_zp(a1);
  unint64_t v28 = cczp_n(v26 + 16 * *v27 + 32);
  uint64_t v29 = ccrsa_ctx_private_zp(a1);
  uint64_t v30 = v29 + 16 * *(void *)ccrsa_ctx_private_zp(a1);
  uint64_t v31 = v30 + 16 * *(void *)ccrsa_ctx_private_zp(a1);
  uint64_t v32 = (void *)ccrsa_ctx_private_zp(a1);
  uint64_t v33 = v25 + ccder_sizeof_integer(v28, (unint64_t *)(v31 + 8 * *v32 + 64));
  uint64_t v34 = ccrsa_ctx_private_zp(a1);
  unint64_t v35 = cczp_n(v34);
  uint64_t v36 = ccrsa_ctx_private_zp(a1);
  uint64_t v37 = v36 + 16 * *(void *)ccrsa_ctx_private_zp(a1);
  uint64_t v38 = v37 + 16 * *(void *)ccrsa_ctx_private_zp(a1);
  uint64_t v39 = v38 + 8 * *(void *)ccrsa_ctx_private_zp(a1);
  uint64_t v40 = (void *)ccrsa_ctx_private_zp(a1);
  uint64_t v41 = ccder_sizeof_integer(v35, (unint64_t *)(v39 + 8 * *v40 + 64));
  return ccder_sizeof(0x2000000000000010, v33 + v41);
}

uint64_t ccsha3_512_c_compress(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return cckeccak_absorb_blocks(a1, 0x48uLL, a2, a3, cckeccak_f1600_c);
}

uint64_t ccsha3_512_c_final(unint64_t *a1, uint64_t a2, void *a3)
{
  return ccsha3_final(a1, a2, a3, cckeccak_f1600_c);
}

void *ccsha3_512_di()
{
  return &ccsha3_512_c_di;
}

unint64_t ccwrap_auth_decrypt_withiv_internal(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t *a4, size_t *a5, char *a6, char *a7)
{
  unint64_t v11 = a3;
  uint64_t v34 = *MEMORY[0x263EF8C08];
  unint64_t v14 = ccwrap_unwrapped_size(a3);
  *a5 = v14;
  if (!ccwrap_argsvalid(a1, v14, v11))
  {
    cc_clear(0x10uLL, &__s);
    unint64_t v25 = 4294967289;
    goto LABEL_9;
  }
  uint64_t v31 = a7;
  unint64_t v15 = v11 >> 3;
  uint64_t v16 = (v11 >> 3) - 1;
  uint64_t __s = *a4;
  unint64_t v28 = a5;
  memmove(a6, a4 + 1, *a5);
  uint64_t v17 = 6 * (v11 >> 3) - 6;
  unint64_t v29 = v11;
  uint64_t v30 = a6;
  uint64_t v18 = 1 - (v11 >> 3);
  uint64_t v19 = a6 - 16;
  uint64_t v20 = 5;
  do
  {
    uint64_t v21 = v20;
    if (v16)
    {
      unint64_t v22 = v15;
      unint64_t v23 = v17;
      do
      {
        uint64_t v24 = *(void *)&v19[8 * v22];
        __s ^= bswap64(v23);
        uint64_t v33 = v24;
        (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t *))(a1 + 24))(a2, 1, &__s, &__s);
        *(void *)&v19[8 * v22] = v33;
        --v23;
        --v22;
      }
      while (v22 != 1);
    }
    uint64_t v20 = v21 - 1;
    v17 += v18;
  }
  while (v21);
  unint64_t v25 = cc_cmp_safe_internal(8, (char *)&__s, v31);
  cc_clear(0x10uLL, &__s);
  if (v25)
  {
    unint64_t v25 = 4294967294;
    unint64_t v11 = v29;
    a6 = v30;
    a5 = v28;
LABEL_9:
    *a5 = 0;
    rsize_t v26 = ccwrap_unwrapped_size(v11);
    cc_clear(v26, a6);
  }
  return v25;
}

unint64_t ccwrap_auth_decrypt_withiv(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t *a4, size_t *a5, char *a6, char *a7)
{
  BOOL v16 = timingsafe_enable_if_supported();
  unint64_t v14 = ccwrap_auth_decrypt_withiv_internal(a1, a2, a3, a4, a5, a6, a7);
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v14;
}

uint64_t fipspost_post_drbg_hmac(char a1)
{
  uint64_t v23 = *MEMORY[0x263EF8C08];
  v22[0] = xmmword_2373BA6C0;
  v22[1] = unk_2373BA6D0;
  v20[1] = unk_2373BA6F0;
  long long v21 = xmmword_2373BA800;
  v19[1] = unk_2373BA710;
  v20[0] = xmmword_2373BA6E0;
  v18[1] = unk_2373BA730;
  v19[0] = xmmword_2373BA700;
  v17[1] = unk_2373BA750;
  v18[0] = xmmword_2373BA720;
  v16[1] = unk_2373BA770;
  v17[0] = xmmword_2373BA740;
  __s2[4] = xmmword_2373BA7C0;
  __s2[5] = unk_2373BA7D0;
  __s2[6] = xmmword_2373BA7E0;
  __s2[7] = unk_2373BA7F0;
  v16[0] = xmmword_2373BA760;
  __s2[0] = xmmword_2373BA780;
  __s2[1] = unk_2373BA790;
  __s2[2] = xmmword_2373BA7A0;
  __s2[3] = unk_2373BA7B0;
  __s1[0] = 0;
  __s1[1] = 0;
  v13[0] = ccsha256_di();
  v13[1] = 0;
  ccdrbg_factory_nisthmac(fipspost_post_drbg_hmac_info, (uint64_t)v13);
  v11[0] = cc_malloc_clear((fipspost_post_drbg_hmac_info[0] + 7) & 0xFFFFFFFFFFFFFFF8);
  v11[1] = (unint64_t)(fipspost_post_drbg_hmac_info[0] + 7) >> 3;
  _OWORD v11[2] = 0;
  v11[3] = cc_ws_alloc;
  uint64_t v12 = cc_ws_free;
  if (!v11[0]) {
    return 4294967283;
  }
  uint64_t v2 = cc_ws_alloc(v11, (unint64_t)(fipspost_post_drbg_hmac_info[0] + 7) >> 3);
  if ((a1 & 0x10) != 0) {
    LOBYTE(__s2[0]) = -36;
  }
  int v3 = ccdrbg_init((uint64_t)fipspost_post_drbg_hmac_info, v2, 32, (uint64_t)v22, 16, (uint64_t)&v21, 32, (uint64_t)v20);
  int v4 = ccdrbg_reseed((uint64_t)fipspost_post_drbg_hmac_info, v2, 32, (uint64_t)v19, 32, (uint64_t)v18);
  int v5 = ccdrbg_generate((uint64_t)fipspost_post_drbg_hmac_info, v2, 128, (uint64_t)__s1, 32, (uint64_t)v17);
  int v6 = ccdrbg_generate((uint64_t)fipspost_post_drbg_hmac_info, v2, 128, (uint64_t)__s1, 32, (uint64_t)v16) | v5 | v4 | v3;
  BOOL v7 = v6 != 0;
  if (!v6 && !memcmp(__s1, __s2, 0x80uLL))
  {
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v8 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: rc: %d\n", v8, "fipspost_post_drbg_hmac", 147, v7);
    uint64_t v9 = 4294967224;
  }
  v12((uint64_t)v11);
  return v9;
}

uint64_t cccmac_final_generate_internal(char *__s, size_t a2, void *a3)
{
  uint64_t v18 = *MEMORY[0x263EF8C08];
  int v4 = (void *)*((void *)__s + 8);
  unint64_t v5 = *((void *)__s + 6);
  unint64_t v6 = *((void *)__s + 7) + v5;
  *((void *)__s + 7) = v6;
  if (v5 > 0x10)
  {
    uint64_t v10 = 0xFFFFFFFFLL;
  }
  else
  {
    if (v5) {
      BOOL v8 = 1;
    }
    else {
      BOOL v8 = v6 == 0;
    }
    char v9 = !v8;
    uint64_t v10 = 0xFFFFFFFFLL;
    if (a2 - 17 >= 0xFFFFFFFFFFFFFFF0 && (v9 & 1) == 0)
    {
      uint64_t v12 = __s + 32;
      uint64_t v13 = __s;
      if (v5 != 16)
      {
        uint64_t v13 = __s + 16;
        unint64_t v14 = &v12[v5];
        cc_clear(16 - v5, &v12[v5]);
        *unint64_t v14 = 0x80;
      }
      for (uint64_t i = 0; i != -16; --i)
        __s[i + 47] ^= v13[i + 15];
      cccbc_update_internal((uint64_t)v4, (uint64_t)(__s + 72), (uint64_t)&__s[*v4 + 72], 1, (uint64_t)(__s + 32), (uint64_t)__src);
      memcpy(a3, __src, a2);
      uint64_t v10 = 0;
      int v4 = (void *)*((void *)__s + 8);
    }
  }
  cc_clear(v4[1] + *v4 + 80, __s);
  return v10;
}

uint64_t cccmac_final_generate(char *a1, size_t a2, void *a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t internal = cccmac_final_generate_internal(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return internal;
}

uint64_t cccmac_final_verify_internal(char *a1, uint64_t a2, char *a3)
{
  uint64_t v7 = *MEMORY[0x263EF8C08];
  if (cccmac_final_generate_internal(a1, 0x10uLL, v6)) {
    return 0xFFFFFFFFLL;
  }
  if (cc_cmp_safe_internal(a2, a3, v6)) {
    return 4294967291;
  }
  return 0;
}

uint64_t cccmac_final_verify(char *a1, uint64_t a2, char *a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t v6 = cccmac_final_verify_internal(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return v6;
}

uint64_t ccdigest_oid_lookup(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v13 = &a9;
  do
  {
    uint64_t v10 = v13++;
    uint64_t v11 = *v10;
  }
  while (*v10 && !ccoid_equal(*(void *)(v11 + 32), a1));
  return v11;
}

uint64_t cc_fault_canary_set(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  for (unint64_t i = 0; i != 16; ++i)
    *(unsigned char *)(result + i) = *(unsigned char *)(a5 + i % a3) ^ *(unsigned char *)(a4 + i % a3) ^ *(unsigned char *)(a2 + i);
  if (a3 >= 0x11)
  {
    for (uint64_t j = 16; j != a3; ++j)
      *(unsigned char *)(result + (j & 0xF)) ^= *(unsigned char *)(a5 + j) ^ *(unsigned char *)(a4 + j);
  }
  return result;
}

uint64_t cckyber_indcpa_keypair(unsigned int *a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v35 = *MEMORY[0x263EF8C08];
  uint64_t v8 = *a1;
  unint64_t v9 = sizeof_struct_ccpolyzp_po2cyc();
  v29[0] = cc_malloc_clear(8 * ((v9 - 1 + (v8 << 9)) / v9 + (v9 - 1 + (v8 << 9) * v8) / v9) + 16
                                                                                            * ((v9 - 1 + (v8 << 9))
                                                                                             / v9));
  uint64_t v10 = *a1;
  unint64_t v11 = sizeof_struct_ccpolyzp_po2cyc();
  v29[1] = (v11 - 1 + (v10 << 9)) / v11 + (v11 - 1 + (v10 << 9) * v10) / v11 + 2 * ((v11 - 1 + (v10 << 9)) / v11);
  uint64_t v30 = 0;
  uint64_t v31 = cc_ws_alloc;
  uint64_t v32 = cc_ws_free;
  if (!v29[0]) {
    return 4294967283;
  }
  uint64_t v28 = a2;
  uint64_t v12 = cc_ws_alloc(v29, ((v10 << 6) * v10) & 0x1FFFFFFFFFFFFFC0);
  uint64_t v13 = v31(v29, v10 << 6);
  uint64_t v14 = v31(v29, v10 << 6);
  uint64_t v15 = v31(v29, v10 << 6);
  cckyber_hash_g(0x20uLL, a4, (uint64_t)__s);
  cckyber_sample_ntt(a1, (char *)__s, 0, v12);
  if (*a1)
  {
    int v16 = 0;
    unint64_t v17 = 0;
    do
    {
      char v18 = v17++;
      cckyber_poly_getnoise(v15 + 2 * (v16 & 0xFFFFFF00), v34, v18);
      unint64_t v19 = *a1;
      v16 += 256;
    }
    while (v17 < v19);
    if (v19)
    {
      int v20 = 0;
      unint64_t v21 = 0;
      do
      {
        cckyber_poly_getnoise(v13 + 2 * (v20 & 0xFFFFFF00), v34, v17);
        ++v21;
        v20 += 256;
        LODWORD(v17) = v17 + 1;
      }
      while (v21 < *a1);
    }
  }
  cckyber_polyvec_ntt_forward(a1, v15);
  cckyber_polyvec_reduce(a1, v15);
  cckyber_polyvec_ntt_forward(a1, v13);
  LODWORD(v22) = *a1;
  if (*a1)
  {
    unsigned int v23 = 0;
    unint64_t v24 = 0;
    do
    {
      cckyber_polyvec_basemul(a1, v14 + 2 * v23, v12 + 2 * v23 * v22, v15);
      cckyber_poly_toplant(v14 + 2 * v23);
      ++v24;
      unint64_t v22 = *a1;
      v23 += 256;
    }
    while (v24 < v22);
  }
  cckyber_polyvec_add(a1, v14, v14, v13);
  cckyber_polyvec_reduce(a1, v14);
  cckyber_polyvec_encode(a1, v28, v14);
  long long v25 = __s[1];
  rsize_t v26 = (_OWORD *)(v28 + 384 * *a1);
  *rsize_t v26 = __s[0];
  v26[1] = v25;
  cckyber_polyvec_encode(a1, a3, v15);
  uint64_t v30 = 0;
  cc_clear(0x40uLL, __s);
  v32((uint64_t)v29);
  return 0;
}

uint64_t cckyber_indcpa_encrypt_ws(uint64_t a1, unsigned int *a2, char *a3, uint64_t a4, char *a5, uint64_t a6)
{
  uint64_t v10 = *a2;
  uint64_t v36 = *(void *)(a1 + 16);
  uint64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 64);
  uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 64);
  uint64_t v32 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10 << 6);
  uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 64);
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10 << 6);
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10 << 6);
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10 << 6);
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, ((v10 << 6) * v10) & 0x1FFFFFFFFFFFFFC0);
  cckyber_polyvec_decode(a2, v13, (uint64_t)a3);
  uint64_t v15 = &a3[384 * *a2];
  int v16 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, (48 * v10) | 4);
  cckyber_polyvec_encode(a2, (uint64_t)v16, v13);
  unint64_t v17 = &v16[384 * *a2];
  long long v18 = *((_OWORD *)v15 + 1);
  *(_OWORD *)unint64_t v17 = *(_OWORD *)v15;
  *((_OWORD *)v17 + 1) = v18;
  if (cc_cmp_safe_internal((384 * *a2) | 0x20, v16, a3)) {
    return 4294967289;
  }
  uint64_t v31 = v13;
  cckyber_sample_ntt(a2, v15, 1, v14);
  if (*a2)
  {
    int v20 = 0;
    unint64_t v21 = 0;
    do
    {
      cckyber_poly_getnoise(v11 + 2 * (v20 & 0xFFFFFF00), a5, v21++);
      unint64_t v22 = *a2;
      v20 += 256;
    }
    while (v21 < v22);
    uint64_t v23 = v32;
    if (v22)
    {
      int v24 = 0;
      unint64_t v25 = 0;
      int v26 = v21;
      do
      {
        LODWORD(v21) = v26 + 1;
        cckyber_poly_getnoise(v32 + 2 * (v24 & 0xFFFFFF00), a5, v26);
        ++v25;
        v24 += 256;
        int v26 = v21;
      }
      while (v25 < *a2);
    }
  }
  else
  {
    LOBYTE(v21) = 0;
    uint64_t v23 = v32;
  }
  cckyber_poly_getnoise(v38, a5, v21);
  cckyber_poly_from_msg(v34, a4);
  cckyber_polyvec_ntt_forward(a2, v11);
  LODWORD(v27) = *a2;
  if (*a2)
  {
    unsigned int v28 = 0;
    unint64_t v29 = 0;
    do
    {
      cckyber_polyvec_basemul(a2, v12 + 2 * v28, v14 + 2 * v28 * v27, v11);
      cckyber_ntt_inverse(v12 + 2 * v28);
      ++v29;
      unint64_t v27 = *a2;
      v28 += 256;
    }
    while (v29 < v27);
  }
  cckyber_polyvec_add(a2, v12, v12, v23);
  cckyber_polyvec_reduce(a2, v12);
  uint64_t v30 = v35;
  cckyber_polyvec_basemul(a2, v35, v31, v11);
  cckyber_ntt_inverse(v35);
  cckyber_poly_add(v30, v30, v38);
  cckyber_poly_add(v30, v30, v34);
  cckyber_poly_reduce(v35);
  cckyber_polyvec_compress(a2, a6, v12);
  cckyber_poly_compress((uint64_t)a2, a6 + 32 * a2[2] * *a2, v35);
  uint64_t result = 0;
  *(void *)(a1 + 16) = v36;
  return result;
}

uint64_t cckyber_indcpa_encrypt(unsigned int *a1, char *a2, uint64_t a3, char *a4, uint64_t a5)
{
  uint64_t v10 = *a1;
  unint64_t v11 = sizeof_struct_ccpolyzp_po2cyc();
  v16[0] = cc_malloc_clear(8* (3 * ((v11 + 511) / v11)+ 4 * ((v11 - 1 + (v10 << 9)) / v11)+ (v11 + 384 * v10 + 31) / v11+ (v11 - 1 + (v10 << 9) * v10) / v11));
  uint64_t v12 = *a1;
  unint64_t v13 = sizeof_struct_ccpolyzp_po2cyc();
  v16[1] = 3 * ((v13 + 511) / v13)
         + 4 * ((v13 - 1 + (v12 << 9)) / v13)
         + (v13 + 384 * v12 + 31) / v13
         + (v13 - 1 + (v12 << 9) * v12) / v13;
  _OWORD v16[2] = 0;
  v16[3] = cc_ws_alloc;
  unint64_t v17 = cc_ws_free;
  if (!v16[0]) {
    return 4294967283;
  }
  uint64_t v14 = cckyber_indcpa_encrypt_ws((uint64_t)v16, a1, a2, a3, a4, a5);
  v17((uint64_t)v16);
  return v14;
}

uint64_t cckyber_indcpa_decrypt_ws(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *a2;
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 64);
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 64);
  v9 <<= 6;
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v9);
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v9);
  uint64_t v15 = a4 + 32 * a2[2] * *a2;
  cckyber_polyvec_decompress(a2, v13, a4);
  cckyber_poly_decompress((uint64_t)a2, v11, v15);
  cckyber_polyvec_decode(a2, v14, a3);
  cckyber_polyvec_ntt_forward(a2, v13);
  cckyber_polyvec_basemul(a2, v12, v14, v13);
  cckyber_ntt_inverse(v12);
  cckyber_poly_sub(v12, v11, v12);
  cckyber_poly_reduce(v12);
  uint64_t result = cckyber_poly_to_msg(a5, v12);
  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t ccsrp_generate_server_pubkey_ws(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = ccdh_gp_n(*(void *)(a2 + 8));
  uint64_t v5 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  uint64_t v6 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  if ((*(_WORD *)(a2 + 24) & 0x1C0) != 0)
  {
    ccdh_gp_n(*(void *)(a2 + 8));
  }
  else
  {
    uint64_t v7 = *(void *)(a2 + 8);
    ccdh_gp_n(v7);
    cczp_mul_ws(a1, v7);
  }
  unint64_t private_key_bitlen = ccdh_generate_private_key_bitlen(*(void **)(a2 + 8));
  uint64_t v9 = ccdh_gp_n(*(void *)(a2 + 8));
  uint64_t v10 = ccdh_gp_n(*(void *)(a2 + 8));
  if (ccn_bitlen_internal(v9, a2 + 32 + 8 * v10) > private_key_bitlen) {
    unint64_t private_key_bitlen = cczp_bitlen(*(void *)(a2 + 8));
  }
  uint64_t v12 = *(void **)(a2 + 8);
  uint64_t v11 = *(uint64_t (***)(void, uint64_t, uint64_t *))(a2 + 16);
  uint64_t v13 = (void *)ccdh_gp_g(v12);
  uint64_t v14 = ccdh_gp_n(*(void *)(a2 + 8));
  uint64_t v15 = ccdh_power_blinded_ws(a1, v11, v12, v6, v13, private_key_bitlen, a2 + 32 + 8 * v14);
  if (!v15)
  {
    uint64_t v16 = *(void *)(a2 + 8);
    ccdh_gp_n(v16);
    cczp_add_ws(a1, v16);
  }
  *(void *)(a1 + 16) = v5;
  return v15;
}

uint64_t ccsrp_generate_server_S_ws(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v8 = ccdh_gp_n(*(void *)(a2 + 8));
  uint64_t v24 = *(void *)(a1 + 16);
  uint64_t v9 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8);
  uint64_t v10 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8);
  uint64_t v11 = *(const void **)(a2 + 8);
  uint64_t v12 = a2 + 32;
  uint64_t v13 = ccdh_gp_n(v11);
  uint64_t v14 = cczp_mm_power_fast_ws(a1, v11, v9, (unint64_t *)(a2 + 32 + 16 * v13), a4);
  if (v14)
  {
    uint64_t v22 = v14;
LABEL_5:
    ccn_zero(v8, a3);
    goto LABEL_6;
  }
  cczp_mul_ws(a1, *(void *)(a2 + 8));
  unint64_t private_key_bitlen = ccdh_generate_private_key_bitlen(*(void **)(a2 + 8));
  uint64_t v16 = ccdh_gp_n(*(void *)(a2 + 8));
  uint64_t v17 = ccdh_gp_n(*(void *)(a2 + 8));
  if (ccn_bitlen_internal(v16, v12 + 8 * v17) > private_key_bitlen) {
    unint64_t private_key_bitlen = cczp_bitlen(*(void *)(a2 + 8));
  }
  uint64_t v20 = a2 + 8;
  long long v18 = *(void **)(a2 + 8);
  unint64_t v19 = *(uint64_t (***)(void, uint64_t, uint64_t *))(v20 + 8);
  uint64_t v21 = ccdh_gp_n(v18);
  uint64_t v22 = ccdh_power_blinded_ws(a1, v19, v18, (uint64_t *)a3, v10, private_key_bitlen, v12 + 8 * v21);
  if (v22) {
    goto LABEL_5;
  }
LABEL_6:
  *(void *)(a1 + 16) = v24;
  return v22;
}

uint64_t ccsrp_server_generate_public_key(uint64_t a1, uint64_t (**a2)(void, unint64_t, uint64_t), uint64_t a3, char *a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  public_key_uint64_t internal = ccsrp_server_generate_public_key_internal(a1, a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return public_key_internal;
}

uint64_t ccsrp_server_generate_public_key_internal(uint64_t a1, uint64_t (**a2)(void, unint64_t, uint64_t), uint64_t a3, char *a4)
{
  uint64_t v8 = ccdh_gp_n(*(void *)(a1 + 8));
  uint64_t v9 = CCDH_POWER_BLINDED_WORKSPACE_N(v8);
  v22[0] = cc_malloc_clear(8 * (3 * v8 + v9));
  v22[1] = CCDH_POWER_BLINDED_WORKSPACE_N(v8) + 3 * v8;
  uint64_t v23 = 0;
  uint64_t v24 = cc_ws_alloc;
  unint64_t v25 = cc_ws_free;
  if (!v22[0]) {
    return 4294967283;
  }
  uint64_t v10 = ccdh_gp_n(*(void *)(a1 + 8));
  uint64_t v11 = cc_ws_alloc(v22, v10);
  uint64_t v12 = a1 + 32 + 16 * ccdh_gp_n(*(void *)(a1 + 8));
  uint64_t v13 = ccdh_gp_n(*(void *)(a1 + 8));
  uint64_t v14 = ccdh_gp_n(*(void *)(a1 + 8));
  uint64_t uint_internal = ccn_read_uint_internal(v13, v12, 8 * v14, a3);
  if (uint_internal
    || (*(_DWORD *)(a1 + 24) &= ~1u,
        uint64_t v16 = *(void **)(a1 + 8),
        uint64_t v17 = ccdh_gp_n(v16),
        uint64_t uint_internal = ccdh_generate_private_key_ws((uint64_t)v22, v16, (void *)(a1 + 32 + 8 * v17), a2),
        uint_internal))
  {
    server_pubuint64_t key_ws = uint_internal;
  }
  else
  {
    if ((*(_WORD *)(a1 + 24) & 0x1C0) == 0) {
      ccsrp_generate_k_ws((uint64_t)v22, a1, v11);
    }
    server_pubuint64_t key_ws = ccsrp_generate_server_pubkey_ws((uint64_t)v22, a1);
    if (!server_pubkey_ws)
    {
      ccdh_gp_n(*(void *)(a1 + 8));
      unint64_t v19 = ccdh_gp_n(*(void *)(a1 + 8));
      uint64_t v20 = ccdh_gp_n(*(void *)(a1 + 8));
      ccn_write_uint_padded_ct_internal(v19, (unint64_t *)(a1 + 32), 8 * v20, a4);
    }
  }
  uint64_t v23 = 0;
  v25((uint64_t)v22);
  return server_pubkey_ws;
}

uint64_t ccsrp_server_compute_session(uint64_t a1, char *a2, size_t a3, char *a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = ccsrp_server_compute_session_internal(a1, a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccsrp_server_compute_session_internal(uint64_t a1, char *a2, size_t a3, char *a4, uint64_t a5)
{
  uint64_t v10 = ccdh_gp_n(*(void *)(a1 + 8));
  uint64_t v11 = CCDH_POWER_BLINDED_WORKSPACE_N(v10);
  v24[0] = cc_malloc_clear(8 * (v11 + 4 * v10));
  v24[1] = CCDH_POWER_BLINDED_WORKSPACE_N(v10) + 4 * v10;
  uint64_t v25 = 0;
  int v26 = cc_ws_alloc;
  unint64_t v27 = cc_ws_free;
  if (!v24[0]) {
    return 4294967283;
  }
  uint64_t v12 = ccdh_gp_n(*(void *)(a1 + 8));
  uint64_t v13 = a1 + 32;
  ccdh_gp_n(*(void *)(a1 + 8));
  if (!ccn_n(v12, a1 + 32))
  {
    uint64_t K_from_S_ws = 4294967237;
    cc_ws_free((uint64_t)v24);
    return K_from_S_ws;
  }
  uint64_t v23 = a4;
  uint64_t v14 = (unint64_t *)cc_ws_alloc(v24, v12);
  uint64_t v15 = v26(v24, v12);
  uint64_t v16 = ccdh_gp_n(*(void *)(a1 + 8));
  uint64_t v17 = ccdh_gp_n(*(void *)(a1 + 8));
  uint64_t v18 = ccdh_gp_n(*(void *)(a1 + 8));
  uint64_t uint_internal = ccn_read_uint_internal(v17, v14, 8 * v18, a5);
  if (!uint_internal)
  {
    cczp_mod_ws((uint64_t)v24, *(void *)(a1 + 8));
    if (!ccn_n(v12, v15))
    {
      uint64_t K_from_S_ws = 4294967238;
      goto LABEL_8;
    }
    ccdh_gp_n(*(void *)(a1 + 8));
    ccsrp_generate_u_ws((uint64_t)v24, (uint64_t *)a1, v15, v14, (unint64_t *)(a1 + 32));
    uint64_t uint_internal = ccsrp_generate_server_S_ws((uint64_t)v24, a1, (void *)(v13 + 24 * v16), v15);
    if (!uint_internal)
    {
      uint64_t K_from_S_ws = ccsrp_generate_K_from_S_ws((uint64_t)v24, a1, (unint64_t *)(v13 + 24 * v16));
      if (!K_from_S_ws)
      {
        ccdh_gp_n(*(void *)(a1 + 8));
        ccsrp_generate_M_ws((uint64_t)v24, (size_t **)a1, a2, a3, v23, v14, (unint64_t *)(a1 + 32));
        ccsrp_generate_H_AMK_ws((uint64_t)v24, a1, v14, v21);
      }
      goto LABEL_8;
    }
  }
  uint64_t K_from_S_ws = uint_internal;
LABEL_8:
  uint64_t v25 = 0;
  v27((uint64_t)v24);
  return K_from_S_ws;
}

uint64_t ccsrp_server_start_authentication(uint64_t a1, uint64_t (**a2)(void, unint64_t, uint64_t), char *a3, size_t a4, char *a5, uint64_t a6, uint64_t a7, char *a8)
{
  BOOL v19 = timingsafe_enable_if_supported();
  *(void *)(a1 + 16) = a2;
  public_key_uint64_t internal = ccsrp_server_generate_public_key_internal(a1, a2, a6, a8);
  if (!public_key_internal) {
    public_key_uint64_t internal = ccsrp_server_compute_session_internal(a1, a3, a4, a5, a7);
  }
  uint64_t v17 = public_key_internal;
  cc_disable_dit_with_sb((unsigned int *)&v19);
  return v17;
}

uint64_t ccsrp_server_verify_session(uint64_t a1, char *a2, void *a3)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v6 = ccsrp_sizeof_M_HAMK(*(void *)a1);
  uint64_t v7 = ccdh_gp_n(*(void *)(a1 + 8));
  int v8 = cc_cmp_safe_internal(v6, (char *)(a1 + 32 + 32 * v7 + 2 * **(void **)a1), a2);
  unsigned int v9 = *(_DWORD *)(a1 + 24);
  if (v8)
  {
    uint64_t v10 = 0;
    *(_DWORD *)(a1 + 24) = v9 & 0xFFFFFFFE;
  }
  else
  {
    *(_DWORD *)(a1 + 24) = v9 & 0xFFFFFFFE | (v9 >> 2) & 1;
    if ((v9 >> 2))
    {
      uint64_t v11 = (const void *)(a1 + 32 + 32 * ccdh_gp_n(*(void *)(a1 + 8)) + 3 * **(void **)a1);
      size_t v12 = ccsrp_sizeof_M_HAMK(*(void *)a1);
      memcpy(a3, v11, v12);
      uint64_t v10 = *(unsigned char *)(a1 + 24) & 1;
    }
    else
    {
      uint64_t v10 = 0;
    }
  }
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v10;
}

uint64_t ccder_blob_encode_integer(uint64_t *a1, unint64_t a2, unint64_t *a3)
{
  return ccder_blob_encode_implicit_integer(a1, 2uLL, a2, a3);
}

uint64_t ccz_seti(uint64_t a1, uint64_t a2)
{
  v7[1] = *MEMORY[0x263EF8C08];
  BOOL v6 = timingsafe_enable_if_supported();
  v7[0] = a2;
  v5[0] = ccn_n(1uLL, (uint64_t)v7);
  v5[1] = 0;
  v5[2] = 1;
  v5[3] = v7;
  ccz_set(a1, (uint64_t)v5);
  return cc_disable_dit_with_sb((unsigned int *)&v6);
}

void *ccspake_transcript_init(uint64_t a1)
{
  uint64_t v2 = (**(uint64_t (***)(void))(a1 + 8))();

  return ccdigest_init_internal(v2, (void *)(a1 + 64));
}

unint64_t *ccspake_transcript_append(uint64_t a1, size_t a2, char *a3)
{
  v9[1] = *MEMORY[0x263EF8C08];
  v9[0] = a2;
  BOOL v6 = (unint64_t *)(**(uint64_t (***)(uint64_t, size_t))(a1 + 8))(a1, a2);
  uint64_t result = ccdigest_update_internal(v6, (void *)(a1 + 64), 8uLL, (char *)v9);
  if (a2)
  {
    int v8 = (unint64_t *)(**(uint64_t (***)(unint64_t *))(a1 + 8))(result);
    return ccdigest_update_internal(v8, (void *)(a1 + 64), a2, a3);
  }
  return result;
}

unint64_t *ccspake_transcript_begin(uint64_t a1, size_t a2, char *a3, size_t a4, char *a5, size_t a6, char *a7)
{
  ccspake_transcript_append(a1, a2, a3);
  ccspake_transcript_append(a1, a4, a5);
  size_t v12 = ccspake_transcript_append(a1, a6, a7);
  uint64_t v13 = (unint64_t *)(*(uint64_t (**)(unint64_t *))(*(void *)a1 + 8))(v12);
  unint64_t v14 = *v13;
  uint64_t v15 = *(unint64_t **)(*(void *)a1 + 24);
  ccspake_transcript_append_point(a1, v13, *(unint64_t **)(*(void *)a1 + 16), (unint64_t *)(*(void *)(*(void *)a1 + 16) + 8 * *v13));

  return ccspake_transcript_append_point(a1, v13, v15, &v15[v14]);
}

unint64_t *ccspake_transcript_append_point(uint64_t a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t v14 = *MEMORY[0x263EF8C08];
  int v13 = 0;
  memset(v12, 0, sizeof(v12));
  char v11 = 4;
  unint64_t v8 = cczp_bitlen((uint64_t)a2) + 7;
  unint64_t v9 = *a2;
  ccn_write_uint_padded_internal(v9, a3, v8 >> 3, (char *)v12);
  ccn_write_uint_padded_internal(v9, a4, v8 >> 3, (char *)v12 + (v8 >> 3));
  return ccspake_transcript_append(a1, (v8 >> 2) | 1, &v11);
}

unint64_t *ccspake_transcript_append_scalar(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  uint64_t v10 = *MEMORY[0x263EF8C08];
  __int16 v9 = 0;
  memset(v8, 0, sizeof(v8));
  unint64_t v6 = (unint64_t)(cczp_bitlen((uint64_t)&a2[5 * *a2 + 4]) + 7) >> 3;
  ccn_write_uint_padded_internal(*a2, a3, v6, (char *)v8);
  return ccspake_transcript_append(a1, v6, (char *)v8);
}

uint64_t ccspake_transcript_finish(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (**(uint64_t (***)(void))(a1 + 8))();
  uint64_t v5 = (void *)(a1 + 64);
  (*(void (**)(uint64_t, void *, uint64_t))(v4 + 56))(v4, v5, a2);
  rsize_t v6 = *(void *)(v4 + 8) + *(void *)(v4 + 16) + 12;

  return cc_clear(v6, v5);
}

uint64_t ccmode_gcm_aad(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (*(_WORD *)(a1 + 80) != 2) {
    return 4294967228;
  }
  uint64_t v3 = a3;
  unint64_t v4 = a2;
  uint64_t v6 = a1 + 16;
  uint64_t v7 = *(void *)(a1 + 88);
  unsigned int v8 = v7 & 0xF;
  if ((v7 & 0xF) == 0) {
    goto LABEL_7;
  }
  uint64_t v9 = 16 - v8;
  if (a2 >= v9)
  {
    uint64_t v10 = (v7 & 0xF) + a1 + 15;
    uint64_t v11 = 16 - v8;
    do
    {
      *(unsigned char *)(v10 + v11) ^= *(unsigned char *)(a3 - 1 + v11);
      --v11;
    }
    while (v11);
    ccmode_gcm_mult_h(a1, a1 + 16);
    v4 -= v9;
    v3 += v9;
    *(void *)(a1 + 88) += v9;
LABEL_7:
    if (v4 >= 0x10)
    {
      do
      {
        for (uint64_t i = 0; i != -16; --i)
          *(unsigned char *)(a1 + i + 31) ^= *(unsigned char *)(v3 + i + 15);
        ccmode_gcm_mult_h(a1, v6);
        v4 -= 16;
        v3 += 16;
        *(void *)(a1 + 88) += 16;
      }
      while (v4 > 0xF);
    }
    unsigned int v8 = 0;
  }
  if (!v4) {
    return 0;
  }
  uint64_t v13 = a1 + v8 + 15;
  unint64_t v14 = v4;
  do
  {
    *(unsigned char *)(v13 + v14) ^= *(unsigned char *)(v3 - 1 + v14);
    --v14;
  }
  while (v14);
  uint64_t result = 0;
  *(void *)(a1 + 88) += v4;
  return result;
}

uint64_t ccrsa_emsa_pkcs1v15_encode_internal(unint64_t a1, _WORD *a2, size_t a3, const void *a4, unsigned __int8 *a5)
{
  if (a5)
  {
    uint64_t v8 = 4294967289;
    if (a3 > 0xFF) {
      return v8;
    }
    uint64_t v9 = a5[1];
    if (v9 > 0xFB) {
      return v8;
    }
    if (a3 + v9 + 8 > 0x7C) {
      return 4294967289;
    }
    unint64_t v10 = a3 + v9 + 10;
  }
  else
  {
    LODWORD(v9) = 0;
    unint64_t v10 = a3;
  }
  uint64_t v8 = 4294967289;
  if (a1 >= 0xB && v10 <= a1 - 11)
  {
    size_t v11 = a1 - v10 - 3;
    *a2 = 256;
    size_t v12 = a2 + 1;
    memset(a2 + 1, 255, v11);
    uint64_t v13 = (char *)v12 + v11;
    *((unsigned char *)v12 + v11) = 0;
    unint64_t v14 = (char *)v12 + v11 + 1;
    if (a5)
    {
      v13[1] = 48;
      void v13[2] = v10 - 2;
      void v13[3] = 48;
      uint64_t v15 = v13 + 5;
      void v13[4] = v9 + 4;
      memcpy(v13 + 5, a5, v9 + 2);
      uint64_t v16 = &v15[v9 + 2];
      *(_WORD *)uint64_t v16 = 5;
      _OWORD v16[2] = 4;
      unint64_t v14 = v16 + 4;
      v16[3] = a3;
    }
    memcpy(v14, a4, a3);
    return 0;
  }
  return v8;
}

uint64_t ccrsa_emsa_pkcs1v15_encode(unint64_t a1, _WORD *a2, size_t a3, const void *a4, unsigned __int8 *a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = ccrsa_emsa_pkcs1v15_encode_internal(a1, a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccrsa_oaep_encode_parameter_ws(uint64_t a1, size_t *a2, uint64_t (**a3)(void, size_t, char *), uint64_t a4, void *a5, size_t a6, const void *a7, size_t a8, char *a9)
{
  uint64_t v30 = *MEMORY[0x263EF8C08];
  uint64_t v9 = a4 - 1;
  rsize_t v10 = *a2;
  if (a4 - 1 >= ((2 * *a2) | 1) && v9 + ~(2 * v10) >= a6)
  {
    uint64_t v20 = *a3;
    if (v10 > 0xB)
    {
      uint64_t v12 = v20(a3, *a2, __src);
      if (v12) {
        return v12;
      }
    }
    else
    {
      uint64_t v12 = v20(a3, 12, __s);
      __memcpy_chk();
      cc_clear(v10, __s);
      if (v12) {
        return v12;
      }
    }
    size_t v26 = v9 - v10;
    unint64_t v21 = (v9 - v10 + 7) >> 3;
    uint64_t v27 = *(void *)(a1 + 16);
    uint64_t v22 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v21);
    uint64_t v25 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v21);
    ccn_zero(v21, v22);
    ccdigest_internal((uint64_t)a2, a8, a9, (uint64_t)v22);
    v22[v26 + ~a6] = 1;
    memcpy(&v22[v26 - a6], a7, a6);
    ccmgf_internal((uint64_t)a2, v26, v25, *a2, __src);
    ccn_xor(v21, (uint64_t)v22, (uint64_t)v22, v25);
    ccmgf_internal((uint64_t)a2, *a2, (uint64_t)__s, v26, v22);
    ccn_xor((*a2 + 7) >> 3, (uint64_t)__src, (uint64_t)__src, (uint64_t)__s);
    uint64_t v23 = ccrsa_block_start(a4, a5, 0);
    memmove((void *)(v23 + 1), __src, *a2);
    uint64_t v24 = (unsigned char *)ccrsa_block_start(a4, a5, 1);
    *uint64_t v24 = 0;
    memcpy(&v24[*a2 + 1], v22, v26);
    ccn_swap((unint64_t)(a4 + 7) >> 3, (unint64_t *)a5);
    cc_clear(0x40uLL, __src);
    cc_clear(0x40uLL, __s);
    *(void *)(a1 + 16) = v27;
    return v12;
  }
  return 4294967273;
}

uint64_t ccrsa_oaep_encode_parameter_internal(size_t *a1, uint64_t (**a2)(void, size_t, char *), uint64_t a3, void *a4, size_t a5, const void *a6, size_t a7, char *a8)
{
  unint64_t v16 = ((a3 + ~*a1 + 7) >> 2) & 0x3FFFFFFFFFFFFFFELL;
  v19[0] = cc_malloc_clear(8 * v16);
  v19[1] = v16;
  _OWORD v19[2] = 0;
  void v19[3] = cc_ws_alloc;
  uint64_t v20 = cc_ws_free;
  if (!v19[0]) {
    return 4294967283;
  }
  uint64_t v17 = ccrsa_oaep_encode_parameter_ws((uint64_t)v19, a1, a2, a3, a4, a5, a6, a7, a8);
  v20((uint64_t)v19);
  return v17;
}

uint64_t ccrsa_oaep_encode_parameter(size_t *a1, uint64_t (**a2)(void, size_t, char *), uint64_t a3, void *a4, size_t a5, const void *a6, size_t a7, char *a8)
{
  BOOL v18 = timingsafe_enable_if_supported();
  uint64_t v16 = ccrsa_oaep_encode_parameter_internal(a1, a2, a3, a4, a5, a6, a7, a8);
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return v16;
}

uint64_t ccder_encode_tag(unint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t v4 = a2;
  uint64_t v5 = a3;
  if (ccder_blob_encode_tag(&v4, a1)) {
    return v5;
  }
  else {
    return 0;
  }
}

uint64_t ccder_encode_len(unint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t v4 = a2;
  uint64_t v5 = a3;
  if (ccder_blob_encode_len(&v4, a1)) {
    return v5;
  }
  else {
    return 0;
  }
}

uint64_t ccder_encode_tl(unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a4) {
    return 0;
  }
  uint64_t v5 = a3;
  uint64_t v6 = a4;
  if (ccder_blob_encode_tl(&v5, a1, a2)) {
    return v6;
  }
  else {
    return 0;
  }
}

uint64_t ccder_encode_body_nocopy(unint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  v4[0] = 0;
  v4[1] = 0;
  uint64_t v5 = a2;
  uint64_t v6 = a3;
  if (ccder_blob_reserve(&v5, a1, v4)) {
    return v6;
  }
  else {
    return 0;
  }
}

uint64_t ccder_encode_constructed_tl(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a4) {
    return 0;
  }
  uint64_t v5 = a3;
  uint64_t v6 = a4;
  if (ccder_blob_encode_tl(&v5, a1, a2 - a4)) {
    return v6;
  }
  else {
    return 0;
  }
}

uint64_t ccder_encode_oid(const void *a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t v4 = a2;
  uint64_t v5 = a3;
  if (ccder_blob_encode_oid(&v4, a1)) {
    return v5;
  }
  else {
    return 0;
  }
}

uint64_t ccder_encode_implicit_integer(unint64_t a1, unint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  if (!a5) {
    return 0;
  }
  uint64_t v6 = a4;
  uint64_t v7 = a5;
  if (ccder_blob_encode_implicit_integer(&v6, a1, a2, a3)) {
    return v7;
  }
  else {
    return 0;
  }
}

uint64_t ccder_encode_integer(unint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (!a4) {
    return 0;
  }
  uint64_t v5 = a3;
  uint64_t v6 = a4;
  if (ccder_blob_encode_integer(&v5, a1, a2)) {
    return v6;
  }
  else {
    return 0;
  }
}

uint64_t ccder_encode_implicit_uint64(unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a4) {
    return 0;
  }
  uint64_t v5 = a3;
  uint64_t v6 = a4;
  if (ccder_blob_encode_implicit_uint64(&v5, a1, a2)) {
    return v6;
  }
  else {
    return 0;
  }
}

uint64_t ccder_encode_uint64(unint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t v4 = a2;
  uint64_t v5 = a3;
  if (ccder_blob_encode_uint64(&v4, a1)) {
    return v5;
  }
  else {
    return 0;
  }
}

uint64_t ccder_encode_implicit_octet_string(unint64_t a1, unint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  if (!a5) {
    return 0;
  }
  uint64_t v6 = a4;
  uint64_t v7 = a5;
  if (ccder_blob_encode_implicit_octet_string(&v6, a1, a2, a3)) {
    return v7;
  }
  else {
    return 0;
  }
}

uint64_t ccder_encode_octet_string(unint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (!a4) {
    return 0;
  }
  uint64_t v5 = a3;
  uint64_t v6 = a4;
  if (ccder_blob_encode_octet_string(&v5, a1, a2)) {
    return v6;
  }
  else {
    return 0;
  }
}

uint64_t ccder_encode_implicit_raw_octet_string(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!a5) {
    return 0;
  }
  uint64_t v6 = a4;
  uint64_t v7 = a5;
  if (ccder_blob_encode_implicit_raw_octet_string(&v6, a1, a2, a3)) {
    return v7;
  }
  else {
    return 0;
  }
}

uint64_t ccder_encode_raw_octet_string(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a4) {
    return 0;
  }
  uint64_t v5 = a3;
  uint64_t v6 = a4;
  if (ccder_blob_encode_raw_octet_string((uint64_t)&v5, a1, a2)) {
    return v6;
  }
  else {
    return 0;
  }
}

uint64_t ccder_encode_eckey_internal(uint64_t a1, uint64_t a2, const void *a3, unint64_t a4, const void *a5, uint64_t a6, uint64_t a7)
{
  if (!a7) {
    return 0;
  }
  uint64_t v8 = a6;
  uint64_t v9 = a7;
  if (ccder_blob_encode_eckey_internal(&v8, a1, a2, a3, a4, a5)) {
    return v9;
  }
  else {
    return 0;
  }
}

uint64_t ccder_encode_eckey(uint64_t a1, uint64_t a2, const void *a3, unint64_t a4, const void *a5, uint64_t a6, uint64_t a7)
{
  BOOL v16 = timingsafe_enable_if_supported();
  if (a7)
  {
    uint64_t v17 = a6;
    uint64_t v18 = a7;
    if (ccder_blob_encode_eckey_internal(&v17, a1, a2, a3, a4, a5)) {
      uint64_t v14 = v18;
    }
    else {
      uint64_t v14 = 0;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v14;
}

uint64_t ccder_encode_body(unint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  if (!a4) {
    return 0;
  }
  uint64_t v5 = a3;
  uint64_t v6 = a4;
  if (ccder_blob_encode_body(&v5, a1, a2)) {
    return v6;
  }
  else {
    return 0;
  }
}

unsigned __int8 *ccder_decode_tag(unint64_t *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (!a2) {
    return 0;
  }
  v4[0] = a2;
  v4[1] = a3;
  if (ccder_blob_decode_tag(v4, a1)) {
    return v4[0];
  }
  else {
    return 0;
  }
}

unsigned __int8 *ccder_decode_len(unint64_t *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (!a2) {
    return 0;
  }
  v4[0] = a2;
  v4[1] = a3;
  if (ccder_blob_decode_len(v4, a1)) {
    return v4[0];
  }
  else {
    return 0;
  }
}

unsigned __int8 *ccder_decode_len_strict(unint64_t *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (!a2) {
    return 0;
  }
  v4[0] = a2;
  v4[1] = a3;
  if (ccder_blob_decode_len_strict(v4, a1)) {
    return v4[0];
  }
  else {
    return 0;
  }
}

unsigned __int8 *ccder_decode_tl(uint64_t a1, unint64_t *a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  if (!a3) {
    return 0;
  }
  v5[0] = a3;
  v5[1] = a4;
  if (ccder_blob_decode_tl(v5, a1, a2)) {
    return v5[0];
  }
  else {
    return 0;
  }
}

unsigned __int8 *ccder_decode_tl_strict(uint64_t a1, unint64_t *a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  if (!a3) {
    return 0;
  }
  v5[0] = a3;
  v5[1] = a4;
  if (ccder_blob_decode_tl_strict(v5, a1, a2)) {
    return v5[0];
  }
  else {
    return 0;
  }
}

unsigned __int8 *ccder_decode_constructed_tl(uint64_t a1, unsigned __int8 **a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  *a2 = a3;
  if (!a3) {
    return 0;
  }
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  v9[0] = a3;
  v9[1] = a4;
  int v5 = ccder_blob_decode_range(v9, a1, &v7);
  uint64_t result = 0;
  if (v5)
  {
    uint64_t result = v7;
    *a2 = v8;
  }
  return result;
}

unsigned __int8 *ccder_decode_constructed_tl_strict(uint64_t a1, unsigned __int8 **a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  *a2 = a3;
  if (!a3) {
    return 0;
  }
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  v9[0] = a3;
  v9[1] = a4;
  int v5 = ccder_blob_decode_range_strict(v9, a1, &v7);
  uint64_t result = 0;
  if (v5)
  {
    uint64_t result = v7;
    *a2 = v8;
  }
  return result;
}

unsigned __int8 *ccder_decode_sequence_tl(unsigned __int8 **a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  *a1 = a2;
  if (!a2) {
    return 0;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  v8[0] = a2;
  v8[1] = a3;
  int v4 = ccder_blob_decode_sequence_tl(v8, &v6);
  uint64_t result = 0;
  if (v4)
  {
    uint64_t result = v6;
    *a1 = v7;
  }
  return result;
}

unsigned __int8 *ccder_decode_sequence_tl_strict(unsigned __int8 **a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  *a1 = a2;
  if (!a2) {
    return 0;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  v8[0] = a2;
  v8[1] = a3;
  int v4 = ccder_blob_decode_sequence_tl_strict(v8, &v6);
  uint64_t result = 0;
  if (v4)
  {
    uint64_t result = v6;
    *a1 = v7;
  }
  return result;
}

unsigned __int8 *ccder_decode_uint_n(unint64_t *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (!a2) {
    return 0;
  }
  v4[0] = a2;
  v4[1] = a3;
  if (ccder_blob_decode_uint_n(v4, a1)) {
    return v4[0];
  }
  else {
    return 0;
  }
}

unsigned __int8 *ccder_decode_uint(unint64_t a1, void *a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  if (!a3) {
    return 0;
  }
  v5[0] = a3;
  v5[1] = a4;
  if (ccder_blob_decode_uint(v5, a1, a2)) {
    return v5[0];
  }
  else {
    return 0;
  }
}

unsigned __int8 *ccder_decode_uint_strict(unint64_t a1, void *a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  if (!a3) {
    return 0;
  }
  v5[0] = a3;
  v5[1] = a4;
  if (ccder_blob_decode_uint_strict(v5, a1, a2)) {
    return v5[0];
  }
  else {
    return 0;
  }
}

unsigned __int8 *ccder_decode_uint64(unint64_t *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (!a2) {
    return 0;
  }
  v4[0] = a2;
  v4[1] = a3;
  if (ccder_blob_decode_uint64(v4, a1)) {
    return v4[0];
  }
  else {
    return 0;
  }
}

unsigned __int8 *ccder_decode_seqii(unint64_t a1, void *a2, void *a3, unsigned __int8 *a4, unsigned __int8 *a5)
{
  if (!a4) {
    return 0;
  }
  v6[0] = a4;
  v6[1] = a5;
  if (ccder_blob_decode_seqii(v6, a1, a2, a3)) {
    return v6[0];
  }
  else {
    return 0;
  }
}

unsigned __int8 *ccder_decode_seqii_strict(unint64_t a1, void *a2, void *a3, unsigned __int8 *a4, unsigned __int8 *a5)
{
  if (!a4) {
    return 0;
  }
  v6[0] = a4;
  v6[1] = a5;
  if (ccder_blob_decode_seqii_strict(v6, a1, a2, a3)) {
    return v6[0];
  }
  else {
    return 0;
  }
}

unsigned __int8 *ccder_decode_oid(unsigned __int8 **a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  *a1 = 0;
  if (!a2) {
    return 0;
  }
  v4[0] = a2;
  v4[1] = a3;
  if (ccder_blob_decode_oid(v4, a1)) {
    return v4[0];
  }
  else {
    return 0;
  }
}

unsigned __int8 *ccder_decode_bitstring(void *a1, unint64_t *a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  if (!a3) {
    return 0;
  }
  v7[0] = 0;
  v7[1] = 0;
  v8[0] = a3;
  v8[1] = a4;
  if (ccder_blob_decode_bitstring(v8, (uint64_t)v7, a2))
  {
    *a1 = v7[0];
    return v8[0];
  }
  else
  {
    uint64_t result = 0;
    *a2 = 0;
    *a1 = 0;
  }
  return result;
}

unsigned __int8 *ccder_decode_eckey_internal(unint64_t *a1, void *a2, void *a3, unsigned __int8 **a4, unint64_t *a5, void *a6, unsigned __int8 *a7, unsigned __int8 *a8)
{
  v10[0] = a7;
  v10[1] = a8;
  uint64_t v9 = 0;
  if (ccder_blob_decode_eckey_internal(v10, a1, a2, a3, a4, &v9, a6, a5)) {
    return v10[0];
  }
  else {
    return 0;
  }
}

unsigned __int8 *ccder_decode_eckey(unint64_t *a1, void *a2, void *a3, unsigned __int8 **a4, unint64_t *a5, void *a6, unsigned __int8 *a7, unsigned __int8 *a8)
{
  BOOL v18 = timingsafe_enable_if_supported();
  v20[0] = a7;
  v20[1] = a8;
  uint64_t v19 = 0;
  if (ccder_blob_decode_eckey_internal(v20, a1, a2, a3, a4, &v19, a6, a5)) {
    BOOL v16 = v20[0];
  }
  else {
    BOOL v16 = 0;
  }
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return v16;
}

uint64_t ccshake_init(rsize_t *a1, void *a2)
{
  return cc_clear(*a1, a2);
}

uint64_t ccshake128(unint64_t a1, char *a2, size_t a3, char *a4)
{
  __dst[48] = *MEMORY[0x263EF8C08];
  uint64_t v8 = ccshake128_xi();
  ccxof_init((uint64_t)v8, __dst);
  ccxof_absorb(v8, (char *)__dst, a1, a2);
  ccxof_squeeze(v8, (unsigned int *)__dst, a3, a4);
  return cc_clear(0x178uLL, __dst);
}

uint64_t ccshake256(unint64_t a1, char *a2, size_t a3, char *a4)
{
  __dst[44] = *MEMORY[0x263EF8C08];
  uint64_t v8 = ccshake256_xi();
  ccxof_init((uint64_t)v8, __dst);
  ccxof_absorb(v8, (char *)__dst, a1, a2);
  ccxof_squeeze(v8, (unsigned int *)__dst, a3, a4);
  return cc_clear(0x158uLL, __dst);
}

void *cckem_kyber768()
{
  return &cckem_kyber768_info;
}

uint64_t cckem_kyber768_generate_key(uint64_t a1, uint64_t (**a2)(void, uint64_t, char *))
{
  int v4 = (void *)(cckem_public_ctx() + 8);
  uint64_t v5 = a1 + *(void *)(*(void *)a1 + 8) + 8;

  return cckyber_kem_keypair(cckyber768_params, v4, v5, a2);
}

uint64_t cckem_kyber768_derive_key_from_seed(uint64_t a1, unint64_t a2, char *a3, uint64_t (**a4)(void, uint64_t, _OWORD *))
{
  uint64_t v13 = *MEMORY[0x263EF8C08];
  if (a2 < 0x20) {
    return 4294967289;
  }
  uint64_t v7 = cckem_public_ctx();
  uint64_t v8 = *(void *)(*(void *)a1 + 8);
  uint64_t v9 = (*a4)(a4, 32, __s);
  if (!v9) {
    uint64_t v9 = cckyber_kem_keypair_coins(cckyber768_params, (void *)(v7 + 8), a1 + v8 + 8, a3, __s);
  }
  uint64_t v10 = v9;
  cc_clear(0x20uLL, __s);
  return v10;
}

uint64_t cckem_kyber768_encapsulate(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t (**a4)(void, uint64_t, long long *))
{
  return cckyber_kem_encapsulate(cckyber768_params, (char *)(a1 + 8), a2, a3, a4);
}

uint64_t cckem_kyber768_decapsulate(uint64_t a1, char *a2, char *a3)
{
  return cckyber_kem_decapsulate(cckyber768_params, a1 + *(void *)(*(void *)a1 + 8) + 8, a2, a3);
}

uint64_t cckem_kyber768_export_pubkey(uint64_t a1, unint64_t *a2, void *a3)
{
  unint64_t v6 = *a2;
  if (v6 < cckem_pubkey_nbytes_ctx(a1)) {
    return 4294967289;
  }
  size_t v7 = cckem_pubkey_nbytes_ctx(a1);
  *a2 = v7;
  memcpy(a3, (const void *)(a1 + 8), v7);
  return 0;
}

uint64_t cckem_kyber768_import_pubkey(uint64_t a1, size_t a2, const void *a3, void *a4)
{
  if (cckem_pubkey_nbytes_info(a1) != a2) {
    return 4294967289;
  }
  cckem_pub_ctx_init(a4, a1);
  memcpy(a4 + 1, a3, a2);
  return 0;
}

uint64_t cckem_kyber768_export_privkey(uint64_t a1, unint64_t *a2, void *a3)
{
  unint64_t v6 = *a2;
  uint64_t v7 = ((uint64_t (*)(void))cckem_public_ctx)();
  if (v6 < cckem_privkey_nbytes_ctx(v7)) {
    return 4294967289;
  }
  uint64_t v8 = cckem_public_ctx(a1);
  size_t v9 = cckem_privkey_nbytes_ctx(v8);
  *a2 = v9;
  memcpy(a3, (const void *)(a1 + *(void *)(*(void *)a1 + 8) + 8), v9);
  return 0;
}

uint64_t cckem_kyber768_import_privkey(void *a1, size_t a2, const void *a3, void *a4)
{
  if (cckem_privkey_nbytes_info(a1) != a2) {
    return 4294967289;
  }
  cckem_full_ctx_init(a4, a1);
  memcpy((char *)a4 + *(void *)(*a4 + 8) + 8, a3, a2);
  return 0;
}

void cc_abort()
{
}

void *ccdh_gp_rfc3526group16()
{
  return &_ccdh_gp_rfc3526group16;
}

unsigned __int8 *ccder_decode_rsa_pub_x509(unint64_t *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  size_t v9 = a3;
  int v4 = ccder_decode_constructed_tl(0x2000000000000010, &v9, a2, a3);
  uint64_t v10 = 0;
  size_t v11 = v9;
  uint64_t v5 = ccder_decode_constructed_tl(0x2000000000000010, &v11, v4, v9);
  if (v5)
  {
    unint64_t v6 = ccder_decode_oid(&v10, v5, v11);
    if (v6) {
      unint64_t v6 = ccder_decode_constructed_tl(5, &v11, v6, v11);
    }
  }
  else
  {
    unint64_t v6 = 0;
  }
  size_t v11 = v9;
  uint64_t result = ccder_decode_constructed_tl(3, &v11, v6, v9);
  if (result)
  {
    uint64_t v8 = result;
    if (result < v11 && !*result) {
      uint64_t v8 = result + 1;
    }
    return ccder_decode_rsa_pub(a1, v8, v11);
  }
  return result;
}

BOOL ccder_blob_encode_body(void *a1, unint64_t a2, const void *a3)
{
  if (!a3) {
    return a2 == 0;
  }
  __dst[0] = 0;
  __dst[1] = 0;
  BOOL v5 = ccder_blob_reserve(a1, a2, __dst);
  if (v5) {
    memmove(__dst[0], a3, a2);
  }
  return v5;
}

uint64_t cczp_sqr_default_ws(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v7 = *(void *)(a1 + 16);
  unint64_t v8 = cczp_n(a2);
  size_t v9 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 2 * v8);
  ccn_sqr_ws(a1, v8, v9, a4);
  uint64_t result = cczp_mod_ws(a1, a2);
  *(void *)(a1 + 16) = v7;
  return result;
}

uint64_t cczp_sqr_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 24))();
}

void *ccsrp_gp_rfc5054_8192()
{
  return &_ccsrp_gp_rfc5054_8192;
}

uint64_t ccmode_ccm_decrypt(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  int v9 = *(_DWORD *)(a2 + 64);
  if (v9 == 5)
  {
    BOOL v10 = 0;
LABEL_5:
    ccmode_ccm_crypt(a1, a2, a3, a4, a5);
    ccmode_ccm_macdata(a1, a2, v10, a3, a5);
    return 0;
  }
  if (v9 == 4)
  {
    BOOL v10 = *(_DWORD *)(a2 + 72) != 0;
    *(_DWORD *)(a2 + 64) = 5;
    goto LABEL_5;
  }
  return 4294967228;
}

uint64_t ccz_write_radix_size(uint64_t a1, int a2)
{
  BOOL v9 = timingsafe_enable_if_supported();
  uint64_t v4 = ccz_n(a1);
  unsigned int v5 = ccz_sign(a1);
  if (a2 == 16 || a2 == 10)
  {
    if (ccz_is_zero(a1))
    {
      uint64_t v6 = 1;
    }
    else
    {
      uint64_t v7 = v5 >> 31;
      if (a2 == 16) {
        uint64_t v6 = v7 + ((unint64_t)(ccn_bitlen_internal(v4, *(void *)(a1 + 24)) + 3) >> 2);
      }
      else {
        uint64_t v6 = ccz_write_radix_10(a1, 0, 0) + v7;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  cc_disable_dit_with_sb((unsigned int *)&v9);
  return v6;
}

uint64_t ccz_write_radix_10(uint64_t a1, uint64_t a2, char *a3)
{
  long long v17 = 0u;
  long long v18 = 0u;
  ccz_init(*(void *)(a1 + 8), (uint64_t)&v17);
  ccz_set((uint64_t)&v17, a1);
  unint64_t v6 = ccz_n((uint64_t)&v17);
  unint64_t v7 = ccn_n(v6, *((uint64_t *)&v18 + 1));
  ccz_set_n(&v17, v7);
  unint64_t v8 = &a3[a2];
  for (uint64_t i = 0; !ccz_is_zero((uint64_t)&v17); ++i)
  {
    if (v8 && v8 <= a3) {
      break;
    }
    if ((ccz_cmpi((uint64_t)&v17, 0xAu) & 0x80000000) != 0)
    {
      uint64_t v16 = **((void **)&v18 + 1);
      ccz_zero(&v17);
      if (!v8) {
        continue;
      }
    }
    else
    {
      long long v20 = 0u;
      long long v21 = 0u;
      memset(v19, 0, sizeof(v19));
      ccz_init(*((uint64_t *)&v17 + 1), (uint64_t)&v20);
      ccz_init(*((uint64_t *)&v17 + 1), (uint64_t)v19);
      unint64_t v11 = ccz_bitlen(&v17) - 4;
      ccz_set((uint64_t)&v20, (uint64_t)&v17);
      ccz_zero(&v17);
      ccz_seti((uint64_t)v19, 10);
      ccz_lsl((uint64_t)v19, (uint64_t)v19, v11);
      unint64_t v12 = 0;
      unint64_t v13 = v11;
      do
      {
        if ((ccz_cmp((uint64_t)&v20, (uint64_t)v19) & 0x80000000) == 0)
        {
          ccz_sub(&v20, (uint64_t)&v20, (uint64_t)v19);
          ccz_set_bit(&v17, v13, 1u);
        }
        ccz_lsr(v19, (uint64_t)v19, 1uLL);
        ++v12;
        --v13;
      }
      while (v12 <= v11);
      unint64_t v14 = ccz_n((uint64_t)&v17);
      unint64_t v15 = ccn_n(v14, *((uint64_t *)&v18 + 1));
      ccz_set_n(&v17, v15);
      uint64_t v16 = **((void **)&v21 + 1);
      ccz_free((uint64_t)&v20);
      ccz_free((uint64_t)v19);
      if (!v8) {
        continue;
      }
    }
    *--unint64_t v8 = DIGITS[v16];
  }
  if (v8 > a3) {
    memset(a3, 48, a2 - i);
  }
  ccz_free((uint64_t)&v17);
  return i;
}

uint64_t ccz_write_radix(uint64_t a1, uint64_t a2, char *a3, int a4)
{
  BOOL v18 = timingsafe_enable_if_supported();
  if (a4 != 16 && a4 != 10)
  {
    uint64_t v8 = 4294967251;
    goto LABEL_20;
  }
  if (!a2) {
    goto LABEL_7;
  }
  if (!ccz_is_zero(a1) && (ccz_sign(a1) & 0x80000000) != 0)
  {
    if ((unint64_t)a2 < 2)
    {
LABEL_7:
      uint64_t v8 = 4294967289;
      goto LABEL_20;
    }
    *a3++ = 45;
    --a2;
  }
  if (a4 == 10)
  {
    ccz_write_radix_10(a1, a2, a3);
  }
  else
  {
    uint64_t v9 = ccz_n(a1);
    unint64_t v10 = ccn_bitlen_internal(v9, *(void *)(a1 + 24)) + 3;
    unint64_t v11 = v10 >> 2;
    if (a2 >= 1 && v10 >= 4)
    {
      char v12 = 0;
      unint64_t v13 = (unint64_t)&a3[a2 - 1];
      unint64_t v14 = 1;
      unint64_t v15 = (unsigned char *)v13;
      do
      {
        *v15-- = DIGITS[(*(void *)(*(void *)(a1 + 24) + (((v14 - 1) >> 1) & 0x7FFFFFFFFFFFFFF8)) >> (v12 & 0x3C)) & 0xFLL];
        if (v14 >= v11) {
          break;
        }
        ++v14;
        v12 += 4;
        BOOL v16 = v13 > (unint64_t)a3;
        unint64_t v13 = (unint64_t)v15;
      }
      while (v16);
    }
    if (a2 > v11) {
      memset(a3, 48, a2 - v11);
    }
  }
  uint64_t v8 = 0;
LABEL_20:
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return v8;
}

uint64_t ccascon_cmac_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(a2, a3, a4, a5, a6);
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v12;
}

uint64_t ccascon_cmac_process(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 32))(a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccascon_cmac_tag(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 40))(a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccascon_cmac_verify(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 48))(a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccascon_cmac_ref_process(unint64_t *a1, unint64_t a2, unint64_t *a3)
{
  return 0;
}

uint64_t ccascon_cmac_ref_tag(_OWORD *a1, uint64_t a2, unint64_t *a3)
{
  long long v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  void v7[2] = a1[2];
  ccascon_ascon128a_ref_pad((uint64_t)v7);
  ccascon_ascon128a_ref_finalize((unint64_t *)v7, a2, a3);
  cc_clear(0x30uLL, v7);
  return 0;
}

uint64_t ccascon_cmac_ref_verify(_OWORD *a1, uint64_t a2, char *a3, unint64_t *a4)
{
  uint64_t v12 = *MEMORY[0x263EF8C08];
  long long v7 = a1[1];
  v10[0] = *a1;
  v10[1] = v7;
  void v10[2] = a1[2];
  ccascon_ascon128a_ref_pad((uint64_t)v10);
  ccascon_ascon128a_ref_finalize((unint64_t *)v10, (uint64_t)__s, a4);
  if (cc_cmp_safe_internal(a2, a3, __s)) {
    uint64_t v8 = 4294967294;
  }
  else {
    uint64_t v8 = 0;
  }
  cc_clear(0x30uLL, v10);
  cc_clear(0x10uLL, __s);
  return v8;
}

void *ccascon_ascon128a_cmac()
{
  return &ccascon_ascon128a_cmac_ref;
}

uint64_t ccec_generate_key_fips_ws(uint64_t a1, unint64_t *a2, uint64_t (**a3)(void, uint64_t, unint64_t *), unint64_t **a4)
{
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t result = ccec_generate_key_internal_fips_ws(a1, a2, a3, a4);
  if (!result)
  {
    if (ccec_pairwise_consistency_check_ws(a1, a4, (uint64_t (**)(void, unint64_t, void *))a3))uint64_t result = 4294967278; {
    else
    }
      uint64_t result = 0;
  }
  *(void *)(a1 + 16) = v7;
  return result;
}

uint64_t ccec_generate_key_fips(unint64_t *a1, uint64_t (**a2)(void, uint64_t, unint64_t *), unint64_t **a3)
{
  BOOL v12 = timingsafe_enable_if_supported();
  unint64_t v6 = cc_malloc_clear(392 * *a1);
  uint64_t v7 = 49 * *a1;
  v10[0] = v6;
  v10[1] = v7;
  void v10[2] = 0;
  _OWORD v10[3] = cc_ws_alloc;
  unint64_t v11 = cc_ws_free;
  if (v6)
  {
    key_fips_uint64_t ws = ccec_generate_key_fips_ws((uint64_t)v10, a1, a2, a3);
    cc_try_abort_if (key_fips_ws == -18);
    v11((uint64_t)v10);
  }
  else
  {
    key_fips_uint64_t ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return key_fips_ws;
}

uint64_t cc_log_default()
{
  if (cc_log_default_initp != -1) {
    _os_once();
  }
  return cc_log_default_log;
}

os_log_t cc_log_init(os_log_t *a1)
{
  os_log_t result = os_log_create("com.apple.corecrypto", "default");
  *a1 = result;
  return result;
}

uint64_t ccsae_init_p384_sha384(void *a1, uint64_t a2)
{
  uint64_t v4 = ccec_cp_384();
  long long v5 = ccsha384_di();
  ccsae_init(a1, v4, a2, (uint64_t)v5);
  return 0;
}

uint64_t ccsae_init(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  rsize_t v8 = ccsae_sizeof_ctx(a2);
  cc_clear(v8, a1);
  *a1 = a2;
  a1[1] = a3;
  a1[2] = a4;
  *((_DWORD *)a1 + 7) = 0;
  *((unsigned char *)a1 + 24) = CCSAE_STATE_INIT;
  *((unsigned char *)a1 + 25) = 40;
  uint64_t v9 = SAE_HUNT_PECK_LABEL;
  a1[4] = SAE_KCK_PMK_LABEL[0];
  a1[5] = v9;
  return 0;
}

uint64_t ccsae_init_p256_sha256(void *a1, uint64_t a2)
{
  uint64_t v4 = ccec_cp_256();
  long long v5 = ccsha256_di();
  ccsae_init(a1, v4, a2, (uint64_t)v5);
  return 0;
}

uint64_t cch2c_map_to_curve_sswu_ws(uint64_t a1, uint64_t a2, int *a3, uint64_t *a4)
{
  uint64_t v7 = (void *)(*(uint64_t (**)(void))(a2 + 16))();
  uint64_t v8 = cczp_n((uint64_t)v7);
  *a4 = (uint64_t)v7;
  a4 += 2;
  uint64_t v9 = &a4[*v7];
  uint64_t v10 = &a4[2 * *v7];
  uint64_t v18 = *(void *)(a1 + 16);
  unint64_t v11 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8);
  BOOL v12 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8);
  unint64_t v15 = v8;
  BOOL v16 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8);
  int v17 = *a3;
  ccn_seti(v8, v10, *(unsigned int *)(a2 + 12));
  cczp_to_ws(a1, (uint64_t)v7);
  cczp_inv_ws(a1, (uint64_t)v7);
  cczp_negate((uint64_t)v7, v10, (unint64_t *)v10);
  ccn_seti(v8, v9, 3);
  cczp_to_ws(a1, (uint64_t)v7);
  cczp_inv_ws(a1, (uint64_t)v7);
  cczp_mul_ws(a1, (uint64_t)v7);
  cczp_negate((uint64_t)v7, v9, (unint64_t *)v9);
  cczp_to_ws(a1, (uint64_t)v7);
  cczp_sqr_ws(a1, (uint64_t)v7);
  cczp_mul_ws(a1, (uint64_t)v7);
  cczp_sqr_ws(a1, (uint64_t)v7);
  cczp_add_ws(a1, (uint64_t)v7);
  uint64_t v20 = *(void *)(a1 + 16);
  uint64_t v13 = cczp_n((uint64_t)v7);
  LOBYTE(v8) = ccn_n(v13, (uint64_t)v12) == 0;
  cczp_inv_ws(a1, (uint64_t)v7);
  ccn_cond_clear(v13, v8, v12);
  *(void *)(a1 + 16) = v20;
  LOBYTE(v8) = ccn_n(v15, (uint64_t)v12) == 0;
  ccn_seti(v15, a4, 1);
  cczp_to_ws(a1, (uint64_t)v7);
  cczp_add_ws(a1, (uint64_t)v7);
  ccn_mux(v15, v8, v12, v16, v12);
  cczp_mul_ws(a1, (uint64_t)v7);
  cczp_sqr_ws(a1, (uint64_t)v7);
  cczp_add_ws(a1, (uint64_t)v7);
  cczp_mul_ws(a1, (uint64_t)v7);
  cczp_add_ws(a1, (uint64_t)v7);
  cczp_mul_ws(a1, (uint64_t)v7);
  cczp_mul_ws(a1, (uint64_t)v7);
  cczp_mul_ws(a1, (uint64_t)v7);
  LOBYTE(v8) = cczp_is_quadratic_residue_ws(a1, (uint64_t)v7, v11);
  ccn_mux(v15, v8, a4, v12, a4);
  cczp_from_ws(a1, (uint64_t)v7);
  ccn_mux(v15, v8, v10, (uint64_t *)v11, v10);
  cczp_sqrt_ws(a1, (uint64_t)v7);
  cczp_from_ws(a1, (uint64_t)v7);
  cczp_cond_negate((uint64_t)v7, (*v9 ^ v17) & 1, v9, (unint64_t *)v9);
  ccn_seti(v15, v10, 1);
  *(void *)(a1 + 16) = v18;
  return 0;
}

uint64_t map_to_curve_sswu(uint64_t a1, int *a2, uint64_t *a3)
{
  BOOL v11 = timingsafe_enable_if_supported();
  unint64_t v6 = (void *)(*(uint64_t (**)(void))(a1 + 16))();
  v9[0] = cc_malloc_clear(144 * *v6);
  v9[1] = 18 * *v6;
  void v9[2] = 0;
  void v9[3] = cc_ws_alloc;
  uint64_t v10 = cc_ws_free;
  if (v9[0])
  {
    cch2c_map_to_curve_sswu_ws((uint64_t)v9, a1, a2, a3);
    v10((uint64_t)v9);
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v7 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v11);
  return v7;
}

uint64_t cch2c_map_to_curve_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

uint64_t fipspost_post_drbg_ctr(char a1)
{
  uint64_t v15 = *MEMORY[0x263EF8C08];
  if ((a1 & 0x10) != 0) {
    uint64_t v1 = "\x01tz\xE6\x1F\x3D\xB31R\x9A\x13\xC3\x6D\xC6\xEB\xD2\xEF";
  }
  else {
    uint64_t v1 = "tz\xE6\x1F\x3D\xB31R\x9A\x13\xC3\x6D\xC6\xEB\xD2\xEF";
  }
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v10 = ccaes_ctr_crypt_mode();
  long long v11 = xmmword_2373BA850;
  DWORD2(v11) = 0;
  BOOL v12 = fipspost_post_drbg_ctr_df_ctx;
  ccdrbg_factory_nistctr(fipspost_post_drbg_ctr_info, (uint64_t)&v10);
  v8[0] = cc_malloc_clear((fipspost_post_drbg_ctr_info[0] + 7) & 0xFFFFFFFFFFFFFFF8);
  v8[1] = (unint64_t)(fipspost_post_drbg_ctr_info[0] + 7) >> 3;
  void v8[2] = 0;
  v8[3] = cc_ws_alloc;
  uint64_t v9 = cc_ws_free;
  if (v8[0])
  {
    uint64_t v2 = cc_ws_alloc(v8, (unint64_t)(fipspost_post_drbg_ctr_info[0] + 7) >> 3);
    uint64_t v3 = ccaes_cbc_encrypt_mode();
    if (ccdrbg_df_bc_init(fipspost_post_drbg_ctr_df_ctx, v3, 0x10uLL))
    {
      mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccdrbg_df_bc_init\n");
    }
    else if (ccdrbg_init((uint64_t)fipspost_post_drbg_ctr_info, v2, 16, (uint64_t)v1, 8, (uint64_t)"\xFF\xBD\xDC\xDF\x7F\xDD\xCE\xA4", 16, (uint64_t)"\xBD\x93\xC6\xD5k\a{\xF3\xCA\x13\x0C\xC3\xEF\xBF\xC7\x10"))
    {
      mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccdrbg_init\n");
    }
    else if (ccdrbg_reseed((uint64_t)fipspost_post_drbg_ctr_info, v2, 16, (uint64_t)"4\x83.\xC3\x2B\x10Xr\xB0\xB6\x89\xA8\xDA\xE2", 16, (uint64_t)"\xC8\xDB\xD7\xEF\x1A \v\x13g\x1A\xE2\x83.\xC3\x2B\x10Xr\xB0\xB6\x89\xA8\xDA\xE2"))
    {
      mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccdrbg_reseed\n");
    }
    else if (ccdrbg_generate((uint64_t)fipspost_post_drbg_ctr_info, v2, 16, (uint64_t)&v13, 0, 0))
    {
      mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccdrbg_generate\n");
    }
    else if (ccdrbg_reseed((uint64_t)fipspost_post_drbg_ctr_info, v2, 16, (uint64_t)"\xBE\xE1\x92\xEF&#j\xF8)\xD0\xC7\xD8\x49\xB7", 16, (uint64_t)"\xD6\x45^\x98\xCD\x09\xD6\x65\x86\xE2\x63\x92m\xE6\xE1\x92\xEF&#j\xF8)\xD0\xC7\xD8\x49\xB7"))
    {
      mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccdrbg_reseed 2\n");
    }
    else
    {
      if (!ccdrbg_generate((uint64_t)fipspost_post_drbg_ctr_info, v2, 16, (uint64_t)&v13, 0, 0))
      {
        if (v13 == 0xED42DA4BEFDD5852 && v14 == 0x87B07451F1579E49)
        {
          uint64_t v4 = 0;
        }
        else
        {
          uint64_t v7 = mach_absolute_time();
          printf("FIPSPOST_USER [%llu] %s:%d: FAILED: memcmp\n", v7, "fipspost_post_drbg_ctr", 116);
          uint64_t v4 = 4294967221;
        }
        goto LABEL_19;
      }
      mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccdrbg_generate 2\n");
    }
    uint64_t v4 = 4294967224;
LABEL_19:
    v9((uint64_t)v8);
    return v4;
  }
  return 4294967283;
}

uint64_t ccz_bitlen(void *a1)
{
  BOOL v4 = timingsafe_enable_if_supported();
  uint64_t v2 = ccn_bitlen_internal(*a1, a1[3]);
  cc_disable_dit_with_sb((unsigned int *)&v4);
  return v2;
}

uint64_t ccn_add_ws(uint64_t a1, uint64_t a2, void *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t result = 0;
  if (a2)
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v8 = *a4++;
      uint64_t v7 = v8;
      uint64_t v10 = *a5++;
      uint64_t v9 = v10;
      BOOL v11 = __CFADD__(result, v7);
      uint64_t v12 = result + v7;
      if (v11) {
        uint64_t v6 = 1;
      }
      BOOL v11 = __CFADD__(v12, v9);
      uint64_t v13 = v12 + v9;
      if (v11) {
        uint64_t result = v6 + 1;
      }
      else {
        uint64_t result = v6;
      }
      *a3++ = v13;
      uint64_t v6 = 0;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t ccn_add(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  BOOL v20 = timingsafe_enable_if_supported();
  v18[0] = xmmword_26EA47A78;
  v18[1] = *(_OWORD *)algn_26EA47A88;
  uint64_t v19 = off_26EA47A98;
  uint64_t v8 = 0;
  if (a1)
  {
    uint64_t v9 = 0;
    do
    {
      uint64_t v11 = *a3++;
      uint64_t v10 = v11;
      uint64_t v13 = *a4++;
      uint64_t v12 = v13;
      BOOL v14 = __CFADD__(v8, v10);
      uint64_t v15 = v8 + v10;
      if (v14) {
        uint64_t v9 = 1;
      }
      BOOL v14 = __CFADD__(v15, v12);
      uint64_t v16 = v15 + v12;
      if (v14) {
        uint64_t v8 = v9 + 1;
      }
      else {
        uint64_t v8 = v9;
      }
      *a2++ = v16;
      uint64_t v9 = 0;
      --a1;
    }
    while (a1);
  }
  cc_ws_free_null(v18);
  cc_disable_dit_with_sb((unsigned int *)&v20);
  return v8;
}

unint64_t ccn_cond_rsub(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t *a4, uint64_t *a5)
{
  uint64_t mask = ccn_mux_next_mask();
  uint64_t v11 = __ROR8__(0x5555555555555555, a2 | (2 * mask));
  if (a1)
  {
    uint64_t v12 = 0;
    do
    {
      unint64_t v14 = *a4++;
      unint64_t v13 = v14;
      uint64_t v15 = *a5++;
      unsigned long long v16 = __PAIR128__(v12, v12) - v13;
      uint64_t v17 = v16 + v15;
      if (__CFADD__((void)v16, v15)) {
        uint64_t v18 = *((void *)&v16 + 1) + 1;
      }
      else {
        uint64_t v18 = (__PAIR128__(v12, v12) - v13) >> 64;
      }
      uint64_t v12 = v18 >> 63;
      uint64_t v19 = v13 ^ v17;
      uint64_t v20 = v13 ^ mask;
      *a3 = v20;
      *a3++ = v19 & v11 ^ v19 & 0x5555555555555555 ^ v20 ^ mask;
      --a1;
    }
    while (a1);
    unint64_t v21 = (unint64_t)v18 >> 63;
  }
  else
  {
    unint64_t v21 = 0;
  }
  return v21 & a2;
}

uint64_t ltc_des3_ecb_decrypt(uint64_t a1, uint64_t a2, unsigned int *a3, _DWORD *a4)
{
  uint64_t v14 = *MEMORY[0x263EF8C08];
  if (a2)
  {
    uint64_t v6 = a2;
    uint64_t v7 = a1 + 384;
    do
    {
      --v6;
      unsigned int v8 = *a3;
      unsigned int v9 = a3[1];
      a3 += 2;
      unsigned int v12 = bswap32(v8);
      unsigned int v13 = bswap32(v9);
      desfunc3(&v12, v7);
      unsigned int v10 = bswap32(v13);
      *a4 = bswap32(v12);
      a4[1] = v10;
      a4 += 2;
    }
    while (v6);
  }
  return 0;
}

uint64_t cccbc_context_size(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t cccbc_block_size(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t cccbc_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 16))(a1, a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t cccbc_copy_iv(void *a1, const void *a2, size_t a3)
{
  BOOL v7 = timingsafe_enable_if_supported();
  memcpy(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return 0;
}

uint64_t cccbc_clear_iv(void *a1, rsize_t a2)
{
  BOOL v5 = timingsafe_enable_if_supported();
  cc_clear(a2, a1);
  cc_disable_dit_with_sb((unsigned int *)&v5);
  return 0;
}

uint64_t cccbc_set_iv_internal(uint64_t a1, void *__dst, void *__src)
{
  if (__src) {
    memcpy(__dst, __src, *(void *)(a1 + 8));
  }
  else {
    cc_clear(*(void *)(a1 + 8), __dst);
  }
  return 0;
}

uint64_t cccbc_set_iv(uint64_t a1, void *a2, void *a3)
{
  BOOL v7 = timingsafe_enable_if_supported();
  cccbc_set_iv_internal(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return 0;
}

uint64_t cccbc_update_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(a2, a3, a4, a5, a6);
}

uint64_t cccbc_update(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(a2, a3, a4, a5, a6);
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v12;
}

uint64_t cccbc_one_shot(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  BOOL v17 = timingsafe_enable_if_supported();
  if (a4) {
    uint64_t v14 = *(void *)(a1 + 8);
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = cccbc_one_shot_explicit_internal(a1, a2, v14, *(void *)(a1 + 8), a5, a3, a4, a6, a7);
  cc_disable_dit_with_sb((unsigned int *)&v17);
  return v15;
}

uint64_t cccbc_one_shot_explicit_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const void *a7, uint64_t a8, uint64_t a9)
{
  v26[1] = *MEMORY[0x263EF8C08];
  if (*(void *)(a1 + 8) != a4 || a3 && a3 != a4) {
    return 4294967289;
  }
  uint64_t v14 = MEMORY[0x270FA53B0](a1, a2, a3, a4);
  unsigned long long v16 = (char *)v26 - v15;
  MEMORY[0x270FA53B0](v14, v17, v18, v19);
  unint64_t v21 = (char *)v26 - v20;
  uint64_t v24 = (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(a1 + 16))(a1, v16, v23, v22);
  if (v24) {
    return v24;
  }
  if (a7) {
    memcpy(v21, a7, *(void *)(a1 + 8));
  }
  else {
    cc_clear(*(void *)(a1 + 8), v21);
  }
  uint64_t v13 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t, uint64_t))(a1 + 24))(v16, v21, a5, a8, a9);
  cc_clear(*(void *)a1, v16);
  return v13;
}

uint64_t cccbc_one_shot_explicit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const void *a7, uint64_t a8, uint64_t a9)
{
  BOOL v19 = timingsafe_enable_if_supported();
  uint64_t v17 = cccbc_one_shot_explicit_internal(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  cc_disable_dit_with_sb((unsigned int *)&v19);
  return v17;
}

void *ccdh_gp_rfc5114_MODP_1024_160()
{
  return &_ccdh_gp_rfc5114_MODP_1024_160;
}

uint64_t ccec_verify_composite_digest_ws(uint64_t a1, uint64_t *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  uint64_t v22 = *MEMORY[0x263EF8C08];
  if (a7)
  {
    *a7 = 0;
    a7[1] = 0;
  }
  long long v21 = 0uLL;
  uint64_t v13 = *(void *)*a2;
  uint64_t v14 = *(void *)(a1 + 16);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v13);
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v13);
  unint64_t v17 = ccec_signature_r_s_size(a2);
  if (ccn_read_uint_internal(v13, v15, v17, a5)
    || (unint64_t v18 = ccec_signature_r_s_size(a2), ccn_read_uint_internal(v13, v16, v18, a6)))
  {
    uint64_t result = 4294967289;
  }
  else
  {
    uint64_t result = ccec_verify_internal_ws(a1, (unint64_t **)a2, a3, a4, v15, v16, (uint64_t)&v21);
    if (a7 && !result) {
      *(_OWORD *)a7 = v21;
    }
  }
  *(void *)(a1 + 16) = v14;
  return result;
}

uint64_t ccec_verify_composite_digest(uint64_t *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  BOOL v16 = timingsafe_enable_if_supported();
  v14[0] = cc_malloc_clear(376 * *(void *)*a1);
  v14[1] = 47 * *(void *)*a1;
  unint64_t v14[2] = 0;
  uint64_t v14[3] = cc_ws_alloc;
  uint64_t v15 = cc_ws_free;
  if (v14[0])
  {
    uint64_t v12 = ccec_verify_composite_digest_ws((uint64_t)v14, a1, a2, a3, a4, a5, a6);
    v15((uint64_t)v14);
  }
  else
  {
    uint64_t v12 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v12;
}

uint64_t ccec_verify_composite_msg_ws(uint64_t a1, uint64_t *a2, unint64_t *a3, size_t a4, char *a5, uint64_t a6, uint64_t a7, void *a8)
{
  uint64_t v16 = *MEMORY[0x263EF8C08];
  ccdigest_internal((uint64_t)a3, a4, a5, (uint64_t)v15);
  return ccec_verify_composite_digest_ws(a1, a2, *a3, (uint64_t)v15, a6, a7, a8);
}

uint64_t ccec_verify_composite_msg(uint64_t *a1, unint64_t *a2, size_t a3, char *a4, uint64_t a5, uint64_t a6, void *a7)
{
  uint64_t v20 = *MEMORY[0x263EF8C08];
  BOOL v18 = timingsafe_enable_if_supported();
  v16[0] = cc_malloc_clear(376 * *(void *)*a1);
  v16[1] = 47 * *(void *)*a1;
  _OWORD v16[2] = 0;
  v16[3] = cc_ws_alloc;
  unint64_t v17 = cc_ws_free;
  if (v16[0])
  {
    ccdigest_internal((uint64_t)a2, a3, a4, (uint64_t)v19);
    uint64_t v14 = ccec_verify_composite_digest_ws((uint64_t)v16, a1, *a2, (uint64_t)v19, a5, a6, a7);
    v17((uint64_t)v16);
  }
  else
  {
    uint64_t v14 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return v14;
}

uint64_t ccec_verify_composite(uint64_t *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, BOOL *a6)
{
  BOOL v19 = timingsafe_enable_if_supported();
  *a6 = 0;
  v17[0] = cc_malloc_clear(376 * *(void *)*a1);
  v17[1] = 47 * *(void *)*a1;
  _OWORD v17[2] = 0;
  _OWORD v17[3] = cc_ws_alloc;
  BOOL v18 = cc_ws_free;
  if (v17[0])
  {
    unsigned int v12 = ccec_verify_composite_digest_ws((uint64_t)v17, a1, a2, a3, a4, a5, 0);
    v18((uint64_t)v17);
    if (v12 == -146) {
      unsigned int v13 = 0;
    }
    else {
      unsigned int v13 = v12;
    }
    BOOL v14 = v12 == 0;
    if (v12) {
      uint64_t v15 = v13;
    }
    else {
      uint64_t v15 = 0;
    }
    *a6 = v14;
  }
  else
  {
    uint64_t v15 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v19);
  return v15;
}

uint64_t ccec_diversify_priv_twin(uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t (**a5)(void, uint64_t, unint64_t *), unint64_t **a6)
{
  BOOL v30 = timingsafe_enable_if_supported();
  uint64_t v11 = *a1;
  unint64_t v12 = 26 * *a1;
  unint64_t v13 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v14 = (v13 + 127) / v13 + 4 * v11 + 3;
  if (v12 > v14) {
    unint64_t v14 = v12;
  }
  uint64_t v15 = cc_malloc_clear(8 * v14 + 16 * v11);
  v26[0] = v15;
  uint64_t v16 = *a1;
  unint64_t v17 = 26 * *a1;
  unint64_t v18 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v19 = (v18 + 127) / v18 + 4 * v16 + 3;
  if (v17 > v19) {
    unint64_t v19 = v17;
  }
  v26[1] = v19 + 2 * v16;
  uint64_t v27 = 0;
  unsigned int v28 = cc_ws_alloc;
  unint64_t v29 = cc_ws_free;
  if (v15)
  {
    uint64_t v20 = (char *)cc_ws_alloc(v26, v16);
    long long v21 = (char *)v28(v26, v16);
    pub_from_priv_uint64_t ws = ccec_diversify_twin_scalars_ws((uint64_t)v26, a1, v20, v21, a3, a4);
    if (!pub_from_priv_ws)
    {
      uint64_t v23 = (uint64_t)&a1[5 * *a1 + 4];
      uint64_t v24 = (uint64_t)&a6[3 * **a6 + 2];
      cczp_mul_ws((uint64_t)v26, v23);
      cczp_add_ws((uint64_t)v26, v23);
      pub_from_priv_uint64_t ws = ccec_make_pub_from_priv_ws((uint64_t)v26, (unint64_t *)a1, a5, v24, 0, a6);
    }
    uint64_t v27 = 0;
    v29((uint64_t)v26);
  }
  else
  {
    pub_from_priv_uint64_t ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v30);
  return pub_from_priv_ws;
}

uint64_t ccwrap_auth_encrypt(uint64_t a1, uint64_t a2, size_t a3, const void *a4, uint64_t *a5, void *a6)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v15 = 0xA6A6A6A6A6A6A6A6;
  uint64_t v12 = ccwrap_auth_encrypt_withiv_internal(a1, a2, a3, a4, a5, a6, &v15);
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v12;
}

uint64_t ccder_encode_rsa_priv_internal(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  v46[1] = *MEMORY[0x263EF8C08];
  BOOL v5 = a1 + 3;
  unint64_t v6 = *a1;
  uint64_t v45 = &a1[2 * *a1 + 4];
  v46[0] = 0;
  char v44 = &a1[3 * v6 + 4];
  uint64_t v43 = ccrsa_ctx_private_zp(a1);
  uint64_t v7 = ccrsa_ctx_private_zp(a1);
  uint64_t v8 = v7 + 16 * *(void *)ccrsa_ctx_private_zp(a1) + 32;
  uint64_t v9 = ccrsa_ctx_private_zp(a1);
  unint64_t v41 = cczp_n(v9);
  uint64_t v10 = ccrsa_ctx_private_zp(a1);
  uint64_t v11 = v10 + 16 * *(void *)ccrsa_ctx_private_zp(a1);
  uint64_t v12 = (unint64_t *)(v11 + 16 * *(void *)ccrsa_ctx_private_zp(a1) + 64);
  uint64_t v13 = ccrsa_ctx_private_zp(a1);
  BOOL v14 = (void *)ccrsa_ctx_private_zp(a1);
  unint64_t v15 = cczp_n(v13 + 16 * *v14 + 32);
  uint64_t v16 = ccrsa_ctx_private_zp(a1);
  uint64_t v17 = v16 + 16 * *(void *)ccrsa_ctx_private_zp(a1);
  uint64_t v18 = v17 + 16 * *(void *)ccrsa_ctx_private_zp(a1);
  unint64_t v19 = (unint64_t *)(v18 + 8 * *(void *)ccrsa_ctx_private_zp(a1) + 64);
  uint64_t v20 = ccrsa_ctx_private_zp(a1);
  unint64_t v21 = cczp_n(v20);
  uint64_t v22 = ccrsa_ctx_private_zp(a1);
  uint64_t v23 = v22 + 16 * *(void *)ccrsa_ctx_private_zp(a1);
  uint64_t v24 = v23 + 16 * *(void *)ccrsa_ctx_private_zp(a1);
  uint64_t v25 = v24 + 8 * *(void *)ccrsa_ctx_private_zp(a1);
  size_t v26 = (unint64_t *)(v25 + 8 * *(void *)ccrsa_ctx_private_zp(a1) + 64);
  uint64_t v27 = ccder_encode_integer(v21, v26, a2, a3);
  uint64_t v28 = ccder_encode_integer(v15, v19, a2, v27);
  uint64_t v29 = ccder_encode_integer(v41, v12, a2, v28);
  unint64_t v30 = cczp_n(v8);
  uint64_t v31 = (unint64_t *)cczp_prime(v8);
  uint64_t v32 = ccder_encode_integer(v30, v31, a2, v29);
  unint64_t v33 = cczp_n(v43);
  uint64_t v34 = (unint64_t *)cczp_prime(v43);
  uint64_t v35 = ccder_encode_integer(v33, v34, a2, v32);
  uint64_t v36 = ccder_encode_integer(v6, v44, a2, v35);
  uint64_t v37 = ccder_encode_integer(v6, v45, a2, v36);
  uint64_t v38 = ccder_encode_integer(v6, v5, a2, v37);
  uint64_t v39 = ccder_encode_integer(1uLL, v46, a2, v38);
  return ccder_encode_constructed_tl(0x2000000000000010uLL, a3, a2, v39);
}

uint64_t ccder_encode_rsa_priv(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t v6 = ccder_encode_rsa_priv_internal(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return v6;
}

uint64_t ccz_read_radix(uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4)
{
  BOOL v26 = timingsafe_enable_if_supported();
  if (a4 != 16 && a4 != 10)
  {
    uint64_t v10 = 4294967251;
    goto LABEL_38;
  }
  if (!a2)
  {
LABEL_10:
    uint64_t v10 = 4294967289;
    goto LABEL_38;
  }
  int v8 = *a3;
  if (v8 == 45)
  {
    int v9 = -1;
LABEL_9:
    if (--a2) {
      goto LABEL_12;
    }
    goto LABEL_10;
  }
  int v9 = 1;
  if (v8 == 43) {
    goto LABEL_9;
  }
  while (v8 == 48)
  {
    --a2;
LABEL_12:
    int v11 = *++a3;
    int v8 = v11;
  }
  unint64_t v12 = (unint64_t)(4 * a2 + 63) >> 6;
  ccz_set_capacity(a1, v12);
  ccz_set_n((void *)a1, v12);
  cc_clear(8 * v12, *(void **)(a1 + 24));
  ccz_set_sign(a1, v9);
  if (a4 == 10)
  {
    if (a2)
    {
      unint64_t v13 = 67;
      while (1)
      {
        int v14 = *a3;
        if ((v14 - 48) > 9) {
          break;
        }
        ++a3;
        ccn_mul1((v13 - 4) >> 6, *(void **)(a1 + 24), *(unint64_t **)(a1 + 24), 0xAuLL);
        ccn_add1_ws(0, v13 >> 6, *(void **)(a1 + 24), *(uint64_t **)(a1 + 24), (v14 - 48));
        v13 += 4;
        if (!--a2) {
          goto LABEL_19;
        }
      }
LABEL_37:
      uint64_t v10 = 4294967252;
      goto LABEL_38;
    }
LABEL_19:
    unint64_t v15 = ccz_n(a1);
    unint64_t v16 = ccn_n(v15, *(void *)(a1 + 24));
    ccz_set_n((void *)a1, v16);
  }
  else if (a2 >= 1)
  {
    uint64_t v17 = 0;
    unint64_t v18 = 0;
    unint64_t v19 = &a3[a2];
    do
    {
      int v21 = *--v19;
      unsigned __int8 v20 = v21;
      unsigned __int8 v22 = v21 & 0xDF;
      if ((v21 - 97) < 6) {
        unsigned __int8 v20 = v22;
      }
      if (v20 < 0x30u) {
        goto LABEL_37;
      }
      if (v20 > 0x46u || (v20 - 58) < 7u) {
        goto LABEL_37;
      }
      if (v20 >= 0x3Au) {
        char v24 = -55;
      }
      else {
        char v24 = -48;
      }
      *(void *)(*(void *)(a1 + 24) + ((v18++ >> 1) & 0x7FFFFFFFFFFFFFF8)) |= (unint64_t)(v24 + v20) << (v17 & 0x3C);
      v17 += 4;
    }
    while (v19 > a3);
  }
  if (ccz_is_zero(a1)) {
    ccz_set_sign(a1, 1);
  }
  uint64_t v10 = 0;
LABEL_38:
  cc_disable_dit_with_sb((unsigned int *)&v26);
  return v10;
}

uint64_t ccdes_cbc_cksum(unsigned int *a1, _DWORD *a2, unint64_t a3, uint64_t a4, uint64_t a5, unsigned int *a6)
{
  v23[1] = *MEMORY[0x263EF8C08];
  BOOL v20 = timingsafe_enable_if_supported();
  v23[0] = 0;
  if (ccdes_ltc_setup(0, __s, a5, a4))
  {
    v23[0] = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v12 = ccrng(0);
    if (v12) {
      ((void (*)(uint64_t *, uint64_t, void *))*v12)(v12, 8, v23);
    }
  }
  else
  {
    unsigned int v13 = bswap32(*a6);
    unsigned int v14 = bswap32(a6[1]);
    if (a3 >= 8)
    {
      do
      {
        unsigned int v15 = *a1;
        unsigned int v16 = a1[1];
        a1 += 2;
        LODWORD(v23[0]) = bswap32(v15) ^ v13;
        HIDWORD(v23[0]) = bswap32(v16) ^ v14;
        desfunc((unsigned int *)v23, (uint64_t)__s);
        unsigned int v13 = v23[0];
        unsigned int v14 = HIDWORD(v23[0]);
        a3 -= 8;
      }
      while (a3 > 7);
    }
    if (a3)
    {
      __memcpy_chk();
      cc_clear(8 - a3, (char *)v21 + a3);
      LODWORD(v23[0]) = bswap32(v21[0]) ^ v13;
      HIDWORD(v23[0]) = bswap32(v21[1]) ^ v14;
      desfunc((unsigned int *)v23, (uint64_t)__s);
    }
  }
  if (a2)
  {
    unsigned int v17 = bswap32(HIDWORD(v23[0]));
    *a2 = bswap32(v23[0]);
    a2[1] = v17;
  }
  LODWORD(v23[0]) = 0;
  cc_clear(0x100uLL, __s);
  uint64_t v18 = HIDWORD(v23[0]);
  cc_disable_dit_with_sb((unsigned int *)&v20);
  return v18;
}

uint64_t cczp_n(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t cczp_bitlen(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t ccz_read_uint(void *a1, uint64_t a2, uint64_t a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  ccz_set_sign((uint64_t)a1, 1);
  ccz_set_capacity((uint64_t)a1, (unint64_t)(a2 + 7) >> 3);
  ccn_read_uint_internal((unint64_t)(a2 + 7) >> 3, a1[3], a2, a3);
  unint64_t v6 = ccn_n((unint64_t)(a2 + 7) >> 3, a1[3]);
  ccz_set_n(a1, v6);
  return cc_disable_dit_with_sb((unsigned int *)&v8);
}

uint64_t cckyber_sample_ntt(unsigned int *a1, char *a2, char a3, uint64_t a4)
{
  *(void *)&v28[166] = *MEMORY[0x263EF8C08];
  BOOL v8 = ccshake128_xi();
  if (*a1)
  {
    int v9 = v8;
    unsigned int v10 = 0;
    int v11 = &v25[a3 & 1];
    do
    {
      unsigned int v12 = 0;
      do
      {
        ccxof_init((uint64_t)v9, __dst);
        ccxof_absorb(v9, (char *)__dst, 0x20uLL, a2);
        v25[0] = v12;
        v25[1] = v10;
        void v25[2] = v12;
        ccxof_absorb(v9, (char *)__dst, 2uLL, v11);
        for (unint64_t i = 0; i < 0x100; i += v15)
        {
          ccxof_squeeze(v9, __dst, 0xA8uLL, v27);
          unint64_t v14 = 0;
          unint64_t v15 = 0;
          unint64_t v16 = 256 - i;
          unsigned int v17 = *a1;
          uint64_t v18 = a4 + 2 * ((v12 + *a1 * v10) << 8) + 2 * i;
          unint64_t v19 = v28;
          do
          {
            unsigned int v20 = *(v19 - 1);
            unsigned int v21 = *(v19 - 2) | ((v20 & 0xF) << 8);
            int v22 = *v19;
            if (v21 <= 0xD00) {
              *(_WORD *)(v18 + 2 * v15++) = v21;
            }
            if (v15 < v16)
            {
              unsigned int v23 = (v20 >> 4) | (16 * v22);
              if (v23 <= 0xD00) {
                *(_WORD *)(v18 + 2 * v15++) = v23;
              }
            }
            if (v14 > 0x36) {
              break;
            }
            v19 += 3;
            ++v14;
          }
          while (v15 < v16);
        }
        ++v12;
      }
      while (v12 < v17);
      ++v10;
    }
    while (v10 < v17);
  }
  return cc_clear(0x178uLL, __dst);
}

uint64_t cckyber_sample_cbd_eta2(uint64_t result, uint64_t a2)
{
  uint64_t v2 = 0;
  int8x16_t v3 = (int8x16_t)vdupq_n_s64(2uLL);
  int64x2_t v4 = vdupq_n_s64(8uLL);
  v5.i64[0] = 0x3000300030003;
  v5.i64[1] = 0x3000300030003;
  do
  {
    uint64_t v6 = 0;
    uint64x2_t v7 = (uint64x2_t)vdupq_n_s64(((*(void *)(a2 + 8 * v2) >> 1) & 0x5555555555555555)+ (*(void *)(a2 + 8 * v2) & 0x5555555555555555uLL));
    int64x2_t v8 = (int64x2_t)xmmword_2373AF940;
    int64x2_t v9 = (int64x2_t)xmmword_2373BA880;
    int64x2_t v10 = (int64x2_t)xmmword_2373BA870;
    int64x2_t v11 = (int64x2_t)xmmword_2373BA860;
    do
    {
      int64x2_t v12 = vshlq_n_s64(v9, 2uLL);
      int64x2_t v13 = vshlq_n_s64(v8, 2uLL);
      int64x2_t v14 = vshlq_n_s64(v11, 2uLL);
      int64x2_t v15 = vshlq_n_s64(v10, 2uLL);
      *(int16x8_t *)(result + v6) = vsubq_s16((int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v7, (uint64x2_t)vnegq_s64(v13)), (int32x4_t)vshlq_u64(v7, (uint64x2_t)vnegq_s64(v12))), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v7, (uint64x2_t)vnegq_s64(v15)), (int32x4_t)vshlq_u64(v7, (uint64x2_t)vnegq_s64(v14)))), v5), (int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16(
                                                                (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v7, (uint64x2_t)vnegq_s64((int64x2_t)vorrq_s8((int8x16_t)v13, v3))), (int32x4_t)vshlq_u64(v7, (uint64x2_t)vnegq_s64((int64x2_t)vorrq_s8((int8x16_t)v12, v3)))), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v7, (uint64x2_t)vnegq_s64((int64x2_t)vorrq_s8((int8x16_t)v15, v3))), (int32x4_t)vshlq_u64(v7, (uint64x2_t)vnegq_s64((int64x2_t)vorrq_s8((int8x16_t)v14, v3))))), v5));
      int64x2_t v10 = vaddq_s64(v10, v4);
      int64x2_t v9 = vaddq_s64(v9, v4);
      int64x2_t v8 = vaddq_s64(v8, v4);
      int64x2_t v11 = vaddq_s64(v11, v4);
      v6 += 16;
    }
    while (v6 != 32);
    ++v2;
    result += 32;
  }
  while (v2 != 16);
  return result;
}

uint64_t ccec_twin_mult_ws(uint64_t a1, uint64_t *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, char *a7)
{
  v28[1] = *MEMORY[0x263EF8C08];
  uint64_t v12 = *a2;
  uint64_t v24 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, *a2);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  int64x2_t v13 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  uint64_t v25 = 3 * v12;
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 12 * v12);
  uint64_t v15 = v14 + 48 * v12;
  uint64_t v26 = v14;
  uint64_t v16 = v14 + 72 * v12;
  ccec_full_add_ws(a1, (uint64_t)a2);
  ccec_full_sub_ws(a1, a2, v16, a5, a7);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  unsigned int v23 = cczp_inv_ws(a1, (uint64_t)a2);
  if (!v23)
  {
    ccec_twin_mult_normalize_ws(a1, a2);
    ccec_twin_mult_normalize_ws(a1, a2);
    ccec_twin_mult_normalize_ws(a1, a2);
    ccec_twin_mult_normalize_ws(a1, a2);
    ccn_seti(v12, v13, 1);
    cczp_to_ws(a1, (uint64_t)a2);
    ccn_set(v12, (void *)(v26 + 24 * v12 + 16 * *a2), (void *)(v26 + 16 * *a2));
    ccn_set(v12, (void *)(v15 + 16 * *a2), (void *)(v26 + 16 * *a2));
    ccn_set(v12, (void *)(v16 + 16 * *a2), (void *)(v26 + 16 * *a2));
    unint64_t v17 = ccn_bitlen_internal(v12, a4);
    unint64_t v18 = ccn_bitlen_internal(v12, a6);
    v27[1] = 0;
    char v27[2] = 0;
    if (v17 <= v18) {
      unint64_t v17 = v18;
    }
    v27[0] = 0;
    ccn_recode_jsf_init((uint64_t)v27, v17, a4, a6);
    ccn_set(v12, a3, (void *)(v26 + 16 * *a2));
    ccn_set(v12, &a3[8 * *a2], (void *)(v26 + 16 * *a2));
    cc_clear(8 * v12, &a3[16 * *a2]);
    for (; v17 != -1; --v17)
    {
      ccec_double_ws(a1, a2);
      ccn_recode_jsf_column((uint64_t)v27, v17, (uint64_t)v28);
      if (v28[0])
      {
        unint64_t v19 = (char *)(v26 + 8 * ccn_recode_jsf_index(v28) * v25);
        if (ccn_recode_jsf_direction((unsigned int *)v28) == 1) {
          ccec_full_add_normalized_ws(a1, (unint64_t *)a2, a3, (uint64_t)a3, v19);
        }
        else {
          ccec_full_sub_normalized_ws(a1, (unint64_t *)a2, a3, (uint64_t)a3, v19);
        }
      }
    }
  }
  *(void *)(a1 + 16) = v24;
  return v23;
}

uint64_t ccec_twin_mult_normalize_ws(uint64_t a1, void *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, void))(a1 + 24))(a1, *a2);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  uint64_t result = cczp_mul_ws(a1, (uint64_t)a2);
  *(void *)(a1 + 16) = v5;
  return result;
}

uint64_t cch2c_ws(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    return cch2c_encode_to_curve_ws(a1, a2);
  }
  else {
    return 4294967289;
  }
}

uint64_t cch2c(uint64_t a1, uint64_t a2)
{
  BOOL v15 = timingsafe_enable_if_supported();
  uint64_t v4 = (uint64_t *)(*(uint64_t (**)(void))(a1 + 16))();
  uint64_t v5 = *v4;
  uint64_t v6 = sizeof_struct_cche_galois_key();
  unint64_t v7 = sizeof_struct_ccpolyzp_po2cyc();
  v13[0] = cc_malloc_clear(144 * v5 + 16 * ((v6 + v7 + 3 * v5 * v7 - 1) / v7 + v5));
  uint64_t v8 = *v4;
  uint64_t v9 = sizeof_struct_cche_galois_key();
  unint64_t v10 = sizeof_struct_ccpolyzp_po2cyc();
  v13[1] = 18 * v8 + 2 * ((v9 + v10 + 3 * v8 * v10 - 1) / v10 + v8);
  void v13[2] = 0;
  void v13[3] = cc_ws_alloc;
  uint64_t v14 = cc_ws_free;
  if (v13[0])
  {
    if (a2)
    {
      uint64_t v11 = cch2c_encode_to_curve_ws((uint64_t)v13, a1);
      v14((uint64_t)v13);
    }
    else
    {
      uint64_t v11 = 4294967289;
      cc_ws_free((uint64_t)v13);
    }
  }
  else
  {
    uint64_t v11 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v11;
}

uint64_t cch2c_name(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t clear_cofactor_nop()
{
  return 0;
}

uint64_t ccmode_ctr_init(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *(void *)(a1 + 48);
  *a2 = v8;
  uint64_t v9 = (*(uint64_t (**)(void))(v8 + 16))();
  (*(void (**)(uint64_t, void *, uint64_t))(a1 + 32))(a1, a2, a5);
  return v9;
}

uint64_t ccec_verify_internal_with_base_ws(uint64_t a1, unint64_t **a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = (uint64_t *)*a2;
  uint64_t v16 = (uint64_t)(*a2 + 4);
  unint64_t v15 = **a2;
  if (a3 <= 0xF)
  {
    uint64_t v34 = cc_log_default();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT)) {
      ccec_sign_internal_ws_cold_1(a3, v34);
    }
  }
  if (!ccec_validate_scalar((unint64_t *)v14, a5)
    && !ccec_validate_scalar((unint64_t *)v14, a6))
  {
    uint64_t v38 = (unint64_t *)a5;
    uint64_t v41 = *(void *)(a1 + 16);
    unint64_t v19 = (unint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v15);
    uint64_t v39 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v15);
    uint64_t v44 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v15);
    uint64_t v43 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v15);
    uint64_t v40 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 3 * v15);
    char v42 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 3 * v15);
    size_t v20 = ccec_signature_r_s_size((uint64_t *)a2);
    uint64_t v36 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v15);
    memset(v36, 170, v20);
    uint64_t __s = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v15);
    unint64_t v37 = v20;
    memset(__s, 255, v20);
    uint64_t v21 = cczp_bitlen(v16 + 40 * *v14);
    unint64_t v22 = v21;
    if ((unint64_t)(v21 + 7) >> 3 >= a3) {
      unint64_t v23 = a3;
    }
    else {
      unint64_t v23 = (unint64_t)(v21 + 7) >> 3;
    }
    uint64_t uint_internal = ccn_read_uint_internal(v15, v19, v23, a4);
    if ((uint_internal & 0x80000000) == 0)
    {
      if (v22 < 8 * a3) {
        ccn_shift_right(v15, (uint64_t)v19, v19, -(int)v22 & 7);
      }
      uint64_t v25 = (unint64_t *)cczp_prime(v16 + 40 * v15);
      if (!ccn_sub_ws(a1, v15, v39, (uint64_t *)v19, v25)) {
        ccn_set(v15, v19, v39);
      }
      if (cczp_inv_ws(a1, v16 + 40 * v15)
        || (cczp_mul_ws(a1, v16 + 40 * v15),
            cczp_mul_ws(a1, v16 + 40 * v15),
            uint64_t v26 = a2 + 2,
            ccn_n(v15, (uint64_t)&a2[2 * *v14 + 2]) != 1)
        || v26[2 * *v14] != (unint64_t *)1)
      {
LABEL_37:
        uint64_t v17 = 4294967289;
LABEL_39:
        uint64_t v29 = v41;
LABEL_34:
        *(void *)(a1 + 16) = v29;
        return v17;
      }
      uint64_t v27 = v16 + 40 * v15;
      uint64_t uint_internal = ccec_projectify_ws(a1, (uint64_t)v14);
      if (!uint_internal)
      {
        uint64_t uint_internal = ccec_projectify_ws(a1, (uint64_t)v14);
        if (!uint_internal)
        {
          if (ccec_is_point_ws(a1, v14, v42))
          {
            uint64_t v28 = *v14;
            if (ccn_cmp_internal(*v14, v16 + 16 * *v14 + 8 * *v14, v26))
            {
              uint64_t v17 = ccec_twin_mult_ws(a1, v14, v40, v44, (uint64_t)v40, v43, v42);
              uint64_t v29 = v41;
              if (v17) {
                goto LABEL_34;
              }
            }
            else
            {
              uint64_t v30 = v16 + 40 * v28;
              uint64_t v31 = *(void *)(a1 + 16);
              (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, 3 * v28);
              cczp_bitlen(v30);
              if (ccec_mult_ws(a1, (uint64_t)v14)
                || (cczp_bitlen(v30), ccec_mult_ws(a1, (uint64_t)v14)))
              {
                uint64_t v17 = 0xFFFFFFFFLL;
              }
              else
              {
                ccec_full_add_ws(a1, (uint64_t)v14);
                uint64_t v17 = 0;
              }
              uint64_t v29 = v41;
              *(void *)(a1 + 16) = v31;
              if (v17) {
                goto LABEL_34;
              }
            }
            if (ccec_affinify_x_only_ws(a1, (unint64_t *)v14, (uint64_t)v40, (uint64_t)v40))
            {
              uint64_t v17 = 4294967289;
            }
            else
            {
              uint64_t v32 = cczp_prime(v27);
              if ((ccn_cmp_internal(v15, v40, v32) & 0x80000000) == 0)
              {
                unint64_t v33 = (unint64_t *)cczp_prime(v27);
                ccn_sub_ws(a1, v15, v40, (uint64_t *)v40, v33);
              }
              if (ccn_cmp_internal(v15, v40, v38)) {
                uint64_t v17 = 4294967150;
              }
              else {
                uint64_t v17 = 0;
              }
              ccn_write_uint_padded_ct_internal(v15, v38, v37, (char *)v36);
              ccn_write_uint_padded_ct_internal(v15, (unint64_t *)v40, v37, (char *)__s);
              cc_fault_canary_set(a8, (uint64_t)&CCEC_FAULT_CANARY, v37, (uint64_t)v36, (uint64_t)__s);
            }
            goto LABEL_34;
          }
          goto LABEL_37;
        }
      }
    }
    uint64_t v17 = uint_internal;
    goto LABEL_39;
  }
  return 4294967289;
}

uint64_t ccec_verify_internal_ws(uint64_t a1, unint64_t **a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return ccec_verify_internal_with_base_ws(a1, a2, a3, a4, a5, a6, (uint64_t)&(*a2)[2 * **a2 + 4 + **a2], a7);
}

void *ccmd5_di()
{
  return &ccmd5_ltc_di;
}

void *ccaes_ecb_encrypt_mode()
{
  return &ccaes_ltc_ecb_encrypt_mode;
}

void *ccec_cp_ed448_opt()
{
  return &ccec_ed448_opt_params;
}

double deskey(uint64_t a1, int a2, _OWORD *a3)
{
  uint64_t v3 = 0;
  uint64_t v34 = *MEMORY[0x263EF8C08];
  do
  {
    v26[v3 + 56] = (bytebit[pc1[v3] & 7] & ~*(unsigned __int8 *)(a1 + ((unint64_t)pc1[v3] >> 3))) == 0;
    ++v3;
  }
  while (v3 != 56);
  for (uint64_t i = 0; i != 16; ++i)
  {
    uint64_t v5 = 0;
    if (a2 == 1) {
      int v6 = 15 - i;
    }
    else {
      int v6 = i;
    }
    uint64_t v7 = (2 * v6) | 1u;
    uint64_t v8 = &v26[8 * v6 + 112];
    *uint64_t v8 = 0;
    uint64_t v9 = totrot[i];
    do
    {
      uint64_t v10 = v9 + v5;
      if ((unint64_t)(v9 + v5) >= 0x1C) {
        uint64_t v10 = (v9 - 28 + v5);
      }
      v26[v5++] = v26[v10 + 56];
    }
    while (v5 != 28);
    for (uint64_t j = 0; j != 28; ++j)
    {
      uint64_t v12 = v9 + j;
      if ((unint64_t)(v9 + j + 28) < 0x38) {
        uint64_t v12 = v9 + j + 28;
      }
      v26[j + 28] = v26[v12 + 56];
    }
    int v13 = 0;
    int v14 = 0;
    for (uint64_t k = 0; k != 24; ++k)
    {
      if (v26[pc2[k]])
      {
        v14 |= bigbyte[k];
        *(_DWORD *)uint64_t v8 = v14;
      }
      if (v26[pc2[k + 24]])
      {
        v13 |= bigbyte[k];
        *(_DWORD *)&v26[4 * v7 + 112] = v13;
      }
    }
  }
  uint64_t v16 = 0;
  do
  {
    uint64_t v17 = (const float *)&v26[v16 + 112];
    uint32x2_t v18 = (uint32x2_t)vld1_dup_f32(v17++);
    *(float *)&uint64_t v17 = *v17;
    int8x8_t v19 = (int8x8_t)vdup_n_s32(v17);
    int8x8_t v20 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)v19, (uint32x2_t)0xFFFFFFFCFFFFFFFALL), (int8x8_t)0x3F000000003FLL);
    v19.i32[0] = v17 >> 10;
    *(int8x8_t *)((char *)v27 + v16) = vorr_s8(vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v18, (uint32x2_t)0xC0000000ALL), (int8x8_t)0x3F000000003F0000), vand_s8((int8x8_t)vshl_u32(v18, (uint32x2_t)0x1000000006), (int8x8_t)0x3F00003F000000)), v20), vand_s8(v19, (int8x8_t)0x3F00003F00));
    v16 += 8;
  }
  while (v16 != 128);
  long long v21 = v31;
  a3[4] = v30;
  a3[5] = v21;
  long long v22 = v33;
  a3[6] = v32;
  a3[7] = v22;
  long long v23 = v27[1];
  *a3 = v27[0];
  a3[1] = v23;
  double result = *(double *)&v28;
  long long v25 = v29;
  a3[2] = v28;
  a3[3] = v25;
  return result;
}

unsigned int *desfunc(unsigned int *result, uint64_t a2)
{
  uint64_t v2 = 0;
  unsigned int v3 = result[1];
  int v4 = (v3 ^ (*result >> 4)) & 0xF0F0F0F;
  int v5 = v4 ^ v3;
  unsigned int v6 = *result ^ (16 * v4);
  int v7 = (unsigned __int16)v5 ^ HIWORD(v6);
  unsigned int v8 = v7 ^ v5;
  int v9 = v6 ^ (v7 << 16);
  int v10 = (v9 ^ (v8 >> 2)) & 0x33333333;
  int v11 = v10 ^ v9;
  unsigned int v12 = v8 ^ (4 * v10);
  int v13 = (v11 ^ (v12 >> 8)) & 0xFF00FF;
  int v14 = v13 ^ v11;
  int v15 = __ROR4__(v12 ^ (v13 << 8), 31);
  unsigned int v16 = (v14 ^ v15) & 0xAAAAAAAA;
  int v17 = v16 ^ v15;
  HIDWORD(v19) = v16 ^ v14;
  LODWORD(v19) = v16 ^ v14;
  int v18 = v19 >> 31;
  do
  {
    unsigned int v20 = *(_DWORD *)(a2 + v2) ^ __ROR4__(v17, 4);
    unsigned int v21 = *(_DWORD *)(a2 + v2 + 4) ^ v17;
    v18 ^= SP7[v20 & 0x3F] ^ SP5[(v20 >> 8) & 0x3F] ^ SP3[HIWORD(v20) & 0x3F] ^ SP1[HIBYTE(v20) & 0x3F] ^ SP8[v21 & 0x3F] ^ SP6[(v21 >> 8) & 0x3F] ^ SP4[HIWORD(v21) & 0x3F] ^ SP2[HIBYTE(v21) & 0x3F];
    unsigned int v22 = *(_DWORD *)(a2 + v2 + 8) ^ __ROR4__(v18, 4);
    unsigned int v23 = *(_DWORD *)(a2 + v2 + 12) ^ v18;
    v17 ^= SP7[v22 & 0x3F] ^ SP5[(v22 >> 8) & 0x3F] ^ SP3[HIWORD(v22) & 0x3F] ^ SP1[HIBYTE(v22) & 0x3F] ^ SP8[v23 & 0x3F] ^ SP6[(v23 >> 8) & 0x3F] ^ SP4[HIWORD(v23) & 0x3F] ^ SP2[HIBYTE(v23) & 0x3F];
    v2 += 16;
  }
  while (v2 != 128);
  unsigned int v24 = (v18 ^ __ROR4__(v17, 1)) & 0xAAAAAAAA;
  int v25 = v24 ^ v18;
  unint64_t v27 = __PAIR64__(v24 ^ v18, __ROR4__(v17, 1));
  int v26 = v24 ^ v27;
  LODWORD(v27) = v25;
  unsigned int v28 = (v26 ^ ((v27 >> 1) >> 8)) & 0xFF00FF;
  int v29 = v28 ^ v26;
  unsigned int v30 = (v28 << 8) ^ __ROR4__(v25, 1);
  int v31 = (v29 ^ (v30 >> 2)) & 0x33333333;
  unsigned int v32 = v31 ^ v29;
  int v33 = v30 ^ (4 * v31);
  int v34 = (unsigned __int16)v33 ^ HIWORD(v32);
  int v35 = v34 ^ v33;
  unsigned int v36 = v32 ^ (v34 << 16);
  int v37 = (v35 ^ (v36 >> 4)) & 0xF0F0F0F;
  *double result = v36 ^ (16 * v37);
  result[1] = v37 ^ v35;
  return result;
}

unsigned int *desfunc3(unsigned int *result, uint64_t a2)
{
  uint64_t v2 = 0;
  unsigned int v3 = result[1];
  int v4 = (v3 ^ (*result >> 4)) & 0xF0F0F0F;
  int v5 = v4 ^ v3;
  unsigned int v6 = *result ^ (16 * v4);
  int v7 = (unsigned __int16)v5 ^ HIWORD(v6);
  unsigned int v8 = v7 ^ v5;
  int v9 = v6 ^ (v7 << 16);
  int v10 = (v9 ^ (v8 >> 2)) & 0x33333333;
  int v11 = v10 ^ v9;
  unsigned int v12 = v8 ^ (4 * v10);
  int v13 = (v11 ^ (v12 >> 8)) & 0xFF00FF;
  int v14 = v13 ^ v11;
  int v15 = __ROR4__(v12 ^ (v13 << 8), 31);
  unsigned int v16 = (v14 ^ v15) & 0xAAAAAAAA;
  int v17 = v16 ^ v15;
  HIDWORD(v19) = v16 ^ v14;
  LODWORD(v19) = v16 ^ v14;
  int v18 = v19 >> 31;
  do
  {
    unsigned int v20 = *(_DWORD *)(a2 + v2) ^ __ROR4__(v17, 4);
    unsigned int v21 = *(_DWORD *)(a2 + v2 + 4) ^ v17;
    v18 ^= SP7[v20 & 0x3F] ^ SP5[(v20 >> 8) & 0x3F] ^ SP3[HIWORD(v20) & 0x3F] ^ SP1[HIBYTE(v20) & 0x3F] ^ SP8[v21 & 0x3F] ^ SP6[(v21 >> 8) & 0x3F] ^ SP4[HIWORD(v21) & 0x3F] ^ SP2[HIBYTE(v21) & 0x3F];
    unsigned int v22 = *(_DWORD *)(a2 + v2 + 8) ^ __ROR4__(v18, 4);
    unsigned int v23 = *(_DWORD *)(a2 + v2 + 12) ^ v18;
    v17 ^= SP7[v22 & 0x3F] ^ SP5[(v22 >> 8) & 0x3F] ^ SP3[HIWORD(v22) & 0x3F] ^ SP1[HIBYTE(v22) & 0x3F] ^ SP8[v23 & 0x3F] ^ SP6[(v23 >> 8) & 0x3F] ^ SP4[HIWORD(v23) & 0x3F] ^ SP2[HIBYTE(v23) & 0x3F];
    v2 += 16;
  }
  while (v2 != 128);
  uint64_t v24 = 0;
  uint64_t v25 = a2 + 128;
  do
  {
    unsigned int v26 = *(_DWORD *)(v25 + v24) ^ __ROR4__(v18, 4);
    unsigned int v27 = *(_DWORD *)(v25 + v24 + 4) ^ v18;
    v17 ^= SP7[v26 & 0x3F] ^ SP5[(v26 >> 8) & 0x3F] ^ SP3[HIWORD(v26) & 0x3F] ^ SP1[HIBYTE(v26) & 0x3F] ^ SP8[v27 & 0x3F] ^ SP6[(v27 >> 8) & 0x3F] ^ SP4[HIWORD(v27) & 0x3F] ^ SP2[HIBYTE(v27) & 0x3F];
    unsigned int v28 = *(_DWORD *)(v25 + v24 + 8) ^ __ROR4__(v17, 4);
    unsigned int v29 = *(_DWORD *)(v25 + v24 + 12) ^ v17;
    v18 ^= SP7[v28 & 0x3F] ^ SP5[(v28 >> 8) & 0x3F] ^ SP3[HIWORD(v28) & 0x3F] ^ SP1[HIBYTE(v28) & 0x3F] ^ SP8[v29 & 0x3F] ^ SP6[(v29 >> 8) & 0x3F] ^ SP4[HIWORD(v29) & 0x3F] ^ SP2[HIBYTE(v29) & 0x3F];
    v24 += 16;
  }
  while (v24 != 128);
  uint64_t v30 = 0;
  uint64_t v31 = a2 + 256;
  do
  {
    unsigned int v32 = *(_DWORD *)(v31 + v30) ^ __ROR4__(v17, 4);
    unsigned int v33 = *(_DWORD *)(v31 + v30 + 4) ^ v17;
    v18 ^= SP7[v32 & 0x3F] ^ SP5[(v32 >> 8) & 0x3F] ^ SP3[HIWORD(v32) & 0x3F] ^ SP1[HIBYTE(v32) & 0x3F] ^ SP8[v33 & 0x3F] ^ SP6[(v33 >> 8) & 0x3F] ^ SP4[HIWORD(v33) & 0x3F] ^ SP2[HIBYTE(v33) & 0x3F];
    unsigned int v34 = *(_DWORD *)(v31 + v30 + 8) ^ __ROR4__(v18, 4);
    unsigned int v35 = *(_DWORD *)(v31 + v30 + 12) ^ v18;
    v17 ^= SP7[v34 & 0x3F] ^ SP5[(v34 >> 8) & 0x3F] ^ SP3[HIWORD(v34) & 0x3F] ^ SP1[HIBYTE(v34) & 0x3F] ^ SP8[v35 & 0x3F] ^ SP6[(v35 >> 8) & 0x3F] ^ SP4[HIWORD(v35) & 0x3F] ^ SP2[HIBYTE(v35) & 0x3F];
    v30 += 16;
  }
  while (v30 != 128);
  unsigned int v36 = (v18 ^ __ROR4__(v17, 1)) & 0xAAAAAAAA;
  unint64_t v38 = __PAIR64__(v36 ^ v18, __ROR4__(v17, 1));
  int v37 = v36 ^ v38;
  LODWORD(v38) = v36 ^ v18;
  unsigned int v39 = (v37 ^ ((v38 >> 1) >> 8)) & 0xFF00FF;
  int v40 = v39 ^ v37;
  unsigned int v41 = (v39 << 8) ^ __ROR4__(v36 ^ v18, 1);
  int v42 = (v40 ^ (v41 >> 2)) & 0x33333333;
  unsigned int v43 = v42 ^ v40;
  int v44 = v41 ^ (4 * v42);
  int v45 = (unsigned __int16)v44 ^ HIWORD(v43);
  int v46 = v45 ^ v44;
  unsigned int v47 = v43 ^ (v45 << 16);
  int v48 = (v46 ^ (v47 >> 4)) & 0xF0F0F0F;
  *double result = v47 ^ (16 * v48);
  result[1] = v48 ^ v46;
  return result;
}

uint64_t ccblowfish_ltc_ecb_decrypt(_DWORD *a1, uint64_t a2, unsigned int *a3, unsigned char *a4)
{
  for (; a2; --a2)
  {
    unsigned int v4 = a1[1041] ^ bswap32(*a3);
    unsigned int v5 = bswap32(a3[1]) ^ a1[1040];
    unsigned int v6 = a1 + 1039;
    for (unint64_t i = 19; i > 4; i -= 4)
    {
      unsigned int v8 = (((a1[BYTE2(v4) + 256] + a1[HIBYTE(v4)]) ^ a1[BYTE1(v4) + 512]) + a1[v4 + 768]) ^ v5;
      unsigned int v9 = *v6 ^ v4 ^ (((a1[BYTE2(v8) + 256] + a1[HIBYTE(v8)]) ^ a1[BYTE1(v8) + 512]) + a1[v8 + 768]);
      unsigned int v10 = *(v6 - 1) ^ v8 ^ (((a1[BYTE2(v9) + 256] + a1[HIBYTE(v9)]) ^ a1[BYTE1(v9) + 512])
                            + a1[v9 + 768]);
      unsigned int v4 = *(v6 - 2) ^ v9 ^ (((a1[BYTE2(v10) + 256] + a1[HIBYTE(v10)]) ^ a1[BYTE1(v10) + 512])
                           + a1[v10 + 768]);
      unsigned int v5 = *(v6 - 3) ^ v10;
      v6 -= 4;
    }
    *a4 = HIBYTE(v5);
    a4[1] = BYTE2(v5);
    a4[2] = BYTE1(v5);
    a4[3] = v5;
    a4[4] = HIBYTE(v4);
    a4[5] = BYTE2(v4);
    a4[6] = BYTE1(v4);
    a4[7] = v4;
    a4 += 8;
    a3 += 2;
  }
  return 0;
}

uint64_t ccmode_cbc_decrypt(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v18 = *MEMORY[0x263EF8C08];
  unsigned int v5 = a1 + 1;
  uint64_t v6 = *a1;
  if (*(void *)(*a1 + 8) > 0x10uLL) {
    return 4294967289;
  }
  for (uint64_t i = a3; i; a5 += v16)
  {
    (*(void (**)(uint64_t *, uint64_t, uint64_t, unsigned char *))(v6 + 24))(v5, 1, a4, v17);
    if (*(void *)(v6 + 8))
    {
      unint64_t v12 = 0;
      do
      {
        char v13 = *(unsigned char *)(a2 + v12);
        char v14 = v17[v12];
        *(unsigned char *)(a2 + v12) = *(unsigned char *)(a4 + v12);
        *(unsigned char *)(a5 + v12++) = v14 ^ v13;
        unint64_t v15 = *(void *)(v6 + 8);
      }
      while (v12 < v15);
    }
    else
    {
      unint64_t v15 = 0;
    }
    if (--i) {
      unint64_t v16 = v15;
    }
    else {
      unint64_t v16 = 0;
    }
    a4 += v16;
  }
  return 0;
}

void *ccrc2_ecb_decrypt_mode()
{
  return &ccrc2_ltc_ecb_decrypt_mode;
}

void *ccrc2_ecb_encrypt_mode()
{
  return &ccrc2_ltc_ecb_encrypt_mode;
}

void *ccrc2_cbc_encrypt_mode()
{
  return cbc_rc2_encrypt;
}

void *ccrc2_cbc_decrypt_mode()
{
  return cbc_rc2_decrypt;
}

void *ccrc2_cfb_encrypt_mode()
{
  return cfb_rc2_encrypt;
}

void *ccrc2_cfb_decrypt_mode()
{
  return cfb_rc2_decrypt;
}

void *ccrc2_cfb8_encrypt_mode()
{
  return cfb8_rc2_encrypt;
}

void *ccrc2_cfb8_decrypt_mode()
{
  return cfb8_rc2_decrypt;
}

void *ccrc2_ctr_crypt_mode()
{
  return ctr_rc2;
}

void *ccrc2_ofb_crypt_mode()
{
  return ofb_rc2;
}

int8x16_t *ccmode_xts_crypt(uint64_t *a1, unint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v5 = *a2 + a3;
  if (v5 > 0x100000) {
    return 0;
  }
  uint64_t v7 = a3;
  *a2 = v5;
  uint64_t v6 = (int8x16_t *)(a2 + 1);
  if (a3)
  {
    unsigned int v10 = a1 + 2;
    uint64_t v11 = *a1;
    do
    {
      ccn_xor(2, a5, a4, (uint64_t)v6);
      (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(v11 + 24))(v10, 1, a5, a5);
      ccn_xor(2, a5, a5, (uint64_t)v6);
      ccmode_xts_mult_alpha(v6);
      a4 += 16;
      a5 += 16;
      --v7;
    }
    while (v7);
  }
  return v6;
}

void *ccshake128_xi()
{
  return &ccxof_shake128_c_xi;
}

uint64_t ccshake128_c_absorb(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  return cckeccak_absorb_blocks(a2, *(void *)(a1 + 8), a3, a4, cckeccak_f1600_c);
}

uint64_t ccshake128_c_absorb_last(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t *a4)
{
  return cckeccak_absorb_and_pad(a2, *(void *)(a1 + 8), a3, a4, 0x1Fu, cckeccak_f1600_c);
}

uint64_t ccshake128_c_squeeze(uint64_t a1, uint64_t a2, unint64_t a3, void *a4)
{
  return cckeccak_squeeze(a2, *(void *)(a1 + 8), a3, a4, cckeccak_f1600_c);
}

uint64_t ccec_make_priv(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t **a8)
{
  BOOL v20 = timingsafe_enable_if_supported();
  cp = (uint64_t *)ccec_get_cp(a1);
  *a8 = cp;
  int v17 = a8 + 2;
  uint64_t uint_internal = ccn_read_uint_internal(*cp, a8 + 2, a2, a3);
  if (!uint_internal)
  {
    uint64_t uint_internal = ccn_read_uint_internal(*cp, &v17[**a8], a4, a5);
    if (!uint_internal)
    {
      uint64_t uint_internal = ccn_read_uint_internal(*cp, &v17[3 * **a8], a6, a7);
      if (!uint_internal) {
        ccn_seti(*cp, &v17[2 * **a8], 1);
      }
    }
  }
  cc_disable_dit_with_sb((unsigned int *)&v20);
  return uint_internal;
}

uint64_t ccec_generate_scalar_legacy_ws(uint64_t a1, uint64_t *a2, size_t a3, void *__src, void *__dst)
{
  uint64_t v7 = a2 + 4;
  uint64_t v6 = *a2;
  size_t v8 = 8 * *a2;
  if (v8 > a3) {
    return 4294967276;
  }
  uint64_t v12 = (uint64_t)&v7[5 * v6];
  memcpy(__dst, __src, v8);
  char v13 = cczp_bitlen((uint64_t)&v7[5 * *a2]);
  if ((v13 & 0x3F) != 0) {
    *((void *)__dst + v6 - 1) &= 0xFFFFFFFFFFFFFFFFLL >> -(v13 & 0x3F);
  }
  uint64_t v14 = *(void *)(a1 + 16);
  unint64_t v15 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  unint64_t v16 = (unint64_t *)cczp_prime(v12);
  char v17 = ccn_sub_ws(a1, v6, v15, (uint64_t *)__dst, v16);
  ccn_mux(v6, v17 ^ 1, (uint64_t *)__dst, v15, (uint64_t *)__dst);
  uint64_t result = 0;
  *(void *)(a1 + 16) = v14;
  return result;
}

uint64_t ccsrp_generate_M_ws(uint64_t a1, size_t **a2, char *a3, size_t a4, char *a5, unint64_t *a6, unint64_t *a7)
{
  unsigned int v27 = a6;
  unsigned int v28 = a7;
  size_t v25 = a4;
  unsigned int v26 = a5;
  uint64_t v30 = &v25;
  uint64_t v35 = *MEMORY[0x263EF8C08];
  unsigned int v10 = *a2;
  size_t v11 = **a2;
  uint64_t v12 = MEMORY[0x270FA53B0](a1, a2, a3, a4);
  uint64_t v14 = (size_t *)((char *)&v25 - v13);
  int v16 = (*(_DWORD *)(v15 + 24) >> 10) & 1;
  uint64_t v29 = *(void *)(v12 + 16);
  char v17 = (unint64_t *)ccdh_gp_prime(*(void *)(v15 + 8));
  ccsrp_digest_ccn_ws(a1, (uint64_t *)a2, v17, (uint64_t)__s, v16);
  uint64_t v18 = (unint64_t *)ccdh_gp_g(a2[1]);
  ccsrp_digest_ccn_ws(a1, (uint64_t *)a2, v18, (uint64_t)v33, v16);
  if (v11)
  {
    size_t v19 = v11;
    do
    {
      v31[v19 - 1] = v32[v19 + 63] ^ v33[v19 + 63];
      --v19;
    }
    while (v19);
  }
  size_t v20 = strlen(a3);
  ccdigest_internal((uint64_t)v10, v20, a3, (uint64_t)v32);
  ccdigest_init_internal((uint64_t)v10, v14);
  ccdigest_update_internal(v10, v14, v11, v31);
  ccdigest_update_internal(v10, v14, v11, v32);
  ccdigest_update_internal(v10, v14, v25, v26);
  ccsrp_digest_update_ccn_ws(a1, (uint64_t)a2, v14, v27, v16);
  ccsrp_digest_update_ccn_ws(a1, (uint64_t)a2, v14, v28, v16);
  size_t session_key_length = ccsrp_get_session_key_length((uint64_t *)a2);
  uint64_t v22 = ccdh_gp_n(a2[1]);
  ccdigest_update_internal(v10, v14, session_key_length, (char *)&a2[4 * v22 + 4]);
  uint64_t v23 = ccdh_gp_n(a2[1]);
  ((void (*)(unint64_t *, void *, size_t))v10[7])(v10, v14, (uint64_t)&a2[4 * v23 + 4] + 2 * **a2);
  cc_clear(v10[1] + v10[2] + 12, v14);
  cc_clear(0x40uLL, __s);
  cc_clear(0x40uLL, v33);
  cc_clear(0x40uLL, v31);
  uint64_t result = cc_clear(0x40uLL, v32);
  *(void *)(a1 + 16) = v29;
  return result;
}

void *ccaes_siv_hmac_sha256_decrypt_mode()
{
  unint64_t v0 = ccsha256_di();
  uint64_t v1 = ccaes_ctr_crypt_mode();
  ccmode_factory_siv_hmac_decrypt((uint64_t)&siv_hmac_decrypt, (uint64_t)v0, (uint64_t)v1);
  return &siv_hmac_decrypt;
}

uint64_t pgp_key_checksum(uint64_t a1, unsigned __int8 *a2)
{
  for (unsigned __int16 i = 0; a1; --a1)
  {
    __int16 v3 = *a2++;
    i += v3;
  }
  return i;
}

uint64_t ccec_validate_scalar(unint64_t *a1, uint64_t a2)
{
  unint64_t v4 = *a1;
  uint64_t v5 = cczp_prime((uint64_t)&a1[5 * *a1 + 4]);
  if ((ccn_cmp_internal(v4, a2, v5) & 0x80000000) == 0) {
    return 0xFFFFFFFFLL;
  }
  if (ccn_n(*a1, a2)) {
    return 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t cccurve448_internal(uint64_t a1, char *a2, uint64_t a3, uint64_t *a4, uint64_t (**a5)(void, unint64_t, uint64_t))
{
  uint64_t v50 = *MEMORY[0x263EF8C08];
  unsigned int v41 = cc_malloc_clear(0x380uLL);
  long long v42 = xmmword_2373BB1C0;
  unsigned int v43 = (uint64_t (*)(void **, uint64_t))cc_ws_alloc;
  int v44 = cc_ws_free;
  if (!v41) {
    return 4294967283;
  }
  unint64_t v38 = a2;
  uint64_t v10 = cczp_n(a1);
  size_t v11 = (char *)cc_ws_alloc(&v41, v10);
  uint64_t v12 = (void *)v43(&v41, v10);
  uint64_t v39 = v43(&v41, v10);
  uint64_t __src = (void *)v43(&v41, v10);
  uint64_t v13 = v43(&v41, v10);
  uint64_t v14 = v43(&v41, v10);
  uint64_t non_zero_element_ws = cczp_generate_non_zero_element_ws((uint64_t)&v41, a1, a5, v11);
  if (non_zero_element_ws
    || (uint64_t non_zero_element_ws = cczp_generate_non_zero_element_ws((uint64_t)&v41, a1, a5, (char *)v12),
        non_zero_element_ws))
  {
    uint64_t v21 = non_zero_element_ws;
  }
  else
  {
    uint64_t v45 = 0;
    (*a5)(a5, 8uLL, (uint64_t)&v45);
    ccn_mux_seed_mask(v45);
    uint64_t v49 = *(void *)(a3 + 48);
    long long v16 = *(_OWORD *)(a3 + 16);
    __s[0] = *(_OWORD *)a3;
    __s[1] = v16;
    _OWORD __s[2] = *(_OWORD *)(a3 + 32);
    LOBYTE(__s[0]) &= 0xFCu;
    HIBYTE(v49) |= 0x80u;
    unsigned int v36 = (uint64_t *)v13;
    int v37 = (uint64_t *)v14;
    if (v10)
    {
      for (uint64_t i = 0; i != v10; ++i)
        *(void *)(v39 + 8 * i) = *((void *)__s + i);
      cc_clear(0x38uLL, __s);
      uint64_t v18 = __src;
      uint64_t v19 = v10;
      do
      {
        uint64_t v20 = *a4++;
        *v18++ = v20;
        --v19;
      }
      while (v19);
    }
    else
    {
      cc_clear(0x38uLL, __s);
    }
    cczp_mul_ws((uint64_t)&v41, a1);
    uint64_t v22 = cczp_n(a1);
    uint64_t v35 = *((void *)&v42 + 1);
    uint64_t v23 = (char *)v43(&v41, 2 * v22);
    uint64_t v24 = &v23[8 * v22];
    size_t v25 = (char *)v43(&v41, 2 * v22);
    unsigned int v26 = &v25[8 * v22];
    v43(&v41, v22);
    v43(&v41, v22);
    cc_clear(8 * v22, v26);
    ccn_set(v22, v24, v11);
    ccn_set(v22, v23, __src);
    uint64_t v34 = v22;
    ccn_set(v22, v25, v12);
    char v27 = 0;
    for (unint64_t j = 447; j != -1; --j)
    {
      char v29 = v27;
      char v27 = (*(void *)(v39 + ((j >> 3) & 0x1FFFFFFFFFFFFFF8)) >> j) & 1;
      ccn_cond_swap(14, v27 ^ v29, (uint64_t *)v23, (uint64_t *)v25);
      cczp_sub_ws((uint64_t)&v41, a1);
      cczp_sub_ws((uint64_t)&v41, a1);
      cczp_add_ws((uint64_t)&v41, a1);
      cczp_add_ws((uint64_t)&v41, a1);
      cczp_mul_ws((uint64_t)&v41, a1);
      cczp_mul_ws((uint64_t)&v41, a1);
      cczp_sqr_ws((uint64_t)&v41, a1);
      cczp_sqr_ws((uint64_t)&v41, a1);
      cczp_add_ws((uint64_t)&v41, a1);
      cczp_sub_ws((uint64_t)&v41, a1);
      cczp_mul_ws((uint64_t)&v41, a1);
      cczp_sub_ws((uint64_t)&v41, a1);
      cczp_sqr_ws((uint64_t)&v41, a1);
      cczp_mul_ws((uint64_t)&v41, a1);
      cczp_sqr_ws((uint64_t)&v41, a1);
      cczp_mul_ws((uint64_t)&v41, a1);
      cczp_add_ws((uint64_t)&v41, a1);
      cczp_mul_ws((uint64_t)&v41, a1);
      cczp_mul_ws((uint64_t)&v41, a1);
    }
    ccn_mux(v34, v27, v36, (uint64_t *)v23, (uint64_t *)v25);
    uint64_t v30 = v37;
    ccn_mux(v34, v27, v37, (uint64_t *)v24, (uint64_t *)v26);
    *((void *)&v42 + 1) = v35;
    cczp_inv_ws((uint64_t)&v41, a1);
    cczp_mul_ws((uint64_t)&v41, a1);
    cczp_from_ws((uint64_t)&v41, a1);
    if (v10)
    {
      uint64_t v31 = v38 + 3;
      do
      {
        uint64_t v32 = *v30++;
        *(void *)(v31 - 3) = v32;
        v31 += 8;
        --v10;
      }
      while (v10);
    }
    uint64_t v47 = 0;
    memset(v46, 0, sizeof(v46));
    if (cc_cmp_safe_internal(56, v38, (char *)v46)) {
      uint64_t v21 = 0;
    }
    else {
      uint64_t v21 = 4294967289;
    }
  }
  *((void *)&v42 + 1) = 0;
  v44((uint64_t)&v41);
  return v21;
}

uint64_t cccurve448(uint64_t (**a1)(void, unint64_t, uint64_t), char *a2, uint64_t a3, uint64_t *a4)
{
  BOOL v11 = timingsafe_enable_if_supported();
  uint64_t v8 = ccec_cp_x448();
  uint64_t v9 = cccurve448_internal(v8, a2, a3, a4, a1);
  cc_disable_dit_with_sb((unsigned int *)&v11);
  return v9;
}

uint64_t cccurve448_make_priv(uint64_t (**a1)(void, uint64_t, unsigned char *), unsigned char *a2)
{
  BOOL v6 = timingsafe_enable_if_supported();
  uint64_t v4 = (*a1)(a1, 56, a2);
  if (!v4)
  {
    *a2 &= 0xFCu;
    a2[55] |= 0x80u;
  }
  cc_disable_dit_with_sb((unsigned int *)&v6);
  return v4;
}

uint64_t cccurve448_make_pub(uint64_t (**a1)(void, unint64_t, uint64_t), char *a2, uint64_t a3)
{
  BOOL v9 = timingsafe_enable_if_supported();
  uint64_t v6 = ccec_cp_x448();
  uint64_t v7 = cccurve448_internal(v6, a2, a3, kX448BasePoint, a1);
  cc_disable_dit_with_sb((unsigned int *)&v9);
  return v7;
}

uint64_t cccurve448_make_key_pair(uint64_t (**a1)(void, unint64_t, uint64_t), char *a2, unsigned char *a3)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v6 = (*a1)(a1, 56uLL, (uint64_t)a3);
  if (!v6)
  {
    *a3 &= 0xFCu;
    a3[55] |= 0x80u;
    uint64_t v7 = ccec_cp_x448();
    uint64_t v6 = cccurve448_internal(v7, a2, (uint64_t)a3, kX448BasePoint, a1);
  }
  uint64_t v8 = v6;
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccspake_kex_generate(unsigned __int8 *a1, uint64_t a2, unsigned char *a3)
{
  BOOL v28 = timingsafe_enable_if_supported();
  uint64_t v6 = (unint64_t *)(*(uint64_t (**)(void))(*(void *)a1 + 8))();
  uint64_t v7 = cczp_bitlen((uint64_t)v6);
  int v8 = a1[60];
  if (v8 == CCSPAKE_STATE_INIT || v8 == CCSPAKE_STATE_KEX_PROCESS)
  {
    unint64_t v10 = (unint64_t)(v7 + 7) >> 3;
    if (((2 * v10) | 1) == a2)
    {
      unint64_t v11 = *v6;
      uint64_t v12 = sizeof_struct_cche_galois_key();
      unint64_t v13 = sizeof_struct_ccpolyzp_po2cyc();
      v26[0] = cc_malloc_clear(8 * ((v12 + v13 + v13 * 3 * v11 - 1) / v13 + 33 * v11));
      uint64_t v14 = sizeof_struct_cche_galois_key();
      unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
      v26[1] = (v14 + v15 + v15 * 3 * v11 - 1) / v15 + 33 * v11;
      void v26[2] = 0;
      v26[3] = cc_ws_alloc;
      char v27 = cc_ws_free;
      if (v26[0])
      {
        uint64_t v16 = ccspake_lazy_gen_xy_XY_ws((uint64_t)v26, a1);
        uint64_t v24 = v16;
        if (!v16)
        {
          *a3 = 4;
          uint64_t v20 = a3 + 1;
          uint64_t v21 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 8))(v16, v17, v18, v19);
          uint64_t v22 = ccn_write_uint_padded_internal(v11, (unint64_t *)&a1[32 * *v21 + 336], v10, v20);
          uint64_t v23 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 8))(v22);
          ccn_write_uint_padded_internal(v11, (unint64_t *)&a1[40 * *v23 + 336], v10, &v20[v10]);
          a1[60] |= CCSPAKE_STATE_KEX_GENERATE;
        }
        v27((uint64_t)v26);
      }
      else
      {
        uint64_t v24 = 4294967283;
      }
    }
    else
    {
      uint64_t v24 = 4294967289;
    }
  }
  else
  {
    uint64_t v24 = 4294967210;
  }
  cc_disable_dit_with_sb((unsigned int *)&v28);
  return v24;
}

uint64_t ccspake_lazy_gen_xy_XY_ws(uint64_t a1, void *a2)
{
  uint64_t v4 = (uint64_t (**)(void, uint64_t, unint64_t *))a2[2];
  uint64_t v5 = (unint64_t *)(*(uint64_t (**)(void))(*a2 + 8))();
  unint64_t v6 = *v5;
  uint64_t v7 = a2 + 42;
  int v8 = (void *)(*(uint64_t (**)(void))(*a2 + 8))();
  if (ccn_n(v6, (uint64_t)&a2[3 * *v8 + 42])) {
    return 0;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  unint64_t v11 = (uint64_t **)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, (24 * v6 + 23) >> 3);
  *unint64_t v11 = (uint64_t *)v5;
  uint64_t v18 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 3 * v6);
  uint64_t v17 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 3 * v6);
  uint64_t v12 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 3 * v6);
  unint64_t v13 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v6);
  uint64_t result = ccec_generate_scalar_fips_retry_ws(a1, v5, (uint64_t (**)(void, unint64_t, void *))a2[2], v13);
  if (!result)
  {
    uint64_t result = ccec_projectify_ws(a1, (uint64_t)v5);
    if (!result)
    {
      uint64_t result = ccec_mult_blinded_ws(a1, v5, v18, (uint64_t)v13, v12, v4);
      if (!result)
      {
        uint64_t result = ccec_projectify_ws(a1, (uint64_t)v5);
        if (!result)
        {
          (*(void (**)(void))(*a2 + 8))();
          uint64_t result = ccec_mult_blinded_ws(a1, v5, v17, (uint64_t)(a2 + 42), v12, v4);
          if (!result)
          {
            ccec_full_add_ws(a1, (uint64_t)v5);
            uint64_t result = ccec_affinify_ws(a1, (uint64_t)v5);
            if (!result)
            {
              uint64_t v14 = (void *)(*(uint64_t (**)(void))(*a2 + 8))();
              unint64_t v15 = ccspake_store_pub_key(v11, (char *)&v7[4 * *v14]);
              uint64_t v16 = (void *)(*(uint64_t (**)(void *))(*a2 + 8))(v15);
              ccn_set(v6, &v7[3 * *v16], v13);
              uint64_t result = 0;
            }
          }
        }
      }
    }
  }
  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t ccspake_kex_process(uint64_t a1, uint64_t a2)
{
  BOOL v53 = timingsafe_enable_if_supported();
  uint64_t v4 = (uint64_t *)(*(uint64_t (**)(void))(*(void *)a1 + 8))();
  uint64_t v5 = *v4;
  uint64_t v6 = sizeof_struct_cche_galois_key();
  unint64_t v7 = sizeof_struct_ccpolyzp_po2cyc();
  v49[0] = cc_malloc_clear(432 * v5 + 16 * ((v6 + v7 + 3 * v5 * v7 - 1) / v7));
  uint64_t v8 = *v4;
  uint64_t v9 = sizeof_struct_cche_galois_key();
  unint64_t v10 = sizeof_struct_ccpolyzp_po2cyc();
  v49[1] = 54 * v8 + 2 * ((v9 + v10 + 3 * v8 * v10 - 1) / v10);
  uint64_t v50 = 0;
  int32x4_t v51 = cc_ws_alloc;
  BOOL v52 = cc_ws_free;
  if (v49[0])
  {
    uint64_t v11 = *(void *)a1;
    uint64_t v12 = (unint64_t *)(*(uint64_t (**)(void))(*(void *)a1 + 8))();
    unint64_t v13 = *v12;
    if (ccspake_sizeof_point(v11) != a2)
    {
      uint64_t v23 = 4294967289;
      goto LABEL_11;
    }
    uint64_t v14 = (uint64_t **)cc_ws_alloc(v49, (24 * v13 + 23) >> 3);
    *uint64_t v14 = (uint64_t *)v12;
    uint64_t v15 = 3 * v13;
    uint64_t v16 = v51(v49, 3 * v13);
    uint64_t v17 = v51(v49, 3 * v13);
    uint64_t v18 = (char *)v51(v49, 3 * v13);
    uint64_t v19 = v51(v49, v15);
    int v48 = (unint64_t *)v51(v49, v15);
    uint64_t v47 = (unint64_t *)v51(v49, v15);
    uint64_t v20 = v51(v49, v15);
    uint64_t v21 = *(uint64_t (***)(void, uint64_t, unint64_t *))(a1 + 16);
    int v22 = *(unsigned __int8 *)(a1 + 60);
    if (v22 != CCSPAKE_STATE_INIT && v22 != CCSPAKE_STATE_KEX_GENERATE)
    {
      uint64_t v23 = 4294967210;
LABEL_11:
      v52((uint64_t)v49);
      goto LABEL_12;
    }
    uint64_t v46 = v20;
    uint64_t v23 = ccspake_import_pub_ws((uint64_t)v49);
    if (!v23)
    {
      uint64_t v23 = ccspake_lazy_gen_xy_XY_ws((uint64_t)v49, (void *)a1);
      if (!v23)
      {
        uint64_t v25 = a1 + 336;
        unsigned int v26 = (void *)(*(uint64_t (**)(void))(*(void *)a1 + 8))();
        if (ccspake_cmp_pub_key(v14, a1 + 336 + 32 * *v26))
        {
          uint64_t v23 = ccec_projectify_ws((uint64_t)v49, (uint64_t)v12);
          if (v23) {
            goto LABEL_10;
          }
          uint64_t v23 = ccec_projectify_ws((uint64_t)v49, (uint64_t)v12);
          if (v23) {
            goto LABEL_10;
          }
          (*(void (**)(void))(*(void *)a1 + 8))();
          uint64_t v23 = ccec_mult_blinded_ws((uint64_t)v49, v12, (uint64_t)v18, a1 + 336, v16, v21);
          if (v23) {
            goto LABEL_10;
          }
          uint64_t v27 = ccec_full_sub_ws((uint64_t)v49, (uint64_t *)v12, v19, v17, v18);
          BOOL v28 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 8))(v27);
          uint64_t v23 = ccec_mult_blinded_ws((uint64_t)v49, v12, (uint64_t)v48, v25 + 24 * *v28, v19, v21);
          if (v23) {
            goto LABEL_10;
          }
          int v29 = *(unsigned __int8 *)(a1 + 24);
          uint64_t v30 = v25 + 8 * *(void *)(*(uint64_t (**)(void))(*(void *)a1 + 8))();
          uint64_t v31 = v12;
          if (v29)
          {
            uint64_t v32 = (uint64_t)v47;
            uint64_t v33 = v19;
          }
          else
          {
            uint64_t v23 = ccec_validate_point_and_projectify_ws((uint64_t)v49, (uint64_t *)v12, v46, v30);
            if (v23) {
              goto LABEL_10;
            }
            uint64_t v30 = v25 + 24 * *(void *)(*(uint64_t (**)(void))(*(void *)a1 + 8))();
            uint64_t v31 = v12;
            uint64_t v33 = v46;
            uint64_t v32 = (uint64_t)v47;
          }
          uint64_t v23 = ccec_mult_blinded_ws((uint64_t)v49, v31, v32, v30, v33, v21);
          if (!v23)
          {
            uint64_t v23 = ccec_affinify_ws((uint64_t)v49, (uint64_t)v12);
            if (!v23)
            {
              uint64_t v23 = ccec_affinify_ws((uint64_t)v49, (uint64_t)v12);
              if (!v23)
              {
                uint64_t v34 = (void *)(*(uint64_t (**)(void))(*(void *)a1 + 8))();
                uint64_t v35 = ccspake_store_pub_key(v14, (char *)(v25 + 48 * *v34));
                int v36 = *(unsigned __int8 *)(a1 + 24);
                uint64_t v37 = *(void *)(*(uint64_t (**)(void *))(*(void *)a1 + 8))(v35);
                uint64_t v38 = *(void *)(*(uint64_t (**)(void))(*(void *)a1 + 8))();
                if (v36)
                {
                  appended = ccspake_transcript_append_point(a1, v12, (unint64_t *)(v25 + 32 * v37), (unint64_t *)(v25 + 40 * v38));
                  uint64_t v40 = 6 * *(void *)(*(uint64_t (**)(unint64_t *))(*(void *)a1 + 8))(appended);
                  uint64_t v41 = 7;
                }
                else
                {
                  long long v42 = ccspake_transcript_append_point(a1, v12, (unint64_t *)(v25 + 48 * v37), (unint64_t *)(v25 + 56 * v38));
                  uint64_t v40 = 4 * *(void *)(*(uint64_t (**)(unint64_t *))(*(void *)a1 + 8))(v42);
                  uint64_t v41 = 5;
                }
                unsigned int v43 = (unint64_t *)(v25 + 8 * v40);
                int v44 = (void *)(*(uint64_t (**)(void))(*(void *)a1 + 8))();
                ccspake_transcript_append_point(a1, v12, v43, (unint64_t *)(v25 + 8 * *v44 * v41));
                ccspake_transcript_append_point(a1, v12, v48, &v48[*v12]);
                uint64_t v45 = ccspake_transcript_append_point(a1, v12, v47, &v47[*v12]);
                (*(void (**)(unint64_t *))(*(void *)a1 + 8))(v45);
                ccspake_transcript_append_scalar(a1, v12, (unint64_t *)(a1 + 336));
                ccspake_transcript_finish(a1, a1 + 272);
                uint64_t v23 = 0;
                *(unsigned char *)(a1 + 60) |= CCSPAKE_STATE_KEX_PROCESS;
              }
            }
          }
          goto LABEL_10;
        }
        uint64_t v23 = 4294967289;
      }
    }
LABEL_10:
    uint64_t v50 = 0;
    goto LABEL_11;
  }
  uint64_t v23 = 4294967283;
LABEL_12:
  cc_disable_dit_with_sb((unsigned int *)&v53);
  return v23;
}

void *ccsha256_di()
{
  return &ccsha256_ltc_di;
}

int8x16_t *ccmode_xts_mult_alpha(int8x16_t *result)
{
  int8x16_t v1 = *result;
  *uint64_t result = vorrq_s8(vaddq_s8(*result, *result), vextq_s8((int8x16_t)0, (int8x16_t)vshrq_n_u8(*(uint8x16_t *)result, 7uLL), 0xFuLL));
  if (v1.i8[15] < 0) {
    result->i8[0] ^= 0x87u;
  }
  return result;
}

uint64_t ccrsa_generate_key(unint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t (**a5)(void, unint64_t, uint64_t))
{
  BOOL v12 = timingsafe_enable_if_supported();
  key_uint64_t internal = ccrsa_generate_key_internal(a1, a2, a3, a4, a5, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return key_internal;
}

uint64_t ccsha3_224_c_compress(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return cckeccak_absorb_blocks(a1, 0x90uLL, a2, a3, cckeccak_f1600_c);
}

uint64_t ccsha3_224_c_final(unint64_t *a1, uint64_t a2, void *a3)
{
  return ccsha3_final(a1, a2, a3, cckeccak_f1600_c);
}

void *ccsha3_224_di()
{
  return &ccsha3_224_c_di;
}

uint64_t ccrsa_make_pub(unint64_t *a1, unint64_t a2, unsigned __int8 *a3, unint64_t a4, unsigned __int8 *a5)
{
  uint64_t v9 = a1 + 3;
  unint64_t v8 = *a1;
  if (ccn_read_uint_public_value(*a1, a1 + 3, a4, a5)
    || ccn_read_uint_public_value(v8, &v9[2 * *a1 + 1], a2, a3))
  {
    return 4294967273;
  }

  return cczp_init(a1);
}

unint64_t CCHE_ENCRYPT_ZERO_SYMMETRIC_HELPER_WORKSPACE_N(unint64_t a1, int a2)
{
  uint64_t v4 = sizeof_struct_ccpolyzp_po2cyc_block_rng_state();
  uint64_t v5 = CCPOLYZP_PO2CYC_RANDOM_UNIFORM_WORKSPACE_N(a1);
  unint64_t v6 = v5 + (a2 * a1) + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3);
  unint64_t v7 = CCPOLYZP_PO2CYC_RANDOM_CBD_WORKSPACE_N(a1);
  if (v6 <= v7) {
    unint64_t v8 = v7;
  }
  else {
    unint64_t v8 = v6;
  }
  return v8 + ((unint64_t)(v4 + 7) >> 3);
}

uint64_t cche_encrypt_zero_symmetric_eval_ws(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t *a4, unsigned int a5, uint64_t a6, uint64_t (**a7)(void, uint64_t, uint64_t))
{
  return cche_encrypt_zero_symmetric_helper_ws(a1, a2, a3, a4, a5, 1, a6, a7);
}

uint64_t cche_encrypt_zero_symmetric_helper_ws(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t *a4, unsigned int a5, int a6, uint64_t a7, uint64_t (**a8)(void, uint64_t, uint64_t))
{
  uint64_t v59 = *MEMORY[0x263EF8C08];
  uint64_t v15 = *(void *)(a1 + 16);
  uint64_t v16 = *a4;
  uint64_t v17 = cche_param_ctx_chain_const((uint64_t)a3);
  BOOL v18 = ccpolyzp_po2cyc_ctx_eq(v16, (_DWORD *)(v17 + 8));
  uint64_t result = 4294967289;
  if (a5 && v18)
  {
    if (*(_DWORD *)(cche_param_ctx_chain_const((uint64_t)a3) + 12) < a5) {
      return 4294967289;
    }
    uint64_t v50 = a4;
    int v51 = a6;
    uint64_t v20 = (unsigned int *)cche_param_ctx_chain_const((uint64_t)a3);
    uint64_t v21 = *v20;
    unint64_t v22 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
    if (v21 >= 0x80) {
      uint64_t v23 = 128;
    }
    else {
      uint64_t v23 = v21;
    }
    uint64_t v24 = &v20[2
             * (v22 + 2 * (v21 + ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v23) + 6)
             * (v20[1] - a5)
             + 2];
    unsigned int v25 = cche_ciphertext_fresh_npolys();
    *(void *)a2 = a3;
    *(_DWORD *)(a2 + 8) = v25;
    *(void *)(a2 + 16) = 1;
    *(void *)(a2 + 24) = v24;
    unsigned int v26 = (unsigned int **)(a2 + 24);
    uint64_t v27 = v24;
    if (v25 >= 2)
    {
      uint64_t v49 = a8;
      uint64_t v28 = v15;
      uint64_t v29 = v25;
      for (uint64_t i = 1; i != v29; ++i)
      {
        uint64_t v31 = *v26;
        v26[(v31[1] * *v31 + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3)) * i] = v24;
      }
      uint64_t v27 = *v26;
      uint64_t v15 = v28;
      a8 = v49;
    }
    unint64_t v32 = v27[1] * *v27 + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3);
    uint64_t v33 = &v26[v32];
    if (a7)
    {
      uint64_t result = (*a8)(a8, 32, a7);
      if (result) {
        goto LABEL_32;
      }
      uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 536);
      uint64_t result = ccpolyzp_po2cyc_block_rng_init(v34);
      if (result) {
        goto LABEL_32;
      }
      uint64_t v35 = a1;
      int v36 = v33;
      uint64_t v37 = (uint64_t (**)(void, uint64_t, uint64_t))v34;
    }
    else
    {
      uint64_t v35 = a1;
      int v36 = &v26[v32];
      uint64_t v37 = a8;
    }
    uint64_t result = ccpolyzp_po2cyc_random_uniform_ws(v35, v36, v37);
    if (!result)
    {
      uint64_t v38 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 24);
      uint64_t v39 = sizeof_struct_ccpolyzp_po2cyc();
      uint64_t v40 = (unsigned int **)v38(a1, v24[1] * *v24 + ((unint64_t)(v39 + 7) >> 3));
      uint64_t v41 = (uint64_t (**)(void, uint64_t, const double *))a8;
      long long v42 = v40;
      *uint64_t v40 = v24;
      uint64_t result = ccpolyzp_po2cyc_random_cbd_ws(a1, v40, v41, 0);
      if (!result)
      {
        if (cche_param_ctx_he_scheme(a3) == 2)
        {
          uint64_t v43 = cche_param_ctx_plaintext_modulus((uint64_t)a3);
          uint64_t v44 = 0;
          uint64_t v58 = 0;
          long long v56 = 0u;
          long long v57 = 0u;
          long long v54 = 0u;
          long long v55 = 0u;
          uint64_t v53 = v43;
          if (a5 <= 1) {
            unsigned int v45 = 1;
          }
          else {
            unsigned int v45 = a5;
          }
          uint64_t v46 = 8 * v45;
          do
          {
            *(uint64_t *)((char *)&v53 + v44) = v43;
            v44 += 8;
          }
          while (v46 != v44);
          ccpolyzp_po2cyc_coeff_scalar_mul_ws(a1, v42, v42, (uint64_t)&v53);
        }
        cche_mul_poly_sk((_DWORD **)(a2 + 24), v33, (_DWORD **)v50);
        if (!v51)
        {
          uint64_t result = ccpolyzp_po2cyc_inv_ntt((unsigned int **)(a2 + 24));
          if (result) {
            goto LABEL_32;
          }
          uint64_t result = ccpolyzp_po2cyc_inv_ntt(v33);
          if (result) {
            goto LABEL_32;
          }
          ccpolyzp_po2cyc_coeff_add((int **)(a2 + 24), a2 + 24, v42);
          ccpolyzp_po2cyc_coeff_negate((int **)(a2 + 24), a2 + 24);
          goto LABEL_31;
        }
        uint64_t result = ccpolyzp_po2cyc_fwd_ntt(v42);
        if (!result)
        {
          ccpolyzp_po2cyc_eval_add(a2 + 24, a2 + 24, v42);
          ccpolyzp_po2cyc_eval_negate(a2 + 24, a2 + 24);
LABEL_31:
          uint64_t v47 = sizeof_struct_ccpolyzp_po2cyc();
          cc_clear((v47 + 8 * v24[1] * *v24 + 7) & 0xFFFFFFFFFFFFFFF8, v42);
          int v48 = cche_ciphertext_fresh_npolys();
          uint64_t result = 0;
          *(_DWORD *)(a2 + 8) = v48;
          *(void *)a2 = a3;
          *(void *)(a2 + 16) = 1;
        }
      }
    }
LABEL_32:
    *(void *)(a1 + 16) = v15;
  }
  return result;
}

uint64_t cche_encrypt_symmetric_ws(uint64_t a1, uint64_t a2, unint64_t *a3, unsigned int *a4, uint64_t *a5, unsigned int a6, uint64_t a7, uint64_t (**a8)(void, uint64_t, uint64_t))
{
  uint64_t result = cche_encrypt_zero_symmetric_helper_ws(a1, a2, a4, a5, a6, 0, a7, a8);
  if (!result)
  {
    return cche_ciphertext_plaintext_add_ws(a1, a2, a2, a3);
  }
  return result;
}

uint64_t cche_encrypt_symmetric(uint64_t a1, unint64_t *a2, unsigned int *a3, uint64_t *a4, unsigned int a5, uint64_t a6, uint64_t (**a7)(void, uint64_t, uint64_t))
{
  BOOL v27 = timingsafe_enable_if_supported();
  unsigned int v14 = cche_param_ctx_polynomial_degree((uint64_t)a3);
  unint64_t v15 = CCHE_ENCRYPT_ZERO_SYMMETRIC_HELPER_WORKSPACE_N(v14, a5);
  unint64_t v16 = CCHE_CIPHERTEXT_PLAINTEXT_ADD_WORKSPACE_N(v14);
  if (v15 <= v16) {
    unint64_t v17 = v16;
  }
  else {
    unint64_t v17 = v15;
  }
  BOOL v18 = cc_malloc_clear(8 * v17);
  v25[0] = v18;
  unsigned int v19 = cche_param_ctx_polynomial_degree((uint64_t)a3);
  unint64_t v20 = CCHE_ENCRYPT_ZERO_SYMMETRIC_HELPER_WORKSPACE_N(v19, a5);
  unint64_t v21 = CCHE_CIPHERTEXT_PLAINTEXT_ADD_WORKSPACE_N(v19);
  if (v20 <= v21) {
    unint64_t v22 = v21;
  }
  else {
    unint64_t v22 = v20;
  }
  v25[1] = v22;
  void v25[2] = 0;
  unsigned char v25[3] = cc_ws_alloc;
  unsigned int v26 = cc_ws_free;
  if (v18)
  {
    uint64_t v23 = cche_encrypt_symmetric_ws((uint64_t)v25, a1, a2, a3, a4, a5, a6, a7);
    v26((uint64_t)v25);
  }
  else
  {
    uint64_t v23 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v27);
  return v23;
}

uint64_t cczp_mm_init_ws(uint64_t a1, uint64_t *a2, uint64_t a3, void *__src)
{
  *a2 = a3;
  ccn_set(a3, a2 + 3, __src);
  uint64_t result = cczp_init_ws(a1, a2);
  a2[2] = (uint64_t)cczp_montgomery_funcs;
  return result;
}

void *cczp_mm_init_copy(void *a1, const void *a2)
{
  uint64_t v4 = cczp_n((uint64_t)a2);
  uint64_t result = memcpy(a1, a2, 16 * v4 + 32);
  a1[2] = cczp_montgomery_funcs;
  return result;
}

uint64_t cczp_mm_power_fast_ws(uint64_t a1, const void *a2, uint64_t *a3, unint64_t *a4, uint64_t a5)
{
  uint64_t v10 = cczp_n((uint64_t)a2);
  uint64_t v11 = cczp_prime((uint64_t)a2);
  if ((ccn_cmp_internal(v10, a4, v11) & 0x80000000) == 0) {
    return 4294967289;
  }
  uint64_t v13 = *(void *)(a1 + 16);
  unsigned int v14 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10);
  unint64_t v15 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10);
  cc_clear(8 * (*(void *)(a1 + 16) - v13), (void *)(*(void *)a1 + 8 * v13));
  unint64_t v16 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 2 * v10 + 4);
  uint64_t v17 = cczp_n((uint64_t)a2);
  memcpy(v16, a2, 16 * v17 + 32);
  _OWORD v16[2] = cczp_montgomery_funcs;
  cczp_mm_to_ws(a1, v16, v14, a4);
  uint64_t v12 = cczp_power_fast_ws(a1, (uint64_t)v16, v15, v14, a5);
  if (!v12) {
    cczp_mm_from_ws(a1, v16, a3, v15);
  }
  *(void *)(a1 + 16) = v13;
  return v12;
}

uint64_t cczp_mm_to_ws(uint64_t a1, void *a2, uint64_t *a3, unint64_t *a4)
{
  unint64_t v8 = cczp_n((uint64_t)a2);
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 2 * v8);
  ccn_mul_ws(a1, v8, v10, a4, &a2[*a2 + 4]);
  uint64_t result = cczp_mm_redc_ws(a1, a2, a3, (uint64_t *)v10);
  *(void *)(a1 + 16) = v9;
  return result;
}

uint64_t cczp_mm_from_ws(uint64_t a1, void *a2, uint64_t *a3, void *a4)
{
  uint64_t v8 = cczp_n((uint64_t)a2);
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 2 * v8);
  if (v8) {
    ccn_set(v8, v10, a4);
  }
  ccn_zero(v8, &v10[8 * v8]);
  uint64_t result = cczp_mm_redc_ws(a1, a2, a3, (uint64_t *)v10);
  *(void *)(a1 + 16) = v9;
  return result;
}

uint64_t cczp_mm_power_ws(uint64_t a1, const void *a2, uint64_t *a3, unint64_t *a4, uint64_t a5, void *a6)
{
  uint64_t v12 = cczp_n((uint64_t)a2);
  uint64_t v13 = cczp_prime((uint64_t)a2);
  if ((ccn_cmp_internal(v12, a4, v13) & 0x80000000) == 0) {
    return 4294967289;
  }
  uint64_t v15 = *(void *)(a1 + 16);
  unint64_t v16 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 2 * v12 + 4);
  uint64_t v17 = cczp_n((uint64_t)a2);
  memcpy(v16, a2, 16 * v17 + 32);
  _OWORD v16[2] = cczp_montgomery_funcs;
  cczp_mm_to_ws(a1, v16, a3, a4);
  uint64_t v14 = cczp_power_ws(a1, (uint64_t)v16, a3, a3, a5, a6);
  if (!v14) {
    cczp_mm_from_ws(a1, v16, a3, a3);
  }
  *(void *)(a1 + 16) = v15;
  return v14;
}

uint64_t cczp_mm_mul_ws(uint64_t a1, void *a2, uint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t v10 = *(void *)(a1 + 16);
  unint64_t v11 = cczp_n((uint64_t)a2);
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 2 * v11);
  ccn_mul_ws(a1, v11, v12, a4, a5);
  uint64_t result = cczp_mm_redc_ws(a1, a2, a3, (uint64_t *)v12);
  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t cczp_mm_sqr_ws(uint64_t a1, void *a2, uint64_t *a3, unint64_t *a4)
{
  uint64_t v8 = *(void *)(a1 + 16);
  unint64_t v9 = cczp_n((uint64_t)a2);
  uint64_t v10 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 2 * v9);
  ccn_sqr_ws(a1, v9, v10, a4);
  uint64_t result = cczp_mm_redc_ws(a1, a2, a3, v10);
  *(void *)(a1 + 16) = v8;
  return result;
}

uint64_t cczp_mm_mod_ws(uint64_t a1, void *a2, uint64_t *a3, void *a4)
{
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = 2 * cczp_n((uint64_t)a2);
  uint64_t v10 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v9);
  ccn_set(v9, v10, a4);
  uint64_t result = cczp_mm_redc_ws(a1, a2, a3, (uint64_t *)v10);
  *(void *)(a1 + 16) = v8;
  return result;
}

void cczp_mm_inv_ws()
{
}

uint64_t sub_23737FC48()
{
  return 0xFFFFFFFFLL;
}

void cczp_mm_sqrt_ws()
{
}

uint64_t sub_23737FC6C()
{
  return 0xFFFFFFFFLL;
}

void *ccec448_add_ws(uint64_t a1, uint64_t a2, void *a3, void *a4, unint64_t *a5)
{
  v36[7] = *MEMORY[0x263EF8C08];
  unint64_t v6 = a5[1];
  long long v7 = *a5 + *(_OWORD *)a4;
  BOOL v8 = __CFADD__(__CFADD__(*a5, *a4), a4[1]);
  uint64_t v9 = a4[2];
  uint64_t v10 = a4[3];
  unint64_t v11 = a5[2];
  unint64_t v12 = a5[3];
  BOOL v29 = __CFADD__(v11, v9);
  uint64_t v13 = v11 + v9;
  uint64_t v14 = v29;
  BOOL v29 = __CFADD__(v12, v10);
  uint64_t v15 = v12 + v10;
  uint64_t v16 = v29;
  uint64_t v17 = a4[4];
  uint64_t v18 = a4[5];
  unint64_t v19 = a5[4];
  unint64_t v20 = a5[5];
  BOOL v29 = __CFADD__(v19, v17);
  uint64_t v21 = v19 + v17;
  uint64_t v22 = v29;
  BOOL v29 = __CFADD__(v20, v18);
  uint64_t v23 = v20 + v18;
  uint64_t v24 = v29;
  v36[0] = *a5 + *a4;
  v36[1] = *((void *)&v7 + 1) + v6;
  BOOL v29 = __CFADD__(__CFADD__(__CFADD__(*((void *)&v7 + 1), v6), v13) | __CFADD__(v8, __CFADD__(*((void *)&v7 + 1), v6)+ v13), v15);
  uint64_t v25 = (__CFADD__(__CFADD__(*((void *)&v7 + 1), v6), v13) | __CFADD__(v8, __CFADD__(*((void *)&v7 + 1), v6)+ v13))+ v15;
  void v36[2] = v8 + __CFADD__(*((void *)&v7 + 1), v6) + v13;
  v36[3] = v14 + v25;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  v36[4] = v16 + (v29 | __CFADD__(v14, v25)) + v21;
  v36[5] = v22
         + (__CFADD__(v29 | __CFADD__(v14, v25), v21) | __CFADD__(v16, (v29 | __CFADD__(v14, v25))+ v21))+ v23;
  uint64_t v27 = a4[6];
  unint64_t v28 = a5[6];
  BOOL v29 = __CFADD__(v28, v27);
  uint64_t v30 = v28 + v27;
  uint64_t v31 = v29;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), StatusReg);
  BOOL v33 = v29;
  BOOL v29 = __CFADD__(v29, v30);
  uint64_t v32 = v33 + v30;
  v29 |= __CFADD__(v24, v32);
  v32 += v24;
  if (v29) {
    uint64_t v34 = v31 + 1;
  }
  else {
    uint64_t v34 = v31;
  }
  v36[6] = v32;
  return ccec448_redc_one(a3, (uint64_t)v36, v34);
}

void *ccec448_redc_one(void *result, uint64_t a2, uint64_t a3)
{
  long long v3 = *(_OWORD *)a2 + a3;
  uint64_t v6 = *(void *)(a2 + 32);
  uint64_t v5 = ((unsigned __int128)__CFADD__(__CFADD__(*(void *)a2, a3), *(void *)(a2 + 8)) + *(_OWORD *)(a2 + 16)) >> 64;
  uint64_t v4 = __CFADD__(__CFADD__(*(void *)a2, a3), *(void *)(a2 + 8)) + *(void *)(a2 + 16);
  BOOL v11 = __CFADD__(__CFADD__(__CFADD__(__CFADD__(*(void *)a2, a3), *(void *)(a2 + 8)), *(void *)(a2 + 16)), *(void *)(a2 + 24)) | __CFADD__(a3 << 32, v5);
  uint64_t v7 = (a3 << 32) + v5;
  result[4] = v11 + v6;
  uint64_t v8 = *(void *)(a2 + 40);
  BOOL v9 = __CFADD__(v11, v6);
  BOOL v11 = __CFADD__(v9, v8);
  result[5] = v9 + v8;
  uint64_t v10 = *(void *)(a2 + 48);
  BOOL v13 = v11;
  BOOL v11 = __CFADD__(v11, v10);
  uint64_t v12 = v13 + v10;
  uint64_t v14 = v11;
  result[6] = v12;
  BOOL v15 = v11;
  BOOL v11 = __CFADD__(v11, (void)v3);
  *uint64_t result = v15 + v3;
  result[1] = v11 + *((void *)&v3 + 1);
  result[2] = __CFADD__(v11, *((void *)&v3 + 1)) + v4;
  result[3] = (v14 << 32) + __CFADD__(__CFADD__(v11, *((void *)&v3 + 1)), v4) + v7;
  return result;
}

void ccec448_sub_ws(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4, void *a5)
{
  unsigned long long v5 = *a4 - __PAIR128__(*a5, *a5);
  unsigned long long v6 = a4[1] - __PAIR128__(a5[1], a5[1]) + __PAIR128__(*((uint64_t *)&v5 + 1) >> 63, *((uint64_t *)&v5 + 1) >> 63);
  unsigned long long v7 = a4[2] - __PAIR128__(a5[2], a5[2]) + __PAIR128__(*((uint64_t *)&v6 + 1) >> 63, *((uint64_t *)&v6 + 1) >> 63);
  unsigned long long v8 = a4[3]
     - __PAIR128__((a4[2] - __PAIR128__(a5[2], a5[2])) >> 64, a5[3])
     + __PAIR128__(*((uint64_t *)&v7 + 1) >> 63, *((uint64_t *)&v7 + 1) >> 63);
  unsigned long long v9 = a4[4] - __PAIR128__(a5[4], a5[4]) + __PAIR128__(*((uint64_t *)&v8 + 1) >> 63, *((uint64_t *)&v8 + 1) >> 63);
  uint64_t v11 = (a4[5] - __PAIR128__(a5[5], a5[5]) + __PAIR128__(*((uint64_t *)&v9 + 1) >> 63, *((uint64_t *)&v9 + 1) >> 63)) >> 64;
  uint64_t v10 = a4[5] - a5[5] + (*((uint64_t *)&v9 + 1) >> 63);
  unint64_t v13 = (a4[6] - __PAIR128__(a5[6], a5[6]) + __PAIR128__(v11 >> 63, v11 >> 63)) >> 64;
  uint64_t v12 = a4[6] - a5[6] + (v11 >> 63);
  unint64_t v14 = v13 >> 63;
  unsigned long long v15 = (unint64_t)v5 - __PAIR128__(v13, v13 >> 63);
  uint64_t v16 = v6 + (*((uint64_t *)&v15 + 1) >> 63);
  if (__CFADD__((void)v6, *((uint64_t *)&v15 + 1) >> 63)) {
    uint64_t v17 = (*((uint64_t *)&v15 + 1) >> 63) + 1;
  }
  else {
    uint64_t v17 = *((uint64_t *)&v15 + 1) >> 63;
  }
  uint64_t v18 = v7 + (v17 >> 63);
  if (__CFADD__((void)v7, v17 >> 63)) {
    uint64_t v19 = (v17 >> 63) + 1;
  }
  else {
    uint64_t v19 = v17 >> 63;
  }
  unsigned long long v20 = (unint64_t)v8 - __PAIR128__(v14, v14 << 32) + __PAIR128__(v19 >> 63, v19 >> 63);
  if (__CFADD__((void)v9, *((uint64_t *)&v20 + 1) >> 63)) {
    uint64_t v21 = (*((uint64_t *)&v20 + 1) >> 63) + 1;
  }
  else {
    uint64_t v21 = *((uint64_t *)&v20 + 1) >> 63;
  }
  BOOL v22 = __CFADD__(v10, v21 >> 63);
  uint64_t v23 = v10 + (v21 >> 63);
  if (v22) {
    uint64_t v24 = (v21 >> 63) + 1;
  }
  else {
    uint64_t v24 = v21 >> 63;
  }
  a3[4] = v9 + (*((uint64_t *)&v20 + 1) >> 63);
  a3[5] = v23;
  unint64_t v25 = v24 >> 63;
  if (__CFADD__(v12, v24 >> 63)) {
    ++v25;
  }
  a3[6] = v12 + (*((uint64_t *)&v15 + 1) >> 63);
  unint64_t v26 = v25 >> 63;
  unsigned long long v27 = (unint64_t)v15 - __PAIR128__(v25, v25 >> 63);
  BOOL v22 = __CFADD__(v16, *((uint64_t *)&v27 + 1) >> 63);
  uint64_t v28 = v16 + (*((uint64_t *)&v27 + 1) >> 63);
  if (v22) {
    uint64_t v29 = (*((uint64_t *)&v27 + 1) >> 63) + 1;
  }
  else {
    uint64_t v29 = *((uint64_t *)&v27 + 1) >> 63;
  }
  *a3 = v27;
  a3[1] = v28;
  uint64_t v30 = *((uint64_t *)&v27 + 1) >> 63;
  if (__CFADD__(v18, *((uint64_t *)&v27 + 1) >> 63)) {
    ++v30;
  }
  a3[2] = v18 + (v29 >> 63);
  a3[3] = v20 - (v26 << 32) + (v30 >> 63);
}

void *ccec448_mul_ws(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4, unint64_t *a5)
{
  v254[14] = *MEMORY[0x263EF8C08];
  unint64_t v6 = *a4;
  unint64_t v7 = a4[1];
  unint64_t v8 = *a5;
  unint64_t v9 = a5[1];
  uint64_t v10 = (v7 * (unsigned __int128)*a5) >> 64;
  unint64_t v11 = (*(_OWORD *)a4 * *a5) >> 64;
  BOOL v12 = __CFADD__(v7 * *a5, (*a5 * (unsigned __int128)*a4) >> 64);
  unint64_t v13 = v9 * v6;
  uint64_t v14 = (v9 * (unsigned __int128)v6) >> 64;
  uint64_t v15 = v14 + v10;
  uint64_t v16 = __CFADD__(v14, v10);
  unint64_t v18 = a4[2];
  unint64_t v17 = a4[3];
  uint64_t v19 = (v18 * (unsigned __int128)v8) >> 64;
  uint64_t v20 = (v9 * (unsigned __int128)v7) >> 64;
  unint64_t v22 = a5[2];
  unint64_t v21 = a5[3];
  uint64_t v23 = (v22 * (unsigned __int128)v6) >> 64;
  unint64_t v24 = v22 * v6;
  unint64_t v25 = v18 * v8 + v9 * v7;
  uint64_t v26 = __CFADD__(v18 * v8, v9 * v7);
  BOOL v27 = __CFADD__(v25, v24);
  unint64_t v28 = v25 + v24;
  if (v27) {
    ++v26;
  }
  BOOL v27 = __CFADD__(v19, v20);
  uint64_t v29 = v19 + v20;
  uint64_t v30 = v27;
  BOOL v27 = __CFADD__(v29, v23);
  uint64_t v31 = v29 + v23;
  if (v27) {
    ++v30;
  }
  v254[0] = *a5 * *a4;
  v254[1] = v11 + v13;
  BOOL v32 = v12 + __CFADD__(v11, v13) + v15;
  BOOL v27 = __CFADD__(__CFADD__(__CFADD__(v11, v13), v15) | __CFADD__(v12, __CFADD__(v11, v13) + v15), v31);
  unint64_t v33 = (__CFADD__(__CFADD__(v11, v13), v15) | __CFADD__(v12, __CFADD__(v11, v13) + v15)) + v31;
  v27 |= __CFADD__(v16, v33);
  v33 += v16;
  if (v27) {
    uint64_t v34 = v30 + 1;
  }
  else {
    uint64_t v34 = v30;
  }
  uint64_t v35 = (v17 * (unsigned __int128)v8) >> 64;
  unint64_t v36 = v17 * v8;
  uint64_t v37 = (v18 * (unsigned __int128)v9) >> 64;
  uint64_t v38 = (v22 * (unsigned __int128)v7) >> 64;
  uint64_t v39 = (v21 * (unsigned __int128)v6) >> 64;
  unint64_t v40 = v21 * v6;
  unint64_t v41 = v22 * v7 + v18 * v9;
  uint64_t v42 = __CFADD__(v22 * v7, v18 * v9);
  BOOL v27 = __CFADD__(v41, v36);
  unint64_t v43 = v41 + v36;
  if (v27) {
    ++v42;
  }
  unint64_t v44 = v43 + v40;
  if (__CFADD__(v43, v40)) {
    uint64_t v45 = v42 + 1;
  }
  else {
    uint64_t v45 = v42;
  }
  BOOL v27 = __CFADD__(v38, v37);
  uint64_t v46 = v38 + v37;
  uint64_t v47 = v27;
  BOOL v27 = __CFADD__(v46, v35);
  uint64_t v48 = v46 + v35;
  if (v27) {
    uint64_t v49 = v47 + 1;
  }
  else {
    uint64_t v49 = v47;
  }
  BOOL v27 = __CFADD__(v48, v39);
  uint64_t v50 = v48 + v39;
  if (v27) {
    ++v49;
  }
  unint64_t v52 = v28 + v32;
  BOOL v27 = __CFADD__(__CFADD__(v28, v32), v33) | __CFADD__(v26, (__PAIR128__(v33, v28) + v32) >> 64);
  uint64_t v51 = v26 + ((__PAIR128__(v33, v28) + v32) >> 64);
  uint64_t v53 = v34 + v27 + v50;
  if (__CFADD__(v27, v50) | __CFADD__(v34, v27 + v50)) {
    ++v49;
  }
  unint64_t v54 = a4[4];
  unint64_t v55 = a4[5];
  unint64_t v56 = v54 * v8;
  uint64_t v57 = (v17 * (unsigned __int128)v9) >> 64;
  uint64_t v58 = (v22 * (unsigned __int128)v18) >> 64;
  unint64_t v59 = v21 * v7;
  unint64_t v60 = v17 * v9 + v22 * v18;
  uint64_t v61 = __CFADD__(v17 * v9, v22 * v18);
  BOOL v27 = __CFADD__(v60, v59);
  unint64_t v62 = v60 + v59;
  if (v27) {
    ++v61;
  }
  BOOL v27 = __CFADD__(v62, v56);
  unint64_t v63 = v62 + v56;
  unint64_t v64 = a5[4];
  unint64_t v65 = a5[5];
  unint64_t v66 = v64 * v6;
  if (v27) {
    ++v61;
  }
  BOOL v27 = __CFADD__(v63, v66);
  unint64_t v67 = v63 + v66;
  uint64_t v68 = (v21 * (unsigned __int128)v7) >> 64;
  if (v27) {
    ++v61;
  }
  BOOL v27 = __CFADD__(v57, v58);
  uint64_t v69 = v57 + v58;
  uint64_t v70 = v27;
  BOOL v27 = __CFADD__(v69, v68);
  uint64_t v71 = v69 + v68;
  uint64_t v72 = (v54 * (unsigned __int128)v8) >> 64;
  if (v27) {
    ++v70;
  }
  BOOL v27 = __CFADD__(v71, v72);
  uint64_t v73 = v71 + v72;
  uint64_t v74 = (v64 * (unsigned __int128)v6) >> 64;
  if (v27) {
    ++v70;
  }
  BOOL v27 = __CFADD__(v73, v74);
  uint64_t v75 = v73 + v74;
  if (v27) {
    ++v70;
  }
  v254[2] = v52;
  v254[3] = v44 + v51;
  BOOL v27 = __CFADD__(__CFADD__(v44, v51), v53) | __CFADD__(v45, __CFADD__(v44, v51) + v53);
  uint64_t v76 = v45 + __CFADD__(v44, v51) + v53;
  uint64_t v77 = v49 + v27 + v75;
  if (__CFADD__(v27, v75) | __CFADD__(v49, v27 + v75)) {
    uint64_t v78 = v70 + 1;
  }
  else {
    uint64_t v78 = v70;
  }
  unint64_t v79 = v55 * v8;
  unint64_t v80 = v54 * v9;
  uint64_t v81 = (v54 * (unsigned __int128)v9) >> 64;
  unint64_t v82 = v21 * v18 + v17 * v22;
  uint64_t v83 = __CFADD__(v21 * v18, v17 * v22);
  BOOL v27 = __CFADD__(v82, v80);
  unint64_t v84 = v82 + v80;
  unint64_t v85 = v64 * v7;
  if (v27) {
    ++v83;
  }
  BOOL v27 = __CFADD__(v84, v85);
  unint64_t v86 = v84 + v85;
  uint64_t v87 = (v17 * (unsigned __int128)v22) >> 64;
  if (v27) {
    ++v83;
  }
  BOOL v27 = __CFADD__(v86, v79);
  unint64_t v88 = v86 + v79;
  unint64_t v89 = v65 * v6;
  if (v27) {
    ++v83;
  }
  BOOL v27 = __CFADD__(v88, v89);
  unint64_t v90 = v88 + v89;
  uint64_t v91 = (v21 * (unsigned __int128)v18) >> 64;
  if (v27) {
    ++v83;
  }
  BOOL v27 = __CFADD__(v91, v87);
  uint64_t v92 = v91 + v87;
  uint64_t v93 = v27;
  BOOL v27 = __CFADD__(v92, v81);
  uint64_t v94 = v92 + v81;
  uint64_t v95 = (v64 * (unsigned __int128)v7) >> 64;
  if (v27) {
    ++v93;
  }
  BOOL v27 = __CFADD__(v94, v95);
  uint64_t v96 = v94 + v95;
  uint64_t v97 = (v55 * (unsigned __int128)v8) >> 64;
  if (v27) {
    ++v93;
  }
  BOOL v27 = __CFADD__(v96, v97);
  uint64_t v98 = v96 + v97;
  uint64_t v99 = (v65 * (unsigned __int128)v6) >> 64;
  if (v27) {
    ++v93;
  }
  BOOL v27 = __CFADD__(v98, v99);
  uint64_t v100 = v98 + v99;
  if (v27) {
    uint64_t v101 = v93 + 1;
  }
  else {
    uint64_t v101 = v93;
  }
  BOOL v27 = __CFADD__(v67, v76);
  uint64_t v102 = v67 + v76;
  BOOL v104 = v27;
  BOOL v27 = __CFADD__(v27, v77);
  uint64_t v103 = v104 + v77;
  v27 |= __CFADD__(v61, v103);
  v103 += v61;
  uint64_t v106 = v27 + v100;
  BOOL v27 = __CFADD__(v27, v100) | __CFADD__(v78, v106);
  uint64_t v105 = v78 + v106;
  if (v27) {
    uint64_t v107 = v101 + 1;
  }
  else {
    uint64_t v107 = v101;
  }
  v254[4] = v102;
  v254[5] = v90 + v103;
  unint64_t v108 = a4[6];
  uint64_t v109 = (v54 * (unsigned __int128)v22) >> 64;
  uint64_t v110 = (v21 * (unsigned __int128)v17) >> 64;
  uint64_t v111 = (v64 * (unsigned __int128)v18) >> 64;
  BOOL v27 = __CFADD__(v109, v110);
  uint64_t v112 = v109 + v110;
  uint64_t v113 = v27;
  BOOL v27 = __CFADD__(v112, v111);
  uint64_t v114 = v112 + v111;
  uint64_t v115 = (v55 * (unsigned __int128)v9) >> 64;
  if (v27) {
    ++v113;
  }
  BOOL v27 = __CFADD__(v114, v115);
  uint64_t v116 = v114 + v115;
  uint64_t v117 = (v65 * (unsigned __int128)v7) >> 64;
  if (v27) {
    ++v113;
  }
  BOOL v27 = __CFADD__(v116, v117);
  uint64_t v118 = v116 + v117;
  uint64_t v119 = (v108 * (unsigned __int128)v8) >> 64;
  unint64_t v120 = a5[6];
  if (v27) {
    uint64_t v121 = v113 + 1;
  }
  else {
    uint64_t v121 = v113;
  }
  BOOL v27 = __CFADD__(v118, v119);
  uint64_t v122 = v118 + v119;
  uint64_t v123 = (v120 * (unsigned __int128)v6) >> 64;
  if (v27) {
    ++v121;
  }
  BOOL v27 = __CFADD__(v122, v123);
  uint64_t v124 = v122 + v123;
  if (v27) {
    ++v121;
  }
  BOOL v27 = __CFADD__(__CFADD__(v90, v103), v105);
  unint64_t v125 = __CFADD__(v90, v103) + v105;
  v27 |= __CFADD__(v83, v125);
  v125 += v83;
  unint64_t v126 = v108 * v8;
  unint64_t v127 = v55 * v9;
  unint64_t v128 = v54 * v22;
  unint64_t v129 = v21 * v17;
  uint64_t v131 = v27 + v124;
  BOOL v27 = __CFADD__(v27, v124) | __CFADD__(v107, v131);
  unint64_t v130 = v107 + v131;
  unint64_t v132 = v64 * v18;
  if (v27) {
    uint64_t v133 = v121 + 1;
  }
  else {
    uint64_t v133 = v121;
  }
  unint64_t v134 = v128 + v129;
  uint64_t v135 = __CFADD__(v128, v129);
  BOOL v27 = __CFADD__(v134, v132);
  unint64_t v136 = v134 + v132;
  unint64_t v137 = v65 * v7;
  unint64_t v138 = v120 * v6;
  if (v27) {
    ++v135;
  }
  BOOL v27 = __CFADD__(v136, v127);
  unint64_t v139 = v136 + v127;
  if (v27) {
    uint64_t v140 = v135 + 1;
  }
  else {
    uint64_t v140 = v135;
  }
  BOOL v27 = __CFADD__(v139, v137);
  unint64_t v141 = v139 + v137;
  if (v27) {
    ++v140;
  }
  BOOL v27 = __CFADD__(v141, v126);
  unint64_t v142 = v141 + v126;
  if (v27) {
    uint64_t v143 = v140 + 1;
  }
  else {
    uint64_t v143 = v140;
  }
  BOOL v27 = __CFADD__(v142, v138);
  unint64_t v144 = v142 + v138;
  if (v27) {
    uint64_t v145 = v143 + 1;
  }
  else {
    uint64_t v145 = v143;
  }
  unint64_t v147 = v144 + v125;
  BOOL v27 = __CFADD__(__CFADD__(v144, v125), v130) | __CFADD__(v145, (__PAIR128__(v130, v144) + v125) >> 64);
  uint64_t v146 = v145 + ((__PAIR128__(v130, v144) + v125) >> 64);
  if (v27) {
    uint64_t v148 = v133 + 1;
  }
  else {
    uint64_t v148 = v133;
  }
  uint64_t v149 = (v108 * (unsigned __int128)v9) >> 64;
  unint64_t v150 = v108 * v9;
  unint64_t v151 = v55 * v22;
  uint64_t v152 = (v55 * (unsigned __int128)v22) >> 64;
  uint64_t v153 = (v54 * (unsigned __int128)v21) >> 64;
  unint64_t v154 = v64 * v17 + v54 * v21;
  uint64_t v155 = __CFADD__(v64 * v17, v54 * v21);
  BOOL v27 = __CFADD__(v154, v151);
  unint64_t v156 = v154 + v151;
  unint64_t v157 = v65 * v18;
  if (v27) {
    ++v155;
  }
  BOOL v27 = __CFADD__(v156, v157);
  unint64_t v158 = v156 + v157;
  uint64_t v159 = (v64 * (unsigned __int128)v17) >> 64;
  if (v27) {
    ++v155;
  }
  BOOL v27 = __CFADD__(v158, v150);
  unint64_t v160 = v158 + v150;
  unint64_t v161 = v120 * v7;
  if (v27) {
    ++v155;
  }
  BOOL v27 = __CFADD__(v160, v161);
  unint64_t v162 = v160 + v161;
  uint64_t v163 = (v65 * (unsigned __int128)v18) >> 64;
  uint64_t v164 = (v120 * (unsigned __int128)v7) >> 64;
  if (v27) {
    ++v155;
  }
  BOOL v27 = __CFADD__(v159, v153);
  uint64_t v165 = v159 + v153;
  uint64_t v166 = v27;
  BOOL v27 = __CFADD__(v165, v152);
  uint64_t v167 = v165 + v152;
  if (v27) {
    uint64_t v168 = v166 + 1;
  }
  else {
    uint64_t v168 = v166;
  }
  BOOL v27 = __CFADD__(v167, v163);
  uint64_t v169 = v167 + v163;
  if (v27) {
    uint64_t v170 = v168 + 1;
  }
  else {
    uint64_t v170 = v168;
  }
  BOOL v27 = __CFADD__(v169, v149);
  uint64_t v171 = v169 + v149;
  if (v27) {
    uint64_t v172 = v170 + 1;
  }
  else {
    uint64_t v172 = v170;
  }
  BOOL v27 = __CFADD__(v171, v164);
  uint64_t v173 = v171 + v164;
  if (v27) {
    uint64_t v174 = v172 + 1;
  }
  else {
    uint64_t v174 = v172;
  }
  BOOL v27 = __CFADD__(v173, v148);
  uint64_t v175 = v173 + v148;
  if (v27) {
    uint64_t v176 = v174 + 1;
  }
  else {
    uint64_t v176 = v174;
  }
  unint64_t v177 = v108 * v22;
  uint64_t v178 = (v55 * (unsigned __int128)v21) >> 64;
  unint64_t v179 = v65 * v17;
  unint64_t v180 = v55 * v21 + v64 * v54;
  uint64_t v181 = __CFADD__(v55 * v21, v64 * v54);
  BOOL v27 = __CFADD__(v180, v179);
  unint64_t v182 = v180 + v179;
  uint64_t v183 = (v64 * (unsigned __int128)v54) >> 64;
  if (v27) {
    ++v181;
  }
  BOOL v27 = __CFADD__(v182, v177);
  unint64_t v184 = v182 + v177;
  unint64_t v185 = v120 * v18;
  if (v27) {
    ++v181;
  }
  BOOL v27 = __CFADD__(v184, v185);
  unint64_t v186 = v184 + v185;
  uint64_t v187 = (v65 * (unsigned __int128)v17) >> 64;
  if (v27) {
    ++v181;
  }
  BOOL v27 = __CFADD__(v178, v183);
  uint64_t v188 = v178 + v183;
  uint64_t v189 = v27;
  BOOL v27 = __CFADD__(v188, v187);
  uint64_t v190 = v188 + v187;
  uint64_t v191 = (v108 * (unsigned __int128)v22) >> 64;
  if (v27) {
    uint64_t v192 = v189 + 1;
  }
  else {
    uint64_t v192 = v189;
  }
  BOOL v27 = __CFADD__(v190, v191);
  uint64_t v193 = v190 + v191;
  uint64_t v194 = (v120 * (unsigned __int128)v18) >> 64;
  if (v27) {
    uint64_t v195 = v192 + 1;
  }
  else {
    uint64_t v195 = v192;
  }
  BOOL v27 = __CFADD__(v193, v194);
  uint64_t v196 = v193 + v194;
  if (v27) {
    uint64_t v197 = v195 + 1;
  }
  else {
    uint64_t v197 = v195;
  }
  v254[6] = v147;
  v254[7] = v162 + v146;
  BOOL v27 = __CFADD__(__CFADD__(v162, v146), v175);
  uint64_t v198 = __CFADD__(v162, v146) + v175;
  v27 |= __CFADD__(v155, v198);
  v198 += v155;
  BOOL v200 = v27;
  BOOL v27 = __CFADD__(v27, v196);
  uint64_t v199 = v200 + v196;
  v27 |= __CFADD__(v176, v199);
  v199 += v176;
  if (v27) {
    ++v197;
  }
  uint64_t v201 = (v108 * (unsigned __int128)v21) >> 64;
  unint64_t v202 = v108 * v21;
  uint64_t v203 = (v55 * (unsigned __int128)v64) >> 64;
  unint64_t v204 = v65 * v54 + v55 * v64;
  uint64_t v205 = __CFADD__(v65 * v54, v55 * v64);
  BOOL v27 = __CFADD__(v204, v202);
  unint64_t v206 = v204 + v202;
  unint64_t v207 = v120 * v17;
  if (v27) {
    ++v205;
  }
  BOOL v27 = __CFADD__(v206, v207);
  unint64_t v208 = v206 + v207;
  uint64_t v209 = (v65 * (unsigned __int128)v54) >> 64;
  if (v27) {
    ++v205;
  }
  BOOL v27 = __CFADD__(v209, v203);
  uint64_t v210 = v209 + v203;
  uint64_t v211 = v27;
  BOOL v27 = __CFADD__(v210, v201);
  uint64_t v212 = v210 + v201;
  uint64_t v213 = (v120 * (unsigned __int128)v17) >> 64;
  if (v27) {
    uint64_t v214 = v211 + 1;
  }
  else {
    uint64_t v214 = v211;
  }
  BOOL v27 = __CFADD__(v212, v213);
  uint64_t v215 = v212 + v213;
  if (v27) {
    uint64_t v216 = v214 + 1;
  }
  else {
    uint64_t v216 = v214;
  }
  BOOL v27 = __CFADD__(v186, v198);
  uint64_t v217 = v186 + v198;
  BOOL v219 = v27;
  BOOL v27 = __CFADD__(v27, v199);
  uint64_t v218 = v219 + v199;
  v27 |= __CFADD__(v181, v218);
  v218 += v181;
  BOOL v221 = v27;
  BOOL v27 = __CFADD__(v27, v215);
  uint64_t v220 = v221 + v215;
  v27 |= __CFADD__(v197, v220);
  v220 += v197;
  if (v27) {
    uint64_t v222 = v216 + 1;
  }
  else {
    uint64_t v222 = v216;
  }
  uint64_t v223 = (v108 * (unsigned __int128)v64) >> 64;
  unint64_t v224 = v108 * v64;
  unint64_t v225 = v120 * v54;
  BOOL v27 = __CFADD__(v224, v65 * v55);
  unint64_t v226 = v224 + v65 * v55;
  uint64_t v227 = v27;
  BOOL v27 = __CFADD__(v226, v225);
  unint64_t v228 = v226 + v225;
  uint64_t v229 = (v65 * (unsigned __int128)v55) >> 64;
  uint64_t v230 = (v120 * (unsigned __int128)v54) >> 64;
  if (v27) {
    ++v227;
  }
  BOOL v27 = __CFADD__(v223, v229);
  uint64_t v231 = v223 + v229;
  uint64_t v232 = v27;
  BOOL v27 = __CFADD__(v231, v230);
  uint64_t v233 = v231 + v230;
  if (v27) {
    uint64_t v234 = v232 + 1;
  }
  else {
    uint64_t v234 = v232;
  }
  v254[8] = v217;
  v254[9] = v208 + v218;
  BOOL v27 = __CFADD__(__CFADD__(v208, v218), v220);
  uint64_t v235 = __CFADD__(v208, v218) + v220;
  v27 |= __CFADD__(v205, v235);
  v235 += v205;
  uint64_t v236 = v222 + v27 + v233;
  if (__CFADD__(v27, v233) | __CFADD__(v222, v27 + v233)) {
    uint64_t v237 = v234 + 1;
  }
  else {
    uint64_t v237 = v234;
  }
  uint64_t v238 = (v108 * (unsigned __int128)v65) >> 64;
  uint64_t v239 = (v120 * (unsigned __int128)v55) >> 64;
  unint64_t v240 = v120 * v55;
  unint64_t v241 = v240 + v108 * v65;
  BOOL v242 = __CFADD__(v240, v108 * v65);
  BOOL v27 = __CFADD__(v239, v238);
  uint64_t v243 = v239 + v238;
  uint64_t v244 = v27;
  BOOL v27 = __CFADD__(v228, v235);
  uint64_t v245 = v228 + v235;
  BOOL v247 = v27;
  BOOL v27 = __CFADD__(v27, v236);
  uint64_t v246 = v247 + v236;
  v27 |= __CFADD__(v227, v246);
  v246 += v227;
  uint64_t v249 = v27 + v243;
  BOOL v27 = __CFADD__(v27, v243) | __CFADD__(v237, v249);
  uint64_t v248 = v237 + v249;
  if (v27) {
    uint64_t v250 = v244 + 1;
  }
  else {
    uint64_t v250 = v244;
  }
  v254[10] = v245;
  v254[11] = v241 + v246;
  BOOL v27 = __CFADD__(__CFADD__(v241, v246), v248) | __CFADD__(v242, __CFADD__(v241, v246) + v248);
  BOOL v251 = v242 + __CFADD__(v241, v246) + v248;
  unint64_t v252 = v120 * v108;
  if (v27) {
    ++v250;
  }
  v254[12] = v251 + v252;
  v254[13] = ((v120 * (unsigned __int128)v108) >> 64) + __CFADD__(v251, v252) + v250;
  return ccec448_redc_full(a3, v254);
}

void *ccec448_redc_full(void *a1, void *a2)
{
  v78[7] = *MEMORY[0x263EF8C08];
  uint64_t v3 = a2[6];
  uint64_t v2 = a2[7];
  unint64_t v5 = (unint64_t)(v2 + *(_OWORD *)a2) >> 64;
  unint64_t v4 = v2 + *a2;
  BOOL v6 = __CFADD__(__CFADD__(v2, *a2), a2[1]);
  unint64_t v7 = a2[8];
  uint64_t v8 = a2[9];
  uint64_t v9 = a2[2];
  uint64_t v10 = a2[3];
  BOOL v41 = __CFADD__(v8, v9);
  unint64_t v11 = v8 + v9;
  uint64_t v12 = v41;
  uint64_t v13 = a2[10];
  uint64_t v14 = a2[11];
  BOOL v41 = __CFADD__(v13, v10);
  uint64_t v15 = v13 + v10;
  uint64_t v16 = v41;
  uint64_t v17 = a2[4];
  uint64_t v18 = a2[5];
  BOOL v41 = __CFADD__(v14, v17);
  uint64_t v19 = v14 + v17;
  uint64_t v20 = v41;
  uint64_t v22 = a2[12];
  uint64_t v21 = a2[13];
  BOOL v41 = __CFADD__(v22, v18);
  uint64_t v23 = v22 + v18;
  uint64_t v24 = v41;
  BOOL v41 = __CFADD__(v21, v3);
  uint64_t v25 = v21 + v3;
  uint64_t v26 = v41;
  unint64_t v28 = v5 + v7;
  BOOL v41 = __CFADD__(__CFADD__(v5, v7), v11) | __CFADD__(v6, (__PAIR128__(v11, v5) + v7) >> 64);
  uint64_t v27 = v6 + ((__PAIR128__(v11, v5) + v7) >> 64);
  uint64_t v29 = v12 + v41 + v15;
  uint64_t v31 = __CFADD__(v41, v15) | __CFADD__(v12, v41 + v15);
  uint64_t v30 = v16 + v31 + v19;
  uint64_t v33 = __CFADD__(v31, v19) | __CFADD__(v16, v31 + v19);
  uint64_t v32 = v20 + v33 + v23;
  uint64_t v34 = v24 + (__CFADD__(v33, v23) | __CFADD__(v20, v33 + v23)) + v25;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  BOOL v41 = __CFADD__(v13 & 0xFFFFFFFF00000000, v29);
  unint64_t v36 = (v13 & 0xFFFFFFFF00000000) + v29;
  BOOL v38 = v41;
  BOOL v41 = __CFADD__(v41, v30);
  uint64_t v37 = v38 + v30;
  v41 |= __CFADD__(v14, v37);
  v37 += v14;
  BOOL v40 = v41;
  BOOL v41 = __CFADD__(v41, v32);
  uint64_t v39 = v40 + v32;
  v41 |= __CFADD__(v22, v39);
  v39 += v22;
  BOOL v43 = v41;
  BOOL v41 = __CFADD__(v41, v34);
  uint64_t v42 = v43 + v34;
  v41 |= __CFADD__(v21, v42);
  v42 += v21;
  uint64_t v44 = v41;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), StatusReg);
  uint64_t v45 = v26 + v41 + v44;
  *((void *)&v47 + 1) = v14;
  *(void *)&long long v47 = v13;
  unint64_t v46 = v47 >> 32;
  BOOL v41 = __CFADD__(v46, v4);
  *((void *)&v47 + 1) = v22;
  *(void *)&long long v47 = v14;
  uint64_t v48 = v47 >> 32;
  unsigned long long v51 = __PAIR128__(v28, v46) + v4;
  uint64_t v50 = v51 >> 64;
  uint64_t v49 = v51;
  BOOL v52 = __CFADD__(v41, v28);
  *((void *)&v54 + 1) = v21;
  *(void *)&long long v54 = v22;
  uint64_t v53 = v54 >> 32;
  BOOL v41 = __CFADD__(v27, v53);
  uint64_t v55 = v27 + v53;
  uint64_t v56 = v41;
  *((void *)&v58 + 1) = v2;
  *(void *)&long long v58 = v21;
  uint64_t v57 = v58 >> 32;
  BOOL v41 = __CFADD__(v57, v36);
  uint64_t v59 = v57 + v36;
  uint64_t v60 = v41;
  *((void *)&v62 + 1) = v7;
  *(void *)&long long v62 = v2;
  uint64_t v61 = v62 >> 32;
  BOOL v41 = __CFADD__(v37, v61);
  uint64_t v63 = v37 + v61;
  uint64_t v64 = v41;
  *((void *)&v66 + 1) = v8;
  *(void *)&long long v66 = v7;
  uint64_t v65 = v66 >> 32;
  BOOL v41 = __CFADD__(v39, v65);
  uint64_t v67 = v39 + v65;
  uint64_t v68 = v41;
  *((void *)&v70 + 1) = v13;
  *(void *)&long long v70 = v8;
  uint64_t v69 = v70 >> 32;
  BOOL v41 = __CFADD__(v42, v69);
  uint64_t v71 = v42 + v69;
  uint64_t v72 = v41;
  v78[0] = v49;
  v78[1] = v50 + v48;
  BOOL v73 = v52 + __CFADD__(v50, v48) + v55;
  BOOL v41 = __CFADD__(__CFADD__(__CFADD__(v50, v48), v55) | __CFADD__(v52, __CFADD__(v50, v48) + v55), v59);
  uint64_t v74 = (__CFADD__(__CFADD__(v50, v48), v55) | __CFADD__(v52, __CFADD__(v50, v48) + v55)) + v59;
  v78[2] = v73;
  v78[3] = v56 + v74;
  uint64_t v76 = v41 | __CFADD__(v56, v74);
  BOOL v41 = __CFADD__(v76, v63);
  uint64_t v75 = v76 + v63;
  v41 |= __CFADD__(v60, v75);
  v78[4] = v60 + v75;
  v78[5] = v64 + v41 + v67;
  v78[6] = v68 + (__CFADD__(v41, v67) | __CFADD__(v64, v41 + v67)) + v71;
  return ccec448_redc_one(a1, (uint64_t)v78, v72+ (__CFADD__(__CFADD__(v41, v67) | __CFADD__(v64, v41 + v67), v71) | __CFADD__(v68, (__CFADD__(v41, v67) | __CFADD__(v64, v41 + v67)) + v71))+ v45);
}

void *ccec448_sqr_ws(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4)
{
  uint64_t v188 = *MEMORY[0x263EF8C08];
  unint64_t v6 = *a4;
  unint64_t v5 = a4[1];
  uint64_t v7 = (v6 * (unsigned __int128)v6) >> 64;
  unint64_t v8 = (v5 * (unsigned __int128)*a4) >> 64;
  unint64_t v9 = v5 * *a4;
  unint64_t v10 = v9 >> 63;
  uint64_t v11 = 2 * v8;
  unint64_t v13 = a4[2];
  unint64_t v12 = a4[3];
  unint64_t v14 = (v13 * (unsigned __int128)*a4) >> 64;
  unint64_t v15 = v13 * *a4;
  uint64_t v16 = (v5 * (unsigned __int128)v5) >> 64;
  unint64_t v17 = v15 >> 63;
  BOOL v18 = __CFADD__(v5 * v5, 2 * v15);
  uint64_t v19 = v5 * v5 + 2 * v15;
  if (v18) {
    unint64_t v20 = v17 + 1;
  }
  else {
    unint64_t v20 = v17;
  }
  unint64_t v21 = v14 >> 63;
  BOOL v18 = __CFADD__(v16, 2 * v14);
  uint64_t v22 = v16 + 2 * v14;
  if (v18) {
    unint64_t v23 = v21 + 1;
  }
  else {
    unint64_t v23 = v21;
  }
  unint64_t v24 = v8 >> 63;
  v186[0] = v6 * v6;
  v186[1] = v7 + 2 * v9;
  BOOL v18 = __CFADD__(__CFADD__(v7, 2 * v9), v11);
  uint64_t v25 = __CFADD__(v7, 2 * v9) + v11;
  v18 |= __CFADD__(v10, v25);
  v25 += v10;
  unint64_t v26 = v24 + v18 + v22;
  if (__CFADD__(v18, v22) | __CFADD__(v24, v18 + v22)) {
    unint64_t v27 = v23 + 1;
  }
  else {
    unint64_t v27 = v23;
  }
  uint64_t v28 = (v12 * (unsigned __int128)v6) >> 64;
  unint64_t v29 = v12 * v6 + v13 * v5;
  BOOL v30 = __CFADD__(v12 * v6, v13 * v5);
  uint64_t v31 = (v13 * (unsigned __int128)v5) >> 64;
  BOOL v18 = __CFADD__(v28, v31);
  uint64_t v32 = v28 + v31;
  uint64_t v33 = v18;
  *((void *)&v35 + 1) = v30;
  *(void *)&long long v35 = v12 * v6 + v13 * v5;
  uint64_t v34 = v35 >> 63;
  uint64_t v37 = v19 + v25;
  BOOL v18 = __CFADD__(__CFADD__(v19, v25), v26) | __CFADD__(v20, (__PAIR128__(v26, v19) + (unint64_t)v25) >> 64);
  uint64_t v36 = v20 + ((__PAIR128__(v26, v19) + (unint64_t)v25) >> 64);
  *((void *)&v35 + 1) = v33;
  *(void *)&long long v35 = v32;
  uint64_t v38 = v35 >> 63;
  uint64_t v40 = v18 + 2 * v32;
  BOOL v18 = __CFADD__(v18, 2 * v32) | __CFADD__(v27, v40);
  unint64_t v39 = v27 + v40;
  if (v18) {
    uint64_t v41 = v38 + 1;
  }
  else {
    uint64_t v41 = v38;
  }
  unint64_t v42 = a4[4];
  unint64_t v43 = a4[5];
  uint64_t v44 = (v42 * (unsigned __int128)v6) >> 64;
  unint64_t v45 = v42 * v6 + v12 * v5;
  BOOL v46 = __CFADD__(v42 * v6, v12 * v5);
  uint64_t v47 = (v12 * (unsigned __int128)v5) >> 64;
  BOOL v18 = __CFADD__(v44, v47);
  uint64_t v48 = v44 + v47;
  uint64_t v49 = v18;
  *((void *)&v51 + 1) = v46;
  *(void *)&long long v51 = v42 * v6 + v12 * v5;
  uint64_t v50 = v51 >> 63;
  BOOL v18 = __CFADD__(v13 * v13, 2 * v45);
  uint64_t v52 = v13 * v13 + 2 * v45;
  uint64_t v53 = (v13 * (unsigned __int128)v13) >> 64;
  if (v18) {
    ++v50;
  }
  *((void *)&v55 + 1) = v49;
  *(void *)&long long v55 = v48;
  uint64_t v54 = v55 >> 63;
  BOOL v18 = __CFADD__(v53, 2 * v48);
  uint64_t v56 = v53 + 2 * v48;
  if (v18) {
    ++v54;
  }
  v186[2] = v37;
  v186[3] = v36 + 2 * v29;
  BOOL v18 = __CFADD__(__CFADD__(v36, 2 * v29), v39);
  unint64_t v57 = __CFADD__(v36, 2 * v29) + v39;
  v18 |= __CFADD__(v34, v57);
  v57 += v34;
  uint64_t v59 = v18 + v56;
  BOOL v18 = __CFADD__(v18, v56) | __CFADD__(v41, v59);
  uint64_t v58 = v41 + v59;
  if (v18) {
    uint64_t v60 = v54 + 1;
  }
  else {
    uint64_t v60 = v54;
  }
  uint64_t v61 = (v43 * (unsigned __int128)v6) >> 64;
  unint64_t v62 = v43 * v6;
  uint64_t v63 = (v42 * (unsigned __int128)v5) >> 64;
  unint64_t v64 = v42 * v5 + v12 * v13;
  BOOL v65 = __CFADD__(v42 * v5, v12 * v13);
  BOOL v18 = __CFADD__(v64, v62);
  unint64_t v66 = v64 + v62;
  if (v18) {
    BOOL v67 = v65 + 1;
  }
  else {
    BOOL v67 = v65;
  }
  uint64_t v68 = (v12 * (unsigned __int128)v13) >> 64;
  BOOL v18 = __CFADD__(v63, v68);
  uint64_t v69 = v63 + v68;
  uint64_t v70 = v18;
  BOOL v18 = __CFADD__(v69, v61);
  uint64_t v71 = v69 + v61;
  if (v18) {
    uint64_t v72 = v70 + 1;
  }
  else {
    uint64_t v72 = v70;
  }
  BOOL v18 = __CFADD__(v52, v57);
  unint64_t v73 = v52 + v57;
  BOOL v75 = v18;
  BOOL v18 = __CFADD__(v18, v58);
  uint64_t v74 = v75 + v58;
  v18 |= __CFADD__(v50, v74);
  v74 += v50;
  *((void *)&v77 + 1) = v67;
  *(void *)&long long v77 = v66;
  uint64_t v76 = v77 >> 63;
  *((void *)&v77 + 1) = v72;
  *(void *)&long long v77 = v71;
  uint64_t v78 = v77 >> 63;
  uint64_t v79 = 2 * v71;
  uint64_t v81 = v18 + v79;
  BOOL v18 = __CFADD__(v18, v79) | __CFADD__(v60, v81);
  uint64_t v80 = v60 + v81;
  if (v18) {
    uint64_t v82 = v78 + 1;
  }
  else {
    uint64_t v82 = v78;
  }
  unint64_t v83 = a4[6];
  uint64_t v84 = (v83 * (unsigned __int128)v6) >> 64;
  unint64_t v85 = v83 * v6;
  uint64_t v86 = (v43 * (unsigned __int128)v5) >> 64;
  unint64_t v87 = v43 * v5 + v42 * v13;
  BOOL v88 = __CFADD__(v43 * v5, v42 * v13);
  BOOL v18 = __CFADD__(v87, v85);
  unint64_t v89 = v87 + v85;
  if (v18) {
    BOOL v90 = v88 + 1;
  }
  else {
    BOOL v90 = v88;
  }
  uint64_t v91 = (v42 * (unsigned __int128)v13) >> 64;
  BOOL v18 = __CFADD__(v86, v91);
  uint64_t v92 = v86 + v91;
  uint64_t v93 = v18;
  BOOL v18 = __CFADD__(v92, v84);
  uint64_t v94 = v92 + v84;
  if (v18) {
    uint64_t v95 = v93 + 1;
  }
  else {
    uint64_t v95 = v93;
  }
  *((void *)&v97 + 1) = v90;
  *(void *)&long long v97 = v89;
  uint64_t v96 = v97 >> 63;
  BOOL v18 = __CFADD__(v12 * v12, 2 * v89);
  uint64_t v98 = v12 * v12 + 2 * v89;
  uint64_t v99 = (v12 * (unsigned __int128)v12) >> 64;
  if (v18) {
    ++v96;
  }
  *((void *)&v101 + 1) = v95;
  *(void *)&long long v101 = v94;
  uint64_t v100 = v101 >> 63;
  BOOL v18 = __CFADD__(v99, 2 * v94);
  uint64_t v102 = v99 + 2 * v94;
  if (v18) {
    ++v100;
  }
  v186[4] = v73;
  v186[5] = v74 + 2 * v66;
  BOOL v18 = __CFADD__(__CFADD__(v74, 2 * v66), v80);
  uint64_t v103 = __CFADD__(v74, 2 * v66) + v80;
  v18 |= __CFADD__(v76, v103);
  v103 += v76;
  uint64_t v104 = v82 + v18 + v102;
  if (__CFADD__(v18, v102) | __CFADD__(v82, v18 + v102)) {
    uint64_t v105 = v100 + 1;
  }
  else {
    uint64_t v105 = v100;
  }
  unint64_t v106 = v83 * v5;
  uint64_t v107 = (v83 * (unsigned __int128)v5) >> 64;
  uint64_t v108 = (v43 * (unsigned __int128)v13) >> 64;
  unint64_t v109 = v43 * v13 + v42 * v12;
  BOOL v110 = __CFADD__(v43 * v13, v42 * v12);
  BOOL v18 = __CFADD__(v109, v106);
  unint64_t v111 = v109 + v106;
  if (v18) {
    BOOL v112 = v110 + 1;
  }
  else {
    BOOL v112 = v110;
  }
  uint64_t v113 = (v42 * (unsigned __int128)v12) >> 64;
  BOOL v18 = __CFADD__(v108, v113);
  uint64_t v114 = v108 + v113;
  uint64_t v115 = v18;
  BOOL v18 = __CFADD__(v114, v107);
  uint64_t v116 = v114 + v107;
  if (v18) {
    uint64_t v117 = v115 + 1;
  }
  else {
    uint64_t v117 = v115;
  }
  BOOL v18 = __CFADD__(v98, v103);
  uint64_t v118 = v98 + v103;
  BOOL v120 = v18;
  BOOL v18 = __CFADD__(v18, v104) | __CFADD__(v96, v18 + v104);
  uint64_t v119 = v96 + v120 + v104;
  *((void *)&v122 + 1) = v112;
  *(void *)&long long v122 = v111;
  uint64_t v121 = v122 >> 63;
  *((void *)&v122 + 1) = v117;
  *(void *)&long long v122 = v116;
  uint64_t v123 = v122 >> 63;
  uint64_t v124 = 2 * v116;
  BOOL v126 = v18;
  BOOL v18 = __CFADD__(v18, v124);
  uint64_t v125 = v126 + v124;
  v18 |= __CFADD__(v105, v125);
  v125 += v105;
  if (v18) {
    uint64_t v127 = v123 + 1;
  }
  else {
    uint64_t v127 = v123;
  }
  unint64_t v128 = v83 * v13;
  uint64_t v129 = (v83 * (unsigned __int128)v13) >> 64;
  BOOL v18 = __CFADD__(v128, v43 * v12);
  unint64_t v130 = v128 + v43 * v12;
  uint64_t v131 = v18;
  uint64_t v132 = (v43 * (unsigned __int128)v12) >> 64;
  BOOL v18 = __CFADD__(v129, v132);
  uint64_t v133 = v129 + v132;
  uint64_t v134 = v18;
  *((void *)&v136 + 1) = v131;
  *(void *)&long long v136 = v130;
  uint64_t v135 = v136 >> 63;
  uint64_t v137 = (v42 * (unsigned __int128)v42) >> 64;
  BOOL v18 = __CFADD__(v42 * v42, 2 * v130);
  uint64_t v138 = v42 * v42 + 2 * v130;
  if (v18) {
    ++v135;
  }
  *((void *)&v140 + 1) = v134;
  *(void *)&long long v140 = v133;
  uint64_t v139 = v140 >> 63;
  BOOL v18 = __CFADD__(v137, 2 * v133);
  uint64_t v141 = v137 + 2 * v133;
  if (v18) {
    ++v139;
  }
  v186[6] = v118;
  v186[7] = v119 + 2 * v111;
  BOOL v18 = __CFADD__(__CFADD__(v119, 2 * v111), v125);
  uint64_t v142 = __CFADD__(v119, 2 * v111) + v125;
  v18 |= __CFADD__(v121, v142);
  v142 += v121;
  BOOL v144 = v18;
  BOOL v18 = __CFADD__(v18, v141);
  uint64_t v143 = v144 + v141;
  v18 |= __CFADD__(v127, v143);
  v143 += v127;
  if (v18) {
    uint64_t v145 = v139 + 1;
  }
  else {
    uint64_t v145 = v139;
  }
  unint64_t v146 = v83 * v12;
  uint64_t v147 = (v83 * (unsigned __int128)v12) >> 64;
  BOOL v18 = __CFADD__(v146, v43 * v42);
  unint64_t v148 = v146 + v43 * v42;
  uint64_t v149 = v18;
  uint64_t v150 = (v43 * (unsigned __int128)v42) >> 64;
  BOOL v18 = __CFADD__(v147, v150);
  uint64_t v151 = v147 + v150;
  uint64_t v152 = v18;
  BOOL v18 = __CFADD__(v138, v142);
  uint64_t v153 = v138 + v142;
  *((void *)&v155 + 1) = v149;
  *(void *)&long long v155 = v148;
  uint64_t v154 = v155 >> 63;
  BOOL v157 = v18;
  BOOL v18 = __CFADD__(v18, v143);
  uint64_t v156 = v157 + v143;
  v18 |= __CFADD__(v135, v156);
  v156 += v135;
  *((void *)&v155 + 1) = v152;
  *(void *)&long long v155 = v151;
  uint64_t v158 = v155 >> 63;
  uint64_t v159 = 2 * v151;
  BOOL v161 = v18;
  BOOL v18 = __CFADD__(v18, v159);
  uint64_t v160 = v161 + v159;
  v18 |= __CFADD__(v145, v160);
  v160 += v145;
  if (v18) {
    uint64_t v162 = v158 + 1;
  }
  else {
    uint64_t v162 = v158;
  }
  unint64_t v163 = (v83 * (unsigned __int128)v42) >> 64;
  unint64_t v164 = v83 * v42;
  unint64_t v165 = v164 >> 63;
  unint64_t v166 = v163 >> 63;
  BOOL v18 = __CFADD__(v43 * v43, 2 * v164);
  uint64_t v167 = v43 * v43 + 2 * v164;
  if (v18) {
    ++v165;
  }
  uint64_t v168 = (v43 * (unsigned __int128)v43) >> 64;
  BOOL v18 = __CFADD__(v168, 2 * v163);
  uint64_t v169 = v168 + 2 * v163;
  if (v18) {
    ++v166;
  }
  v186[8] = v153;
  v186[9] = v156 + 2 * v148;
  BOOL v18 = __CFADD__(__CFADD__(v156, 2 * v148), v160);
  uint64_t v170 = __CFADD__(v156, 2 * v148) + v160;
  v18 |= __CFADD__(v154, v170);
  v170 += v154;
  uint64_t v171 = v162 + v18 + v169;
  if (__CFADD__(v18, v169) | __CFADD__(v162, v18 + v169)) {
    unint64_t v172 = v166 + 1;
  }
  else {
    unint64_t v172 = v166;
  }
  BOOL v18 = __CFADD__(v167, v170);
  uint64_t v173 = v167 + v170;
  BOOL v175 = v18;
  BOOL v18 = __CFADD__(v18, v171) | __CFADD__(v165, v18 + v171);
  unint64_t v174 = v165 + v175 + v171;
  unint64_t v176 = (v83 * (unsigned __int128)v43) >> 64;
  unint64_t v177 = v83 * v43;
  unint64_t v178 = v177 >> 63;
  uint64_t v179 = 2 * v176;
  unint64_t v180 = v176 >> 63;
  uint64_t v182 = v18 + v179;
  BOOL v18 = __CFADD__(v18, v179) | __CFADD__(v172, v182);
  unint64_t v181 = v172 + v182;
  if (v18) {
    ++v180;
  }
  v186[10] = v173;
  v186[11] = v174 + 2 * v177;
  unint64_t v183 = v178 + __CFADD__(v174, 2 * v177) + v181;
  if (__CFADD__(__CFADD__(v174, 2 * v177), v181) | __CFADD__(v178, __CFADD__(v174, 2 * v177) + v181)) {
    unint64_t v184 = v180 + 1;
  }
  else {
    unint64_t v184 = v180;
  }
  unsigned long long v187 = __PAIR128__(v184, v183) + v83 * (unsigned __int128)v83;
  return ccec448_redc_full(a3, v186);
}

uint64_t ccec448_inv_ws(uint64_t a1, uint64_t a2)
{
  cczp_sqr_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  int v4 = 2;
  do
  {
    cczp_sqr_ws(a1, a2);
    --v4;
  }
  while (v4);
  cczp_mul_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  int v5 = 5;
  do
  {
    cczp_sqr_ws(a1, a2);
    --v5;
  }
  while (v5);
  cczp_mul_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  int v6 = 12;
  do
  {
    cczp_sqr_ws(a1, a2);
    --v6;
  }
  while (v6);
  cczp_mul_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  int v7 = 26;
  do
  {
    cczp_sqr_ws(a1, a2);
    --v7;
  }
  while (v7);
  cczp_mul_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  int v8 = 54;
  do
  {
    cczp_sqr_ws(a1, a2);
    --v8;
  }
  while (v8);
  cczp_mul_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  int v9 = 110;
  do
  {
    cczp_sqr_ws(a1, a2);
    --v9;
  }
  while (v9);
  cczp_mul_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  int v10 = 222;
  do
  {
    cczp_sqr_ws(a1, a2);
    --v10;
  }
  while (v10);
  cczp_mul_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  return 0;
}

uint64_t ccec448_from_ws(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  unsigned char v19[7] = *MEMORY[0x263EF8C08];
  int v6 = (void *)cczp_prime(a2);
  unsigned long long v7 = (unint64_t)*a4 - __PAIR128__(*v6, *v6);
  unsigned long long v8 = (unint64_t)a4[1]
     - __PAIR128__(v6[1], v6[1])
     + __PAIR128__(*((uint64_t *)&v7 + 1) >> 63, *((uint64_t *)&v7 + 1) >> 63);
  v19[0] = *a4 - *v6;
  v19[1] = v8;
  unsigned long long v9 = (unint64_t)a4[2] - __PAIR128__(v6[2], v6[2]);
  unsigned long long v10 = (unint64_t)a4[3]
      - __PAIR128__(v6[3], v6[3])
      + __PAIR128__(((*((uint64_t *)&v8 + 1) >> 63) + __CFADD__((void)v9, *((uint64_t *)&v8 + 1) >> 63) + *((void *)&v9 + 1)) >> 63, ((*((uint64_t *)&v8 + 1) >> 63) + __CFADD__((void)v9, *((uint64_t *)&v8 + 1) >> 63) + *((void *)&v9 + 1)) >> 63);
  _OWORD v19[2] = v9 + (*((uint64_t *)&v8 + 1) >> 63);
  void v19[3] = v10;
  unint64_t v12 = ((unint64_t)a4[4] - __PAIR128__(v6[4], v6[4])) >> 64;
  unint64_t v11 = a4[4] - v6[4];
  uint64_t v13 = (*((uint64_t *)&v10 + 1) >> 63) + __CFADD__(v11, *((uint64_t *)&v10 + 1) >> 63) + v12;
  unsigned long long v14 = (unint64_t)a4[5] - __PAIR128__(v12, v6[5]);
  uint64_t v15 = v14 + (v13 >> 63);
  uint64_t v16 = (v13 >> 63) + __CFADD__((void)v14, v13 >> 63) + *((void *)&v14 + 1);
  void v19[4] = v11 + (*((uint64_t *)&v10 + 1) >> 63);
  v19[5] = v15;
  unsigned long long v17 = (unint64_t)a4[6] - __PAIR128__(v6[6], v6[6]);
  v19[6] = v17 + (v16 >> 63);
  return ccn_mux(7, (v16 >> 63) + __CFADD__((void)v17, v16 >> 63) + *((void *)&v17 + 1) < 0, a3, a4, v19);
}

BOOL ccrsa_import_priv_ws(uint64_t a1, unint64_t *a2, uint64_t a3, unsigned __int8 *a4)
{
  return ccder_decode_rsa_priv_ws(a1, a2, a4, &a4[a3]) == 0;
}

uint64_t ccrsa_dump_public_key(uint64_t *a1)
{
  BOOL v4 = timingsafe_enable_if_supported();
  uint64_t v2 = ccrsa_pubkeylength(a1);
  fprintf((FILE *)*MEMORY[0x263EF8C10], "%lu bit rsa key\n", v2);
  ccn_lprint(*a1, "m  = 0x", (uint64_t)(a1 + 3));
  ccn_lprint(*a1, "e  = 0x", (uint64_t)&a1[2 * *a1 + 4]);
  return cc_disable_dit_with_sb((unsigned int *)&v4);
}

uint64_t ccrsa_dump_full_key(void *a1)
{
  BOOL v35 = timingsafe_enable_if_supported();
  uint64_t v2 = (uint64_t *)ccrsa_ctx_public(a1);
  uint64_t v3 = ccrsa_pubkeylength(v2);
  BOOL v4 = (FILE **)MEMORY[0x263EF8C10];
  fprintf((FILE *)*MEMORY[0x263EF8C10], "%lu bit rsa key\n", v3);
  ccn_lprint(*v2, "m  = 0x", (uint64_t)(v2 + 3));
  ccn_lprint(*v2, "e  = 0x", (uint64_t)&v2[2 * *v2 + 4]);
  ccn_lprint(*v2, "d  = 0x", (uint64_t)&v2[3 * *v2 + 4]);
  uint64_t v5 = ccrsa_ctx_private_zp(a1);
  uint64_t v6 = cczp_n(v5);
  uint64_t v7 = ccrsa_ctx_private_zp(a1);
  uint64_t v8 = cczp_prime(v7);
  ccn_lprint(v6, "p  = 0x", v8);
  uint64_t v9 = ccrsa_ctx_private_zp(a1);
  unsigned long long v10 = (void *)ccrsa_ctx_private_zp(a1);
  uint64_t v11 = cczp_n(v9 + 16 * *v10 + 32);
  uint64_t v12 = ccrsa_ctx_private_zp(a1);
  uint64_t v13 = (void *)ccrsa_ctx_private_zp(a1);
  uint64_t v14 = cczp_prime(v12 + 16 * *v13 + 32);
  ccn_lprint(v11, "q  = 0x", v14);
  uint64_t v15 = ccrsa_ctx_private_zp(a1);
  uint64_t v16 = cczp_n(v15);
  uint64_t v17 = ccrsa_ctx_private_zp(a1);
  uint64_t v18 = v17 + 16 * *(void *)ccrsa_ctx_private_zp(a1);
  uint64_t v19 = (void *)ccrsa_ctx_private_zp(a1);
  ccn_lprint(v16, "dp = 0x", v18 + 16 * *v19 + 64);
  uint64_t v20 = ccrsa_ctx_private_zp(a1);
  unint64_t v21 = (void *)ccrsa_ctx_private_zp(a1);
  uint64_t v22 = cczp_n(v20 + 16 * *v21 + 32);
  uint64_t v23 = ccrsa_ctx_private_zp(a1);
  uint64_t v24 = v23 + 16 * *(void *)ccrsa_ctx_private_zp(a1);
  uint64_t v25 = v24 + 16 * *(void *)ccrsa_ctx_private_zp(a1);
  unint64_t v26 = (void *)ccrsa_ctx_private_zp(a1);
  ccn_lprint(v22, "dq = 0x", v25 + 8 * *v26 + 64);
  uint64_t v27 = ccrsa_ctx_private_zp(a1);
  uint64_t v28 = cczp_n(v27);
  uint64_t v29 = ccrsa_ctx_private_zp(a1);
  uint64_t v30 = v29 + 16 * *(void *)ccrsa_ctx_private_zp(a1);
  uint64_t v31 = v30 + 16 * *(void *)ccrsa_ctx_private_zp(a1);
  uint64_t v32 = v31 + 8 * *(void *)ccrsa_ctx_private_zp(a1);
  uint64_t v33 = (void *)ccrsa_ctx_private_zp(a1);
  ccn_lprint(v28, "qinv=0x", v32 + 8 * *v33 + 64);
  fputc(10, *v4);
  return cc_disable_dit_with_sb((unsigned int *)&v35);
}

uint64_t md2_processblock(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v4 = a2;
    uint64_t v5 = result;
    uint64_t v6 = result + 48;
    do
    {
      uint64_t result = md2_compress(v5, a3);
      uint64_t v7 = 0;
      char v8 = *(unsigned char *)(v5 + 63);
      do
      {
        char v8 = *(unsigned char *)(v6 + v7) ^ PI_SUBST[(*(unsigned char *)(a3 + v7) ^ v8)];
        *(unsigned char *)(v6 + v7++) = v8;
      }
      while (v7 != 16);
      a3 += 16;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t md2_final(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4)
{
  v18[1] = *MEMORY[0x263EF8C08];
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)(a1 + 16);
  MEMORY[0x270FA53B0](a1, a2, a3, a4);
  uint64_t v9 = (char *)v18 - v8;
  memcpy((char *)v18 - v8, v11, v10 + 4);
  uint64_t v12 = &v9[v6 + 8];
  uint64_t v13 = *(unsigned int *)&v12[v7];
  if (v13 <= 0xF) {
    memset(&v9[v6 + 8 + v13], 16 - v13, 16 - v13);
  }
  uint64_t v14 = v9 + 56;
  md2_compress((uint64_t)(v9 + 8), (uint64_t)v12);
  uint64_t v15 = 0;
  char v16 = v9[71];
  do
  {
    char v16 = *((unsigned char *)v14 + v15) ^ PI_SUBST[(v12[v15] ^ v16)];
    *((unsigned char *)v14 + v15++) = v16;
  }
  while (v15 != 16);
  *(_OWORD *)uint64_t v12 = *v14;
  md2_compress((uint64_t)(v9 + 8), (uint64_t)v12);
  *a3 = *(_OWORD *)(v9 + 8);
  return cc_clear(*(void *)(a1 + 8) + *(void *)(a1 + 16) + 12, v9);
}

uint64_t md2_compress(uint64_t result, uint64_t a2)
{
  for (uint64_t i = 0; i != 16; ++i)
  {
    char v3 = *(unsigned char *)(a2 + i);
    uint64_t v4 = result + i;
    *(unsigned char *)(v4 + 16) = v3;
    *(unsigned char *)(v4 + 32) = *(unsigned char *)(result + i) ^ v3;
  }
  unsigned __int8 v5 = 0;
  for (int j = 0; j != 18; ++j)
  {
    for (uint64_t k = 0; k != 48; ++k)
    {
      unsigned __int8 v5 = *(unsigned char *)(result + k) ^ PI_SUBST[v5];
      *(unsigned char *)(result + k) = v5;
    }
    v5 += j;
  }
  return result;
}

uint64_t ccecies_derive_gcm_key_iv(uint64_t a1, size_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, char *a8)
{
  uint64_t v18 = *MEMORY[0x263EF8C08];
  int v8 = *(_DWORD *)(a1 + 32);
  if (a4) {
    BOOL v9 = 0;
  }
  else {
    BOOL v9 = (*(_DWORD *)(a1 + 32) & 0x20) != 0;
  }
  uint64_t v10 = 4294967289;
  if (!v9 && (*(_DWORD *)(a1 + 32) & 0x21) != 0x21 && ((a4 != 0) & v8) == 0)
  {
    uint64_t v12 = *(unsigned int *)(a1 + 24);
    if ((v8 & 0x10) == 0)
    {
      uint64_t v12 = (v12 + 16);
      goto LABEL_11;
    }
    if (v12 <= 0xFFFFFFEF)
    {
      uint64_t v13 = &a8[v12];
      *(void *)uint64_t v13 = 0;
      *((void *)v13 + 1) = 0;
LABEL_11:
      memset(v17, 0, sizeof(v17));
      if ((v8 & 0x21) != 0)
      {
        *(void *)&v17[0] = a7;
        *((void *)&v17[0] + 1) = a6;
        uint64_t v14 = 1;
        if (v8 & 0x20) == 0 && (v8) {
          return ccansikdf_x963_iovec(*(unint64_t **)a1, a2, a3, v14, (uint64_t)v17, v12, a8);
        }
      }
      else
      {
        LODWORD(v14) = 0;
      }
      uint64_t v15 = &v17[v14];
      void *v15 = a5;
      v15[1] = a4;
      uint64_t v14 = (v14 + 1);
      return ccansikdf_x963_iovec(*(unint64_t **)a1, a2, a3, v14, (uint64_t)v17, v12, a8);
    }
  }
  return v10;
}

uint64_t cckyber_hash_h(size_t a1, char *a2, uint64_t a3)
{
  uint64_t v6 = ccsha3_256_di();

  return ccdigest_internal((uint64_t)v6, a1, a2, a3);
}

uint64_t cckyber_hash_g(size_t a1, char *a2, uint64_t a3)
{
  uint64_t v6 = ccsha3_512_di();

  return ccdigest_internal((uint64_t)v6, a1, a2, a3);
}

uint64_t cckyber_prf(char *a1, char a2, char *a3)
{
  __dst[44] = *MEMORY[0x263EF8C08];
  char __src = a2;
  unsigned __int8 v5 = ccshake256_xi();
  ccxof_init((uint64_t)v5, __dst);
  ccxof_absorb(v5, (char *)__dst, 0x20uLL, a1);
  ccxof_absorb(v5, (char *)__dst, 1uLL, &__src);
  ccxof_squeeze(v5, (unsigned int *)__dst, 0x80uLL, a3);
  return cc_clear(0x158uLL, __dst);
}

uint64_t cckyber_rkprf(char *a1, unint64_t a2, char *a3, char *a4)
{
  __dst[44] = *MEMORY[0x263EF8C08];
  int v8 = ccshake256_xi();
  ccxof_init((uint64_t)v8, __dst);
  ccxof_absorb(v8, (char *)__dst, 0x20uLL, a1);
  ccxof_absorb(v8, (char *)__dst, a2, a3);
  ccxof_squeeze(v8, (unsigned int *)__dst, 0x20uLL, a4);
  return cc_clear(0x158uLL, __dst);
}

int *CC_CAST_encrypt(int *result, uint64_t a2)
{
  int v2 = result[1];
  unsigned int v3 = __ROR4__(*(_DWORD *)a2 + v2, -*(unsigned char *)(a2 + 4));
  int v4 = ((CC_CAST_S_table1[v3] ^ CC_CAST_S_table0[BYTE1(v3)])
      - CC_CAST_S_table2[HIBYTE(v3)]
      + CC_CAST_S_table3[BYTE2(v3)]) ^ *result;
  unsigned int v5 = __ROR4__(v4 ^ *(_DWORD *)(a2 + 8), -*(unsigned char *)(a2 + 12));
  int v6 = CC_CAST_S_table3[BYTE2(v5)] ^ v2 ^ (CC_CAST_S_table0[BYTE1(v5)]
                                         - CC_CAST_S_table1[v5]
                                         + CC_CAST_S_table2[HIBYTE(v5)]);
  unsigned int v7 = __ROR4__(*(_DWORD *)(a2 + 16) - v6, -*(unsigned char *)(a2 + 20));
  int v8 = (((CC_CAST_S_table1[v7] + CC_CAST_S_table0[BYTE1(v7)]) ^ CC_CAST_S_table2[HIBYTE(v7)])
      - CC_CAST_S_table3[BYTE2(v7)]) ^ v4;
  unsigned int v9 = __ROR4__(v8 + *(_DWORD *)(a2 + 24), -*(unsigned char *)(a2 + 28));
  int v10 = ((CC_CAST_S_table1[v9] ^ CC_CAST_S_table0[BYTE1(v9)])
       - CC_CAST_S_table2[HIBYTE(v9)]
       + CC_CAST_S_table3[BYTE2(v9)]) ^ v6;
  unsigned int v11 = __ROR4__(v10 ^ *(_DWORD *)(a2 + 32), -*(unsigned char *)(a2 + 36));
  int v12 = CC_CAST_S_table3[BYTE2(v11)] ^ v8 ^ (CC_CAST_S_table0[BYTE1(v11)]
                                           - CC_CAST_S_table1[v11]
                                           + CC_CAST_S_table2[HIBYTE(v11)]);
  unsigned int v13 = __ROR4__(*(_DWORD *)(a2 + 40) - v12, -*(unsigned char *)(a2 + 44));
  int v14 = (((CC_CAST_S_table1[v13] + CC_CAST_S_table0[BYTE1(v13)]) ^ CC_CAST_S_table2[HIBYTE(v13)])
       - CC_CAST_S_table3[BYTE2(v13)]) ^ v10;
  unsigned int v15 = __ROR4__(v14 + *(_DWORD *)(a2 + 48), -*(unsigned char *)(a2 + 52));
  int v16 = ((CC_CAST_S_table1[v15] ^ CC_CAST_S_table0[BYTE1(v15)])
       - CC_CAST_S_table2[HIBYTE(v15)]
       + CC_CAST_S_table3[BYTE2(v15)]) ^ v12;
  unsigned int v17 = __ROR4__(v16 ^ *(_DWORD *)(a2 + 56), -*(unsigned char *)(a2 + 60));
  int v18 = CC_CAST_S_table3[BYTE2(v17)] ^ v14 ^ (CC_CAST_S_table0[BYTE1(v17)]
                                            - CC_CAST_S_table1[v17]
                                            + CC_CAST_S_table2[HIBYTE(v17)]);
  unsigned int v19 = __ROR4__(*(_DWORD *)(a2 + 64) - v18, -*(unsigned char *)(a2 + 68));
  int v20 = (((CC_CAST_S_table1[v19] + CC_CAST_S_table0[BYTE1(v19)]) ^ CC_CAST_S_table2[HIBYTE(v19)])
       - CC_CAST_S_table3[BYTE2(v19)]) ^ v16;
  unsigned int v21 = __ROR4__(v20 + *(_DWORD *)(a2 + 72), -*(unsigned char *)(a2 + 76));
  int v22 = ((CC_CAST_S_table1[v21] ^ CC_CAST_S_table0[BYTE1(v21)])
       - CC_CAST_S_table2[HIBYTE(v21)]
       + CC_CAST_S_table3[BYTE2(v21)]) ^ v18;
  unsigned int v23 = __ROR4__(v22 ^ *(_DWORD *)(a2 + 80), -*(unsigned char *)(a2 + 84));
  int v24 = CC_CAST_S_table3[BYTE2(v23)] ^ v20 ^ (CC_CAST_S_table0[BYTE1(v23)]
                                            - CC_CAST_S_table1[v23]
                                            + CC_CAST_S_table2[HIBYTE(v23)]);
  unsigned int v25 = __ROR4__(*(_DWORD *)(a2 + 88) - v24, -*(unsigned char *)(a2 + 92));
  int v26 = (((CC_CAST_S_table1[v25] + CC_CAST_S_table0[BYTE1(v25)]) ^ CC_CAST_S_table2[HIBYTE(v25)])
       - CC_CAST_S_table3[BYTE2(v25)]) ^ v22;
  if (!*(_DWORD *)(a2 + 128))
  {
    unsigned int v27 = __ROR4__(*(_DWORD *)(a2 + 96) + v26, -*(unsigned char *)(a2 + 100));
    int v28 = ((CC_CAST_S_table1[v27] ^ CC_CAST_S_table0[BYTE1(v27)])
         - CC_CAST_S_table2[HIBYTE(v27)]
         + CC_CAST_S_table3[BYTE2(v27)]) ^ v24;
    unsigned int v29 = __ROR4__(v28 ^ *(_DWORD *)(a2 + 104), -*(unsigned char *)(a2 + 108));
    int v30 = CC_CAST_S_table3[BYTE2(v29)] ^ v26 ^ (CC_CAST_S_table0[BYTE1(v29)]
                                              - CC_CAST_S_table1[v29]
                                              + CC_CAST_S_table2[HIBYTE(v29)]);
    unsigned int v31 = __ROR4__(*(_DWORD *)(a2 + 112) - v30, -*(unsigned char *)(a2 + 116));
    int v24 = (((CC_CAST_S_table1[v31] + CC_CAST_S_table0[BYTE1(v31)]) ^ CC_CAST_S_table2[HIBYTE(v31)])
         - CC_CAST_S_table3[BYTE2(v31)]) ^ v28;
    unsigned int v32 = __ROR4__(v24 + *(_DWORD *)(a2 + 120), -*(unsigned char *)(a2 + 124));
    int v26 = ((CC_CAST_S_table1[v32] ^ CC_CAST_S_table0[BYTE1(v32)])
         - CC_CAST_S_table2[HIBYTE(v32)]
         + CC_CAST_S_table3[BYTE2(v32)]) ^ v30;
  }
  *uint64_t result = v26;
  result[1] = v24;
  return result;
}

int *CC_CAST_decrypt(int *result, uint64_t a2)
{
  int v3 = *result;
  int v2 = result[1];
  if (!*(_DWORD *)(a2 + 128))
  {
    unsigned int v4 = __ROR4__(*(_DWORD *)(a2 + 120) + v2, -*(unsigned char *)(a2 + 124));
    int v5 = ((CC_CAST_S_table1[v4] ^ CC_CAST_S_table0[BYTE1(v4)])
        - CC_CAST_S_table2[HIBYTE(v4)]
        + CC_CAST_S_table3[BYTE2(v4)]) ^ v3;
    unsigned int v6 = __ROR4__(*(_DWORD *)(a2 + 112) - v5, -*(unsigned char *)(a2 + 116));
    int v7 = (((CC_CAST_S_table1[v6] + CC_CAST_S_table0[BYTE1(v6)]) ^ CC_CAST_S_table2[HIBYTE(v6)])
        - CC_CAST_S_table3[BYTE2(v6)]) ^ v2;
    unsigned int v8 = __ROR4__(v7 ^ *(_DWORD *)(a2 + 104), -*(unsigned char *)(a2 + 108));
    int v3 = CC_CAST_S_table3[BYTE2(v8)] ^ v5 ^ (CC_CAST_S_table0[BYTE1(v8)]
                                           - CC_CAST_S_table1[v8]
                                           + CC_CAST_S_table2[HIBYTE(v8)]);
    unsigned int v9 = __ROR4__(v3 + *(_DWORD *)(a2 + 96), -*(unsigned char *)(a2 + 100));
    int v2 = ((CC_CAST_S_table1[v9] ^ CC_CAST_S_table0[BYTE1(v9)])
        - CC_CAST_S_table2[HIBYTE(v9)]
        + CC_CAST_S_table3[BYTE2(v9)]) ^ v7;
  }
  unsigned int v10 = __ROR4__(*(_DWORD *)(a2 + 88) - v2, -*(unsigned char *)(a2 + 92));
  int v11 = (((CC_CAST_S_table1[v10] + CC_CAST_S_table0[BYTE1(v10)]) ^ CC_CAST_S_table2[HIBYTE(v10)])
       - CC_CAST_S_table3[BYTE2(v10)]) ^ v3;
  unsigned int v12 = __ROR4__(v11 ^ *(_DWORD *)(a2 + 80), -*(unsigned char *)(a2 + 84));
  int v13 = CC_CAST_S_table3[BYTE2(v12)] ^ v2 ^ (CC_CAST_S_table0[BYTE1(v12)]
                                           - CC_CAST_S_table1[v12]
                                           + CC_CAST_S_table2[HIBYTE(v12)]);
  unsigned int v14 = __ROR4__(v13 + *(_DWORD *)(a2 + 72), -*(unsigned char *)(a2 + 76));
  int v15 = ((CC_CAST_S_table1[v14] ^ CC_CAST_S_table0[BYTE1(v14)])
       - CC_CAST_S_table2[HIBYTE(v14)]
       + CC_CAST_S_table3[BYTE2(v14)]) ^ v11;
  unsigned int v16 = __ROR4__(*(_DWORD *)(a2 + 64) - v15, -*(unsigned char *)(a2 + 68));
  int v17 = (((CC_CAST_S_table1[v16] + CC_CAST_S_table0[BYTE1(v16)]) ^ CC_CAST_S_table2[HIBYTE(v16)])
       - CC_CAST_S_table3[BYTE2(v16)]) ^ v13;
  unsigned int v18 = __ROR4__(v17 ^ *(_DWORD *)(a2 + 56), -*(unsigned char *)(a2 + 60));
  int v19 = CC_CAST_S_table3[BYTE2(v18)] ^ v15 ^ (CC_CAST_S_table0[BYTE1(v18)]
                                            - CC_CAST_S_table1[v18]
                                            + CC_CAST_S_table2[HIBYTE(v18)]);
  unsigned int v20 = __ROR4__(v19 + *(_DWORD *)(a2 + 48), -*(unsigned char *)(a2 + 52));
  int v21 = ((CC_CAST_S_table1[v20] ^ CC_CAST_S_table0[BYTE1(v20)])
       - CC_CAST_S_table2[HIBYTE(v20)]
       + CC_CAST_S_table3[BYTE2(v20)]) ^ v17;
  unsigned int v22 = __ROR4__(*(_DWORD *)(a2 + 40) - v21, -*(unsigned char *)(a2 + 44));
  int v23 = (((CC_CAST_S_table1[v22] + CC_CAST_S_table0[BYTE1(v22)]) ^ CC_CAST_S_table2[HIBYTE(v22)])
       - CC_CAST_S_table3[BYTE2(v22)]) ^ v19;
  unsigned int v24 = __ROR4__(v23 ^ *(_DWORD *)(a2 + 32), -*(unsigned char *)(a2 + 36));
  int v25 = CC_CAST_S_table3[BYTE2(v24)] ^ v21 ^ (CC_CAST_S_table0[BYTE1(v24)]
                                            - CC_CAST_S_table1[v24]
                                            + CC_CAST_S_table2[HIBYTE(v24)]);
  unsigned int v26 = __ROR4__(v25 + *(_DWORD *)(a2 + 24), -*(unsigned char *)(a2 + 28));
  int v27 = ((CC_CAST_S_table1[v26] ^ CC_CAST_S_table0[BYTE1(v26)])
       - CC_CAST_S_table2[HIBYTE(v26)]
       + CC_CAST_S_table3[BYTE2(v26)]) ^ v23;
  unsigned int v28 = __ROR4__(*(_DWORD *)(a2 + 16) - v27, -*(unsigned char *)(a2 + 20));
  int v29 = (((CC_CAST_S_table1[v28] + CC_CAST_S_table0[BYTE1(v28)]) ^ CC_CAST_S_table2[HIBYTE(v28)])
       - CC_CAST_S_table3[BYTE2(v28)]) ^ v25;
  unsigned int v30 = __ROR4__(v29 ^ *(_DWORD *)(a2 + 8), -*(unsigned char *)(a2 + 12));
  int v31 = CC_CAST_S_table3[BYTE2(v30)] ^ v27 ^ (CC_CAST_S_table0[BYTE1(v30)]
                                            - CC_CAST_S_table1[v30]
                                            + CC_CAST_S_table2[HIBYTE(v30)]);
  unsigned int v32 = __ROR4__(v31 + *(_DWORD *)a2, -*(unsigned char *)(a2 + 4));
  *uint64_t result = ((CC_CAST_S_table1[v32] ^ CC_CAST_S_table0[BYTE1(v32)])
           - CC_CAST_S_table2[HIBYTE(v32)]
           + CC_CAST_S_table3[BYTE2(v32)]) ^ v29;
  result[1] = v31;
  return result;
}

uint64_t ccz_muli(uint64_t a1, uint64_t a2, unsigned int a3)
{
  v9[1] = *MEMORY[0x263EF8C08];
  BOOL v8 = timingsafe_enable_if_supported();
  v9[0] = a3;
  v7[0] = ccn_n(1uLL, (uint64_t)v9);
  v7[1] = 0;
  void v7[2] = 1;
  _OWORD v7[3] = v9;
  ccz_mul(a1, a2, (uint64_t)v7);
  return cc_disable_dit_with_sb((unsigned int *)&v8);
}

uint64_t ccrsa_generate_key_deterministic(unint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, uint64_t (**a10)(void, unint64_t, uint64_t))
{
  uint64_t v49 = *MEMORY[0x263EF8C08];
  BOOL v47 = timingsafe_enable_if_supported();
  if (a9 == 1)
  {
    memset(v48, 0, 512);
    unsigned int v14 = ccaes_cbc_encrypt_mode();
    uint64_t inited = ccdrbg_df_bc_init_internal(v48, v14, 0x10uLL);
    if (inited)
    {
      uint64_t v36 = inited;
    }
    else
    {
      uint64_t v40 = a4;
      uint64_t v38 = a2;
      uint64_t v39 = a3;
      v46[0] = ccaes_ctr_crypt_mode();
      v46[1] = 16;
      unint64_t v46[2] = 0;
      _OWORD v46[3] = v48;
      uint64_t v45 = 0;
      memset(v44, 0, sizeof(v44));
      ccdrbg_factory_nistctr(v44, (uint64_t)v46);
      unint64_t v16 = (a1 + 63) >> 6;
      uint64_t v17 = sizeof_struct_ccrns_mul_modulus();
      unint64_t v18 = sizeof_struct_ccpolyzp_po2cyc();
      unint64_t v19 = (v17 + v18 - 1) / v18;
      uint64_t v20 = 11 * v16 + 1;
      unint64_t v21 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(v16);
      if (v19 + v20 <= v21) {
        unint64_t v22 = v21;
      }
      else {
        unint64_t v22 = v19 + v20;
      }
      unint64_t v23 = 7 * ((a1 + 63) >> 6);
      unint64_t v24 = v22 + v23;
      uint64_t v25 = 21 * v16 + 2;
      if (v24 <= v19 + v25) {
        unint64_t v24 = v19 + v25;
      }
      unsigned int v26 = cc_malloc_clear((*(void *)&v44[0] + 8 * v24 + 7) & 0xFFFFFFFFFFFFFFF8);
      v42[0] = v26;
      uint64_t v27 = sizeof_struct_ccrns_mul_modulus();
      unint64_t v28 = sizeof_struct_ccpolyzp_po2cyc();
      unint64_t v29 = (v27 + v28 - 1) / v28;
      unint64_t v30 = v29 + v20;
      unint64_t v31 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N((a1 + 63) >> 6);
      if (v30 <= v31) {
        unint64_t v32 = v31;
      }
      else {
        unint64_t v32 = v30;
      }
      unint64_t v33 = v32 + v23;
      unint64_t v34 = v29 + v25;
      if (v33 > v29 + v25) {
        unint64_t v34 = v33;
      }
      v42[1] = v34 + ((unint64_t)(*(void *)&v44[0] + 7) >> 3);
      v42[2] = 0;
      v42[3] = cc_ws_alloc;
      unint64_t v43 = cc_ws_free;
      if (v26)
      {
        BOOL v35 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))cc_ws_alloc(v42, (unint64_t)(*(void *)&v44[0] + 7) >> 3);
        if (!ccdrbg_init_internal((uint64_t)v44))
        {
          memset(v41, 0, sizeof(v41));
          if (!ccrng_drbg_init_withdrbg((uint64_t (**)(uint64_t, uint64_t, uint64_t))v41, (uint64_t (*)(uint64_t, uint64_t, uint64_t))v44, v35)&& !ccrsa_generate_key_internal_ws((uint64_t)v42, a1, v38, v39, v40, v41, a10))
          {
            ccdrbg_done((uint64_t)v44, (uint64_t)v35);
          }
        }
        v43((uint64_t)v42);
        uint64_t v36 = 0;
      }
      else
      {
        uint64_t v36 = 4294967283;
      }
    }
  }
  else
  {
    uint64_t v36 = 4294967289;
  }
  cc_disable_dit_with_sb((unsigned int *)&v47);
  return v36;
}

uint64_t cced448_verify_internal(uint64_t *a1, unint64_t a2, char *a3, char *a4, char *a5)
{
  uint64_t v48 = *MEMORY[0x263EF8C08];
  unint64_t v43 = cc_malloc_clear(0xA48uLL);
  long long v44 = xmmword_2373BB380;
  uint64_t v45 = (uint64_t (*)(void **, uint64_t))cc_ws_alloc;
  BOOL v46 = cc_ws_free;
  if (!v43) {
    return 4294967283;
  }
  uint64_t v10 = *a1;
  uint64_t v11 = cczp_n((uint64_t)a1);
  uint64_t v12 = cc_ws_alloc(&v43, v11);
  uint64_t v13 = v45(&v43, v11);
  unsigned int v14 = (void *)v45(&v43, 3 * v11);
  if (v11)
  {
    int v15 = (uint64_t *)(a4 + 57);
    unint64_t v16 = (void *)v13;
    uint64_t v17 = v11;
    do
    {
      uint64_t v18 = *v15++;
      *v16++ = v18;
      --v17;
    }
    while (v17);
  }
  if (a4[113] || (uint64_t v19 = cczp_prime((uint64_t)&a1[5 * v10 + 4]), (ccn_cmp_internal(v11, v13, v19) & 0x80000000) == 0))
  {
    uint64_t v36 = 4294967150;
  }
  else
  {
    uint64_t v42 = v13;
    uint64_t v20 = cczp_n((uint64_t)a1);
    if ((a5[56] & 0x7F) == 0)
    {
      unint64_t v21 = v20;
      uint64_t v41 = (uint64_t *)v12;
      uint64_t v22 = *a1;
      unint64_t v23 = &v14[*a1];
      if (v20)
      {
        unint64_t v24 = a5;
        uint64_t v25 = &v14[*a1];
        uint64_t v26 = v20;
        do
        {
          uint64_t v27 = *(void *)v24;
          v24 += 8;
          *v25++ = v27;
          --v26;
        }
        while (v26);
      }
      uint64_t v28 = cczp_prime((uint64_t)a1);
      if ((ccn_cmp_internal(v21, v23, v28) & 0x80000000) != 0)
      {
        uint64_t v39 = a3;
        unint64_t v40 = a2;
        unint64_t v29 = &v14[2 * v22];
        uint64_t v38 = *((void *)&v44 + 1);
        v45(&v43, v21);
        uint64_t v30 = v45(&v43, v21);
        uint64_t v31 = v45(&v43, v21);
        ccn_seti(v21, v29, 1);
        cczp_sqr_ws((uint64_t)&v43, (uint64_t)a1);
        cczp_mul_ws((uint64_t)&v43, (uint64_t)a1);
        cczp_sub_ws((uint64_t)&v43, (uint64_t)a1);
        cczp_sub_ws((uint64_t)&v43, (uint64_t)a1);
        cczp_sqr_ws((uint64_t)&v43, (uint64_t)a1);
        cczp_mul_ws((uint64_t)&v43, (uint64_t)a1);
        cczp_sqr_ws((uint64_t)&v43, (uint64_t)a1);
        cczp_mul_ws((uint64_t)&v43, (uint64_t)a1);
        cczp_mul_ws((uint64_t)&v43, (uint64_t)a1);
        cczp_mul_ws((uint64_t)&v43, (uint64_t)a1);
        uint64_t v32 = cczp_power_fast_ws((uint64_t)&v43, (uint64_t)a1, v14, v14, (uint64_t)&kPsub3div4);
        if (v32)
        {
LABEL_29:
          uint64_t v36 = v32;
          goto LABEL_24;
        }
        cczp_mul_ws((uint64_t)&v43, (uint64_t)a1);
        cczp_mul_ws((uint64_t)&v43, (uint64_t)a1);
        cczp_sqr_ws((uint64_t)&v43, (uint64_t)a1);
        cczp_mul_ws((uint64_t)&v43, (uint64_t)a1);
        cczp_from_ws((uint64_t)&v43, (uint64_t)a1);
        cczp_from_ws((uint64_t)&v43, (uint64_t)a1);
        if (!ccn_cmp_internal(v21, v30, v31))
        {
          cczp_from_ws((uint64_t)&v43, (uint64_t)a1);
          int v33 = a5[56];
          if (ccn_n(v21, (uint64_t)v14) || (v33 & 0x80000000) == 0)
          {
            if ((*v14 & 1) == (unint64_t)v33 >> 7) {
              cczp_negate((uint64_t)a1, v14, v14);
            }
            *((void *)&v44 + 1) = v38;
            cced448_shake_to_scalar_ws((uint64_t)&v43, a1, v41, 0x39uLL, a4, 0x39uLL, a5, v40, v39);
            cced448_double_scalar_mult_ws((uint64_t)&v43, a1, (char *)v14, v42, (uint64_t)v41);
            uint64_t v32 = ccec_affinify_ws((uint64_t)&v43, (uint64_t)a1);
            if (!v32)
            {
              uint64_t v34 = 0;
              BOOL v35 = &v14[*a1];
              do
              {
                *(void *)&v47[v34 * 8] = v35[v34];
                ++v34;
              }
              while (v34 != 7);
              v47[56] = *(unsigned char *)v14 << 7;
              if (cc_cmp_safe_internal(57, v47, a4)) {
                uint64_t v36 = 4294967150;
              }
              else {
                uint64_t v36 = 0;
              }
              goto LABEL_24;
            }
            goto LABEL_29;
          }
        }
      }
    }
    uint64_t v36 = 4294967289;
  }
LABEL_24:
  *((void *)&v44 + 1) = 0;
  v46((uint64_t)&v43);
  return v36;
}

uint64_t cced448_verify(unint64_t a1, char *a2, char *a3, char *a4)
{
  BOOL v11 = timingsafe_enable_if_supported();
  BOOL v8 = (uint64_t *)ccec_cp_ed448();
  uint64_t v9 = cced448_verify_internal(v8, a1, a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v11);
  return v9;
}

uint64_t cckeccak_f1600_c(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v1 = a1[1];
  uint64_t v3 = a1[10];
  uint64_t v4 = a1[11];
  uint64_t v84 = 0;
  uint64_t v85 = a1[20];
  uint64_t v5 = a1[22];
  uint64_t v6 = a1[6];
  uint64_t v87 = a1[7];
  uint64_t v7 = a1[16];
  uint64_t v8 = a1[17];
  uint64_t v10 = a1[2];
  uint64_t v9 = a1[3];
  uint64_t v11 = a1[12];
  uint64_t v12 = a1[13];
  uint64_t v13 = a1[23];
  uint64_t v14 = a1[24];
  uint64_t v15 = a1[4];
  uint64_t v16 = a1[5];
  uint64_t v18 = a1[8];
  uint64_t v17 = a1[9];
  uint64_t v19 = a1[14];
  uint64_t v20 = a1[15];
  uint64_t v21 = a1[18];
  uint64_t v22 = a1[19];
  uint64_t result = a1[21];
  do
  {
    uint64_t v81 = result;
    uint64_t v82 = v16;
    uint64_t v24 = v20;
    uint64_t v83 = v20;
    uint64_t v25 = v3;
    uint64_t v79 = v19;
    uint64_t v80 = v22;
    uint64_t v26 = v16 ^ v2 ^ v3 ^ v24;
    uint64_t v27 = v7;
    uint64_t v28 = v6 ^ v1 ^ v4 ^ v7 ^ result;
    uint64_t v29 = v8;
    uint64_t v30 = v87 ^ v10 ^ v11 ^ v8;
    uint64_t v31 = v18;
    uint64_t v32 = v18 ^ v9 ^ v12 ^ v21;
    uint64_t v33 = v15;
    uint64_t v34 = v13;
    uint64_t v35 = v17 ^ v15 ^ v19 ^ v22 ^ v14;
    uint64_t v36 = v35 ^ __ROR8__(v28, 63);
    uint64_t v37 = v32 ^ v34;
    uint64_t v38 = v28 ^ __ROR8__(v37, 63);
    uint64_t v39 = v26 ^ v85;
    uint64_t v40 = v37 ^ __ROR8__(v39, 63);
    uint64_t v41 = v30 ^ v5;
    uint64_t v42 = v39 ^ __ROR8__(v41, 63);
    uint64_t v43 = v14 ^ v40;
    uint64_t v44 = v41 ^ __ROR8__(v35, 63);
    uint64_t v45 = v36 ^ v2;
    uint64_t v46 = v44 ^ v9;
    uint64_t v47 = __ROR8__(v44 ^ v21, 43);
    uint64_t v78 = v45 & ~__ROR8__(v43, 50) ^ v47;
    uint64_t v48 = v38 ^ v10;
    uint64_t v77 = __ROR8__(v43, 50) & ~v47 ^ __ROR8__(v38 ^ v11, 21);
    uint64_t v49 = __ROR8__(v38 ^ v11, 21) & ~__ROR8__(v42 ^ v6, 20);
    uint64_t v50 = v42 ^ v1;
    uint64_t v51 = v40 ^ v33;
    uint64_t v76 = v47 & ~__ROR8__(v38 ^ v11, 21) ^ __ROR8__(v42 ^ v6, 20);
    uint64_t v75 = __ROR8__(v42 ^ v6, 20) & ~v45 ^ __ROR8__(v43, 50);
    uint64_t v52 = v36 ^ v82;
    uint64_t v53 = v36 ^ v25;
    uint64_t v54 = v36 ^ v83;
    uint64_t v55 = v36 ^ v85;
    uint64_t v56 = v42 ^ v4;
    uint64_t v57 = v42 ^ v27;
    uint64_t v58 = v42 ^ v81;
    uint64_t v59 = v17 ^ v40;
    uint64_t v60 = __ROR8__(v17 ^ v40, 44);
    uint64_t v61 = v38 ^ v87;
    uint64_t v62 = v38 ^ v29;
    uint64_t v63 = v38 ^ v5;
    uint64_t v64 = __ROR8__(v38 ^ v5, 3);
    uint64_t v65 = v44 ^ v31;
    uint64_t v66 = v44 ^ v12;
    uint64_t v67 = v44 ^ v34;
    uint64_t v68 = v79 ^ v40;
    uint64_t v86 = __ROR8__(v79 ^ v40, 25);
    uint64_t v69 = v80 ^ v40;
    uint64_t v2 = v49 ^ *(void *)((char *)&unk_2373BB3C8 + v84) ^ v45;
    uint64_t v70 = __ROR8__(v53, 61) & ~__ROR8__(v59, 44);
    uint64_t v6 = __ROR8__(v57, 19) & ~__ROR8__(v53, 61) ^ __ROR8__(v59, 44);
    uint64_t v87 = v64 & ~__ROR8__(v57, 19) ^ __ROR8__(v53, 61);
    uint64_t v71 = __ROR8__(v48, 2);
    uint64_t v16 = v70 ^ __ROR8__(v46, 36);
    uint64_t v18 = __ROR8__(v46, 36) & ~__ROR8__(v63, 3) ^ __ROR8__(v57, 19);
    uint64_t v17 = v60 & ~__ROR8__(v46, 36) ^ __ROR8__(v63, 3);
    uint64_t v3 = __ROR8__(v66, 39) & ~__ROR8__(v61, 58) ^ __ROR8__(v50, 63);
    uint64_t v4 = __ROR8__(v69, 56) & ~__ROR8__(v66, 39) ^ __ROR8__(v61, 58);
    uint64_t v11 = __ROR8__(v55, 46) & ~__ROR8__(v69, 56) ^ __ROR8__(v66, 39);
    uint64_t v12 = __ROR8__(v50, 63) & ~__ROR8__(v55, 46) ^ __ROR8__(v69, 56);
    uint64_t v19 = __ROR8__(v61, 58) & ~__ROR8__(v50, 63) ^ __ROR8__(v55, 46);
    uint64_t v7 = __ROR8__(v62, 49) & ~__ROR8__(v56, 54) ^ __ROR8__(v52, 28);
    uint64_t v8 = __ROR8__(v67, 8) & ~__ROR8__(v62, 49) ^ __ROR8__(v56, 54);
    uint64_t v72 = __ROR8__(v52, 28) & ~__ROR8__(v51, 37);
    uint64_t v20 = __ROR8__(v56, 54) & ~__ROR8__(v52, 28) ^ __ROR8__(v51, 37);
    uint64_t v21 = __ROR8__(v51, 37) & ~__ROR8__(v67, 8) ^ __ROR8__(v62, 49);
    uint64_t v15 = v75;
    uint64_t v1 = v76;
    uint64_t v22 = v72 ^ __ROR8__(v67, 8);
    uint64_t v73 = __ROR8__(v65, 9) & ~v71;
    uint64_t v85 = v86 & ~__ROR8__(v65, 9) ^ v71;
    uint64_t v10 = v77;
    uint64_t v9 = v78;
    uint64_t result = __ROR8__(v54, 23) & ~__ROR8__(v68, 25) ^ __ROR8__(v65, 9);
    uint64_t v5 = __ROR8__(v58, 62) & ~__ROR8__(v54, 23) ^ __ROR8__(v68, 25);
    uint64_t v13 = v71 & ~__ROR8__(v58, 62) ^ __ROR8__(v54, 23);
    uint64_t v14 = v73 ^ __ROR8__(v58, 62);
    v84 += 8;
  }
  while (v84 != 192);
  *a1 = v2;
  a1[1] = v76;
  a1[10] = v3;
  a1[11] = v4;
  a1[20] = v85;
  a1[21] = result;
  a1[6] = v6;
  a1[7] = v87;
  a1[16] = v7;
  a1[17] = v8;
  a1[2] = v77;
  a1[3] = v78;
  a1[12] = v11;
  a1[13] = v12;
  a1[22] = v5;
  a1[23] = v13;
  a1[4] = v75;
  a1[5] = v16;
  a1[8] = v18;
  a1[9] = v17;
  a1[14] = v19;
  a1[15] = v20;
  a1[18] = v21;
  a1[19] = v22;
  a1[24] = v14;
  return result;
}

uint64_t cckeccak_absorb_blocks(uint64_t result, unint64_t a2, uint64_t a3, uint64_t *a4, uint64_t (*a5)(void *))
{
  if (a3)
  {
    uint64_t v9 = (void *)result;
    uint64_t v10 = 0;
    if (a2 >> 3 <= 1) {
      uint64_t v11 = 1;
    }
    else {
      uint64_t v11 = a2 >> 3;
    }
    do
    {
      uint64_t v12 = v9;
      uint64_t v13 = v11;
      if (a2 >= 8)
      {
        do
        {
          uint64_t v14 = *a4++;
          *v12++ ^= v14;
          --v13;
        }
        while (v13);
      }
      uint64_t result = a5(v9);
      ++v10;
    }
    while (v10 != a3);
  }
  return result;
}

uint64_t cckeccak_absorb_and_pad(uint64_t result, unint64_t a2, unint64_t a3, uint64_t *a4, unsigned int a5, uint64_t (*a6)(void *))
{
  uint64_t v10 = (void *)result;
  v25[1] = *MEMORY[0x263EF8C08];
  unint64_t v11 = a3 / a2;
  if (a2 <= a3)
  {
    uint64_t v13 = 0;
    if (a2 >> 3 <= 1) {
      uint64_t v14 = 1;
    }
    else {
      uint64_t v14 = a2 >> 3;
    }
    uint64_t v15 = a4;
    do
    {
      uint64_t v16 = v10;
      uint64_t v17 = v14;
      if (a2 >= 8)
      {
        do
        {
          uint64_t v18 = *v15++;
          *v16++ ^= v18;
          --v17;
        }
        while (v17);
      }
      uint64_t result = a6(v10);
      ++v13;
    }
    while (v13 != v11);
  }
  unint64_t v19 = a3 - v11 * a2;
  uint64_t v20 = (uint64_t *)((char *)a4 + v11 * a2);
  unint64_t v21 = v19 >> 3;
  if (v19 >= 8)
  {
    uint64_t v22 = 0;
    if (v21 <= 1) {
      uint64_t v23 = 1;
    }
    else {
      uint64_t v23 = v19 >> 3;
    }
    do
    {
      uint64_t v24 = *v20++;
      v10[v22++] ^= v24;
    }
    while (v23 != v22);
  }
  else
  {
    uint64_t v22 = 0;
  }
  if ((a3 & 7) != 0)
  {
    v25[0] = 0;
    __memcpy_chk();
    v10[v22] = v10[v22];
    uint64_t result = cc_clear(8uLL, v25);
  }
  v10[v21] ^= (unint64_t)a5 << (8 * (v19 & 7u));
  *(void *)((char *)v10 + ((a2 - 1) & 0xFFFFFFFFFFFFFFF8)) ^= 128 << (8 * ((a2 - 1) & 7));
  return result;
}

uint64_t cckeccak_squeeze(uint64_t result, unint64_t a2, unint64_t a3, void *a4, uint64_t (*a5)(uint64_t *))
{
  unint64_t v7 = a3;
  uint64_t v8 = (uint64_t *)result;
  v18[1] = *MEMORY[0x263EF8C08];
  if (a3 >= a2)
  {
    if (a2 >> 3 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = a2 >> 3;
    }
    do
    {
      uint64_t result = a5(v8);
      unint64_t v11 = v8;
      uint64_t v12 = v10;
      if (a2 >= 8)
      {
        do
        {
          uint64_t v13 = *v11++;
          *a4++ = v13;
          --v12;
        }
        while (v12);
      }
      v7 -= a2;
    }
    while (v7 >= a2);
  }
  if (v7)
  {
    uint64_t result = a5(v8);
    if (v7 >= 8)
    {
      unint64_t v14 = v7 >> 3;
      uint64_t v15 = v8;
      unint64_t v16 = v7 >> 3;
      do
      {
        uint64_t v17 = *v15++;
        *a4++ = v17;
        --v16;
      }
      while (v16);
    }
    else
    {
      unint64_t v14 = 0;
    }
    if ((v7 & 7) != 0)
    {
      v18[0] = v8[v14];
      memcpy(a4, v18, v7 & 7);
      return cc_clear(8uLL, v18);
    }
  }
  return result;
}

uint64_t frandom(int8x16_t *a1, void (**a2)(void, uint64_t, int8x16_t *))
{
  unsigned int v4 = 0;
  while (1)
  {
    (*a2)(a2, 32, a1);
    int v5 = a1[1].i8[15] & 0x7F;
    a1[1].i8[15] = v5;
    int8x16_t v6 = vorrq_s8(a1[1], *a1);
    if (vorr_s8(*(int8x8_t *)v6.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL)))
    {
      int v7 = v5 ^ 0x7F;
      uint64_t v8 = 30;
      do
        v7 |= a1->u8[v8--] ^ 0xFF;
      while (v8);
      if (v7 | ((unsigned __int16)(a1->u8[0] - 237) >> 8)) {
        break;
      }
    }
    if (v4++ >= 9) {
      return 0xFFFFFFFFLL;
    }
  }
  return 0;
}

uint64_t ccec_pairwise_consistency_check_ws(uint64_t a1, unint64_t **a2, uint64_t (**a3)(void, unint64_t, void *))
{
  unint64_t v14[2] = *MEMORY[0x263EF8C08];
  unint64_t v6 = **a2;
  char v13 = 0;
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v6);
  uint64_t v9 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v6);
  uint64_t v10 = (unint64_t *)ccsha256_di();
  uint64_t result = ccec_sign_composite_msg_ws(a1, a2, v10, 0, &v13, v8, v9, a3);
  if (!result)
  {
    v14[0] = 0;
    v14[1] = 0;
    uint64_t v12 = (unint64_t *)ccsha256_di();
    uint64_t result = ccec_verify_composite_msg_ws(a1, (uint64_t *)a2, v12, 0, &v13, (uint64_t)v8, (uint64_t)v9, v14);
    if (!result)
    {
      cc_cmp_safe_internal(16, CCEC_FAULT_CANARY, (char *)v14);
      uint64_t result = 0;
    }
  }
  *(void *)(a1 + 16) = v7;
  return result;
}

BOOL ccec_pairwise_consistency_check(unint64_t **a1, uint64_t (**a2)(void, unint64_t, void *))
{
  BOOL v10 = timingsafe_enable_if_supported();
  unsigned int v4 = *a1;
  v8[0] = cc_malloc_clear(392 * **a1);
  v8[1] = 49 * *v4;
  void v8[2] = 0;
  v8[3] = cc_ws_alloc;
  uint64_t v9 = cc_ws_free;
  if (v8[0])
  {
    int v5 = ccec_pairwise_consistency_check_ws((uint64_t)v8, a1, a2);
    v9((uint64_t)v8);
    BOOL v6 = v5 == 0;
  }
  else
  {
    BOOL v6 = 0;
  }
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v6;
}

uint64_t ccec_compact_generate_key_checksign_ws(uint64_t a1, uint64_t (**a2)(void, unint64_t, void *), uint64_t a3)
{
  if (*(unsigned char *)(a3 + 8) != 2) {
    return 4294967210;
  }
  uint64_t result = ccec_sign_internal_ws(a1, (uint64_t **)(a3 + 16 + 16 * *(void *)a3), 0x20uLL, (uint64_t)&FAKE_DIGEST, (void *)(a3 + 16), (void *)(a3 + 16 + 8 * *(void *)a3), a2);
  if (!result) {
    *(unsigned char *)(a3 + 8) = 3;
  }
  return result;
}

uint64_t ccec_compact_generate_key_checkverify_and_extract_ws(uint64_t a1, uint64_t a2, void *a3)
{
  void v7[2] = *MEMORY[0x263EF8C08];
  *a3 = 0;
  if (*(unsigned char *)(a2 + 8) != 3) {
    return 4294967210;
  }
  v7[0] = 0;
  v7[1] = 0;
  uint64_t v5 = ccec_verify_internal_ws(a1, (unint64_t **)(a2 + 16 + 16 * *(void *)a2), 0x20uLL, (uint64_t)&FAKE_DIGEST, a2 + 16, a2 + 16 + 8 * *(void *)a2, (uint64_t)v7);
  if (!v5 && !cc_cmp_safe_internal(16, CCEC_FAULT_CANARY, (char *)v7))
  {
    *(unsigned char *)(a2 + 8) = 4;
    *a3 = a2 + 16 * *(void *)a2 + 16;
  }
  return v5;
}

_DWORD *rmd160_compress(_DWORD *result, uint64_t a2, _DWORD *a3)
{
  v562 = result;
  if (a2)
  {
    int v3 = *result;
    int v4 = result[1];
    int v6 = result[2];
    int v5 = result[3];
    int v7 = result[4];
    do
    {
      int v573 = v3;
      int v571 = v6;
      v574 = a3;
      uint64_t v568 = a2;
      int v8 = *a3;
      int v9 = a3[1];
      HIDWORD(v11) = v6;
      LODWORD(v11) = v6;
      int v10 = v11 >> 22;
      int v12 = a3[2];
      int v13 = a3[3];
      int v14 = a3[4];
      int v15 = a3[5];
      int v16 = a3[6];
      int v17 = a3[7];
      int v18 = a3[8];
      int v19 = a3[9];
      HIDWORD(v11) = (v6 ^ v4 ^ v5) + v3 + *a3;
      LODWORD(v11) = HIDWORD(v11);
      int v20 = (v11 >> 21) + v7;
      int v572 = v7;
      HIDWORD(v11) = v9 + v7 + (v4 ^ __ROR4__(v6, 22) ^ v20);
      LODWORD(v11) = HIDWORD(v11);
      int v21 = v11 >> 18;
      HIDWORD(v11) = v4;
      LODWORD(v11) = v4;
      int v22 = v11 >> 22;
      int v23 = a3[10];
      int v24 = a3[11];
      int v25 = v21 + v5;
      int v26 = a3[12];
      LODWORD(v11) = v12 + v5 + (v20 ^ __ROR4__(v4, 22) ^ v25);
      HIDWORD(v11) = v11;
      int v27 = v11 >> 17;
      int v28 = a3[13];
      int v29 = a3[14];
      int v30 = a3[15];
      HIDWORD(v11) = v20;
      LODWORD(v11) = v20;
      int v31 = v11 >> 22;
      int v567 = v10;
      int v32 = v27 + v10;
      LODWORD(v11) = v13 + v10 + (v25 ^ __ROR4__(v20, 22) ^ v32);
      HIDWORD(v11) = v11;
      int v33 = (v11 >> 20) + v22;
      HIDWORD(v11) = v25;
      LODWORD(v11) = v25;
      int v34 = v11 >> 22;
      LODWORD(v11) = v14 + v22 + (v32 ^ __ROR4__(v25, 22) ^ v33);
      HIDWORD(v11) = v11;
      int v35 = v11 >> 27;
      HIDWORD(v11) = v32;
      LODWORD(v11) = v32;
      int v36 = v11 >> 22;
      int v37 = v35 + v31;
      LODWORD(v11) = v31 + v15 + (v33 ^ __ROR4__(v32, 22) ^ v37);
      HIDWORD(v11) = v11;
      int v38 = (v11 >> 24) + v34;
      HIDWORD(v11) = v33;
      LODWORD(v11) = v33;
      int v39 = v11 >> 22;
      LODWORD(v11) = v34 + v16 + (v37 ^ __ROR4__(v33, 22) ^ v38);
      HIDWORD(v11) = v11;
      int v40 = v11 >> 25;
      HIDWORD(v11) = v37;
      LODWORD(v11) = v37;
      int v41 = v11 >> 22;
      int v42 = v40 + v36;
      LODWORD(v11) = v36 + v17 + (v38 ^ __ROR4__(v37, 22) ^ v42);
      HIDWORD(v11) = v11;
      int v43 = (v11 >> 23) + v39;
      HIDWORD(v11) = v38;
      LODWORD(v11) = v38;
      int v44 = v11 >> 22;
      LODWORD(v11) = v39 + v18 + (v42 ^ __ROR4__(v38, 22) ^ v43);
      HIDWORD(v11) = v11;
      int v45 = v11 >> 21;
      HIDWORD(v11) = v42;
      LODWORD(v11) = v42;
      int v46 = v11 >> 22;
      int v47 = v45 + v41;
      int v48 = v19;
      LODWORD(v11) = v41 + v19 + (v43 ^ __ROR4__(v42, 22) ^ v47);
      HIDWORD(v11) = v11;
      int v49 = (v11 >> 19) + v44;
      HIDWORD(v11) = v43;
      LODWORD(v11) = v43;
      int v50 = v11 >> 22;
      LODWORD(v11) = v44 + v23 + (v47 ^ __ROR4__(v43, 22) ^ v49);
      HIDWORD(v11) = v11;
      int v51 = v11 >> 18;
      HIDWORD(v11) = v47;
      LODWORD(v11) = v47;
      int v52 = v11 >> 22;
      int v53 = v51 + v46;
      int v54 = v24;
      LODWORD(v11) = v46 + v24 + (v49 ^ __ROR4__(v47, 22) ^ v53);
      HIDWORD(v11) = v11;
      int v55 = (v11 >> 17) + v50;
      HIDWORD(v11) = v49;
      LODWORD(v11) = v49;
      int v56 = v11 >> 22;
      LODWORD(v11) = v50 + v26 + (v53 ^ __ROR4__(v49, 22) ^ v55);
      HIDWORD(v11) = v11;
      int v57 = v11 >> 26;
      HIDWORD(v11) = v53;
      LODWORD(v11) = v53;
      int v58 = v11 >> 22;
      int v59 = v57 + v52;
      LODWORD(v11) = v52 + v28 + (v55 ^ __ROR4__(v53, 22) ^ v59);
      HIDWORD(v11) = v11;
      int v60 = (v11 >> 25) + v56;
      HIDWORD(v11) = v55;
      LODWORD(v11) = v55;
      int v61 = v11 >> 22;
      LODWORD(v11) = v56 + v29 + (v59 ^ __ROR4__(v55, 22) ^ v60);
      HIDWORD(v11) = v11;
      int v62 = v11 >> 23;
      HIDWORD(v11) = v59;
      LODWORD(v11) = v59;
      int v63 = v11 >> 22;
      int v64 = v62 + v58;
      LODWORD(v11) = v58 + v30 + (v60 ^ __ROR4__(v59, 22) ^ v64);
      HIDWORD(v11) = v11;
      int v65 = (v11 >> 24) + v61;
      HIDWORD(v11) = v60;
      LODWORD(v11) = v60;
      int v66 = v11 >> 22;
      HIDWORD(v11) = v17 + 1518500249 + v61 + (v66 & ~v65) + (v65 & v64);
      LODWORD(v11) = HIDWORD(v11);
      int v67 = (v11 >> 25) + v63;
      HIDWORD(v11) = v64;
      LODWORD(v11) = v64;
      int v68 = v11 >> 22;
      HIDWORD(v11) = v14 + 1518500249 + v63 + (v68 & ~v67) + (v67 & v65);
      LODWORD(v11) = HIDWORD(v11);
      int v69 = (v11 >> 26) + v66;
      HIDWORD(v11) = v65;
      LODWORD(v11) = v65;
      int v70 = v11 >> 22;
      HIDWORD(v11) = v28 + 1518500249 + v66 + (v70 & ~v69) + (v69 & v67);
      LODWORD(v11) = HIDWORD(v11);
      int v71 = (v11 >> 24) + v68;
      HIDWORD(v11) = v67;
      LODWORD(v11) = v67;
      int v72 = v11 >> 22;
      HIDWORD(v11) = v9 + 1518500249 + v68 + (v72 & ~v71) + (v71 & v69);
      LODWORD(v11) = HIDWORD(v11);
      int v73 = (v11 >> 19) + v70;
      HIDWORD(v11) = v69;
      LODWORD(v11) = v69;
      int v74 = v11 >> 22;
      HIDWORD(v11) = v23 + 1518500249 + v70 + (v74 & ~v73) + (v73 & v71);
      LODWORD(v11) = HIDWORD(v11);
      int v75 = (v11 >> 21) + v72;
      HIDWORD(v11) = v71;
      LODWORD(v11) = v71;
      int v76 = v11 >> 22;
      int v566 = v16;
      HIDWORD(v11) = v16 + 1518500249 + v72 + (v76 & ~v75) + (v75 & v73);
      LODWORD(v11) = HIDWORD(v11);
      int v77 = (v11 >> 23) + v74;
      HIDWORD(v11) = v73;
      LODWORD(v11) = v73;
      int v78 = v11 >> 22;
      HIDWORD(v11) = v30 + 1518500249 + v74 + (v78 & ~v77) + (v77 & v75);
      LODWORD(v11) = HIDWORD(v11);
      int v79 = (v11 >> 25) + v76;
      HIDWORD(v11) = v75;
      LODWORD(v11) = v75;
      int v80 = v11 >> 22;
      int v570 = v13;
      HIDWORD(v11) = v13 + 1518500249 + v76 + (v80 & ~v79) + (v79 & v77);
      LODWORD(v11) = HIDWORD(v11);
      int v81 = (v11 >> 17) + v78;
      HIDWORD(v11) = v77;
      LODWORD(v11) = v77;
      int v82 = v11 >> 22;
      HIDWORD(v11) = v26 + 1518500249 + v78 + (v82 & ~v81) + (v81 & v79);
      LODWORD(v11) = HIDWORD(v11);
      int v83 = (v11 >> 25) + v80;
      HIDWORD(v11) = v79;
      LODWORD(v11) = v79;
      int v84 = v11 >> 22;
      HIDWORD(v11) = v8 + 1518500249 + v80 + (v84 & ~v83) + (v83 & v81);
      LODWORD(v11) = HIDWORD(v11);
      int v85 = (v11 >> 20) + v82;
      HIDWORD(v11) = v81;
      LODWORD(v11) = v81;
      int v86 = v11 >> 22;
      HIDWORD(v11) = v48 + 1518500249 + v82 + (v86 & ~v85) + (v85 & v83);
      LODWORD(v11) = HIDWORD(v11);
      int v87 = (v11 >> 17) + v84;
      HIDWORD(v11) = v83;
      LODWORD(v11) = v83;
      int v88 = v11 >> 22;
      HIDWORD(v11) = v15 + 1518500249 + v84 + (v88 & ~v87) + (v87 & v85);
      LODWORD(v11) = HIDWORD(v11);
      int v89 = (v11 >> 23) + v86;
      HIDWORD(v11) = v85;
      LODWORD(v11) = v85;
      int v90 = v11 >> 22;
      HIDWORD(v11) = v12 + 1518500249 + v86 + (v90 & ~v89) + (v89 & v87);
      LODWORD(v11) = HIDWORD(v11);
      int v91 = (v11 >> 21) + v88;
      HIDWORD(v11) = v87;
      LODWORD(v11) = v87;
      int v92 = v11 >> 22;
      int v93 = v29 + 1518500249 + v88 + (v92 & ~v91) + (v91 & v89);
      HIDWORD(v11) = v89;
      LODWORD(v11) = v89;
      int v94 = v11 >> 22;
      HIDWORD(v11) = v93;
      LODWORD(v11) = v93;
      int v95 = (v11 >> 25) + v90;
      HIDWORD(v11) = v54 + 1518500249 + v90 + (v94 & ~v95) + (v95 & v91);
      LODWORD(v11) = HIDWORD(v11);
      int v96 = v11 >> 19;
      HIDWORD(v11) = v91;
      LODWORD(v11) = v91;
      int v97 = v11 >> 22;
      int v98 = v96 + v92;
      HIDWORD(v11) = v18 + 1518500249 + v92 + (v97 & ~v98) + (v98 & v95);
      LODWORD(v11) = HIDWORD(v11);
      unsigned int v99 = (v11 >> 20) + v94;
      HIDWORD(v11) = v95;
      LODWORD(v11) = v95;
      int v100 = v11 >> 22;
      LODWORD(v11) = v13 + 1859775393 + v94 + ((v99 | ~v98) ^ __ROR4__(v95, 22));
      HIDWORD(v11) = v11;
      int v101 = (v11 >> 21) + v97;
      HIDWORD(v11) = v98;
      LODWORD(v11) = v98;
      int v102 = v11 >> 22;
      int v569 = v23;
      unint64_t v103 = __PAIR64__(v99, __ROR4__(v98, 22));
      int v104 = v23 + 1859775393 + v97 + ((v101 | ~v99) ^ v103);
      LODWORD(v103) = v99;
      int v105 = v103 >> 22;
      HIDWORD(v103) = v104;
      LODWORD(v103) = v104;
      int v106 = (v103 >> 19) + v100;
      LODWORD(v103) = v29 + 1859775393 + v100 + ((v106 | ~v101) ^ __ROR4__(v99, 22));
      HIDWORD(v103) = v103;
      unsigned int v107 = (v103 >> 26) + v102;
      HIDWORD(v103) = v101;
      LODWORD(v103) = v101;
      int v108 = v103 >> 22;
      LODWORD(v103) = v14 + 1859775393 + v102 + ((v107 | ~v106) ^ __ROR4__(v101, 22));
      HIDWORD(v103) = v103;
      int v109 = (v103 >> 25) + v105;
      HIDWORD(v103) = v106;
      LODWORD(v103) = v106;
      int v110 = v103 >> 22;
      unint64_t v111 = __PAIR64__(v107, __ROR4__(v106, 22));
      int v112 = v48 + 1859775393 + v105 + ((v109 | ~v107) ^ v111);
      LODWORD(v111) = v107;
      int v113 = v111 >> 22;
      HIDWORD(v111) = v112;
      LODWORD(v111) = v112;
      int v114 = (v111 >> 18) + v108;
      LODWORD(v111) = v30 + 1859775393 + v108 + ((v114 | ~v109) ^ __ROR4__(v107, 22));
      HIDWORD(v111) = v111;
      unsigned int v115 = (v111 >> 23) + v110;
      HIDWORD(v111) = v109;
      LODWORD(v111) = v109;
      int v116 = v111 >> 22;
      LODWORD(v111) = v18 + 1859775393 + v110 + ((v115 | ~v114) ^ __ROR4__(v109, 22));
      HIDWORD(v111) = v111;
      int v117 = (v111 >> 19) + v113;
      HIDWORD(v111) = v114;
      LODWORD(v111) = v114;
      int v118 = v111 >> 22;
      int v565 = v9;
      unint64_t v119 = __PAIR64__(v115, __ROR4__(v114, 22));
      int v120 = v9 + 1859775393 + v113 + ((v117 | ~v115) ^ v119);
      LODWORD(v119) = v115;
      int v121 = v119 >> 22;
      HIDWORD(v119) = v120;
      LODWORD(v119) = v120;
      int v122 = (v119 >> 17) + v116;
      int v564 = v12;
      LODWORD(v119) = v12 + 1859775393 + v116 + ((v122 | ~v117) ^ __ROR4__(v115, 22));
      HIDWORD(v119) = v119;
      unsigned int v123 = (v119 >> 18) + v118;
      HIDWORD(v119) = v117;
      LODWORD(v119) = v117;
      int v124 = v119 >> 22;
      LODWORD(v119) = v17 + 1859775393 + v118 + ((v123 | ~v122) ^ __ROR4__(v117, 22));
      HIDWORD(v119) = v119;
      int v125 = (v119 >> 24) + v121;
      HIDWORD(v119) = v122;
      LODWORD(v119) = v122;
      int v126 = v119 >> 22;
      unint64_t v127 = __PAIR64__(v123, __ROR4__(v122, 22));
      int v128 = v8 + 1859775393 + v121 + ((v125 | ~v123) ^ v127);
      LODWORD(v127) = v123;
      int v129 = v127 >> 22;
      HIDWORD(v127) = v128;
      LODWORD(v127) = v128;
      int v130 = (v127 >> 19) + v124;
      LODWORD(v127) = v16 + 1859775393 + v124 + ((v130 | ~v125) ^ __ROR4__(v123, 22));
      HIDWORD(v127) = v127;
      unsigned int v131 = (v127 >> 26) + v126;
      HIDWORD(v127) = v125;
      LODWORD(v127) = v125;
      int v132 = v127 >> 22;
      LODWORD(v127) = v28 + 1859775393 + v126 + ((v131 | ~v130) ^ __ROR4__(v125, 22));
      HIDWORD(v127) = v127;
      int v133 = (v127 >> 27) + v129;
      HIDWORD(v127) = v130;
      LODWORD(v127) = v130;
      int v134 = v127 >> 22;
      unint64_t v135 = __PAIR64__(v131, __ROR4__(v130, 22));
      int v136 = v54 + 1859775393 + v129 + ((v133 | ~v131) ^ v135);
      LODWORD(v135) = v131;
      int v137 = v135 >> 22;
      HIDWORD(v135) = v136;
      LODWORD(v135) = v136;
      int v138 = (v135 >> 20) + v132;
      LODWORD(v135) = v15 + 1859775393 + v132 + ((v138 | ~v133) ^ __ROR4__(v131, 22));
      HIDWORD(v135) = v135;
      int v139 = (v135 >> 25) + v134;
      HIDWORD(v135) = v133;
      LODWORD(v135) = v133;
      int v140 = v135 >> 22;
      LODWORD(v135) = v26 + 1859775393 + v134 + ((v139 | ~v138) ^ __ROR4__(v133, 22));
      HIDWORD(v135) = v135;
      unsigned int v141 = (v135 >> 27) + v137;
      HIDWORD(v135) = v138;
      LODWORD(v135) = v138;
      int v142 = v135 >> 22;
      LODWORD(v135) = v9 - 1894007588 + v137 + (v139 & ~__ROR4__(v138, 22)) + (v141 & __ROR4__(v138, 22));
      HIDWORD(v135) = v135;
      unsigned int v143 = (v135 >> 21) + v140;
      HIDWORD(v135) = v139;
      LODWORD(v135) = v139;
      int v144 = v135 >> 22;
      LODWORD(v135) = v48 - 1894007588 + v140 + (v141 & ~__ROR4__(v139, 22)) + (v143 & __ROR4__(v139, 22));
      HIDWORD(v135) = v135;
      unsigned int v145 = (v135 >> 20) + v142;
      int v146 = v54 - 1894007588 + v142 + (v143 & ~__ROR4__(v141, 22)) + (v145 & __ROR4__(v141, 22));
      unint64_t v147 = __PAIR64__(v146, __ROR4__(v143, 22));
      int v148 = v23 - 1894007588 + v144 + (v145 & ~v147);
      LODWORD(v147) = v146;
      unsigned int v149 = (v147 >> 18) + v144;
      HIDWORD(v147) = v573 + 1352829926 + ((v571 | ~v5) ^ v4) + v15;
      LODWORD(v147) = HIDWORD(v147);
      unsigned int v150 = (v147 >> 24) + v572;
      LODWORD(v147) = v572 + 1352829926 + v29 + (v150 ^ (v4 | ~__ROR4__(v571, 22)));
      HIDWORD(v147) = v147;
      int v151 = (v147 >> 23) + v5;
      int v152 = v5 + 1352829926 + v17 + (v151 ^ (v150 | ~__ROR4__(v4, 22)));
      unint64_t v153 = __PAIR64__(v152, __ROR4__(v143, 22));
      int v154 = v148 + (v149 & v153);
      LODWORD(v153) = v152;
      unsigned int v155 = (v153 >> 23) + v567;
      LODWORD(v153) = v567 + 1352829926 + v8 + (v155 ^ (v151 | ~__ROR4__(v150, 22)));
      HIDWORD(v153) = v153;
      int v156 = (v153 >> 21) + v22;
      unint64_t v157 = __PAIR64__(v150, __ROR4__(v151, 22));
      int v158 = v22 + 1352829926 + v48 + (v156 ^ (v155 | ~v157));
      LODWORD(v157) = v150;
      int v159 = v157 >> 22;
      HIDWORD(v157) = v158;
      LODWORD(v157) = v158;
      unsigned int v160 = (v157 >> 19) + v159;
      unint64_t v161 = __PAIR64__(v141, __ROR4__(v155, 22));
      int v162 = v12 + 1352829926 + v159 + (v160 ^ (v156 | ~v161));
      LODWORD(v161) = v141;
      int v163 = v161 >> 22;
      HIDWORD(v161) = v154;
      LODWORD(v161) = v154;
      unsigned int v164 = (v161 >> 17) + v163;
      HIDWORD(v161) = v151;
      LODWORD(v161) = v151;
      int v165 = v161 >> 22;
      HIDWORD(v161) = v162;
      LODWORD(v161) = v162;
      int v166 = v8;
      int v563 = v8;
      unsigned int v167 = (v161 >> 17) + v165;
      unint64_t v168 = __PAIR64__(v155, __ROR4__(v156, 22));
      int v169 = v54 + 1352829926 + v165 + (v167 ^ (v160 | ~v168));
      LODWORD(v168) = v155;
      int v170 = v168 >> 22;
      HIDWORD(v168) = v169;
      LODWORD(v168) = v169;
      int v171 = (v168 >> 17) + v170;
      unint64_t v172 = __PAIR64__(v143, __ROR4__(v145, 22));
      unsigned int v173 = v8 - 1894007588 + v163 + (v149 & ~__ROR4__(v145, 22)) + (v164 & v172);
      LODWORD(v172) = v143;
      int v174 = v172 >> 22;
      int v175 = v18 - 1894007588 + v174 + (v164 & ~__ROR4__(v149, 22));
      unint64_t v176 = __PAIR64__(v173, __ROR4__(v160, 22));
      int v177 = v14 + 1352829926 + v170 + (v171 ^ (v167 | ~v176));
      LODWORD(v176) = v173;
      unsigned int v178 = (v176 >> 18) + v174;
      HIDWORD(v176) = v156;
      LODWORD(v176) = v156;
      int v179 = v176 >> 22;
      HIDWORD(v176) = v177;
      LODWORD(v176) = v177;
      unsigned int v180 = (v176 >> 27) + v179;
      unint64_t v181 = __PAIR64__(v160, __ROR4__(v149, 22));
      int v182 = v175 + (v178 & v181);
      LODWORD(v181) = v160;
      int v183 = v181 >> 22;
      HIDWORD(v181) = v28 + 1352829926 + v179 + (v180 ^ (v171 | ~__ROR4__(v167, 22)));
      LODWORD(v181) = HIDWORD(v181);
      int v184 = (v181 >> 25) + v183;
      unint64_t v185 = __PAIR64__(v167, __ROR4__(v171, 22));
      int v186 = v566 + 1352829926 + v183 + (v184 ^ (v180 | ~v185));
      LODWORD(v185) = v167;
      int v187 = v185 >> 22;
      HIDWORD(v185) = v186;
      LODWORD(v185) = v186;
      unsigned int v188 = (v185 >> 25) + v187;
      unint64_t v189 = __PAIR64__(v145, __ROR4__(v180, 22));
      int v190 = v30 + 1352829926 + v187 + (v188 ^ (v184 | ~v189));
      LODWORD(v189) = v145;
      int v191 = v189 >> 22;
      HIDWORD(v189) = v182;
      LODWORD(v189) = v182;
      unsigned int v192 = (v189 >> 17) + v191;
      HIDWORD(v189) = v171;
      LODWORD(v189) = v171;
      int v193 = v189 >> 22;
      HIDWORD(v189) = v190;
      LODWORD(v189) = v190;
      unsigned int v194 = (v189 >> 24) + v193;
      unint64_t v195 = __PAIR64__(v180, __ROR4__(v184, 22));
      int v196 = v18 + 1352829926 + v193 + (v194 ^ (v188 | ~v195));
      LODWORD(v195) = v180;
      int v197 = v195 >> 22;
      HIDWORD(v195) = v196;
      LODWORD(v195) = v196;
      unsigned int v198 = (v195 >> 21) + v197;
      unint64_t v199 = __PAIR64__(v149, __ROR4__(v164, 22));
      unsigned int v200 = v26 - 1894007588 + v191 + (v178 & ~__ROR4__(v164, 22)) + (v192 & v199);
      LODWORD(v199) = v149;
      int v201 = v199 >> 22;
      int v202 = v14 - 1894007588 + v201 + (v192 & ~__ROR4__(v178, 22));
      unint64_t v203 = __PAIR64__(v200, __ROR4__(v188, 22));
      int v204 = v565 + 1352829926 + v197 + (v198 ^ (v194 | ~v203));
      LODWORD(v203) = v200;
      unsigned int v205 = (v203 >> 23) + v201;
      HIDWORD(v203) = v184;
      LODWORD(v203) = v184;
      int v206 = v203 >> 22;
      HIDWORD(v203) = v204;
      LODWORD(v203) = v204;
      unsigned int v207 = (v203 >> 18) + v206;
      unint64_t v208 = __PAIR64__(v164, __ROR4__(v178, 22));
      int v209 = v202 + (v205 & v208);
      LODWORD(v208) = v164;
      int v210 = v208 >> 22;
      unint64_t v211 = __PAIR64__(v188, __ROR4__(v192, 22));
      int v212 = v28 - 1894007588 + v210 + (v205 & ~v211);
      LODWORD(v211) = v188;
      int v213 = v211 >> 22;
      HIDWORD(v211) = v569 + 1352829926 + v206 + (v207 ^ (v198 | ~__ROR4__(v194, 22)));
      LODWORD(v211) = HIDWORD(v211);
      unsigned int v214 = (v211 >> 18) + v213;
      unint64_t v215 = __PAIR64__(v194, __ROR4__(v198, 22));
      int v216 = v13 + 1352829926 + v213 + (v214 ^ (v207 | ~v215));
      LODWORD(v215) = v194;
      int v217 = v215 >> 22;
      HIDWORD(v215) = v216;
      LODWORD(v215) = v216;
      unsigned int v218 = (v215 >> 20) + v217;
      unint64_t v219 = __PAIR64__(v198, __ROR4__(v207, 22));
      int v220 = v26 + 1352829926 + v217 + (v218 ^ (v214 | ~v219));
      LODWORD(v219) = v198;
      int v221 = v219 >> 22;
      HIDWORD(v219) = v220;
      LODWORD(v219) = v220;
      unsigned int v222 = (v219 >> 26) + v221;
      HIDWORD(v219) = v209;
      LODWORD(v219) = v209;
      unsigned int v223 = (v219 >> 24) + v210;
      int v224 = v566 + 1548603684 + v221 + (v218 & ~__ROR4__(v214, 22)) + (v222 & __ROR4__(v214, 22));
      unint64_t v225 = __PAIR64__(v178, __ROR4__(v192, 22));
      unsigned int v226 = v212 + (v223 & v225);
      LODWORD(v225) = v178;
      int v227 = v225 >> 22;
      unint64_t v228 = __PAIR64__(v207, __ROR4__(v205, 22));
      int v229 = v13 - 1894007588 + v227 + (v223 & ~v228);
      LODWORD(v228) = v207;
      int v230 = v228 >> 22;
      HIDWORD(v228) = v224;
      LODWORD(v228) = v224;
      unsigned int v231 = (v228 >> 23) + v230;
      unint64_t v232 = __PAIR64__(v226, __ROR4__(v218, 22));
      int v233 = v54 + 1548603684 + v230 + (v222 & ~v232);
      LODWORD(v232) = v226;
      unsigned int v234 = (v232 >> 23) + v227;
      unint64_t v235 = __PAIR64__(v214, __ROR4__(v218, 22));
      int v236 = v233 + (v231 & v235);
      LODWORD(v235) = v214;
      int v237 = v235 >> 22;
      HIDWORD(v235) = v236;
      LODWORD(v235) = v236;
      unsigned int v238 = (v235 >> 19) + v237;
      unint64_t v239 = __PAIR64__(v218, __ROR4__(v222, 22));
      int v240 = v13 + 1548603684 + v237 + (v231 & ~__ROR4__(v222, 22)) + (v238 & v239);
      LODWORD(v239) = v218;
      int v241 = v239 >> 22;
      HIDWORD(v239) = v240;
      LODWORD(v239) = v240;
      unsigned int v242 = (v239 >> 17) + v241;
      int v243 = v17 + 1548603684 + v241 + (v238 & ~__ROR4__(v231, 22));
      unint64_t v244 = __PAIR64__(v192, __ROR4__(v205, 22));
      int v245 = v229 + (v234 & v244);
      LODWORD(v244) = v192;
      int v246 = v244 >> 22;
      int v247 = v17 - 1894007588 + v246 + (v234 & ~__ROR4__(v223, 22));
      unint64_t v248 = __PAIR64__(v222, __ROR4__(v231, 22));
      int v249 = v243 + (v242 & v248);
      LODWORD(v248) = v222;
      int v250 = v248 >> 22;
      HIDWORD(v248) = v249;
      LODWORD(v248) = v249;
      unsigned int v251 = (v248 >> 25) + v250;
      HIDWORD(v248) = v245;
      LODWORD(v248) = v245;
      int v252 = (v248 >> 18) + v246;
      int v253 = v166 + 1548603684 + v250 + (v242 & ~__ROR4__(v238, 22)) + (v251 & __ROR4__(v238, 22));
      unint64_t v254 = __PAIR64__(v205, __ROR4__(v223, 22));
      unsigned int v255 = v247 + (v252 & v254);
      LODWORD(v254) = v205;
      int v256 = v254 >> 22;
      unint64_t v257 = __PAIR64__(v231, __ROR4__(v234, 22));
      int v258 = v30 - 1894007588 + v256 + (v252 & ~v257);
      LODWORD(v257) = v231;
      int v259 = v257 >> 22;
      HIDWORD(v257) = v253;
      LODWORD(v257) = v253;
      unsigned int v260 = (v257 >> 20) + v259;
      unint64_t v261 = __PAIR64__(v255, __ROR4__(v242, 22));
      int v262 = v28 + 1548603684 + v259 + (v251 & ~v261);
      LODWORD(v261) = v255;
      unsigned int v263 = (v261 >> 27) + v256;
      unint64_t v264 = __PAIR64__(v238, __ROR4__(v242, 22));
      int v265 = v262 + (v260 & v264);
      LODWORD(v264) = v238;
      int v266 = v264 >> 22;
      HIDWORD(v264) = v265;
      LODWORD(v264) = v265;
      unsigned int v267 = (v264 >> 24) + v266;
      unint64_t v268 = __PAIR64__(v242, __ROR4__(v251, 22));
      int v269 = v15 + 1548603684 + v266 + (v260 & ~__ROR4__(v251, 22)) + (v267 & v268);
      LODWORD(v268) = v242;
      int v270 = v268 >> 22;
      HIDWORD(v268) = v269;
      LODWORD(v268) = v269;
      unsigned int v271 = (v268 >> 23) + v270;
      int v272 = v569 + 1548603684 + v270 + (v267 & ~__ROR4__(v260, 22));
      unint64_t v273 = __PAIR64__(v223, __ROR4__(v234, 22));
      int v274 = v258 + (v263 & v273);
      LODWORD(v273) = v223;
      int v275 = v273 >> 22;
      unint64_t v276 = __PAIR64__(v251, __ROR4__(v260, 22));
      int v277 = v272 + (v271 & v276);
      LODWORD(v276) = v251;
      int v278 = v276 >> 22;
      HIDWORD(v276) = v277;
      LODWORD(v276) = v277;
      unsigned int v279 = (v276 >> 21) + v278;
      HIDWORD(v276) = v274;
      LODWORD(v276) = v274;
      unsigned int v280 = (v276 >> 26) + v275;
      unint64_t v281 = __PAIR64__(v234, __ROR4__(v252, 22));
      unsigned int v282 = v29 - 1894007588 + v275 + (v263 & ~__ROR4__(v252, 22)) + (v280 & v281);
      LODWORD(v281) = v234;
      int v283 = v281 >> 22;
      unint64_t v284 = __PAIR64__(v260, __ROR4__(v263, 22));
      int v285 = v15 - 1894007588 + v283 + (v280 & ~v284);
      LODWORD(v284) = v260;
      int v286 = v284 >> 22;
      HIDWORD(v284) = v29 + 1548603684 + v278 + (v271 & ~__ROR4__(v267, 22)) + (v279 & __ROR4__(v267, 22));
      LODWORD(v284) = HIDWORD(v284);
      unsigned int v287 = (v284 >> 25) + v286;
      unint64_t v288 = __PAIR64__(v282, __ROR4__(v271, 22));
      int v289 = v30 + 1548603684 + v286 + (v279 & ~v288);
      LODWORD(v288) = v282;
      unsigned int v290 = (v288 >> 24) + v283;
      unint64_t v291 = __PAIR64__(v267, __ROR4__(v271, 22));
      int v292 = v289 + (v287 & v291);
      LODWORD(v291) = v267;
      int v293 = v291 >> 22;
      HIDWORD(v291) = v292;
      LODWORD(v291) = v292;
      unsigned int v294 = (v291 >> 25) + v293;
      unint64_t v295 = __PAIR64__(v271, __ROR4__(v279, 22));
      int v296 = v18 + 1548603684 + v293 + (v287 & ~__ROR4__(v279, 22)) + (v294 & v295);
      LODWORD(v295) = v271;
      int v297 = v295 >> 22;
      HIDWORD(v295) = v296;
      LODWORD(v295) = v296;
      unsigned int v298 = (v295 >> 20) + v297;
      int v299 = v285 + (v290 & __ROR4__(v263, 22));
      unint64_t v300 = __PAIR64__(v279, __ROR4__(v287, 22));
      int v301 = v26 + 1548603684 + v297 + (v294 & ~__ROR4__(v287, 22)) + (v298 & v300);
      LODWORD(v300) = v279;
      int v302 = v300 >> 22;
      HIDWORD(v300) = v301;
      LODWORD(v300) = v301;
      int v303 = (v300 >> 25) + v302;
      HIDWORD(v300) = v252;
      LODWORD(v300) = v252;
      int v304 = v300 >> 22;
      unint64_t v305 = __PAIR64__(v299, __ROR4__(v294, 22));
      int v306 = v14 + 1548603684 + v302 + (v298 & ~v305);
      LODWORD(v305) = v299;
      int v307 = v566 - 1894007588 + v304;
      unsigned int v308 = (v305 >> 26) + v304;
      unint64_t v309 = __PAIR64__(v287, __ROR4__(v294, 22));
      int v310 = v306 + (v303 & v309);
      LODWORD(v309) = v287;
      int v311 = v309 >> 22;
      HIDWORD(v309) = v310;
      LODWORD(v309) = v310;
      unsigned int v312 = (v309 >> 26) + v311;
      unint64_t v313 = __PAIR64__(v294, __ROR4__(v298, 22));
      int v314 = v48 + 1548603684 + v311 + (v303 & ~__ROR4__(v298, 22)) + (v312 & v313);
      LODWORD(v313) = v294;
      int v315 = v313 >> 22;
      HIDWORD(v313) = v314;
      LODWORD(v313) = v314;
      int v316 = (v313 >> 17) + v315;
      unint64_t v317 = __PAIR64__(v263, __ROR4__(v280, 22));
      unsigned int v318 = v307 + (v290 & ~__ROR4__(v280, 22)) + (v308 & v317);
      LODWORD(v317) = v263;
      int v319 = v317 >> 22;
      int v320 = v564 - 1894007588 + v319 + (v308 & ~__ROR4__(v290, 22));
      unint64_t v321 = __PAIR64__(v298, __ROR4__(v303, 22));
      int v322 = v565 + 1548603684 + v315 + (v312 & ~__ROR4__(v303, 22)) + (v316 & v321);
      LODWORD(v321) = v298;
      int v323 = v321 >> 22;
      HIDWORD(v321) = v322;
      LODWORD(v321) = v322;
      unsigned int v324 = (v321 >> 19) + v323;
      unint64_t v325 = __PAIR64__(v318, __ROR4__(v312, 22));
      int v326 = v564 + 1548603684 + v323 + (v316 & ~__ROR4__(v312, 22)) + (v324 & v325);
      LODWORD(v325) = v318;
      unsigned int v327 = (v325 >> 27) + v319;
      HIDWORD(v325) = v303;
      LODWORD(v325) = v303;
      int v328 = v325 >> 22;
      HIDWORD(v325) = v326;
      LODWORD(v325) = v326;
      int v329 = (v325 >> 21) + v328;
      unint64_t v330 = __PAIR64__(v312, __ROR4__(v290, 22));
      int v331 = v320 + (v327 & v330);
      LODWORD(v330) = v312;
      int v332 = v330 >> 22;
      HIDWORD(v330) = v30 + 1836072691 + v328 + ((v329 | ~v324) ^ __ROR4__(v316, 22));
      LODWORD(v330) = HIDWORD(v330);
      unsigned int v333 = (v330 >> 23) + v332;
      unint64_t v334 = __PAIR64__(v280, __ROR4__(v324, 22));
      int v335 = v15 + 1836072691 + v332 + ((v333 | ~v329) ^ v334);
      LODWORD(v334) = v280;
      int v336 = v334 >> 22;
      HIDWORD(v334) = v316;
      LODWORD(v334) = v316;
      int v337 = v334 >> 22;
      HIDWORD(v334) = v335;
      LODWORD(v334) = v335;
      int v338 = (v334 >> 25) + v337;
      HIDWORD(v334) = v331;
      LODWORD(v334) = v331;
      int v339 = v14 - 1454113458 + v336;
      unsigned int v340 = (v334 >> 20) + v336;
      int v341 = v565 + 1836072691 + v337 + ((v338 | ~v333) ^ __ROR4__(v329, 22));
      unint64_t v342 = __PAIR64__(v324, __ROR4__(v308, 22));
      int v343 = v339 + (v340 ^ (v327 | ~v342));
      LODWORD(v342) = v324;
      int v344 = v342 >> 22;
      HIDWORD(v342) = v341;
      LODWORD(v342) = v341;
      unsigned int v345 = (v342 >> 17) + v344;
      unint64_t v346 = __PAIR64__(v290, __ROR4__(v333, 22));
      int v347 = v13 + 1836072691 + v344 + ((v345 | ~v338) ^ v346);
      LODWORD(v346) = v290;
      int v348 = v346 >> 22;
      HIDWORD(v346) = v329;
      LODWORD(v346) = v329;
      int v349 = v346 >> 22;
      HIDWORD(v346) = v347;
      LODWORD(v346) = v347;
      int v350 = (v346 >> 21) + v349;
      HIDWORD(v346) = v343;
      LODWORD(v346) = v343;
      int v351 = v563 - 1454113458 + v348;
      unsigned int v352 = (v346 >> 23) + v348;
      int v353 = v17 + 1836072691 + v349 + ((v350 | ~v345) ^ __ROR4__(v338, 22));
      unint64_t v354 = __PAIR64__(v333, __ROR4__(v327, 22));
      int v355 = v351 + (v352 ^ (v340 | ~v354));
      LODWORD(v354) = v333;
      int v356 = v354 >> 22;
      HIDWORD(v354) = v353;
      LODWORD(v354) = v353;
      unsigned int v357 = (v354 >> 24) + v356;
      unint64_t v358 = __PAIR64__(v308, __ROR4__(v345, 22));
      int v359 = v29 + 1836072691 + v356 + ((v357 | ~v350) ^ v358);
      LODWORD(v358) = v308;
      int v360 = v358 >> 22;
      HIDWORD(v358) = v338;
      LODWORD(v358) = v338;
      int v361 = v358 >> 22;
      HIDWORD(v358) = v359;
      LODWORD(v358) = v359;
      int v362 = (v358 >> 26) + v361;
      HIDWORD(v358) = v355;
      LODWORD(v358) = v355;
      int v363 = v15 - 1454113458 + v360;
      unsigned int v364 = (v358 >> 17) + v360;
      int v365 = v566 + 1836072691 + v361 + ((v362 | ~v357) ^ __ROR4__(v350, 22));
      unint64_t v366 = __PAIR64__(v345, __ROR4__(v340, 22));
      int v367 = v363 + (v364 ^ (v352 | ~v366));
      LODWORD(v366) = v345;
      int v368 = v366 >> 22;
      HIDWORD(v366) = v365;
      LODWORD(v366) = v365;
      unsigned int v369 = (v366 >> 26) + v368;
      unint64_t v370 = __PAIR64__(v327, __ROR4__(v357, 22));
      int v371 = v48 + 1836072691 + v368 + ((v369 | ~v362) ^ v370);
      LODWORD(v370) = v327;
      int v372 = v370 >> 22;
      HIDWORD(v370) = v350;
      LODWORD(v370) = v350;
      int v373 = v370 >> 22;
      HIDWORD(v370) = v371;
      LODWORD(v370) = v371;
      int v374 = (v370 >> 18) + v373;
      HIDWORD(v370) = v367;
      LODWORD(v370) = v367;
      int v375 = v48 - 1454113458 + v372;
      int v376 = (v370 >> 27) + v372;
      int v377 = v54 + 1836072691 + v373 + ((v374 | ~v369) ^ __ROR4__(v362, 22));
      unint64_t v378 = __PAIR64__(v357, __ROR4__(v352, 22));
      int v379 = v375 + (v376 ^ (v364 | ~v378));
      LODWORD(v378) = v357;
      int v380 = v378 >> 22;
      HIDWORD(v378) = v377;
      LODWORD(v378) = v377;
      unsigned int v381 = (v378 >> 20) + v380;
      unint64_t v382 = __PAIR64__(v340, __ROR4__(v369, 22));
      int v383 = v18 + 1836072691 + v380 + ((v381 | ~v374) ^ v382);
      LODWORD(v382) = v340;
      int v384 = v382 >> 22;
      HIDWORD(v382) = v362;
      LODWORD(v382) = v362;
      int v385 = v382 >> 22;
      HIDWORD(v382) = v383;
      LODWORD(v382) = v383;
      int v386 = (v382 >> 19) + v385;
      int v387 = v26 + 1836072691 + v385;
      HIDWORD(v382) = v379;
      LODWORD(v382) = v379;
      int v388 = v17 - 1454113458 + v384;
      int v389 = (v382 >> 21) + v384;
      unint64_t v390 = __PAIR64__(v369, __ROR4__(v364, 22));
      int v391 = v388 + (v389 ^ (v376 | ~v390));
      LODWORD(v390) = v369;
      int v392 = v390 >> 22;
      HIDWORD(v390) = v387 + ((v386 | ~v381) ^ __ROR4__(v374, 22));
      LODWORD(v390) = HIDWORD(v390);
      unsigned int v393 = (v390 >> 27) + v392;
      unint64_t v394 = __PAIR64__(v352, __ROR4__(v381, 22));
      int v395 = v564 + 1836072691 + v392 + ((v393 | ~v386) ^ v394);
      LODWORD(v394) = v352;
      int v396 = v394 >> 22;
      HIDWORD(v394) = v374;
      LODWORD(v394) = v374;
      int v397 = v394 >> 22;
      HIDWORD(v394) = v395;
      LODWORD(v394) = v395;
      unsigned int v398 = (v394 >> 18) + v397;
      HIDWORD(v394) = v391;
      LODWORD(v394) = v391;
      int v399 = v26 - 1454113458 + v396;
      int v400 = (v394 >> 26) + v396;
      int v401 = v569 + 1836072691 + v397 + ((v398 | ~v393) ^ __ROR4__(v386, 22));
      unint64_t v402 = __PAIR64__(v381, __ROR4__(v376, 22));
      int v403 = v399 + (v400 ^ (v389 | ~v402));
      LODWORD(v402) = v381;
      int v404 = v402 >> 22;
      HIDWORD(v402) = v401;
      LODWORD(v402) = v401;
      int v405 = (v402 >> 19) + v404;
      unint64_t v406 = __PAIR64__(v364, __ROR4__(v393, 22));
      int v407 = v563 + 1836072691 + v404 + ((v405 | ~v398) ^ v406);
      LODWORD(v406) = v364;
      int v408 = v406 >> 22;
      HIDWORD(v406) = v386;
      LODWORD(v406) = v386;
      int v409 = v406 >> 22;
      HIDWORD(v406) = v407;
      LODWORD(v406) = v407;
      int v410 = (v406 >> 19) + v409;
      HIDWORD(v406) = v403;
      LODWORD(v406) = v403;
      int v411 = v564 - 1454113458 + v408;
      int v412 = (v406 >> 24) + v408;
      int v413 = v14 + 1836072691 + v409 + ((v410 | ~v405) ^ __ROR4__(v398, 22));
      unint64_t v414 = __PAIR64__(v393, __ROR4__(v389, 22));
      int v415 = v411 + (v412 ^ (v400 | ~v414));
      LODWORD(v414) = v393;
      int v416 = v414 >> 22;
      HIDWORD(v414) = v413;
      LODWORD(v414) = v413;
      unsigned int v417 = (v414 >> 25) + v416;
      unint64_t v418 = __PAIR64__(v398, __ROR4__(v405, 22));
      int v419 = v28 + 1836072691 + v416 + ((v417 | ~v410) ^ v418);
      LODWORD(v418) = v398;
      int v420 = v418 >> 22;
      HIDWORD(v418) = v419;
      LODWORD(v418) = v419;
      int v421 = (v418 >> 27) + v420;
      HIDWORD(v418) = v410;
      LODWORD(v418) = v410;
      int v422 = v418 >> 22;
      HIDWORD(v418) = v376;
      LODWORD(v418) = v376;
      int v423 = v418 >> 22;
      HIDWORD(v418) = v415;
      LODWORD(v418) = v415;
      int v424 = v569 - 1454113458 + v423;
      int v425 = (v418 >> 19) + v423;
      HIDWORD(v418) = v405;
      LODWORD(v418) = v405;
      int v426 = v418 >> 22;
      HIDWORD(v418) = v18 + 2053994217 + v420 + (v422 & ~v421) + (v421 & v417);
      LODWORD(v418) = HIDWORD(v418);
      int v427 = v418 >> 17;
      unint64_t v428 = __PAIR64__(v417, __ROR4__(v400, 22));
      int v429 = v424 + (v425 ^ (v412 | ~v428));
      int v430 = v427 + v426;
      LODWORD(v428) = v417;
      int v431 = v428 >> 22;
      int v432 = v566 + 2053994217 + v426 + (v431 & ~v430) + (v430 & v421);
      HIDWORD(v428) = v389;
      LODWORD(v428) = v389;
      int v433 = v428 >> 22;
      HIDWORD(v428) = v429;
      LODWORD(v428) = v429;
      int v434 = (v428 >> 20) + v433;
      HIDWORD(v428) = v432;
      LODWORD(v428) = v432;
      int v435 = (v428 >> 27) + v422;
      int v436 = v14 + 2053994217 + v422;
      HIDWORD(v428) = v421;
      LODWORD(v428) = v421;
      int v437 = v428 >> 22;
      HIDWORD(v428) = v436 + (v437 & ~v435) + (v435 & v430);
      LODWORD(v428) = HIDWORD(v428);
      int v438 = (v428 >> 24) + v431;
      HIDWORD(v428) = v430;
      LODWORD(v428) = v430;
      int v439 = v428 >> 22;
      HIDWORD(v428) = v565 + 2053994217 + v431 + (v439 & ~v438) + (v438 & v435);
      LODWORD(v428) = HIDWORD(v428);
      int v440 = (v428 >> 21) + v437;
      HIDWORD(v428) = v435;
      LODWORD(v428) = v435;
      int v441 = v428 >> 22;
      HIDWORD(v428) = v400;
      LODWORD(v428) = v400;
      int v442 = v428 >> 22;
      HIDWORD(v428) = v29 - 1454113458 + v433 + (v434 ^ (v425 | ~__ROR4__(v412, 22)));
      LODWORD(v428) = HIDWORD(v428);
      int v443 = v565 - 1454113458 + v442;
      int v444 = (v428 >> 27) + v442;
      HIDWORD(v428) = v13 + 2053994217 + v437 + (v441 & ~v440) + (v440 & v438);
      LODWORD(v428) = HIDWORD(v428);
      unsigned int v445 = (v428 >> 18) + v439;
      HIDWORD(v428) = v438;
      LODWORD(v428) = v438;
      int v446 = v428 >> 22;
      int v447 = v54 + 2053994217 + v439 + (v446 & ~v445);
      int v448 = v443 + (v444 ^ (v434 | ~__ROR4__(v425, 22)));
      HIDWORD(v428) = v447 + (v445 & v440);
      LODWORD(v428) = HIDWORD(v428);
      int v449 = (v428 >> 18) + v441;
      int v450 = v30 + 2053994217 + v441;
      HIDWORD(v428) = v412;
      LODWORD(v428) = v412;
      int v451 = v428 >> 22;
      HIDWORD(v428) = v440;
      LODWORD(v428) = v440;
      int v452 = v428 >> 22;
      int v453 = v450 + (v452 & ~v449);
      HIDWORD(v428) = v448;
      LODWORD(v428) = v448;
      int v454 = v13 - 1454113458 + v451;
      int v455 = (v428 >> 20) + v451;
      HIDWORD(v428) = v453 + (v449 & v445);
      LODWORD(v428) = HIDWORD(v428);
      int v456 = v428 >> 26;
      unint64_t v457 = __PAIR64__(v445, __ROR4__(v434, 22));
      int v458 = v454 + (v455 ^ (v444 | ~v457));
      int v459 = v456 + v446;
      int v460 = v563 + 2053994217 + v446;
      LODWORD(v457) = v445;
      int v461 = v457 >> 22;
      HIDWORD(v457) = v425;
      LODWORD(v457) = v425;
      int v462 = v457 >> 22;
      HIDWORD(v457) = v458;
      LODWORD(v457) = v458;
      unsigned int v463 = (v457 >> 19) + v462;
      HIDWORD(v457) = v460 + (v461 & ~v459) + (v459 & v449);
      LODWORD(v457) = HIDWORD(v457);
      int v464 = (v457 >> 18) + v452;
      HIDWORD(v457) = v449;
      LODWORD(v457) = v449;
      int v465 = v457 >> 22;
      HIDWORD(v457) = v15 + 2053994217 + v452 + (v465 & ~v464) + (v464 & v459);
      LODWORD(v457) = HIDWORD(v457);
      int v466 = (v457 >> 26) + v461;
      HIDWORD(v457) = v459;
      LODWORD(v457) = v459;
      int v467 = v457 >> 22;
      HIDWORD(v457) = v26 + 2053994217 + v461 + (v467 & ~v466) + (v466 & v464);
      LODWORD(v457) = HIDWORD(v457);
      int v468 = (v457 >> 23) + v465;
      HIDWORD(v457) = v464;
      LODWORD(v457) = v464;
      int v469 = v457 >> 22;
      HIDWORD(v457) = v434;
      LODWORD(v457) = v434;
      int v470 = v457 >> 22;
      HIDWORD(v457) = v18 - 1454113458 + v462 + (v463 ^ (v455 | ~__ROR4__(v444, 22)));
      LODWORD(v457) = HIDWORD(v457);
      int v471 = v54 - 1454113458 + v470;
      int v472 = (v457 >> 18) + v470;
      HIDWORD(v457) = v564 + 2053994217 + v465 + (v469 & ~v468) + (v468 & v466);
      LODWORD(v457) = HIDWORD(v457);
      unsigned int v473 = (v457 >> 20) + v467;
      HIDWORD(v457) = v466;
      LODWORD(v457) = v466;
      int v474 = v457 >> 22;
      HIDWORD(v457) = v28 + 2053994217 + v467 + (v474 & ~v473) + (v473 & v468);
      LODWORD(v457) = HIDWORD(v457);
      int v475 = (v457 >> 23) + v469;
      HIDWORD(v457) = v444;
      LODWORD(v457) = v444;
      int v476 = v457 >> 22;
      HIDWORD(v457) = v468;
      LODWORD(v457) = v468;
      int v477 = v457 >> 22;
      HIDWORD(v457) = v471 + (v472 ^ (v463 | ~__ROR4__(v455, 22)));
      LODWORD(v457) = HIDWORD(v457);
      int v478 = v566 - 1454113458 + v476;
      int v479 = (v457 >> 21) + v476;
      HIDWORD(v457) = v48 + 2053994217 + v469 + (v477 & ~v475) + (v475 & v473);
      LODWORD(v457) = HIDWORD(v457);
      int v480 = v457 >> 20;
      unint64_t v481 = __PAIR64__(v473, __ROR4__(v463, 22));
      int v482 = v478 + (v479 ^ (v472 | ~v481));
      int v483 = v480 + v474;
      LODWORD(v481) = v473;
      int v484 = v481 >> 22;
      HIDWORD(v481) = v455;
      LODWORD(v481) = v455;
      int v485 = v481 >> 22;
      HIDWORD(v481) = v482;
      LODWORD(v481) = v482;
      int v486 = (v481 >> 24) + v485;
      HIDWORD(v481) = v17 + 2053994217 + v474 + (v484 & ~v483) + (v483 & v475);
      LODWORD(v481) = HIDWORD(v481);
      unsigned int v487 = (v481 >> 27) + v477;
      HIDWORD(v481) = v475;
      LODWORD(v481) = v475;
      int v488 = v481 >> 22;
      HIDWORD(v481) = v569 + 2053994217 + v477 + (v488 & ~v487) + (v487 & v483);
      LODWORD(v481) = HIDWORD(v481);
      unsigned int v489 = (v481 >> 17) + v484;
      HIDWORD(v481) = v483;
      LODWORD(v481) = v483;
      int v490 = v481 >> 22;
      HIDWORD(v481) = v29 + 2053994217 + v484 + (v490 & ~v489) + (v489 & v487);
      LODWORD(v481) = HIDWORD(v481);
      unsigned int v491 = (v481 >> 24) + v488;
      LODWORD(v481) = v488 + v26 + (v489 ^ __ROR4__(v487, 22) ^ v491);
      HIDWORD(v481) = v481;
      unsigned int v492 = (v481 >> 24) + v490;
      unint64_t v493 = __PAIR64__(v487, __ROR4__(v489, 22));
      int v494 = v491 ^ v493 ^ v492;
      LODWORD(v493) = v487;
      int v495 = v493 >> 22;
      HIDWORD(v493) = v490 + v30 + v494;
      LODWORD(v493) = HIDWORD(v493);
      unsigned int v496 = (v493 >> 27) + v495;
      unint64_t v497 = __PAIR64__(v489, __ROR4__(v491, 22));
      int v498 = v495 + v569 + (v492 ^ v497 ^ v496);
      LODWORD(v497) = v489;
      int v499 = v497 >> 22;
      HIDWORD(v497) = v498;
      LODWORD(v497) = v498;
      unsigned int v500 = (v497 >> 20) + v499;
      unint64_t v501 = __PAIR64__(v491, __ROR4__(v492, 22));
      int v502 = v496 ^ v501 ^ v500;
      LODWORD(v501) = v491;
      int v503 = v501 >> 22;
      HIDWORD(v501) = v499 + v14 + v502;
      LODWORD(v501) = HIDWORD(v501);
      unsigned int v504 = (v501 >> 23) + v503;
      unint64_t v505 = __PAIR64__(v492, __ROR4__(v496, 22));
      int v506 = v503 + v565 + (v500 ^ v505 ^ v504);
      LODWORD(v505) = v492;
      int v507 = v505 >> 22;
      HIDWORD(v505) = v506;
      LODWORD(v505) = v506;
      unsigned int v508 = (v505 >> 20) + v507;
      unint64_t v509 = __PAIR64__(v496, __ROR4__(v500, 22));
      int v510 = v504 ^ v509 ^ v508;
      LODWORD(v509) = v496;
      int v511 = v509 >> 22;
      HIDWORD(v509) = v507 + v15 + v510;
      LODWORD(v509) = HIDWORD(v509);
      unsigned int v512 = (v509 >> 27) + v511;
      unint64_t v513 = __PAIR64__(v500, __ROR4__(v504, 22));
      int v514 = v511 + v18 + (v508 ^ v513 ^ v512);
      LODWORD(v513) = v500;
      int v515 = v513 >> 22;
      HIDWORD(v513) = v514;
      LODWORD(v513) = v514;
      unsigned int v516 = (v513 >> 18) + v515;
      unint64_t v517 = __PAIR64__(v504, __ROR4__(v508, 22));
      int v518 = v512 ^ v517 ^ v516;
      LODWORD(v517) = v504;
      int v519 = v517 >> 22;
      HIDWORD(v517) = v515 + v17 + v518;
      LODWORD(v517) = HIDWORD(v517);
      unsigned int v520 = (v517 >> 26) + v519;
      unint64_t v521 = __PAIR64__(v508, __ROR4__(v512, 22));
      int v522 = v519 + v566 + (v516 ^ v521 ^ v520);
      LODWORD(v521) = v508;
      int v523 = v521 >> 22;
      HIDWORD(v521) = v522;
      LODWORD(v521) = v522;
      unsigned int v524 = (v521 >> 24) + v523;
      unint64_t v525 = __PAIR64__(v512, __ROR4__(v472, 22));
      int v526 = v486 ^ (v479 | ~v525);
      LODWORD(v525) = v512;
      int v527 = v525 >> 22;
      HIDWORD(v525) = v523 + v564 + (v520 ^ __ROR4__(v516, 22) ^ v524);
      LODWORD(v525) = HIDWORD(v525);
      int v528 = v30 - 1454113458 + v485 + v526;
      unsigned int v529 = (v525 >> 19) + v527;
      unint64_t v530 = __PAIR64__(v516, __ROR4__(v520, 22));
      int v531 = v524 ^ v530 ^ v529;
      LODWORD(v530) = v516;
      int v532 = v530 >> 22;
      HIDWORD(v530) = v527 + v28 + v531;
      LODWORD(v530) = HIDWORD(v530);
      unsigned int v533 = (v530 >> 26) + v532;
      unint64_t v534 = __PAIR64__(v520, __ROR4__(v524, 22));
      int v535 = v532 + v29 + (v529 ^ v534 ^ v533);
      LODWORD(v534) = v520;
      int v536 = v534 >> 22;
      HIDWORD(v534) = v535;
      LODWORD(v534) = v535;
      int v537 = (v534 >> 27) + v536;
      unint64_t v538 = __PAIR64__(v524, __ROR4__(v529, 22));
      int v539 = v533 ^ v538 ^ v537;
      LODWORD(v538) = v524;
      int v540 = v538 >> 22;
      HIDWORD(v538) = v536 + v563 + v539;
      LODWORD(v538) = HIDWORD(v538);
      int v541 = (v538 >> 17) + v540;
      unint64_t v542 = __PAIR64__(v529, __ROR4__(v533, 22));
      int v543 = v540 + v570 + (v537 ^ v542 ^ v541);
      LODWORD(v542) = v529;
      int v544 = v542 >> 22;
      HIDWORD(v542) = v543;
      LODWORD(v542) = v543;
      unsigned int v545 = (v542 >> 19) + v544;
      unint64_t v546 = __PAIR64__(v463, __ROR4__(v537, 22));
      int v547 = v541 ^ v546 ^ v545;
      LODWORD(v546) = v463;
      int v548 = v546 >> 22;
      int v549 = v544 + v48 + v547;
      HIDWORD(v546) = v528;
      LODWORD(v546) = v528;
      int v550 = v28 - 1454113458 + v548;
      int v551 = (v546 >> 27) + v548;
      unint64_t v553 = __PAIR64__(v533, __ROR4__(v479, 22));
      int v552 = v486 | ~v553;
      LODWORD(v553) = v533;
      int v554 = v553 >> 22;
      HIDWORD(v553) = v549;
      LODWORD(v553) = v549;
      int v555 = v550 + (v551 ^ v552);
      uint64_t result = (_DWORD *)((v553 >> 21) + v554);
      unint64_t v556 = __PAIR64__(v545, __ROR4__(v541, 22));
      int v557 = v554 + v54 + (v545 ^ v556 ^ result);
      LODWORD(v556) = v545;
      int v558 = v551 + v4 + (v556 >> 22);
      HIDWORD(v556) = v541;
      LODWORD(v556) = v541;
      int v559 = v571 + (v556 >> 22);
      HIDWORD(v556) = v486;
      LODWORD(v556) = v486;
      int v4 = (v556 >> 22) + v559;
      HIDWORD(v556) = v537;
      LODWORD(v556) = v537;
      int v560 = v556 >> 22;
      HIDWORD(v556) = v479;
      LODWORD(v556) = v479;
      int v6 = (v556 >> 22) + v5 + v560;
      HIDWORD(v556) = v472;
      LODWORD(v556) = v472;
      int v561 = v556 >> 22;
      HIDWORD(v556) = v557;
      LODWORD(v556) = v557;
      int v5 = v561 + v572 + v560 + (v556 >> 21);
      HIDWORD(v556) = v555;
      LODWORD(v556) = v555;
      int v7 = v561 + v573 + result + (v556 >> 26);
      v562[2] = v6;
      v562[3] = v5;
      v562[4] = v7;
      _DWORD *v562 = v558;
      v562[1] = v4;
      a3 = v574 + 16;
      int v3 = v558;
      a2 = v568 - 1;
    }
    while (v568 != 1);
  }
  return result;
}

uint64_t ccder_blob_encode_eckey_internal(uint64_t *a1, uint64_t a2, uint64_t a3, const void *a4, unint64_t a5, const void *a6)
{
  if (!a2) {
    return 0;
  }
  uint64_t v10 = a1[1];
  if (a5 && a6)
  {
    char v13 = 0;
    if (!ccder_blob_encode_body(a1, a5, a6)
      || !ccder_blob_encode_body(a1, 1uLL, &v13)
      || !ccder_blob_encode_tl(a1, 3uLL, v10 - a1[1]))
    {
      return 0;
    }
    uint64_t result = ccder_blob_encode_tl(a1, 0xA000000000000001, v10 - a1[1]);
    if (!result) {
      return result;
    }
  }
  if (!a4
    || (uint64_t v12 = a1[1], result = ccder_blob_encode_oid(a1, a4), result)
    && (uint64_t result = ccder_blob_encode_tl(a1, 0xA000000000000000, v12 - a1[1]), result))
  {
    uint64_t result = ccder_blob_encode_raw_octet_string((uint64_t)a1, a2, a3);
    if (result)
    {
      uint64_t result = ccder_blob_encode_uint64(a1, 1uLL);
      if (result) {
        return ccder_blob_encode_tl(a1, 0x2000000000000010uLL, v10 - a1[1]);
      }
    }
  }
  return result;
}

uint64_t ccder_blob_encode_eckey(uint64_t *a1, uint64_t a2, uint64_t a3, const void *a4, unint64_t a5, const void *a6)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v12 = ccder_blob_encode_eckey_internal(a1, a2, a3, a4, a5, a6);
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v12;
}

uint64_t ccsrp_digest_ccn_ws(uint64_t a1, uint64_t *a2, unint64_t *a3, uint64_t a4, int a5)
{
  uint64_t v10 = ccdh_gp_n(a2[1]);
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10);
  unint64_t v13 = ccdh_gp_n(a2[1]);
  uint64_t v14 = ccdh_gp_n(a2[1]);
  int v15 = ccn_write_uint_padded_ct_internal(v13, a3, 8 * v14, v12);
  if (a5) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v17 = *a2;
  uint64_t v18 = ccdh_gp_n(a2[1]);
  uint64_t result = ccdigest_internal(v17, 8 * v18 - v16, &v12[v16], a4);
  *(void *)(a1 + 16) = v11;
  return result;
}

unint64_t *ccsrp_digest_update_ccn_ws(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4, int a5)
{
  uint64_t v10 = ccdh_gp_n(*(void *)(a2 + 8));
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10);
  unint64_t v13 = ccdh_gp_n(*(void *)(a2 + 8));
  uint64_t v14 = ccdh_gp_n(*(void *)(a2 + 8));
  int v15 = ccn_write_uint_padded_ct_internal(v13, a4, 8 * v14, v12);
  if (a5) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v17 = *(unint64_t **)a2;
  uint64_t v18 = ccdh_gp_n(*(void *)(a2 + 8));
  uint64_t result = ccdigest_update_internal(v17, a3, 8 * v18 - v16, &v12[v16]);
  *(void *)(a1 + 16) = v11;
  return result;
}

uint64_t ccsrp_digest_ccn_ccn_ws(uint64_t a1, uint64_t *a2, uint64_t a3, unint64_t *a4, unint64_t *a5, rsize_t a6, int a7)
{
  uint64_t v20 = (uint64_t)&v20;
  uint64_t v22 = *MEMORY[0x263EF8C08];
  uint64_t v14 = *a2;
  MEMORY[0x270FA53B0](a1, a2, a3, a4);
  uint64_t v16 = &__s[-v15 - 8];
  ccdigest_init_internal(v14, &__s[-v15 - 8]);
  uint64_t v17 = *(void *)(a1 + 16);
  if (a4) {
    ccsrp_digest_update_ccn_ws(a1, (uint64_t)a2, v16, a4, a7);
  }
  ccsrp_digest_update_ccn_ws(a1, (uint64_t)a2, v16, a5, a7);
  (*(void (**)(uint64_t, void *, unsigned char *))(v14 + 56))(v14, v16, __s);
  if (a6 - 1 >= *(void *)v14) {
    a6 = *(void *)v14;
  }
  uint64_t v18 = ccdh_gp_n(a2[1]);
  ccn_read_uint_internal(v18, a3, a6, __s);
  cc_clear(*(void *)v14, __s);
  uint64_t result = cc_clear(*(void *)(v14 + 8) + *(void *)(v14 + 16) + 12, v16);
  *(void *)(a1 + 16) = v17;
  return result;
}

uint64_t ccec_generate_key_deterministic_ws(uint64_t a1, unint64_t *a2, unint64_t a3, char *__src, uint64_t (**a5)(void, uint64_t, unint64_t *), int a6, unint64_t **a7)
{
  *a7 = a2;
  if ((~a6 & 0x19) != 0)
  {
    if (a6)
    {
      uint64_t result = ccec_generate_scalar_fips_extrabits_ws(a1, a2, a3, (uint64_t)__src, (char *)&a7[3 * *a2 + 2]);
      if (result) {
        return result;
      }
    }
    else
    {
      if ((a6 & 4) == 0) {
        return 4294967275;
      }
      uint64_t result = ccec_generate_scalar_legacy_ws(a1, (uint64_t *)a2, a3, __src, &a7[3 * *a2 + 2]);
      if (result) {
        return result;
      }
    }
LABEL_12:
    uint64_t result = ccec_make_pub_from_priv_ws(a1, a2, a5, (uint64_t)&a7[3 * **a7 + 2], 0, a7);
    if (!result)
    {
      if ((~a6 & 9) == 0) {
        ccec_compact_transform_key_ws(a1, (uint64_t **)a7);
      }
      if (ccec_pairwise_consistency_check_ws(a1, a7, (uint64_t (**)(void, unint64_t, void *))a5))return 4294967278; {
      else
      }
        return 0;
    }
    return result;
  }
  memset(v17, 0, sizeof(v17));
  unint64_t v14 = ((unint64_t)(cczp_bitlen((uint64_t)a2) + 62) >> 3) & 0x1FFFFFFFFFFFFFF8;
  unint64_t v15 = a3 - v14;
  if (v15 < 10 * (((unint64_t)(cczp_bitlen((uint64_t)&a2[5 * *a2 + 4]) + 63) >> 3) & 0x1FFFFFFFFFFFFFF8)) {
    return 4294967286;
  }
  uint64_t result = ccrng_sequence_non_repeat_init((uint64_t (**)(uint64_t, unint64_t, uint64_t))v17, (uint64_t (*)(uint64_t, unint64_t, uint64_t))v15, (uint64_t (*)(uint64_t, unint64_t, uint64_t))&__src[v14]);
  if (!result)
  {
    uint64_t result = ccec_generate_scalar_fips_retry_ws(a1, a2, v17, &a7[3 * **a7 + 2]);
    if (!result) {
      goto LABEL_12;
    }
  }
  return result;
}

uint64_t ccec_generate_key_deterministic(unint64_t *a1, unint64_t a2, char *a3, uint64_t (**a4)(void, uint64_t, unint64_t *), int a5, unint64_t **a6)
{
  BOOL v18 = timingsafe_enable_if_supported();
  uint64_t v12 = cc_malloc_clear(392 * *a1);
  uint64_t v13 = 49 * *a1;
  v16[0] = v12;
  v16[1] = v13;
  _OWORD v16[2] = 0;
  v16[3] = cc_ws_alloc;
  uint64_t v17 = cc_ws_free;
  if (v12)
  {
    key_deterministic_uint64_t ws = ccec_generate_key_deterministic_ws((uint64_t)v16, a1, a2, a3, a4, a5, a6);
    v17((uint64_t)v16);
  }
  else
  {
    key_deterministic_uint64_t ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return key_deterministic_ws;
}

uint64_t ccmode_ofb_crypt(void *a1, uint64_t a2, char *a3, unsigned char *a4)
{
  uint64_t v5 = a1[1];
  if (a2)
  {
    uint64_t v8 = a2;
    uint64_t v9 = *a1;
    uint64_t v10 = a1 + 2;
    unint64_t v11 = (unint64_t)a1 + ((*(void *)(*a1 + 8) + 7) & 0xFFFFFFFFFFFFFFF8) + 16;
    do
    {
      if (v5 == *(void *)(v9 + 8))
      {
        (*(void (**)(unint64_t, uint64_t, void *, void *))(v9 + 24))(v11, 1, a1 + 2, a1 + 2);
        uint64_t v5 = 0;
      }
      char v12 = *a3++;
      uint64_t v13 = v5 + 1;
      *a4++ = *((unsigned char *)v10 + v5++) ^ v12;
      --v8;
    }
    while (v8);
  }
  else
  {
    uint64_t v13 = a1[1];
  }
  a1[1] = v13;
  return 0;
}

uint64_t ccder_blob_encode_implicit_uint64(uint64_t *a1, unint64_t a2, unint64_t a3)
{
  v4[1] = *MEMORY[0x263EF8C08];
  v4[0] = a3;
  return ccder_blob_encode_implicit_integer(a1, a2, 1uLL, v4);
}

uint64_t ccn_sqr_ws(uint64_t a1, unint64_t a2, void *a3, unint64_t *a4)
{
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 2 * a2);
  uint64_t result = ccn_mul1(a2 - 1, (void *)(v9 + 8), a4 + 1, *a4);
  *(void *)(v9 + 8 * a2) = result;
  long long v11 = *a4;
  *a3 = *a4 * *a4;
  unint64_t v12 = *(void *)(v9 + 8);
  if (__CFADD__((unsigned __int128)(v11 * v11) >> 64, 2 * v12)) {
    uint64_t v13 = (v12 >> 63) + 1;
  }
  else {
    uint64_t v13 = v12 >> 63;
  }
  a3[1] = (__PAIR128__(2, v11) * v11) >> 64;
  uint64_t v14 = a2 - 2;
  if (a2 >= 2)
  {
    uint64_t v15 = 0;
    uint64_t v16 = v9 + 8 * a2 + 8;
    uint64_t v17 = (unint64_t *)(v9 + 24);
    BOOL v18 = a3 + 3;
    do
    {
      uint64_t result = ccn_addmul1(v14, v17, &a4[v15 + 2], a4[v15 + 1]);
      *(void *)(v16 + v15 * 8) = result;
      unint64_t v19 = a4[v15 + 1];
      uint64_t v20 = (v19 * (unsigned __int128)v19) >> 64;
      unint64_t v21 = v19 * v19;
      BOOL v22 = __CFADD__(v21, v13);
      unint64_t v23 = v21 + v13;
      if (v22) {
        ++v20;
      }
      unint64_t v24 = *(v17 - 1);
      *(v18 - 1) = v23 + 2 * v24;
      unint64_t v25 = *v17;
      v17 += 2;
      unint64_t v26 = v25 >> 63;
      BOOL v22 = __CFADD__(v20, 2 * v25);
      uint64_t v27 = v20 + 2 * v25;
      if (v22) {
        uint64_t v28 = v26 + 1;
      }
      else {
        uint64_t v28 = v26;
      }
      BOOL v22 = __CFADD__(__CFADD__(v23, 2 * v24), v27) | __CFADD__(v24 >> 63, __CFADD__(v23, 2 * v24) + v27);
      unint64_t v29 = (v24 >> 63) + __CFADD__(v23, 2 * v24) + v27;
      if (v22) {
        uint64_t v13 = v28 + 1;
      }
      else {
        uint64_t v13 = v28;
      }
      *BOOL v18 = v29;
      v18 += 2;
      ++v15;
      --v14;
    }
    while (v14 != -1);
  }
  *(void *)(a1 + 16) = v8;
  return result;
}

unint64_t cc_cmp_safe_internal(uint64_t a1, char *a2, char *a3)
{
  if (!a1) {
    return 1;
  }
  unsigned __int8 v3 = 0;
  do
  {
    char v5 = *a2++;
    char v4 = v5;
    char v6 = *a3++;
    v3 |= v6 ^ v4;
    --a1;
  }
  while (a1);
  return ((unint64_t)v3 + 0xFFFFFFFF) >> 32;
}

unint64_t cc_cmp_safe(uint64_t a1, char *a2, char *a3)
{
  BOOL v12 = timingsafe_enable_if_supported();
  if (a1)
  {
    unsigned __int8 v6 = 0;
    do
    {
      char v8 = *a2++;
      char v7 = v8;
      char v9 = *a3++;
      v6 |= v9 ^ v7;
      --a1;
    }
    while (a1);
    unint64_t v10 = ((unint64_t)v6 + 0xFFFFFFFF) >> 32;
  }
  else
  {
    unint64_t v10 = 1;
  }
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

BOOL ccz_is_zero(uint64_t a1)
{
  BOOL v5 = timingsafe_enable_if_supported();
  unint64_t v2 = ccz_n(a1);
  BOOL v3 = ccn_n(v2, *(void *)(a1 + 24)) == 0;
  cc_disable_dit_with_sb((unsigned int *)&v5);
  return v3;
}

uint64_t cccast_ecb_decrypt(uint64_t a1, uint64_t a2, unsigned int *a3, _DWORD *a4)
{
  uint64_t v14 = *MEMORY[0x263EF8C08];
  if (a2)
  {
    uint64_t v6 = a2;
    do
    {
      --v6;
      unsigned int v8 = *a3;
      unsigned int v9 = a3[1];
      a3 += 2;
      unsigned int v12 = bswap32(v8);
      unsigned int v13 = bswap32(v9);
      CC_CAST_decrypt((int *)&v12, a1);
      unsigned int v10 = bswap32(v13);
      *a4 = bswap32(v12);
      a4[1] = v10;
      a4 += 2;
    }
    while (v6);
  }
  return 0;
}

unint64_t CCHE_CIPHERTEXT_PLAINTEXT_ADD_WORKSPACE_N(unsigned int a1)
{
  return ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3) + a1;
}

uint64_t cche_ciphertext_plaintext_add_ws(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  v107[1] = *MEMORY[0x263EF8C08];
  int v8 = cche_param_ctx_he_scheme(*(unsigned int **)a3);
  if (v8 == 2)
  {
    int v55 = *(_DWORD *)(a3 + 8);
    if (v55 == cche_ciphertext_fresh_npolys() && *(_DWORD *)(a2 + 8) == v55)
    {
      int v56 = (int **)(a2 + 24);
      if (ccpolyzp_po2cyc_ctx_eq(*(void *)(a3 + 24), *(_DWORD **)(a2 + 24)))
      {
        unsigned int v57 = cche_param_ctx_polynomial_degree(*(void *)a3);
        int v58 = *v56;
        int v59 = **v56;
        int v60 = (*v56)[1];
        int v62 = **(_DWORD **)(a3 + 24);
        int v61 = *(_DWORD *)(*(void *)(a3 + 24) + 4);
        int v63 = (void *)*a4;
        int v64 = *(_DWORD *)(*a4 + 4) - 1;
        uint64_t v102 = a2;
        uint64_t v98 = (v62 * v61);
        uint64_t v100 = (v60 * v59);
        if (*(_DWORD *)(*a4 + 4) != 1)
        {
          do
          {
            int v63 = (void *)v63[14];
            --v64;
          }
          while (v64);
        }
        if (v61)
        {
          unsigned int v65 = 0;
          unsigned int v66 = 0;
          unsigned int v67 = 0;
          unsigned int v68 = v60 - 1;
          int v69 = a4 + 1;
          uint64_t v70 = a2 + 32;
          do
          {
            int v71 = v58;
            if (v68 > v67)
            {
              unsigned int v72 = v68;
              int v71 = v58;
              do
              {
                int v71 = (int *)*((void *)v71 + 14);
                --v72;
              }
              while (v72 > v67);
            }
            int v73 = v69;
            unsigned int v74 = v65;
            unsigned int v75 = v66;
            uint64_t v76 = v57;
            if (v57)
            {
              do
              {
                unint64_t v77 = *v73++;
                unint64_t v78 = *(void *)(a3 + 16);
                unint64_t v79 = (v78 * (unsigned __int128)v77) >> 64;
                uint64_t v80 = v78 * v77;
                unint64_t v81 = v63[4];
                uint64_t v82 = ((unint64_t)v80 * (unsigned __int128)v81) >> 64;
                uint64_t v83 = (v79 * (unsigned __int128)v81) >> 64;
                uint64_t v84 = v79 * v81;
                BOOL v42 = __CFADD__(v82, v84);
                uint64_t v85 = v82 + v84;
                uint64_t v86 = v42;
                uint64_t v87 = v86
                    + __CFADD__(v80 * v63[5], v85)
                    + v83
                    + v63[5] * v79
                    + (((unint64_t)v80 * (unsigned __int128)(unint64_t)v63[5]) >> 64);
                uint64_t v88 = v63[2];
                uint64_t v89 = v80 - v87 * v88;
                uint64_t v90 = v89 - v88;
                if (v90 >= 0) {
                  uint64_t v89 = v90;
                }
                uint64_t v91 = *((void *)v71 + 2);
                uint64_t v92 = v89 + *(void *)(a3 + 32 + 8 * v74);
                if (v92 - v91 >= 0) {
                  v92 -= v91;
                }
                *(void *)(v70 + 8 * v75++) = v92;
                ++v74;
                --v76;
              }
              while (v76);
            }
            ++v67;
            v66 += v59;
            v65 += v62;
          }
          while (v67 != v61);
        }
        uint64_t v93 = sizeof_struct_ccpolyzp_po2cyc();
        memmove(&(&v56[v100])[(unint64_t)(v93 + 7) >> 3], (const void *)(a3 + 24 + 8 * (v98 + ((unint64_t)(v93 + 7) >> 3))), (v93+ 7+ 8* (*(_DWORD *)(*(void *)(a3 + 24 + 8 * (v98 + ((unint64_t)(v93 + 7) >> 3))) + 4)* **(_DWORD **)(a3 + 24 + 8 * (v98 + ((unint64_t)(v93 + 7) >> 3))))) & 0xFFFFFFFFFFFFFFF8);
        uint64_t result = 0;
        *(void *)(v102 + 16) = *(void *)(a3 + 16);
        return result;
      }
    }
    return 4294967289;
  }
  if (v8 != 1) {
    return 4294967289;
  }
  int v9 = *(_DWORD *)(a3 + 8);
  if (v9 != cche_ciphertext_fresh_npolys()) {
    return 4294967289;
  }
  if (*(_DWORD *)(a2 + 8) != v9) {
    return 4294967289;
  }
  int v94 = (_DWORD **)(a3 + 24);
  unint64_t v103 = (void *)(a2 + 24);
  if (!ccpolyzp_po2cyc_ctx_eq(*(void *)(a3 + 24), *(_DWORD **)(a2 + 24)) || *(void *)(a3 + 16) != 1) {
    return 4294967289;
  }
  uint64_t v101 = a2;
  uint64_t v95 = *(void *)(a1 + 16);
  unsigned int v10 = *(unsigned int **)a3;
  unsigned int v11 = cche_param_ctx_polynomial_degree(*(void *)a3);
  unsigned int v12 = *(_DWORD *)(*(void *)(a3 + 24) + 4);
  uint64_t v13 = cche_param_ctx_cipher_plain_ctx_const((uint64_t)v10, v12);
  uint64_t v14 = (_DWORD *)*v103;
  uint64_t v15 = cche_param_ctx_plaintext_ctx((uint64_t)v10);
  uint64_t v16 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 24);
  uint64_t v17 = sizeof_struct_ccpolyzp_po2cyc();
  uint64_t v18 = v11;
  uint64_t v97 = v13;
  unsigned int v99 = a4;
  int v96 = (unint64_t *)v16(a1, ((unint64_t)(v17 + 7) >> 3) + v11);
  *int v96 = *a4;
  ccn_set(1, &__dst, (void *)(v13 + 24));
  ccn_zero(1, v107);
  if (v11)
  {
    unint64_t v19 = (unint64_t *)(v15 + 4);
    uint64_t v20 = (unint64_t *)(v13 + 16);
    unint64_t v21 = v99 + 1;
    BOOL v22 = (char *)(v96 + 1);
    uint64_t v23 = v18;
    while (1)
    {
      ccn_mul_ws(a1, 1uLL, (char *)v105, v20, v21);
      if (ccn_add_ws(a1, 2, v104, v105, &__dst)) {
        break;
      }
      ccpolyzp_po2cyc_scalar_divmod_ws(a1, v22, v104, v19);
      v22 += 8;
      ++v21;
      if (!--v23) {
        goto LABEL_11;
      }
    }
    uint64_t result = 0xFFFFFFFFLL;
  }
  else
  {
LABEL_11:
    if (v12)
    {
      unsigned int v24 = 0;
      unint64_t v25 = (unint64_t *)(v97 + 32);
      unsigned int v26 = v14[1] - 1;
      do
      {
        uint64_t v27 = v14;
        if (v26 > v24)
        {
          unsigned int v28 = v26;
          uint64_t v27 = v14;
          do
          {
            uint64_t v27 = (void *)v27[14];
            --v28;
          }
          while (v28 > v24);
        }
        if (v18)
        {
          unint64_t v29 = *v25;
          unsigned int v30 = **v94 * v24;
          unsigned int v31 = *(_DWORD *)*v103 * v24;
          int v32 = v99 + 1;
          int v33 = (uint64_t *)(v96 + 1);
          uint64_t v34 = v18;
          do
          {
            unint64_t v35 = *v32++;
            unint64_t v36 = (v35 * (unsigned __int128)v29) >> 64;
            uint64_t v37 = v35 * v29;
            unint64_t v38 = v27[4];
            uint64_t v39 = (v35 * v29 * (unsigned __int128)v38) >> 64;
            uint64_t v40 = (v36 * (unsigned __int128)v38) >> 64;
            uint64_t v41 = v36 * v38;
            BOOL v42 = __CFADD__(v39, v41);
            uint64_t v43 = v39 + v41;
            uint64_t v44 = v42;
            uint64_t v45 = v44
                + __CFADD__(v37 * v27[5], v43)
                + v40
                + v27[5] * v36
                + (((unint64_t)v37 * (unsigned __int128)(unint64_t)v27[5]) >> 64);
            uint64_t v46 = v27[2];
            uint64_t v47 = v37 - v45 * v46;
            if (v47 - v46 >= 0) {
              v47 -= v46;
            }
            uint64_t v48 = *v33++;
            uint64_t v49 = v47 + v48;
            if (v49 - v46 >= 0) {
              v49 -= v46;
            }
            uint64_t v50 = v49 + *(void *)(a3 + 32 + 8 * v30);
            if (v50 - v46 >= 0) {
              v50 -= v46;
            }
            *(void *)(v101 + 32 + 8 * v31++) = v50;
            ++v30;
            --v34;
          }
          while (v34);
        }
        ++v25;
        ++v24;
      }
      while (v24 != v12);
    }
    int v51 = *(_DWORD **)(v101 + 24);
    uint64_t v52 = sizeof_struct_ccpolyzp_po2cyc();
    int v53 = &(&v94[*(_DWORD *)(*(void *)(a3 + 24) + 4) * **(_DWORD **)(a3 + 24)])[(unint64_t)(v52 + 7) >> 3];
    memmove(&v103[(v51[1] * *v51) + ((unint64_t)(v52 + 7) >> 3)], v53, (v52 + 7 + 8 * ((*v53)[1] * **v53)) & 0xFFFFFFFFFFFFFFF8);
    uint64_t result = 0;
    *(void *)(v101 + 16) = *(void *)(a3 + 16);
  }
  *(void *)(a1 + 16) = v95;
  return result;
}

uint64_t cche_ciphertext_plaintext_add(uint64_t a1, uint64_t *a2, unint64_t *a3)
{
  BOOL v13 = timingsafe_enable_if_supported();
  unsigned int v6 = cche_param_ctx_polynomial_degree(*a2);
  uint64_t v7 = sizeof_struct_ccpolyzp_po2cyc();
  v11[0] = cc_malloc_clear((v7 + 8 * v6 + 7) & 0xFFFFFFFFFFFFFFF8);
  unsigned int v8 = cche_param_ctx_polynomial_degree(*a2);
  v11[1] = ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3) + v8;
  _OWORD v11[2] = 0;
  v11[3] = cc_ws_alloc;
  unsigned int v12 = cc_ws_free;
  if (v11[0])
  {
    uint64_t v9 = cche_ciphertext_plaintext_add_ws((uint64_t)v11, a1, (uint64_t)a2, a3);
    v12((uint64_t)v11);
  }
  else
  {
    uint64_t v9 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v13);
  return v9;
}

uint64_t cche_ciphertext_coeff_plaintext_mul_ws(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if (*(_DWORD *)(a2 + 8) != *(_DWORD *)(a3 + 8)) {
    return 4294967289;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  if (!ccpolyzp_po2cyc_ctx_eq(*(void *)(a2 + 24), *(_DWORD **)(a3 + 24))) {
    return 4294967289;
  }
  uint64_t v9 = *a4;
  unsigned int v10 = cche_param_ctx_plaintext_ctx(*(void *)a3);
  if (!ccpolyzp_po2cyc_ctx_eq(v9, v10)) {
    return 4294967289;
  }
  unsigned int v11 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 24);
  unsigned int v12 = *(_DWORD **)(a3 + 24);
  uint64_t v13 = sizeof_struct_ccpolyzp_po2cyc();
  uint64_t v14 = (unsigned int **)v11(a1, (v12[1] * *v12) + ((unint64_t)(v13 + 7) >> 3));
  uint64_t v15 = cche_param_ctx_cipher_plain_ctx_const(*(void *)a3, *(_DWORD *)(*(void *)(a3 + 24) + 4));
  uint64_t result = cche_dcrt_plaintext_encode_ws(a1, v14, (uint64_t)a4, v15);
  if (!result) {
    uint64_t result = cche_ciphertext_coeff_dcrt_plaintext_mul_internal(a2, a3, (uint64_t *)v14);
  }
  *(void *)(a1 + 16) = v8;
  return result;
}

uint64_t cche_param_ctx_cipher_plain_ctx_const(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *cche_param_ctx_plaintext_ctx(a1);
  BOOL v5 = cche_param_ctx_plaintext_ctx(a1);
  unsigned int v6 = cche_param_ctx_polynomial_degree(a1);
  unint64_t v7 = sizeof_struct_ccpolyzp_po2cyc_ctx() + 7;
  if (v6 >= 0x80) {
    uint64_t v8 = 128;
  }
  else {
    uint64_t v8 = v6;
  }
  unint64_t v9 = ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v8 + v6;
  uint64_t v10 = (4 * v4 + 7) & 0x7FFFFFFF8;
  uint64_t v11 = cche_param_ctx_chain_const(a1);
  uint64_t v12 = cche_decrypt_ctx_nof_n((unsigned int *)(v11 + 8));
  uint64_t v13 = v12;
  if (a2 < 2) {
    return (uint64_t)&v5[4 * v9 + 12 + 2 * (v7 >> 3) + 2 * v12] + v10;
  }
  uint64_t v14 = sizeof_struct_cche_cipher_plain_ctx();
  return (uint64_t)&v5[4 * v9 + 16 + 4 * (((a2 - 2) * (unint64_t)(a2 - 3)) >> 1) + 2 * v13]
       + ((v14 + 7) & 0xFFFFFFFFFFFFFFF8)
       + (v7 & 0xFFFFFFFFFFFFFFF8)
       + v10
       + (((v14 + 7) & 0xFFFFFFFFFFFFFFF8) + 32) * (a2 - 2);
}

uint64_t cche_ciphertext_coeff_dcrt_plaintext_mul_internal(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 4294967289;
  }
  unsigned int v6 = (_DWORD **)(a1 + 24);
  if (!ccpolyzp_po2cyc_ctx_eq(*(void *)(a1 + 24), *(_DWORD **)(a2 + 24))
    || !ccpolyzp_po2cyc_ctx_eq(*a3, *(_DWORD **)(a2 + 24)))
  {
    return 4294967289;
  }
  uint64_t v7 = *(unsigned int *)(a2 + 8);
  if (a1 != a2)
  {
    uint64_t v8 = *(_DWORD **)(a2 + 24);
    uint64_t v9 = sizeof_struct_ccrns_mul_modulus();
    unint64_t v10 = sizeof_struct_ccpolyzp_po2cyc();
    unint64_t v11 = (v9 + v10 - 1) / v10;
    uint64_t v12 = sizeof_struct_ccpolyzp_po2cyc();
    memmove((void *)a1, (const void *)a2, 8 * (v11 + ((v8[1] * *v8) + ((unint64_t)(v12 + 7) >> 3)) * v7));
  }
  uint64_t result = cche_ciphertext_fwd_ntt_internal(a1);
  if (!result)
  {
    if (v7)
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        uint64_t v15 = *v6;
        uint64_t v16 = &v6[((v15[1] * *v15) + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3)) * i];
        ccpolyzp_po2cyc_eval_mul(v16, v16, (_DWORD **)a3);
      }
    }
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    return cche_ciphertext_inv_ntt_internal(a1);
  }
  return result;
}

uint64_t cche_ciphertext_coeff_plaintext_mul(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  BOOL v15 = timingsafe_enable_if_supported();
  unsigned int v6 = *(int **)(a2 + 24);
  int v7 = *v6;
  int v8 = v6[1];
  uint64_t v9 = sizeof_struct_ccpolyzp_po2cyc();
  v13[0] = cc_malloc_clear((v9 + 8 * (v8 * v7) + 7) & 0xFFFFFFFFFFFFFFF8);
  int v10 = *v6;
  LODWORD(v6) = v6[1];
  v13[1] = (v6 * v10) + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3);
  void v13[2] = 0;
  void v13[3] = cc_ws_alloc;
  uint64_t v14 = cc_ws_free;
  if (v13[0])
  {
    uint64_t v11 = cche_ciphertext_coeff_plaintext_mul_ws((uint64_t)v13, a1, a2, a3);
    v14((uint64_t)v13);
  }
  else
  {
    uint64_t v11 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v11;
}

uint64_t cche_ciphertext_coeff_dcrt_plaintext_mul(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t v6 = cche_ciphertext_coeff_dcrt_plaintext_mul_internal(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return v6;
}

uint64_t cche_ciphertext_eval_dcrt_plaintext_mul(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t v6 = cche_ciphertext_eval_dcrt_plaintext_mul_internal(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return v6;
}

uint64_t cche_ciphertext_eval_dcrt_plaintext_mul_internal(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 4294967289;
  }
  uint64_t v6 = (_DWORD **)(a1 + 24);
  int v7 = (_DWORD **)(a2 + 24);
  if (!ccpolyzp_po2cyc_ctx_eq(*(void *)(a1 + 24), *(_DWORD **)(a2 + 24)) || !ccpolyzp_po2cyc_ctx_eq(*a3, *v7)) {
    return 4294967289;
  }
  uint64_t v8 = *(unsigned int *)(a2 + 8);
  if (v8)
  {
    for (uint64_t i = 0; i != v8; ++i)
    {
      int v10 = *v6;
      uint64_t v11 = sizeof_struct_ccpolyzp_po2cyc();
      ccpolyzp_po2cyc_eval_mul(&v6[((v10[1] * *v10) + ((unint64_t)(v11 + 7) >> 3)) * i], &v7[(((*v7)[1] * **v7) + ((unint64_t)(v11 + 7) >> 3)) * i], (_DWORD **)a3);
    }
  }
  uint64_t result = 0;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  return result;
}

uint64_t cche_ciphertext_eval_plaintext_mul_ws(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if (*(_DWORD *)(a2 + 8) != *(_DWORD *)(a3 + 8)) {
    return 4294967289;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  if (!ccpolyzp_po2cyc_ctx_eq(*(void *)(a2 + 24), *(_DWORD **)(a3 + 24))) {
    return 4294967289;
  }
  uint64_t v9 = *a4;
  int v10 = cche_param_ctx_plaintext_ctx(*(void *)a3);
  if (!ccpolyzp_po2cyc_ctx_eq(v9, v10)) {
    return 4294967289;
  }
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 24);
  uint64_t v12 = *(_DWORD **)(a3 + 24);
  uint64_t v13 = sizeof_struct_ccpolyzp_po2cyc();
  uint64_t v14 = (unsigned int **)v11(a1, (v12[1] * *v12) + ((unint64_t)(v13 + 7) >> 3));
  uint64_t v15 = cche_param_ctx_cipher_plain_ctx_const(*(void *)a3, *(_DWORD *)(*(void *)(a3 + 24) + 4));
  uint64_t result = cche_dcrt_plaintext_encode_ws(a1, v14, (uint64_t)a4, v15);
  if (!result)
  {
    uint64_t result = cche_ciphertext_eval_dcrt_plaintext_mul_internal(a2, a3, (uint64_t *)v14);
    *(void *)(a2 + 16) = *(void *)(a3 + 16);
  }
  *(void *)(a1 + 16) = v8;
  return result;
}

uint64_t cche_ciphertext_eval_plaintext_mul(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  BOOL v15 = timingsafe_enable_if_supported();
  uint64_t v6 = *(int **)(a2 + 24);
  int v7 = *v6;
  int v8 = v6[1];
  uint64_t v9 = sizeof_struct_ccpolyzp_po2cyc();
  v13[0] = cc_malloc_clear((v9 + 8 * (v8 * v7) + 7) & 0xFFFFFFFFFFFFFFF8);
  int v10 = *v6;
  LODWORD(v6) = v6[1];
  v13[1] = (v6 * v10) + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3);
  void v13[2] = 0;
  void v13[3] = cc_ws_alloc;
  uint64_t v14 = cc_ws_free;
  if (v13[0])
  {
    uint64_t v11 = cche_ciphertext_eval_plaintext_mul_ws((uint64_t)v13, a1, a2, a3);
    v14((uint64_t)v13);
  }
  else
  {
    uint64_t v11 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v11;
}

uint64_t ccder_blob_decode_eckey_internal(unsigned __int8 **a1, unint64_t *a2, void *a3, void *a4, unsigned __int8 **a5, void *a6, void *a7, unint64_t *a8)
{
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  long long v22 = 0uLL;
  uint64_t result = ccder_blob_decode_sequence_tl(a1, (unsigned __int8 **)&v22);
  if (result)
  {
    uint64_t result = ccder_blob_decode_uint64((unsigned __int8 **)&v22, a2);
    if (result)
    {
      if (*a2 == 1)
      {
        uint64_t result = ccder_blob_decode_range((unsigned __int8 **)&v22, 4, &v23);
        if (!result) {
          return result;
        }
        uint64_t v16 = v23;
        uint64_t v17 = v24;
        *a4 = v23;
        *a3 = v17 - (void)v16;
        long long v21 = v22;
        if (ccder_blob_decode_range((unsigned __int8 **)&v21, 0xA000000000000000, &v23))
        {
          uint64_t result = ccder_blob_decode_oid(&v23, a5);
          if (!result) {
            return result;
          }
          long long v22 = v21;
        }
        else
        {
          *a5 = 0;
        }
        long long v20 = v22;
        if (ccder_blob_decode_range((unsigned __int8 **)&v20, 0xA000000000000001, &v23))
        {
          uint64_t result = ccder_blob_decode_bitstring(&v23, (uint64_t)&v23, a8);
          if (result)
          {
            uint64_t v18 = v23;
            uint64_t v19 = v24;
            *a7 = v23;
            *a6 = v19 - (void)v18;
            return 1;
          }
        }
        else
        {
          *a7 = 0;
          *a6 = 0;
          uint64_t result = 1;
          *a8 = 0;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t ccder_blob_decode_eckey(unsigned __int8 **a1, unint64_t *a2, void *a3, void *a4, unsigned __int8 **a5, void *a6, void *a7, unint64_t *a8)
{
  BOOL v18 = timingsafe_enable_if_supported();
  uint64_t v16 = ccder_blob_decode_eckey_internal(a1, a2, a3, a4, a5, a6, a7, a8);
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return v16;
}

uint64_t ccz_mul(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v24 = timingsafe_enable_if_supported();
  int v6 = ccz_sign(a2);
  int v7 = ccz_sign(a3);
  ccz_set_sign(a1, v7 * v6);
  unint64_t v8 = ccz_n(a2);
  unint64_t v9 = ccz_n(a3);
  if (v8 <= v9) {
    unint64_t v8 = v9;
  }
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  ccz_init(*(void *)(a2 + 8), (uint64_t)&v22);
  ccz_init(*(void *)(a2 + 8), (uint64_t)&v20);
  ccz_set_capacity((uint64_t)&v22, v8);
  ccz_set_capacity((uint64_t)&v20, v8);
  int v10 = (char *)*((void *)&v23 + 1);
  uint64_t v11 = ccz_n(a2);
  uint64_t v12 = v11;
  if (v11) {
    ccn_set(v11, v10, *(void **)(a2 + 24));
  }
  ccn_zero(v8 - v12, &v10[8 * v12]);
  uint64_t v13 = (char *)*((void *)&v21 + 1);
  uint64_t v14 = ccz_n(a3);
  uint64_t v15 = v14;
  if (v14) {
    ccn_set(v14, v13, *(void **)(a3 + 24));
  }
  ccn_zero(v8 - v15, &v13[8 * v15]);
  ccz_set_capacity(a1, 2 * v8);
  ccn_mul(v8, *(char **)(a1 + 24), *((unint64_t **)&v21 + 1), *((unint64_t **)&v23 + 1));
  uint64_t v16 = ccz_n(a2);
  uint64_t v17 = ccz_n(a3);
  unint64_t v18 = ccn_n(v17 + v16, *(void *)(a1 + 24));
  ccz_set_n((void *)a1, v18);
  ccz_free((uint64_t)&v22);
  ccz_free((uint64_t)&v20);
  return cc_disable_dit_with_sb((unsigned int *)&v24);
}

uint64_t ccmode_siv_decrypt(void *a1, unint64_t a2, _OWORD *a3, char *a4)
{
  uint64_t v15 = *MEMORY[0x263EF8C08];
  if (*(void *)(*(void *)(*a1 + 56) + 8) != 16) {
    return 4294967226;
  }
  uint64_t v5 = a1[2];
  if (v5 != 4 && v5 != 2) {
    return 4294967228;
  }
  unint64_t v7 = a2 - 16;
  if (a2 >= 0x10)
  {
    uint64_t v10 = *(void *)(*a1 + 64);
    *(_OWORD *)uint64_t v14 = *a3;
    long long v12 = *(_OWORD *)v14;
    BYTE8(v12) = v14[8] & 0x7F;
    BYTE12(v12) = v14[12] & 0x7F;
    uint64_t v8 = ccctr_one_shot_internal(v10, a1[1] >> 1, (uint64_t)(a1 + 7), (uint64_t)&v12, v7, (uint64_t)(a3 + 1), (uint64_t)a4);
    if (!v8)
    {
      uint64_t v8 = ccmode_siv_auth_finalize((uint64_t)a1, v7, a4, v13);
      if (!v8)
      {
        if (!cc_cmp_safe_internal(16, v13, v14) && a1[2] == 5) {
          return 0;
        }
        uint64_t v8 = 4294967227;
      }
    }
    cc_clear(v7, a4);
    return v8;
  }
  return 4294967229;
}

uint64_t cczp_generate_non_zero_element_ws(uint64_t a1, uint64_t a2, uint64_t (**a3)(void, unint64_t, uint64_t), char *a4)
{
  uint64_t v8 = cczp_n(a2);
  uint64_t v9 = cczp_bitlen(a2);
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8);
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8 + 1);
  uint64_t v13 = ccn_random_bits(v9 + 64, v12, a3);
  if (!v13)
  {
    uint64_t v14 = (unint64_t *)cczp_prime(a2);
    ccn_sub1(v8, v11, v14, 1uLL);
    ccn_divmod_ws(a1, (unint64_t)(v9 + 127) >> 6, v12, 0, 0, v8, a4, v11);
    ccn_add1_ws(a1, v8, a4, (uint64_t *)a4, 1);
  }
  *(void *)(a1 + 16) = v10;
  return v13;
}

void *ccdh_gp_rfc3526group05()
{
  return &_ccdh_gp_rfc3526group05;
}

uint64_t ccrng_test_init(uint64_t (**a1)(uint64_t a1, uint64_t a2, uint64_t a3), uint64_t a2, uint64_t a3, const char *a4)
{
  *a1 = ccrng_test_generate;
  uint64_t v8 = ccaes_cbc_encrypt_mode();
  uint64_t result = ccdrbg_df_bc_init(ccrng_test_init_df_ctx, v8, 0x10uLL);
  if (!result)
  {
    ccrng_test_init_custom = (uint64_t)ccaes_ctr_crypt_mode();
    ccdrbg_factory_nistctr(a1 + 1, (uint64_t)&ccrng_test_init_custom);
    uint64_t v10 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))malloc_type_malloc(2 * (void)a1[1], 0x319C42F8uLL);
    a1[8] = v10;
    if (!a4) {
      a4 = (const char *)&unk_2373C8106;
    }
    size_t v11 = strlen(a4);
    return ccdrbg_init((uint64_t)(a1 + 1), (uint64_t)v10, a2, a3, a2, a3, v11, (uint64_t)a4);
  }
  return result;
}

uint64_t ccrng_test_generate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ccdrbg_generate(a1 + 8, *(void *)(a1 + 64), a2, a3, 0, 0);
}

void ccrng_test_done(uint64_t a1)
{
  *(void *)(a1 + 64) = 0;
}

BOOL ccec_is_compactable_pub(unint64_t **a1)
{
  unint64_t v2 = *a1;
  unint64_t v3 = **a1;
  v9[0] = cc_malloc_clear(8 * v3);
  v9[1] = v3;
  uint64_t v10 = 0;
  size_t v11 = cc_ws_alloc;
  uint64_t v12 = cc_ws_free;
  if (!v9[0]) {
    return 0;
  }
  uint64_t v4 = a1 + 2;
  uint64_t v5 = *v2;
  if (ccn_n(*v2, (uint64_t)&v4[2 * *v2]) == 1 && v4[2 * *v2] == (void *)1)
  {
    int v6 = (uint64_t *)cc_ws_alloc(v9, v5);
    cczp_negate((uint64_t)v2, v6, (unint64_t *)&v4[*v2]);
    BOOL v7 = (int)ccn_cmp_public_value(v5, v6, (uint64_t *)&v4[*v2]) >= 0;
    uint64_t v10 = 0;
    v12((uint64_t)v9);
  }
  else
  {
    BOOL v7 = 0;
    cc_ws_free((uint64_t)v9);
  }
  return v7;
}

uint64_t ccec_compact_export_pub(char *a1, uint64_t *a2)
{
  unint64_t v3 = (unint64_t *)(a2 + 2);
  uint64_t v4 = (unint64_t *)*a2;
  unint64_t v6 = (unint64_t)(cczp_bitlen(*a2) + 7) >> 3;
  return ccec_export_affine_point_public_value(v4, 4, v3, &v6, a1);
}

uint64_t ccprime_rabin_miller_init_ws(uint64_t a1, uint64_t *a2, unint64_t a3, void *a4)
{
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t inited = cczp_mm_init_ws(a1, a2, a3, a4);
  if (!inited)
  {
    uint64_t v10 = &a2[2 * *a2];
    size_t v11 = &v10[*a2 + 5];
    ccn_set(a3, v11, a4);
    *v11 &= ~1uLL;
    unint64_t v12 = ccn_trailing_zeros(a3, (uint64_t)v11);
    void v10[4] = v12;
    ccn_shift_right_multi(a3, (uint64_t)(v10 + 5), (unint64_t *)v11, v12);
    cczp_to_ws(a1, (uint64_t)a2);
  }
  *(void *)(a1 + 16) = v8;
  return inited;
}

uint64_t ccprime_rabin_miller_iteration_ws(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t (**a4)(void, unint64_t, uint64_t))
{
  uint64_t v4 = *a2;
  uint64_t v5 = &a2[2 * *a2];
  if ((unint64_t)v5[4] > 0x3F) {
    return 0;
  }
  uint64_t v21 = v5[4];
  uint64_t v9 = (uint64_t)(v5 + 5);
  uint64_t v10 = cczp_n((uint64_t)a2);
  uint64_t v11 = *(void *)(a1 + 16);
  unint64_t v12 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10);
  uint64_t v13 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10);
  cczp_to_ws(a1, (uint64_t)a2);
  ccn_seti(v10, v13, 1);
  cczp_to_ws(a1, (uint64_t)a2);
  uint64_t v14 = cczp_power_blinded_ws(a1, (uint64_t)a2, v12, v12, v10 << 6, v9, a4);
  if (!v14)
  {
    uint64_t v15 = v9 + 8 * v4;
    char v16 = ccn_cmp_internal(v10, v15, v12);
    uint64_t v14 = ((ccn_cmp_internal(v10, v12, v13) & 1) == 0) | ((v16 & 1) == 0);
    uint64_t v17 = 1;
    do
    {
      if ((v14 | (((v17 ^ (unint64_t)v21) + 0xFFFFFFFF) >> 32)) != 1) {
        break;
      }
      cczp_sqr_ws(a1, (uint64_t)a2);
      v14 |= (ccn_cmp_internal(v10, v15, v12) & 1) == 0;
      int v18 = ccn_cmp_internal(v10, v12, v13);
      BOOL v19 = (v14 & 1) == 0 && v18 == 0;
      if (v19) {
        break;
      }
      BOOL v19 = v17++ == 63;
    }
    while (!v19);
  }
  *(void *)(a1 + 16) = v11;
  return v14;
}

uint64_t ccprime_rabin_miller_ws(uint64_t a1, unint64_t a2, unint64_t *a3, unint64_t a4, uint64_t (**a5)(void, unint64_t, uint64_t))
{
  if (!a4) {
    return 4294967289;
  }
  uint64_t result = ccn_n(a2, (uint64_t)a3);
  if (result)
  {
    uint64_t v11 = result;
    unint64_t v12 = *a3;
    if (result == 1 && v12 == 1) {
      return 0;
    }
    if (v12)
    {
      uint64_t v14 = 0;
      while (1)
      {
        unint64_t v13 = (unsigned __int16)ccn_prime_table[v14];
        if (ccn_divides1(a2, a3, v13)) {
          break;
        }
        if (++v14 == 255)
        {
          uint64_t v15 = *(void *)(a1 + 16);
          char v16 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 4 * a2 + 5);
          uint64_t result = ccprime_rabin_miller_init_ws(a1, v16, a2, a3);
          if (!result)
          {
            uint64_t v17 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, a2);
            uint64_t v18 = 0;
            if (a4 <= 1) {
              uint64_t v19 = 1;
            }
            else {
              uint64_t v19 = a4;
            }
            uint64_t v26 = v19;
LABEL_21:
            unint64_t v20 = cczp_n((uint64_t)v16);
            uint64_t v21 = *(void *)(a1 + 16);
            long long v22 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 2 * v20);
            cc_clear(16 * v20, v22);
            uint64_t v23 = cczp_bitlen((uint64_t)v16);
            uint64_t v27 = v21;
            if ((unint64_t)cczp_bitlen((uint64_t)v16) <= 0x40) {
              uint64_t v24 = cczp_bitlen((uint64_t)v16) + (v20 << 6) - 1;
            }
            else {
              uint64_t v24 = v23 + 64;
            }
            int v25 = 100;
            while (1)
            {
              uint64_t result = ccn_random_bits(v24, (uint64_t)v22, a5);
              if (result) {
                break;
              }
              cczp_mod_ws(a1, (uint64_t)v16);
              if (v20 && (ccn_n(v20, (uint64_t)v17) > 1 || *v17 > 1uLL))
              {
                *(void *)(a1 + 16) = v27;
                uint64_t result = ccprime_rabin_miller_iteration_ws(a1, v16, (uint64_t)v17, a5);
                if (result == 1 && ++v18 != v26) {
                  goto LABEL_21;
                }
                break;
              }
              if (!--v25) {
                cc_try_abort();
              }
            }
          }
          *(void *)(a1 + 16) = v15;
          return result;
        }
      }
    }
    else
    {
      unint64_t v13 = 2;
    }
    return v11 == 1 && *a3 == v13;
  }
  return result;
}

uint64_t ccprime_rabin_miller(unint64_t a1, unint64_t *a2, unint64_t a3, uint64_t (**a4)(void, unint64_t, uint64_t))
{
  uint64_t v8 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v9 = sizeof_struct_ccpolyzp_po2cyc();
  uint64_t v10 = 19 * a1 + 2;
  v15[0] = cc_malloc_clear(8 * ((v8 + v9 - 1) / v9 + v10));
  uint64_t v11 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v12 = sizeof_struct_ccpolyzp_po2cyc();
  v15[1] = (v11 + v12 - 1) / v12 + v10;
  _OWORD v15[2] = 0;
  v15[3] = cc_ws_alloc;
  char v16 = cc_ws_free;
  if (!v15[0]) {
    return 4294967283;
  }
  uint64_t v13 = ccprime_rabin_miller_ws((uint64_t)v15, a1, a2, a3, a4);
  v16((uint64_t)v15);
  return v13;
}

unint64_t ccn_subn(uint64_t a1, void *a2, uint64_t *a3, uint64_t a4, unint64_t *a5)
{
  uint64_t v5 = a1 - a4;
  unint64_t v6 = &a2[a4];
  BOOL v7 = (unint64_t *)&a3[a4];
  unint64_t v8 = ccn_sub_ws(0, a4, a2, a3, a5);

  return ccn_sub1(v5, v6, v7, v8);
}

uint64_t ccmode_siv_hmac_nonce(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3 != 4 && v3 != 2) {
    return 4294967228;
  }
  if (!a2) {
    return 4294967194;
  }
  ccmode_siv_hmac_auth_backend(a1, a2, a3, 78);
  uint64_t result = 0;
  *(void *)(a1 + 24) = 6;
  return result;
}

double ccmode_factory_ccm_decrypt(uint64_t a1, void *a2)
{
  *(void *)a1 = ((a2[1] + 7) & 0xFFFFFFFFFFFFFFF8) + ((*a2 + 7) & 0xFFFFFFFFFFFFFFF8) + 8;
  *(void *)&double result = 96;
  *(_OWORD *)(a1 + 8) = xmmword_2373B5210;
  *(void *)(a1 + 24) = ccmode_ccm_init;
  *(void *)(a1 + 32) = ccmode_ccm_set_iv;
  *(void *)(a1 + 40) = ccmode_ccm_cbcmac;
  *(void *)(a1 + 48) = ccmode_ccm_decrypt;
  *(void *)(a1 + 56) = ccmode_ccm_finalize;
  *(void *)(a1 + 64) = ccmode_ccm_reset;
  *(void *)(a1 + 72) = a2;
  *(void *)(a1 + 80) = 0;
  return result;
}

uint64_t ccz_init(uint64_t a1, uint64_t a2)
{
  BOOL v5 = timingsafe_enable_if_supported();
  *(void *)(a2 + 24) = 0;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = a1;
  *(_DWORD *)(a2 + 16) = 0;
  return cc_disable_dit_with_sb((unsigned int *)&v5);
}

size_t ccpad_cts2_encrypt(uint64_t a1, uint64_t a2, uint64_t a3, size_t a4, uint64_t a5, char *a6)
{
  uint64_t v22 = *MEMORY[0x263EF8C08];
  BOOL v20 = timingsafe_enable_if_supported();
  unint64_t v12 = *(void *)(a1 + 8);
  unint64_t v13 = (a4 - 1) / v12;
  if (v13 >= 2)
  {
    uint64_t v15 = (v13 - 1) * v12;
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a2, a3);
    size_t v14 = a4 - v15;
    a5 += v15;
    a6 += v15;
  }
  else
  {
    size_t v14 = a4;
  }
  if (v14 == 2 * v12)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *))(a1 + 24))(a2, a3, 2, a5, __src);
  }
  else
  {
    cc_clear(2 * v12, __src);
    __memcpy_chk();
    (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *))(a1 + 24))(a2, a3, 2, __src, __src);
    uint64_t v16 = 0;
    uint64_t v17 = &__src[v12];
    do
    {
      char v18 = __src[v16];
      __src[v16] = v17[v16];
      v17[v16++] = v18;
    }
    while (v12 != v16);
  }
  memcpy(a6, __src, v14);
  cc_disable_dit_with_sb((unsigned int *)&v20);
  return a4;
}

uint64_t cc_atfork_child()
{
  BOOL v1 = timingsafe_enable_if_supported();
  ccrng_atfork_child();
  return cc_disable_dit_with_sb((unsigned int *)&v1);
}

uint64_t cccmac_one_shot_generate_internal(void *a1, uint64_t a2, uint64_t a3, unint64_t a4, char *a5, size_t a6, void *a7)
{
  v20[1] = *MEMORY[0x263EF8C08];
  unint64_t v12 = (void *)MEMORY[0x270FA53B0](a1, a2, a2, a3);
  size_t v14 = (char *)&v20[-2 * v13];
  uint64_t inited = cccmac_init_internal(v12, (uint64_t)v14, v15, v16);
  if (!inited)
  {
    uint64_t inited = cccmac_update_internal(v14, a4, a5);
    if (!inited) {
      uint64_t inited = cccmac_final_generate_internal(v14, a6, a7);
    }
  }
  uint64_t v18 = inited;
  cc_clear(a1[1] + *a1 + 80, v14);
  return v18;
}

uint64_t cccmac_one_shot_generate(void *a1, uint64_t a2, uint64_t a3, unint64_t a4, char *a5, size_t a6, void *a7)
{
  BOOL v16 = timingsafe_enable_if_supported();
  uint64_t internal = cccmac_one_shot_generate_internal(a1, a2, a3, a4, a5, a6, a7);
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return internal;
}

uint64_t cccmac_one_shot_verify(void *a1, unint64_t a2, uint64_t a3, unint64_t a4, char *a5, uint64_t a6, char *a7)
{
  uint64_t v24 = *MEMORY[0x263EF8C08];
  BOOL v14 = timingsafe_enable_if_supported();
  HIDWORD(v23) = v14;
  MEMORY[0x270FA53B0](v14, v15, v16, v17);
  uint64_t v19 = (char *)(&v23 - 2 * v18);
  uint64_t inited = cccmac_init_internal(a1, (uint64_t)v19, a2, a3);
  if (!inited)
  {
    uint64_t inited = cccmac_update_internal(v19, a4, a5);
    if (!inited) {
      uint64_t inited = cccmac_final_verify_internal(v19, a6, a7);
    }
  }
  uint64_t v21 = inited;
  cc_clear(a1[1] + *a1 + 80, v19);
  cc_disable_dit_with_sb((unsigned int *)&v23 + 1);
  return v21;
}

void *ccrc4()
{
  return &ccrc4_eay;
}

void *ccaes_siv_decrypt_mode()
{
  unint64_t v0 = ccaes_cbc_encrypt_mode();
  BOOL v1 = ccaes_ctr_crypt_mode();
  ccmode_factory_siv_decrypt((uint64_t)&siv_decrypt, (uint64_t)v0, (uint64_t)v1);
  return &siv_decrypt;
}

uint64_t ccrsa_sign_pkcs1v15_blinded_ws(uint64_t a1, uint64_t (**a2)(void, uint64_t, uint64_t), unint64_t *a3, unsigned __int8 *a4, size_t a5, const void *a6, unint64_t *a7, char *a8)
{
  unint64_t v16 = *a3;
  unint64_t v17 = ccn_write_uint_size_public_value(*a3, a3 + 3);
  if (*a7 < v17) {
    return 4294967273;
  }
  unint64_t v19 = v17;
  uint64_t v21 = a2;
  uint64_t v22 = *(void *)(a1 + 16);
  BOOL v20 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v16);
  *a7 = v19;
  uint64_t result = ccrsa_emsa_pkcs1v15_encode_internal(v19, a8, a5, a6, a4);
  if (!result)
  {
    ccn_read_uint_internal(v16, v20, v19, a8);
    uint64_t result = ccrsa_priv_crypt_blinded_ws(a1, v21, (uint64_t *)a3, v20, v20);
    if (!result)
    {
      ccn_write_uint_padded_ct_internal(v16, (unint64_t *)v20, v19, a8);
      uint64_t result = 0;
    }
  }
  *(void *)(a1 + 16) = v22;
  return result;
}

uint64_t ccrsa_sign_pkcs1v15_blinded(uint64_t (**a1)(void, uint64_t, uint64_t), unint64_t *a2, unsigned __int8 *a3, size_t a4, const void *a5, unint64_t *a6, char *a7)
{
  unint64_t v13 = *a2;
  uint64_t v14 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v16 = (v14 + v15 - 1) / v15 + 11 * v13;
  unint64_t v17 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(v13);
  if (v16 + 1 > v17) {
    unint64_t v18 = v16 + 1;
  }
  else {
    unint64_t v18 = v17;
  }
  unint64_t v19 = cc_malloc_clear(8 * (v18 + 3 * v13));
  v29[0] = v19;
  unint64_t v20 = *a2;
  uint64_t v21 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v22 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v23 = (v21 + v22 - 1) / v22 + 11 * v20;
  unint64_t v24 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(v20);
  if (v23 + 1 > v24) {
    unint64_t v25 = v23 + 1;
  }
  else {
    unint64_t v25 = v24;
  }
  v29[1] = v25 + 3 * v20;
  void v29[2] = 0;
  v29[3] = cc_ws_alloc;
  unsigned int v30 = cc_ws_free;
  if (!v19) {
    return 4294967283;
  }
  uint64_t v26 = ccrsa_sign_pkcs1v15_blinded_ws((uint64_t)v29, a1, a2, a3, a4, a5, a6, a7);
  v30((uint64_t)v29);
  return v26;
}

uint64_t ccrsa_sign_pkcs1v15(unint64_t *a1, unsigned __int8 *a2, size_t a3, const void *a4, unint64_t *a5, char *a6)
{
  BOOL v15 = timingsafe_enable_if_supported();
  unint64_t v12 = ccrng(0);
  if (v12) {
    uint64_t v13 = ccrsa_sign_pkcs1v15_blinded((uint64_t (**)(void, uint64_t, uint64_t))v12, a1, a2, a3, a4, a5, a6);
  }
  else {
    uint64_t v13 = 0xFFFFFFFFLL;
  }
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v13;
}

uint64_t ccrsa_sign_pkcs1v15_msg_blinded_ws(uint64_t a1, uint64_t (**a2)(void, uint64_t, uint64_t), unint64_t *a3, uint64_t a4, size_t a5, char *a6, unint64_t *a7, char *a8)
{
  uint64_t v16 = *MEMORY[0x263EF8C08];
  ccdigest_internal(a4, a5, a6, (uint64_t)v15);
  return ccrsa_sign_pkcs1v15_blinded_ws(a1, a2, a3, *(unsigned __int8 **)(a4 + 32), *(void *)a4, v15, a7, a8);
}

uint64_t ccrsa_sign_pkcs1v15_msg_blinded(uint64_t (**a1)(void, uint64_t, uint64_t), unint64_t *a2, uint64_t a3, size_t a4, char *a5, unint64_t *a6, char *a7)
{
  uint64_t v32 = *MEMORY[0x263EF8C08];
  unint64_t v13 = *a2;
  uint64_t v14 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v16 = (v14 + v15 - 1) / v15 + 11 * v13;
  unint64_t v17 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(v13);
  if (v16 + 1 > v17) {
    unint64_t v18 = v16 + 1;
  }
  else {
    unint64_t v18 = v17;
  }
  unint64_t v19 = cc_malloc_clear(8 * (v18 + 3 * v13));
  v29[0] = v19;
  unint64_t v20 = *a2;
  uint64_t v21 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v22 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v23 = (v21 + v22 - 1) / v22 + 11 * v20;
  unint64_t v24 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(v20);
  if (v23 + 1 > v24) {
    unint64_t v25 = v23 + 1;
  }
  else {
    unint64_t v25 = v24;
  }
  v29[1] = v25 + 3 * v20;
  void v29[2] = 0;
  v29[3] = cc_ws_alloc;
  unsigned int v30 = cc_ws_free;
  if (!v19) {
    return 4294967283;
  }
  ccdigest_internal(a3, a4, a5, (uint64_t)v31);
  uint64_t v26 = ccrsa_sign_pkcs1v15_blinded_ws((uint64_t)v29, a1, a2, *(unsigned __int8 **)(a3 + 32), *(void *)a3, v31, a6, a7);
  v30((uint64_t)v29);
  return v26;
}

uint64_t ccrsa_sign_pkcs1v15_msg(unint64_t *a1, uint64_t a2, size_t a3, char *a4, unint64_t *a5, char *a6)
{
  uint64_t v17 = *MEMORY[0x263EF8C08];
  BOOL v15 = timingsafe_enable_if_supported();
  ccdigest_internal(a2, a3, a4, (uint64_t)v16);
  unint64_t v12 = ccrng(0);
  if (v12) {
    uint64_t v13 = ccrsa_sign_pkcs1v15_blinded((uint64_t (**)(void, uint64_t, uint64_t))v12, a1, *(unsigned __int8 **)(a2 + 32), *(void *)a2, v16, a5, a6);
  }
  else {
    uint64_t v13 = 0xFFFFFFFFLL;
  }
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v13;
}

uint64_t ccsha3_final(unint64_t *a1, uint64_t a2, void *a3, uint64_t (*a4)(uint64_t *))
{
  v15[1] = *MEMORY[0x263EF8C08];
  unint64_t v8 = a1[1];
  unint64_t v7 = a1[2];
  uint64_t v9 = a2 + v8 + 8;
  if (v7 <= *(unsigned int *)(v9 + v7)) {
    *(_DWORD *)(v9 + v7) = 0;
  }
  MEMORY[0x270FA53B0](a1, a2, a3, a4);
  uint64_t v11 = (char *)v15 - v10;
  memcpy((char *)v15 - v10, v13, v12 + 12);
  cckeccak_absorb_and_pad((uint64_t)(v11 + 8), v7, *(unsigned int *)&v11[v8 + 8 + v7], (uint64_t *)&v11[v8 + 8], 6u, a4);
  cckeccak_squeeze((uint64_t)(v11 + 8), a1[2], *a1, a3, a4);
  return cc_clear(a1[1] + a1[2] + 12, v11);
}

uint64_t ccrsa_generate_probable_prime_ws(uint64_t a1, unint64_t a2, char *a3, void *a4, unint64_t a5, unint64_t a6, uint64_t a7, void *a8, uint64_t (**a9)(void, unint64_t, void *), uint64_t (**a10)(void, unint64_t, uint64_t), void *a11)
{
  uint64_t v17 = a11;
  unint64_t v18 = a9;
  unint64_t v19 = (a2 + 63) >> 6;
  uint64_t v41 = *(void *)(a1 + 16);
  int v63 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v19);
  int v69 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v19);
  unsigned int v20 = 0;
  unint64_t v72 = (a5 + 63) >> 6;
  if (a5 + 1 > a6) {
    unint64_t v21 = a5 + 1;
  }
  else {
    unint64_t v21 = a6;
  }
  unint64_t v22 = (v21 + 63) >> 6;
  unint64_t v53 = a5 + 63;
  uint64_t v52 = v22 - ((a5 + 63) >> 6);
  unint64_t v54 = a6 - 1;
  unint64_t v55 = a5 - 1;
  unint64_t v57 = (a6 + 63) >> 6;
  unint64_t v51 = a6 + 63;
  uint64_t v50 = v22 - v57;
  unint64_t v47 = 2 * v22;
  unint64_t v64 = v22;
  uint64_t v43 = v19 - 2 * v22;
  unint64_t v45 = a2 - 5;
  unint64_t v23 = a2 - 1;
  unint64_t v75 = a2 - 256;
  rsize_t __n = 8 * v19;
  unint64_t v49 = a2;
  uint64_t v24 = 5 * a2;
  if (5 * a2 <= 1) {
    uint64_t v24 = 1;
  }
  uint64_t v42 = v24;
  unint64_t v62 = a6;
  unint64_t v25 = a5;
  unint64_t v48 = a5;
  uint64_t __s = a3;
  do
  {
    unsigned int v67 = v20;
    ccn_zero(v72, v63);
    ccn_zero(v72, v69);
    if (ccn_random_bits_fips(v25, v63, v18) || ccn_random_bits_fips(v62, v69, v18))
    {
      uint64_t result = 4294967260;
      goto LABEL_60;
    }
    uint64_t v73 = *(void *)(a1 + 16);
    ccn_set_bit((uint64_t)v63, v55, 1);
    ccn_set_bit((uint64_t)v69, v54, 1);
    if (v17)
    {
      v17 += 387 * v17[2];
      *uint64_t v17 = ccn_bitlen_internal(v72, v63);
      v17[1] = ccn_bitlen_internal(v72, v69);
      __memcpy_chk();
      __memcpy_chk();
      v17[3] |= 1uLL;
      v17[67] |= 1uLL;
    }
    unint64_t v26 = v64;
    uint64_t result = ccrsa_find_next_prime_ws(a1, v25, (unint64_t *)v63, a10);
    if (result) {
      goto LABEL_60;
    }
    uint64_t result = ccrsa_find_next_prime_ws(a1, v62, (unint64_t *)v69, a10);
    if (result || !v17)
    {
      *(void *)(a1 + 16) = v73;
      unint64_t v28 = v49;
      if (result) {
        goto LABEL_60;
      }
    }
    else
    {
      __memcpy_chk();
      unint64_t v26 = v64;
      __memcpy_chk();
      *(void *)(a1 + 16) = v73;
      unint64_t v28 = v49;
    }
    unint64_t v68 = ccrsa_num_mr_iterations(v28);
    uint64_t v59 = *(void *)(a1 + 16);
    unint64_t v29 = (unint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v19);
    int v56 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v19);
    unsigned int v74 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v19);
    *unint64_t v29 = v28;
    uint64_t v65 = ccn_bitlen_internal(1, v29);
    uint64_t v70 = *(void *)(a1 + 16);
    unsigned int v30 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v19);
    unsigned int v31 = &v30[8 * v26];
    if (v53 >= 0x40) {
      ccn_set(v72, v31, v63);
    }
    ccn_zero(v52, &v31[8 * v72]);
    if (v51 >= 0x40) {
      ccn_set(v57, v29, v69);
    }
    ccn_zero(v50, &v29[v57]);
    if (ccn_invmod_ws(a1, v64, v30, v64, v31, v29))
    {
      unsigned int v66 = a11;
LABEL_50:
      unsigned int v33 = v67;
      *(void *)(a1 + 16) = v70;
      unsigned int v34 = -32;
      goto LABEL_51;
    }
    ccn_sub_ws(a1, v64, v30, (uint64_t *)v29, (unint64_t *)v30);
    ccn_add_ws(a1, v64, v31, (uint64_t *)v31, (uint64_t *)v31);
    uint64_t v32 = v74;
    ccn_mul_ws(a1, v64, v74, (unint64_t *)v31, v29);
    if (v19 <= v47)
    {
      ccn_mul_ws(a1, v64, (char *)v29, (unint64_t *)v31, (unint64_t *)v30);
      ccn_add1_ws(a1, v47, v29, (uint64_t *)v29, 1);
    }
    else
    {
      ccn_zero(v43, &v74[8 * v47]);
      ccn_mul_ws(a1, v64, (char *)v29, (unint64_t *)v31, (unint64_t *)v30);
      ccn_add1_ws(a1, v47, v29, (uint64_t *)v29, 1);
      uint64_t v32 = v74;
      ccn_zero(v43, &v29[v47]);
    }
    *(void *)(a1 + 16) = v70;
    unsigned int v33 = v67;
    a3 = __s;
    if (ccn_bitlen_internal(v19, v32) <= v45 - v65)
    {
      uint64_t v35 = 0;
      unsigned int v66 = a11;
      unint64_t v18 = a9;
LABEL_27:
      uint64_t v44 = v35;
      ccn_zero(v19, a4);
      uint64_t v70 = *(void *)(a1 + 16);
      uint64_t v36 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v19);
      uint64_t v37 = 100;
      while (!ccn_random_bits_fips(v28, a4, a9))
      {
        ccn_set_bit((uint64_t)a4, v23, 1);
        ccn_shift_right_multi(v19, v36, (unint64_t *)a4, v75);
        if ((ccn_cmp_internal(4, v36, &SQRT2) & 0x80000000) == 0)
        {
          *(void *)(a1 + 16) = v70;
          if (v66)
          {
            v66 += 387 * v66[2];
            __memcpy_chk();
          }
          else
          {
            unsigned int v66 = 0;
          }
          ccn_divmod_ws(a1, v19, (uint64_t)a4, 0, 0, v19, __s, (unint64_t *)v74);
          char v71 = ccn_sub_ws(a1, v19, __s, (uint64_t *)v29, (unint64_t *)__s);
          ccn_add_ws(a1, v19, v56, (uint64_t *)v74, (uint64_t *)__s);
          ccn_mux(v19, v71, (uint64_t *)__s, v56, (uint64_t *)__s);
          uint64_t v38 = ccn_add_ws(a1, v19, __s, (uint64_t *)a4, (uint64_t *)__s);
          if (v28)
          {
            uint64_t v39 = v42;
            while (!v38 && ccn_bitlen_internal(v19, __s) <= v28)
            {
              is_valid_prime_uint64_t ws = ccrsa_is_valid_prime_ws(a1, v19, __s, a7, a8, v68, a10);
              if (is_valid_prime_ws < 0)
              {
                unsigned int v34 = -32;
                goto LABEL_47;
              }
              if (is_valid_prime_ws == 1)
              {
                unsigned int v34 = 0;
                unint64_t v25 = v48;
                uint64_t v17 = a11;
                unsigned int v33 = v67;
                goto LABEL_52;
              }
              uint64_t v38 = ccn_add_ws(a1, v19, __s, (uint64_t *)__s, (uint64_t *)v74);
              if (!--v39) {
                goto LABEL_45;
              }
            }
            uint64_t v35 = v44 + 1;
            unsigned int v34 = -30;
            unsigned int v33 = v67;
            if (v44 != 99) {
              goto LABEL_27;
            }
          }
          else
          {
LABEL_45:
            unsigned int v34 = -31;
LABEL_47:
            unsigned int v33 = v67;
          }
          goto LABEL_51;
        }
        if (!--v37) {
          goto LABEL_50;
        }
      }
      goto LABEL_50;
    }
    unsigned int v34 = -38;
    unsigned int v66 = a11;
    unint64_t v18 = a9;
LABEL_51:
    cc_clear(__n, a3);
    cc_clear(__n, a4);
    unint64_t v25 = v48;
    uint64_t v17 = a11;
LABEL_52:
    if (v66) {
      memcpy(v66 + 323, a3, __n);
    }
    *(void *)(a1 + 16) = v59;
    if (!v34) {
      break;
    }
    unsigned int v20 = v33 + 1;
  }
  while (v33 < 0x63);
  if (v33 == 99) {
    uint64_t result = 0xFFFFFFFFLL;
  }
  else {
    uint64_t result = v34;
  }
LABEL_60:
  *(void *)(a1 + 16) = v41;
  return result;
}

uint64_t ccrsa_check_delta_100bits_ws(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t *a4, uint64_t *a5, unint64_t *a6)
{
  uint64_t v12 = *(void *)(a1 + 16);
  uint64_t v13 = (uint64_t *)(*(uint64_t (**)(void))(a1 + 24))();
  uint64_t v14 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, a2);
  uint64_t v15 = ccn_bitlen_internal(a2, a3);
  ccn_zero(a2, v14);
  ccn_set_bit((uint64_t)v14, v15 - 100, 1);
  ccn_abs(a2, v13, a3, a4);
  LODWORD(a4) = ccn_cmp_internal(a2, v13, v14);
  ccn_abs(a2, v13, a5, a6);
  int v16 = ccn_cmp_internal(a2, v13, v14);
  *(void *)(a1 + 16) = v12;
  if (v16 + a4 == 2) {
    return 0;
  }
  else {
    return 4294967257;
  }
}

uint64_t ccrsa_crt_make_fips186_key_ws(uint64_t a1, unint64_t a2, uint64_t *a3, uint64_t a4, void *a5, void *a6, void *a7)
{
  uint64_t v13 = *a3;
  uint64_t v14 = ((unint64_t)*a3 >> 1) + 1;
  uint64_t v15 = (void *)ccrsa_ctx_public(a3);
  uint64_t v16 = ccn_bitlen_internal(v14, a6);
  if (ccn_bitlen_internal(v14, a7) + v16 > (unint64_t)(v13 << 6)) {
    return 4294967273;
  }
  uint64_t v26 = *(void *)(a1 + 16);
  unint64_t v18 = &v15[2 * *v15];
  unint64_t v19 = v18 + 4;
  if (a4) {
    ccn_set(a4, v18 + 4, a5);
  }
  ccn_zero(v13 - a4, &v19[a4]);
  int v20 = ccn_cmp_internal(v14, a6, a7);
  if (v20 >= 0) {
    unint64_t v21 = a7;
  }
  else {
    unint64_t v21 = a6;
  }
  if (v20 >= 0) {
    a7 = a6;
  }
  *(void *)ccrsa_ctx_private_zp(a3) = v14;
  uint64_t v22 = ccrsa_ctx_private_zp(a3);
  *(void *)(v22 + 16 * *(void *)ccrsa_ctx_private_zp(a3) + 32) = v14;
  unint64_t v23 = (void *)ccrsa_ctx_private_zp(a3);
  uint64_t v24 = ccrsa_ctx_private_zp(a3);
  uint64_t v25 = v24 + 16 * *(void *)ccrsa_ctx_private_zp(a3);
  ccn_set(v14, v23 + 3, a7);
  ccn_set(v14, (void *)(v25 + 56), v21);
  uint64_t result = cczp_init_ws(a1, v23);
  if (!result)
  {
    uint64_t result = cczp_init_ws(a1, (void *)(v25 + 32));
    if (!result)
    {
      uint64_t result = ccrsa_crt_makekey_ws(a1, a3);
      if (!result)
      {
        if (cczp_bitlen((uint64_t)v15) + 1 >= a2) {
          uint64_t result = 0;
        }
        else {
          uint64_t result = 4294967273;
        }
      }
    }
  }
  *(void *)(a1 + 16) = v26;
  return result;
}

uint64_t ccrsa_generate_fips186_key_trace(unint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t (**a5)(void, unint64_t, void *), uint64_t (**a6)(void, unint64_t, uint64_t), void *a7)
{
  unint64_t v9 = a1 + 63;
  unint64_t v10 = (a1 + 63) >> 6;
  uint64_t v11 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v12 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v13 = (v11 + v12 - 1) / v12;
  uint64_t v14 = 11 * v10 + 1;
  unint64_t v15 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(v10);
  if (v13 + v14 <= v15) {
    unint64_t v16 = v15;
  }
  else {
    unint64_t v16 = v13 + v14;
  }
  uint64_t v17 = 8 * v10 - (v9 >> 6);
  unint64_t v18 = v16 + v17;
  uint64_t v19 = (v10 & 0x3FFFFFFFFFFFFFELL) + (v9 >> 6) + 25 * v10 + 4;
  if (v18 <= v13 + v19) {
    unint64_t v18 = v13 + v19;
  }
  unint64_t v20 = v9 >> 7;
  uint64_t v21 = 3 * (v9 >> 7) + 3;
  uint64_t v22 = cc_malloc_clear(8 * (v18 + v21));
  v67[0] = v22;
  uint64_t v23 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v24 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v25 = (v23 + v24 - 1) / v24;
  unint64_t v26 = v25 + v14;
  unint64_t v60 = v10;
  unint64_t v27 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(v10);
  if (v26 <= v27) {
    unint64_t v28 = v27;
  }
  else {
    unint64_t v28 = v26;
  }
  unint64_t v29 = v28 + v17;
  if (v29 <= v25 + v19) {
    unint64_t v29 = v25 + v19;
  }
  v67[1] = v29 + v21;
  uint64_t v68 = 0;
  int v69 = cc_ws_alloc;
  uint64_t v70 = cc_ws_free;
  if (!v22) {
    return 4294967283;
  }
  if (a1 <= 0x2000)
  {
    unint64_t v31 = a1;
    *a2 = v10;
    uint64_t v32 = (uint64_t *)ccrsa_ctx_public(a2);
    if (ccn_read_uint_internal(v10, &v32[2 * *v32 + 4], a3, a4))
    {
      uint64_t v30 = 4294967268;
      cc_ws_free((uint64_t)v67);
    }
    else
    {
      uint64_t v33 = v20 + 1;
      unsigned int v66 = (char *)cc_ws_alloc(v67, v20 + 1);
      unsigned int v34 = (char *)v69(v67, v20 + 1);
      uint64_t v35 = *a2;
      uint64_t v54 = *v32;
      uint64_t v36 = (void *)v69(v67, v33);
      uint64_t v62 = v33;
      cc_clear(8 * v33, v36);
      int v56 = v36;
      unint64_t v57 = (v31 + 1) >> 1;
      ccn_set_bit((uint64_t)v36, v57, 1);
      if (v31 >= 0x200)
      {
        unint64_t v37 = (unint64_t)(a3 + 7) >> 3;
        uint64_t v38 = &v32[2 * v54 + 4];
        unint64_t v39 = v31 - ((v31 + 1) >> 1);
        uint64_t v40 = 171;
        if (v31 > 0xFFE) {
          uint64_t v40 = 201;
        }
        uint64_t v41 = 101;
        if (v31 > 0x400) {
          uint64_t v41 = 141;
        }
        uint64_t v53 = (uint64_t)&a2[3 * v35 + 4];
        unint64_t v55 = v31;
        if (v31 <= 0xBFE) {
          unint64_t v42 = v41;
        }
        else {
          unint64_t v42 = v40;
        }
        uint64_t v43 = v62;
LABEL_27:
        unint64_t v44 = ccn_bitlen_internal(v37, v38);
        uint64_t v59 = v68;
        unint64_t v45 = (void *)v69(v67, v43);
        uint64_t v46 = v69(v67, v43);
        uint64_t v30 = 4294967268;
        if ((*(unsigned char *)v38 & 1) != 0 && v44 >= 0x11 && v44 <= 0xFF)
        {
          unint64_t v47 = (void *)v46;
          if (a7)
          {
            cc_clear(0x1830uLL, a7);
            a7[389] = 0;
            a7[2] = 0;
          }
          probable_prime_uint64_t ws = ccrsa_generate_probable_prime_ws((uint64_t)v67, v57, v66, v45, v42, v42, v37, v38, a5, a6, a7);
          if (!probable_prime_ws)
          {
            unint64_t v49 = 0;
            while (1)
            {
              if (a7)
              {
                a7[389] = 1;
                a7[2] = 1;
              }
              probable_prime_uint64_t ws = ccrsa_generate_probable_prime_ws((uint64_t)v67, v39, v34, v47, v42, v42, v37, v38, a5, a6, a7);
              if (probable_prime_ws) {
                break;
              }
              uint64_t v50 = ccrsa_check_delta_100bits_ws((uint64_t)v67, v62, (uint64_t *)v66, (unint64_t *)v34, (uint64_t *)v45, (unint64_t *)v47);
              uint64_t v30 = v50;
              if (v49 <= 0x62)
              {
                ++v49;
                if (v50 == -39) {
                  continue;
                }
              }
              uint64_t v68 = v59;
              uint64_t v43 = v62;
              if (v50) {
                goto LABEL_46;
              }
              probable_prime_uint64_t ws = ccrsa_crt_make_fips186_key_ws((uint64_t)v67, v55, a2, v37, v38, v66, v34);
              if (probable_prime_ws) {
                break;
              }
              if ((int)ccn_cmpn_internal(v60, v53, v62, v56) < 1) {
                goto LABEL_27;
              }
              ccrsa_pairwise_consistency_check_ws((uint64_t)v67, a2, (uint64_t (**)(void, uint64_t, uint64_t))a5);
              if (v51) {
                uint64_t v30 = 4294967259;
              }
              else {
                uint64_t v30 = 0;
              }
              goto LABEL_46;
            }
          }
          uint64_t v30 = probable_prime_ws;
        }
      }
      else
      {
        uint64_t v30 = 4294967268;
      }
LABEL_46:
      uint64_t v68 = 0;
      v70((uint64_t)v67);
    }
  }
  else
  {
    uint64_t v30 = 4294967273;
    cc_ws_free((uint64_t)v67);
  }
  return v30;
}

uint64_t ccrsa_generate_fips186_key(unint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t (**a5)(void, unint64_t, void *), uint64_t (**a6)(void, unint64_t, uint64_t))
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t fips186_key_trace = ccrsa_generate_fips186_key_trace(a1, a2, a3, a4, a5, a6, 0);
  cc_try_abort_if (fips186_key_trace == -37);
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return fips186_key_trace;
}

uint64_t ccrsa_find_next_prime_ws(uint64_t a1, unint64_t a2, unint64_t *a3, uint64_t (**a4)(void, unint64_t, uint64_t))
{
  unint64_t v7 = (a2 + 63) >> 6;
  unint64_t v8 = ccrsa_num_mr_iterations_aux(a2);
  unint64_t v9 = ccn_sub1(v7, a3, a3, 2uLL);
  if (v9) {
    return 4294967262;
  }
  *a3 |= 1uLL;
  uint64_t v11 = *(void *)(a1 + 16);
  while (!v9)
  {
    if (!ccn_add1_ws(a1, v7, a3, (uint64_t *)a3, 2))
    {
      LODWORD(v9) = ccprime_rabin_miller_ws(a1, v7, a3, v8, a4);
      if (v9 < 2) {
        continue;
      }
    }
    uint64_t result = 4294967262;
    goto LABEL_9;
  }
  uint64_t result = 0;
LABEL_9:
  *(void *)(a1 + 16) = v11;
  return result;
}

uint64_t ccrsa_sign_pss_blinded(uint64_t (**a1)(void, uint64_t, uint64_t), uint64_t *a2, uint64_t *a3, uint64_t a4, unint64_t a5, uint64_t (**a6)(void, unint64_t, char *), size_t a7, char *a8, unint64_t *a9, char *a10)
{
  uint64_t v54 = *MEMORY[0x263EF8C08];
  unint64_t v16 = *a2;
  uint64_t v17 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v18 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v19 = (v17 + v18 - 1) / v18 + 11 * v16;
  unint64_t v20 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(v16);
  if (v19 + 1 > v20) {
    unint64_t v21 = v19 + 1;
  }
  else {
    unint64_t v21 = v20;
  }
  uint64_t v22 = cc_malloc_clear(8 * (v21 + 3 * v16));
  v48[0] = v22;
  unint64_t v23 = *a2;
  uint64_t v24 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v25 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v26 = (v24 + v25 - 1) / v25 + 11 * v23;
  unint64_t v27 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(v23);
  if (v26 + 1 > v27) {
    unint64_t v28 = v26 + 1;
  }
  else {
    unint64_t v28 = v27;
  }
  v48[1] = v28 + 3 * v23;
  uint64_t v49 = 0;
  uint64_t v50 = cc_ws_alloc;
  int v51 = cc_ws_free;
  if (!v22) {
    return 4294967283;
  }
  uint64_t v29 = cczp_bitlen((uint64_t)a2);
  if (v29 == 1024)
  {
    uint64_t v30 = *a3;
    BOOL v32 = a7 - 2 < a5 && v30 == 512;
    uint64_t v33 = 4294967273;
    if (a5 > a7 || v32) {
      goto LABEL_24;
    }
  }
  else
  {
    if (a5 > a7)
    {
LABEL_23:
      uint64_t v33 = 4294967273;
LABEL_24:
      cc_ws_free((uint64_t)v48);
      return v33;
    }
    uint64_t v30 = *a3;
  }
  if (v30 != a7) {
    goto LABEL_23;
  }
  unint64_t v34 = (unint64_t)(v29 + 7) >> 3;
  if (*a9 < v34) {
    goto LABEL_23;
  }
  unint64_t v36 = (unint64_t)(v29 + 6) >> 3;
  *a9 = v34;
  unint64_t v45 = v29 - 1;
  if (a5)
  {
    unint64_t v37 = *a6;
    if (a5 > 0xB)
    {
      unsigned int v38 = v37(a6, a5, v52);
    }
    else
    {
      unsigned int v38 = v37(a6, 12uLL, __s);
      __memcpy_chk();
      cc_clear(a5, __s);
    }
    uint64_t v44 = v49;
    unint64_t v39 = v50;
  }
  else
  {
    unint64_t v39 = cc_ws_alloc;
    uint64_t v44 = 0;
    unsigned int v38 = 0;
  }
  unint64_t v40 = *a2;
  uint64_t v41 = (unint64_t *)v39(v48, *a2);
  v41[v40 - 1] = 0;
  *uint64_t v41 = 0;
  int v42 = ccrsa_emsa_pss_encode_internal((uint64_t)a3, a4, a5, v52, a7, a8, v45, (unsigned char *)v41 + 8 * v40 - v36);
  ccn_swap(v40, v41);
  unsigned int v43 = ccrsa_priv_crypt_blinded_ws((uint64_t)v48, a1, a2, (uint64_t *)v41, v41) | v42;
  if (v43 | v38)
  {
    cc_clear(8 * v40, v41);
    if (v38) {
      uint64_t v33 = v38;
    }
    else {
      uint64_t v33 = v43;
    }
  }
  else
  {
    ccn_write_uint_padded_ct_internal(v40, v41, *a9, a10);
    uint64_t v33 = 0;
  }
  uint64_t v49 = v44;
  v51((uint64_t)v48);
  return v33;
}

uint64_t fipspost_post_hkdf(char a1)
{
  uint64_t v44 = *MEMORY[0x263EF8C08];
  unint64_t v2 = ccsha1_di();
  uint64_t v3 = ccsha256_di();
  uint64_t v4 = ccsha512_di();
  BOOL v5 = ccsha3_224_di();
  unint64_t v6 = ccsha3_256_di();
  unint64_t v7 = ccsha3_384_di();
  unint64_t v8 = ccsha3_512_di();
  memset(v43, 0, sizeof(v43));
  long long v42 = 0uLL;
  uint64_t v41 = 0;
  memset(v40, 0, sizeof(v40));
  if ((a1 & 0x10) != 0) {
    LOBYTE(v43[0]) = 1;
  }
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  v13[0] = v2;
  v13[1] = "sha1";
  long long v14 = xmmword_2373BB6E8;
  long long v15 = unk_2373BB6F8;
  unint64_t v16 = v3;
  uint64_t v17 = "sha256";
  long long v18 = xmmword_2373BB708;
  long long v19 = unk_2373BB718;
  unint64_t v20 = v4;
  unint64_t v21 = "sha512";
  long long v22 = xmmword_2373BB728;
  long long v23 = unk_2373BB738;
  uint64_t v24 = v5;
  unint64_t v25 = "sha3_224";
  long long v26 = xmmword_2373BB748;
  long long v27 = unk_2373BB758;
  unint64_t v28 = v6;
  uint64_t v29 = "sha3_256";
  long long v30 = xmmword_2373BB768;
  long long v31 = unk_2373BB778;
  BOOL v32 = v7;
  uint64_t v33 = "sha3_384";
  long long v34 = xmmword_2373BB788;
  long long v35 = unk_2373BB798;
  unint64_t v36 = v8;
  unint64_t v37 = "sha3_512";
  long long v38 = xmmword_2373BB7A8;
  long long v39 = unk_2373BB7B8;
  do
  {
    cchkdf((rsize_t *)v13[v9], 32, (uint64_t)v43, 16, &v42, 8, (uint64_t)&v41, 32, (uint64_t)v40);
    if (cc_cmp_safe(32, (char *)v40, (char *)&v13[v9 + 2]))
    {
      uint64_t v11 = mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: HKDF with digest %s\n", v11, "fipspost_post_hkdf", 86, (const char *)v13[v9 + 1]);
      uint64_t v10 = 4294967221;
    }
    v9 += 6;
  }
  while (v9 != 42);
  return v10;
}

uint64_t ccn_cond_swap(uint64_t a1, char a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t result = ccn_mux_next_mask();
  for (uint64_t i = __ROR8__(0x5555555555555555, a2 | (2 * result)); a1; --a1)
  {
    uint64_t v10 = *a4 ^ *a3;
    *a3 ^= result;
    uint64_t v11 = *a4 ^ result;
    *a4 = v11;
    uint64_t v12 = *a3 ^ v10 & 0x5555555555555555;
    uint64_t v13 = v11 ^ v10 & 0x5555555555555555;
    uint64_t v14 = v10 & i;
    *a3++ = v12 ^ v14 ^ result;
    *a4++ = v13 ^ v14 ^ result;
  }
  return result;
}

uint64_t cccmac_sl_test_xor(uint64_t result, char *a2)
{
  LOBYTE(v2) = 0;
  unsigned int v3 = *a2;
  for (uint64_t i = 15; i != -1; --i)
  {
    unsigned int v5 = a2[i];
    *(unsigned char *)(result + i) = v2 | (2 * v5);
    unsigned int v2 = v5 >> 7;
  }
  *(unsigned char *)(result + 15) ^= (v3 >> 7) & 0x87;
  return result;
}

uint64_t cccmac_generate_subkeys(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  _OWORD v17[2] = *MEMORY[0x263EF8C08];
  v17[0] = 0;
  v17[1] = 0;
  __s[0] = 0;
  __s[1] = 0;
  uint64_t result = cccbc_one_shot_explicit_internal(a1, a2, 16, *(void *)(a1 + 8), 1, a3, v17, (uint64_t)__s, (uint64_t)__s);
  if (!result)
  {
    LOBYTE(v8) = 0;
    unsigned int v9 = SLOBYTE(__s[0]);
    for (uint64_t i = 15; i != -1; --i)
    {
      unsigned int v11 = *((unsigned __int8 *)__s + i);
      a4[i] = v8 | (2 * v11);
      unsigned int v8 = v11 >> 7;
    }
    LOBYTE(v12) = 0;
    a4[15] ^= (v9 >> 7) & 0x87;
    unsigned int v13 = *a4;
    for (uint64_t j = 15; j != -1; --j)
    {
      unsigned int v15 = a4[j];
      *(unsigned char *)(a5 + j) = v12 | (2 * v15);
      unsigned int v12 = v15 >> 7;
    }
    *(unsigned char *)(a5 + 15) ^= (v13 >> 7) & 0x87;
    cc_clear(0x10uLL, __s);
    return 0;
  }
  return result;
}

uint64_t ccec_affine_point_from_x_ws(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *a2;
  uint64_t v8 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, void))(a1 + 24))(a1, *a2);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v7);
  if ((ccn_cmp_internal(*a2, a4, a2 + 3) & 0x80000000) != 0)
  {
    cczp_to_ws(a1, (uint64_t)a2);
    cczp_sqr_ws(a1, (uint64_t)a2);
    cczp_mul_ws(a1, (uint64_t)a2);
    cczp_add_ws(a1, (uint64_t)a2);
    cczp_add_ws(a1, (uint64_t)a2);
    cczp_sub_ws(a1, (uint64_t)a2);
    cczp_add_ws(a1, (uint64_t)a2);
    uint64_t result = cczp_sqrt_ws(a1, (uint64_t)a2);
    if (!result)
    {
      cczp_from_ws(a1, (uint64_t)a2);
      cczp_from_ws(a1, (uint64_t)a2);
      uint64_t result = 0;
    }
  }
  else
  {
    uint64_t result = 4294967289;
  }
  *(void *)(a1 + 16) = v8;
  return result;
}

uint64_t cczp_generate_random_element_ws(uint64_t a1, void *a2, uint64_t (**a3)(void, unint64_t, uint64_t), uint64_t *a4)
{
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = cczp_n((uint64_t)a2);
  uint64_t v10 = cczp_bitlen((uint64_t)a2);
  unsigned int v11 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v9 + 1);
  uint64_t v12 = ccn_random_bits(v10 + 64, (uint64_t)v11, a3);
  if (!v12) {
    cczp_modn_ws(a1, a2, a4, (unint64_t)(v10 + 127) >> 6, v11);
  }
  *(void *)(a1 + 16) = v8;
  return v12;
}

const char *fips_allowed_mode_(const char *result, uint64_t a2)
{
  if (result)
  {
    unsigned int v3 = result;
    if (strcmp(result, "ccaes_ctr_crypt_mode")
      && strcmp(v3, "ccaes_ecb_encrypt_mode")
      && strcmp(v3, "ccaes_ecb_decrypt_mode")
      && strcmp(v3, "ccaes_cbc_encrypt_mode")
      && strcmp(v3, "ccaes_cbc_decrypt_mode")
      && strcmp(v3, "ccaes_ccm_encrypt_mode")
      && strcmp(v3, "ccaes_ccm_decrypt_mode")
      && strcmp(v3, "ccaes_cfb_encrypt_mode")
      && strcmp(v3, "ccaes_cfb_decrypt_mode")
      && strcmp(v3, "ccaes_cfb8_encrypt_mode")
      && strcmp(v3, "ccaes_cfb8_decrypt_mode")
      && strcmp(v3, "ccaes_ofb_crypt_mode")
      && strcmp(v3, "ccwrap_auth_encrypt_withiv")
      && strcmp(v3, "ccwrap_auth_decrypt_withiv")
      && strcmp(v3, "ccaes_gcm_encrypt_mode")
      && strcmp(v3, "ccaes_gcm_decrypt_mode"))
    {
      if (!strcmp(v3, "ccaes_xts_encrypt_mode") || !strcmp(v3, "ccaes_xts_decrypt_mode")) {
        return (const char *)(a2 == 16 || a2 == 32);
      }
      if (strcmp(v3, "ccpad_cts1_encrypt")
        && strcmp(v3, "ccpad_cts1_decrypt")
        && strcmp(v3, "ccpad_cts2_encrypt")
        && strcmp(v3, "ccpad_cts2_decrypt")
        && strcmp(v3, "ccpad_cts3_encrypt")
        && strcmp(v3, "ccpad_cts3_decrypt"))
      {
        return 0;
      }
    }
    return (const char *)(a2 == 32 || (a2 & 0xFFFFFFFFFFFFFFF7) == 16);
  }
  return result;
}

BOOL fips_allowed(char *__s1, const char *a2)
{
  if (!a2)
  {
    if (__s1)
    {
      int v43 = strcmp(__s1, "fipspost_post_integrity");
      int v42 = strcmp(__s1, "ccsha1_di");
      int v41 = strcmp(__s1, "ccsha224_di");
      int v40 = strcmp(__s1, "ccsha256_di");
      int v39 = strcmp(__s1, "ccsha384_di");
      int v38 = strcmp(__s1, "ccsha512_di");
      int v37 = strcmp(__s1, "ccsha512_256_di");
      int v36 = strcmp(__s1, "ccsha3_224_di");
      int v5 = strcmp(__s1, "ccsha3_256_di");
      int v6 = strcmp(__s1, "ccsha3_384_di");
      int v7 = strcmp(__s1, "ccsha3_512_di");
      int v8 = strcmp(__s1, "ccshake128_xi");
      int v9 = strcmp(__s1, "ccshake256_xi");
      int v10 = strcmp(__s1, "ccdh_gp_rfc3526group14");
      int v11 = strcmp(__s1, "ccdh_gp_rfc3526group15");
      int v12 = strcmp(__s1, "ccdh_gp_rfc3526group16");
      int v13 = strcmp(__s1, "ccdh_gp_rfc3526group17");
      int v14 = strcmp(__s1, "ccdh_gp_rfc3526group18");
      if (v43) {
        BOOL v15 = v42 == 0;
      }
      else {
        BOOL v15 = 1;
      }
      return v15
          || v41 == 0
          || v40 == 0
          || v39 == 0
          || v38 == 0
          || v37 == 0
          || v36 == 0
          || v5 == 0
          || v6 == 0
          || v7 == 0
          || v8 == 0
          || v9 == 0
          || v10 == 0
          || v11 == 0
          || v12 == 0
          || v13 == 0
          || v14 == 0;
    }
    return 0;
  }
  if (!__s1) {
    return 0;
  }
  if (!strcmp(__s1, "ccec_generate_key_fips")
    || !strcmp(__s1, "ccec_sign_msg")
    || !strcmp(__s1, "ccec_make_priv")
    || !strcmp(__s1, "ccec_make_pub"))
  {
    BOOL v4 = !strcmp(a2, "ccec_cp_224")
      || !strcmp(a2, "ccec_cp_256")
      || !strcmp(a2, "ccec_cp_384")
      || strcmp(a2, "ccec_cp_521") == 0;
  }
  else
  {
    BOOL v4 = 0;
  }
  if (!strcmp(__s1, "ccec_verify_msg") || !strcmp(__s1, "ccec_validate_pub")) {
    BOOL v4 = !strcmp(a2, "ccec_cp_192")
  }
      || !strcmp(a2, "ccec_cp_224")
      || !strcmp(a2, "ccec_cp_256")
      || !strcmp(a2, "ccec_cp_384")
      || strcmp(a2, "ccec_cp_521") == 0;
  if (!strcmp(__s1, "cchmac")) {
    BOOL v4 = !strcmp(a2, "ccsha1_di")
  }
      || !strcmp(a2, "ccsha224_di")
      || !strcmp(a2, "ccsha256_di")
      || !strcmp(a2, "ccsha384_di")
      || !strcmp(a2, "ccsha512_di")
      || !strcmp(a2, "ccsha512_256_di")
      || !strcmp(a2, "ccsha3_224_di")
      || !strcmp(a2, "ccsha3_256_di")
      || !strcmp(a2, "ccsha3_384_di")
      || strcmp(a2, "ccsha3_512_di") == 0;
  if (!strcmp(__s1, "ccecdh_compute_shared_secret") || !strcmp(__s1, "ccecdh_generate_key")) {
    BOOL v4 = !strcmp(a2, "ccec_cp_224")
  }
      || !strcmp(a2, "ccec_cp_256")
      || !strcmp(a2, "ccec_cp_384")
      || strcmp(a2, "ccec_cp_521") == 0;
  if (!strcmp(__s1, "ccdh_generate_key")
    || !strcmp(__s1, "ccdh_import_pub")
    || !strcmp(__s1, "ccdh_import_priv")
    || !strcmp(__s1, "ccdh_compute_shared_secret"))
  {
    BOOL v4 = !strcmp(a2, "2048")
      || !strcmp(a2, "3072")
      || !strcmp(a2, "4096")
      || !strcmp(a2, "6144")
      || strcmp(a2, "8192") == 0;
  }
  if (!strcmp(__s1, "ccnistkdf_ctr_hmac") || !strcmp(__s1, "ccnistkdf_ctr_hmac_fixed")) {
    BOOL v4 = !strcmp(a2, "ccsha1_di")
  }
      || !strcmp(a2, "ccsha224_di")
      || !strcmp(a2, "ccsha256_di")
      || !strcmp(a2, "ccsha384_di")
      || !strcmp(a2, "ccsha512_di")
      || !strcmp(a2, "ccsha512_256_di")
      || !strcmp(a2, "ccsha3_224_di")
      || !strcmp(a2, "ccsha3_256_di")
      || !strcmp(a2, "ccsha3_384_di")
      || strcmp(a2, "ccsha3_512_di") == 0;
  if (!strcmp(__s1, "cchkdf")) {
    BOOL v4 = !strcmp(a2, "ccsha1_di")
  }
      || !strcmp(a2, "ccsha224_di")
      || !strcmp(a2, "ccsha256_di")
      || !strcmp(a2, "ccsha384_di")
      || !strcmp(a2, "ccsha512_di")
      || !strcmp(a2, "ccsha512_256_di")
      || !strcmp(a2, "ccsha3_224_di")
      || !strcmp(a2, "ccsha3_256_di")
      || !strcmp(a2, "ccsha3_384_di")
      || strcmp(a2, "ccsha3_512_di") == 0;
  if (!strcmp(__s1, "ccpbkdf2_hmac")) {
    BOOL v4 = !strcmp(a2, "ccsha1_di")
  }
      || !strcmp(a2, "ccsha224_di")
      || !strcmp(a2, "ccsha256_di")
      || !strcmp(a2, "ccsha384_di")
      || !strcmp(a2, "ccsha512_di")
      || !strcmp(a2, "ccsha512_256_di")
      || !strcmp(a2, "ccsha3_224_di")
      || !strcmp(a2, "ccsha3_256_di")
      || !strcmp(a2, "ccsha3_384_di")
      || strcmp(a2, "ccsha3_512_di") == 0;
  if (!strcmp(__s1, "ccnistkdf_ctr_cmac") || !strcmp(__s1, "ccnistkdf_ctr_cmac_fixed"))
  {
    unint64_t v34 = strtoul(a2, 0, 10);
    return v34 == 32 || (v34 & 0xFFFFFFFFFFFFFFF7) == 16;
  }
  if (!strcmp(__s1, "ccrsa_generate_fips186_key")
    || !strcmp(__s1, "ccrsa_sign_pss_msg")
    || !strcmp(__s1, "ccrsa_sign_pkcs1v15_msg"))
  {
    BOOL v4 = strtoul(a2, 0, 10) > 0x7FF;
  }
  if (!strcmp(__s1, "ccrsa_verify_pss_msg") || !strcmp(__s1, "ccrsa_verify_pkcs1v15_msg"))
  {
    unint64_t v32 = strtoul(a2, 0, 10);
    return v32 == 1024 || v32 > 0x7FF;
  }
  return v4;
}

BOOL fips_allowed_drbg_(const char *a1, const char *a2, const char *a3)
{
  BOOL v3 = 0;
  if (a1 && a2 && a3)
  {
    if (!strcmp(a1, "ccdrbg_init")
      || !strcmp(a1, "ccdrbg_reseed")
      || !strcmp(a1, "ccdrbg_generate")
      || !strcmp(a1, "ccdrbg_done"))
    {
      if (!strcmp(a2, "ccdrbg_factory_nisthmac")) {
        BOOL v3 = !strcmp(a3, "ccsha1_di") || !strcmp(a3, "ccsha256_di") || strcmp(a3, "ccsha512_di") == 0;
      }
      else {
        BOOL v3 = 0;
      }
      if (!strcmp(a2, "ccdrbg_factory_nistctr")) {
        return !strcmp(a3, "CCAES_KEY_SIZE_128") || strcmp(a3, "CCAES_KEY_SIZE_256") == 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

uint64_t ccn_divmod_ws(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, char *a7, unint64_t *a8)
{
  v63[2] = *MEMORY[0x263EF8C08];
  unint64_t v12 = ccn_n(a6, (uint64_t)a8);
  unint64_t v13 = a2 - v12;
  uint64_t v48 = *(void *)(a1 + 16);
  uint64_t v14 = v12 + 1;
  BOOL v15 = (unint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v12 + 1);
  unint64_t v16 = (unint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v12 + 1);
  uint64_t v57 = a1;
  uint64_t v17 = (unint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v12 + 1);
  v15[v12] = 0;
  unint64_t v55 = v12 - 1;
  unint64_t v18 = __clz(a8[v12 - 1]);
  ccn_shift_left(v12, v15, a8, v18);
  int v19 = -(int)v18;
  unint64_t v58 = v18;
  unint64_t v20 = v18 + 0xFFFFFFFF;
  if (v12) {
    ccn_set(v12, v16, (void *)(a3 + 8 * v13));
  }
  uint64_t v51 = -(uint64_t)HIDWORD(v20);
  char v52 = v19 & 0x3F;
  ccn_zero(1, &v16[v12]);
  ccn_shift_left(v14, v16, v16, v58);
  unint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  unint64_t v24 = v15[v55];
  uint64_t v25 = -(uint64_t)v24;
  unint64_t v27 = (unsigned __int128)-(__int128)__PAIR128__(v26, v24) >> 64;
  uint64_t v28 = 65;
  unint64_t v29 = v24;
  do
  {
    unsigned long long v30 = __PAIR128__(v27, v25) - __PAIR128__(v29, v21);
    unint64_t v31 = (unint64_t)((__PAIR128__(v27, v25) - __PAIR128__(v29, v21)) >> 64) >> 63;
    uint64_t v32 = v27 & ((uint64_t)((__PAIR128__(v27, v25) - __PAIR128__(v29, v21)) >> 64) >> 63);
    uint64_t v25 = (v31 - 1) & v30 | v25 & (*((uint64_t *)&v30 + 1) >> 63);
    *((void *)&v33 + 1) = v23;
    *(void *)&long long v33 = v22;
    uint64_t v23 = v33 >> 63;
    *((void *)&v33 + 1) = v22;
    *(void *)&long long v33 = *((void *)&v30 + 1);
    unint64_t v27 = (v31 != 0 ? 0 : *((void *)&v30 + 1)) | v32;
    uint64_t v22 = (v33 >> 63) ^ 1;
    *((void *)&v33 + 1) = v29;
    *(void *)&long long v33 = v21;
    unint64_t v21 = v33 >> 1;
    v29 >>= 1;
    --v28;
  }
  while (v28);
  unint64_t v54 = (v22 + 2) | ((((HIDWORD(v15[v55]) ^ 0x80000000 | v15[v55]) + 0xFFFFFFFF) >> 32) - 1);
  size_t v50 = 8 * v12;
  uint64_t v56 = v12;
  unint64_t v34 = (void *)(a3 - 8 * v12 + 8 * a2);
  unint64_t v35 = v13;
  do
  {
    unint64_t v36 = v13;
    unint64_t v37 = *v34 << v58;
    *unint64_t v16 = v37;
    if (v35) {
      *unint64_t v16 = ((*(v34 - 1) & (unint64_t)v51) >> v52) | v37;
    }
    unint64_t v38 = v16[v56];
    uint64_t v39 = v16[v55];
    unint64_t v61 = v15[v55];
    unint64_t v40 = ((__PAIR128__(v38, v39) - v61) >> 64) + ((v38 * (unsigned __int128)v54) >> 64) + 2;
    if (v40 < v38) {
      unint64_t v40 = -1;
    }
    unint64_t v60 = v40;
    ccn_mul(1uLL, (char *)v63, &v60, &v61);
    v62[0] = v39;
    v62[1] = v38;
    uint64_t v41 = ccn_sub_ws(0, 2, v63, v62, (unint64_t *)v63);
    v60 -= 2 * v41;
    BOOL v42 = ccn_add1_ws(0, 2, v63, v63, v61);
    uint64_t v43 = v60 + v42;
    v17[v56] = ccn_mul1(v56, v17, v15, v60 + v42);
    uint64_t v44 = ccn_sub_ws(v57, v14, v16, (uint64_t *)v16, v17);
    uint64_t v45 = v44 - ccn_cond_add(v14, v44, (uint64_t *)v16, (uint64_t *)v16, (uint64_t *)v15);
    uint64_t result = ccn_cond_add(v14, v45, (uint64_t *)v16, (uint64_t *)v16, (uint64_t *)v15);
    if (a5 && v35 < a4) {
      *(void *)(a5 + 8 * v35) = v43 - (v44 + v45);
    }
    if (v35) {
      uint64_t result = (uint64_t)memmove(v16 + 1, v16, v50);
    }
    --v35;
    --v34;
    unint64_t v13 = v36;
  }
  while (v35 <= v36);
  if (a5 && a4 > v36 + 1) {
    uint64_t result = cc_clear(8 * (a4 - (v36 + 1)), (void *)(a5 + 8 * (v36 + 1)));
  }
  if (a7)
  {
    ccn_shift_right(v56, (uint64_t)v16, v16, v58);
    if (v56) {
      ccn_set(v56, a7, v16);
    }
    uint64_t result = ccn_zero(a6 - v56, &a7[8 * v56]);
  }
  *(void *)(v57 + 16) = v48;
  return result;
}

void *ccckg2_params_p224_sha256_v2()
{
  return &_ccckg2_params_p224_sha256_v2;
}

uint64_t ccckg2_ctx_cp(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t ccckg2_ctx_di(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

unint64_t ccckg2_sizeof_ctx(uint64_t a1)
{
  unsigned int v2 = (uint64_t *)(*(uint64_t (**)(void))(a1 + 8))();
  BOOL v3 = (void *)(*(uint64_t (**)(void))(a1 + 16))();
  uint64_t v4 = *v2;
  unint64_t v5 = ((((unint64_t)(cczp_bitlen((uint64_t)v2) + 7) >> 2) & 0x3FFFFFFFFFFFFFFELL) + 16 * v4) | 1;
  if (v5 <= ((*v3 + 7) & 0xFFFFFFFFFFFFFFF8) + 16 * *v2) {
    unint64_t v5 = ((*v3 + 7) & 0xFFFFFFFFFFFFFFF8) + 16 * *v2;
  }
  return v5 + 40;
}

uint64_t ccckg2_sizeof_commitment(uint64_t a1)
{
  return *(void *)(*(uint64_t (**)(void))(a1 + 16))();
}

unint64_t ccckg2_sizeof_share(uint64_t a1)
{
  uint64_t v1 = (*(uint64_t (**)(void))(a1 + 8))();
  return ((unint64_t)(cczp_bitlen(v1) + 7) >> 1) & 0x7FFFFFFFFFFFFFFCLL | 2;
}

unint64_t ccckg2_sizeof_opening(uint64_t a1)
{
  uint64_t v1 = (void *)(*(uint64_t (**)(void))(a1 + 8))();
  unint64_t v2 = cczp_bitlen((uint64_t)&v1[5 * *v1 + 4]) + 7;
  return (((unint64_t)(cczp_bitlen((uint64_t)v1) + 7) >> 2) | 1) + (v2 >> 3);
}

uint64_t ccckg2_init(_DWORD *a1, uint64_t a2)
{
  if (*(_DWORD *)a2 != 2) {
    return 4294967289;
  }
  rsize_t v4 = ccckg2_sizeof_ctx(a2);
  uint64_t v5 = cc_clear(v4, a1);
  *a1 = *(_DWORD *)a2;
  *((void *)a1 + 1) = (*(uint64_t (**)(uint64_t))(a2 + 8))(v5);
  uint64_t v6 = (*(uint64_t (**)(void))(a2 + 16))();
  uint64_t result = 0;
  *((void *)a1 + 2) = v6;
  *((unsigned char *)a1 + 32) = 0;
  return result;
}

uint64_t ccckg2_derive_sk_ws(uint64_t a1, uint64_t a2, unsigned char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t (**a7)(void, uint64_t, unint64_t *))
{
  uint64_t v28 = *MEMORY[0x263EF8C08];
  if (*a3 != 4) {
    return 4294967289;
  }
  unint64_t v12 = *(uint64_t **)(a2 + 8);
  unint64_t v21 = *(unint64_t **)(a2 + 16);
  unint64_t v13 = *v12;
  uint64_t v24 = *(void *)(a1 + 16);
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 3 * *v12);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 3 * v13);
  unint64_t v16 = (uint64_t **)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, (24 * v13 + 23) >> 3);
  *unint64_t v16 = v12;
  uint64_t v17 = cczp_bitlen((uint64_t)v12);
  uint64_t result = ccec_raw_import_pub(v12, ((unint64_t)(v17 + 7) >> 2) & 0x3FFFFFFFFFFFFFFELL, a3 + 1, v16);
  if (!result)
  {
    uint64_t result = ccec_validate_point_and_projectify_ws(a1, v12, v14, (uint64_t)(v16 + 2));
    if (!result)
    {
      uint64_t result = ccec_mult_blinded_ws(a1, (unint64_t *)v12, v15, a2 + 8 * **(void **)(a2 + 8) + 40, v14, a7);
      if (!result)
      {
        uint64_t result = ccec_affinify_ws(a1, (uint64_t)v12);
        if (!result)
        {
          uint64_t v19 = cczp_bitlen((uint64_t)v12);
          ccn_write_uint_padded_internal(v13, (unint64_t *)(a4 + 16), (unint64_t)(v19 + 7) >> 3, v27);
          uint64_t result = ccec_export_pub((uint64_t *)v16, v26);
          if (!result)
          {
            v25[0] = v26;
            v25[1] = ((unint64_t)(cczp_bitlen((uint64_t)v12) + 7) >> 2) | 1;
            uint64_t v20 = cczp_bitlen((uint64_t)v12);
            uint64_t result = ccansikdf_x963_iovec(v21, (unint64_t)(v20 + 7) >> 3, v27, 1, (uint64_t)v25, a5, a6);
          }
        }
      }
    }
  }
  *(void *)(a1 + 16) = v24;
  return result;
}

uint64_t ccckg2_derive_sk(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, char *a5, uint64_t (**a6)(void, uint64_t, unint64_t *))
{
  unint64_t v12 = *(uint64_t **)(a1 + 8);
  uint64_t v13 = *v12;
  uint64_t v14 = sizeof_struct_cche_galois_key();
  unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
  v21[0] = cc_malloc_clear(8 * ((v14 + v15 + 3 * v13 * v15 - 1) / v15 + 29 * v13));
  uint64_t v16 = *v12;
  uint64_t v17 = sizeof_struct_cche_galois_key();
  unint64_t v18 = sizeof_struct_ccpolyzp_po2cyc();
  v21[1] = (v17 + v18 + 3 * v16 * v18 - 1) / v18 + 29 * v16;
  unsigned int v21[2] = 0;
  v21[3] = cc_ws_alloc;
  uint64_t v22 = cc_ws_free;
  if (!v21[0]) {
    return 4294967283;
  }
  uint64_t v19 = ccckg2_derive_sk_ws((uint64_t)v21, a1, a2, a3, a4, a5, a6);
  v22((uint64_t)v21);
  return v19;
}

uint64_t ccecies_export_eph_pub(char a1, uint64_t *a2, char *a3)
{
  if ((a1 & 2) != 0) {
    return ccec_export_pub(a2, a3);
  }
  if ((a1 & 4) != 0) {
    return ccec_compact_export_pub(a3, a2);
  }
  return 4294967289;
}

uint64_t ccn_cmpn_public_value(unint64_t a1, uint64_t *a2, unint64_t a3, uint64_t *a4)
{
  if (a1 >= a3) {
    uint64_t v4 = a3;
  }
  else {
    uint64_t v4 = a1;
  }
  if (a1 >= a3) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = a4;
  }
  if (a1 <= a3) {
    unint64_t v6 = a3;
  }
  else {
    unint64_t v6 = a1;
  }
  if (a1 < a3) {
    unsigned int v7 = -1;
  }
  else {
    unsigned int v7 = 1;
  }
  unsigned int v8 = ccn_cmp_public_value(v4, a2, a4);
  if (ccn_n(v6 - v4, (uint64_t)&v5[v4])) {
    return v7;
  }
  else {
    return v8;
  }
}

uint64_t ccn_cmpn(unint64_t a1, uint64_t *a2, unint64_t a3, uint64_t *a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = ccn_cmpn_public_value(a1, a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t cche_decrypt_ctx_nof_n(unsigned int *a1)
{
  unint64_t v2 = sizeof_struct_ccpolyzp_po2cyc() + 7;
  uint64_t v3 = *a1;
  uint64_t v4 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v5 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v6 = (v5 - 1 + v4) / v5;
  unint64_t v7 = sizeof_struct_ccpolyzp_po2cyc_ctx() + 7;
  if (v3 >= 0x80) {
    uint64_t v8 = 128;
  }
  else {
    uint64_t v8 = v3;
  }
  unint64_t v9 = (unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3;
  uint64_t v10 = v6 + (v2 >> 3) + 2 * (v7 >> 3) + 4 * (v3 + v9 * v8) + 12;
  if (a1[1] <= 1) {
    unsigned int v11 = 1;
  }
  else {
    unsigned int v11 = a1[1];
  }
  uint64_t v12 = sizeof_struct_ccpolyzp_po2cyc_base_convert();
  unsigned int v13 = 1;
  unsigned int v14 = 2;
  do
  {
    v10 += v13 + (v14 + (unint64_t)v13 + 2 * (v13 - 1)) * v9 + (v5 - 1 + v12) / v5;
    ++v13;
    v14 += 2;
  }
  while (v13 <= v11);
  return v10;
}

unint64_t CCHE_DECRYPT_CTX_INIT_WORKSPACE_N(unsigned int a1)
{
  unint64_t v2 = CCPOLYZP_PO2CYC_CTX_INIT_WORKSPACE_N(1);
  unint64_t result = CCPOLYZP_PO2CYC_BASE_CONVERT_INIT_WORKSPACE_N(a1);
  if (v2 > result) {
    return v2;
  }
  return result;
}

uint64_t cche_decrypt_ctx_init_ws(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = a2;
  void v34[2] = *MEMORY[0x263EF8C08];
  *a2 = a3;
  unint64_t v6 = (unsigned int *)(a2 + 1);
  unsigned int v32 = cche_param_ctx_polynomial_degree(a3);
  int v33 = 2;
  v34[0] = cche_param_ctx_plaintext_modulus(a3);
  v34[1] = 0x1FFFFFFFFFFFFFFFLL;
  unsigned long long v30 = v6;
  uint64_t v31 = a1;
  uint64_t result = ccpolyzp_po2cyc_ctx_chain_init_ws(a1, v6, &v32, v34);
  if (!result)
  {
    int v8 = v33;
    uint64_t v9 = *((unsigned int *)v4 + 2);
    unint64_t v10 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
    if (v9 >= 0x80) {
      uint64_t v11 = 128;
    }
    else {
      uint64_t v11 = v9;
    }
    unint64_t v29 = &v4[(v10 + 2 * (v9 + ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v11) + 6)
            * (*((_DWORD *)v4 + 3) - v8)
            + 2];
    uint64_t v12 = cche_param_ctx_chain_const(*v4) + 8;
    uint64_t v28 = v4;
    while (1)
    {
      uint64_t v13 = *(unsigned int *)(v12 + 4);
      uint64_t v14 = sizeof_struct_ccpolyzp_po2cyc();
      unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
      unint64_t v16 = v15 - 1 + v14;
      uint64_t v17 = *((unsigned int *)v4 + 2);
      uint64_t v18 = *((unsigned int *)v4 + 3);
      unint64_t v19 = v16 / v15;
      unint64_t v20 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
      uint64_t v21 = v17 >= 0x80 ? 128 : v17;
      unint64_t v22 = (unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3;
      uint64_t v23 = (uint64_t *)&v30[2 * v19 + 2 * (v20 + 2 * (v17 + v22 * v21) + 6) * v18];
      if (v13 >= 2)
      {
        uint64_t v24 = sizeof_struct_ccpolyzp_po2cyc_base_convert();
        unsigned int v25 = v18;
        uint64_t v26 = 1;
        for (uint64_t i = 1; i != v13; ++i)
        {
          v23 += i + (v24 + v15 - 1) / v15 + (v26 + v25) * v22;
          v26 += 3;
          v25 += v18;
        }
      }
      uint64_t result = ccpolyzp_po2cyc_base_convert_init_ws(v31, v23, (char *)v12, v29);
      if (result) {
        break;
      }
      uint64_t v12 = *(void *)(v12 + 112);
      uint64_t v4 = v28;
      if (!v12) {
        return 0;
      }
    }
  }
  return result;
}

unint64_t CCHE_DECRYPT_WORKSPACE_N(uint64_t a1, int a2)
{
  unsigned int v4 = cche_ciphertext_fresh_npolys();
  uint64_t v5 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v6 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v7 = (v5 + v6 - 1) / v6
     + ((a2 * a1) + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3)) * v4;
  unint64_t v8 = CCPOLYZP_PO2CYC_BASE_CONVERT_DIVIDE_AND_ROUND_WORKSPACE_N(a1, a2);
  unint64_t v9 = CCPOLYZP_PO2CYC_BASE_CONVERT_EXACT_POLY_WORKSPACE_N(a1) + 15;
  if (v8 > v9) {
    unint64_t v9 = v8;
  }
  return v7 + v9;
}

uint64_t cche_decrypt_ws(uint64_t a1, unsigned int **a2, unsigned int *a3, uint64_t a4, _DWORD **a5)
{
  int v10 = *(_DWORD *)(a4 + 8);
  if (v10 != cche_ciphertext_fresh_npolys()) {
    return 4294967289;
  }
  if (!cche_param_ctx_eq(*(unsigned int **)a4, a3)) {
    return 4294967289;
  }
  uint64_t v11 = *a5;
  uint64_t v12 = cche_param_ctx_chain_const((uint64_t)a3);
  if (!ccpolyzp_po2cyc_ctx_eq((uint64_t)v11, (_DWORD *)(v12 + 8))) {
    return 4294967289;
  }
  uint64_t v13 = *(void *)(a1 + 16);
  *a2 = cche_param_ctx_plaintext_ctx((uint64_t)a3);
  uint64_t v14 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 24);
  unint64_t v15 = *(_DWORD **)(a4 + 24);
  uint64_t v16 = *(unsigned int *)(a4 + 8);
  uint64_t v17 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v18 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v19 = (v17 + v18 - 1) / v18;
  uint64_t v20 = sizeof_struct_ccpolyzp_po2cyc();
  uint64_t v21 = (void *)v14(a1, v19 + ((v15[1] * *v15) + ((unint64_t)(v20 + 7) >> 3)) * v16);
  unint64_t v22 = *(_DWORD **)(a4 + 24);
  uint64_t v23 = *(unsigned int *)(a4 + 8);
  uint64_t v24 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v25 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v26 = (v24 + v25 - 1) / v25;
  uint64_t v27 = sizeof_struct_ccpolyzp_po2cyc();
  memmove(v21, (const void *)a4, 8 * (v26 + ((v22[1] * *v22) + ((unint64_t)(v27 + 7) >> 3)) * v23));
  unint64_t v29 = (_DWORD *)v21[3];
  uint64_t v28 = (uint64_t)(v21 + 3);
  unsigned long long v30 = (unsigned int **)(v28
                        + 8
                        * ((v29[1] * *v29) + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3)));
  uint64_t v31 = ccpolyzp_po2cyc_fwd_ntt(v30);
  if (v31) {
    goto LABEL_20;
  }
  cche_mul_poly_sk(v30, v30, a5);
  uint64_t v31 = ccpolyzp_po2cyc_inv_ntt(v30);
  if (v31) {
    goto LABEL_20;
  }
  unint64_t v61 = (uint64_t *)a2;
  uint64_t v62 = v13;
  uint64_t v63 = a1;
  ccpolyzp_po2cyc_coeff_add((int **)v30, v28, v30);
  uint64_t v32 = *cche_param_ctx_plaintext_ctx((uint64_t)a3);
  int v33 = cche_param_ctx_plaintext_ctx((uint64_t)a3);
  unint64_t v60 = a3;
  unsigned int v34 = cche_param_ctx_polynomial_degree((uint64_t)a3);
  unint64_t v35 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
  if (v34 >= 0x80) {
    uint64_t v36 = 128;
  }
  else {
    uint64_t v36 = v34;
  }
  unint64_t v37 = (unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3;
  unint64_t v38 = v35 + 6;
  uint64_t v39 = (uint64_t)&v33[4 * v37 * v36 + 12 + 4 * v34 + 2 * v35] + ((4 * v32 + 7) & 0x7FFFFFFF8);
  uint64_t v40 = (*v30)[1];
  uint64_t v41 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v42 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v43 = v42 - 1;
  uint64_t v44 = *(unsigned int *)(v39 + 8);
  uint64_t v46 = *(unsigned int *)(v39 + 12);
  uint64_t v45 = v39 + 8;
  if (v44 >= 0x80) {
    uint64_t v47 = 128;
  }
  else {
    uint64_t v47 = v44;
  }
  uint64_t v48 = (uint64_t *)(v45 + 8 * ((v42 - 1 + v41) / v42 + (v38 + 2 * (v44 + v37 * v47)) * v46));
  if (v40 < 2)
  {
    a1 = v63;
    unint64_t v54 = v61;
  }
  else
  {
    unint64_t v49 = v42;
    uint64_t v50 = sizeof_struct_ccpolyzp_po2cyc_base_convert();
    uint64_t v51 = 1;
    unsigned int v52 = v46;
    uint64_t v53 = 1;
    a1 = v63;
    unint64_t v54 = v61;
    do
    {
      v48 += v53 + (v50 + v43) / v49 + (v51 + v52) * v37;
      ++v53;
      v51 += 3;
      v52 += v46;
    }
    while (v40 != v53);
  }
  int v55 = cche_param_ctx_he_scheme(v60);
  if (v55 == 2)
  {
    uint64_t v31 = ccpolyzp_po2cyc_base_convert_exact_poly_ws(a1, v54, (uint64_t *)v30, v48);
    uint64_t v13 = v62;
    if (v31) {
      goto LABEL_20;
    }
LABEL_22:
    uint64_t v64 = *(void *)(a4 + 16);
    uint64_t v56 = cche_param_ctx_plaintext_modulus_inverse_ws(a1, &v64, (uint64_t)v60, v64);
    if (!v56) {
      ccpolyzp_po2cyc_coeff_scalar_mul_ws(a1, (_DWORD **)v54, (unsigned int **)v54, (uint64_t)&v64);
    }
    goto LABEL_25;
  }
  uint64_t v13 = v62;
  if (v55 != 1)
  {
    uint64_t v56 = 4294967289;
    goto LABEL_25;
  }
  uint64_t v31 = ccpolyzp_po2cyc_base_convert_divide_and_round_ws(a1, (_DWORD **)v54, (uint64_t *)v30, v48);
  if (!v31) {
    goto LABEL_22;
  }
LABEL_20:
  uint64_t v56 = v31;
LABEL_25:
  uint64_t v57 = *v30;
  uint64_t v58 = sizeof_struct_ccpolyzp_po2cyc();
  cc_clear((v58 + 8 * v57[1] * *v57 + 7) & 0xFFFFFFFFFFFFFFF8, v30);
  *(void *)(a1 + 16) = v13;
  return v56;
}

uint64_t cche_decrypt(unsigned int **a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  BOOL v15 = timingsafe_enable_if_supported();
  unsigned int v8 = cche_param_ctx_polynomial_degree((uint64_t)a2);
  unint64_t v9 = CCHE_DECRYPT_WORKSPACE_N(v8, *(_DWORD *)(*(void *)(a3 + 24) + 4));
  v13[0] = cc_malloc_clear(8 * v9);
  unsigned int v10 = cche_param_ctx_polynomial_degree((uint64_t)a2);
  v13[1] = CCHE_DECRYPT_WORKSPACE_N(v10, *(_DWORD *)(*(void *)(a3 + 24) + 4));
  void v13[2] = 0;
  void v13[3] = cc_ws_alloc;
  uint64_t v14 = cc_ws_free;
  if (v13[0])
  {
    uint64_t v11 = cche_decrypt_ws((uint64_t)v13, a1, a2, a3, a4);
    v14((uint64_t)v13);
  }
  else
  {
    uint64_t v11 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v11;
}

uint64_t ccder_blob_decode_uint_strict(unsigned __int8 **a1, unint64_t a2, void *a3)
{
  v6[0] = 0;
  v6[1] = 0;
  uint64_t result = ccder_blob_decode_range_strict(a1, 2, v6);
  if (result) {
    return ccder_blob_decode_uint_range(v6, a2, a3);
  }
  return result;
}

BOOL ccder_blob_decode_uint_range(unsigned __int8 **a1, unint64_t a2, void *a3)
{
  uint64_t v3 = *a1;
  unsigned int v4 = a1[1];
  if (*a1 == v4 || (char)*v3 < 0) {
    goto LABEL_7;
  }
  if (!*v3)
  {
    if (++v3 == v4)
    {
      uint64_t v3 = a1[1];
      goto LABEL_4;
    }
    if (((char)*v3 & 0x80000000) == 0)
    {
LABEL_7:
      uint64_t v5 = 0;
      *a1 = 0;
      a1[1] = 0;
      return v5;
    }
  }
LABEL_4:
  *a1 = v3;
  return ccn_read_uint_public_value(a2, a3, v4 - v3, v3) == 0;
}

uint64_t ccder_blob_decode_uint(unsigned __int8 **a1, unint64_t a2, void *a3)
{
  v6[0] = 0;
  v6[1] = 0;
  uint64_t result = ccder_blob_decode_range(a1, 2, v6);
  if (result) {
    return ccder_blob_decode_uint_range(v6, a2, a3);
  }
  return result;
}

void *ccdes_ecb_encrypt_mode()
{
  return &ccdes_ltc_ecb_encrypt_mode;
}

double ccmode_factory_gcm_encrypt(void *a1, void *a2)
{
  *a1 = ((*a2 + 7) & 0xFFFFFFFFFFFFFFF8) + 5 * ((a2[1] + 7) & 0xFFFFFFFFFFFFFFF8) + 128;
  *(void *)&double result = 4073947;
  a1[1] = 4073947;
  a1[2] = 1;
  a1[3] = ccmode_gcm_init;
  a1[4] = ccmode_gcm_set_iv;
  a1[5] = ccmode_gcm_aad;
  a1[6] = ccmode_gcm_encrypt;
  a1[7] = ccmode_gcm_finalize;
  a1[8] = ccmode_gcm_reset;
  a1[9] = a2;
  return result;
}

uint64_t ccss_shamir_share_generator_init(uint64_t *a1, int *a2, uint64_t (**a3)(void, unint64_t, uint64_t), uint64_t a4, unint64_t a5)
{
  char v10 = 0;
  char v24 = 0;
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    if ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) & 0x1000000) != 0)
    {
      char v10 = 0;
    }
    else
    {
      __asm { MSR             DIT, #1 }
      char v10 = 1;
    }
  }
  char v24 = v10;
  uint64_t v16 = cczp_n((uint64_t)(a2 + 2));
  unint64_t v17 = sizeof_struct_ccpolyzp_po2cyc();
  v22[0] = cc_malloc_clear(8 * (5 * v16 + (v17 + 7) / v17) + 24);
  uint64_t v18 = cczp_n((uint64_t)(a2 + 2));
  unint64_t v19 = sizeof_struct_ccpolyzp_po2cyc();
  v22[1] = 5 * v18 + (v19 + 7) / v19 + 3;
  void v22[2] = 0;
  v22[3] = cc_ws_alloc;
  uint64_t v23 = cc_ws_free;
  if (v22[0])
  {
    ccss_shamir_init_share_poly((uint64_t)a1, a2);
    share_poly_uint64_t ws = ccss_shamir_generate_share_poly_ws((uint64_t)v22, a1, a3, a5, a4, 0);
    v23((uint64_t)v22);
  }
  else
  {
    share_poly_uint64_t ws = 4294967283;
  }
  cc_disable_dit(&v24);
  return share_poly_ws;
}

uint64_t ccss_shamir_share_generator_init_with_secrets_less_than_prime(uint64_t *a1, int *a2, uint64_t (**a3)(void, unint64_t, uint64_t), uint64_t a4, unint64_t a5)
{
  char v10 = 0;
  char v24 = 0;
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    if ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) & 0x1000000) != 0)
    {
      char v10 = 0;
    }
    else
    {
      __asm { MSR             DIT, #1 }
      char v10 = 1;
    }
  }
  char v24 = v10;
  uint64_t v16 = cczp_n((uint64_t)(a2 + 2));
  unint64_t v17 = sizeof_struct_ccpolyzp_po2cyc();
  v22[0] = cc_malloc_clear(8 * (5 * v16 + (v17 + 7) / v17) + 24);
  uint64_t v18 = cczp_n((uint64_t)(a2 + 2));
  unint64_t v19 = sizeof_struct_ccpolyzp_po2cyc();
  v22[1] = 5 * v18 + (v19 + 7) / v19 + 3;
  void v22[2] = 0;
  v22[3] = cc_ws_alloc;
  uint64_t v23 = cc_ws_free;
  if (v22[0])
  {
    ccss_shamir_init_share_poly((uint64_t)a1, a2);
    share_poly_uint64_t ws = ccss_shamir_generate_share_poly_ws((uint64_t)v22, a1, a3, a5, a4, 1);
    v23((uint64_t)v22);
  }
  else
  {
    share_poly_uint64_t ws = 4294967283;
  }
  cc_disable_dit(&v24);
  return share_poly_ws;
}

uint64_t ccder_blob_decode_oid(unsigned __int8 **a1, unsigned __int8 **a2)
{
  uint64_t v3 = *a1;
  v6[0] = 0;
  v6[1] = 0;
  uint64_t result = ccder_blob_decode_range(a1, 6, v6);
  if (result) {
    uint64_t v5 = v3;
  }
  else {
    uint64_t v5 = 0;
  }
  *a2 = v5;
  return result;
}

uint64_t cche_ciphertext_fresh_npolys()
{
  return 2;
}

uint64_t cche_ciphertext_fresh_correction_factor()
{
  return 1;
}

uint64_t cche_ciphertext_correction_factor(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t cche_ciphertext_fwd_ntt_internal(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 8)) {
    return 0;
  }
  uint64_t v2 = 0;
  uint64_t v3 = (_DWORD **)(a1 + 24);
  while (1)
  {
    unsigned int v4 = *v3;
    uint64_t v5 = sizeof_struct_ccpolyzp_po2cyc();
    uint64_t result = ccpolyzp_po2cyc_fwd_ntt(&v3[((v4[1] * *v4) + ((unint64_t)(v5 + 7) >> 3)) * v2]);
    if (result) {
      break;
    }
    if (++v2 >= (unint64_t)*(unsigned int *)(a1 + 8)) {
      return 0;
    }
  }
  return result;
}

uint64_t cche_ciphertext_fwd_ntt(uint64_t a1)
{
  BOOL v4 = timingsafe_enable_if_supported();
  uint64_t v2 = cche_ciphertext_fwd_ntt_internal(a1);
  cc_disable_dit_with_sb((unsigned int *)&v4);
  return v2;
}

uint64_t cche_ciphertext_inv_ntt_internal(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 8)) {
    return 0;
  }
  uint64_t v2 = 0;
  uint64_t v3 = (_DWORD **)(a1 + 24);
  while (1)
  {
    BOOL v4 = *v3;
    uint64_t v5 = sizeof_struct_ccpolyzp_po2cyc();
    uint64_t result = ccpolyzp_po2cyc_inv_ntt(&v3[((v4[1] * *v4) + ((unint64_t)(v5 + 7) >> 3)) * v2]);
    if (result) {
      break;
    }
    if (++v2 >= (unint64_t)*(unsigned int *)(a1 + 8)) {
      return 0;
    }
  }
  return result;
}

uint64_t cche_ciphertext_inv_ntt(uint64_t a1)
{
  BOOL v4 = timingsafe_enable_if_supported();
  uint64_t v2 = cche_ciphertext_inv_ntt_internal(a1);
  cc_disable_dit_with_sb((unsigned int *)&v4);
  return v2;
}

void *ccdh_gp_rfc5114_MODP_2048_224()
{
  return &_ccdh_gp_rfc5114_MODP_2048_224;
}

unint64_t ccpad_xts_decrypt(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v20 = *MEMORY[0x263EF8C08];
  BOOL v17 = timingsafe_enable_if_supported();
  uint64_t v12 = a4 & 0xF;
  if ((a4 & 0xF) != 0)
  {
    unint64_t v13 = a4 & 0xFFFFFFFFFFFFFFF0;
    uint64_t v14 = (int8x16_t *)(*(uint64_t (**)(uint64_t, uint64_t, unint64_t, uint64_t, uint64_t))(a1 + 48))(a2, a3, (a4 >> 4) - 1, a5, a6);
    int8x16_t v19 = *v14;
    ccmode_xts_mult_alpha(v14);
    (*(void (**)(uint64_t, uint64_t, uint64_t, unint64_t, unsigned char *))(a1 + 48))(a2, a3, 1, a5 + (a4 & 0xFFFFFFFFFFFFFFF0) - 16, v18);
    uint64_t v15 = 0;
    *uint64_t v14 = v19;
    do
    {
      v19.i8[v15] = *(unsigned char *)(a5 + v13 + v15);
      *(unsigned char *)(a6 + v13 + v15) = v18[v15];
      ++v15;
    }
    while (v12 != v15);
    if ((unint64_t)(v15 - 1) <= 0xE) {
      memcpy((void *)((unint64_t)&v19 | v12), &v18[v12], 16 - v12);
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, int8x16_t *, unint64_t))(a1 + 48))(a2, a3, 1, &v19, a6 + (a4 & 0xFFFFFFFFFFFFFFF0) - 16);
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t, unint64_t, uint64_t, uint64_t))(a1 + 48))(a2, a3, a4 >> 4, a5, a6);
  }
  cc_disable_dit_with_sb((unsigned int *)&v17);
  return a4;
}

unint64_t fipspost_post_tdes_ecb(char a1)
{
  uint64_t v8 = *MEMORY[0x263EF8C08];
  uint64_t v2 = ccdes3_ecb_decrypt_mode();
  if ((a1 & 0x10) != 0) {
    uint64_t v3 = &invalid_key;
  }
  else {
    uint64_t v3 = &valid_key;
  }
  if (ccecb_one_shot((uint64_t)v2, 24, (uint64_t)v3, 1, (uint64_t)&ciphertext_data, (uint64_t)v7))
  {
    uint64_t v4 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: des3_ecb_decrypt one_shot\n", v4, "fipspost_post_tdes_ecb_decrypt", 40);
    return 4294967223;
  }
  else
  {
    unint64_t result = cc_cmp_safe(8, v7, plaintext_data);
    if (result)
    {
      uint64_t v6 = mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: des3_ecb_decrypt cmp\n", v6, "fipspost_post_tdes_ecb_decrypt", 45);
      return 4294967221;
    }
  }
  return result;
}

uint64_t ccder_blob_encode_implicit_integer(uint64_t *a1, unint64_t a2, unint64_t a3, unint64_t *a4)
{
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  unint64_t v8 = ccn_write_int_size_public_value(a3, a4);
  uint64_t v9 = ccder_blob_reserve_tl(a1, a2, v8, &v11);
  if (v9) {
    ccn_write_int_public_value(a3, a4, v12 - (void)v11, v11);
  }
  return v9;
}

uint64_t ccder_sizeof_len(unint64_t a1)
{
  if (a1 < 0x80) {
    return 1;
  }
  uint64_t v2 = 3;
  uint64_t v3 = 4;
  uint64_t v4 = 5;
  uint64_t v5 = 6;
  uint64_t v6 = 7;
  uint64_t v7 = 8;
  if (HIBYTE(a1)) {
    uint64_t v7 = 9;
  }
  if (HIWORD(a1)) {
    uint64_t v6 = v7;
  }
  if (a1 >> 40) {
    uint64_t v5 = v6;
  }
  if (HIDWORD(a1)) {
    uint64_t v4 = v5;
  }
  if (a1 >> 24) {
    uint64_t v3 = v4;
  }
  if (a1 >= 0x10000) {
    uint64_t v2 = v3;
  }
  if (a1 >= 0x100) {
    return v2;
  }
  else {
    return 2;
  }
}

int64x2_t *ccaes_xts_encrypt_mode()
{
  unint64_t v0 = ccaes_ecb_encrypt_mode();
  uint64_t v1 = ccaes_ecb_encrypt_mode();
  ccmode_factory_xts_encrypt(xts_encrypt, v0, (uint64_t)v1);
  return xts_encrypt;
}

void *ccec_cp_ed25519_opt()
{
  return &ccec_cp25519_opt_params_0;
}

uint64_t cczp_mul_default_ws(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = cczp_n(a2);
  uint64_t v11 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 2 * v10);
  unint64_t v12 = cczp_n(a2);
  ccn_mul_ws(a1, v12, v11, a4, a5);
  uint64_t result = cczp_mod_ws(a1, a2);
  *(void *)(a1 + 16) = v9;
  return result;
}

uint64_t cczp_mul_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 16))();
}

uint64_t cczp_mul(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v13 = timingsafe_enable_if_supported();
  uint64_t v8 = cczp_n(a1);
  v11[0] = cc_malloc_clear(32 * v8);
  v11[1] = 4 * cczp_n(a1);
  _OWORD v11[2] = 0;
  v11[3] = cc_ws_alloc;
  unint64_t v12 = cc_ws_free;
  if (v11[0])
  {
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 16) + 16))(v11, a1, a2, a3, a4);
    v12((uint64_t)v11);
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v9 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v13);
  return v9;
}

uint64_t ccvrf_irtf_ed25519_string_to_point(int *a1, uint64_t a2)
{
  if (ge_frombytes_vartime(a1, a2)) {
    return 4294967209;
  }
  else {
    return 0;
  }
}

__n128 ccvrf_irtf_ed25519_decode_proof(uint64_t a1, int *a2, _OWORD *a3, uint64_t a4)
{
  if (!ge_frombytes_vartime(a2, a1))
  {
    *a3 = *(_OWORD *)(a1 + 32);
    __n128 result = *(__n128 *)(a1 + 48);
    long long v8 = *(_OWORD *)(a1 + 64);
    *(__n128 *)a4 = result;
    *(_OWORD *)(a4 + 16) = v8;
  }
  return result;
}

uint64_t ccvrf_irtf_ed25519_encode_proof(int *a1, _OWORD *a2, _OWORD *a3, _OWORD *a4)
{
  ge_p3_tobytes((uint64_t)a4, a1);
  a4[2] = *a2;
  long long v7 = a3[1];
  a4[3] = *a3;
  a4[4] = v7;
  return 0;
}

uint64_t ccvrf_irtf_ed25519_hash_points(uint64_t a1, int **a2, uint64_t a3, void *a4)
{
  v14[16] = *MEMORY[0x263EF8C08];
  __int16 v13 = 516;
  if (a3)
  {
    long long v8 = v14;
    uint64_t v9 = a3;
    do
    {
      uint64_t v10 = *a2++;
      ge_p3_tobytes((uint64_t)v8, v10);
      v8 += 4;
      --v9;
    }
    while (v9);
  }
  ccdigest_internal(*(void *)(a1 + 40), (32 * a3) | 2, (char *)&v13, (uint64_t)__src);
  memcpy(a4, __src, *(void *)(a1 + 32) >> 1);
  return cc_clear(0x40uLL, __src);
}

unint64_t CCPOLYZP_PO2CYC_WORKSPACE_N(int a1, int a2)
{
  return (a2 * a1) + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3);
}

uint64_t ccpolyzp_po2cyc_init(void *a1, _DWORD *a2, uint64_t *a3)
{
  *a1 = a2;
  int v3 = *a2 * a2[1];
  if (v3)
  {
    uint64_t v4 = a1 + 1;
    do
    {
      uint64_t v5 = *a3++;
      *v4++ = v5;
      --v3;
    }
    while (v3);
  }
  return 0;
}

uint64_t ccpolyzp_po2cyc_init_zero(void *a1, _DWORD *a2)
{
  *a1 = a2;
  return cc_clear(8 * (*a2 * a2[1]), a1 + 1);
}

uint64_t ccpolyzp_po2cyc_modulus_to_cczp_ws(uint64_t a1, void *a2, unint64_t a3)
{
  *a2 = 1;
  unint64_t v6 = bswap64(a3);
  uint64_t result = ccn_read_uint_public_value(1uLL, a2 + 3, 8uLL, (unsigned __int8 *)&v6);
  if (!result) {
    return cczp_init_ws(a1, a2);
  }
  return result;
}

int **ccpolyzp_po2cyc_coeff_negate(int **result, uint64_t a2)
{
  uint64_t v2 = *(_DWORD **)a2;
  uint64_t v3 = *(unsigned int *)(*(void *)a2 + 4);
  if (v3)
  {
    unint64_t v4 = 0;
    int v5 = *v2;
    unint64_t v6 = *result++;
    int v7 = *v6;
    uint64_t v8 = a2 + 8;
    do
    {
      uint64_t v9 = v2;
      if (v4 < (v3 - 1))
      {
        unsigned int v10 = v3 - 2;
        uint64_t v9 = v2;
        do
          uint64_t v9 = (_DWORD *)*((void *)v9 + 14);
        while (v4 < v10--);
      }
      if (v5)
      {
        uint64_t v12 = *((void *)v9 + 2);
        __int16 v13 = (unint64_t *)(v8 + 8 * (v5 * v4));
        uint64_t v14 = (uint64_t *)&result[(v7 * v4)];
        int v15 = v5;
        do
        {
          unint64_t v16 = *v13++;
          *v14++ = (v12 - v16) & -(uint64_t)(((v16 | HIDWORD(v16)) + 0xFFFFFFFF) >> 32);
          --v15;
        }
        while (v15);
      }
      ++v4;
    }
    while (v4 != v3);
  }
  return result;
}

int **ccpolyzp_po2cyc_coeff_add(int **result, uint64_t a2, void *a3)
{
  uint64_t v3 = *(_DWORD **)a2;
  uint64_t v4 = *(unsigned int *)(*(void *)a2 + 4);
  if (v4)
  {
    unint64_t v5 = 0;
    int v6 = *v3;
    int v7 = *result++;
    int v8 = *v7;
    uint64_t v9 = a2 + 8;
    uint64_t v11 = (int *)*a3;
    unsigned int v10 = a3 + 1;
    int v12 = *v11;
    do
    {
      __int16 v13 = v3;
      if (v5 < (v4 - 1))
      {
        unsigned int v14 = v4 - 2;
        __int16 v13 = v3;
        do
          __int16 v13 = (_DWORD *)*((void *)v13 + 14);
        while (v5 < v14--);
      }
      if (v6)
      {
        uint64_t v16 = *((void *)v13 + 2);
        BOOL v17 = &v10[(v12 * v5)];
        uint64_t v18 = (uint64_t *)(v9 + 8 * (v6 * v5));
        int8x16_t v19 = &result[(v8 * v5)];
        int v20 = v6;
        do
        {
          uint64_t v22 = *v18++;
          uint64_t v21 = v22;
          uint64_t v23 = *v17++;
          char v24 = (int *)(v23 + v21);
          if ((uint64_t)v24 - v16 >= 0) {
            char v24 = (int *)((char *)v24 - v16);
          }
          *v19++ = v24;
          --v20;
        }
        while (v20);
      }
      ++v5;
    }
    while (v5 != v4);
  }
  return result;
}

_DWORD **ccpolyzp_po2cyc_eval_mul(_DWORD **result, unsigned int **a2, _DWORD **a3)
{
  uint64_t v3 = *a2;
  unsigned int v4 = (*a2)[1];
  if (v4)
  {
    int v5 = 0;
    unsigned int v6 = 0;
    uint64_t v7 = *v3;
    int v8 = a2 + 1;
    do
    {
      uint64_t v9 = v3;
      if (v4 - 1 > v6)
      {
        unsigned int v10 = v4 - 1;
        uint64_t v9 = v3;
        do
        {
          uint64_t v9 = (void *)v9[14];
          --v10;
        }
        while (v10 > v6);
      }
      if (v7)
      {
        unsigned int v11 = **a3 * v6;
        unsigned int v12 = **result * v6;
        uint64_t v13 = v7;
        int v14 = v5;
        do
        {
          unint64_t v15 = (unint64_t)v8[v14];
          unint64_t v16 = (unint64_t)a3[v11 + 1];
          unint64_t v17 = (v16 * (unsigned __int128)v15) >> 64;
          uint64_t v18 = v16 * v15;
          unint64_t v19 = v9[4];
          uint64_t v20 = ((unint64_t)v18 * (unsigned __int128)v19) >> 64;
          uint64_t v21 = (v17 * (unsigned __int128)v19) >> 64;
          uint64_t v22 = v17 * v19;
          BOOL v23 = __CFADD__(v20, v22);
          uint64_t v24 = v20 + v22;
          uint64_t v25 = v23;
          uint64_t v26 = v25
              + __CFADD__(v18 * v9[5], v24)
              + v21
              + v9[5] * v17
              + (((unint64_t)v18 * (unsigned __int128)(unint64_t)v9[5]) >> 64);
          uint64_t v27 = v9[2];
          uint64_t v28 = (_DWORD *)(v18 - v26 * v27);
          if ((uint64_t)v28 - v27 >= 0) {
            uint64_t v28 = (_DWORD *)((char *)v28 - v27);
          }
          result[++v12] = v28;
          ++v11;
          ++v14;
          --v13;
        }
        while (v13);
      }
      ++v6;
      v5 += v7;
    }
    while (v6 != v4);
  }
  return result;
}

uint64_t ccpolyzp_po2cyc_coeff_scalar_mul_ws(uint64_t result, _DWORD **a2, unsigned int **a3, uint64_t a4)
{
  uint64_t v4 = (*a3)[1];
  if (v4)
  {
    uint64_t v8 = result;
    unint64_t v9 = 0;
    uint64_t v10 = **a3;
    unsigned int v11 = a3 + 1;
    unsigned int v12 = a2 + 1;
    do
    {
      uint64_t v13 = (uint64_t)*a3;
      unsigned int v14 = (*a3)[1];
      if (v9 < v14 - 1)
      {
        unsigned int v15 = v14 - 2;
        do
          uint64_t v13 = *(void *)(v13 + 112);
        while (v9 < v15--);
      }
      uint64_t v17 = *(void *)(v13 + 16);
      uint64_t v25 = 0;
      uint64_t v26 = 0;
      unint64_t v27 = 0;
      uint64_t result = ccrns_mul_modulus_init_ws(v8, &v25, v17, *(void *)(a4 + 8 * v9));
      if (v10)
      {
        uint64_t v19 = v26;
        unint64_t v18 = v27;
        uint64_t v20 = v25;
        int v21 = **a2 * v9;
        int v22 = **a3 * v9;
        uint64_t v23 = v10;
        do
        {
          uint64_t v24 = (_DWORD *)(v19 * (void)v11[v22] - v20 * ((v18 * (unsigned __int128)(unint64_t)v11[v22]) >> 64));
          if ((uint64_t)v24 - v20 >= 0) {
            uint64_t v24 = (_DWORD *)((char *)v24 - v20);
          }
          v12[v21++] = v24;
          ++v22;
          --v23;
        }
        while (v23);
      }
      ++v9;
    }
    while (v9 != v4);
  }
  return result;
}

uint64_t ccpolyzp_po2cyc_divide_and_round_q_last_ws(uint64_t a1, unsigned int **a2)
{
  uint64_t v22 = *MEMORY[0x263EF8C08];
  uint64_t v2 = *a2;
  if (!*((void *)*a2 + 14)) {
    return 4294967289;
  }
  unsigned int v3 = v2[1];
  if (v3 < 2) {
    return 4294967289;
  }
  uint64_t v6 = *v2;
  unsigned int v7 = v3 - 1;
  uint64_t v8 = (char *)(v2 + 36);
  ccn_shift_right(1, (uint64_t)v21, (unint64_t *)v2 + 18, 1uLL);
  if (v6)
  {
    int v9 = 0;
    uint64_t v10 = (uint64_t)(v2 + 30);
    do
    {
      cczp_add_ws(a1, v10);
      ++v9;
    }
    while (v6 != v9);
  }
  unsigned int v11 = 0;
  unsigned int v12 = a2 + 1;
  while (1)
  {
    uint64_t v13 = *a2;
    unsigned int v14 = (*a2)[1];
    while (--v14 > v11)
      uint64_t v13 = (unsigned int *)*((void *)v13 + 14);
    unsigned int v15 = v13 + 30;
    cczp_modn_ws(a1, (void *)v13 + 15, &v20, 1, v21);
    cczp_modn_ws(a1, v15, &v19, 1, v8);
    uint64_t result = cczp_inv_field_ws(a1, (uint64_t)v15, &v19, &v19);
    if (result) {
      break;
    }
    if (v6)
    {
      int v17 = 0;
      do
      {
        cczp_modn_ws(a1, v15, &v18, 1, (char *)&(&v12[v17])[**a2 * v7]);
        cczp_sub_ws(a1, (uint64_t)v15);
        cczp_sub_ws(a1, (uint64_t)v15);
        cczp_mul_ws(a1, (uint64_t)v15);
        ++v17;
      }
      while (v6 != v17);
    }
    if (++v11 == v7)
    {
      cc_clear(8 * v6, &v12[**a2 * v7]);
      uint64_t result = 0;
      *a2 = (unsigned int *)*((void *)*a2 + 14);
      return result;
    }
  }
  return result;
}

void *ccsha224_di()
{
  return &ccsha224_ltc_di;
}

uint64_t ccwrap_auth_encrypt_withiv_internal(uint64_t a1, uint64_t a2, size_t a3, const void *a4, uint64_t *a5, void *a6, uint64_t *a7)
{
  uint64_t v26 = *MEMORY[0x263EF8C08];
  uint64_t v14 = ccwrap_wrapped_size(a3);
  *a5 = v14;
  if (ccwrap_argsvalid(a1, a3, v14))
  {
    uint64_t v22 = a6;
    uint64_t v23 = a6 + 1;
    uint64_t v24 = *a7;
    memmove(a6 + 1, a4, a3);
    uint64_t v15 = 0;
    if (a3 >> 3 <= 1) {
      uint64_t v16 = 1;
    }
    else {
      uint64_t v16 = a3 >> 3;
    }
    uint64_t v17 = 1;
    do
    {
      if (a3 >= 8)
      {
        uint64_t v18 = v23;
        unint64_t v19 = v17;
        uint64_t v20 = v16;
        do
        {
          uint64_t v25 = *v18;
          (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t *))(a1 + 24))(a2, 1, &v24, &v24);
          v24 ^= bswap64(v19);
          *v18++ = v25;
          ++v19;
          --v20;
        }
        while (v20);
      }
      ++v15;
      v17 += a3 >> 3;
    }
    while (v15 != 6);
    uint64_t result = 0;
    *uint64_t v22 = v24;
  }
  else
  {
    *a5 = 0;
    return 4294967289;
  }
  return result;
}

uint64_t ccwrap_auth_encrypt_withiv(uint64_t a1, uint64_t a2, size_t a3, const void *a4, uint64_t *a5, void *a6, uint64_t *a7)
{
  BOOL v16 = timingsafe_enable_if_supported();
  uint64_t v14 = ccwrap_auth_encrypt_withiv_internal(a1, a2, a3, a4, a5, a6, a7);
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v14;
}

uint64_t ccdh_import_pub(uint64_t a1, unint64_t a2, unsigned __int8 *a3, void *a4)
{
  unsigned int v7 = a4 + 2;
  ccdh_ctx_init(a1, a4);
  unint64_t v8 = ccdh_gp_n(a1);
  if (ccn_read_uint_public_value(v8, v7, a2, a3)) {
    return 4294967244;
  }
  uint64_t v10 = ccdh_gp_n(a1);
  unsigned int v11 = (uint64_t *)ccdh_gp_prime(a1);
  if ((int)ccn_cmp_public_value(v10, v7, v11) >= 0) {
    return 4294967247;
  }
  else {
    return 0;
  }
}

uint64_t ccmode_xts_init(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, char *a5)
{
  if (cc_cmp_safe_internal(a3, a4, a5)) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = 4294967132;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, char *, char *))(a1 + 32))(a1, a2, a3, a4, a5);
  return v10;
}

uint64_t ccapsic_client_state_sizeof(void **a1)
{
  return 112 * **a1 + 192;
}

uint64_t ccapsic_server_state_sizeof(void **a1)
{
  return 120 * **a1 + 192;
}

uint64_t ccapsic_server_init(unint64_t **a1, unint64_t **a2, unint64_t *a3, size_t a4, const void *a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t inited = ccapsic_client_init_internal(a1, a2, a3, a4, a5);
  if (!inited) {
    ccn_set(**a2, &(&a1[12 * **a1])[2 * **a1 + 24], &a2[3 * **a2 + 2]);
  }
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return inited;
}

uint64_t ccapsic_client_init_internal(unint64_t **a1, unint64_t **a2, unint64_t *a3, size_t a4, const void *a5)
{
  int v9 = *a2;
  *a1 = *a2;
  a1[1] = a3;
  a1[2] = 0;
  unint64_t v10 = *v9;
  unint64_t v11 = sizeof_struct_ccpolyzp_po2cyc();
  v25[0] = cc_malloc_clear(8 * (5 * v10 + (v11 + 7) / v11) + 24);
  unint64_t v12 = *v9;
  unint64_t v13 = sizeof_struct_ccpolyzp_po2cyc();
  v25[1] = 5 * v12 + (v13 + 7) / v13 + 3;
  void v25[2] = 0;
  unsigned char v25[3] = cc_ws_alloc;
  uint64_t v26 = cc_ws_free;
  if (v25[0])
  {
    if (a4 - 129 < 0xFFFFFFFFFFFFFF80) {
      goto LABEL_9;
    }
    uint64_t v15 = *a2;
    uint64_t v14 = a2 + 2;
    if (ccec_is_point_at_infinity(v15, (uint64_t)v14)) {
      goto LABEL_9;
    }
    memcpy(&(&a1[9 * **a1 + 24])[2 * **a1], v14, 24 * *v9);
    uint64_t v16 = ccec_projectify_ws((uint64_t)v25, (uint64_t)v9);
    if (v16 || (uint64_t v16 = ccec_projectify_ws((uint64_t)v25, (uint64_t)v9), v16))
    {
      uint64_t v18 = v16;
      goto LABEL_15;
    }
    uint64_t v17 = *a1;
    if (v17 == ccec_cp_256())
    {
      unint64_t v19 = &cch2c_p256_sha256_sswu_ro_info;
    }
    else if (v17 == ccec_cp_384())
    {
      unint64_t v19 = &cch2c_p384_sha512_sswu_ro_info;
    }
    else
    {
      if (v17 != ccec_cp_521())
      {
LABEL_9:
        uint64_t v18 = 4294967289;
LABEL_15:
        v26((uint64_t)v25);
        return v18;
      }
      unint64_t v19 = &cch2c_p521_sha512_sswu_ro_info;
    }
    a1[2] = (unint64_t *)v19;
    uint64_t v20 = (const char *)cch2c_name((uint64_t)v19);
    size_t v21 = strlen(v20);
    uint64_t v22 = (const void *)cch2c_name((uint64_t)a1[2]);
    memcpy(a1 + 4, v22, v21);
    uint64_t v23 = (char *)a1 + v21 + 32;
    *(_DWORD *)uint64_t v23 = 1230196801;
    void v23[4] = 67;
    memcpy(v23 + 5, a5, a4);
    uint64_t v18 = 0;
    a1[3] = (unint64_t *)(a4 + v21 + 5);
    goto LABEL_15;
  }
  return 4294967283;
}

uint64_t ccapsic_client_init(unint64_t **a1, unint64_t **a2, unint64_t *a3, size_t a4, const void *a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t inited = ccapsic_client_init_internal(a1, a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return inited;
}

void *cckem_kyber1024()
{
  return &cckem_kyber1024_info;
}

uint64_t cckem_kyber1024_generate_key(uint64_t a1, uint64_t (**a2)(void, uint64_t, char *))
{
  uint64_t v4 = (void *)(cckem_public_ctx(a1) + 8);
  uint64_t v5 = a1 + *(void *)(*(void *)a1 + 8) + 8;

  return cckyber_kem_keypair(cckyber1024_params, v4, v5, a2);
}

uint64_t cckem_kyber1024_derive_key_from_seed(uint64_t a1, unint64_t a2, char *a3, uint64_t (**a4)(void, uint64_t, _OWORD *))
{
  uint64_t v13 = *MEMORY[0x263EF8C08];
  if (a2 < 0x20) {
    return 4294967289;
  }
  uint64_t v7 = cckem_public_ctx(a1);
  uint64_t v8 = *(void *)(*(void *)a1 + 8);
  uint64_t v9 = (*a4)(a4, 32, __s);
  if (!v9) {
    uint64_t v9 = cckyber_kem_keypair_coins(cckyber1024_params, (void *)(v7 + 8), a1 + v8 + 8, a3, __s);
  }
  uint64_t v10 = v9;
  cc_clear(0x20uLL, __s);
  return v10;
}

uint64_t cckem_kyber1024_encapsulate(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t (**a4)(void, uint64_t, long long *))
{
  return cckyber_kem_encapsulate(cckyber1024_params, (char *)(a1 + 8), a2, a3, a4);
}

uint64_t cckem_kyber1024_decapsulate(uint64_t a1, char *a2, char *a3)
{
  return cckyber_kem_decapsulate(cckyber1024_params, a1 + *(void *)(*(void *)a1 + 8) + 8, a2, a3);
}

uint64_t cckem_kyber1024_export_pubkey(uint64_t a1, unint64_t *a2, void *a3)
{
  unint64_t v6 = *a2;
  if (v6 < cckem_pubkey_nbytes_ctx(a1)) {
    return 4294967289;
  }
  size_t v7 = cckem_pubkey_nbytes_ctx(a1);
  *a2 = v7;
  memcpy(a3, (const void *)(a1 + 8), v7);
  return 0;
}

uint64_t cckem_kyber1024_import_pubkey(uint64_t a1, size_t a2, const void *a3, void *a4)
{
  if (cckem_pubkey_nbytes_info(a1) != a2) {
    return 4294967289;
  }
  cckem_pub_ctx_init(a4, a1);
  memcpy(a4 + 1, a3, a2);
  return 0;
}

uint64_t cckem_kyber1024_export_privkey(uint64_t a1, unint64_t *a2, void *a3)
{
  unint64_t v6 = *a2;
  uint64_t v7 = cckem_public_ctx(a1);
  if (v6 < cckem_privkey_nbytes_ctx(v7)) {
    return 4294967289;
  }
  uint64_t v8 = cckem_public_ctx(a1);
  size_t v9 = cckem_privkey_nbytes_ctx(v8);
  *a2 = v9;
  memcpy(a3, (const void *)(a1 + *(void *)(*(void *)a1 + 8) + 8), v9);
  return 0;
}

uint64_t cckem_kyber1024_import_privkey(void *a1, size_t a2, const void *a3, void *a4)
{
  if (cckem_privkey_nbytes_info(a1) != a2) {
    return 4294967289;
  }
  cckem_full_ctx_init(a4, a1);
  memcpy((char *)a4 + *(void *)(*a4 + 8) + 8, a3, a2);
  return 0;
}

uint64_t ccec_mult_default_ws(uint64_t a1, unint64_t *a2, uint64_t *a3, unsigned char *a4, unint64_t a5, uint64_t *a6)
{
  BOOL v12 = a2 + 4;
  if (cczp_bitlen((uint64_t)&a2[5 * *a2 + 4]) < a5) {
    return 4294967289;
  }
  uint64_t v51 = a3;
  char __src = a4;
  unint64_t v54 = v12;
  unint64_t v14 = *a2;
  unint64_t v15 = (a5 + 63) >> 6;
  uint64_t v53 = *(void *)(a1 + 16);
  uint64_t v16 = 3 * *a2;
  uint64_t v17 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v16);
  uint64_t v18 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v14);
  unint64_t v55 = ccn_n(v14, (uint64_t)a6) == 0;
  if (a5 + 63 >= 0x40) {
    ccn_set((a5 + 63) >> 6, v18, a4);
  }
  ccn_zero(v14 - v15, &v18[8 * v15]);
  *(void *)&v18[8 * v15 - 8] &= 0xFFFFFFFFFFFFFFFFLL >> -(char)a5;
  unint64_t v50 = (a5 + 63) >> 6;
  uint64_t v57 = v18;
  ccn_shift_right(v50, (uint64_t)v18, (unint64_t *)v18, v55);
  ccec_double_ws(a1, a2);
  ccn_mux(3 * v14, v55 ^ 1, v17, a6, v17);
  if (!ccn_n(v14, (uint64_t)v17))
  {
LABEL_13:
    uint64_t result = 0xFFFFFFFFLL;
    goto LABEL_16;
  }
  if (cczp_bitlen((uint64_t)&v54[5 * *a2]) >= a5)
  {
    uint64_t v19 = *a2;
    if (ccn_n(*a2, (uint64_t)v17))
    {
      uint64_t v47 = v16;
      uint64_t v45 = *(void *)(a1 + 16);
      uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 2 * v19);
      uint64_t v49 = v19;
      size_t v21 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 2 * v19);
      uint64_t v56 = 2 * v19;
      uint64_t v22 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 2 * v19);
      unint64_t v23 = *a2;
      uint64_t v42 = *(void *)(a1 + 16);
      uint64_t __dst = (void *)v22;
      (*(void (**)(uint64_t, unint64_t))(a1 + 24))(a1, *a2);
      (*(void (**)(uint64_t, unint64_t))(a1 + 24))(a1, v23);
      (*(void (**)(uint64_t, unint64_t))(a1 + 24))(a1, v23);
      cczp_sqr_ws(a1, (uint64_t)a2);
      cczp_add_ws(a1, (uint64_t)a2);
      cczp_add_ws(a1, (uint64_t)a2);
      cczp_sqr_ws(a1, (uint64_t)a2);
      cczp_sqr_ws(a1, (uint64_t)a2);
      cczp_add_ws(a1, (uint64_t)a2);
      cczp_add_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      cczp_sqr_ws(a1, (uint64_t)a2);
      cczp_add_ws(a1, (uint64_t)a2);
      cczp_add_ws(a1, (uint64_t)a2);
      uint64_t v46 = v17;
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_sqr_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      uint64_t v24 = a1;
      uint64_t v25 = a1;
      uint64_t v26 = (uint64_t *)v20;
      cczp_sub_ws(v24, (uint64_t)a2);
      cczp_mul_ws(v25, (uint64_t)a2);
      cczp_sqr_ws(v25, (uint64_t)a2);
      cczp_add_ws(v25, (uint64_t)a2);
      cczp_sub_ws(v25, (uint64_t)a2);
      uint64_t v48 = v25;
      *(void *)(v25 + 16) = v42;
      unint64_t v27 = v18;
      uint64_t v28 = *(void *)&v18[((a5 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8] >> (a5 - 1);
      char v29 = v28 & 1;
      unsigned __int8 v30 = !(v28 & 1);
      unint64_t v31 = a5 - 2;
      if (a5 == 2)
      {
        char v43 = !(v28 & 1);
        LOBYTE(v32) = v28 & 1;
      }
      else
      {
        LOBYTE(v32) = v28 & 1;
        do
        {
          char v33 = v32;
          uint64_t v32 = (*(void *)&v27[(v31 >> 3) & 0x1FFFFFFFFFFFFFF8] >> v31) & 1;
          cczp_cond_negate((uint64_t)a2, v30, &v21[v49], (unint64_t *)&v21[v49]);
          ccn_cond_swap(v56, v32 ^ v33 | v29 ^ 1, v26, v21);
          ccec_mult_XYCZaddC_ws(v25, a2);
          ccec_mult_XYCZadd_ws(v25, a2);
          unsigned __int8 v30 = v32 & (v29 ^ 1);
          unint64_t v27 = v18;
          v29 |= v32;
          --v31;
        }
        while (v31);
        char v43 = v29 ^ 1;
      }
      cczp_cond_negate((uint64_t)a2, v30, &v21[v49], (unint64_t *)&v21[v49]);
      ccn_cond_swap(v56, *v27 & 1 ^ v32, v26, v21);
      ccec_mult_XYCZaddC_ws(v25, a2);
      ccn_set(v56, __dst, v21);
      uint64_t v41 = *(void *)v27 & 1;
      ccn_cond_swap(v56, *v27 & 1, v26, v21);
      unsigned int v34 = v26;
      a1 = v25;
      unint64_t v35 = v51;
      uint64_t v40 = *(void *)(v25 + 16);
      cczp_sub_ws(v25, (uint64_t)a2);
      cczp_mul_ws(v25, (uint64_t)a2);
      cczp_mul_ws(v25, (uint64_t)a2);
      cczp_mul_ws(v25, (uint64_t)a2);
      cczp_mul_ws(v25, (uint64_t)a2);
      cczp_sqr_ws(v25, (uint64_t)a2);
      cczp_mul_ws(v25, (uint64_t)a2);
      *(void *)(v25 + 16) = v40;
      ccn_cond_swap(v56, v41, v34, v21);
      ccec_mult_XYCZadd_ws(v25, a2);
      ccn_mux(v56, v41, v34, v21, v34);
      cczp_mul_ws(v25, (uint64_t)a2);
      cczp_mul_ws(v25, (uint64_t)a2);
      uint64_t v36 = (unint64_t *)cczp_prime((uint64_t)&v54[5 * *a2]);
      ccn_sub1(v49, __dst, v36, 1uLL);
      unsigned __int8 v37 = (ccn_cmpn_internal(v50, v57, v49, __dst) & 1) == 0;
      BOOL is_point_at_infinity = ccec_is_point_at_infinity(a2, (uint64_t)v46);
      ccn_mux(3 * v49, v43 | is_point_at_infinity | v37, v35, v46, v35);
      cczp_cond_negate((uint64_t)a2, v37, &v35[*a2], (unint64_t *)&v35[*a2]);
      char v39 = v43 & ~*v57 & 1;
      ccn_cond_clear(v49, v39, &v51[2 * *a2]);
      ccn_seti(v49, v34, 1);
      cczp_to_ws(v48, (uint64_t)a2);
      ccn_mux(v49, v39, v35, v34, v35);
      ccn_mux(v49, v39, &v35[*a2], v34, &v35[*a2]);
      *(void *)(v48 + 16) = v45;
      ccec_full_add_ws(v48, (uint64_t)a2);
      ccn_mux(v47, *__src & v55, v35, v46, v35);
      uint64_t result = 0;
      goto LABEL_16;
    }
    goto LABEL_13;
  }
  uint64_t result = 4294967289;
LABEL_16:
  *(void *)(a1 + 16) = v53;
  return result;
}

uint64_t ccec_mult_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 96))();
}

uint64_t ccec_mult_XYCZaddC_ws(uint64_t a1, void *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, void))(a1 + 24))(a1, *a2);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  uint64_t result = cczp_sub_ws(a1, (uint64_t)a2);
  *(void *)(a1 + 16) = v5;
  return result;
}

uint64_t ccec_mult_XYCZadd_ws(uint64_t a1, void *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, void))(a1 + 24))(a1, *a2);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  uint64_t result = cczp_sub_ws(a1, (uint64_t)a2);
  *(void *)(a1 + 16) = v5;
  return result;
}

double ccmode_factory_siv_hmac_decrypt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)&double result = 600;
  *(_OWORD *)a1 = xmmword_2373AF980;
  *(void *)(a1 + 16) = ccmode_siv_hmac_init;
  *(void *)(a1 + 24) = ccmode_siv_hmac_nonce;
  *(void *)(a1 + 32) = ccmode_siv_hmac_auth;
  *(void *)(a1 + 40) = ccmode_siv_hmac_decrypt;
  *(void *)(a1 + 48) = ccmode_siv_hmac_reset;
  *(void *)(a1 + 56) = a2;
  *(void *)(a1 + 64) = a3;
  return result;
}

size_t ccpad_cts3_encrypt(uint64_t a1, uint64_t a2, uint64_t a3, size_t a4, unsigned char *a5, char *a6)
{
  uint64_t v22 = *MEMORY[0x263EF8C08];
  BOOL v20 = timingsafe_enable_if_supported();
  unint64_t v12 = *(void *)(a1 + 8);
  unint64_t v13 = (a4 - 1) / v12;
  if (v13 >= 2)
  {
    uint64_t v15 = (v13 - 1) * v12;
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a2, a3);
    size_t v14 = a4 - v15;
    a5 += v15;
    a6 += v15;
  }
  else
  {
    size_t v14 = a4;
  }
  if (v14 != 2 * v12)
  {
    cc_clear(2 * v12, __src);
    __memcpy_chk();
    a5 = __src;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *))(a1 + 24))(a2, a3, 2, a5, __src);
  uint64_t v16 = 0;
  uint64_t v17 = &__src[v12];
  do
  {
    char v18 = __src[v16];
    __src[v16] = v17[v16];
    v17[v16++] = v18;
  }
  while (v12 != v16);
  memcpy(a6, __src, v14);
  cc_disable_dit_with_sb((unsigned int *)&v20);
  return a4;
}

BOOL timingsafe_enable_if_supported()
{
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    BOOL v0 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) != 0;
    __asm { MSR             DIT, #1 }
  }
  else
  {
    BOOL v0 = 0;
  }
  if ((MEMORY[0xFFFFFC010] & 0x200000000000) != 0)
  {
    sb();
  }
  else
  {
    __dsb(0xFu);
    __isb(0xFu);
  }
  return v0;
}

uint64_t timingsafe_restore_if_supported(uint64_t result)
{
  if ((result & 1) == 0 && (MEMORY[0xFFFFFC010] & 0x200000000000000) != 0) {
    __asm { MSR             DIT, #0 }
  }
  return result;
}

void sb()
{
  __asm { SB }
}

uint64_t ccder_blob_encode_raw_octet_string(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ccder_blob_encode_implicit_raw_octet_string(a1, 4, a2, a3);
}

uint64_t ccmode_gcm_set_iv(int8x16_t *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v11 = *MEMORY[0x263EF8C08];
  if (a1[5].i16[0] != 1 || (a1[5].i16[1] & 1) != 0) {
    return 4294967228;
  }
  unint64_t v4 = a2;
  uint64_t result = 4294967228;
  if (a2)
  {
    uint64_t v6 = a3;
    if (a3)
    {
      uint64_t v7 = a1 + 2;
      if (a2 == 12)
      {
        uint64_t v8 = *(void *)a3;
        a1[2].i32[2] = *(_DWORD *)(a3 + 8);
        v7->i64[0] = v8;
        a1[2].i32[3] = 0x1000000;
      }
      else
      {
        cc_clear(8uLL, &v10);
        v10.i64[1] = bswap64(8 * v4);
        cc_clear(0x10uLL, &a1[2]);
        if (v4 < 0x10) {
          goto LABEL_20;
        }
        do
        {
          for (uint64_t i = 0; i != -16; --i)
            a1[2].i8[i + 15] ^= *(unsigned char *)(v6 + i + 15);
          ccmode_gcm_mult_h((uint64_t)a1, (uint64_t)a1[2].i64);
          v6 += 16;
          v4 -= 16;
        }
        while (v4 > 0xF);
        if (v4)
        {
LABEL_20:
          do
          {
            a1[1].i8[v4 + 15] ^= *(unsigned char *)(v6 - 1 + v4);
            --v4;
          }
          while (v4);
          ccmode_gcm_mult_h((uint64_t)a1, (uint64_t)a1[2].i64);
        }
        a1[2] = veorq_s8(v10, a1[2]);
        ccmode_gcm_mult_h((uint64_t)a1, (uint64_t)a1[2].i64);
      }
      a1[3] = *v7;
      ccmode_gcm_update_pad((uint64_t)a1);
      uint64_t result = 0;
      a1[5].i16[0] = 2;
    }
  }
  return result;
}

uint64_t ccrng_uniform_internal(uint64_t (**a1)(void, uint64_t, unint64_t *), unint64_t a2, unint64_t *a3)
{
  if (a2)
  {
    unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> __clz(a2);
    while (1)
    {
      uint64_t v7 = (*a1)(a1, 8, a3);
      if (v7) {
        break;
      }
      unint64_t v8 = *a3 & v6;
      *a3 = v8;
      if (v8 < a2) {
        return 0;
      }
    }
    uint64_t v9 = v7;
  }
  else
  {
    uint64_t v9 = 4294967289;
  }
  cc_clear(8uLL, a3);
  return v9;
}

uint64_t ccrng_uniform(uint64_t (**a1)(void, uint64_t, unint64_t *), unint64_t a2, unint64_t *a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t v6 = ccrng_uniform_internal(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return v6;
}

unint64_t ccecies_decrypt_gcm_plaintext_size(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  unint64_t v5 = ccecies_pub_key_size_cp(*a1, a2);
  if (v5 - 1 >= a3) {
    return 0;
  }
  unint64_t v6 = v5 + *(unsigned int *)(a2 + 28);
  BOOL v7 = a3 >= v6;
  unint64_t v8 = a3 - v6;
  if (v7) {
    return v8;
  }
  else {
    return 0;
  }
}

unint64_t ccecies_decrypt_gcm_plaintext_size_cp(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v5 = ccecies_pub_key_size_cp(a1, a2);
  if (v5 - 1 >= a3) {
    return 0;
  }
  unint64_t v6 = v5 + *(unsigned int *)(a2 + 28);
  BOOL v7 = a3 >= v6;
  unint64_t v8 = a3 - v6;
  if (v7) {
    return v8;
  }
  else {
    return 0;
  }
}

void *ccsha512_256_di()
{
  return &ccsha512_256_ltc_di;
}

uint64_t cche_ciphertext_coeff_decompose_nptexts_internal(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  int v5 = 0;
  int v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = *(unsigned int *)(*(void *)(a1 + 24) + 4);
  do
  {
    if (v8)
    {
      for (uint64_t i = 0; i != v8; ++i)
      {
        if (a2) {
          int v10 = *(_DWORD *)(a2 + 4 * (v5 + i));
        }
        else {
          int v10 = 0;
        }
        uint64_t v7 = cche_ciphertext_coeff_decompose_nptexts_rns((uint64_t *)a1, i, v10) + v7;
      }
    }
    ++v6;
    v5 += v8;
  }
  while (v6 != v2);
  return v7;
}

uint64_t cche_ciphertext_coeff_decompose_nptexts_rns(uint64_t *a1, unsigned int a2, int a3)
{
  unint64_t v6 = cche_param_ctx_plaintext_modulus(*a1);
  uint64_t v7 = a1[3];
  int v8 = *(_DWORD *)(v7 + 4);
  while (--v8 > a2)
    uint64_t v7 = *(void *)(v7 + 112);
  int v9 = __clz(v6);
  unint64_t v10 = *(void *)(v7 + 16);
  int v11 = __clz(v10);
  uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
  v12.i16[0] = vaddlv_u8(v12);
  if (v12.u32[0] == 1) {
    int v13 = 63;
  }
  else {
    int v13 = 64;
  }
  return (v13 - (v9 + a3 + v11) + 62) / (63 - v9);
}

uint64_t cche_ciphertext_coeff_decompose_nptexts(uint64_t a1, uint64_t a2)
{
  BOOL v6 = timingsafe_enable_if_supported();
  uint64_t v4 = cche_ciphertext_coeff_decompose_nptexts_internal(a1, a2);
  cc_disable_dit_with_sb((unsigned int *)&v6);
  return v4;
}

uint64_t cche_ciphertext_coeff_compose(uint64_t *a1, int a2, uint64_t a3, uint64_t a4, unsigned int a5, unint64_t a6, uint64_t a7)
{
  BOOL v53 = timingsafe_enable_if_supported();
  if (!a2 || cche_param_ctx_key_ctx_nmoduli(a4) < a5 || cche_param_ctx_plaintext_modulus(a4) <= a6) {
    goto LABEL_28;
  }
  int v49 = a2;
  int v13 = (unsigned int *)cche_param_ctx_chain_const(a4);
  uint64_t v14 = *v13;
  unint64_t v15 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
  if (v14 >= 0x80) {
    uint64_t v16 = 128;
  }
  else {
    uint64_t v16 = v14;
  }
  unint64_t v17 = (unint64_t)&v13[2
                             * (v15
                              + 2 * (v14 + ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v16)
                              + 6)
                             * (v13[1] - a5)
                             + 2];
  unsigned int v18 = cche_ciphertext_fresh_npolys();
  size_t v19 = cche_ciphertext_sizeof(a4, a5, v18);
  bzero(a1, v19);
  unsigned int v20 = cche_ciphertext_fresh_npolys();
  *a1 = a4;
  *((_DWORD *)a1 + 2) = v20;
  a1[2] = 1;
  a1[3] = v17;
  size_t v21 = a1 + 3;
  uint64_t v51 = (int **)(a1 + 3);
  if (v20 >= 2)
  {
    for (uint64_t i = 1; i != v20; v51[((v26 * v25) + ((unint64_t)(v24 + 7) >> 3)) * i++] = (int *)v17)
    {
      unint64_t v23 = *v51;
      uint64_t v24 = sizeof_struct_ccpolyzp_po2cyc();
      int v25 = *v23;
      int v26 = v23[1];
      size_t v21 = a1 + 3;
    }
  }
  uint64_t v47 = v20;
  a1[2] = a6;
  if (cche_ciphertext_coeff_decompose_nptexts_internal((uint64_t)a1, a7) != v49)
  {
LABEL_28:
    uint64_t v44 = 4294967289;
    goto LABEL_29;
  }
  if (v20)
  {
    unsigned int v46 = a5;
    uint64_t v27 = 0;
    unsigned int v28 = 0;
    uint64_t v29 = 63 - __clz(cche_param_ctx_plaintext_modulus(a4));
    uint64_t v48 = (*(_DWORD *)(*v21 + 4) * *(_DWORD *)*v21);
    while (1)
    {
      unsigned __int8 v30 = (unsigned int **)&v21[(v48 + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3)) * v27];
      unint64_t v31 = *v30;
      uint64_t v32 = (*v30)[1];
      uint64_t v50 = v27;
      if (v32) {
        break;
      }
LABEL_26:
      size_t v21 = a1 + 3;
      uint64_t v27 = v50 + 1;
      if (v50 + 1 == v47) {
        goto LABEL_27;
      }
    }
    uint64_t v33 = 0;
    int v34 = v27 * v46;
    unint64_t v35 = v30 + 1;
    while (1)
    {
      unsigned int v36 = a7 ? *(_DWORD *)(a7 + 4 * (v34 + v33)) : 0;
      int v37 = cche_ciphertext_coeff_decompose_nptexts_rns(a1, v33, v36);
      if (v37) {
        break;
      }
LABEL_25:
      if (++v33 == v32) {
        goto LABEL_26;
      }
    }
    int v38 = 0;
    unint64_t v39 = v36;
    while (v39 <= 0x3F)
    {
      uint64_t v40 = *v31;
      if (v40)
      {
        uint64_t v41 = (uint64_t *)(*(void *)(a3 + 8 * v28) + 8);
        int v42 = v33 * v40;
        do
        {
          uint64_t v43 = *v41++;
          v35[v42] = (unsigned int *)((unint64_t)v35[v42] | (v43 << v39));
          ++v42;
          --v40;
        }
        while (v40);
      }
      v39 += v29;
      ++v38;
      ++v28;
      if (v38 == v37) {
        goto LABEL_25;
      }
    }
    goto LABEL_28;
  }
LABEL_27:
  uint64_t v44 = 0;
LABEL_29:
  cc_disable_dit_with_sb((unsigned int *)&v53);
  return v44;
}

unint64_t cche_ciphertext_coeff_decompose(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v37 = timingsafe_enable_if_supported();
  if (cche_ciphertext_coeff_decompose_nptexts_internal(a3, a4) == a1)
  {
    uint64_t v35 = *(void *)a3;
    unint64_t v7 = cche_param_ctx_plaintext_modulus(*(void *)a3);
    int v8 = (_DWORD **)(a3 + 24);
    unint64_t v9 = *(unsigned int *)(a3 + 8);
    if (v9)
    {
      unint64_t v10 = 0;
      unsigned int v11 = 0;
      char v12 = __clz(v7);
      char v13 = 63 - v12;
      uint64_t v14 = ~(-1 << ~v12);
      unsigned int v15 = *(_DWORD *)(*(void *)(a3 + 24) + 4);
      uint64_t v33 = a3;
      uint64_t v34 = a4;
      uint64_t v29 = (_DWORD **)(a3 + 24);
      uint64_t v32 = v15;
      do
      {
        uint64_t v16 = *v8;
        uint64_t v17 = sizeof_struct_ccpolyzp_po2cyc();
        if (v15)
        {
          unint64_t v18 = v10;
          uint64_t v19 = 0;
          unsigned int v20 = &v8[((v16[1] * *v16) + ((unint64_t)(v17 + 7) >> 3)) * v18];
          unint64_t v30 = v18;
          int v31 = v15 * v18;
          do
          {
            if (a4) {
              LODWORD(a4) = *(_DWORD *)(a4 + 4 * (v31 + v19));
            }
            int v21 = cche_ciphertext_coeff_decompose_nptexts_rns((uint64_t *)a3, v19, a4);
            if (v21)
            {
              int v22 = v21;
              for (int i = 0; i != v22; ++i)
              {
                uint64_t v24 = *(unsigned int ***)(a2 + 8 * v11);
                *uint64_t v24 = cche_param_ctx_plaintext_ctx(v35);
                uint64_t v25 = **v20;
                if (v25)
                {
                  int v26 = (unint64_t *)(v24 + 1);
                  unsigned int v27 = v19 * v25;
                  do
                  {
                    *v26++ = ((unint64_t)v20[++v27] >> a4) & v14;
                    --v25;
                  }
                  while (v25);
                }
                LOBYTE(a4) = a4 + v13;
                ++v11;
              }
            }
            ++v19;
            unsigned int v15 = v32;
            a3 = v33;
            a4 = v34;
          }
          while (v19 != v32);
          unint64_t v9 = *(unsigned int *)(v33 + 8);
          int v8 = v29;
          unint64_t v10 = v30;
        }
        ++v10;
      }
      while (v10 < v9);
      unint64_t v9 = 0;
    }
  }
  else
  {
    unint64_t v9 = 4294967289;
  }
  cc_disable_dit_with_sb((unsigned int *)&v37);
  return v9;
}

uint64_t ccder_sizeof_eckey(unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = ccder_sizeof_uint64(1uLL);
  unint64_t v7 = ccder_sizeof(4, a1) + v6;
  if (a2)
  {
    unint64_t v8 = ccder_sizeof_oid(a2);
    v7 += ccder_sizeof(0xA000000000000000, v8);
  }
  if (a3)
  {
    unint64_t v9 = ccder_sizeof(3, a3 + 1);
    v7 += ccder_sizeof(0xA000000000000001, v9);
  }

  return ccder_sizeof(0x2000000000000010, v7);
}

unint64_t ccn_write_int_size_public_value(unint64_t a1, unint64_t *a2)
{
  unint64_t v2 = ccn_bitlen_public_value(a1, a2);
  if ((v2 & 7) != 0) {
    return (v2 + 7) >> 3;
  }
  else {
    return ((v2 + 7) >> 3) + 1;
  }
}

unint64_t ccn_write_int_size(unint64_t a1, unint64_t *a2)
{
  BOOL v7 = timingsafe_enable_if_supported();
  unint64_t v4 = ccn_bitlen_public_value(a1, a2);
  if ((v4 & 7) != 0) {
    unint64_t v5 = (v4 + 7) >> 3;
  }
  else {
    unint64_t v5 = ((v4 + 7) >> 3) + 1;
  }
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return v5;
}

unint64_t ccn_write_int_public_value(unint64_t a1, unint64_t *a2, unint64_t a3, unsigned char *a4)
{
  if ((ccn_bitlen_public_value(a1, a2) & 7) == 0)
  {
    *a4++ = 0;
    --a3;
  }

  return ccn_write_uint_public_value(a1, a2, a3, (uint64_t)a4);
}

uint64_t ccn_write_int(unint64_t a1, unint64_t *a2, unint64_t a3, unsigned char *a4)
{
  BOOL v9 = timingsafe_enable_if_supported();
  ccn_write_int_public_value(a1, a2, a3, a4);
  return cc_disable_dit_with_sb((unsigned int *)&v9);
}

uint64_t ccrng_sequence_init(uint64_t (**a1)(uint64_t a1, uint64_t a2, uint64_t a3), uint64_t (*a2)(uint64_t a1, uint64_t a2, uint64_t a3), uint64_t (*a3)(uint64_t a1, uint64_t a2, uint64_t a3))
{
  BOOL v7 = timingsafe_enable_if_supported();
  *a1 = sequence_repeat_generate;
  a1[1] = a3;
  a1[2] = a2;
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return 0;
}

uint64_t sequence_repeat_generate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(void *)(a1 + 16)) {
    return 4294967291;
  }
  if (a2)
  {
    for (unint64_t i = 0; i != a2; ++i)
      *(unsigned char *)(a3 + i) = *(unsigned char *)(*(void *)(a1 + 8) + i % *(void *)(a1 + 16));
  }
  return 0;
}

uint64_t ccrng_sequence_non_repeat_init(uint64_t (**a1)(uint64_t a1, unint64_t a2, uint64_t a3), uint64_t (*a2)(uint64_t a1, unint64_t a2, uint64_t a3), uint64_t (*a3)(uint64_t a1, unint64_t a2, uint64_t a3))
{
  *a1 = non_repeat_sequence_generate;
  a1[1] = a3;
  a1[2] = a2;
  return 0;
}

uint64_t non_repeat_sequence_generate(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a1 + 16);
  if (v3 < a2) {
    return 4294967286;
  }
  if (a2)
  {
    for (uint64_t i = 0; i != a2; ++i)
      *(unsigned char *)(a3 + i) = *(unsigned char *)(*(void *)(a1 + 8) + i);
    unint64_t v3 = *(void *)(a1 + 16);
  }
  uint64_t v4 = 0;
  *(void *)(a1 + 8) += a2;
  *(void *)(a1 + 16) = v3 - a2;
  return v4;
}

uint64_t ccrsa_num_mr_iterations(unint64_t a1)
{
  uint64_t v1 = 5;
  uint64_t v2 = 16;
  if (a1 > 0x1FF) {
    uint64_t v2 = 7;
  }
  if (a1 <= 0x3FF) {
    uint64_t v1 = v2;
  }
  if (a1 <= 0x5FF) {
    return v1;
  }
  else {
    return 4;
  }
}

uint64_t ccrsa_num_mr_iterations_aux(unint64_t a1)
{
  uint64_t v1 = 38;
  if (a1 > 0xAA) {
    uint64_t v1 = 41;
  }
  if (a1 <= 0xC8) {
    return v1;
  }
  else {
    return 44;
  }
}

uint64_t ccrsa_import_pub(unint64_t *a1, uint64_t a2, unsigned __int8 *a3)
{
  unint64_t v5 = &a3[a2];
  uint64_t v6 = ccder_decode_rsa_pub_x509(a1, a3, &a3[a2]);
  if (!v6) {
    uint64_t v6 = ccder_decode_rsa_pub(a1, a3, v5);
  }
  if (v6) {
    return 0;
  }
  else {
    return 4294967289;
  }
}

BOOL ccder_blob_reserve(void *a1, unint64_t a2, void *a3)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = v3 - *a1;
  if (v4 < a2)
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    a1[1] = v3 - a2;
    *a3 = v3 - a2;
    a3[1] = v3;
  }
  return v4 >= a2;
}

void *ccec_get_cp(uint64_t a1)
{
  if (a1 <= 255)
  {
    if (a1 == 192) {
      return ccec_cp_192();
    }
    if (a1 == 224) {
      return ccec_cp_224();
    }
  }
  else
  {
    switch(a1)
    {
      case 256:
        return ccec_cp_256();
      case 384:
        return ccec_cp_384();
      case 521:
        return ccec_cp_521();
    }
  }
  return 0;
}

uint64_t ccec_keysize_is_supported(uint64_t a1)
{
  BOOL v4 = timingsafe_enable_if_supported();
  uint64_t v2 = 1;
  if (a1 <= 255)
  {
    if (a1 != 192 && a1 != 224) {
      goto LABEL_8;
    }
  }
  else if (a1 != 256 && a1 != 384 && a1 != 521)
  {
LABEL_8:
    uint64_t v2 = 0;
  }
  cc_disable_dit_with_sb((unsigned int *)&v4);
  return v2;
}

uint64_t ccn_p224_sqrt_ws(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  return cczp_sqrt_tonelli_shanks_precomp_ws(a1, a2, a3, a4, 0x60uLL, (uint64_t)&SQRT_C3, &SQRT_C5);
}

uint64_t ccn_p224_to_ws(uint64_t a1, uint64_t a2)
{
  return cczp_mul_ws(a1, a2);
}

void *ccec_cp_224()
{
  return &ccec_cp224;
}

uint64_t ccn_p224_mul_ws(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t v10 = *(void *)(a1 + 16);
  unsigned int v11 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 8);
  ccn_mul_ws(a1, 4uLL, v11, a4, a5);
  uint64_t result = ccn_p224_redc_ws(a1, a2, a3, (uint64_t *)v11);
  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t ccn_p224_sqr_ws(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t *a4)
{
  uint64_t v8 = *(void *)(a1 + 16);
  BOOL v9 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 8);
  ccn_sqr_ws(a1, 4uLL, v9, a4);
  uint64_t result = ccn_p224_redc_ws(a1, a2, a3, v9);
  *(void *)(a1 + 16) = v8;
  return result;
}

uint64_t ccn_p224_from_ws(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 8);
  ccn_set(4, (void *)v9, a4);
  ccn_zero(4, (void *)(v9 + 32));
  uint64_t result = ccn_p224_redc_ws(a1, a2, a3, (uint64_t *)v9);
  *(void *)(a1 + 16) = v8;
  return result;
}

uint64_t ccn_p224_redc_ws(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8 = 0;
  uint64_t v9 = a4[2];
  do
  {
    uint64_t v10 = &a4[v8];
    uint64_t v11 = a4[v8];
    uint64_t v12 = a4[v8 + 1];
    uint64_t v13 = -v11;
    uint64_t v14 = ((unint64_t)-v11 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
    unint64_t v15 = 0xFFFFFFFF00000001 * v11;
    uint64_t v16 = ((unint64_t)-v11 * (unsigned __int128)0xFFFFFFFF00000000) >> 64;
    BOOL v17 = __CFADD__(v11 << 32, v12);
    uint64_t v18 = (v11 << 32) + v12;
    if (v17) {
      ++v16;
    }
    BOOL v17 = __CFADD__(__CFADD__(v11, v13), v18);
    uint64_t v19 = __CFADD__(v11, v13) + v18;
    if (v17) {
      ++v16;
    }
    uint64_t v20 = ((unint64_t)v13 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
    BOOL v17 = __CFADD__(v11, v9);
    uint64_t v21 = v11 + v9;
    if (v17) {
      uint64_t v22 = v20 + 1;
    }
    else {
      uint64_t v22 = v20;
    }
    uint64_t v23 = v21 + v16;
    if (__CFADD__(v21, v16)) {
      uint64_t v24 = v22 + 1;
    }
    else {
      uint64_t v24 = v22;
    }
    uint64_t v25 = v10[3];
    BOOL v17 = __CFADD__(v15, v25);
    unint64_t v26 = v15 + v25;
    if (v17) {
      ++v14;
    }
    BOOL v17 = __CFADD__(v26, v24);
    uint64_t v9 = v26 + v24;
    if (v17) {
      uint64_t v27 = v14 + 1;
    }
    else {
      uint64_t v27 = v14;
    }
    void v10[2] = v23;
    _OWORD v10[3] = v9;
    *uint64_t v10 = v27;
    v10[1] = v19;
    ++v8;
  }
  while (v8 != 4);
  char v28 = ccn_add_ws(a1, 4, a4 + 4, a4 + 4, a4);
  uint64_t v29 = (unint64_t *)cczp_prime(a2);
  char v30 = ccn_sub_ws(a1, 4, a4, a4 + 4, v29) ^ v28;

  return ccn_mux(4, v30, a3, a4 + 4, a4);
}

uint64_t ccec_affinify_jacobian_ws(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6 = *a2;
  if (ccec_is_point_at_infinity(a2, a4)) {
    return 4294967289;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, unint64_t))(a1 + 24))(a1, v6);
  (*(void (**)(uint64_t, unint64_t))(a1 + 24))(a1, v6);
  uint64_t v9 = cczp_inv_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_from_ws(a1, (uint64_t)a2);
  cczp_from_ws(a1, (uint64_t)a2);
  *(void *)(a1 + 16) = v8;
  return v9;
}

uint64_t ccec_affinify_homogeneous_ws(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v7 = cczp_n((uint64_t)a2);
  if (!ccn_n(v7, a4 + 16 * *a2)) {
    return 4294967289;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, unint64_t))(a1 + 24))(a1, v7);
  uint64_t v9 = cczp_inv_ws(a1, (uint64_t)a2);
  if (!v9)
  {
    cczp_mul_ws(a1, (uint64_t)a2);
    cczp_mul_ws(a1, (uint64_t)a2);
    cczp_from_ws(a1, (uint64_t)a2);
    cczp_from_ws(a1, (uint64_t)a2);
  }
  *(void *)(a1 + 16) = v8;
  return v9;
}

uint64_t ccec_affinify_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 80))();
}

uint64_t ccec_affinify(void *a1, uint64_t a2, uint64_t a3)
{
  BOOL v12 = timingsafe_enable_if_supported();
  unint64_t v6 = cc_malloc_clear(88 * *a1);
  uint64_t v7 = 11 * *a1;
  v10[0] = v6;
  v10[1] = v7;
  void v10[2] = 0;
  _OWORD v10[3] = cc_ws_alloc;
  uint64_t v11 = cc_ws_free;
  if (v6)
  {
    uint64_t v8 = (*(uint64_t (**)(void *, void *, uint64_t, uint64_t))(a1[2] + 80))(v10, a1, a2, a3);
    v11((uint64_t)v10);
  }
  else
  {
    uint64_t v8 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v8;
}

uint64_t ccec_affinify_x_only_ws(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6 = *a2;
  if (ccec_is_point_at_infinity(a2, a4)) {
    return 4294967289;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, unint64_t))(a1 + 24))(a1, v6);
  cczp_sqr_ws(a1, (uint64_t)a2);
  uint64_t v9 = cczp_inv_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_from_ws(a1, (uint64_t)a2);
  *(void *)(a1 + 16) = v8;
  return v9;
}

uint64_t ccsae_generate_h2c_pt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, const void *a6, size_t a7, char *a8)
{
  uint64_t v35 = *MEMORY[0x263EF8C08];
  BOOL v33 = timingsafe_enable_if_supported();
  BOOL v12 = (uint64_t *)(*(uint64_t (**)(void))(a1 + 16))();
  uint64_t v13 = *v12;
  uint64_t v14 = sizeof_struct_cche_galois_key();
  unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v16 = (v14 + v15 + 3 * v13 * v15 - 1) / v15;
  v29[0] = cc_malloc_clear(16 * (v16 + v13) + 8 * (v16 + 18 * v13));
  uint64_t v17 = *v12;
  uint64_t v18 = sizeof_struct_cche_galois_key();
  unint64_t v19 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v20 = (v18 + v19 + 3 * v17 * v19 - 1) / v19;
  v29[1] = v20 + 18 * v17 + 2 * (v20 + v17);
  uint64_t v30 = 0;
  int v31 = cc_ws_alloc;
  uint64_t v32 = cc_ws_free;
  if (v29[0])
  {
    uint64_t v21 = 4294967289;
    uint64_t v22 = cc_ws_free;
    if (a5 <= 0x40 && a7 <= 0x40)
    {
      uint64_t v23 = (void *)(*(uint64_t (**)(void))(a1 + 16))();
      uint64_t v24 = (uint64_t *)cc_ws_alloc(v29, (unint64_t)(24 * *v23 + 23) >> 3);
      memset(v34, 0, sizeof(v34));
      __memcpy_chk();
      memcpy((char *)v34 + a5, a6, a7);
      uint64_t v25 = cch2c_ws((uint64_t)v29, a1, a3);
      if (!v25) {
        uint64_t v25 = ccec_export_pub(v24, a8);
      }
      uint64_t v21 = v25;
      uint64_t v30 = 0;
      uint64_t v22 = v32;
    }
    v22((uint64_t)v29);
  }
  else
  {
    uint64_t v21 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v33);
  return v21;
}

uint64_t ccmgf_internal(uint64_t a1, uint64_t a2, uint64_t a3, size_t a4, char *a5)
{
  uint64_t v20 = *MEMORY[0x263EF8C08];
  uint64_t v8 = (void *)MEMORY[0x270FA53B0](a1, a2, a3, a4);
  uint64_t v10 = &__src[-v9 - 8];
  unint64_t v12 = v11 / *v8;
  uint64_t v13 = v12 * *v8;
  unint64_t v15 = (char *)(v14 + v13);
  size_t v16 = v11 - v13;
  if (v11 != v13)
  {
    ccdigest_init_internal(a1, v10);
    ccdigest_update_internal((unint64_t *)a1, v10, a4, a5);
    HIDWORD(v18) = bswap32(v12);
    ccdigest_update_internal((unint64_t *)a1, v10, 4uLL, (char *)&v18 + 4);
    (*(void (**)(uint64_t, void *, unsigned char *))(a1 + 56))(a1, v10, __src);
    memmove(v15, __src, v16);
  }
  while (v12)
  {
    LODWORD(v12) = v12 - 1;
    v15 -= *(void *)a1;
    ccdigest_init_internal(a1, v10);
    ccdigest_update_internal((unint64_t *)a1, v10, a4, a5);
    HIDWORD(v18) = bswap32(v12);
    ccdigest_update_internal((unint64_t *)a1, v10, 4uLL, (char *)&v18 + 4);
    (*(void (**)(uint64_t, void *, char *))(a1 + 56))(a1, v10, v15);
  }
  cc_clear(*(void *)(a1 + 8) + *(void *)(a1 + 16) + 12, v10);
  cc_clear(0x40uLL, __src);
  return 0;
}

uint64_t ccmgf(uint64_t a1, uint64_t a2, uint64_t a3, size_t a4, char *a5)
{
  BOOL v11 = timingsafe_enable_if_supported();
  ccmgf_internal(a1, a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v11);
  return 0;
}

void *ccaes_ccm_encrypt_mode()
{
  BOOL v0 = ccaes_ecb_encrypt_mode();
  ccmode_factory_ccm_encrypt((uint64_t)&ccm_encrypt_info, v0);
  return &ccm_encrypt_info;
}

BOOL ccn_neg(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  if (a1)
  {
    uint64_t v3 = a2;
    uint64_t v4 = a1;
    do
    {
      uint64_t v5 = *a3++;
      *v3++ = ~v5;
      --v4;
    }
    while (v4);
  }
  return ccn_add1_ws(0, a1, a2, a2, 1);
}

uint64_t ccrsa_init_pub_ws(uint64_t a1, uint64_t *a2, void *a3, void *a4)
{
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = *a2;
  uint64_t v9 = a2 + 3;
  ccn_set(*a2, a2 + 3, a3);
  uint64_t inited = cczp_init_ws(a1, a2);
  ccn_set(v8, &v9[2 * *a2 + 1], a4);
  *(void *)(a1 + 16) = v7;
  return inited;
}

uint64_t ccrsa_init_pub(uint64_t *a1, void *a2, void *a3)
{
  uint64_t v6 = 5 * *a1 + 3;
  v9[0] = cc_malloc_clear(8 * v6);
  v9[1] = v6;
  void v9[2] = 0;
  void v9[3] = cc_ws_alloc;
  uint64_t v10 = cc_ws_free;
  if (!v9[0]) {
    return 4294967283;
  }
  uint64_t inited = ccrsa_init_pub_ws((uint64_t)v9, a1, a2, a3);
  v10((uint64_t)v9);
  return inited;
}

unint64_t ccdh_generate_private_key_bitlen(void *a1)
{
  if (ccdh_gp_order_bitlen(a1))
  {
    return ccdh_gp_order_bitlen(a1);
  }
  else if (ccdh_gp_l(a1))
  {
    return ccdh_gp_l(a1);
  }
  else
  {
    return cczp_bitlen((uint64_t)a1);
  }
}

uint64_t ccdh_generate_private_key_ws(uint64_t a1, void *a2, void *a3, uint64_t (**a4)(void, unint64_t, uint64_t))
{
  uint64_t v8 = ccdh_gp_n(a2);
  unint64_t v9 = ccdh_gp_l(a2);
  uint64_t v10 = *(void *)(a1 + 16);
  BOOL v11 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8);
  ccn_zero(v8, a3);
  ccn_zero(v8, v11);
  if (v9 > cczp_bitlen((uint64_t)a2))
  {
    uint64_t result = 4294967245;
  }
  else
  {
    unint64_t private_key_bitlen = ccdh_generate_private_key_bitlen(a2);
    uint64_t result = ccn_random_bits(private_key_bitlen, (uint64_t)a3, a4);
    if (!result)
    {
      if (ccdh_gp_order_bitlen(a2) || !v9)
      {
        if (ccdh_gp_order_bitlen(a2)) {
          uint64_t v14 = (unint64_t *)ccdh_gp_order(a2);
        }
        else {
          uint64_t v14 = (unint64_t *)ccdh_gp_prime(a2);
        }
        ccn_sub1(v8, v11, v14, 2uLL);
        unint64_t v15 = 0;
        while ((int)ccn_cmp_internal(v8, a3, v11) > 0 || !ccn_n(v8, (uint64_t)a3))
        {
          uint64_t result = ccn_random_bits(private_key_bitlen, (uint64_t)a3, a4);
          if (result) {
            goto LABEL_16;
          }
          if (++v15 == 100) {
            goto LABEL_15;
          }
        }
        if (v15 >= 0x64)
        {
LABEL_15:
          uint64_t result = 4294967249;
          goto LABEL_16;
        }
      }
      else
      {
        ccn_set_bit((uint64_t)a3, v9 - 1, 1);
      }
      uint64_t result = 0;
    }
  }
LABEL_16:
  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t ccentropy_digest_init(uint64_t a1, uint64_t a2, int a3)
{
  BOOL v7 = timingsafe_enable_if_supported();
  *(void *)a1 = entropy_digest_info;
  *(void *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 376) = a3;
  *(_DWORD *)(a1 + 380) = 0;
  ccdigest_init_internal(a2, (void *)(a1 + 16));
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return 0;
}

uint64_t ccentropy_digest_get_seed(uint64_t a1, size_t a2, void *a3)
{
  uint64_t v9 = *MEMORY[0x263EF8C08];
  uint64_t v3 = *(void *)(a1 + 8);
  if (*(void *)v3 < a2) {
    return 4294967291;
  }
  if (*(_DWORD *)(a1 + 380) < *(_DWORD *)(a1 + 376)) {
    return 4294967286;
  }
  *(_DWORD *)(a1 + 380) = 0;
  BOOL v7 = (void *)(a1 + 16);
  (*(void (**)(uint64_t, uint64_t, unsigned char *))(v3 + 56))(v3, a1 + 16, __src);
  ccdigest_init_internal(v3, v7);
  memcpy(a3, __src, a2);
  cc_clear(0x40uLL, __src);
  return 0;
}

uint64_t ccentropy_digest_add_entropy(uint64_t a1, int a2, size_t a3, char *a4, BOOL *a5)
{
  int v5 = *(_DWORD *)(a1 + 380);
  BOOL v6 = __CFADD__(v5, a2);
  unsigned int v7 = v5 + a2;
  if (v6) {
    unsigned int v7 = -1;
  }
  *(_DWORD *)(a1 + 380) = v7;
  if (a5) {
    *a5 = v7 >= *(_DWORD *)(a1 + 376);
  }
  ccdigest_update_internal(*(unint64_t **)(a1 + 8), (void *)(a1 + 16), a3, a4);
  return 0;
}

uint64_t ccentropy_digest_reset(uint64_t a1)
{
  *(_DWORD *)(a1 + 380) = 0;
  return 0;
}

uint64_t ccrng_getentropy_generate(int a1, unint64_t a2, char *buffer)
{
  if (a2)
  {
    unint64_t v4 = a2;
    do
    {
      if (v4 >= 0x100) {
        size_t v5 = 256;
      }
      else {
        size_t v5 = v4;
      }
      if (getentropy(buffer, v5) == -1) {
        cc_abort();
      }
      buffer += v5;
      v4 -= v5;
    }
    while (v4);
  }
  return 0;
}

uint64_t ccrng_drbg_init(uint64_t (**a1)(uint64_t a1, uint64_t a2, uint64_t a3), uint64_t a2, uint64_t (*a3)(uint64_t a1, uint64_t a2, uint64_t a3))
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t inited = ccdrbg_init_internal(a2);
  if (!inited)
  {
    *a1 = generate_4;
    a1[1] = (uint64_t (*)(uint64_t, uint64_t, uint64_t))a2;
    a1[2] = a3;
  }
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return inited;
}

uint64_t ccrng_drbg_init_withdrbg(uint64_t (**a1)(uint64_t a1, uint64_t a2, uint64_t a3), uint64_t (*a2)(uint64_t a1, uint64_t a2, uint64_t a3), uint64_t (*a3)(uint64_t a1, uint64_t a2, uint64_t a3))
{
  *a1 = generate_4;
  a1[1] = a2;
  a1[2] = a3;
  return 0;
}

uint64_t ccrng_drbg_reseed(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = ccdrbg_reseed_internal(*(void *)(a1 + 8), *(void *)(a1 + 16), a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccrng_drbg_done(uint64_t a1)
{
  BOOL v3 = timingsafe_enable_if_supported();
  ccdrbg_done(*(void *)(a1 + 8), *(void *)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  return cc_disable_dit_with_sb((unsigned int *)&v3);
}

uint64_t generate_4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ccdrbg_generate(*(void *)(a1 + 8), *(void *)(a1 + 16), a2, a3, 0, 0);
}

uint64_t ccentropy_lock_init(void *a1, uint64_t a2, uint64_t a3)
{
  BOOL v7 = timingsafe_enable_if_supported();
  *a1 = entropy_lock_info;
  a1[1] = a2;
  a1[2] = a3;
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return 0;
}

uint64_t ccentropy_lock_get_seed(uint64_t a1)
{
  os_unfair_lock_lock(*(os_unfair_lock_t *)(a1 + 16));
  seed_uint64_t internal = ccentropy_get_seed_internal(*(uint64_t (****)(void))(a1 + 8));
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(a1 + 16));
  return seed_internal;
}

uint64_t ccentropy_lock_add_entropy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  os_unfair_lock_lock(*(os_unfair_lock_t *)(a1 + 16));
  uint64_t v10 = ccentropy_add_entropy_internal(*(void *)(a1 + 8), a2, a3, a4, a5);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(a1 + 16));
  return v10;
}

uint64_t ccentropy_lock_reset(uint64_t a1)
{
  os_unfair_lock_lock(*(os_unfair_lock_t *)(a1 + 16));
  uint64_t v2 = ccentropy_reset(*(void *)(a1 + 8));
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(a1 + 16));
  return v2;
}

uint64_t ccmode_gcm_decrypt(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a1 + 96);
  ccmode_gcm_aad_finalize(a1);
  if (*(_WORD *)(a1 + 80) != 3) {
    return 4294967228;
  }
  uint64_t v9 = *(void *)(a1 + 96);
  uint64_t result = 4294967229;
  if (!__CFADD__(v9, a2) && v9 + a2 <= 0xFFFFFFFE0)
  {
    unsigned int v11 = v8 & 0xF;
    if ((v8 & 0xF) != 0)
    {
      uint64_t v12 = 16 - v11;
      if (a2 < v12)
      {
LABEL_18:
        if (!a2) {
          return 0;
        }
        uint64_t v19 = v11;
        uint64_t v20 = a3 - 1;
        uint64_t v21 = a1 + v11 + 15;
        unint64_t v22 = a2;
        do
        {
          *(unsigned char *)(v21 + v22) ^= *(unsigned char *)(v20 + v22);
          --v22;
        }
        while (v22);
        uint64_t v23 = v19 + a1 + 63;
        unint64_t v24 = a2;
        do
        {
          *(unsigned char *)(a4 - 1 + v24) = *(unsigned char *)(v23 + v24) ^ *(unsigned char *)(v20 + v24);
          --v24;
        }
        while (v24);
        uint64_t result = 0;
        *(void *)(a1 + 96) += a2;
        return result;
      }
      uint64_t v13 = v8 & 0xF;
      uint64_t v14 = a3 - 1;
      uint64_t v15 = 16 - v11;
      do
      {
        *(unsigned char *)(v13 + a1 + 15 + v15) ^= *(unsigned char *)(v14 + v15);
        --v15;
      }
      while (v15);
      ccmode_gcm_mult_h(a1, a1 + 16);
      uint64_t v16 = v12;
      do
      {
        *(unsigned char *)(a4 - 1 + v16) = *(unsigned char *)(v13 + a1 + 63 + v16) ^ *(unsigned char *)(v14 + v16);
        --v16;
      }
      while (v16);
      a2 -= v12;
      a3 += v12;
      a4 += v12;
      *(void *)(a1 + 96) += v12;
      ccmode_gcm_update_pad(a1);
    }
    if (a2 >= 0x10)
    {
      do
      {
        for (uint64_t i = 0; i != -16; --i)
          *(unsigned char *)(a1 + i + 31) ^= *(unsigned char *)(a3 + i + 15);
        ccmode_gcm_mult_h(a1, a1 + 16);
        for (uint64_t j = 0; j != -16; --j)
          *(unsigned char *)(a4 + j + 15) = *(unsigned char *)(a1 + j + 79) ^ *(unsigned char *)(a3 + j + 15);
        a2 -= 16;
        a3 += 16;
        a4 += 16;
        *(void *)(a1 + 96) += 16;
        ccmode_gcm_update_pad(a1);
      }
      while (a2 > 0xF);
    }
    unsigned int v11 = 0;
    goto LABEL_18;
  }
  return result;
}

unint64_t *AccelerateCrypto_SHA3_keccak_hwassist(unint64_t *result, int8x16_t _Q0, __n128 _Q1, __n128 _Q2, __n128 _Q3, __n128 _Q4, __n128 _Q5, __n128 _Q6, __n128 _Q7)
{
  _Q0.i64[0] = *result;
  _Q1.n128_u64[0] = result[1];
  _Q2.n128_u64[0] = result[2];
  _Q3.n128_u64[0] = result[3];
  _Q4.n128_u64[0] = result[4];
  _Q5.n128_u64[0] = result[5];
  _Q6.n128_u64[0] = result[6];
  _Q7.n128_u64[0] = result[7];
  *(void *)&_Q8 = result[8];
  *(void *)&_Q9 = result[9];
  *(void *)&_Q10 = result[10];
  *(void *)&_Q11 = result[11];
  *(void *)&_Q12 = result[12];
  *(void *)&_Q13 = result[13];
  *(void *)&_Q14 = result[14];
  *(void *)&_Q15 = result[15];
  *(void *)&_Q16 = result[16];
  *(void *)&_Q17 = result[17];
  *(void *)&_Q18 = result[18];
  *(void *)&_Q19 = result[19];
  *(void *)&_Q20 = result[20];
  *(void *)&_Q21 = result[21];
  *(void *)&_Q22 = result[22];
  *(void *)&_Q23 = result[23];
  *(void *)&_Q24 = result[24];
  uint64_t v26 = 0;
  uint64_t v27 = &qword_2373BB878;
  do
  {
    __asm
    {
      EOR3            V25.16B, V0.16B, V5.16B, V10.16B
      EOR3            V26.16B, V1.16B, V6.16B, V11.16B
      EOR3            V27.16B, V2.16B, V7.16B, V12.16B
      EOR3            V28.16B, V3.16B, V8.16B, V13.16B
      EOR3            V29.16B, V4.16B, V9.16B, V14.16B
      EOR3            V25.16B, V25.16B, V15.16B, V20.16B
      EOR3            V26.16B, V26.16B, V16.16B, V21.16B
      EOR3            V27.16B, V27.16B, V17.16B, V22.16B
      EOR3            V28.16B, V28.16B, V18.16B, V23.16B
      EOR3            V29.16B, V29.16B, V19.16B, V24.16B
      RAX1            V30.2D, V25.2D, V27.2D
      RAX1            V31.2D, V26.2D, V28.2D
      RAX1            V27.2D, V27.2D, V29.2D
      RAX1            V28.2D, V28.2D, V25.2D
      RAX1            V29.2D, V29.2D, V26.2D
      XAR             V25.2D, V1.2D, V30.2D, #0x3F ; '?'
      XAR             V1.2D, V6.2D, V30.2D, #0x14
      XAR             V6.2D, V9.2D, V28.2D, #0x2C ; ','
      XAR             V9.2D, V22.2D, V31.2D, #3
      XAR             V22.2D, V14.2D, V28.2D, #0x19
      XAR             V14.2D, V20.2D, V29.2D, #0x2E ; '.'
      XAR             V20.2D, V2.2D, V31.2D, #2
      XAR             V2.2D, V12.2D, V31.2D, #0x15
      XAR             V12.2D, V13.2D, V27.2D, #0x27 ; '''
      XAR             V13.2D, V19.2D, V28.2D, #0x38 ; '8'
      XAR             V19.2D, V23.2D, V27.2D, #8
      XAR             V23.2D, V15.2D, V29.2D, #0x17
      XAR             V15.2D, V4.2D, V28.2D, #0x25 ; '%'
      XAR             V26.2D, V21.2D, V30.2D, #0x3E ; '>'
      XAR             V8.2D, V8.2D, V27.2D, #9
    }
    _Q0 = veorq_s8(_Q0, _Q29);
    __asm
    {
      BCAX            V21.16B, V8.16B, V23.16B, V22.16B
      XAR             V28.2D, V24.2D, V28.2D, #0x32 ; '2'
      BCAX            V24.16B, V26.16B, V8.16B, V20.16B
      XAR             V18.2D, V18.2D, V27.2D, #0x2B ; '+'
      BCAX            V23.16B, V23.16B, V20.16B, V26.16B
      XAR             V11.2D, V11.2D, V30.2D, #0x36 ; '6'
      BCAX            V20.16B, V20.16B, V22.16B, V8.16B
      XAR             V30.2D, V16.2D, V30.2D, #0x13
      BCAX            V22.16B, V22.16B, V26.16B, V23.16B
      XAR             V16.2D, V5.2D, V29.2D, #0x1C
      XAR             V27.2D, V3.2D, V27.2D, #0x24 ; '$'
      BCAX            V3.16B, V18.16B, V0.16B, V28.16B
      XAR             V29.2D, V10.2D, V29.2D, #0x3D ; '='
      BCAX            V4.16B, V28.16B, V1.16B, V0.16B
      XAR             V10.2D, V17.2D, V31.2D, #0x31 ; '1'
      BCAX            V0.16B, V0.16B, V2.16B, V1.16B
      XAR             V7.2D, V7.2D, V31.2D, #0x3A ; ':'
      BCAX            V1.16B, V1.16B, V18.16B, V2.16B
      BCAX            V2.16B, V2.16B, V28.16B, V18.16B
      BCAX            V17.16B, V11.16B, V19.16B, V10.16B
      BCAX            V18.16B, V10.16B, V15.16B, V19.16B
      BCAX            V19.16B, V19.16B, V16.16B, V15.16B
      BCAX            V15.16B, V15.16B, V11.16B, V16.16B
      BCAX            V16.16B, V16.16B, V10.16B, V11.16B
      BCAX            V10.16B, V25.16B, V12.16B, V7.16B
      BCAX            V11.16B, V7.16B, V13.16B, V12.16B
      BCAX            V12.16B, V12.16B, V14.16B, V13.16B
      BCAX            V13.16B, V13.16B, V25.16B, V14.16B
      BCAX            V14.16B, V14.16B, V7.16B, V25.16B
    }
    *(void *)&_Q26 = *v27;
    __asm
    {
      BCAX            V7.16B, V29.16B, V9.16B, V30.16B
      BCAX            V8.16B, V30.16B, V27.16B, V9.16B
      BCAX            V9.16B, V9.16B, V6.16B, V27.16B
      BCAX            V5.16B, V27.16B, V29.16B, V6.16B
    }
    ++v27;
    __asm { BCAX            V6.16B, V6.16B, V30.16B, V29.16B }
    v26 += 8;
    *(int8x8_t *)_Q0.i8 = veor_s8(*(int8x8_t *)_Q0.i8, *(int8x8_t *)&_Q26);
  }
  while (v26 != 192);
  *uint64_t result = _Q0.i64[0];
  result[1] = _Q1.n128_u64[0];
  result[2] = _Q2.n128_u64[0];
  result[3] = _Q3.n128_u64[0];
  result[4] = _Q4.n128_u64[0];
  result[5] = _Q5.n128_u64[0];
  result[6] = _Q6.n128_u64[0];
  result[7] = _Q7.n128_u64[0];
  result[8] = _Q8;
  result[9] = _Q9;
  result[10] = _Q10;
  result[11] = _Q11;
  result[12] = _Q12;
  result[13] = _Q13;
  result[14] = _Q14;
  result[15] = _Q15;
  result[16] = _Q16;
  result[17] = _Q17;
  result[18] = _Q18;
  result[19] = _Q19;
  result[20] = _Q20;
  result[21] = _Q21;
  result[22] = _Q22;
  result[23] = _Q23;
  result[24] = _Q24;
  return result;
}

unsigned __int8 *ccder_decode_dhparams(uint64_t *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v17 = a3;
  uint64_t v6 = ccdh_gp_n(a1);
  unint64_t v16 = 0;
  BOOL v7 = ccder_decode_constructed_tl(0x2000000000000010, &v17, a2, a3);
  uint64_t v8 = a1 + 3;
  uint64_t v9 = ccder_decode_uint(v6, a1 + 3, v7, v17);
  if (v9 && cczp_init(a1)) {
    return 0;
  }
  unsigned int v11 = ccder_decode_uint(v6, &v8[*a1 + 1 + *a1], v9, v17);
  uint64_t v12 = (const void *)ccdh_lookup_gp(v6, a1 + 3, v6, &v8[*a1 + 1 + *a1]);
  if (v12) {
    ccdh_copy_gp(a1, v12);
  }
  else {
    ccn_zero(v6, &v8[*a1 + 1 + *a1 + *a1]);
  }
  uint64_t v13 = ccder_decode_uint64(&v16, v11, v17);
  if (v13) {
    uint64_t v10 = v13;
  }
  else {
    uint64_t v10 = v11;
  }
  unint64_t v14 = v16;
  v8[*a1 + 1 + *a1 + *a1 + *a1] = v16;
  ccdh_ramp_gp_exponent(v14, a1);
  return v10;
}

unsigned __int8 *ccder_decode_dhparam_n(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unint64_t v3 = 0;
  unint64_t v4 = a2;
  uint64_t result = ccder_decode_constructed_tl(0x2000000000000010, &v4, a1, a2);
  if (result)
  {
    if (ccder_decode_uint_n(&v3, result, v4)) {
      return (unsigned __int8 *)v3;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t ccrsa_decrypt_oaep_blinded_ws(uint64_t a1, uint64_t (**a2)(void, uint64_t, uint64_t), uint64_t *a3, uint64_t *a4, size_t *a5, void *a6, unint64_t a7, uint64_t a8, size_t a9, char *a10)
{
  uint64_t v18 = (unint64_t *)ccrsa_ctx_public(a3);
  unint64_t v19 = ccrsa_block_size(v18);
  uint64_t v20 = 2 * *a4;
  if (v19 < v20 + 2) {
    return 4294967272;
  }
  unint64_t v22 = v19;
  uint64_t result = 4294967273;
  if (v22 <= a7 && *a5 >= v22 - v20 - 2)
  {
    uint64_t v25 = a6;
    uint64_t v23 = *a3;
    uint64_t v26 = *(void *)(a1 + 16);
    unint64_t v24 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, *a3);
    uint64_t result = ccn_read_uint_internal(v23, v24, a7, a8);
    if (!result)
    {
      uint64_t result = ccrsa_priv_crypt_blinded_ws(a1, a2, a3, v24, v24);
      if (!result) {
        uint64_t result = ccrsa_oaep_decode_parameter_ws(a1, a4, a5, v25, v22, (unint64_t *)v24, a9, a10);
      }
    }
    *(void *)(a1 + 16) = v26;
  }
  return result;
}

int64x2_t *AccelerateCrypto_SHA512_compress_hwassist(int64x2_t *result, uint64_t a2, int8x16_t *a3)
{
  if (a2)
  {
    int64x2_t v3 = *result;
    int64x2_t v4 = result[1];
    int64x2_t v5 = result[2];
    int64x2_t v6 = result[3];
    do
    {
      _Q24 = v3;
      _Q25 = v4;
      _Q0 = vrev64q_s8(*a3);
      _Q1 = vrev64q_s8(a3[1]);
      _Q2 = vrev64q_s8(a3[2]);
      _Q3 = vrev64q_s8(a3[3]);
      _Q4 = vrev64q_s8(a3[4]);
      _Q5 = vrev64q_s8(a3[5]);
      _Q6 = vrev64q_s8(a3[6]);
      _Q7 = vrev64q_s8(a3[7]);
      a3 += 8;
      _Q29 = vextq_s8((int8x16_t)v5, (int8x16_t)v6, 8uLL);
      _Q28 = vextq_s8((int8x16_t)v4, (int8x16_t)v5, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }
      int64x2_t v26 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }
      int8x16_t v29 = (int8x16_t)vaddq_s64(v4, v26);
      _Q29 = vextq_s8(v29, (int8x16_t)v5, 8uLL);
      _Q28 = vextq_s8((int8x16_t)v3, v29, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }
      int64x2_t v35 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }
      int8x16_t v38 = (int8x16_t)vaddq_s64(v3, v35);
      _Q29 = vextq_s8(v38, v29, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v38, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }
      int64x2_t v44 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }
      int8x16_t v47 = (int8x16_t)vaddq_s64(_Q27, v44);
      _Q29 = vextq_s8(v47, v38, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v47, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }
      int64x2_t v53 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }
      int8x16_t v56 = (int8x16_t)vaddq_s64(_Q26, v53);
      _Q29 = vextq_s8(v56, v47, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v56, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }
      int64x2_t v62 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }
      int8x16_t v65 = (int8x16_t)vaddq_s64(_Q25, v62);
      _Q29 = vextq_s8(v65, v56, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v65, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }
      int64x2_t v71 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }
      int8x16_t v74 = (int8x16_t)vaddq_s64(_Q24, v71);
      _Q29 = vextq_s8(v74, v65, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v74, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }
      int64x2_t v80 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }
      int8x16_t v83 = (int8x16_t)vaddq_s64(_Q27, v80);
      _Q29 = vextq_s8(v83, v74, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v83, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }
      int64x2_t v89 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }
      int8x16_t v92 = (int8x16_t)vaddq_s64(_Q26, v89);
      _Q29 = vextq_s8(v92, v83, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v92, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }
      int64x2_t v98 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }
      int8x16_t v101 = (int8x16_t)vaddq_s64(_Q25, v98);
      _Q29 = vextq_s8(v101, v92, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v101, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }
      int64x2_t v107 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }
      int8x16_t v110 = (int8x16_t)vaddq_s64(_Q24, v107);
      _Q29 = vextq_s8(v110, v101, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v110, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }
      int64x2_t v116 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }
      int8x16_t v119 = (int8x16_t)vaddq_s64(_Q27, v116);
      _Q29 = vextq_s8(v119, v110, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v119, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }
      int64x2_t v125 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }
      int8x16_t v128 = (int8x16_t)vaddq_s64(_Q26, v125);
      _Q29 = vextq_s8(v128, v119, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v128, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }
      int64x2_t v134 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }
      int8x16_t v137 = (int8x16_t)vaddq_s64(_Q25, v134);
      _Q29 = vextq_s8(v137, v128, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v137, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }
      int64x2_t v143 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }
      int8x16_t v146 = (int8x16_t)vaddq_s64(_Q24, v143);
      _Q29 = vextq_s8(v146, v137, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v146, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }
      int64x2_t v152 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }
      int8x16_t v155 = (int8x16_t)vaddq_s64(_Q27, v152);
      _Q29 = vextq_s8(v155, v146, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v155, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }
      int64x2_t v161 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }
      int8x16_t v164 = (int8x16_t)vaddq_s64(_Q26, v161);
      _Q29 = vextq_s8(v164, v155, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v164, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }
      int64x2_t v170 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }
      int8x16_t v173 = (int8x16_t)vaddq_s64(_Q25, v170);
      _Q29 = vextq_s8(v173, v164, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v173, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }
      int64x2_t v179 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }
      int8x16_t v182 = (int8x16_t)vaddq_s64(_Q24, v179);
      _Q29 = vextq_s8(v182, v173, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v182, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }
      int64x2_t v188 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }
      int8x16_t v191 = (int8x16_t)vaddq_s64(_Q27, v188);
      _Q29 = vextq_s8(v191, v182, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v191, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }
      int64x2_t v197 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }
      int8x16_t v200 = (int8x16_t)vaddq_s64(_Q26, v197);
      _Q29 = vextq_s8(v200, v191, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v200, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }
      int64x2_t v206 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }
      int8x16_t v209 = (int8x16_t)vaddq_s64(_Q25, v206);
      _Q29 = vextq_s8(v209, v200, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v209, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }
      int64x2_t v215 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }
      int8x16_t v218 = (int8x16_t)vaddq_s64(_Q24, v215);
      _Q29 = vextq_s8(v218, v209, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v218, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }
      int64x2_t v224 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }
      int8x16_t v227 = (int8x16_t)vaddq_s64(_Q27, v224);
      _Q29 = vextq_s8(v227, v218, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v227, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }
      int64x2_t v233 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }
      int8x16_t v236 = (int8x16_t)vaddq_s64(_Q26, v233);
      _Q29 = vextq_s8(v236, v227, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v236, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }
      int64x2_t v242 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }
      int8x16_t v245 = (int8x16_t)vaddq_s64(_Q25, v242);
      _Q29 = vextq_s8(v245, v236, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v245, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }
      int64x2_t v251 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }
      int8x16_t v254 = (int8x16_t)vaddq_s64(_Q24, v251);
      _Q29 = vextq_s8(v254, v245, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v254, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }
      int64x2_t v260 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }
      int8x16_t v263 = (int8x16_t)vaddq_s64(_Q27, v260);
      _Q29 = vextq_s8(v263, v254, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v263, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }
      int64x2_t v269 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }
      int8x16_t v272 = (int8x16_t)vaddq_s64(_Q26, v269);
      _Q29 = vextq_s8(v272, v263, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v272, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }
      int64x2_t v278 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }
      int8x16_t v281 = (int8x16_t)vaddq_s64(_Q25, v278);
      _Q29 = vextq_s8(v281, v272, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v281, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }
      int64x2_t v287 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }
      int8x16_t v290 = (int8x16_t)vaddq_s64(_Q24, v287);
      _Q29 = vextq_s8(v290, v281, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v290, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }
      int64x2_t v296 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }
      int8x16_t v299 = (int8x16_t)vaddq_s64(_Q27, v296);
      _Q29 = vextq_s8(v299, v290, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v299, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }
      int64x2_t v305 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }
      int8x16_t v308 = (int8x16_t)vaddq_s64(_Q26, v305);
      _Q29 = vextq_s8(v308, v299, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v308, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q27, Q25, V24.2D
      }
      int8x16_t v313 = (int8x16_t)vaddq_s64(_Q25, _Q30);
      _Q29 = vextq_s8(v313, v308, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v313, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q26, Q24, V27.2D
      }
      int8x16_t v318 = (int8x16_t)vaddq_s64(_Q24, _Q30);
      _Q29 = vextq_s8(v318, v313, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v318, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q25, Q27, V26.2D
      }
      int8x16_t v323 = (int8x16_t)vaddq_s64(_Q27, _Q30);
      _Q29 = vextq_s8(v323, v318, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v323, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q24, Q26, V25.2D
      }
      int8x16_t v328 = (int8x16_t)vaddq_s64(_Q26, _Q30);
      _Q29 = vextq_s8(v328, v323, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v328, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q27, Q25, V24.2D
      }
      int8x16_t v333 = (int8x16_t)vaddq_s64(_Q25, _Q30);
      _Q29 = vextq_s8(v333, v328, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v333, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q26, Q24, V27.2D
      }
      int8x16_t v338 = (int8x16_t)vaddq_s64(_Q24, _Q30);
      _Q29 = vextq_s8(v338, v333, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v338, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q25, Q27, V26.2D
      }
      int64x2_t v343 = vaddq_s64(_Q27, _Q30);
      _Q29 = vextq_s8((int8x16_t)v343, v338, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, (int8x16_t)v343, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q24, Q26, V25.2D
      }
      int64x2_t v3 = vaddq_s64(v3, _Q24);
      int64x2_t v4 = vaddq_s64(v4, _Q25);
      int64x2_t v5 = vaddq_s64(v5, vaddq_s64(_Q26, _Q30));
      int64x2_t v6 = vaddq_s64(v6, v343);
    }
    while (a2-- > 1);
    *uint64_t result = v3;
    result[1] = v4;
    result[2] = v5;
    result[3] = v6;
  }
  return result;
}

uint64_t ccrsa_encrypt_eme_pkcs1v15_ws(uint64_t a1, unint64_t *a2, uint64_t (**a3)(void, size_t, char *), unint64_t *a4, char *a5, size_t a6, void *a7)
{
  unint64_t v14 = ccrsa_block_size(a2);
  uint64_t result = 4294967268;
  if (v14)
  {
    unint64_t v16 = *a2;
    if (*a2)
    {
      if (ccn_n(*a2, (uint64_t)(a2 + 3)) > 1 || a2[3] >= 2)
      {
        if (*a4 >= v14)
        {
          *a4 = v14;
          uint64_t v17 = *(void *)(a1 + 16);
          uint64_t v18 = (_WORD *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v16);
          cc_clear(8 * v16, v18);
          uint64_t result = ccrsa_eme_pkcs1v15_encode_internal(a3, v14, v18, a6, a7);
          if (!result)
          {
            uint64_t result = ccrsa_pub_crypt_ws(a1, a2, (uint64_t *)v18, (unint64_t *)v18);
            if (!result)
            {
              int v19 = ccn_write_uint_padded_ct_internal(v16, (unint64_t *)v18, v14, a5);
              uint64_t result = v19 & (v19 >> 31);
            }
          }
          *(void *)(a1 + 16) = v17;
        }
        else
        {
          return 4294967273;
        }
      }
      else
      {
        return 4294967268;
      }
    }
  }
  return result;
}

uint64_t ccrsa_encrypt_eme_pkcs1v15(unint64_t *a1, uint64_t (**a2)(void, size_t, char *), unint64_t *a3, char *a4, size_t a5, void *a6)
{
  BOOL v22 = timingsafe_enable_if_supported();
  unint64_t v12 = *a1;
  uint64_t v13 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v14 = sizeof_struct_ccpolyzp_po2cyc();
  v20[0] = cc_malloc_clear(8 * ((v13 + v14 - 1) / v14 + 12 * v12) + 8);
  unint64_t v15 = *a1;
  uint64_t v16 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v17 = sizeof_struct_ccpolyzp_po2cyc();
  v20[1] = (v16 + v17 - 1) / v17 + 12 * v15 + 1;
  void v20[2] = 0;
  unsigned char v20[3] = cc_ws_alloc;
  uint64_t v21 = cc_ws_free;
  if (v20[0])
  {
    uint64_t v18 = ccrsa_encrypt_eme_pkcs1v15_ws((uint64_t)v20, a1, a2, a3, a4, a5, a6);
    v21((uint64_t)v20);
  }
  else
  {
    uint64_t v18 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v22);
  return v18;
}

uint64_t fipspost_post_aes_xts(char a1)
{
  uint64_t v12 = *MEMORY[0x263EF8C08];
  int v11 = 0;
  uint64_t v10 = 0;
  int v9 = 41;
  if ((a1 & 0x10) != 0) {
    uint64_t v1 = &unk_2373BB938;
  }
  else {
    uint64_t v1 = &unk_2373BB94A;
  }
  uint64_t v2 = ccaes_xts_encrypt_mode();
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  if (ccxts_one_shot((uint64_t)v2, 16, (uint64_t)v1, (uint64_t)"O\x9B6!r\x8D\x8AgT\x9Ft\xAA\b-X\xEF\x14{\xB2\xA2\x05\x97M\x1E\xFD8h\x85\xB2G\x97", (uint64_t)&v9, 1, (uint64_t)"\x18\x14{\xB2\xA2\x05\x97M\x1E\xFD8h\x85\xB2G\x97", (uint64_t)&v7))
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: encrypt\n");
    return 4294967223;
  }
  if (v7 == 0x15E6D4FF84381AB9 && v8 == 0xFFA95FCBAEAA5A1CLL)
  {
    int64x2_t v5 = ccaes_xts_decrypt_mode();
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    if (ccxts_one_shot((uint64_t)v5, 16, (uint64_t)v1, (uint64_t)"O\x9B6!r\x8D\x8AgT\x9Ft\xAA\b-X\xEF\x14{\xB2\xA2\x05\x97M\x1E\xFD8h\x85\xB2G\x97", (uint64_t)&v9, 1, (uint64_t)"\xB9\x1A8\x84\xFF\xD4\xE6\x15\x1CZ\xAA\xAE\xCB\x5F\xA9\xFF", (uint64_t)&v7))
    {
      mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: decrypt\n");
      return 4294967223;
    }
    if (v7 == 0x4D9705A2B27B1418 && v8 == 0x9747B2856838FD1ELL) {
      return 0;
    }
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: decrypt\n");
  }
  else
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: encrypt\n");
  }
  return 4294967221;
}

void *ccspake_cp_256()
{
  return &ccspake_cp256;
}

void *ccspake_cp_256_rfc()
{
  return &ccspake_cp256_rfc;
}

uint64_t ccn_cond_clear(uint64_t a1, char a2, uint64_t *a3)
{
  uint64_t result = ccn_mux_next_mask();
  for (uint64_t i = __ROR8__(0x5555555555555555, a2 | (2 * result)); a1; --a1)
  {
    uint64_t v8 = *a3;
    uint64_t v9 = *a3 ^ result;
    *a3 = v9;
    *a3++ = v9 ^ v8 & 0x5555555555555555 ^ v8 & i ^ result;
  }
  return result;
}

uint64_t (**ccspake_mac_hkdf_hmac_sha256())()
{
  return &ccspake_mac_hkdf_hmac_sha256_decl;
}

uint64_t (**ccspake_mac_hkdf_hmac_sha512())()
{
  return &ccspake_mac_hkdf_hmac_sha512_decl;
}

uint64_t ccspake_mac_hkdf_hmac_compute(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = *(void *)(a1 + 8);
  if (*(void *)(v7 + 24) != a6) {
    return 4294967289;
  }
  uint64_t v13 = (*(uint64_t (**)(void))v7)();
  cchmac_internal(v13, a2, a3, a4, a5, a7);
  return 0;
}

uint64_t ccdh_check_pub_ws(uint64_t a1, void *a2, void *a3)
{
  uint64_t v6 = ccdh_gp_n(a2);
  if (v6 != ccdh_gp_n(*a3)) {
    return 4294967243;
  }
  uint64_t v7 = ccdh_gp_prime(a2);
  uint64_t v8 = ccdh_gp_prime(*a3);
  if (ccn_cmp_internal(v6, v7, v8)) {
    return 4294967243;
  }
  if ((*(unsigned char *)ccdh_gp_prime(a2) & 1) == 0) {
    return 4294967245;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  int v11 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  uint64_t v12 = (unint64_t *)ccdh_gp_prime(a2);
  if (ccn_sub1(v6, v11, v12, 1uLL)) {
    goto LABEL_7;
  }
  uint64_t v13 = a3 + 2;
  int v14 = ccn_cmp_internal(v6, v13, v11);
  uint64_t result = 4294967247;
  if ((v14 & 0x80000000) == 0 || !v6) {
    goto LABEL_8;
  }
  if (ccn_n(v6, (uint64_t)v13) <= 1 && *v13 < 2
    || ccdh_gp_order_bitlen(a2)
    && ((uint64_t v15 = ccdh_gp_order(a2), cczp_mm_power_fast_ws(a1, a2, v11, v13, v15))
     || ccn_n(v6, (uint64_t)v11) != 1
     || *v11 != 1))
  {
LABEL_7:
    uint64_t result = 4294967247;
  }
  else
  {
    uint64_t result = 0;
  }
LABEL_8:
  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t ccmode_cfb_encrypt(void *a1, uint64_t a2, char *a3, unsigned char *a4)
{
  uint64_t v5 = a1[1];
  if (a2)
  {
    uint64_t v8 = a2;
    uint64_t v9 = *a1;
    unint64_t v10 = (unint64_t)(*(void *)(*a1 + 8) + 7) >> 3;
    int v11 = a1 + 2;
    uint64_t v12 = (uint64_t)&a1[2 * v10 + 2];
    uint64_t v13 = (uint64_t)&a1[v10 + 2];
    do
    {
      if (v5 == *(void *)(v9 + 8))
      {
        (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(v9 + 24))(v12, 1, v13, a1 + 2);
        uint64_t v5 = 0;
      }
      char v14 = *a3++;
      char v15 = *((unsigned char *)v11 + v5);
      *a4++ = v15 ^ v14;
      *(unsigned char *)(v13 + v5++) = v15 ^ v14;
      --v8;
    }
    while (v8);
  }
  a1[1] = v5;
  return 0;
}

double ccmode_factory_xts_decrypt(int64x2_t *a1, void *a2, uint64_t a3)
{
  uint64_t v3 = a2[1];
  v4.i64[0] = 2 * *a2;
  v4.i64[1] = v3;
  *a1 = vaddq_s64((int64x2_t)vandq_s8((int8x16_t)vaddq_s64(v4, (int64x2_t)xmmword_2373AB2C0), (int8x16_t)xmmword_2373AB2D0), (int64x2_t)xmmword_2373AB2E0);
  a1[1].i64[0] = v3;
  a1[1].i64[1] = (uint64_t)ccmode_xts_init;
  a1[2].i64[0] = (uint64_t)ccmode_xts_key_sched;
  a1[2].i64[1] = (uint64_t)ccmode_xts_set_tweak;
  a1[3].i64[0] = (uint64_t)ccmode_xts_crypt;
  a1[3].i64[1] = (uint64_t)a2;
  a1[4].i64[0] = a3;
  *(void *)&double result = 21;
  a1[4].i64[1] = 21;
  return result;
}

uint64_t ccrsa_crt_makekey_ws(uint64_t a1, void *a2)
{
  uint64_t v4 = ccrsa_ctx_private_zp(a2);
  uint64_t v5 = ccrsa_ctx_private_zp(a2);
  uint64_t v6 = v5 + 16 * *(void *)ccrsa_ctx_private_zp(a2) + 32;
  unint64_t v7 = cczp_n((uint64_t)a2);
  unint64_t v8 = cczp_n(v4);
  unint64_t v9 = cczp_n(v6);
  if (v8 < v9 || v8 > (v7 >> 1) + 1) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v11 = v9;
  uint64_t v12 = cczp_prime(v4);
  uint64_t v13 = cczp_prime(v6);
  if ((int)ccn_cmpn_internal(v8, v12, v11, v13) < 1) {
    return 4294967289;
  }
  uint64_t v42 = *(void *)(a1 + 16);
  char v14 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v7 + 2);
  uint64_t __dst = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, (v7 >> 1) + 1);
  int64x2_t v44 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, (v7 >> 1) + 1);
  cc_clear(8 * v7, v14);
  char v15 = (unint64_t *)cczp_prime(v4);
  uint64_t v16 = (unint64_t *)cczp_prime(v6);
  uint64_t v46 = a1;
  char __src = v14;
  ccn_mul_ws(a1, v11, v14, v15, v16);
  uint64_t v45 = v8 - v11;
  if (v8 != v11)
  {
    unint64_t v17 = (uint64_t *)&v14[16 * v11];
    unint64_t v18 = v11;
    int v19 = (unint64_t *)&__src[8 * v11];
    do
    {
      uint64_t v20 = (unint64_t *)cczp_prime(v6);
      uint64_t v21 = cczp_prime(v4);
      *v17++ = ccn_addmul1(v11, v19++, v20, *(void *)(v21 + 8 * v18++));
    }
    while (v8 != v18);
  }
  uint64_t v40 = a2 + 3;
  ccn_set(v7, a2 + 3, __src);
  uint64_t v22 = v46;
  uint64_t result = cczp_init_ws(v46, a2);
  if (!result)
  {
    uint64_t v23 = (void *)cczp_prime(v4);
    ccn_set(v8, __dst, v23);
    unint64_t v24 = (void *)cczp_prime(v6);
    if (v11) {
      ccn_set(v11, v44, v24);
    }
    ccn_zero(v45, &v44[v11]);
    *__dst &= ~1uLL;
    *v44 &= ~1uLL;
    cc_clear(8 * v7, __src);
    ccn_lcm_ws(v46, v8, __src, __dst, v44);
    uint64_t v25 = &v40[2 * *a2 + 1];
    rsize_t __n = &v40[3 * *a2 + 1];
    unint64_t v26 = ccn_n(v7, (uint64_t)v25);
    uint64_t result = ccn_invmod_ws(v46, v7, __n, v26, v25, __src);
    if (result)
    {
      uint64_t v22 = v46;
    }
    else
    {
      uint64_t v27 = ccrsa_ctx_private_zp(a2);
      uint64_t v28 = v27 + 16 * *(void *)ccrsa_ctx_private_zp(a2);
      int8x16_t v29 = (void *)ccrsa_ctx_private_zp(a2);
      ccn_divmod_ws(v46, v7, (uint64_t)__n, 0, 0, v8, (char *)(v28 + 16 * *v29 + 64), __dst);
      uint64_t v30 = ccrsa_ctx_private_zp(a2);
      uint64_t v31 = v30 + 16 * *(void *)ccrsa_ctx_private_zp(a2);
      uint64_t v32 = v31 + 16 * *(void *)ccrsa_ctx_private_zp(a2);
      BOOL v33 = (void *)ccrsa_ctx_private_zp(a2);
      ccn_divmod_ws(v46, v7, (uint64_t)__n, 0, 0, v8, (char *)(v32 + 8 * *v33 + 64), v44);
      uint64_t v34 = ccrsa_ctx_private_zp(a2);
      uint64_t v35 = v34 + 16 * *(void *)ccrsa_ctx_private_zp(a2);
      uint64_t v36 = v35 + 16 * *(void *)ccrsa_ctx_private_zp(a2);
      uint64_t v37 = v36 + 8 * *(void *)ccrsa_ctx_private_zp(a2);
      int8x16_t v38 = (char *)(v37 + 8 * *(void *)ccrsa_ctx_private_zp(a2) + 64);
      unint64_t v39 = (void *)cczp_prime(v6);
      uint64_t v22 = v46;
      if (v11) {
        ccn_set(v11, v38, v39);
      }
      ccn_zero(v45, &v38[8 * v11]);
      ccrsa_ctx_private_zp(a2);
      ccrsa_ctx_private_zp(a2);
      ccrsa_ctx_private_zp(a2);
      ccrsa_ctx_private_zp(a2);
      ccrsa_ctx_private_zp(a2);
      ccrsa_ctx_private_zp(a2);
      ccrsa_ctx_private_zp(a2);
      ccrsa_ctx_private_zp(a2);
      ccrsa_ctx_private_zp(a2);
      ccrsa_ctx_private_zp(a2);
      uint64_t result = cczp_inv_ws(v46, v4);
      if (result) {
        uint64_t result = 4294967263;
      }
    }
  }
  *(void *)(v22 + 16) = v42;
  return result;
}

uint64_t ccec_compressed_x962_import_pub(uint64_t *a1, uint64_t a2, unsigned __int8 *a3, uint64_t **a4)
{
  LODWORD(result) = ccec_x963_import_pub(a1, a2, a3, a4);
  if (result == -7) {
    return 4294967135;
  }
  else {
    return result;
  }
}

void *ccaes_siv_encrypt_mode()
{
  BOOL v0 = ccaes_cbc_encrypt_mode();
  uint64_t v1 = ccaes_ctr_crypt_mode();
  ccmode_factory_siv_encrypt((uint64_t)&siv_encrypt, (uint64_t)v0, (uint64_t)v1);
  return &siv_encrypt;
}

uint64_t ccz_mod(uint64_t a1, void *a2, void *a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  memset(v7, 0, sizeof(v7));
  ccz_init(*(void *)(a1 + 8), (uint64_t)v7);
  ccz_divmod((uint64_t)v7, a1, a2, a3);
  ccz_free((uint64_t)v7);
  return cc_disable_dit_with_sb((unsigned int *)&v8);
}

unint64_t *ccdigest_update_internal(unint64_t *result, void *a2, size_t a3, char *__src)
{
  size_t v5 = a3;
  unint64_t v7 = result;
  unint64_t v8 = result[2];
  uint64_t v9 = (uint64_t)a2 + result[1] + 8;
  if (v8 <= *(unsigned int *)(v9 + v8)) {
    *(_DWORD *)(v9 + v8) = 0;
  }
  if (a3)
  {
    unint64_t v10 = a2 + 1;
    do
    {
      size_t v11 = v7[2];
      uint64_t v12 = (char *)v10 + v7[1];
      uint64_t v13 = *(unsigned int *)&v12[v11];
      if (v5 > v11 && v13 == 0)
      {
        if (v11 == 128)
        {
          size_t v22 = v5 >> 7;
          size_t v16 = v5 & 0xFFFFFFFFFFFFFF80;
        }
        else if (v11 == 64)
        {
          size_t v22 = v5 >> 6;
          size_t v16 = v5 & 0xFFFFFFFFFFFFFFC0;
        }
        else
        {
          size_t v22 = v5 / v11;
          size_t v16 = v5 / v11 * v11;
        }
        uint64_t result = (unint64_t *)((uint64_t (*)(void *, size_t, char *))v7[6])(a2 + 1, v22, __src);
        *a2 += 8 * v16;
      }
      else
      {
        size_t v15 = v11 - v13;
        if (v15 >= v5) {
          size_t v16 = v5;
        }
        else {
          size_t v16 = v15;
        }
        uint64_t result = (unint64_t *)memcpy(&v12[v13], __src, v16);
        unint64_t v17 = v7[2];
        unint64_t v18 = (char *)v10 + v7[1];
        uint64_t v19 = (*(_DWORD *)&v18[v17] + v16);
        *(_DWORD *)&v18[v17] = v19;
        if (v17 == v19)
        {
          uint64_t result = (unint64_t *)((uint64_t (*)(void *, uint64_t))v7[6])(a2 + 1, 1);
          unint64_t v20 = v7[2];
          uint64_t v21 = (char *)v10 + v7[1];
          *a2 += (8 * *(_DWORD *)&v21[v20]);
          *(_DWORD *)&v21[v20] = 0;
        }
      }
      __src += v16;
      v5 -= v16;
    }
    while (v5);
  }
  return result;
}

uint64_t ccdigest_update(unint64_t *a1, void *a2, size_t a3, char *a4)
{
  BOOL v9 = timingsafe_enable_if_supported();
  ccdigest_update_internal(a1, a2, a3, a4);
  return cc_disable_dit_with_sb((unsigned int *)&v9);
}

uint64_t ccec_make_pub_from_priv_ws(uint64_t a1, unint64_t *a2, uint64_t (**a3)(void, uint64_t, unint64_t *), uint64_t a4, uint64_t a5, unint64_t **a6)
{
  *a6 = a2;
  uint64_t v12 = *a2;
  uint64_t v13 = *(void *)(a1 + 16);
  uint64_t v14 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 3 * *a2);
  if (ccec_validate_scalar(a2, a4))
  {
    uint64_t result = 4294967274;
    goto LABEL_10;
  }
  if (a5)
  {
    uint64_t result = ccec_validate_point_and_projectify_ws(a1, (uint64_t *)a2, v14, a5);
    if (result) {
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t result = ccec_projectify_ws(a1, (uint64_t)a2);
    if (result) {
      goto LABEL_10;
    }
  }
  if (ccec_mult_blinded_ws(a1, a2, (uint64_t)(a6 + 2), a4, v14, a3))
  {
    uint64_t result = 4294967280;
  }
  else if (ccec_is_point_projective_ws(a1, a2))
  {
    if (ccec_affinify_ws(a1, (uint64_t)a2))
    {
      uint64_t result = 4294967279;
    }
    else
    {
      ccn_seti(v12, &a6[2 * **a6 + 2], 1);
      uint64_t result = 0;
    }
  }
  else
  {
    uint64_t result = 4294967277;
  }
LABEL_10:
  *(void *)(a1 + 16) = v13;
  return result;
}

uint64_t ccec_curve_for_length_lookup(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  BOOL v16 = timingsafe_enable_if_supported();
  size_t v15 = &a9;
  do
  {
    unint64_t v10 = v15++;
    uint64_t v11 = *v10;
    if (!*v10) {
      break;
    }
    uint64_t v12 = cczp_bitlen(*v10);
  }
  while (v12 != a1 && ((v12 + 7) & 0xFFFFFFFFFFFFFFF8) != a1);
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v11;
}

uint64_t ccec_compact_export(int a1, char *a2, uint64_t *a3)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v6 = ccec_compact_export_pub(a2, a3);
  uint64_t v7 = v6;
  if (a1 && !v6)
  {
    uint64_t v8 = *a3;
    unint64_t v9 = *(void *)*a3;
    unint64_t v10 = (unint64_t)(cczp_bitlen(*a3 + 40 * v9 + 32) + 7) >> 3;
    uint64_t v11 = cczp_bitlen(v8);
    int v12 = ccn_write_uint_padded_ct_internal(v9, (unint64_t *)&a3[3 * v9 + 2], v10, &a2[(unint64_t)(v11 + 7) >> 3]);
    uint64_t v7 = v12 & (v12 >> 31);
  }
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v7;
}

uint64_t ccec_raw_import_pub(uint64_t *a1, uint64_t a2, unsigned __int8 *a3, uint64_t **a4)
{
  if ((((unint64_t)(cczp_bitlen((uint64_t)a1) + 7) >> 2) & 0x3FFFFFFFFFFFFFFELL) != a2) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v7 = *a1;
  unint64_t v8 = (unint64_t)(cczp_bitlen((uint64_t)a1) + 7) >> 3;
  *a4 = a1;
  unint64_t v9 = a4 + 2;
  if (ccn_read_uint_public_value(v7, a4 + 2, v8, a3)
    || ccn_read_uint_public_value(v7, &v9[**a4], v8, &a3[v8]))
  {
    return 0xFFFFFFFFLL;
  }
  ccn_seti(*a1, &v9[2 * **a4], 1);
  return 0;
}

uint64_t ccec_raw_import_priv_only(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t **a4)
{
  BOOL v11 = timingsafe_enable_if_supported();
  if (a2 == (unint64_t)(cczp_bitlen((uint64_t)&a1[5 * *a1 + 4]) + 7) >> 3)
  {
    uint64_t v8 = *a1;
    *a4 = a1;
    memset(a4 + 2, 255, 8 * v8);
    memset(&a4[*a1 + 2], 255, 8 * v8);
    uint64_t uint_internal = ccn_read_uint_internal(v8, &a4[3 * **a4 + 2], a2, a3);
  }
  else
  {
    uint64_t uint_internal = 0xFFFFFFFFLL;
  }
  cc_disable_dit_with_sb((unsigned int *)&v11);
  return uint_internal;
}

double ccmode_factory_siv_decrypt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)&double result = 104;
  *(_OWORD *)a1 = xmmword_2373AB2A0;
  *(void *)(a1 + 16) = ccmode_siv_init;
  *(void *)(a1 + 24) = ccmode_siv_auth;
  *(void *)(a1 + 32) = ccmode_siv_auth;
  *(void *)(a1 + 40) = ccmode_siv_decrypt;
  *(void *)(a1 + 48) = ccmode_siv_reset;
  *(void *)(a1 + 56) = a2;
  *(void *)(a1 + 64) = a3;
  return result;
}

uint64_t ccdes3_ltc_setup(uint64_t a1, _OWORD *a2, uint64_t a3, char *a4)
{
  if (a3 != 24) {
    return 0xFFFFFFFFLL;
  }
  deskey((uint64_t)a4, 0, a2);
  deskey((uint64_t)(a4 + 8), 1, a2 + 8);
  deskey((uint64_t)(a4 + 16), 0, a2 + 16);
  deskey((uint64_t)a4, 1, a2 + 40);
  deskey((uint64_t)(a4 + 8), 0, a2 + 32);
  deskey((uint64_t)(a4 + 16), 1, a2 + 24);
  if (cc_cmp_safe_internal(8, a4, a4 + 8)
    && cc_cmp_safe_internal(8, a4, a4 + 16)
    && cc_cmp_safe_internal(8, a4 + 8, a4 + 16))
  {
    return 0;
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

uint64_t ccss_shamir_share_bag_set_ith_share(void *a1, unsigned int a2, uint64_t a3)
{
  uint64_t result = ccss_shamir_consistent_primes(*a1 + 8, *(void *)a3);
  if (!result)
  {
    if (*(_DWORD *)*a1 <= a2)
    {
      return 4294967165;
    }
    else
    {
      int v7 = *(_DWORD *)(a3 + 8);
      return ccss_shamir_share_bag_set_ith_share_with_xy(a1, a2, v7, (void *)(a3 + 16));
    }
  }
  return result;
}

uint64_t ccss_shamir_share_bag_set_ith_share_with_xy(void *a1, unsigned int a2, int a3, void *a4)
{
  uint64_t v8 = cczp_n(*a1 + 8);
  unint64_t v9 = (_DWORD *)*a1;
  if (*(_DWORD *)*a1 <= a2) {
    return 4294967165;
  }
  unint64_t v10 = &a1[a2 * v8 + a2];
  *((_DWORD *)v10 + 4) = a3;
  BOOL v11 = v10 + 3;
  uint64_t v12 = cczp_n((uint64_t)(v9 + 2));
  ccn_set(v12, v11, a4);
  return 0;
}

uint64_t ccss_shamir_share_bag_copy_ith_share_x(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 8) - 1 < a2) {
    cc_abort();
  }
  return *(unsigned int *)(a1 + 8 * (a2 * cczp_n(*(void *)a1 + 8) + a2) + 16);
}

uint64_t ccss_shamir_share_bag_ith_share_y(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 8) - 1 < a2) {
    cc_abort();
  }
  return a1 + 8 * (a2 * cczp_n(*(void *)a1 + 8) + a2) + 24;
}

uint64_t ccss_shamir_share_import(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  char v6 = 0;
  char v14 = 0;
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    if ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) & 0x1000000) != 0)
    {
      char v6 = 0;
    }
    else
    {
      __asm { MSR             DIT, #1 }
      char v6 = 1;
    }
  }
  char v14 = v6;
  uint64_t v12 = ccss_encode_string_into_value_smaller_than_prime(*(void *)a1, (void *)(a1 + 16), a4, a3);
  if (!v12) {
    *(_DWORD *)(a1 + 8) = a2;
  }
  cc_disable_dit(&v14);
  return v12;
}

uint64_t ccss_shamir_share_sizeof_y(uint64_t *a1)
{
  char v1 = 0;
  char v9 = 0;
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    if ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) & 0x1000000) != 0)
    {
      char v1 = 0;
    }
    else
    {
      __asm { MSR             DIT, #1 }
      char v1 = 1;
    }
  }
  char v9 = v1;
  uint64_t v7 = 8 * cczp_n(*a1);
  cc_disable_dit(&v9);
  return v7;
}

uint64_t ccss_shamir_share_export(uint64_t a1, _DWORD *a2, char *a3, unint64_t a4)
{
  char v8 = 0;
  char v18 = 0;
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    if ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) & 0x1000000) != 0)
    {
      char v8 = 0;
    }
    else
    {
      __asm { MSR             DIT, #1 }
      char v8 = 1;
    }
  }
  char v18 = v8;
  unint64_t v14 = cczp_n(*(void *)a1);
  if (ccn_write_uint_size_public_value(v14, (unint64_t *)(a1 + 16)) <= a4)
  {
    unint64_t v16 = cczp_n(*(void *)a1);
    ccn_write_uint_padded_ct_internal(v16, (unint64_t *)(a1 + 16), a4, a3);
    uint64_t v15 = 0;
    *a2 = *(_DWORD *)(a1 + 8);
  }
  else
  {
    uint64_t v15 = 4294967289;
  }
  cc_disable_dit(&v18);
  return v15;
}

uint64_t ccrsa_verify_pkcs1v15_allowshortsigs(unint64_t *a1, uint64_t a2, unint64_t a3, char *a4, unint64_t a5, uint64_t a6, unsigned char *a7)
{
  void v18[2] = *MEMORY[0x263EF8C08];
  BOOL v17 = timingsafe_enable_if_supported();
  *a7 = 0;
  v18[0] = 0;
  v18[1] = 0;
  unsigned int v14 = ccrsa_verify_pkcs1v15_internal(a1, a2, a3, a4, a5, a6, 2110636126, (unsigned __int8 *)v18);
  if (v14)
  {
    if (v14 == -146) {
      uint64_t v15 = 0;
    }
    else {
      uint64_t v15 = v14;
    }
  }
  else
  {
    uint64_t v15 = 0;
    *a7 = 1;
  }
  cc_disable_dit_with_sb((unsigned int *)&v17);
  return v15;
}

void *ccmode_factory_cfb_encrypt(void *result, void *a2)
{
  *uint64_t result = ((2 * a2[1] + 14) & 0xFFFFFFFFFFFFFFF0) + ((*a2 + 7) & 0xFFFFFFFFFFFFFFF8) + 16;
  result[1] = 1;
  result[2] = ccmode_cfb_init;
  result[3] = ccmode_cfb_encrypt;
  result[4] = a2;
  return result;
}

uint64_t ccec_generate_key_internal_legacy_ws(uint64_t a1, uint64_t *a2, uint64_t (**a3)(void, size_t, void *), unint64_t **a4)
{
  uint64_t v8 = *a2;
  *a4 = (unint64_t *)a2;
  uint64_t v9 = *(void *)(a1 + 16);
  unint64_t v10 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8);
  size_t v11 = 8 * v8;
  uint64_t result = (*a3)(a3, v11, v10);
  if (!result)
  {
    uint64_t result = ccec_generate_scalar_legacy_ws(a1, a2, v11, v10, &a4[3 * **a4 + 2]);
    if (!result) {
      uint64_t result = ccec_make_pub_from_priv_ws(a1, (unint64_t *)a2, 0, (uint64_t)&a4[3 * **a4 + 2], 0, a4);
    }
  }
  *(void *)(a1 + 16) = v9;
  return result;
}

uint64_t cckem_generate_key(uint64_t a1, uint64_t a2)
{
  BOOL v6 = timingsafe_enable_if_supported();
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 32))(a1, a2);
  cc_disable_dit_with_sb((unsigned int *)&v6);
  return v4;
}

uint64_t cckem_derive_key_from_seed(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 40))(a1, a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t cckem_encapsulate(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v15 = timingsafe_enable_if_supported();
  uint64_t v12 = *a1;
  if (*(void *)(*a1 + 16) == a2 && *(void *)(v12 + 24) == a4) {
    uint64_t v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(v12 + 48))(a1, a3, a5, a6);
  }
  else {
    uint64_t v13 = 4294967289;
  }
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v13;
}

uint64_t cckem_encapsulated_key_nbytes_ctx(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 16);
}

uint64_t cckem_shared_key_nbytes_ctx(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 24);
}

uint64_t cckem_decapsulate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  if (*(void *)(*(void *)cckem_public_ctx(a1) + 16) == a2
    && *(void *)(*(void *)cckem_public_ctx(a1) + 24) == a4)
  {
    uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 56))(a1, a3, a5);
  }
  else
  {
    uint64_t v10 = 4294967289;
  }
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t cckem_export_pubkey(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
}

uint64_t cckem_import_pubkey(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 72))();
}

uint64_t cckem_export_privkey(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return v6;
}

uint64_t cckem_import_privkey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 88))(a1, a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t cckem_pubkey_nbytes_info(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t cckem_pubkey_nbytes_ctx(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 8);
}

uint64_t cckem_privkey_nbytes_info(void *a1)
{
  return *a1 - a1[1];
}

uint64_t cckem_privkey_nbytes_ctx(uint64_t a1)
{
  return **(void **)a1 - *(void *)(*(void *)a1 + 8);
}

uint64_t cckem_encapsulated_key_nbytes_info(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t cckem_shared_key_nbytes_info(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t ge_frombytes_vartime(int *a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x263EF8C08];
  uint64_t v15 = 0;
  memset(v14, 0, sizeof(v14));
  uint64_t v13 = 0;
  memset(v12, 0, sizeof(v12));
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  uint64_t v7 = 0;
  uint64_t v4 = a1 + 10;
  memset(v6, 0, sizeof(v6));
  fe_frombytes(a1 + 10, (unsigned int *)a2);
  fe_1((uint64_t)(a1 + 20));
  fe_sq(v14, v4);
  fe_mul(v12, (int *)v14, d);
  fe_sub((uint64_t)v14, (uint64_t)v14, (uint64_t)(a1 + 20));
  fe_add((uint64_t)v12, (uint64_t)v12, (uint64_t)(a1 + 20));
  fe_sq(v10, (int *)v12);
  fe_mul(v10, (int *)v10, (int *)v12);
  fe_sq(a1, (int *)v10);
  fe_mul(a1, a1, (int *)v12);
  fe_mul(a1, a1, (int *)v14);
  fe_pow22523(a1, a1);
  fe_mul(a1, a1, (int *)v10);
  fe_mul(a1, a1, (int *)v14);
  fe_sq(v8, a1);
  fe_mul(v8, (int *)v8, (int *)v12);
  fe_sub((uint64_t)v6, (uint64_t)v8, (uint64_t)v14);
  if (fe_isnonzero(v6))
  {
    fe_add((uint64_t)v6, (uint64_t)v8, (uint64_t)v14);
    if (fe_isnonzero(v6)) {
      return 0xFFFFFFFFLL;
    }
    fe_mul(a1, a1, sqrtm1);
  }
  if (fe_isnegative(a1) != *(unsigned __int8 *)(a2 + 31) >> 7) {
    fe_neg((uint64_t)a1, (uint64_t)a1);
  }
  fe_mul(a1 + 30, a1, v4);
  return 0;
}

uint64_t ge_from_uniform(uint64_t a1, _OWORD *a2)
{
  uint64_t v45 = *MEMORY[0x263EF8C08];
  uint64_t v32 = 0;
  memset(v31, 0, sizeof(v31));
  uint64_t v30 = 0;
  memset(v29, 0, sizeof(v29));
  uint64_t v28 = 0;
  memset(v27, 0, sizeof(v27));
  uint64_t v26 = 0;
  memset(v25, 0, sizeof(v25));
  uint64_t v24 = 0;
  memset(v23, 0, sizeof(v23));
  uint64_t v22 = 0;
  memset(v21, 0, sizeof(v21));
  memset(v18, 0, sizeof(v18));
  memset(v17, 0, sizeof(v17));
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  long long v3 = a2[1];
  *(_OWORD *)a1 = *a2;
  *(_OWORD *)(a1 + 16) = v3;
  char v4 = *(unsigned char *)(a1 + 31);
  *(unsigned char *)(a1 + 31) = v4 & 0x7F;
  fe_frombytes(v27, (unsigned int *)a1);
  fe_sq2(v27, (int *)v27);
  ++LODWORD(v27[0]);
  fe_invert(v27, (int *)v27);
  fe_mul(v25, (int *)curve25519_A, (int *)v27);
  fe_neg((uint64_t)v25, (uint64_t)v25);
  fe_sq(v23, (int *)v25);
  fe_mul(v21, (int *)v25, (int *)v23);
  fe_add((uint64_t)v31, (uint64_t)v21, (uint64_t)v25);
  fe_mul(v23, (int *)v23, (int *)curve25519_A);
  fe_add((uint64_t)v31, (uint64_t)v23, (uint64_t)v31);
  uint64_t v44 = 0;
  long long v42 = 0u;
  long long v43 = 0u;
  uint64_t v41 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  uint64_t v38 = 0;
  long long v36 = 0u;
  long long v37 = 0u;
  uint64_t v35 = 0;
  long long v33 = 0u;
  long long v34 = 0u;
  fe_sq(&v42, (int *)v31);
  fe_mul(&v39, (int *)&v42, (int *)v31);
  fe_sq(&v42, (int *)&v39);
  fe_sq(&v36, (int *)&v42);
  fe_sq(&v36, (int *)&v36);
  fe_mul(&v36, (int *)&v36, (int *)&v42);
  fe_mul(&v39, (int *)&v36, (int *)v31);
  fe_sq(&v36, (int *)&v39);
  int v5 = 4;
  do
  {
    fe_sq(&v36, (int *)&v36);
    --v5;
  }
  while (v5);
  fe_mul(&v39, (int *)&v36, (int *)&v39);
  fe_sq(&v36, (int *)&v39);
  int v6 = 9;
  do
  {
    fe_sq(&v36, (int *)&v36);
    --v6;
  }
  while (v6);
  fe_mul(&v36, (int *)&v36, (int *)&v39);
  fe_sq(&v33, (int *)&v36);
  int v7 = 19;
  do
  {
    fe_sq(&v33, (int *)&v33);
    --v7;
  }
  while (v7);
  fe_mul(&v36, (int *)&v33, (int *)&v36);
  fe_sq(&v36, (int *)&v36);
  int v8 = 9;
  do
  {
    fe_sq(&v36, (int *)&v36);
    --v8;
  }
  while (v8);
  fe_mul(&v39, (int *)&v36, (int *)&v39);
  fe_sq(&v36, (int *)&v39);
  int v9 = 49;
  do
  {
    fe_sq(&v36, (int *)&v36);
    --v9;
  }
  while (v9);
  fe_mul(&v36, (int *)&v36, (int *)&v39);
  fe_sq(&v33, (int *)&v36);
  int v10 = 99;
  do
  {
    fe_sq(&v33, (int *)&v33);
    --v10;
  }
  while (v10);
  fe_mul(&v36, (int *)&v33, (int *)&v36);
  fe_sq(&v36, (int *)&v36);
  int v11 = 49;
  do
  {
    fe_sq(&v36, (int *)&v36);
    --v11;
  }
  while (v11);
  fe_mul(&v39, (int *)&v36, (int *)&v39);
  fe_sq(&v39, (int *)&v39);
  int v12 = 3;
  do
  {
    fe_sq(&v39, (int *)&v39);
    --v12;
  }
  while (v12);
  fe_mul(v31, (int *)&v39, (int *)&v42);
  fe_tobytes(a1, v31);
  int v13 = *(unsigned char *)(a1 + 1) & 1;
  fe_neg((uint64_t)v29, (uint64_t)v25);
  fe_cmov((uint64_t *)v25, (uint64_t *)v29, v13);
  fe_0((uint64_t)v23);
  fe_cmov((uint64_t *)v23, curve25519_A, v13);
  fe_sub((uint64_t)v25, (uint64_t)v25, (uint64_t)v23);
  uint64_t v44 = 0;
  long long v42 = 0u;
  long long v43 = 0u;
  uint64_t v41 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  uint64_t v38 = 0;
  long long v36 = 0u;
  long long v37 = 0u;
  uint64_t v35 = 0;
  long long v33 = 0u;
  long long v34 = 0u;
  uint64_t v20 = 0;
  memset(v19, 0, sizeof(v19));
  fe_1((uint64_t)&v42);
  fe_add((uint64_t)&v39, (uint64_t)v25, (uint64_t)&v42);
  fe_sub((uint64_t)&v33, (uint64_t)v25, (uint64_t)&v42);
  fe_invert(&v36, (int *)&v39);
  fe_mul(v19, (int *)&v33, (int *)&v36);
  fe_tobytes(a1, v19);
  *(unsigned char *)(a1 + 31) |= v4 & 0x80;
  ge_frombytes_vartime((int *)v18, a1);
  ge_p3_dbl(v17, (uint64_t)v18);
  ge_p1p1_to_p2(v15, (int *)v17);
  ge_p2_dbl(v17, (int *)v15);
  ge_p1p1_to_p2(v15, (int *)v17);
  ge_p2_dbl(v17, (int *)v15);
  ge_p1p1_to_p3(v18, (int *)v17);
  return ge_p3_tobytes(a1, (int *)v18);
}

uint64_t ge_scalarmult(_DWORD *a1, int8x16_t *a2, uint64_t a3)
{
  uint64_t v43 = *MEMORY[0x263EF8C08];
  memset(v32, 0, sizeof(v32));
  uint64_t v31 = 0;
  memset(v30, 0, sizeof(v30));
  memset(v29, 0, sizeof(v29));
  memset(v28, 0, sizeof(v28));
  memset(v27, 0, sizeof(v27));
  memset(v26, 0, sizeof(v26));
  memset(v25, 0, sizeof(v25));
  memset(v24, 0, sizeof(v24));
  memset(v23, 0, sizeof(v23));
  memset(v22, 0, sizeof(v22));
  memset(v21, 0, sizeof(v21));
  memset(v20, 0, sizeof(v20));
  memset(v19, 0, sizeof(v19));
  memset(v18, 0, sizeof(v18));
  memset(v17, 0, sizeof(v17));
  memset(v16, 0, sizeof(v16));
  memset(v15, 0, sizeof(v15));
  ge_p3_to_cached((uint64_t)v33, a3);
  ge_p3_dbl(v29, a3);
  ge_p1p1_to_p3(v22, (int *)v29);
  ge_p3_to_cached((uint64_t)v34, (uint64_t)v22);
  ge_add((int *)v28, a3, v34);
  ge_p1p1_to_p3(v21, (int *)v28);
  ge_p3_to_cached((uint64_t)&v35, (uint64_t)v21);
  ge_p3_dbl(v27, (uint64_t)v22);
  ge_p1p1_to_p3(v20, (int *)v27);
  ge_p3_to_cached((uint64_t)v36, (uint64_t)v20);
  ge_add((int *)v26, a3, v36);
  ge_p1p1_to_p3(v19, (int *)v26);
  ge_p3_to_cached((uint64_t)&v37, (uint64_t)v19);
  ge_p3_dbl(v25, (uint64_t)v21);
  ge_p1p1_to_p3(v18, (int *)v25);
  ge_p3_to_cached((uint64_t)v38, (uint64_t)v18);
  ge_add((int *)v24, a3, v38);
  ge_p1p1_to_p3(v17, (int *)v24);
  ge_p3_to_cached((uint64_t)&v39, (uint64_t)v17);
  ge_p3_dbl(v23, (uint64_t)v20);
  ge_p1p1_to_p3(v16, (int *)v23);
  ge_p3_to_cached((uint64_t)&v40, (uint64_t)v16);
  uint64_t v6 = 0;
  v7.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v7.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  do
  {
    int8x16_t v8 = *a2++;
    v44.val[0] = vandq_s8(v8, v7);
    v44.val[1] = (int8x16_t)vshrq_n_u8((uint8x16_t)v8, 4uLL);
    int v9 = &v41[v6];
    vst2q_s8(v9, v44);
    v6 += 32;
  }
  while (v6 != 64);
  uint64_t v10 = 0;
  int v11 = 0;
  do
  {
    int v12 = v41[v10] + v11;
    int v11 = (v12 + 8) << 24 >> 28;
    v41[v10++] = v12 - ((v12 + 8) & 0xF0);
  }
  while (v10 != 63);
  v42 += v11;
  ge_p3_0((uint64_t)a1);
  uint64_t v13 = 63;
  do
  {
    ge_select_cached((uint64_t *)v15, v33, (char)v41[v13]);
    ge_add((int *)v32, (uint64_t)a1, (int *)v15);
    ge_p1p1_to_p2(v30, (int *)v32);
    ge_p2_dbl(v32, (int *)v30);
    ge_p1p1_to_p2(v30, (int *)v32);
    ge_p2_dbl(v32, (int *)v30);
    ge_p1p1_to_p2(v30, (int *)v32);
    ge_p2_dbl(v32, (int *)v30);
    ge_p1p1_to_p2(v30, (int *)v32);
    ge_p2_dbl(v32, (int *)v30);
    ge_p1p1_to_p3(a1, (int *)v32);
    --v13;
  }
  while (v13);
  ge_select_cached((uint64_t *)v15, v33, v41[0]);
  ge_add((int *)v32, (uint64_t)a1, (int *)v15);
  return ge_p1p1_to_p3(a1, (int *)v32);
}

uint64_t ge_select_cached(uint64_t *a1, uint64_t *a2, int a3)
{
  memset(v9, 0, sizeof(v9));
  int v5 = (a3 >> 7) & 1;
  int v6 = a3 - 2 * (a3 & (a3 >> 31));
  memset(v8, 0, sizeof(v8));
  fe_1((uint64_t)a1);
  fe_1((uint64_t)(a1 + 5));
  fe_1((uint64_t)(a1 + 10));
  fe_0((uint64_t)(a1 + 15));
  ge_cmov_cached(a1, a2, (v6 ^ 1) - 1 < 0);
  ge_cmov_cached(a1, a2 + 20, (v6 ^ 2) - 1 < 0);
  ge_cmov_cached(a1, a2 + 40, (v6 ^ 3) - 1 < 0);
  ge_cmov_cached(a1, a2 + 60, (v6 ^ 4) - 1 < 0);
  ge_cmov_cached(a1, a2 + 80, (v6 ^ 5) - 1 < 0);
  ge_cmov_cached(a1, a2 + 100, (v6 ^ 6) - 1 < 0);
  ge_cmov_cached(a1, a2 + 120, (v6 ^ 7) - 1 < 0);
  ge_cmov_cached(a1, a2 + 140, (v6 ^ 8) - 1 < 0);
  fe_copy((uint64_t)v8, (uint64_t)(a1 + 5));
  fe_copy((uint64_t)&v8[2] + 8, (uint64_t)a1);
  fe_copy((uint64_t)v9, (uint64_t)(a1 + 10));
  fe_neg((uint64_t)&v9[2] + 8, (uint64_t)(a1 + 15));
  return ge_cmov_cached(a1, (uint64_t *)v8, v5);
}

uint64_t ge_scalarmult_cofactor(_DWORD *a1)
{
  memset(v5, 0, sizeof(v5));
  uint64_t v4 = 0;
  memset(v3, 0, sizeof(v3));
  ge_p3_dbl(v5, (uint64_t)a1);
  ge_p1p1_to_p2(v3, (int *)v5);
  ge_p2_dbl(v5, (int *)v3);
  ge_p1p1_to_p2(v3, (int *)v5);
  ge_p2_dbl(v5, (int *)v3);
  return ge_p1p1_to_p3(a1, (int *)v5);
}

uint64_t ge_has_small_order(uint64_t a1)
{
  uint64_t v1 = 0;
  memset(v14, 0, 7);
  uint64_t v2 = &ge_has_small_order_small_order_blocklist;
  do
  {
    uint64_t v3 = 0;
    char v4 = *(unsigned char *)(a1 + v1);
    int v5 = v2;
    do
    {
      char v6 = *v5;
      v5 += 32;
      v14[v3++] |= v6 ^ v4;
    }
    while (v3 != 7);
    ++v1;
    ++v2;
  }
  while (v1 != 31);
  uint64_t v7 = 0;
  char v8 = *(unsigned char *)(a1 + 31) & 0x7F;
  int v9 = &byte_2373BB9FF;
  do
  {
    char v10 = *v9;
    v9 += 32;
    v14[v7++] |= v8 ^ v10;
  }
  while (v7 != 7);
  uint64_t v11 = 0;
  unsigned int v12 = 0;
  do
    v12 |= v14[v11++] - 1;
  while (v11 != 7);
  return (v12 >> 8) & 1;
}

uint64_t ge_cmov_cached(uint64_t *a1, uint64_t *a2, char a3)
{
  fe_cmov(a1, a2, a3);
  fe_cmov(a1 + 5, a2 + 5, a3);
  fe_cmov(a1 + 10, a2 + 10, a3);

  return fe_cmov(a1 + 15, a2 + 15, a3);
}

uint64_t fipspost_post_aes_cbc(char a1)
{
  uint64_t v30 = *MEMORY[0x263EF8C08];
  uint64_t v1 = "2]\xE3\x14\xE9)\xED\x08\x97\x87\x05\xD1\xEB3";
  uint64_t v19 = 16;
  uint64_t v21 = "4I\x1B&m\x8F\xB5L\\\xE1\xA9\xFB\xF1\x7B\x09\x8C";
  uint64_t v22 = "\x9B\xC2\x0B)Q\xFFr\xD3\xF2\x80\xFF;\xD2\xDC=\xCC\x06\xFE\x99qc\xCB\xCBU\x85>(Wt\x9D";
  if ((a1 & 0x10) != 0) {
    uint64_t v1 = "\x012]\xE3\x14\xE9)\xED\x08\x97\x87\x05\xD1\xEB3";
  }
  char v2 = 1;
  int v20 = 1;
  uint64_t v23 = "\x06\xFE\x99qc\xCB\xCBU\x85>(Wt\x9D";
  v24[0] = v1;
  uint64_t v3 = "\x9Ef\x1D\xB3\x809 \x9Ar\xC7\xD2\x96@f\x88\xF2PSPOST_USER [%llu] %s:%d: FAILED: test %d\n";
  if ((a1 & 0x10) != 0) {
    uint64_t v3 = "\x01\x9Ef\x1D\xB3\x809 \x9Ar\xC7\xD2\x96@f\x88\xF2\x1D\xB3\x809 \x9Ar\xC7\xD2\x96@f\x88\xF2PSPOST_USER [%llu] %s:%d: FAILED: test %d\n";
  }
  v24[1] = 16;
  int v25 = 0;
  uint64_t v26 = "N\xB2\xCA\x2A\x11\x94";
  uint64_t v27 = "\x11\xA1\xBD\":\xCF\x68\xE1\x96\x4C\x18\x9B";
  uint64_t v28 = "\xAA6W\x9B\fr\xC5\x28\x16{p\x12\xD7\xFA\xF0\xDE\x9Ef\x1D\xB3\x809 \x9Ar\xC7\xD2\x96@f\x88\xF2\x1D\xB3\x809 \x9Ar"
        "\xC7\xD2\x96@f\x88\xF2PSPOST_USER [%llu] %s:%d: FAILED: test %d\n";
  int8x16_t v29 = v3;
  char v4 = ccaes_cbc_encrypt_mode();
  int v5 = ccaes_cbc_decrypt_mode();
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  while (1)
  {
    char v8 = v2;
    int v9 = &v19 + 6 * v6;
    uint64_t v10 = (uint64_t)(*((_DWORD *)v9 + 2) ? v4 : v5);
    if (cccbc_one_shot(v10, *v9, v9[2], (const void *)v9[3], 1, v9[4], (uint64_t)v18)) {
      break;
    }
    uint64_t v11 = (uint64_t *)v24[6 * v6];
    uint64_t v13 = *v11;
    uint64_t v12 = v11[1];
    if (v13 != v18[0] || v12 != v18[1])
    {
      uint64_t v15 = mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: AES-CBC KAT Failed %d\n", v15, "fipspost_post_aes_cbc", 96, 2 * v6);
      uint64_t v7 = v7 | 0xFFFFFFB5;
    }
    char v2 = 0;
    uint64_t v6 = 1;
    if ((v8 & 1) == 0) {
      return v7;
    }
  }
  uint64_t v16 = mach_absolute_time();
  printf("FIPSPOST_USER [%llu] %s:%d: FAILED: test %d\n", v16, "fipspost_post_aes_cbc", 87, 2 * v6);
  return 4294967223;
}

uint64_t cczp_mm_redc_ws(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8 = cczp_n((uint64_t)a2);
  uint64_t v9 = v8;
  if (v8)
  {
    uint64_t v10 = a2[*a2 + 3];
    uint64_t v11 = (unint64_t *)a4;
    uint64_t v12 = v8;
    do
    {
      uint64_t v13 = (unint64_t *)cczp_prime((uint64_t)a2);
      *uint64_t v11 = ccn_addmul1(v9, v11, v13, *v11 * v10);
      ++v11;
      --v12;
    }
    while (v12);
  }
  char v14 = ccn_add_ws(a1, v9, &a4[v9], &a4[v9], a4);
  uint64_t v15 = (unint64_t *)cczp_prime((uint64_t)a2);
  char v16 = ccn_sub_ws(a1, v9, a4, &a4[v9], v15) ^ v14;

  return ccn_mux(v9, v16, a3, &a4[v9], a4);
}

uint64_t fipspost_post_aes_ecb(char a1)
{
  uint64_t v13 = *MEMORY[0x263EF8C08];
  char v2 = ccaes_ecb_encrypt_mode();
  if ((a1 & 0x10) != 0) {
    uint64_t v3 = &invalid_key_0;
  }
  else {
    uint64_t v3 = &valid_key_0;
  }
  if (ccecb_one_shot((uint64_t)v2, 16, (uint64_t)v3, 1, (uint64_t)plaintext_data_0, (uint64_t)v12))
  {
    uint64_t v4 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: aes_ecb_encrypt one_shot\n", v4, "fipspost_post_aes_ecb_encrypt", 36);
    int v5 = -73;
  }
  else if (cc_cmp_safe(16, v12, ciphertext_data_0))
  {
    uint64_t v6 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: aes_ecb_encrypt cmp\n", v6, "fipspost_post_aes_ecb_encrypt", 41);
    int v5 = -75;
  }
  else
  {
    int v5 = 0;
  }
  uint64_t v7 = ccaes_ecb_decrypt_mode();
  if (ccecb_one_shot((uint64_t)v7, 16, (uint64_t)v3, 1, (uint64_t)ciphertext_data_0, (uint64_t)v12))
  {
    uint64_t v8 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: aes_ecb_decrypt one_shot\n", v8, "fipspost_post_aes_ecb_decrypt", 59);
    int v9 = -73;
  }
  else if (cc_cmp_safe(16, v12, plaintext_data_0))
  {
    uint64_t v10 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: aes_ecb_decrypt cmp\n", v10, "fipspost_post_aes_ecb_decrypt", 64);
    int v9 = -75;
  }
  else
  {
    int v9 = 0;
  }
  return v9 | v5;
}

void *ccdh_gp_rfc3526group15()
{
  return &_ccdh_gp_rfc3526group15;
}

uint64_t cccast_ecb_encrypt(uint64_t a1, uint64_t a2, unsigned int *a3, _DWORD *a4)
{
  uint64_t v14 = *MEMORY[0x263EF8C08];
  if (a2)
  {
    uint64_t v6 = a2;
    do
    {
      --v6;
      unsigned int v8 = *a3;
      unsigned int v9 = a3[1];
      a3 += 2;
      unsigned int v12 = bswap32(v8);
      unsigned int v13 = bswap32(v9);
      CC_CAST_encrypt((int *)&v12, a1);
      unsigned int v10 = bswap32(v13);
      *a4 = bswap32(v12);
      a4[1] = v10;
      a4 += 2;
    }
    while (v6);
  }
  return 0;
}

void *ccaes_siv_hmac_sha256_encrypt_mode()
{
  BOOL v0 = ccsha256_di();
  uint64_t v1 = ccaes_ctr_crypt_mode();
  ccmode_factory_siv_hmac_encrypt((uint64_t)&siv_hmac_encrypt, (uint64_t)v0, (uint64_t)v1);
  return &siv_hmac_encrypt;
}

uint64_t ccder_blob_encode_octet_string(uint64_t *a1, unint64_t a2, unint64_t *a3)
{
  return ccder_blob_encode_implicit_octet_string(a1, 4uLL, a2, a3);
}

uint64_t ccder_sizeof_uint64(unint64_t a1)
{
  return ccder_sizeof_implicit_uint64(2, a1);
}

unint64_t CCHE_CIPHERTEXT_MOD_SWITCH_DOWN_WORKSPACE_N(unsigned int a1, int a2)
{
  unint64_t result = CCPOLYZP_PO2CYC_BASE_CONVERT_MOD_T_DIVIDE_AND_ROUND_Q_LAST_WORKSPACE_N(a1, a2);
  if (result <= 8) {
    return 8;
  }
  return result;
}

uint64_t cche_ciphertext_mod_switch_down_ws(uint64_t a1, uint64_t a2)
{
  char v2 = (uint64_t *)a2;
  int v5 = (unsigned int **)(a2 + 24);
  uint64_t v4 = *(_DWORD **)(a2 + 24);
  uint64_t v6 = sizeof_struct_ccpolyzp_po2cyc();
  if (!*((_DWORD *)v2 + 2)) {
    return 0;
  }
  int v7 = *(_DWORD *)*v2;
  if (v7)
  {
    uint64_t v8 = 0;
    unint64_t v9 = (v4[1] * *v4) + ((unint64_t)(v6 + 7) >> 3);
    unsigned int v10 = v5;
    char v42 = v2;
    uint64_t v43 = a1;
    uint64_t v41 = v5;
    int v40 = *(_DWORD *)*v2;
    unint64_t v39 = v9;
    while (v7 != 2)
    {
      if (v7 == 1)
      {
        uint64_t result = ccpolyzp_po2cyc_divide_and_round_q_last_ws(a1, v10);
        if (result) {
          return result;
        }
      }
      if (v8) {
        goto LABEL_22;
      }
LABEL_23:
      v10 += v9;
      if (++v8 >= (unint64_t)*((unsigned int *)v2 + 2)) {
        return 0;
      }
    }
    unsigned int v12 = (_DWORD *)*v2;
    uint64_t v13 = *cche_param_ctx_plaintext_ctx(*v2);
    uint64_t v14 = cche_param_ctx_plaintext_ctx((uint64_t)v12);
    unsigned int v15 = cche_param_ctx_polynomial_degree((uint64_t)v12);
    unint64_t v16 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
    if (v15 >= 0x80) {
      uint64_t v17 = 128;
    }
    else {
      uint64_t v17 = v15;
    }
    unint64_t v18 = (unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3;
    unint64_t v19 = v16 + 6;
    uint64_t v20 = (uint64_t)&v14[4 * v18 * v17 + 12 + 4 * v15 + 2 * v16] + ((4 * v13 + 7) & 0x7FFFFFFF8);
    uint64_t v21 = (*v10)[1];
    uint64_t v22 = sizeof_struct_ccpolyzp_po2cyc();
    unint64_t v23 = sizeof_struct_ccpolyzp_po2cyc();
    unint64_t v24 = v23 - 1;
    uint64_t v25 = *(unsigned int *)(v20 + 8);
    uint64_t v27 = *(unsigned int *)(v20 + 12);
    uint64_t v26 = v20 + 8;
    if (v25 >= 0x80) {
      uint64_t v28 = 128;
    }
    else {
      uint64_t v28 = v25;
    }
    int8x16_t v29 = (void *)(v26 + 8 * ((v23 - 1 + v22) / v23 + (v19 + 2 * (v25 + v18 * v28)) * v27));
    if (v21 >= 2)
    {
      unint64_t v30 = v23;
      uint64_t v31 = sizeof_struct_ccpolyzp_po2cyc_base_convert();
      unsigned int v32 = v27;
      uint64_t v33 = 1;
      for (uint64_t i = 1; i != v21; ++i)
      {
        v29 += i + (v31 + v24) / v30 + (v33 + v32) * v18;
        v33 += 3;
        v32 += v27;
      }
    }
    uint64_t result = ccpolyzp_po2cyc_fwd_ntt(v10);
    if (result) {
      return result;
    }
    a1 = v43;
    uint64_t result = ccpolyzp_po2cyc_base_convert_mod_t_divide_and_round_q_last_ws(v43, (uint64_t *)v10, v29);
    if (result) {
      return result;
    }
    uint64_t result = ccpolyzp_po2cyc_inv_ntt(v10);
    if (result) {
      return result;
    }
    int v5 = v41;
    char v2 = v42;
    int v7 = v40;
    unint64_t v9 = v39;
    if (!v8)
    {
      uint64_t v37 = v29[9];
      uint64_t v38 = v29[10] * v42[2] - v37 * (((unint64_t)v29[11] * (unsigned __int128)(unint64_t)v42[2]) >> 64);
      if (v38 - v37 >= 0) {
        v38 -= v37;
      }
      v42[2] = v38;
      goto LABEL_23;
    }
LABEL_22:
    uint64_t v35 = *v5;
    uint64_t v36 = sizeof_struct_ccpolyzp_po2cyc();
    memmove(&v5[(v35[1] * *v35 + ((unint64_t)(v36 + 7) >> 3)) * v8], v10, (v36 + 7 + 8 * (*v10)[1] * **v10) & 0xFFFFFFFFFFFFFFF8);
    goto LABEL_23;
  }
  return 4294967289;
}

uint64_t ccecies_decrypt_gcm_from_shared_secret_composite(uint64_t a1, uint64_t a2, size_t a3, char *a4, rsize_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  uint64_t v23 = *MEMORY[0x263EF8C08];
  unint64_t v18 = ccecies_pub_key_size_cp(a1, a2);
  uint64_t v19 = ccecies_derive_gcm_key_iv(a2, a3, a4, a9, a10, v18, a6, __s);
  if (v19)
  {
    uint64_t v20 = v19;
    goto LABEL_3;
  }
  uint64_t v20 = ccecies_decrypt_gcm_decrypt(a2, (uint64_t)__s, a11, a12);
  if (v20) {
LABEL_3:
  }
    cc_clear(a5, a13);
  cc_clear(0x30uLL, __s);
  return v20;
}

uint64_t ccecies_decrypt_gcm_from_shared_secret(uint64_t a1, uint64_t a2, size_t a3, char *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, rsize_t *a11, void *a12)
{
  BOOL v25 = timingsafe_enable_if_supported();
  unint64_t v18 = ccecies_pub_key_size_cp(a1, a2);
  rsize_t v19 = ccecies_decrypt_gcm_plaintext_size_cp(a1, a2, a5);
  if ((*(unsigned char *)(a2 + 32) & 0x21) == 0)
  {
    uint64_t v21 = 4294967291;
    goto LABEL_9;
  }
  rsize_t v20 = v19;
  if (!v19 || v19 > *a11)
  {
    uint64_t v21 = 4294967289;
    goto LABEL_9;
  }
  uint64_t v21 = ccecies_decrypt_gcm_from_shared_secret_composite(a1, a2, a3, a4, v19, a6, a6 + v18, a6 + a5 - *(unsigned int *)(a2 + 28), a7, a8, a9, a10, a12);
  if (v21)
  {
LABEL_9:
    cc_clear(*a11, a12);
    goto LABEL_6;
  }
  *a11 = v20;
LABEL_6:
  cc_disable_dit_with_sb((unsigned int *)&v25);
  return v21;
}

uint64_t ccec_der_export_priv_size(uint64_t *a1, uint64_t a2, int a3)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v6 = cczp_bitlen(*a1 + 40 * *(void *)*a1 + 32);
  if (a3) {
    unint64_t v7 = ((unint64_t)(cczp_bitlen(*a1) + 7) >> 2) | 1;
  }
  else {
    unint64_t v7 = 0;
  }
  uint64_t v8 = ccder_encode_eckey_size((unint64_t)(v6 + 7) >> 3, a2, v7);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccec_der_export_priv(unint64_t **a1, const void *a2, int a3, uint64_t a4, uint64_t a5)
{
  BOOL v23 = timingsafe_enable_if_supported();
  BOOL v10 = *a1;
  v19[0] = cc_malloc_clear(24 * **a1 + 8);
  v19[1] = 3 * *v10 + 1;
  uint64_t v20 = 0;
  uint64_t v21 = cc_ws_alloc;
  uint64_t v22 = cc_ws_free;
  if (v19[0])
  {
    unint64_t v11 = **a1;
    unint64_t v12 = (unint64_t)(cczp_bitlen((uint64_t)&(*a1)[5 * v11 + 4]) + 7) >> 3;
    uint64_t v13 = (char *)cc_ws_alloc(v19, v11);
    if ((ccn_write_uint_padded_ct_internal(v11, (unint64_t *)&a1[3 * **a1 + 2], v12, v13) & 0x80000000) != 0)
    {
      uint64_t v15 = 4294967289;
    }
    else
    {
      if (a3) {
        unint64_t v14 = ((unint64_t)(cczp_bitlen((uint64_t)*a1) + 7) >> 2) | 1;
      }
      else {
        unint64_t v14 = 0;
      }
      unint64_t v16 = (char *)v21(v19, (2 * v11) | 1);
      if (a3)
      {
        uint64_t v17 = ccec_export_pub((uint64_t *)a1, v16);
        if (v17)
        {
          uint64_t v15 = v17;
          goto LABEL_13;
        }
      }
      if (ccder_encode_eckey_internal(v12, (uint64_t)v13, a2, v14, v16, a5, a5 + a4) == a5) {
        uint64_t v15 = 0;
      }
      else {
        uint64_t v15 = 0xFFFFFFFFLL;
      }
    }
    uint64_t v20 = 0;
LABEL_13:
    v22((uint64_t)v19);
    goto LABEL_14;
  }
  uint64_t v15 = 4294967283;
LABEL_14:
  cc_disable_dit_with_sb((unsigned int *)&v23);
  return v15;
}

uint64_t fipspost_post_aes_gcm(char a1)
{
  uint64_t v10 = *MEMORY[0x263EF8C08];
  if ((a1 & 0x10) != 0) {
    uint64_t v1 = "\x01\xF2\xA1\x24\x6B\xFF-\x89:\xEF\xCD\xE5\x90z\x12\a\x9B";
  }
  else {
    uint64_t v1 = "\xF2\xA1\x24\x6B\xFF-\x89:\xEF\xCD\xE5\x90z\x12\a\x9B";
  }
  if ((a1 & 0x10) != 0) {
    char v2 = "\x01&\x86\xF5\xA1\x1F\x0CKS\x81\n[2\xB0\xA8\xFF\xBC";
  }
  else {
    char v2 = "&\x86\xF5\xA1\x1F\x0CKS\x81\n[2\xB0\xA8\xFF\xBC";
  }
  long long v8 = *(_OWORD *)v1;
  uint64_t v3 = ccaes_gcm_decrypt_mode();
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccgcm_one_shot decrypt\n");
    return 4294967223;
  }
  if ((void)v8 == *(void *)v1 && *((void *)&v8 + 1) == *((void *)v1 + 1))
  {
    long long v8 = 0uLL;
    uint64_t v6 = ccaes_gcm_encrypt_mode();
    if (ccgcm_one_shot((uint64_t)v6, 16, (uint64_t)"p\xB6\x02v\xE2\x18\xA0\uD8AA\xD1\xFD\xC1\x9C", 12, (uint64_t)&unk_2373BBB2C, 0, 0, 0, 0, (uint64_t)v9, 16, (uint64_t)&v8))
    {
      mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccgcm_one_shot encrypt\n");
      return 4294967223;
    }
    if ((void)v8 == *(void *)v2 && *((void *)&v8 + 1) == *((void *)v2 + 1)) {
      return 0;
    }
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccgcm_one_shot encrypt\n");
  }
  else
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccgcm_one_shot decrypt\n");
  }
  return 4294967221;
}

uint64_t ccrsa_sign_pss(uint64_t *a1, uint64_t *a2, uint64_t a3, unint64_t a4, uint64_t (**a5)(void, unint64_t, char *), size_t a6, char *a7, unint64_t *a8, char *a9)
{
  BOOL v20 = timingsafe_enable_if_supported();
  uint64_t v17 = ccrng(0);
  if (v17) {
    uint64_t v18 = ccrsa_sign_pss_blinded((uint64_t (**)(void, uint64_t, uint64_t))v17, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  }
  else {
    uint64_t v18 = 0xFFFFFFFFLL;
  }
  cc_disable_dit_with_sb((unsigned int *)&v20);
  return v18;
}

uint64_t ccrsa_sign_pss_msg(uint64_t *a1, uint64_t *a2, uint64_t a3, unint64_t a4, uint64_t (**a5)(void, unint64_t, char *), size_t a6, char *a7, unint64_t *a8, char *a9)
{
  uint64_t v22 = *MEMORY[0x263EF8C08];
  BOOL v20 = timingsafe_enable_if_supported();
  ccdigest_internal((uint64_t)a2, a6, a7, (uint64_t)v21);
  uint64_t v17 = ccrng(0);
  if (v17) {
    uint64_t v18 = ccrsa_sign_pss_blinded((uint64_t (**)(void, uint64_t, uint64_t))v17, a1, a2, a3, a4, a5, *a2, v21, a8, a9);
  }
  else {
    uint64_t v18 = 0xFFFFFFFFLL;
  }
  cc_disable_dit_with_sb((unsigned int *)&v20);
  return v18;
}

uint64_t ccansikdf_x963(unint64_t *a1, size_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, char *a7)
{
  _OWORD v17[2] = *MEMORY[0x263EF8C08];
  BOOL v16 = timingsafe_enable_if_supported();
  v17[0] = a5;
  v17[1] = a4;
  uint64_t v14 = ccansikdf_x963_iovec(a1, a2, a3, 1, (uint64_t)v17, a6, a7);
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v14;
}

uint64_t ccansikdf_x963_iovec(unint64_t *a1, size_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, char *a7)
{
  uint64_t v28 = *MEMORY[0x263EF8C08];
  unint64_t v7 = (a6 + *a1 - 1) / *a1;
  if (v7 > 0xFFFFFFFE) {
    return 4294967289;
  }
  uint64_t v16 = MEMORY[0x270FA53B0](a1, a2, a3, a4);
  uint64_t v18 = &__src[-v17 - 8];
  ccdigest_init_internal(v16, &__src[-v17 - 8]);
  uint64_t updated = ccdigest_update_internal(a1, v18, a2, a3);
  MEMORY[0x270FA53B0](updated, v20, v21, v22);
  unint64_t v24 = &__src[-v23 - 8];
  if (v7 >= 2)
  {
    for (uint64_t i = 1; i != v7; ++i)
    {
      ccansikdf_x963_round((uint64_t)a1, v24, v18, i, a4, a5, (uint64_t)a7);
      a7 += *a1;
    }
  }
  ccansikdf_x963_round((uint64_t)a1, v24, v18, v7, a4, a5, (uint64_t)__src);
  memcpy(a7, __src, a6 - *a1 * (v7 - 1));
  cc_clear(a1[1] + a1[2] + 12, v24);
  cc_clear(a1[1] + a1[2] + 12, v18);
  return 0;
}

uint64_t ccansikdf_x963_round(uint64_t a1, void *__dst, void *__src, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  memcpy(__dst, __src, *(void *)(a1 + 8) + *(void *)(a1 + 16) + 12);
  unsigned int __srca = bswap32(a4);
  ccdigest_update_internal((unint64_t *)a1, __dst, 4uLL, (char *)&__srca);
  if (a5)
  {
    uint64_t v13 = (size_t *)(a6 + 8);
    do
    {
      ccdigest_update_internal((unint64_t *)a1, __dst, *v13, (char *)*(v13 - 1));
      v13 += 2;
      --a5;
    }
    while (a5);
  }
  return (*(uint64_t (**)(uint64_t, void *, uint64_t))(a1 + 56))(a1, __dst, a7);
}

unsigned char *cc_disable_dit(unsigned char *result)
{
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    if (*result) {
      __asm { MSR             DIT, #0 }
    }
  }
  return result;
}

uint64_t cc_disable_dit_with_sb(unsigned int *a1)
{
  return timingsafe_restore_if_supported(*a1);
}

uint64_t ccder_encode_rsa_pub_size(unint64_t *a1)
{
  uint64_t v1 = a1 + 3;
  unint64_t v2 = *a1;
  uint64_t v3 = ccder_sizeof_integer(*a1, a1 + 3);
  unint64_t v4 = ccder_sizeof_integer(v2, &v1[2 * v2 + 1]) + v3;

  return ccder_sizeof(0x2000000000000010, v4);
}

uint64_t ccrsa_ctx_private_zp(void *a1)
{
  return (uint64_t)&a1[4 * *a1 + 4];
}

unsigned __int8 *ccrsa_import_pub_n(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3 = &a2[a1];
  uint64_t result = ccder_decode_rsa_pub_x509_n(a2, &a2[a1]);
  if (!result)
  {
    return ccder_decode_rsa_pub_n(a2, v3);
  }
  return result;
}

uint64_t ccrsa_export_priv_size(unint64_t *a1)
{
  BOOL v4 = timingsafe_enable_if_supported();
  uint64_t v2 = ccder_encode_rsa_priv_size(a1);
  cc_disable_dit_with_sb((unsigned int *)&v4);
  return v2;
}

BOOL ccrsa_export_priv(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  BOOL v6 = ccder_encode_rsa_priv_internal(a1, a3, a3 + a2) != a3;
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return v6;
}

unsigned __int8 *ccrsa_import_priv_n(uint64_t a1, unsigned __int8 *a2)
{
  BOOL v6 = timingsafe_enable_if_supported();
  BOOL v4 = ccder_decode_rsa_priv_n(a2, &a2[a1]);
  cc_disable_dit_with_sb((unsigned int *)&v6);
  return v4;
}

BOOL ccrsa_import_priv(unint64_t *a1, uint64_t a2, unsigned __int8 *a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  BOOL v6 = ccder_decode_rsa_priv_internal(a1, a3, &a3[a2]) == 0;
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return v6;
}

uint64_t ccrsa_oaep_encode(size_t *a1, uint64_t (**a2)(void, size_t, char *), uint64_t a3, void *a4, size_t a5, const void *a6)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v12 = ccrsa_oaep_encode_parameter_internal(a1, a2, a3, a4, a5, a6, 0, 0);
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v12;
}

uint64_t ccrsa_oaep_decode(uint64_t *a1, size_t *a2, void *a3, uint64_t a4, unint64_t *a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = ccrsa_oaep_decode_parameter(a1, a2, a3, a4, a5, 0, 0);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

unint64_t ccrsa_n_from_size(uint64_t a1)
{
  return (unint64_t)(a1 + 7) >> 3;
}

unint64_t ccrsa_sizeof_n_from_size(uint64_t a1)
{
  return (a1 + 7) & 0xFFFFFFFFFFFFFFF8;
}

uint64_t ccrsa_block_start(uint64_t a1, void *__s, int a3)
{
  unint64_t v4 = (a1 + 7) & 0xFFFFFFFFFFFFFFF8;
  uint64_t v5 = v4 - a1;
  if (a3) {
    cc_clear(v4 - a1, __s);
  }
  return (uint64_t)__s + v5;
}

unint64_t ccrsa_block_size(unint64_t *a1)
{
  return ccn_write_uint_size_public_value(*a1, a1 + 3);
}

unsigned int *sha1_compress_0(unsigned int *result, uint64_t a2, const char *a3)
{
  v98[8] = *MEMORY[0x263EF8C08];
  if (a2)
  {
    unsigned int v3 = *result;
    int v4 = result[1];
    int v5 = result[2];
    int v6 = result[3];
    int v7 = result[4];
    do
    {
      uint64_t v8 = 0;
      int8x16x4_t v99 = vld4q_s8(a3);
      uint16x8_t v9 = vmovl_u8(*(uint8x8_t *)v99.val[0].i8);
      uint16x8_t v10 = vmovl_high_u8((uint8x16_t)v99.val[0]);
      _Q16 = vmovl_u8(*(uint8x8_t *)v99.val[1].i8);
      _Q17 = vmovl_high_u8((uint8x16_t)v99.val[1]);
      __asm
      {
        SHLL2           V18.4S, V17.8H, #0x10
        SHLL2           V19.4S, V16.8H, #0x10
      }
      uint16x8_t v19 = vmovl_high_u8((uint8x16_t)v99.val[2]);
      uint16x8_t v20 = vmovl_u8(*(uint8x8_t *)v99.val[2].i8);
      int8x16_t v21 = vorrq_s8(vorrq_s8((int8x16_t)vshll_n_s16(*(int16x4_t *)_Q16.i8, 0x10uLL), (int8x16_t)vshll_n_u16(*(uint16x4_t *)v20.i8, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v9.i8), 0x18uLL));
      uint16x8_t v22 = vmovl_high_u8((uint8x16_t)v99.val[3]);
      v99.val[0] = (int8x16_t)vmovl_u8(*(uint8x8_t *)v99.val[3].i8);
      v95[0] = vorrq_s8(vorrq_s8(vorrq_s8((int8x16_t)vshll_n_s16(*(int16x4_t *)_Q17.i8, 0x10uLL), (int8x16_t)vshll_n_u16(*(uint16x4_t *)v19.i8, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v10.i8), 0x18uLL)), (int8x16_t)vmovl_u16(*(uint16x4_t *)v22.i8));
      v95[1] = vorrq_s8(vorrq_s8(vorrq_s8(_Q18, (int8x16_t)vshll_high_n_u16(v19, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_high_u16(v10), 0x18uLL)), (int8x16_t)vmovl_high_u16(v22));
      v94[0] = vorrq_s8(v21, (int8x16_t)vmovl_u16(*(uint16x4_t *)v99.val[0].i8));
      v94[1] = vorrq_s8(vorrq_s8(vorrq_s8(_Q19, (int8x16_t)vshll_high_n_u16(v20, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_high_u16(v9), 0x18uLL)), (int8x16_t)vmovl_high_u16((uint16x8_t)v99.val[0]));
      do
      {
        HIDWORD(v23) = *(_DWORD *)((char *)v95 + v8) ^ *(_DWORD *)((char *)&v95[1] + v8 + 4) ^ *(_DWORD *)((char *)v94 + v8 + 8) ^ *(_DWORD *)((char *)v94 + v8);
        LODWORD(v23) = HIDWORD(v23);
        *(_DWORD *)((char *)&v95[2] + v8) = v23 >> 31;
        v8 += 4;
      }
      while (v8 != 256);
      unint64_t v24 = -5;
      BOOL v25 = (_DWORD *)v94 + 2;
      int v26 = v7;
      int v27 = v6;
      int v28 = v5;
      int v29 = v4;
      unsigned int v30 = v3;
      do
      {
        HIDWORD(v31) = v30;
        LODWORD(v31) = v30;
        unsigned int v32 = (v31 >> 27) + v26 + 1518500249 + (v28 & v29 | v27 & ~v29) + *(v25 - 2);
        HIDWORD(v31) = v29;
        LODWORD(v31) = v29;
        int v33 = v31 >> 2;
        unint64_t v34 = __PAIR64__(v32, __ROR4__(v29, 2));
        int v35 = v30 & v34 | v28 & ~v30;
        LODWORD(v34) = v32;
        unsigned int v36 = v27 + 1518500249 + v35 + *(v25 - 1) + (v34 >> 27);
        HIDWORD(v34) = v30;
        LODWORD(v34) = v30;
        int v37 = v34 >> 2;
        unint64_t v38 = __PAIR64__(v36, __ROR4__(v30, 2));
        int v39 = v32 & v38 | v33 & ~v32;
        LODWORD(v38) = v36;
        unsigned int v40 = v28 + 1518500249 + *v25 + v39 + (v38 >> 27);
        HIDWORD(v38) = v32;
        LODWORD(v38) = v32;
        int v26 = v38 >> 2;
        unint64_t v41 = __PAIR64__(v40, __ROR4__(v32, 2));
        int v42 = v36 & v41 | v37 & ~v36;
        LODWORD(v41) = v40;
        int v29 = v33 + 1518500249 + v25[1] + v42 + (v41 >> 27);
        HIDWORD(v41) = v36;
        LODWORD(v41) = v36;
        int v27 = v41 >> 2;
        HIDWORD(v41) = v29;
        LODWORD(v41) = v29;
        int v43 = v41 >> 27;
        unint64_t v44 = __PAIR64__(v40, __ROR4__(v36, 2));
        unsigned int v30 = v37 + 1518500249 + v25[2] + (v40 & v44 | v26 & ~v40) + v43;
        LODWORD(v44) = v40;
        int v28 = v44 >> 2;
        v24 += 5;
        v25 += 5;
      }
      while (v24 < 0xF);
      --a2;
      uint64_t v45 = (int *)&v96;
      for (unint64_t i = 15; i < 0x23; i += 5)
      {
        HIDWORD(v47) = v30;
        LODWORD(v47) = v30;
        unsigned int v48 = (v47 >> 27) + 1859775393 + (v28 ^ v29 ^ v27) + v26 + *(v45 - 4);
        HIDWORD(v47) = v29;
        LODWORD(v47) = v29;
        int v49 = v47 >> 2;
        HIDWORD(v47) = v48;
        LODWORD(v47) = v48;
        int v50 = v47 >> 27;
        unint64_t v51 = __PAIR64__(v30, __ROR4__(v29, 2));
        unsigned int v52 = v27 + 1859775393 + (v30 ^ v51 ^ v28) + *(v45 - 3) + v50;
        LODWORD(v51) = v30;
        int v53 = v51 >> 2;
        HIDWORD(v51) = v52;
        LODWORD(v51) = v52;
        int v54 = v51 >> 27;
        unint64_t v55 = __PAIR64__(v48, __ROR4__(v30, 2));
        unsigned int v56 = v28 + 1859775393 + *(v45 - 2) + (v49 ^ v55 ^ v48) + v54;
        LODWORD(v55) = v48;
        int v26 = v55 >> 2;
        HIDWORD(v55) = v56;
        LODWORD(v55) = v56;
        int v57 = v55 >> 27;
        unint64_t v58 = __PAIR64__(v52, __ROR4__(v30, 2));
        int v29 = v49 + 1859775393 + *(v45 - 1) + (v26 ^ v58 ^ v52) + v57;
        LODWORD(v58) = v52;
        int v27 = v58 >> 2;
        HIDWORD(v58) = v29;
        LODWORD(v58) = v29;
        int v59 = v58 >> 27;
        unint64_t v60 = __PAIR64__(v56, __ROR4__(v48, 2));
        int v61 = *v45;
        v45 += 5;
        unsigned int v30 = v53 + 1859775393 + v61 + (v27 ^ v60 ^ v56) + v59;
        LODWORD(v60) = v56;
        int v28 = v60 >> 2;
      }
      int64x2_t v62 = (int *)&v97;
      unint64_t v63 = 35;
      do
      {
        HIDWORD(v65) = v30;
        LODWORD(v65) = v30;
        int v64 = v65 >> 27;
        HIDWORD(v65) = v29;
        LODWORD(v65) = v29;
        int v66 = v65 >> 2;
        int v67 = v64 + v26 - 1894007588 + (v27 & (v28 | v29) | v28 & v29) + *(v62 - 4);
        HIDWORD(v65) = v67;
        LODWORD(v65) = v67;
        int v68 = v65 >> 27;
        unint64_t v69 = __PAIR64__(v30, __ROR4__(v29, 2));
        int v70 = (v30 | v69) & v28 | v30 & __ROR4__(v29, 2);
        LODWORD(v69) = v30;
        int v71 = v69 >> 2;
        int v72 = v27 - 1894007588 + v70 + *(v62 - 3) + v68;
        HIDWORD(v69) = v72;
        LODWORD(v69) = v72;
        int v73 = v28
            - 1894007588
            + *(v62 - 2)
            + ((v67 | __ROR4__(v30, 2)) & __ROR4__(v29, 2) | v67 & __ROR4__(v30, 2))
            + (v69 >> 27);
        HIDWORD(v69) = v73;
        LODWORD(v69) = v73;
        int v29 = v66
            - 1894007588
            + *(v62 - 1)
            + ((v72 | __ROR4__(v67, 2)) & __ROR4__(v30, 2) | v72 & __ROR4__(v67, 2))
            + (v69 >> 27);
        unint64_t v74 = __PAIR64__(v67, __ROR4__(v67, 2));
        int v75 = (v73 | __ROR4__(v72, 2)) & v74 | v73 & __ROR4__(v72, 2);
        int v76 = *v62;
        v62 += 5;
        LODWORD(v74) = v67;
        int v26 = v74 >> 2;
        HIDWORD(v74) = v72;
        LODWORD(v74) = v72;
        int v27 = v74 >> 2;
        HIDWORD(v74) = v29;
        LODWORD(v74) = v29;
        unsigned int v30 = v71 - 1894007588 + v76 + v75 + (v74 >> 27);
        v63 += 5;
        HIDWORD(v74) = v73;
        LODWORD(v74) = v73;
        int v28 = v74 >> 2;
      }
      while (v63 < 0x37);
      unint64_t v77 = (int *)v98;
      for (unint64_t j = 55; j < 0x4B; j += 5)
      {
        HIDWORD(v79) = v30;
        LODWORD(v79) = v30;
        unsigned int v80 = (v79 >> 27) - 899497514 + (v28 ^ v29 ^ v27) + v26 + *(v77 - 4);
        HIDWORD(v79) = v29;
        LODWORD(v79) = v29;
        int v81 = v79 >> 2;
        HIDWORD(v79) = v80;
        LODWORD(v79) = v80;
        int v82 = v79 >> 27;
        unint64_t v83 = __PAIR64__(v30, __ROR4__(v29, 2));
        unsigned int v84 = v27 - 899497514 + (v30 ^ v83 ^ v28) + *(v77 - 3) + v82;
        LODWORD(v83) = v30;
        int v85 = v83 >> 2;
        HIDWORD(v83) = v84;
        LODWORD(v83) = v84;
        int v86 = v83 >> 27;
        unint64_t v87 = __PAIR64__(v80, __ROR4__(v30, 2));
        unsigned int v88 = v28 - 899497514 + *(v77 - 2) + (v81 ^ v87 ^ v80) + v86;
        LODWORD(v87) = v80;
        int v26 = v87 >> 2;
        HIDWORD(v87) = v88;
        LODWORD(v87) = v88;
        int v89 = v87 >> 27;
        unint64_t v90 = __PAIR64__(v84, __ROR4__(v30, 2));
        int v29 = v81 - 899497514 + *(v77 - 1) + (v26 ^ v90 ^ v84) + v89;
        LODWORD(v90) = v84;
        int v27 = v90 >> 2;
        HIDWORD(v90) = v29;
        LODWORD(v90) = v29;
        int v91 = v90 >> 27;
        unint64_t v92 = __PAIR64__(v88, __ROR4__(v80, 2));
        int v93 = *v77;
        v77 += 5;
        unsigned int v30 = v85 - 899497514 + v93 + (v27 ^ v92 ^ v88) + v91;
        LODWORD(v92) = v88;
        int v28 = v92 >> 2;
      }
      v3 += v30;
      v4 += v29;
      *uint64_t result = v3;
      result[1] = v4;
      v5 += v28;
      v6 += v27;
      result[2] = v5;
      result[3] = v6;
      v7 += v26;
      a3 += 64;
      result[4] = v7;
    }
    while (a2);
  }
  return result;
}

uint64_t ccaes_ecb_decrypt(_DWORD *a1, uint64_t a2, _DWORD *a3, int *a4)
{
  if (a2)
  {
    while (1)
    {
      unsigned int v4 = a1[61] ^ *a3;
      unsigned int v5 = a1[62] ^ a3[1];
      unsigned int v6 = a1[63] ^ a3[2];
      unsigned int v7 = a1[64] ^ a3[3];
      uint64_t v8 = a1 + 72;
      for (int i = (a1[121] >> 5) - 1; ; --i)
      {
        unsigned int v10 = TD1[BYTE1(v7)] ^ TD0[v4] ^ TD2[BYTE2(v6)] ^ TD3[HIBYTE(v5)] ^ *(v8 - 7);
        unsigned int v11 = TD1[BYTE1(v4)] ^ TD0[v5] ^ TD2[BYTE2(v7)] ^ TD3[HIBYTE(v6)] ^ *(v8 - 6);
        unsigned int v12 = TD1[BYTE1(v5)] ^ TD0[v6] ^ TD2[BYTE2(v4)] ^ TD3[HIBYTE(v7)] ^ *(v8 - 5);
        unsigned int v13 = TD1[BYTE1(v6)] ^ TD0[v7] ^ TD2[BYTE2(v5)] ^ TD3[HIBYTE(v4)] ^ *(v8 - 4);
        if (!i) {
          break;
        }
        unsigned int v4 = TD1[BYTE1(v13)] ^ TD0[v10] ^ TD2[BYTE2(v12)] ^ TD3[HIBYTE(v11)] ^ *(v8 - 3);
        unsigned int v5 = TD1[BYTE1(v10)] ^ TD0[v11] ^ TD2[BYTE2(v13)] ^ TD3[HIBYTE(v12)] ^ *(v8 - 2);
        int v14 = *(v8 - 1);
        int v15 = *v8;
        v8 += 8;
        unsigned int v6 = TD1[BYTE1(v11)] ^ TD0[v12] ^ TD2[BYTE2(v10)] ^ TD3[HIBYTE(v13)] ^ v14;
        unsigned int v7 = TD1[BYTE1(v12)] ^ TD0[v13] ^ TD2[BYTE2(v11)] ^ TD3[HIBYTE(v10)] ^ v15;
      }
      uint64_t v16 = &a1[8 * ((a1[121] >> 5) - 1)];
      *a4 = (Td4[4 * v10] | (Td4[4 * BYTE1(v13) + 1] << 8) | (Td4[4 * BYTE2(v12) + 2] << 16) | (Td4[4 * HIBYTE(v11) + 3] << 24)) ^ v16[69];
      a4[1] = (Td4[4 * v11] | (Td4[4 * BYTE1(v10) + 1] << 8) | (Td4[4 * BYTE2(v13) + 2] << 16) | (Td4[4 * HIBYTE(v12) + 3] << 24)) ^ v16[70];
      a4[2] = (Td4[4 * v12] | (Td4[4 * BYTE1(v11) + 1] << 8) | (Td4[4 * BYTE2(v10) + 2] << 16) | (Td4[4 * HIBYTE(v13) + 3] << 24)) ^ v16[71];
      a4[3] = (Td4[4 * v13] | (Td4[4 * BYTE1(v12) + 1] << 8) | (Td4[4 * BYTE2(v11) + 2] << 16) | (Td4[4 * HIBYTE(v10) + 3] << 24)) ^ v16[72];
      if (!--a2) {
        break;
      }
      a4 += 4;
      a3 += 4;
    }
  }
  return 0;
}

uint64_t cccmac_update_internal(void *a1, unint64_t a2, char *__src)
{
  uint64_t result = 0;
  uint64_t v13 = *MEMORY[0x263EF8C08];
  if (a2)
  {
    unsigned int v5 = __src;
    if (__src)
    {
      unint64_t v6 = a2;
      unint64_t v7 = a1[6];
      if (16 - v7 >= a2) {
        size_t v8 = a2;
      }
      else {
        size_t v8 = 16 - v7;
      }
      if (v7 > 0x10) {
        return 0xFFFFFFFFLL;
      }
      uint16x8_t v9 = (void *)a1[8];
      if (v7)
      {
        memcpy((char *)a1 + v7 + 32, __src, v8);
        a1[6] += v8;
        v6 -= v8;
        if (!v6) {
          return 0;
        }
        v5 += v8;
        cccbc_update_internal((uint64_t)v9, (uint64_t)(a1 + 9), (uint64_t)a1 + *v9 + 72, 1, (uint64_t)(a1 + 4), (uint64_t)v12);
        a1[7] += 16;
      }
      if (v6 >= 0x11)
      {
        unint64_t v10 = (v6 - 1) >> 4;
        do
        {
          if (v10 >= 0x10) {
            uint64_t v11 = 16;
          }
          else {
            uint64_t v11 = v10;
          }
          cccbc_update_internal((uint64_t)v9, (uint64_t)(a1 + 9), (uint64_t)a1 + *v9 + 72, v11, (uint64_t)v5, (uint64_t)v12);
          v5 += 16 * v11;
          v10 -= v11;
        }
        while (v10);
      }
      __memcpy_chk();
      uint64_t result = 0;
      a1[6] = v6 - ((v6 - 1) & 0xFFFFFFFFFFFFFFF0);
    }
  }
  return result;
}

uint64_t cccmac_update(void *a1, unint64_t a2, char *a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t updated = cccmac_update_internal(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return updated;
}

void *ccmode_factory_ofb_crypt(void *result, void *a2)
{
  *uint64_t result = ((a2[1] + 7) & 0xFFFFFFFFFFFFFFF8) + ((*a2 + 7) & 0xFFFFFFFFFFFFFFF8) + 16;
  result[1] = 1;
  result[2] = ccmode_ofb_init;
  result[3] = ccmode_ofb_crypt;
  result[4] = a2;
  return result;
}

uint64_t ccrsa_decrypt_oaep_ws(uint64_t a1, uint64_t *a2, uint64_t *a3, size_t *a4, void *a5, unint64_t a6, uint64_t a7, size_t a8, char *a9)
{
  uint64_t v17 = ccrng(0);
  if (v17) {
    return ccrsa_decrypt_oaep_blinded_ws(a1, (uint64_t (**)(void, uint64_t, uint64_t))v17, a2, a3, a4, a5, a6, a7, a8, a9);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t ccrsa_decrypt_oaep(uint64_t *a1, uint64_t *a2, size_t *a3, void *a4, unint64_t a5, uint64_t a6, size_t a7, char *a8)
{
  BOOL v33 = timingsafe_enable_if_supported();
  unint64_t v14 = *a1;
  uint64_t v15 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v16 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v17 = (v15 + v16 - 1) / v16 + 11 * v14;
  unint64_t v18 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(v14);
  if (v17 + 1 > v18) {
    unint64_t v19 = v17 + 1;
  }
  else {
    unint64_t v19 = v18;
  }
  uint16x8_t v20 = cc_malloc_clear(8 * (v19 + 3 * v14));
  v31[0] = v20;
  unint64_t v21 = *a1;
  uint64_t v22 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v23 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v24 = (v22 + v23 - 1) / v23 + 11 * v21;
  unint64_t v25 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(v21);
  if (v24 + 1 > v25) {
    unint64_t v26 = v24 + 1;
  }
  else {
    unint64_t v26 = v25;
  }
  v31[1] = v26 + 3 * v21;
  _OWORD v31[2] = 0;
  v31[3] = cc_ws_alloc;
  unsigned int v32 = cc_ws_free;
  if (v20)
  {
    uint64_t v27 = ccrsa_decrypt_oaep_ws((uint64_t)v31, a1, a2, a3, a4, a5, a6, a7, a8);
    v32((uint64_t)v31);
  }
  else
  {
    uint64_t v27 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v33);
  return v27;
}

uint64_t ccdrbg_df_derive_keys(uint64_t (**a1)(void), uint64_t a2, uint64_t a3, rsize_t a4, void *a5)
{
  uint64_t v7 = (*a1)();
  if (v7) {
    cc_clear(a4, a5);
  }
  return v7;
}

uint64_t ccdrbg_df_bc_derive_keys(uint64_t a1, uint64_t a2, uint64_t a3, size_t a4, void *a5)
{
  size_t v6 = a4;
  uint64_t v45 = *MEMORY[0x263EF8C08];
  uint64_t v8 = MEMORY[0x270FA53B0](*(void *)(a1 + 8), a2, a3, a4);
  unint64_t v10 = (char *)&v34 - v9;
  uint64_t v14 = MEMORY[0x270FA53B0](v8, v11, v12, v13);
  unint64_t v18 = (char *)&v34 - v17;
  unsigned int v19 = 0;
  if (v15)
  {
    uint16x8_t v20 = (uint64_t *)(v16 + 8);
    uint64_t v21 = v15;
    do
    {
      uint64_t v22 = *v20;
      v20 += 2;
      v19 += v22;
      --v21;
    }
    while (v21);
  }
  __src[0] = 0;
  __src[1] = 0;
  unsigned int v43 = bswap32(v19);
  unsigned int v44 = bswap32(v6);
  long long v41 = xmmword_2373BBB40;
  unint64_t v39 = *(void *)(a1 + 16) + 16;
  if (!v39)
  {
LABEL_13:
    uint64_t inited = ccecb_init_internal(v14);
    if (!inited)
    {
      if (!v6)
      {
LABEL_26:
        uint64_t v32 = 0;
        goto LABEL_27;
      }
      int v29 = (void *)((char *)&v40[2] + *(void *)(a1 + 16));
      while (1)
      {
        uint64_t v30 = (uint64_t)v29;
        cc_clear(*(void *)(*(void *)(a1 + 8) + 8), v18);
        int v29 = v6 <= 0xF ? v40 : a5;
        uint64_t inited = cccbc_update_internal(*(void *)(a1 + 8), (uint64_t)v10, (uint64_t)v18, 1, v30, (uint64_t)v29);
        if (inited) {
          break;
        }
        if (v6 <= 0xF) {
          memcpy(a5, v29, v6);
        }
        if (v6 >= 0x10) {
          uint64_t v31 = 16;
        }
        else {
          uint64_t v31 = v6;
        }
        a5 = (void *)((char *)a5 + v31);
        v6 -= v31;
        if (!v6) {
          goto LABEL_26;
        }
      }
    }
    uint64_t v32 = inited;
    goto LABEL_27;
  }
  unint64_t v34 = a5;
  int v35 = v10;
  unsigned int v23 = 0;
  unint64_t v24 = 0;
  size_t v36 = 16 - (((_BYTE)v19 + 8) & 0xF);
  int v37 = (size_t *)(v16 + 8);
  uint64_t v38 = v15;
  while (1)
  {
    cc_clear(*(void *)(*(void *)(a1 + 8) + 8), v18);
    LODWORD(__src[0]) = bswap32(v23);
    v40[0] = 0;
    uint64_t updated = update_0(*(void *)(a1 + 8), a1 + 32, (uint64_t)v18, (uint64_t)&v40[v24 / 8 + 2], v40, 0x18uLL, (char *)__src);
    if (updated) {
      break;
    }
    unint64_t v26 = v37;
    uint64_t v27 = v38;
    if (v38)
    {
      do
      {
        uint64_t updated = update_0(*(void *)(a1 + 8), a1 + 32, (uint64_t)v18, (uint64_t)&v40[v24 / 8 + 2], v40, *v26, (char *)*(v26 - 1));
        if (updated) {
          goto LABEL_28;
        }
        v26 += 2;
      }
      while (--v27);
    }
    uint64_t updated = update_0(*(void *)(a1 + 8), a1 + 32, (uint64_t)v18, (uint64_t)&v40[v24 / 8 + 2], v40, v36, (char *)&v41);
    if (updated) {
      break;
    }
    ++v23;
    v24 += 16;
    if (v24 >= v39)
    {
      uint64_t v14 = *(void *)(a1 + 8);
      a5 = v34;
      unint64_t v10 = v35;
      goto LABEL_13;
    }
  }
LABEL_28:
  uint64_t v32 = updated;
  unint64_t v10 = v35;
LABEL_27:
  cc_clear(**(void **)(a1 + 8), v10);
  cc_clear(*(void *)(*(void *)(a1 + 8) + 8), v18);
  return v32;
}

uint64_t update_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, size_t __n, char *__src)
{
  uint64_t v7 = __src;
  size_t v8 = __n;
  unint64_t v14 = 16 - *a5;
  if (*a5) {
    BOOL v15 = __n >= v14;
  }
  else {
    BOOL v15 = 0;
  }
  if (v15)
  {
    memcpy((void *)(a4 + *a5), __src, 16 - *a5);
    uint64_t result = cccbc_update_internal(a1, a2, a3, 1, a4, a4);
    if (result) {
      return result;
    }
    v8 -= v14;
    v7 += v14;
    *a5 = 0;
  }
  if (v8 < 0x10)
  {
LABEL_11:
    if (v8)
    {
      memcpy((void *)(a4 + *a5), v7, v8);
      uint64_t result = 0;
      *a5 += v8;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    while (1)
    {
      uint64_t result = cccbc_update_internal(a1, a2, a3, 1, (uint64_t)v7, a4);
      if (result) {
        break;
      }
      v8 -= 16;
      v7 += 16;
      if (v8 <= 0xF) {
        goto LABEL_11;
      }
    }
  }
  return result;
}

uint64_t ccdrbg_df_bc_init_internal(void *a1, void *a2, unint64_t a3)
{
  uint64_t v3 = 4294967291;
  if (a3 <= 0x20 && *a2 <= 0x200uLL)
  {
    if (a2[1] == 16)
    {
      *a1 = ccdrbg_df_bc_derive_keys;
      a1[1] = a2;
      a1[2] = a3;
      return ccecb_init_internal((uint64_t)a2);
    }
    else
    {
      return 4294967291;
    }
  }
  return v3;
}

uint64_t ccdrbg_df_bc_init(void *a1, void *a2, unint64_t a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t inited = ccdrbg_df_bc_init_internal(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return inited;
}

uint64_t ccder_blob_decode_tl_internal(unsigned __int8 **a1, uint64_t a2, unint64_t *a3, int a4)
{
  unint64_t v10 = 0;
  *a3 = 0;
  int v8 = ccder_blob_decode_tag(a1, &v10);
  uint64_t result = 0;
  if (v8 && v10 == a2)
  {
    if (a4) {
      return ccder_blob_decode_len_strict(a1, a3);
    }
    else {
      return ccder_blob_decode_len(a1, a3);
    }
  }
  return result;
}

uint64_t ccder_blob_decode_tl_strict(unsigned __int8 **a1, uint64_t a2, unint64_t *a3)
{
  return ccder_blob_decode_tl_internal(a1, a2, a3, 1);
}

uint64_t ccder_blob_decode_tl(unsigned __int8 **a1, uint64_t a2, unint64_t *a3)
{
  return ccder_blob_decode_tl_internal(a1, a2, a3, 0);
}

uint64_t ccder_sizeof_tag(uint64_t a1)
{
  unint64_t v1 = a1 & 0x1FFFFFFFFFFFFFFFLL;
  uint64_t v2 = 2;
  uint64_t v3 = 3;
  uint64_t v4 = 4;
  uint64_t v5 = 5;
  if ((a1 & 0x1FFFFFFFFFFFFFFFuLL) >> 28) {
    uint64_t v5 = 6;
  }
  if (v1 >= 0x200000) {
    uint64_t v4 = v5;
  }
  if (v1 >= 0x4000) {
    uint64_t v3 = v4;
  }
  if (v1 >= 0x80) {
    uint64_t v2 = v3;
  }
  if (v1 >= 0x1F) {
    return v2;
  }
  else {
    return 1;
  }
}

uint64_t ccz_subi(void *a1, uint64_t a2, unsigned int a3)
{
  v9[1] = *MEMORY[0x263EF8C08];
  BOOL v8 = timingsafe_enable_if_supported();
  v9[0] = a3;
  v7[0] = 1;
  v7[1] = 0;
  void v7[3] = v9;
  _OWORD v7[2] = 1;
  ccz_sub(a1, a2, (uint64_t)v7);
  return cc_disable_dit_with_sb((unsigned int *)&v8);
}

uint64_t ccctr_context_size(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t ccctr_block_size(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t ccctr_init_internal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 24))();
}

uint64_t ccctr_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(a1, a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccctr_update_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 40))(a2, a3, a4, a5);
}

uint64_t ccctr_update(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 40))(a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccctr_one_shot_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v16[1] = *MEMORY[0x263EF8C08];
  uint64_t v11 = MEMORY[0x270FA53B0](a1, a2, a2, a3);
  uint64_t v13 = (char *)v16 - v12;
  uint64_t v14 = (*(uint64_t (**)(uint64_t, char *))(v11 + 24))(v11, (char *)v16 - v12);
  if (!v14) {
    uint64_t v14 = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(a1 + 40))(v13, a5, a6, a7);
  }
  cc_clear(*(void *)a1, v13);
  return v14;
}

uint64_t ccctr_one_shot(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  BOOL v16 = timingsafe_enable_if_supported();
  uint64_t v14 = ccctr_one_shot_internal(a1, a2, a3, a4, a5, a6, a7);
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v14;
}

unint64_t *ccn_lcm_ws(uint64_t a1, unint64_t a2, char *a3, void *a4, void *a5)
{
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = (uint64_t *)(*(uint64_t (**)(void))(a1 + 24))();
  unint64_t v12 = ccn_gcd_ws(a1, a2, v11, a2, a4, a2, a5);
  ccn_div_exact_ws(a1, a2, (unint64_t *)v11, (unint64_t *)a5, (unint64_t *)v11);
  ccn_shift_right_multi(a2, (uint64_t)v11, (unint64_t *)v11, v12);
  uint64_t result = ccn_mul_ws(a1, a2, a3, (unint64_t *)a4, (unint64_t *)v11);
  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t ccecies_encrypt_gcm_setup(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7)
{
  BOOL v19 = timingsafe_enable_if_supported();
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a4;
  *(_DWORD *)(a1 + 28) = a6;
  *(_DWORD *)(a1 + 32) = a7;
  *(_DWORD *)(a1 + 24) = a5;
  if ((a6 - 17) >= 0xFFFFFFFB) {
    int v14 = 0;
  }
  else {
    int v14 = -5;
  }
  if (((1 << a5) & 0x101010000) != 0) {
    int v15 = v14;
  }
  else {
    int v15 = -5;
  }
  if (a5 <= 0x20) {
    unsigned int v16 = v15;
  }
  else {
    unsigned int v16 = -5;
  }
  if (*(_DWORD *)(a4 + 8) == 4073947) {
    uint64_t v17 = v16;
  }
  else {
    uint64_t v17 = 4294967291;
  }
  cc_disable_dit_with_sb((unsigned int *)&v19);
  return v17;
}

uint64_t ccecies_decrypt_gcm_decrypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8C08];
  uint64_t v7 = *(void *)(a1 + 16);
  MEMORY[0x270FA53B0](a1, a2, *(unsigned int *)(a1 + 24), a2);
  int v15 = &v26[-v14 - 8];
  if (*(_DWORD *)(v7 + 8) != 78647) {
    return 4294967291;
  }
  uint64_t v16 = v10;
  uint64_t v17 = v11;
  uint64_t v18 = v13;
  uint64_t v25 = v12;
  uint64_t v19 = v9 + v8;
  int inited = ccgcm_init_internal(v7);
  int v21 = ccgcm_set_iv_internal(v7, (uint64_t)v15, 16, v19) | inited;
  if (a3 && a4) {
    v21 |= ccgcm_aad_internal(v7, (uint64_t)v15, a3, a4);
  }
  uint64_t v22 = ccgcm_update_internal(v7, (uint64_t)v15, v16, v17, v18) | v21;
  if (!v22)
  {
    uint64_t v23 = *(unsigned int *)(a1 + 28);
    __memcpy_chk();
    uint64_t v22 = ccgcm_finalize_internal(v7, (uint64_t)v15, v23, (uint64_t)v26);
  }
  cc_clear(*(void *)v7, v15);
  return v22;
}

void *ccblowfish_ecb_decrypt_mode()
{
  return &ccblowfish_ltc_ecb_decrypt_mode;
}

void *ccblowfish_ecb_encrypt_mode()
{
  return &ccblowfish_ltc_ecb_encrypt_mode;
}

void *ccblowfish_cbc_encrypt_mode()
{
  return cbc_blowfish_encrypt;
}

void *ccblowfish_cbc_decrypt_mode()
{
  return cbc_blowfish_decrypt;
}

void *ccblowfish_cfb_encrypt_mode()
{
  return cfb_blowfish_encrypt;
}

void *ccblowfish_cfb_decrypt_mode()
{
  return cfb_blowfish_decrypt;
}

void *ccblowfish_cfb8_encrypt_mode()
{
  return cfb8_blowfish_encrypt;
}

void *ccblowfish_cfb8_decrypt_mode()
{
  return cfb8_blowfish_decrypt;
}

void *ccblowfish_ctr_crypt_mode()
{
  return ctr_blowfish;
}

void *ccblowfish_ofb_crypt_mode()
{
  return ofb_blowfish;
}

const char *cc_impl_name(int a1)
{
  if ((a1 - 1) > 0x38) {
    return "UNKNOWN";
  }
  else {
    return off_264CD2780[a1 - 1];
  }
}

uint64_t ccder_encode_dhparams_size(void *a1)
{
  unint64_t v2 = ccdh_gp_n(a1);
  unint64_t v3 = ccdh_gp_l(a1);
  uint64_t v4 = (unint64_t *)ccdh_gp_prime(a1);
  uint64_t v5 = ccder_sizeof_integer(v2, v4);
  size_t v6 = (unint64_t *)ccdh_gp_g(a1);
  uint64_t v7 = ccder_sizeof_integer(v2, v6);
  if (v3) {
    uint64_t v8 = ccder_sizeof_uint64(v3);
  }
  else {
    uint64_t v8 = 0;
  }

  return ccder_sizeof(0x2000000000000010, v7 + v5 + v8);
}

uint64_t ccder_encode_dhparams(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = ccdh_gp_n(a1);
  uint64_t v7 = (unint64_t *)ccdh_gp_prime(a1);
  uint64_t v8 = (unint64_t *)ccdh_gp_g(a1);
  uint64_t v9 = ccdh_gp_l(a1);
  uint64_t v10 = a3;
  if (v9)
  {
    unint64_t v11 = ccdh_gp_l(a1);
    uint64_t v10 = ccder_encode_uint64(v11, a2, a3);
  }
  uint64_t v12 = ccder_encode_integer(v6, v8, a2, v10);
  uint64_t v13 = ccder_encode_integer(v6, v7, a2, v12);

  return ccder_encode_constructed_tl(0x2000000000000010uLL, a3, a2, v13);
}

uint64_t ccgcm_context_size(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t ccgcm_block_size(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t ccgcm_init_internal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 24))();
}

uint64_t ccgcm_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(a1, a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccgcm_set_iv_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 32))(a2, a3, a4);
}

uint64_t ccgcm_init_with_iv(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(a1, a2, a3, a4);
  if (!v10)
  {
    uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 32))(a2, 12, a5);
    if (!v10) {
      *(_WORD *)(a2 + 82) |= 1u;
    }
  }
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccgcm_set_iv(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 32))(a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccgcm_inc_iv_internal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_WORD *)(a2 + 80) != 1 || (*(_WORD *)(a2 + 82) & 1) == 0) {
    return 4294967228;
  }
  uint64_t v4 = (uint64_t *)(a2 + 48);
  unint64_t v5 = 1;
  uint64_t v6 = 59;
  do
  {
    char v7 = *(unsigned char *)(a2 + v6) + 1;
    *(unsigned char *)(a2 + v6) = v7;
    if (v5 > 7) {
      break;
    }
    ++v5;
    --v6;
  }
  while (!v7);
  uint64_t v8 = *v4;
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a2 + 56);
  *(void *)a3 = v8;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)v4;
  ccmode_gcm_update_pad(a2);
  uint64_t result = 0;
  *(_WORD *)(a2 + 80) = 2;
  return result;
}

uint64_t inc_uint(uint64_t result, unint64_t a2)
{
  if (a2)
  {
    unint64_t v2 = (unsigned char *)(a2 + result - 1);
    unint64_t v3 = 2;
    do
    {
      if (++*v2--) {
        BOOL v5 = 1;
      }
      else {
        BOOL v5 = v3 > a2;
      }
      ++v3;
    }
    while (!v5);
  }
  return result;
}

uint64_t ccmode_gcm_update_pad(uint64_t a1)
{
  unint64_t v1 = (unsigned char *)(a1 + 47);
  unint64_t v2 = 1;
  do
  {
    char v3 = *v1 + 1;
    *v1-- = v3;
    if (v2 > 3) {
      break;
    }
    ++v2;
  }
  while (!v3);
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 104) + 24))(*(void *)(a1 + 112), 1, a1 + 32, a1 + 64);
}

uint64_t ccgcm_inc_iv(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v5 = timingsafe_enable_if_supported();
  BOOL v8 = v5;
  uint64_t v6 = ccgcm_inc_iv_internal(v5, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return v6;
}

uint64_t ccgcm_aad_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 40))(a2, a3, a4);
}

uint64_t ccgcm_aad(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 40))(a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccgcm_gmac(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 40))(a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccgcm_update_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 48))(a2, a3, a4, a5);
}

uint64_t ccgcm_update(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 48))(a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccgcm_finalize_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56))(a2, a3, a4);
}

uint64_t ccgcm_finalize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56))(a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccgcm_reset(uint64_t a1, uint64_t a2)
{
  BOOL v6 = timingsafe_enable_if_supported();
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(a1 + 64))(a2);
  cc_disable_dit_with_sb((unsigned int *)&v6);
  return v4;
}

uint64_t ccgcm_one_shot_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  v24[1] = *MEMORY[0x263EF8C08];
  uint64_t v18 = MEMORY[0x270FA53B0](a1, a2, a2, a3);
  uint16x8_t v20 = (char *)v24 - v19;
  uint64_t v21 = (*(uint64_t (**)(uint64_t, char *))(v18 + 24))(v18, (char *)v24 - v19);
  if (!v21)
  {
    uint64_t v21 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a1 + 32))(v20, a4, a5);
    if (!v21)
    {
      uint64_t v21 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a1 + 40))(v20, a6, a7);
      if (!v21)
      {
        uint64_t v21 = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(a1 + 48))(v20, a8, a9, a10);
        if (!v21) {
          uint64_t v21 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a1 + 56))(v20, a11, a12);
        }
      }
    }
  }
  uint64_t v22 = v21;
  cc_clear(*(void *)a1, v20);
  return v22;
}

uint64_t ccgcm_one_shot(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  BOOL v22 = timingsafe_enable_if_supported();
  uint64_t v20 = ccgcm_one_shot_internal(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
  cc_disable_dit_with_sb((unsigned int *)&v22);
  return v20;
}

uint64_t ccgcm_set_iv_legacy(uint64_t a1, _WORD *a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  if (a3 && a4)
  {
    BOOL v11 = timingsafe_enable_if_supported();
    uint64_t v8 = (*(uint64_t (**)(_WORD *, uint64_t, uint64_t))(a1 + 32))(a2, a3, a4);
    cc_disable_dit_with_sb((unsigned int *)&v11);
  }
  else if (a2[40] == 1)
  {
    cc_clear(0x10uLL, a2 + 16);
    ccmode_gcm_update_pad((uint64_t)a2);
    cc_clear(0x10uLL, a2 + 24);
    uint64_t v8 = 0;
    a2[40] = 2;
  }
  else
  {
    uint64_t v8 = 0xFFFFFFFFLL;
  }
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccgcm_one_shot_legacy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v31 = *MEMORY[0x263EF8C08];
  BOOL v20 = timingsafe_enable_if_supported();
  BOOL v29 = v20;
  MEMORY[0x270FA53B0](v20, v21, v22, v23);
  uint64_t v25 = (_WORD *)((char *)&v29 - v24);
  BOOL v30 = 0;
  BOOL v30 = timingsafe_enable_if_supported();
  uint64_t v26 = (*(uint64_t (**)(uint64_t, _WORD *, uint64_t, uint64_t))(a1 + 24))(a1, v25, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v30);
  if (!v26)
  {
    uint64_t v27 = ccgcm_set_iv_legacy(a1, v25, a4, a5);
    if (v27)
    {
      uint64_t v26 = v27;
    }
    else
    {
      BOOL v30 = 0;
      BOOL v30 = timingsafe_enable_if_supported();
      uint64_t v26 = (*(uint64_t (**)(_WORD *, uint64_t, uint64_t))(a1 + 40))(v25, a6, a7);
      cc_disable_dit_with_sb((unsigned int *)&v30);
      if (!v26)
      {
        BOOL v30 = 0;
        BOOL v30 = timingsafe_enable_if_supported();
        uint64_t v26 = (*(uint64_t (**)(_WORD *, uint64_t, uint64_t, uint64_t))(a1 + 48))(v25, a8, a9, a10);
        cc_disable_dit_with_sb((unsigned int *)&v30);
        if (!v26)
        {
          BOOL v30 = 0;
          BOOL v30 = timingsafe_enable_if_supported();
          uint64_t v26 = (*(uint64_t (**)(_WORD *, uint64_t, uint64_t))(a1 + 56))(v25, a11, a12);
          cc_disable_dit_with_sb((unsigned int *)&v30);
        }
      }
    }
  }
  cc_clear(*(void *)a1, v25);
  cc_disable_dit_with_sb((unsigned int *)&v29);
  return v26;
}

uint64_t ccmode_gcm_aad_finalize(uint64_t result)
{
  if (*(_WORD *)(result + 80) == 2)
  {
    uint64_t v1 = result;
    if ((*(unsigned char *)(result + 88) & 0xF) != 0) {
      uint64_t result = ccmode_gcm_mult_h(result, result + 16);
    }
    *(_WORD *)(v1 + 80) = 3;
  }
  return result;
}

uint64_t ccxts_context_size(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t ccxts_block_size(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t ccxts_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(a1, a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccxts_set_tweak(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 40))(a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccxts_update(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 48))(a2, a3, a4, a5, a6);
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v12;
}

uint64_t ccxts_one_shot(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v30 = a8;
  uint64_t v32 = *MEMORY[0x263EF8C08];
  BOOL v15 = timingsafe_enable_if_supported();
  BOOL v31 = v15;
  uint64_t v19 = MEMORY[0x270FA53B0](v15, v16, v17, v18);
  uint64_t v21 = (char *)&v29 - v20;
  MEMORY[0x270FA53B0](v19, v22, v23, v24);
  uint64_t v26 = (char *)&v29 - v25;
  uint64_t v27 = (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t, uint64_t))(a1 + 24))(a1, v21, a2, a3, a4);
  if (!v27)
  {
    uint64_t v27 = (*(uint64_t (**)(char *, char *, uint64_t))(a1 + 40))(v21, v26, a5);
    if (!v27)
    {
      if ((*(uint64_t (**)(char *, char *, uint64_t, uint64_t, uint64_t))(a1 + 48))(v21, v26, a6, a7, v30)) {
        uint64_t v27 = 0;
      }
      else {
        uint64_t v27 = 4294967289;
      }
    }
  }
  cc_clear(*(void *)a1, v21);
  cc_clear(*(void *)(a1 + 8), v26);
  cc_disable_dit_with_sb((unsigned int *)&v31);
  return v27;
}

uint64_t ccec_der_import_priv_keytype(uint64_t a1, unsigned __int8 *a2, void *a3, void *a4)
{
  BOOL v16 = timingsafe_enable_if_supported();
  uint64_t v14 = 0;
  unint64_t v15 = 0;
  uint64_t v12 = 0;
  unint64_t v13 = 0;
  BOOL v10 = 0;
  uint64_t v11 = 0;
  if (ccder_decode_eckey_internal(&v15, &v14, &v12, &v10, &v13, &v11, a2, &a2[a1]))
  {
    uint64_t v8 = 0;
    *a3 = v10;
    *a4 = v14;
  }
  else
  {
    uint64_t v8 = 0xFFFFFFFFLL;
  }
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v8;
}

uint64_t ccec_der_import_priv(unint64_t *a1, uint64_t a2, unsigned __int8 *a3, unint64_t **a4)
{
  BOOL v23 = timingsafe_enable_if_supported();
  unint64_t v8 = 26 * *a1;
  if (20 * *a1 > v8) {
    unint64_t v8 = 20 * *a1;
  }
  uint64_t v9 = cc_malloc_clear(8 * v8);
  unint64_t v10 = 26 * *a1;
  if (20 * *a1 > v10) {
    unint64_t v10 = 20 * *a1;
  }
  v21[0] = v9;
  v21[1] = v10;
  _OWORD v21[2] = 0;
  v21[3] = cc_ws_alloc;
  uint64_t v22 = cc_ws_free;
  if (v9)
  {
    uint64_t v19 = 0;
    unint64_t v20 = 0;
    uint64_t v17 = 0;
    unint64_t v18 = 0;
    unint64_t v15 = 0;
    uint64_t v16 = 0;
    *a4 = a1;
    if (ccder_decode_eckey_internal(&v20, &v19, &v17, &v15, &v18, &v16, a3, &a3[a2])
      && (uint64_t v11 = v19, v11 == (unint64_t)(cczp_bitlen((uint64_t)&a1[5 * *a1 + 4]) + 7) >> 3)
      && !ccn_read_uint_internal(*a1, &a4[3 * **a4 + 2], v19, v17))
    {
      if (v16 && (unint64_t v12 = v18, (((unint64_t)(cczp_bitlen((uint64_t)a1) + 7) >> 2) | 1) <= v12 >> 3))
      {
        if (ccec_import_pub_ws(v21, a1, v18 >> 3, v16, a4)) {
          pub_from_priv_uint64_t ws = 0xFFFFFFFFLL;
        }
        else {
          pub_from_priv_uint64_t ws = 0;
        }
      }
      else
      {
        pub_from_priv_uint64_t ws = ccec_make_pub_from_priv_ws((uint64_t)v21, a1, 0, (uint64_t)&a4[3 * **a4 + 2], 0, a4);
      }
    }
    else
    {
      pub_from_priv_uint64_t ws = 0xFFFFFFFFLL;
    }
    v22((uint64_t)v21);
  }
  else
  {
    pub_from_priv_uint64_t ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v23);
  return pub_from_priv_ws;
}

uint64_t ccvrf_irtf_ed25519_proof_to_hash(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v13 = *MEMORY[0x263EF8C08];
  memset(v8, 0, sizeof(v8));
  long long v12 = 0uLL;
  memset(v11, 0, sizeof(v11));
  ccvrf_irtf_ed25519_decode_proof(a2, (int *)v8, &v12, (uint64_t)v11);
  uint64_t v6 = v5;
  if (!v5)
  {
    __int16 v9 = 772;
    ge_scalarmult_cofactor(v8);
    ccvrf_irtf_ed25519_point_to_string(&v10, v8);
    ccdigest_internal(*(void *)(a1 + 40), 0x22uLL, (char *)&v9, a3);
  }
  return v6;
}

uint64_t ccvrf_proof_to_hash(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  if (ccvrf_sizeof_proof(a1) == a2 && ccvrf_sizeof_hash(a1) == a4) {
    uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 80))(a1, a3, a5);
  }
  else {
    uint64_t v10 = 4294967289;
  }
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t cczp_sqrt_tonelli_shanks_precomp_ws(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, unint64_t a5, uint64_t a6, void *a7)
{
  uint64_t v12 = cczp_n(a2);
  uint64_t v23 = *(void *)(a1 + 16);
  uint64_t v13 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  uint64_t v14 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  unint64_t v15 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  uint64_t v16 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  uint64_t result = cczp_power_fast_ws(a1, a2, a3, a4, a6);
  uint64_t v18 = v23;
  if (!result)
  {
    ccn_seti(v12, v16, 1);
    uint64_t v25 = v16;
    cczp_to_ws(a1, a2);
    ccn_set(v12, v15, a7);
    cczp_sqr_ws(a1, a2);
    cczp_mul_ws(a1, a2);
    cczp_mul_ws(a1, a2);
    if (a5 >= 2)
    {
      while (1)
      {
        ccn_set(v12, v14, v13);
        if (a5 - 1 < 2) {
          break;
        }
        uint64_t v19 = 2;
        do
        {
          cczp_sqr_ws(a1, a2);
          ++v19;
        }
        while (a5 != v19);
        char v20 = ccn_cmp_internal(v12, v14, v25) & 1;
        cczp_mul_ws(a1, a2);
        ccn_mux(v12, v20, a3, (uint64_t *)v14, a3);
        cczp_sqr_ws(a1, a2);
        cczp_mul_ws(a1, a2);
        ccn_mux(v12, v20, (uint64_t *)v13, (uint64_t *)v14, (uint64_t *)v13);
        --a5;
      }
      char v21 = ccn_cmp_internal(v12, v14, v25) & 1;
      cczp_mul_ws(a1, a2);
      ccn_mux(v12, v21, a3, (uint64_t *)v14, a3);
      cczp_sqr_ws(a1, a2);
      cczp_mul_ws(a1, a2);
      ccn_mux(v12, v21, (uint64_t *)v13, (uint64_t *)v14, (uint64_t *)v13);
    }
    cczp_sqr_ws(a1, a2);
    if (ccn_cmp_internal(v12, v14, a4)) {
      uint64_t result = 4294967289;
    }
    else {
      uint64_t result = 0;
    }
    uint64_t v18 = v23;
  }
  *(void *)(a1 + 16) = v18;
  return result;
}

uint64_t cczp_sqrt_default_ws(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  uint64_t v8 = ~*(_DWORD *)cczp_prime(a2) & 3;
  uint64_t v9 = cczp_n(a2);
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v9);
  uint64_t v12 = (void *)cczp_prime(a2);
  if (v8)
  {
    ccn_set(v9, v11, v12);
    *v11 &= ~1uLL;
    unint64_t v14 = ccn_trailing_zeros(v9, (uint64_t)v11);
    ccn_shift_right_multi(v9, (uint64_t)v11, v11, v14);
    unint64_t v15 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v9);
    ccn_sub1(v9, v15, v11, 1uLL);
    ccn_shift_right(v9, (uint64_t)v15, v15, 1uLL);
    uint64_t v16 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v9);
    ccn_seti(v9, v16, 1);
    while (cczp_is_quadratic_residue_ws(a1, a2, v16) == 1)
      ccn_add1_ws(a1, v9, v16, v16, 1);
    uint64_t result = cczp_power_fast_ws(a1, a2, v16, v16, (uint64_t)v11);
    if (!result) {
      uint64_t result = cczp_sqrt_tonelli_shanks_precomp_ws(a1, a2, a3, a4, v14, (uint64_t)v15, v16);
    }
  }
  else
  {
    ccn_add1_ws(a1, v9, v11, (uint64_t *)v12, 1);
    ccn_shift_right(v9, (uint64_t)v11, v11, 2uLL);
    uint64_t result = cczp_power_fast_ws(a1, a2, a3, a4, (uint64_t)v11);
    if (!result)
    {
      cczp_sqr_ws(a1, a2);
      if (ccn_cmp_internal(v9, v11, a4)) {
        uint64_t result = 4294967289;
      }
      else {
        uint64_t result = 0;
      }
    }
  }
  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t cczp_sqrt_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 48))();
}

void *ccsrp_gp_rfc5054_4096()
{
  return &_ccsrp_gp_rfc5054_4096;
}

uint64_t cced25519_verify_internal(uint64_t *a1, uint64_t a2, size_t a3, char *a4, char *a5, uint64_t *a6)
{
  uint64_t v46 = *MEMORY[0x263EF8C08];
  unsigned int v40 = cc_malloc_clear(0x5E0uLL);
  long long v41 = xmmword_2373BBBB0;
  int v42 = (uint64_t (*)(void **, uint64_t))cc_ws_alloc;
  unsigned int v43 = cc_ws_free;
  if (!v40) {
    return 4294967283;
  }
  uint64_t v12 = (uint64_t)&a1[5 * *a1 + 4];
  uint64_t v13 = cczp_n((uint64_t)a1);
  unint64_t v39 = (uint64_t *)cc_ws_alloc(&v40, v13);
  uint64_t v14 = v42(&v40, v13);
  unint64_t v15 = (void *)v42(&v40, 3 * v13);
  if (v13)
  {
    uint64_t v16 = (uint64_t *)(a5 + 32);
    uint64_t v17 = (void *)v14;
    uint64_t v18 = v13;
    do
    {
      uint64_t v19 = *v16++;
      *v17++ = v19;
      --v18;
    }
    while (v18);
  }
  uint64_t v20 = cczp_prime(v12);
  if ((ccn_cmp_internal(v13, v14, v20) & 0x80000000) == 0)
  {
    uint64_t v35 = 4294967150;
    goto LABEL_24;
  }
  cced25519_hash_to_scalar_ws((uint64_t)&v40, a1, a2, v39, 0x20uLL, a5, 0x20uLL, (char *)a6, a3, a4);
  uint64_t v21 = cczp_n((uint64_t)a1);
  unint64_t v22 = v21;
  uint64_t v23 = *a1;
  uint64_t v24 = &v15[*a1];
  unint64_t v25 = *((unsigned __int8 *)a6 + 31);
  if (v21)
  {
    uint64_t v26 = &v15[*a1];
    uint64_t v27 = v21;
    do
    {
      uint64_t v28 = *a6++;
      *v26++ = v28;
      --v27;
    }
    while (v27);
  }
  v24[v21 - 1] &= ~0x8000000000000000;
  uint64_t v29 = cczp_prime((uint64_t)a1);
  if ((ccn_cmp_internal(v22, v24, v29) & 0x80000000) == 0) {
    goto LABEL_27;
  }
  uint64_t v37 = *((void *)&v41 + 1);
  unint64_t v38 = v25;
  v42(&v40, v22);
  uint64_t v30 = (uint64_t *)v42(&v40, v22);
  uint64_t v31 = v42(&v40, v22);
  ccn_seti(v22, &v15[2 * v23], 1);
  cczp_sqr_ws((uint64_t)&v40, (uint64_t)a1);
  cczp_mul_ws((uint64_t)&v40, (uint64_t)a1);
  cczp_sub_ws((uint64_t)&v40, (uint64_t)a1);
  cczp_add_ws((uint64_t)&v40, (uint64_t)a1);
  cczp_sqr_ws((uint64_t)&v40, (uint64_t)a1);
  cczp_mul_ws((uint64_t)&v40, (uint64_t)a1);
  cczp_mul_ws((uint64_t)&v40, (uint64_t)a1);
  cczp_mul_ws((uint64_t)&v40, (uint64_t)a1);
  cczp_mul_ws((uint64_t)&v40, (uint64_t)a1);
  uint64_t v32 = cczp_power_fast_ws((uint64_t)&v40, (uint64_t)a1, v15, v15, (uint64_t)&kPsub5div8);
  if (v32)
  {
LABEL_28:
    uint64_t v35 = v32;
    goto LABEL_24;
  }
  cczp_mul_ws((uint64_t)&v40, (uint64_t)a1);
  cczp_sqr_ws((uint64_t)&v40, (uint64_t)a1);
  cczp_mul_ws((uint64_t)&v40, (uint64_t)a1);
  cczp_from_ws((uint64_t)&v40, (uint64_t)a1);
  cczp_from_ws((uint64_t)&v40, (uint64_t)a1);
  if (ccn_cmp_internal(v22, v30, v31))
  {
    cczp_negate((uint64_t)a1, v30, (unint64_t *)v30);
    if (ccn_cmp_internal(v22, v30, v31)) {
      goto LABEL_27;
    }
    cczp_mul_ws((uint64_t)&v40, (uint64_t)a1);
  }
  cczp_from_ws((uint64_t)&v40, (uint64_t)a1);
  if (ccn_n(v22, (uint64_t)v15) || ((char)v38 & 0x80000000) == 0)
  {
    if ((*v15 & 1) == v38 >> 7) {
      cczp_negate((uint64_t)a1, v15, v15);
    }
    *((void *)&v41 + 1) = v37;
    cced25519_double_scalar_mult_ws((uint64_t)&v40, a1, (char *)v15, v14, (uint64_t)v39);
    uint64_t v32 = ccec_affinify_ws((uint64_t)&v40, (uint64_t)a1);
    if (!v32)
    {
      uint64_t v33 = 0;
      unint64_t v34 = &v15[*a1];
      do
      {
        *(void *)&v44[v33 * 8] = v34[v33];
        ++v33;
      }
      while (v33 != 4);
      v45 |= *(unsigned char *)v15 << 7;
      if (cc_cmp_safe_internal(32, v44, a5)) {
        uint64_t v35 = 4294967150;
      }
      else {
        uint64_t v35 = 0;
      }
      goto LABEL_24;
    }
    goto LABEL_28;
  }
LABEL_27:
  uint64_t v35 = 4294967289;
LABEL_24:
  *((void *)&v41 + 1) = 0;
  v43((uint64_t)&v40);
  return v35;
}

uint64_t cced25519_verify(uint64_t a1, size_t a2, char *a3, char *a4, uint64_t *a5)
{
  BOOL v13 = timingsafe_enable_if_supported();
  uint64_t v10 = (uint64_t *)ccec_cp_ed25519();
  uint64_t v11 = cced25519_verify_internal(v10, a1, a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v13);
  return v11;
}

uint64_t ccxof_init(uint64_t a1, void *a2)
{
  *a2 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 16))(a1, (uint64_t)a2 + *(void *)(a1 + 8) + 8);
}

void *ccxof_absorb(void *result, char *__dst, unint64_t a3, char *__src)
{
  uint64_t v4 = __src;
  unint64_t v5 = a3;
  char v7 = result;
  uint64_t v8 = __dst + 8;
  uint64_t v9 = *(unsigned int *)__dst;
  unint64_t v10 = result[1];
  uint64_t v11 = &__dst[v10 + 8];
  if (v9)
  {
    unint64_t v12 = v10 - v9;
    size_t v13 = v12 >= a3 ? a3 : v12;
    uint64_t result = memcpy(&v8[v9], __src, v13);
    v4 += v13;
    v5 -= v13;
    *(_DWORD *)uint64_t __dst = v13 + v9;
    unint64_t v10 = v7[1];
    if (v13 + v9 == v10)
    {
      uint64_t result = (void *)((uint64_t (*)(void *, char *, uint64_t, char *))v7[3])(v7, v11, 1, v8);
      *(_DWORD *)uint64_t __dst = 0;
      unint64_t v10 = v7[1];
    }
  }
  unint64_t v14 = v5 / v10;
  if (v10 <= v5)
  {
    uint64_t result = (void *)((uint64_t (*)(void *, char *, unint64_t, char *))v7[3])(v7, v11, v14, v4);
    unint64_t v10 = v7[1];
  }
  uint64_t v15 = v10 * v14;
  size_t v16 = v5 - v15;
  if (v16)
  {
    uint64_t result = memcpy(v8, &v4[v15], v16);
    *(_DWORD *)uint64_t __dst = v16;
  }
  return result;
}

void *ccxof_squeeze(void *result, unsigned int *a2, size_t a3, char *__dst)
{
  char v7 = result;
  uint64_t v8 = a2 + 2;
  uint64_t v9 = (uint64_t)a2 + result[1] + 8;
  uint64_t v10 = *a2;
  if (a2[1])
  {
    if (!a3) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t result = (void *)((uint64_t (*)(void *, uint64_t, uint64_t, unsigned int *))result[4])(result, (uint64_t)a2 + result[1] + 8, v10, v8);
    LODWORD(v10) = 0;
    *(void *)a2 = 0x100000000;
    if (!a3) {
      goto LABEL_13;
    }
  }
  size_t v11 = v10;
  do
  {
    size_t v12 = v7[1];
    if (!v11)
    {
      ((void (*)(void *, uint64_t, size_t, unsigned int *))v7[5])(v7, v9, v12, v8);
      size_t v12 = v7[1];
      size_t v11 = v12;
    }
    if (a3 >= v11) {
      size_t v13 = v11;
    }
    else {
      size_t v13 = a3;
    }
    uint64_t result = memcpy(__dst, (char *)v8 + v12 - v11, v13);
    v11 -= v13;
    __dst += v13;
    a3 -= v13;
  }
  while (a3);
  LODWORD(v10) = v11;
LABEL_13:
  *a2 = v10;
  return result;
}

uint64_t ccec_full_sub_normalized_ws(uint64_t a1, unint64_t *a2, char *a3, uint64_t a4, char *a5)
{
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = *a2;
  if (ccec_is_point_at_infinity(a2, a4))
  {
    ccn_set(v11, a3, a5);
    cczp_negate((uint64_t)a2, (uint64_t *)&a3[8 * *a2], (unint64_t *)&a5[8 * *a2]);
    uint64_t result = (uint64_t)ccn_set(v11, &a3[16 * *a2], &a5[16 * *a2]);
  }
  else
  {
    uint64_t result = ccec_add_normalized_ws(a1, a2, a3, a4, (uint64_t)a5, 1);
  }
  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t ccec_full_sub_ws(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, char *a5)
{
  uint64_t v8 = *a2;
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 3 * *a2);
  ccn_set(v8, v10, a5);
  cczp_negate((uint64_t)a2, (uint64_t *)&v10[8 * *a2], (unint64_t *)&a5[8 * *a2]);
  ccn_set(v8, &v10[16 * *a2], &a5[16 * *a2]);
  uint64_t result = ccec_full_add_ws(a1, (uint64_t)a2);
  *(void *)(a1 + 16) = v9;
  return result;
}

uint64_t ccec_full_sub(uint64_t *a1, uint64_t a2, uint64_t a3, char *a4)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v8 = cc_malloc_clear(144 * *a1);
  uint64_t v9 = 18 * *a1;
  v12[0] = v8;
  v12[1] = v9;
  _OWORD v12[2] = 0;
  v12[3] = cc_ws_alloc;
  size_t v13 = cc_ws_free;
  if (v8)
  {
    ccec_full_sub_ws((uint64_t)v12, a1, a2, a3, a4);
    v13((uint64_t)v12);
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v10;
}

void *ccdigest_init_internal(uint64_t a1, void *a2)
{
  uint64_t result = memcpy(a2 + 1, *(const void **)(a1 + 40), *(void *)(a1 + 8));
  *a2 = 0;
  *(_DWORD *)((char *)a2 + *(void *)(a1 + 8) + *(void *)(a1 + 16) + 8) = 0;
  return result;
}

uint64_t ccdigest_init(uint64_t a1, void *a2)
{
  BOOL v5 = timingsafe_enable_if_supported();
  memcpy(a2 + 1, *(const void **)(a1 + 40), *(void *)(a1 + 8));
  *a2 = 0;
  *(_DWORD *)((char *)a2 + *(void *)(a1 + 8) + *(void *)(a1 + 16) + 8) = 0;
  return cc_disable_dit_with_sb((unsigned int *)&v5);
}

uint64_t ccrng_system_init(uint64_t *a1)
{
  BOOL v6 = timingsafe_enable_if_supported();
  unsigned int v5 = 0;
  unint64_t v2 = ccrng(&v5);
  if (v2) {
    *a1 = *v2;
  }
  uint64_t v3 = v5;
  cc_disable_dit_with_sb((unsigned int *)&v6);
  return v3;
}

uint64_t ccrng_system_done()
{
  BOOL v1 = timingsafe_enable_if_supported();
  return cc_disable_dit_with_sb((unsigned int *)&v1);
}

void *ccaes_cbc_decrypt_mode()
{
  return &ccaes_gladman_cbc_decrypt_mode;
}

unint64_t ccn_sub1(uint64_t a1, void *a2, unint64_t *a3, unint64_t a4)
{
  for (; a1; --a1)
  {
    unint64_t v4 = *a3++;
    unsigned long long v5 = v4 - (unsigned __int128)a4;
    *a2++ = v5;
    a4 = *((void *)&v5 + 1) >> 63;
  }
  return a4;
}

uint64_t cczp_sub_default_ws(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unint64_t *a5)
{
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = cczp_n(a2);
  uint64_t v12 = ccn_sub_ws(a1, v11, a3, a4, a5);
  size_t v13 = (uint64_t *)cczp_prime(a2);
  uint64_t result = ccn_cond_add(v11, v12, a3, a3, v13);
  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t cczp_sub_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 8))();
}

uint64_t cczp_sub(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v12 = timingsafe_enable_if_supported();
  cczp_n(a1);
  v10[0] = cc_malloc_clear(0);
  cczp_n(a1);
  v10[1] = 0;
  _OWORD v10[2] = 0;
  _OWORD v10[3] = cc_ws_alloc;
  uint64_t v11 = cc_ws_free;
  if (v10[0])
  {
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 16) + 8))(v10, a1, a2, a3, a4);
    v11((uint64_t)v10);
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v8 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v8;
}

uint64_t ccpad_cts1_decrypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v28 = *MEMORY[0x263EF8C08];
  BOOL v24 = timingsafe_enable_if_supported();
  unint64_t v12 = *(void *)(a1 + 8);
  unint64_t v13 = (a4 - 1) / v12;
  if (v13 >= 2)
  {
    uint64_t v15 = (v13 - 1) * v12;
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a2, a3);
    uint64_t v14 = a4 - v15;
    a5 += v15;
    a6 += v15;
  }
  else
  {
    uint64_t v14 = a4;
  }
  if (2 * v12 == v14)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(a2, a3, 2, a5, a6);
  }
  else
  {
    uint64_t v16 = v14 - v12;
    __memcpy_chk();
    __memcpy_chk();
    ecb_from_cbc_1(a1, a2, (uint64_t)v25, (uint64_t)v27);
    if (v14 - v12 < v12) {
      memcpy(&v26[v16], &v27[v16], 2 * v12 - v14);
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *, uint64_t))(a1 + 24))(a2, a3, 1, v26, a6);
    if (v14 != v12)
    {
      uint64_t v17 = (unsigned char *)(a6 + v12);
      uint64_t v18 = v27;
      uint64_t v19 = v26;
      do
      {
        char v21 = *v19++;
        char v20 = v21;
        char v22 = *v18++;
        *v17++ = v22 ^ v20;
        --v16;
      }
      while (v16);
    }
  }
  cc_disable_dit_with_sb((unsigned int *)&v24);
  return a4;
}

uint64_t ecb_from_cbc_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v13[1] = *MEMORY[0x263EF8C08];
  rsize_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = MEMORY[0x270FA53B0](a1, a2, a3, a4);
  uint64_t v11 = (char *)v13 - v10;
  cccbc_set_iv_internal(v9, (char *)v13 - v10, 0);
  cccbc_update_internal(a1, a2, (uint64_t)v11, 1, a3, a4);
  return cc_clear(v8, v11);
}

uint64_t cckem_sizeof_full_ctx(void *a1)
{
  return *a1 + 8;
}

uint64_t cckem_sizeof_pub_ctx(uint64_t a1)
{
  return *(void *)(a1 + 8) + 8;
}

void cckem_full_ctx_init(void *a1, void *a2)
{
  *a1 = a2;
}

void cckem_pub_ctx_init(void *a1, uint64_t a2)
{
  *a1 = a2;
}

const char *ccscrypt_salsa20_8(const char *result, uint64_t a2)
{
  uint64_t v59 = *MEMORY[0x263EF8C08];
  int8x16x4_t v60 = vld4q_s8(result);
  uint16x8_t v2 = vmovl_u8(*(uint8x8_t *)v60.val[0].i8);
  int8x16_t v3 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v2.i8);
  uint16x8_t v4 = vmovl_high_u8((uint8x16_t)v60.val[0]);
  int8x16_t v5 = (int8x16_t)vmovl_high_u16(v4);
  uint16x8_t v6 = vmovl_high_u8((uint8x16_t)v60.val[1]);
  uint16x8_t v7 = vmovl_u8(*(uint8x8_t *)v60.val[1].i8);
  int8x16_t v8 = vorrq_s8((int8x16_t)vshll_n_u16(*(uint16x4_t *)v6.i8, 8uLL), (int8x16_t)vmovl_u16(*(uint16x4_t *)v4.i8));
  int8x16_t v9 = vorrq_s8((int8x16_t)vshll_high_n_u16(v7, 8uLL), (int8x16_t)vmovl_high_u16(v2));
  int8x16_t v10 = vorrq_s8((int8x16_t)vshll_high_n_u16(v6, 8uLL), v5);
  int8x16_t v11 = vorrq_s8((int8x16_t)vshll_n_u16(*(uint16x4_t *)v7.i8, 8uLL), v3);
  _Q16 = vmovl_u8(*(uint8x8_t *)v60.val[2].i8);
  _Q17 = (int8x16_t)vmovl_high_u8((uint8x16_t)v60.val[2]);
  int8x16_t v14 = (int8x16_t)vshll_n_s16(*(int16x4_t *)_Q17.i8, 0x10uLL);
  __asm
  {
    SHLL2           V19.4S, V16.8H, #0x10
    SHLL2           V17.4S, V17.8H, #0x10
  }
  int8x16_t v20 = vorrq_s8(v11, (int8x16_t)vshll_n_s16(*(int16x4_t *)_Q16.i8, 0x10uLL));
  uint16x8_t v21 = vmovl_high_u8((uint8x16_t)v60.val[3]);
  v60.val[0] = (int8x16_t)vmovl_u8(*(uint8x8_t *)v60.val[3].i8);
  int8x16_t v55 = vorrq_s8(v20, (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v60.val[0].i8), 0x18uLL));
  int8x16_t v56 = vorrq_s8(vorrq_s8(v9, _Q19), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_high_u16((uint16x8_t)v60.val[0]), 0x18uLL));
  int8x16_t v58 = vorrq_s8(vorrq_s8(v10, _Q17), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_high_u16(v21), 0x18uLL));
  int8x16_t v57 = vorrq_s8(vorrq_s8(v8, v14), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v21.i8), 0x18uLL));
  int v23 = v56.i32[0];
  int v22 = v56.i32[1];
  int v25 = v55.i32[0];
  int v24 = v55.i32[1];
  int v27 = v57.i32[0];
  int v26 = v57.i32[1];
  int v29 = v58.i32[0];
  int v28 = v58.i32[1];
  int v31 = v58.i32[2];
  int v30 = v58.i32[3];
  int v32 = v57.i32[2];
  int v33 = v57.i32[3];
  int v35 = v55.i32[2];
  int v34 = v55.i32[3];
  uint64_t v36 = -8;
  int v38 = v56.i32[2];
  int v37 = v56.i32[3];
  do
  {
    int v39 = v23 ^ __ROR4__(v29 + v25, 25);
    int v40 = v27 ^ __ROR4__(v39 + v25, 23);
    int v41 = v29 ^ __ROR4__(v40 + v39, 19);
    int v42 = v25 ^ __ROR4__(v41 + v40, 14);
    int v43 = v26 ^ __ROR4__(v24 + v22, 25);
    int v44 = v28 ^ __ROR4__(v43 + v22, 23);
    int v45 = v24 ^ __ROR4__(v44 + v43, 19);
    int v46 = v22 ^ __ROR4__(v45 + v44, 14);
    int v47 = v31 ^ __ROR4__(v38 + v32, 25);
    int v48 = v35 ^ __ROR4__(v47 + v32, 23);
    int v49 = v38 ^ __ROR4__(v48 + v47, 19);
    int v50 = v32 ^ __ROR4__(v49 + v48, 14);
    int v51 = v34 ^ __ROR4__(v33 + v30, 25);
    int v52 = v37 ^ __ROR4__(v51 + v30, 23);
    int v53 = v33 ^ __ROR4__(v52 + v51, 19);
    int v54 = v30 ^ __ROR4__(v53 + v52, 14);
    int v24 = v45 ^ __ROR4__(v51 + v42, 25);
    int v35 = v48 ^ __ROR4__(v24 + v42, 23);
    int v34 = v51 ^ __ROR4__(v35 + v24, 19);
    int v25 = v42 ^ __ROR4__(v34 + v35, 14);
    int v38 = v49 ^ __ROR4__(v46 + v39, 25);
    int v37 = v52 ^ __ROR4__(v38 + v46, 23);
    int v23 = v39 ^ __ROR4__(v37 + v38, 19);
    int v22 = v46 ^ __ROR4__(v23 + v37, 14);
    int v33 = v53 ^ __ROR4__(v50 + v43, 25);
    int v27 = v40 ^ __ROR4__(v33 + v50, 23);
    int v26 = v43 ^ __ROR4__(v27 + v33, 19);
    int v32 = v50 ^ __ROR4__(v26 + v27, 14);
    int v29 = v41 ^ __ROR4__(v54 + v47, 25);
    int v28 = v44 ^ __ROR4__(v29 + v54, 23);
    int v31 = v47 ^ __ROR4__(v28 + v29, 19);
    int v30 = v54 ^ __ROR4__(v31 + v28, 14);
    v36 += 2;
  }
  while (v36);
  v56.i64[0] = __PAIR64__(v22, v23);
  v55.i64[0] = __PAIR64__(v24, v25);
  v57.i64[0] = __PAIR64__(v26, v27);
  v58.i64[0] = __PAIR64__(v28, v29);
  v58.i64[1] = __PAIR64__(v30, v31);
  v57.i64[1] = __PAIR64__(v33, v32);
  v55.i64[1] = __PAIR64__(v34, v35);
  v56.i64[1] = __PAIR64__(v37, v38);
  do
  {
    *(_DWORD *)(a2 + v36) = *(_DWORD *)&result[v36] + *(__int32 *)((char *)v55.i32 + v36);
    v36 += 4;
  }
  while (v36 != 64);
  return result;
}

__n128 ccscrypt_blockmix_salsa8(_OWORD *a1, _OWORD *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v31 = *MEMORY[0x263EF8C08];
  uint64_t v6 = 2 * a3;
  uint16x8_t v7 = (__n128 *)&a1[8 * a3];
  __n128 v8 = v7[-3];
  __n128 v27 = v7[-4];
  __n128 v28 = v8;
  __n128 result = v7[-2];
  __n128 v10 = v7[-1];
  __n128 v29 = result;
  __n128 v30 = v10;
  if (2 * a3)
  {
    uint64_t v11 = 0;
    unint64_t v12 = a1;
    do
    {
      for (uint64_t i = 0; i != 4; ++i)
        *(int8x16_t *)((char *)&v27 + i * 16) = veorq_s8((int8x16_t)v12[i], *(int8x16_t *)((char *)&v27 + i * 16));
      ccscrypt_salsa20_8((const char *)&v27, (uint64_t)&v27);
      int8x16_t v14 = (__n128 *)&a2[4 * v11];
      __n128 v15 = v28;
      *int8x16_t v14 = v27;
      v14[1] = v15;
      result.n128_u64[0] = v29.n128_u64[0];
      __n128 v16 = v30;
      _OWORD v14[2] = v29;
      void v14[3] = v16;
      ++v11;
      v12 += 4;
    }
    while (v11 != v6);
  }
  if (v3)
  {
    uint64_t v17 = a2;
    uint64_t v18 = a1;
    uint64_t v19 = v3;
    do
    {
      long long v20 = *v17;
      long long v21 = v17[1];
      long long v22 = v17[3];
      void v18[2] = v17[2];
      void v18[3] = v22;
      *uint64_t v18 = v20;
      v18[1] = v21;
      v18 += 4;
      v17 += 8;
      --v19;
    }
    while (v19);
    int v23 = &a1[4 * v3];
    int v24 = (__n128 *)(a2 + 4);
    do
    {
      __n128 result = *v24;
      __n128 v25 = v24[1];
      __n128 v26 = v24[3];
      _OWORD v23[2] = v24[2];
      v23[3] = v26;
      *int v23 = result;
      v23[1] = v25;
      v23 += 4;
      v24 += 8;
      --v3;
    }
    while (v3);
  }
  return result;
}

void *ccscrypt_romix(uint64_t a1, void *a2, uint64_t a3, char *a4, _OWORD *__dst, _OWORD *a6)
{
  size_t v12 = a1 << 7;
  memcpy(__dst, a2, a1 << 7);
  if (a3)
  {
    unint64_t v13 = a4;
    uint64_t v14 = a3;
    do
    {
      memcpy(v13, __dst, v12);
      ccscrypt_blockmix_salsa8(__dst, a6, a1);
      v13 += v12;
      --v14;
    }
    while (v14);
    uint64_t v15 = 0;
    do
    {
      if (v12)
      {
        __n128 v16 = &a4[(*(void *)((unsigned char *)__dst + v12 - 64) & (a3 - 1)) * v12];
        uint64_t v17 = __dst;
        size_t v18 = v12;
        do
        {
          char v19 = *v16++;
          *v17++ ^= v19;
          --v18;
        }
        while (v18);
      }
      ccscrypt_blockmix_salsa8(__dst, a6, a1);
      ++v15;
    }
    while (v15 != a3);
  }

  return memcpy(a2, __dst, v12);
}

uint64_t ccscrypt_storage_size(unint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v3 = -7;
  if (a2 && a1)
  {
    uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
    v4.i16[0] = vaddlv_u8(v4);
    if (0xFFFFFFE0 / (a2 << 7) >= a3 && v4.u32[0] <= 1uLL)
    {
      unint64_t v6 = (unint64_t)a2 << 7;
      uint64_t v7 = v6 * a3;
      BOOL v9 = !is_mul_ok(v6, a3) || v7 < 0;
      uint64_t v10 = v6 * a1;
      int v12 = !is_mul_ok(v6, a1) || v10 < 0 || v9;
      unint64_t v13 = v7 + ((unint64_t)a2 << 8);
      if (__OFADD__(v7, (unint64_t)a2 << 8)) {
        int v12 = 1;
      }
      BOOL v14 = __OFADD__(v10, v13);
      uint64_t v3 = v10 + v13;
      if (v14) {
        int v12 = 1;
      }
      if (v12) {
        return -12;
      }
    }
  }
  return v3;
}

rsize_t ccscrypt(uint64_t a1, uint64_t a2, size_t a3, char *a4, char *a5, unint64_t a6, unsigned int a7, unsigned int a8, unint64_t a9, char *a10)
{
  BOOL v34 = timingsafe_enable_if_supported();
  rsize_t v18 = ccscrypt_storage_size(a6, a7, a8);
  if ((v18 & 0x8000000000000000) == 0)
  {
    if (a9 <= 0xFFFFFFFE0)
    {
      uint64_t v19 = a8;
      int v33 = a5;
      uint64_t v20 = a2;
      unint64_t v21 = (unint64_t)a7 << 7;
      long long v22 = (unint64_t *)ccsha256_di();
      uint64_t v31 = a1;
      uint64_t v32 = v20;
      uint64_t v23 = a1;
      unint64_t v24 = v21 * a8;
      if (ccpbkdf2_hmac_internal(v22, v23, v20, a3, a4, 1uLL, v24, v33)) {
        goto LABEL_9;
      }
      if (a8)
      {
        __n128 v25 = v33;
        unint64_t v26 = v24 + ((unint64_t)a7 << 7);
        __n128 v27 = &v33[v26];
        __n128 v28 = &v33[128 * (unint64_t)a7 + v26];
        do
        {
          ccscrypt_romix(a7, v25, a6, v28, &v33[v24], v27);
          v25 += v21;
          --v19;
        }
        while (v19);
      }
      __n128 v29 = (unint64_t *)ccsha256_di();
      if (ccpbkdf2_hmac_internal(v29, v31, v32, v24, v33, 1uLL, a9, a10))
      {
LABEL_9:
        rsize_t v18 = 0xFFFFFFFFLL;
      }
      else
      {
        cc_clear(v18, v33);
        rsize_t v18 = 0;
      }
    }
    else
    {
      rsize_t v18 = 4294967289;
    }
  }
  cc_disable_dit_with_sb((unsigned int *)&v34);
  return v18;
}

uint64_t ccsae_sizeof_ctx(void *a1)
{
  return 72 * *a1 + 144;
}

unint64_t ccsae_sizeof_commitment(uint64_t *a1)
{
  return 3 * ((unint64_t)(cczp_bitlen(*a1) + 7) >> 3);
}

uint64_t ccsae_sizeof_confirmation(uint64_t a1)
{
  return **(void **)(a1 + 16);
}

unint64_t ccsae_sizeof_pt(uint64_t a1)
{
  uint64_t v1 = (*(uint64_t (**)(void))(a1 + 16))();
  return ((unint64_t)(cczp_bitlen(v1) + 7) >> 2) | 1;
}

void *ccsae_lexographic_order_key_internal(const void *a1, size_t a2, void *__s2, size_t a4, char *a5)
{
  if (a2 >= a4) {
    size_t v10 = a4;
  }
  else {
    size_t v10 = a2;
  }
  int v11 = memcmp(a1, __s2, v10);
  if (v11 < 0 || !v11 && a2 <= a4)
  {
    memcpy(a5, __s2, a4);
    int v12 = &a5[a4];
    unint64_t v13 = a1;
    size_t v14 = a2;
  }
  else
  {
    memcpy(a5, a1, a2);
    int v12 = &a5[a2];
    unint64_t v13 = __s2;
    size_t v14 = a4;
  }

  return memcpy(v12, v13, v14);
}

uint64_t ccsae_lexographic_order_key(const void *a1, size_t a2, void *a3, size_t a4, char *a5)
{
  BOOL v11 = timingsafe_enable_if_supported();
  ccsae_lexographic_order_key_internal(a1, a2, a3, a4, a5);
  return cc_disable_dit_with_sb((unsigned int *)&v11);
}

uint64_t ccsae_gen_keys_ws(uint64_t a1, uint64_t a2, char *a3, unint64_t *a4)
{
  uint64_t v21 = *MEMORY[0x263EF8C08];
  __n128 v8 = *(size_t **)(a2 + 16);
  BOOL v9 = *(unint64_t **)a2;
  uint64_t v10 = **(void **)a2;
  uint64_t v11 = ((unint64_t)(cczp_bitlen(*(void *)a2) + 7) >> 3) + 19;
  uint64_t v12 = *(void *)(a1 + 16);
  unint64_t v13 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10 + 3);
  size_t v14 = *(char **)(a2 + 32);
  __int16 v15 = ccsae_sizeof_kck_internal(a2);
  sae_construct_fixed_data(v9, v14, a4, 8 * v15 + 256, v13);
  uint64_t v16 = ccsae_sizeof_kck_internal(a2);
  ccsae_ctr_hmac_fixed(v8, a3, v13, v11, v20, v16 + 32);
  ccsae_sizeof_kck_internal(a2);
  __memcpy_chk();
  uint64_t v17 = ccsae_sizeof_kck_internal(a2);
  long long v18 = *(_OWORD *)&v20[v17 + 16];
  *(_OWORD *)(a2 + 112) = *(_OWORD *)&v20[v17];
  *(_OWORD *)(a2 + 128) = v18;
  *(void *)(a1 + 16) = v12;
  return 0;
}

uint64_t sae_construct_fixed_data(unint64_t *a1, char *__s, unint64_t *a3, __int16 a4, char *a5)
{
  unint64_t v10 = *a1;
  size_t v11 = strlen(__s);
  unint64_t v12 = (unint64_t)(cczp_bitlen((uint64_t)a1) + 7) >> 3;
  a5 += 2;
  memcpy(a5, __s, v11);
  unint64_t v13 = &a5[v11];
  uint64_t result = ccn_write_uint_padded_internal(v10, a3, v12, v13);
  *(_WORD *)&v13[v12] = a4;
  return result;
}

uint64_t ccsae_ctr_hmac_fixed(size_t *a1, char *a2, _WORD *a3, uint64_t a4, char *a5, size_t a6)
{
  v20[1] = v20;
  uint64_t v23 = *MEMORY[0x263EF8C08];
  size_t v12 = *a1;
  MEMORY[0x270FA53B0](a1, a2, a3, a4);
  __int16 v15 = (void *)((char *)v20 - v14);
  if ((v16 & 1) == 0)
  {
    unint64_t v17 = 1;
    size_t v21 = v13 / v12;
    do
    {
      cchmac_init_internal((uint64_t)a1, v15, v12, a2);
      *a3 = v17;
      cchmac_update_internal(a1, v15, a4, a3);
      cchmac_final_internal((uint64_t)a1, v15, (uint64_t)__src);
      if (a6 >= v12) {
        size_t v18 = v12;
      }
      else {
        size_t v18 = a6;
      }
      memcpy(a5, __src, v18);
      ++v17;
      a5 += v12;
      a6 -= v12;
    }
    while (v17 <= v21);
  }
  cc_clear(((a1[1] + a1[2] + 19) & 0xFFFFFFFFFFFFFFF8) + a1[1], v15);
  return cc_clear(v12, __src);
}

uint64_t ccsae_gen_password_value_ws(uint64_t a1, uint64_t *a2, char *a3, unint64_t *a4)
{
  unint64_t v17 = (size_t *)a2[2];
  uint64_t v7 = (uint64_t *)*a2;
  BOOL v9 = (unint64_t *)(*a2 + 24);
  uint64_t v8 = *(void *)*a2;
  size_t v10 = (unint64_t)(cczp_bitlen(*a2) + 7) >> 3;
  char v16 = cczp_bitlen((uint64_t)v7);
  uint64_t v19 = *(void *)(a1 + 16);
  size_t v11 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8);
  size_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8 + 4);
  unint64_t v13 = (char *)a2[5];
  __int16 v14 = cczp_bitlen((uint64_t)v7);
  sae_construct_fixed_data((unint64_t *)v7, v13, v9, v14, v12);
  ccsae_ctr_hmac_fixed(v17, a3, v12, v10 + 27, v11, v10);
  uint64_t result = ccn_read_uint_internal(v8, a4, v10, v11);
  if ((v16 & 7) != 0) {
    uint64_t result = ccn_shift_right(v8, (uint64_t)a4, a4, 8 - (v16 & 7));
  }
  *(void *)(a1 + 16) = v19;
  return result;
}

unint64_t ccsae_y2_from_x_ws(uint64_t a1, uint64_t *a2, void *a3, void *a4)
{
  uint64_t v8 = *a2;
  uint64_t v9 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, *a2);
  size_t v10 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8);
  size_t v11 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8);
  ccn_set(v8, v10, a4);
  size_t v12 = (unint64_t *)cczp_prime((uint64_t)a2);
  ccn_sub1(v8, v11, v12, 1uLL);
  uint64_t v13 = *a2;
  uint64_t v14 = cczp_prime((uint64_t)a2);
  int v15 = ccn_cmp_internal(v13, v10, v14);
  int v16 = (v15 + 1) & 1;
  int v17 = (v15 + 1) >> 1;
  LODWORD(v13) = v17 | v16;
  ccn_mux(v8, v17 | v16, (uint64_t *)v10, v11, (uint64_t *)v10);
  cczp_to_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  is_quadratic_residue_uint64_t ws = cczp_is_quadratic_residue_ws(a1, (uint64_t)a2, a3);
  *(void *)(a1 + 16) = v9;
  return ((((unint64_t)(is_quadratic_residue_ws - 1) + 0xFFFFFFFF) >> 32) ^ 1) & ~v13;
}

uint64_t ccec_rfc6637_wrap_core_ws(uint64_t a1, uint64_t *a2, unint64_t **a3, _WORD *a4, uint64_t a5, char a6, size_t a7, unsigned __int8 *a8, char *a9, uint64_t (**a10)(void), char *a11, uint64_t (**a12)(void, uint64_t, unint64_t *))
{
  uint64_t v65 = *MEMORY[0x263EF8C08];
  uint64_t v20 = (rsize_t *)(*((uint64_t (**)(void))*a10 + 2))();
  if (a7 > 0x24) {
    return 4294967289;
  }
  size_t v21 = v20;
  if (*v20 < *((void *)*a10 + 4)) {
    return 4294967289;
  }
  int v54 = a4;
  int8x16_t v58 = a8;
  uint64_t v53 = a10[1]();
  uint64_t v23 = ccecb_context_size(v53);
  int8x16_t v57 = &v51;
  MEMORY[0x270FA53B0](v23, v24, v25, v26);
  int v52 = (char *)&v51 - v27;
  uint64_t v28 = *(void *)(a1 + 16);
  uint64_t v55 = *(void *)*a2;
  uint64_t v56 = v28;
  __n128 v29 = (char *)(*(uint64_t (**)(uint64_t))(a1 + 24))(a1);
  size_t v61 = (unint64_t)(cczp_bitlen(*a2) + 7) >> 3;
  uint64_t v30 = ccecdh_compute_shared_secret_ws(a1, a3, (unint64_t **)a2, &v61, v29, a12);
  if (v30)
  {
    uint64_t v22 = v30;
  }
  else
  {
    int v51 = a11;
    LOBYTE(v63[0]) = a6;
    uint64_t v31 = a5;
    uint64_t v32 = v58;
    __memcpy_chk();
    *(_WORD *)((char *)v63 + a7 + 1) = __rev16(pgp_key_checksum(a7, v32));
    memset((char *)v63 + a7 + 3, 37 - a7, 37 - a7);
    ccec_rfc6637_kdf((uint64_t)v21, a9, (uint64_t)*a10, v61, v29, 0x14uLL, v51, (uint64_t)__s);
    int v51 = v29;
    cc_clear(v61, v29);
    size_t v33 = ccec_rfc6637_wrap_pub_size((uint64_t *)a3, v31);
    BOOL v34 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, (2 * v55) | 1);
    int v35 = v34;
    uint64_t v55 = v31;
    if (v31) {
      uint64_t v36 = ccec_compact_export_pub(v34, (uint64_t *)a3);
    }
    else {
      uint64_t v36 = ccec_export_pub((uint64_t *)a3, v34);
    }
    uint64_t v22 = v36;
    int v37 = v54;
    if (!v36)
    {
      *int v54 = bswap32(8 * v33) >> 16;
      memcpy(v37 + 1, v35, v33);
      size_t v38 = (size_t)v37 + v33;
      *((unsigned char *)v37 + v33 + 2) = 40;
      size_t v39 = v33 + 3;
      size_t v40 = (size_t)v37 + v33 + 3;
      long long v41 = v63[1];
      *(_OWORD *)size_t v40 = v63[0];
      *(_OWORD *)(v40 + 16) = v41;
      *(void *)(v40 + 32) = v64;
      uint64_t v42 = v53;
      int v43 = v52;
      ccecb_init_internal(v53);
      cc_clear(*v21, __s);
      uint64_t v59 = 0xA6A6A6A6A6A6A6A6;
      uint64_t v60 = 0;
      uint64_t v22 = ccwrap_auth_encrypt_withiv_internal(v42, (uint64_t)v43, 0x28uLL, v63, &v60, (void *)v40, &v59);
      rsize_t v44 = ccecb_context_size(v42);
      cc_clear(v44, v43);
      uint64_t v45 = v60;
      *(unsigned char *)(v38 + 2) = v60;
      if ((v55 & 2) != 0)
      {
        size_t v46 = v45 + v39;
        int v47 = (char *)v37 + v46;
        *int v47 = a7;
        size_t v48 = v61;
        v47[1] = v61;
        size_t v49 = v46 + 2;
        memcpy((char *)v37 + v46 + 2, v58, a7);
        memcpy((char *)v37 + a7 + v49, v51, v48);
      }
    }
  }
  *(void *)(a1 + 16) = v56;
  return v22;
}

uint64_t ccecdh_pairwise_consistency_check_ws(uint64_t a1, unint64_t **a2, uint64_t a3, uint64_t (**a4)(void, uint64_t, unint64_t *))
{
  unint64_t v6 = *a2;
  unint64_t v7 = **a2;
  uint64_t v28 = *(void *)(a1 + 16);
  uint64_t v8 = (unint64_t **)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, (4 * (v7 & 0x7FFFFFFFFFFFFFFLL)) | 2);
  *uint64_t v8 = v6;
  unint64_t v9 = *v6;
  uint64_t v10 = (uint64_t)&v8[3 * *v6 + 2];
  ccn_set(1, (void *)v10, &REF_K);
  ccn_zero(v9 - 1, (void *)(v10 + 8));
  uint64_t v11 = *(void *)(a1 + 16);
  size_t v12 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 3 * *v6);
  uint64_t v13 = v28;
  uint64_t result = ccecdh_fast_scalar_mult_ws(a1, v6, v12, (uint64_t)&v8[3 * **v8 + 2]);
  if (!result)
  {
    uint64_t result = ccec_affinify_ws(a1, (uint64_t)v6);
    *(void *)(a1 + 16) = v11;
    if (result) {
      goto LABEL_15;
    }
    int v15 = v8 + 2;
    unint64_t v16 = (unint64_t)(cczp_bitlen((uint64_t)v6) + 7) >> 3;
    unint64_t v29 = v16;
    int v17 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v7);
    size_t v18 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v7);
    cc_clear(v16, v17);
    cc_clear(v16, v18);
    uint64_t result = ccecdh_compute_shared_secret_ws(a1, a2, v8, &v29, (char *)v17, a4);
    if (result) {
      goto LABEL_15;
    }
    if (!v29) {
      goto LABEL_14;
    }
    uint64_t v19 = 0;
    int v20 = 0;
    do
      v20 |= v17[v19++];
    while (v29 != v19);
    if (!v20) {
      goto LABEL_14;
    }
    size_t v21 = *v8;
    unint64_t v22 = **v8;
    uint64_t v23 = *(void *)(a1 + 16);
    uint64_t v24 = (void *)(*(uint64_t (**)(uint64_t))(a1 + 24))(a1);
    uint64_t result = ccecdh_fast_scalar_mult_ws(a1, v21, v24, (uint64_t)&v15[3 * v22]);
    uint64_t v13 = v28;
    if (!result)
    {
      uint64_t v25 = (unint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v22);
      uint64_t result = ccec_affinify_x_only_ws(a1, v21, (uint64_t)v25, (uint64_t)v24);
      if (!result)
      {
        uint64_t v26 = cczp_bitlen((uint64_t)v21);
        ccn_write_uint_padded_internal(v22, v25, (unint64_t)(v26 + 7) >> 3, (char *)v18);
        *(void *)(a1 + 16) = v23;
        if (v29 == v16)
        {
          if (cc_cmp_safe_internal(v16, (char *)v17, (char *)v18)) {
            uint64_t result = 4294967278;
          }
          else {
            uint64_t result = 0;
          }
          goto LABEL_15;
        }
LABEL_14:
        uint64_t result = 4294967278;
LABEL_15:
        uint64_t v13 = v28;
      }
    }
  }
  *(void *)(a1 + 16) = v13;
  return result;
}

uint64_t ccecdh_fast_scalar_mult_ws(uint64_t a1, unint64_t *a2, void *a3, uint64_t a4)
{
  unint64_t v8 = *a2;
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = 3 * *a2;
  uint64_t v11 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10);
  uint64_t v12 = ccec_projectify_ws(a1, (uint64_t)a2);
  if (!v12)
  {
    ccn_set(v10, a3, v11);
    uint64_t v13 = ccn_bitlen_internal(v8, a4);
    if (v13 != 1)
    {
      unint64_t v14 = v13 - 2;
      do
      {
        ccec_double_ws(a1, a2);
        if ((*(void *)(a4 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v14)) {
          ccec_full_add_normalized_ws(a1, a2, (char *)a3, (uint64_t)a3, (char *)v11);
        }
        --v14;
      }
      while (v14 != -1);
    }
  }
  *(void *)(a1 + 16) = v9;
  return v12;
}

uint64_t fipspost_post_kdf_ctr(char a1)
{
  uint64_t v45 = *MEMORY[0x263EF8C08];
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint16x8_t v2 = (unint64_t *)ccsha1_di();
  if (ccnistkdf_ctr_hmac_fixed(v2, 0x14uLL, (uint64_t)"\xF7\x59\x17\x33\xC8\x56Y5e\x13\tu5\x19T\xD0\x15Z\xBF<", 0x3CuLL, "\x8E4~\xF5\x5D\x5F\x5E\x99\xEA\xB6\xDEpkQ\xDE\x7C\xE0\x04\xF3\x88(\x89\xE2\x59\xFFN\\\xFF\x10!g\xA5\xA4\xBDq\x15x\xD4\xCE\x17\xBEV\xE5\x1C\x1F-\xF9P\xE2\xFC\x81.\xC1\xB2\x17\xCA\x08\xD6\x014\xFED\xB0\xD8\xC4\x1B\x93\xF5\xFA\x64\xFB\x96\xF0\x0E\x5B4\xFED\xB0\xD8\xC4\x1B\x93\xF5\xFA\x64\xFB\x96\xF0\x0E\x5BFIPSPOST_USER [%llu] %s:%d: FAILED: failed ccnistkdf_ctr_hmac_fixed (SHA-1): %d\n", 0x10uLL, (char *)&v43))
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccnistkdf_ctr_hmac_fixed (SHA-1): %d\n");
    return 4294967224;
  }
  uint64_t v3 = "\x014\xFED\xB0\xD8\xC4\x1B\x93\xF5\xFA\x64\xFB\x96\xF0\x0E\x5B4\xFED\xB0\xD8\xC4\x1B\x93\xF5\xFA\x64\xFB\x96\xF0\x0E\x5BFIPSPOST_USER [%llu] %s:%d: FAILED: failed ccnistkdf_ctr_hmac_fixed (SHA-1): %d\n";
  if ((a1 & 0x10) == 0) {
    uint64_t v3 = "4\xFED\xB0\xD8\xC4\x1B\x93\xF5\xFA\x64\xFB\x96\xF0\x0E\x5BFIPSPOST_USER [%llu] %s:%d: FAILED: failed ccnistkdf_ctr_hmac_fixed (SHA-1): %d\n";
  }
  uint64_t v5 = *(void *)v3;
  uint64_t v4 = *((void *)v3 + 1);
  if (v5 == v43 && v4 == v44)
  {
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v7 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed HMAC_SHA1 KAT\n", v7, "fipspost_post_kdf_ctr", 70);
    uint64_t v8 = 4294967221;
  }
  uint64_t v42 = 0;
  memset(__s2, 0, sizeof(__s2));
  uint64_t v9 = (unint64_t *)ccsha256_di();
  if (ccnistkdf_ctr_hmac_fixed(v9, 0x20uLL, (uint64_t)"\xDB\xDD\xB6d\x93\xE7\xC7\x25\x9A;\xBB\xC2\x5F\x8C~\f\xA7\xFE(M\x92\xD4\x31\xD9\xCD\x99" {
                                "\xA0\xD2\x14\xAC",
  }
                       0x3CuLL,
                       "\x1Ci\xC5\x47fy\x1E1\\,\xC5\xC4~\xCD\x3F\xFA\xB8}\r'=\xD9\x20\xE7\x09\x55\x81L\"\x0E\xAC\xACeB\xDA"
                       "\x3D\xFE$\xFFbkH\x97\x89\x8C\xAF\xB7\xBD\xFF<\x14\xFAF\xFDK",
                       0x28uLL,
                       (char *)__s2))
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccnistkdf_ctr_hmac_fixed (SHA-256): %d\n");
    return 4294967224;
  }
  if ((a1 & 0x10) != 0) {
    uint64_t v10 = "\x01\x1D\xA4v8\xD6\xC9\xC4\xD0Mt\xD4\x64\v\xBDB\xAB\x81M\x9E\x8C\xC2\x2FC&iR9\xF9k\x06\x93\xF1\x2D\x0D\xD1\x15"
  }
          ",\xF4\x44\x30\x1D\xA4v8\xD6\xC9\xC4\xD0Mt\xD4\x64\v\xBDB\xAB\x81M\x9E\x8C\xC2\x2FC&iR9\xF9k\x06\x93\xF1\x2D\x0D"
          "\xD1\x15,\xF4\x44\x30FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccnistkdf_ctr_hmac_fixed (SHA-256): %d\n";
  else {
    uint64_t v10 = "\x1D\xA4v8\xD6\xC9\xC4\xD0Mt\xD4\x64\v\xBDB\xAB\x81M\x9E\x8C\xC2\x2FC&iR9\xF9k\x06\x93\xF1\x2D\x0D\xD1\x15,\xF4\x44\x30FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccnistkdf_ctr_hmac_fixed (SHA-256): %d\n";
  }
  if (memcmp(v10, __s2, 0x28uLL))
  {
    uint64_t v11 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed HMAC_SHA256 KAT\n", v11, "fipspost_post_kdf_ctr", 123);
    uint64_t v8 = 4294967221;
  }
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v12 = (unint64_t *)ccsha512_di();
  if (ccnistkdf_ctr_hmac_fixed(v12, 0x40uLL, (uint64_t)"\xDD\x5D\xBDEY>\xE2\xAC\x13\x97H\xE7\x64\x5BE\x0F\"=/\xF2\x97\xB7\x3F\xD7\x1C\xBC\xEB\xE7\x1DAe<\x95\v\x88P\r\xE5\x32\x2D\x99\xEF\x18\xDF\xDD\x30B\x82\x94\tOL\x95C4\x98.\xC6\x14", 0x3CuLL, "\xB5\v\f\x96<k04\xB8\xCF\x19\xCD\x3F\\N\xBEOI\x85\xAF\f\x03\xE5\x75\xDBb\xE6\xFD\xF1\xEC\xFE\x4F(\xB9]|\xE1\x6D\xF8XC$n\x15W\xBB&!\x97K\xBD.\xB6\x9E\x83U", 0x10uLL, (char *)&v39))
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccnistkdf_ctr_hmac_fixed (SHA-512): %d\n");
    return 4294967224;
  }
  uint64_t v13 = "\x01\xE5\x99\x3B\xF9\xBD*\xA1\xC4\x57F\x04.\x12Y\x81U";
  if ((a1 & 0x10) == 0) {
    uint64_t v13 = "\xE5\x99\x3B\xF9\xBD*\xA1\xC4\x57F\x04.\x12Y\x81U";
  }
  uint64_t v15 = *(void *)v13;
  uint64_t v14 = *((void *)v13 + 1);
  if (v15 != v39 || v14 != v40)
  {
    uint64_t v17 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed HMAC_SHA512 KAT\n", v17, "fipspost_post_kdf_ctr", 174);
    uint64_t v8 = 4294967221;
  }
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  if ((a1 & 0x10) != 0) {
    size_t v18 = "\x01Z\xC9\xF7\xEC\x38\xF6\x8Bv#\x94\xD3\xCA\xEC\xEB\xA5\xBB";
  }
  else {
    size_t v18 = "Z\xC9\xF7\xEC\x38\xF6\x8Bv#\x94\xD3\xCA\xEC\xEB\xA5\xBB";
  }
  if ((a1 & 0x10) != 0) {
    uint64_t v19 = "\x01h\x8B\x9E(#+vT\xF95\x93\xA5\xC3\xF085";
  }
  else {
    uint64_t v19 = "h\x8B\x9E(#+vT\xF95\x93\xA5\xC3\xF085";
  }
  if ((a1 & 0x10) != 0) {
    int v20 = "\x01\xFE\xA9j\xF5\x19\x2A\xD4'\x1Dy\xB9\x80\x80;W\x11";
  }
  else {
    int v20 = "\xFE\xA9j\xF5\x19\x2A\xD4'\x1Dy\xB9\x80\x80;W\x11";
  }
  size_t v21 = (unint64_t *)ccsha3_224_di();
  if (ccnistkdf_ctr_hmac_fixed(v21, 0x14uLL, (uint64_t)"\xF7\x59\x17\x33\xC8\x56Y5e\x13\tu5\x19T\xD0\x15Z\xBF<", 0x3CuLL, "\x8E4~\xF5\x5D\x5F\x5E\x99\xEA\xB6\xDEpkQ\xDE\x7C\xE0\x04\xF3\x88(\x89\xE2\x59\xFFN\\\xFF\x10!g\xA5\xA4\xBDq\x15x\xD4\xCE\x17\xBEV\xE5\x1C\x1F-\xF9P\xE2\xFC\x81.\xC1\xB2\x17\xCA\x08\xD6\x014\xFED\xB0\xD8\xC4\x1B\x93\xF5\xFA\x64\xFB\x96\xF0\x0E\x5B4\xFED\xB0\xD8\xC4\x1B\x93\xF5\xFA\x64\xFB\x96\xF0\x0E\x5BFIPSPOST_USER [%llu] %s:%d: FAILED: failed ccnistkdf_ctr_hmac_fixed (SHA-1): %d\n", 0x10uLL, (char *)&v37))
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccnistkdf_ctr_hmac_fixed (SHA3-224): %d\n");
    return 4294967224;
  }
  unint64_t v22 = (uint64_t *)&unk_2373BBC18;
  if ((a1 & 0x10) == 0) {
    unint64_t v22 = (uint64_t *)&unk_2373BBC2A;
  }
  uint64_t v24 = *v22;
  uint64_t v23 = v22[1];
  if (v24 != v37 || v23 != v38)
  {
    uint64_t v26 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed HMAC_SHA3_224 KAT\n", v26, "fipspost_post_kdf_ctr", 213);
    uint64_t v8 = 4294967221;
  }
  uint64_t v27 = (unint64_t *)ccsha3_256_di();
  if (ccnistkdf_ctr_hmac_fixed(v27, 0x14uLL, (uint64_t)"\xF7\x59\x17\x33\xC8\x56Y5e\x13\tu5\x19T\xD0\x15Z\xBF<", 0x3CuLL, "\x8E4~\xF5\x5D\x5F\x5E\x99\xEA\xB6\xDEpkQ\xDE\x7C\xE0\x04\xF3\x88(\x89\xE2\x59\xFFN\\\xFF\x10!g\xA5\xA4\xBDq\x15x\xD4\xCE\x17\xBEV\xE5\x1C\x1F-\xF9P\xE2\xFC\x81.\xC1\xB2\x17\xCA\x08\xD6\x014\xFED\xB0\xD8\xC4\x1B\x93\xF5\xFA\x64\xFB\x96\xF0\x0E\x5B4\xFED\xB0\xD8\xC4\x1B\x93\xF5\xFA\x64\xFB\x96\xF0\x0E\x5BFIPSPOST_USER [%llu] %s:%d: FAILED: failed ccnistkdf_ctr_hmac_fixed (SHA-1): %d\n", 0x10uLL, (char *)&v37))
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccnistkdf_ctr_hmac_fixed (SHA3-256): %d\n");
    return 4294967224;
  }
  if (*(void *)v18 != v37 || *((void *)v18 + 1) != v38)
  {
    uint64_t v29 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed HMAC_SHA3_256 KAT\n", v29, "fipspost_post_kdf_ctr", 227);
    uint64_t v8 = 4294967221;
  }
  uint64_t v30 = (unint64_t *)ccsha3_384_di();
  if (ccnistkdf_ctr_hmac_fixed(v30, 0x14uLL, (uint64_t)"\xF7\x59\x17\x33\xC8\x56Y5e\x13\tu5\x19T\xD0\x15Z\xBF<", 0x3CuLL, "\x8E4~\xF5\x5D\x5F\x5E\x99\xEA\xB6\xDEpkQ\xDE\x7C\xE0\x04\xF3\x88(\x89\xE2\x59\xFFN\\\xFF\x10!g\xA5\xA4\xBDq\x15x\xD4\xCE\x17\xBEV\xE5\x1C\x1F-\xF9P\xE2\xFC\x81.\xC1\xB2\x17\xCA\x08\xD6\x014\xFED\xB0\xD8\xC4\x1B\x93\xF5\xFA\x64\xFB\x96\xF0\x0E\x5B4\xFED\xB0\xD8\xC4\x1B\x93\xF5\xFA\x64\xFB\x96\xF0\x0E\x5BFIPSPOST_USER [%llu] %s:%d: FAILED: failed ccnistkdf_ctr_hmac_fixed (SHA-1): %d\n", 0x10uLL, (char *)&v37))
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccnistkdf_ctr_hmac_fixed (SHA3-384): %d\n");
    return 4294967224;
  }
  if (*(void *)v19 != v37 || *((void *)v19 + 1) != v38)
  {
    uint64_t v32 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed HMAC_SHA3_384 KAT\n", v32, "fipspost_post_kdf_ctr", 241);
    uint64_t v8 = 4294967221;
  }
  size_t v33 = (unint64_t *)ccsha3_512_di();
  if (ccnistkdf_ctr_hmac_fixed(v33, 0x14uLL, (uint64_t)"\xF7\x59\x17\x33\xC8\x56Y5e\x13\tu5\x19T\xD0\x15Z\xBF<", 0x3CuLL, "\x8E4~\xF5\x5D\x5F\x5E\x99\xEA\xB6\xDEpkQ\xDE\x7C\xE0\x04\xF3\x88(\x89\xE2\x59\xFFN\\\xFF\x10!g\xA5\xA4\xBDq\x15x\xD4\xCE\x17\xBEV\xE5\x1C\x1F-\xF9P\xE2\xFC\x81.\xC1\xB2\x17\xCA\x08\xD6\x014\xFED\xB0\xD8\xC4\x1B\x93\xF5\xFA\x64\xFB\x96\xF0\x0E\x5B4\xFED\xB0\xD8\xC4\x1B\x93\xF5\xFA\x64\xFB\x96\xF0\x0E\x5BFIPSPOST_USER [%llu] %s:%d: FAILED: failed ccnistkdf_ctr_hmac_fixed (SHA-1): %d\n", 0x10uLL, (char *)&v37))
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed ccnistkdf_ctr_hmac_fixed (SHA3-512): %d\n");
    return 4294967224;
  }
  if (*(void *)v20 != v37 || *((void *)v20 + 1) != v38)
  {
    uint64_t v36 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed HMAC_SHA3_512 KAT\n", v36, "fipspost_post_kdf_ctr", 255);
    return 4294967221;
  }
  return v8;
}

uint64_t cczp_power_blinded_ws(uint64_t a1, uint64_t a2, void *a3, void *a4, unint64_t a5, uint64_t a6, uint64_t (**a7)(void, unint64_t, uint64_t))
{
  v21[1] = *MEMORY[0x263EF8C08];
  if (a5 <= 0x20) {
    uint64_t v13 = 32;
  }
  else {
    uint64_t v13 = a5;
  }
  uint64_t v14 = cczp_n(a2);
  uint64_t v15 = cczp_prime(a2);
  if ((ccn_cmp_internal(v14, a4, v15) & 0x80000000) == 0) {
    return 4294967289;
  }
  uint64_t v17 = *(void *)(a1 + 16);
  size_t v18 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v14);
  uint64_t v19 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v14);
  uint64_t result = ccn_random_bits(32, (uint64_t)v21, a7);
  if (!result)
  {
    v21[0] |= 0x80000000uLL;
    ccn_mux_seed_mask(v21[0]);
    ccn_divmod_ws(a1, (unint64_t)(v13 + 63) >> 6, a6, (unint64_t)(v13 + 63) >> 6, (uint64_t)v18, 1uLL, (char *)&v20, v21);
    uint64_t result = cczp_power_ws(a1, a2, v19, a4, v13 - 31, v18);
    if (!result)
    {
      uint64_t result = cczp_power_ws(a1, a2, a3, a4, 32, &v20);
      if (!result)
      {
        uint64_t result = cczp_power_ws(a1, a2, v18, v19, 32, v21);
        if (!result)
        {
          cczp_mul_ws(a1, a2);
          uint64_t result = 0;
        }
      }
    }
  }
  *(void *)(a1 + 16) = v17;
  return result;
}

uint64_t ccec_compact_import_priv_size(uint64_t a1)
{
  BOOL v4 = timingsafe_enable_if_supported();
  if (a1 <= 63)
  {
    if (a1 == 48)
    {
      uint64_t v2 = 192;
      goto LABEL_13;
    }
    if (a1 == 56)
    {
      uint64_t v2 = 224;
      goto LABEL_13;
    }
LABEL_12:
    uint64_t v2 = 0;
    goto LABEL_13;
  }
  if (a1 == 64)
  {
    uint64_t v2 = 256;
    goto LABEL_13;
  }
  if (a1 == 96)
  {
    uint64_t v2 = 384;
    goto LABEL_13;
  }
  if (a1 != 132) {
    goto LABEL_12;
  }
  uint64_t v2 = 521;
LABEL_13:
  cc_disable_dit_with_sb((unsigned int *)&v4);
  return v2;
}

uint64_t ccec_compact_import_priv(uint64_t *a1, uint64_t a2, unsigned __int8 *a3, uint64_t **a4)
{
  BOOL v17 = timingsafe_enable_if_supported();
  unint64_t v8 = cczp_bitlen((uint64_t)a1) + 7;
  if (((unint64_t)(cczp_bitlen((uint64_t)&a1[5 * *a1 + 4]) + 7) >> 3) + (v8 >> 3) == a2)
  {
    *a4 = a1;
    uint64_t v9 = cczp_bitlen((uint64_t)a1);
    uint64_t uint_internal = ccec_compact_import_pub(a1, (unint64_t)(v9 + 7) >> 3, a3, a4);
    if (!uint_internal)
    {
      uint64_t v11 = *a1;
      uint64_t v12 = (uint64_t)&a4[3 * **a4 + 2];
      unint64_t v13 = (unint64_t)(cczp_bitlen((uint64_t)&a1[5 * *a1 + 4]) + 7) >> 3;
      uint64_t v14 = cczp_bitlen((uint64_t)a1);
      uint64_t uint_internal = ccn_read_uint_internal(v11, v12, v13, &a3[(unint64_t)(v14 + 7) >> 3]);
    }
    uint64_t v15 = uint_internal;
  }
  else
  {
    uint64_t v15 = 4294967124;
  }
  cc_disable_dit_with_sb((unsigned int *)&v17);
  return v15;
}

uint64_t ltc_des_ecb_encrypt(uint64_t a1, uint64_t a2, unsigned int *a3, _DWORD *a4)
{
  uint64_t v14 = *MEMORY[0x263EF8C08];
  if (a2)
  {
    uint64_t v6 = a2;
    do
    {
      --v6;
      unsigned int v8 = *a3;
      unsigned int v9 = a3[1];
      a3 += 2;
      unsigned int v12 = bswap32(v8);
      unsigned int v13 = bswap32(v9);
      desfunc(&v12, a1);
      unsigned int v10 = bswap32(v13);
      *a4 = bswap32(v12);
      a4[1] = v10;
      a4 += 2;
    }
    while (v6);
  }
  return 0;
}

void *ccec_cp_192()
{
  return &ccec_cp192;
}

uint64_t ccn_mod_192_ws(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v16[3] = *MEMORY[0x263EF8C08];
  uint64_t v7 = a4[4];
  v16[0] = a4[3];
  v16[1] = v16[0];
  void v16[2] = 0;
  v15[0] = 0;
  v15[1] = v7;
  void v15[2] = v7;
  v14[0] = a4[5];
  v14[1] = v14[0];
  _OWORD v14[2] = v14[0];
  uint64_t v8 = ccn_add_ws(a1, 3, a3, a4, v16);
  uint64_t v9 = ccn_add_ws(a1, 3, a3, a3, v15) + v8;
  v13[0] = v9 + ccn_add_ws(a1, 3, a3, a3, v14);
  v13[1] = v13[0];
  void v13[2] = 0;
  LOBYTE(v9) = ccn_add_ws(a1, 3, v13, a3, v13);
  unsigned int v10 = (unint64_t *)cczp_prime(a2);
  char v11 = ccn_sub_ws(a1, 3, a3, v13, v10);
  return ccn_mux(3, v11 ^ 1u | v9, a3, a3, v13);
}

void *cczp_from_default_ws(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v6 = cczp_n(a2);

  return ccn_set(v6, a3, a4);
}

uint64_t cczp_from_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 64))();
}

uint64_t fipspost_post_rsa_enc_dec(char a1)
{
  uint64_t v31 = *MEMORY[0x263EF8C08];
  uint64_t v2 = sizeof_struct_cche_cipher_plain_ctx() + 8;
  unint64_t v3 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v4 = (v2
      - 1
      + 2 * v2
      + (v3 - 1 + 32 * v3) / v3 * v3
      + 3 * (v3 - 1 + 32 * v3) / v3 * v3
      - v3 * (((v3 - 1 + 32 * v3) / v3) >> 1)
      + 8 * (v3 + v3 * (((v3 - 1 + 32 * v3) / v3) >> 1)))
     / v3;
  unint64_t v5 = (sizeof_struct_ccrns_mul_modulus() + v3 - 1) / v3 + 353;
  unint64_t v6 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(0x20uLL);
  if (v5 <= v6) {
    unint64_t v7 = v6;
  }
  else {
    unint64_t v7 = v5;
  }
  uint64_t v8 = cc_malloc_clear(8 * (v4 + v7) + 768);
  v25[0] = v8;
  uint64_t v9 = sizeof_struct_cche_cipher_plain_ctx() + 8;
  unint64_t v10 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v11 = (v9
       - 1
       + 2 * v9
       + (v10 - 1 + 32 * v10) / v10 * v10
       + 3 * (v10 - 1 + 32 * v10) / v10 * v10
       - v10 * (((v10 - 1 + 32 * v10) / v10) >> 1)
       + 8 * (v10 + v10 * (((v10 - 1 + 32 * v10) / v10) >> 1)))
      / v10;
  unint64_t v12 = (sizeof_struct_ccrns_mul_modulus() + v10 - 1) / v10 + 353;
  unint64_t v13 = CCRSA_CRT_POWER_BLINDED_WORKSPACE_N(0x20uLL);
  if (v12 <= v13) {
    unint64_t v14 = v13;
  }
  else {
    unint64_t v14 = v12;
  }
  v25[1] = v11 + v14 + 96;
  uint64_t v26 = 0;
  uint64_t v27 = cc_ws_alloc;
  uint64_t v28 = cc_ws_free;
  if (!v8) {
    return 4294967283;
  }
  uint64_t v15 = (uint64_t *)cc_ws_alloc(v25, 262);
  uint64_t *v15 = 32;
  if (ccrsa_import_priv_ws((uint64_t)v25, (unint64_t *)v15, 1191, FIPS_RSA_OAEP_KEY))
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccrsa_import_priv\n");
  }
  else
  {
    unint64_t v29 = 256;
    BOOL v17 = (unint64_t *)ccrsa_ctx_public(v15);
    size_t v18 = (size_t *)ccsha256_di();
    if (ccrsa_encrypt_oaep_ws((uint64_t)v25, v17, v18, (uint64_t (**)(void, size_t, char *))&ccrng_zero, &v29, v30, 0x20uLL, &FIPS_RSA_OAEP_MESSAGE, 0, 0))
    {
      mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccrsa_encrypt_oaep\n");
    }
    else
    {
      if (!fipspost_post_rsa_oaep_decrypt_ws((uint64_t)v25, a1, v15, v29))
      {
        int v19 = 0;
        goto LABEL_16;
      }
      mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_rsa_oaep_consistency\n");
    }
  }
  int v19 = -72;
LABEL_16:
  uint64_t v26 = 0;
  uint64_t v20 = (uint64_t *)v27(v25, 262);
  *uint64_t v20 = 32;
  if (ccrsa_import_priv_ws((uint64_t)v25, (unint64_t *)v20, 1191, FIPS_RSA_OAEP_KEY))
  {
    uint64_t v21 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccrsa_import_priv\n", v21, "fipspost_post_rsa_oaep_kat_ws", 135);
    int v22 = -72;
  }
  else if (fipspost_post_rsa_oaep_decrypt_ws((uint64_t)v25, a1, v20, 0x100uLL))
  {
    uint64_t v23 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: fipspost_post_rsa_oaep_kat\n", v23, "fipspost_post_rsa_oaep_kat_ws", 146);
    int v22 = -75;
  }
  else
  {
    int v22 = 0;
  }
  uint64_t v16 = v22 | v19;
  uint64_t v26 = 0;
  v28((uint64_t)v25);
  return v16;
}

uint64_t fipspost_post_rsa_oaep_decrypt_ws(uint64_t a1, char a2, uint64_t *a3, unint64_t a4)
{
  char v17[32] = *MEMORY[0x263EF8C08];
  size_t v15 = 256;
  __memcpy_chk();
  if ((a2 & 0x10) != 0) {
    v16[0] ^= 0xAAu;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = (uint64_t *)ccsha256_di();
  if (ccrsa_decrypt_oaep_blinded_ws(a1, (uint64_t (**)(void, uint64_t, uint64_t))&ccrng_zero, a3, v9, &v15, v17, a4, (uint64_t)v16, 0, 0))
  {
    uint64_t v10 = mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: ccrsa_decrypt_oaep\n", v10, "fipspost_post_rsa_oaep_decrypt_ws", 56);
    uint64_t result = 4294967224;
  }
  else
  {
    if (v15 == 32)
    {
      if (v17[0] == 0xE7E6E5E4E3E2E1E0
        && v17[1] == 0xEFEEEDECEBEAE9E8
        && v17[2] == 0xF7F6F5F4F3F2F1F0
        && v17[3] == 0xFFFEFDFCFBFAF9F8)
      {
        uint64_t result = 0;
        goto LABEL_19;
      }
      mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: plaintext != message\n");
    }
    else
    {
      mach_absolute_time();
      printf("FIPSPOST_USER [%llu] %s:%d: FAILED: len(plaintext) != len(message)\n");
    }
    uint64_t result = 4294967221;
  }
LABEL_19:
  *(void *)(a1 + 16) = v8;
  return result;
}

uint64_t ccsae_generate_commitment_init(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 24);
  if (v1 != CCSAE_STATE_INIT) {
    return 4294967210;
  }
  uint64_t result = 0;
  *(_WORD *)(a1 + 48) = 256;
  *(unsigned char *)(a1 + 50) = 0;
  *(unsigned char *)(a1 + 24) = CCSAE_STATE_COMMIT_INIT | v1;
  return result;
}

uint64_t ccsae_generate_commitment_partial(uint64_t **a1, const void *a2, size_t a3, void *a4, size_t a5, uint64_t a6, unint64_t a7, uint64_t a8, unint64_t a9, char a10)
{
  BOOL v23 = timingsafe_enable_if_supported();
  size_t v18 = *a1;
  v21[0] = cc_malloc_clear(104 * **a1);
  v21[1] = 13 * *v18;
  unint64_t v21[2] = 0;
  v21[3] = cc_ws_alloc;
  int v22 = cc_ws_free;
  if (v21[0])
  {
    commitment_partial_uint64_t ws = ccsae_generate_commitment_partial_ws((uint64_t)v21, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
    v22((uint64_t)v21);
  }
  else
  {
    commitment_partial_uint64_t ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v23);
  return commitment_partial_ws;
}

uint64_t ccsae_generate_commitment_partial_ws(uint64_t a1, uint64_t **a2, const void *a3, size_t a4, void *__s2, size_t a6, uint64_t a7, unint64_t a8, uint64_t a9, unint64_t a10, unsigned __int8 a11)
{
  uint64_t v50 = *MEMORY[0x263EF8C08];
  int v11 = *((unsigned __int8 *)a2 + 24);
  if (v11 != CCSAE_STATE_COMMIT_UPDATE && v11 != CCSAE_STATE_COMMIT_INIT) {
    return 4294967210;
  }
  int v13 = a11;
  if (!a11) {
    return 4294967289;
  }
  uint64_t result = 4294967289;
  if (a4 <= 0x10 && a6 <= 0x10 && a8 <= 0x40 && a10 <= 0x40)
  {
    int v17 = *((unsigned __int8 *)a2 + 25);
    int v18 = v17 - (*((unsigned char *)a2 + 49) - 1);
    if (v17 == (*((unsigned char *)a2 + 49) - 1))
    {
      return 0;
    }
    else
    {
      unint64_t v41 = a10;
      if (v18 <= a11) {
        int v13 = v18;
      }
      int v47 = v13;
      uint64_t v21 = a2[2];
      uint64_t v45 = *a2;
      uint64_t v46 = *v45;
      int v22 = *((unsigned __int8 *)a2 + 48);
      int v23 = *((unsigned __int8 *)a2 + 50);
      uint64_t v44 = (const void *)(a6 + a4);
      uint64_t v24 = ccsae_lexographic_order_key_internal(a3, a4, __s2, a6, v49);
      uint64_t v43 = &v41;
      uint64_t v42 = *(void *)(a1 + 16);
      MEMORY[0x270FA53B0](v24, v25, v26, v27);
      unint64_t v29 = (char *)&v41 - v28;
      cchmac_init_internal((uint64_t)v21, (unint64_t *)((char *)&v41 - v28), (size_t)v44, v49);
      uint64_t updated = cchmac_update_internal(v21, v29, a8, a7);
      if (a9) {
        uint64_t updated = cchmac_update_internal(v21, v29, v41, a9);
      }
      MEMORY[0x270FA53B0](updated, v31, ((v21[1] + v21[2] + 19) & 0xFFFFFFFFFFFFFFF8) + v21[1], v32);
      BOOL v34 = (char *)&v41 - v33;
      memcpy((char *)&v41 - v33, v29, v35);
      char v36 = v47;
      if ((_BYTE)v47)
      {
        int v37 = 0;
        uint64_t v38 = a2 + 18;
        uint64_t v44 = v34;
        do
        {
          char v48 = *((unsigned char *)a2 + 49) + v37;
          memcpy(v29, v44, ((v21[1] + v21[2] + 19) & 0xFFFFFFFFFFFFFFF8) + v21[1]);
          cchmac_update_internal(v21, v29, 1, &v48);
          cchmac_final_internal((uint64_t)v21, v29, (uint64_t)&v38[5 * **a2]);
          ccsae_gen_password_value_ws(a1, (uint64_t *)a2, (char *)&v38[5 * **a2], (unint64_t *)&v38[8 * **a2]);
          ccn_mux(v46, v23, (uint64_t *)a2 + 18, (uint64_t *)a2 + 18, (uint64_t *)&v38[8 * **a2]);
          uint64_t v39 = **a2;
          int v22 = *((unsigned char *)&v38[5 * v39 - 1] + *v21 + 7) & ~(_BYTE)v23 & 1 | v22 & -v23;
          int v40 = ccsae_y2_from_x_ws(a1, v45, &v38[v39], a2 + 18);
          char v36 = v47;
          v23 |= v40;
          ++v37;
        }
        while (v37 < v47);
      }
      *((unsigned char *)a2 + 48) = v22;
      *((unsigned char *)a2 + 50) = v23;
      *((unsigned char *)a2 + 49) += v36;
      *((unsigned char *)a2 + 24) |= CCSAE_STATE_COMMIT_UPDATE;
      *(void *)(a1 + 16) = v42;
      if (*((unsigned __int8 *)a2 + 49) - 1 == *((unsigned __int8 *)a2 + 25)) {
        return 0;
      }
      else {
        return 4294967163;
      }
    }
  }
  return result;
}

uint64_t ccsae_generate_commitment_finalize(void *a1, char *a2)
{
  BOOL v9 = timingsafe_enable_if_supported();
  unint64_t v4 = (void *)*a1;
  v7[0] = cc_malloc_clear(216 * *(void *)*a1);
  v7[1] = 27 * *v4;
  _OWORD v7[2] = 0;
  void v7[3] = cc_ws_alloc;
  uint64_t v8 = cc_ws_free;
  if (v7[0])
  {
    commitment_finalize_uint64_t ws = ccsae_generate_commitment_finalize_ws((uint64_t)v7, (uint64_t)a1, a2);
    v8((uint64_t)v7);
  }
  else
  {
    commitment_finalize_uint64_t ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v9);
  return commitment_finalize_ws;
}

uint64_t ccsae_generate_commitment_finalize_ws(uint64_t a1, uint64_t a2, char *a3)
{
  if (*(unsigned __int8 *)(a2 + 24) != CCSAE_STATE_COMMIT_UPDATE) {
    return 4294967210;
  }
  if (*(unsigned __int8 *)(a2 + 49) <= *(unsigned __int8 *)(a2 + 25)) {
    return 4294967164;
  }
  if (!*(unsigned char *)(a2 + 50)) {
    return 4294967211;
  }
  unint64_t v6 = *(void **)a2;
  char v7 = *(unsigned char *)(a2 + 48);
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 3 * **(void **)a2);
  uint64_t result = cczp_sqrt_ws(a1, (uint64_t)v6);
  if (!result)
  {
    cczp_from_ws(a1, (uint64_t)v6);
    cczp_cond_negate((uint64_t)v6, *(unsigned char *)(a2 + 144 + 8 * **(void **)a2) & 1 ^ v7 & 1, (uint64_t *)(a2 + 144 + 8 * **(void **)a2), (unint64_t *)(a2 + 144 + 8 * **(void **)a2));
    uint64_t result = ccec_projectify_ws(a1, (uint64_t)v6);
    if (!result)
    {
      uint64_t result = ccsae_generate_commitment_shared_ws(a1, (uint64_t *)a2, v9, a3);
      if (!result)
      {
        *(_DWORD *)(a2 + 28) = 1;
        *(unsigned char *)(a2 + 24) |= CCSAE_STATE_COMMIT_GENERATED;
      }
    }
  }
  *(void *)(a1 + 16) = v8;
  return result;
}

uint64_t ccsae_generate_commitment(uint64_t **a1, const void *a2, size_t a3, void *a4, size_t a5, uint64_t a6, unint64_t a7, uint64_t a8, unint64_t a9, char *a10)
{
  BOOL v30 = timingsafe_enable_if_supported();
  int v17 = *a1;
  uint64_t v18 = **a1;
  unint64_t v19 = 13 * v18;
  unint64_t v20 = 27 * v18;
  if (v19 > v20) {
    unint64_t v20 = v19;
  }
  uint64_t v21 = cc_malloc_clear(8 * v20);
  v28[0] = v21;
  unint64_t v22 = 27 * *v17;
  if (13 * *v17 > v22) {
    unint64_t v22 = 13 * *v17;
  }
  v28[1] = v22;
  void v28[2] = 0;
  v28[3] = cc_ws_alloc;
  unint64_t v29 = cc_ws_free;
  if (v21)
  {
    int v23 = *((unsigned __int8 *)a1 + 24);
    if (v23 == CCSAE_STATE_INIT)
    {
      *((_WORD *)a1 + 24) = 256;
      *((unsigned char *)a1 + 50) = 0;
      *((unsigned char *)a1 + 24) = CCSAE_STATE_COMMIT_INIT | v23;
      commitment_partial_uint64_t ws = ccsae_generate_commitment_partial_ws((uint64_t)v28, a1, a2, a3, a4, a5, a6, a7, a8, a9, 0x28u);
      if (!commitment_partial_ws) {
        commitment_partial_uint64_t ws = ccsae_generate_commitment_finalize_ws((uint64_t)v28, (uint64_t)a1, a10);
      }
      uint64_t v25 = commitment_partial_ws;
    }
    else
    {
      uint64_t v25 = 4294967210;
    }
    v29((uint64_t)v28);
  }
  else
  {
    uint64_t v25 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v30);
  return v25;
}

uint64_t ccsae_generate_h2c_commit_finalize(void *a1, char *a2)
{
  BOOL v9 = timingsafe_enable_if_supported();
  unint64_t v4 = (void *)*a1;
  v7[0] = cc_malloc_clear(192 * *(void *)*a1);
  v7[1] = 24 * *v4;
  _OWORD v7[2] = 0;
  void v7[3] = cc_ws_alloc;
  uint64_t v8 = cc_ws_free;
  if (v7[0])
  {
    h2c_commit_finalize_uint64_t ws = ccsae_generate_h2c_commit_finalize_ws((uint64_t)v7, (uint64_t)a1, a2);
    v8((uint64_t)v7);
  }
  else
  {
    h2c_commit_finalize_uint64_t ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v9);
  return h2c_commit_finalize_ws;
}

uint64_t ccsae_generate_h2c_commit_finalize_ws(uint64_t a1, uint64_t a2, char *a3)
{
  if (*(unsigned __int8 *)(a2 + 24) != CCSAE_STATE_COMMIT_UPDATE) {
    return 4294967210;
  }
  uint64_t result = ccsae_generate_commitment_shared_ws(a1, (uint64_t *)a2, a2 + 144, a3);
  if (!result)
  {
    *(_DWORD *)(a2 + 28) = 2;
    *(unsigned char *)(a2 + 24) |= CCSAE_STATE_COMMIT_GENERATED;
  }
  return result;
}

uint64_t ccsae_generate_h2c_commit_init(uint64_t **a1, const void *a2, size_t a3, void *a4, size_t a5, uint64_t a6, uint64_t a7)
{
  BOOL v25 = timingsafe_enable_if_supported();
  int v13 = *a1;
  uint64_t v14 = **a1;
  uint64_t v15 = sizeof_struct_cche_galois_key();
  unint64_t v16 = sizeof_struct_ccpolyzp_po2cyc();
  v23[0] = cc_malloc_clear(8 * ((v15 + v16 + 3 * v14 * v16 - 1) / v16 + 28 * v14));
  uint64_t v17 = *v13;
  uint64_t v18 = sizeof_struct_cche_galois_key();
  unint64_t v19 = sizeof_struct_ccpolyzp_po2cyc();
  v23[1] = (v18 + v19 + 3 * v17 * v19 - 1) / v19 + 28 * v17;
  _OWORD v23[2] = 0;
  v23[3] = cc_ws_alloc;
  uint64_t v24 = cc_ws_free;
  if (v23[0])
  {
    h2c_commit_init_uint64_t ws = ccsae_generate_h2c_commit_init_ws((uint64_t)v23, (uint64_t)a1, a2, a3, a4, a5, a6, a7);
    v24((uint64_t)v23);
  }
  else
  {
    h2c_commit_init_uint64_t ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v25);
  return h2c_commit_init_ws;
}

uint64_t ccsae_generate_h2c_commit_init_ws(uint64_t a1, uint64_t a2, const void *a3, size_t a4, void *a5, size_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v33 = *MEMORY[0x263EF8C08];
  if (*(unsigned __int8 *)(a2 + 24) != CCSAE_STATE_INIT) {
    return 4294967210;
  }
  unint64_t v12 = *(uint64_t **)(a2 + 16);
  int v13 = *(unint64_t **)a2;
  unint64_t v22 = *(uint64_t (***)(void, uint64_t, unint64_t *))(a2 + 8);
  unint64_t v14 = **(void **)a2;
  uint64_t v15 = *v12;
  memset(v29, 0, sizeof(v29));
  uint64_t v16 = *(void *)(a1 + 16);
  uint64_t v17 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v14);
  uint64_t v24 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v14);
  int v23 = (unint64_t **)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, (24 * v14 + 23) >> 3);
  uint64_t v21 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 3 * v14);
  uint64_t result = 4294967289;
  if (a4 <= 0x10 && a6 <= 0x10)
  {
    unint64_t v19 = (unint64_t)(v15 + 7) >> 3;
    ccsae_lexographic_order_key_internal(a3, a4, a5, a6, v32);
    cchmac_internal((uint64_t)v12, *v12, (uint64_t)v29, a6 + a4, (uint64_t)v32, (uint64_t)v30);
    uint64_t result = ccn_read_uint_internal(v19, v31, *v12, v30);
    if (!result)
    {
      unint64_t v20 = (void *)cczp_prime((uint64_t)&v13[5 * v14 + 4]);
      ccn_set(v14, v17, v20);
      *v17 &= ~1uLL;
      ccn_divmod_ws(a1, v19, (uint64_t)v31, 0, 0, v14, v24, v17);
      ccn_add1_ws(a1, v14, v24, (uint64_t *)v24, 1);
      *int v23 = v13;
      uint64_t result = ccec_import_pub_ws(a1, v13, a8, a7, v23);
      if (!result)
      {
        uint64_t result = ccec_validate_point_and_projectify_ws(a1, (uint64_t *)v13, v21, (uint64_t)(v23 + 2));
        if (!result)
        {
          uint64_t result = ccec_mult_blinded_ws(a1, v13, a2 + 144, (uint64_t)v24, v21, v22);
          if (!result) {
            *(unsigned char *)(a2 + 24) |= CCSAE_STATE_COMMIT_UPDATE;
          }
        }
      }
    }
  }
  *(void *)(a1 + 16) = v16;
  return result;
}

uint64_t ccsae_generate_h2c_commit(uint64_t **a1, const void *a2, size_t a3, void *a4, size_t a5, uint64_t a6, uint64_t a7, char *a8)
{
  BOOL v32 = timingsafe_enable_if_supported();
  uint64_t v13 = **a1;
  uint64_t v14 = sizeof_struct_cche_galois_key();
  unint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
  uint64_t v16 = 3 * v13;
  uint64_t v17 = 28 * v13;
  unint64_t v18 = (v14 + v15 + v15 * 3 * v13 - 1) / v15 + 28 * v13;
  uint64_t v19 = 24 * v13;
  if (v18 <= 24 * v13) {
    unint64_t v18 = 24 * v13;
  }
  unint64_t v20 = cc_malloc_clear(8 * v18);
  v30[0] = v20;
  uint64_t v21 = sizeof_struct_cche_galois_key();
  unint64_t v22 = sizeof_struct_ccpolyzp_po2cyc();
  unint64_t v23 = (v21 + v22 + v22 * v16 - 1) / v22 + v17;
  if (v23 <= 8 * v16) {
    unint64_t v23 = v19;
  }
  v30[1] = v23;
  _OWORD v30[2] = 0;
  v30[3] = cc_ws_alloc;
  uint64_t v31 = cc_ws_free;
  if (v20)
  {
    h2c_commit_init_uint64_t ws = ccsae_generate_h2c_commit_init_ws((uint64_t)v30, (uint64_t)a1, a2, a3, a4, a5, a6, a7);
    if (!h2c_commit_init_ws) {
      h2c_commit_init_uint64_t ws = ccsae_generate_h2c_commit_finalize_ws((uint64_t)v30, (uint64_t)a1, a8);
    }
    uint64_t v25 = h2c_commit_init_ws;
    v31((uint64_t)v30);
  }
  else
  {
    uint64_t v25 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v32);
  return v25;
}

uint64_t ccsae_generate_commitment_shared_ws(uint64_t a1, uint64_t *a2, uint64_t a3, char *a4)
{
  uint64_t v8 = (unint64_t *)*a2;
  unint64_t v9 = *(void *)*a2;
  uint64_t v10 = cczp_bitlen(*a2);
  int v11 = (uint64_t (**)(void, unint64_t, void *))a2[1];
  uint64_t v16 = *(void *)(a1 + 16);
  unint64_t v12 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v9);
  uint64_t v13 = a2 + 18;
  if (ccec_generate_scalar_fips_retry_ws(a1, v8, v11, &a2[4 * *(void *)*a2 + 18])
    || ccec_generate_scalar_fips_retry_ws(a1, v8, v11, v12)
    || ccec_mult_blinded_ws(a1, v8, (uint64_t)&v13[5 * *(void *)*a2], (uint64_t)v12, a3, (uint64_t (**)(void, uint64_t, unint64_t *))v11)|| ccec_affinify_ws(a1, (uint64_t)v8)|| (cczp_negate((uint64_t)v8, &v13[6 * *(void *)*a2], (unint64_t *)&v13[6 * *(void *)*a2]), cczp_add_ws(a1, (uint64_t)&v8[5 * *v8 + 4]), !v9)|| ccn_n(v9, (uint64_t)&v13[3 * *(void *)*a2]) <= 1 && (unint64_t)v13[3 * *(void *)*a2] < 2|| (unint64_t v14 = (unint64_t)(v10 + 7) >> 3, (ccn_write_uint_padded_ct_internal(v9, (unint64_t *)&v13[3 * *(void *)*a2], v14, a4) & 0x80000000) != 0)|| (ccn_write_uint_padded_ct_internal(v9, (unint64_t *)&v13[5 * *(void *)*a2], v14, &a4[v14]) & 0x80000000) != 0|| (ccn_write_uint_padded_ct_internal(v9, (unint64_t *)&v13[6 * *(void *)*a2], v14, &a4[2 * v14]) & 0x80000000) != 0)
  {
    uint64_t result = 4294967289;
  }
  else
  {
    uint64_t result = ccec_affinify_ws(a1, (uint64_t)v8);
  }
  *(void *)(a1 + 16) = v16;
  return result;
}

uint64_t cche_serialize_ciphertext_coeff_nbytes_internal(uint64_t a1, unsigned int *a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (!v2) {
    return 2;
  }
  unint64_t v4 = *(unsigned int **)(a1 + 24);
  uint64_t v5 = 2;
  unint64_t v6 = a2;
  do
  {
    if (a2) {
      unsigned int v7 = *v6;
    }
    else {
      unsigned int v7 = 0;
    }
    v5 += ccpolyzp_po2cyc_serialize_poly_nbytes(v4, v7);
    ++v6;
    --v2;
  }
  while (v2);
  return v5;
}

uint64_t cche_serialize_ciphertext_coeff_nbytes(uint64_t a1, unsigned int *a2)
{
  BOOL v6 = timingsafe_enable_if_supported();
  uint64_t v4 = cche_serialize_ciphertext_coeff_nbytes_internal(a1, a2);
  cc_disable_dit_with_sb((unsigned int *)&v6);
  return v4;
}

uint64_t cche_serialize_ciphertext_eval_nbytes(uint64_t a1)
{
  BOOL v6 = timingsafe_enable_if_supported();
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2)
  {
    unint64_t v3 = *(unsigned int **)(a1 + 24);
    uint64_t v4 = 2;
    do
    {
      v4 += ccpolyzp_po2cyc_serialize_poly_nbytes(v3, 0);
      --v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v4 = 2;
  }
  cc_disable_dit_with_sb((unsigned int *)&v6);
  return v4;
}

uint64_t cche_serialize_seeded_ciphertext_coeff_nbytes(uint64_t a1)
{
  BOOL v4 = timingsafe_enable_if_supported();
  uint64_t v2 = ccpolyzp_po2cyc_serialize_poly_nbytes(*(unsigned int **)(a1 + 24), 0);
  cc_disable_dit_with_sb((unsigned int *)&v4);
  return v2;
}

uint64_t cche_serialize_seeded_ciphertext_eval_nbytes(uint64_t a1)
{
  BOOL v4 = timingsafe_enable_if_supported();
  uint64_t v2 = ccpolyzp_po2cyc_serialize_poly_nbytes(*(unsigned int **)(a1 + 24), 0);
  cc_disable_dit_with_sb((unsigned int *)&v4);
  return v2;
}

uint64_t cche_serialize_ciphertext_coeff_max_nskip_lsbs(_DWORD *a1, unsigned int *a2)
{
  BOOL v5 = timingsafe_enable_if_supported();
  cche_serialize_ciphertext_coeff_max_nskip_lsbs_internal(a1, a2);
  return cc_disable_dit_with_sb((unsigned int *)&v5);
}

uint64_t cche_serialize_ciphertext_coeff_max_nskip_lsbs_internal(_DWORD *a1, unsigned int *a2)
{
  if (a2[2])
  {
    unint64_t v4 = 0;
    do
    {
      a1[v4++] = 0;
      unint64_t v5 = a2[2];
    }
    while (v4 < v5);
  }
  else
  {
    LODWORD(v5) = 0;
  }
  uint64_t result = cche_ciphertext_fresh_npolys();
  if (v5 == result)
  {
    uint64_t v7 = *(void *)a2;
    *a1 = *(_DWORD *)(*(void *)a2 + 20);
    a1[1] = *(_DWORD *)(v7 + 24);
  }
  return result;
}

uint64_t cche_serialize_ciphertext_coeff_ws(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v23 = *MEMORY[0x263EF8C08];
  if (cche_serialize_ciphertext_coeff_nbytes_internal(a4, a5) != a2) {
    return 4294967289;
  }
  uint64_t v9 = *(unsigned int *)(a4 + 8);
  if (WORD1(v9)) {
    return 4294967289;
  }
  if (!a5) {
    goto LABEL_9;
  }
  if (v9 != cche_ciphertext_fresh_npolys()) {
    return 4294967289;
  }
  cche_serialize_ciphertext_coeff_max_nskip_lsbs_internal(v22, (unsigned int *)a4);
  if (v9)
  {
    uint64_t v10 = 0;
    while (a5[v10] <= v22[v10])
    {
      if (v9 == ++v10) {
        goto LABEL_9;
      }
    }
    return 4294967289;
  }
LABEL_9:
  uint64_t v13 = *(unsigned int **)(a4 + 24);
  int v11 = (_DWORD **)(a4 + 24);
  unint64_t v12 = v13;
  *a3 = v9;
  if (!v9) {
    return 0;
  }
  uint64_t v14 = 0;
  uint64_t v15 = (uint64_t)(a3 + 1);
  while (1)
  {
    uint64_t v16 = *v11;
    uint64_t v17 = sizeof_struct_ccpolyzp_po2cyc();
    unsigned int v18 = a5 ? a5[v14] : 0;
    uint64_t v19 = &v11[((v16[1] * *v16) + ((unint64_t)(v17 + 7) >> 3)) * v14];
    uint64_t v20 = ccpolyzp_po2cyc_serialize_poly_nbytes(v12, v18);
    uint64_t result = ccpolyzp_po2cyc_serialize_poly_ws(a1, v20, v15, v18, v19);
    if (result) {
      break;
    }
    v15 += v20;
    if (v9 == ++v14) {
      return 0;
    }
  }
  return result;
}

uint64_t cche_serialize_ciphertext_coeff(uint64_t a1, _WORD *a2, uint64_t *a3, unsigned int *a4)
{
  BOOL v15 = timingsafe_enable_if_supported();
  unsigned int v8 = cche_param_ctx_polynomial_degree(*a3);
  uint64_t v9 = CCPOLYZP_PO2CYC_SERIALIZE_POLY_WORKSPACE_N(v8);
  v13[0] = cc_malloc_clear(8 * v9);
  unsigned int v10 = cche_param_ctx_polynomial_degree(*a3);
  v13[1] = CCPOLYZP_PO2CYC_SERIALIZE_POLY_WORKSPACE_N(v10);
  void v13[2] = 0;
  uint64_t v13[3] = cc_ws_alloc;
  uint64_t v14 = cc_ws_free;
  if (v13[0])
  {
    uint64_t v11 = cche_serialize_ciphertext_coeff_ws((uint64_t)v13, a1, a2, (uint64_t)a3, a4);
    v14((uint64_t)v13);
  }
  else
  {
    uint64_t v11 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v11;
}

uint64_t cche_serialize_ciphertext_eval(uint64_t a1, _WORD *a2, uint64_t *a3)
{
  BOOL v13 = timingsafe_enable_if_supported();
  unsigned int v6 = cche_param_ctx_polynomial_degree(*a3);
  uint64_t v7 = CCPOLYZP_PO2CYC_SERIALIZE_POLY_WORKSPACE_N(v6);
  v11[0] = cc_malloc_clear(8 * v7);
  unsigned int v8 = cche_param_ctx_polynomial_degree(*a3);
  v11[1] = CCPOLYZP_PO2CYC_SERIALIZE_POLY_WORKSPACE_N(v8);
  _OWORD v11[2] = 0;
  v11[3] = cc_ws_alloc;
  unint64_t v12 = cc_ws_free;
  if (v11[0])
  {
    uint64_t v9 = cche_serialize_ciphertext_coeff_ws((uint64_t)v11, a1, a2, (uint64_t)a3, 0);
    v12((uint64_t)v11);
  }
  else
  {
    uint64_t v9 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v13);
  return v9;
}

uint64_t cche_deserialize_ciphertext_coeff_ws(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, unsigned int *a5)
{
  unsigned int v10 = (_DWORD **)(a2 + 24);
  uint64_t v9 = *(unsigned int **)(a2 + 24);
  if (cche_serialize_ciphertext_coeff_nbytes_internal(a2, a5) != a3) {
    return 4294967289;
  }
  uint64_t v11 = (unsigned __int16)*a4;
  if (v11 != *(_DWORD *)(a2 + 8)) {
    return 4294967289;
  }
  if (!*a4) {
    return 0;
  }
  uint64_t v12 = 0;
  uint64_t v13 = (uint64_t)(a4 + 1);
  while (1)
  {
    unsigned int v14 = a5 ? a5[v12] : 0;
    uint64_t v15 = ccpolyzp_po2cyc_serialize_poly_nbytes(v9, v14);
    uint64_t v16 = *v10;
    uint64_t v17 = sizeof_struct_ccpolyzp_po2cyc();
    uint64_t result = ccpolyzp_po2cyc_deserialize_poly_ws(a1, &v10[((v16[1] * *v16) + ((unint64_t)(v17 + 7) >> 3)) * v12], v14, v15, v13);
    if (result) {
      break;
    }
    v13 += v15;
    if (v11 == ++v12) {
      return 0;
    }
  }
  return result;
}

uint64_t cche_deserialize_ciphertext_coeff(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, int a5, unsigned int a6, uint64_t a7, unsigned int *a8)
{
  BOOL v33 = timingsafe_enable_if_supported();
  unsigned int v16 = cche_param_ctx_polynomial_degree(a4);
  uint64_t v17 = CCPOLYZP_PO2CYC_SERIALIZE_POLY_WORKSPACE_N(v16);
  v31[0] = cc_malloc_clear(8 * v17);
  unsigned int v18 = cche_param_ctx_polynomial_degree(a4);
  v31[1] = CCPOLYZP_PO2CYC_SERIALIZE_POLY_WORKSPACE_N(v18);
  _OWORD v31[2] = 0;
  v31[3] = cc_ws_alloc;
  BOOL v32 = cc_ws_free;
  if (v31[0])
  {
    uint64_t v29 = a2;
    uint64_t v30 = a7;
    uint64_t v19 = (unsigned int *)cche_param_ctx_chain_const(a4);
    uint64_t v20 = *v19;
    unint64_t v21 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
    if (v20 >= 0x80) {
      uint64_t v22 = 128;
    }
    else {
      uint64_t v22 = v20;
    }
    unint64_t v23 = (unint64_t)&v19[2
                               * (v21
                                + 2 * (v20 + ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v22)
                                + 6)
                               * (v19[1] - a5)
                               + 2];
    *(void *)a1 = a4;
    *(_DWORD *)(a1 + 8) = a6;
    *(void *)(a1 + 16) = 1;
    *(void *)(a1 + 24) = v23;
    uint64_t v24 = (_DWORD **)(a1 + 24);
    if (a6 >= 2)
    {
      uint64_t v25 = 1;
      do
      {
        uint64_t v26 = *v24;
        v24[((v26[1] * *v26) + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3)) * v25++] = (_DWORD *)v23;
      }
      while (a6 != v25);
    }
    uint64_t v27 = cche_deserialize_ciphertext_coeff_ws((uint64_t)v31, a1, v29, a3, a8);
    *(void *)(a1 + 16) = v30;
    v32((uint64_t)v31);
  }
  else
  {
    uint64_t v27 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v33);
  return v27;
}

uint64_t cche_deserialize_ciphertext_eval(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, int a5, unsigned int a6, uint64_t a7)
{
  BOOL v30 = timingsafe_enable_if_supported();
  unsigned int v14 = cche_param_ctx_polynomial_degree(a4);
  uint64_t v15 = CCPOLYZP_PO2CYC_SERIALIZE_POLY_WORKSPACE_N(v14);
  v28[0] = cc_malloc_clear(8 * v15);
  unsigned int v16 = cche_param_ctx_polynomial_degree(a4);
  v28[1] = CCPOLYZP_PO2CYC_SERIALIZE_POLY_WORKSPACE_N(v16);
  void v28[2] = 0;
  v28[3] = cc_ws_alloc;
  uint64_t v29 = cc_ws_free;
  if (v28[0])
  {
    uint64_t v27 = a7;
    uint64_t v17 = (unsigned int *)cche_param_ctx_chain_const(a4);
    uint64_t v18 = *v17;
    unint64_t v19 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
    if (v18 >= 0x80) {
      uint64_t v20 = 128;
    }
    else {
      uint64_t v20 = v18;
    }
    unint64_t v21 = (unint64_t)&v17[2
                               * (v19
                                + 2 * (v18 + ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v20)
                                + 6)
                               * (v17[1] - a5)
                               + 2];
    *(void *)a1 = a4;
    *(_DWORD *)(a1 + 8) = a6;
    *(void *)(a1 + 16) = 1;
    *(void *)(a1 + 24) = v21;
    uint64_t v22 = (_DWORD **)(a1 + 24);
    if (a6 >= 2)
    {
      uint64_t v23 = 1;
      do
      {
        uint64_t v24 = *v22;
        v22[((v24[1] * *v24) + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3)) * v23++] = (_DWORD *)v21;
      }
      while (a6 != v23);
    }
    uint64_t v25 = cche_deserialize_ciphertext_coeff_ws((uint64_t)v28, a1, a2, a3, 0);
    *(void *)(a1 + 16) = v27;
    v29((uint64_t)v28);
  }
  else
  {
    uint64_t v25 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v30);
  return v25;
}

uint64_t cche_serialize_seeded_ciphertext_coeff(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v13 = timingsafe_enable_if_supported();
  unsigned int v6 = cche_param_ctx_polynomial_degree(*(void *)a3);
  uint64_t v7 = CCPOLYZP_PO2CYC_SERIALIZE_POLY_WORKSPACE_N(v6);
  v11[0] = cc_malloc_clear(8 * v7);
  unsigned int v8 = cche_param_ctx_polynomial_degree(*(void *)a3);
  v11[1] = CCPOLYZP_PO2CYC_SERIALIZE_POLY_WORKSPACE_N(v8);
  _OWORD v11[2] = 0;
  v11[3] = cc_ws_alloc;
  uint64_t v12 = cc_ws_free;
  if (v11[0])
  {
    uint64_t v9 = ccpolyzp_po2cyc_serialize_poly_ws((uint64_t)v11, a1, a2, 0, (unsigned int **)(a3 + 24));
    v12((uint64_t)v11);
  }
  else
  {
    uint64_t v9 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v13);
  return v9;
}

uint64_t cche_serialize_seeded_ciphertext_eval(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v13 = timingsafe_enable_if_supported();
  unsigned int v6 = cche_param_ctx_polynomial_degree(*(void *)a3);
  uint64_t v7 = CCPOLYZP_PO2CYC_SERIALIZE_POLY_WORKSPACE_N(v6);
  v11[0] = cc_malloc_clear(8 * v7);
  unsigned int v8 = cche_param_ctx_polynomial_degree(*(void *)a3);
  v11[1] = CCPOLYZP_PO2CYC_SERIALIZE_POLY_WORKSPACE_N(v8);
  _OWORD v11[2] = 0;
  v11[3] = cc_ws_alloc;
  uint64_t v12 = cc_ws_free;
  if (v11[0])
  {
    uint64_t v9 = ccpolyzp_po2cyc_serialize_poly_ws((uint64_t)v11, a1, a2, 0, (unsigned int **)(a3 + 24));
    v12((uint64_t)v11);
  }
  else
  {
    uint64_t v9 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v13);
  return v9;
}

uint64_t cche_deserialize_seeded_ciphertext_coeff_ws(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = cche_deserialize_seeded_ciphertext_eval_ws(a1, a2, a3, a4);
  if (!result)
  {
    unsigned int v6 = *(_DWORD **)(a2 + 24);
    uint64_t v7 = (unsigned int **)(a2
                         + 24
                         + 8
                         * ((v6[1] * *v6) + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3)));
    return ccpolyzp_po2cyc_inv_ntt(v7);
  }
  return result;
}

uint64_t cche_deserialize_seeded_ciphertext_eval_ws(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v8 = *(_DWORD *)(a2 + 8);
  if (v8 != cche_ciphertext_fresh_npolys()) {
    return 4294967289;
  }
  unsigned int v10 = *(unsigned int **)(a2 + 24);
  uint64_t v9 = (unsigned int **)(a2 + 24);
  if (ccpolyzp_po2cyc_serialize_poly_nbytes(v10, 0) != a3) {
    return 4294967289;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t result = ccpolyzp_po2cyc_deserialize_poly_ws(a1, v9, 0, a3, a4);
  if (!result)
  {
    BOOL v13 = (uint64_t (**)(void, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 536);
    uint64_t result = ccpolyzp_po2cyc_block_rng_init((uint64_t)v13);
    if (!result)
    {
      unsigned int v14 = *v9;
      uint64_t v15 = sizeof_struct_ccpolyzp_po2cyc();
      uint64_t result = ccpolyzp_po2cyc_random_uniform_ws(a1, &(&v9[v14[1] * *v14])[(unint64_t)(v15 + 7) >> 3], v13);
    }
  }
  *(void *)(a1 + 16) = v11;
  return result;
}

unint64_t CCHE_DESERIALIZE_SEEDED_CIPHERTEXT_EVAL_WORKSPACE_N(unint64_t a1)
{
  unint64_t v2 = CCPOLYZP_PO2CYC_SERIALIZE_POLY_WORKSPACE_N(a1);
  uint64_t v3 = CCPOLYZP_PO2CYC_RANDOM_UNIFORM_WORKSPACE_N(a1);
  uint64_t v4 = sizeof_struct_ccpolyzp_po2cyc_block_rng_state();
  unint64_t v5 = sizeof_struct_ccpolyzp_po2cyc();
  if (v2 <= (v4 + v5 - 1) / v5 + v3) {
    return (v4 + v5 - 1) / v5 + v3;
  }
  else {
    return v2;
  }
}

uint64_t cche_deserialize_seeded_ciphertext_coeff(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7)
{
  BOOL v31 = timingsafe_enable_if_supported();
  unsigned int v13 = cche_param_ctx_polynomial_degree(a5);
  unint64_t v14 = CCHE_DESERIALIZE_SEEDED_CIPHERTEXT_EVAL_WORKSPACE_N(v13);
  v29[0] = cc_malloc_clear(8 * v14);
  unsigned int v15 = cche_param_ctx_polynomial_degree(a5);
  v29[1] = CCHE_DESERIALIZE_SEEDED_CIPHERTEXT_EVAL_WORKSPACE_N(v15);
  _OWORD v29[2] = 0;
  v29[3] = cc_ws_alloc;
  BOOL v30 = cc_ws_free;
  if (v29[0])
  {
    uint64_t v28 = a7;
    unsigned int v16 = (unsigned int *)cche_param_ctx_chain_const(a5);
    uint64_t v17 = *v16;
    unint64_t v18 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
    if (v17 >= 0x80) {
      uint64_t v19 = 128;
    }
    else {
      uint64_t v19 = v17;
    }
    unint64_t v20 = (unint64_t)&v16[2
                               * (v18
                                + 2 * (v17 + ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v19)
                                + 6)
                               * (v16[1] - a6)
                               + 2];
    unsigned int v21 = cche_ciphertext_fresh_npolys();
    *(void *)a1 = a5;
    *(_DWORD *)(a1 + 8) = v21;
    *(void *)(a1 + 16) = 1;
    *(void *)(a1 + 24) = v20;
    uint64_t v22 = (_DWORD **)(a1 + 24);
    if (v21 >= 2)
    {
      uint64_t v23 = v21;
      for (uint64_t i = 1; i != v23; ++i)
      {
        uint64_t v25 = *v22;
        v22[((v25[1] * *v25) + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3)) * i] = (_DWORD *)v20;
      }
    }
    uint64_t v26 = cche_deserialize_seeded_ciphertext_coeff_ws((uint64_t)v29, a1, a2, a3);
    *(void *)(a1 + 16) = v28;
    v30((uint64_t)v29);
  }
  else
  {
    uint64_t v26 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v31);
  return v26;
}

uint64_t cche_deserialize_seeded_ciphertext_eval(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7)
{
  BOOL v31 = timingsafe_enable_if_supported();
  unsigned int v13 = cche_param_ctx_polynomial_degree(a5);
  unint64_t v14 = CCHE_DESERIALIZE_SEEDED_CIPHERTEXT_EVAL_WORKSPACE_N(v13);
  v29[0] = cc_malloc_clear(8 * v14);
  unsigned int v15 = cche_param_ctx_polynomial_degree(a5);
  v29[1] = CCHE_DESERIALIZE_SEEDED_CIPHERTEXT_EVAL_WORKSPACE_N(v15);
  _OWORD v29[2] = 0;
  v29[3] = cc_ws_alloc;
  BOOL v30 = cc_ws_free;
  if (v29[0])
  {
    uint64_t v28 = a7;
    unsigned int v16 = (unsigned int *)cche_param_ctx_chain_const(a5);
    uint64_t v17 = *v16;
    unint64_t v18 = (unint64_t)(sizeof_struct_ccpolyzp_po2cyc_ctx() + 7) >> 3;
    if (v17 >= 0x80) {
      uint64_t v19 = 128;
    }
    else {
      uint64_t v19 = v17;
    }
    unint64_t v20 = (unint64_t)&v16[2
                               * (v18
                                + 2 * (v17 + ((unint64_t)(sizeof_struct_ccrns_mul_modulus() + 7) >> 3) * v19)
                                + 6)
                               * (v16[1] - a6)
                               + 2];
    unsigned int v21 = cche_ciphertext_fresh_npolys();
    *(void *)a1 = a5;
    *(_DWORD *)(a1 + 8) = v21;
    *(void *)(a1 + 16) = 1;
    *(void *)(a1 + 24) = v20;
    uint64_t v22 = (_DWORD **)(a1 + 24);
    if (v21 >= 2)
    {
      uint64_t v23 = v21;
      for (uint64_t i = 1; i != v23; ++i)
      {
        uint64_t v25 = *v22;
        v22[((v25[1] * *v25) + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3)) * i] = (_DWORD *)v20;
      }
    }
    uint64_t v26 = cche_deserialize_seeded_ciphertext_eval_ws((uint64_t)v29, a1, a2, a3);
    *(void *)(a1 + 16) = v28;
    v30((uint64_t)v29);
  }
  else
  {
    uint64_t v26 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v31);
  return v26;
}

uint64_t cche_bytes_to_coeffs(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = ccpolyzp_po2cyc_bytes_to_coeffs(a1, a2, a3, a4, a5, 0);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t cche_coeffs_to_bytes(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = ccpolyzp_po2cyc_coeffs_to_bytes(a1, a2, a3, a4, a5, 0);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccn_recode_jsf_init(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  void v16[2] = *MEMORY[0x263EF8C08];
  unint64_t v5 = (unint64_t)(a2 - 1) >> 6;
  *(void *)(result + 8) = a3;
  *(void *)(result + 16) = a4;
  char v6 = (a2 - 1) & 0x3F;
  unint64_t v7 = (unint64_t)(a2 - 2) >> 6;
  char v8 = (a2 - 2) & 0x3F;
  v16[0] = a3;
  v16[1] = a4;
  unint64_t v9 = (unint64_t)(a2 - 3) >> 6;
  char v10 = (a2 - 3) & 0x3F;
  unint64_t v11 = (unint64_t)(a2 - 4) >> 6;
  char v12 = (a2 - 4) & 0x3F;
  char v13 = 1;
  do
  {
    char v14 = v13;
    uint64_t v15 = v16[v4];
    *(unsigned char *)(result + v4) = (8 * ((*(void *)(v15 + 8 * v5) >> v6) & 1)) | (4
                                                                             * ((*(void *)(v15 + 8 * v7) >> v8) & 1)) | (2 * ((*(void *)(v15 + 8 * v9) >> v10) & 1)) | (*(void *)(v15 + 8 * v11) >> v12) & 1;
    uint64_t v4 = 1;
    char v13 = 0;
  }
  while ((v14 & 1) != 0);
  return result;
}

uint64_t ccn_recode_jsf_column(uint64_t result, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v12 = *MEMORY[0x263EF8C08];
  if ((*(unsigned char *)result & 0x20) != 0) {
    char v4 = *(unsigned char *)result & 0x1F ^ 0x1F;
  }
  else {
    char v4 = *(unsigned char *)result & 0x1F;
  }
  v10[0] = v4;
  if ((*(unsigned char *)(result + 1) & 0x20) != 0) {
    char v5 = *(unsigned char *)(result + 1) & 0x1F ^ 0x1F;
  }
  else {
    char v5 = *(unsigned char *)(result + 1) & 0x1F;
  }
  v10[1] = v5;
  long long v11 = *(_OWORD *)(result + 8);
  char v6 = 1;
  do
  {
    char v7 = v6;
    if (a2 < 5) {
      LOBYTE(v8) = 0;
    }
    else {
      uint64_t v8 = (*(void *)(*((void *)&v11 + v3) + 8 * ((a2 - 5) >> 6)) >> ((a2 - 5) & 0x3F)) & 1;
    }
    if (v10[v3] >= F_2_2_11[v10[v3 ^ 1]])
    {
      LOBYTE(v8) = v8 | 0x20;
      if ((*(unsigned char *)(result + v3) & 0x20) != 0) {
        int v9 = -1;
      }
      else {
        int v9 = 1;
      }
    }
    else
    {
      int v9 = 0;
    }
    char v6 = 0;
    *(_DWORD *)(a3 + 4 * v3) = v9;
    *(unsigned char *)(result + v3) = v8 ^ (2 * *(unsigned char *)(result + v3));
    uint64_t v3 = 1;
  }
  while ((v7 & 1) != 0);
  return result;
}

unint64_t ccn_recode_jsf_index(_DWORD *a1)
{
  return (*a1 & 1 | (2 * (a1[1] & 1u))) - (unint64_t)(*a1 + a1[1] != 0);
}

uint64_t ccn_recode_jsf_direction(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result != -1)
  {
    if (!result && a1[1] == -1) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 1;
    }
  }
  return result;
}

uint64_t ccmode_gcm_init(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 72);
  if (*(void *)(v2 + 8) != 16) {
    return 0xFFFFFFFFLL;
  }
  *(void *)(a2 + 104) = v2;
  *(void *)(a2 + 112) = a2 + 128;
  *(_DWORD *)(a2 + 120) = *(_DWORD *)(a1 + 8);
  (*(void (**)(uint64_t))(v2 + 16))(v2);
  *(_WORD *)(a2 + 82) = 0;
  ccmode_gcm_reset(a2);
  (*(void (**)(void, uint64_t, uint64_t, uint64_t))(v2 + 24))(*(void *)(a2 + 112), 1, a2 + 16, a2);
  return 0;
}

void *ccsha1_di()
{
  return &ccsha1_ltc_di;
}

uint64_t ccdes_key_is_weak(char *a1, uint64_t a2)
{
  BOOL v7 = timingsafe_enable_if_supported();
  if (a2 == 8)
  {
    uint64_t v4 = 0;
    while (cc_cmp_safe_internal(8, &weak_keys[v4], a1))
    {
      v4 += 8;
      if (v4 == 128)
      {
        uint64_t v5 = 0;
        goto LABEL_7;
      }
    }
  }
  uint64_t v5 = 0xFFFFFFFFLL;
LABEL_7:
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return v5;
}

uint64_t ccdes_key_set_odd_parity(unsigned char *a1, uint64_t a2)
{
  for (BOOL i = timingsafe_enable_if_supported(); a2; --a2)
  {
    *a1 = odd_parity[*a1];
    ++a1;
  }
  return cc_disable_dit_with_sb((unsigned int *)&i);
}

long long *ccsha512_ltc_compress(long long *result, uint64_t a2, uint64_t a3)
{
  for (uint64_t i = *MEMORY[0x263EF8C08]; a2; --a2)
  {
    uint64_t v3 = 0;
    long long v4 = result[1];
    long long v39 = *result;
    long long v40 = v4;
    long long v5 = result[3];
    long long v41 = result[2];
    long long v42 = v5;
    do
    {
      v37[v3] = bswap64(*(void *)(a3 + v3 * 8));
      ++v3;
    }
    while (v3 != 16);
    unint64_t v6 = 0;
    unint64_t v7 = v37[0];
    do
    {
      unint64_t v8 = v37[v6 / 8 + 1];
      *(void *)&v38[v6 + 96] = (__ROR8__(*(void *)&v38[v6 + 80], 19) ^ __ROR8__(*(void *)&v38[v6 + 80], 61) ^ (*(void *)&v38[v6 + 80] >> 6))
                               + *(void *)&v38[v6 + 40]
                               + v7
                               + (__ROR8__(v8, 1) ^ __ROR8__(v8, 8) ^ (v8 >> 7));
      v6 += 8;
      unint64_t v7 = v8;
    }
    while (v6 != 512);
    uint64_t v9 = *((void *)&v42 + 1);
    uint64_t v10 = v42;
    uint64_t v12 = *((void *)&v41 + 1);
    uint64_t v11 = v41;
    uint64_t v14 = *((void *)&v39 + 1);
    uint64_t v13 = v39;
    uint64_t v15 = &xmmword_2373B4610;
    unint64_t v16 = -8;
    uint64_t v17 = v38;
    uint64_t v18 = *((void *)&v40 + 1);
    uint64_t v19 = v40;
    do
    {
      uint64_t v20 = (__ROR8__(v11, 14) ^ __ROR8__(v11, 18) ^ __ROR8__(v11, 41))
          + v9
          + *((void *)v15 - 4)
          + *(v17 - 4)
          + (v12 & v11 | v10 & ~v11);
      uint64_t v21 = v18 + v20;
      uint64_t v22 = v20 + (__ROR8__(v13, 28) ^ __ROR8__(v13, 34) ^ __ROR8__(v13, 39)) + ((v14 | v13) & v19 | v14 & v13);
      uint64_t v23 = (v11 & v21 | v12 & ~v21)
          + v10
          + *((void *)v15 - 3)
          + *(v17 - 3)
          + (__ROR8__(v21, 14) ^ __ROR8__(v21, 18) ^ __ROR8__(v21, 41));
      uint64_t v24 = v23 + v19;
      uint64_t v25 = (__ROR8__(v22, 28) ^ __ROR8__(v22, 34) ^ __ROR8__(v22, 39)) + ((v22 | v13) & v14 | v22 & v13) + v23;
      uint64_t v26 = *((void *)v15 - 2)
          + v12
          + *(v17 - 2)
          + (v21 & v24 | v11 & ~v24)
          + (__ROR8__(v24, 14) ^ __ROR8__(v24, 18) ^ __ROR8__(v24, 41));
      uint64_t v27 = v26 + v14;
      uint64_t v28 = (__ROR8__(v25, 28) ^ __ROR8__(v25, 34) ^ __ROR8__(v25, 39)) + ((v25 | v22) & v13 | v25 & v22) + v26;
      uint64_t v29 = *((void *)v15 - 1)
          + v11
          + *(v17 - 1)
          + (v24 & v27 | v21 & ~v27)
          + (__ROR8__(v27, 14) ^ __ROR8__(v27, 18) ^ __ROR8__(v27, 41));
      uint64_t v30 = v29 + v13;
      uint64_t v31 = (__ROR8__(v28, 28) ^ __ROR8__(v28, 34) ^ __ROR8__(v28, 39)) + ((v28 | v25) & v22 | v28 & v25) + v29;
      uint64_t v32 = *(void *)v15
          + *v17
          + v21
          + (v27 & v30 | v24 & ~v30)
          + (__ROR8__(v30, 14) ^ __ROR8__(v30, 18) ^ __ROR8__(v30, 41));
      uint64_t v9 = v32 + v22;
      uint64_t v18 = (__ROR8__(v31, 28) ^ __ROR8__(v31, 34) ^ __ROR8__(v31, 39)) + ((v31 | v28) & v25 | v31 & v28) + v32;
      uint64_t v33 = *((void *)v15 + 1)
          + v17[1]
          + v24
          + (v30 & v9 | v27 & ~v9)
          + (__ROR8__(v9, 14) ^ __ROR8__(v9, 18) ^ __ROR8__(v9, 41));
      uint64_t v10 = v33 + v25;
      uint64_t v19 = (__ROR8__(v18, 28) ^ __ROR8__(v18, 34) ^ __ROR8__(v18, 39)) + ((v18 | v31) & v28 | v18 & v31) + v33;
      uint64_t v34 = *((void *)v15 + 2)
          + v17[2]
          + v27
          + (v9 & v10 | v30 & ~v10)
          + (__ROR8__(v10, 14) ^ __ROR8__(v10, 18) ^ __ROR8__(v10, 41));
      uint64_t v12 = v34 + v28;
      uint64_t v14 = (__ROR8__(v19, 28) ^ __ROR8__(v19, 34) ^ __ROR8__(v19, 39)) + ((v19 | v18) & v31 | v19 & v18) + v34;
      uint64_t v35 = *((void *)v15 + 3)
          + v17[3]
          + v30
          + (v10 & v12 | v9 & ~v12)
          + (__ROR8__(v12, 14) ^ __ROR8__(v12, 18) ^ __ROR8__(v12, 41));
      uint64_t v11 = v35 + v31;
      uint64_t v13 = (__ROR8__(v14, 28) ^ __ROR8__(v14, 34) ^ __ROR8__(v14, 39)) + ((v14 | v19) & v18 | v14 & v19) + v35;
      v16 += 8;
      v17 += 8;
      v15 += 4;
    }
    while (v16 < 0x48);
    uint64_t v36 = 0;
    *(void *)&long long v42 = v10;
    *((void *)&v42 + 1) = v9;
    *(void *)&long long v41 = v11;
    *((void *)&v41 + 1) = v12;
    *(void *)&long long v39 = v13;
    *((void *)&v39 + 1) = v14;
    *(void *)&long long v40 = v19;
    *((void *)&v40 + 1) = v18;
    do
    {
      result[v36] = (__int128)vaddq_s64(*(int64x2_t *)((char *)&v39 + v36 * 16), (int64x2_t)result[v36]);
      ++v36;
    }
    while (v36 != 4);
    a3 += 128;
  }
  return result;
}

uint64_t ccsha512_final(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v23[1] = *MEMORY[0x263EF8C08];
  uint64_t v7 = *(void *)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 16);
  uint64_t v8 = a2 + v7 + 8;
  if (v6 <= *(unsigned int *)(v8 + v6)) {
    *(_DWORD *)(v8 + v6) = 0;
  }
  MEMORY[0x270FA53B0](a1, a2, a3, a4);
  uint64_t v10 = (void *)((char *)v23 - v9);
  memcpy((char *)v23 - v9, v12, v11 + 4);
  uint64_t v13 = (char *)v10 + v7 + 8;
  uint64_t v14 = *(unsigned int *)&v13[v6];
  *v10 += (8 * v14);
  *(_DWORD *)&v13[v6] = v14 + 1;
  v13[v14] = 0x80;
  unint64_t v15 = *(unsigned int *)&v13[v6];
  if (v6 - 16 < v15)
  {
    while (v6 > v15)
    {
      *(_DWORD *)&v13[v6] = v15 + 1;
      v13[v15] = 0;
      unint64_t v15 = *(unsigned int *)&v13[v6];
    }
    (*(void (**)(unint64_t *, uint64_t))(a1 + 48))(v10 + 1, 1);
    LODWORD(v15) = 0;
    uint64_t v7 = *(void *)(a1 + 8);
    unint64_t v6 = *(void *)(a1 + 16);
    *(_DWORD *)((char *)v10 + v7 + v6 + 8) = 0;
  }
  uint64_t v16 = (uint64_t)v10 + v7 + 8;
  uint64_t v17 = (_DWORD *)(v16 + v6);
  if (v6 - 8 > v15)
  {
    unint64_t v18 = v15;
    do
    {
      *uint64_t v17 = v15 + 1;
      *(unsigned char *)(v16 + v18) = 0;
      unint64_t v18 = *v17;
      LODWORD(v15) = *v17;
    }
    while (v6 - 8 > v18);
  }
  *((void *)v17 - 1) = bswap64(*v10);
  (*(void (**)(unint64_t *, uint64_t))(a1 + 48))(v10 + 1, 1);
  if (*(void *)a1 >= 8uLL)
  {
    unsigned int v19 = 0;
    unint64_t v20 = 0;
    unsigned int v21 = 1;
    do
    {
      *(void *)(a3 + v19) = bswap64(v10[v20 + 1]);
      unint64_t v20 = v21++;
      v19 += 8;
    }
    while (v20 < *(void *)a1 >> 3);
  }
  return cc_clear(*(void *)(a1 + 8) + *(void *)(a1 + 16) + 12, v10);
}

uint64_t ccn_cond_add(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t mask = ccn_mux_next_mask();
  uint64_t v11 = __ROR8__(0x5555555555555555, a2 | (2 * mask));
  uint64_t v12 = 0;
  if (a1)
  {
    uint64_t v13 = 0;
    do
    {
      uint64_t v15 = *a4++;
      uint64_t v14 = v15;
      uint64_t v17 = *a5++;
      uint64_t v16 = v17;
      BOOL v18 = __CFADD__(v12, v14);
      uint64_t v19 = v12 + v14;
      if (v18) {
        uint64_t v13 = 1;
      }
      BOOL v18 = __CFADD__(v19, v16);
      uint64_t v20 = v19 + v16;
      if (v18) {
        uint64_t v12 = v13 + 1;
      }
      else {
        uint64_t v12 = v13;
      }
      uint64_t v21 = v14 ^ v20;
      uint64_t v22 = v14 ^ mask;
      *a3 = v22;
      *a3++ = v21 & v11 ^ v21 & 0x5555555555555555 ^ v22 ^ mask;
      uint64_t v13 = 0;
      --a1;
    }
    while (a1);
  }
  return v12 & a2;
}

void *ccspake_cp_384()
{
  return &ccspake_cp384;
}

void *ccspake_cp_384_rfc()
{
  return &ccspake_cp384_rfc;
}

uint64_t ccz_cmp(uint64_t a1, uint64_t a2)
{
  BOOL v12 = timingsafe_enable_if_supported();
  int v4 = ccz_sign(a1);
  if (v4 == ccz_sign(a2))
  {
    uint64_t v5 = ccz_n(a1);
    uint64_t v6 = *(void *)(a1 + 24);
    uint64_t v7 = ccz_n(a2);
    int v8 = ccn_cmpn_internal(v5, v6, v7, *(void *)(a2 + 24));
    uint64_t v9 = ccz_sign(a1) * v8;
  }
  else if (ccz_n(a2) || ccz_n(a1))
  {
    int v10 = ccz_sign(a1);
    if (v10 < (int)ccz_sign(a2)) {
      uint64_t v9 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v9 = 1;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v9;
}

uint64_t ccpost_digest_message(uint64_t a1, void *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8C08];
  int v4 = (uint64_t *)(*(uint64_t (**)(void))(a1 + 8))();
  ccdigest((uint64_t)v4, *(void *)(a1 + 24), *(char **)(a1 + 16), (uint64_t)v7);
  BOOL v5 = cc_cmp_safe(*v4, v7, *(char **)(a1 + 32)) != 0;
  return ccpost_report(a1, a2, v5);
}

void *ccdes_cbc_encrypt_mode()
{
  BOOL v0 = ccdes_ecb_encrypt_mode();
  ccmode_factory_cbc_encrypt(cbc_des_encrypt, v0);
  return cbc_des_encrypt;
}

void *ccdes_cbc_decrypt_mode()
{
  BOOL v0 = ccdes_ecb_decrypt_mode();
  ccmode_factory_cbc_decrypt(cbc_des_decrypt, v0);
  return cbc_des_decrypt;
}

void *ccdes_cfb_encrypt_mode()
{
  BOOL v0 = ccdes_ecb_encrypt_mode();
  ccmode_factory_cfb_encrypt(cfb_des_encrypt, v0);
  return cfb_des_encrypt;
}

void *ccdes_cfb_decrypt_mode()
{
  BOOL v0 = ccdes_ecb_encrypt_mode();
  ccmode_factory_cfb_decrypt(cfb_des_decrypt, v0);
  return cfb_des_decrypt;
}

void *ccdes_cfb8_encrypt_mode()
{
  BOOL v0 = ccdes_ecb_encrypt_mode();
  ccmode_factory_cfb8_encrypt(cfb8_des_encrypt, v0);
  return cfb8_des_encrypt;
}

void *ccdes_cfb8_decrypt_mode()
{
  BOOL v0 = ccdes_ecb_encrypt_mode();
  ccmode_factory_cfb8_decrypt(cfb8_des_decrypt, v0);
  return cfb8_des_decrypt;
}

void *ccdes_ctr_crypt_mode()
{
  BOOL v0 = ccdes_ecb_encrypt_mode();
  ccmode_factory_ctr_crypt(ctr_des, v0);
  return ctr_des;
}

void *ccdes_ofb_crypt_mode()
{
  BOOL v0 = ccdes_ecb_encrypt_mode();
  ccmode_factory_ofb_crypt(ofb_des, v0);
  return ofb_des;
}

void *ccdes3_cbc_encrypt_mode()
{
  BOOL v0 = ccdes3_ecb_encrypt_mode();
  ccmode_factory_cbc_encrypt(cbc_des3_encrypt, v0);
  return cbc_des3_encrypt;
}

void *ccdes3_cbc_decrypt_mode()
{
  BOOL v0 = ccdes3_ecb_decrypt_mode();
  ccmode_factory_cbc_decrypt(cbc_des3_decrypt, v0);
  return cbc_des3_decrypt;
}

void *ccdes3_cfb_encrypt_mode()
{
  BOOL v0 = ccdes3_ecb_encrypt_mode();
  ccmode_factory_cfb_encrypt(cfb_des3_encrypt, v0);
  return cfb_des3_encrypt;
}

void *ccdes3_cfb_decrypt_mode()
{
  BOOL v0 = ccdes3_ecb_encrypt_mode();
  ccmode_factory_cfb_decrypt(cfb_des3_decrypt, v0);
  return cfb_des3_decrypt;
}

void *ccdes3_cfb8_encrypt_mode()
{
  BOOL v0 = ccdes3_ecb_encrypt_mode();
  ccmode_factory_cfb8_encrypt(cfb8_des3_encrypt, v0);
  return cfb8_des3_encrypt;
}

void *ccdes3_cfb8_decrypt_mode()
{
  BOOL v0 = ccdes3_ecb_encrypt_mode();
  ccmode_factory_cfb8_decrypt(cfb8_des3_decrypt, v0);
  return cfb8_des3_decrypt;
}

void *ccdes3_ctr_crypt_mode()
{
  BOOL v0 = ccdes3_ecb_encrypt_mode();
  ccmode_factory_ctr_crypt(ctr_des3, v0);
  return ctr_des3;
}

void *ccdes3_ofb_crypt_mode()
{
  BOOL v0 = ccdes3_ecb_encrypt_mode();
  ccmode_factory_ofb_crypt(ofb_des3, v0);
  return ofb_des3;
}

uint64_t ccder_blob_decode_uint64(unsigned __int8 **a1, unint64_t *a2)
{
  if (a2) {
    *a2 = 0;
  }
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t result = ccder_blob_decode_range(a1, 2, (unsigned __int8 **)&v7);
  if (result)
  {
    int v4 = (unsigned __int8 *)v7;
    if (v7 == (char *)v8 || *v7 < 0) {
      return 0;
    }
    if (*v7) {
      goto LABEL_7;
    }
    int v4 = (unsigned __int8 *)(v7 + 1);
    if (v7 + 1 == (char *)v8)
    {
      int v4 = v8;
    }
    else if (((char)*v4 & 0x80000000) == 0)
    {
      return 0;
    }
LABEL_7:
    uint64_t v7 = (char *)v4;
    if ((unint64_t)(v8 - v4) <= 8)
    {
      if (v4 == v8)
      {
        unint64_t v5 = 0;
        if (!a2) {
          return 1;
        }
      }
      else
      {
        unint64_t v5 = 0;
        do
        {
          unsigned int v6 = *v4++;
          unint64_t v5 = v6 | (v5 << 8);
        }
        while (v4 != v8);
        if (!a2) {
          return 1;
        }
      }
      *a2 = v5;
      return 1;
    }
    return 0;
  }
  return result;
}

uint64_t ccdigest_final_64le(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v22[1] = *MEMORY[0x263EF8C08];
  uint64_t v7 = *(void *)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 16);
  uint64_t v8 = a2 + v7 + 8;
  if (v6 <= *(unsigned int *)(v8 + v6)) {
    *(_DWORD *)(v8 + v6) = 0;
  }
  MEMORY[0x270FA53B0](a1, a2, a3, a4);
  int v10 = (void *)((char *)v22 - v9);
  memcpy((char *)v22 - v9, v12, v11 + 12);
  uint64_t v13 = (char *)v10 + v7;
  uint64_t v14 = (uint64_t)v10 + v7 + 8;
  uint64_t v15 = (char *)(v14 + v6);
  uint64_t v16 = *(unsigned int *)(v14 + v6);
  *v10 += (8 * v16);
  *(_DWORD *)(v14 + v6) = v16 + 1;
  *(unsigned char *)(v14 + v16) = 0x80;
  unint64_t v17 = *(unsigned int *)(v14 + v6);
  if (v17 < 0x39)
  {
    if (v17 == 56) {
      goto LABEL_9;
    }
  }
  else
  {
    if (v17 <= 0x3F)
    {
      do
      {
        *(_DWORD *)uint64_t v15 = v17 + 1;
        *(unsigned char *)(v14 + v17) = 0;
        unint64_t v17 = *(unsigned int *)v15;
      }
      while (v17 < 0x40);
    }
    (*(void (**)(void *, uint64_t))(a1 + 48))(v10 + 1, 1);
    unint64_t v17 = 0;
    uint64_t v13 = (char *)v10 + *(void *)(a1 + 8);
    uint64_t v14 = (uint64_t)(v13 + 8);
    uint64_t v15 = &v13[*(void *)(a1 + 16) + 8];
    *(_DWORD *)uint64_t v15 = 0;
  }
  do
  {
    *(_DWORD *)uint64_t v15 = v17 + 1;
    *(unsigned char *)(v14 + v17) = 0;
    unint64_t v17 = *(unsigned int *)v15;
  }
  while (v17 < 0x38);
LABEL_9:
  *((void *)v13 + 8) = *v10;
  (*(void (**)(void *, uint64_t))(a1 + 48))(v10 + 1, 1);
  if (*(void *)a1 >= 4uLL)
  {
    unsigned int v18 = 0;
    unint64_t v19 = 0;
    unsigned int v20 = 1;
    do
    {
      *(_DWORD *)(a3 + v18) = *((_DWORD *)v10 + v19 + 2);
      unint64_t v19 = v20++;
      v18 += 4;
    }
    while (v19 < *(void *)a1 >> 2);
  }
  return cc_clear(*(void *)(a1 + 8) + *(void *)(a1 + 16) + 12, v10);
}

uint64_t ccecies_encrypt_gcm_from_shared_secret_composite(void *a1, uint64_t a2, uint64_t *a3, size_t a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, uint64_t a13, uint64_t a14)
{
  uint64_t v28 = *MEMORY[0x263EF8C08];
  unint64_t v22 = ccecies_pub_key_size(a3, a2);
  if (*a1 == *a3)
  {
    uint64_t v23 = v22;
    uint64_t v24 = ccecies_export_eph_pub(*(_DWORD *)(a2 + 32), a3, a12);
    if (!v24)
    {
      uint64_t v24 = ccecies_derive_gcm_key_iv(a2, a4, a5, a8, a9, v23, (uint64_t)a12, __s);
      if (!v24) {
        uint64_t v24 = ccecies_encrypt_gcm_encrypt(a2, (uint64_t)__s, a10, a11, a6, a7, a13, a14);
      }
    }
    uint64_t v25 = v24;
  }
  else
  {
    uint64_t v25 = 4294967289;
  }
  cc_clear(0x30uLL, __s);
  return v25;
}

uint64_t ccecies_encrypt_gcm_from_shared_secret(void *a1, uint64_t a2, uint64_t *a3, size_t a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, rsize_t *a12, void *a13)
{
  BOOL v26 = timingsafe_enable_if_supported();
  unint64_t v19 = ccecies_pub_key_size(a3, a2);
  unint64_t v20 = ccecies_encrypt_gcm_ciphertext_size(a3, a2, a6);
  rsize_t v21 = *a12;
  if ((*(unsigned char *)(a2 + 32) & 0x21) == 0)
  {
    uint64_t v22 = 4294967291;
    goto LABEL_10;
  }
  if (v20 > v21 || *a1 != *a3)
  {
    uint64_t v22 = 4294967289;
LABEL_10:
    cc_clear(v21, a13);
    goto LABEL_6;
  }
  uint64_t v22 = ccecies_encrypt_gcm_from_shared_secret_composite(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, (char *)a13, (uint64_t)a13 + v19, (uint64_t)a13 + v19 + a6);
  if (v22)
  {
    rsize_t v21 = *a12;
    goto LABEL_10;
  }
  *a12 = v20;
LABEL_6:
  cc_disable_dit_with_sb((unsigned int *)&v26);
  return v22;
}

uint64_t ccn_cond_shift_right_carry(unint64_t a1, char a2, uint64_t a3, uint64_t a4, char a5, unint64_t a6)
{
  uint64_t result = ccn_mux_next_mask();
  uint64_t v13 = __ROR8__(0x5555555555555555, a2 | (2 * result));
  if (a1)
  {
    unint64_t v14 = a1 - 1;
    uint64_t v15 = 8 * a1 - 8;
    do
    {
      uint64_t v16 = 2 * a6;
      uint64_t v17 = a6 >> a5;
      a6 = *(void *)(a4 + 8 * v14);
      uint64_t v18 = (v16 << ~a5) | (a6 >> a5);
      if ((a5 & 0x40) != 0) {
        uint64_t v18 = v17;
      }
      *(void *)(a3 + 8 * v14) = a6 ^ result;
      *(void *)(a3 + 8 * v14--) = (a6 ^ v18) & v13 ^ (a6 ^ v18) & 0x5555555555555555 ^ a6 ^ result ^ result;
      v15 -= 8;
    }
    while (v14 < a1);
  }
  return result;
}

uint64_t ccn_cond_shift_right(unint64_t a1, char a2, uint64_t a3, uint64_t a4, char a5)
{
  return ccn_cond_shift_right_carry(a1, a2, a3, a4, a5, 0);
}

uint64_t cc_lock_init(_DWORD *a1)
{
  *a1 = 0;
  return 0;
}

uint64_t ccss_shamir_share_bag_recover_secret(unsigned int **a1, char *a2, unint64_t a3)
{
  char v6 = 0;
  char v48 = 0;
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    if ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) & 0x1000000) != 0)
    {
      char v6 = 0;
    }
    else
    {
      __asm { MSR             DIT, #1 }
      char v6 = 1;
    }
  }
  char v48 = v6;
  uint64_t v12 = cczp_n((uint64_t)(*a1 + 2));
  uint64_t v13 = 15 * v12;
  v44[0] = cc_malloc_clear(120 * v12);
  v44[1] = v13;
  uint64_t v45 = 0;
  uint64_t v46 = cc_ws_alloc;
  int v47 = cc_ws_free;
  if (!v44[0])
  {
    uint64_t v16 = 4294967283;
    goto LABEL_30;
  }
  unint64_t v14 = *a1;
  unsigned int v15 = **a1;
  if (*((_DWORD *)a1 + 2) < v15)
  {
    uint64_t v16 = 4294967175;
    cc_ws_free((uint64_t)v44);
    goto LABEL_30;
  }
  unint64_t v38 = a3;
  long long v39 = a2;
  uint64_t v17 = (uint64_t)(v14 + 2);
  uint64_t v18 = cczp_n((uint64_t)(v14 + 2));
  unint64_t v19 = (uint64_t *)cc_ws_alloc(v44, v18);
  unint64_t v20 = (void *)v46(v44, v18);
  v46(v44, v18);
  long long v40 = (void *)v46(v44, v18);
  rsize_t v21 = (void *)v46(v44, v18);
  long long v41 = (unint64_t *)v46(v44, v18);
  ccn_seti(v18, v41, 0);
  unsigned int v22 = **a1;
  unsigned int v23 = v22 - 1;
  if (v22 != 1 && csss_shamir_share_bag_can_recover_secret((uint64_t)a1))
  {
    uint64_t v43 = (uint64_t)(*a1 + 2);
    unsigned int v42 = v23;
    uint64_t v24 = cczp_n(v43);
    uint64_t v37 = v45;
    uint64_t v25 = (void *)v46(v44, v24);
    unsigned int v26 = ccss_shamir_share_bag_copy_ith_share_x((uint64_t)a1, 0);
    ccn_seti(v24, v19, v26);
    unsigned int v27 = 1;
    do
    {
      unsigned int v28 = ccss_shamir_share_bag_copy_ith_share_x((uint64_t)a1, v27);
      ccn_seti(v24, v25, v28);
      cczp_mul_ws((uint64_t)v44, v43);
      ++v27;
    }
    while (v27 <= v42);
    if (v42) {
      cczp_negate(v43, v19, (unint64_t *)v19);
    }
    uint64_t v45 = v37;
  }
  if (v15)
  {
    unsigned int v29 = 0;
LABEL_18:
    unsigned int v30 = ccss_shamir_share_bag_copy_ith_share_x((uint64_t)a1, v29);
    ccss_shamir_share_bag_ith_share_y((uint64_t)a1, v29);
    ccn_seti(v18, v20, 1);
    unsigned int v31 = 0;
    while (1)
    {
      unsigned int v32 = ccss_shamir_share_bag_copy_ith_share_x((uint64_t)a1, v31);
      if (v30 <= v32)
      {
        if (v30 >= v32)
        {
          if (v29 != v31)
          {
            uint64_t v16 = 4294967172;
            goto LABEL_29;
          }
          goto LABEL_25;
        }
        unsigned int v33 = v32;
        uint64_t v34 = (unint64_t *)cczp_prime(v17);
        ccn_sub1(v18, v21, v34, v33 - v30);
      }
      else
      {
        ccn_seti(v18, v21, v30 - v32);
      }
      cczp_mul_ws((uint64_t)v44, v17);
LABEL_25:
      if (v15 == ++v31)
      {
        ccn_seti(v18, v40, v30);
        cczp_mul_ws((uint64_t)v44, v17);
        cczp_inv_ws((uint64_t)v44, v17);
        cczp_mul_ws((uint64_t)v44, v17);
        cczp_mul_ws((uint64_t)v44, v17);
        cczp_add_ws((uint64_t)v44, v17);
        if (++v29 != v15) {
          goto LABEL_18;
        }
        break;
      }
    }
  }
  int v35 = ccn_write_uint_padded_ct_internal(v18, v41, v38, v39);
  uint64_t v16 = v35 & (v35 >> 31);
LABEL_29:
  uint64_t v45 = 0;
  v47((uint64_t)v44);
LABEL_30:
  cc_disable_dit(&v48);
  return v16;
}

uint64_t ccsrp_generate_H_AMK_ws(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  v17[1] = *MEMORY[0x263EF8C08];
  uint64_t v7 = *(unint64_t **)a2;
  MEMORY[0x270FA53B0](a1, a2, a3, a4);
  uint64_t v9 = (void *)((char *)v17 - v8);
  ccdigest_init_internal((uint64_t)v7, (void *)((char *)v17 - v8));
  uint64_t v10 = *(void *)(a1 + 16);
  ccsrp_digest_update_ccn_ws(a1, a2, v9, a3, (*(_DWORD *)(a2 + 24) >> 10) & 1);
  size_t v11 = ccsrp_session_size(a2);
  uint64_t v12 = ccdh_gp_n(*(void *)(a2 + 8));
  ccdigest_update_internal(v7, v9, v11, (char *)(a2 + 32 + 32 * v12 + 2 * **(void **)a2));
  size_t session_key_length = ccsrp_get_session_key_length((uint64_t *)a2);
  uint64_t v14 = ccdh_gp_n(*(void *)(a2 + 8));
  ccdigest_update_internal(v7, v9, session_key_length, (char *)(a2 + 32 + 32 * v14));
  uint64_t v15 = ccdh_gp_n(*(void *)(a2 + 8));
  ((void (*)(unint64_t *, void *, uint64_t))v7[7])(v7, v9, a2 + 32 + 32 * v15 + 3 * **(void **)a2);
  uint64_t result = cc_clear(v7[1] + v7[2] + 12, v9);
  *(void *)(a1 + 16) = v10;
  return result;
}

unint64_t ccn_n(unint64_t result, uint64_t a2)
{
  if (result)
  {
    unint64_t v2 = result;
    uint64_t v3 = 0;
    uint64_t result = 0;
    do
    {
      unint64_t v4 = *(void *)(a2 + 8 * v3);
      unint64_t v5 = v3 + 2;
      uint64_t result = ((((v4 | HIDWORD(v4)) + 0xFFFFFFFF) >> 32) - 1) & result | ++v3 & -(uint64_t)(((v4 | HIDWORD(v4)) + 0xFFFFFFFF) >> 32);
    }
    while (v5 <= v2);
  }
  return result;
}

uint64_t ccsrp_sizeof_verifier()
{
  return 8 * ccdh_gp_n();
}

uint64_t ccsrp_sizeof_public_key()
{
  return 8 * ccdh_gp_n();
}

uint64_t ccsrp_sizeof_M_HAMK(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t ccsrp_ctx_init_with_size_option(void *__s, rsize_t __n, uint64_t a3, uint64_t a4, unsigned __int16 a5, uint64_t a6)
{
  cc_clear(__n, __s);
  *uint64_t __s = a3;
  __s[1] = a4;
  int v11 = *((_DWORD *)__s + 6);
  _OWORD __s[2] = a6;
  *((_DWORD *)__s + 6) = v11 & 0xFFF80002 | (8 * a5);
  return 0;
}

uint64_t ccsrp_client_set_noUsernameInX(uint64_t a1, uint64_t a2)
{
  if (a2) {
    int v2 = 2;
  }
  else {
    int v2 = 0;
  }
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 24) & 0xFFFFFFFD | v2;
  return a2;
}

uint64_t ccsrp_is_authenticated(uint64_t a1)
{
  return *(_DWORD *)(a1 + 24) & 1;
}

uint64_t ccsrp_exchange_size(uint64_t a1)
{
  return 8 * ccdh_gp_n(*(void *)(a1 + 8));
}

uint64_t ccsrp_session_size(uint64_t a1)
{
  return **(void **)a1;
}

uint64_t ccsrp_sizeof_session_key(uint64_t a1, char a2)
{
  if ((a2 & 7u) - 1 < 2) {
    return 2 * *(void *)a1;
  }
  if ((a2 & 7) != 0) {
    return 0;
  }
  return *(void *)a1;
}

uint64_t ccsrp_get_session_key_length(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v2 = (*((_DWORD *)a1 + 6) >> 3) & 7;
  if ((v2 - 1) < 2) {
    return 2 * *(void *)v1;
  }
  if (v2) {
    return 0;
  }
  return *(void *)v1;
}

uint64_t ccsrp_get_session_key(uint64_t a1, uint64_t *a2)
{
  int v2 = *(uint64_t **)a1;
  int v3 = (*(_DWORD *)(a1 + 24) >> 3) & 7;
  if ((v3 - 1) >= 2)
  {
    if (v3) {
      uint64_t v4 = 0;
    }
    else {
      uint64_t v4 = *v2;
    }
  }
  else
  {
    uint64_t v4 = 2 * *v2;
  }
  *a2 = v4;
  if ((*(unsigned char *)(a1 + 24) & 4) != 0) {
    return a1 + 32 * ccdh_gp_n(*(void *)(a1 + 8)) + 32;
  }
  else {
    return 0;
  }
}

uint64_t ccsrp_get_premaster_secret(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 24) & 4) != 0) {
    return a1 + 24 * ccdh_gp_n(*(void *)(a1 + 8)) + 32;
  }
  else {
    return 0;
  }
}

uint64_t ccsrp_ctx_init_option(void *a1, void *a2, void *a3, unsigned __int16 a4, uint64_t a5)
{
  uint64_t v10 = ccdh_ccn_size(a3);
  cc_clear(4 * (*a2 + v10) + 48, a1);
  *a1 = a2;
  a1[1] = a3;
  int v11 = *((_DWORD *)a1 + 6);
  a1[2] = a5;
  *((_DWORD *)a1 + 6) = v11 & 0xFFF80002 | (8 * a4);
  return 0;
}

uint64_t ccsrp_ctx_init(void *a1, void *a2, void *a3)
{
  rsize_t v6 = 4 * (*a2 + ccdh_ccn_size(a3)) + 48;
  uint64_t v7 = ccrng(0);
  uint64_t result = cc_clear(v6, a1);
  *a1 = a2;
  a1[1] = a3;
  int v9 = *((_DWORD *)a1 + 6);
  a1[2] = v7;
  *((_DWORD *)a1 + 6) = v9 & 0xFFF80002;
  return result;
}

void *ccdes_ecb_decrypt_mode()
{
  return &ccdes_ltc_ecb_decrypt_mode;
}

uint64_t ccaes_gladman_encrypt(_DWORD *a1, int *a2, uint64_t a3, uint64_t a4, int *a5)
{
  int v5 = a1[65];
  int v6 = *a2;
  int v7 = a2[1];
  int v8 = a2[2];
  int v9 = a2[3];
  if (a3)
  {
    uint64_t v10 = (_DWORD *)(a4 + 8);
    do
    {
      if (v5)
      {
        unsigned int v11 = *a1 ^ v6 ^ *(v10 - 2);
        unsigned int v12 = a1[1] ^ v7 ^ *(v10 - 1);
        unsigned int v13 = a1[2] ^ v8 ^ *v10;
        unsigned int v14 = a1[3] ^ v9 ^ v10[1];
      }
      else
      {
        unsigned int v11 = *a1 ^ *(v10 - 2);
        unsigned int v12 = a1[1] ^ *(v10 - 1);
        unsigned int v13 = a1[2] ^ *v10;
        unsigned int v14 = a1[3] ^ v10[1];
      }
      int v15 = a1[60];
      if (v15 == 12)
      {
        unint64_t v20 = a1;
      }
      else
      {
        if (v15 != 14)
        {
          rsize_t v21 = a1;
          goto LABEL_12;
        }
        unsigned int v16 = t_fn[v11] ^ a1[4] ^ t_fn[BYTE1(v12) + 256] ^ t_fn[BYTE2(v13) + 512] ^ t_fn[HIBYTE(v14) + 768];
        unsigned int v17 = t_fn[v12] ^ a1[5] ^ t_fn[BYTE1(v13) + 256] ^ t_fn[BYTE2(v14) + 512] ^ t_fn[HIBYTE(v11) + 768];
        unsigned int v18 = t_fn[v13] ^ a1[6] ^ t_fn[BYTE1(v14) + 256] ^ t_fn[BYTE2(v11) + 512] ^ t_fn[HIBYTE(v12) + 768];
        unsigned int v19 = t_fn[v14] ^ a1[7] ^ t_fn[BYTE1(v11) + 256] ^ t_fn[BYTE2(v12) + 512] ^ t_fn[HIBYTE(v13) + 768];
        unsigned int v11 = t_fn[v16] ^ a1[8] ^ t_fn[BYTE1(v17) + 256] ^ t_fn[BYTE2(v18) + 512] ^ t_fn[HIBYTE(v19) + 768];
        unsigned int v12 = t_fn[v17] ^ a1[9] ^ t_fn[BYTE1(v18) + 256] ^ t_fn[BYTE2(v19) + 512] ^ t_fn[HIBYTE(v16) + 768];
        unsigned int v13 = t_fn[v18] ^ a1[10] ^ t_fn[BYTE1(v19) + 256] ^ t_fn[BYTE2(v16) + 512] ^ t_fn[HIBYTE(v17) + 768];
        unsigned int v14 = t_fn[v19] ^ a1[11] ^ t_fn[BYTE1(v16) + 256] ^ t_fn[BYTE2(v17) + 512] ^ t_fn[HIBYTE(v18) + 768];
        unint64_t v20 = a1 + 8;
      }
      int v22 = v20[8];
      rsize_t v21 = v20 + 8;
      unsigned int v23 = t_fn[v11] ^ *(v21 - 4) ^ t_fn[BYTE1(v12) + 256] ^ t_fn[BYTE2(v13) + 512] ^ t_fn[HIBYTE(v14) + 768];
      unsigned int v24 = t_fn[v12] ^ *(v21 - 3) ^ t_fn[BYTE1(v13) + 256] ^ t_fn[BYTE2(v14) + 512] ^ t_fn[HIBYTE(v11) + 768];
      unsigned int v25 = t_fn[v13] ^ *(v21 - 2) ^ t_fn[BYTE1(v14) + 256] ^ t_fn[BYTE2(v11) + 512] ^ t_fn[HIBYTE(v12) + 768];
      unsigned int v26 = t_fn[v14] ^ *(v21 - 1) ^ t_fn[BYTE1(v11) + 256] ^ t_fn[BYTE2(v12) + 512] ^ t_fn[HIBYTE(v13) + 768];
      unsigned int v11 = t_fn[v23] ^ v22 ^ t_fn[BYTE1(v24) + 256] ^ t_fn[BYTE2(v25) + 512] ^ t_fn[HIBYTE(v26) + 768];
      unsigned int v12 = t_fn[v24] ^ v21[1] ^ t_fn[BYTE1(v25) + 256] ^ t_fn[BYTE2(v26) + 512] ^ t_fn[HIBYTE(v23) + 768];
      unsigned int v13 = t_fn[v25] ^ v21[2] ^ t_fn[BYTE1(v26) + 256] ^ t_fn[BYTE2(v23) + 512] ^ t_fn[HIBYTE(v24) + 768];
      unsigned int v14 = t_fn[v26] ^ v21[3] ^ t_fn[BYTE1(v23) + 256] ^ t_fn[BYTE2(v24) + 512] ^ t_fn[HIBYTE(v25) + 768];
LABEL_12:
      unsigned int v27 = t_fn[v11] ^ v21[4] ^ t_fn[BYTE1(v12) + 256] ^ t_fn[BYTE2(v13) + 512] ^ t_fn[HIBYTE(v14) + 768];
      unsigned int v28 = t_fn[v12] ^ v21[5] ^ t_fn[BYTE1(v13) + 256] ^ t_fn[BYTE2(v14) + 512] ^ t_fn[HIBYTE(v11) + 768];
      unsigned int v29 = t_fn[v13] ^ v21[6] ^ t_fn[BYTE1(v14) + 256] ^ t_fn[BYTE2(v11) + 512] ^ t_fn[HIBYTE(v12) + 768];
      unsigned int v30 = t_fn[v14] ^ v21[7] ^ t_fn[BYTE1(v11) + 256] ^ t_fn[BYTE2(v12) + 512] ^ t_fn[HIBYTE(v13) + 768];
      unsigned int v31 = t_fn[v27] ^ v21[8] ^ t_fn[BYTE1(v28) + 256] ^ t_fn[BYTE2(v29) + 512] ^ t_fn[HIBYTE(v30) + 768];
      unsigned int v32 = t_fn[v28] ^ v21[9] ^ t_fn[BYTE1(v29) + 256] ^ t_fn[BYTE2(v30) + 512] ^ t_fn[HIBYTE(v27) + 768];
      unsigned int v33 = t_fn[v29] ^ v21[10] ^ t_fn[BYTE1(v30) + 256] ^ t_fn[BYTE2(v27) + 512] ^ t_fn[HIBYTE(v28) + 768];
      unsigned int v34 = t_fn[v30] ^ v21[11] ^ t_fn[BYTE1(v27) + 256] ^ t_fn[BYTE2(v28) + 512] ^ t_fn[HIBYTE(v29) + 768];
      unsigned int v35 = t_fn[v31] ^ v21[12] ^ t_fn[BYTE1(v32) + 256] ^ t_fn[BYTE2(v33) + 512] ^ t_fn[HIBYTE(v34) + 768];
      unsigned int v36 = t_fn[v32] ^ v21[13] ^ t_fn[BYTE1(v33) + 256] ^ t_fn[BYTE2(v34) + 512] ^ t_fn[HIBYTE(v31) + 768];
      unsigned int v37 = t_fn[v33] ^ v21[14] ^ t_fn[BYTE1(v34) + 256] ^ t_fn[BYTE2(v31) + 512] ^ t_fn[HIBYTE(v32) + 768];
      unsigned int v38 = t_fn[v34] ^ v21[15] ^ t_fn[BYTE1(v31) + 256] ^ t_fn[BYTE2(v32) + 512] ^ t_fn[HIBYTE(v33) + 768];
      unsigned int v39 = t_fn[v35] ^ v21[16] ^ t_fn[BYTE1(v36) + 256] ^ t_fn[BYTE2(v37) + 512] ^ t_fn[HIBYTE(v38) + 768];
      unsigned int v40 = t_fn[v36] ^ v21[17] ^ t_fn[BYTE1(v37) + 256] ^ t_fn[BYTE2(v38) + 512] ^ t_fn[HIBYTE(v35) + 768];
      unsigned int v41 = t_fn[v37] ^ v21[18] ^ t_fn[BYTE1(v38) + 256] ^ t_fn[BYTE2(v35) + 512] ^ t_fn[HIBYTE(v36) + 768];
      unsigned int v42 = t_fn[v38] ^ v21[19] ^ t_fn[BYTE1(v35) + 256] ^ t_fn[BYTE2(v36) + 512] ^ t_fn[HIBYTE(v37) + 768];
      unsigned int v43 = t_fn[v39] ^ v21[20] ^ t_fn[BYTE1(v40) + 256] ^ t_fn[BYTE2(v41) + 512] ^ t_fn[HIBYTE(v42) + 768];
      unsigned int v44 = t_fn[v40] ^ v21[21] ^ t_fn[BYTE1(v41) + 256] ^ t_fn[BYTE2(v42) + 512] ^ t_fn[HIBYTE(v39) + 768];
      unsigned int v45 = t_fn[v41] ^ v21[22] ^ t_fn[BYTE1(v42) + 256] ^ t_fn[BYTE2(v39) + 512] ^ t_fn[HIBYTE(v40) + 768];
      unsigned int v46 = t_fn[v42] ^ v21[23] ^ t_fn[BYTE1(v39) + 256] ^ t_fn[BYTE2(v40) + 512] ^ t_fn[HIBYTE(v41) + 768];
      unsigned int v47 = t_fn[v43] ^ v21[24] ^ t_fn[BYTE1(v44) + 256] ^ t_fn[BYTE2(v45) + 512] ^ t_fn[HIBYTE(v46) + 768];
      unsigned int v48 = t_fn[v44] ^ v21[25] ^ t_fn[BYTE1(v45) + 256] ^ t_fn[BYTE2(v46) + 512] ^ t_fn[HIBYTE(v43) + 768];
      unsigned int v49 = t_fn[v45] ^ v21[26] ^ t_fn[BYTE1(v46) + 256] ^ t_fn[BYTE2(v43) + 512] ^ t_fn[HIBYTE(v44) + 768];
      unsigned int v50 = t_fn[v46] ^ v21[27] ^ t_fn[BYTE1(v43) + 256] ^ t_fn[BYTE2(v44) + 512] ^ t_fn[HIBYTE(v45) + 768];
      unsigned int v51 = t_fn[v47] ^ v21[28] ^ t_fn[BYTE1(v48) + 256] ^ t_fn[BYTE2(v49) + 512] ^ t_fn[HIBYTE(v50) + 768];
      unsigned int v52 = t_fn[v48] ^ v21[29] ^ t_fn[BYTE1(v49) + 256] ^ t_fn[BYTE2(v50) + 512] ^ t_fn[HIBYTE(v47) + 768];
      unsigned int v53 = t_fn[v49] ^ v21[30] ^ t_fn[BYTE1(v50) + 256] ^ t_fn[BYTE2(v47) + 512] ^ t_fn[HIBYTE(v48) + 768];
      unsigned int v54 = t_fn[v50] ^ v21[31] ^ t_fn[BYTE1(v47) + 256] ^ t_fn[BYTE2(v48) + 512] ^ t_fn[HIBYTE(v49) + 768];
      unsigned int v55 = t_fn[v51] ^ v21[32] ^ t_fn[BYTE1(v52) + 256] ^ t_fn[BYTE2(v53) + 512] ^ t_fn[HIBYTE(v54) + 768];
      unsigned int v56 = t_fn[v52] ^ v21[33] ^ t_fn[BYTE1(v53) + 256] ^ t_fn[BYTE2(v54) + 512] ^ t_fn[HIBYTE(v51) + 768];
      unsigned int v57 = t_fn[v53] ^ v21[34] ^ t_fn[BYTE1(v54) + 256] ^ t_fn[BYTE2(v51) + 512] ^ t_fn[HIBYTE(v52) + 768];
      unsigned int v58 = t_fn[v54] ^ v21[35] ^ t_fn[BYTE1(v51) + 256] ^ t_fn[BYTE2(v52) + 512] ^ t_fn[HIBYTE(v53) + 768];
      unsigned int v59 = t_fn[v55] ^ v21[36] ^ t_fn[BYTE1(v56) + 256] ^ t_fn[BYTE2(v57) + 512] ^ t_fn[HIBYTE(v58) + 768];
      unsigned int v60 = t_fn[v56] ^ v21[37] ^ t_fn[BYTE1(v57) + 256] ^ t_fn[BYTE2(v58) + 512] ^ t_fn[HIBYTE(v55) + 768];
      unsigned int v61 = t_fn[v57] ^ v21[38] ^ t_fn[BYTE1(v58) + 256] ^ t_fn[BYTE2(v55) + 512] ^ t_fn[HIBYTE(v56) + 768];
      int v62 = t_fl[(LOBYTE(t_fn[v55]) ^ *((unsigned char *)v21 + 144) ^ LOBYTE(t_fn[BYTE1(v56) + 256]) ^ LOBYTE(t_fn[BYTE2(v57) + 512]) ^ LOBYTE(t_fn[HIBYTE(v58) + 768]))];
      unsigned int v63 = t_fn[v58] ^ v21[39] ^ t_fn[BYTE1(v55) + 256] ^ t_fn[BYTE2(v56) + 512] ^ t_fn[HIBYTE(v57) + 768];
      int v6 = v62 ^ v21[40] ^ t_fl[BYTE1(v60) + 256] ^ t_fl[BYTE2(v61) + 512] ^ t_fl[HIBYTE(v63) + 768];
      int v7 = t_fl[v60] ^ v21[41] ^ t_fl[BYTE1(v61) + 256] ^ t_fl[BYTE2(v63) + 512] ^ t_fl[HIBYTE(v59) + 768];
      int v64 = v21[43];
      int v8 = t_fl[v61] ^ v21[42] ^ t_fl[BYTE1(v63) + 256] ^ t_fl[BYTE2(v59) + 512] ^ t_fl[HIBYTE(v60) + 768];
      int v65 = t_fl[BYTE1(v59) + 256] ^ t_fl[BYTE2(v60) + 512];
      int v66 = t_fl[HIBYTE(v61) + 768];
      int v67 = t_fl[v63] ^ v64 ^ v65;
      *a5 = v6;
      a5[1] = v7;
      int v9 = v67 ^ v66;
      a5[2] = v8;
      a5[3] = v9;
      a5 += 4;
      v10 += 4;
      --a3;
    }
    while (a3);
  }
  if (v5)
  {
    *a2 = v6;
    a2[1] = v7;
    a2[2] = v8;
    a2[3] = v9;
  }
  return 0;
}

uint64_t ccaes_gladman_decrypt(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v5 = *(_DWORD *)(a1 + 260);
  if (a3 || !v5)
  {
    uint64_t v6 = a4 + 16 * a3;
    int v7 = *(_DWORD *)(v6 - 16);
    int v9 = *(_DWORD *)(v6 - 12);
    int v8 = (long long *)(v6 - 16);
    int v10 = *((_DWORD *)v8 + 2);
    int v11 = *((_DWORD *)v8 + 3);
    if (a3 && v5)
    {
      long long v78 = *v8;
LABEL_7:
      unsigned int v12 = (_DWORD *)(a1 + 4 * (4 * *(_DWORD *)(a1 + 240)));
      unsigned int v13 = (int *)(16 * a3 + a5 - 8);
      while (1)
      {
        unsigned int v14 = *v12 ^ v7;
        unsigned int v15 = v12[1] ^ v9;
        unsigned int v16 = v12[2] ^ v10;
        unsigned int v17 = v12[3] ^ v11;
        int v18 = *(_DWORD *)(a1 + 240);
        unsigned int v19 = v12;
        if (v18 != 12)
        {
          if (v18 != 14) {
            goto LABEL_12;
          }
          unsigned int v20 = t_in[v14] ^ *(v12 - 4) ^ t_in[BYTE1(v17) + 256] ^ t_in[BYTE2(v16) + 512] ^ t_in[HIBYTE(v15) + 768];
          unsigned int v21 = t_in[v15] ^ *(v12 - 3) ^ t_in[BYTE1(v14) + 256] ^ t_in[BYTE2(v17) + 512] ^ t_in[HIBYTE(v16) + 768];
          unsigned int v22 = t_in[v16] ^ *(v12 - 2) ^ t_in[BYTE1(v15) + 256] ^ t_in[BYTE2(v14) + 512] ^ t_in[HIBYTE(v17) + 768];
          unsigned int v23 = t_in[v17] ^ *(v12 - 1) ^ t_in[BYTE1(v16) + 256] ^ t_in[BYTE2(v15) + 512] ^ t_in[HIBYTE(v14) + 768];
          unsigned int v14 = t_in[v20] ^ *(v12 - 8) ^ t_in[BYTE1(v23) + 256] ^ t_in[BYTE2(v22) + 512] ^ t_in[HIBYTE(v21) + 768];
          unsigned int v15 = t_in[v21] ^ *(v12 - 7) ^ t_in[BYTE1(v20) + 256] ^ t_in[BYTE2(v23) + 512] ^ t_in[HIBYTE(v22) + 768];
          unsigned int v16 = t_in[v22] ^ *(v12 - 6) ^ t_in[BYTE1(v21) + 256] ^ t_in[BYTE2(v20) + 512] ^ t_in[HIBYTE(v23) + 768];
          unsigned int v17 = t_in[v23] ^ *(v12 - 5) ^ t_in[BYTE1(v22) + 256] ^ t_in[BYTE2(v21) + 512] ^ t_in[HIBYTE(v20) + 768];
          unsigned int v19 = v12 - 8;
        }
        int v24 = *(v19 - 8);
        v19 -= 8;
        unsigned int v25 = t_in[v14] ^ v19[4] ^ t_in[BYTE1(v17) + 256] ^ t_in[BYTE2(v16) + 512] ^ t_in[HIBYTE(v15) + 768];
        unsigned int v26 = t_in[v15] ^ v19[5] ^ t_in[BYTE1(v14) + 256] ^ t_in[BYTE2(v17) + 512] ^ t_in[HIBYTE(v16) + 768];
        unsigned int v27 = t_in[v16] ^ v19[6] ^ t_in[BYTE1(v15) + 256] ^ t_in[BYTE2(v14) + 512] ^ t_in[HIBYTE(v17) + 768];
        unsigned int v28 = t_in[v17] ^ v19[7] ^ t_in[BYTE1(v16) + 256] ^ t_in[BYTE2(v15) + 512] ^ t_in[HIBYTE(v14) + 768];
        unsigned int v14 = t_in[v25] ^ v24 ^ t_in[BYTE1(v28) + 256] ^ t_in[BYTE2(v27) + 512] ^ t_in[HIBYTE(v26) + 768];
        unsigned int v15 = t_in[v26] ^ v19[1] ^ t_in[BYTE1(v25) + 256] ^ t_in[BYTE2(v28) + 512] ^ t_in[HIBYTE(v27) + 768];
        unsigned int v16 = t_in[v27] ^ v19[2] ^ t_in[BYTE1(v26) + 256] ^ t_in[BYTE2(v25) + 512] ^ t_in[HIBYTE(v28) + 768];
        unsigned int v17 = t_in[v28] ^ v19[3] ^ t_in[BYTE1(v27) + 256] ^ t_in[BYTE2(v26) + 512] ^ t_in[HIBYTE(v25) + 768];
LABEL_12:
        unsigned int v29 = t_in[v14] ^ *(v19 - 4) ^ t_in[BYTE1(v17) + 256] ^ t_in[BYTE2(v16) + 512] ^ t_in[HIBYTE(v15) + 768];
        unsigned int v30 = t_in[v15] ^ *(v19 - 3) ^ t_in[BYTE1(v14) + 256] ^ t_in[BYTE2(v17) + 512] ^ t_in[HIBYTE(v16) + 768];
        unsigned int v31 = t_in[v16] ^ *(v19 - 2) ^ t_in[BYTE1(v15) + 256] ^ t_in[BYTE2(v14) + 512] ^ t_in[HIBYTE(v17) + 768];
        unsigned int v32 = t_in[v17] ^ *(v19 - 1) ^ t_in[BYTE1(v16) + 256] ^ t_in[BYTE2(v15) + 512] ^ t_in[HIBYTE(v14) + 768];
        unsigned int v33 = t_in[v29] ^ *(v19 - 8) ^ t_in[BYTE1(v32) + 256] ^ t_in[BYTE2(v31) + 512] ^ t_in[HIBYTE(v30) + 768];
        int v34 = t_in[v30] ^ *(v19 - 7) ^ t_in[BYTE1(v29) + 256] ^ t_in[BYTE2(v32) + 512];
        unsigned int v35 = t_in[v31] ^ *(v19 - 6) ^ t_in[BYTE1(v30) + 256] ^ t_in[BYTE2(v29) + 512] ^ t_in[HIBYTE(v32) + 768];
        unsigned int v36 = t_in[v32] ^ *(v19 - 5) ^ t_in[BYTE1(v31) + 256] ^ t_in[BYTE2(v30) + 512] ^ t_in[HIBYTE(v29) + 768];
        unsigned int v37 = v34 ^ t_in[HIBYTE(v31) + 768];
        unsigned int v38 = t_in[v33] ^ *(v19 - 12) ^ t_in[BYTE1(v36) + 256] ^ t_in[BYTE2(v35) + 512] ^ t_in[HIBYTE(v37) + 768];
        unsigned int v39 = t_in[(v34 ^ LOBYTE(t_in[HIBYTE(v31) + 768]))] ^ *(v19 - 11) ^ t_in[BYTE1(v33) + 256] ^ t_in[BYTE2(v36) + 512] ^ t_in[HIBYTE(v35) + 768];
        unsigned int v40 = t_in[v35] ^ *(v19 - 10) ^ t_in[BYTE1(v37) + 256] ^ t_in[BYTE2(v33) + 512] ^ t_in[HIBYTE(v36) + 768];
        unsigned int v41 = t_in[v36] ^ *(v19 - 9) ^ t_in[BYTE1(v35) + 256] ^ t_in[BYTE2(v37) + 512] ^ t_in[HIBYTE(v33) + 768];
        unsigned int v42 = t_in[v38] ^ *(v19 - 16) ^ t_in[BYTE1(v41) + 256] ^ t_in[BYTE2(v40) + 512] ^ t_in[HIBYTE(v39) + 768];
        unsigned int v43 = t_in[v39] ^ *(v19 - 15) ^ t_in[BYTE1(v38) + 256] ^ t_in[BYTE2(v41) + 512] ^ t_in[HIBYTE(v40) + 768];
        unsigned int v44 = t_in[v40] ^ *(v19 - 14) ^ t_in[BYTE1(v39) + 256] ^ t_in[BYTE2(v38) + 512] ^ t_in[HIBYTE(v41) + 768];
        unsigned int v45 = t_in[v41] ^ *(v19 - 13) ^ t_in[BYTE1(v40) + 256] ^ t_in[BYTE2(v39) + 512] ^ t_in[HIBYTE(v38) + 768];
        unsigned int v46 = t_in[v42] ^ *(v19 - 20) ^ t_in[BYTE1(v45) + 256] ^ t_in[BYTE2(v44) + 512] ^ t_in[HIBYTE(v43) + 768];
        int v47 = t_in[v43] ^ *(v19 - 19) ^ t_in[BYTE1(v42) + 256] ^ t_in[BYTE2(v45) + 512];
        unsigned int v48 = t_in[v44] ^ *(v19 - 18) ^ t_in[BYTE1(v43) + 256] ^ t_in[BYTE2(v42) + 512] ^ t_in[HIBYTE(v45) + 768];
        unsigned int v49 = t_in[v45] ^ *(v19 - 17) ^ t_in[BYTE1(v44) + 256] ^ t_in[BYTE2(v43) + 512] ^ t_in[HIBYTE(v42) + 768];
        unsigned int v50 = v47 ^ t_in[HIBYTE(v44) + 768];
        unsigned int v51 = t_in[v46] ^ *(v19 - 24) ^ t_in[BYTE1(v49) + 256] ^ t_in[BYTE2(v48) + 512] ^ t_in[HIBYTE(v50) + 768];
        unsigned int v52 = t_in[v50] ^ *(v19 - 23) ^ t_in[BYTE1(v46) + 256] ^ t_in[BYTE2(v49) + 512] ^ t_in[HIBYTE(v48) + 768];
        unsigned int v53 = t_in[v48] ^ *(v19 - 22) ^ t_in[BYTE1(v50) + 256] ^ t_in[BYTE2(v46) + 512] ^ t_in[HIBYTE(v49) + 768];
        unsigned int v54 = t_in[v49] ^ *(v19 - 21) ^ t_in[BYTE1(v48) + 256] ^ t_in[BYTE2(v50) + 512] ^ t_in[HIBYTE(v46) + 768];
        unsigned int v55 = t_in[v51] ^ *(v19 - 28) ^ t_in[BYTE1(v54) + 256] ^ t_in[BYTE2(v53) + 512] ^ t_in[HIBYTE(v52) + 768];
        unsigned int v56 = t_in[v52] ^ *(v19 - 27) ^ t_in[BYTE1(v51) + 256] ^ t_in[BYTE2(v54) + 512] ^ t_in[HIBYTE(v53) + 768];
        unsigned int v57 = t_in[v53] ^ *(v19 - 26) ^ t_in[BYTE1(v52) + 256] ^ t_in[BYTE2(v51) + 512] ^ t_in[HIBYTE(v54) + 768];
        unsigned int v58 = t_in[v54] ^ *(v19 - 25) ^ t_in[BYTE1(v53) + 256] ^ t_in[BYTE2(v52) + 512] ^ t_in[HIBYTE(v51) + 768];
        unsigned int v59 = t_in[v55] ^ *(v19 - 32) ^ t_in[BYTE1(v58) + 256] ^ t_in[BYTE2(v57) + 512] ^ t_in[HIBYTE(v56) + 768];
        unsigned int v60 = t_in[v56] ^ *(v19 - 31) ^ t_in[BYTE1(v55) + 256] ^ t_in[BYTE2(v58) + 512] ^ t_in[HIBYTE(v57) + 768];
        unsigned int v61 = t_in[HIBYTE(v58) + 768];
        int v62 = t_in[v57] ^ *(v19 - 30) ^ t_in[BYTE1(v56) + 256] ^ t_in[BYTE2(v55) + 512];
        int v63 = t_in[BYTE1(v57) + 256];
        LOWORD(v57) = v62 ^ v61;
        unsigned int v64 = t_in[v58] ^ *(v19 - 29) ^ v63 ^ t_in[BYTE2(v56) + 512] ^ t_in[HIBYTE(v55) + 768];
        unsigned int v65 = t_in[v59] ^ *(v19 - 36) ^ t_in[BYTE1(v64) + 256] ^ t_in[((v62 ^ v61) >> 16)
                                                                                     + 512] ^ t_in[HIBYTE(v60) + 768];
        unsigned int v66 = t_in[v60] ^ *(v19 - 35) ^ t_in[BYTE1(v59) + 256] ^ t_in[BYTE2(v64) + 512] ^ t_in[((v62 ^ v61) >> 24) + 768];
        unsigned int v67 = t_in[v57] ^ *(v19 - 34) ^ t_in[BYTE1(v60) + 256] ^ t_in[BYTE2(v59) + 512] ^ t_in[HIBYTE(v64) + 768];
        unsigned int v68 = t_in[v64] ^ *(v19 - 33) ^ t_in[BYTE1(v57) + 256] ^ t_in[BYTE2(v60) + 512] ^ t_in[HIBYTE(v59) + 768];
        int v69 = t_il[v65] ^ *(v19 - 40) ^ t_il[BYTE1(v68) + 256] ^ t_il[BYTE2(v67) + 512] ^ t_il[HIBYTE(v66) + 768];
        int v70 = t_il[v66] ^ *(v19 - 39) ^ t_il[BYTE1(v65) + 256] ^ t_il[BYTE2(v68) + 512] ^ t_il[HIBYTE(v67) + 768];
        int v71 = t_il[(LOBYTE(t_in[v57]) ^ *((unsigned char *)v19 - 136) ^ LOBYTE(t_in[BYTE1(v60) + 256]) ^ LOBYTE(t_in[BYTE2(v59) + 512]) ^ LOBYTE(t_in[HIBYTE(v64) + 768]))] ^ *(v19 - 38) ^ t_il[BYTE1(v66) + 256] ^ t_il[BYTE2(v65) + 512] ^ t_il[HIBYTE(v68) + 768];
        int v72 = t_il[v68] ^ *(v19 - 37) ^ t_il[BYTE1(v67) + 256] ^ t_il[BYTE2(v66) + 512] ^ t_il[HIBYTE(v65) + 768];
        if (v5)
        {
          if (a3 == 1)
          {
            int v73 = a2;
            unint64_t v74 = a2 + 1;
            int v75 = a2 + 2;
            int v76 = a2 + 3;
          }
          else
          {
            int v73 = (int *)(v8 - 1);
            unint64_t v74 = (int *)v8 - 3;
            int v75 = (int *)v8 - 2;
            int v76 = (int *)v8-- - 1;
          }
          int v11 = *v76;
          int v10 = *v75;
          int v9 = *v74;
          int v7 = *v73;
          v69 ^= v7;
          v70 ^= v9;
          v71 ^= v10;
          v72 ^= v11;
        }
        else
        {
          if (a3 == 1)
          {
            *(v13 - 2) = v69;
            *(v13 - 1) = v70;
            *unsigned int v13 = v71;
            v13[1] = v72;
            return 0;
          }
          int v7 = *((_DWORD *)v8 - 4);
          int v9 = *((_DWORD *)v8-- - 3);
          int v10 = *((_DWORD *)v8 + 2);
          int v11 = *((_DWORD *)v8 + 3);
        }
        *(v13 - 2) = v69;
        *(v13 - 1) = v70;
        *unsigned int v13 = v71;
        v13[1] = v72;
        v13 -= 4;
        if (!--a3) {
          goto LABEL_20;
        }
      }
    }
    if (a3) {
      goto LABEL_7;
    }
LABEL_20:
    if (v5) {
      *(_OWORD *)a2 = v78;
    }
  }
  return 0;
}

long long *cc_module_id(int a1)
{
  strcpy((char *)&cc_module_id_moduleProc, "Apple ARM");
  cc_module_id_moduleSecLevel = 3230803;
  switch(a1)
  {
    case 0:
      snprintf((char *)&cc_module_id_moduleID, 0x100uLL, "%s v%s [%s, %s, %s, %s]", "Apple corecrypto Module");
      break;
    case 1:
      strcpy((char *)&cc_module_id_moduleID, "Apple corecrypto Module");
      break;
    case 2:
      BYTE4(cc_module_id_moduleID) = 0;
      int v1 = 808334385;
      goto LABEL_7;
    case 3:
      BYTE4(cc_module_id_moduleID) = 0;
      int v1 = 1919251285;
LABEL_7:
      LODWORD(cc_module_id_moduleID) = v1;
      break;
    case 4:
      strcpy((char *)&cc_module_id_moduleID, "Software");
      break;
    case 5:
    case 6:
      snprintf((char *)&cc_module_id_moduleID, 0x100uLL, "%s");
      break;
    default:
      strcpy((char *)&cc_module_id_moduleID, "INVALID Module ID");
      break;
  }
  return &cc_module_id_moduleID;
}

uint64_t ccpolyzp_po2cyc_coeff_apply_galois(uint64_t *a1, unsigned int **a2, unsigned int a3)
{
  if (a1 == (uint64_t *)a2) {
    return 4294967289;
  }
  if (!ccpolyzp_po2cyc_ctx_eq(*a1, *a2)) {
    return 4294967289;
  }
  uint64_t v6 = *a2;
  unsigned int v7 = **a2;
  uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
  v8.i16[0] = vaddlv_u8(v8);
  BOOL v9 = v7 <= 0x100000 && v8.i32[0] == 1;
  if (!v9) {
    return 4294967289;
  }
  uint64_t result = 4294967289;
  if (a3 >= 2 && (a3 & 1) != 0 && 2 * v7 > a3)
  {
    uint64_t v11 = v6[1];
    if (v11)
    {
      unint64_t v12 = 0;
      unsigned int v13 = a2 + 1;
      unsigned int v14 = 0x80000000 >> __clz(v7);
      unsigned int v16 = (int *)*a1;
      unsigned int v15 = a1 + 1;
      int v17 = *v16;
      do
      {
        int v18 = v6;
        if (v12 < (v11 - 1))
        {
          unsigned int v19 = v11 - 2;
          int v18 = v6;
          do
            int v18 = (unsigned int *)*((void *)v18 + 14);
          while (v12 < v19--);
        }
        int v21 = 0;
        int v22 = 0;
        uint64_t v23 = *((void *)v18 + 2);
        int v24 = (unint64_t *)&v13[v7 * v12];
        unsigned int v25 = v7;
        do
        {
          BOOL v9 = (v22 & v14) == 0;
          v22 += a3;
          int v26 = v17 * v12 + v21;
          unint64_t v28 = *v24++;
          uint64_t v27 = v28;
          uint64_t v29 = (v23 - v28) & -(uint64_t)(((v28 | HIDWORD(v28)) + 0xFFFFFFFF) >> 32);
          if (!v9) {
            uint64_t v27 = v29;
          }
          v15[v26] = v27;
          int v21 = v22 & (v7 - 1);
          --v25;
        }
        while (v25);
        ++v12;
      }
      while (v12 != v11);
    }
    return 0;
  }
  return result;
}

uint64_t ccpolyzp_po2cyc_eval_apply_galois(uint64_t *a1, unsigned int **a2, unsigned int a3)
{
  if (a1 == (uint64_t *)a2) {
    return 4294967289;
  }
  if (!ccpolyzp_po2cyc_ctx_eq(*a1, *a2)) {
    return 4294967289;
  }
  unsigned int v6 = **a2;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
  v7.i16[0] = vaddlv_u8(v7);
  if (v6 > 0x100000 || v7.i32[0] != 1) {
    return 4294967289;
  }
  uint64_t result = 4294967289;
  if (a3 >= 2 && (a3 & 1) != 0 && 2 * v6 > a3)
  {
    unsigned int v16 = (*a2)[1];
    if (v16)
    {
      int v10 = 0;
      char v11 = __clz(v6);
      unsigned int v12 = a3;
      do
      {
        int v13 = 0;
        unsigned int v14 = &a1[(*(_DWORD *)*a1 * v10) + 1];
        do
        {
          unsigned int v15 = __rbit32(v6 + v13++);
          ccn_set(1, v14++, &(&a2[(__rbit32((v6 - 1) & ((v12 * (unint64_t)(v15 >> v11)) >> 1)) >> (v11 + 1)) + 1])[**a2 * v10]);
        }
        while (v6 != v13);
        ++v10;
      }
      while (v10 != v16);
    }
    return 0;
  }
  return result;
}

uint64_t ccsiv_context_size(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t ccsiv_block_size(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t ccsiv_ciphertext_size(uint64_t a1, uint64_t a2)
{
  return *(void *)(*(void *)(a1 + 56) + 8) + a2;
}

unint64_t ccsiv_plaintext_size(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(*(void *)(a1 + 56) + 8);
  BOOL v3 = a2 >= v2;
  unint64_t v4 = a2 - v2;
  if (v3) {
    return v4;
  }
  else {
    return 0;
  }
}

uint64_t ccsiv_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 16))(a1, a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccsiv_set_nonce(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 24))(a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccsiv_aad(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 32))(a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccsiv_crypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 40))(a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccsiv_reset(uint64_t a1, uint64_t a2)
{
  BOOL v6 = timingsafe_enable_if_supported();
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(a1 + 48))(a2);
  cc_disable_dit_with_sb((unsigned int *)&v6);
  return v4;
}

uint64_t ccsiv_one_shot(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, unsigned int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v28 = *MEMORY[0x263EF8C08];
  BOOL v18 = timingsafe_enable_if_supported();
  BOOL v27 = v18;
  MEMORY[0x270FA53B0](v18, v19, v20, v21);
  uint64_t v23 = &v26[-v22];
  uint64_t v24 = (*(uint64_t (**)(uint64_t, unsigned char *, uint64_t, uint64_t))(a1 + 16))(a1, &v26[-v22], a2, a3);
  if (!v24)
  {
    uint64_t v24 = (*(uint64_t (**)(unsigned char *, void, uint64_t))(a1 + 24))(v23, a4, a5);
    if (!v24)
    {
      uint64_t v24 = (*(uint64_t (**)(unsigned char *, void, uint64_t))(a1 + 32))(v23, a6, a7);
      if (!v24)
      {
        uint64_t v24 = (*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(a1 + 40))(v23, a8, a9, a10);
        if (!v24) {
          cc_clear(*(void *)a1, v23);
        }
      }
    }
  }
  cc_disable_dit_with_sb((unsigned int *)&v27);
  return v24;
}

uint64_t ccss_sizeof_shamir_share_generator_serialization(uint64_t a1, unint64_t *a2)
{
  unint64_t v3 = *(unsigned int *)(a1 + 8) + 2;
  unint64_t v4 = 8 * cczp_n(*(void *)a1);
  if (!is_mul_ok(v3, v4)) {
    return 0;
  }
  uint64_t result = 0;
  unint64_t v6 = v3 * v4;
  BOOL v7 = __CFADD__(v6, 9);
  unint64_t v8 = v6 + 9;
  uint64_t v9 = v7;
  uint64_t v10 = v9 << 63 >> 63;
  if (v10 == v9 && (v10 & 0x8000000000000000) == 0)
  {
    *a2 = v8;
    return 1;
  }
  return result;
}

uint64_t ccss_shamir_share_generator_serialize(unint64_t a1, uint64_t a2, uint64_t a3)
{
  char v6 = 0;
  char v21 = 0;
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    if ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) & 0x1000000) != 0)
    {
      char v6 = 0;
    }
    else
    {
      __asm { MSR             DIT, #1 }
      char v6 = 1;
    }
  }
  char v21 = v6;
  unint64_t v20 = 0;
  uint64_t v12 = 4294967289;
  if (ccss_sizeof_shamir_share_generator_serialization(a3, &v20) && v20 <= a1)
  {
    *(unsigned char *)a2 = 1;
    unint64_t v13 = **(void **)a3;
    if ((v13 >> 29))
    {
      uint64_t v12 = 4294967284;
    }
    else
    {
      uint64_t v14 = 8 * v13;
      *(_DWORD *)(a2 + 1) = bswap32(8 * v13);
      unsigned int v15 = *(_DWORD *)(a3 + 8);
      *(_DWORD *)(a2 + 5) = bswap32(v15);
      uint64_t v16 = ccn_write_uint_padded_ct_internal(v13, (unint64_t *)(*(void *)a3 + 24), 8 * v13, (char *)(a2 + 9));
      if ((v16 & 0x80000000) == 0)
      {
        unsigned int v17 = 0;
        BOOL v18 = (char *)(v14 + a2 + 9);
        while (1)
        {
          uint64_t v16 = ccn_write_uint_padded_ct_internal(v13, (unint64_t *)(a3 + 8 * v13 * v17 + 16), 8 * v13, v18);
          if ((v16 & 0x80000000) != 0) {
            break;
          }
          ++v17;
          v18 += v14;
          if (v17 > v15)
          {
            uint64_t v12 = 0;
            goto LABEL_13;
          }
        }
      }
      uint64_t v12 = v16;
    }
  }
LABEL_13:
  cc_disable_dit(&v21);
  return v12;
}

uint64_t ccss_shamir_share_generator_deserialize(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  char v8 = 0;
  char v29 = 0;
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    if ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) & 0x1000000) != 0)
    {
      char v8 = 0;
    }
    else
    {
      __asm { MSR             DIT, #1 }
      char v8 = 1;
    }
  }
  char v29 = v8;
  uint64_t v14 = *(void *)(a2 + 8);
  v25[0] = cc_malloc_clear(8 * v14);
  v25[1] = v14;
  uint64_t v26 = 0;
  BOOL v27 = cc_ws_alloc;
  uint64_t v28 = cc_ws_free;
  if (!v25[0])
  {
    uint64_t v23 = 4294967283;
    goto LABEL_22;
  }
  ccss_shamir_init_share_poly(a1, (int *)a2);
  if (a3 >= 0xA && *(unsigned char *)a4 == 1)
  {
    uint64_t v15 = bswap32(*(_DWORD *)(a4 + 1));
    if (v15)
    {
      if (v14 == (unint64_t)(v15 + 7) >> 3)
      {
        uint64_t v16 = bswap32(*(_DWORD *)(a4 + 5));
        *(_DWORD *)(a1 + 8) = v16;
        if (v16 != -1 && v16 + 1 == *(_DWORD *)a2 && (v16 + 2) * v15 + 9 == a3)
        {
          uint64_t v17 = cc_ws_alloc(v25, v14);
          uint64_t uint_internal = ccn_read_uint_internal(v14, v17, v15, a4 + 9);
          if (uint_internal)
          {
            uint64_t v23 = uint_internal;
            goto LABEL_20;
          }
          uint64_t v19 = cczp_prime(*(void *)a1);
          if (!ccn_cmp_internal(v14, v17, v19))
          {
            unsigned int v20 = 0;
            uint64_t v21 = v15 + a4 + 9;
            while (!ccn_read_uint_internal(v14, a1 + 8 * v14 * v20 + 16, v15, v21))
            {
              uint64_t v22 = cczp_prime(*(void *)a1);
              if (ccn_cmp_internal(v14, a1 + 8 * v14 * v20 + 16, v22) != -1) {
                break;
              }
              ++v20;
              v21 += v15;
              if (v20 > *(_DWORD *)(a1 + 8))
              {
                uint64_t v23 = 0;
                goto LABEL_20;
              }
            }
          }
        }
      }
    }
  }
  uint64_t v23 = 4294967289;
LABEL_20:
  uint64_t v26 = 0;
  v28((uint64_t)v25);
LABEL_22:
  cc_disable_dit(&v29);
  return v23;
}

uint64_t ccmode_ccm_init(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 72);
  *a2 = v2;
  (*(void (**)(void))(v2 + 16))();
  return 0;
}

void ccrsa_pairwise_consistency_check_ws(uint64_t a1, uint64_t *a2, uint64_t (**a3)(void, uint64_t, uint64_t))
{
  char v6 = (unint64_t *)ccrsa_ctx_public(a2);
  uint64_t v7 = *a2;
  uint64_t v8 = cczp_bitlen((uint64_t)v6);
  char v18 = 0;
  uint64_t v16 = *(void *)(a1 + 16);
  uint64_t v9 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v7);
  uint64_t v10 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v7);
  char v11 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v7);
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v7);
  unint64_t v17 = (unint64_t)(v8 + 7) >> 3;
  unint64_t v13 = ccsha256_di();
  if (!ccrsa_sign_pkcs1v15_msg_blinded_ws(a1, a3, (unint64_t *)a2, (uint64_t)v13, 0, &v18, &v17, v12))
  {
    uint64_t v14 = ccsha256_di();
    ccrsa_verify_pkcs1v15_msg_ws(a1, v6, (uint64_t)v14, 0, &v18, v17, (uint64_t)v12, 0);
    if (!v15)
    {
      ccn_seti(v7, v10, 42);
      ccn_set_bit((uint64_t)v10, v8 - 9, 1);
      if (!ccrsa_pub_crypt_ws(a1, v6, v9, v10)
        && ccn_cmp_internal(v7, v10, v9)
        && !ccrsa_priv_crypt_blinded_ws(a1, a3, a2, v11, v9))
      {
        ccn_cmp_internal(v7, v11, v10);
      }
    }
  }
  *(void *)(a1 + 16) = v16;
}

uint64_t ccpost(unsigned int *a1, int64x2_t *a2)
{
  BOOL v7 = timingsafe_enable_if_supported();
  memset(v6, 0, sizeof(v6));
  if (!a2) {
    a2 = (int64x2_t *)v6;
  }
  cc_clear(0x18uLL, a2);
  ccpost_internal(a1, a2);
  if (a2->i64[1]) {
    uint64_t v4 = 4294967221;
  }
  else {
    uint64_t v4 = 0;
  }
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return v4;
}

unsigned int *ccpost_internal(unsigned int *result, int64x2_t *a2)
{
  if (result)
  {
    uint64_t v2 = *result;
    if (v2 < 2)
    {
      return (unsigned int *)((uint64_t (*)(uint64_t, uint64_t))vector_handlers[v2])((uint64_t)result, (uint64_t)a2);
    }
    else
    {
      *a2 = vaddq_s64(*a2, vdupq_n_s64(1uLL));
      if (!a2[1].i64[0]) {
        a2[1].i64[0] = (uint64_t)result;
      }
    }
  }
  return result;
}

uint64_t ccpost_report(uint64_t result, void *a2, int a3)
{
  ++*a2;
  if (a3)
  {
    uint64_t v3 = a2[2];
    ++a2[1];
    if (!v3) {
      a2[2] = result;
    }
  }
  return result;
}

unint64_t ccec_rfc6637_wrap_pub_size(uint64_t *a1, char a2)
{
  uint64_t v3 = cczp_bitlen(*a1);
  if (a2) {
    return (unint64_t)(v3 + 7) >> 3;
  }
  else {
    return ((unint64_t)(v3 + 7) >> 2) | 1;
  }
}

unint64_t ccec_rfc6637_wrap_key_size(uint64_t *a1, char a2, uint64_t a3)
{
  BOOL v9 = timingsafe_enable_if_supported();
  uint64_t v6 = cczp_bitlen(*a1);
  if (a2) {
    unint64_t v7 = (unint64_t)(v6 + 7) >> 3;
  }
  else {
    unint64_t v7 = ((unint64_t)(v6 + 7) >> 2) | 1;
  }
  if ((a2 & 2) != 0) {
    v7 += a3 + ((unint64_t)(cczp_bitlen(*a1) + 7) >> 3) + 2;
  }
  cc_disable_dit_with_sb((unsigned int *)&v9);
  return v7 + 51;
}

uint64_t ccec_rfc6637_wrap_key(uint64_t *a1, _WORD *a2, uint64_t a3, char a4, size_t a5, unsigned __int8 *a6, char *a7, uint64_t (**a8)(void), char *a9, uint64_t (**a10)(void, uint64_t, unint64_t *))
{
  BOOL v34 = timingsafe_enable_if_supported();
  unint64_t v17 = (uint64_t *)*a1;
  uint64_t v18 = *(void *)*a1;
  uint64_t v19 = sizeof_struct_cche_galois_key();
  unint64_t v20 = sizeof_struct_ccpolyzp_po2cyc();
  v30[0] = cc_malloc_clear(248 * v18 + 16 * ((v19 + v20 + 4 * v18 * v20 - 1) / v20));
  uint64_t v21 = *v17;
  uint64_t v22 = sizeof_struct_cche_galois_key();
  unint64_t v23 = sizeof_struct_ccpolyzp_po2cyc();
  v30[1] = 31 * v21 + 2 * ((v22 + v23 + 4 * v21 * v23 - 1) / v23);
  uint64_t v31 = 0;
  unsigned int v32 = cc_ws_alloc;
  unsigned int v33 = cc_ws_free;
  if (v30[0])
  {
    uint64_t v24 = (unint64_t *)*a1;
    unsigned int v25 = (unint64_t **)cc_ws_alloc(v30, (4 * (*(void *)*a1 & 0x7FFFFFFFFFFFFFFLL)) | 2);
    uint64_t key_ws = ccecdh_generate_key_ws((uint64_t)v30, v24, a10, v25);
    if (!key_ws) {
      uint64_t key_ws = ccec_rfc6637_wrap_core_ws((uint64_t)v30, a1, v25, a2, a3, a4, a5, a6, a7, a8, a9, a10);
    }
    uint64_t v27 = key_ws;
    uint64_t v31 = 0;
    v33((uint64_t)v30);
  }
  else
  {
    uint64_t v27 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v34);
  return v27;
}

uint64_t ccz_size()
{
  BOOL v1 = timingsafe_enable_if_supported();
  cc_disable_dit_with_sb((unsigned int *)&v1);
  return 32;
}

void *ccdrbg_factory_nisthmac(void *result, uint64_t a2)
{
  *uint64_t result = 160;
  result[1] = init_1;
  result[3] = generate_5;
  result[2] = reseed_0;
  result[4] = done_0;
  result[5] = a2;
  result[6] = must_reseed_0;
  return result;
}

uint64_t init_1(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7)
{
  unint64_t v7 = *(unint64_t ***)(a1 + 40);
  *(void *)a2 = v7;
  uint64_t result = 4294967233;
  if (a3 <= 0x10000)
  {
    unint64_t v9 = **v7;
    if (v9 <= 0x40 && a7 <= 0x10000 && v9 >> 1 <= a3)
    {
      __memset_chk();
      __memset_chk();
      update_1((size_t ***)a2, 3, v12, v13, v14, v15, v16, v17, a3);
      uint64_t result = 0;
      *(void *)(a2 + 136) = 1;
    }
  }
  return result;
}

uint64_t generate_5(rsize_t ***a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v18 = *MEMORY[0x263EF8C08];
  uint64_t v8 = **a1;
  rsize_t v9 = *v8;
  uint64_t v10 = 4294967233;
  if (a2 <= 0x10000 && a4 < 0x10001)
  {
    uint64_t v12 = (char *)a3;
    rsize_t v13 = a2;
    if (*((_DWORD *)*a1 + 2) && (unint64_t)a1[17] > 0x1000000000000)
    {
      uint64_t v10 = 4294967234;
    }
    else
    {
      if (a4) {
        update_1(a1, 1, a3, a4, a5, a6, a7, a8, a4);
      }
      for (; v13; v13 -= v15)
      {
        __memcpy_chk();
        cchmac_internal((uint64_t)v8, v9, (uint64_t)(a1 + 1), v9, (uint64_t)(a1 + 9), (uint64_t)(a1 + 9));
        if (!cc_cmp_safe_internal(v9, __s, (char *)a1 + 72))
        {
          cc_clear(0x40uLL, a1 + 1);
          cc_clear(0x40uLL, a1 + 9);
          a1[17] = (rsize_t **)-1;
          cc_try_abort();
        }
        if (v13 >= v9) {
          size_t v15 = v9;
        }
        else {
          size_t v15 = v13;
        }
        memcpy(v12, a1 + 9, v15);
        v12 += v15;
      }
      update_1(a1, 1, a3, a4, a5, a6, a7, a8, a4);
      uint64_t v10 = 0;
      a1[17] = (rsize_t **)((char *)a1[17] + 1);
    }
  }
  cc_clear(v9, __s);
  return v10;
}

uint64_t reseed_0(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 > 0x10000) {
    return 4294967233;
  }
  uint64_t result = 4294967233;
  if (a4 < 0x10001 && ***(void ***)a1 >> 1 <= a2)
  {
    update_1((size_t ***)a1, 2, a3, a4, a5, a6, a7, a8, a2);
    uint64_t result = 0;
    *(void *)(a1 + 136) = 1;
  }
  return result;
}

uint64_t done_0(void *a1)
{
  cc_clear(0x40uLL, a1 + 1);
  uint64_t result = cc_clear(0x40uLL, a1 + 9);
  a1[17] = -1;
  return result;
}

BOOL must_reseed_0(void *a1)
{
  return *(_DWORD *)(*a1 + 8) && a1[17] > 0x1000000000000uLL;
}

uint64_t update_1(size_t ***a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v9 = a2;
  uint64_t v22 = (uint64_t)&v22;
  uint64_t v25 = *MEMORY[0x263EF8C08];
  uint64_t v10 = (uint64_t)(a1 + 9);
  char v11 = **a1;
  size_t v12 = *v11;
  uint64_t v24 = 0;
  uint64_t v13 = MEMORY[0x270FA53B0](a1, a2, a3, a4);
  size_t v15 = (uint64_t *)((char *)&v22 - v14);
  uint64_t v16 = 0;
  unsigned __int8 v23 = 0;
  uint64_t v17 = (char *)(v13 + 8);
  do
  {
    cchmac_init_internal((uint64_t)v11, v15, v12, v17);
    cchmac_update_internal(v11, v15, v12, v10);
    cchmac_update_internal(v11, v15, 1, &v23);
    uint64_t v24 = &a9;
    for (int i = v9; i; --i)
    {
      uint64_t v19 = v24++;
      uint64_t v20 = *v19;
      uint64_t v24 = v19 + 2;
      cchmac_update_internal(v11, v15, v20, v19[1]);
      v16 += v20;
    }
    cchmac_final_internal((uint64_t)v11, v15, (uint64_t)v17);
    cchmac_internal((uint64_t)v11, v12, (uint64_t)v17, v12, v10, v10);
    if (!v16) {
      break;
    }
    ++v23;
  }
  while (v23 < 2u);
  return cc_clear(((v11[1] + v11[2] + 19) & 0xFFFFFFFFFFFFFFF8) + v11[1], v15);
}

unint64_t cche_relin_key_nof_n(uint64_t a1)
{
  unint64_t v2 = sizeof_struct_ccpolyzp_po2cyc() + 7;
  int v3 = cche_param_ctx_key_ctx_nmoduli(a1);
  if ((v3 - 1) <= 1) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = (v3 - 1);
  }
  int v5 = cche_param_ctx_polynomial_degree(a1);
  unsigned int v6 = cche_ciphertext_fresh_npolys();
  uint64_t v7 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v8 = sizeof_struct_ccpolyzp_po2cyc();
  return ((v7 + v8 - 1) / v8
        + ((v5 * v3) + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3)) * v6)
       * v4
       + (v2 >> 3);
}

unint64_t cche_relin_key_ciphertext(uint64_t *a1, unsigned int a2)
{
  uint64_t v4 = cche_param_ctx_chain_const(*a1);
  uint64_t v5 = a2;
  unsigned int v6 = cche_ciphertext_fresh_npolys();
  uint64_t v7 = sizeof_struct_ccrns_mul_modulus();
  unint64_t v8 = sizeof_struct_ccpolyzp_po2cyc();
  return (unint64_t)&a1[((v7 + v8 - 1) / v8
                              + ((*(_DWORD *)(v4 + 12) * *(_DWORD *)(v4 + 8))
                               + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3))
                              * v6)
                             * v5
                             + 1];
}

uint64_t cche_relin_key_generate_ws(uint64_t a1, uint64_t *a2, unsigned int **a3, unsigned int *a4, int a5, uint64_t a6, uint64_t (**a7)(void, uint64_t, uint64_t))
{
  uint64_t v10 = cche_param_ctx_chain_const((uint64_t)a4);
  unsigned int v11 = *(_DWORD *)(v10 + 12);
  if (v11 < 2) {
    return 4294967289;
  }
  uint64_t v12 = v10;
  unsigned int v13 = cche_param_ctx_ciphertext_ctx_nmoduli((uint64_t)a4);
  if (a5)
  {
    if (cche_rng_seed_sizeof() * v13 != a5) {
      return 4294967289;
    }
  }
  *a2 = (uint64_t)a4;
  unsigned int v53 = cche_param_ctx_polynomial_degree((uint64_t)a4);
  uint64_t v15 = *(void *)(a1 + 16);
  uint64_t v14 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 24);
  uint64_t v16 = sizeof_struct_ccpolyzp_po2cyc();
  uint64_t v17 = (unsigned int **)v14(a1, *(_DWORD *)(v12 + 8) * v11 + ((unint64_t)(v16 + 7) >> 3));
  *uint64_t v17 = *a3;
  unsigned int v51 = v17;
  ccpolyzp_po2cyc_eval_mul(v17, a3, a3);
  unsigned int v18 = *(_DWORD *)(v12 + 12) - 1;
  uint64_t v19 = v12 + 8;
  if (v18 > v13)
  {
    uint64_t v19 = v12 + 8;
    do
    {
      uint64_t v19 = *(void *)(v19 + 112);
      --v18;
    }
    while (v18 > v13);
  }
  if (v13)
  {
    uint64_t v50 = v15;
    unint64_t v20 = 0;
    uint64_t v21 = v13;
    while (1)
    {
      int v22 = *(_DWORD *)(v12 + 12);
      unsigned __int8 v23 = (void *)(v12 + 8);
      if (v20 < (v22 - 1))
      {
        unsigned int v24 = v22 - 2;
        unsigned __int8 v23 = (void *)(v12 + 8);
        do
        {
          unsigned __int8 v23 = (void *)v23[14];
          BOOL v25 = v20 >= v24--;
        }
        while (!v25);
      }
      unint64_t v26 = cche_relin_key_ciphertext(a2, v20);
      unsigned int v27 = *(_DWORD *)(v12 + 12);
      uint64_t v28 = a6 ? a6 + cche_rng_seed_sizeof() * v20 : 0;
      uint64_t result = cche_encrypt_zero_symmetric_eval_ws(a1, v26, a4, (uint64_t *)a3, v27, v28, a7);
      if (result) {
        break;
      }
      if (v53)
      {
        uint64_t v30 = v23[2];
        uint64_t v31 = *(void *)(v19 + 16)
            - v30 * (((unint64_t)v23[3] * (unsigned __int128)*(unint64_t *)(v19 + 16)) >> 64);
        uint64_t v32 = v31 - v30;
        if (v32 >= 0) {
          uint64_t v31 = v32;
        }
        unint64_t v33 = v26 + 32;
        uint64_t v34 = v53;
        unsigned int v35 = **v51 * v20;
        unsigned int v36 = **(_DWORD **)(v26 + 24) * v20;
        do
        {
          unint64_t v37 = (unint64_t)v51[v35 + 1];
          unint64_t v38 = (v37 * (unsigned __int128)(unint64_t)v31) >> 64;
          uint64_t v39 = v37 * v31;
          unint64_t v40 = v23[4];
          uint64_t v41 = ((unint64_t)v39 * (unsigned __int128)v40) >> 64;
          uint64_t v42 = (v38 * (unsigned __int128)v40) >> 64;
          uint64_t v43 = v38 * v40;
          BOOL v25 = __CFADD__(v41, v43);
          uint64_t v44 = v41 + v43;
          uint64_t v45 = v25;
          uint64_t v46 = v45
              + __CFADD__(v39 * v23[5], v44)
              + v42
              + v23[5] * v38
              + (((unint64_t)v39 * (unsigned __int128)(unint64_t)v23[5]) >> 64);
          uint64_t v47 = v23[2];
          uint64_t v48 = v39 - v46 * v47;
          if (v48 - v47 >= 0) {
            v48 -= v47;
          }
          uint64_t v49 = v48 + *(void *)(v33 + 8 * v36);
          if (v49 - v47 >= 0) {
            v49 -= v47;
          }
          *(void *)(v33 + 8 * v36) = v49;
          ++v35;
          ++v36;
          --v34;
        }
        while (v34);
      }
      if (++v20 == v21)
      {
        uint64_t result = 0;
        break;
      }
    }
    uint64_t v15 = v50;
  }
  else
  {
    uint64_t result = 0;
  }
  *(void *)(a1 + 16) = v15;
  return result;
}

uint64_t cche_relin_key_generate(uint64_t *a1, unsigned int **a2, unsigned int *a3, int a4, uint64_t a5, uint64_t (**a6)(void, uint64_t, uint64_t))
{
  BOOL v26 = timingsafe_enable_if_supported();
  uint64_t v12 = cche_param_ctx_chain_const((uint64_t)a3);
  unsigned int v13 = cche_param_ctx_polynomial_degree((uint64_t)a3);
  uint64_t v14 = v13;
  uint64_t v15 = *(unsigned int *)(v12 + 12);
  unint64_t v16 = CCPOLYZP_PO2CYC_WORKSPACE_N(v13, *(_DWORD *)(v12 + 12));
  uint64_t v17 = CCHE_ENCRYPT_ZERO_SYMMETRIC_EVAL_WORKSPACE_N(v14, v15);
  v24[0] = cc_malloc_clear(8 * (v17 + v16));
  unsigned int v18 = cche_param_ctx_polynomial_degree((uint64_t)a3);
  uint64_t v19 = v18;
  uint64_t v20 = *(unsigned int *)(v12 + 12);
  unint64_t v21 = CCPOLYZP_PO2CYC_WORKSPACE_N(v18, v20);
  v24[1] = CCHE_ENCRYPT_ZERO_SYMMETRIC_EVAL_WORKSPACE_N(v19, v20) + v21;
  void v24[2] = 0;
  v24[3] = cc_ws_alloc;
  BOOL v25 = cc_ws_free;
  if (v24[0])
  {
    uint64_t ws = cche_relin_key_generate_ws((uint64_t)v24, a1, a2, a3, a4, a5, a6);
    v25((uint64_t)v24);
  }
  else
  {
    uint64_t ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v26);
  return ws;
}

uint64_t cche_relin_key_save_ws(uint64_t a1, int a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8 = cche_param_ctx_chain_const(*a4);
  if (*(_DWORD *)(v8 + 12) < 2u) {
    return 4294967289;
  }
  int v9 = (unsigned int *)(v8 + 8);
  unsigned int v10 = cche_param_ctx_ciphertext_ctx_nmoduli(*a4);
  uint64_t v11 = ccpolyzp_po2cyc_serialize_poly_nbytes(v9, 0);
  if (v11 * v10 != a2) {
    return 4294967289;
  }
  if (!v10) {
    return 0;
  }
  uint64_t v12 = v11;
  unsigned int v13 = 0;
  while (1)
  {
    unint64_t v14 = cche_relin_key_ciphertext(a4, v13);
    uint64_t result = ccpolyzp_po2cyc_serialize_poly_ws(a1, v12, a3, 0, (unsigned int **)(v14 + 24));
    if (result) {
      break;
    }
    a3 += v12;
    if (v10 == ++v13) {
      return 0;
    }
  }
  return result;
}

uint64_t cche_relin_key_save(int a1, uint64_t a2, uint64_t *a3)
{
  BOOL v13 = timingsafe_enable_if_supported();
  unsigned int v6 = cche_param_ctx_polynomial_degree(*a3);
  uint64_t v7 = CCPOLYZP_PO2CYC_SERIALIZE_POLY_WORKSPACE_N(v6);
  v11[0] = cc_malloc_clear(8 * v7);
  unsigned int v8 = cche_param_ctx_polynomial_degree(*a3);
  v11[1] = CCPOLYZP_PO2CYC_SERIALIZE_POLY_WORKSPACE_N(v8);
  _OWORD v11[2] = 0;
  v11[3] = cc_ws_alloc;
  uint64_t v12 = cc_ws_free;
  if (v11[0])
  {
    uint64_t v9 = cche_relin_key_save_ws((uint64_t)v11, a1, a2, a3);
    v12((uint64_t)v11);
  }
  else
  {
    uint64_t v9 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v13);
  return v9;
}

uint64_t cche_relin_key_load_ws(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, uint64_t a5, int a6, uint64_t a7)
{
  uint64_t v11 = a3;
  uint64_t v12 = cche_param_ctx_chain_const(a3);
  if (*(_DWORD *)(v12 + 12) < 2u) {
    return 4294967289;
  }
  BOOL v13 = (unsigned int *)(v12 + 8);
  unsigned int v14 = cche_param_ctx_ciphertext_ctx_nmoduli(v11);
  uint64_t v15 = ccpolyzp_po2cyc_serialize_poly_nbytes(v13, 0);
  uint64_t v27 = cche_rng_seed_sizeof();
  if (v15 * v14 != a4 || v27 * v14 != a6) {
    return 4294967289;
  }
  *a2 = v11;
  if (!v14) {
    return 0;
  }
  unsigned int v17 = 0;
  unsigned int v26 = v14;
  uint64_t v25 = v11;
  while (1)
  {
    unint64_t v18 = cche_relin_key_ciphertext(a2, v17);
    unsigned int v19 = cche_ciphertext_fresh_npolys();
    *(void *)unint64_t v18 = v11;
    *(_DWORD *)(v18 + 8) = v19;
    *(void *)(v18 + 16) = 1;
    *(void *)(v18 + 24) = v13;
    uint64_t v20 = (_DWORD **)(v18 + 24);
    if (v19 >= 2)
    {
      uint64_t v21 = v19;
      for (uint64_t i = 1; i != v21; ++i)
      {
        unsigned __int8 v23 = *v20;
        v20[((v23[1] * *v23) + ((unint64_t)(sizeof_struct_ccpolyzp_po2cyc() + 7) >> 3)) * i] = v13;
      }
    }
    uint64_t result = cche_deserialize_seeded_ciphertext_eval_ws(a1, v18, v15, a5);
    if (result) {
      break;
    }
    a7 += v27;
    a5 += v15;
    ++v17;
    uint64_t v11 = v25;
    if (v17 == v26) {
      return 0;
    }
  }
  return result;
}

uint64_t cche_relin_key_load(uint64_t *a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  BOOL v19 = timingsafe_enable_if_supported();
  unsigned int v12 = cche_param_ctx_polynomial_degree(a2);
  unint64_t v13 = CCHE_DESERIALIZE_SEEDED_CIPHERTEXT_EVAL_WORKSPACE_N(v12);
  v17[0] = cc_malloc_clear(8 * v13);
  unsigned int v14 = cche_param_ctx_polynomial_degree(a2);
  v17[1] = CCHE_DESERIALIZE_SEEDED_CIPHERTEXT_EVAL_WORKSPACE_N(v14);
  void v17[2] = 0;
  void v17[3] = cc_ws_alloc;
  unint64_t v18 = cc_ws_free;
  if (v17[0])
  {
    uint64_t ws = cche_relin_key_load_ws((uint64_t)v17, a1, a2, a3, a4, a5, a6);
    v18((uint64_t)v17);
  }
  else
  {
    uint64_t ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v19);
  return ws;
}

uint64_t ccz_lsr(void *a1, uint64_t a2, unint64_t a3)
{
  BOOL v15 = timingsafe_enable_if_supported();
  uint64_t v6 = ccz_n(a2);
  unint64_t v7 = ccn_bitlen_internal(v6, *(void *)(a2 + 24));
  unint64_t v8 = v7 - a3;
  if (v7 <= a3)
  {
    ccz_zero(a1);
  }
  else
  {
    unint64_t v9 = a3 >> 6;
    int v10 = ccz_sign(a2);
    ccz_set_sign((uint64_t)a1, v10);
    uint64_t v11 = ccz_n(a2);
    ccz_set_capacity((uint64_t)a1, v11 - (a3 >> 6));
    if ((a3 & 0x3F) != 0)
    {
      uint64_t v12 = ccz_n(a2);
      ccn_shift_right(v12 - v9, a1[3], (unint64_t *)(*(void *)(a2 + 24) + 8 * v9), a3 & 0x3F);
    }
    else if (a1 != (void *)a2 || a3 >= 0x40)
    {
      uint64_t v13 = ccz_n(a2);
      ccn_set(v13 - v9, (void *)a1[3], (void *)(*(void *)(a2 + 24) + 8 * v9));
    }
    ccz_set_n(a1, (v8 + 63) >> 6);
  }
  return cc_disable_dit_with_sb((unsigned int *)&v15);
}

uint64_t ccsiv_hmac_context_size(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t ccsiv_hmac_block_size(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t ccsiv_hmac_ciphertext_size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 16) + a2;
}

unint64_t ccsiv_hmac_plaintext_size(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  BOOL v3 = a2 >= v2;
  unint64_t v4 = a2 - v2;
  if (v3) {
    return v4;
  }
  else {
    return 0;
  }
}

uint64_t ccsiv_hmac_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 16))(a1, a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccsiv_hmac_aad(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 32))(a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccsiv_hmac_set_nonce(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 24))(a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccsiv_hmac_crypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 40))(a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccsiv_hmac_reset(uint64_t a1, uint64_t a2)
{
  BOOL v6 = timingsafe_enable_if_supported();
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(a1 + 48))(a2);
  cc_disable_dit_with_sb((unsigned int *)&v6);
  return v4;
}

uint64_t ccsiv_hmac_one_shot(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, unsigned int a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v29 = *MEMORY[0x263EF8C08];
  BOOL v19 = timingsafe_enable_if_supported();
  BOOL v28 = v19;
  MEMORY[0x270FA53B0](v19, v20, v21, v22);
  unsigned int v24 = &v27[-v23];
  uint64_t v25 = (*(uint64_t (**)(uint64_t, unsigned char *, uint64_t, uint64_t, uint64_t))(a1 + 16))(a1, &v27[-v23], a2, a3, a4);
  if (!v25)
  {
    if (!a7 || (uint64_t v25 = (*(uint64_t (**)(unsigned char *, void, uint64_t))(a1 + 32))(v24, a7, a8), !v25))
    {
      if (!a5 || (uint64_t v25 = (*(uint64_t (**)(unsigned char *, void, uint64_t))(a1 + 24))(v24, a5, a6), !v25))
      {
        uint64_t v25 = (*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(a1 + 40))(v24, a9, a10, a11);
        if (!v25) {
          cc_clear(*(void *)a1, v24);
        }
      }
    }
  }
  cc_disable_dit_with_sb((unsigned int *)&v28);
  return v25;
}

uint64_t fipspost_post_aes_cmac(char a1)
{
  void v15[2] = *MEMORY[0x263EF8C08];
  unint64_t v2 = ccaes_cbc_encrypt_mode();
  int v14 = 0;
  if (cccmac_one_shot_generate(v2, 16, (uint64_t)"\xE4\xB7\x64[/}c\xB4gL\xD0\x19p\xC9\xD1\xEC\xF2\x66\xA1\x87", 0, (char *)&unk_2373C8106, 4uLL, &v14))
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed cccmac_one_shot_generate COUNT #0: %d\n");
    return 4294967224;
  }
  uint64_t v4 = "\x01\xF2\x66\xA1\x87";
  if ((a1 & 0x10) == 0) {
    uint64_t v4 = "\xF2\x66\xA1\x87";
  }
  if (*(_DWORD *)v4 != v14)
  {
    uint64_t v5 = mach_absolute_time();
    int v6 = 56;
LABEL_8:
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed AES-CMAC KAT\n", v5, "fipspost_post_aes_cmac", v6);
    return 4294967221;
  }
  int v13 = 0;
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed cccmac_one_shot_generate COUNT #32: %d\n");
    return 4294967224;
  }
  unint64_t v7 = "\x01\xFB\xFE\xA4\x1B";
  if ((a1 & 0x10) == 0) {
    unint64_t v7 = "\xFB\xFE\xA4\x1B";
  }
  if (*(_DWORD *)v7 != v13)
  {
    uint64_t v5 = mach_absolute_time();
    int v6 = 95;
    goto LABEL_8;
  }
  *(void *)((char *)v15 + 7) = 0;
  v15[0] = 0;
  if (cccmac_one_shot_generate(v2, 16, (uint64_t)"\x18tYl\xF1\x8A\x10\xBCq\xD6\x0Ck\xB9=", 0x25uLL, "\x12\xA3@\xEF\x01\x5D\xC0\xA3\x86%\xA4\x84~\xB6\xCA\xC9E\x05H\xE9\xF9\x64\x02ue1\xA6\xA5\xBF\x9C7\xC1\x46\xBB\x01", 0xFuLL, v15))
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed cccmac_one_shot_generate COUNT #79: %d\n");
    return 4294967224;
  }
  uint64_t v8 = "\x01&\xA5\xFD%\x80Q)uk[\x1A\xC3\x3D\x87t";
  if ((a1 & 0x10) == 0) {
    uint64_t v8 = "&\xA5\xFD%\x80Q)uk[\x1A\xC3\x3D\x87t";
  }
  uint64_t v9 = *(void *)v8;
  uint64_t v10 = *(void *)(v8 + 7);
  if (v9 != v15[0] || v10 != *(void *)((char *)v15 + 7))
  {
    uint64_t v5 = mach_absolute_time();
    int v6 = 134;
    goto LABEL_8;
  }
  if ((a1 & 0x10) != 0) {
    BOOL v12 = "\x01\xD4\xD7\xFC\xC5\xF9y#\x0F";
  }
  else {
    BOOL v12 = "\xD4\xD7\xFC\xC5\xF9y#\x0F";
  }
  if (cccmac_one_shot_verify(v2, 0x10uLL, (uint64_t)"rV\xE3\x44\xF6\x8B>\x7F\x9D\xD6\xE0L\\e\x13\\"", 0, (char *)&unk_2373C8106, 8, v12))
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed cccmac_one_shot_verify COUNT #2: %d\n");
    return 4294967224;
  }
  if (!cccmac_one_shot_verify(v2, 0x10uLL, (uint64_t)"e\x83\xA4\xFF'\xB6\xE1\x09\x04m\x11\xB9w\xC8\x29=", 0x20uLL, "\xB6;\xE3\x20\xF9.\x01&\x0F\xBA71\"$IJ'd\xDF\xC9((|u\xDC\x1C\xAF\xEE\x7B\x69\x8DH", {
                        8,
  }
                        "\xFA\f\xCE\xD2.\x89k@"))
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed cccmac_one_shot_verify COUNT #47: %d\n");
    return 4294967224;
  }
  if (!cccmac_one_shot_verify(v2, 0x10uLL, (uint64_t)"\xED\xFE\x2E\x15\xED\xF0\xB0\u0088ue\x1DK\xEC\xFC\xA5", 0x40uLL, aP_1, 8, "{ps\x02\x19\x90}\x18"))
  {
    mach_absolute_time();
    printf("FIPSPOST_USER [%llu] %s:%d: FAILED: failed cccmac_one_shot_verify COUNT #89: %d\n");
    return 4294967224;
  }
  return 0;
}

uint64_t ccn_read_uint_public_value(unint64_t a1, void *a2, unint64_t a3, unsigned __int8 *a4)
{
  unint64_t v4 = 8 * a1;
  if (a3 > 8 * a1)
  {
    int v5 = 0;
    unint64_t v6 = a3 - v4;
    unint64_t v7 = a4;
    do
    {
      int v8 = *v7++;
      v5 |= v8;
      --a3;
    }
    while (a3 > v4);
    if (v5) {
      return 4294967289;
    }
    a4 += v6;
    a3 = 8 * a1;
  }
  if (a3 < 8)
  {
    unint64_t v10 = 0;
  }
  else
  {
    unint64_t v10 = ((a3 - 8) >> 3) + 1;
    uint64_t v11 = a2;
    unint64_t v12 = v10;
    do
    {
      *v11++ = bswap64(*(void *)&a4[a3 - 8]);
      a3 -= 8;
      --v12;
    }
    while (v12);
  }
  if (a3)
  {
    unint64_t v13 = 0;
    uint64_t v14 = -(uint64_t)a3;
    do
      unint64_t v13 = a4[a3 + v14] | (v13 << 8);
    while (!__CFADD__(v14++, 1));
    a2[v10++] = v13;
  }
  if (v10 < a1) {
    bzero(&a2[v10], v4 - 8 * v10);
  }
  return 0;
}

uint64_t ccn_read_uint(unint64_t a1, void *a2, unint64_t a3, unsigned __int8 *a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t uint_public_value = ccn_read_uint_public_value(a1, a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return uint_public_value;
}

void *ccaes_cfb_encrypt_mode()
{
  BOOL v0 = ccaes_ecb_encrypt_mode();
  ccmode_factory_cfb_encrypt(cfb_encrypt, v0);
  return cfb_encrypt;
}

uint64_t ccdh_ctx_init(uint64_t result, void *a2)
{
  *a2 = result;
  return result;
}

uint64_t ccdh_ccn_size(void *a1)
{
  return 8 * *a1;
}

uint64_t ccdh_export_pub_size(void **a1)
{
  return 8 * **a1;
}

uint64_t ccdh_gp_g(void *a1)
{
  return (uint64_t)&a1[*a1 + 4 + *a1];
}

uint64_t ccdh_gp_order(void *a1)
{
  return (uint64_t)&a1[*a1 + 4 + *a1 + *a1];
}

uint64_t ccdh_gp_l(void *a1)
{
  return a1[*a1 + 4 + *a1 + *a1 + *a1];
}

unint64_t ccdh_gp_order_bitlen(void *a1)
{
  unint64_t v2 = cczp_n((uint64_t)a1);
  BOOL v3 = &a1[*a1 + 4 + *a1 + *a1];

  return ccn_bitlen_public_value(v2, v3);
}

double fe_0(uint64_t a1)
{
  *(void *)(a1 + 32) = 0;
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

double fe_1(uint64_t a1)
{
  *(_DWORD *)a1 = 1;
  double result = 0.0;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_OWORD *)(a1 + 20) = 0u;
  *(_DWORD *)(a1 + 36) = 0;
  return result;
}

int32x4_t fe_add(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int32x4_t result = vaddq_s32(*(int32x4_t *)a3, *(int32x4_t *)a2);
  int32x4_t v4 = vaddq_s32(*(int32x4_t *)(a3 + 16), *(int32x4_t *)(a2 + 16));
  int32x2_t v5 = vadd_s32(*(int32x2_t *)(a3 + 32), *(int32x2_t *)(a2 + 32));
  *(int32x4_t *)a1 = result;
  *(int32x4_t *)(a1 + 16) = v4;
  *(int32x2_t *)(a1 + 32) = v5;
  return result;
}

uint64_t fe_cmov(uint64_t *a1, uint64_t *a2, char a3)
{
  return ccn_mux(5, a3, a1, a2, a1);
}

__n128 fe_copy(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  uint64_t v4 = *(void *)(a2 + 32);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v3;
  *(void *)(a1 + 32) = v4;
  return result;
}

uint64_t fe_invert(_DWORD *a1, int *a2)
{
  uint64_t v21 = *MEMORY[0x263EF8C08];
  uint64_t v20 = 0;
  memset(v19, 0, sizeof(v19));
  uint64_t v18 = 0;
  memset(v17, 0, sizeof(v17));
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  fe_sq(v19, a2);
  fe_sq(v17, (int *)v19);
  fe_sq(v17, (int *)v17);
  fe_mul(v17, a2, (int *)v17);
  fe_mul(v19, (int *)v19, (int *)v17);
  fe_sq(v15, (int *)v19);
  fe_mul(v17, (int *)v17, (int *)v15);
  fe_sq(v15, (int *)v17);
  int v4 = 4;
  do
  {
    fe_sq(v15, (int *)v15);
    --v4;
  }
  while (v4);
  fe_mul(v17, (int *)v15, (int *)v17);
  fe_sq(v15, (int *)v17);
  int v5 = 9;
  do
  {
    fe_sq(v15, (int *)v15);
    --v5;
  }
  while (v5);
  uint64_t v14 = 0;
  memset(v13, 0, sizeof(v13));
  fe_mul(v15, (int *)v15, (int *)v17);
  fe_sq(v13, (int *)v15);
  int v6 = 19;
  do
  {
    fe_sq(v13, (int *)v13);
    --v6;
  }
  while (v6);
  fe_mul(v15, (int *)v13, (int *)v15);
  fe_sq(v15, (int *)v15);
  int v7 = 9;
  do
  {
    fe_sq(v15, (int *)v15);
    --v7;
  }
  while (v7);
  fe_mul(v17, (int *)v15, (int *)v17);
  fe_sq(v15, (int *)v17);
  int v8 = 49;
  do
  {
    fe_sq(v15, (int *)v15);
    --v8;
  }
  while (v8);
  fe_mul(v15, (int *)v15, (int *)v17);
  fe_sq(v13, (int *)v15);
  int v9 = 99;
  do
  {
    fe_sq(v13, (int *)v13);
    --v9;
  }
  while (v9);
  fe_mul(v15, (int *)v13, (int *)v15);
  fe_sq(v15, (int *)v15);
  int v10 = 49;
  do
  {
    fe_sq(v15, (int *)v15);
    --v10;
  }
  while (v10);
  fe_mul(v17, (int *)v15, (int *)v17);
  fe_sq(v17, (int *)v17);
  int v11 = 4;
  do
  {
    fe_sq(v17, (int *)v17);
    --v11;
  }
  while (v11);
  return fe_mul(a1, (int *)v17, (int *)v19);
}

_DWORD *fe_sq(_DWORD *result, int *a2)
{
  uint64_t v3 = a2[4];
  uint64_t v2 = a2[5];
  uint64_t v5 = a2[6];
  uint64_t v4 = a2[7];
  uint64_t v6 = 19 * (int)v5;
  uint64_t v7 = *a2;
  uint64_t v8 = a2[1];
  uint64_t v9 = 38 * (int)v4;
  uint64_t v11 = a2[8];
  uint64_t v10 = a2[9];
  uint64_t v12 = 19 * (int)v11;
  uint64_t v13 = a2[2];
  uint64_t v14 = a2[3];
  uint64_t v15 = 2 * v7;
  uint64_t v16 = 2 * v13;
  uint64_t v17 = 2 * v14;
  uint64_t v18 = 38 * (int)v10;
  uint64_t v19 = 2 * v7 * v8;
  uint64_t v20 = 2 * v8 * v13;
  uint64_t v21 = 38 * (int)v2 * (uint64_t)(int)v2
      + (int)v7 * (uint64_t)(int)v7
      + v6 * 2 * v3
      + v9 * 2 * v14
      + v12 * 2 * v13
      + v18 * 2 * v8;
  uint64_t v22 = 2 * v8 * v8 + v13 * 2 * v7;
  uint64_t v23 = 2 * v14 * 2 * v8 + (int)v13 * (uint64_t)(int)v13 + v3 * 2 * v7 + v9 * v4 + 2 * v5 * v12 + v18 * 2 * v2;
  uint64_t v24 = v19 + v6 * 2 * v2 + v9 * v3 + v12 * 2 * v14 + v18 * v13 + ((v21 + 0x2000000) >> 26);
  uint64_t v25 = 2 * v13 * v14 + v3 * 2 * v8 + v2 * v15 + v12 * 2 * v4 + v18 * v5 + ((v23 + 0x2000000) >> 26);
  uint64_t v26 = v22 + v6 * v5 + v9 * 2 * v2 + v12 * 2 * v3 + v18 * 2 * v14 + ((v24 + 0x1000000) >> 25);
  uint64_t v27 = v20 + v14 * v15;
  uint64_t v28 = v3 * v16 + 2 * v14 * v14 + 2 * v2 * 2 * v8 + v5 * v15 + v12 * v11 + v18 * 2 * v4 + ((v25 + 0x1000000) >> 25);
  uint64_t v29 = v27 + v9 * v5 + v12 * 2 * v2 + v18 * v3 + ((v26 + 0x2000000) >> 26);
  LODWORD(v12) = v26 - ((v26 + 0x2000000) & 0xFC000000);
  uint64_t v30 = 2 * v3 * v2;
  uint64_t v31 = v17 * v3 + v2 * v16;
  uint64_t v32 = v5 * v16 + (int)v3 * (uint64_t)(int)v3 + 2 * v2 * v17;
  uint64_t v33 = v31 + v5 * 2 * v8 + v4 * v15 + v18 * v11 + ((v28 + 0x2000000) >> 26);
  uint64_t v34 = v30 + v5 * v17 + v4 * v16 + v11 * 2 * v8;
  uint64_t v35 = v32 + 2 * v4 * 2 * v8 + v11 * v15 + v18 * v10 + ((v33 + 0x1000000) >> 25);
  uint64_t v36 = v34 + v10 * v15 + ((v35 + 0x2000000) >> 26);
  unint64_t v37 = v21 - ((v21 + 0x2000000) & 0xFFFFFFFFFC000000) + 19 * ((v36 + 0x1000000) >> 25);
  *__n128 result = v37 - ((v37 + 0x2000000) & 0xFC000000);
  result[1] = v24 - ((v24 + 0x1000000) & 0xFE000000) + ((v37 + 0x2000000) >> 26);
  unint64_t v38 = v23 - ((v23 + 0x2000000) & 0xFFFFFFFFFC000000) + ((v29 + 0x1000000) >> 25);
  result[2] = v12;
  result[3] = v29 - ((v29 + 0x1000000) & 0xFE000000);
  result[4] = v38 - ((v38 + 0x2000000) & 0xFC000000);
  result[5] = v25 - ((v25 + 0x1000000) & 0xFE000000) + ((v38 + 0x2000000) >> 26);
  result[6] = v28 - ((v28 + 0x2000000) & 0xFC000000);
  result[7] = v33 - ((v33 + 0x1000000) & 0xFE000000);
  result[8] = v35 - ((v35 + 0x2000000) & 0xFC000000);
  result[9] = v36 - ((v36 + 0x1000000) & 0xFE000000);
  return result;
}

uint64_t fe_mul(_DWORD *a1, int *a2, int *a3)
{
  uint64_t v4 = a2[8];
  uint64_t v5 = a3[1];
  uint64_t v6 = 2 * a2[9];
  uint64_t v7 = a2[9];
  int v9 = a3[2];
  uint64_t v8 = a3[3];
  uint64_t v10 = 19 * v9;
  uint64_t v11 = 19 * (int)v8;
  int v12 = a3[4];
  uint64_t v81 = a3[5];
  uint64_t v13 = 19 * v12;
  uint64_t v14 = 19 * (int)v81;
  uint64_t v16 = a2[2];
  uint64_t v15 = a2[3];
  uint64_t v82 = a2[1];
  uint64_t v17 = a2[4];
  uint64_t v18 = a2[5];
  uint64_t v19 = a2[6];
  uint64_t v20 = a2[7];
  uint64_t v71 = 2 * v15;
  uint64_t v72 = 2 * v18;
  uint64_t v21 = 19 * v5 * v6 + *a3 * (uint64_t)*a2 + v10 * v4 + v11 * 2 * v20;
  uint64_t v22 = *a3 * (uint64_t)(int)v82 + (int)v5 * (uint64_t)*a2 + v10 * v7 + v11 * v4;
  uint64_t v23 = v5 * 2 * v82 + *a3 * (uint64_t)(int)v16 + v9 * (uint64_t)*a2 + v11 * v6;
  uint64_t v24 = v21 + v13 * v19 + v14 * 2 * v18;
  uint64_t v25 = v5 * 2 * v15
      + *a3 * (uint64_t)(int)v17
      + v9 * (uint64_t)(int)v16
      + v8 * 2 * v82
      + v12 * (uint64_t)*a2
      + v14 * 2 * v7;
  uint64_t v79 = v15;
  uint64_t v26 = v22 + v13 * v20 + v14 * v19;
  uint64_t v80 = v23 + v13 * v4 + v14 * 2 * v20;
  uint64_t v27 = *a3 * (uint64_t)(int)v15
      + (int)v5 * (uint64_t)(int)v16
      + v9 * (uint64_t)(int)v82
      + (int)v8 * (uint64_t)*a2
      + v13 * v7
      + v14 * v4;
  LODWORD(v23) = a3[6];
  uint64_t v28 = a3[7];
  uint64_t v29 = 19 * (int)v23;
  uint64_t v30 = v24 + v29 * v17;
  uint64_t v31 = v25 + v29 * v4;
  uint64_t v75 = v18;
  uint64_t v32 = v26 + v29 * v18;
  uint64_t v33 = *a3 * (uint64_t)(int)v18
      + (int)v5 * (uint64_t)(int)v17
      + v9 * (uint64_t)(int)v15
      + (int)v8 * (uint64_t)(int)v16
      + v12 * (uint64_t)(int)v82
      + (int)v81 * (uint64_t)*a2
      + v29 * a2[9];
  uint64_t v34 = a2[9];
  uint64_t v35 = v80 + v29 * v19;
  uint64_t v36 = v27 + v29 * v20;
  uint64_t v37 = 19 * (int)v28;
  uint64_t v74 = v31 + v37 * 2 * v20;
  uint64_t v76 = v32 + v37 * v17;
  uint64_t v77 = v30 + v37 * v71;
  uint64_t v38 = v33 + v37 * v4;
  uint64_t v78 = v35 + v37 * v72;
  uint64_t v39 = v5 * v72
      + *a3 * (uint64_t)(int)v19
      + v9 * (uint64_t)(int)v17
      + v8 * v71
      + v12 * (uint64_t)(int)v16
      + v81 * 2 * v82
      + (int)v23 * (uint64_t)*a2
      + v37 * 2 * v34;
  uint64_t v73 = v36 + v37 * v19;
  LODWORD(v37) = a3[8];
  LODWORD(v80) = a3[9];
  uint64_t v40 = 19 * (int)v37;
  uint64_t v41 = 19 * (int)v80;
  uint64_t v42 = v39 + v40 * v4 + v41 * 2 * v20;
  uint64_t v43 = v5 * 2 * v20 + *a3 * (uint64_t)(int)v4;
  uint64_t v44 = v38 + v40 * v20;
  uint64_t v45 = *a3 * (uint64_t)(int)v34 + (int)v5 * (uint64_t)(int)v4 + v9 * (uint64_t)(int)v20;
  uint64_t v46 = *a3 * (uint64_t)(int)v20 + (int)v5 * (uint64_t)(int)v19 + v9 * (uint64_t)(int)v75;
  uint64_t v47 = v74 + v40 * v19 + v41 * v72;
  uint64_t v48 = v43 + v9 * (uint64_t)(int)v19 + v8 * v72;
  uint64_t v49 = v44 + v41 * v19;
  uint64_t v50 = v45 + (int)v8 * (uint64_t)(int)v19;
  uint64_t v51 = v46
      + (int)v8 * (uint64_t)(int)v17
      + v12 * (uint64_t)(int)v79
      + (int)v81 * (uint64_t)(int)v16
      + (int)v23 * (uint64_t)(int)v82
      + (int)v28 * (uint64_t)*a2
      + v40 * v34;
  uint64_t v52 = v77 + v40 * v16;
  uint64_t v53 = v76 + v40 * v79;
  uint64_t v54 = v50 + v12 * (uint64_t)(int)v75;
  uint64_t v55 = v78 + v40 * v17 + v41 * v71;
  uint64_t v56 = v73 + v40 * v75 + v41 * v17;
  uint64_t v57 = v51 + v41 * v4;
  uint64_t v58 = v52 + v41 * 2 * v82;
  uint64_t v59 = v48
      + v12 * (uint64_t)(int)v17
      + v81 * v71
      + (int)v23 * (uint64_t)(int)v16
      + v28 * 2 * v82
      + (int)v37 * (uint64_t)*a2
      + v41 * 2 * v34;
  uint64_t result = 0x2000000;
  uint64_t v61 = v53 + v41 * v16 + ((v58 + 0x2000000) >> 26);
  uint64_t v62 = v49 + ((v47 + 0x2000000) >> 26);
  uint64_t v63 = v55 + ((v61 + 0x1000000) >> 25);
  uint64_t v64 = v42 + ((v62 + 0x1000000) >> 25);
  uint64_t v65 = v56 + ((v63 + 0x2000000) >> 26);
  uint64_t v66 = v57 + ((v64 + 0x2000000) >> 26);
  uint64_t v67 = v59 + ((v66 + 0x1000000) >> 25);
  uint64_t v68 = v54
      + (int)v81 * (uint64_t)(int)v17
      + (int)v23 * (uint64_t)(int)v79
      + (int)v28 * (uint64_t)(int)v16
      + (int)v37 * (uint64_t)(int)v82
      + (int)v80 * (uint64_t)*a2
      + ((v67 + 0x2000000) >> 26);
  unint64_t v69 = v58 - ((v58 + 0x2000000) & 0xFFFFFFFFFC000000) + 19 * ((v68 + 0x1000000) >> 25);
  *a1 = v69 - ((v69 + 0x2000000) & 0xFC000000);
  a1[1] = v61 - ((v61 + 0x1000000) & 0xFE000000) + ((v69 + 0x2000000) >> 26);
  unint64_t v70 = v47 - ((v47 + 0x2000000) & 0xFFFFFFFFFC000000) + ((v65 + 0x1000000) >> 25);
  a1[2] = v63 - ((v63 + 0x2000000) & 0xFC000000);
  a1[3] = v65 - ((v65 + 0x1000000) & 0xFE000000);
  a1[4] = v70 - ((v70 + 0x2000000) & 0xFC000000);
  a1[5] = v62 - ((v62 + 0x1000000) & 0xFE000000) + ((v70 + 0x2000000) >> 26);
  a1[6] = v64 - ((v64 + 0x2000000) & 0xFC000000);
  a1[7] = v66 - ((v66 + 0x1000000) & 0xFE000000);
  a1[8] = v67 - ((v67 + 0x2000000) & 0xFC000000);
  a1[9] = v68 - ((v68 + 0x1000000) & 0xFE000000);
  return result;
}

uint64_t fe_isnegative(_DWORD *a1)
{
  uint64_t v3 = *MEMORY[0x263EF8C08];
  fe_tobytes((uint64_t)v2, a1);
  return v2[0] & 1;
}

uint64_t fe_tobytes(uint64_t result, _DWORD *a2)
{
  int v2 = a2[1];
  int v3 = a2[2];
  int v4 = a2[3];
  int v5 = a2[4];
  int v6 = a2[5];
  int v7 = a2[6];
  int v8 = a2[7];
  int v9 = a2[8];
  int v10 = a2[9];
  int v11 = *a2
      + 19
      * ((v10
        + ((v9
          + ((v8
            + ((v7
              + ((v6
                + ((v5 + ((v4 + ((v3 + ((v2 + ((*a2 + ((19 * v10 + 0x1000000) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25);
  unsigned int v12 = v2 + (v11 >> 26);
  unsigned int v13 = v3 + ((int)v12 >> 25);
  unsigned int v14 = v4 + ((int)v13 >> 26);
  unsigned int v15 = v5 + ((int)v14 >> 25);
  int v16 = v6 + ((int)v15 >> 26);
  unsigned int v17 = v7 + (v16 >> 25);
  unsigned int v18 = v8 + ((int)v17 >> 26);
  unsigned int v19 = v9 + ((int)v18 >> 25);
  unsigned int v20 = v10 + ((int)v19 >> 26);
  *(_WORD *)uint64_t result = v11;
  *(unsigned char *)(result + 2) = BYTE2(v11);
  *(unsigned char *)(result + 3) = HIBYTE(v11) & 3 | (4 * v12);
  *(unsigned char *)(result + 4) = v12 >> 6;
  *(unsigned char *)(result + 5) = v12 >> 14;
  *(unsigned char *)(result + 6) = (v12 >> 22) & 7 | (8 * v13);
  *(unsigned char *)(result + 7) = v13 >> 5;
  *(unsigned char *)(result + 8) = v13 >> 13;
  *(unsigned char *)(result + 9) = (v13 >> 21) & 0x1F | (32 * v14);
  *(unsigned char *)(result + 10) = v14 >> 3;
  *(unsigned char *)(result + 11) = v14 >> 11;
  *(unsigned char *)(result + 12) = (v14 >> 19) & 0x3F | ((_BYTE)v15 << 6);
  *(unsigned char *)(result + 13) = v15 >> 2;
  *(unsigned char *)(result + 14) = v15 >> 10;
  *(unsigned char *)(result + 15) = v15 >> 18;
  *(_WORD *)(result + 16) = v16;
  *(unsigned char *)(result + 18) = BYTE2(v16);
  *(unsigned char *)(result + 19) = HIBYTE(v16) & 1 | (2 * v17);
  *(unsigned char *)(result + 20) = v17 >> 7;
  *(unsigned char *)(result + 21) = v17 >> 15;
  *(unsigned char *)(result + 22) = (v17 >> 23) & 7 | (8 * v18);
  *(unsigned char *)(result + 23) = v18 >> 5;
  *(unsigned char *)(result + 24) = v18 >> 13;
  *(unsigned char *)(result + 25) = (v18 >> 21) & 0xF | (16 * v19);
  *(unsigned char *)(result + 26) = v19 >> 4;
  *(unsigned char *)(result + 27) = v19 >> 12;
  *(unsigned char *)(result + 28) = (v19 >> 20) & 0x3F | ((_BYTE)v20 << 6);
  *(unsigned char *)(result + 29) = v20 >> 2;
  *(unsigned char *)(result + 30) = v20 >> 10;
  *(unsigned char *)(result + 31) = (v20 >> 18) & 0x7F;
  return result;
}

uint64_t fe_isnonzero(_DWORD *a1)
{
  uint64_t v3 = *MEMORY[0x263EF8C08];
  fe_tobytes((uint64_t)v2, a1);
  return crypto_verify_32(v2, zero);
}

uint64_t crypto_verify_32(int8x16_t *a1, int8x16_t *a2)
{
  int8x16_t v2 = vorrq_s8(veorq_s8(*a2, *a1), veorq_s8(a2[1], a1[1]));
  *(int8x8_t *)v2.i8 = vorr_s8(*(int8x8_t *)v2.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL));
  return ((((v2.i8[0] | v2.i8[4] | ((v2.i32[0] | v2.i32[1]) >> 16) | ((unsigned __int16)(v2.i16[0] | v2.i16[2] | ((v2.i32[0] | v2.i32[1]) >> 16)) >> 8))
          - 1) >> 8) & 1)
       - 1;
}

_DWORD *fe_frombytes(_DWORD *result, unsigned int *a2)
{
  uint64_t v2 = *((unsigned __int8 *)a2 + 6);
  int v3 = (*((unsigned __int8 *)a2 + 4) << 6) | (*((unsigned __int8 *)a2 + 5) << 14) | (v2 << 22);
  uint64_t v4 = *((unsigned __int8 *)a2 + 12);
  uint64_t v5 = *((unsigned __int8 *)a2 + 25);
  unint64_t v6 = (unint64_t)(*((unsigned char *)a2 + 31) & 0x7F) << 18;
  int v7 = v6 | (*((unsigned __int8 *)a2 + 30) << 10) | (4 * *((unsigned __int8 *)a2 + 29));
  v6 += 0x1000000;
  uint64_t v8 = a2[4];
  uint64_t v9 = *a2 + 19 * (v6 >> 25);
  unint64_t v10 = (v2 << 22) + 0x1000000;
  unint64_t v11 = v8 + 0x1000000;
  unint64_t v12 = ((32 * *((unsigned __int8 *)a2 + 7)) | ((unint64_t)*((unsigned __int8 *)a2 + 8) << 13) | ((unint64_t)*((unsigned __int8 *)a2 + 9) << 21))
      + (v10 >> 25);
  LODWORD(v10) = v3 - (v10 & 0x7E000000) + ((unint64_t)(v9 + 0x2000000) >> 26);
  int v13 = v9 - ((v9 + 0x2000000) & 0xFC000000);
  int v14 = ((v12 + 0x2000000) >> 26)
      + ((8 * *((unsigned __int8 *)a2 + 10)) | (*((unsigned __int8 *)a2 + 11) << 11) | (v4 << 19));
  unint64_t v15 = (v4 << 19) + 0x1000000;
  int v16 = v14 - (v15 & 0xE000000);
  unint64_t v17 = ((4 * *((unsigned __int8 *)a2 + 13)) | ((unint64_t)*((unsigned __int8 *)a2 + 14) << 10) | ((unint64_t)*((unsigned __int8 *)a2 + 15) << 18))
      + (v15 >> 25);
  LODWORD(v9) = v8 - ((v8 + 0x1000000) & 0xFE000000) + ((v17 + 0x2000000) >> 26);
  uint64_t v18 = *((unsigned __int8 *)a2 + 26);
  unint64_t v19 = (((unint64_t)*((unsigned __int8 *)a2 + 20) << 7) | ((unint64_t)*((unsigned __int8 *)a2 + 21) << 15) | ((unint64_t)*((unsigned __int8 *)a2 + 22) << 23))
      + (v11 >> 25);
  int v20 = ((v19 + 0x2000000) >> 26)
      + ((32 * *((unsigned __int8 *)a2 + 23)) | (*((unsigned __int8 *)a2 + 24) << 13) | (v5 << 21));
  uint64_t v21 = *((unsigned __int8 *)a2 + 27);
  uint64_t v22 = *((unsigned __int8 *)a2 + 28);
  unint64_t v23 = (v5 << 21) + 0x1000000;
  int v24 = v20 - (v23 & 0x3E000000);
  *uint64_t result = v13;
  result[1] = v10;
  uint64_t v25 = ((16 * v18) | (v21 << 12) | (v22 << 20)) + (v23 >> 25);
  result[2] = v12 - ((v12 + 0x2000000) & 0xFC000000);
  result[3] = v16;
  result[4] = v17 - ((v17 + 0x2000000) & 0xFC000000);
  result[5] = v9;
  result[6] = v19 - ((v19 + 0x2000000) & 0xFC000000);
  result[7] = v24;
  result[8] = v25 - ((v25 + 0x2000000) & 0xFC000000);
  result[9] = v7 + ((unint64_t)(v25 + 0x2000000) >> 26) - (v6 & 0x2000000);
  return result;
}

int32x4_t fe_neg(uint64_t a1, uint64_t a2)
{
  int32x4_t result = vnegq_s32(*(int32x4_t *)a2);
  int32x4_t v3 = vnegq_s32(*(int32x4_t *)(a2 + 16));
  int32x2_t v4 = vneg_s32(*(int32x2_t *)(a2 + 32));
  *(int32x4_t *)a1 = result;
  *(int32x4_t *)(a1 + 16) = v3;
  *(int32x2_t *)(a1 + 32) = v4;
  return result;
}

uint64_t fe_pow22523(_DWORD *a1, int *a2)
{
  uint64_t v18 = *MEMORY[0x263EF8C08];
  uint64_t v17 = 0;
  memset(v16, 0, sizeof(v16));
  uint64_t v15 = 0;
  memset(v14, 0, sizeof(v14));
  fe_sq(v16, a2);
  fe_sq(v14, (int *)v16);
  fe_sq(v14, (int *)v14);
  fe_mul(v14, a2, (int *)v14);
  fe_mul(v16, (int *)v16, (int *)v14);
  fe_sq(v16, (int *)v16);
  fe_mul(v16, (int *)v14, (int *)v16);
  fe_sq(v14, (int *)v16);
  int v4 = 4;
  do
  {
    fe_sq(v14, (int *)v14);
    --v4;
  }
  while (v4);
  fe_mul(v16, (int *)v14, (int *)v16);
  fe_sq(v14, (int *)v16);
  int v5 = 9;
  do
  {
    fe_sq(v14, (int *)v14);
    --v5;
  }
  while (v5);
  uint64_t v13 = 0;
  memset(v12, 0, sizeof(v12));
  fe_mul(v14, (int *)v14, (int *)v16);
  fe_sq(v12, (int *)v14);
  int v6 = 19;
  do
  {
    fe_sq(v12, (int *)v12);
    --v6;
  }
  while (v6);
  fe_mul(v14, (int *)v12, (int *)v14);
  fe_sq(v14, (int *)v14);
  int v7 = 9;
  do
  {
    fe_sq(v14, (int *)v14);
    --v7;
  }
  while (v7);
  fe_mul(v16, (int *)v14, (int *)v16);
  fe_sq(v14, (int *)v16);
  int v8 = 49;
  do
  {
    fe_sq(v14, (int *)v14);
    --v8;
  }
  while (v8);
  fe_mul(v14, (int *)v14, (int *)v16);
  fe_sq(v12, (int *)v14);
  int v9 = 99;
  do
  {
    fe_sq(v12, (int *)v12);
    --v9;
  }
  while (v9);
  fe_mul(v14, (int *)v12, (int *)v14);
  fe_sq(v14, (int *)v14);
  int v10 = 49;
  do
  {
    fe_sq(v14, (int *)v14);
    --v10;
  }
  while (v10);
  fe_mul(v16, (int *)v14, (int *)v16);
  fe_sq(v16, (int *)v16);
  fe_sq(v16, (int *)v16);
  return fe_mul(a1, (int *)v16, a2);
}

_DWORD *fe_sq2(_DWORD *result, int *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  uint64_t v4 = a2[4];
  uint64_t v5 = a2[5];
  uint64_t v7 = a2[6];
  uint64_t v6 = a2[7];
  uint64_t v8 = 19 * (int)v7;
  uint64_t v9 = a2[2];
  uint64_t v10 = a2[3];
  uint64_t v12 = a2[8];
  uint64_t v11 = a2[9];
  uint64_t v13 = 2 * v2;
  uint64_t v14 = 2 * v3;
  uint64_t v15 = 2 * v9;
  uint64_t v16 = 38 * (int)v6;
  uint64_t v17 = 2 * v10;
  uint64_t v18 = 2 * v5;
  uint64_t v19 = 19 * (int)v12;
  uint64_t v20 = 38 * (int)v11;
  uint64_t v21 = 2 * v2 * v3;
  uint64_t v22 = 38 * (int)v5 * (uint64_t)(int)v5 + (int)v2 * (uint64_t)(int)v2 + v8 * 2 * v4;
  uint64_t v23 = 2 * v3 * v3 + v9 * v13 + v8 * v7;
  uint64_t v24 = v21 + v8 * 2 * v5 + v16 * v4 + v19 * 2 * v10 + v20 * v9;
  uint64_t v25 = 2 * v10 * v14 + (int)v9 * (uint64_t)(int)v9;
  uint64_t v26 = v22 + v16 * 2 * v10;
  uint64_t v27 = v23 + v16 * 2 * v5;
  uint64_t v28 = v14 * v9 + v10 * v13 + v16 * v7;
  uint64_t v29 = v25 + v4 * v13 + v16 * v6 + 2 * v7 * v19;
  uint64_t v30 = v4 * v15 + 2 * v10 * v10;
  uint64_t v31 = v27 + v19 * 2 * v4;
  uint64_t v32 = v28 + v19 * 2 * v5;
  uint64_t v33 = v15 * v10 + v4 * v14 + v5 * v13 + v19 * 2 * v6;
  uint64_t v34 = v30 + 2 * v5 * v14 + v7 * v13 + v19 * v12;
  uint64_t v35 = 2 * v4 * v5;
  uint64_t v36 = v17 * v4 + v5 * v15;
  uint64_t v37 = v32 + v20 * v4;
  uint64_t v38 = v29 + v20 * v18;
  uint64_t v39 = v7 * v15 + (int)v4 * (uint64_t)(int)v4 + v18 * v17;
  uint64_t v40 = v31 + v20 * v17;
  uint64_t v41 = v35 + v7 * v17;
  uint64_t v42 = v33 + v20 * v7;
  uint64_t v43 = v36 + v7 * v14;
  uint64_t v44 = v26 + v19 * v15 + v20 * v14;
  uint64_t v45 = v34 + v20 * 2 * v6;
  uint64_t v46 = 2 * v44 + 0x2000000;
  uint64_t v47 = (v46 >> 26) + 2 * v24;
  uint64_t v48 = v43 + v6 * v13 + v20 * v12;
  uint64_t v49 = v39 + 2 * v6 * v14 + v12 * v13;
  unint64_t v50 = 2 * v44 - (v46 & 0xFFFFFFFFFC000000);
  uint64_t v51 = 2 * v38 + 0x2000000;
  uint64_t v52 = v49 + v20 * v11;
  uint64_t v53 = (v51 >> 26) + 2 * v42;
  uint64_t v54 = v41 + v6 * v15 + v12 * v14;
  uint64_t v55 = ((v47 + 0x1000000) >> 25) + 2 * v40;
  uint64_t v56 = v54 + v11 * v13;
  uint64_t v57 = ((v53 + 0x1000000) >> 25) + 2 * v45;
  uint64_t v58 = ((v55 + 0x2000000) >> 26) + 2 * v37;
  uint64_t v59 = ((v57 + 0x2000000) >> 26) + 2 * v48;
  uint64_t v60 = ((v59 + 0x1000000) >> 25) + 2 * v52;
  uint64_t v61 = ((v60 + 0x2000000) >> 26) + 2 * v56;
  unint64_t v62 = v50 + 19 * ((v61 + 0x1000000) >> 25);
  *int32x4_t result = v62 - ((v62 + 0x2000000) & 0xFC000000);
  result[1] = v47 - ((v47 + 0x1000000) & 0xFE000000) + ((v62 + 0x2000000) >> 26);
  unint64_t v63 = 2 * v38 - (v51 & 0xFFFFFFFFFC000000) + ((v58 + 0x1000000) >> 25);
  result[2] = v55 - ((v55 + 0x2000000) & 0xFC000000);
  result[3] = v58 - ((v58 + 0x1000000) & 0xFE000000);
  result[4] = v63 - ((v63 + 0x2000000) & 0xFC000000);
  result[5] = v53 - ((v53 + 0x1000000) & 0xFE000000) + ((v63 + 0x2000000) >> 26);
  result[6] = v57 - ((v57 + 0x2000000) & 0xFC000000);
  result[7] = v59 - ((v59 + 0x1000000) & 0xFE000000);
  result[8] = v60 - ((v60 + 0x2000000) & 0xFC000000);
  result[9] = v61 - ((v61 + 0x1000000) & 0xFE000000);
  return result;
}

int32x4_t fe_sub(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int32x4_t result = vsubq_s32(*(int32x4_t *)a2, *(int32x4_t *)a3);
  int32x4_t v4 = vsubq_s32(*(int32x4_t *)(a2 + 16), *(int32x4_t *)(a3 + 16));
  int32x2_t v5 = vsub_s32(*(int32x2_t *)(a2 + 32), *(int32x2_t *)(a3 + 32));
  *(int32x4_t *)a1 = result;
  *(int32x4_t *)(a1 + 16) = v4;
  *(int32x2_t *)(a1 + 32) = v5;
  return result;
}

double ge_add(int *a1, uint64_t a2, int *a3)
{
  uint64_t v10 = *MEMORY[0x263EF8C08];
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  uint64_t v6 = a2 + 40;
  fe_add((uint64_t)a1, a2 + 40, a2);
  fe_sub((uint64_t)(a1 + 10), v6, a2);
  fe_mul(a1 + 20, a1, a3);
  fe_mul(a1 + 10, a1 + 10, a3 + 10);
  fe_mul(a1 + 30, a3 + 30, (int *)(a2 + 120));
  fe_mul(a1, (int *)(a2 + 80), a3 + 20);
  fe_add((uint64_t)v8, (uint64_t)a1, (uint64_t)a1);
  fe_sub((uint64_t)a1, (uint64_t)(a1 + 20), (uint64_t)(a1 + 10));
  fe_add((uint64_t)(a1 + 10), (uint64_t)(a1 + 20), (uint64_t)(a1 + 10));
  fe_add((uint64_t)(a1 + 20), (uint64_t)v8, (uint64_t)(a1 + 30));
  *(void *)&double result = fe_sub((uint64_t)(a1 + 30), (uint64_t)v8, (uint64_t)(a1 + 30)).u64[0];
  return result;
}

uint64_t ge_p3_to_cached(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2 + 40;
  fe_add(a1, a2 + 40, a2);
  fe_sub(a1 + 40, v4, a2);
  long long v5 = *(_OWORD *)(a2 + 96);
  uint64_t v6 = *(void *)(a2 + 112);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 96) = v5;
  *(void *)(a1 + 112) = v6;

  return fe_mul((_DWORD *)(a1 + 120), (int *)(a2 + 120), d2);
}

double ge_p3_dbl(_DWORD *a1, uint64_t a2)
{
  uint64_t v5 = 0;
  memset(v4, 0, sizeof(v4));
  ge_p3_to_p2((uint64_t)v4, a2);
  return ge_p2_dbl(a1, (int *)v4);
}

uint64_t ge_p1p1_to_p3(_DWORD *a1, int *a2)
{
  uint64_t v4 = a2 + 30;
  fe_mul(a1, a2, a2 + 30);
  fe_mul(a1 + 10, a2 + 10, a2 + 20);
  fe_mul(a1 + 20, a2 + 20, v4);

  return fe_mul(a1 + 30, a2, a2 + 10);
}

double ge_p2_dbl(_DWORD *a1, int *a2)
{
  uint64_t v7 = *MEMORY[0x263EF8C08];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  fe_sq(a1, a2);
  fe_sq(a1 + 20, a2 + 10);
  fe_sq2(a1 + 30, a2 + 20);
  fe_add((uint64_t)(a1 + 10), (uint64_t)a2, (uint64_t)(a2 + 10));
  fe_sq(v5, a1 + 10);
  fe_add((uint64_t)(a1 + 10), (uint64_t)(a1 + 20), (uint64_t)a1);
  fe_sub((uint64_t)(a1 + 20), (uint64_t)(a1 + 20), (uint64_t)a1);
  fe_sub((uint64_t)a1, (uint64_t)v5, (uint64_t)(a1 + 10));

  *(void *)&double result = fe_sub((uint64_t)(a1 + 30), (uint64_t)(a1 + 30), (uint64_t)(a1 + 20)).u64[0];
  return result;
}

double ge_sub(int *a1, uint64_t a2, int *a3)
{
  uint64_t v10 = *MEMORY[0x263EF8C08];
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  uint64_t v6 = a2 + 40;
  fe_add((uint64_t)a1, a2 + 40, a2);
  fe_sub((uint64_t)(a1 + 10), v6, a2);
  fe_mul(a1 + 20, a1, a3 + 10);
  fe_mul(a1 + 10, a1 + 10, a3);
  fe_mul(a1 + 30, a3 + 30, (int *)(a2 + 120));
  fe_mul(a1, (int *)(a2 + 80), a3 + 20);
  fe_add((uint64_t)v8, (uint64_t)a1, (uint64_t)a1);
  fe_sub((uint64_t)a1, (uint64_t)(a1 + 20), (uint64_t)(a1 + 10));
  fe_add((uint64_t)(a1 + 10), (uint64_t)(a1 + 20), (uint64_t)(a1 + 10));
  fe_sub((uint64_t)(a1 + 20), (uint64_t)v8, (uint64_t)(a1 + 30));
  *(void *)&double result = fe_add((uint64_t)(a1 + 30), (uint64_t)v8, (uint64_t)(a1 + 30)).u64[0];
  return result;
}

double ge_madd(int *a1, uint64_t a2, int *a3)
{
  uint64_t v10 = *MEMORY[0x263EF8C08];
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  uint64_t v6 = a2 + 40;
  fe_add((uint64_t)a1, a2 + 40, a2);
  fe_sub((uint64_t)(a1 + 10), v6, a2);
  fe_mul(a1 + 20, a1, a3);
  fe_mul(a1 + 10, a1 + 10, a3 + 10);
  fe_mul(a1 + 30, a3 + 20, (int *)(a2 + 120));
  fe_add((uint64_t)v8, a2 + 80, a2 + 80);
  fe_sub((uint64_t)a1, (uint64_t)(a1 + 20), (uint64_t)(a1 + 10));
  fe_add((uint64_t)(a1 + 10), (uint64_t)(a1 + 20), (uint64_t)(a1 + 10));
  fe_add((uint64_t)(a1 + 20), (uint64_t)v8, (uint64_t)(a1 + 30));
  *(void *)&double result = fe_sub((uint64_t)(a1 + 30), (uint64_t)v8, (uint64_t)(a1 + 30)).u64[0];
  return result;
}

uint64_t ge_p1p1_to_p2(_DWORD *a1, int *a2)
{
  uint64_t v4 = a2 + 30;
  fe_mul(a1, a2, a2 + 30);
  uint64_t v5 = a2 + 10;
  uint64_t v6 = a2 + 20;
  fe_mul(a1 + 10, v5, v6);

  return fe_mul(a1 + 20, v6, v4);
}

__n128 ge_p3_to_p2(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 16);
  uint64_t v3 = *(void *)(a2 + 32);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v2;
  *(void *)(a1 + 32) = v3;
  long long v4 = *(_OWORD *)(a2 + 56);
  uint64_t v5 = *(void *)(a2 + 72);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = v4;
  *(void *)(a1 + 72) = v5;
  __n128 result = *(__n128 *)(a2 + 80);
  long long v7 = *(_OWORD *)(a2 + 96);
  uint64_t v8 = *(void *)(a2 + 112);
  *(__n128 *)(a1 + 80) = result;
  *(_OWORD *)(a1 + 96) = v7;
  *(void *)(a1 + 112) = v8;
  return result;
}

uint64_t ge_p3_tobytes(uint64_t a1, int *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8C08];
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  fe_invert(v9, a2 + 20);
  fe_mul(v7, a2, (int *)v9);
  fe_mul(v5, a2 + 10, (int *)v9);
  fe_tobytes(a1, v5);
  uint64_t result = fe_tobytes((uint64_t)v11, v7);
  *(unsigned char *)(a1 + 31) ^= v11[0] << 7;
  return result;
}

double ge_p3_0(uint64_t a1)
{
  *(void *)(a1 + 32) = 0;
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 40) = 1;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_OWORD *)(a1 + 60) = 0u;
  *(void *)(a1 + 76) = 0x100000000;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 100) = 0u;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  return result;
}

uint64_t ge_scalarmult_base(_DWORD *a1, int8x16_t *a2)
{
  *((void *)a1 + 4) = 0;
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  a1[10] = 1;
  *(_OWORD *)(a1 + 11) = 0u;
  *(_OWORD *)(a1 + 15) = 0u;
  *(void *)(a1 + 19) = 0x100000000;
  *(_OWORD *)(a1 + 21) = 0u;
  *(_OWORD *)(a1 + 25) = 0u;
  *(_OWORD *)(a1 + 29) = 0u;
  *(_OWORD *)(a1 + 33) = 0u;
  *((_OWORD *)a1 + 9) = 0u;
  return ge_scalarmult_base_internal(a1, a2);
}

uint64_t ge_scalarmult_base_internal(_DWORD *a1, int8x16_t *a2)
{
  uint64_t v3 = 0;
  uint64_t v25 = *MEMORY[0x263EF8C08];
  v4.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v4.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  do
  {
    int8x16_t v5 = *a2++;
    v26.val[0] = vandq_s8(v5, v4);
    v26.val[1] = (int8x16_t)vshrq_n_u8((uint8x16_t)v5, 4uLL);
    uint64_t v6 = &v23[v3];
    vst2q_s8(v6, v26);
    v3 += 32;
  }
  while (v3 != 64);
  uint64_t v7 = 0;
  int v8 = 0;
  do
  {
    int v9 = v23[v7] + v8;
    int v8 = (v9 + 8) << 24 >> 28;
    v23[v7++] = v9 - ((v9 + 8) & 0xF0);
  }
  while (v7 != 63);
  int v10 = 0;
  memset(v20, 0, sizeof(v20));
  memset(v16, 0, sizeof(v16));
  v24 += v8;
  unint64_t v11 = 1;
  uint64_t v17 = 0;
  do
  {
    ge_select((uint64_t)v16, v10, (char)v23[v11]);
    ge_madd((int *)v20, (uint64_t)a1, (int *)v16);
    ge_p1p1_to_p3(a1, (int *)v20);
    ++v10;
    BOOL v12 = v11 >= 0x3E;
    v11 += 2;
  }
  while (!v12);
  uint64_t v19 = 0;
  memset(v18, 0, sizeof(v18));
  uint64_t v22 = 0;
  memset(v21, 0, sizeof(v21));
  ge_p3_to_p2((uint64_t)v21, (uint64_t)a1);
  ge_p2_dbl(v20, (int *)v21);
  ge_p1p1_to_p2(v18, (int *)v20);
  ge_p2_dbl(v20, (int *)v18);
  ge_p1p1_to_p2(v18, (int *)v20);
  ge_p2_dbl(v20, (int *)v18);
  ge_p1p1_to_p2(v18, (int *)v20);
  ge_p2_dbl(v20, (int *)v18);
  ge_p1p1_to_p3(a1, (int *)v20);
  int v13 = 0;
  unint64_t v14 = 0;
  do
  {
    ge_select((uint64_t)v16, v13, (char)v23[v14]);
    ge_madd((int *)v20, (uint64_t)a1, (int *)v16);
    uint64_t result = ge_p1p1_to_p3(a1, (int *)v20);
    ++v13;
    BOOL v12 = v14 >= 0x3E;
    v14 += 2;
  }
  while (!v12);
  return result;
}

uint64_t ge_scalarmult_base_masked(uint64_t a1, int8x16_t *a2, void (**a3)(void, uint64_t, int8x16_t *))
{
  uint64_t v11 = *MEMORY[0x263EF8C08];
  uint64_t v6 = frandom(v10, a3);
  if (!v6)
  {
    uint64_t v9 = 0;
    (*a3)(a3, 8, (int8x16_t *)&v9);
    ccn_mux_seed_mask(v9);
    fe_frombytes((_DWORD *)(a1 + 80), (unsigned int *)v10);
    *(void *)(a1 + 32) = 0;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 120) = 0u;
    *(_OWORD *)(a1 + 136) = 0u;
    *(void *)(a1 + 152) = 0;
    long long v7 = *(_OWORD *)(a1 + 96);
    *(_OWORD *)(a1 + 40) = *(_OWORD *)(a1 + 80);
    *(_OWORD *)(a1 + 56) = v7;
    *(void *)(a1 + 72) = *(void *)(a1 + 112);
    ge_scalarmult_base_internal((_DWORD *)a1, a2);
  }
  return v6;
}

unsigned char *sc_muladd(unsigned char *a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  unsigned int v4 = *a2 | ((a2[1] & 0x1F) << 16);
  unint64_t v5 = *(unsigned int *)((char *)a2 + 15);
  unint64_t v6 = (v5 >> 24) | ((unint64_t)*((unsigned __int8 *)a2 + 19) << 8) | ((unint64_t)*((unsigned __int8 *)a2
                                                                                                + 20) << 16);
  unsigned int v7 = *(unsigned __int16 *)((char *)a2 + 21) | ((*((unsigned char *)a2 + 23) & 0x1F) << 16);
  unsigned int v8 = *a3 | ((a3[1] & 0x1F) << 16);
  unint64_t v9 = *(unsigned int *)((char *)a3 + 15);
  unint64_t v10 = (v9 >> 24) | ((unint64_t)*((unsigned __int8 *)a3 + 19) << 8) | ((unint64_t)*((unsigned __int8 *)a3
                                                                                                 + 20) << 16);
  unsigned int v11 = *(unsigned __int16 *)((char *)a3 + 21) | ((*((unsigned char *)a3 + 23) & 0x1F) << 16);
  unint64_t v12 = *(unsigned int *)((char *)a4 + 15);
  unint64_t v152 = (v12 >> 24) | ((unint64_t)*((unsigned __int8 *)a4 + 19) << 8) | ((unint64_t)*((unsigned __int8 *)a4 + 20) << 16);
  unint64_t v13 = ((unint64_t)*(unsigned int *)(a2 + 1) >> 5) & 0x1FFFFF;
  unint64_t v14 = ((unint64_t)(HIBYTE(*(_DWORD *)(a2 + 1)) | (*((unsigned __int8 *)a2 + 6) << 8) | (*((unsigned __int8 *)a2
                                                                                                 + 7) << 16)) >> 2) & 0x1FFFFF;
  unint64_t v15 = ((unint64_t)*(unsigned int *)(a3 + 1) >> 5) & 0x1FFFFF;
  unint64_t v16 = ((unint64_t)(HIBYTE(*(_DWORD *)(a3 + 1)) | (*((unsigned __int8 *)a3 + 6) << 8) | (*((unsigned __int8 *)a3
                                                                                                 + 7) << 16)) >> 2) & 0x1FFFFF;
  unint64_t v162 = v15 * v13
       + v8 * v14
       + v16 * v4
       + (((unint64_t)(HIBYTE(*(_DWORD *)(a4 + 1)) | (*((unsigned __int8 *)a4 + 6) << 8) | (*((unsigned __int8 *)a4 + 7) << 16)) >> 2) & 0x1FFFFF);
  unint64_t v17 = ((unint64_t)*(unsigned int *)((char *)a2 + 7) >> 7) & 0x1FFFFF;
  unint64_t v18 = ((unint64_t)*(unsigned int *)(a2 + 5) >> 4) & 0x1FFFFF;
  unint64_t v19 = ((unint64_t)*(unsigned int *)((char *)a3 + 7) >> 7) & 0x1FFFFF;
  unint64_t v20 = ((unint64_t)*(unsigned int *)(a3 + 5) >> 4) & 0x1FFFFF;
  unint64_t v21 = v15 * (unint64_t)v17
      + v8 * (unint64_t)v18
      + v19 * (unint64_t)v13
      + v4 * (unint64_t)v20
      + v16 * v14
      + (((unint64_t)*(unsigned int *)(a4 + 5) >> 4) & 0x1FFFFF);
  unint64_t v22 = ((unint64_t)(HIBYTE(*(_DWORD *)(a2 + 5)) | (*((unsigned __int8 *)a2 + 14) << 8) | (*((unsigned __int8 *)a2
                                                                                                  + 15) << 16)) >> 1) & 0x1FFFFF;
  uint64_t v23 = (v5 >> 6) & 0x1FFFFF;
  uint64_t v24 = (v9 >> 6) & 0x1FFFFF;
  unint64_t v25 = ((unint64_t)(HIBYTE(*(_DWORD *)(a3 + 5)) | (*((unsigned __int8 *)a3 + 14) << 8) | (*((unsigned __int8 *)a3
                                                                                                  + 15) << 16)) >> 1) & 0x1FFFFF;
  unint64_t v158 = v22 * v15
       + v8 * (unint64_t)v23
       + v19 * (unint64_t)v17
       + v14 * v20
       + v16 * (unint64_t)v18
       + v4 * (unint64_t)v24
       + v25 * (unint64_t)v13
       + ((v12 >> 6) & 0x1FFFFF);
  unint64_t v26 = v6 >> 3;
  v10 >>= 3;
  unint64_t v155 = (v6 >> 3) * (unint64_t)v15
       + v8 * (unint64_t)v7
       + v22 * (unint64_t)v19
       + v20 * (unint64_t)v18
       + v16 * (unint64_t)v23
       + v14 * v24
       + v25 * (unint64_t)v17
       + v10 * (unint64_t)v13
       + v11 * (unint64_t)v4
       + *(unsigned __int16 *)((char *)a4 + 21)
       + ((unint64_t)(*((unsigned char *)a4 + 23) & 0x1F) << 16);
  unint64_t v27 = ((unint64_t)*(unsigned int *)((char *)a2 + 23) >> 5) & 0x1FFFFF;
  unint64_t v28 = ((unint64_t)(HIBYTE(*(_DWORD *)((char *)a2 + 23)) | (*((unsigned __int8 *)a2 + 27) << 8) | (*((unsigned __int8 *)a2 + 28) << 16)) >> 2) & 0x1FFFFF;
  unint64_t v29 = ((unint64_t)*(unsigned int *)((char *)a3 + 23) >> 5) & 0x1FFFFF;
  unint64_t v30 = ((unint64_t)(HIBYTE(*(_DWORD *)((char *)a3 + 23)) | (*((unsigned __int8 *)a3 + 27) << 8) | (*((unsigned __int8 *)a3 + 28) << 16)) >> 2) & 0x1FFFFF;
  unint64_t v154 = v15 * v27
       + v8 * v28
       + v26 * (unint64_t)v19
       + v20 * (unint64_t)v23
       + v16 * (unint64_t)v7
       + v24 * (unint64_t)v18
       + v25 * (unint64_t)v22
       + v10 * (unint64_t)v17
       + v29 * (unint64_t)v13
       + v11 * v14
       + v30 * v4
       + (((unint64_t)(HIBYTE(*(_DWORD *)((char *)a4 + 23)) | (*((unsigned __int8 *)a4 + 27) << 8) | (*((unsigned __int8 *)a4 + 28) << 16)) >> 2) & 0x1FFFFF);
  unint64_t v31 = (*a4 | ((unint64_t)(a4[1] & 0x1F) << 16)) + v8 * (unint64_t)v4;
  unint64_t v32 = v4 * (unint64_t)v15
      + v8 * (unint64_t)v13
      + (((unint64_t)*(unsigned int *)(a4 + 1) >> 5) & 0x1FFFFF)
      + ((v31 + 0x100000) >> 21);
  unint64_t v159 = v31 - ((v31 + 0x100000) & 0xFFFFFE00000);
  unint64_t v156 = v14 * (unint64_t)v15
       + v8 * (unint64_t)v17
       + v4 * (unint64_t)v19
       + v16 * (unint64_t)v13
       + (((unint64_t)*(unsigned int *)((char *)a4 + 7) >> 7) & 0x1FFFFF);
  unint64_t v161 = v15 * (unint64_t)v18
       + v8 * (unint64_t)v22
       + v14 * (unint64_t)v19
       + v20 * (unint64_t)v13
       + v16 * (unint64_t)v17
       + v25 * (unint64_t)v4
       + (((unint64_t)(HIBYTE(*(_DWORD *)(a4 + 5)) | (*((unsigned __int8 *)a4 + 14) << 8) | (*((unsigned __int8 *)a4 + 15) << 16)) >> 1) & 0x1FFFFF)
       + ((v21 + 0x100000) >> 21);
  unint64_t v149 = v15 * (unint64_t)v23
       + v8 * (unint64_t)v26
       + v19 * (unint64_t)v18
       + v20 * (unint64_t)v17
       + v16 * (unint64_t)v22
       + v24 * (unint64_t)v13
       + v25 * (unint64_t)v14
       + v10 * (unint64_t)v4
       + (v152 >> 3);
  unint64_t v148 = v7 * (unint64_t)v15
       + v8 * (unint64_t)v27
       + v19 * (unint64_t)v23
       + v22 * (unint64_t)v20
       + v16 * (unint64_t)v26
       + v24 * (unint64_t)v17
       + v25 * (unint64_t)v18
       + v10 * (unint64_t)v14
       + v4 * (unint64_t)v29
       + v11 * (unint64_t)v13
       + (((unint64_t)*(unsigned int *)((char *)a4 + 23) >> 5) & 0x1FFFFF);
  unint64_t v33 = (unint64_t)*((unsigned int *)a2 + 7) >> 7;
  unint64_t v34 = (unint64_t)*((unsigned int *)a3 + 7) >> 7;
  unint64_t v143 = v15 * (unint64_t)v33
       + v19 * (unint64_t)v27
       + v7 * (unint64_t)v20
       + v16 * (unint64_t)v28
       + v24 * (unint64_t)v23
       + v25 * (unint64_t)v26
       + v10 * (unint64_t)v22
       + v29 * (unint64_t)v17
       + v11 * (unint64_t)v18
       + v34 * (unint64_t)v13;
  unint64_t v147 = v28 * (unint64_t)v15
       + v8 * (unint64_t)v33
       + v7 * (unint64_t)v19
       + v26 * (unint64_t)v20
       + v16 * (unint64_t)v27
       + v22 * (unint64_t)v24
       + v25 * (unint64_t)v23
       + v10 * (unint64_t)v18
       + v14 * (unint64_t)v29
       + v11 * (unint64_t)v17
       + v4 * (unint64_t)v34
       + v30 * (unint64_t)v13
       + ((unint64_t)*((unsigned int *)a4 + 7) >> 7);
  unint64_t v144 = v28 * (unint64_t)v19
       + v20 * (unint64_t)v27
       + v16 * (unint64_t)v33;
  unsigned int v35 = v11;
  unint64_t v36 = v10 * (unint64_t)v33
      + v29 * (unint64_t)v27
      + v11 * (unint64_t)v28
      + v26 * (unint64_t)v34
      + v30 * (unint64_t)v7;
  unint64_t v37 = v28 * (unint64_t)v29
      + v11 * (unint64_t)v33
      + v7 * (unint64_t)v34
      + v30 * (unint64_t)v27
      + ((v36 + 0x100000) >> 21);
  unint64_t v142 = v36 - ((v36 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v38 = v29 * (unint64_t)v33
      + v34 * (unint64_t)v27
      + v30 * (unint64_t)v28;
  unint64_t v39 = v28 * (unint64_t)v34
      + v30 * (unint64_t)v33
      + ((v38 + 0x100000) >> 21);
  unint64_t v40 = v38 - ((v38 + 0x100000) & 0x1FFFFFFE00000);
  unint64_t v41 = v34 * (unint64_t)v33;
  unint64_t v150 = v32 + 0x100000;
  unint64_t v151 = v32 - ((v32 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v42 = v156 + ((v162 + 0x100000) >> 21);
  unint64_t v157 = v21 - ((v21 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v42 + 0x100000) >> 21);
  unint64_t v153 = v42 - ((v42 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v43 = v19 * (unint64_t)v33
      + v28 * (unint64_t)v20;
  unint64_t v44 = v20 * (unint64_t)v33;
  unint64_t v45 = v28 * (unint64_t)v24
      + v25 * (unint64_t)v33
      + v10 * (unint64_t)v27
      + v26 * (unint64_t)v29
      + v35 * (unint64_t)v7
      + v22 * (unint64_t)v34
      + v30 * (unint64_t)v23;
  LODWORD(v36) = v7;
  unint64_t v46 = v24 * (unint64_t)v33
      + v10 * (unint64_t)v28
      + v7 * (unint64_t)v29
      + v35 * (unint64_t)v27
      + v34 * (unint64_t)v23
      + v30 * (unint64_t)v26
      + ((v45 + 0x100000) >> 21);
  unint64_t v47 = v142 + ((v46 + 0x100000) >> 21);
  unint64_t v146 = v46 - ((v46 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v48 = v43 + v7 * (unint64_t)v24 + v25 * (unint64_t)v27;
  unint64_t v49 = v44 + v24 * (unint64_t)v27;
  unint64_t v50 = v144 + v26 * (unint64_t)v24;
  unint64_t v51 = v40 + ((v37 + 0x100000) >> 21);
  unint64_t v52 = v37 - ((v37 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v53 = v41 - ((v41 + 0x100000) & 0x7FFFFFFE00000) + ((v39 + 0x100000) >> 21);
  unint64_t v54 = v39 - ((v39 + 0x100000) & 0x1FFFFFFE00000);
  unint64_t v55 = v50 + v25 * (unint64_t)v36;
  unint64_t v56 = (v41 + 0x100000) >> 21;
  unint64_t v145 = v45 - 683901 * (int)v56 - ((v45 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v57 = v55
      + v10 * (unint64_t)v23
      + v29 * (unint64_t)v18
      + v35 * (unint64_t)v22;
  unint64_t v58 = v143 + v30 * (unint64_t)v14;
  unint64_t v59 = v48
      + v10 * (unint64_t)v26
      + v22 * (unint64_t)v29
      + v35 * (unint64_t)v23
      + v34 * (unint64_t)v17
      + v30 * (unint64_t)v18;
  unint64_t v60 = v49
      + v25 * (unint64_t)v28
      + v10 * (unint64_t)v36
      + v29 * (unint64_t)v23
      + v35 * (unint64_t)v26
      + v34 * (unint64_t)v18
      + v30 * (unint64_t)v22
      + ((v59 + 0x100000) >> 21);
  unint64_t v61 = 654183 * v53 + 470296 * v56 - 997805 * v54 + v58;
  v58 += 0x100000;
  unint64_t v62 = v57
      + v14 * (unint64_t)v34
      + v30 * (unint64_t)v17
      + (v58 >> 21);
  unint64_t v63 = v61 + 136657 * v51 - 683901 * v52 - (v58 & 0xFFFFFFFFFFE00000);
  unint64_t v64 = v149 + ((v158 + 0x100000) >> 21);
  unint64_t v65 = v148 + ((v155 + 0x100000) >> 21);
  unint64_t v66 = 666643 * v51
      + 470296 * v52
      + 654183 * v47
      + ((v64 + 0x100000) >> 21)
      + v155
      - ((v155 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v67 = v147 + ((v154 + 0x100000) >> 21);
  unint64_t v68 = 666643 * v53
      + 470296 * v54
      + 654183 * v51
      - 997805 * v52
      + 136657 * v47
      + ((v65 + 0x100000) >> 21)
      + v154
      - ((v154 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v69 = v158 + 666643 * v47 - ((v158 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v161 + 0x100000) >> 21);
  unint64_t v70 = 666643 * v52
      + 470296 * v47
      + v64
      + ((uint64_t)(v69 + 0x100000) >> 21)
      - ((v64 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v71 = 666643 * v54 + 470296 * v51 + 654183 * v52 - 997805 * v47 + v65 - ((v65 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v72 = v63 + ((v67 + 0x100000) >> 21);
  unint64_t v73 = 470296 * v53
      + 666643 * v56
      + 654183 * v54
      - 997805 * v51
      + 136657 * v52
      - 683901 * v47
      + v67
      - ((v67 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v74 = -997805 * v53 + 654183 * v56 + 136657 * v54 - 683901 * v51 + v62;
  v62 += 0x100000;
  unint64_t v75 = v59
      - 997805 * (int)v56
      + 136657 * v53
      - 683901 * v54
      - ((v59 + 0x100000) & 0xFFFFFFFFFFE00000)
      + (v62 >> 21);
  unint64_t v76 = v74 - (v62 & 0xFFFFFFFFFFE00000) + ((uint64_t)(v72 + 0x100000) >> 21);
  unint64_t v77 = v72 - ((v72 + 0x100000) & 0xFFFFFFFFFFE00000);
  uint64_t v78 = -683901 * v53 + 136657 * v56;
  unint64_t v79 = v145 + ((v60 + 0x100000) >> 21);
  unint64_t v80 = v73 + ((uint64_t)(v68 + 0x100000) >> 21);
  unint64_t v81 = v78 + v60 - ((v60 + 0x100000) & 0xFFFFFFFFFFE00000) + ((uint64_t)(v75 + 0x100000) >> 21);
  unint64_t v82 = v146 + ((uint64_t)(v79 + 0x100000) >> 21);
  unint64_t v83 = v77 + ((uint64_t)(v80 + 0x100000) >> 21);
  unint64_t v84 = v80 - ((v80 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v85 = v75 - ((v75 + 0x100000) & 0xFFFFFFFFFFE00000) + ((uint64_t)(v76 + 0x100000) >> 21);
  unint64_t v86 = v76 - ((v76 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v87 = v79 - ((v79 + 0x100000) & 0xFFFFFFFFFFE00000) + ((uint64_t)(v81 + 0x100000) >> 21);
  unint64_t v88 = v81 - ((v81 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v89 = v71 + ((uint64_t)(v66 + 0x100000) >> 21);
  unint64_t v90 = -683901 * v82 + ((uint64_t)(v89 + 0x100000) >> 21) + v68 - ((v68 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v91 = -997805 * v82
      + 136657 * v87
      - 683901 * v88
      + ((uint64_t)(v70 + 0x100000) >> 21)
      + v66
      - ((v66 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v92 = v69 + 470296 * v82 - ((v69 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v93 = v159 + 666643 * v83;
  uint64_t v94 = v151 + 470296 * v83 + 666643 * v86 + ((uint64_t)(v93 + 0x100000) >> 21);
  unint64_t v95 = v161 + 666643 * v82 - ((v161 + 0x100000) & 0xFFFFFFFFFFE00000);
  uint64_t v96 = v92 + 654183 * v87 - 997805 * v88 + 136657 * v85 - 683901 * v86;
  unint64_t v97 = 654183 * v82
      - 997805 * v87
      + 136657 * v88
      + v70
      - ((v70 + 0x100000) & 0xFFFFFFFFFFE00000)
      - 683901 * v85
      + ((v96 + 0x100000) >> 21);
  unint64_t v98 = 136657 * v82
      - 683901 * v87
      + v89
      - ((v89 + 0x100000) & 0xFFFFFFFFFFE00000)
      + ((uint64_t)(v91 + 0x100000) >> 21);
  unint64_t v99 = v84 + ((uint64_t)(v90 + 0x100000) >> 21);
  uint64_t v100 = v94 + 0x100000;
  uint64_t v101 = v98 + 0x100000;
  unint64_t v102 = v98 - ((v98 + 0x100000) & 0xFFFFFFFFFFE00000);
  uint64_t v103 = (uint64_t)(v99 + 0x100000) >> 21;
  unint64_t v104 = v94 + 470296 * v103 - ((v94 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v105 = v162 + (v150 >> 21) - ((v162 + 0x100000) & 0xFFFFFFFFFFE00000) + 654183 * v83 + 666643 * v85 + 470296 * v86;
  uint64_t v106 = v153 + 666643 * v88 - 997805 * v83 + 470296 * v85 + 654183 * v86 + ((uint64_t)(v105 + 0x100000) >> 21);
  uint64_t v107 = v106 + 0x100000;
  unint64_t v108 = v105 + 654183 * v103 - ((v105 + 0x100000) & 0xFFFFFFFFFFE00000) + (v100 >> 21);
  unint64_t v109 = v106 - 997805 * v103 - ((v106 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v110 = v157 + 666643 * v87;
  uint64_t v111 = v95 + 470296 * v87 + 654183 * v88;
  uint64_t v112 = v110 + 470296 * v88 + 136657 * v83;
  uint64_t v113 = v111 - 683901 * v83 - 997805 * v85;
  uint64_t v114 = v112 + 654183 * v85 - 997805 * v86;
  uint64_t v115 = v113 + 136657 * v86 + ((v114 + 0x100000) >> 21);
  unint64_t v116 = v90 + (v101 >> 21) - ((v90 + 0x100000) & 0xFFFFFFFFFFE00000);
  int64_t v117 = v93 - ((v93 + 0x100000) & 0xFFFFFFFFFFE00000) + 666643 * v103;
  uint64_t v118 = v104 + (v117 >> 21);
  uint64_t v119 = v108 + (v118 >> 21);
  uint64_t v120 = v109 + (v119 >> 21);
  int64_t v121 = v114 + 136657 * v103 - ((v114 + 0x100000) & 0xFFFFFFFFFFE00000) + (v107 >> 21) + (v120 >> 21);
  int64_t v122 = v115 - 683901 * v103 - ((v115 + 0x100000) & 0xFFFFFFFFFFE00000) + (v121 >> 21);
  int64_t v123 = v96 - ((v96 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v115 + 0x100000) >> 21) + (v122 >> 21);
  int64_t v124 = v97 - ((v97 + 0x100000) & 0xFFFFFFFFFFE00000) + (v123 >> 21);
  int64_t v125 = v91 - ((v91 + 0x100000) & 0xFFFFFFFFFFE00000) + ((uint64_t)(v97 + 0x100000) >> 21) + (v124 >> 21);
  uint64_t v126 = v102 + (v125 >> 21);
  uint64_t v127 = v116 + (v126 >> 21);
  int64_t v128 = v99 - ((v99 + 0x100000) & 0xFFFFFFFFFFE00000) + (v127 >> 21);
  uint64_t v129 = (v117 & 0x1FFFFF) + 666643 * (v128 >> 21);
  uint64_t result = a1;
  a1[1] = (unsigned __int16)(v117 + 11283 * (v128 >> 21)) >> 8;
  uint64_t v131 = (v118 & 0x1FFFFF) + 470296 * (v128 >> 21) + (v129 >> 21);
  *a1 = v117 + 19 * (v128 >> 21);
  a1[2] = ((unint64_t)((v117 & 0x1FFFFF) + 666643 * (v128 >> 21)) >> 16) & 0x1F | (32 * (v118 + 24 * (v128 >> 21) + (v129 >> 21)));
  a1[3] = (unint64_t)v131 >> 3;
  a1[4] = (unint64_t)v131 >> 11;
  uint64_t v132 = (v119 & 0x1FFFFF) + 654183 * (v128 >> 21) + (v131 >> 21);
  a1[5] = (v131 >> 19) & 3 | (4 * (v119 + 103 * (v128 >> 21) + (v131 >> 21)));
  a1[6] = (unint64_t)v132 >> 6;
  uint64_t v133 = (v120 & 0x1FFFFF) - 997805 * (v128 >> 21) + (v132 >> 21);
  a1[7] = (v132 >> 14) & 0x7F | (((_BYTE)v120
                                              - -83 * (v128 >> 21)
                                              + (v132 >> 21)) << 7);
  a1[8] = (unint64_t)v133 >> 1;
  a1[9] = (unint64_t)v133 >> 9;
  uint64_t v134 = (v121 & 0x1FFFFF) + 136657 * (v128 >> 21) + (v133 >> 21);
  a1[10] = (v133 >> 17) & 0xF | (16 * (v121 - 47 * (v128 >> 21) + (v133 >> 21)));
  a1[11] = (unint64_t)v134 >> 4;
  a1[12] = (unint64_t)v134 >> 12;
  uint64_t v135 = (v122 & 0x1FFFFF) - 683901 * (v128 >> 21) + (v134 >> 21);
  a1[13] = ((v134 & 0x100000) != 0) | (2 * (v122 - 125 * (v128 >> 21) + (v134 >> 21)));
  a1[14] = (unint64_t)v135 >> 7;
  uint64_t v136 = (v123 & 0x1FFFFF) + (v135 >> 21);
  a1[15] = (v135 >> 15) & 0x3F | (((_BYTE)v123 + (v135 >> 21)) << 6);
  a1[16] = (unint64_t)v136 >> 2;
  a1[17] = (unint64_t)v136 >> 10;
  uint64_t v137 = (v124 & 0x1FFFFF) + (v136 >> 21);
  a1[18] = (v136 >> 18) & 7 | (8 * (v97 + (v123 >> 21) + (v136 >> 21)));
  a1[19] = (unint64_t)v137 >> 5;
  uint64_t v138 = (v125 & 0x1FFFFF) + (v137 >> 21);
  a1[20] = (unint64_t)v137 >> 13;
  a1[22] = (unsigned __int16)(v125 + (v137 >> 21)) >> 8;
  uint64_t v139 = (v126 & 0x1FFFFF) + (v138 >> 21);
  a1[21] = v138;
  a1[23] = BYTE2(v138) & 0x1F | (32 * (v126 + (v138 >> 21)));
  a1[24] = (unint64_t)v139 >> 3;
  a1[25] = (unint64_t)v139 >> 11;
  uint64_t v140 = (v127 & 0x1FFFFF) + (v139 >> 21);
  a1[26] = (v139 >> 19) & 3 | (4 * (v127 + (v139 >> 21)));
  a1[27] = (unint64_t)v140 >> 6;
  unint64_t v141 = (v128 & 0x1FFFFF) + (v140 >> 21);
  a1[28] = (v140 >> 14) & 0x7F | (((_BYTE)v99
                                               + (v127 >> 21)
                                               + (v140 >> 21)) << 7);
  a1[29] = v141 >> 1;
  a1[30] = v141 >> 9;
  a1[31] = v141 >> 17;
  return result;
}

unsigned __int16 *sc_reduce(unsigned __int16 *result)
{
  unint64_t v1 = *(unsigned int *)((char *)result + 15);
  unint64_t v2 = *((unsigned int *)result + 9);
  unint64_t v3 = (v2 >> 24) | ((unint64_t)*((unsigned __int8 *)result + 40) << 8) | ((unint64_t)*((unsigned __int8 *)result + 41) << 16);
  unint64_t v4 = ((unint64_t)(HIBYTE(*((_DWORD *)result + 11)) | (*((unsigned __int8 *)result + 48) << 8) | (*((unsigned __int8 *)result + 49) << 16)) >> 2) & 0x1FFFFF;
  unint64_t v5 = ((unint64_t)*(unsigned int *)((char *)result + 49) >> 7) & 0x1FFFFF;
  unint64_t v6 = ((unint64_t)*((unsigned int *)result + 13) >> 4) & 0x1FFFFF;
  unint64_t v7 = ((unint64_t)(HIBYTE(*((_DWORD *)result + 13)) | (*((unsigned __int8 *)result + 56) << 8) | (*((unsigned __int8 *)result + 57) << 16)) >> 1) & 0x1FFFFF;
  uint64_t v8 = ((v1 >> 6) & 0x1FFFFF) + 666643 * v4;
  unint64_t v9 = (*(unsigned __int16 *)((char *)result + 21) | ((unint64_t)(*((unsigned char *)result + 23) & 0x1F) << 16))
     + 470296 * v5
     + 666643 * v6
     + 654183 * v4;
  unint64_t v10 = (((v1 >> 24) | ((unint64_t)*((unsigned __int8 *)result + 19) << 8) | ((unint64_t)*((unsigned __int8 *)result + 20) << 16)) >> 3)
      + 666643 * v5
      + 470296 * v4
      + ((unint64_t)(v8 + 0x100000) >> 21);
  unint64_t v11 = (((unint64_t)*(unsigned int *)((char *)result + 23) >> 5) & 0x1FFFFF)
      + 654183 * v5
      + 470296 * v6
      - 997805 * (int)v4
      + 666643 * v7
      + ((v9 + 0x100000) >> 21);
  unint64_t v12 = (((unint64_t)(HIBYTE(*(_DWORD *)((char *)result + 23)) | (*((unsigned __int8 *)result + 27) << 8) | (*((unsigned __int8 *)result + 28) << 16)) >> 2) & 0x1FFFFF)
      - 997805 * (int)v5
      + 654183 * v6
      + 136657 * v4;
  unint64_t v13 = (((unint64_t)*((unsigned int *)result + 7) >> 7) & 0x1FFFFF)
      + 136657 * v5
      - 997805 * (int)v6
      - 683901 * (int)v4;
  unint64_t v14 = (((unint64_t)*(unsigned int *)((char *)result + 31) >> 4) & 0x1FFFFF)
      - 683901 * (int)v5
      + 136657 * v6;
  unint64_t v15 = (((unint64_t)(HIBYTE(*(_DWORD *)((char *)result + 31)) | (*((unsigned __int8 *)result + 35) << 8) | (*((unsigned __int8 *)result + 36) << 16)) >> 1) & 0x1FFFFF)
      - 683901 * (int)v6;
  unint64_t v16 = (unint64_t)*((unsigned int *)result + 15) >> 3;
  uint64_t v17 = ((v2 >> 6) & 0x1FFFFF) - 997805 * (int)v16;
  uint64_t v18 = (v3 >> 3) + 136657 * v16;
  unint64_t v19 = (result[21] | ((unint64_t)(result[22] & 0x1F) << 16)) - 683901 * (int)v16;
  unint64_t v20 = v14 + 470296 * v16;
  unint64_t v21 = v13 + 666643 * v16;
  unint64_t v22 = v15 + 654183 * v16;
  unint64_t v23 = ((unint64_t)*(unsigned int *)((char *)result + 57) >> 6) & 0x1FFFFF;
  uint64_t v24 = v18 - 683901 * (int)v23;
  uint64_t v25 = v17 + 136657 * v23 - 683901 * (int)v7;
  uint64_t v26 = v20 + 654183 * v23 - 997805 * (int)v7;
  uint64_t v27 = v12 + 666643 * v23 + 470296 * v7;
  unint64_t v28 = v21 + 470296 * v23;
  unint64_t v29 = v22 - 997805 * (int)v23;
  uint64_t v30 = v28 + 654183 * v7 + ((v27 + 0x100000) >> 21);
  uint64_t v31 = v29 + 136657 * v7 + ((v26 + 0x100000) >> 21);
  unint64_t v32 = v26 - ((v26 + 0x100000) & 0xFFFFFFFFFFE00000);
  uint64_t v33 = v24 + ((v25 + 0x100000) >> 21);
  unint64_t v34 = (((unint64_t)*((unsigned int *)result + 11) >> 5) & 0x1FFFFF) + ((uint64_t)(v19 + 0x100000) >> 21);
  unint64_t v35 = v9 - ((v9 + 0x100000) & 0xFFFFFE00000) + ((v10 + 0x100000) >> 21);
  unint64_t v36 = v10 - ((v10 + 0x100000) & 0x7FFFFFFFFFE00000);
  unint64_t v37 = v32 + ((v30 + 0x100000) >> 21);
  unint64_t v38 = v30 - ((v30 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v39 = v25 - ((v25 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v31 + 0x100000) >> 21);
  unint64_t v40 = v31 - ((v31 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v41 = v19 - ((v19 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v33 + 0x100000) >> 21);
  unint64_t v42 = v33 - ((v33 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v43 = (((unint64_t)*(unsigned int *)((char *)result + 7) >> 7) & 0x1FFFFF) + 666643 * v42;
  unint64_t v44 = (((unint64_t)*(unsigned int *)(result + 5) >> 4) & 0x1FFFFF) + 666643 * v41 + 470296 * v42;
  unint64_t v45 = (((unint64_t)(HIBYTE(*(_DWORD *)(result + 5)) | (*((unsigned __int8 *)result + 14) << 8) | (*((unsigned __int8 *)result + 15) << 16)) >> 1) & 0x1FFFFF)
      + 666643 * v34
      + 470296 * v41
      + 654183 * v42;
  uint64_t v46 = v8 - ((v8 + 0x100000) & 0x7FFFFE00000) + 470296 * v34 + 654183 * v41 - 997805 * v42;
  uint64_t v47 = v36 + 654183 * v34 - 997805 * v41 + 136657 * v42;
  uint64_t v48 = v35 - 997805 * v34 + 136657 * v41 - 683901 * v42;
  unint64_t v49 = (((unint64_t)(HIBYTE(*(_DWORD *)(result + 1)) | (*((unsigned __int8 *)result + 6) << 8) | (*((unsigned __int8 *)result + 7) << 16)) >> 2) & 0x1FFFFF)
      + 666643 * v39;
  unint64_t v50 = v43 + 470296 * v39;
  unint64_t v51 = v44 + 654183 * v39;
  unint64_t v52 = v45 - 997805 * v39;
  unint64_t v53 = v46 + 136657 * v39;
  unint64_t v54 = v47 - 683901 * v39;
  unint64_t v55 = (((unint64_t)*(unsigned int *)(result + 1) >> 5) & 0x1FFFFF) + 666643 * v40;
  unint64_t v56 = v49 + 470296 * v40;
  unint64_t v57 = v50 + 654183 * v40;
  unint64_t v58 = v51 - 997805 * v40;
  unint64_t v59 = v52 + 136657 * v40;
  unint64_t v60 = v53 - 683901 * v40;
  unint64_t v61 = v27 - 683901 * v34 - ((v27 + 0x100000) & 0xFFFFFFFFFFE00000) + ((uint64_t)(v11 + 0x100000) >> 21);
  unint64_t v62 = (*result | ((unint64_t)(result[1] & 0x1F) << 16)) + 666643 * v37;
  unint64_t v63 = v56 + 654183 * v37;
  unint64_t v64 = v58 + 136657 * v37;
  uint64_t v65 = v55 + 470296 * v37 + ((uint64_t)(v62 + 0x100000) >> 21);
  unint64_t v66 = v54 + ((uint64_t)(v60 + 0x100000) >> 21);
  unint64_t v67 = v11 + 136657 * v34 - ((v11 + 0x100000) & 0xFFFFFFFFFFE00000) - 683901 * v41 + ((v48 + 0x100000) >> 21);
  unint64_t v68 = v48 - ((v48 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v69 = v38 + ((uint64_t)(v61 + 0x100000) >> 21);
  unint64_t v70 = v61 - ((v61 + 0x100000) & 0xFFFFFFFFFFE00000);
  uint64_t v71 = v65 + 0x100000;
  unint64_t v72 = v70 + ((uint64_t)(v67 + 0x100000) >> 21);
  unint64_t v73 = v67 - ((v67 + 0x100000) & 0xFFFFFFFFFFE00000);
  uint64_t v74 = (uint64_t)(v69 + 0x100000) >> 21;
  unint64_t v75 = v65 + 470296 * v74 - ((v65 + 0x100000) & 0xFFFFFFFFFFE00000);
  uint64_t v76 = v57 - 997805 * v37 + ((uint64_t)(v63 + 0x100000) >> 21);
  unint64_t v77 = v63 + 654183 * v74 - ((v63 + 0x100000) & 0xFFFFFFFFFFE00000) + (v71 >> 21);
  unint64_t v78 = v76 - 997805 * v74 - ((v76 + 0x100000) & 0xFFFFFFFFFFE00000);
  uint64_t v79 = v59 - 683901 * v37 + ((uint64_t)(v64 + 0x100000) >> 21);
  unint64_t v80 = v64 + 136657 * v74 - ((v64 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v76 + 0x100000) >> 21);
  int64_t v81 = v62 - ((v62 + 0x100000) & 0xFFFFFFFFFFE00000) + 666643 * v74;
  uint64_t v82 = v79 - 683901 * v74;
  v79 += 0x100000;
  unint64_t v83 = v60 - ((v60 + 0x100000) & 0xFFFFFFFFFFE00000) + (v79 >> 21);
  uint64_t v84 = v75 + (v81 >> 21);
  uint64_t v85 = v77 + (v84 >> 21);
  uint64_t v86 = v78 + (v85 >> 21);
  uint64_t v87 = v80 + (v86 >> 21);
  int64_t v88 = v82 - (v79 & 0xFFFFFFFFFFE00000) + (v87 >> 21);
  uint64_t v89 = v83 + (v88 >> 21);
  int64_t v90 = v66 - ((v66 + 0x100000) & 0xFFFFFFFFFFE00000) + (v89 >> 21);
  uint64_t v91 = v68 + ((uint64_t)(v66 + 0x100000) >> 21) + (v90 >> 21);
  uint64_t v92 = v73 + (v91 >> 21);
  uint64_t v93 = v72 + (v92 >> 21);
  int64_t v94 = v69 - ((v69 + 0x100000) & 0xFFFFFFFFFFE00000) + (v93 >> 21);
  uint64_t v95 = (v81 & 0x1FFFFF) + 666643 * (v94 >> 21);
  *((unsigned char *)result + 1) = (unsigned __int16)(v81 + 11283 * (v94 >> 21)) >> 8;
  uint64_t v96 = (v84 & 0x1FFFFF) + 470296 * (v94 >> 21) + (v95 >> 21);
  *(unsigned char *)uint64_t result = v81 + 19 * (v94 >> 21);
  *((unsigned char *)result + 2) = ((unint64_t)((v81 & 0x1FFFFF) + 666643 * (v94 >> 21)) >> 16) & 0x1F | (32 * (v84 + 24 * (v94 >> 21) + (v95 >> 21)));
  *((unsigned char *)result + 3) = (unint64_t)v96 >> 3;
  *((unsigned char *)result + 4) = (unint64_t)v96 >> 11;
  uint64_t v97 = (v85 & 0x1FFFFF) + 654183 * (v94 >> 21) + (v96 >> 21);
  *((unsigned char *)result + 5) = (v96 >> 19) & 3 | (4 * (v85 + 103 * (v94 >> 21) + (v96 >> 21)));
  *((unsigned char *)result + 6) = (unint64_t)v97 >> 6;
  uint64_t v98 = (v86 & 0x1FFFFF) - 997805 * (v94 >> 21) + (v97 >> 21);
  *((unsigned char *)result + 7) = (v97 >> 14) & 0x7F | (((_BYTE)v86
                                                              - -83 * (v94 >> 21)
                                                              + (v97 >> 21)) << 7);
  *((unsigned char *)result + 8) = (unint64_t)v98 >> 1;
  *((unsigned char *)result + 9) = (unint64_t)v98 >> 9;
  uint64_t v99 = (v87 & 0x1FFFFF) + 136657 * (v94 >> 21) + (v98 >> 21);
  *((unsigned char *)result + 10) = (v98 >> 17) & 0xF | (16 * (v87 - 47 * (v94 >> 21) + (v98 >> 21)));
  *((unsigned char *)result + 11) = (unint64_t)v99 >> 4;
  *((unsigned char *)result + 12) = (unint64_t)v99 >> 12;
  uint64_t v100 = (v88 & 0x1FFFFF) - 683901 * (v94 >> 21) + (v99 >> 21);
  *((unsigned char *)result + 13) = ((v99 & 0x100000) != 0) | (2 * (v88 - 125 * (v94 >> 21) + (v99 >> 21)));
  *((unsigned char *)result + 14) = (unint64_t)v100 >> 7;
  uint64_t v101 = (v89 & 0x1FFFFF) + (v100 >> 21);
  *((unsigned char *)result + 15) = (v100 >> 15) & 0x3F | (((_BYTE)v89 + (v100 >> 21)) << 6);
  *((unsigned char *)result + 16) = (unint64_t)v101 >> 2;
  *((unsigned char *)result + 17) = (unint64_t)v101 >> 10;
  uint64_t v102 = (v90 & 0x1FFFFF) + (v101 >> 21);
  *((unsigned char *)result + 18) = (v101 >> 18) & 7 | (8 * (v66 + (v89 >> 21) + (v101 >> 21)));
  *((unsigned char *)result + 19) = (unint64_t)v102 >> 5;
  *((unsigned char *)result + 20) = (unint64_t)v102 >> 13;
  *((unsigned char *)result + 22) = (unsigned __int16)(v91 + (v102 >> 21)) >> 8;
  uint64_t v103 = (v92 & 0x1FFFFF) + (((v91 & 0x1FFFFF) + (v102 >> 21)) >> 21);
  *((unsigned char *)result + 21) = v91 + (v102 >> 21);
  *((unsigned char *)result + 23) = ((unint64_t)((v91 & 0x1FFFFF) + (v102 >> 21)) >> 16) & 0x1F | (32 * v103);
  *((unsigned char *)result + 24) = (unint64_t)v103 >> 3;
  *((unsigned char *)result + 25) = (unint64_t)v103 >> 11;
  uint64_t v104 = (v93 & 0x1FFFFF) + (v103 >> 21);
  *((unsigned char *)result + 26) = (v103 >> 19) & 3 | (4 * v104);
  *((unsigned char *)result + 27) = (unint64_t)v104 >> 6;
  unint64_t v105 = (v94 & 0x1FFFFF) + (v104 >> 21);
  *((unsigned char *)result + 28) = (v104 >> 14) & 0x7F | ((_BYTE)v105 << 7);
  *((unsigned char *)result + 29) = v105 >> 1;
  *((unsigned char *)result + 30) = v105 >> 9;
  *((unsigned char *)result + 31) = v105 >> 17;
  return result;
}

uint64_t ge_select(uint64_t a1, int a2, int a3)
{
  int v4 = (a3 >> 7) & 1;
  int v5 = a3 - 2 * (a3 & (a3 >> 31));
  *(_DWORD *)a1 = 1;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_OWORD *)(a1 + 20) = 0u;
  *(void *)(a1 + 36) = 0x100000000;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_OWORD *)(a1 + 60) = 0u;
  *(_OWORD *)(a1 + 76) = 0u;
  *(_OWORD *)(a1 + 92) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  unint64_t v6 = (uint64_t *)((char *)&base + 960 * a2);
  ge_cmov((uint64_t *)a1, v6, ((a3 - 2 * (a3 & (a3 >> 31))) ^ 1) - 1 < 0);
  ge_cmov((uint64_t *)a1, v6 + 15, (v5 ^ 2) - 1 < 0);
  ge_cmov((uint64_t *)a1, v6 + 30, (v5 ^ 3) - 1 < 0);
  ge_cmov((uint64_t *)a1, v6 + 45, (v5 ^ 4) - 1 < 0);
  ge_cmov((uint64_t *)a1, v6 + 60, (v5 ^ 5) - 1 < 0);
  ge_cmov((uint64_t *)a1, v6 + 75, (v5 ^ 6) - 1 < 0);
  ge_cmov((uint64_t *)a1, v6 + 90, (v5 ^ 7) - 1 < 0);
  ge_cmov((uint64_t *)a1, v6 + 105, (v5 ^ 8) - 1 < 0);
  *(void *)&long long v7 = *(void *)(a1 + 72);
  long long v8 = *(_OWORD *)(a1 + 56);
  v13[0] = *(_OWORD *)(a1 + 40);
  v13[1] = v8;
  *((void *)&v7 + 1) = *(void *)a1;
  long long v9 = *(_OWORD *)(a1 + 8);
  _OWORD v13[2] = v7;
  uint64_t v13[3] = v9;
  int32x4_t v10 = *(int32x4_t *)(a1 + 96);
  int32x4_t v11 = vnegq_s32(*(int32x4_t *)(a1 + 80));
  void v13[4] = *(_OWORD *)(a1 + 24);
  v13[5] = v11;
  v13[6] = vnegq_s32(v10);
  int32x2_t v14 = vneg_s32(*(int32x2_t *)(a1 + 112));
  return ge_cmov((uint64_t *)a1, (uint64_t *)v13, v4);
}

uint64_t ge_cmov(uint64_t *a1, uint64_t *a2, char a3)
{
  ccn_mux(5, a3, a1, a2, a1);
  ccn_mux(5, a3, a1 + 5, a2 + 5, a1 + 5);

  return ccn_mux(5, a3, a1 + 10, a2 + 10, a1 + 10);
}

unsigned int *ccsha256_ltc_compress(unsigned int *result, uint64_t a2, const char *a3)
{
  uint64_t v79 = *MEMORY[0x263EF8C08];
  if (a2)
  {
    unsigned int v3 = *result;
    unsigned int v4 = result[1];
    unsigned int v5 = result[2];
    unsigned int v6 = result[3];
    int v7 = result[4];
    int v8 = result[5];
    int v9 = result[6];
    int v10 = result[7];
    do
    {
      uint64_t v11 = 0;
      --a2;
      int8x16x4_t v80 = vld4q_s8(a3);
      uint16x8_t v12 = vmovl_u8(*(uint8x8_t *)v80.val[0].i8);
      uint16x8_t v13 = vmovl_high_u8((uint8x16_t)v80.val[0]);
      _Q16 = vmovl_high_u8((uint8x16_t)v80.val[1]);
      _Q17 = (int8x16_t)vmovl_u8(*(uint8x8_t *)v80.val[1].i8);
      int8x16_t v16 = (int8x16_t)vshll_n_s16(*(int16x4_t *)_Q17.i8, 0x10uLL);
      __asm
      {
        SHLL2           V19.4S, V16.8H, #0x10
        SHLL2           V17.4S, V17.8H, #0x10
      }
      uint16x8_t v22 = vmovl_u8(*(uint8x8_t *)v80.val[2].i8);
      uint16x8_t v23 = vmovl_high_u8((uint8x16_t)v80.val[2]);
      int8x16_t v24 = vorrq_s8(vorrq_s8((int8x16_t)vshll_n_s16(*(int16x4_t *)_Q16.i8, 0x10uLL), (int8x16_t)vshll_n_u16(*(uint16x4_t *)v23.i8, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v13.i8), 0x18uLL));
      uint16x8_t v25 = vmovl_u8(*(uint8x8_t *)v80.val[3].i8);
      v80.val[0] = (int8x16_t)vmovl_high_u8((uint8x16_t)v80.val[3]);
      v78[0] = vorrq_s8(v24, (int8x16_t)vmovl_u16(*(uint16x4_t *)v80.val[0].i8));
      v78[1] = vorrq_s8(vorrq_s8(vorrq_s8(_Q19, (int8x16_t)vshll_high_n_u16(v23, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_high_u16(v13), 0x18uLL)), (int8x16_t)vmovl_high_u16((uint16x8_t)v80.val[0]));
      int8x16_t v76 = vorrq_s8(vorrq_s8(vorrq_s8(v16, (int8x16_t)vshll_n_u16(*(uint16x4_t *)v22.i8, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v12.i8), 0x18uLL)), (int8x16_t)vmovl_u16(*(uint16x4_t *)v25.i8));
      int8x16_t v77 = vorrq_s8(vorrq_s8(vorrq_s8(_Q17, (int8x16_t)vshll_high_n_u16(v22, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_high_u16(v12), 0x18uLL)), (int8x16_t)vmovl_high_u16(v25));
      __int32 v26 = v76.i32[0];
      do
      {
        HIDWORD(v27) = *(_DWORD *)((char *)&v78[1] + v11 * 4 + 8);
        LODWORD(v27) = HIDWORD(v27);
        int v28 = (v27 >> 17) ^ __ROR4__(HIDWORD(v27), 19) ^ (HIDWORD(v27) >> 10);
        HIDWORD(v27) = v76.i32[v11 + 1];
        LODWORD(v27) = HIDWORD(v27);
        *(_DWORD *)((char *)&v78[2] + v11 * 4) = v28
                                               + *(_DWORD *)((char *)v78 + v11 * 4 + 4)
                                               + v26
                                               + ((v27 >> 7) ^ __ROR4__(HIDWORD(v27), 18) ^ (HIDWORD(v27) >> 3));
        ++v11;
        __int32 v26 = HIDWORD(v27);
      }
      while (v11 != 48);
      unint64_t v29 = &dword_2373AF850;
      unint64_t v30 = -8;
      uint64_t v31 = &v77;
      unsigned int v32 = v3;
      unsigned int v33 = v4;
      unsigned int v34 = v5;
      unsigned int v35 = v6;
      int v36 = v7;
      int v37 = v8;
      int v38 = v9;
      int v39 = v10;
      do
      {
        HIDWORD(v40) = v36;
        LODWORD(v40) = v36;
        int v41 = (v40 >> 6) ^ __ROR4__(v36, 11);
        unint64_t v43 = __PAIR64__(v32, __ROR4__(v36, 25));
        int v42 = v41 ^ v43;
        LODWORD(v43) = v32;
        int v44 = (v37 & v36 | v38 & ~v36) + v39 + *(v29 - 4) + v31[-1].i32[0] + v42;
        int v45 = v44 + v35;
        unsigned int v46 = ((v43 >> 2) ^ __ROR4__(v32, 13) ^ __ROR4__(v32, 22)) + ((v32 | v33) & v34 | v32 & v33) + v44;
        HIDWORD(v43) = v45;
        LODWORD(v43) = v45;
        int v47 = (v43 >> 6) ^ __ROR4__(v45, 11);
        unint64_t v48 = __PAIR64__(v46, __ROR4__(v45, 25));
        int v49 = *(v29 - 3) + v38 + v31[-1].i32[1] + (v36 & v45 | v37 & ~v45) + (v47 ^ v48);
        LODWORD(v48) = v46;
        int v50 = v49 + v34;
        unsigned int v51 = ((v48 >> 2) ^ __ROR4__(v46, 13) ^ __ROR4__(v46, 22)) + ((v46 | v32) & v33 | v46 & v32) + v49;
        HIDWORD(v48) = v50;
        LODWORD(v48) = v50;
        int v52 = (v48 >> 6) ^ __ROR4__(v50, 11);
        unint64_t v54 = __PAIR64__(v51, __ROR4__(v50, 25));
        int v53 = v52 ^ v54;
        LODWORD(v54) = v51;
        int v55 = *(v29 - 2) + v37 + v31[-1].i32[2] + (v45 & v50 | v36 & ~v50) + v53;
        int v56 = v55 + v33;
        unsigned int v57 = ((v54 >> 2) ^ __ROR4__(v51, 13) ^ __ROR4__(v51, 22)) + ((v51 | v46) & v32 | v51 & v46) + v55;
        HIDWORD(v54) = v56;
        LODWORD(v54) = v56;
        int v58 = (v54 >> 6) ^ __ROR4__(v56, 11);
        unint64_t v59 = __PAIR64__(v57, __ROR4__(v56, 25));
        int v60 = *(v29 - 1) + v36 + v31[-1].i32[3] + (v50 & v56 | v45 & ~v56) + (v58 ^ v59);
        LODWORD(v59) = v57;
        int v61 = v60 + v32;
        unsigned int v62 = ((v59 >> 2) ^ __ROR4__(v57, 13) ^ __ROR4__(v57, 22)) + ((v57 | v51) & v46 | v57 & v51) + v60;
        HIDWORD(v59) = v61;
        LODWORD(v59) = v61;
        int v63 = (v59 >> 6) ^ __ROR4__(v61, 11);
        unint64_t v65 = __PAIR64__(v62, __ROR4__(v61, 25));
        int v64 = v63 ^ v65;
        LODWORD(v65) = v62;
        int v66 = *v29 + v31->i32[0] + v45 + (v56 & v61 | v50 & ~v61) + v64;
        int v39 = v66 + v46;
        unsigned int v35 = ((v65 >> 2) ^ __ROR4__(v62, 13) ^ __ROR4__(v62, 22)) + ((v62 | v57) & v51 | v62 & v57) + v66;
        HIDWORD(v65) = v39;
        LODWORD(v65) = v39;
        int v67 = (v65 >> 6) ^ __ROR4__(v39, 11);
        unint64_t v68 = __PAIR64__(v35, __ROR4__(v39, 25));
        int v69 = v50 + v29[1] + v31->i32[1] + (v61 & v39 | v56 & ~v39) + (v67 ^ v68);
        LODWORD(v68) = v35;
        int v38 = v69 + v51;
        unsigned int v34 = ((v68 >> 2) ^ __ROR4__(v35, 13) ^ __ROR4__(v35, 22)) + ((v35 | v62) & v57 | v35 & v62) + v69;
        HIDWORD(v68) = v38;
        LODWORD(v68) = v38;
        int v70 = (v68 >> 6) ^ __ROR4__(v38, 11);
        unint64_t v71 = __PAIR64__(v34, __ROR4__(v38, 25));
        int v72 = v31->i32[2] + v29[2] + v56 + (v39 & v38 | v61 & ~v38) + (v70 ^ v71);
        LODWORD(v71) = v34;
        int v37 = v72 + v57;
        unsigned int v33 = ((v71 >> 2) ^ __ROR4__(v34, 13) ^ __ROR4__(v34, 22)) + ((v34 | v35) & v62 | v34 & v35) + v72;
        HIDWORD(v71) = v37;
        LODWORD(v71) = v37;
        int v73 = (v71 >> 6) ^ __ROR4__(v37, 11);
        unint64_t v74 = __PAIR64__(v33, __ROR4__(v37, 25));
        int v75 = v31->i32[3] + v29[3] + v61 + (v38 & v37 | v39 & ~v37) + (v73 ^ v74);
        LODWORD(v74) = v33;
        int v36 = v75 + v62;
        unsigned int v32 = ((v74 >> 2) ^ __ROR4__(v33, 13) ^ __ROR4__(v33, 22)) + ((v33 | v34) & v35 | v33 & v34) + v75;
        v30 += 8;
        v31 += 2;
        v29 += 8;
      }
      while (v30 < 0x38);
      v3 += v32;
      v4 += v33;
      *uint64_t result = v3;
      result[1] = v4;
      v5 += v34;
      v6 += v35;
      result[2] = v5;
      result[3] = v6;
      v7 += v36;
      v8 += v37;
      result[4] = v7;
      result[5] = v8;
      v9 += v38;
      v10 += v39;
      a3 += 64;
      result[6] = v9;
      result[7] = v10;
    }
    while (a2);
  }
  return result;
}

BOOL ccec25519_mul121666_ws(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4)
{
  void v8[4] = *MEMORY[0x263EF8C08];
  uint64_t v6 = ccn_mul1(4, v8, a4, 0x1DB42uLL);
  BOOL result = ccn_add1_ws(a1, 4, a3, v8, 38 * v6);
  *a3 += result ? 0x26uLL : 0;
  return result;
}

uint64_t ccec25519_inv_ws(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = *(void *)(a1 + 16);
  int v7 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 4);
  int v8 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 4);
  int v9 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 4);
  cczp_sqr_ws(a1, a2);
  ccn_set(4, v7, v8);
  cczp_sqr_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  ccn_set(4, v7, v9);
  int v10 = 5;
  do
  {
    cczp_sqr_ws(a1, a2);
    --v10;
  }
  while (v10);
  cczp_mul_ws(a1, a2);
  ccn_set(4, v7, v9);
  int v11 = 10;
  do
  {
    cczp_sqr_ws(a1, a2);
    --v11;
  }
  while (v11);
  cczp_mul_ws(a1, a2);
  ccn_set(4, v7, a3);
  int v12 = 20;
  do
  {
    cczp_sqr_ws(a1, a2);
    --v12;
  }
  while (v12);
  cczp_mul_ws(a1, a2);
  ccn_set(4, v7, v7);
  int v13 = 10;
  do
  {
    cczp_sqr_ws(a1, a2);
    --v13;
  }
  while (v13);
  cczp_mul_ws(a1, a2);
  ccn_set(4, v7, v9);
  int v14 = 50;
  do
  {
    cczp_sqr_ws(a1, a2);
    --v14;
  }
  while (v14);
  cczp_mul_ws(a1, a2);
  ccn_set(4, v7, a3);
  int v15 = 100;
  do
  {
    cczp_sqr_ws(a1, a2);
    --v15;
  }
  while (v15);
  cczp_mul_ws(a1, a2);
  ccn_set(4, v7, v7);
  int v16 = 50;
  do
  {
    cczp_sqr_ws(a1, a2);
    --v16;
  }
  while (v16);
  cczp_mul_ws(a1, a2);
  ccn_set(4, v7, v7);
  int v17 = 5;
  do
  {
    cczp_sqr_ws(a1, a2);
    --v17;
  }
  while (v17);
  cczp_mul_ws(a1, a2);
  *(void *)(a1 + 16) = v6;
  return 0;
}

uint64_t ccec25519_from_ws(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  void v11[4] = *MEMORY[0x263EF8C08];
  BOOL v7 = ccn_add1_ws(a1, 4, a3, a4, (a4[3] >> 63) & 0x13);
  ccn_set_bit((uint64_t)a3, 0xFFuLL, v7);
  int v8 = (unint64_t *)cczp_prime(a2);
  int v9 = ccn_sub_ws(a1, 4, v11, a3, v8);
  ccn_sub1(4, a3, v11, -v9 & 0x13);
  return ccn_set_bit((uint64_t)a3, 0xFFuLL, 0);
}

void ccec25519_add_opt_ws(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4, void *a5)
{
  unint64_t v5 = a4[1];
  long long v6 = *(_OWORD *)a5 + *a4;
  BOOL v7 = __CFADD__(__CFADD__(*a5, *a4), a5[1]) | __CFADD__(v5, *((void *)&v6 + 1));
  unint64_t v8 = v5 + *((void *)&v6 + 1);
  unint64_t v9 = a4[2];
  unint64_t v10 = a4[3];
  uint64_t v11 = a5[2];
  uint64_t v12 = a5[3];
  uint64_t v14 = v7 + v11;
  BOOL v7 = __CFADD__(v7, v11) | __CFADD__(v9, v14);
  uint64_t v13 = v9 + v14;
  uint64_t v16 = v7 + v12;
  BOOL v7 = __CFADD__(v7, v12) | __CFADD__(v10, v16);
  uint64_t v15 = v10 + v16;
  int v17 = v7;
  uint64_t v18 = -v17 & 0x26;
  uint64_t v19 = v18 + v6;
  BOOL v7 = __CFADD__(__CFADD__(v18, (void)v6), v8);
  unint64_t v20 = __CFADD__(v18, (void)v6) + v8;
  BOOL v22 = v7;
  BOOL v7 = __CFADD__(v7, v13);
  uint64_t v21 = v22 + v13;
  BOOL v24 = v7;
  BOOL v7 = __CFADD__(v7, v15);
  uint64_t v23 = v24 + v15;
  int v25 = v7;
  a3[2] = v21;
  a3[3] = v23;
  *a3 = (-v25 & 0x26) + v19;
  a3[1] = v20;
}

void ccec25519_sub_opt_ws(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4, void *a5)
{
  unsigned long long v5 = *a4 - __PAIR128__(*a5, *a5);
  unsigned long long v6 = a4[1] - __PAIR128__(a5[1], a5[1]) + __PAIR128__(*((uint64_t *)&v5 + 1) >> 63, *((uint64_t *)&v5 + 1) >> 63);
  unsigned long long v7 = a4[2] - __PAIR128__(a5[2], a5[2]) + __PAIR128__(*((uint64_t *)&v6 + 1) >> 63, *((uint64_t *)&v6 + 1) >> 63);
  unsigned long long v8 = a4[3]
     - __PAIR128__((a4[2] - __PAIR128__(a5[2], a5[2])) >> 64, a5[3])
     + __PAIR128__(*((uint64_t *)&v7 + 1) >> 63, *((uint64_t *)&v7 + 1) >> 63);
  unint64_t v9 = (*((uint64_t *)&v8 + 1) >> 63) & 0xFFFFFFFFFFFFFFDALL;
  uint64_t v10 = v9 + v5;
  if (__CFADD__(v9, (void)v5)) {
    uint64_t v11 = (*((uint64_t *)&v8 + 1) >> 63) + 1;
  }
  else {
    uint64_t v11 = *((uint64_t *)&v8 + 1) >> 63;
  }
  uint64_t v12 = v6 + (v11 >> 63);
  if (__CFADD__((void)v6, v11 >> 63)) {
    uint64_t v13 = (v11 >> 63) + 1;
  }
  else {
    uint64_t v13 = v11 >> 63;
  }
  uint64_t v14 = v7 + (v13 >> 63);
  if (__CFADD__((void)v7, v13 >> 63)) {
    uint64_t v15 = (v13 >> 63) + 1;
  }
  else {
    uint64_t v15 = v13 >> 63;
  }
  uint64_t v16 = v8 + (v15 >> 63);
  if (__CFADD__((void)v8, v15 >> 63)) {
    uint64_t v17 = (v15 >> 63) + 1;
  }
  else {
    uint64_t v17 = v15 >> 63;
  }
  a3[2] = v14;
  a3[3] = v16;
  *a3 = ((v17 >> 63) & 0xFFFFFFFFFFFFFFDALL) + v10;
  a3[1] = v12;
}

uint64_t ccec25519_mul_opt_ws(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4, unint64_t *a5)
{
  unint64_t v5 = *a5;
  unint64_t v6 = a5[1];
  unint64_t v7 = *a4;
  unint64_t v8 = a4[1];
  unint64_t v9 = *a5 * *a4;
  uint64_t v10 = (*a5 * (unsigned __int128)*a4) >> 64;
  unint64_t v11 = a4[2];
  unint64_t v12 = a4[3];
  uint64_t v13 = (v6 * (unsigned __int128)v12) >> 64;
  unint64_t v15 = a5[2];
  unint64_t v14 = a5[3];
  uint64_t v16 = (v15 * (unsigned __int128)v11) >> 64;
  unint64_t v17 = v15 * v11 + v6 * v12;
  unint64_t v18 = __CFADD__(v15 * v11, v6 * v12);
  BOOL v19 = __CFADD__(v16, v13);
  uint64_t v20 = v16 + v13;
  uint64_t v21 = v19;
  uint64_t v22 = (v14 * (unsigned __int128)v8) >> 64;
  BOOL v19 = __CFADD__(v17, v14 * v8);
  unint64_t v23 = v17 + v14 * v8;
  if (v19) {
    ++v18;
  }
  BOOL v19 = __CFADD__(v20, v22);
  unint64_t v24 = v20 + v22;
  if (v19) {
    ++v21;
  }
  uint64_t v25 = (__PAIR128__(v18, v23) * 0x26) >> 64;
  uint64_t v26 = 38 * v23;
  uint64_t v27 = (v24 * (unsigned __int128)0x26uLL) >> 64;
  uint64_t v28 = 38 * v24;
  BOOL v19 = __CFADD__(v28, v10);
  uint64_t v29 = v28 + v10;
  uint64_t v30 = 38 * v21 + v19 + v27;
  uint64_t v31 = (v8 * (unsigned __int128)v5) >> 64;
  unint64_t v32 = v8 * v5;
  uint64_t v33 = (v6 * (unsigned __int128)v7) >> 64;
  unint64_t v34 = v6 * v7;
  uint64_t v35 = (v15 * (unsigned __int128)v12) >> 64;
  uint64_t v36 = (v14 * (unsigned __int128)v11) >> 64;
  unint64_t v37 = v14 * v11 + v15 * v12;
  BOOL v38 = __CFADD__(v14 * v11, v15 * v12);
  BOOL v19 = __CFADD__(v36, v35);
  unint64_t v39 = v36 + v35;
  unsigned int v40 = v19;
  unint64_t v41 = (__PAIR128__(v38, v37) * 0x26) >> 64;
  uint64_t v42 = 38 * v37;
  BOOL v19 = __CFADD__(v32, v34);
  unint64_t v43 = v32 + v34;
  uint64_t v44 = v19;
  unsigned long long v45 = __PAIR128__(v44, v43) + __PAIR128__(v41, v42);
  unint64_t v46 = (__PAIR128__(v40, v39) * 0x26) >> 64;
  uint64_t v47 = 38 * v39;
  BOOL v19 = __CFADD__(v31, v33);
  unint64_t v48 = v31 + v33;
  uint64_t v49 = v19;
  unsigned long long v50 = __PAIR128__(v49, v48) + __PAIR128__(v46, v47);
  BOOL v19 = __CFADD__(v26, v9);
  unint64_t v51 = v26 + v9;
  BOOL v53 = v19;
  BOOL v19 = __CFADD__(v19, v29);
  uint64_t v52 = v53 + v29;
  v19 |= __CFADD__(v25, v52);
  v52 += v25;
  uint64_t v54 = v30 + v19 + v48 + v47;
  if (__CFADD__(v19, (void)v50) | __CFADD__(v30, v19 + (void)v50)) {
    uint64_t v55 = *((void *)&v50 + 1) + 1;
  }
  else {
    uint64_t v55 = (__PAIR128__(v49, v48) + __PAIR128__(v46, v47)) >> 64;
  }
  uint64_t v56 = (v11 * (unsigned __int128)v5) >> 64;
  uint64_t v57 = (v8 * (unsigned __int128)v6) >> 64;
  unint64_t v58 = v8 * v6;
  uint64_t v59 = (v15 * (unsigned __int128)v7) >> 64;
  unint64_t v60 = (v14 * (unsigned __int128)v12) >> 64;
  unint64_t v61 = v15 * v7 + v11 * v5;
  BOOL v62 = __CFADD__(v15 * v7, v11 * v5);
  BOOL v19 = __CFADD__(v61, v58);
  unint64_t v63 = v61 + v58;
  if (v19) {
    BOOL v64 = v62 + 1;
  }
  else {
    BOOL v64 = v62;
  }
  unsigned long long v65 = __PAIR128__(v64, v63) + v14 * v12 * (unsigned __int128)0x26uLL;
  unint64_t v66 = (v60 * (unsigned __int128)0x26uLL) >> 64;
  uint64_t v67 = 38 * v60;
  BOOL v19 = __CFADD__(v59, v56);
  uint64_t v68 = v59 + v56;
  uint64_t v69 = v19;
  BOOL v19 = __CFADD__(v68, v57);
  unint64_t v70 = v68 + v57;
  if (v19) {
    uint64_t v71 = v69 + 1;
  }
  else {
    uint64_t v71 = v69;
  }
  BOOL v19 = __CFADD__((void)v45, v52);
  uint64_t result = v45 + v52;
  BOOL v74 = v19;
  BOOL v19 = __CFADD__(v19, v54);
  uint64_t v73 = v74 + v54;
  v19 |= __CFADD__(*((void *)&v45 + 1), v73);
  v73 += *((void *)&v45 + 1);
  uint64_t v76 = v19 + v70 + v67;
  BOOL v19 = __CFADD__(v19, v70 + v67) | __CFADD__(v55, v76);
  uint64_t v75 = v55 + v76;
  if (v19) {
    uint64_t v77 = ((__PAIR128__(v71, v70) + __PAIR128__(v66, v67)) >> 64) + 1;
  }
  else {
    uint64_t v77 = (__PAIR128__(v71, v70) + __PAIR128__(v66, v67)) >> 64;
  }
  uint64_t v78 = (v12 * (unsigned __int128)v5) >> 64;
  unint64_t v79 = v12 * v5;
  uint64_t v80 = (v11 * (unsigned __int128)v6) >> 64;
  unint64_t v81 = v11 * v6;
  uint64_t v82 = (v8 * (unsigned __int128)v15) >> 64;
  unint64_t v83 = v8 * v15;
  uint64_t v84 = (v14 * (unsigned __int128)v7) >> 64;
  unint64_t v85 = v14 * v7;
  BOOL v19 = __CFADD__(v81, v79);
  unint64_t v86 = v81 + v79;
  uint64_t v87 = v19;
  BOOL v19 = __CFADD__(v86, v83);
  unint64_t v88 = v86 + v83;
  if (v19) {
    ++v87;
  }
  BOOL v19 = __CFADD__(v88, v85);
  unint64_t v89 = v88 + v85;
  if (v19) {
    uint64_t v90 = v87 + 1;
  }
  else {
    uint64_t v90 = v87;
  }
  uint64_t v91 = v80 + v78;
  unint64_t v92 = __CFADD__(v80, v78);
  BOOL v19 = __CFADD__(v91, v82);
  uint64_t v93 = v91 + v82;
  if (v19) {
    ++v92;
  }
  BOOL v19 = __CFADD__(v93, v84);
  uint64_t v94 = v93 + v84;
  if (v19) {
    ++v92;
  }
  unsigned long long v97 = v65 + __PAIR128__(v75, v73);
  unint64_t v96 = v97 >> 64;
  uint64_t v95 = v97;
  BOOL v19 = __CFADD__(__CFADD__(__CFADD__((void)v65, v73), v75) | __CFADD__(*((void *)&v65 + 1), __CFADD__((void)v65, v73) + v75), v94);
  unint64_t v98 = (__CFADD__(__CFADD__((void)v65, v73), v75) | __CFADD__(*((void *)&v65 + 1), __CFADD__((void)v65, v73) + v75))+ v94;
  v19 |= __CFADD__(v77, v98);
  v98 += v77;
  if (v19) {
    ++v92;
  }
  unint64_t v100 = v89 + v96;
  BOOL v19 = __CFADD__(__CFADD__(v89, v96), v98) | __CFADD__(v90, (__PAIR128__(v98, v89) + v96) >> 64);
  unint64_t v99 = v90 + ((__PAIR128__(v98, v89) + v96) >> 64);
  if (v19) {
    unint64_t v101 = v92 + 1;
  }
  else {
    unint64_t v101 = v92;
  }
  uint64_t v102 = (__PAIR128__(v101, v99) * 0x26) >> 64;
  uint64_t v103 = 38 * v99;
  BOOL v19 = __CFADD__(v103, v51);
  unint64_t v104 = v103 + v51;
  BOOL v106 = v19;
  BOOL v19 = __CFADD__(v19, v102);
  uint64_t v105 = v106 + v102;
  v19 |= __CFADD__(result, v105);
  v105 += result;
  uint64_t v107 = v19 + v95;
  BOOL v109 = __CFADD__(v19, v95);
  unint64_t v108 = v109 + v100;
  int v110 = __CFADD__(v109, v100);
  a3[2] = v107;
  a3[3] = v108;
  *a3 = (-v110 & 0x26) + v104;
  a3[1] = v105;
  return result;
}

uint64_t ccec25519_sqr_opt_ws(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4)
{
  unint64_t v4 = *a4;
  unint64_t v5 = a4[1];
  uint64_t v6 = v4 * v4;
  uint64_t v7 = (v4 * (unsigned __int128)v4) >> 64;
  unint64_t v9 = a4[2];
  unint64_t v8 = a4[3];
  unint64_t v10 = (v5 * (unsigned __int128)v8) >> 64;
  unint64_t v11 = (v5 * v8) >> 63;
  unint64_t v12 = v10 >> 63;
  uint64_t v13 = (v9 * (unsigned __int128)v9) >> 64;
  uint64_t v14 = v9 * v9 + 2 * v5 * v8;
  if (__CFADD__(v9 * v9, 2 * v5 * v8)) {
    ++v11;
  }
  BOOL v78 = __CFADD__(v13, 2 * v10);
  unint64_t v15 = v13 + 2 * v10;
  if (v78) {
    ++v12;
  }
  uint64_t v16 = (__PAIR128__(v11, v14) * 0x26) >> 64;
  uint64_t v17 = 38 * v14;
  uint64_t v18 = (v15 * (unsigned __int128)0x26uLL) >> 64;
  uint64_t v19 = 38 * v15;
  BOOL v78 = __CFADD__(v19, v7);
  uint64_t v20 = v19 + v7;
  uint64_t v21 = 38 * v12 + v78 + v18;
  unint64_t v22 = (v5 * (unsigned __int128)v4) >> 64;
  unint64_t v23 = v22 >> 63;
  unint64_t v24 = (v9 * (unsigned __int128)v8) >> 64;
  unsigned long long v25 = v9 * v8 * (unsigned __int128)0x4CuLL + __PAIR128__((v5 * v4) >> 63, 2 * v5 * v4);
  uint64_t v26 = (v24 * (unsigned __int128)0x4CuLL) >> 64;
  v24 *= 76;
  BOOL v78 = __CFADD__(v24, 2 * v22);
  unint64_t v27 = v24 + 2 * v22;
  unint64_t v28 = v23 + v78 + v26;
  BOOL v78 = __CFADD__(v17, v6);
  uint64_t v29 = v17 + v6;
  BOOL v31 = v78;
  BOOL v78 = __CFADD__(v78, v20);
  uint64_t v30 = v31 + v20;
  v78 |= __CFADD__(v16, v30);
  v30 += v16;
  uint64_t v32 = v21 + v78 + v27;
  if (__CFADD__(v78, v27) | __CFADD__(v21, v78 + v27)) {
    unint64_t v33 = v28 + 1;
  }
  else {
    unint64_t v33 = v28;
  }
  unint64_t v34 = (v9 * (unsigned __int128)v4) >> 64;
  uint64_t v35 = v9 * v4;
  unint64_t v36 = v34 >> 63;
  uint64_t v37 = (v5 * (unsigned __int128)v5) >> 64;
  unint64_t v38 = (v8 * (unsigned __int128)v8) >> 64;
  uint64_t v39 = 38 * v8 * v8;
  uint64_t v40 = v39 + v5 * v5;
  if (__CFADD__(v39, v5 * v5)) {
    uint64_t v41 = ((v8 * v8 * (unsigned __int128)0x26uLL) >> 64) + 1;
  }
  else {
    uint64_t v41 = (v8 * v8 * (unsigned __int128)0x26uLL) >> 64;
  }
  BOOL v78 = __CFADD__(v40, 2 * v35);
  uint64_t result = v40 + 2 * v35;
  unint64_t v43 = ((v9 * v4) >> 63) + v78 + v41;
  uint64_t v44 = (v38 * (unsigned __int128)0x26uLL) >> 64;
  uint64_t v45 = 38 * v38;
  BOOL v78 = __CFADD__(v45, v37);
  uint64_t v46 = v45 + v37;
  if (v78) {
    ++v44;
  }
  BOOL v78 = __CFADD__(v46, 2 * v34);
  uint64_t v47 = v46 + 2 * v34;
  unint64_t v48 = v36 + v78 + v44;
  BOOL v78 = __CFADD__(76 * v9 * v8 + 2 * v5 * v4, v30);
  uint64_t v49 = 76 * v9 * v8 + 2 * v5 * v4 + v30;
  BOOL v51 = v78;
  BOOL v78 = __CFADD__(v78, v32);
  uint64_t v50 = v51 + v32;
  v78 |= __CFADD__(*((void *)&v25 + 1), v50);
  v50 += *((void *)&v25 + 1);
  uint64_t v53 = v78 + v47;
  BOOL v78 = __CFADD__(v78, v47) | __CFADD__(v33, v53);
  uint64_t v52 = v33 + v53;
  if (v78) {
    unint64_t v54 = v48 + 1;
  }
  else {
    unint64_t v54 = v48;
  }
  uint64_t v55 = (v8 * (unsigned __int128)v4) >> 64;
  uint64_t v56 = v8 * v4;
  uint64_t v57 = (v9 * (unsigned __int128)v5) >> 64;
  uint64_t v58 = v9 * v5;
  BOOL v78 = __CFADD__(v58, v56);
  uint64_t v59 = v58 + v56;
  uint64_t v60 = v78;
  BOOL v78 = __CFADD__(v57, v55);
  uint64_t v61 = v57 + v55;
  uint64_t v62 = v78;
  BOOL v78 = __CFADD__(result, v50);
  uint64_t v63 = result + v50;
  *((void *)&v65 + 1) = v60;
  *(void *)&long long v65 = v59;
  uint64_t v64 = v65 >> 63;
  BOOL v67 = v78;
  BOOL v78 = __CFADD__(v78, v52);
  unint64_t v66 = v67 + v52;
  v78 |= __CFADD__(v43, v66);
  v66 += v43;
  *((void *)&v65 + 1) = v62;
  *(void *)&long long v65 = v61;
  unint64_t v68 = v65 >> 63;
  uint64_t v69 = 2 * v61;
  BOOL v71 = v78;
  BOOL v78 = __CFADD__(v78, v69);
  uint64_t v70 = v71 + v69;
  v78 |= __CFADD__(v54, v70);
  v70 += v54;
  if (v78) {
    ++v68;
  }
  unint64_t v73 = v66 + 2 * v59;
  BOOL v78 = __CFADD__(__CFADD__(v66, 2 * v59), v70) | __CFADD__(v64, (__PAIR128__(v70, v66) + (unint64_t)(2 * v59)) >> 64);
  unint64_t v72 = v64 + ((__PAIR128__(v70, v66) + (unint64_t)(2 * v59)) >> 64);
  if (v78) {
    unint64_t v74 = v68 + 1;
  }
  else {
    unint64_t v74 = v68;
  }
  uint64_t v75 = (__PAIR128__(v74, v72) * 0x26) >> 64;
  uint64_t v76 = 38 * v72;
  BOOL v78 = __CFADD__(v76, v29);
  uint64_t v77 = v76 + v29;
  BOOL v80 = v78;
  BOOL v78 = __CFADD__(v78, v75);
  uint64_t v79 = v80 + v75;
  v78 |= __CFADD__(v49, v79);
  v79 += v49;
  BOOL v82 = __CFADD__(v78, v63);
  unint64_t v81 = v82 + v73;
  int v83 = __CFADD__(v82, v73);
  a3[2] = v78 + v63;
  a3[3] = v81;
  *a3 = (-v83 & 0x26) + v77;
  a3[1] = v79;
  return result;
}

uint64_t ccec_der_import_diversified_pub(uint64_t *a1, uint64_t a2, unsigned __int8 *a3, _DWORD *a4, uint64_t **a5, uint64_t **a6)
{
  BOOL v30 = timingsafe_enable_if_supported();
  unint64_t v12 = &a3[a2];
  uint64_t v28 = 0;
  uint64_t v29 = v12;
  uint64_t v13 = ccder_decode_constructed_tl(0x2000000000000010, &v29, a3, v12);
  uint64_t v14 = ccder_decode_tl(4, (unint64_t *)&v28, v13, v29);
  unint64_t v15 = v14;
  if (v14) {
    uint64_t v16 = &v14[v28];
  }
  else {
    uint64_t v16 = 0;
  }
  if (v14) {
    uint64_t v17 = v28;
  }
  else {
    uint64_t v17 = 0;
  }
  uint64_t v18 = ccder_decode_tl(4, (unint64_t *)&v28, v16, v29);
  uint64_t v19 = &v18[v28];
  if (v18)
  {
    uint64_t v20 = v28;
  }
  else
  {
    uint64_t v19 = 0;
    uint64_t v20 = 0;
  }
  uint64_t v21 = 0xFFFFFFFFLL;
  if (v15)
  {
    unint64_t v22 = v18;
    if (v18 && v19 == v12)
    {
      int v24 = ccec_compact_import_pub(a1, v17, v15, a5);
      if (v24)
      {
        uint64_t v25 = ccec_import_pub(a1, v17, v15, a5);
        if (v25)
        {
          uint64_t v21 = v25;
          goto LABEL_23;
        }
        uint64_t v26 = ccec_import_pub(a1, v20, v22, a6);
      }
      else
      {
        uint64_t v26 = ccec_compact_import_pub(a1, v20, v22, a6);
      }
      uint64_t v21 = v26;
      if (a4 && !v26) {
        *a4 = 4 * (v24 == 0);
      }
    }
  }
LABEL_23:
  cc_disable_dit_with_sb((unsigned int *)&v30);
  return v21;
}

BOOL ccn_addn(uint64_t a1, void *a2, uint64_t *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v5 = a1 - a4;
  uint64_t v6 = &a2[a4];
  uint64_t v7 = &a3[a4];
  uint64_t v8 = ccn_add_ws(0, a4, a2, a3, a5);

  return ccn_add1_ws(0, v5, v6, v7, v8);
}

uint64_t ccn_recode_ssw(uint64_t result, uint64_t a2, char a3, uint64_t a4)
{
  uint64_t v4 = result << 6;
  if (result << 6)
  {
    unint64_t v5 = 0;
    do
    {
      *(unsigned char *)(a4 + v5) = (*(void *)(a2 + ((v5 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v5) & 1;
      ++v5;
    }
    while (v4 != v5);
    if ((int)v4 >= 1)
    {
      uint64_t v6 = 0;
      int v7 = 1 << (a3 - 1);
      int v8 = 1 << a3;
      int v9 = -(1 << a3);
      uint64_t v10 = (int)(result << 6);
      uint64_t v11 = a4 + 1;
      uint64_t result = 1;
      do
      {
        if (*(unsigned char *)(a4 + v6)) {
          BOOL v12 = v7 < 3;
        }
        else {
          BOOL v12 = 1;
        }
        if (!v12)
        {
          uint64_t v13 = v11;
          uint64_t v14 = 1;
          int v15 = result;
          do
          {
            uint64_t v16 = v14 + v6;
            if (v14 + v6 >= v10) {
              break;
            }
            if (*(unsigned char *)(a4 + v16))
            {
              int v17 = *(char *)(a4 + v16) << v14;
              int v18 = *(char *)(a4 + v6);
              if (v17 + v18 >= v8)
              {
                int v19 = v18 - v17;
                if (v19 <= v9) {
                  break;
                }
                uint64_t v20 = 0;
                *(unsigned char *)(a4 + v6) = v19;
                while (*(unsigned char *)(v13 + v20))
                {
                  *(unsigned char *)(v13 + v20++) = 0;
                  if (v15 + (int)v20 >= (int)v4) {
                    goto LABEL_21;
                  }
                }
                *(unsigned char *)(v13 + v20) = 1;
              }
              else
              {
                *(unsigned char *)(a4 + v6) = v17 + v18;
                *(unsigned char *)(a4 + v16) = 0;
              }
            }
LABEL_21:
            ++v14;
            ++v15;
            ++v13;
          }
          while (v14 != v7 - 1);
        }
        ++v6;
        ++result;
        ++v11;
      }
      while (v6 != (v4 & 0xFFFFFFC0));
    }
  }
  return result;
}

uint64_t ltc_des3_ecb_encrypt(uint64_t a1, uint64_t a2, unsigned int *a3, _DWORD *a4)
{
  uint64_t v14 = *MEMORY[0x263EF8C08];
  if (a2)
  {
    uint64_t v6 = a2;
    do
    {
      --v6;
      unsigned int v8 = *a3;
      unsigned int v9 = a3[1];
      a3 += 2;
      unsigned int v12 = bswap32(v8);
      unsigned int v13 = bswap32(v9);
      desfunc3(&v12, a1);
      unsigned int v10 = bswap32(v13);
      *a4 = bswap32(v12);
      a4[1] = v10;
      a4 += 2;
    }
    while (v6);
  }
  return 0;
}

uint64_t ccec_sign_composite_ws(uint64_t a1, unint64_t **a2, unint64_t a3, uint64_t a4, char *a5, char *a6, uint64_t (**a7)(void, unint64_t, void *))
{
  unint64_t v14 = **a2;
  uint64_t v15 = *(void *)(a1 + 16);
  uint64_t v16 = (unint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v14);
  int v17 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v14);
  uint64_t v18 = ccec_sign_internal_ws(a1, (uint64_t **)a2, a3, a4, v16, v17, a7);
  if (!v18)
  {
    unint64_t v19 = **a2;
    unint64_t v20 = ccec_signature_r_s_size((uint64_t *)a2);
    ccn_write_uint_padded_ct_internal(v19, v16, v20, a5);
    unint64_t v21 = **a2;
    unint64_t v22 = ccec_signature_r_s_size((uint64_t *)a2);
    ccn_write_uint_padded_ct_internal(v21, (unint64_t *)v17, v22, a6);
  }
  *(void *)(a1 + 16) = v15;
  return v18;
}

uint64_t ccec_sign_composite_msg_ws(uint64_t a1, unint64_t **a2, unint64_t *a3, size_t a4, char *a5, char *a6, char *a7, uint64_t (**a8)(void, unint64_t, void *))
{
  uint64_t v16 = *MEMORY[0x263EF8C08];
  ccdigest_internal((uint64_t)a3, a4, a5, (uint64_t)v15);
  return ccec_sign_composite_ws(a1, a2, *a3, (uint64_t)v15, a6, a7, a8);
}

uint64_t ccec_sign_composite_msg(unint64_t **a1, unint64_t *a2, size_t a3, char *a4, char *a5, char *a6, uint64_t (**a7)(void, unint64_t, void *))
{
  uint64_t v20 = *MEMORY[0x263EF8C08];
  BOOL v18 = timingsafe_enable_if_supported();
  v16[0] = cc_malloc_clear(280 * **a1);
  v16[1] = 35 * **a1;
  _OWORD v16[2] = 0;
  void v16[3] = cc_ws_alloc;
  int v17 = cc_ws_free;
  if (v16[0])
  {
    ccdigest_internal((uint64_t)a2, a3, a4, (uint64_t)v19);
    uint64_t v14 = ccec_sign_composite_ws((uint64_t)v16, a1, *a2, (uint64_t)v19, a5, a6, a7);
    v17((uint64_t)v16);
  }
  else
  {
    uint64_t v14 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return v14;
}

uint64_t ccec_sign_composite(unint64_t **a1, unint64_t a2, uint64_t a3, char *a4, char *a5, uint64_t (**a6)(void, unint64_t, void *))
{
  BOOL v17 = timingsafe_enable_if_supported();
  unsigned int v12 = *a1;
  v15[0] = cc_malloc_clear(280 * **a1);
  v15[1] = 35 * *v12;
  _OWORD v15[2] = 0;
  void v15[3] = cc_ws_alloc;
  uint64_t v16 = cc_ws_free;
  if (v15[0])
  {
    uint64_t v13 = ccec_sign_composite_ws((uint64_t)v15, a1, a2, a3, a4, a5, a6);
    v16((uint64_t)v15);
  }
  else
  {
    uint64_t v13 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v17);
  return v13;
}

uint64_t ccz_neg(uint64_t a1)
{
  BOOL v4 = timingsafe_enable_if_supported();
  if (ccz_n(a1))
  {
    int v2 = ccz_sign(a1);
    ccz_set_sign(a1, -v2);
  }
  return cc_disable_dit_with_sb((unsigned int *)&v4);
}

void *ccdh_gp_rfc2409group02()
{
  return &_ccdh_gp_rfc2409group02;
}

uint64_t cc_atfork_prepare()
{
  BOOL v1 = timingsafe_enable_if_supported();
  ccrng_atfork_prepare();
  return cc_disable_dit_with_sb((unsigned int *)&v1);
}

uint64_t ccder_blob_decode_len_strict(unsigned __int8 **a1, unint64_t *a2)
{
  return ccder_blob_decode_len_internal(a1, a2, 1);
}

uint64_t ccder_blob_decode_len_internal(unsigned __int8 **a1, unint64_t *a2, int a3)
{
  BOOL v4 = *a1;
  unint64_t v3 = (unint64_t)a1[1];
  if (*a1) {
    BOOL v5 = v3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5 || (unint64_t)v4 >= v3) {
    goto LABEL_10;
  }
  int v7 = v4 + 1;
  unint64_t v8 = *v4;
  if ((char)*v4 < 0)
  {
    switch(*v4)
    {
      case 0x81u:
        if ((uint64_t)(v3 - (void)v7) >= 1)
        {
          int v7 = v4 + 2;
          int v10 = (char)v4[1];
          unint64_t v8 = v10;
          if (!a3 || v10 < 0) {
            break;
          }
        }
        goto LABEL_10;
      case 0x82u:
        if ((uint64_t)(v3 - (void)v7) >= 2)
        {
          int v7 = v4 + 3;
          unint64_t v8 = __rev16(*(unsigned __int16 *)(v4 + 1));
          if (!a3 || v8 >= 0x100) {
            break;
          }
        }
        goto LABEL_10;
      case 0x83u:
        if ((uint64_t)(v3 - (void)v7) >= 3)
        {
          int v7 = v4 + 4;
          unint64_t v8 = ((unint64_t)v4[1] << 16) | ((unint64_t)v4[2] << 8) | v4[3];
          if (!a3 || v8 >= 0x10000) {
            break;
          }
        }
        goto LABEL_10;
      case 0x84u:
        if ((uint64_t)(v3 - (void)v7) >= 4)
        {
          int v7 = v4 + 5;
          unint64_t v8 = bswap32(*(_DWORD *)(v4 + 1));
          if (!a3 || v8 >> 24) {
            break;
          }
        }
        goto LABEL_10;
      default:
        goto LABEL_10;
    }
  }
  if (v3 - (unint64_t)v7 < v8)
  {
LABEL_10:
    uint64_t result = 0;
    *a2 = 0;
  }
  else
  {
    *a2 = v8;
    *a1 = v7;
    return 1;
  }
  return result;
}

uint64_t ccder_blob_decode_len(unsigned __int8 **a1, unint64_t *a2)
{
  return ccder_blob_decode_len_internal(a1, a2, 0);
}

uint64_t ccrng_schedule_read(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    return 3;
  }
  uint64_t result = (**(uint64_t (***)(uint64_t))a1)(a1);
  *(unsigned char *)(a1 + 8) = result == 3;
  return result;
}

uint64_t ccrng_schedule_notify_reseed(unsigned char *a1)
{
  a1[8] = 0;
  return (*(uint64_t (**)(unsigned char *))(*(void *)a1 + 8))(a1);
}

uint64_t ccrng_schedule_atomic_flag_init(uint64_t result)
{
  *(void *)uint64_t result = &ccrng_schedule_atomic_flag_info;
  *(unsigned char *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 1;
  return result;
}

uint64_t ccrng_schedule_atomic_flag_set(uint64_t result)
{
  *(_DWORD *)(result + 16) = 3;
  return result;
}

uint64_t ccrng_schedule_timer_init(uint64_t a1, uint64_t (*a2)(void), uint64_t a3)
{
  *(void *)a1 = &ccrng_schedule_timer_info;
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = a3;
  uint64_t result = a2();
  *(void *)(a1 + 32) = result;
  return result;
}

uint64_t ccrng_schedule_tree_init(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)uint64_t result = &ccrng_schedule_tree_info;
  *(unsigned char *)(result + 8) = 0;
  *(void *)(result + 16) = a2;
  *(void *)(result + 24) = a3;
  return result;
}

uint64_t ccrng_schedule_atomic_flag_read(uint64_t result)
{
  return result;
}

uint64_t ccrng_schedule_timer_read(uint64_t a1)
{
  if ((unint64_t)((*(uint64_t (**)(void))(a1 + 16))() - *(void *)(a1 + 32)) < *(void *)(a1 + 24)) {
    return 1;
  }
  else {
    return 3;
  }
}

uint64_t ccrng_schedule_timer_notify_reseed(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(a1 + 16))();
  *(void *)(a1 + 32) = result;
  return result;
}

uint64_t ccrng_schedule_tree_read(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (*(unsigned char *)(v2 + 8))
  {
    unsigned int v3 = 3;
  }
  else
  {
    unsigned int v3 = (**(uint64_t (***)(void))v2)(*(void *)(a1 + 16));
    *(unsigned char *)(v2 + 8) = v3 == 3;
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (*(unsigned char *)(v4 + 8))
  {
    LODWORD(result) = 3;
  }
  else
  {
    LODWORD(result) = (**(uint64_t (***)(uint64_t))v4)(v4);
    *(unsigned char *)(v4 + 8) = result == 3;
  }
  if (v3 <= result) {
    return result;
  }
  else {
    return v3;
  }
}

uint64_t ccrng_schedule_tree_notify_reseed(uint64_t a1)
{
  uint64_t v2 = *(unsigned char **)(a1 + 16);
  v2[8] = 0;
  (*(void (**)(unsigned char *))(*(void *)v2 + 8))(v2);
  unsigned int v3 = *(unsigned char **)(a1 + 24);
  v3[8] = 0;
  uint64_t v4 = *(uint64_t (**)(void))(*(void *)v3 + 8);

  return v4();
}

unint64_t ccn_trailing_zeros(unint64_t result, uint64_t a2)
{
  if (result)
  {
    unint64_t v2 = result;
    uint64_t result = 0;
    unint64_t v3 = v2 - 1;
    uint64_t v4 = (v2 << 6) - 64;
    do
    {
      unint64_t v5 = *(void *)(a2 + 8 * v3);
      uint64_t result = ((((v5 | HIDWORD(v5)) + 0xFFFFFFFF) >> 32) - 1) & result | (__clz(__rbit64(v5 | 0x8000000000000000))
                                                                                       + v4) & -(uint64_t)(((v5 | HIDWORD(v5)) + 0xFFFFFFFF) >> 32);
      --v3;
      v4 -= 64;
    }
    while (v3 < v2);
  }
  return result;
}

uint64_t cc_clear(rsize_t __n, void *__s)
{
  return memset_s(__s, __n, 0, __n);
}

uint64_t ccder_sizeof(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = ccder_sizeof_tag(a1);
  return v3 + a2 + ccder_sizeof_len(a2);
}

unint64_t ccder_sizeof_overflow(uint64_t a1, unint64_t a2, char *a3)
{
  if (*a3)
  {
    unint64_t result = 0;
    char v5 = 1;
  }
  else
  {
    uint64_t v7 = ccder_sizeof_tag(a1);
    uint64_t v8 = ccder_sizeof_len(a2);
    BOOL v9 = __CFADD__(v8 + v7, a2);
    unint64_t result = v8 + v7 + a2;
    char v5 = v9;
  }
  *a3 = v5;
  return result;
}

uint64_t cczp_power_ws(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5, void *a6)
{
  uint64_t v12 = cczp_n(a2);
  uint64_t v13 = cczp_prime(a2);
  if ((ccn_cmp_internal(v12, a4, v13) & 0x80000000) == 0) {
    return 4294967289;
  }
  uint64_t v19 = *(void *)(a1 + 16);
  uint64_t v15 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 4 * v12);
  uint64_t v16 = (uint64_t *)(*(uint64_t (**)(uint64_t))(a1 + 24))(a1);
  BOOL v17 = (unint64_t *)cczp_prime(a2);
  ccn_sub1(v12, v15, v17, 1uLL);
  cczp_to_ws(a1, a2);
  ccn_set(v12, &v15[v12], a4);
  cczp_sqr_ws(a1, a2);
  cczp_mul_ws(a1, a2);
  ccn_set(v12, a3, v15);
  unint64_t v18 = (a5 & 1) + a5;
  if (v18 >= 2)
  {
    do
    {
      cczp_sqr_ws(a1, a2);
      cczp_sqr_ws(a1, a2);
      ccn_mux(2 * v12, (*(void *)((char *)a6 + (((v18 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v18 - 1)) & 1, v16, &v15[2 * v12], v15);
      v18 -= 2;
      ccn_mux(v12, (*(void *)((char *)a6 + ((v18 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v18) & 1, v16, &v16[v12], v16);
      cczp_mul_ws(a1, a2);
    }
    while (v18 > 1);
  }
  cczp_cond_negate(a2, (*a6 & 3) == 0, (uint64_t *)a3, (unint64_t *)a3);
  uint64_t result = 0;
  *(void *)(a1 + 16) = v19;
  return result;
}

uint64_t ccccm_context_size(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t ccccm_block_size(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t ccccm_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(a1, a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccccm_set_iv(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v18 = timingsafe_enable_if_supported();
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 32))(a2, a3, a4, a5, a6, a7, a8);
  cc_disable_dit_with_sb((unsigned int *)&v18);
  return v16;
}

uint64_t ccccm_cbcmac(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 40))(a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccccm_aad(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 40))(a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccccm_update(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 48))(a2, a3, a4, a5, a6);
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v12;
}

uint64_t ccccm_encrypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v14 = timingsafe_enable_if_supported();
  if (*(unsigned char *)(a1 + 80)) {
    uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 48))(a2, a3, a4, a5, a6);
  }
  else {
    uint64_t v12 = 4294967228;
  }
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v12;
}

uint64_t ccccm_decrypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v14 = timingsafe_enable_if_supported();
  if (*(unsigned char *)(a1 + 80)) {
    uint64_t v12 = 4294967228;
  }
  else {
    uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 48))(a2, a3, a4, a5, a6);
  }
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v12;
}

uint64_t ccccm_finalize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56))(a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccccm_finalize_and_generate_tag(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  if (*(unsigned char *)(a1 + 80)) {
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56))(a2, a3, a4);
  }
  else {
    uint64_t v8 = 4294967228;
  }
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

unint64_t ccccm_finalize_and_verify_tag(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  unint64_t v8 = ccccm_finalize_and_verify_tag_internal(a1, a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

unint64_t ccccm_finalize_and_verify_tag_internal(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v8 = *MEMORY[0x263EF8C08];
  if (*(unsigned char *)(a1 + 80)) {
    return 4294967228;
  }
  unint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, char *))(a1 + 56))(a2, a3, __s);
  if (!result)
  {
    unint64_t result = cc_cmp_safe_internal(*(void *)(a3 + 88), __s, a4);
    if (result)
    {
      cc_clear(*(void *)(a3 + 88), __s);
      return 4294967227;
    }
  }
  return result;
}

uint64_t ccccm_reset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 64))(a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return v6;
}

uint64_t ccccm_one_shot_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  v29[1] = *MEMORY[0x263EF8C08];
  uint64_t v18 = MEMORY[0x270FA53B0](a1, a2, a2, a3);
  uint64_t v20 = (char *)v29 - v19;
  uint64_t v24 = MEMORY[0x270FA53B0](v18, v21, v22, v23);
  uint64_t v26 = (char *)v29 - v25;
  uint64_t v27 = (*(uint64_t (**)(uint64_t, char *))(v24 + 24))(v24, v20);
  if (!v27)
  {
    uint64_t v27 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 32))(v20, v26, a4, a5, a11, a9, a6);
    if (!v27)
    {
      uint64_t v27 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(a1 + 40))(v20, v26, a9, a10);
      if (!v27)
      {
        uint64_t v27 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t, uint64_t))(a1 + 48))(v20, v26, a6, a7, a8);
        if (!v27) {
          uint64_t v27 = (*(uint64_t (**)(char *, char *, uint64_t))(a1 + 56))(v20, v26, a12);
        }
      }
    }
  }
  cc_clear(*(void *)a1, v20);
  cc_clear(*(void *)(a1 + 8), v26);
  return v27;
}

uint64_t ccccm_one_shot(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  BOOL v22 = timingsafe_enable_if_supported();
  uint64_t v20 = ccccm_one_shot_internal(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
  cc_disable_dit_with_sb((unsigned int *)&v22);
  return v20;
}

uint64_t ccccm_one_shot_encrypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v37 = *MEMORY[0x263EF8C08];
  BOOL v20 = timingsafe_enable_if_supported();
  BOOL v36 = v20;
  if (*(unsigned char *)(a1 + 80))
  {
    uint64_t v35 = a7;
    uint64_t v24 = MEMORY[0x270FA53B0](v20, v21, v22, v23);
    uint64_t v26 = (char *)&v34 - v25;
    MEMORY[0x270FA53B0](v24, v27, v28, v29);
    BOOL v31 = (char *)&v34 - v30;
    uint64_t v32 = (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(a1 + 24))(a1, v26, a2, a3);
    if (!v32)
    {
      uint64_t v32 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 32))(v26, v31, a4, a5, a11, a9, a6);
      if (!v32)
      {
        uint64_t v32 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(a1 + 40))(v26, v31, a9, a10);
        if (!v32)
        {
          uint64_t v32 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t, uint64_t))(a1 + 48))(v26, v31, a6, v35, a8);
          if (!v32) {
            uint64_t v32 = (*(uint64_t (**)(char *, char *, uint64_t))(a1 + 56))(v26, v31, a12);
          }
        }
      }
    }
    cc_clear(*(void *)a1, v26);
    cc_clear(*(void *)(a1 + 8), v31);
  }
  else
  {
    uint64_t v32 = 4294967228;
  }
  cc_disable_dit_with_sb((unsigned int *)&v36);
  return v32;
}

unint64_t ccccm_one_shot_decrypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12)
{
  uint64_t v37 = *MEMORY[0x263EF8C08];
  BOOL v20 = timingsafe_enable_if_supported();
  BOOL v36 = v20;
  if (*(unsigned char *)(a1 + 80))
  {
    unint64_t v32 = 4294967228;
  }
  else
  {
    uint64_t v35 = a7;
    uint64_t v24 = MEMORY[0x270FA53B0](v20, v21, v22, v23);
    uint64_t v26 = (char *)&v34 - v25;
    MEMORY[0x270FA53B0](v24, v27, v28, v29);
    BOOL v31 = (char *)&v34 - v30;
    unint64_t v32 = (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(a1 + 24))(a1, v26, a2, a3);
    if (!v32)
    {
      unint64_t v32 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 32))(v26, v31, a4, a5, a11, a9, a6);
      if (!v32)
      {
        unint64_t v32 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(a1 + 40))(v26, v31, a9, a10);
        if (!v32)
        {
          unint64_t v32 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t, uint64_t))(a1 + 48))(v26, v31, a6, v35, a8);
          if (!v32) {
            unint64_t v32 = ccccm_finalize_and_verify_tag_internal(a1, (uint64_t)v26, (uint64_t)v31, a12);
          }
        }
      }
    }
    cc_clear(*(void *)a1, v26);
    cc_clear(*(void *)(a1 + 8), v31);
  }
  cc_disable_dit_with_sb((unsigned int *)&v36);
  return v32;
}

uint64_t ccec_extract_rs_ws(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned __int8 *a4, char *a5, char *a6)
{
  unint64_t v12 = *(void *)*a2;
  uint64_t v13 = *(void *)(a1 + 16);
  BOOL v14 = (unint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v12);
  uint64_t v15 = (unint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v12);
  if (ccder_decode_seqii(v12, v14, v15, a4, &a4[a3]) != &a4[a3]
    || a5
    && (unint64_t v16 = ccec_signature_r_s_size(a2), (ccn_write_uint_padded_ct_internal(v12, v14, v16, a5) & 0x80000000) != 0)
    || a6
    && (unint64_t v17 = ccec_signature_r_s_size(a2), (ccn_write_uint_padded_ct_internal(v12, v15, v17, a6) & 0x80000000) != 0))
  {
    uint64_t result = 4294967289;
  }
  else
  {
    uint64_t result = 0;
  }
  *(void *)(a1 + 16) = v13;
  return result;
}

uint64_t ccec_extract_rs(uint64_t *a1, uint64_t a2, unsigned __int8 *a3, char *a4, char *a5)
{
  BOOL v14 = timingsafe_enable_if_supported();
  v12[0] = cc_malloc_clear(16 * *(void *)*a1);
  v12[1] = 2 * *(void *)*a1;
  _OWORD v12[2] = 0;
  v12[3] = cc_ws_alloc;
  uint64_t v13 = cc_ws_free;
  if (v12[0])
  {
    rs_uint64_t ws = ccec_extract_rs_ws((uint64_t)v12, a1, a2, a3, a4, a5);
    v13((uint64_t)v12);
  }
  else
  {
    rs_uint64_t ws = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return rs_ws;
}

uint64_t ccec_verify_digest(unint64_t **a1, unint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, void *a6)
{
  BOOL v16 = timingsafe_enable_if_supported();
  v14[0] = cc_malloc_clear(376 * **a1);
  v14[1] = 47 * **a1;
  _OWORD v14[2] = 0;
  uint64_t v14[3] = cc_ws_alloc;
  uint64_t v15 = cc_ws_free;
  if (v14[0])
  {
    uint64_t v12 = ccec_verify_digest_ws((uint64_t)v14, a1, a2, a3, a4, a5, a6);
    v15((uint64_t)v14);
  }
  else
  {
    uint64_t v12 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v16);
  return v12;
}

uint64_t ccec_verify_digest_ws(uint64_t a1, unint64_t **a2, unint64_t a3, uint64_t a4, uint64_t a5, unsigned __int8 *a6, void *a7)
{
  uint64_t v20 = *MEMORY[0x263EF8C08];
  if (a7)
  {
    *a7 = 0;
    a7[1] = 0;
  }
  long long v19 = 0uLL;
  unint64_t v13 = **a2;
  uint64_t v14 = *(void *)(a1 + 16);
  uint64_t v15 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v13);
  BOOL v16 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v13);
  if (ccder_decode_seqii(v13, v15, v16, a6, &a6[a5]) == &a6[a5])
  {
    uint64_t result = ccec_verify_internal_ws(a1, a2, a3, a4, (uint64_t)v15, (uint64_t)v16, (uint64_t)&v19);
    if (a7 && !result) {
      *(_OWORD *)a7 = v19;
    }
  }
  else
  {
    uint64_t result = 4294967289;
  }
  *(void *)(a1 + 16) = v14;
  return result;
}

uint64_t ccec_verify_msg_ws(uint64_t a1, unint64_t **a2, unint64_t *a3, size_t a4, char *a5, uint64_t a6, unsigned __int8 *a7, void *a8)
{
  uint64_t v16 = *MEMORY[0x263EF8C08];
  ccdigest_internal((uint64_t)a3, a4, a5, (uint64_t)v15);
  return ccec_verify_digest_ws(a1, a2, *a3, (uint64_t)v15, a6, a7, a8);
}

uint64_t ccec_verify_msg(unint64_t **a1, unint64_t *a2, size_t a3, char *a4, uint64_t a5, unsigned __int8 *a6, void *a7)
{
  uint64_t v21 = *MEMORY[0x263EF8C08];
  BOOL v19 = timingsafe_enable_if_supported();
  uint64_t v14 = *a1;
  v17[0] = cc_malloc_clear(376 * **a1);
  v17[1] = 47 * *v14;
  _OWORD v17[2] = 0;
  void v17[3] = cc_ws_alloc;
  uint64_t v18 = cc_ws_free;
  if (v17[0])
  {
    ccdigest_internal((uint64_t)a2, a3, a4, (uint64_t)v20);
    uint64_t v15 = ccec_verify_digest_ws((uint64_t)v17, a1, *a2, (uint64_t)v20, a5, a6, a7);
    v18((uint64_t)v17);
  }
  else
  {
    uint64_t v15 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v19);
  return v15;
}

uint64_t ccec_verify(unint64_t **a1, unint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, BOOL *a6)
{
  BOOL v19 = timingsafe_enable_if_supported();
  *a6 = 0;
  v17[0] = cc_malloc_clear(376 * **a1);
  v17[1] = 47 * **a1;
  _OWORD v17[2] = 0;
  void v17[3] = cc_ws_alloc;
  uint64_t v18 = cc_ws_free;
  if (v17[0])
  {
    unsigned int v12 = ccec_verify_digest_ws((uint64_t)v17, a1, a2, a3, a4, a5, 0);
    v18((uint64_t)v17);
    if (v12 == -146) {
      unsigned int v13 = 0;
    }
    else {
      unsigned int v13 = v12;
    }
    BOOL v14 = v12 == 0;
    if (v12) {
      uint64_t v15 = v13;
    }
    else {
      uint64_t v15 = 0;
    }
    *a6 = v14;
  }
  else
  {
    uint64_t v15 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v19);
  return v15;
}

uint64_t ccec_x963_import_priv_size(uint64_t a1)
{
  BOOL v4 = timingsafe_enable_if_supported();
  if (a1 <= 96)
  {
    if (a1 == 73)
    {
      uint64_t v2 = 192;
      goto LABEL_13;
    }
    if (a1 == 85)
    {
      uint64_t v2 = 224;
      goto LABEL_13;
    }
LABEL_12:
    uint64_t v2 = 0;
    goto LABEL_13;
  }
  if (a1 == 97)
  {
    uint64_t v2 = 256;
    goto LABEL_13;
  }
  if (a1 == 145)
  {
    uint64_t v2 = 384;
    goto LABEL_13;
  }
  if (a1 != 199) {
    goto LABEL_12;
  }
  uint64_t v2 = 521;
LABEL_13:
  cc_disable_dit_with_sb((unsigned int *)&v4);
  return v2;
}

uint64_t ccec_x963_import_priv_ws(uint64_t a1, uint64_t *a2, unint64_t a3, unsigned __int8 *a4, uint64_t **a5)
{
  unsigned int v5 = *a4;
  BOOL v6 = v5 > 7;
  int v7 = (1 << v5) & 0xD0;
  if (v6 || v7 == 0) {
    return 4294967289;
  }
  BOOL v14 = a2 + 4;
  if (a3 < (unint64_t)(cczp_bitlen((uint64_t)&a2[5 * *a2 + 4]) + 7) >> 3) {
    return 4294967289;
  }
  uint64_t v15 = *(void *)(a1 + 16);
  uint64_t v16 = cczp_bitlen((uint64_t)&v14[5 * *a2]);
  uint64_t result = ccec_x963_import_pub_ws(a1, a2, a3 - ((unint64_t)(v16 + 7) >> 3), a4, a5);
  if (!result)
  {
    uint64_t v18 = *a2;
    uint64_t v19 = (uint64_t)&a5[3 * **a5 + 2];
    unint64_t v20 = (unint64_t)(cczp_bitlen((uint64_t)&v14[5 * *a2]) + 7) >> 3;
    uint64_t v21 = cczp_bitlen((uint64_t)a2);
    uint64_t result = ccn_read_uint_internal(v18, v19, v20, &a4[((unint64_t)(v21 + 7) >> 2) | 1]);
  }
  *(void *)(a1 + 16) = v15;
  return result;
}

uint64_t ccec_x963_import_priv(uint64_t *a1, unint64_t a2, unsigned __int8 *a3, uint64_t **a4)
{
  BOOL v14 = timingsafe_enable_if_supported();
  BOOL v8 = cc_malloc_clear(160 * *a1);
  uint64_t v9 = 20 * *a1;
  v12[0] = v8;
  v12[1] = v9;
  _OWORD v12[2] = 0;
  v12[3] = cc_ws_alloc;
  unsigned int v13 = cc_ws_free;
  if (v8)
  {
    uint64_t v10 = ccec_x963_import_priv_ws((uint64_t)v12, a1, a2, a3, a4);
    v13((uint64_t)v12);
  }
  else
  {
    uint64_t v10 = 4294967283;
  }
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v10;
}

uint64_t ccmode_siv_hmac_reset(uint64_t a1)
{
  *(void *)(a1 + 24) = 2;
  return 0;
}

uint64_t ccmode_ccm_macdata(uint64_t result, uint64_t a2, int a3, unint64_t a4, uint64_t a5)
{
  uint64_t v8 = result;
  unsigned int v9 = *(_DWORD *)(*(void *)result + 8);
  if (a3)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)result + 24))(result + 8, 1, a2 + 16, a2 + 16);
    unsigned int v10 = 0;
    *(_DWORD *)(a2 + 72) = 0;
  }
  else
  {
    unsigned int v10 = *(_DWORD *)(a2 + 72);
  }
  uint64_t v17 = a2;
  if (a4)
  {
    unint64_t v11 = 0;
    uint64_t v12 = a2 + 16;
    uint64_t v13 = a5 - 1;
    uint64_t v14 = a2 + 15;
    do
    {
      if (a4 - v11 >= v9 - v10) {
        unint64_t v15 = v9 - v10;
      }
      else {
        unint64_t v15 = a4 - v11;
      }
      if (v15)
      {
        unint64_t v16 = v15;
        do
        {
          *(unsigned char *)(v14 + v10 + v16) ^= *(unsigned char *)(v13 + v11 + v16);
          --v16;
        }
        while (v16);
      }
      unsigned int v10 = (v10 + v15) % v9;
      if (!v10) {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v8 + 24))(v8 + 8, 1, v12, v12);
      }
      v11 += v15;
    }
    while (v11 < a4);
  }
  *(_DWORD *)(v17 + 72) = v10;
  return result;
}

uint64_t ccmode_ccm_cbcmac(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (a3 && *(_DWORD *)(a2 + 64) != 4) {
    return 4294967228;
  }
  ccmode_ccm_macdata(a1, a2, 0, a3, a4);
  return 0;
}

void cced25519_sign_with_rng_internal_cold_1(os_log_t log)
{
  *(_WORD *)BOOL v1 = 0;
  _os_log_fault_impl(&dword_237334000, log, OS_LOG_TYPE_FAULT, "cced25519_sign: pk != sk * G", v1, 2u);
}

void ccec_sign_internal_ws_cold_1(uint64_t a1, NSObject *a2)
{
  uint64_t v4 = *MEMORY[0x263EF8C08];
  int v2 = 134217984;
  uint64_t v3 = a1;
  _os_log_fault_impl(&dword_237334000, a2, OS_LOG_TYPE_FAULT, "Digest should be at least 128 bits long: argument digest_len = %lu", (uint8_t *)&v2, 0xCu);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x270EDCEE0]();
}

uint64_t __memset_chk()
{
  return MEMORY[0x270EDCEE8]();
}

uint64_t __udivti3()
{
  return MEMORY[0x270EDC490]();
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _os_once()
{
  return MEMORY[0x270EDDBB0]();
}

void abort(void)
{
}

void bzero(void *a1, size_t a2)
{
}

__uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
{
  return MEMORY[0x270EDD030](*(void *)&__clock_id);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x270EDD0C8](a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x270EDD0D0](*(void *)&a1, a2);
}

void free(void *a1)
{
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x270EDD128](__ptr, __size, __nitems, __stream);
}

int getentropy(void *buffer, size_t size)
{
  return MEMORY[0x270EDD6C8](buffer, size);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x270EDD768]();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x270EDD838](info);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDDB08](size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x270EDD180](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDD188](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDD190](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x270EDD198](__b, *(void *)&__c, __len);
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  return MEMORY[0x270EDD1A8](__s, __smax, *(void *)&__c, __n);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x270EDDD40](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDDD50](oslog, type);
}

void os_unfair_lock_assert_owner(const os_unfair_lock *lock)
{
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

int printf(const char *a1, ...)
{
  return MEMORY[0x270EDD1D0](a1);
}

int putchar(int a1)
{
  return MEMORY[0x270EDD1D8](*(void *)&a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x270EDD268](__str, __size, __format);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x270EDD2A0](__s1, __s2);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x270EDD2E0](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x270EDD2F0](__s1, __s2, __n);
}