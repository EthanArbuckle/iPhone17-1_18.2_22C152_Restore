uint64_t processEntryThreadProc()
{
  uint64_t v0;
  uint64_t *v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  size_t v6;
  size_t v7;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void **v12;
  char *v13;
  void *v14;
  void *v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  void *v27;
  void *v28;
  const char *v29;
  uint64_t v30;
  unsigned int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  const char *v42;
  __int16 v43;
  int v44;
  const char *v45;
  FILE *v46;
  uint64_t v47;
  uint64_t v48;
  int AAEntryType;
  uint64_t v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  void (*v54)(void, unsigned char *);
  uint64_t v55;
  uint64_t v56;
  const char *v57;
  __int16 v58;
  int v59;
  const char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  mode_t st_mode;
  uint64_t v65;
  uint64_t v66;
  int FileProtectionClass;
  int v68;
  uint64_t v69;
  long long v70;
  uint64_t v71;
  char v72;
  int v73;
  int v74;
  unsigned __int8 *FreePtr;
  size_t FreeSize;
  int v77;
  unsigned __int8 *v78;
  ssize_t v79;
  ssize_t v80;
  char v81;
  BOOL v82;
  ssize_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  __int16 v87;
  const char *v88;
  int *v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  ssize_t v94;
  size_t v95;
  ssize_t v96;
  size_t v97;
  char *v98;
  uint64_t DataSize;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  ssize_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  void *v110;
  size_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t DataPtr;
  int v119;
  _acl *file;
  int v121;
  const unsigned __int8 *qualifier;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  int v140;
  uint64_t v141;
  const void *v142;
  size_t v143;
  int v144;
  uint64_t v145;
  uint64_t v146;
  FILE *v147;
  uint64_t v148;
  int v149;
  uint64_t v150;
  uint64_t v151;
  __int16 v152;
  const char *v153;
  char *v154;
  uint64_t v155;
  uint64_t v156;
  char *v157;
  unsigned char *v158;
  unint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  size_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  size_t v174;
  const void *v175;
  size_t v176;
  FILE *v177;
  uint64_t v178;
  int *v180;
  uint64_t v181;
  uint64_t v182;
  const char *v183;
  __int16 v184;
  char *v185;
  char v186;
  ssize_t v187;
  uint64_t v188;
  int64_t v189;
  size_t v190;
  size_t v191;
  char *name;
  int namea;
  char *nameb;
  char *namec;
  char *__ptr;
  _acl *__ptra;
  void *__ptrb;
  uint64_t v199;
  size_t size;
  size_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  int v205;
  size_t v206;
  pthread_mutex_t *v207;
  void **v208;
  char *v209;
  char *string;
  void *v211;
  void *v212;
  passwd *v213;
  passwd v214;
  int id_type[2];
  acl_flagset_t flagset_p;
  acl_permset_mask_t mask_p;
  acl_tag_t tag_type_p;
  acl_entry_t entry_p;
  CC_SHA1_CTX c;
  stat v221;
  unsigned char v222[112];
  long long v223;
  long long v224;
  long long v225;
  long long v226;
  long long v227;
  long long v228;
  long long v229;
  long long v230;
  long long v231;
  long long v232;
  long long v233;
  char path[2048];
  char v235[1024];
  long long v236[512];
  uint64_t v237;

  v0 = MEMORY[0x270FA5388]();
  v237 = *MEMORY[0x263EF8340];
  v1 = *(uint64_t **)v0;
  v2 = *(_DWORD *)(*(void *)v0 + 16);
  if (v2 >= 3) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "[%d] Entry processing thread starting\n", *(_DWORD *)(v0 + 8));
  }
  memset(&v221, 0, sizeof(v221));
  saveThreadErrorContext(v236);
  v3 = sysconf(71);
  v4 = sysconf(70);
  if (v3 <= v4) {
    v5 = v4;
  }
  else {
    v5 = v3;
  }
  if (v5 <= 4096) {
    v6 = 4096;
  }
  else {
    v6 = v5;
  }
  v7 = *(void *)(*v1 + 40);
  v8 = *(void *)(*v1 + 48);
  bzero(v235, 0x400uLL);
  bzero(path, 0x800uLL);
  v9 = v1[131];
  __memcpy_chk();
  path[v9] = 47;
  v209 = &path[v9 + 1];
  v12 = MemBufferCreate(0x40000uLL);
  if (!v12)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 244, 12, 0, "alloc writer buffer", v10, v11, (char)v185);
    ++*(void *)(v0 + 32);
  }
  v13 = (char *)malloc(v6);
  if (v13)
  {
    if (v7) {
      goto LABEL_13;
    }
LABEL_19:
    v14 = 0;
    if (v8) {
      goto LABEL_15;
    }
    goto LABEL_20;
  }
  v19 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 246, 12, *v19, "malloc", v20, v21, (char)v185);
  v6 = 0;
  ++*(void *)(v0 + 32);
  if (!v7) {
    goto LABEL_19;
  }
LABEL_13:
  v14 = calloc(v7, 0x408uLL);
  if (v14)
  {
    if (v8)
    {
LABEL_15:
      v15 = malloc(v8);
      if (!v15)
      {
        v16 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 255, 12, *v16, "malloc", v17, v18, (char)v185);
        v15 = 0;
        v8 = 0;
        ++*(void *)(v0 + 32);
      }
      v211 = v15;
      v206 = v8;
      bzero(v15, v8);
      goto LABEL_21;
    }
  }
  else
  {
    v180 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 250, 12, *v180, "malloc", v181, v182, (char)v185);
    v7 = 0;
    ++*(void *)(v0 + 32);
    if (v8) {
      goto LABEL_15;
    }
  }
LABEL_20:
  v206 = 0;
  v211 = 0;
LABEL_21:
  v212 = v14;
  v22 = *(_DWORD *)(v0 + 8);
  string = v13;
  if (pthread_mutex_lock((pthread_mutex_t *)(v1 + 143)))
  {
    v26 = 0;
    goto LABEL_23;
  }
  v207 = (pthread_mutex_t *)(v1 + 143);
  v201 = 0;
  v26 = 0;
  v202 = 0;
  v199 = v0 + 160;
  size = 0;
  v29 = "processEntryThreadProc";
  v205 = v2;
  v208 = v12;
  while (1)
  {
    v30 = *((unsigned int *)v1 + 282);
    v31 = *((_DWORD *)v1 + 283);
    v32 = v30;
    if (v30 < v31)
    {
      *(_DWORD *)(v1[142] + 4 * v30) = v22;
      v32 = *((_DWORD *)v1 + 282);
    }
    *((_DWORD *)v1 + 282) = v32 + 1;
    if (!v32)
    {
      if (pthread_cond_broadcast((pthread_cond_t *)(v1 + 151))) {
        break;
      }
    }
    if (pthread_mutex_unlock(v207))
    {
      v183 = "SharedArrayPush: pthread_mutex_unlock failed\n";
      v184 = 124;
      goto LABEL_244;
    }
    if (v30 >= v31)
    {
      v183 = "SharedArrayPush: stack is full\n";
      v184 = 125;
      goto LABEL_244;
    }
    v2 = v205;
    v12 = v208;
    if (pthread_mutex_lock((pthread_mutex_t *)(v0 + 48))) {
      goto LABEL_233;
    }
    while (1)
    {
      v36 = *(_DWORD *)(v0 + 40);
      if (v36 > 0) {
        break;
      }
      if (pthread_cond_wait((pthread_cond_t *)(v0 + 112), (pthread_mutex_t *)(v0 + 48))) {
        goto LABEL_233;
      }
    }
    *(_DWORD *)(v0 + 40) = v36 - 1;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v0 + 48)))
    {
LABEL_233:
      v28 = v212;
      v27 = (void *)(v0 + 32);
      goto LABEL_234;
    }
    v37 = *(void *)(v0 + 24);
    if (v37 < 0)
    {
      v28 = v212;
      goto LABEL_235;
    }
    v204 = v1[134];
    v38 = ArchiveTreeNodePath(v1[132], v37, (uint64_t)v209, 2047 - v1[131]);
    v203 = v37;
    if (v38 < 0)
    {
      v41 = v29;
      v42 = v29;
      v43 = 276;
      v44 = 0;
      v45 = "full entry path is too long";
      goto LABEL_47;
    }
    if (v205 < 3)
    {
      if (v205 == 2)
      {
        v46 = (FILE *)*MEMORY[0x263EF8348];
        if (v38) {
          fprintf(v46, "%s\n");
        }
        else {
          fwrite(".\n", 2uLL, 1uLL, v46);
        }
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x263EF8348], "[%d] processing entry %s\n");
    }
    *(_DWORD *)(v204 + 280 * v37 + 192) = *(_DWORD *)(v0 + 8);
    if (lstat(path, &v221))
    {
      v44 = *__error();
      v185 = path;
      v41 = v29;
      v42 = v29;
      v43 = 289;
      v45 = "%s";
      goto LABEL_47;
    }
    __ptr = v26;
    AAEntryType = getAAEntryType(v221.st_mode);
    v52 = AAEntryType;
    v53 = *v1;
    v54 = *(void (**)(void, unsigned char *))(*v1 + 64);
    if (v54)
    {
      *(_DWORD *)&v222[12] = 0;
      *(void *)v222 = v209;
      *(_DWORD *)&v222[8] = AAEntryType;
      *(void *)&v222[16] = v212;
      *(void *)&v222[24] = v7;
      *(void *)&v222[32] = 0;
      *(void *)&v222[40] = v211;
      *(_OWORD *)&v222[48] = v206;
      v54(*(void *)(v53 + 72), v222);
      v201 = *(void *)&v222[56];
      v202 = *(void *)&v222[32];
    }
    v55 = v203;
    *(_DWORD *)(v204 + 280 * v203) = v52;
    if (!v52)
    {
      LOBYTE(v185) = v221.st_mode;
      v41 = v29;
      v57 = v29;
      v58 = 318;
      v59 = 0;
      v60 = "file type is not supported (st_mode=0%o): %s";
      goto LABEL_57;
    }
    v56 = v204 + 280 * v203;
    *(void *)(v56 + 80) = v221.st_ino;
    *(_WORD *)(v56 + 72) = v221.st_nlink;
    name = (char *)v56;
    if (v52 == 70)
    {
      *(void *)(v204 + 280 * v203 + 96) = v221.st_size;
    }
    else
    {
      if ((v52 & 0xFFFFFFFE) != 0x42)
      {
        v82 = v52 == 76;
        v55 = v203;
        v61 = v204;
        if (v82)
        {
          v83 = readlink(path, v235, 0x3FFuLL);
          if (v83 < 0)
          {
            v144 = *__error();
            v41 = v29;
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)v29, 328, 12, v144, "%s", v145, v146, (char)path);
            goto LABEL_185;
          }
          if (!v83)
          {
            v185 = path;
            v41 = v29;
            v86 = (uint64_t)v29;
            v87 = 329;
            v88 = "readlink returned an empty string: %s";
LABEL_184:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", v86, v87, 12, 0, v88, v84, v85, (char)v185);
LABEL_185:
            v12 = v208;
            goto LABEL_58;
          }
          v235[v83] = 0;
          v61 = v204;
          if (BlobBufferStore(v199, v235, v83 + 1, (void *)(v204 + 280 * v203 + 200)))
          {
            v41 = v29;
            v86 = (uint64_t)v29;
            v87 = 333;
            v88 = "storing link";
            goto LABEL_184;
          }
        }
        goto LABEL_62;
      }
      v55 = v203;
      *(_DWORD *)(v204 + 280 * v203 + 88) = v221.st_rdev;
    }
    v61 = v204;
LABEL_62:
    v62 = v61 + 280 * v55;
    v63 = *(void *)&v221.st_uid;
    st_mode = v221.st_mode;
    *(_OWORD *)(v62 + 24) = 0u;
    v65 = v62 + 24;
    *(void *)(v65 + 36) = v63;
    *(_DWORD *)(v65 - 20) = st_mode & 0xFFF;
    *(_OWORD *)(v65 + 16) = 0u;
    *(_DWORD *)(v65 + 44) = v221.st_flags;
    *(timespec *)(v65 - 16) = v221.st_mtimespec;
    *(void *)&c.h2 = 0;
    *(void *)&c.h4 = 0;
    memset(v222, 0, 64);
    c.h0 = 5;
    c.h1 = 8704;
    v66 = v55;
    if (!getattrlist(path, &c, v222, 0x40uLL, 1u) && *(_DWORD *)v222 == 36)
    {
      *(_OWORD *)v65 = *(_OWORD *)&v222[4];
      *(_OWORD *)(v204 + 280 * v55 + 40) = *(_OWORD *)&v222[20];
    }
    FileProtectionClass = getFileProtectionClass(path);
    if ((FileProtectionClass - 1) >= 6) {
      v68 = 0;
    }
    else {
      v68 = FileProtectionClass + 64;
    }
    v69 = v204 + 280 * v55;
    *(void *)&v70 = -1;
    *((void *)&v70 + 1) = -1;
    *(_OWORD *)(v69 + 104) = v70;
    v71 = v69 + 104;
    *(_DWORD *)(v71 - 48) = v68;
    *(_OWORD *)(v71 + 16) = v70;
    if (*(_DWORD *)name != 70) {
      goto LABEL_103;
    }
    *(void *)&v222[8] = 0;
    *(void *)v222 = 0;
    if (!fsctl(path, 0x40104A0EuLL, v222, 0) && *(void *)v222 == 2) {
      *(void *)v71 = *(void *)&v222[8];
    }
    if (!v208) {
      goto LABEL_103;
    }
    if (*(_DWORD *)name != 70) {
      goto LABEL_103;
    }
    v72 = *((unsigned char *)v1 + 1080);
    if ((v72 & 7) == 0) {
      goto LABEL_103;
    }
    v214.pw_name = 0;
    v214.pw_passwd = 0;
    memset(&c, 0, sizeof(c));
    memset(v222, 0, 104);
    if (v72)
    {
      CC_CKSUM_Init((uint64_t)&v214);
      v72 = *((unsigned char *)v1 + 1080);
    }
    if ((v72 & 2) != 0)
    {
      CC_SHA1_Deprecated_Init(&c);
      v72 = *((unsigned char *)v1 + 1080);
    }
    v12 = v208;
    if ((v72 & 4) != 0) {
      CC_SHA256_Init((CC_SHA256_CTX *)v222);
    }
    v73 = open(path, 0);
    if (v73 < 0)
    {
      v59 = *__error();
      v185 = path;
      v41 = v29;
      v57 = v29;
      v58 = 413;
      goto LABEL_195;
    }
    v74 = v73;
    MemBufferClear(v208);
    FreePtr = (unsigned __int8 *)MemBufferGetFreePtr((uint64_t)v208);
    FreeSize = MemBufferGetFreeSize(v208);
    namea = v74;
    v77 = v74;
    v78 = FreePtr;
    v190 = FreeSize;
    v79 = read(v77, FreePtr, FreeSize);
    if (v79 < 0)
    {
LABEL_101:
      v89 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)v29, 421, 12, *v89, "%s", v90, v91, (char)path);
      v66 = v203;
      v92 = namea;
      goto LABEL_102;
    }
    v80 = v79;
    while (1)
    {
      v81 = *((unsigned char *)v1 + 1080);
      if (!v80) {
        break;
      }
      if (v1[135])
      {
        CC_CKSUM_Update((uint64_t)&v214, v78, v80);
        v81 = *((unsigned char *)v1 + 1080);
        if ((v81 & 2) != 0)
        {
LABEL_92:
          CC_SHA1_Deprecated_Update(&c, v78, v80);
          if ((v1[135] & 4) == 0) {
            goto LABEL_89;
          }
LABEL_88:
          CC_SHA256_Update((CC_SHA256_CTX *)v222, v78, v80);
          goto LABEL_89;
        }
      }
      else if ((v1[135] & 2) != 0)
      {
        goto LABEL_92;
      }
      if ((v81 & 4) != 0) {
        goto LABEL_88;
      }
LABEL_89:
      v80 = read(namea, v78, v190);
      if (v80 < 0) {
        goto LABEL_101;
      }
    }
    v66 = v203;
    if (v1[135])
    {
      CC_CKSUM_Final((unsigned int *)(v204 + 280 * v203 + 136), (uint64_t)&v214);
      v81 = *((unsigned char *)v1 + 1080);
    }
    v92 = namea;
    if ((v81 & 2) != 0)
    {
      CC_SHA1_Deprecated_Final((unsigned __int8 *)(v204 + 280 * v203 + 140), &c);
      v81 = *((unsigned char *)v1 + 1080);
    }
    if ((v81 & 4) != 0) {
      CC_SHA256_Final((unsigned __int8 *)(v204 + 280 * v203 + 160), (CC_SHA256_CTX *)v222);
    }
LABEL_102:
    close(v92);
LABEL_103:
    if ((*(unsigned char *)(*v1 + 33) & 4) != 0)
    {
      v12 = v208;
      MemBufferClear(v208);
      v94 = listxattr(path, 0, 0, 1);
      if (v94 >= 1)
      {
        v95 = size;
        if (v94 <= size)
        {
          v26 = __ptr;
        }
        else
        {
          size = v94;
          v26 = (char *)reallocf(__ptr, v94);
          if (!v26)
          {
            v44 = *__error();
            v41 = v29;
            v42 = v29;
            v43 = 455;
            v45 = "malloc";
            goto LABEL_47;
          }
          v95 = size;
        }
        size = v95;
        v96 = listxattr(path, v26, v95, 1);
        __ptr = v26;
        if (v96 >= 1)
        {
          v97 = 0;
          v187 = v96;
          do
          {
            v98 = &__ptr[v97];
            if (__ptr[v97])
            {
              ++v97;
              v12 = v208;
            }
            else
            {
              v191 = v97;
              nameb = v26;
              *(void *)v222 = 0;
              DataSize = MemBufferGetDataSize((uint64_t)v208);
              if (MemBufferFillFromBufferWithCapacityIncrease((unint64_t *)v208, 4uLL, v222) < 0)
              {
                v41 = "processEntryThreadProc";
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 479, 12, 0, "inserting XAT xsize: %s", v100, v101, (char)path);
                v12 = v208;
                goto LABEL_58;
              }
              v189 = v98 - v26;
              v102 = MemBufferFillFromBufferWithCapacityIncrease((unint64_t *)v208, v98 - v26 + 1, v26);
              v12 = v208;
              if (v102 < 0)
              {
                v41 = "processEntryThreadProc";
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 480, 12, 0, "inserting XAT xname: %s", v103, v104, (char)path);
                goto LABEL_58;
              }
              v188 = DataSize;
              v105 = getxattr(path, v26, 0, 0, 0, 1);
              if (v105 < 0)
              {
                v59 = *__error();
                v185 = path;
                v41 = "processEntryThreadProc";
                v57 = "processEntryThreadProc";
                v58 = 488;
LABEL_195:
                v60 = "%s";
LABEL_57:
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)v57, v58, 12, v59, v60, v50, v51, (char)v185);
                goto LABEL_58;
              }
              v106 = v105;
              v107 = MemBufferGetDataSize((uint64_t)v208);
              if ((MemBufferIncreaseCapacity((uint64_t)v208, v107 + v106) & 0x8000000000000000) != 0)
              {
                v41 = "processEntryThreadProc";
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 492, 12, 0, "increasing XAT buffer capacity: %s", v108, v109, (char)path);
                goto LABEL_58;
              }
              v110 = (void *)MemBufferGetFreePtr((uint64_t)v208);
              v111 = MemBufferGetFreeSize(v208);
              if (getxattr(path, nameb, v110, v111, 0, 1) < 0)
              {
                v59 = *__error();
                v41 = "processEntryThreadProc";
                v57 = "processEntryThreadProc";
                v58 = 500;
                v60 = "getxattr";
                goto LABEL_57;
              }
              if (MemBufferIncreaseSize((unint64_t *)v208, v106, v112, v113, v114, v115, v116, v117) < 0)
              {
                v41 = "processEntryThreadProc";
                v57 = "processEntryThreadProc";
                v58 = 501;
                v59 = 0;
                v60 = "invalid size increase";
                goto LABEL_57;
              }
              *(void *)v222 = v189 + v106 + 5;
              if (*(_DWORD *)&v222[4])
              {
                v186 = v106;
                v41 = "processEntryThreadProc";
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 505, 12, 0, "XAT value is too long to be stored in YAA archive (%zd B): %s", v50, v51, v186);
LABEL_58:
                v26 = __ptr;
LABEL_48:
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)v41, 680, 12, 0, "processing failed for entry %zd\n", v47, v48, *(void *)(v0 + 24));
                ++*(void *)(v0 + 32);
                *(_DWORD *)(v204 + 280 * v203 + 196) = 1;
                v29 = v41;
                goto LABEL_49;
              }
              DataPtr = MemBufferGetDataPtr((uint64_t)v208);
              *(_DWORD *)(DataPtr + v188) = *(_DWORD *)v222;
              v97 = v191 + 1;
              v26 = &__ptr[v191 + 1];
              v66 = v203;
              v96 = v187;
            }
          }
          while (v97 != v96);
        }
      }
      v93 = v202;
      if (MemBufferIsEmpty((uint64_t)v12))
      {
        v26 = __ptr;
      }
      else
      {
        v141 = v66;
        v142 = (const void *)MemBufferGetDataPtr((uint64_t)v12);
        v143 = MemBufferGetDataSize((uint64_t)v12);
        if (BlobBufferStore(v199, v142, v143, (void *)(v204 + 280 * v141 + 216)))
        {
          v41 = "processEntryThreadProc";
          v57 = "processEntryThreadProc";
          v58 = 517;
          v59 = 0;
          v60 = "storing XAT";
          goto LABEL_57;
        }
        v26 = __ptr;
        if (v205 >= 3)
        {
          v147 = (FILE *)*MEMORY[0x263EF8348];
          v148 = MemBufferGetDataSize((uint64_t)v12);
          fprintf(v147, "XAT blob [%zu] stored for %s\n", v148, path);
        }
        v66 = v203;
      }
    }
    else
    {
      v12 = v208;
      v26 = __ptr;
      v93 = v202;
    }
    if ((*(unsigned char *)(*v1 + 33) & 8) == 0) {
      goto LABEL_208;
    }
    v119 = v221.st_mode & 0xF000;
    if (v119 != 0x8000 && v119 != 0x4000) {
      goto LABEL_208;
    }
    MemBufferClear(v12);
    file = acl_get_file(path, ACL_TYPE_EXTENDED);
    if (!file) {
      goto LABEL_207;
    }
    entry_p = 0;
    v232 = 0u;
    v233 = 0u;
    v230 = 0u;
    v231 = 0u;
    v228 = 0u;
    v229 = 0u;
    v226 = 0u;
    v227 = 0u;
    v224 = 0u;
    v225 = 0u;
    v223 = 0u;
    memset(v222, 0, sizeof(v222));
    __ptra = file;
    if (acl_get_entry(file, 0, &entry_p)) {
      goto LABEL_206;
    }
    v121 = 1;
    while (2)
    {
      tag_type_p = ACL_UNDEFINED_TAG;
      flagset_p = 0;
      mask_p = 0;
      *(void *)id_type = 0;
      memset(&c, 0, 72);
      memset(v222, 0, sizeof(v222));
      v223 = 0u;
      v224 = 0u;
      v225 = 0u;
      v226 = 0u;
      v227 = 0u;
      v228 = 0u;
      v229 = 0u;
      v230 = 0u;
      v231 = 0u;
      v232 = 0u;
      v233 = 0u;
      if (acl_get_tag_type(entry_p, &tag_type_p))
      {
        v149 = *__error();
        v152 = 551;
        v153 = "acl_get_tag_type";
LABEL_204:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", v152, 12, v149, v153, v150, v151, (char)v185);
        v154 = 0;
        goto LABEL_205;
      }
      if (tag_type_p - 1 >= 2)
      {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Warning: ACL tag type is not ALLOW/DENY (ignoring entry): %d\n", tag_type_p);
LABEL_160:
        if (acl_get_entry(__ptra, v121++, &entry_p)) {
          goto LABEL_206;
        }
        continue;
      }
      break;
    }
    *(_DWORD *)v222 = tag_type_p;
    if (acl_get_flagset_np(entry_p, &flagset_p))
    {
      v149 = *__error();
      v152 = 558;
      v153 = "acl_get_flagset_np";
      goto LABEL_204;
    }
    if (acl_get_flag_np(flagset_p, ACL_FLAG_NO_INHERIT)) {
      *(void *)&v222[16] |= 0x20000uLL;
    }
    if (acl_get_flag_np(flagset_p, ACL_ENTRY_INHERITED)) {
      *(void *)&v222[16] |= 0x10uLL;
    }
    if (acl_get_flag_np(flagset_p, ACL_ENTRY_FILE_INHERIT)) {
      *(void *)&v222[16] |= 0x20uLL;
    }
    if (acl_get_flag_np(flagset_p, ACL_ENTRY_DIRECTORY_INHERIT)) {
      *(void *)&v222[16] |= 0x40uLL;
    }
    if (acl_get_flag_np(flagset_p, ACL_ENTRY_LIMIT_INHERIT)) {
      *(void *)&v222[16] |= 0x80uLL;
    }
    if (acl_get_flag_np(flagset_p, ACL_ENTRY_ONLY_INHERIT)) {
      *(void *)&v222[16] |= 0x100uLL;
    }
    if (acl_get_permset_mask_np(entry_p, &mask_p))
    {
      v149 = *__error();
      v152 = 569;
      v153 = "acl_get_permset_mask_np";
      goto LABEL_204;
    }
    *(void *)&v222[8] = mask_p & 0x103FFE;
    qualifier = (const unsigned __int8 *)acl_get_qualifier(entry_p);
    if (!qualifier)
    {
      v149 = *__error();
      v152 = 574;
      v153 = "acl_get_qualifier";
      goto LABEL_204;
    }
    namec = (char *)qualifier;
    if (!*(_DWORD *)&v222[24])
    {
      if (mbr_uuid_to_id(qualifier, (id_t *)&id_type[1], id_type)) {
        goto LABEL_150;
      }
      if (id_type[0] == 1)
      {
        memset(&v214, 0, 32);
        v213 = 0;
        if (!getgrgid_r(id_type[1], (group *)&v214, string, v6, (group **)&v213)
          && v213
          && v214.pw_name
          && strlen(v214.pw_name) <= 0xFF)
        {
          v140 = 2;
LABEL_174:
          *(_DWORD *)&v222[24] = v140;
          __strlcpy_chk();
        }
      }
      else if (!id_type[0])
      {
        memset(&v214, 0, sizeof(v214));
        v213 = 0;
        if (!getpwuid_r(id_type[1], &v214, string, v6, &v213) && v213 && v214.pw_name && strlen(v214.pw_name) <= 0xFF)
        {
          v140 = 1;
          goto LABEL_174;
        }
      }
LABEL_150:
      if (!*(_DWORD *)&v222[24])
      {
        if (!mbr_uuid_to_sid((const unsigned __int8 *)namec, (nt_sid_t *)&c)
          && !mbr_sid_to_string((const nt_sid_t *)&c, string)
          && strlen(string) <= 0xFF)
        {
          *(_DWORD *)&v222[24] = 3;
          __strlcpy_chk();
        }
        if (!*(_DWORD *)&v222[24])
        {
          *(_DWORD *)&v222[24] = 4;
          uuid_unparse_upper((const unsigned __int8 *)namec, &v222[28]);
          if (!*(_DWORD *)&v222[24])
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 616, 12, 0, "resolving ACE qualifier: %s", v123, v124, (char)path);
            goto LABEL_231;
          }
        }
      }
    }
    v125 = MemBufferGetFreePtr((uint64_t)v12);
    v126 = MemBufferGetFreeSize(v12);
    v132 = yaa_encodeACE(v125, v126, (uint64_t)v222, v127, v128, v129, v130, v131);
    if ((v132 & 0x8000000000000000) == 0)
    {
      MemBufferIncreaseSize((unint64_t *)v12, v132, v133, v134, v135, v136, v137, v138);
      acl_free(namec);
      v66 = v203;
      goto LABEL_160;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 620, 12, 0, "encoding ACE", v137, v138, (char)v185);
LABEL_231:
    v66 = v203;
    v154 = namec;
LABEL_205:
    acl_free(v154);
LABEL_206:
    acl_free(__ptra);
    v93 = v202;
LABEL_207:
    if (!MemBufferIsEmpty((uint64_t)v12))
    {
      __ptrb = (void *)MemBufferGetDataPtr((uint64_t)v12);
      v174 = MemBufferGetDataSize((uint64_t)v12);
      if (!BlobBufferStore(v199, __ptrb, v174, (void *)(v204 + 280 * v66 + 232)))
      {
        if (v205 >= 3)
        {
          v177 = (FILE *)*MEMORY[0x263EF8348];
          v178 = MemBufferGetDataSize((uint64_t)v12);
          fprintf(v177, "ACL blob [%zu] stored for %s\n", v178, path);
        }
        goto LABEL_208;
      }
      v41 = "processEntryThreadProc";
      v42 = "processEntryThreadProc";
      v43 = 637;
      v44 = 0;
      v45 = "storing ACL";
LABEL_47:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)v42, v43, 12, v44, v45, v39, v40, (char)v185);
      goto LABEL_48;
    }
LABEL_208:
    if (!v93)
    {
      v202 = 0;
      goto LABEL_220;
    }
    MemBufferClear(v12);
    v155 = 0;
    v156 = (uint64_t)v212;
    v157 = v26;
    do
    {
      if (*(_DWORD *)(v156 + 4) == 2) {
        v155 += *(void *)(v156 + 8);
      }
      v12 = v208;
      v158 = (unsigned char *)MemBufferGetFreePtr((uint64_t)v208);
      v159 = MemBufferGetFreeSize(v208);
      v165 = yaa_encodeHeaderField(v158, v159, v156, v160, v161, v162, v163, v164);
      if ((v165 & 0x8000000000000000) != 0)
      {
        v41 = "processEntryThreadProc";
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 653, 12, 0, "extra header field is too large for processing thread buffer", v170, v171, (char)v185);
        v2 = v205;
        v26 = v157;
        goto LABEL_48;
      }
      MemBufferIncreaseSize((unint64_t *)v208, v165, v166, v167, v168, v169, v170, v171);
      v156 += 1032;
      --v93;
    }
    while (v93);
    v26 = v157;
    if (v201 != v155)
    {
      v41 = "processEntryThreadProc";
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 658, 12, 0, "extra header data size doesn't match expected value", v172, v173, (char)v185);
      v2 = v205;
      v12 = v208;
      goto LABEL_48;
    }
    v12 = v208;
    v2 = v205;
    if (!MemBufferIsEmpty((uint64_t)v208))
    {
      v175 = (const void *)MemBufferGetDataPtr((uint64_t)v208);
      v176 = MemBufferGetDataSize((uint64_t)v208);
      if (BlobBufferStore(v199, v175, v176, (void *)(v204 + 280 * v203 + 248)))
      {
        v41 = "processEntryThreadProc";
        v42 = "processEntryThreadProc";
        v43 = 663;
        v44 = 0;
        v45 = "storing encoded extra fields";
        goto LABEL_47;
      }
    }
    if (v201)
    {
      if (!BlobBufferStore(v199, v211, v201, (void *)(v204 + 280 * v203 + 264))) {
        goto LABEL_220;
      }
      v41 = "processEntryThreadProc";
      v42 = "processEntryThreadProc";
      v43 = 668;
      v44 = 0;
      v45 = "storing extra fields data";
      goto LABEL_47;
    }
    v201 = 0;
LABEL_220:
    v29 = "processEntryThreadProc";
LABEL_49:
    v22 = *(_DWORD *)(v0 + 8);
    if (pthread_mutex_lock(v207))
    {
LABEL_23:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPush", 117, 0, "SharedArrayPush: pthread_mutex_lock failed\n", v23, v24, v25, (char)v185);
      goto LABEL_24;
    }
  }
  v183 = "SharedArrayPush: pthread_cond_broadcast failed\n";
  v184 = 122;
LABEL_244:
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPush", v184, 0, v183, v33, v34, v35, (char)v185);
  v2 = v205;
  v12 = v208;
LABEL_24:
  v27 = (void *)(v0 + 32);
  v28 = v212;
LABEL_234:
  ++*v27;
LABEL_235:
  MemBufferDestroy(v12);
  free(string);
  free(v28);
  free(v211);
  free(v26);
  if (v2 >= 3) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "[%d] terminating\n", *(_DWORD *)(v0 + 8));
  }
  restoreThreadErrorContext(v236);
  return 0;
}

uint64_t *resolveSameThreadProc()
{
  v0 = (uint64_t *)MEMORY[0x270FA5388]();
  uint64_t v61 = *MEMORY[0x263EF8340];
  uint64_t v1 = *v0;
  bzero(v60, 0x800uLL);
  bzero(v59, 0x800uLL);
  unint64_t v2 = *(void *)(v1 + 1272);
  if (v2)
  {
    uint64_t v3 = 0;
    unint64_t v4 = 0;
    uint64_t v5 = v1 + 20;
    v6 = v0 + 5;
    v7 = v0 + 4;
    while (1)
    {
      uint64_t v8 = *(void *)(v1 + 1288);
      unint64_t v9 = HIDWORD(*(void *)(v8 + 16 * v4));
      if (v9 >= v0[2])
      {
        if (v9 >= v0[3]) {
          return v0;
        }
        uint64_t v10 = *(void *)(v1 + 1072);
        uint64_t v11 = *(void *)(v8 + 16 * v4 + 8);
        uint64_t v12 = v10 + 280 * v11;
        uint64_t v14 = *(void *)(v12 + 128);
        v13 = (unint64_t *)(v12 + 128);
        unint64_t v15 = v4 + 1;
        if (v14 == -1 && v15 < v2)
        {
          uint64_t v17 = *(void *)(v1 + 1288);
          if (*(void *)(v17 + 16 * v15) == *(void *)(v17 + 16 * v4)) {
            break;
          }
        }
      }
LABEL_10:
      ++v4;
      v3 += 16;
      if (v4 >= v2) {
        return v0;
      }
    }
    uint64_t v18 = v10 + 280 * v11;
    uint64_t v19 = v18 + 140;
    v20 = (void *)(v18 + 160);
    uint64_t v21 = v3;
    while (1)
    {
      uint64_t v22 = *(void *)(v1 + 1072);
      uint64_t v23 = *(void *)(v17 + v21 + 24);
      if (*(void *)(v22 + 280 * v23 + 112) != -1) {
        goto LABEL_50;
      }
      if (*(void *)(v22 + 280 * v23 + 120) != -1) {
        goto LABEL_50;
      }
      uint64_t v24 = v22 + 280 * v23;
      uint64_t v26 = *(void *)(v24 + 128);
      v25 = (unint64_t *)(v24 + 128);
      if (v26 != -1) {
        goto LABEL_50;
      }
      if ((*(unsigned char *)(v1 + 1080) & 2) != 0)
      {
        uint64_t v27 = v22 + 280 * v23;
        uint64_t v28 = *(void *)(v27 + 140);
        uint64_t v29 = *(void *)(v27 + 148);
        uint64_t v30 = *(unsigned int *)(v27 + 156);
        BOOL v31 = *(void *)v19 == v28 && *(void *)(v19 + 8) == v29;
        if (!v31 || *(_DWORD *)(v19 + 16) != v30) {
          goto LABEL_50;
        }
      }
      if ((*(unsigned char *)(v1 + 1080) & 4) != 0)
      {
        v33 = (void *)(v22 + 280 * v23);
        uint64_t v34 = v33[20];
        uint64_t v35 = v33[21];
        uint64_t v37 = v33[22];
        uint64_t v36 = v33[23];
        BOOL v38 = *v20 == v34 && v20[1] == v35;
        BOOL v39 = v38 && v20[2] == v37;
        if (!v39 || v20[3] != v36) {
          goto LABEL_50;
        }
      }
      v53 = v25;
      v54 = v20;
      uint64_t v55 = v19;
      v56 = v7;
      v57 = v6;
      uint64_t v58 = v5;
      if (ArchiveTreeNodePath(*(void *)(v1 + 1056), *(_DWORD *)(v17 + 16 * v4 + 8), (uint64_t)v60, 0x800uLL) < 0) {
        break;
      }
      if (ArchiveTreeNodePath(*(void *)(v1 + 1056), *(_DWORD *)(*(void *)(v1 + 1288) + v21 + 24), (uint64_t)v59, 0x800uLL) < 0)
      {
        __int16 v49 = 726;
        goto LABEL_47;
      }
      int v43 = areFilesEqual2();
      if (v43 < 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"resolveSameThreadProc", 729, 12, 0, "File comparison failed: %s vs %s", v44, v45, (char)v60);
        goto LABEL_48;
      }
      v6 = v57;
      uint64_t v5 = v58;
      uint64_t v19 = v55;
      v7 = v56;
      v20 = v54;
      if (!v43) {
        goto LABEL_50;
      }
      unint64_t add = *v13;
      if (*v13 == -1)
      {
        unint64_t add = atomic_fetch_add((atomic_ullong *volatile)(v1 + 1328), 1uLL);
        unint64_t *v13 = add;
      }
      unint64_t *v53 = add;
      uint64_t v47 = *(void *)(v22 + 280 * v23 + 96);
      v48 = v57;
LABEL_49:
      *v48 += v47;
LABEL_50:
      ++v15;
      unint64_t v2 = *(void *)(v1 + 1272);
      if (v15 < v2)
      {
        uint64_t v17 = *(void *)(v1 + 1288);
        uint64_t v50 = v17 + v21;
        v21 += 16;
        if (*(void *)(v50 + 32) == *(void *)(v17 + 16 * v4)) {
          continue;
        }
      }
      goto LABEL_10;
    }
    __int16 v49 = 725;
LABEL_47:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"resolveSameThreadProc", v49, 12, 0, "entry path too long", v41, v42, v52);
LABEL_48:
    v7 = v56;
    v6 = v57;
    v48 = v56;
    uint64_t v47 = 1;
    uint64_t v5 = v58;
    v20 = v54;
    uint64_t v19 = v55;
    goto LABEL_49;
  }
  return v0;
}

uint64_t ParallelArchiveWriteDirContents()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v3 = v0;
  uint64_t v326 = *MEMORY[0x263EF8340];
  enterThreadErrorContext(v0, v1, v4, v5, v6, v7, v8, v9, v279);
  unsigned int DefaultNThreads = *(_DWORD *)(v2 + 4);
  if (!DefaultNThreads) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  int v11 = *(_DWORD *)v2;
  uint64_t v12 = *(void *)(v3 + 40);
  bzero(&v297, 0x540uLL);
  uint64_t v295 = v2;
  uint64_t v296 = v3;
  int v297 = *(_DWORD *)v3;
  if (!realpath_DARWIN_EXTSN(*(const char **)(v2 + 16), v298))
  {
    int v17 = *__error();
    unint64_t v15 = "invalid inDir";
    __int16 v16 = 825;
    goto LABEL_26;
  }
  size_t v299 = strlen(v298);
  if (v299 - 1015 <= 0xFFFFFFFFFFFFFBFELL)
  {
    unint64_t v15 = "invalid inDir length";
    __int16 v16 = 827;
    goto LABEL_25;
  }
  uint64_t v18 = ArchiveTreeCreateFromDirectory(v298, *(const __CFArray **)(v2 + 24), *(void *)(v2 + 56), *(void *)(v2 + 72), DefaultNThreads, v11);
  v300 = v18;
  if (!v18)
  {
    unint64_t v15 = "building archive tree";
    __int16 v16 = 831;
    goto LABEL_25;
  }
  size_t v301 = ArchiveTreeSize(v18);
  v302 = calloc(v301, 0x118uLL);
  if (!v302)
  {
    int v17 = *__error();
    unint64_t v15 = "malloc";
    __int16 v16 = 836;
    goto LABEL_26;
  }
  if (!v301) {
    goto LABEL_409;
  }
  uint64_t v19 = 0;
  for (size_t i = 0; i < v301; ++i)
  {
    uint64_t v21 = (char *)v302 + v19;
    *((void *)v21 + 34) = 0;
    *((_OWORD *)v21 + 15) = 0uLL;
    *((_OWORD *)v21 + 16) = 0uLL;
    *((_OWORD *)v21 + 13) = 0uLL;
    *((_OWORD *)v21 + 14) = 0uLL;
    *((_OWORD *)v21 + 11) = 0uLL;
    *((_OWORD *)v21 + 12) = 0uLL;
    *((_OWORD *)v21 + 9) = 0uLL;
    *((_OWORD *)v21 + 10) = 0uLL;
    *((_OWORD *)v21 + 7) = 0uLL;
    *((_OWORD *)v21 + 8) = 0uLL;
    *((_OWORD *)v21 + 5) = 0uLL;
    *((_OWORD *)v21 + 6) = 0uLL;
    *((_OWORD *)v21 + 3) = 0uLL;
    *((_OWORD *)v21 + 4) = 0uLL;
    *((_OWORD *)v21 + 1) = 0uLL;
    *((_OWORD *)v21 + 2) = 0uLL;
    *(_OWORD *)uint64_t v21 = 0uLL;
    *((_DWORD *)v21 + 48) = -1;
    v19 += 280;
  }
  if (!v301) {
    goto LABEL_409;
  }
  int v22 = v303 & 0xFE | (*(_DWORD *)(v295 + 32) >> 12) & 1;
  char v303 = v303 & 0xFE | ((*(_DWORD *)(v295 + 32) & 0x1000) != 0);
  char v303 = v22 & 0xFD | (2 * ((*(_DWORD *)(v295 + 32) & 0x2000) != 0));
  char v303 = v303 & 0xFB | (*(_DWORD *)(v295 + 32) >> 12) & 4;
  if (v301 >= DefaultNThreads) {
    size_t v23 = DefaultNThreads;
  }
  else {
    size_t v23 = v301;
  }
  LODWORD(__count) = v23;
  int v308 = 0;
  int v309 = v23;
  v310 = calloc(v23, 4uLL);
  if (!v310)
  {
    uint64_t v27 = "SharedArrayInit: malloc failed\n";
    __int16 v28 = 55;
    goto LABEL_24;
  }
  if (pthread_mutex_init(&v311, 0))
  {
    uint64_t v27 = "SharedArrayInit: pthread_mutex_init failed\n";
    __int16 v28 = 56;
LABEL_24:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayInit", v28, 0, v27, v24, v25, v26, v280);
    unint64_t v15 = "init available_threads";
    __int16 v16 = 850;
    goto LABEL_25;
  }
  if (pthread_cond_init(&v312, 0))
  {
    uint64_t v27 = "SharedArrayInit: pthread_cond_init failed\n";
    __int16 v28 = 57;
    goto LABEL_24;
  }
  v307 = calloc(__count, 0xC8uLL);
  if (!v307)
  {
    int v17 = *__error();
    unint64_t v15 = "malloc";
    __int16 v16 = 852;
    goto LABEL_26;
  }
  uint64_t v292 = v12;
  if (__count)
  {
    uint64_t v43 = 0;
    unint64_t v44 = 0;
    do
    {
      uint64_t v45 = (char *)v307;
      v46 = (char *)v307 + v43;
      *(void *)v46 = &v295;
      *((_DWORD *)v46 + 2) = v44;
      *((void *)v46 + 3) = -1;
      *((_DWORD *)v46 + 10) = 0;
      if (pthread_mutex_init((pthread_mutex_t *)(v46 + 48), 0)
        || pthread_cond_init((pthread_cond_t *)(v46 + 112), 0))
      {
        v82 = "init entry_ready";
        __int16 v83 = 860;
        goto LABEL_119;
      }
      if (createThread((pthread_t *)&v45[v43 + 16], (uint64_t)processEntryThreadProc, (uint64_t)v46, 0))
      {
        int v84 = *__error();
        v82 = "createThread";
        __int16 v83 = 863;
        goto LABEL_138;
      }
      ++v44;
      unint64_t v47 = __count;
      v43 += 200;
    }
    while (v44 < __count);
  }
  else
  {
    unint64_t v47 = 0;
  }
  size_t v48 = v301;
  if (v301 + v47)
  {
    size_t v85 = 0;
    uint64_t v12 = v292;
    while (!pthread_mutex_lock(&v311))
    {
      while (1)
      {
        int v89 = v308;
        if (v308) {
          break;
        }
        if (pthread_cond_wait(&v312, &v311))
        {
          v100 = "SharedArrayPop: pthread_cond_wait failed\n";
          __int16 v101 = 94;
          goto LABEL_135;
        }
      }
      --v308;
      unsigned int v90 = *((_DWORD *)v310 + (v89 - 1));
      if (pthread_mutex_unlock(&v311))
      {
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", 98, 0, "SharedArrayPop: pthread_mutex_unlock failed\n", v91, v92, v93, v280);
        uint64_t v12 = v292;
        goto LABEL_136;
      }
      v94 = (char *)v307;
      if (v85 >= v301) {
        uint64_t v95 = -1;
      }
      else {
        uint64_t v95 = v85;
      }
      v96 = (char *)v307 + 200 * v90;
      *((void *)v96 + 3) = v95;
      v97 = (pthread_mutex_t *)(v96 + 48);
      if (pthread_mutex_lock((pthread_mutex_t *)(v96 + 48))
        || (v98 = &v94[200 * v90], int v99 = *((_DWORD *)v98 + 10), *((_DWORD *)v98 + 10) = v99 + 1, !v99)
        && pthread_cond_broadcast((pthread_cond_t *)&v94[200 * v90 + 112])
        || pthread_mutex_unlock(v97))
      {
        v82 = "starting task";
        __int16 v83 = 879;
LABEL_119:
        int v84 = 0;
LABEL_138:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", v83, 12, v84, v82, v13, v14, v280);
        char v29 = 1;
LABEL_139:
        uint64_t v12 = v292;
        goto LABEL_28;
      }
      ++v85;
      size_t v48 = v301;
      unint64_t v47 = __count;
      uint64_t v12 = v292;
      if (v85 >= v301 + __count) {
        goto LABEL_63;
      }
    }
    v100 = "SharedArrayPop: pthread_mutex_lock failed\n";
    __int16 v101 = 91;
LABEL_135:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v101, 0, v100, v86, v87, v88, v280);
LABEL_136:
    unint64_t v15 = "waiting for an available worker";
    __int16 v16 = 871;
LABEL_25:
    int v17 = 0;
    goto LABEL_26;
  }
LABEL_63:
  uint64_t v12 = v292;
  if (v48)
  {
    uint64_t v49 = 0;
    uint64_t v50 = (char *)v302 + 196;
    do
    {
      if (*v50) {
        ++v49;
      }
      v50 += 70;
      --v48;
    }
    while (v48);
    if (v49)
    {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", 887, 12, "%zu failed entries reported", v42, v13, v14, v49);
      unint64_t v47 = __count;
    }
  }
  if (v47)
  {
    uint64_t v51 = 0;
    for (unint64_t j = 0; j < v47; ++j)
    {
      v53 = (const void **)((char *)v307 + v51);
      size_t v54 = *(void *)((char *)v307 + v51 + 168);
      if (v54)
      {
        if (BlobBufferStore((uint64_t)v304, v53[22], v54, v53 + 23))
        {
          unint64_t v15 = "moving thread data to main state";
          __int16 v16 = 897;
          goto LABEL_25;
        }
        BlobBufferFree((uint64_t)(v53 + 20));
        unint64_t v47 = __count;
      }
      v51 += 200;
    }
  }
  size_t v55 = v301;
  if (v301)
  {
    v56 = v307;
    v57 = (char *)v302 + 272;
    size_t v58 = v301;
    while (1)
    {
      unsigned int v59 = *((_DWORD *)v57 - 20);
      if (v59 == -1) {
        break;
      }
      uint64_t v60 = v56[25 * v59 + 23];
      if (*(v57 - 6)) {
        *(v57 - 7) += v60;
      }
      if (*(v57 - 4)) {
        *(v57 - 5) += v60;
      }
      if (*(v57 - 8)) {
        *(v57 - 9) += v60;
      }
      if (*(v57 - 2)) {
        *(v57 - 3) += v60;
      }
      if (*v57) {
        *(v57 - 1) += v60;
      }
      v57 += 35;
      if (!--v58)
      {
        uint64_t v61 = v318;
        uint64_t v62 = v319;
        v63 = (char *)v302 + 104;
        size_t v64 = v55;
        do
        {
          if (*((_DWORD *)v63 - 26) == 70)
          {
            if (*((unsigned __int16 *)v63 - 16) >= 2u) {
              uint64_t v318 = ++v61;
            }
            if (*v63 != -1) {
              uint64_t v319 = ++v62;
            }
          }
          v63 += 35;
          --v64;
        }
        while (v64);
        goto LABEL_97;
      }
    }
    unint64_t v15 = "invalid thread_id stored in entry";
    __int16 v16 = 907;
    goto LABEL_25;
  }
LABEL_97:
  if (v297 >= 1)
  {
    if (v55)
    {
      uint64_t v65 = 0;
      uint64_t v66 = 0;
      uint64_t v67 = 0;
      v68 = 0;
      uint64_t v69 = 0;
      uint64_t v70 = 0;
      uint64_t v71 = 0;
      uint64_t v72 = 0;
      uint64_t v73 = 0;
      uint64_t v74 = 0;
      v75 = 0;
      v76 = (char *)v302 + 240;
      size_t v77 = v55;
      do
      {
        int v78 = *((_DWORD *)v76 - 60);
        switch(v78)
        {
          case 'B':
            ++v71;
            break;
          case 'C':
            ++v70;
            break;
          case 'D':
            ++v66;
            break;
          case 'E':
          case 'G':
          case 'H':
          case 'I':
          case 'J':
          case 'K':
          case 'M':
          case 'N':
          case 'O':
            break;
          case 'F':
            ++v65;
            v75 = (pthread_cond_t *)((char *)v75 + *(v76 - 18));
            break;
          case 'L':
            ++v67;
            break;
          case 'P':
            ++v68;
            break;
          default:
            if (v78 == 83) {
              ++v69;
            }
            break;
        }
        uint64_t v79 = *(v76 - 2);
        uint64_t v80 = *v76;
        int v81 = *((_DWORD *)v76 - 11);
        v76 += 35;
        if (v79) {
          ++v72;
        }
        if (v80) {
          ++v73;
        }
        if (v81) {
          ++v74;
        }
        --v77;
      }
      while (v77);
    }
    else
    {
      v75 = 0;
      uint64_t v74 = 0;
      uint64_t v73 = 0;
      uint64_t v72 = 0;
      uint64_t v71 = 0;
      uint64_t v70 = 0;
      uint64_t v69 = 0;
      v68 = 0;
      uint64_t v67 = 0;
      uint64_t v66 = 0;
      uint64_t v65 = 0;
    }
    uint64_t v281 = v66;
    uint64_t v282 = v67;
    uint64_t v283 = v69;
    uint64_t v284 = v70;
    uint64_t v286 = v71;
    v288 = v68;
    v290 = v75;
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12zu entries selected\n", v55);
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12zu regular files\n", v65);
    v102 = (FILE **)MEMORY[0x263EF8348];
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12zu directories\n", v281);
    fprintf(*v102, "%12zu symbolic links\n", v282);
    if (v283) {
      fprintf(*v102, "%12zu sockets\n", v283);
    }
    if (v284) {
      fprintf(*v102, "%12zu character special entries\n", v284);
    }
    if (v286) {
      fprintf(*v102, "%12zu block special entries\n", v286);
    }
    if (v288) {
      fprintf(*v102, "%12zu FIFO\n", (size_t)v288);
    }
    if (v72) {
      fprintf(*v102, "%12zu entries with XAT blob\n", v72);
    }
    if (v73) {
      fprintf(*v102, "%12zu entries with ACL blob\n", v73);
    }
    double v103 = 0.0009765625;
    if ((unint64_t)v290 >> 20)
    {
      double v103 = 0.000000953674316;
      LODWORD(v104) = 77;
    }
    else
    {
      LODWORD(v104) = 75;
    }
    if ((unint64_t)v290 >> 30)
    {
      double v103 = 9.31322575e-10;
      uint64_t v104 = 71;
    }
    else
    {
      uint64_t v104 = v104;
    }
    fprintf(*v102, "%12llu bytes in regular files (%.2f %cB)\n", v290, v103 * (double)(unint64_t)v290, v104);
    if (v74)
    {
      fprintf(*v102, "%12zu entries reported an error\n", v74);
      if (v297 >= 2)
      {
        if (v301)
        {
          size_t v105 = 0;
          uint64_t v106 = 196;
          do
          {
            if (*(_DWORD *)((char *)v302 + v106)
              && (ArchiveTreeNodePath((uint64_t)v300, v105, (uint64_t)__key, 0x400uLL) & 0x8000000000000000) == 0)
            {
              fprintf((FILE *)*MEMORY[0x263EF8348], "- %s\n", (const char *)__key);
            }
            ++v105;
            v106 += 280;
          }
          while (v105 < v301);
        }
      }
    }
  }
  if (v318)
  {
    size_t __nel = 0;
    size_t v107 = v301;
    if (v301)
    {
      uint64_t v108 = 0;
      size_t v109 = 0;
      size_t v110 = 0;
      while (1)
      {
        v111 = (char *)v302;
        if (*(_DWORD *)((char *)v302 + v108) == 70 && *(unsigned __int16 *)((char *)v302 + v108 + 72) >= 2u)
        {
          v112 = (char *)__ptr;
          if (v109 >= v316)
          {
            uint64_t v113 = v316 + (v316 >> 1);
            if (!v316) {
              uint64_t v113 = 64;
            }
            size_t v316 = v113;
            v112 = (char *)reallocf(__ptr, 16 * v113);
            __ptr = v112;
            if (!v112)
            {
              int v17 = *__error();
              unint64_t v15 = "malloc";
              __int16 v16 = 1007;
LABEL_26:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", v16, 12, v17, v15, v13, v14, v280);
              goto LABEL_27;
            }
            size_t v109 = __nel;
            size_t v107 = v301;
          }
          v114 = &v112[16 * v109];
          *((void *)v114 + 1) = v110;
          *(void *)v114 = *(void *)&v111[v108 + 80];
          size_t __nel = ++v109;
        }
        ++v110;
        v108 += 280;
        if (v110 >= v107) {
          goto LABEL_183;
        }
      }
    }
    size_t v109 = 0;
LABEL_183:
    qsort(__ptr, v109, 0x10uLL, (int (__cdecl *)(const void *, const void *))cmpINOEntry);
    size_t v115 = __nel;
    if (__nel)
    {
      size_t v116 = 0;
      do
      {
        if (v116 + 1 >= v115)
        {
          size_t v115 = v116 + 1;
          uint64_t v121 = 1;
        }
        else
        {
          v117 = (uint64_t *)((char *)__ptr + 16 * v116);
          uint64_t v120 = *v117;
          v119 = v117 + 2;
          uint64_t v118 = v120;
          uint64_t v121 = 1;
          while (1)
          {
            uint64_t v122 = *v119;
            v119 += 2;
            if (v118 != v122) {
              break;
            }
            ++v121;
            if (!(v116 - v115 + v121))
            {
              uint64_t v121 = v115 - v116;
              goto LABEL_192;
            }
          }
          size_t v115 = v116 + v121;
LABEL_192:
          if (!v121) {
            goto LABEL_197;
          }
        }
        uint64_t v123 = 0;
        uint64_t v124 = (16 * v116) | 8;
        do
        {
          v125 = v302;
          uint64_t v126 = *(void *)((char *)__ptr + v124);
          unint64_t v127 = atomic_load(&v320);
          v125[35 * v126 + 14] = v127;
          if (v123) {
            v323 += v125[35 * v126 + 12];
          }
          ++v123;
          v124 += 16;
        }
        while (v121 != v123);
LABEL_197:
        size_t v116 = v115;
        atomic_fetch_add((atomic_ullong *volatile)&v320, 1uLL);
        size_t v115 = __nel;
      }
      while (v116 < __nel);
    }
  }
  if (v319)
  {
    size_t __nel = 0;
    size_t v128 = v301;
    if (v301)
    {
      uint64_t v129 = 0;
      size_t v130 = 0;
      size_t v131 = 0;
      do
      {
        v132 = (char *)v302;
        if (*(_DWORD *)((char *)v302 + v129) == 70)
        {
          v133 = (char *)__ptr;
          if (v130 >= v316)
          {
            uint64_t v134 = v316 + (v316 >> 1);
            if (!v316) {
              uint64_t v134 = 64;
            }
            size_t v316 = v134;
            v133 = (char *)reallocf(__ptr, 16 * v134);
            __ptr = v133;
            if (!v133)
            {
              int v17 = *__error();
              unint64_t v15 = "malloc";
              __int16 v16 = 1051;
              goto LABEL_26;
            }
            size_t v130 = __nel;
            size_t v128 = v301;
          }
          v135 = &v133[16 * v130];
          *((void *)v135 + 1) = v131;
          *(void *)v135 = *(void *)&v132[v129 + 104];
          size_t __nel = ++v130;
        }
        ++v131;
        v129 += 280;
      }
      while (v131 < v128);
    }
    else
    {
      size_t v130 = 0;
    }
    qsort(__ptr, v130, 0x10uLL, (int (__cdecl *)(const void *, const void *))cmpINOEntry);
    size_t v136 = v301;
    if (v301)
    {
      uint64_t v137 = 0;
      size_t v138 = 0;
      do
      {
        v139 = (char *)v302;
        if (*(_DWORD *)((char *)v302 + v137) == 70 && *(void *)((char *)v302 + v137 + 104) != -1)
        {
          __key[1] = 0;
          __key[0] = 0;
          __key[0] = *(void *)((char *)v302 + v137 + 104);
          v140 = bsearch(__key, __ptr, __nel, 0x10uLL, (int (__cdecl *)(const void *, const void *))cmpINOEntry);
          if (v140)
          {
            v141 = (char *)v302 + 280 * v140[1];
            unint64_t v144 = *((void *)v141 + 15);
            v143 = (unint64_t *)(v141 + 120);
            unint64_t add = v144;
            v324 += *(v143 - 3);
            if (v144 == -1)
            {
              unint64_t add = atomic_fetch_add((atomic_ullong *volatile)&v321, 1uLL);
              unint64_t *v143 = add;
            }
            *(void *)&v139[v137 + 120] = add;
          }
          size_t v136 = v301;
        }
        ++v138;
        v137 += 280;
      }
      while (v138 < v136);
    }
  }
  if ((v303 & 6) != 0)
  {
    size_t __nel = 0;
    size_t v145 = v301;
    if (v301)
    {
      uint64_t v146 = 0;
      size_t v147 = 0;
      size_t v148 = 0;
      while (1)
      {
        v149 = (char *)v302;
        if (*(_DWORD *)((char *)v302 + v146) == 70)
        {
          v150 = (char *)__ptr;
          if (v147 >= v316)
          {
            uint64_t v151 = 64;
            if (v316) {
              uint64_t v151 = v316 + (v316 >> 1);
            }
            size_t v316 = v151;
            v150 = (char *)reallocf(__ptr, 16 * v151);
            __ptr = v150;
            if (!v150)
            {
              int v17 = *__error();
              unint64_t v15 = "malloc";
              __int16 v16 = 1103;
              goto LABEL_26;
            }
            size_t v147 = __nel;
          }
          v152 = &v150[16 * v147];
          *((void *)v152 + 1) = v148;
          if ((v303 & 2) != 0) {
            uint64_t v153 = 140;
          }
          else {
            uint64_t v153 = 160;
          }
          *(void *)v152 = *(void *)&v149[v146 + v153];
          size_t v147 = ++__nel;
          size_t v145 = v301;
        }
        ++v148;
        v146 += 280;
        if (v148 >= v145) {
          goto LABEL_237;
        }
      }
    }
    size_t v147 = 0;
LABEL_237:
    qsort(__ptr, v147, 0x10uLL, (int (__cdecl *)(const void *, const void *))cmpINOEntry);
    unsigned int v313 = DefaultNThreads;
    if ((0x100000000uLL / DefaultNThreads * DefaultNThreads) >> 32) {
      unint64_t v154 = 0x100000000uLL / DefaultNThreads;
    }
    else {
      unint64_t v154 = 0x100000000uLL / DefaultNThreads + 1;
    }
    v314 = calloc(DefaultNThreads, 0x30uLL);
    if (!v314)
    {
      int v17 = *__error();
      unint64_t v15 = "malloc";
      __int16 v16 = 1118;
      goto LABEL_26;
    }
    if (v313)
    {
      uint64_t v155 = 0;
      unint64_t v156 = 0;
      int v157 = 1;
      do
      {
        v158 = (char *)v314 + v155;
        *(void *)v158 = &v295;
        unint64_t v159 = v154 * v156++;
        *((void *)v158 + 2) = v159;
        *((void *)v158 + 3) = v154 * v156;
        if ((createThread((pthread_t *)v158 + 1, (uint64_t)resolveSameThreadProc, (uint64_t)v158, 0) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", 1126, 12, 0, "creating resolve thread", v160, v161, v280);
          int v157 = 0;
        }
        unint64_t v162 = v313;
        v155 += 48;
      }
      while (v156 < v313);
      if (v313)
      {
        uint64_t v163 = 0;
        unint64_t v164 = 0;
        do
        {
          v165 = (char *)v314;
          v166 = (char *)v314 + v163;
          v167 = *(_opaque_pthread_t **)((char *)v314 + v163 + 8);
          if (v167)
          {
            if ((joinThread(v167) & 0x80000000) != 0)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", 1133, 12, 0, "joining resolve thread", v168, v169, v280);
              int v157 = 0;
            }
            *((void *)v166 + 1) = 0;
            v170 = &v165[v163];
            if (*((void *)v170 + 4))
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", 1135, 12, 0, "Thread reported an error", v168, v169, v280);
              int v157 = 0;
            }
            v325 += *((void *)v170 + 5);
            unint64_t v162 = v313;
          }
          ++v164;
          v163 += 48;
        }
        while (v164 < v162);
      }
      uint64_t v12 = v292;
      if (!v157)
      {
LABEL_27:
        char v29 = 1;
        goto LABEL_28;
      }
    }
  }
  if (v297 >= 1)
  {
    size_t v171 = v301;
    if (v301)
    {
      uint64_t v172 = 0;
      uint64_t v173 = 0;
      uint64_t v174 = 0;
      v175 = (char *)v302 + 128;
      do
      {
        if (*(v175 - 2) != -1) {
          ++v174;
        }
        if (*(v175 - 1) != -1) {
          ++v173;
        }
        if (*v175 != -1) {
          ++v172;
        }
        v175 += 35;
        --v171;
      }
      while (v171);
    }
    else
    {
      uint64_t v174 = 0;
      uint64_t v173 = 0;
      uint64_t v172 = 0;
    }
    uint64_t v176 = atomic_load(&v320);
    v177 = (FILE **)MEMORY[0x263EF8348];
    if (v176 > 0)
    {
      v178 = (FILE *)*MEMORY[0x263EF8348];
      unint64_t v179 = atomic_load(&v320);
      fprintf(v178, "%12llu hard link clusters\n", v179);
      fprintf(*v177, "%12llu hard link entries\n", v174);
      fprintf(*v177, "%12llu redundant bytes in hard links\n", v323);
    }
    uint64_t v180 = atomic_load(&v321);
    if (v180 >= 1)
    {
      v181 = *v177;
      unint64_t v182 = atomic_load(&v321);
      fprintf(v181, "%12llu clone clusters\n", v182);
      fprintf(*v177, "%12llu clone entries\n", v173);
      fprintf(*v177, "%12llu redundant bytes in clones\n", v324);
    }
    uint64_t v183 = atomic_load(&v322);
    if (v183 >= 1)
    {
      v184 = *v177;
      unint64_t v185 = atomic_load(&v322);
      fprintf(v184, "%12llu same data clusters\n", v185);
      fprintf(*v177, "%12llu same data entries\n", v172);
      fprintf(*v177, "%12llu redundant bytes in same data files\n", v325);
    }
  }
  if (!v301)
  {
LABEL_409:
    char v29 = 0;
    goto LABEL_28;
  }
  uint64_t v186 = 0;
  v289 = (_DWORD *)(v3 + 64);
  v187 = (unsigned char *)(v3 + 70);
  while (1)
  {
    v188 = (uint64_t *)v302;
    if (ArchiveTreeNodePath((uint64_t)v300, v186, (uint64_t)__key, 0x800uLL) < 0)
    {
      v82 = "entry path too long";
      __int16 v83 = 1179;
      goto LABEL_119;
    }
    v191 = &v188[35 * v186];
    int v193 = *((_DWORD *)v191 + 49);
    v192 = (_DWORD *)v191 + 49;
    if (v193)
    {
      if ((sendFailureEntry(&v295, v186, 1uLL) & 0x80000000) != 0)
      {
        v82 = "sending failure info";
        __int16 v83 = 1184;
        goto LABEL_119;
      }
      goto LABEL_407;
    }
    unint64_t v194 = *(void *)(v3 + 56);
    if (v194 >= 0xFFFF) {
      unint64_t v194 = 0xFFFFLL;
    }
    v291 = (pthread_cond_t *)&v188[35 * v186];
    if (LODWORD(v291->__sig) == 70) {
      int v287 = (*(unsigned __int8 *)(v2 + 33) >> 1) & 1;
    }
    else {
      int v287 = 0;
    }
    if (v194 <= 5)
    {
      v82 = "encode header field";
      __int16 v83 = 1197;
      goto LABEL_119;
    }
    *(_WORD *)(v3 + 68) = 30840;
    _DWORD *v289 = 825246017;
    if (*(_DWORD *)(v3 + 32)) {
      _DWORD *v289 = 826360153;
    }
    v285 = v192;
    unint64_t v195 = v194 - 6;
    int v196 = *(_DWORD *)(v2 + 32);
    if (v196)
    {
      uint64_t v197 = yaa_encodeKeyValue_uint(v187, v195, "TYP", LODWORD(v291->__sig));
      if (v197 < 0)
      {
        v82 = "encode TYP field";
        __int16 v83 = 1205;
        goto LABEL_119;
      }
      v187 += v197;
      v195 -= v197;
      int v196 = *(_DWORD *)(v2 + 32);
    }
    if ((v196 & 2) != 0)
    {
      uint64_t v198 = yaa_encodeKeyValue_uint(v187, v195, "UID", HIDWORD(v188[35 * v186 + 7]));
      if (v198 < 0)
      {
        v82 = "encode UID field";
        __int16 v83 = 1210;
        goto LABEL_119;
      }
      v187 += v198;
      v195 -= v198;
      int v196 = *(_DWORD *)(v2 + 32);
    }
    if ((v196 & 4) != 0)
    {
      uint64_t v199 = yaa_encodeKeyValue_uint(v187, v195, "GID", LODWORD(v188[35 * v186 + 8]));
      if (v199 < 0)
      {
        v82 = "encode GID field";
        __int16 v83 = 1215;
        goto LABEL_119;
      }
      v187 += v199;
      v195 -= v199;
      int v196 = *(_DWORD *)(v2 + 32);
    }
    if ((v196 & 8) != 0)
    {
      uint64_t v200 = yaa_encodeKeyValue_uint(v187, v195, "FLG", HIDWORD(v188[35 * v186 + 8]));
      if (v200 < 0)
      {
        v82 = "encode FLG field";
        __int16 v83 = 1220;
        goto LABEL_119;
      }
      v187 += v200;
      v195 -= v200;
      int v196 = *(_DWORD *)(v2 + 32);
    }
    if ((v196 & 0x10) != 0)
    {
      uint64_t v201 = yaa_encodeKeyValue_uint(v187, v195, "MOD", HIDWORD(v188[35 * v186]));
      if (v201 < 0)
      {
        v82 = "encode MOD field";
        __int16 v83 = 1225;
        goto LABEL_119;
      }
      v187 += v201;
      v195 -= v201;
      unint64_t v202 = LODWORD(v188[35 * v186 + 7]);
      if (v202)
      {
        uint64_t v203 = yaa_encodeKeyValue_uint(v187, v195, "PRC", v202);
        if (v203 < 0)
        {
          v82 = "encode PRC field";
          __int16 v83 = 1229;
          goto LABEL_119;
        }
        v187 += v203;
        v195 -= v203;
      }
    }
    if (*(unsigned char *)(v2 + 33))
    {
      uint64_t v204 = yaa_encodeKeyValue_timespec((uint64_t)v187, v195, "MTM", &v188[35 * v186 + 1]);
      if (v204 < 0)
      {
        v82 = "encode MTM field";
        __int16 v83 = 1235;
        goto LABEL_119;
      }
      v187 += v204;
      v195 -= v204;
      v205 = &v188[35 * v186];
      uint64_t v207 = v205[3];
      v206 = v205 + 3;
      if (v207)
      {
        uint64_t v208 = yaa_encodeKeyValue_timespec((uint64_t)v187, v195, "CTM", v206);
        if (v208 < 0)
        {
          v82 = "encode CTM field";
          __int16 v83 = 1239;
          goto LABEL_119;
        }
        v187 += v208;
        v195 -= v208;
      }
      v209 = &v188[35 * v186];
      uint64_t v211 = v209[5];
      v210 = v209 + 5;
      if (v211)
      {
        uint64_t v212 = yaa_encodeKeyValue_timespec((uint64_t)v187, v195, "BTM", v210);
        if (v212 < 0)
        {
          v82 = "encode BTM field";
          __int16 v83 = 1244;
          goto LABEL_119;
        }
        v187 += v212;
        v195 -= v212;
      }
    }
    int v213 = *(_DWORD *)(v2 + 32);
    if ((v213 & 0x40) != 0)
    {
      uint64_t v214 = yaa_encodeKeyValue_uint(v187, v195, "INO", v188[35 * v186 + 10]);
      if (v214 < 0)
      {
        v82 = "encode INO field";
        __int16 v83 = 1250;
        goto LABEL_119;
      }
      v187 += v214;
      v195 -= v214;
      int v213 = *(_DWORD *)(v2 + 32);
    }
    if ((v213 & 0x80) != 0 && LODWORD(v291->__sig) == 70)
    {
      uint64_t v215 = yaa_encodeKeyValue_uint(v187, v195, "SIZ", v188[35 * v186 + 12]);
      if (v215 < 0)
      {
        v82 = "encode SIZ field";
        __int16 v83 = 1255;
        goto LABEL_119;
      }
      v187 += v215;
      v195 -= v215;
      int v213 = *(_DWORD *)(v2 + 32);
    }
    if ((v213 & 0x20) != 0 && (v291->__sig & 0xFFFFFFFE) == 0x42)
    {
      uint64_t v216 = yaa_encodeKeyValue_uint(v187, v195, "DEV", SLODWORD(v188[35 * v186 + 11]));
      if (v216 < 0)
      {
        v82 = "encode DEV field";
        __int16 v83 = 1260;
        goto LABEL_119;
      }
      v187 += v216;
      v195 -= v216;
      int v213 = *(_DWORD *)(v2 + 32);
    }
    if ((v213 & 0x8000) != 0)
    {
      size_t v217 = yaa_encodeKeyValue_path((uint64_t)v187, v195, "PAT", (char *)__key);
      if ((v217 & 0x8000000000000000) != 0)
      {
        v82 = "encode PAT field";
        __int16 v83 = 1265;
        goto LABEL_119;
      }
      v187 += v217;
      v195 -= v217;
      int v213 = *(_DWORD *)(v2 + 32);
    }
    if ((v213 & 0x10000) != 0 && v188[35 * v186 + 26])
    {
      size_t v218 = yaa_encodeKeyValue_path((uint64_t)v187, v195, "LNK", (char *)(v305 + v188[35 * v186 + 25]));
      if ((v218 & 0x8000000000000000) != 0)
      {
        v82 = "encode LNK field";
        __int16 v83 = 1270;
        goto LABEL_119;
      }
      v187 += v218;
      v195 -= v218;
    }
    if (v287)
    {
      unint64_t v219 = v188[35 * v186 + 12];
      uint64_t v220 = yaa_encodeKeyValue_blob((uint64_t)v187, v195, "DAT", v219);
      if (v220 < 0)
      {
        v82 = "encode DAT field";
        __int16 v83 = 1276;
        goto LABEL_119;
      }
      v187 += v220;
      v195 -= v220;
    }
    else
    {
      unint64_t v219 = 0;
    }
    int v221 = *(_DWORD *)(v2 + 32);
    if ((v221 & 0x400) != 0)
    {
      v222 = &v188[35 * v186];
      uint64_t v223 = v222[28];
      if (v223)
      {
        uint64_t v224 = yaa_encodeKeyValue_blob((uint64_t)v187, v195, "XAT", v222[28]);
        if (v224 < 0)
        {
          v82 = "encode XAT field";
          __int16 v83 = 1282;
          goto LABEL_119;
        }
        v219 += v223;
        v187 += v224;
        v195 -= v224;
        int v221 = *(_DWORD *)(v2 + 32);
      }
    }
    if ((v221 & 0x800) != 0)
    {
      v225 = &v188[35 * v186];
      uint64_t v226 = v225[30];
      if (v226)
      {
        uint64_t v227 = yaa_encodeKeyValue_blob((uint64_t)v187, v195, "ACL", v225[30]);
        if (v227 < 0)
        {
          v82 = "encode ACL field";
          __int16 v83 = 1288;
          goto LABEL_119;
        }
        v219 += v226;
        v187 += v227;
        v195 -= v227;
        int v221 = *(_DWORD *)(v2 + 32);
      }
    }
    int sig = v291->__sig;
    if ((v221 & 0x1000) != 0 && sig == 70)
    {
      uint64_t v229 = yaa_encodeKeyValue_cksum((uint64_t)v187, v195, "CKS", &v188[35 * v186 + 17]);
      if (v229 < 0)
      {
        v82 = "encode CKS field";
        __int16 v83 = 1293;
        goto LABEL_119;
      }
      v187 += v229;
      v195 -= v229;
      int v221 = *(_DWORD *)(v2 + 32);
      int sig = v291->__sig;
    }
    if ((v221 & 0x2000) != 0 && sig == 70)
    {
      uint64_t v230 = yaa_encodeKeyValue_sha1((uint64_t)v187, v195, "SH1", (uint64_t)&v188[35 * v186 + 17] + 4);
      if (v230 < 0)
      {
        v82 = "encode SH1 field";
        __int16 v83 = 1298;
        goto LABEL_119;
      }
      v187 += v230;
      v195 -= v230;
      int v221 = *(_DWORD *)(v2 + 32);
      int sig = v291->__sig;
    }
    if ((v221 & 0x4000) != 0)
    {
      if (sig != 70) {
        goto LABEL_366;
      }
      uint64_t v231 = yaa_encodeKeyValue_sha256((uint64_t)v187, v195, "SH2", &v188[35 * v186 + 20]);
      if (v231 < 0)
      {
        v82 = "encode SH2 field";
        __int16 v83 = 1303;
        goto LABEL_119;
      }
      v187 += v231;
      v195 -= v231;
      int sig = v291->__sig;
    }
    if (sig == 70)
    {
      unint64_t v232 = v188[35 * v186 + 14];
      if (v232 == -1) {
        goto LABEL_360;
      }
      uint64_t v233 = yaa_encodeKeyValue_uint(v187, v195, "HLC", v232);
      if (v233 < 0)
      {
        v82 = "encode HLC field";
        __int16 v83 = 1309;
        goto LABEL_119;
      }
      v187 += v233;
      v195 -= v233;
      if (LODWORD(v291->__sig) == 70)
      {
LABEL_360:
        unint64_t v234 = v188[35 * v186 + 15];
        if (v234 == -1) {
          goto LABEL_363;
        }
        uint64_t v235 = yaa_encodeKeyValue_uint(v187, v195, "CLC", v234);
        if (v235 < 0)
        {
          v82 = "encode CLC field";
          __int16 v83 = 1315;
          goto LABEL_119;
        }
        v187 += v235;
        v195 -= v235;
        if (LODWORD(v291->__sig) == 70)
        {
LABEL_363:
          unint64_t v236 = v188[35 * v186 + 16];
          if (v236 != -1)
          {
            uint64_t v237 = yaa_encodeKeyValue_uint(v187, v195, "SLC", v236);
            if (v237 < 0)
            {
              v82 = "encode SLC field";
              __int16 v83 = 1321;
              goto LABEL_119;
            }
            v187 += v237;
            v195 -= v237;
          }
        }
      }
    }
LABEL_366:
    v238 = &v188[35 * v186];
    size_t v239 = v238[32];
    if (v239)
    {
      if (v195 < v239)
      {
        v82 = "copy header extra fields";
        __int16 v83 = 1327;
        goto LABEL_119;
      }
      v219 += v188[35 * v186 + 34];
      memcpy(v187, (const void *)(v305 + v238[31]), v239);
      v187 += v239;
    }
    *(_WORD *)(v3 + 68) = (_WORD)v187 - (_WORD)v289;
    if (*(_DWORD *)(v3 + 32)) {
      _DWORD *v289 = 826360153;
    }
    if ((yaa_writeRawEntryHeader(v3, (uint64_t)v289, v187 - (unsigned char *)v289, v219, v189, v190, v13, v14) & 0x80000000) != 0) {
      break;
    }
    if (v287)
    {
      if (concatPath(v293, 0x800uLL, v298, (const char *)__key))
      {
        v277 = "full path too long";
        __int16 v278 = 1348;
        goto LABEL_439;
      }
      unint64_t v245 = v188[35 * v186 + 12];
      if (v245)
      {
        int v246 = open(v293, 0);
        if (v246 < 0)
        {
          v262 = __error();
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", 1354, 12, "open failed (%d): %s", v263, v264, v265, *v262);
          int v261 = 1;
          _DWORD *v285 = 1;
LABEL_391:
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", 1391, 12, "truncated data: %s", v242, v243, v244, (char)v293);
          _DWORD *v285 = 1;
          bzero(v289, *(void *)(v3 + 56));
          while (1)
          {
            unint64_t v270 = *(void *)(v3 + 56) >= v245 ? v245 : *(void *)(v3 + 56);
            if (ParallelArchiveWriteEntryData(v296, (uint64_t)v289, v270, v240, v241, v242, v243, v244)) {
              break;
            }
            v245 -= v270;
            if (!v245) {
              goto LABEL_397;
            }
          }
          char v280 = v270;
          v274 = "write DAT 0x00, w=%zu: %s";
          __int16 v275 = 1397;
LABEL_417:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", v275, 12, 0, v274, v243, v244, v280);
LABEL_418:
          int v276 = 99;
          goto LABEL_440;
        }
        int v247 = v246;
        while (1)
        {
          unint64_t v248 = read(v247, v289, *(void *)(v3 + 56));
          if ((v248 & 0x8000000000000000) != 0)
          {
            v266 = __error();
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", 1377, 12, "read failed (%d): %s", v267, v268, v269, *v266);
            int v261 = 1;
            _DWORD *v285 = 1;
            goto LABEL_390;
          }
          unint64_t v254 = v248;
          if (!v248)
          {
            int v261 = 1;
            goto LABEL_390;
          }
          unint64_t v255 = v248 >= v245 ? v245 : v248;
          if (ParallelArchiveWriteEntryData(v296, (uint64_t)v289, v255, v249, v250, v251, v252, v253)) {
            break;
          }
          unint64_t v259 = v245 - v255;
          BOOL v260 = v254 > v245;
          unint64_t v245 = v259;
          if (v260)
          {
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", 1384, 12, "extra data: %s", v256, v257, v258, (char)v293);
            int v261 = 1;
            _DWORD *v285 = 1;
            unint64_t v245 = v259;
            goto LABEL_390;
          }
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", 1381, 12, 0, "write DAT, w=%zu: %s", v257, v258, v255);
        int v261 = 0;
LABEL_390:
        close(v247);
        if (v245) {
          goto LABEL_391;
        }
LABEL_397:
        if (!v261) {
          goto LABEL_418;
        }
      }
    }
    unint64_t v271 = v188[35 * v186 + 28];
    if (v271
      && ParallelArchiveWriteEntryData(v296, v305 + v188[35 * v186 + 27], v271, v240, v241, v242, v243, v244))
    {
      v274 = "write entry XAT";
      __int16 v275 = 1407;
      goto LABEL_417;
    }
    unint64_t v272 = v188[35 * v186 + 30];
    if (v272
      && ParallelArchiveWriteEntryData(v296, v305 + v188[35 * v186 + 29], v272, v240, v241, v242, v243, v244))
    {
      v274 = "write entry ACL";
      __int16 v275 = 1413;
      goto LABEL_417;
    }
    unint64_t v273 = v188[35 * v186 + 34];
    if (v273
      && ParallelArchiveWriteEntryData(v296, v305 + v188[35 * v186 + 33], v273, v240, v241, v242, v243, v244))
    {
      v274 = "write extra fields data";
      __int16 v275 = 1419;
      goto LABEL_417;
    }
    if (*v285 && (sendFailureEntry(&v295, v186, 2uLL) & 0x80000000) != 0)
    {
      v277 = "sending failure info";
      __int16 v278 = 1425;
      goto LABEL_439;
    }
    uint64_t v12 = v292;
    v187 = (unsigned char *)(v3 + 70);
LABEL_407:
    char v29 = 0;
    if (++v186 >= v301) {
      goto LABEL_28;
    }
  }
  v277 = "writing raw header";
  __int16 v278 = 1340;
LABEL_439:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", v278, 12, 0, v277, v243, v244, v280);
  int v276 = 4;
LABEL_440:
  char v29 = 1;
  if (v276 == 99) {
    goto LABEL_139;
  }
  uint64_t v12 = v292;
LABEL_28:
  BlobBufferFree((uint64_t)v304);
  ArchiveTreeDestroy((uint64_t)v300);
  free(v302);
  uint64_t v30 = v307;
  if (v307 && __count)
  {
    uint64_t v31 = 0;
    unint64_t v32 = 0;
    do
    {
      v33 = (char *)v307;
      uint64_t v34 = (char *)v307 + v31;
      uint64_t v35 = *(_opaque_pthread_t **)((char *)v307 + v31 + 16);
      if (v35) {
        joinThread(v35);
      }
      BlobBufferFree((uint64_t)(v34 + 160));
      if (!pthread_mutex_destroy((pthread_mutex_t *)(v34 + 48))) {
        pthread_cond_destroy((pthread_cond_t *)&v33[v31 + 112]);
      }
      ++v32;
      v31 += 200;
    }
    while (v32 < __count);
    uint64_t v30 = v307;
  }
  free(v30);
  if (!pthread_mutex_destroy(&v311) && !pthread_cond_destroy(&v312)) {
    free(v310);
  }
  uint64_t v36 = v314;
  if (v314)
  {
    unint64_t v37 = v313;
    if (v313)
    {
      unint64_t v38 = 0;
      uint64_t v39 = 8;
      do
      {
        v40 = *(_opaque_pthread_t **)((char *)v314 + v39);
        if (v40)
        {
          joinThread(v40);
          unint64_t v37 = v313;
        }
        ++v38;
        v39 += 48;
      }
      while (v38 < v37);
      uint64_t v36 = v314;
    }
  }
  free(v36);
  free(__ptr);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((result & 0x80000000) != 0) {
    return (int)result;
  }
  if (v29) {
    return -1;
  }
  return *(void *)(v3 + 40) - v12;
}

uint64_t cmpINOEntry(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a2 < *a1;
  }
}

uint64_t sendFailureEntry(void *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v6 = a1[1];
  if (ArchiveTreeNodePath(a1[132], a2, (uint64_t)__s, 0x800uLL) < 0)
  {
    uint64_t v10 = "entry path too long";
    __int16 v11 = 766;
  }
  else
  {
    unint64_t v9 = *(void *)(v6 + 56);
    if (v9 >= 0xFFFF) {
      unint64_t v9 = 0xFFFFLL;
    }
    if (v9 > 5)
    {
      uint64_t v12 = (_DWORD *)(v6 + 64);
      *(_WORD *)(v6 + 68) = 30840;
      *(_DWORD *)(v6 + 64) = 825246017;
      if (*(_DWORD *)(v6 + 32))
      {
        *(_WORD *)(v6 + 68) = 30840;
        *uint64_t v12 = 826360153;
      }
      unint64_t v13 = v9 - 6;
      uint64_t v14 = yaa_encodeKeyValue_uint((unsigned char *)(v6 + 70), v9 - 6, "TYP", 0x4DuLL);
      if (v14 < 0)
      {
        uint64_t v10 = "encode TYP field";
        __int16 v11 = 783;
      }
      else
      {
        uint64_t v15 = v6 + 70 + v14;
        unint64_t v16 = v13 - v14;
        size_t v17 = yaa_encodeKeyValue_path(v15, v16, "PAT", __s);
        if ((v17 & 0x8000000000000000) != 0)
        {
          uint64_t v10 = "encode PAT field";
          __int16 v11 = 787;
        }
        else
        {
          uint64_t v18 = (unsigned char *)(v15 + v17);
          unint64_t v19 = v16 - v17;
          uint64_t v20 = yaa_encodeKeyValue_uint(v18, v19, "ERR", a3);
          if (v20 < 0)
          {
            uint64_t v10 = "encode ERR field";
            __int16 v11 = 791;
          }
          else
          {
            uint64_t v21 = &v18[v20];
            uint64_t v22 = yaa_encodeKeyValue_uint(&v18[v20], v19 - v20, "EYP", *(unsigned int *)(a1[134] + 280 * a2));
            if (v22 < 0)
            {
              uint64_t v10 = "encode EYP field";
              __int16 v11 = 795;
            }
            else
            {
              uint64_t v25 = &v21[v22] - (unsigned char *)v12;
              *(_WORD *)(v6 + 68) = v25;
              if ((yaa_writeRawEntryHeader(v6, v6 + 64, v25, 0, v23, v24, v7, v8) & 0x80000000) == 0) {
                return 0;
              }
              uint64_t v10 = "writing raw header";
              __int16 v11 = 802;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v10 = "encode header field";
      __int16 v11 = 775;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"sendFailureEntry", v11, 12, 0, v10, v7, v8, v27);
  return 0xFFFFFFFFLL;
}

void *aaInSituStreamOpen(void *a1, uint64_t a2, int a3, int a4, int a5)
{
  uint64_t v10 = calloc(1uLL, 0x68uLL);
  __int16 v11 = calloc(1uLL, 0x140uLL);
  uint64_t v14 = (uint64_t)v11;
  if (!v10 || !v11)
  {
    uint64_t v23 = "aaCalloc";
    __int16 v24 = 336;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"aaInSituStreamOpen", v24, 140, 0, v23, v12, v13, v33);
    free(v10);
    InSituStreamClose(v14, v25, v26, v27, v28, v29, v30, v31);
    return 0;
  }
  *(void *)__int16 v11 = a1;
  v11[78] = a5;
  unint64_t v15 = (unint64_t)(a2 + 0x3FFF) >> 14;
  v11[72] = v15;
  LODWORD(v15) = v15 + ((a3 + 0x3FFF) >> 14) + ((int)v15 >> 2);
  v11[79] = a4;
  size_t v16 = (v15 + 256);
  *(_DWORD *)(v14 + 292) = v16;
  if ((int)v15 + 256 < 0)
  {
    *__error() = 12;
    *(void *)(v14 + 8) = 0;
    goto LABEL_14;
  }
  size_t v17 = calloc(v16, 0xDuLL);
  *(void *)(v14 + 8) = v17;
  if (!v17)
  {
LABEL_14:
    uint64_t v23 = "aaCalloc";
    __int16 v24 = 347;
    goto LABEL_16;
  }
  *(void *)&long long v18 = -1;
  *((void *)&v18 + 1) = -1;
  *(_OWORD *)(v14 + 240) = v18;
  *(_OWORD *)(v14 + 256) = v18;
  *(_OWORD *)(v14 + 208) = v18;
  *(_OWORD *)(v14 + 224) = v18;
  *(_OWORD *)(v14 + 176) = v18;
  *(_OWORD *)(v14 + 192) = v18;
  *(_OWORD *)(v14 + 144) = v18;
  *(_OWORD *)(v14 + 160) = v18;
  *(_OWORD *)(v14 + 112) = v18;
  *(_OWORD *)(v14 + 128) = v18;
  *(_OWORD *)(v14 + 80) = v18;
  *(_OWORD *)(v14 + 96) = v18;
  *(_OWORD *)(v14 + 48) = v18;
  *(_OWORD *)(v14 + 64) = v18;
  *(_OWORD *)(v14 + 16) = v18;
  *(_OWORD *)(v14 + 32) = v18;
  int v19 = *(_DWORD *)(v14 + 292);
  if (v19 >= 1)
  {
    uint64_t v20 = 0;
    for (uint64_t i = 0; i < v19; ++i)
    {
      uint64_t v22 = *(void *)(v14 + 8) + v20;
      *(_DWORD *)(v22 + 1) = i;
      *(void *)(v22 + 5) = 0xFFFFFFFF00000000;
      if (i < *(int *)(v14 + 288))
      {
        free_page(v14, i);
        int v19 = *(_DWORD *)(v14 + 292);
      }
      v20 += 13;
    }
  }
  if ((AAByteStreamTruncate(a1) & 0x80000000) != 0)
  {
    uint64_t v23 = "AAByteStreamTruncate";
    __int16 v24 = 362;
    goto LABEL_16;
  }
  AACustomByteStreamSetData((AAByteStream)v10, (void *)v14);
  AACustomByteStreamSetCloseProc((AAByteStream)v10, (AAByteStreamCloseProc)InSituStreamClose);
  AACustomByteStreamSetPReadProc((AAByteStream)v10, (AAByteStreamPReadProc)InSituStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v10, (AAByteStreamPWriteProc)InSituStreamPWrite);
  AACustomByteStreamSetCancelProc((AAByteStream)v10, (AAByteStreamCancelProc)InSituStreamCancel);
  AACustomByteStreamSetCloseProc((AAByteStream)v10, (AAByteStreamCloseProc)InSituStreamClose);
  v10[8] = InSituTruncate;
  v10[11] = InSituStreamSimulate;
  return v10;
}

uint64_t free_page(uint64_t result, int a2)
{
  uint64_t v3 = result;
  for (uint64_t i = *(void *)(result + 8); ; a2 = *(_DWORD *)(i + 13 * a2 + 1))
  {
    uint64_t v5 = (unsigned char *)(i + 13 * a2);
    int v6 = *v5;
    if (v6 != 2) {
      break;
    }
  }
  if (v6 == 1)
  {
    *uint64_t v5 = 0;
    *(_DWORD *)(i + 13 * a2 + 5) = 0;
  }
  ++*(_DWORD *)(result + 296);
  uint64_t v7 = i + 13 * a2;
  int v9 = *(_DWORD *)(v7 + 9);
  uint64_t v8 = (_DWORD *)(v7 + 9);
  if (v9 < 0)
  {
    int v10 = *(_DWORD *)(result + 276);
    *(_DWORD *)(result + 276) = v10 - 1;
    if (v10 >= 2)
    {
      int v11 = *(_DWORD *)(result + 272);
    }
    else
    {
      *(_DWORD *)(result + 276) = 32;
      uint64_t result = rand();
      int v11 = result & 0x3F;
      *(_DWORD *)(v3 + 272) = v11;
    }
    uint64_t v12 = v3 + 4 * v11;
    *uint64_t v8 = *(_DWORD *)(v12 + 16);
    *(_DWORD *)(v12 + 16) = a2;
  }
  return result;
}

uint64_t InSituStreamClose(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = result;
    uint64_t v9 = *(unsigned int *)(result + 292);
    if ((int)v9 < 1) {
      goto LABEL_7;
    }
    int v10 = 0;
    int v11 = (int *)(*(void *)(result + 8) + 5);
    do
    {
      int v12 = *v11;
      int v11 = (int *)((char *)v11 + 13);
      v10 += v12;
      --v9;
    }
    while (v9);
    if (v10)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamClose", 298, 140, 0, "%i dangling reads", a7, a8, v10);
      int v13 = 0;
    }
    else
    {
LABEL_7:
      int v13 = 1;
    }
    int v14 = *(_DWORD *)(v8 + 288);
    int v15 = *(_DWORD *)(v8 + 308);
    if (*(_DWORD *)(v8 + 300) + v14 != *(_DWORD *)(v8 + 296) + v15)
    {
      pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamClose", 301, 140, "file + excess != written + free", a6, a7, a8, v18);
      int v14 = *(_DWORD *)(v8 + 288);
      int v15 = *(_DWORD *)(v8 + 308);
    }
    if (v14 < v15) {
      pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamClose", 302, 140, "file < written", a6, a7, a8, v18);
    }
    if (*(_DWORD *)(v8 + 316)) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "InSituStream: pages: %i file, %i written, %i remapped, %i free, %i excess (%iK)\n", *(_DWORD *)(v8 + 288), *(_DWORD *)(v8 + 308), *(_DWORD *)(v8 + 304), *(_DWORD *)(v8 + 296), *(_DWORD *)(v8 + 300), 16 * *(_DWORD *)(v8 + 300));
    }
    free(*(void **)(v8 + 8));
    if (*(_DWORD *)(v8 + 312) && AAByteStreamClose(*(AAByteStream *)v8) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamClose", 319, 140, 0, "AAByteStreamClose", v16, v17, v18);
      int v13 = 0;
    }
    free((void *)v8);
    if (v13) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t InSituStreamPRead(void *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    return 0;
  }
  unint64_t v11 = 0;
  while (1)
  {
    uint64_t v12 = a1[1];
    uint64_t v13 = (v11 + a4) & 0x3FFF;
    uint64_t v14 = a3 - v11 >= 0x4000 - v13 ? 0x4000 - v13 : a3 - v11;
    if (!*(_DWORD *)(v12 + 13 * (int)((v11 + a4) >> 14) + 5)) {
      break;
    }
    uint64_t v15 = *a1;
    if (!*(void *)(*a1 + 32)) {
      goto LABEL_19;
    }
    if (v14)
    {
      uint64_t v16 = 0;
      uint64_t v17 = v13 | ((uint64_t)*(int *)(v12 + 13 * (int)((uint64_t)(v11 + a4) >> 14) + 1) << 14);
      uint64_t v18 = a2 + v11;
      uint64_t v19 = v14;
      while (1)
      {
        uint64_t v20 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(v15 + 32))(*(void *)v15, v18, v19, v17);
        if (v20 < 0) {
          break;
        }
        if (v20)
        {
          v18 += v20;
          v16 += v20;
          v17 += v20;
          v19 -= v20;
          if (v19) {
            continue;
          }
        }
        goto LABEL_15;
      }
      uint64_t v16 = v20;
LABEL_15:
      if (v14 != v16)
      {
LABEL_19:
        uint64_t v21 = "aaByteStreamPReadExpected";
        __int16 v22 = 238;
        goto LABEL_21;
      }
    }
    v11 += v14;
    if (v11 >= a3) {
      return v11;
    }
  }
  uint64_t v21 = "data not locked";
  __int16 v22 = 235;
LABEL_21:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamPRead", v22, 140, 0, v21, a7, a8, v24);
  return -1;
}

uint64_t InSituStreamPWrite(uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    return 0;
  }
  unint64_t v11 = 0;
  while (1)
  {
    uint64_t v12 = v11 + a4;
    unint64_t v13 = (v11 + a4) >> 14;
    uint64_t v14 = (unsigned char *)(a1[1] + 13 * (int)v13);
    if (a3 - v11 >= 0x4000 - ((v11 + a4) & 0x3FFF)) {
      uint64_t v15 = 0x4000 - ((v11 + a4) & 0x3FFF);
    }
    else {
      uint64_t v15 = a3 - v11;
    }
    if (*v14 == 2) {
      goto LABEL_9;
    }
    if ((remap_page(a1, v13) & 0x80000000) != 0) {
      break;
    }
    *uint64_t v14 = 2;
    --*((_DWORD *)a1 + 74);
    ++*((_DWORD *)a1 + 77);
LABEL_9:
    uint64_t v16 = *a1;
    if (!*(void *)(*a1 + 40)) {
      goto LABEL_20;
    }
    if (v15)
    {
      uint64_t v17 = 0;
      uint64_t v18 = a2 + v11;
      uint64_t v19 = v15;
      while (1)
      {
        uint64_t v20 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(v16 + 40))(*(void *)v16, v18, v19, v12);
        if (v20 < 1) {
          break;
        }
        v18 += v20;
        v17 += v20;
        v12 += v20;
        v19 -= v20;
        if (!v19) {
          goto LABEL_16;
        }
      }
      uint64_t v17 = v20;
LABEL_16:
      if (v15 != v17)
      {
LABEL_20:
        uint64_t v21 = "aaByteStreamPWriteExpected";
        __int16 v22 = 268;
        goto LABEL_22;
      }
    }
    v11 += v15;
    if (v11 >= a3) {
      return v11;
    }
  }
  uint64_t v21 = "remap_page";
  __int16 v22 = 261;
LABEL_22:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamPWrite", v22, 140, 0, v21, a7, a8, v24);
  return -1;
}

void InSituStreamCancel(AAByteStream *a1)
{
}

uint64_t InSituTruncate(void **a1)
{
  return AAByteStreamTruncate(*a1);
}

uint64_t InSituStreamSimulate(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a5;
  uint64_t v9 = a4;
  if (a2 == 3)
  {
    uint64_t v11 = *(void *)a1;
    if (!*(void *)(*(void *)a1 + 32)) {
      return -1;
    }
    if (!a4) {
      return 0;
    }
    uint64_t v13 = 0;
    while (1)
    {
      uint64_t v14 = (*(uint64_t (**)(void, uint64_t, uint64_t, unint64_t))(v11 + 32))(*(void *)v11, a3, v9, v8);
      if (v14 < 0) {
        break;
      }
      if (v14)
      {
        a3 += v14;
        v13 += v14;
        v8 += v14;
        v9 -= v14;
        if (v9) {
          continue;
        }
      }
      return v13;
    }
    return v14;
  }
  if (a4 < 1) {
    return v9;
  }
  if (a2 > 1)
  {
    uint64_t v23 = "not implemented";
    __int16 v24 = 197;
    goto LABEL_24;
  }
  int64_t v16 = a5 + a4;
  while (1)
  {
    uint64_t v17 = *(void *)(a1 + 8) + 13 * (int)(v8 >> 14);
    int v20 = *(_DWORD *)(v17 + 5);
    uint64_t v18 = (int *)(v17 + 5);
    int v19 = v20;
    if (!a2) {
      break;
    }
    if (v19 <= 0)
    {
      uint64_t v23 = "data not locked";
      __int16 v24 = 209;
      goto LABEL_24;
    }
    int v21 = v19 - 1;
    *uint64_t v18 = v21;
    if (!v21) {
      free_page(a1, v8 >> 14);
    }
LABEL_18:
    unint64_t v8 = (v8 & 0xFFFFFFFFFFFFC000) + 0x4000;
    if ((uint64_t)v8 >= v16) {
      return v9;
    }
  }
  *uint64_t v18 = v19 + 1;
  if (v19) {
    goto LABEL_18;
  }
  int v22 = *(_DWORD *)(a1 + 296);
  *(_DWORD *)(a1 + 296) = v22 - 1;
  if (v22) {
    goto LABEL_18;
  }
  uint64_t v23 = "no free pages";
  __int16 v24 = 204;
LABEL_24:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamSimulate", v24, 140, 0, v23, a7, a8, v26);
  return -1;
}

uint64_t remap_page(_DWORD *a1, int a2)
{
  uint64_t v2 = *((void *)a1 + 1);
  uint64_t v3 = v2 + 13 * a2;
  int v5 = *(_DWORD *)(v3 + 5);
  uint64_t v4 = (_DWORD *)(v3 + 5);
  if (v5)
  {
    if (*(unsigned char *)(v2 + 13 * a2) == 1)
    {
      uint64_t result = remap_page(a1, *(unsigned int *)(v2 + 13 * a2 + 1));
      *uint64_t v4 = 0;
      return result;
    }
    uint64_t v11 = (char *)malloc(0x4000uLL);
    uint64_t v14 = v11;
    if (v11)
    {
      int v15 = a1[74];
      if (v15 <= 0)
      {
        int v26 = a1[72];
        int v27 = a1[75];
        a1[75] = v27 + 1;
        unsigned int v19 = v27 + v26;
        if (v27 + v26 >= a1[73])
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"allocate_page", 97, 140, 0, "too many excess pages", v12, v13, v42);
        }
        else if ((v19 & 0x80000000) == 0)
        {
LABEL_20:
          uint64_t v28 = *(void *)a1;
          if (*(void *)(*(void *)a1 + 32))
          {
            uint64_t v29 = 0;
            uint64_t v30 = (unsigned int *)(v2 + 13 * a2 + 1);
            uint64_t v31 = (uint64_t)(int)*v30 << 14;
            uint64_t v32 = 0x4000;
            char v33 = v11;
            while (1)
            {
              uint64_t v34 = (*(uint64_t (**)(void, char *, uint64_t, uint64_t))(v28 + 32))(*(void *)v28, v33, v32, v31);
              if (v34 < 0) {
                break;
              }
              if (v34)
              {
                v33 += v34;
                v29 += v34;
                v31 += v34;
                v32 -= v34;
                if (v32) {
                  continue;
                }
              }
              if (v29 != 0x4000) {
                break;
              }
              uint64_t v35 = *(void *)a1;
              if (*(void *)(*(void *)a1 + 40))
              {
                uint64_t v36 = 0;
                unint64_t v37 = (unint64_t)v19 << 14;
                uint64_t v38 = 0x4000;
                uint64_t v39 = v14;
                while (1)
                {
                  uint64_t v40 = (*(uint64_t (**)(void, char *, uint64_t, unint64_t))(v35 + 40))(*(void *)v35, v39, v38, v37);
                  if (v40 < 1) {
                    break;
                  }
                  v39 += v40;
                  v36 += v40;
                  v37 += v40;
                  v38 -= v40;
                  if (!v38)
                  {
                    if (v36 != 0x4000) {
                      break;
                    }
                    uint64_t v10 = 0;
                    *uint64_t v30 = v19;
                    uint64_t v41 = *((void *)a1 + 1) + 13 * v19;
                    *(unsigned char *)uint64_t v41 = 1;
                    *(_DWORD *)(v41 + 1) = a2;
                    *(_DWORD *)(v41 + 5) = 0x7FFFFFFF;
                    ++a1[76];
                    ++a1[74];
                    goto LABEL_35;
                  }
                }
              }
              __int16 v24 = "aaByteStreamPWriteExpected";
              __int16 v25 = 158;
              goto LABEL_34;
            }
          }
          __int16 v24 = "aaByteStreamPReadExpected";
          __int16 v25 = 157;
          goto LABEL_34;
        }
      }
      else
      {
        int v16 = a1[70];
        a1[74] = v15 - 1;
        int v17 = a1[73];
        if (v17)
        {
          uint64_t v18 = &a1[(v16 & 0x3F) + 4];
          do
          {
            unsigned int v19 = *v18;
            if ((*v18 & 0x80000000) != 0
              || (v20 = a1[71], BOOL v21 = __OFSUB__(v20, 1), --v20, a1[71] = v20, (v20 < 0) ^ v21 | (v20 == 0)))
            {
              a1[71] = 32;
              int v22 = a1[70] + 1;
              a1[70] = v22;
              uint64_t v18 = &a1[(v22 & 0x3F) + 4];
            }
            else
            {
              uint64_t v23 = v2 + 13 * v19;
              *uint64_t v18 = *(_DWORD *)(v23 + 9);
              *(_DWORD *)(v23 + 9) = -1;
              if (!*(_DWORD *)(v23 + 5) && !*(unsigned char *)(v2 + 13 * v19)) {
                goto LABEL_20;
              }
            }
            --v17;
          }
          while (v17);
        }
      }
      __int16 v24 = "allocate_page";
      __int16 v25 = 153;
    }
    else
    {
      __int16 v24 = "aaMalloc";
      __int16 v25 = 149;
    }
LABEL_34:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"remap_page", v25, 140, 0, v24, v12, v13, v42);
    uint64_t v10 = 0xFFFFFFFFLL;
LABEL_35:
    free(v14);
    return v10;
  }
  return 0;
}

void *AATempStreamOpen(unint64_t a1)
{
  return AATempStreamOpenWithDirectory(a1, 0);
}

void *AATempStreamOpenWithDirectory(unint64_t a1, const char *a2)
{
  uint64_t v4 = calloc(1uLL, 0x68uLL);
  int v5 = (char *)malloc(0x88uLL);
  int v6 = v5;
  if (v5 && (memset_s(v5, 0x88uLL, 0, 0x88uLL), v4))
  {
    if (a2)
    {
      size_t v7 = strlen(a2);
      size_t v8 = v7 + 1;
      if (v7 + 1 < 0x2000000001)
      {
        int v15 = malloc(v7 + 1);
        uint64_t v9 = v15;
        if (v15) {
          memcpy(v15, a2, v8);
        }
      }
      else
      {
        uint64_t v9 = 0;
        *__error() = 12;
      }
    }
    else
    {
      uint64_t v9 = 0;
    }
    *((void *)v6 + 13) = v9;
    uint64_t v16 = a1 >> 20;
    if (a1 == -1) {
      uint64_t v16 = -1;
    }
    *((void *)v6 + 1) = 0x100000;
    *((void *)v6 + 2) = v16;
    if ((pthread_mutex_init((pthread_mutex_t *)(v6 + 40), 0) & 0x80000000) == 0)
    {
      *uint64_t v4 = v6;
      v4[1] = tempStreamClose;
      v4[7] = tempStreamCancel;
      v4[2] = tempStreamRead;
      v4[4] = tempStreamPRead;
      v4[6] = tempStreamSeek;
      v4[3] = tempStreamWrite;
      v4[5] = tempStreamPWrite;
      v4[8] = tempStreamTruncate;
      return v4;
    }
    int v10 = *__error();
    uint64_t v13 = "mutex init";
    __int16 v14 = 326;
  }
  else
  {
    int v10 = *__error();
    uint64_t v13 = "malloc";
    __int16 v14 = 320;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"AATempStreamOpenWithDirectory", v14, 50, v10, v13, v11, v12, v18);
  free(v6);
  free(v4);
  return 0;
}

uint64_t tempStreamClose(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = atomic_load((unsigned int *)(result + 128));
    AAByteStreamClose(*(AAByteStream *)(result + 112));
    uint64_t v3 = *(void **)(v1 + 32);
    if (v3)
    {
      if (*(void *)(v1 + 24))
      {
        unint64_t v4 = 0;
        do
          free(*(void **)(*(void *)(v1 + 32) + 8 * v4++));
        while (v4 < *(void *)(v1 + 24));
        uint64_t v3 = *(void **)(v1 + 32);
      }
      free(v3);
    }
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 40));
    free(*(void **)(v1 + 104));
    free((void *)v1);
    if (v2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
  return result;
}

void tempStreamCancel(uint64_t a1)
{
  int v1 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 128), (unsigned int *)&v1, 1u);
}

ssize_t tempStreamRead(uint64_t a1, void *a2, size_t a3)
{
  if (atomic_load((unsigned int *)(a1 + 128))) {
    return -1;
  }
  if (*(void *)(a1 + 112)) {
    return AAByteStreamRead(*(AAByteStream *)(a1 + 112), a2, a3);
  }
  return tempStreamPRead(a1, (char *)a2, a3, atomic_fetch_add((atomic_ullong *volatile)(a1 + 120), a3));
}

ssize_t tempStreamPRead(uint64_t a1, char *buf, size_t a3, off_t offset)
{
  if (atomic_load((unsigned int *)(a1 + 128))) {
    return -1;
  }
  unint64_t v7 = offset;
  size_t v8 = buf;
  int v10 = *(AAByteStream_impl **)(a1 + 112);
  if (!v10)
  {
    if (((offset | a3) & 0x8000000000000000) == 0)
    {
      int64_t v11 = offset + a3;
      if (!__OFADD__(offset, a3))
      {
        if (*(void *)a1 <= offset) {
          return 0;
        }
        if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 40)) < 0)
        {
          int v20 = *__error();
          uint64_t v23 = "mutex lock";
          __int16 v24 = 120;
        }
        else
        {
          if (v11 >= *(void *)a1) {
            unint64_t v12 = *(void *)a1;
          }
          else {
            unint64_t v12 = v11;
          }
          uint64_t v5 = 0;
          if (v12 > v7)
          {
            unint64_t v13 = *(void *)(a1 + 8);
            unint64_t v14 = v7 / v13;
            unint64_t v15 = v7 / v13 * v13;
            unint64_t v16 = v15 + v13;
            do
            {
              if (v16 >= v12) {
                unint64_t v17 = v12;
              }
              else {
                unint64_t v17 = v16;
              }
              memcpy(v8, (const void *)(*(void *)(*(void *)(a1 + 32) + 8 * v14) + v7 - v15), v17 - v7);
              v8 += v17 - v7;
              v5 += v17 - v7;
              ++v14;
              uint64_t v18 = *(void *)(a1 + 8);
              v15 += v18;
              unint64_t v7 = v17;
              BOOL v19 = v12 > v16;
              v16 += v18;
            }
            while (v19);
          }
          if ((pthread_mutex_unlock((pthread_mutex_t *)(a1 + 40)) & 0x80000000) == 0) {
            return v5;
          }
          int v20 = *__error();
          uint64_t v23 = "mutex unlock";
          __int16 v24 = 148;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamPRead", v24, 50, v20, v23, v21, v22, v26);
        int v25 = 0;
        atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 128), (unsigned int *)&v25, 1u);
      }
    }
    return -1;
  }

  return AAByteStreamPRead(v10, buf, a3, offset);
}

off_t tempStreamSeek(uint64_t a1, unint64_t a2, int a3)
{
  if (atomic_load((unsigned int *)(a1 + 128))) {
    return -1;
  }
  if (!*(void *)(a1 + 112))
  {
    if (a3)
    {
      if (a3 == 1)
      {
        a2 += atomic_fetch_add((atomic_ullong *volatile)(a1 + 120), a2);
        return a2;
      }
      if (a3 != 2) {
        return -1;
      }
      a2 += *(void *)a1;
    }
    atomic_store(a2, (unint64_t *)(a1 + 120));
    return a2;
  }
  return AAByteStreamSeek(*(AAByteStream *)(a1 + 112), a2, a3);
}

ssize_t tempStreamWrite(uint64_t a1, void *a2, size_t a3)
{
  if (atomic_load((unsigned int *)(a1 + 128))) {
    return -1;
  }
  if (*(void *)(a1 + 112)) {
    return AAByteStreamWrite(*(AAByteStream *)(a1 + 112), a2, a3);
  }
  return tempStreamPWrite(a1, (char *)a2, a3, atomic_fetch_add((atomic_ullong *volatile)(a1 + 120), a3));
}

ssize_t tempStreamPWrite(uint64_t a1, char *buf, size_t nbyte, unint64_t offset)
{
  if (atomic_load((unsigned int *)(a1 + 128))) {
    return -1;
  }
  unint64_t v7 = offset;
  uint64_t v9 = buf;
  int64_t v11 = *(AAByteStream_impl **)(a1 + 112);
  if (!v11)
  {
    if (((offset | nbyte) & 0x8000000000000000) != 0) {
      return -1;
    }
    int64_t v12 = offset + nbyte;
    if (__OFADD__(offset, nbyte)) {
      return -1;
    }
    unint64_t v13 = (pthread_mutex_t *)(a1 + 40);
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 40)) < 0)
    {
      int v26 = *__error();
      uint64_t v29 = "mutex lock";
      __int16 v30 = 164;
      goto LABEL_37;
    }
    if (v12 <= *(void *)a1) {
      uint64_t v20 = *(void *)a1;
    }
    else {
      uint64_t v20 = v7 + nbyte;
    }
    if ((resizeStream(a1, v20, v14, v15, v16, v17, v18, v19) & 0x80000000) != 0)
    {
      uint64_t v31 = "resizing stream";
      __int16 v32 = 170;
    }
    else
    {
      uint64_t v23 = *(AAByteStream_impl **)(a1 + 112);
      if (!v23)
      {
        if (v12 <= v7)
        {
          ssize_t v5 = 0;
        }
        else
        {
          ssize_t v5 = 0;
          unint64_t v33 = *(void *)(a1 + 8);
          unint64_t v34 = v7 / v33;
          unint64_t v35 = v7 / v33 * v33;
          unint64_t v36 = v35 + v33;
          do
          {
            if (v36 >= v12) {
              unint64_t v37 = v12;
            }
            else {
              unint64_t v37 = v36;
            }
            memcpy((void *)(*(void *)(*(void *)(a1 + 32) + 8 * v34) + v7 - v35), v9, v37 - v7);
            v9 += v37 - v7;
            v5 += v37 - v7;
            ++v34;
            uint64_t v38 = *(void *)(a1 + 8);
            v35 += v38;
            unint64_t v7 = v37;
            BOOL v39 = v12 > v36;
            v36 += v38;
          }
          while (v39);
        }
        int v25 = 0;
        uint64_t v40 = *(void *)a1;
        if (v12 > *(void *)a1) {
          uint64_t v40 = v12;
        }
        *(void *)a1 = v40;
        unint64_t v13 = (pthread_mutex_t *)(a1 + 40);
        goto LABEL_33;
      }
      ssize_t v24 = AAByteStreamPWrite(v23, v9, nbyte, v7);
      if ((v24 & 0x8000000000000000) == 0)
      {
        ssize_t v5 = v24;
        int v25 = 0;
LABEL_33:
        if ((pthread_mutex_unlock(v13) & 0x80000000) == 0)
        {
          if (!v25) {
            return v5;
          }
          goto LABEL_38;
        }
        int v26 = *__error();
        uint64_t v29 = "mutex unlock";
        __int16 v30 = 209;
LABEL_37:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamPWrite", v30, 50, v26, v29, v27, v28, v42);
LABEL_38:
        int v41 = 0;
        atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 128), (unsigned int *)&v41, 1u);
        return -1;
      }
      uint64_t v31 = "temp file write";
      __int16 v32 = 176;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamPWrite", v32, 50, 0, v31, v21, v22, v42);
    ssize_t v5 = 0;
    int v25 = 1;
    goto LABEL_33;
  }

  return AAByteStreamPWrite(v11, buf, nbyte, offset);
}

uint64_t tempStreamTruncate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (atomic_load((unsigned int *)(a1 + 128))) {
    return 0xFFFFFFFFLL;
  }
  int64_t v12 = *(void **)(a1 + 112);
  if (v12)
  {
    return AAByteStreamTruncate(v12);
  }
  if (a2 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamTruncate", 271, 50, 0, "invalid length", a7, a8, v30);
    return 0xFFFFFFFFLL;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 40)) < 0)
  {
    uint64_t v22 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamTruncate", 272, 50, *v22, "mutex lock", v23, v24, v30);
    int v25 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 128), (unsigned int *)&v25, 1u);
    return 0xFFFFFFFFLL;
  }
  if ((resizeStream(a1, a2, v13, v14, v15, v16, v17, v18) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamTruncate", 274, 50, 0, "resize stream", v19, v20, v30);
    int v21 = 0;
  }
  else
  {
    int v21 = 1;
  }
  if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 40)) < 0)
  {
    int v26 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamTruncate", 276, 50, *v26, "mutex lock", v27, v28, v30);
    int v29 = 0;
    int v21 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 128), (unsigned int *)&v29, 1u);
  }
  if (v21) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t resizeStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 112))
  {
    size_t v8 = "invalid state";
    __int16 v9 = 64;
LABEL_3:
    int v10 = 0;
LABEL_4:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"resizeStream", v9, 50, v10, v8, a7, a8, v42);
    return 0xFFFFFFFFLL;
  }
  if (*(void *)a1 >= a2) {
    goto LABEL_51;
  }
  uint64_t v14 = *(void *)(a1 + 8);
  if (__OFADD__(a2, v14))
  {
    char v42 = a2;
    size_t v8 = "new size out of range: %zu";
    __int16 v9 = 70;
    goto LABEL_3;
  }
  uint64_t v15 = (a2 + v14 - 1) / v14;
  if (v15 <= *(void *)(a1 + 16))
  {
    unint64_t v32 = *(void *)(a1 + 24);
    while (v32 < v15)
    {
      if (v32) {
        v32 *= 2;
      }
      else {
        unint64_t v32 = 32;
      }
    }
    if (8 * v32 >= 0x2000000001)
    {
      *__error() = 12;
LABEL_55:
      *(void *)(a1 + 32) = 0;
      int v10 = *__error();
      size_t v8 = "malloc";
      __int16 v9 = 89;
      goto LABEL_4;
    }
    unint64_t v33 = *(void **)(a1 + 32);
    unint64_t v34 = (char *)realloc(v33, 8 * v32);
    if (!v34)
    {
      free(v33);
      goto LABEL_55;
    }
    *(void *)(a1 + 32) = v34;
    memset_s(&v34[8 * *(void *)(a1 + 24)], 8 * (v32 - *(void *)(a1 + 24)), 0, 8 * (v32 - *(void *)(a1 + 24)));
    *(void *)(a1 + 24) = v32;
    uint64_t v35 = v15 - 1;
    while (v35 != -1 && !*(void *)(*(void *)(a1 + 32) + 8 * v35))
    {
      rsize_t v36 = *(void *)(a1 + 8);
      if (v36 < 0x2000000001)
      {
        uint64_t v38 = malloc(*(void *)(a1 + 8));
        unint64_t v37 = v38;
        if (v38) {
          memset_s(v38, v36, 0, v36);
        }
      }
      else
      {
        unint64_t v37 = 0;
        *__error() = 12;
      }
      *(void *)(*(void *)(a1 + 32) + 8 * v35) = v37;
      if (!*(void *)(*(void *)(a1 + 32) + 8 * v35--))
      {
        int v10 = *__error();
        size_t v8 = "malloc";
        __int16 v9 = 99;
        goto LABEL_4;
      }
    }
LABEL_51:
    uint64_t result = 0;
    *(void *)a1 = a2;
    return result;
  }
  uint64_t v16 = AATempFileStreamOpenWithDirectory(*(const char **)(a1 + 104));
  *(void *)(a1 + 112) = v16;
  if (!v16)
  {
    uint64_t v40 = "AATempFileStreamOpen";
    __int16 v41 = 36;
LABEL_57:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"offloadToFile", v41, 50, 0, v40, v17, v18, v42);
    size_t v8 = "offload to file";
    __int16 v9 = 76;
    goto LABEL_3;
  }
  uint64_t v19 = (void *)(a1 + 24);
  if (*(void *)(a1 + 24))
  {
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    while (*(void *)a1 > v21)
    {
      if (*(void *)(a1 + 8) >= *(void *)a1 - v21) {
        uint64_t v22 = *(void *)a1 - v21;
      }
      else {
        uint64_t v22 = *(void *)(a1 + 8);
      }
      uint64_t v23 = *(void *)(a1 + 112);
      if (*(void *)(v23 + 24))
      {
        uint64_t v24 = 0;
        if (v22)
        {
          uint64_t v25 = *(void *)(*(void *)(a1 + 32) + 8 * v20);
          uint64_t v26 = v22;
          while (1)
          {
            uint64_t v27 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v23 + 24))(*(void *)v23, v25, v26);
            if (v27 < 1) {
              break;
            }
            v25 += v27;
            v24 += v27;
            v26 -= v27;
            if (!v26) {
              goto LABEL_26;
            }
          }
          uint64_t v24 = v27;
        }
      }
      else
      {
        uint64_t v24 = -1;
      }
LABEL_26:
      if (v24 != v22)
      {
        uint64_t v40 = "writing data to temp file";
        __int16 v41 = 43;
        goto LABEL_57;
      }
      v21 += v22;
      if ((unint64_t)++v20 >= *v19)
      {
        if (!*v19) {
          goto LABEL_31;
        }
        break;
      }
    }
    unint64_t v28 = 0;
    do
      free(*(void **)(*(void *)(a1 + 32) + 8 * v28++));
    while (v28 < *(void *)(a1 + 24));
  }
LABEL_31:
  free(*(void **)(a1 + 32));
  *uint64_t v19 = 0;
  *(void *)(a1 + 32) = 0;
  if ((AAByteStreamTruncate(*(void **)(a1 + 112)) & 0x80000000) != 0)
  {
    size_t v8 = "truncate temp file";
    __int16 v9 = 78;
    goto LABEL_3;
  }
  int v29 = *(AAByteStream_impl **)(a1 + 112);
  off_t v30 = atomic_load((unint64_t *)(a1 + 120));
  off_t v31 = AAByteStreamSeek(v29, v30, 0);
  uint64_t result = 0;
  if (v31 < 0)
  {
    size_t v8 = "seek temp file";
    __int16 v9 = 80;
    goto LABEL_3;
  }
  return result;
}

uint64_t yaa_encodeKeyValue_marker(unsigned char *a1, unint64_t a2, char *a3)
{
  if (a2 < 4) {
    return -1;
  }
  *a1 = __toupper(*a3);
  a1[1] = __toupper(a3[1]);
  a1[2] = __toupper(a3[2]);
  a1[3] = __toupper(42);
  return 4;
}

uint64_t yaa_encodeKeyValue_uint(unsigned char *a1, unint64_t a2, char *a3, unint64_t a4)
{
  if (a4 <= 0xFF)
  {
    if (a2 >= 5)
    {
      *a1 = __toupper(*a3);
      a1[1] = __toupper(a3[1]);
      a1[2] = __toupper(a3[2]);
      a1[3] = __toupper(49);
      a1[4] = a4;
      return 5;
    }
    return -1;
  }
  if (!(a4 >> 16))
  {
    if (a2 >= 6)
    {
      *a1 = __toupper(*a3);
      a1[1] = __toupper(a3[1]);
      a1[2] = __toupper(a3[2]);
      a1[3] = __toupper(50);
      *((_WORD *)a1 + 2) = a4;
      return 6;
    }
    return -1;
  }
  if (!HIDWORD(a4))
  {
    if (a2 >= 8)
    {
      *a1 = __toupper(*a3);
      a1[1] = __toupper(a3[1]);
      a1[2] = __toupper(a3[2]);
      a1[3] = __toupper(52);
      *((_DWORD *)a1 + 1) = a4;
      return 8;
    }
    return -1;
  }
  if (a2 < 0xC) {
    return -1;
  }
  *a1 = __toupper(*a3);
  a1[1] = __toupper(a3[1]);
  a1[2] = __toupper(a3[2]);
  a1[3] = __toupper(56);
  *(void *)(a1 + 4) = a4;
  return 12;
}

uint64_t yaa_encodeKeyValue_blob(uint64_t a1, unint64_t a2, char *a3, unint64_t a4)
{
  if (!(a4 >> 16))
  {
    if (a2 >= 6)
    {
      *(unsigned char *)a1 = __toupper(*a3);
      *(unsigned char *)(a1 + 1) = __toupper(a3[1]);
      *(unsigned char *)(a1 + 2) = __toupper(a3[2]);
      *(unsigned char *)(a1 + 3) = __toupper(65);
      *(_WORD *)(a1 + 4) = a4;
      return 6;
    }
    return -1;
  }
  if (!HIDWORD(a4))
  {
    if (a2 >= 8)
    {
      *(unsigned char *)a1 = __toupper(*a3);
      *(unsigned char *)(a1 + 1) = __toupper(a3[1]);
      *(unsigned char *)(a1 + 2) = __toupper(a3[2]);
      *(unsigned char *)(a1 + 3) = __toupper(66);
      *(_DWORD *)(a1 + 4) = a4;
      return 8;
    }
    return -1;
  }
  if (a2 < 0xC) {
    return -1;
  }
  *(unsigned char *)a1 = __toupper(*a3);
  *(unsigned char *)(a1 + 1) = __toupper(a3[1]);
  *(unsigned char *)(a1 + 2) = __toupper(a3[2]);
  *(unsigned char *)(a1 + 3) = __toupper(67);
  *(void *)(a1 + 4) = a4;
  return 12;
}

uint64_t yaa_encodeKeyValue_cksum(uint64_t a1, unint64_t a2, char *a3, _DWORD *a4)
{
  if (a2 < 8) {
    return -1;
  }
  *(unsigned char *)a1 = __toupper(*a3);
  *(unsigned char *)(a1 + 1) = __toupper(a3[1]);
  *(unsigned char *)(a1 + 2) = __toupper(a3[2]);
  *(unsigned char *)(a1 + 3) = __toupper(70);
  *(_DWORD *)(a1 + 4) = *a4;
  return 8;
}

uint64_t yaa_encodeKeyValue_sha1(uint64_t a1, unint64_t a2, char *a3, uint64_t a4)
{
  if (a2 < 0x18) {
    return -1;
  }
  *(unsigned char *)a1 = __toupper(*a3);
  *(unsigned char *)(a1 + 1) = __toupper(a3[1]);
  *(unsigned char *)(a1 + 2) = __toupper(a3[2]);
  *(unsigned char *)(a1 + 3) = __toupper(71);
  int v8 = *(_DWORD *)(a4 + 16);
  *(_OWORD *)(a1 + 4) = *(_OWORD *)a4;
  *(_DWORD *)(a1 + 20) = v8;
  return 24;
}

uint64_t yaa_encodeKeyValue_sha256(uint64_t a1, unint64_t a2, char *a3, _OWORD *a4)
{
  if (a2 < 0x24) {
    return -1;
  }
  *(unsigned char *)a1 = __toupper(*a3);
  *(unsigned char *)(a1 + 1) = __toupper(a3[1]);
  *(unsigned char *)(a1 + 2) = __toupper(a3[2]);
  *(unsigned char *)(a1 + 3) = __toupper(72);
  long long v8 = a4[1];
  *(_OWORD *)(a1 + 4) = *a4;
  *(_OWORD *)(a1 + 20) = v8;
  return 36;
}

size_t yaa_encodeKeyValue_path(uint64_t a1, unint64_t a2, char *a3, char *__s)
{
  size_t v8 = strlen(__s);
  size_t result = -1;
  if (!(v8 >> 16) && v8 + 6 <= a2)
  {
    *(unsigned char *)a1 = __toupper(*a3);
    *(unsigned char *)(a1 + 1) = __toupper(a3[1]);
    *(unsigned char *)(a1 + 2) = __toupper(a3[2]);
    *(unsigned char *)(a1 + 3) = __toupper(80);
    *(_WORD *)(a1 + 4) = v8;
    memcpy((void *)(a1 + 6), __s, v8);
    return v8 + 6;
  }
  return result;
}

uint64_t yaa_encodeKeyValue_timespec(uint64_t a1, unint64_t a2, char *a3, uint64_t *a4)
{
  uint64_t v6 = *a4;
  uint64_t v7 = a4[1];
  if ((unint64_t)(v7 - 1000000000) < 0xFFFFFFFFC4653601)
  {
    if (a2 >= 0xC)
    {
      *(unsigned char *)a1 = __toupper(*a3);
      *(unsigned char *)(a1 + 1) = __toupper(a3[1]);
      *(unsigned char *)(a1 + 2) = __toupper(a3[2]);
      *(unsigned char *)(a1 + 3) = __toupper(83);
      *(void *)(a1 + 4) = v6;
      return 12;
    }
    return -1;
  }
  if (a2 < 0x10) {
    return -1;
  }
  *(unsigned char *)a1 = __toupper(*a3);
  *(unsigned char *)(a1 + 1) = __toupper(a3[1]);
  *(unsigned char *)(a1 + 2) = __toupper(a3[2]);
  *(unsigned char *)(a1 + 3) = __toupper(84);
  *(void *)(a1 + 4) = v6;
  *(_DWORD *)(a1 + 12) = v7;
  return 16;
}

size_t yaa_encodeHeaderField(unsigned char *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(*(_DWORD *)(a3 + 4))
  {
    case 1:
      unint64_t v8 = *(void *)(a3 + 8);
      size_t result = yaa_encodeKeyValue_uint(a1, a2, (char *)a3, v8);
      break;
    case 2:
      unint64_t v10 = *(void *)(a3 + 8);
      size_t result = yaa_encodeKeyValue_blob((uint64_t)a1, a2, (char *)a3, v10);
      break;
    case 3:
      size_t result = yaa_encodeKeyValue_timespec((uint64_t)a1, a2, (char *)a3, (uint64_t *)(a3 + 8));
      break;
    case 4:
      size_t result = yaa_encodeKeyValue_cksum((uint64_t)a1, a2, (char *)a3, (_DWORD *)(a3 + 8));
      break;
    case 5:
      size_t result = yaa_encodeKeyValue_sha1((uint64_t)a1, a2, (char *)a3, a3 + 8);
      break;
    case 6:
      size_t result = yaa_encodeKeyValue_sha256((uint64_t)a1, a2, (char *)a3, (_OWORD *)(a3 + 8));
      break;
    case 7:
      size_t result = yaa_encodeKeyValue_path((uint64_t)a1, a2, (char *)a3, (char *)(a3 + 8));
      break;
    case 8:
      size_t result = yaa_encodeKeyValue_marker(a1, a2, (char *)a3);
      break;
    default:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_encodeHeaderField", 190, 10, 0, "invalid valueType in field", a7, a8, vars0);
      size_t result = -1;
      break;
  }
  return result;
}

uint64_t yaa_encodeHeader(uint64_t a1, unint64_t a2, int *a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 >= 0xFFFF) {
    unint64_t v8 = 0xFFFFLL;
  }
  else {
    unint64_t v8 = a2;
  }
  if ((*(unsigned char *)a3 & 1) == 0)
  {
    __int16 v9 = "invalid header, TYP must be set";
    __int16 v10 = 204;
LABEL_6:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_encodeHeader", v10, 10, 0, v9, a7, a8, v43);
    return -1;
  }
  unsigned int v12 = a3[1] - 66;
  BOOL v13 = v12 > 0x11;
  int v14 = (1 << v12) & 0x24C57;
  if (v13 || v14 == 0)
  {
    __int16 v9 = "invalid entryType";
    __int16 v10 = 217;
    goto LABEL_6;
  }
  unint64_t v16 = v8 - 6;
  if (v8 < 6) {
    return -1;
  }
  uint64_t v18 = a4;
  *(_WORD *)(a1 + 4) = 30840;
  *(_DWORD *)a1 = 825246017;
  int v20 = *a3;
  if (*a3)
  {
    if (v16 < 5) {
      return -1;
    }
    int v22 = a3[1];
    *(unsigned char *)(a1 + 6) = __toupper(84);
    *(unsigned char *)(a1 + 7) = __toupper(89);
    *(unsigned char *)(a1 + 8) = __toupper(80);
    *(unsigned char *)(a1 + 9) = __toupper(49);
    *(unsigned char *)(a1 + 10) = v22;
    uint64_t v21 = a1 + 11;
    unint64_t v16 = v8 - 11;
    int v20 = *a3;
    if ((*a3 & 0x8000) == 0)
    {
LABEL_14:
      if ((v20 & 0x10000) == 0) {
        goto LABEL_15;
      }
      goto LABEL_26;
    }
  }
  else
  {
    uint64_t v21 = a1 + 6;
    if ((v20 & 0x8000) == 0) {
      goto LABEL_14;
    }
  }
  size_t v23 = yaa_encodeKeyValue_path(v21, v16, "PAT", (char *)a3 + 144);
  if ((v23 & 0x8000000000000000) != 0) {
    return -1;
  }
  v21 += v23;
  v16 -= v23;
  int v20 = *a3;
  if ((*a3 & 0x10000) == 0)
  {
LABEL_15:
    if ((v20 & 2) == 0) {
      goto LABEL_16;
    }
    goto LABEL_28;
  }
LABEL_26:
  size_t v24 = yaa_encodeKeyValue_path(v21, v16, "LNK", (char *)a3 + 1168);
  if ((v24 & 0x8000000000000000) != 0) {
    return -1;
  }
  v21 += v24;
  v16 -= v24;
  int v20 = *a3;
  if ((*a3 & 2) == 0)
  {
LABEL_16:
    if ((v20 & 4) == 0) {
      goto LABEL_17;
    }
    goto LABEL_30;
  }
LABEL_28:
  uint64_t v25 = yaa_encodeKeyValue_uint((unsigned char *)v21, v16, "UID", a3[2]);
  if (v25 < 0) {
    return -1;
  }
  v21 += v25;
  v16 -= v25;
  int v20 = *a3;
  if ((*a3 & 4) == 0)
  {
LABEL_17:
    if ((v20 & 0x10) == 0) {
      goto LABEL_18;
    }
    goto LABEL_32;
  }
LABEL_30:
  uint64_t v26 = yaa_encodeKeyValue_uint((unsigned char *)v21, v16, "GID", a3[3]);
  if (v26 < 0) {
    return -1;
  }
  v21 += v26;
  v16 -= v26;
  int v20 = *a3;
  if ((*a3 & 0x10) == 0)
  {
LABEL_18:
    if ((v20 & 0x20) == 0) {
      goto LABEL_19;
    }
    goto LABEL_35;
  }
LABEL_32:
  BOOL v27 = v16 >= 6;
  v16 -= 6;
  if (!v27) {
    return -1;
  }
  int v28 = a3[5];
  *(unsigned char *)uint64_t v21 = __toupper(77);
  *(unsigned char *)(v21 + 1) = __toupper(79);
  *(unsigned char *)(v21 + 2) = __toupper(68);
  *(unsigned char *)(v21 + 3) = __toupper(50);
  *(_WORD *)(v21 + 4) = v28;
  v21 += 6;
  int v20 = *a3;
  if ((*a3 & 0x20) == 0)
  {
LABEL_19:
    if ((v20 & 0x40) == 0) {
      goto LABEL_20;
    }
LABEL_37:
    uint64_t v30 = yaa_encodeKeyValue_uint((unsigned char *)v21, v16, "INO", *((void *)a3 + 4));
    if (v30 < 0) {
      return -1;
    }
    v21 += v30;
    v16 -= v30;
    int v20 = *a3;
    if ((*a3 & 0x80) == 0) {
      goto LABEL_41;
    }
    goto LABEL_39;
  }
LABEL_35:
  uint64_t v29 = yaa_encodeKeyValue_uint((unsigned char *)v21, v16, "DEV", a3[6]);
  if (v29 < 0) {
    return -1;
  }
  v21 += v29;
  v16 -= v29;
  int v20 = *a3;
  if ((*a3 & 0x40) != 0) {
    goto LABEL_37;
  }
LABEL_20:
  if ((v20 & 0x80) != 0)
  {
LABEL_39:
    uint64_t v31 = yaa_encodeKeyValue_uint((unsigned char *)v21, v16, "SIZ", *((void *)a3 + 5));
    if (v31 < 0) {
      return -1;
    }
    v21 += v31;
    v16 -= v31;
    int v20 = *a3;
  }
LABEL_41:
  if ((v20 & 8) != 0)
  {
    uint64_t v32 = yaa_encodeKeyValue_uint((unsigned char *)v21, v16, "FLG", a3[4]);
    if (v32 < 0) {
      return -1;
    }
    v21 += v32;
    v16 -= v32;
    int v20 = *a3;
  }
  if ((v20 & 0x100) != 0)
  {
    uint64_t v33 = yaa_encodeKeyValue_timespec(v21, v16, "MTM", (uint64_t *)a3 + 6);
    if (v33 < 0) {
      return -1;
    }
    v21 += v33;
    v16 -= v33;
    int v20 = *a3;
  }
  if ((v20 & 0x1000) != 0)
  {
    uint64_t v34 = yaa_encodeKeyValue_cksum(v21, v16, "CKS", a3 + 22);
    if (v34 < 0) {
      return -1;
    }
    v21 += v34;
    v16 -= v34;
    int v20 = *a3;
  }
  if ((v20 & 0x2000) != 0)
  {
    uint64_t v35 = yaa_encodeKeyValue_sha1(v21, v16, "SH1", (uint64_t)(a3 + 23));
    if (v35 < 0) {
      return -1;
    }
    v21 += v35;
    v16 -= v35;
    int v20 = *a3;
  }
  if ((v20 & 0x4000) != 0)
  {
    uint64_t v36 = yaa_encodeKeyValue_sha256(v21, v16, "SH2", (_OWORD *)a3 + 7);
    if (v36 < 0) {
      return -1;
    }
    v21 += v36;
    v16 -= v36;
    int v20 = *a3;
  }
  if ((v20 & 0x200) != 0)
  {
    uint64_t v37 = yaa_encodeKeyValue_blob(v21, v16, "DAT", *((void *)a3 + 8));
    if (v37 < 0) {
      return -1;
    }
    v21 += v37;
    v16 -= v37;
    int v20 = *a3;
  }
  if ((v20 & 0x400) != 0)
  {
    uint64_t v38 = yaa_encodeKeyValue_blob(v21, v16, "XAT", *((void *)a3 + 9));
    if (v38 < 0) {
      return -1;
    }
    v21 += v38;
    v16 -= v38;
    int v20 = *a3;
  }
  if ((v20 & 0x800) != 0)
  {
    uint64_t v39 = yaa_encodeKeyValue_blob(v21, v16, "ACL", *((void *)a3 + 10));
    if (v39 < 0) {
      return -1;
    }
    v21 += v39;
    v16 -= v39;
  }
  if (!v18 || !a5)
  {
LABEL_70:
    uint64_t result = v21 - a1;
    *(_WORD *)(a1 + 4) = v21 - a1;
    return result;
  }
  unint64_t v40 = 0;
  while (1)
  {
    size_t v41 = yaa_encodeHeaderField((unsigned char *)v21, v16, v18, a4, a5, a6, a7, a8);
    if ((v41 & 0x8000000000000000) != 0) {
      return -1;
    }
    v21 += v41;
    v16 -= v41;
    ++v40;
    v18 += 1032;
    if (v40 >= a5) {
      goto LABEL_70;
    }
  }
}

uint64_t yaa_encodeACE(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)a3 - 1;
  if (v8 >= 4)
  {
    unint64_t v16 = "invalid ACE type";
    __int16 v17 = 281;
LABEL_8:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_encodeACE", v17, 10, 0, v16, a7, a8, v18);
    return -1;
  }
  unsigned int v10 = *(_DWORD *)(a3 + 24) - 1;
  if (v10 >= 4)
  {
    unint64_t v16 = "invalid ACE qualifier type";
    __int16 v17 = 298;
    goto LABEL_8;
  }
  size_t v13 = strlen((const char *)(a3 + 28));
  size_t v14 = v13 + 22;
  uint64_t result = -1;
  if (v13 + 22 <= a2 && !HIDWORD(v14))
  {
    *(_DWORD *)a1 = v14;
    *(unsigned char *)(a1 + 4) = 0x4C554441u >> (8 * v8);
    *(void *)(a1 + 5) = *(void *)(a3 + 16);
    *(void *)(a1 + 13) = *(void *)(a3 + 8);
    *(unsigned char *)(a1 + 21) = 0x69736775u >> (8 * v10);
    memcpy((void *)(a1 + 22), (const void *)(a3 + 28), v13);
    return v14;
  }
  return result;
}

uint64_t yaa_decodeHeaderField(uint64_t a1, uint64_t a2, unint64_t a3)
{
  bzero((void *)a1, 0x408uLL);
  if (a3 < 4) {
    return -1;
  }
  for (uint64_t i = 0; i != 3; ++i)
    *(unsigned char *)(a1 + i) = __toupper(*(unsigned __int8 *)(a2 + i));
  switch(*(unsigned char *)(a2 + 3))
  {
    case 'A':
      if (a3 < 6) {
        return -1;
      }
      int v11 = 2;
LABEL_35:
      *(_DWORD *)(a1 + 4) = v11;
      *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 4);
      return 6;
    case 'B':
      if (a3 < 8) {
        return -1;
      }
      int v14 = 2;
      goto LABEL_38;
    case 'C':
      if (a3 < 0xC) {
        return -1;
      }
      int v15 = 2;
LABEL_41:
      *(_DWORD *)(a1 + 4) = v15;
      *(void *)(a1 + 8) = *(void *)(a2 + 4);
      return 12;
    case 'D':
    case 'E':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'O':
    case 'Q':
    case 'R':
LABEL_14:
      unsigned int v12 = "invalid fields storage type";
      __int16 v13 = 404;
      goto LABEL_15;
    case 'F':
      if (a3 < 8) {
        return -1;
      }
      int v14 = 4;
LABEL_38:
      *(_DWORD *)(a1 + 4) = v14;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 4);
      return 8;
    case 'G':
      if (a3 < 0x18) {
        return -1;
      }
      *(_DWORD *)(a1 + 4) = 5;
      long long v16 = *(_OWORD *)(a2 + 4);
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 20);
      *(_OWORD *)(a1 + 8) = v16;
      return 24;
    case 'H':
      if (a3 < 0x24) {
        return -1;
      }
      *(_DWORD *)(a1 + 4) = 6;
      long long v17 = *(_OWORD *)(a2 + 4);
      *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 20);
      *(_OWORD *)(a1 + 8) = v17;
      return 36;
    case 'P':
      if (a3 < 6) {
        return -1;
      }
      size_t v18 = *(unsigned __int16 *)(a2 + 4);
      if (v18 >= 0x3FF)
      {
        unsigned int v12 = "path too long in header";
        __int16 v13 = 396;
LABEL_15:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeaderField", v13, 10, 0, v12, v9, v10, v19);
        return -1;
      }
      size_t v6 = v18 + 6;
      if (v18 + 6 > a3) {
        return -1;
      }
      *(_DWORD *)(a1 + 4) = 7;
      memcpy((void *)(a1 + 8), (const void *)(a2 + 6), v18);
      break;
    case 'S':
      if (a3 < 0xC) {
        return -1;
      }
      *(_DWORD *)(a1 + 4) = 3;
      *(void *)(a1 + 8) = *(void *)(a2 + 4);
      *(void *)(a1 + 16) = 0;
      return 12;
    case 'T':
      if (a3 < 0x10) {
        return -1;
      }
      *(_DWORD *)(a1 + 4) = 3;
      *(void *)(a1 + 8) = *(void *)(a2 + 4);
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 12);
      return 16;
    default:
      switch(*(unsigned char *)(a2 + 3))
      {
        case '1':
          if (a3 < 5) {
            return -1;
          }
          *(_DWORD *)(a1 + 4) = 1;
          *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 4);
          return 5;
        case '2':
          if (a3 < 6) {
            return -1;
          }
          int v11 = 1;
          goto LABEL_35;
        case '3':
        case '5':
        case '6':
        case '7':
          goto LABEL_14;
        case '4':
          if (a3 < 8) {
            return -1;
          }
          int v14 = 1;
          goto LABEL_38;
        case '8':
          if (a3 < 0xC) {
            return -1;
          }
          int v15 = 1;
          goto LABEL_41;
        default:
          if (*(unsigned char *)(a2 + 3) != 42) {
            goto LABEL_14;
          }
          *(_DWORD *)(a1 + 4) = 8;
          return 4;
      }
  }
  return v6;
}

uint64_t yaa_decodeHeader(_DWORD *a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t *a6)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  bzero(a1, 0x890uLL);
  if (a3 < 6 || *(_DWORD *)a2 != 826360153 && *(_DWORD *)a2 != 825246017) {
    return -1;
  }
  unint64_t v12 = *(unsigned __int16 *)(a2 + 4);
  if (v12 < 6 || v12 > a3) {
    return -1;
  }
  uint64_t v15 = a2 + 6;
  unint64_t v16 = v12 - 6;
  if (v12 != 6)
  {
    unint64_t v28 = 0;
    memset(__src, 0, 512);
    while (1)
    {
      uint64_t v17 = yaa_decodeHeaderField((uint64_t)__src, v15, v16);
      if (v17 < 0) {
        return -1;
      }
      uint64_t v20 = v17;
      int v21 = __src[0] & 0xDFDFDF;
      if ((__src[0] & 0xDFDFDF) <= 0x4D544C)
      {
        if ((__src[0] & 0xDFDFDF) > 0x444F4C)
        {
          if ((__src[0] & 0xDFDFDF) > 0x4B4E4B)
          {
            if (v21 == 4935244)
            {
              if (DWORD1(__src[0]) != 7)
              {
                BOOL v27 = __src;
                uint64_t v25 = "invalid type for default field %s";
                __int16 v26 = 459;
LABEL_100:
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", v26, 10, 0, v25, v18, v19, (char)v27);
                return -1;
              }
              *a1 |= 0x10000u;
              strlcpy((char *)a1 + 1168, (const char *)__src + 8, 0x400uLL);
            }
            else
            {
              if (v21 != 4997953)
              {
LABEL_73:
                unint64_t v24 = v28;
                if (a4 && v28 < a5)
                {
                  memcpy((void *)(a4 + 1032 * v28), __src, 0x408uLL);
                  unint64_t v24 = v28;
                }
                unint64_t v28 = v24 + 1;
                goto LABEL_77;
              }
              if (DWORD1(__src[0]) != 2)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 473, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
                return -1;
              }
              *a1 |= 0x800u;
              *((void *)a1 + 10) = *((void *)&__src[0] + 1);
            }
          }
          else if (v21 == 4476749)
          {
            if (DWORD1(__src[0]) != 1)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 463, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
              return -1;
            }
            *a1 |= 0x10u;
            a1[5] = DWORD2(__src[0]);
          }
          else
          {
            if (v21 != 4672582) {
              goto LABEL_73;
            }
            if (DWORD1(__src[0]) != 1)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 462, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
              return -1;
            }
            *a1 |= 8u;
            a1[4] = DWORD2(__src[0]);
          }
        }
        else if ((__src[0] & 0xDFDFDF) > 0x444946)
        {
          if (v21 == 4475207)
          {
            if (DWORD1(__src[0]) != 1)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 461, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
              return -1;
            }
            *a1 |= 4u;
            a1[3] = DWORD2(__src[0]);
          }
          else
          {
            if (v21 != 4475221) {
              goto LABEL_73;
            }
            if (DWORD1(__src[0]) != 1)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 460, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
              return -1;
            }
            *a1 |= 2u;
            a1[2] = DWORD2(__src[0]);
          }
        }
        else if (v21 == 1132627)
        {
          if (DWORD1(__src[0]) != 5)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 469, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
            return -1;
          }
          *a1 |= 0x2000u;
          *(_OWORD *)(a1 + 23) = *(_OWORD *)((char *)__src + 8);
          a1[27] = DWORD2(__src[1]);
        }
        else
        {
          if (v21 != 1198163) {
            goto LABEL_73;
          }
          if (DWORD1(__src[0]) != 6)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 470, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
            return -1;
          }
          *a1 |= 0x4000u;
          long long v22 = *(_OWORD *)((char *)&__src[1] + 8);
          *((_OWORD *)a1 + 7) = *(_OWORD *)((char *)__src + 8);
          *((_OWORD *)a1 + 8) = v22;
        }
      }
      else if ((__src[0] & 0xDFDFDF) <= 0x544143)
      {
        if ((__src[0] & 0xDFDFDF) > 0x505953)
        {
          if (v21 == 5265748)
          {
            if (DWORD1(__src[0]) != 1)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 440, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
              return -1;
            }
            int v23 = DWORD2(__src[0]);
            if ((unint64_t)(*((void *)&__src[0] + 1) - 66) > 0x11
              || ((1 << (BYTE8(__src[0]) - 66)) & 0x24C57) == 0)
            {
              uint64_t v25 = "invalid entryType";
              __int16 v26 = 455;
              goto LABEL_100;
            }
            *a1 |= 1u;
            a1[1] = v23;
          }
          else
          {
            if (v21 != 5458755) {
              goto LABEL_73;
            }
            if (DWORD1(__src[0]) != 4)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 468, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
              return -1;
            }
            *a1 |= 0x1000u;
            a1[22] = DWORD2(__src[0]);
          }
        }
        else if (v21 == 5067853)
        {
          if (DWORD1(__src[0]) != 3)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 467, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
            return -1;
          }
          *a1 |= 0x100u;
          *((_OWORD *)a1 + 3) = *(_OWORD *)((char *)__src + 8);
        }
        else
        {
          if (v21 != 5197385) {
            goto LABEL_73;
          }
          if (DWORD1(__src[0]) != 1)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 465, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
            return -1;
          }
          *a1 |= 0x40u;
          *((void *)a1 + 4) = *((void *)&__src[0] + 1);
        }
      }
      else if ((__src[0] & 0xDFDFDF) <= 0x544157)
      {
        if (v21 == 5521732)
        {
          if (DWORD1(__src[0]) != 2)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 471, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
            return -1;
          }
          *a1 |= 0x200u;
          *((void *)a1 + 8) = *((void *)&__src[0] + 1);
        }
        else
        {
          if (v21 != 5521744) {
            goto LABEL_73;
          }
          if (DWORD1(__src[0]) != 7)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 458, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
            return -1;
          }
          *a1 |= 0x8000u;
          __strlcpy_chk();
        }
      }
      else
      {
        switch(v21)
        {
          case 5521752:
            if (DWORD1(__src[0]) != 2)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 472, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
              return -1;
            }
            *a1 |= 0x400u;
            *((void *)a1 + 9) = *((void *)&__src[0] + 1);
            break;
          case 5653828:
            if (DWORD1(__src[0]) != 1)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 464, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
              return -1;
            }
            *a1 |= 0x20u;
            a1[6] = DWORD2(__src[0]);
            break;
          case 5917011:
            if (DWORD1(__src[0]) != 1)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 466, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
              return -1;
            }
            *a1 |= 0x80u;
            *((void *)a1 + 5) = *((void *)&__src[0] + 1);
            break;
          default:
            goto LABEL_73;
        }
      }
LABEL_77:
      v15 += v20;
      v16 -= v20;
      if (!v16) {
        goto LABEL_80;
      }
    }
  }
  unint64_t v28 = 0;
LABEL_80:
  if (a6) {
    *a6 = v28;
  }
  return v15 - a2;
}

unint64_t yaa_decodeHeaderInfo(uint64_t a1, unint64_t a2, void *a3, void *a4)
{
  if (a2 < 6) {
    return -1;
  }
  if (*(_DWORD *)a1 != 826360153 && *(_DWORD *)a1 != 825246017) {
    return -1;
  }
  unint64_t result = *(unsigned __int16 *)(a1 + 4);
  if (result < 6 || result > a2) {
    return -1;
  }
  unint64_t v7 = result - 6;
  if (result != 6)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = (int *)(a1 + 6);
    while (1)
    {
      if (v7 < 4) {
        return -1;
      }
      int v11 = *((unsigned __int8 *)v10 + 3);
      int v19 = *v10;
      switch(*((unsigned char *)v10 + 3))
      {
        case 'A':
          if (v7 < 6) {
            return -1;
          }
          uint64_t v12 = *((unsigned __int16 *)v10 + 2);
          BOOL v13 = __CFADD__(v8, v12);
          v8 += v12;
          if (v13) {
            return -1;
          }
LABEL_20:
          unint64_t v14 = 6;
          break;
        case 'B':
          if (v7 < 8) {
            return -1;
          }
          uint64_t v15 = v10[1];
          BOOL v13 = __CFADD__(v8, v15);
          v8 += v15;
          if (v13) {
            return -1;
          }
          goto LABEL_25;
        case 'C':
          if (v7 < 0xC) {
            return -1;
          }
          uint64_t v16 = *(void *)(v10 + 1);
          BOOL v13 = __CFADD__(v8, v16);
          v8 += v16;
          if (v13) {
            return -1;
          }
          goto LABEL_28;
        case 'D':
        case 'E':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'Q':
        case 'R':
LABEL_64:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeaderInfo", 558, 10, 0, "invalid storage type in YAA header: 0x%02x, key=%s", 1052673, 4935243, v11);
          return -1;
        case 'F':
LABEL_25:
          unint64_t v14 = 8;
          break;
        case 'G':
          unint64_t v14 = 24;
          break;
        case 'H':
          unint64_t v14 = 36;
          break;
        case 'P':
          if (v7 < 6) {
            return -1;
          }
          unint64_t v14 = *((unsigned __int16 *)v10 + 2) + 6;
          break;
        case 'S':
LABEL_28:
          unint64_t v14 = 12;
          break;
        case 'T':
          unint64_t v14 = 16;
          break;
        default:
          unint64_t v14 = 5;
          switch(*((unsigned char *)v10 + 3))
          {
            case '1':
              goto LABEL_34;
            case '2':
              goto LABEL_20;
            case '3':
            case '5':
            case '6':
            case '7':
              goto LABEL_64;
            case '4':
              goto LABEL_25;
            case '8':
              goto LABEL_28;
            default:
              if (v11 != 42) {
                goto LABEL_64;
              }
              unint64_t v14 = 4;
              break;
          }
          break;
      }
LABEL_34:
      if (v7 < v14) {
        return -1;
      }
      int v17 = v19 & 0xDFDFDF;
      if ((v19 & 0xDFDFDFu) > 0x4F4E48)
      {
        if ((v19 & 0xDFDFDFu) <= 0x544143)
        {
          if (v17 == 5197385 || v17 == 5265748 || v17 == 5458755) {
            goto LABEL_58;
          }
        }
        else if ((v17 - 5521732) <= 0x14 && ((1 << (v17 - 68)) & 0x101001) != 0 {
               || v17 == 5653828
        }
               || v17 == 5917011)
        {
          goto LABEL_58;
        }
LABEL_60:
        if (v17 != 4997953) {
          ++v9;
        }
        goto LABEL_58;
      }
      if ((v19 & 0xDFDFDFu) > 0x444F4C)
      {
        if ((v19 & 0xDFDFDFu) > 0x4B4E4B)
        {
          if (v17 == 4935244) {
            goto LABEL_58;
          }
          int v18 = 5067853;
        }
        else
        {
          if (v17 == 4476749) {
            goto LABEL_58;
          }
          int v18 = 4672582;
        }
      }
      else if ((v19 & 0xDFDFDFu) > 0x444946)
      {
        if (v17 == 4475207) {
          goto LABEL_58;
        }
        int v18 = 4475221;
      }
      else
      {
        if (v17 == 1132627) {
          goto LABEL_58;
        }
        int v18 = 1198163;
      }
      if (v17 != v18) {
        goto LABEL_60;
      }
LABEL_58:
      uint64_t v10 = (int *)((char *)v10 + v14);
      v7 -= v14;
      if (!v7) {
        goto LABEL_63;
      }
    }
  }
  uint64_t v9 = 0;
  uint64_t v8 = 0;
LABEL_63:
  *a3 = v9;
  *a4 = v8;
  return result;
}

uint64_t yaa_decodeACE(unsigned int *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 240) = 0u;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  if (a2 <= 3)
  {
    uint64_t v8 = "invalid ACL blob";
    __int16 v9 = 610;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeACE", v9, 10, 0, v8, a7, a8, v23);
    return -1;
  }
  unint64_t v10 = *a1;
  if (v10 > a2)
  {
    uint64_t v8 = "invalid ACL blob";
    __int16 v9 = 612;
    goto LABEL_7;
  }
  __darwin_ct_rune_t v12 = *((char *)a1 + 4);
  *(void *)(a3 + 16) = *(void *)((char *)a1 + 5);
  *(void *)(a3 + 8) = *(void *)((char *)a1 + 13);
  if (v10 - 22 >= 0x101)
  {
    uint64_t v8 = "unsupported qualifier length";
    __int16 v9 = 622;
    goto LABEL_7;
  }
  __darwin_ct_rune_t v14 = *((char *)a1 + 21);
  memcpy((void *)(a3 + 28), (char *)a1 + 22, v10 - 22);
  __darwin_ct_rune_t v15 = __toupper(v12);
  if (v15 > 75)
  {
    if (v15 == 76)
    {
      int v18 = 4;
      goto LABEL_19;
    }
    if (v15 == 85)
    {
      int v18 = 3;
      goto LABEL_19;
    }
LABEL_21:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeACE", 632, 10, 0, "invalid ACE type in ACL blob: %c", v16, v17, v12);
    return -1;
  }
  if (v15 == 65)
  {
    int v18 = 1;
    goto LABEL_19;
  }
  if (v15 != 68) {
    goto LABEL_21;
  }
  int v18 = 2;
LABEL_19:
  *(_DWORD *)a3 = v18;
  HIDWORD(v21) = __toupper(v14) - 71;
  LODWORD(v21) = HIDWORD(v21);
  switch((v21 >> 1))
  {
    case 0u:
      int v22 = 2;
      break;
    case 1u:
      int v22 = 4;
      break;
    case 6u:
      int v22 = 3;
      break;
    case 7u:
      int v22 = 1;
      break;
    default:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeACE", 642, 10, 0, "invalid ACE qualifier type in ACL blob: %c", v19, v20, v14);
      return -1;
  }
  *(_DWORD *)(a3 + 24) = v22;
  return v10;
}

unint64_t yaa_decodeACL(uint64_t a1, unint64_t *a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10 = *a2;
  int v11 = *a3;
  if (a4)
  {
    __darwin_ct_rune_t v12 = (unsigned int *)a5;
    unint64_t v13 = a4;
    uint64_t v14 = 0;
    unint64_t v15 = 0;
    while (1)
    {
      if (v15 >= v10)
      {
        if (v10) {
          v10 += v10 >> 1;
        }
        else {
          unint64_t v10 = 8;
        }
        int v11 = reallocf(v11, 288 * v10);
        if (!v11) {
          break;
        }
      }
      uint64_t v16 = yaa_decodeACE(v12, v13, (uint64_t)v11 + v14, a4, a5, a6, a7, a8);
      if (v16 < 0)
      {
        uint64_t v17 = "decoding ACE";
        __int16 v18 = 670;
        int v19 = 0;
        goto LABEL_14;
      }
      ++v15;
      __darwin_ct_rune_t v12 = (unsigned int *)((char *)v12 + v16);
      v14 += 288;
      v13 -= v16;
      if (!v13) {
        goto LABEL_15;
      }
    }
    int v19 = *__error();
    uint64_t v17 = "malloc";
    __int16 v18 = 665;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeACL", v18, 10, v19, v17, a7, a8, v21);
    unint64_t v15 = -1;
  }
  else
  {
    unint64_t v15 = 0;
  }
LABEL_15:
  *a2 = v10;
  *a3 = v11;
  return v15;
}

uint64_t yaa_setEntryAttributes(char *a1, int *a2, uint64_t a3, int a4)
{
  uint64_t v73 = *MEMORY[0x263EF8340];
  v71[1] = 0;
  v71[2] = 0;
  v71[0] = 5;
  memset(v72, 0, sizeof(v72));
  if (a3 && (*(_WORD *)a3 & 1) != 0)
  {
    v72[0] = *(_OWORD *)(a3 + 8);
    int v8 = 512;
    HIDWORD(v71[0]) = 512;
    unsigned int v9 = 16;
  }
  else
  {
    int v8 = 0;
    unsigned int v9 = 0;
  }
  int v10 = *a2;
  if ((*a2 & 0x100) != 0)
  {
    long long v11 = *((_OWORD *)a2 + 3);
    __darwin_ct_rune_t v12 = (_OWORD *)((char *)v72 + v9);
    *__darwin_ct_rune_t v12 = v11;
    v12[1] = v11;
    v9 |= 0x20u;
    v8 |= 0x1400u;
    HIDWORD(v71[0]) = v8;
  }
  if (a3 && (*(_WORD *)a3 & 2) != 0)
  {
    *(_OWORD *)((char *)v72 + v9) = *(_OWORD *)(a3 + 24);
    v9 += 16;
    HIDWORD(v71[0]) = v8 | 0x2000;
  }
  if ((v10 & 2) != 0)
  {
    uid_t v13 = a2[2];
    if ((v10 & 4) != 0) {
      goto LABEL_12;
    }
  }
  else
  {
    uid_t v13 = -1;
    if ((v10 & 4) != 0)
    {
LABEL_12:
      gid_t v14 = a2[3];
      goto LABEL_15;
    }
  }
  gid_t v14 = -1;
LABEL_15:
  memset(&v70, 0, sizeof(v70));
  if (lstat(a1, &v70) < 0)
  {
    uint64_t v17 = __error();
    if (a4 && *v17 == 13) {
      return 0;
    }
    int v24 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 751, 10, v24, "%s", v25, v26, (char)a1);
    return 0xFFFFFFFFLL;
  }
  int v15 = v70.st_mode & 0xF000;
  if (v15 == 0x8000 || v15 == 0x4000) {
    uint64_t FileAPFSInternalFlags = getFileAPFSInternalFlags();
  }
  else {
    uint64_t FileAPFSInternalFlags = 0;
  }
  unsigned int v19 = a2[1] - 68;
  if (v19 > 8 || ((1 << v19) & 0x115) == 0)
  {
    if ((*a2 & 2) != 0 && v13 != v70.st_uid || (int v22 = 1, (*a2 & 4) != 0) && v14 != v70.st_gid)
    {
      if (!lchown(a1, v13, v14) || (uint64_t v30 = __error(), a4) && *v30 == 1)
      {
        int v22 = 1;
      }
      else
      {
        char v52 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 814, 10, *v52, "%s", v53, v54, (char)a1);
        int v22 = 0;
      }
    }
    if ((*(unsigned char *)a2 & 0x10) != 0)
    {
      int v55 = a2[5] & 0xFFF;
      if (v55 != (v70.st_mode & 0xFFF))
      {
        if (lchmod(a1, v55))
        {
          v56 = __error();
          if (!a4 || *v56 != 1)
          {
            v57 = __error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 819, 10, *v57, "%s", v58, v59, (char)a1);
            int v22 = 0;
          }
        }
      }
    }
    if (HIDWORD(v71[0]))
    {
      if (setattrlist(a1, v71, v72, v9, 1u))
      {
        uint64_t v60 = __error();
        if (!a4 || *v60 != 1)
        {
          uint64_t v61 = __error();
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 835, 10, "setattrlist error %d: %s", v62, v63, v64, *v61);
        }
      }
    }
    if ((*(unsigned char *)a2 & 8) != 0)
    {
      __uint32_t v65 = a2[4] & 0xFFFFFFDF | (32 * ((v70.st_flags >> 5) & 1));
      if (v70.st_flags != v65)
      {
        if (lchflags(a1, v65))
        {
          uint64_t v66 = __error();
          if (!a4 || *v66 != 1)
          {
            uint64_t v67 = __error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 849, 10, *v67, "%s", v68, v69, (char)a1);
            int v22 = 0;
          }
        }
      }
    }
    goto LABEL_69;
  }
  uint64_t v20 = open(a1, 0x200000);
  if ((v20 & 0x80000000) != 0)
  {
    int v27 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 770, 10, v27, "%s", v28, v29, (char)a1);
    return 0xFFFFFFFFLL;
  }
  uint64_t v21 = v20;
  if ((*a2 & 2) != 0 && v13 != v70.st_uid || (int v22 = 1, (*a2 & 4) != 0) && v14 != v70.st_gid)
  {
    if (!fchown(v20, v13, v14) || (char v23 = __error(), a4) && *v23 == 1)
    {
      int v22 = 1;
    }
    else
    {
      uint64_t v31 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 774, 10, *v31, "%s", v32, v33, (char)a1);
      int v22 = 0;
    }
  }
  if ((*(unsigned char *)a2 & 0x10) != 0)
  {
    int v34 = a2[5] & 0xFFF;
    if (v34 != (v70.st_mode & 0xFFF))
    {
      if (fchmod(v21, v34))
      {
        uint64_t v35 = __error();
        if (!a4 || *v35 != 1)
        {
          uint64_t v36 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 778, 10, *v36, "%s", v37, v38, (char)a1);
          int v22 = 0;
        }
      }
    }
  }
  if (HIDWORD(v71[0]))
  {
    if (fsetattrlist(v21, v71, v72, v9, 1u))
    {
      uint64_t v39 = __error();
      if (!a4 || *v39 != 1)
      {
        unint64_t v40 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 783, 10, *v40, "%s", v41, v42, (char)a1);
        int v22 = 0;
      }
    }
  }
  if (a3)
  {
    if ((*(_WORD *)a3 & 0x100) != 0)
    {
      uint64_t v43 = *(void *)(a3 + 80);
      if (FileAPFSInternalFlags != v43 && (setFileAPFSInternalFlagsFD(v21, v43) & 0x80000000) != 0)
      {
        unint64_t v44 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 794, 10, *v44, "%s", v45, v46, (char)a1);
        int v22 = 0;
      }
    }
  }
  if ((*(unsigned char *)a2 & 8) != 0)
  {
    __uint32_t v47 = a2[4] & 0xFFFFFFDF | (32 * ((v70.st_flags >> 5) & 1));
    if (v70.st_flags != v47)
    {
      if (fchflags(v21, v47))
      {
        size_t v48 = __error();
        if (!a4 || *v48 != 1)
        {
          uint64_t v49 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 803, 10, *v49, "%s", v50, v51, (char)a1);
          int v22 = 0;
        }
      }
    }
  }
  close(v21);
LABEL_69:
  if (v22) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t yaa_setEntryXAT(char *path, uint64_t a2, int a3, unint64_t a4, unsigned int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a2 + 1) & 4) == 0) {
    return 0;
  }
  unint64_t v9 = a4;
  if (*(void *)(a2 + 72) != a4)
  {
    int v24 = "XAT blob size mismatch";
    __int16 v25 = 863;
LABEL_32:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryXAT", v25, 10, 0, v24, a7, a8, v26);
    return 0xFFFFFFFFLL;
  }
  if (a4)
  {
    int v13 = 1;
    while (1)
    {
      unint64_t v14 = *a5;
      if (v9 < v14)
      {
        int v24 = "invalid XAT entry size";
        __int16 v25 = 871;
        goto LABEL_32;
      }
      if (v14 < 5) {
        break;
      }
      int v15 = a5;
      uint64_t v16 = 0;
      a5 = (unsigned int *)((char *)a5 + v14);
      uint64_t v17 = (const char *)(v15 + 1);
      while (v17[v16])
      {
        __int16 v18 = &v17[++v16];
        if (&v17[v16] >= (const char *)a5) {
          goto LABEL_13;
        }
      }
      __int16 v18 = &v17[v16];
LABEL_13:
      if (!v16 || v18 == (const char *)a5) {
        goto LABEL_31;
      }
      if (a5 == (unsigned int *)(v18 + 1)) {
        unsigned int v19 = 0;
      }
      else {
        unsigned int v19 = v18 + 1;
      }
      if (setxattr(path, v17, v19, (char *)a5 - (v18 + 1), 0, 1) < 0)
      {
        uint64_t v20 = __error();
        if (!a3 || *v20 != 1)
        {
          uint64_t v21 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryXAT", 891, 10, *v21, "setxattr: %s", v22, v23, (char)path);
          int v13 = 0;
        }
      }
      v9 -= v14;
      if (!v9) {
        goto LABEL_26;
      }
    }
    LOBYTE(v16) = 0;
LABEL_31:
    char v26 = v16;
    int v24 = "invalid XAT entry key %zu";
    __int16 v25 = 878;
    goto LABEL_32;
  }
  int v13 = 1;
LABEL_26:
  if (v13) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t yaa_setEntryACL(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  if ((*(unsigned char *)(a2 + 1) & 8) == 0) {
    return 0;
  }
  memset(&v35, 0, sizeof(v35));
  if (!lstat(a1, &v35) && (v35.st_mode & 0xF000) == 0xA000) {
    return 0;
  }
  if (!a4) {
    return 0;
  }
  int v8 = 0;
  unint64_t v9 = (_DWORD *)a5;
  uint64_t v10 = a4;
  do
  {
    if ((*v9 - 1) < 2) {
      ++v8;
    }
    v9 += 72;
    --v10;
  }
  while (v10);
  if (!v8) {
    return 0;
  }
  acl_t acl_p = 0;
  uint64_t v11 = sysconf(71);
  uint64_t v12 = sysconf(70);
  if (v11 <= v12) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = v11;
  }
  if (v13 <= 4096) {
    size_t v14 = 4096;
  }
  else {
    size_t v14 = v13;
  }
  int v15 = (char *)malloc(v14);
  if (!v15)
  {
    int v26 = *__error();
    int v27 = "malloc";
    __int16 v28 = 943;
    goto LABEL_50;
  }
  acl_t acl_p = acl_init(v8);
  if (!acl_p)
  {
    int v26 = *__error();
    int v27 = "acl_init";
    __int16 v28 = 946;
    goto LABEL_50;
  }
  __int16 v18 = (const char *)(a5 + 28);
  while (1)
  {
    acl_flagset_t flagset_p = 0;
    acl_entry_t entry_p = 0;
    memset(uu, 0, sizeof(uu));
    acl_tag_t v19 = *((_DWORD *)v18 - 7);
    if (v19 - 1 <= 1) {
      break;
    }
LABEL_42:
    v18 += 288;
    if (!--a4)
    {
      if (acl_set_file(a1, ACL_TYPE_EXTENDED, acl_p))
      {
        int v26 = *__error();
        LOBYTE(v29) = (_BYTE)a1;
        int v27 = "acl_set_file: %s";
        __int16 v28 = 1022;
        goto LABEL_50;
      }
      uint64_t v24 = 0;
      goto LABEL_51;
    }
  }
  if ((*(void *)(v18 - 12) & 0xFFFFFFFFFFFDFE0FLL) != 0)
  {
    uint64_t v29 = *(void *)(v18 - 12);
    int v27 = "invalid ACE flags: 0x%016llx";
    __int16 v28 = 973;
    goto LABEL_65;
  }
  if ((*(void *)(v18 - 20) & 0xFFFFFFFFFFEFC001) != 0)
  {
    uint64_t v29 = *(void *)(v18 - 20);
    int v27 = "invalid ACE perms: 0x%016llx";
    __int16 v28 = 974;
    goto LABEL_65;
  }
  switch(*((_DWORD *)v18 - 1))
  {
    case 1:
      memset(&v31, 0, sizeof(v31));
      uint64_t v30 = 0;
      int v20 = getpwnam_r(v18, &v31, v15, v14, &v30);
      BOOL v21 = 0;
      if (v20 || !v30) {
        goto LABEL_35;
      }
      int v22 = mbr_uid_to_uuid(v31.pw_uid, uu);
      goto LABEL_34;
    case 2:
      memset(&v31, 0, 32);
      uint64_t v30 = 0;
      int v23 = getgrnam_r(v18, (group *)&v31, v15, v14, (group **)&v30);
      BOOL v21 = 0;
      if (v23 || !v30) {
        goto LABEL_35;
      }
      int v22 = mbr_gid_to_uuid(v31.pw_uid, uu);
      goto LABEL_34;
    case 3:
      memset(&v31, 0, sizeof(v31));
      if (mbr_string_to_sid(v18, (nt_sid_t *)&v31))
      {
        BOOL v21 = 0;
      }
      else
      {
        int v22 = mbr_sid_to_uuid((const nt_sid_t *)&v31, uu);
LABEL_34:
        BOOL v21 = v22 == 0;
      }
LABEL_35:
      if (v21)
      {
LABEL_36:
        if (acl_create_entry(&acl_p, &entry_p))
        {
          int v26 = *__error();
          int v27 = "acl_create_entry";
          __int16 v28 = 1013;
          goto LABEL_50;
        }
        if (acl_set_tag_type(entry_p, v19))
        {
          int v26 = *__error();
          int v27 = "acl_set_tag_type";
          __int16 v28 = 1014;
          goto LABEL_50;
        }
        if (acl_set_permset_mask_np(entry_p, *(void *)(v18 - 20)))
        {
          int v26 = *__error();
          int v27 = "acl_set_permset_mask_np";
          __int16 v28 = 1015;
          goto LABEL_50;
        }
        if (acl_get_flagset_np(entry_p, &flagset_p))
        {
          int v26 = *__error();
          int v27 = "acl_get_flagset_np";
          __int16 v28 = 1016;
          goto LABEL_50;
        }
        if (acl_add_flag_np(flagset_p, *((acl_flag_t *)v18 - 3)))
        {
          int v26 = *__error();
          int v27 = "acl_add_flag_np";
          __int16 v28 = 1017;
          goto LABEL_50;
        }
        if (acl_set_qualifier(entry_p, uu))
        {
          int v26 = *__error();
          int v27 = "acl_set_qualifier";
          __int16 v28 = 1018;
          goto LABEL_50;
        }
        goto LABEL_42;
      }
LABEL_57:
      LODWORD(v29) = *((_DWORD *)v18 - 1);
      int v27 = "could not resolve qualifier (type %d): %s";
      __int16 v28 = 1010;
LABEL_65:
      int v26 = 0;
LABEL_50:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryACL", v28, 10, v26, v27, v16, v17, v29);
      uint64_t v24 = 0xFFFFFFFFLL;
LABEL_51:
      if (acl_p) {
        acl_free(acl_p);
      }
      free(v15);
      return v24;
    case 4:
      if (uuid_parse(v18, uu)) {
        goto LABEL_57;
      }
      goto LABEL_36;
    default:
      LODWORD(v29) = *((_DWORD *)v18 - 1);
      int v27 = "invalid qualifier type: %d";
      __int16 v28 = 1007;
      goto LABEL_65;
  }
}

uint64_t ParallelArchiveGetPayloadSize(int *a1, uint64_t a2, uint64_t a3, void *a4)
{
  int v4 = *a1;
  if ((*a1 & 0x800) != 0)
  {
    uint64_t v5 = *((void *)a1 + 10);
    if ((v4 & 0x200) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  uint64_t v5 = 0;
  if ((v4 & 0x200) != 0) {
LABEL_5:
  }
    v5 += *((void *)a1 + 8);
LABEL_6:
  if ((v4 & 0x400) != 0)
  {
    v5 += *((void *)a1 + 9);
    if (!a3) {
      goto LABEL_14;
    }
  }
  else if (!a3)
  {
    goto LABEL_14;
  }
  size_t v6 = (void *)(a2 + 8);
  do
  {
    if (*((_DWORD *)v6 - 1) == 2) {
      v5 += *v6;
    }
    v6 += 129;
    --a3;
  }
  while (a3);
LABEL_14:
  *a4 = v5;
  return 0;
}

char *fileSessionCreate(const char *a1)
{
  memset(&v12, 0, sizeof(v12));
  unsigned int v2 = (char *)calloc(1uLL, 0x800uLL);
  if (!v2)
  {
    int v5 = *__error();
    unint64_t v9 = "malloc";
    __int16 v8 = 140;
    goto LABEL_7;
  }
  if (!realpath_DARWIN_EXTSN(a1, v2))
  {
    int v5 = *__error();
    char v11 = (char)a1;
    unint64_t v9 = "%s";
    __int16 v8 = 143;
    goto LABEL_7;
  }
  if (lstat(v2, &v12))
  {
    int v5 = *__error();
    __int16 v8 = 146;
    unint64_t v9 = v2;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileSessionCreate", v8, 40, v5, v9, v6, v7, v11);
    goto LABEL_8;
  }
  if ((v12.st_mode & 0xF000) == 0x4000)
  {
    __strlcpy_chk();
    __strlcat_chk();
    return v2;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileSessionCreate", 147, 40, 0, "Not a directory: %s", v3, v4, (char)v2);
LABEL_8:
  free(v2);
  return 0;
}

uint64_t fileSessionDestroy(void *a1)
{
  return 0;
}

void *fileRequestOpenForWriting(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (char *)calloc(1uLL, 0x498uLL);
  int v5 = v4;
  if (!v4)
  {
    stat v12 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestOpenForWriting", 173, 40, *v12, "malloc", v13, v14, v16);
LABEL_6:
    free(v5);
    return 0;
  }
  *((_DWORD *)v4 + 2) = 1;
  *(void *)uint64_t v4 = a1;
  *((_DWORD *)v4 + 264) = -1;
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = a2;
  CC_SHA256_Init((CC_SHA256_CTX *)(v4 + 1064));
  uint64_t v6 = (const char *)(a1 + 1024);
  __strlcpy_chk();
  int v7 = mkstemp((char *)v5 + 32);
  *((_DWORD *)v5 + 264) = v7;
  if (v7 < 0)
  {
    __int16 v8 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestOpenForWriting", 184, 40, *v8, v6, v9, v10, v16);
    int v11 = *((_DWORD *)v5 + 264);
    if ((v11 & 0x80000000) == 0) {
      close(v11);
    }
    goto LABEL_6;
  }
  return v5;
}

size_t fileRequestWrite(uint64_t a1, const void *a2, size_t __nbyte, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 1060)) {
    return -1;
  }
  if (!*(_DWORD *)(a1 + 8))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestWrite", 200, 40, 0, "Invalid request type", a7, a8, v20);
    return -1;
  }
  if (*(void *)(a1 + 24) < __nbyte)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestWrite", 203, 40, 0, "Exceeding write limit %llu: nbyte=%llu", a7, a8, *(void *)(a1 + 24));
LABEL_15:
    *(_DWORD *)(a1 + 1060) = 1;
    return -1;
  }
  ssize_t v13 = write(*(_DWORD *)(a1 + 1056), a2, __nbyte);
  ssize_t v8 = v13;
  if (v13 < 0)
  {
    uint64_t v17 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestWrite", 207, 40, *v17, "write", v18, v19, v20);
    return v8;
  }
  if (v13 != __nbyte)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestWrite", 208, 40, 0, "truncated write: %zd/%zu", v14, v15, v13);
    goto LABEL_15;
  }
  CC_SHA256_Update((CC_SHA256_CTX *)(a1 + 1064), a2, __nbyte);
  uint64_t v16 = *(void *)(a1 + 24);
  if (v16 != -1) {
    *(void *)(a1 + 24) = v16 - __nbyte;
  }
  return __nbyte;
}

uint64_t fileRequestCloseAndGetKey(char *a1, _OWORD *a2, unint64_t a3, void *a4)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 0;
  }
  ssize_t v8 = *(const char **)a1;
  bzero(__s, 0x400uLL);
  *(_OWORD *)md = 0u;
  long long v50 = 0u;
  if (*((_DWORD *)a1 + 265)) {
    goto LABEL_41;
  }
  if (!*((_DWORD *)a1 + 2))
  {
    stat v12 = "Invalid request type";
    __int16 v13 = 229;
LABEL_40:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestCloseAndGetKey", v13, 40, 0, v12, v9, v10, v46);
    goto LABEL_41;
  }
  if (a3 <= 0x1F)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestCloseAndGetKey", 230, 40, 0, "Key capacity is too low, %d bytes needed", v9, v10, 32);
    goto LABEL_41;
  }
  if ((unint64_t)(*((void *)a1 + 3) + 1) >= 2)
  {
    uint64_t v46 = *((void *)a1 + 3);
    stat v12 = "Missing write limit %llu";
    __int16 v13 = 233;
    goto LABEL_40;
  }
  int v14 = *((_DWORD *)a1 + 264);
  if ((v14 & 0x80000000) == 0)
  {
    close(v14);
    *((_DWORD *)a1 + 264) = -1;
  }
  CC_SHA256_Final(md, (CC_SHA256_CTX *)(a1 + 1064));
  while (1)
  {
    pathFromKey(__s, v8, md);
    size_t v15 = strlen(__s);
    makePath(__s, v15);
    memset(&v48, 0, sizeof(v48));
    if (!stat(__s, &v48)) {
      goto LABEL_34;
    }
    int v16 = open(a1 + 32, 0);
    if (v16 < 0)
    {
      __int16 v28 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"renameIfNotExist", 90, 40, *v28, "%s", v29, v30, (_BYTE)a1 + 32);
    }
    else
    {
      LOBYTE(v47) = 0x80;
      int v17 = open(__s, 2561);
      if (v17 == -17) {
        goto LABEL_34;
      }
      int v18 = v17;
      if (v17 < 0)
      {
        passwd v31 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"renameIfNotExist", 94, 40, *v31, "%s", v32, v33, (char)__s);
        close(v16);
        int v16 = v18;
      }
      else
      {
        uint64_t v19 = malloc(0x10000uLL);
        if (v19)
        {
          while (1)
          {
            ssize_t v20 = read(v16, v19, 0x10000uLL);
            ssize_t v21 = v20;
            if (!v20) {
              goto LABEL_29;
            }
            if (v20 < 0) {
              break;
            }
            ssize_t v22 = write(v18, v19, v20);
            if (v22 < 0)
            {
              int v26 = *__error();
              __uint32_t v47 = __s;
              __int16 v25 = 110;
              goto LABEL_27;
            }
            if (v22 != v21)
            {
              __int16 v25 = 111;
              int v26 = 0;
              int v27 = "truncated write";
              goto LABEL_28;
            }
          }
          int v26 = *__error();
          LOBYTE(v47) = (_BYTE)a1 + 32;
          __int16 v25 = 107;
LABEL_27:
          int v27 = "%s";
          goto LABEL_28;
        }
        int v26 = *__error();
        __int16 v25 = 101;
        int v27 = "malloc";
LABEL_28:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"renameIfNotExist", v25, 40, v26, v27, v23, v24, (char)v47);
        LODWORD(v21) = 1;
LABEL_29:
        free(v19);
        close(v18);
        close(v16);
        int v34 = v21 ? __s : a1 + 32;
        unlink(v34);
        int v16 = (int)(v21 << 31) >> 31;
      }
    }
    if (v16 != -17) {
      break;
    }
LABEL_34:
    if ((int)areFilesEqual(a1 + 32, __s) > 0) {
      goto LABEL_47;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestCloseAndGetKey", 262, 40, "SHA256 hash collision: %s", v35, v36, v37, (char)__s);
    uint64_t v38 = 31;
    do
    {
      if (v38 == -1) {
        break;
      }
      __int16 v39 = ++md[v38--];
    }
    while ((v39 & 0x100) != 0);
  }
  if (!v16)
  {
LABEL_47:
    uint64_t v11 = 0;
    long long v42 = v50;
    *a2 = *(_OWORD *)md;
    a2[1] = v42;
    *a4 = 32;
    goto LABEL_42;
  }
  int v43 = *__error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestCloseAndGetKey", 252, 40, v43, "%s", v44, v45, (char)__s);
LABEL_41:
  uint64_t v11 = 0xFFFFFFFFLL;
LABEL_42:
  int v40 = *((_DWORD *)a1 + 264);
  if ((v40 & 0x80000000) == 0) {
    close(v40);
  }
  unlink(a1 + 32);
  free(a1);
  return v11;
}

char **fileRequestOpenForReading(const char *a1, unsigned __int8 *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  bzero(v22, 0x400uLL);
  if (a3 != 32)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestOpenForReading", 288, 40, 0, "invalid key size: %zu", v10, v11, a3);
    __int16 v13 = 0;
    goto LABEL_7;
  }
  pathFromKey(v22, a1, a2);
  stat v12 = (char **)calloc(1uLL, 0x498uLL);
  __int16 v13 = v12;
  if (!v12)
  {
    int v17 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestOpenForReading", 295, 40, *v17, "malloc", v18, v19, v21);
    goto LABEL_7;
  }
  *stat v12 = (char *)a1;
  uint64_t v14 = IFileStreamCreateWithFilename(v22, a4, a5);
  v13[146] = (char *)v14;
  if (!v14)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestOpenForReading", 300, 40, 0, "creating file stream: %s", v15, v16, (char)v22);
    IFileStreamDestroy(v13[146]);
LABEL_7:
    free(v13);
    return 0;
  }
  return v13;
}

unint64_t fileRequestRead(uint64_t a1, char *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 8))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestRead", 315, 40, 0, "Invalid request type", a7, a8, vars0);
    return -1;
  }
  else
  {
    uint64_t v9 = *(void *)(a1 + 1168);
    return IFileStreamRead(v9, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t fileRequestPRead(uint64_t a1, char *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 8))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestPRead", 322, 40, 0, "Invalid request type", a7, a8, v32);
    return -1;
  }
  else
  {
    uint64_t Pos = IFileStreamGetPos(*(void *)(a1 + 1168));
    IFileStreamSetPos(*(void *)(a1 + 1168), a4, v14, v15, v16, v17, v18, v19);
    unint64_t v25 = IFileStreamRead(*(void *)(a1 + 1168), a2, a3, v20, v21, v22, v23, v24);
    IFileStreamSetPos(*(void *)(a1 + 1168), Pos, v26, v27, v28, v29, v30, v31);
    return v25;
  }
}

uint64_t fileRequestClose(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    ssize_t v8 = (void *)result;
    if (*(_DWORD *)(result + 8))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestClose", 334, 40, 0, "Invalid request type", a7, a8, v9);
      return 0xFFFFFFFFLL;
    }
    else
    {
      IFileStreamDestroy(*(char **)(result + 1168));
      free(v8);
      return 0;
    }
  }
  return result;
}

uint64_t fileSessionClone(const char *a1, const char *a2, unsigned __int8 *a3, uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  bzero(v15, 0x400uLL);
  if (a4 == 32)
  {
    pathFromKey(v15, a1, a3);
    int v10 = clonefile(v15, a2, 0);
    uint64_t result = 0;
    if ((v10 & 0x80000000) == 0) {
      return result;
    }
    int v12 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileSessionClone", 354, 40, v12, "cloning %s to %s", v13, v14, (char)v15);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileSessionClone", 347, 40, 0, "invalid key size: %zu", v8, v9, a4);
  }
  return 0xFFFFFFFFLL;
}

uint64_t pathFromKey(char *a1, const char *a2, unsigned __int8 *a3)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  char v7 = 0;
  memset(v6, 0, sizeof(v6));
  serializeHexString((uint64_t)v6, 0x20u, a3);
  return snprintf(a1, 0x400uLL, "%s/%c%c%c/%s", a2, SLOBYTE(v6[0]), SBYTE1(v6[0]), SBYTE2(v6[0]), (const char *)v6);
}

_OWORD *ParallelArchiveWriterCreate(_OWORD *a1)
{
  unsigned int v2 = calloc(1uLL, 0x100040uLL);
  uint64_t v3 = v2;
  if (v2)
  {
    long long v4 = a1[1];
    *unsigned int v2 = *a1;
    v2[1] = v4;
    *((void *)v2 + 7) = 0x100000;
    *((_DWORD *)v2 + 8) = 0;
  }
  else
  {
    int v5 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Write.c", (uint64_t)"ParallelArchiveWriterCreate", 15, 22, *v5, "malloc", v6, v7, v9);
  }
  return v3;
}

_OWORD *ParallelArchiveWriterCreateLegacy(_OWORD *a1)
{
  uint64_t result = ParallelArchiveWriterCreate(a1);
  if (result) {
    *((_DWORD *)result + 8) = 1;
  }
  return result;
}

uint64_t ParallelArchiveWriterDestroy(void *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = a1[5];
  free(a1);
  return v1;
}

uint64_t yaa_writeRawEntryHeader(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 48))
  {
    uint64_t v15 = *(void *)(a1 + 48);
    uint64_t v8 = "truncated entry payload: %llu B missing";
    __int16 v9 = 46;
LABEL_3:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Write.c", (uint64_t)"yaa_writeRawEntryHeader", v9, 22, 0, v8, a7, a8, v15);
    return 0xFFFFFFFFLL;
  }
  uint64_t v13 = (*(uint64_t (**)(void))(a1 + 8))(*(void *)(a1 + 24));
  if (v13 < 0)
  {
    uint64_t v8 = "writing header";
    __int16 v9 = 50;
    goto LABEL_3;
  }
  uint64_t v14 = v13;
  uint64_t result = 0;
  *(void *)(a1 + 40) += v14;
  *(void *)(a1 + 48) = a4;
  return result;
}

uint64_t ParallelArchiveWriteEntryHeader(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a4;
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v28);
  if (*(void *)(a1 + 48))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Write.c", (uint64_t)"ParallelArchiveWriteEntryHeader", 68, 22, 0, "truncated entry payload: %llu B missing", v13, v14, *(void *)(a1 + 48));
LABEL_20:
    unsigned int v25 = -1;
    goto LABEL_21;
  }
  if (v8)
  {
    uint64_t v15 = (unsigned char *)a3;
    unint64_t v16 = v8;
    while (*v15 && v15[1] && v15[2] && !v15[3])
    {
      v15 += 1032;
      if (!--v16) {
        goto LABEL_10;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Write.c", (uint64_t)"ParallelArchiveWriteEntryHeader", 76, 22, 0, "invalid extra field key: %s", v13, v14, (char)v15);
    goto LABEL_20;
  }
LABEL_10:
  uint64_t v17 = yaa_encodeHeader(a1 + 64, *(void *)(a1 + 56), (int *)a2, a3, v8, v12, v13, v14);
  if (v17 < 0)
  {
    uint64_t v23 = "generating entry header";
    __int16 v24 = 81;
LABEL_19:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Write.c", (uint64_t)"ParallelArchiveWriteEntryHeader", v24, 22, 0, v23, v18, v19, v29);
    goto LABEL_20;
  }
  if (*(_DWORD *)(a1 + 32)) {
    *(_DWORD *)(a1 + 64) = 826360153;
  }
  uint64_t v20 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a1 + 8))(*(void *)(a1 + 24), a1 + 64, v17);
  if (v20 < 0)
  {
    uint64_t v23 = "writing header";
    __int16 v24 = 88;
    goto LABEL_19;
  }
  *(void *)(a1 + 40) += v20;
  int v21 = *(_DWORD *)a2;
  if ((*(_DWORD *)a2 & 0x200) != 0) {
    uint64_t v22 = *(void *)(a2 + 64);
  }
  else {
    uint64_t v22 = 0;
  }
  if ((v21 & 0x400) != 0)
  {
    v22 += *(void *)(a2 + 72);
    if ((v21 & 0x800) == 0)
    {
LABEL_27:
      if (!v8) {
        goto LABEL_35;
      }
LABEL_31:
      uint64_t v27 = (void *)(a3 + 8);
      do
      {
        if (*((_DWORD *)v27 - 1) == 2) {
          v22 += *v27;
        }
        v27 += 129;
        --v8;
      }
      while (v8);
      goto LABEL_35;
    }
  }
  else if ((v21 & 0x800) == 0)
  {
    goto LABEL_27;
  }
  v22 += *(void *)(a2 + 80);
  if (v8) {
    goto LABEL_31;
  }
LABEL_35:
  unsigned int v25 = 0;
  *(void *)(a1 + 48) = v22;
LABEL_21:
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0) {
    return v25;
  }
  else {
    return result;
  }
}

uint64_t ParallelArchiveWriteEntryData(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    return 0;
  }
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v19);
  if (*(void *)(a1 + 48) >= a3)
  {
    uint64_t v14 = (*(uint64_t (**)(void, uint64_t, unint64_t))(a1 + 8))(*(void *)(a1 + 24), a2, a3);
    if ((v14 & 0x8000000000000000) == 0 && v14 == a3)
    {
      unsigned int v17 = 0;
      unint64_t v18 = *(void *)(a1 + 48) - a3;
      *(void *)(a1 + 40) += a3;
      *(void *)(a1 + 48) = v18;
      goto LABEL_10;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Write.c", (uint64_t)"ParallelArchiveWriteEntryData", 133, 22, 0, "writing data", v15, v16, v20);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Write.c", (uint64_t)"ParallelArchiveWriteEntryData", 129, 22, 0, "Payload too large: %zu B received / %llu B expected", v11, v12, a3);
  }
  unsigned int v17 = -1;
LABEL_10:
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0) {
    return v17;
  }
  else {
    return result;
  }
}

uint64_t BlobBufferStore(uint64_t a1, const void *a2, size_t a3, void *a4)
{
  if (!a3) {
    return 0xFFFFFFFFLL;
  }
  size_t v8 = *(void *)(a1 + 8) + a3;
  if ((BlobBufferIncreaseCapacity(a1, v8) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/BlobBuffer.c", (uint64_t)"BlobBufferStore", 19, 6, 0, "BlobBufferStore", v9, v10, v12);
    return 0xFFFFFFFFLL;
  }
  else
  {
    if (a2) {
      memcpy((void *)(*(void *)(a1 + 16) + *(void *)(a1 + 8)), a2, a3);
    }
    if (a4)
    {
      *a4 = *(void *)(a1 + 8);
      a4[1] = a3;
    }
    uint64_t result = 0;
    *(void *)(a1 + 8) = v8;
  }
  return result;
}

uint64_t BlobBufferIncreaseCapacity(uint64_t a1, size_t a2)
{
  size_t v2 = *(void *)a1;
  if (*(void *)a1 >= a2) {
    return 0;
  }
  do
  {
    uint64_t v4 = v2 + (v2 >> 1);
    if (__CFADD__(v2, v2 >> 1)) {
      uint64_t v4 = -1;
    }
    if (v2) {
      size_t v2 = v4;
    }
    else {
      size_t v2 = 0x10000;
    }
  }
  while (v2 < a2);
  int v5 = reallocf(*(void **)(a1 + 16), v2);
  *(void *)(a1 + 16) = v5;
  if (v5)
  {
    uint64_t result = 0;
    *(void *)a1 = v2;
  }
  else
  {
    uint64_t v7 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/BlobBuffer.c", (uint64_t)"BlobBufferIncreaseCapacity", 58, 6, *v7, "malloc", v8, v9, v10);
    return 0xFFFFFFFFLL;
  }
  return result;
}

void BlobBufferFree(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
}

size_t PCompressLZ4Encode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_encode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZ4);
  if (!result) {
    return -1;
  }
  return result;
}

size_t PCompressLZ4Decode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_decode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZ4);
  if (!result) {
    return -1;
  }
  return result;
}

uint64_t BXDiffWithCache(unint64_t a1, const char **a2, uint64_t a3, const char *a4, _DWORD *a5, int a6, uint64_t a7, void *a8, void *a9, atomic_ullong *a10)
{
  unint64_t v15 = a1;
  v157[98] = *MEMORY[0x263EF8340];
  int v138 = *(_DWORD *)(a7 + 4);
  uint64_t v16 = a1 - 1;
  memset(&v141, 0, sizeof(v141));
  bzero(v154, 0x360uLL);
  memset(v153, 0, sizeof(v153));
  long long v152 = 0u;
  memset(v151, 0, sizeof(v151));
  long long v149 = 0u;
  *(_OWORD *)v150 = 0u;
  long long v147 = 0u;
  *(_OWORD *)size_t v148 = 0u;
  long long v145 = 0u;
  long long v146 = 0u;
  long long v144 = 0u;
  *a8 = 0;
  *a9 = 0;
  if (!v15)
  {
    size_t v130 = a2;
    int v131 = a6;
    v132 = a5;
    v133 = a8;
    v135 = a4;
    BOOL v129 = 0;
LABEL_12:
    size_t v22 = 0;
    unint64_t v25 = 0;
    uint64_t v23 = -1;
    do
    {
      if (v15)
      {
        BOOL v26 = 0;
        unint64_t v27 = 0;
        uint64_t v28 = a3;
        while (v27 >= v25 && v16 != v27 || sha1cmp(a3 + 20 * v25, v28))
        {
          BOOL v26 = ++v27 >= v15;
          v28 += 20;
          if (v15 == v27)
          {
            int v29 = 1;
            uint64_t v23 = v25;
            goto LABEL_22;
          }
        }
        int v29 = 0;
      }
      else
      {
        BOOL v26 = 1;
        uint64_t v23 = v25;
        int v29 = 1;
      }
LABEL_22:
      *(_DWORD *)&v154[96 * v25] = v29;
      v22 += v26;
      ++v25;
    }
    while (v25 != v16);
    char v30 = 0;
    a8 = v133;
    a4 = v135;
    goto LABEL_24;
  }
  unint64_t st_size = 0;
  unint64_t v18 = v15;
  char v19 = a2;
  do
  {
    if (lstat(*v19, &v141) || (v141.st_mode & 0xF000) != 0x8000)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 59, 91, 0, "Invalid file: %s", v20, v21, (char)*v19);
      size_t v22 = 0;
      uint64_t v23 = -1;
      char v24 = 1;
      goto LABEL_71;
    }
    if (v141.st_size > st_size) {
      unint64_t st_size = v141.st_size;
    }
    ++v19;
    --v18;
  }
  while (v18);
  BOOL v129 = st_size > 0xA00000;
  v132 = a5;
  int v131 = a6;
  size_t v130 = a2;
  if (v16)
  {
    v133 = a8;
    v135 = a4;
    goto LABEL_12;
  }
  size_t v22 = 0;
  uint64_t v23 = -1;
  char v30 = 1;
LABEL_24:
  if (bxdiff5Alloc(v22, (uint64_t *)a7, (uint64_t)&v144))
  {
    uint64_t v33 = "bxdiff5Alloc";
    __int16 v34 = 79;
LABEL_26:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", v34, 91, 0, v33, v31, v32, v127);
    char v24 = 1;
    goto LABEL_68;
  }
  v142[0] = 0;
  v142[1] = 0;
  int v143 = 0;
  char v134 = v30;
  if ((v30 & 1) == 0)
  {
    uint64_t v35 = v155;
    uint64_t v36 = (unsigned __int8 *)a3;
    uint64_t v37 = v16;
    do
    {
      if (*((_DWORD *)v35 - 1))
      {
        patchCacheKeyFromSHA1(v36, (uint64_t)v35);
        sha1xor((uint64_t)v142, (uint64_t)v36);
      }
      v35 += 96;
      v36 += 20;
      --v37;
    }
    while (v37);
  }
  patchCacheKeyFromSHA1((unsigned __int8 *)v142, (uint64_t)v151 + 4);
  patchCacheKeyFromSHA1((unsigned __int8 *)(a3 + 20 * v16), (unint64_t)&v154[96 * v16] | 4);
  if (v138 > 1) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%zu/%zu unique inputs: %s\n", v22, v16, a4);
  }
  if (v132)
  {
    uint64_t v43 = 3;
    if (v22 == 1) {
      uint64_t v43 = 0;
    }
    atomic_fetch_add(&a10[v43], 1uLL);
    unint64_t v44 = (unint64_t)&v154[96 * v23];
    if (v22 == 1) {
      uint64_t v45 = (char *)(v44 | 4);
    }
    else {
      uint64_t v45 = (char *)v151 + 4;
    }
    uint64_t v46 = (long long *)(v44 + 48);
    if (v22 == 1) {
      __uint32_t v47 = v46;
    }
    else {
      __uint32_t v47 = &v152;
    }
    int v48 = patchCacheLookup(v132, (uint64_t)v45, (unint64_t)&v154[96 * v16] | 4, (uint64_t)v47, v131, 0x11E1A300uLL, v41, v42);
    if (v48 < 0)
    {
      atomic_fetch_add(a10 + 8, 1uLL);
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 118, 91, "cache lookup failed (ignored): %s", v40, v41, v42, (char)a4);
    }
    else if (v48)
    {
      if (v22 == 1)
      {
        atomic_fetch_add(a10 + 1, 1uLL);
        if (v138 >= 2) {
          fprintf((FILE *)*MEMORY[0x263EF8348], "Loaded 1:1 patch from cache: %s\n", a4);
        }
        char v24 = 0;
        goto LABEL_69;
      }
      atomic_fetch_add(a10 + 4, 1uLL);
      if (v138 >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Loaded combo patch from cache: %s\n");
      }
      goto LABEL_63;
    }
    if (v138 >= 2) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "No patch in cache: %s\n", a4);
    }
  }
  uint64_t v137 = v23;
  uint64_t v49 = &v154[96 * v16];
  uint64_t v51 = *((void *)v49 + 10);
  long long v50 = (char **)(v49 + 80);
  if (!v51)
  {
    v57 = v130[v16];
    if ((loadFileContents(v57, v50, &v157[12 * v16 + 1], 0) & 0x80000000) != 0)
    {
      char v127 = (char)v57;
      int v55 = "loadFileContents: %s";
      __int16 v56 = 150;
      goto LABEL_65;
    }
    if (v138 >= 2) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "Loaded output file: %s\n", v57);
    }
  }
  unint64_t v128 = (unint64_t)&v154[96 * v16] | 4;
  uint64_t v52 = &v154[96 * v16];
  unint64_t v54 = *((void *)v52 + 11);
  uint64_t v53 = (unint64_t *)(v52 + 88);
  if (bxdiff5SetOut((uint64_t)&v144, (uint64_t)*v50, v54, v38, v39, v40, v41, v42))
  {
    int v55 = "bxdiff5SetOut";
    __int16 v56 = 154;
LABEL_65:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", v56, 91, 0, v55, v41, v42, v127);
    goto LABEL_66;
  }
  if (sha1cmp((uint64_t)&v147, a3 + 20 * v16))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 156, 91, 0, "SHA1 inconsistency (patching): %s", v58, v59, (char)v130[v16]);
LABEL_66:
    char v24 = 1;
    goto LABEL_67;
  }
  uint64_t CompressedSize = ParallelCompressionGetCompressedSize((uint64_t)*v50, *v53, 1);
  if (v134)
  {
    unint64_t v94 = 0;
  }
  else
  {
    unint64_t v94 = 0;
    uint64_t v95 = 0;
    v96 = v157;
    do
    {
      if (*((_DWORD *)v96 - 20))
      {
        if (!*v96)
        {
          v97 = v130[v95];
          if ((loadFileContents(v97, (char **)v96, v96 + 1, 0) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 169, 91, 0, "loadFileContents: %s", v91, v92, (char)v97);
            goto LABEL_183;
          }
          if (v138 >= 2) {
            fprintf((FILE *)*MEMORY[0x263EF8348], "Loaded input file %zu: %s\n", v95, v97);
          }
        }
        if (bxdiff5SetIn(&v144, v94, *v96, v96[1], v89, v90, v91, v92))
        {
          int v99 = "bxdiff5SetIn";
          __int16 v100 = 173;
          goto LABEL_182;
        }
        if (sha1cmp(*((void *)&v145 + 1) + 80 * v94 + 16, a3))
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 175, 91, 0, "SHA1 inconsistency (patching): %s", v91, v92, (char)v130[v95]);
          goto LABEL_183;
        }
        ++v94;
      }
      v96 += 12;
      ++v95;
      a3 += 20;
    }
    while (v16 != v95);
  }
  if (v94 != v22)
  {
    int v99 = "inconsistent N";
    __int16 v100 = 178;
    goto LABEL_182;
  }
  uint64_t v23 = v137;
  if (v138 >= 2) {
    bxdiff5Dump((uint64_t)&v144, (FILE *)*MEMORY[0x263EF8348]);
  }
  if (v22 < 2)
  {
    if (bxdiff5CreateInControls((uint64_t)&v144, 0, v129, 0, v89, v90, v91, v92))
    {
      uint64_t v33 = "bxdiff5CreateInControls";
      __int16 v34 = 294;
      goto LABEL_26;
    }
    if (bxdiff5CreateInPatch((uint64_t)&v144, 0))
    {
      uint64_t v33 = "bxdiff5CreateInPatch";
      __int16 v34 = 295;
      goto LABEL_26;
    }
    uint64_t v120 = *((void *)&v145 + 1);
    uint64_t v121 = CompressedSize;
    uint64_t v122 = &v154[96 * v137];
    v122[9] = *(void *)(*((void *)&v145 + 1) + 64);
    v122[7] = *(void *)(v120 + 72);
    v122[8] = v121;
    *(void *)(v120 + 64) = 0;
    *(void *)(v120 + 72) = 0;
    atomic_fetch_add(a10 + 6, 1uLL);
    if (v138 >= 2) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "Created 1:1 patch: %s\n", a4);
    }
    if (*(_DWORD *)&v155[96 * v137 + 48])
    {
      atomic_fetch_add(a10 + 2, 1uLL);
      if (v132
        && patchCacheUpdate(v132, (unint64_t)&v154[96 * v137] | 4, v128, (uint64_t)(v122 + 6), v116, v117, v31, v32))
      {
        atomic_fetch_add(a10 + 9, 1uLL);
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 311, 91, 0, "cache update failed (ignored): %s", v123, v124, (char)a4);
      }
      if (v138 >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Updated 1:1 patch to cache: %s\n");
      }
    }
LABEL_63:
    char v24 = 0;
    goto LABEL_68;
  }
  uint64_t v140 = CompressedSize;
  if (v134)
  {
    unint64_t v98 = 0;
LABEL_152:
    if (v98 != v22)
    {
      int v99 = "inconsistent N";
      __int16 v100 = 262;
      goto LABEL_182;
    }
    uint64_t v23 = v137;
    if (bxdiff5CreateComboControls((uint64_t)&v144, v86, v87, v88, v89, v90, v91, v92))
    {
      uint64_t v33 = "bxdiff5CreateComboControls";
      __int16 v34 = 265;
      goto LABEL_26;
    }
    if (bxdiff5CreateComboPatch((uint64_t)&v144, v111, v112, v113, v114, v115, v31, v32))
    {
      uint64_t v33 = "bxdiff5CreateComboPatch";
      __int16 v34 = 266;
      goto LABEL_26;
    }
    atomic_fetch_add(a10 + 7, 1uLL);
    if (v138 >= 2) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "Created combo patch: %s\n", a4);
    }
    *((void **)&v152 + 1) = v150[1];
    *(void *)&v153[0] = v140;
    *((void **)&v153[0] + 1) = v150[0];
    v150[0] = 0;
    v150[1] = 0;
    if (DWORD1(v152))
    {
      atomic_fetch_add(a10 + 5, 1uLL);
      if (v132 && patchCacheUpdate(v132, (uint64_t)v151 + 4, v128, (uint64_t)&v152, v118, v119, v31, v32))
      {
        atomic_fetch_add(a10 + 9, 1uLL);
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 284, 91, 0, "cache update failed (ignored): %s", v125, v126, (char)a4);
      }
      if (v138 >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Updated combo patch to cache: %s\n", a4);
      }
      char v24 = 0;
      goto LABEL_67;
    }
    goto LABEL_63;
  }
  unint64_t v98 = 0;
  uint64_t v101 = 0;
  v102 = &v156;
  double v103 = (FILE **)MEMORY[0x263EF8348];
  while (1)
  {
    if (!*((_DWORD *)v102 - 18)) {
      goto LABEL_151;
    }
    atomic_fetch_add(a10, 1uLL);
    if (!v132) {
      goto LABEL_135;
    }
    int v104 = patchCacheLookup(v132, (uint64_t)v102 - 68, v128, (uint64_t)(v102 - 3), v131, 0x11E1A300uLL, v91, v92);
    if (v104 < 0)
    {
      atomic_fetch_add(a10 + 8, 1uLL);
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 199, 91, 0, "cache lookup failed (ignored): %s", v91, v92, (char)a4);
LABEL_135:
      if (v138 >= 2) {
        fprintf(*v103, "No 1:1 patch %zu in cache: %s\n", v101, a4);
      }
      goto LABEL_137;
    }
    if (!v104) {
      goto LABEL_135;
    }
    atomic_fetch_add(a10 + 1, 1uLL);
    if (v138 >= 2) {
      fprintf(*v103, "Loaded 1:1 patch %zu from cache: %s\n", v101, a4);
    }
    uint64_t v87 = *v102;
    if (*v102) {
      break;
    }
LABEL_137:
    if (!*(void *)(*((void *)&v145 + 1) + 80 * v98 + 40))
    {
      if (bxdiff5CreateInControls((uint64_t)&v144, v98, v129, 0, v89, v90, v91, v92))
      {
        int v99 = "bxdiff5CreateInControls";
        __int16 v100 = 232;
        goto LABEL_182;
      }
      if (v138 >= 2) {
        fprintf(*v103, "Created 1:1 controls %zu: %s\n", v101, a4);
      }
    }
    if (*((_DWORD *)v102 - 5))
    {
      if (bxdiff5CreateInPatch((uint64_t)&v144, v98))
      {
        int v99 = "bxdiff5CreateInPatch";
        __int16 v100 = 239;
        goto LABEL_182;
      }
      atomic_fetch_add(a10 + 6, 1uLL);
      if (v138 >= 2) {
        fprintf(*v103, "Created 1:1 patch %zu: %s\n", v101, a4);
      }
      uint64_t v110 = *((void *)&v145 + 1) + 80 * v98;
      uint64_t *v102 = *(void *)(v110 + 64);
      *(v102 - 2) = *(void *)(v110 + 72);
      *(v102 - 1) = v140;
      *(void *)(v110 + 64) = 0;
      *(void *)(v110 + 72) = 0;
      atomic_fetch_add(a10 + 2, 1uLL);
      if (v132
        && patchCacheUpdate(v132, (uint64_t)v102 - 68, v128, (uint64_t)(v102 - 3), v89, v90, v91, v92))
      {
        atomic_fetch_add(a10 + 9, 1uLL);
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 254, 91, 0, "cache update failed (ignored): %s", v91, v92, (char)a4);
      }
      if (v138 >= 2) {
        fprintf(*v103, "Updated 1:1 patch %zu to cache: %s\n", v101, a4);
      }
    }
    ++v98;
LABEL_151:
    ++v101;
    v102 += 12;
    if (v16 == v101) {
      goto LABEL_152;
    }
  }
  if (bxdiff5SetInPatch((uint64_t)&v144, v98, v87, *(v102 - 2), v89, v90, v91, v92))
  {
    int v99 = "bxdiff5SetInPatch";
    __int16 v100 = 213;
    goto LABEL_182;
  }
  if (!bxdiff5ReadInControlsFromInPatch((uint64_t)&v144, v98, v105, v106, v107, v108, v91, v92))
  {
    if (v138 >= 2) {
      fprintf(*v103, "Loaded 1:1 controls from patch %zu: %s\n", v101, a4);
    }
    uint64_t v109 = *((void *)&v145 + 1) + 80 * v98;
    *(void *)(v109 + 64) = 0;
    *(void *)(v109 + 72) = 0;
    goto LABEL_137;
  }
  int v99 = "bxdiff5ReadInControlsFromInPatch";
  __int16 v100 = 216;
LABEL_182:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", v100, 91, 0, v99, v91, v92, v127);
LABEL_183:
  char v24 = 1;
LABEL_67:
  uint64_t v23 = v137;
LABEL_68:
  if (v22)
  {
LABEL_69:
    uint64_t v60 = 0;
    uint64_t v61 = *((void *)&v145 + 1);
    size_t v62 = v22;
    do
    {
      uint64_t v63 = v61 + v60;
      *(void *)uint64_t v63 = 0;
      free(*(void **)(v63 + 40));
      uint64_t v64 = *((void *)&v145 + 1) + v60;
      *(void *)(v64 + 40) = 0;
      free(*(void **)(v64 + 64));
      uint64_t v61 = *((void *)&v145 + 1);
      *(void *)(*((void *)&v145 + 1) + v60 + 64) = 0;
      v60 += 80;
      --v62;
    }
    while (v62);
  }
LABEL_71:
  *(void *)&long long v146 = 0;
  free(v148[1]);
  v148[1] = 0;
  free(v150[0]);
  v150[0] = 0;
  if (bxdiff5Free((uint64_t)&v144, v65, v66, v67, v68, v69, v70, v71))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 330, 91, 0, "bxdiff5Free", v72, v73, v127);
    goto LABEL_74;
  }
  if (v24)
  {
LABEL_74:
    unlink(a4);
    unsigned int v74 = 0;
    int v75 = 0;
    if (v15) {
      goto LABEL_75;
    }
  }
  else
  {
    int v78 = &v157[12 * v23 - 1];
    if (v22 != 1) {
      int v78 = (uint64_t *)v153 + 1;
    }
    uint64_t v79 = *v78;
    if (*v78)
    {
      uint64_t v80 = (unint64_t *)&v155[96 * v23 + 52];
      if (v22 != 1) {
        uint64_t v80 = (unint64_t *)&v152 + 1;
      }
      if (storeFileContents(a4, v79, *v80))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 340, 91, 0, "writing patch to disk", v81, v82, v127);
        int v75 = 0;
      }
      else
      {
        int v75 = 1;
      }
      if (v138 >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Stored patch: %s\n", a4);
      }
      unsigned int v74 = 1;
    }
    else
    {
      unsigned int v74 = 0;
      int v75 = 1;
    }
    __int16 v83 = &v154[96 * v23];
    int v84 = v83 + 56;
    if (v22 != 1) {
      int v84 = (void *)&v152 + 1;
    }
    *a8 = *v84;
    size_t v85 = v83 + 64;
    if (v22 != 1) {
      size_t v85 = v153;
    }
    *a9 = *v85;
    if (v15)
    {
LABEL_75:
      v76 = (void **)v157;
      do
      {
        free(*v76);
        free(*(v76 - 1));
        v76 += 12;
        --v15;
      }
      while (v15);
    }
  }
  if (v75) {
    return v74;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

size_t pc_log_error(uint64_t a1, uint64_t a2, __int16 a3, int a4, int a5, const char *a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  bzero(__str, 0x400uLL);
  uint64_t v13 = (_WORD *)(((a3 & 0x3FFF) << 10) | (a4 << 24) | a5 & 0x3FF | 0x80000000);
  if (a5 >= 1)
  {
    uint64_t v14 = strerror(a5);
    snprintf(__str, 0x400uLL, "%s: ", v14);
  }
  size_t v15 = strlen(__str);
  vsnprintf(&__str[v15], 1024 - v15, a6, &a9);
  if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
    pc_log_error_cold_1((uint64_t)__str, (int)v13);
  }
  return ParallelCompressionUpdateError(v13, (size_t)__str);
}

uint64_t pc_log_warning(uint64_t a1, uint64_t a2, __int16 a3, int a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  bzero(__s, 0x400uLL);
  uint64_t v12 = ((a3 & 0x3FFF) << 10) | (a4 << 24) | 0x80000000;
  size_t v13 = strlen(__s);
  vsnprintf(&__s[v13], 1024 - v13, a5, &a9);
  if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109378;
    int v16 = v12;
    __int16 v17 = 2080;
    uint64_t v18 = __s;
    _os_log_impl(&dword_21066E000, MEMORY[0x263EF8438], OS_LOG_TYPE_INFO, "[0x%08x](warning) %s", buf, 0x12u);
  }
  return ParallelCompressionUpdateWarning(v12, __s);
}

void pc_log_info(uint64_t a1, uint64_t a2, __int16 a3, int a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  bzero(__s, 0x400uLL);
  size_t v12 = strlen(__s);
  vsnprintf(&__s[v12], 1024 - v12, a5, &a9);
  if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109378;
    unsigned int v14 = ((a3 & 0x3FFF) << 10) | (a4 << 24) | 0x80000000;
    __int16 v15 = 2080;
    int v16 = __s;
    _os_log_impl(&dword_21066E000, MEMORY[0x263EF8438], OS_LOG_TYPE_INFO, "[0x%08x] %s", buf, 0x12u);
  }
}

uint64_t pc_info(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  time_t v13 = 0;
  *(_OWORD *)__s = 0u;
  long long v15 = 0u;
  time(&v13);
  ctime_r(&v13, __s);
  size_t v10 = strlen(__s);
  if (v10) {
    __s[v10 - 1] = 0;
  }
  uint64_t v11 = (FILE **)MEMORY[0x263EF8348];
  fprintf((FILE *)*MEMORY[0x263EF8348], "[%s] ", __s);
  return vfprintf(*v11, a1, &a9);
}

unsigned char *filePatchCacheOpen(const char *a1, int a2)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  if (strncmp(a1, "file:", 5uLL))
  {
    LOBYTE(v29) = (_BYTE)a1;
    uint64_t v6 = "invalid cache url: %s";
    __int16 v7 = 178;
LABEL_3:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"filePatchCacheOpen", v7, 9, 0, v6, v4, v5, (char)v29);
    return 0;
  }
  bzero(__s, 0x400uLL);
  size_t v10 = a1 + 5;
  if (!realpath_DARWIN_EXTSN(v10, __s))
  {
    LOBYTE(v29) = (_BYTE)v10;
    uint64_t v6 = "invalid cache directory: %s";
    __int16 v7 = 182;
    goto LABEL_3;
  }
  size_t v11 = strlen(__s);
  if (v11 - 927 <= 0xFFFFFFFFFFFFFBFELL)
  {
    int v29 = __s;
    uint64_t v6 = "File patch cache dir name is too long: %s";
    __int16 v7 = 186;
    goto LABEL_3;
  }
  size_t v12 = v11;
  memset(&v30, 0, sizeof(v30));
  if (stat(__s, &v30))
  {
    int v13 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"filePatchCacheOpen", 188, 9, v13, "%s", v14, v15, (char)__s);
    return 0;
  }
  if ((v30.st_mode & 0xF000) != 0x4000)
  {
    int v29 = __s;
    uint64_t v6 = "File patch cache path is not a directory: %s";
    __int16 v7 = 189;
    goto LABEL_3;
  }
  uint64_t v16 = malloc(0x418uLL);
  uint64_t v8 = v16;
  if (v16)
  {
    bzero(v16, 0x418uLL);
    __memcpy_chk();
    do
    {
      size_t v24 = v12;
      if (!v12) {
        break;
      }
      --v12;
    }
    while (v8[v24 + 3] == 47);
    v8[v24 + 4] = 0;
    *((void *)v8 + 129) = v24;
    *((_DWORD *)v8 + 260) = a2;
    if (a2 >= 1) {
      pc_info("Opening file patch cache in directory: %s\n", v17, v18, v19, v20, v21, v22, v23, (_BYTE)v8 + 4);
    }
  }
  else
  {
    unint64_t v25 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"filePatchCacheOpen", 193, 9, *v25, "malloc", v26, v27, v28);
  }
  return v8;
}

uint64_t filePatchCacheClose(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && a1[260] >= 1) {
    pc_info("Closing file patch cache in directory: %s\n", a2, a3, a4, a5, a6, a7, a8, (_BYTE)a1 + 4);
  }
  free(a1);
  return 0;
}

uint64_t filePatchCacheLookup(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unint64_t *a5, int a6, unint64_t a7)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  *a4 = 0;
  *a5 = 0;
  bzero(&__to, 0x400uLL);
  uint64_t v14 = *(void *)(a1 + 1032);
  __memcpy_chk();
  uint64_t v15 = (char *)&__to + v14;
  *(_OWORD *)(v15 + 5) = *(_OWORD *)a3;
  *(_OWORD *)(v15 + 21) = *(_OWORD *)(a3 + 16);
  long long v16 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v15 + 46) = *(_OWORD *)a2;
  *uint64_t v15 = 47;
  *(_WORD *)(v15 + 1) = *(_WORD *)a3;
  v15[3] = *(unsigned char *)(a3 + 2);
  v15[4] = 47;
  *(void *)(v15 + 37) = *(void *)(a3 + 32);
  v15[45] = 47;
  *(_OWORD *)(v15 + 62) = v16;
  unint64_t v17 = v14 + 86;
  *(void *)(v15 + 78) = *(void *)(a2 + 32);
  __to.__pn_.__r_.__value_.__s.__data_[v17] = 0;
  int FileContents = loadFileContentsEx((const char *)&__to, a4, a5);
  if (FileContents < 0) {
    return 0xFFFFFFFFLL;
  }
  if (!a6)
  {
    uint64_t v31 = (void *)*a4;
    if (*a4 && *v31 == 0x5F44414F4C594150) {
      return 1;
    }
    free(v31);
    uint64_t v32 = 0;
    *a4 = 0;
    *a5 = 0;
    return v32;
  }
  if (!FileContents) {
    makePath((const char *)&__to, v17);
  }
  unint64_t v19 = 0;
  unint64_t v20 = 10000000;
  while (1)
  {
    uint64_t v21 = (void *)*a4;
    if (!*a4) {
      break;
    }
    if (*v21 == 0x5F44414F4C594150) {
      return 1;
    }
    if (*v21 != 0x5F474E49444E4550) {
      break;
    }
    time_t v22 = time(0);
    uint64_t v23 = v21[1];
    free((void *)*a4);
    *a4 = 0;
    *a5 = 0;
    if (v19 >= a7 || 1000000 * (v22 - v23) >= a7)
    {
      if (*(int *)(a1 + 1040) < 1)
      {
        uint64_t v21 = 0;
      }
      else
      {
        pc_info("Cache miss after PENDING timeout: %s\n", v24, v25, v26, v27, v28, v29, v30, (char)&__to);
        uint64_t v21 = (void *)*a4;
      }
      break;
    }
    if (*(int *)(a1 + 1040) >= 1 && v19 >= v20)
    {
      pc_info("Waiting for PENDING patch (%llu s): %s\n", v24, v25, v26, v27, v28, v29, v30, v19 / 0xF4240);
      v20 *= 2;
    }
    v19 += 500000;
    usleep(0x7A120u);
    if ((loadFileContentsEx((const char *)&__to, a4, a5) & 0x80000000) != 0) {
      return 0xFFFFFFFFLL;
    }
  }
  free(v21);
  *a4 = 0;
  *a5 = 0;
  bzero(&__from, 0x400uLL);
  __buf[0] = 0x5F474E49444E4550;
  __buf[1] = time(0);
  int v33 = openEntryTemp(a1, (long long *)a2, (__int16 *)a3, (char *)&__from);
  if (v33 < 0) {
    return 0xFFFFFFFFLL;
  }
  int v34 = v33;
  ssize_t v35 = write(v33, __buf, 0x10uLL);
  close(v34);
  if (v35 == 16)
  {
    rename(&__from, &__to, v36);
    if (!v40) {
      return 0;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"installFile", 151, 9, "Moving %s to %s (1st attempt)", v37, v38, v39, (char)&__from);
    rename(&__from, &__to, v41);
    if (!v45) {
      return 0;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"installFile", 153, 9, "Moving %s to %s (2nd attempt)", v42, v43, v44, (char)&__from);
    uint64_t v32 = 0;
  }
  else
  {
    __uint32_t v47 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"filePatchCacheLookup", 331, 9, *v47, "writing PENDING in cache entry failed", v48, v49, v50);
    uint64_t v32 = 0xFFFFFFFFLL;
  }
  unlink((const char *)&__from);
  return v32;
}

uint64_t loadFileContentsEx(const char *a1, void *a2, unint64_t *a3)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  memset(&v20, 0, sizeof(v20));
  int v5 = open(a1, 0);
  if (v5 < 0)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    goto LABEL_8;
  }
  int v6 = v5;
  if (fstat(v5, &v20) || (unint64_t st_size = v20.st_size, v20.st_size < 8))
  {
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v8 = (char *)malloc(v20.st_size);
    if (!v8)
    {
      int v13 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"loadFileContentsEx", 51, 9, *v13, "malloc", v14, v15, v19.tv_sec);
      uint64_t v9 = 0xFFFFFFFFLL;
      goto LABEL_6;
    }
    unint64_t v11 = 0;
    while (st_size > v11)
    {
      ssize_t v12 = read(v6, &v8[v11], st_size - v11);
      v11 += v12 & ~(v12 >> 63);
      if (v12 <= 0) {
        goto LABEL_5;
      }
    }
    timeval v19 = (timeval)0;
    if (!gettimeofday(&v19, 0))
    {
      timeval v21 = v19;
      timeval v22 = v19;
      futimes(v6, &v21);
      close(v6);
      uint64_t v9 = 1;
      goto LABEL_9;
    }
    long long v16 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"loadFileContentsEx", 66, 9, *v16, "gettimeofday", v17, v18, v19.tv_sec);
  }
LABEL_5:
  uint64_t v9 = 0;
LABEL_6:
  close(v6);
LABEL_8:
  free(v8);
  uint64_t v8 = 0;
  unint64_t st_size = 0;
LABEL_9:
  *a2 = v8;
  *a3 = st_size;
  return v9;
}

uint64_t openEntryTemp(uint64_t a1, long long *a2, __int16 *a3, char *__dst)
{
  memcpy(__dst, (const void *)(a1 + 4), *(void *)(a1 + 1032));
  uint64_t v8 = *(void *)(a1 + 1032);
  uint64_t v9 = &__dst[v8];
  *uint64_t v9 = 47;
  __int16 v10 = *a3;
  v9[3] = *((unsigned char *)a3 + 2);
  *(_WORD *)(v9 + 1) = v10;
  v9[4] = 47;
  uint64_t v11 = *((void *)a3 + 4);
  long long v12 = *((_OWORD *)a3 + 1);
  *(_OWORD *)(v9 + 5) = *(_OWORD *)a3;
  *(_OWORD *)(v9 + 21) = v12;
  *(void *)(v9 + 37) = v11;
  v9[45] = 47;
  long long v14 = *a2;
  long long v13 = a2[1];
  uint64_t v15 = *((void *)a2 + 4);
  v9[86] = 0;
  long long v16 = &__dst[v8 + 86];
  *((void *)v16 - 1) = v15;
  *(_OWORD *)(v16 - 40) = v14;
  *(_OWORD *)(v16 - 24) = v13;
  LODWORD(a3) = getpid();
  LODWORD(a3) = a3 + time(0);
  int v17 = 0;
  int v18 = a3 + pthread_self();
  useconds_t v19 = 250000;
  while (1)
  {
    int v18 = 1103515245 * v18 + 12345;
    snprintf(v16, 938 - v8, ".%08x", v18);
    uint64_t result = open(__dst, 2561, 384);
    if ((result & 0x80000000) == 0) {
      break;
    }
    if (*__error() != 17)
    {
      if (v17 == 10)
      {
        timeval v22 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"openEntryTemp", 129, 9, *v22, "Retry limit reached: %s", v23, v24, (char)__dst);
        return 0xFFFFFFFFLL;
      }
      usleep(v19);
      v19 *= 2;
      ++v17;
      size_t v21 = strlen(__dst);
      statPath(__dst, v21);
    }
  }
  return result;
}

uint64_t filePatchCacheUpdate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  bzero(&__to, 0x400uLL);
  bzero(&__from, 0x400uLL);
  uint64_t v10 = *(void *)(a1 + 1032);
  __memcpy_chk();
  uint64_t v11 = (char *)&__to + v10;
  *(_OWORD *)(v11 + 5) = *(_OWORD *)a3;
  *(_OWORD *)(v11 + 21) = *(_OWORD *)(a3 + 16);
  long long v12 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v11 + 46) = *(_OWORD *)a2;
  *uint64_t v11 = 47;
  *(_WORD *)(v11 + 1) = *(_WORD *)a3;
  v11[3] = *(unsigned char *)(a3 + 2);
  v11[4] = 47;
  *(void *)(v11 + 37) = *(void *)(a3 + 32);
  v11[45] = 47;
  *(_OWORD *)(v11 + 62) = v12;
  *(void *)(v11 + 78) = *(void *)(a2 + 32);
  v11[86] = 0;
  int v13 = openEntryTemp(a1, (long long *)a2, (__int16 *)a3, (char *)&__from);
  if (v13 < 0) {
    return 0xFFFFFFFFLL;
  }
  int v14 = v13;
  if (a5)
  {
    unint64_t v15 = 0;
    while (1)
    {
      ssize_t v16 = write(v14, (const void *)(a4 + v15), a5 - v15);
      if (v16 < 0)
      {
        int v30 = *__error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"filePatchCacheUpdate", 369, 9, v30, "%s", v31, v32, (char)&__from);
        goto LABEL_14;
      }
      if (!v16) {
        break;
      }
      v15 += v16;
      if (v15 >= a5) {
        goto LABEL_7;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"filePatchCacheUpdate", 370, 9, 0, "write error: %s", v17, v18, (char)&__from);
LABEL_14:
    close(v14);
    uint64_t v29 = 0xFFFFFFFFLL;
  }
  else
  {
LABEL_7:
    close(v14);
    rename(&__from, &__to, v19);
    if (v23)
    {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"installFile", 151, 9, "Moving %s to %s (1st attempt)", v20, v21, v22, (char)&__from);
      rename(&__from, &__to, v24);
      if (v28)
      {
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"installFile", 153, 9, "Moving %s to %s (2nd attempt)", v25, v26, v27, (char)&__from);
        unlink((const char *)&__from);
      }
    }
    uint64_t v29 = 0;
  }
  unlink((const char *)&__from);
  return v29;
}

AAByteStream_impl *aaForkOutputStreamOpen(uint64_t a1, void *a2)
{
  uint64_t v4 = (AAByteStream_impl *)calloc(1uLL, 0x68uLL);
  int v5 = calloc(1uLL, 0x20050uLL);
  uint64_t v8 = v5;
  if (!v4 || !v5)
  {
    int v17 = *__error();
    uint64_t v18 = "malloc";
    __int16 v19 = 405;
LABEL_13:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"aaForkOutputStreamOpen", v19, 136, v17, v18, v6, v7, v38);
    goto LABEL_14;
  }
  if (!*(void *)(a1 + 40) || !*(void *)(a1 + 32))
  {
    uint64_t v18 = "stream not compatible\n";
    __int16 v19 = 406;
    int v17 = 0;
    goto LABEL_13;
  }
  uint64_t v9 = v5 + 16385;
  AACustomByteStreamSetData(v4, v5);
  AACustomByteStreamSetWriteProc(v4, (AAByteStreamWriteProc)ForkOutputStreamWrite);
  AACustomByteStreamSetPWriteProc(v4, (AAByteStreamPWriteProc)ForkOutputStreamPWrite);
  AACustomByteStreamSetCancelProc(v4, (AAByteStreamCancelProc)ForkOutputStreamCancel);
  AACustomByteStreamSetCloseProc(v4, (AAByteStreamCloseProc)ForkOutputStreamClose);
  *uint64_t v9 = a1;
  v8[16386] = a2;
  if (a2[258]) {
    size_t v10 = a2[270] + 1;
  }
  else {
    size_t v10 = a2[270];
  }
  v8[16390] = v10;
  if (is_mul_ok(v10, 0x30uLL) && 48 * v10 < 0x2000000001)
  {
    ssize_t v16 = calloc(v10, 0x30uLL);
  }
  else
  {
    int v13 = __error();
    ssize_t v16 = 0;
    int *v13 = 12;
  }
  v8[16389] = v16;
  *(_OWORD *)(v8 + 16391) = 0u;
  *((_DWORD *)v8 + 32786) = 0;
  if (!v16)
  {
    int v17 = *__error();
    uint64_t v18 = "aaCalloc";
    __int16 v19 = 423;
    goto LABEL_13;
  }
  uint64_t v28 = 0;
  uint64_t v29 = a2[270];
  uint64_t v30 = a2[258];
  char v31 = 1;
  uint64_t v32 = v16;
  while (1)
  {
    if (v29)
    {
      int v33 = (void *)a2[268];
      for (uint64_t i = v29; i; --i)
      {
        uint64_t v35 = v33[51];
        if (v31)
        {
          if (v35)
          {
            *uint64_t v32 = v33;
            v32[1] = v28;
            uint64_t v36 = (void *)v33[48];
            uint64_t v37 = v33[49];
            v32[2] = 0;
            v32[3] = v37;
            v32[4] = *v36;
LABEL_26:
            v32[5] = v33[5];
            v28 += v37;
            v8[16392] = v28;
            v32 += 6;
          }
        }
        else if ((v35 & 2) != 0)
        {
          v32[1] = v28;
          v32[2] = 0;
          uint64_t v37 = v33[4];
          v32[3] = v37;
          goto LABEL_26;
        }
        v33 += 55;
      }
    }
    if ((v31 & 1) == 0) {
      break;
    }
    char v31 = 0;
    uint64_t v14 = v28;
    uint64_t v15 = v28;
    if (v30)
    {
      char v31 = 0;
      v32[1] = v28;
      v32[2] = 0;
      v32[3] = v30;
      v32[5] = 0;
      uint64_t v14 = v30 + v28;
      v32 += 6;
      uint64_t v15 = v28;
      uint64_t v28 = v14;
      v8[16392] = v14;
    }
  }
  a2[257] = v15;
  a2[259] = v14;
  if (v32 == &v16[6 * v8[16390]])
  {
    a2[260] = v28;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"aaForkOutputStreamOpen", 477, 136, 0, "bad variant", v11, v12, v38);
    a2[260] = v8[16392];
LABEL_14:
    free(v4);
    ForkOutputStreamClose((void **)v8, v20, v21, v22, v23, v24, v25, v26);
    return 0;
  }
  return v4;
}

uint64_t ForkOutputStreamWrite(_DWORD *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (void **)(a1 + 32770);
  if (a1[32786])
  {
    uint64_t v9 = "bad write mode";
    __int16 v10 = 198;
    goto LABEL_3;
  }
  unint64_t v11 = a3;
  if (!a3) {
    return v11;
  }
  int v13 = (const uint8_t *)a1;
  unint64_t v14 = 0;
  dst_buffer = (uint8_t *)a1 + 65537;
  __dst = (char *)a1 + 65538;
  uint64_t v155 = a1 + 32770;
  while (1)
  {
    uint64_t v15 = v8[6];
    if (v15 == v8[5])
    {
      uint64_t v9 = "segment out of range";
      __int16 v10 = 202;
      goto LABEL_3;
    }
    uint64_t v153 = v8[4];
    ssize_t v16 = &v153[6 * (void)v15];
    uint64_t v18 = v16 + 2;
    size_t v17 = v16[2];
    unint64_t v19 = v11 - v14;
    uint64_t v21 = v16 + 3;
    size_t v20 = v16[3];
    if (v11 - v14 >= 0x10000 - (unint64_t)(unsigned __int16)v17) {
      unint64_t v19 = 0x10000 - (unsigned __int16)v17;
    }
    if (v20 - v17 >= v19) {
      size_t v22 = v19;
    }
    else {
      size_t v22 = v20 - v17;
    }
    memcpy((void *)&v13[(unsigned __int16)v17], (const void *)(a2 + v14), v22);
    size_t v23 = v22 + *v18;
    long long v152 = v16 + 2;
    *uint64_t v18 = v23;
    long long v149 = v16 + 3;
    size_t v24 = *v21;
    if (v23 == *v21) {
      v8[6] = (void *)((char *)v8[6] + 1);
    }
    size_t v25 = (unsigned __int16)v23;
    if ((_WORD)v23)
    {
      if (v23 < v24) {
        goto LABEL_134;
      }
    }
    else
    {
      size_t v25 = 0x10000;
    }
    size_t v150 = v22;
    uint64_t v26 = (void *)*v16;
    if (!*v16)
    {
      uint64_t v30 = (uint64_t)*v8;
      if ((*v8)[5])
      {
        uint64_t v31 = 0;
        size_t v32 = v23 - v25 + v153[6 * (void)v15 + 5];
        int v33 = a1;
        size_t v34 = v25;
        while (1)
        {
          uint64_t v35 = (*(uint64_t (**)(void, _DWORD *, size_t, size_t))(v30 + 40))(*(void *)v30, v33, v34, v32);
          if (v35 < 1) {
            break;
          }
          int v33 = (_DWORD *)((char *)v33 + v35);
          v31 += v35;
          v32 += v35;
          v34 -= v35;
          if (!v34) {
            goto LABEL_85;
          }
        }
        uint64_t v31 = v35;
      }
      else
      {
        uint64_t v31 = -1;
      }
LABEL_85:
      BOOL v87 = v25 == v31;
      uint64_t v8 = (void **)v155;
      int v13 = (const uint8_t *)a1;
      size_t v22 = v150;
      if (!v87)
      {
        uint64_t v9 = "aaByteStreamPWriteExpected";
        __int16 v10 = 230;
        goto LABEL_3;
      }
      goto LABEL_134;
    }
    unint64_t v27 = v26[7];
    unint64_t v145 = v14;
    size_t v148 = &v153[6 * (void)v15];
    if ((unint64_t)v8[3] < v27)
    {
      v8[3] = (void *)v27;
      if (24 * v27 >= 0x2000000001)
      {
        *__error() = 12;
      }
      else
      {
        uint64_t v28 = v8[2];
        uint64_t v29 = realloc(v28, 24 * v27);
        if (v29)
        {
          v8[2] = v29;
          size_t v23 = *v152;
          goto LABEL_30;
        }
        free(v28);
      }
      v8[2] = 0;
      uint64_t v9 = "aaReallocf";
      __int16 v10 = 240;
      goto LABEL_3;
    }
    uint64_t v29 = v8[2];
LABEL_30:
    unint64_t v36 = (v23 - 1) >> 16;
    uint64_t v37 = v26[48] + 12 * v36;
    unint64_t v156 = v36;
    char v38 = &v29[3 * v36];
    size_t v39 = compression_encode_buffer(dst_buffer, 0x10000uLL, v13, v25, 0, (compression_algorithm)LODWORD(v8[1][*((unsigned __int8 *)v26 + 432)]));
    if (v39 - 1 >= v25) {
      size_t v40 = v25 + 1;
    }
    else {
      size_t v40 = v39;
    }
    v38[1] = v40;
    uint64_t v41 = v38 + 1;
    long long v144 = v38;
    v38[2] = v40;
    uint64_t v42 = v38 + 2;
    uint64_t v43 = &v153[6 * (void)v15];
    uint64_t v44 = v43[4];
    int v157 = v43 + 4;
    size_t v45 = *(void *)v37 + *(unsigned int *)(v37 + 8);
    size_t v46 = v40;
    if (v44 + v40 < v45)
    {
      size_t v46 = v45 - v44;
      *uint64_t v42 = v45 - v44;
    }
    if (v46 == v25 + 1)
    {
      *uint64_t v41 = v25 + 1;
      uint8_t *dst_buffer = BYTE4(v8[1][*((unsigned __int8 *)v26 + 432)]);
      memcpy(__dst, a1, v25);
      size_t v40 = *v41;
      size_t v46 = *v42;
    }
    bzero(&dst_buffer[v40], v46 - v40);
    uint64_t v47 = v26[50];
    uint64_t v48 = *v157;
    unint64_t v49 = v47 - *v157;
    unint64_t v50 = *v42 - v49;
    long long v147 = v15;
    if (*v42 > v49) {
      break;
    }
LABEL_76:
    *long long v144 = v48;
    size_t v80 = *v42;
    uint64_t v81 = (uint64_t)*v8;
    if ((*v8)[5])
    {
      if (!v80) {
        goto LABEL_89;
      }
      uint64_t v82 = 0;
      uint64_t v83 = v153[6 * (void)v15 + 5] + v48;
      int v84 = dst_buffer;
      size_t v85 = *v42;
      while (1)
      {
        uint64_t v86 = (*(uint64_t (**)(void, uint8_t *, size_t, uint64_t))(v81 + 40))(*(void *)v81, v84, v85, v83);
        if (v86 < 1) {
          break;
        }
        v84 += v86;
        v82 += v86;
        v83 += v86;
        v85 -= v86;
        if (!v85) {
          goto LABEL_88;
        }
      }
      uint64_t v82 = v86;
    }
    else
    {
      uint64_t v82 = -1;
    }
LABEL_88:
    uint64_t v8 = (void **)v155;
    uint64_t v15 = v147;
    ssize_t v16 = v148;
    if (v80 != v82)
    {
      uint64_t v9 = "aaByteStreamPWriteExpected";
      __int16 v10 = 287;
      goto LABEL_3;
    }
LABEL_89:
    *v157 += v80;
    size_t v22 = v150;
    int v13 = (const uint8_t *)a1;
    unint64_t v14 = v145;
    if (*v152 == *v149)
    {
      uint64_t v88 = (void *)*v16;
      uint64_t v89 = *(void *)(*v16 + 408);
      uint64_t v90 = *(void *)(*v16 + 56);
      uint64_t v91 = 2 * v90;
      if ((v89 & 4) == 0) {
        uint64_t v91 = v90 + 1;
      }
      size_t v92 = 4 * v91;
      if ((unint64_t)(4 * v91) >= 0x2000000001)
      {
        *__error() = 12;
LABEL_148:
        v135 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"fork_write_index", 81, 136, *v135, "aaMalloc", v136, v137, v138);
        v96 = 0;
        goto LABEL_142;
      }
      uint64_t v93 = malloc(v92);
      if (!v93) {
        goto LABEL_148;
      }
      v96 = v93;
      if ((v89 & 4) != 0)
      {
        uint64_t v107 = (uint64_t)*v8;
        if ((*v8)[5])
        {
          uint64_t v108 = 0;
          uint64_t v109 = &v153[6 * (void)v147 + 5];
          uint64_t v110 = v88 + 41;
          uint64_t v111 = *v109 + v88[50] - 50;
          uint64_t v112 = 50;
          while (1)
          {
            uint64_t v113 = (*(uint64_t (**)(void, void *, uint64_t, uint64_t))(v107 + 40))(*(void *)v107, v110, v112, v111);
            if (v113 < 1) {
              break;
            }
            uint64_t v110 = (void *)((char *)v110 + v113);
            v108 += v113;
            v111 += v113;
            v112 -= v113;
            if (!v112)
            {
              if (v108 != 50) {
                break;
              }
              uint64_t v114 = (void *)*v155;
              if (*(void *)(*v155 + 40))
              {
                uint64_t v115 = 0;
                uint64_t v116 = v88 + 8;
                uint64_t v117 = *v109;
                uint64_t v118 = 264;
                while (1)
                {
                  uint64_t v119 = ((uint64_t (*)(void, void *, uint64_t, uint64_t))v114[5])(*v114, v116, v118, v117);
                  if (v119 < 1) {
                    break;
                  }
                  uint64_t v116 = (void *)((char *)v116 + v119);
                  v115 += v119;
                  v117 += v119;
                  v118 -= v119;
                  if (!v118)
                  {
                    if (v115 != 264) {
                      break;
                    }
                    uint64_t v120 = v88[7];
                    uint64_t v8 = (void **)v155;
                    if (v120)
                    {
                      uint64_t v121 = (void *)(v155[2] + 16);
                      uint64_t v122 = v96 + 1;
                      do
                      {
                        *(v122 - 1) = *((_DWORD *)v121 - 4) - 260;
                        uint64_t v123 = *v121;
                        v121 += 3;
                        *uint64_t v122 = v123;
                        v122 += 2;
                        --v120;
                      }
                      while (v120);
                    }
                    uint64_t v101 = *v109 + 264;
                    unint64_t v14 = v145;
                    goto LABEL_99;
                  }
                }
              }
              v133 = "aaByteStreamPWriteExpected";
              __int16 v134 = 94;
              goto LABEL_141;
            }
          }
        }
        v133 = "aaByteStreamPWriteExpected";
        __int16 v134 = 89;
LABEL_141:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"fork_write_index", v134, 136, 0, v133, v94, v95, v138);
LABEL_142:
        free(v96);
        uint64_t v9 = "fork_write_index";
        __int16 v10 = 294;
        goto LABEL_3;
      }
      if (v90)
      {
        v97 = v93 + 1;
        unint64_t v98 = (int *)(v8[2] + 2);
        do
        {
          int v99 = *(v98 - 4);
          *(v97 - 1) = v99;
          int v100 = *v98;
          v98 += 6;
          *v97++ = v100 + v99;
          --v90;
        }
        while (v90);
      }
      uint64_t v101 = v153[6 * (void)v15 + 5];
      unint64_t v14 = v145;
LABEL_99:
      uint64_t v102 = (uint64_t)*v8;
      if (!(*v8)[5]) {
        goto LABEL_149;
      }
      if (v92)
      {
        uint64_t v103 = 0;
        int v104 = v96;
        size_t v105 = v92;
        while (1)
        {
          uint64_t v106 = (*(uint64_t (**)(void, _DWORD *, size_t, uint64_t))(v102 + 40))(*(void *)v102, v104, v105, v101);
          if (v106 < 1) {
            break;
          }
          int v104 = (_DWORD *)((char *)v104 + v106);
          v103 += v106;
          v101 += v106;
          v105 -= v106;
          if (!v105) {
            goto LABEL_120;
          }
        }
        uint64_t v103 = v106;
LABEL_120:
        BOOL v87 = v92 == v103;
        uint64_t v8 = (void **)v155;
        unint64_t v14 = v145;
        if (!v87)
        {
LABEL_149:
          v133 = "aaByteStreamPWriteExpected";
          __int16 v134 = 117;
          goto LABEL_141;
        }
      }
      uint64_t v124 = v88[4];
      uint64_t v125 = v88[50];
      unint64_t v126 = v124 - v125;
      if (v124 != v125)
      {
        if (v126 >= 0x1000)
        {
          v133 = "too much padding";
          __int16 v134 = 123;
          goto LABEL_141;
        }
        bzero(dst_buffer, v124 - v125);
        uint64_t v127 = (uint64_t)*v8;
        if (!(*v8)[5]) {
          goto LABEL_150;
        }
        if (v126)
        {
          uint64_t v128 = 0;
          uint64_t v129 = v153[6 * (void)v147 + 5] + v88[50];
          size_t v130 = dst_buffer;
          unint64_t v131 = v126;
          while (1)
          {
            uint64_t v132 = (*(uint64_t (**)(void, uint8_t *, unint64_t, uint64_t))(v127 + 40))(*(void *)v127, v130, v131, v129);
            if (v132 < 1) {
              break;
            }
            v130 += v132;
            v128 += v132;
            v129 += v132;
            v131 -= v132;
            if (!v131) {
              goto LABEL_131;
            }
          }
          uint64_t v128 = v132;
LABEL_131:
          BOOL v87 = v126 == v128;
          uint64_t v8 = (void **)v155;
          unint64_t v14 = v145;
          if (!v87)
          {
LABEL_150:
            v133 = "aaByteStreamPWriteExpected";
            __int16 v134 = 126;
            goto LABEL_141;
          }
        }
      }
      free(v96);
      unint64_t v11 = a3;
      int v13 = (const uint8_t *)a1;
      size_t v22 = v150;
    }
LABEL_134:
    v14 += v22;
    if (v14 >= v11) {
      return v11;
    }
  }
  int v51 = v153 + 48 * v15 + 40;
  unint64_t v154 = &v153[6 * (void)v15 + 5];
  unint64_t v52 = v156;
  uint64_t v140 = v42;
  do
  {
    if (!v52)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"fork_realign", 142, 136, 0, "realignment failed", a7, a8, v138);
      goto LABEL_139;
    }
    uint64_t v53 = v8[2];
    uint64_t v54 = &v53[3 * v52 - 3];
    uint64_t v57 = v54[2];
    int v55 = v54 + 2;
    uint64_t v56 = v57;
    uint64_t v58 = *(v55 - 1);
    unint64_t v59 = v57 - v58;
    unint64_t v60 = v50 - (v57 - v58);
    if (v50 > v57 - v58)
    {
      *int v55 = v58;
      --v52;
      goto LABEL_73;
    }
    *int v55 = v56 - v50;
    uint64_t v48 = v53[3 * v52 - 3] + v56 - v50;
    *int v157 = v48;
    if (v52 >= v156) {
      goto LABEL_76;
    }
    unint64_t v141 = v59;
    unint64_t v142 = v50;
    while (1)
    {
      uint64_t v61 = &v8[2][3 * v52];
      uint64_t v62 = *v154;
      uint64_t v63 = v61[1];
      uint64_t v64 = *v61 + *v154;
      uint64_t v65 = (uint64_t)*v8;
      if ((*v8)[11])
      {
        if (v63 != aaByteStreamSimulate(*v8))
        {
          __int16 v77 = 173;
          int v78 = "aaByteStreamSimulate";
          goto LABEL_72;
        }
        goto LABEL_59;
      }
      if (*(void *)(v65 + 32))
      {
        if (!v63)
        {
          if (!*(void *)(v65 + 40)) {
            goto LABEL_70;
          }
          goto LABEL_68;
        }
        uint64_t v66 = 0;
        uint64_t v67 = a1;
        uint64_t v68 = v61[1];
        while (1)
        {
          uint64_t v69 = (*(uint64_t (**)(void, _DWORD *, uint64_t, uint64_t))(v65 + 32))(*(void *)v65, v67, v68, v64);
          if (v69 < 0) {
            break;
          }
          if (v69)
          {
            uint64_t v67 = (_DWORD *)((char *)v67 + v69);
            v66 += v69;
            v64 += v69;
            v68 -= v69;
            if (v68) {
              continue;
            }
          }
          goto LABEL_58;
        }
        uint64_t v66 = v69;
      }
      else
      {
        uint64_t v66 = -1;
      }
LABEL_58:
      uint64_t v8 = (void **)v155;
      if (v63 != v66) {
        break;
      }
LABEL_59:
      uint64_t v70 = (uint64_t)*v8;
      if ((*v8)[5])
      {
        if (!v63) {
          goto LABEL_68;
        }
        uint64_t v71 = 0;
        uint64_t v72 = v62 + v48;
        uint64_t v73 = a1;
        uint64_t v74 = v63;
        while (1)
        {
          uint64_t v75 = (*(uint64_t (**)(void, _DWORD *, uint64_t, uint64_t))(v70 + 40))(*(void *)v70, v73, v74, v72);
          if (v75 < 1) {
            break;
          }
          uint64_t v73 = (_DWORD *)((char *)v73 + v75);
          v71 += v75;
          v72 += v75;
          v74 -= v75;
          if (!v74) {
            goto LABEL_67;
          }
        }
        uint64_t v71 = v75;
      }
      else
      {
        uint64_t v71 = -1;
      }
LABEL_67:
      uint64_t v8 = (void **)v155;
      if (v63 != v71)
      {
LABEL_70:
        __int16 v77 = 180;
        int v78 = "aaByteStreamPWriteExpected";
        goto LABEL_72;
      }
LABEL_68:
      uint64_t v76 = *v157;
      *uint64_t v61 = *v157;
      uint64_t v48 = v76 + v63;
      *int v157 = v76 + v63;
      if (++v52 == v156) {
        goto LABEL_75;
      }
    }
    __int16 v77 = 176;
    int v78 = "aaByteStreamPReadExpected";
LABEL_72:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"fork_realign", v77, 136, 0, v78, a7, a8, v138);
    int v51 = -1;
    unint64_t v50 = v142;
    unint64_t v11 = a3;
    unint64_t v60 = v142;
    uint64_t v15 = v147;
    ssize_t v16 = v148;
    uint64_t v42 = v140;
    unint64_t v59 = v141;
LABEL_73:
    BOOL v79 = v50 > v59;
    unint64_t v50 = v60;
  }
  while (v79);
  if ((v51 & 0x80000000) == 0)
  {
LABEL_75:
    uint64_t v48 = *v157;
    unint64_t v11 = a3;
    uint64_t v15 = v147;
    ssize_t v16 = v148;
    uint64_t v42 = v140;
    goto LABEL_76;
  }
LABEL_139:
  uint64_t v9 = "realign_fork";
  __int16 v10 = 279;
LABEL_3:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"ForkOutputStreamWrite", v10, 136, 0, v9, a7, a8, v138);
  return -1;
}

uint64_t ForkOutputStreamPWrite(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a4;
  uint64_t v9 = (uint64_t *)(a1 + 131080);
  if (*(_DWORD *)(a1 + 131144)) {
    goto LABEL_2;
  }
  uint64_t v25 = a1;
  uint64_t v26 = *(void *)(a1 + 131112);
  uint64_t v27 = *(void *)(a1 + 131128);
  uint64_t v28 = (void *)(v26 + 48 * v27);
  uint64_t v29 = v28[2];
  if (v29 + v28[1] != a4)
  {
    uint64_t v31 = (unsigned __int16)v28[2];
    if ((unsigned __int16)v28[2])
    {
      if (*v28)
      {
        size_t v32 = "pending compressed fork";
        __int16 v33 = 323;
        goto LABEL_50;
      }
      uint64_t v34 = *v9;
      if (!*(void *)(*v9 + 40)) {
        goto LABEL_49;
      }
      unint64_t v35 = a3;
      uint64_t v36 = 0;
      unint64_t v37 = (v29 & 0xFFFFFFFFFFFF0000) + *(void *)(v26 + 48 * v27 + 40);
      uint64_t v38 = (unsigned __int16)v28[2];
      while (1)
      {
        uint64_t v39 = (*(uint64_t (**)(void, uint64_t, uint64_t, unint64_t))(v34 + 40))(*(void *)v34, v25, v38, v37);
        if (v39 < 1) {
          break;
        }
        v25 += v39;
        v36 += v39;
        v37 += v39;
        v38 -= v39;
        if (!v38) {
          goto LABEL_47;
        }
      }
      uint64_t v36 = v39;
LABEL_47:
      a3 = v35;
      if (v31 != v36)
      {
LABEL_49:
        size_t v32 = "aaByteStreamPWriteExpected";
        __int16 v33 = 325;
LABEL_50:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"ForkOutputStreamPWrite", v33, 136, 0, v32, a7, a8, a2);
        return -1;
      }
    }
    *((_DWORD *)v9 + 16) = 1;
LABEL_2:
    unint64_t v10 = 0;
    if (a3)
    {
      unint64_t v41 = a3;
      while (1)
      {
        if (v9[7] <= v8)
        {
LABEL_37:
          size_t v32 = "no segment found";
          __int16 v33 = 340;
          goto LABEL_50;
        }
        uint64_t v11 = v9[4];
        unint64_t v12 = v9[5];
        if (v12 < 2)
        {
          if (!v11) {
            goto LABEL_37;
          }
          uint64_t v13 = 0;
        }
        else
        {
          uint64_t v13 = 0;
          do
          {
            if (*(void *)(v11 + 48 * ((v13 + v12) >> 1) + 8) > v8) {
              unint64_t v12 = (v13 + v12) >> 1;
            }
            else {
              uint64_t v13 = (v13 + v12) >> 1;
            }
          }
          while (v13 + 1 < v12);
        }
        if (*(void *)(v11 + 48 * v13))
        {
          size_t v32 = "compressed fork";
          __int16 v33 = 341;
          goto LABEL_50;
        }
        unint64_t v14 = (void *)(v11 + 48 * v13);
        unint64_t v15 = v8 - v14[1];
        unint64_t v16 = v14[3];
        if (a3 - v10 >= v16 - v15) {
          unint64_t v17 = v16 - v15;
        }
        else {
          unint64_t v17 = a3 - v10;
        }
        unint64_t v18 = v17 + v14[2];
        v14[2] = v18;
        if (v18 > v16)
        {
          size_t v32 = "too much data";
          __int16 v33 = 349;
          goto LABEL_50;
        }
        uint64_t v19 = *v9;
        if (*(void *)(*v9 + 40))
        {
          if (!v17) {
            goto LABEL_28;
          }
          uint64_t v20 = 0;
          unint64_t v21 = a2 + v10;
          unint64_t v22 = *(void *)(v11 + 48 * v13 + 40) + v15;
          unint64_t v23 = v17;
          while (1)
          {
            uint64_t v24 = (*(uint64_t (**)(void, unint64_t, unint64_t, unint64_t))(v19 + 40))(*(void *)v19, v21, v23, v22);
            if (v24 < 1) {
              break;
            }
            v21 += v24;
            v20 += v24;
            v22 += v24;
            v23 -= v24;
            if (!v23) {
              goto LABEL_27;
            }
          }
          uint64_t v20 = v24;
        }
        else
        {
          uint64_t v20 = -1;
        }
LABEL_27:
        a3 = v41;
        if (v17 != v20)
        {
          size_t v32 = "aaByteStreamPWriteExpected";
          __int16 v33 = 353;
          goto LABEL_50;
        }
LABEL_28:
        v8 += v17;
        v10 += v17;
        if (v10 >= a3) {
          return v10;
        }
      }
    }
    return v10;
  }

  return ForkOutputStreamWrite((_DWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
}

void ForkOutputStreamCancel(uint64_t a1)
{
}

uint64_t ForkOutputStreamClose(void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v9 = a1 + 16387;
    unint64_t v10 = a1[16389];
    if (v10)
    {
      uint64_t v11 = (char *)v9[3];
      if (v11)
      {
        unint64_t v12 = v10 + 3;
        while (*(v12 - 1) == *v12)
        {
          v12 += 6;
          if (!--v11) {
            goto LABEL_7;
          }
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"ForkOutputStreamClose", 382, 136, 0, "data missing", a7, a8, v15);
        int v13 = 0;
        unint64_t v10 = v9[2];
      }
      else
      {
LABEL_7:
        int v13 = 1;
      }
      free(v10);
    }
    else
    {
      int v13 = 1;
    }
    free(*v9);
    free(a1);
  }
  else
  {
    int v13 = 1;
  }
  if (v13) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t DirectoryPatch()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  v72[4] = *MEMORY[0x263EF8340];
  enterThreadErrorContext(v0, v1, v2, v3, v4, v5, v6, v7, v49);
  int DefaultNThreads = *(_DWORD *)(v0 + 48);
  int v9 = *(_DWORD *)(v0 + 52);
  if (!DefaultNThreads) {
    int DefaultNThreads = getDefaultNThreads();
  }
  memset(&v58, 0, sizeof(v58));
  memset(v72, 0, 28);
  uint64_t v57 = 0;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v52 = 0u;
  bzero(&v59, 0x1510uLL);
  int v59 = v9;
  unint64_t v10 = MemBufferCreate(0x40000uLL);
  uint64_t v67 = v10;
  uint64_t v11 = MemBufferCreate(0x100000uLL);
  uint64_t v68 = v11;
  unint64_t v14 = (const float *)(v0 + 24);
  int8x16_t v15 = (int8x16_t)vld1q_dup_f32(v14);
  int8x16_t v63 = vandq_s8(v15, (int8x16_t)xmmword_2106D3DD0);
  long long v64 = *(_OWORD *)(v0 + 28);
  int v65 = *(_DWORD *)(v0 + 44);
  int v66 = 0;
  if (!v10 || !v11)
  {
    unint64_t v17 = "allocation";
    __int16 v18 = 332;
    goto LABEL_25;
  }
  if (*(void *)v0)
  {
    if (!realpath_DARWIN_EXTSN(*(const char **)v0, v60))
    {
      int v19 = *__error();
      unint64_t v17 = *(const char **)v0;
      __int16 v18 = 339;
LABEL_27:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"DirectoryPatch", v18, 25, v19, v17, v12, v13, (char)v50);
      uint64_t v20 = 0;
LABEL_28:
      unsigned int v21 = -1;
      goto LABEL_29;
    }
    if (stat(*(const char **)v0, &v58) || (v58.st_mode & 0xF000) != 0x4000)
    {
      unint64_t v50 = *(const char **)v0;
      unint64_t v17 = "inPath is not a directory: %s";
      __int16 v18 = 340;
      goto LABEL_25;
    }
  }
  if (stat(*(const char **)(v0 + 8), &v58)) {
    mkdir(*(const char **)(v0 + 8), 0x1EDu);
  }
  if (!realpath_DARWIN_EXTSN(*(const char **)(v0 + 8), v61))
  {
    int v19 = *__error();
    unint64_t v17 = *(const char **)(v0 + 8);
    __int16 v18 = 350;
    goto LABEL_27;
  }
  if (stat(*(const char **)(v0 + 8), &v58) || (v58.st_mode & 0xF000) != 0x4000)
  {
    unint64_t v50 = *(const char **)(v0 + 8);
    unint64_t v17 = "outPath is not a directory: %s";
    __int16 v18 = 351;
    goto LABEL_25;
  }
  if (*(void *)v0 && !strcmp(v60, v61))
  {
    unint64_t v17 = "inPath == outPath is not supported";
    __int16 v18 = 354;
    goto LABEL_25;
  }
  if (!realpath_DARWIN_EXTSN(*(const char **)(v0 + 16), v62))
  {
    int v19 = *__error();
    unint64_t v17 = *(const char **)(v0 + 16);
    __int16 v18 = 357;
    goto LABEL_27;
  }
  if (stat(*(const char **)(v0 + 16), &v58) || (v58.st_mode & 0xF000) != 0x8000)
  {
    unint64_t v50 = *(const char **)(v0 + 16);
    unint64_t v17 = "patchFilename is not a regular file: %s";
    __int16 v18 = 358;
    goto LABEL_25;
  }
  off_t st_size = v58.st_size;
  if (loadFileSegment(v62, v72, 0x1CuLL, 0))
  {
    unint64_t v17 = "read patch header";
    __int16 v18 = 362;
LABEL_25:
    int v19 = 0;
    goto LABEL_27;
  }
  if (v72[0] != 0x3031464649444944)
  {
    unint64_t v17 = "invalid patch header";
    __int16 v18 = 365;
    goto LABEL_25;
  }
  uint64_t v23 = *(void *)((char *)&v72[2] + 4);
  uint64_t v24 = *(void *)((char *)&v72[1] + 4) + 28 + *(void *)((char *)&v72[2] + 4);
  if (st_size != *(void *)((char *)&v72[1] + 4) + 28 && st_size != v24)
  {
    unint64_t v17 = "invalid patch size";
    __int16 v18 = 368;
    goto LABEL_25;
  }
  if (*(void *)((char *)&v72[2] + 4) && st_size != v24 && (*(unsigned char *)(v0 + 24) & 2) == 0)
  {
    unint64_t v17 = "patch has been truncated, can't expand archive payload";
    __int16 v18 = 369;
    goto LABEL_25;
  }
  uint64_t v51 = *(void *)((char *)&v72[1] + 4) + 28 + *(void *)((char *)&v72[2] + 4);
  if (v9 >= 1)
  {
    uint64_t v25 = (FILE **)MEMORY[0x263EF8348];
    fwrite("DirectoryPatch:\n", 0x10uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    if (*(void *)v0) {
      fprintf(*v25, "  input directory: %s\n", v60);
    }
    fprintf(*v25, "  output directory: %s\n", v61);
    fprintf(*v25, "  patch file: %s\n", v62);
    fprintf(*v25, "  worker threads: %d\n", DefaultNThreads);
    int v26 = *(_DWORD *)(v0 + 24);
    if (v26)
    {
      if (v26) {
        uint64_t v27 = "yes";
      }
      else {
        uint64_t v27 = "no";
      }
      fprintf(*v25, "  skip diff payload: %s\n", v27);
      if ((*(_DWORD *)(v0 + 24) & 2) != 0) {
        uint64_t v28 = "yes";
      }
      else {
        uint64_t v28 = "no";
      }
      fprintf(*v25, "  skip archive payload: %s\n", v28);
      if ((*(_DWORD *)(v0 + 24) & 4) != 0) {
        uint64_t v29 = "yes";
      }
      else {
        uint64_t v29 = "no";
      }
      fprintf(*v25, "  truncate archive payload: %s\n", v29);
      if ((*(_DWORD *)(v0 + 24) & 0x200) != 0) {
        uint64_t v30 = "yes";
      }
      else {
        uint64_t v30 = "no";
      }
      fprintf(*v25, "  skip attributes: %s\n", v30);
      int v26 = *(_DWORD *)(v0 + 24);
      if ((v26 & 0x10000) != 0)
      {
        fwrite("  MSU mode: yes\n", 0x10uLL, 1uLL, *v25);
        int v26 = *(_DWORD *)(v0 + 24);
      }
      if ((v26 & 0x200) != 0) {
        goto LABEL_71;
      }
    }
    if ((v26 & 0x100) != 0) {
      uint64_t v31 = "yes";
    }
    else {
      uint64_t v31 = "no";
    }
    fprintf(*v25, "  ignore EPERM: %s\n", v31);
    char v32 = *(unsigned char *)(v0 + 28);
    if (v32)
    {
      fprintf(*v25, "  override UID: %u\n", *(_DWORD *)(v0 + 32));
      char v32 = *(unsigned char *)(v0 + 28);
      if ((v32 & 2) == 0)
      {
LABEL_68:
        if ((v32 & 8) == 0) {
          goto LABEL_69;
        }
        goto LABEL_79;
      }
    }
    else if ((*(unsigned char *)(v0 + 28) & 2) == 0)
    {
      goto LABEL_68;
    }
    fprintf(*v25, "  override GID: %u\n", *(_DWORD *)(v0 + 36));
    char v32 = *(unsigned char *)(v0 + 28);
    if ((v32 & 8) == 0)
    {
LABEL_69:
      if ((v32 & 4) == 0)
      {
LABEL_71:
        fprintf(*v25, "%12llu diff payload size\n", *(void *)((char *)&v72[1] + 4));
        fprintf(*v25, "%12llu archive payload size\n", *(void *)((char *)&v72[2] + 4));
        uint64_t v23 = *(void *)((char *)&v72[2] + 4);
        goto LABEL_72;
      }
LABEL_70:
      fprintf(*v25, "  override mode for directories: 0%o\n", *(_DWORD *)(v0 + 40));
      goto LABEL_71;
    }
LABEL_79:
    fprintf(*v25, "  override mode for regular files: 0%o\n", *(_DWORD *)(v0 + 44));
    if ((*(unsigned char *)(v0 + 28) & 4) == 0) {
      goto LABEL_71;
    }
    goto LABEL_70;
  }
LABEL_72:
  long long v52 = 0u;
  long long v53 = 0u;
  DWORD1(v52) = DefaultNThreads;
  *(void *)&long long v54 = directoryPatchBegin;
  *(void *)&long long v56 = directoryPatchEnd;
  *((void *)&v54 + 1) = directoryPatchBlob;
  *(void *)&long long v55 = directoryPatchPayload;
  *((void *)&v55 + 1) = directoryPatchPadding;
  *((void *)&v56 + 1) = directoryPatchPadding;
  uint64_t v57 = &v59;
  if (v23 && (*(unsigned char *)(v0 + 24) & 2) == 0)
  {
    uint64_t v33 = IFileStreamCreateWithFilename(v62, *(void *)((char *)&v72[1] + 4) + 28, v23);
    uint64_t v20 = (char *)v33;
    if (!v33)
    {
      unint64_t v41 = "create archive payload stream";
      __int16 v42 = 418;
      goto LABEL_94;
    }
    uint64_t v69 = 0;
    *((void *)&v53 + 1) = v33;
    *((void *)&v52 + 1) = IFileStreamRead;
    if (ParallelArchiveRead((uint64_t)&v52, v34, v35, v36, v37, v38, v39, v40))
    {
      unint64_t v41 = "read archive payload";
      __int16 v42 = 423;
LABEL_94:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"DirectoryPatch", v42, 25, 0, v41, v39, v40, (char)v50);
      goto LABEL_28;
    }
    IFileStreamDestroy(v20);
    if (v70)
    {
      LOBYTE(v50) = v70;
      unint64_t v17 = "DirectoryPatch: %llu errors after processing the archive payload";
      __int16 v18 = 432;
      goto LABEL_25;
    }
  }
  if (st_size == v51 && (*(unsigned char *)(v0 + 24) & 4) != 0 && truncate(v62, *(void *)((char *)&v72[1] + 4) + 28))
  {
    int v19 = *__error();
    __int16 v18 = 441;
    unint64_t v17 = v62;
    goto LABEL_27;
  }
  if (*(void *)((char *)&v72[1] + 4) && (*(unsigned char *)(v0 + 24) & 1) == 0)
  {
    uint64_t v43 = IFileStreamCreateWithFilename(v62, 0x1CuLL, *(void *)((char *)&v72[1] + 4));
    uint64_t v20 = (char *)v43;
    if (!v43)
    {
      unint64_t v41 = "create diff payload stream";
      __int16 v42 = 448;
      goto LABEL_94;
    }
    uint64_t v69 = 28;
    *((void *)&v53 + 1) = v43;
    *((void *)&v52 + 1) = IFileStreamRead;
    if (ParallelArchiveRead((uint64_t)&v52, v44, v45, v46, v47, v48, v39, v40))
    {
      unint64_t v41 = "read diff payload";
      __int16 v42 = 453;
      goto LABEL_94;
    }
    IFileStreamDestroy(v20);
    if (v70)
    {
      LOBYTE(v50) = v70;
      unint64_t v17 = "DirectoryPatch: %llu errors after processing the diff payload";
      __int16 v18 = 462;
      goto LABEL_25;
    }
  }
  if (v9 >= 1) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12lld entries processed\n", v71);
  }
  uint64_t v20 = 0;
  unsigned int v21 = 0;
LABEL_29:
  IFileStreamDestroy(v20);
  MemBufferDestroy(v67);
  MemBufferDestroy(v68);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0) {
    return v21;
  }
  else {
    return result;
  }
}

void directoryPatchBegin()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v9 = v0;
  uint64_t v49 = *MEMORY[0x263EF8340];
  bzero(v48, 0x800uLL);
  bzero(v47, 0x800uLL);
  *(void *)(v9 + 5328) += v2;
  uint64_t v12 = (int *)(v9 + 5336);
  *(_OWORD *)(v9 + 5336) = 0u;
  *(_OWORD *)(v9 + 5352) = 0u;
  if (*(void *)(v9 + 5376)) {
    goto LABEL_9;
  }
  if ((*(_DWORD *)v8 & 1) == 0) {
    goto LABEL_7;
  }
  if (*(_DWORD *)(v8 + 4) == 77)
  {
LABEL_9:
    *(_DWORD *)(v9 + 5340) = 1;
    return;
  }
  if ((~*(_DWORD *)v8 & 0x8001) != 0)
  {
LABEL_7:
    uint64_t v13 = "invalid archive entry, PAT/TYP missing";
    __int16 v14 = 78;
    goto LABEL_8;
  }
  if (*(void *)(v9 + 5368))
  {
    uint64_t v13 = "output file stream was not closed";
    __int16 v14 = 79;
LABEL_8:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", v14, 25, 0, v13, v10, v11, v44);
    ++*(void *)(v9 + 5376);
    goto LABEL_9;
  }
  memset(&v45, 0, sizeof(v45));
  if (concatPath(v48, 0x800uLL, (char *)(v9 + 1028), (const char *)(v8 + 144)))
  {
    uint64_t v13 = "create output path";
    __int16 v14 = 82;
    goto LABEL_8;
  }
  ++*(void *)(v9 + 5384);
  memcpy((void *)(v9 + 3136), (const void *)v8, 0x890uLL);
  if (*(int *)v9 >= 2) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%s\n", (const char *)(v8 + 144));
  }
  size_t v15 = strlen(v48);
  makePath(v48, v15);
  if (!lstat(v48, &v45) && (v45.st_mode & 0xF000) != 0x4000) {
    unlink(v48);
  }
  int v18 = *(_DWORD *)(v8 + 4);
  switch(v18)
  {
    case 'D':
      if (lstat(v48, &v45))
      {
        if (mkdir(v48, 0x1EDu))
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", 107, 25, 0, "mkdir %s", v21, v22, (char)v48);
          goto LABEL_63;
        }
      }
      else if ((v45.st_mode & 0xF000) != 0x4000)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", 112, 25, 0, "entry expected to be a directory: %s", v19, v20, (char)v48);
        goto LABEL_63;
      }
      return;
    case 'F':
      int v23 = *(_DWORD *)(v9 + 3076);
      if (v23) {
        int v24 = 2;
      }
      else {
        int v24 = 1;
      }
      *(_DWORD *)(v9 + 5336) = v24;
      if ((*(unsigned char *)(v8 + 1) & 2) != 0)
      {
        int v29 = 4;
LABEL_47:
        *uint64_t v12 = v29;
        goto LABEL_48;
      }
      if (v4)
      {
        while ((*v6 & 0xDFDFDF) != 0x505842)
        {
          v6 += 258;
          if (!--v4) {
            goto LABEL_30;
          }
        }
        int v29 = 3;
        goto LABEL_47;
      }
LABEL_30:
      if (!v23)
      {
        bzero(v46, 0x800uLL);
        if (concatPath(v46, 0x800uLL, (char *)(v9 + 4), (const char *)(v8 + 144)))
        {
          uint64_t v27 = "create input path";
          __int16 v28 = 141;
          goto LABEL_62;
        }
        if (link(v46, v48))
        {
          int v29 = 2;
          goto LABEL_47;
        }
      }
LABEL_48:
      uint64_t v34 = 64;
      if ((*(_DWORD *)v8 & 0x200) == 0) {
        uint64_t v34 = 40;
      }
      unint64_t v35 = *(void *)(v8 + v34);
      if ((*(_DWORD *)v8 & 8) != 0) {
        int v36 = 4 * (statIsCompressed(*(_DWORD *)(v8 + 16)) != 0);
      }
      else {
        int v36 = 0;
      }
      if ((*v12 - 2) <= 2)
      {
        unsigned int v37 = *(_DWORD *)(v9 + 3084) ? v36 | 0x2B : v36;
        uint64_t v38 = OArchiveFileStreamCreate(v48, v35, v37, -1, *(_DWORD *)(v9 + 3112));
        *(void *)(v9 + 5368) = v38;
        if (!v38)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", 160, 25, 0, "create output stream", v39, v40, v44);
          ++*(void *)(v9 + 5376);
        }
        if (*v12 == 2)
        {
          bzero(v46, 0x800uLL);
          if (concatPath(v46, 0x800uLL, (char *)(v9 + 4), (const char *)(v8 + 144)))
          {
            uint64_t v27 = "create input path";
            __int16 v28 = 167;
            goto LABEL_62;
          }
          uint64_t v41 = IFileStreamCreateWithFilename(v46, 0, -1);
          if (!v41)
          {
            uint64_t v27 = "create input stream";
            __int16 v28 = 169;
            goto LABEL_62;
          }
          __int16 v42 = (char *)v41;
          uint64_t v43 = MemBufferTransmit(*(unint64_t **)(v9 + 3120), v35, (size_t (*)(int, void *, size_t))IFileStreamRead, v41, (uint64_t (*)(uint64_t, uint64_t, uint64_t))OArchiveFileStreamWrite, *(void *)(v9 + 5368), v25, v26);
          IFileStreamDestroy(v42);
          if (v43 != v35)
          {
            uint64_t v27 = "copy preserved";
            __int16 v28 = 172;
            goto LABEL_62;
          }
        }
      }
      return;
    case 'H':
      if ((*(unsigned char *)(v8 + 2) & 1) == 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", 122, 25, 0, "missing LNK field: %s", v16, v17, v8 - 112);
        goto LABEL_63;
      }
      if (concatPath(v47, 0x800uLL, (char *)(v9 + 1028), (const char *)(v8 + 1168)))
      {
        uint64_t v27 = "create output link path";
        __int16 v28 = 123;
LABEL_62:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", v28, 25, 0, v27, v25, v26, v44);
        goto LABEL_63;
      }
      if (link(v47, v48))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", 124, 25, 0, "hlink %s -> %s", v32, v33, (char)v48);
        goto LABEL_63;
      }
      return;
    case 'L':
      if ((*(unsigned char *)(v8 + 2) & 1) == 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", 117, 25, 0, "missing LNK field: %s", v16, v17, v8 - 112);
        goto LABEL_63;
      }
      if (symlink((const char *)(v8 + 1168), v48))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", 118, 25, 0, "slink %s -> %s", v30, v31, (char)v48);
        goto LABEL_63;
      }
      return;
    default:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", 179, 25, 0, "unsupported entry type '%c'", v16, v17, v18);
LABEL_63:
      ++*(void *)(v9 + 5376);
      return;
  }
}

unsigned int *directoryPatchEnd(unsigned int *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  if (result[1335]) {
    return result;
  }
  uint64_t v8 = result;
  if (result[1334] == 3)
  {
    bzero(v36, 0x800uLL);
    if (concatPath(v36, 0x800uLL, (char *)v8 + 4, (const char *)v8 + 3280))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchEnd", 196, 25, 0, "create input path", v9, v10, v31);
      ++*((void *)v8 + 672);
    }
    uint64_t v11 = MappedBufferCreateWithFilename((const char *)v8 + 2052, *((void *)v8 + 669), *((void *)v8 + 670));
    if (v11)
    {
      uint64_t v12 = v11;
      uint64_t NWritten = OMemStreamGetNWritten((uint64_t)v11);
      unint64_t DataSize = MappedBufferGetDataSize((uint64_t)v12);
      LODWORD(NWritten) = BXPatch5FileWithFlags(v36, NWritten, DataSize, (uint64_t (*)(uint64_t, void *, uint64_t))OArchiveFileStreamWrite, *((void *)v8 + 671), 0);
      MappedBufferDestroy(v12);
      if (!NWritten) {
        goto LABEL_10;
      }
    }
    else
    {
      MappedBufferDestroy(0);
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchEnd", 205, 25, 0, "patching file %s", a7, a8, (_BYTE)v8 - 48);
    ++*((void *)v8 + 672);
  }
LABEL_10:
  uint64_t result = (unsigned int *)*((void *)v8 + 671);
  if (result)
  {
    uint64_t result = (unsigned int *)OArchiveFileStreamDestroy(result, a2, a3, a4, a5, a6, a7, a8);
    *((void *)v8 + 671) = 0;
  }
  if ((*((unsigned char *)v8 + 3137) & 0x20) != 0)
  {
    unsigned int v15 = v8[1334];
    if (v15 <= 4 && ((1 << v15) & 0x16) != 0)
    {
      bzero(v36, 0x800uLL);
      uint64_t v33 = 0;
      uint64_t v34 = 0;
      int v35 = 0;
      if (concatPath(v36, 0x800uLL, (char *)v8 + 1028, (const char *)v8 + 3280))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchEnd", 223, 25, 0, "create output path", v16, v17, v31);
        ++*((void *)v8 + 672);
      }
      uint64_t result = (unsigned int *)getFileSHA1Digest(v36, (uint64_t)&v33);
      if (result)
      {
        uint64_t result = (unsigned int *)pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchEnd", 224, 25, 0, "hashing output file", v18, v19, v31);
        ++*((void *)v8 + 672);
      }
      if (v33 != *(void *)(v8 + 807) || v34 != *(void *)(v8 + 809) || v35 != (unint64_t)v8[811])
      {
        memset(v32, 0, 41);
        sha1ToString((uint64_t)v32, (uint64_t)&v33);
        uint64_t result = (unsigned int *)pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchEnd", 229, 25, 0, "invalid output file SHA1 digest %s: %s", v22, v23, v8 - 48);
        ++*((void *)v8 + 672);
      }
    }
  }
  if (!v8[772])
  {
    bzero(v36, 0x800uLL);
    if (concatPath(v36, 0x800uLL, (char *)v8 + 1028, (const char *)v8 + 3280))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchEnd", 238, 25, 0, "create output path", v24, v25, v31);
      ++*((void *)v8 + 672);
    }
    char v26 = *((unsigned char *)v8 + 3092);
    if (v26)
    {
      v8[784] |= 2u;
      v8[786] = v8[774];
    }
    if ((v26 & 2) != 0)
    {
      v8[784] |= 4u;
      v8[787] = v8[775];
    }
    unsigned int v27 = v8[785];
    if (v27 == 68)
    {
      if ((v26 & 4) == 0) {
        goto LABEL_41;
      }
      v8[784] |= 0x10u;
      __int16 v28 = v8 + 776;
    }
    else
    {
      if (v27 != 70 || (v26 & 8) == 0) {
        goto LABEL_41;
      }
      v8[784] |= 0x10u;
      __int16 v28 = v8 + 777;
    }
    v8[789] = *v28;
LABEL_41:
    uint64_t result = (unsigned int *)yaa_setEntryAttributes(v36, (int *)v8 + 784, 0, v8[770]);
    if (result)
    {
      uint64_t result = (unsigned int *)pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchEnd", 253, 25, 0, "set output attributes", v29, v30, v31);
      ++*((void *)v8 + 672);
    }
  }
  return result;
}

uint64_t directoryPatchBlob(uint64_t result, _DWORD *a2)
{
  if (!*(_DWORD *)(result + 5340))
  {
    *(void *)(result + 5344) = 0;
    int v2 = *a2 & 0xDFDFDF;
    if (v2 == 5265474)
    {
      *(_DWORD *)(result + 5348) = 1;
      *(void *)(result + 5352) = *(void *)(result + 5328);
    }
    else if (v2 == 5521732)
    {
      *(_DWORD *)(result + 5344) = 1;
    }
  }
  return result;
}

size_t directoryPatchPayload(size_t result, char *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)(result + 5328) += a3;
  if (!*(_DWORD *)(result + 5340))
  {
    size_t v8 = result;
    if (*(_DWORD *)(result + 5344))
    {
      uint64_t result = OArchiveFileStreamWrite(*(void *)(result + 5368), a2, a3, a4, a5, a6, a7, a8);
      if ((result & 0x8000000000000000) == 0) {
        return result;
      }
      uint64_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchPayload", 283, 25, 0, "write DAT blob", v9, v10, v12);
      uint64_t v11 = (void *)(v8 + 5376);
      a3 = 1;
    }
    else
    {
      if (!*(_DWORD *)(result + 5348)) {
        return result;
      }
      uint64_t v11 = (void *)(result + 5360);
    }
    *v11 += a3;
  }
  return result;
}

uint64_t directoryPatchPadding(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 5328) += a3;
  return result;
}

uint64_t ECC65537GetParity(unsigned int a1, uint64_t a2, uint64_t a3)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  if (a1 > 0x1FFE0) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v4 = (a1 & 1) + a1;
  if (v4)
  {
    int8x16_t v5 = 0uLL;
    int8x8_t v6 = vmovn_s16((int16x8_t)vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)ECC65537_G), (int16x8_t)vceqzq_s32(unk_2106D3E10))));
    int8x16_t v7 = vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)xmmword_2106D3E20), (int16x8_t)vceqzq_s32((int32x4_t)qword_2106D3E30)));
    v8.i64[0] = 0xFFFF0000FFFFLL;
    v8.i64[1] = 0xFFFF0000FFFFLL;
    v9.i64[0] = 0x1000000010000;
    v9.i64[1] = 0x1000000010000;
    v10.i64[0] = 0x100000001;
    v10.i64[1] = 0x100000001;
    int8x16_t v11 = 0uLL;
    int8x16_t v12 = 0uLL;
    int32x4_t v13 = 0uLL;
    do
    {
      uint64_t v14 = v4 - 2;
      if (v4 <= a1) {
        __int32 v15 = *(unsigned __int16 *)(a2 + v14);
      }
      else {
        __int32 v15 = *(unsigned __int8 *)(a2 + v14);
      }
      int32x4_t v16 = (int32x4_t)vextq_s8(v12, (int8x16_t)v13, 0xCuLL);
      int32x4_t v17 = (int32x4_t)vextq_s8(v11, v12, 0xCuLL);
      int32x4_t v18 = (int32x4_t)vextq_s8(qword_2106D3E30, v5, 0xCuLL);
      int32x4_t v19 = vdupq_laneq_s32(v13, 3);
      v18.i32[0] = v15;
      int32x4_t v20 = (int32x4_t)vextq_s8(v5, v11, 0xCuLL);
      int32x4_t v21 = vmulq_laneq_s32((int32x4_t)xmmword_2106D3E20, v13, 3);
      int32x4_t v22 = vmulq_laneq_s32((int32x4_t)qword_2106D3E30, v13, 3);
      int32x4_t v23 = vmulq_laneq_s32((int32x4_t)ECC65537_G, v13, 3);
      int32x4_t v24 = vmulq_laneq_s32(unk_2106D3E10, v13, 3);
      int16x8_t v25 = (int16x8_t)vceqzq_s32(v19);
      int8x16_t v26 = (int8x16_t)vuzp1q_s16(v25, v25);
      int8x8_t v27 = vmovn_s16((int16x8_t)vmvnq_s8(v26));
      int8x8_t v28 = vmovn_s16(vuzp1q_s16((int16x8_t)vceqzq_s32(v23), (int16x8_t)vceqzq_s32(v24)));
      int8x16_t v29 = (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32(v21), (int16x8_t)vceqzq_s32(v22));
      int8x16_t v30 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v22, v8), (int32x4_t)vshrq_n_u32((uint32x4_t)v22, 0x10uLL));
      int8x16_t v31 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v21, v8), (int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x10uLL));
      int8x16_t v32 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v24, v8), (int32x4_t)vshrq_n_u32((uint32x4_t)v24, 0x10uLL));
      int8x16_t v33 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v23, v8), (int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x10uLL));
      *(int8x8_t *)v26.i8 = vmovn_s16((int16x8_t)vandq_s8(vbicq_s8(v7, v26), v29));
      int32x4_t v34 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v26.i8, (int8x8_t)0xB4200003C1CLL)), 0x1FuLL)), v10, vorrq_s8(vandq_s8(v30, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v30)), (int8x16_t)vqsubq_u32((uint32x4_t)v30, v9)));
      int32x4_t v35 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v26.i8, (int8x8_t)0xB4200003C1CLL)), 0x1FuLL)), v10, vorrq_s8(vandq_s8(v31, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v31)), (int8x16_t)vqsubq_u32((uint32x4_t)v31, v9)));
      *(int8x8_t *)v26.i8 = vand_s8(vand_s8(v6, v28), v27);
      int8x16_t v36 = (int8x16_t)vsubq_s32(v18, (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v26.i8, (int8x8_t)0xB4200003C1CLL)), 0x1FuLL)), v10, vorrq_s8(vandq_s8(v33, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v33)), (int8x16_t)vqsubq_u32((uint32x4_t)v33, v9))));
      int8x16_t v37 = (int8x16_t)vsubq_s32(v20, (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v26.i8, (int8x8_t)0xB4200003C1CLL)), 0x1FuLL)), v10, vorrq_s8(vandq_s8(v32, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v32)), (int8x16_t)vqsubq_u32((uint32x4_t)v32, v9))));
      int8x16_t v38 = (int8x16_t)vsubq_s32(v17, v35);
      int8x16_t v39 = (int8x16_t)vsubq_s32(v16, v34);
      int32x4_t v13 = (int32x4_t)vorrq_s8(vandq_s8(v39, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v39)), (int8x16_t)vqsubq_u32((uint32x4_t)v39, v9));
      int8x16_t v12 = vorrq_s8(vandq_s8(v38, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v38)), (int8x16_t)vqsubq_u32((uint32x4_t)v38, v9));
      int8x16_t v11 = vorrq_s8(vandq_s8(v37, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v37)), (int8x16_t)vqsubq_u32((uint32x4_t)v37, v9));
      int8x16_t v5 = vorrq_s8(vandq_s8(v36, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v36)), (int8x16_t)vqsubq_u32((uint32x4_t)v36, v9));
      unsigned int v4 = v14;
    }
    while (v14);
  }
  else
  {
    int8x16_t v5 = 0uLL;
    int8x16_t v11 = 0uLL;
    int8x16_t v12 = 0uLL;
    int32x4_t v13 = 0uLL;
  }
  uint64_t v40 = 0;
  int v41 = 0;
  v44[0] = v5;
  v44[1] = v11;
  v44[2] = v12;
  v44[3] = v13;
  do
  {
    int v42 = *((_DWORD *)v44 + v40);
    if (v42) {
      int v43 = 65537 - v42;
    }
    else {
      int v43 = 0;
    }
    v41 |= (1 << v40) & (v43 << 15 >> 31);
    *(_WORD *)(a3 + 2 * v40++) = v43;
  }
  while (v40 != 16);
  uint64_t result = 0;
  *(_WORD *)(a3 + 32) = v41;
  return result;
}

uint64_t ECC65537CheckAndFix(unsigned int a1, uint64_t a2, uint16x8_t *a3, _DWORD *a4)
{
  uint64_t v118 = *MEMORY[0x263EF8340];
  int8x16_t v7 = 0uLL;
  unsigned int v8 = (a1 & 1) + a1;
  if (v8)
  {
    int8x16_t v9 = 0uLL;
    int8x8_t v10 = vmovn_s16((int16x8_t)vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)ECC65537_G), (int16x8_t)vceqzq_s32(unk_2106D3E10))));
    int8x16_t v11 = vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)xmmword_2106D3E20), (int16x8_t)vceqzq_s32((int32x4_t)qword_2106D3E30)));
    v12.i64[0] = 0xFFFF0000FFFFLL;
    v12.i64[1] = 0xFFFF0000FFFFLL;
    v13.i64[0] = 0x1000000010000;
    v13.i64[1] = 0x1000000010000;
    v14.i64[0] = 0x100000001;
    v14.i64[1] = 0x100000001;
    int8x16_t v15 = 0uLL;
    int8x16_t v16 = 0uLL;
    int32x4_t v17 = 0uLL;
    unsigned int v18 = (a1 & 1) + a1;
    do
    {
      uint64_t v19 = v18 - 2;
      if (v18 <= a1) {
        __int32 v20 = *(unsigned __int16 *)(a2 + v19);
      }
      else {
        __int32 v20 = *(unsigned __int8 *)(a2 + v19);
      }
      int32x4_t v21 = (int32x4_t)vextq_s8(v16, (int8x16_t)v17, 0xCuLL);
      int32x4_t v22 = (int32x4_t)vextq_s8(v15, v16, 0xCuLL);
      int32x4_t v23 = (int32x4_t)vextq_s8((int8x16_t)0, v9, 0xCuLL);
      int32x4_t v24 = vdupq_laneq_s32(v17, 3);
      v23.i32[0] = v20;
      int32x4_t v25 = (int32x4_t)vextq_s8(v9, v15, 0xCuLL);
      int32x4_t v26 = vmulq_laneq_s32((int32x4_t)xmmword_2106D3E20, v17, 3);
      int32x4_t v27 = vmulq_laneq_s32((int32x4_t)qword_2106D3E30, v17, 3);
      int32x4_t v28 = vmulq_laneq_s32((int32x4_t)ECC65537_G, v17, 3);
      int32x4_t v29 = vmulq_laneq_s32(unk_2106D3E10, v17, 3);
      int16x8_t v30 = (int16x8_t)vceqzq_s32(v24);
      int8x16_t v31 = (int8x16_t)vuzp1q_s16(v30, v30);
      int8x8_t v32 = vmovn_s16((int16x8_t)vmvnq_s8(v31));
      int8x8_t v33 = vmovn_s16(vuzp1q_s16((int16x8_t)vceqzq_s32(v28), (int16x8_t)vceqzq_s32(v29)));
      int8x16_t v34 = (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32(v26), (int16x8_t)vceqzq_s32(v27));
      int8x16_t v35 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v27, v12), (int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x10uLL));
      int8x16_t v36 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v26, v12), (int32x4_t)vshrq_n_u32((uint32x4_t)v26, 0x10uLL));
      int8x16_t v37 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v29, v12), (int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x10uLL));
      int8x16_t v38 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v28, v12), (int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x10uLL));
      *(int8x8_t *)v31.i8 = vmovn_s16((int16x8_t)vandq_s8(vbicq_s8(v11, v31), v34));
      int32x4_t v39 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v31.i8, 0)), 0x1FuLL)), v14, vorrq_s8(vandq_s8(v35, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v35)), (int8x16_t)vqsubq_u32((uint32x4_t)v35, v13)));
      int32x4_t v40 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v31.i8, 0)), 0x1FuLL)), v14, vorrq_s8(vandq_s8(v36, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v36)), (int8x16_t)vqsubq_u32((uint32x4_t)v36, v13)));
      *(int8x8_t *)v31.i8 = vand_s8(vand_s8(v10, v33), v32);
      int8x16_t v41 = (int8x16_t)vsubq_s32(v23, (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v31.i8, 0)), 0x1FuLL)), v14, vorrq_s8(vandq_s8(v38, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v38)), (int8x16_t)vqsubq_u32((uint32x4_t)v38, v13))));
      int8x16_t v42 = (int8x16_t)vsubq_s32(v25, (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v31.i8, 0)), 0x1FuLL)), v14, vorrq_s8(vandq_s8(v37, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v37)), (int8x16_t)vqsubq_u32((uint32x4_t)v37, v13))));
      int8x16_t v43 = (int8x16_t)vsubq_s32(v22, v40);
      int8x16_t v44 = (int8x16_t)vsubq_s32(v21, v39);
      int32x4_t v17 = (int32x4_t)vorrq_s8(vandq_s8(v44, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v44)), (int8x16_t)vqsubq_u32((uint32x4_t)v44, v13));
      int8x16_t v16 = vorrq_s8(vandq_s8(v43, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v43)), (int8x16_t)vqsubq_u32((uint32x4_t)v43, v13));
      int8x16_t v15 = vorrq_s8(vandq_s8(v42, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v42)), (int8x16_t)vqsubq_u32((uint32x4_t)v42, v13));
      int8x16_t v9 = vorrq_s8(vandq_s8(v41, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v41)), (int8x16_t)vqsubq_u32((uint32x4_t)v41, v13));
      unsigned int v18 = v19;
    }
    while (v19);
  }
  else
  {
    int8x16_t v9 = 0uLL;
    int8x16_t v15 = 0uLL;
    int8x16_t v16 = 0uLL;
    int32x4_t v17 = 0uLL;
  }
  uint64_t v45 = 0;
  v117[0] = v9;
  v117[1] = v15;
  v117[2] = v16;
  v117[3] = v17;
  int32x4_t v46 = (int32x4_t)xmmword_2106D3DE0;
  int8x16_t v47 = (int8x16_t)vdupq_n_s32(a3[2].u16[0]);
  int32x4_t v48 = (int32x4_t)xmmword_2106D3DF0;
  v49.i64[0] = 0x100000001;
  v49.i64[1] = 0x100000001;
  v50.i64[0] = 0x1000000010000;
  v50.i64[1] = 0x1000000010000;
  v51.i64[0] = 0x800000008;
  v51.i64[1] = 0x800000008;
  int8x16_t v52 = 0uLL;
  do
  {
    uint16x8_t v53 = *a3++;
    int8x16_t v54 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v53.i8);
    int8x16_t v55 = (int8x16_t)vmovl_high_u16(v53);
    long long v56 = (int8x16_t *)&v117[v45];
    int32x4_t v57 = vaddq_s32((int32x4_t)vbslq_s8((int8x16_t)vceqzq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32(v49, (uint32x4_t)v46), v47)), v55, (int8x16_t)(*(_OWORD *)&v55 | __PAIR128__(0x1000000010000, 0x1000000010000))), (int32x4_t)v117[v45 + 1]);
    int32x4_t v58 = vaddq_s32((int32x4_t)vbslq_s8((int8x16_t)vceqzq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32(v49, (uint32x4_t)v48), v47)), v54, (int8x16_t)(*(_OWORD *)&v54 | __PAIR128__(0x1000000010000, 0x1000000010000))), (int32x4_t)v117[v45]);
    int8x16_t v59 = (int8x16_t)vminq_u32((uint32x4_t)vaddq_s32(v57, v50), (uint32x4_t)v57);
    int8x16_t v60 = (int8x16_t)vminq_u32((uint32x4_t)vaddq_s32(v58, v50), (uint32x4_t)v58);
    int8x16_t *v56 = v60;
    v56[1] = v59;
    int8x16_t v52 = vorrq_s8(v59, v52);
    int8x16_t v7 = vorrq_s8(v60, v7);
    int32x4_t v48 = vaddq_s32(v48, v51);
    int32x4_t v46 = vaddq_s32(v46, v51);
    v45 += 2;
  }
  while (v45 != 4);
  int8x16_t v61 = vorrq_s8(v7, v52);
  if (vorr_s8(*(int8x8_t *)v61.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v61, v61, 8uLL)))
  {
    uint64_t v62 = (int *)calloc(1uLL, 0x4C0uLL);
    if (v62)
    {
      int8x16_t v63 = v62;
      uint64_t v64 = 0;
      unsigned int v65 = v8 >> 1;
      int v66 = 1;
      do
      {
        v63[v64] = ecc65537PolyEval(16, (uint64_t)v117, v66);
        unsigned int v67 = (unsigned __int16)(3 * v66) - ((3 * v66) >> 16);
        if (v67 + 65537 >= v67) {
          int v66 = (unsigned __int16)(3 * v66) - ((3 * v66) >> 16);
        }
        else {
          int v66 = v67 + 65537;
        }
        ++v64;
      }
      while (v64 != 16);
      uint64_t v115 = a4;
      uint64_t v68 = 0;
      uint64_t v69 = 48;
      do
      {
        uint64_t v70 = &v63[v69];
        long long v71 = *(_OWORD *)&v63[v68];
        long long v72 = *(_OWORD *)&v63[v68 + 4];
        v70[8] = v63[v68 + 8];
        *(_OWORD *)uint64_t v70 = v71;
        *((_OWORD *)v70 + 1) = v72;
        v69 += 16;
        ++v68;
      }
      while (v68 != 8);
      int v73 = ecc65537Triangulate(8, 9, (uint64_t)(v63 + 48));
      if (v73 >= 1)
      {
        int v74 = v73;
        if ((ecc65537Solve(v73, v63 + 48, (uint64_t)(v63 + 16)) & 0x80000000) == 0)
        {
          uint64_t v114 = v63 + 48;
          unsigned int v75 = v74;
          int v76 = 0;
          int v77 = 0;
          unsigned int v116 = v75;
          int v78 = v75 + 1;
          unsigned int v79 = v65 + 16;
          int v80 = 1;
          do
          {
            if (!ecc65537PolyEval(v78, (uint64_t)(v63 + 16), v80) && v77 <= 7)
            {
              uint64_t v81 = &v63[v77++];
              v81[32] = v76;
            }
            unsigned int v82 = (unsigned __int16)(3 * v80) - ((3 * v80) >> 16);
            if (v82 + 65537 >= v82) {
              int v80 = (unsigned __int16)(3 * v80) - ((3 * v80) >> 16);
            }
            else {
              int v80 = v82 + 65537;
            }
            ++v76;
          }
          while (v79 != v76);
          if (v77 == v116)
          {
            uint64_t v83 = 0;
            uint64_t v84 = v116;
            do
            {
              uint64_t v85 = 0;
              uint64_t v86 = (16 * v83);
              do
              {
                int v87 = v63[v85 + 32] * v83;
                if (v87)
                {
                  int v88 = 3;
                  if (v87 < 0)
                  {
                    int v88 = ecc65537Inv(3);
                    int v87 = -v87;
                  }
                  unsigned int v89 = (unsigned __int16)v87;
                  unsigned int v90 = 1;
                  while (1)
                  {
                    if (v89)
                    {
                      if (v88 && v90 && !(v90 * v88))
                      {
                        unsigned int v90 = 1;
                      }
                      else
                      {
                        unsigned int v90 = (unsigned __int16)(v90 * v88) - ((v90 * v88) >> 16);
                        if (v90 + 65537 < v90) {
                          v90 += 65537;
                        }
                      }
                    }
                    if (v89 < 2) {
                      break;
                    }
                    v89 >>= 1;
                    unsigned int v91 = v88 * v88;
                    if (v88)
                    {
                      int v88 = 1;
                      if (!v91) {
                        continue;
                      }
                    }
                    unsigned int v92 = (unsigned __int16)v91 - HIWORD(v91);
                    if (v92 + 65537 >= v92) {
                      int v88 = v92;
                    }
                    else {
                      int v88 = v92 + 65537;
                    }
                  }
                }
                else
                {
                  unsigned int v90 = 1;
                }
                v63[v85 + 48 + v86] = v90;
                ++v85;
              }
              while (v85 != v116);
              int v93 = v63[v83];
              if (v93) {
                int v94 = 65537 - v93;
              }
              else {
                int v94 = 0;
              }
              v63[(int)(v86 + v116) + 48] = v94;
              ++v83;
            }
            while (v83 != v116);
            if (ecc65537Triangulate(v116, v78, (uint64_t)v114) == v116)
            {
              uint64_t v95 = v63 + 40;
              if ((ecc65537Solve(v116, v114, (uint64_t)(v63 + 40)) & 0x80000000) == 0)
              {
                uint64_t v97 = 0;
                int v98 = 0;
                while (1)
                {
                  int v99 = *(v95 - 8);
                  if (a1 > 2 * v99)
                  {
                    uint64_t v100 = (2 * v99);
                    BOOL v101 = (int)v100 + 2 <= a1 || a1 - v100 == 2;
                    int v102 = v101;
                    if (v101) {
                      int v103 = *(unsigned __int16 *)(a2 + v100);
                    }
                    else {
                      int v103 = *(unsigned __int8 *)(a2 + v100);
                    }
                    unsigned int v104 = v103 - *v95;
                    if (v104 + 65537 < v104) {
                      v104 += 65537;
                    }
                    if (HIWORD(v104)) {
                      goto LABEL_85;
                    }
                    int v105 = v104 ^ v103;
                    v96.i32[0] = v105;
                    int8x8_t v96 = vcnt_s8(v96);
                    v96.i16[0] = vaddlv_u8((uint8x8_t)v96);
                    v98 += v96.i32[0];
                    if ((_BYTE)v105) {
                      unsigned int v106 = v97 + 1;
                    }
                    else {
                      unsigned int v106 = v97;
                    }
                    if ((v105 & 0xFF00) != 0) {
                      uint64_t v97 = v106 + 1;
                    }
                    else {
                      uint64_t v97 = v106;
                    }
                    if (v102) {
                      *(_WORD *)(a2 + v100) = v104;
                    }
                    else {
                      *(unsigned char *)(a2 + v100) = v104;
                    }
                  }
                  ++v95;
                  uint64_t v107 = v97;
                  if (!--v84) {
                    goto LABEL_86;
                  }
                }
              }
            }
          }
        }
      }
      int v98 = 0;
      LODWORD(v97) = 0;
LABEL_85:
      uint64_t v107 = 0xFFFFFFFFLL;
LABEL_86:
      free(v63);
      if (v115 && (v107 & 0x80000000) == 0)
      {
        int v108 = v115[1] + v97;
        *v115 += v98;
        v115[1] = v108;
      }
    }
    else
    {
      uint64_t v109 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection_ECC65537.c", (uint64_t)"ECC65537CheckAndFix", 423, 63, *v109, "malloc", v110, v111, v113);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    return 0;
  }
  return v107;
}

uint64_t ecc65537PolyEval(int a1, uint64_t a2, int a3)
{
  if (a1 < 1) {
    return 0;
  }
  LODWORD(result) = 0;
  unint64_t v5 = a1 + 1;
  do
  {
    if (a3 && result && !(result * a3))
    {
      unsigned int v6 = 1;
    }
    else
    {
      unsigned int v6 = (unsigned __int16)(result * a3) - ((result * a3) >> 16);
      if (v6 + 65537 < v6) {
        v6 += 65537;
      }
    }
    unsigned int v7 = v6 + *(_DWORD *)(a2 + 4 * (v5 - 2));
    if (v7 - 65537 >= v7) {
      uint64_t result = v7;
    }
    else {
      uint64_t result = v7 - 65537;
    }
    --v5;
  }
  while (v5 > 1);
  return result;
}

uint64_t ecc65537Triangulate(uint64_t a1, int a2, uint64_t a3)
{
  if ((int)a1 < 1) {
    return 0;
  }
  unsigned int v3 = 0;
  uint64_t v4 = 0;
  int v5 = 0;
  LODWORD(v6) = 0;
  int v7 = 16;
  uint64_t v8 = 1;
  while (1)
  {
    if (v5 >= a2)
    {
      LODWORD(v11) = v6;
    }
    else
    {
      unsigned int v9 = v5 + v3;
LABEL_5:
      unsigned int v10 = v9;
      uint64_t v11 = v4;
      while (!*(_DWORD *)(a3 + 4 * (int)v10))
      {
        ++v11;
        v10 += 16;
        if (a1 == v11)
        {
          ++v5;
          ++v9;
          if (v5 != a2) {
            goto LABEL_5;
          }
          return v4;
        }
      }
    }
    uint64_t v6 = v4;
    if (v5 == a2) {
      return v6;
    }
    if (v4 == v11 || a2 <= 0)
    {
      int v12 = 16 * v4;
    }
    else
    {
      int v12 = 16 * v4;
      uint32x4_t v13 = (int *)(a3 + 64 * v11);
      uint64_t v14 = a2;
      unsigned int v15 = v3;
      do
      {
        int v16 = *v13;
        *v13++ = *(_DWORD *)(a3 + 4 * v15);
        *(_DWORD *)(a3 + 4 * v15++) = v16;
        --v14;
      }
      while (v14);
    }
    if (++v4 < (unint64_t)a1)
    {
      int v17 = *(_DWORD *)(a3 + 4 * (v12 + v5));
      uint64_t v18 = v5 + 1;
      uint64_t v19 = (int *)(a3 + 4 * (v12 + v18));
      int v20 = v7;
      uint64_t v21 = v8;
      do
      {
        int v22 = v5 + 16 * v21;
        int v23 = *(_DWORD *)(a3 + 4 * v22);
        if (v23)
        {
          *(_DWORD *)(a3 + 4 * v22) = 0;
          if ((int)v18 < a2)
          {
            int32x4_t v24 = (_WORD *)(a3 + 4 * (v18 + v20));
            int v25 = a2 - 1 - v5;
            int32x4_t v26 = v19;
            do
            {
              if (v17 && (*(_DWORD *)v24 ? (BOOL v27 = *(_DWORD *)v24 * v17 == 0) : (BOOL v27 = 0), v27))
              {
                unsigned int v28 = 1;
              }
              else
              {
                unsigned int v28 = (unsigned __int16)(*v24 * v17) - ((*(_DWORD *)v24 * v17) >> 16);
                if (v28 + 65537 < v28) {
                  v28 += 65537;
                }
              }
              int v30 = *v26++;
              int v29 = v30;
              int v31 = v30 * v23;
              unsigned int v32 = (unsigned __int16)(v30 * v23) - ((v30 * v23) >> 16);
              if (v32 + 65537 < v32) {
                v32 += 65537;
              }
              if (v29) {
                BOOL v33 = v31 == 0;
              }
              else {
                BOOL v33 = 0;
              }
              if (v33) {
                int v34 = 1;
              }
              else {
                int v34 = v32;
              }
              unsigned int v35 = v28 - v34;
              if (v35 + 65537 < v35) {
                v35 += 65537;
              }
              *(_DWORD *)int32x4_t v24 = v35;
              v24 += 2;
              --v25;
            }
            while (v25);
          }
        }
        ++v21;
        v20 += 16;
      }
      while (v21 != a1);
    }
    ++v8;
    v3 += 16;
    v7 += 16;
    if (v4 == a1) {
      return a1;
    }
  }
}

uint64_t ecc65537Solve(int a1, int *a2, uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  if (a1 <= 0)
  {
    uint64_t v24 = 0;
    *(_DWORD *)(a3 + 4 * a1) = 1;
  }
  else
  {
    uint64_t v5 = a1;
    uint64_t v6 = a2;
    do
    {
      int v7 = *v6;
      v6 += 17;
      if (!v7) {
        return 0xFFFFFFFFLL;
      }
      --v5;
    }
    while (v5);
    *(_DWORD *)(a3 + 4 * a1) = 1;
    uint64_t v8 = a1;
    int v9 = 16 * a1 - 16;
    uint64_t v10 = a1;
    do
    {
      if (v10 <= v8)
      {
        unsigned int v11 = 0;
        uint64_t v12 = v8;
        do
        {
          int v13 = *(_DWORD *)(a3 + 4 * v12);
          int v14 = a2[v9 + v12];
          if (v13) {
            BOOL v15 = v14 == 0;
          }
          else {
            BOOL v15 = 1;
          }
          if (!v15 && v14 * v13 == 0)
          {
            unsigned int v17 = 1;
          }
          else
          {
            unsigned int v17 = (unsigned __int16)(v14 * v13) - ((v14 * v13) >> 16);
            if (v17 + 65537 < v17) {
              v17 += 65537;
            }
          }
          unsigned int v18 = v17 + v11;
          if (v18 - 65537 >= v18) {
            unsigned int v11 = v18;
          }
          else {
            unsigned int v11 = v18 - 65537;
          }
          BOOL v19 = v12-- <= v10;
        }
        while (!v19);
      }
      else
      {
        unsigned int v11 = 0;
      }
      int v20 = ecc65537Inv(a2[17 * v10 - 17]);
      if (v11 && (v20 ? (BOOL v21 = v20 * v11 == 0) : (BOOL v21 = 0), v21))
      {
        unsigned int v22 = 1;
      }
      else
      {
        unsigned int v22 = (unsigned __int16)(v20 * v11) - ((v20 * v11) >> 16);
        if (v22 + 65537 < v22) {
          v22 += 65537;
        }
      }
      if (65537 - v22 >= -v22) {
        int v23 = -v22;
      }
      else {
        int v23 = 65537 - v22;
      }
      *(_DWORD *)(a3 + 4 * (v10 - 1)) = v23;
      v9 -= 16;
      BOOL v19 = v10-- <= 1;
    }
    while (!v19);
    return 0;
  }
  return v24;
}

uint64_t ecc65537Inv(uint64_t a1)
{
  if (a1 == 1)
  {
    LODWORD(v1) = 1;
  }
  else
  {
    uint64_t v2 = 0;
    uint64_t v3 = 1;
    uint64_t v4 = 65537;
    do
    {
      if (a1 <= v4)
      {
        char v5 = -1;
        do
        {
          unsigned int v6 = a1 << (v5 + 2);
          ++v5;
        }
        while (v6 <= v4);
        uint64_t v4 = (v4 - (a1 << v5));
        uint64_t v2 = (v2 - (v3 << v5));
      }
      uint64_t v1 = v2;
      uint64_t v7 = v4;
      uint64_t v2 = v3;
      uint64_t v3 = v1;
      uint64_t v4 = a1;
      a1 = v7;
    }
    while (v7 != 1);
  }
  int v8 = v1
     + 65537
     * (((v1 & ~((int)v1 >> 31)) - (v1 + (v1 >> 31))) / 0x10001
      + (v1 >> 31));
  if (v8 <= 0x10000) {
    unsigned int v9 = 0x10000;
  }
  else {
    unsigned int v9 = v1
  }
       + 65537
       * (((v1 & ~((int)v1 >> 31)) - (v1 + (v1 >> 31))) / 0x10001
        + (v1 >> 31));
  return v9 % 0x10001 - v9 + v8;
}

void *PagedFileCreate(const char *a1, unint64_t a2, unint64_t a3, int a4)
{
  memset(&v57, 0, sizeof(v57));
  if (stat(a1, &v57))
  {
    int v10 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileCreate", 320, 21, v10, "%s", v11, v12, (char)a1);
    return 0;
  }
  unint64_t st_size = v57.st_size;
  if (v57.st_size <= a2) {
    off_t v14 = a2;
  }
  else {
    off_t v14 = v57.st_size;
  }
  unint64_t v15 = v14 + 4095;
  if (v15 >= 0xFFFFFFEF000)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileCreate", 324, 21, 0, "File is too large to be patched in place", v8, v9, v55);
    return 0;
  }
  uint64_t v18 = (v15 >> 12) + 16;
  if ((a3 >> 12) <= 1) {
    unsigned int v19 = 1;
  }
  else {
    unsigned int v19 = a3 >> 12;
  }
  unsigned int v20 = v19 + v18;
  size_t v21 = (v19 << 12) + 4096 + 4 * v19 + 16 * (v18 & 0x3FFFFFFF) + 8 * v20 + 8 * v20 + 216;
  unsigned int v22 = malloc(v21);
  int v16 = v22;
  if (!v22)
  {
    int v29 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileCreate", 339, 21, *v29, "malloc", v30, v31, v55);
    return v16;
  }
  bzero(v22, v21);
  if (a4 >= 2) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "Opening paged file %s, %u pages in file, %u pages in cache, %u pages total, memory usage: %zu B\n", a1, v18, v19, v19 + v18, v21);
  }
  *(_DWORD *)int v16 = -1;
  v16[1] = st_size;
  v16[2] = a2;
  *((_DWORD *)v16 + 32) = a4;
  *((_DWORD *)v16 + 6) = v18;
  *((_DWORD *)v16 + 7) = v19;
  *((_DWORD *)v16 + 8) = v20;
  int v23 = open(a1, 2);
  *(_DWORD *)int v16 = v23;
  if (v23 < 0)
  {
    int v26 = *__error();
    char v56 = (char)a1;
    BOOL v27 = "%s";
    __int16 v28 = 357;
    goto LABEL_23;
  }
  char v56 = 1;
  if (fcntl(v23, 48)) {
    fwrite("Warning: couldn't set F_NOCACHE on paged file\n", 0x2EuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  if (ftruncate(*(_DWORD *)v16, v18 << 12))
  {
    int v26 = *__error();
    char v56 = (char)a1;
    BOOL v27 = "%s";
    __int16 v28 = 365;
LABEL_23:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileCreate", v28, 21, v26, v27, v24, v25, v56);
    if ((*(_DWORD *)v16 & 0x80000000) == 0) {
      close(*(_DWORD *)v16);
    }
    free(v16);
    return 0;
  }
  unsigned int v32 = (char *)(v16 + 24);
  uint64_t v33 = *((unsigned int *)v16 + 6);
  uint64_t v34 = *((unsigned int *)v16 + 7);
  uint64_t v35 = (uint64_t)v16 + 4 * v33 + 192;
  uint64_t v36 = v35 + 4 * v33;
  uint64_t v37 = v36 + 4 * v33;
  v16[14] = v36;
  v16[15] = v37;
  uint64_t v38 = v37 + 4 * v33;
  v16[7] = v38;
  v16[8] = v35;
  uint64_t v39 = *((unsigned int *)v16 + 8);
  uint64_t v40 = v38 + 4 * v39;
  uint64_t v41 = v40 + 4 * v39;
  v16[5] = v41;
  v16[6] = v16 + 24;
  uint64_t v42 = v41 + 8 * v39;
  v16[9] = v40;
  v16[10] = v42;
  uint64_t v43 = v42 + 4096;
  uint64_t v44 = v42 + 4096 + (v34 << 12);
  v16[11] = v43;
  v16[12] = v44;
  if (v44 + 4 * v34 > (unint64_t)v16 + v21)
  {
    BOOL v27 = "in memory allocation for PagedFile";
    __int16 v28 = 378;
    int v26 = 0;
    goto LABEL_23;
  }
  if (v39)
  {
    unint64_t v45 = 0;
    do
    {
      *(void *)(v38 + 8 * v39) = 0;
      *(_DWORD *)(v38 + 4 * v45) = -1;
      *(_DWORD *)(v38 + 4 * v39) = -1;
      ++v45;
      ++v39;
    }
    while (v45 < *((unsigned int *)v16 + 8));
    unsigned int v46 = *((_DWORD *)v16 + 6);
  }
  else
  {
    unsigned int v46 = v33;
  }
  if (v46)
  {
    unint64_t v47 = 0;
    int32x4_t v48 = &v32[4 * v33];
    uint32x4_t v49 = &v32[12 * v33];
    int32x4_t v50 = &v32[8 * v33];
    do
    {
      *(_DWORD *)&v32[4 * v47] = -1;
      *(_DWORD *)&v48[4 * v47] = -1;
      *(_DWORD *)&v50[4 * v47] = -1;
      *(_DWORD *)&v49[4 * v47++] = -1;
    }
    while (v47 < v46);
    unint64_t v51 = 0;
    unint64_t v52 = 0;
    unint64_t v53 = st_size;
    do
    {
      if (v51 >= st_size) {
        break;
      }
      unint64_t v54 = v53 - 4096;
      if (v53 >= 0x1000) {
        unint64_t v53 = 4096;
      }
      *(void *)(v41 + 8 * v52) = v53;
      *(_DWORD *)(v38 + 4 * v52) = v52;
      *(_DWORD *)&v32[4 * v52] = v52;
      ++v52;
      v51 += 4096;
      unint64_t v53 = v54;
    }
    while (v52 < v46);
  }
  return v16;
}

uint64_t PagedFileDestroy(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = result;
    for (unsigned int i = *(_DWORD *)(result + 24); ; ++i)
    {
      if (i >= *(_DWORD *)(v8 + 32))
      {
        int v10 = 1;
        goto LABEL_8;
      }
      if (storeCachePos(v8, i, a3, a4, a5, a6, a7, a8)) {
        break;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"flushCache", 243, 21, 0, "flushing cache pos", a7, a8, v19);
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileDestroy", 423, 21, 0, "flush cache", v11, v12, v20);
    int v10 = 0;
LABEL_8:
    if ((*(_DWORD *)v8 & 0x80000000) == 0)
    {
      if (ftruncate(*(_DWORD *)v8, *(void *)(v8 + 16)))
      {
        int v13 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileDestroy", 427, 21, *v13, "Final truncate", v14, v15, v19);
        int v10 = 0;
      }
      if (fcntl(*(_DWORD *)v8, 51, 0) == -1)
      {
        int v16 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileDestroy", 432, 21, *v16, "Final FULLSYNC", v17, v18, v21);
        int v10 = 0;
      }
      close(*(_DWORD *)v8);
    }
    if (*(int *)(v8 + 128) >= 2) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "Closing paged file, input size: %llu B, output size: %llu B, bytes read: %llu B, bytes written: %llu B\n", *(void *)(v8 + 8), *(void *)(v8 + 16), *(void *)(v8 + 136), *(void *)(v8 + 144));
    }
    free((void *)v8);
    if (v10) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t PagedFileDump(uint64_t a1, const char *a2)
{
  uint64_t v3 = (FILE **)MEMORY[0x263EF8348];
  uint64_t v4 = "current PagedFile state";
  if (a2) {
    uint64_t v4 = a2;
  }
  fprintf((FILE *)*MEMORY[0x263EF8348], "*** %s\n", v4);
  LODWORD(v7) = *(_DWORD *)(a1 + 32);
  if (!v7)
  {
    int v14 = 0;
    int v13 = 0;
    uint64_t v12 = 0;
    uint64_t v11 = 0;
    int v10 = 0;
    int v9 = 0;
    goto LABEL_29;
  }
  unint64_t v8 = 0;
  int v9 = 0;
  int v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  int v13 = 0;
  int v14 = 0;
  do
  {
    uint64_t v15 = *(void *)(*(void *)(a1 + 40) + 8 * v8);
    if (!v15)
    {
      if (v8 < *(unsigned int *)(a1 + 24)) {
        ++v13;
      }
      else {
        ++v14;
      }
    }
    uint64_t v16 = *(unsigned int *)(*(void *)(a1 + 56) + 4 * v8);
    if (v16 != -1)
    {
      ++v9;
      v11 += v15;
      if (v8 != *(_DWORD *)(*(void *)(a1 + 48) + 4 * v16)) {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileDump", 472, 21, 0, "invalid reverse index for IN", v5, v6, v22);
      }
    }
    uint64_t v17 = *(unsigned int *)(*(void *)(a1 + 72) + 4 * v8);
    if (v17 != -1)
    {
      ++v10;
      v12 += v15;
      if (v8 != *(_DWORD *)(*(void *)(a1 + 64) + 4 * v17)) {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileDump", 480, 21, 0, "invalid reverse index for OUT", v5, v6, v22);
      }
    }
    if (*(_DWORD *)(*(void *)(a1 + 56) + 4 * v8) != -1 && *(_DWORD *)(*(void *)(a1 + 72) + 4 * v8) != -1) {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileDump", 483, 21, 0, "inconsistency in inPage/outPage indices", v5, v6, v22);
    }
    int v18 = *(_DWORD *)(*(void *)(a1 + 56) + 4 * v8);
    if (v15)
    {
      if (v18 == -1 && *(_DWORD *)(*(void *)(a1 + 72) + 4 * v8) == -1)
      {
        __int16 v19 = 485;
        char v20 = "inconsistency in nRefs != 0";
LABEL_25:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileDump", v19, 21, 0, v20, v5, v6, v22);
      }
    }
    else if (v18 != -1 || *(_DWORD *)(*(void *)(a1 + 72) + 4 * v8) != -1)
    {
      __int16 v19 = 486;
      char v20 = "inconsistency in nRefs == 0";
      goto LABEL_25;
    }
    ++v8;
    unint64_t v7 = *(unsigned int *)(a1 + 32);
  }
  while (v8 < v7);
  uint64_t v3 = (FILE **)MEMORY[0x263EF8348];
LABEL_29:
  fprintf(*v3, "  %u total pages\n", v7);
  fprintf(*v3, "  %u free pages in file\n", v13);
  fprintf(*v3, "  %u free pages in cache\n", v14);
  fprintf(*v3, "  %u input pages stored, %llu bytes referenced\n", v9, v11);
  return fprintf(*v3, "  %u output pages stored, %llu bytes referenced\n", v10, v12);
}

uint64_t PagedFileRetainIn(void *a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    return 0;
  }
  uint64_t v8 = a1[6];
  while (1)
  {
    uint64_t v9 = *(unsigned int *)(v8 + 4 * (a2 >> 12));
    if (v9 == -1) {
      break;
    }
    uint64_t v10 = a1[15];
    *(_DWORD *)(a1[14] + 4 * (a2 >> 12)) = v9;
    unint64_t v11 = 4096 - (a2 & 0xFFF);
    *(_DWORD *)(v10 + 4 * v9) = a2 >> 12;
    if (v11 >= a3) {
      unint64_t v11 = a3;
    }
    *(void *)(a1[5] + 8 * v9) += v11;
    a2 += v11;
    a3 -= v11;
    if (!a3) {
      return 0;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileRetainIn", 503, 21, 0, "input page is not stored", a7, a8, vars0);
  return 0xFFFFFFFFLL;
}

uint64_t PagedFileReleaseIn(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    return 0;
  }
  unint64_t v8 = a3;
  uint64_t v11 = *(void *)(a1 + 48);
  uint64_t v12 = (FILE **)MEMORY[0x263EF8348];
  while (1)
  {
    unint64_t v13 = 4096 - (a2 & 0xFFF) >= v8 ? v8 : 4096 - (a2 & 0xFFF);
    uint64_t v14 = *(unsigned int *)(v11 + 4 * (a2 >> 12));
    if (v14 == -1) {
      break;
    }
    uint64_t v15 = *(void *)(a1 + 40);
    unint64_t v16 = *(void *)(v15 + 8 * v14) - v13;
    *(void *)(v15 + 8 * v14) = v16;
    if (!v16)
    {
      if (*(int *)(a1 + 128) >= 3)
      {
        fprintf(*v12, "PagedFile: input page %u removed from storage\n", a2 >> 12);
        uint64_t v11 = *(void *)(a1 + 48);
      }
      *(_DWORD *)(*(void *)(a1 + 56) + 4 * v14) = -1;
      *(_DWORD *)(v11 + 4 * (a2 >> 12)) = -1;
    }
    a2 += v13;
    v8 -= v13;
    if (!v8) {
      return 0;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileReleaseIn", 525, 21, 0, "input page is not stored", a7, a8, v18);
  return 0xFFFFFFFFLL;
}

uint64_t PagedFileRetainOut(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    return 0;
  }
  unint64_t v8 = a3;
  unint64_t v9 = a2;
  uint64_t v11 = *(void *)(a1 + 64);
  uint64_t v12 = (FILE **)MEMORY[0x263EF8348];
  while (1)
  {
    unint64_t v13 = v9 >> 12;
    if (4096 - (v9 & 0xFFF) >= v8) {
      uint64_t v14 = v8;
    }
    else {
      uint64_t v14 = 4096 - (v9 & 0xFFF);
    }
    uint64_t v15 = *(unsigned int *)(v11 + 4 * v13);
    if (v15 != -1) {
      goto LABEL_11;
    }
    FreeCacheuint64_t Pos = getFreeCachePos(a1, a2, a3, a4, a5, a6, a7, a8);
    if (FreeCachePos == -1) {
      break;
    }
    unsigned int v17 = FreeCachePos;
    if (*(int *)(a1 + 128) >= 3) {
      fprintf(*v12, "PagedFile: assigning cache[%u] to new output page %u\n", FreeCachePos, v9 >> 12);
    }
    uint64_t v15 = v17;
    uint64_t v11 = *(void *)(a1 + 64);
    *(_DWORD *)(*(void *)(a1 + 72) + 4 * v17) = v13;
    *(_DWORD *)(v11 + 4 * (v9 >> 12)) = v17;
LABEL_11:
    *(void *)(*(void *)(a1 + 40) + 8 * v15) += v14;
    v9 += v14;
    v8 -= v14;
    if (!v8) {
      return 0;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileRetainOut", 555, 21, 0, "no storage available for output page", a7, a8, v19);
  return 0xFFFFFFFFLL;
}

uint64_t getFreeCachePos(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned int *)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(a1 + 32);
  if (v8 >= v9)
  {
LABEL_13:
    uint64_t v14 = "no cache";
    __int16 v15 = 231;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"getFreeCachePos", v15, 21, 0, v14, a7, a8, v17);
    return 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v12 = v8 - v9;
    uint64_t v13 = 0xFFFFFFFFLL;
    do
    {
      if (!*(void *)(*(void *)(a1 + 40) + 8 * v8 + 8 * v11)) {
        return (v8 + v11);
      }
      if (v13 == -1
        || *(_DWORD *)(*(void *)(a1 + 96) + 4 * v11) < *(_DWORD *)(*(void *)(a1 + 96)
                                                                   + 4 * (v13 - v8)))
      {
        uint64_t v13 = (v8 + v11);
      }
      ++v11;
    }
    while (v12 + v11);
    if (v13 == -1) {
      goto LABEL_13;
    }
    if (*(int *)(a1 + 128) >= 3) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "PagedFile: storing oldest cache[%u] to file\n", v13);
    }
    if (storeCachePos(a1, v13, a3, a4, a5, a6, a7, a8))
    {
      uint64_t v14 = "flushing cache pos";
      __int16 v15 = 235;
      goto LABEL_14;
    }
  }
  return v13;
}

uint64_t PagedFileReleaseAllIn(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return PagedFileReleaseIn(a1, 0, *(void *)(a1 + 8), a4, a5, a6, a7, a8);
}

BOOL PagedFileHasNoIn(uint64_t a1)
{
  unint64_t v1 = *(unsigned int *)(a1 + 32);
  if (v1)
  {
    uint64_t v2 = 0;
    BOOL v3 = 0;
    do
    {
      if (*(_DWORD *)(*(void *)(a1 + 56) + 4 * v2) != -1 && *(void *)(*(void *)(a1 + 40) + 8 * v2)) {
        break;
      }
      BOOL v3 = ++v2 >= v1;
    }
    while (v1 != v2);
  }
  else
  {
    return 1;
  }
  return v3;
}

BOOL PagedFileHasAllOut(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = *(unsigned int *)(a1 + 32);
  if (v2)
  {
    unint64_t v3 = 0;
    uint64_t v4 = 0;
    while (1)
    {
      if (*(_DWORD *)(*(void *)(a1 + 72) + 4 * v3) != -1)
      {
        uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8 * v3);
        v4 += v5;
        if (v3 < (v1 >> 12) && v5 != 4096) {
          break;
        }
      }
      if (v2 == ++v3) {
        return v4 == v1;
      }
    }
    return 0;
  }
  else
  {
    uint64_t v4 = 0;
    return v4 == v1;
  }
}

uint64_t PagedFileReadAndReleaseIn(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    return 0;
  }
  uint64_t v8 = (char *)a4;
  unint64_t v9 = a3;
  while (1)
  {
    unint64_t v12 = a2 >> 12;
    if (4096 - (a2 & 0xFFF) >= v9) {
      size_t v13 = v9;
    }
    else {
      size_t v13 = 4096 - (a2 & 0xFFF);
    }
    unsigned int v14 = *(_DWORD *)(a1 + 24);
    if (v14 <= v12)
    {
      uint64_t v31 = "invalid input PAGE";
      __int16 v32 = 252;
      goto LABEL_27;
    }
    uint64_t v15 = *(unsigned int *)(*(void *)(a1 + 48) + 4 * v12);
    if (v15 == -1)
    {
      uint64_t v31 = "input page is not stored";
      __int16 v32 = 254;
      goto LABEL_27;
    }
    uint64_t v16 = (a2 >> 12);
    if (v15 >= v14)
    {
      uint64_t v18 = 0xFFFFFFFFLL;
    }
    else
    {
      FreeCacheuint64_t Pos = getFreeCachePos(a1, v15, a3, a4, a5, a6, a7, a8);
      if (FreeCachePos == -1)
      {
        uint64_t v31 = "could not get a free pos from cache";
        __int16 v32 = 261;
        goto LABEL_27;
      }
      uint64_t v18 = FreeCachePos;
      LODWORD(v15) = *(_DWORD *)(*(void *)(a1 + 48) + 4 * v16);
      unsigned int v14 = *(_DWORD *)(a1 + 24);
    }
    if (v15 < v14) {
      break;
    }
LABEL_15:
    BOOL v19 = v15 >= v14;
    unsigned int v20 = v15 - v14;
    if (!v19 || v15 >= *(_DWORD *)(a1 + 32))
    {
      uint64_t v31 = "could not move input page in cache";
      __int16 v32 = 273;
      goto LABEL_27;
    }
    int v21 = *(_DWORD *)(a1 + 104);
    *(_DWORD *)(a1 + 104) = v21 + 1;
    *(_DWORD *)(*(void *)(a1 + 96) + 4 * v20) = v21;
    uint64_t v22 = cacheData(a1, v15, v18, a4, a5, a6, a7, a8);
    if (!v22) {
      goto LABEL_28;
    }
    memcpy(v8, (const void *)(v22 + (a2 & 0xFFF)), v13);
    PagedFileReleaseIn(a1, a2, v13, v25, v26, v27, v28, v29);
    a2 += v13;
    v8 += v13;
    v9 -= v13;
    if (!v9) {
      return 0;
    }
  }
  if (!movePage(a1, v15, v18, a4, a5, a6, a7, a8))
  {
    LODWORD(v15) = *(_DWORD *)(*(void *)(a1 + 48) + 4 * v16);
    unsigned int v14 = *(_DWORD *)(a1 + 24);
    goto LABEL_15;
  }
  uint64_t v31 = "moving page from disk to cache";
  __int16 v32 = 268;
LABEL_27:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"inputPageData", v32, 21, 0, v31, a7, a8, v33);
LABEL_28:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileReadAndReleaseIn", 615, 21, 0, "unable to load input page", v23, v24, v33);
  return 0xFFFFFFFFLL;
}

uint64_t PagedFileRetainAndWriteOut(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    return 0;
  }
  uint64_t v8 = (char *)a4;
  unint64_t v9 = a3;
  while (1)
  {
    if (4096 - (a2 & 0xFFF) >= v9) {
      uint64_t v12 = v9;
    }
    else {
      uint64_t v12 = 4096 - (a2 & 0xFFF);
    }
    if (PagedFileRetainOut(a1, a2, v12, a4, a5, a6, a7, a8))
    {
      uint64_t v31 = "retain output chunk";
      __int16 v32 = 639;
      goto LABEL_31;
    }
    unsigned int v19 = *(_DWORD *)(a1 + 24);
    if (v19 <= (a2 >> 12))
    {
      uint64_t v29 = "invalid output PAGE";
      __int16 v30 = 286;
      goto LABEL_29;
    }
    uint64_t v20 = *(unsigned int *)(*(void *)(a1 + 64) + 4 * (a2 >> 12));
    if (v20 == -1)
    {
      uint64_t v29 = "output page is not stored";
      __int16 v30 = 288;
      goto LABEL_29;
    }
    uint64_t v21 = (a2 >> 12);
    if (v20 >= v19)
    {
      uint64_t v23 = 0xFFFFFFFFLL;
    }
    else
    {
      FreeCacheuint64_t Pos = getFreeCachePos(a1, v20, v13, v14, v15, v16, v17, v18);
      if (FreeCachePos == -1)
      {
        uint64_t v29 = "could not get a free pos from cache";
        __int16 v30 = 294;
        goto LABEL_29;
      }
      uint64_t v23 = FreeCachePos;
      LODWORD(v20) = *(_DWORD *)(*(void *)(a1 + 64) + 4 * v21);
      unsigned int v19 = *(_DWORD *)(a1 + 24);
    }
    if (v20 < v19) {
      break;
    }
LABEL_16:
    BOOL v24 = v20 >= v19;
    unsigned int v25 = v20 - v19;
    if (!v24 || v20 >= *(_DWORD *)(a1 + 32))
    {
      uint64_t v29 = "could not move output page in cache";
      __int16 v30 = 305;
      goto LABEL_29;
    }
    int v26 = *(_DWORD *)(a1 + 104);
    *(_DWORD *)(a1 + 104) = v26 + 1;
    *(_DWORD *)(*(void *)(a1 + 96) + 4 * v25) = v26;
    uint64_t v27 = cacheData(a1, v20, v23, v14, v15, v16, v17, v18);
    if (!v27) {
      goto LABEL_30;
    }
    memcpy((void *)(v27 + (a2 & 0xFFF)), v8, v12);
    a2 += v12;
    v8 += v12;
    v9 -= v12;
    if (!v9) {
      return 0;
    }
  }
  if (!movePage(a1, v20, v23, v14, v15, v16, v17, v18))
  {
    LODWORD(v20) = *(_DWORD *)(*(void *)(a1 + 64) + 4 * v21);
    unsigned int v19 = *(_DWORD *)(a1 + 24);
    goto LABEL_16;
  }
  uint64_t v29 = "moving page from disk to cache";
  __int16 v30 = 301;
LABEL_29:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"outputPageData", v30, 21, 0, v29, v17, v18, v33);
LABEL_30:
  uint64_t v31 = "unable to load output page";
  __int16 v32 = 643;
LABEL_31:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileRetainAndWriteOut", v32, 21, 0, v31, v17, v18, v33);
  return 0xFFFFFFFFLL;
}

uint64_t storeCachePos(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned int *)(a1 + 24);
  if (v8 > a2 || *(_DWORD *)(a1 + 32) <= a2)
  {
    uint64_t v18 = "invalid cache POS";
    __int16 v19 = 165;
    goto LABEL_9;
  }
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = *(void *)(v11 + 8 * a2);
  if (!v12) {
    return 0;
  }
  uint64_t v13 = *(void *)(a1 + 56);
  uint64_t v14 = *(unsigned int *)(v13 + 4 * a2);
  if (v14 == -1)
  {
    uint64_t v20 = *(unsigned int *)(*(void *)(a1 + 72) + 4 * a2);
    if (v20 != -1)
    {
      if (*(void *)(v11 + 8 * v20))
      {
        int v21 = -(int)v8;
        uint64_t v22 = v8 - 1;
        do
        {
          if (v22 == -1) {
            goto LABEL_18;
          }
          uint64_t v23 = *(void *)(v11 + 8 * v22);
          ++v21;
          --v22;
        }
        while (v23);
        if (v21 == 1)
        {
LABEL_18:
          uint64_t v18 = "no free pages in file";
          __int16 v19 = 208;
          goto LABEL_9;
        }
        uint64_t v28 = -v21;
        if (*(int *)(a1 + 128) >= 3) {
          fwrite("PagedFile: vacating file pos\n", 0x1DuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
        }
        if (movePage(a1, v20, v28, a4, a5, a6, a7, a8))
        {
          uint64_t v18 = "vacating page in file";
          __int16 v19 = 210;
          goto LABEL_9;
        }
      }
      if (*(int *)(a1 + 128) >= 3) {
        fwrite("PagedFile: storing cached output page to file\n", 0x2EuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
      }
      uint64_t result = movePage(a1, a2, v20, a4, a5, a6, a7, a8);
      if (result)
      {
        uint64_t v18 = "moving output page from cache to disk";
        __int16 v19 = 213;
        goto LABEL_9;
      }
      return result;
    }
    uint64_t v18 = "nRefs inconsistency";
    __int16 v19 = 215;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"storeCachePos", v19, 21, 0, v18, a7, a8, v29);
    return 0xFFFFFFFFLL;
  }
  uint64_t v15 = *(unsigned int *)(*(void *)(a1 + 112) + 4 * v14);
  if (v15 == -1)
  {
    uint64_t v18 = "cached input page does not have a file position";
    __int16 v19 = 175;
    goto LABEL_9;
  }
  if (*(_DWORD *)(*(void *)(a1 + 120) + 4 * v15) == v14)
  {
    uint64_t result = 0;
    *(_DWORD *)(*(void *)(a1 + 48) + 4 * v14) = v15;
    *(void *)(v11 + 8 * v15) = v12;
    *(_DWORD *)(v13 + 4 * v15) = v14;
    uint64_t v17 = *(void *)(a1 + 72);
    *(_DWORD *)(v17 + 4 * v15) = -1;
    *(void *)(v11 + 8 * a2) = 0;
    *(_DWORD *)(v13 + 4 * a2) = -1;
    *(_DWORD *)(v17 + 4 * a2) = -1;
    return result;
  }
  int v24 = -(int)v8;
  uint64_t v25 = v8 - 1;
  do
  {
    if (v25 == -1) {
      goto LABEL_24;
    }
    uint64_t v26 = *(void *)(v11 + 8 * v25);
    ++v24;
    --v25;
  }
  while (v26);
  if (v24 == 1)
  {
LABEL_24:
    uint64_t v18 = "no free pages in file";
    __int16 v19 = 196;
    goto LABEL_9;
  }
  uint64_t v27 = -v24;
  if (*(int *)(a1 + 128) >= 3) {
    fwrite("PagedFile: storing cached input page to file\n", 0x2DuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  uint64_t result = movePage(a1, a2, v27, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v18 = "moving input page from cache to disk";
    __int16 v19 = 198;
    goto LABEL_9;
  }
  return result;
}

uint64_t movePage(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)(a1 + 32);
  if (v8 <= a2 || v8 <= a3)
  {
    uint64_t v10 = "invalid SRC/DST";
    __int16 v11 = 77;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"movePage", v11, 21, 0, v10, a7, a8, v39);
    return 0xFFFFFFFFLL;
  }
  uint64_t v14 = *(void *)(a1 + 40);
  if (!*(void *)(v14 + 8 * a2))
  {
    uint64_t v10 = "SRC is empty";
    __int16 v11 = 78;
    goto LABEL_10;
  }
  unsigned int v15 = a3;
  if (*(void *)(v14 + 8 * a3))
  {
    uint64_t v10 = "DST is not empty";
    __int16 v11 = 79;
    goto LABEL_10;
  }
  unsigned int v17 = *(_DWORD *)(a1 + 24);
  if (v17 > a2 && v17 > a3)
  {
    uint64_t v22 = *(unsigned int *)(*(void *)(a1 + 56) + 4 * a2);
    if (v22 != -1) {
      *(_DWORD *)(*(void *)(a1 + 112) + 4 * v22) = a3;
    }
    *(_DWORD *)(*(void *)(a1 + 120) + 4 * a3) = v22;
    if (*(int *)(a1 + 128) >= 3) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "PagedFile: moving page from file[%u] to file[%u]\n", a2, a3);
    }
    if (pread(*(_DWORD *)a1, *(void **)(a1 + 80), 0x1000uLL, a2 << 12) != 4096)
    {
      uint64_t v10 = "reading page";
      __int16 v11 = 93;
      goto LABEL_10;
    }
    if (pwrite(*(_DWORD *)a1, *(const void **)(a1 + 80), 0x1000uLL, v15 << 12) != 4096)
    {
      uint64_t v10 = "writing page";
      __int16 v11 = 94;
      goto LABEL_10;
    }
    *(int64x2_t *)(a1 + 136) = vaddq_s64(*(int64x2_t *)(a1 + 136), vdupq_n_s64(0x1000uLL));
  }
  else if (v17 > a2 || v17 <= a3)
  {
    if (v17 <= a2 || v17 > a3)
    {
      if (*(int *)(a1 + 128) >= 3) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "PagedFile: moving page from cache[%u] to cache[%u]\n", a2, a3);
      }
      uint64_t v26 = (void *)cacheData(a1, v15, a3, a4, a5, a6, a7, a8);
      char v33 = (const void *)cacheData(a1, a2, v27, v28, v29, v30, v31, v32);
      memcpy(v26, v33, 0x1000uLL);
    }
    else
    {
      uint64_t v23 = *(unsigned int *)(*(void *)(a1 + 56) + 4 * a2);
      if (v23 != -1) {
        *(_DWORD *)(*(void *)(a1 + 112) + 4 * v23) = a2;
      }
      *(_DWORD *)(*(void *)(a1 + 120) + 4 * a2) = v23;
      if (*(int *)(a1 + 128) >= 3) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "PagedFile: moving page from file[%u] to cache[%u]\n", a2, a3);
      }
      int v24 = *(_DWORD *)a1;
      uint64_t v25 = (void *)cacheData(a1, v15, a3, a4, a5, a6, a7, a8);
      if (pread(v24, v25, 0x1000uLL, a2 << 12) != 4096)
      {
        uint64_t v10 = "reading page";
        __int16 v11 = 121;
        goto LABEL_10;
      }
      *(void *)(a1 + 136) += 4096;
    }
  }
  else
  {
    uint64_t v19 = *(unsigned int *)(*(void *)(a1 + 56) + 4 * a2);
    if (v19 != -1) {
      *(_DWORD *)(*(void *)(a1 + 112) + 4 * v19) = a3;
    }
    *(_DWORD *)(*(void *)(a1 + 120) + 4 * a3) = v19;
    if (*(int *)(a1 + 128) >= 3) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "PagedFile: moving page from cache[%u] to file[%u]\n", a2, a3);
    }
    int v20 = *(_DWORD *)a1;
    int v21 = (const void *)cacheData(a1, a2, a3, a4, a5, a6, a7, a8);
    if (pwrite(v20, v21, 0x1000uLL, v15 << 12) != 4096)
    {
      uint64_t v10 = "writing page";
      __int16 v11 = 108;
      goto LABEL_10;
    }
    *(void *)(a1 + 144) += 4096;
  }
  uint64_t v34 = *(void *)(a1 + 40);
  *(void *)(v34 + 8 * v15) = *(void *)(v34 + 8 * a2);
  *(void *)(v34 + 8 * a2) = 0;
  uint64_t v35 = *(void *)(a1 + 56);
  uint64_t v36 = *(unsigned int *)(v35 + 4 * a2);
  *(_DWORD *)(v35 + 4 * v15) = v36;
  *(_DWORD *)(v35 + 4 * a2) = -1;
  if (v36 != -1) {
    *(_DWORD *)(*(void *)(a1 + 48) + 4 * v36) = v15;
  }
  uint64_t v37 = *(void *)(a1 + 72);
  uint64_t v38 = *(unsigned int *)(v37 + 4 * a2);
  *(_DWORD *)(v37 + 4 * v15) = v38;
  *(_DWORD *)(v37 + 4 * a2) = -1;
  uint64_t result = 0;
  if (v38 != -1) {
    *(_DWORD *)(*(void *)(a1 + 64) + 4 * v38) = v15;
  }
  return result;
}

uint64_t cacheData(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)(a1 + 24);
  BOOL v9 = a2 >= v8;
  unsigned int v10 = a2 - v8;
  if (v9 && *(_DWORD *)(a1 + 32) > a2) {
    return *(void *)(a1 + 88) + (v10 << 12);
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"cacheData", 66, 21, 0, "invalid cache pos", a7, a8, vars0);
  return 0;
}

_WORD *enterThreadErrorContext(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  pthread_key_t ErrorContextKey = getErrorContextKey();
  uint64_t result = pthread_getspecific(ErrorContextKey);
  if (result)
  {
    ++result[2];
  }
  else
  {
    __int16 v11 = calloc(1uLL, 0x2000uLL);
    if (v11)
    {
      v11[2] = 1;
      *((_DWORD *)v11 + 18) = 531890176;
      return (_WORD *)setThreadErrorContext(v11, v12, v13, v14, v15, v16, v17, v18, a9);
    }
    else
    {
      int v19 = *__error();
      return (_WORD *)pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThreadErrorContext", 76, 5, v19, "malloc", v20, v21, a9);
    }
  }
  return result;
}

size_t setThreadErrorContext(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  pthread_key_t ErrorContextKey = getErrorContextKey();
  size_t result = pthread_setspecific(ErrorContextKey, a1);
  if (result)
  {
    int v12 = *__error();
    return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"setThreadErrorContext", 65, 5, v12, "pthread_setspecific", v13, v14, a9);
  }
  return result;
}

uint64_t leaveThreadErrorContext(__CFError **a1, const __CFString **a2, int a3)
{
  userInfoValues[1] = *(void **)MEMORY[0x263EF8340];
  pthread_key_t ErrorContextKey = getErrorContextKey();
  unint64_t v7 = (unsigned __int16 *)pthread_getspecific(ErrorContextKey);
  if (v7)
  {
    uint64_t v15 = v7;
    unsigned __int16 v16 = v7[2] - 1;
    v7[2] = v16;
    if (!v16)
    {
      uint64_t v18 = v7[36];
      uint64_t v17 = *(unsigned int *)v7;
      if (!v7[36] && (v17 & 0x80000000) == 0)
      {
        if (!v7[3] || !a2 && !a3) {
          goto LABEL_46;
        }
        bzero(userInfoKeys, 0x400uLL);
        unint64_t v35 = 0;
        do
        {
          size_t v36 = strlen((const char *)userInfoKeys);
          if (v36 + 20 > 0x3FF) {
            break;
          }
          if (v36) {
            snprintf((char *)userInfoKeys + v36, 1024 - v36, ",0x%08x");
          }
          else {
            snprintf((char *)userInfoKeys, 0x400uLL, "Warnings:0x%08x");
          }
          ++v35;
        }
        while (v35 < v15[3]);
        CFStringRef v37 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x263EFFB08], (const char *)userInfoKeys, 0x600u);
        if (!v37) {
          goto LABEL_46;
        }
        CFStringRef v38 = v37;
        if (a2)
        {
          *a2 = v37;
          goto LABEL_46;
        }
        CFIndex v45 = CFStringGetLength(v37) + 1;
        unsigned int v46 = (char *)calloc(1uLL, v45);
        if (v46)
        {
          unint64_t v47 = v46;
          CFStringGetCString(v38, v46, v45, 0x600u);
          fprintf((FILE *)*MEMORY[0x263EF8348], "%s\n", v47);
          free(v47);
        }
        uint64_t v44 = v38;
LABEL_45:
        CFRelease(v44);
        goto LABEL_46;
      }
      if (!a1 && !a3) {
        goto LABEL_46;
      }
      size_t v19 = v18 + 32;
      uint64_t v20 = (char *)calloc(v18 + 32, 1uLL);
      if (!v20) {
        goto LABEL_46;
      }
      uint64_t v21 = v20;
      uint64_t v22 = v20;
      if ((v17 & 0x80000000) != 0)
      {
        snprintf(v20, v19, "Error 0x%08x\n", v17);
        uint64_t v22 = &v21[strlen(v21)];
      }
      unsigned int v23 = v15[36];
      if (v15[36])
      {
        unsigned int v24 = 0;
        do
        {
          uint64_t v25 = (unsigned __int16 *)((char *)v15 + v24 + 76);
          unsigned int v26 = *v25;
          unsigned int v27 = v26 + v24;
          if (v26 < 4 || v27 > v23) {
            break;
          }
          size_t v29 = v26 - 3;
          memcpy(v22, v25 + 1, v29);
          uint64_t v30 = &v22[v29];
          *uint64_t v30 = 10;
          uint64_t v22 = v30 + 1;
          unsigned int v24 = (unsigned __int16)v27;
          unsigned int v23 = v15[36];
        }
        while (v23 > (unsigned __int16)v27);
      }
      if (v22 > v21) {
        *(v22 - 1) = 0;
      }
      CFAllocatorRef v31 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      CFStringRef v32 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x263EFFB08], v21, 0x600u);
      if (!v32)
      {
        free(v21);
        goto LABEL_46;
      }
      CFStringRef v33 = v32;
      userInfoKeys[0] = *(void **)MEMORY[0x263EFFC70];
      userInfoValues[0] = (void *)v32;
      uint64_t v34 = CFErrorCreateWithUserInfoKeysAndValues(v31, @"com.apple.ParallelCompression", 1, (const void *const *)userInfoKeys, (const void *const *)userInfoValues, 1);
      CFRelease(v33);
      free(v21);
      if (v34)
      {
        if (!a1)
        {
          CFStringRef v39 = CFErrorCopyDescription(v34);
          if (v39)
          {
            CFStringRef v40 = v39;
            CFIndex v41 = CFStringGetLength(v39) + 1;
            uint64_t v42 = (char *)calloc(1uLL, v41);
            if (v42)
            {
              uint64_t v43 = v42;
              CFStringGetCString(v40, v42, v41, 0x600u);
              fprintf((FILE *)*MEMORY[0x263EF8348], "%s\n", v43);
              free(v43);
            }
            CFRelease(v40);
          }
          uint64_t v44 = v34;
          goto LABEL_45;
        }
        *a1 = v34;
      }
LABEL_46:
      setThreadErrorContext(0, v8, v9, v10, v11, v12, v13, v14, v49);
      free(v15);
      return v17;
    }
  }
  return 0;
}

size_t appendThreadErrorContextString(size_t result)
{
  if (result)
  {
    unint64_t v1 = (const void *)result;
    size_t result = strlen((const char *)result);
    if (result - 8193 >= 0xFFFFFFFFFFFFE000)
    {
      size_t v2 = result;
      pthread_key_t ErrorContextKey = getErrorContextKey();
      size_t result = (size_t)pthread_getspecific(ErrorContextKey);
      if (result)
      {
        size_t v4 = result;
        __int16 v5 = v2 + 3;
        uint64_t v6 = *(unsigned __int16 *)(result + 72);
        if (v6 + (unsigned __int16)(v2 + 3) <= *(unsigned __int16 *)(result + 74))
        {
          size_t v7 = result + v6;
          *(_WORD *)(v7 + 76) = v5;
          size_t v8 = v7 + 78;
          size_t result = (size_t)memcpy((void *)(v7 + 78), v1, v2);
          *(unsigned char *)(v8 + v2) = 0;
          *(_WORD *)(v4 + 72) += v5;
        }
      }
    }
  }
  return result;
}

_WORD *updateThreadErrorContextErrorCode(_WORD *result)
{
  if ((result & 0x80000000) != 0)
  {
    int v1 = (int)result;
    pthread_key_t ErrorContextKey = getErrorContextKey();
    size_t result = pthread_getspecific(ErrorContextKey);
    if (result)
    {
      if ((*(_DWORD *)result & 0x80000000) == 0)
      {
        *(_DWORD *)size_t result = v1;
        result[3] = 0;
      }
    }
  }
  return result;
}

_DWORD *updateThreadErrorContextWarningCode(_DWORD *result)
{
  if ((result & 0x80000000) != 0)
  {
    int v1 = (int)result;
    pthread_key_t ErrorContextKey = getErrorContextKey();
    size_t result = pthread_getspecific(ErrorContextKey);
    if (result)
    {
      if ((*result & 0x80000000) == 0)
      {
        uint64_t v3 = *((unsigned __int16 *)result + 3);
        if (v3 <= 0xF)
        {
          result[v3 + 2] = v1;
          *((_WORD *)result + 3) = v3 + 1;
        }
      }
    }
  }
  return result;
}

unsigned __int16 *saveThreadErrorContext(void *a1)
{
  pthread_key_t ErrorContextKey = getErrorContextKey();
  size_t result = (unsigned __int16 *)pthread_getspecific(ErrorContextKey);
  if (result)
  {
    size_t v4 = result;
    bzero(a1, 0x2000uLL);
    uint64_t v5 = v4[36];
    if (v5 <= 0x1FB4) {
      size_t v6 = v5 + 76;
    }
    else {
      size_t v6 = 0;
    }
    return (unsigned __int16 *)memcpy(a1, v4, v6);
  }
  return result;
}

unsigned __int16 *restoreThreadErrorContext(long long *a1)
{
  pthread_key_t ErrorContextKey = getErrorContextKey();
  size_t result = (unsigned __int16 *)pthread_getspecific(ErrorContextKey);
  if (result)
  {
    long long v4 = a1[1];
    long long v13 = *a1;
    long long v14 = v4;
    long long v5 = a1[3];
    long long v15 = a1[2];
    *(_OWORD *)unsigned __int16 v16 = v5;
    *(_OWORD *)&v16[12] = *(long long *)((char *)a1 + 60);
    if ((v13 & 0x80000000) == 0)
    {
      unsigned int v6 = WORD3(v13);
      if ((*(_DWORD *)result & 0x80000000) != 0 && WORD3(v13) <= 0xFu)
      {
        unsigned int v6 = WORD3(v13) + 1;
        *((_DWORD *)&v13 + WORD3(v13) + 2) = *(_DWORD *)result;
      }
      unint64_t v7 = result[3];
      if (result[3] && v6 <= 0xF)
      {
        unint64_t v8 = 0;
        do
        {
          int v9 = *(_DWORD *)&result[2 * v8 + 4];
          if (v8 >= v6 || *((_DWORD *)&v13 + v8 + 2) != v9)
          {
            uint64_t v10 = v6++;
            *((_DWORD *)&v13 + v10 + 2) = v9;
          }
          ++v8;
        }
        while (v8 < v7 && v6 < 0x10);
      }
      WORD3(v13) = v6;
    }
    long long v11 = *(_OWORD *)v16;
    *((_OWORD *)result + 2) = v15;
    *((_OWORD *)result + 3) = v11;
    *(_OWORD *)(result + 30) = *(_OWORD *)&v16[12];
    long long v12 = v14;
    *(_OWORD *)size_t result = v13;
    *((_OWORD *)result + 1) = v12;
    if (*(unsigned __int16 *)&v16[24] <= 0x1FB4uLL) {
      return (unsigned __int16 *)memcpy(result + 38, (char *)a1 + 76, *(unsigned __int16 *)&v16[24]);
    }
  }
  return result;
}

uint64_t createThread(pthread_t *a1, uint64_t a2, uint64_t a3, size_t a4)
{
  *(void *)__relative_priority = 0;
  unint64_t v8 = calloc(1uLL, 0x2000uLL);
  if (!v8)
  {
    size_t v19 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThread", 552, 5, *v19, "malloc", v20, v21, v36[0]);
    return -*__error();
  }
  int v9 = v8;
  uint64_t v10 = (pthread_attr_t *)calloc(1uLL, 0x40uLL);
  if (!v10)
  {
    uint64_t v22 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThread", 555, 5, *v22, "malloc", v23, v24, v36[0]);
    uint64_t v25 = __error();
    uint64_t v13 = -*v25;
    if (!*v25) {
      return v13;
    }
    goto LABEL_10;
  }
  long long v11 = v10;
  uint64_t v12 = pthread_attr_init(v10);
  if (v12)
  {
    uint64_t v13 = v12;
    int v14 = *__error();
    uint64_t v17 = "pthread_attr_init";
    __int16 v18 = 558;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThread", v18, 5, v14, v17, v15, v16, v36[0]);
    goto LABEL_6;
  }
  if (a4)
  {
    uint64_t v28 = pthread_attr_setstacksize(v11, a4);
    if (v28)
    {
      uint64_t v13 = v28;
      int v14 = *__error();
      uint64_t v17 = "pthread_attr_setstacksize";
      __int16 v18 = 564;
      goto LABEL_5;
    }
  }
  size_t v29 = pthread_self();
  uint64_t qos_class_np = pthread_get_qos_class_np(v29, (qos_class_t *)&__relative_priority[1], __relative_priority);
  if (qos_class_np)
  {
    uint64_t v13 = qos_class_np;
    int v14 = *__error();
    uint64_t v17 = "pthread_get_qos_class_np";
    __int16 v18 = 570;
    goto LABEL_5;
  }
  uint64_t v31 = pthread_attr_set_qos_class_np(v11, (qos_class_t)__relative_priority[1], __relative_priority[0]);
  if (v31)
  {
    uint64_t v13 = v31;
    int v14 = *__error();
    uint64_t v17 = "pthread_attr_set_qos_class_np";
    __int16 v18 = 572;
    goto LABEL_5;
  }
  v36[0] = MEMORY[0x263EF8330];
  v36[1] = 0x40000000;
  v36[2] = __createThread_block_invoke;
  v36[3] = &__block_descriptor_tmp;
  v36[4] = v9;
  dispatch_block_t v32 = dispatch_block_create(DISPATCH_BLOCK_ASSIGN_CURRENT, v36);
  v9[2] = v32;
  if (v32)
  {
    *int v9 = a2;
    v9[1] = a3;
    *((_DWORD *)v9 + 7) = 1;
    *((_DWORD *)v9 + 24) = 530317312;
    uint64_t v13 = pthread_create(a1, v11, (void *(__cdecl *)(void *))threadWrapperProc, v9);
    if (v13)
    {
      int v14 = *__error();
      uint64_t v17 = "pthread_create";
      __int16 v18 = 591;
      goto LABEL_5;
    }
  }
  else
  {
    CFStringRef v33 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThread", 578, 5, *v33, "dispatch_block_create", v34, v35, v36[0]);
    uint64_t v13 = -*__error();
  }
LABEL_6:
  pthread_attr_destroy(v11);
  free(v11);
  if (!v13) {
    return v13;
  }
LABEL_10:
  unsigned int v26 = (const void *)v9[2];
  if (v26) {
    _Block_release(v26);
  }
  free(v9);
  return v13;
}

uint64_t __createThread_block_invoke(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 32))(*(void *)(*(void *)(a1 + 32) + 8));
}

uint64_t threadWrapperProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  setThreadErrorContext((const void *)(a1 + 24), a2, a3, a4, a5, a6, a7, a8, v17);
  (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
  setThreadErrorContext(0, v9, v10, v11, v12, v13, v14, v15, v18);
  return a1;
}

uint64_t joinThread(_opaque_pthread_t *a1)
{
  unsigned int v27 = 0;
  uint64_t v1 = pthread_join(a1, &v27);
  if (v1)
  {
    uint64_t v4 = v1;
    long long v5 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"joinThread", 623, 5, *v5, "pthread_join", v6, v7, v26);
    unint64_t v8 = 0;
    goto LABEL_26;
  }
  unint64_t v8 = v27;
  if (*((_WORD *)v27 + 14) != 1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"joinThread", 627, 5, 0, "expected ref_count=1 for terminating thread", v2, v3, v26);
    uint64_t v4 = 0xFFFFFFFFLL;
    goto LABEL_26;
  }
  pthread_key_t ErrorContextKey = getErrorContextKey();
  uint64_t v10 = pthread_getspecific(ErrorContextKey);
  if (!v10) {
    goto LABEL_25;
  }
  uint64_t v11 = v10;
  int v12 = *v10;
  if ((*v10 & 0x80000000) == 0)
  {
    int v13 = v8[6];
    if (v13 < 0)
    {
      *uint64_t v10 = v13;
      int v12 = v13;
    }
  }
  unsigned int v14 = *((unsigned __int16 *)v8 + 48);
  if (!*((_WORD *)v8 + 48))
  {
LABEL_15:
    if (v12)
    {
      uint64_t v4 = 0;
      *((_WORD *)v11 + 3) = 0;
      goto LABEL_26;
    }
    if (*((_WORD *)v8 + 15))
    {
      unint64_t v19 = 0;
      uint64_t v20 = *((unsigned __int16 *)v11 + 3);
      LODWORD(v21) = 16 - v20;
      if (v20 <= 0x10) {
        uint64_t v21 = v21;
      }
      else {
        uint64_t v21 = 0;
      }
      uint64_t v22 = (uint64_t)&v11[v20 + 2];
      __int16 v23 = v20 + 1;
      do
      {
        if (v21 == v19) {
          break;
        }
        *(_DWORD *)(v22 + 4 * v19) = v8[v19 + 8];
        *((_WORD *)v11 + 3) = v23 + v19++;
      }
      while (v19 < *((unsigned __int16 *)v8 + 15));
    }
LABEL_25:
    uint64_t v4 = 0;
    goto LABEL_26;
  }
  unsigned int v15 = 0;
  while (1)
  {
    uint64_t v16 = (_WORD *)((char *)v8 + v15 + 100);
    uint64_t v4 = (unsigned __int16)*v16;
    if (!*v16) {
      break;
    }
    unsigned __int16 v17 = v15 + v4;
    if (v15 + v4 > v14) {
      goto LABEL_25;
    }
    uint64_t v18 = *((unsigned __int16 *)v11 + 36);
    if ((int)v18 + (int)v4 <= *((unsigned __int16 *)v11 + 37))
    {
      memcpy((char *)v11 + v18 + 76, v16, (unsigned __int16)*v16);
      *((_WORD *)v11 + 36) += v4;
      unsigned int v15 = v17;
      unsigned int v14 = *((unsigned __int16 *)v8 + 48);
      if (v14 > v17) {
        continue;
      }
    }
    int v12 = *v11;
    goto LABEL_15;
  }
LABEL_26:
  uint64_t v24 = (const void *)*((void *)v8 + 2);
  if (v24) {
    _Block_release(v24);
  }
  free(v8);
  return v4;
}

size_t ParallelCompressionUpdateError(_WORD *a1, size_t a2)
{
  updateThreadErrorContextErrorCode(a1);

  return appendThreadErrorContextString(a2);
}

uint64_t getErrorContextKey()
{
  if (pthread_once(&getErrorContextKey_errorContextOnce, (void (*)(void))createErrorContextKey))
  {
    uint64_t v0 = __error();
    pc_log_error("/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", "getErrorContextKey", 53, 5, *v0, "pthread_once");
  }
  return gErrorContextKey;
}

uint64_t createErrorContextKey()
{
  uint64_t result = pthread_key_create((pthread_key_t *)&gErrorContextKey, 0);
  if (result)
  {
    uint64_t v1 = *__error();
    return pc_log_error("/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", "createErrorContextKey", 42, 5, v1, "pthread_key_create");
  }
  return result;
}

size_t PCompressLZMA6Encode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_encode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZMA);
  if (!result) {
    return -1;
  }
  return result;
}

size_t PCompressLZMADecode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_decode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZMA);
  if (!result) {
    return -1;
  }
  return result;
}

uint64_t PCompressZLIB5Encode(uint64_t a1, unint64_t a2, const uint8_t *a3, size_t a4)
{
  BOOL v4 = a2 >= 2;
  size_t v5 = a2 - 2;
  if (!v4) {
    return -1;
  }
  *(_WORD *)a1 = 24184;
  size_t v7 = compression_encode_buffer((uint8_t *)(a1 + 2), v5, a3, a4, 0, COMPRESSION_ZLIB);
  if (v7) {
    return v7 + 2;
  }
  else {
    return -1;
  }
}

size_t PCompressZLIBDecode(uint8_t *a1, size_t a2, uint64_t a3, unint64_t a4)
{
  BOOL v4 = a4 >= 2;
  size_t v5 = a4 - 2;
  if (!v4) {
    return -1;
  }
  size_t result = compression_decode_buffer(a1, a2, (const uint8_t *)(a3 + 2), v5, 0, COMPRESSION_ZLIB);
  if (!result) {
    return -1;
  }
  return result;
}

uint64_t load_variants(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = (const char **)(a2 + 16);
  size_t v7 = (FILE **)MEMORY[0x263EF8348];
  while (1)
  {
    unint64_t v8 = v6;
    if (v4) {
      unint64_t v8 = (const char **)(*(void *)(a2 + 8) + 8 * v4 - 8);
    }
    uint64_t v9 = rawimg_create_with_path(*v8);
    *(void *)(a1 + 8 * v4) = v9;
    if (!v9)
    {
      uint64_t v22 = "rawimg_create_with_file";
      __int16 v23 = 37;
      goto LABEL_26;
    }
    if ((rawimg_get_digests((uint64_t)v9, *(_DWORD *)(a2 + 36), 0, 0) & 0x80000000) != 0) {
      break;
    }
    int v12 = *(uint64_t **)(a1 + 8 * v4);
    if (v4 < 2)
    {
LABEL_19:
      *(void *)(a1 + 8 * v5++) = v12;
    }
    else
    {
      uint64_t v13 = 1;
      while (1)
      {
        unsigned int v14 = *(void **)(a1 + 8 * v13);
        uint64_t v15 = v14[261];
        uint64_t v16 = v14[262];
        uint64_t v17 = v14[263];
        uint64_t v18 = v14[264];
        BOOL v19 = v12[261] == v15 && v12[262] == v16;
        BOOL v20 = v19 && v12[263] == v17;
        if (v20 && v12[264] == v18) {
          break;
        }
        if (v4 == ++v13) {
          goto LABEL_19;
        }
      }
      rawimg_destroy(v12);
      if (*(_DWORD *)(a2 + 40)) {
        fprintf(*v7, "ImageDiff: Removed non-unique input variant <%s>.\n", *(const char **)(*(void *)(a1 + 8 * v4) + 2048));
      }
    }
    if (++v4 > *(void *)a2) {
      return v5;
    }
  }
  uint64_t v22 = "rawimg_get_digests";
  __int16 v23 = 38;
LABEL_26:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"load_variants", v23, 134, 0, v22, v10, v11, v25);
  return 0;
}

uint64_t patch_write_controls(AAByteStream_impl *a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  off_t v8 = AAByteStreamSeek(a1, 0, 1);
  *(void *)(a3 + 38) = v8;
  if (v8 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_controls", 331, 134, 0, "AAByteStreamSeek", v9, v10, v33);
    uint64_t v20 = 0;
    uint64_t v16 = 0;
  }
  else
  {
    uint64_t v11 = *(unsigned int *)(a4 + 40);
    if (v11 <= 3) {
      AAFlagSet v12 = v11 << 62;
    }
    else {
      AAFlagSet v12 = 0xC000000000000000;
    }
    AAByteStream v13 = AACompressionOutputStreamOpen(a1, 0x306u, 0x100000uLL, v12, *(_DWORD *)(a4 + 36));
    uint64_t v16 = v13;
    if (v13)
    {
      unint64_t v17 = a2[2];
      if (v17 < 2)
      {
        unint64_t v21 = a2[3];
        uint64_t v18 = (uint64_t *)(v21 + 56);
        BOOL v19 = (uint64_t *)(v21 + 40);
      }
      else
      {
        uint64_t v18 = (uint64_t *)(a2 + 11);
        BOOL v19 = (uint64_t *)(a2 + 9);
      }
      uint64_t v22 = *v18;
      *(void *)(a3 + 18) = v22;
      uint64_t v20 = *v19;
      if (*((void *)v13 + 3))
      {
        uint64_t v23 = 8 * v17 + 16;
        uint64_t v24 = v23 * v22;
        if (!(v23 * v22)) {
          goto LABEL_19;
        }
        uint64_t v25 = 0;
        uint64_t v26 = *v19;
        uint64_t v27 = v23 * v22;
        while (1)
        {
          uint64_t v28 = (*((uint64_t (**)(void, uint64_t, uint64_t))v16 + 3))(*(void *)v16, v26, v27);
          if (v28 < 1) {
            break;
          }
          v26 += v28;
          v25 += v28;
          v27 -= v28;
          if (!v27) {
            goto LABEL_18;
          }
        }
        uint64_t v25 = v28;
LABEL_18:
        if (v24 == v25)
        {
LABEL_19:
          int v29 = 0;
          goto LABEL_22;
        }
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_controls", 350, 134, 0, "aaByteStreamWriteExpected", v14, v15, v33);
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_controls", 335, 134, 0, "AACompressionOutputStreamOpen", v14, v15, v33);
      uint64_t v20 = 0;
    }
  }
  int v29 = 1;
LABEL_22:
  if (AAByteStreamClose(v16) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_controls", 353, 134, 0, "AAByteStreamClose", v30, v31, v33);
  }
  else if (!v29)
  {
    return v20;
  }
  return 0;
}

uint64_t RawImageDiff(uint64_t a1)
{
  uint64_t v326 = *MEMORY[0x263EF8340];
  long long v324 = 0u;
  long long v325 = 0u;
  long long v322 = 0u;
  long long v323 = 0u;
  long long v320 = 0u;
  long long v321 = 0u;
  long long v319 = 0u;
  if (!*(_DWORD *)(a1 + 36)) {
    *(_DWORD *)(a1 + 36) = getDefaultNThreads();
  }
  if (*(_DWORD *)(a1 + 40))
  {
    uint64_t v2 = (FILE **)MEMORY[0x263EF8348];
    fwrite("ImageDiff\n", 0xAuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    unint64_t v3 = *(void *)a1;
    if (*(void *)a1)
    {
      unint64_t v4 = 0;
      do
      {
        uint64_t v5 = *(const char **)(*(void *)(a1 + 8) + 8 * v4);
        if (v5)
        {
          fprintf(*v2, "  Input %zu: %s\n", v4, v5);
          unint64_t v3 = *(void *)a1;
        }
        ++v4;
      }
      while (v4 < v3);
    }
    if (*(void *)(a1 + 16)) {
      fprintf(*v2, "  Output: %s\n", *(const char **)(a1 + 16));
    }
    if (*(void *)(a1 + 24)) {
      fprintf(*v2, "  Patch: %s\n", *(const char **)(a1 + 24));
    }
    if (*(_DWORD *)(a1 + 32)) {
      uint64_t v6 = "yes";
    }
    else {
      uint64_t v6 = "no";
    }
    fprintf(*v2, "  In-place: %s\n", v6);
  }
  size_t v7 = *(void *)a1 + 1;
  if (v7 > 0x400000000)
  {
    *__error() = 12;
LABEL_95:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"RawImageDiff", 592, 134, 0, "aaCalloc", v8, v9, v282);
    uint64_t v104 = 0xFFFFFFFFLL;
    goto LABEL_117;
  }
  uint64_t v10 = (uint64_t *)calloc(v7, 8uLL);
  if (!v10) {
    goto LABEL_95;
  }
  uint64_t v11 = v10;
  unint64_t variants = load_variants((uint64_t)v10, a1);
  if (!variants)
  {
    int v105 = "load_variants";
    __int16 v106 = 596;
    goto LABEL_113;
  }
  *(void *)a1 = variants - 1;
  if ((rawimg_set_fork_types((uint64_t)v11, variants, v13, v14, v15, v16, v17, v18) & 0x80000000) != 0)
  {
    int v105 = "rawimg_set_fork_types";
    __int16 v106 = 600;
    goto LABEL_113;
  }
  unint64_t v19 = *(void *)a1;
  if ((*(void *)a1 & 0x80000000) == 0)
  {
    uint64_t v20 = *(void *)a1;
    do
    {
      rawimg_show(v11[v20], v20 == 0, *(_DWORD *)(a1 + 40));
      --v20;
    }
    while (v20 != -1);
    unint64_t v19 = *(void *)a1;
  }
  uint64_t v21 = *v11;
  uint64_t v22 = (void **)(*(void *)(*v11 + 2120) / 0x64uLL + 0x2000000);
  long long v319 = 0u;
  long long v320 = 0u;
  long long v321 = 0u;
  long long v322 = 0u;
  long long v323 = 0u;
  long long v324 = 0u;
  long long v325 = 0u;
  *(int32x2_t *)((char *)&v319 + 4) = vrev64_s32(*(int32x2_t *)(a1 + 36));
  *(void *)&long long v320 = v19;
  if (v19 <= 1) {
    unint64_t v23 = 1;
  }
  else {
    unint64_t v23 = v19;
  }
  if (!is_mul_ok(v23, 0x50uLL) || 80 * v23 >= 0x2000000001)
  {
    *__error() = 12;
    *((void *)&v320 + 1) = 0;
    goto LABEL_99;
  }
  uint64_t v24 = (char *)calloc(v23, 0x50uLL);
  *((void *)&v320 + 1) = v24;
  if (!v24)
  {
LABEL_99:
    int v107 = *__error();
    __int16 v110 = 205;
LABEL_100:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", v110, 134, v107, "aaCalloc", v108, v109, v282);
    CFIndex v45 = 0;
    CFStringRef v37 = 0;
    uint64_t v30 = 0;
LABEL_101:
    int8x16_t v63 = 0;
    int8x16_t v59 = 0;
    unint64_t v52 = 0;
    goto LABEL_102;
  }
  uint64_t v25 = v24;
  if (v19)
  {
    uint64_t v26 = v24 + 36;
    do
    {
      *uint64_t v26 = 1;
      v26 += 20;
      --v19;
    }
    while (v19);
  }
  if (!*(void *)a1)
  {
    uint64_t v250 = calloc(1uLL, 0x18uLL);
    *((void *)v25 + 5) = v250;
    if (v250)
    {
      CFIndex v45 = 0;
      uint64_t v30 = 0;
      int8x16_t v63 = 0;
      int8x16_t v59 = 0;
      unint64_t v52 = 0;
      uint64_t v251 = *(void *)(v21 + 2080);
      if (v251 < 0) {
        uint64_t v251 = 0x8000000000000000 - v251;
      }
      v250[1] = v251;
      int v111 = 1;
      *((void *)v25 + 7) = 1;
      CFStringRef v37 = 0;
      goto LABEL_103;
    }
    int v107 = *__error();
    __int16 v110 = 213;
    goto LABEL_100;
  }
  AAByteStream v27 = AAFileStreamOpenWithPath(*(const char **)(v21 + 2048), 0, 0);
  uint64_t v30 = v27;
  if (!v27)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 223, 134, 0, "AAFileStreamOpenWithPath", v28, v29, v282);
    CFIndex v45 = 0;
    CFStringRef v37 = 0;
    goto LABEL_101;
  }
  uint64_t v31 = aaSegmentStreamOpen(v27, (void *)v21);
  CFStringRef v37 = (AAByteStream_impl *)v31;
  if (!v31)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 225, 134, 0, "aaSegmentStreamOpen", v35, v36, v282);
    CFIndex v45 = 0;
    goto LABEL_101;
  }
  CFIndex v45 = aaForkInputStreamOpen(v31, v21, 0, v32, v33, v34, v35, v36);
  if (!v45)
  {
    uint64_t v252 = "aaForkInputStreamOpen";
    __int16 v253 = 227;
LABEL_290:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", v253, 134, 0, v252, v43, v44, v282);
    goto LABEL_101;
  }
  unint64_t v46 = 0;
  int64x2_t v303 = vdupq_n_s64(0x8000000000000000);
  pthread_mutex_t v311 = v37;
  AAByteStream v315 = (AAByteStream)v22;
  while (1)
  {
    if (v46 >= (unint64_t)v320)
    {
      if ((unint64_t)v320 < 2)
      {
        int8x16_t v63 = 0;
        int8x16_t v59 = 0;
        unint64_t v52 = 0;
        int v111 = 1;
      }
      else
      {
        if (bxdiff5CreateComboControls((uint64_t)&v319, v38, v39, v40, v41, v42, v43, v44))
        {
          uint64_t v252 = "bxdiff5CreateComboControls";
          __int16 v253 = 270;
          goto LABEL_290;
        }
        if ((controls_combo_enforce_copy_fork_boundary(*v11, &v319, v265, v266, v267, v268, v43, v44) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 272, 134, 0, "controls_combo_enforce_copy_fork_boundary", v280, v281, v282);
          int8x16_t v63 = 0;
          int8x16_t v59 = 0;
          unint64_t v52 = 0;
          int v111 = 0;
        }
        else
        {
          if (*(_DWORD *)(a1 + 40)) {
            fprintf((FILE *)*MEMORY[0x263EF8348], "ImageDiff: Constructed %zd combo controls.\n", *((size_t *)&v324 + 1));
          }
          int8x16_t v63 = 0;
          int8x16_t v59 = 0;
          unint64_t v52 = 0;
          int v111 = 1;
        }
        CFStringRef v37 = v311;
      }
      goto LABEL_103;
    }
    uint64_t v22 = (void **)v30;
    unint64_t v317 = v46;
    unint64_t v47 = v46 + 1;
    uint64_t v48 = v11[v46 + 1];
    AAByteStream v49 = AAFileStreamOpenWithPath(*(const char **)(v48 + 2048), 0, 0);
    unint64_t v52 = v49;
    if (!v49)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 236, 134, 0, "AAFileStreamOpenWithPath", v50, v51, v282);
      int8x16_t v63 = 0;
      int8x16_t v59 = 0;
LABEL_318:
      int v111 = 0;
      uint64_t v30 = (AAByteStream_impl *)v22;
      LODWORD(v22) = v315;
      goto LABEL_103;
    }
    unint64_t v53 = aaSegmentStreamOpen(v49, (void *)v48);
    int8x16_t v59 = (AAByteStream_impl *)v53;
    if (!v53)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 238, 134, 0, "aaSegmentStreamOpen", v57, v58, v282);
      int8x16_t v63 = 0;
      goto LABEL_318;
    }
    unint64_t v309 = v47;
    int8x16_t v60 = aaForkInputStreamOpen(v53, v48, 0, v54, v55, v56, v57, v58);
    int8x16_t v63 = (AAByteStream_impl *)v60;
    if (!v60)
    {
      uint64_t v269 = "aaForkInputStreamOpen";
      __int16 v270 = 240;
LABEL_317:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", v270, 134, 0, v269, v61, v62, v282);
      goto LABEL_318;
    }
    unsigned int v313 = (unsigned char *)v48;
    if ((GetLargeFileControlsWithStreams((uint64_t)v60, *(void *)(v48 + 2072), (unint64_t)v45, *(void *)(v21 + 2072), (void **)(*((void *)&v320 + 1) + 80 * v317 + 40), (uint64_t *)(*((void *)&v320 + 1) + 80 * v317 + 56), (uint64_t *)&v319) & 0x80000000) != 0)
    {
      uint64_t v269 = "GetLargeFileControlsWithStreams";
      __int16 v270 = 246;
      goto LABEL_317;
    }
    uint64_t v64 = *(void *)(v21 + 2160);
    uint64_t v30 = (AAByteStream_impl *)v22;
    uint64_t v22 = (void **)v315;
    if (v64)
    {
      uint64_t v65 = *((void *)&v320 + 1) + 80 * v317;
      AAByteStream v307 = (AAByteStream)(v65 + 56);
      uint64_t v66 = *(void *)(v65 + 56);
      if (!v66)
      {
        uint64_t v256 = "empty controls";
        __int16 v257 = 124;
LABEL_293:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_append_copy_forks", v257, 134, 0, v256, v61, v62, v282);
        goto LABEL_294;
      }
      if ((*(unsigned char *)(v21 + 2128) & 0x10) == 0 || (v313[2128] & 0x10) == 0)
      {
        uint64_t v256 = "no digests found";
        __int16 v257 = 126;
        goto LABEL_293;
      }
      uint64_t v22 = (void **)(v65 + 40);
      size_t v67 = 24 * (v66 + v64);
      if (v67 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_332;
      }
      int v305 = *(_DWORD *)(a1 + 40);
      uint64_t v68 = *v22;
      uint64_t v69 = (uint64_t *)realloc(*v22, v67);
      if (!v69)
      {
        free(v68);
        CFStringRef v37 = v311;
LABEL_332:
        *uint64_t v22 = 0;
        int v276 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_append_copy_forks", 130, 134, *v276, "aaReallocf", v277, v278, v282);
        LODWORD(v22) = v315;
LABEL_294:
        uint64_t v258 = "controls_append_copy_forks";
        __int16 v259 = 250;
LABEL_295:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", v259, 134, 0, v258, v99, v100, v282);
        goto LABEL_102;
      }
      *uint64_t v22 = v69;
      uint64_t v70 = *(void *)v307;
      if (*(void *)v307)
      {
        uint64_t v71 = 0;
        long long v72 = v69 + 2;
        uint64_t v73 = *(void *)v307;
        uint64_t v22 = (void **)v315;
        CFStringRef v37 = v311;
        do
        {
          uint64_t v74 = *(v72 - 2);
          if (v74 < 0) {
            uint64_t v74 = 0x8000000000000000 - v74;
          }
          uint64_t v76 = *v72;
          v72 += 3;
          uint64_t v75 = v76;
          unint64_t v77 = 0x8000000000000000 - v76;
          if (v76 < 0) {
            uint64_t v75 = v77;
          }
          v71 += v74 + v75;
          --v73;
        }
        while (v73);
      }
      else
      {
        uint64_t v71 = 0;
        uint64_t v22 = (void **)v315;
        CFStringRef v37 = v311;
      }
      unint64_t v78 = *(void *)(v21 + 2160);
      if (v78)
      {
        unint64_t v79 = 0;
        uint64_t v80 = *(void *)(v21 + 2144);
        uint64_t v81 = (char *)(v69 - 1);
        do
        {
          uint64_t v82 = v80 + 440 * v79;
          if ((*(unsigned char *)(v82 + 408) & 2) != 0)
          {
            uint64_t v83 = *((void *)v313 + 270);
            if (!v83) {
              goto LABEL_292;
            }
            uint64_t v84 = *((void *)v313 + 268);
            uint64_t v85 = (void *)(v80 + 440 * v79);
            uint64_t v86 = v85 + 49;
            int v87 = v85 + 50;
            int v88 = v85 + 4;
            while (1)
            {
              if ((*(unsigned char *)(v84 + 408) & 2) != 0 && *(void *)(v84 + 392) == *v86 && *(void *)(v84 + 400) == *v87)
              {
                uint64_t v89 = *(void *)(v84 + 32);
                if (v89 == *v88)
                {
                  uint64_t v61 = *(void *)(v82 + 8);
                  uint64_t v62 = *(void *)(v84 + 16);
                  BOOL v90 = *(void *)v84 == *(void *)v82 && *(void *)(v84 + 8) == v61;
                  BOOL v91 = v90 && v62 == *(void *)(v82 + 16);
                  uint64_t v22 = (void **)v315;
                  BOOL v92 = v91 && *(void *)(v84 + 24) == *(void *)(v82 + 24);
                  CFStringRef v37 = v311;
                  if (v92) {
                    break;
                  }
                }
              }
              v84 += 440;
              if (!--v83) {
                goto LABEL_292;
              }
            }
            uint64_t v93 = *(void *)(v84 + 48);
            if (v93 < 0)
            {
LABEL_292:
              uint64_t v256 = "copy fork not found";
              __int16 v257 = 161;
              goto LABEL_293;
            }
            uint64_t v94 = 3 * v70++;
            *(void *)AAByteStream v307 = v70;
            uint64_t v95 = (char *)&v69[v94];
            uint64_t v96 = 8 * v94;
            *((void *)v95 + 1) = 0;
            *((void *)v95 + 2) = 0;
            uint64_t v97 = *(void *)&v81[8 * v94];
            if (v97 < 0) {
              uint64_t v97 = 0x8000000000000000 - v97;
            }
            v98.i64[0] = v97 + v93 - v71;
            v98.i64[1] = v89;
            *(int8x16_t *)&v81[v96] = vbslq_s8((int8x16_t)vcltzq_s64(v98), (int8x16_t)vsubq_s64(v303, v98), (int8x16_t)v98);
            uint64_t v71 = v93 + v89;
            unint64_t v78 = *(void *)(v21 + 2160);
          }
          ++v79;
        }
        while (v79 < v78);
      }
      if (v305 >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "ImageDiff: Processed copy forks: %zd controls\n", v70);
      }
    }
    if ((*(unsigned char *)(a1 + 32) & 1) != 0
      && (rawimg_force_in_place((void *)(*((void *)&v320 + 1) + 80 * v317 + 40), (unint64_t *)(*((void *)&v320 + 1) + 80 * v317 + 56), v313, v21, (uint64_t)v22, *(_DWORD *)(a1 + 40)) & 0x80000000) != 0)
    {
      uint64_t v258 = "rawimg_force_in_place";
      __int16 v259 = 258;
      goto LABEL_295;
    }
    if (AAByteStreamClose(v63) < 0)
    {
      uint64_t v258 = "AAByteStreamClose";
      __int16 v259 = 262;
      goto LABEL_295;
    }
    if (AAByteStreamClose(v59) < 0) {
      break;
    }
    int v103 = AAByteStreamClose(v52);
    unint64_t v46 = v309;
    if (v103 < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 264, 134, 0, "AAByteStreamClose", v43, v44, v282);
      int8x16_t v63 = 0;
      int8x16_t v59 = 0;
      goto LABEL_102;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 263, 134, 0, "AAByteStreamClose", v101, v102, v282);
  int8x16_t v63 = 0;
LABEL_102:
  int v111 = 0;
LABEL_103:
  if (AAByteStreamClose((AAByteStream)v45) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 280, 134, 0, "AAByteStreamClose", v112, v113, v282);
    int v111 = 0;
  }
  if (AAByteStreamClose(v37) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 281, 134, 0, "AAByteStreamClose", v114, v115, v282);
    if ((AAByteStreamClose(v30) & 0x80000000) == 0) {
      goto LABEL_112;
    }
LABEL_111:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 282, 134, 0, "AAByteStreamClose", v116, v117, v282);
    goto LABEL_112;
  }
  if (AAByteStreamClose(v30) < 0) {
    goto LABEL_111;
  }
  if (!v111)
  {
LABEL_112:
    AAByteStreamClose(v63);
    AAByteStreamClose(v59);
    AAByteStreamClose(v52);
    BXDiff5Data_free((uint64_t)&v319);
    int v105 = "controls_create_with_variants";
    __int16 v106 = 612;
    goto LABEL_113;
  }
  int v118 = (int)v22;
  unint64_t v119 = 8 * *(void *)a1 + 62;
  if (v119 >= 0x2000000001)
  {
    *__error() = 12;
    goto LABEL_281;
  }
  int v122 = *(_DWORD *)(a1 + 32);
  uint64_t v123 = (char *)calloc(1uLL, 8 * *(void *)a1 + 62);
  if (!v123)
  {
LABEL_281:
    int v247 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write", 515, 134, *v247, "aaCalloc", v248, v249, v282);
    uint64_t v124 = 0;
    uint64_t v129 = 0;
LABEL_303:
    int v262 = 1;
    goto LABEL_304;
  }
  uint64_t v124 = (uint64_t)v123;
  *(void *)uint64_t v123 = 0x3031464649444952;
  *((_WORD *)v123 + 4) = *(_WORD *)a1 + 1;
  *(void *)(v123 + 10) = v122 & 1;
  if (v122) {
    int v125 = v118;
  }
  else {
    int v125 = 0;
  }
  *(_DWORD *)(v123 + 26) = v125;
  *(void *)(v123 + 30) = v119;
  unint64_t v126 = AAFileStreamOpenWithPath(*(const char **)(a1 + 24), 1537, 0x1A4u);
  uint64_t v129 = v126;
  if (!v126)
  {
    unint64_t v254 = "AAFileStreamOpenWithPath";
    __int16 v255 = 526;
LABEL_302:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write", v255, 134, 0, v254, v127, v128, v282);
    goto LABEL_303;
  }
  if (AAByteStreamSeek(v126, v119, 0) < 0)
  {
    unint64_t v254 = "AAByteStreamSeek";
    __int16 v255 = 527;
    goto LABEL_302;
  }
  uint64_t v130 = *(unsigned int *)(a1 + 40);
  if (v130 <= 3) {
    AAFlagSet v131 = v130 << 62;
  }
  else {
    AAFlagSet v131 = 0xC000000000000000;
  }
  uint64_t v137 = AACompressionOutputStreamOpen(v129, 0x306u, 0x100000uLL, v131, *(_DWORD *)(a1 + 36));
  if (!v137)
  {
    BOOL v260 = "AACompressionOutputStreamOpen";
    __int16 v261 = 305;
    goto LABEL_299;
  }
  unint64_t v138 = 0;
  do
  {
    if ((rawimg_save_to_stream(v137, v11[v138], v138 == 0, v132, v133, v134, v135, v136) & 0x80000000) != 0)
    {
      BOOL v260 = "rawimg_save_to_stream";
      __int16 v261 = 311;
LABEL_299:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_metadata", v261, 134, 0, v260, v135, v136, v282);
      if ((AAByteStreamClose(v137) & 0x80000000) == 0)
      {
LABEL_301:
        unint64_t v254 = "patch_write_metadata";
        __int16 v255 = 530;
        goto LABEL_302;
      }
LABEL_300:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_metadata", 315, 134, 0, "AAByteStreamClose", v127, v128, v282);
      goto LABEL_301;
    }
    ++v138;
  }
  while (v138 <= *(void *)a1);
  if (AAByteStreamClose(v137) < 0) {
    goto LABEL_300;
  }
  uint64_t v139 = patch_write_controls(v129, (unint64_t *)&v319, v124, a1);
  if (!v139)
  {
    unint64_t v254 = "patch_write_controls";
    __int16 v255 = 534;
    goto LABEL_302;
  }
  uint64_t v292 = v139;
  uint64_t v140 = 0;
  do
  {
    uint64_t v141 = v11[v140];
    uint64_t v300 = *v11;
    off_t v142 = AAByteStreamSeek(v129, 0, 1);
    size_t v299 = (off_t *)(v124 + 46 + 8 * v140);
    *size_t v299 = v142;
    uint64_t v310 = v140;
    if (v142 < 0)
    {
      __int16 v160 = 383;
      uint64_t v161 = "AAByteStreamSeek";
LABEL_147:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", v160, 134, 0, v161, v143, v144, v282);
      pthread_cond_t v312 = 0;
      v314 = 0;
      uint64_t v318 = 0;
      v302 = 0;
      v304 = 0;
      size_t v316 = 0;
      v306 = 0;
      int v308 = 0;
      goto LABEL_148;
    }
    LODWORD(v145) = *(_DWORD *)(a1 + 40);
    if (v145 >= 3) {
      uint64_t v145 = 3;
    }
    else {
      uint64_t v145 = v145;
    }
    s = AACompressionOutputStreamOpen(v129, 0x306u, 0x100000uLL, v145 << 62, *(_DWORD *)(a1 + 36));
    if (!s)
    {
      __int16 v160 = 387;
      uint64_t v161 = "AACompressionOutputStreamOpen";
      goto LABEL_147;
    }
    if (v140)
    {
      AAByteStream v146 = AAFileStreamOpenWithPath(*(const char **)(v141 + 2048), 0, 0);
      if (!v146)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 394, 134, 0, "AAFileStreamOpenWithPath", v147, v148, v282);
        pthread_cond_t v312 = 0;
        v314 = 0;
        uint64_t v318 = 0;
        v302 = 0;
        v304 = 0;
        size_t v316 = 0;
        v306 = 0;
        int v308 = 0;
        goto LABEL_254;
      }
      int v308 = v146;
      long long v149 = aaSegmentStreamOpen(v146, (void *)v141);
      if (!v149)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 396, 134, 0, "aaSegmentStreamOpen", v153, v154, v282);
        pthread_cond_t v312 = 0;
        v314 = 0;
        uint64_t v318 = 0;
        v302 = 0;
        v304 = 0;
        size_t v316 = 0;
        v306 = 0;
        goto LABEL_254;
      }
      v306 = (AAByteStream_impl *)v149;
      size_t v316 = (AAByteStream_impl *)aaForkInputStreamOpen(v149, v141, 0, v150, v151, v152, v153, v154);
      if (!v316)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 398, 134, 0, "aaForkInputStreamOpen", v155, v156, v282);
        pthread_cond_t v312 = 0;
        v314 = 0;
        uint64_t v318 = 0;
        v302 = 0;
        v304 = 0;
        size_t v316 = 0;
        goto LABEL_254;
      }
      pthread_cond_t v312 = malloc(0x10000uLL);
      if (!v312)
      {
        int v157 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 400, 134, *v157, "aaMalloc", v158, v159, v282);
        pthread_cond_t v312 = 0;
        v314 = 0;
        goto LABEL_235;
      }
    }
    else
    {
      pthread_cond_t v312 = 0;
      size_t v316 = 0;
      v306 = 0;
      int v308 = 0;
    }
    uint64_t v164 = v300;
    AAByteStream v165 = AAFileStreamOpenWithPath(*(const char **)(v300 + 2048), 0, 0);
    if (!v165)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 405, 134, 0, "AAFileStreamOpenWithPath", v166, v167, v282);
      v314 = 0;
LABEL_235:
      uint64_t v318 = 0;
      v302 = 0;
      v304 = 0;
LABEL_254:
      int v163 = 0;
      unint64_t v162 = s;
      goto LABEL_255;
    }
    v304 = v165;
    uint64_t v168 = aaSegmentStreamOpen(v165, (void *)v300);
    if (!v168)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 407, 134, 0, "aaSegmentStreamOpen", v172, v173, v282);
      v314 = 0;
      uint64_t v318 = 0;
      v302 = 0;
      goto LABEL_254;
    }
    v302 = (AAByteStream_impl *)v168;
    uint64_t v318 = aaForkInputStreamOpen(v168, v300, 0, v169, v170, v171, v172, v173);
    if (!v318)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 409, 134, 0, "aaForkInputStreamOpen", v174, v175, v282);
      v314 = 0;
      uint64_t v318 = 0;
      goto LABEL_254;
    }
    uint64_t v176 = malloc(0x10000uLL);
    if (!v176)
    {
      int v221 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 411, 134, *v221, "aaMalloc", v222, v223, v282);
      v314 = 0;
      goto LABEL_254;
    }
    v314 = v176;
    uint64_t v179 = v292;
    if (*(void *)(v124 + 18))
    {
      uint64_t v180 = 0;
      unint64_t v181 = 0;
      uint64_t v182 = 0;
      unint64_t v183 = 0;
      uint64_t v283 = v140 + 1;
      while (1)
      {
        unint64_t v289 = v183;
        v288 = (unint64_t *)(v179 + 8 * (v183 + v183 * *(unsigned __int16 *)(v124 + 8)));
        uint64_t v184 = v288[1];
        unint64_t v185 = 0x8000000000000000 - *v288;
        if ((*v288 & 0x8000000000000000) == 0) {
          unint64_t v185 = *v288;
        }
        unint64_t v186 = 0x8000000000000000 - v184;
        if (v184 >= 0) {
          unint64_t v186 = v288[1];
        }
        if (v140)
        {
          unint64_t v286 = v186;
          unint64_t v187 = *(void *)(v164 + 2072);
          if (v181 < v187 && v185 + v181 > v187)
          {
            __int16 v227 = 427;
            goto LABEL_246;
          }
          BOOL v188 = v181 >= v187;
          if (v181 >= v187) {
            unint64_t v189 = v185 + v181;
          }
          else {
            unint64_t v189 = v181;
          }
          if (v181 >= v187) {
            unint64_t v190 = v185;
          }
          else {
            unint64_t v190 = 0;
          }
          unint64_t v293 = v189;
          uint64_t v295 = v190 + v180;
          uint64_t v284 = v182;
          if (!v188 && v185)
          {
            unint64_t v191 = v185;
            unint64_t v290 = v185;
            while (1)
            {
              unint64_t v291 = v191;
              if (v191 >= 0x10000) {
                uint64_t v192 = 0x10000;
              }
              else {
                uint64_t v192 = v191;
              }
              if (!*((void *)v316 + 4)) {
                goto LABEL_248;
              }
              uint64_t v193 = 0;
              unint64_t v194 = v312;
              uint64_t v195 = v295;
              unint64_t v297 = v192;
              while (1)
              {
                uint64_t v196 = (*((uint64_t (**)(void, unsigned char *, uint64_t, uint64_t))v316 + 4))(*(void *)v316, v194, v192, v195);
                if (v196 < 0) {
                  break;
                }
                if (v196)
                {
                  v194 += v196;
                  v193 += v196;
                  v195 += v196;
                  v192 -= v196;
                  if (v192) {
                    continue;
                  }
                }
                goto LABEL_183;
              }
              uint64_t v193 = v196;
LABEL_183:
              unint64_t v197 = v297;
              if (v297 != v193)
              {
LABEL_248:
                __int16 v227 = 442;
                goto LABEL_251;
              }
              uint64_t v198 = v314;
              if (!v318[4]) {
                goto LABEL_250;
              }
              uint64_t v199 = 0;
              unint64_t v200 = v293;
              while (1)
              {
                uint64_t v201 = ((uint64_t (*)(uint64_t, unsigned char *, unint64_t, unint64_t))v318[4])(*v318, v198, v197, v200);
                if (v201 < 0) {
                  break;
                }
                if (v201)
                {
                  v198 += v201;
                  v199 += v201;
                  v200 += v201;
                  v197 -= v201;
                  if (v197) {
                    continue;
                  }
                }
                goto LABEL_191;
              }
              uint64_t v199 = v201;
LABEL_191:
              unint64_t v202 = v297;
              uint64_t v203 = v314;
              if (v297 != v199)
              {
LABEL_250:
                __int16 v227 = 443;
                goto LABEL_251;
              }
              uint64_t v204 = 0;
              uint64_t v205 = v297 <= 1 ? 1 : v297;
              do
              {
                v314[v204] -= v312[v204];
                ++v204;
              }
              while (v205 != v204);
              if (!*((void *)s + 3)) {
                break;
              }
              uint64_t v206 = 0;
              while (1)
              {
                uint64_t v207 = (*((uint64_t (**)(void, unsigned char *, unint64_t))s + 3))(*(void *)s, v203, v202);
                if (v207 < 1) {
                  break;
                }
                v203 += v207;
                v206 += v207;
                v202 -= v207;
                if (!v202) {
                  goto LABEL_202;
                }
              }
              uint64_t v206 = v207;
LABEL_202:
              uint64_t v176 = v314;
              if (v297 != v206) {
                break;
              }
              v295 += v297;
              v293 += v297;
              unint64_t v191 = v291 - v297;
              unint64_t v185 = v290;
              if (v291 == v297) {
                goto LABEL_204;
              }
            }
            __int16 v227 = 447;
            v228 = "aaByteStreamWriteExpected";
            goto LABEL_253;
          }
LABEL_204:
          uint64_t v182 = v284;
          uint64_t v208 = v288[v283];
          if (v208 < 0) {
            uint64_t v208 = 0x8000000000000000 - v208;
          }
          uint64_t v180 = v208 + v295;
          unint64_t v181 = v293 + v286;
          uint64_t v164 = v300;
        }
        else
        {
          v181 += v185;
          if (v186)
          {
            uint64_t v294 = v180;
            uint64_t v285 = v182;
            unint64_t v287 = v186;
            unint64_t v209 = v186;
            while (1)
            {
              uint64_t v210 = v209 >= 0x10000 ? 0x10000 : v209;
              if (!v318[4]) {
                break;
              }
              uint64_t v211 = 0;
              uint64_t v212 = v176;
              unint64_t v296 = v181;
              uint64_t v298 = v210;
              unint64_t v213 = v181;
              while (1)
              {
                uint64_t v214 = ((uint64_t (*)(uint64_t, char *, uint64_t, unint64_t))v318[4])(*v318, v212, v210, v213);
                if (v214 < 0) {
                  break;
                }
                if (v214)
                {
                  v212 += v214;
                  v211 += v214;
                  v213 += v214;
                  v210 -= v214;
                  if (v210) {
                    continue;
                  }
                }
                goto LABEL_219;
              }
              uint64_t v211 = v214;
LABEL_219:
              uint64_t v215 = v298;
              uint64_t v216 = v314;
              if (v298 != v211) {
                break;
              }
              unint64_t v217 = v209;
              unint64_t v162 = s;
              if (!*((void *)s + 3)) {
                goto LABEL_249;
              }
              uint64_t v218 = 0;
              while (1)
              {
                uint64_t v219 = (*((uint64_t (**)(void, unsigned char *, uint64_t))s + 3))(*(void *)s, v216, v215);
                if (v219 < 1) {
                  break;
                }
                v216 += v219;
                v218 += v219;
                v215 -= v219;
                if (!v215) {
                  goto LABEL_226;
                }
              }
              uint64_t v218 = v219;
LABEL_226:
              uint64_t v176 = v314;
              if (v298 != v218)
              {
LABEL_249:
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 467, 134, 0, "aaByteStreamWriteExpected", v177, v178, v282);
                goto LABEL_149;
              }
              unint64_t v181 = v298 + v296;
              unint64_t v209 = v217 - v298;
              if (v217 == v298)
              {
                uint64_t v182 = v285;
                unint64_t v185 = v287;
                uint64_t v140 = v310;
                uint64_t v164 = v300;
                unint64_t v220 = v289;
                uint64_t v180 = v294;
                goto LABEL_231;
              }
            }
            __int16 v227 = 466;
LABEL_251:
            v228 = "aaByteStreamPReadExpected";
            goto LABEL_253;
          }
          unint64_t v185 = 0;
        }
        unint64_t v220 = v289;
LABEL_231:
        v182 += v185;
        unint64_t v183 = v220 + 1;
        uint64_t v179 = v292;
        if (v183 >= *(void *)(v124 + 18)) {
          goto LABEL_242;
        }
      }
    }
    uint64_t v182 = 0;
    unint64_t v181 = 0;
LABEL_242:
    if (v181 != *(void *)(v164 + 2080))
    {
      __int16 v227 = 472;
LABEL_246:
      v228 = "bad controls";
LABEL_253:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", v227, 134, 0, v228, v177, v178, v282);
      goto LABEL_254;
    }
    uint64_t v224 = v182;
    if (AAByteStreamClose(s) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 475, 134, 0, "AAByteStreamClose", v225, v226, v282);
      int v163 = 0;
    }
    else
    {
      int v163 = 1;
    }
    off_t v243 = AAByteStreamSeek(v129, 0, 1);
    v299[1] = v243;
    if ((v243 & 0x8000000000000000) == 0)
    {
      if (*(int *)(a1 + 40) >= 2)
      {
        int v246 = "Diff";
        if (!v310) {
          int v246 = "Literal";
        }
        fprintf((FILE *)*MEMORY[0x263EF8348], "%s stream: %llu bytes -> %llu bytes\n", v246, v224, v243 - *v299);
      }
      unint64_t v162 = 0;
      goto LABEL_255;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 480, 134, 0, "AAByteStreamSeek", v244, v245, v282);
LABEL_148:
    unint64_t v162 = 0;
LABEL_149:
    int v163 = 0;
LABEL_255:
    if (AAByteStreamClose(v162) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 489, 134, 0, "AAByteStreamClose", v229, v230, v282);
      int v163 = 0;
    }
    if (AAByteStreamClose(v316) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 490, 134, 0, "AAByteStreamClose", v231, v232, v282);
      int v163 = 0;
    }
    if (AAByteStreamClose(v306) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 491, 134, 0, "AAByteStreamClose", v233, v234, v282);
      int v163 = 0;
    }
    if (AAByteStreamClose(v308) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 492, 134, 0, "AAByteStreamClose", v235, v236, v282);
      int v163 = 0;
    }
    if (AAByteStreamClose((AAByteStream)v318) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 493, 134, 0, "AAByteStreamClose", v237, v238, v282);
      int v163 = 0;
    }
    if (AAByteStreamClose(v302) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 494, 134, 0, "AAByteStreamClose", v239, v240, v282);
      int v163 = 0;
    }
    if (AAByteStreamClose(v304) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 495, 134, 0, "AAByteStreamClose", v241, v242, v282);
      int v163 = 0;
    }
    free(v312);
    free(v314);
    if (!v163)
    {
      unint64_t v254 = "patch_write_stream";
      __int16 v255 = 539;
      goto LABEL_302;
    }
    uint64_t v140 = v310 + 1;
  }
  while ((unint64_t)(v310 + 1) <= *(void *)a1);
  if (!*((void *)v129 + 5)) {
    goto LABEL_341;
  }
  uint64_t v271 = 0;
  uint64_t v272 = 0;
  uint64_t v273 = v124;
  unint64_t v274 = v119;
  while (1)
  {
    uint64_t v275 = (*((uint64_t (**)(void, uint64_t, unint64_t, uint64_t))v129 + 5))(*(void *)v129, v273, v274, v272);
    if (v275 < 1) {
      break;
    }
    v273 += v275;
    v271 += v275;
    v272 += v275;
    v274 -= v275;
    if (!v274) {
      goto LABEL_335;
    }
  }
  uint64_t v271 = v275;
LABEL_335:
  if (v119 != v271)
  {
LABEL_341:
    unint64_t v254 = "aaByteStreamPWriteExpected";
    __int16 v255 = 543;
    goto LABEL_302;
  }
  int v279 = *(_DWORD *)(a1 + 40);
  if (v279 > 1)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "  Metadata: %llu bytes\n  Controls: %llu bytes\n", *(void *)(v124 + 38) - *(void *)(v124 + 30), *(void *)(v124 + 46) - *(void *)(v124 + 38));
    int v279 = *(_DWORD *)(a1 + 40);
  }
  if (v279 >= 1) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12llu final patch size\n", *(void *)(v124 + 8 * *(unsigned __int16 *)(v124 + 8) + 46));
  }
  int v262 = 0;
LABEL_304:
  if (AAByteStreamClose(v129) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write", 562, 134, 0, "AAByteStreamClose", v263, v264, v282);
    free((void *)v124);
  }
  else
  {
    free((void *)v124);
    if (!v262)
    {
      uint64_t v104 = 0;
      goto LABEL_114;
    }
  }
  int v105 = "patch_write";
  __int16 v106 = 615;
LABEL_113:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"RawImageDiff", v106, 134, 0, v105, v17, v18, v282);
  uint64_t v104 = 0xFFFFFFFFLL;
LABEL_114:
  unint64_t v120 = 0;
  do
    rawimg_destroy((uint64_t *)v11[v120++]);
  while (v120 <= *(void *)a1);
  free(v11);
LABEL_117:
  BXDiff5Data_free((uint64_t)&v319);
  return v104;
}

double BXDiff5Data_free(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    if (*(void *)(a1 + 16))
    {
      unint64_t v3 = 0;
      uint64_t v4 = 40;
      do
      {
        free(*(void **)(*(void *)(a1 + 24) + v4));
        ++v3;
        v4 += 80;
      }
      while (v3 < *(void *)(a1 + 16));
      uint64_t v2 = *(void **)(a1 + 24);
    }
    free(v2);
  }
  free(*(void **)(a1 + 72));
  double result = 0.0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  return result;
}

uint64_t controls_combo_enforce_copy_fork_boundary(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1;
  unint64_t v9 = a2[11];
  if (v9)
  {
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v36 = a2[2];
    uint64_t v14 = v36 + 2;
    uint64_t v15 = 8 * (v36 + 2);
    if (v36 == 0 || v36 >= 0xFFFFFFFFFFFFFFFELL) {
      uint64_t v14 = 2;
    }
    uint64_t v35 = 8 * v14 - 8;
    uint64_t v16 = -1;
    while (1)
    {
      uint64_t v17 = (char *)a2[9];
      uint64_t v18 = *(void *)&v17[v11];
      if (v18 >= 0) {
        unint64_t v19 = *(void *)&v17[v11];
      }
      else {
        unint64_t v19 = 0x8000000000000000 - v18;
      }
      unint64_t v20 = *(void *)(v8 + 2072);
      unint64_t v21 = v19 + v13;
      uint64_t v22 = v20 - v13;
      if (v20 > v13 && v21 > v20)
      {
        unint64_t v25 = v9 + 1;
        a2[11] = v25;
        if (v15 * v25 >= 0x2000000001)
        {
          *__error() = 12;
          goto LABEL_32;
        }
        uint64_t v26 = (char *)realloc(v17, v15 * v25);
        if (!v26)
        {
          free(v17);
LABEL_32:
          a2[9] = 0;
          uint64_t v32 = "aaReallocf";
          __int16 v33 = 88;
LABEL_33:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_combo_enforce_copy_fork_boundary", v33, 134, 0, v32, a7, a8, v34);
          return 0xFFFFFFFFLL;
        }
        a2[9] = v26;
        AAByteStream v27 = (uint64_t *)&v26[v11];
        uint64_t v28 = (unint64_t *)&v26[v11 + v15];
        memmove(v28, &v26[v11], v15 * (v16 + a2[11]));
        uint64_t v29 = 0x8000000000000000 - v22;
        if (v22 >= 0) {
          uint64_t v29 = v22;
        }
        *AAByteStream v27 = v29;
        if (v36 <= 0xFFFFFFFFFFFFFFFDLL) {
          bzero(v27 + 1, v35);
        }
        unint64_t v30 = v19 - v22;
        if ((uint64_t)(v19 - v22) < 0) {
          unint64_t v30 = 0x8000000000000000 - (v19 - v22);
        }
        *uint64_t v28 = v30;
        unint64_t v9 = a2[11];
        unint64_t v13 = v20;
        uint64_t v8 = a1;
      }
      else
      {
        uint64_t v24 = *(void *)&v17[v11 + 8];
        if (v24 < 0) {
          uint64_t v24 = 0x8000000000000000 - v24;
        }
        unint64_t v13 = v21 + v24;
      }
      ++v12;
      v11 += v15;
      --v16;
      if (v12 >= v9) {
        goto LABEL_27;
      }
    }
  }
  unint64_t v13 = 0;
LABEL_27:
  if (v13 != *(void *)(v8 + 2080))
  {
    uint64_t v32 = "SIZE MISMATCH";
    __int16 v33 = 108;
    goto LABEL_33;
  }
  return 0;
}

char *SharedBufferCreate(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 - 0x100000000 > 0xFFFFFFFF00000000)
  {
    int v9 = getpagesize();
    if (v9 <= 0x197)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferCreate", 252, 73, 0, "Incompatible page size", v10, v11, v39);
      return 0;
    }
    uint64_t v14 = v9;
    if (a1 >> 2 < v9) {
      unint64_t v15 = 1;
    }
    else {
      unint64_t v15 = (a1 >> 2) / v9;
    }
    unint64_t v16 = v15 * v9;
    uint64_t v17 = (unsigned int *)valloc(v9 + 4 * v16);
    unint64_t v12 = v17;
    if (!v17)
    {
      uint64_t v24 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferCreate", 262, 73, *v24, "malloc", v25, v26, v39);
      return (char *)v12;
    }
    *((void *)v17 + 50) = 0;
    *((_OWORD *)v17 + 23) = 0u;
    *((_OWORD *)v17 + 24) = 0u;
    *((_OWORD *)v17 + 21) = 0u;
    *((_OWORD *)v17 + 22) = 0u;
    *((_OWORD *)v17 + 19) = 0u;
    *((_OWORD *)v17 + 20) = 0u;
    *((_OWORD *)v17 + 17) = 0u;
    *((_OWORD *)v17 + 18) = 0u;
    *((_OWORD *)v17 + 15) = 0u;
    *((_OWORD *)v17 + 16) = 0u;
    *((_OWORD *)v17 + 13) = 0u;
    *((_OWORD *)v17 + 14) = 0u;
    *((_OWORD *)v17 + 11) = 0u;
    *((_OWORD *)v17 + 12) = 0u;
    *((_OWORD *)v17 + 9) = 0u;
    *((_OWORD *)v17 + 10) = 0u;
    *((_OWORD *)v17 + 7) = 0u;
    *((_OWORD *)v17 + 8) = 0u;
    *((_OWORD *)v17 + 5) = 0u;
    *((_OWORD *)v17 + 6) = 0u;
    *((_OWORD *)v17 + 3) = 0u;
    *((_OWORD *)v17 + 4) = 0u;
    *((_OWORD *)v17 + 1) = 0u;
    *((_OWORD *)v17 + 2) = 0u;
    *(_OWORD *)uint64_t v17 = 0u;
    *((void *)v17 + 48) = -1;
    atomic_store(2u, v17 + 101);
    *(void *)uint64_t v17 = 0x600000000;
    uint64_t v18 = calloc(6uLL, 4uLL);
    *((void *)v12 + 1) = v18;
    if (v18)
    {
      if (pthread_mutex_init((pthread_mutex_t *)(v12 + 4), 0))
      {
        uint64_t v22 = "SharedArrayInit: pthread_mutex_init failed\n";
        __int16 v23 = 56;
      }
      else
      {
        if (!pthread_cond_init((pthread_cond_t *)(v12 + 20), 0))
        {
          *((void *)v12 + 16) = 0x600000000;
          uint64_t v31 = calloc(6uLL, 4uLL);
          *((void *)v12 + 17) = v31;
          if (v31)
          {
            if (pthread_mutex_init((pthread_mutex_t *)(v12 + 36), 0))
            {
              uint64_t v35 = "SharedArrayInit: pthread_mutex_init failed\n";
              __int16 v36 = 56;
            }
            else
            {
              if (!pthread_cond_init((pthread_cond_t *)(v12 + 52), 0))
              {
                uint64_t v37 = 0;
                for (unsigned int i = v12 + 68; ; i += 4)
                {
                  *unsigned int i = 0;
                  i[1] = 0;
                  *(i - 2) = (char *)v12 + v14;
                  *(i - 1) = v16;
                  if ((SharedArrayPush(v12 + 32, v37) & 0x80000000) != 0) {
                    break;
                  }
                  ++v37;
                  v14 += v16;
                  if (v37 == 4) {
                    return (char *)v12;
                  }
                }
                uint64_t v29 = "SharedArrayPush";
                __int16 v30 = 283;
                goto LABEL_19;
              }
              uint64_t v35 = "SharedArrayInit: pthread_cond_init failed\n";
              __int16 v36 = 57;
            }
          }
          else
          {
            uint64_t v35 = "SharedArrayInit: malloc failed\n";
            __int16 v36 = 55;
          }
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayInit", v36, 0, v35, v32, v33, v34, v39);
          uint64_t v29 = "SharedArrayInit";
          __int16 v30 = 270;
LABEL_19:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferCreate", v30, 73, 0, v29, v27, v28, v39);
          if (!pthread_mutex_destroy((pthread_mutex_t *)(v12 + 4))
            && !pthread_cond_destroy((pthread_cond_t *)(v12 + 20)))
          {
            free(*((void **)v12 + 1));
          }
          if (!pthread_mutex_destroy((pthread_mutex_t *)(v12 + 36))
            && !pthread_cond_destroy((pthread_cond_t *)(v12 + 52)))
          {
            free(*((void **)v12 + 17));
          }
          free(v12);
          return 0;
        }
        uint64_t v22 = "SharedArrayInit: pthread_cond_init failed\n";
        __int16 v23 = 57;
      }
    }
    else
    {
      uint64_t v22 = "SharedArrayInit: malloc failed\n";
      __int16 v23 = 55;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayInit", v23, 0, v22, v19, v20, v21, v39);
    uint64_t v29 = "SharedArrayInit";
    __int16 v30 = 269;
    goto LABEL_19;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferCreate", 247, 73, 0, "SharedBuffer invalid capacity: %zu", a7, a8, a1);
  return 0;
}

uint64_t SharedArrayPush(unsigned int *a1, int a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 4);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 4)))
  {
    uint64_t v8 = "SharedArrayPush: pthread_mutex_lock failed\n";
    __int16 v9 = 117;
  }
  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = a1[1];
    int v12 = v10;
    if (v10 < v11)
    {
      *(_DWORD *)(*((void *)a1 + 1) + 4 * v10) = a2;
      int v12 = *a1;
    }
    *a1 = v12 + 1;
    if (v12 || !pthread_cond_broadcast((pthread_cond_t *)(a1 + 20)))
    {
      if (pthread_mutex_unlock(v4))
      {
        uint64_t v8 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        __int16 v9 = 124;
      }
      else
      {
        if (v10 < v11) {
          return 0;
        }
        uint64_t v8 = "SharedArrayPush: stack is full\n";
        __int16 v9 = 125;
      }
    }
    else
    {
      uint64_t v8 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      __int16 v9 = 122;
    }
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPush", v9, 0, v8, v5, v6, v7, v14);
  return 0xFFFFFFFFLL;
}

void SharedBufferDestroy(uint64_t a1)
{
  if (a1)
  {
    if (!pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16)) && !pthread_cond_destroy((pthread_cond_t *)(a1 + 80))) {
      free(*(void **)(a1 + 8));
    }
    if (!pthread_mutex_destroy((pthread_mutex_t *)(a1 + 144)) && !pthread_cond_destroy((pthread_cond_t *)(a1 + 208))) {
      free(*(void **)(a1 + 136));
    }
    free((void *)a1);
  }
}

uint64_t SharedBufferFillFromStream(size_t a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    if (!atomic_load((unsigned int *)(a1 + 400)))
    {
      if (atomic_load((unsigned int *)(a1 + 392)))
      {
        unsigned int v11 = "write after EOF";
        __int16 v12 = 365;
LABEL_26:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferFillFromStream", v12, 73, 0, v11, a7, a8, v45);
      }
      else
      {
        unint64_t v14 = a2;
        uint64_t v15 = 0;
        size_t v16 = a1 + 256;
        while (1)
        {
          uint64_t v17 = *(unsigned int *)(a1 + 384);
          if (v17 <= 3)
          {
            uint64_t v22 = *(void *)(v16 + 32 * v17 + 24);
          }
          else
          {
            if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 144)))
            {
              uint64_t v42 = "SharedArrayPop: pthread_mutex_lock failed\n";
              __int16 v43 = 91;
LABEL_25:
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v43, 0, v42, v18, v19, v20, v45);
              unsigned int v11 = "SharedArrayPop";
              __int16 v12 = 378;
              goto LABEL_26;
            }
            while (1)
            {
              int v21 = *(_DWORD *)(a1 + 128);
              if (v21) {
                break;
              }
              if (pthread_cond_wait((pthread_cond_t *)(a1 + 208), (pthread_mutex_t *)(a1 + 144)))
              {
                uint64_t v42 = "SharedArrayPop: pthread_cond_wait failed\n";
                __int16 v43 = 94;
                goto LABEL_25;
              }
            }
            unsigned int v23 = v21 - 1;
            *(_DWORD *)(a1 + 128) = v23;
            uint64_t v17 = *(unsigned int *)(*(void *)(a1 + 136) + 4 * v23);
            if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 144)))
            {
              uint64_t v42 = "SharedArrayPop: pthread_mutex_unlock failed\n";
              __int16 v43 = 98;
              goto LABEL_25;
            }
            if (v17 > 3) {
              goto LABEL_27;
            }
            uint64_t v22 = 0;
            *(_DWORD *)(a1 + 384) = v17;
            size_t v28 = v16 + 32 * v17;
            *(void *)(v28 + 16) = 0;
            *(void *)(v28 + 24) = 0;
          }
          size_t v29 = v16;
          __int16 v30 = (uint64_t *)(v16 + 32 * v17);
          uint64_t v32 = v30 + 1;
          uint64_t v31 = v30[1];
          uint64_t v35 = *v30;
          uint64_t v34 = v30 + 3;
          uint64_t v33 = v35;
          unint64_t v36 = v31 - v22;
          if (v36 >= v14) {
            unint64_t v37 = v14;
          }
          else {
            unint64_t v37 = v36;
          }
          uint64_t v38 = a3(a4, v33 + v22, v37);
          if (v38 < 0)
          {
            unsigned int v11 = "stream read";
            __int16 v12 = 393;
            goto LABEL_26;
          }
          uint64_t v39 = v38;
          if (!v38) {
            break;
          }
          uint64_t v40 = *v34 + v38;
          *uint64_t v34 = v40;
          BOOL v41 = v40 == *v32;
          size_t v16 = v29;
          if (v41 && (currentWriteBufferFull((unsigned int *)a1) & 0x80000000) != 0) {
            goto LABEL_27;
          }
          v15 += v39;
          v14 -= v39;
          if (!v14) {
            goto LABEL_32;
          }
        }
        if ((sendEOF(a1) & 0x80000000) == 0)
        {
LABEL_32:
          if ((currentWriteBufferFull((unsigned int *)a1) & 0x80000000) == 0) {
            return v15;
          }
        }
      }
LABEL_27:
      SharedBufferAbort(a1, v24, v25, v26, v27, v18, v19, v20, v45);
    }
  }
  return -1;
}

uint64_t sendEOF(uint64_t a1)
{
  int v2 = 0;
  uint64_t result = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 392), (unsigned int *)&v2, 1u);
  if (!v2)
  {
    if ((currentWriteBufferFull((unsigned int *)a1) & 0x80000000) == 0)
    {
      if ((SharedArrayEnqueue((unsigned int *)a1, -2) & 0x80000000) == 0) {
        return 0;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"sendEOF", 351, 73, 0, "SharedArrayEnqueue", v4, v5, v6);
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t currentWriteBufferFull(unsigned int *a1)
{
  unsigned int v1 = a1[96];
  a1[96] = -1;
  if (v1 > 3 || (SharedArrayEnqueue(a1, v1) & 0x80000000) == 0) {
    return 0;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"currentWriteBufferFull", 324, 73, 0, "SharedArrayEnqueue", v2, v3, vars0);
  return 0xFFFFFFFFLL;
}

size_t SharedBufferAbort(size_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (result)
  {
    __int16 v9 = (unsigned int *)result;
    int v10 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(result + 400), (unsigned int *)&v10, 1u);
    if (!v10)
    {
      if ((SharedArrayPush((unsigned int *)(result + 128), -1) & 0x80000000) != 0) {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferAbort", 500, 73, 0, "SharedArrayPush", v11, v12, v15);
      }
      uint64_t result = SharedArrayEnqueue(v9, -1);
      if ((result & 0x80000000) != 0)
      {
        return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferAbort", 501, 73, 0, "SharedArrayPush", v13, v14, a9);
      }
    }
  }
  return result;
}

uint64_t SharedBufferFlushToStream(size_t a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4)
{
  if (!a2) {
    return -1;
  }
  if (atomic_load((unsigned int *)(a1 + 400))) {
    return -1;
  }
  if (!atomic_load((unsigned int *)(a1 + 396)))
  {
    unint64_t v11 = a2;
    uint64_t v6 = 0;
    BOOL v41 = (unsigned int *)(a1 + 128);
    size_t v42 = a1 + 256;
    while (1)
    {
      unint64_t v12 = *(unsigned int *)(a1 + 388);
      if (v12 >= 4)
      {
        if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 16)))
        {
          uint64_t v35 = "SharedArrayPop: pthread_mutex_lock failed\n";
          __int16 v36 = 91;
          goto LABEL_26;
        }
        while (!*(_DWORD *)a1)
        {
          if (pthread_cond_wait((pthread_cond_t *)(a1 + 80), (pthread_mutex_t *)(a1 + 16)))
          {
            uint64_t v35 = "SharedArrayPop: pthread_cond_wait failed\n";
            __int16 v36 = 94;
            goto LABEL_26;
          }
        }
        unsigned int v16 = *(_DWORD *)a1 - 1;
        *(_DWORD *)a1 = v16;
        unint64_t v12 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v16);
        if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16)))
        {
          uint64_t v35 = "SharedArrayPop: pthread_mutex_unlock failed\n";
          __int16 v36 = 98;
LABEL_26:
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v36, 0, v35, v13, v14, v15, (char)v41);
          unint64_t v37 = "SharedBufferFlushToStream";
          uint64_t v38 = "SharedArrayDequeue";
          __int16 v39 = 448;
LABEL_27:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)v37, v39, 73, 0, v38, v30, v31, (char)v41);
LABEL_28:
          SharedBufferAbort(a1, v17, v18, v19, v20, v13, v14, v15, (char)v41);
          return -1;
        }
        if (v12 == 4294967294)
        {
          int v40 = 0;
          atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 396), (unsigned int *)&v40, 1u);
          return v6;
        }
        if (v12 > 3) {
          goto LABEL_28;
        }
        *(_DWORD *)(a1 + 388) = v12;
      }
      size_t v21 = v42 + 32 * v12;
      unsigned int v23 = (void *)(v21 + 24);
      uint64_t v22 = *(void *)(v21 + 24);
      uint64_t v26 = *(void *)(v21 + 16);
      uint64_t v25 = (void *)(v21 + 16);
      uint64_t v24 = v26;
      unint64_t v27 = v22 - v26;
      if (v27 >= v11) {
        unint64_t v28 = v11;
      }
      else {
        unint64_t v28 = v27;
      }
      uint64_t v29 = a3(a4, *(void *)(v42 + 32 * v12) + v24, v28);
      if (v29 <= 0)
      {
        unint64_t v37 = "SharedBufferFlushToStream";
        uint64_t v38 = "stream write";
        __int16 v39 = 469;
        goto LABEL_27;
      }
      uint64_t v32 = v29;
      uint64_t v33 = *v25 + v29;
      void *v25 = v33;
      if (v33 == *v23)
      {
        unsigned int v34 = *(_DWORD *)(a1 + 388);
        *(_DWORD *)(a1 + 388) = -1;
        if (v34 <= 3 && (SharedArrayPush(v41, v34) & 0x80000000) != 0)
        {
          unint64_t v37 = "currentReadBufferEmpty";
          uint64_t v38 = "SharedArrayPush";
          __int16 v39 = 337;
          goto LABEL_27;
        }
      }
      v6 += v32;
      v11 -= v32;
      if (!v11) {
        return v6;
      }
    }
  }
  return 0;
}

uint64_t SharedArrayEnqueue(unsigned int *a1, int a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 4);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 4)))
  {
    uint64_t v8 = "SharedArrayPush: pthread_mutex_lock failed\n";
    __int16 v9 = 157;
  }
  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = a1[1];
    if (v10 >= v11)
    {
      int v12 = *a1;
    }
    else
    {
      if (v10) {
        memmove((void *)(*((void *)a1 + 1) + 4), *((const void **)a1 + 1), 4 * v10);
      }
      **((_DWORD **)a1 + 1) = a2;
      int v12 = *a1;
    }
    *a1 = v12 + 1;
    if (v12 || !pthread_cond_broadcast((pthread_cond_t *)(a1 + 20)))
    {
      if (pthread_mutex_unlock(v4))
      {
        uint64_t v8 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        __int16 v9 = 168;
      }
      else
      {
        if (v10 < v11) {
          return 0;
        }
        uint64_t v8 = "SharedArrayPush: stack is full\n";
        __int16 v9 = 169;
      }
    }
    else
    {
      uint64_t v8 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      __int16 v9 = 166;
    }
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayEnqueue", v9, 0, v8, v5, v6, v7, v14);
  return 0xFFFFFFFFLL;
}

uint64_t SharedBufferWrite(size_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (atomic_load((unsigned int *)(a1 + 400))) {
    return -1;
  }
  if (!a3) {
    return (int)sendEOF(a1);
  }
  uint64_t v10 = a2;
  return SharedBufferFillFromStream(a1, a3, (uint64_t (*)(uint64_t, uint64_t, unint64_t))SharedBufferReadFromBufferProc, (uint64_t)&v10, a5, a6, a7, a8);
}

size_t SharedBufferReadFromBufferProc(const void **a1, void *__dst, size_t a3)
{
  *a1 = (char *)*a1 + a3;
  return a3;
}

uint64_t SharedBufferRead(size_t a1, uint64_t a2, unint64_t a3)
{
  if (atomic_load((unsigned int *)(a1 + 400))) {
    return -1;
  }
  uint64_t v5 = a2;
  return SharedBufferFlushToStream(a1, a3, (uint64_t (*)(uint64_t, uint64_t, unint64_t))SharedBufferWriteToBufferProc, (uint64_t)&v5);
}

size_t SharedBufferWriteToBufferProc(void **a1, const void *a2, size_t a3)
{
  *a1 = (char *)*a1 + a3;
  return a3;
}

uint64_t ParallelArchiveRead(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v66 = *MEMORY[0x263EF8340];
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v51);
  bzero(v56, 0x928uLL);
  uint64_t v57 = 0x20000;
  __int16 v9 = malloc(0x20000uLL);
  uint64_t v10 = *(void *)(a1 + 80);
  uint64_t v58 = v9;
  uint64_t v64 = v10;
  long long v11 = *(_OWORD *)(a1 + 48);
  long long v61 = *(_OWORD *)(a1 + 32);
  long long v62 = v11;
  long long v63 = *(_OWORD *)(a1 + 64);
  int v12 = IMagicStreamCreate(*(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(a1 + 8), *(void *)(a1 + 16), *(void *)(a1 + 24), 12);
  uint64_t v13 = v12;
  if (!v12) {
    goto LABEL_59;
  }
  uint64_t Magic = IMagicStreamGetMagic((uint64_t)v12);
  unint64_t MagicSize = IMagicStreamGetMagicSize((uint64_t)v13);
  if (v9)
  {
    if (MagicSize < 0xC)
    {
      if (MagicSize < 6)
      {
        if (MagicSize < 4)
        {
          if (!MagicSize)
          {
LABEL_54:
            int v39 = 1;
            goto LABEL_55;
          }
          goto LABEL_43;
        }
LABEL_32:
        if (*(_DWORD *)Magic == 826360153 || *(_DWORD *)Magic == 825246017)
        {
LABEL_34:
          if (*(int *)a1 >= 2) {
            fwrite("Raw cpio/yaa archive payload\n", 0x1DuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
          }
          unsigned int v34 = (unint64_t *)MemBufferCreate(0x100000uLL);
          if (!v34) {
            goto LABEL_59;
          }
          unint64_t v37 = (void **)v34;
          uint64_t v38 = MemBufferTransmit(v34, 0xFFFFFFFFFFFFFFFFLL, (size_t (*)(int, void *, size_t))IMagicStreamRead, (uint64_t)v13, (uint64_t (*)(uint64_t, uint64_t, uint64_t))readProcessData, (uint64_t)v56, v35, v36);
          MemBufferDestroy(v37);
          if ((v38 & 0x8000000000000000) == 0)
          {
            if (*(int *)a1 >= 1) {
              fprintf((FILE *)*MEMORY[0x263EF8348], "%12lld raw archive\n");
            }
            goto LABEL_54;
          }
          unint64_t v27 = "MemBufferTransmit";
          __int16 v28 = 550;
          goto LABEL_41;
        }
LABEL_43:
        uint64_t v40 = ILowMemoryDecoderStreamCreate((uint64_t (*)(uint64_t, uint64_t, unint64_t))IMagicStreamRead, (uint64_t)IMagicStreamAbort, (uint64_t)v13, 0x100000uLL);
        if (!v40)
        {
          uint64_t v30 = "Could not identify payload format";
          __int16 v31 = 580;
LABEL_57:
          int v29 = 0;
          goto LABEL_58;
        }
        uint64_t v41 = v40;
        if (*(int *)a1 >= 2) {
          fwrite("Compressed archive payload (gzip, bzip2, xz)\n", 0x2DuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
        }
        size_t v42 = (unint64_t *)MemBufferCreate(0x100000uLL);
        if (!v42) {
          goto LABEL_59;
        }
        char v45 = (void **)v42;
        uint64_t v46 = MemBufferTransmit(v42, 0xFFFFFFFFFFFFFFFFLL, (size_t (*)(int, void *, size_t))ILowMemoryDecoderStreamRead, v41, (uint64_t (*)(uint64_t, uint64_t, uint64_t))readProcessData, (uint64_t)v56, v43, v44);
        MemBufferDestroy(v45);
        if (v46 < 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Read.c", (uint64_t)"ParallelArchiveRead", 570, 7, 0, "MemBufferTransmit", v47, v48, v52);
          int v39 = 0;
        }
        else
        {
          if (*(int *)a1 >= 1) {
            fprintf((FILE *)*MEMORY[0x263EF8348], "%12lld raw archive size\n", v46);
          }
          int v39 = 1;
        }
        ILowMemoryDecoderStreamDestroy(v41);
LABEL_55:
        if (!v65) {
          goto LABEL_60;
        }
        char v52 = v65;
        uint64_t v30 = "Errors in archive: %u";
        __int16 v31 = 585;
        goto LABEL_57;
      }
    }
    else if (*(_WORD *)Magic == 25200 && *(unsigned char *)(Magic + 2) == 122)
    {
      if (*(int *)a1 >= 1)
      {
        unsigned int v22 = 0;
        unint64_t v23 = *(void *)(Magic + 4);
        while (PCompressGetDecoderKey(v22) != *(unsigned __int8 *)(Magic + 3))
        {
          if (++v22 == 7)
          {
            unsigned int v22 = -1;
            break;
          }
        }
        uint64_t v24 = (FILE *)*MEMORY[0x263EF8348];
        DecoderDescription = PCompressGetDecoderDescription(v22);
        fprintf(v24, "Input archive compression: %s %llum\n", DecoderDescription, bswap64(v23) >> 20);
      }
      v55[1] = 0;
      v55[4] = 0;
      memset(v54, 0, sizeof(v54));
      v53[0] = 0;
      v53[1] = 0;
      v55[0] = IMagicStreamRead;
      v55[2] = v13;
      v55[3] = readProcessData;
      v55[5] = v56;
      DWORD1(v54[0]) = 1;
      int DefaultNThreads = *(_DWORD *)(a1 + 4);
      if (!DefaultNThreads) {
        int DefaultNThreads = getDefaultNThreads();
      }
      DWORD2(v54[0]) = DefaultNThreads;
      if (!PCompressFilter((unsigned int *)v54, (uint64_t)v55, v53, v16, v17, v18, v19, v20))
      {
        if (*(int *)a1 >= 1) {
          fprintf((FILE *)*MEMORY[0x263EF8348], "%12llu compressed archive size\n%12llu raw archive size\n%12.3f compression ratio\n");
        }
        goto LABEL_54;
      }
      unint64_t v27 = "PCompressFilter";
      __int16 v28 = 530;
LABEL_41:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Read.c", (uint64_t)"ParallelArchiveRead", v28, 7, 0, v27, v19, v20, v52);
      int v39 = 0;
      goto LABEL_55;
    }
    if (*(_DWORD *)Magic == 925906736 && *(_WORD *)(Magic + 4) == 12592) {
      goto LABEL_34;
    }
    if (*(_DWORD *)Magic == 925906736 && *(_WORD *)(Magic + 4) == 14128) {
      goto LABEL_34;
    }
    goto LABEL_32;
  }
  int v29 = *__error();
  uint64_t v30 = "malloc";
  __int16 v31 = 500;
LABEL_58:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Read.c", (uint64_t)"ParallelArchiveRead", v31, 7, v29, v30, v19, v20, v52);
LABEL_59:
  int v39 = 0;
LABEL_60:
  IMagicStreamDestroy(v13);
  free(v58);
  free(v59);
  free(v60);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (v39) {
    unsigned int v50 = 0;
  }
  else {
    unsigned int v50 = -1;
  }
  if ((int)result >= 0) {
    return v50;
  }
  else {
    return result;
  }
}

size_t readProcessData(uint64_t a1, char *__src, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (unint64_t *)(a1 + 2256);
  size_t v144 = a3;
  uint64_t v145 = (unint64_t *)(a1 + 2232);
  long long v11 = (int *)(a1 + 32);
  int v12 = (char *)(a1 + 176);
  while (2)
  {
    switch(*(_DWORD *)a1)
    {
      case 0:
        *(void *)(a1 + 2232) = 0;
        *uint64_t v10 = 0;
        v10[1] = 0;
        unint64_t v13 = *(void *)(a1 + 16);
        if (v13 <= 7)
        {
          uint64_t v107 = 8;
LABEL_177:
          size_t v22 = v107 - v13;
          goto LABEL_178;
        }
        uint64_t v14 = 0;
        unint64_t v15 = 0;
        uint64_t v16 = *(void *)(a1 + 24);
        do
        {
          unint64_t v17 = v15;
          unint64_t v15 = *(unsigned char *)(v16 + v14++) & 7 | (8 * v15);
        }
        while (v14 != 8);
        if (*(unsigned char *)v16 == 16)
        {
          if (v13 <= 0x1D)
          {
            uint64_t v107 = 30;
            goto LABEL_177;
          }
          uint64_t v18 = bswap32(*(unsigned __int16 *)(v16 + 22)) >> 16;
          if (v18 >= 0x400)
          {
            uint64_t v133 = "readProcessData";
            uint64_t v134 = "invalid nameSize";
            __int16 v135 = 165;
            goto LABEL_213;
          }
          unint64_t v19 = v18 + 30;
          if (*(unsigned __int8 *)(v16 + 1) - 3 <= 1)
          {
            unint64_t v20 = bswap64(*(void *)(v16 + 2));
            if (v20 >= 0x400)
            {
              uint64_t v133 = "readProcessData";
              uint64_t v134 = "invalid linkSize";
              __int16 v135 = 169;
              goto LABEL_213;
            }
            v19 += v20;
          }
          BOOL v21 = v19 > v13;
          size_t v22 = v19 - v13;
          if (v21) {
            goto LABEL_178;
          }
          setAAHeaderFromHeader_v10(v11, v16);
LABEL_48:
          if ((*((unsigned char *)v11 + 1) & 2) != 0)
          {
            uint64_t v49 = *(void *)(a1 + 96);
            unint64_t v50 = *(void *)(a1 + 2256);
            unint64_t v51 = *(void *)(a1 + 2248);
            if (v50 >= v51)
            {
              *(void *)(a1 + 2248) = v51 + 16;
              char v52 = (char *)reallocf(*(void **)(a1 + 2272), 16 * (v51 + 16));
              *(void *)(a1 + 2272) = v52;
              if (!v52) {
                goto LABEL_195;
              }
              unint64_t v50 = *v10;
            }
            else
            {
              char v52 = *(char **)(a1 + 2272);
            }
            uint64_t v82 = &v52[16 * v50];
            *(void *)uint64_t v82 = 0;
            *((void *)v82 + 1) = 0;
LABEL_108:
            __strlcpy_chk();
            *((void *)v82 + 1) = v49;
            ++*v10;
          }
LABEL_163:
          if ((*v11 & 1) == 0)
          {
            uint64_t v133 = "readProcessData";
            uint64_t v134 = "Invalid entry, no TYP field";
            __int16 v135 = 309;
            goto LABEL_213;
          }
          if ((*v11 & 0x8000) != 0 && *(_DWORD *)(a1 + 36) != 77)
          {
            size_t v127 = strlen(v12);
            if (!pathIsValid(v12, v127))
            {
              uint64_t v133 = "readProcessData";
              uint64_t v134 = "Invalid entry path";
              __int16 v135 = 315;
              goto LABEL_213;
            }
          }
          uint64_t v128 = *(void (**)(void, int *, void, void, void, void))(a1 + 2280);
          if (v128) {
            v128(*(void *)(a1 + 2328), v11, *(void *)(a1 + 2240), *(void *)(a1 + 2232), *(void *)(a1 + 24), *(void *)(a1 + 16));
          }
          *(void *)(a1 + 16) = 0;
          int v25 = 1;
LABEL_170:
          *(_DWORD *)a1 = v25;
          continue;
        }
        unint64_t v26 = ((8 * v17) >> 6) & 0x3FFFF;
        if (v26 == 29121)
        {
          if (v13 <= 0x6D)
          {
            uint64_t v107 = 110;
            goto LABEL_177;
          }
          uint64_t v53 = 0;
          unint64_t v54 = 0;
          do
          {
            int v55 = *(char *)(v16 + 94 + v53);
            v54 *= 16;
            char v56 = v55 - 48;
            if ((v55 - 48) <= 0x36)
            {
              if (((1 << v56) & 0x3FF) != 0)
              {
                unint64_t v54 = v54 + *(char *)(v16 + 94 + v53) - 48;
              }
              else if (((1 << v56) & 0x7E0000) != 0)
              {
                unint64_t v54 = v54 + *(char *)(v16 + 94 + v53) - 55;
              }
              else if (((1 << v56) & 0x7E000000000000) != 0)
              {
                unint64_t v54 = v54 + *(char *)(v16 + 94 + v53) - 87;
              }
            }
            ++v53;
          }
          while (v53 != 8);
          uint64_t v57 = 0;
          unint64_t v58 = 0;
          do
          {
            int v59 = *(char *)(v16 + 54 + v57);
            v58 *= 16;
            char v60 = v59 - 48;
            if ((v59 - 48) <= 0x36)
            {
              if (((1 << v60) & 0x3FF) != 0)
              {
                unint64_t v58 = v58 + *(char *)(v16 + 54 + v57) - 48;
              }
              else if (((1 << v60) & 0x7E0000) != 0)
              {
                unint64_t v58 = v58 + *(char *)(v16 + 54 + v57) - 55;
              }
              else if (((1 << v60) & 0x7E000000000000) != 0)
              {
                unint64_t v58 = v58 + *(char *)(v16 + 54 + v57) - 87;
              }
            }
            ++v57;
          }
          while (v57 != 8);
          uint64_t v61 = 0;
          uint64_t v62 = 0;
          do
          {
            int v63 = *(char *)(v16 + 14 + v61);
            v62 *= 16;
            char v64 = v63 - 48;
            if ((v63 - 48) <= 0x36)
            {
              if (((1 << v64) & 0x3FF) != 0)
              {
                uint64_t v62 = v62 + *(char *)(v16 + 14 + v61) - 48;
              }
              else if (((1 << v64) & 0x7E0000) != 0)
              {
                uint64_t v62 = v62 + *(char *)(v16 + 14 + v61) - 55;
              }
              else if (((1 << v64) & 0x7E000000000000) != 0)
              {
                uint64_t v62 = v62 + *(char *)(v16 + 14 + v61) - 87;
              }
            }
            ++v61;
          }
          while (v61 != 8);
          int OLDEntryType = getOLDEntryType(v62);
          if (v54 >= 0x400)
          {
            uint64_t v133 = "readProcessData";
            uint64_t v134 = "invalid nameSize";
            __int16 v135 = 225;
            goto LABEL_213;
          }
          unint64_t v66 = v54 + 110;
          if ((OLDEntryType - 3) <= 1)
          {
            if (v58 >= 0x400)
            {
              uint64_t v133 = "readProcessData";
              uint64_t v134 = "invalid linkSize";
              __int16 v135 = 229;
              goto LABEL_213;
            }
            v66 += v58;
          }
          unint64_t v67 = *(void *)(a1 + 16);
          size_t v22 = v66 - v67;
          if (v66 > v67) {
            goto LABEL_178;
          }
          uint64_t v68 = *(void *)(a1 + 24);
          if (OLDEntryType
            || v58
            || v54 != 11
            || (*(void *)(v68 + 110) == 0x2152454C49415254
              ? (BOOL v69 = *(void *)(v68 + 113) == 0x21212152454C49)
              : (BOOL v69 = 0),
                !v69))
          {
            setAAHeaderFromHeader_NEWC(v11, v68);
            unint64_t v70 = (v66 + 3) & 0xFFFFFFFFFFFFFFFCLL;
            unint64_t v71 = v70 - v66;
            if (v70 != v66)
            {
              unint64_t v72 = *(void *)(a1 + 2256);
              unint64_t v73 = *(void *)(a1 + 2248);
              if (v72 >= v73)
              {
                *(void *)(a1 + 2248) = v73 + 16;
                uint64_t v74 = (char *)reallocf(*(void **)(a1 + 2272), 16 * (v73 + 16));
                *(void *)(a1 + 2272) = v74;
                if (!v74) {
                  goto LABEL_195;
                }
                unint64_t v72 = *v10;
              }
              else
              {
                uint64_t v74 = *(char **)(a1 + 2272);
              }
              uint64_t v86 = &v74[16 * v72];
              *(void *)uint64_t v86 = 0;
              *((void *)v86 + 1) = 0;
              __strlcpy_chk();
              *((void *)v86 + 1) = v71;
              ++*v10;
            }
            if ((*((unsigned char *)v11 + 1) & 2) != 0)
            {
              uint64_t v87 = *(void *)(a1 + 96);
              unint64_t v88 = *(void *)(a1 + 2256);
              unint64_t v89 = *(void *)(a1 + 2248);
              if (v88 >= v89)
              {
                *(void *)(a1 + 2248) = v89 + 16;
                BOOL v90 = (char *)reallocf(*(void **)(a1 + 2272), 16 * (v89 + 16));
                *(void *)(a1 + 2272) = v90;
                if (!v90) {
                  goto LABEL_195;
                }
                unint64_t v88 = *v10;
              }
              else
              {
                BOOL v90 = *(char **)(a1 + 2272);
              }
              BOOL v91 = &v90[16 * v88];
              *(void *)BOOL v91 = 0;
              *((void *)v91 + 1) = 0;
              __strlcpy_chk();
              *((void *)v91 + 1) = v87;
              ++*v10;
            }
            uint64_t v92 = *(void *)(a1 + 96);
            unint64_t v93 = (v92 + 3) & 0xFFFFFFFFFFFFFFFCLL;
            uint64_t v49 = v93 - v92;
            if (v93 == v92) {
              goto LABEL_163;
            }
            unint64_t v94 = *(void *)(a1 + 2256);
            unint64_t v95 = *(void *)(a1 + 2248);
            if (v94 >= v95)
            {
              *(void *)(a1 + 2248) = v95 + 16;
              uint64_t v96 = (char *)reallocf(*(void **)(a1 + 2272), 16 * (v95 + 16));
              *(void *)(a1 + 2272) = v96;
              if (!v96) {
                goto LABEL_195;
              }
              unint64_t v94 = *v10;
            }
            else
            {
              uint64_t v96 = *(char **)(a1 + 2272);
            }
            uint64_t v82 = &v96[16 * v94];
            *(void *)uint64_t v82 = 0;
            *((void *)v82 + 1) = 0;
            goto LABEL_108;
          }
          AAFlagSet v131 = *(void (**)(uint64_t))(a1 + 2320);
          if (v131)
          {
            uint64_t v132 = *(void *)(a1 + 2328);
            goto LABEL_189;
          }
LABEL_190:
          size_t v22 = 0;
          *(void *)(a1 + 16) = 0;
          *(_DWORD *)a1 = 3;
LABEL_178:
          if (!v144) {
            return a3;
          }
          if (v22)
          {
            if (v22 >= v144) {
              size_t v129 = v144;
            }
            else {
              size_t v129 = v22;
            }
            uint64_t v130 = *(void *)(a1 + 16);
            if (v130 + v129 > *(void *)(a1 + 8))
            {
              uint64_t v133 = "readProcessData";
              uint64_t v134 = "internal header buffer is too small";
              __int16 v135 = 452;
              goto LABEL_213;
            }
            memcpy((void *)(*(void *)(a1 + 24) + v130), __src, v129);
            *(void *)(a1 + 16) += v129;
            __src += v129;
            v144 -= v129;
          }
          continue;
        }
        if (v26 == 29127)
        {
          if (v13 <= 0x4B)
          {
            uint64_t v107 = 76;
            goto LABEL_177;
          }
          uint64_t v27 = 0;
          unint64_t v28 = 0;
          do
          {
            unint64_t v29 = *(unsigned char *)(v16 + 57 + v27++) & 7 | (8 * v28);
            unint64_t v28 = v29;
          }
          while (v27 != 8);
          uint64_t v30 = 0;
          unint64_t v31 = 0;
          do
          {
            unint64_t v32 = *(unsigned char *)(v16 + 64 + v30++) & 7 | (8 * v31);
            unint64_t v31 = v32;
          }
          while (v30 != 4);
          uint64_t v33 = 0;
          unint64_t v34 = 0;
          do
          {
            unint64_t v35 = *(unsigned char *)(v16 + 68 + v33++) & 7 | (8 * v34);
            unint64_t v34 = v35;
          }
          while (v33 != 8);
          uint64_t v36 = 0;
          unint64_t v37 = 0;
          unint64_t v38 = v32 << 24;
          do
          {
            unint64_t v39 = *(unsigned char *)(v16 + 16 + v36++) & 7 | (8 * v37);
            unint64_t v37 = v39;
          }
          while (v36 != 8);
          unint64_t v40 = v29 & 0x3FFFF;
          int v41 = getOLDEntryType(v39);
          if (v40 >= 0x400)
          {
            uint64_t v133 = "readProcessData";
            uint64_t v134 = "invalid nameSize";
            __int16 v135 = 191;
            goto LABEL_213;
          }
          unint64_t v42 = v35 + (v38 & 0x1FF000000);
          unint64_t v43 = v40 + 76;
          if ((v41 - 3) <= 1)
          {
            if (v42 >= 0x400)
            {
              uint64_t v133 = "readProcessData";
              uint64_t v134 = "invalid linkSize";
              __int16 v135 = 195;
              goto LABEL_213;
            }
            v43 += v42;
          }
          unint64_t v44 = *(void *)(a1 + 16);
          size_t v22 = v43 - v44;
          if (v43 > v44) {
            goto LABEL_178;
          }
          uint64_t v45 = *(void *)(a1 + 24);
          if (v41) {
            BOOL v46 = 0;
          }
          else {
            BOOL v46 = v42 == 0;
          }
          BOOL v47 = v46 && v40 == 11;
          if (!v47
            || (*(void *)(v45 + 76) == 0x2152454C49415254
              ? (BOOL v48 = *(void *)(v45 + 79) == 0x21212152454C49)
              : (BOOL v48 = 0),
                !v48))
          {
            setAAHeaderFromHeader_ODC(v11, v45);
            goto LABEL_48;
          }
          AAFlagSet v131 = *(void (**)(uint64_t))(a1 + 2320);
          if (v131)
          {
            uint64_t v132 = *(void *)(a1 + 2328);
LABEL_189:
            v131(v132);
            goto LABEL_190;
          }
          goto LABEL_190;
        }
        if (*(_DWORD *)v16 == 826360153 || *(_DWORD *)v16 == 825246017)
        {
          unint64_t v75 = *(unsigned __int16 *)(v16 + 4);
          size_t v22 = v75 - v13;
          if (v75 > v13) {
            goto LABEL_178;
          }
          uint64_t v146 = 0;
          unint64_t v147 = 0;
          if ((yaa_decodeHeaderInfo(v16, v13, &v147, &v146) & 0x8000000000000000) != 0)
          {
            uint64_t v133 = "readProcessData";
            uint64_t v134 = "invalid YAA header";
            __int16 v135 = 268;
            goto LABEL_213;
          }
          unint64_t v76 = *(void *)(a1 + 2224);
          unint64_t v77 = v147;
          unint64_t v78 = *(void **)(a1 + 2240);
          if (v76 < v147)
          {
            *(void *)(a1 + 2224) = v147;
            unint64_t v79 = reallocf(v78, 1032 * v77);
            *(void *)(a1 + 2240) = v79;
            if (!v79)
            {
              int v138 = *__error();
              uint64_t v133 = "readProcessData";
              uint64_t v134 = "malloc";
              __int16 v135 = 275;
              goto LABEL_214;
            }
            unint64_t v78 = v79;
            unint64_t v76 = *(void *)(a1 + 2224);
          }
          if (yaa_decodeHeader(v11, *(void *)(a1 + 24), *(void *)(a1 + 16), (uint64_t)v78, v76, v145) != v75)
          {
            uint64_t v133 = "readProcessData";
            uint64_t v134 = "invalid YAA header";
            __int16 v135 = 280;
            goto LABEL_213;
          }
          *uint64_t v10 = 0;
          v10[1] = 0;
          int v80 = *v11;
          if ((*v11 & 0x200) != 0)
          {
            uint64_t v83 = *(void *)(a1 + 96);
            if (*(void *)(a1 + 2248))
            {
              unint64_t v84 = 0;
              uint64_t v85 = *(char **)(a1 + 2272);
            }
            else
            {
              *(void *)(a1 + 2248) = 16;
              uint64_t v85 = (char *)reallocf(*(void **)(a1 + 2272), 0x100uLL);
              *(void *)(a1 + 2272) = v85;
              if (!v85) {
                goto LABEL_195;
              }
              unint64_t v84 = *v10;
            }
            uint64_t v109 = &v85[16 * v84];
            *(void *)uint64_t v109 = 0;
            *((void *)v109 + 1) = 0;
            __strlcpy_chk();
            *((void *)v109 + 1) = v83;
            unint64_t v81 = *v10 + 1;
            *uint64_t v10 = v81;
            int v80 = *v11;
            if ((*v11 & 0x400) == 0) {
              goto LABEL_146;
            }
          }
          else
          {
            unint64_t v81 = 0;
            if ((v80 & 0x400) == 0)
            {
LABEL_146:
              uint64_t v143 = v12;
              if ((v80 & 0x800) != 0)
              {
                uint64_t v115 = *(void *)(a1 + 112);
                unint64_t v116 = *(void *)(a1 + 2248);
                if (v81 >= v116)
                {
                  *(void *)(a1 + 2248) = v116 + 16;
                  uint64_t v117 = (char *)reallocf(*(void **)(a1 + 2272), 16 * (v116 + 16));
                  *(void *)(a1 + 2272) = v117;
                  if (!v117)
                  {
LABEL_195:
                    int v138 = *__error();
                    uint64_t v133 = "addBlob";
                    uint64_t v134 = "malloc";
                    __int16 v135 = 111;
                    goto LABEL_214;
                  }
                  uint64_t v114 = __src;
                  unint64_t v81 = *v10;
                }
                else
                {
                  uint64_t v114 = __src;
                  uint64_t v117 = *(char **)(a1 + 2272);
                }
                int v118 = &v117[16 * v81];
                *(void *)int v118 = 0;
                *((void *)v118 + 1) = 0;
                __strlcpy_chk();
                *((void *)v118 + 1) = v115;
                unint64_t v81 = *v10 + 1;
                *uint64_t v10 = v81;
              }
              else
              {
                uint64_t v114 = __src;
              }
              unint64_t v119 = *v145;
              if (*v145)
              {
                uint64_t v120 = 0;
                unint64_t v121 = 0;
                do
                {
                  uint64_t v122 = *(void *)(a1 + 2240) + v120;
                  if (*(_DWORD *)(v122 + 4) == 2)
                  {
                    uint64_t v123 = *(void *)(v122 + 8);
                    unint64_t v124 = *(void *)(a1 + 2248);
                    if (v81 >= v124)
                    {
                      *(void *)(a1 + 2248) = v124 + 16;
                      int v125 = (char *)reallocf(*(void **)(a1 + 2272), 16 * (v124 + 16));
                      *(void *)(a1 + 2272) = v125;
                      if (!v125) {
                        goto LABEL_195;
                      }
                      unint64_t v81 = *v10;
                    }
                    else
                    {
                      int v125 = *(char **)(a1 + 2272);
                    }
                    unint64_t v126 = &v125[16 * v81];
                    *(void *)unint64_t v126 = 0;
                    *((void *)v126 + 1) = 0;
                    __strlcpy_chk();
                    *((void *)v126 + 1) = v123;
                    unint64_t v81 = *v10 + 1;
                    *uint64_t v10 = v81;
                    unint64_t v119 = *v145;
                  }
                  ++v121;
                  v120 += 1032;
                }
                while (v121 < v119);
              }
              __src = v114;
              int v12 = v143;
              goto LABEL_163;
            }
          }
          uint64_t v110 = *(void *)(a1 + 104);
          unint64_t v111 = *(void *)(a1 + 2248);
          if (v81 >= v111)
          {
            *(void *)(a1 + 2248) = v111 + 16;
            uint64_t v112 = (char *)reallocf(*(void **)(a1 + 2272), 16 * (v111 + 16));
            *(void *)(a1 + 2272) = v112;
            if (!v112) {
              goto LABEL_195;
            }
            unint64_t v81 = *v10;
          }
          else
          {
            uint64_t v112 = *(char **)(a1 + 2272);
          }
          uint64_t v113 = &v112[16 * v81];
          *(void *)uint64_t v113 = 0;
          *((void *)v113 + 1) = 0;
          __strlcpy_chk();
          *((void *)v113 + 1) = v110;
          unint64_t v81 = *v10 + 1;
          *uint64_t v10 = v81;
          int v80 = *v11;
          goto LABEL_146;
        }
        unint64_t v139 = 0;
        ++*(_DWORD *)(a1 + 2336);
        uint64_t v140 = (FILE **)MEMORY[0x263EF8348];
        do
        {
          if (*(char *)(*(void *)(a1 + 24) + v139) > 31) {
            fputc(*(unsigned __int8 *)(*(void *)(a1 + 24) + v139), *v140);
          }
          else {
            fprintf(*v140, "<%02x>", *(unsigned __int8 *)(*(void *)(a1 + 24) + v139));
          }
          ++v139;
        }
        while (v139 < *(void *)(a1 + 16));
        fputc(10, *v140);
        uint64_t v133 = "readProcessData";
        uint64_t v134 = "Invalid header";
        __int16 v135 = 305;
LABEL_213:
        int v138 = 0;
LABEL_214:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Read.c", (uint64_t)v133, v135, 7, v138, v134, a7, a8, v141);
        return -1;
      case 1:
        uint64_t v23 = *(void *)(a1 + 2264);
        if (v23 != *(void *)(a1 + 2256))
        {
          if (*(unsigned char *)(*(void *)(a1 + 2272) + 16 * v23))
          {
            uint64_t v24 = *(void (**)(void))(a1 + 2288);
            if (v24) {
              v24(*(void *)(a1 + 2328));
            }
          }
          int v25 = 2;
          goto LABEL_170;
        }
        uint64_t v108 = *(void (**)(void))(a1 + 2312);
        if (v108) {
          v108(*(void *)(a1 + 2328));
        }
        size_t v22 = 0;
        *(_DWORD *)a1 = 0;
        goto LABEL_178;
      case 2:
        uint64_t v97 = *(void *)(a1 + 2272);
        uint64_t v98 = *(void *)(a1 + 2264);
        uint64_t v99 = v97 + 16 * v98;
        uint64_t v100 = 16 * v98;
        size_t v103 = *(void *)(v99 + 8);
        uint64_t v102 = (size_t *)(v99 + 8);
        size_t v101 = v103;
        if (v144 >= v103) {
          size_t v104 = v101;
        }
        else {
          size_t v104 = v144;
        }
        if (*(unsigned char *)(v97 + v100))
        {
          int v105 = *(void (**)(void, char *, size_t))(a1 + 2296);
          if (!v105) {
            goto LABEL_132;
          }
LABEL_131:
          v105(*(void *)(a1 + 2328), __src, v104);
          size_t v101 = *v102;
          goto LABEL_132;
        }
        int v105 = *(void (**)(void, char *, size_t))(a1 + 2304);
        if (v105) {
          goto LABEL_131;
        }
LABEL_132:
        v144 -= v104;
        __src += v104;
        size_t v106 = v101 - v104;
        size_t *v102 = v106;
        if (!v106)
        {
          ++*(void *)(a1 + 2264);
          *(_DWORD *)a1 = 1;
          continue;
        }
        size_t v22 = 0;
        goto LABEL_178;
      case 3:
        uint64_t v136 = *(void (**)(void, char *, size_t))(a1 + 2320);
        if (v136) {
          v136(*(void *)(a1 + 2328), __src, v144);
        }
        return a3;
      default:
        uint64_t v133 = "readProcessData";
        uint64_t v134 = "invalid state";
        __int16 v135 = 436;
        goto LABEL_213;
    }
  }
}

uint64_t ParallelArchiveReadMetadata(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v49);
  __int16 v9 = (unint64_t *)MemBufferCreate(0x10000uLL);
  if (!v9)
  {
    uint64_t v17 = 0;
    long long v11 = 0;
LABEL_51:
    int v18 = 0;
    goto LABEL_52;
  }
  uint64_t v10 = IMagicStreamCreate(*(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(a1 + 8), *(void *)(a1 + 16), *(void *)(a1 + 24), 8);
  long long v11 = v10;
  if (!v10)
  {
LABEL_47:
    uint64_t v17 = 0;
    goto LABEL_51;
  }
  uint64_t Magic = IMagicStreamGetMagic((uint64_t)v10);
  unint64_t MagicSize = IMagicStreamGetMagicSize((uint64_t)v11);
  if (!MagicSize)
  {
    uint64_t v17 = 0;
    goto LABEL_19;
  }
  if (MagicSize < 6)
  {
    if (MagicSize < 4)
    {
LABEL_23:
      uint64_t v19 = ILowMemoryDecoderStreamCreate((uint64_t (*)(uint64_t, uint64_t, unint64_t))IMagicStreamRead, (uint64_t)IMagicStreamAbort, (uint64_t)v11, 0x10000uLL);
      if (v19)
      {
        uint64_t v22 = v19;
        uint64_t v23 = (uint64_t (*)(uint64_t, uint64_t, unint64_t))ILowMemoryDecoderStreamRead;
        uint64_t v17 = v19;
        goto LABEL_29;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Read.c", (uint64_t)"ParallelArchiveReadMetadata", 642, 7, 0, "Could not identify payload format", v20, v21, v49);
      goto LABEL_47;
    }
  }
  else
  {
    if (*(_DWORD *)Magic == 925906736 && *(_WORD *)(Magic + 4) == 12592) {
      goto LABEL_25;
    }
    if (*(_DWORD *)Magic == 925906736 && *(_WORD *)(Magic + 4) == 14128) {
      goto LABEL_25;
    }
  }
  if (*(_DWORD *)Magic != 826360153 && *(_DWORD *)Magic != 825246017) {
    goto LABEL_23;
  }
LABEL_25:
  if (*(int *)a1 < 2)
  {
    uint64_t v23 = (uint64_t (*)(uint64_t, uint64_t, unint64_t))IMagicStreamRead;
    uint64_t v17 = 0;
  }
  else
  {
    fwrite("Raw cpio/yaa archive payload\n", 0x1DuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    uint64_t v17 = 0;
    uint64_t v23 = (uint64_t (*)(uint64_t, uint64_t, unint64_t))IMagicStreamRead;
  }
  uint64_t v22 = (uint64_t)v11;
LABEL_29:
  if (MemBufferFillFromIStream(v9, 0x10000uLL, v23, v22) < 0)
  {
    BOOL v46 = "Reading entry";
    __int16 v47 = 649;
LABEL_50:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Read.c", (uint64_t)"ParallelArchiveReadMetadata", v47, 7, 0, v46, v24, v25, v49);
    goto LABEL_51;
  }
  uint64_t DataPtr = MemBufferGetDataPtr((uint64_t)v9);
  unint64_t DataSize = MemBufferGetDataSize((uint64_t)v9);
  size_t v49 = 0;
  uint64_t v50 = 0;
  unint64_t v28 = yaa_decodeHeaderInfo(DataPtr, DataSize, &v50, &v49);
  if ((v28 & 0x8000000000000000) != 0)
  {
    BOOL v46 = "Parsing YAA header";
    __int16 v47 = 660;
    goto LABEL_50;
  }
  unint64_t v29 = v28;
  *(void *)(a1 + 2240) = v50;
  *(void *)(a1 + 2264) = v49;
  if (yaa_decodeHeader((_DWORD *)(a1 + 32), DataPtr, v28, *(void *)(a1 + 2224), *(void *)(a1 + 2232), (unint64_t *)(a1 + 2240)) < 0)
  {
    BOOL v46 = "Decoding YAA header";
    __int16 v47 = 665;
    goto LABEL_50;
  }
  MemBufferDecreaseSize((uint64_t)v9, v29, v30, v31, v32, v33, v24, v25);
  if (v49 >= *(void *)(a1 + 2256)) {
    size_t v34 = *(void *)(a1 + 2256);
  }
  else {
    size_t v34 = v49;
  }
  if (v34)
  {
    unint64_t v35 = *(char **)(a1 + 2248);
    while (1)
    {
      unint64_t v36 = MemBufferGetDataSize((uint64_t)v9);
      if (v34 > v36 && MemBufferFillFromIStream(v9, v34 - v36, v23, v22) < 0) {
        break;
      }
      unint64_t v37 = MemBufferGetDataSize((uint64_t)v9);
      if (v37 >= v34) {
        size_t v38 = v34;
      }
      else {
        size_t v38 = v37;
      }
      unint64_t v39 = (const void *)MemBufferGetDataPtr((uint64_t)v9);
      memcpy(v35, v39, v38);
      MemBufferDecreaseSize((uint64_t)v9, v38, v40, v41, v42, v43, v44, v45);
      v35 += v38;
      v34 -= v38;
      if (!v34) {
        goto LABEL_19;
      }
    }
    BOOL v46 = "Reading entry";
    __int16 v47 = 678;
    goto LABEL_50;
  }
LABEL_19:
  int v18 = 1;
LABEL_52:
  ILowMemoryDecoderStreamDestroy(v17);
  IMagicStreamDestroy(v11);
  MemBufferDestroy((void **)v9);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (v18) {
    unsigned int v48 = 0;
  }
  else {
    unsigned int v48 = -1;
  }
  if ((int)result >= 0) {
    return v48;
  }
  else {
    return result;
  }
}

void *reallocToFit(void *a1, size_t __size)
{
  if (__size >= 0x1000)
  {
    uint64_t v4 = malloc(__size);
    if (v4)
    {
      uint64_t v5 = v4;
      memcpy(v4, a1, __size);
      free(a1);
      return v5;
    }
  }
  return a1;
}

uint64_t getInstalledMemorySize()
{
  uint64_t v0 = sysconf(200);
  uint64_t v1 = sysconf(29);
  if (v1 <= 0 || v0 <= 0) {
    return 0;
  }
  else {
    return v1 * v0;
  }
}

double getRealTime()
{
  v1.tv_sec = 0;
  *(void *)&v1.tv_usec = 0;
  gettimeofday(&v1, 0);
  return (double)v1.tv_sec + (double)v1.tv_usec * 0.000001;
}

uint64_t getDefaultNThreads()
{
  unsigned int v5 = 0;
  size_t v4 = 4;
  if (!sysctlbyname("hw.physicalcpu", &v5, &v4, 0, 0)) {
    return v5;
  }
  uint64_t v0 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getDefaultNThreads", 107, 3, *v0, "sysctlbyname", v1, v2, v4);
  return 1;
}

uint64_t sha1ToString(uint64_t result, uint64_t a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = (unsigned char *)(result + 1);
  do
  {
    unint64_t v4 = *(unsigned __int8 *)(a2 + v2);
    *(v3 - 1) = serializeHexString_digit[v4 >> 4];
    *uint64_t v3 = serializeHexString_digit[v4 & 0xF];
    v3 += 2;
    ++v2;
  }
  while (v2 != 20);
  *(unsigned char *)(result + 40) = 0;
  return result;
}

uint64_t serializeHexString(uint64_t result, unsigned int a2, unsigned __int8 *a3)
{
  if (a2)
  {
    uint64_t v3 = 0;
    do
    {
      unsigned int v4 = *a3++;
      *(unsigned char *)(result + v3) = serializeHexString_digit[(unint64_t)v4 >> 4];
      *(unsigned char *)(result + (v3 + 1)) = serializeHexString_digit[v4 & 0xF];
      v3 += 2;
    }
    while (2 * a2 != v3);
  }
  *(unsigned char *)(result + 2 * a2) = 0;
  return result;
}

uint64_t sha1cmp(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = bswap64(*(void *)a1);
  unint64_t v3 = bswap64(*(void *)a2);
  if (v2 == v3)
  {
    unint64_t v2 = bswap64(*(void *)(a1 + 8));
    unint64_t v3 = bswap64(*(void *)(a2 + 8));
    if (v2 == v3)
    {
      unint64_t v2 = bswap32(*(_DWORD *)(a1 + 16));
      unint64_t v3 = bswap32(*(_DWORD *)(a2 + 16));
      if (v2 == v3) {
        return 0;
      }
    }
  }
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  return 1;
}

uint64_t sha1xor(uint64_t result, uint64_t a2)
{
  for (uint64_t i = 0; i != 20; ++i)
    *(unsigned char *)(result + i) ^= *(unsigned char *)(a2 + i);
  return result;
}

const char *makePath(const char *result, unint64_t a2)
{
  unint64_t v3 = result;
  memset(&v6, 0, sizeof(v6));
  if (a2)
  {
    unint64_t v4 = a2;
    do
    {
      if (v3[v4] == 47)
      {
        v3[v4] = 0;
        uint64_t result = (const char *)stat(v3, &v6);
        if (!result) {
          break;
        }
      }
      --v4;
    }
    while (v4);
  }
  else
  {
    unint64_t v4 = 0;
  }
  if (v4 < a2)
  {
    int v5 = 1;
    do
    {
      if (!v3[v4])
      {
        if (!v5) {
          uint64_t result = (const char *)mkdir(v3, 0x1EDu);
        }
        int v5 = 0;
        v3[v4] = 47;
      }
      ++v4;
    }
    while (a2 != v4);
  }
  return result;
}

const char *statPath(const char *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    unint64_t v3 = result;
    memset(&v4, 0, sizeof(v4));
    do
    {
      if (v3[v2] == 47)
      {
        v3[v2] = 0;
        uint64_t result = (const char *)stat(v3, &v4);
        v3[v2] = 47;
      }
      --v2;
    }
    while (v2);
  }
  return result;
}

uint64_t concatPath(char *a1, unint64_t a2, char *__s, const char *a4)
{
  size_t v8 = strlen(__s);
  size_t v9 = strlen(a4);
  if (v8 + v9 + 2 > a2) {
    return 0xFFFFFFFFLL;
  }
  size_t v11 = v9;
  if (a1 != __s) {
    memcpy(a1, __s, v8);
  }
  if (v11)
  {
    if (!v8 || a1[v8 - 1] != 47) {
      a1[v8++] = 47;
    }
    memcpy(&a1[v8], a4, v11);
    v8 += v11;
  }
  uint64_t result = 0;
  a1[v8] = 0;
  return result;
}

uint64_t concatExtractPath(char *a1, size_t a2, char *__s, const char *a4)
{
  size_t v8 = strlen(__s);
  size_t v9 = strlen(a4);
  if (!v8)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 278, 3, 0, "invalid dir: %s", v10, v11, (char)__s);
    return 0xFFFFFFFFLL;
  }
  unint64_t v12 = v9;
  if (v8 + v9 + 1 >= a2)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 279, 3, 0, "dir/path too long: %s", v10, v11, (char)__s);
    return 0xFFFFFFFFLL;
  }
  strlcpy(a1, __s, a2);
  if (!v12) {
    return 0;
  }
  int64_t v13 = 0;
  memset(&v29, 0, sizeof(v29));
  while (1)
  {
    uint64_t v14 = &a4[v13];
    unint64_t v15 = strchr((char *)&a4[v13], 47);
    int64_t v18 = v15 - a4;
    if (v15) {
      unint64_t v19 = v15 - a4;
    }
    else {
      unint64_t v19 = v12;
    }
    size_t v20 = v19 - v13;
    if (v19 == v13)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 297, 3, 0, "invalid path: %s", v16, v17, (char)a4);
      return 0xFFFFFFFFLL;
    }
    uint64_t v21 = v15;
    if (v20 != 2)
    {
      if (v20 == 1 && *v14 == 46) {
        goto LABEL_29;
      }
      goto LABEL_15;
    }
    if (*v14 == 46 && a4[v13 + 1] == 46) {
      break;
    }
LABEL_15:
    int v22 = lstat(a1, &v29);
    if (v13)
    {
      if (v22)
      {
        if (mkdir(a1, 0x1EDu) && (lstat(a1, &v29) || (v29.st_mode & 0xF000) != 0x4000))
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 326, 3, 0, "a parent of path is not a directory: %s", v25, v26, (char)a4);
          return 0xFFFFFFFFLL;
        }
      }
      else if ((v29.st_mode & 0xF000) != 0x4000)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 316, 3, 0, "a parent of path is not a directory: %s", v23, v24, (char)a4);
        return 0xFFFFFFFFLL;
      }
    }
    else if (v22 || (int v27 = v29.st_mode & 0xF000, v27 != 0x4000) && v27 != 40960)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 311, 3, 0, "dir doesn't exist, or is invalid: %s", v23, v24, (char)__s);
      return 0xFFFFFFFFLL;
    }
    if (a1[v8 - 1] != 47) {
      a1[v8++] = 47;
    }
    memcpy(&a1[v8], &a4[v13], v20);
    v8 += v20;
    a1[v8] = 0;
LABEL_29:
    if (v21)
    {
      int64_t v13 = v18 + 1;
      if (v18 + 1 < v12) {
        continue;
      }
    }
    return 0;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 304, 3, 0, "invalid path: %s", v16, v17, (char)a4);
  return 0xFFFFFFFFLL;
}

BOOL pathIsValid(unsigned char *a1, size_t __n)
{
  if (!__n) {
    return 1;
  }
  if (__n > 0x3FF) {
    return 0;
  }
  int v5 = memchr(a1, 0, __n);
  BOOL result = 0;
  if (v5) {
    return result;
  }
  if (*a1 == 47) {
    return 0;
  }
  uint64_t v6 = 0;
  do
  {
    uint64_t v7 = &a1[v6];
    size_t v8 = memchr(&a1[v6], 47, __n - v6);
    if (!v8) {
      break;
    }
    uint64_t v9 = v8 - a1;
    uint64_t v10 = v8 - a1 - v6;
    if (v8 - a1 == v6) {
      return 0;
    }
    if (v6 && v10 == 1)
    {
      int v11 = *v7;
      goto LABEL_13;
    }
    if (v10 == 2 && *v7 == 46)
    {
      int v11 = a1[v6 + 1];
LABEL_13:
      if (v11 == 46) {
        return 0;
      }
    }
    uint64_t v6 = v9 + 1;
  }
  while (v9 + 1 < __n);
  return v6 != __n;
}

uint64_t getTempDir(char *a1, size_t a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  stat v4 = (const char *)confstr(65537, a1, a2);
  if (!v4)
  {
    if (issetugid())
    {
      stat v4 = 0;
    }
    else
    {
      stat v4 = getenv("TMPDIR");
      if (v4) {
        stat v4 = (const char *)strlcpy(a1, v4, a2);
      }
    }
  }
  if ((unint64_t)v4 >= a2) {
    return 0xFFFFFFFFLL;
  }
  size_t v6 = strlen(a1);
  do
  {
    size_t v7 = v6;
    if (!v6) {
      break;
    }
    --v6;
  }
  while (a1[v7 - 1] == 47);
  a1[v7] = 0;
  if (v7) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t loadFileContents(const char *a1, char **a2, off_t *a3, uint64_t a4)
{
  memset(&v31, 0, sizeof(v31));
  if (lstat(a1, &v31))
  {
    size_t v8 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"loadFileContents", 475, 3, *v8, "%s", v9, v10, (char)a1);
    int v11 = 0;
    goto LABEL_3;
  }
  off_t st_size = v31.st_size;
  if (v31.st_size)
  {
    int v11 = (char *)malloc(v31.st_size + a4);
    if (v11)
    {
      int v14 = open(a1, 0);
      if ((v14 & 0x80000000) == 0)
      {
        int v15 = v14;
        uint64_t v16 = v11;
        unint64_t v17 = st_size;
        while (1)
        {
          if (v17 >= 0x40000000) {
            size_t v18 = 0x40000000;
          }
          else {
            size_t v18 = v17;
          }
          ssize_t v19 = read(v15, v16, v18);
          if (v19 < 0)
          {
            int v27 = *__error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"loadFileContents", 499, 3, v27, "%s", v28, v29, (char)a1);
            goto LABEL_23;
          }
          if (v19 != v18) {
            break;
          }
          v16 += v18;
          v17 -= v18;
          if (!v17)
          {
            close(v15);
            goto LABEL_17;
          }
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"loadFileContents", 500, 3, 0, "reading contents: %s", v20, v21, (char)a1);
LABEL_23:
        close(v15);
        goto LABEL_3;
      }
      int v22 = *__error();
      char v30 = (char)a1;
      uint64_t v25 = "%s";
      __int16 v26 = 486;
    }
    else
    {
      int v22 = *__error();
      uint64_t v25 = "malloc";
      __int16 v26 = 482;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"loadFileContents", v26, 3, v22, v25, v23, v24, v30);
LABEL_3:
    free(v11);
    int v11 = 0;
    off_t st_size = 0;
    uint64_t result = 0xFFFFFFFFLL;
    goto LABEL_4;
  }
  int v11 = 0;
LABEL_17:
  uint64_t result = 0;
LABEL_4:
  *a2 = v11;
  *a3 = st_size;
  return result;
}

uint64_t loadFileSegment(const char *a1, void *a2, size_t a3, off_t a4)
{
  char v7 = (char)a1;
  int v8 = open(a1, 0);
  if (v8 < 0)
  {
    int v15 = *__error();
    char v17 = v7;
    int64_t v13 = "%s";
    __int16 v14 = 521;
    goto LABEL_7;
  }
  int v9 = v8;
  unint64_t v10 = pread(v8, a2, a3, a4);
  close(v9);
  if ((v10 & 0x8000000000000000) != 0)
  {
    int v15 = *__error();
    char v17 = v7;
    int64_t v13 = "%s";
    __int16 v14 = 524;
    goto LABEL_7;
  }
  if (v10 < a3)
  {
    int64_t v13 = "truncated read";
    __int16 v14 = 525;
    int v15 = 0;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"loadFileSegment", v14, 3, v15, v13, v11, v12, v17);
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t storeFileContents(const char *a1, uint64_t a2, unint64_t a3)
{
  char v5 = (char)a1;
  int v6 = open(a1, 1537, 420);
  if (v6 < 0)
  {
    __int16 v14 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"storeFileContents", 535, 3, *v14, "%s", v15, v16, v5);
    int v13 = 0;
  }
  else
  {
    int v7 = v6;
    if (a3)
    {
      unint64_t v8 = 0;
      while (1)
      {
        if (a3 - v8 >= 0x10000000) {
          size_t v9 = 0x10000000;
        }
        else {
          size_t v9 = a3 - v8;
        }
        ssize_t v10 = write(v7, (const void *)(a2 + v8), v9);
        if (v10 < 0)
        {
          int v17 = *__error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"storeFileContents", 544, 3, v17, "%s", v18, v19, v5);
          goto LABEL_14;
        }
        if (!v10) {
          break;
        }
        v8 += v10;
        if (v8 >= a3) {
          goto LABEL_10;
        }
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"storeFileContents", 545, 3, 0, "write error: %s", v11, v12, v5);
LABEL_14:
      int v13 = 0;
    }
    else
    {
LABEL_10:
      int v13 = 1;
    }
    close(v7);
  }
  if (v13) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t copyFileSegment(const char *a1, unint64_t a2, unint64_t a3, const char *a4)
{
  ssize_t v10 = (unint64_t *)MemBufferCreate(0x100000uLL);
  if (v10)
  {
    int v13 = (char *)IFileStreamCreateWithFilename(a1, a2, a3);
    if (v13)
    {
      uint64_t v16 = OFileStreamCreateWithFilename(a4, a3);
      if (v16)
      {
        if ((MemBufferTransmit(v10, a3, (size_t (*)(int, void *, size_t))IFileStreamRead, (uint64_t)v13, (uint64_t (*)(uint64_t, uint64_t, uint64_t))OFileStreamWrite, (uint64_t)v16, v14, v15) & 0x8000000000000000) == 0)
        {
          int v19 = 0;
          goto LABEL_11;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileSegment", 569, 3, 0, "copy failed: %s to %s", v17, v18, (char)a1);
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileSegment", 566, 3, 0, "opening file: %s", v14, v15, (char)a4);
      }
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileSegment", 565, 3, 0, "opening file: %s", v11, v12, (char)a1);
      uint64_t v16 = 0;
    }
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileSegment", 564, 3, 0, "mem buffer creation", v8, v9, v21);
    uint64_t v16 = 0;
    int v13 = 0;
  }
  int v19 = 1;
LABEL_11:
  IFileStreamDestroy(v13);
  OFileStreamDestroy(v16);
  MemBufferDestroy((void **)v10);
  if (v19) {
    unlink(a4);
  }
  return (v19 << 31 >> 31);
}

uint64_t statIsCompressed(unsigned int a1)
{
  if ((a1 & 0x40000000) != 0) {
    return 0;
  }
  else {
    return (a1 >> 5) & 1;
  }
}

uint64_t getFileAPFSInternalFlags()
{
  return 0;
}

uint64_t areFilesEqual(const char *a1, const char *a2)
{
  memset(&v39, 0, sizeof(v39));
  memset(&v38, 0, sizeof(v38));
  if (stat(a1, &v39))
  {
    int v4 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 708, 3, v4, "%s", v5, v6, (char)a1);
LABEL_5:
    ssize_t v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0xFFFFFFFFLL;
    goto LABEL_6;
  }
  if (stat(a2, &v38))
  {
    int v7 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 709, 3, v7, "%s", v8, v9, (char)a2);
    goto LABEL_5;
  }
  if ((v39.st_mode & 0xF000) != 0x8000 || (v38.st_mode & 0xF000) != 0x8000 || v39.st_size != v38.st_size)
  {
    ssize_t v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    goto LABEL_6;
  }
  int v14 = open(a1, 0);
  if (v14 < 0)
  {
    int v22 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 714, 3, v22, "%s", v23, v24, (char)a1);
    goto LABEL_5;
  }
  int v15 = v14;
  int v16 = open(a2, 0);
  if (v16 < 0)
  {
    uint64_t v25 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 716, 3, *v25, "%s", v26, v27, (char)a2);
    close(v15);
    goto LABEL_5;
  }
  int v17 = v16;
  uint64_t v11 = malloc(0x40000uLL);
  uint64_t v18 = malloc(0x40000uLL);
  ssize_t v10 = v18;
  if (!v11 || !v18)
  {
    uint64_t v28 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 719, 3, *v28, "malloc", v29, v30, v37);
    close(v15);
    uint64_t v12 = 0xFFFFFFFFLL;
    goto LABEL_29;
  }
  while (1)
  {
    ssize_t v19 = read(v15, v11, 0x40000uLL);
    if (v19 < 0)
    {
      int v31 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 723, 3, v31, "%s read", v32, v33, (char)a1);
LABEL_26:
      uint64_t v12 = 0xFFFFFFFFLL;
      goto LABEL_28;
    }
    size_t v20 = v19;
    ssize_t v21 = read(v17, v10, 0x40000uLL);
    if (v21 < 0)
    {
      int v34 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 725, 3, v34, "%s read", v35, v36, (char)a2);
      goto LABEL_26;
    }
    if (v20 != v21) {
      goto LABEL_19;
    }
    if (!v20) {
      break;
    }
    if (memcmp(v11, v10, v20))
    {
LABEL_19:
      uint64_t v12 = 0;
      goto LABEL_28;
    }
  }
  uint64_t v12 = 1;
LABEL_28:
  close(v15);
  if ((v17 & 0x80000000) == 0) {
LABEL_29:
  }
    close(v17);
LABEL_6:
  free(v11);
  free(v10);
  return v12;
}

uint64_t areFilesEqual2()
{
  uint64_t v0 = (char *)MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  unint64_t v3 = v0;
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (concatPath(v7, 0x800uLL, v0, v4) || concatPath(v6, 0x800uLL, v3, v2)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return areFilesEqual(v7, v6);
  }
}

uint64_t getFilesystemBlockSize(const char *a1)
{
  char v1 = (char)a1;
  uint64_t v7 = *MEMORY[0x263EF8340];
  memset(&v6, 0, 512);
  if ((statfs(a1, &v6) & 0x80000000) == 0) {
    return v6.f_bsize;
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFilesystemBlockSize", 752, 3, "statfs failed: %s\n", v2, v3, v4, v1);
  return 4096;
}

uint64_t getFileDiskUsage(const char *a1)
{
  memset(&v12, 0, sizeof(v12));
  if (lstat(a1, &v12))
  {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileDiskUsage", 765, 3, "stat failed: %s\n", v2, v3, v4, (char)a1);
    return -1;
  }
  else
  {
    if (v12.st_blocks << 9 >= (unint64_t)v12.st_size || v12.st_blocks << 9 == 0) {
      off_t st_size = v12.st_size;
    }
    else {
      off_t st_size = v12.st_blocks << 9;
    }
    if ((v12.st_mode & 0xF000) == 0x8000)
    {
      uint64_t v10 = 0;
      off_t v11 = 0;
      int v7 = ParallelCompressionAFSCGetMetadata(a1, &v11, (unsigned int *)&v10 + 1, &v10);
      if (HIDWORD(v10) != -1 && v7 == 0) {
        return v10;
      }
    }
  }
  return st_size;
}

uint64_t setFileAPFSInternalFlagsFD(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t getFileProtectionClass(const char *a1)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  v4[1] = 0;
  v4[2] = 0;
  memset(v5, 0, sizeof(v5));
  v4[0] = 0x4000000000000005;
  int v1 = getattrlist(a1, v4, v5, 0x40uLL, 1u);
  if (LODWORD(v5[0]) == 8 && v1 == 0) {
    return DWORD1(v5[0]);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t clearEntryXAT(const char *a1)
{
  ssize_t v2 = listxattr(a1, 0, 0, 1);
  if (v2 < 0)
  {
    uint64_t v9 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"clearEntryXAT", 912, 3, *v9, "listxattr failed: %s", v10, v11, (char)a1);
    uint64_t v4 = 0;
    goto LABEL_20;
  }
  size_t v3 = v2;
  if (!v2)
  {
    uint64_t v4 = 0;
LABEL_15:
    uint64_t v12 = 0;
    goto LABEL_21;
  }
  uint64_t v4 = (char *)malloc(v2);
  if (!v4)
  {
    int v13 = *__error();
    int v16 = "malloc";
    __int16 v17 = 918;
    goto LABEL_19;
  }
  ssize_t v5 = listxattr(a1, v4, v3, 1);
  if (v5 < 0)
  {
    int v18 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"clearEntryXAT", 927, 3, v18, "listxattr failed: %s", v19, v20, (char)a1);
    goto LABEL_20;
  }
  ssize_t v6 = v5;
  if (!v5) {
    goto LABEL_15;
  }
  uint64_t v7 = 0;
  uint64_t v8 = v4;
  while (v4[v7])
  {
    ++v7;
LABEL_11:
    if (v7 == v6) {
      goto LABEL_15;
    }
  }
  if ((removexattr(a1, v8, 1) & 0x80000000) == 0)
  {
    uint64_t v8 = &v4[++v7];
    goto LABEL_11;
  }
  int v13 = *__error();
  char v22 = (char)v8;
  int v16 = "removexattr failed for name=%s: %s";
  __int16 v17 = 941;
LABEL_19:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"clearEntryXAT", v17, 3, v13, v16, v14, v15, v22);
LABEL_20:
  uint64_t v12 = 0xFFFFFFFFLL;
LABEL_21:
  free(v4);
  return v12;
}

uint64_t getBufferSHA1Digest(uint64_t a1, unint64_t a2, unsigned __int8 *a3)
{
  memset(&v11, 0, sizeof(v11));
  CC_SHA1_Init(&v11);
  if (a2)
  {
    unint64_t v6 = 0;
    CC_LONG v7 = a2;
    do
    {
      unint64_t v8 = v6 + 0x100000;
      if (v6 + 0x100000 <= a2) {
        CC_LONG v9 = 0x100000;
      }
      else {
        CC_LONG v9 = v7;
      }
      CC_SHA1_Update(&v11, (const void *)(a1 + v6), v9);
      v7 -= 0x100000;
      unint64_t v6 = v8;
    }
    while (v8 < a2);
  }
  CC_SHA1_Final(a3, &v11);
  return 0;
}

uint64_t getFileDigests(char *a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned int *a4)
{
  char v7 = (char)a1;
  if (!a2 && !a3 && !a4) {
    return 0;
  }
  memset(&c, 0, sizeof(c));
  memset(&v27, 0, sizeof(v27));
  v26[0] = 0;
  v26[1] = 0;
  int v9 = open(a1, 0);
  if (v9 < 0)
  {
    uint64_t v19 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileDigests", 983, 3, *v19, "%s", v20, v21, v7);
    int v18 = 0;
  }
  else
  {
    int v10 = v9;
    CC_SHA1_CTX v11 = valloc(0x100000uLL);
    if (v11)
    {
      uint64_t v12 = v11;
      if (a2) {
        CC_SHA1_Init(&c);
      }
      if (a3) {
        CC_SHA256_Init(&v27);
      }
      if (a4) {
        CC_CKSUM_Init((uint64_t)v26);
      }
      ssize_t v13 = read(v10, v12, 0x100000uLL);
      if (v13 < 0)
      {
LABEL_23:
        uint64_t v15 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileDigests", 997, 3, *v15, "read", v16, v17, v25);
        int v18 = 0;
      }
      else
      {
        ssize_t v14 = v13;
        while (v14)
        {
          if (a2) {
            CC_SHA1_Update(&c, v12, v14);
          }
          if (a3) {
            CC_SHA256_Update(&v27, v12, v14);
          }
          if (a4) {
            CC_CKSUM_Update((uint64_t)v26, (unsigned __int8 *)v12, v14);
          }
          ssize_t v14 = read(v10, v12, 0x100000uLL);
          if (v14 < 0) {
            goto LABEL_23;
          }
        }
        if (a2) {
          CC_SHA1_Final(a2, &c);
        }
        if (a3) {
          CC_SHA256_Final(a3, &v27);
        }
        if (a4) {
          CC_CKSUM_Final(a4, (uint64_t)v26);
        }
        int v18 = 1;
      }
      free(v12);
    }
    else
    {
      char v22 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileDigests", 987, 3, *v22, "malloc", v23, v24, v25);
      int v18 = 0;
    }
    close(v10);
  }
  if (v18) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t getFileSHA1Digest(const char *a1, uint64_t a2)
{
  return getFileSegmentSHA1Digest(a1, 0, 0xFFFFFFFFFFFFFFFFLL, a2);
}

uint64_t getFileSegmentSHA1Digest(const char *a1, off_t a2, unint64_t a3, uint64_t a4)
{
  char v7 = (char)a1;
  int v8 = open(a1, 0);
  if (v8 < 0)
  {
    uint64_t v12 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileSegmentSHA1Digest", 1025, 3, *v12, "%s", v13, v14, v7);
    return 0xFFFFFFFFLL;
  }
  else
  {
    int v9 = v8;
    uint64_t FileSegmentSHA1DigestFD = getFileSegmentSHA1DigestFD(v8, a2, a3, a4);
    close(v9);
    return FileSegmentSHA1DigestFD;
  }
}

uint64_t getFileSegmentSHA1DigestFD(int a1, off_t a2, unint64_t a3, uint64_t a4)
{
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  *(_DWORD *)(a4 + 16) = 0;
  char v24 = 1;
  if (fcntl(a1, 48)) {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileSegmentSHA1DigestFD", 1044, 3, "Warning: couldn't set F_NOCACHE\n", v8, v9, v10, 1);
  }
  memset(&c, 0, sizeof(c));
  CC_SHA1_CTX v11 = valloc(0x100000uLL);
  if (!v11)
  {
    int v18 = *__error();
    uint64_t v21 = "malloc";
    __int16 v22 = 1049;
LABEL_15:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileSegmentSHA1DigestFD", v22, 3, v18, v21, v19, v20, v24);
LABEL_16:
    uint64_t v17 = 0xFFFFFFFFLL;
    goto LABEL_17;
  }
  CC_SHA1_Init(&c);
  if (a3)
  {
    while (1)
    {
      if (a3 >= 0x100000) {
        size_t v12 = 0x100000;
      }
      else {
        size_t v12 = a3;
      }
      unint64_t v13 = pread(a1, v11, v12, a2);
      if ((v13 & 0x8000000000000000) != 0)
      {
        int v18 = *__error();
        uint64_t v21 = "read";
        __int16 v22 = 1059;
        goto LABEL_15;
      }
      unint64_t v16 = v13;
      if (!v13) {
        goto LABEL_12;
      }
      if (v13 > v12) {
        break;
      }
      CC_SHA1_Update(&c, v11, v13);
      a2 += v16;
      a3 -= v16;
      if (!a3) {
        goto LABEL_12;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileSegmentSHA1DigestFD", 1062, 3, 0, "error: read more bytes than requested: %zd (requested %zu)", v14, v15, v13);
    goto LABEL_16;
  }
LABEL_12:
  CC_SHA1_Final((unsigned __int8 *)a4, &c);
  uint64_t v17 = 0;
LABEL_17:
  free(v11);
  return v17;
}

uint64_t enumerateTree(void *a1, char *__s)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  size_t v3 = strlen(__s);
  if (v3 - 1024 < 0xFFFFFFFFFFFFFBFFLL) {
    return 0xFFFFFFFFLL;
  }
  size_t v5 = v3;
  bzero(v7, 0x400uLL);
  __memcpy_chk();
  do
  {
    uint64_t v6 = v5;
    if (!v5) {
      break;
    }
    --v5;
  }
  while (v7[v6 - 1] == 47);
  v7[v6] = 0;
  return enumerateTree_rec(a1, v7, v6);
}

uint64_t removeFile(const char *a1)
{
  memset(&v3, 0, sizeof(v3));
  if (lstat(a1, &v3)) {
    return 0;
  }
  if ((v3.st_mode & 0xF000) == 0x4000) {
    return 0xFFFFFFFFLL;
  }
  if ((v3.st_flags & 0x20002) != 0) {
    lchflags(a1, v3.st_flags & 0xFFFDFFFD);
  }
  return unlink(a1);
}

uint64_t enumerateTree_rec(void *a1, const char *a2, uint64_t a3)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  if (a3) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = "/";
  }
  char v7 = opendir(v6);
  if (v7)
  {
    memset(&v33, 0, 512);
    uint64_t v32 = 0;
    uint64_t v8 = (uint64_t (*)(void, const char *))a1[1];
    if (v8 && (v8(*a1, a2) & 0x80000000) != 0)
    {
LABEL_35:
      int v28 = 0;
    }
    else
    {
      uint64_t v9 = a3 + 1;
      uint64_t v10 = (char *)&a2[a3];
      CC_SHA1_CTX v11 = (char *)&a2[a3 + 1];
      while (1)
      {
        if (readdir_r(v7, &v33, &v32))
        {
          char v25 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"enumerateTree_rec", 1143, 3, *v25, "readdir_r", v26, v27, v30);
          goto LABEL_35;
        }
        if (!v32) {
          break;
        }
        size_t d_namlen = v33.d_namlen;
        if ((v33.d_namlen != 1 || v33.d_name[0] != 46)
          && (v33.d_namlen != 2 || v33.d_name[0] != 46 || v33.d_name[1] != 46))
        {
          unint64_t v13 = v9 + v33.d_namlen;
          if (v13 > 0x3FF) {
            goto LABEL_35;
          }
          *uint64_t v10 = 47;
          memcpy(v11, v33.d_name, d_namlen);
          a2[v13] = 0;
          memset(&v31, 0, sizeof(v31));
          int v14 = lstat(a2, &v31);
          if (v14)
          {
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"enumerateTree_rec", 1170, 3, "lstat after readdir failed (errno=%d): %s", v15, v16, v17, v14);
          }
          else if ((v31.st_flags & 0x40000000) != 0)
          {
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"enumerateTree_rec", 1175, 3, "skip dataless: %s", v15, v16, v17, (char)a2);
          }
          else
          {
            int d_type = v33.d_type;
            if (!v33.d_type)
            {
              if ((v31.st_mode & 0xF000) == 0x4000)
              {
                int d_type = 4;
                v33.int d_type = 4;
              }
              else
              {
                int d_type = 0;
              }
            }
            uint64_t v19 = (int (*)(void, const char *))a1[3];
            if (v19)
            {
              BOOL v20 = v19(*a1, a2) >= 0;
              int d_type = v33.d_type;
            }
            else
            {
              BOOL v20 = 1;
            }
            if (d_type == 4 && (int)enumerateTree_rec(a1, a2, v13) < 0) {
              BOOL v20 = 0;
            }
            *uint64_t v10 = 0;
            if (!v20) {
              goto LABEL_35;
            }
          }
        }
      }
      int v28 = 1;
    }
    closedir(v7);
    uint64_t v29 = (int (*)(void, const char *))a1[2];
    if (v29 && v29(*a1, a2) < 0) {
      int v28 = 0;
    }
    if (v28) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    uint64_t v21 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"enumerateTree_rec", 1126, 3, *v21, "%s", v22, v23, (char)a2);
    return 0xFFFFFFFFLL;
  }
}

uint64_t removeTree(char *__s)
{
  v2[0] = 0;
  v2[1] = 0;
  v2[3] = removeEntryProc;
  v2[2] = removeLeaveDirProc;
  return enumerateTree(v2, __s);
}

uint64_t removeEntryProc(int a1, char *a2)
{
  memset(&v8, 0, sizeof(v8));
  if (lstat(a2, &v8))
  {
    __int16 v3 = 1247;
LABEL_3:
    uint64_t v4 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"removeEntryProc", v3, 3, *v4, "%s", v5, v6, (char)a2);
    return 0xFFFFFFFFLL;
  }
  if ((v8.st_mode & 0xF000) == 0x4000) {
    return 0;
  }
  uint64_t result = unlink(a2);
  if (result)
  {
    __int16 v3 = 1250;
    goto LABEL_3;
  }
  return result;
}

uint64_t removeLeaveDirProc(int a1, char *a2)
{
  char v2 = (char)a2;
  uint64_t result = rmdir(a2);
  if (result)
  {
    uint64_t v4 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"removeLeaveDirProc", 1258, 3, *v4, "%s", v5, v6, v2);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t statIsDataless(unsigned int a1)
{
  return (a1 >> 30) & 1;
}

uint64_t ParallelArchiveExtractSubtree(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v26);
  bzero(&v36, 0x430uLL);
  uint64_t v10 = *(const char **)(a2 + 16);
  strncpy(v38, v10, 0x400uLL);
  size_t v39 = strlen(v10);
  uint64_t v37 = a1;
  int v18 = *(_DWORD *)a2;
  int v36 = *(_DWORD *)a2;
  int v19 = *(_DWORD *)(a2 + 8) & 1;
  int v40 = v19;
  if (v39)
  {
    if (v18 >= 1)
    {
      BOOL v20 = (FILE *)*MEMORY[0x263EF8348];
      if (v19) {
        fprintf(v20, "Extracting all entries not in subtree: %s\n");
      }
      else {
        fprintf(v20, "Extracting subtree: %s\n");
      }
    }
    long long v32 = 0u;
    long long v33 = 0u;
    uint64_t v28 = *(void *)a2;
    uint64_t v21 = *(void *)(a2 + 40);
    long long v29 = *(_OWORD *)(a2 + 24);
    uint64_t v30 = v21;
    stat v31 = extractSubtreeBegin;
    *((void *)&v32 + 1) = extractSubtreeData;
    *(void *)&long long v33 = extractSubtreeData;
    uint64_t v34 = extractSubtreeData;
    uint64_t v35 = &v36;
    if ((ParallelArchiveRead((uint64_t)&v28, v11, v12, v13, v14, v15, v16, v17) & 0x80000000) == 0)
    {
      uint64_t result = leaveThreadErrorContext(0, 0, 0);
      if ((result & 0x80000000) == 0)
      {
        if (*(int *)a2 >= 1)
        {
          char v25 = (FILE **)MEMORY[0x263EF8348];
          fprintf((FILE *)*MEMORY[0x263EF8348], "%12llu entries in input archive\n", v41);
          fprintf(*v25, "%12llu entries in subtree\n", v42);
        }
        return 0;
      }
      return result;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractSubtree.c", (uint64_t)"ParallelArchiveExtractSubtree", 116, 69, 0, "reading archive", v22, v23, v27);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractSubtree.c", (uint64_t)"ParallelArchiveExtractSubtree", 95, 69, 0, "Invalid path length for subtree: %s\n", v16, v17, (char)v10);
  }
  uint64_t result = leaveThreadErrorContext(0, 0, 0);
  if ((result & 0x80000000) == 0) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

size_t extractSubtreeBegin(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  *(_DWORD *)(a1 + 1052) = 0;
  ++*(void *)(a1 + 1056);
  size_t result = (size_t)memcpy(__dst, a2, sizeof(__dst));
  if (__dst[1] == 77)
  {
    *(_DWORD *)(a1 + 1052) = 1;
  }
  else
  {
    if ((__dst[0] & 0x8000) == 0) {
      return result;
    }
    size_t v15 = *(void *)(a1 + 1040);
    size_t result = strlen((const char *)&__dst[36]);
    size_t v16 = result;
    if (result < v15 || (size_t result = memcmp(&__dst[36], (const void *)(a1 + 16), v15), result))
    {
      int v17 = 0;
    }
    else
    {
      if (*((unsigned char *)&__dst[36] + v15)) {
        BOOL v18 = *((unsigned char *)&__dst[36] + v15) == 47;
      }
      else {
        BOOL v18 = 1;
      }
      int v17 = v18;
    }
    *(_DWORD *)(a1 + 1052) = v17;
    if (*(_DWORD *)(a1 + 1048))
    {
      *(_DWORD *)(a1 + 1052) = v17 ^ 1;
      if (v17) {
        return result;
      }
    }
    else
    {
      if (!v17) {
        return result;
      }
      if (v16 == v15) {
        LOBYTE(__dst[36]) = 0;
      }
      else {
        strncpy((char *)&__dst[36], (const char *)a2 + v15 + 145, 0x400uLL);
      }
    }
  }
  ++*(void *)(a1 + 1064);
  if (*(int *)a1 >= 2) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%s\n", (const char *)&__dst[36]);
  }
  size_t result = ParallelArchiveWriteEntryHeader(*(void *)(a1 + 8), (uint64_t)__dst, a3, a4, v9, v10, v11, v12);
  if ((result & 0x80000000) != 0)
  {
    size_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractSubtree.c", (uint64_t)"extractSubtreeBegin", 70, 69, 0, "writing entry header", v13, v14, v19);
    *(_DWORD *)(a1 + 1052) = 0;
  }
  return result;
}

size_t extractSubtreeData(size_t result, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (*(_DWORD *)(result + 1052))
  {
    size_t result = ParallelArchiveWriteEntryData(*(void *)(result + 8), a2, a3, a4, a5, a6, a7, a8);
    if ((result & 0x80000000) != 0)
    {
      return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractSubtree.c", (uint64_t)"extractSubtreeData", 77, 69, 0, "writing entry data", v9, v10, a9);
    }
  }
  return result;
}

uint64_t io_hint_static_content(unsigned int **a1)
{
  int FD = aaFileStreamGetFD(a1);
  if (FD < 0)
  {
    uint64_t v6 = "file not open";
    __int16 v7 = 63;
  }
  else
  {
    char v8 = 1;
    if (fcntl(FD, 68) != -1) {
      return 0;
    }
    uint64_t v6 = "static content hint failed";
    __int16 v7 = 64;
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_hint_static_content", v7, 137, v6, v2, v3, v4, v8);
  return 0xFFFFFFFFLL;
}

uint64_t io_preallocate(unsigned int **a1, unint64_t a2)
{
  getRealTime();
  int FD = aaFileStreamGetFD(a1);
  memset(&v25, 0, sizeof(v25));
  if (FD < 0)
  {
    size_t v15 = "file not open";
    __int16 v16 = 84;
LABEL_12:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_preallocate", v16, 137, v15, v5, v6, v7, v21);
    LOBYTE(v10) = 0;
    goto LABEL_13;
  }
  int v8 = FD;
  if (fstat(FD, &v25) || v25.st_size)
  {
    size_t v15 = "file not empty";
    __int16 v16 = 85;
    goto LABEL_12;
  }
  pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_preallocate", 88, 137, "preallocating %llu B", v5, v6, v7, a2);
  if (!a2)
  {
    uint64_t v14 = 0;
    LOBYTE(v10) = 0;
    goto LABEL_14;
  }
  int v9 = 0;
  unint64_t v10 = 0;
  while (1)
  {
    v23[0] = 0x300000002;
    v23[1] = 0;
    v23[2] = a2 - v10;
    uint64_t v24 = 0;
    if (fcntl(v8, 42, v23) == -1 || v24 <= 0) {
      break;
    }
    v10 += v24;
    ++v9;
    if (v10 >= a2)
    {
      uint64_t v14 = 0;
      goto LABEL_14;
    }
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_preallocate", 99, 137, "preallocation failed", v11, v12, v13, v22);
LABEL_13:
  uint64_t v14 = 0xFFFFFFFFLL;
LABEL_14:
  getRealTime();
  pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_preallocate", 110, 137, "preallocation %llu/%llu B took %0.2f seconds (# of calls=%i)", v17, v18, v19, v10);
  return v14;
}

uint64_t io_set_nocache(unsigned int **a1)
{
  int FD = aaFileStreamGetFD(a1);
  if (FD < 0)
  {
    uint64_t v5 = "aaFileStreamGetFD";
    __int16 v6 = 126;
    int v7 = 0;
  }
  else
  {
    char v8 = 1;
    if (fcntl(FD, 48) != -1) {
      return 0;
    }
    int v7 = *__error();
    uint64_t v5 = "fcntl";
    __int16 v6 = 127;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_set_nocache", v6, 137, v7, v5, v2, v3, v8);
  return 0xFFFFFFFFLL;
}

uint64_t **aaSegmentStreamOpen(void *a1, void *a2)
{
  uint64_t v3 = (uint64_t **)SegmentStreamCreate(a1, (uint64_t)a2);
  uint64_t v4 = v3;
  if (v3)
  {
    uint64_t v5 = *v3;
    uint64_t v12 = pc_array_indirect_sort(a2[267], compare_extents_by_position);
    if (v12)
    {
      unint64_t v13 = 0;
      unint64_t v14 = 0;
      unint64_t v15 = a2[269];
      do
      {
        if (v13 >= v15)
        {
          unint64_t v17 = 0;
          __int16 v16 = a2 + 265;
        }
        else
        {
          __int16 v16 = (unint64_t *)v12[v13];
          unint64_t v17 = v16[1];
        }
        unint64_t v18 = *v16;
        BOOL v19 = *v16 >= v14;
        unint64_t v20 = *v16 - v14;
        if (v20 != 0 && v19)
        {
          uint64_t v40 = v5[397];
          unint64_t v41 = v20;
          unint64_t v42 = v14;
          int v43 = 0;
          char v44 = 0;
          v5[397] = v40 + v20;
          char v21 = pc_array_append(v5[395], &v40, v6, v7, v8, v9, v10, v11);
          v5[395] = (uint64_t)v21;
          if (!v21)
          {
            uint64_t v37 = "segment_add";
            __int16 v38 = 476;
            goto LABEL_28;
          }
          unint64_t v15 = a2[269];
        }
        unint64_t v14 = v18 + v17;
        ++v13;
      }
      while (v13 <= v15);
      uint64_t v22 = v5[397];
      a2[258] = v22;
      unint64_t v23 = a2[270];
      if (v23)
      {
        uint64_t v24 = 0;
        while (1)
        {
          uint64_t v25 = a2[267];
          uint64_t v26 = a2[268] + 440 * v24;
          *(void *)(v26 + 32) = 0;
          char v27 = (void *)(v26 + 32);
          v27[1] = v5[397];
          if (v27[49]) {
            break;
          }
LABEL_19:
          if (++v24 >= v23)
          {
            uint64_t v22 = v5[397];
            goto LABEL_21;
          }
        }
        uint64_t v28 = 0;
        long long v29 = (void *)v5[395];
        uint64_t v30 = (uint64_t *)(v25 + 16 * v27[48] + 8);
        while (1)
        {
          unint64_t v32 = *(v30 - 1);
          unint64_t v31 = *v30;
          uint64_t v40 = v5[397];
          unint64_t v41 = v31;
          unint64_t v42 = v32;
          int v43 = 0;
          char v44 = 0;
          v5[397] = v40 + v31;
          long long v29 = pc_array_append((uint64_t)v29, &v40, v6, v7, v8, v9, v10, v11);
          v5[395] = (uint64_t)v29;
          if (!v29) {
            break;
          }
          uint64_t v33 = *v30;
          v30 += 2;
          *v27 += v33;
          if ((unint64_t)++v28 >= v27[49])
          {
            unint64_t v23 = a2[270];
            goto LABEL_19;
          }
        }
        uint64_t v37 = "segment_add";
        __int16 v38 = 500;
      }
      else
      {
LABEL_21:
        v5[396] = *(void *)(v5[395] - 64);
        if (v22 == a2[265])
        {
          free(v12);
          return v4;
        }
        uint64_t v37 = "bad image";
        __int16 v38 = 507;
      }
    }
    else
    {
      uint64_t v37 = "pc_array_indirect_sort";
      __int16 v38 = 465;
    }
LABEL_28:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaSegmentStreamOpen", v38, 137, 0, v37, v10, v11, v40);
  }
  else
  {
    uint64_t v34 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaSegmentStreamOpen", 457, 137, *v34, "aaSegmentStreamOpen", v35, v36, v40);
    uint64_t v12 = 0;
    uint64_t v5 = 0;
  }
  free(v12);
  free(v4);
  SegmentStreamClose((uint64_t)v5);
  return 0;
}

void *SegmentStreamCreate(void *a1, uint64_t a2)
{
  uint64_t v4 = calloc(1uLL, 0x68uLL);
  uint64_t v5 = calloc(1uLL, 0xC78uLL);
  uint64_t v8 = v5;
  if (!v4 || !v5)
  {
    int v9 = *__error();
    uint64_t v10 = "malloc";
    __int16 v11 = 416;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"SegmentStreamCreate", v11, 137, v9, v10, v6, v7, v13);
    free(v4);
    SegmentStreamClose((uint64_t)v8);
    return 0;
  }
  if (!a1[4] || !a1[5])
  {
    uint64_t v10 = "stream not compatible";
    __int16 v11 = 417;
    int v9 = 0;
    goto LABEL_9;
  }
  *uint64_t v5 = a1;
  v5[1] = a2;
  v5[395] = pc_array_init(29);
  AACustomByteStreamSetData((AAByteStream)v4, v8);
  AACustomByteStreamSetPReadProc((AAByteStream)v4, (AAByteStreamPReadProc)SegmentStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v4, (AAByteStreamPWriteProc)SegmentStreamPWrite);
  AACustomByteStreamSetCancelProc((AAByteStream)v4, (AAByteStreamCancelProc)SegmentStreamCancel);
  AACustomByteStreamSetCloseProc((AAByteStream)v4, (AAByteStreamCloseProc)SegmentStreamClose);
  if (a1[11]) {
    v4[11] = SegmentStreamSimulate;
  }
  return v4;
}

uint64_t SegmentStreamClose(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 3152))
    {
      for (uint64_t i = 16; i != 3088; i += 24)
        free(*(void **)(a1 + i));
      pthread_mutex_destroy((pthread_mutex_t *)(a1 + 3088));
    }
    pc_array_free(*(void *)(a1 + 3160));
    free((void *)a1);
  }
  return 0;
}

uint64_t *aaForkInputStreamOpen(void *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a2 + 2128) & 8) == 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaForkInputStreamOpen", 538, 137, 0, "no chunk info", a7, a8, v58);
    uint64_t v8 = 0;
LABEL_13:
    uint64_t v13 = 0;
    goto LABEL_16;
  }
  uint64_t v10 = (void *)a2;
  uint64_t v12 = SegmentStreamCreate(a1, a2);
  uint64_t v8 = v12;
  if (!v12)
  {
    uint64_t v26 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaForkInputStreamOpen", 542, 137, *v26, "SegmentStreamCreate", v27, v28, v58);
    goto LABEL_13;
  }
  uint64_t v13 = *v12;
  if (a1[11]) {
    *(_DWORD *)(v13 + 3184) = 1;
  }
  uint64_t v14 = 0;
  *(void *)(v13 + 3152) = 1;
  do
  {
    unint64_t v15 = malloc(0x10000uLL);
    uint64_t v16 = v13 + v14;
    *(void *)(v16 + 16) = v15;
    *(void *)(v16 + 24) = -1;
    if (!v15)
    {
      int v25 = *__error();
      unint64_t v23 = "malloc";
      __int16 v24 = 554;
      goto LABEL_15;
    }
    v14 += 24;
  }
  while (v14 != 3072);
  if (pthread_mutex_init((pthread_mutex_t *)(v13 + 3088), 0))
  {
    unint64_t v23 = "MutexInit";
    __int16 v24 = 556;
    goto LABEL_11;
  }
  int v59 = v8;
  char v63 = 0;
  uint64_t v61 = v10;
  char v62 = 1;
  int v60 = a3;
  while (!v10[270])
  {
LABEL_36:
    uint64_t v8 = v59;
    if ((v62 & 1) == 0)
    {
      *(void *)(v13 + 3168) = *(void *)(*(void *)(v13 + 3160) - 64);
      v10[260] = *(void *)(v13 + 3176);
      return v8;
    }
    uint64_t v53 = *(void *)(v13 + 3176);
    v10[257] = v53;
    unint64_t v54 = v10[258];
    if (v54)
    {
      __srCC_SHA1_CTX c = v53;
      long long v67 = v54;
      int v68 = 0;
      char v69 = 0;
      *(void *)(v13 + 3176) = v54 + v53;
      int v55 = pc_array_append(*(void *)(v13 + 3160), &__src, v17, v18, v19, v20, v21, v22);
      *(void *)(v13 + 3160) = v55;
      if (!v55)
      {
        unint64_t v23 = "segment_add";
        __int16 v24 = 607;
LABEL_11:
        int v25 = 0;
LABEL_15:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaForkInputStreamOpen", v24, 137, v25, v23, v21, v22, v58);
        goto LABEL_16;
      }
      uint64_t v53 = *(void *)(v13 + 3176);
    }
    char v62 = 0;
    v10[259] = v53;
    char v63 = 1;
  }
  unint64_t v30 = 0;
  while (1)
  {
    uint64_t v65 = v10[268];
    if (a3) {
      LOBYTE(v31) = 1;
    }
    else {
      uint64_t v31 = *(void *)(v10[268] + 440 * v30 + 408);
    }
    char v64 = v31;
    if (!(v63 & 1 | ((v31 & 1) == 0))) {
      break;
    }
LABEL_33:
    if (!(v62 & 1 | ((v64 & 2) == 0)))
    {
      uint64_t v49 = *(void *)(v13 + 3176);
      uint64_t v50 = v65 + 440 * v30;
      *(void *)(v50 + 48) = v49;
      long long v51 = *(_OWORD *)(v50 + 32);
      __srCC_SHA1_CTX c = v49;
      long long v67 = v51;
      int v68 = 0;
      char v69 = 0;
      *(void *)(v13 + 3176) = v51 + v49;
      char v52 = pc_array_append(*(void *)(v13 + 3160), &__src, v17, v18, v19, v20, v21, v22);
      *(void *)(v13 + 3160) = v52;
      if (!v52)
      {
        char v56 = "segment_add";
        __int16 v57 = 597;
        goto LABEL_42;
      }
    }
LABEL_35:
    ++v30;
    uint64_t v10 = v61;
    a3 = v60;
    if (v30 >= v61[270]) {
      goto LABEL_36;
    }
  }
  uint64_t v32 = v65 + 440 * v30;
  if (!*(void *)(v32 + 384))
  {
    char v56 = "no chunks found";
    __int16 v57 = 572;
    goto LABEL_42;
  }
  uint64_t v33 = v65 + 440 * v30;
  uint64_t v35 = *(void *)(v33 + 56);
  uint64_t v34 = (unint64_t *)(v33 + 56);
  *(v34 - 1) = *(void *)(v13 + 3176);
  if (!v35) {
    goto LABEL_35;
  }
  uint64_t v36 = 0;
  unint64_t v37 = 0;
  __int16 v38 = (void *)(v32 + 384);
  uint64_t v39 = v65 + 440 * v30;
  unint64_t v40 = *(void *)(v39 + 392);
  unint64_t v41 = (void *)(v39 + 40);
  unint64_t v42 = (char *)(v39 + 432);
  int v43 = *(void **)(v13 + 3160);
  while (1)
  {
    uint64_t v44 = *v38 + v36;
    uint64_t v45 = v40 >= 0x10000 ? 0x10000 : v40;
    uint64_t v46 = *(void *)v44 + *v41;
    int v47 = *(_DWORD *)(v44 + 8);
    char v48 = *v42;
    __srCC_SHA1_CTX c = *(void *)(v13 + 3176);
    *(void *)&long long v67 = v45;
    *((void *)&v67 + 1) = v46;
    int v68 = v47;
    char v69 = v48;
    *(void *)(v13 + 3176) = __src + v45;
    int v43 = pc_array_append((uint64_t)v43, &__src, v17, v18, v19, v20, v21, v22);
    *(void *)(v13 + 3160) = v43;
    if (!v43) {
      break;
    }
    v40 -= v45;
    ++v37;
    v36 += 12;
    if (v37 >= *v34) {
      goto LABEL_33;
    }
  }
  char v56 = "segment_add";
  __int16 v57 = 584;
LABEL_42:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaForkInputStreamOpen", v57, 137, 0, v56, v21, v22, v58);
  uint64_t v8 = v59;
LABEL_16:
  free(v8);
  SegmentStreamClose(v13);
  return 0;
}

AAByteStream_impl *aaIntervalInputStreamOpen(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (AAByteStream_impl *)calloc(1uLL, 0x68uLL);
  uint64_t v7 = calloc(1uLL, 0x20uLL);
  uint64_t v10 = v7;
  if (v6 && v7)
  {
    if (a3 >= a2)
    {
      void *v7 = a1;
      v7[1] = a2;
      v7[2] = a3 - a2;
      v7[3] = 0;
      AACustomByteStreamSetData(v6, v7);
      AACustomByteStreamSetReadProc(v6, (AAByteStreamReadProc)IntervalStreamRead);
      AACustomByteStreamSetPReadProc(v6, (AAByteStreamPReadProc)IntervalStreamPRead);
      AACustomByteStreamSetSeekProc(v6, (AAByteStreamSeekProc)IntervalStreamSeek);
      AACustomByteStreamSetCancelProc(v6, (AAByteStreamCancelProc)IntervalStreamCancel);
      AACustomByteStreamSetCloseProc(v6, (AAByteStreamCloseProc)IntervalStreamClose);
      return v6;
    }
    __int16 v11 = "bad interval";
    __int16 v12 = 703;
    int v13 = 0;
  }
  else
  {
    int v13 = *__error();
    __int16 v11 = "malloc";
    __int16 v12 = 702;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaIntervalInputStreamOpen", v12, 137, v13, v11, v8, v9, v15);
  free(v6);
  free(v10);
  return 0;
}

ssize_t IntervalStreamRead(uint64_t a1, void *a2, size_t a3)
{
  return IntervalStreamPRead(a1, a2, a3, *(void *)(a1 + 24));
}

ssize_t IntervalStreamPRead(uint64_t a1, void *a2, size_t a3, int64_t a4)
{
  if (!a3) {
    return 0;
  }
  int64_t v5 = *(void *)(a1 + 16);
  if (v5 == a4) {
    return 0;
  }
  if (v5 < a4) {
    return -1;
  }
  if ((uint64_t)(a4 + a3) > v5) {
    a3 = v5 - a4;
  }
  ssize_t result = AAByteStreamPRead(*(AAByteStream *)a1, a2, a3, *(void *)(a1 + 8) + a4);
  if (result < 0) {
    return -1;
  }
  *(void *)(a1 + 24) += result;
  return result;
}

uint64_t IntervalStreamSeek(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    uint64_t v3 = (void *)(a1 + 24);
    if (a3 != 1)
    {
      if (a3 != 2) {
        return -1;
      }
      uint64_t v3 = (void *)(a1 + 16);
    }
    a2 += *v3;
  }
  if ((a2 & 0x8000000000000000) == 0 && a2 <= *(void *)(a1 + 16))
  {
    *(void *)(a1 + 24) = a2;
    return a2;
  }
  return -1;
}

void IntervalStreamCancel(AAByteStream *a1)
{
}

uint64_t IntervalStreamClose(void *a1)
{
  return 0;
}

uint64_t SegmentStreamPRead(void **a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (!a3) {
    return 0;
  }
  unint64_t v5 = a3;
  unint64_t v7 = 0;
  uint64_t v8 = (pthread_mutex_t *)(a1 + 386);
  uint64_t v9 = a1 + 2;
  unint64_t v73 = (unint64_t *)(a1 + 4);
  unint64_t v75 = (pthread_mutex_t *)(a1 + 386);
  while (1)
  {
    uint64_t v10 = segment_find(a1, a4);
    if (!v10)
    {
      char v63 = "no segment found";
      __int16 v64 = 321;
      goto LABEL_74;
    }
    uint64_t v13 = v10;
    unint64_t v14 = a4 - *(void *)v10;
    if (v5 - v7 >= *(void *)(v10 + 8) - v14) {
      size_t v15 = *(void *)(v10 + 8) - v14;
    }
    else {
      size_t v15 = v5 - v7;
    }
    if (!*(_DWORD *)(v10 + 24))
    {
      uint64_t v22 = (uint64_t)*a1;
      if ((*a1)[4])
      {
        if (!v15) {
          goto LABEL_41;
        }
        uint64_t v23 = 0;
        uint64_t v24 = a2 + v7;
        size_t v25 = v15;
        unint64_t v26 = *(void *)(v10 + 16) + a4 - *(void *)v10;
        size_t __n = v25;
        while (1)
        {
          uint64_t v27 = (*(uint64_t (**)(void, uint64_t, size_t, unint64_t))(v22 + 32))(*(void *)v22, v24, v25, v26);
          if (v27 < 0) {
            break;
          }
          if (v27)
          {
            v24 += v27;
            v23 += v27;
            v26 += v27;
            v25 -= v27;
            if (v25) {
              continue;
            }
          }
          goto LABEL_39;
        }
        uint64_t v23 = v27;
      }
      else
      {
        size_t __n = v15;
        uint64_t v23 = -1;
      }
LABEL_39:
      size_t v15 = __n;
      BOOL v51 = __n == v23;
      uint64_t v8 = v75;
      unint64_t v5 = a3;
      if (!v51)
      {
        char v63 = "aaSegmentStreamProcess";
        __int16 v64 = 337;
        goto LABEL_74;
      }
LABEL_41:
      if (*((_DWORD *)a1 + 796) && v15 != aaByteStreamSimulate(*a1))
      {
        char v63 = "aaByteStreamSimulate";
        __int16 v64 = 340;
        goto LABEL_74;
      }
      goto LABEL_57;
    }
    uint64_t v81 = *(unsigned __int8 *)(v10 + 28);
    uint64_t v82 = a1[1];
    if (pthread_mutex_lock(v8))
    {
      int v60 = "MutexLock";
      __int16 v61 = 169;
LABEL_62:
      int v62 = 0;
      goto LABEL_68;
    }
    uint64_t v18 = *(void *)(v13 + 16);
    unint64_t v19 = ((unint64_t)(0x317E428CA9 * v18) >> 32) & 0x7F;
    uint64_t v20 = &v9[3 * v19];
    if (v20[1] != v18) {
      break;
    }
    uint64_t v21 = (uint64_t)a1[394] + 1;
    a1[394] = (void *)v21;
    v9[3 * v19 + 2] = (void *)v21;
LABEL_26:
    memcpy((void *)(a2 + v7), (const void *)(*v20 + v14), v15);
    unint64_t v41 = 0;
LABEL_53:
    if (pthread_mutex_unlock(v8))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"segment_decode_to_buffer", 208, 137, 0, "MutexUnlock", v56, v57, v68);
      goto LABEL_73;
    }
    free(v41);
    if (*((_DWORD *)a1 + 796))
    {
      size_t v58 = v15;
      uint64_t v59 = *(unsigned int *)(v13 + 24);
      BOOL v51 = aaByteStreamSimulate(*a1) == v59;
      size_t v15 = v58;
      if (!v51)
      {
        char v63 = "aaByteStreamSimulate";
        __int16 v64 = 333;
        goto LABEL_74;
      }
    }
LABEL_57:
    a4 += v15;
    v7 += v15;
    if (v7 >= v5) {
      return v7;
    }
  }
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  unint64_t v30 = v73;
  while (*(v30 - 1) != v18)
  {
    unint64_t v31 = *v30;
    v30 += 3;
    if (v31 < (unint64_t)v9[3 * v29 + 2]) {
      uint64_t v29 = v28;
    }
    if (++v28 == 128) {
      goto LABEL_25;
    }
  }
  uint64_t v29 = v28;
LABEL_25:
  uint64_t v32 = (void *)v20[2];
  long long v33 = *(_OWORD *)v20;
  uint64_t v34 = &v9[3 * v29];
  uint64_t v35 = v34[2];
  *(_OWORD *)uint64_t v20 = *(_OWORD *)v34;
  v20[2] = v35;
  *(_OWORD *)uint64_t v34 = v33;
  v34[2] = v32;
  uint64_t v36 = v20[1];
  uint64_t v37 = *(void *)(v13 + 16);
  uint64_t v38 = (uint64_t)a1[394] + 1;
  a1[394] = (void *)v38;
  uint64_t v39 = &v9[3 * v19];
  v39[2] = (void *)v38;
  unint64_t v40 = (uint64_t *)(v39 + 2);
  if (v36 == v37) {
    goto LABEL_26;
  }
  unint64_t v70 = v40;
  unint64_t v71 = v20 + 1;
  unint64_t v72 = (void **)v20;
  if (pthread_mutex_unlock(v8))
  {
    int v60 = "MutexUnlock";
    __int16 v61 = 175;
    goto LABEL_62;
  }
  uint64_t v42 = *(unsigned int *)(v13 + 24);
  size_t v43 = *(void *)(v13 + 8) + v42;
  if (v43 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_67:
    int v62 = *__error();
    int v60 = "aaMalloc";
    __int16 v61 = 179;
LABEL_68:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"segment_decode_to_buffer", v61, 137, v62, v60, v16, v17, v68);
    unint64_t v41 = 0;
    goto LABEL_73;
  }
  src_buffer = (uint8_t *)malloc(v43);
  if (!src_buffer) {
    goto LABEL_67;
  }
  uint64_t v46 = (uint64_t)*a1;
  if ((*a1)[4])
  {
    size_t __na = v15;
    unint64_t v80 = v14;
    uint64_t v69 = v42;
    uint64_t v47 = 0;
    if (v42)
    {
      uint64_t v48 = *(void *)(v13 + 16);
      uint64_t v49 = src_buffer;
      while (1)
      {
        uint64_t v50 = (*(uint64_t (**)(void, uint8_t *, uint64_t, uint64_t))(v46 + 32))(*(void *)v46, v49, v42, v48);
        if (v50 < 0) {
          break;
        }
        if (v50)
        {
          v49 += v50;
          v47 += v50;
          v48 += v50;
          v42 -= v50;
          if (v42) {
            continue;
          }
        }
        goto LABEL_45;
      }
      uint64_t v47 = v50;
    }
LABEL_45:
    BOOL v51 = v47 == v69;
    uint64_t v8 = v75;
    unint64_t v5 = a3;
    if (v51)
    {
      size_t v52 = *(void *)(v13 + 8);
      if (*src_buffer == BYTE4(v82[v81]))
      {
        if (v52 + 1 != *(_DWORD *)(v13 + 24))
        {
          uint64_t v65 = "chunk error";
          __int16 v66 = 189;
          goto LABEL_72;
        }
        uint64_t v53 = src_buffer + 1;
      }
      else
      {
        size_t v54 = *(unsigned int *)(v13 + 24);
        uint64_t v53 = &src_buffer[v54];
        if (compression_decode_buffer(&src_buffer[v54], v52, src_buffer, v54, 0, (compression_algorithm)LODWORD(v82[v81])) != *(void *)(v13 + 8))
        {
          uint64_t v65 = "compression_decode_buffer";
          __int16 v66 = 195;
          goto LABEL_72;
        }
      }
      memcpy((void *)(a2 + v7), &v53[v80], __na);
      if (pthread_mutex_lock(v75))
      {
        uint64_t v65 = "MutexLock";
        __int16 v66 = 202;
        goto LABEL_72;
      }
      memcpy(*v72, v53, *(void *)(v13 + 8));
      *unint64_t v71 = *(void *)(v13 + 16);
      uint64_t v55 = (uint64_t)a1[394] + 1;
      a1[394] = (void *)v55;
      *unint64_t v70 = v55;
      size_t v15 = __na;
      unint64_t v41 = src_buffer;
      goto LABEL_53;
    }
  }
  uint64_t v65 = "aaByteStreamPReadExpected";
  __int16 v66 = 183;
LABEL_72:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"segment_decode_to_buffer", v66, 137, 0, v65, v44, v45, v68);
  unint64_t v41 = src_buffer;
LABEL_73:
  free(v41);
  char v63 = "segment_decode_to_buffer";
  __int16 v64 = 330;
LABEL_74:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"SegmentStreamPRead", v64, 137, 0, v63, v11, v12, v68);
  return -1;
}

uint64_t SegmentStreamPWrite(void *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (!a3) {
    return 0;
  }
  unint64_t v7 = 0;
  while (1)
  {
    uint64_t v8 = segment_find(a1, a4);
    if (!v8)
    {
      unint64_t v19 = "no segment found";
      __int16 v20 = 363;
      goto LABEL_23;
    }
    unint64_t v11 = a4 - *(void *)v8;
    if (a3 - v7 >= *(void *)(v8 + 8) - v11) {
      unint64_t v12 = *(void *)(v8 + 8) - v11;
    }
    else {
      unint64_t v12 = a3 - v7;
    }
    if (*(_DWORD *)(v8 + 24))
    {
      unint64_t v19 = "compressed content";
      __int16 v20 = 370;
      goto LABEL_23;
    }
    uint64_t v13 = *a1;
    if (!*(void *)(*a1 + 40))
    {
      uint64_t v14 = -1;
      goto LABEL_16;
    }
    if (v12) {
      break;
    }
LABEL_17:
    a4 += v12;
    v7 += v12;
    if (v7 >= a3) {
      return v7;
    }
  }
  uint64_t v14 = 0;
  uint64_t v15 = a2 + v7;
  unint64_t v16 = *(void *)(v8 + 16) + v11;
  unint64_t v17 = v12;
  while (1)
  {
    uint64_t v18 = (*(uint64_t (**)(void, uint64_t, unint64_t, unint64_t))(v13 + 40))(*(void *)v13, v15, v17, v16);
    if (v18 < 1) {
      break;
    }
    v15 += v18;
    v14 += v18;
    v16 += v18;
    v17 -= v18;
    if (!v17) {
      goto LABEL_16;
    }
  }
  uint64_t v14 = v18;
LABEL_16:
  if (v12 == v14) {
    goto LABEL_17;
  }
  unint64_t v19 = "aaByteStreamPWriteExpected";
  __int16 v20 = 374;
LABEL_23:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"SegmentStreamPWrite", v20, 137, 0, v19, v9, v10, v22);
  return -1;
}

void SegmentStreamCancel(AAByteStream *a1)
{
}

uint64_t SegmentStreamSimulate(void *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  unint64_t v8 = 0;
  while (a4 > v8)
  {
    uint64_t v9 = segment_find(a1, a5);
    if (!v9)
    {
      uint64_t v14 = "no segment found";
      __int16 v15 = 276;
      goto LABEL_12;
    }
    unint64_t v12 = *(void *)(v9 + 8) - (a5 - *(void *)v9);
    if (a4 - v8 < v12) {
      unint64_t v12 = a4 - v8;
    }
    a5 += v12;
    v8 += v12;
    if (*(_DWORD *)(v9 + 24)) {
      unint64_t v13 = *(unsigned int *)(v9 + 24);
    }
    else {
      unint64_t v13 = v12;
    }
    if (v13 != aaByteStreamSimulate((void *)*a1))
    {
      uint64_t v14 = "aaByteStreamSimulate";
      __int16 v15 = 303;
LABEL_12:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"SegmentStreamSimulate", v15, 137, 0, v14, v10, v11, v17);
      return -1;
    }
  }
  return v8;
}

uint64_t segment_find(void *a1, unint64_t a2)
{
  if (a1[397] <= a2) {
    return 0;
  }
  unint64_t v2 = a1[396];
  uint64_t v3 = a1[395];
  if (v2 < 2)
  {
    unint64_t v4 = 0;
  }
  else
  {
    unint64_t v4 = 0;
    do
    {
      if (*(void *)(v3 + 29 * ((v2 + v4) >> 1)) > a2) {
        unint64_t v2 = (v2 + v4) >> 1;
      }
      else {
        unint64_t v4 = (v2 + v4) >> 1;
      }
    }
    while (v4 + 1 < v2);
  }
  return v3 + 29 * v4;
}

uint64_t createSearchThread(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)(a1 + 152);
  uint64_t v5 = v4 + 2368 * a2;
  bzero((void *)v5, 0x940uLL);
  *(void *)(v5 + 16) = a1;
  *(_DWORD *)(v5 + 8) = a2;
  *(_DWORD *)(v5 + 24) = 0;
  if (pthread_mutex_init((pthread_mutex_t *)(v5 + 32), 0)
    || pthread_cond_init((pthread_cond_t *)(v4 + 2368 * a2 + 96), 0))
  {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = v4 + 2368 * a2;
  *(void *)(v7 + 2336) = 0x1000000;
  unint64_t v8 = malloc(0x1000000uLL);
  *(void *)(v7 + 2360) = v8;
  if (!v8)
  {
    uint64_t v9 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Search.c", (uint64_t)"createSearchThread", 142, 23, *v9, "malloc", v10, v11, v12);
    return 0xFFFFFFFFLL;
  }
  if (createThread((pthread_t *)v5, (uint64_t)searchThreadMain, v5, 0)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t searchThreadMain(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v54 = *(void *)(*(void *)v2 + 16);
  int Count = CFArrayGetCount(*(CFArrayRef *)(*(void *)v2 + 64));
  uint64_t v4 = calloc(Count, 8uLL);
  uint64_t v5 = calloc(Count, 8uLL);
  int v52 = Count;
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)v2 + 64), i);
      if (ValueAtIndex)
      {
        CStringPtr = CFStringGetCStringPtr(ValueAtIndex, 0x8000100u);
        if (CStringPtr)
        {
          unint64_t v13 = CStringPtr;
          size_t v14 = strlen(CStringPtr);
          v4[i] = v14;
          __int16 v15 = strdup(v13);
          v5[i] = v15;
          if (*(_DWORD *)(*(void *)v2 + 24)) {
            BOOL v16 = v14 == 0;
          }
          else {
            BOOL v16 = 1;
          }
          if (!v16)
          {
            char v17 = v15;
            do
            {
              *char v17 = __tolower(*v17);
              ++v17;
              --v14;
            }
            while (v14);
          }
        }
        else
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Search.c", (uint64_t)"searchThreadMain", 65, 23, 0, "CFStringGetCStringPtr returned 0", v11, v12, v47);
        }
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Search.c", (uint64_t)"searchThreadMain", 63, 23, 0, "CFArrayGetValueAtIndex(%d) returned 0", v8, v9, i);
      }
    }
  }
  uint64_t v18 = (pthread_mutex_t *)(v2 + 32);
  int v19 = *(_DWORD *)(a1 + 8);
  if (pthread_mutex_lock((pthread_mutex_t *)(v2 + 32)))
  {
LABEL_16:
    uint64_t v23 = "SharedArrayPush: pthread_mutex_lock failed\n";
    __int16 v24 = 117;
  }
  else
  {
    unint64_t v26 = (pthread_cond_t *)(v2 + 96);
    uint64_t v50 = (pthread_cond_t *)(a1 + 96);
    BOOL v51 = (pthread_mutex_t *)(a1 + 32);
    uint64_t v27 = a1 + 288;
    uint64_t v53 = a1;
    while (1)
    {
      uint64_t v28 = *(unsigned int *)(v2 + 16);
      unsigned int v29 = *(_DWORD *)(v2 + 20);
      int v30 = v28;
      if (v28 < v29)
      {
        *(_DWORD *)(*(void *)(v2 + 24) + 4 * v28) = v19;
        int v30 = *(_DWORD *)(v2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v30 + 1;
      if (!v30)
      {
        if (pthread_cond_broadcast(v26)) {
          break;
        }
      }
      if (pthread_mutex_unlock(v18))
      {
        uint64_t v23 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        __int16 v24 = 124;
        goto LABEL_17;
      }
      if (v28 >= v29)
      {
        uint64_t v23 = "SharedArrayPush: stack is full\n";
        __int16 v24 = 125;
        goto LABEL_17;
      }
      if (pthread_mutex_lock(v51)) {
        goto LABEL_18;
      }
      while (1)
      {
        int v31 = *(_DWORD *)(v53 + 24);
        if (v31 > 0) {
          break;
        }
        if (pthread_cond_wait(v50, v51)) {
          goto LABEL_18;
        }
      }
      *(_DWORD *)(v53 + 24) = v31 - 1;
      if (pthread_mutex_unlock(v51)) {
        goto LABEL_18;
      }
      uint64_t v32 = *(void *)(v53 + 2344);
      if (!v32)
      {
        free(v4);
        free(v5);
        return 0;
      }
      uint64_t v48 = v26;
      uint64_t v49 = v18;
      if (*(_DWORD *)(*(void *)v2 + 24))
      {
        long long v33 = *(unsigned char **)(v53 + 2360);
        do
        {
          unsigned char *v33 = __tolower(*v33);
          ++v33;
          --v32;
        }
        while (v32);
      }
      if (v52 >= 1)
      {
        for (uint64_t j = 0; j != v52; ++j)
        {
          if (v4[j] >= 2uLL)
          {
            uint64_t v35 = *(void *)(v53 + 2344);
            if (v35 >= 1)
            {
              uint64_t v36 = *(char **)(v53 + 2360);
              unint64_t v37 = (unint64_t)&v36[*(void *)(v53 + 2352)];
              unint64_t v38 = (unint64_t)&v36[v35];
              uint64_t v39 = v36;
              do
              {
                unint64_t v40 = (char *)memmem(v39, v38 - (void)v39, (const void *)v5[j], v4[j]);
                if (!v40) {
                  break;
                }
                unint64_t v41 = v40;
                uint64_t v42 = &v40[-v54];
                if (&v40[-v54] < v36) {
                  uint64_t v42 = v36;
                }
                v55[2] = v42;
                size_t v43 = &v40[v4[j]];
                unint64_t v44 = (unint64_t)&v43[v54];
                if ((unint64_t)&v43[v54] > v38) {
                  unint64_t v44 = v38;
                }
                v55[3] = v44;
                v55[4] = v40;
                v55[5] = v43;
                uint64_t v45 = (uint64_t)&v40[-v37];
                if ((unint64_t)v40 < v37) {
                  uint64_t v45 = -1;
                }
                v55[0] = v27;
                v55[1] = v45;
                uint64_t v46 = *(void (**)(void, void *))(*(void *)v2 + 48);
                if (v46) {
                  v46(*(void *)(*(void *)v2 + 56), v55);
                }
                uint64_t v39 = v41 + 1;
              }
              while ((unint64_t)(v41 + 1) < v38);
            }
          }
        }
      }
      int v19 = *(_DWORD *)(v53 + 8);
      uint64_t v18 = v49;
      unint64_t v26 = v48;
      if (pthread_mutex_lock(v49)) {
        goto LABEL_16;
      }
    }
    uint64_t v23 = "SharedArrayPush: pthread_cond_broadcast failed\n";
    __int16 v24 = 122;
  }
LABEL_17:
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPush", v24, 0, v23, v20, v21, v22, v47);
LABEL_18:
  *(_DWORD *)(v2 + 8) = 0;
  return 0;
}

uint64_t joinSearchThread(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 152);
  uint64_t v3 = *(_opaque_pthread_t **)(v2 + 2368 * a2);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  joinThread(v3);
  if (pthread_mutex_destroy((pthread_mutex_t *)(v2 + 2368 * a2 + 32))
    || pthread_cond_destroy((pthread_cond_t *)(v2 + 2368 * a2 + 96)))
  {
    return 0xFFFFFFFFLL;
  }
  free(*(void **)(v2 + 2368 * a2 + 2360));
  return 0;
}

uint64_t appendPayload(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t v6 = *(void *)(a1 + 2344);
  size_t v7 = v6 + a3;
  if (v6 + a3 <= *(void *)(a1 + 2336))
  {
    uint64_t v8 = *(char **)(a1 + 2360);
    goto LABEL_5;
  }
  *(void *)(a1 + 2336) = v7;
  uint64_t v8 = (char *)reallocf(*(void **)(a1 + 2360), v7);
  *(void *)(a1 + 2360) = v8;
  if (v8)
  {
    uint64_t v6 = *(void *)(a1 + 2344);
LABEL_5:
    memcpy(&v8[v6], a2, a3);
    uint64_t result = 0;
    *(void *)(a1 + 2344) += a3;
    return result;
  }
  uint64_t v10 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Search.c", (uint64_t)"appendPayload", 176, 23, *v10, "reallocf", v11, v12, v13);
  *(void *)(a1 + 2336) = 0;
  return 0xFFFFFFFFLL;
}

uint64_t ParallelArchiveSearch(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v61 = *MEMORY[0x263EF8340];
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v45);
  long long v52 = 0u;
  *(_OWORD *)uint64_t v53 = 0u;
  memset(v57, 0, sizeof(v57));
  long long v56 = 0u;
  long long v55 = 0u;
  long long v54 = 0u;
  LODWORD(v52) = 1;
  uint64_t v51 = a1;
  unsigned int v58 = *(_DWORD *)(a1 + 8);
  int v59 = -1;
  int v60 = (char *)calloc(v58, 0x940uLL);
  if (v60)
  {
    DWORD2(v52) = 0;
    HIDWORD(v52) = v58;
    v53[0] = calloc(v58, 4uLL);
    if (!v53[0])
    {
      uint64_t v12 = "SharedArrayInit: malloc failed\n";
      __int16 v13 = 55;
      goto LABEL_10;
    }
    if (pthread_mutex_init((pthread_mutex_t *)&v53[1], 0))
    {
      uint64_t v12 = "SharedArrayInit: pthread_mutex_init failed\n";
      __int16 v13 = 56;
LABEL_10:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayInit", v13, 0, v12, v9, v10, v11, v45);
      goto LABEL_11;
    }
    if (pthread_cond_init((pthread_cond_t *)&v57[1], 0))
    {
      uint64_t v12 = "SharedArrayInit: pthread_cond_init failed\n";
      __int16 v13 = 57;
      goto LABEL_10;
    }
    if (v58)
    {
      unsigned int v42 = 0;
      while (!createSearchThread((uint64_t)&v51, v42))
      {
        if (++v42 >= v58) {
          goto LABEL_49;
        }
      }
      goto LABEL_11;
    }
LABEL_49:
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v45 = 0u;
    int DefaultNThreads = *(_DWORD *)(a1 + 4);
    if (!DefaultNThreads) {
      int DefaultNThreads = getDefaultNThreads();
    }
    DWORD1(v45) = DefaultNThreads;
    uint64_t v44 = *(void *)(a1 + 40);
    *((void *)&v45 + 1) = *(void *)(a1 + 32);
    *((void *)&v46 + 1) = v44;
    *(void *)&long long v47 = searchBeginProc;
    *(void *)&long long v48 = searchPayloadProc;
    *((void *)&v48 + 1) = 0;
    *(void *)&long long v49 = searchEndProc;
    uint64_t v50 = &v51;
    if (!ParallelArchiveRead((uint64_t)&v45, v19, v20, v21, v22, v9, v10, v11)) {
      goto LABEL_12;
    }
    char v17 = "Search failed";
    __int16 v18 = 273;
    int v14 = 0;
  }
  else
  {
    int v14 = *__error();
    char v17 = "calloc";
    __int16 v18 = 252;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Search.c", (uint64_t)"ParallelArchiveSearch", v18, 23, v14, v17, v15, v16, v45);
LABEL_11:
  LODWORD(v52) = 0;
LABEL_12:
  if (!v58) {
    goto LABEL_35;
  }
  for (unsigned int i = 0; i < v58; ++i)
  {
    if (pthread_mutex_lock((pthread_mutex_t *)&v53[1]))
    {
      __int16 v27 = 91;
      uint64_t v28 = "SharedArrayPop: pthread_mutex_lock failed\n";
LABEL_19:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v27, 0, v28, v24, v25, v26, v45);
      unsigned int v30 = -1;
      goto LABEL_20;
    }
    while (1)
    {
      int v29 = DWORD2(v52);
      if (DWORD2(v52)) {
        break;
      }
      if (pthread_cond_wait((pthread_cond_t *)&v57[1], (pthread_mutex_t *)&v53[1]))
      {
        __int16 v27 = 94;
        uint64_t v28 = "SharedArrayPop: pthread_cond_wait failed\n";
        goto LABEL_19;
      }
    }
    --DWORD2(v52);
    unsigned int v30 = *((_DWORD *)v53[0] + (v29 - 1));
    if (pthread_mutex_unlock((pthread_mutex_t *)&v53[1]))
    {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", 98, 0, "SharedArrayPop: pthread_mutex_unlock failed\n", v36, v37, v38, v45);
LABEL_20:
      LODWORD(v52) = 0;
    }
    int v31 = v60;
    uint64_t v32 = &v60[2368 * v30];
    *((void *)v32 + 293) = 0;
    long long v33 = (pthread_mutex_t *)(v32 + 32);
    if (pthread_mutex_lock((pthread_mutex_t *)(v32 + 32))
      || (uint64_t v34 = &v31[2368 * v30], v35 = *((_DWORD *)v34 + 6), *((_DWORD *)v34 + 6) = v35 + 1, !v35)
      && pthread_cond_broadcast((pthread_cond_t *)&v31[2368 * v30 + 96])
      || pthread_mutex_unlock(v33))
    {
      LODWORD(v52) = 0;
    }
  }
  if (v58)
  {
    for (unsigned int j = 0; j < v58; ++j)
    {
      if (joinSearchThread((uint64_t)&v51, j)) {
        LODWORD(v52) = 0;
      }
    }
  }
LABEL_35:
  if (pthread_mutex_destroy((pthread_mutex_t *)&v53[1]) || pthread_cond_destroy((pthread_cond_t *)&v57[1])) {
    LODWORD(v52) = 0;
  }
  else {
    free(v53[0]);
  }
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (v52) {
    unsigned int v41 = 0;
  }
  else {
    unsigned int v41 = -1;
  }
  if ((int)result >= 0) {
    return v41;
  }
  else {
    return result;
  }
}

uint64_t searchBeginProc(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, const void *a5, size_t a6)
{
  *(_DWORD *)(a1 + 148) = -1;
  uint64_t v10 = (pthread_mutex_t *)(a1 + 32);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 32)))
  {
    int v14 = "SharedArrayPop: pthread_mutex_lock failed\n";
    __int16 v15 = 91;
LABEL_8:
    uint64_t result = pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v15, 0, v14, v11, v12, v13, v21);
    *(_DWORD *)(a1 + 8) = 0;
    goto LABEL_9;
  }
  while (1)
  {
    int v16 = *(_DWORD *)(a1 + 16);
    if (v16) {
      break;
    }
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 96), v10))
    {
      int v14 = "SharedArrayPop: pthread_cond_wait failed\n";
      __int16 v15 = 94;
      goto LABEL_8;
    }
  }
  unsigned int v17 = v16 - 1;
  *(_DWORD *)(a1 + 16) = v17;
  *(_DWORD *)(a1 + 148) = *(_DWORD *)(*(void *)(a1 + 24) + 4 * v17);
  uint64_t result = pthread_mutex_unlock(v10);
  if (result)
  {
    int v14 = "SharedArrayPop: pthread_mutex_unlock failed\n";
    __int16 v15 = 98;
    goto LABEL_8;
  }
LABEL_9:
  unsigned int v19 = *(_DWORD *)(a1 + 148);
  if (v19 != -1)
  {
    uint64_t v20 = (void *)(*(void *)(a1 + 152) + 2368 * v19);
    memcpy(v20 + 18, a2, 0x890uLL);
    v20[293] = 0;
    v20[294] = a6;
    uint64_t result = appendPayload((uint64_t)v20, a5, a6);
    if (result) {
      *(_DWORD *)(a1 + 8) = 0;
    }
  }
  return result;
}

uint64_t searchPayloadProc(uint64_t result, const void *a2, size_t a3)
{
  unsigned int v3 = *(_DWORD *)(result + 148);
  if (v3 != -1)
  {
    uint64_t v4 = result;
    uint64_t result = appendPayload(*(void *)(result + 152) + 2368 * v3, a2, a3);
    if (result) {
      *(_DWORD *)(v4 + 8) = 0;
    }
  }
  return result;
}

uint64_t searchEndProc(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 148);
  if (v1 != -1)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(result + 152);
    if (**(int **)result >= 2)
    {
      uint64_t v4 = v3 + 2368 * v1;
      fprintf((FILE *)*MEMORY[0x263EF8348], "Thread %d processing '%s', size=%zu, header=%zu, capacity=%zu\n", *(_DWORD *)(v4 + 8), (const char *)(v4 + 288), *(void *)(v4 + 2344), *(void *)(v4 + 2352), *(void *)(v4 + 2336));
    }
    uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(v3 + 2368 * v1 + 32));
    if (result
      || (uint64_t v5 = v3 + 2368 * v1, v6 = *(_DWORD *)(v5 + 24), *(_DWORD *)(v5 + 24) = v6 + 1, !v6)
      && (uint64_t result = pthread_cond_broadcast((pthread_cond_t *)(v3 + 2368 * v1 + 96)), result)
      || (uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v3 + 2368 * v1 + 32)), result))
    {
      *(_DWORD *)(v2 + 8) = 0;
    }
  }
  return result;
}

uint64_t apfs_scan_diskimage(const char *a1, uint64_t (*a2)(long long *, uint64_t), uint64_t a3, uint64_t a4)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  memset(&v60, 0, sizeof(v60));
  if (snprintf(__str, 0x400uLL, "%s.json", a1) > 0)
  {
    if (!stat(__str, &v60) && (v60.st_mode & 0xF000) == 0x8000)
    {
      uint64_t v11 = AAFileStreamOpenWithPath(__str, 0, 0);
      if (v11)
      {
        uint64_t v12 = 0;
LABEL_6:
        long long v67 = 0u;
        *(_OWORD *)char v68 = 0u;
        __srCC_SHA1_CTX c = 0;
        uint64_t v66 = 0;
        uint64_t v13 = (void **)AAJSONInputStreamOpen((uint64_t)v11);
        if (v13)
        {
          uint64_t v20 = v13;
          uint64_t v64 = 0;
          long long v62 = 0u;
          long long v63 = 0u;
          *(_OWORD *)__s1 = 0u;
          if ((AAJSONInputStreamRead((uint64_t)v13, (int *)__s1, v14, v15, v16, v17, v18, v19) & 0x80000000) == 0)
          {
            while (1)
            {
              int v27 = v64;
              if (!v64)
              {
                AAJSONInputStreamClose(v20);
                int v46 = 1;
                goto LABEL_66;
              }
              if (LODWORD(__s1[0]) < 2) {
                break;
              }
              if (LODWORD(__s1[0]) == 2)
              {
                if (v64 == 4)
                {
                  v68[1] = *(void *)(*(void *)&v68[2] - 64);
                  if ((a2(&v67, a4) & 0x80000000) != 0)
                  {
                    long long v55 = "add_fork";
                    __int16 v56 = 58;
                    goto LABEL_88;
                  }
                  pc_array_free(*(uint64_t *)&v68[2]);
                  *(void *)&v68[2] = 0;
                  int v27 = v64;
                }
                if (v27 == 6)
                {
                  *(void *)&v68[2] = pc_array_append(*(uint64_t *)&v68[2], &__src, v21, v22, v23, v24, v25, v26);
                  if (!*(void *)&v68[2])
                  {
                    long long v55 = "pc_array_append";
                    __int16 v56 = 67;
                    goto LABEL_88;
                  }
                }
              }
              else if (LODWORD(__s1[0]) == 4)
              {
                if (v64 == 7)
                {
                  int v29 = __s1[1];
                  if (!strcmp(__s1[1], "offset"))
                  {
                    __srCC_SHA1_CTX c = *((void *)&v62 + 1);
                  }
                  else
                  {
                    if (strcmp(v29, "length"))
                    {
                      long long v55 = "bad map";
                      __int16 v56 = 83;
                      goto LABEL_88;
                    }
                    uint64_t v66 = *((void *)&v62 + 1);
                  }
                }
                else if (v64 == 5)
                {
                  uint64_t v28 = __s1[1];
                  if (!strcmp(__s1[1], "compression"))
                  {
                    v68[0] = BYTE8(v62);
                  }
                  else if (!strcmp(v28, "uncompressed_size"))
                  {
                    *(void *)&long long v67 = *((void *)&v62 + 1);
                  }
                  else
                  {
                    if (strcmp(v28, "size"))
                    {
                      long long v55 = "bad map";
                      __int16 v56 = 77;
                      goto LABEL_88;
                    }
                    *((void *)&v67 + 1) = *((void *)&v62 + 1);
                  }
                }
              }
LABEL_38:
              uint64_t v64 = 0;
              long long v62 = 0u;
              long long v63 = 0u;
              *(_OWORD *)__s1 = 0u;
              if ((AAJSONInputStreamRead((uint64_t)v20, (int *)__s1, v21, v22, v23, v24, v25, v26) & 0x80000000) != 0) {
                goto LABEL_89;
              }
            }
            switch((int)v64)
            {
              case 2:
                if (!strcmp(__s1[1], "volumes")) {
                  goto LABEL_38;
                }
                long long v55 = "bad map";
                __int16 v56 = 41;
                break;
              case 4:
                if (!strcmp(__s1[1], "files")) {
                  goto LABEL_38;
                }
                long long v55 = "bad map";
                __int16 v56 = 42;
                break;
              case 5:
                long long v67 = 0u;
                *(_OWORD *)char v68 = 0u;
                *(void *)&v68[2] = pc_array_init(16);
                goto LABEL_38;
              case 6:
                if (!strcmp(__s1[1], "extents")) {
                  goto LABEL_38;
                }
                long long v55 = "bad map";
                __int16 v56 = 43;
                break;
              case 8:
                long long v55 = "bad map";
                __int16 v56 = 44;
                break;
              default:
                goto LABEL_38;
            }
LABEL_88:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"parseAPFSJSON", v56, 144, 0, v55, v25, v26, (char)v59);
          }
LABEL_89:
          long long v54 = v20;
        }
        else
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"parseAPFSJSON", 27, 144, 0, "AAJSONInputStreamOpen", v18, v19, (char)v59);
          long long v54 = 0;
        }
        AAJSONInputStreamClose(v54);
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 181, 144, 0, "invalid image map JSON", v57, v58, (char)v59);
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 114, 144, 0, "AAFileStreamOpenWithPath", v9, v10, (char)v59);
        uint64_t v12 = 0;
      }
      goto LABEL_65;
    }
    if (getenv("PC_APFS_DISKIMAGE_MAP") && (__strlcpy_chk(), !stat(__str, &v60)) && (v60.st_mode & 0xF000) == 0x8000
      || (unsigned int v30 = getenv("MASTERING_TOOLCHAIN_DIR")) != 0
      && (snprintf(__str, 0x400uLL, "%s%s/%s", v30, "/System/Library/Filesystems/apfs.fs/Contents/Resources", "apfs_diskimage_map"), !stat(__str, &v60))&& (v60.st_mode & 0xF000) == 0x8000|| (snprintf(__str, 0x400uLL, "%s/%s", "/System/Library/Filesystems/apfs.fs/Contents/Resources", "apfs_diskimage_map"), !stat(__str, &v60))&& (v60.st_mode & 0xF000) == 0x8000)
    {
      uint64_t v12 = (char *)malloc(0x40000uLL);
      if (v12)
      {
        uint64_t v11 = (AAByteStream_impl *)AATempStreamOpen(0x800000uLL);
        if (v11)
        {
          snprintf(v69, 0x400uLL, "%s \"%s\"", __str, a1);
          int v35 = popen(v69, "r");
          if (v35)
          {
            uint64_t v36 = v35;
            while (1)
            {
              if (feof(v36))
              {
                pclose(v36);
                AAByteStreamSeek(v11, 0, 0);
                goto LABEL_6;
              }
              size_t v37 = fread(v12, 1uLL, 0x40000uLL, v36);
              if (ferror(v36)) {
                break;
              }
              if (*((void *)v11 + 3))
              {
                uint64_t v40 = 0;
                if (v37)
                {
                  unsigned int v41 = v12;
                  size_t v42 = v37;
                  while (1)
                  {
                    uint64_t v43 = (*((uint64_t (**)(void, char *, size_t))v11 + 3))(*(void *)v11, v41, v42);
                    if (v43 < 1) {
                      break;
                    }
                    v41 += v43;
                    v40 += v43;
                    v42 -= v43;
                    if (!v42) {
                      goto LABEL_62;
                    }
                  }
                  uint64_t v40 = v43;
                }
              }
              else
              {
                uint64_t v40 = -1;
              }
LABEL_62:
              if (v40 != v37)
              {
                uint64_t v44 = "writing tool output";
                __int16 v45 = 172;
                goto LABEL_82;
              }
            }
            uint64_t v44 = "reading from tool pipe";
            __int16 v45 = 170;
LABEL_82:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", v45, 144, 0, v44, v38, v39, (char)v59);
            AAByteStreamClose(v11);
            pclose(v36);
            goto LABEL_70;
          }
          int v53 = *__error();
          int v59 = v69;
          uint64_t v51 = "%s";
          __int16 v52 = 164;
        }
        else
        {
          uint64_t v51 = "temp stream open";
          __int16 v52 = 159;
          int v53 = 0;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", v52, 144, v53, v51, v33, v34, (char)v59);
LABEL_69:
        AAByteStreamClose(v11);
LABEL_70:
        int v46 = 0;
        goto LABEL_71;
      }
      long long v48 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 156, 144, *v48, "malloc", v49, v50, (char)v59);
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 153, 144, 0, "could not locate the apfs diskimage map tool", v31, v32, (char)v59);
      uint64_t v12 = 0;
    }
    uint64_t v11 = 0;
    goto LABEL_69;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 110, 144, 0, "snprintf", v7, v8, (char)v59);
  uint64_t v12 = 0;
  uint64_t v11 = 0;
LABEL_65:
  int v46 = 0;
LABEL_66:
  AAByteStreamClose(v11);
LABEL_71:
  free(v12);
  if (v46) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t archiveTreeUpdateChilds(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *a1;
  if (!v8)
  {
LABEL_16:
    int v13 = 0;
    return (v13 << 31 >> 31);
  }
  uint64_t v9 = (_DWORD *)(*((void *)a1 + 1) + 48);
  uint64_t v10 = *a1;
  do
  {
    *(void *)(v9 - 11) = -1;
    *uint64_t v9 = -1;
    v9 += 14;
    --v10;
  }
  while (v10);
  uint64_t v11 = 0;
  uint64_t v12 = (int *)*((void *)a1 + 1);
  int v13 = 1;
  uint64_t v14 = v12;
  uint64_t v15 = 0xFFFFFFFFLL;
  int v16 = -1;
  while (1)
  {
    int v18 = *v14;
    v14 += 14;
    int v17 = v18;
    if (v18 == -1) {
      break;
    }
    uint64_t v19 = &v12[14 * v17];
    int v22 = v19[12];
    uint64_t v21 = v19 + 12;
    int v20 = v22;
    if (v22 == -1)
    {
      uint64_t v23 = &v12[14 * v17];
      int v25 = v23[1];
      uint64_t v24 = v23 + 1;
      if (v25 != -1)
      {
        int v27 = "node has a first child, but no last child";
        __int16 v28 = 1092;
        goto LABEL_20;
      }
      *uint64_t v24 = v11;
    }
    else
    {
      v12[14 * v20 + 2] = v11;
    }
    *uint64_t v21 = v11;
LABEL_15:
    int v13 = ++v11 < v8;
    if (v8 == v11) {
      goto LABEL_16;
    }
  }
  if (v15 != 0xFFFFFFFFLL)
  {
    v12[14 * v15 + 2] = v11;
    uint64_t v15 = v11;
    goto LABEL_15;
  }
  if (v16 == -1)
  {
    uint64_t v15 = v11;
    int v16 = v11;
    goto LABEL_15;
  }
  int v27 = "tree has a first root, but no last root";
  __int16 v28 = 1080;
LABEL_20:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeUpdateChilds", v28, 34, 0, v27, a7, a8, v29);
  return (v13 << 31 >> 31);
}

unsigned int *ArchiveTreeCreateWithRootEntry()
{
  uint64_t v0 = (unsigned int *)archiveTreeCreate();
  uint64_t v3 = v0;
  if (!v0)
  {
    uint64_t v9 = "archive tree creation";
    __int16 v10 = 1134;
LABEL_6:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"ArchiveTreeCreateWithRootEntry", v10, 34, 0, v9, v1, v2, v12);
    ArchiveTreeDestroy((uint64_t)v3);
    return 0;
  }
  if ((archiveTreeAppend(v0, -1, &unk_2106C9523, 0, -1, -1, 68) & 0x80000000) != 0)
  {
    uint64_t v9 = "inserting root entry";
    __int16 v10 = 1137;
    goto LABEL_6;
  }
  archiveTreeUpdateChilds(v3, v4, v5, v6, v7, v8, v1, v2);
  return v3;
}

void *archiveTreeCreate()
{
  uint64_t v2 = calloc(1uLL, 0x20uLL);
  if (v2)
  {
    uint64_t v3 = StringTableCreate();
    v2[2] = v3;
    if (!v3)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeCreate", 109, 34, 0, "string table creation", v4, v5, v7);
      free(v2);
      return 0;
    }
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeCreate", 108, 34, 0, "malloc", v0, v1, v7);
  }
  return v2;
}

uint64_t archiveTreeAppend(unsigned int *a1, int a2, const void *a3, size_t a4, uint64_t a5, uint64_t a6, int a7)
{
  if (archiveTreeReserve((uint64_t)a1, *a1 + 1))
  {
    int v18 = "increasing archive tree storage";
    __int16 v19 = 140;
LABEL_3:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeAppend", v19, 34, 0, v18, v16, v17, v25);
    return 0xFFFFFFFFLL;
  }
  uint64_t v21 = *((void *)a1 + 1);
  unsigned int v22 = *a1;
  uint64_t v23 = v21 + 56 * *a1;
  *(void *)(v23 + 48) = 0;
  *(_OWORD *)(v23 + 16) = 0u;
  *(_OWORD *)(v23 + 32) = 0u;
  *(_OWORD *)uint64_t v23 = 0u;
  if ((StringTableAppend(*((unsigned int **)a1 + 2), a3, a4, (_DWORD *)(v23 + 12), v14, v15, v16, v17) & 0x80000000) != 0)
  {
    int v18 = "inserting tree node";
    __int16 v19 = 144;
    goto LABEL_3;
  }
  uint64_t result = 0;
  *(_DWORD *)uint64_t v23 = a2;
  uint64_t v24 = v21 + 56 * v22;
  *(_DWORD *)(v24 + 16) = a7;
  *(void *)(v24 + 24) = a5;
  *(void *)(v24 + 32) = a6;
  ++*a1;
  return result;
}

void ArchiveTreeDestroy(uint64_t a1)
{
  if (a1)
  {
    free(*(void **)(a1 + 8));
    StringTableDestroy(*(void ***)(a1 + 16));
    MemBufferDestroy(*(void ***)(a1 + 24));
    free((void *)a1);
  }
}

unsigned int *ArchiveTreeCreateFromIndex(uint64_t a1, uint64_t a2, int (*a3)(uint64_t, unsigned char *, void), uint64_t a4, int a5, int a6)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  long long v62 = 0;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v57 = 0u;
  long long v55 = 0;
  uint64_t v56 = 0;
  char v12 = (unsigned int *)archiveTreeCreate();
  int v20 = v12;
  if (!v12)
  {
    uint64_t v26 = "archive tree creation";
    __int16 v27 = 1164;
    goto LABEL_8;
  }
  *(void *)&long long v58 = 0;
  *((void *)&v59 + 1) = 0;
  long long v60 = 0u;
  long long v61 = 0u;
  *((void *)&v57 + 1) = a1;
  LODWORD(v57) = 0;
  DWORD1(v57) = a5;
  *((void *)&v58 + 1) = a2;
  *(void *)&long long v59 = archiveTreeFromIndexBeginProc;
  long long v62 = &v55;
  long long v55 = v12;
  uint64_t v56 = 0x1FFFFFFFFLL;
  if (ParallelArchiveRead((uint64_t)&v57, v13, v14, v15, v16, v17, v18, v19) || !HIDWORD(v56))
  {
    uint64_t v26 = "parsing index";
    __int16 v27 = 1178;
    goto LABEL_8;
  }
  if (archiveTreeSort(v20))
  {
    uint64_t v26 = "sorting tree";
    __int16 v27 = 1181;
    goto LABEL_8;
  }
  if (a6 >= 1) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12u entries in index\n", *v20);
  }
  if (!a3)
  {
    uint64_t v39 = 0;
LABEL_50:
    archiveTreeUpdateChilds(v20, v21, v22, v23, v24, v25, v18, v19);
    free(v39);
    return v20;
  }
  bzero(v63, 0x800uLL);
  size_t v30 = *v20;
  if (!v30)
  {
    size_t v30 = 0;
LABEL_30:
    uint64_t v40 = calloc(v30, 4uLL);
    if (!v40)
    {
      int v28 = *__error();
      uint64_t v26 = "malloc";
      __int16 v27 = 1216;
      goto LABEL_9;
    }
    uint64_t v39 = v40;
    unint64_t v41 = *v20;
    if (v41)
    {
      uint64_t v42 = 0;
      unint64_t v43 = 0;
      unsigned int v44 = 0;
      do
      {
        uint64_t v45 = *((void *)v20 + 1);
        if (*(unsigned char *)(v45 + v42 + 48))
        {
          *((_DWORD *)v40 + v43) = v44;
          if (v43 != v44)
          {
            uint64_t v46 = v45 + 56 * v44;
            long long v47 = (long long *)(v45 + v42);
            long long v48 = *v47;
            long long v49 = v47[1];
            long long v50 = v47[2];
            *(void *)(v46 + 48) = *((void *)v47 + 6);
            *(_OWORD *)(v46 + 16) = v49;
            *(_OWORD *)(v46 + 32) = v50;
            *(_OWORD *)uint64_t v46 = v48;
          }
          ++v44;
          unint64_t v41 = *v20;
        }
        ++v43;
        v42 += 56;
      }
      while (v43 < v41);
      unsigned int *v20 = v44;
      if (v44)
      {
        uint64_t v51 = (_DWORD *)*((void *)v20 + 1);
        uint64_t v52 = v44;
        do
        {
          uint64_t v53 = *v51;
          if (v53 != -1) {
            LODWORD(v53) = *((_DWORD *)v40 + v53);
          }
          *uint64_t v51 = v53;
          v51 += 14;
          --v52;
        }
        while (v52);
      }
    }
    else
    {
      unsigned int v44 = 0;
      unsigned int *v20 = 0;
    }
    if (a6 > 0) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "%12u entries selected\n", v44);
    }
    goto LABEL_50;
  }
  uint64_t v31 = (_DWORD *)(*((void *)v20 + 1) + 48);
  uint64_t v32 = *v20;
  do
  {
    *uint64_t v31 = 0;
    v31 += 14;
    --v32;
  }
  while (v32);
  uint64_t v33 = 0;
  size_t v34 = 0;
  uint64_t v35 = *((void *)v20 + 1);
  while (1)
  {
    unsigned int v36 = *(_DWORD *)(v35 + v33);
    if (v36 != -1) {
      break;
    }
LABEL_21:
    if (ArchiveTreeNodePath((uint64_t)v20, v34, (uint64_t)v63, 0x800uLL) < 0)
    {
      uint64_t v26 = "getting node path";
      __int16 v27 = 1209;
      goto LABEL_8;
    }
    if (a3(a4, v63, *(unsigned int *)(*((void *)v20 + 1) + v33 + 16)) <= 0) {
      int v38 = 2;
    }
    else {
      int v38 = 3;
    }
    uint64_t v35 = *((void *)v20 + 1);
    *(_DWORD *)(v35 + v33 + 48) = v38;
    size_t v30 = *v20;
LABEL_26:
    ++v34;
    v33 += 56;
    if (v34 >= v30) {
      goto LABEL_30;
    }
  }
  int v37 = *(_DWORD *)(v35 + 56 * v36 + 48);
  if (v37)
  {
    *(_DWORD *)(v35 + v33 + 48) = v37;
    if ((v37 & 1) == 0) {
      goto LABEL_26;
    }
    goto LABEL_21;
  }
  uint64_t v26 = "parent node was not processed first";
  __int16 v27 = 1202;
LABEL_8:
  int v28 = 0;
LABEL_9:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"ArchiveTreeCreateFromIndex", v27, 34, v28, v26, v18, v19, v54);
  ArchiveTreeDestroy((uint64_t)v20);
  return 0;
}

size_t archiveTreeFromIndexBeginProc(size_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a2 + 4) != 77)
  {
    size_t v9 = result;
    if (!a4) {
      goto LABEL_18;
    }
    uint64_t v10 = *(void *)result;
    uint64_t v11 = (uint64_t *)(a3 + 8);
    uint64_t v12 = -1;
    do
    {
      if ((*(_DWORD *)(v11 - 1) & 0xDFDFDF) == 0x584449 && *((_DWORD *)v11 - 1) == 1) {
        uint64_t v12 = *v11;
      }
      v11 += 129;
      --a4;
    }
    while (a4);
    if (v12 == -1)
    {
LABEL_18:
      char v33 = a2 - 112;
      uint64_t v23 = "entry is missing IDX field: %s";
      __int16 v24 = 589;
    }
    else
    {
      unsigned int v13 = *(_DWORD *)(result + 8);
      if (v13 != -1)
      {
        uint64_t v14 = *(void *)(v10 + 8) + 56 * v13;
        unint64_t v16 = *(void *)(v14 + 32);
        uint64_t v15 = (unint64_t *)(v14 + 32);
        unint64_t v17 = v12 - *(v15 - 1);
        if (v17 < v16) {
          *uint64_t v15 = v17;
        }
      }
      strncpy(__dst, (const char *)(a2 + 144), 0x400uLL);
      size_t v18 = strlen(__dst);
      size_t v19 = v18;
      int v36 = -1;
      if (v18)
      {
        uint64_t v20 = 0;
        while (__dst[v18 + v20] != 47)
        {
          --v20;
          if (!(v18 + v20)) {
            goto LABEL_16;
          }
        }
        int64_t v25 = v18 + v20;
        uint64_t v26 = &__dst[v18 + v20];
        *uint64_t v26 = 0;
        uint64_t v21 = v26 + 1;
        if ((archiveTreeFindPath(v10, __dst, (unsigned int *)&v36) & 0x80000000) == 0)
        {
          size_t v19 = ~v20;
          int v22 = v36;
          if (v36 == -1)
          {
            size_t v34 = v21;
            uint64_t v35 = v10;
            __int16 v27 = *(unsigned int **)v9;
            int v28 = __dst;
            while (1)
            {
              char v29 = strchr(v28, 47);
              size_t v30 = v29;
              int64_t v31 = v29 - v28;
              size_t v32 = v29 ? v29 - v28 : v25;
              if ((archiveTreeAppend(v27, v22, v28, v32, -1, -1, 68) & 0x80000000) != 0) {
                break;
              }
              __int16 v27 = *(unsigned int **)v9;
              int v22 = **(_DWORD **)v9 - 1;
              int v36 = v22;
              if (v30)
              {
                v28 += v31 + 1;
                v25 -= v31 + 1;
                if (v25) {
                  continue;
                }
              }
              uint64_t v21 = v34;
              uint64_t v10 = v35;
              goto LABEL_31;
            }
            uint64_t v23 = "inserting tree node";
            __int16 v24 = 640;
            goto LABEL_19;
          }
LABEL_31:
          uint64_t result = archiveTreeAppend((unsigned int *)v10, v22, v21, v19, v12, -1, *(_DWORD *)(a2 + 4));
          if ((result & 0x80000000) == 0)
          {
            *(_DWORD *)(v9 + 8) = *(_DWORD *)v10 - 1;
            return result;
          }
          uint64_t v23 = "inserting tree node";
          __int16 v24 = 650;
          goto LABEL_19;
        }
        uint64_t v23 = "looking up parent path failed";
        __int16 v24 = 624;
      }
      else
      {
LABEL_16:
        if ((archiveTreeFindPath(v10, (const char *)&unk_2106C9523, (unsigned int *)&v36) & 0x80000000) == 0)
        {
          uint64_t v21 = __dst;
          int v22 = v36;
          goto LABEL_31;
        }
        uint64_t v23 = "looking up parent path failed";
        __int16 v24 = 629;
      }
    }
LABEL_19:
    uint64_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeFromIndexBeginProc", v24, 34, 0, v23, a7, a8, v33);
    *(_DWORD *)(v9 + 12) = 0;
  }
  return result;
}

uint64_t archiveTreeSort(_DWORD *a1)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  if (*a1)
  {
    if ((archiveTreeSortStringTable((unsigned int **)a1) & 0x80000000) != 0)
    {
      size_t v9 = "sort string table";
      __int16 v10 = 510;
    }
    else
    {
      if ((archiveTreeUpdateDepth(a1) & 0x80000000) == 0)
      {
        uint64_t v4 = (unsigned int *)calloc(*a1, 4uLL);
        uint64_t v5 = v4;
        if (v4)
        {
          if (*a1)
          {
            size_t v6 = 0;
            do
            {
              v4[v6] = v6;
              ++v6;
              size_t v7 = *a1;
            }
            while (v6 < v7);
          }
          else
          {
            size_t v7 = 0;
          }
          qsort_r(v4, v7, 4uLL, a1, (int (__cdecl *)(void *, const void *, const void *))archiveTreeCompareNodesLexProc);
          unint64_t v16 = *a1;
          if (v16)
          {
            uint64_t v17 = 0;
            size_t v18 = 0;
            while (v17)
            {
              unsigned int v19 = v5[v17 - 1];
              unsigned int v20 = v5[v17];
              if (v19 != v20)
              {
                unsigned int v21 = v5[v17];
                while (v21 != -1)
                {
                  if (v19 == -1) {
                    break;
                  }
                  uint64_t v22 = *((void *)a1 + 1);
                  if (*(_DWORD *)(v22 + 56 * v19 + 12) != *(_DWORD *)(v22 + 56 * v21 + 12)) {
                    break;
                  }
                  unsigned int v19 = *(_DWORD *)(v22 + 56 * v19);
                  unsigned int v21 = *(_DWORD *)(v22 + 56 * v21);
                  if (v19 == v21) {
                    goto LABEL_24;
                  }
                }
                goto LABEL_26;
              }
LABEL_24:
              ArchiveTreeNodePath((uint64_t)a1, v20, (uint64_t)v31, 0x400uLL);
              ArchiveTreeNodePath((uint64_t)a1, v5[v17 - 1], (uint64_t)v30, 0x400uLL);
              *(_DWORD *)(*((void *)a1 + 1) + 56 * v5[v17] + 48) = v18 - 1;
              unint64_t v16 = *a1;
LABEL_27:
              if (++v17 >= v16) {
                goto LABEL_30;
              }
            }
            unsigned int v20 = *v5;
LABEL_26:
            *(_DWORD *)(*((void *)a1 + 1) + 56 * v20 + 48) = v18;
            size_t v18 = (v18 + 1);
            goto LABEL_27;
          }
          size_t v18 = 0;
LABEL_30:
          if ((archiveTreeRemapNodes(a1, v18) & 0x80000000) != 0)
          {
            uint64_t v14 = "remapping nodes";
            __int16 v15 = 544;
          }
          else if ((archiveTreeUpdateDepth(a1) & 0x80000000) != 0)
          {
            uint64_t v14 = "storing depth in AUX";
            __int16 v15 = 547;
          }
          else
          {
            if (*a1)
            {
              size_t v23 = 0;
              do
              {
                v5[v23] = v23;
                ++v23;
                size_t v24 = *a1;
              }
              while (v23 < v24);
            }
            else
            {
              size_t v24 = 0;
            }
            qsort_r(v5, v24, 4uLL, a1, (int (__cdecl *)(void *, const void *, const void *))archiveTreeCompareNodesStrProc);
            uint64_t v25 = *a1;
            if (v25)
            {
              uint64_t v26 = 0;
              uint64_t v27 = *((void *)a1 + 1);
              do
              {
                *(_DWORD *)(v27 + 56 * v5[v26] + 48) = v26;
                ++v26;
              }
              while (v25 != v26);
            }
            if ((archiveTreeRemapNodes(a1, v18) & 0x80000000) == 0)
            {
              uint64_t v8 = 0;
LABEL_48:
              free(v5);
              return v8;
            }
            uint64_t v14 = "remapping nodes";
            __int16 v15 = 559;
          }
          int v11 = 0;
        }
        else
        {
          int v11 = *__error();
          uint64_t v14 = "malloc";
          __int16 v15 = 517;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeSort", v15, 34, v11, v14, v12, v13, v29);
LABEL_47:
        uint64_t v8 = 0xFFFFFFFFLL;
        goto LABEL_48;
      }
      size_t v9 = "store AUX in depth";
      __int16 v10 = 513;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeSort", v10, 34, 0, v9, v2, v3, v29);
    uint64_t v5 = 0;
    goto LABEL_47;
  }
  return 0;
}

uint64_t ArchiveTreeNodePath(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4)
{
  if (a2 == -1 || *(_DWORD *)a1 <= a2)
  {
    uint64_t result = 0;
LABEL_8:
    *(unsigned char *)(a3 + result) = 0;
    return result;
  }
  uint64_t v8 = ArchiveTreeNodePath(a1, *(unsigned int *)(*(void *)(a1 + 8) + 56 * a2), a3);
  if ((v8 & 0x8000000000000000) == 0)
  {
    uint64_t v9 = *(void *)(a1 + 16);
    uint64_t v10 = *(void *)(v9 + 32);
    uint64_t v11 = *(void *)(v9 + 8) + 16 * *(unsigned int *)(*(void *)(a1 + 8) + 56 * a2 + 12);
    uint64_t v12 = *(void *)v11;
    size_t v13 = *(unsigned int *)(v11 + 8);
    if (v8)
    {
      uint64_t v14 = v8 + 1;
      if (v8 + 1 + v13 < a4)
      {
        *(unsigned char *)(a3 + v8) = 47;
LABEL_11:
        memcpy((void *)(a3 + v14), (const void *)(v10 + v12), v13);
        uint64_t result = v14 + v13;
        goto LABEL_8;
      }
    }
    else if (v13 < a4)
    {
      uint64_t v14 = 0;
      goto LABEL_11;
    }
  }
  return -1;
}

unsigned int *ArchiveTreeCreateFromArchive(uint64_t a1, uint64_t a2, int a3)
{
  int DefaultNThreads = a3;
  uint64_t v32 = *MEMORY[0x263EF8340];
  if (!a3) {
    int DefaultNThreads = getDefaultNThreads();
  }
  size_t v30 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v25 = 0u;
  memset(v31, 0, 512);
  size_t v6 = (unsigned int *)archiveTreeCreate();
  if (v6)
  {
    bzero((char *)v31 + 8, 0x428uLL);
    DWORD2(v31[0]) = 1;
    *(void *)&v31[0] = v6;
    *((void *)&v25 + 1) = a1;
    *(void *)&long long v26 = 0;
    LODWORD(v25) = 0;
    DWORD1(v25) = DefaultNThreads;
    *((void *)&v26 + 1) = a2;
    *(void *)&long long v27 = archiveTreeFromArchiveBeginProc;
    *(void *)&long long v29 = archiveTreeFromArchiveEndProc;
    *((void *)&v27 + 1) = archiveTreeFromArchiveBlobProc;
    *(void *)&long long v28 = archiveTreeFromArchivePayloadProc;
    *((void *)&v28 + 1) = archiveTreeFromArchivePaddingProc;
    *((void *)&v29 + 1) = archiveTreeFromArchivePaddingProc;
    size_t v30 = v31;
    if (ParallelArchiveRead((uint64_t)&v25, v7, v8, v9, v10, v11, v12, v13) || !DWORD2(v31[0]))
    {
      unsigned int v21 = "parsing archive";
      __int16 v22 = 1292;
    }
    else
    {
      if (!archiveTreeSort(v6))
      {
        archiveTreeUpdateChilds(v6, v16, v17, v18, v19, v20, v14, v15);
        return v6;
      }
      unsigned int v21 = "sorting tree";
      __int16 v22 = 1295;
    }
    int v23 = 0;
  }
  else
  {
    int v23 = *__error();
    unsigned int v21 = "archive tree creation";
    __int16 v22 = 1274;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"ArchiveTreeCreateFromArchive", v22, 34, v23, v21, v14, v15, v25);
  ArchiveTreeDestroy((uint64_t)v6);
  return 0;
}

char *archiveTreeFromArchiveBeginProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6 = *(_DWORD *)(a2 + 4);
  *(unsigned char *)(a1 + 48) = 0;
  uint64_t result = (char *)(a1 + 48);
  uint64_t v8 = *((void *)result - 4);
  *((void *)result - 4) = v8 + a6;
  *((void *)result - 3) = v8;
  *((_DWORD *)result - 2) = 0;
  *((_DWORD *)result - 1) = v6;
  if ((*(unsigned char *)(a2 + 1) & 0x80) != 0) {
    return (char *)strlcpy(result, (const char *)(a2 + 144), 0x400uLL);
  }
  return result;
}

size_t archiveTreeFromArchiveEndProc(size_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  uint64_t v2 = *(void *)(result + 16) - v1;
  *(void *)(result + 32) = v2;
  int v3 = *(_DWORD *)(result + 44);
  if (v3 != 77)
  {
    size_t v4 = result;
    uint64_t v5 = (char *)(result + 48);
    size_t v6 = strlen((const char *)(result + 48));
    size_t v7 = v6;
    int v21 = -1;
    if (v6 >= 2)
    {
      if (*(_WORD *)v5 == 12078)
      {
        uint64_t v5 = (char *)(v4 + 50);
        size_t v7 = v6 - 2;
        if (v6 == 2) {
          goto LABEL_9;
        }
      }
LABEL_12:
      uint64_t v12 = strrchr(v5, 47);
      if (v12)
      {
        uint64_t v13 = v12;
        uint64_t v14 = v12 + 1;
        if (v12 == v5) {
          goto LABEL_17;
        }
        *uint64_t v12 = 0;
        if ((archiveTreeFindPath(*(void *)v4, v5, (unsigned int *)&v21) & 0x80000000) == 0)
        {
          char *v13 = 47;
          goto LABEL_17;
        }
        uint64_t v10 = "looking up parent node";
        __int16 v11 = 712;
      }
      else
      {
        uint64_t v14 = v5;
        if ((archiveTreeFindPath(*(void *)v4, (const char *)&unk_2106C9523, (unsigned int *)&v21) & 0x80000000) == 0)
        {
LABEL_17:
          if (v21 == -1)
          {
            int v16 = -1;
            while (1)
            {
              uint64_t v17 = strchr(v5, 47);
              uint64_t v18 = *(unsigned int **)v4;
              if (!v17) {
                break;
              }
              int64_t v19 = v17 - v5;
              uint64_t result = archiveTreeAppend(v18, v16, v5, v17 - v5, -1, -1, 68);
              if ((result & 0x80000000) != 0)
              {
                uint64_t v10 = "inserting tree node";
                __int16 v11 = 741;
                goto LABEL_30;
              }
              v5 += v19 + 1;
              int v16 = **(_DWORD **)v4 - 1;
              int v21 = v16;
              v7 -= v19 + 1;
              if (!v7) {
                return result;
              }
            }
            uint64_t result = archiveTreeAppend(v18, v16, v5, v7, *(void *)(v4 + 24), *(void *)(v4 + 16) - *(void *)(v4 + 24), *(_DWORD *)(v4 + 44));
            if ((result & 0x80000000) == 0) {
              return result;
            }
            uint64_t v10 = "inserting tree node";
            __int16 v11 = 748;
          }
          else
          {
            size_t v15 = strlen(v14);
            uint64_t result = archiveTreeAppend(*(unsigned int **)v4, v21, v14, v15, *(void *)(v4 + 24), *(void *)(v4 + 32), *(_DWORD *)(v4 + 44));
            if ((result & 0x80000000) == 0) {
              return result;
            }
            uint64_t v10 = "inserting tree node";
            __int16 v11 = 725;
          }
          goto LABEL_30;
        }
        uint64_t v10 = "looking up parent node";
        __int16 v11 = 719;
      }
LABEL_30:
      uint64_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeFromArchiveEndProc", v11, 34, 0, v10, v8, v9, v20);
      *(_DWORD *)(v4 + 8) = 0;
      return result;
    }
    if (v6 == 1)
    {
      if (*(unsigned char *)(v4 + 48) != 46)
      {
        size_t v7 = 1;
        goto LABEL_12;
      }
      uint64_t v5 = (char *)(v4 + 49);
    }
LABEL_9:
    uint64_t result = archiveTreeAppend(*(unsigned int **)v4, -1, v5, 0, v1, v2, v3);
    if ((result & 0x80000000) == 0) {
      return result;
    }
    uint64_t v10 = "inserting root node";
    __int16 v11 = 698;
    goto LABEL_30;
  }
  return result;
}

_DWORD *archiveTreeFromArchiveBlobProc(_DWORD *result, _DWORD *a2, size_t a3)
{
  int v3 = result;
  if (!a3 || result[11] != 77 || (*a2 & 0xDFDFDF) != 0x464159)
  {
    size_t v7 = result + 10;
    goto LABEL_8;
  }
  uint64_t v4 = *(void *)(*(void *)result + 24);
  result[10] = v4 == 0;
  if (!v4)
  {
    uint64_t result = MemBufferCreate(a3);
    *(void *)(*(void *)v3 + 24) = result;
    if (!result)
    {
      uint64_t result = (_DWORD *)pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeFromArchiveBlobProc", 764, 34, 0, "allocating YAF buffer", v5, v6, v8);
      size_t v7 = v3 + 2;
LABEL_8:
      _DWORD *v7 = 0;
    }
  }
  return result;
}

unint64_t *archiveTreeFromArchivePayloadProc(unint64_t *result, const void *a2, size_t a3)
{
  result[2] += a3;
  if (*((_DWORD *)result + 10))
  {
    uint64_t v4 = result;
    uint64_t result = *(unint64_t **)(*result + 24);
    if (result)
    {
      uint64_t result = (unint64_t *)MemBufferFillFromBuffer(result, a3, a2);
      if (result != (unint64_t *)a3)
      {
        uint64_t result = (unint64_t *)pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeFromArchivePayloadProc", 775, 34, 0, "collecting YAF buffer", v5, v6, v7);
        *((_DWORD *)v4 + 2) = 0;
      }
    }
  }
  return result;
}

uint64_t archiveTreeFromArchivePaddingProc(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 16) += a3;
  return result;
}

unsigned int *ArchiveTreeCreateFromDirectory(char *a1, const __CFArray *a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  int DefaultNThreads = a5;
  uint64_t v45 = *MEMORY[0x263EF8340];
  if (!a5) {
    int DefaultNThreads = getDefaultNThreads();
  }
  uint64_t v12 = (unsigned int *)archiveTreeCreate();
  uint64_t v13 = v12;
  if (!v12)
  {
    int v21 = *__error();
    __int16 v22 = "archive tree creation";
    __int16 v23 = 1323;
LABEL_31:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"ArchiveTreeCreateFromDirectory", v23, 34, v21, v22, v18, v19, (char)v32);
    ArchiveTreeDestroy((uint64_t)v13);
    return 0;
  }
  if (a2)
  {
    bzero(buffer, 0x400uLL);
    bzero(v34, 0x800uLL);
    CFIndex Count = CFArrayGetCount(a2);
    if (Count)
    {
      CFIndex v15 = Count;
      CFIndex v16 = 0;
      while (1)
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, v16);
        if (!CFStringGetCString(ValueAtIndex, buffer, 1024, 0x8000100u))
        {
          __int16 v22 = "getting string from includePaths";
          __int16 v23 = 1341;
          goto LABEL_30;
        }
        if ((concatPath(v34, 0x800uLL, a1, buffer) & 0x80000000) != 0)
        {
          __int16 v22 = "building full path from includePaths";
          __int16 v23 = 1342;
          goto LABEL_30;
        }
        memset(&v33, 0, sizeof(v33));
        if (stat(v34, &v33) || (v33.st_mode & 0xF000) != 0x4000)
        {
          uint64_t v32 = v34;
          __int16 v22 = "include path doesn't exist, or is not a directory: %s";
          __int16 v23 = 1346;
          goto LABEL_30;
        }
        size_t v20 = strlen(buffer);
        if (archiveTreeAppend(v13, -1, buffer, v20, -1, -1, 68)) {
          break;
        }
        if (v15 == ++v16) {
          goto LABEL_17;
        }
      }
      __int16 v22 = "ArchiveTree append";
      __int16 v23 = 1351;
      goto LABEL_30;
    }
  }
  else if (archiveTreeAppend(v12, -1, &unk_2106C9523, 0, -1, -1, 68))
  {
    __int16 v22 = "ArchiveTree append";
    __int16 v23 = 1330;
LABEL_30:
    int v21 = 0;
    goto LABEL_31;
  }
LABEL_17:
  unsigned int v24 = *v13;
  if (*v13)
  {
    unsigned int v25 = 0;
    while (1)
    {
      unsigned int v40 = v25;
      unsigned int v41 = v24;
      unsigned int v25 = v24;
      long long v42 = 0u;
      long long v43 = 0u;
      *(_DWORD *)size_t v34 = a6;
      int v35 = DefaultNThreads;
      int v36 = a1;
      uint64_t v37 = a3;
      uint64_t v38 = a4;
      uint64_t v39 = v13;
      if (expandDirRange((uint64_t)v34)) {
        break;
      }
      unsigned int v24 = *v13;
      if (v25 >= *v13) {
        goto LABEL_21;
      }
    }
    __int16 v22 = "expanding archive tree range";
    __int16 v23 = 1370;
    goto LABEL_30;
  }
LABEL_21:
  long long v42 = 0u;
  long long v43 = 0u;
  *(_DWORD *)size_t v34 = a6;
  int v35 = DefaultNThreads;
  int v36 = a1;
  uint64_t v37 = a3;
  uint64_t v38 = a4;
  uint64_t v39 = v13;
  unsigned int v40 = 0;
  unsigned int v41 = v24;
  LODWORD(v42) = 1;
  if (expandDirRange((uint64_t)v34))
  {
    __int16 v22 = "expanding archive tree range";
    __int16 v23 = 1390;
    goto LABEL_30;
  }
  if (archiveTreeSort(v13))
  {
    __int16 v22 = "sorting tree";
    __int16 v23 = 1394;
    goto LABEL_30;
  }
  archiveTreeUpdateChilds(v13, v26, v27, v28, v29, v30, v18, v19);
  if (a6 > 1) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12u entries in archive tree\n", *v13);
  }
  return v13;
}

uint64_t expandDirRange(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 40);
  if (!v1) {
    return 0;
  }
  if ((v1 + 999) < 0x3E8) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = (v1 + 999) / 0x3E8u;
  }
  int v6 = *(_DWORD *)a1;
  unsigned int v5 = *(_DWORD *)(a1 + 4);
  *(void *)(a1 + 56) = 0;
  char v7 = (uint64_t *)(a1 + 56);
  *(void *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  if ((v1 + 999) / 0x3E8u <= v5) {
    size_t v8 = v4;
  }
  else {
    size_t v8 = v5;
  }
  unsigned int v9 = (v1 + (int)v8 - 1) / v8;
  if (v6 >= 2) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "Running %u threads to expand %u nodes (%u per thread)\n", v8, v1, (v1 + (int)v8 - 1) / v8);
  }
  if (v8 == 1)
  {
    uint64_t v10 = archiveTreeCreate();
    uint64_t *v7 = (uint64_t)v10;
    if (v10)
    {
      expandDirRangeThreadProc();
      if (!*(_DWORD *)(a1 + 72))
      {
        __int16 v14 = 1000;
        int v37 = 0;
        uint64_t v13 = "expandDirRange";
        goto LABEL_40;
      }
      if (!archiveTreeAppendTree(*(unsigned int **)(a1 + 32), *(unsigned int **)(a1 + 56), 0))
      {
        int v25 = 1;
        goto LABEL_49;
      }
      uint64_t v13 = "append expandDirRange output to main tree";
      __int16 v14 = 1003;
    }
    else
    {
      uint64_t v13 = "archive tree creation";
      __int16 v14 = 996;
    }
    int v37 = 0;
LABEL_40:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDirRange", v14, 34, v37, v13, v11, v12, v47);
    int v25 = 0;
    goto LABEL_49;
  }
  CFIndex v15 = (char *)calloc(v8, 0x50uLL);
  if (!v15)
  {
    int v37 = *__error();
    uint64_t v13 = "malloc";
    __int16 v14 = 1009;
    goto LABEL_40;
  }
  CFIndex v16 = v15;
  int v17 = *(_DWORD *)(a1 + 40);
  uint64_t v18 = v15 + 56;
  size_t v19 = v8;
  do
  {
    if (v17 + v9 >= *(_DWORD *)(a1 + 44)) {
      int v20 = *(_DWORD *)(a1 + 44);
    }
    else {
      int v20 = v17 + v9;
    }
    long long v21 = *(_OWORD *)(a1 + 48);
    long long v22 = *(_OWORD *)(a1 + 64);
    long long v23 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)(v18 - 24) = *(_OWORD *)(a1 + 32);
    *(_OWORD *)(v18 - 56) = *(_OWORD *)a1;
    *(_OWORD *)(v18 + 8) = v22;
    *(_OWORD *)(v18 - 8) = v21;
    *(_OWORD *)(v18 - 40) = v23;
    *((_DWORD *)v18 - 4) = v17;
    *((_DWORD *)v18 - 3) = v20;
    unsigned int v24 = archiveTreeCreate();
    *(void *)uint64_t v18 = v24;
    if (!v24)
    {
      uint64_t v38 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDirRange", 1022, 34, *v38, "malloc", v39, v40, v47);
      int v25 = 0;
      goto LABEL_45;
    }
    v18 += 80;
    int v17 = v20;
    --v19;
  }
  while (v19);
  int v25 = 1;
  size_t v26 = v8;
  uint64_t v27 = (uint64_t)v16;
  do
  {
    if (createThread((pthread_t *)(v27 + 64), (uint64_t)expandDirRangeThreadProc, v27, 0))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDirRange", 1030, 34, 0, "create expandDir thread", v28, v29, v47);
      int v25 = 0;
    }
    v27 += 80;
    --v26;
  }
  while (v26);
  uint64_t v30 = v16 + 72;
  size_t v31 = v8;
  do
  {
    uint64_t v32 = (_opaque_pthread_t *)*((void *)v30 - 1);
    if (!v32) {
      goto LABEL_33;
    }
    if (joinThread(v32))
    {
      __int16 v35 = 1037;
      int v36 = "join expandDir thread";
LABEL_31:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDirRange", v35, 34, 0, v36, v33, v34, v47);
      int v25 = 0;
      goto LABEL_33;
    }
    if (!*v30)
    {
      __int16 v35 = 1038;
      int v36 = "expandDirRange";
      goto LABEL_31;
    }
LABEL_33:
    v30 += 20;
    --v31;
  }
  while (v31);
  unsigned int v41 = (unsigned int **)(v16 + 56);
  size_t v42 = v8;
  do
  {
    if (archiveTreeAppendTree(*(unsigned int **)(a1 + 32), *v41, 0))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDirRange", 1044, 34, 0, "append expandDirRange output to main tree", v43, v44, v47);
      int v25 = 0;
    }
    v41 += 10;
    --v42;
  }
  while (v42);
LABEL_45:
  uint64_t v45 = (uint64_t *)(v16 + 56);
  do
  {
    uint64_t v46 = *v45;
    v45 += 10;
    ArchiveTreeDestroy(v46);
    --v8;
  }
  while (v8);
  free(v16);
LABEL_49:
  ArchiveTreeDestroy(*v7);
  uint64_t *v7 = 0;
  if (v25) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t ArchiveTreeMergeAndDestroy(uint64_t a1, unsigned int *a2, int a3)
{
  if (!a2) {
    return 0;
  }
  unsigned int v6 = *(_DWORD *)a1;
  uint64_t v7 = *a2;
  size_t v8 = calloc((v7 + *(_DWORD *)a1), 0x38uLL);
  if (!v8)
  {
    int v37 = *__error();
    uint64_t v38 = "malloc";
    __int16 v39 = 1435;
    goto LABEL_38;
  }
  if (v7)
  {
    unsigned int v9 = (_DWORD *)(*((void *)a2 + 1) + 40);
    uint64_t v10 = v7;
    do
    {
      *unsigned int v9 = a3;
      v9 += 14;
      --v10;
    }
    while (v10);
  }
  if ((archiveTreeAppendTree((unsigned int *)a1, a2, 1) & 0x80000000) != 0)
  {
    uint64_t v38 = "merging trees";
    __int16 v39 = 1441;
    goto LABEL_37;
  }
  if ((archiveTreeSortStringTable((unsigned int **)a1) & 0x80000000) != 0)
  {
    uint64_t v38 = "sorting string table";
    __int16 v39 = 1444;
    goto LABEL_37;
  }
  if ((archiveTreeUpdateDepth((unsigned int *)a1) & 0x80000000) != 0)
  {
    uint64_t v38 = "storing node depth in AUX";
    __int16 v39 = 1447;
    goto LABEL_37;
  }
  int v47 = v7 + v6;
  unsigned int v13 = 0;
  if (v6 | v7)
  {
    unsigned int v14 = 0;
    unsigned int v15 = 0;
    BOOL v16 = v7 != 0;
    BOOL v17 = v6 != 0;
    while (1)
    {
      if (v16)
      {
        unsigned int v18 = v14 + v6;
        if (!v17) {
          goto LABEL_15;
        }
        int v19 = archiveTreeCompareNodesStrRec(a1, v15, v14 + v6, 0, 0);
        if ((v19 & 0x80000000) == 0) {
          break;
        }
      }
      uint64_t v25 = *(void *)(a1 + 8) + 56 * v15;
      *(_DWORD *)(v25 + 48) = v13;
      size_t v26 = (char *)&v8[14 * v13];
      long long v27 = *(_OWORD *)v25;
      long long v28 = *(_OWORD *)(v25 + 16);
      long long v29 = *(_OWORD *)(v25 + 32);
      *((void *)v26 + 6) = *(void *)(v25 + 48);
      *((_OWORD *)v26 + 1) = v28;
      *((_OWORD *)v26 + 2) = v29;
      *(_OWORD *)size_t v26 = v27;
      ++v15;
LABEL_18:
      ++v13;
      BOOL v16 = v14 < v7;
      BOOL v17 = v15 < v6;
      if (v15 >= v6 && v14 >= v7) {
        goto LABEL_25;
      }
    }
    if (v19)
    {
LABEL_15:
      uint64_t v20 = *(void *)(a1 + 8) + 56 * v18;
      *(_DWORD *)(v20 + 48) = v13;
      long long v21 = (char *)&v8[14 * v13];
      long long v22 = *(_OWORD *)v20;
      long long v23 = *(_OWORD *)(v20 + 16);
      long long v24 = *(_OWORD *)(v20 + 32);
      *((void *)v21 + 6) = *(void *)(v20 + 48);
      *((_OWORD *)v21 + 1) = v23;
      *((_OWORD *)v21 + 2) = v24;
      *(_OWORD *)long long v21 = v22;
    }
    else
    {
      uint64_t v30 = *(void *)(a1 + 8);
      size_t v31 = (long long *)(v30 + 56 * v15);
      *((_DWORD *)v31 + 12) = v13;
      *(_DWORD *)(v30 + 56 * v18 + 48) = v13;
      uint64_t v32 = (char *)&v8[14 * v13];
      long long v33 = *v31;
      long long v34 = v31[1];
      long long v35 = v31[2];
      *((void *)v32 + 6) = *((void *)v31 + 6);
      *((_OWORD *)v32 + 1) = v34;
      *((_OWORD *)v32 + 2) = v35;
      *(_OWORD *)uint64_t v32 = v33;
      ++v15;
    }
    ++v14;
    goto LABEL_18;
  }
LABEL_25:
  uint64_t v40 = *(void **)(a1 + 8);
  if (!v47)
  {
LABEL_33:
    free(v40);
    uint64_t v36 = 0;
    *(void *)(a1 + 8) = v8;
    *(_DWORD *)a1 = v13;
    *(_DWORD *)(a1 + 4) = v47;
    size_t v8 = 0;
    goto LABEL_39;
  }
  uint64_t v41 = v7 + v6;
  size_t v42 = *(unsigned int **)(a1 + 8);
  while (1)
  {
    unsigned int v43 = v42[12];
    if (v43 != -1) {
      break;
    }
LABEL_32:
    v42 += 14;
    if (!--v41) {
      goto LABEL_33;
    }
  }
  if (v43 < v13)
  {
    unsigned int v44 = *v42;
    if (*v42 != -1) {
      unsigned int v44 = *((_DWORD *)v40 + 14 * v44 + 12);
    }
    v8[14 * v43] = v44;
    goto LABEL_32;
  }
  uint64_t v38 = "invalid new index";
  __int16 v39 = 1490;
LABEL_37:
  int v37 = 0;
LABEL_38:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"ArchiveTreeMergeAndDestroy", v39, 34, v37, v38, v11, v12, v46);
  uint64_t v36 = 0xFFFFFFFFLL;
LABEL_39:
  free(v8);
  ArchiveTreeDestroy((uint64_t)a2);
  return v36;
}

uint64_t archiveTreeAppendTree(unsigned int *a1, unsigned int *a2, int a3)
{
  if (!a2) {
    return 0;
  }
  if (!*a2) {
    return 0;
  }
  if (archiveTreeReserve((uint64_t)a1, *a1 + *a2))
  {
    size_t v8 = "increasing archive tree storage";
    __int16 v9 = 164;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeAppendTree", v9, 34, 0, v8, v6, v7, v17);
    return 0xFFFFFFFFLL;
  }
  int v18 = 0;
  if ((StringTableAppendTable(*((void *)a1 + 2), *((unsigned int **)a2 + 2), &v18) & 0x80000000) != 0)
  {
    size_t v8 = "merging string tables";
    __int16 v9 = 168;
    goto LABEL_5;
  }
  memcpy((void *)(*((void *)a1 + 1) + 56 * *a1), *((const void **)a2 + 1), 56 * *a2);
  int v11 = *a2;
  int v12 = *a1;
  if (*a2)
  {
    uint64_t v13 = *((void *)a1 + 1);
    uint64_t v14 = *a2;
    unsigned int v15 = *a1;
    do
    {
      BOOL v16 = (_DWORD *)(v13 + 56 * v15);
      v16[3] += v18;
      if (a3)
      {
        if (*v16 != -1) {
          *v16 += v12;
        }
      }
      ++v15;
      --v14;
    }
    while (v14);
  }
  uint64_t result = 0;
  *a1 = v12 + v11;
  return result;
}

uint64_t archiveTreeSortStringTable(unsigned int **a1)
{
  if (!*(_DWORD *)a1) {
    return 0;
  }
  uint64_t v10 = 0;
  int v4 = StringTableSort(a1[2], &v10);
  if (v4)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeSortStringTable", 397, 34, 0, "string table sorting", v2, v3, v9);
    unsigned int v5 = v10;
  }
  else
  {
    uint64_t v7 = *(unsigned int *)a1;
    unsigned int v5 = v10;
    if (v7)
    {
      size_t v8 = a1[1] + 3;
      do
      {
        *size_t v8 = v5[*v8];
        v8 += 14;
        --v7;
      }
      while (v7);
    }
  }
  free(v5);
  if (v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t archiveTreeUpdateDepth(unsigned int *a1)
{
  uint64_t v1 = *a1;
  if (!v1) {
    return 0;
  }
  uint64_t v3 = (_DWORD *)(*((void *)a1 + 1) + 44);
  do
  {
    *uint64_t v3 = -1;
    v3 += 14;
    --v1;
  }
  while (v1);
  unsigned int v4 = 0;
  while ((archiveTreeUpdateNodeDepth((uint64_t)a1, v4) & 0x80000000) == 0)
  {
    if (++v4 >= *a1) {
      return 0;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeUpdateDepth", 218, 34, 0, "update node depth", v5, v6, v8);
  return 0xFFFFFFFFLL;
}

uint64_t ArchiveTreePrune(unsigned int *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if ((archiveTreeUpdateDepth(a1) & 0x80000000) != 0)
  {
    size_t v31 = "updating depth field";
    __int16 v32 = 1520;
LABEL_38:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"ArchiveTreePrune", v32, 34, 0, v31, v6, v7, v33);
    return 0xFFFFFFFFLL;
  }
  else
  {
    if (*a1)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      unsigned int v10 = 0;
      int v11 = -1;
      do
      {
        uint64_t v12 = *((void *)a1 + 1);
        unsigned int v13 = *(_DWORD *)(v12 + v8 + 44);
        if (v13 == a2)
        {
          if (v11 != -1)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"ArchiveTreePrune", 1530, 34, 0, "invalid prune operation: more than one node at depth %u", v6, v7, a2);
            return 0xFFFFFFFFLL;
          }
          *(_DWORD *)(v12 + v8) = -1;
          if ((StringTableAppend(*((unsigned int **)a1 + 2), &unk_2106C9523, 0, (_DWORD *)(v12 + v8 + 12), v4, v5, v6, v7) & 0x80000000) != 0)
          {
            size_t v31 = "inserting new root name string";
            __int16 v32 = 1536;
            goto LABEL_38;
          }
          uint64_t v12 = *((void *)a1 + 1);
          unsigned int v13 = *(_DWORD *)(v12 + v8 + 44);
          int v11 = v9;
        }
        BOOL v14 = v13 >= a2;
        if (v13 < a2) {
          int v15 = -1;
        }
        else {
          int v15 = v10;
        }
        if (v14) {
          ++v10;
        }
        *(_DWORD *)(v12 + v8 + 48) = v15;
        ++v9;
        unint64_t v16 = *a1;
        v8 += 56;
      }
      while (v9 < v16);
      if (*a1)
      {
        char v17 = (unsigned int *)*((void *)a1 + 1);
        int v18 = v17;
        uint64_t v19 = *a1;
        do
        {
          if (v18[12] != -1 && *v18 != -1) {
            *int v18 = v17[14 * *v18 + 12];
          }
          v18 += 14;
          --v19;
        }
        while (v19);
        uint64_t v20 = 0;
        for (unint64_t i = 0; i < v16; ++i)
        {
          uint64_t v22 = *((void *)a1 + 1);
          long long v23 = (long long *)(v22 + v20);
          unint64_t v24 = *(unsigned int *)(v22 + v20 + 48);
          if (v24 != -1)
          {
            if (v24 >= v10 || i < v24)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreePackNodes", 424, 34, 0, "invalid new index", v6, v7, v33);
              size_t v31 = "remapping tree nodes";
              __int16 v32 = 1543;
              goto LABEL_38;
            }
            if (i > v24)
            {
              uint64_t v26 = v22 + 56 * v24;
              long long v27 = *v23;
              long long v28 = v23[1];
              long long v29 = v23[2];
              *(void *)(v26 + 48) = *((void *)v23 + 6);
              *(_OWORD *)(v26 + 16) = v28;
              *(_OWORD *)(v26 + 32) = v29;
              *(_OWORD *)uint64_t v26 = v27;
              unint64_t v16 = *a1;
            }
          }
          v20 += 56;
        }
      }
    }
    else
    {
      unsigned int v10 = 0;
    }
    uint64_t result = 0;
    *a1 = v10;
  }
  return result;
}

size_t ArchiveTreeInsert(uint64_t a1, char *__s)
{
  if (__s) {
    size_t result = strlen(__s);
  }
  else {
    size_t result = 0;
  }
  do
  {
    if (!result) {
      return result;
    }
    size_t v5 = result - 1;
    int v6 = __s[--result];
  }
  while (v6 == 47);
  if ((archiveTreeUpdateDepth((unsigned int *)a1) & 0x80000000) != 0)
  {
    unsigned int v10 = "updating tree depth";
    __int16 v11 = 1572;
    goto LABEL_12;
  }
  if (!*(_DWORD *)a1 || (unint64_t v9 = *(_DWORD **)(a1 + 8), v9[11]) || *v9 != -1)
  {
    unsigned int v10 = "invalid input for ArchiveTreeInsert";
    __int16 v11 = 1575;
    goto LABEL_12;
  }
  if ((archiveTreeAppend((unsigned int *)a1, -1, &unk_2106C9523, 0, -1, -1, 68) & 0x80000000) != 0)
  {
    unsigned int v10 = "inserting root node";
    __int16 v11 = 1579;
    goto LABEL_12;
  }
  unint64_t v14 = 0;
  unint64_t v15 = 0;
  int v16 = *(_DWORD *)a1 - 1;
  while (__s[v14] && __s[v14] != 47)
  {
    ++v14;
LABEL_26:
    if (v14 > v5 + 1)
    {
      archiveTreeSort((_DWORD *)a1);
      return 0;
    }
  }
  if (v14 == v15)
  {
LABEL_25:
    unint64_t v15 = ++v14;
    goto LABEL_26;
  }
  if (v14 - 1 == v5)
  {
    if ((StringTableAppend(*(unsigned int **)(a1 + 16), &__s[v15], v14 - v15, (_DWORD *)(*(void *)(a1 + 8) + 12), v12, v13, v7, v8) & 0x80000000) != 0)
    {
      unsigned int v10 = "inserting string";
      __int16 v11 = 1596;
      goto LABEL_12;
    }
    **(_DWORD **)(a1 + 8) = v16;
    goto LABEL_25;
  }
  if ((archiveTreeAppend((unsigned int *)a1, v16, &__s[v15], v14 - v15, -1, -1, 68) & 0x80000000) == 0)
  {
    int v16 = *(_DWORD *)a1 - 1;
    goto LABEL_25;
  }
  unsigned int v10 = "inserting new node";
  __int16 v11 = 1603;
LABEL_12:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"ArchiveTreeInsert", v11, 34, 0, v10, v7, v8, v17);
  return 0xFFFFFFFFLL;
}

unsigned int *ArchiveTreeSize(unsigned int *result)
{
  if (result) {
    return (unsigned int *)*result;
  }
  return result;
}

size_t ArchiveTreeYAF(size_t result, unsigned char *a2, unint64_t a3)
{
  *a2 = 0;
  if (result)
  {
    size_t v3 = result;
    size_t result = *(void *)(result + 24);
    if (result)
    {
      uint64_t DataPtr = (const void *)MemBufferGetDataPtr(result);
      size_t DataSize = MemBufferGetDataSize(*(void *)(v3 + 24));
      if (DataSize + 1 <= a3)
      {
        size_t v8 = DataSize;
        memcpy(a2, DataPtr, DataSize);
        a2[v8] = 0;
        return strlen(a2);
      }
      else
      {
        return -1;
      }
    }
  }
  return result;
}

uint64_t ArchiveTreeNodeEntryType(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)a1 <= a2) {
    return 0;
  }
  else {
    return *(unsigned int *)(*(void *)(a1 + 8) + 56 * a2 + 16);
  }
}

uint64_t ArchiveTreeNodeArchiveID(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)a1 <= a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *(unsigned int *)(*(void *)(a1 + 8) + 56 * a2 + 40);
  }
}

uint64_t ArchiveTreeNodeSegment(uint64_t a1, unsigned int a2, void *a3, void *a4)
{
  if (*(_DWORD *)a1 <= a2) {
    return 0xFFFFFFFFLL;
  }
  if (a3) {
    *a3 = *(void *)(*(void *)(a1 + 8) + 56 * a2 + 24);
  }
  uint64_t result = 0;
  if (a4) {
    *a4 = *(void *)(*(void *)(a1 + 8) + 56 * a2 + 32);
  }
  return result;
}

uint64_t archiveTreeReserve(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 4);
  if (v2 >= a2) {
    return 0;
  }
  unsigned int v4 = v2 ? v2 + (v2 >> 1) : 256;
  if (v4 <= a2) {
    unsigned int v4 = a2;
  }
  *(_DWORD *)(a1 + 4) = v4;
  size_t v5 = reallocf(*(void **)(a1 + 8), 56 * v4);
  *(void *)(a1 + 8) = v5;
  if (v5) {
    return 0;
  }
  uint64_t v7 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeReserve", 122, 34, *v7, "malloc", v8, v9, v10);
  *(void *)a1 = 0;
  return 0xFFFFFFFFLL;
}

uint64_t archiveTreeFindPath(uint64_t a1, const char *a2, unsigned int *a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  bzero(__s1, 0x400uLL);
  if (!*(_DWORD *)a1) {
    return 0;
  }
  unsigned int v6 = *(_DWORD *)a1 - 1;
  while (1)
  {
    if (ArchiveTreeNodePath(a1, v6, (uint64_t)__s1, 0x400uLL) < 0)
    {
      __int16 v15 = 243;
      goto LABEL_19;
    }
    int v9 = strcmp(__s1, a2);
    if (!v9)
    {
      unsigned int v12 = v6;
LABEL_21:
      if (a3) {
        *a3 = v12;
      }
      return 1;
    }
    if (v9 < 0) {
      break;
    }
    unsigned int v6 = *(_DWORD *)(*(void *)(a1 + 8) + 56 * v6);
    if (v6 == -1)
    {
      unsigned int v6 = 0;
      break;
    }
  }
  unsigned int v10 = *(_DWORD *)a1 - v6;
  if (v10 < 2) {
    return 0;
  }
  unsigned int v11 = v10 >> 1;
  while (1)
  {
    unsigned int v12 = v6 + v11;
    if (v6 + v11 < *(_DWORD *)a1) {
      break;
    }
    v11 >>= 1;
LABEL_16:
    if (!v11) {
      return 0;
    }
  }
  if ((ArchiveTreeNodePath(a1, v6 + v11, (uint64_t)__s1, 0x400uLL) & 0x8000000000000000) == 0)
  {
    int v13 = strcmp(__s1, a2);
    if (!v13) {
      goto LABEL_21;
    }
    v11 >>= v13 > 0;
    if (v13 <= 0) {
      unsigned int v6 = v12;
    }
    goto LABEL_16;
  }
  __int16 v15 = 262;
LABEL_19:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeFindPath", v15, 34, 0, "invalid path", v7, v8, v16);
  return 0xFFFFFFFFLL;
}

uint64_t archiveTreeCompareNodesLexProc(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  return archiveTreeCompareNodesLex(a1, *a2, *a3);
}

uint64_t archiveTreeRemapNodes(unsigned int *a1, size_t __count)
{
  unsigned int v2 = __count;
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v4 = __count;
  size_t v5 = (char *)calloc(__count, 0x38uLL);
  uint64_t v8 = v5;
  if (v5)
  {
    if (v2)
    {
      int v9 = v5 + 12;
      do
      {
        *((_DWORD *)v9 - 3) = -1;
        *(_DWORD *)int v9 = -1;
        *(void *)(v9 + 12) = -1;
        *(void *)(v9 + 20) = -1;
        v9 += 56;
        --v4;
      }
      while (v4);
    }
    uint64_t v10 = *a1;
    if (v10)
    {
      uint64_t v11 = *((void *)a1 + 1);
      uint64_t v12 = v11 + 24;
      do
      {
        unsigned int v13 = *(_DWORD *)(v12 + 24);
        if (v13 > v2)
        {
          long long v28 = "invalid new node index";
          __int16 v29 = 458;
          int v27 = 0;
          goto LABEL_25;
        }
        unint64_t v14 = &v5[56 * v13];
        if (!*((_DWORD *)v14 + 4)) {
          *((_DWORD *)v14 + 4) = *(_DWORD *)(v12 - 8);
        }
        __int16 v15 = &v5[56 * v13];
        uint64_t v17 = *((void *)v15 + 3);
        char v16 = v15 + 24;
        if (v17 == -1) {
          *char v16 = *(void *)v12;
        }
        uint64_t v18 = &v5[56 * v13];
        uint64_t v20 = *((void *)v18 + 4);
        uint64_t v19 = v18 + 32;
        if (v20 == -1) {
          *uint64_t v19 = *(void *)(v12 + 8);
        }
        long long v21 = &v5[56 * v13];
        int v23 = *((_DWORD *)v21 + 3);
        uint64_t v22 = v21 + 12;
        if (v23 == -1) {
          *uint64_t v22 = *(_DWORD *)(v12 - 12);
        }
        if (*(_DWORD *)v14 == -1)
        {
          unsigned int v24 = *(_DWORD *)(v12 - 24);
          if (v24 != -1) {
            *(_DWORD *)unint64_t v14 = *(_DWORD *)(v11 + 56 * v24 + 48);
          }
        }
        v12 += 56;
        --v10;
      }
      while (v10);
      unsigned int v25 = 0;
      do
        ArchiveTreeNodePath((uint64_t)a1, v25++, (uint64_t)v31, 0x400uLL);
      while (v25 < *a1);
    }
    free(*((void **)a1 + 1));
    uint64_t result = 0;
    *((void *)a1 + 1) = v8;
    *a1 = v2;
    a1[1] = v2;
  }
  else
  {
    int v27 = *__error();
    long long v28 = "malloc";
    __int16 v29 = 443;
LABEL_25:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeRemapNodes", v29, 34, v27, v28, v6, v7, v30);
    free(v8);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t archiveTreeCompareNodesStrProc(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  return archiveTreeCompareNodesStrRec(a1, *a2, *a3, 0, 0);
}

uint64_t archiveTreeCompareNodesLex(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (a2 == a3) {
    return 0;
  }
  if (a2 == -1) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v4 = a3;
  if (a3 == -1) {
    return 1;
  }
  uint64_t v6 = *(void *)(a1 + 8);
  unsigned int v7 = a2;
  unsigned int v8 = *(_DWORD *)(v6 + 56 * a2 + 44);
  int v9 = (unsigned int *)(v6 + 56 * a3);
  unsigned int v10 = v9[11];
  if (v8 <= v10)
  {
    if (v10 <= v8)
    {
      unsigned int v11 = a3;
      ArchiveTreeNodePath(a1, a2, (uint64_t)v17, 0x400uLL);
      ArchiveTreeNodePath(a1, v4, (uint64_t)v16, 0x400uLL);
      if (!v8
        || (uint64_t result = archiveTreeCompareNodesLex(a1, *(unsigned int *)(*(void *)(a1 + 8) + 56 * v7), *(unsigned int *)(*(void *)(a1 + 8) + 56 * v11)), !result))
      {
        uint64_t v12 = *(void *)(a1 + 8);
        unsigned int v13 = *(_DWORD *)(v12 + 56 * v7 + 12);
        LODWORD(v12) = *(_DWORD *)(v12 + 56 * v11 + 12);
        BOOL v14 = v13 >= v12;
        BOOL v15 = v13 > v12;
        if (v14) {
          return v15;
        }
        else {
          return 0xFFFFFFFFLL;
        }
      }
    }
    else
    {
      LODWORD(result) = archiveTreeCompareNodesLex(a1, a2, *v9);
      if (result) {
        return result;
      }
      else {
        return 0xFFFFFFFFLL;
      }
    }
  }
  else
  {
    LODWORD(result) = archiveTreeCompareNodesLex(a1, *(unsigned int *)(v6 + 56 * a2), a3);
    if (result <= 1) {
      return 1;
    }
    else {
      return result;
    }
  }
  return result;
}

uint64_t expandDirRangeThreadProc()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v60 = *MEMORY[0x263EF8340];
  bzero(__s, 0x400uLL);
  *(_DWORD *)(v0 + 72) = 1;
  unsigned int v1 = *(_DWORD *)(v0 + 40);
  if (v1 >= *(_DWORD *)(v0 + 44)) {
    return v0;
  }
LABEL_2:
  if (ArchiveTreeNodePath(*(void *)(v0 + 32), v1, (uint64_t)__s, 0x400uLL) < 0)
  {
    uint64_t v38 = "path too long";
    __int16 v39 = 960;
    goto LABEL_68;
  }
  unsigned int v4 = *(unsigned int **)(v0 + 56);
  int v52 = *(_DWORD *)(v0 + 48);
  size_t v5 = *(const char **)(v0 + 8);
  uint64_t v6 = *(int (**)(uint64_t, char *, uint64_t))(v0 + 16);
  uint64_t v53 = *(void *)(v0 + 24);
  size_t v7 = strlen(v5);
  size_t v8 = strlen(__s);
  __memcpy_chk();
  v59[v7] = 0;
  if (v8)
  {
    if (v7 + v8 - 2047 <= 0xFFFFFFFFFFFFF7FFLL)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", 812, 34, 0, "path too long: %s/%s", v9, v10, (char)v5);
      goto LABEL_67;
    }
    v59[v7] = 47;
    memcpy(&v59[v7 + 1], __s, v8);
    size_t v11 = v8 + v7 + 1;
    v59[v11] = 0;
  }
  else
  {
    size_t v11 = v7;
  }
  memset(&v56, 0, sizeof(v56));
  if (lstat(v59, &v56) < 0)
  {
    int v40 = *__error();
    unsigned int v43 = "lstat %s";
    __int16 v44 = 822;
    goto LABEL_66;
  }
  if (statIsDataless(v56.st_flags))
  {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", 828, 34, "skip dataless dir: %s", v12, v13, v14, (char)v59);
    goto LABEL_57;
  }
  BOOL v15 = opendir(v59);
  if (v15)
  {
    char v16 = v15;
    long long v50 = v4;
    size_t v17 = v11 + 1;
    uint64_t v18 = &v59[v11];
    memset(&v58, 0, 512);
    uint64_t v19 = &v59[v11 + 1];
    uint64_t v51 = &v59[v7 + 1];
    int v20 = 1;
    long long v55 = 0;
    while (1)
    {
      if (!v20) {
        goto LABEL_64;
      }
      if (readdir_r(v16, &v58, &v55))
      {
        if (*__error() == 11)
        {
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", 845, 34, "readdir on dataless directory: %s", v35, v36, v37, (char)v59);
LABEL_55:
          closedir(v16);
          goto LABEL_57;
        }
        int v47 = *__error();
        uint64_t v45 = "readdir_r";
        __int16 v46 = 846;
        goto LABEL_63;
      }
      if (!v55) {
        goto LABEL_55;
      }
      size_t d_namlen = v58.d_namlen;
      if ((v58.d_namlen != 1 || v58.d_name[0] != 46)
        && (v58.d_namlen != 2 || v58.d_name[0] != 46 || v58.d_name[1] != 46))
      {
        if (v17 + v58.d_namlen >= 0x800)
        {
          uint64_t v45 = "path too long";
          __int16 v46 = 865;
          int v47 = 0;
LABEL_63:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", v46, 34, v47, v45, v21, v22, v49);
LABEL_64:
          closedir(v16);
          goto LABEL_67;
        }
        *uint64_t v18 = 47;
        memcpy(v19, v58.d_name, d_namlen);
        v59[v17 + d_namlen] = 0;
        memset(&v54, 0, sizeof(v54));
        if (lstat(v59, &v54))
        {
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", 872, 34, "stat failed: %s", v24, v25, v26, (char)v59);
        }
        else
        {
          if ((v54.st_mode & 0xF000) == 0x4000 && v54.st_dev != v56.st_dev)
          {
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", 877, 34, "skip mounted dir: %s", v24, v25, v26, (char)v59);
          }
          else
          {
            if (!statIsDataless(v54.st_flags))
            {
              uint64_t v30 = 68;
              uint64_t AAEntryType = 70;
              switch(v58.d_type)
              {
                case 0u:
                  uint64_t AAEntryType = getAAEntryType(v54.st_mode);
                  if (AAEntryType) {
                    goto LABEL_41;
                  }
                  goto LABEL_29;
                case 1u:
                  uint64_t AAEntryType = 80;
                  goto LABEL_41;
                case 2u:
                  uint64_t AAEntryType = 67;
                  goto LABEL_41;
                case 4u:
                  goto LABEL_45;
                case 6u:
                  uint64_t AAEntryType = 66;
                  goto LABEL_41;
                case 8u:
                  goto LABEL_41;
                case 0xAu:
                  uint64_t AAEntryType = 76;
                  goto LABEL_41;
                case 0xCu:
                  uint64_t AAEntryType = 83;
LABEL_41:
                  if (v52)
                  {
                    uint64_t v30 = AAEntryType;
                  }
                  else
                  {
                    uint64_t v30 = AAEntryType;
                    if (AAEntryType != 68) {
                      goto LABEL_33;
                    }
                  }
LABEL_45:
                  if (v52 == 1 && v30 == 68 || v6 && v6(v53, v51, v30) < 1) {
                    goto LABEL_33;
                  }
                  if (archiveTreeAppend(v50, v1, v58.d_name, d_namlen, -1, -1, v30))
                  {
                    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", 920, 34, 0, "ArchiveTree append", v33, v34, v49);
LABEL_51:
                    int v20 = 0;
                    int v32 = 11;
                  }
                  else
                  {
                    int v32 = 0;
                    *uint64_t v18 = 0;
                    int v20 = 1;
                  }
                  break;
                default:
LABEL_29:
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", 910, 34, 0, "invalid entry type: %s", v28, v29, (char)v59);
                  goto LABEL_51;
              }
              goto LABEL_34;
            }
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", 888, 34, "skip dataless: %s", v27, v28, v29, (char)v59);
          }
          if (v6) {
            v6(v53, v51, 0);
          }
        }
      }
LABEL_33:
      int v20 = 1;
      int v32 = 10;
LABEL_34:
      if (v32 == 11)
      {
        closedir(v16);
        if (!v20) {
          goto LABEL_67;
        }
LABEL_57:
        if (++v1 >= *(_DWORD *)(v0 + 44)) {
          return v0;
        }
        goto LABEL_2;
      }
    }
  }
  int v40 = *__error();
  unsigned int v43 = "opendir %s";
  __int16 v44 = 835;
LABEL_66:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", v44, 34, v40, v43, v41, v42, (char)v59);
LABEL_67:
  uint64_t v38 = "expand directory";
  __int16 v39 = 961;
LABEL_68:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDirRangeThreadProc", v39, 34, 0, v38, v2, v3, v49);
  *(_DWORD *)(v0 + 72) = 0;
  return v0;
}

uint64_t archiveTreeUpdateNodeDepth(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)a1 <= a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = v3 + 56 * a2;
  int v6 = *(_DWORD *)(v4 + 44);
  size_t v5 = (_DWORD *)(v4 + 44);
  if (v6 != -1) {
    return 0;
  }
  unsigned int v9 = *(_DWORD *)(v3 + 56 * a2);
  if (v9 != -1)
  {
    if ((archiveTreeUpdateNodeDepth(a1, *(unsigned int *)(v3 + 56 * a2)) & 0x80000000) == 0)
    {
      uint64_t result = 0;
      *(_DWORD *)(*(void *)(a1 + 8) + 56 * a2 + 44) = *(_DWORD *)(*(void *)(a1 + 8) + 56 * v9 + 44) + 1;
      return result;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeUpdateNodeDepth", 198, 34, 0, "update parent depth", v10, v11, v12);
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 16) + 8) + 16 * *(unsigned int *)(v3 + 56 * a2 + 12) + 8))
  {
    uint64_t result = 0;
    *size_t v5 = 1;
  }
  else
  {
    uint64_t result = 0;
    *size_t v5 = 0;
  }
  return result;
}

uint64_t archiveTreeCompareNodesStrRec(uint64_t a1, unsigned int a2, unsigned int a3, char a4, char a5)
{
  uint64_t v7 = a3;
  uint64_t v8 = a2;
  uint64_t v9 = *(void *)(a1 + 8);
  unsigned int v10 = *(_DWORD *)(v9 + 56 * a2 + 44);
  unsigned int v11 = *(_DWORD *)(v9 + 56 * a3 + 44);
  if (v10 <= v11)
  {
    char v12 = a4;
    if (v11 > v10)
    {
      do
      {
        LODWORD(v7) = *(_DWORD *)(v9 + 56 * v7);
        --v11;
      }
      while (v11 > v10);
      a5 = 47;
    }
    unsigned int v11 = *(_DWORD *)(v9 + 56 * a2 + 44);
  }
  else
  {
    do
    {
      LODWORD(v8) = *(_DWORD *)(v9 + 56 * v8);
      --v10;
    }
    while (v10 > v11);
    char v12 = 47;
  }
  if (v11 < 2
    || (uint64_t result = archiveTreeCompareNodesStrRec(a1, *(unsigned int *)(v9 + 56 * v8), *(unsigned int *)(v9 + 56 * v7), 47, 47), !result))
  {
    uint64_t v14 = *(unsigned int *)(v9 + 56 * v8 + 12);
    uint64_t v15 = *(void *)(a1 + 16);
    uint64_t v16 = *(void *)(v15 + 8);
    size_t v17 = *(unsigned int *)(v16 + 16 * v14 + 8);
    uint64_t v18 = *(unsigned int *)(v9 + 56 * v7 + 12);
    uint64_t v19 = *(unsigned int *)(v16 + 16 * v18 + 8);
    if (v17 == v19)
    {
      if (v14 < v18) {
        unsigned int v20 = -1;
      }
      else {
        unsigned int v20 = 1;
      }
      if (v14 == v18) {
        return v12 - a5;
      }
      else {
        return v20;
      }
    }
    else
    {
      uint64_t v21 = *(void *)(v15 + 32);
      uint64_t v22 = (unsigned char *)(v21 + *(void *)(v16 + 16 * v14));
      int v23 = (unsigned char *)(v21 + *(void *)(v16 + 16 * v18));
      if (v17 >= v19)
      {
        char v12 = v22[v19];
        size_t v17 = *(unsigned int *)(v16 + 16 * v18 + 8);
      }
      else
      {
        a5 = v23[v17];
      }
      LODWORD(result) = memcmp(v22, v23, v17);
      if (result) {
        return result;
      }
      else {
        return (v12 - a5);
      }
    }
  }
  return result;
}

uint64_t aaByteStreamSimulate(void *a1)
{
  unsigned int v1 = (uint64_t (*)(void))a1[11];
  if (v1) {
    return v1(*a1);
  }
  else {
    return -1;
  }
}

ssize_t AAByteStreamWrite(AAByteStream s, const void *buf, size_t nbyte)
{
  uint64_t v3 = (uint64_t (*)(void, const void *, size_t))*((void *)s + 3);
  if (v3) {
    return v3(*(void *)s, buf, nbyte);
  }
  else {
    return -1;
  }
}

uint64_t aaFileStreamGetFD(unsigned int **a1)
{
  unsigned int v1 = (uint64_t (*)(int *))a1[1];
  if (v1 == aaFileStreamClose || (char *)v1 == (char *)aaTempFileStreamClose) {
    return **a1;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t aaFileStreamClose(int *a1)
{
  if (a1)
  {
    if (a1[1])
    {
      int v2 = *a1;
      if ((v2 & 0x80000000) == 0) {
        close(v2);
      }
    }
    free(a1);
  }
  return 0;
}

uint64_t aaTempFileStreamClose(char *a1)
{
  if (a1)
  {
    int v2 = *(_DWORD *)a1;
    if ((v2 & 0x80000000) == 0)
    {
      close(v2);
      unlink(a1 + 12);
    }
    free(a1);
  }
  return 0;
}

ssize_t AAByteStreamPWrite(AAByteStream s, const void *buf, size_t nbyte, off_t offset)
{
  uint64_t v4 = (uint64_t (*)(void, const void *, size_t, off_t))*((void *)s + 5);
  if (v4) {
    return v4(*(void *)s, buf, nbyte, offset);
  }
  else {
    return -1;
  }
}

ssize_t AAByteStreamRead(AAByteStream s, void *buf, size_t nbyte)
{
  uint64_t v3 = (uint64_t (*)(void, void *, size_t))*((void *)s + 2);
  if (v3) {
    return v3(*(void *)s, buf, nbyte);
  }
  else {
    return -1;
  }
}

ssize_t AAByteStreamPRead(AAByteStream s, void *buf, size_t nbyte, off_t offset)
{
  uint64_t v4 = (uint64_t (*)(void, void *, size_t, off_t))*((void *)s + 4);
  if (v4) {
    return v4(*(void *)s, buf, nbyte, offset);
  }
  else {
    return -1;
  }
}

off_t AAByteStreamSeek(AAByteStream s, off_t offset, int whence)
{
  uint64_t v3 = (uint64_t (*)(void, off_t, void))*((void *)s + 6);
  if (v3) {
    return v3(*(void *)s, offset, *(void *)&whence);
  }
  else {
    return -1;
  }
}

void AAByteStreamCancel(AAByteStream s)
{
  unsigned int v1 = (void (*)(void))*((void *)s + 7);
  if (v1) {
    v1(*(void *)s);
  }
}

int AAByteStreamClose(AAByteStream s)
{
  if (!s) {
    return 0;
  }
  if (*(void *)s) {
    int v2 = (*((uint64_t (**)(void))s + 1))();
  }
  else {
    int v2 = 0;
  }
  free(s);
  return v2;
}

uint64_t AAByteStreamFlush(void *a1)
{
  unsigned int v1 = (uint64_t (*)(void))a1[9];
  if (v1) {
    return v1(*a1);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t AAByteStreamTruncate(void *a1)
{
  unsigned int v1 = (uint64_t (*)(void))a1[8];
  if (v1) {
    return v1(*a1);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

AAByteStream AAFileStreamOpenWithFD(int fd, int automatic_close)
{
  uint64_t v4 = calloc(1uLL, 0x68uLL);
  size_t v5 = malloc(0xCuLL);
  int v6 = v5;
  if (v5 && v4)
  {
    *size_t v5 = fd;
    v5[1] = automatic_close;
    v5[2] = 0;
    *uint64_t v4 = v5;
    v4[1] = aaFileStreamClose;
    v4[2] = aaFileStreamRead;
    void v4[3] = aaFileStreamWrite;
    v4[4] = aaFileStreamPRead;
    v4[5] = aaFileStreamPWrite;
    v4[7] = aaFileStreamAbort;
    v4[6] = aaFileStreamSeek;
    v4[8] = aaFileStreamTruncate;
    v4[9] = aaFileStreamFlush;
  }
  else
  {
    uint64_t v7 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"AAFileStreamOpenWithFD", 402, 17, *v7, "malloc", v8, v9, v11);
    free(v4);
    free(v6);
    return 0;
  }
  return (AAByteStream)v4;
}

uint64_t aaFileStreamRead(int *a1, void *a2, size_t a3)
{
  if (a1[2]) {
    return -1;
  }
  ssize_t v3 = read(*a1, a2, a3);
  if (v3 < 0) {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"aaFileStreamRead", 92, 17, "aaFileStreamRead err=%zd buf=%p n=%zu", v4, v5, v6, v3);
  }
  return v3;
}

uint64_t aaFileStreamWrite(int *a1, const void *a2, size_t a3)
{
  if (a1[2]) {
    return -1;
  }
  ssize_t v3 = write(*a1, a2, a3);
  if (v3 < 0) {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"aaFileStreamWrite", 104, 17, "aaFileStreamWrite err=%zd buf=%p n=%zu", v4, v5, v6, v3);
  }
  return v3;
}

uint64_t aaFileStreamPRead(int *a1, void *a2, size_t a3, off_t a4)
{
  if (a1[2]) {
    return -1;
  }
  ssize_t v4 = pread(*a1, a2, a3, a4);
  if (v4 < 0) {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"aaFileStreamPRead", 116, 17, "aaFileStreamPRead err=%zd buf=%p n=%zu off=%llu", v5, v6, v7, v4);
  }
  return v4;
}

uint64_t aaFileStreamPWrite(int *a1, const void *a2, size_t a3, off_t a4)
{
  if (a1[2]) {
    return -1;
  }
  ssize_t v4 = pwrite(*a1, a2, a3, a4);
  if (v4 < 0) {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"aaFileStreamPWrite", 128, 17, "aaFileStreamPWrite err=%zd buf=%p n=%zu off=%llu", v5, v6, v7, v4);
  }
  return v4;
}

uint64_t aaFileStreamAbort(uint64_t result)
{
  *(_DWORD *)(result + 8) = 1;
  return result;
}

off_t aaFileStreamSeek(int *a1, off_t a2, int a3)
{
  if (a1[2]) {
    return -1;
  }
  else {
    return lseek(*a1, a2, a3);
  }
}

uint64_t aaFileStreamTruncate(int *a1, off_t a2)
{
  if (a1[2]) {
    return 0xFFFFFFFFLL;
  }
  else {
    return ftruncate(*a1, a2);
  }
}

uint64_t aaFileStreamFlush(int *a1)
{
  if (!a1[2])
  {
    uint64_t result = fsync(*a1);
    if (!result) {
      return result;
    }
    int v2 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"aaFileStreamFlush", 151, 17, *v2, "fsync", v3, v4, vars0);
  }
  return 0xFFFFFFFFLL;
}

AAByteStream AAFileStreamOpenWithPath(const char *path, int open_flags, mode_t open_mode)
{
  char v3 = (char)path;
  int v4 = open(path, open_flags, open_mode);
  if (v4 < 0)
  {
    uint64_t v7 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"AAFileStreamOpenWithPath", 428, 17, *v7, "open: %s", v8, v9, v3);
  }
  else
  {
    int v5 = v4;
    AAByteStream result = AAFileStreamOpenWithFD(v4, 1);
    if (result) {
      return result;
    }
    close(v5);
  }
  return 0;
}

void *AATempFileStreamOpenWithDirectory(const char *a1)
{
  int v2 = calloc(1uLL, 0x68uLL);
  char v3 = (char *)malloc(0x40CuLL);
  int v4 = v3;
  if (!v2 || !v3)
  {
    int v9 = *__error();
    uint64_t v7 = "malloc";
    __int16 v8 = 447;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"AATempFileStreamOpenWithDirectory", v8, 17, v9, v7, v5, v6, v12);
    free(v2);
    free(v4);
    return 0;
  }
  memset_s(v3, 0x40CuLL, 0, 0x40CuLL);
  if (a1)
  {
    memset(&v13, 0, sizeof(v13));
    if (!realpath_DARWIN_EXTSN(a1, v4 + 12) || stat(v4 + 12, &v13) || (v13.st_mode & 0xF000) != 0x4000)
    {
      char v12 = (char)a1;
      uint64_t v7 = "invalid temp_dir: %s";
      __int16 v8 = 457;
LABEL_15:
      int v9 = 0;
      goto LABEL_16;
    }
  }
  else if ((getTempDir(v4 + 12, 0x400uLL) & 0x80000000) != 0)
  {
    uint64_t v7 = "get temp dir";
    __int16 v8 = 462;
    goto LABEL_15;
  }
  if ((unint64_t)__strlcat_chk() >= 0x400)
  {
    char v12 = (_BYTE)v4 + 12;
    uint64_t v7 = "Invalid temp dir path: %s";
    __int16 v8 = 464;
    goto LABEL_15;
  }
  int v10 = mkostemp(v4 + 12, 0x1000000);
  *(_DWORD *)int v4 = v10;
  if (v10 < 0)
  {
    int v9 = *__error();
    uint64_t v7 = "mkostemp";
    __int16 v8 = 466;
    goto LABEL_16;
  }
  *int v2 = v4;
  v2[1] = aaTempFileStreamClose;
  v2[2] = aaFileStreamRead;
  v2[3] = aaFileStreamWrite;
  void v2[4] = aaFileStreamPRead;
  v2[5] = aaFileStreamPWrite;
  v2[7] = aaFileStreamAbort;
  v2[6] = aaFileStreamSeek;
  v2[8] = aaFileStreamTruncate;
  v2[9] = aaFileStreamFlush;
  return v2;
}

AAByteStream AADecompressionInputStreamOpen(AAByteStream compressed_stream, AAFlagSet flags, int n_threads)
{
  return (AAByteStream)aaSequentialDecompressionIStreamOpen((uint64_t)compressed_stream, n_threads);
}

void AACustomByteStreamSetData(AAByteStream s, void *data)
{
  *(void *)s = data;
}

void AACustomByteStreamSetCloseProc(AAByteStream s, AAByteStreamCloseProc proc)
{
  *((void *)s + 1) = proc;
}

void AACustomByteStreamSetReadProc(AAByteStream s, AAByteStreamReadProc proc)
{
  *((void *)s + 2) = proc;
}

void AACustomByteStreamSetPReadProc(AAByteStream s, AAByteStreamPReadProc proc)
{
  *((void *)s + 4) = proc;
}

void AACustomByteStreamSetWriteProc(AAByteStream s, AAByteStreamWriteProc proc)
{
  *((void *)s + 3) = proc;
}

void AACustomByteStreamSetPWriteProc(AAByteStream s, AAByteStreamPWriteProc proc)
{
  *((void *)s + 5) = proc;
}

void AACustomByteStreamSetSeekProc(AAByteStream s, AAByteStreamSeekProc proc)
{
  *((void *)s + 6) = proc;
}

void AACustomByteStreamSetCancelProc(AAByteStream s, AAByteStreamCancelProc proc)
{
  *((void *)s + 7) = proc;
}

size_t PCompressLZBITMAPEncode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_encode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZBITMAP);
  if (!result) {
    return -1;
  }
  return result;
}

size_t PCompressLZBITMAPDecode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_decode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZBITMAP);
  if (!result) {
    return -1;
  }
  return result;
}

size_t IZeroStreamRead(int a1, void *a2, size_t a3)
{
  return a3;
}

uint64_t ONullStreamWrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

void *OSHA1StreamCreate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = malloc(0x80uLL);
  uint64_t v7 = v6;
  if (v6)
  {
    *((_OWORD *)v6 + 6) = 0u;
    *((_OWORD *)v6 + 7) = 0u;
    *((_OWORD *)v6 + 4) = 0u;
    *((_OWORD *)v6 + 5) = 0u;
    *((_OWORD *)v6 + 2) = 0u;
    *((_OWORD *)v6 + 3) = 0u;
    *(_OWORD *)uint64_t v6 = 0u;
    *((_OWORD *)v6 + 1) = 0u;
    CC_SHA1_Deprecated_Init((CC_SHA1_CTX *)v6);
    v7[13] = a1;
    v7[14] = a2;
    v7[15] = a3;
  }
  else
  {
    __int16 v8 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OSHA1StreamCreate", 76, 29, *v8, "malloc", v9, v10, v12);
  }
  return v7;
}

void OSHA1StreamDestroy(CC_SHA1_CTX *c, unsigned __int8 *md)
{
  if (c)
  {
    CC_SHA1_Deprecated_Final(md, c);
    free(c);
  }
}

uint64_t OSHA1StreamWrite(CC_SHA1_CTX *c, const void *a2, uint64_t a3)
{
  if (!c || c[1].h0) {
    return -1;
  }
  uint64_t v4 = a3;
  CC_SHA1_Deprecated_Update(c, a2, a3);
  uint64_t v7 = *(uint64_t (**)(uint64_t, const void *, uint64_t))&c[1].h2;
  if (!v7) {
    return v4;
  }
  uint64_t v8 = *(void *)&c[1].Nh;

  return v7(v8, a2, v4);
}

uint64_t OSHA1StreamAbort(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    int v2 = *(uint64_t (**)(void))(result + 112);
    if (v2) {
      size_t result = v2(*(void *)(result + 120));
    }
    *(_DWORD *)(v1 + 96) = 1;
  }
  return result;
}

uint64_t *IMagicStreamCreate(uint64_t (*a1)(uint64_t, uint64_t *, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  size_t v8 = a4 + 48;
  uint64_t v9 = (uint64_t *)malloc(a4 + 48);
  uint64_t v10 = v9;
  if (v9)
  {
    bzero(v9, v8);
    uint64_t v11 = a1(a3, v10 + 6, a4);
    if (v11 < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IMagicStreamCreate", 138, 29, 0, "reading magic", v12, v13, v18);
      free(v10);
      return 0;
    }
    else
    {
      *uint64_t v10 = v11;
      v10[1] = v11;
      v10[3] = (uint64_t)a1;
      v10[4] = a2;
      v10[5] = a3;
    }
  }
  else
  {
    uint64_t v14 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IMagicStreamCreate", 133, 29, *v14, "malloc", v15, v16, v18);
  }
  return v10;
}

uint64_t IMagicStreamGetMagic(uint64_t a1)
{
  return a1 + 48;
}

uint64_t IMagicStreamGetMagicSize(uint64_t a1)
{
  return *(void *)a1;
}

size_t IMagicStreamRead(uint64_t a1, char *__dst, size_t a3)
{
  if (!a1 || *(_DWORD *)(a1 + 16)) {
    return -1;
  }
  size_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    if (v8 >= a3) {
      size_t v4 = a3;
    }
    else {
      size_t v4 = *(void *)(a1 + 8);
    }
    memcpy(__dst, (const void *)(a1 + *(void *)a1 - v8 + 48), v4);
    *(void *)(a1 + 8) -= v4;
    if (v8 < a3)
    {
      uint64_t v9 = (*(uint64_t (**)(void, char *, size_t))(a1 + 24))(*(void *)(a1 + 40), &__dst[v4], a3 - v4);
      if (v9 < 0) {
        return -1;
      }
      else {
        v4 += v9;
      }
    }
    return v4;
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t))(a1 + 24);
  uint64_t v11 = *(void *)(a1 + 40);

  return v10(v11);
}

uint64_t IMagicStreamAbort(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    int v2 = *(uint64_t (**)(void))(result + 32);
    if (v2) {
      size_t result = v2(*(void *)(result + 40));
    }
    *(_DWORD *)(v1 + 16) = 1;
  }
  return result;
}

uint64_t IFileStreamCreateWithFilename(const char *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6 = (char *)malloc(0x70uLL);
  uint64_t v7 = (uint64_t)v6;
  if (v6)
  {
    *(_OWORD *)(v6 + 8) = 0u;
    *(_OWORD *)(v6 + 24) = 0u;
    *((void *)v6 + 13) = 0;
    *(_OWORD *)(v6 + 88) = 0u;
    *(_OWORD *)(v6 + 72) = 0u;
    *(_OWORD *)(v6 + 56) = 0u;
    *(_OWORD *)(v6 + 40) = 0u;
    size_t v8 = (pthread_mutex_t *)(v6 + 40);
    *(void *)uint64_t v7 = 0x1FFFFFFFFLL;
    uint64_t v9 = a2 + a3;
    if (__CFADD__(a2, a3)) {
      uint64_t v9 = -1;
    }
    *(void *)(v7 + 16) = a2;
    *(void *)(v7 + 24) = v9;
    if (pthread_mutex_init(v8, 0))
    {
      uint64_t v12 = "pthread_mutex_init";
      __int16 v13 = 293;
    }
    else
    {
      int v16 = open(a1, 0);
      *(_DWORD *)uint64_t v7 = v16;
      if (v16 < 0)
      {
        int v14 = *__error();
        char v17 = (char)a1;
        uint64_t v12 = "%s";
        __int16 v13 = 297;
        goto LABEL_9;
      }
      clampIfRegularFile(v7);
      if ((seekTo(v7, a2) & 0x80000000) == 0) {
        return v7;
      }
      uint64_t v12 = "seek error";
      __int16 v13 = 303;
    }
    int v14 = 0;
  }
  else
  {
    int v14 = *__error();
    uint64_t v12 = "malloc";
    __int16 v13 = 282;
  }
LABEL_9:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IFileStreamCreateWithFilename", v13, 29, v14, v12, v10, v11, v17);
  IFileStreamDestroy((char *)v7);
  return 0;
}

uint64_t clampIfRegularFile(uint64_t a1)
{
  memset(&v4, 0, sizeof(v4));
  uint64_t result = fstat(*(_DWORD *)a1, &v4);
  if (!result && (v4.st_mode & 0xF000) == 0x8000)
  {
    unint64_t st_size = v4.st_size;
    if (*(void *)(a1 + 16) > v4.st_size) {
      *(void *)(a1 + 16) = v4.st_size;
    }
    if (*(void *)(a1 + 24) > st_size) {
      *(void *)(a1 + 24) = st_size;
    }
  }
  return result;
}

uint64_t seekTo(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 32) == a2) {
    return 0;
  }
  off_t v4 = lseek(*(_DWORD *)a1, a2, 0);
  if ((v4 & 0x8000000000000000) == 0)
  {
    unint64_t v7 = v4;
    *(void *)(a1 + 32) = v4;
LABEL_4:
    if (v7 == a2) {
      return 0;
    }
    uint64_t v9 = "pos not reached";
    __int16 v10 = 261;
    goto LABEL_10;
  }
  if (*__error() != 32)
  {
    int v11 = *__error();
    uint64_t v9 = "lseek failed";
    __int16 v10 = 258;
    goto LABEL_12;
  }
  unint64_t v7 = *(void *)(a1 + 32);
  if (v7 <= a2)
  {
    uint64_t v12 = valloc(0x4000uLL);
    if (!v12)
    {
      int v11 = *__error();
      uint64_t v9 = "malloc";
      __int16 v10 = 244;
      goto LABEL_12;
    }
    for (unint64_t i = v12; v7 < a2; *(void *)(a1 + 32) = v7)
    {
      if (v7 + 0x4000 <= a2) {
        size_t v14 = 0x4000;
      }
      else {
        size_t v14 = a2 - v7;
      }
      ssize_t v15 = read(*(_DWORD *)a1, i, v14);
      unint64_t v7 = *(void *)(a1 + 32);
      if (v15 < 1) {
        break;
      }
      v7 += v15;
    }
    free(i);
    goto LABEL_4;
  }
  uint64_t v9 = "lseek failed and pos < s->pos";
  __int16 v10 = 240;
LABEL_10:
  int v11 = 0;
LABEL_12:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"seekTo", v10, 29, v11, v9, v5, v6, v16);
  return 0xFFFFFFFFLL;
}

void IFileStreamDestroy(char *a1)
{
  if (a1)
  {
    if (*((_DWORD *)a1 + 1))
    {
      int v2 = *(_DWORD *)a1;
      if ((v2 & 0x80000000) == 0) {
        close(v2);
      }
    }
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 40));
    free(a1);
  }
}

unint64_t IFileStreamRead(uint64_t a1, char *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 8)) {
    return -1;
  }
  if (!a3) {
    return 0;
  }
  unint64_t v11 = *(void *)(a1 + 32);
  if (v11 < *(void *)(a1 + 16))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IFileStreamRead", 358, 29, 0, "pos out of range", a7, a8, v21);
    return -1;
  }
  if (~v11 < a3) {
    size_t v12 = ~v11;
  }
  else {
    size_t v12 = a3;
  }
  unint64_t v13 = a3 + v11;
  if (__CFADD__(a3, v11)) {
    unint64_t v13 = -1;
  }
  unint64_t v14 = *(void *)(a1 + 24);
  if (v13 <= v14) {
    size_t v15 = v12;
  }
  else {
    size_t v15 = v14 - v11;
  }
  if (v15)
  {
    unint64_t v8 = 0;
    while (1)
    {
      ssize_t v17 = read(*(_DWORD *)a1, a2, v15);
      if (v17 < 0) {
        break;
      }
      if (v17)
      {
        a2 += v17;
        v8 += v17;
        v15 -= v17;
        if (v15) {
          continue;
        }
      }
      unint64_t v11 = *(void *)(a1 + 32);
      goto LABEL_24;
    }
    char v18 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IFileStreamRead", 374, 29, *v18, "read", v19, v20, v21);
    *(void *)(a1 + 32) += v8;
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 104), v8);
    return -1;
  }
  unint64_t v8 = 0;
LABEL_24:
  *(void *)(a1 + 32) = v11 + v8;
  atomic_fetch_add((atomic_ullong *volatile)(a1 + 104), v8);
  return v8;
}

uint64_t IFileStreamSetPos(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 8)) {
    return -1;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  BOOL v10 = __CFADD__(v9, a2);
  unint64_t v11 = v9 + a2;
  if (v10 || v11 > *(void *)(a1 + 24))
  {
    size_t v12 = "invalid pos";
    __int16 v13 = 435;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IFileStreamSetPos", v13, 29, 0, v12, a7, a8, v15);
    return -1;
  }
  if ((seekTo(a1, v11) & 0x80000000) != 0)
  {
    size_t v12 = "changing pos";
    __int16 v13 = 436;
    goto LABEL_5;
  }
  return *(void *)(a1 + 32) - *(void *)(a1 + 16);
}

uint64_t IFileStreamGetPos(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 8)) {
    return -1;
  }
  else {
    return *(void *)(a1 + 32) - *(void *)(a1 + 16);
  }
}

int *OFileStreamCreateWithFilename(const char *a1, uint64_t a2)
{
  off_t v4 = (int *)malloc(0x20uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    *((void *)v4 + 2) = a2;
    *((void *)v4 + 3) = 0;
    v4[1] = 1;
    *((void *)v4 + 1) = 0;
    int v6 = open(a1, 1537, 420);
    *uint64_t v5 = v6;
    if (v6 < 0)
    {
      unint64_t v7 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OFileStreamCreateWithFilename", 490, 29, *v7, "%s", v8, v9, (char)a1);
      free(v5);
      return 0;
    }
  }
  else
  {
    BOOL v10 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OFileStreamCreateWithFilename", 484, 29, *v10, "malloc", v11, v12, v14);
  }
  return v5;
}

void *OFileStreamCreateWithFD(int a1, uint64_t a2)
{
  off_t v4 = malloc(0x20uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    v4[2] = a2;
    void v4[3] = 0;
    *(_DWORD *)off_t v4 = a1;
    *((_DWORD *)v4 + 1) = 0;
    v4[1] = 0;
  }
  else
  {
    int v6 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OFileStreamCreateWithFD", 497, 29, *v6, "malloc", v7, v8, v10);
  }
  return v5;
}

void OFileStreamDestroy(int *a1)
{
  if (a1)
  {
    if (a1[1])
    {
      int v2 = *a1;
      if ((v2 & 0x80000000) == 0) {
        close(v2);
      }
    }
    free(a1);
  }
}

uint64_t OFileStreamWrite(uint64_t a1, char *__buf, unint64_t a3)
{
  if (*(_DWORD *)(a1 + 8)) {
    return -1;
  }
  if (*(void *)(a1 + 16) >= a3) {
    unint64_t v5 = a3;
  }
  else {
    unint64_t v5 = *(void *)(a1 + 16);
  }
  if (v5)
  {
    uint64_t v3 = 0;
    while (1)
    {
      size_t v7 = v5 >= 0x7FFFFFFF ? 0x7FFFFFFFLL : v5;
      ssize_t v8 = write(*(_DWORD *)a1, __buf, v7);
      if (v8 < 0) {
        break;
      }
      if (v8)
      {
        uint64_t v9 = *(void *)(a1 + 16);
        if (v9 != -1) {
          *(void *)(a1 + 16) = v9 - v8;
        }
        __buf += v8;
        v3 += v8;
        v5 -= v8;
        if (v5) {
          continue;
        }
      }
      goto LABEL_18;
    }
    uint64_t v11 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OFileStreamWrite", 538, 29, *v11, "write", v12, v13, v14);
    return -1;
  }
  uint64_t v3 = 0;
LABEL_18:
  *(void *)(a1 + 24) += v3;
  return v3;
}

off_t OFileStreamSetPos(int *a1, off_t a2)
{
  if (a1[2]) {
    return -1;
  }
  off_t result = lseek(*a1, a2, 0);
  if (result < 0)
  {
    uint64_t v3 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OFileStreamSetPos", 558, 29, *v3, "lseek", v4, v5, vars0);
    return -1;
  }
  return result;
}

off_t OFileStreamGetPos(int *a1)
{
  if (a1[2]) {
    return -1;
  }
  off_t result = lseek(*a1, 0, 1);
  if (result < 0)
  {
    int v2 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OFileStreamGetPos", 568, 29, *v2, "lseek", v3, v4, vars0);
    return -1;
  }
  return result;
}

uint64_t OFileStreamAbort(uint64_t result)
{
  if (result) {
    *(_DWORD *)(result + 8) = 1;
  }
  return result;
}

int *OArchiveFileStreamCreate(const char *a1, unint64_t a2, unsigned int a3, int a4, int a5)
{
  char v10 = (int *)malloc(0x60uLL);
  uint64_t v11 = v10;
  if (v10)
  {
    *((_OWORD *)v10 + 4) = 0u;
    *((_OWORD *)v10 + 5) = 0u;
    *((_OWORD *)v10 + 2) = 0u;
    *((_OWORD *)v10 + 3) = 0u;
    *(_OWORD *)char v10 = 0u;
    *((_OWORD *)v10 + 1) = 0u;
    if ((a3 & 0x100) == 0) {
      unlink(a1);
    }
    v11[1] = (a3 >> 4) & 1;
    *((void *)v11 + 2) = a2;
    if (a3) {
      int v12 = 4;
    }
    else {
      int v12 = a4;
    }
    if (v12 < 1)
    {
      int v13 = open(a1, 1537, 420);
      *uint64_t v11 = v13;
      if (v13 < 0)
      {
        __int16 v14 = 648;
        goto LABEL_31;
      }
    }
    else
    {
      int v13 = open_dprotected_np(a1, 1537, v12, 0, 420);
      *uint64_t v11 = v13;
      if (v13 < 0)
      {
        __int16 v14 = 640;
LABEL_31:
        uint64_t v37 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", v14, 29, *v37, "%s", v38, v39, (char)a1);
        ParallelCompressionAFSCStreamClose(0, v40, v41, v42, v43, v44, v45, v46);
        goto LABEL_32;
      }
    }
    if ((a3 & 8) != 0 && fcntl(v13, 48, 1)) {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", 656, 29, "Warning: F_NOCACHE failed: %s\n", v18, v19, v20, (char)a1);
    }
    if ((a3 & 2) != 0 && fcntl(v13, 68, 1) == -1)
    {
      char v21 = __error();
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", 665, 29, "Warning: F_SETSTATICCONTENT failed with error %d: %s\n", v22, v23, v24, *v21);
    }
    if (a2 && (a3 & 4) != 0 && a5 != -1)
    {
      if ((a3 & 0x80) != 0) {
        int v25 = 6;
      }
      else {
        int v25 = 4;
      }
      uint64_t v26 = ParallelCompressionAFSCStreamOpen(v13, a2, a5, v25);
      *((void *)v11 + 3) = v26;
      if (!v26)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", 677, 29, 0, "ParallelCompressionAFSCStreamOpen failed: %s", v27, v28, (char)a1);
        ParallelCompressionAFSCStreamClose(0, v29, v30, v31, v32, v33, v34, v35);
        close(v13);
LABEL_32:
        free(v11);
        return 0;
      }
    }
    else if ((a3 & 0x40) != 0)
    {
      uint64_t v36 = fpathconf(v13, 27);
      if (v36 >= 1)
      {
        v11[10] = 1;
        if (v36 == 4096)
        {
          v11[18] = 4096;
        }
        else
        {
          unsigned int v48 = 0x10000;
          if (v36 < 0x10000) {
            unsigned int v48 = v36;
          }
          int v49 = 1024;
          do
          {
            unsigned int v50 = v49;
            v49 *= 2;
          }
          while (v50 < v48);
          v11[18] = v50;
        }
      }
    }
  }
  else
  {
    char v15 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", 617, 29, *v15, "malloc", v16, v17, v51);
  }
  return v11;
}

uint64_t OArchiveFileStreamDestroy(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return OArchiveFileStreamDestroyEx(a1, 0, 0, 0, a5, a6, a7, a8);
}

uint64_t OArchiveFileStreamDestroyEx(unsigned int *a1, uint64_t a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  int v10 = a2;
  if (*((void *)a1 + 2)) {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamDestroyEx", 863, 29, "OArchiveFileStream didn't receive enough data before being destroyed\n", a6, a7, a8, v27);
  }
  ParallelCompressionAFSCStreamClose(*((void *)a1 + 3), a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
  if ((*a1 & 0x80000000) != 0)
  {
    uint64_t v13 = 0;
    uint64_t v19 = 0xFFFFFFFFLL;
    if (!a3) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  if (*((void *)a1 + 7))
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    uint64_t v15 = *((void *)a1 + 8);
    while (fcntl(*a1, 99, v15 + v12) != -1)
    {
      uint64_t v15 = *((void *)a1 + 8);
      v13 += *(void *)(v15 + v12 + 16);
      ++v14;
      v12 += 24;
      if (v14 >= *((void *)a1 + 7)) {
        goto LABEL_15;
      }
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamDestroyEx", 875, 29, "F_PUNCHHOLE failed", v16, v17, v18, v27);
  }
  else
  {
    uint64_t v13 = 0;
  }
LABEL_15:
  if (a1[1])
  {
    char v27 = 0;
    if (fcntl(*a1, 51) == -1)
    {
      uint64_t v20 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamDestroyEx", 883, 29, *v20, "Final FULLSYNC", v21, v22, 0);
    }
  }
  uint64_t v19 = *a1;
  if (!v10)
  {
    if (close(*a1))
    {
      uint64_t v24 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamDestroyEx", 890, 29, *v24, "close", v25, v26, v27);
    }
    uint64_t v19 = 0xFFFFFFFFLL;
    *a1 = -1;
    if (!a3) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  if (a3) {
LABEL_20:
  }
    *a3 = *((void *)a1 + 4) - v13;
LABEL_21:
  if (a4) {
    *a4 = v13;
  }
  free(*((void **)a1 + 8));
  free(a1);
  return v19;
}

uint64_t OArchiveFileStreamWrite(uint64_t a1, char *__buf, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)(a1 + 8)) {
    return -1;
  }
  unint64_t v11 = a3;
  if (a3)
  {
    uint64_t v9 = 0;
    unsigned int v48 = (unint64_t *)(a1 + 48);
    unint64_t v13 = *(void *)(a1 + 16);
    while (v13)
    {
      if (v13 >= v11) {
        unint64_t v13 = v11;
      }
      if (v13 >= 0x40000000) {
        unint64_t v14 = 0x40000000;
      }
      else {
        unint64_t v14 = v13;
      }
      uint64_t v15 = *(void *)(a1 + 24);
      if (v15)
      {
        uint64_t v16 = ParallelCompressionAFSCStreamWrite(v15, (uint64_t)__buf, v14, a4, a5, a6, a7, a8);
        ssize_t v17 = v16;
        if (v16 < 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamWrite", 955, 29, 0, "ParallelCompressionAFSCStreamWrite failed with status %d", a7, a8, v16);
          return -1;
        }
      }
      else
      {
        if ((*(_DWORD *)a1 & 0x80000000) != 0) {
          return -1;
        }
        ssize_t v17 = write(*(_DWORD *)a1, __buf, v14);
        if (v17 < 0)
        {
          int v44 = *__error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamWrite", 960, 29, v44, "write", v45, v46, v47);
          return -1;
        }
      }
      if (*(_DWORD *)(a1 + 40))
      {
        unint64_t v18 = 0;
        LODWORD(v19) = *(_DWORD *)(a1 + 72);
        int v20 = *(_DWORD *)(a1 + 76);
        do
        {
          uint64_t v21 = (v19 - v20);
          if (v18 + v21 <= v14) {
            uint64_t v22 = v21;
          }
          else {
            uint64_t v22 = (v14 - v18);
          }
          uint64_t v23 = &__buf[v18];
          uint64_t v24 = &__buf[v18 + v22];
          if (((unint64_t)&__buf[v18] & 7) != 0 && v22)
          {
            uint64_t v25 = &__buf[v18 + 1];
            while (!*v23)
            {
              if (++v23 < v24)
              {
                if ((unint64_t)(v25++ & 7)) {
                  continue;
                }
              }
              goto LABEL_29;
            }
LABEL_35:
            int v28 = 1;
          }
          else
          {
LABEL_29:
            while (v23 + 8 <= v24)
            {
              uint64_t v27 = *(void *)v23;
              v23 += 8;
              if (v27) {
                goto LABEL_35;
              }
            }
            while (v23 < v24)
            {
              if (*v23) {
                goto LABEL_35;
              }
              ++v23;
            }
            int v28 = 0;
          }
          int v29 = *(_DWORD *)(a1 + 88) | v28;
          *(_DWORD *)(a1 + 88) = v29;
          v20 += v22;
          *(_DWORD *)(a1 + 76) = v20;
          if (v20 == v19)
          {
            if (!v29)
            {
              uint64_t v30 = *(void *)(a1 + 80);
              unint64_t v31 = *(void *)(a1 + 56);
              if (v31
                && (uint64_t v32 = *(void *)(a1 + 64) + 24 * v31,
                    uint64_t v35 = *(void *)(v32 - 8),
                    uint64_t v33 = (void *)(v32 - 8),
                    uint64_t v34 = v35,
                    v35 + *(v33 - 1) == v30))
              {
                void *v33 = v34 + v19;
              }
              else
              {
                unint64_t v36 = *v48;
                if (v31 >= *v48)
                {
                  uint64_t v37 = v36 + (v36 >> 1);
                  BOOL v38 = v36 == 0;
                  uint64_t v39 = 32;
                  if (!v38) {
                    uint64_t v39 = v37;
                  }
                  *(void *)(a1 + 48) = v39;
                  uint64_t v40 = reallocf(*(void **)(a1 + 64), 24 * v39);
                  *(void *)(a1 + 64) = v40;
                  if (!v40)
                  {
                    unint64_t *v48 = 0;
                    v48[1] = 0;
                    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamWrite", 994, 29, "malloc holes failed", a6, a7, a8, v47);
                  }
                }
                unint64_t v41 = *(void *)(a1 + 56);
                if (v41 >= *(void *)(a1 + 48))
                {
                  LODWORD(v19) = *(_DWORD *)(a1 + 72);
                }
                else
                {
                  uint64_t v42 = *(void *)(a1 + 64);
                  *(void *)(a1 + 56) = v41 + 1;
                  uint64_t v43 = (void *)(v42 + 24 * v41);
                  *uint64_t v43 = 0;
                  v43[1] = 0;
                  v43[1] = v30;
                  v43[2] = 0;
                  uint64_t v19 = *(unsigned int *)(a1 + 72);
                  v43[2] = v19;
                }
              }
            }
            int v20 = 0;
            *(void *)(a1 + 80) += v19;
            *(_DWORD *)(a1 + 76) = 0;
            *(_DWORD *)(a1 + 88) = 0;
          }
          v18 += v22;
        }
        while (v18 < v14);
      }
      __buf += v17;
      v9 += v17;
      unint64_t v13 = *(void *)(a1 + 16) - v17;
      *(void *)(a1 + 16) = v13;
      v11 -= v17;
      if (!v11) {
        break;
      }
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  *(void *)(a1 + 32) += v9;
  return v9;
}

void *OMemStreamCreate(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = malloc(0x20uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    *uint64_t v4 = a1;
    v4[1] = 0;
    v4[2] = a2;
    void v4[3] = 0;
  }
  else
  {
    int v6 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OMemStreamCreate", 1050, 29, *v6, "malloc", v7, v8, v10);
  }
  return v5;
}

uint64_t OMemStreamGetNWritten(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t OMemStreamWrite(uint64_t a1, const void *a2, size_t a3)
{
  if (!a1 || *(_DWORD *)(a1 + 8)) {
    return -1;
  }
  if (*(void *)(a1 + 16) >= a3) {
    size_t v4 = a3;
  }
  else {
    size_t v4 = *(void *)(a1 + 16);
  }
  memcpy(*(void **)a1, a2, v4);
  *(void *)a1 += v4;
  size_t v5 = *(void *)(a1 + 24) + v4;
  *(void *)(a1 + 16) -= v4;
  *(void *)(a1 + 24) = v5;
  return v4;
}

void *IMemStreamCreate(uint64_t a1, uint64_t a2)
{
  size_t v4 = malloc(0x20uLL);
  size_t v5 = v4;
  if (v4)
  {
    *size_t v4 = a1;
    v4[1] = 0;
    v4[2] = a2;
    void v4[3] = 0;
  }
  else
  {
    int v6 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IMemStreamCreate", 1112, 29, *v6, "malloc", v7, v8, v10);
  }
  return v5;
}

size_t IMemStreamRead(uint64_t a1, void *__dst, size_t a3)
{
  if (!a1 || *(_DWORD *)(a1 + 8)) {
    return -1;
  }
  if (*(void *)(a1 + 16) >= a3) {
    size_t v4 = a3;
  }
  else {
    size_t v4 = *(void *)(a1 + 16);
  }
  memcpy(__dst, *(const void **)a1, v4);
  *(void *)a1 += v4;
  size_t v5 = *(void *)(a1 + 24) + v4;
  *(void *)(a1 + 16) -= v4;
  *(void *)(a1 + 24) = v5;
  return v4;
}

uint64_t IMemStreamAbort(uint64_t result)
{
  if (result) {
    *(_DWORD *)(result + 8) = 1;
  }
  return result;
}

char *OBufferedStreamCreate(uint64_t a1, uint64_t a2, uint64_t a3, size_t a4)
{
  uint64_t v8 = (char *)malloc(0x28uLL);
  uint64_t v9 = v8;
  if (v8)
  {
    *(_OWORD *)(v8 + 24) = 0u;
    *(_OWORD *)(v8 + 8) = 0u;
    char v10 = MemBufferCreate(a4);
    *(void *)uint64_t v9 = v10;
    if (v10)
    {
      *((void *)v9 + 1) = a1;
      *((void *)v9 + 2) = a2;
      *((void *)v9 + 3) = a3;
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OBufferedStreamCreate", 1182, 29, 0, "creating internal buffer", v11, v12, v24);
      OBufferedStreamDestroy((void ***)v9, v16, v17, v18, v19, v20, v21, v22);
      return 0;
    }
  }
  else
  {
    unint64_t v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OBufferedStreamCreate", 1176, 29, *v13, "malloc", v14, v15, v24);
  }
  return v9;
}

void OBufferedStreamDestroy(void ***a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    MemBufferFlushToOStream(*a1, 0xFFFFFFFFFFFFFFFFLL, (uint64_t (*)(uint64_t, uint64_t, unint64_t))a1[1], (uint64_t)a1[3], a5, a6, a7, a8);
    MemBufferDestroy(*a1);
    free(a1);
  }
}

uint64_t OBufferedStreamWrite(unint64_t **a1, char *a2, unint64_t a3)
{
  if (a1 && !*((_DWORD *)a1 + 8))
  {
    unint64_t v6 = a3;
    if (!a3) {
      return 0;
    }
    uint64_t v4 = 0;
    while (1)
    {
      unint64_t FreeSize = MemBufferGetFreeSize(*a1);
      if (!FreeSize)
      {
        if (MemBufferFlushToOStream(*a1, 0xFFFFFFFFFFFFFFFFLL, (uint64_t (*)(uint64_t, uint64_t, unint64_t))a1[1], (uint64_t)a1[3], v9, v10, v11, v12) < 0)return -1; {
        unint64_t FreeSize = MemBufferGetFreeSize(*a1);
        }
      }
      size_t v13 = v6 >= FreeSize ? FreeSize : v6;
      if (MemBufferFillFromBuffer(*a1, v13, a2) < 0) {
        break;
      }
      a2 += v13;
      v4 += v13;
      v6 -= v13;
      if (!v6) {
        return v4;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OBufferedStreamWrite", 1221, 29, 0, "MemBufferFillFromBuffer failed", v14, v15, v16);
  }
  return -1;
}

uint64_t bxdiff5Alloc(size_t a1, uint64_t *a2, uint64_t a3)
{
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  *(void *)(a3 + 16) = a1;
  uint64_t v3 = *a2;
  *(_DWORD *)(a3 + 8) = *((_DWORD *)a2 + 2);
  *(void *)a3 = v3;
  if (a1) {
    *(void *)(a3 + 24) = calloc(a1, 0x50uLL);
  }
  return 0;
}

uint64_t bxdiff5Free(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 16))
  {
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    int v11 = 1;
    do
    {
      uint64_t v12 = *(void *)(a1 + 24);
      if (*(void *)(v12 + v9))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 40, 54, 0, "in[%zu] is not NULL", a7, a8, v10);
        int v11 = 0;
        uint64_t v12 = *(void *)(a1 + 24);
      }
      if (*(void *)(v12 + v9 + 64))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 41, 54, 0, "inPatch[%zu] is not NULL", a7, a8, v10);
        int v11 = 0;
        uint64_t v12 = *(void *)(a1 + 24);
      }
      if (*(void *)(v12 + v9 + 40))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 42, 54, 0, "inControls[%zu] is not NULL", a7, a8, v10);
        int v11 = 0;
      }
      ++v10;
      v9 += 80;
    }
    while (v10 < *(void *)(a1 + 16));
  }
  else
  {
    int v11 = 1;
  }
  if (*(void *)(a1 + 32))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 44, 54, 0, "out is not NULL", a7, a8, v14);
    int v11 = 0;
  }
  if (*(void *)(a1 + 72))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 45, 54, 0, "comboControls is not NULL", a7, a8, v14);
    int v11 = 0;
  }
  if (*(void *)(a1 + 96))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 46, 54, 0, "comboPatch is not NULL", a7, a8, v14);
    int v11 = 0;
  }
  free(*(void **)(a1 + 24));
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  if (v11) {
    uint64_t result = 0;
  }
  else {
    uint64_t result = 0xFFFFFFFFLL;
  }
  *(_OWORD *)a1 = 0uLL;
  return result;
}

uint64_t bxdiff5Dump(uint64_t a1, FILE *a2)
{
  if (*(void *)(a1 + 16))
  {
    uint64_t v4 = 0;
    size_t v5 = (int *)(*(void *)(a1 + 24) + 36);
    uint64_t v6 = *(void *)(a1 + 16);
    do
    {
      int v7 = *v5;
      v5 += 20;
      if (v7) {
        ++v4;
      }
      --v6;
    }
    while (v6);
  }
  else
  {
    uint64_t v4 = 0;
  }
  fprintf(a2, "BXDiff5Data: n=%zu, nUnique=%zu\n", *(void *)(a1 + 16), v4);
  if (*(void *)(a1 + 16))
  {
    unint64_t v8 = 0;
    unint64_t v9 = 0;
    uint64_t v10 = 16;
    do
    {
      fprintf(a2, "- input %zu\n", v9);
      uint64_t v11 = *(void *)(a1 + 24);
      if (*(void *)(v11 + 80 * v9))
      {
        fprintf(a2, "    in set, inSize=%zu, inSHA1=", *(void *)(v11 + 80 * v9 + 8));
        for (uint64_t i = 0; i != 20; ++i)
          fprintf(a2, "%02x", *(unsigned __int8 *)(*(void *)(a1 + 24) + v10 + i));
        size_t v13 = "unique";
        if (!*(_DWORD *)(*(void *)(a1 + 24) + 80 * v9 + 36)) {
          size_t v13 = "non unique";
        }
        fprintf(a2, ", %s", v13);
        fputc(10, a2);
      }
      else
      {
        fwrite("    in is NULL\n", 0xFuLL, 1uLL, a2);
      }
      uint64_t v14 = *(void *)(a1 + 24);
      if (*(void *)(v14 + 80 * v9 + 40))
      {
        uint64_t v15 = v14 + 80 * v9;
        unint64_t v16 = 3 * *(void *)(v15 + 56);
        fprintf(a2, "    inControls set, nControls=%zu, inPlace=%d (%zu MB)\n", *(void *)(v15 + 56), *(_DWORD *)(v15 + 48), (v16 >> 17) & 0xFFFFFFFFFFFLL);
        v8 += 8 * v16;
      }
      else
      {
        fwrite("    inControls is NULL\n", 0x17uLL, 1uLL, a2);
      }
      uint64_t v17 = *(void *)(a1 + 24);
      if (*(void *)(v17 + 80 * v9 + 64))
      {
        unint64_t v18 = *(void *)(v17 + 80 * v9 + 72);
        fprintf(a2, "    inPatch set, inPatchSize=%zu (%zu MB)\n", v18, v18 >> 20);
        v8 += v18;
      }
      else
      {
        fwrite("    inPatch is NULL\n", 0x14uLL, 1uLL, a2);
      }
      ++v9;
      v10 += 80;
    }
    while (v9 < *(void *)(a1 + 16));
  }
  else
  {
    unint64_t v8 = 0;
  }
  fwrite("- output\n", 9uLL, 1uLL, a2);
  if (*(void *)(a1 + 32))
  {
    fprintf(a2, "    out set, outSize=%zu, outSHA1=", *(void *)(a1 + 40));
    for (uint64_t j = 0; j != 20; ++j)
      fprintf(a2, "%02x", *(unsigned __int8 *)(a1 + 48 + j));
    fputc(10, a2);
  }
  else
  {
    fwrite("    out is NULL\n", 0x10uLL, 1uLL, a2);
  }
  if (*(void *)(a1 + 72))
  {
    unint64_t v20 = (8 * v4 + 16) * *(void *)(a1 + 88);
    fprintf(a2, "    comboControls set, nControls=%zu, inPlace=%d (%zu MB)\n", *(void *)(a1 + 88), *(_DWORD *)(a1 + 80), v20 >> 20);
    v8 += v20;
  }
  else
  {
    fwrite("    comboControls is NULL\n", 0x1AuLL, 1uLL, a2);
  }
  if (*(void *)(a1 + 96))
  {
    unint64_t v21 = *(void *)(a1 + 104);
    fprintf(a2, "    comboPatch set, comboPatchSize=%zu (%zu MB)\n", v21, v21 >> 20);
    v8 += v21;
  }
  else
  {
    fwrite("    comboPatch is NULL\n", 0x17uLL, 1uLL, a2);
  }
  fprintf(a2, "Total size %zu MB\n", v8 >> 20);
  return 0;
}

uint64_t bxdiff5SetIn(void *a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[2] <= a2)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5SetIn", 122, 54, 0, "invalid I=%zu", a7, a8, a2);
    return 0xFFFFFFFFLL;
  }
  if (!a3 || !a4)
  {
    unint64_t v16 = "invalid in,inSize";
    __int16 v17 = 123;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5SetIn", v17, 54, 0, v16, a7, a8, v19);
    return 0xFFFFFFFFLL;
  }
  if (!a1[4])
  {
    unint64_t v16 = "missing out";
    __int16 v17 = 124;
    goto LABEL_16;
  }
  uint64_t v10 = a1[3] + 80 * a2;
  *(void *)uint64_t v10 = a3;
  *(void *)(v10 + 8) = a4;
  getBufferSHA1Digest(a3, a4, (unsigned __int8 *)(v10 + 16));
  unint64_t v11 = a1[2];
  uint64_t v12 = a1[3];
  *(_DWORD *)(v12 + 80 * a2 + 36) = 1;
  if (v11)
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    while (1)
    {
      if (a2 != v14)
      {
        uint64_t v15 = a1[3];
        if (*(void *)(v15 + v13))
        {
          if (!sha1cmp(v15 + 80 * a2 + 16, v15 + v13 + 16))
          {
            uint64_t v12 = a1[3];
            *(_DWORD *)(v12 + 80 * a2 + 36) = 0;
            break;
          }
          unint64_t v11 = a1[2];
        }
      }
      ++v14;
      v13 += 80;
      if (v14 >= v11)
      {
        uint64_t v12 = a1[3];
        break;
      }
    }
  }
  uint64_t result = sha1cmp(v12 + 80 * a2 + 16, (uint64_t)(a1 + 6));
  if (result) {
    return 0;
  }
  *(_DWORD *)(a1[3] + 80 * a2 + 36) = 0;
  return result;
}

uint64_t bxdiff5SetOut(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 && a3)
  {
    *(void *)(a1 + 32) = a2;
    *(void *)(a1 + 40) = a3;
    getBufferSHA1Digest(a2, a3, (unsigned __int8 *)(a1 + 48));
    return 0;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5SetOut", 155, 54, 0, "invalid out,outSize", a7, a8, vars0);
    return 0xFFFFFFFFLL;
  }
}

uint64_t bxdiff5SetInPatch(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5SetInPatch", 165, 54, 0, "invalid I=%zu", a7, a8, a2);
  }
  else
  {
    if (a3 && a4)
    {
      uint64_t result = 0;
      uint64_t v10 = *(void *)(a1 + 24) + 80 * a2;
      *(void *)(v10 + 64) = a3;
      *(void *)(v10 + 72) = a4;
      return result;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5SetInPatch", 166, 54, 0, "invalid inPatch,inPatchSize", a7, a8, v11);
  }
  return 0xFFFFFFFFLL;
}

uint64_t bxdiff5ReadInControlsFromInPatch(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    unint64_t v9 = "invalid input index";
    __int16 v10 = 176;
    goto LABEL_12;
  }
  uint64_t v8 = *(void *)(a1 + 24);
  if (!*(void *)(v8 + 80 * a2))
  {
    unint64_t v9 = "input data is missing";
    __int16 v10 = 177;
    goto LABEL_12;
  }
  if (!*(void *)(a1 + 32))
  {
    unint64_t v9 = "output data is missing";
    __int16 v10 = 178;
    goto LABEL_12;
  }
  if (*(void *)(v8 + 80 * a2 + 40))
  {
    unint64_t v9 = "input controls already present";
    __int16 v10 = 179;
LABEL_12:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5ReadInControlsFromInPatch", v10, 54, 0, v9, a7, a8, v41);
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = *(void *)(v8 + 80 * a2 + 64);
  if (!v11 || (unint64_t v12 = *(void *)(v8 + 80 * a2 + 72), v12 <= 0x57))
  {
    unint64_t v9 = "input patch is missing or invalid";
    __int16 v10 = 180;
    goto LABEL_12;
  }
  if (!*(_DWORD *)(v8 + 80 * a2 + 36)) {
    return 0;
  }
  if (*(void *)v11 != 0x3035464649445842 || *(_DWORD *)(v11 + 8) != 1 || (uint64_t v14 = *(void *)(v11 + 24)) == 0)
  {
    __int16 v17 = "patch is not a valid 1:1 BXDIFF50";
    __int16 v18 = 199;
    goto LABEL_28;
  }
  if (*(void *)(v11 + 16) != *(void *)(a1 + 40))
  {
    __int16 v17 = "out size mismatch in patch";
    __int16 v18 = 202;
    goto LABEL_28;
  }
  if (*(void *)(a1 + 48) != *(void *)(v11 + 40)
    || *(void *)(a1 + 56) != *(void *)(v11 + 48)
    || *(_DWORD *)(a1 + 64) != (unint64_t)*(unsigned int *)(v11 + 56))
  {
    __int16 v17 = "out digest mismatch in patch";
    __int16 v18 = 203;
LABEL_28:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5ReadInControlsFromInPatch", v18, 54, 0, v17, a7, a8, v41);
    uint64_t v19 = 0;
    goto LABEL_29;
  }
  uint64_t v21 = v8 + 80 * a2;
  uint64_t v22 = *(void *)(v21 + 16);
  uint64_t v23 = *(void *)(v21 + 24);
  uint64_t v24 = *(unsigned int *)(v21 + 32);
  if (v22 != *(void *)(v11 + 68) || v23 != *(void *)(v11 + 76) || v24 != *(_DWORD *)(v11 + 84))
  {
    __int16 v17 = "in digest mismatch in patch";
    __int16 v18 = 204;
    goto LABEL_28;
  }
  uint64_t v41 = a1;
  if (v11 + 88 + v14 > v11 + v12)
  {
    __int16 v17 = "invalid patch payload size";
    __int16 v18 = 212;
    goto LABEL_28;
  }
  int v27 = *(_DWORD *)(v11 + 12);
  uint64_t v19 = ILowMemoryDecoderStreamCreateWithBuffer(v11 + 88, v14, 0x10000uLL);
  if (!v19)
  {
    uint64_t v37 = "Control stream init";
    __int16 v38 = 215;
    int v39 = 0;
    goto LABEL_58;
  }
  unint64_t v20 = 0;
  unint64_t v30 = 0;
  unint64_t v31 = 0;
  int v32 = v27 & 1;
  while (1)
  {
    if (v30 < v31) {
      goto LABEL_51;
    }
    if (v31) {
      v31 += v31 >> 1;
    }
    else {
      unint64_t v31 = 4096;
    }
    uint64_t v33 = reallocf(v20, 24 * v31);
    if (!v33) {
      break;
    }
    unint64_t v20 = v33;
LABEL_51:
    unint64_t v34 = ILowMemoryDecoderStreamRead(v19, (char *)v20 + 24 * v30, 24 * (v31 - v30));
    if ((v34 & 0x8000000000000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5ReadInControlsFromInPatch", 227, 54, 0, "ILZMAMemStreamRead", v35, v36, v41);
      ILowMemoryDecoderStreamDestroy(v19);
      goto LABEL_30;
    }
    if (!v34)
    {
      ILowMemoryDecoderStreamDestroy(v19);
      uint64_t result = 0;
      uint64_t v40 = *(void *)(v41 + 24) + 80 * a2;
      *(void *)(v40 + 40) = v20;
      *(_DWORD *)(v40 + 48) = v32;
      *(void *)(v40 + 56) = v30;
      return result;
    }
    v30 += v34 / 0x18;
  }
  int v39 = *__error();
  uint64_t v37 = "malloc";
  __int16 v38 = 223;
LABEL_58:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5ReadInControlsFromInPatch", v38, 54, v39, v37, v28, v29, v41);
LABEL_29:
  ILowMemoryDecoderStreamDestroy(v19);
  unint64_t v20 = 0;
LABEL_30:
  free(v20);
  return 0xFFFFFFFFLL;
}

uint64_t bxdiff5CreateInControls(uint64_t a1, unint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    uint64_t v14 = "invalid input index";
    __int16 v15 = 247;
    goto LABEL_5;
  }
  uint64_t v10 = *(void *)(a1 + 24);
  uint64_t v11 = v10 + 80 * a2;
  uint64_t v13 = *(void *)(v11 + 40);
  unint64_t v12 = (int8x16_t **)(v11 + 40);
  if (v13)
  {
    uint64_t v14 = "input controls already present";
    __int16 v15 = 248;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateInControls", v15, 54, 0, v14, a7, a8, v25);
    return 0xFFFFFFFFLL;
  }
  uint64_t v17 = *(void *)(v10 + 80 * a2);
  if (!v17 || (unint64_t v18 = *(void *)(v10 + 80 * a2 + 8)) == 0)
  {
    uint64_t v14 = "input is missing or invalid";
    __int16 v15 = 249;
    goto LABEL_5;
  }
  if (!*(_DWORD *)(v10 + 80 * a2 + 36)) {
    return 0;
  }
  uint64_t v20 = *(void *)(a1 + 32);
  unint64_t v21 = *(void *)(a1 + 40);
  uint64_t v22 = (uint64_t *)(v10 + 80 * a2 + 56);
  if (!(v18 >> 28) || v21 >> 28 == 0)
  {
    if ((getBXDiffControls(v17, v18, v20, v21, v12, (uint64_t)v22, (int *)a1, a8) & 0x80000000) != 0)
    {
      uint64_t v14 = "generic controls";
      __int16 v15 = 270;
      goto LABEL_5;
    }
  }
  else
  {
    int LargeFileControls = GetLargeFileControls(v17, v18, v20, v21, (void **)v12, v22, (uint64_t *)a1, a8);
    if (LargeFileControls < 0)
    {
      uint64_t v14 = "largefile controls";
      __int16 v15 = 262;
      goto LABEL_5;
    }
  }
  if (!a3) {
    return 0;
  }
  if ((forceInPlaceControls(*(void *)(*(void *)(a1 + 24) + 80 * a2 + 8), *(void *)(a1 + 40), *(void *)(*(void *)(a1 + 24) + 80 * a2 + 40), *(void *)(*(void *)(a1 + 24) + 80 * a2 + 56), *(_DWORD *)(a1 + 4)) & 0x80000000) != 0)
  {
    uint64_t v14 = "forceInPlaceControls";
    __int16 v15 = 278;
    goto LABEL_5;
  }
  uint64_t result = 0;
  *(_DWORD *)(*(void *)(a1 + 24) + 80 * a2 + 48) = 1;
  return result;
}

uint64_t bxdiff5CreateComboControls(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8 = *(void *)(a1 + 16);
  if (!v8) {
    goto LABEL_7;
  }
  unint64_t v10 = 0;
  uint64_t v11 = (int *)(*(void *)(a1 + 24) + 36);
  uint64_t v12 = *(void *)(a1 + 16);
  do
  {
    int v13 = *v11;
    v11 += 20;
    if (v13) {
      ++v10;
    }
    --v12;
  }
  while (v12);
  if (v10 > 1)
  {
    *(_DWORD *)(a1 + 80) = 1;
    __int16 v15 = (uint64_t *)calloc(v8, 0x18uLL);
    if (v15)
    {
      unint64_t v16 = v15;
      uint64_t v17 = v15;
      size_t v18 = v8;
      do
      {
        initDiffSegmentVector(v17);
        v17 += 3;
        --v18;
      }
      while (v18);
      uint64_t v25 = 0;
      unint64_t v26 = 0;
      uint64_t v27 = *(void *)(a1 + 24);
      do
      {
        if (*(_DWORD *)(v27 + v25 + 36))
        {
          uint64_t v28 = *(void *)(v27 + v25 + 40);
          if (!v28)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboControls", 309, 54, 0, "missing controls for input %zu", v23, v24, v18);
            goto LABEL_28;
          }
          if ((pushControls((unint64_t *)&v16[3 * v26], v28, *(void *)(v27 + v25 + 56), 0, 0) & 0x80000000) != 0)
          {
            uint64_t v33 = "pushControls";
            __int16 v34 = 312;
            goto LABEL_27;
          }
          uint64_t v27 = *(void *)(a1 + 24);
          if (!*(_DWORD *)(v27 + v25 + 48)) {
            *(_DWORD *)(a1 + 80) = 0;
          }
          ++v26;
        }
        ++v18;
        v25 += 80;
      }
      while (v8 != v18);
      if ((mergeDiffSegmentVectors(v26, v16, v19, v20, v21, v22, v23, v24) & 0x80000000) != 0)
      {
        uint64_t v33 = "mergeDiffSegmentVectors";
        __int16 v34 = 321;
      }
      else
      {
        if ((getComboControlsFromMergedDiffSegmentVectors((char *)v26, v16, (void *)(a1 + 72), (uint64_t *)(a1 + 88)) & 0x80000000) == 0)
        {
          int v29 = 1;
          goto LABEL_29;
        }
        uint64_t v33 = "getComboControlsFromMergedDiffSegmentVectors";
        __int16 v34 = 324;
      }
LABEL_27:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboControls", v34, 54, 0, v33, v23, v24, v37);
LABEL_28:
      int v29 = 0;
LABEL_29:
      if (v8 <= 1) {
        uint64_t v35 = 1;
      }
      else {
        uint64_t v35 = v8;
      }
      uint64_t v36 = (uint64_t)v16;
      do
      {
        BlobBufferFree(v36);
        v36 += 24;
        --v35;
      }
      while (v35);
      free(v16);
    }
    else
    {
      unint64_t v30 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboControls", 300, 54, *v30, "malloc", v31, v32, v37);
      int v29 = 0;
    }
    if (v29) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboControls", 289, 54, 0, "creating combo controls requires 2 or more unique inputs", a7, a8, v37);
    return 0xFFFFFFFFLL;
  }
}

uint64_t bxdiff5CreateInPatch(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 24) + 80 * a2;
  return bxdiff5CreatePatchBackend(1, v2, v2 + 8, v2 + 16, *(void *)(a1 + 32), *(void *)(a1 + 40), a1 + 48, *(void *)(v2 + 40), *(void *)(v2 + 56), (void *)(v2 + 64), (size_t *)(v2 + 72), *(_DWORD *)(v2 + 48), *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
}

uint64_t bxdiff5CreatePatchBackend(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int64_t __size, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, size_t *a11, int a12, int a13, unsigned int a14)
{
  uint64_t v19 = a10;
  size_t v18 = a11;
  uint64_t v22 = (char *)malloc(__size);
  if (!v22)
  {
    int v28 = *__error();
    int v29 = "malloc";
    __int16 v30 = 447;
LABEL_48:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", v30, 54, v28, v29, v20, v21, v86);
    __int16 v34 = 0;
LABEL_49:
    free(v22);
    free(v34);
    long long v67 = 0;
    size_t v68 = 0;
    uint64_t v69 = 0xFFFFFFFFLL;
    goto LABEL_50;
  }
  uint64_t v23 = a9;
  if (a9)
  {
    int64x2_t v24 = 0uLL;
    int64x2_t v25 = vdupq_n_s64(0x8000000000000000);
    unint64_t v26 = (int64x2_t *)a8;
    uint64_t v27 = a9;
    do
    {
      int64x2_t v24 = vaddq_s64((int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(*v26), (int8x16_t)vsubq_s64(v25, *v26), *(int8x16_t *)v26), v24);
      unint64_t v26 = (int64x2_t *)((char *)v26 + 8 * a1 + 16);
      --v27;
    }
    while (v27);
  }
  else
  {
    int64x2_t v24 = 0uLL;
  }
  uint64_t v88 = a1 + 2;
  if (a13 > 1)
  {
    *(int64x2_t *)__dsta = v24;
    fprintf((FILE *)*MEMORY[0x263EF8348], "BXDiff5 backend, out: %zu B, diff: %zu B, lit: %zu B, ctrl: %zu B\n", __size, v24.u64[0], v24.u64[1], 8 * (a1 + 2) * a9);
    int64x2_t v24 = *(int64x2_t *)__dsta;
  }
  if (vaddvq_s64(v24) != __size)
  {
    int v29 = "size inconsistency: diff + archive != out";
    __int16 v30 = 458;
    int v28 = 0;
    goto LABEL_48;
  }
  __dst = v22;
  uint64_t v31 = 28 * a1 + lzma_stream_buffer_bound() * a1;
  size_t v32 = v31 + lzma_stream_buffer_bound() + 60;
  if (a13 >= 2) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "BXDiff5 patch allocated: %zu B\n", v32);
  }
  uint64_t v33 = malloc(v32);
  __int16 v34 = v33;
  if (!v33)
  {
    uint64_t v71 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 469, 54, *v71, "malloc", v72, v73, v86);
LABEL_52:
    uint64_t v19 = a10;
    uint64_t v22 = __dst;
    goto LABEL_49;
  }
  *(_OWORD *)((char *)v33 + 44) = 0u;
  v33[1] = 0u;
  v33[2] = 0u;
  _OWORD *v33 = 0u;
  uint64_t v87 = (char *)v33 + 60;
  bzero((char *)v33 + 60, 28 * a1);
  *__int16 v34 = 0x3035464649445842;
  v34[2] = __size;
  *(_OWORD *)(v34 + 5) = *(_OWORD *)a7;
  *((_DWORD *)v34 + 14) = *(_DWORD *)(a7 + 16);
  *((_DWORD *)v34 + 2) = a1;
  *((_DWORD *)v34 + 3) = a12 != 0;
  if (a1)
  {
    uint64_t v35 = (char *)v34 + 68;
    uint64_t v36 = a1;
    do
    {
      *(_OWORD *)uint64_t v35 = *(_OWORD *)a4;
      *((_DWORD *)v35 + 4) = *(_DWORD *)(a4 + 16);
      a4 += 20;
      v35 += 28;
      --v36;
    }
    while (v36);
  }
  char v37 = (char *)v34 + v32;
  uint64_t v38 = (uint64_t)&v87[28 * a1];
  if (a13 > 1) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "BXDiff5 patch headers: %zu B\n", v38 - (void)v34);
  }
  uint64_t v19 = a10;
  uint64_t v39 = plzmaEncodeBuffer(v38, (uint64_t)&v37[-v38], a8, 8 * (a1 + 2) * a9, a14);
  if (v39 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 499, 54, 0, "Payload compression", v40, v41, v86);
    uint64_t v22 = __dst;
    goto LABEL_49;
  }
  uint64_t v42 = v38 + v39;
  v34[3] = v39;
  if (a13 >= 2) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "BXDiff5 patch control payload: %zu B\n", v39);
  }
  uint64_t v22 = __dst;
  if (a1)
  {
    uint64_t v43 = 0;
    uint64_t v44 = a5;
    while (!a9)
    {
      unsigned int v48 = v22;
LABEL_42:
      uint64_t v63 = plzmaEncodeBuffer(v42, (uint64_t)&v37[-v42], (uint64_t)v22, v48 - v22, a14);
      if (v63 < 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 530, 54, 0, "Payload compression", v64, v65, v86);
        goto LABEL_52;
      }
      uint64_t v66 = v63;
      *(void *)&v87[28 * v43] = v63;
      if (a13 >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "BXDiff5 patch diff[%zu] payload: %zu B\n", v43, v63);
      }
      v42 += v66;
      ++v43;
      uint64_t v22 = __dst;
      uint64_t v44 = a5;
      if (v43 == a1) {
        goto LABEL_56;
      }
    }
    uint64_t v45 = 0;
    uint64_t v46 = 0;
    uint64_t v47 = 0;
    unsigned int v48 = v22;
    while (1)
    {
      int v49 = (int64_t *)(a8 + 8 * v45 * v88);
      uint64_t v50 = v49[1];
      int64_t v51 = 0x8000000000000000 - *v49;
      if (*v49 >= 0) {
        int64_t v51 = *v49;
      }
      unint64_t v52 = 0x8000000000000000 - v50;
      if (v50 >= 0) {
        unint64_t v52 = v49[1];
      }
      uint64_t v53 = v49[v43 + 2];
      if (v53 < 0) {
        uint64_t v53 = 0x8000000000000000 - v53;
      }
      if (v46 < 0) {
        break;
      }
      uint64_t v54 = v51 + v46;
      if (v51 + v46 > __size) {
        break;
      }
      if (v47 < 0 || (uint64_t v55 = v51 + v47, v51 + v47 > *(void *)(a3 + 8 * v43)))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 519, 54, 0, "in[%zu] access out of range", a2, v88, v43);
        goto LABEL_69;
      }
      if (v51 >= 1)
      {
        stat v56 = (char *)(*(void *)(a2 + 8 * v43) + v47);
        long long v57 = (char *)(v44 + v46);
        dirent v58 = v48;
        int64_t v59 = v51;
        do
        {
          char v61 = *v57++;
          char v60 = v61;
          char v62 = *v56++;
          *v58++ = v60 - v62;
          --v59;
        }
        while (v59);
      }
      v48 += v51;
      uint64_t v46 = v54 + v52;
      uint64_t v47 = v55 + v53;
      if (++v45 == a9) {
        goto LABEL_42;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 518, 54, 0, "out access out of range", a2, v88, v86);
    goto LABEL_69;
  }
  uint64_t v44 = a5;
LABEL_56:
  if (a9)
  {
    size_t v74 = 0;
    unint64_t v75 = (size_t *)(a8 + 8);
    uint64_t v76 = 8 * a1 + 16;
    uint64_t v22 = __dst;
    do
    {
      uint64_t v77 = *(v75 - 1);
      if (v77 < 0) {
        uint64_t v77 = 0x8000000000000000 - v77;
      }
      if ((*v75 & 0x8000000000000000) == 0) {
        size_t v78 = *v75;
      }
      else {
        size_t v78 = 0x8000000000000000 - *v75;
      }
      size_t v79 = v77 + v74;
      memcpy(v22, (const void *)(v44 + v77 + v74), v78);
      uint64_t v44 = a5;
      v22 += v78;
      size_t v74 = v79 + v78;
      unint64_t v75 = (size_t *)((char *)v75 + v76);
      --v23;
    }
    while (v23);
  }
  uint64_t v80 = v22 - __dst;
  uint64_t v22 = __dst;
  uint64_t v81 = plzmaEncodeBuffer(v42, (uint64_t)&v37[-v42], (uint64_t)__dst, v80, a14);
  if (v81 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 554, 54, 0, "Payload compression", v82, v83, v86);
    size_t v18 = a11;
LABEL_69:
    uint64_t v19 = a10;
    goto LABEL_49;
  }
  uint64_t v84 = v42 + v81;
  char v34[4] = v81;
  if (a13 <= 1)
  {
    size_t v68 = v84 - (void)v34;
  }
  else
  {
    uint64_t v85 = (FILE **)MEMORY[0x263EF8348];
    fprintf((FILE *)*MEMORY[0x263EF8348], "BXDiff5 patch archive payload: %zu B\n", v81);
    size_t v68 = v84 - (void)v34;
    fprintf(*v85, "BXDiff5 patch total size: %zu B\n", v84 - (void)v34);
  }
  size_t v18 = a11;
  uint64_t v19 = a10;
  free(__dst);
  long long v67 = reallocToFit(v34, v68);
  uint64_t v69 = 0;
LABEL_50:
  *uint64_t v19 = v67;
  *size_t v18 = v68;
  return v69;
}

uint64_t bxdiff5CreateComboPatch(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 72))
  {
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      size_t v10 = 0;
      uint64_t v11 = (int *)(*(void *)(a1 + 24) + 36);
      do
      {
        int v12 = *v11;
        v11 += 20;
        if (v12) {
          ++v10;
        }
        --v9;
      }
      while (v9);
    }
    else
    {
      size_t v10 = 0;
    }
    uint64_t v14 = calloc(v10, 8uLL);
    __int16 v15 = calloc(v10, 8uLL);
    unint64_t v16 = (char *)calloc(v10, 0x14uLL);
    uint64_t v17 = v16;
    if (v14) {
      BOOL v18 = v15 == 0;
    }
    else {
      BOOL v18 = 1;
    }
    if (v18 || v16 == 0)
    {
      uint64_t v20 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboPatch", 609, 54, *v20, "malloc", v21, v22, v32);
      uint64_t PatchBackend = 0xFFFFFFFFLL;
    }
    else
    {
      unint64_t v23 = *(void *)(a1 + 16);
      if (v23)
      {
        uint64_t v24 = 0;
        unint64_t v25 = 0;
        uint64_t v26 = 0;
        do
        {
          uint64_t v27 = *(void *)(a1 + 24);
          if (*(_DWORD *)(v27 + v24 + 36))
          {
            v14[v26] = *(void *)(v27 + v24);
            uint64_t v28 = *(void *)(a1 + 24) + v24;
            v15[v26] = *(void *)(v28 + 8);
            int v29 = &v16[20 * v26];
            long long v30 = *(_OWORD *)(v28 + 16);
            *((_DWORD *)v29 + 4) = *(_DWORD *)(v28 + 32);
            *(_OWORD *)int v29 = v30;
            ++v26;
            unint64_t v23 = *(void *)(a1 + 16);
          }
          ++v25;
          v24 += 80;
        }
        while (v25 < v23);
      }
      uint64_t PatchBackend = bxdiff5CreatePatchBackend(v10, (uint64_t)v14, (uint64_t)v15, (uint64_t)v16, *(void *)(a1 + 32), *(void *)(a1 + 40), a1 + 48, *(void *)(a1 + 72), *(void *)(a1 + 88), (void *)(a1 + 96), (size_t *)(a1 + 104), *(_DWORD *)(a1 + 80), *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
    }
    free(v14);
    free(v15);
    free(v17);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboPatch", 600, 54, 0, "missing combo controls", a7, a8, v32);
    return 0xFFFFFFFFLL;
  }
  return PatchBackend;
}

uint64_t BXDiff5(uint64_t a1, void **a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return BXDiff5WithIndividualPatches(a1, a2, a3, 0, 0, a6, a7, a8);
}

uint64_t BXDiff5WithIndividualPatches(uint64_t a1, void **a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v109 = *MEMORY[0x263EF8340];
  if (HIDWORD(*(void *)a1))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"BXDiff5WithIndividualPatches", 645, 54, 0, "Invalid number of inputs: %zu", a7, a8, *(void *)a1);
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = (void *)a5;
  size_t v10 = (void *)a4;
  int v14 = *(_DWORD *)(a1 + 48);
  enterThreadErrorContext(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, v93);
  size_t v15 = *(void *)a1;
  int v16 = *(_DWORD *)(a1 + 52);
  if (v10) {
    BOOL v17 = v9 == 0;
  }
  else {
    BOOL v17 = 1;
  }
  int v18 = !v17;
  long long v107 = 0u;
  long long v108 = 0u;
  long long v105 = 0u;
  *(_OWORD *)size_t v106 = 0u;
  long long v103 = 0u;
  long long v104 = 0u;
  long long v102 = 0u;
  int v19 = *(_DWORD *)(a1 + 44);
  int v99 = v18;
  LODWORD(v100) = *(_DWORD *)(a1 + 40);
  HIDWORD(v100) = v16;
  int v101 = v19;
  bxdiff5Alloc(v15, &v100, (uint64_t)&v102);
  *a2 = 0;
  *a3 = 0;
  if (v10 && v15) {
    bzero(v10, 8 * v15);
  }
  if (v9 && v15) {
    bzero(v9, 8 * v15);
  }
  if (bxdiff5SetOut((uint64_t)&v102, *(void *)(a1 + 24), *(void *)(a1 + 32), v20, v21, v22, v23, v24))
  {
    char v32 = "bxdiff5SetOut";
    __int16 v33 = 672;
LABEL_17:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"BXDiff5WithIndividualPatches", v33, 54, 0, v32, v30, v31, v94);
    LODWORD(v34) = 0;
    goto LABEL_18;
  }
  if (v15)
  {
    unint64_t v45 = 0;
    while (!bxdiff5SetIn(&v102, v45, *(void *)(*(void *)(a1 + 8) + 8 * v45), *(void *)(*(void *)(a1 + 16) + 8 * v45), v28, v29, v30, v31))
    {
      if (v15 == ++v45) {
        goto LABEL_28;
      }
    }
    char v32 = "bxdiff5SetIn";
    __int16 v33 = 675;
    goto LABEL_17;
  }
LABEL_28:
  uint64_t v46 = v103;
  if ((void)v103)
  {
    uint64_t v47 = 0;
    unsigned int v48 = (int *)(*((void *)&v103 + 1) + 36);
    do
    {
      int v49 = *v48;
      v48 += 20;
      if (v49) {
        ++v47;
      }
      --v46;
    }
    while (v46);
    if (!v47) {
      *(_DWORD *)(*((void *)&v103 + 1) + 36) = 1;
    }
  }
  if (v16 >= 2) {
    bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x263EF8348]);
  }
  if (v15)
  {
    uint64_t v50 = v103;
    uint64_t v96 = a2;
    if ((void)v103)
    {
      unint64_t v34 = 0;
      int64_t v51 = (int *)(*((void *)&v103 + 1) + 36);
      do
      {
        int v52 = *v51;
        v51 += 20;
        if (v52) {
          ++v34;
        }
        --v50;
      }
      while (v50);
      if (v34 == 1)
      {
        uint64_t v53 = 0;
        uint64_t v54 = (int *)(*((void *)&v103 + 1) + 36);
        while (1)
        {
          int v55 = *v54;
          v54 += 20;
          if (v55) {
            break;
          }
          if (v15 == ++v53)
          {
            char v32 = "could not find unique input";
            __int16 v33 = 699;
            goto LABEL_17;
          }
        }
        char v67 = v14;
        int v98 = v16;
        int v99 = 0;
        uint64_t v97 = a3;
        int v68 = 1;
        unint64_t v34 = 1;
LABEL_59:
        unint64_t v69 = 0;
        int v70 = v67 & 2;
        if (v15 <= 1) {
          uint64_t v71 = 1;
        }
        else {
          uint64_t v71 = v15;
        }
        uint64_t v72 = 36;
        do
        {
          if (*(_DWORD *)(*((void *)&v103 + 1) + v72))
          {
            if (bxdiff5CreateInControls((uint64_t)&v102, v69, v70, v27, v28, v29, v30, v31))
            {
              char v32 = "bxdiff5CreateInControls";
              __int16 v33 = 710;
              goto LABEL_17;
            }
            int v73 = v53 == v69 ? v68 : 0;
            if ((v99 || v73) && bxdiff5CreateInPatch((uint64_t)&v102, v69))
            {
              char v32 = "bxdiff5CreateInPatch";
              __int16 v33 = 718;
              goto LABEL_17;
            }
          }
          ++v69;
          v72 += 80;
        }
        while (v71 != v69);
        if (v98 >= 2) {
          bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x263EF8348]);
        }
        if (v34 >= 2)
        {
          if (bxdiff5CreateComboControls((uint64_t)&v102, v25, v26, v27, v28, v29, v30, v31))
          {
            char v32 = "bxdiff5CreateComboControls";
            __int16 v33 = 730;
            goto LABEL_17;
          }
          uint64_t v79 = 0;
          uint64_t v80 = *((void *)&v103 + 1);
          uint64_t v81 = v71;
          do
          {
            free(*(void **)(v80 + v79 + 40));
            uint64_t v80 = *((void *)&v103 + 1);
            uint64_t v89 = *((void *)&v103 + 1) + v79;
            *(void *)(v89 + 40) = 0;
            *(void *)(v89 + 56) = 0;
            v79 += 80;
            --v81;
          }
          while (v81);
          if (v98 > 1) {
            bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x263EF8348]);
          }
          if (bxdiff5CreateComboPatch((uint64_t)&v102, v82, v83, v84, v85, v86, v87, v88))
          {
            char v32 = "bxdiff5CreateComboPatch";
            __int16 v33 = 747;
            goto LABEL_17;
          }
        }
        if (v98 >= 2) {
          bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x263EF8348]);
        }
        if (v34 >= 2)
        {
          uint64_t v90 = *((void *)&v108 + 1);
          char *v96 = (void *)v108;
          void *v97 = v90;
          long long v108 = 0uLL;
          if (!v99) {
            goto LABEL_97;
          }
          BOOL v91 = (void *)(*((void *)&v103 + 1) + 64);
          do
          {
            *v10++ = *v91;
            *v9++ = v91[1];
            *BOOL v91 = 0;
            v91[1] = 0;
            v91 += 10;
            --v71;
          }
          while (v71);
        }
        if (v34 == 1)
        {
          uint64_t v92 = *((void *)&v103 + 1) + 80 * v53;
          char *v96 = *(void **)(v92 + 64);
          void *v97 = *(void *)(v92 + 72);
          *(void *)(v92 + 64) = 0;
          *(void *)(v92 + 72) = 0;
          goto LABEL_18;
        }
LABEL_97:
        LODWORD(v34) = 1;
LABEL_18:
        if (v15)
        {
          uint64_t v35 = 0;
          uint64_t v36 = *((void *)&v103 + 1);
          do
          {
            uint64_t v37 = v36 + v35;
            *(void *)uint64_t v37 = 0;
            free(*(void **)(v37 + 40));
            uint64_t v36 = *((void *)&v103 + 1);
            *(void *)(*((void *)&v103 + 1) + v35 + 40) = 0;
            v35 += 80;
            --v15;
          }
          while (v15);
        }
        goto LABEL_21;
      }
      char v67 = v14;
      int v98 = v16;
      uint64_t v97 = a3;
      int v68 = 0;
    }
    else
    {
      char v67 = v14;
      int v98 = v16;
      uint64_t v97 = a3;
      int v68 = 0;
      unint64_t v34 = 0;
    }
    uint64_t v53 = -1;
    goto LABEL_59;
  }
  long long v56 = v104;
  int v57 = DWORD1(v102);
  unsigned int v58 = DWORD2(v102);
  uint64_t v59 = lzma_stream_buffer_bound();
  size_t v60 = v59 + 60;
  if (v57 >= 1) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "BXDiff5 patch capacity: %zu B\n", v60);
  }
  char v61 = (char *)malloc(v60);
  char v62 = v61;
  if (v61)
  {
    *(_OWORD *)char v61 = 0u;
    *((_OWORD *)v61 + 1) = 0u;
    *(_OWORD *)(v61 + 44) = 0u;
    *((_OWORD *)v61 + 2) = 0u;
    *(void *)char v61 = 0x3035464649445842;
    *((void *)v61 + 1) = 0;
    *((void *)v61 + 2) = *((void *)&v56 + 1);
    *(_OWORD *)(v61 + 40) = v105;
    *((_DWORD *)v61 + 14) = v106[0];
    uint64_t v63 = plzmaEncodeBuffer((uint64_t)(v61 + 60), v59, v56, *((uint64_t *)&v56 + 1), v58);
    if ((v63 & 0x8000000000000000) == 0)
    {
      uint64_t v66 = (char *)v62 + v63 + 60;
      v62[4] = v63;
      if (v57 >= 1) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "BXDiff5 patch archive payload size: %zu B\n", v63);
      }
      *a2 = reallocToFit(v62, v66 - (char *)v62);
      *a3 = v66 - (char *)v62;
      LODWORD(v34) = 1;
      goto LABEL_21;
    }
    unint64_t v75 = "Payload compression";
    __int16 v76 = 406;
    int v74 = 0;
  }
  else
  {
    int v74 = *__error();
    unint64_t v75 = "malloc patch";
    __int16 v76 = 386;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateFullReplacementBackend", v76, 54, v74, v75, v64, v65, v94);
  free(v62);
  *a2 = 0;
  *a3 = 0;
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"BXDiff5WithIndividualPatches", 689, 54, 0, "bxdiff5CreateFullReplacementBackend", v77, v78, v95);
  LODWORD(v34) = 0;
LABEL_21:
  *(void *)&long long v104 = 0;
  free(v106[1]);
  v106[1] = 0;
  bxdiff5Free((uint64_t)&v102, v38, v39, v40, v41, v42, v43, v44);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0) {
    return (v34 - 1);
  }
  else {
    return result;
  }
}

uint64_t plzmaEncodeBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v29 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  size_t v10 = IMemStreamCreate(a3, a4);
  if (!v10)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"plzmaEncodeBuffer", 348, 54, 0, "is", v8, v9, v25);
    int v19 = 0;
LABEL_8:
    int v22 = 1;
    goto LABEL_9;
  }
  uint64_t v11 = OMemStreamCreate(a1, a2);
  int v19 = v11;
  if (!v11)
  {
    uint64_t v20 = "os";
    __int16 v21 = 349;
    goto LABEL_7;
  }
  *(void *)((char *)&v25 + 4) = a5 | 0x100000000;
  LODWORD(v25) = 0;
  *(void *)&long long v26 = 0x100000;
  *((void *)&v26 + 1) = IMemStreamRead;
  *((void *)&v27 + 1) = v10;
  *(void *)&long long v28 = OMemStreamWrite;
  uint64_t v29 = v11;
  if (ParallelCompressionEncode((uint64_t)&v25, v12, v13, v14, v15, v16, v17, v18))
  {
    uint64_t v20 = "encode";
    __int16 v21 = 358;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"plzmaEncodeBuffer", v21, 54, 0, v20, v17, v18, v25);
    goto LABEL_8;
  }
  int v22 = 0;
LABEL_9:
  uint64_t NWritten = OMemStreamGetNWritten((uint64_t)v19);
  IMagicStreamDestroy(v10);
  IMagicStreamDestroy(v19);
  if (v22) {
    return -1;
  }
  else {
    return NWritten;
  }
}

void *StringTableCreate()
{
  uint64_t v0 = calloc(1uLL, 0x28uLL);
  if (!v0)
  {
    uint64_t v1 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"StringTableCreate", 30, 35, *v1, "malloc", v2, v3, v5);
  }
  return v0;
}

uint64_t stringTableReserve(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 4);
  if (v2 >= a2) {
    return 0;
  }
  unsigned int v4 = v2 ? v2 + (v2 >> 1) : 32;
  if (v4 <= a2) {
    unsigned int v4 = a2;
  }
  *(_DWORD *)(a1 + 4) = v4;
  char v5 = reallocf(*(void **)(a1 + 8), 16 * v4);
  *(void *)(a1 + 8) = v5;
  if (v5) {
    return 0;
  }
  int v7 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"stringTableReserve", 23, 35, *v7, "malloc", v8, v9, v10);
  return 0xFFFFFFFFLL;
}

void StringTableDestroy(void **a1)
{
  if (a1)
  {
    BlobBufferFree((uint64_t)(a1 + 2));
    free(a1[1]);
    free(a1);
  }
}

uint64_t StringTableAppend(unsigned int *a1, const void *a2, size_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4) {
    *a4 = *a1;
  }
  if (HIDWORD(a3))
  {
    uint64_t v11 = "string too long for StringTable";
    __int16 v12 = 74;
  }
  else if (stringTableReserve((uint64_t)a1, *a1 + 1))
  {
    uint64_t v11 = "increasing string table capacity";
    __int16 v12 = 77;
  }
  else
  {
    v17[0] = 0;
    v17[1] = 0;
    if (!BlobBufferStore((uint64_t)(a1 + 4), 0, a3 + 1, v17))
    {
      uint64_t v14 = *((void *)a1 + 1) + 16 * *a1;
      uint64_t v15 = v17[0];
      *(void *)uint64_t v14 = v17[0];
      *(_DWORD *)(v14 + 8) = a3;
      uint64_t v16 = (void *)(*((void *)a1 + 4) + v15);
      memcpy(v16, a2, a3);
      uint64_t result = 0;
      *((unsigned char *)v16 + a3) = 0;
      ++*a1;
      return result;
    }
    uint64_t v11 = "insertion failed in string table";
    __int16 v12 = 81;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"StringTableAppend", v12, 35, 0, v11, a7, a8, v17[0]);
  return 0xFFFFFFFFLL;
}

uint64_t StringTableAppendTable(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  if (a3) {
    *a3 = *(_DWORD *)a1;
  }
  if (!*a2) {
    return 0;
  }
  if (stringTableReserve(a1, *(_DWORD *)a1 + *a2))
  {
    int v7 = "increasing string table capacity";
    __int16 v8 = 152;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"StringTableAppendTable", v8, 35, 0, v7, v5, v6, v15[0]);
    return 0xFFFFFFFFLL;
  }
  v15[0] = 0;
  v15[1] = 0;
  if (BlobBufferStore(a1 + 16, *((const void **)a2 + 4), *((void *)a2 + 3), v15))
  {
    int v7 = "increasing blob capacity failed";
    __int16 v8 = 156;
    goto LABEL_9;
  }
  if (*a2)
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    uint64_t v12 = *(void *)(a1 + 8);
    do
    {
      unsigned int v13 = v11 + *(_DWORD *)a1;
      *(_OWORD *)(v12 + 16 * v13) = *(_OWORD *)(*((void *)a2 + 1) + v10);
      uint64_t v12 = *(void *)(a1 + 8);
      *(void *)(v12 + 16 * v13) += v15[0];
      ++v11;
      unint64_t v14 = *a2;
      v10 += 16;
    }
    while (v11 < v14);
  }
  else
  {
    LODWORD(v14) = 0;
  }
  uint64_t result = 0;
  *(_DWORD *)a1 += v14;
  return result;
}

size_t StringTableSort(unsigned int *a1, void *a2)
{
  size_t result = *a1;
  if (result)
  {
    if (a2)
    {
      uint64_t v5 = calloc(result, 4uLL);
      if (!v5)
      {
        unsigned int v13 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"StringTableSort", 195, 35, *v13, "malloc", v14, v15, v16);
        return 0xFFFFFFFFLL;
      }
      uint64_t v6 = v5;
      *a2 = v5;
      size_t result = *a1;
      if (result)
      {
        uint64_t v7 = 0;
        __int16 v8 = (_DWORD *)(*((void *)a1 + 1) + 12);
        do
        {
          *__int16 v8 = v7;
          v8 += 4;
          ++v7;
        }
        while (result != v7);
      }
    }
    else
    {
      uint64_t v6 = 0;
    }
    qsort_r(*((void **)a1 + 1), result, 0x10uLL, a1, (int (__cdecl *)(void *, const void *, const void *))stringTableIndexCompareProc);
    if (*a1 < 2)
    {
      unsigned int v11 = 1;
    }
    else
    {
      uint64_t v9 = 0;
      unint64_t v10 = 1;
      unsigned int v11 = 1;
      do
      {
        uint64_t v12 = *((void *)a1 + 1);
        if (!strcmp((const char *)(*((void *)a1 + 4) + *(void *)(v12 + 16 * (v11 - 1))), (const char *)(*((void *)a1 + 4) + *(void *)(v12 + v9 + 16))))
        {
          if (v6) {
            v6[*(unsigned int *)(v12 + v9 + 28)] = v11 - 1;
          }
        }
        else
        {
          if (v6) {
            v6[*(unsigned int *)(v12 + v9 + 28)] = v11;
          }
          if (v10 != v11) {
            *(_OWORD *)(v12 + 16 * v11) = *(_OWORD *)(v12 + v9 + 16);
          }
          ++v11;
        }
        ++v10;
        v9 += 16;
      }
      while (v10 < *a1);
    }
    size_t result = 0;
    *a1 = v11;
  }
  return result;
}

uint64_t stringTableIndexCompareProc(uint64_t a1, void *a2, void *a3)
{
  return strcmp((const char *)(*(void *)(a1 + 32) + *a2), (const char *)(*(void *)(a1 + 32) + *a3));
}

uint64_t getBXDiffControls(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, int8x16_t **a5, uint64_t a6, int *a7, uint64_t a8)
{
  uint64_t v8 = 0xFFFFFFFFLL;
  if (!a2 || !a4) {
    return v8;
  }
  unint64_t v10 = (void *)a6;
  if (a2 >= a4) {
    unint64_t v13 = a4;
  }
  else {
    unint64_t v13 = a2;
  }
  if (v13 >= 0x10000)
  {
    unint64_t v14 = a2 - a4;
    if (a2 < a4) {
      unint64_t v14 = a4 - a2;
    }
    uint64_t v15 = (unsigned __int8 *)a1;
    char v16 = (unsigned __int8 *)a3;
    do
    {
      int v18 = *v15++;
      int v17 = v18;
      int v19 = *v16++;
      if (v17 != v19) {
        ++v14;
      }
      --v13;
    }
    while (v13);
    if (v14 <= a4 / 0x64)
    {
      uint64_t v96 = (int8x16_t *)calloc(1uLL, 0x18uLL);
      if (v96)
      {
        *a5 = v96;
        *unint64_t v10 = 1;
        if (a2 <= a4)
        {
          uint64_t v8 = 0;
          v101.i64[0] = a2;
          v101.i64[1] = a4 - a2;
          int8x16_t *v96 = vbslq_s8((int8x16_t)vcltzq_s64(v101), (int8x16_t)vsubq_s64(vdupq_n_s64(0x8000000000000000), v101), (int8x16_t)v101);
          v96[1].i64[0] = 0;
        }
        else
        {
          uint64_t v8 = 0;
          unint64_t v97 = 0x8000000000000000 - a4;
          v96->i64[1] = 0;
          v96[1].i64[0] = 0;
          if ((a4 & 0x8000000000000000) == 0) {
            unint64_t v97 = a4;
          }
          v96->i64[0] = v97;
        }
        return v8;
      }
      int v98 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c", (uint64_t)"bxdiffFastPathControls", 101, 24, *v98, "calloc", v99, v100, v105);
      char v94 = "building fast path controls";
      __int16 v95 = 311;
LABEL_121:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c", (uint64_t)"getBXDiffControls", v95, 24, 0, v94, v21, v22, v105);
      return 0xFFFFFFFFLL;
    }
  }
  uint64_t v20 = BXDiffMatchesCreate(a1, a2, a3, a4, a7, a6, (uint64_t)a7, a8);
  if (!v20)
  {
    char v94 = "creating diff match lookup object";
    __int16 v95 = 319;
    goto LABEL_121;
  }
  uint64_t v23 = (void **)v20;
  uint64_t v24 = BXDiffMatchesIBuf(v20);
  uint64_t v25 = BXDiffMatchesISize((uint64_t)v23);
  uint64_t NWritten = OMemStreamGetNWritten((uint64_t)v23);
  uint64_t v27 = BXDiffMatchesOSize((uint64_t)v23);
  long long v28 = 0;
  uint64_t v117 = 0;
  if (!v25 || !v27) {
    goto LABEL_126;
  }
  if (v27 < 1)
  {
    unint64_t v30 = 0;
    char v93 = 0;
    goto LABEL_123;
  }
  uint64_t v115 = (uint64_t)v23;
  size_t v106 = v10;
  long long v107 = a5;
  __ptr = 0;
  unint64_t v29 = 0;
  unint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v113 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  uint64_t v35 = v27;
  int v108 = 1;
  int64x2_t v109 = vdupq_n_s64(0x8000000000000000);
  uint64_t v116 = v27;
  do
  {
    unint64_t v112 = v30;
    v34 += v33;
    BOOL v111 = v34 < v27;
    unint64_t v114 = v29;
    uint64_t v36 = 0;
    if (v34 >= v27)
    {
LABEL_46:
      if (v33 == v36)
      {
        unint64_t v30 = v112;
        if (v34 != v27) {
          continue;
        }
        goto LABEL_50;
      }
    }
    else
    {
      uint64_t v37 = v34;
      do
      {
        uint64_t BestMatch = BXDiffMatchesGetBestMatch(v115, v37, &v117);
        uint64_t v39 = BestMatch + v37;
        if (BestMatch + v37 <= v35) {
          uint64_t v33 = BestMatch;
        }
        else {
          uint64_t v33 = v35 - v37;
        }
        if (v34 >= v33 + v37)
        {
          uint64_t v27 = v116;
        }
        else
        {
          if (v39 >= v35) {
            uint64_t v39 = v35;
          }
          uint64_t v40 = (unsigned __int8 *)(NWritten + v34);
          uint64_t v41 = v39 - v34;
          uint64_t v42 = v31 + v34;
          uint64_t v27 = v116;
          do
          {
            if (v42 < v25 && *(unsigned __int8 *)(v24 + v42) == *v40) {
              ++v36;
            }
            ++v40;
            ++v42;
            --v41;
          }
          while (v41);
          uint64_t v34 = v39;
        }
        BOOL v43 = v33 != v36 || v33 == 0;
        if (!v43 || v33 > v36 + 8)
        {
          uint64_t v34 = v37;
          unint64_t v29 = v114;
          goto LABEL_46;
        }
        if (v37 + v31 < v25) {
          v36 -= *(unsigned __int8 *)(v24 + v37 + v31) == *(unsigned __int8 *)(NWritten + v37);
        }
        ++v37;
      }
      while (v37 < v27);
      BOOL v111 = 0;
      uint64_t v34 = v27;
    }
    unint64_t v30 = v112;
LABEL_50:
    uint64_t v45 = v34 - v32;
    uint64_t v46 = v25 - v113;
    if (v34 - v32 < v25 - v113) {
      uint64_t v46 = v34 - v32;
    }
    if (v46 < 1)
    {
      uint64_t v51 = 0;
    }
    else
    {
      uint64_t v47 = 0;
      int v48 = 0;
      unsigned __int8 v49 = 0;
      unint64_t v50 = 0;
      uint64_t v51 = 0;
      do
      {
        unint64_t v52 = v49 | (v50 << 8);
        unsigned __int8 v53 = *(unsigned char *)(v24 + v47 + v113) - *(unsigned char *)(NWritten + v47 + v32);
        if ((v50 & 0xFF000000FF0000) != 0 || (unsigned __int16)v52 == 0) {
          int v55 = 3;
        }
        else {
          int v55 = 4;
        }
        BOOL v56 = __OFADD__(v55, v48);
        int v57 = v55 + v48;
        if ((v57 < 0) ^ v56 | (v57 == 0)) {
          uint64_t v58 = v51;
        }
        else {
          uint64_t v58 = v47 + 1;
        }
        int v59 = v57 & (v57 >> 31);
        v48 -= 4;
        ++v47;
        if (!v53)
        {
          uint64_t v51 = v58;
          int v48 = v59;
        }
        unint64_t v50 = v52;
        unsigned __int8 v49 = v53;
      }
      while (v47 != v46);
    }
    if (!v111) {
      goto LABEL_86;
    }
    if (v45 >= v117) {
      uint64_t v45 = v117;
    }
    if (v45 >= 1)
    {
      uint64_t v60 = 0;
      int v61 = 0;
      unsigned __int8 v62 = 0;
      unint64_t v63 = 0;
      uint64_t v64 = 0;
      uint64_t v65 = (char *)(NWritten - 1 + v34);
      uint64_t v66 = (char *)(v24 - 1 + v117);
      do
      {
        ++v60;
        unint64_t v67 = v62 | (v63 << 8);
        BOOL v43 = (v63 & 0xFF000000FF0000) == 0;
        char v69 = *v66--;
        char v68 = v69;
        char v70 = *v65--;
        unsigned __int8 v71 = v68 - v70;
        if (!v43 || (unsigned __int16)v67 == 0) {
          int v73 = 3;
        }
        else {
          int v73 = 4;
        }
        BOOL v56 = __OFADD__(v73, v61);
        int v74 = v73 + v61;
        if ((v74 < 0) ^ v56 | (v74 == 0)) {
          uint64_t v75 = v64;
        }
        else {
          uint64_t v75 = v60;
        }
        int v76 = v74 & (v74 >> 31);
        v61 -= 4;
        if (!v71)
        {
          uint64_t v64 = v75;
          int v61 = v76;
        }
        unint64_t v63 = v67;
        unsigned __int8 v62 = v71;
      }
      while (v45 != v60);
    }
    else
    {
LABEL_86:
      uint64_t v64 = 0;
    }
    uint64_t v77 = v51 + v32 - (v34 - v64);
    if (v51 + v32 > v34 - v64)
    {
      if (v77 < 1)
      {
        uint64_t v80 = 0;
      }
      else
      {
        uint64_t v78 = 0;
        uint64_t v79 = 0;
        uint64_t v80 = 0;
        do
        {
          int v81 = *(unsigned __int8 *)(NWritten + v79 + v34 - v64);
          v78 -= v81 == *(unsigned __int8 *)(v24 + v117 - v64 + v79);
          int v82 = *(unsigned __int8 *)(v24 + v113 - (v32 - (v34 - v64)) + v79);
          if (v78 >= 0) {
            uint64_t v83 = v79 + 1;
          }
          else {
            uint64_t v83 = v80;
          }
          if (v78 < 0) {
            uint64_t v84 = v78 + 1;
          }
          else {
            uint64_t v84 = 0;
          }
          ++v79;
          if (v81 == v82)
          {
            uint64_t v80 = v83;
            uint64_t v78 = v84;
          }
        }
        while (v79 < v77);
      }
      uint64_t v51 = v34 - v64 - v32 + v80;
      v64 -= v80;
    }
    unint64_t v85 = v114;
    if (v30 >= v114)
    {
      v114 += 0x40000;
      __ptr = (int8x16_t *)reallocf(__ptr, 24 * (v85 + 0x40000));
      if (!__ptr)
      {
        uint64_t v86 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c", (uint64_t)"bxdiffControlsWithMatches", 255, 24, *v86, "malloc", v87, v88, v105);
        __ptr = 0;
        int v108 = 0;
      }
      uint64_t v27 = v116;
    }
    uint64_t v89 = v51 + v32;
    uint64_t v32 = v34 - v64;
    v90.i64[0] = v51;
    v90.i64[1] = v34 - v64 - v89;
    BOOL v91 = (int8x16_t *)((char *)__ptr + 24 * v30);
    *BOOL v91 = vbslq_s8((int8x16_t)vcltzq_s64(v90), (int8x16_t)vsubq_s64(v109, v90), (int8x16_t)v90);
    uint64_t v92 = v117 - (v51 + v113 + v64);
    if (v92 < 0) {
      uint64_t v92 = 0x8000000000000000 - v92;
    }
    v91[1].i64[0] = v92;
    ++v30;
    uint64_t v113 = v117 - v64;
    uint64_t v31 = v117 - v34;
    unint64_t v29 = v114;
  }
  while (v34 < v27);
  unint64_t v10 = v106;
  a5 = v107;
  if (!v108)
  {
    uint64_t v23 = (void **)v115;
    long long v28 = __ptr;
LABEL_126:
    free(v28);
    *a5 = 0;
    *unint64_t v10 = 0;
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c", (uint64_t)"getBXDiffControls", 324, 24, 0, "building diff controls", v102, v103, v105);
    goto LABEL_127;
  }
  char v93 = __ptr;
  if (__ptr) {
    char v93 = (int8x16_t *)reallocToFit(__ptr, 24 * v30);
  }
  uint64_t v23 = (void **)v115;
LABEL_123:
  *a5 = v93;
  *unint64_t v10 = v30;
LABEL_127:
  BXDiffMatchesDestroy(v23);
  if (*a5) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

_DWORD *ParallelCompressionAFSCStreamOpen(int a1, unint64_t a2, int a3, int a4)
{
  unint64_t v10 = calloc(1uLL, 0x78uLL);
  if (!v10)
  {
    unint64_t v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCStreamOpen", 163, 86, *v13, "malloc", v14, v15, v35);
LABEL_39:
    free(v10);
    return 0;
  }
  if (!a2)
  {
    unsigned int v11 = "File too small for AFSC";
    __int16 v12 = 167;
LABEL_7:
    int v16 = 0;
LABEL_38:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCStreamOpen", v12, 86, v16, v11, v8, v9, v35);
    free(*((void **)v10 + 5));
    free(*((void **)v10 + 8));
    free(*((void **)v10 + 10));
    free(*((void **)v10 + 11));
    goto LABEL_39;
  }
  if (a2 >= 0xFA000001)
  {
    unsigned int v11 = "File too large for AFSC";
    __int16 v12 = 168;
    goto LABEL_7;
  }
  if (a3) {
    int v17 = a3;
  }
  else {
    int v17 = 4;
  }
  int v18 = v17 - 3;
  if (v17 - 3) <= 0xA && ((0x551u >> v18)) {
    int v17 = dword_2106D3EBC[v18];
  }
  compression_algorithm v19 = 0;
  size_t v20 = 0;
  char v21 = -52;
  compression_algorithm v22 = 1285;
  char v23 = -1;
  switch(v17)
  {
    case 4:
      goto LABEL_19;
    case 8:
      compression_algorithm v22 = 2304;
      char v23 = 6;
      goto LABEL_19;
    case 10:
      goto LABEL_22;
    case 12:
      compression_algorithm v22 = COMPRESSION_LZFSE;
      goto LABEL_19;
    case 14:
      compression_algorithm v22 = COMPRESSION_LZBITMAP;
LABEL_19:
      size_t v20 = compression_encode_scratch_buffer_size(v22);
      size_t v24 = compression_decode_scratch_buffer_size(v22);
      if (v20 <= v24) {
        size_t v20 = v24;
      }
      compression_algorithm v19 = v22;
      char v21 = v23;
LABEL_22:
      *unint64_t v10 = a1;
      unint64_t v25 = (a2 + 0xFFFF) >> 16;
      *((void *)v10 + 1) = a2;
      v10[4] = v17;
      v10[5] = v19;
      *((unsigned char *)v10 + 24) = v21;
      v10[7] = a4;
      v10[8] = v25;
      long long v26 = calloc(v25 + 1, 4uLL);
      *((void *)v10 + 5) = v26;
      if (!v26)
      {
        int v16 = *__error();
        unsigned int v11 = "malloc";
        __int16 v12 = 210;
        goto LABEL_38;
      }
      uint64_t v27 = v26;
      *((_OWORD *)v10 + 3) = xmmword_2106D3E70;
      long long v28 = malloc(0x100000uLL);
      *((void *)v10 + 8) = v28;
      if (!v28)
      {
        int v16 = *__error();
        unsigned int v11 = "malloc";
        __int16 v12 = 214;
        goto LABEL_38;
      }
      *((void *)v10 + 9) = 0;
      unint64_t v29 = malloc(0x10000uLL);
      *((void *)v10 + 10) = v29;
      if (!v29)
      {
        int v16 = *__error();
        unsigned int v11 = "malloc";
        __int16 v12 = 217;
        goto LABEL_38;
      }
      if (v20)
      {
        unint64_t v30 = malloc(v20);
        *((void *)v10 + 11) = v30;
        if (!v30)
        {
          int v16 = *__error();
          unsigned int v11 = "malloc";
          __int16 v12 = 221;
          goto LABEL_38;
        }
      }
      char v31 = 2;
      if (v10[4] == 4) {
        char v31 = 3;
      }
      uint64_t v32 = 4;
      if (v10[4] == 4) {
        uint64_t v32 = 264;
      }
      unint64_t v33 = ((unint64_t)v10[8] << v31) + v32;
      if (HIDWORD(v33))
      {
        unsigned int v11 = "File too large for AFSC";
        __int16 v12 = 235;
        goto LABEL_7;
      }
      v10[27] = v33;
      *uint64_t v27 = v33;
      v10[26] = 0;
      *((void *)v10 + 12) = 0;
      v10[28] = 0;
      break;
    default:
      char v35 = v17;
      unsigned int v11 = "invalid compression type %d";
      __int16 v12 = 192;
      goto LABEL_7;
  }
  return v10;
}

uint64_t ParallelCompressionAFSCStreamWrite(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 96) + a3 <= *(void *)(a1 + 8))
  {
    if (!a3) {
      return 0;
    }
    unint64_t v10 = 0;
    size_t v14 = *(void *)(a1 + 56);
    while (v14 + 65537 <= *(void *)(a1 + 48) || (flushToResourceFork(a1) & 0x80000000) == 0)
    {
      uint64_t v15 = *(void *)(a1 + 72);
      if (0x10000 - v15 + v10 <= a3) {
        size_t v16 = 0x10000 - v15;
      }
      else {
        size_t v16 = a3 - v10;
      }
      if (v16 == 0x10000)
      {
        int v17 = (char *)(a2 + v10);
      }
      else
      {
        int v17 = *(char **)(a1 + 80);
        memcpy(&v17[v15], (const void *)(a2 + v10), v16);
        uint64_t v15 = *(void *)(a1 + 72);
      }
      size_t v18 = *(void *)(a1 + 96) + v16;
      *(void *)(a1 + 96) = v18;
      v10 += v16;
      size_t v19 = v15 + v16;
      *(void *)(a1 + 72) = v15 + v16;
      if ((v15 + v16) >> 16 || v18 >= *(void *)(a1 + 8))
      {
        uint64_t v21 = *(void *)(a1 + 56);
        uint64_t v20 = *(void *)(a1 + 64);
        compression_algorithm v22 = (unsigned char *)(v20 + v21);
        compression_algorithm v23 = *(_DWORD *)(a1 + 20);
        BOOL v24 = v19 < 0x78 || v23 == 0;
        if (v24
          || (v25 = compression_encode_buffer((uint8_t *)(v20 + v21), 0x10000uLL, (const uint8_t *)v17, v19, *(void **)(a1 + 88), v23)) == 0|| (*(unsigned char *)(a1 + 28) & 1) != 0 && (size_t v26 = v25 + (v25 >> 6), v25 = v26 + 32, v26 == -32)|| v25 > *(void *)(a1 + 72) + 1)
        {
          *compression_algorithm v22 = *(unsigned char *)(a1 + 24);
          memcpy(v22 + 1, v17, *(void *)(a1 + 72));
          size_t v25 = *(void *)(a1 + 72) + 1;
        }
        *(void *)(a1 + 72) = 0;
        size_t v14 = *(void *)(a1 + 56) + v25;
        *(void *)(a1 + 56) = v14;
        *(_DWORD *)(*(void *)(a1 + 40) + 4 * ++*(_DWORD *)(a1 + 104)) = *(_DWORD *)(*(void *)(a1 + 40) + 4 * *(unsigned int *)(a1 + 104))
                                                                                        + v25;
        if (v10 < a3) {
          continue;
        }
      }
      return v10;
    }
    uint64_t v8 = "update resource fork";
    __int16 v9 = 270;
  }
  else
  {
    uint64_t v8 = "too many bytes received";
    __int16 v9 = 262;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCStreamWrite", v9, 86, 0, v8, a7, a8, v28);
  return -1;
}

uint64_t flushToResourceFork(uint64_t a1)
{
  int v2 = fsetxattr(*(_DWORD *)a1, "com.apple.ResourceFork", *(const void **)(a1 + 64), *(void *)(a1 + 56), *(_DWORD *)(a1 + 108), 0);
  if (v2 < 0)
  {
    uint64_t v3 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"flushToResourceFork", 142, 86, *v3, "fsetxattr resource fork", v4, v5, v8);
  }
  int v6 = *(_DWORD *)(a1 + 108) + *(_DWORD *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 108) = v6;
  *(_DWORD *)(a1 + 112) = 1;
  return (v2 >> 31);
}

uint64_t ParallelCompressionAFSCStreamClose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 0;
  }
  memset(&v42, 0, sizeof(v42));
  if (*(void *)(a1 + 96) >= *(void *)(a1 + 8) && !*(void *)(a1 + 72))
  {
    unsigned int v14 = *(_DWORD *)(a1 + 112);
    int v15 = *(_DWORD *)(a1 + 20);
    if (v15) {
      int v15 = (*(unsigned __int8 *)(a1 + 28) >> 1) & 1;
    }
    if (*(_DWORD *)(a1 + 32) > 1u) {
      int v15 = 1;
    }
    if ((unint64_t)(*(void *)(a1 + 56) - 3569) < 0xFFFFFFFFFFFFF1FFLL) {
      int v15 = 1;
    }
    if (v14 | v15)
    {
      if ((flushToResourceFork(a1) & 0x80000000) != 0)
      {
        __int16 v9 = "update resource fork";
        __int16 v10 = 341;
        goto LABEL_5;
      }
      unsigned int v14 = *(_DWORD *)(a1 + 112);
    }
    int v16 = (__PAIR64__(*(_DWORD *)(a1 + 16), v14) - 1) >> 32;
    uint64_t v17 = *(void *)(a1 + 8);
    uint64_t v18 = *(void *)(a1 + 80);
    *(_DWORD *)uint64_t v18 = 1668116582;
    *(_DWORD *)(v18 + 4) = v16;
    *(void *)(v18 + 8) = v17;
    size_t v19 = 16;
    *(void *)(a1 + 72) = 16;
    if (!*(_DWORD *)(a1 + 112))
    {
      memcpy((void *)(*(void *)(a1 + 80) + 16), *(const void **)(a1 + 64), *(void *)(a1 + 56));
      size_t v19 = *(void *)(a1 + 72) + *(void *)(a1 + 56);
      *(void *)(a1 + 72) = v19;
      *(void *)(a1 + 56) = 0;
    }
    if (fsetxattr(*(_DWORD *)a1, "com.apple.decmpfs", *(const void **)(a1 + 80), v19, 0, 0) < 0)
    {
      int v11 = *__error();
      __int16 v9 = "fsetxattr decmpfs";
      __int16 v10 = 363;
      goto LABEL_6;
    }
    if (!*(_DWORD *)(a1 + 112))
    {
      unsigned int v21 = 0;
      goto LABEL_36;
    }
    if (*(_DWORD *)(a1 + 16) == 4)
    {
      uint64_t v20 = *(void *)(a1 + 64);
      *(_OWORD *)uint64_t v20 = old_resource_fork_map;
      *(_OWORD *)(v20 + 16) = unk_2106D3E98;
      *(_OWORD *)(v20 + 32) = xmmword_2106D3EA8;
      *(_WORD *)(v20 + 48) = 0;
      *(void *)(a1 + 56) = 50;
      if ((flushToResourceFork(a1) & 0x80000000) != 0)
      {
        __int16 v9 = "update resource fork";
        __int16 v10 = 373;
        goto LABEL_5;
      }
      unsigned int v21 = *(_DWORD *)(a1 + 108);
      if (*(_DWORD *)(a1 + 16) == 4)
      {
        int v22 = *(_DWORD *)(a1 + 32);
        if ((unint64_t)(8 * v22) + 264 > *(void *)(a1 + 48))
        {
          LOBYTE(v41) = 8 * v22 + 8;
          __int16 v9 = "File a radar to increase obuf_capacity, sz=%zu";
          __int16 v10 = 382;
          goto LABEL_5;
        }
        long long v43 = 0u;
        long long v44 = 0u;
        long long v47 = 0u;
        long long v48 = 0u;
        long long v45 = 0u;
        long long v46 = 0u;
        long long v51 = 0u;
        long long v52 = 0u;
        long long v49 = 0u;
        long long v50 = 0u;
        long long v55 = 0u;
        long long v56 = 0u;
        long long v53 = 0u;
        long long v54 = 0u;
        long long v57 = 0u;
        uint64_t v32 = *(void *)(a1 + 64);
        *(_DWORD *)uint64_t v32 = 0x10000;
        *(int8x8_t *)(v32 + 4) = vrev32_s8((int8x8_t)vadd_s32(vdup_n_s32(v21), (int32x2_t)0xFFFFFECEFFFFFFCELL));
        *(_DWORD *)(v32 + 12) = 838860800;
        long long v33 = v44;
        *(_OWORD *)(v32 + 16) = v43;
        *(_OWORD *)(v32 + 32) = v33;
        long long v34 = v48;
        *(_OWORD *)(v32 + 80) = v47;
        *(_OWORD *)(v32 + 96) = v34;
        long long v35 = v46;
        *(_OWORD *)(v32 + 48) = v45;
        *(_OWORD *)(v32 + 64) = v35;
        long long v36 = v52;
        *(_OWORD *)(v32 + 144) = v51;
        *(_OWORD *)(v32 + 160) = v36;
        long long v37 = v50;
        *(_OWORD *)(v32 + 112) = v49;
        *(_OWORD *)(v32 + 128) = v37;
        long long v38 = v56;
        *(_OWORD *)(v32 + 208) = v55;
        *(_OWORD *)(v32 + 224) = v38;
        long long v39 = v54;
        *(_OWORD *)(v32 + 176) = v53;
        *(_OWORD *)(v32 + 192) = v39;
        *(_OWORD *)(v32 + 240) = v57;
        *(_DWORD *)(v32 + 256) = bswap32(v21 - 310);
        *(_DWORD *)(v32 + 260) = v22;
        size_t v23 = 264;
        *(void *)(a1 + 56) = 264;
        if (*(_DWORD *)(a1 + 32))
        {
          unint64_t v40 = 0;
          size_t v23 = 264;
          do
          {
            *(void *)(*(void *)(a1 + 64) + v23) = (*(_DWORD *)(*(void *)(a1 + 40) + 4 * v40) - 260) | ((unint64_t)(*(_DWORD *)(*(void *)(a1 + 40) + 4 * v40 + 4) - *(_DWORD *)(*(void *)(a1 + 40) + 4 * v40)) << 32);
            ++v40;
            size_t v23 = *(void *)(a1 + 56) + 8;
            *(void *)(a1 + 56) = v23;
          }
          while (v40 < *(unsigned int *)(a1 + 32));
        }
        goto LABEL_35;
      }
    }
    else
    {
      unsigned int v21 = *(_DWORD *)(a1 + 108);
    }
    size_t v23 = (4 * *(_DWORD *)(a1 + 32) + 4);
    if (*(void *)(a1 + 48) < v23)
    {
      int v41 = 4 * *(_DWORD *)(a1 + 32) + 4;
      __int16 v9 = "File a radar to increase obuf_capacity, sz=%zu";
      __int16 v10 = 408;
      goto LABEL_5;
    }
    memcpy(*(void **)(a1 + 64), *(const void **)(a1 + 40), (4 * *(_DWORD *)(a1 + 32) + 4));
    *(void *)(a1 + 56) = v23;
LABEL_35:
    if (fsetxattr(*(_DWORD *)a1, "com.apple.ResourceFork", *(const void **)(a1 + 64), v23, 0, 0) < 0)
    {
      int v11 = *__error();
      __int16 v9 = "fsetxattr resource fork header";
      __int16 v10 = 418;
      goto LABEL_6;
    }
LABEL_36:
    if (ftruncate(*(_DWORD *)a1, 0))
    {
      int v11 = *__error();
      __int16 v9 = "ftruncate";
      __int16 v10 = 422;
      goto LABEL_6;
    }
    if ((*(unsigned char *)(a1 + 28) & 4) != 0 || !*(_DWORD *)(a1 + 112) || 93 * *(void *)(a1 + 8) / 0x64uLL >= v21)
    {
      if (fstat(*(_DWORD *)a1, &v42))
      {
        int v11 = *__error();
        __int16 v9 = "fstat";
        __int16 v10 = 465;
        goto LABEL_6;
      }
      if (fchflags(*(_DWORD *)a1, v42.st_flags | 0x20) < 0)
      {
        int v11 = *__error();
        __int16 v9 = "fchflags UF_COMPRESSED";
        __int16 v10 = 466;
        goto LABEL_6;
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 32))
      {
        unint64_t v24 = 0;
        off_t v25 = 0;
        while (1)
        {
          size_t v26 = (u_int32_t *)(*(void *)(a1 + 40) + 4 * v24);
          u_int32_t v27 = v26[1];
          size_t v28 = v27 - *v26;
          if (v27 == *v26 || v28 >= 0x10002)
          {
            __int16 v9 = "Invalid chunk size";
            __int16 v10 = 437;
            goto LABEL_5;
          }
          if (fgetxattr(*(_DWORD *)a1, "com.apple.ResourceFork", *(void **)(a1 + 64), v27 - *v26, *v26, 32) != v28)
          {
            __int16 v9 = "reading chunk";
            __int16 v10 = 440;
            goto LABEL_5;
          }
          unint64_t v30 = *(const uint8_t **)(a1 + 64);
          if (*v30 == *(unsigned __int8 *)(a1 + 24))
          {
            size_t v31 = (v28 - 1);
            memcpy(*(void **)(a1 + 80), v30 + 1, v31);
          }
          else
          {
            size_t v31 = compression_decode_buffer(*(uint8_t **)(a1 + 80), 0x10000uLL, v30, v28, *(void **)(a1 + 88), (compression_algorithm)*(_DWORD *)(a1 + 20));
          }
          if (v31 != 0x10000)
          {
            if (!v31)
            {
              __int16 v9 = "Decompression";
              __int16 v10 = 451;
              goto LABEL_5;
            }
            if (v31 + v25 != *(void *)(a1 + 8)) {
              break;
            }
          }
          if (pwrite(*(_DWORD *)a1, *(const void **)(a1 + 80), v31, v25) != v31)
          {
            __int16 v9 = "writing chunk";
            __int16 v10 = 454;
            goto LABEL_5;
          }
          ++v24;
          v25 += v31;
          if (v24 >= *(unsigned int *)(a1 + 32)) {
            goto LABEL_56;
          }
        }
        __int16 v9 = "Invalid uncompressed chunk size";
        __int16 v10 = 452;
        goto LABEL_5;
      }
LABEL_56:
      if (fremovexattr(*(_DWORD *)a1, "com.apple.ResourceFork", 32) < 0)
      {
        int v11 = *__error();
        __int16 v9 = "Removing xattr";
        __int16 v10 = 459;
        goto LABEL_6;
      }
      if (fremovexattr(*(_DWORD *)a1, "com.apple.decmpfs", 32) < 0)
      {
        int v11 = *__error();
        __int16 v9 = "Removing xattr";
        __int16 v10 = 460;
        goto LABEL_6;
      }
    }
    uint64_t v12 = 0;
    goto LABEL_7;
  }
  __int16 v9 = "not enough bytes received";
  __int16 v10 = 325;
LABEL_5:
  int v11 = 0;
LABEL_6:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCStreamClose", v10, 86, v11, v9, a7, a8, v41);
  uint64_t v12 = 0xFFFFFFFFLL;
LABEL_7:
  free(*(void **)(a1 + 40));
  free(*(void **)(a1 + 64));
  free(*(void **)(a1 + 80));
  free(*(void **)(a1 + 88));
  free((void *)a1);
  return v12;
}

uint64_t ParallelCompressionAFSCGetMetadataFD(int a1, off_t *a2, unsigned int *a3, _DWORD *a4)
{
  memset(&v24, 0, sizeof(v24));
  if (fstat(a1, &v24))
  {
    char v8 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCGetMetadataFD", 488, 86, *v8, "fstat", v9, v10, v23);
    int v11 = 0;
LABEL_22:
    uint64_t v12 = 0xFFFFFFFFLL;
    goto LABEL_23;
  }
  if ((v24.st_flags & 0x20) != 0)
  {
    int v11 = (off_t *)malloc(0x1000uLL);
    if (v11)
    {
      unint64_t v13 = fgetxattr(a1, "com.apple.decmpfs", v11, 0x1000uLL, 0, 32);
      if ((v13 & 0x8000000000000000) != 0)
      {
        int v16 = "Missing decmpfs xattr";
        __int16 v17 = 504;
      }
      else if (v13 > 0xF)
      {
        if (*(_DWORD *)v11 == 1668116582)
        {
          unsigned int v19 = *((_DWORD *)v11 + 1);
          if (v19 > 0xE) {
            goto LABEL_27;
          }
          off_t v20 = v11[1];
          if (((1 << v19) & 0x2A88) != 0)
          {
            uint64_t v12 = 0;
            *a2 = v20;
            *a3 = v19;
            goto LABEL_5;
          }
          if (((1 << v19) & 0x5510) != 0)
          {
            *a2 = v20;
            *a3 = v19;
            unint64_t v21 = fgetxattr(a1, "com.apple.ResourceFork", 0, 0, 0, 32);
            if ((v21 & 0x8000000000000000) != 0)
            {
              int v16 = "Missing resource fork xattr";
              __int16 v17 = 532;
            }
            else
            {
              if (!HIDWORD(v21))
              {
                uint64_t v12 = 0;
                *a4 = v21;
                goto LABEL_23;
              }
              int v16 = "Invalid resource fork xattr";
              __int16 v17 = 533;
            }
          }
          else
          {
LABEL_27:
            int v23 = *((_DWORD *)v11 + 1);
            int v16 = "Invalid compression type %u in decmpfs xattr";
            __int16 v17 = 524;
          }
        }
        else
        {
          int v16 = "Invalid decmpfs xattr";
          __int16 v17 = 507;
        }
      }
      else
      {
        int v16 = "Truncated decmpfs xattr";
        __int16 v17 = 505;
      }
      int v18 = 0;
    }
    else
    {
      int v18 = *__error();
      int v16 = "malloc";
      __int16 v17 = 501;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCGetMetadataFD", v17, 86, v18, v16, v14, v15, v23);
    goto LABEL_22;
  }
  int v11 = 0;
  uint64_t v12 = 0;
  *a2 = v24.st_size;
  *a3 = -1;
LABEL_5:
  *a4 = 0;
LABEL_23:
  free(v11);
  return v12;
}

uint64_t ParallelCompressionAFSCGetMetadata(const char *a1, off_t *a2, unsigned int *a3, _DWORD *a4)
{
  char v7 = (char)a1;
  int v8 = open(a1, 0);
  if (v8 < 0)
  {
    unint64_t v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCGetMetadata", 550, 86, *v13, "open %s", v14, v15, v7);
    return 0xFFFFFFFFLL;
  }
  else
  {
    int v9 = v8;
    if ((ParallelCompressionAFSCGetMetadataFD(v8, a2, a3, a4) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCGetMetadata", 553, 86, 0, "retrieving AFSC metadata: %s", v10, v11, v7);
      uint64_t v12 = 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t v12 = 0;
    }
    close(v9);
  }
  return v12;
}

uint64_t ParallelCompressionAFSCFixupMetadata(const std::__fs::filesystem::path *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v213 = *MEMORY[0x263EF8340];
  unsigned int v195 = -1;
  u_int32_t v194 = 0;
  unint64_t v193 = 0;
  memset(&v192, 0, sizeof(v192));
  int v211 = 0;
  long long v209 = 0u;
  long long v210 = 0u;
  long long v207 = 0u;
  long long v208 = 0u;
  long long v205 = 0u;
  long long v206 = 0u;
  long long v203 = 0u;
  long long v204 = 0u;
  long long v201 = 0u;
  long long v202 = 0u;
  long long v199 = 0u;
  long long v200 = 0u;
  long long v197 = 0u;
  long long v198 = 0u;
  long long v196 = 0u;
  value[0] = 0;
  value[1] = 0;
  if ((unint64_t)__strlcpy_chk() >= 0x400)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 581, 86, 0, "Path too long: %s", v6, v7, (char)a1);
LABEL_5:
    int v17 = 0;
    int v18 = 0;
LABEL_134:
    long long v45 = 0;
    uint64_t v75 = 0;
    uint64_t v77 = 0;
    int v35 = -1;
LABEL_135:
    int v37 = -1;
    goto LABEL_136;
  }
  if ((unint64_t)__strlcat_chk() >= 0x400)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 582, 86, 0, "Path too long: %s", v15, v16, (char)a1);
    goto LABEL_5;
  }
  int v18 = (int *)malloc(0x100000uLL);
  if (!v18)
  {
    int v23 = *__error();
    unint64_t v21 = "malloc";
    __int16 v22 = 586;
LABEL_133:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v22, 86, v23, v21, v13, v14, v170);
    int v17 = 0;
    goto LABEL_134;
  }
  if (a2) {
    uint64_t v19 = a2;
  }
  else {
    uint64_t v19 = 4;
  }
  if ((v19 + 1) > 0xF) {
    goto LABEL_131;
  }
  int v20 = 1 << (v19 + 1);
  if ((v20 & 0x5511) != 0)
  {
    if (a3)
    {
      char v170 = a3;
      unint64_t v21 = "Invalid resource fork size request: %u";
      __int16 v22 = 605;
LABEL_132:
      int v23 = 0;
      goto LABEL_133;
    }
    goto LABEL_16;
  }
  if ((v20 & 0xAA20) == 0)
  {
LABEL_131:
    char v170 = v19;
    unint64_t v21 = "Invalid compression type request %d";
    __int16 v22 = 608;
    goto LABEL_132;
  }
LABEL_16:
  if ((ParallelCompressionAFSCGetMetadata((const char *)a1, (off_t *)&v193, &v195, &v194) & 0x80000000) != 0)
  {
LABEL_130:
    char v170 = (char)a1;
    unint64_t v21 = "obtain AFSC data: %s";
    __int16 v22 = 615;
    goto LABEL_132;
  }
  char v24 = 0;
  int v181 = 0;
  int v25 = 0;
  uint64_t v182 = v18 + 3;
  uint64_t v180 = (unint64_t *)(v18 + 66);
  int8x8_t v26 = (int8x8_t)vadd_s32(vdup_n_s32(a3), (int32x2_t)0xFFFFFECEFFFFFFCELL);
  int8x8_t v27 = vrev32_s8(v26);
  u_int32_t position = v26.i32[0];
  unsigned int v177 = bswap32(a3 - 310);
  uint64_t v28 = (int)v19 - 4;
  unsigned int v185 = (0x551u >> (v19 - 4)) & 1;
  while (1)
  {
    unint64_t v29 = v193;
    if (v193 >= 0xFA000001)
    {
      unint64_t v21 = "Invalid AFSC data";
      __int16 v22 = 616;
      goto LABEL_132;
    }
    char v187 = v24;
    if (v195 == v19)
    {
      if (!a3 || v194 == a3) {
        goto LABEL_152;
      }
      if ((v19 & 0x80000000) == 0) {
        goto LABEL_55;
      }
    }
    else if ((v19 & 0x80000000) == 0)
    {
      uint64_t v174 = v28;
      int v30 = 4;
      if (v19 > 0xE)
      {
        int v33 = v19;
      }
      else
      {
        int v31 = 1 << v19;
        if (((1 << v19) & 0x5510) != 0) {
          int v32 = 6;
        }
        else {
          int v32 = 4;
        }
        if ((v31 & 0x2A88) != 0) {
          int v30 = 4;
        }
        else {
          int v30 = v32;
        }
        if ((v31 & 0x2A88) != 0) {
          int v33 = v19 + 1;
        }
        else {
          int v33 = v19;
        }
      }
      int v34 = open((const char *)a1, 0);
      int v35 = v34;
      if ((v34 & 0x80000000) == 0)
      {
        if (!fstat(v34, &v192))
        {
          int v178 = v25;
          int v36 = mkstemp((char *)&__from);
          int v37 = v36;
          if (v36 < 0)
          {
            int v157 = __error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 664, 86, *v157, "mkstemp", v158, v159, v170);
            int v17 = 0;
            long long v45 = 0;
          }
          else
          {
            long long v45 = ParallelCompressionAFSCStreamOpen(v36, v29, v33, v30);
            if (v45)
            {
              uint64_t v183 = v19;
              int fd = v35;
              BOOL v188 = v18;
              uint64_t v46 = 0;
              unint64_t v47 = 0;
              uint64_t v48 = 0x100000;
              unint64_t v49 = 0x100000;
              while (1)
              {
                unint64_t v50 = v29 >= v49 ? v49 : v29;
                if (v49 - 0x100000 >= v29) {
                  break;
                }
                int64_t v51 = v50 + v46;
                ssize_t v52 = read(fd, v188, v50 + v46);
                if (v52 < 0)
                {
                  int v126 = *__error();
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 675, 86, v126, "read: %s", v127, v128, (char)a1);
                  goto LABEL_149;
                }
                if (v52 < v51)
                {
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 676, 86, 0, "truncated read: %s", v56, v57, (char)a1);
LABEL_149:
                  int v17 = 0;
LABEL_150:
                  uint64_t v75 = 0;
                  uint64_t v77 = 0;
                  int v18 = v188;
                  goto LABEL_151;
                }
                v47 += 0x100000;
                uint64_t v58 = ParallelCompressionAFSCStreamWrite((uint64_t)v45, (uint64_t)v188, v51, v53, v54, v55, v56, v57);
                v49 += 0x100000;
                v46 -= 0x100000;
                if (v29 >= v47) {
                  unint64_t v59 = v47;
                }
                else {
                  unint64_t v59 = v29;
                }
                v48 -= 0x100000;
                if (v58 < (uint64_t)(v59 + v48))
                {
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 678, 86, 0, "write to stream failed: %s", v43, v44, (char)a1);
                  goto LABEL_149;
                }
              }
              if ((ParallelCompressionAFSCStreamClose((uint64_t)v45, v38, v39, v40, v41, v42, v43, v44) & 0x80000000) != 0)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 683, 86, 0, "Stream close error", v93, v94, v170);
                int v17 = 0;
                long long v45 = 0;
                goto LABEL_150;
              }
              fchown(v37, v192.st_uid, v192.st_gid);
              fchmod(v37, v192.st_mode & 0xFFF);
              close(fd);
              close(v37);
              rename(&__from, a1, v95);
              int v97 = v96;
              unlink((const char *)&__from);
              int v18 = v188;
              uint64_t v19 = v183;
              uint64_t v28 = v174;
              int v25 = v178;
              if ((v97 & 0x80000000) == 0) {
                goto LABEL_55;
              }
              int v23 = *__error();
              char v170 = (char)a1;
              unint64_t v21 = "rename: %s";
              __int16 v22 = 694;
              goto LABEL_133;
            }
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 667, 86, 0, "creating compression stream %s", v43, v44, (char)a1);
            int v17 = 0;
          }
          uint64_t v75 = 0;
          uint64_t v77 = 0;
          goto LABEL_136;
        }
        int v141 = *__error();
        char v170 = (char)a1;
        size_t v144 = "stat: %s";
        __int16 v145 = 661;
        goto LABEL_170;
      }
      int v146 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 660, 86, v146, "open: %s", v147, v148, (char)a1);
LABEL_171:
      int v17 = 0;
      long long v45 = 0;
      uint64_t v75 = 0;
      uint64_t v77 = 0;
      goto LABEL_135;
    }
    int v60 = open((const char *)a1, 9);
    int v35 = v60;
    if (v60 < 0)
    {
      int v135 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 629, 86, v135, "open %s", v136, v137, (char)a1);
      goto LABEL_171;
    }
    if (write(v60, 0, 0) < 0)
    {
      int v141 = *__error();
      size_t v144 = "write";
      __int16 v145 = 630;
LABEL_170:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v145, 86, v141, v144, v142, v143, v170);
      goto LABEL_171;
    }
    if (close(v35) < 0)
    {
      int v23 = *__error();
      unint64_t v21 = "close";
      __int16 v22 = 631;
      goto LABEL_133;
    }
    unsigned int v195 = -1;
    u_int32_t v194 = 0;
LABEL_55:
    if ((ParallelCompressionAFSCGetMetadata((const char *)a1, (off_t *)&v193, &v195, &v194) & 0x80000000) != 0)
    {
      char v170 = (char)a1;
      unint64_t v21 = "obtain AFSC data: %s";
      __int16 v22 = 699;
      goto LABEL_132;
    }
    if (v195 != v19)
    {
      unint64_t v21 = "Couldn't convert to requested compression type";
      __int16 v22 = 700;
      goto LABEL_132;
    }
    if (!a3) {
      goto LABEL_152;
    }
    u_int32_t v61 = v194;
    unsigned int v62 = a3 - v194;
    if (a3 == v194) {
      goto LABEL_152;
    }
    if (a3 >= v194) {
      break;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 711, 86, "Can't shrink resource fork: %s (current %u, target %u)", v12, v13, v14, (char)a1);
LABEL_61:
    if (v187)
    {
      unint64_t v21 = "Second pass fixup failed: %s, compression_type=%d (expected %d), resource_fork_size=%u (expected %u)";
      char v170 = (char)a1;
      __int16 v22 = 852;
      goto LABEL_132;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 859, 86, "First pass fixup failed: %s, compression_type=%d (expected %d), resource_fork_size=%u (expected %u)", v12, v13, v14, (char)a1);
    int v63 = open((const char *)a1, 9);
    int v35 = v63;
    if (v63 < 0)
    {
      int v138 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 864, 86, v138, "open %s", v139, v140, (char)a1);
      goto LABEL_171;
    }
    if (write(v63, 0, 0) < 0)
    {
      int v141 = *__error();
      size_t v144 = "write";
      __int16 v145 = 865;
      goto LABEL_170;
    }
    if (close(v35) < 0)
    {
      int v23 = *__error();
      unint64_t v21 = "close";
      __int16 v22 = 866;
      goto LABEL_133;
    }
    unsigned int v195 = -1;
    u_int32_t v194 = 0;
    int v64 = ParallelCompressionAFSCGetMetadata((const char *)a1, (off_t *)&v193, &v195, &v194);
    char v24 = 1;
    if (v64 < 0) {
      goto LABEL_130;
    }
  }
  if (v28 > 0xA || !v185)
  {
    char v170 = v19;
    unint64_t v21 = "Invalid compression type %u";
    __int16 v22 = 722;
    goto LABEL_132;
  }
  uint64_t v184 = v19;
  int v186 = dword_2106D3EE8[v28];
  int v65 = open((const char *)a1, 0);
  int v66 = v65;
  if (v65 < 0)
  {
    int v149 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 727, 86, v149, "open: %s", v150, v151, (char)a1);
LABEL_176:
    int v17 = 0;
    long long v45 = 0;
    uint64_t v75 = 0;
    uint64_t v77 = 0;
    int v37 = -1;
    int v35 = v66;
    goto LABEL_136;
  }
  if (fstat(v65, &v192))
  {
    int v152 = *__error();
    uint64_t v155 = "fstat";
    __int16 v156 = 728;
LABEL_175:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v156, 86, v152, v155, v153, v154, v170);
    goto LABEL_176;
  }
  if (fgetxattr(v66, "com.apple.decmpfs", value, 0x10uLL, 0, 32) != 16)
  {
    int v152 = *__error();
    uint64_t v155 = "Reading decmpfs";
    __int16 v156 = 729;
    goto LABEL_175;
  }
  int fd = v66;
  if (fchflags(v66, v192.st_flags & 0xFFFFFFDF) < 0)
  {
    int v121 = *__error();
    unint64_t v124 = "fchflags UF_COMPRESSED";
    __int16 v125 = 730;
LABEL_145:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v125, 86, v121, v124, v122, v123, v170);
    int v17 = 0;
    long long v45 = 0;
    uint64_t v75 = 0;
    uint64_t v77 = 0;
    goto LABEL_146;
  }
  int v179 = v25;
  unint64_t v67 = v29 + 0xFFFF;
  unint64_t v173 = (v29 + 0xFFFF) >> 16;
  uint64_t v175 = v28;
  unsigned int v68 = v61 + 0x100000;
  int v69 = -v61;
  u_int32_t v70 = v61;
  while (1)
  {
    unsigned int v71 = a3 >= v68 ? v68 : a3;
    if (v70 >= a3) {
      break;
    }
    size_t v72 = v71 + v69;
    if (v70 == v61) {
      __memset_chk();
    }
    int v73 = fsetxattr(fd, "com.apple.ResourceFork", v18, v72, v70, 0);
    v68 += 0x100000;
    v69 -= 0x100000;
    v70 += 0x100000;
    if (v73)
    {
      int v121 = *__error();
      unint64_t v124 = "Expanding resource fork";
      __int16 v125 = 738;
      goto LABEL_145;
    }
  }
  int v74 = v173;
  uint64_t v75 = malloc((4 * v173 + 4));
  size_t size = (4 * v173 + 4);
  int v76 = (int *)malloc(size);
  uint64_t v77 = v76;
  if (v75) {
    BOOL v78 = v76 == 0;
  }
  else {
    BOOL v78 = 1;
  }
  if (v78)
  {
    int v160 = *__error();
    int v163 = "malloc";
    __int16 v164 = 744;
    goto LABEL_183;
  }
  uint64_t v171 = (v67 >> 16);
  if (v184 != 4)
  {
    int v35 = fd;
    size_t v89 = (4 * v173 + 4);
    if (fgetxattr(fd, "com.apple.ResourceFork", v75, size, 0, 32) == size)
    {
LABEL_98:
      unint64_t v189 = v18;
      memcpy(v77, v75, v89);
      v77[v173] = v75[v173] + v62;
      while (v62 && v74)
      {
        uint64_t v98 = (v74 - 1);
        u_int32_t v99 = v75[v98];
        size_t v100 = v75[v74] - v99;
        if (fgetxattr(v35, "com.apple.ResourceFork", v189, v100, v99, 32) != v100)
        {
          size_t v129 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 777, 86, *v129, "Reading chunk", v130, v131, v170);
          int v17 = 0;
          long long v45 = 0;
          int v37 = -1;
          int v18 = v189;
          goto LABEL_136;
        }
        unsigned int v101 = 0x10000 - v100;
        if (v186 == *(unsigned __int8 *)v189 || v100 > 0x10000) {
          unsigned int v101 = 0;
        }
        if (v62 >= v101) {
          size_t v103 = v101;
        }
        else {
          size_t v103 = v62;
        }
        if (v103) {
          bzero((char *)v189 + v100, v103);
        }
        size_t v104 = (v103 + v100);
        u_int32_t v105 = v77[v74] - v104;
        v77[v98] = v105;
        v62 -= v103;
        int v35 = fd;
        --v74;
        if (fsetxattr(fd, "com.apple.ResourceFork", v189, v104, v105, 0))
        {
          uint64_t v132 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 791, 86, *v132, "Writing chunk", v133, v134, v170);
          int v17 = 0;
          long long v45 = 0;
          int v37 = -1;
          int v18 = v189;
          goto LABEL_136;
        }
      }
      uint64_t v19 = v184;
      if (v184 == 4)
      {
        int v18 = v189;
        int v25 = v179;
        *unint64_t v189 = v179;
        *(int8x8_t *)(v189 + 1) = v27;
        long long v106 = v209;
        *((_OWORD *)v182 + 12) = v208;
        *((_OWORD *)v182 + 13) = v106;
        *((_OWORD *)v182 + 14) = v210;
        v182[60] = v211;
        long long v107 = v205;
        *((_OWORD *)v182 + 8) = v204;
        *((_OWORD *)v182 + 9) = v107;
        long long v108 = v207;
        *((_OWORD *)v182 + 10) = v206;
        *((_OWORD *)v182 + 11) = v108;
        long long v109 = v201;
        *((_OWORD *)v182 + 4) = v200;
        *((_OWORD *)v182 + 5) = v109;
        long long v110 = v203;
        *((_OWORD *)v182 + 6) = v202;
        *((_OWORD *)v182 + 7) = v110;
        long long v111 = v197;
        *(_OWORD *)uint64_t v182 = v196;
        *((_OWORD *)v182 + 1) = v111;
        long long v112 = v199;
        *((_OWORD *)v182 + 2) = v198;
        *((_OWORD *)v182 + 3) = v112;
        v189[64] = v177;
        v189[65] = v181;
        uint64_t v113 = v171;
        if (v173)
        {
          unint64_t v114 = v77 + 1;
          int v115 = *v77;
          uint64_t v116 = v180;
          do
          {
            int v117 = *v114++;
            *v116++ = (v115 - 260) | ((unint64_t)(v117 - v115) << 32);
            int v115 = v117;
            --v113;
          }
          while (v113);
        }
        if (fsetxattr(v35, "com.apple.ResourceFork", v189, (8 * v173) + 264, 0, 0))
        {
          int v165 = *__error();
          uint64_t v168 = "Writing resource fork header";
          __int16 v169 = 817;
          goto LABEL_189;
        }
        if (fsetxattr(v35, "com.apple.ResourceFork", &old_resource_fork_map, 0x32uLL, position, 0))
        {
          int v165 = *__error();
          uint64_t v168 = "Writing resource map";
          __int16 v169 = 820;
          goto LABEL_189;
        }
      }
      else
      {
        int v18 = v189;
        int v25 = v179;
        if (fsetxattr(v35, "com.apple.ResourceFork", v77, size, 0, 0))
        {
          int v165 = *__error();
          uint64_t v168 = "Writing chunk sizes";
          __int16 v169 = 827;
          goto LABEL_189;
        }
      }
      if (fsetxattr(v35, "com.apple.decmpfs", value, 0x10uLL, 0, 0))
      {
        int v165 = *__error();
        uint64_t v168 = "Writing decmpfs";
        __int16 v169 = 831;
      }
      else
      {
        if ((fchflags(v35, v192.st_flags | 0x20) & 0x80000000) == 0)
        {
          close(v35);
          free(v75);
          free(v77);
          if ((ParallelCompressionAFSCGetMetadata((const char *)a1, (off_t *)&v193, &v195, &v194) & 0x80000000) == 0)
          {
            if (v195 != v184)
            {
              uint64_t v28 = v175;
              goto LABEL_61;
            }
            uint64_t v28 = v175;
            if (v194 != a3) {
              goto LABEL_61;
            }
LABEL_152:
            if (v187) {
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 876, 86, "Second pass fixup succeeded: %s", v12, v13, v14, (char)a1);
            }
            long long v45 = 0;
            uint64_t v75 = 0;
            uint64_t v77 = 0;
            int v35 = -1;
            int v17 = 1;
            goto LABEL_135;
          }
          char v170 = (char)a1;
          unint64_t v21 = "obtain AFSC data: %s";
          __int16 v22 = 840;
          goto LABEL_132;
        }
        int v165 = *__error();
        uint64_t v168 = "fchflags UF_COMPRESSED";
        __int16 v169 = 832;
      }
    }
    else
    {
      int v165 = *__error();
      uint64_t v168 = "Reading chunk sizes";
      __int16 v169 = 763;
    }
LABEL_189:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v169, 86, v165, v168, v166, v167, v170);
    int v17 = 0;
    long long v45 = 0;
    goto LABEL_135;
  }
  if (fgetxattr(fd, "com.apple.ResourceFork", v18, (8 * v173) + 264, 0, 32) == (8 * v173)
                                                                                              + 264)
  {
    int v79 = *v18;
    long long v80 = *((_OWORD *)v182 + 13);
    long long v208 = *((_OWORD *)v182 + 12);
    long long v209 = v80;
    long long v210 = *((_OWORD *)v182 + 14);
    int v211 = v182[60];
    long long v81 = *((_OWORD *)v182 + 9);
    long long v204 = *((_OWORD *)v182 + 8);
    long long v205 = v81;
    long long v82 = *((_OWORD *)v182 + 11);
    long long v206 = *((_OWORD *)v182 + 10);
    long long v207 = v82;
    long long v83 = *((_OWORD *)v182 + 5);
    long long v200 = *((_OWORD *)v182 + 4);
    long long v201 = v83;
    long long v84 = *((_OWORD *)v182 + 7);
    long long v202 = *((_OWORD *)v182 + 6);
    long long v203 = v84;
    long long v85 = *((_OWORD *)v182 + 1);
    long long v196 = *(_OWORD *)v182;
    long long v197 = v85;
    long long v86 = *((_OWORD *)v182 + 3);
    long long v198 = *((_OWORD *)v182 + 2);
    long long v199 = v86;
    int v181 = v18[65];
    int v35 = fd;
    int v179 = v79;
    if (v173)
    {
      uint64_t v87 = v75 + 1;
      uint64_t v88 = (v67 >> 16);
      size_t v89 = (4 * v173 + 4);
      int64x2_t v90 = v180;
      do
      {
        int v91 = *(_DWORD *)v90;
        int v92 = *((_DWORD *)v90++ + 1);
        v91 += 260;
        *(v87 - 1) = v91;
        *v87++ = v91 + v92;
        --v88;
      }
      while (v88);
    }
    else
    {
      size_t v89 = 4;
    }
    goto LABEL_98;
  }
  int v160 = *__error();
  int v163 = "Reading chunk sizes";
  __int16 v164 = 749;
LABEL_183:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v164, 86, v160, v163, v161, v162, v170);
  int v17 = 0;
  long long v45 = 0;
LABEL_146:
  int v37 = -1;
LABEL_151:
  int v35 = fd;
LABEL_136:
  if ((ParallelCompressionAFSCStreamClose((uint64_t)v45, v8, v9, v10, v11, v12, v13, v14) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 877, 86, 0, "Stream close error", v118, v119, v170);
    int v17 = 0;
  }
  if ((v35 & 0x80000000) == 0) {
    close(v35);
  }
  if ((v37 & 0x80000000) == 0)
  {
    close(v37);
    unlink((const char *)&__from);
  }
  free(v18);
  free(v75);
  free(v77);
  if (v17) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t ParallelCompressionAFSCUseMaxEmbeddedSize(const char *a1)
{
  int v2 = 1;
  return fsctl(a1, 0xC0044A36uLL, &v2, 0);
}

uint64_t ParallelCompressionAFSCCompress(const char *a1, int a2)
{
  unint64_t v61 = 0;
  unsigned int v60 = -1;
  if ((ParallelCompressionAFSCGetMetadata(a1, (off_t *)&v61, &v60, &v59) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 907, 86, 0, "looking up AFSC data: %s", v4, v5, (char)a1);
    return 0xFFFFFFFFLL;
  }
  unint64_t v6 = v61;
  if (!v61) {
    return 0;
  }
  if (v60 == -1)
  {
    if (!a2) {
      return 0;
    }
    int v17 = malloc(0x10000uLL);
    if (v17)
    {
      int v18 = open(a1, 2);
      if ((v18 & 0x80000000) == 0)
      {
        int v19 = v18;
        int v20 = ParallelCompressionAFSCStreamOpen(v18, v6, 0, 0);
        if (v20)
        {
          uint64_t v28 = (uint64_t)v20;
          uint64_t v29 = 0;
          unint64_t v30 = 0;
          uint64_t v31 = 0x10000;
          unint64_t v32 = 0x10000;
          while (1)
          {
            if (v6 >= v32) {
              unint64_t v33 = v32;
            }
            else {
              unint64_t v33 = v6;
            }
            if (v32 - 0x10000 >= v6)
            {
              int v51 = 1;
              goto LABEL_43;
            }
            unint64_t v34 = v33 + v29;
            ssize_t v35 = read(v19, v17, v33 + v29);
            if (v35 < 0)
            {
              int v52 = *__error();
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 950, 86, v52, "read: %s", v53, v54, (char)a1);
              goto LABEL_42;
            }
            if (v34 != v35)
            {
              char v58 = (char)a1;
              uint64_t v41 = "truncated read: %s";
              __int16 v42 = 951;
              goto LABEL_41;
            }
            uint64_t v39 = ParallelCompressionAFSCStreamWrite(v28, (uint64_t)v17, v34, v36, v37, v38, v26, v27);
            if (v39 < 0) {
              break;
            }
            v30 += 0x10000;
            v32 += 0x10000;
            v29 -= 0x10000;
            if (v6 >= v30) {
              unint64_t v40 = v30;
            }
            else {
              unint64_t v40 = v6;
            }
            v31 -= 0x10000;
            if (v40 + v31 != v39)
            {
              char v58 = (char)a1;
              uint64_t v41 = "truncated write: %s";
              __int16 v42 = 954;
              goto LABEL_41;
            }
          }
          char v58 = (char)a1;
          uint64_t v41 = "Stream write failed: %s";
          __int16 v42 = 953;
LABEL_41:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", v42, 86, 0, v41, v26, v27, v58);
LABEL_42:
          int v51 = 0;
LABEL_43:
          if ((ParallelCompressionAFSCStreamClose(v28, v21, v22, v23, v24, v25, v26, v27) & 0x80000000) == 0) {
            goto LABEL_46;
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 956, 86, 0, "AFSC compression failed: %s", v55, v56, (char)a1);
        }
        else
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 942, 86, 0, "creating AFSC stream: %s", v26, v27, (char)a1);
        }
        int v51 = 0;
LABEL_46:
        close(v19);
LABEL_47:
        free(v17);
        if (v51) {
          return 0;
        }
        else {
          return 0xFFFFFFFFLL;
        }
      }
      int v46 = *__error();
      char v57 = (char)a1;
      unint64_t v49 = "open: %s";
      __int16 v50 = 940;
    }
    else
    {
      int v46 = *__error();
      unint64_t v49 = "malloc";
      __int16 v50 = 938;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", v50, 86, v46, v49, v47, v48, v57);
    int v51 = 0;
    goto LABEL_47;
  }
  if (a2) {
    return 0;
  }
  int v7 = open(a1, 9);
  if (v7 < 0)
  {
    int v43 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 921, 86, v43, "open: %s", v44, v45, (char)a1);
    return 0xFFFFFFFFLL;
  }
  int v8 = v7;
  ssize_t v9 = write(v7, 0, 0);
  if (v9 < 0)
  {
    uint64_t v10 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 922, 86, *v10, "write: %s", v11, v12, (char)a1);
  }
  if (close(v8) < 0)
  {
    uint64_t v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 923, 86, *v13, "close: %s", v14, v15, (char)a1);
  }
  return v9 >> 63;
}

uint64_t fullReplacementBXPatch5(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  int v34 = 0;
  uint64_t v12 = *(void *)(a1 + 32);
  if (a5 >= 1) {
    fwrite("Full replacement patch\n", 0x17uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  if (v12 + 60 <= a2)
  {
    if (v12 + 60 < a2) {
      fwrite("Extra bytes in patch (ignored)", 0x1EuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    }
    uint64_t v14 = (char *)malloc(0x20000uLL);
    if (v14)
    {
      uint64_t v17 = ILowMemoryDecoderStreamCreateWithBuffer(a1 + 60, v12, 0x20000uLL);
      if (v17)
      {
        int v18 = (CC_SHA1_CTX *)OSHA1StreamCreate(a3, 0, a4);
        if (v18)
        {
          int v19 = v18;
          unint64_t v20 = *(void *)(a1 + 16);
          if (v20)
          {
            unint64_t v21 = 0;
            while (1)
            {
              unint64_t v22 = v20 - v21;
              if (v22 >= 0x20000) {
                size_t v23 = 0x20000;
              }
              else {
                size_t v23 = v22;
              }
              if (ILowMemoryDecoderStreamRead(v17, v14, v23) != v23)
              {
                uint64_t v26 = "reading from payload stream";
                __int16 v27 = 62;
                goto LABEL_32;
              }
              if (OSHA1StreamWrite(v19, v14, v23) != v23) {
                break;
              }
              v21 += v23;
              unint64_t v20 = *(void *)(a1 + 16);
              if (v21 >= v20) {
                goto LABEL_18;
              }
            }
            uint64_t v26 = "writing to digest stream";
            __int16 v27 = 64;
          }
          else
          {
LABEL_18:
            OSHA1StreamDestroy(v19, (unsigned __int8 *)&v32);
            if (v32 == *(void *)(a1 + 40)
              && v33 == *(void *)(a1 + 48)
              && v34 == (unint64_t)*(unsigned int *)(a1 + 56))
            {
              uint64_t v13 = 0;
LABEL_34:
              free(v14);
              ILowMemoryDecoderStreamDestroy(v17);
              return v13;
            }
            uint64_t v26 = "Invalid output digest after patch application";
            __int16 v27 = 71;
          }
        }
        else
        {
          uint64_t v26 = "Digest stream init";
          __int16 v27 = 52;
        }
      }
      else
      {
        uint64_t v26 = "Payload stream init";
        __int16 v27 = 51;
      }
LABEL_32:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"fullReplacementBXPatch5", v27, 42, 0, v26, v15, v16, v32);
    }
    else
    {
      uint64_t v28 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"fullReplacementBXPatch5", 50, 42, *v28, "malloc", v29, v30, v32);
      uint64_t v17 = 0;
    }
    uint64_t v13 = 0xFFFFFFFFLL;
    goto LABEL_34;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"fullReplacementBXPatch5", 45, 42, 0, "Missing bytes in patch", a7, a8, v32);
  return 0xFFFFFFFFLL;
}

uint64_t BXDiff5GetPatchInfo(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 < 8) {
    return 0xFFFFFFFFLL;
  }
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 >= 0x3C && *(void *)a1 == 0x3035464649445842)
  {
    uint64_t result = 0;
    *(void *)a3 = *(void *)(a1 + 16);
    int v5 = *(_DWORD *)(a1 + 12) & 1;
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 8) == 0;
    *(_DWORD *)(a3 + 12) = v5;
  }
  return result;
}

uint64_t BXPatch5(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t (*a5)(uint64_t, void *, uint64_t), uint64_t a6, int a7)
{
  v8[0] = a1;
  v8[1] = a2;
  return BXPatch5StreamWithFlags((uint64_t (*)(uint64_t, void *, uint64_t, unint64_t))BXPatch5WithFlagsBufferStreamPRead, (uint64_t)v8, a2, a3, a4, a5, a6, a7 > 0);
}

uint64_t BXPatch5WithFlags(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t (*a5)(uint64_t, void *, uint64_t), uint64_t a6, uint64_t a7)
{
  v8[0] = a1;
  v8[1] = a2;
  return BXPatch5StreamWithFlags((uint64_t (*)(uint64_t, void *, uint64_t, unint64_t))BXPatch5WithFlagsBufferStreamPRead, (uint64_t)v8, a2, a3, a4, a5, a6, a7);
}

uint64_t BXPatch5StreamWithFlags(uint64_t (*a1)(uint64_t, void *, uint64_t, unint64_t), uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t (*a6)(uint64_t, void *, uint64_t), uint64_t a7, uint64_t a8)
{
  uint64_t v157 = *MEMORY[0x263EF8340];
  if (a5 <= 0x3B)
  {
    int v8 = "Invalid patch size";
    __int16 v9 = 264;
    goto LABEL_50;
  }
  if (*(void *)a4 != 0x3035464649445842)
  {
    int v8 = "Invalid patch header";
    __int16 v9 = 265;
    goto LABEL_50;
  }
  unsigned int v12 = *(_DWORD *)(a4 + 8);
  unint64_t v13 = 28 * v12 + 60;
  if (v13 > a5)
  {
    int v8 = "Invalid patch size";
    __int16 v9 = 269;
    goto LABEL_50;
  }
  int v16 = a8 & 1;
  uint64_t v17 = *(void *)(a4 + 24);
  BOOL v18 = __CFADD__(v13, v17);
  uint64_t v19 = v13 + v17;
  if (v18) {
    uint64_t v19 = -1;
  }
  if (!v12)
  {
    uint64_t v39 = *(void *)(a4 + 32);
    BOOL v18 = __CFADD__(v19, v39);
    unint64_t v40 = v19 + v39;
    if (v18) {
      unint64_t v40 = -1;
    }
    if (v40 <= a5)
    {
      return fullReplacementBXPatch5(a4, a5, (uint64_t)a6, a7, a8 & 1, (uint64_t)a6, a7, a8);
    }
    goto LABEL_42;
  }
  uint64_t v23 = *(unsigned int *)(a4 + 8);
  uint64_t v24 = (uint64_t *)(a4 + 60);
  do
  {
    uint64_t v25 = *v24;
    uint64_t v24 = (uint64_t *)((char *)v24 + 28);
    BOOL v18 = __CFADD__(v19, v25);
    v19 += v25;
    if (v18) {
      uint64_t v19 = -1;
    }
    --v23;
  }
  while (v23);
  uint64_t v26 = *(void *)(a4 + 32);
  BOOL v18 = __CFADD__(v19, v26);
  unint64_t v27 = v19 + v26;
  if (v18) {
    unint64_t v27 = -1;
  }
  if (v27 > a5)
  {
LABEL_42:
    int v8 = "Invalid patch size";
    __int16 v9 = 278;
    goto LABEL_50;
  }
  uint64_t v151 = (uint64_t *)(a4 + 60);
  *(void *)md = 0;
  uint64_t v155 = 0;
  int v156 = 0;
  memset(&c, 0, sizeof(c));
  uint64_t v28 = malloc(0x40000uLL);
  if (!v28)
  {
    int v42 = *__error();
    int v43 = "malloc";
    __int16 v44 = 156;
LABEL_48:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"getStreamSHA1Digest", v44, 42, v42, v43, v32, v33, v130);
    free(v28);
    goto LABEL_49;
  }
  int v149 = v16;
  CC_SHA1_Deprecated_Init(&c);
  unint64_t v29 = 0;
  if (a3)
  {
    while (1)
    {
      uint64_t v30 = v29 + 0x40000 <= a3 ? 0x40000 : a3 - v29;
      uint64_t v31 = a1(a2, v28, v30, v29);
      if (v31 <= 0) {
        break;
      }
      uint64_t v34 = v31;
      CC_SHA1_Deprecated_Update(&c, v28, v31);
      v29 += v34;
      if (v29 >= a3) {
        goto LABEL_27;
      }
    }
    int v43 = "inProc read";
    __int16 v44 = 165;
    int v42 = 0;
    goto LABEL_48;
  }
LABEL_27:
  CC_SHA1_Deprecated_Final(md, &c);
  free(v28);
  if (v29 != a3)
  {
LABEL_49:
    int v8 = "Input digest failed";
    __int16 v9 = 285;
    goto LABEL_50;
  }
  if (!v149)
  {
    uint64_t v36 = a4 + 40;
    if (*(void *)md != *(void *)(a4 + 40)
      || v155 != *(void *)(a4 + 48)
      || v156 != (unint64_t)*(unsigned int *)(a4 + 56))
    {
      goto LABEL_58;
    }
LABEL_78:
    if ((copyStream(a1, a2, a3, a6, a7) & 0x80000000) == 0) {
      return 0;
    }
    int v8 = "Output copy failed\n";
    __int16 v9 = 293;
LABEL_50:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v9, 42, 0, v8, a7, a8, v130);
    return 0xFFFFFFFFLL;
  }
  uint64_t v45 = (FILE **)MEMORY[0x263EF8348];
  fprintf((FILE *)*MEMORY[0x263EF8348], "Input variants in patch: %u\n", *(_DWORD *)(a4 + 8));
  uint64_t v36 = a4 + 40;
  if (*(void *)md == *(void *)(a4 + 40)
    && v155 == *(void *)(a4 + 48)
    && v156 == (unint64_t)*(unsigned int *)(a4 + 56))
  {
    fwrite("No-op patch matching, writing input\n", 0x24uLL, 1uLL, *v45);
    goto LABEL_78;
  }
LABEL_58:
  uint64_t v48 = *(unsigned int *)(a4 + 8);
  if (!v48)
  {
LABEL_68:
    int v8 = "Input doesn't match any of the expected patch inputs";
    __int16 v9 = 310;
    goto LABEL_50;
  }
  uint64_t v49 = 0;
  uint64_t v50 = a4 + 68;
  while (1)
  {
    BOOL v51 = *(void *)md == *(void *)v50 && v155 == *(void *)(v50 + 8);
    if (v51 && v156 == (unint64_t)*(unsigned int *)(v50 + 16)) {
      break;
    }
    ++v49;
    v50 += 28;
    if (v48 == v49) {
      goto LABEL_68;
    }
  }
  uint64_t v146 = v49;
  if (v149)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "Patch matching entry %u\n", v49);
    uint64_t v49 = v146;
    uint64_t v48 = *(unsigned int *)(a4 + 8);
  }
  uint64_t v135 = v36;
  uint64_t v53 = v151;
  uint64_t v142 = (uint64_t)v151 + 28 * v48;
  uint64_t v144 = *(void *)(a4 + 24);
  uint64_t v54 = v142 + v144;
  if (v48)
  {
    uint64_t v55 = 0;
    uint64_t v56 = 0;
    do
    {
      if (v49 == v55) {
        uint64_t v56 = v54;
      }
      uint64_t v57 = *v53;
      uint64_t v53 = (uint64_t *)((char *)v53 + 28);
      v54 += v57;
      ++v55;
    }
    while (v48 != v55);
  }
  else
  {
    uint64_t v56 = 0;
  }
  uint64_t v138 = *(void *)(a4 + 32);
  uint64_t v140 = *(void *)(v50 - 8);
  if (v54 + v138 - a4 != a5)
  {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 331, 42, "Warning: extra bytes in patch (ignored)\n", v35, a7, a8, v130);
    LODWORD(v48) = *(_DWORD *)(a4 + 8);
  }
  unint64_t v137 = *(void *)(a4 + 16);
  uint64_t v58 = 8 * (v48 + 2);
  int v152 = (char *)malloc(0x20000uLL);
  int v59 = malloc(0x20000uLL);
  size_t v136 = v58;
  size_t v60 = v58;
  unint64_t v61 = v152;
  uint64_t v150 = malloc(v60);
  enterThreadErrorContext((uint64_t)v150, v62, v63, v64, v65, v66, v67, v68, v130);
  uint64_t v148 = v59;
  if (!v59 || !v152 || !v150)
  {
    int v112 = *__error();
    uint64_t v113 = "malloc";
    __int16 v114 = 351;
LABEL_135:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v114, 42, v112, v113, v69, v70, v131);
    uint64_t v115 = 0;
    uint64_t v73 = 0;
    uint64_t v116 = 0;
    long long v109 = 0;
    long long v110 = 0;
    unsigned int v111 = -1;
    int v91 = v148;
    goto LABEL_157;
  }
  uint64_t v145 = ILowMemoryDecoderStreamCreateWithBuffer(v142, v144, 0x20000uLL);
  if (!v145)
  {
    uint64_t v113 = "Control stream init";
    __int16 v114 = 352;
    int v112 = 0;
    goto LABEL_135;
  }
  uint64_t v73 = ILowMemoryDecoderStreamCreateWithBuffer(v56, v140, 0x20000uLL);
  if (!v73)
  {
    int v117 = "Diff stream init";
    __int16 v118 = 353;
LABEL_138:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v118, 42, 0, v117, v71, v72, v131);
    uint64_t v116 = 0;
    long long v109 = 0;
    long long v110 = 0;
    unsigned int v111 = -1;
    int v91 = v148;
    uint64_t v115 = v145;
    goto LABEL_157;
  }
  uint64_t v143 = ILowMemoryDecoderStreamCreateWithBuffer(v54, v138, 0x20000uLL);
  if (!v143)
  {
    int v117 = "Archive stream init";
    __int16 v118 = 354;
    goto LABEL_138;
  }
  int v74 = (CC_SHA1_CTX *)OSHA1StreamCreate((uint64_t)a6, 0, a7);
  if (!v74)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 355, 42, 0, "Digest stream init", v75, v76, v131);
    long long v109 = 0;
    long long v110 = 0;
    unsigned int v111 = -1;
    int v91 = v148;
    uint64_t v115 = v145;
LABEL_143:
    uint64_t v116 = v143;
    goto LABEL_157;
  }
  uint64_t v139 = v73;
  uint64_t v134 = v74;
  int v141 = OBufferedStreamCreate((uint64_t)OSHA1StreamWrite, (uint64_t)OSHA1StreamAbort, (uint64_t)v74, 0x20000uLL);
  if (!v141)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 356, 42, 0, "OBufferedStreamCreate", v82, v83, v131);
    long long v109 = 0;
    unsigned int v111 = -1;
    unint64_t v61 = v152;
    int v91 = v148;
    uint64_t v116 = v143;
    uint64_t v115 = v145;
    goto LABEL_156;
  }
  if (!v137)
  {
LABEL_125:
    OBufferedStreamDestroy((void ***)v141, v77, v78, v79, v80, v81, v82, v83);
    OSHA1StreamDestroy(v134, md);
    if (*(void *)md == *(void *)v135
      && v155 == *(void *)(v135 + 8)
      && v156 == (unint64_t)*(unsigned int *)(v135 + 16))
    {
      long long v109 = 0;
      long long v110 = 0;
      unsigned int v111 = 0;
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 421, 42, 0, "Invalid output digest after patch application", v105, v106, v131);
      long long v109 = 0;
      long long v110 = 0;
      unsigned int v111 = -1;
    }
    unint64_t v61 = v152;
    int v91 = v148;
    uint64_t v115 = v145;
    uint64_t v73 = v139;
    goto LABEL_143;
  }
  unint64_t v84 = 0;
  uint64_t v85 = 0;
  uint64_t v133 = (v146 + 2);
  while (1)
  {
    if (ILowMemoryDecoderStreamRead(v145, (char *)v150, v136) != v136)
    {
      int v121 = "reading from control stream";
      __int16 v122 = 362;
      goto LABEL_153;
    }
    uint64_t v86 = *((void *)v150 + 1);
    if (*(uint64_t *)v150 >= 0) {
      unint64_t v87 = *(void *)v150;
    }
    else {
      unint64_t v87 = 0x8000000000000000 - *(void *)v150;
    }
    unint64_t v88 = 0x8000000000000000 - v86;
    if (v86 >= 0) {
      unint64_t v88 = *((void *)v150 + 1);
    }
    unint64_t v147 = v88;
    uint64_t v89 = *((void *)v150 + v133);
    if (v89 < 0) {
      uint64_t v89 = 0x8000000000000000 - v89;
    }
    uint64_t v132 = v89;
    if (v85 < 0 || v87 + v85 > a3)
    {
      int v121 = "Invalid in segment in patch";
      __int16 v122 = 369;
      goto LABEL_153;
    }
    if (v87 + v84 + v147 > *(void *)(a4 + 16))
    {
      int v121 = "Invalid out segment in patch";
      __int16 v122 = 370;
LABEL_153:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v122, 42, 0, v121, v82, v83, v131);
      unsigned int v111 = -1;
      unint64_t v61 = v152;
LABEL_154:
      int v91 = v148;
      goto LABEL_155;
    }
    if (v87) {
      break;
    }
LABEL_116:
    if (v147)
    {
      unint64_t v99 = 0;
      unint64_t v100 = v147;
      while (1)
      {
        unint64_t v101 = v100 - v99;
        if (v101 >= 0x20000) {
          size_t v102 = 0x20000;
        }
        else {
          size_t v102 = v101;
        }
        if (ILowMemoryDecoderStreamRead(v143, v152, v102) != v102)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 405, 42, 0, "reading from archive stream", v103, v104, v131);
          unsigned int v111 = -1;
          unint64_t v61 = v152;
          goto LABEL_154;
        }
        if (OBufferedStreamWrite((unint64_t **)v141, v152, v102) != v102) {
          break;
        }
        v99 += v102;
        v84 += v102;
        unint64_t v100 = v147;
        if (v99 >= v147) {
          goto LABEL_124;
        }
      }
      int v121 = "writing to digest stream";
      __int16 v122 = 407;
      goto LABEL_153;
    }
LABEL_124:
    v85 += v132;
    if (v84 >= v137) {
      goto LABEL_125;
    }
  }
  unint64_t v90 = 0;
  int v91 = v148;
  unint64_t v92 = v87;
  while (1)
  {
    unint64_t v93 = v92 - v90;
    if (v93 >= 0x20000) {
      size_t v94 = 0x20000;
    }
    else {
      size_t v94 = v93;
    }
    if (ILowMemoryDecoderStreamRead(v139, v152, v94) != v94)
    {
      uint64_t v119 = "reading from diff stream";
      __int16 v120 = 379;
      goto LABEL_147;
    }
    if (a1(a2, v148, v94, v85) != v94)
    {
      uint64_t v119 = "reading from input stream";
      __int16 v120 = 381;
      goto LABEL_147;
    }
    __int16 v95 = (char *)v148;
    int v96 = v152;
    for (size_t i = v94; i; --i)
    {
      char v98 = *v95++;
      *v96++ += v98;
    }
    if (OBufferedStreamWrite((unint64_t **)v141, v152, v94) != v94) {
      break;
    }
    v90 += v94;
    v85 += v94;
    v84 += v94;
    unint64_t v92 = v87;
    if (v90 >= v87) {
      goto LABEL_116;
    }
  }
  uint64_t v119 = "writing to digest stream";
  __int16 v120 = 390;
LABEL_147:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v120, 42, 0, v119, v82, v83, v131);
  unsigned int v111 = -1;
  unint64_t v61 = v152;
LABEL_155:
  uint64_t v116 = v143;
  uint64_t v115 = v145;
  uint64_t v73 = v139;
  long long v109 = (void ***)v141;
LABEL_156:
  long long v110 = v134;
LABEL_157:
  free(v150);
  free(v61);
  free(v91);
  OBufferedStreamDestroy(v109, v123, v124, v125, v126, v127, v128, v129);
  OSHA1StreamDestroy(v110, md);
  ILowMemoryDecoderStreamDestroy(v115);
  ILowMemoryDecoderStreamDestroy(v73);
  ILowMemoryDecoderStreamDestroy(v116);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0) {
    return v111;
  }
  else {
    return result;
  }
}

uint64_t BXPatch5WithFlagsBufferStreamPRead(void *a1, void *__dst, size_t __n, uint64_t a4)
{
  if (!__n) {
    return 0;
  }
  uint64_t result = -1;
  if (!__CFADD__(a4, __n) && a4 + __n <= a1[1])
  {
    memcpy(__dst, (const void *)(*a1 + a4), __n);
    return __n;
  }
  return result;
}

uint64_t BXPatch5FileWithFlags(const char *a1, uint64_t a2, unint64_t a3, uint64_t (*a4)(uint64_t, void *, uint64_t), uint64_t a5, uint64_t a6)
{
  char v11 = (char)a1;
  off_t st_size = 0;
  memset(&v22, 0, sizeof(v22));
  unsigned int v12 = open(a1, 0);
  uint64_t v23 = v12;
  if ((v12 & 0x80000000) != 0)
  {
    BOOL v18 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5FileWithFlags", 235, 42, *v18, "open: %s", v19, v20, v11);
    return 0xFFFFFFFFLL;
  }
  else
  {
    int v13 = v12;
    if (fstat(v12, &v22))
    {
      uint64_t v14 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5FileWithFlags", 236, 42, *v14, "fstat: %s", v15, v16, v11);
      uint64_t v17 = 0xFFFFFFFFLL;
LABEL_6:
      close(v13);
      return v17;
    }
    off_t st_size = v22.st_size;
    uint64_t v17 = BXPatch5StreamWithFlags((uint64_t (*)(uint64_t, void *, uint64_t, unint64_t))BXPatch5WithFlagsFileStreamPRead, (uint64_t)&v23, v22.st_size, a2, a3, a4, a5, a6);
    int v13 = v23;
    if ((v23 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  return v17;
}

ssize_t BXPatch5WithFlagsFileStreamPRead(uint64_t a1, void *a2, size_t a3, off_t a4)
{
  if (!a3) {
    return 0;
  }
  ssize_t result = -1;
  if (!__CFADD__(a4, a3) && a4 + a3 <= *(void *)(a1 + 8)) {
    return pread(*(_DWORD *)a1, a2, a3, a4);
  }
  return result;
}

uint64_t copyStream(uint64_t (*a1)(uint64_t, void *, uint64_t, unint64_t), uint64_t a2, unint64_t a3, uint64_t (*a4)(uint64_t, void *, uint64_t), uint64_t a5)
{
  uint64_t v10 = malloc(0x40000uLL);
  if (!v10)
  {
    int v18 = *__error();
    uint64_t v19 = "malloc";
    __int16 v20 = 188;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"copyStream", v20, 42, v18, v19, v14, v15, v22);
    uint64_t v17 = 0xFFFFFFFFLL;
    goto LABEL_17;
  }
  unint64_t v11 = 0;
  if (a3)
  {
    while (1)
    {
      if (v11 + 0x40000 <= a3) {
        uint64_t v12 = 0x40000;
      }
      else {
        uint64_t v12 = a3 - v11;
      }
      uint64_t v13 = a1(a2, v10, v12, v11);
      if (v13 <= 0)
      {
        uint64_t v19 = "inProc read";
        __int16 v20 = 196;
        goto LABEL_15;
      }
      uint64_t v16 = a4(a5, v10, v13);
      if (v16 <= 0) {
        break;
      }
      v11 += v16;
      if (v11 >= a3) {
        goto LABEL_9;
      }
    }
    uint64_t v19 = "outProc write";
    __int16 v20 = 198;
LABEL_15:
    int v18 = 0;
    goto LABEL_16;
  }
LABEL_9:
  if (v11 == a3) {
    uint64_t v17 = 0;
  }
  else {
    uint64_t v17 = 0xFFFFFFFFLL;
  }
LABEL_17:
  free(v10);
  return v17;
}

uint64_t BXPatch5InPlace(const char *a1, uint64_t a2, unint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v152 = *MEMORY[0x263EF8340];
  if (a3 <= 0x3B)
  {
    int v8 = "Invalid patch size";
    __int16 v9 = 441;
LABEL_29:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", v9, 42, 0, v8, a7, a8, v125);
    return 0xFFFFFFFFLL;
  }
  if (*(void *)a2 != 0x3035464649445842)
  {
    int v8 = "Invalid patch header";
    __int16 v9 = 442;
    goto LABEL_29;
  }
  if ((*(unsigned char *)(a2 + 12) & 1) == 0)
  {
    int v8 = "Patch can't be applied in-place";
    __int16 v9 = 445;
    goto LABEL_29;
  }
  if (a4 >= 1) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "Input variants in patch: %u\n", *(_DWORD *)(a2 + 8));
  }
  uint64_t v149 = 0;
  uint64_t v150 = 0;
  int v151 = 0;
  uint64_t FileSHA1Digest = getFileSHA1Digest(a1, (uint64_t)&v149);
  if (FileSHA1Digest)
  {
    int v8 = "computing file digest";
    __int16 v9 = 450;
    goto LABEL_29;
  }
  if (v149 == *(void *)(a2 + 40)
    && v150 == *(void *)(a2 + 48)
    && v151 == (unint64_t)*(unsigned int *)(a2 + 56))
  {
    if (a4 >= 1) {
      fwrite("No-op patch matching, do nothing\n", 0x21uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    }
    return 0;
  }
  uint64_t v22 = *(unsigned int *)(a2 + 8);
  if (!v22)
  {
LABEL_28:
    int v8 = "Input doesn't match any of the expected patch inputs (in-place)";
    __int16 v9 = 467;
    goto LABEL_29;
  }
  uint64_t v23 = 0;
  uint64_t v24 = (uint64_t *)(a2 + 60);
  uint64_t v25 = a2 + 68;
  while (1)
  {
    BOOL v26 = v149 == *(void *)v25 && v150 == *(void *)(v25 + 8);
    if (v26 && v151 == (unint64_t)*(unsigned int *)(v25 + 16)) {
      break;
    }
    ++v23;
    v25 += 28;
    if (v22 == v23) {
      goto LABEL_28;
    }
  }
  if (a4 >= 1)
  {
    uint64_t FileSHA1Digest = fprintf((FILE *)*MEMORY[0x263EF8348], "In-place patch matching entry %u\n", v23);
    uint64_t v22 = *(unsigned int *)(a2 + 8);
  }
  uint64_t v29 = (uint64_t)v24 + 28 * v22 + *(void *)(a2 + 24);
  uint64_t v147 = *(void *)(a2 + 24);
  uint64_t v143 = (char *)v24 + 28 * v22;
  if (v22)
  {
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    do
    {
      if (v23 == v30) {
        uint64_t v31 = v29;
      }
      uint64_t v32 = *v24;
      uint64_t v24 = (uint64_t *)((char *)v24 + 28);
      v29 += v32;
      ++v30;
    }
    while (v22 != v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v33 = *(void *)(v25 - 8);
  uint64_t v128 = *(void *)(a2 + 32);
  if (v29 + v128 - a2 != a3)
  {
    uint64_t FileSHA1Digest = pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 489, 42, "Warning: extra bytes in patch (ignored)\n", v19, a7, a8, v125);
    LODWORD(v22) = *(_DWORD *)(a2 + 8);
  }
  enterThreadErrorContext(FileSHA1Digest, v15, v16, v17, v18, v19, a7, a8, v125);
  uint64_t v134 = malloc(0x1000uLL);
  if (!v134)
  {
    int v54 = *__error();
    __int16 v57 = 511;
LABEL_62:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", v57, 42, v54, "malloc", v55, v56, v126);
    unint64_t v40 = 0;
    uint64_t v65 = 0;
    uint64_t v66 = 0;
    uint64_t v67 = 0;
    uint64_t v68 = 0;
    uint64_t v69 = 0;
    uint64_t v70 = 0;
    goto LABEL_95;
  }
  uint64_t v34 = malloc(0x1000uLL);
  if (!v34)
  {
    int v54 = *__error();
    __int16 v57 = 513;
    goto LABEL_62;
  }
  char v130 = v34;
  uint64_t v135 = (v22 + 2);
  uint64_t v136 = 8 * v135;
  uint64_t v133 = (char *)malloc(8 * v135);
  uint64_t v35 = ILowMemoryDecoderStreamCreateWithBuffer((uint64_t)v143, v147, 0x1000uLL);
  if (!v35)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 517, 42, 0, "Control stream init", v36, v37, v126);
    unint64_t v40 = 0;
    uint64_t v67 = 0;
    uint64_t v68 = 0;
    uint64_t v69 = 0;
    uint64_t v70 = 0;
LABEL_64:
    uint64_t v66 = v130;
    uint64_t v65 = v133;
    goto LABEL_95;
  }
  uint64_t v127 = v33;
  uint64_t v139 = v35;
  uint64_t v140 = 0;
  uint64_t v38 = 0;
  unint64_t v39 = 0;
  unint64_t v40 = 0;
  uint64_t v41 = v133;
  for (i = 8 * (v22 + 2); ; uint64_t v38 = &v144[i])
  {
    uint64_t v144 = v38;
    uint64_t v148 = v39;
    if (v39 == v140)
    {
      uint64_t v43 = v39 + (v39 >> 1);
      if (v39 >> 5 <= 0xC34) {
        uint64_t v43 = 2 * v39;
      }
      if (!v39) {
        uint64_t v43 = 2000;
      }
      uint64_t v140 = v43;
      __int16 v44 = (char *)reallocf(v40, i * v43);
      size_t i = 8 * (v22 + 2);
      uint64_t v41 = v133;
      unint64_t v40 = v44;
      if (!v44)
      {
        uint64_t v65 = v133;
        int v94 = *__error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 527, 42, v94, "malloc", v95, v96, v126);
LABEL_92:
        uint64_t v67 = 0;
        uint64_t v68 = 0;
        uint64_t v69 = 0;
        uint64_t v66 = v130;
LABEL_94:
        uint64_t v70 = v139;
        goto LABEL_95;
      }
    }
    uint64_t v45 = ILowMemoryDecoderStreamRead(v139, v41, i);
    if (!v45) {
      break;
    }
    uint64_t v48 = (uint64_t *)v41;
    uint64_t v49 = v144;
    uint64_t v50 = (v22 + 2);
    if (v45 != i)
    {
      uint64_t v65 = v41;
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 533, 42, 0, "reading from control stream S=%lld", v46, v47, v45);
      goto LABEL_92;
    }
    do
    {
      uint64_t v52 = *v48++;
      uint64_t v51 = v52;
      unint64_t v53 = 0x8000000000000000 - v52;
      if (v52 < 0) {
        uint64_t v51 = v53;
      }
      *(void *)&v49[(void)v40] = v51;
      v49 += 8;
      --v50;
    }
    while (v50);
    unint64_t v39 = v148 + 1;
  }
  if (a4 >= 2) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%zu controls in patch (%zu B allocated)\n", v148, v136 * v140);
  }
  uint64_t v71 = PagedFileCreate(a1, *(void *)(a2 + 16), 0x2800000uLL, a4);
  if (!v71)
  {
    uint64_t v67 = 0;
    uint64_t v68 = 0;
    uint64_t v69 = 0;
    uint64_t v66 = v130;
    uint64_t v65 = v133;
    goto LABEL_94;
  }
  uint64_t v67 = v71;
  if (v148)
  {
    unint64_t v72 = 0;
    uint64_t v73 = (unint64_t *)v40;
    uint64_t v74 = v148;
    do
    {
      unint64_t v131 = *v73;
      unint64_t v141 = v72;
      uint64_t v145 = (void *)v73[(v23 + 2)];
      PagedFileRetainIn(v67, v72, *v73, v60, v61, v62, v63, v64);
      unint64_t v72 = (unint64_t)v145 + v131 + v141;
      uint64_t v73 = (unint64_t *)((char *)v73 + v136);
      --v74;
    }
    while (v74);
  }
  PagedFileReleaseAllIn((uint64_t)v67, v58, v59, v60, v61, v62, v63, v64);
  if (a4 > 1) {
    PagedFileDump((uint64_t)v67, "Input retained");
  }
  uint64_t v75 = ILowMemoryDecoderStreamCreateWithBuffer(v31, v127, 0x1000uLL);
  uint64_t v70 = v139;
  if (!v75)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 563, 42, 0, "Diff stream init", v76, v77, v126);
    uint64_t v68 = 0;
    uint64_t v69 = 0;
    goto LABEL_64;
  }
  uint64_t v142 = v75;
  uint64_t v146 = v67;
  if (v148)
  {
    uint64_t v78 = 0;
    unint64_t v79 = 0;
    unint64_t v80 = 0;
    uint64_t v81 = (v23 + 2);
    uint64_t v82 = (char *)v130;
    uint64_t v129 = v81;
    while (1)
    {
      uint64_t v83 = (unint64_t *)((char *)v40 + 8 * v78 * v135);
      unint64_t v84 = *v83;
      unint64_t v85 = v83[1];
      unint64_t v137 = v83[v81];
      if (a4 >= 3)
      {
        fprintf((FILE *)*MEMORY[0x263EF8348], "DIFF STREAM: I=%zu OPOS=%llu IPOS=%llu NDIFF=%llu NARCHIVE=%llu IDELTA=%lld\n", v78, v79, v80, v84, v85, v137);
        PagedFileDump((uint64_t)v146, "Before applying control");
        uint64_t v82 = (char *)v130;
      }
      unint64_t v132 = v85;
      if (v84) {
        break;
      }
LABEL_88:
      v80 += v137;
      v79 += v132;
      ++v78;
      uint64_t v81 = v129;
      if (v78 == v148) {
        goto LABEL_105;
      }
    }
    while (1)
    {
      if (v84 >= 0x1000) {
        size_t v86 = 4096;
      }
      else {
        size_t v86 = v84;
      }
      if (ILowMemoryDecoderStreamRead(v142, v82, v86) != v86)
      {
        uint64_t v119 = "reading from diff stream";
        __int16 v120 = 584;
        goto LABEL_130;
      }
      if (PagedFileReadAndReleaseIn((uint64_t)v146, v80, v86, (uint64_t)v134, v87, v88, v89, v90))
      {
        uint64_t v119 = "reading from input stream";
        __int16 v120 = 587;
        goto LABEL_130;
      }
      for (uint64_t j = 0; j != v86; ++j)
        *((unsigned char *)v130 + j) += v134[j];
      if (PagedFileRetainAndWriteOut((uint64_t)v146, v79, v86, (uint64_t)v130, v91, v92, v89, v90)) {
        break;
      }
      v80 += v86;
      v79 += v86;
      v84 -= v86;
      uint64_t v82 = (char *)v130;
      if (!v84) {
        goto LABEL_88;
      }
    }
    uint64_t v119 = "writing output";
    __int16 v120 = 593;
LABEL_130:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", v120, 42, 0, v119, v89, v90, v126);
    uint64_t v68 = 0;
LABEL_137:
    uint64_t v66 = v130;
LABEL_138:
    uint64_t v65 = v133;
    uint64_t v70 = v139;
    uint64_t v67 = v146;
LABEL_139:
    uint64_t v69 = v142;
LABEL_95:
    PagedFileDestroy((uint64_t)v67, v58, v59, v60, v61, v62, v63, v64);
    free(v40);
    free(v65);
    free(v134);
    free(v66);
    ILowMemoryDecoderStreamDestroy(v70);
    ILowMemoryDecoderStreamDestroy(v69);
    ILowMemoryDecoderStreamDestroy(v68);
LABEL_96:
    int v97 = 0;
    goto LABEL_97;
  }
  unint64_t v80 = 0;
LABEL_105:
  uint64_t v67 = v146;
  if (a4 >= 2) {
    PagedFileDump((uint64_t)v146, "Diff stream applied");
  }
  if (!PagedFileHasNoIn((uint64_t)v146))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 608, 42, 0, "some input bytes are still mapped after diff expansion", v99, v100, v126);
    uint64_t v68 = 0;
    uint64_t v66 = v130;
    uint64_t v65 = v133;
    uint64_t v70 = v139;
    goto LABEL_139;
  }
  uint64_t v68 = ILowMemoryDecoderStreamCreateWithBuffer(v29, v128, 0x1000uLL);
  if (!v68)
  {
    int v121 = "Archive stream init";
    __int16 v122 = 611;
LABEL_136:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", v122, 42, 0, v121, v101, v102, v126);
    goto LABEL_137;
  }
  if (v148)
  {
    uint64_t v138 = 0;
    unint64_t v103 = 0;
    while (1)
    {
      uint64_t v104 = (char *)v40 + 8 * v138 * v135;
      uint64_t v106 = *(void *)v104;
      unint64_t v105 = *((void *)v104 + 1);
      if (a4 >= 3) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "ARCHIVE STREAM: OPOS=%llu IPOS=%llu NDIFF=%llu NARCHIVE=%llu\n", v103, v80, v106, v105);
      }
      v103 += v106;
      if (v105) {
        break;
      }
LABEL_121:
      if (++v138 == v148) {
        goto LABEL_122;
      }
    }
    uint64_t v66 = v130;
    while (1)
    {
      if (v105 >= 0x1000) {
        size_t v107 = 4096;
      }
      else {
        size_t v107 = v105;
      }
      if (ILowMemoryDecoderStreamRead(v68, (char *)v66, v107) != v107)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 630, 42, 0, "reading from archive stream", v110, v111, v126);
        goto LABEL_138;
      }
      if (PagedFileRetainAndWriteOut((uint64_t)v146, v103, v107, (uint64_t)v66, v108, v109, v110, v111)) {
        break;
      }
      v103 += v107;
      v105 -= v107;
      uint64_t v66 = v130;
      if (!v105) {
        goto LABEL_121;
      }
    }
    int v121 = "writing output";
    __int16 v122 = 633;
    goto LABEL_136;
  }
LABEL_122:
  if (a4 >= 2) {
    PagedFileDump((uint64_t)v146, "Archive stream applied");
  }
  if (!PagedFileHasAllOut((uint64_t)v146))
  {
    int v121 = "some output bytes are missing or referenced more than once after archive expansion";
    __int16 v122 = 643;
    goto LABEL_136;
  }
  PagedFileDestroy((uint64_t)v146, v112, v113, v114, v115, v116, v101, v102);
  free(v40);
  free(v133);
  free(v134);
  free(v130);
  ILowMemoryDecoderStreamDestroy(v139);
  ILowMemoryDecoderStreamDestroy(v142);
  ILowMemoryDecoderStreamDestroy(v68);
  if (getFileSHA1Digest(a1, (uint64_t)&v149))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 658, 42, 0, "computing file digest", v117, v118, v126);
    int v97 = 0;
  }
  else
  {
    int v97 = 1;
  }
  if (v149 != *(void *)(a2 + 40)
    || v150 != *(void *)(a2 + 48)
    || v151 != (unint64_t)*(unsigned int *)(a2 + 56))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 659, 42, 0, "Invalid output digest", v117, v118, v126);
    goto LABEL_96;
  }
LABEL_97:
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (v97) {
    unsigned int v98 = 0;
  }
  else {
    unsigned int v98 = -1;
  }
  if ((int)result >= 0) {
    return v98;
  }
  else {
    return result;
  }
}

uint64_t CC_CKSUM_Init(uint64_t a1)
{
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  return 1;
}

uint64_t CC_CKSUM_Update(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int v3 = *(_DWORD *)a1;
  if (a3)
  {
    uint64_t v4 = a3;
    uint64_t v5 = a3;
    do
    {
      int v6 = *a2++;
      unsigned int v3 = CKSUMTable[v6 ^ HIBYTE(v3)] ^ (v3 << 8);
      --v5;
    }
    while (v5);
  }
  else
  {
    uint64_t v4 = 0;
  }
  *(_DWORD *)a1 = v3;
  *(void *)(a1 + 8) += v4;
  return 1;
}

uint64_t CC_CKSUM_Final(unsigned int *a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)a2;
  unint64_t v3 = *(void *)(a2 + 8);
  if (v3)
  {
    do
    {
      unsigned int v2 = CKSUMTable[v3 ^ HIBYTE(v2)] ^ (v2 << 8);
      BOOL v4 = v3 > 0xFF;
      v3 >>= 8;
    }
    while (v4);
  }
  *a1 = ~v2;
  return 1;
}

unsigned int *ThreadPipelineCreate(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, size_t a6)
{
  uint64_t v12 = (unsigned int *)calloc(1uLL, 0x1A8uLL);
  uint64_t v13 = v12;
  if (v12)
  {
    *uint64_t v12 = a1;
    uint64_t v14 = calloc(a1, 0x198uLL);
    *((void *)v13 + 1) = v14;
    if (v14)
    {
      uint64_t v15 = calloc(1uLL, 0x20uLL);
      *((void *)v13 + 2) = v15;
      if (v15)
      {
        size_t v16 = *v13;
        v13[10] = 0;
        v13[11] = v16;
        uint64_t v17 = calloc(v16, 4uLL);
        *((void *)v13 + 6) = v17;
        if (v17)
        {
          if (pthread_mutex_init((pthread_mutex_t *)(v13 + 14), 0))
          {
            unint64_t v21 = "SharedArrayInit: pthread_mutex_init failed\n";
            __int16 v22 = 56;
          }
          else
          {
            if (!pthread_cond_init((pthread_cond_t *)(v13 + 30), 0))
            {
              size_t v29 = *v13 + 1;
              v13[42] = 0;
              v13[43] = v29;
              uint64_t v30 = calloc(v29, 4uLL);
              *((void *)v13 + 22) = v30;
              if (v30)
              {
                if (pthread_mutex_init((pthread_mutex_t *)(v13 + 46), 0))
                {
                  uint64_t v34 = "SharedArrayInit: pthread_mutex_init failed\n";
                  __int16 v35 = 56;
                }
                else
                {
                  if (!pthread_cond_init((pthread_cond_t *)(v13 + 62), 0))
                  {
                    v13[6] = -1;
                    v13[74] = 0;
                    if (pthread_mutex_init((pthread_mutex_t *)(v13 + 76), 0)
                      || pthread_cond_init((pthread_cond_t *)(v13 + 92), 0))
                    {
                      BOOL v26 = "SemInit";
                      __int16 v27 = 184;
                    }
                    else if (*v13)
                    {
                      uint64_t v36 = 0;
                      unint64_t v37 = 0;
                      while (1)
                      {
                        uint64_t v38 = *((void *)v13 + 1);
                        uint64_t v39 = v38 + v36;
                        *(void *)(v39 + 16) = v13;
                        *(_DWORD *)(v39 + 8) = v37;
                        *(void *)(v39 + 24) = *(void *)(a2 + 8 * v37);
                        *(void *)(v39 + 32) = a3;
                        *(_DWORD *)(v39 + 40) = 0;
                        if (pthread_mutex_init((pthread_mutex_t *)(v38 + v36 + 48), 0)
                          || pthread_cond_init((pthread_cond_t *)(v39 + 112), 0))
                        {
                          BOOL v26 = "SemInit";
                          __int16 v27 = 194;
                          goto LABEL_14;
                        }
                        uint64_t v43 = v36;
                        uint64_t v40 = v38 + v36;
                        *(_DWORD *)(v40 + 160) = 0;
                        if (pthread_mutex_init((pthread_mutex_t *)(v40 + 168), 0)
                          || pthread_cond_init((pthread_cond_t *)(v40 + 232), 0))
                        {
                          BOOL v26 = "SemInit";
                          __int16 v27 = 195;
                          goto LABEL_14;
                        }
                        *(_DWORD *)(v38 + v43 + 280) = 0;
                        if (pthread_mutex_init((pthread_mutex_t *)(v38 + v43 + 288), 0)
                          || pthread_cond_init((pthread_cond_t *)(v38 + v43 + 352), 0))
                        {
                          BOOL v26 = "SemInit";
                          __int16 v27 = 196;
                          goto LABEL_14;
                        }
                        if ((createThread((pthread_t *)v39, (uint64_t)threadPipelineWorkerThreadProc, v39, a6) & 0x80000000) != 0) {
                          break;
                        }
                        ++v37;
                        uint64_t v36 = v43 + 408;
                        if (v37 >= *v13) {
                          goto LABEL_37;
                        }
                      }
                      BOOL v26 = "Thread creation";
                      __int16 v27 = 197;
                    }
                    else
                    {
LABEL_37:
                      uint64_t v41 = *((void *)v13 + 2);
                      *(void *)(v41 + 8) = v13;
                      *(void *)(v41 + 16) = a4;
                      *(void *)(v41 + 24) = a5;
                      if ((createThread((pthread_t *)v41, (uint64_t)threadPipelineConsumerThreadProc, v41, 0) & 0x80000000) == 0) {
                        return v13;
                      }
                      BOOL v26 = "Thread creation";
                      __int16 v27 = 206;
                    }
                    goto LABEL_14;
                  }
                  uint64_t v34 = "SharedArrayInit: pthread_cond_init failed\n";
                  __int16 v35 = 57;
                }
              }
              else
              {
                uint64_t v34 = "SharedArrayInit: malloc failed\n";
                __int16 v35 = 55;
              }
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayInit", v35, 0, v34, v31, v32, v33, v42);
              BOOL v26 = "SharedArrayInit";
              __int16 v27 = 182;
LABEL_14:
              int v23 = 0;
              goto LABEL_15;
            }
            unint64_t v21 = "SharedArrayInit: pthread_cond_init failed\n";
            __int16 v22 = 57;
          }
        }
        else
        {
          unint64_t v21 = "SharedArrayInit: malloc failed\n";
          __int16 v22 = 55;
        }
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayInit", v22, 0, v21, v18, v19, v20, v42);
        BOOL v26 = "SharedArrayInit";
        __int16 v27 = 180;
        goto LABEL_14;
      }
      int v23 = *__error();
      BOOL v26 = "malloc";
      __int16 v27 = 179;
    }
    else
    {
      int v23 = *__error();
      BOOL v26 = "malloc";
      __int16 v27 = 177;
    }
  }
  else
  {
    int v23 = *__error();
    BOOL v26 = "malloc";
    __int16 v27 = 172;
  }
LABEL_15:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineCreate", v27, 87, v23, v26, v24, v25, v42);
  ThreadPipelineDestroy((uint64_t)v13);
  return 0;
}

uint64_t threadPipelineWorkerThreadProc(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  unint64_t v3 = (pthread_mutex_t *)(a1 + 48);
  BOOL v4 = (pthread_cond_t *)(a1 + 112);
  uint64_t v28 = (pthread_mutex_t *)(a1 + 168);
  __int16 v27 = (pthread_cond_t *)(a1 + 232);
  uint64_t v5 = (pthread_mutex_t *)(a1 + 288);
  int v6 = (pthread_cond_t *)(a1 + 352);
  while (1)
  {
    int v7 = *(_DWORD *)(a1 + 8);
    if (pthread_mutex_lock((pthread_mutex_t *)(v2 + 56)))
    {
      uint64_t v24 = "SharedArrayPush: pthread_mutex_lock failed\n";
      __int16 v25 = 117;
      goto LABEL_35;
    }
    uint64_t v12 = *(unsigned int *)(v2 + 40);
    unsigned int v11 = *(_DWORD *)(v2 + 44);
    int v13 = v12;
    if (v12 < v11)
    {
      *(_DWORD *)(*(void *)(v2 + 48) + 4 * v12) = v7;
      int v13 = *(_DWORD *)(v2 + 40);
    }
    *(_DWORD *)(v2 + 40) = v13 + 1;
    if (!v13)
    {
      if (pthread_cond_broadcast((pthread_cond_t *)(v2 + 120))) {
        break;
      }
    }
    if (pthread_mutex_unlock((pthread_mutex_t *)(v2 + 56)))
    {
      uint64_t v24 = "SharedArrayPush: pthread_mutex_unlock failed\n";
      __int16 v25 = 124;
      goto LABEL_35;
    }
    if (v12 >= v11)
    {
      uint64_t v24 = "SharedArrayPush: stack is full\n";
      __int16 v25 = 125;
      goto LABEL_35;
    }
    if (pthread_mutex_lock(v3)) {
      goto LABEL_27;
    }
    while (1)
    {
      int v16 = *(_DWORD *)(a1 + 40);
      if (v16 > 0) {
        break;
      }
      if (pthread_cond_wait(v4, v3)) {
        goto LABEL_27;
      }
    }
    *(_DWORD *)(a1 + 40) = v16 - 1;
    if (pthread_mutex_unlock(v3))
    {
LABEL_27:
      unint64_t v21 = "SemAcquire";
      __int16 v22 = 72;
      goto LABEL_28;
    }
    if ((*(void *)(a1 + 400) & 0x8000000000000000) != 0) {
      return a1;
    }
    if (((*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 24)) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"threadPipelineWorkerThreadProc", 82, 87, 0, "worker proc reported an error", v17, v18, v26);
      atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 416), 1u, memory_order_relaxed);
    }
    if (pthread_mutex_lock(v28)
      || (int v19 = *(_DWORD *)(a1 + 160), *(_DWORD *)(a1 + 160) = v19 + 1, !v19) && pthread_cond_broadcast(v27)
      || pthread_mutex_unlock(v28))
    {
      unint64_t v21 = "SemRelease";
      __int16 v22 = 85;
      goto LABEL_28;
    }
    if (!pthread_mutex_lock(v5))
    {
      while (1)
      {
        int v20 = *(_DWORD *)(a1 + 280);
        if (v20 > 0) {
          break;
        }
        if (pthread_cond_wait(v6, v5)) {
          goto LABEL_26;
        }
      }
      *(_DWORD *)(a1 + 280) = v20 - 1;
      if (!pthread_mutex_unlock(v5)) {
        continue;
      }
    }
LABEL_26:
    unint64_t v21 = "SemAcquire";
    __int16 v22 = 88;
    goto LABEL_28;
  }
  uint64_t v24 = "SharedArrayPush: pthread_cond_broadcast failed\n";
  __int16 v25 = 122;
LABEL_35:
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPush", v25, 0, v24, v8, v9, v10, v26);
  unint64_t v21 = "SharedArrayPush";
  __int16 v22 = 69;
LABEL_28:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"threadPipelineWorkerThreadProc", v22, 87, 0, v21, v14, v15, v26);
  atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 416), 1u, memory_order_relaxed);
  return a1;
}

uint64_t threadPipelineConsumerThreadProc(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!pthread_mutex_lock((pthread_mutex_t *)(v2 + 184)))
  {
    uint64_t v12 = (pthread_cond_t *)(v2 + 248);
    int v13 = (pthread_mutex_t *)(v2 + 304);
    uint64_t v28 = (pthread_cond_t *)(v2 + 368);
    do
    {
      while (1)
      {
        int v14 = *(_DWORD *)(v2 + 168);
        if (v14) {
          break;
        }
        if (pthread_cond_wait(v12, (pthread_mutex_t *)(v2 + 184)))
        {
          int v6 = "SharedArrayPop: pthread_cond_wait failed\n";
          __int16 v7 = 94;
          goto LABEL_3;
        }
      }
      unsigned int v15 = v14 - 1;
      *(_DWORD *)(v2 + 168) = v15;
      unsigned int v16 = *(_DWORD *)(*(void *)(v2 + 176) + 4 * v15);
      if (pthread_mutex_unlock((pthread_mutex_t *)(v2 + 184)))
      {
        int v6 = "SharedArrayPop: pthread_mutex_unlock failed\n";
        __int16 v7 = 98;
        goto LABEL_3;
      }
      if (v16 == -2)
      {
        if (!pthread_mutex_lock(v13))
        {
          int v22 = *(_DWORD *)(v2 + 296);
          *(_DWORD *)(v2 + 296) = v22 + 1;
          if (v22 || !pthread_cond_broadcast(v28)) {
            pthread_mutex_unlock(v13);
          }
        }
      }
      else
      {
        if (v16 == -1) {
          return a1;
        }
        uint64_t v17 = v12;
        uint64_t v18 = *(void *)(v2 + 8);
        uint64_t v19 = v18 + 408 * v16;
        int v20 = (pthread_mutex_t *)(v19 + 168);
        if (pthread_mutex_lock((pthread_mutex_t *)(v19 + 168))) {
          goto LABEL_30;
        }
        unint64_t v21 = (int *)(v19 + 160);
        while (*v21 <= 0)
        {
          if (pthread_cond_wait((pthread_cond_t *)(v18 + 408 * v16 + 232), v20)) {
            goto LABEL_30;
          }
        }
        --*v21;
        if (pthread_mutex_unlock(v20))
        {
LABEL_30:
          uint64_t v10 = "SemAcquire";
          __int16 v11 = 134;
          goto LABEL_31;
        }
        if (((*(uint64_t (**)(void, void))(a1 + 24))(*(void *)(a1 + 16), *(void *)(v18 + 408 * v16 + 24)) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"threadPipelineConsumerThreadProc", 141, 87, 0, "consumer proc reported an error", v23, v24, (char)v28);
          atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 416), 1u, memory_order_relaxed);
        }
        uint64_t v12 = v17;
        int v13 = (pthread_mutex_t *)(v2 + 304);
        if (pthread_mutex_lock((pthread_mutex_t *)(v18 + 408 * v16 + 288))
          || (v25 = v18 + 408 * v16, int v26 = *(_DWORD *)(v25 + 280), *(_DWORD *)(v25 + 280) = v26 + 1, !v26)
          && pthread_cond_broadcast((pthread_cond_t *)(v18 + 408 * v16 + 352))
          || pthread_mutex_unlock((pthread_mutex_t *)(v18 + 408 * v16 + 288)))
        {
          uint64_t v10 = "SemRelease";
          __int16 v11 = 144;
          goto LABEL_31;
        }
      }
    }
    while (!pthread_mutex_lock((pthread_mutex_t *)(v2 + 184)));
  }
  int v6 = "SharedArrayPop: pthread_mutex_lock failed\n";
  __int16 v7 = 91;
LABEL_3:
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v7, 0, v6, v3, v4, v5, (char)v28);
  uint64_t v10 = "SharedArrayDequeue";
  __int16 v11 = 114;
LABEL_31:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"threadPipelineConsumerThreadProc", v11, 87, 0, v10, v8, v9, (char)v28);
  atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 416), 1u, memory_order_relaxed);
  return a1;
}

uint64_t ThreadPipelineDestroy(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (unsigned int *)result;
    uint64_t v2 = *(void **)(result + 8);
    if (v2)
    {
      uint64_t v3 = *(unsigned int *)result;
      if (!v3)
      {
        int v6 = 1;
        goto LABEL_41;
      }
      int v4 = 0;
      do
      {
        if (*v2) {
          ++v4;
        }
        v2 += 51;
        --v3;
      }
      while (v3);
      if (v4)
      {
        int v5 = 0;
        int v6 = 1;
        while (1)
        {
          if (pthread_mutex_lock((pthread_mutex_t *)(v1 + 14)))
          {
            __int16 v10 = 91;
            __int16 v11 = "SharedArrayPop: pthread_mutex_lock failed\n";
LABEL_15:
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v10, 0, v11, v7, v8, v9, v41);
            unsigned int v15 = -1;
          }
          else
          {
            while (1)
            {
              unsigned int v12 = v1[10];
              if (v12) {
                break;
              }
              if (pthread_cond_wait((pthread_cond_t *)(v1 + 30), (pthread_mutex_t *)(v1 + 14)))
              {
                __int16 v10 = 94;
                __int16 v11 = "SharedArrayPop: pthread_cond_wait failed\n";
                goto LABEL_15;
              }
            }
            unsigned int v22 = v12 - 1;
            v1[10] = v22;
            unsigned int v15 = *(_DWORD *)(*((void *)v1 + 6) + 4 * v22);
            if (!pthread_mutex_unlock((pthread_mutex_t *)(v1 + 14))) {
              goto LABEL_17;
            }
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", 98, 0, "SharedArrayPop: pthread_mutex_unlock failed\n", v23, v24, v25, v41);
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 237, 87, 0, "SharedArrayPop", v13, v14, v42);
          int v6 = 0;
LABEL_17:
          uint64_t v16 = *((void *)v1 + 1);
          uint64_t v17 = v16 + 408 * v15;
          *(void *)(v17 + 400) = -1;
          if (pthread_mutex_lock((pthread_mutex_t *)(v17 + 48))
            || (v20 = v16 + 408 * v15, int v21 = *(_DWORD *)(v20 + 40), *(_DWORD *)(v20 + 40) = v21 + 1, !v21)
            && pthread_cond_broadcast((pthread_cond_t *)(v16 + 408 * v15 + 112))
            || pthread_mutex_unlock((pthread_mutex_t *)(v17 + 48)))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 245, 87, 0, "SemRelease", v18, v19, v41);
            int v6 = 0;
          }
          if ((joinThread(*(_opaque_pthread_t **)v17) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 246, 87, 0, "joinThread", v26, v27, v41);
            int v6 = 0;
          }
          *(void *)uint64_t v17 = 0;
          if (++v5 == v4)
          {
            if (!*v1) {
              goto LABEL_41;
            }
            goto LABEL_33;
          }
        }
      }
      int v6 = 1;
LABEL_33:
      unint64_t v28 = 0;
      uint64_t v29 = 352;
      do
      {
        uint64_t v30 = *((void *)v1 + 1);
        uint64_t v31 = v30 + v29;
        if (!pthread_mutex_destroy((pthread_mutex_t *)(v30 + v29 - 304))) {
          pthread_cond_destroy((pthread_cond_t *)(v31 - 240));
        }
        if (!pthread_mutex_destroy((pthread_mutex_t *)(v31 - 184))) {
          pthread_cond_destroy((pthread_cond_t *)(v30 + v29 - 120));
        }
        uint64_t v32 = (pthread_cond_t *)(v30 + v29);
        if (!pthread_mutex_destroy((pthread_mutex_t *)&v32[-2].__opaque[24])) {
          pthread_cond_destroy(v32);
        }
        ++v28;
        v29 += 408;
      }
      while (v28 < *v1);
LABEL_41:
      free(*((void **)v1 + 1));
      *((void *)v1 + 1) = 0;
    }
    else
    {
      int v6 = 1;
    }
    uint64_t v33 = (_opaque_pthread_t **)*((void *)v1 + 2);
    if (v33)
    {
      if (*v33)
      {
        if ((SharedArrayEnqueue(v1 + 42, -1) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 272, 87, 0, "SharedArrayEnqueue", v34, v35, v41);
          int v6 = 0;
        }
        if ((joinThread(*v33) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 273, 87, 0, "joinThread", v36, v37, v41);
          int v6 = 0;
        }
        _OWORD *v33 = 0;
        uint64_t v33 = (_opaque_pthread_t **)*((void *)v1 + 2);
      }
      free(v33);
      *((void *)v1 + 2) = 0;
    }
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 14)) && !pthread_cond_destroy((pthread_cond_t *)(v1 + 30))) {
      free(*((void **)v1 + 6));
    }
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 46)) && !pthread_cond_destroy((pthread_cond_t *)(v1 + 62))) {
      free(*((void **)v1 + 22));
    }
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 76))) {
      pthread_cond_destroy((pthread_cond_t *)(v1 + 92));
    }
    int v40 = atomic_load(v1 + 104);
    if (v40 >= 1)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 285, 87, 0, "Threads reported errors", v38, v39, v41);
      int v6 = 0;
    }
    free(v1);
    if (v6) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t ThreadPipelineGetWorker(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 24) != -1)
  {
    uint64_t v8 = "Missing call to RunWorker before GetWorker";
    __int16 v9 = 294;
LABEL_11:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineGetWorker", v9, 87, 0, v8, a7, a8, v21);
    return 0;
  }
  __int16 v11 = (pthread_mutex_t *)(a1 + 56);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 56)))
  {
    unsigned int v15 = "SharedArrayPop: pthread_mutex_lock failed\n";
    __int16 v16 = 91;
LABEL_10:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v16, 0, v15, v12, v13, v14, v21);
    uint64_t v8 = "SharedArrayPop failed";
    __int16 v9 = 298;
    goto LABEL_11;
  }
  while (1)
  {
    int v17 = *(_DWORD *)(a1 + 40);
    if (v17) {
      break;
    }
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 120), v11))
    {
      unsigned int v15 = "SharedArrayPop: pthread_cond_wait failed\n";
      __int16 v16 = 94;
      goto LABEL_10;
    }
  }
  unsigned int v18 = v17 - 1;
  *(_DWORD *)(a1 + 40) = v18;
  unsigned int v19 = *(_DWORD *)(*(void *)(a1 + 48) + 4 * v18);
  if (pthread_mutex_unlock(v11))
  {
    unsigned int v15 = "SharedArrayPop: pthread_mutex_unlock failed\n";
    __int16 v16 = 98;
    goto LABEL_10;
  }
  *(_DWORD *)(a1 + 24) = v19;
  return *(void *)(*(void *)(a1 + 8) + 408 * v19 + 24);
}

uint64_t ThreadPipelineRunWorker(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)(a1 + 24);
  if (v8 == -1)
  {
    uint64_t v14 = "Missing call to GetWorker before RunWorker";
    __int16 v15 = 311;
    goto LABEL_10;
  }
  *(_DWORD *)(a1 + 24) = -1;
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = v10 + 1;
  *(void *)(v9 + 408 * v8 + 400) = v10;
  if ((SharedArrayEnqueue((unsigned int *)(a1 + 168), v8) & 0x80000000) != 0)
  {
    uint64_t v14 = "SharedArrayEnqueue failed";
    __int16 v15 = 324;
    goto LABEL_10;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(v9 + 408 * v8 + 48))
    || (uint64_t v11 = v9 + 408 * v8, v12 = *(_DWORD *)(v11 + 40), *(_DWORD *)(v11 + 40) = v12 + 1, !v12)
    && pthread_cond_broadcast((pthread_cond_t *)(v9 + 408 * v8 + 112))
    || (uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v9 + 408 * v8 + 48)), result))
  {
    uint64_t v14 = "SemRelease failed";
    __int16 v15 = 325;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineRunWorker", v15, 87, 0, v14, a7, a8, v16);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t ThreadPipelineFlush(uint64_t a1)
{
  if ((SharedArrayEnqueue((unsigned int *)(a1 + 168), -2) & 0x80000000) != 0)
  {
    int v5 = "SharedArrayEnqueue failed";
    __int16 v6 = 333;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineFlush", v6, 87, 0, v5, v2, v3, v8);
    return 0xFFFFFFFFLL;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 304))) {
    goto LABEL_8;
  }
  while (1)
  {
    int v4 = *(_DWORD *)(a1 + 296);
    if (v4 > 0) {
      break;
    }
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 368), (pthread_mutex_t *)(a1 + 304))) {
      goto LABEL_8;
    }
  }
  *(_DWORD *)(a1 + 296) = v4 - 1;
  uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(a1 + 304));
  if (result)
  {
LABEL_8:
    int v5 = "SemAquire failed";
    __int16 v6 = 336;
    goto LABEL_9;
  }
  return result;
}

unsigned char *pc_zero_coder_decode(unsigned __int8 *a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4)
{
  unint64_t v4 = (unint64_t)&a3[a4];
  int v5 = &a1[a2];
  if (a2 >= 8 && a4 >= 9)
  {
    __int16 v6 = a1;
    while (1)
    {
      unsigned __int8 v7 = *a3;
      if (*a3)
      {
        unsigned __int8 v8 = a3[1];
        a3 += 2;
        if ((v7 & 2) != 0)
        {
LABEL_6:
          unsigned __int8 v10 = *a3++;
          unsigned __int8 v9 = v10;
          if ((v7 & 4) != 0) {
            goto LABEL_7;
          }
          goto LABEL_11;
        }
      }
      else
      {
        unsigned __int8 v8 = 0;
        ++a3;
        if ((v7 & 2) != 0) {
          goto LABEL_6;
        }
      }
      unsigned __int8 v9 = 0;
      if ((v7 & 4) != 0)
      {
LABEL_7:
        unsigned __int8 v12 = *a3++;
        unsigned __int8 v11 = v12;
        if ((v7 & 8) != 0) {
          goto LABEL_8;
        }
        goto LABEL_12;
      }
LABEL_11:
      unsigned __int8 v11 = 0;
      if ((v7 & 8) != 0)
      {
LABEL_8:
        unsigned __int8 v14 = *a3++;
        unsigned __int8 v13 = v14;
        goto LABEL_13;
      }
LABEL_12:
      unsigned __int8 v13 = 0;
LABEL_13:
      unsigned __int8 *v6 = v8;
      v6[1] = v9;
      v6[2] = v11;
      v6[3] = v13;
      if ((v7 & 0x10) != 0)
      {
        unsigned __int8 v22 = *a3++;
        unsigned __int8 v15 = v22;
        if ((v7 & 0x20) != 0)
        {
LABEL_15:
          unsigned __int8 v17 = *a3++;
          unsigned __int8 v16 = v17;
          if ((v7 & 0x40) != 0) {
            goto LABEL_16;
          }
          goto LABEL_20;
        }
      }
      else
      {
        unsigned __int8 v15 = 0;
        if ((v7 & 0x20) != 0) {
          goto LABEL_15;
        }
      }
      unsigned __int8 v16 = 0;
      if ((v7 & 0x40) != 0)
      {
LABEL_16:
        unsigned __int8 v19 = *a3++;
        unsigned __int8 v18 = v19;
        if ((v7 & 0x80) != 0) {
          goto LABEL_17;
        }
        goto LABEL_21;
      }
LABEL_20:
      unsigned __int8 v18 = 0;
      if ((v7 & 0x80) != 0)
      {
LABEL_17:
        unsigned __int8 v21 = *a3++;
        unsigned __int8 v20 = v21;
        goto LABEL_22;
      }
LABEL_21:
      unsigned __int8 v20 = 0;
LABEL_22:
      _OWORD v6[4] = v15;
      v6[5] = v16;
      v6[6] = v18;
      v6[7] = v20;
      uint64_t v23 = v6 + 16;
      v6 += 8;
      if (v23 > v5 || (unint64_t)(a3 + 9) > v4) {
        goto LABEL_26;
      }
    }
  }
  __int16 v6 = a1;
LABEL_26:
  if ((unint64_t)a3 < v4)
  {
    int v24 = *a3++;
    unsigned int v25 = v24 | 0x100;
    while (v6 != v5)
    {
      if (v25)
      {
        if (a3 == (unsigned __int8 *)v4) {
          return (unsigned char *)(v6 - a1);
        }
        unsigned __int8 v27 = *a3++;
        unsigned __int8 v26 = v27;
      }
      else
      {
        unsigned __int8 v26 = 0;
      }
      *v6++ = v26;
      BOOL v28 = v25 > 3;
      v25 >>= 1;
      if (!v28) {
        goto LABEL_26;
      }
    }
    __int16 v6 = &a1[a2];
  }
  return (unsigned char *)(v6 - a1);
}

unsigned char *pc_zero_coder_encode(char *a1, uint64_t a2, char *a3, uint64_t a4)
{
  if (a2 < 9) {
    return 0;
  }
  unint64_t v5 = (unint64_t)&a3[a4];
  __int16 v6 = a1;
  while ((unint64_t)(a3 + 8) <= v5)
  {
    char v7 = *a3;
    int v8 = a3[1];
    int v9 = a3[2];
    int v10 = a3[3];
    if (!*a3)
    {
      unsigned __int8 v11 = v6 + 1;
      if (!a3[1]) {
        goto LABEL_8;
      }
LABEL_7:
      *v11++ = v8;
      v7 |= 2u;
      goto LABEL_8;
    }
    unsigned __int8 v11 = v6 + 2;
    v6[1] = v7;
    char v7 = 1;
    if (v8) {
      goto LABEL_7;
    }
LABEL_8:
    if (v9)
    {
      *v11++ = v9;
      v7 |= 4u;
    }
    if (v10)
    {
      *v11++ = v10;
      v7 |= 8u;
    }
    int v12 = a3[5];
    int v13 = a3[6];
    int v14 = a3[7];
    if (a3[4])
    {
      *v11++ = a3[4];
      v7 |= 0x10u;
    }
    if (v12)
    {
      *v11++ = v12;
      v7 |= 0x20u;
    }
    if (v13)
    {
      *v11++ = v13;
      v7 |= 0x40u;
    }
    if (v14)
    {
      *v11++ = v14;
      v7 |= 0x80u;
    }
    char *v6 = v7;
    __int16 v6 = v11;
    a3 += 8;
    if (v11 + 9 > &a1[a2]) {
      return 0;
    }
  }
  if ((unint64_t)a3 >= v5)
  {
    unsigned __int8 v17 = v6;
  }
  else
  {
    char v15 = 0;
    int v16 = 0;
    unsigned __int8 v17 = v6 + 1;
    int v18 = -1 << (a4 & 7);
    unsigned __int8 v19 = 1;
    unsigned __int8 v20 = a3;
    do
    {
      int v21 = *v20;
      if (v21)
      {
        *v17++ = v21;
        v18 |= 1 << v15;
      }
      char v15 = ++v16;
      unsigned __int8 v20 = &a3[v19++];
    }
    while ((unint64_t)v20 < v5);
    char *v6 = v18;
  }
  return (unsigned char *)(v17 - a1);
}

uint64_t compressionWorkerProc(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a1;
  if (atomic_load((unsigned int *)(*a1 + 112)))
  {
    uint64_t result = 0;
    a1[6] = -1;
    return result;
  }
  uint64_t v12 = a1[2];
  a1[6] = v12;
  if (v12 == -2) {
    return 0;
  }
  if (v12 == -1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"compressionWorkerProc", 244, 37, 0, "NOP received", a7, a8, v20);
    return 0;
  }
  if (v12 < 0)
  {
    int v14 = "Invalid iBlock received";
    __int16 v15 = 246;
  }
  else
  {
    if (!*(_DWORD *)(v9 + 4))
    {
      unint64_t v16 = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v9 + 96))(a1[5], *(void *)(v9 + 16), a1[1], a1[3]);
      size_t v17 = a1[3];
      if ((v16 & 0x8000000000000000) != 0 || v16 >= v17)
      {
        memcpy((void *)a1[5], (const void *)a1[1], v17);
        unint64_t v16 = a1[3];
        size_t v17 = v16;
      }
      a1[7] = v16;
      a1[8] = v17;
      if (*(int *)(v9 + 24) >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Worker: encode block %5lld: %7llu => %7llu\n");
      }
      return 0;
    }
    if (a1[3] == a1[4])
    {
      memcpy((void *)a1[5], (const void *)a1[1], a1[3]);
      uint64_t v13 = a1[3];
      a1[7] = v13;
      goto LABEL_19;
    }
    uint64_t v18 = (*(uint64_t (**)(uint64_t))(v9 + 96))(a1[5]);
    if ((v18 & 0x8000000000000000) == 0 && v18 == a1[4])
    {
      a1[7] = v18;
      uint64_t v13 = a1[3];
LABEL_19:
      a1[8] = v13;
      if (*(int *)(v9 + 24) >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Worker: decode block %5lld: %7llu => %7llu\n");
      }
      return 0;
    }
    uint64_t v20 = a1[6];
    int v14 = "invalid output size/decoder error: block=%lld, inSize=%lld, outSize=%lld, expectedOutSize=%lld";
    __int16 v15 = 292;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"compressionWorkerProc", v15, 37, 0, v14, a7, a8, v20);
  int v19 = 0;
  a1[6] = -1;
  atomic_compare_exchange_strong((atomic_uint *volatile)(v9 + 112), (unsigned int *)&v19, 1u);
  return 0xFFFFFFFFLL;
}

uint64_t outputStreamProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  if (atomic_load((unsigned int *)(a1 + 112))) {
    return 0;
  }
  unint64_t v12 = *(void *)(a2 + 48);
  if (v12 > 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v13 = 0;
LABEL_5:
    uint64_t result = 0;
    *(void *)(a1 + 88) += v13;
    return result;
  }
  if ((v12 & 0x8000000000000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 327, 37, 0, "invalid block ID in write thread %lld", a7, a8, *(void *)(a2 + 48));
LABEL_20:
    uint64_t v13 = 0;
    goto LABEL_22;
  }
  if (*(_DWORD *)(a1 + 4) != 1)
  {
    int8x16_t v17 = vrev64q_s8(*(int8x16_t *)(a2 + 56));
    int8x16_t v26 = vextq_s8(v17, v17, 8uLL);
    uint64_t v18 = pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56), *(void *)(a1 + 72), (uint64_t)&v26, 16);
    if ((v18 & 0x8000000000000000) == 0)
    {
      uint64_t v13 = v18;
      if (v18 == 16)
      {
        uint64_t v19 = pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56), *(void *)(a1 + 72), *(void *)(a2 + 40), *(void *)(a2 + 56));
        if (v19 < 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 351, 37, 0, "writing block payload", v20, v21, v25);
          uint64_t v13 = 16;
        }
        else
        {
          uint64_t v13 = v19 + 16;
          if (v19 == *(void *)(a2 + 56)) {
            goto LABEL_5;
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 353, 37, 0, "Truncated block payload (%lld/%llu bytes read)", v20, v21, v19);
        }
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 347, 37, 0, "Truncated block header (%lld/16 bytes written)", v15, v16, v18);
      }
      goto LABEL_22;
    }
    unsigned __int8 v22 = "writing block header";
    __int16 v23 = 345;
    goto LABEL_19;
  }
  uint64_t v14 = pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56), *(void *)(a1 + 72), *(void *)(a2 + 40), *(void *)(a2 + 56));
  if (v14 < 0)
  {
    unsigned __int8 v22 = "writing block";
    __int16 v23 = 334;
LABEL_19:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", v23, 37, 0, v22, v15, v16, v25);
    goto LABEL_20;
  }
  uint64_t v13 = v14;
  if (v14 == *(void *)(a2 + 56)) {
    goto LABEL_5;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 336, 37, 0, "Truncated block payload (%lld/%llu bytes written)", v15, v16, v14);
LABEL_22:
  int v24 = 0;
  *(void *)(a1 + 88) += v13;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 112), (unsigned int *)&v24, 1u);
  return 0xFFFFFFFFLL;
}

uint64_t pcWrite(uint64_t (*a1)(uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = a4;
    uint64_t v8 = 0;
    while (1)
    {
      uint64_t v9 = a1(a2, a3, v6);
      uint64_t v12 = v9;
      if (v9 < 0) {
        break;
      }
      a3 += v9;
      v8 += v9;
      v6 -= v9;
      if (!v6) {
        return v8;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"pcWrite", 131, 37, 0, "pcWrite failed", v10, v11, v16);
    return v12;
  }
  else
  {
    uint64_t v8 = a1(a2, 0, 0);
    if (v8 < 0) {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"pcWrite", 121, 37, 0, "pcWrite EOF failed", v13, v14, v16);
    }
  }
  return v8;
}

uint64_t PCompressFilter(unsigned int *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v117[2] = *MEMORY[0x263EF8340];
  enterThreadErrorContext((uint64_t)a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8, v105);
  *(void *)uint64_t v115 = 0;
  long long v113 = 0u;
  *(_OWORD *)uint64_t v114 = 0u;
  long long v111 = 0u;
  long long v112 = 0u;
  long long v109 = 0u;
  long long v110 = 0u;
  long long v108 = 0u;
  unsigned int DefaultNThreads = a1[2];
  if (!DefaultNThreads) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  a1[2] = DefaultNThreads;
  if (a1[1] == 1)
  {
    if (pcRead(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))a2, *(void *)(a2 + 16), (uint64_t)&v116, 4) != 4)goto LABEL_34; {
    if (a3)
    }
      *a3 += 4;
    unsigned int v14 = 0;
    while (getHeader(v14, (uint64_t)v117) || v116 != LODWORD(v117[0]))
    {
      if (++v14 == 7)
      {
        if (compression_stream_identify_algorithm() == -1)
        {
          uint64_t v15 = "invalid header in input stream";
          __int16 v16 = 179;
        }
        else
        {
          uint64_t v15 = "compressed stream detected : try compression_tool";
          __int16 v16 = 178;
        }
LABEL_33:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processFileHeader", v16, 37, 0, v15, v12, v13, v106);
LABEL_34:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"PCompressFilter", 507, 37, 0, "processFileHeader", v12, v13, v106);
        goto LABEL_35;
      }
    }
    v117[0] = 0;
    if (pcRead(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))a2, *(void *)(a2 + 16), (uint64_t)v117, 8) != 8)goto LABEL_34; {
    if (a3)
    }
      *a3 += 8;
    if (!v117[0])
    {
      uint64_t v15 = "invalid blockSize in input stream";
      __int16 v16 = 191;
      goto LABEL_33;
    }
    *((void *)a1 + 2) = bswap64(v117[0]);
    *a1 = v14;
    if ((int)a1[6] >= 1)
    {
      uint64_t v20 = (FILE **)MEMORY[0x263EF8348];
      uint64_t v21 = (FILE *)*MEMORY[0x263EF8348];
      DecoderDescription = PCompressGetDecoderDescription(v14);
      fprintf(v21, "Decoder: %s\n", DecoderDescription);
      fprintf(*v20, "Blocksize: %llu\n");
    }
  }
  else
  {
    unint64_t v17 = *((void *)a1 + 2);
    unsigned int EncoderDecoder = PCompressGetEncoderDecoder(*a1);
    if (getHeader(EncoderDecoder, (uint64_t)&v116)
      || pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 24), *(void *)(a2 + 40), (uint64_t)&v116, 4) != 4)
    {
      goto LABEL_34;
    }
    if (a3) {
      a3[1] += 4;
    }
    v117[0] = bswap64(v17);
    if (pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 24), *(void *)(a2 + 40), (uint64_t)v117, 8) != 8)goto LABEL_34; {
    if (a3)
    }
      a3[1] += 8;
    if ((int)a1[6] >= 1)
    {
      uint64_t v19 = (FILE *)*MEMORY[0x263EF8348];
      PCompressGetEncoderDescription(*a1);
      fprintf(v19, "Encoder: %s\n");
    }
  }
  long long v23 = *((_OWORD *)a1 + 1);
  long long v108 = *(_OWORD *)a1;
  long long v109 = v23;
  long long v113 = 0u;
  *(_OWORD *)uint64_t v114 = 0u;
  *(void *)uint64_t v115 = 0;
  long long v24 = *(_OWORD *)(a2 + 16);
  long long v110 = *(_OWORD *)a2;
  long long v111 = v24;
  long long v112 = *(_OWORD *)(a2 + 32);
  if (a3) {
    long long v113 = *(_OWORD *)a3;
  }
  unsigned int v25 = *a1;
  if (a1[1]) {
    DecoderFilter = PCompressGetDecoderFilter(v25);
  }
  else {
    DecoderFilter = PCompressGetEncoderFilter(v25);
  }
  v114[0] = DecoderFilter;
  uint64_t v31 = calloc((int)a1[2], 0x48uLL);
  v114[1] = v31;
  if (!v31)
  {
    __int16 v37 = 468;
LABEL_98:
    size_t v86 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"initFilterState", v37, 37, *v86, "malloc", v87, v88, v106);
LABEL_99:
    uint64_t v89 = "initFilterState";
    __int16 v90 = 510;
LABEL_105:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"PCompressFilter", v90, 37, 0, v89, v45, v46, v106);
    char v94 = 0;
    int v95 = 1;
    goto LABEL_106;
  }
  unint64_t v32 = a1[2];
  if ((int)v32 < 1) {
    goto LABEL_53;
  }
  uint64_t v33 = v31;
  size_t v34 = *((void *)a1 + 2);
  uint64_t v35 = malloc(v34);
  v33[1] = v35;
  uint64_t v36 = malloc(v34);
  v33[5] = v36;
  void *v33 = &v108;
  __int16 v37 = 477;
  if (!v35 || !v36) {
    goto LABEL_98;
  }
  unint64_t v38 = 0;
  uint64_t v39 = v33 + 9;
  do
  {
    if (v32 - 1 == v38) {
      goto LABEL_53;
    }
    int v40 = malloc(v34);
    v39[1] = v40;
    char v41 = malloc(v34);
    v39[5] = v41;
    *uint64_t v39 = &v108;
    ++v38;
    if (!v40) {
      break;
    }
    v39 += 9;
  }
  while (v41);
  char v42 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"initFilterState", 477, 37, *v42, "malloc", v43, v44, v106);
  if (v38 < v32) {
    goto LABEL_99;
  }
LABEL_53:
  unint64_t v107 = v109;
  signed int v47 = DWORD2(v108);
  uint64_t v48 = malloc(8 * SDWORD2(v108));
  if (!v48)
  {
    int v91 = *__error();
    uint64_t v92 = "malloc";
    __int16 v93 = 372;
LABEL_103:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", v93, 37, v91, v92, v59, v60, v106);
    goto LABEL_104;
  }
  uint64_t v49 = v48;
  if (v47 >= 1)
  {
    uint64_t v50 = (char *)v114[1];
    uint64_t v51 = v48;
    uint64_t v52 = v47;
    do
    {
      *v51++ = v50;
      v50 += 72;
      --v52;
    }
    while (v52);
  }
  unint64_t v53 = ThreadPipelineCreate(v47, (uint64_t)v48, (uint64_t)compressionWorkerProc, (uint64_t)&v108, (uint64_t)outputStreamProc, 0);
  if (!v53)
  {
    uint64_t v92 = "creating pipeline";
    __int16 v93 = 375;
    int v91 = 0;
    goto LABEL_103;
  }
  uint64_t v61 = (uint64_t)v53;
  uint64_t v62 = 0;
  int v63 = 1;
  unint64_t v64 = v107;
  while (1)
  {
    if (atomic_load(v115))
    {
      int v63 = 0;
      goto LABEL_120;
    }
    if (!v63) {
      break;
    }
    uint64_t Worker = ThreadPipelineGetWorker(v61, v54, v55, v56, v57, v58, v59, v60);
    if (!Worker)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 387, 37, 0, "getting worker from pipeline", v67, v68, v106);
      int v82 = 0;
LABEL_94:
      int v63 = 0;
      goto LABEL_95;
    }
    uint64_t v69 = (uint64_t *)Worker;
    if (DWORD1(v108) == 1)
    {
      uint64_t v70 = pcRead((uint64_t (*)(uint64_t, uint64_t, uint64_t))v110, v111, (uint64_t)v117, 16);
      uint64_t v77 = v70;
      if (v70)
      {
        if (v70 < 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 397, 37, 0, "reading block header", v75, v76, v106);
          int v82 = 0;
          int v83 = 0;
          uint64_t v77 = 0;
        }
        else if (v70 == 16)
        {
          unint64_t v78 = bswap64(v117[0]);
          unint64_t v79 = bswap64(v117[1]);
          if (v79 > v64 || v78 > v64)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 405, 37, 0, "Invalid block header payload=0x%llx raw=0x%llx block=0x%llx\n", v75, v76, v79);
            int v82 = 0;
            int v83 = 0;
            uint64_t v77 = 16;
          }
          else
          {
            uint64_t v80 = pcRead((uint64_t (*)(uint64_t, uint64_t, uint64_t))v110, v111, v69[1], v79);
            if (v80 < 0)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 411, 37, 0, "reading block payload", v75, v76, v106);
              int v82 = 0;
              int v83 = 0;
              uint64_t v77 = 16;
            }
            else
            {
              uint64_t v77 = v80 + 16;
              if (v80 == v79)
              {
                unint64_t v81 = v78;
                int v82 = 0;
                v69[3] = v79;
                v69[4] = v81;
                int v83 = 1;
                v69[2] = v62;
              }
              else
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 415, 37, 0, "Truncated block payload (%lld/%llu bytes read)", v75, v76, v80);
                int v82 = 0;
                int v83 = 0;
              }
            }
            unint64_t v64 = v107;
          }
        }
        else
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 399, 37, 0, "Truncated block header (%lld/16 bytes read)", v75, v76, v70);
          int v82 = 0;
          int v83 = 0;
        }
      }
      else
      {
        int v82 = 1;
        int v83 = 1;
      }
    }
    else
    {
      uint64_t v84 = pcRead((uint64_t (*)(uint64_t, uint64_t, uint64_t))v110, v111, *(void *)(Worker + 8), v64);
      if (v84 < 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 428, 37, 0, "reading block", v75, v76, v106);
        int v82 = 0;
LABEL_90:
        int v63 = 0;
        uint64_t v85 = -1;
        goto LABEL_91;
      }
      uint64_t v77 = v84;
      if (!v84)
      {
        uint64_t v85 = -2;
        int v82 = 1;
        goto LABEL_89;
      }
      int v82 = 0;
      v69[3] = v84;
      v69[4] = 0;
      int v83 = 1;
      v69[2] = v62;
    }
    *(void *)&long long v113 = v113 + v77;
    if (!v82 && v83)
    {
      int v82 = 0;
      int v63 = 1;
      goto LABEL_92;
    }
    if (!v83) {
      goto LABEL_90;
    }
    uint64_t v85 = -2;
LABEL_89:
    int v63 = 1;
LABEL_91:
    v69[2] = v85;
LABEL_92:
    if ((ThreadPipelineRunWorker(v61, (uint64_t)v69, v71, v72, v73, v74, v75, v76) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 445, 37, 0, "RunWorker", v59, v60, v106);
      goto LABEL_94;
    }
LABEL_95:
    ++v62;
    if (v82) {
      goto LABEL_120;
    }
  }
  atomic_load(v115);
LABEL_120:
  if ((ThreadPipelineDestroy(v61) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 447, 37, 0, "ThreadPipelineDestroy", v100, v101, v106);
    free(v49);
    goto LABEL_104;
  }
  free(v49);
  if (!v63)
  {
LABEL_104:
    uint64_t v89 = "processStream";
    __int16 v90 = 513;
    goto LABEL_105;
  }
  uint64_t v102 = (*(uint64_t (**)(void, void, void))(a2 + 24))(*(void *)(a2 + 40), 0, 0);
  if (v102 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"pcWrite", 121, 37, 0, "pcWrite EOF failed", v103, v104, v106);
    uint64_t v89 = "writing EOF";
    __int16 v90 = 520;
    goto LABEL_105;
  }
  int v95 = 0;
  *((void *)&v113 + 1) += v102;
  char v94 = 1;
LABEL_106:
  uint64_t v96 = v114[1];
  if (v114[1])
  {
    if (SDWORD2(v108) >= 1)
    {
      uint64_t v97 = 0;
      uint64_t v98 = 0;
      do
      {
        free(*(void **)((char *)v114[1] + v97 + 8));
        free(*(void **)((char *)v114[1] + v97 + 40));
        ++v98;
        v97 += 72;
      }
      while (v98 < SDWORD2(v108));
      uint64_t v96 = v114[1];
    }
    free(v96);
    v114[1] = 0;
  }
  char v99 = v94 ^ 1;
  if (!a3) {
    char v99 = 1;
  }
  if ((v99 & 1) == 0)
  {
    unsigned int v29 = 0;
    *(_OWORD *)a3 = v113;
    goto LABEL_40;
  }
  if (!v95)
  {
    unsigned int v29 = 0;
    goto LABEL_40;
  }
LABEL_35:
  uint64_t v27 = *(void (**)(void))(a2 + 32);
  if (v27) {
    v27(*(void *)(a2 + 40));
  }
  BOOL v28 = *(void (**)(void))(a2 + 8);
  if (v28) {
    v28(*(void *)(a2 + 16));
  }
  unsigned int v29 = -1;
LABEL_40:
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0) {
    return v29;
  }
  else {
    return result;
  }
}

uint64_t pcRead(uint64_t (*a1)(uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a4) {
    return 0;
  }
  uint64_t v4 = a4;
  uint64_t v8 = 0;
  while (1)
  {
    uint64_t v9 = a1(a2, a3, v4);
    uint64_t v12 = v9;
    if (v9 < 0) {
      break;
    }
    if (v9)
    {
      a3 += v9;
      v8 += v9;
      v4 -= v9;
      if (v4) {
        continue;
      }
    }
    return v8;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"pcRead", 82, 37, 0, "pcRead failed", v10, v11, v14);
  return v12;
}

uint64_t getHeader(unsigned int a1, uint64_t a2)
{
  int DecoderKey = PCompressGetDecoderKey(a1);
  if (DecoderKey == 63) {
    return 0xFFFFFFFFLL;
  }
  char v5 = DecoderKey;
  uint64_t result = 0;
  *(_DWORD *)a2 = 538976288;
  *(_WORD *)a2 = 25200;
  *(unsigned char *)(a2 + 2) = 122;
  *(unsigned char *)(a2 + 3) = v5;
  return result;
}

uint64_t clusterLookup(uint64_t a1, unint64_t a2, char *__source, char *__dst, size_t __size, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (HIDWORD(a2))
  {
    uint64_t v8 = "cluster id out of range";
    __int16 v9 = 213;
    int v10 = 0;
LABEL_3:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"clusterLookup", v9, 2, v10, v8, a7, a8, v20);
    return 0xFFFFFFFFLL;
  }
  unint64_t v17 = *(void *)a1;
  if (*(void *)a1 <= a2)
  {
    do
    {
      if (v17) {
        v17 += v17 >> 1;
      }
      else {
        unint64_t v17 = 32;
      }
    }
    while (v17 <= a2);
    uint64_t v19 = (char *)reallocf(*(void **)(a1 + 8), 1028 * v17);
    *(void *)(a1 + 8) = v19;
    if (!v19)
    {
      int v10 = *__error();
      uint64_t v8 = "malloc";
      __int16 v9 = 221;
      goto LABEL_3;
    }
    uint64_t v18 = v19;
    bzero(&v19[1028 * *(void *)a1], 1028 * (v17 - *(void *)a1));
    *(void *)a1 = v17;
  }
  else
  {
    uint64_t v18 = *(char **)(a1 + 8);
  }
  if (*(_DWORD *)&v18[1028 * a2])
  {
    strlcpy(__dst, &v18[1028 * a2 + 4], __size);
    return 1;
  }
  else
  {
    strlcpy(&v18[1028 * a2 + 4], __source, 0x400uLL);
    uint64_t result = 0;
    *(_DWORD *)(*(void *)(a1 + 8) + 1028 * a2) = 1;
  }
  return result;
}

uint64_t setEntryAttributes(uint64_t a1, uint64_t a2)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(int **)a1;
  int v5 = *(_DWORD *)(*(void *)a1 + 24);
  bzero(path, 0x800uLL);
  uint64_t v6 = (FILE **)MEMORY[0x263EF8348];
  if (*v4 >= 3) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "[%7d] set attributes: %s\n", *(_DWORD *)(a2 + 2296), (const char *)(a2 + 144));
  }
  if ((concatExtractPath(path, 0x800uLL, (char *)(a1 + 12), (const char *)(a2 + 144)) & 0x80000000) != 0)
  {
    LOBYTE(v25) = a2 - 112;
    uint64_t v11 = "invalid path: %s";
    __int16 v10 = 252;
    goto LABEL_16;
  }
  if (*(_DWORD *)(a2 + 4) == 68 && (clearEntryXAT(path) & 0x80000000) != 0)
  {
    unsigned int v25 = path;
    uint64_t v11 = "clear XAT: %s";
    __int16 v10 = 257;
    goto LABEL_16;
  }
  uint64_t v9 = v5 & 1;
  if (yaa_setEntryAttributes(path, (int *)a2, a2 + 2192, v9))
  {
    __int16 v10 = 261;
    uint64_t v11 = "setEntryAttributes";
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"setEntryAttributes", v10, 2, 0, v11, v7, v8, (char)v25);
    uint64_t v21 = 0xFFFFFFFFLL;
    goto LABEL_17;
  }
  uint64_t v12 = *(void *)(a2 + 2280);
  if (v12)
  {
    unint64_t DataSize = MemBufferGetDataSize(v12);
    uint64_t DataPtr = (unsigned int *)MemBufferGetDataPtr(*(void *)(a2 + 2280));
    if (yaa_setEntryXAT(path, a2, v9, DataSize, DataPtr, v15, v16, v17))
    {
      uint64_t v11 = "setEntryXAT";
      __int16 v10 = 266;
      goto LABEL_16;
    }
  }
  uint64_t v18 = *(void *)(a2 + 2288);
  if (v18)
  {
    unint64_t v19 = MemBufferGetDataSize(v18) / 0x120uLL;
    uint64_t v20 = MemBufferGetDataPtr(*(void *)(a2 + 2288));
    if (yaa_setEntryACL(path, a2, v9, v19, v20))
    {
      uint64_t v11 = "setEntryACL";
      __int16 v10 = 272;
      goto LABEL_16;
    }
  }
  uint64_t v21 = 0;
LABEL_17:
  unsigned __int8 v22 = *(int **)a1;
  long long v23 = *(void (**)(void, uint64_t))(*(void *)a1 + 96);
  if (v23)
  {
    v23(*((void *)v22 + 18), a2);
    unsigned __int8 v22 = *(int **)a1;
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 1528), 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
  if (*v22 >= 3) {
    fprintf(*v6, "[%7d] end: %s\n", *(_DWORD *)(a2 + 2296), (const char *)(a2 + 144));
  }
  return v21;
}

uint64_t inFlightQueueEntry(void *a1, int a2)
{
  unint64_t v2 = a1[174];
  if (!v2) {
    return 0;
  }
  uint64_t v3 = a1[177];
  uint64_t v4 = a1[175];
  uint64_t v5 = (a2 - *(_DWORD *)(v3 + 2320 * v4 + 2296));
  if ((int)v5 < 0 || v2 <= v5) {
    return 0;
  }
  unint64_t v6 = v4 + v5;
  unint64_t v7 = a1[173];
  if (v6 < v7) {
    unint64_t v7 = 0;
  }
  uint64_t v8 = v6 - v7;
  uint64_t v9 = v3 + 2320 * v8;
  if (v8 >= 0) {
    return v9;
  }
  else {
    return 0;
  }
}

uint64_t writeToThread(uint64_t a1, char *a2, size_t a3)
{
  if (!a3) {
    return 0;
  }
  size_t v3 = a3;
  unint64_t v6 = (pthread_mutex_t *)(a1 + 32);
  unint64_t v7 = (pthread_cond_t *)(a1 + 96);
  uint64_t v8 = (pthread_mutex_t *)(a1 + 152);
  uint64_t v9 = (pthread_cond_t *)(a1 + 216);
  while (1)
  {
    unint64_t FreeSize = MemBufferGetFreeSize(*(void **)(a1 + 16));
    if (FreeSize >= v3) {
      size_t v11 = v3;
    }
    else {
      size_t v11 = FreeSize;
    }
    if (v11)
    {
      MemBufferFillFromBuffer(*(unint64_t **)(a1 + 16), v11, a2);
      a2 += v11;
      v3 -= v11;
      goto LABEL_18;
    }
    if (pthread_mutex_lock(v6)
      || (int v14 = *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 24) = v14 + 1, !v14) && pthread_cond_broadcast(v7)
      || pthread_mutex_unlock(v6))
    {
      uint64_t v17 = "SemRelease";
      __int16 v18 = 755;
      goto LABEL_21;
    }
    if (pthread_mutex_lock(v8)) {
      goto LABEL_20;
    }
    while (1)
    {
      int v15 = *(_DWORD *)(a1 + 144);
      if (v15 > 0) {
        break;
      }
      if (pthread_cond_wait(v9, v8)) {
        goto LABEL_20;
      }
    }
    *(_DWORD *)(a1 + 144) = v15 - 1;
    if (pthread_mutex_unlock(v8))
    {
LABEL_20:
      uint64_t v17 = "SemAcquire";
      __int16 v18 = 758;
      goto LABEL_21;
    }
    if (!MemBufferGetFreeSize(*(void **)(a1 + 16))) {
      break;
    }
LABEL_18:
    if (!v3) {
      return 0;
    }
  }
  uint64_t v17 = "thread didn't consume data";
  __int16 v18 = 761;
LABEL_21:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"writeToThread", v18, 2, 0, v17, v12, v13, v19);
  return 0xFFFFFFFFLL;
}

uint64_t SemRelease(uint64_t a1)
{
  unint64_t v2 = (pthread_mutex_t *)(a1 + 8);
  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if (!result)
  {
    int v4 = (*(_DWORD *)a1)++;
    if (v4 || (uint64_t result = pthread_cond_broadcast((pthread_cond_t *)(a1 + 72)), !result))
    {
      return pthread_mutex_unlock(v2);
    }
  }
  return result;
}

uint64_t SemAcquire(uint64_t a1)
{
  unint64_t v2 = (pthread_mutex_t *)(a1 + 8);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 8))) {
    return 0xFFFFFFFFLL;
  }
  while (*(int *)a1 <= 0)
  {
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 72), v2)) {
      return 0xFFFFFFFFLL;
    }
  }
  --*(_DWORD *)a1;
  if (pthread_mutex_unlock(v2)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t ParallelArchiveExtract()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v167 = *MEMORY[0x263EF8340];
  if (!v0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = v0;
  enterThreadErrorContext(v0, v1, v2, v3, v4, v5, v6, v7, v111);
  bzero(&v127, 0x628uLL);
  char v126 = (int *)v8;
  int DefaultNThreads = *(_DWORD *)(v8 + 20);
  if (!DefaultNThreads) {
    int DefaultNThreads = getDefaultNThreads();
  }
  LODWORD(__count) = DefaultNThreads;
  unsigned int v140 = -1;
  int v10 = *(_DWORD *)(v8 + 40);
  int v127 = (*(_DWORD *)(v8 + 24) >> 1) & 1;
  int v129 = v10;
  pthread_mutex_init(&v138, 0);
  pthread_mutex_init(&v139, 0);
  uint64_t v113 = v8;
  if (!realpath_DARWIN_EXTSN(*(const char **)(v8 + 8), v128))
  {
    int v17 = *__error();
    uint64_t v20 = *(const char **)(v8 + 8);
    __int16 v21 = 1889;
    goto LABEL_15;
  }
  int v130 = 0;
  int v131 = __count;
  unint64_t v132 = calloc(__count, 4uLL);
  if (!v132)
  {
    int v14 = "SharedArrayInit: malloc failed\n";
    __int16 v15 = 55;
    goto LABEL_13;
  }
  if (pthread_mutex_init(&v133, 0))
  {
    int v14 = "SharedArrayInit: pthread_mutex_init failed\n";
    __int16 v15 = 56;
LABEL_13:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayInit", v15, 0, v14, v11, v12, v13, v112);
    uint64_t v20 = "SharedArrayInit";
    __int16 v21 = 1892;
    goto LABEL_14;
  }
  if (pthread_cond_init(&v134, 0))
  {
    int v14 = "SharedArrayInit: pthread_cond_init failed\n";
    __int16 v15 = 57;
    goto LABEL_13;
  }
  uint64_t v136 = calloc(__count, 0x130uLL);
  if (!v136)
  {
    int v17 = *__error();
    uint64_t v20 = "malloc";
    __int16 v21 = 1896;
    goto LABEL_15;
  }
  if (__count)
  {
    uint64_t v87 = 0;
    unint64_t v88 = 0;
    while (1)
    {
      uint64_t v89 = (char *)v136;
      __int16 v90 = (char *)v136 + v87;
      *(void *)((char *)v136 + v87) = &v126;
      int v91 = MemBufferCreate(0x100000uLL);
      *((void *)v90 + 2) = v91;
      if (!v91) {
        break;
      }
      *((_DWORD *)v90 + 6) = 0;
      if (pthread_mutex_init((pthread_mutex_t *)(v90 + 32), 0)
        || (uint64_t v92 = &v89[v87], pthread_cond_init((pthread_cond_t *)&v89[v87 + 96], 0)))
      {
        uint64_t v20 = "SemInit";
        __int16 v21 = 1903;
        goto LABEL_14;
      }
      *((_DWORD *)v92 + 36) = 0;
      if (pthread_mutex_init((pthread_mutex_t *)(v92 + 152), 0)
        || (__int16 v93 = &v89[v87], pthread_cond_init((pthread_cond_t *)(v93 + 216), 0)))
      {
        uint64_t v20 = "SemInit";
        __int16 v21 = 1904;
        goto LABEL_14;
      }
      if (createThread((pthread_t *)v93 + 1, (uint64_t)extractThreadProc, (uint64_t)v90, 0))
      {
        int v17 = *__error();
        uint64_t v20 = "createThread";
        __int16 v21 = 1905;
        goto LABEL_15;
      }
      ++v88;
      v87 += 304;
      if (v88 >= __count) {
        goto LABEL_86;
      }
    }
    uint64_t v20 = "MemBufferCreate";
    __int16 v21 = 1902;
LABEL_14:
    int v17 = 0;
LABEL_15:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"ParallelArchiveExtract", v21, 2, v17, v20, v18, v19, v112);
    int v114 = 0;
    double v22 = 0.0;
    goto LABEL_16;
  }
LABEL_86:
  uint64_t v117 = 0;
  int v94 = *(_DWORD *)(v8 + 16);
  if (!v94) {
    int v94 = getDefaultNThreads();
  }
  v115[0] = 0;
  v115[1] = v94;
  uint64_t v95 = *(void *)(v8 + 64);
  uint64_t v116 = *(void *)(v8 + 48);
  uint64_t v118 = v95;
  uint64_t v119 = extractBeginProc;
  __int16 v120 = extractBlobProc;
  int v121 = extractPayloadProc;
  uint64_t v123 = extractEndProc;
  __int16 v122 = extractPaddingProc;
  uint64_t v124 = extractPaddingProc;
  char v125 = &v126;
  double RealTime = getRealTime();
  int v104 = ParallelArchiveRead((uint64_t)v115, v97, v98, v99, v100, v101, v102, v103);
  double v107 = getRealTime();
  int v114 = 1;
  if (v104 | v137)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"ParallelArchiveExtract", 1929, 2, 0, "ParallelArchiveRead failed", v105, v106, v112);
    int v137 = 1;
    int v114 = 0;
  }
  double v22 = v107 - RealTime;
  if (v140 != -1 && v141)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"ParallelArchiveExtract", 1937, 2, 0, "aborting current receiving thread", v105, v106, v112);
    int v137 = 1;
    long long v108 = (char *)v136;
    unsigned int v109 = v140;
    if (!v141)
    {
      SemAcquire((uint64_t)v136 + 304 * v140 + 144);
      int v141 = 1;
    }
    long long v110 = &v108[304 * v109];
    MemBufferClear(*((void **)v110 + 2));
    int v141 = 0;
    SemRelease((uint64_t)(v110 + 24));
  }
  while (1)
  {
LABEL_16:
    if (v136) {
      BOOL v23 = __count == 0;
    }
    else {
      BOOL v23 = 1;
    }
    if (!v23)
    {
      unint64_t v24 = 0;
      do
      {
        unsigned int v25 = (char *)v136;
        int8x16_t v26 = (char *)v136 + 304 * v24;
        uint64_t v28 = *((void *)v26 + 1);
        uint64_t v27 = (_opaque_pthread_t **)(v26 + 8);
        if (v28)
        {
          LODWORD(v160[0]) = 0;
          unsigned int v29 = (char *)v136 + 304 * v24;
          uint64_t v30 = (pthread_mutex_t *)(v29 + 152);
          if (!pthread_mutex_lock((pthread_mutex_t *)(v29 + 152)))
          {
            uint64_t v31 = (int *)(v29 + 144);
            while (*v31 <= 0)
            {
              if (pthread_cond_wait((pthread_cond_t *)&v25[304 * v24 + 216], v30)) {
                goto LABEL_28;
              }
            }
            --*v31;
            pthread_mutex_unlock(v30);
          }
LABEL_28:
          unint64_t v32 = &v25[304 * v24];
          MemBufferFillFromBuffer(*((unint64_t **)v32 + 2), 4uLL, v160);
          if (!pthread_mutex_lock((pthread_mutex_t *)(v32 + 32)))
          {
            uint64_t v33 = &v25[304 * v24];
            int v34 = *((_DWORD *)v33 + 6);
            *((_DWORD *)v33 + 6) = v34 + 1;
            if (v34 || !pthread_cond_broadcast((pthread_cond_t *)&v25[304 * v24 + 96])) {
              pthread_mutex_unlock((pthread_mutex_t *)(v32 + 32));
            }
          }
          if (joinThread(*v27))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"ParallelArchiveExtract", 1970, 2, 0, "joinThread", v35, v36, v112);
            int v114 = 0;
          }
        }
        __int16 v37 = &v25[304 * v24];
        MemBufferDestroy(*((void ***)v37 + 2));
        if (!pthread_mutex_destroy((pthread_mutex_t *)(v37 + 32))) {
          pthread_cond_destroy((pthread_cond_t *)&v25[304 * v24 + 96]);
        }
        if (!pthread_mutex_destroy((pthread_mutex_t *)&v25[304 * v24 + 152])) {
          pthread_cond_destroy((pthread_cond_t *)&v25[304 * v24 + 216]);
        }
        unint64_t v38 = &v25[304 * v24];
        atomic_fetch_add((atomic_ullong *volatile)&v155, *((void *)v38 + 36));
        atomic_fetch_add((atomic_ullong *volatile)&v159, *((void *)v38 + 37));
        ++v24;
      }
      while (v24 < __count);
    }
    if (pthread_mutex_lock(&v138))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"processDeferredEntries", 692, 2, 0, "pthread_mutex_lock", v39, v40, v112);
      goto LABEL_52;
    }
    uint64_t v43 = v146;
    uint64_t v44 = (FILE **)MEMORY[0x263EF8348];
    if (!v146) {
      break;
    }
    int v45 = 1;
    do
    {
      memset(v162, 0, 368);
      memset(v161, 0, sizeof(v161));
      uint64_t v146 = v43 - 1;
      uint64_t v46 = (char *)v147 + 16 * v43 - 16;
      pc_zero_coder_decode((unsigned __int8 *)v161, 2320, *(unsigned __int8 **)v46, *((void *)v46 + 1));
      if (v166 != 6 || v161[1] != 68)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"processDeferredEntries", 702, 2, 0, "Invalid entry state", v47, v48, v112);
        int v45 = 0;
      }
      saveThreadErrorContext(v160);
      if (*v126 >= 3) {
        fprintf(*v44, "[%7d] processing deferred Dir: %s\n", v165, v162);
      }
      if ((setEntryAttributes((uint64_t)&v126, (uint64_t)v161) & 0x80000000) != 0)
      {
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"processDeferredEntries", 711, 2, "Failed to set dir attributes", v49, v50, v51, v112);
        restoreThreadErrorContext(v160);
        int v166 = 7;
        ++v148;
      }
      MemBufferDestroy(v163);
      MemBufferDestroy(v164);
      free(*(void **)v46);
      *(void *)uint64_t v46 = 0;
      uint64_t v43 = v146;
    }
    while (v146);
    pthread_mutex_unlock(&v138);
    if (v45) {
      goto LABEL_54;
    }
LABEL_52:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"ParallelArchiveExtract", 1983, 2, 0, "Processing deferred entries", v41, v42, v112);
    int v114 = 0;
  }
  pthread_mutex_unlock(&v138);
LABEL_54:
  if (v114)
  {
    if (*(int *)v8 >= 1)
    {
      unint64_t v52 = atomic_load(&v155);
      unint64_t v53 = atomic_load(&v159);
      unint64_t v54 = v53 + v52;
      unint64_t v55 = atomic_load(&v156);
      unint64_t v56 = atomic_load(&v157);
      unint64_t v57 = v54 + v55 + v56;
      unint64_t v58 = atomic_load(&v158);
      uint64_t v59 = v57 + v58;
      uint64_t v60 = *v44;
      unint64_t v61 = atomic_load(&v152);
      fprintf(v60, "%12lld entries in archive\n", v61);
      uint64_t v62 = *v44;
      unint64_t v63 = atomic_load(&v153);
      fprintf(v62, "%12lld entries extracted\n", v63);
      fprintf(*v44, "%12llu entries failed to extract\n", v148);
      fprintf(*v44, "%12lld max entries in flight\n", v144);
      unint64_t v64 = *v44;
      unint64_t v65 = atomic_load(v154);
      fprintf(v64, "%12lld deferred directories\n", v65);
      fprintf(*v44, "%12llu bytes in archive\n", v142);
      fprintf(*v44, "%12lld bytes received in regular files\n", v59);
      uint64_t v66 = *v44;
      unint64_t v67 = atomic_load(&v155);
      fprintf(v66, "%12lld bytes stored in regular files\n", v67);
      uint64_t v68 = *v44;
      unint64_t v69 = atomic_load(&v159);
      fprintf(v68, "%12lld bytes not stored in holes\n", v69);
      uint64_t v70 = *v44;
      unint64_t v71 = atomic_load(&v156);
      fprintf(v70, "%12lld bytes not stored in hard links\n", v71);
      uint64_t v72 = *v44;
      unint64_t v73 = atomic_load(&v157);
      fprintf(v72, "%12lld bytes not stored in clones\n", v73);
      uint64_t v74 = *v44;
      unint64_t v75 = atomic_load(&v158);
      fprintf(v74, "%12lld bytes not stored in same data files\n", v75);
      fprintf(*v44, "%12.0f MB/s\n", (double)v59 / v22 * 0.000000953674316);
      if (*(int *)v8 >= 3)
      {
        if (__count)
        {
          unint64_t v76 = 0;
          uint64_t v77 = 288;
          do
          {
            unint64_t v78 = (char *)v136;
            fprintf(*v44, "-- thread %d:\n", v76);
            unint64_t v79 = &v78[v77];
            fprintf(*v44, "%12lld entries stored\n", *((void *)v79 - 2));
            fprintf(*v44, "%12lld bytes received\n", *((void *)v79 - 1));
            fprintf(*v44, "%12lld bytes stored\n", *(void *)v79);
            fprintf(*v44, "%12lld buffers exchanged\n", *((void *)v79 - 3));
            ++v76;
            v77 += 304;
          }
          while (v76 < __count);
        }
      }
    }
  }
  free(v136);
  if (!pthread_mutex_destroy(&v133) && !pthread_cond_destroy(&v134)) {
    free(v132);
  }
  pthread_mutex_destroy(&v138);
  pthread_mutex_destroy(&v139);
  if (v143) {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"ParallelArchiveExtract", 2024, 2, 0, "Destroying state with non-empty in-flight queue", v80, v81, v112);
  }
  free(v145);
  if (v146) {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"ParallelArchiveExtract", 2026, 2, 0, "Destroying state with non-empty deferred queue", v82, v83, v112);
  }
  free(v147);
  free(v149);
  free(v150);
  free(v151);
  if (v148 && (*(unsigned char *)(v113 + 24) & 8) == 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"ParallelArchiveExtract", 2035, 2, 0, "%llu entries failed to extract", v84, v85, v148);
    int v114 = 0;
  }
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (v114) {
    unsigned int v86 = 0;
  }
  else {
    unsigned int v86 = -1;
  }
  if ((int)result >= 0) {
    return v86;
  }
  else {
    return result;
  }
}

uint64_t extractThreadProc()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v265 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(unsigned int **)v0;
  uint64_t v2 = **(void **)v0;
  int v222 = *(_DWORD *)v2;
  uint64_t v3 = 678152731 * ((unint64_t)(v0 - *(void *)(*(void *)v0 + 1176)) >> 4);
  int __dst = -1;
  memset(v263, 0, 368);
  long long v262 = 0u;
  long long v261 = 0u;
  long long v260 = 0u;
  long long v259 = 0u;
  long long v258 = 0u;
  long long v257 = 0u;
  long long v256 = 0u;
  *(_OWORD *)__int16 v255 = 0u;
  long long v254 = 0u;
  uint64_t v243 = 0;
  long long v242 = 0u;
  memset(v241, 0, sizeof(v241));
  bzero(v253, 0x800uLL);
  int v237 = -1;
  uint64_t v4 = *(void *)(v2 + 144);
  uint64_t v224 = *(void (**)(uint64_t, long long *, uint64_t *))(v2 + 88);
  uint64_t v225 = *(void (**)(void, long long *))(v2 + 96);
  uint64_t v223 = *(uint64_t (**)(uint64_t, long long *, unint64_t, size_t, void *))(v2 + 104);
  int v5 = *(_DWORD *)(v2 + 24);
  uint64_t v6 = MemBufferCreate(0x10000uLL);
  uint64_t v233 = (unint64_t *)MemBufferCreate(0x10000uLL);
  if (!v6 || !v233) {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 818, 2, 0, "MemBufferCreate", v7, v8, v214);
  }
  uint64_t v238 = 0;
  uint64_t v239 = 0;
  dev_t v240 = 0;
  if (*(void *)(*(void *)v1 + 32) <= 8uLL) {
    size_t v9 = 8;
  }
  else {
    size_t v9 = *(void *)(*(void *)v1 + 32);
  }
  size_t v236 = v9;
  uint64_t v235 = calloc(v9, 0x120uLL);
  if (!v235) {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 823, 2, 0, "malloc ACE", v10, v11, v214);
  }
  uint64_t v231 = v1 + 260;
  if (SharedArrayPush_0(v1 + 260, v3)) {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 826, 2, 0, "SharedArrayPush", v12, v13, v214);
  }
  unsigned int v226 = v5 & 1;
  uint64_t v234 = (pthread_mutex_t *)(v0 + 152);
  if (pthread_mutex_lock((pthread_mutex_t *)(v0 + 152))
    || (int v16 = *(_DWORD *)(v0 + 144), *(_DWORD *)(v0 + 144) = v16 + 1, !v16)
    && pthread_cond_broadcast((pthread_cond_t *)(v0 + 216))
    || pthread_mutex_unlock(v234))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 835, 2, 0, "SemRelease", v14, v15, v214);
  }
  uint64_t v232 = 0;
  int v17 = 0;
  size_t v230 = 0;
  uint64_t v18 = 0;
  __int16 v227 = (pthread_mutex_t *)(v1 + 298);
  uint64_t v219 = (pthread_mutex_t *)(v1 + 314);
  uint64_t v19 = " (MSU)";
  if ((v5 & 0x10000) == 0) {
    uint64_t v19 = (const char *)&unk_2106C9523;
  }
  uint64_t v218 = v19;
  int v220 = (16 * v5) & 0x40;
  int v221 = v5;
  int v229 = 7;
  char v20 = 1;
  v228 = (unint64_t *)v6;
  while (v18 != -1)
  {
    uint64_t v21 = v18;
    if (v18 == 6) {
      break;
    }
    if (v20)
    {
      if (pthread_mutex_lock((pthread_mutex_t *)(v0 + 32))) {
        goto LABEL_28;
      }
      while (1)
      {
        int v24 = *(_DWORD *)(v0 + 24);
        if (v24 > 0) {
          break;
        }
        if (pthread_cond_wait((pthread_cond_t *)(v0 + 96), (pthread_mutex_t *)(v0 + 32))) {
          goto LABEL_28;
        }
      }
      *(_DWORD *)(v0 + 24) = v24 - 1;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v0 + 32))) {
LABEL_28:
      }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 847, 2, 0, "SemAcquire", v22, v23, v214);
      ++*(void *)(v0 + 264);
    }
    if (MemBufferGetDataSize(*(void *)(v0 + 16)) || !v1[296])
    {
      char v20 = 0;
      switch((int)v18)
      {
        case 0:
        case 2:
          if ((unint64_t)MemBufferGetDataSize(*(void *)(v0 + 16)) < 4) {
            goto LABEL_99;
          }
          if (MemBufferFlushToBuffer(*(void **)(v0 + 16), 4uLL, &__dst, v29, v30, v31, v32, v33) < 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 870, 2, 0, "MemBufferFlushToBuffer", v34, v35, v214);
            char v20 = 0;
            continue;
          }
          char v20 = 0;
          *(void *)(v0 + 280) += 4;
          uint64_t v18 = 6;
          if (!(v21 | __dst)) {
            continue;
          }
          if (!v21)
          {
            char v20 = 0;
            uint64_t v18 = 1;
            if (__dst == 1) {
              continue;
            }
          }
          if (v21 == 2 && __dst == 2)
          {
            if ((BYTE1(v254) & 2) != 0)
            {
              char v20 = 0;
              uint64_t v18 = 3;
              size_t v230 = v258;
              continue;
            }
            uint64_t v18 = 2;
            __int16 v36 = 882;
            __int16 v37 = "unexpected DAT blob";
            goto LABEL_162;
          }
          if (v21 == 2 && __dst == 3)
          {
            if ((BYTE1(v254) & 4) == 0)
            {
              uint64_t v18 = 2;
              __int16 v36 = 889;
              __int16 v37 = "unexpected XAT blob";
LABEL_162:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", v36, 2, 0, v37, v34, v35, v214);
              goto LABEL_144;
            }
            char v20 = 0;
            uint64_t v18 = 3;
            size_t v230 = *((void *)&v258 + 1);
          }
          else if (v21 == 2 && __dst == 4)
          {
            if ((BYTE1(v254) & 8) == 0)
            {
              uint64_t v18 = 2;
              __int16 v36 = 896;
              __int16 v37 = "unexpected ACL blob";
              goto LABEL_162;
            }
            char v20 = 0;
            uint64_t v18 = 3;
            size_t v230 = v259;
          }
          else
          {
            char v20 = 0;
            if (__dst == 5 && v21 == 2) {
              uint64_t v18 = 4;
            }
            else {
              uint64_t v18 = 0xFFFFFFFFLL;
            }
          }
          continue;
        case 1:
          if ((unint64_t)MemBufferGetDataSize(*(void *)(v0 + 16)) < 0x8EC)
          {
            uint64_t v21 = 1;
            goto LABEL_99;
          }
          if (MemBufferFlushToBuffer(*(void **)(v0 + 16), 0x890uLL, &v254, v40, v41, v42, v43, v44) < 0)
          {
            __int16 v120 = 914;
            goto LABEL_154;
          }
          if (MemBufferFlushToBuffer(*(void **)(v0 + 16), 0x58uLL, v241, v71, v72, v73, v74, v75) < 0)
          {
            __int16 v120 = 915;
            goto LABEL_154;
          }
          if (MemBufferFlushToBuffer(*(void **)(v0 + 16), 4uLL, &v237, v76, v77, v78, v74, v75) < 0)
          {
            __int16 v120 = 916;
LABEL_154:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", v120, 2, 0, "MemBufferFlushToBuffer", v74, v75, v214);
LABEL_219:
            char v20 = 0;
            uint64_t v18 = 1;
            continue;
          }
          *(int64x2_t *)(v0 + 272) = vaddq_s64(*(int64x2_t *)(v0 + 272), (int64x2_t)xmmword_2106D4320);
          if (!v224) {
            goto LABEL_187;
          }
          uint64_t v238 = 0;
          uint64_t v239 = 0;
          dev_t v240 = 0;
          v224(v4, &v254, &v238);
          if (v238)
          {
            LODWORD(v254) = v254 | 2;
            DWORD2(v254) = HIDWORD(v238);
            if ((v238 & 2) == 0)
            {
LABEL_80:
              if ((v238 & 8) == 0) {
                goto LABEL_81;
              }
              goto LABEL_165;
            }
          }
          else if ((v238 & 2) == 0)
          {
            goto LABEL_80;
          }
          LODWORD(v254) = v254 | 4;
          HIDWORD(v254) = v239;
          if ((v238 & 8) == 0)
          {
LABEL_81:
            if ((v238 & 4) == 0) {
              goto LABEL_83;
            }
LABEL_82:
            LODWORD(v254) = v254 | 8;
            v255[0] = HIDWORD(v239);
            goto LABEL_83;
          }
LABEL_165:
          LODWORD(v254) = v254 | 0x10;
          v255[1] = v240;
          if ((v238 & 4) != 0) {
            goto LABEL_82;
          }
LABEL_83:
          if ((v238 & 0xF) == 0) {
            goto LABEL_187;
          }
          int v79 = v237;
          if (pthread_mutex_lock(v227))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueOverrideAttributes", 392, 2, 0, "pthread_mutex_lock", v80, v81, v214);
            goto LABEL_86;
          }
          uint64_t v148 = (_DWORD *)inFlightQueueEntry(v1, v79);
          if (!v148)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueOverrideAttributes", 396, 2, 0, "couldn't locate entry [%d] in queue", v149, v150, v79);
            pthread_mutex_unlock(v227);
LABEL_86:
            __int16 v84 = 937;
            uint64_t v85 = "override attributes";
LABEL_217:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", v84, 2, 0, v85, v82, v83, v214);
LABEL_218:
            int v229 = 0;
            goto LABEL_219;
          }
          char v151 = v238;
          if (v238)
          {
            *v148 |= 2u;
            v148[2] = HIDWORD(v238);
            char v151 = v238;
            if ((v238 & 2) == 0)
            {
LABEL_183:
              if ((v151 & 8) == 0) {
                goto LABEL_184;
              }
              goto LABEL_223;
            }
          }
          else if ((v238 & 2) == 0)
          {
            goto LABEL_183;
          }
          *v148 |= 4u;
          v148[3] = v239;
          char v151 = v238;
          if ((v238 & 8) == 0)
          {
LABEL_184:
            if ((v151 & 4) == 0) {
              goto LABEL_186;
            }
LABEL_185:
            *v148 |= 8u;
            v148[4] = HIDWORD(v239);
            goto LABEL_186;
          }
LABEL_223:
          *v148 |= 0x10u;
          v148[5] = v240;
          if ((v238 & 4) != 0) {
            goto LABEL_185;
          }
LABEL_186:
          pthread_mutex_unlock(v227);
LABEL_187:
          atomic_fetch_add_explicit((atomic_ullong *volatile)v1 + 191, 1uLL, memory_order_relaxed);
          if (**(int **)v1 >= 3) {
            fprintf((FILE *)*MEMORY[0x263EF8348], "[%7d] begin: %s\n", v237, (const char *)v263);
          }
          if ((concatExtractPath((char *)v253, 0x800uLL, (char *)v1 + 12, (const char *)v263) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 943, 2, 0, "invalid path: %s", v152, v153, (char)v263);
            goto LABEL_218;
          }
          __int16 v154 = v254;
          if ((v254 & 0x400) != 0)
          {
            if ((MemBufferIncreaseCapacity((uint64_t)v6, *((size_t *)&v258 + 1)) & 0x8000000000000000) != 0)
            {
              __int16 v84 = 948;
              uint64_t v85 = "allocate XAT blob";
              goto LABEL_217;
            }
            __int16 v154 = v254;
          }
          if ((v154 & 0x800) != 0 && (MemBufferIncreaseCapacity((uint64_t)v233, v259) & 0x8000000000000000) != 0)
          {
            __int16 v84 = 952;
            uint64_t v85 = "allocate ACL blob";
            goto LABEL_217;
          }
          if (!MemBufferIsEmpty((uint64_t)v6) || !MemBufferIsEmpty((uint64_t)v233))
          {
            __int16 v84 = 956;
            uint64_t v85 = "XAT/ACL blob is not empty";
            goto LABEL_217;
          }
          switch(DWORD1(v254))
          {
            case 'B':
            case 'C':
              if (v222 >= 3)
              {
                unint64_t v155 = "CHAR";
                if (DWORD1(v254) == 66) {
                  unint64_t v155 = "BLOCK";
                }
                fprintf((FILE *)*MEMORY[0x263EF8348], "[%7d] %s SPECIAL: %s\n", v237, v155, (const char *)v253);
              }
              if ((v254 & 0x20) == 0) {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1183, 2, 0, "DEV field is not set for a block/char special entry", v82, v83, v214);
              }
              unlink((const char *)v253);
              __int16 v156 = v255[1];
              if ((v254 & 0x10) == 0) {
                __int16 v156 = 420;
              }
              if (DWORD1(v254) == 66) {
                __int16 v157 = 24576;
              }
              else {
                __int16 v157 = 0x2000;
              }
              int v158 = mknod((const char *)v253, v157 | v156, v255[2]);
              char v20 = 0;
              uint64_t v18 = 2;
              int v229 = 3;
              if (v158)
              {
                pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1197, 2, "mknod %s", v159, v160, v161, (char)v253);
                goto LABEL_248;
              }
              continue;
            case 'D':
              char v20 = 0;
              uint64_t v18 = 2;
              int v229 = 1;
              if (v222 >= 3)
              {
                fprintf((FILE *)*MEMORY[0x263EF8348], "[%7d] DIR deferred: %s\n");
                goto LABEL_236;
              }
              continue;
            case 'E':
            case 'G':
            case 'I':
            case 'J':
            case 'K':
            case 'M':
            case 'N':
            case 'O':
            case 'Q':
            case 'R':
              goto LABEL_228;
            case 'F':
              uint64_t v162 = v3;
              int v163 = v1[259];
              BOOL v164 = (v254 & 8) != 0 && statIsCompressed(v255[0]) && (void)v258 != 0;
              if (v222 >= 3)
              {
                unsigned int v185 = (const char *)&unk_2106C9523;
                if (v164) {
                  unsigned int v185 = " (C)";
                }
                fprintf((FILE *)*MEMORY[0x263EF8348], "[%7d] FILE writing %s%s: %s\n", v237, v185, v218, (const char *)v263);
              }
              if (v164)
              {
                if ((v241[0] & 0x20) != 0
                  && (int v186 = v242 - 3, (v242 - 3) <= 0xB)
                  && ((0xFF3u >> v186) & 1) != 0)
                {
                  int v187 = dword_2106D4340[v186];
                  int v163 = dword_2106D4370[v186];
                }
                else
                {
                  int v187 = 4;
                }
              }
              else
              {
                int v187 = 0;
              }
              int v188 = v187 | v220;
              if ((v221 & 0x10000) != 0) {
                int v189 = v188 | 0x2B;
              }
              else {
                int v189 = v188;
              }
              if ((v221 & 0x10) != 0)
              {
                if ((v241[0] & 0x80) != 0) {
                  int v190 = DWORD2(v242);
                }
                else {
                  int v190 = -1;
                }
              }
              else
              {
                int v190 = -1;
              }
              removeFile((const char *)v253);
              saveThreadErrorContext(__s);
              int v17 = OArchiveFileStreamCreate((const char *)v253, v258, v189 | 0x100u, v190, v163);
              if (!v17)
              {
                pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1050, 2, "OArchiveFileStreamCreate: %s", v191, v192, v193, (char)v253);
                restoreThreadErrorContext(__s);
              }
              char v20 = 0;
              int v229 = 2;
              uint64_t v18 = 2;
              uint64_t v3 = v162;
              uint64_t v6 = (void **)v228;
              continue;
            case 'H':
              char v20 = 0;
              uint64_t v18 = 2;
              int v229 = 1;
              if (v222 < 3) {
                continue;
              }
              fprintf((FILE *)*MEMORY[0x263EF8348], "[%7d] HLINK (legacy) deferred: %s\n");
              goto LABEL_236;
            case 'L':
              if (v222 >= 3) {
                fprintf((FILE *)*MEMORY[0x263EF8348], "[%7d] SLINK: %s -> %s\n", v237, (const char *)v263, v264);
              }
              unlink((const char *)v253);
              int v165 = symlink(v264, (const char *)v253);
              char v20 = 0;
              uint64_t v18 = 2;
              int v229 = 3;
              if (!v165) {
                continue;
              }
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1074, 2, "symlink %s -> %s", v166, v167, v168, (char)v253);
              goto LABEL_248;
            case 'P':
              if (v222 >= 3) {
                fprintf((FILE *)*MEMORY[0x263EF8348], "[%7d] FIFO: %s\n", v237, (const char *)v263);
              }
              unlink((const char *)v253);
              if ((v254 & 0x10) != 0) {
                mode_t v169 = LOWORD(v255[1]) | 0x1000;
              }
              else {
                mode_t v169 = 4516;
              }
              int v170 = mkfifo((const char *)v253, v169);
              char v20 = 0;
              uint64_t v18 = 2;
              int v229 = 3;
              if (!v170) {
                continue;
              }
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1096, 2, "mkfifo %s", v171, v172, v173, (char)v253);
LABEL_248:
              char v20 = 0;
              int v229 = 7;
              continue;
            case 'S':
              if (v222 >= 3) {
                fprintf((FILE *)*MEMORY[0x263EF8348], "[%7d] SOCKET: %s\n", v237, (const char *)v263);
              }
              unlink((const char *)v253);
              bzero(__s, 0x400uLL);
              bzero(v251, 0x400uLL);
              long long v249 = 0u;
              memset(v250, 0, sizeof(v250));
              long long v247 = 0u;
              long long v248 = 0u;
              sockaddr v245 = (sockaddr)0;
              long long v246 = 0u;
              __strlcpy_chk();
              uint64_t v174 = strrchr((char *)__s, 47);
              if (!v174)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1125, 2, 0, "could not determine parent directory: %s", v175, v176, (char)v253);
LABEL_283:
                int v229 = 3;
                goto LABEL_115;
              }
              *uint64_t v174 = 0;
              long long v249 = 0u;
              memset(v250, 0, sizeof(v250));
              long long v247 = 0u;
              long long v248 = 0u;
              sockaddr v245 = (sockaddr)0;
              long long v246 = 0u;
              __strlcpy_chk();
              v245.sa_len = strlen(v245.sa_data) + 3;
              v245.sa_family = 1;
              int v177 = socket(1, 1, 0);
              if (v177 < 0)
              {
                int v194 = *__error();
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1150, 2, v194, "socket failed: %s", v195, v196, (char)v253);
                goto LABEL_283;
              }
              int v217 = v177;
              if (pthread_mutex_lock(v219) < 0)
              {
                int v178 = __error();
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1157, 2, *v178, "locking chdir_mutex failed: %s", v179, v180, (char)v253);
              }
              if (getcwd(v251, 0x400uLL))
              {
                if (chdir((const char *)__s) < 0 || bind(v217, &v245, 0x6Au) < 0)
                {
                  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1164, 2, "chdir+bind failed: %s/%s", v181, v182, v183, (char)__s);
                  int v184 = 7;
                }
                else
                {
                  int v184 = 3;
                }
                int v229 = v184;
                if (chdir(v251) < 0)
                {
                  long long v197 = __error();
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1168, 2, *v197, "chdir failed: %s", v198, v199, (char)v251);
                }
              }
              else
              {
                long long v200 = __error();
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1170, 2, *v200, "getcwd failed: %s", v201, v202, (char)v253);
                int v229 = 3;
              }
              if (pthread_mutex_unlock(v219) < 0)
              {
                long long v203 = __error();
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1171, 2, *v203, "unlocking chdir_mutex failed: %s", v204, v205, (char)v253);
              }
              close(v217);
              break;
            default:
              if ((DWORD1(v254) - 120) >= 2)
              {
LABEL_228:
                uint64_t v18 = 2;
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1205, 2, 0, "unsupported entry type", v82, v83, v214);
                int v229 = 0;
                goto LABEL_144;
              }
              char v20 = 0;
              uint64_t v18 = 2;
              int v229 = 1;
              if (v222 >= 3)
              {
                fprintf((FILE *)*MEMORY[0x263EF8348], "[%7d] HLINK/CLONE deferred: %s\n");
LABEL_236:
                char v20 = 0;
                int v229 = 1;
              }
              continue;
          }
          goto LABEL_115;
        case 3:
          unint64_t DataSize = MemBufferGetDataSize(*(void *)(v0 + 16));
          uint64_t DataPtr = (void *)MemBufferGetDataPtr(*(void *)(v0 + 16));
          if (DataSize >= v230) {
            size_t v52 = v230;
          }
          else {
            size_t v52 = DataSize;
          }
          *(void *)(v0 + 280) += v52;
          switch(__dst)
          {
            case 4:
              if (MemBufferFillFromBuffer(v233, v52, DataPtr) < 0)
              {
                __int16 v103 = 1239;
                int v104 = "storing ACL blob contents";
LABEL_148:
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", v103, 2, 0, v104, v50, v51, v214);
                char v20 = 0;
                uint64_t v18 = 3;
                uint64_t v6 = (void **)v228;
                continue;
              }
              break;
            case 3:
              if (MemBufferFillFromBuffer(v228, v52, DataPtr) < 0)
              {
                __int16 v103 = 1234;
                int v104 = "storing XAT blob contents";
                goto LABEL_148;
              }
              break;
            case 2:
              if (!v17 || OArchiveFileStreamWrite((uint64_t)v17, (char *)DataPtr, v52, v47, v48, v49, v50, v51) != v52)
              {
                pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1227, 2, "OArchiveFileStreamWrite", v49, v50, v51, v214);
                int v229 = 7;
              }
              break;
            default:
              __int16 v103 = 1241;
              int v104 = "invalid op in BLOB PAYLOAD";
              goto LABEL_148;
          }
          MemBufferDecreaseSize(*(void *)(v0 + 16), v52, v53, v54, v55, v49, v50, v51);
          v230 -= v52;
          if (v230)
          {
            uint64_t v21 = 3;
            uint64_t v6 = (void **)v228;
            goto LABEL_99;
          }
          size_t v230 = 0;
          char v20 = 0;
          uint64_t v18 = 2;
          uint64_t v6 = (void **)v228;
          if (__dst == 4)
          {
            char v20 = 0;
            size_t v230 = 0;
            if ((BYTE1(v254) & 8) != 0)
            {
              if ((void)v259)
              {
                uint64_t v109 = MemBufferGetDataSize((uint64_t)v233);
                uint64_t v110 = MemBufferGetDataPtr((uint64_t)v233);
                int64_t v116 = yaa_decodeACL((uint64_t)&v254, &v236, &v235, v109, v110, v111, v112, v113);
                if (v116 < 0) {
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1255, 2, 0, "decodeEntryACL", v114, v115, v214);
                }
                unint64_t v117 = v116 & ~(v116 >> 63);
                if (v223)
                {
                  unint64_t v117 = v223(v4, &v254, v117, v236, v235);
                  if (v117 > v236)
                  {
                    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1262, 2, 0, "invalid user ACL callback return value", v118, v119, v214);
                    unint64_t v117 = 0;
                  }
                }
                uint64_t v232 = v117;
                MemBufferClear(v233);
                size_t v230 = 0;
LABEL_115:
                char v20 = 0;
                uint64_t v18 = 2;
              }
            }
          }
          break;
        case 4:
          *(void *)&__s[0] = 0;
          if ((unint64_t)MemBufferGetDataSize(*(void *)(v0 + 16)) < 8)
          {
            uint64_t v21 = 4;
            goto LABEL_99;
          }
          if (MemBufferFlushToBuffer(*(void **)(v0 + 16), 8uLL, __s, v56, v57, v58, v59, v60) < 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1283, 2, 0, "MemBufferFlushToBuffer", v86, v87, v214);
            uint64_t v18 = 4;
            goto LABEL_144;
          }
          *(void *)(v0 + 280) += 8;
          int v88 = v237;
          uint64_t v89 = *(void *)&__s[0];
          if (pthread_mutex_lock(v227))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueStoreEntryEnd", 415, 2, 0, "pthread_mutex_lock", v90, v91, v214);
LABEL_90:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1285, 2, 0, "store entryEnd", v92, v93, v215);
            goto LABEL_143;
          }
          uint64_t v142 = inFlightQueueEntry(v1, v88);
          if (!v142)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueStoreEntryEnd", 419, 2, 0, "couldn't locate entry [%d] in queue", v143, v144, v88);
            pthread_mutex_unlock(v227);
            goto LABEL_90;
          }
          *(void *)(v142 + 2312) = v89;
          pthread_mutex_unlock(v227);
LABEL_143:
          uint64_t v18 = 5;
LABEL_144:
          char v20 = 0;
          continue;
        case 5:
          unint64_t v61 = (unsigned int *)v17;
          int v62 = v229;
          if (v61)
          {
            *(void *)&__s[0] = 0;
            *(void *)uint64_t v251 = 0;
            OArchiveFileStreamDestroyEx(v61, 0, __s, v251, v25, v26, v27, v28);
            uint64_t v63 = *(void *)(v0 + 296) + *(void *)v251;
            *(void *)(v0 + 288) += *(void *)&__s[0];
            *(void *)(v0 + 296) = v63;
            if ((v254 & 8) != 0
              && statIsCompressed(v255[0])
              && (void)v258
              && (v241[0] & 0x20) != 0
              && (v241[0] & 0x40) != 0
              && DWORD1(v242)
              && (ParallelCompressionAFSCFixupMetadata(v253, v242, DWORD1(v242)) & 0x80000000) != 0)
            {
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1310, 2, "ParallelCompressionAFSCFixupMetadata failed: %s (aft=%d afr=%u)", v64, v65, v66, (char)v253);
            }
          }
          if (v229 == 2) {
            int v62 = 3;
          }
          if (v62 == 7) {
            goto LABEL_130;
          }
          if (v62 == 3)
          {
            saveThreadErrorContext(__s);
            if (yaa_setEntryAttributes((char *)v253, (int *)&v254, (uint64_t)v241, v226))
            {
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1329, 2, "setEntryAttributes: %s", v67, v68, v69, (char)v253);
              int v70 = 7;
            }
            else
            {
              int v70 = 3;
            }
            if ((BYTE1(v254) & 4) != 0)
            {
              unint64_t v121 = MemBufferGetDataSize((uint64_t)v6);
              __int16 v122 = (unsigned int *)MemBufferGetDataPtr((uint64_t)v6);
              if (yaa_setEntryXAT((char *)v253, (uint64_t)&v254, v226, v121, v122, v123, v124, v125))
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1338, 2, 0, "setEntryXAT: %s", v126, v127, (char)v253);
                int v70 = 7;
              }
            }
            if ((BYTE1(v254) & 8) != 0
              && yaa_setEntryACL((const char *)v253, (uint64_t)&v254, v226, v232, (uint64_t)v235))
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1348, 2, 0, "setEntryACL: %s", v128, v129, (char)v253);
              int v70 = 7;
            }
            if (v225) {
              v225(*(void *)(*(void *)v1 + 144), &v254);
            }
            atomic_fetch_add_explicit((atomic_ullong *volatile)v1 + 191, 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
            if (v70 == 7)
            {
              restoreThreadErrorContext(__s);
              int v62 = 7;
            }
            else
            {
              int v62 = 4;
            }
          }
          else
          {
            int v229 = v62;
            *(void *)uint64_t v216 = v4;
            uint64_t v94 = v3;
            int v95 = v237;
            size_t v96 = MemBufferGetDataSize((uint64_t)v6);
            uint64_t v97 = (const void *)MemBufferGetDataPtr((uint64_t)v6);
            uint64_t v98 = v235;
            if (pthread_mutex_lock(v227))
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueStoreBlobs", 436, 2, 0, "pthread_mutex_lock", v99, v100, v214);
              uint64_t v3 = v94;
              uint64_t v4 = *(void *)v216;
              uint64_t v6 = (void **)v228;
              goto LABEL_178;
            }
            uint64_t v132 = inFlightQueueEntry(v1, v95);
            if (!v132)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueStoreBlobs", 440, 2, 0, "couldn't locate entry [%d] in queue", v133, v134, v95);
              goto LABEL_176;
            }
            uint64_t v135 = v132;
            if (v96)
            {
              uint64_t v136 = MemBufferCreateWithData(v96, v97);
              *(void *)(v135 + 2280) = v136;
              if (!v136)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueStoreBlobs", 445, 2, 0, "allocating XAT blob", v137, v138, v214);
LABEL_176:
                uint64_t v3 = v94;
LABEL_177:
                pthread_mutex_unlock(v227);
                uint64_t v4 = *(void *)v216;
                uint64_t v6 = (void **)v228;
LABEL_178:
                __int16 v130 = 1372;
                int v131 = "store XAT and ACL blobs in entry";
LABEL_179:
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", v130, 2, 0, v131, v101, v102, v214);
                int v17 = 0;
                char v20 = 0;
                uint64_t v18 = 5;
                continue;
              }
            }
            if (v232)
            {
              pthread_mutex_t v139 = MemBufferCreateWithData(288 * v232, v98);
              *(void *)(v135 + 2288) = v139;
              if (!v139)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueStoreBlobs", 450, 2, 0, "allocating ACL blob", v140, v141, v214);
                uint64_t v3 = v94;
                goto LABEL_177;
              }
            }
            pthread_mutex_unlock(v227);
            uint64_t v3 = v94;
            uint64_t v4 = *(void *)v216;
            uint64_t v6 = (void **)v228;
            int v62 = v229;
          }
LABEL_130:
          int v229 = v62;
          if (inFlightQueueRetire())
          {
            __int16 v130 = 1380;
            int v131 = "retiring entry from in-flight state";
            goto LABEL_179;
          }
          if (MemBufferGetDataSize(*(void *)(v0 + 16)))
          {
            __int16 v130 = 1383;
            int v131 = "buffer is not empty";
            goto LABEL_179;
          }
          int v237 = -1;
          MemBufferClear(v6);
          MemBufferClear(v233);
          if (SharedArrayPush_0(v231, v3))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1398, 2, 0, "SharedArrayPush", v145, v146, v214);
            int v17 = 0;
            uint64_t v232 = 0;
            uint64_t v21 = 5;
            goto LABEL_99;
          }
          uint64_t v21 = 0;
          int v17 = 0;
          goto LABEL_45;
        case 6:
          goto LABEL_99;
        case 7:
          goto LABEL_42;
        default:
          continue;
      }
    }
    else
    {
LABEL_42:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1406, 2, 0, "aborting entry", v27, v28, v214);
      int v237 = -1;
      MemBufferClear(v6);
      MemBufferClear(v233);
      if (SharedArrayPush_0(v231, v3))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1421, 2, 0, "SharedArrayPush", v38, v39, v214);
        uint64_t v232 = 0;
        uint64_t v21 = 7;
      }
      else
      {
        uint64_t v21 = 0;
LABEL_45:
        uint64_t v232 = 0;
      }
LABEL_99:
      if (pthread_mutex_lock(v234)
        || (int v107 = *(_DWORD *)(v0 + 144), *(_DWORD *)(v0 + 144) = v107 + 1, !v107)
        && pthread_cond_broadcast((pthread_cond_t *)(v0 + 216))
        || (v108 = pthread_mutex_unlock(v234), v20 = 1, uint64_t v18 = v21, v108))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1443, 2, 0, "SemRelease", v105, v106, v214);
        char v20 = 1;
        uint64_t v18 = v21;
      }
    }
  }
  MemBufferDestroy(v6);
  MemBufferDestroy((void **)v233);
  OArchiveFileStreamDestroy((unsigned int *)v17, v206, v207, v208, v209, v210, v211, v212);
  free(v235);
  return 0;
}

void extractBeginProc()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  uint64_t v11 = v0;
  uint64_t v98 = *MEMORY[0x263EF8340];
  bzero(v97, 0x800uLL);
  unint64_t v95 = 0;
  *(_OWORD *)uint64_t v93 = 0u;
  long long v94 = 0u;
  memset(v92, 0, sizeof(v92));
  bzero(__dst, 0x890uLL);
  uint64_t v12 = (int *)(v11 + 1320);
  *(_OWORD *)(v11 + 1320) = xmmword_2106D4330;
  uint64_t v13 = *(void *)(v11 + 1368);
  *(void *)(v11 + 1352) = v13;
  *(void *)(v11 + 1368) = v13 + v2;
  *(void *)(v11 + 1336) = 0xFFFFFFFF00000000;
  if (*(_DWORD *)(v11 + 1184)) {
    return;
  }
  if (v10[1] != 77)
  {
    memcpy(__dst, v10, sizeof(__dst));
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 1504), 1uLL, memory_order_relaxed);
    *(_DWORD *)(v11 + 1324) = 0;
    uint64_t v19 = *(void *)v11;
    char v20 = *(uint64_t (**)(void, void *))(*(void *)v11 + 72);
    if (v20)
    {
      if ((*(unsigned char *)(v19 + 26) & 2) != 0)
      {
        LODWORD(__dst[0]) |= 0x40u;
        __dst[4] = v13;
      }
      LODWORD(v20) = v20(*(void *)(v19 + 144), __dst) == 0;
      *(_DWORD *)(v11 + 1324) = v20;
    }
    unint64_t v21 = 0;
    if (v6)
    {
      unint64_t v22 = 0;
      unint64_t v23 = 0;
      unsigned int v24 = 0;
      unsigned int v25 = 0;
      int v26 = 0;
      unint64_t v27 = 0;
      int v28 = 0;
      uint64_t v29 = (unint64_t *)(v8 + 8);
      long long v30 = 0uLL;
      uint64_t v16 = 4410435;
      uint64_t v17 = 4410440;
      uint64_t v18 = 4410451;
      long long v31 = 0uLL;
      do
      {
        unsigned int v32 = *(_DWORD *)(v29 - 1) & 0xDFDFDF;
        if (v32 <= 0x494C45)
        {
          if ((*(_DWORD *)(v29 - 1) & 0xDFDFDFu) > 0x434C52)
          {
            if (v32 == 4410451)
            {
              v28 |= 0x10u;
              unint64_t v23 = *v29;
            }
            else if (v32 == 4411984)
            {
              v28 |= 0x80u;
              switch(*v29)
              {
                case 'A':
                  int v26 = 1;
                  break;
                case 'B':
                  int v26 = 2;
                  break;
                case 'C':
                  int v26 = 3;
                  break;
                case 'D':
                  int v26 = 4;
                  break;
                case 'E':
                  int v26 = 5;
                  break;
                case 'F':
                  int v26 = 6;
                  break;
                default:
                  int v26 = -1;
                  break;
              }
            }
          }
          else if (v32 == 4410435)
          {
            v28 |= 8u;
            unint64_t v22 = *v29;
          }
          else if (v32 == 4410440)
          {
            v28 |= 4u;
            unint64_t v21 = *v29;
          }
        }
        else if ((*(_DWORD *)(v29 - 1) & 0xDFDFDFu) <= 0x4D5442)
        {
          if (v32 == 4803654)
          {
            v28 |= 0x100u;
            unint64_t v27 = *v29;
          }
          else if (v32 == 5067842)
          {
            v28 |= 2u;
            long long v31 = *(_OWORD *)v29;
          }
        }
        else
        {
          switch(v32)
          {
            case 0x544641u:
              v28 |= 0x20u;
              unsigned int v24 = *(_DWORD *)v29;
              break;
            case 0x524641u:
              v28 |= 0x40u;
              unsigned int v25 = *(_DWORD *)v29;
              break;
            case 0x4D5443u:
              v28 |= 1u;
              long long v30 = *(_OWORD *)v29;
              break;
          }
        }
        v29 += 129;
        --v6;
      }
      while (v6);
      unint64_t v95 = v27;
      DWORD2(v94) = v26;
      *(void *)&long long v94 = __PAIR64__(v25, v24);
      *(void *)uint64_t v93 = v22;
      *(void *)&v93[2] = v23;
      *((void *)&v92[2] + 1) = v21;
      *(_OWORD *)((char *)&v92[1] + 8) = v31;
      *(_OWORD *)((char *)v92 + 8) = v30;
    }
    else
    {
      LOWORD(v28) = 0;
    }
    LOWORD(v92[0]) = v28;
    if (!v20 && HIDWORD(__dst[0]) == 70)
    {
      if ((v28 & 4) != 0 && v21 != -1)
      {
        int v33 = clusterLookup(v11 + 1456, v21, (char *)&__dst[18], (char *)&__dst[146], 0x400uLL, v16, v17, v18);
        if (v33 < 0)
        {
          int v43 = *__error();
          uint64_t v41 = "looking up cluster";
          __int16 v42 = 1589;
          goto LABEL_69;
        }
        if (v33)
        {
          HIDWORD(__dst[0]) = 120;
          *(_DWORD *)(v11 + 1336) = 1;
          atomic_fetch_add((atomic_ullong *volatile)(v11 + 1552), __dst[8]);
        }
      }
      if (HIDWORD(__dst[0]) == 70)
      {
        if ((v92[0] & 8) != 0 && *(void *)v93 != -1)
        {
          int v34 = clusterLookup(v11 + 1472, *(unint64_t *)v93, (char *)&__dst[18], (char *)&__dst[146], 0x400uLL, v16, v17, v18);
          if (v34 < 0)
          {
            int v43 = *__error();
            uint64_t v41 = "looking up cluster";
            __int16 v42 = 1611;
            goto LABEL_69;
          }
          if (v34)
          {
            HIDWORD(__dst[0]) = 121;
            *(_DWORD *)(v11 + 1336) = 1;
            atomic_fetch_add((atomic_ullong *volatile)(v11 + 1560), __dst[8]);
          }
        }
        if (HIDWORD(__dst[0]) == 70 && (v92[0] & 0x10) != 0 && *(void *)&v93[2] != -1 && *(_DWORD *)(v11 + 8))
        {
          int v35 = clusterLookup(v11 + 1488, *(unint64_t *)&v93[2], (char *)&__dst[18], (char *)&__dst[146], 0x400uLL, v16, v17, v18);
          if (v35 < 0)
          {
            int v43 = *__error();
            uint64_t v41 = "looking up cluster";
            __int16 v42 = 1633;
            goto LABEL_69;
          }
          if (v35)
          {
            HIDWORD(__dst[0]) = 121;
            *(_DWORD *)(v11 + 1336) = 1;
            atomic_fetch_add((atomic_ullong *volatile)(v11 + 1568), __dst[8]);
          }
        }
      }
    }
    unint64_t v36 = *(void *)(v11 + 1352);
    if (pthread_mutex_lock((pthread_mutex_t *)(v11 + 1192)))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueInsert", 316, 2, 0, "pthread_mutex_lock", v37, v38, (char)v90);
LABEL_66:
      *uint64_t v12 = -1;
      goto LABEL_67;
    }
    size_t v44 = *(void *)(v11 + 1392);
    size_t v45 = *(void *)(v11 + 1384);
    if (v44 >= v45)
    {
      if (v45) {
        v45 += v45 >> 1;
      }
      else {
        size_t v45 = 128;
      }
      uint64_t v46 = (char *)calloc(v45, 0x910uLL);
      if (!v46)
      {
        uint64_t v76 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueInsert", 327, 2, *v76, "malloc", v77, v78, (char)v90);
        pthread_mutex_unlock((pthread_mutex_t *)(v11 + 1192));
        goto LABEL_66;
      }
      uint64_t v47 = v46;
      if (*(void *)(v11 + 1392))
      {
        unint64_t v48 = 0;
        unint64_t v49 = *(void *)(v11 + 1400);
        uint64_t v50 = v46;
        do
        {
          memcpy(v50, (const void *)(*(void *)(v11 + 1416) + 2320 * v49), 0x910uLL);
          unint64_t v51 = *(void *)(v11 + 1384);
          if (v49 + 1 < v51) {
            unint64_t v51 = 0;
          }
          unint64_t v49 = v49 + 1 - v51;
          ++v48;
          v50 += 2320;
        }
        while (v48 < *(void *)(v11 + 1392));
      }
      free(*(void **)(v11 + 1416));
      *(void *)(v11 + 1416) = v47;
      *(void *)(v11 + 1384) = v45;
      *(void *)(v11 + 1400) = 0;
      size_t v44 = *(void *)(v11 + 1392);
    }
    if (v44)
    {
      uint64_t v52 = *(void *)(v11 + 1400);
    }
    else
    {
      uint64_t v52 = 0;
      *(void *)(v11 + 1400) = 0;
    }
    size_t v53 = v52 + v44;
    if (v53 >= v45) {
      size_t v54 = v45;
    }
    else {
      size_t v54 = 0;
    }
    uint64_t v55 = *(void *)(v11 + 1416) + 2320 * (v53 - v54);
    int v56 = *(_DWORD *)(v11 + 1376);
    *(_DWORD *)(v11 + 1376) = v56 + 1;
    bzero((void *)v55, 0x910uLL);
    memcpy((void *)v55, __dst, 0x890uLL);
    long long v57 = v92[0];
    *(_OWORD *)(v55 + 2208) = v92[1];
    *(_OWORD *)(v55 + 2192) = v57;
    long long v58 = v92[2];
    long long v59 = *(_OWORD *)v93;
    long long v60 = v94;
    *(void *)(v55 + 2272) = v95;
    *(_OWORD *)(v55 + 2256) = v60;
    *(_OWORD *)(v55 + 2240) = v59;
    *(_OWORD *)(v55 + 2224) = v58;
    *(_DWORD *)(v55 + 2296) = v56;
    *(int64x2_t *)(v55 + 2304) = vdupq_n_s64(v36);
    *(_DWORD *)(v55 + 2300) = 0;
    unint64_t v61 = *(void *)(v11 + 1392) + 1;
    *(void *)(v11 + 1392) = v61;
    if (v61 > *(void *)(v11 + 1408)) {
      *(void *)(v11 + 1408) = v61;
    }
    if (**(int **)v11 >= 3) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "[%7d] inserted: %s\n", v56, (const char *)&__dst[18]);
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v11 + 1192));
    *uint64_t v12 = v56;
    if ((v56 & 0x80000000) == 0)
    {
      if (*(_DWORD *)(v11 + 1324)) {
        return;
      }
      int v62 = 1;
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 1512), 1uLL, memory_order_relaxed);
      if ((concatExtractPath(v97, 0x800uLL, (char *)(v11 + 12), (const char *)&__dst[18]) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractBeginProc", 1671, 2, 0, "invalid path: %s", v63, v64, (char)&__dst[18]);
        int v62 = 0;
      }
      int v65 = HIDWORD(__dst[0]);
      if (HIDWORD(__dst[0]) == 68)
      {
        if (**(int **)v11 >= 3) {
          fprintf((FILE *)*MEMORY[0x263EF8348], "[%7d] DIR mkdir: %s\n", *v12, (const char *)&__dst[18]);
        }
        memset(&v91, 0, sizeof(v91));
        if (!lstat(v97, &v91) && (v91.st_mode & 0xF000) != 0x4000) {
          unlink(v97);
        }
        if (mkdir(v97, 0x1EDu) && *__error() != 17)
        {
          uint64_t v66 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractBeginProc", 1687, 2, *v66, "%s", v67, v68, (char)v97);
          int v62 = 0;
        }
        if ((__dst[0] & 6) != 0)
        {
          if ((__dst[0] & 4) != 0) {
            gid_t v69 = HIDWORD(__dst[1]);
          }
          else {
            gid_t v69 = -1;
          }
          if ((__dst[0] & 2) != 0) {
            uid_t v70 = __dst[1];
          }
          else {
            uid_t v70 = -1;
          }
          chown(v97, v70, v69);
        }
        int v65 = HIDWORD(__dst[0]);
      }
      if (v65 == 70 && (__dst[0] & 0x200) == 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractBeginProc", 1701, 2, 0, "Regular file is missing DAT blob: %s", v63, v64, (char)&__dst[18]);
        int v62 = 0;
      }
      if (pthread_mutex_lock((pthread_mutex_t *)(v11 + 1056)))
      {
        uint64_t v74 = "SharedArrayPop: pthread_mutex_lock failed\n";
        __int16 v75 = 91;
      }
      else
      {
        while (1)
        {
          int v79 = *(_DWORD *)(v11 + 1040);
          if (v79) {
            break;
          }
          if (pthread_cond_wait((pthread_cond_t *)(v11 + 1120), (pthread_mutex_t *)(v11 + 1056)))
          {
            uint64_t v74 = "SharedArrayPop: pthread_cond_wait failed\n";
            __int16 v75 = 94;
            goto LABEL_128;
          }
        }
        unsigned int v80 = v79 - 1;
        *(_DWORD *)(v11 + 1040) = v80;
        *(_DWORD *)(v11 + 1340) = *(_DWORD *)(*(void *)(v11 + 1048) + 4 * v80);
        if (!pthread_mutex_unlock((pthread_mutex_t *)(v11 + 1056)))
        {
          uint64_t v81 = *(void *)(v11 + 1176) + 304 * *(unsigned int *)(v11 + 1340);
          if (SemAcquire(v81 + 144))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractBeginProc", 1721, 2, 0, "SemAcquire", v82, v83, (char)v90);
            int v62 = 0;
          }
          *(_DWORD *)(v11 + 1344) = 1;
          v91.st_dev = 1;
          if (writeToThread(v81, (char *)&v91, 4uLL))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractBeginProc", 1729, 2, 0, "writeToThread", v84, v85, (char)v90);
            int v62 = 0;
          }
          if (writeToThread(v81, (char *)__dst, 0x890uLL))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractBeginProc", 1730, 2, 0, "writeToThread", v86, v87, (char)v90);
            int v62 = 0;
          }
          if (writeToThread(v81, (char *)v92, 0x58uLL))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractBeginProc", 1731, 2, 0, "writeToThread", v88, v89, (char)v90);
            if (!writeToThread(v81, (char *)(v11 + 1320), 4uLL)) {
              goto LABEL_70;
            }
          }
          else if (!writeToThread(v81, (char *)(v11 + 1320), 4uLL))
          {
            if (v62) {
              return;
            }
LABEL_70:
            *(_DWORD *)(v11 + 1184) = 1;
            return;
          }
          uint64_t v41 = "writeToThread";
          __int16 v42 = 1732;
          goto LABEL_68;
        }
        uint64_t v74 = "SharedArrayPop: pthread_mutex_unlock failed\n";
        __int16 v75 = 98;
      }
LABEL_128:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v75, 0, v74, v71, v72, v73, (char)v90);
      uint64_t v41 = "SharedArrayPop";
      __int16 v42 = 1710;
LABEL_68:
      int v43 = 0;
LABEL_69:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractBeginProc", v42, 2, v43, v41, v39, v40, (char)v90);
      goto LABEL_70;
    }
LABEL_67:
    uint64_t v90 = &__dst[18];
    uint64_t v41 = "extractInsertEntry: %s";
    __int16 v42 = 1657;
    goto LABEL_68;
  }
  *(_DWORD *)(v11 + 1332) = 1;
  uint64_t v14 = *(void (**)(uint64_t, _DWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v11 + 112);
  if (v14)
  {
    uint64_t v15 = *(void *)(*(void *)v11 + 144);
    v14(v15, v10, v8, v6, v4, v2);
  }
}

_DWORD *extractBlobProc(_DWORD *result, _DWORD *a2)
{
  uint64_t v3 = result;
  if (result[333])
  {
    uint64_t v4 = *(uint64_t (**)(void, _DWORD *))(*(void *)result + 120);
    if (v4) {
      uint64_t result = (_DWORD *)v4(*(void *)(*(void *)result + 144), a2);
    }
  }
  if ((v3[330] & 0x80000000) == 0 && !v3[331])
  {
    uint64_t v5 = *((void *)v3 + 147);
    unsigned int v6 = v3[335];
    v3[332] = 0;
    int v7 = *a2 & 0xDFDFDF;
    if (v7 == 4997953)
    {
      int v9 = 4;
    }
    else if (v7 == 5521752)
    {
      int v9 = 3;
    }
    else
    {
      uint64_t v8 = v3 + 332;
      if (v7 != 5521732 || v3[334])
      {
LABEL_15:
        *uint64_t v8 = 1;
        return result;
      }
      int v9 = 2;
    }
    int v13 = v9;
    uint64_t result = (_DWORD *)writeToThread(v5 + 304 * v6, (char *)&v13, 4uLL);
    if (!result) {
      return result;
    }
    uint64_t result = (_DWORD *)pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractBlobProc", 1771, 2, 0, "writeToThread", v10, v11, v12);
    uint64_t v8 = v3 + 296;
    goto LABEL_15;
  }
  return result;
}

uint64_t extractPayloadProc(uint64_t result, char *a2, size_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 1368) += a3;
  if (*(_DWORD *)(result + 1332))
  {
    unsigned int v6 = *(uint64_t (**)(void, char *, size_t))(*(void *)result + 128);
    if (v6) {
      uint64_t result = v6(*(void *)(*(void *)result + 144), a2, a3);
    }
  }
  if ((*(_DWORD *)(v5 + 1320) & 0x80000000) == 0 && !*(_DWORD *)(v5 + 1324) && !*(_DWORD *)(v5 + 1328))
  {
    uint64_t result = writeToThread(*(void *)(v5 + 1176) + 304 * *(unsigned int *)(v5 + 1340), a2, a3);
    if (result)
    {
      uint64_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractPayloadProc", 1800, 2, 0, "extractWriteToThread", v7, v8, v9);
      *(_DWORD *)(v5 + 1184) = 1;
    }
  }
  return result;
}

uint64_t extractEndProc(uint64_t result)
{
  uint64_t v1 = result;
  *(void *)(result + 1360) = *(void *)(result + 1368);
  if (*(_DWORD *)(result + 1332))
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)result + 136);
    if (v2) {
      uint64_t result = v2(*(void *)(*(void *)result + 144));
    }
  }
  if ((*(_DWORD *)(v1 + 1320) & 0x80000000) == 0)
  {
    if (*(_DWORD *)(v1 + 1324))
    {
      uint64_t result = inFlightQueueRetire();
      if ((result & 0x80000000) == 0)
      {
LABEL_7:
        *(_DWORD *)(v1 + 1320) = -1;
        *(_DWORD *)(v1 + 1340) = -1;
        return result;
      }
      uint64_t v7 = "Updating entry state";
      __int16 v8 = 1851;
    }
    else
    {
      uint64_t v5 = *(void *)(v1 + 1176);
      unsigned int v6 = *(_DWORD *)(v1 + 1340);
      int v12 = 5;
      if (writeToThread(v5 + 304 * v6, (char *)&v12, 4uLL))
      {
        uint64_t v7 = "extractWriteToThread";
        __int16 v8 = 1840;
      }
      else if (writeToThread(v5 + 304 * v6, (char *)(v1 + 1360), 8uLL))
      {
        uint64_t v7 = "extractWriteToThread";
        __int16 v8 = 1841;
      }
      else
      {
        *(_DWORD *)(v1 + 1344) = 0;
        if (!pthread_mutex_lock((pthread_mutex_t *)(v5 + 304 * v6 + 32)))
        {
          uint64_t v9 = v5 + 304 * v6;
          int v10 = *(_DWORD *)(v9 + 24);
          *(_DWORD *)(v9 + 24) = v10 + 1;
          if (v10 || !pthread_cond_broadcast((pthread_cond_t *)(v5 + 304 * v6 + 96)))
          {
            uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v5 + 304 * v6 + 32));
            if (!result) {
              goto LABEL_7;
            }
          }
        }
        uint64_t v7 = "SemRelease";
        __int16 v8 = 1846;
      }
    }
    uint64_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractEndProc", v8, 2, 0, v7, v3, v4, v11);
    *(_DWORD *)(v1 + 1184) = 1;
  }
  return result;
}

uint64_t extractPaddingProc(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 1368) += a3;
  return result;
}

uint64_t SharedArrayPush_0(unsigned int *a1, int a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 4);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 4)))
  {
    __int16 v8 = "SharedArrayPush: pthread_mutex_lock failed\n";
    __int16 v9 = 117;
  }
  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = a1[1];
    int v12 = v10;
    if (v10 < v11)
    {
      *(_DWORD *)(*((void *)a1 + 1) + 4 * v10) = a2;
      int v12 = *a1;
    }
    *a1 = v12 + 1;
    if (v12 || !pthread_cond_broadcast((pthread_cond_t *)(a1 + 20)))
    {
      if (pthread_mutex_unlock(v4))
      {
        __int16 v8 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        __int16 v9 = 124;
      }
      else
      {
        if (v10 < v11) {
          return 0;
        }
        __int16 v8 = "SharedArrayPush: stack is full\n";
        __int16 v9 = 125;
      }
    }
    else
    {
      __int16 v8 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      __int16 v9 = 122;
    }
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPush", v9, 0, v8, v5, v6, v7, v14);
  return 0xFFFFFFFFLL;
}

uint64_t inFlightQueueRetire()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  unsigned int v2 = v1;
  int v4 = v3;
  uint64_t v5 = (void *)v0;
  uint64_t v65 = *MEMORY[0x263EF8340];
  uint64_t v6 = (pthread_mutex_t *)(v0 + 1192);
  if (pthread_mutex_lock((pthread_mutex_t *)(v0 + 1192)))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 467, 2, 0, "pthread_mutex_lock", v7, v8, v62);
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = inFlightQueueEntry(v5, v4);
  if (!v10)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 471, 2, 0, "couldn't locate entry [%d] in queue", v11, v12, v4);
    goto LABEL_12;
  }
  unsigned int v13 = *(_DWORD *)(v10 + 2300);
  switch(v13)
  {
    case 0u:
      *(_DWORD *)(v10 + 2300) = v2;
      unsigned int v13 = v2;
      goto LABEL_6;
    case 7u:
LABEL_6:
      if (*(int *)*v5 >= 3)
      {
        if (v13 > 7) {
          char v14 = "???";
        }
        else {
          char v14 = (&off_264133838)[v13];
        }
        fprintf((FILE *)*MEMORY[0x263EF8348], "[%7d] retiring %s: %s\n", v4, v14, (const char *)(v10 + 144));
      }
      if (v5[174])
      {
        uint64_t v18 = (char *)v5 + 12;
        uint64_t v19 = v5[175];
        int v17 = 1;
        while (1)
        {
          uint64_t v20 = v5[177];
          uint64_t v21 = v20 + 2320 * v19;
          unint64_t v22 = (int *)(v21 + 2300);
          int v23 = *(_DWORD *)(v21 + 2300);
          if (v23 != 1)
          {
            if (!v23) {
              goto LABEL_13;
            }
            goto LABEL_22;
          }
          int v27 = *(_DWORD *)(v21 + 4);
          if (v27 == 72)
          {
            bzero(__src, 0x800uLL);
            bzero(v64, 0x800uLL);
            if ((concatExtractPath(__src, 0x800uLL, v18, (const char *)(v21 + 144)) & 0x80000000) != 0)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 497, 2, 0, "invalid path: %s", v28, v29, v21 - 112);
              goto LABEL_12;
            }
            if (concatPath(v64, 0x800uLL, v18, (const char *)(v21 + 1168)))
            {
              uint64_t v15 = "concatPath";
              __int16 v16 = 498;
LABEL_11:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", v16, 2, 0, v15, v11, v12, v62);
              goto LABEL_12;
            }
            if (*(int *)*v5 >= 3) {
              fprintf((FILE *)*MEMORY[0x263EF8348], "[%7d] HLINK (legacy) %s -> %s\n", *(_DWORD *)(v20 + 2320 * v19 + 2296), (const char *)(v21 + 144), v64);
            }
            unlink(__src);
            if (link(v64, __src))
            {
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 512, 2, "%s", v30, v11, v12, (char)__src);
              int v23 = 7;
            }
            else
            {
              int v23 = 3;
            }
            *unint64_t v22 = v23;
            goto LABEL_22;
          }
          if (v27 == 120) {
            break;
          }
          int v34 = *(_DWORD *)(v21 + 4);
          if (v34 == 121)
          {
            bzero(__src, 0x800uLL);
            bzero(v64, 0x800uLL);
            if ((concatExtractPath(__src, 0x800uLL, v18, (const char *)(v21 + 144)) & 0x80000000) != 0)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 551, 2, 0, "invalid path: %s", v35, v36, v21 - 112);
              goto LABEL_12;
            }
            if (concatPath(v64, 0x800uLL, v18, (const char *)(v21 + 1168)))
            {
              uint64_t v15 = "concatPath";
              __int16 v16 = 552;
              goto LABEL_11;
            }
            if (*(int *)*v5 >= 3) {
              fprintf((FILE *)*MEMORY[0x263EF8348], "[%7d] CLONE %s -> %s\n", *(_DWORD *)(v20 + 2320 * v19 + 2296), (const char *)(v21 + 144), (const char *)(v21 + 1168));
            }
            unlink(__src);
            if (clonefile(v64, __src, 0))
            {
              uint64_t v18 = (char *)v5 + 12;
              if ((copyFileSegment(v64, 0, 0xFFFFFFFFFFFFFFFFLL, __src) & 0x80000000) != 0)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 563, 2, 0, "cloning file, falling back to copy, failed: %s", v11, v12, (char)__src);
                int v17 = 0;
              }
            }
            else
            {
              uint64_t v18 = (char *)v5 + 12;
            }
            *unint64_t v22 = 3;
            int v23 = 3;
LABEL_22:
            if (v23 == 3) {
              goto LABEL_23;
            }
            if ((v23 & 0xFFFFFFFC) == 4)
            {
              char v26 = 1;
              goto LABEL_77;
            }
            goto LABEL_60;
          }
          if (v34 == 68)
          {
            BOOL v37 = (*(_DWORD *)v21 & 8) != 0 && *(_DWORD *)(v21 + 16) != 0;
            if ((*(_DWORD *)v21 & 0x10) != 0 && (~*(_DWORD *)(v21 + 20) & 0x1ED) != 0) {
              BOOL v37 = 1;
            }
            uint64_t v38 = v20 + 2320 * v19;
            if (*(void *)(v38 + 2288)) {
              BOOL v39 = 0;
            }
            else {
              BOOL v39 = (*(_DWORD *)v21 & 0x100) == 0;
            }
            if (v39 && *(void *)(v38 + 2280) == 0 && !v37)
            {
              *unint64_t v22 = 3;
LABEL_23:
              if ((setEntryAttributes((uint64_t)v5, v20 + 2320 * v19) & 0x80000000) != 0)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 590, 2, 0, "setEntryAttributes failed", v24, v25, v62);
                char v26 = 1;
                int v23 = 7;
              }
              else
              {
                char v26 = 1;
                int v23 = 4;
              }
            }
            else
            {
              char v26 = 0;
              int v23 = 6;
            }
            *unint64_t v22 = v23;
LABEL_77:
            __int16 v42 = (int *)*v5;
            if (*(void *)(*v5 + 80))
            {
              int v43 = v42[6];
              if ((v43 & 8) != 0)
              {
                *(_DWORD *)v21 |= 0x20u;
                *(_DWORD *)(v21 + 24) = v23 == 7;
                __int16 v42 = (int *)*v5;
                int v43 = *(_DWORD *)(*v5 + 24);
              }
              if ((v43 & 0x20000) != 0)
              {
                *(_DWORD *)v21 |= 0x40u;
                *(void *)(v21 + 32) = *(void *)(v20 + 2320 * v19 + 2312);
                __int16 v42 = (int *)*v5;
              }
              (*((void (**)(void, uint64_t))v42 + 10))(*((void *)v42 + 18), v20 + 2320 * v19);
              int v23 = *v22;
            }
            if (v23 == 7) {
              ++v5[181];
            }
            if (*(int *)*v5 < 2 || v23 == 5)
            {
              if ((v26 & 1) == 0) {
                goto LABEL_96;
              }
            }
            else
            {
              if (v23 == 7) {
                fprintf((FILE *)*MEMORY[0x263EF8348], "%s (with errors)\n");
              }
              else {
                fprintf((FILE *)*MEMORY[0x263EF8348], "%s\n");
              }
              if ((v26 & 1) == 0)
              {
LABEL_96:
                unint64_t v46 = v5[179];
                unint64_t v47 = v5[178];
                unint64_t v48 = (void *)v5[180];
                if (v46 < v47) {
                  goto LABEL_101;
                }
                uint64_t v49 = v47 + (v47 >> 1);
                BOOL v39 = v47 == 0;
                uint64_t v50 = 16;
                if (!v39) {
                  uint64_t v50 = v49;
                }
                v5[178] = v50;
                unint64_t v51 = (char *)reallocf(v48, 16 * v50);
                v5[180] = v51;
                if (v51)
                {
                  unint64_t v48 = v51;
                  unint64_t v46 = v5[179];
                  bzero(&v51[16 * v46], 16 * (v5[178] - v46));
LABEL_101:
                  uint64_t v52 = pc_zero_coder_encode(__src, 2610, (char *)(v20 + 2320 * v19), 2320);
                  *((void *)v48 + 2 * v46 + 1) = v52;
                  if (v52)
                  {
                    size_t v55 = (size_t)v52;
                    int v56 = malloc((size_t)v52);
                    *((void *)v48 + 2 * v46) = v56;
                    if (v56)
                    {
                      memcpy(v56, __src, v55);
                      ++v5[179];
                      atomic_fetch_add_explicit(v5 + 190, 1uLL, memory_order_relaxed);
                      goto LABEL_108;
                    }
                    int v58 = *__error();
                    __int16 v57 = 652;
                    long long v59 = "Allocating deferred entry";
                  }
                  else
                  {
                    __int16 v57 = 648;
                    int v58 = 0;
                    long long v59 = "zero_coder_encode";
                  }
                }
                else
                {
                  int v58 = *__error();
                  __int16 v57 = 637;
                  long long v59 = "Allocating deferred stack";
                }
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", v57, 2, v58, v59, v53, v54, v62);
                int v17 = 0;
                goto LABEL_108;
              }
            }
            uint64_t v45 = v20 + 2320 * v19;
            MemBufferDestroy(*(void ***)(v45 + 2280));
            MemBufferDestroy(*(void ***)(v45 + 2288));
LABEL_108:
            uint64_t v18 = (char *)v5 + 12;
            goto LABEL_109;
          }
LABEL_60:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 599, 2, 0, "Invalid entry state [%d] %s: %s", v11, v12, v4);
          int v17 = 0;
LABEL_109:
          bzero((void *)(v20 + 2320 * v19), 0x910uLL);
          uint64_t v60 = v5[175];
          if (v60 + 1 == v5[173]) {
            uint64_t v19 = 0;
          }
          else {
            uint64_t v19 = v60 + 1;
          }
          v5[175] = v19;
          uint64_t v61 = v5[174] - 1;
          v5[174] = v61;
          if (!v61) {
            goto LABEL_13;
          }
        }
        bzero(__src, 0x800uLL);
        bzero(v64, 0x800uLL);
        if ((concatExtractPath(__src, 0x800uLL, v18, (const char *)(v21 + 144)) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 524, 2, 0, "invalid path: %s", v31, v32, v21 - 112);
LABEL_12:
          int v17 = 0;
          goto LABEL_13;
        }
        if (concatPath(v64, 0x800uLL, v18, (const char *)(v21 + 1168)))
        {
          uint64_t v15 = "concatPath";
          __int16 v16 = 525;
          goto LABEL_11;
        }
        if (*(int *)*v5 >= 3) {
          fprintf((FILE *)*MEMORY[0x263EF8348], "[%7d] HLINK %s -> %s\n", *(_DWORD *)(v20 + 2320 * v19 + 2296), (const char *)(v21 + 144), (const char *)(v21 + 1168));
        }
        unlink(__src);
        if (link(v64, __src))
        {
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 539, 2, "%s", v33, v11, v12, (char)__src);
          int v23 = 7;
        }
        else
        {
          int v23 = 3;
        }
        uint64_t v18 = (char *)v5 + 12;
        *unint64_t v22 = v23;
        goto LABEL_22;
      }
      int v17 = 1;
LABEL_13:
      pthread_mutex_unlock(v6);
      if (v17) {
        return 0;
      }
      else {
        return 0xFFFFFFFFLL;
      }
    default:
      char v62 = v4;
      uint64_t v15 = "Invalid entry state [%d] %s: %s";
      __int16 v16 = 476;
      goto LABEL_11;
  }
}

unsigned int *ThreadPoolCreate(unsigned int a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (unsigned int *)calloc(1uLL, 0xA8uLL);
  uint64_t v7 = v6;
  if (v6)
  {
    unsigned int *v6 = a1;
    uint64_t v8 = calloc(a1, 0xA8uLL);
    *((void *)v7 + 1) = v8;
    if (v8)
    {
      size_t v9 = *v7;
      v7[8] = 0;
      v7[9] = v9;
      uint64_t v10 = calloc(v9, 4uLL);
      *((void *)v7 + 5) = v10;
      if (v10)
      {
        if (pthread_mutex_init((pthread_mutex_t *)(v7 + 12), 0))
        {
          char v14 = "SharedArrayInit: pthread_mutex_init failed\n";
          __int16 v15 = 56;
        }
        else
        {
          if (!pthread_cond_init((pthread_cond_t *)(v7 + 28), 0))
          {
            v7[4] = -1;
            if (!*v7) {
              return v7;
            }
            uint64_t v22 = 0;
            unint64_t v23 = 0;
            while (1)
            {
              uint64_t v24 = *((void *)v7 + 1);
              uint64_t v25 = v24 + v22;
              *(void *)(v25 + 16) = v7;
              *(_DWORD *)(v25 + 8) = v23;
              *(void *)(v25 + 24) = *(void *)(a2 + 8 * v23);
              *(void *)(v25 + 32) = a3;
              *(_DWORD *)(v25 + 40) = 0;
              if (pthread_mutex_init((pthread_mutex_t *)(v24 + v22 + 48), 0)
                || pthread_cond_init((pthread_cond_t *)(v25 + 112), 0))
              {
                uint64_t v19 = "SemInit";
                __int16 v20 = 115;
                goto LABEL_12;
              }
              if ((createThread((pthread_t *)(v24 + v22), (uint64_t)threadPoolWorkerThreadProc, v24 + v22, 0) & 0x80000000) != 0) {
                break;
              }
              ++v23;
              v22 += 168;
              if (v23 >= *v7) {
                return v7;
              }
            }
            uint64_t v19 = "Thread creation";
            __int16 v20 = 116;
            goto LABEL_12;
          }
          char v14 = "SharedArrayInit: pthread_cond_init failed\n";
          __int16 v15 = 57;
        }
      }
      else
      {
        char v14 = "SharedArrayInit: malloc failed\n";
        __int16 v15 = 55;
      }
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayInit", v15, 0, v14, v11, v12, v13, v26);
      uint64_t v19 = "SharedArrayInit";
      __int16 v20 = 104;
LABEL_12:
      int v16 = 0;
      goto LABEL_13;
    }
    int v16 = *__error();
    uint64_t v19 = "malloc";
    __int16 v20 = 103;
  }
  else
  {
    int v16 = *__error();
    uint64_t v19 = "malloc";
    __int16 v20 = 98;
  }
LABEL_13:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"ThreadPoolCreate", v20, 90, v16, v19, v17, v18, v26);
  ThreadPoolDestroy((uint64_t)v7);
  return 0;
}

uint64_t threadPoolWorkerThreadProc(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  int v3 = *(_DWORD *)(a1 + 8);
  if (pthread_mutex_lock((pthread_mutex_t *)(v2 + 48)))
  {
LABEL_2:
    uint64_t v7 = "SharedArrayPush: pthread_mutex_lock failed\n";
    __int16 v8 = 117;
  }
  else
  {
    while (1)
    {
      uint64_t v13 = *(unsigned int *)(v2 + 32);
      unsigned int v14 = *(_DWORD *)(v2 + 36);
      int v15 = v13;
      if (v13 < v14)
      {
        *(_DWORD *)(*(void *)(v2 + 40) + 4 * v13) = v3;
        int v15 = *(_DWORD *)(v2 + 32);
      }
      *(_DWORD *)(v2 + 32) = v15 + 1;
      if (!v15)
      {
        if (pthread_cond_broadcast((pthread_cond_t *)(v2 + 112))) {
          break;
        }
      }
      if (pthread_mutex_unlock((pthread_mutex_t *)(v2 + 48)))
      {
        uint64_t v7 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        __int16 v8 = 124;
        goto LABEL_3;
      }
      if (v13 >= v14)
      {
        uint64_t v7 = "SharedArrayPush: stack is full\n";
        __int16 v8 = 125;
        goto LABEL_3;
      }
      if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 48))) {
        goto LABEL_21;
      }
      while (1)
      {
        int v16 = *(_DWORD *)(a1 + 40);
        if (v16 > 0) {
          break;
        }
        if (pthread_cond_wait((pthread_cond_t *)(a1 + 112), (pthread_mutex_t *)(a1 + 48))) {
          goto LABEL_21;
        }
      }
      *(_DWORD *)(a1 + 40) = v16 - 1;
      if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 48)))
      {
LABEL_21:
        uint64_t v11 = "SemAcquire";
        __int16 v12 = 59;
        goto LABEL_22;
      }
      uint64_t v17 = *(void *)(a1 + 160);
      if (v17 != -2)
      {
        if (v17 < 0) {
          return a1;
        }
        if (((*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 24)) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"threadPoolWorkerThreadProc", 72, 90, 0, "worker proc reported an error", v18, v19, v21);
          atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 160), 1u, memory_order_relaxed);
        }
      }
      int v3 = *(_DWORD *)(a1 + 8);
      if (pthread_mutex_lock((pthread_mutex_t *)(v2 + 48))) {
        goto LABEL_2;
      }
    }
    uint64_t v7 = "SharedArrayPush: pthread_cond_broadcast failed\n";
    __int16 v8 = 122;
  }
LABEL_3:
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPush", v8, 0, v7, v4, v5, v6, v21);
  uint64_t v11 = "SharedArrayPush";
  __int16 v12 = 56;
LABEL_22:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"threadPoolWorkerThreadProc", v12, 90, 0, v11, v9, v10, v21);
  atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 160), 1u, memory_order_relaxed);
  return a1;
}

uint64_t ThreadPoolDestroy(uint64_t result)
{
  if (result)
  {
    unsigned int v1 = (unsigned int *)result;
    uint64_t v2 = *(uint64_t **)(result + 8);
    if (v2)
    {
      uint64_t v3 = *(unsigned int *)result;
      if (!v3)
      {
        int v7 = 1;
        goto LABEL_37;
      }
      int v4 = 0;
      do
      {
        uint64_t v5 = *v2;
        v2 += 21;
        if (v5) {
          ++v4;
        }
        --v3;
      }
      while (v3);
      if (v4)
      {
        int v6 = 0;
        int v7 = 1;
        while (1)
        {
          if (pthread_mutex_lock((pthread_mutex_t *)(v1 + 12)))
          {
            __int16 v11 = 91;
            __int16 v12 = "SharedArrayPop: pthread_mutex_lock failed\n";
LABEL_15:
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v11, 0, v12, v8, v9, v10, v35);
            unsigned int v16 = -1;
          }
          else
          {
            while (1)
            {
              unsigned int v13 = v1[8];
              if (v13) {
                break;
              }
              if (pthread_cond_wait((pthread_cond_t *)(v1 + 28), (pthread_mutex_t *)(v1 + 12)))
              {
                __int16 v11 = 94;
                __int16 v12 = "SharedArrayPop: pthread_cond_wait failed\n";
                goto LABEL_15;
              }
            }
            unsigned int v23 = v13 - 1;
            v1[8] = v23;
            unsigned int v16 = *(_DWORD *)(*((void *)v1 + 5) + 4 * v23);
            if (!pthread_mutex_unlock((pthread_mutex_t *)(v1 + 12))) {
              goto LABEL_17;
            }
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", 98, 0, "SharedArrayPop: pthread_mutex_unlock failed\n", v24, v25, v26, v35);
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"ThreadPoolDestroy", 147, 90, 0, "SharedArrayPop", v14, v15, v36);
          int v7 = 0;
LABEL_17:
          uint64_t v17 = *((void *)v1 + 1);
          uint64_t v18 = v17 + 168 * v16;
          *(void *)(v18 + 160) = -1;
          if (pthread_mutex_lock((pthread_mutex_t *)(v18 + 48))
            || (uint64_t v21 = v17 + 168 * v16, v22 = *(_DWORD *)(v21 + 40), *(_DWORD *)(v21 + 40) = v22 + 1, !v22)
            && pthread_cond_broadcast((pthread_cond_t *)(v17 + 168 * v16 + 112))
            || pthread_mutex_unlock((pthread_mutex_t *)(v18 + 48)))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"ThreadPoolDestroy", 155, 90, 0, "SemRelease", v19, v20, v35);
            int v7 = 0;
          }
          if ((joinThread(*(_opaque_pthread_t **)v18) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"ThreadPoolDestroy", 156, 90, 0, "joinThread", v27, v28, v35);
            int v7 = 0;
          }
          *(void *)uint64_t v18 = 0;
          if (++v6 == v4)
          {
            if (!*v1) {
              goto LABEL_37;
            }
            goto LABEL_33;
          }
        }
      }
      int v7 = 1;
LABEL_33:
      unint64_t v29 = 0;
      uint64_t v30 = 112;
      do
      {
        uint64_t v31 = (pthread_cond_t *)(*((void *)v1 + 1) + v30);
        if (!pthread_mutex_destroy((pthread_mutex_t *)&v31[-2].__opaque[24])) {
          pthread_cond_destroy(v31);
        }
        ++v29;
        v30 += 168;
      }
      while (v29 < *v1);
LABEL_37:
      free(*((void **)v1 + 1));
      *((void *)v1 + 1) = 0;
    }
    else
    {
      int v7 = 1;
    }
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 12)) && !pthread_cond_destroy((pthread_cond_t *)(v1 + 28))) {
      free(*((void **)v1 + 5));
    }
    int v34 = atomic_load(v1 + 40);
    if (v34 >= 1)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"ThreadPoolDestroy", 171, 90, 0, "Threads reported errors", v32, v33, v35);
      int v7 = 0;
    }
    free(v1);
    if (v7) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t ThreadPoolGetWorker(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 16) != -1)
  {
    uint64_t v8 = "Missing call to RunWorker before GetWorker";
    __int16 v9 = 182;
LABEL_11:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"ThreadPoolGetWorker", v9, 90, 0, v8, a7, a8, v21);
    return 0;
  }
  __int16 v11 = (pthread_mutex_t *)(a1 + 48);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 48)))
  {
    uint64_t v15 = "SharedArrayPop: pthread_mutex_lock failed\n";
    __int16 v16 = 91;
LABEL_10:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v16, 0, v15, v12, v13, v14, v21);
    uint64_t v8 = "SharedArrayPop failed";
    __int16 v9 = 186;
    goto LABEL_11;
  }
  while (1)
  {
    int v17 = *(_DWORD *)(a1 + 32);
    if (v17) {
      break;
    }
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 112), v11))
    {
      uint64_t v15 = "SharedArrayPop: pthread_cond_wait failed\n";
      __int16 v16 = 94;
      goto LABEL_10;
    }
  }
  unsigned int v18 = v17 - 1;
  *(_DWORD *)(a1 + 32) = v18;
  unsigned int v19 = *(_DWORD *)(*(void *)(a1 + 40) + 4 * v18);
  if (pthread_mutex_unlock(v11))
  {
    uint64_t v15 = "SharedArrayPop: pthread_mutex_unlock failed\n";
    __int16 v16 = 98;
    goto LABEL_10;
  }
  *(_DWORD *)(a1 + 16) = v19;
  return *(void *)(*(void *)(a1 + 8) + 168 * v19 + 24);
}

uint64_t ThreadPoolRunWorker(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)(a1 + 16);
  if (v8 == -1)
  {
    __int16 v16 = "Missing call to GetWorker before RunWorker";
    __int16 v17 = 199;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"ThreadPoolRunWorker", v17, 90, 0, v16, a7, a8, v18);
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 16) = -1;
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v10 + 1;
  uint64_t v11 = v9 + 168 * v8;
  *(void *)(v11 + 160) = v10;
  uint64_t v12 = (pthread_mutex_t *)(v11 + 48);
  if (pthread_mutex_lock((pthread_mutex_t *)(v11 + 48))
    || (v13 = v9 + 168 * v8, int v14 = *(_DWORD *)(v13 + 40), *(_DWORD *)(v13 + 40) = v14 + 1, !v14)
    && pthread_cond_broadcast((pthread_cond_t *)(v9 + 168 * v8 + 112))
    || (uint64_t result = pthread_mutex_unlock(v12), result))
  {
    __int16 v16 = "SemRelease failed";
    __int16 v17 = 211;
    goto LABEL_9;
  }
  return result;
}

uint64_t ThreadPoolSync(unsigned int *a1)
{
  uint64_t v1 = *a1;
  if (!v1)
  {
    int v7 = 1;
    goto LABEL_30;
  }
  int v3 = 0;
  int v4 = (uint64_t *)*((void *)a1 + 1);
  do
  {
    uint64_t v5 = *v4;
    v4 += 21;
    if (v5) {
      ++v3;
    }
    --v1;
  }
  while (v1);
  if (v3)
  {
    int v6 = 0;
    int v7 = 1;
    while (1)
    {
      if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)))
      {
        __int16 v11 = 91;
        uint64_t v12 = "SharedArrayPop: pthread_mutex_lock failed\n";
      }
      else
      {
        while (1)
        {
          unsigned int v13 = a1[8];
          if (v13) {
            break;
          }
          if (pthread_cond_wait((pthread_cond_t *)(a1 + 28), (pthread_mutex_t *)(a1 + 12)))
          {
            __int16 v11 = 94;
            uint64_t v12 = "SharedArrayPop: pthread_cond_wait failed\n";
            goto LABEL_15;
          }
        }
        a1[8] = v13 - 1;
        if (!pthread_mutex_unlock((pthread_mutex_t *)(a1 + 12))) {
          goto LABEL_16;
        }
        __int16 v11 = 98;
        uint64_t v12 = "SharedArrayPop: pthread_mutex_unlock failed\n";
      }
LABEL_15:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v11, 0, v12, v8, v9, v10, v24);
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"ThreadPoolSync", 231, 90, 0, "SharedArrayPop", v14, v15, v25);
      int v7 = 0;
LABEL_16:
      if (++v6 == v3)
      {
        if (!*a1) {
          goto LABEL_30;
        }
        goto LABEL_21;
      }
    }
  }
  int v7 = 1;
LABEL_21:
  uint64_t v16 = 0;
  unint64_t v17 = 0;
  do
  {
    uint64_t v18 = *((void *)a1 + 1);
    if (*(void *)(v18 + v16))
    {
      if ((uint64_t v19 = v18 + v16, *(void *)(v18 + v16 + 160) = -2,
                             pthread_mutex_lock((pthread_mutex_t *)(v18 + v16 + 48)))
        || (int v22 = *(_DWORD *)(v19 + 40), *(_DWORD *)(v19 + 40) = v22 + 1, !v22)
        && pthread_cond_broadcast((pthread_cond_t *)(v18 + v16 + 112))
        || pthread_mutex_unlock((pthread_mutex_t *)(v18 + v16 + 48)))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"ThreadPoolSync", 240, 90, 0, "SemRelease", v20, v21, v24);
        int v7 = 0;
      }
    }
    ++v17;
    v16 += 168;
  }
  while (v17 < *a1);
LABEL_30:
  if (v7) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t RawImageGetPatchInfo(long long *a1, unint64_t a2, void *__s, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 <= 0x2D)
  {
    uint64_t v8 = "invalid patch size";
    __int16 v9 = 488;
LABEL_17:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImageGetPatchInfo", v9, 135, 0, v8, a7, a8, v15);
    return 0xFFFFFFFFLL;
  }
  long long v15 = *a1;
  long long v16 = *(long long *)((char *)a1 + 30);
  int v10 = (unsigned __int16)*((void *)a1 + 1);
  BOOL v12 = *(void *)a1 != 0x3031464649444952 || v10 == 0 || (unint64_t)((unsigned __int128)a1[1] >> 16) == 0;
  if (v12 || (unint64_t)v16 < 0x2F || (unint64_t)v16 >= *((void *)&v16 + 1))
  {
    uint64_t v8 = "bad header";
    __int16 v9 = 497;
    goto LABEL_17;
  }
  if (__s) {
    memset_s(__s, 0x10uLL, 0, 0x10uLL);
  }
  *((_DWORD *)__s + 2) = v10 == 1;
  uint64_t result = 0;
  if (BYTE10(v15)) {
    *((_DWORD *)__s + 3) = 1;
  }
  return result;
}

uint64_t RawImagePatchInternal(uint64_t a1, AAByteStream_impl *a2)
{
  int v5 = *(_DWORD *)(a1 + 40);
  int DefaultNThreads = *(_DWORD *)(a1 + 44);
  if (!DefaultNThreads)
  {
    int DefaultNThreads = getDefaultNThreads();
    *(_DWORD *)(a1 + 44) = DefaultNThreads;
  }
  if (DefaultNThreads >= 3) {
    *(_DWORD *)(a1 + 44) = 2;
  }
  if (!*(void *)(a1 + 16)) {
    *(void *)(a1 + 16) = *(void *)(a1 + 24);
  }
  int v6 = a2;
  if (!a2)
  {
    uint64_t v18 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(a1 + 32), 0, 0);
    int v6 = (AAByteStream_impl *)v18;
    if (!v18)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 542, 135, 0, "AAFileStreamOpenWithPath", v19, v20, v254);
      uint64_t v31 = 0;
      uint64_t v30 = 0;
      unint64_t v29 = 0;
      uint64_t v28 = 0;
      int v27 = 0;
      goto LABEL_30;
    }
    if ((v5 & 1) != 0 && (io_set_nocache(v18) & 0x80000000) != 0) {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 543, 135, "io_set_nocache %s", v21, v22, v23, *(void *)(a1 + 32));
    }
  }
  int v7 = malloc(0x2EuLL);
  int v10 = v7;
  if (!v7)
  {
    int v17 = *__error();
    long long v15 = "aaMalloc";
    __int16 v16 = 108;
    goto LABEL_24;
  }
  if (!*((void *)v6 + 2)) {
    goto LABEL_17;
  }
  uint64_t v11 = 0;
  uint64_t v12 = 46;
  unsigned int v13 = v7;
  do
  {
    uint64_t v14 = (*((uint64_t (**)(void, void *, uint64_t))v6 + 2))(*(void *)v6, v13, v12);
    if (v14 < 0) {
      goto LABEL_17;
    }
    if (!v14) {
      break;
    }
    unsigned int v13 = (void *)((char *)v13 + v14);
    v11 += v14;
    v12 -= v14;
  }
  while (v12);
  if (v11 != 46)
  {
LABEL_17:
    long long v15 = "aaByteStreamReadExpected";
    __int16 v16 = 110;
    goto LABEL_18;
  }
  if (*v10 != 0x3031464649444952
    || !*((_WORD *)v10 + 4)
    || !*(void *)((char *)v10 + 18)
    || (size_t v35 = *(void *)((char *)v10 + 30), v35 < 0x2F)
    || v35 >= *(void *)((char *)v10 + 38))
  {
    long long v15 = "bad header";
    __int16 v16 = 118;
LABEL_18:
    int v17 = 0;
LABEL_24:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_header", v16, 135, v17, v15, v8, v9, v254);
LABEL_25:
    free(v10);
    char v24 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 548, 135, *v24, "patch_read_header", v25, v26, v255);
    int v27 = 0;
    uint64_t v28 = 0;
    unint64_t v29 = 0;
    uint64_t v30 = 0;
LABEL_26:
    uint64_t v31 = 0;
    goto LABEL_27;
  }
  if (v35 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_50:
    size_t v44 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_header", 122, 135, *v44, "aaReallocf", v45, v46, v254);
    int v10 = 0;
    goto LABEL_25;
  }
  char v36 = (char *)realloc(v10, v35);
  if (!v36)
  {
    free(v10);
    goto LABEL_50;
  }
  uint64_t v30 = v36;
  uint64_t v39 = *(void *)(v36 + 30) - 46;
  if (*((void *)v6 + 2))
  {
    if (*(void *)(v36 + 30) == 46) {
      goto LABEL_54;
    }
    uint64_t v40 = 0;
    uint64_t v41 = v36 + 46;
    uint64_t v42 = *(void *)(v36 + 30) - 46;
    while (1)
    {
      uint64_t v43 = (*((uint64_t (**)(void, char *, uint64_t))v6 + 2))(*(void *)v6, v41, v42);
      if (v43 < 0) {
        break;
      }
      if (v43)
      {
        v41 += v43;
        v40 += v43;
        v42 -= v43;
        if (v42) {
          continue;
        }
      }
      goto LABEL_53;
    }
    uint64_t v40 = v43;
  }
  else
  {
    uint64_t v40 = -1;
  }
LABEL_53:
  if (v39 != v40)
  {
    uint64_t v53 = "aaByteStreamReadExpected";
    __int16 v54 = 124;
LABEL_62:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_header", v54, 135, 0, v53, v37, v38, v254);
    int v10 = v30;
    goto LABEL_25;
  }
LABEL_54:
  uint64_t v47 = 0;
  unint64_t v48 = *(void *)(v30 + 38);
  uint64_t v49 = *((unsigned __int16 *)v30 + 4);
  do
  {
    unint64_t v50 = *(void *)&v30[v47 + 46];
    if (v48 >= v50)
    {
      uint64_t v53 = "bad header";
      __int16 v54 = 130;
      goto LABEL_62;
    }
    v47 += 8;
    unint64_t v48 = v50;
  }
  while (8 * v49 + 8 != v47);
  if (*(int *)(a1 + 48) >= 1)
  {
    unint64_t v51 = (FILE **)MEMORY[0x263EF8348];
    if (v49 == 1) {
      uint64_t v52 = "*full replacement*";
    }
    else {
      uint64_t v52 = *(const char **)(a1 + 16);
    }
    size_t v55 = "(stream based)";
    if (*(void *)(a1 + 32)) {
      size_t v55 = *(const char **)(a1 + 32);
    }
    int v56 = *(_DWORD *)(a1 + 40);
    if (v56) {
      __int16 v57 = "no";
    }
    else {
      __int16 v57 = "yes";
    }
    if ((v56 & 2) != 0) {
      int v58 = "yes";
    }
    else {
      int v58 = "no";
    }
    fprintf((FILE *)*MEMORY[0x263EF8348], "ImagePatch\n  Input:        %s\n  Output:       %s\n  Patch:        %s\n  CryptexCache: %s\n  StaticContent: %s\n", v52, *(const char **)(a1 + 24), v55, v57, v58);
    if (*(int *)(a1 + 48) >= 2)
    {
      fprintf(*v51, "  - Variants:   %d\n  - Flags:      %llx\n  - # controls: %llu\n  - Patch size: %llu bytes\n    - Metadata: %llu bytes\n    - Controls: %llu bytes\n", *((unsigned __int16 *)v30 + 4), *(void *)(v30 + 10), *(void *)(v30 + 18), *(void *)&v30[8 * *((unsigned __int16 *)v30 + 4) + 46], *(void *)(v30 + 38) - *(void *)(v30 + 30), *(void *)(v30 + 46) - *(void *)(v30 + 38));
      if (*((_WORD *)v30 + 4))
      {
        unint64_t v59 = 0;
        do
        {
          if (v59) {
            uint64_t v60 = "Diff";
          }
          else {
            uint64_t v60 = "Literal";
          }
          unint64_t v61 = v59 + 1;
          fprintf(*v51, "    - %s stream: %llu bytes\n", v60, *(void *)&v30[8 * v59 + 54] - *(void *)&v30[8 * v59 + 46]);
          unint64_t v59 = v61;
        }
        while (v61 < *((unsigned __int16 *)v30 + 4));
      }
    }
  }
  char v62 = aaIntervalInputStreamOpen((uint64_t)v6, *(void *)(v30 + 30), *(void *)(v30 + 38));
  uint64_t v65 = v62;
  if (!v62)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_variants", 187, 135, 0, "aaIntervalInputStreamOpen", v63, v64, v254);
    unint64_t v29 = 0;
    AAByteStream v70 = 0;
    goto LABEL_95;
  }
  uint64_t v66 = *(unsigned int *)(a1 + 48);
  if (v66 <= 3) {
    AAFlagSet v67 = v66 << 62;
  }
  else {
    AAFlagSet v67 = 0xC000000000000000;
  }
  AAByteStream v70 = AADecompressionInputStreamOpen(v62, v67, *(_DWORD *)(a1 + 44));
  if (!v70)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_variants", 189, 135, 0, "AADecompressionInputStreamOpen", v68, v69, v254);
    unint64_t v29 = 0;
    goto LABEL_95;
  }
  unint64_t v29 = calloc(*((unsigned __int16 *)v30 + 4), 8uLL);
  if (!v29)
  {
    uint64_t v76 = "aaCalloc";
    __int16 v77 = 193;
    goto LABEL_94;
  }
  if (*((_WORD *)v30 + 4))
  {
    uint64_t v73 = 0;
    while (1)
    {
      uint64_t v74 = rawimg_create_with_stream(v70, v73 == 0);
      v29[v73] = v74;
      if (!v74) {
        break;
      }
      if (++v73 >= (unint64_t)*((unsigned __int16 *)v30 + 4)) {
        goto LABEL_89;
      }
    }
    uint64_t v76 = "rawimg_create_with_stream";
    __int16 v77 = 199;
LABEL_94:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_variants", v77, 135, 0, v76, v71, v72, v254);
LABEL_95:
    free(v29);
    char v75 = 1;
  }
  else
  {
LABEL_89:
    char v75 = 0;
  }
  int v78 = AAByteStreamClose(v70);
  int v79 = AAByteStreamClose(v65);
  if (!v29 || (v75 & 1) != 0 || v79 < 0 || v78 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 552, 135, 0, "patch_read_variants", v80, v81, v254);
    int v27 = 0;
    uint64_t v28 = 0;
    unint64_t v29 = 0;
    goto LABEL_26;
  }
  uint64_t v82 = calloc(*((unsigned __int16 *)v30 + 4), 0x20uLL);
  uint64_t v31 = v82;
  if (!v82)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 556, 135, 0, "aaCalloc", v83, v84, v254);
    uint64_t v28 = 0;
    goto LABEL_374;
  }
  if (*((_WORD *)v30 + 4))
  {
    unint64_t v85 = 0;
    uint64_t v86 = v82;
    do
    {
      long long v87 = *(_OWORD *)(v29[v85] + 2104);
      *uint64_t v86 = *(_OWORD *)(v29[v85] + 2088);
      v86[1] = v87;
      v86 += 2;
      ++v85;
      unint64_t v88 = *((unsigned __int16 *)v30 + 4);
    }
    while (v85 < v88);
    *(void *)(*v29 + 2048) = *(void *)(a1 + 24);
    if (v88 == 1)
    {
      uint64_t v28 = 0;
      int v273 = 0;
      int v279 = 0;
      s = 0;
      unint64_t v291 = 0;
      AAByteStream compressed_stream = 0;
      uint64_t v283 = 0;
      uint64_t v89 = *v29;
      int v90 = *(_DWORD *)(a1 + 40);
      int v91 = v90 & 1;
      goto LABEL_106;
    }
  }
  else
  {
    *(void *)(*v29 + 2048) = *(void *)(a1 + 24);
  }
  uint64_t v106 = (long long *)malloc(0x2000uLL);
  uint64_t v28 = v106;
  if (!v106)
  {
    unint64_t v121 = "aaMalloc";
    __int16 v122 = 568;
    goto LABEL_373;
  }
  saveThreadErrorContext(v106);
  uint64_t v109 = *((unsigned __int16 *)v30 + 4);
  if (!*((_WORD *)v30 + 4))
  {
LABEL_138:
    restoreThreadErrorContext(v28);
    goto LABEL_139;
  }
  uint64_t v110 = &v31[4 * v109 - 4];
  uint64_t v111 = (char *)(v29 - 1);
  while (1)
  {
    uint64_t v295 = v109;
    uint64_t v112 = v109 - 1;
    *(void *)(*(void *)&v111[8 * v109] + 2048) = *(void *)(a1 + 16);
    if (!rawimg_get_digests(*(void *)&v111[8 * v109], 4, 1, 1))
    {
      uint64_t v113 = *(void **)&v111[8 * v295];
      uint64_t v114 = v113[261];
      uint64_t v115 = v113[262];
      uint64_t v116 = v113[263];
      uint64_t v117 = v113[264];
      BOOL v118 = *v110 == v114 && v110[1] == v115;
      BOOL v119 = v118 && v110[2] == v116;
      if (v119 && v110[3] == v117) {
        break;
      }
    }
    v110 -= 4;
    uint64_t v109 = v112;
    if (!v112) {
      goto LABEL_138;
    }
  }
  restoreThreadErrorContext(v28);
  int v273 = v112;
  if ((v112 & 0x80000000) != 0)
  {
LABEL_139:
    unint64_t v121 = "ImagePatch: No variant found";
    __int16 v122 = 586;
    goto LABEL_373;
  }
  if (v295 == 1) {
    goto LABEL_285;
  }
  int v188 = &v31[4 * v112];
  uint64_t v189 = *v188;
  uint64_t v190 = v188[1];
  uint64_t v192 = v188[2];
  uint64_t v191 = v188[3];
  if (*v31 == v189 && v31[1] == v190 && v31[2] == v192 && v31[3] == v191)
  {
    *(void *)(*v29 + 2048) = *(void *)(a1 + 16);
LABEL_285:
    uint64_t v211 = *v29;
    uint64_t v212 = *(const char **)(*v29 + 2048);
    uint64_t v213 = *(const char **)(a1 + 24);
    int v214 = strcmp(v212, v213);
    int v215 = *(_DWORD *)(a1 + 48);
    if (v214)
    {
      if (v215 >= 2)
      {
        fwrite("ImagePatch: Digest match. Copy input to output.\n", 0x30uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
        uint64_t v211 = *v29;
      }
      if ((copyFileSegment(v212, 0, *(void *)(v211 + 2120), v213) & 0x80000000) != 0)
      {
        unint64_t v121 = "copyFileSegment";
        __int16 v122 = 607;
        goto LABEL_373;
      }
    }
    else if (v215 >= 2)
    {
      uint64_t v216 = (FILE *)*MEMORY[0x263EF8348];
      int v217 = "ImagePatch: Digest match. Output already correct.\n";
      size_t v218 = 50;
      goto LABEL_381;
    }
LABEL_382:
    int v27 = 1;
    rawimg_show(*v29, 1, *(_DWORD *)(a1 + 48));
    if (*(void *)a1
      && ((*(uint64_t (**)(void, uint64_t))a1)(*(void *)(a1 + 8), 100) & 0x80000000) != 0)
    {
      unint64_t v121 = "callback signaled abort";
      __int16 v122 = 641;
      goto LABEL_373;
    }
    goto LABEL_375;
  }
  rawimg_show(v29[v112], 0, *(_DWORD *)(a1 + 48));
  int v90 = *(_DWORD *)(a1 + 40);
  int v91 = v90 & 1;
  uint64_t v289 = *v29;
  uint64_t v292 = (void *)v29[v273];
  uint64_t v196 = (const char *)v292[256];
  int v287 = strcmp(v196, *(const char **)(*v29 + 2048));
  if (!v287)
  {
    if (v30[10])
    {
      if (*(_DWORD *)(a1 + 48)) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "ImagePatch: Patching with excess space <= %d bytes.\n", *(_DWORD *)(v30 + 26));
      }
    }
    else
    {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 245, 135, "ImagePatch: Patch not created with in place. No bound on needed excess space.", v197, v198, v199, v254);
    }
    unint64_t v227 = v292[265];
    if (*(void *)(v289 + 2120) > v227) {
      unint64_t v227 = *(void *)(v289 + 2120);
    }
    uint64_t v285 = v227;
    uint64_t v294 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(v289 + 2048), 2, 0x1A4u);
    if (!v294)
    {
      uint64_t v244 = "AAFileStreamOpenWithPath";
      __int16 v245 = 252;
      goto LABEL_352;
    }
    if (v90)
    {
      if ((io_set_nocache(v294) & 0x80000000) != 0) {
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 257, 135, "io_set_nocache %s", v228, v229, v230, *(void *)(v289 + 2048));
      }
      LODWORD(v231) = *(_DWORD *)(a1 + 48);
      uint64_t v231 = v231 >= 3 ? 3 : v231;
      uint64_t v294 = (unsigned int **)aaCacheStreamOpen((AAByteStream_impl *)v294, 0x1000000uLL, 14, 1, v231 << 62);
      if (!v294)
      {
        uint64_t v244 = "aaCacheStreamOpen";
        __int16 v245 = 259;
        goto LABEL_352;
      }
    }
    int v279 = (unsigned int **)aaInSituStreamOpen(v294, v285, *(_DWORD *)(v30 + 26), *(_DWORD *)(a1 + 48), 1);
    if (!v279)
    {
      uint64_t v244 = "aaInSituStreamOpen";
      __int16 v245 = 264;
      goto LABEL_352;
    }
    if (*((unsigned __int16 *)v30 + 4) <= 1u)
    {
      s = 0;
      unint64_t v291 = 0;
      AAByteStream compressed_stream = 0;
      uint64_t v283 = 0;
      int v272 = 0;
      unint64_t v293 = v279;
      uint64_t v123 = aaSegmentStreamOpen(v279, (void *)v289);
      goto LABEL_145;
    }
    unint64_t v293 = v279;
LABEL_330:
    s = aaSegmentStreamOpen(v279, v292);
    if (!s)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 290, 135, 0, "aaSegmentStreamOpen", v235, v236, v254);
      uint64_t v280 = 0;
      v288 = 0;
      uint64_t v283 = 0;
      uint64_t v284 = 0;
      AAByteStream compressed_stream = 0;
      unint64_t v296 = 0;
      unint64_t v286 = 0;
      unint64_t v291 = 0;
      s = 0;
      goto LABEL_353;
    }
    unint64_t v291 = aaForkInputStreamOpen(s, (uint64_t)v292, 0, v232, v233, v234, v235, v236);
    if (!v291)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 292, 135, 0, "aaForkInputStreamOpen", v237, v238, v254);
      uint64_t v280 = 0;
      v288 = 0;
      uint64_t v283 = 0;
      uint64_t v284 = 0;
      AAByteStream compressed_stream = 0;
      unint64_t v296 = 0;
      unint64_t v286 = 0;
      unint64_t v291 = 0;
      goto LABEL_353;
    }
    AAByteStream compressed_stream = aaIntervalInputStreamOpen((uint64_t)v6, *(void *)&v30[8 * v273 + 46], *(void *)&v30[8 * v295 + 46]);
    if (compressed_stream)
    {
      LODWORD(v241) = *(_DWORD *)(a1 + 48);
      if (v241 >= 3) {
        uint64_t v241 = 3;
      }
      else {
        uint64_t v241 = v241;
      }
      uint64_t v283 = AADecompressionInputStreamOpen(compressed_stream, v241 << 62, *(_DWORD *)(a1 + 44));
      if (v283)
      {
        if (v287) {
          goto LABEL_312;
        }
        int v272 = 0;
        goto LABEL_144;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 298, 135, 0, "AADecompressionInputStreamOpen", v242, v243, v254);
      uint64_t v280 = 0;
      v288 = 0;
      uint64_t v283 = 0;
      uint64_t v284 = 0;
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 296, 135, 0, "aaIntervalInputStreamOpen", v239, v240, v254);
      uint64_t v280 = 0;
      v288 = 0;
      uint64_t v283 = 0;
      uint64_t v284 = 0;
      AAByteStream compressed_stream = 0;
    }
LABEL_279:
    unint64_t v296 = 0;
    unint64_t v286 = 0;
    goto LABEL_353;
  }
  if (*((unsigned __int16 *)v30 + 4) > 1u)
  {
    int v279 = (unsigned int **)AAFileStreamOpenWithPath(v196, 0, 0);
    if (v279)
    {
      if ((v90 & 1) == 0) {
        goto LABEL_277;
      }
      if ((io_set_nocache(v279) & 0x80000000) != 0) {
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 284, 135, "io_set_nocache %s", v202, v203, v204, v292[256]);
      }
      LODWORD(v205) = *(_DWORD *)(a1 + 48);
      uint64_t v205 = v205 >= 3 ? 3 : v205;
      int v91 = 1;
      int v279 = (unsigned int **)aaCacheStreamOpen((AAByteStream_impl *)v279, 0x1000000uLL, 14, 1, v205 << 62);
      if (v279)
      {
LABEL_277:
        unint64_t v293 = 0;
        goto LABEL_330;
      }
      uint64_t v244 = "aaCacheStreamOpen";
      __int16 v245 = 286;
    }
    else
    {
      uint64_t v244 = "AAFileStreamOpenWithPath";
      __int16 v245 = 281;
    }
LABEL_352:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v245, 135, 0, v244, v200, v201, v254);
    uint64_t v280 = 0;
    v288 = 0;
    uint64_t v283 = 0;
    uint64_t v284 = 0;
    AAByteStream compressed_stream = 0;
    unint64_t v293 = 0;
    unint64_t v296 = 0;
    unint64_t v286 = 0;
    unint64_t v291 = 0;
    s = 0;
    int v279 = 0;
LABEL_353:
    int v290 = 0;
    uint64_t v281 = 0;
    goto LABEL_354;
  }
  int v279 = 0;
  s = 0;
  unint64_t v291 = 0;
  AAByteStream compressed_stream = 0;
  uint64_t v283 = 0;
LABEL_312:
  uint64_t v89 = v289;
LABEL_106:
  uint64_t v289 = v89;
  unint64_t v293 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(v89 + 2048), 1538, 0x1A4u);
  if (!v293)
  {
    int v104 = "AAFileStreamOpenWithPath";
    __int16 v105 = 305;
    goto LABEL_142;
  }
  if ((v90 & 2) != 0 && (io_hint_static_content(v293) & 0x80000000) != 0) {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 308, 135, "ImagePatch: Static content hint failed.", v94, v95, v96, v254);
  }
  if ((io_preallocate(v293, *(void *)(v289 + 2120)) & 0x80000000) != 0) {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 311, 135, "ImagePatch: Preallocation failed.", v97, v98, v99, v254);
  }
  if (v91)
  {
    if ((io_set_nocache(v293) & 0x80000000) != 0) {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 316, 135, "io_set_nocache %s", v100, v101, v102, *(void *)(v289 + 2048));
    }
    LODWORD(v103) = *(_DWORD *)(a1 + 48);
    if (v103 >= 3) {
      uint64_t v103 = 3;
    }
    else {
      uint64_t v103 = v103;
    }
    int v272 = 1;
    unint64_t v293 = (unsigned int **)aaCacheStreamOpen((AAByteStream_impl *)v293, 0x100000uLL, 14, 1, v103 << 62);
    if (!v293)
    {
      int v104 = "aaCacheStreamOpen";
      __int16 v105 = 318;
LABEL_142:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v105, 135, 0, v104, v92, v93, v254);
      uint64_t v280 = 0;
      unint64_t v286 = 0;
      v288 = 0;
      uint64_t v284 = 0;
      unint64_t v293 = 0;
      unint64_t v296 = 0;
      goto LABEL_353;
    }
  }
  else
  {
    int v272 = 1;
  }
LABEL_144:
  uint64_t v123 = aaSegmentStreamOpen(v293, (void *)v289);
LABEL_145:
  unint64_t v286 = (AAByteStream_impl *)v123;
  if (!v123)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 322, 135, 0, "aaSegmentStreamOpen", v124, v125, v254);
    uint64_t v280 = 0;
    v288 = 0;
    uint64_t v284 = 0;
    goto LABEL_279;
  }
  unint64_t v296 = aaForkOutputStreamOpen((uint64_t)v123, (void *)v289);
  if (!v296)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 324, 135, 0, "aaForkOutputStreamOpen", v126, v127, v254);
    uint64_t v280 = 0;
    v288 = 0;
    uint64_t v284 = 0;
    unint64_t v296 = 0;
    goto LABEL_353;
  }
  uint64_t v284 = aaIntervalInputStreamOpen((uint64_t)v6, *(void *)(v30 + 46), *(void *)(v30 + 54));
  if (!v284)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 328, 135, 0, "aaIntervalInputStreamOpen", v128, v129, v254);
    uint64_t v280 = 0;
    v288 = 0;
    uint64_t v284 = 0;
    goto LABEL_353;
  }
  LODWORD(v130) = *(_DWORD *)(a1 + 48);
  if (v130 >= 3) {
    uint64_t v130 = 3;
  }
  else {
    uint64_t v130 = v130;
  }
  v288 = AADecompressionInputStreamOpen(v284, v130 << 62, *(_DWORD *)(a1 + 44));
  if (!v288)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 330, 135, 0, "AADecompressionInputStreamOpen", v131, v132, v254);
    uint64_t v280 = 0;
    v288 = 0;
    goto LABEL_353;
  }
  uint64_t v280 = calloc(1uLL, 0x10040uLL);
  if (!v280)
  {
    uint64_t v206 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"ctrl_reader_create", 36, 135, *v206, "aaCalloc", v207, v208, v254);
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 338, 135, 0, "control_reader_create", v209, v210, v256);
    uint64_t v280 = 0;
    goto LABEL_353;
  }
  *((void *)v280 + 0x2000) = v6;
  *((void *)v280 + 8195) = v30;
  *((void *)v280 + 8196) = a1;
  uint64_t v139 = *((unsigned __int16 *)v30 + 4) + 1;
  *((void *)v280 + 8197) = 0x2000 / v139 * v139;
  *((void *)v280 + 8198) = -1;
  uint64_t v140 = *(void *)(v30 + 18);
  *((void *)v280 + 8199) = v140 * v139;
  char v141 = v272;
  if (!v140) {
    char v141 = 1;
  }
  if ((v141 & 1) == 0)
  {
    unint64_t v282 = 0;
    uint64_t v219 = 0;
    while (1)
    {
      int v220 = (unint64_t *)ctrl_reader_get((uint64_t)v280, v282, v133, v134, v135, v136, v137, v138);
      if (!v220)
      {
        uint64_t v224 = "ctrl_reader_get";
        __int16 v225 = 349;
        goto LABEL_308;
      }
      if ((*v220 & 0x8000000000000000) == 0) {
        unint64_t v221 = *v220;
      }
      else {
        unint64_t v221 = 0x8000000000000000 - *v220;
      }
      uint64_t v222 = v220[v273 + 1];
      if (v222 < 0) {
        uint64_t v222 = 0x8000000000000000 - v222;
      }
      uint64_t v271 = v222;
      if (v221) {
        break;
      }
LABEL_305:
      v219 += v271;
      if (++v282 >= *(void *)(v30 + 18)) {
        goto LABEL_156;
      }
    }
    while (1)
    {
      uint64_t v223 = v221 >= 0x10000 ? 0x10000 : v221;
      if (v223 != aaByteStreamSimulate(v291)) {
        break;
      }
      v219 += v223;
      v221 -= v223;
      if (!v221) {
        goto LABEL_305;
      }
    }
    uint64_t v224 = "aaByteStreamSimulate";
    __int16 v225 = 358;
LABEL_308:
    int v226 = 0;
    goto LABEL_314;
  }
LABEL_156:
  uint64_t v281 = calloc(1uLL, 0x20000uLL);
  if (!v281)
  {
    int v226 = *__error();
    uint64_t v224 = "aaCalloc";
    __int16 v225 = 371;
LABEL_314:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v225, 135, v226, v224, v137, v138, v254);
    goto LABEL_353;
  }
  unint64_t v267 = 0;
  unint64_t v263 = 0;
  uint64_t v258 = v273 + 1;
  unint64_t v148 = *(void *)(v30 + 18);
  unsigned int v259 = 1;
  while (!v148)
  {
LABEL_250:
    int v187 = v272;
    if (v259 > 1) {
      int v187 = 1;
    }
    ++v259;
    if (v187 == 1)
    {
      if ((AAByteStreamTruncate(v293) & 0x80000000) == 0)
      {
        int v290 = 1;
        goto LABEL_354;
      }
      long long v246 = "AAByteStreamTruncate";
      __int16 v247 = 457;
LABEL_390:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v247, 135, 0, v246, v146, v147, v254);
      int v290 = 0;
LABEL_354:
      if (v279 == v293) {
        long long v248 = 0;
      }
      else {
        long long v248 = (AAByteStream_impl *)v279;
      }
      goto LABEL_357;
    }
  }
  unint64_t v260 = 0;
  unint64_t v268 = 0;
  uint64_t v262 = 0;
  while (2)
  {
    uint64_t v149 = (unint64_t *)ctrl_reader_get((uint64_t)v280, v260, v142, v143, v144, v145, v146, v147);
    if (!v149)
    {
      long long v246 = "ctrl_reader_get";
      __int16 v247 = 387;
      goto LABEL_390;
    }
    unint64_t v150 = *v149;
    uint64_t v151 = v149[1];
    if ((*v149 & 0x8000000000000000) != 0) {
      unint64_t v150 = 0x8000000000000000 - *v149;
    }
    unint64_t v265 = v150;
    unint64_t v152 = 0x8000000000000000 - v151;
    if (v151 >= 0) {
      unint64_t v152 = v149[1];
    }
    unint64_t v264 = v152;
    uint64_t v153 = v149[v258];
    if (v153 < 0) {
      uint64_t v153 = 0x8000000000000000 - v153;
    }
    uint64_t v257 = v153;
    if (v259 == 2)
    {
      v268 += v265;
      if ((v272 & 1) == 0 && v268 < *(void *)(v289 + 2056)) {
        goto LABEL_170;
      }
LABEL_218:
      if (v264)
      {
        unint64_t v266 = 0;
        while (1)
        {
          uint64_t v174 = v264 - v266;
          if (v264 - v266 >= 0x10000) {
            uint64_t v174 = 0x10000;
          }
          uint64_t v270 = v174;
          if (!*((void *)v288 + 2))
          {
LABEL_342:
            long long v246 = "aaByteStreamReadExpected";
            __int16 v247 = 439;
            goto LABEL_390;
          }
          if (v174)
          {
            uint64_t v175 = 0;
            uint64_t v176 = v281;
            uint64_t v177 = v174;
            while (1)
            {
              uint64_t v178 = (*((uint64_t (**)(void, unsigned char *, uint64_t))v288 + 2))(*(void *)v288, v176, v177);
              if (v178 < 0) {
                break;
              }
              if (v178)
              {
                v176 += v178;
                v175 += v178;
                v177 -= v178;
                if (v177) {
                  continue;
                }
              }
              goto LABEL_232;
            }
            uint64_t v175 = v178;
LABEL_232:
            if (v270 != v175) {
              goto LABEL_342;
            }
            if (!*((void *)v296 + 5)) {
              goto LABEL_343;
            }
            uint64_t v276 = 0;
            uint64_t v179 = v281;
            unint64_t v180 = v268;
            uint64_t v181 = v270;
            while (1)
            {
              uint64_t v182 = (*((uint64_t (**)(void, unsigned char *, uint64_t, unint64_t))v296 + 5))(*(void *)v296, v179, v181, v180);
              if (v182 < 1) {
                break;
              }
              v179 += v182;
              v276 += v182;
              v180 += v182;
              v181 -= v182;
              if (!v181) {
                goto LABEL_239;
              }
            }
            uint64_t v276 = v182;
LABEL_239:
            if (v270 != v276)
            {
LABEL_343:
              long long v246 = "aaByteStreamWriteExpected";
              __int16 v247 = 440;
              goto LABEL_390;
            }
          }
          else if (!*((void *)v296 + 5))
          {
            goto LABEL_343;
          }
          unint64_t v183 = v270 + v267;
          v267 += v270;
          if (*(void *)a1) {
            BOOL v184 = v183 > v263;
          }
          else {
            BOOL v184 = 0;
          }
          if (v184)
          {
            unint64_t v185 = *(void *)(v289 + 2080);
            if (v267 < v185)
            {
              unint64_t v186 = ((v185 >> 2) * (unsigned __int128)0x28F5C28F5C28F5C3uLL) >> 64;
              if (((*(uint64_t (**)(void, unint64_t))a1)(*(void *)(a1 + 8), v267 / (v185 / 0x64 + 1)) & 0x80000000) != 0)
              {
                __int16 v253 = 450;
                goto LABEL_393;
              }
              unint64_t v263 = v267 + (v186 >> 2);
            }
          }
          v268 += v270;
          v266 += v270;
          if (v266 >= v264) {
            goto LABEL_249;
          }
        }
      }
      goto LABEL_249;
    }
    if (!v265)
    {
LABEL_215:
      v262 += v257;
      if ((v272 & 1) != 0 || v259 != 1 || v268 < *(void *)(v289 + 2056)) {
        goto LABEL_218;
      }
LABEL_170:
      v268 += v264;
LABEL_249:
      unint64_t v148 = *(void *)(v30 + 18);
      if (++v260 >= v148) {
        goto LABEL_250;
      }
      continue;
    }
    break;
  }
  unint64_t v261 = 0;
  while (2)
  {
    uint64_t v154 = v265 - v261;
    if (v265 - v261 >= 0x10000) {
      uint64_t v154 = 0x10000;
    }
    uint64_t v269 = v154;
    if (!v291[4]) {
      goto LABEL_346;
    }
    if (v154)
    {
      uint64_t v274 = 0;
      unint64_t v155 = v281;
      uint64_t v156 = v262;
      uint64_t v157 = v154;
      while (1)
      {
        uint64_t v158 = ((uint64_t (*)(uint64_t, unsigned char *, uint64_t, uint64_t))v291[4])(*v291, v155, v157, v156);
        if (v158 < 0) {
          break;
        }
        if (v158)
        {
          v155 += v158;
          v274 += v158;
          v156 += v158;
          v157 -= v158;
          if (v157) {
            continue;
          }
        }
        goto LABEL_183;
      }
      uint64_t v274 = v158;
LABEL_183:
      if (v269 != v274)
      {
LABEL_346:
        long long v246 = "aaByteStreamPReadExpected";
        __int16 v247 = 400;
        goto LABEL_390;
      }
    }
    unint64_t v159 = *(void *)(v289 + 2072);
    if (v268 >= v159)
    {
LABEL_198:
      if (!*((void *)v296 + 5)) {
        goto LABEL_348;
      }
      if (v269)
      {
        uint64_t v275 = 0;
        uint64_t v166 = v281;
        unint64_t v167 = v268;
        uint64_t v168 = v269;
        while (1)
        {
          uint64_t v169 = (*((uint64_t (**)(void, unsigned char *, uint64_t, unint64_t))v296 + 5))(*(void *)v296, v166, v168, v167);
          if (v169 < 1) {
            break;
          }
          v166 += v169;
          v275 += v169;
          v167 += v169;
          v168 -= v169;
          if (!v168) {
            goto LABEL_205;
          }
        }
        uint64_t v275 = v169;
LABEL_205:
        if (v269 != v275)
        {
LABEL_348:
          long long v246 = "aaByteStreamWriteExpected";
          __int16 v247 = 412;
          goto LABEL_390;
        }
      }
    }
    else
    {
      if (v269 + v268 > v159)
      {
        long long v246 = "bad controls";
        __int16 v247 = 406;
        goto LABEL_390;
      }
      if (!*((void *)v283 + 2)) {
        goto LABEL_386;
      }
      if (v269)
      {
        uint64_t v160 = 0;
        uint64_t v161 = v281 + 0x10000;
        uint64_t v162 = v269;
        while (1)
        {
          uint64_t v163 = (*((uint64_t (**)(void, char *, uint64_t))v283 + 2))(*(void *)v283, v161, v162);
          if (v163 < 0) {
            break;
          }
          if (v163)
          {
            v161 += v163;
            v160 += v163;
            v162 -= v163;
            if (v162) {
              continue;
            }
          }
          goto LABEL_196;
        }
        uint64_t v160 = v163;
LABEL_196:
        BOOL v164 = v281;
        uint64_t v165 = v269;
        if (v269 != v160)
        {
LABEL_386:
          long long v246 = "aaByteStreamReadExpected";
          __int16 v247 = 407;
          goto LABEL_390;
        }
        do
        {
          *v164 += v164[0x10000];
          ++v164;
          --v165;
        }
        while (v165);
        goto LABEL_198;
      }
      if (!*((void *)v296 + 5)) {
        goto LABEL_348;
      }
    }
    unint64_t v170 = v267 + v269;
    v267 += v269;
    if (*(void *)a1) {
      BOOL v171 = v170 > v263;
    }
    else {
      BOOL v171 = 0;
    }
    if (!v171 || (unint64_t v172 = *(void *)(v289 + 2080), v267 >= v172))
    {
LABEL_214:
      v262 += v269;
      v268 += v269;
      v261 += v269;
      if (v261 >= v265) {
        goto LABEL_215;
      }
      continue;
    }
    break;
  }
  unint64_t v173 = ((v172 >> 2) * (unsigned __int128)0x28F5C28F5C28F5C3uLL) >> 64;
  if (((*(uint64_t (**)(void, unint64_t))a1)(*(void *)(a1 + 8), v267 / (v172 / 0x64 + 1)) & 0x80000000) == 0)
  {
    unint64_t v263 = v267 + (v173 >> 2);
    goto LABEL_214;
  }
  __int16 v253 = 422;
LABEL_393:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v253, 135, 0, "callback signaled abort", v146, v147, v254);
  if (v279 == v293) {
    long long v248 = 0;
  }
  else {
    long long v248 = (AAByteStream_impl *)v279;
  }
  if (v283) {
    AAByteStreamCancel(v283);
  }
  AAByteStreamCancel(v288);
  int v290 = 0;
LABEL_357:
  if (v280)
  {
    AAByteStreamClose(*((AAByteStream *)v280 + 8194));
    AAByteStreamClose(*((AAByteStream *)v280 + 8193));
    free(v280);
  }
  free(v281);
  AAByteStreamClose((AAByteStream)v291);
  AAByteStreamClose((AAByteStream)s);
  AAByteStreamClose(v248);
  AAByteStreamClose(v296);
  AAByteStreamClose(v286);
  AAByteStreamClose((AAByteStream)v293);
  AAByteStreamClose(v283);
  AAByteStreamClose(compressed_stream);
  AAByteStreamClose(v288);
  AAByteStreamClose(v284);
  if (v290)
  {
    if (rawimg_get_digests(*v29, 4, 0, 1)
      || (*v31 == *(void *)(*v29 + 2088) ? (BOOL v249 = v31[1] == *(void *)(*v29 + 2096)) : (BOOL v249 = 0),
          v249 ? (BOOL v250 = v31[2] == *(void *)(*v29 + 2104)) : (BOOL v250 = 0),
          v250 ? (BOOL v251 = v31[3] == *(void *)(*v29 + 2112)) : (BOOL v251 = 0),
          !v251))
    {
      unint64_t v121 = "digest mismatch";
      __int16 v122 = 630;
      goto LABEL_373;
    }
    if (*(int *)(a1 + 48) >= 2)
    {
      uint64_t v216 = (FILE *)*MEMORY[0x263EF8348];
      int v217 = "ImagePatch: Digest match. Output reconstructed.\n";
      size_t v218 = 48;
LABEL_381:
      fwrite(v217, v218, 1uLL, v216);
    }
    goto LABEL_382;
  }
  unint64_t v121 = "patch_apply";
  __int16 v122 = 621;
LABEL_373:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", v122, 135, 0, v121, v107, v108, v254);
LABEL_374:
  int v27 = 0;
LABEL_375:
  if (*((_WORD *)v30 + 4))
  {
    unint64_t v252 = 0;
    do
      rawimg_destroy((uint64_t *)v29[v252++]);
    while (v252 < *((unsigned __int16 *)v30 + 4));
  }
LABEL_27:
  if (!a2)
  {
LABEL_30:
    if (AAByteStreamClose(v6) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 649, 135, 0, "AAByteStreamClose", v32, v33, v254);
      int v27 = 0;
    }
  }
  free(v31);
  free(v30);
  free(v29);
  free(v28);
  if (v27) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t RawImagePatch(uint64_t a1)
{
  return RawImagePatchInternal(a1, 0);
}

uint64_t ctrl_reader_get(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1 + 0x10000;
  uint64_t v9 = *(void *)(a1 + 65560);
  if (*(void *)(v9 + 18) <= a2) {
    return 0;
  }
  unint64_t v11 = a2 + a2 * *(unsigned __int16 *)(v9 + 8);
  if (v11 >= *(void *)(a1 + 65584)) {
    goto LABEL_8;
  }
  uint64_t v12 = *(void *)(a1 + 65568);
  *(void *)(a1 + 65584) = -*(void *)(a1 + 65576);
  AAByteStreamClose(*(AAByteStream *)(a1 + 65552));
  *(void *)(v8 + 16) = 0;
  AAByteStreamClose(*(AAByteStream *)(v8 + 8));
  *(void *)(v8 + 8) = 0;
  unsigned int v13 = aaIntervalInputStreamOpen(*(void *)v8, *(void *)(v9 + 38), *(void *)(v9 + 46));
  *(void *)(v8 + 8) = v13;
  if (!v13)
  {
    int v27 = "aaIntervalInputStreamOpen";
    __int16 v28 = 81;
LABEL_24:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"ctrl_reader_get", v28, 135, 0, v27, a7, a8, v30);
    return 0;
  }
  uint64_t v14 = *(unsigned int *)(v12 + 48);
  if (v14 <= 3) {
    AAFlagSet v15 = v14 << 62;
  }
  else {
    AAFlagSet v15 = 0xC000000000000000;
  }
  AAByteStream v16 = AADecompressionInputStreamOpen(v13, v15, *(_DWORD *)(v12 + 44));
  *(void *)(v8 + 16) = v16;
  if (!v16)
  {
    int v27 = "AADecompressionInputStreamOpen";
    __int16 v28 = 83;
    goto LABEL_24;
  }
LABEL_8:
  while (1)
  {
    unint64_t v17 = *(void *)(v8 + 40);
    uint64_t v18 = *(void *)(v8 + 48);
    uint64_t v19 = v17 + v18;
    if (v11 < v17 + v18) {
      return a1 + 8 * (v11 - v18);
    }
    *(void *)(v8 + 48) = v19;
    unint64_t v20 = *(void *)(v8 + 56) - v19;
    if (v20 < v17) {
      unint64_t v17 = v20;
    }
    uint64_t v21 = *(void *)(v8 + 16);
    if (*(void *)(v21 + 16))
    {
      uint64_t v22 = 0;
      uint64_t v23 = 8 * v17;
      if (8 * v17)
      {
        uint64_t v24 = a1;
        uint64_t v25 = 8 * v17;
        while (1)
        {
          uint64_t v26 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v21 + 16))(*(void *)v21, v24, v25);
          if (v26 < 0) {
            break;
          }
          if (v26)
          {
            v24 += v26;
            v22 += v26;
            v25 -= v26;
            if (v25) {
              continue;
            }
          }
          goto LABEL_19;
        }
        uint64_t v22 = v26;
      }
LABEL_19:
      if (v23 == v22) {
        continue;
      }
    }
    int v27 = "aaByteStreamReadExpected";
    __int16 v28 = 91;
    goto LABEL_24;
  }
}

uint64_t ParallelArchiveCheckAndFix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v71[1] = *MEMORY[0x263EF8340];
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v52);
  bzero(v61, 0x458uLL);
  uint64_t v60 = a1;
  unsigned int DefaultNThreads = *(_DWORD *)(a1 + 4);
  if (!DefaultNThreads) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  unint64_t v59 = 0;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v54 = 0u;
  unsigned int v65 = DefaultNThreads;
  int v10 = calloc(DefaultNThreads, 0x8B0uLL);
  uint64_t v63 = v10;
  unint64_t v11 = malloc(8 * DefaultNThreads);
  uint64_t v64 = v11;
  if (v10) {
    BOOL v12 = v11 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12)
  {
    int v13 = *__error();
    AAByteStream v16 = "malloc";
    __int16 v17 = 365;
LABEL_17:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"ParallelArchiveCheckAndFix", v17, 13, v13, v16, v14, v15, v53);
    goto LABEL_18;
  }
  if (!realpath_DARWIN_EXTSN(*(const char **)(a1 + 16), v61))
  {
    int v13 = *__error();
    AAByteStream v16 = *(const char **)(a1 + 16);
    __int16 v17 = 366;
    goto LABEL_17;
  }
  uint64_t v18 = v65;
  if (v65)
  {
    uint64_t v19 = 0;
    do
    {
      unint64_t v20 = (uint64_t **)((char *)v63 + 2224 * v19);
      const char *v20 = &v60;
      *((void *)v64 + v19++) = v20;
    }
    while (v19 != v18);
  }
  char v62 = ThreadPoolCreate(v18, (uint64_t)v64, (uint64_t)checkAndFixThreadProc);
  if (!v62)
  {
    AAByteStream v16 = "ThreadPoolCreate";
    __int16 v17 = 375;
    int v13 = 0;
    goto LABEL_17;
  }
  long long v54 = 0u;
  long long v55 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v56 = 0u;
  DWORD1(v54) = *(_DWORD *)(a1 + 4);
  uint64_t v26 = *(void *)(a1 + 40);
  *((void *)&v54 + 1) = *(void *)(a1 + 24);
  *((void *)&v55 + 1) = v26;
  *(void *)&long long v56 = checkAndFixBeginEntry;
  *(void *)&long long v58 = checkAndFixEndEntry;
  *((void *)&v56 + 1) = checkAndFixBlob;
  *(void *)&long long v57 = checkAndFixPayload;
  unint64_t v59 = &v60;
  if (ParallelArchiveRead((uint64_t)&v54, v21, v22, v23, v24, v25, v14, v15))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"ParallelArchiveCheckAndFix", 390, 13, 0, "reading manifest", v27, v28, v53);
    int v29 = 0;
  }
  else
  {
    int v29 = 1;
  }
  if ((ThreadPoolDestroy((uint64_t)v62) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"ParallelArchiveCheckAndFix", 393, 13, 0, "ThreadPoolDestroy failed", v38, v39, v53);
    int v29 = 0;
    char v62 = 0;
    goto LABEL_19;
  }
  char v62 = 0;
  uint64_t v40 = atomic_load(v71);
  if (v40 > 0)
  {
LABEL_18:
    int v29 = 0;
    goto LABEL_19;
  }
  if (*(int *)a1 >= 1)
  {
    uint64_t v41 = (FILE **)MEMORY[0x263EF8348];
    uint64_t v42 = (FILE *)*MEMORY[0x263EF8348];
    unint64_t v43 = atomic_load(&v66);
    fprintf(v42, "%12lld entries in manifest\n", v43);
    size_t v44 = *v41;
    unint64_t v45 = atomic_load(&v67);
    fprintf(v44, "%12lld entries valid\n", v45);
    uint64_t v46 = *v41;
    unint64_t v47 = atomic_load(&v68);
    fprintf(v46, "%12lld entries fixed\n", v47);
    unint64_t v48 = *v41;
    unint64_t v49 = atomic_load(&v69);
    fprintf(v48, "%12lld entries invalid\n", v49);
    unint64_t v50 = *v41;
    unint64_t v51 = atomic_load(&v70);
    fprintf(v50, "%12lld entries missing\n", v51);
  }
LABEL_19:
  if ((ThreadPoolDestroy((uint64_t)v62) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"ParallelArchiveCheckAndFix", 409, 13, 0, "ThreadPoolDestroy", v30, v31, v53);
    int v29 = 0;
  }
  uint64_t v32 = v63;
  if (v63)
  {
    if (v65)
    {
      unint64_t v33 = 0;
      uint64_t v34 = 2216;
      do
      {
        free(*(void **)((char *)v63 + v34));
        ++v33;
        v34 += 2224;
      }
      while (v33 < v65);
      uint64_t v32 = v63;
    }
    free(v32);
  }
  free(v64);
  uint64_t result = leaveThreadErrorContext(0, 0, 0);
  if ((result & 0x80000000) == 0)
  {
    if (v29)
    {
      if (atomic_load(&v69))
      {
        return 0;
      }
      else
      {
        unint64_t v37 = atomic_load(&v70);
        return v37 == 0;
      }
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t checkAndFixThreadProc(uint64_t **a1)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  uint64_t v2 = (const char *)(a1 + 19);
  int v3 = *a1;
  int v5 = (char *)(*a1 + 1);
  uint64_t v4 = **a1;
  int v6 = *(_DWORD *)v4;
  uint64_t v8 = *(void (**)(uint64_t, uint64_t, int *))(v4 + 48);
  uint64_t v7 = *(void *)(v4 + 56);
  int v9 = *(_DWORD *)(v4 + 12);
  bzero(v63, 0x800uLL);
  memset(&v57, 0, sizeof(v57));
  atomic_fetch_add_explicit(v3 + 134, 1uLL, memory_order_relaxed);
  int v10 = (int *)(a1 + 1);
  if (concatPath(v63, 0x800uLL, v5, v2))
  {
    LOBYTE(v53) = (_BYTE)v2;
    int v13 = "building full path: %s";
    __int16 v14 = 80;
LABEL_3:
    int v15 = 0;
LABEL_4:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixThreadProc", v14, 13, v15, v13, v11, v12, (char)v53);
    atomic_fetch_add_explicit(v3 + 139, 1uLL, memory_order_relaxed);
LABEL_5:
    AAByteStream v16 = v3 + 137;
    uint64_t v17 = 2;
    goto LABEL_10;
  }
  if (v6 >= 3) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "> %s %zu\n", v63, (size_t)a1[276]);
  }
  if (lstat(v63, &v57)) {
    goto LABEL_9;
  }
  if (*((_DWORD *)a1 + 3) == 72) {
    int v19 = 70;
  }
  else {
    int v19 = *((_DWORD *)a1 + 3);
  }
  if (v19 != getAAEntryType(v57.st_mode)) {
    goto LABEL_5;
  }
  BOOL v20 = *((_DWORD *)a1 + 3) == 70 && statIsCompressed(v57.st_flags) != 0;
  int v21 = *v10;
  if ((*v10 & 8) != 0)
  {
    if (statIsCompressed(*((_DWORD *)a1 + 6))) {
      BOOL v20 = 1;
    }
    int v21 = *((_DWORD *)a1 + 2);
  }
  int v22 = *(_DWORD *)(*v3 + 8) & v21;
  int v23 = *((_DWORD *)a1 + 3);
  if (v23 == 70)
  {
    unint64_t v61 = 0;
    uint64_t v60 = 0;
    unsigned int v62 = 0;
    long long __s2 = 0u;
    long long v59 = 0u;
    int v56 = 0;
    if ((v22 & 0x2000) != 0) {
      uint64_t v24 = (unsigned __int8 *)&v60;
    }
    else {
      uint64_t v24 = 0;
    }
    if ((v22 & 0x4000) != 0) {
      p_s2 = (unsigned __int8 *)&__s2;
    }
    else {
      p_s2 = 0;
    }
    if ((v22 & 0x1000) != 0) {
      uint64_t v26 = (unsigned int *)&v56;
    }
    else {
      uint64_t v26 = 0;
    }
    if ((getFileDigests(v63, v24, p_s2, v26) & 0x80000000) != 0)
    {
      char v53 = v63;
      int v13 = "computing file digests: %s";
      __int16 v14 = 120;
      goto LABEL_3;
    }
    BOOL v27 = (v22 & 0x2000) != 0
       && (*(uint64_t **)((char *)a1 + 100) != v60
        || *(uint64_t **)((char *)a1 + 108) != v61
        || *((_DWORD *)a1 + 29) != (unint64_t)v62);
    if ((v22 & 0x4000) != 0
      && (unint64_t)a1[15] ^ (unint64_t)__s2 | (unint64_t)a1[16] ^ *((void *)&__s2 + 1) | (unint64_t)a1[17] ^ (unint64_t)v59 | (unint64_t)a1[18] ^ *((void *)&v59 + 1))
    {
      BOOL v27 = 1;
    }
    if ((v22 & 0x1000) != 0 && *((_DWORD *)a1 + 24) != v56) {
      BOOL v27 = 1;
    }
    int v31 = *((_DWORD *)a1 + 3);
    if (v31 != 76 || (v22 & 0x10000) == 0)
    {
      if (!v27)
      {
        int v28 = 0;
        goto LABEL_74;
      }
LABEL_65:
      if (v31 == 70)
      {
        BOOL v27 = 1;
        if (a1[276])
        {
          int v28 = 1;
          if ((v9 & 1) == 0)
          {
            long long __s2 = 0uLL;
            *(void *)&long long v59 = 0;
            int v32 = open(v63, 2);
            if (v32 < 0)
            {
              int v15 = *__error();
              char v53 = v63;
              int v13 = "%s";
              __int16 v14 = 154;
              goto LABEL_4;
            }
            int v33 = v32;
            int v34 = ParallelArchiveECCFixFileSegment(v32, 0, v57.st_size, (long long *)a1[277], (unint64_t)a1[276], (uint64_t)&__s2);
            close(v33);
            if (v34 < 0)
            {
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixThreadProc", 163, 13, "Data not fixed with ECC (diag 0x%08x): %s", v35, v36, v37, SBYTE4(v59));
              int v38 = 1;
            }
            else
            {
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixThreadProc", 169, 13, "Data fixed with ECC (diag 0x%08x): %s", v35, v36, v37, SBYTE4(v59));
              int v38 = 0;
            }
            ParallelCompressionUpdateWarning(DWORD1(v59) | 0xFF000000, &unk_2106C9523);
            if (lstat(v63, &v57)) {
              goto LABEL_9;
            }
            BOOL v27 = 1;
            int v28 = v38;
          }
          goto LABEL_74;
        }
      }
      else
      {
        BOOL v27 = 1;
      }
      int v28 = 1;
      goto LABEL_74;
    }
LABEL_58:
    bzero(&__s2, 0x400uLL);
    if (readlink(v63, (char *)&__s2, 0x400uLL) < 0)
    {
      int v15 = *__error();
      char v53 = v63;
      int v13 = "reading link: %s";
      __int16 v14 = 136;
      goto LABEL_4;
    }
    int v28 = strncmp((const char *)a1 + 1176, (const char *)&__s2, 0x400uLL) | v27;
    if (!v28)
    {
      BOOL v27 = 0;
      goto LABEL_74;
    }
    int v31 = *((_DWORD *)a1 + 3);
    goto LABEL_65;
  }
  BOOL v27 = 0;
  if (v23 != 76)
  {
    int v28 = 0;
    goto LABEL_74;
  }
  int v28 = 0;
  if ((v22 & 0x10000) != 0) {
    goto LABEL_58;
  }
LABEL_74:
  int v55 = v28;
  BOOL v39 = (v22 & 2) != 0 && v57.st_uid != *((_DWORD *)a1 + 4);
  if ((v22 & 4) != 0)
  {
    if (v57.st_gid != *((_DWORD *)a1 + 5)) {
      BOOL v39 = 1;
    }
    if ((v22 & 0x10) == 0)
    {
LABEL_79:
      if ((v22 & 8) == 0) {
        goto LABEL_82;
      }
      goto LABEL_80;
    }
  }
  else if ((v22 & 0x10) == 0)
  {
    goto LABEL_79;
  }
  if ((*((_DWORD *)a1 + 7) & 0xFFF) != (v57.st_mode & 0xFFF)) {
    BOOL v39 = 1;
  }
  if ((v22 & 8) != 0)
  {
LABEL_80:
    if (v57.st_flags != *((_DWORD *)a1 + 6)) {
      BOOL v39 = 1;
    }
  }
LABEL_82:
  if (*((_DWORD *)a1 + 3) != 70) {
    goto LABEL_99;
  }
  int IsCompressed = statIsCompressed(v57.st_flags);
  if (v20)
  {
    if (IsCompressed) {
      goto LABEL_99;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixThreadProc", 200, 13, "Compressing the file: %s\n", v41, v42, v43, (char)v63);
    if ((ParallelCompressionAFSCCompress(v63, 1) & 0x80000000) != 0)
    {
      unint64_t v47 = "Error compressing file";
      __int16 v48 = 201;
LABEL_97:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixThreadProc", v48, 13, v47, v44, v45, v46, v54);
    }
  }
  else
  {
    if (!IsCompressed) {
      goto LABEL_99;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixThreadProc", 212, 13, "Decompressing the file: %s\n", v41, v42, v43, (char)v63);
    if ((ParallelCompressionAFSCCompress(v63, 0) & 0x80000000) != 0)
    {
      unint64_t v47 = "Error decompressing file";
      __int16 v48 = 213;
      goto LABEL_97;
    }
  }
  if (lstat(v63, &v57))
  {
LABEL_9:
    AAByteStream v16 = v3 + 138;
    uint64_t v17 = 3;
    goto LABEL_10;
  }
LABEL_99:
  int v49 = v39;
  if (v39)
  {
    int v49 = v39;
    if ((v9 & 2) == 0)
    {
      if ((yaa_setEntryAttributes(v63, v10, 0, 0) & 0x80000000) != 0)
      {
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixThreadProc", 234, 13, "Attr not fixed: %s", v50, v51, v52, (char)v63);
        int v49 = 1;
      }
      else
      {
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixThreadProc", 238, 13, "Attr fixed: %s", v50, v51, v52, (char)v63);
        int v49 = 0;
      }
    }
  }
  if (v49 | v55) {
    goto LABEL_5;
  }
  if (v39 || v27)
  {
    AAByteStream v16 = v3 + 136;
    uint64_t v17 = 1;
  }
  else
  {
    uint64_t v17 = 0;
    AAByteStream v16 = v3 + 135;
  }
LABEL_10:
  atomic_fetch_add_explicit(v16, 1uLL, memory_order_relaxed);
  if (v8) {
    v8(v7, v17, v10);
  }
  return 0;
}

void *checkAndFixBeginEntry(void *result, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2[1] != 77)
  {
    int v9 = result;
    uint64_t Worker = ThreadPoolGetWorker(result[129], (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    v9[130] = Worker;
    if (Worker)
    {
      *(void *)(Worker + 2208) = 0;
      int v13 = (void *)(Worker + 8);
      return memcpy(v13, a2, 0x890uLL);
    }
    else
    {
      uint64_t result = (void *)pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixBeginEntry", 291, 13, 0, "ThreadPoolGetWorker failed", v11, v12, v14);
      atomic_fetch_add_explicit(v9 + 139, 1uLL, memory_order_relaxed);
    }
  }
  return result;
}

size_t checkAndFixEndEntry(size_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(result + 1040);
  if (v8)
  {
    size_t v9 = result;
    uint64_t result = ThreadPoolRunWorker(*(void *)(result + 1032), v8, a3, a4, a5, a6, a7, a8);
    if ((result & 0x80000000) != 0)
    {
      uint64_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixEndEntry", 305, 13, 0, "ThreadPoolRunWorker failed", v10, v11, v12);
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 1112), 1uLL, memory_order_relaxed);
    }
    *(void *)(v9 + 1040) = 0;
  }
  return result;
}

uint64_t checkAndFixBlob(uint64_t result, _DWORD *a2, size_t __size)
{
  uint64_t v3 = *(void *)(result + 1040);
  if (v3)
  {
    uint64_t v4 = result;
    BOOL v5 = (*a2 & 0xDFDFDF) == 4408665;
    *(_DWORD *)(result + 1068) = (*a2 & 0xDFDFDF) == 4408665;
    if (v5 && *(void *)(v3 + 2200) < __size)
    {
      *(void *)(v3 + 2200) = __size;
      uint64_t result = (uint64_t)reallocf(*(void **)(v3 + 2216), __size);
      *(void *)(v3 + 2216) = result;
      if (!result)
      {
        int v6 = __error();
        uint64_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixBlob", 327, 13, *v6, "malloc", v7, v8, v9);
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 1112), 1uLL, memory_order_relaxed);
      }
    }
  }
  return result;
}

uint64_t checkAndFixPayload(uint64_t result, const void *a2, size_t __n, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void **)(result + 1040);
  if (v8)
  {
    uint64_t v9 = result;
    if (*(_DWORD *)(result + 1068))
    {
      uint64_t v11 = v8[276];
      if (v11 + __n <= v8[275])
      {
        uint64_t result = (uint64_t)memcpy((void *)(v8[277] + v11), a2, __n);
        v8[276] += __n;
      }
      else
      {
        uint64_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixPayload", 342, 13, 0, "Invalid YEC blob size", a7, a8, v12);
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 1112), 1uLL, memory_order_relaxed);
      }
    }
  }
  return result;
}

uint64_t ParallelCompressionGetCompressedSize(uint64_t a1, unint64_t a2, int a3)
{
  uint64_t v3 = a2;
  if (a2 >= 0x400)
  {
    uint64_t v24 = 0;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    uint64_t v19 = 0;
    uint64_t v7 = IMemStreamCreate(a1, a2);
    if (v7)
    {
      DWORD2(v20) = a3;
      LODWORD(v20) = 0;
      DWORD1(v20) = getDefaultNThreads();
      *(void *)&long long v21 = 0x200000;
      *((void *)&v21 + 1) = IMemStreamRead;
      *((void *)&v22 + 1) = v7;
      *(void *)&long long v23 = getCompressedSizeCounterProc;
      uint64_t v24 = &v19;
      if (!ParallelCompressionEncode((uint64_t)&v20, v8, v9, v10, v11, v12, v13, v14))
      {
        if (v19 < v3) {
          uint64_t v3 = v19;
        }
        goto LABEL_9;
      }
      int v15 = "ParallelCompressionEncode";
      __int16 v16 = 75;
    }
    else
    {
      int v15 = "IMemStreamCreate";
      __int16 v16 = 64;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ParallelCompressionGetCompressedSize", v16, 39, 0, v15, v5, v6, v18);
    uint64_t v3 = -1;
LABEL_9:
    IMagicStreamDestroy(v7);
  }
  return v3;
}

uint64_t getCompressedSizeCounterProc(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 += a3;
  return a3;
}

uint64_t IDecoderStreamThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (ParallelCompressionDecode(a1, a2, a3, a4, a5, a6, a7, a8)) {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamThreadProc", 100, 39, 0, "decoder failed", v8, v9, vars0);
  }
  return 0;
}

uint64_t IDecoderStreamCreate(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, int a5)
{
  uint64_t v10 = malloc(0x48uLL);
  uint64_t v18 = (uint64_t)v10;
  if (v10)
  {
    v10[2] = 0u;
    v10[3] = 0u;
    *uint64_t v10 = 0u;
    v10[1] = 0u;
    uint64_t v19 = SharedBufferCreate(a4, v11, v12, v13, v14, v15, v16, v17);
    *(void *)(v18 + 64) = v19;
    if (!v19)
    {
      long long v23 = "fail to init buffer";
      __int16 v24 = 112;
      int v22 = 0;
      goto LABEL_7;
    }
    *(_DWORD *)uint64_t v18 = 0;
    *(_DWORD *)(v18 + 4) = a5;
    *(void *)(v18 + 8) = a1;
    *(void *)(v18 + 16) = a2;
    *(void *)(v18 + 24) = a3;
    *(void *)(v18 + 32) = SharedBufferWrite;
    *(void *)(v18 + 40) = SharedBufferAbort;
    *(void *)(v18 + 48) = v19;
    if (createThread((pthread_t *)(v18 + 56), (uint64_t)IDecoderStreamThreadProc, v18, 0))
    {
      int v22 = *__error();
      long long v23 = "failed to start decoder thread";
      __int16 v24 = 125;
LABEL_7:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamCreate", v24, 39, v22, v23, v20, v21, v29);
      IDecoderStreamDestroy((void *)v18);
      return 0;
    }
  }
  else
  {
    uint64_t v25 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamCreate", 107, 39, *v25, "malloc", v26, v27, v29);
  }
  return v18;
}

void IDecoderStreamDestroy(void *a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a1[8])
    {
      while (1)
      {
        uint64_t v2 = SharedBufferRead(a1[8], (uint64_t)v10, 0x400uLL);
        if (v2 < 0) {
          break;
        }
        if (!v2) {
          goto LABEL_7;
        }
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamDestroy", 155, 39, 0, "flushing shared buffer", v3, v4, v9);
    }
LABEL_7:
    uint64_t v5 = (_opaque_pthread_t *)a1[7];
    if (v5)
    {
      if (joinThread(v5))
      {
        uint64_t v6 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamDestroy", 163, 39, *v6, "failed to join decoder thread", v7, v8, v9);
      }
    }
    SharedBufferDestroy(a1[8]);
    free(a1);
  }
}

uint64_t IDecoderStreamRead(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1) {
    return SharedBufferRead(*(void *)(a1 + 64), a2, a3);
  }
  else {
    return -1;
  }
}

size_t IDecoderStreamAbort(size_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (result) {
    return SharedBufferAbort(*(void *)(result + 64), a2, a3, a4, a5, a6, a7, a8, a9);
  }
  return result;
}

uint64_t OEncoderStreamThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (ParallelCompressionEncode(a1, a2, a3, a4, a5, a6, a7, a8)) {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"OEncoderStreamThreadProc", 192, 39, 0, "encoder failed", v8, v9, vars0);
  }
  return 0;
}

uint64_t OEncoderStreamCreate(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, int a5, uint64_t a6, int a7)
{
  uint64_t v14 = malloc(0x60uLL);
  uint64_t v22 = (uint64_t)v14;
  if (v14)
  {
    v14[10] = 0;
    *((_OWORD *)v14 + 3) = 0u;
    *((_OWORD *)v14 + 4) = 0u;
    *((_OWORD *)v14 + 1) = 0u;
    *((_OWORD *)v14 + 2) = 0u;
    *(_OWORD *)uint64_t v14 = 0u;
    long long v23 = SharedBufferCreate(a4, v15, v16, v17, v18, v19, v20, v21);
    *(void *)(v22 + 88) = v23;
    if (!v23)
    {
      uint64_t v27 = "init buffer";
      __int16 v28 = 204;
      int v26 = 0;
      goto LABEL_7;
    }
    *(_DWORD *)(v22 + 4) = a7;
    *(_DWORD *)(v22 + 8) = a5;
    *(_DWORD *)uint64_t v22 = 0;
    *(void *)(v22 + 16) = a6;
    *(void *)(v22 + 24) = SharedBufferRead;
    *(void *)(v22 + 32) = SharedBufferAbort;
    *(void *)(v22 + 40) = v23;
    *(void *)(v22 + 48) = a1;
    *(void *)(v22 + 56) = a2;
    *(void *)(v22 + 64) = a3;
    if (createThread((pthread_t *)(v22 + 80), (uint64_t)OEncoderStreamThreadProc, v22, 0))
    {
      int v26 = *__error();
      uint64_t v27 = "failed to start encoder thread";
      __int16 v28 = 219;
LABEL_7:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"OEncoderStreamCreate", v28, 39, v26, v27, v24, v25, v40);
      OEncoderStreamDestroy(v22, v32, v33, v34, v35, v36, v37, v38);
      return 0;
    }
  }
  else
  {
    char v29 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"OEncoderStreamCreate", 199, 39, *v29, "malloc", v30, v31, v40);
  }
  return v22;
}

void OEncoderStreamDestroy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (!*(_DWORD *)(a1 + 72)) {
      SharedBufferWrite(*(void *)(a1 + 88), 0, 0, a4, a5, a6, a7, a8);
    }
    uint64_t v9 = *(_opaque_pthread_t **)(a1 + 80);
    if (v9 && joinThread(v9))
    {
      uint64_t v10 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"OEncoderStreamDestroy", 260, 39, *v10, "failed to join encoder thread", v11, v12, v13);
    }
    SharedBufferDestroy(*(void *)(a1 + 88));
    free((void *)a1);
  }
}

uint64_t OEncoderStreamWrite(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return -1;
  }
  int v8 = *(_DWORD *)(a1 + 72);
  if (a3)
  {
    if (v8)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"OEncoderStreamWrite", 241, 39, 0, "extra bytes written after EOF has been sent", a7, a8, vars0);
      return -1;
    }
  }
  else
  {
    if (v8) {
      return 0;
    }
    *(_DWORD *)(a1 + 72) = 1;
  }
  size_t v10 = *(void *)(a1 + 88);

  return SharedBufferWrite(v10, a2, a3, a4, a5, a6, a7, a8);
}

size_t OEncoderStreamAbort(size_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (result) {
    return SharedBufferAbort(*(void *)(result + 88), a2, a3, a4, a5, a6, a7, a8, a9);
  }
  return result;
}

void *OFileEncoderStreamCreateWithFD(int a1, uint64_t a2, unint64_t a3, int a4, uint64_t a5, int a6)
{
  uint64_t v12 = malloc(0x10uLL);
  char v13 = v12;
  if (v12)
  {
    v12[1] = 0;
    uint64_t v14 = OFileStreamCreateWithFD(a1, a2);
    void *v13 = v14;
    if (!v14
      || (uint64_t v22 = OEncoderStreamCreate((uint64_t)OFileStreamWrite, (uint64_t)OFileStreamAbort, (uint64_t)v14, a3, a4, a5, a6),
          (v13[1] = v22) == 0))
    {
      OFileEncoderStreamDestroy((uint64_t)v13, v15, v16, v17, v18, v19, v20, v21);
      return 0;
    }
  }
  else
  {
    long long v23 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"OFileEncoderStreamCreateWithFD", 355, 39, *v23, "malloc", v24, v25, v27);
  }
  return v13;
}

void OFileEncoderStreamDestroy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    OEncoderStreamDestroy(*(void *)(a1 + 8), a2, a3, a4, a5, a6, a7, a8);
    OFileStreamDestroy(*(int **)a1);
    free((void *)a1);
  }
}

uint64_t OFileEncoderStreamWrite(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return OEncoderStreamWrite(*(void *)(a1 + 8), a2, a3, a4, a5, a6, a7, a8);
}

uint64_t ILowMemoryDecoderStreamCreate(uint64_t (*a1)(uint64_t, uint64_t, unint64_t), uint64_t a2, uint64_t a3, size_t a4)
{
  int v8 = malloc(0xD8uLL);
  uint64_t v9 = (uint64_t)v8;
  if (v8)
  {
    v8[26] = 0;
    *((_OWORD *)v8 + 11) = 0u;
    *((_OWORD *)v8 + 12) = 0u;
    *((_OWORD *)v8 + 9) = 0u;
    *((_OWORD *)v8 + 10) = 0u;
    *((_OWORD *)v8 + 7) = 0u;
    *((_OWORD *)v8 + 8) = 0u;
    *((_OWORD *)v8 + 5) = 0u;
    *((_OWORD *)v8 + 6) = 0u;
    *((_OWORD *)v8 + 3) = 0u;
    *((_OWORD *)v8 + 4) = 0u;
    *((_OWORD *)v8 + 1) = 0u;
    *((_OWORD *)v8 + 2) = 0u;
    if (a4 <= 0x1000) {
      a4 = 4096;
    }
    *(_OWORD *)int v8 = 0uLL;
    size_t v10 = MemBufferCreate(a4);
    *(void *)(v9 + 56) = v10;
    if (!v10) {
      goto LABEL_27;
    }
    uint64_t v11 = MemBufferCreate(a4);
    *(void *)(v9 + 64) = v11;
    if (!v11) {
      goto LABEL_27;
    }
    *(_DWORD *)(v9 + 32) = -1;
    *(void *)uint64_t v9 = a1;
    *(void *)(v9 + 8) = a2;
    *(void *)(v9 + 16) = a3;
    if (MemBufferFillFromIStream(*(unint64_t **)(v9 + 56), 0xCuLL, a1, a3) != 12)
    {
      uint64_t v19 = "couldn't read enough header bytes from compressed file";
      __int16 v20 = 465;
      goto LABEL_26;
    }
    uint64_t DataPtr = MemBufferGetDataPtr(*(void *)(v9 + 56));
    if ((*(_DWORD *)(v9 + 32) & 0x80000000) != 0)
    {
      uint64_t v15 = (unsigned __int8 *)DataPtr;
      if (*(_WORD *)DataPtr == 25200 && *(unsigned char *)(DataPtr + 2) == 122)
      {
        unsigned int v25 = 0;
        while (1)
        {
          int v26 = v15[3];
          if (v26 == PCompressGetDecoderKey(v25)) {
            break;
          }
          if (++v25 == 7)
          {
            if ((*(_DWORD *)(v9 + 32) & 0x80000000) == 0) {
              return v9;
            }
            goto LABEL_12;
          }
        }
        *(void *)(v9 + 40) = bswap64(*(void *)(v15 + 4));
        *(void *)(v9 + 48) = PCompressGetDecoderFilter(v25);
        MemBufferDecreaseSize(*(void *)(v9 + 56), 0xCuLL, v34, v35, v36, v37, v38, v39);
        if ((MemBufferIncreaseCapacity(*(void *)(v9 + 56), *(void *)(v9 + 40)) & 0x8000000000000000) != 0)
        {
          uint64_t v19 = "MemBufferIncreaseCapacity in";
          __int16 v20 = 487;
        }
        else
        {
          if ((MemBufferIncreaseCapacity(*(void *)(v9 + 64), *(void *)(v9 + 40)) & 0x8000000000000000) == 0)
          {
            *(_DWORD *)(v9 + 32) = 0;
            return v9;
          }
          uint64_t v19 = "MemBufferIncreaseCapacity out";
          __int16 v20 = 488;
        }
        goto LABEL_26;
      }
LABEL_12:
      if (*(_DWORD *)v15 == 1484404733 && *((_WORD *)v15 + 2) == 90)
      {
        if (!lzma_stream_decoder())
        {
          *(_DWORD *)(v9 + 32) = 1;
          return v9;
        }
        uint64_t v19 = "lzma_stream_decoder";
        __int16 v20 = 503;
        goto LABEL_26;
      }
      BOOL v18 = *(_WORD *)v15 == 23106 && v15[2] == 104;
      if (v18 && v15[3] - 49 <= 8)
      {
        if (BZ2_bzDecompressInit((bz_stream *)(v9 + 72), 0, 0))
        {
          uint64_t v19 = "BZ2_bzDecompressInit";
          __int16 v20 = 514;
LABEL_26:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamCreate", v20, 39, 0, v19, v12, v13, v47);
LABEL_27:
          ILowMemoryDecoderStreamDestroy(v9);
          return 0;
        }
        int v44 = 3;
LABEL_54:
        *(_DWORD *)(v9 + 32) = v44;
        return v9;
      }
      int v27 = *v15;
      if (v27 == 120)
      {
        if (-1108378657 * (v15[1] | 0x7800u) <= 0x8421084)
        {
          if (compression_stream_init((compression_stream *)(v9 + 72), COMPRESSION_STREAM_DECODE, COMPRESSION_ZLIB) == COMPRESSION_STATUS_OK)
          {
            MemBufferDecreaseSize(*(void *)(v9 + 56), 2uLL, v40, v41, v42, v43, v12, v13);
            *(_DWORD *)(v9 + 32) = 2;
            return v9;
          }
          uint64_t v19 = "compression_stream_init";
          __int16 v20 = 570;
          goto LABEL_26;
        }
      }
      else if (v27 == 31 && v15[1] == 139 && v15[2] == 8)
      {
        if (MemBufferFillFromIStream(*(unint64_t **)(v9 + 56), 0x1000uLL, *(uint64_t (**)(uint64_t, uint64_t, unint64_t))v9, *(void *)(v9 + 16)) < 0)
        {
          uint64_t v19 = "reading gzip header data";
          __int16 v20 = 525;
          goto LABEL_26;
        }
        unint64_t DataSize = MemBufferGetDataSize(*(void *)(v9 + 56));
        if ((v15[3] & 4) != 0)
        {
          if (DataSize <= 0xB)
          {
            uint64_t v19 = "parsing gzip header";
            __int16 v20 = 531;
            goto LABEL_26;
          }
          unint64_t v33 = *((unsigned __int16 *)v15 + 5) + 12;
          if (v33 > DataSize)
          {
            uint64_t v19 = "parsing gzip header";
            __int16 v20 = 534;
            goto LABEL_26;
          }
        }
        else
        {
          unint64_t v33 = 10;
        }
        if ((v15[3] & 8) != 0)
        {
          unint64_t v45 = v33 + 2;
          if (v33 + 2 > DataSize)
          {
            uint64_t v19 = "parsing gzip header";
            __int16 v20 = 539;
            goto LABEL_26;
          }
          if (v33 + 2 < DataSize)
          {
            while (v15[v33 + 1])
            {
              if (DataSize - 2 == ++v33)
              {
                unint64_t v45 = DataSize;
                goto LABEL_63;
              }
            }
            unint64_t v45 = v33 + 2;
          }
        }
        else
        {
          unint64_t v45 = v33;
        }
LABEL_63:
        if ((v15[3] & 0x10) != 0)
        {
          unint64_t v46 = v45 + 2;
          if (v45 + 2 > DataSize)
          {
            uint64_t v19 = "parsing gzip header";
            __int16 v20 = 545;
            goto LABEL_26;
          }
          if (v45 + 2 < DataSize)
          {
            while (v15[v45 + 1])
            {
              if (DataSize - 2 == ++v45)
              {
                unint64_t v46 = DataSize;
                goto LABEL_65;
              }
            }
            unint64_t v46 = v45 + 2;
          }
        }
        else
        {
          unint64_t v46 = v45;
        }
LABEL_65:
        if ((v15[3] & 2) != 0)
        {
          v46 += 2;
          if (v46 > DataSize)
          {
            uint64_t v19 = "parsing gzip header";
            __int16 v20 = 551;
            goto LABEL_26;
          }
        }
        MemBufferDecreaseSize(*(void *)(v9 + 56), v46, v29, v30, v31, v32, v12, v13);
        if (compression_stream_init((compression_stream *)(v9 + 72), COMPRESSION_STREAM_DECODE, COMPRESSION_ZLIB))
        {
          uint64_t v19 = "compression_stream_init";
          __int16 v20 = 557;
          goto LABEL_26;
        }
        int v44 = 2;
        goto LABEL_54;
      }
      uint64_t v19 = "Could not identify compressed stream format";
      __int16 v20 = 579;
      goto LABEL_26;
    }
  }
  else
  {
    uint64_t v21 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamCreate", 452, 39, *v21, "malloc", v22, v23, v47);
  }
  return v9;
}

void ILowMemoryDecoderStreamDestroy(uint64_t a1)
{
  if (a1)
  {
    int v2 = *(_DWORD *)(a1 + 32);
    switch(v2)
    {
      case 3:
        BZ2_bzDecompressEnd((bz_stream *)(a1 + 72));
        break;
      case 2:
        compression_stream_destroy((compression_stream *)(a1 + 72));
        break;
      case 1:
        lzma_end();
        break;
    }
    MemBufferDestroy(*(void ***)(a1 + 56));
    MemBufferDestroy(*(void ***)(a1 + 64));
    IMagicStreamDestroy(*(void **)(a1 + 24));
    free((void *)a1);
  }
}

uint64_t ILowMemoryDecoderStreamCreateWithBuffer(uint64_t a1, uint64_t a2, size_t a3)
{
  uint64_t v4 = IMemStreamCreate(a1, a2);
  if (v4)
  {
    uint64_t v7 = v4;
    uint64_t result = ILowMemoryDecoderStreamCreate((uint64_t (*)(uint64_t, uint64_t, unint64_t))IMemStreamRead, (uint64_t)IMemStreamAbort, (uint64_t)v4, a3);
    if (result)
    {
      *(void *)(result + 24) = v7;
      return result;
    }
    IMagicStreamDestroy(v7);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamCreateWithBuffer", 596, 39, 0, "IMemStreamCreate failed", v5, v6, v9);
  }
  return 0;
}

uint64_t ILowMemoryDecoderStreamRead(uint64_t a1, char *a2, size_t a3)
{
  if (a1)
  {
    int v6 = 0;
    uint64_t v7 = 0;
    stream = (bz_stream *)(a1 + 72);
    do
    {
      if (!a3) {
        return v7;
      }
      unint64_t DataSize = MemBufferGetDataSize(*(void *)(a1 + 64));
      if (DataSize >= a3) {
        size_t v9 = a3;
      }
      else {
        size_t v9 = DataSize;
      }
      if (v9)
      {
        uint64_t DataPtr = (const void *)MemBufferGetDataPtr(*(void *)(a1 + 64));
        memcpy(a2, DataPtr, v9);
        MemBufferDecreaseSize(*(void *)(a1 + 64), v9, v11, v12, v13, v14, v15, v16);
        v7 += v9;
        a3 -= v9;
        if (!a3) {
          return v7;
        }
        a2 += v9;
      }
      if (*(_DWORD *)(a1 + 208)) {
        return v7;
      }
      uint64_t v17 = *(unint64_t **)(a1 + 56);
      if (!*(_DWORD *)(a1 + 32))
      {
        unint64_t v43 = MemBufferGetDataSize((uint64_t)v17);
        uint64_t v44 = v43;
        if (v43 <= 0xF)
        {
          if (MemBufferFillFromIStream(*(unint64_t **)(a1 + 56), 16 - v43, *(uint64_t (**)(uint64_t, uint64_t, unint64_t))a1, *(void *)(a1 + 16)) < 0)
          {
            uint64_t v106 = "reading block header failed";
            __int16 v107 = 645;
            goto LABEL_76;
          }
          uint64_t v44 = MemBufferGetDataSize(*(void *)(a1 + 56));
          if (!v44)
          {
            *(_DWORD *)(a1 + 208) = 1;
            return v7;
          }
        }
        unint64_t v45 = (unint64_t *)MemBufferGetDataPtr(*(void *)(a1 + 56));
        unint64_t v51 = *v45;
        unint64_t v50 = v45[1];
        unint64_t v52 = bswap64(*v45);
        unint64_t v53 = bswap64(v50);
        unint64_t v54 = *(void *)(a1 + 40);
        if (v52 > v54 || v53 > v54)
        {
          uint64_t v106 = "invalid block header";
          __int16 v107 = 655;
          goto LABEL_76;
        }
        MemBufferDecreaseSize(*(void *)(a1 + 56), 0x10uLL, v46, v47, v48, v49, v18, v19);
        BOOL v56 = v53 >= v44 - 16;
        unint64_t v57 = v53 - (v44 - 16);
        if (v57 != 0 && v56)
        {
          if (MemBufferFillFromIStream(*(unint64_t **)(a1 + 56), v57, *(uint64_t (**)(uint64_t, uint64_t, unint64_t))a1, *(void *)(a1 + 16)) != v57)
          {
            uint64_t v106 = "reading block payload failed";
            __int16 v107 = 665;
            goto LABEL_76;
          }
          MemBufferGetDataSize(*(void *)(a1 + 56));
        }
        if (v51 == v50)
        {
          FreePtr = (void *)MemBufferGetFreePtr(*(void *)(a1 + 64));
          long long v59 = (const void *)MemBufferGetDataPtr(*(void *)(a1 + 56));
          memcpy(FreePtr, v59, v52);
        }
        else
        {
          uint64_t v97 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t, unint64_t))(a1 + 48);
          uint64_t v98 = MemBufferGetFreePtr(*(void *)(a1 + 64));
          uint64_t v99 = MemBufferGetDataPtr(*(void *)(a1 + 56));
          if (v97(v98, v52, v99, v53) != v52)
          {
            uint64_t v106 = "decoding block payload failed";
            __int16 v107 = 677;
            goto LABEL_76;
          }
        }
        MemBufferDecreaseSize(*(void *)(a1 + 56), v53, v60, v61, v62, v63, v18, v19);
        MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v52, v100, v101, v102, v103, v104, v105);
        goto LABEL_62;
      }
      if (MemBufferFillFromIStream(v17, 0xFFFFFFFFFFFFFFFFLL, *(uint64_t (**)(uint64_t, uint64_t, unint64_t))a1, *(void *)(a1 + 16)) < 0)
      {
        uint64_t v106 = "reading payload failed";
        __int16 v107 = 687;
        goto LABEL_76;
      }
      uint64_t v20 = MemBufferGetDataPtr(*(void *)(a1 + 56));
      uint64_t v21 = MemBufferGetDataSize(*(void *)(a1 + 56));
      uint64_t v22 = MemBufferGetFreePtr(*(void *)(a1 + 64));
      uint64_t FreeSize = MemBufferGetFreeSize(*(void **)(a1 + 64));
      uint64_t v26 = FreeSize;
      int v27 = *(_DWORD *)(a1 + 32);
      switch(v27)
      {
        case 1:
          *(void *)(a1 + 72) = v20;
          *(void *)(a1 + 80) = v21;
          *(void *)(a1 + 96) = v22;
          *(void *)(a1 + 104) = FreeSize;
          unsigned int v64 = lzma_code();
          unsigned int v71 = v64;
          if (v64 > 0xA || ((1 << v64) & 0x403) == 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamRead", 738, 39, 0, "decoding lzma payload", v69, v70, v109);
            int v81 = 1;
            goto LABEL_60;
          }
          uint64_t v72 = *(void *)(a1 + 72);
          uint64_t v73 = *(void *)(a1 + 96);
          MemBufferDecreaseSize(*(void *)(a1 + 56), v72 - v20, v65, v66, v67, v68, v69, v70);
          if (v73 == v22 && v72 == v20) {
            ++v6;
          }
          else {
            int v6 = 0;
          }
          MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v73 - v22, v74, v75, v76, v77, v78, v79);
          if (v71 != 1)
          {
            int v81 = 14;
LABEL_60:
            if (v71 > 0xA || ((1 << v71) & 0x403) == 0) {
              continue;
            }
            goto LABEL_62;
          }
          break;
        case 3:
          *(void *)(a1 + 72) = v20;
          *(_DWORD *)(a1 + 80) = v21;
          *(void *)(a1 + 96) = v22;
          *(_DWORD *)(a1 + 104) = FreeSize;
          int v82 = BZ2_bzDecompress(stream);
          if (v82 < 0)
          {
            uint64_t v106 = "decoding bzip2 payload";
            __int16 v107 = 722;
            goto LABEL_76;
          }
          int v87 = v82;
          uint64_t v88 = *(void *)(a1 + 72);
          uint64_t v89 = *(void *)(a1 + 96);
          MemBufferDecreaseSize(*(void *)(a1 + 56), v88 - v20, v83, v84, v85, v86, v18, v19);
          if (v89 == v22 && v88 == v20) {
            ++v6;
          }
          else {
            int v6 = 0;
          }
          MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v89 - v22, v90, v91, v92, v93, v94, v95);
          if (v87 != 4) {
            goto LABEL_62;
          }
          break;
        case 2:
          *(void *)(a1 + 88) = v20;
          *(void *)(a1 + 96) = v21;
          *(void *)(a1 + 72) = v22;
          *(void *)(a1 + 80) = FreeSize;
          compression_status v28 = compression_stream_process((compression_stream *)stream, 0);
          if (v28 < 0)
          {
            uint64_t v106 = "decoding zlib payload";
            __int16 v107 = 706;
            goto LABEL_76;
          }
          compression_status v33 = v28;
          uint64_t v34 = *(void *)(a1 + 96);
          uint64_t v35 = *(void *)(a1 + 80);
          MemBufferDecreaseSize(*(void *)(a1 + 56), v21 - v34, v29, v30, v31, v32, v18, v19);
          if (v26 == v35 && v21 == v34) {
            ++v6;
          }
          else {
            int v6 = 0;
          }
          MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v26 - v35, v36, v37, v38, v39, v40, v41);
          if (v33 != COMPRESSION_STATUS_END) {
            goto LABEL_62;
          }
          break;
        default:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamRead", 748, 39, 0, "invalid decoder: %d", v24, v25, *(_DWORD *)(a1 + 32));
          return -1;
      }
      *(_DWORD *)(a1 + 208) = 1;
LABEL_62:
      if (v6 >= 3)
      {
        uint64_t v106 = "Truncated stream";
        __int16 v107 = 753;
LABEL_76:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamRead", v107, 39, 0, v106, v18, v19, v109);
        return -1;
      }
      int v81 = 0;
    }
    while (!v81);
  }
  return -1;
}

uint64_t ILowMemoryDecoderStreamAbort(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    int v2 = *(void (**)(void))(result + 8);
    if (v2) {
      v2(*(void *)(result + 16));
    }
    uint64_t v3 = *(void *)(v1 + 24);
    return IMemStreamAbort(v3);
  }
  return result;
}

size_t PCompressCopyEncode(void *a1, size_t a2, void *__src, size_t __n)
{
  if (a2 < __n) {
    return -1;
  }
  size_t v4 = __n;
  memcpy(a1, __src, __n);
  return v4;
}

size_t PCompressCopyDecode(void *a1, size_t a2, void *__src, size_t __n)
{
  if (a2 < __n) {
    return -1;
  }
  size_t v4 = __n;
  memcpy(a1, __src, __n);
  return v4;
}

void *ISparseArchiveStreamCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v54);
  int v57 = 0;
  size_t v9 = calloc(1uLL, 0x40uLL);
  if (!v9)
  {
    unint64_t v43 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ISparseArchiveStream.c", (uint64_t)"ISparseArchiveStreamCreate", 46, 8, *v43, "malloc", v44, v45, v55);
    uint64_t v12 = 0;
LABEL_37:
    uint64_t v16 = 0;
LABEL_59:
    int v51 = 0;
    goto LABEL_60;
  }
  uint64_t v12 = (char *)IFileStreamCreateWithFilename(*(const char **)(a1 + 32), 0, -1);
  if (!v12)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ISparseArchiveStream.c", (uint64_t)"ISparseArchiveStreamCreate", 50, 8, 0, "creating index file stream", v10, v11, v55);
    goto LABEL_37;
  }
  uint64_t v13 = ArchiveTreeCreateFromIndex((uint64_t)IFileStreamRead, (uint64_t)v12, *(int (**)(uint64_t, unsigned char *, void))(a1 + 40), *(void *)(a1 + 48), *(_DWORD *)(a1 + 4), *(_DWORD *)a1);
  uint64_t v16 = (uint64_t)v13;
  if (!v13)
  {
    uint64_t v41 = "loading archive tree";
    __int16 v42 = 53;
    goto LABEL_57;
  }
  unsigned int v17 = ArchiveTreeSize(v13);
  if (v17)
  {
    unsigned int v18 = v17;
    for (unsigned int i = 0; v18 != i; ++i)
    {
      *(void *)__s = -1;
      uint64_t v56 = -1;
      if (ArchiveTreeNodeSegment(v16, i, __s, &v56))
      {
        uint64_t v41 = "reading node segment";
        __int16 v42 = 61;
        goto LABEL_57;
      }
      unint64_t v20 = v9[1];
      uint64_t v21 = (char *)v9[3];
      if (v20) {
        BOOL v22 = v21 == 0;
      }
      else {
        BOOL v22 = 1;
      }
      if (v22) {
        goto LABEL_18;
      }
      uint64_t v23 = &v21[16 * v20];
      uint64_t v26 = *((void *)v23 - 1);
      uint64_t v24 = (uint64_t *)(v23 - 8);
      uint64_t v25 = v26;
      unint64_t v27 = v26 + *(v24 - 1);
      if (v27 > *(void *)__s)
      {
        uint64_t v41 = "invalid segment order";
        __int16 v42 = 67;
        goto LABEL_57;
      }
      if (v25 == -1)
      {
        uint64_t v41 = "invalid segments in archive";
        __int16 v42 = 68;
        goto LABEL_57;
      }
      if (v27 != *(void *)__s)
      {
LABEL_18:
        unint64_t v30 = v9[2];
        if (v20 >= v30)
        {
          uint64_t v31 = v30 + (v30 >> 1);
          if (!v30) {
            uint64_t v31 = 32;
          }
          v9[2] = v31;
          uint64_t v21 = (char *)reallocf(v21, 16 * v31);
          v9[3] = v21;
          if (!v21)
          {
            int v49 = *__error();
            uint64_t v41 = "malloc";
            __int16 v42 = 78;
            goto LABEL_58;
          }
          unint64_t v20 = v9[1];
        }
        uint64_t v32 = &v21[16 * v20];
        *(void *)uint64_t v32 = *(void *)__s;
        *((void *)v32 + 1) = v56;
        v9[1] = v20 + 1;
      }
      else
      {
        uint64_t v28 = v25 + v56;
        if (v56 == -1) {
          uint64_t v29 = -1;
        }
        else {
          uint64_t v29 = v28;
        }
        *uint64_t v24 = v29;
      }
    }
  }
  if (*(int *)a1 >= 1)
  {
    compression_status v33 = (FILE **)MEMORY[0x263EF8348];
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12zu segments to read in archive\n", v9[1]);
    if (*(int *)a1 >= 2)
    {
      if (v9[1])
      {
        uint64_t v34 = 0;
        unint64_t v35 = 0;
        do
        {
          uint64_t v36 = *v33;
          if (*(void *)(v9[3] + v34 + 8) == -1) {
            fprintf(v36, "segment=%zu offset=%llu size=<to EOF>\n");
          }
          else {
            fprintf(v36, "segment=%zu offset=%llu size=%llu\n");
          }
          ++v35;
          v34 += 16;
        }
        while (v35 < v9[1]);
      }
    }
  }
  if (loadFileSegment(*(const char **)(a1 + 8), &v57, 4uLL, 0))
  {
    uint64_t v41 = "reading archive header";
    __int16 v42 = 100;
    goto LABEL_57;
  }
  if ((unsigned __int16)v57 == 25200 && BYTE2(v57) == 122)
  {
    __int16 v70 = 0;
    long long v69 = 0u;
    long long v68 = 0u;
    long long v67 = 0u;
    long long v66 = 0u;
    long long v65 = 0u;
    long long v64 = 0u;
    long long v63 = 0u;
    long long v62 = 0u;
    long long v61 = 0u;
    long long v60 = 0u;
    long long v59 = 0u;
    *(_OWORD *)&__s[6] = 0u;
    strcpy(__s, "r,c=1");
    if (*(void *)(a1 + 16)) {
      uint64_t v48 = snprintf(&__s[5], 0xC3uLL, ",o=%llu", *(void *)(a1 + 16)) + 5;
    }
    else {
      uint64_t v48 = 5;
    }
    if (*(void *)(a1 + 24) != -1) {
      snprintf(&__s[v48], 200 - v48, ",s=%llu", *(void *)(a1 + 24));
    }
    unint64_t v50 = ParallelCompressionFileOpen(*(const char **)(a1 + 8), __s, v37, v38, v39, v40, v14, v15);
    v9[4] = v50;
    if (!v50)
    {
      uint64_t v41 = "creating archive decoder stream";
      __int16 v42 = 110;
LABEL_57:
      int v49 = 0;
LABEL_58:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ISparseArchiveStream.c", (uint64_t)"ISparseArchiveStreamCreate", v42, 8, v49, v41, v14, v15, v55);
      goto LABEL_59;
    }
  }
  else
  {
    uint64_t v47 = IFileStreamCreateWithFilename(*(const char **)(a1 + 8), *(void *)(a1 + 16), *(void *)(a1 + 24));
    v9[5] = v47;
    if (!v47)
    {
      uint64_t v41 = "creating archive file stream";
      __int16 v42 = 116;
      goto LABEL_57;
    }
  }
  int v51 = 1;
LABEL_60:
  IFileStreamDestroy(v12);
  ArchiveTreeDestroy(v16);
  int v52 = leaveThreadErrorContext(0, 0, 0);
  if (!v51 || v52 < 0)
  {
    ISparseArchiveStreamDestroy((uint64_t)v9);
    return 0;
  }
  return v9;
}

void ISparseArchiveStreamDestroy(uint64_t a1)
{
  if (a1)
  {
    free(*(void **)(a1 + 24));
    ParallelCompressionFileClose(*(void **)(a1 + 32), v2, v3, v4, v5, v6, v7, v8);
    IFileStreamDestroy(*(char **)(a1 + 40));
    free((void *)a1);
  }
}

uint64_t ISparseArchiveStreamRead(void *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    size_t v8 = a3;
    uint64_t v11 = 0;
    while (1)
    {
      unint64_t v12 = a1[6];
      if (v12 >= a1[1]) {
        return v11;
      }
      uint64_t v14 = a1[3];
      uint64_t v13 = a1[4];
      uint64_t v15 = v14 + 16 * v12;
      uint64_t v16 = 16 * v12;
      uint64_t v18 = *(void *)(v15 + 8);
      unsigned int v17 = (void *)(v15 + 8);
      uint64_t v19 = a1[7];
      size_t v20 = v18 - v19;
      if (v8 >= v18 - v19) {
        size_t v21 = v20;
      }
      else {
        size_t v21 = v8;
      }
      uint64_t v22 = *(void *)(v14 + v16);
      uint64_t v23 = v22 + v19;
      if (v13)
      {
        if (ParallelCompressionFileSeek(v13, v22 + v19, 0, a4, a5, a6, a7, a8) != v23)
        {
          compression_status v33 = "seek archive decoder";
          __int16 v34 = 163;
          goto LABEL_23;
        }
        unint64_t v27 = ParallelCompressionFileRead(a1[4], a2, v21, v24, v25, v26, a7, a8);
        if ((v27 & 0x8000000000000000) != 0) {
          goto LABEL_20;
        }
      }
      else
      {
        uint64_t v28 = a1[5];
        if (!v28) {
          goto LABEL_20;
        }
        if (IFileStreamSetPos(v28, v22 + v19, a3, a4, a5, a6, a7, a8) != v23)
        {
          compression_status v33 = "seek file decoder";
          __int16 v34 = 168;
          goto LABEL_23;
        }
        unint64_t v27 = IFileStreamRead(a1[5], a2, v21, v29, v30, v31, a7, a8);
        if ((v27 & 0x8000000000000000) != 0)
        {
LABEL_20:
          compression_status v33 = "archive read failed";
          __int16 v34 = 171;
LABEL_23:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ISparseArchiveStream.c", (uint64_t)"ISparseArchiveStreamRead", v34, 8, 0, v33, a7, a8, v36);
          return -1;
        }
      }
      if (v27)
      {
        unint64_t v32 = a1[7] + v27;
        a1[7] = v32;
        if (v32 == *v17)
        {
          ++a1[6];
          a1[7] = 0;
        }
        a2 += v27;
        v11 += v27;
        v8 -= v27;
        if (v8) {
          continue;
        }
      }
      return v11;
    }
  }
  return 0;
}

uint64_t initBestMatchThreadProc()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v72 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)v0;
  unsigned int v2 = *(_DWORD *)(v0 + 20);
  bzero(v71, 0x3000uLL);
  bzero(v70, 0x7000uLL);
  unsigned int v3 = *(_DWORD *)(v0 + 12);
  unsigned int v4 = *(_DWORD *)(v0 + 16);
  unsigned int v5 = *(_DWORD *)(v1 + 36);
  unsigned int v6 = v5 - v2;
  if (v5 < v2) {
    unsigned int v6 = 0;
  }
  if (v4 + v2 > v5) {
    unsigned int v4 = v6;
  }
  if (v3 < v4)
  {
    for (unsigned int i = *(_DWORD *)(v0 + 12); i < v4; ++i)
    {
      uint64_t v8 = *(void *)(v1 + 48);
      unsigned int v9 = *(_DWORD *)(v8 + 8 * i + 4);
      if (v9 < 0x400)
      {
        uint64_t v10 = i;
        uint64_t v11 = *(void *)(v1 + 24);
        unsigned int v12 = 0;
        if (v2)
        {
          uint64_t v13 = (int *)(v11 + i);
          unsigned int v14 = v2;
          do
          {
            int v15 = *v13++;
            unsigned int v12 = -1640531535 * (v15 + v12) - 1640531535;
            v14 -= 4;
          }
          while (v14);
        }
        uint64_t v16 = *(void *)(v0 + 32);
        int v17 = v12 ^ HIWORD(v12);
        unsigned int v18 = v12 >> *(_DWORD *)(v1 + 44);
        if (*(unsigned __int16 *)(v16 + 6 * v18 + 4) == (unsigned __int16)v17)
        {
          unsigned int v19 = *(_DWORD *)(v16 + 6 * v18);
          if (v19 >= *(_DWORD *)(v0 + 8))
          {
            int v20 = ((_WORD)i - (_WORD)v19) & 0x3FF;
            size_t v21 = &v71[3 * (((_WORD)i - (_WORD)v19) & 0x3FF)];
            if (v19 != v21[1] + i - *v21 || v71[3 * (((_WORD)i - (_WORD)v19) & 0x3FF) + 2] + *v21 < i)
            {
              int v22 = v19 & 0x3FF;
              uint64_t v23 = (unsigned int *)&v70[28 * (v19 & 0x3FF)];
              if (*v23 == v19)
              {
                uint64_t v24 = &v70[28 * (v19 & 0x3FF)];
                int v25 = *((_DWORD *)v24 + 2);
                int v26 = i - v25;
                if (v25 != *((_DWORD *)v24 + 5) + i - v25) {
                  goto LABEL_26;
                }
                unint64_t v27 = &v70[28 * (v19 & 0x3FF)];
                int v29 = v27[3];
                int v28 = v27[4];
                int v30 = v28 + v26;
                unsigned int v31 = v27[1];
                if (v28 + v26 <= v31) {
                  int v30 = v27[1];
                }
                uint64_t v32 = (v30 + v26);
                unsigned int v33 = v27[6] + v28;
                if (v33 >= v29 + v31) {
                  unsigned int v33 = v29 + v31;
                }
                BOOL v34 = v33 >= v32;
                int v35 = v33 - v32;
                if (v35 != 0 && v34)
                {
                  unsigned int v19 = v19 - i + v32;
                  uint64_t v10 = v32;
                }
                else
                {
LABEL_26:
                  int v35 = 0;
LABEL_27:
                  LODWORD(v32) = i;
                }
                unsigned int v37 = 0;
                if (v19 >= v32 - v3) {
                  unsigned int v38 = v32 - v3;
                }
                else {
                  unsigned int v38 = v19;
                }
                uint64_t v39 = *(void *)(v1 + 16);
                uint64_t v40 = v39 + v19;
                uint64_t v41 = v11 + v10;
                unsigned int v42 = -1;
                while (1)
                {
                  v37 += 8;
                  if (v37 > v38) {
                    break;
                  }
                  v42 += 8;
                  unint64_t v43 = *(void *)(v41 - v37) ^ *(void *)(v40 - v37);
                  if (v43)
                  {
                    unsigned int v42 = v37 + (__clz(v43) >> 3) - 8;
                    goto LABEL_39;
                  }
                }
                while (1)
                {
                  unsigned int v44 = v42 + 2;
                  if (v42 + 2 > v38) {
                    break;
                  }
                  ++v42;
                  if (*(unsigned __int8 *)(v40 - v44) != *(unsigned __int8 *)(v41 - v44)) {
                    goto LABEL_39;
                  }
                }
                unsigned int v42 = v38;
LABEL_39:
                uint64_t v45 = v19 - v42;
                uint64_t v46 = v32 - v42;
                unsigned int v47 = v42 + v35;
                unsigned int v48 = *(_DWORD *)(v1 + 32) - v45;
                LODWORD(v49) = *(_DWORD *)(v1 + 36) - v46;
                if (v48 >= v49) {
                  unint64_t v49 = v49;
                }
                else {
                  unint64_t v49 = v48;
                }
                uint64_t v50 = v39 + v45;
                uint64_t v51 = v11 + v46;
                while (1)
                {
                  unsigned int v52 = v47 + 8;
                  if (v47 + 8 > v49) {
                    break;
                  }
                  uint64_t v53 = *(void *)(v50 + v47);
                  uint64_t v54 = *(void *)(v51 + v47);
                  v47 += 8;
                  unint64_t v55 = v54 ^ v53;
                  if (v55)
                  {
                    LODWORD(v49) = v52 + (__clz(__rbit64(v55)) >> 3) - 8;
                    goto LABEL_52;
                  }
                }
                if (v47 < v49)
                {
                  uint64_t v56 = v47;
                  while (*(unsigned __int8 *)(v50 + v56) == *(unsigned __int8 *)(v51 + v56))
                  {
                    if (++v56 >= v49) {
                      goto LABEL_52;
                    }
                  }
                  LODWORD(v49) = v56;
                }
LABEL_52:
                if (v49 >= v2)
                {
                  *size_t v21 = v46;
                  v21[1] = v45;
                  v71[3 * v20 + 2] = v49;
                  int v57 = &v70[28 * v22];
                  int v58 = v57[1];
                  int v59 = v57[3];
                  v57[5] = v25;
                  v57[6] = v59;
                  v57[1] = v46;
                  v57[2] = i;
                  v57[3] = v49;
                  v57[4] = v58;
                  long long v60 = (_DWORD *)(v8 + 8 * v46);
                  if (v49 > v60[1])
                  {
                    *long long v60 = v45;
                    *(_DWORD *)(*(void *)(v1 + 48) + 8 * v46 + 4) = v49;
                    if ((int)v49 + (int)v46 > i + 1024) {
                      unsigned int i = v49 + v46 - 1024;
                    }
                  }
                }
                continue;
              }
              int v25 = 0;
              int v35 = 0;
              *uint64_t v23 = v19;
              char v36 = &v70[28 * (v19 & 0x3FF)];
              *((void *)v36 + 1) = 0;
              *((_DWORD *)v36 + 1) = 0;
              goto LABEL_27;
            }
          }
        }
      }
      else
      {
        unsigned int i = i + v9 - 1024;
      }
    }
  }
  if (*(_DWORD *)(v0 + 24))
  {
    unsigned int v61 = *(_DWORD *)(v0 + 16);
    unint64_t v62 = (*(_DWORD *)(v0 + 12) + 1);
    if (v62 < v61)
    {
      uint64_t v63 = 8 * (*(_DWORD *)(v0 + 12) + 1);
      do
      {
        uint64_t v64 = *(void *)(v1 + 48);
        uint64_t v65 = v64 + v63;
        unsigned int v66 = *(_DWORD *)(v64 + v63 - 4);
        if (v66 > v2 && v66 > *(_DWORD *)(v64 + v63 + 4))
        {
          unsigned int v68 = *(_DWORD *)(v65 - 8) + 1;
          if (v68 < *(_DWORD *)(v1 + 32))
          {
            *(_DWORD *)(v64 + v63) = v68;
            *(_DWORD *)(v65 + 4) = v66 - 1;
            unsigned int v61 = *(_DWORD *)(v0 + 16);
          }
        }
        ++v62;
        v63 += 8;
      }
      while (v62 < v61);
    }
  }
  return 0;
}

uint64_t BXDiffMatchesCreate(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v182 = *MEMORY[0x263EF8340];
  uint64_t v177 = 0;
  uint64_t v178 = 0;
  uint64_t v179 = 0;
  int v8 = *a5;
  if (!*a5) {
    int v8 = 6;
  }
  if (a4 >= 0x4B000) {
    int v9 = v8;
  }
  else {
    int v9 = 20;
  }
  if (a2 > 0xFFFFFFFE || (unint64_t v10 = a4, a4 >= 0xFFFFFFFF))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"BXDiffMatchesCreate", 994, 92, 0, "isize,osize too large", a7, a8, v167);
    return 0;
  }
  int v15 = calloc(1uLL, 0x40uLL);
  uint64_t v16 = (uint64_t)v15;
  if (!v15)
  {
    int v87 = *__error();
    uint64_t v88 = "malloc";
    __int16 v89 = 998;
    goto LABEL_108;
  }
  uint64_t v17 = *(void *)a5;
  void v15[2] = a5[2];
  *(void *)int v15 = v17;
  int DefaultNThreads = a5[2];
  if (!DefaultNThreads) {
    int DefaultNThreads = getDefaultNThreads();
  }
  *(_DWORD *)(v16 + 8) = DefaultNThreads;
  *(void *)(v16 + 16) = a1;
  *(void *)(v16 + 24) = a3;
  *(_DWORD *)(v16 + 32) = a2;
  *(_DWORD *)(v16 + 36) = v10;
  if ((getProfile(&v177, v9) & 0x80000000) != 0)
  {
    int v167 = *a5;
    uint64_t v88 = "loading profile: %d";
    __int16 v89 = 1008;
    goto LABEL_106;
  }
  if ((int)v177 >= 1)
  {
    getRealTime();
    size_t v21 = malloc(4 * a2 + 1028);
    int v22 = malloc(8 * a2);
    uint64_t v23 = v22;
    if (!v21 || !v22)
    {
      uint64_t v90 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"qsufsort32", 377, 92, *v90, "malloc", v91, v92, v167);
      free(v21);
      free(v23);
      *(void *)(v16 + 56) = 0;
      __int16 v89 = 1021;
      int v87 = 0;
      uint64_t v88 = "qsufsort32";
      goto LABEL_108;
    }
    uint64_t v24 = v21 + 257;
    v21[257] = a2;
    *int v22 = 0;
    if (a2)
    {
      unint64_t v170 = v21;
      unint64_t v172 = v10;
      uint64_t v174 = v16;
      unsigned int v25 = 0;
      int v175 = a2 ^ 0x80000000;
      int v26 = v22 + 1;
      do
      {
        if (*v23 == v175) {
          break;
        }
        unsigned int v27 = 0;
        unsigned int v28 = -1;
        do
        {
          int v29 = &v23[2 * v27];
          uint64_t v30 = *v29;
          if ((v30 & 0x80000000) != 0)
          {
            LODWORD(v31) = v30 ^ 0x80000000;
          }
          else
          {
            uint64_t v31 = v24[v30];
            if (v25)
            {
              if (v31 > v27)
              {
                uint64_t v32 = v31 - v27;
                unsigned int v33 = &v26[2 * v27];
                do
                {
                  _DWORD *v33 = v24[*(v33 - 1) + v25];
                  v33 += 2;
                  --v32;
                }
                while (v32);
              }
            }
            else if (v31 > v27)
            {
              int v34 = 0;
              uint64_t v35 = (v31 - 1);
              char v36 = &v26[2 * v35];
              unsigned int v37 = (unsigned __int8 *)(a1 + v35);
              int v38 = 1;
              unsigned int v39 = v31;
              do
              {
                unsigned int v40 = *v37--;
                int v41 = __PAIR64__(v40, v34) >> 8;
                unsigned int v42 = v39 + 2;
                unsigned int v43 = v39 - 1;
                int v44 = v41 | 0xFF;
                int v34 = v38 + (v41 & 0xFFFFFF00);
                if (v42 < v31) {
                  int v34 = v44;
                }
                *(v36 - 1) = v43;
                *char v36 = v34;
                v36 -= 2;
                ++v38;
                unsigned int v39 = v43;
              }
              while (v27 < v43);
            }
            quicksort64(v31 - v27, (unint64_t *)&v23[2 * v27], 24);
            unsigned int v45 = v27 + 1;
            if (v27 + 1 <= v31)
            {
              unsigned int v46 = v29[1];
              do
              {
                unsigned int v47 = v46;
                if (v45 >= v31) {
                  unsigned int v46 = 0;
                }
                else {
                  unsigned int v46 = v26[2 * v45];
                }
                if (v47 != v46)
                {
                  if (v45 - v27 < 2)
                  {
                    if (v28 >= a2) {
                      unsigned int v28 = v27;
                    }
                  }
                  else if (v28 < a2)
                  {
                    v23[2 * v28] = v27 ^ 0x80000000;
                    unsigned int v28 = -1;
                  }
                  if (v45 > v27)
                  {
                    unint64_t v48 = v45 - (unint64_t)v27;
                    unint64_t v49 = &v23[2 * v27];
                    do
                    {
                      int v50 = *v49;
                      v49 += 2;
                      v24[v50] = v45;
                      --v48;
                    }
                    while (v48);
                    unsigned int v27 = v45;
                  }
                }
                ++v45;
              }
              while (v45 <= v31);
            }
          }
          unsigned int v27 = v31;
        }
        while (v31 < a2);
        if (v28 < a2) {
          v23[2 * v28] = v175;
        }
        if (v25 >= 3) {
          v25 *= 2;
        }
        else {
          unsigned int v25 = 3;
        }
      }
      while (v25 < a2);
      uint64_t v51 = 0;
      unint64_t v10 = v172;
      uint64_t v16 = v174;
      size_t v21 = v170;
      do
      {
        *(void *)&v23[2 * (v24[v51] - 1)] = v51;
        ++v51;
      }
      while (a2 != v51);
    }
    if (a2)
    {
      unsigned int v52 = (uint64_t *)v23;
      uint64_t v53 = v24;
      unint64_t v54 = a2;
      do
      {
        uint64_t v55 = *v52++;
        *v53++ = v55;
        --v54;
      }
      while (v54);
    }
    int v56 = 0;
    *size_t v21 = 0;
    v21[256] = a2;
    for (unint64_t i = 1; i != 256; ++i)
    {
      unsigned int v58 = a2;
      if (v56 != a2)
      {
        if (v56 + 1 >= a2)
        {
          unsigned int v58 = a2;
        }
        else
        {
          unsigned int v58 = a2;
          do
          {
            if (i <= *(unsigned __int8 *)(a1 + v24[v56 + ((v58 - v56) >> 1)])) {
              unsigned int v58 = v56 + ((v58 - v56) >> 1);
            }
            else {
              v56 += (v58 - v56) >> 1;
            }
          }
          while (v58 > v56 + 1);
        }
        uint64_t v59 = v24[v56];
        if (v59 != a2 && i == *(unsigned __int8 *)(a1 + v59)) {
          unsigned int v58 = v56;
        }
      }
      v21[i] = v58;
      int v56 = v58;
    }
    free(v23);
    *(void *)(v16 + 56) = v21;
    getRealTime();
  }
  if (SHIDWORD(v177) >= 1)
  {
    long long v60 = malloc(8 * v10);
    *(void *)(v16 + 48) = v60;
    if (!v60)
    {
      int v87 = *__error();
      uint64_t v88 = "malloc";
      __int16 v89 = 1033;
      goto LABEL_108;
    }
    if (*(_DWORD *)(v16 + 36))
    {
      uint64_t v61 = 0;
      unint64_t v62 = 0;
      do
      {
        *(void *)(*(void *)(v16 + 48) + v61) = 0xFFFFFFFFLL;
        ++v62;
        v61 += 8;
      }
      while (v62 < *(unsigned int *)(v16 + 36));
    }
  }
  uint64_t v63 = *(void *)(v16 + 48);
  if (*(void *)(v16 + 56))
  {
    if (v63)
    {
      int v65 = HIDWORD(v178);
      unsigned int v64 = v179;
      getRealTime();
      unsigned int v66 = *(_DWORD *)(v16 + 36);
      if (v66)
      {
        unsigned int v67 = 0;
        unsigned int v68 = 1;
        do
        {
          unsigned int v69 = v67;
          __int16 v70 = (_DWORD *)(*(void *)(v16 + 48) + 8 * v67);
          if (v70[1] < v64)
          {
            uint64_t v71 = *(void *)(v16 + 56);
            uint64_t v72 = (unsigned int *)(v71 + 4 * *(unsigned __int8 *)(*(void *)(v16 + 24) + v67));
            unsigned int v73 = *v72;
            unsigned int v74 = v72[1] + 1;
            LODWORD(v180) = -1;
            unsigned int v75 = bestMatchInRange(v16, v71 + 1028, v67, v73, v74, &v180);
            int v76 = (int)v180;
            *__int16 v70 = v180;
            *(_DWORD *)(*(void *)(v16 + 48) + 8 * v67 + 4) = v75;
            if (v75 >= v64)
            {
              if ((v76 + 1) < *(_DWORD *)(v16 + 32))
              {
                uint64_t v77 = 8 * v68;
                unsigned int v78 = v75 - 1;
                int v79 = 1;
                do
                {
                  BOOL v80 = v67 + v79 < *(_DWORD *)(v16 + 36) && v78 >= v64;
                  if (!v80) {
                    break;
                  }
                  *(_DWORD *)(*(void *)(v16 + 48) + v77) = v76 + v79;
                  *(_DWORD *)(*(void *)(v16 + 48) + v77 + 4) = v78;
                  v77 += 8;
                  ++v79;
                  --v78;
                }
                while ((v76 + v79) < *(_DWORD *)(v16 + 32));
              }
              if (v67 && v76)
              {
                uint64_t v81 = 0;
                uint64_t v82 = v67 - 1;
                uint64_t v83 = 8 * v67;
                unsigned int v84 = v75 + 1;
                do
                {
                  uint64_t v85 = *(void *)(v16 + 48) + v83;
                  if (*(_DWORD *)(v85 - 8) != -1) {
                    break;
                  }
                  if (*(unsigned __int8 *)(*(void *)(v16 + 16) + (v76 + v81 - 1)) != *(unsigned __int8 *)(*(void *)(v16 + 24) + v82 + v81)) {
                    break;
                  }
                  *(_DWORD *)(v85 - 8) = v76 - 1 + v81;
                  *(_DWORD *)(*(void *)(v16 + 48) + v83 - 4) = v84;
                  if (!(v82 + v81)) {
                    break;
                  }
                  int v86 = v76 + v81--;
                  v83 -= 8;
                  ++v84;
                }
                while (v86 != 1);
              }
            }
            unsigned int v66 = *(_DWORD *)(v16 + 36);
          }
          v67 += v65;
          v68 += v65;
        }
        while (v69 + v65 < v66);
      }
LABEL_185:
      getRealTime();
    }
    goto LABEL_186;
  }
  if (!v63)
  {
LABEL_186:
    if ((int)v177 >= 2)
    {
      free(*(void **)(v16 + 56));
      *(void *)(v16 + 56) = 0;
    }
    return v16;
  }
  int v94 = -13;
  do
  {
    int v95 = v94 + 33;
    unsigned int v96 = 1 << (v94++ + 33 + v178);
  }
  while (v95 < SHIDWORD(v179) && v96 < *(_DWORD *)(v16 + 32));
  *(_DWORD *)(v16 + 40) = v94 + 32;
  *(_DWORD *)(v16 + 44) = -v94;
  unsigned int v97 = v179;
  getRealTime();
  size_t v98 = *(unsigned int *)(v16 + 8);
  unint64_t v180 = 0;
  uint64_t v181 = 0;
  int v99 = 1;
  unsigned int v101 = *(_DWORD *)(v16 + 32);
  unsigned int v100 = *(_DWORD *)(v16 + 36);
  if (v101 >= v100) {
    unsigned int v101 = *(_DWORD *)(v16 + 36);
  }
  if (v101 < 2 * v97)
  {
    uint64_t v102 = 0;
    uint64_t v103 = 0;
    goto LABEL_184;
  }
  uint64_t v104 = 0;
  size_t v105 = 6 * (1 << *(_DWORD *)(v16 + 40));
  unsigned int v176 = ((v98 + v100 - 1) / v98 + 0xFFFF) & 0xFFFF0000;
  char v106 = 1;
  do
  {
    __int16 v107 = calloc(1uLL, v105);
    *(&v180 + v104) = v107;
    if (!v107)
    {
      uint64_t v123 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"initBestMatchFromHashes", 852, 92, *v123, "malloc", v124, v125, v167);
      uint64_t v102 = 0;
      uint64_t v103 = 0;
LABEL_183:
      int v99 = 0;
      goto LABEL_184;
    }
    char v108 = (v98 != 1) & v106;
    uint64_t v104 = 1;
    char v106 = 0;
  }
  while ((v108 & 1) != 0);
  uint64_t v102 = calloc(v98, 0x28uLL);
  char v109 = (uint64_t *)malloc(8 * v98);
  uint64_t v103 = v109;
  if (!v102 || !v109)
  {
    int v126 = *__error();
    unint64_t v121 = "malloc";
    __int16 v122 = 862;
LABEL_182:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"initBestMatchFromHashes", v122, 92, v126, v121, v115, v116, v167);
    goto LABEL_183;
  }
  if (!v98) {
    goto LABEL_129;
  }
  uint64_t v117 = v109;
  BOOL v118 = v102;
  size_t v119 = v98;
  do
  {
    *v117++ = (uint64_t)v118;
    v118[5] = v97;
    *(void *)BOOL v118 = v16;
    v118 += 10;
    --v119;
  }
  while (v119);
  if (v98 == 1)
  {
    __int16 v120 = 0;
  }
  else
  {
LABEL_129:
    __int16 v120 = ThreadPoolCreate(v98, (uint64_t)v109, (uint64_t)initBestMatchThreadProc);
    if (!v120)
    {
      unint64_t v121 = "ThreadPoolCreate";
      __int16 v122 = 874;
      goto LABEL_181;
    }
  }
  unsigned int v127 = *(_DWORD *)(v16 + 32);
  if (v127)
  {
    BOOL v171 = v103;
    uint64_t v168 = v102;
    unsigned int v128 = 0;
    unsigned int v129 = 0;
    while (1)
    {
      unsigned int v169 = v128;
      uint64_t v130 = *(&v180 + v128);
      BOOL v80 = v127 >= v97;
      unsigned int v131 = v127 - v97;
      if (!v80) {
        unsigned int v131 = 0;
      }
      unsigned int v173 = v129 + v96;
      if (v129 + v96 < v131) {
        unsigned int v131 = v129 + v96;
      }
      unsigned int v132 = v129 + 4;
      if (v129 + 4 < v131)
      {
        uint64_t v133 = *(void *)(v16 + 16);
        unsigned int v134 = v129;
        do
        {
          unsigned int v135 = v132;
          if (v97)
          {
            unsigned int v136 = 0;
            uint64_t v137 = (int *)(v133 + v134);
            uint64_t v138 = v137;
            unsigned int v139 = v97;
            do
            {
              int v140 = *v138++;
              unsigned int v136 = -1640531535 * (v140 + v136) - 1640531535;
              v139 -= 4;
            }
            while (v139);
            unsigned int v141 = 0;
            int v142 = *(_DWORD *)(v16 + 44);
            unsigned int v143 = v136 >> v142;
            uint64_t v144 = (int *)((char *)v137 + 1);
            unsigned int v145 = v97;
            do
            {
              int v146 = *v144++;
              unsigned int v141 = -1640531535 * (v146 + v141) - 1640531535;
              v145 -= 4;
            }
            while (v145);
            unsigned int v147 = 0;
            unsigned int v148 = v141 >> v142;
            uint64_t v149 = (int *)((char *)v137 + 2);
            unsigned int v150 = v97;
            do
            {
              int v151 = *v149++;
              unsigned int v147 = -1640531535 * (v151 + v147) - 1640531535;
              v150 -= 4;
            }
            while (v150);
            LODWORD(v110) = 0;
            __int16 v152 = HIWORD(v136) ^ v136;
            unsigned int v153 = v147 >> v142;
            uint64_t v154 = (unsigned int *)((char *)v137 + 3);
            unsigned int v155 = v97;
            do
            {
              unsigned int v156 = *v154++;
              uint64_t v115 = v156;
              uint64_t v110 = -1640531535 * (v156 + v110) - 1640531535;
              v155 -= 4;
            }
            while (v155);
            __int16 v157 = HIWORD(v141) ^ v141;
            __int16 v158 = HIWORD(v147) ^ v147;
            uint64_t v112 = (_DWORD *)((char *)v130 + 6 * v143);
            uint64_t v113 = (_DWORD *)((char *)v130 + 6 * v148);
            uint64_t v111 = (_DWORD *)((char *)v130 + 6 * v153);
          }
          else
          {
            unsigned int v153 = 0;
            __int16 v158 = 0;
            unsigned int v143 = 0;
            __int16 v152 = 0;
            __int16 v157 = 0;
            unsigned int v148 = 0;
            uint64_t v110 = 0;
            int v142 = *(_DWORD *)(v16 + 44);
            uint64_t v111 = v130;
            uint64_t v112 = v130;
            uint64_t v113 = v130;
          }
          uint64_t v114 = v110 ^ WORD1(v110);
          unint64_t v159 = (char *)v130 + 6 * (v110 >> v142);
          unsigned int *v112 = v134;
          *((_WORD *)v130 + 3 * v143 + 2) = v152;
          *uint64_t v113 = v134 + 1;
          *((_WORD *)v130 + 3 * v148 + 2) = v157;
          _DWORD *v111 = v134 + 2;
          *((_WORD *)v130 + 3 * v153 + 2) = v158;
          *(_DWORD *)unint64_t v159 = v134 + 3;
          *((_WORD *)v159 + 2) = v110 ^ WORD1(v110);
          unsigned int v132 = v135 + 4;
          unsigned int v134 = v135;
        }
        while (v135 + 4 < v131);
      }
      if (v120 && (ThreadPoolSync(v120) & 0x80000000) != 0) {
        break;
      }
      if (v98)
      {
        int v160 = 0;
        int v161 = v98;
        while (1)
        {
          uint64_t v162 = v120
               ? ThreadPoolGetWorker((uint64_t)v120, v110, (uint64_t)v111, (uint64_t)v112, (uint64_t)v113, v114, v115, v116)
               : *v171;
          if (!v162) {
            break;
          }
          *(void *)(v162 + 32) = v130;
          *(_DWORD *)(v162 + 24) = v173 >= *(_DWORD *)(v16 + 32);
          *(_DWORD *)(v162 + 8) = v129;
          *(_DWORD *)(v162 + 12) = v160 * v176;
          unsigned int v163 = v160 * v176 + v176;
          *(_DWORD *)(v162 + 16) = v163;
          unsigned int v164 = *(_DWORD *)(v16 + 36);
          if (v160 * v176 > v164) {
            *(_DWORD *)(v162 + 12) = v164;
          }
          if (v163 > v164) {
            *(_DWORD *)(v162 + 16) = v164;
          }
          if (v120)
          {
            if ((ThreadPoolRunWorker((uint64_t)v120, v162, (uint64_t)v111, (uint64_t)v112, (uint64_t)v113, v114, v115, v116) & 0x80000000) != 0)
            {
              uint64_t v165 = "ThreadPoolRunWorker";
              __int16 v166 = 920;
              goto LABEL_178;
            }
          }
          else
          {
            initBestMatchThreadProc();
          }
          ++v160;
          if (!--v161) {
            goto LABEL_171;
          }
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"initBestMatchFromHashes", 910, 92, 0, "ThreadPoolGetWorker", v115, v116, v167);
        int v99 = 0;
        goto LABEL_175;
      }
LABEL_171:
      unsigned int v128 = v169 ^ (v120 != 0);
      unsigned int v127 = *(_DWORD *)(v16 + 32);
      v129 += v96;
      if (v173 >= v127)
      {
        int v99 = 1;
LABEL_175:
        uint64_t v102 = v168;
        uint64_t v103 = v171;
        goto LABEL_176;
      }
    }
    uint64_t v165 = "ThreadPoolSync";
    __int16 v166 = 906;
LABEL_178:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"initBestMatchFromHashes", v166, 92, 0, v165, v115, v116, v167);
    int v99 = 0;
    uint64_t v102 = v168;
    uint64_t v103 = v171;
    goto LABEL_179;
  }
  int v99 = 1;
LABEL_176:
  if (v120)
  {
LABEL_179:
    if ((ThreadPoolDestroy((uint64_t)v120) & 0x80000000) == 0) {
      goto LABEL_184;
    }
    unint64_t v121 = "ThreadPoolDestroy";
    __int16 v122 = 930;
LABEL_181:
    int v126 = 0;
    goto LABEL_182;
  }
LABEL_184:
  free(v102);
  free(v103);
  free(v180);
  free(v181);
  if (v99) {
    goto LABEL_185;
  }
  uint64_t v88 = "initBestMatchFromHashes";
  __int16 v89 = 1069;
LABEL_106:
  int v87 = 0;
LABEL_108:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"BXDiffMatchesCreate", v89, 92, v87, v88, v19, v20, v167);
  BXDiffMatchesDestroy((void **)v16);
  return 0;
}

size_t getProfile(_DWORD *a1, int a2)
{
  *(void *)a1 = 0;
  *((void *)a1 + 1) = 0;
  *((void *)a1 + 2) = 0;
  if (a2) {
    int v3 = a2;
  }
  else {
    int v3 = 6;
  }
  switch(v3)
  {
    case 2:
      long long v4 = xmmword_2106D4460;
      goto LABEL_10;
    case 3:
      long long v4 = xmmword_2106D4450;
      goto LABEL_10;
    case 4:
      long long v4 = xmmword_2106D4440;
      goto LABEL_10;
    case 5:
      long long v4 = xmmword_2106D4430;
      goto LABEL_10;
    case 6:
      *(_OWORD *)a1 = xmmword_2106D4430;
      uint64_t v5 = 0x1A00000010;
      goto LABEL_30;
    case 7:
      long long v6 = xmmword_2106D4430;
      goto LABEL_15;
    case 8:
      *(_OWORD *)a1 = xmmword_2106D4420;
      uint64_t v5 = 0x1A0000000CLL;
      goto LABEL_30;
    case 9:
      long long v6 = xmmword_2106D4420;
LABEL_15:
      *(_OWORD *)a1 = v6;
      uint64_t v5 = 0x1A00000008;
      goto LABEL_30;
    case 10:
      long long v7 = xmmword_2106D4410;
      goto LABEL_24;
    case 11:
      long long v7 = xmmword_2106D4400;
      goto LABEL_24;
    case 12:
      long long v7 = xmmword_2106D43F0;
      goto LABEL_24;
    case 13:
      long long v8 = xmmword_2106D43E0;
      goto LABEL_26;
    case 14:
      long long v8 = xmmword_2106D43D0;
      goto LABEL_26;
    case 15:
      long long v7 = xmmword_2106D43C0;
      goto LABEL_24;
    case 16:
      long long v7 = xmmword_2106D43B0;
      goto LABEL_24;
    case 17:
      long long v7 = xmmword_2106D43A0;
LABEL_24:
      *(_OWORD *)a1 = v7;
      uint64_t v5 = 24;
      goto LABEL_30;
    case 18:
      long long v8 = xmmword_2106D43A0;
LABEL_26:
      *(_OWORD *)a1 = v8;
      uint64_t v5 = 16;
      goto LABEL_30;
    case 19:
      *(_OWORD *)a1 = xmmword_2106D43A0;
      uint64_t v5 = 8;
      goto LABEL_30;
    case 20:
      *a1 = 1;
      *(void *)(a1 + 3) = 0;
      *(void *)(a1 + 1) = 0;
      a1[5] = 0;
      goto LABEL_31;
    case 21:
      *(_OWORD *)a1 = xmmword_2106D4430;
      uint64_t v5 = 0x1800000010;
      goto LABEL_30;
    default:
      long long v4 = xmmword_2106D4470;
LABEL_10:
      *(_OWORD *)a1 = v4;
      uint64_t v5 = 0x1A00000018;
LABEL_30:
      *((void *)a1 + 2) = v5;
LABEL_31:
      size_t result = (size_t)getenv("BXDIFF_MATCHES_PROFILE");
      if (!result) {
        return result;
      }
      size_t v10 = result;
      size_t result = strlen((const char *)result);
      if (!result) {
        return result;
      }
      size_t v11 = result;
      uint64_t v12 = 0;
      uint64_t v13 = MEMORY[0x263EF8318];
      break;
  }
  while (1)
  {
    unsigned int v14 = __tolower(*(char *)(v10 + v12));
    unsigned int v17 = v14;
    if (v14 > 0x7F)
    {
      if (__maskrune(v14, 0x4000uLL)) {
        goto LABEL_52;
      }
    }
    else if ((*(_DWORD *)(v13 + 4 * v14 + 60) & 0x4000) != 0)
    {
      goto LABEL_52;
    }
    char v18 = v17 - 58;
    if (v17 - 58 > 0x39) {
      goto LABEL_44;
    }
    if (((1 << v18) & 0x224820000000000) != 0) {
      break;
    }
    if (((1 << v18) & 3) != 0) {
      goto LABEL_52;
    }
LABEL_44:
    if (v17 != 44)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"parseProfile", 505, 92, 0, "Invalid profile code: %c", v15, v16, v17);
      goto LABEL_56;
    }
LABEL_52:
    if (v11 == ++v12) {
      return 0;
    }
  }
  __endptr = 0;
  int v19 = strtol((const char *)(v10 + v12 + 1), &__endptr, 10);
  if (!*__error())
  {
    switch(v17)
    {
      case 'c':
        int v22 = a1 + 1;
        goto LABEL_51;
      case 'd':
        int v22 = a1 + 3;
        goto LABEL_51;
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
        goto LABEL_55;
      case 'i':
        int v22 = a1 + 2;
        goto LABEL_51;
      case 'l':
        int v22 = a1 + 4;
        goto LABEL_51;
      default:
        int v22 = a1;
        if (v17 != 115)
        {
LABEL_55:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"parseProfile", 515, 92, 0, "Invalid profile code: %c", v20, v21, v17);
          goto LABEL_56;
        }
LABEL_51:
        *int v22 = v19;
        break;
    }
    goto LABEL_52;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"parseProfile", 508, 92, 0, "Invalid profile value: %s", v20, v21, v10 + v12 + 1);
LABEL_56:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"getProfile", 560, 92, 0, "parsing profile: %s", v23, v24, v10);
  return 0xFFFFFFFFLL;
}

void BXDiffMatchesDestroy(void **a1)
{
  if (a1)
  {
    free(a1[7]);
    free(a1[6]);
    free(a1);
  }
}

uint64_t BXDiffMatchesGetBestMatch(uint64_t a1, unsigned int a2, void *a3)
{
  unsigned int v10 = 0;
  if (*(_DWORD *)(a1 + 36) <= a2)
  {
    uint64_t v7 = 0;
    goto LABEL_6;
  }
  uint64_t v5 = *(void *)(a1 + 48);
  if (v5)
  {
    long long v6 = (unsigned int *)(v5 + 8 * a2);
    uint64_t v7 = *v6;
    unsigned int v10 = v7;
    if (v7 != -1)
    {
      LODWORD(result) = v6[1];
      goto LABEL_7;
    }
  }
  uint64_t v7 = *(void *)(a1 + 56);
  if (!v7)
  {
LABEL_6:
    LODWORD(result) = 0;
    goto LABEL_7;
  }
  int v9 = (unsigned int *)(v7 + 4 * *(unsigned __int8 *)(*(void *)(a1 + 24) + a2));
  uint64_t result = bestMatchInRange(a1, v7 + 1028, a2, *v9, v9[1], &v10);
  uint64_t v7 = v10;
  if (v5) {
    *(void *)(v5 + 8 * a2) = v10 | (unint64_t)(result << 32);
  }
LABEL_7:
  *a3 = v7;
  return result;
}

uint64_t bestMatchInRange(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, _DWORD *a6)
{
  if (a5 <= a4)
  {
    int v19 = 0;
    uint64_t result = 0;
  }
  else
  {
    unsigned int v6 = 0;
    uint64_t v7 = *(unsigned int *)(a2 + 4 * a4);
    uint64_t v8 = a4;
    int v9 = *(_DWORD *)(a1 + 32);
    unsigned int v10 = *(_DWORD *)(a1 + 36) - a3;
    if (v10 >= v9 - (int)v7) {
      uint64_t v11 = (v9 - v7);
    }
    else {
      uint64_t v11 = v10;
    }
    uint64_t v12 = *(void *)(a1 + 16);
    uint64_t v13 = *(void *)(a1 + 24);
    uint64_t v14 = v13 + a3;
    while (1)
    {
      unsigned int v15 = v6 + 8;
      if (v6 + 8 > v11) {
        break;
      }
      uint64_t v16 = *(void *)(v12 + v7 + v6);
      uint64_t v17 = *(void *)(v14 + v6);
      v6 += 8;
      unint64_t v18 = v17 ^ v16;
      if (v18)
      {
        LODWORD(v11) = v15 + (__clz(__rbit64(v18)) >> 3) - 8;
        goto LABEL_16;
      }
    }
    if (v6 < v11)
    {
      uint64_t v21 = v11 - v6;
      int v22 = (unsigned __int8 *)(v13 + a3 + v6);
      uint64_t v23 = (unsigned __int8 *)(v12 + v7 + v6);
      while (1)
      {
        int v25 = *v23++;
        int v24 = v25;
        int v26 = *v22++;
        if (v24 != v26) {
          break;
        }
        ++v6;
        if (!--v21) {
          goto LABEL_16;
        }
      }
      LODWORD(v11) = v6;
    }
LABEL_16:
    unsigned int v27 = 0;
    uint64_t v28 = a5 - 1;
    uint64_t v29 = *(unsigned int *)(a2 + 4 * v28);
    LODWORD(v30) = v9 - v29;
    if (v10 >= v9 - (int)v29) {
      uint64_t v30 = v30;
    }
    else {
      uint64_t v30 = v10;
    }
    while (1)
    {
      unsigned int v31 = v27 + 8;
      if (v27 + 8 > v30) {
        break;
      }
      uint64_t v32 = *(void *)(v12 + v29 + v27);
      uint64_t v33 = *(void *)(v14 + v27);
      v27 += 8;
      unint64_t v34 = v33 ^ v32;
      if (v34)
      {
        LODWORD(v30) = v31 + (__clz(__rbit64(v34)) >> 3) - 8;
        goto LABEL_28;
      }
    }
    if (v27 < v30)
    {
      uint64_t v35 = v30 - v27;
      char v36 = (unsigned __int8 *)(v13 + a3 + v27);
      unsigned int v37 = (unsigned __int8 *)(v12 + v29 + v27);
      while (1)
      {
        int v39 = *v37++;
        int v38 = v39;
        int v40 = *v36++;
        if (v38 != v40) {
          break;
        }
        ++v27;
        if (!--v35) {
          goto LABEL_28;
        }
      }
      LODWORD(v30) = v27;
    }
LABEL_28:
    unint64_t v41 = v28 - v8;
    if ((unint64_t)(v28 - v8) < 2)
    {
      uint64_t v42 = v8;
    }
    else
    {
      do
      {
        uint64_t v42 = v8 + (v41 >> 1);
        uint64_t v43 = *(unsigned int *)(a2 + 4 * v42);
        LODWORD(v44) = v9 - v43;
        if (v10 >= v9 - (int)v43) {
          unint64_t v44 = v44;
        }
        else {
          unint64_t v44 = v10;
        }
        if (v11 >= v30) {
          LODWORD(v45) = v30;
        }
        else {
          LODWORD(v45) = v11;
        }
        uint64_t v46 = v12 + v43;
        while (1)
        {
          int v47 = v45 + 8;
          if ((int)v45 + 8 > v44) {
            break;
          }
          uint64_t v48 = *(void *)(v46 + v45);
          uint64_t v49 = *(void *)(v14 + v45);
          LODWORD(v45) = v45 + 8;
          unint64_t v50 = v49 ^ v48;
          if (v50)
          {
            LODWORD(v45) = v47 + (__clz(__rbit64(v50)) >> 3) - 8;
            goto LABEL_39;
          }
        }
        if (v45 >= v44)
        {
LABEL_46:
          LODWORD(v45) = v44;
          goto LABEL_47;
        }
        uint64_t v45 = v45;
        while (*(unsigned __int8 *)(v46 + v45) == *(unsigned __int8 *)(v14 + v45))
        {
          if (++v45 >= v44) {
            goto LABEL_46;
          }
        }
LABEL_39:
        if (v45 < v44
          && *(unsigned __int8 *)(v13 + v45 + a3) < *(unsigned __int8 *)(v12 + (v45 + v43)))
        {
          uint64_t v28 = v42;
          uint64_t v42 = v8;
          LODWORD(v30) = v45;
          goto LABEL_48;
        }
LABEL_47:
        LODWORD(v11) = v45;
        uint64_t v8 = v42;
LABEL_48:
        unint64_t v41 = v28 - v42;
      }
      while ((unint64_t)(v28 - v42) > 1);
    }
    if (v11 <= v30) {
      uint64_t v51 = v28;
    }
    else {
      uint64_t v51 = v42;
    }
    if (v11 <= v30) {
      uint64_t result = v30;
    }
    else {
      uint64_t result = v11;
    }
    int v19 = *(_DWORD *)(a2 + 4 * v51);
  }
  *a6 = v19;
  return result;
}

uint64_t BXDiffMatchesIBuf(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t BXDiffMatchesISize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t BXDiffMatchesOSize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t GetBXDiffMaxMemoryUsage(unint64_t a1, unint64_t a2, int a3, int a4)
{
  int DefaultNThreads = a3;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  if (!a3) {
    int DefaultNThreads = getDefaultNThreads();
  }
  if (a4) {
    int v8 = a4;
  }
  else {
    int v8 = 6;
  }
  if (a2 >= 0x4B000) {
    int v9 = v8;
  }
  else {
    int v9 = 20;
  }
  if ((getProfile(&v19, v9) & 0x80000000) != 0)
  {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"GetBXDiffMaxMemoryUsage", 1190, 92, "loading profile: %d", v10, v11, v12, v9);
    return 0;
  }
  else
  {
    uint64_t v13 = 8 * a2;
    if (SHIDWORD(v19) <= 0) {
      uint64_t v13 = 0;
    }
    if ((int)v19 < 1)
    {
      int v16 = 19;
      do
      {
        char v17 = v16 + 1;
        if (v16 + 1 >= SHIDWORD(v21)) {
          break;
        }
        unint64_t v18 = (1 << (v20 + v16++ + 1));
      }
      while (v18 < a1);
      uint64_t v14 = 6 << v17 << (DefaultNThreads != 1);
    }
    else
    {
      uint64_t v14 = 4 * a1;
    }
    return v14 + v13;
  }
}

unint64_t quicksort64(unint64_t result, unint64_t *a2, int a3)
{
  BOOL v3 = result > 2;
  if (result >= 2)
  {
    unint64_t v6 = result;
    while (1)
    {
      if (!v3)
      {
        switch(v6)
        {
          case 2uLL:
            unint64_t v33 = *a2;
            unint64_t v34 = a2[1];
            if (HIDWORD(*a2) > HIDWORD(v34))
            {
              *a2 = v34;
              a2[1] = v33;
            }
            break;
          case 3uLL:
            unint64_t v55 = *a2;
            unint64_t v56 = a2[2];
            unint64_t v57 = HIDWORD(*a2);
            if (v57 <= HIDWORD(v56))
            {
              unint64_t v58 = a2[2];
              unint64_t v56 = *a2;
            }
            else
            {
              unint64_t v57 = HIDWORD(v56);
              *a2 = v56;
              a2[2] = v55;
              unint64_t v58 = v55;
            }
            unint64_t v67 = a2[1];
            if (v57 <= HIDWORD(v67))
            {
              unint64_t v57 = HIDWORD(v67);
            }
            else
            {
              *a2 = v67;
              a2[1] = v56;
              unint64_t v67 = v56;
            }
            if (v57 > HIDWORD(v58))
            {
              a2[1] = v58;
              a2[2] = v67;
            }
            break;
          case 4uLL:
            unint64_t v36 = *a2;
            unint64_t v35 = a2[1];
            if (HIDWORD(*a2) <= HIDWORD(v35))
            {
              unint64_t v37 = a2[1];
              unint64_t v35 = *a2;
            }
            else
            {
              *a2 = v35;
              a2[1] = v36;
              unint64_t v37 = v36;
            }
            unint64_t v60 = a2[2];
            unint64_t v59 = a2[3];
            unint64_t v61 = HIDWORD(v60);
            if (HIDWORD(v60) <= HIDWORD(v59))
            {
              unint64_t v62 = a2[3];
              unint64_t v59 = a2[2];
            }
            else
            {
              unint64_t v61 = HIDWORD(v59);
              a2[2] = v59;
              a2[3] = v60;
              unint64_t v62 = v60;
            }
            if (v61 >= HIDWORD(v35))
            {
              unint64_t v35 = v59;
            }
            else
            {
              *a2 = v59;
              a2[2] = v35;
            }
            unint64_t v69 = HIDWORD(v37);
            if (HIDWORD(v37) <= HIDWORD(v62))
            {
              unint64_t v62 = v37;
            }
            else
            {
              unint64_t v69 = HIDWORD(v62);
              a2[1] = v62;
              a2[3] = v37;
            }
            if (v69 > HIDWORD(v35))
            {
              a2[1] = v35;
              a2[2] = v62;
            }
            break;
          case 5uLL:
            unint64_t v38 = *a2;
            unint64_t v39 = a2[1];
            if (HIDWORD(*a2) <= HIDWORD(v39))
            {
              unint64_t v40 = a2[1];
              unint64_t v39 = *a2;
            }
            else
            {
              *a2 = v39;
              a2[1] = v38;
              unint64_t v40 = v38;
            }
            unint64_t v64 = a2[2];
            unint64_t v63 = a2[3];
            unint64_t v65 = HIDWORD(v64);
            if (HIDWORD(v64) <= HIDWORD(v63))
            {
              unint64_t v66 = a2[3];
              unint64_t v63 = a2[2];
            }
            else
            {
              unint64_t v65 = HIDWORD(v63);
              a2[2] = v63;
              a2[3] = v64;
              unint64_t v66 = v64;
            }
            if (v65 >= HIDWORD(v39))
            {
              unint64_t v68 = v63;
              unint64_t v63 = v39;
            }
            else
            {
              *a2 = v63;
              a2[2] = v39;
              unint64_t v68 = v39;
            }
            unint64_t v70 = a2[4];
            unint64_t v71 = HIDWORD(v40);
            if (HIDWORD(v40) <= HIDWORD(v70))
            {
              unint64_t v72 = a2[4];
              unint64_t v70 = v40;
            }
            else
            {
              unint64_t v71 = HIDWORD(v70);
              a2[1] = v70;
              a2[4] = v40;
              unint64_t v72 = v40;
            }
            if (v71 >= HIDWORD(v63))
            {
              unint64_t v63 = v70;
            }
            else
            {
              *a2 = v70;
              a2[1] = v63;
            }
            unint64_t v73 = HIDWORD(v68);
            if (HIDWORD(v68) <= HIDWORD(v66))
            {
              unint64_t v74 = v66;
              unint64_t v66 = v68;
            }
            else
            {
              unint64_t v73 = HIDWORD(v66);
              a2[2] = v66;
              a2[3] = v68;
              unint64_t v74 = v68;
            }
            if (v73 >= HIDWORD(v63))
            {
              unint64_t v63 = v66;
            }
            else
            {
              a2[1] = v66;
              a2[2] = v63;
            }
            unint64_t v75 = HIDWORD(v74);
            if (HIDWORD(v74) <= HIDWORD(v72))
            {
              unint64_t v72 = v74;
            }
            else
            {
              unint64_t v75 = HIDWORD(v72);
              a2[3] = v72;
              a2[4] = v74;
            }
            if (v75 < HIDWORD(v63))
            {
              a2[2] = v72;
              a2[3] = v63;
            }
            break;
          default:
            JUMPOUT(0);
        }
        return result;
      }
      if (a3 <= 0) {
        break;
      }
      unint64_t v7 = v6 >> 2;
      int v8 = &a2[v6 >> 1];
      unint64_t v9 = *a2;
      unint64_t v10 = v8[-(v6 >> 2)];
      if (HIDWORD(*a2) > HIDWORD(v10))
      {
        *a2 = v10;
        v8[-(v6 >> 2)] = v9;
        unint64_t v11 = v9;
      }
      else
      {
        unint64_t v11 = v8[-(v6 >> 2)];
        unint64_t v10 = *a2;
      }
      unint64_t v12 = *v8;
      unint64_t v13 = v8[v7];
      unint64_t v14 = HIDWORD(*v8);
      if (v14 <= HIDWORD(v13))
      {
        unint64_t v15 = v8[v7];
        unint64_t v13 = *v8;
      }
      else
      {
        unint64_t v14 = HIDWORD(v13);
        *int v8 = v13;
        v8[v7] = v12;
        unint64_t v15 = v12;
      }
      if (v14 >= HIDWORD(v10))
      {
        unint64_t v16 = v13;
        unint64_t v13 = v10;
      }
      else
      {
        *a2 = v13;
        *int v8 = v10;
        unint64_t v16 = v10;
      }
      char v17 = &a2[v6];
      unint64_t v18 = *(v17 - 1);
      unint64_t v19 = HIDWORD(v11);
      if (HIDWORD(v11) <= HIDWORD(v18))
      {
        unint64_t v20 = *(v17 - 1);
        unint64_t v18 = v11;
      }
      else
      {
        unint64_t v19 = HIDWORD(v18);
        v8[-(v6 >> 2)] = v18;
        *(v17 - 1) = v11;
        unint64_t v20 = v11;
      }
      if (v19 >= HIDWORD(v13))
      {
        unint64_t v13 = v18;
      }
      else
      {
        *a2 = v18;
        v8[-(v6 >> 2)] = v13;
      }
      unint64_t v21 = HIDWORD(v16);
      if (HIDWORD(v16) <= HIDWORD(v15))
      {
        unint64_t v22 = v15;
        unint64_t v15 = v16;
      }
      else
      {
        unint64_t v21 = HIDWORD(v15);
        *int v8 = v15;
        v8[v7] = v16;
        unint64_t v22 = v16;
      }
      if (v21 >= HIDWORD(v13))
      {
        unint64_t v13 = v15;
      }
      else
      {
        v8[-(v6 >> 2)] = v15;
        *int v8 = v13;
      }
      unint64_t v23 = HIDWORD(v22);
      if (HIDWORD(v22) <= HIDWORD(v20))
      {
        unint64_t v20 = v22;
      }
      else
      {
        unint64_t v23 = HIDWORD(v20);
        v8[v7] = v20;
        *(v17 - 1) = v22;
      }
      if (v23 < HIDWORD(v13))
      {
        *int v8 = v20;
        v8[v7] = v13;
      }
      unint64_t v24 = 0;
      unint64_t v25 = *((unsigned int *)v8 + 1);
      int v26 = a2 - 1;
      unint64_t v27 = v6;
      while (1)
      {
        if (v24 < v6)
        {
          while (HIDWORD(a2[v24]) < v25)
          {
            if (v6 == ++v24)
            {
              unint64_t v24 = v6;
              goto LABEL_38;
            }
          }
        }
        do
        {
LABEL_38:
          unint64_t v28 = v27;
          if (!v27) {
            break;
          }
          --v27;
        }
        while (HIDWORD(v26[v28]) >= v25);
        if (v24 >= v28) {
          break;
        }
        if (v24 + 1 != v28)
        {
          unint64_t v29 = a2[v24];
          a2[v24] = v26[v28];
          v26[v28] = v29;
        }
        unint64_t v27 = v28 - 1;
        ++v24;
      }
      for (unint64_t i = v28; i < v6; ++i)
      {
        unint64_t v31 = a2[i];
        if (v25 == HIDWORD(v31))
        {
          if (i != v28)
          {
            unint64_t v32 = a2[v28];
            a2[v28] = v31;
            a2[i] = v32;
          }
          ++v28;
        }
      }
      --a3;
      uint64_t result = quicksort64();
      v6 -= v28;
      a2 += v28;
      BOOL v3 = v6 > 2;
      if (v6 < 2) {
        return result;
      }
    }
    for (uint64_t j = 1; j != v6; ++j)
    {
      unint64_t v42 = a2[j];
      unint64_t v43 = j;
      while (1)
      {
        unint64_t v44 = v43 - 1;
        unint64_t v45 = (v43 - 1) >> 1;
        unint64_t v46 = a2[v45];
        if (v46 >= v42) {
          break;
        }
        a2[v43] = v46;
        unint64_t v43 = (v43 - 1) >> 1;
        if (v44 <= 1) {
          goto LABEL_63;
        }
      }
      unint64_t v45 = v43;
LABEL_63:
      a2[v45] = v42;
    }
    unint64_t v47 = v6 - 1;
    unint64_t v48 = a2[v6 - 1];
    a2[v6 - 1] = *a2;
    if (v6 - 1 >= 2)
    {
      do
      {
        uint64_t v49 = 0;
        unint64_t v50 = 0;
        unint64_t v51 = 1;
        while (1)
        {
          unint64_t v52 = a2[v51];
          unint64_t v53 = v49 + 2;
          if (v49 + 2 < v47)
          {
            unint64_t v54 = a2[v53];
            if (v52 >= v54) {
              unint64_t v53 = v51;
            }
            if (v52 <= v54) {
              unint64_t v52 = v54;
            }
          }
          else
          {
            unint64_t v53 = v51;
          }
          if (v48 >= v52) {
            break;
          }
          a2[v50] = v52;
          uint64_t v49 = 2 * v53;
          unint64_t v51 = (2 * v53) | 1;
          unint64_t v50 = v53;
          if (v51 >= v47) {
            goto LABEL_75;
          }
        }
        unint64_t v53 = v50;
LABEL_75:
        a2[v53] = v48;
        unint64_t v48 = a2[--v47];
        a2[v47] = *a2;
      }
      while (v47 > 1);
    }
    *a2 = v48;
  }
  return result;
}

AAByteStream AACompressionOutputStreamOpen(AAByteStream compressed_stream, AACompressionAlgorithm compression_algorithm, size_t block_size, AAFlagSet flags, int n_threads)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  unint64_t v9 = calloc(1uLL, 0x68uLL);
  if (!v9)
  {
    unint64_t v16 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"AACompressionOutputStreamOpen", 254, 19, *v16, "malloc", v17, v18, v32);
    unint64_t v10 = 0;
LABEL_37:
    free(v9);
    aaCompressionOutputStreamClose(v10, v24, v25, v26, v27, v28, v29, v30);
    return 0;
  }
  unint64_t v10 = (uint64_t *)calloc(1uLL, 0x30uLL);
  if (!v10)
  {
    int v19 = *__error();
    unint64_t v20 = "malloc";
    __int16 v21 = 256;
LABEL_36:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"AACompressionOutputStreamOpen", v21, 19, v19, v20, v13, v14, v32);
    goto LABEL_37;
  }
  if (!n_threads) {
    n_threads = getDefaultNThreads();
  }
  *((_DWORD *)v10 + 2) = n_threads;
  unint64_t v11 = calloc(n_threads, 8uLL);
  v10[2] = (uint64_t)v11;
  if (*((_DWORD *)v10 + 2))
  {
    unint64_t v12 = 0;
    while (1)
    {
      *(void *)(v10[2] + 8 * v12) = CompressionWorkerDataCreate(block_size, (compression_algorithm)compression_algorithm);
      uint64_t v15 = v10[2];
      if (!*(void *)(v15 + 8 * v12)) {
        break;
      }
      ++v12;
      unint64_t v11 = (void *)*((unsigned int *)v10 + 2);
      if (v12 >= (unint64_t)v11) {
        goto LABEL_13;
      }
    }
    unint64_t v20 = "Worker data allocation";
    __int16 v21 = 264;
    goto LABEL_35;
  }
  uint64_t v15 = (uint64_t)v11;
  LODWORD(v11) = 0;
LABEL_13:
  unint64_t v22 = ThreadPipelineCreate(v11, v15, (uint64_t)CompressionWorkerProc, (uint64_t)v10, (uint64_t)CompressionConsumerProc, 0);
  *unint64_t v10 = (uint64_t)v22;
  if (!v22)
  {
    unint64_t v20 = "Thread allocation";
    __int16 v21 = 267;
LABEL_35:
    int v19 = 0;
    goto LABEL_36;
  }
  v10[3] = (uint64_t)compressed_stream;
  qmemcpy(buf, "pbz", sizeof(buf));
  char v23 = 122;
  if ((int)compression_algorithm <= 1284)
  {
    if (compression_algorithm)
    {
      if (compression_algorithm == 256)
      {
        char v23 = 52;
      }
      else
      {
        if (compression_algorithm != 774) {
          goto LABEL_34;
        }
        char v23 = 120;
      }
    }
    else
    {
      char v23 = 45;
    }
  }
  else
  {
    if ((int)compression_algorithm <= 2048)
    {
      if (compression_algorithm == 1285) {
        goto LABEL_31;
      }
      if (compression_algorithm == 1794)
      {
        char v23 = 98;
        goto LABEL_31;
      }
LABEL_34:
      unint64_t v20 = "Invalid compression algorithm";
      __int16 v21 = 274;
      goto LABEL_35;
    }
    if (compression_algorithm == 2049)
    {
      char v23 = 101;
    }
    else
    {
      if (compression_algorithm != 2304) {
        goto LABEL_34;
      }
      char v23 = 102;
    }
  }
LABEL_31:
  char v34 = v23;
  unint64_t v35 = bswap64(block_size);
  if (AAByteStreamWrite(compressed_stream, buf, 0xCuLL) != 12)
  {
    unint64_t v20 = "writing stream magic";
    __int16 v21 = 277;
    goto LABEL_35;
  }
  v9[3] = aaCompressionOutputStreamWrite;
  v9[7] = aaCompressionOutputStreamAbort;
  *unint64_t v9 = v10;
  v9[1] = aaCompressionOutputStreamClose;
  v9[9] = aaCompressionOutputStreamFlush;
  return (AAByteStream)v9;
}

void *CompressionWorkerDataCreate(size_t a1, compression_algorithm a2)
{
  __int16 v4 = 56;
  uint64_t v5 = calloc(1uLL, 0x38uLL);
  unint64_t v6 = v5;
  if (!v5) {
    goto LABEL_5;
  }
  v5[1] = 0;
  v5[2] = 0;
  *uint64_t v5 = a1;
  if (a1 >= 0x2000000001)
  {
    *__error() = 12;
    v6[3] = 0;
    *__error() = 12;
    unint64_t v7 = v6 + 4;
    __int16 v4 = 62;
LABEL_4:
    void *v7 = 0;
LABEL_5:
    int v8 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"CompressionWorkerDataCreate", v4, 19, *v8, "malloc", v9, v10, v16);
    CompressionWorkerDataDestroy((void **)v6);
    return 0;
  }
  unint64_t v12 = malloc(a1);
  v6[3] = v12;
  uint64_t v13 = malloc(a1);
  _OWORD v6[4] = v13;
  __int16 v4 = 62;
  if (!v12 || !v13) {
    goto LABEL_5;
  }
  *((_DWORD *)v6 + 10) = a2;
  if (a2)
  {
    if (a2 != COMPRESSION_LZMA)
    {
      size_t v14 = compression_encode_scratch_buffer_size(a2);
      if (v14)
      {
        if (v14 < 0x2000000001)
        {
          uint64_t v15 = malloc(v14);
          v6[6] = v15;
          if (v15) {
            return v6;
          }
          __int16 v4 = 68;
          goto LABEL_5;
        }
        *__error() = 12;
        unint64_t v7 = v6 + 6;
        __int16 v4 = 68;
        goto LABEL_4;
      }
    }
  }
  return v6;
}

uint64_t CompressionWorkerProc(uint64_t a1)
{
  size_t v2 = *(void *)(a1 + 8);
  compression_algorithm v3 = *(_DWORD *)(a1 + 40);
  if (!v3
    || (v3 != COMPRESSION_LZMA
      ? (v5 = compression_encode_buffer(*(uint8_t **)(a1 + 32), *(void *)a1, *(const uint8_t **)(a1 + 24), v2, *(void **)(a1 + 48), v3)): (int64_t v4 = PCompressLZMA6Encode(*(uint8_t **)(a1 + 32), *(void *)a1, *(const uint8_t **)(a1 + 24), v2), v5 = v4 & ~(v4 >> 63)), v5 ? (v6 = v5 + (v2 >> 4) >= v2) : (v6 = 1), v6))
  {
    memcpy(*(void **)(a1 + 32), *(const void **)(a1 + 24), v2);
    size_t v5 = v2;
  }
  *(void *)(a1 + 16) = v5;
  return 0;
}

uint64_t CompressionConsumerProc(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (!*(_DWORD *)(a1 + 40))
  {
    int8x16_t v8 = vrev64q_s8(*(int8x16_t *)(a2 + 8));
    if (AAByteStreamWrite(*(AAByteStream *)(a1 + 24), &v8, 0x10uLL) == 16)
    {
      if (AAByteStreamWrite(*(AAByteStream *)(a1 + 24), *(const void **)(a2 + 32), *(void *)(a2 + 16)) == *(void *)(a2 + 16)) {
        return 0;
      }
      __int16 v7 = 119;
    }
    else
    {
      __int16 v7 = 115;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"CompressionConsumerProc", v7, 19, 0, "Stream write failed", v4, v5, v8.i8[0]);
    *(_DWORD *)(a1 + 40) = 1;
  }
  return 0xFFFFFFFFLL;
}

uint64_t aaCompressionOutputStreamWrite(uint64_t a1, uint64_t __src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    return 0;
  }
  size_t v8 = a3;
  uint64_t v9 = (char *)__src;
  uint64_t v11 = 0;
  while (1)
  {
    unint64_t v12 = *(uint64_t **)(a1 + 32);
    if (v12)
    {
      uint64_t v13 = v12[1];
      goto LABEL_7;
    }
    uint64_t Worker = ThreadPipelineGetWorker(*(void *)a1, __src, a3, a4, a5, a6, a7, a8);
    *(void *)(a1 + 32) = Worker;
    if (!Worker) {
      break;
    }
    unint64_t v12 = (uint64_t *)Worker;
    uint64_t v13 = 0;
    *(void *)(Worker + 8) = 0;
    *(void *)(Worker + 16) = 0;
LABEL_7:
    if (*v12 - v13 >= v8) {
      size_t v15 = v8;
    }
    else {
      size_t v15 = *v12 - v13;
    }
    memcpy((void *)(v12[3] + v13), v9, v15);
    uint64_t v16 = *v12;
    size_t v17 = v12[1] + v15;
    v12[1] = v17;
    if (v17 == v16)
    {
      if ((ThreadPipelineRunWorker(*(void *)a1, *(void *)(a1 + 32), a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        uint64_t v18 = "running worker";
        __int16 v19 = 186;
        goto LABEL_18;
      }
      *(void *)(a1 + 32) = 0;
    }
    v9 += v15;
    v11 += v15;
    v8 -= v15;
    if (!v8) {
      return v11;
    }
  }
  uint64_t v18 = "getting next worker";
  __int16 v19 = 168;
LABEL_18:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"aaCompressionOutputStreamWrite", v19, 19, 0, v18, a7, a8, v21);
  *(_DWORD *)(a1 + 40) = 1;
  return -1;
}

uint64_t aaCompressionOutputStreamAbort(uint64_t result)
{
  *(_DWORD *)(result + 40) = 1;
  return result;
}

uint64_t *aaCompressionOutputStreamClose(uint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    size_t v8 = result;
    uint64_t v9 = result[4];
    if (v9)
    {
      if ((ThreadPipelineRunWorker(*result, v9, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"aaCompressionOutputStreamClose", 133, 19, 0, "RunWorker", v10, v11, v20);
        int v12 = 0;
      }
      else
      {
        int v12 = 1;
      }
      v8[4] = 0;
    }
    else
    {
      int v12 = 1;
    }
    if ((ThreadPipelineDestroy(*v8) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"aaCompressionOutputStreamClose", 138, 19, 0, "Thread shutdown", v13, v14, v20);
      int v12 = 0;
    }
    size_t v15 = (void *)v8[2];
    if (v15)
    {
      if (*((_DWORD *)v8 + 2))
      {
        unint64_t v16 = 0;
        do
          CompressionWorkerDataDestroy(*(void ***)(v8[2] + 8 * v16++));
        while (v16 < *((unsigned int *)v8 + 2));
        size_t v15 = (void *)v8[2];
      }
      free(v15);
    }
    if (*((_DWORD *)v8 + 11)
      && (AAByteStreamSeek((AAByteStream)v8[3], 0, 1) < 0 || (AAByteStreamTruncate((void *)v8[3]) & 0x80000000) != 0))
    {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"aaCompressionOutputStreamClose", 151, 19, "Truncate on compressed stream failed", v17, v18, v19, v20);
    }
    free(v8);
    if (v12) {
      return 0;
    }
    else {
      return (uint64_t *)0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t aaCompressionOutputStreamFlush(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 40)) {
    return 0xFFFFFFFFLL;
  }
  if ((ThreadPipelineFlush(*(void *)a1) & 0x80000000) != 0)
  {
    uint64_t v10 = "ThreadPipelineFlush";
    __int16 v11 = 209;
LABEL_15:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"aaCompressionOutputStreamFlush", v11, 19, 0, v10, v2, v3, v12);
    *(_DWORD *)(a1 + 40) = 1;
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(a1 + 32))
  {
    off_t v4 = AAByteStreamSeek(*(AAByteStream *)(a1 + 24), 0, 1);
    if (v4 < 0)
    {
      uint64_t v10 = "AAByteStreamSeek";
      __int16 v11 = 216;
    }
    else
    {
      off_t v5 = v4;
      CompressionWorkerProc(*(void *)(a1 + 32));
      if ((CompressionConsumerProc(a1, *(void *)(a1 + 32)) & 0x80000000) != 0)
      {
        uint64_t v10 = "CompressionConsumerProc";
        __int16 v11 = 220;
      }
      else
      {
        if (v5 == AAByteStreamSeek(*(AAByteStream *)(a1 + 24), v5, 0))
        {
          *(_DWORD *)(a1 + 44) = 1;
          goto LABEL_8;
        }
        uint64_t v10 = "AAByteStreamSeek";
        __int16 v11 = 223;
      }
    }
    goto LABEL_15;
  }
LABEL_8:
  if ((AAByteStreamFlush(*(void **)(a1 + 24)) & 0x80000000) != 0) {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"aaCompressionOutputStreamFlush", 230, 19, "Flush on underlying stream failed", v6, v7, v8, v12);
  }
  return 0;
}

void CompressionWorkerDataDestroy(void **a1)
{
  if (a1)
  {
    free(a1[3]);
    free(a1[4]);
    free(a1[6]);
    free(a1);
  }
}

uint64_t ParallelArchiveGenerateMSUBOM(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return generateBOM(a1, 1, a3, a4, a5, a6, a7, a8);
}

uint64_t generateBOM(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  uint64_t v142 = *MEMORY[0x263EF8340];
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v103);
  bzero(__fd, 0x4D8uLL);
  v113[0] = *(_DWORD *)a1;
  v113[1] = v8;
  long long v114 = *(_OWORD *)(a1 + 48);
  long long v110 = 0u;
  long long v109 = 0u;
  long long v108 = 0u;
  long long v107 = 0u;
  int DefaultNThreads = *(_DWORD *)(a1 + 16);
  if (!DefaultNThreads) {
    int DefaultNThreads = getDefaultNThreads();
  }
  v105[0] = 0;
  v105[1] = DefaultNThreads;
  uint64_t v15 = *(void *)(a1 + 40);
  uint64_t v106 = *(void *)(a1 + 24);
  uint64_t v111 = v113;
  *((void *)&v107 + 1) = v15;
  *(void *)&long long v108 = bomBeginProc;
  if (storeBlock((uint64_t)v113, 0, 0, __buf, v10, v11, v12, v13))
  {
    char v23 = "alloc first block";
    __int16 v24 = 929;
LABEL_70:
    int v83 = 0;
    goto LABEL_71;
  }
  int v25 = ParallelArchiveRead((uint64_t)v105, v16, v17, v18, v19, v20, v21, v22);
  if (v25 | v129)
  {
    char v23 = "ParallelArchiveRead";
    __int16 v24 = 934;
    goto LABEL_70;
  }
  qsort(v117, *(size_t *)v116, 0x30uLL, (int (__cdecl *)(const void *, const void *))BOMEntryCompareProc);
  if (createTree((uint64_t)v113, *(unint64_t *)v116, (void (*)(uint64_t, unint64_t, int8x8_t *))getPathsPK, (uint64_t)v113, 0x1000uLL, &v125, v26, v27))
  {
    char v23 = "path_tree";
    __int16 v24 = 940;
    goto LABEL_70;
  }
  if (!__count)
  {
    int v66 = createTree((uint64_t)v113, 0, 0, 0, 0x1000uLL, &v126, v21, v22);
    goto LABEL_62;
  }
  uint64_t v28 = (char *)calloc(2 * __count, 4uLL);
  if (!v28)
  {
    unint64_t v67 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"createHLinks", 499, 52, *v67, "malloc", v68, v69, v104);
    char v34 = 0;
    goto LABEL_60;
  }
  uint64_t v29 = calloc(__count, 8uLL);
  char v34 = v29;
  if (!v29)
  {
    int v70 = *__error();
    unint64_t v71 = "malloc";
    __int16 v72 = 501;
    goto LABEL_59;
  }
  size_t v35 = *(void *)v116;
  if (!*(void *)v116)
  {
    if (!__count)
    {
LABEL_47:
      unint64_t v59 = 0;
LABEL_48:
      if (v113[0] >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "%zu clusters in main hlinks tree\n", v59);
      }
      if (createTree((uint64_t)v113, v59, (void (*)(uint64_t, unint64_t, int8x8_t *))getTablePK, (uint64_t)v28, 0x1000uLL, &v126, v32, v33))
      {
        unint64_t v71 = "hlink_tree";
        __int16 v72 = 577;
        goto LABEL_58;
      }
      int v66 = 0;
      goto LABEL_61;
    }
LABEL_45:
    unint64_t v71 = "mismatch in hlink entry count";
    __int16 v72 = 511;
    goto LABEL_58;
  }
  size_t v36 = 0;
  size_t v37 = 0;
  unint64_t v38 = (int *)((char *)v117 + 36);
  do
  {
    int v39 = *v38;
    v38 += 12;
    if (v39 != -1)
    {
      if (v36 >= __count)
      {
        unint64_t v71 = "mismatch in hlink entry count";
        __int16 v72 = 508;
        goto LABEL_58;
      }
      v29[v36++] = v37;
      size_t v35 = *(void *)v116;
    }
    ++v37;
  }
  while (v37 < v35);
  if (v36 != __count) {
    goto LABEL_45;
  }
  if (!v36) {
    goto LABEL_47;
  }
  for (uint64_t i = 0; i != v36; ++i)
  {
    uint64_t v41 = v34[i];
    if (*((_DWORD *)v117 + 12 * v41 + 9) != -1)
    {
      unint64_t v42 = (char *)v117 + 48 * v41;
      bzero((char *)__buf + 2, 0x462uLL);
      LOWORD(__buf[0]) = 12078;
      __memcpy_chk();
      uint64_t v43 = *((void *)v42 + 1);
      *((unsigned char *)__buf + v43 + 2) = 0;
      if (storeBlock((uint64_t)v113, __buf, v43 + 3, (_DWORD *)v42 + 10, v44, v45, v46, v47))
      {
        unint64_t v71 = "hlink_path";
        __int16 v72 = 525;
        goto LABEL_58;
      }
    }
  }
  for (uint64_t j = 0; j != v36; ++j)
  {
    uint64_t v49 = v34[j];
    unint64_t v50 = v117;
    unint64_t v51 = (char *)v117 + 48 * v49;
    int v53 = *((_DWORD *)v51 + 4);
    unint64_t v52 = v51 + 16;
    if (v52[5] == v53)
    {
      uint64_t v54 = 0;
      unint64_t v55 = 0;
      do
      {
        uint64_t v56 = v34[v54];
        if (v50[12 * v56 + 9] == *v52)
        {
          unint64_t v57 = &v28[8 * v55];
          *(_DWORD *)unint64_t v57 = 0;
          *((_DWORD *)v57 + 1) = v50[12 * v56 + 10];
          ++v55;
        }
        ++v54;
      }
      while (v36 != v54);
      if (v113[0] > 1) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "%zu entries in hlinks cluster %zu\n", v55, j);
      }
      if (createTree((uint64_t)v113, v55, (void (*)(uint64_t, unint64_t, int8x8_t *))getTablePK, (uint64_t)v28, 0x40uLL, &v50[12 * v49 + 11], v32, v33))
      {
        unint64_t v71 = "hlink_cluster_tree";
        __int16 v72 = 551;
        goto LABEL_58;
      }
    }
  }
  uint64_t v58 = 0;
  unint64_t v59 = 0;
  while (1)
  {
    unint64_t v60 = v117;
    uint64_t v61 = v34[v58];
    if (*((_DWORD *)v117 + 12 * v61 + 9) == *((_DWORD *)v117 + 12 * v61 + 4)) {
      break;
    }
LABEL_39:
    if (v36 == ++v58) {
      goto LABEL_48;
    }
  }
  uint64_t v112 = 0;
  __buf[0] = bswap32(*((_DWORD *)v117 + 12 * v61 + 11));
  if (storeBlock((uint64_t)v113, __buf, 4uLL, (_DWORD *)&v112 + 1, v30, v31, v32, v33))
  {
    __int16 v72 = 567;
    goto LABEL_57;
  }
  __buf[0] = bswap32(v60[12 * v61 + 7]);
  if (!storeBlock((uint64_t)v113, __buf, 4uLL, &v112, v62, v63, v32, v33))
  {
    int v64 = v112;
    unint64_t v65 = &v28[8 * v59];
    *(_DWORD *)unint64_t v65 = HIDWORD(v112);
    *((_DWORD *)v65 + 1) = v64;
    ++v59;
    goto LABEL_39;
  }
  __int16 v72 = 569;
LABEL_57:
  unint64_t v71 = "storeBlock";
LABEL_58:
  int v70 = 0;
LABEL_59:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"createHLinks", v72, 52, v70, v71, v32, v33, v104);
LABEL_60:
  int v66 = -1;
LABEL_61:
  free(v34);
  free(v28);
LABEL_62:
  if (v66)
  {
    char v23 = "hlinks";
    __int16 v24 = 943;
    goto LABEL_70;
  }
  if (createTree((uint64_t)v113, *(unint64_t *)v118, (void (*)(uint64_t, unint64_t, int8x8_t *))getSize64PK, (uint64_t)v113, 0x80uLL, v127, v21, v22))
  {
    char v23 = "size64_tree";
    __int16 v24 = 946;
    goto LABEL_70;
  }
  if (createBomInfo((uint64_t)v113, v73, v74, v75, v76, v77, v21, v22))
  {
    char v23 = "bom_info";
    __int16 v24 = 949;
    goto LABEL_70;
  }
  if (createVIndex((uint64_t)v113, v78, v79, v80, v81, v82, v21, v22))
  {
    char v23 = "vindex";
    __int16 v24 = 952;
    goto LABEL_70;
  }
  if (v113[0] >= 1)
  {
    int v86 = (FILE **)MEMORY[0x263EF8348];
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12zu entries in BOM\n", *(size_t *)v116);
    fprintf(*v86, "%12zu hard link entries\n", __count);
    fprintf(*v86, "%12zu hard link clusters\n", v121);
    fprintf(*v86, "%12zu blocks allocated\n", v122);
    fprintf(*v86, "%12zu B in state blob storage\n", v128[1]);
  }
  uint64_t v124 = calloc(v122, 8uLL);
  if (!v124)
  {
    int v83 = *__error();
    char v23 = "malloc";
    __int16 v24 = 967;
    goto LABEL_71;
  }
  int v87 = *(const char **)(a1 + 8);
  if (!v87)
  {
    char v23 = "No output_file given";
    __int16 v24 = 970;
    goto LABEL_70;
  }
  char v104 = -92;
  __fd[0] = open(v87, 1537);
  if (__fd[0] < 0)
  {
    int v83 = *__error();
    char v23 = *(const char **)(a1 + 8);
    __int16 v24 = 972;
    goto LABEL_71;
  }
  uint64_t v88 = 0;
  int v136 = 83886080;
  *(_OWORD *)uint64_t v137 = xmmword_2106D44C0;
  size_t v89 = 516;
  do
  {
    switch(v88)
    {
      case 0:
        unsigned int v90 = v127[2];
        uint64_t v91 = "BomInfo";
        break;
      case 1:
        unsigned int v90 = v125;
        uint64_t v91 = "Paths";
        break;
      case 2:
        unsigned int v90 = v126;
        uint64_t v91 = "HLIndex";
        break;
      case 3:
        unsigned int v90 = v127[0];
        uint64_t v91 = "Size64";
        break;
      case 4:
        unsigned int v90 = v127[3];
        uint64_t v91 = "VIndex";
        break;
      default:
        char v23 = "invalid entry?";
        __int16 v24 = 993;
        goto LABEL_70;
    }
    size_t v92 = strlen(v91);
    *(_DWORD *)((char *)&v130 + v89) = bswap32(v90);
    *(void *)v137 += 4;
    *((unsigned char *)&v130 + (*(void *)v137)++) = v92 + 1;
    memcpy((char *)&v130 + *(void *)v137, v91, v92);
    *(void *)v137 += v92;
    *((unsigned char *)&v130 + *(void *)v137) = 0;
    size_t v89 = ++*(void *)v137;
    ++v88;
  }
  while (v88 != 5);
  *(void *)&v137[16] = v89 - *(void *)&v137[8];
  if (v113[0] >= 1)
  {
    uint64_t v93 = (FILE **)MEMORY[0x263EF8348];
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12zu B written for header\n", *(size_t *)&v137[8]);
    fprintf(*v93, "%12zu B written for TOC\n", *(size_t *)&v137[16]);
    size_t v89 = *(void *)v137;
  }
  ssize_t v94 = write(__fd[0], &v130, v89);
  if (v94 != *(void *)v137)
  {
    int v83 = *__error();
    char v23 = "write";
    __int16 v24 = 1008;
    goto LABEL_71;
  }
  size_t v95 = v122;
  if (v122)
  {
    uint64_t v96 = 0;
    for (unint64_t k = 0; k < v95; ++k)
    {
      size_t v98 = *((void *)v123 + v96 + 1);
      if (v98)
      {
        if ((v94 | v98) >> 32)
        {
          char v23 = "overflow in offset,size";
          __int16 v24 = 1016;
          goto LABEL_70;
        }
        if (write(__fd[0], (const void *)(v128[2] + *((void *)v123 + v96)), v98) != v98)
        {
          int v83 = *__error();
          char v23 = "write";
          __int16 v24 = 1018;
          goto LABEL_71;
        }
        uint64_t v99 = (4 * v96) & 0x3FFFFFFF8;
        *(_DWORD *)((char *)v124 + v99) = bswap32(*(unsigned int *)v137);
        *(_DWORD *)((char *)v124 + v99 + 4) = bswap32(v98);
        size_t v95 = v122;
        ssize_t v94 = *(void *)v137 + v98;
        *(void *)v137 += v98;
        v140 += v98;
      }
      v96 += 2;
    }
  }
  if (v113[0] >= 1)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12zu B written for blocks\n", v140);
    size_t v95 = v122;
    ssize_t v94 = *(void *)v137;
  }
  unint64_t v138 = v94;
  __buf[0] = bswap32(v95);
  if (write(__fd[0], __buf, 4uLL) != 4)
  {
    int v83 = *__error();
    char v23 = "write";
    __int16 v24 = 1033;
    goto LABEL_71;
  }
  *(void *)v137 += 4;
  if (write(__fd[0], v124, 8 * v95) != 8 * v95)
  {
    int v83 = *__error();
    char v23 = "write";
    __int16 v24 = 1036;
LABEL_71:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"generateBOM", v24, 52, v83, v23, v21, v22, v104);
    unsigned int v84 = -1;
    goto LABEL_72;
  }
  *(void *)v137 += 8 * v95;
  __buf[0] = 0;
  if (write(__fd[0], __buf, 4uLL) != 4)
  {
    int v83 = *__error();
    char v23 = "write";
    __int16 v24 = 1040;
    goto LABEL_71;
  }
  *(void *)v137 += 4;
  unsigned int v100 = v138;
  unint64_t v101 = *(void *)v137 - v138;
  unint64_t v139 = *(void *)v137 - v138;
  if (HIDWORD(v138) || HIDWORD(v101))
  {
    char v23 = "overflow in offset,size";
    __int16 v24 = 1045;
    goto LABEL_70;
  }
  if (v113[0] >= 1)
  {
    uint64_t v102 = (FILE **)MEMORY[0x263EF8348];
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12zu B written for blocks table\n", *(void *)v137 - v138);
    fprintf(*v102, "%12zu B final BOM size\n", *(size_t *)v137);
    unsigned int v100 = v138;
    LODWORD(v101) = v139;
  }
  int v131 = 0x1000000;
  unsigned int v132 = bswap32(v122);
  uint64_t v130 = 0x65726F74534D4F42;
  unsigned int v133 = bswap32(v100);
  unsigned int v134 = bswap32(v101);
  int8x8_t v135 = vrev32_s8((int8x8_t)vmovn_s64(*(int64x2_t *)&v137[8]));
  if (pwrite(__fd[0], &v130, 0x200uLL, 0) != 512)
  {
    int v83 = *__error();
    char v23 = "write";
    __int16 v24 = 1064;
    goto LABEL_71;
  }
  unsigned int v84 = 0;
LABEL_72:
  BlobBufferFree((uint64_t)v128);
  free(v117);
  free(v119);
  free(v123);
  free(v124);
  if ((__fd[0] & 0x80000000) == 0) {
    close(__fd[0]);
  }
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0) {
    return v84;
  }
  else {
    return result;
  }
}

uint64_t ParallelArchiveGenerateBOM(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return generateBOM(a1, 0, a3, a4, a5, a6, a7, a8);
}

uint64_t bomBeginProc(uint64_t result, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v100 = *MEMORY[0x263EF8340];
  unsigned int v8 = a2[1] - 77;
  BOOL v9 = v8 > 6;
  int v10 = (1 << v8) & 0x49;
  BOOL v11 = v9 || v10 == 0;
  if (!v11) {
    return result;
  }
  uint64_t v13 = result;
  if ((*((unsigned char *)a2 + 1) & 0x80) == 0)
  {
    uint64_t v14 = "missing PAT field";
    __int16 v15 = 622;
LABEL_42:
    int v43 = 0;
LABEL_43:
    uint64_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"bomBeginProc", v15, 52, v43, v14, a7, a8, (char)v91);
    ++*(_DWORD *)(v13 + 184);
    return result;
  }
  __strlcpy_chk();
  uint64_t v16 = *(uint64_t (**)(void, char *, void))(v13 + 8);
  if (v16)
  {
    uint64_t result = v16(*(void *)(v13 + 16), __s, a2[1]);
    if ((int)result < 1) {
      return result;
    }
  }
  int v17 = a2[1];
  if (v17 == 68 && !__s[0]) {
    strcpy(__s, ".");
  }
  uint64_t v18 = __s;
  size_t v19 = strlen(__s);
  size_t v20 = v19;
  if (!v19)
  {
    size_t v94 = 0;
LABEL_24:
    unint64_t v23 = *(void *)(v13 + 40);
    int v26 = v23 != 0;
    goto LABEL_25;
  }
  uint64_t v21 = 0;
  uint64_t v22 = __s;
  while (v22[v19] != 47)
  {
    ++v21;
    --v22;
    if (v19 == v21)
    {
      uint64_t v18 = __s;
      size_t v94 = v19;
      goto LABEL_24;
    }
  }
  uint64_t v18 = &v22[v19 + 1];
  size_t v94 = v21 - 1;
  unint64_t v23 = *(void *)(v13 + 40);
  if (!v23) {
    goto LABEL_24;
  }
  uint64_t v24 = *(void *)(v13 + 48) + 48 * v23 - 48;
  uint64_t v25 = *(void *)(v13 + 40);
  while (v20 - *(void *)(v24 + 8) != v21
       || memcmp((const void *)(*(void *)(v13 + 176) + *(void *)v24), __s, v20 - v21))
  {
    v24 -= 48;
    if (!--v25) {
      goto LABEL_24;
    }
  }
  int v26 = *(_DWORD *)(v24 + 16);
  if (!v26) {
    goto LABEL_24;
  }
LABEL_25:
  if (v17 != 72)
  {
    uint64_t v30 = -1;
    int v32 = -1;
    goto LABEL_32;
  }
  size_t v92 = v18;
  size_t v27 = strlen((const char *)a2 + 1168);
  if (!v23) {
    goto LABEL_30;
  }
  size_t v28 = v27;
  int v29 = cmpBOMPath(v13, a2 + 292, v27, 0);
  if (v29 < 0) {
    goto LABEL_30;
  }
  if (v29)
  {
    uint64_t v30 = v23 - 1;
    int v31 = cmpBOMPath(v13, a2 + 292, v28, v23 - 1);
    if (v31 <= 0)
    {
      if (v31)
      {
        uint64_t v58 = 0;
        while (v58 + 1 < v30)
        {
          uint64_t v59 = v58 + ((v30 - v58) >> 1);
          int v60 = cmpBOMPath(v13, a2 + 292, v28, v59);
          if (v60 < 0) {
            uint64_t v30 = v58 + ((v30 - v58) >> 1);
          }
          else {
            v58 += (v30 - v58) >> 1;
          }
          if (!v60)
          {
            uint64_t v30 = v59;
            goto LABEL_63;
          }
        }
        goto LABEL_30;
      }
LABEL_63:
      if ((v30 & 0x8000000000000000) == 0) {
        goto LABEL_64;
      }
    }
LABEL_30:
    uint64_t v91 = __s;
    uint64_t v14 = "missing hard link target entry: %s";
    __int16 v15 = 666;
    goto LABEL_42;
  }
  uint64_t v30 = 0;
LABEL_64:
  uint64_t v61 = *(void *)(v13 + 48) + 48 * v30;
  int v63 = *(_DWORD *)(v61 + 36);
  uint64_t v62 = (int *)(v61 + 36);
  int v32 = *(v62 - 5);
  uint64_t v64 = *(void *)(v13 + 88);
  *(void *)(v13 + 88) = v64 + 1;
  if (v63 == -1)
  {
    *uint64_t v62 = v32;
    uint64_t v65 = v64 + 2;
    uint64_t v66 = *(void *)(v13 + 96) + 1;
    *(void *)(v13 + 88) = v65;
    *(void *)(v13 + 96) = v66;
  }
  uint64_t v18 = v92;
LABEL_32:
  unint64_t v33 = *(void *)(v13 + 32);
  if (v23 >= v33)
  {
    uint64_t v35 = v33 + (v33 >> 1);
    BOOL v11 = v33 == 0;
    uint64_t v36 = 0x4000;
    if (!v11) {
      uint64_t v36 = v35;
    }
    *(void *)(v13 + 32) = v36;
    char v34 = (char *)reallocf(*(void **)(v13 + 48), 48 * v36);
    *(void *)(v13 + 48) = v34;
    if (!v34)
    {
      int v43 = *__error();
      uint64_t v14 = "malloc";
      __int16 v15 = 688;
      goto LABEL_43;
    }
    unint64_t v23 = *(void *)(v13 + 40);
  }
  else
  {
    char v34 = *(char **)(v13 + 48);
  }
  int v37 = *(_DWORD *)(v13 + 56);
  if (v37 == -1)
  {
    uint64_t v14 = "too many entries";
    __int16 v15 = 695;
    goto LABEL_42;
  }
  unint64_t v38 = &v34[48 * v23];
  int v39 = v37 + 1;
  *(_DWORD *)(v13 + 56) = v39;
  *((_DWORD *)v38 + 4) = v39;
  unint64_t v40 = (unsigned int *)(v38 + 16);
  *((_DWORD *)v38 + 5) = v26;
  uint64_t v41 = (unsigned int *)(v38 + 20);
  *((_DWORD *)v38 + 9) = v32;
  unint64_t v42 = v34;
  if (BlobBufferStore(v13 + 160, __s, v20, v38))
  {
    uint64_t v14 = "path_blob";
    __int16 v15 = 703;
    goto LABEL_42;
  }
  uint64_t v44 = v42;
  int v45 = a2[1];
  if (v45 == 72)
  {
    uint64_t v46 = v18;
    int v47 = *(_DWORD *)(*(void *)(v13 + 48) + 48 * v30 + 28);
    unint64_t v48 = v44;
    *(_DWORD *)&v44[48 * v23 + 28] = v47;
  }
  else
  {
    bzero(v98, 0x44DuLL);
    int v57 = *a2;
    if ((*a2 & 0x10) == 0)
    {
      uint64_t v91 = __s;
      uint64_t v14 = "missing MOD field: %s";
      __int16 v15 = 720;
      goto LABEL_42;
    }
    if ((v57 & 2) == 0)
    {
      uint64_t v91 = __s;
      uint64_t v14 = "missing UID field: %s";
      __int16 v15 = 721;
      goto LABEL_42;
    }
    if ((v57 & 4) == 0)
    {
      uint64_t v91 = __s;
      uint64_t v14 = "missing GID field: %s";
      __int16 v15 = 722;
      goto LABEL_42;
    }
    if ((v57 & 0x100) == 0)
    {
      uint64_t v91 = __s;
      uint64_t v14 = "missing MTM field: %s";
      __int16 v15 = 723;
      goto LABEL_42;
    }
    int v76 = a2[5];
    switch(v45)
    {
      case 'B':
        if ((v57 & 0x20) == 0)
        {
          uint64_t v91 = __s;
          uint64_t v14 = "missing DEV field: %s";
          __int16 v15 = 749;
          goto LABEL_42;
        }
        uint64_t v46 = v18;
        unsigned int v81 = v76 | 0x6000;
        goto LABEL_107;
      case 'C':
        if ((v57 & 0x20) == 0)
        {
          uint64_t v91 = __s;
          uint64_t v14 = "missing DEV field: %s";
          __int16 v15 = 756;
          goto LABEL_42;
        }
        uint64_t v46 = v18;
        unsigned int v81 = v76 | 0x2000;
LABEL_107:
        BOOL v93 = *(_DWORD *)(v13 + 4) == 0;
        if (*(_DWORD *)(v13 + 4)) {
          __int16 v82 = 17;
        }
        else {
          __int16 v82 = 1;
        }
        char v83 = 4;
        goto LABEL_116;
      case 'D':
        uint64_t v46 = v18;
        unsigned int v81 = v76 | 0x4000;
        BOOL v93 = *(_DWORD *)(v13 + 4) == 0;
        if (*(_DWORD *)(v13 + 4)) {
          __int16 v82 = 17;
        }
        else {
          __int16 v82 = 1;
        }
        char v83 = 2;
        goto LABEL_116;
      case 'F':
        if ((v57 & 0x80) == 0)
        {
          uint64_t v91 = __s;
          uint64_t v14 = "missing SIZ field: %s";
          __int16 v15 = 727;
          goto LABEL_42;
        }
        if ((v57 & 0x1000) == 0)
        {
          uint64_t v91 = __s;
          uint64_t v14 = "missing CKS field: %s";
          __int16 v15 = 728;
          goto LABEL_42;
        }
        if ((v57 & 8) == 0)
        {
          uint64_t v91 = __s;
          uint64_t v14 = "missing FLG field: %s";
          __int16 v15 = 729;
          goto LABEL_42;
        }
        uint64_t v46 = v18;
        unsigned int v81 = v76 | 0xFFFF8000;
        BOOL v93 = *(_DWORD *)(v13 + 4) == 0;
        if (*(_DWORD *)(v13 + 4)) {
          __int16 v82 = 19;
        }
        else {
          __int16 v82 = 3;
        }
        char v83 = 1;
        goto LABEL_116;
      case 'L':
        if ((v57 & 0x10000) == 0)
        {
          uint64_t v91 = __s;
          uint64_t v14 = "missing LNK field: %s";
          __int16 v15 = 742;
          goto LABEL_42;
        }
        uint64_t v46 = v18;
        unsigned int v81 = v76 | 0xFFFFA000;
        BOOL v93 = *(_DWORD *)(v13 + 4) == 0;
        char v83 = 3;
        if (*(_DWORD *)(v13 + 4)) {
          __int16 v82 = 19;
        }
        else {
          __int16 v82 = 3;
        }
LABEL_116:
        v95[0] = v83;
        v95[1] = 1;
        *(_WORD *)&v95[2] = v82 << 8;
        *(_WORD *)&v95[4] = bswap32(v81) >> 16;
        *(int8x8_t *)&v95[6] = vrev32_s8(*(int8x8_t *)(a2 + 2));
        int32x2_t v96 = vrev64_s32((int32x2_t)vrev32_s8((int8x8_t)vmovn_s64(*(int64x2_t *)(a2 + 10))));
        char v97 = 1;
        if ((v82 & 2) != 0)
        {
          if ((v57 & 0x1000) != 0) {
            unsigned int v85 = a2[22];
          }
          else {
            unsigned int v85 = 0;
          }
          v98[0] = bswap32(v85);
          size_t v84 = 27;
        }
        else
        {
          size_t v84 = 23;
        }
        if (v45 == 76)
        {
          size_t v86 = strlen((const char *)a2 + 1168);
          *(_DWORD *)&v95[v84] = bswap32(v86 + 1);
          size_t v87 = v84 + 4;
          memcpy(&v95[v84 + 4], a2 + 292, v86);
          v84 += v86 + 4 + 1;
          v95[v86 + v87] = 0;
        }
        else if ((v45 & 0xFFFFFFFE) == 0x42)
        {
          *(_DWORD *)&v95[v84] = bswap32(a2[6]);
          v84 += 4;
        }
        if (!v93)
        {
          *(_DWORD *)&v95[v84] = 0x8000000;
          uint64_t IsCompressed = statIsCompressed(a2[4]);
          size_t v89 = strstr(__s, "/usr/standalone/update");
          uint64_t v90 = (IsCompressed << 32) | 0xF1;
          if (v89) {
            uint64_t v90 = 0x1000000F1;
          }
          *(void *)&v95[v84 + 4] = v90;
          v84 += 12;
        }
        if (storeBlock(v13, v95, v84, &v44[48 * v23 + 28], v55, v56, a7, a8))
        {
          uint64_t v14 = "attr";
          __int16 v15 = 830;
          goto LABEL_42;
        }
        unint64_t v48 = v44;
        break;
      default:
        uint64_t v91 = __s;
        uint64_t v14 = "invalid entry type: %s";
        __int16 v15 = 763;
        goto LABEL_42;
    }
  }
  bzero(&v95[4], 0x460uLL);
  *(_DWORD *)size_t v95 = bswap32(*v41);
  __memcpy_chk();
  v95[v94 + 4] = 0;
  if (storeBlock(v13, v95, v94 + 5, &v48[48 * v23 + 24], v49, v50, v51, v52))
  {
    uint64_t v14 = "name";
    __int16 v15 = 846;
    goto LABEL_42;
  }
  *(_DWORD *)size_t v95 = bswap32(*v40);
  unint64_t v67 = &v48[48 * v23];
  unsigned int v69 = *((_DWORD *)v67 + 7);
  uint64_t v68 = (unsigned int *)(v67 + 28);
  *(_DWORD *)&v95[4] = bswap32(v69);
  uint64_t result = storeBlock(v13, v95, 8uLL, v68 + 1, v53, v54, a7, a8);
  if (result)
  {
    uint64_t v14 = "tree_ptr";
    __int16 v15 = 856;
    goto LABEL_42;
  }
  unint64_t v72 = *((void *)a2 + 5);
  if (HIDWORD(v72))
  {
    unint64_t v74 = *(void *)(v13 + 64);
    unint64_t v73 = *(void *)(v13 + 72);
    if (v73 >= v74)
    {
      uint64_t v77 = v74 + (v74 >> 1);
      if (!v74) {
        uint64_t v77 = 0x4000;
      }
      *(void *)(v13 + 64) = v77;
      uint64_t v75 = (char *)reallocf(*(void **)(v13 + 80), 8 * v77);
      *(void *)(v13 + 80) = v75;
      if (!v75)
      {
        int v43 = *__error();
        uint64_t v14 = "malloc";
        __int16 v15 = 868;
        goto LABEL_43;
      }
      unint64_t v73 = *(void *)(v13 + 72);
      unint64_t v72 = *((void *)a2 + 5);
    }
    else
    {
      uint64_t v75 = *(char **)(v13 + 80);
    }
    uint64_t v78 = &v75[8 * v73];
    *(void *)size_t v95 = bswap64(v72);
    if (storeBlock(v13, v95, 8uLL, v78, v70, v71, a7, a8))
    {
      uint64_t v14 = "size";
      __int16 v15 = 877;
      goto LABEL_42;
    }
    *(_DWORD *)size_t v95 = bswap32(*v68);
    uint64_t result = storeBlock(v13, v95, 4uLL, (_DWORD *)v78 + 1, v79, v80, a7, a8);
    if (result)
    {
      uint64_t v14 = "attr";
      __int16 v15 = 881;
      goto LABEL_42;
    }
    ++*(void *)(v13 + 72);
  }
  if (*(int *)v13 >= 2) {
    uint64_t result = fprintf((FILE *)*MEMORY[0x263EF8348], "entry_id=%u parent_id=%u %s\n", *v40, *v41, v46);
  }
  ++*(void *)(v13 + 40);
  return result;
}

uint64_t storeBlock(uint64_t a1, const void *a2, size_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *(void *)(a1 + 112);
  if (v8 >= 0xFFFFFFFF)
  {
    BOOL v9 = "too many blocks";
    __int16 v10 = 168;
LABEL_13:
    int v18 = 0;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"storeBlock", v10, 52, v18, v9, a7, a8, v21);
    return 0xFFFFFFFFLL;
  }
  if (HIDWORD(a3))
  {
    char v21 = a3;
    BOOL v9 = "block is too large: %zu B";
    __int16 v10 = 169;
    goto LABEL_13;
  }
  unint64_t v15 = *(void *)(a1 + 104);
  if (v8 >= v15)
  {
    uint64_t v16 = v15 + (v15 >> 1);
    if (!v15) {
      uint64_t v16 = 4096;
    }
    *(void *)(a1 + 104) = v16;
    int v17 = reallocf(*(void **)(a1 + 120), 16 * v16);
    *(void *)(a1 + 120) = v17;
    if (!v17)
    {
      int v18 = *__error();
      BOOL v9 = "malloc";
      __int16 v10 = 177;
      goto LABEL_14;
    }
    unint64_t v8 = *(void *)(a1 + 112);
  }
  *a4 = v8;
  if (a3)
  {
    if (BlobBufferStore(a1 + 160, a2, a3, (void *)(*(void *)(a1 + 120) + 16 * v8)))
    {
      BOOL v9 = "blob store";
      __int16 v10 = 187;
      goto LABEL_13;
    }
    unint64_t v8 = *(void *)(a1 + 112);
  }
  else
  {
    size_t v20 = (void *)(*(void *)(a1 + 120) + 16 * v8);
    void *v20 = 0;
    v20[1] = 0;
  }
  uint64_t result = 0;
  *(void *)(a1 + 112) = v8 + 1;
  return result;
}

uint64_t BOMEntryCompareProc(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 20);
  unsigned int v3 = *(_DWORD *)(a2 + 20);
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  if (v2 > v3) {
    return 1;
  }
  unsigned int v5 = *(_DWORD *)(a1 + 16);
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  BOOL v7 = v5 >= v6;
  BOOL v8 = v5 > v6;
  if (v7) {
    return v8;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t createTree(uint64_t a1, unint64_t a2, void (*a3)(uint64_t, unint64_t, int8x8_t *), uint64_t a4, size_t __size, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v95 = *MEMORY[0x263EF8340];
  if (a2 >= 0xFFFFFFFF)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"createTree", 259, 52, 0, "too many entries in tree", a7, a8, v77);
    return 0xFFFFFFFFLL;
  }
  uint64_t v14 = malloc(__size);
  if (!v14)
  {
    size_t v20 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"createTree", 273, 52, *v20, "malloc", v21, v22, v77);
    unint64_t v23 = 0;
    uint64_t v24 = 0;
LABEL_67:
    int v76 = 0;
    goto LABEL_68;
  }
  size_t v15 = (__size - 16) >> 3;
  unint64_t v16 = a2;
  if (a2 < 2)
  {
    unint64_t v18 = 0;
  }
  else
  {
    uint64_t v17 = 0;
    unint64_t v18 = 0;
    do
    {
      if (v17) {
        size_t v19 = v15 + 1;
      }
      else {
        size_t v19 = (__size - 16) >> 3;
      }
      unint64_t v16 = (v16 + v19 - 1) / v19;
      v18 += v16;
      --v17;
    }
    while (v16 > 1);
  }
  if (v18 <= 1) {
    size_t v25 = 1;
  }
  else {
    size_t v25 = v18;
  }
  uint64_t v24 = calloc(v25, 4uLL);
  if (!v24)
  {
    uint64_t v66 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"createTree", 287, 52, *v66, "malloc", v67, v68, v77);
    unint64_t v23 = 0;
    goto LABEL_67;
  }
  size_t v81 = v15 + 1;
  int v26 = calloc(v25, 4uLL);
  unint64_t v23 = v26;
  if (!v26)
  {
    int v69 = *__error();
    uint64_t v70 = "malloc";
    __int16 v71 = 289;
LABEL_66:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"createTree", v71, 52, v69, v70, v43, v44, v77);
    goto LABEL_67;
  }
  uint64_t v85 = a1;
  if (a2)
  {
    uint64_t v79 = a6;
    size_t v80 = v25;
    size_t v89 = __size;
    char v83 = v24;
    size_t v84 = v26;
    unint64_t v27 = 0;
    unint64_t v28 = 0;
    int v29 = v14 + 3;
    uint64_t v30 = 1;
    a6 = (_DWORD *)a2;
    __int16 v82 = v14;
    do
    {
      uint64_t v86 = v30;
      bzero(v14, v89);
      unint64_t v35 = v27 + v15;
      if (v27 + v15 <= (unint64_t)a6) {
        size_t v36 = v15;
      }
      else {
        size_t v36 = (size_t)a6 - v27;
      }
      int8x8_t v90 = 0;
      if (v36)
      {
        size_t v37 = 0;
        uint64_t v38 = 6;
        do
        {
          a3(a4, v27 + v37, &v90);
          __int32 v39 = v90.i32[1];
          *(int8x8_t *)&v29[2 * v37] = vrev32_s8(v90);
          v38 += 4;
          ++v37;
        }
        while (v37 < v36);
        __int32 v40 = v39;
        a1 = v85;
      }
      else
      {
        __int32 v40 = 0;
        uint64_t v38 = 6;
      }
      uint64_t v24 = v83;
      v84[v28] = v40;
      *(_DWORD *)&v82[v38] = 0;
      uint64_t v14 = v82;
      _WORD *v82 = 256;
      v82[1] = bswap32(v36) >> 16;
      if (storeBlock(a1, v82, v89, &v83[v28], v31, v32, v33, v34))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"createTree", 337, 52, 0, "storing page", v43, v44, v77);
        int v76 = 0;
        unint64_t v23 = v84;
        goto LABEL_68;
      }
      ++v28;
      a6 = (_DWORD *)a2;
      uint64_t v30 = v86 + 1;
      unint64_t v27 = v35;
    }
    while (v35 < a2);
    uint64_t v24 = v83;
    unint64_t v23 = v84;
    if (v28)
    {
      uint64_t v45 = 0;
      do
      {
        uint64_t v46 = v45 + 1;
        if (v45 + 1 >= v28)
        {
          unsigned int v47 = 0;
          if (!v45)
          {
LABEL_36:
            unsigned int v48 = 0;
            goto LABEL_37;
          }
        }
        else
        {
          unsigned int v47 = v83[v45 + 1];
          if (!v45) {
            goto LABEL_36;
          }
        }
        unsigned int v48 = v83[v45 - 1];
LABEL_37:
        uint64_t v49 = *(void *)(a1 + 176) + *(void *)(*(void *)(a1 + 120) + 16 * v83[v45]);
        *(_DWORD *)(v49 + 4) = bswap32(v47);
        *(_DWORD *)(v49 + 8) = bswap32(v48);
        uint64_t v45 = v46;
      }
      while (v86 != v46);
    }
    if (v28 < 2)
    {
      unint64_t v65 = 0;
    }
    else
    {
      unint64_t v50 = 0;
      uint64_t v51 = 4 * v15 + 4;
      unint64_t v52 = v28;
      while (2)
      {
        uint64_t v53 = 0;
        unint64_t v78 = v28;
        uint64_t v54 = &v83[v50];
        unint64_t v87 = v50;
        uint64_t v55 = (char *)&v84[v50];
        do
        {
          bzero(v82, v89);
          unint64_t v60 = v53 + v81;
          unint64_t v61 = v52 - v53;
          if (v53 + v81 <= v52) {
            unint64_t v61 = v81;
          }
          if (v61)
          {
            unsigned int v62 = v84[v53 + v87];
            *((_DWORD *)v82 + 3) = bswap32(v83[v53 + v87]);
            if (v61 != 1)
            {
              int v63 = v82 + 10;
              for (unint64_t i = 1; i < v61; ++i)
              {
                *(v63 - 1) = bswap32(v62);
                unsigned int v62 = *(_DWORD *)&v55[4 * i];
                _DWORD *v63 = bswap32(v54[i]);
                v63 += 2;
              }
            }
          }
          else
          {
            unsigned int v62 = 0;
          }
          v84[v28] = v62;
          _WORD *v82 = 0;
          v82[1] = bswap32(v61 - 1) >> 16;
          if (storeBlock(v85, v82, v89, &v83[v28], v56, v57, v58, v59))
          {
            uint64_t v70 = "storing page";
            __int16 v71 = 388;
            goto LABEL_65;
          }
          ++v28;
          uint64_t v54 = (_DWORD *)((char *)v54 + v51);
          v55 += v51;
          v53 += v81;
        }
        while (v60 < v52);
        unint64_t v65 = v78;
        unint64_t v52 = v28 - v78;
        unint64_t v50 = v78;
        LODWORD(a6) = a2;
        if (v28 - v78 >= 2) {
          continue;
        }
        break;
      }
    }
  }
  else
  {
    bzero(v14, __size);
    *uint64_t v14 = 256;
    if (storeBlock(a1, v14, __size, v24, v72, v73, v74, v75))
    {
      uint64_t v70 = "storing page";
      __int16 v71 = 301;
LABEL_65:
      int v69 = 0;
      goto LABEL_66;
    }
    uint64_t v79 = a6;
    size_t v80 = v25;
    LODWORD(v89) = __size;
    unint64_t v65 = 0;
    unint64_t v28 = 1;
    LODWORD(a6) = 0;
  }
  if (v28 != v80)
  {
    char v77 = v28;
    uint64_t v70 = "mismatch in number of tree pages: i_page=%zu n_pages=%zu";
    __int16 v71 = 399;
    goto LABEL_65;
  }
  int8x8_t v90 = (int8x8_t)0x100000065657274;
  unsigned int v91 = bswap32(v24[v65]);
  unsigned int v92 = bswap32(v89);
  unsigned int v93 = bswap32(a6);
  char v94 = 0;
  if (storeBlock(v85, &v90, 0x15uLL, v79, v41, v42, v43, v44))
  {
    uint64_t v70 = "storing base block";
    __int16 v71 = 413;
    goto LABEL_65;
  }
  int v76 = 1;
LABEL_68:
  free(v14);
  free(v24);
  free(v23);
  if (v76) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t getPathsPK(uint64_t result, uint64_t a2, _DWORD *a3)
{
  uint64_t v3 = *(void *)(result + 48) + 48 * a2;
  *a3 = *(_DWORD *)(v3 + 32);
  a3[1] = *(_DWORD *)(v3 + 24);
  return result;
}

uint64_t getSize64PK(uint64_t result, uint64_t a2, _DWORD *a3)
{
  uint64_t v3 = (_DWORD *)(*(void *)(result + 80) + 8 * a2);
  *a3 = *v3;
  a3[1] = v3[1];
  return result;
}

uint64_t createBomInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  unsigned int v8 = bswap32(*(_DWORD *)(a1 + 56) + 1);
  v12[0] = 0x1000000;
  v12[1] = v8;
  v12[2] = 0;
  uint64_t result = storeBlock(a1, v12, 0xCuLL, (_DWORD *)(a1 + 152), a5, a6, a7, a8);
  if (result)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"createBomInfo", 458, 52, 0, "storing bom_info block", v10, v11, v12[0]);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t createVIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  if (createTree(a1, 0, 0, 0, 0x80uLL, (_DWORD *)(a1 + 148), a7, a8))
  {
    uint64_t v13 = "vindex_tree";
    __int16 v14 = 466;
  }
  else
  {
    unsigned int v15 = bswap32(*(_DWORD *)(a1 + 148));
    v17[0] = 0x1000000;
    v17[1] = v15;
    void v17[2] = 0;
    char v18 = 0;
    uint64_t result = storeBlock(a1, v17, 0xDuLL, (_DWORD *)(a1 + 156), v9, v10, v11, v12);
    if (!result) {
      return result;
    }
    uint64_t v13 = "storing vindex block";
    __int16 v14 = 477;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"createVIndex", v14, 52, 0, v13, v11, v12, v17[0]);
  return 0xFFFFFFFFLL;
}

uint64_t cmpBOMPath(uint64_t a1, void *__s1, size_t a3, uint64_t a4)
{
  size_t v4 = a3;
  size_t v5 = *(void *)(*(void *)(a1 + 48) + 48 * a4 + 8);
  if (v5 < a3) {
    a3 = *(void *)(*(void *)(a1 + 48) + 48 * a4 + 8);
  }
  LODWORD(result) = memcmp(__s1, (const void *)(*(void *)(a1 + 176) + *(void *)(*(void *)(a1 + 48) + 48 * a4)), a3);
  if (v5 <= v4) {
    int v7 = 0;
  }
  else {
    int v7 = -1;
  }
  if (v5 >= v4) {
    unsigned int v8 = v7;
  }
  else {
    unsigned int v8 = 1;
  }
  if (result) {
    return result;
  }
  else {
    return v8;
  }
}

uint64_t getTablePK(uint64_t result, uint64_t a2, _DWORD *a3)
{
  uint64_t v3 = (_DWORD *)(result + 8 * a2);
  *a3 = *v3;
  a3[1] = v3[1];
  return result;
}

uint64_t ParallelArchiveExtractClones()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v41 = *MEMORY[0x263EF8340];
  enterThreadErrorContext(v0, v1, v2, v3, v4, v5, v6, v7, v28);
  bzero(&v36, 0xED0uLL);
  uint64_t v34 = 0;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v31 = 0u;
  memset(v30, 0, sizeof(v30));
  int v36 = *(_DWORD *)v0;
  if (realpath_DARWIN_EXTSN(*(const char **)(v0 + 16), v37))
  {
    size_t v13 = *(void *)(v0 + 48);
    if (v13)
    {
      uint64_t v38 = (void *)ParallelArchiveDBSetCreate(v13, *(void *)(v0 + 56), 0, v8, v9, v10, v11, v12);
      if (v38)
      {
        int v39 = 0;
        int v19 = *(_DWORD *)v0;
        if (*(int *)v0 >= 1)
        {
          memset(&v35, 0, 512);
          if (!statfs(v37, &v35))
          {
            size_t v20 = (FILE **)MEMORY[0x263EF8348];
            fprintf((FILE *)*MEMORY[0x263EF8348], "%12llu initial free blocks\n", v35.f_bfree);
            fprintf(*v20, "%12llu initial available blocks\n", v35.f_bavail);
            fprintf(*v20, "%12llu initial blocks\n", v35.f_blocks);
          }
          int v19 = *(_DWORD *)v0;
        }
        *(void *)&v30[0] = __PAIR64__(*(_DWORD *)(v0 + 4), v19);
        uint64_t v21 = *(void *)(v0 + 40);
        *(_OWORD *)((char *)v30 + 8) = *(_OWORD *)(v0 + 24);
        uint64_t v34 = &v36;
        *((void *)&v30[1] + 1) = v21;
        *(void *)&long long v31 = extractClonesBegin;
        *(void *)&long long v33 = extractClonesEnd;
        *((void *)&v31 + 1) = extractClonesBlob;
        *(void *)&long long v32 = extractClonesData;
        if ((ParallelArchiveRead((uint64_t)v30, v14, v15, v16, v17, v18, v11, v12) & 0x80000000) == 0)
        {
          int v22 = 0;
          goto LABEL_16;
        }
        uint64_t v24 = "reading archive";
        __int16 v25 = 189;
      }
      else
      {
        uint64_t v24 = "connecting to database";
        __int16 v25 = 162;
      }
    }
    else
    {
      uint64_t v24 = "No database provided";
      __int16 v25 = 160;
    }
    int v23 = 0;
  }
  else
  {
    int v23 = *__error();
    uint64_t v24 = *(const char **)(v0 + 16);
    __int16 v25 = 159;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractClones.c", (uint64_t)"ParallelArchiveExtractClones", v25, 71, v23, v24, v11, v12, v29);
  int v22 = 1;
LABEL_16:
  ParallelArchiveDBSetDestroy((uint64_t)v38);
  uint64_t result = leaveThreadErrorContext(0, 0, 0);
  if ((result & 0x80000000) == 0)
  {
    if ((v22 & 1) == 0 && *(int *)v0 >= 1)
    {
      unint64_t v27 = (FILE **)MEMORY[0x263EF8348];
      fprintf((FILE *)*MEMORY[0x263EF8348], "%12llu entries extracted\n", v40);
      memset(&v35, 0, 512);
      if (!statfs(v37, &v35))
      {
        fprintf(*v27, "%12llu final free blocks\n", v35.f_bfree);
        fprintf(*v27, "%12llu final available blocks\n", v35.f_bavail);
        fprintf(*v27, "%12llu final blocks\n", v35.f_blocks);
      }
    }
    return (v22 << 31 >> 31);
  }
  return result;
}

size_t extractClonesBegin(uint64_t a1, int *a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  size_t result = (size_t)memcpy((void *)(a1 + 1048), a2, 0x890uLL);
  *(_OWORD *)(a1 + 3240) = 0u;
  *(_OWORD *)(a1 + 3256) = 0u;
  *(_OWORD *)(a1 + 3272) = 0u;
  *(_OWORD *)(a1 + 3288) = 0u;
  *(_OWORD *)(a1 + 3304) = 0u;
  *(_OWORD *)(a1 + 3320) = 0u;
  *(_OWORD *)(a1 + 3336) = 0u;
  *(_OWORD *)(a1 + 3352) = 0u;
  *(_OWORD *)(a1 + 3368) = 0u;
  *(_OWORD *)(a1 + 3384) = 0u;
  *(_OWORD *)(a1 + 3400) = 0u;
  *(_OWORD *)(a1 + 3416) = 0u;
  *(_OWORD *)(a1 + 3432) = 0u;
  *(_OWORD *)(a1 + 3448) = 0u;
  *(_OWORD *)(a1 + 3464) = 0u;
  *(_OWORD *)(a1 + 3480) = 0u;
  *(void *)(a1 + 3496) = 0;
  *(_DWORD *)(a1 + 3504) = 0;
  *(_OWORD *)(a1 + 3732) = 0u;
  *(_OWORD *)(a1 + 3748) = 0u;
  *(_OWORD *)(a1 + 3700) = 0u;
  *(_OWORD *)(a1 + 3716) = 0u;
  *(_OWORD *)(a1 + 3668) = 0u;
  *(_OWORD *)(a1 + 3684) = 0u;
  *(_OWORD *)(a1 + 3636) = 0u;
  *(_OWORD *)(a1 + 3652) = 0u;
  *(_OWORD *)(a1 + 3604) = 0u;
  *(_OWORD *)(a1 + 3620) = 0u;
  *(_OWORD *)(a1 + 3572) = 0u;
  *(_OWORD *)(a1 + 3588) = 0u;
  *(_OWORD *)(a1 + 3540) = 0u;
  *(_OWORD *)(a1 + 3556) = 0u;
  *(_OWORD *)(a1 + 3508) = 0u;
  *(_OWORD *)(a1 + 3524) = 0u;
  *(void *)(a1 + 3768) = 0;
  *(_DWORD *)(a1 + 3776) = 0;
  if (*(_DWORD *)(a1 + 1052) == 68)
  {
    bzero(__s, 0x800uLL);
    if (concatPath(__s, 0x800uLL, (char *)(a1 + 4), (const char *)(a1 + 1192))) {
      return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractClones.c", (uint64_t)"extractClonesBegin", 49, 71, 0, "concatPath", v5, v6, v11);
    }
    size_t v7 = strlen(__s);
    makePath(__s, v7);
    size_t result = mkdir(__s, 0x1EDu);
    int v8 = *a2;
    if ((*a2 & 2) != 0)
    {
      uid_t v9 = a2[2];
      if ((v8 & 4) != 0) {
        goto LABEL_6;
      }
    }
    else
    {
      uid_t v9 = -1;
      if ((v8 & 4) != 0)
      {
LABEL_6:
        gid_t v10 = a2[3];
        return chown(__s, v9, v10);
      }
    }
    if ((v8 & 6) == 0) {
      return result;
    }
    gid_t v10 = -1;
    return chown(__s, v9, v10);
  }
  return result;
}

uint64_t extractClonesEnd(uint64_t result)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(result + 1052) != 77)
  {
    uint64_t v1 = result;
    bzero(__s, 0x800uLL);
    if (concatPath(__s, 0x800uLL, (char *)(v1 + 4), (const char *)(v1 + 1192)))
    {
      uint64_t v4 = "concatPath";
      __int16 v5 = 67;
      return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractClones.c", (uint64_t)"extractClonesEnd", v5, 71, 0, v4, v2, v3, (char)v14);
    }
    int v6 = *(_DWORD *)(v1 + 1052);
    if (v6 != 68)
    {
      if (v6 == 76)
      {
        size_t v10 = strlen(__s);
        makePath(__s, v10);
        unlink(__s);
        if (symlink((const char *)(v1 + 2216), __s))
        {
          int v11 = *__error();
          return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractClones.c", (uint64_t)"extractClonesEnd", 82, 71, v11, "%s", v12, v13, (char)__s);
        }
      }
      else
      {
        if (v6 != 70)
        {
          LOBYTE(v14) = *(_DWORD *)(v1 + 1052);
          uint64_t v4 = "Unsupported file type [%c] %s";
          __int16 v5 = 85;
          return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractClones.c", (uint64_t)"extractClonesEnd", v5, 71, 0, v4, v2, v3, (char)v14);
        }
        size_t v7 = strlen(__s);
        makePath(__s, v7);
        unlink(__s);
        if ((ParallelArchiveDBCloneWithSet(*(uint64_t **)(v1 + 1032), (char *)(v1 + 3508), (uint64_t)__s, v1 + 3240, *(void *)(v1 + 3496), 0, v8, v9) & 0x80000000) != 0)
        {
          uint64_t v14 = __s;
          uint64_t v4 = "cloning file: %s";
          __int16 v5 = 77;
          return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractClones.c", (uint64_t)"extractClonesEnd", v5, 71, 0, v4, v2, v3, (char)v14);
        }
      }
    }
    size_t result = yaa_setEntryAttributes(__s, (int *)(v1 + 1048), 0, *(_DWORD *)(v1 + 1040));
    if ((result & 0x80000000) != 0)
    {
      uint64_t v14 = __s;
      uint64_t v4 = "setting attributes: %s";
      __int16 v5 = 92;
      return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractClones.c", (uint64_t)"extractClonesEnd", v5, 71, 0, v4, v2, v3, (char)v14);
    }
    ++*(void *)(v1 + 3784);
    if (*(int *)v1 >= 2) {
      return fprintf((FILE *)*MEMORY[0x263EF8348], "%s\n", __s);
    }
  }
  return result;
}

_DWORD *extractClonesBlob(_DWORD *result, _DWORD *a2)
{
  if (result[263] != 77)
  {
    result[944] = 0;
    result[876] = 0;
    int v2 = *a2 & 0xDFDFDF;
    if (v2 == 4277337)
    {
      result[944] = 1;
      uint64_t v3 = result + 942;
    }
    else
    {
      if (v2 != 4932697) {
        return result;
      }
      result[876] = 1;
      uint64_t v3 = result + 874;
    }
    *uint64_t v3 = 0;
  }
  return result;
}

char *extractClonesData(char *result, void *__src, unint64_t a3)
{
  if (*((_DWORD *)result + 263) != 77)
  {
    size_t v3 = a3;
    __int16 v5 = result;
    if (*((_DWORD *)result + 876))
    {
      uint64_t v6 = *((void *)result + 437);
      if (256 - v6 >= a3) {
        size_t v7 = a3;
      }
      else {
        size_t v7 = 256 - v6;
      }
      size_t result = (char *)memcpy(&result[v6 + 3240], __src, v7);
      v5[437] += v7;
    }
    if (*((_DWORD *)v5 + 944))
    {
      uint64_t v8 = v5[471];
      if (256 - v8 < v3) {
        size_t v3 = 256 - v8;
      }
      size_t result = (char *)memcpy((char *)v5 + v8 + 3508, __src, v3);
      v5[471] += v3;
    }
  }
  return result;
}

uint64_t jsonPushLabel(uint64_t a1, char a2)
{
  unint64_t v4 = *(void *)(a1 + 72);
  unint64_t v5 = *(void *)(a1 + 80);
  uint64_t v6 = (void *)(a1 + 72);
  if (v5 >= v4)
  {
    if (v4) {
      size_t v8 = v4 + (v4 >> 1);
    }
    else {
      size_t v8 = 256;
    }
    *(void *)(a1 + 72) = v8;
    size_t v7 = reallocf(*(void **)(a1 + 88), v8);
    *(void *)(a1 + 88) = v7;
    if (!v7)
    {
      size_t v10 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAJSONStreams.c", (uint64_t)"jsonPushLabel", 358, 109, *v10, "malloc", v11, v12, v14);
      void *v6 = 0;
      v6[1] = 0;
      return 0xFFFFFFFFLL;
    }
    unint64_t v5 = *(void *)(a1 + 80);
  }
  else
  {
    size_t v7 = *(unsigned char **)(a1 + 88);
  }
  uint64_t v9 = 0;
  *(void *)(a1 + 80) = v5 + 1;
  v7[v5] = a2;
  return v9;
}

uint64_t jsonPushValue(uint64_t a1, char a2)
{
  unint64_t v4 = *(void *)(a1 + 96);
  unint64_t v5 = *(void *)(a1 + 104);
  uint64_t v6 = (void *)(a1 + 96);
  if (v5 >= v4)
  {
    if (v4) {
      size_t v8 = v4 + (v4 >> 1);
    }
    else {
      size_t v8 = 256;
    }
    *(void *)(a1 + 96) = v8;
    size_t v7 = reallocf(*(void **)(a1 + 112), v8);
    *(void *)(a1 + 112) = v7;
    if (!v7)
    {
      size_t v10 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAJSONStreams.c", (uint64_t)"jsonPushValue", 372, 109, *v10, "malloc", v11, v12, v14);
      void *v6 = 0;
      v6[1] = 0;
      return 0xFFFFFFFFLL;
    }
    unint64_t v5 = *(void *)(a1 + 104);
  }
  else
  {
    size_t v7 = *(unsigned char **)(a1 + 112);
  }
  uint64_t v9 = 0;
  *(void *)(a1 + 104) = v5 + 1;
  v7[v5] = a2;
  return v9;
}

void *AAJSONInputStreamOpen(uint64_t a1)
{
  int v2 = malloc(0x78uLL);
  size_t v3 = v2;
  if (v2)
  {
    memset_s(v2, 0x78uLL, 0, 0x78uLL);
    v3[1] = a1;
    v3[5] = 0x10000;
    unint64_t v4 = malloc(0x10000uLL);
    v3[8] = v4;
    if (v4)
    {
      *(void *)((char *)v3 + 20) = 32;
      v3[4] = calloc(0x20uLL, 4uLL);
    }
    else
    {
      size_t v8 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAJSONStreams.c", (uint64_t)"AAJSONInputStreamOpen", 387, 109, *v8, "malloc", v9, v10, v12);
      AAJSONInputStreamClose((void **)v3);
      return 0;
    }
  }
  else
  {
    unint64_t v5 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAJSONStreams.c", (uint64_t)"AAJSONInputStreamOpen", 382, 109, *v5, "malloc", v6, v7, v12);
  }
  return v3;
}

void AAJSONInputStreamClose(void **a1)
{
  if (a1)
  {
    free(a1[4]);
    free(a1[11]);
    free(a1[14]);
    free(a1[8]);
    free(a1);
  }
}

uint64_t AAJSONInputStreamRead(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (atomic_load((unsigned int *)a1)) {
    return 0xFFFFFFFFLL;
  }
  int v10 = *(_DWORD *)(a1 + 16);
  if (v10 == 9 || v10 == -1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAJSONStreams.c", (uint64_t)"AAJSONInputStreamRead", 418, 109, 0, "unexpected read call", a7, a8, v46);
    return 0xFFFFFFFFLL;
  }
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 104) = 0;
  uint64_t v14 = MEMORY[0x263EF8318];
  while (2)
  {
    unint64_t v15 = *(void *)(a1 + 56);
    uint64_t v16 = *(unsigned __int8 **)(a1 + 64);
    if (v15 >= *(void *)(a1 + 48))
    {
      ssize_t v17 = AAByteStreamRead(*(AAByteStream *)(a1 + 8), v16, *(void *)(a1 + 40));
      if (v17 < 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAJSONStreams.c", (uint64_t)"AAJSONInputStreamRead", 430, 109, 0, "read error: %zd", a7, a8, v17);
LABEL_104:
        uint64_t result = 0xFFFFFFFFLL;
        *(_DWORD *)(a1 + 16) = -1;
        return result;
      }
      if (!v17)
      {
        uint64_t v30 = "EOF reached";
        __int16 v31 = 431;
        goto LABEL_103;
      }
      unint64_t v15 = 0;
      *(void *)(a1 + 48) = v17;
      uint64_t v16 = *(unsigned __int8 **)(a1 + 64);
    }
    *(void *)(a1 + 56) = v15 + 1;
    int v18 = v16[v15];
    char v19 = v16[v15];
    switch(*(_DWORD *)(a1 + 16))
    {
      case 0:
        *(void *)(a1 + 104) = 0;
        if ((char)v18 < 0)
        {
          if (__maskrune((char)v18, 0x4000uLL)) {
            continue;
          }
        }
        else if ((*(_DWORD *)(v14 + 4 * (char)v18 + 60) & 0x4000) != 0)
        {
          continue;
        }
        if (v18 == 34) {
          goto LABEL_68;
        }
        if (v18 == 43 || v18 == 45 || ((char)v18 - 48) <= 9)
        {
          if ((jsonPushValue(a1, v18) & 0x80000000) == 0)
          {
            int v23 = 3;
            goto LABEL_69;
          }
          uint64_t v30 = "jsonPushValue";
          __int16 v31 = 451;
          goto LABEL_103;
        }
        if (v18 == 123)
        {
          uint64_t v32 = *(unsigned int *)(a1 + 24);
          if (v32 == *(_DWORD *)(a1 + 20))
          {
            uint64_t v30 = "max level reached";
            __int16 v31 = 465;
            goto LABEL_103;
          }
          int v27 = 0;
          uint64_t v44 = *(void *)(a1 + 32);
          *(_DWORD *)(a1 + 24) = v32 + 1;
          *(_DWORD *)(v44 + 4 * v32) = 0;
          int v37 = 6;
          goto LABEL_125;
        }
        if (v18 == 91)
        {
          uint64_t v33 = *(unsigned int *)(a1 + 24);
          if (v33 == *(_DWORD *)(a1 + 20))
          {
            uint64_t v30 = "max level reached";
            __int16 v31 = 457;
            goto LABEL_103;
          }
          int v37 = 0;
          uint64_t v45 = *(void *)(a1 + 32);
          *(_DWORD *)(a1 + 24) = v33 + 1;
          int v27 = 1;
          *(_DWORD *)(v45 + 4 * v33) = 1;
          goto LABEL_125;
        }
        if (((char)v18 - 97) <= 0x19)
        {
          if ((jsonPushValue(a1, v18) & 0x80000000) == 0)
          {
            int v23 = 4;
            goto LABEL_69;
          }
          uint64_t v30 = "jsonPushValue";
          __int16 v31 = 473;
          goto LABEL_103;
        }
        unsigned int v25 = *(_DWORD *)(a1 + 24) - 1;
        BOOL v34 = (*(_DWORD *)(*(void *)(a1 + 32) + 4 * v25) & 1) == 0 || (char)v18 != 93;
        BOOL v35 = (*(_DWORD *)(*(void *)(a1 + 32) + 4 * v25) & 1) == 0 && (char)v18 == 125;
        if (v34 && !v35) {
          goto LABEL_102;
        }
        goto LABEL_121;
      case 1:
        if (v18 == 92)
        {
          int v23 = 2;
          goto LABEL_69;
        }
        if (v18 == 34)
        {
          *(_DWORD *)(a1 + 16) = 5;
          if ((jsonPushValue(a1, 0) & 0x80000000) == 0)
          {
            int v27 = 3;
            goto LABEL_126;
          }
          uint64_t v30 = "jsonPushValue";
          __int16 v31 = 499;
          goto LABEL_103;
        }
        if ((jsonPushValue(a1, v18) & 0x80000000) != 0)
        {
          uint64_t v30 = "jsonPushValue";
          __int16 v31 = 503;
          goto LABEL_103;
        }
        continue;
      case 2:
        HIDWORD(v21) = (char)v18;
        LODWORD(v21) = ((char)v18 << 24) - 1644167168;
        unsigned __int8 v20 = v21 >> 25;
        if (v20 < 0xAu && ((0x341u >> v20) & 1) != 0)
        {
          char v22 = asc_2106D44E8[(char)v20];
        }
        else if ((char)v18 == 102)
        {
          char v22 = 12;
        }
        else
        {
          char v22 = v19;
        }
        if ((jsonPushValue(a1, v22) & 0x80000000) != 0)
        {
          uint64_t v30 = "jsonPushValue";
          __int16 v31 = 512;
          goto LABEL_103;
        }
LABEL_68:
        int v23 = 1;
        goto LABEL_69;
      case 3:
        if (((char)v18 - 48) > 9)
        {
          *(_DWORD *)(a1 + 16) = 5;
          *(void *)(a1 + 56) = v15;
          if ((jsonPushValue(a1, 0) & 0x80000000) == 0)
          {
            int v27 = 4;
            goto LABEL_126;
          }
          uint64_t v30 = "jsonPushValue";
          __int16 v31 = 539;
          goto LABEL_103;
        }
        if ((jsonPushValue(a1, v18) & 0x80000000) != 0)
        {
          uint64_t v30 = "jsonPushValue";
          __int16 v31 = 533;
          goto LABEL_103;
        }
        continue;
      case 4:
        if (((char)v18 - 97) > 0x19)
        {
          *(_DWORD *)(a1 + 16) = 5;
          *(void *)(a1 + 56) = v15;
          if ((jsonPushValue(a1, 0) & 0x80000000) == 0)
          {
            char v28 = *(const char **)(a1 + 112);
            if (!strcmp(v28, "false") || !strcmp(v28, "true"))
            {
              int v27 = 6;
            }
            else
            {
              if (strcmp(v28, "null")) {
                goto LABEL_102;
              }
              int v27 = 7;
            }
            goto LABEL_126;
          }
          uint64_t v30 = "jsonPushValue";
          __int16 v31 = 524;
          goto LABEL_103;
        }
        if ((jsonPushValue(a1, v18) & 0x80000000) != 0)
        {
          uint64_t v30 = "jsonPushValue";
          __int16 v31 = 519;
          goto LABEL_103;
        }
        continue;
      case 5:
        if ((char)v18 < 0)
        {
          if (__maskrune((char)v18, 0x4000uLL)) {
            continue;
          }
        }
        else if ((*(_DWORD *)(v14 + 4 * (char)v18 + 60) & 0x4000) != 0)
        {
          continue;
        }
        int v24 = *(_DWORD *)(a1 + 24);
        if (!v24)
        {
          uint64_t v30 = "invalid JSON state";
          __int16 v31 = 546;
          goto LABEL_103;
        }
        unsigned int v25 = v24 - 1;
        int v26 = *(_DWORD *)(*(void *)(a1 + 32) + 4 * v25);
        if (v18 != 44)
        {
          if (v18 == 93)
          {
            if (v26) {
              goto LABEL_121;
            }
            char v19 = 93;
          }
          else if (v18 == 125)
          {
            goto LABEL_91;
          }
LABEL_102:
          char v46 = v19;
          uint64_t v30 = "invalid char %c %s";
          __int16 v31 = 610;
          goto LABEL_103;
        }
        if (v26) {
          int v23 = 0;
        }
        else {
          int v23 = 6;
        }
LABEL_69:
        *(_DWORD *)(a1 + 16) = v23;
        continue;
      case 6:
        *(void *)(a1 + 80) = 0;
        if (((char)v18 & 0x80000000) == 0)
        {
          if ((*(_DWORD *)(v14 + 4 * (char)v18 + 60) & 0x4000) == 0) {
            goto LABEL_61;
          }
          continue;
        }
        if (__maskrune((char)v18, 0x4000uLL)) {
          continue;
        }
LABEL_61:
        if (v18 == 34)
        {
          int v23 = 7;
          goto LABEL_69;
        }
        if (v18 != 125) {
          goto LABEL_102;
        }
        int v29 = *(_DWORD *)(a1 + 24);
        if (!v29) {
          goto LABEL_92;
        }
        unsigned int v25 = v29 - 1;
        int v26 = *(_DWORD *)(*(void *)(a1 + 32) + 4 * v25);
LABEL_91:
        if (v26)
        {
LABEL_92:
          char v19 = 125;
          goto LABEL_102;
        }
LABEL_121:
        *(_DWORD *)(a1 + 24) = v25;
        if (v25) {
          int v37 = 5;
        }
        else {
          int v37 = 9;
        }
        int v27 = 2;
LABEL_125:
        *(_DWORD *)(a1 + 16) = v37;
LABEL_126:
        if (a2) {
          memset_s(a2, 0x38uLL, 0, 0x38uLL);
        }
        *a2 = v27;
        uint64_t v38 = *(void *)(a1 + 80);
        if (v38) {
          uint64_t v38 = *(void *)(a1 + 88);
        }
        *((void *)a2 + 1) = v38;
        a2[12] = *(_DWORD *)(a1 + 24);
        if (v27 == 6)
        {
          int v39 = strcmp(*(const char **)(a1 + 112), "true");
          uint64_t result = 0;
          a2[9] = v39 == 0;
        }
        else if (v27 == 4)
        {
          uint64_t v40 = *(const char **)(a1 + 112);
          if (*v40 == 45)
          {
            unint64_t v41 = strtoull(v40 + 1, 0, 10);
            uint64_t result = 0;
            *((void *)a2 + 3) = v41;
            int v42 = -1;
          }
          else
          {
            unint64_t v43 = strtoull(v40, 0, 0);
            uint64_t result = 0;
            *((void *)a2 + 3) = v43;
            int v42 = v43 != 0;
          }
          a2[8] = v42;
        }
        else
        {
          uint64_t result = 0;
          if (v27 == 3) {
            *((void *)a2 + 2) = *(void *)(a1 + 112);
          }
        }
        return result;
      case 7:
        if ((char)v18 == 34)
        {
          if ((jsonPushLabel(a1, 0) & 0x80000000) == 0)
          {
            int v23 = 8;
            goto LABEL_69;
          }
          uint64_t v30 = "jsonPushLabel";
          __int16 v31 = 587;
LABEL_103:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAJSONStreams.c", (uint64_t)"AAJSONInputStreamRead", v31, 109, 0, v30, a7, a8, v46);
          goto LABEL_104;
        }
        if ((jsonPushLabel(a1, v18) & 0x80000000) != 0)
        {
          uint64_t v30 = "jsonPushLabel";
          __int16 v31 = 591;
          goto LABEL_103;
        }
        continue;
      case 8:
        if ((char)v18 < 0)
        {
          if (__maskrune((char)v18, 0x4000uLL)) {
            continue;
          }
        }
        else if ((*(_DWORD *)(v14 + 4 * (char)v18 + 60) & 0x4000) != 0)
        {
          continue;
        }
        if ((char)v18 != 58) {
          goto LABEL_102;
        }
        int v23 = 0;
        goto LABEL_69;
      default:
        goto LABEL_102;
    }
  }
}

uint64_t pc_array_compare(uint64_t (*a1)(void, void), void *a2, void *a3)
{
  return a1(*a2, *a3);
}

void *pc_array_init(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = malloc(a2 * a1 + 64);
  if (v4)
  {
    *unint64_t v4 = 0;
    v4[1] = a2;
    unint64_t v5 = v4 + 8;
    v4[2] = a1;
  }
  else
  {
    uint64_t v6 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c", (uint64_t)"pc_array_init", 26, 139, *v6, "malloc", v7, v8, v10);
    return 0;
  }
  return v5;
}

void *pc_array_init(uint64_t a1)
{
  return pc_array_init(a1, 8);
}

void pc_array_free(uint64_t a1)
{
  if (a1) {
    free((void *)(a1 - 64));
  }
}

char *pc_array_compact(uint64_t a1)
{
  unint64_t v3 = *(void *)(a1 - 64);
  unint64_t v4 = *(void *)(a1 - 56);
  int v2 = (char *)(a1 - 64);
  if (v4 <= v3) {
    return v2 + 64;
  }
  *(void *)(a1 - 56) = v3;
  int v2 = (char *)reallocf(v2, *(void *)(a1 - 48) * v3 + 64);
  if (v2) {
    return v2 + 64;
  }
  uint64_t v6 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c", (uint64_t)"pc_array_compact", 56, 139, *v6, "reallocf", v7, v8, vars0);
  return 0;
}

void *pc_array_append(uint64_t a1, void *__src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9 = *(void *)(a1 - 64);
  unint64_t v10 = *(void *)(a1 - 56);
  uint64_t v11 = (void *)(a1 - 64);
  if (v10 > v9) {
    goto LABEL_7;
  }
  uint64_t v12 = 2 * v10;
  BOOL v13 = v10 == 0;
  unint64_t v14 = 16;
  if (!v13) {
    unint64_t v14 = v12;
  }
  *(void *)(a1 - 56) = v14;
  if (v14 <= v9)
  {
    ssize_t v17 = "too many elements";
    __int16 v18 = 70;
    int v19 = 0;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c", (uint64_t)"pc_array_append", v18, 139, v19, v17, a7, a8, v21);
    return 0;
  }
  unint64_t v15 = reallocf((void *)(a1 - 64), *(void *)(a1 - 48) * v14 + 64);
  if (!v15)
  {
    int v19 = *__error();
    ssize_t v17 = "reallocf";
    __int16 v18 = 72;
    goto LABEL_10;
  }
  uint64_t v11 = v15;
  unint64_t v9 = *v15;
LABEL_7:
  uint64_t v16 = v11 + 8;
  memcpy((char *)v11 + v11[2] * v9 + 64, __src, v11[2]);
  ++*v11;
  return v16;
}

void pc_array_sort(void *a1, int (__cdecl *__compar)(const void *, const void *))
{
}

void *pc_array_indirect_sort(uint64_t a1, void *a2)
{
  uint64_t v3 = a1;
  size_t v4 = *(void *)(a1 - 64);
  unint64_t v5 = malloc(8 * v4);
  uint64_t v6 = v5;
  if (v5)
  {
    if (v4)
    {
      uint64_t v7 = *(void *)(v3 - 48);
      uint64_t v8 = v5;
      size_t v9 = v4;
      do
      {
        *v8++ = v3;
        v3 += v7;
        --v9;
      }
      while (v9);
    }
    qsort_r(v5, v4, 8uLL, a2, (int (__cdecl *)(void *, const void *, const void *))pc_array_compare);
  }
  else
  {
    unint64_t v10 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c", (uint64_t)"pc_array_indirect_sort", 95, 139, *v10, "malloc", v11, v12, v14);
  }
  return v6;
}

uint64_t pc_array_aggregate(char *a1, unsigned int (*a2)(char *, char *), uint64_t (*a3)(char *, char *))
{
  if (*((void *)a1 - 8) < 2uLL) {
    return 0;
  }
  uint64_t v7 = &a1[*((void *)a1 - 6)];
  unint64_t v8 = 1;
  uint64_t v9 = 1;
  unint64_t v10 = a1;
  while (1)
  {
    if (a2(v10, v7))
    {
      size_t v11 = *((void *)a1 - 6);
      v10 += v11;
      if (v10 < v7) {
        memcpy(v10, v7, v11);
      }
      ++v9;
      goto LABEL_9;
    }
    if ((a3(v10, v7) & 0x80000000) != 0) {
      return 0xFFFFFFFFLL;
    }
LABEL_9:
    ++v8;
    v7 += *((void *)a1 - 6);
    if (v8 >= *((void *)a1 - 8))
    {
      uint64_t result = 0;
      *((void *)a1 - 8) = v9;
      return result;
    }
  }
}

uint64_t ParallelArchiveConvert(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v59 = *MEMORY[0x263EF8340];
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v26);
  uint64_t v32 = 0;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v29 = 0u;
  memset(v28, 0, sizeof(v28));
  bzero(v35, 0xC10uLL);
  v34[0] = a1;
  v34[1] = a2;
  unint64_t v10 = MemBufferCreate(0x100000uLL);
  int v36 = v10;
  size_t v11 = MemBufferCreate(0x100000uLL);
  int v42 = v11;
  if (!v10 || !v11)
  {
    unsigned __int8 v20 = "allocating state buffers";
    __int16 v21 = 769;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"ParallelArchiveConvert", v21, 62, 0, v20, v17, v18, v27);
    int v19 = 1;
    goto LABEL_10;
  }
  *(void *)&v28[0] = 0;
  DWORD1(v28[0]) = *(_DWORD *)(a2 + 4);
  *(_OWORD *)((char *)v28 + 8) = *(_OWORD *)(a2 + 24);
  *((void *)&v28[1] + 1) = *(void *)(a2 + 40);
  *(void *)&long long v29 = convertBegin;
  *(void *)&long long v31 = convertEnd;
  *((void *)&v29 + 1) = convertBlob;
  *(void *)&long long v30 = convertPayload;
  *((void *)&v30 + 1) = convertPadding;
  *((void *)&v31 + 1) = convertPadding;
  uint64_t v32 = v34;
  if ((ParallelArchiveRead((uint64_t)v28, v12, v13, v14, v15, v16, v17, v18) & 0x80000000) != 0)
  {
    unsigned __int8 v20 = "Archive read";
    __int16 v21 = 787;
    goto LABEL_9;
  }
  if (*(int *)a2 >= 1) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12llu bytes read\n", v38);
  }
  int v19 = 0;
LABEL_10:
  MemBufferDestroy(v42);
  MemBufferDestroy(v36);
  if (v41)
  {
    long long v58 = 0u;
    long long v57 = 0u;
    long long v56 = 0u;
    long long v55 = 0u;
    long long v54 = 0u;
    long long v53 = 0u;
    long long v52 = 0u;
    long long v51 = 0u;
    long long v50 = 0u;
    long long v49 = 0u;
    long long v48 = 0u;
    long long v47 = 0u;
    long long v46 = 0u;
    long long v45 = 0u;
    long long v44 = 0u;
    long long v43 = 0u;
    uint64_t v33 = 0;
    ParallelArchiveDBRequestCloseAndGetKey(v41);
  }
  if (v40) {
    ParallelArchiveDBRequestClose(v40);
  }
  ParallelArchiveDBSetDestroy((uint64_t)v35[0]);
  ParallelArchiveDBSessionDestroy((uint64_t)v35[1]);
  free(v39);
  int v22 = v37;
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (v22) {
    int v24 = 1;
  }
  else {
    int v24 = v19;
  }
  unsigned int v25 = v24 << 31 >> 31;
  if ((int)result >= 0) {
    return v25;
  }
  else {
    return result;
  }
}

uint64_t convertBegin(uint64_t result, _DWORD *a2, const void *a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t v68 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(result + 56)) {
    return result;
  }
  uint64_t v11 = result;
  uint64_t v12 = *(void *)(result + 64);
  *(void *)(result + 2296) = 0;
  *(void *)(result + 64) = v12 + a6;
  *(void *)(result + 72) = 0;
  *(void *)(result + 80) = 0;
  *(void *)(result + 88) = 0;
  MemBufferClear(*(void **)(result + 2856));
  bzero((void *)(v11 + 96), 0x890uLL);
  if ((reserveExtraFields(v11, a4) & 0x80000000) != 0)
  {
    int v24 = "allocating extraFields";
    __int16 v25 = 424;
LABEL_10:
    uint64_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"convertBegin", v25, 62, 0, v24, v13, v14, v65);
    if (!*(_DWORD *)(v11 + 56))
    {
      *(_DWORD *)(v11 + 56) = 1;
      uint64_t v26 = *(void *)(v11 + 8);
      char v27 = *(uint64_t (**)(uint64_t))(v26 + 32);
      if (v27)
      {
        uint64_t v28 = *(void *)(v26 + 40);
        return v27(v28);
      }
    }
    return result;
  }
  memcpy((void *)(v11 + 96), a2, 0x890uLL);
  uint64_t result = (uint64_t)memcpy(*(void **)(v11 + 2304), a3, 1032 * a4);
  *(void *)(v11 + 2296) = a4;
  BOOL v34 = a2[1] == 77;
  *(_DWORD *)(v11 + 72) = v34;
  if (v34) {
    return result;
  }
  if (*(_DWORD *)(v11 + 60)) {
    goto LABEL_6;
  }
  int v29 = 99103;
  if (a6 >= 8)
  {
    uint64_t v30 = 0;
    unint64_t v31 = 0;
    do
    {
      unint64_t v32 = v31;
      unint64_t v31 = *(unsigned char *)(a5 + v30++) & 7 | (8 * v31);
    }
    while (v30 != 8);
    unint64_t v33 = ((8 * v32) >> 6) & 0x3FFFF;
    BOOL v34 = v33 == 29121 || v33 == 29127;
    if (v34) {
      int v29 = 99191;
    }
    else {
      int v29 = 99103;
    }
  }
  *(_DWORD *)(v11 + 40) = v29;
  *(_DWORD *)(v11 + 44) = 0;
  if ((resolveFields(v11, v15, v16, v17, v18, v19, v20, v21) & 0x80000000) != 0)
  {
    int v24 = "resolving output fields";
    __int16 v25 = 472;
    goto LABEL_10;
  }
  uint64_t result = writeMetadata();
  if ((result & 0x80000000) != 0)
  {
    int v24 = "writing metadata";
    __int16 v25 = 475;
    goto LABEL_10;
  }
  if (!*(_DWORD *)(v11 + 60))
  {
    int v24 = "metadata entry was not written";
    __int16 v25 = 482;
    goto LABEL_10;
  }
LABEL_6:
  uint64_t v22 = *(void *)(v11 + 8);
  int v23 = *(uint64_t (**)(void, _DWORD *, void))(v22 + 48);
  if (v23)
  {
    uint64_t result = v23(*(void *)(v22 + 56), a2 + 36, a2[1]);
    *(_DWORD *)(v11 + 76) = (int)result < 1;
    if ((int)result < 1) {
      return result;
    }
  }
  else if (*(_DWORD *)(v11 + 76))
  {
    return result;
  }
  unsigned int v35 = *(_DWORD *)(v11 + 96);
  if (*(void *)(v11 + 2296))
  {
    uint64_t v36 = 0;
    unint64_t v37 = 0;
    uint64_t v38 = 0;
    unsigned int v39 = 0;
    LOWORD(v40) = 0;
    while (1)
    {
      unint64_t v41 = (const char *)(*(void *)(v11 + 2304) + v36);
      *(_DWORD *)uint64_t v67 = 0;
      uint64_t result = yaa_parseFields(v41, 0, v67);
      int v42 = *(_DWORD *)v67;
      if (*(_DWORD *)v67)
      {
        if ((*(_DWORD *)(v11 + 52) & *(_DWORD *)v67) != 0) {
          goto LABEL_35;
        }
      }
      else if (*(_DWORD *)(*(void *)(v11 + 8) + 20))
      {
LABEL_35:
        if (v37 != v38) {
          uint64_t result = (uint64_t)memcpy((void *)(*(void *)(v11 + 2304) + 1032 * v38), (const void *)(*(void *)(v11 + 2304) + v36), 0x408uLL);
        }
        ++v38;
      }
      int v40 = v42 | v39 | (unsigned __int16)v40;
      unsigned int v39 = v40 & 0xFFFF0000;
      ++v37;
      v36 += 1032;
      if (v37 >= *(void *)(v11 + 2296))
      {
        __int16 v43 = v40;
        goto LABEL_42;
      }
    }
  }
  __int16 v43 = 0;
  LOWORD(v39) = 0;
  uint64_t v38 = 0;
LABEL_42:
  int v44 = 0;
  *(void *)(v11 + 2296) = v38;
  int v45 = *(_DWORD *)(v11 + 48);
  *(_DWORD *)(v11 + 96) = v45 & v35;
  int v46 = v45 & 0x2000;
  if ((v35 & 0x2200) != 0x200) {
    int v46 = 512;
  }
  if ((v35 & 0x4200) == 0x200) {
    int v47 = v45 & 0x4000;
  }
  else {
    int v47 = 512;
  }
  if ((v35 & 0x1200) == 0x200) {
    int v48 = v45 & 0x1000;
  }
  else {
    int v48 = 512;
  }
  int v49 = (v35 >> 7) & 1;
  if ((v35 & 0x200) == 0) {
    int v49 = 1;
  }
  BOOL v34 = v49 == 0;
  int v50 = v45 & 0x80;
  if (!v34) {
    int v50 = 0;
  }
  if ((v43 & 8) == 0 && (v35 & 0x200) != 0) {
    int v44 = *(_WORD *)(v11 + 52) & 8;
  }
  int v51 = 0;
  unsigned int v52 = *(_DWORD *)(v11 + 84) & 0xFFFF8D7F | v46;
  int v53 = v47 | v48;
  int v54 = *(_WORD *)(v11 + 88) & 0xFFE7 | v44;
  if ((v43 & 0x10) == 0 && (v35 & 0x200) != 0) {
    int v51 = *(_WORD *)(v11 + 52) & 0x10;
  }
  int v55 = v52 | v53;
  unsigned int v56 = v51 | v54;
  if ((v43 & 0x100) != 0 || (v35 & 0x200) == 0)
  {
    int v58 = (v35 >> 9) & 1;
    if ((v43 & 0x10) != 0) {
      int v59 = (v35 >> 9) & 1;
    }
    else {
      int v59 = 1;
    }
    LOWORD(v56) = v56 & 0xFEFF;
    if ((v35 & 0x80) == 0) {
      int v59 = 1;
    }
    int v57 = v45 & 0x200;
    if (v59) {
      int v57 = 0;
    }
  }
  else
  {
    int v57 = 0;
    unsigned int v56 = v56 & 0xFFFFFEFF | ((HIBYTE(*(unsigned __int16 *)(v11 + 52)) & 1) << 8);
    LOBYTE(v58) = 1;
  }
  *(_WORD *)(v11 + 88) = v56;
  *(_DWORD *)(v11 + 84) = v57 | v50 | v55 & 0xFFFFFD7F;
  if (**(int **)(v11 + 8) >= 3)
  {
    bzero(v67, 0x400uLL);
    bzero(v66, 0x400uLL);
    yaa_serializeFields(v67, 0x400uLL, v35, v39 | v43);
    yaa_serializeFields(v66, 0x400uLL, *(_DWORD *)(v11 + 84), *(_DWORD *)(v11 + 88));
    uint64_t result = fprintf((FILE *)*MEMORY[0x263EF8348], "%s: generating %s -> %s\n", (const char *)(v11 + 240), v67, v66);
  }
  if ((v43 & 2) == 0
    && (*(_WORD *)(v11 + 52) & 2) != 0
    && (uint64_t result = insertUINTField(v11, v12), (result & 0x80000000) != 0))
  {
    uint64_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"convertBegin", 544, 62, 0, "inserting IDX", v60, v61, v65);
    if (!*(_DWORD *)(v11 + 56))
    {
      *(_DWORD *)(v11 + 56) = 1;
      uint64_t v63 = *(void *)(v11 + 8);
      uint64_t v64 = *(uint64_t (**)(void))(v63 + 32);
      if (v64) {
        return v64(*(void *)(v63 + 40));
      }
    }
  }
  else
  {
    if ((*(unsigned char *)(v11 + 40) & 0x80) != 0) {
      char v62 = v58;
    }
    else {
      char v62 = 1;
    }
    if ((v62 & 1) == 0) {
      *(void *)(v11 + 160) = *(void *)(v11 + 136);
    }
  }
  return result;
}

void convertEnd(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 56) || *(_DWORD *)(a1 + 76)) {
    return;
  }
  if (*(_DWORD *)(a1 + 72))
  {
    if ((reserveBlobPayload(a1, 1) & 0x80000000) != 0)
    {
      uint64_t v17 = "allocating blob buffer";
      __int16 v18 = 561;
      goto LABEL_22;
    }
    uint64_t DataPtr = (const char *)MemBufferGetDataPtr(*(void *)(a1 + 2856));
    DataPtr[MemBufferGetDataSize(*(void *)(a1 + 2856))] = 0;
    if ((yaa_parseFields(DataPtr, (_DWORD *)(a1 + 40), (_WORD *)(a1 + 44)) & 0x80000000) != 0)
    {
      uint64_t v17 = "parsing YAF blob";
      __int16 v18 = 565;
      goto LABEL_22;
    }
    if ((resolveFields(a1, v12, v13, v14, v15, v16, v9, v10) & 0x80000000) != 0)
    {
      uint64_t v17 = "resolving output fields";
      __int16 v18 = 568;
      goto LABEL_22;
    }
    if ((writeMetadata() & 0x80000000) != 0)
    {
      uint64_t v17 = "writing metadata";
      __int16 v18 = 571;
      goto LABEL_22;
    }
    return;
  }
  int v19 = *(_DWORD *)(a1 + 84);
  if ((v19 & 0x200) != 0 && *(void *)(a1 + 16))
  {
    v19 &= ~0x200u;
    *(_DWORD *)(a1 + 84) = v19;
    *(_DWORD *)(a1 + 96) |= 0x200u;
    int v20 = 1;
  }
  else
  {
    int v20 = 0;
  }
  if (*(_DWORD *)(a1 + 80))
  {
    uint64_t v21 = "writing entry header twice";
    __int16 v22 = 368;
LABEL_20:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"writeHeader", v22, 62, 0, v21, a7, a8, v52);
    uint64_t v17 = "writing entry header";
    __int16 v18 = 587;
    goto LABEL_22;
  }
  if (v19 || *(_DWORD *)(a1 + 88))
  {
    uint64_t v21 = "writing header before all required fields are updated";
    __int16 v22 = 369;
    goto LABEL_20;
  }
  if ((ParallelArchiveWriteEntryHeader(*(void *)a1, a1 + 96, *(void *)(a1 + 2304), *(void *)(a1 + 2296), a5, a6, a7, a8) & 0x80000000) != 0)
  {
    uint64_t v21 = "writing entry header";
    __int16 v22 = 373;
    goto LABEL_20;
  }
  *(_DWORD *)(a1 + 80) = 1;
  if (v20)
  {
    if (*(void *)(a1 + 2584)) {
      uint64_t v26 = (char *)(a1 + 2328);
    }
    else {
      uint64_t v26 = 0;
    }
    unint64_t v27 = *(void *)(a1 + 160);
    uint64_t v28 = ParallelArchiveDBReadRequestOpenWithSet(*(uint64_t **)(a1 + 16), v26, a1 + 2592, *(void *)(a1 + 2848), 0, v27, 0, a8);
    *(void *)(a1 + 2312) = v28;
    if (!v28)
    {
      uint64_t v17 = "opening read request from database";
      __int16 v18 = 597;
      goto LABEL_22;
    }
    uint64_t v29 = MemBufferTransmit(*(unint64_t **)(a1 + 32), v27, (size_t (*)(int, void *, size_t))readFromDBProc, a1, (uint64_t (*)(uint64_t, uint64_t, uint64_t))archiveWriterProc, a1, v9, v10);
    if (v29 < 0 || v29 != v27)
    {
      uint64_t v17 = "readining from database";
      __int16 v18 = 600;
      goto LABEL_22;
    }
    ParallelArchiveDBRequestClose(*(void **)(a1 + 2312));
    *(void *)(a1 + 2312) = 0;
  }
  if (MemBufferGetDataSize(*(void *)(a1 + 2856)))
  {
    uint64_t v33 = MemBufferGetDataPtr(*(void *)(a1 + 2856));
    unint64_t DataSize = MemBufferGetDataSize(*(void *)(a1 + 2856));
    if ((ParallelArchiveWriteEntryData(*(void *)a1, v33, DataSize, v35, v36, v37, v38, v39) & 0x80000000) != 0)
    {
      uint64_t v17 = "writing entry data BLOBS";
      __int16 v18 = 612;
      goto LABEL_22;
    }
  }
  if (!*(void *)(a1 + 2296))
  {
LABEL_55:
    OECCStreamDestroy(*(void ***)(a1 + 3096));
    *(void *)(a1 + 3096) = 0;
    return;
  }
  uint64_t v40 = 0;
  unint64_t v41 = 0;
  while (1)
  {
    __int16 v42 = *(_WORD *)(a1 + 92);
    if ((v42 & 8) != 0 && (*(_DWORD *)(*(void *)(a1 + 2304) + v40) & 0xDFDFDF) == 0x414459)
    {
      unint64_t v43 = *(void *)(a1 + 2584);
      if (v43)
      {
        if ((ParallelArchiveWriteEntryData(*(void *)a1, a1 + 2328, v43, v30, v31, v32, v9, v10) & 0x80000000) != 0)
        {
          uint64_t v17 = "writing entry data YDA";
          __int16 v18 = 620;
          goto LABEL_22;
        }
        goto LABEL_54;
      }
    }
    if ((v42 & 0x10) == 0) {
      break;
    }
    if ((*(_DWORD *)(*(void *)(a1 + 2304) + v40) & 0xDFDFDF) != 0x4B4459) {
      break;
    }
    unint64_t v44 = *(void *)(a1 + 2848);
    if (!v44) {
      break;
    }
    if ((ParallelArchiveWriteEntryData(*(void *)a1, a1 + 2592, v44, v30, v31, v32, v9, v10) & 0x80000000) != 0)
    {
      uint64_t v17 = "writing entry data YDK";
      __int16 v18 = 625;
      goto LABEL_22;
    }
LABEL_54:
    ++v41;
    v40 += 1032;
    if (v41 >= *(void *)(a1 + 2296)) {
      goto LABEL_55;
    }
  }
  if ((*(_WORD *)(a1 + 92) & 0x100) == 0) {
    goto LABEL_54;
  }
  if ((*(_DWORD *)(*(void *)(a1 + 2304) + v40) & 0xDFDFDF) != 0x434559) {
    goto LABEL_54;
  }
  unint64_t v45 = OECCStreamGetDataSize(*(void *)(a1 + 3096));
  uint64_t v46 = OECCStreamGetDataPtr(*(void *)(a1 + 3096));
  if ((ParallelArchiveWriteEntryData(*(void *)a1, v46, v45, v47, v48, v49, v50, v51) & 0x80000000) == 0) {
    goto LABEL_54;
  }
  uint64_t v17 = "writing entry data YEC";
  __int16 v18 = 632;
LABEL_22:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"convertEnd", v18, 62, 0, v17, v9, v10, v52);
  if (!*(_DWORD *)(a1 + 56))
  {
    *(_DWORD *)(a1 + 56) = 1;
    uint64_t v23 = *(void *)(a1 + 8);
    int v24 = *(void (**)(uint64_t))(v23 + 32);
    if (v24)
    {
      uint64_t v25 = *(void *)(v23 + 40);
      v24(v25);
    }
  }
}

uint64_t convertBlob(uint64_t result, __int16 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(result + 56)) {
    return result;
  }
  uint64_t v8 = result;
  if (*(_DWORD *)(result + 76)) {
    return result;
  }
  *(_DWORD *)(result + 2868) = 0;
  __int16 v10 = *a2;
  *(unsigned char *)(result + 2866) = *((unsigned char *)a2 + 2);
  *(_WORD *)(result + 2864) = v10;
  *(unsigned char *)(result + 2867) = 0;
  *(void *)(result + 2872) = a3;
  int v11 = *(_DWORD *)(result + 2864);
  int v12 = v11 & 0xDFDFDF;
  if (*(_DWORD *)(result + 72))
  {
    if (v12 != 4604249) {
      return result;
    }
    uint64_t result = reserveBlobPayload(result, a3 + 1);
    if ((result & 0x80000000) == 0)
    {
      *(_DWORD *)(v8 + 2868) = 1;
      return result;
    }
    uint64_t v17 = "allocating blob buffer";
    __int16 v18 = 661;
    goto LABEL_48;
  }
  if (v12 == 4997953)
  {
    char v13 = 11;
LABEL_12:
    int v14 = *(_DWORD *)(result + 48) >> v13;
    *(_DWORD *)(result + 2868) = v14 & 1;
    if ((v14 & 1) == 0) {
      goto LABEL_23;
    }
    goto LABEL_21;
  }
  if (v12 == 5521752)
  {
    char v13 = 10;
    goto LABEL_12;
  }
  uint64_t v15 = *(void *)(result + 2296);
  if (!v15) {
    goto LABEL_23;
  }
  uint64_t v16 = *(_DWORD **)(result + 2304);
  while (((*v16 ^ v11) & 0xDFDFDF) != 0)
  {
    v16 += 258;
    if (!--v15) {
      goto LABEL_23;
    }
  }
  *(_DWORD *)(result + 2868) = 1;
LABEL_21:
  uint64_t result = reserveBlobPayload(result, a3);
  if ((result & 0x80000000) != 0)
  {
    uint64_t v17 = "allocating blob buffer";
    __int16 v18 = 683;
LABEL_48:
    uint64_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"convertBlob", v18, 62, 0, v17, a7, a8, v29);
    if (!*(_DWORD *)(v8 + 56))
    {
      *(_DWORD *)(v8 + 56) = 1;
      uint64_t v26 = *(void *)(v8 + 8);
      unint64_t v27 = *(uint64_t (**)(uint64_t))(v26 + 32);
      if (v27)
      {
        uint64_t v28 = *(void *)(v26 + 40);
        return v27(v28);
      }
    }
    return result;
  }
  int v11 = *(_DWORD *)(v8 + 2864);
LABEL_23:
  int v19 = v11 & 0xDFDFDF;
  switch(v19)
  {
    case 5521732:
      int v20 = *(_DWORD *)(v8 + 84);
      if ((v20 & 0x80) != 0)
      {
        *(_DWORD *)(v8 + 96) |= 0x80u;
        *(void *)(v8 + 136) = a3;
      }
      LOWORD(v21) = v20 & 0xFF7F;
      *(_DWORD *)(v8 + 84) = v20 & 0xFFFFFF7F;
      if ((v20 & 0x2000) != 0)
      {
        uint64_t result = CC_SHA1_Deprecated_Init((CC_SHA1_CTX *)(v8 + 2880));
        int v21 = *(_DWORD *)(v8 + 84);
        if ((v21 & 0x4000) == 0)
        {
LABEL_31:
          if ((v21 & 0x1000) == 0) {
            goto LABEL_33;
          }
          goto LABEL_32;
        }
      }
      else if ((v20 & 0x4000) == 0)
      {
        goto LABEL_31;
      }
      uint64_t result = CC_SHA256_Init((CC_SHA256_CTX *)(v8 + 2976));
      if ((*(_DWORD *)(v8 + 84) & 0x1000) == 0)
      {
LABEL_33:
        __int16 v22 = *(_WORD *)(v8 + 88);
        if ((v22 & 0x100) != 0)
        {
          uint64_t result = (uint64_t)OECCStreamCreate(1, 0x4000u, a3);
          *(void *)(v8 + 3096) = result;
          if (!result)
          {
            int v24 = "creating ECC context to get YEC";
            __int16 v25 = 228;
LABEL_47:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"processDATBegin", v25, 62, 0, v24, a7, a8, v29);
            uint64_t v17 = "processing DAT begin";
            __int16 v18 = 693;
            goto LABEL_48;
          }
          __int16 v22 = *(_WORD *)(v8 + 88);
        }
        if ((v22 & 0x18) == 0) {
          return result;
        }
        uint64_t v23 = *(void *)(v8 + 24);
        if (v23)
        {
          uint64_t result = (uint64_t)ParallelArchiveDBRequestOpenForWriting(v23, *(void *)(v8 + 160), 0);
          *(void *)(v8 + 2320) = result;
          if (result) {
            return result;
          }
          int v24 = "creating database write request";
          __int16 v25 = 236;
        }
        else
        {
          int v24 = "can't connect to database to get YDA YDK";
          __int16 v25 = 234;
        }
        goto LABEL_47;
      }
LABEL_32:
      uint64_t result = CC_CKSUM_Init(v8 + 3080);
      goto LABEL_33;
    case 4932697:
      *(void *)(v8 + 2848) = 0;
      break;
    case 4277337:
      *(void *)(v8 + 2584) = 0;
      break;
  }
  return result;
}

uint64_t convertPayload(uint64_t result, void *__src, size_t __n, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(result + 56)) {
    return result;
  }
  uint64_t v9 = result;
  *(void *)(result + 64) += __n;
  if (*(_DWORD *)(result + 76)) {
    return result;
  }
  *(void *)(result + 2872) -= __n;
  if (*(_DWORD *)(result + 2868)
    && (uint64_t result = MemBufferFillFromBuffer(*(unint64_t **)(result + 2856), __n, __src), result < 0))
  {
    uint64_t v15 = "storing blob data";
    __int16 v16 = 710;
  }
  else
  {
    if (*(_DWORD *)(v9 + 72)) {
      return result;
    }
    int v11 = *(_DWORD *)(v9 + 2864) & 0xDFDFDF;
    switch(v11)
    {
      case 4277337:
        uint64_t v20 = *(void *)(v9 + 2584);
        if (__n + v20 - 256 > 0xFFFFFFFFFFFFFEFELL)
        {
          uint64_t result = (uint64_t)memcpy((void *)(v9 + 2328 + v20), __src, __n);
          size_t v22 = *(void *)(v9 + 2584) + __n;
          *(void *)(v9 + 2584) = v22;
          *(unsigned char *)(v9 + 2328 + v22) = 0;
          goto LABEL_30;
        }
        uint64_t v15 = "YDA payload is too large";
        __int16 v16 = 727;
        break;
      case 4932697:
        uint64_t v21 = *(void *)(v9 + 2848);
        if (v21 + __n < 0x101)
        {
          uint64_t result = (uint64_t)memcpy((void *)(v9 + v21 + 2592), __src, __n);
          *(void *)(v9 + 2848) += __n;
          goto LABEL_30;
        }
        uint64_t v15 = "YDK payload is too large";
        __int16 v16 = 734;
        break;
      case 5521732:
        uint64_t result = *(void *)(v9 + 2320);
        if (result)
        {
          uint64_t result = ParallelArchiveDBRequestWrite((void *)result);
          if (result < 0)
          {
            char v13 = "writing data to database request";
            __int16 v14 = 248;
            goto LABEL_38;
          }
        }
        int v12 = *(_DWORD *)(v9 + 84);
        if ((v12 & 0x2000) != 0)
        {
          uint64_t result = CC_SHA1_Deprecated_Update((CC_SHA1_CTX *)(v9 + 2880), __src, __n);
          int v12 = *(_DWORD *)(v9 + 84);
          if ((v12 & 0x4000) == 0)
          {
LABEL_13:
            if ((v12 & 0x1000) == 0)
            {
LABEL_15:
              if ((*(_WORD *)(v9 + 88) & 0x100) != 0)
              {
                uint64_t result = OECCStreamWrite(*(void *)(v9 + 3096), (char *)__src, __n, a4, a5, a6, a7, a8);
                if (result < 0)
                {
                  char v13 = "writing data to ECC stream";
                  __int16 v14 = 258;
LABEL_38:
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"processDATPayload", v14, 62, 0, v13, a7, a8, v23);
                  uint64_t v15 = "processing DAT payload";
                  __int16 v16 = 723;
                  break;
                }
              }
LABEL_30:
              if ((*(_DWORD *)(v9 + 2864) & 0xDFDFDF) != 0x544144) {
                return result;
              }
              if (*(void *)(v9 + 2872)) {
                return result;
              }
              uint64_t result = processDATEnd(v9);
              if ((result & 0x80000000) == 0) {
                return result;
              }
              uint64_t v15 = "processing DAT end";
              __int16 v16 = 742;
              break;
            }
LABEL_14:
            uint64_t result = CC_CKSUM_Update(v9 + 3080, (unsigned __int8 *)__src, __n);
            goto LABEL_15;
          }
        }
        else if ((v12 & 0x4000) == 0)
        {
          goto LABEL_13;
        }
        uint64_t result = CC_SHA256_Update((CC_SHA256_CTX *)(v9 + 2976), __src, __n);
        if ((*(_DWORD *)(v9 + 84) & 0x1000) == 0) {
          goto LABEL_15;
        }
        goto LABEL_14;
      default:
        goto LABEL_30;
    }
  }
  uint64_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"convertPayload", v16, 62, 0, v15, a7, a8, v23);
  if (!*(_DWORD *)(v9 + 56))
  {
    *(_DWORD *)(v9 + 56) = 1;
    uint64_t v17 = *(void *)(v9 + 8);
    __int16 v18 = *(uint64_t (**)(uint64_t))(v17 + 32);
    if (v18)
    {
      uint64_t v19 = *(void *)(v17 + 40);
      return v18(v19);
    }
  }
  return result;
}

uint64_t convertPadding(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (!*(_DWORD *)(result + 56)) {
    *(void *)(result + 64) += a3;
  }
  return result;
}

uint64_t reserveExtraFields(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 2288) > a2) {
    return 0;
  }
  *(void *)(a1 + 2288) = a2 + 8;
  uint64_t v3 = reallocf(*(void **)(a1 + 2304), 1032 * (a2 + 8));
  *(void *)(a1 + 2304) = v3;
  if (v3) {
    return 0;
  }
  unint64_t v5 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"reserveExtraFields", 98, 62, *v5, "malloc", v6, v7, v8);
  return 0xFFFFFFFFLL;
}

uint64_t resolveFields(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a1 + 8);
  int v10 = *(_DWORD *)(v9 + 12);
  int v11 = *(unsigned __int16 *)(v9 + 16);
  unsigned int v12 = *(_DWORD *)(a1 + 40);
  int v13 = *(_DWORD *)(a1 + 44);
  int v14 = v12 & v10;
  int v15 = v11 | (*(unsigned __int16 *)(v9 + 18) << 16);
  *(_DWORD *)(a1 + 48) = v12 & v10;
  *(_DWORD *)(a1 + 52) = v13 & v15;
  __int16 v16 = v13 & v15 & 0xFFFD | v11 & 2;
  *(_WORD *)(a1 + 52) = v16;
  int v17 = (v12 >> 9) & 1;
  BOOL v18 = (v12 & 0x80) == 0;
  if ((v13 & 0x10) == 0) {
    BOOL v18 = 1;
  }
  if (!v18) {
    int v17 = 1;
  }
  int v19 = 0;
  if ((v10 & 0x1000) != 0 && (v12 & 0x1000) == 0 && v17)
  {
    v14 |= 0x1000u;
    *(_DWORD *)(a1 + 48) = v14;
    int v19 = 1;
  }
  if ((v10 & 0x2000) != 0 && (v12 & 0x2000) == 0 && v17)
  {
    v14 |= 0x2000u;
    *(_DWORD *)(a1 + 48) = v14;
    int v19 = 1;
  }
  if ((v10 & 0x4000) != 0 && (v12 & 0x4000) == 0 && v17)
  {
    v14 |= 0x4000u;
    *(_DWORD *)(a1 + 48) = v14;
    int v19 = 1;
  }
  if ((v10 & 0x80) != 0 && (v12 & 0x80) == 0 && v17)
  {
    v14 |= 0x80u;
    *(_DWORD *)(a1 + 48) = v14;
    int v19 = 1;
  }
  if ((v11 & 0x10) != 0 && v17 && (v13 & 0x10) == 0)
  {
    v16 |= 0x10u;
    *(_WORD *)(a1 + 52) = v16;
    int v19 = 1;
  }
  if ((v11 & 0x100) != 0 && v17 && (v13 & 0x100) == 0)
  {
    *(_WORD *)(a1 + 52) = v16 | 0x100;
    int v19 = 1;
  }
  if ((v10 & 0x200) != 0 && (v12 & 0x200) == 0 && v17)
  {
    v14 |= 0x200u;
    *(_DWORD *)(a1 + 48) = v14;
  }
  if (v19 && (v14 & 0x200) != 0)
  {
    size_t v22 = "Can't write DAT-based field and DAT itself at the same time";
    __int16 v23 = 142;
LABEL_42:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"resolveFields", v23, 62, 0, v22, a7, a8, v31);
    return 0xFFFFFFFFLL;
  }
  if ((v12 & 0x200) == 0 && (v14 & 0x200) != 0)
  {
    if (v18 || (size_t v25 = *(void *)(v9 + 64)) == 0)
    {
      *(_DWORD *)(a1 + 48) = v14 & 0xFFFFFDFF;
    }
    else
    {
      uint64_t v26 = ParallelArchiveDBSetCreate(v25, *(void *)(v9 + 72), 0, a4, a5, a6, a7, a8);
      *(void *)(a1 + 16) = v26;
      if (!v26)
      {
        size_t v22 = "connecting to database";
        __int16 v23 = 152;
        goto LABEL_42;
      }
      if (**(int **)(a1 + 8) >= 1) {
        fwrite("Reading DAT blobs from database\n", 0x20uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
      }
    }
  }
  __int16 v27 = *(_WORD *)(a1 + 52);
  if ((v27 & 0x10) != 0 && (*(_WORD *)(a1 + 44) & 0x10) == 0)
  {
    if ((*(unsigned char *)(a1 + 41) & 2) != 0 && (uint64_t v28 = *(void *)(a1 + 8), *(void *)(v28 + 64) == 1))
    {
      char v29 = ParallelArchiveDBSessionCreate(**(char ***)(v28 + 72), (void *)(a1 + 2328), 0x100uLL, 0);
      *(void *)(a1 + 24) = v29;
      if (!v29)
      {
        size_t v22 = "connecting to database";
        __int16 v23 = 164;
        goto LABEL_42;
      }
      *(void *)(a1 + 2584) = strlen((const char *)(a1 + 2328));
      if (**(int **)(a1 + 8) >= 1) {
        fwrite("Writing DAT blobs to database\n", 0x1EuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
      }
    }
    else
    {
      *(_WORD *)(a1 + 52) = v27 & 0xFFEF;
    }
  }
  *(_WORD *)(a1 + 52) = (*(_WORD *)(a1 + 52) >> 1) & 8 | *(_WORD *)(a1 + 52) & 0xFFF7;
  if (**(int **)(a1 + 8) >= 1)
  {
    bzero(v32, 0x400uLL);
    yaa_serializeFields(v32, 0x400uLL, *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 44));
    uint64_t v30 = (FILE **)MEMORY[0x263EF8348];
    fprintf((FILE *)*MEMORY[0x263EF8348], "Input fields:          %s\n", v32);
    yaa_serializeFields(v32, 0x400uLL, v10, v15);
    fprintf(*v30, "Allowed output fields: %s\n", v32);
    yaa_serializeFields(v32, 0x400uLL, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52));
    fprintf(*v30, "Output fields:         %s\n", v32);
  }
  return 0;
}

uint64_t writeMetadata()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  v20[273] = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(v0 + 60))
  {
    uint64_t v3 = "writing archive metadata twice";
    __int16 v4 = 334;
  }
  else
  {
    uint64_t v6 = v0;
    bzero(v15, 0x400uLL);
    if ((yaa_serializeFields(v15, 0x400uLL, *(_DWORD *)(v6 + 48), *(_DWORD *)(v6 + 52)) & 0x80000000) != 0)
    {
      uint64_t v3 = "serializing YAF entry";
      __int16 v4 = 342;
    }
    else
    {
      unint64_t v7 = strlen(v15) + 1;
      bzero(v20, 0x888uLL);
      uint64_t v19 = 0x4D00000001;
      bzero(v17, 0x405uLL);
      qmemcpy(v16, "YAF", sizeof(v16));
      *(_DWORD *)&v17[1] = 2;
      unint64_t v18 = v7;
      if ((ParallelArchiveWriteEntryHeader(*(void *)v6, (uint64_t)&v19, (uint64_t)v16, 1, v8, v9, v10, v11) & 0x80000000) != 0)
      {
        uint64_t v3 = "writing metadata entry header";
        __int16 v4 = 356;
      }
      else
      {
        if ((ParallelArchiveWriteEntryData(*(void *)v6, (uint64_t)v15, v7, v12, v13, v14, v1, v2) & 0x80000000) == 0)
        {
          uint64_t result = 0;
          *(_DWORD *)(v6 + 60) = 1;
          return result;
        }
        uint64_t v3 = "writing metadata entry blob";
        __int16 v4 = 357;
      }
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"writeMetadata", v4, 62, 0, v3, v1, v2, v15[0]);
  return 0xFFFFFFFFLL;
}

uint64_t insertUINTField(uint64_t a1, uint64_t a2)
{
  if ((reserveExtraFields(a1, *(void *)(a1 + 2296) + 1) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"insertUINTField", 191, 62, 0, "reserving extra fields", v4, v5, v8);
    return 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v6 = (_WORD *)(*(void *)(a1 + 2304) + 1032 * *(void *)(a1 + 2296));
    bzero(v6, 0x408uLL);
    uint64_t result = 0;
    *((_DWORD *)v6 + 1) = 1;
    _WORD *v6 = 17481;
    *((unsigned char *)v6 + 2) = 88;
    *((void *)v6 + 1) = a2;
    ++*(void *)(a1 + 2296);
  }
  return result;
}

uint64_t reserveBlobPayload(uint64_t a1, uint64_t a2)
{
  uint64_t DataSize = MemBufferGetDataSize(*(void *)(a1 + 2856));
  if (__CFADD__(DataSize, a2))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"reserveBlobPayload", 106, 62, 0, "invalid blob size: %llu", v5, v6, a2);
  }
  else
  {
    unint64_t v7 = MemBufferIncreaseCapacity(*(void *)(a1 + 2856), DataSize + a2);
    if ((v7 & 0x8000000000000000) == 0) {
      return 0;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"reserveBlobPayload", 107, 62, 0, "resize blob buffer", v8, v9, v11);
  }
  return 0xFFFFFFFFLL;
}

uint64_t readFromDBProc(uint64_t a1)
{
  return ParallelArchiveDBRequestRead(*(void **)(a1 + 2312));
}

unint64_t archiveWriterProc(uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  LODWORD(result) = ParallelArchiveWriteEntryData(*a1, a2, a3, a4, a5, a6, a7, a8);
  if ((result & 0x80000000) == 0) {
    return a3;
  }
  else {
    return (int)result;
  }
}

uint64_t processDATEnd(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 84);
  if ((v2 & 0x2000) != 0)
  {
    *(_DWORD *)(a1 + 96) |= 0x2000u;
    CC_SHA1_Deprecated_Final((unsigned __int8 *)(a1 + 188), (CC_SHA1_CTX *)(a1 + 2880));
    int v2 = *(_DWORD *)(a1 + 84);
  }
  unsigned int v3 = v2 & 0xFFFFDFFF;
  *(_DWORD *)(a1 + 84) = v2 & 0xFFFFDFFF;
  if ((v2 & 0x4000) != 0)
  {
    *(_DWORD *)(a1 + 96) |= 0x4000u;
    CC_SHA256_Final((unsigned __int8 *)(a1 + 208), (CC_SHA256_CTX *)(a1 + 2976));
    unsigned int v3 = *(_DWORD *)(a1 + 84);
  }
  unsigned int v4 = v3 & 0xFFFFBFFF;
  *(_DWORD *)(a1 + 84) = v3 & 0xFFFFBFFF;
  if ((v3 & 0x1000) != 0)
  {
    *(_DWORD *)(a1 + 96) |= 0x1000u;
    CC_CKSUM_Final((unsigned int *)(a1 + 184), a1 + 3080);
    unsigned int v4 = *(_DWORD *)(a1 + 84);
  }
  *(_DWORD *)(a1 + 84) = v4 & 0xFFFFEFFF;
  __int16 v5 = *(_WORD *)(a1 + 88);
  if ((v5 & 0x100) != 0)
  {
    uint64_t DataSize = OECCStreamGetDataSize(*(void *)(a1 + 3096));
    if ((insertBLOBField(a1, (__int16 *)"YEC", DataSize) & 0x80000000) != 0)
    {
      uint64_t v13 = "inserting YEC";
      __int16 v14 = 295;
      goto LABEL_24;
    }
    *(_WORD *)(a1 + 92) |= 0x100u;
    __int16 v5 = *(_WORD *)(a1 + 88);
  }
  *(_WORD *)(a1 + 88) = v5 & 0xFEFF;
  uint64_t result = *(void *)(a1 + 2320);
  if (!result) {
    return result;
  }
  if ((ParallelArchiveDBRequestCloseAndGetKey((void *)result) & 0x80000000) != 0)
  {
    uint64_t v13 = "finalizing database write";
    __int16 v14 = 304;
  }
  else
  {
    *(void *)(a1 + 2320) = 0;
    __int16 v10 = *(_WORD *)(a1 + 88);
    if ((v10 & 0x10) != 0)
    {
      if ((insertBLOBField(a1, (__int16 *)"YDK", *(void *)(a1 + 2848)) & 0x80000000) != 0)
      {
        uint64_t v13 = "inserting YDK";
        __int16 v14 = 312;
        goto LABEL_24;
      }
      *(_WORD *)(a1 + 92) |= 0x10u;
      __int16 v10 = *(_WORD *)(a1 + 88);
    }
    __int16 v11 = v10 & 0xFFEF;
    *(_WORD *)(a1 + 88) = v10 & 0xFFEF;
    if ((v10 & 8) == 0) {
      goto LABEL_19;
    }
    uint64_t v12 = *(void *)(a1 + 2584);
    if (!v12) {
      goto LABEL_19;
    }
    if ((insertBLOBField(a1, (__int16 *)"YDA", v12) & 0x80000000) == 0)
    {
      *(_WORD *)(a1 + 92) |= 8u;
      __int16 v11 = *(_WORD *)(a1 + 88);
LABEL_19:
      uint64_t result = 0;
      *(_WORD *)(a1 + 88) = v11 & 0xFFF7;
      return result;
    }
    uint64_t v13 = "inserting YDA";
    __int16 v14 = 320;
  }
LABEL_24:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"processDATEnd", v14, 62, 0, v13, v7, v8, v15);
  return 0xFFFFFFFFLL;
}

uint64_t insertBLOBField(uint64_t a1, __int16 *a2, uint64_t a3)
{
  if ((reserveExtraFields(a1, *(void *)(a1 + 2296) + 1) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"insertBLOBField", 204, 62, 0, "reserving extra fields", v6, v7, v11);
    return 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v8 = (_WORD *)(*(void *)(a1 + 2304) + 1032 * *(void *)(a1 + 2296));
    bzero(v8, 0x408uLL);
    uint64_t result = 0;
    *((_DWORD *)v8 + 1) = 2;
    __int16 v10 = *a2;
    *((unsigned char *)v8 + 2) = *((unsigned char *)a2 + 2);
    *uint64_t v8 = v10;
    *((void *)v8 + 1) = a3;
    ++*(void *)(a1 + 2296);
  }
  return result;
}

_DWORD *ParallelCompressionFileOpen(const char *a1, char *__s, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v113 = *MEMORY[0x263EF8340];
  if (!a1 || !__s)
  {
    uint64_t v21 = "invalid args";
    __int16 v22 = 149;
LABEL_74:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", v22, 46, 0, v21, a7, a8, v97);
    return 0;
  }
  size_t v9 = strlen(__s);
  uint64_t v10 = 0;
  size_t v11 = 0;
  unint64_t __offseta = 0;
  unint64_t v103 = 0;
  uint64_t v105 = 0;
  int v106 = 0;
  int v12 = -1;
  uint64_t v13 = MEMORY[0x263EF8318];
  uint64_t v14 = -1;
  uint64_t v15 = -1;
  uint64_t v99 = -1;
  int v101 = -1;
  int DefaultNThreads = -1;
  int v104 = -1;
  while (1)
  {
    unsigned int v16 = __s[v11];
    if ((v16 & 0x80000000) != 0)
    {
      if (__maskrune(__s[v11], 0x4000uLL))
      {
LABEL_6:
        ++v11;
LABEL_7:
        int v17 = 4;
        goto LABEL_8;
      }
    }
    else if ((*(_DWORD *)(v13 + 4 * v16 + 60) & 0x4000) != 0)
    {
      goto LABEL_6;
    }
    if ((v12 & 0x80000000) == 0) {
      break;
    }
    uint64_t v18 = 1;
    switch(v16)
    {
      case 'o':
      case 's':
      case 't':
        goto LABEL_53;
      case 'p':
      case 'q':
      case 'u':
        goto LABEL_90;
      case 'r':
        ++HIDWORD(v105);
        goto LABEL_52;
      case 'v':
        LODWORD(v105) = v105 + 1;
        goto LABEL_52;
      case 'w':
        ++v106;
LABEL_52:
        uint64_t v18 = v10;
        goto LABEL_53;
      default:
        if (v16 - 97 >= 3)
        {
LABEL_90:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 190, 46, 0, "invalid option in mode: %s (was '%c')", a7, a8, (char)__s);
          return 0;
        }
LABEL_53:
        ++v11;
        int v17 = 4;
        uint64_t v10 = v18;
        int v12 = v16;
        break;
    }
LABEL_8:
    if (v17 != 4) {
      return 0;
    }
  }
  if (v15 == -1 && v10)
  {
    if (v16 != 61)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 199, 46, 0, "invalid option in mode: %s (%c requires an arg)", a7, a8, (char)__s);
      return 0;
    }
    uint64_t v15 = v11++;
    uint64_t v10 = 1;
    goto LABEL_7;
  }
  if (v14 == -1 && v10)
  {
    if (v12 == 97)
    {
      size_t v19 = v11 + 4;
      if (v11 + 4 > v9) {
        goto LABEL_24;
      }
      if (!strncmp(&__s[v11], "lzma", 4uLL))
      {
        uint64_t v14 = 1;
      }
      else if (!strncmp(&__s[v11], "zlib", 4uLL))
      {
        uint64_t v14 = 0;
      }
      else
      {
LABEL_24:
        size_t v19 = v11 + 5;
        if (v11 + 5 <= v9 && !strncmp(&__s[v11], "lzfse", 5uLL))
        {
          uint64_t v14 = 4;
        }
        else
        {
          size_t v19 = v11 + 8;
          if (v11 + 8 <= v9 && !strncmp(&__s[v11], "lzbitmap", 8uLL))
          {
            uint64_t v14 = 5;
          }
          else
          {
            size_t v19 = v11 + 3;
            if (v11 + 3 > v9 || (uint64_t v14 = 3, strncmp(&__s[v11], "lz4", 3uLL)))
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 214, 46, 0, "invalid compression algorithm in mode: %s", a7, a8, (char)__s);
              return 0;
            }
          }
        }
      }
      int v12 = 97;
      uint64_t v10 = 1;
      int v17 = 4;
      size_t v11 = v19;
      int v104 = v14;
      goto LABEL_8;
    }
    *(void *)&__endptr.st_dev = 0;
    unint64_t v20 = strtoull(&__s[v11], (char **)&__endptr, 10);
    if (*(char **)&__endptr.st_dev == &__s[v11] || (uint64_t v14 = v20, v20 == -1))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 223, 46, 0, "invalid argument for '%c' in mode: %s", a7, a8, v12);
      uint64_t v14 = -1;
      int v17 = 1;
    }
    else
    {
      size_t v11 = *(void *)&__endptr.st_dev - (void)__s;
      if (v12 == 98 && v11 < v9 && **(unsigned char **)&__endptr.st_dev == 109)
      {
        uint64_t v14 = v20 << 20;
        ++v11;
      }
      if (v12 == 98 && v11 < v9 && __s[v11] == 107)
      {
        v14 <<= 10;
        ++v11;
      }
      if (v12 == 98 && v11 < v9)
      {
        if (__s[v11] == 98) {
          ++v11;
        }
LABEL_49:
        int v17 = 4;
        unint64_t v103 = v14;
      }
      else
      {
        int v17 = 4;
        if (v12 > 110)
        {
          switch(v12)
          {
            case 'o':
              unint64_t __offseta = v14;
              break;
            case 's':
              uint64_t v99 = v14;
              break;
            case 't':
              if (v14) {
                int DefaultNThreads = v14;
              }
              else {
                int DefaultNThreads = getDefaultNThreads();
              }
              break;
          }
        }
        else
        {
          if (v12 == 98) {
            goto LABEL_49;
          }
          if (v12 == 99) {
            int v101 = v14;
          }
        }
      }
    }
    uint64_t v10 = 1;
    goto LABEL_8;
  }
  if (v16 == 44)
  {
    uint64_t v10 = 0;
    ++v11;
    int v12 = -1;
    uint64_t v14 = -1;
    int v17 = 4;
    uint64_t v15 = -1;
    goto LABEL_8;
  }
  if ((_BYTE)v16)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 252, 46, 0, "invalid character in mode: %s ('%c')", a7, a8, (char)__s);
    return 0;
  }
  int v26 = HIDWORD(v105);
  int v25 = v106;
  if (HIDWORD(v105) + v106 != 1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 256, 46, 0, "mode should specify either 'w' or 'r': %s", a7, a8, (char)__s);
    return 0;
  }
  if (HIDWORD(v105) && ((v104 & 0x80000000) == 0 || v103 || (DefaultNThreads & 0x80000000) == 0))
  {
    uint64_t v21 = "a,b,t options are invalid in read mode";
    __int16 v22 = 257;
    goto LABEL_74;
  }
  if (v106 && (v101 & 0x80000000) == 0)
  {
    uint64_t v21 = "c option is invalid in write mode";
    __int16 v22 = 258;
    goto LABEL_74;
  }
  if (v106 != 0 && v104 < 0) {
    unsigned int v27 = 4;
  }
  else {
    unsigned int v27 = v104;
  }
  if (v106 != 0 && v103 == 0) {
    unint64_t v28 = 0x800000;
  }
  else {
    unint64_t v28 = v103;
  }
  if (v106)
  {
    char v29 = a1;
    if (DefaultNThreads <= 0) {
      int DefaultNThreads = getDefaultNThreads();
    }
  }
  else
  {
    char v29 = a1;
  }
  if (v101 >= 1 || HIDWORD(v105) == 0) {
    int v31 = v101;
  }
  else {
    int v31 = 1;
  }
  if (HIDWORD(v105))
  {
    memset(&__endptr, 0, sizeof(__endptr));
    if (stat(v29, &__endptr))
    {
      int v34 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 270, 46, v34, "%s", v35, v36, (char)v29);
      return 0;
    }
    if ((__endptr.st_mode & 0xF000) != 0x8000)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 271, 46, 0, "%s must be an existing regular file", v32, v33, (char)v29);
      return 0;
    }
    if (__endptr.st_size <= __offseta)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 272, 46, 0, "invalid segment offset: %llu", v32, v33, __offseta);
      return 0;
    }
    unint64_t v37 = v99;
    if (v99 == -1)
    {
      unint64_t v37 = __endptr.st_size - __offseta;
    }
    else
    {
      if (__CFADD__(__offseta, v99))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 277, 46, 0, "invalid segment size: %llu", v32, v33, v99);
        return 0;
      }
      if (__offseta + v99 > __endptr.st_size)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 278, 46, 0, "invalid segment size: %llu", v32, v33, v99);
        return 0;
      }
    }
    uint64_t v99 = v37;
    if (v37 <= 0xB)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 283, 46, 0, "invalid segment size: %llu", v32, v33, v37);
      return 0;
    }
    char v29 = a1;
    int v26 = HIDWORD(v105);
    int v25 = v106;
  }
  uint64_t v38 = calloc(1uLL, 0x88uLL);
  __int16 v23 = v38;
  if (!v38)
  {
    uint64_t v51 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 287, 46, *v51, "malloc", v52, v53, v97);
    return v23;
  }
  *uint64_t v38 = v26 == 0;
  v38[1] = -1;
  v38[2] = v105;
  if (!v25)
  {
    int v54 = open(v29, 0);
    v23[1] = v54;
    if (v54 < 0)
    {
      int v63 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 316, 46, v63, "%s", v64, v65, (char)v29);
      goto LABEL_144;
    }
    if (pread(v54, &__buf, 0xCuLL, __offseta) != 12)
    {
      int v58 = "reading file header";
      __int16 v59 = 320;
      goto LABEL_142;
    }
    if (__buf != 25200 || v109 != 122)
    {
      int v58 = "invalid file header";
      __int16 v59 = 321;
      goto LABEL_142;
    }
    char v67 = v110;
    if (v110 <= 0x64u)
    {
      switch(v110)
      {
        case '-':
          unsigned int v68 = 6;
          goto LABEL_161;
        case '4':
          unsigned int v68 = 3;
          goto LABEL_161;
        case 'b':
          unsigned int v68 = 5;
          goto LABEL_161;
      }
    }
    else if (v110 > 0x77u)
    {
      if (v110 == 120)
      {
        unsigned int v68 = 1;
        goto LABEL_161;
      }
      if (v110 == 122)
      {
        unsigned int v68 = 0;
        goto LABEL_161;
      }
    }
    else
    {
      if (v110 == 101)
      {
        unsigned int v68 = 4;
        goto LABEL_161;
      }
      if (v110 == 102)
      {
        unsigned int v68 = 2;
LABEL_161:
        DecoderFilter = PCompressGetDecoderFilter(v68);
        *((void *)v23 + 3) = DecoderFilter;
        if (DecoderFilter)
        {
          *((void *)v23 + 5) = bswap64(v111);
          unint64_t v70 = __offseta + 12;
          unint64_t v71 = v99 + __offseta;
          if (__offseta + 12 < v99 + __offseta)
          {
            uint64_t v72 = 0;
            while (1)
            {
              if (v71 - v70 <= 0xF)
              {
                int v58 = "truncated block header";
                __int16 v59 = 347;
                goto LABEL_142;
              }
              if (pread(v23[1], &__endptr, 0x10uLL, v70) != 16)
              {
                char v97 = v70;
                int v58 = "reading block header at offset %llu";
                __int16 v59 = 348;
                goto LABEL_142;
              }
              unint64_t v73 = v70 + 16;
              int8x16_t v74 = vrev64q_s8(*(int8x16_t *)&__endptr.st_dev);
              unint64_t v75 = v71 - (v70 + 16);
              uint64_t v76 = v74.i64[1];
              if (v75 < v74.i64[1])
              {
                int v58 = "truncated block payload";
                __int16 v59 = 352;
                goto LABEL_142;
              }
              int8x16_t v107 = v74;
              uint64_t v77 = v74.i64[0];
              if (v74.i64[1] > (unint64_t)v74.i64[0] || v74.i64[0] > *((void *)v23 + 5))
              {
                int v58 = "corrupted file";
                __int16 v59 = 353;
                goto LABEL_142;
              }
              unint64_t v79 = *((void *)v23 + 6);
              unint64_t v80 = *((void *)v23 + 7);
              size_t v81 = (char *)*((void *)v23 + 8);
              if (v79 >= v80)
              {
                uint64_t v82 = v80 + (v80 >> 1);
                if (!v80) {
                  uint64_t v82 = 32;
                }
                *((void *)v23 + 7) = v82;
                size_t v81 = (char *)reallocf(v81, 40 * v82);
                *((void *)v23 + 8) = v81;
                if (!v81)
                {
                  int v66 = *__error();
                  int v58 = "malloc";
                  __int16 v59 = 361;
                  goto LABEL_143;
                }
                unint64_t v79 = *((void *)v23 + 6);
              }
              char v83 = (int8x16_t *)&v81[40 * v79];
              v83->i64[0] = v72;
              v83->i64[1] = v73;
              v83[1] = v107;
              v83[2].i64[0] = -1;
              unint64_t v70 = v76 + v73;
              if ((int)v105 <= 1)
              {
                v72 += v77;
              }
              else
              {
                uint64_t v84 = v77 + v72;
                fprintf((FILE *)*MEMORY[0x263EF8348], "block %zu: compressed:%llu..%llu raw:%llu..%llu\n", v79, v73, v70, v72, v84);
                unint64_t v79 = *((void *)v23 + 6);
                uint64_t v72 = v84;
              }
              *((void *)v23 + 6) = v79 + 1;
              if (v70 >= v71) {
                goto LABEL_183;
              }
            }
          }
          uint64_t v72 = 0;
LABEL_183:
          if (v70 == v71)
          {
            *((void *)v23 + 4) = v72;
            *((void *)v23 + 9) = v31;
            unint64_t v85 = *((void *)v23 + 5);
            if (is_mul_ok(v31, v85))
            {
              uint64_t v86 = malloc(v31 * v85);
              *((void *)v23 + 10) = v86;
              if (!v86)
              {
                int v66 = *__error();
                int v58 = "malloc";
                __int16 v59 = 392;
                goto LABEL_143;
              }
              unint64_t v87 = (char *)calloc(v31, 0x18uLL);
              *((void *)v23 + 11) = v87;
              if (v87)
              {
                uint64_t v88 = v87;
                uint64_t v89 = *((void *)v23 + 9);
                size_t v90 = *((void *)v23 + 5);
                if (v89)
                {
                  uint64_t v91 = *((void *)v23 + 10);
                  unsigned int v92 = v88 + 16;
                  do
                  {
                    *((_OWORD *)v92 - 1) = xmmword_2106D4500;
                    *unsigned int v92 = v91;
                    v92 += 3;
                    v91 += v90;
                    --v89;
                  }
                  while (v89);
                }
                unsigned int v93 = malloc(v90);
                *((void *)v23 + 12) = v93;
                if (v93)
                {
                  *((void *)v23 + 13) = 0;
                  *((void *)v23 + 14) = 0;
                  if ((int)v105 >= 1)
                  {
                    char v94 = (FILE **)MEMORY[0x263EF8348];
                    fprintf((FILE *)*MEMORY[0x263EF8348], "filename: %s\n", a1);
                    fwrite("mode: r\n", 8uLL, 1uLL, *v94);
                    uint64_t v95 = *v94;
                    DecoderDescription = PCompressGetDecoderDescription(v68);
                    fprintf(v95, "algorithm: %s\n", DecoderDescription);
                    fprintf(*v94, "payload segment: %llu [%llu]\n", __offseta, v99);
                    fprintf(*v94, "raw data size: %llu B\n", *((void *)v23 + 4));
                    fprintf(*v94, "blocks: %zu\n", *((void *)v23 + 6));
                    fprintf(*v94, "block size: %zu B\n", *((void *)v23 + 5));
                    fprintf(*v94, "cache size: %zu B (%d blocks)\n");
                  }
                  return v23;
                }
                int v66 = *__error();
                int v58 = "malloc";
                __int16 v59 = 405;
              }
              else
              {
                int v66 = *__error();
                int v58 = "malloc";
                __int16 v59 = 394;
              }
LABEL_143:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", v59, 46, v66, v58, v55, v56, v97);
              goto LABEL_144;
            }
            int v58 = "Invalid cache size";
            __int16 v59 = 390;
          }
          else
          {
            int v58 = "extra bytes found in file";
            __int16 v59 = 383;
          }
LABEL_142:
          int v66 = 0;
          goto LABEL_143;
        }
        char v67 = v110;
LABEL_188:
        char v97 = v67;
        int v58 = "unsupported decoder in file header: %c";
        __int16 v59 = 334;
        goto LABEL_142;
      }
    }
    *((void *)v23 + 3) = 0;
    goto LABEL_188;
  }
  int v39 = open(v29, 1537, 420);
  v23[1] = v39;
  if (v39 < 0)
  {
    int v60 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 297, 46, v60, "%s", v61, v62, (char)v29);
  }
  else
  {
    uint64_t v40 = OFileEncoderStreamCreateWithFD(v39, -1, v28, v27, v28, DefaultNThreads);
    *((void *)v23 + 2) = v40;
    if (v40)
    {
      if ((int)v105 >= 1)
      {
        uint64_t v48 = (FILE **)MEMORY[0x263EF8348];
        fprintf((FILE *)*MEMORY[0x263EF8348], "filename: %s\n", v29);
        fwrite("mode: w\n", 8uLL, 1uLL, *v48);
        uint64_t v49 = *v48;
        EncoderDescription = PCompressGetEncoderDescription(v27);
        fprintf(v49, "algorithm: %s\n", EncoderDescription);
        fprintf(*v48, "block size: %zu B\n", v28);
        fprintf(*v48, "n threads: %d\n");
      }
      return v23;
    }
  }
LABEL_144:
  ParallelCompressionFileClose(v23, v41, v42, v43, v44, v45, v46, v47);
  return 0;
}

uint64_t ParallelCompressionFileClose(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (!*(_DWORD *)a1 && *((int *)a1 + 2) >= 1)
    {
      size_t v9 = (FILE **)MEMORY[0x263EF8348];
      fprintf((FILE *)*MEMORY[0x263EF8348], "read: %llu B\n", *((void *)a1 + 15));
      fprintf(*v9, "decoded: %llu B\n", *((void *)a1 + 16));
      unint64_t v10 = *((void *)a1 + 15);
      if (v10) {
        fprintf(*v9, "decoded/read ratio: %.2f\n", (double)*((unint64_t *)a1 + 16) / (double)v10);
      }
    }
    uint64_t v11 = *((void *)a1 + 2);
    if (v11)
    {
      OFileEncoderStreamWrite(v11, 0, 0, a4, a5, a6, a7, a8);
      OFileEncoderStreamDestroy(*((void *)a1 + 2), v12, v13, v14, v15, v16, v17, v18);
    }
    int v19 = *((_DWORD *)a1 + 1);
    if ((v19 & 0x80000000) == 0) {
      close(v19);
    }
    free(*((void **)a1 + 8));
    free(*((void **)a1 + 10));
    free(*((void **)a1 + 11));
    free(*((void **)a1 + 12));
    free(a1);
  }
  return 0;
}

uint64_t ParallelCompressionFileSeek(uint64_t a1, unint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)a1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileSeek", 458, 46, 0, "invalid mode", a7, a8, vars0);
  }
  else
  {
    if (a3)
    {
      if (a3 == 2)
      {
        size_t v9 = (void *)(a1 + 32);
      }
      else
      {
        if (a3 != 1) {
          return -1;
        }
        size_t v9 = (void *)(a1 + 104);
      }
      a2 += *v9;
    }
    if ((a2 & 0x8000000000000000) == 0 && a2 <= *(void *)(a1 + 32))
    {
      *(void *)(a1 + 104) = a2;
      return a2;
    }
  }
  return -1;
}

uint64_t ParallelCompressionFileWrite(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)a1 != 1) {
    return -1;
  }
  if (!a3) {
    return 0;
  }
  uint64_t result = OFileEncoderStreamWrite(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
  if (result < 0) {
    return -1;
  }
  return result;
}

uint64_t ParallelCompressionFileRead(uint64_t a1, char *__dst, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_DWORD *)a1)
  {
    size_t v9 = a3;
    ++*(void *)(a1 + 112);
    if (!a3) {
      return 0;
    }
    unint64_t v11 = *(void *)(a1 + 104);
    if (v11 >= *(void *)(a1 + 32)) {
      return 0;
    }
    uint64_t v13 = *(void *)(a1 + 48);
    if (v13)
    {
      uint64_t v14 = *(void *)(a1 + 64);
      if (*(void *)(v14 + 16) > v11)
      {
        unint64_t v15 = 0;
        goto LABEL_20;
      }
      unint64_t v17 = v13 - 1;
      if (*(void *)(v14 + 40 * v17) <= v11)
      {
        unint64_t v15 = v17;
        goto LABEL_20;
      }
      unint64_t v18 = 0;
      while (1)
      {
        unint64_t v15 = v17;
        do
        {
          if (v18 >= v15)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"locateBlock", 78, 46, 0, "locateBlock failed", a7, a8, v50);
            goto LABEL_19;
          }
          unint64_t v17 = v15;
          unint64_t v15 = (v15 + v18) >> 1;
          unint64_t v19 = *(void *)(v14 + 40 * v15);
        }
        while (v19 > v11);
        unint64_t v18 = v15;
        if (*(void *)(v14 + 40 * v15 + 16) + v19 > v11)
        {
LABEL_20:
          uint64_t v8 = 0;
          unint64_t v20 = (FILE **)MEMORY[0x263EF8348];
          while (1)
          {
            if (v15 >= *(void *)(a1 + 48)) {
              return v8;
            }
            uint64_t v21 = *(void *)(a1 + 64);
            unint64_t v22 = *(void *)(v21 + 40 * v15 + 32);
            if (v22 != -1)
            {
              uint64_t v23 = *(void *)(a1 + 88);
              *(void *)(v23 + 24 * v22 + 8) = *(void *)(a1 + 112);
              goto LABEL_44;
            }
            uint64_t v24 = *(void *)(a1 + 72);
            uint64_t v25 = *(void *)(a1 + 88);
            if (v24)
            {
              unint64_t v26 = 0;
              unsigned int v27 = (void *)(v25 + 8);
              unint64_t v22 = -1;
              while (*(v27 - 1) != -1)
              {
                if (v22 == -1 || *v27 < *(void *)(v25 + 24 * v22 + 8)) {
                  unint64_t v22 = v26;
                }
                ++v26;
                v27 += 3;
                if (v24 == v26) {
                  goto LABEL_34;
                }
              }
              unint64_t v22 = v26;
            }
            else
            {
              unint64_t v22 = -1;
            }
LABEL_34:
            uint64_t v28 = *(void *)(v25 + 24 * v22);
            if (v28 != -1)
            {
              if (*(int *)(a1 + 8) >= 2)
              {
                fprintf(*v20, "Block %zu evicted from cache\n", *(void *)(v25 + 24 * v22));
                uint64_t v21 = *(void *)(a1 + 64);
                uint64_t v25 = *(void *)(a1 + 88);
                uint64_t v28 = *(void *)(v25 + 24 * v22);
              }
              *(void *)(v21 + 40 * v28 + 32) = -1;
              *(void *)(v25 + 24 * v22) = -1;
            }
            char v29 = (void *)(v21 + 40 * v15);
            size_t v30 = v29[3];
            int v31 = *(_DWORD *)(a1 + 4);
            off_t v32 = v29[1];
            if (v30 == v29[2])
            {
              ssize_t v33 = pread(v31, *(void **)(v25 + 24 * v22 + 16), v30, v32);
              if (v33 < 0 || (uint64_t v21 = *(void *)(a1 + 64), v33 != *(void *)(v21 + 40 * v15 + 24)))
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"loadBlock", 117, 46, 0, "reading uncompressed block %zu", a7, a8, v15);
                return -1;
              }
              int v34 = "Block %zu loaded in cache\n";
              if (*(int *)(a1 + 8) <= 1) {
                goto LABEL_43;
              }
            }
            else
            {
              ssize_t v43 = pread(v31, *(void **)(a1 + 96), v30, v32);
              if (v43 < 0 || v43 != *(void *)(*(void *)(a1 + 64) + 40 * v15 + 24))
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"loadBlock", 125, 46, 0, "reading compressed block %zu", v44, v45, v15);
                return -1;
              }
              uint64_t v46 = (*(uint64_t (**)(void, void, void, ssize_t))(a1 + 24))(*(void *)(*(void *)(a1 + 88) + 24 * v22 + 16), *(void *)(a1 + 40), *(void *)(a1 + 96), v43);
              if (v46 < 0 || (uint64_t v21 = *(void *)(a1 + 64), v46 != *(void *)(v21 + 40 * v15 + 16)))
              {
                char v50 = v15;
                uint64_t v47 = "loadBlock";
                uint64_t v48 = "decoding compressed block %zu";
                __int16 v49 = 128;
                goto LABEL_60;
              }
              int v34 = "Block %zu loaded and decoded in cache\n";
              if (*(int *)(a1 + 8) < 2) {
                goto LABEL_43;
              }
            }
            fprintf(*v20, v34, v15);
            uint64_t v21 = *(void *)(a1 + 64);
LABEL_43:
            uint64_t v23 = *(void *)(a1 + 88);
            uint64_t v35 = (unint64_t *)(v23 + 24 * v22);
            unint64_t v36 = *(void *)(a1 + 112);
            *uint64_t v35 = v15;
            v35[1] = v36;
            uint64_t v37 = v21 + 40 * v15;
            *(void *)(v37 + 32) = v22;
            *(void *)(a1 + 128) += *(void *)(v37 + 16);
LABEL_44:
            if (v22 >= *(void *)(a1 + 72))
            {
              uint64_t v47 = "ParallelCompressionFileRead";
              uint64_t v48 = "invalid entry";
              __int16 v49 = 506;
LABEL_60:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)v47, v49, 46, 0, v48, a7, a8, v50);
              return -1;
            }
            uint64_t v38 = (void *)(v21 + 40 * v15);
            uint64_t v39 = *(void *)(a1 + 104);
            uint64_t v40 = (const void *)(*(void *)(v23 + 24 * v22 + 16) + v39 - *v38);
            size_t v41 = v38[2] + *v38 - v39;
            if (v9 >= v41) {
              size_t v42 = v41;
            }
            else {
              size_t v42 = v9;
            }
            memcpy(__dst, v40, v42);
            __dst += v42;
            *(void *)(a1 + 104) += v42;
            *(void *)(a1 + 120) += v42;
            v8 += v42;
            ++v15;
            v9 -= v42;
            if (!v9) {
              return v8;
            }
          }
        }
      }
    }
LABEL_19:
    unint64_t v15 = -1;
    goto LABEL_20;
  }
  return -1;
}

unsigned __int8 *patchCacheKeyFromSHA1(unsigned __int8 *result, uint64_t a2)
{
  unint64_t v2 = 0;
  do
  {
    unsigned int v3 = *result++;
    unsigned int v4 = (unsigned char *)(a2 + v2);
    *unsigned int v4 = patchCacheKeyFromSHA1_hex[(unint64_t)v3 >> 4];
    v4[1] = patchCacheKeyFromSHA1_hex[v3 & 0xF];
    BOOL v5 = v2 >= 0x26;
    v2 += 2;
  }
  while (!v5);
  return result;
}

unsigned char *patchCacheOpenFromURL(const char *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    uint64_t v12 = "Invalid patch cache URL (NULL)";
    __int16 v13 = 56;
LABEL_8:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/PatchCache.c", (uint64_t)"patchCacheOpenFromURL", v13, 38, 0, v12, a7, a8, v15);
    return 0;
  }
  if (!strncasecmp(a1, "file:", 5uLL))
  {
    uint64_t result = filePatchCacheOpen(a1, a2);
    if (result)
    {
      *(_DWORD *)uint64_t result = 1;
      return result;
    }
    uint64_t v12 = "filePatchCacheOpen failed";
    __int16 v13 = 61;
    goto LABEL_8;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/PatchCache.c", (uint64_t)"patchCacheOpenFromURL", 66, 38, 0, "Unknown patch cache URL: %s", v10, v11, (char)a1);
  return 0;
}

uint64_t patchCacheClose(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    if (*(_DWORD *)result == 1) {
      return filePatchCacheClose((int *)result, a2, a3, a4, a5, a6, a7, a8);
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t patchCacheLookup(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = 0;
  unint64_t v17 = 0;
  int __dst = 0;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  do
  {
    if (!*(unsigned char *)(a2 + v11))
    {
      char v15 = "invalid inKey";
      __int16 v16 = 142;
LABEL_16:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/PatchCache.c", (uint64_t)"patchCacheLookup", v16, 38, 0, v15, a6, a8, v17);
      return 0xFFFFFFFFLL;
    }
    if (!*(unsigned char *)(a3 + v11))
    {
      char v15 = "invalid outKey";
      __int16 v16 = 143;
      goto LABEL_16;
    }
    ++v11;
  }
  while (v11 != 40);
  if (*a1 != 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = filePatchCacheLookup((uint64_t)a1, a2, a3, &__dst, &v17, a5, a6);
  if ((result & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  if (result)
  {
    __int16 v13 = (char *)__dst;
    long long v14 = *((_OWORD *)__dst + 1);
    *(_OWORD *)(a4 + 8) = v14;
    *(void *)(a4 + 24) = 0;
    *(_DWORD *)a4 = 1;
    if ((void)v14)
    {
      if (v17 >= (uint64_t)v14 + 32)
      {
        memmove(v13, v13 + 32, v14);
        __int16 v13 = 0;
        *(void *)(a4 + 24) = __dst;
        int __dst = 0;
      }
    }
    free(v13);
    return 1;
  }
  else
  {
    *(_DWORD *)(a4 + 4) = a5;
  }
  return result;
}

uint64_t patchCacheUpdate(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (!*(_DWORD *)(a4 + 4))
  {
    unint64_t v19 = "PatchCache update not expected";
    __int16 v20 = 183;
LABEL_15:
    int v21 = 0;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/PatchCache.c", (uint64_t)"patchCacheUpdate", v20, 38, v21, v19, a7, a8, v23);
    return 0xFFFFFFFFLL;
  }
  for (uint64_t i = 0; i != 40; ++i)
  {
    if (!*(unsigned char *)(a2 + i))
    {
      unint64_t v19 = "invalid inKey";
      __int16 v20 = 186;
      goto LABEL_15;
    }
    if (!*(unsigned char *)(a3 + i))
    {
      unint64_t v19 = "invalid outKey";
      __int16 v20 = 187;
      goto LABEL_15;
    }
  }
  *(void *)&long long v24 = 0x5F44414F4C594150;
  long long v25 = *(_OWORD *)(a4 + 8);
  *((void *)&v24 + 1) = time(0);
  __int16 v13 = *(const void **)(a4 + 24);
  if (v13)
  {
    size_t v14 = *(void *)(a4 + 8);
    if (v14 < *(void *)(a4 + 16))
    {
      char v15 = malloc(v14 + 32);
      if (v15)
      {
        __int16 v16 = v15;
        long long v17 = v25;
        *char v15 = v24;
        v15[1] = v17;
        memcpy(v15 + 2, v13, v14);
        if (*a1 == 1) {
          uint64_t v18 = filePatchCacheUpdate((uint64_t)a1, a2, a3, (uint64_t)v16, v14 + 32);
        }
        else {
          uint64_t v18 = 0xFFFFFFFFLL;
        }
        free(v16);
        if (!v18) {
          goto LABEL_25;
        }
        return v18;
      }
      int v21 = *__error();
      unint64_t v19 = "malloc";
      __int16 v20 = 209;
      goto LABEL_16;
    }
  }
  if (*a1 != 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v18 = filePatchCacheUpdate((uint64_t)a1, a2, a3, (uint64_t)&v24, 0x20uLL);
  if (!v18) {
LABEL_25:
  }
    *(void *)a4 = 1;
  return v18;
}

void *aaSequentialDecompressionIStreamOpen(uint64_t a1, int a2)
{
  if (!a2) {
    getDefaultNThreads();
  }
  unsigned int v3 = calloc(1uLL, 0x68uLL);
  unsigned int v4 = malloc(0x160uLL);
  uint64_t v5 = (uint64_t)v4;
  if (!v4 || (memset_s(v4, 0x160uLL, 0, 0x160uLL), !v3))
  {
    int v16 = *__error();
    long long v17 = "malloc";
    __int16 v18 = 266;
LABEL_31:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AASequentialDecompressionStream.c", (uint64_t)"aaSequentialDecompressionIStreamOpen", v18, 20, v16, v17, v14, v15, v20);
    free(v3);
    aaDecompressionStreamClose(v5);
    return 0;
  }
  *(void *)uint64_t v5 = a1;
  *(_DWORD *)(v5 + 56) = -1;
  uint64_t v6 = (void *)(v5 + 8);
  size_t v7 = *(void *)(v5 + 16);
  if (!(v7 >> 16))
  {
    do
    {
      size_t v8 = (v7 >> 1) + v7;
      if (((v7 >> 1) & v7) != 0) {
        size_t v8 = ((v7 >> 1) & v7) + v7;
      }
      if (v7) {
        size_t v7 = v8;
      }
      else {
        size_t v7 = 0x4000;
      }
    }
    while (v7 < 0x10000);
    size_t v9 = *(void **)(v5 + 24);
    uint64_t v10 = realloc(v9, v7);
    if (!v10) {
      goto LABEL_29;
    }
    *(void *)(v5 + 16) = v7;
    *(void *)(v5 + 24) = v10;
  }
  size_t v11 = *(void *)(v5 + 40);
  if (v11 >> 16) {
    goto LABEL_23;
  }
  do
  {
    size_t v12 = (v11 >> 1) + v11;
    if (((v11 >> 1) & v11) != 0) {
      size_t v12 = ((v11 >> 1) & v11) + v11;
    }
    if (v11) {
      size_t v11 = v12;
    }
    else {
      size_t v11 = 0x4000;
    }
  }
  while (v11 < 0x10000);
  size_t v9 = *(void **)(v5 + 48);
  __int16 v13 = realloc(v9, v11);
  if (!v13)
  {
    uint64_t v6 = (void *)(v5 + 32);
LABEL_29:
    free(v9);
    void *v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
    long long v17 = "allocating buffer";
    __int16 v18 = 273;
    goto LABEL_30;
  }
  *(void *)(v5 + 40) = v11;
  *(void *)(v5 + 48) = v13;
LABEL_23:
  if (aaDecompressionStreamRefill(v5, 0xCuLL) < 0)
  {
    long long v17 = "reading magic";
    __int16 v18 = 276;
LABEL_30:
    int v16 = 0;
    goto LABEL_31;
  }
  __memcpy_chk();
  if (*(_DWORD *)(v5 + 56) == -1) {
    *(_DWORD *)(v5 + 56) = 0;
  }
  *unsigned int v3 = v5;
  v3[1] = aaDecompressionStreamClose;
  v3[2] = aaDecompressionStreamRead;
  v3[7] = aaDecompressionStreamAbort;
  return v3;
}

uint64_t aaDecompressionStreamRefill(uint64_t a1, size_t a2)
{
  if (!a2) {
    return 0;
  }
  size_t v2 = a2;
  uint64_t v4 = 0;
  uint64_t v6 = (unint64_t *)(a1 + 8);
  uint64_t v5 = *(AAByteStream_impl **)a1;
  unint64_t v8 = *(void *)(a1 + 8);
  unint64_t v7 = *(void *)(a1 + 16);
  while (1)
  {
    if (v8 != v7) {
      goto LABEL_14;
    }
    unint64_t v9 = v7 + 0x40000;
    if ((uint64_t)(v7 + 0x40000) < 0) {
      return -1;
    }
    if (v7 <= 0xFFFFFFFFFFFBFFFFLL) {
      break;
    }
    unint64_t v8 = v7;
LABEL_14:
    size_t v11 = v7;
LABEL_18:
    if (v11 - v8 >= v2) {
      size_t v14 = v2;
    }
    else {
      size_t v14 = v11 - v8;
    }
    ssize_t v15 = AAByteStreamRead(v5, (void *)(*(void *)(a1 + 24) + v8), v14);
    if (v15 < 0) {
      return -1;
    }
    if (!v15) {
      return v4;
    }
    unint64_t v8 = *v6 + v15;
    if (__CFADD__(*v6, v15)) {
      return -1;
    }
    unint64_t v7 = *(void *)(a1 + 16);
    if (v8 > v7) {
      return -1;
    }
    unint64_t *v6 = v8;
    v4 += v15;
    v2 -= v15;
    if (!v2) {
      return v4;
    }
  }
  do
  {
    while (!v7)
    {
      unint64_t v7 = 0x4000;
      size_t v11 = 0x4000;
      if (v9 <= 0x4000) {
        goto LABEL_16;
      }
    }
    unint64_t v10 = v7 >> 1;
    if ((v7 & (v7 >> 1)) != 0) {
      unint64_t v10 = v7 & (v7 >> 1);
    }
    v7 += v10;
  }
  while (v7 < v9);
  size_t v11 = v7;
  if (v7 >= 0x2000000001)
  {
    *__error() = 12;
    goto LABEL_32;
  }
LABEL_16:
  size_t v12 = *(void **)(a1 + 24);
  __int16 v13 = realloc(v12, v11);
  if (v13)
  {
    *(void *)(a1 + 16) = v11;
    *(void *)(a1 + 24) = v13;
    unint64_t v8 = *(void *)(a1 + 8);
    goto LABEL_18;
  }
  free(v12);
LABEL_32:
  unint64_t *v6 = 0;
  v6[1] = 0;
  uint64_t v4 = -1;
  v6[2] = 0;
  return v4;
}

size_t aaDecompressionStreamReadInput(uint64_t a1, uint64_t a2, size_t nbyte)
{
  if (nbyte)
  {
    size_t v3 = nbyte;
    uint64_t v6 = 0;
    while (1)
    {
      size_t v7 = *(void *)(a1 + 8);
      if (v7)
      {
        if (v3 >= v7) {
          size_t v8 = *(void *)(a1 + 8);
        }
        else {
          size_t v8 = v3;
        }
        memcpy((void *)(a2 + v6), *(const void **)(a1 + 24), v8);
        if ((v8 & 0x8000000000000000) != 0) {
          return v8;
        }
        unint64_t v9 = *(void *)(a1 + 8);
        size_t v10 = v9 - v8;
        if (v9 >= v8)
        {
          if (v9 != v8) {
            memmove(*(void **)(a1 + 24), (const void *)(*(void *)(a1 + 24) + v8), v9 - v8);
          }
          *(void *)(a1 + 8) = v10;
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 60)) {
          return v6;
        }
        ssize_t v11 = AAByteStreamRead(*(AAByteStream *)a1, (void *)(a2 + v6), v3);
        size_t v8 = v11;
        if (v11 < 0) {
          return v8;
        }
        if (!v11)
        {
          *(_DWORD *)(a1 + 60) = 1;
          return v6;
        }
      }
      v6 += v8;
      v3 -= v8;
      if (!v3) {
        return v6;
      }
    }
  }
  return 0;
}

uint64_t aaDecompressionStreamClose(uint64_t a1)
{
  if (a1)
  {
    int v2 = *(_DWORD *)(a1 + 56);
    switch(v2)
    {
      case 2:
        compression_stream_destroy((compression_stream *)(a1 + 312));
        break;
      case 4:
        BZ2_bzDecompressEnd((bz_stream *)(a1 + 96));
        break;
      case 3:
        lzma_end();
        break;
    }
    IDecoderStreamDestroy(*(void **)(a1 + 72));
    free(*(void **)(a1 + 24));
    memset_s((void *)(a1 + 8), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(a1 + 48));
    memset_s((void *)(a1 + 32), 0x18uLL, 0, 0x18uLL);
    free((void *)a1);
  }
  return 0;
}

size_t aaDecompressionStreamRead(uint64_t a1, uint64_t a2, size_t nbyte, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 68)) {
    return -1;
  }
  size_t v10 = nbyte;
  uint64_t v13 = *(void *)(a1 + 72);
  if (v13)
  {
    return IDecoderStreamRead(v13, a2, nbyte);
  }
  int v14 = *(_DWORD *)(a1 + 56);
  if (v14 == -1) {
    return -1;
  }
  if (!v14)
  {
    return aaDecompressionStreamReadInput(a1, a2, nbyte);
  }
  if (!nbyte) {
    return 0;
  }
  int v15 = 0;
  size_t v16 = 0;
  char v83 = (unint64_t *)(a1 + 8);
LABEL_15:
  size_t v17 = *(void *)(a1 + 32);
  if (v17)
  {
    if (v10 >= v17) {
      size_t v8 = *(void *)(a1 + 32);
    }
    else {
      size_t v8 = v10;
    }
    memcpy((void *)(a2 + v16), *(const void **)(a1 + 48), v8);
    if ((v8 & 0x8000000000000000) == 0)
    {
      unint64_t v18 = *(void *)(a1 + 32);
      size_t v19 = v18 - v8;
      if (v18 >= v8)
      {
        if (v18 != v8) {
          memmove(*(void **)(a1 + 48), (const void *)(*(void *)(a1 + 48) + v8), v18 - v8);
        }
        *(void *)(a1 + 32) = v19;
      }
      v16 += v8;
      v10 -= v8;
      goto LABEL_141;
    }
    return v8;
  }
  if (*(_DWORD *)(a1 + 64)) {
    return v16;
  }
  unint64_t v21 = *(void *)(a1 + 8);
  unint64_t v20 = *(void *)(a1 + 16);
  if (v20 == v21) {
    goto LABEL_57;
  }
  if (*(_DWORD *)(a1 + 60)) {
    goto LABEL_56;
  }
  size_t v22 = v20 - v21;
  if (v20 == v21) {
    goto LABEL_55;
  }
  size_t v8 = 0;
  char v23 = *(AAByteStream_impl **)a1;
  while (1)
  {
    if (v21 != v20) {
      goto LABEL_41;
    }
    unint64_t v24 = v20 + 0x40000;
    if ((uint64_t)(v20 + 0x40000) < 0) {
      goto LABEL_144;
    }
    if (v20 > 0xFFFFFFFFFFFBFFFFLL)
    {
      unint64_t v21 = v20;
LABEL_41:
      size_t v26 = v20;
      goto LABEL_45;
    }
    do
    {
      while (!v20)
      {
        unint64_t v20 = 0x4000;
        size_t v26 = 0x4000;
        if (v24 <= 0x4000) {
          goto LABEL_43;
        }
      }
      unint64_t v25 = v20 >> 1;
      if ((v20 & (v20 >> 1)) != 0) {
        unint64_t v25 = v20 & (v20 >> 1);
      }
      v20 += v25;
    }
    while (v20 < v24);
    size_t v26 = v20;
    if (v20 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_156;
    }
LABEL_43:
    unsigned int v27 = *(void **)(a1 + 24);
    uint64_t v28 = realloc(v27, v26);
    if (!v28) {
      break;
    }
    *(void *)(a1 + 16) = v26;
    *(void *)(a1 + 24) = v28;
    unint64_t v21 = *(void *)(a1 + 8);
LABEL_45:
    if (v26 - v21 >= v22) {
      size_t v29 = v22;
    }
    else {
      size_t v29 = v26 - v21;
    }
    ssize_t v30 = AAByteStreamRead(v23, (void *)(*(void *)(a1 + 24) + v21), v29);
    if (v30 < 0) {
      goto LABEL_144;
    }
    if (!v30) {
      goto LABEL_53;
    }
    unint64_t v21 = *v83 + v30;
    if (__CFADD__(*v83, v30) || (unint64_t v20 = *(void *)(a1 + 16), v21 > v20))
    {
LABEL_144:
      size_t v8 = -1;
      goto LABEL_145;
    }
    *char v83 = v21;
    v8 += v30;
    v22 -= v30;
    if (!v22)
    {
LABEL_53:
      if ((v8 & 0x8000000000000000) != 0) {
        goto LABEL_145;
      }
      if (!v8) {
LABEL_55:
      }
        *(_DWORD *)(a1 + 60) = 1;
LABEL_56:
      unint64_t v21 = *v83;
LABEL_57:
      off_t v32 = *(unint64_t **)(a1 + 24);
      uint64_t v31 = *(void *)(a1 + 32);
      size_t v33 = *(void *)(a1 + 40) - v31;
      int v34 = (unsigned char *)(*(void *)(a1 + 48) + v31);
      switch(*(_DWORD *)(a1 + 56))
      {
        case 1:
          if (!v21)
          {
            if (!*(_DWORD *)(a1 + 60))
            {
LABEL_150:
              uint64_t v76 = "truncated stream header";
              __int16 v77 = 208;
              goto LABEL_158;
            }
LABEL_124:
            *(_DWORD *)(a1 + 64) = 1;
            goto LABEL_140;
          }
          if (v21 <= 0xF) {
            goto LABEL_150;
          }
          unint64_t v35 = v32[1];
          size_t v36 = bswap64(*v32);
          unint64_t v37 = bswap64(v35);
          size_t v38 = *(void *)(a1 + 80);
          if (v36 > v38 || v37 > v38)
          {
            uint64_t v76 = "corrupted stream header";
            __int16 v77 = 217;
            goto LABEL_158;
          }
          int v79 = v15;
          unint64_t v40 = v37 + 16;
          if (v37 + 16 > v21)
          {
            uint64_t v76 = "truncated stream payload";
            __int16 v77 = 218;
            goto LABEL_158;
          }
          if (v36 > v33)
          {
            uint64_t v76 = "unexpected output buffer size";
            __int16 v77 = 219;
            goto LABEL_158;
          }
          unint64_t v41 = *v32;
          if (*v32 != v35)
          {
            if ((*(uint64_t (**)(unsigned char *, size_t, unint64_t *))(a1 + 88))(v34, v33, v32 + 2) == v36) {
              goto LABEL_126;
            }
            uint64_t v76 = "block decompression failed";
            __int16 v77 = 229;
LABEL_158:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AASequentialDecompressionStream.c", (uint64_t)"aaDecompressionStreamRead", v77, 20, 0, v76, a7, a8, v78);
            return -1;
          }
          memcpy(v34, v32 + 2, v36);
LABEL_126:
          if (v40)
          {
            unint64_t v72 = *v83 - v40;
            if (*v83 >= v40)
            {
              if (*v83 != v40) {
                memmove(*(void **)(a1 + 24), (const void *)(*(void *)(a1 + 24) + v40), *v83 - v40);
              }
              *char v83 = v72;
            }
          }
          if (v41)
          {
            uint64_t v73 = *(void *)(a1 + 32);
            BOOL v74 = __CFADD__(v73, v36);
            size_t v75 = v73 + v36;
            int v15 = v79;
            if (!v74 && v75 <= *(void *)(a1 + 40)) {
              *(void *)(a1 + 32) = v75;
            }
          }
          else
          {
            int v15 = v79;
          }
LABEL_140:
          if (v15 >= 3)
          {
            uint64_t v76 = "truncated stream";
            __int16 v77 = 240;
            goto LABEL_158;
          }
LABEL_141:
          size_t v8 = v16;
          if (!v10) {
            return v8;
          }
          break;
        case 2:
          *(void *)(a1 + 328) = v32;
          *(void *)(a1 + 336) = v21;
          *(void *)(a1 + 312) = v34;
          *(void *)(a1 + 320) = v33;
          compression_status v42 = compression_stream_process((compression_stream *)(a1 + 312), *(_DWORD *)(a1 + 60) != 0);
          if (v42 < 0)
          {
            uint64_t v76 = "decoding compression payload";
            __int16 v77 = 162;
            goto LABEL_158;
          }
          compression_status v43 = v42;
          int v44 = v15;
          uint64_t v45 = *(void *)(a1 + 336);
          uint64_t v46 = *(void *)(a1 + 320);
          unint64_t v47 = v21 - v45;
          if (v21 != v45)
          {
            size_t v48 = *v83 - v47;
            if (*v83 >= v47)
            {
              if (*v83 != v47)
              {
                size_t v80 = *v83 - v47;
                memmove(*(void **)(a1 + 24), (const void *)(*(void *)(a1 + 24) + v47), v48);
                size_t v48 = v80;
              }
              *char v83 = v48;
            }
          }
          if (v33 != v46)
          {
            uint64_t v49 = *(void *)(a1 + 32);
            size_t v50 = v49 + v33 - v46;
            if (!__CFADD__(v49, v33 - v46) && v50 <= *(void *)(a1 + 40)) {
              *(void *)(a1 + 32) = v50;
            }
          }
          if (v33 == v46 && v21 == v45) {
            int v15 = v44 + 1;
          }
          else {
            int v15 = 0;
          }
          if (v43 != COMPRESSION_STATUS_END) {
            goto LABEL_140;
          }
          goto LABEL_124;
        case 3:
          *(void *)(a1 + 176) = v32;
          *(void *)(a1 + 184) = v21;
          *(void *)(a1 + 200) = v34;
          *(void *)(a1 + 208) = v33;
          unsigned int v52 = lzma_code();
          unsigned int v53 = v52;
          if (v52 <= 0xA && ((1 << v52) & 0x403) != 0)
          {
            int v54 = v15;
            uint64_t v55 = *(unint64_t **)(a1 + 176);
            uint64_t v56 = *(unsigned char **)(a1 + 200);
            unint64_t v57 = (char *)v55 - (char *)v32;
            if (v55 != v32)
            {
              size_t v58 = *v83 - v57;
              if (*v83 >= v57)
              {
                if (*v83 != v57)
                {
                  size_t v81 = *v83 - v57;
                  memmove(*(void **)(a1 + 24), (const void *)(*(void *)(a1 + 24) + v57), v58);
                  size_t v58 = v81;
                }
                *char v83 = v58;
              }
            }
            if (v56 != v34)
            {
              uint64_t v59 = *(void *)(a1 + 32);
              unint64_t v60 = v59 + v56 - v34;
              if (!__CFADD__(v59, v56 - v34) && v60 <= *(void *)(a1 + 40)) {
                *(void *)(a1 + 32) = v60;
              }
            }
            if (v56 == v34 && v55 == v32) {
              int v15 = v54 + 1;
            }
            else {
              int v15 = 0;
            }
            if (v53 == 1) {
              goto LABEL_124;
            }
          }
          else
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AASequentialDecompressionStream.c", (uint64_t)"aaDecompressionStreamRead", 194, 20, 0, "decoding lzma payload", a7, a8, v78);
          }
          size_t v8 = -1;
          if (v53 <= 0xA && ((1 << v53) & 0x403) != 0) {
            goto LABEL_140;
          }
          return v8;
        case 4:
          *(void *)(a1 + 96) = v32;
          *(_DWORD *)(a1 + 104) = v21;
          *(void *)(a1 + 120) = v34;
          *(_DWORD *)(a1 + 128) = v33;
          int v62 = BZ2_bzDecompress((bz_stream *)(a1 + 96));
          if (v62 < 0)
          {
            uint64_t v76 = "decoding bzip2 payload";
            __int16 v77 = 178;
            goto LABEL_158;
          }
          int v63 = v62;
          int v64 = v15;
          uint64_t v65 = *(unint64_t **)(a1 + 96);
          int v66 = *(unsigned char **)(a1 + 120);
          unint64_t v67 = (char *)v65 - (char *)v32;
          if (v65 != v32)
          {
            size_t v68 = *v83 - v67;
            if (*v83 >= v67)
            {
              if (*v83 != v67)
              {
                size_t v82 = *v83 - v67;
                memmove(*(void **)(a1 + 24), (const void *)(*(void *)(a1 + 24) + v67), v68);
                size_t v68 = v82;
              }
              *char v83 = v68;
            }
          }
          if (v66 != v34)
          {
            uint64_t v69 = *(void *)(a1 + 32);
            unint64_t v70 = v69 + v66 - v34;
            if (!__CFADD__(v69, v66 - v34) && v70 <= *(void *)(a1 + 40)) {
              *(void *)(a1 + 32) = v70;
            }
          }
          if (v66 == v34 && v65 == v32) {
            int v15 = v64 + 1;
          }
          else {
            int v15 = 0;
          }
          if (v63 != 4) {
            goto LABEL_140;
          }
          goto LABEL_124;
        default:
          return -1;
      }
      goto LABEL_15;
    }
  }
  free(v27);
LABEL_156:
  *char v83 = 0;
  *(void *)(a1 + 16) = 0;
  size_t v8 = -1;
  *(void *)(a1 + 24) = 0;
LABEL_145:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AASequentialDecompressionStream.c", (uint64_t)"aaDecompressionStreamRead", 144, 20, 0, "stream read failed", a7, a8, v78);
  return v8;
}

size_t aaDecompressionStreamAbort(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  *(_DWORD *)(a1 + 68) = 1;
  size_t result = *(void *)(a1 + 72);
  if (result) {
    return IDecoderStreamAbort(result, a2, a3, a4, a5, a6, a7, a8, a9);
  }
  return result;
}

void *AAMemoryInputStreamOpen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 && a2)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c", (uint64_t)"AAMemoryInputStreamOpen", 132, 68, 0, "Invalid arguments", a7, a8, v17);
    size_t v10 = 0;
    ssize_t v11 = 0;
LABEL_8:
    free(v11);
    free(v10);
    return 0;
  }
  size_t v10 = calloc(1uLL, 0x68uLL);
  size_t v12 = malloc(0x20uLL);
  ssize_t v11 = v12;
  if (!v12 || (memset_s(v12, 0x20uLL, 0, 0x20uLL), !v10))
  {
    uint64_t v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c", (uint64_t)"AAMemoryInputStreamOpen", 137, 68, *v13, "malloc", v14, v15, v17);
    goto LABEL_8;
  }
  *ssize_t v11 = a1;
  v11[1] = a2;
  *size_t v10 = v11;
  v10[1] = memoryInputStreamClose;
  v10[7] = memoryInputStreamCancel;
  v10[2] = memoryInputStreamRead;
  v10[4] = memoryInputStreamPRead;
  v10[6] = memoryInputStreamSeek;
  return v10;
}

uint64_t memoryInputStreamClose(void *a1)
{
  return 0;
}

void memoryInputStreamCancel(uint64_t a1)
{
  int v1 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 24), (unsigned int *)&v1, 1u);
}

size_t memoryInputStreamRead(uint64_t a1, void *a2, unint64_t a3)
{
  if (atomic_load((unsigned int *)(a1 + 24))) {
    return -1;
  }
  else {
    return memoryInputStreamPRead(a1, a2, a3, atomic_fetch_add((atomic_ullong *volatile)(a1 + 16), a3));
  }
}

size_t memoryInputStreamPRead(uint64_t a1, void *__dst, uint64_t a3, uint64_t a4)
{
  unsigned int v4 = atomic_load((unsigned int *)(a1 + 24));
  size_t v5 = -1;
  if ((a4 & 0x8000000000000000) == 0 && !v4)
  {
    unint64_t v6 = *(void *)(a1 + 8);
    unint64_t v7 = (uint64_t)v6 >= a4 ? a4 : *(void *)(a1 + 8);
    if (!__CFADD__(v7, a3))
    {
      if (v7 + a3 < v6) {
        unint64_t v6 = v7 + a3;
      }
      size_t v5 = v6 - v7;
      if (v6 <= v7) {
        return 0;
      }
      else {
        memcpy(__dst, (const void *)(*(void *)a1 + v7), v5);
      }
    }
  }
  return v5;
}

uint64_t memoryInputStreamSeek(uint64_t a1, unint64_t a2, int a3)
{
  if (!atomic_load((unsigned int *)(a1 + 24)))
  {
    if (a3)
    {
      if (a3 == 1)
      {
        a2 += atomic_fetch_add((atomic_ullong *volatile)(a1 + 16), a2);
        return a2;
      }
      if (a3 != 2) {
        return -1;
      }
      a2 += *(void *)(a1 + 8);
    }
    atomic_store(a2, (unint64_t *)(a1 + 16));
    return a2;
  }
  return -1;
}

uint64_t LargeFileWorker()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v72 = *MEMORY[0x263EF8340];
  *(void *)(v0 + 8) = 0;
  if (atomic_load((unsigned int *)(*(void *)v0 + 104))) {
    return 0;
  }
  int v2 = (void *)v0;
  size_t v3 = 0;
  unsigned int v4 = 0;
  size_t v5 = 0;
  uint64_t v6 = *(void *)v0;
  uint64_t v7 = *(unsigned int *)(v0 + 32);
  size_t v8 = (unint64_t *)(v0 + 16);
  unint64_t v70 = 0;
  if ((unint64_t)(*(void *)(v6 + 56) - (v7 << 21)) >= 0x200000) {
    size_t v9 = 0x200000;
  }
  else {
    size_t v9 = *(void *)(v6 + 56) - (v7 << 21);
  }
  size_t v10 = v9 - 17;
  if (v9 >= 0x11)
  {
    unsigned int v4 = malloc(0x1000000uLL);
    size_t v3 = (unsigned __int8 *)malloc(v9);
    uint64_t v14 = (char *)malloc(0x40000uLL);
    size_t v5 = v14;
    if (!v4 || (v3 ? (BOOL v15 = v14 == 0) : (BOOL v15 = 1), v15))
    {
      int v25 = *__error();
      size_t v26 = "aaMalloc";
      __int16 v27 = 496;
LABEL_72:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_output_block", v27, 112, v25, v26, v16, v17, v62);
      int v13 = 0;
      goto LABEL_73;
    }
    int v64 = v8;
    memset(__b, 255, sizeof(__b));
    unint64_t v18 = *(void **)(v6 + 24);
    if (!v18[4]) {
      goto LABEL_70;
    }
    __base = v5;
    uint64_t v19 = 0;
    size_t v20 = v9;
    uint64_t v21 = v7 << 21;
    size_t v22 = v3;
    int v65 = v7;
    unint64_t v66 = v20;
    size_t v23 = v20;
    while (1)
    {
      uint64_t v24 = ((uint64_t (*)(void, unsigned __int8 *, size_t, uint64_t))v18[4])(*v18, v22, v23, v21);
      if (v24 < 0) {
        break;
      }
      if (v24)
      {
        v22 += v24;
        v19 += v24;
        v21 += v24;
        v23 -= v24;
        if (v23) {
          continue;
        }
      }
      goto LABEL_25;
    }
    uint64_t v19 = v24;
LABEL_25:
    LODWORD(v7) = v65;
    size_t v9 = v66;
    BOOL v15 = v66 == v19;
    size_t v5 = __base;
    if (v15)
    {
      uint64_t v28 = 0;
      unsigned int v29 = 0;
      do
        unsigned int v29 = -1640531535 * (v29 + v3[v28++]);
      while (v28 != 16);
      uint64_t v67 = (uint64_t)v4;
      unint64_t v30 = 0;
      unint64_t v31 = 0;
      unint64_t v32 = 0;
      unsigned int v33 = 0;
      int v34 = *(_DWORD *)(v6 + 76);
      uint64_t v35 = 16;
      do
      {
        if (v32 >= v30 || (*(_DWORD *)(v6 + 68) & ~v29) == 0)
        {
          unint64_t v30 = v32 + (2 * *(_DWORD *)(v6 + 72));
          if (v32 >= v31)
          {
            uint64_t v36 = *(unsigned int *)(*(void *)(v6 + 40) + 4 * (v29 >> -*(unsigned char *)(v6 + 64)));
            if (v36 != -1)
            {
              uint64_t v37 = __ROR8__(__ROR8__(2654435761 * *(void *)&v3[v32], 41) + 2654435761 * *(void *)&v3[v32 + 8], 41);
              int v38 = HIDWORD(v37) ^ v37;
              uint64_t v39 = *(void *)(v6 + 32);
              while (1)
              {
                uint64_t v40 = v39 + 16 * v36;
                if (*(_DWORD *)(v40 + 8) == v38) {
                  break;
                }
                uint64_t v36 = *(unsigned int *)(v40 + 12);
                if (v36 == -1) {
                  goto LABEL_46;
                }
              }
              uint64_t v41 = *(void *)(v39 + 16 * v36);
              uint64_t v42 = v41 >> 20;
              unint64_t v43 = v41 & 0xFFFFFFFFFFF00000;
              int v44 = __b[v42];
              if (v44 == -1)
              {
LABEL_42:
                if (v33 != 0x4000)
                {
                  uint64_t v46 = &__base[16 * v33];
                  *(void *)uint64_t v46 = v43;
                  *((_DWORD *)v46 + 2) = v44;
                  *((_DWORD *)v46 + 3) = 1;
                  __b[v42] = v33++;
                }
              }
              else
              {
                uint64_t v45 = __b[v42];
                while (*(void *)&__base[16 * v45] != v43)
                {
                  uint64_t v45 = *(unsigned int *)&__base[16 * v45 + 8];
                  if (v45 == -1) {
                    goto LABEL_42;
                  }
                }
                ++*(_DWORD *)&__base[16 * v45 + 12];
              }
              unint64_t v31 = v35;
            }
          }
        }
LABEL_46:
        unsigned int v29 = -1640531535 * (v29 + v3[v35]) - v34 * v3[v32];
        uint64_t v35 = v32 + 17;
        BOOL v15 = v32++ == v10;
      }
      while (!v15);
      if (!v33)
      {
        size_t v8 = v64;
        goto LABEL_6;
      }
      uint64_t v63 = (uint64_t)v3;
      qsort(__base, v33, 0x10uLL, (int (__cdecl *)(const void *, const void *))chunk_compare_by_rating);
      if (v33 >= 0x10) {
        size_t v47 = 16;
      }
      else {
        size_t v47 = v33;
      }
      size_t v68 = v47;
      qsort(__base, v47, 0x10uLL, (int (__cdecl *)(const void *, const void *))chunk_compare_by_position);
      uint64_t v50 = 0;
      LODWORD(v9) = 0;
      do
      {
        uint64_t v51 = *(void *)&v5[16 * v50];
        if ((unint64_t)(*(void *)(v6 + 48) - v51) >= 0x100000) {
          uint64_t v52 = 0x100000;
        }
        else {
          uint64_t v52 = *(void *)(v6 + 48) - v51;
        }
        unsigned int v53 = *(void **)(v6 + 16);
        if (!v53[4]) {
          goto LABEL_80;
        }
        if (v52)
        {
          uint64_t v54 = 0;
          uint64_t v55 = v67 + v9;
          uint64_t v56 = v52;
          while (1)
          {
            uint64_t v57 = ((uint64_t (*)(void, uint64_t, uint64_t, uint64_t))v53[4])(*v53, v55, v56, v51);
            if (v57 < 0) {
              break;
            }
            if (v57)
            {
              v55 += v57;
              v54 += v57;
              v51 += v57;
              v56 -= v57;
              if (v56) {
                continue;
              }
            }
            goto LABEL_64;
          }
          uint64_t v54 = v57;
LABEL_64:
          BOOL v15 = v52 == v54;
          size_t v5 = __base;
          if (!v15)
          {
LABEL_80:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_output_block", 546, 112, 0, "aaByteStreamPReadExpected", v48, v49, v62);
            int v13 = 0;
            unsigned int v4 = (void *)v67;
            size_t v3 = (unsigned __int8 *)v63;
            goto LABEL_73;
          }
        }
        size_t v9 = (v9 + v52);
        ++v50;
      }
      while (v50 != v68);
      unsigned int v4 = (void *)v67;
      size_t v3 = (unsigned __int8 *)v63;
      size_t v8 = v64;
      if ((getBXDiffControls(v67, v9, v63, v66, (int8x16_t **)&v70, (uint64_t)v64, (int *)v6, v49) & 0x80000000) != 0)
      {
        size_t v26 = "generic controls";
        __int16 v27 = 550;
      }
      else
      {
        unint64_t v70 = convert_block_controls(v64, v70, *v64, (uint64_t)v5, v58, v59, v16, v17);
        if (v70)
        {
          LODWORD(v7) = v65;
          goto LABEL_8;
        }
        size_t v26 = "convert_block_controls";
        __int16 v27 = 552;
      }
    }
    else
    {
LABEL_70:
      size_t v26 = "aaByteStreamPReadExpected";
      __int16 v27 = 501;
    }
    int v25 = 0;
    goto LABEL_72;
  }
LABEL_6:
  ssize_t v11 = malloc(0x18uLL);
  unint64_t v70 = v11;
  if (!v11)
  {
    int v25 = *__error();
    size_t v26 = "aaMalloc";
    __int16 v27 = 534;
    goto LABEL_72;
  }
  size_t v12 = v9;
  LODWORD(v9) = 0;
  *ssize_t v11 = 0;
  v11[1] = v12;
  v11[2] = 0;
  *size_t v8 = 1;
LABEL_8:
  if (*(int *)(v6 + 4) >= 3) {
    fprintf((FILE *)*MEMORY[0x263EF8348], " LargeFile: Blocunint64_t k = %5u, %5u K cache, %6zu controls\n", v7, v9 >> 10, *v8);
  }
  int v13 = 1;
LABEL_73:
  free(v4);
  free(v3);
  free(v5);
  if ((v13 & 1) == 0) {
    free(v70);
  }
  unint64_t v60 = v70;
  if (!v13) {
    unint64_t v60 = 0;
  }
  v2[1] = v60;
  if (v60) {
    return 0;
  }
  atomic_compare_exchange_strong((atomic_uint *volatile)(*v2 + 104), (unsigned int *)&v60, 1u);
  return 0xFFFFFFFFLL;
}

uint64_t LargeFileConsumer(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (atomic_load((unsigned int *)(*a2 + 104))) {
    return 0;
  }
  uint64_t result = a2[1];
  if (result)
  {
    if (a2[2])
    {
      uint64_t v12 = 0;
      unint64_t v13 = 0;
      uint64_t v14 = *(char **)a1;
      do
      {
        uint64_t v14 = add_control(v14, (unint64_t *)(a1 + 8), (unint64_t *)(a1 + 16), *(void *)(a2[1] + v12), *(void *)(a2[1] + v12 + 8), *(void *)(a2[1] + v12 + 16), a7, a8);
        *(void *)a1 = v14;
        if (!v14) {
          break;
        }
        ++v13;
        v12 += 24;
      }
      while (v13 < a2[2]);
      uint64_t result = a2[1];
    }
    free((void *)result);
    if (!*(void *)a1)
    {
      BOOL v15 = *(char **)a1;
      atomic_compare_exchange_strong((atomic_uint *volatile)(*a2 + 104), (unsigned int *)&v15, 1u);
      return 0xFFFFFFFFLL;
    }
    return 0;
  }
  return result;
}

unint64_t GetLargeFileMaxMemoryUsage(unint64_t a1, uint64_t a2, int DefaultNThreads)
{
  int v4 = __clz((a1 + 15) >> 4);
  if (1 << ~(_BYTE)v4 >= (a1 + 15) >> 4) {
    unsigned int v5 = 63 - v4;
  }
  else {
    unsigned int v5 = 64 - v4;
  }
  unint64_t v6 = 16;
  if (v5 >= 0x1E)
  {
    do
    {
      --v5;
      unint64_t v6 = (2 * v6);
    }
    while (v5 > 0x1D);
    LOBYTE(v5) = 29;
  }
  if (!DefaultNThreads) {
    int DefaultNThreads = getDefaultNThreads();
  }
  return (4 << v5)
       + 16 * ((5 * (a1 / v6)) >> 2)
       + (GetBXDiffMaxMemoryUsage(0x1000000uLL, 0x200000uLL, 1, 21) + 19136512) * DefaultNThreads;
}

uint64_t GetLargeFileControlsWithStreams(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, void **a5, uint64_t *a6, uint64_t *a7)
{
  double RealTime = getRealTime();
  unsigned int DefaultNThreads = *((_DWORD *)a7 + 2);
  if (!DefaultNThreads) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  *(void *)char v109 = 0;
  long long v107 = 0u;
  *(_OWORD *)long long v108 = 0u;
  *(_OWORD *)uint64_t v105 = 0u;
  long long v106 = 0u;
  uint64_t v102 = 0;
  size_t v98 = 0;
  uint64_t v99 = 0;
  uint64_t v103 = a1;
  long long v104 = a3;
  uint64_t v16 = *a7;
  int v17 = 16;
  unint64_t v100 = 0;
  v101[1] = HIDWORD(v16);
  v101[0] = 21;
  int v18 = __clz((a2 + 15) >> 4);
  LODWORD(v102) = 1;
  v105[1] = (void *)a2;
  *(void *)&long long v106 = a4;
  if (1 << ~(_BYTE)v18 >= (a2 + 15) >> 4) {
    unsigned int v19 = 63 - v18;
  }
  else {
    unsigned int v19 = 64 - v18;
  }
  LODWORD(v107) = 16;
  if (v19 >= 0x1E)
  {
    do
    {
      --v19;
      v17 *= 2;
    }
    while (v19 > 0x1D);
    LODWORD(v107) = v17;
    unsigned int v19 = 29;
  }
  DWORD2(v106) = v19;
  HIDWORD(v106) = v17 - 1;
  DWORD1(v107) = 840293553;
  if (DefaultNThreads < 0xCCCCCCCD)
  {
    size_t v20 = calloc(DefaultNThreads, 0x28uLL);
  }
  else
  {
    size_t v20 = 0;
    *__error() = 12;
  }
  v108[0] = v20;
  uint64_t v21 = calloc(DefaultNThreads, 8uLL);
  v108[1] = v21;
  if (!v20 || !v21)
  {
    int v49 = *__error();
    uint64_t v50 = "aaCalloc";
    __int16 v51 = 672;
LABEL_35:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"GetLargeFileControlsWithStreams", v51, 112, v49, v50, v22, v23, v95);
    goto LABEL_36;
  }
  *((void *)&v104 + 1) = pc_array_init(16, (5 * (a2 / v107)) >> 2);
  if (!*((void *)&v104 + 1))
  {
    uint64_t v50 = "pc_array_init";
    __int16 v51 = 678;
LABEL_34:
    int v49 = 0;
    goto LABEL_35;
  }
  uint64_t v24 = malloc(4 << SBYTE8(v106));
  v105[0] = v24;
  if (!v24)
  {
    int v49 = *__error();
    uint64_t v50 = "malloc";
    __int16 v51 = 683;
    goto LABEL_35;
  }
  memset(v24, 255, 4 << SBYTE8(v106));
  int v25 = calloc(DefaultNThreads, 0x20uLL);
  size_t v26 = calloc(DefaultNThreads, 8uLL);
  __int16 v27 = v26;
  if (!v25 || !v26)
  {
    uint64_t v54 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_input", 433, 112, *v54, "aaCalloc", v55, v56, v95);
    uint64_t v39 = 0;
LABEL_49:
    int v48 = 0;
    goto LABEL_50;
  }
  if (DefaultNThreads)
  {
    uint64_t v28 = v25;
    unsigned int v29 = v26;
    uint64_t v30 = DefaultNThreads;
    unint64_t v31 = v25;
    do
    {
      *unint64_t v31 = v101;
      v31 += 4;
      *v29++ = v28;
      uint64_t v28 = v31;
      --v30;
    }
    while (v30);
  }
  uint64_t v39 = ThreadPipelineCreate(DefaultNThreads, (uint64_t)v26, (uint64_t)fingerprint_worker, (uint64_t)v101, (uint64_t)fingerprint_consumer, 0);
  if (!v39)
  {
    uint64_t v57 = "ThreadPipelineCreate";
    __int16 v58 = 444;
LABEL_48:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_input", v58, 112, 0, v57, v37, v38, v95);
    goto LABEL_49;
  }
  char v97 = a6;
  if (!v105[1])
  {
LABEL_29:
    a6 = v97;
    if ((ThreadPipelineFlush((uint64_t)v39) & 0x80000000) != 0)
    {
      uint64_t v57 = "ThreadPipelineFlush";
      __int16 v58 = 461;
    }
    else
    {
      *((void *)&v104 + 1) = pc_array_compact(*((uint64_t *)&v104 + 1));
      if (*((void *)&v104 + 1))
      {
        int v48 = 1;
        goto LABEL_50;
      }
      uint64_t v57 = "pc_array_compact";
      __int16 v58 = 465;
    }
    goto LABEL_48;
  }
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  while (1)
  {
    uint64_t Worker = (void *)ThreadPipelineGetWorker((uint64_t)v39, v32, v33, v34, v35, v36, v37, v38);
    if (!Worker)
    {
      uint64_t v59 = "ThreadPipelineGetWorker";
      __int16 v60 = 451;
      goto LABEL_45;
    }
    Worker[1] = 0;
    Worker[2] = v41;
    uint64_t v47 = (uint64_t)v105[1] + v40;
    if ((unint64_t)v105[1] + v40 >= 0x200000) {
      uint64_t v47 = 0x200000;
    }
    Worker[3] = v47;
    if ((ThreadPipelineRunWorker((uint64_t)v39, (uint64_t)Worker, v43, v44, v45, v46, v37, v38) & 0x80000000) != 0) {
      break;
    }
    v41 += 0x200000;
    v40 -= 0x200000;
    if (v41 >= v105[1]) {
      goto LABEL_29;
    }
  }
  uint64_t v59 = "ThreadPipelineRunWorker";
  __int16 v60 = 457;
LABEL_45:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_input", v60, 112, 0, v59, v37, v38, v95);
  int v48 = 0;
  a6 = v97;
LABEL_50:
  if ((ThreadPipelineDestroy((uint64_t)v39) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_input", 468, 112, 0, "ThreadPipelineDestroy", v61, v62, v95);
    int v48 = 0;
  }
  free(v25);
  free(v27);
  if (!v48) {
    goto LABEL_36;
  }
  if (*((int *)a7 + 1) >= 3)
  {
    int v65 = (FILE *)*MEMORY[0x263EF8348];
    unint64_t v66 = (unint64_t)(4 << SBYTE8(v106)) >> 20;
    uint64_t v67 = a5;
    uint64_t v68 = (*(void *)(*((void *)&v104 + 1) - 64) >> 16) & 0xFFFFFFFFFFFLL;
    unint64_t v69 = (unint64_t)v105[1] >> 20;
    double v70 = getRealTime();
    uint64_t v96 = v68;
    a5 = v67;
    fprintf(v65, " LargeFile: Using %zu M for hashing.\n LargeFile: Using %zu M for fingerprints.\n LargeFile: Parsed %zu M in %0.2f (s). Added %zu/%zu fingerprints.\n", v66, v96, v69, v70 - RealTime, *(void *)(*((void *)&v104 + 1) - 64), (unint64_t)v105[1] / v107);
  }
  size_t v98 = add_control(0, (unint64_t *)&v99, &v100, 0, 0, 0, v63, v64);
  if (!v98) {
    goto LABEL_36;
  }
  if (DefaultNThreads)
  {
    for (uint64_t i = 0; i != DefaultNThreads; *((void *)v108[1] + i++) = v72)
    {
      uint64_t v72 = (char *)v108[0] + 40 * i;
      *uint64_t v72 = v101;
    }
  }
  uint64_t v73 = ThreadPipelineCreate(DefaultNThreads, (uint64_t)v108[1], (uint64_t)LargeFileWorker, (uint64_t)&v98, (uint64_t)LargeFileConsumer, 0);
  *((void *)&v107 + 1) = v73;
  if (!v73)
  {
    uint64_t v50 = "creating pipeline";
    __int16 v51 = 711;
    goto LABEL_34;
  }
  if (!a4)
  {
LABEL_67:
    if ((ThreadPipelineDestroy((uint64_t)v73) & 0x80000000) == 0)
    {
      *((void *)&v107 + 1) = 0;
      uint64_t v99 = sanitize_internal_controls(v98, v99);
      convert_internal_controls((uint64_t)&v98);
      if (*((int *)a7 + 1) >= 2)
      {
        uint64_t v89 = (FILE *)*MEMORY[0x263EF8348];
        uint64_t v90 = v99;
        double v91 = getRealTime();
        fprintf(v89, "LargeFile: Constructed %zu controls in %0.2f (s).\n", v90, v91 - RealTime);
      }
      int v52 = 0;
      uint64_t v92 = v99;
      *a5 = v98;
      *a6 = v92;
      goto LABEL_37;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"GetLargeFileControlsWithStreams", 725, 112, 0, "ThreadPipelineDestroy failed", v87, v88, v95);
    *((void *)&v107 + 1) = 0;
LABEL_36:
    int v52 = 1;
    goto LABEL_37;
  }
  unsigned int v79 = 1;
  while (1)
  {
    uint64_t v80 = ThreadPipelineGetWorker(*((uint64_t *)&v107 + 1), v74, v75, v76, v77, v78, v22, v23);
    if (!v80) {
      break;
    }
    *(_DWORD *)(v80 + 32) = v79 - 1;
    if ((ThreadPipelineRunWorker(*((uint64_t *)&v107 + 1), v80, v81, v82, v83, v84, v22, v23) & 0x80000000) != 0
      || (unsigned int v85 = atomic_load(v109)) != 0)
    {
      unsigned int v93 = "RunWorker";
      __int16 v94 = 723;
      goto LABEL_75;
    }
    uint64_t v86 = v79++;
    if (a4 <= v86 << 21)
    {
      uint64_t v73 = (unsigned int *)*((void *)&v107 + 1);
      goto LABEL_67;
    }
  }
  unsigned int v93 = "getting worker from pipeline";
  __int16 v94 = 718;
LABEL_75:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"GetLargeFileControlsWithStreams", v94, 112, 0, v93, v22, v23, v95);
  int v52 = 1;
LABEL_37:
  ThreadPipelineDestroy(*((uint64_t *)&v107 + 1));
  free(v108[0]);
  free(v108[1]);
  free(v105[0]);
  pc_array_free(*((uint64_t *)&v104 + 1));
  if (v52)
  {
    free(v98);
    *a5 = 0;
    *a6 = 0;
  }
  return (v52 << 31 >> 31);
}

char *add_control(char *__ptr, unint64_t *a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = __ptr;
  unint64_t v13 = *a2;
  if (*a2 < *a3) {
    goto LABEL_2;
  }
  unint64_t v15 = v13 + (v13 >> 1) + 1;
  *a3 = v15;
  if (*a2 >= v15)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"add_control", 213, 112, 0, "too many controls", a7, a8, v21);
    free(v12);
    return 0;
  }
  if (24 * v15 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_10:
    int v17 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"add_control", 215, 112, *v17, "aaReallocf", v18, v19, v21);
    return 0;
  }
  uint64_t v16 = (char *)realloc(__ptr, 24 * v15);
  if (!v16)
  {
    free(v12);
    goto LABEL_10;
  }
  unint64_t v13 = *a2;
  uint64_t v12 = v16;
LABEL_2:
  *a2 = v13 + 1;
  uint64_t v14 = &v12[24 * v13];
  *(void *)uint64_t v14 = a4;
  *((void *)v14 + 1) = a5;
  *((void *)v14 + 2) = a6;
  return v12;
}

uint64_t sanitize_internal_controls(void *a1, uint64_t a2)
{
  int v2 = (char *)a1;
  if (a2 >= 2)
  {
    unint64_t v3 = (unint64_t)&a1[3 * a2];
    int v4 = a1 + 3;
    unsigned int v5 = a1;
    unint64_t v6 = (char *)a1;
    do
    {
      uint64_t v7 = v5;
      while (1)
      {
        unsigned int v5 = v4;
        uint64_t v8 = *v4;
        if (!v8)
        {
          uint64_t v9 = *((void *)v6 + 1) + v7[4];
          goto LABEL_9;
        }
        if (*((void *)v6 + 1) || *(void *)v6 + *((void *)v6 + 2) != v7[5]) {
          break;
        }
        *(void *)v6 += v8;
        uint64_t v9 = v7[4];
LABEL_9:
        *((void *)v6 + 1) = v9;
        int v4 = v5 + 3;
        uint64_t v7 = v5;
        if ((unint64_t)(v5 + 3) >= v3)
        {
          int v2 = v6;
          return -1431655765 * ((unint64_t)(v2 - (char *)a1) >> 3) + 1;
        }
      }
      int v2 = v6 + 24;
      long long v10 = *(_OWORD *)v5;
      *((void *)v6 + 5) = v5[2];
      *(_OWORD *)(v6 + 24) = v10;
      int v4 = v5 + 3;
      v6 += 24;
    }
    while ((unint64_t)(v5 + 3) < v3);
  }
  return -1431655765 * ((unint64_t)(v2 - (char *)a1) >> 3) + 1;
}

uint64_t convert_internal_controls(uint64_t result)
{
  unint64_t v1 = *(void *)(result + 8);
  if (v1)
  {
    unint64_t v2 = 0;
    unint64_t v3 = *(uint64_t **)result;
    int64x2_t v4 = vdupq_n_s64(0x8000000000000000);
    do
    {
      uint64_t v5 = *v3;
      uint64_t v6 = v3[2] + *v3;
      ++v2;
      uint64_t v7 = v6;
      if (v2 < v1) {
        uint64_t v7 = v3[5];
      }
      if (v5 < 0) {
        uint64_t v5 = 0x8000000000000000 - v5;
      }
      *unint64_t v3 = v5;
      v8.i64[0] = v3[1];
      v8.i64[1] = v7 - v6;
      *(int8x16_t *)(v3 + 1) = vbslq_s8((int8x16_t)vcltzq_s64(v8), (int8x16_t)vsubq_s64(v4, v8), (int8x16_t)v8);
      v3 += 3;
    }
    while (v1 != v2);
  }
  return result;
}

uint64_t GetLargeFileControls(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, void **a5, uint64_t *a6, uint64_t *a7, uint64_t a8)
{
  uint64_t v14 = (AAByteStream_impl *)AAMemoryInputStreamOpen(a1, a2, a3, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8);
  char v21 = (AAByteStream_impl *)AAMemoryInputStreamOpen(a3, a4, v15, v16, v17, v18, v19, v20);
  uint64_t v24 = v21;
  if (!v14 || !v21)
  {
    size_t v26 = "AAMemoryInputStreamOpen";
    __int16 v27 = 758;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"GetLargeFileControls", v27, 112, 0, v26, v22, v23, v29);
    uint64_t v25 = 0xFFFFFFFFLL;
    goto LABEL_8;
  }
  if ((GetLargeFileControlsWithStreams((uint64_t)v14, a2, (unint64_t)v21, a4, a5, a6, a7) & 0x80000000) != 0)
  {
    size_t v26 = "GetLargeFileControlsWithStreams";
    __int16 v27 = 761;
    goto LABEL_7;
  }
  uint64_t v25 = 0;
LABEL_8:
  AAByteStreamClose(v14);
  AAByteStreamClose(v24);
  return v25;
}

uint64_t chunk_compare_by_rating(uint64_t a1, uint64_t a2)
{
  return (*(_DWORD *)(a2 + 12) - *(_DWORD *)(a1 + 12));
}

uint64_t chunk_compare_by_position(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

char *convert_block_controls(unint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v26 = 0;
  *a1 = 0;
  if (a3)
  {
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    do
    {
      uint64_t v14 = a2[3 * v11];
      if (v14 >= 0) {
        uint64_t v15 = a2[3 * v11];
      }
      else {
        uint64_t v15 = 0x8000000000000000 - v14;
      }
      while (1)
      {
        uint64_t v16 = v12 & 0xFFFFF;
        uint64_t v17 = 0x100000 - (v12 & 0xFFFFF);
        if (v17 >= v15) {
          break;
        }
        uint64_t v18 = add_control(v13, a1, &v26, 0x100000 - (v12 & 0xFFFFF), 0, *(void *)(a4 + 16 * (v12 >> 20)) + v16, a7, a8);
        if (!v18)
        {
          __int16 v23 = 251;
LABEL_18:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"convert_block_controls", v23, 112, 0, "add_control", a7, a8, a3);
          goto LABEL_19;
        }
        unint64_t v13 = v18;
        v15 -= v17;
        v12 += v17;
      }
      uint64_t v19 = a2[3 * v11 + 1];
      if (v19 >= 0) {
        uint64_t v20 = a2[3 * v11 + 1];
      }
      else {
        uint64_t v20 = 0x8000000000000000 - v19;
      }
      char v21 = add_control(v13, a1, &v26, v15, v20, *(void *)(a4 + 16 * (v12 >> 20)) + v16, a7, a8);
      if (!v21)
      {
        __int16 v23 = 255;
        goto LABEL_18;
      }
      unint64_t v13 = v21;
      uint64_t v22 = a2[3 * v11 + 2];
      if (v22 < 0) {
        uint64_t v22 = 0x8000000000000000 - v22;
      }
      v12 += v15 + v22;
      ++v11;
    }
    while (v11 != a3);
  }
  else
  {
LABEL_19:
    unint64_t v13 = 0;
  }
  free(a2);
  return v13;
}

uint64_t fingerprint_worker(uint64_t *a1)
{
  size_t v2 = a1[3];
  if (v2 < 0x11) {
    return 0;
  }
  if (v2 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"fingerprint_worker", 325, 112, 0, "aaMalloc", v4, v5, v40);
    int64x2_t v8 = 0;
    uint64_t v15 = 0;
    goto LABEL_32;
  }
  uint64_t v6 = *a1;
  uint64_t v7 = (unsigned __int8 *)malloc(v2);
  if (!v7) {
    goto LABEL_14;
  }
  int64x2_t v8 = v7;
  uint64_t v15 = pc_array_init(16);
  if (!v15)
  {
    __int16 v23 = "pc_array_init";
    __int16 v24 = 329;
    goto LABEL_31;
  }
  uint64_t v16 = a1[3];
  uint64_t v17 = *(void **)(v6 + 16);
  if (!v17[4])
  {
    uint64_t v18 = -1;
LABEL_18:
    if (v16 != v18)
    {
      __int16 v23 = "aaByteStreamPReadExpected";
      __int16 v24 = 333;
      goto LABEL_31;
    }
    goto LABEL_19;
  }
  if (v16)
  {
    uint64_t v18 = 0;
    uint64_t v19 = a1[2];
    uint64_t v20 = v8;
    uint64_t v21 = a1[3];
    while (1)
    {
      uint64_t v22 = ((uint64_t (*)(void, unsigned __int8 *, uint64_t, uint64_t))v17[4])(*v17, v20, v21, v19);
      if (v22 < 0) {
        break;
      }
      if (v22)
      {
        v20 += v22;
        v18 += v22;
        v19 += v22;
        v21 -= v22;
        if (v21) {
          continue;
        }
      }
      goto LABEL_18;
    }
    uint64_t v18 = v22;
    goto LABEL_18;
  }
LABEL_19:
  uint64_t v25 = 0;
  unsigned int v26 = 0;
  do
    unsigned int v26 = -1640531535 * (v26 + v8[v25++]);
  while (v25 != 16);
  unint64_t v27 = a1[3];
  if (v27 < 0x11)
  {
LABEL_29:
    uint64_t v3 = 0;
    a1[1] = (uint64_t)v15;
    uint64_t v15 = 0;
    goto LABEL_33;
  }
  int v28 = 0;
  unint64_t v29 = 0;
  unint64_t v30 = 0;
  unint64_t v31 = 0;
  unsigned int v32 = *(_DWORD *)(v6 + 72) << 8;
  while (1)
  {
    if (v31 < v30 || v31 < v29 && (*(_DWORD *)(v6 + 68) & ~v26) != 0) {
      goto LABEL_28;
    }
    uint64_t v33 = *(unsigned int *)(v6 + 72);
    unint64_t v40 = v31 + a1[2];
    uint64_t v34 = __ROR8__(__ROR8__(2654435761 * *(void *)&v8[v31], 41) + 2654435761 * *(void *)&v8[v31 + 8], 41);
    unsigned int v35 = v26 >> -*(unsigned char *)(v6 + 64);
    int v41 = HIDWORD(v34) ^ v34;
    unsigned int v42 = v35;
    uint64_t v15 = pc_array_append((uint64_t)v15, &v40, v9, v10, v11, v12, v13, v14);
    if (!v15) {
      break;
    }
    unint64_t v29 = v31 + (2 * v33);
    int v36 = v28 + (v32 >> 8);
    int v37 = v32 + v31;
    unsigned int v32 = v31 + v32 - v36;
    unint64_t v30 = v31 + v33 - ((unint64_t)(v37 - v36) >> 8);
    unint64_t v27 = a1[3];
    int v28 = v31;
LABEL_28:
    unsigned int v26 = -1640531535 * (v26 + v8[v31 + 16]) - *(_DWORD *)(v6 + 76) * v8[v31];
    unint64_t v38 = v31 + 17;
    ++v31;
    if (v38 >= v27) {
      goto LABEL_29;
    }
  }
  __int16 v23 = "pc_array_append";
  __int16 v24 = 361;
LABEL_31:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"fingerprint_worker", v24, 112, 0, v23, v13, v14, v40);
LABEL_32:
  uint64_t v3 = 0xFFFFFFFFLL;
LABEL_33:
  free(v8);
  pc_array_free((uint64_t)v15);
  return v3;
}

uint64_t fingerprint_consumer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a2 + 8);
  if (!v8) {
    return 0;
  }
  unint64_t v9 = *(void *)(v8 - 64);
  if (!v9)
  {
LABEL_13:
    int v12 = 0;
    goto LABEL_16;
  }
  uint64_t v11 = 0;
  int v12 = 1;
  while (1)
  {
    uint64_t v13 = (_DWORD *)(v8 + 16 * v11);
    uint64_t v14 = *(void *)(a1 + 40);
    uint64_t v15 = v13[3];
    int v16 = *(_DWORD *)(v14 + 4 * v15);
    if (v16 != -1)
    {
      uint64_t v17 = *(unsigned int *)(v14 + 4 * v15);
      while (1)
      {
        uint64_t v18 = *(void *)(a1 + 32) + 16 * v17;
        if (v13[2] == *(_DWORD *)(v18 + 8)) {
          break;
        }
        uint64_t v17 = *(unsigned int *)(v18 + 12);
        if (v17 == -1) {
          goto LABEL_8;
        }
      }
      if (*(void *)v18 < *(void *)v13) {
        *(void *)uint64_t v18 = *(void *)v13;
      }
      goto LABEL_9;
    }
LABEL_8:
    v13[3] = v16;
    uint64_t v19 = *(void *)(a1 + 32);
    *(_DWORD *)(v14 + 4 * v15) = *(void *)(v19 - 64);
    uint64_t v20 = pc_array_append(v19, v13, a3, a4, a5, a6, a7, a8);
    *(void *)(a1 + 32) = v20;
    if (!v20) {
      break;
    }
LABEL_9:
    int v12 = ++v11 < v9;
    if (v11 == v9) {
      goto LABEL_13;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"fingerprint_consumer", 413, 112, 0, "pc_array_append", a7, a8, v22);
LABEL_16:
  pc_array_free(v8);
  return (v12 << 31 >> 31);
}

uint64_t ParallelCompressionEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15 = 0;
  unsigned int v8 = *(_DWORD *)(a1 + 4);
  LODWORD(v15) = *(_DWORD *)a1;
  uint64_t v14 = *(void *)(a1 + 16);
  v12[1] = 0;
  uint64_t v13 = v8;
  v12[0] = *(_DWORD *)(a1 + 8);
  long long v9 = *(_OWORD *)(a1 + 40);
  v11[0] = *(_OWORD *)(a1 + 24);
  v11[1] = v9;
  v11[2] = *(_OWORD *)(a1 + 56);
  return PCompressFilter(v12, (uint64_t)v11, 0, a4, a5, a6, a7, a8);
}

uint64_t ParallelCompressionDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v12 = 0u;
  long long v13 = 0u;
  int v8 = *(_DWORD *)(a1 + 4);
  DWORD2(v13) = *(_DWORD *)a1;
  DWORD1(v12) = 1;
  DWORD2(v12) = v8;
  long long v9 = *(_OWORD *)(a1 + 24);
  v11[0] = *(_OWORD *)(a1 + 8);
  v11[1] = v9;
  v11[2] = *(_OWORD *)(a1 + 40);
  return PCompressFilter((unsigned int *)&v12, (uint64_t)v11, 0, a4, a5, a6, a7, a8);
}

uint64_t (*PCompressGetEncoderFilter(unsigned int a1))()
{
  if (a1 > 6) {
    return 0;
  }
  else {
    return off_26C28FB28[a1];
  }
}

uint64_t (*PCompressGetDecoderFilter(unsigned int a1))()
{
  if (a1 > 6) {
    return 0;
  }
  else {
    return off_26C28FB60[a1];
  }
}

char *PCompressGetEncoderDescription(unsigned int a1)
{
  if (a1 > 6) {
    return 0;
  }
  else {
    return (&off_264133898)[a1];
  }
}

uint64_t PCompressGetEncoderDecoder(uint64_t result)
{
  if (result >= 7) {
    return 0xFFFFFFFFLL;
  }
  else {
    return result;
  }
}

unint64_t PCompressGetDecoderKey(unsigned int a1)
{
  unint64_t v1 = 0x2D62653466787AuLL >> (8 * a1);
  if (a1 >= 7) {
    LOBYTE(v1) = 63;
  }
  return v1 & 0x7F;
}

char *PCompressGetDecoderDescription(unsigned int a1)
{
  if (a1 > 6) {
    return 0;
  }
  else {
    return (&off_2641338D0)[a1];
  }
}

void *aaCacheStreamOpen(AAByteStream_impl *a1, unint64_t a2, int a3, int a4, unint64_t a5)
{
  uint64_t v10 = calloc(1uLL, 0x68uLL);
  uint64_t v11 = calloc(1uLL, 0x70uLL);
  uint64_t v14 = (uint64_t)v11;
  if (!v11 || !v10)
  {
    int v18 = *__error();
    int v16 = "aaCalloc";
    __int16 v17 = 472;
LABEL_18:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamOpen", v17, 146, v18, v16, v12, v13, v35);
    free(v10);
    aaCacheStreamClose(v14, v27, v28, v29, v30, v31, v32, v33);
    return 0;
  }
  *(void *)uint64_t v11 = a1;
  v11[26] = a4;
  v11[27] = a5 >> 62;
  uint64_t v15 = ((1 << a3) - 1);
  v11[23] = 1 << a3;
  v11[24] = v15;
  v11[21] = (v15 | a2) >> a3;
  v11[22] = a3;
  if (a2 - 1073741825 <= 0xFFFFFFFFBFFFFFFFLL)
  {
    int v16 = "cache too big";
    __int16 v17 = 484;
LABEL_17:
    int v18 = 0;
    goto LABEL_18;
  }
  off_t v19 = AAByteStreamSeek(a1, 0, 2);
  *(void *)(v14 + 24) = v19;
  *(void *)(v14 + 32) = v19;
  if (v19 < 0)
  {
    int v16 = "AAByteStreamSeek";
    __int16 v17 = 488;
    goto LABEL_17;
  }
  size_t v20 = *(unsigned int *)(v14 + 84);
  if (v20 >= 0xCCCCCCCD)
  {
    *__error() = 12;
    *(void *)(v14 + 72) = 0;
LABEL_16:
    int v16 = "aaCalloc";
    __int16 v17 = 492;
    goto LABEL_17;
  }
  uint64_t v21 = calloc(v20, 0x28uLL);
  *(void *)(v14 + 72) = v21;
  if (!v21) {
    goto LABEL_16;
  }
  if (*(_DWORD *)(v14 + 84))
  {
    uint64_t v22 = 0;
    unint64_t v23 = 0;
    size_t v24 = *(unsigned int *)(v14 + 92);
    while (1)
    {
      uint64_t v25 = calloc(1uLL, v24);
      uint64_t v26 = *(void *)(v14 + 72) + v22;
      *(void *)(v26 + 16) = v25;
      if (!v25) {
        break;
      }
      bzero(v25, *(unsigned int *)(v14 + 92));
      *(void *)uint64_t v26 = -1;
      size_t v24 = *(unsigned int *)(v14 + 92);
      *(_DWORD *)(v26 + 28) = 0;
      *(_DWORD *)(v26 + 32) = 0;
      *(_DWORD *)(v26 + 24) = v24;
      ++v23;
      v22 += 40;
      if (v23 >= *(unsigned int *)(v14 + 84)) {
        goto LABEL_15;
      }
    }
    int v16 = "aaCalloc";
    __int16 v17 = 498;
    goto LABEL_17;
  }
LABEL_15:
  AACustomByteStreamSetData((AAByteStream)v10, (void *)v14);
  AACustomByteStreamSetSeekProc((AAByteStream)v10, (AAByteStreamSeekProc)aaCacheStreamSeek);
  AACustomByteStreamSetPReadProc((AAByteStream)v10, (AAByteStreamPReadProc)aaCacheStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v10, (AAByteStreamPWriteProc)aaCacheStreamPWrite);
  AACustomByteStreamSetReadProc((AAByteStream)v10, (AAByteStreamReadProc)aaCacheStreamRead);
  AACustomByteStreamSetWriteProc((AAByteStream)v10, (AAByteStreamWriteProc)aaCacheStreamWrite);
  AACustomByteStreamSetCancelProc((AAByteStream)v10, (AAByteStreamCancelProc)aaCacheStreamCancel);
  AACustomByteStreamSetCloseProc((AAByteStream)v10, (AAByteStreamCloseProc)aaCacheStreamClose);
  v10[8] = aaCacheStreamTruncate;
  return v10;
}

uint64_t aaCacheStreamSeek(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 100)) {
    return -1;
  }
  if (a3)
  {
    if (a3 == 2)
    {
      int v8 = (void *)(a1 + 24);
    }
    else
    {
      if (a3 != 1)
      {
LABEL_10:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamSeek", 392, 146, 0, "bad seek", a7, a8, vars0);
        return -1;
      }
      int v8 = (void *)(a1 + 16);
    }
    a2 += *v8;
  }
  if (a2 < 0) {
    goto LABEL_10;
  }
  *(void *)(a1 + 16) = a2;
  return a2;
}

uint64_t aaCacheStreamPRead(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 100)) {
    return -1;
  }
  uint64_t v9 = a4;
  uint64_t v11 = *(void *)(a1 + 24);
  BOOL v12 = v11 <= a4;
  int64_t v13 = v11 - a4;
  if (v12) {
    return 0;
  }
  if (v13 >= a3) {
    unint64_t v14 = a3;
  }
  else {
    unint64_t v14 = v13;
  }
  if (v14)
  {
    uint64_t v8 = 0;
    while (1)
    {
      unint64_t v16 = *(unsigned int *)(a1 + 96);
      if (*(unsigned int *)(a1 + 92) - (v9 & v16) >= v14) {
        size_t v17 = v14;
      }
      else {
        size_t v17 = *(unsigned int *)(a1 + 92) - (v9 & v16);
      }
      int v18 = cachePageGet(a1, v9 & ~v16, a3, a4, a5, a6, a7, a8);
      if (!v18)
      {
        uint64_t v29 = "cachePageGet";
        __int16 v30 = 224;
        goto LABEL_25;
      }
      uint64_t v25 = v18;
      uint64_t v26 = v16 & v9;
      if ((v26 < *((_DWORD *)v18 + 6) || (v26 + v17) > *((_DWORD *)v18 + 7))
        && (cachePageReadFromDisk((uint64_t *)a1, (uint64_t *)v18, v19, v20, v21, v22, v23, v24) & 0x80000000) != 0)
      {
        break;
      }
      memcpy(a2, (const void *)(*((void *)v25 + 2) + v26), v17);
      ++*(void *)(a1 + 40);
      uint64_t v27 = *(void *)(a1 + 8) + 1;
      *(void *)(a1 + 8) = v27;
      *((void *)v25 + 1) = v27;
      if ((v17 & 0x8000000000000000) != 0) {
        goto LABEL_26;
      }
      v8 += v17;
      a2 += v17;
      v9 += v17;
      v14 -= v17;
      if (!v14) {
        goto LABEL_21;
      }
    }
    uint64_t v29 = "cachePageReadFromDisk";
    __int16 v30 = 229;
LABEL_25:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cacheRead", v30, 146, 0, v29, v23, v24, v31);
LABEL_26:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamPRead", 313, 146, 0, "cacheRead", a7, a8, v31);
    return -1;
  }
  uint64_t v8 = 0;
LABEL_21:
  *(void *)(a1 + 16) = v9;
  return v8;
}

uint64_t aaCacheStreamPWrite(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 100)) {
    return -1;
  }
  uint64_t v8 = a4;
  unint64_t v9 = a3;
  if (a3)
  {
    uint64_t v12 = 0;
    while (1)
    {
      unint64_t v13 = *(unsigned int *)(a1 + 96);
      if (*(unsigned int *)(a1 + 92) - (v8 & v13) >= v9) {
        size_t v14 = v9;
      }
      else {
        size_t v14 = *(unsigned int *)(a1 + 92) - (v8 & v13);
      }
      uint64_t v15 = cachePageGet(a1, v8 & ~v13, a3, a4, a5, a6, a7, a8);
      if (!v15)
      {
        __int16 v30 = "cachePageGet";
        __int16 v31 = 254;
        goto LABEL_28;
      }
      uint64_t v22 = v15;
      uint64_t v23 = v13 & v8;
      unsigned int v24 = v23 + v14;
      unsigned int v25 = *((_DWORD *)v15 + 6);
      unsigned int v26 = *((_DWORD *)v15 + 7);
      if (v25 < v26)
      {
        BOOL v27 = v24 < v25 || v23 > v26;
        if (v27
          && (cachePageReadFromDisk((uint64_t *)a1, (uint64_t *)v15, v16, v17, v18, v19, v20, v21) & 0x80000000) != 0)
        {
          break;
        }
      }
      memcpy((void *)(*((void *)v22 + 2) + v23), a2, v14);
      ++*(void *)(a1 + 48);
      if (v23 < *((_DWORD *)v22 + 6)) {
        *((_DWORD *)v22 + 6) = v23;
      }
      if (v24 > *((_DWORD *)v22 + 7)) {
        *((_DWORD *)v22 + 7) = v24;
      }
      uint64_t v28 = *(void *)(a1 + 8) + 1;
      *(void *)(a1 + 8) = v28;
      *((void *)v22 + 1) = v28;
      *((_DWORD *)v22 + 8) = 1;
      uint64_t v29 = v8 + (int)v14;
      if (*(void *)(a1 + 24) < v29) {
        *(void *)(a1 + 24) = v29;
      }
      if ((v14 & 0x8000000000000000) != 0) {
        goto LABEL_29;
      }
      v12 += v14;
      a2 += v14;
      v8 += v14;
      v9 -= v14;
      if (!v9) {
        goto LABEL_25;
      }
    }
    __int16 v30 = "cachePageReadFromDisk";
    __int16 v31 = 262;
LABEL_28:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cacheWrite", v31, 146, 0, v30, v20, v21, v33);
LABEL_29:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamPWrite", 346, 146, 0, "cacheWrite", a7, a8, v33);
    return -1;
  }
  uint64_t v12 = 0;
LABEL_25:
  *(void *)(a1 + 16) = v8;
  return v12;
}

uint64_t aaCacheStreamRead(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return aaCacheStreamPRead(a1, a2, a3, *(void *)(a1 + 16), a5, a6, a7, a8);
}

uint64_t aaCacheStreamWrite(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return aaCacheStreamPWrite(a1, a2, a3, *(void *)(a1 + 16), a5, a6, a7, a8);
}

uint64_t aaCacheStreamCancel(uint64_t result)
{
  *(_DWORD *)(result + 100) = 1;
  return result;
}

uint64_t aaCacheStreamClose(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = result;
    if (*(void *)(result + 72))
    {
      if ((cacheFlush(result, a2, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamClose", 440, 146, 0, "cacheFlush", v9, v10, v16);
        int v11 = 0;
      }
      else
      {
        int v11 = 1;
      }
      if (*(_DWORD *)(v8 + 84))
      {
        unint64_t v12 = 0;
        uint64_t v13 = 16;
        do
        {
          free(*(void **)(*(void *)(v8 + 72) + v13));
          ++v12;
          v13 += 40;
        }
        while (v12 < *(unsigned int *)(v8 + 84));
      }
      free(*(void **)(v8 + 72));
    }
    else
    {
      int v11 = 1;
    }
    if (*(_DWORD *)(v8 + 104) && AAByteStreamClose(*(AAByteStream *)v8) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamClose", 446, 146, 0, "AAByteStreamClose", v14, v15, v16);
      int v11 = 0;
    }
    if (*(int *)(v8 + 108) >= 1) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "CacheStream: read ops %zu/%zu, write ops %zu/%zu\n", *(void *)(v8 + 56), *(void *)(v8 + 40), *(void *)(v8 + 64), *(void *)(v8 + 48));
    }
    free((void *)v8);
    if (v11) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t aaCacheStreamTruncate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_DWORD *)(a1 + 100))
  {
    if ((cacheFlush(a1, a2, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
    {
      uint64_t v13 = "cacheFlush";
      __int16 v14 = 411;
    }
    else
    {
      if ((AAByteStreamTruncate(*(void **)a1) & 0x80000000) == 0)
      {
        uint64_t result = 0;
        *(void *)(a1 + 24) = a2;
        *(void *)(a1 + 32) = a2;
        return result;
      }
      uint64_t v13 = "AAByteStreamTruncate";
      __int16 v14 = 412;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamTruncate", v14, 146, 0, v13, v10, v11, v15);
  }
  return 0xFFFFFFFFLL;
}

long long *cachePageGet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 72);
  unsigned int v9 = *(_DWORD *)(a1 + 84) - 1;
  unsigned int v10 = v9 & ((unint64_t)(0x16069317E428CA9 * a2) >> 32);
  uint64_t v11 = (long long *)(v8 + 40 * v10);
  if (*(void *)v11 != a2)
  {
    unsigned int v14 = v10 & 0xFFFFFC00;
    unsigned int v15 = v10 | 0x3FF;
    if ((v10 | 0x3FF) >= v9) {
      unsigned int v15 = *(_DWORD *)(a1 + 84) - 1;
    }
    if (v14 <= v15)
    {
      unsigned int v16 = v10 & 0xFFFFFC00;
      while (*(void *)(v8 + 40 * v14) != a2)
      {
        if (*(void *)(v8 + 40 * v14 + 8) < *(void *)(v8 + 40 * v16 + 8)) {
          unsigned int v16 = v14;
        }
        if (++v14 > v15) {
          goto LABEL_11;
        }
      }
    }
    unsigned int v16 = v14;
LABEL_11:
    uint64_t v17 = *((void *)v11 + 4);
    long long v19 = *v11;
    long long v18 = v11[1];
    uint64_t v20 = (long long *)(v8 + 40 * v16);
    uint64_t v21 = *((void *)v20 + 4);
    long long v22 = v20[1];
    *uint64_t v11 = *v20;
    v11[1] = v22;
    *((void *)v11 + 4) = v21;
    uint64_t v23 = *(void *)(a1 + 72) + 40 * v16;
    *(_OWORD *)uint64_t v23 = v19;
    *(_OWORD *)(v23 + 16) = v18;
    *(void *)(v23 + 32) = v17;
    if (*(void *)v11 != a2)
    {
      if ((cachePageEvict((uint64_t *)a1, v8 + 40 * v10, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cachePageGet", 162, 146, 0, "cachePageEvict", v24, v25, v29);
        return 0;
      }
      else
      {
        uint64_t v26 = v8 + 40 * v10;
        bzero(*(void **)(v26 + 16), *(unsigned int *)(a1 + 92));
        int v27 = *(_DWORD *)(a1 + 92);
        *(_DWORD *)(v26 + 28) = 0;
        *(_DWORD *)(v26 + 32) = 0;
        *(_DWORD *)(v26 + 24) = v27;
        *(void *)uint64_t v11 = a2;
      }
    }
  }
  return v11;
}

uint64_t cachePageReadFromDisk(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *((unsigned int *)a2 + 6);
  unsigned int v10 = *((_DWORD *)a2 + 7);
  if (v10 >= v11) {
    size_t v12 = v10 - v11;
  }
  else {
    size_t v12 = 0;
  }
  int v13 = *((_DWORD *)a2 + 8);
  if (v10 <= v11 || v13 == 0)
  {
    unsigned int v15 = 0;
  }
  else
  {
    unsigned int v16 = malloc(v12);
    unsigned int v15 = v16;
    if (!v16)
    {
      uint64_t v24 = "aaMalloc";
      __int16 v25 = 184;
LABEL_33:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cachePageReadFromDisk", v25, 146, 0, v24, a7, a8, v30);
      uint64_t v27 = 0xFFFFFFFFLL;
      goto LABEL_34;
    }
    memcpy(v16, (const void *)(a2[2] + v11), v12);
  }
  uint64_t v17 = *a2;
  if (a1[4] - *a2 >= *((unsigned int *)a1 + 23)) {
    uint64_t v18 = *((unsigned int *)a1 + 23);
  }
  else {
    uint64_t v18 = a1[4] - *a2;
  }
  if (v18 < 1) {
    goto LABEL_26;
  }
  uint64_t v19 = *a1;
  if (!*(void *)(*a1 + 32)) {
    goto LABEL_32;
  }
  unsigned int v31 = v10;
  size_t v32 = v12;
  uint64_t v20 = 0;
  uint64_t v21 = a2[2];
  uint64_t v22 = v18;
  while (1)
  {
    uint64_t v23 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(v19 + 32))(*(void *)v19, v21, v22, v17);
    if (v23 < 0) {
      break;
    }
    if (v23)
    {
      v21 += v23;
      v20 += v23;
      v17 += v23;
      v22 -= v23;
      if (v22) {
        continue;
      }
    }
    goto LABEL_24;
  }
  uint64_t v20 = v23;
LABEL_24:
  size_t v12 = v32;
  unsigned int v10 = v31;
  if (v18 != v20)
  {
LABEL_32:
    uint64_t v24 = "AAByteStreamPRead";
    __int16 v25 = 193;
    goto LABEL_33;
  }
  ++a1[7];
  int v13 = *((_DWORD *)a2 + 8);
LABEL_26:
  if (v10 > v11 && v13 != 0) {
    memcpy((void *)(a2[2] + *((unsigned int *)a2 + 6)), v15, v12);
  }
  uint64_t v27 = 0;
  int v28 = *((_DWORD *)a1 + 23);
  *((_DWORD *)a2 + 6) = 0;
  *((_DWORD *)a2 + 7) = v28;
LABEL_34:
  free(v15);
  return v27;
}

uint64_t cachePageEvict(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((_DWORD *)a1 + 25)) {
    return 0xFFFFFFFFLL;
  }
  if (!*(_DWORD *)(a2 + 32)) {
    return 0;
  }
  uint64_t v9 = *(unsigned int *)(a2 + 24);
  unsigned int v10 = *(_DWORD *)(a2 + 28);
  if (v10 <= v9) {
    return 0;
  }
  uint64_t v12 = *(void *)a2 + v9;
  uint64_t v13 = v10 - v9;
  if (v13 >= a1[3] - v12) {
    uint64_t v14 = a1[3] - v12;
  }
  else {
    uint64_t v14 = v13;
  }
  if (v14 <= 0)
  {
    uint64_t v21 = "bad page";
    __int16 v22 = 87;
LABEL_21:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cachePageEvict", v22, 146, 0, v21, a7, a8, v23);
    return 0xFFFFFFFFLL;
  }
  uint64_t v15 = *a1;
  if (!*(void *)(*a1 + 40)) {
    goto LABEL_20;
  }
  uint64_t v16 = 0;
  uint64_t v17 = *(void *)(a2 + 16) + v9;
  uint64_t v18 = *(void *)a2 + v9;
  uint64_t v19 = v14;
  while (1)
  {
    uint64_t v20 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(v15 + 40))(*(void *)v15, v17, v19, v18);
    if (v20 < 1) {
      break;
    }
    v17 += v20;
    v16 += v20;
    v18 += v20;
    v19 -= v20;
    if (!v19) {
      goto LABEL_16;
    }
  }
  uint64_t v16 = v20;
LABEL_16:
  if (v14 != v16)
  {
LABEL_20:
    uint64_t v21 = "aaByteStreamPWriteExpected";
    __int16 v22 = 90;
    goto LABEL_21;
  }
  ++a1[8];
  if (a1[4] < v14 + v12)
  {
    uint64_t result = 0;
    a1[4] = v14 + v12;
    return result;
  }
  return 0;
}

uint64_t cacheFlush(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 100)) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(a1 + 84))
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    while ((cachePageEvict((uint64_t *)a1, *(void *)(a1 + 72) + v10, a3, a4, a5, a6, a7, a8) & 0x80000000) == 0)
    {
      uint64_t v14 = *(void *)(a1 + 72) + v10;
      bzero(*(void **)(v14 + 16), *(unsigned int *)(a1 + 92));
      *(void *)uint64_t v14 = -1;
      int v15 = *(_DWORD *)(a1 + 92);
      *(_DWORD *)(v14 + 28) = 0;
      *(_DWORD *)(v14 + 32) = 0;
      *(_DWORD *)(v14 + 24) = v15;
      ++v11;
      v10 += 40;
      if (v11 >= *(unsigned int *)(a1 + 84)) {
        return 0;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cacheFlush", 115, 146, 0, "cachePageEvict", v12, v13, v16);
    return 0xFFFFFFFFLL;
  }
  return 0;
}

size_t PCompressLZVNEncode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_encode_buffer(a1, a2, a3, a4, 0, (compression_algorithm)0x900u);
  if (!result) {
    return -1;
  }
  return result;
}

size_t PCompressLZVNDecode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_decode_buffer(a1, a2, a3, a4, 0, (compression_algorithm)0x900u);
  if (!result) {
    return -1;
  }
  return result;
}

uint64_t getOLDEntryType(unsigned __int16 a1)
{
  unint64_t v1 = (((unint64_t)(a1 & 0xF000) - 4096) >> 12) - 3;
  if (v1 > 6) {
    return 0;
  }
  else {
    return dword_2106D4558[v1];
  }
}

uint64_t getAAEntryType(__int16 a1)
{
  unsigned int v1 = (a1 & 0xF000) - 4096;
  if (v1 >> 14 > 2) {
    return 0;
  }
  else {
    return *(unsigned int *)&patchCacheKeyFromSHA1_hex[4 * (v1 >> 12) + 16];
  }
}

void setAAHeaderFromHeader_v10(_DWORD *a1, uint64_t a2)
{
  bzero(a1, 0x890uLL);
  unsigned int v4 = *(unsigned __int16 *)(a2 + 22);
  unint64_t v5 = *(void *)(a2 + 2);
  unsigned int v6 = *a1 | 1;
  switch(*(unsigned char *)(a2 + 1))
  {
    case 1:
      int v7 = 70;
      goto LABEL_7;
    case 2:
      int v7 = 68;
      goto LABEL_7;
    case 3:
      int v7 = 76;
      goto LABEL_7;
    case 4:
      int v7 = 72;
LABEL_7:
      a1[1] = v7;
      break;
    default:
      unsigned int v6 = *a1 & 0xFFFFFFFE;
      int v7 = a1[1];
      break;
  }
  size_t v8 = bswap64(v5);
  *a1 = v6 | 2;
  a1[2] = bswap32(*(unsigned __int16 *)(a2 + 24)) >> 16;
  *a1 = v6 | 6;
  a1[3] = bswap32(*(unsigned __int16 *)(a2 + 26)) >> 16;
  *a1 = v6 | 0x16;
  a1[5] = bswap32(*(unsigned __int16 *)(a2 + 28)) >> 16;
  *a1 = v6 | 0x1E;
  a1[4] = bswap32(*(_DWORD *)(a2 + 18));
  int v9 = v6 | 0x11E;
  *a1 = v6 | 0x11E;
  *((void *)a1 + 6) = bswap64(*(void *)(a2 + 10));
  if (v7 == 70)
  {
    int v9 = v6 | 0x31E;
    *a1 = v6 | 0x31E;
    *((void *)a1 + 8) = v8;
  }
  if (v4)
  {
    size_t v10 = __rev16(v4);
    v9 |= 0x8000u;
    *a1 = v9;
    memcpy(a1 + 36, (const void *)(a2 + 30), v10);
    uint64_t v11 = v10 + 30;
    if (!v5) {
      return;
    }
  }
  else
  {
    uint64_t v11 = 30;
    if (!v5) {
      return;
    }
  }
  if ((v7 | 4) == 0x4C)
  {
    *a1 = v9 | 0x10000;
    memcpy(a1 + 292, (const void *)(a2 + v11), v8);
  }
}

void *setAAHeaderFromHeader_ODC(int *a1, uint64_t a2)
{
  bzero(a1, 0x890uLL);
  uint64_t v4 = 0;
  unint64_t v5 = 0;
  do
  {
    unint64_t v6 = *(unsigned char *)(a2 + 57 + v4++) & 7 | (8 * v5);
    unint64_t v5 = v6;
  }
  while (v4 != 8);
  uint64_t v7 = 0;
  unint64_t v8 = 0;
  do
  {
    unint64_t v9 = *(unsigned char *)(a2 + 64 + v7++) & 7 | (8 * v8);
    unint64_t v8 = v9;
  }
  while (v7 != 4);
  uint64_t v10 = 0;
  unint64_t v11 = 0;
  do
  {
    unint64_t v12 = *(unsigned char *)(a2 + 68 + v10++) & 7 | (8 * v11);
    unint64_t v11 = v12;
  }
  while (v10 != 8);
  uint64_t v13 = 0;
  int v14 = 0;
  uint64_t v15 = (v9 << 24) & 0x1FF000000;
  do
  {
    int v16 = *(unsigned char *)(a2 + 16 + v13++) & 7 | (8 * v14);
    int v14 = v16;
  }
  while (v13 != 8);
  size_t v17 = v6 & 0x3FFFF;
  int v18 = *a1;
  size_t result = (void *)getAAEntryType(v16);
  int v20 = (int)result;
  uint64_t v21 = 0;
  unint64_t v22 = 0;
  a1[5] = v16 & 0xFFF;
  *a1 = v18 | 0x111;
  a1[1] = (int)result;
  do
  {
    unint64_t v23 = *(unsigned char *)(a2 + 47 + v21++) & 7 | (8 * v22);
    unint64_t v22 = v23;
  }
  while (v21 != 4);
  uint64_t v24 = 0;
  unint64_t v25 = 0;
  unint64_t v26 = v23 << 24;
  do
  {
    unint64_t v27 = *(unsigned char *)(a2 + 51 + v24++) & 7 | (8 * v25);
    unint64_t v25 = v27;
  }
  while (v24 != 8);
  uint64_t v28 = 0;
  int v29 = 0;
  *((void *)a1 + 6) = v27 + (v26 & 0x1FF000000);
  *a1 = v18 | 0x113;
  do
  {
    int v30 = *(unsigned char *)(a2 + 22 + v28++) & 7 | (8 * v29);
    int v29 = v30;
  }
  while (v28 != 8);
  uint64_t v31 = 0;
  int v32 = 0;
  a1[2] = v30 & 0x3FFFF;
  *a1 = v18 | 0x117;
  do
  {
    int v33 = *(unsigned char *)(a2 + 28 + v31++) & 7 | (8 * v32);
    int v32 = v33;
  }
  while (v31 != 8);
  uint64_t v34 = 0;
  unint64_t v35 = 0;
  a1[3] = v33 & 0x3FFFF;
  *a1 = v18 | 0x157;
  do
  {
    unint64_t v36 = *(unsigned char *)(a2 + 10 + v34++) & 7 | (8 * v35);
    unint64_t v35 = v36;
  }
  while (v34 != 8);
  uint64_t v37 = 0;
  int v38 = 0;
  *((void *)a1 + 4) = v36 & 0x3FFFF;
  int v39 = v18 | 0x177;
  *a1 = v18 | 0x177;
  do
  {
    int v40 = *(unsigned char *)(a2 + 40 + v37++) & 7 | (8 * v38);
    int v38 = v40;
  }
  while (v37 != 8);
  size_t v41 = v12 + v15;
  a1[6] = v40 & 0x3FFFF;
  if (result == 70)
  {
    int v39 = v18 | 0x377;
    *a1 = v18 | 0x377;
    *((void *)a1 + 8) = v41;
  }
  if (v17)
  {
    v39 |= 0x8000u;
    *a1 = v39;
    size_t result = memcpy(a1 + 36, (const void *)(a2 + 76), v17);
    uint64_t v42 = v17 + 76;
    if (!v41) {
      return result;
    }
  }
  else
  {
    uint64_t v42 = 76;
    if (!v41) {
      return result;
    }
  }
  if ((v20 | 4) == 0x4C)
  {
    *a1 = v39 | 0x10000;
    return memcpy(a1 + 292, (const void *)(a2 + v42), v41);
  }
  return result;
}

void *setAAHeaderFromHeader_NEWC(int *a1, uint64_t a2)
{
  bzero(a1, 0x890uLL);
  uint64_t v4 = 0;
  size_t v5 = 0;
  do
  {
    int v6 = *(char *)(a2 + 94 + v4);
    v5 *= 16;
    char v7 = v6 - 48;
    if ((v6 - 48) <= 0x36)
    {
      if (((1 << v7) & 0x3FF) != 0)
      {
        size_t v5 = v5 + *(char *)(a2 + 94 + v4) - 48;
      }
      else if (((1 << v7) & 0x7E0000) != 0)
      {
        size_t v5 = v5 + *(char *)(a2 + 94 + v4) - 55;
      }
      else if (((1 << v7) & 0x7E000000000000) != 0)
      {
        size_t v5 = v5 + *(char *)(a2 + 94 + v4) - 87;
      }
    }
    ++v4;
  }
  while (v4 != 8);
  uint64_t v8 = 0;
  size_t v9 = 0;
  do
  {
    int v10 = *(char *)(a2 + 54 + v8);
    v9 *= 16;
    char v11 = v10 - 48;
    if ((v10 - 48) <= 0x36)
    {
      if (((1 << v11) & 0x3FF) != 0)
      {
        size_t v9 = v9 + *(char *)(a2 + 54 + v8) - 48;
      }
      else if (((1 << v11) & 0x7E0000) != 0)
      {
        size_t v9 = v9 + *(char *)(a2 + 54 + v8) - 55;
      }
      else if (((1 << v11) & 0x7E000000000000) != 0)
      {
        size_t v9 = v9 + *(char *)(a2 + 54 + v8) - 87;
      }
    }
    ++v8;
  }
  while (v8 != 8);
  uint64_t v12 = 0;
  int v13 = 0;
  do
  {
    int v14 = *(char *)(a2 + 14 + v12);
    v13 *= 16;
    char v15 = v14 - 48;
    if ((v14 - 48) <= 0x36)
    {
      if (((1 << v15) & 0x3FF) != 0)
      {
        int v13 = v13 + v14 - 48;
      }
      else if (((1 << v15) & 0x7E0000) != 0)
      {
        int v13 = v13 + v14 - 55;
      }
      else if (((1 << v15) & 0x7E000000000000) != 0)
      {
        int v13 = v13 + v14 - 87;
      }
    }
    ++v12;
  }
  while (v12 != 8);
  int v16 = *a1;
  size_t result = (void *)getAAEntryType(v13);
  int v18 = (int)result;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  a1[5] = v13 & 0xFFF;
  *a1 = v16 | 0x111;
  a1[1] = (int)result;
  do
  {
    int v21 = *(char *)(a2 + 46 + v19);
    v20 *= 16;
    char v22 = v21 - 48;
    if ((v21 - 48) <= 0x36)
    {
      if (((1 << v22) & 0x3FF) != 0)
      {
        uint64_t v20 = v20 + *(char *)(a2 + 46 + v19) - 48;
      }
      else if (((1 << v22) & 0x7E0000) != 0)
      {
        uint64_t v20 = v20 + *(char *)(a2 + 46 + v19) - 55;
      }
      else if (((1 << v22) & 0x7E000000000000) != 0)
      {
        uint64_t v20 = v20 + *(char *)(a2 + 46 + v19) - 87;
      }
    }
    ++v19;
  }
  while (v19 != 8);
  uint64_t v23 = 0;
  int v24 = 0;
  *((void *)a1 + 6) = v20;
  *a1 = v16 | 0x113;
  do
  {
    int v25 = *(char *)(a2 + 22 + v23);
    v24 *= 16;
    char v26 = v25 - 48;
    if ((v25 - 48) <= 0x36)
    {
      if (((1 << v26) & 0x3FF) != 0)
      {
        int v24 = v24 + v25 - 48;
      }
      else if (((1 << v26) & 0x7E0000) != 0)
      {
        int v24 = v24 + v25 - 55;
      }
      else if (((1 << v26) & 0x7E000000000000) != 0)
      {
        int v24 = v24 + v25 - 87;
      }
    }
    ++v23;
  }
  while (v23 != 8);
  uint64_t v27 = 0;
  int v28 = 0;
  a1[2] = v24;
  *a1 = v16 | 0x117;
  do
  {
    int v29 = *(char *)(a2 + 30 + v27);
    v28 *= 16;
    char v30 = v29 - 48;
    if ((v29 - 48) <= 0x36)
    {
      if (((1 << v30) & 0x3FF) != 0)
      {
        int v28 = v28 + v29 - 48;
      }
      else if (((1 << v30) & 0x7E0000) != 0)
      {
        int v28 = v28 + v29 - 55;
      }
      else if (((1 << v30) & 0x7E000000000000) != 0)
      {
        int v28 = v28 + v29 - 87;
      }
    }
    ++v27;
  }
  while (v27 != 8);
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  a1[3] = v28;
  *a1 = v16 | 0x157;
  do
  {
    int v33 = *(char *)(a2 + 6 + v31);
    v32 *= 16;
    char v34 = v33 - 48;
    if ((v33 - 48) <= 0x36)
    {
      if (((1 << v34) & 0x3FF) != 0)
      {
        uint64_t v32 = v32 + *(char *)(a2 + 6 + v31) - 48;
      }
      else if (((1 << v34) & 0x7E0000) != 0)
      {
        uint64_t v32 = v32 + *(char *)(a2 + 6 + v31) - 55;
      }
      else if (((1 << v34) & 0x7E000000000000) != 0)
      {
        uint64_t v32 = v32 + *(char *)(a2 + 6 + v31) - 87;
      }
    }
    ++v31;
  }
  while (v31 != 8);
  uint64_t v35 = 0;
  int v36 = 0;
  *((void *)a1 + 4) = v32;
  do
  {
    int v37 = *(char *)(a2 + 78 + v35);
    v36 *= 16;
    char v38 = v37 - 48;
    if ((v37 - 48) <= 0x36)
    {
      if (((1 << v38) & 0x3FF) != 0)
      {
        int v36 = v36 + v37 - 48;
      }
      else if (((1 << v38) & 0x7E0000) != 0)
      {
        int v36 = v36 + v37 - 55;
      }
      else if (((1 << v38) & 0x7E000000000000) != 0)
      {
        int v36 = v36 + v37 - 87;
      }
    }
    ++v35;
  }
  while (v35 != 8);
  uint64_t v39 = 0;
  int v40 = 0;
  do
  {
    int v41 = *(char *)(a2 + 86 + v39);
    v40 *= 16;
    char v42 = v41 - 48;
    if ((v41 - 48) <= 0x36)
    {
      if (((1 << v42) & 0x3FF) != 0)
      {
        int v40 = v40 + v41 - 48;
      }
      else if (((1 << v42) & 0x7E0000) != 0)
      {
        int v40 = v40 + v41 - 55;
      }
      else if (((1 << v42) & 0x7E000000000000) != 0)
      {
        int v40 = v40 + v41 - 87;
      }
    }
    ++v39;
  }
  while (v39 != 8);
  int v43 = v16 | 0x177;
  *a1 = v16 | 0x177;
  a1[6] = v40 + (v36 << 24);
  if (result == 70)
  {
    int v43 = v16 | 0x377;
    *a1 = v16 | 0x377;
    *((void *)a1 + 8) = v9;
  }
  if (v5)
  {
    v43 |= 0x8000u;
    *a1 = v43;
    size_t result = memcpy(a1 + 36, (const void *)(a2 + 110), v5);
    uint64_t v44 = v5 + 110;
    if (!v9) {
      return result;
    }
  }
  else
  {
    uint64_t v44 = 110;
    if (!v9) {
      return result;
    }
  }
  if ((v18 | 4) == 0x4C)
  {
    *a1 = v43 | 0x10000;
    return memcpy(a1 + 292, (const void *)(a2 + v44), v9);
  }
  return result;
}

uint64_t setHeaderFromValues_v10(uint64_t result, char a2, unint64_t a3, unint64_t a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, unsigned __int16 a9)
{
  *(void *)size_t result = 0;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)(result + 22) = 0;
  *(unsigned char *)size_t result = 16;
  *(unsigned char *)(result + 1) = a2;
  *(void *)(result + 2) = bswap64(a3);
  *(void *)(result + 10) = bswap64(a4);
  *(_DWORD *)(result + 18) = bswap32(a5);
  *(_WORD *)(result + 22) = __rev16(a6);
  *(_WORD *)(result + 24) = __rev16(a7);
  *(_WORD *)(result + 26) = __rev16(a8);
  *(_WORD *)(result + 28) = __rev16(a9);
  return result;
}

uint64_t yaa_parseFields(const char *a1, _DWORD *a2, _WORD *a3)
{
  size_t v6 = strlen(a1);
  if (v6)
  {
    unint64_t v7 = v6;
    unint64_t v8 = 0;
    int v9 = 0;
    int v10 = 0;
    uint64_t v11 = MEMORY[0x263EF8318];
    while (1)
    {
      unsigned int v12 = *(_DWORD *)&a1[v8] & 0xDFDFDF;
      if (v12 <= 0x4B4E4B)
      {
        if ((*(_DWORD *)&a1[v8] & 0xDFDFDFu) > 0x444946)
        {
          if ((*(_DWORD *)&a1[v8] & 0xDFDFDFu) > 0x464158)
          {
            switch(v12)
            {
              case 0x464159u:
                v9 |= 4u;
                goto LABEL_70;
              case 0x474C46u:
                v10 |= 8u;
                goto LABEL_70;
              case 0x4B4459u:
                v9 |= 0x10u;
                goto LABEL_70;
            }
          }
          else
          {
            switch(v12)
            {
              case 0x444947u:
                v10 |= 4u;
                goto LABEL_70;
              case 0x444955u:
                v10 |= 2u;
                goto LABEL_70;
              case 0x444F4Du:
                v10 |= 0x10u;
                goto LABEL_70;
            }
          }
        }
        else if ((*(_DWORD *)&a1[v8] & 0xDFDFDFu) > 0x124857)
        {
          switch(v12)
          {
            case 0x124858u:
              v9 |= 0x40u;
              goto LABEL_70;
            case 0x414459u:
              v9 |= 8u;
              goto LABEL_70;
            case 0x434559u:
              v9 |= 0x100u;
              goto LABEL_70;
          }
        }
        else
        {
          switch(v12)
          {
            case 0x114853u:
              v10 |= 0x2000u;
              goto LABEL_70;
            case 0x114858u:
              v9 |= 0x20u;
              goto LABEL_70;
            case 0x124853u:
              v10 |= 0x4000u;
              goto LABEL_70;
          }
        }
      }
      else if ((*(_DWORD *)&a1[v8] & 0xDFDFDFu) <= 0x544143)
      {
        if ((*(_DWORD *)&a1[v8] & 0xDFDFDFu) > 0x505841)
        {
          switch(v12)
          {
            case 0x505842u:
              v9 |= 0x80u;
              goto LABEL_70;
            case 0x505954u:
              v10 |= 1u;
              goto LABEL_70;
            case 0x534B43u:
              v10 |= 0x1000u;
              goto LABEL_70;
          }
        }
        else
        {
          switch(v12)
          {
            case 0x4B4E4Cu:
              v10 |= 0x10000u;
              goto LABEL_70;
            case 0x4C4341u:
              v10 |= 0x800u;
              goto LABEL_70;
            case 0x4D544Du:
              v10 |= 0x100u;
              goto LABEL_70;
          }
        }
      }
      else if ((*(_DWORD *)&a1[v8] & 0xDFDFDFu) <= 0x564543)
      {
        switch(v12)
        {
          case 0x544144u:
            v10 |= 0x200u;
            goto LABEL_70;
          case 0x544150u:
            v10 |= 0x8000u;
            goto LABEL_70;
          case 0x544158u:
            v10 |= 0x400u;
            goto LABEL_70;
        }
      }
      else if ((*(_DWORD *)&a1[v8] & 0xDFDFDFu) > 0x5A4952)
      {
        if (v12 == 5917011)
        {
          v10 |= 0x80u;
          goto LABEL_70;
        }
        if (v12 == 5920068)
        {
          v9 |= 1u;
          goto LABEL_70;
        }
      }
      else
      {
        if (v12 == 5653828)
        {
          v10 |= 0x20u;
          goto LABEL_70;
        }
        if (v12 == 5784649)
        {
          v9 |= 2u;
          goto LABEL_70;
        }
      }
      if (v8 + 3 < v7)
      {
        uint64_t v13 = 3;
        do
        {
          unsigned int v14 = a1[v8 + v13];
          if ((v14 & 0x80000000) != 0)
          {
            if (!__maskrune(v14, 0x500uLL)) {
              goto LABEL_71;
            }
          }
          else if ((*(_DWORD *)(v11 + 4 * v14 + 60) & 0x500) == 0)
          {
            goto LABEL_71;
          }
          ++v13;
        }
        while (v7 - v8 != v13);
        uint64_t v13 = v7 - v8;
        goto LABEL_71;
      }
LABEL_70:
      uint64_t v13 = 3;
LABEL_71:
      v8 += v13;
      int v15 = a1[v8];
      if (v15 == 32 || v15 == 44)
      {
        ++v8;
      }
      else if (!a1[v8])
      {
        goto LABEL_77;
      }
      if (v8 >= v7)
      {
LABEL_77:
        if (a2) {
          goto LABEL_78;
        }
        goto LABEL_79;
      }
    }
  }
  int v10 = 0;
  LOWORD(v9) = 0;
  if (a2) {
LABEL_78:
  }
    *a2 = v10;
LABEL_79:
  if (a3)
  {
    *a3 = v9;
    a3[1] = 0;
  }
  return 0;
}

uint64_t yaa_serializeFields(unsigned char *a1, unint64_t a2, int a3, __int16 a4)
{
  if ((a3 & 1) == 0)
  {
    int v5 = 0;
    if ((a3 & 0x8000) == 0) {
      goto LABEL_5;
    }
LABEL_14:
    if ((a3 & 1) != 0 && !a2) {
      return 0xFFFFFFFFLL;
    }
    if (a3)
    {
      *a1++ = 44;
      --a2;
    }
    BOOL v4 = a2 >= 3;
    a2 -= 3;
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
    a1[2] = 84;
    *(_WORD *)a1 = 16720;
    a1 += 3;
    int v5 = 1;
    if ((a3 & 0x10000) == 0) {
      goto LABEL_21;
    }
    goto LABEL_6;
  }
  BOOL v4 = a2 >= 3;
  a2 -= 3;
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  a1[2] = 80;
  *(_WORD *)a1 = 22868;
  a1 += 3;
  int v5 = 1;
  if ((a3 & 0x8000) != 0) {
    goto LABEL_14;
  }
LABEL_5:
  if ((a3 & 0x10000) == 0) {
    goto LABEL_21;
  }
LABEL_6:
  if (!a2 && v5) {
    return 0xFFFFFFFFLL;
  }
  if (v5)
  {
    *a1++ = 44;
    --a2;
  }
  BOOL v4 = a2 >= 3;
  a2 -= 3;
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  a1[2] = 75;
  *(_WORD *)a1 = 20044;
  a1 += 3;
  int v5 = 1;
LABEL_21:
  if ((a3 & 0x20) != 0)
  {
    if (!a2 && v5) {
      return 0xFFFFFFFFLL;
    }
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    BOOL v4 = a2 >= 3;
    a2 -= 3;
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
    a1[2] = 86;
    *(_WORD *)a1 = 17732;
    a1 += 3;
    int v5 = 1;
    if ((a3 & 2) == 0) {
      goto LABEL_37;
    }
  }
  else if ((a3 & 2) == 0)
  {
    goto LABEL_37;
  }
  if (!a2 && v5) {
    return 0xFFFFFFFFLL;
  }
  if (v5)
  {
    *a1++ = 44;
    --a2;
  }
  BOOL v4 = a2 >= 3;
  a2 -= 3;
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  a1[2] = 68;
  *(_WORD *)a1 = 18773;
  a1 += 3;
  int v5 = 1;
LABEL_37:
  if ((a3 & 4) != 0)
  {
    if (!a2 && v5) {
      return 0xFFFFFFFFLL;
    }
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    BOOL v4 = a2 >= 3;
    a2 -= 3;
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
    a1[2] = 68;
    *(_WORD *)a1 = 18759;
    a1 += 3;
    int v5 = 1;
    if ((a3 & 0x10) == 0)
    {
LABEL_39:
      if ((a3 & 8) == 0) {
        goto LABEL_40;
      }
LABEL_62:
      if (v5 && !a2) {
        return 0xFFFFFFFFLL;
      }
      if (v5)
      {
        *a1++ = 44;
        --a2;
      }
      BOOL v4 = a2 >= 3;
      a2 -= 3;
      if (!v4) {
        return 0xFFFFFFFFLL;
      }
      a1[2] = 71;
      *(_WORD *)a1 = 19526;
      a1 += 3;
      int v5 = 1;
      if ((a3 & 0x100) == 0) {
        goto LABEL_69;
      }
      goto LABEL_41;
    }
  }
  else if ((a3 & 0x10) == 0)
  {
    goto LABEL_39;
  }
  if (v5 && !a2) {
    return 0xFFFFFFFFLL;
  }
  if (v5)
  {
    *a1++ = 44;
    --a2;
  }
  BOOL v4 = a2 >= 3;
  a2 -= 3;
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  a1[2] = 68;
  *(_WORD *)a1 = 20301;
  a1 += 3;
  int v5 = 1;
  if ((a3 & 8) != 0) {
    goto LABEL_62;
  }
LABEL_40:
  if ((a3 & 0x100) == 0) {
    goto LABEL_69;
  }
LABEL_41:
  if (v5 && !a2) {
    return 0xFFFFFFFFLL;
  }
  if (v5)
  {
    *a1++ = 44;
    --a2;
  }
  BOOL v4 = a2 >= 3;
  a2 -= 3;
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  a1[2] = 77;
  *(_WORD *)a1 = 21581;
  a1 += 3;
  int v5 = 1;
LABEL_69:
  if ((a3 & 0x200) != 0)
  {
    if (v5 && !a2) {
      return 0xFFFFFFFFLL;
    }
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    BOOL v4 = a2 >= 3;
    a2 -= 3;
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
    a1[2] = 84;
    *(_WORD *)a1 = 16708;
    a1 += 3;
    int v5 = 1;
  }
  if ((a3 & 0x1000) != 0)
  {
    if (v5 && !a2) {
      return 0xFFFFFFFFLL;
    }
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    BOOL v4 = a2 >= 3;
    a2 -= 3;
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
    a1[2] = 83;
    *(_WORD *)a1 = 19267;
    a1 += 3;
    int v5 = 1;
  }
  if ((a3 & 0x2000) == 0)
  {
    if ((a3 & 0x4000) == 0) {
      goto LABEL_87;
    }
LABEL_102:
    if (v5 && !a2) {
      return 0xFFFFFFFFLL;
    }
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    BOOL v4 = a2 >= 3;
    a2 -= 3;
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
    a1[2] = 50;
    *(_WORD *)a1 = 18515;
    a1 += 3;
    int v5 = 1;
    if ((a3 & 0x400) == 0) {
      goto LABEL_109;
    }
    goto LABEL_88;
  }
  if (v5 && !a2) {
    return 0xFFFFFFFFLL;
  }
  if (v5)
  {
    *a1++ = 44;
    --a2;
  }
  BOOL v4 = a2 >= 3;
  a2 -= 3;
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  a1[2] = 49;
  *(_WORD *)a1 = 18515;
  a1 += 3;
  int v5 = 1;
  if ((a3 & 0x4000) != 0) {
    goto LABEL_102;
  }
LABEL_87:
  if ((a3 & 0x400) == 0) {
    goto LABEL_109;
  }
LABEL_88:
  if (v5 && !a2) {
    return 0xFFFFFFFFLL;
  }
  if (v5)
  {
    *a1++ = 44;
    --a2;
  }
  BOOL v4 = a2 >= 3;
  a2 -= 3;
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  a1[2] = 84;
  *(_WORD *)a1 = 16728;
  a1 += 3;
  int v5 = 1;
LABEL_109:
  if ((a3 & 0x800) != 0)
  {
    if (v5 && !a2) {
      return 0xFFFFFFFFLL;
    }
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    BOOL v4 = a2 >= 3;
    a2 -= 3;
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
    a1[2] = 76;
    *(_WORD *)a1 = 17217;
    a1 += 3;
    int v5 = 1;
  }
  if ((a3 & 0x80) != 0)
  {
    if (v5 && !a2) {
      return 0xFFFFFFFFLL;
    }
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    BOOL v4 = a2 >= 3;
    a2 -= 3;
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
    a1[2] = 90;
    *(_WORD *)a1 = 18771;
    a1 += 3;
    int v5 = 1;
  }
  if ((a4 & 0x80) != 0)
  {
    if (v5 && !a2) {
      return 0xFFFFFFFFLL;
    }
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    BOOL v4 = a2 >= 3;
    a2 -= 3;
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
    a1[2] = 80;
    *(_WORD *)a1 = 22594;
    a1 += 3;
    int v5 = 1;
  }
  if (a4)
  {
    if (v5 && !a2) {
      return 0xFFFFFFFFLL;
    }
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    BOOL v4 = a2 >= 3;
    a2 -= 3;
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
    a1[2] = 90;
    *(_WORD *)a1 = 21828;
    a1 += 3;
    int v5 = 1;
  }
  if ((a4 & 2) != 0)
  {
    if (v5 && !a2) {
      return 0xFFFFFFFFLL;
    }
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    BOOL v4 = a2 >= 3;
    a2 -= 3;
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
    a1[2] = 88;
    *(_WORD *)a1 = 17481;
    a1 += 3;
    int v5 = 1;
  }
  if ((a4 & 0x20) != 0)
  {
    if (v5 && !a2) {
      return 0xFFFFFFFFLL;
    }
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    BOOL v4 = a2 >= 3;
    a2 -= 3;
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
    a1[2] = 49;
    *(_WORD *)a1 = 18520;
    a1 += 3;
    int v5 = 1;
    if ((a4 & 0x40) == 0) {
      goto LABEL_165;
    }
  }
  else if ((a4 & 0x40) == 0)
  {
    goto LABEL_165;
  }
  if (v5 && !a2) {
    return 0xFFFFFFFFLL;
  }
  if (v5)
  {
    *a1++ = 44;
    --a2;
  }
  BOOL v4 = a2 >= 3;
  a2 -= 3;
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  a1[2] = 50;
  *(_WORD *)a1 = 18520;
  a1 += 3;
  int v5 = 1;
LABEL_165:
  if ((a4 & 4) != 0)
  {
    if (v5 && !a2) {
      return 0xFFFFFFFFLL;
    }
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    BOOL v4 = a2 >= 3;
    a2 -= 3;
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
    a1[2] = 70;
    *(_WORD *)a1 = 16729;
    a1 += 3;
    int v5 = 1;
    if ((a4 & 8) == 0)
    {
LABEL_167:
      if ((a4 & 0x10) == 0) {
        goto LABEL_168;
      }
LABEL_190:
      if (v5 && !a2) {
        return 0xFFFFFFFFLL;
      }
      if (v5)
      {
        *a1++ = 44;
        --a2;
      }
      BOOL v4 = a2 >= 3;
      a2 -= 3;
      if (!v4) {
        return 0xFFFFFFFFLL;
      }
      a1[2] = 75;
      *(_WORD *)a1 = 17497;
      a1 += 3;
      int v5 = 1;
      if ((a4 & 0x100) == 0) {
        goto LABEL_197;
      }
      goto LABEL_169;
    }
  }
  else if ((a4 & 8) == 0)
  {
    goto LABEL_167;
  }
  if (v5 && !a2) {
    return 0xFFFFFFFFLL;
  }
  if (v5)
  {
    *a1++ = 44;
    --a2;
  }
  BOOL v4 = a2 >= 3;
  a2 -= 3;
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  a1[2] = 65;
  *(_WORD *)a1 = 17497;
  a1 += 3;
  int v5 = 1;
  if ((a4 & 0x10) != 0) {
    goto LABEL_190;
  }
LABEL_168:
  if ((a4 & 0x100) == 0) {
    goto LABEL_197;
  }
LABEL_169:
  if (v5 && !a2) {
    return 0xFFFFFFFFLL;
  }
  if (v5)
  {
    *a1++ = 44;
    --a2;
  }
  BOOL v4 = a2 >= 3;
  a2 -= 3;
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  a1[2] = 67;
  *(_WORD *)a1 = 17753;
  a1 += 3;
LABEL_197:
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = 0;
  *a1 = 0;
  return v6;
}

uint64_t ECCGenerateThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_DWORD *)(a1 + 40) & 0x80000000) != 0)
  {
    int v9 = 0;
  }
  else
  {
    int v9 = malloc(*(unsigned int *)(a1 + 28));
    if (!v9)
    {
      int v10 = "creating workBuffer";
      __int16 v11 = 66;
LABEL_25:
      int v21 = 0;
LABEL_26:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ECCGenerateThreadProc", v11, 64, v21, v10, a7, a8, v23);
      goto LABEL_27;
    }
  }
  for (unint64_t i = *(void *)(a1 + 8); i < *(void *)(a1 + 16); ++i)
  {
    uint64_t v13 = *(unsigned int *)(a1 + 28);
    uint64_t v14 = i * v13;
    unint64_t v15 = *(void *)(a1 + 64);
    if (v15 < i * v13)
    {
      int v10 = "Invalid block index";
      __int16 v11 = 74;
      goto LABEL_25;
    }
    if (v14 + v13 <= v15) {
      size_t v16 = v13;
    }
    else {
      size_t v16 = (v15 - v14);
    }
    int v17 = *(_DWORD *)(a1 + 40);
    if (v17 < 0)
    {
      uint64_t v19 = *(void *)(a1 + 48) + v14;
    }
    else
    {
      ssize_t v18 = pread(v17, v9, v16, *(void *)(a1 + 56) + v14);
      if (v18 < 0)
      {
        int v21 = *__error();
        int v10 = "reading data segment";
        __int16 v11 = 82;
        goto LABEL_26;
      }
      uint64_t v19 = (uint64_t)v9;
      if (v16 != v18)
      {
        LOBYTE(v23) = v18;
        int v10 = "Truncated read n=%zd pos=%llu read=%llu %s";
        __int16 v11 = 83;
        goto LABEL_25;
      }
    }
    uint64_t v20 = *(unsigned int *)(a1 + 32);
    if (i * v20 + v20 > *(void *)(a1 + 80))
    {
      int v10 = "Parity buffer out of range";
      __int16 v11 = 94;
      goto LABEL_25;
    }
    if (*(_DWORD *)(a1 + 24) != 1)
    {
      int v23 = *(_DWORD *)(a1 + 24);
      int v10 = "invalid variant %u";
      __int16 v11 = 101;
      goto LABEL_25;
    }
    if (ECC65537GetParity(v16, v19, *(void *)(a1 + 72) + i * v20))
    {
      LOBYTE(v23) = i;
      int v10 = "generating parity block %llu\n";
      __int16 v11 = 99;
      goto LABEL_25;
    }
  }
LABEL_27:
  free(v9);
  return 0;
}

uint64_t ECCFixThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_DWORD *)(a1 + 40) & 0x80000000) != 0)
  {
    int v9 = 0;
  }
  else
  {
    int v9 = malloc(*(unsigned int *)(a1 + 28));
    if (!v9)
    {
      int v10 = "creating workBuffer";
      __int16 v11 = 157;
LABEL_31:
      int v25 = 0;
LABEL_32:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ECCFixThreadProc", v11, 64, v25, v10, a7, a8, v27);
      goto LABEL_33;
    }
  }
  for (unint64_t i = *(void *)(a1 + 8); i < *(void *)(a1 + 16); ++i)
  {
    uint64_t v13 = *(unsigned int *)(a1 + 28);
    uint64_t v14 = i * v13;
    unint64_t v15 = *(void *)(a1 + 64);
    if (v15 < i * v13)
    {
      int v10 = "Invalid block index";
      __int16 v11 = 166;
      goto LABEL_31;
    }
    if (v14 + v13 <= v15) {
      size_t v16 = v13;
    }
    else {
      size_t v16 = (v15 - v14);
    }
    int v17 = *(_DWORD *)(a1 + 40);
    if (v17 < 0)
    {
      uint64_t v19 = *(void *)(a1 + 48) + v14;
    }
    else
    {
      ssize_t v18 = pread(v17, v9, v16, *(void *)(a1 + 56) + v14);
      if (v18 < 0)
      {
        int v25 = *__error();
        int v10 = "reading data segment";
        __int16 v11 = 174;
        goto LABEL_32;
      }
      uint64_t v19 = (uint64_t)v9;
      if (v16 != v18)
      {
        LOBYTE(v27) = v18;
        int v10 = "Truncated read n=%zd pos=%llu read=%u fd=%d";
        __int16 v11 = 175;
        goto LABEL_31;
      }
    }
    uint64_t v20 = *(unsigned int *)(a1 + 32);
    if (i * v20 + v20 > *(void *)(a1 + 80))
    {
      int v10 = "Parity buffer out of range";
      __int16 v11 = 187;
      goto LABEL_31;
    }
    if (*(_DWORD *)(a1 + 24) != 1)
    {
      int v27 = *(_DWORD *)(a1 + 24);
      int v10 = "invalid variant %u";
      __int16 v11 = 205;
      goto LABEL_31;
    }
    uint64_t v28 = 0;
    int v21 = ECC65537CheckAndFix(v16, v19, (uint16x8_t *)(*(void *)(a1 + 72) + i * v20), &v28);
    if (v21 < 0)
    {
      ++*(void *)(a1 + 88);
    }
    else if (v21)
    {
      ++*(void *)(a1 + 96);
      v22.i64[0] = v28;
      v22.i64[1] = HIDWORD(v28);
      *(int64x2_t *)(a1 + 104) = vaddq_s64(*(int64x2_t *)(a1 + 104), (int64x2_t)vextq_s8(v22, v22, 8uLL));
      int v23 = *(_DWORD *)(a1 + 40);
      if ((v23 & 0x80000000) == 0)
      {
        ssize_t v24 = pwrite(v23, v9, v16, *(void *)(a1 + 56) + v14);
        if (v24 < 0)
        {
          int v25 = *__error();
          int v10 = "writing data segment";
          __int16 v11 = 211;
          goto LABEL_32;
        }
        if (v16 != v24)
        {
          LOBYTE(v27) = v24;
          int v10 = "Truncated write n=%zd pos=%llu read=%u fd=%d";
          __int16 v11 = 212;
          goto LABEL_31;
        }
      }
    }
  }
LABEL_33:
  free(v9);
  return 0;
}

unint64_t ParallelArchiveECCGenerateCommon(int a1, uint64_t a2, off_t a3, unint64_t a4, uint64_t a5, unint64_t a6, int *a7)
{
  uint64_t v80 = *MEMORY[0x263EF8340];
  unsigned int DefaultNThreads = a7[1];
  if (!DefaultNThreads) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  unsigned int v15 = a7[4];
  if (v15) {
    unint64_t v16 = v15;
  }
  else {
    unint64_t v16 = 0x4000;
  }
  int v17 = *a7;
  long long v78 = 0uLL;
  int v79 = 0;
  long long v76 = 0uLL;
  int v77 = 0;
  double RealTime = getRealTime();
  enterThreadErrorContext(v19, v20, v21, v22, v23, v24, v25, v26, v66);
  if (a7[3] != 1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCGenerateCommon", 262, 64, 0, "Invalid ECC variant: %u", v27, v28, a7[3]);
    goto LABEL_10;
  }
  if (v16 >= 0x1FFE1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCGenerateCommon", 258, 64, 0, "Invalid blockSize: %u", v27, v28, v16);
LABEL_10:
    unint64_t v29 = 0;
LABEL_11:
    char v30 = 0;
LABEL_12:
    int v31 = 1;
    goto LABEL_13;
  }
  uint64_t v72 = a2;
  off_t v73 = a3;
  unint64_t v37 = (a4 + v16 - 1) / v16;
  unint64_t v29 = 34 * v37 + 48;
  if (!a5 && !a6)
  {
    int v31 = 0;
    char v30 = 0;
    goto LABEL_13;
  }
  if (v29 > a6)
  {
    char v67 = 34 * v37 + 48;
    char v38 = "Output buffer too small, %zu B required, %zu B provided";
    __int16 v39 = 273;
LABEL_31:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCGenerateCommon", v39, 64, 0, v38, v27, v28, v67);
    goto LABEL_11;
  }
  if (v37 >= DefaultNThreads) {
    LODWORD(v40) = DefaultNThreads;
  }
  else {
    LODWORD(v40) = (a4 + v16 - 1) / v16;
  }
  if (v40 <= 1) {
    uint64_t v40 = 1;
  }
  else {
    uint64_t v40 = v40;
  }
  unint64_t v74 = v40;
  if (a1 < 0)
  {
    if ((getBufferSHA1Digest(v72, a4, (unsigned __int8 *)&v78) & 0x80000000) != 0)
    {
      char v38 = "computing buffer digest";
      __int16 v39 = 287;
      goto LABEL_31;
    }
  }
  else if ((getFileSegmentSHA1DigestFD(a1, v73, a4, (uint64_t)&v78) & 0x80000000) != 0)
  {
    char v38 = "computing file digest";
    __int16 v39 = 283;
    goto LABEL_31;
  }
  size_t v41 = v74;
  unint64_t v42 = (v37 + v74 - 1) / v74;
  int v69 = v17;
  if (v17 >= 1)
  {
    memset(v75, 0, sizeof(v75));
    sha1ToString((uint64_t)v75, (uint64_t)&v78);
    int v43 = (FILE **)MEMORY[0x263EF8348];
    fwrite("ParallelArchiveECCGenerateCommon:\n", 0x22uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    fprintf(*v43, "  Input data SHA1: %s\n", (const char *)v75);
    fwrite("  ECC variant: ", 0xFuLL, 1uLL, *v43);
    if (a7[3] == 1) {
      fwrite("RS65537\n", 8uLL, 1uLL, *v43);
    }
    fprintf(*v43, "%12llu data size\n", a4);
    fprintf(*v43, "%12u block size\n", v16);
    fprintf(*v43, "%12u ECC parity size per block\n", 34);
    fprintf(*v43, "%11.2f%% parity/data ratio\n", 3400.0 / (double)v16);
    fprintf(*v43, "%12zu block count\n", (a4 + v16 - 1) / v16);
    fprintf(*v43, "%12zu ECC buffer size\n", 34 * v37 + 48);
    fprintf(*v43, "%12u worker threads\n", v74);
    fprintf(*v43, "%12zu blocks per thread\n", v42);
    size_t v41 = v74;
  }
  char v30 = (char *)calloc(v41, 0x58uLL);
  if (!v30)
  {
    uint64_t v63 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCGenerateCommon", 313, 64, *v63, "malloc %u threads", v64, v65, v74);
    goto LABEL_12;
  }
  uint64_t v44 = 0;
  uint64_t v45 = a5;
  uint64_t v46 = 0;
  uint64_t v68 = v45;
  uint64_t v71 = v45 + 48;
  int v70 = 1;
  do
  {
    unint64_t v47 = v42 * v46;
    if (v42 * v46 < v37)
    {
      unint64_t v48 = v47 + v42;
      if (v47 + v42 >= v37) {
        unint64_t v48 = (a4 + v16 - 1) / v16;
      }
      int v49 = &v30[v44];
      *((void *)v49 + 1) = v47;
      *((void *)v49 + 2) = v48;
      *((_DWORD *)v49 + 7) = v16;
      *((_DWORD *)v49 + 10) = a1;
      *((void *)v49 + 6) = v72;
      *((void *)v49 + 7) = v73;
      *((void *)v49 + 8) = a4;
      *((void *)v49 + 9) = v71;
      *((void *)v49 + 10) = 34 * v37;
      *((_DWORD *)v49 + 6) = a7[3];
      *((void *)v49 + 4) = 34;
      if (createThread((pthread_t *)&v30[v44], (uint64_t)ECCGenerateThreadProc, (uint64_t)&v30[v44], 0))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCGenerateCommon", 336, 64, 0, "createThread", v50, v51, v67);
        int v70 = 0;
      }
    }
    ++v46;
    v44 += 88;
  }
  while (88 * v74 != v44);
  uint64_t v52 = 0;
  unint64_t v53 = v74;
  while (2)
  {
    uint64_t v54 = 88 * v52;
    while (1)
    {
      uint64_t v55 = *(_opaque_pthread_t **)&v30[v54];
      if (v55)
      {
        int v56 = joinThread(v55);
        unint64_t v53 = v74;
        if (v56) {
          break;
        }
      }
      ++v52;
      v54 += 88;
      if (v53 == v52)
      {
        int v17 = v69;
        if (v70)
        {
          int v31 = 0;
          long long v60 = v78;
          long long v76 = v78;
          int v61 = v79;
          int v77 = v79;
          int v62 = a7[3];
          a5 = v68;
          *(void *)uint64_t v68 = 0x3031304343455842;
          *(void *)(v68 + 8) = a4;
          *(_OWORD *)(v68 + 16) = v60;
          *(_DWORD *)(v68 + 32) = v61;
          *(_DWORD *)(v68 + 36) = v62;
          *(_DWORD *)(v68 + 40) = v16;
          *(_DWORD *)(v68 + 44) = 0;
        }
        else
        {
          int v31 = 1;
          a5 = v68;
        }
        goto LABEL_13;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCGenerateCommon", 343, 64, 0, "joinThread", v57, v58, v67);
    int v70 = 0;
    int v31 = 1;
    BOOL v59 = v74 - 1 == v52++;
    unint64_t v53 = v74;
    if (!v59) {
      continue;
    }
    break;
  }
  a5 = v68;
  int v17 = v69;
LABEL_13:
  free(v30);
  int v32 = leaveThreadErrorContext(0, 0, 0);
  if (v32 < 0) {
    return v32;
  }
  int v33 = v17;
  if (v31) {
    int v34 = -1;
  }
  else {
    int v34 = v32;
  }
  if (a5 && v31 != 1 && v33 >= 1)
  {
    double v35 = getRealTime();
    fprintf((FILE *)*MEMORY[0x263EF8348], "Total time %.2fs, %.2f MB/s\n", v35 - RealTime, (double)a4 * 0.000000953674316 / (v35 - RealTime));
    if ((v31 & 1) == 0) {
      return v29;
    }
    return v34;
  }
  if (v31) {
    return v34;
  }
  return v29;
}

unint64_t ParallelArchiveECCGenerateFromFileSegment(int a1, off_t a2, unint64_t a3, uint64_t a4, unint64_t a5, int *a6)
{
  return ParallelArchiveECCGenerateCommon(a1, 0, a2, a3, a4, a5, a6);
}

uint64_t ParallelArchiveECCFixFileSegment(int a1, off_t a2, unint64_t a3, long long *a4, unint64_t a5, uint64_t a6)
{
  return ParallelArchiveECCFixCommon(a1, 0, a2, a3, a4, a5, a6);
}

unint64_t ParallelArchiveECCGenerateFromBuffer(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, int *a5)
{
  return ParallelArchiveECCGenerateCommon(-1, a1, 0, a2, a3, a4, a5);
}

uint64_t ParallelArchiveECCFixBuffer(uint64_t a1, unint64_t a2, long long *a3, unint64_t a4, uint64_t a5)
{
  return ParallelArchiveECCFixCommon(-1, a1, 0, a2, a3, a4, a5);
}

uint64_t ParallelArchiveECCFixCommon(int a1, uint64_t a2, off_t a3, unint64_t a4, long long *a5, unint64_t a6, uint64_t a7)
{
  uint64_t v114 = *MEMORY[0x263EF8340];
  unsigned int DefaultNThreads = *(_DWORD *)(a7 + 4);
  if (!DefaultNThreads) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  int v91 = *(_DWORD *)a7;
  uint64_t v111 = 0;
  uint64_t v112 = 0;
  int v113 = 0;
  long long v109 = 0u;
  long long v110 = 0u;
  long long v108 = 0u;
  double RealTime = getRealTime();
  *(void *)(a7 + 16) = 0;
  *(_DWORD *)(a7 + 12) = 0;
  enterThreadErrorContext(v16, v17, v18, v19, v20, v21, v22, v23, v81);
  unint64_t v90 = a4;
  if (a6 <= 0x2F)
  {
    uint64_t v26 = "Truncated ECC buffer";
    __int16 v27 = 452;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", v27, 64, 0, v26, v24, v25, v82);
LABEL_10:
    int v29 = 0;
    unint64_t v30 = 0;
    unint64_t v31 = 0;
    unint64_t v32 = 0;
    unint64_t v33 = 0;
    unsigned int v34 = 0;
    int v35 = 0;
    goto LABEL_11;
  }
  long long v28 = a5[1];
  long long v108 = *a5;
  long long v109 = v28;
  long long v110 = a5[2];
  if ((void)v108 != 0x3031304343455842)
  {
    uint64_t v26 = "Invalid ECC magic";
    __int16 v27 = 454;
    goto LABEL_9;
  }
  if (HIDWORD(v110))
  {
    uint64_t v26 = "Invalid ECC header";
    __int16 v27 = 455;
    goto LABEL_9;
  }
  unsigned int v89 = DWORD2(v110);
  if (!DWORD2(v110))
  {
    uint64_t v26 = "Invalid ECC header";
    __int16 v27 = 456;
    goto LABEL_9;
  }
  if (*((void *)&v108 + 1) != a4)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 457, 64, 0, "Input buffer size mismatch: expected %llu B, got %llu B", v24, v25, SBYTE8(v108));
    goto LABEL_10;
  }
  int v35 = DWORD1(v110);
  if (DWORD1(v110) != 1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 476, 64, 0, "Invalid ECC variant: %u", v24, v25, SBYTE4(v110));
    int v29 = 0;
    unint64_t v30 = 0;
    unint64_t v31 = 0;
    unint64_t v32 = 0;
    unint64_t v33 = 0;
LABEL_55:
    unsigned int v34 = v89;
    goto LABEL_11;
  }
  if (DWORD2(v110) >= 0x1FFE1)
  {
    unsigned int v34 = DWORD2(v110);
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 472, 64, 0, "Invalid blockSize: %u", v24, v25, SBYTE8(v110));
    int v29 = 0;
    unint64_t v30 = 0;
    unint64_t v31 = 0;
    unint64_t v32 = 0;
    unint64_t v33 = 0;
    int v35 = 1;
    goto LABEL_11;
  }
  unint64_t v49 = (a4 + DWORD2(v110) - 1) / DWORD2(v110);
  uint64_t v84 = 34 * v49;
  if (34 * v49 + 48 != a6)
  {
    uint64_t v52 = "Invalid ECC buffer size";
    __int16 v53 = 481;
    goto LABEL_52;
  }
  unint64_t v86 = (a4 + DWORD2(v110) - 1) / DWORD2(v110);
  if (v49 >= DefaultNThreads) {
    unsigned int v50 = DefaultNThreads;
  }
  else {
    unsigned int v50 = (a4 + DWORD2(v110) - 1) / DWORD2(v110);
  }
  if (v50 <= 1) {
    size_t v51 = 1;
  }
  else {
    size_t v51 = v50;
  }
  if (a1 < 0)
  {
    if ((getBufferSHA1Digest(a2, a4, (unsigned __int8 *)&v111) & 0x80000000) != 0)
    {
      uint64_t v52 = "computing buffer digest";
      __int16 v53 = 495;
      goto LABEL_52;
    }
  }
  else if ((getFileSegmentSHA1DigestFD(a1, a3, a4, (uint64_t)&v111) & 0x80000000) != 0)
  {
    uint64_t v52 = "computing file digest";
    __int16 v53 = 491;
LABEL_52:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", v53, 64, 0, v52, v24, v25, v82);
    int v29 = 0;
    unint64_t v30 = 0;
LABEL_53:
    unint64_t v31 = 0;
    unint64_t v32 = 0;
    unint64_t v33 = 0;
LABEL_54:
    int v35 = 1;
    goto LABEL_55;
  }
  unint64_t v87 = (v86 + v51 - 1) / v51;
  if (v91 >= 1)
  {
    long long v106 = 0u;
    long long v107 = 0u;
    long long v104 = 0u;
    long long v105 = 0u;
    long long v102 = 0u;
    long long v103 = 0u;
    long long v100 = 0u;
    long long v101 = 0u;
    long long v98 = 0u;
    long long v99 = 0u;
    long long v96 = 0u;
    long long v97 = 0u;
    long long v94 = 0u;
    long long v95 = 0u;
    long long v92 = 0u;
    long long v93 = 0u;
    uint64_t v54 = (FILE **)MEMORY[0x263EF8348];
    fwrite("ParallelArchiveECCFixCommon:\n", 0x1DuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    sha1ToString((uint64_t)&v92, (uint64_t)&v111);
    fprintf(*v54, "  Input data SHA1: %s\n", (const char *)&v92);
    sha1ToString((uint64_t)&v92, (uint64_t)&v109);
    fprintf(*v54, "  Expected SHA1: %s\n", (const char *)&v92);
    fwrite("  ECC variant: ", 0xFuLL, 1uLL, *v54);
    fwrite("RS65537\n", 8uLL, 1uLL, *v54);
    fprintf(*v54, "%12llu data size\n", a4);
    fprintf(*v54, "%12u block size\n", v89);
    fprintf(*v54, "%12u ECC parity size per block\n", 34);
    fprintf(*v54, "%11.2f%% parity/data ratio\n", 3400.0 / (double)v89);
    fprintf(*v54, "%12zu block count\n", v86);
    fprintf(*v54, "%12zu ECC buffer size\n", a6);
    fprintf(*v54, "%12u worker threads\n", v51);
    fprintf(*v54, "%12zu blocks per thread\n", v87);
  }
  if (v111 == (void)v109 && v112 == *((void *)&v109 + 1) && v113 == (unint64_t)v110)
  {
    unint64_t v30 = 0;
    unint64_t v31 = 0;
    unint64_t v32 = 0;
    unint64_t v33 = 0;
    int v29 = 1;
    goto LABEL_54;
  }
  uint64_t v57 = calloc(v51, 0x78uLL);
  unint64_t v30 = (unint64_t)v57;
  if (!v57)
  {
    uint64_t v72 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 526, 64, *v72, "malloc %u threads", v73, v74, v51);
    int v29 = 0;
    goto LABEL_53;
  }
  uint64_t v58 = 0;
  uint64_t v83 = a5 + 3;
  size_t v59 = v51;
  uint64_t v60 = (uint64_t)v57;
  int v29 = 1;
  unint64_t v61 = (v86 + v51 - 1) / v51;
  do
  {
    unint64_t v62 = v61 * v58;
    if (v61 * v58 < v86)
    {
      unint64_t v63 = v62 + v87;
      if (v62 + v87 >= v86) {
        unint64_t v63 = v86;
      }
      *(void *)(v60 + 8) = v62;
      *(void *)(v60 + 16) = v63;
      *(_DWORD *)(v60 + 40) = a1;
      *(void *)(v60 + 48) = a2;
      *(void *)(v60 + 56) = a3;
      *(void *)(v60 + 64) = v90;
      *(void *)(v60 + 72) = v83;
      *(void *)(v60 + 80) = v84;
      *(_DWORD *)(v60 + 24) = 1;
      *(_DWORD *)(v60 + 28) = v89;
      *(void *)(v60 + 32) = 34;
      int Thread = createThread((pthread_t *)v60, (uint64_t)ECCFixThreadProc, v60, 0);
      unint64_t v61 = (v86 + v51 - 1) / v51;
      if (Thread)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 549, 64, 0, "createThread", v65, v66, v82);
        unint64_t v61 = (v86 + v51 - 1) / v51;
        int v29 = 0;
      }
    }
    ++v58;
    v60 += 120;
    --v59;
  }
  while (v59);
  int64x2_t v67 = 0uLL;
  int64x2_t v68 = 0uLL;
  do
  {
    if (*(void *)v30)
    {
      int64x2_t v85 = v68;
      int64x2_t v88 = v67;
      if (joinThread(*(_opaque_pthread_t **)v30))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 556, 64, 0, "joinThread", v69, v70, v82);
        int v29 = 0;
      }
      int64x2_t v68 = vaddq_s64(*(int64x2_t *)(v30 + 104), v85);
      int64x2_t v67 = vaddq_s64(*(int64x2_t *)(v30 + 88), v88);
    }
    v30 += 120;
    --v51;
  }
  while (v51);
  unint64_t v32 = v67.u64[1];
  unint64_t v33 = v67.i64[0];
  unint64_t v30 = v68.u64[1];
  unint64_t v71 = v68.i64[0];
  if (v67.i64[0]) {
    goto LABEL_81;
  }
  if (a1 < 0)
  {
    if ((getBufferSHA1Digest(a2, v90, (unsigned __int8 *)&v111) & 0x80000000) != 0)
    {
      int v77 = "computing buffer digest";
      __int16 v78 = 574;
      goto LABEL_102;
    }
  }
  else if ((getFileSegmentSHA1DigestFD(a1, a3, v90, (uint64_t)&v111) & 0x80000000) != 0)
  {
    int v77 = "computing file digest";
    __int16 v78 = 570;
LABEL_102:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", v78, 64, 0, v77, v75, v76, v82);
    int v29 = 0;
    unint64_t v33 = 0;
LABEL_81:
    int v35 = 1;
    unsigned int v34 = v89;
LABEL_82:
    unint64_t v31 = v71;
    goto LABEL_11;
  }
  unsigned int v34 = v89;
  if (v91 >= 1)
  {
    long long v106 = 0u;
    long long v107 = 0u;
    long long v104 = 0u;
    long long v105 = 0u;
    long long v102 = 0u;
    long long v103 = 0u;
    long long v100 = 0u;
    long long v101 = 0u;
    long long v98 = 0u;
    long long v99 = 0u;
    long long v96 = 0u;
    long long v97 = 0u;
    long long v94 = 0u;
    long long v95 = 0u;
    long long v92 = 0u;
    long long v93 = 0u;
    sha1ToString((uint64_t)&v92, (uint64_t)&v111);
    fprintf((FILE *)*MEMORY[0x263EF8348], "  Output data SHA1: %s\n", (const char *)&v92);
    sha1ToString((uint64_t)&v92, (uint64_t)&v109);
  }
  if (v111 == (void)v109 && v112 == *((void *)&v109 + 1) && v113 == (unint64_t)v110)
  {
    unint64_t v33 = 0;
    int v35 = 1;
    goto LABEL_82;
  }
  unint64_t v30 = 0;
  unint64_t v31 = 0;
  unint64_t v32 = 0;
  int v35 = 1;
  unint64_t v33 = v86;
LABEL_11:
  uint64_t result = leaveThreadErrorContext(0, 0, 0);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  if (!v29) {
    return 0xFFFFFFFFLL;
  }
  int v37 = 0x7FFF;
  if (v30 < 0x7FFF) {
    int v37 = v30;
  }
  int v38 = v37 << 8;
  int v39 = 255;
  if (v32 < 0xFF) {
    int v39 = v32;
  }
  int v40 = v38 | v39;
  int v41 = 255;
  if (v33 < 0xFF) {
    int v41 = v33;
  }
  int v42 = v38 | v41 | 0x800000;
  if (v33) {
    int v43 = v42;
  }
  else {
    int v43 = v40;
  }
  if (v91 <= 0)
  {
    *(_DWORD *)(a7 + 12) = v35;
    *(_DWORD *)(a7 + 16) = v34;
    *(_DWORD *)(a7 + 20) = v43;
    if (v33) {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    unsigned int v44 = v34;
    uint64_t v45 = (FILE **)MEMORY[0x263EF8348];
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12llu fixed blocks\n", v32);
    unint64_t v46 = v31;
    fprintf(*v45, "%12llu fixed bytes\n", v31);
    fprintf(*v45, "%12llu fixed bits\n", v30);
    if (v33)
    {
      fprintf(*v45, "%12llu INVALID BLOCKS\n", v33);
      unint64_t v47 = "FAIL";
    }
    else
    {
      unint64_t v47 = "OK";
    }
    fprintf(*v45, "    0x%06x diagnostic code\n", v43);
    *(_DWORD *)(a7 + 12) = v35;
    *(_DWORD *)(a7 + 16) = v44;
    *(_DWORD *)(a7 + 20) = v43;
    double v48 = getRealTime();
    fprintf(*v45, "Total time %.2fs, %.2f MB/s (%s)\n", v48 - RealTime, (double)v90 * 0.000000953674316 / (v48 - RealTime), v47);
    unint64_t v31 = v46;
    if (v33) {
      return 0xFFFFFFFFLL;
    }
  }
  if (v31 >= 0x7FFFFFFF) {
    return 0x7FFFFFFFLL;
  }
  else {
    return v31;
  }
}

uint64_t ParallelArchiveECCVerifyBuffer(uint64_t a1, unint64_t a2, long long *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return ParallelArchiveECCVerifyCommon(-1, a1, 0, a2, a3, a4, a7, a8);
}

uint64_t ParallelArchiveECCVerifyCommon(int a1, uint64_t a2, off_t a3, unint64_t a4, long long *a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  int v18 = 0;
  if (a6 <= 0x2F)
  {
    unint64_t v8 = "Truncated ECC buffer";
    __int16 v9 = 390;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCVerifyCommon", v9, 64, 0, v8, a7, a8, v13);
    return 0xFFFFFFFFLL;
  }
  long long v13 = *a5;
  long long v14 = a5[1];
  long long v15 = a5[2];
  if (*(void *)a5 != 0x3031304343455842)
  {
    unint64_t v8 = "Invalid ECC magic";
    __int16 v9 = 392;
    goto LABEL_7;
  }
  if (HIDWORD(v15))
  {
    unint64_t v8 = "Invalid ECC header";
    __int16 v9 = 393;
    goto LABEL_7;
  }
  if (!DWORD2(v15))
  {
    unint64_t v8 = "Invalid ECC header";
    __int16 v9 = 394;
    goto LABEL_7;
  }
  if (*((void *)&v13 + 1) != a4) {
    return 0;
  }
  if (a1 < 0)
  {
    if ((getBufferSHA1Digest(a2, a4, (unsigned __int8 *)&v16) & 0x80000000) != 0)
    {
      unint64_t v8 = "computing buffer digest";
      __int16 v9 = 404;
      goto LABEL_7;
    }
  }
  else if ((getFileSegmentSHA1DigestFD(a1, a3, a4, (uint64_t)&v16) & 0x80000000) != 0)
  {
    unint64_t v8 = "computing file digest";
    __int16 v9 = 400;
    goto LABEL_7;
  }
  return v16 == (void)v14 && v17 == *((void *)&v14 + 1) && v18 == (unint64_t)v15;
}

uint64_t ParallelArchiveECCVerifyFileSegment(int a1, off_t a2, unint64_t a3, long long *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return ParallelArchiveECCVerifyCommon(a1, 0, a2, a3, a4, a5, a7, a8);
}

void *OECCStreamCreate(int a1, unsigned int a2, uint64_t a3)
{
  uint64_t v6 = calloc(1uLL, 0xB0uLL);
  unint64_t v7 = v6;
  if (v6)
  {
    *(_DWORD *)uint64_t v6 = a1;
    _OWORD v6[4] = a3;
    *((_DWORD *)v6 + 10) = a2;
    unint64_t v8 = malloc(a2);
    v7[8] = v8;
    if (v8)
    {
      if (a1 != 1)
      {
        __int16 v11 = "Invalid ECC algorithm";
        __int16 v12 = 857;
        goto LABEL_9;
      }
      if (a2 >= 0x1FFE1)
      {
        __int16 v11 = "Invalid ECC block size";
        __int16 v12 = 853;
LABEL_9:
        int v13 = 0;
        goto LABEL_10;
      }
      *((_DWORD *)v7 + 6) = 34;
      size_t v15 = 34 * ((a3 + (unint64_t)a2 - 1) / a2) + 48;
      v7[2] = v15;
      uint64_t v16 = malloc(v15);
      v7[1] = v16;
      if (v16)
      {
        CC_SHA1_Deprecated_Init((CC_SHA1_CTX *)((char *)v7 + 76));
        v7[7] = 48;
        checkEOF((int *)v7);
        return v7;
      }
      int v13 = *__error();
      __int16 v11 = "malloc";
      __int16 v12 = 862;
    }
    else
    {
      int v13 = *__error();
      __int16 v11 = "malloc";
      __int16 v12 = 846;
    }
  }
  else
  {
    int v13 = *__error();
    __int16 v11 = "malloc";
    __int16 v12 = 841;
  }
LABEL_10:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"OECCStreamCreate", v12, 64, v13, v11, v9, v10, v17);
  OECCStreamDestroy((void **)v7);
  return 0;
}

int *checkEOF(int *result)
{
  if (*((void *)result + 6) == *((void *)result + 4) && !result[43])
  {
    result[43] = 1;
    uint64_t v1 = *((void *)result + 1);
    *(void *)uint64_t v1 = 0x3031304343455842;
    int v2 = *result;
    *(void *)(v1 + 8) = *((void *)result + 4);
    *(_DWORD *)(v1 + 44) = 0;
    int v3 = result[10];
    *(_DWORD *)(v1 + 36) = v2;
    *(_DWORD *)(v1 + 40) = v3;
    return (int *)CC_SHA1_Deprecated_Final((unsigned __int8 *)(v1 + 16), (CC_SHA1_CTX *)(result + 19));
  }
  return result;
}

void OECCStreamDestroy(void **a1)
{
  if (a1)
  {
    free(a1[8]);
    free(a1[1]);
    free(a1);
  }
}

uint64_t OECCStreamGetDataPtr(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 172)) {
    return *(void *)(a1 + 8);
  }
  else {
    return 0;
  }
}

uint64_t OECCStreamGetDataSize(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 172)) {
    return *(void *)(a1 + 16);
  }
  else {
    return 0;
  }
}

uint64_t OECCStreamWrite(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 48);
  BOOL v9 = __CFADD__(v8, a3);
  unint64_t v10 = v8 + a3;
  int v11 = v9;
  if (v10 <= *(void *)(a1 + 32) && v11 == 0)
  {
    uint64_t v16 = a3;
    char v17 = a2;
    CC_SHA1_Deprecated_Update((CC_SHA1_CTX *)(a1 + 76), a2, a3);
    uint64_t v15 = 0;
    if (v16)
    {
      unsigned int v19 = *(_DWORD *)(a1 + 72);
      do
      {
        unint64_t v20 = *(unsigned int *)(a1 + 40);
        size_t v21 = v16 + (unint64_t)v19 <= v20 ? v16 : v20 - v19;
        memcpy((void *)(*(void *)(a1 + 64) + v19), v17, v21);
        unsigned int v22 = *(_DWORD *)(a1 + 72) + v21;
        *(_DWORD *)(a1 + 72) = v22;
        size_t v23 = *(void *)(a1 + 48) + v21;
        *(void *)(a1 + 48) = v23;
        v15 += v21;
        if (v22 < *(_DWORD *)(a1 + 40) && v23 < *(void *)(a1 + 32)) {
          break;
        }
        uint64_t v24 = *(void *)(a1 + 56);
        if (v24 + (unint64_t)*(unsigned int *)(a1 + 24) > *(void *)(a1 + 16))
        {
          int v13 = "ECC buffer overflow";
          __int16 v14 = 914;
          goto LABEL_9;
        }
        if (*(_DWORD *)a1 != 1)
        {
          int v13 = "Invalid ECC algorithm";
          __int16 v14 = 921;
          goto LABEL_9;
        }
        if ((ECC65537GetParity(v22, *(void *)(a1 + 64), *(void *)(a1 + 8) + v24) & 0x80000000) != 0)
        {
          int v13 = "ECC generation failed";
          __int16 v14 = 918;
          goto LABEL_9;
        }
        unsigned int v19 = 0;
        v17 += v21;
        *(void *)(a1 + 56) += *(unsigned int *)(a1 + 24);
        *(_DWORD *)(a1 + 72) = 0;
        v16 -= v21;
      }
      while (v16);
    }
    checkEOF((int *)a1);
  }
  else
  {
    int v13 = "Too many bytes received";
    __int16 v14 = 892;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"OECCStreamWrite", v14, 64, 0, v13, a7, a8, v26);
    return -1;
  }
  return v15;
}

uint64_t ParallelCompressionOStreamCreate(uint64_t a1)
{
  uint64_t v3 = OEncoderStreamCreate(*(void *)(a1 + 32), *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 8), *(_DWORD *)(a1 + 4), *(void *)(a1 + 16), *(_DWORD *)a1);
  if (!v3) {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Streams.c", (uint64_t)"ParallelCompressionOStreamCreate", 20, 45, 0, "creating encoder failed", v1, v2, v5);
  }
  return v3;
}

uint64_t *ParallelCompressionIStreamCreate(uint64_t a1)
{
  uint64_t v2 = (uint64_t *)malloc(0x10uLL);
  uint64_t v3 = v2;
  if (v2)
  {
    *uint64_t v2 = 0;
    v2[1] = 0;
    BOOL v4 = *(uint64_t (**)(uint64_t, uint64_t, unint64_t))(a1 + 24);
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 40);
    size_t v7 = *(void *)(a1 + 8);
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v14 = ILowMemoryDecoderStreamCreate(v4, v5, v6, v7);
      v3[1] = v14;
      if (!v14)
      {
LABEL_7:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Streams.c", (uint64_t)"ParallelCompressionIStreamCreate", 63, 45, 0, "creating decoder failed", v9, v10, v16);
        free(v3);
        return 0;
      }
    }
    else
    {
      uint64_t v8 = IDecoderStreamCreate((uint64_t)v4, v5, v6, v7, *(_DWORD *)a1);
      *uint64_t v3 = v8;
      if (!v8) {
        goto LABEL_7;
      }
    }
  }
  else
  {
    int v11 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Streams.c", (uint64_t)"ParallelCompressionIStreamCreate", 51, 45, *v11, "malloc", v12, v13, v16);
  }
  return v3;
}

uint64_t ParallelCompressionIStreamRead(uint64_t *a1, char *a2, size_t a3)
{
  if (!a1) {
    return -1;
  }
  if (a1[1]) {
    return ILowMemoryDecoderStreamRead(a1[1], a2, a3);
  }
  return IDecoderStreamRead(*a1, (uint64_t)a2, a3);
}

size_t ParallelCompressionIStreamAbort(size_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (result)
  {
    if (*(void *)(result + 8)) {
      return ILowMemoryDecoderStreamAbort(*(void *)(result + 8));
    }
    else {
      return IDecoderStreamAbort(*(void *)result, a2, a3, a4, a5, a6, a7, a8, a9);
    }
  }
  return result;
}

void ParallelCompressionIStreamDestroy(void **a1)
{
  if (a1)
  {
    ILowMemoryDecoderStreamDestroy((uint64_t)a1[1]);
    IDecoderStreamDestroy(*a1);
    free(a1);
  }
}

void **MemBufferCreate(size_t a1)
{
  uint64_t v2 = (void **)malloc(0x28uLL);
  uint64_t v3 = v2;
  if (v2)
  {
    void v2[4] = 0;
    *(_OWORD *)uint64_t v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    if ((MemBufferIncreaseCapacity((uint64_t)v2, a1) & 0x8000000000000000) != 0)
    {
      free(v3[4]);
      free(v3);
      return 0;
    }
  }
  else
  {
    BOOL v4 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferCreate", 41, 36, *v4, "malloc", v5, v6, v8);
  }
  return v3;
}

unint64_t MemBufferIncreaseCapacity(uint64_t a1, size_t a2)
{
  unint64_t result = *(void *)a1;
  if (result < a2)
  {
    uint64_t v5 = reallocf(*(void **)(a1 + 32), a2);
    *(void *)(a1 + 32) = v5;
    if (v5)
    {
      *(void *)a1 = a2;
      return a2;
    }
    else
    {
      uint64_t v6 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferIncreaseCapacity", 91, 36, *v6, "malloc", v7, v8, v9);
      return -1;
    }
  }
  return result;
}

void MemBufferDestroy(void **a1)
{
  if (a1)
  {
    free(a1[4]);
    free(a1);
  }
}

void **MemBufferCreateWithData(size_t a1, const void *a2)
{
  BOOL v4 = MemBufferCreate(a1);
  uint64_t v5 = v4;
  if (v4)
  {
    memcpy(v4[4], a2, a1);
    v5[1] = (void *)a1;
    v5[2] = 0;
    v5[3] = (void *)a1;
  }
  return v5;
}

uint64_t MemBufferGetDataSize(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t MemBufferGetFreeSize(void *a1)
{
  return *a1 - a1[1];
}

uint64_t MemBufferGetDataPtr(uint64_t a1)
{
  return *(void *)(a1 + 32) + *(void *)(a1 + 16);
}

uint64_t MemBufferGetFreePtr(uint64_t a1)
{
  size_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      memmove(*(void **)(a1 + 32), (const void *)(*(void *)(a1 + 32) + v3), v2);
      uint64_t v4 = *(void *)(a1 + 8);
      *(void *)(a1 + 16) = 0;
      *(void *)(a1 + 24) = v4;
    }
  }
  return *(void *)(a1 + 32) + *(void *)(a1 + 24);
}

uint64_t MemBufferDecreaseSize(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9 = (void *)(a1 + 8);
  unint64_t v10 = *(void *)(a1 + 8);
  uint64_t result = v10 - a2;
  if (v10 >= a2)
  {
    if (v10 == a2)
    {
      uint64_t result = 0;
      *char v9 = 0;
      v9[1] = 0;
      v9[2] = 0;
    }
    else
    {
      unint64_t v12 = *(void *)(a1 + 16) + a2;
      *(void *)(a1 + 8) = result;
      *(void *)(a1 + 16) = v12;
    }
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferDecreaseSize", 117, 36, 0, "MemBufferDecreaseSize n is too large: %zu", a7, a8, a2);
    return -1;
  }
  return result;
}

uint64_t MemBufferIncreaseSize(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a1[3] + a2;
  if (v8 <= *a1)
  {
    a1[3] = v8;
    unint64_t v9 = a1[1] + a2;
    a1[1] = v9;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferIncreaseSize", 137, 36, 0, "MemBufferIncreaseSize n is too large: %zu", a7, a8, a2);
    return -1;
  }
  return v9;
}

void *MemBufferClear(void *result)
{
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  return result;
}

BOOL MemBufferIsEmpty(uint64_t a1)
{
  return *(void *)(a1 + 8) == 0;
}

uint64_t MemBufferFillFromBuffer(unint64_t *a1, size_t a2, const void *a3)
{
  size_t v6 = *a1 - a1[1];
  FreePtr = (void *)MemBufferGetFreePtr((uint64_t)a1);
  if (v6 >= a2)
  {
    memcpy(FreePtr, a3, a2);
    return MemBufferIncreaseSize(a1, a2, v11, v12, v13, v14, v15, v16);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferFillFromBuffer", 162, 36, 0, "MemBufferFillFromBuffer n is too large: %zu", v8, v9, a2);
    return -1;
  }
}

uint64_t MemBufferFillFromBufferWithCapacityIncrease(unint64_t *a1, size_t a2, const void *a3)
{
  size_t v6 = a1[1] + a2;
  if (v6 > *a1 && (MemBufferIncreaseCapacity((uint64_t)a1, v6) & 0x8000000000000000) != 0) {
    return -1;
  }

  return MemBufferFillFromBuffer(a1, a2, a3);
}

uint64_t MemBufferFlushToBuffer(void *a1, size_t __n, void *__dst, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[1] >= __n)
  {
    memcpy(__dst, (const void *)(a1[4] + a1[2]), __n);
    return MemBufferDecreaseSize((uint64_t)a1, __n, v11, v12, v13, v14, v15, v16);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferFlushToBuffer", 183, 36, 0, "MemBufferFlushToBuffer n is too large: %zu", a7, a8, __n);
    return -1;
  }
}

uint64_t MemBufferFillFromIStream(unint64_t *a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4)
{
  unint64_t v8 = *a1 - a1[1];
  uint64_t FreePtr = MemBufferGetFreePtr((uint64_t)a1);
  if (v8 >= a2) {
    unint64_t v8 = a2;
  }
  if (v8)
  {
    uint64_t v16 = FreePtr;
    uint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = a3(a4, v16, v8);
      if (v18 < 0) {
        return -1;
      }
      if (v18)
      {
        v16 += v18;
        v17 += v18;
        v8 -= v18;
        if (v8) {
          continue;
        }
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v17 = 0;
LABEL_10:
    return MemBufferIncreaseSize(a1, v17, v10, v11, v12, v13, v14, v15);
  }
}

uint64_t MemBufferFlushToOStream(void *a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[1] >= a2) {
    unint64_t v9 = a2;
  }
  else {
    unint64_t v9 = a1[1];
  }
  if (v9)
  {
    unint64_t v12 = 0;
    uint64_t v13 = a1[4] + a1[2];
    while (1)
    {
      uint64_t v14 = a3(a4, v13, v9);
      if (v14 < 0) {
        return -1;
      }
      if (!v14)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferFlushToOStream", 265, 36, 0, "MemBuffer write proc returned 0", a7, a8, v16);
        return -1;
      }
      v13 += v14;
      v12 += v14;
      v9 -= v14;
      if (!v9) {
        goto LABEL_11;
      }
    }
  }
  else
  {
    unint64_t v12 = 0;
LABEL_11:
    return MemBufferDecreaseSize((uint64_t)a1, v12, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
}

uint64_t MemBufferTransmit(unint64_t *a1, unint64_t a2, size_t (*a3)(int a1, void *a2, size_t a3), uint64_t a4, uint64_t (*a5)(uint64_t a1, uint64_t a2, uint64_t a3), uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a2;
  if ((unint64_t)a3 | (unint64_t)a5)
  {
    if (a3) {
      uint64_t v11 = a4;
    }
    else {
      uint64_t v11 = 0;
    }
    if (a3) {
      unint64_t v12 = a3;
    }
    else {
      unint64_t v12 = IZeroStreamRead;
    }
    if (a5) {
      uint64_t v13 = a5;
    }
    else {
      uint64_t v13 = ONullStreamWrite;
    }
    if (a5) {
      uint64_t v14 = a6;
    }
    else {
      uint64_t v14 = 0;
    }
    if (*a1)
    {
      a1[1] = 0;
      a1[2] = 0;
      a1[3] = 0;
      uint64_t v9 = 0;
      if (!a2) {
        return v9;
      }
      while (1)
      {
        if (*a1 >= v8) {
          size_t v15 = v8;
        }
        else {
          size_t v15 = *a1;
        }
        uint64_t v16 = v12(v11, (void *)a1[4], v15);
        if (v16 < 0)
        {
          unsigned int v19 = "read failed";
          __int16 v20 = 294;
          goto LABEL_30;
        }
        unint64_t v17 = v16;
        unint64_t v18 = v13(v14, a1[4], v16);
        if ((v18 & 0x8000000000000000) != 0)
        {
          unsigned int v19 = "write failed";
          __int16 v20 = 298;
          goto LABEL_30;
        }
        if (v18 < v17) {
          break;
        }
        if (v17)
        {
          v9 += v17;
          if (v8 == -1) {
            unint64_t v8 = -1;
          }
          else {
            v8 -= v17;
          }
          if (v8) {
            continue;
          }
        }
        return v9;
      }
      unsigned int v19 = "truncated write";
      __int16 v20 = 299;
    }
    else
    {
      unsigned int v19 = "MemBuffer is not allocated";
      __int16 v20 = 281;
    }
LABEL_30:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferTransmit", v20, 36, 0, v19, a7, a8, v22);
    return -1;
  }
  return a2;
}

void *MappedBufferCreateWithFilename(const char *a1, unint64_t a2, unint64_t a3)
{
  size_t v6 = malloc(0x28uLL);
  uint64_t v7 = v6;
  if (v6)
  {
    v6[3] = 0;
    _OWORD v6[4] = 0;
    v6[1] = -1;
    v6[2] = 0;
    memset(&v24, 0, sizeof(v24));
    int v8 = getpagesize();
    *((_DWORD *)v7 + 1) = 1;
    int v9 = open(a1, 0);
    *(_DWORD *)uint64_t v7 = v9;
    if (v9 < 0)
    {
      int v13 = *__error();
      char v23 = (char)a1;
      uint64_t v14 = "%s";
      __int16 v15 = 344;
      goto LABEL_7;
    }
    int v10 = v9;
    if (fstat(v9, &v24))
    {
      int v13 = *__error();
      char v23 = (char)a1;
      uint64_t v14 = "%s";
      __int16 v15 = 347;
LABEL_7:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MappedBufferCreateWithFilename", v15, 36, v13, v14, v11, v12, v23);
      MappedBufferDestroy(v7);
      return 0;
    }
    if (v24.st_size > a2)
    {
      if (a3 == -1)
      {
        a3 = v24.st_size - a2;
      }
      else if (a3 + a2 > v24.st_size)
      {
        char v23 = a2;
        uint64_t v14 = "invalid offset=%llu, size=%llu in file %s";
        __int16 v15 = 352;
LABEL_19:
        int v13 = 0;
        goto LABEL_7;
      }
      if (a3)
      {
        v7[4] = a3;
        off_t v20 = a2 / v8 * v8;
        unint64_t v21 = a2 % v8;
        v7[2] = v21 + a3;
        char v22 = (char *)mmap(0, v21 + a3, 1, 2, v10, v20);
        v7[1] = v22;
        if (v22 != (char *)-1)
        {
          v7[3] = &v22[v21];
          return v7;
        }
        int v13 = *__error();
        uint64_t v14 = "mmap file segment";
        __int16 v15 = 364;
        goto LABEL_7;
      }
      char v23 = 0;
      uint64_t v14 = "invalid size=%llu";
      __int16 v15 = 354;
      goto LABEL_19;
    }
    char v23 = a2;
    uint64_t v14 = "invalid offset=%llu in file %s";
    __int16 v15 = 348;
    goto LABEL_19;
  }
  uint64_t v16 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MappedBufferCreateWithFilename", 329, 36, *v16, "malloc", v17, v18, v23);
  return v7;
}

void MappedBufferDestroy(void *a1)
{
  if (a1)
  {
    size_t v2 = (void *)a1[1];
    if (v2 != (void *)-1) {
      munmap(v2, a1[2]);
    }
    if (*((_DWORD *)a1 + 1) && (*(_DWORD *)a1 & 0x80000000) == 0) {
      close(*(_DWORD *)a1);
    }
    free(a1);
  }
}

uint64_t MappedBufferGetDataSize(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t verifyDirThreadProc()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v43 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)v0;
  bzero(v42, 0x800uLL);
  bzero(v41, 0x800uLL);
  memset(&v36, 0, sizeof(v36));
  uint64_t v3 = *(void (**)(uint64_t, uint64_t, void, uint64_t, void, void))(*(void *)v1 + 64);
  uint64_t v2 = *(void *)(*(void *)v1 + 72);
  atomic_fetch_add_explicit((atomic_ullong *volatile)(v1 + 2136), 1uLL, memory_order_relaxed);
  if (!concatPath(v42, 0x800uLL, (char *)(v1 + 8), (const char *)(v0 + 152)))
  {
    if (lstat(v42, &v36))
    {
      int v8 = *__error();
      unsigned int v34 = v42;
      size_t v6 = "%s";
      __int16 v7 = 81;
      goto LABEL_6;
    }
    int v10 = *(_DWORD *)(v0 + 8);
    int AAEntryType = getAAEntryType(v36.st_mode);
    int v12 = *(_DWORD *)(v0 + 12);
    if (v12 == 72)
    {
      if (concatPath(v41, 0x800uLL, (char *)(v1 + 8), (const char *)(v0 + 1176)))
      {
        LOBYTE(v34) = v0 - 104;
        size_t v6 = "building full link path: %s";
        __int16 v7 = 93;
        goto LABEL_3;
      }
      memset(&v37, 0, sizeof(v37));
      if (lstat(v41, &v37))
      {
        int v8 = *__error();
        unsigned int v34 = v42;
        size_t v6 = "%s";
        __int16 v7 = 97;
        goto LABEL_6;
      }
      if (v37.st_ino == v36.st_ino)
      {
        uint64_t v15 = 0;
        unsigned int v13 = 0;
        if (!v3) {
          return 0;
        }
        goto LABEL_118;
      }
      unsigned int v13 = 64;
      goto LABEL_117;
    }
    if (AAEntryType != v12)
    {
      unsigned int v13 = 1;
      goto LABEL_117;
    }
    if ((v10 & 2) != 0) {
      unsigned int v13 = 2 * (*(_DWORD *)(v0 + 16) != v36.st_uid);
    }
    else {
      unsigned int v13 = 0;
    }
    if ((v10 & 4) != 0)
    {
      if (*(_DWORD *)(v0 + 20) != v36.st_gid) {
        v13 |= 4u;
      }
      if ((v10 & 8) == 0)
      {
LABEL_20:
        if ((v10 & 0x10) == 0) {
          goto LABEL_21;
        }
        goto LABEL_30;
      }
    }
    else if ((v10 & 8) == 0)
    {
      goto LABEL_20;
    }
    if (*(_DWORD *)(v0 + 24) != v36.st_flags) {
      v13 |= 8u;
    }
    if ((v10 & 0x10) == 0)
    {
LABEL_21:
      if ((v10 & 0x80) == 0) {
        goto LABEL_22;
      }
      goto LABEL_33;
    }
LABEL_30:
    if (*(_DWORD *)(v0 + 28) != (v36.st_mode & 0xFFF)) {
      v13 |= 0x10u;
    }
    if ((v10 & 0x80) == 0)
    {
LABEL_22:
      if ((v10 & 0x100) == 0) {
        goto LABEL_40;
      }
      goto LABEL_36;
    }
LABEL_33:
    if (*(void *)(v0 + 48) != v36.st_size) {
      v13 |= 0x80u;
    }
    if ((v10 & 0x100) == 0)
    {
LABEL_40:
      if ((v10 & 0x10000) != 0 && AAEntryType == 76)
      {
        bzero(&v37, 0x400uLL);
        if (readlink(v42, (char *)&v37, 0x3FFuLL) < 0)
        {
          int v8 = *__error();
          unsigned int v34 = v42;
          size_t v6 = "%s";
          __int16 v7 = 129;
          goto LABEL_6;
        }
        if (strcmp((const char *)&v37, (const char *)(v0 + 1176)))
        {
          v13 |= 0x10000u;
          goto LABEL_117;
        }
        goto LABEL_116;
      }
      if (AAEntryType != 70)
      {
LABEL_116:
        if (!v13)
        {
          uint64_t v15 = 0;
          if (!v3) {
            return 0;
          }
          goto LABEL_118;
        }
LABEL_117:
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v1 + 2160), 1uLL, memory_order_relaxed);
        uint64_t v15 = 3;
        if (!v3) {
          return 0;
        }
LABEL_118:
        v3(v2, v15, v13, v0 + 8, *(void *)(v0 + 2216), *(void *)(v0 + 2200));
        return 0;
      }
      if ((v10 & 0x1000) != 0)
      {
        uint64_t v14 = (unsigned int *)&v35;
      }
      else
      {
        if ((v10 & 0x6000) == 0) {
          goto LABEL_116;
        }
        uint64_t v14 = 0;
      }
      int v35 = 0;
      uint64_t v39 = 0;
      uint64_t v38 = 0;
      int v40 = 0;
      memset(&v37, 0, 32);
      if ((v10 & 0x2000) != 0) {
        uint64_t v16 = (unsigned __int8 *)&v38;
      }
      else {
        uint64_t v16 = 0;
      }
      if ((v10 & 0x4000) != 0) {
        uint64_t v17 = (unsigned __int8 *)&v37;
      }
      else {
        uint64_t v17 = 0;
      }
      if ((getFileDigests(v42, v16, v17, v14) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"verifyDirThreadProc", 141, 43, 0, "verification failed: %s", v18, v19, (char)v42);
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v1 + 2176), 1uLL, memory_order_relaxed);
        if ((v10 & 0x1000) == 0)
        {
LABEL_63:
          if ((v10 & 0x2000) == 0) {
            goto LABEL_89;
          }
LABEL_69:
          if (v38 != *(void *)(v0 + 100)
            || v39 != *(void *)(v0 + 108)
            || v40 != (unint64_t)*(unsigned int *)(v0 + 116))
          {
            uint64_t v22 = *(void *)(v0 + 2200);
            if (v22)
            {
              uint64_t v23 = *(void *)(v0 + 2216) + 8;
              while (1)
              {
                if (*(_DWORD *)(v23 - 4) == 5 && (*(_DWORD *)(v23 - 8) & 0xDFDFDF) == 0x114858)
                {
                  BOOL v24 = v38 == *(void *)v23 && v39 == *(void *)(v23 + 8);
                  if (v24 && v40 == (unint64_t)*(unsigned int *)(v23 + 16)) {
                    break;
                  }
                }
                v23 += 1032;
                if (!--v22) {
                  goto LABEL_88;
                }
              }
            }
            else
            {
LABEL_88:
              v13 |= 0x2000u;
            }
          }
LABEL_89:
          if ((v10 & 0x4000) != 0)
          {
            BOOL v26 = *(void *)&v37.st_dev == *(void *)(v0 + 120) && v37.st_ino == *(void *)(v0 + 128);
            BOOL v27 = v26 && *(void *)&v37.st_uid == *(void *)(v0 + 136);
            if (!v27 || *(void *)&v37.st_rdev != *(void *)(v0 + 144))
            {
              uint64_t v29 = *(void *)(v0 + 2200);
              if (!v29)
              {
LABEL_115:
                v13 |= 0x4000u;
                goto LABEL_117;
              }
              unint64_t v30 = (void *)(*(void *)(v0 + 2216) + 8);
              while (1)
              {
                if (*((_DWORD *)v30 - 1) == 6 && (*(_DWORD *)(v30 - 1) & 0xDFDFDF) == 0x124858)
                {
                  BOOL v31 = *(void *)&v37.st_dev == *v30 && v37.st_ino == v30[1];
                  BOOL v32 = v31 && *(void *)&v37.st_uid == v30[2];
                  if (v32 && *(void *)&v37.st_rdev == v30[3]) {
                    break;
                  }
                }
                v30 += 129;
                if (!--v29) {
                  goto LABEL_115;
                }
              }
            }
          }
          goto LABEL_116;
        }
      }
      else if ((v10 & 0x1000) == 0)
      {
        goto LABEL_63;
      }
      if (v35 != *(_DWORD *)(v0 + 96)) {
        v13 |= 0x1000u;
      }
      if ((v10 & 0x2000) == 0) {
        goto LABEL_89;
      }
      goto LABEL_69;
    }
LABEL_36:
    if (AAEntryType != 68
      && (*(void *)(v0 + 56) != v36.st_mtimespec.tv_sec
       || *(void *)(v0 + 64) / 0x3E8uLL != v36.st_mtimespec.tv_nsec / 0x3E8uLL))
    {
      v13 |= 0x100u;
    }
    goto LABEL_40;
  }
  LOBYTE(v34) = v0 - 104;
  size_t v6 = "building full path: %s";
  __int16 v7 = 78;
LABEL_3:
  int v8 = 0;
LABEL_6:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"verifyDirThreadProc", v7, 43, v8, v6, v4, v5, (char)v34);
  atomic_fetch_add_explicit((atomic_ullong *volatile)(v1 + 2176), 1uLL, memory_order_relaxed);
  return 0;
}

uint64_t ParallelArchiveVerifyDir(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v80[1] = *MEMORY[0x263EF8340];
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v58);
  bzero(v67, 0x880uLL);
  uint64_t v66 = a1;
  int DefaultNThreads = *(_DWORD *)(a1 + 4);
  if (!DefaultNThreads) {
    int DefaultNThreads = getDefaultNThreads();
  }
  uint64_t v65 = 0;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v60 = 0u;
  LODWORD(__count) = DefaultNThreads;
  if (!realpath_DARWIN_EXTSN(*(const char **)(a1 + 16), v67))
  {
    int v25 = *__error();
    BOOL v26 = *(const char **)(a1 + 16);
    __int16 v27 = 350;
LABEL_18:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"ParallelArchiveVerifyDir", v27, 43, v25, v26, v11, v12, v59);
    goto LABEL_19;
  }
  uint64_t v70 = calloc(__count, 0x8B0uLL);
  int v10 = calloc(__count, 8uLL);
  unint64_t v71 = v10;
  if (!v70 || !v10)
  {
    int v25 = *__error();
    BOOL v26 = "malloc";
    __int16 v27 = 353;
    goto LABEL_18;
  }
  int64x2_t v68 = ArchiveTreeCreateFromDirectory(*(char **)(a1 + 16), 0, *(void *)(a1 + 48), *(void *)(a1 + 56), *(_DWORD *)(a1 + 4), *(_DWORD *)a1);
  if (!v68)
  {
    BOOL v26 = "creating directory tree";
    __int16 v27 = 357;
LABEL_17:
    int v25 = 0;
    goto LABEL_18;
  }
  uint64_t v13 = __count;
  if (__count)
  {
    uint64_t v14 = 0;
    do
    {
      uint64_t v15 = (uint64_t **)((char *)v70 + 2224 * v14);
      *uint64_t v15 = &v66;
      *((void *)v71 + v14++) = v15;
    }
    while (v14 != v13);
  }
  uint64_t v72 = ThreadPoolCreate(v13, (uint64_t)v71, (uint64_t)verifyDirThreadProc);
  if (!v72)
  {
    BOOL v26 = "ThreadPoolCreate";
    __int16 v27 = 366;
    goto LABEL_17;
  }
  long long v60 = 0u;
  long long v61 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v62 = 0u;
  DWORD1(v60) = *(_DWORD *)(a1 + 4);
  uint64_t v21 = *(void *)(a1 + 40);
  *((void *)&v60 + 1) = *(void *)(a1 + 24);
  *((void *)&v61 + 1) = v21;
  *(void *)&long long v62 = verifyDirBeginEntry;
  *(void *)&long long v64 = verifyDirEndEntry;
  *((void *)&v62 + 1) = verifyDirBlob;
  *(void *)&long long v63 = verifyDirPayload;
  uint64_t v65 = &v66;
  if (ParallelArchiveRead((uint64_t)&v60, v16, v17, v18, v19, v20, v11, v12))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"ParallelArchiveVerifyDir", 379, 43, 0, "reading manifest", v22, v23, v59);
    int v24 = 0;
  }
  else
  {
    int v24 = 1;
  }
  if ((ThreadPoolDestroy((uint64_t)v72) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"ParallelArchiveVerifyDir", 382, 43, 0, "ThreadPoolDestroy failed", v37, v38, v59);
    int v24 = 0;
    uint64_t v72 = 0;
    goto LABEL_20;
  }
  uint64_t v72 = 0;
  uint64_t v39 = atomic_load(v80);
  if (v39 > 0)
  {
LABEL_19:
    int v24 = 0;
    goto LABEL_20;
  }
  if (*(int *)a1 >= 1)
  {
    int v40 = (FILE **)MEMORY[0x263EF8348];
    int v41 = (FILE *)*MEMORY[0x263EF8348];
    unint64_t v42 = atomic_load(&v73);
    fprintf(v41, "%12lld entries in manifest\n", v42);
    uint64_t v43 = *v40;
    unint64_t v44 = atomic_load(&v74);
    fprintf(v43, "%12lld entries selected\n", v44);
    uint64_t v45 = *v40;
    unint64_t v46 = atomic_load(&v77);
    fprintf(v45, "%12lld entries added\n", v46);
    unint64_t v47 = *v40;
    unint64_t v48 = atomic_load(&v76);
    fprintf(v47, "%12lld entries removed\n", v48);
    unint64_t v49 = *v40;
    unint64_t v50 = atomic_load(&v75);
    fprintf(v49, "%12lld entries compared\n", v50);
    size_t v51 = *v40;
    unint64_t v52 = atomic_load(&v78);
    fprintf(v51, "%12lld entries compared -> modified\n", v52);
    __int16 v53 = *v40;
    unint64_t v54 = atomic_load(&v75);
    unint64_t v55 = atomic_load(&v78);
    fprintf(v53, "%12lld entries compared -> verified\n", v54 - v55);
    int v56 = *v40;
    unint64_t v57 = atomic_load(&v79);
    fprintf(v56, "%12lld bytes hashed\n", v57);
  }
LABEL_20:
  ArchiveTreeDestroy((uint64_t)v68);
  if ((ThreadPoolDestroy((uint64_t)v72) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"ParallelArchiveVerifyDir", 403, 43, 0, "ThreadPoolDestroy", v28, v29, v59);
    int v24 = 0;
  }
  free(v71);
  unint64_t v30 = v70;
  if (v70)
  {
    if (__count)
    {
      unint64_t v31 = 0;
      uint64_t v32 = 2216;
      do
      {
        free(*(void **)((char *)v70 + v32));
        ++v31;
        v32 += 2224;
      }
      while (v31 < __count);
      unint64_t v30 = v70;
    }
    free(v30);
  }
  uint64_t result = leaveThreadErrorContext(0, 0, 0);
  if ((result & 0x80000000) == 0)
  {
    if (v24)
    {
      if (atomic_load(&v78)) {
        return 0;
      }
      if (atomic_load(&v77))
      {
        return 0;
      }
      else
      {
        unint64_t v36 = atomic_load(&v76);
        return v36 == 0;
      }
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t verifyDirBeginEntry()
{
  uint64_t result = MEMORY[0x270FA5388]();
  uint64_t v40 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(void (**)(uint64_t, uint64_t))(*(void *)result + 64);
  uint64_t v4 = *(void *)(*(void *)result + 72);
  BOOL v6 = *(_DWORD *)(v1 + 4) == 77;
  *(_DWORD *)(result + 1084) = v6;
  if (!v6)
  {
    unint64_t v7 = v3;
    int v8 = v2;
    int v9 = (const char *)v1;
    uint64_t v10 = result;
    atomic_fetch_add((atomic_ullong *volatile)(result + 2120), 1uLL);
    uint64_t v11 = *(uint64_t (**)(void, uint64_t, void))(*(void *)result + 48);
    if (!v11
      || (uint64_t result = v11(*(void *)(*(void *)result + 56), v1 + 144, *(unsigned int *)(v1 + 4)), (int)result >= 1))
    {
      atomic_fetch_add((atomic_ullong *volatile)(v10 + 2128), 1uLL);
      unsigned int v12 = *(_DWORD *)(v10 + 1072);
      uint64_t result = (uint64_t)ArchiveTreeSize(*(unsigned int **)(v10 + 1032));
      if (v12 < result)
      {
        while (1)
        {
          if (ArchiveTreeNodePath(*(void *)(v10 + 1032), *(_DWORD *)(v10 + 1072), (uint64_t)__s1, 0x800uLL) < 0)
          {
            uint64_t v23 = "getting node path";
            __int16 v24 = 220;
            goto LABEL_27;
          }
          uint64_t result = strcmp(__s1, v9 + 144);
          if ((result & 0x80000000) == 0) {
            break;
          }
          if (__s1[0])
          {
            atomic_fetch_add((atomic_ullong *volatile)(v10 + 2152), 1uLL);
            if (v5)
            {
              bzero(v37, 0x890uLL);
              __strlcpy_chk();
              int v38 = ArchiveTreeNodeEntryType(*(void *)(v10 + 1032), *(_DWORD *)(v10 + 1072));
              v36 &= 0xFFFFFFFF00000000;
              v5(v4, 2);
            }
          }
          unsigned int v22 = *(_DWORD *)(v10 + 1072) + 1;
          *(_DWORD *)(v10 + 1072) = v22;
          if (v22 >= ArchiveTreeSize(*(unsigned int **)(v10 + 1032))) {
            goto LABEL_16;
          }
        }
        if (result) {
          goto LABEL_14;
        }
LABEL_16:
        uint64_t Worker = ThreadPoolGetWorker(*(void *)(v10 + 1064), v15, v16, v17, v18, v19, v20, v21);
        if (Worker)
        {
          uint64_t v26 = Worker;
          memcpy((void *)(Worker + 8), v9, 0x890uLL);
          if (*(void *)(v26 + 2208) >= v7)
          {
            uint64_t v28 = *(void **)(v26 + 2216);
          }
          else
          {
            uint64_t v27 = 16;
            if (v7 > 0x10) {
              uint64_t v27 = v7;
            }
            *(void *)(v26 + 2208) = v27;
            uint64_t v28 = reallocf(*(void **)(v26 + 2216), 1032 * v27);
            *(void *)(v26 + 2216) = v28;
            if (!v28)
            {
              uint64_t v23 = "malloc";
              __int16 v24 = 272;
LABEL_27:
              uint64_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"verifyDirBeginEntry", v24, 43, 0, v23, v13, v14, v35);
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 2176), 1uLL, memory_order_relaxed);
              return result;
            }
          }
          memcpy(v28, v8, 1032 * v7);
          *(void *)(v26 + 2200) = v7;
          *(_DWORD *)(v26 + 8) &= *(_DWORD *)(*(void *)v10 + 8);
          uint64_t result = ThreadPoolRunWorker(*(void *)(v10 + 1064), v26, v29, v30, v31, v32, v33, v34);
          if ((result & 0x80000000) == 0)
          {
            ++*(_DWORD *)(v10 + 1072);
            return result;
          }
          uint64_t v23 = "ThreadPoolRunWorker failed";
          __int16 v24 = 281;
          goto LABEL_27;
        }
        uint64_t v23 = "ThreadPoolGetWorker failed";
        __int16 v24 = 262;
        goto LABEL_27;
      }
LABEL_14:
      atomic_fetch_add((atomic_ullong *volatile)(v10 + 2144), 1uLL);
      if (v5) {
        return ((uint64_t (*)(uint64_t, uint64_t, void, const char *, const void *, unint64_t))v5)(v4, 1, 0, v9, v8, v7);
      }
    }
  }
  return result;
}

size_t verifyDirEndEntry(size_t result)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(result + 1084))
  {
    size_t v1 = result;
    uint64_t v2 = *(void *)(result + 2112);
    if ((unint64_t)(v2 + 1) <= 0x3FF)
    {
      *(unsigned char *)(result + 1088 + v2) = 0;
      int v10 = 0;
      uint64_t result = yaa_parseFields((const char *)(result + 1088), &v10, 0);
      if (result)
      {
        uint64_t v5 = "parsing YAF metadata field";
        __int16 v6 = 296;
LABEL_5:
        uint64_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"verifyDirEndEntry", v6, 43, 0, v5, v3, v4, v9);
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v1 + 2176), 1uLL, memory_order_relaxed);
        return result;
      }
      int v7 = *(_DWORD *)(*(void *)v1 + 8) & v10;
      int v8 = (FILE **)MEMORY[0x263EF8348];
      if (**(int **)v1 >= 1)
      {
        bzero(v11, 0x400uLL);
        fprintf(*v8, "Manifest fields: %s\n", (const char *)(v1 + 1088));
        if (yaa_serializeFields(v11, 0x400uLL, v7, 0))
        {
          uint64_t v5 = "serializing fields";
          __int16 v6 = 307;
          goto LABEL_5;
        }
        uint64_t result = fprintf(*v8, "Comparison fields: %s\n", v11);
      }
      if ((v7 & 0x400) != 0) {
        uint64_t result = fwrite("Warning: XAT field verification is not implemented\n", 0x33uLL, 1uLL, *v8);
      }
      if ((v7 & 0x800) != 0) {
        return fwrite("Warning: ACL field verification is not implemented\n", 0x33uLL, 1uLL, *v8);
      }
    }
  }
  return result;
}

uint64_t verifyDirBlob(uint64_t result, char *a2)
{
  uint64_t v2 = result;
  int v3 = *(_DWORD *)(result + 1084);
  if (v3)
  {
    uint64_t result = strncasecmp(a2, "YAF", 3uLL);
    int v3 = result == 0;
  }
  *(_DWORD *)(v2 + 1080) = v3;
  return result;
}

char *verifyDirPayload(char *result, const void *a2, size_t __n)
{
  if (*((_DWORD *)result + 270))
  {
    uint64_t v4 = result;
    uint64_t v5 = *((void *)result + 264);
    if (v5 + __n <= 0x3FF)
    {
      uint64_t result = (char *)memcpy(&result[v5 + 1088], a2, __n);
      v4[264] += __n;
    }
  }
  return result;
}

_OWORD *ParallelArchiveDBSessionCreate(char *a1, void *a2, size_t a3, uint64_t a4)
{
  int v8 = calloc(1uLL, 0x58uLL);
  if (v8)
  {
    char v9 = strchr(a1, 61);
    if (v9)
    {
      size_t v10 = v9 - a1;
      uint64_t v11 = v9 + 1;
      if (!isValidAliasOrEngine((uint64_t)a1, v9 - a1))
      {
        char v25 = (char)v11;
        uint64_t v16 = "invalid session URL: %s (invalid alias chars)";
        __int16 v17 = 68;
        goto LABEL_15;
      }
      uint64_t v14 = a1;
      a1 = v11;
    }
    else
    {
      uint64_t v14 = 0;
      size_t v10 = 0;
    }
    uint64_t v18 = strchr(a1, 58);
    if (v18)
    {
      int64_t v19 = v18 - a1;
      uint64_t v20 = v18 + 1;
      if (!isValidAliasOrEngine((uint64_t)a1, v18 - a1))
      {
        char v25 = (char)v20;
        uint64_t v16 = "invalid session URL: %s (invalid engine chars)";
        __int16 v17 = 78;
        goto LABEL_15;
      }
      if (v19 == 4 && *(_DWORD *)a1 == 1701603686)
      {
        long long v22 = *(_OWORD *)&off_26C28FB00;
        void v8[2] = xmmword_26C28FAF0;
        v8[3] = v22;
        v8[4] = xmmword_26C28FB10;
        *((void *)v8 + 10) = qword_26C28FB20;
        long long v23 = *(_OWORD *)&off_26C28FAE0;
        *int v8 = ParallelArchiveDBSession_FILE;
        v8[1] = v23;
        uint64_t v24 = (*(uint64_t (**)(char *, uint64_t))v8)(v20, a4);
        *((void *)v8 + 10) = v24;
        if (v24)
        {
          if (!a2) {
            return v8;
          }
          bzero(a2, a3);
          if (v10 + 1 <= a3)
          {
            memcpy(a2, v14, v10);
            *((unsigned char *)a2 + v10) = 0;
            return v8;
          }
          uint64_t v16 = "invalid aliasCapacity";
          __int16 v17 = 98;
        }
        else
        {
          char v25 = (char)v20;
          uint64_t v16 = "create session: %s";
          __int16 v17 = 91;
        }
        goto LABEL_15;
      }
      LOBYTE(a1) = (_BYTE)v20;
    }
    char v25 = (char)a1;
    uint64_t v16 = "Invalid session URL: %s (unknown engine)";
    __int16 v17 = 87;
LABEL_15:
    int v15 = 0;
    goto LABEL_16;
  }
  int v15 = *__error();
  uint64_t v16 = "malloc";
  __int16 v17 = 52;
LABEL_16:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabase.c", (uint64_t)"ParallelArchiveDBSessionCreate", v17, 11, v15, v16, v12, v13, v25);
  free(v8);
  return 0;
}

BOOL isValidAliasOrEngine(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    BOOL v4 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = MEMORY[0x263EF8318];
    while (1)
    {
      unsigned int v7 = *(char *)(a1 + v5);
      if ((v7 & 0x80000000) != 0)
      {
        if (__maskrune(*(char *)(a1 + v5), 0x500uLL)) {
          goto LABEL_9;
        }
      }
      else if ((*(_DWORD *)(v6 + 4 * v7 + 60) & 0x500) != 0)
      {
        goto LABEL_9;
      }
      if (v7 != 95 && v7 != 45) {
        return v4;
      }
LABEL_9:
      BOOL v4 = ++v5 >= a2;
      if (a2 == v5) {
        return v4;
      }
    }
  }
  return 1;
}

uint64_t ParallelArchiveDBSessionDestroy(uint64_t result)
{
  if (result)
  {
    size_t v1 = (void *)result;
    uint64_t v2 = (*(uint64_t (**)(void))(result + 8))(*(void *)(result + 80));
    free(v1);
    return v2;
  }
  return result;
}

void *ParallelArchiveDBRequestOpenForWriting(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = calloc(1uLL, 0x10uLL);
  unsigned int v7 = v6;
  if (!v6)
  {
    int v13 = *__error();
    uint64_t v11 = "malloc";
    __int16 v12 = 122;
    goto LABEL_5;
  }
  void *v6 = a1;
  uint64_t v8 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a1 + 16))(*(void *)(a1 + 80), a2, a3);
  v7[1] = v8;
  if (!v8)
  {
    uint64_t v11 = "Request creation";
    __int16 v12 = 126;
    int v13 = 0;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabase.c", (uint64_t)"ParallelArchiveDBRequestOpenForWriting", v12, 11, v13, v11, v9, v10, v15);
    free(v7);
    return 0;
  }
  return v7;
}

uint64_t ParallelArchiveDBRequestWrite(void *a1)
{
  return (*(uint64_t (**)(void))(*a1 + 24))(a1[1]);
}

uint64_t ParallelArchiveDBRequestCloseAndGetKey(void *a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(*a1 + 32))(a1[1]);
  free(a1);
  return v2;
}

void *ParallelArchiveDBRequestOpenForReading(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  __int16 v12 = calloc(1uLL, 0x10uLL);
  int v13 = v12;
  if (!v12)
  {
    int v19 = *__error();
    __int16 v17 = "malloc";
    __int16 v18 = 151;
    goto LABEL_5;
  }
  *__int16 v12 = a1;
  uint64_t v14 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 40))(*(void *)(a1 + 80), a2, a3, a4, a5, a6);
  v13[1] = v14;
  if (!v14)
  {
    __int16 v17 = "Request creation";
    __int16 v18 = 155;
    int v19 = 0;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabase.c", (uint64_t)"ParallelArchiveDBRequestOpenForReading", v18, 11, v19, v17, v15, v16, v21);
    free(v13);
    return 0;
  }
  return v13;
}

uint64_t ParallelArchiveDBRequestRead(void *a1)
{
  return (*(uint64_t (**)(void))(*a1 + 48))(a1[1]);
}

uint64_t ParallelArchiveDBRequestClose(void *a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(*a1 + 64))(a1[1]);
  free(a1);
  return v2;
}

uint64_t ParallelArchiveDBSetCreate(size_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabase.c", (uint64_t)"ParallelArchiveDBSetCreate", 191, 11, 0, "nDB is not expected to be 0\n", a7, a8, v25);
    uint64_t v12 = 0;
    goto LABEL_20;
  }
  uint64_t v11 = calloc(1uLL, 0x18uLL);
  uint64_t v12 = (uint64_t)v11;
  if (!v11)
  {
    int v16 = *__error();
    int v19 = "malloc";
    __int16 v20 = 195;
    goto LABEL_19;
  }
  *uint64_t v11 = a1;
  v11[1] = calloc(a1, 8uLL);
  int v13 = calloc(a1, 8uLL);
  *(void *)(v12 + 16) = v13;
  uint64_t v14 = *(void *)(v12 + 8);
  if (v14) {
    BOOL v15 = v13 == 0;
  }
  else {
    BOOL v15 = 1;
  }
  if (v15)
  {
    int v16 = *__error();
    int v19 = "malloc";
    __int16 v20 = 200;
    goto LABEL_19;
  }
  uint64_t v21 = 0;
  int v22 = 0;
  while (1)
  {
    *(void *)(v14 + 8 * v21) = malloc(0x100uLL);
    long long v23 = *(void **)(*(void *)(v12 + 8) + 8 * v21);
    if (!v23)
    {
      int v16 = *__error();
      int v19 = "malloc";
      __int16 v20 = 205;
      goto LABEL_19;
    }
    *(void *)(*(void *)(v12 + 16) + 8 * v21) = ParallelArchiveDBSessionCreate(*(char **)(a2 + 8 * v21), v23, 0x100uLL, a3);
    if (!*(void *)(*(void *)(v12 + 16) + 8 * v21))
    {
      uint64_t v25 = *(void *)(a2 + 8 * v21);
      int v19 = "creating session for: %s";
      __int16 v20 = 207;
      goto LABEL_24;
    }
    uint64_t v14 = *(void *)(v12 + 8);
    if (!**(unsigned char **)(v14 + 8 * v21)) {
      break;
    }
LABEL_16:
    if (a1 == ++v21) {
      return v12;
    }
  }
  if (!v22)
  {
    int v22 = 1;
    goto LABEL_16;
  }
  int v19 = "Only one default database is allowed";
  __int16 v20 = 212;
LABEL_24:
  int v16 = 0;
LABEL_19:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabase.c", (uint64_t)"ParallelArchiveDBSetCreate", v20, 11, v16, v19, v17, v18, v25);
LABEL_20:
  ParallelArchiveDBSetDestroy(v12);
  return 0;
}

uint64_t ParallelArchiveDBSetDestroy(uint64_t result)
{
  if (result)
  {
    size_t v1 = (unint64_t *)result;
    uint64_t v2 = *(void **)(result + 8);
    if (v2)
    {
      if (*v1)
      {
        unint64_t v3 = 0;
        do
          free(*(void **)(v1[1] + 8 * v3++));
        while (v3 < *v1);
        uint64_t v2 = (void *)v1[1];
      }
      free(v2);
    }
    BOOL v4 = (void *)v1[2];
    if (v4)
    {
      if (*v1)
      {
        unint64_t v5 = 0;
        int v6 = 1;
        do
        {
          uint64_t v7 = *(void *)(v1[2] + 8 * v5);
          if (v7)
          {
            int v8 = (*(uint64_t (**)(void))(v7 + 8))(*(void *)(v7 + 80));
            free((void *)v7);
            if (v8 < 0)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabase.c", (uint64_t)"ParallelArchiveDBSetDestroy", 239, 11, 0, "destroying session", v9, v10, v11);
              int v6 = 0;
            }
          }
          ++v5;
        }
        while (v5 < *v1);
        BOOL v4 = (void *)v1[2];
      }
      else
      {
        int v6 = 1;
      }
      free(v4);
    }
    else
    {
      int v6 = 1;
    }
    free(v1);
    if (v6) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

void *ParallelArchiveDBReadRequestOpenWithSet(uint64_t *a1, char *__s2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a1;
  if (!*a1) {
    goto LABEL_19;
  }
  uint64_t v15 = 0;
  uint64_t v16 = a1[1];
  uint64_t v17 = -1;
  while (1)
  {
    uint64_t v18 = *(const char **)(v16 + 8 * v15);
    uint64_t v19 = v15;
    if (v18)
    {
      uint64_t v19 = *v18 ? v17 : v15;
      if (*v18 && __s2 != 0)
      {
        int v21 = strcmp(v18, __s2);
        uint64_t v19 = v17;
        if (!v21) {
          break;
        }
      }
    }
    ++v15;
    uint64_t v17 = v19;
    if (v9 == v15) {
      goto LABEL_15;
    }
  }
  uint64_t v19 = v15;
LABEL_15:
  if (v19 == -1)
  {
LABEL_19:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabase.c", (uint64_t)"ParallelArchiveDBReadRequestOpenWithSet", 261, 11, 0, "No database in set matches alias %s", a7, a8, (char)__s2);
    return 0;
  }
  else
  {
    uint64_t v22 = *(void *)(a1[2] + 8 * v19);
    return ParallelArchiveDBRequestOpenForReading(v22, a3, a4, a5, a6, a7);
  }
}

uint64_t ParallelArchiveDBCloneWithSet(uint64_t *a1, char *__s2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a1;
  if (!*a1) {
    goto LABEL_19;
  }
  uint64_t v15 = 0;
  uint64_t v16 = a1[1];
  uint64_t v17 = -1;
  while (1)
  {
    uint64_t v18 = *(const char **)(v16 + 8 * v15);
    uint64_t v19 = v15;
    if (v18)
    {
      uint64_t v19 = *v18 ? v17 : v15;
      if (*v18 && __s2 != 0)
      {
        int v21 = strcmp(v18, __s2);
        uint64_t v19 = v17;
        if (!v21) {
          break;
        }
      }
    }
    ++v15;
    uint64_t v17 = v19;
    if (v9 == v15) {
      goto LABEL_15;
    }
  }
  uint64_t v19 = v15;
LABEL_15:
  if (v19 == -1)
  {
LABEL_19:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabase.c", (uint64_t)"ParallelArchiveDBCloneWithSet", 281, 11, 0, "No database in set matches alias %s", a7, a8, (char)__s2);
    return 0;
  }
  else
  {
    uint64_t v22 = *(void *)(a1[2] + 8 * v19);
    uint64_t v24 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v22 + 72);
    uint64_t v23 = *(void *)(v22 + 80);
    return v24(v23, a3, a4, a5, a6);
  }
}

uint64_t ParallelArchiveSort(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v107[1] = *MEMORY[0x263EF8340];
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v90);
  int v9 = *(_DWORD *)a1;
  if (*(int *)a1 >= 1) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "ParallelArchiveSort:\n  input archive: %s\n", *(const char **)(a1 + 8));
  }
  long long v106 = 0;
  v107[0] = 0;
  long long v104 = 0u;
  long long v105 = 0u;
  long long v102 = 0u;
  long long v103 = 0u;
  long long v101 = 0u;
  *(_OWORD *)__int16 __buf = 0u;
  memset(&v100, 0, sizeof(v100));
  *(_OWORD *)__base = 0u;
  *(_OWORD *)long long v98 = 0u;
  v96[1] = a1;
  v96[0] = 1;
  __buf[0] = malloc(0x100000uLL);
  if (!__buf[0])
  {
    int v10 = *__error();
    int v13 = "malloc";
    __int16 v14 = 116;
    goto LABEL_10;
  }
  if (stat(*(const char **)(a1 + 8), &v100))
  {
    int v10 = *__error();
    int v13 = *(const char **)(a1 + 8);
    __int16 v14 = 119;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Sort.c", (uint64_t)"ParallelArchiveSort", v14, 49, v10, v13, v11, v12, (char)v91);
    LODWORD(v96[0]) = 0;
    goto LABEL_11;
  }
  unint64_t st_size = v100.st_size;
  if (loadFileSegment(*(const char **)(a1 + 8), v107, 6uLL, 0))
  {
    int v13 = "Reading input file magic failed";
    __int16 v14 = 123;
    goto LABEL_9;
  }
  int v18 = LODWORD(v107[0]) ^ 0x37303730 | WORD2(v107[0]) ^ 0x3130;
  if (v18)
  {
    BOOL v19 = LODWORD(v107[0]) == 925906736 && WORD2(v107[0]) == 14128;
    if (!v19)
    {
      int v91 = v107;
      int v13 = "Invalid input file: 'odc' or 'newc' raw cpio archive expected: %s";
      __int16 v14 = 125;
      goto LABEL_9;
    }
    __int16 v20 = 0;
  }
  else
  {
    __int16 v20 = "07070100000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000b00000000TRAILER!!!";
  }
  int v21 = LODWORD(v107[0]) ^ 0x37303730 | WORD2(v107[0]) ^ 0x3730;
  BOOL v19 = v21 == 0;
  BOOL v22 = v21 != 0;
  if (v19) {
    uint64_t v23 = "0707070000000000000000000000000000000000010000000000000000000001300000000000TRAILER!!!";
  }
  else {
    uint64_t v23 = v20;
  }
  if (v18) {
    BOOL v24 = v22;
  }
  else {
    BOOL v24 = 0;
  }
  uint64_t v25 = IFileStreamCreateWithFilename(*(const char **)(a1 + 8), 0, -1);
  if (!v25)
  {
    int v13 = "Reading input file failed";
    __int16 v14 = 134;
    goto LABEL_9;
  }
  uint64_t v31 = (char *)v25;
  *(void *)&long long v101 = 0x100000000;
  *(void *)&long long v102 = 0;
  long long v103 = 0u;
  long long v105 = 0u;
  *((void *)&v101 + 1) = IFileStreamRead;
  *((void *)&v102 + 1) = v25;
  *(void *)&long long v103 = indexBeginProc;
  *(void *)&long long v104 = indexPayloadAndPaddingProc;
  *((void *)&v104 + 1) = indexPayloadAndPaddingProc;
  long long v106 = v96;
  if (ParallelArchiveRead((uint64_t)&v101, v26, v27, v28, v29, v30, v11, v12))
  {
    int v13 = "Indexing failed";
    __int16 v14 = 145;
    goto LABEL_9;
  }
  IFileStreamDestroy(v31);
  size_t v32 = SLODWORD(__base[0]);
  v98[0] = malloc(4 * SLODWORD(__base[0]));
  if (!v98[0])
  {
    int v10 = *__error();
    int v13 = "malloc";
    __int16 v14 = 148;
    goto LABEL_10;
  }
  uint64_t v33 = (FILE **)MEMORY[0x263EF8348];
  BOOL v93 = v24;
  if (v9 >= 1)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "  %llu B, %d entries\n", __buf[1], v32);
    size_t v32 = SLODWORD(__base[0]);
  }
  qsort(__base[1], v32, 0x8A8uLL, (int (__cdecl *)(const void *, const void *))cmpINode);
  uint64_t v34 = LODWORD(__base[0]);
  if (SLODWORD(__base[0]) >= 1)
  {
    uint64_t v35 = 0;
    uint64_t v36 = (char *)__base[1];
    uint64_t v37 = (char *)__base[1] - 2184;
    do
    {
      int v38 = &v36[2216 * v35];
      uint64_t v39 = *((void *)v38 + 4);
      int v40 = *((_DWORD *)v38 + 548);
      int v41 = v38 + 2196;
      *((_DWORD *)v38 + 549) = v40;
      unint64_t v42 = (uint64_t *)v37;
      uint64_t v43 = v35;
      while (1)
      {
        int v44 = v43;
        if (v43-- < 1) {
          break;
        }
        uint64_t v46 = *v42;
        v42 -= 277;
        if (v46 != v39) {
          goto LABEL_47;
        }
      }
      int v44 = 0;
LABEL_47:
      if (v35 != v44)
      {
        unint64_t v47 = &v36[2216 * v44];
        int v48 = *((_DWORD *)v47 + 549);
        if (v48 >= v40)
        {
          uint64_t v49 = v44;
          if (v35 > v44)
          {
            unint64_t v50 = v47 + 2196;
            do
            {
              ++v49;
              *unint64_t v50 = v40;
              v50 += 554;
            }
            while (v35 != v49);
          }
        }
        else
        {
          *int v41 = v48;
        }
      }
      ++v35;
      v37 += 2216;
    }
    while (v35 != v34);
  }
  int v51 = v34;
  if (v9 > 1)
  {
    qsort(__base[1], (int)v34, 0x8A8uLL, (int (__cdecl *)(const void *, const void *))cmpIndex);
    int v51 = (int)__base[0];
    if (SLODWORD(__base[0]) >= 1)
    {
      __s = (char *)v23;
      unint64_t v52 = v33;
      uint64_t v53 = 0;
      uint64_t v54 = 2208;
      do
      {
        unint64_t v55 = *v52;
        if (v53 == *(_DWORD *)((char *)__base[1] + v54 - 12)) {
          fprintf(v55, "%d ino=%llu size=%llu -- %s\n");
        }
        else {
          fprintf(v55, "%d HLINK(%d) ino=%llu size=%llu -- %s = %s\n");
        }
        ++v53;
        int v51 = (int)__base[0];
        v54 += 2216;
      }
      while (v53 < SLODWORD(__base[0]));
      uint64_t v33 = v52;
      uint64_t v23 = __s;
    }
  }
  qsort(__base[1], v51, 0x8A8uLL, (int (__cdecl *)(const void *, const void *))cmpSortPath);
  int v56 = (int)__base[0];
  if (v9 >= 1)
  {
    if (SLODWORD(__base[0]) < 1) {
      goto LABEL_71;
    }
    unint64_t v57 = 0;
    char v58 = (unsigned int *)((char *)__base[1] + 2192);
    do
    {
      unint64_t v59 = v57;
      uint64_t v60 = *v58;
      ++v57;
      v58 += 554;
    }
    while (v59 == v60 && v57 < LODWORD(__base[0]));
    if (v59 == v60)
    {
LABEL_71:
      fwrite("Input archive is already sorted\n", 0x20uLL, 1uLL, *v33);
      int v56 = (int)__base[0];
    }
  }
  if (v56 >= 1)
  {
    uint64_t v62 = 0;
    long long v63 = __base[1];
    long long v64 = v98[0];
    do
    {
      v63[4] = -1;
      v64[*((int *)v63 + 548)] = v62++;
      v63 += 277;
    }
    while (v62 < SLODWORD(__base[0]));
    uint64_t v65 = LODWORD(__base[0]);
    if (SLODWORD(__base[0]) >= 1)
    {
      uint64_t v66 = 0;
      int64x2_t v67 = (char *)__base[1];
      int64x2_t v68 = (int *)v98[0];
      uint64_t v69 = __base[1];
      do
      {
        uint64_t v70 = &v67[2216 * v68[*((int *)v69 + 549)]];
        uint64_t v73 = *((void *)v70 + 4);
        uint64_t v72 = v70 + 32;
        uint64_t v71 = v73;
        if (v73 == -1)
        {
          *uint64_t v72 = v66;
          uint64_t v71 = v66++;
        }
        v69[4] = v71;
        v69 += 277;
        --v65;
      }
      while (v65);
    }
  }
  LODWORD(v98[1]) = open(*(const char **)(a1 + 8), 0);
  if (((uint64_t)v98[1] & 0x80000000) != 0)
  {
    int v10 = *__error();
    int v13 = *(const char **)(a1 + 8);
    __int16 v14 = 225;
    goto LABEL_10;
  }
  if (SLODWORD(__base[0]) < 1)
  {
    unint64_t v75 = 0;
  }
  else
  {
    uint64_t v74 = 0;
    unint64_t v75 = 0;
    __sa = (char *)v23;
    do
    {
      unint64_t v76 = (char *)__base[1] + 2216 * v74;
      unint64_t v77 = *((void *)v76 + 276);
      off_t v78 = *((void *)v76 + 275);
      uint64_t v92 = v74;
      if (v9 >= 2) {
        fprintf(*v33, "%d (old=%d) ino=%llu size=%llu -- %s\n", v74, *((_DWORD *)__base[1] + 554 * v74 + 548), *((void *)v76 + 4), v77, v76 + 144);
      }
      if (v77)
      {
        char v79 = 0;
        do
        {
          if (v77 >= 0x100000) {
            size_t v80 = 0x100000;
          }
          else {
            size_t v80 = v77;
          }
          ssize_t v81 = pread((int)v98[1], __buf[0], v80, v78);
          if (v81 < 0)
          {
            int v10 = *__error();
            int v13 = "read";
            __int16 v14 = 247;
            goto LABEL_10;
          }
          if (v81 != v80)
          {
            int v13 = "truncated read";
            __int16 v14 = 248;
            goto LABEL_9;
          }
          if ((v79 & 1) == 0)
          {
            if (v80 <= 5)
            {
              int v13 = "truncated header";
              __int16 v14 = 254;
              goto LABEL_9;
            }
            unint64_t v82 = *((void *)v76 + 4);
            if (*(_DWORD *)__buf[0] == 925906736 && *((_WORD *)__buf[0] + 2) == 14128)
            {
              if (v82 >= 0x40000)
              {
                int v13 = "inode index is too large";
                __int16 v14 = 257;
                goto LABEL_9;
              }
              if (v80 <= 0x4B)
              {
                int v13 = "truncated header";
                __int16 v14 = 258;
                goto LABEL_9;
              }
              toOctal6((unsigned char *)__buf[0] + 12, v82);
            }
            else
            {
              if (*(_DWORD *)__buf[0] != 925906736 || *((_WORD *)__buf[0] + 2) != 12592)
              {
                int v13 = "invalid header";
                __int16 v14 = 269;
                goto LABEL_9;
              }
              if (HIDWORD(v82))
              {
                int v13 = "inode index is too large";
                __int16 v14 = 264;
                goto LABEL_9;
              }
              if (v80 <= 0x6D)
              {
                int v13 = "truncated header";
                __int16 v14 = 265;
                goto LABEL_9;
              }
              toHex8((unsigned char *)__buf[0] + 6, v82);
            }
          }
          uint64_t v85 = (*(uint64_t (**)(void, void *, size_t))(a1 + 16))(*(void *)(a1 + 24), __buf[0], v80);
          if (v85 < 0)
          {
            int v13 = "write error";
            __int16 v14 = 275;
            goto LABEL_9;
          }
          if (v85 != v80)
          {
            int v13 = "truncated write";
            __int16 v14 = 276;
            goto LABEL_9;
          }
          v78 += v80;
          v75 += v80;
          char v79 = 1;
          v77 -= v80;
        }
        while (v77);
      }
      uint64_t v74 = v92 + 1;
      uint64_t v23 = __sa;
      uint64_t v33 = (FILE **)MEMORY[0x263EF8348];
    }
    while (v92 + 1 < SLODWORD(__base[0]));
  }
  if (!v93)
  {
    size_t v86 = strlen(v23);
    uint64_t v87 = (*(uint64_t (**)(void, const char *, size_t))(a1 + 16))(*(void *)(a1 + 24), v23, v86);
    if (v87 < 0)
    {
      int v13 = "write error";
      __int16 v14 = 290;
      goto LABEL_9;
    }
    if (v87 != v86)
    {
      int v13 = "truncated write";
      __int16 v14 = 291;
      goto LABEL_9;
    }
    v75 += v86;
  }
  if (v75 < st_size)
  {
    bzero(__buf[0], 0x100000uLL);
    while (1)
    {
      if (st_size - v75 >= 0x100000) {
        uint64_t v88 = 0x100000;
      }
      else {
        uint64_t v88 = st_size - v75;
      }
      uint64_t v89 = (*(uint64_t (**)(void, void *, uint64_t))(a1 + 16))(*(void *)(a1 + 24), __buf[0], v88);
      if (v89 < 0)
      {
        int v13 = "write error";
        __int16 v14 = 305;
        goto LABEL_9;
      }
      if (v89 != v88) {
        break;
      }
      v75 += v88;
      if (v75 >= st_size) {
        goto LABEL_11;
      }
    }
    int v13 = "truncated write";
    __int16 v14 = 306;
LABEL_9:
    int v10 = 0;
    goto LABEL_10;
  }
LABEL_11:
  if (((uint64_t)v98[1] & 0x80000000) == 0) {
    close((int)v98[1]);
  }
  free(__base[1]);
  free(v98[0]);
  free(__buf[0]);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (LODWORD(v96[0])) {
    unsigned int v17 = 0;
  }
  else {
    unsigned int v17 = -1;
  }
  if ((int)result >= 0) {
    return v17;
  }
  else {
    return result;
  }
}

uint64_t indexBeginProc(uint64_t a1, void *__src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v9 = *(_DWORD *)(a1 + 16);
  uint64_t v10 = *(int *)(a1 + 20);
  if (v9 < (int)v10)
  {
    uint64_t v11 = *(char **)(a1 + 24);
LABEL_5:
    *(_DWORD *)(a1 + 16) = v9 + 1;
    uint64_t v12 = &v11[2216 * v9];
    uint64_t result = (uint64_t)memcpy(v12, __src, 0x890uLL);
    *((_DWORD *)v12 + 548) = *(_DWORD *)(a1 + 16) - 1;
    uint64_t v14 = *(void *)(a1 + 56);
    *((void *)v12 + 275) = v14;
    *((void *)v12 + 276) = a6;
    *(void *)(a1 + 56) = v14 + a6;
    return result;
  }
  *(_DWORD *)(a1 + 20) = v10 + 10000;
  uint64_t v11 = (char *)reallocf(*(void **)(a1 + 24), 2216 * (v10 + 10000));
  *(void *)(a1 + 24) = v11;
  if (v11)
  {
    int v9 = *(_DWORD *)(a1 + 16);
    goto LABEL_5;
  }
  uint64_t v15 = __error();
  uint64_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Sort.c", (uint64_t)"indexBeginProc", 67, 49, *v15, "malloc", v16, v17, v18);
  *(_DWORD *)a1 = 0;
  return result;
}

uint64_t indexPayloadAndPaddingProc(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 24) + 2216 * *(int *)(result + 16);
  *(void *)(v3 - 8) += a3;
  *(void *)(result + 56) += a3;
  return result;
}

uint64_t cmpINode(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  unint64_t v3 = *(void *)(a2 + 32);
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v3 < v2;
  }
}

uint64_t cmpIndex(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 2192);
  int v3 = *(_DWORD *)(a2 + 2192);
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v3 < v2;
  }
}

uint64_t cmpSortPath(uint64_t a1, uint64_t a2)
{
  return strcmp((const char *)(a1 + 144), (const char *)(a2 + 144));
}

unsigned char *toOctal6(unsigned char *result, unint64_t a2)
{
  *uint64_t result = toOctal6_oct[(a2 >> 15) & 7];
  result[1] = toOctal6_oct[(a2 >> 12) & 7];
  result[2] = toOctal6_oct[(a2 >> 9) & 7];
  result[3] = toOctal6_oct[(a2 >> 6) & 7];
  result[4] = toOctal6_oct[(a2 >> 3) & 7];
  result[5] = toOctal6_oct[a2 & 7];
  return result;
}

unsigned char *toHex8(unsigned char *result, unint64_t a2)
{
  *uint64_t result = toHex8_hex[a2 >> 28];
  result[1] = toHex8_hex[(a2 >> 24) & 0xF];
  result[2] = toHex8_hex[(a2 >> 20) & 0xF];
  result[3] = toHex8_hex[(a2 >> 16) & 0xF];
  result[4] = toHex8_hex[(unsigned __int16)a2 >> 12];
  result[5] = toHex8_hex[(a2 >> 8) & 0xF];
  result[6] = toHex8_hex[a2 >> 4];
  result[7] = toHex8_hex[a2 & 0xF];
  return result;
}

char *ParallelArchiveOLDWriterCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v21);
  int v9 = (char *)calloc(1uLL, 0x608uLL);
  uint64_t v10 = v9;
  if (!v9)
  {
    int v17 = *__error();
    uint64_t v15 = "malloc";
    __int16 v16 = 122;
    goto LABEL_12;
  }
  *((_DWORD *)v9 + 258) = *(_DWORD *)(a1 + 8);
  size_t v11 = strlen(*(const char **)a1);
  *(void *)uint64_t v10 = v11;
  if (v11 - 1024 >= 0xFFFFFFFFFFFFFBFFLL)
  {
    __strlcpy_chk();
    *((void *)v10 + 168) = 0x40000;
    uint64_t v12 = malloc(0x40000uLL);
    *((void *)v10 + 171) = v12;
    if (v12)
    {
      if (pthread_mutex_init((pthread_mutex_t *)(v10 + 1464), 0))
      {
        uint64_t v15 = "pthread_mutex_init";
        __int16 v16 = 138;
      }
      else
      {
        *((_DWORD *)v10 + 260) = 0;
        if (pthread_mutex_init((pthread_mutex_t *)(v10 + 1048), 0)
          || pthread_cond_init((pthread_cond_t *)(v10 + 1112), 0))
        {
          uint64_t v15 = "SemInit";
          __int16 v16 = 141;
        }
        else
        {
          *((_DWORD *)v10 + 290) = 0;
          if (pthread_mutex_init((pthread_mutex_t *)(v10 + 1168), 0)
            || pthread_cond_init((pthread_cond_t *)(v10 + 1232), 0))
          {
            uint64_t v15 = "SemInit";
            __int16 v16 = 142;
          }
          else if (pthread_mutex_init((pthread_mutex_t *)v10 + 20, 0))
          {
            uint64_t v15 = "pthread_mutex_init";
            __int16 v16 = 143;
          }
          else
          {
            if (!writerReleaseSem((uint64_t)v10))
            {
              uint64_t v19 = (uint64_t)(v10 + 1384);
              *((_DWORD *)v10 + 346) = 0;
              *((_DWORD *)v10 + 348) = *(_DWORD *)(a1 + 12);
              *((void *)v10 + 176) = writerReceiveData;
              *((void *)v10 + 178) = v10;
              *((void *)v10 + 179) = *(void *)(a1 + 32);
              *((void *)v10 + 181) = *(void *)(a1 + 48);
              int DefaultNThreads = *(_DWORD *)(a1 + 16);
              if (!DefaultNThreads)
              {
                int DefaultNThreads = getDefaultNThreads();
                uint64_t v19 = (uint64_t)(v10 + 1384);
              }
              *((_DWORD *)v10 + 347) = DefaultNThreads;
              *((void *)v10 + 175) = *(void *)(a1 + 24);
              if (!createThread((pthread_t *)v10 + 182, (uint64_t)ParallelArchiveEncoderProc, v19, 0))
              {
                if ((leaveThreadErrorContext(0, 0, 0) & 0x80000000) == 0) {
                  return v10;
                }
                goto LABEL_14;
              }
              int v17 = *__error();
              uint64_t v15 = "compressor thread";
              __int16 v16 = 155;
              goto LABEL_12;
            }
            uint64_t v15 = "writerReleaseSem";
            __int16 v16 = 144;
          }
        }
      }
      int v17 = 0;
    }
    else
    {
      int v17 = *__error();
      uint64_t v15 = "malloc";
      __int16 v16 = 135;
    }
LABEL_12:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/MSUArchive.c", (uint64_t)"ParallelArchiveOLDWriterCreate", v16, 47, v17, v15, v13, v14, v22);
  }
  leaveThreadErrorContext(0, 0, 0);
LABEL_14:
  free(*((void **)v10 + 171));
  free(v10);
  return 0;
}

uint64_t writerReleaseSem(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 1032);
  uint64_t v3 = *(void *)(a1 + 1360) - *(void *)(a1 + 1352);
  if (v3)
  {
    if (v2 >= 3) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "Release bufferReady, buffer size: %zu\n", v3);
    }
    BOOL v4 = (pthread_mutex_t *)(a1 + 1168);
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 1168))) {
      return 0xFFFFFFFFLL;
    }
    int v7 = *(_DWORD *)(a1 + 1160);
    *(_DWORD *)(a1 + 1160) = v7 + 1;
    if (v7) {
      goto LABEL_14;
    }
    int v6 = (pthread_cond_t *)(a1 + 1232);
    goto LABEL_12;
  }
  if (v2 >= 3) {
    fwrite("Release bufferEmpty\n", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  BOOL v4 = (pthread_mutex_t *)(a1 + 1048);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 1048))) {
    return 0xFFFFFFFFLL;
  }
  int v5 = *(_DWORD *)(a1 + 1040);
  *(_DWORD *)(a1 + 1040) = v5 + 1;
  if (!v5)
  {
    int v6 = (pthread_cond_t *)(a1 + 1112);
LABEL_12:
    if (pthread_cond_broadcast(v6)) {
      return 0xFFFFFFFFLL;
    }
  }
LABEL_14:
  if (pthread_mutex_unlock(v4)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t writerReceiveData(uint64_t a1, void *a2, size_t a3)
{
  int v3 = *(_DWORD *)(a1 + 1032);
  if (*(_DWORD *)(a1 + 1376))
  {
    if (v3 >= 3) {
      fwrite("writerReceiveData: ZERO (end of stream)\n", 0x28uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    }
    return 0;
  }
  else
  {
    size_t v4 = a3;
    if (v3 >= 3) {
      fwrite("Acquire bufferReady\n", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    }
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 1168))) {
      return -1;
    }
    while (1)
    {
      int v7 = *(_DWORD *)(a1 + 1160);
      if (v7 > 0) {
        break;
      }
      if (pthread_cond_wait((pthread_cond_t *)(a1 + 1232), (pthread_mutex_t *)(a1 + 1168))) {
        return -1;
      }
    }
    *(_DWORD *)(a1 + 1160) = v7 - 1;
    if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1168))) {
      return -1;
    }
    uint64_t v8 = *(void *)(a1 + 1352);
    if (*(void *)(a1 + 1360) - v8 < v4) {
      size_t v4 = *(void *)(a1 + 1360) - v8;
    }
    if (v4)
    {
      memcpy(a2, (const void *)(*(void *)(a1 + 1368) + v8), v4);
      *(void *)(a1 + 1352) += v4;
    }
    else
    {
      if (*(int *)(a1 + 1032) >= 3) {
        fwrite("end of stream\n", 0xEuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
      }
      *(_DWORD *)(a1 + 1376) = 1;
    }
    if (writerReleaseSem(a1))
    {
      return -1;
    }
    else if (*(int *)(a1 + 1032) >= 3)
    {
      fprintf((FILE *)*MEMORY[0x263EF8348], "writerReceiveData: %zu\n", v4);
    }
  }
  return v4;
}

uint64_t ParallelArchiveEncoderProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 0;
}

uint64_t ParallelArchiveOLDWriterAddEntry(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v62 = *MEMORY[0x263EF8340];
  enterThreadErrorContext(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v55);
  memset(&v58, 0, sizeof(v58));
  bzero(v61, 0x400uLL);
  bzero(__s, 0x400uLL);
  if (!a1 || !a2)
  {
    int v17 = "invalid args";
    __int16 v18 = 179;
LABEL_10:
    int v19 = 0;
LABEL_11:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/MSUArchive.c", (uint64_t)"ParallelArchiveOLDWriterAddEntry", v18, 47, v19, v17, v10, v11, st_mode);
    goto LABEL_12;
  }
  size_t v12 = strlen(a2);
  if (*a2 == 47 || (size_t v13 = v12, v12 >= 0x400))
  {
    char st_mode = (char)a2;
    int v17 = "invalid path: %s";
    __int16 v18 = 185;
    goto LABEL_10;
  }
  if (concatPath(v61, 0x400uLL, (char *)(a1 + 8), a2))
  {
LABEL_12:
    int v20 = 0;
    goto LABEL_13;
  }
  if (lstat(v61, &v58))
  {
    int v14 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/MSUArchive.c", (uint64_t)"ParallelArchiveOLDWriterAddEntry", 191, 47, v14, "%s", v15, v16, (char)v61);
    goto LABEL_12;
  }
  int v20 = 0;
  if (HIWORD(v58.st_uid) || HIWORD(v58.st_gid)) {
    goto LABEL_13;
  }
  int v23 = v58.st_mode & 0xF000;
  if (v23 == 0x4000)
  {
    int v26 = 0;
    unint64_t st_size = 0;
    int v27 = -1;
    int v28 = 2;
    goto LABEL_48;
  }
  if (v23 == 0x8000)
  {
    unint64_t st_size = v58.st_size;
    if (v58.st_nlink >= 2u)
    {
      if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 1464))) {
        goto LABEL_12;
      }
      uint64_t v29 = *(unsigned int *)(a1 + 1532);
      if ((int)v29 < 1)
      {
        LODWORD(v30) = 0;
      }
      else
      {
        uint64_t v30 = 0;
        uint64_t v31 = *(void **)(a1 + 1536);
        while (*v31 != v58.st_ino)
        {
          v31 += 129;
          if (v29 == ++v30) {
            goto LABEL_38;
          }
        }
      }
      if (v30 != v29)
      {
        __strlcpy_chk();
        unint64_t st_size = strlen(__s);
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1464));
        int v26 = 0;
        int v27 = -1;
        int v28 = 4;
        goto LABEL_48;
      }
LABEL_38:
      if (v29 == *(_DWORD *)(a1 + 1528))
      {
        int v35 = 2 * v29;
        if (!v29) {
          int v35 = 16;
        }
        *(_DWORD *)(a1 + 1528) = v35;
        uint64_t v36 = (char *)reallocf(*(void **)(a1 + 1536), 1032 * v35);
        *(void *)(a1 + 1536) = v36;
        if (!v36)
        {
          *(void *)(a1 + 1528) = 0;
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1464));
          int v19 = *__error();
          int v17 = "malloc";
          __int16 v18 = 226;
          goto LABEL_11;
        }
      }
      else
      {
        uint64_t v36 = *(char **)(a1 + 1536);
      }
      uint64_t v37 = 129 * v29;
      bzero(&v36[8 * v37], 0x408uLL);
      int v38 = (__darwin_ino64_t *)(*(void *)(a1 + 1536) + 8 * v37);
      *int v38 = v58.st_ino;
      memcpy(v38 + 1, a2, v13);
      ++*(_DWORD *)(a1 + 1532);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1464));
    }
    int v39 = open(v61, 0);
    if (v39 < 0)
    {
      int v48 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/MSUArchive.c", (uint64_t)"ParallelArchiveOLDWriterAddEntry", 261, 47, v48, "%s", v49, v50, (char)v61);
      goto LABEL_12;
    }
    int v27 = v39;
    int v26 = 1;
    int v28 = 1;
    goto LABEL_48;
  }
  if (v23 != 40960)
  {
    char st_mode = v58.st_mode;
    int v17 = "unsupported entry type %d";
    __int16 v18 = 199;
    goto LABEL_10;
  }
  ssize_t v24 = readlink(v61, __s, 0x3FFuLL);
  if (v24 < 1)
  {
    int v32 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/MSUArchive.c", (uint64_t)"ParallelArchiveOLDWriterAddEntry", 252, 47, v32, "%s", v33, v34, (char)v61);
    goto LABEL_12;
  }
  unint64_t st_size = v24;
  int v26 = 0;
  __s[v24] = 0;
  int v27 = -1;
  int v28 = 3;
LABEL_48:
  *(void *)unint64_t v59 = 0;
  *(void *)&v59[8] = 0;
  *(void *)&v59[22] = 0;
  *(void *)&v59[16] = 0;
  setHeaderFromValues_v10((uint64_t)v59, v28, st_size, v58.st_mtimespec.tv_sec, v58.st_flags, (unsigned __int16)v13, LOWORD(v58.st_uid), LOWORD(v58.st_gid), v58.st_mode);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 1280)))
  {
    int v40 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/MSUArchive.c", (uint64_t)"ParallelArchiveOLDWriterAddEntry", 295, 47, *v40, "pthread_mutex_lock", v41, v42, v57);
    int v20 = 0;
  }
  else
  {
    if (!writerAcquireEmpty(a1))
    {
      *(_OWORD *)(a1 + 1352) = 0u;
      int v44 = *(_OWORD **)(a1 + 1368);
      long long v45 = *(_OWORD *)v59;
      *(_OWORD *)((char *)v44 + 14) = *(_OWORD *)&v59[14];
      *int v44 = v45;
      uint64_t v46 = *(void *)(a1 + 1360) + 30;
      *(void *)(a1 + 1360) = v46;
      memcpy((void *)(*(void *)(a1 + 1368) + v46), a2, v13);
      size_t v47 = *(void *)(a1 + 1360) + v13;
      *(void *)(a1 + 1360) = v47;
      if ((v28 - 3) > 1)
      {
        if (v26)
        {
          if (*(void *)(a1 + 1344) - v47 >= st_size) {
            size_t v51 = st_size;
          }
          else {
            size_t v51 = *(void *)(a1 + 1344) - v47;
          }
          ssize_t v52 = read(v27, (void *)(*(void *)(a1 + 1368) + v47), v51);
          if (v52 < 0) {
            goto LABEL_67;
          }
          *(void *)(a1 + 1360) += v52;
          st_size -= v52;
        }
        int v43 = 1;
      }
      else
      {
        memcpy((void *)(*(void *)(a1 + 1368) + v47), __s, st_size);
        *(void *)(a1 + 1360) += st_size;
        int v43 = 1;
        unint64_t st_size = 0;
      }
      while (!writerReleaseSem(a1))
      {
        if (!st_size) {
          goto LABEL_52;
        }
        if (writerAcquireEmpty(a1)) {
          break;
        }
        *(void *)(a1 + 1352) = 0;
        *(void *)(a1 + 1360) = 0;
        if (*(void *)(a1 + 1344) >= st_size) {
          size_t v53 = st_size;
        }
        else {
          size_t v53 = *(void *)(a1 + 1344);
        }
        ssize_t v54 = read(v27, *(void **)(a1 + 1368), v53);
        if (v54 < 0)
        {
LABEL_67:
          int v43 = 0;
        }
        else
        {
          *(void *)(a1 + 1360) += v54;
          st_size -= v54;
        }
      }
    }
    int v43 = 0;
LABEL_52:
    if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1280))) {
      int v20 = 0;
    }
    else {
      int v20 = v43;
    }
  }
  if ((v27 & 0x80000000) == 0) {
    close(v27);
  }
LABEL_13:
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (v20) {
    unsigned int v22 = 0;
  }
  else {
    unsigned int v22 = -1;
  }
  if ((int)result >= 0) {
    return v22;
  }
  else {
    return result;
  }
}

uint64_t writerAcquireEmpty(uint64_t a1)
{
  if (*(int *)(a1 + 1032) >= 3) {
    fwrite("Acquire bufferEmpty\n", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 1048))) {
    return 0xFFFFFFFFLL;
  }
  while (1)
  {
    int v2 = *(_DWORD *)(a1 + 1040);
    if (v2 > 0) {
      break;
    }
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 1112), (pthread_mutex_t *)(a1 + 1048))) {
      return 0xFFFFFFFFLL;
    }
  }
  *(_DWORD *)(a1 + 1040) = v2 - 1;
  if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1048))) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t ParallelArchiveOLDWriterDestroy(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = result;
    enterThreadErrorContext(result, a2, a3, a4, a5, a6, a7, a8, v19);
    if (pthread_mutex_lock((pthread_mutex_t *)(v8 + 1048)))
    {
LABEL_5:
      BOOL v10 = 0;
    }
    else
    {
      while (1)
      {
        int v9 = *(_DWORD *)(v8 + 1040);
        if (v9 > 0) {
          break;
        }
        if (pthread_cond_wait((pthread_cond_t *)(v8 + 1112), (pthread_mutex_t *)(v8 + 1048))) {
          goto LABEL_5;
        }
      }
      *(_DWORD *)(v8 + 1040) = v9 - 1;
      BOOL v10 = pthread_mutex_unlock((pthread_mutex_t *)(v8 + 1048)) == 0;
    }
    if (pthread_mutex_lock((pthread_mutex_t *)(v8 + 1168))
      || (int v12 = *(_DWORD *)(v8 + 1160), *(_DWORD *)(v8 + 1160) = v12 + 1, !v12)
      && pthread_cond_broadcast((pthread_cond_t *)(v8 + 1232)))
    {
      BOOL v11 = 0;
    }
    else if (pthread_mutex_unlock((pthread_mutex_t *)(v8 + 1168)))
    {
      BOOL v11 = 0;
    }
    else
    {
      BOOL v11 = v10;
    }
    if (pthread_mutex_lock((pthread_mutex_t *)(v8 + 1048)))
    {
LABEL_15:
      BOOL v14 = 0;
    }
    else
    {
      while (1)
      {
        int v13 = *(_DWORD *)(v8 + 1040);
        if (v13 > 0) {
          break;
        }
        if (pthread_cond_wait((pthread_cond_t *)(v8 + 1112), (pthread_mutex_t *)(v8 + 1048))) {
          goto LABEL_15;
        }
      }
      *(_DWORD *)(v8 + 1040) = v13 - 1;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v8 + 1048))) {
        BOOL v14 = 0;
      }
      else {
        BOOL v14 = v11;
      }
    }
    joinThread(*(_opaque_pthread_t **)(v8 + 1456));
    if (pthread_mutex_destroy((pthread_mutex_t *)(v8 + 1048)))
    {
      BOOL v15 = 0;
    }
    else if (pthread_cond_destroy((pthread_cond_t *)(v8 + 1112)))
    {
      BOOL v15 = 0;
    }
    else
    {
      BOOL v15 = v14;
    }
    if (pthread_mutex_destroy((pthread_mutex_t *)(v8 + 1168)))
    {
      unsigned int v16 = -1;
    }
    else
    {
      if (pthread_cond_destroy((pthread_cond_t *)(v8 + 1232))) {
        BOOL v17 = 1;
      }
      else {
        BOOL v17 = !v15;
      }
      int v18 = v17;
      unsigned int v16 = v18 << 31 >> 31;
    }
    pthread_mutex_destroy((pthread_mutex_t *)(v8 + 1464));
    pthread_mutex_destroy((pthread_mutex_t *)(v8 + 1280));
    free(*(void **)(v8 + 1536));
    free(*(void **)(v8 + 1368));
    free((void *)v8);
    LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
    if ((int)result >= 0) {
      return v16;
    }
    else {
      return result;
    }
  }
  return result;
}

uint64_t forceInPlaceControls(unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, int a5)
{
  if (a1 <= a2) {
    unint64_t v8 = a2;
  }
  else {
    unint64_t v8 = a1;
  }
  size_t v9 = ((v8 + 4095) >> 12) + 16;
  if (a5 >= 3) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "Post-processing ctrl for in-place patching, %u pages\n", v9);
  }
  BOOL v10 = calloc(v9, 4uLL);
  BOOL v11 = (char *)calloc(v9, 4uLL);
  int v12 = v11;
  if (v10) {
    BOOL v13 = v11 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13)
  {
    if (a4)
    {
      uint64_t v19 = 0;
      unint64_t v20 = 0;
      int v21 = v9;
      do
      {
        unsigned int v22 = (unint64_t *)(a3 + 24 * v19);
        unint64_t v23 = *v22;
        if ((*v22 & 0x8000000000000000) != 0) {
          unint64_t v23 = 0x8000000000000000 - *v22;
        }
        uint64_t v24 = v22[2];
        if (v24 < 0) {
          uint64_t v24 = 0x8000000000000000 - v24;
        }
        unint64_t v25 = v20 >> 12;
        if (v23) {
          int v26 = ((v20 + v23 - 1) >> 12) - (v20 >> 12) + 1;
        }
        else {
          int v26 = 0;
        }
        uint64_t v27 = (v26 + v25);
        if (v27 > v25)
        {
          int v28 = &v10[v25];
          uint64_t v29 = v27 - v25;
          do
          {
            int v21 = (__PAIR64__(v21, (*v28++)++) - 1) >> 32;
            --v29;
          }
          while (v29);
        }
        v20 += v23 + v24;
        ++v19;
      }
      while (v19 != a4);
    }
    else
    {
      int v21 = v9;
    }
    if (a5 > 1) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "After input pages retained, %u free pages\n", v21);
    }
    if (a4)
    {
      uint64_t v30 = 0;
      unint64_t v31 = 0;
      unint64_t v32 = 0;
      int v33 = v21;
      do
      {
        uint64_t v34 = (unint64_t *)(a3 + 24 * v30);
        uint64_t v35 = v34[1];
        unint64_t v36 = 0x8000000000000000 - *v34;
        if ((*v34 & 0x8000000000000000) == 0) {
          unint64_t v36 = *v34;
        }
        unint64_t v37 = 0x8000000000000000 - v35;
        if (v35 >= 0) {
          unint64_t v37 = v34[1];
        }
        uint64_t v38 = v34[2];
        if (v38 < 0) {
          uint64_t v38 = 0x8000000000000000 - v38;
        }
        if (v36)
        {
          unint64_t v39 = v36 + v31;
          do
          {
            unint64_t v40 = (v31 & 0xFFFFFFFFFFFFF000) + 4096;
            if (v40 >= v39) {
              unint64_t v40 = v39;
            }
            unint64_t v41 = v32 >> 12;
            unint64_t v42 = v40 - v31;
            if (v40 == v31) {
              int v43 = 0;
            }
            else {
              int v43 = ((v32 + v42 - 1) >> 12) - v41 + 1;
            }
            unint64_t v44 = v31 >> 12;
            int v45 = v10[v44] - 1;
            v10[v44] = v45;
            if (!v45) {
              ++v21;
            }
            uint64_t v46 = (v43 + v41);
            if (v46 > v41)
            {
              size_t v47 = &v12[4 * v41];
              uint64_t v48 = v46 - v41;
              do
              {
                int v21 = (__PAIR64__(v21, (*(_DWORD *)v47)++) - 1) >> 32;
                v47 += 4;
                --v48;
              }
              while (v48);
            }
            v32 += v42;
            if (v21 < v33) {
              int v33 = v21;
            }
            unint64_t v31 = v40;
            v36 -= v42;
          }
          while (v36);
        }
        else
        {
          unint64_t v40 = v31;
        }
        unint64_t v31 = v40 + v38;
        v32 += v37;
        ++v30;
      }
      while (v30 != a4);
    }
    else
    {
      int v33 = v21;
    }
    if (a5 > 2)
    {
      uint64_t v49 = (FILE **)MEMORY[0x263EF8348];
      fprintf((FILE *)*MEMORY[0x263EF8348], "Free pages after diff controls: %u\n", v21);
      fprintf(*v49, "Min free pages reached: %d\n", v33);
    }
    bzero(v10, 4 * v9);
    if (a4)
    {
      uint64_t v50 = 0;
      unint64_t v51 = 0;
      do
      {
        ssize_t v52 = (unint64_t *)(a3 + 24 * v50);
        unint64_t v53 = *v52;
        if ((*v52 & 0x8000000000000000) != 0) {
          unint64_t v53 = 0x8000000000000000 - *v52;
        }
        uint64_t v54 = v52[2];
        if (v54 < 0) {
          uint64_t v54 = 0x8000000000000000 - v54;
        }
        unint64_t v55 = v51 >> 12;
        if (v53) {
          int v56 = ((v51 + v53 - 1) >> 12) - (v51 >> 12) + 1;
        }
        else {
          int v56 = 0;
        }
        uint64_t v57 = (v56 + v55);
        if (v57 > v55)
        {
          stat v58 = &v10[v55];
          uint64_t v59 = v57 - v55;
          do
          {
            ++*v58++;
            --v59;
          }
          while (v59);
        }
        v51 += v53 + v54;
        ++v50;
      }
      while (v50 != a4);
      BOOL v60 = v33 < 4;
      ssize_t v81 = v12;
      if (v33 <= 3)
      {
        uint64_t v82 = a3;
        unint64_t v83 = a4;
        unint64_t v61 = 0;
        unint64_t v62 = 0;
        int64x2_t v63 = vdupq_n_s64(0x8000000000000000);
        int64x2_t v84 = v63;
        do
        {
          long long v64 = (int64x2_t *)(v82 + 24 * v61);
          int64x2_t v65 = (int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(*v64), (int8x16_t)vsubq_s64(v63, *v64), *(int8x16_t *)v64);
          uint64_t v66 = v64[1].i64[0];
          if (v66 >= 0) {
            uint64_t v67 = v64[1].i64[0];
          }
          else {
            uint64_t v67 = 0x8000000000000000 - v66;
          }
          if (a5 >= 3)
          {
            int64x2_t v87 = v65;
            fprintf((FILE *)*MEMORY[0x263EF8348], "ctrl[%zu]: ndiff=%llu nlit=%llu\n", v61, v65.i64[0], v65.i64[1]);
            int64x2_t v65 = v87;
            int64x2_t v63 = v84;
          }
          unint64_t v68 = v65.i64[0];
          if (v65.i64[0])
          {
            do
            {
              unint64_t v69 = v65.i64[0] + v62;
              unint64_t v70 = (v65.i64[0] + v62 - 1) & 0xFFFFFFFFFFFFF000;
              if (v70 <= v62) {
                unint64_t v70 = v62;
              }
              int v71 = v10[(v70 >> 12)] - 1;
              v10[(v70 >> 12)] = v71;
              if (!v71) {
                ++v33;
              }
              unint64_t v72 = v69 - v70;
              int64x2_t v73 = vdupq_n_s64(v69 - v70);
              unint64_t v74 = vsubq_s64(v65, v73).u64[0];
              if (a5 >= 3)
              {
                int64x2_t v88 = v65;
                int64x2_t v85 = v73;
                unint64_t v86 = v74;
                fprintf((FILE *)*MEMORY[0x263EF8348], "ctrl[%zu]: moving %llu bytes from diff to lit (minFree=%d, ndiff=%llu)\n", v61, v72, v33, v74);
                int64x2_t v73 = v85;
                unint64_t v74 = v86;
                int64x2_t v65 = v88;
                int64x2_t v63 = v84;
              }
              int64x2_t v75 = vaddq_s64(v65, v73);
              v65.i64[0] = v74;
              v65.i64[1] = v75.i64[1];
              v67 += v72;
              *(int8x16_t *)long long v64 = vbslq_s8((int8x16_t)vcltzq_s64(v65), (int8x16_t)vsubq_s64(v63, v65), (int8x16_t)v65);
              uint64_t v76 = 0x8000000000000000 - v67;
              if (v67 >= 0) {
                uint64_t v76 = v67;
              }
              v64[1].i64[0] = v76;
              unint64_t v68 = v74;
            }
            while (v33 <= 3 && v74 != 0);
          }
          ++v61;
          BOOL v60 = v33 < 4;
          if (v61 >= v83) {
            break;
          }
          v62 += v68 + v67;
        }
        while (v33 <= 3);
      }
      int v12 = v81;
      if (v60) {
        goto LABEL_96;
      }
    }
    else if (v33 < 4)
    {
LABEL_96:
      char v80 = 4;
      BOOL v17 = "Could not reduce minFree to %d, something is wrong";
      __int16 v18 = 264;
      int v14 = 0;
      goto LABEL_97;
    }
    uint64_t v78 = 0;
    goto LABEL_100;
  }
  int v14 = *__error();
  BOOL v17 = "malloc";
  __int16 v18 = 139;
LABEL_97:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffControls.c", (uint64_t)"forceInPlaceControls", v18, 53, v14, v17, v15, v16, v80);
  uint64_t v78 = 0xFFFFFFFFLL;
LABEL_100:
  free(v10);
  free(v12);
  return v78;
}

void *initDiffSegmentVector(void *result)
{
  *uint64_t result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

uint64_t reserveDiffSegmentVector(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 8) >= a2) {
    return 0;
  }
  *(void *)(a1 + 8) = a2;
  int v3 = reallocf(*(void **)(a1 + 16), 24 * a2);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    return 0;
  }
  int v5 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffControls.c", (uint64_t)"reserveDiffSegmentVector", 327, 53, *v5, "reallocf", v6, v7, v8);
  return 0xFFFFFFFFLL;
}

__n128 pushDiffSegment(unint64_t *a1, __n128 *a2)
{
  if (!a2[1].n128_u64[0]) {
    return result;
  }
  unint64_t v4 = *a1;
  unint64_t v5 = a1[1];
  if (*a1 < v5)
  {
LABEL_10:
    unint64_t v8 = a1[2];
    *a1 = v4 + 1;
    size_t v9 = (__n128 *)(v8 + 24 * v4);
    __n128 result = *a2;
    v9[1].n128_u64[0] = a2[1].n128_u64[0];
    *size_t v9 = result;
    return result;
  }
  if (v5) {
    unint64_t v6 = v5 + (v5 >> 1);
  }
  else {
    unint64_t v6 = 64;
  }
  if (!reserveDiffSegmentVector((uint64_t)a1, v6))
  {
    unint64_t v4 = *a1;
    goto LABEL_10;
  }
  return result;
}

uint64_t pushControls(unint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  if (a3)
  {
    uint64_t v9 = 0;
    BOOL v10 = (unint64_t *)(a2 + 16);
    int v11 = 1;
    do
    {
      uint64_t v12 = *(v10 - 2);
      uint64_t v13 = *(v10 - 1);
      if (v12 >= 0) {
        unint64_t v14 = *(v10 - 2);
      }
      else {
        unint64_t v14 = 0x8000000000000000 - v12;
      }
      if (v13 >= 0) {
        unint64_t v15 = *(v10 - 1);
      }
      else {
        unint64_t v15 = 0x8000000000000000 - v13;
      }
      if ((*v10 & 0x8000000000000000) == 0) {
        unint64_t v16 = *v10;
      }
      else {
        unint64_t v16 = 0x8000000000000000 - *v10;
      }
      v21.n128_u64[0] = a5;
      v21.n128_u64[1] = a4;
      unint64_t v22 = v14;
      pushDiffSegment(a1, &v21);
      if (v17) {
        break;
      }
      unint64_t v18 = v14 + a5;
      v21.n128_u64[0] = v18;
      v21.n128_u64[1] = -1;
      unint64_t v22 = v15;
      pushDiffSegment(a1, &v21);
      if (v19) {
        break;
      }
      v10 += 3;
      a4 += v14 + v16;
      a5 = v18 + v15;
      int v11 = ++v9 < a3;
    }
    while (a3 != v9);
  }
  else
  {
    int v11 = 0;
  }
  return (v11 << 31 >> 31);
}

uint64_t mergeDiffSegmentVectors(unint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0;
  }
  uint64_t v10 = 0;
  unint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  long long v61 = 0uLL;
  unint64_t v62 = 0;
  do
  {
    unint64_t v14 = &a2[3 * v13];
    uint64_t v15 = *v14;
    if (!*v14)
    {
      uint64_t v38 = "empty segment vector";
      __int16 v39 = 429;
LABEL_62:
      int v37 = 0;
LABEL_32:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffControls.c", (uint64_t)"mergeDiffSegmentVectors", v39, 53, v37, v38, a7, a8, v56);
      goto LABEL_33;
    }
    unint64_t v16 = (void *)(v14[2] + 16);
    do
    {
      if (v10 + 4 > v11)
      {
        v11 += 0x4000;
        uint64_t v12 = (char *)reallocf(v12, 16 * v11);
        if (!v12)
        {
          int v37 = *__error();
          uint64_t v38 = "malloc";
          __int16 v39 = 437;
          goto LABEL_32;
        }
      }
      uint64_t v17 = *(v16 - 2);
      if (*(v16 - 1) == -1)
      {
        uint64_t v21 = *v16 + v17;
        uint64_t v20 = v10 + 1;
        unint64_t v22 = &v12[16 * v10];
        *(void *)unint64_t v22 = v17;
        *((void *)v22 + 1) = 1;
        int v19 = &v12[16 * v10 + 16];
        *(void *)int v19 = v21;
        int v18 = -1;
      }
      else
      {
        int v18 = 0;
        int v19 = &v12[16 * v10];
        *(void *)int v19 = v17;
        uint64_t v20 = v10;
      }
      *((_DWORD *)v19 + 2) = v18;
      *((_DWORD *)v19 + 3) = 0;
      uint64_t v10 = v20 + 1;
      v16 += 3;
      --v15;
    }
    while (v15);
    ++v13;
  }
  while (v13 != a1);
  uint64_t v23 = a2[2] + 24 * *a2;
  size_t v24 = v20 + 2;
  unint64_t v25 = &v12[16 * v10];
  *(void *)unint64_t v25 = *(void *)(v23 - 8) + *(void *)(v23 - 24);
  *((void *)v25 + 1) = 0;
  qsort(v12, v24, 0x10uLL, (int (__cdecl *)(const void *, const void *))mergeDiffSegmentEventCompareProc);
  if (v24)
  {
    size_t v26 = 0;
    unint64_t v27 = 0;
    int v28 = 0;
    while (1)
    {
      int v29 = 0;
      uint64_t v30 = *(void *)&v12[16 * v26];
      if (v24 <= v26 + 1) {
        size_t v31 = v26 + 1;
      }
      else {
        size_t v31 = v24;
      }
      unint64_t v32 = &v12[16 * v26 + 8];
      while (*((void *)v32 - 1) == v30)
      {
        int v33 = *(_DWORD *)v32;
        v32 += 16;
        v29 += v33;
        if (v31 == ++v26)
        {
          size_t v26 = v31;
          break;
        }
      }
      if (v29 | v28)
      {
        if (!v29) {
          goto LABEL_28;
        }
        if (!v28)
        {
          unint64_t v36 = &v12[16 * v27];
          *(void *)unint64_t v36 = v30;
          *((_DWORD *)v36 + 2) = 1;
          ++v27;
        }
        v28 += v29;
        if (v28) {
          goto LABEL_28;
        }
        int v34 = -1;
      }
      else
      {
        int v34 = 0;
      }
      int v28 = 0;
      uint64_t v35 = &v12[16 * v27];
      *(void *)uint64_t v35 = v30;
      *((_DWORD *)v35 + 2) = v34;
      ++v27;
LABEL_28:
      if (v26 >= v24) {
        goto LABEL_39;
      }
    }
  }
  unint64_t v27 = 0;
LABEL_39:
  uint64_t v42 = 0;
  if (a1 <= 1) {
    uint64_t v43 = 1;
  }
  else {
    uint64_t v43 = a1;
  }
  uint64_t v56 = v43;
  while (1)
  {
    unint64_t v44 = &a2[3 * v42];
    unint64_t v45 = *v44;
    unint64_t v58 = v44[2];
    if (reserveDiffSegmentVector((uint64_t)&v61, v27)) {
      break;
    }
    uint64_t v57 = v42;
    if (v27)
    {
      uint64_t v46 = 0;
      unint64_t v47 = 0;
      int v48 = 0;
      unint64_t v49 = 0;
      while (1)
      {
        uint64_t v50 = (unint64_t *)&v12[16 * v46];
        unint64_t v51 = *v50;
        if (v49 < v45)
        {
          ssize_t v52 = (void *)(v58 + 16 + 24 * v49);
          while (*v52 + *(v52 - 2) < v51)
          {
            v52 += 3;
            if (v45 == ++v49) {
              goto LABEL_61;
            }
          }
        }
        if (v49 == v45) {
          break;
        }
        if (v46)
        {
          if (v48) {
            unint64_t v53 = -1;
          }
          else {
            unint64_t v53 = *(void *)(v58 + 24 * v49 + 8) + v47 - *(void *)(v58 + 24 * v49);
          }
          v59.n128_u64[0] = v47;
          v59.n128_u64[1] = v53;
          unint64_t v60 = v51 - v47;
          pushDiffSegment((unint64_t *)&v61, &v59);
          unint64_t v47 = *v50;
        }
        else
        {
          unint64_t v47 = *v50;
        }
        v48 += *(_DWORD *)&v12[16 * v46++ + 8];
        if (v46 == v27) {
          goto LABEL_59;
        }
      }
LABEL_61:
      uint64_t v38 = "no overlapping segment found";
      __int16 v39 = 539;
      goto LABEL_62;
    }
LABEL_59:
    uint64_t v54 = v61;
    unint64_t v55 = reallocToFit(v62, 24 * v61);
    *((void *)&v61 + 1) = v54;
    unint64_t v62 = v55;
    free((void *)v44[2]);
    *(_OWORD *)unint64_t v44 = v61;
    v44[2] = (unint64_t)v62;
    unint64_t v62 = 0;
    long long v61 = 0uLL;
    uint64_t v42 = v57 + 1;
    if (v57 + 1 == v56)
    {
      uint64_t v40 = 0;
      goto LABEL_34;
    }
  }
LABEL_33:
  uint64_t v40 = 0xFFFFFFFFLL;
LABEL_34:
  free(v12);
  free(v62);
  return v40;
}

uint64_t mergeDiffSegmentEventCompareProc(uint64_t a1, uint64_t a2)
{
  if (*(void *)a1 < *(void *)a2) {
    return 0xFFFFFFFFLL;
  }
  if (*(void *)a2 >= *(void *)a1) {
    return (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8));
  }
  return 1;
}

uint64_t getComboControlsFromMergedDiffSegmentVectors(char *a1, uint64_t *a2, void *a3, uint64_t *a4)
{
  if (!a1)
  {
    uint64_t v16 = 0;
LABEL_39:
    uint64_t v39 = 0;
    goto LABEL_40;
  }
  size_t v7 = (size_t)a1;
  uint64_t v8 = *a2;
  uint64_t v9 = a1 + 2;
  uint64_t v10 = (char *)calloc((size_t)&v9[(void)v9 * *a2], 8uLL);
  if (v10)
  {
    unint64_t v11 = calloc(v7, 8uLL);
    if (v11)
    {
      if (v8)
      {
        uint64_t v12 = 0;
        uint64_t v15 = a2[2];
        unint64_t v14 = a2 + 2;
        uint64_t v13 = v15;
        uint64_t v16 = 1;
        while (1)
        {
          uint64_t v17 = (uint64_t *)&v10[8 * v16 * (void)v9];
          int v18 = (uint64_t *)&v10[8 * (v16 - 1) * (void)v9];
          uint64_t v19 = *(void *)(v13 + 24 * v12 + 16);
          if (*(void *)(v13 + 24 * v12 + 8) == -1)
          {
            if (v19 < 0) {
              uint64_t v19 = 0x8000000000000000 - v19;
            }
            if (!v18[1])
            {
              v18[1] = v19;
              goto LABEL_25;
            }
            v17[1] = v19;
          }
          else
          {
            uint64_t v20 = (uint64_t *)&v10[8 * (void)v9 * (v16 - 1) + 16];
            int v21 = 1;
            unint64_t v22 = v14;
            uint64_t v23 = v11;
            size_t v24 = v7;
            do
            {
              uint64_t v25 = *v22;
              v22 += 3;
              uint64_t v26 = *(void *)(v25 + 24 * v12 + 8);
              uint64_t v27 = v26 - *v23;
              if (v26 != *v23) {
                int v21 = 0;
              }
              *v23++ = v26 + v19;
              uint64_t v28 = 0x8000000000000000 - v27;
              if (v27 >= 0) {
                uint64_t v28 = v27;
              }
              *v20++ = v28;
              --v24;
            }
            while (v24);
            if (v21)
            {
              uint64_t v29 = v18[1];
              if (v29 < 0) {
                uint64_t v29 = 0x8000000000000000 - v29;
              }
              if (!v29)
              {
                unint64_t v31 = *v18;
                if (*v18 < 0) {
                  unint64_t v31 = 0x8000000000000000 - *v18;
                }
                BOOL v32 = __OFADD__(v31, v19);
                uint64_t v33 = v31 + v19;
                if (v33 < 0 != v32) {
                  uint64_t v33 = 0x8000000000000000 - v33;
                }
                *int v18 = v33;
                goto LABEL_25;
              }
            }
            uint64_t v30 = 0x8000000000000000 - v19;
            if (v19 >= 0) {
              uint64_t v30 = v19;
            }
            *uint64_t v17 = v30;
          }
          ++v16;
LABEL_25:
          if (++v12 == v8) {
            goto LABEL_38;
          }
        }
      }
      uint64_t v16 = 1;
LABEL_38:
      free(v11);
      a1 = (char *)reallocToFit(v10, 8 * (void)v9 * v16);
      goto LABEL_39;
    }
    int v34 = *__error();
    int v37 = "calloc ipos";
    __int16 v38 = 600;
  }
  else
  {
    int v34 = *__error();
    int v37 = "calloc controls";
    __int16 v38 = 596;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffControls.c", (uint64_t)"getComboControlsFromMergedDiffSegmentVectors", v38, 53, v34, v37, v35, v36, v41);
  free(v10);
  a1 = 0;
  uint64_t v16 = 0;
  uint64_t v39 = 0xFFFFFFFFLL;
LABEL_40:
  *a3 = a1;
  *a4 = v16;
  return v39;
}

uint64_t rawimg_force_in_place(void *a1, unint64_t *a2, void *a3, uint64_t a4, uint64_t a5, int a6)
{
  if (*(void *)(a4 + 2120) <= a3[265]) {
    uint64_t v12 = a3[265];
  }
  else {
    uint64_t v12 = *(void *)(a4 + 2120);
  }
  uint64_t v15 = AAFileStreamOpenWithPath(*(const char **)(a4 + 2048), 0, 0);
  if (!v15)
  {
    long long v99 = "AAFileStreamOpenWithPath";
    __int16 v100 = 234;
LABEL_121:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", v100, 141, 0, v99, v13, v14, v145);
    uint64_t v43 = 0;
    uint64_t v40 = 0;
    uint64_t v33 = 0;
    uint64_t v30 = 0;
    uint64_t v17 = 0;
LABEL_122:
    int v110 = 0;
    goto LABEL_123;
  }
  unint64_t v16 = (unint64_t)(a5 + 0x3FFF) >> 14;
  uint64_t v17 = (uint64_t *)calloc(1uLL, 0x68uLL);
  int v18 = calloc(1uLL, 0x28uLL);
  int v21 = v18;
  if ((v16 & 0x80000000) != 0)
  {
    long long v101 = "too little excess";
    __int16 v102 = 184;
LABEL_120:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"aaSimStreamOpen", v102, 141, 0, v101, v19, v20, v145);
    free(v17);
    SimStreamClose((uint64_t)v21, v103, v104, v105, v106, v107, v108, v109);
    long long v99 = "aaSimStreamOpen";
    __int16 v100 = 236;
    goto LABEL_121;
  }
  if (!v17 || !v18)
  {
    long long v101 = "aaCalloc";
    __int16 v102 = 185;
    goto LABEL_120;
  }
  *int v18 = v15;
  *((_DWORD *)v18 + 4) = (unint64_t)(v12 + 0x3FFF) >> 14;
  *((_DWORD *)v18 + 8) = v16;
  *((_DWORD *)v18 + 9) = a6;
  if (((v12 + 0x3FFF) & 0x200000000000) != 0)
  {
    *__error() = 12;
    v21[1] = 0;
    goto LABEL_119;
  }
  unint64_t v22 = calloc(((unint64_t)(v12 + 0x3FFF) >> 14), 5uLL);
  v21[1] = v22;
  if (!v22)
  {
LABEL_119:
    long long v101 = "aaCalloc";
    __int16 v102 = 195;
    goto LABEL_120;
  }
  AACustomByteStreamSetData((AAByteStream)v17, v21);
  AACustomByteStreamSetCloseProc((AAByteStream)v17, (AAByteStreamCloseProc)SimStreamClose);
  AACustomByteStreamSetPReadProc((AAByteStream)v17, (AAByteStreamPReadProc)SimStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v17, (AAByteStreamPWriteProc)SimStreamPWrite);
  v17[11] = (uint64_t)SimStreamSimulate;
  uint64_t v23 = *v17;
  size_t v24 = aaSegmentStreamOpen(v17, a3);
  uint64_t v30 = (AAByteStream_impl *)v24;
  if (!v24)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 241, 141, 0, "aaSegmentStreamOpen", v28, v29, v145);
    uint64_t v43 = 0;
    uint64_t v40 = 0;
    uint64_t v33 = 0;
    goto LABEL_122;
  }
  uint64_t v33 = aaForkInputStreamOpen(v24, (uint64_t)a3, 0, v25, v26, v27, v28, v29);
  if (!v33)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 243, 141, 0, "aaForkInputStreamOpen", v31, v32, v145);
    uint64_t v43 = 0;
    uint64_t v40 = 0;
    goto LABEL_122;
  }
  int v34 = aaSegmentStreamOpen(v17, (void *)a4);
  uint64_t v40 = (AAByteStream_impl *)v34;
  if (!v34)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 247, 141, 0, "aaSegmentStreamOpen", v38, v39, v145);
    uint64_t v43 = 0;
    goto LABEL_122;
  }
  uint64_t v169 = v23;
  uint64_t v43 = aaForkInputStreamOpen(v34, a4, 0, v35, v36, v37, v38, v39);
  if (!v43)
  {
    long long v97 = "aaForkOutputStreamOpen";
    __int16 v98 = 249;
LABEL_142:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", v98, 141, 0, v97, v41, v42, v145);
    goto LABEL_122;
  }
  uint64_t v154 = 0;
  int64x2_t v152 = vdupq_n_s64(0x8000000000000000);
  int v151 = 1;
  BOOL v171 = a1;
  uint64_t v168 = v40;
  int v153 = a6;
  unint64_t v170 = a2;
  while (2)
  {
    bzero(*(void **)(v169 + 8), 5 * *(int *)(v169 + 16));
    int v44 = *(_DWORD *)(v169 + 16);
    *(void *)(v169 + 24) = 0;
    *(_DWORD *)(v169 + 20) = v44;
    unint64_t v45 = *a2;
    if (*a2)
    {
      uint64_t v46 = 0;
      unint64_t v47 = 0;
      do
      {
        int v48 = (unint64_t *)(*a1 + 24 * v47);
        if ((*v48 & 0x8000000000000000) == 0) {
          unint64_t v49 = *v48;
        }
        else {
          unint64_t v49 = 0x8000000000000000 - *v48;
        }
        uint64_t v50 = v48[2];
        uint64_t v51 = 0x8000000000000000 - v50;
        if (v50 >= 0) {
          uint64_t v51 = v50;
        }
        if (v49)
        {
          uint64_t v161 = v51;
          unint64_t v164 = v47;
          for (unint64_t i = 0; i < v49; i += v53)
          {
            if (v49 - i >= 0x10000) {
              uint64_t v53 = 0x10000;
            }
            else {
              uint64_t v53 = v49 - i;
            }
            if (v53 != aaByteStreamSimulate(v33))
            {
              uint64_t v124 = "aaByteStreamSimulate";
              __int16 v125 = 270;
              goto LABEL_144;
            }
          }
          a1 = v171;
          unint64_t v45 = *v170;
          uint64_t v51 = v161;
          unint64_t v47 = v164;
        }
        v46 += v49 + v51;
        ++v47;
      }
      while (v47 < v45);
    }
    int v54 = 1;
    unint64_t v55 = v45;
    unsigned int v156 = v30;
    do
    {
      if (!v55) {
        goto LABEL_59;
      }
      unint64_t v56 = 0;
      unint64_t v57 = 0;
      uint64_t v58 = 0;
      int v165 = v54;
      do
      {
        __n128 v59 = (unint64_t *)(*v171 + 24 * v56);
        uint64_t v60 = v59[1];
        unint64_t v61 = 0x8000000000000000 - *v59;
        if ((*v59 & 0x8000000000000000) == 0) {
          unint64_t v61 = *v59;
        }
        if (v60 >= 0) {
          unint64_t v62 = v59[1];
        }
        else {
          unint64_t v62 = 0x8000000000000000 - v60;
        }
        uint64_t v63 = v59[2];
        if (v63 < 0) {
          uint64_t v63 = 0x8000000000000000 - v63;
        }
        if (v54 == 2)
        {
          v57 += v61;
          if (v57 < *(void *)(a4 + 2056)) {
            goto LABEL_57;
          }
        }
        else
        {
          uint64_t v157 = v63;
          unint64_t v159 = v62;
          unint64_t v162 = v56;
          if (v61)
          {
            unint64_t v64 = 0;
            while (1)
            {
              unint64_t v65 = v61;
              if (v61 - v64 >= 0x10000) {
                uint64_t v66 = 0x10000;
              }
              else {
                uint64_t v66 = v61 - v64;
              }
              if (v66 != aaByteStreamSimulate(v33))
              {
                __int16 v126 = 298;
                goto LABEL_148;
              }
              if (v66 != aaByteStreamSimulate(v43)) {
                break;
              }
              v58 += v66;
              v57 += v66;
              v64 += v66;
              unint64_t v61 = v65;
              if (v64 >= v65) {
                goto LABEL_52;
              }
            }
            __int16 v126 = 299;
LABEL_148:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", v126, 141, 0, "aaByteStreamSimulate", v41, v42, v145);
            int v110 = 0;
            uint64_t v40 = v168;
            uint64_t v30 = v156;
            goto LABEL_123;
          }
LABEL_52:
          v58 += v157;
          int v54 = v165;
          if (v165 == 1)
          {
            unint64_t v56 = v162;
            unint64_t v62 = v159;
            uint64_t v30 = v156;
            if (v57 >= *(void *)(a4 + 2056)) {
              goto LABEL_57;
            }
          }
          else
          {
            unint64_t v56 = v162;
            unint64_t v62 = v159;
            uint64_t v30 = v156;
          }
        }
        uint64_t v67 = aaByteStreamSimulate(v43);
        int v54 = v165;
        if (v62 != v67)
        {
          uint64_t v124 = "aaByteStreamSimulate";
          __int16 v125 = 310;
          goto LABEL_144;
        }
LABEL_57:
        v57 += v62;
        ++v56;
        unint64_t v45 = *v170;
      }
      while (v56 < *v170);
      unint64_t v55 = *v170;
LABEL_59:
      ++v54;
    }
    while (v54 != 3);
    int v68 = *(_DWORD *)(v169 + 28);
    if (v153 >= 3)
    {
      fprintf((FILE *)*MEMORY[0x263EF8348], "ForceInPlace %d: excess_pages=%d/%d, converted bytes=%llu, %zu controls\n", v151, v68, *(_DWORD *)(v169 + 32), v154, v45);
      int v68 = *(_DWORD *)(v169 + 28);
    }
    int v69 = *(_DWORD *)(v169 + 32);
    BOOL v70 = __OFSUB__(v68, v69);
    int v71 = v68 - v69;
    if (!((v71 < 0) ^ v70 | (v71 == 0)))
    {
      int v72 = v71 + 1;
      unint64_t v73 = (uint64_t)(v72 >> 1) << 14;
      if (v72 < 2)
      {
        int v74 = 0;
        a2 = v170;
        a1 = v171;
        uint64_t v75 = v154;
        goto LABEL_112;
      }
      uint64_t v149 = 0;
      unint64_t v146 = -1;
      unint64_t v76 = 1;
      a2 = v170;
      a1 = v171;
      uint64_t v75 = v154;
      int64x2_t v77 = v152;
      while (2)
      {
        unint64_t v78 = *(void *)(a4 + 2080);
        unint64_t v79 = *a2;
        if (*a2)
        {
          int v74 = 0;
          unint64_t v147 = v76 - 1;
          unint64_t v148 = v76;
          uint64_t v80 = 24 * v79;
          while (1)
          {
            uint64_t v81 = *a1 + v80;
            uint64_t v82 = (int8x16_t *)(v81 - 24);
            int64x2_t v83 = *(int64x2_t *)(v81 - 24);
            int64x2_t v84 = (int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(v83), (int8x16_t)vsubq_s64(v77, v83), (int8x16_t)v83);
            uint64_t v85 = *(void *)(v81 - 8);
            unint64_t v86 = 0x8000000000000000 - v85;
            if (v85 >= 0) {
              unint64_t v86 = *(void *)(v81 - 8);
            }
            v78 -= vaddvq_s64(v84);
            if (!v73) {
              goto LABEL_94;
            }
            unint64_t v87 = v84.i64[0];
            if (!v84.i64[0]) {
              goto LABEL_94;
            }
            if (v76 == 1) {
              break;
            }
            if (v76 != 2)
            {
              if (v76 != 3) {
                goto LABEL_94;
              }
              unint64_t v88 = *(void *)(a4 + 2056);
              goto LABEL_78;
            }
            if (v78 >= *(void *)(a4 + 2072))
            {
              if (v84.i64[0] > v73)
              {
                uint64_t v89 = v146;
                uint64_t v90 = v149;
                if (v146 > v84.i64[0]) {
                  uint64_t v90 = v81 - 24;
                }
                uint64_t v149 = v90;
                if (v146 >= v84.i64[0]) {
                  uint64_t v89 = v84.i64[0];
                }
                unint64_t v146 = v89;
                goto LABEL_94;
              }
              goto LABEL_89;
            }
LABEL_94:
            v80 -= 24;
            --v79;
            a1 = v171;
            if (!v79) {
              goto LABEL_97;
            }
          }
          if (v78 < *(void *)(a4 + 2056)) {
            goto LABEL_94;
          }
          unint64_t v88 = *(void *)(a4 + 2072);
LABEL_78:
          if (v78 < v88)
          {
            if (v84.i64[0] >= v73) {
              unint64_t v87 = v73;
            }
LABEL_89:
            if (v153 >= 4)
            {
              unint64_t v91 = v73;
              uint64_t v155 = v75;
              uint64_t v163 = v81;
              unint64_t v166 = v78;
              unint64_t v158 = v86;
              unint64_t v160 = v87;
              int64x2_t v150 = v84;
              fprintf((FILE *)*MEMORY[0x263EF8348], "Dropping %llu bytes at %llu, needed=%llu bytes, type %s\n", v87, v78, v73, (&rawimg_force_in_place_pass_name)[v147]);
              int64x2_t v84 = v150;
              unint64_t v86 = v158;
              unint64_t v87 = v160;
              uint64_t v81 = v163;
              unint64_t v78 = v166;
              unint64_t v76 = v148;
              uint64_t v75 = v155;
              unint64_t v73 = v91;
              int64x2_t v77 = v152;
            }
            v83.i64[0] = v87;
            v92.i64[0] = vsubq_s64(v84, v83).u64[0];
            v92.i64[1] = vaddq_s64(v84, vdupq_n_s64(v87)).i64[1];
            int8x16_t *v82 = vbslq_s8((int8x16_t)vcltzq_s64(v92), (int8x16_t)vsubq_s64(v77, v92), (int8x16_t)v92);
            unint64_t v93 = v87 + v86;
            if ((uint64_t)(v87 + v86) < 0) {
              unint64_t v93 = 0x8000000000000000 - (v87 + v86);
            }
            *(void *)(v81 - 8) = v93;
            v75 += v87;
            v73 -= v87;
            int v74 = 1;
            goto LABEL_94;
          }
          goto LABEL_94;
        }
        int v74 = 0;
LABEL_97:
        if (v78)
        {
          uint64_t v124 = "control sequence broken";
          __int16 v125 = 411;
          goto LABEL_144;
        }
        a2 = v170;
        if (v76 != 3 || v74 || !v73 || !v149)
        {
          if (v76 > 2) {
            goto LABEL_112;
          }
          if (v74) {
            goto LABEL_112;
          }
          ++v76;
          if (!v73) {
            goto LABEL_112;
          }
          continue;
        }
        break;
      }
      uint64_t v94 = v75;
      if (*(uint64_t *)v149 >= 0) {
        unint64_t v95 = *(void *)v149;
      }
      else {
        unint64_t v95 = 0x8000000000000000 - *(void *)v149;
      }
      int64x2_t v167 = *(int64x2_t *)(v149 + 8);
      if (v153 >= 4) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Dropping copy fork with %llu bytes, needed=%llu bytesx\n", v95, v73);
      }
      unint64_t v73 = 0;
      *(void *)uint64_t v149 = 0;
      int64x2_t v96 = vaddq_s64((int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(v167), (int8x16_t)vsubq_s64(v152, v167), (int8x16_t)v167), vdupq_n_s64(v95));
      *(int8x16_t *)(v149 + 8) = vbslq_s8((int8x16_t)vcltzq_s64(v96), (int8x16_t)vsubq_s64(v152, v96), (int8x16_t)v96);
      uint64_t v75 = v95 + v94;
      int v74 = 1;
      a2 = v170;
      a1 = v171;
LABEL_112:
      uint64_t v154 = v75;
      ++v151;
      uint64_t v40 = v168;
      if (!v74 && v73)
      {
        long long v97 = "no possible conversions";
        __int16 v98 = 441;
        goto LABEL_142;
      }
      continue;
    }
    break;
  }
  unsigned int v127 = (void *)*v171;
  unint64_t v128 = *v170;
  if (!*v170) {
    goto LABEL_155;
  }
  if (v128 != 1)
  {
    uint64_t v129 = 0;
    uint64_t v130 = v127[1] + *v127;
    int v131 = v127 + 3;
    unint64_t v132 = 1;
    while (1)
    {
      uint64_t v133 = *v131;
      uint64_t v134 = v131[1];
      if (v130 != *(void *)(a4 + 2072))
      {
        int8x8_t v135 = &v127[3 * v129];
        uint64_t v138 = v135[1];
        uint64_t v137 = v135 + 1;
        uint64_t v136 = v138;
        if (!v133)
        {
          uint64_t v141 = v127[3 * v129 + 2];
LABEL_167:
          v127[3 * v129] += v133;
          *uint64_t v137 = v136 + v134;
          uint64_t v142 = 0x8000000000000000 - v141;
          if (v141 >= 0) {
            uint64_t v142 = v141;
          }
          uint64_t v143 = v131[2];
          if (v143 < 0) {
            uint64_t v143 = 0x8000000000000000 - v143;
          }
          BOOL v70 = __OFADD__(v143, v142);
          uint64_t v144 = v143 + v142;
          if (v144 < 0 != v70) {
            uint64_t v144 = 0x8000000000000000 - v144;
          }
          v127[3 * v129 + 2] = v144;
          goto LABEL_174;
        }
        if (!v136)
        {
          uint64_t v136 = v127[3 * v129 + 2];
          if (!v136)
          {
            uint64_t v141 = 0;
            goto LABEL_167;
          }
        }
      }
      ++v129;
      long long v139 = *(_OWORD *)v131;
      size_t v140 = &v127[3 * v129];
      v140[2] = v131[2];
      *(_OWORD *)size_t v140 = v139;
LABEL_174:
      v130 += v134 + v133;
      ++v132;
      v131 += 3;
      if (v132 >= *v170) {
        goto LABEL_154;
      }
    }
  }
  uint64_t v129 = 0;
LABEL_154:
  unint64_t v128 = v129 + 1;
  unint64_t *v170 = v128;
LABEL_155:
  *BOOL v171 = v127;
  if (v127)
  {
    if (v153 >= 2) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "ForceInPlace: %zu controls. Dropped %llu bytes to stay within budget.\n", v128, v154);
    }
    int v110 = 1;
  }
  else
  {
    uint64_t v124 = "merge_controls";
    __int16 v125 = 447;
LABEL_144:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", v125, 141, 0, v124, v41, v42, v145);
    int v110 = 0;
  }
  uint64_t v40 = v168;
LABEL_123:
  if (AAByteStreamClose((AAByteStream)v33) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 458, 141, 0, "AAByteStreamClose", v111, v112, v145);
    int v110 = 0;
  }
  if (AAByteStreamClose(v30) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 459, 141, 0, "AAByteStreamClose", v113, v114, v145);
    int v110 = 0;
  }
  if (AAByteStreamClose((AAByteStream)v43) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 460, 141, 0, "AAByteStreamClose", v115, v116, v145);
    int v110 = 0;
  }
  if (AAByteStreamClose(v40) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 461, 141, 0, "AAByteStreamClose", v117, v118, v145);
    int v110 = 0;
  }
  if (AAByteStreamClose((AAByteStream)v17) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 462, 141, 0, "AAByteStreamClose", v119, v120, v145);
    int v110 = 0;
  }
  if (AAByteStreamClose(v15) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 463, 141, 0, "AAByteStreamClose", v121, v122, v145);
    int v110 = 0;
  }
  if (v110) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t SimStreamClose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0;
  }
  int v9 = *(_DWORD *)(a1 + 16);
  if (v9 < 1) {
    goto LABEL_8;
  }
  int v10 = 0;
  unint64_t v11 = *(int **)(a1 + 8);
  uint64_t v12 = *(unsigned int *)(a1 + 16);
  do
  {
    int v13 = *v11;
    unint64_t v11 = (int *)((char *)v11 + 5);
    v10 += v13;
    --v12;
  }
  while (v12);
  if (v10)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"SimStreamClose", 148, 141, 0, "%i dangling reads", a7, a8, v10);
    int v9 = *(_DWORD *)(a1 + 16);
    uint64_t v14 = 0xFFFFFFFFLL;
  }
  else
  {
LABEL_8:
    uint64_t v14 = 0;
  }
  int v15 = *(_DWORD *)(a1 + 24);
  if (*(_DWORD *)(a1 + 28) + v9 != *(_DWORD *)(a1 + 20) + v15)
  {
    pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"SimStreamClose", 152, 141, "file + excess != written + free", a6, a7, a8, v17);
    int v9 = *(_DWORD *)(a1 + 16);
    int v15 = *(_DWORD *)(a1 + 24);
  }
  if (v9 < v15) {
    pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"SimStreamClose", 154, 141, "file < written", a6, a7, a8, v17);
  }
  if (*(int *)(a1 + 36) >= 2) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "SimStream: pages: %i file, %i written, %i free, %i excess (%iK)\n", *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 28), 16 * *(_DWORD *)(a1 + 28));
  }
  free(*(void **)(a1 + 8));
  free((void *)a1);
  return v14;
}

ssize_t SimStreamPRead(AAByteStream *a1, void *a2, size_t a3, off_t a4)
{
  return AAByteStreamPRead(*a1, a2, a3, a4);
}

ssize_t SimStreamPWrite(AAByteStream *a1, const void *a2, size_t a3, off_t a4)
{
  return AAByteStreamPWrite(*a1, a2, a3, a4);
}

uint64_t SimStreamSimulate(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, int64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4 < 1) {
    return a4;
  }
  if (a2 > 2)
  {
    uint64_t v20 = "not implemented";
    __int16 v21 = 87;
    goto LABEL_20;
  }
  int64_t v9 = a5 + a4;
  uint64_t v10 = *(void *)(a1 + 8);
  while (1)
  {
    unint64_t v11 = (int *)(v10 + 5 * (a5 >> 14));
    if (a2) {
      break;
    }
    if (!(*v11)++)
    {
      int v14 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 20) = v14 - 1;
      if (!v14)
      {
        uint64_t v20 = "no free pages";
        __int16 v21 = 94;
        goto LABEL_20;
      }
    }
LABEL_17:
    a5 = (a5 & 0xFFFFFFFFFFFFC000) + 0x4000;
    if (a5 >= v9) {
      return a4;
    }
  }
  if (a2 != 1)
  {
    uint64_t v15 = v10 + 5 * (a5 >> 14);
    int v17 = *(unsigned __int8 *)(v15 + 4);
    unint64_t v16 = (unsigned char *)(v15 + 4);
    if (!v17)
    {
      *unint64_t v16 = 1;
      int v18 = *(_DWORD *)(a1 + 20);
      if (v18) {
        *(_DWORD *)(a1 + 20) = v18 - 1;
      }
      else {
        ++*(_DWORD *)(a1 + 28);
      }
      ++*(_DWORD *)(a1 + 24);
    }
    goto LABEL_17;
  }
  if (*v11 > 0)
  {
    int v12 = *v11 - 1;
    *unint64_t v11 = v12;
    if (!v12) {
      ++*(_DWORD *)(a1 + 20);
    }
    goto LABEL_17;
  }
  uint64_t v20 = "data not locked";
  __int16 v21 = 99;
LABEL_20:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"SimStreamSimulate", v21, 141, 0, v20, a7, a8, v8);
  return -1;
}

uint64_t compare_extents_by_position(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 1;
  }
}

void rawimg_destroy(uint64_t *a1)
{
  if (a1)
  {
    if (a1[270])
    {
      unint64_t v2 = 0;
      uint64_t v3 = 384;
      do
      {
        free(*(void **)(a1[268] + v3));
        ++v2;
        v3 += 440;
      }
      while (v2 < a1[270]);
    }
    pc_array_free(a1[267]);
    pc_array_free(a1[268]);
    free(a1);
  }
}

uint64_t rawimg_show(uint64_t result, int a2, int a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (a3)
  {
    unint64_t v5 = (void *)result;
    char v17 = 0;
    memset(v16, 0, sizeof(v16));
    uint64_t v6 = *(void *)(result + 2160);
    if (v6)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 0;
      int64_t v9 = (void *)(*(void *)(result + 2144) + 400);
      do
      {
        v7 += *v9;
        v8 += *(v9 - 1);
        v9 += 55;
        --v6;
      }
      while (v6);
    }
    else
    {
      uint64_t v8 = 0;
      uint64_t v7 = 0;
    }
    __n128 result = serializeHexString((uint64_t)v16, 0x20u, (unsigned __int8 *)(result + 2088));
    if (a3 > 1)
    {
      uint64_t v10 = (FILE **)MEMORY[0x263EF8348];
      unint64_t v11 = "Output";
      if (!a2) {
        unint64_t v11 = "Input";
      }
      int v12 = (const char *)&unk_2106C9523;
      if (v5[256]) {
        int v12 = (const char *)v5[256];
      }
      __n128 result = fprintf((FILE *)*MEMORY[0x263EF8348], "%s variant <%s> | %llu bytes | %zu extents | %zu forks (%llu/%llu) | digest=%s\n", v11, v12, v5[265], v5[269], v5[270], v7, v8, (const char *)v16);
      if (a3 != 2)
      {
        __n128 result = fprintf(*v10, " fork | %64s | algo |       size | compressed | V | C\n", "digest");
        if (v5[270])
        {
          uint64_t v13 = 0;
          unint64_t v14 = 0;
          do
          {
            uint64_t v15 = v5[268] + v13;
            serializeHexString((uint64_t)v16, 0x20u, (unsigned __int8 *)v15);
            __n128 result = fprintf(*v10, "%5zu | %s | %4d | %10llu | %10llu | %d | %d\n", ++v14, (const char *)v16, *(unsigned __int8 *)(v15 + 432), *(void *)(v15 + 392), *(void *)(v15 + 400), *(_DWORD *)(v15 + 408) & 1, (*(_DWORD *)(v15 + 408) >> 1) & 1);
            v13 += 440;
          }
          while (v14 < v5[270]);
        }
      }
    }
  }
  return result;
}

uint64_t *rawimg_create_with_path(const char *a1)
{
  unint64_t v2 = (uint64_t *)calloc(1uLL, 0x878uLL);
  memset(&v23, 0, sizeof(v23));
  if (!v2)
  {
    int v20 = *__error();
    uint64_t v18 = "aaCalloc";
    __int16 v19 = 468;
    goto LABEL_17;
  }
  if (lstat(a1, &v23) || (v23.st_mode & 0xF000) != 0x8000)
  {
    uint64_t v18 = "lstat";
    __int16 v19 = 469;
LABEL_15:
    int v20 = 0;
LABEL_17:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_create_with_path", v19, 138, v20, v18, v3, v4, v23.st_dev);
    rawimg_destroy(v2);
    return 0;
  }
  v2[256] = (uint64_t)a1;
  v2[265] = v23.st_size;
  v2[267] = (uint64_t)pc_array_init(16);
  unint64_t v5 = pc_array_init(440);
  v2[268] = (uint64_t)v5;
  if (!v2[267] || !v5)
  {
    uint64_t v18 = "pc_array_init";
    __int16 v19 = 476;
    goto LABEL_15;
  }
  if ((apfs_scan_diskimage(a1, (uint64_t (*)(long long *, uint64_t))rawimg_add_fork, (uint64_t)rawimg_add_volume, (uint64_t)v2) & 0x80000000) != 0)
  {
    uint64_t v18 = "rawimg_query_forks";
    __int16 v19 = 479;
    goto LABEL_15;
  }
  uint64_t v6 = (void *)v2[268];
  uint64_t v7 = *(v6 - 8);
  v2[270] = v7;
  v2[269] = *(void *)(v2[267] - 64);
  if (v7)
  {
    pc_array_sort(v6, (int (__cdecl *)(const void *, const void *))compare_forks_by_extent);
    if ((pc_array_aggregate((char *)v2[268], (unsigned int (*)(char *, char *))compare_forks_by_extent, (uint64_t (*)(char *, char *))aggregate_identical_forks) & 0x80000000) != 0)
    {
      unint64_t v22 = "rawimg_remove_fork_duplicates";
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_remove_fork_duplicates", 454, 138, 0, "bad duplicate", v8, v9, v23.st_dev);
      __int16 v19 = 484;
      goto LABEL_23;
    }
    uint64_t v6 = (void *)v2[268];
    v2[270] = *(v6 - 8);
  }
  v2[268] = (uint64_t)pc_array_compact((uint64_t)v6);
  uint64_t v10 = pc_array_compact(v2[267]);
  v2[267] = (uint64_t)v10;
  if (!v10 || !v2[268])
  {
    unint64_t v22 = "rawimg_compact";
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_compact", 77, 138, 0, "pc_array_compress", v16, v17, v23.st_dev);
    __int16 v19 = 485;
LABEL_23:
    int v20 = 0;
    uint64_t v18 = v22;
    goto LABEL_17;
  }
  if ((rawimg_verify(v2, v11, v12, v13, v14, v15, v16, v17) & 0x80000000) != 0)
  {
    uint64_t v18 = "rawimg_verify";
    __int16 v19 = 486;
    goto LABEL_15;
  }
  qsort_r((void *)v2[268], v2[270], 0x1B8uLL, v2, (int (__cdecl *)(void *, const void *, const void *))compare_forks_by_position);
  return v2;
}

uint64_t rawimg_add_fork(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v27 = 0;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v24 = 0u;
  memset(__src, 0, sizeof(__src));
  uint64_t v8 = *(unsigned int *)(a1 + 20);
  if (v8 && *(void *)a1)
  {
    uint64_t v11 = *(void *)(a1 + 8);
    *((void *)&v24 + 1) = *(void *)a1;
    *(void *)&long long v25 = v11;
    *(void *)&long long v26 = *(void *)(*(void *)(a2 + 2136) - 64);
    *((void *)&v26 + 1) = v8;
    LOBYTE(v27) = *(_DWORD *)(a1 + 16);
    uint64_t v12 = pc_array_append(*(void *)(a2 + 2144), __src, a3, a4, a5, a6, a7, a8);
    *(void *)(a2 + 2144) = v12;
    if (v12)
    {
      if (*(int *)(a1 + 20) < 1) {
        return 0;
      }
      uint64_t v17 = 0;
      uint64_t v18 = *(void **)(a2 + 2136);
      while (1)
      {
        long long v22 = 0uLL;
        long long v22 = *(_OWORD *)(*(void *)(a1 + 24) + 16 * v17);
        uint64_t v18 = pc_array_append((uint64_t)v18, &v22, v13, v14, v15, v16, a7, a8);
        *(void *)(a2 + 2136) = v18;
        if (!v18) {
          break;
        }
        if (++v17 >= *(int *)(a1 + 20)) {
          return 0;
        }
      }
      int v20 = "pc_array_append";
      __int16 v21 = 440;
    }
    else
    {
      int v20 = "pc_array_append";
      __int16 v21 = 427;
    }
  }
  else
  {
    int v20 = "bad fork";
    __int16 v21 = 416;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_add_fork", v21, 138, 0, v20, a7, a8, v22);
  return 0xFFFFFFFFLL;
}

uint64_t rawimg_add_volume()
{
  return 0;
}

uint64_t rawimg_verify(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[270];
  uint64_t v9 = a1[269];
  if (!v8 || !v9)
  {
    if (!(v8 + v9)) {
      return 0;
    }
    long long v26 = "bad variant";
    __int16 v27 = 184;
LABEL_22:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_verify", v27, 138, 0, v26, a7, a8, v61);
    uint64_t v28 = 0;
    uint64_t v17 = 0;
    goto LABEL_23;
  }
  uint64_t v11 = a1[267];
  uint64_t v12 = (void *)(v11 + 8);
  do
  {
    uint64_t v13 = *(v12 - 1);
    if ((unint64_t)(*v12 + v13) > a1[265])
    {
      long long v26 = "bad extent";
      __int16 v27 = 195;
      goto LABEL_22;
    }
    if ((v13 & 0xFFF) != 0)
    {
      long long v26 = "bad extent pos";
      __int16 v27 = 196;
      goto LABEL_22;
    }
    if ((*v12 & 0xFFFLL) != 0)
    {
      long long v26 = "bad extent size";
      __int16 v27 = 197;
      goto LABEL_22;
    }
    v12 += 2;
    --v9;
  }
  while (v9);
  uint64_t v14 = pc_array_indirect_sort(v11, compare_extents_by_position);
  uint64_t v17 = v14;
  if (!v14)
  {
    stat v23 = "pc_array_indirect_sort";
    __int16 v24 = 202;
    goto LABEL_27;
  }
  uint64_t v18 = 0;
  unint64_t v19 = a1[269];
  if (v19 <= 1) {
    uint64_t v20 = 1;
  }
  else {
    uint64_t v20 = a1[269];
  }
  uint64_t v21 = v20 - 1;
  while (v21 != v18)
  {
    long long v22 = (void **)&v14[v18++];
    if ((*v22)[1] + **v22 > *v22[1])
    {
      stat v23 = "extents overlapping";
      __int16 v24 = 205;
      goto LABEL_27;
    }
  }
  uint64_t v30 = a1[270];
  uint64_t v31 = a1[268];
  if (!v30)
  {
LABEL_42:
    uint64_t v28 = pc_array_indirect_sort(v31, compare_forks_by_extent);
    if (v28)
    {
      unint64_t v45 = a1[270];
      if (v45 <= 1) {
        uint64_t v46 = 1;
      }
      else {
        uint64_t v46 = a1[270];
      }
      uint64_t v47 = 856;
      while (--v46)
      {
        int v48 = (void *)(a1[268] + v47);
        v47 += 440;
        if (*(v48 - 55) == *v48)
        {
          unint64_t v49 = "duplicate fork";
          __int16 v50 = 239;
          goto LABEL_69;
        }
      }
      if (!v45)
      {
LABEL_59:
        uint64_t v25 = 0;
        goto LABEL_24;
      }
      uint64_t v51 = 0;
      uint64_t v52 = a1[268];
      while (1)
      {
        uint64_t v53 = *(void *)(v52 + 440 * v51 + 56);
        if (v53) {
          break;
        }
LABEL_58:
        if (++v51 == v45) {
          goto LABEL_59;
        }
      }
      unint64_t v54 = 0;
      uint64_t v55 = v52 + 440 * v51;
      uint64_t v56 = *(void *)(v55 + 384);
      unint64_t v57 = (unint64_t *)(v55 + 400);
      uint64_t v58 = (unsigned int *)(v56 + 8);
      while (1)
      {
        unint64_t v59 = *((void *)v58 - 1);
        if (v59 < v54)
        {
          unint64_t v49 = "bad chunk order";
          __int16 v50 = 256;
          goto LABEL_69;
        }
        unint64_t v54 = v59 + *v58;
        if (v54 > *v57) {
          break;
        }
        v58 += 3;
        if (!--v53) {
          goto LABEL_58;
        }
      }
      unint64_t v49 = "chunk out of bounds";
      __int16 v50 = 257;
    }
    else
    {
      unint64_t v49 = "pc_array_indirect_sort";
      __int16 v50 = 236;
    }
LABEL_69:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_verify", v50, 138, 0, v49, v43, v44, v61);
    goto LABEL_23;
  }
  uint64_t v32 = 0;
  while (2)
  {
    uint64_t v33 = v31 + 440 * v32;
    uint64_t v35 = *(void *)(v33 + 416);
    uint64_t v34 = *(void *)(v33 + 424);
    if (v34 + v35 > v19)
    {
      stat v23 = "bad fork";
      __int16 v24 = 216;
      goto LABEL_27;
    }
    if (!v34)
    {
      stat v23 = "no fork extents";
      __int16 v24 = 219;
      goto LABEL_27;
    }
    if (!*(void *)(v31 + 440 * v32 + 392))
    {
      stat v23 = "bad fork size";
      __int16 v24 = 222;
      goto LABEL_27;
    }
    uint64_t v36 = *(unsigned __int8 *)(v31 + 440 * v32 + 432);
    if (!*(unsigned char *)(v31 + 440 * v32 + 432))
    {
      __int16 v60 = 155;
      goto LABEL_66;
    }
    uint64_t v37 = &a1[*(unsigned __int8 *)(v31 + 440 * v32 + 432)];
    if (*v37)
    {
LABEL_38:
      unint64_t v40 = 0;
      uint64_t v41 = (uint64_t *)(a1[267] + 16 * v35 + 8);
      do
      {
        uint64_t v42 = *v41;
        v41 += 2;
        v40 += v42;
        --v34;
      }
      while (v34);
      if (v40 < *(void *)(v31 + 440 * v32 + 400))
      {
        stat v23 = "bad fork size";
        __int16 v24 = 231;
        goto LABEL_27;
      }
      if (++v32 == v30) {
        goto LABEL_42;
      }
      continue;
    }
    break;
  }
  HIDWORD(v39) = *(unsigned __int8 *)(v31 + 440 * v32 + 432);
  LODWORD(v39) = v36 - 4;
  unsigned int v38 = v39 >> 1;
  if (v38 < 6 && ((0x35u >> v38) & 1) != 0)
  {
    *uint64_t v37 = dword_2106D4590[v38];
    BYTE4(a1[v36]) = 0xFFFFFF06FFFFuLL >> (8 * v38);
    goto LABEL_38;
  }
  __int16 v60 = 167;
LABEL_66:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_init_algorithm", v60, 138, 0, "bad algo", v15, v16, v61);
  __int16 v24 = 225;
  stat v23 = "rawimg_init_algorithm";
LABEL_27:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_verify", v24, 138, 0, v23, v15, v16, v61);
  uint64_t v28 = 0;
LABEL_23:
  uint64_t v25 = 0xFFFFFFFFLL;
LABEL_24:
  free(v17);
  free(v28);
  return v25;
}

uint64_t rawimg_get_digests(uint64_t a1, signed int a2, int a3, int a4)
{
  memset(&c, 0, sizeof(c));
  uint64_t v8 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(a1 + 2048), 0, 0);
  uint64_t v11 = (AAByteStream_impl *)v8;
  if (!v8)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 570, 138, 0, "AAFileStreamOpenWithPath", v9, v10, v150);
LABEL_78:
    unint64_t v79 = 0;
    uint64_t v82 = 0;
    uint64_t v80 = 0;
    unint64_t v93 = 0;
    unint64_t v76 = 0;
    uint64_t v20 = 0;
LABEL_95:
    int v113 = 0;
    goto LABEL_96;
  }
  if (a4 && (io_set_nocache(v8) & 0x80000000) != 0) {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 571, 138, "io_set_nocache %s", v12, v13, v14, *(void *)(a1 + 2048));
  }
  if (AAByteStreamSeek(v11, 0, 2) != *(void *)(a1 + 2120))
  {
    if (!a3) {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 575, 138, "image size mismatch", v15, v16, v17, v150);
    }
    goto LABEL_78;
  }
  uint64_t v20 = aaSegmentStreamOpen(v11, (void *)a1);
  if (!v20)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 581, 138, 0, "aaSegmentStreamOpen", v18, v19, v150);
LABEL_94:
    unint64_t v79 = 0;
    uint64_t v82 = 0;
    uint64_t v80 = 0;
    unint64_t v93 = 0;
    unint64_t v76 = 0;
    goto LABEL_95;
  }
  rawimg_free_chunks((void *)a1);
  if (*(void *)(a1 + 2160))
  {
    unint64_t v26 = 0;
    signed int v160 = a2;
    while (1)
    {
      uint64_t v27 = *(void *)(a1 + 2144);
      uint64_t v28 = v27 + 440 * v26;
      unint64_t v29 = *(void *)(v28 + 392) + 0xFFFFLL;
      *(void *)(v28 + 56) = v29 >> 16;
      uint64_t v30 = (uint64_t *)(v28 + 56);
      if (v29 >= 0x2AAAAAAAB0000)
      {
        *__error() = 12;
        *(void *)(v27 + 440 * v26 + 384) = 0;
LABEL_102:
        uint64_t v117 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", 307, 138, *v117, "aaCalloc", v118, v119, v150);
        uint64_t v55 = 0;
        goto LABEL_92;
      }
      uint64_t v31 = calloc(v29 >> 16, 0xCuLL);
      uint64_t v34 = v27 + 440 * v26;
      *(void *)(v34 + 384) = v31;
      if (!v31) {
        goto LABEL_102;
      }
      uint64_t v35 = (void **)(v34 + 384);
      uint64_t v36 = *v30;
      uint64_t v164 = v27;
      if (*(unsigned char *)(v27 + 440 * v26 + 432) == 4)
      {
        int v156 = a3;
        unint64_t v158 = v11;
        unint64_t v162 = v26;
        uint64_t v37 = (void *)(v27 + 440 * v26);
        uint64_t v38 = v37[5];
        int64x2_t v152 = v35;
        uint64_t v154 = v37[50];
        v37[51] |= 4uLL;
        if (v20[4])
        {
          uint64_t v39 = 0;
          size_t v40 = 8 * v36;
          uint64_t v151 = 8 * v36 + 264;
          uint64_t v41 = v38 + 264;
          uint64_t v42 = v27 + 440 * v26 + 64;
          uint64_t v43 = v38;
          uint64_t v44 = 264;
          while (1)
          {
            uint64_t v45 = ((uint64_t (*)(uint64_t *, uint64_t, uint64_t, uint64_t))v20[4])(*v20, v42, v44, v43);
            if (v45 < 0) {
              break;
            }
            if (v45)
            {
              v42 += v45;
              v39 += v45;
              v43 += v45;
              v44 -= v45;
              if (v44) {
                continue;
              }
            }
            if (v39 != 264) {
              break;
            }
            if (v20[4])
            {
              uint64_t v46 = 0;
              uint64_t v47 = v164 + 440 * v162 + 328;
              uint64_t v48 = v38 + v154 - 50;
              uint64_t v49 = 50;
              while (1)
              {
                uint64_t v50 = ((uint64_t (*)(uint64_t *, uint64_t, uint64_t, uint64_t))v20[4])(*v20, v47, v49, v48);
                if (v50 < 0) {
                  break;
                }
                if (v50)
                {
                  v47 += v50;
                  v46 += v50;
                  v48 += v50;
                  v49 -= v50;
                  if (v49) {
                    continue;
                  }
                }
                if (v46 != 50) {
                  break;
                }
                if (v40 >= 0x2000000001)
                {
                  uint64_t v55 = 0;
                  *__error() = 12;
                  goto LABEL_91;
                }
                uint64_t v51 = (int *)malloc(v40);
                uint64_t v55 = v51;
                if (!v51) {
                  goto LABEL_91;
                }
                if (!v20[4]) {
                  goto LABEL_111;
                }
                if (v40)
                {
                  uint64_t v56 = 0;
                  unint64_t v57 = (char *)v51;
                  size_t v58 = v40;
                  while (1)
                  {
                    uint64_t v59 = ((uint64_t (*)(uint64_t *, char *, size_t, uint64_t))v20[4])(*v20, v57, v58, v41);
                    if (v59 < 0) {
                      break;
                    }
                    if (v59)
                    {
                      v57 += v59;
                      v56 += v59;
                      v41 += v59;
                      v58 -= v59;
                      if (v58) {
                        continue;
                      }
                    }
                    goto LABEL_42;
                  }
                  uint64_t v56 = v59;
LABEL_42:
                  if (v40 != v56)
                  {
LABEL_111:
                    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", 333, 138, 0, "fork chunks", v53, v54, v150);
                    goto LABEL_91;
                  }
                }
                uint64_t v61 = *v30;
                unint64_t v62 = *v152;
                if (!*v30)
                {
                  uint64_t v63 = 50;
                  size_t v60 = v151;
                  size_t v67 = v151;
                  uint64_t v11 = v158;
                  a3 = v156;
                  unint64_t v26 = v162;
                  goto LABEL_53;
                }
                int v68 = v62 + 1;
                int v69 = v55 + 1;
                uint64_t v70 = *v30;
                uint64_t v11 = v158;
                unint64_t v26 = v162;
                size_t v60 = v151;
                do
                {
                  *((void *)v68 - 1) = (*(v69 - 1) + 260);
                  int v71 = *v69;
                  v69 += 2;
                  _DWORD *v68 = v71;
                  v68 += 3;
                  --v70;
                }
                while (v70);
                uint64_t v63 = 50;
                a3 = v156;
                goto LABEL_47;
              }
            }
            uint64_t v105 = "fork footer";
            __int16 v106 = 328;
            goto LABEL_90;
          }
        }
        uint64_t v105 = "fork header";
        __int16 v106 = 325;
LABEL_90:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", v106, 138, 0, v105, v32, v33, v150);
        uint64_t v55 = 0;
LABEL_91:
        uint64_t v11 = v158;
        a3 = v156;
        goto LABEL_92;
      }
      size_t v60 = 4 * v36 + 4;
      if (v60 >= 0x2000000001)
      {
        uint64_t v55 = 0;
        *__error() = 12;
        goto LABEL_92;
      }
      uint64_t v55 = (int *)malloc(v60);
      if (!v55) {
        goto LABEL_92;
      }
      if (v60 != AAByteStreamPRead((AAByteStream)v20, v55, v60, *(void *)(v164 + 440 * v26 + 40)))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", 351, 138, 0, "fork chunks", v53, v54, v150);
        goto LABEL_92;
      }
      uint64_t v61 = *v30;
      unint64_t v62 = *v35;
      uint64_t v63 = 0;
      if (*v30)
      {
        unint64_t v64 = v62 + 1;
        do
        {
          unint64_t v65 = (unsigned int *)&v55[v63];
          uint64_t v66 = *v65;
          *((void *)v64 - 1) = v66;
          ++v63;
          *unint64_t v64 = v65[1] - v66;
          v64 += 3;
        }
        while (v61 != v63);
        uint64_t v63 = 0;
LABEL_47:
        int v72 = (unsigned int *)(v62 + 1);
        size_t v67 = v60;
        while (1)
        {
          size_t v73 = *((void *)v72 - 1);
          if (v73 < v67) {
            break;
          }
          size_t v67 = v73 + *v72;
          if (v67 > *(void *)(v164 + 440 * v26 + 400)) {
            break;
          }
          v72 += 3;
          if (!--v61) {
            goto LABEL_53;
          }
        }
        if (!a3)
        {
          uint64_t v103 = "bad chunk";
          __int16 v104 = 372;
LABEL_82:
          pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", v104, 138, v103, v52, v53, v54, v150);
          goto LABEL_92;
        }
        goto LABEL_92;
      }
      size_t v67 = v60;
LABEL_53:
      if (*v62 != v60 || v67 + v63 != *(void *)(v164 + 440 * v26 + 400)) {
        break;
      }
      free(v55);
      ++v26;
      a2 = v160;
      if (v26 >= *(void *)(a1 + 2160)) {
        goto LABEL_56;
      }
    }
    if (!a3)
    {
      uint64_t v103 = "bad index";
      __int16 v104 = 381;
      goto LABEL_82;
    }
LABEL_92:
    free(v55);
    rawimg_free_chunks((void *)a1);
    if (!a3) {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 587, 138, "bad chunk info", v110, v111, v112, v150);
    }
    goto LABEL_94;
  }
LABEL_56:
  *(void *)(a1 + 2128) |= 8uLL;
  unint64_t v76 = aaForkInputStreamOpen(v20, a1, 1, v21, v22, v23, v24, v25);
  if (!v76)
  {
    uint64_t v107 = "aaForkInputStreamOpen";
    __int16 v108 = 593;
    int v109 = 0;
LABEL_87:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", v108, 138, v109, v107, v74, v75, v150);
    unint64_t v79 = 0;
    uint64_t v82 = 0;
    uint64_t v80 = 0;
LABEL_88:
    unint64_t v93 = 0;
    goto LABEL_95;
  }
  unint64_t v77 = *(void *)(a1 + 2160) + ((unint64_t)(*(void *)(a1 + 2080) + 0x7FFFFFLL) >> 23);
  if (!is_mul_ok(v77, 0x38uLL) || 56 * v77 > 0x2000000000)
  {
    *__error() = 12;
    goto LABEL_86;
  }
  unint64_t v78 = calloc(*(void *)(a1 + 2160) + ((unint64_t)(*(void *)(a1 + 2080) + 0x7FFFFFLL) >> 23), 0x38uLL);
  if (!v78)
  {
LABEL_86:
    int v109 = *__error();
    uint64_t v107 = "aaCalloc";
    __int16 v108 = 601;
    goto LABEL_87;
  }
  unint64_t v79 = v78;
  if (a2 < 0)
  {
    *__error() = 12;
    uint64_t v80 = 0;
    uint64_t v82 = 0;
    *__error() = 12;
LABEL_104:
    uint64_t v120 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 606, 138, *v120, "aaCalloc", v121, v122, v150);
    goto LABEL_88;
  }
  uint64_t v80 = (uint64_t **)calloc(a2, 0x10uLL);
  uint64_t v81 = calloc(a2, 8uLL);
  uint64_t v82 = v81;
  if (!v80 || !v81) {
    goto LABEL_104;
  }
  if (a2)
  {
    uint64_t v83 = a2;
    int64x2_t v84 = v80;
    uint64_t v85 = (uint64_t ***)v81;
    do
    {
      *v85++ = v84;
      *int64x2_t v84 = v76;
      v84 += 2;
      --v83;
    }
    while (v83);
  }
  unint64_t v93 = ThreadPoolCreate(a2, (uint64_t)v81, (uint64_t)rawimg_digest_worker);
  if (!v93)
  {
    uint64_t v123 = "ThreadPoolCreate";
    __int16 v124 = 613;
    goto LABEL_110;
  }
  unint64_t v153 = v77;
  unint64_t v159 = v11;
  unint64_t v94 = *(void *)(a1 + 2056);
  if (v94 < *(void *)(a1 + 2072))
  {
    size_t v165 = 0;
    uint64_t v95 = -(uint64_t)v94;
    int64x2_t v96 = v79;
    while (1)
    {
      uint64_t Worker = ThreadPoolGetWorker((uint64_t)v93, v86, v87, v88, v89, v90, v91, v92);
      if (!Worker)
      {
        uint64_t v143 = "ThreadPoolGetWorker";
        __int16 v144 = 622;
        goto LABEL_133;
      }
      *(void *)(Worker + 8) = v96;
      v96[6] = -1;
      v96[4] = v94;
      unint64_t v102 = v95 + *(void *)(a1 + 2072);
      if (v102 >= 0x800000) {
        unint64_t v102 = 0x800000;
      }
      v96[5] = v102;
      if ((ThreadPoolRunWorker((uint64_t)v93, Worker, v98, v99, v100, v101, v91, v92) & 0x80000000) != 0) {
        break;
      }
      ++v165;
      v94 += 0x800000;
      v95 -= 0x800000;
      v96 += 7;
      if (v94 >= *(void *)(a1 + 2072)) {
        goto LABEL_113;
      }
    }
    uint64_t v143 = "ThreadPoolRunWorker";
    __int16 v144 = 627;
    goto LABEL_133;
  }
  size_t v165 = 0;
LABEL_113:
  unint64_t v125 = *(void *)(a1 + 2160);
  if (!v125)
  {
    uint64_t v11 = v159;
    size_t v127 = v153;
    size_t v128 = v165;
LABEL_127:
    if (v128 <= v127)
    {
      if ((ThreadPoolSync(v93) & 0x80000000) == 0)
      {
        qsort(v79, v128, 0x38uLL, (int (__cdecl *)(const void *, const void *))compare_digest_tasks);
        CC_SHA256_Init(&c);
        if (v128)
        {
          char v145 = (char *)v79;
          do
          {
            CC_SHA256_Update(&c, v145, 0x20u);
            v145 += 56;
            --v128;
          }
          while (v128);
        }
        CC_SHA256_Final((unsigned __int8 *)(a1 + 2088), &c);
        if (*(void *)(a1 + 2160))
        {
          uint64_t v146 = 0;
          unint64_t v147 = 0;
          do
          {
            CC_SHA256_Init(&c);
            if (v79[7 * v146 + 6] == v147)
            {
              unint64_t v148 = &v79[7 * v146];
              do
              {
                CC_SHA256_Update(&c, v148, 0x20u);
                ++v146;
                uint64_t v149 = v148[13];
                v148 += 7;
              }
              while (v149 == v147);
            }
            CC_SHA256_Final((unsigned __int8 *)(*(void *)(a1 + 2144) + 440 * v147++), &c);
          }
          while (v147 < *(void *)(a1 + 2160));
        }
        *(void *)(a1 + 2128) |= 0x10uLL;
        int v113 = 1;
        goto LABEL_134;
      }
      uint64_t v123 = "ThreadPoolSync";
      __int16 v124 = 655;
    }
    else
    {
      uint64_t v123 = "too many tasks";
      __int16 v124 = 649;
    }
LABEL_110:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", v124, 138, 0, v123, v91, v92, v150);
    goto LABEL_95;
  }
  uint64_t v126 = 0;
  uint64_t v11 = v159;
  size_t v127 = v153;
  size_t v128 = v165;
  while (1)
  {
    uint64_t v129 = *(void *)(a1 + 2144);
    uint64_t v130 = v129 + 440 * v126;
    if (*(void *)(v130 + 392)) {
      break;
    }
LABEL_123:
    if (++v126 >= v125) {
      goto LABEL_127;
    }
  }
  uint64_t v131 = 0;
  uint64_t v132 = 0;
  uint64_t v133 = (void *)(v130 + 392);
  uint64_t v161 = v126;
  uint64_t v155 = v133;
  uint64_t v157 = (void *)(v129 + 440 * v126 + 48);
  size_t v166 = v128;
  uint64_t v134 = &v79[7 * v128];
  while (1)
  {
    uint64_t v163 = v131;
    uint64_t v135 = v132;
    uint64_t v136 = v133;
    uint64_t v137 = ThreadPoolGetWorker((uint64_t)v93, v86, v87, v88, v89, v90, v91, v92);
    if (!v137)
    {
      uint64_t v143 = "ThreadPoolGetWorker";
      __int16 v144 = 641;
      goto LABEL_133;
    }
    *(void *)(v137 + 8) = v134;
    v134[6] = v161;
    v134[4] = v135 + *v157;
    unint64_t v142 = v163 + *v136;
    if (v142 >= 0x800000) {
      unint64_t v142 = 0x800000;
    }
    v134[5] = v142;
    if ((ThreadPoolRunWorker((uint64_t)v93, v137, v138, v139, v140, v141, v91, v92) & 0x80000000) != 0) {
      break;
    }
    ++v166;
    uint64_t v133 = v155;
    uint64_t v131 = v163 - 0x800000;
    v134 += 7;
    uint64_t v132 = v135 + 0x800000;
    if ((unint64_t)(v135 + 0x800000) >= *v155)
    {
      unint64_t v125 = *(void *)(a1 + 2160);
      uint64_t v11 = v159;
      uint64_t v126 = v161;
      size_t v127 = v153;
      size_t v128 = v166;
      goto LABEL_123;
    }
  }
  uint64_t v143 = "ThreadPoolRunWorker";
  __int16 v144 = 646;
LABEL_133:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", v144, 138, 0, v143, v91, v92, v150);
  int v113 = 0;
LABEL_134:
  uint64_t v11 = v159;
LABEL_96:
  if ((ThreadPoolDestroy((uint64_t)v93) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 683, 138, 0, "ThreadPoolDestroy", v114, v115, v150);
    int v113 = 0;
  }
  free(v80);
  free(v82);
  free(v79);
  AAByteStreamClose((AAByteStream)v76);
  AAByteStreamClose((AAByteStream)v20);
  AAByteStreamClose(v11);
  if (v113) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void rawimg_free_chunks(void *a1)
{
  if (a1[270])
  {
    unint64_t v2 = 0;
    uint64_t v3 = 384;
    do
    {
      uint64_t v4 = a1[268] + v3;
      free(*(void **)v4);
      *(void *)uint64_t v4 = 0;
      *(void *)(v4 - 328) = 0;
      *(void *)(v4 + 24) &= ~4uLL;
      ++v2;
      v3 += 440;
    }
    while (v2 < a1[270]);
  }
  a1[266] &= ~8uLL;
}

uint64_t rawimg_digest_worker(void *a1)
{
  uint64_t v2 = a1[1];
  memset(&v21, 0, sizeof(v21));
  uint64_t v3 = (char *)malloc(0x10000uLL);
  if (!v3)
  {
    int v17 = *__error();
    uint64_t v18 = "aaMalloc";
    __int16 v19 = 530;
LABEL_20:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_digest_worker", v19, 138, v17, v18, v4, v5, v21.count[0]);
    uint64_t v16 = 0xFFFFFFFFLL;
    goto LABEL_21;
  }
  CC_SHA256_Init(&v21);
  unint64_t v6 = *(void *)(v2 + 40);
  if (v6)
  {
    unint64_t v7 = 0;
    while (1)
    {
      unint64_t v8 = v6 - v7;
      uint64_t v9 = v8 >= 0x10000 ? 0x10000 : v8;
      uint64_t v10 = *a1;
      if (!*(void *)(*a1 + 32)) {
        break;
      }
      if (v9)
      {
        uint64_t v11 = 0;
        unint64_t v12 = *(void *)(v2 + 32) + v7;
        uint64_t v13 = v3;
        uint64_t v14 = v9;
        while (1)
        {
          uint64_t v15 = (*(uint64_t (**)(void, char *, uint64_t, unint64_t))(v10 + 32))(*(void *)v10, v13, v14, v12);
          if (v15 < 0) {
            break;
          }
          if (v15)
          {
            v13 += v15;
            v11 += v15;
            v12 += v15;
            v14 -= v15;
            if (v14) {
              continue;
            }
          }
          goto LABEL_15;
        }
        uint64_t v11 = v15;
LABEL_15:
        if (v9 != v11) {
          break;
        }
      }
      CC_SHA256_Update(&v21, v3, v9);
      v7 += 0x10000;
      unint64_t v6 = *(void *)(v2 + 40);
      if (v7 >= v6) {
        goto LABEL_17;
      }
    }
    uint64_t v18 = "aaByteStreamPReadExpected";
    __int16 v19 = 537;
    int v17 = 0;
    goto LABEL_20;
  }
LABEL_17:
  CC_SHA256_Final((unsigned __int8 *)v2, &v21);
  uint64_t v16 = 0;
LABEL_21:
  free(v3);
  return v16;
}

uint64_t compare_digest_tasks(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 48);
  unint64_t v3 = *(void *)(a2 + 48);
  BOOL v4 = v2 >= v3;
  if (v2 == v3) {
    BOOL v4 = *(void *)(a1 + 32) >= *(void *)(a2 + 32);
  }
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 1;
  }
}

uint64_t rawimg_set_fork_types(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 >= 0x21)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_set_fork_types", 751, 138, 0, "too many variants", a7, a8, v41);
    unint64_t v8 = 0;
    goto LABEL_33;
  }
  if (a2 != 1)
  {
    unint64_t v8 = pc_array_init(16);
    if (v8)
    {
      if (!a2)
      {
LABEL_18:
        pc_array_sort(v8, (int (__cdecl *)(const void *, const void *))compare_copy_fork_5);
        pc_array_aggregate((char *)v8, (unsigned int (*)(char *, char *))compare_copy_fork_4, (uint64_t (*)(char *, char *))aggregate_copy_fork);
        uint64_t v24 = *(v8 - 8);
        if (v24)
        {
          uint64_t v25 = v8 + 1;
          do
          {
            if ((*v25 & 1) == 0) {
              *(void *)(*((void *)v25 - 1) + 408) |= 1uLL;
            }
            v25 += 16;
            --v24;
          }
          while (v24);
        }
        pc_array_aggregate((char *)v8, (unsigned int (*)(char *, char *))compare_copy_fork_3, (uint64_t (*)(char *, char *))aggregate_copy_fork);
        unint64_t v26 = *(v8 - 8);
        if (v26)
        {
          unint64_t v27 = 0;
          uint64_t v28 = 0;
          unint64_t v29 = v8 + 1;
          do
          {
            if (*v29 == ~(-1 << a2))
            {
              *(_OWORD *)&v8[2 * v28++] = *(_OWORD *)(v29 - 2);
              unint64_t v26 = *(v8 - 8);
            }
            ++v27;
            v29 += 4;
          }
          while (v27 < v26);
        }
        else
        {
          uint64_t v28 = 0;
        }
        *(v8 - 8) = v28;
        if (a2)
        {
          uint64_t v33 = 0;
          do
          {
            uint64_t v34 = *(void *)(a1 + 8 * v33);
            if (*(void *)(v34 + 2160))
            {
              unint64_t v35 = 0;
              uint64_t v36 = 408;
              do
              {
                uint64_t v37 = *(void *)(v34 + 2144);
                uint64_t v41 = v37 + v36 - 408;
                uint64_t v42 = 0;
                uint64_t v38 = bsearch(&v41, v8, *(v8 - 8), 0x10uLL, (int (__cdecl *)(const void *, const void *))compare_copy_fork_3);
                if (v38) {
                  BOOL v39 = 1;
                }
                else {
                  BOOL v39 = v33 == 0;
                }
                if (v39)
                {
                  if (v38) {
                    uint64_t v40 = 2;
                  }
                  else {
                    uint64_t v40 = 1;
                  }
                  *(void *)(v37 + v36) |= v40;
                }
                ++v35;
                v36 += 440;
              }
              while (v35 < *(void *)(v34 + 2160));
            }
            ++v33;
          }
          while (v33 != a2);
        }
        uint64_t v13 = 0;
        goto LABEL_34;
      }
      uint64_t v20 = 0;
      while (1)
      {
        uint64_t v21 = *(void *)(a1 + 8 * v20);
        if ((*(unsigned char *)(v21 + 2128) & 0x10) == 0)
        {
          uint64_t v30 = "no digests found";
          __int16 v31 = 778;
          goto LABEL_32;
        }
        if (*(void *)(v21 + 2160)) {
          break;
        }
LABEL_17:
        if (++v20 == a2) {
          goto LABEL_18;
        }
      }
      uint64_t v22 = 0;
      unint64_t v23 = 0;
      while (1)
      {
        uint64_t v41 = *(void *)(v21 + 2144) + v22;
        uint64_t v42 = (1 << v20);
        if ((*(unsigned char *)(v41 + 408) & 3) != 0)
        {
          uint64_t v30 = "bad flags";
          __int16 v31 = 789;
          goto LABEL_32;
        }
        unint64_t v8 = pc_array_append((uint64_t)v8, &v41, v14, v15, v16, v17, v18, v19);
        if (!v8) {
          break;
        }
        ++v23;
        v22 += 440;
        if (v23 >= *(void *)(v21 + 2160)) {
          goto LABEL_17;
        }
      }
      uint64_t v30 = "pc_array_append";
      __int16 v31 = 793;
    }
    else
    {
      uint64_t v30 = "pc_array_init";
      __int16 v31 = 771;
    }
LABEL_32:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_set_fork_types", v31, 138, 0, v30, v18, v19, v41);
LABEL_33:
    uint64_t v13 = 0xFFFFFFFFLL;
LABEL_34:
    pc_array_free((uint64_t)v8);
    return v13;
  }
  uint64_t v11 = *(void *)(*(void *)a1 + 2160);
  if (v11)
  {
    unint64_t v12 = (unint64_t *)(*(void *)(*(void *)a1 + 2144) + 408);
    do
    {
      *unint64_t v12 = *v12 & 0xFFFFFFFFFFFFFFFCLL | 1;
      v12 += 55;
      --v11;
    }
    while (v11);
  }
  return 0;
}

uint64_t compare_copy_fork_5(uint64_t a1, uint64_t a2)
{
  uint64_t result = compare_copy_fork_3((unint64_t **)a1, (unint64_t **)a2);
  if (!result)
  {
    int v5 = *(_DWORD *)(a1 + 8);
    int v6 = *(_DWORD *)(a2 + 8);
    uint64_t result = (v5 - v6);
    if (v5 == v6)
    {
      if (*(void *)(*(void *)a1 + 416) < *(void *)(*(void *)a2 + 416)) {
        return 0xFFFFFFFFLL;
      }
      else {
        return 1;
      }
    }
  }
  return result;
}

uint64_t compare_copy_fork_4(uint64_t a1, uint64_t a2)
{
  uint64_t result = compare_copy_fork_3((unint64_t **)a1, (unint64_t **)a2);
  if (!result) {
    return (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8));
  }
  return result;
}

uint64_t aggregate_copy_fork(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) |= *(_DWORD *)(a2 + 8);
  return 0;
}

uint64_t compare_copy_fork_3(unint64_t **a1, unint64_t **a2)
{
  unint64_t v2 = *a1;
  unint64_t v3 = *a2;
  unint64_t v4 = bswap64(**a1);
  unint64_t v5 = bswap64(**a2);
  if (v4 == v5
    && (unint64_t v4 = bswap64(v2[1]), v5 = bswap64(v3[1]), v4 == v5)
    && (unint64_t v4 = bswap64(v2[2]), v5 = bswap64(v3[2]), v4 == v5)
    && (unint64_t v4 = bswap64(v2[3]), v5 = bswap64(v3[3]), v4 == v5))
  {
    uint64_t v7 = v2[50] - v3[50];
    if (v7)
    {
      if (v7 < 0) {
        return 0xFFFFFFFFLL;
      }
      else {
        return 1;
      }
    }
    else
    {
      return *((unsigned __int8 *)v2 + 432) - *((unsigned __int8 *)v3 + 432);
    }
  }
  else if (v4 < v5)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 1;
  }
}

uint64_t rawimg_save_to_stream(void *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a2 + 2128);
  if ((v8 & 0x10) != 0)
  {
    if ((v8 & 8) != 0)
    {
      long long v14 = *(_OWORD *)(a2 + 2104);
      v50[0] = *(_OWORD *)(a2 + 2088);
      v50[1] = v14;
      uint64_t v15 = 24;
      if (!a3) {
        uint64_t v15 = 16;
      }
      uint64_t v51 = *(void *)(a2 + 2120);
      uint64_t v52 = v15;
      long long v53 = *(_OWORD *)(a2 + 2152);
      if (a1[3])
      {
        uint64_t v16 = 0;
        uint64_t v17 = v50;
        uint64_t v18 = 64;
        while (1)
        {
          uint64_t v19 = ((uint64_t (*)(void, _OWORD *, uint64_t))a1[3])(*a1, v17, v18);
          if (v19 < 1) {
            break;
          }
          uint64_t v17 = (_OWORD *)((char *)v17 + v19);
          v16 += v19;
          v18 -= v19;
          if (!v18)
          {
            if (v16 != 64) {
              break;
            }
            if (!a1[3]) {
              goto LABEL_55;
            }
            uint64_t v20 = 16 * v53;
            if (16 * (void)v53)
            {
              uint64_t v21 = 0;
              uint64_t v22 = *(void *)(a2 + 2136);
              uint64_t v23 = 16 * v53;
              while (1)
              {
                uint64_t v24 = ((uint64_t (*)(void, uint64_t, uint64_t))a1[3])(*a1, v22, v23);
                if (v24 < 1) {
                  break;
                }
                v22 += v24;
                v21 += v24;
                v23 -= v24;
                if (!v23) {
                  goto LABEL_21;
                }
              }
              uint64_t v21 = v24;
LABEL_21:
              if (v20 != v21)
              {
LABEL_55:
                uint64_t v9 = "aaByteStreamWriteExpected";
                __int16 v10 = 893;
                goto LABEL_19;
              }
            }
            if (!*((void *)&v53 + 1)) {
              return 0;
            }
            uint64_t v26 = 0;
            __n128 v27 = 0uLL;
LABEL_24:
            uint64_t v28 = *(void *)(a2 + 2144);
            *(__n128 *)((char *)v49 + 9) = v27;
            __n128 v48 = v27;
            v49[0] = v27;
            uint64_t v29 = v28 + 440 * v26;
            __n128 v48 = *(__n128 *)(v29 + 392);
            long long v30 = *(_OWORD *)(v29 + 408);
            v49[0] = v30;
            *(void *)&v49[1] = *(void *)(v29 + 424);
            BYTE8(v49[1]) = *(unsigned char *)(v29 + 432);
            if ((v30 & 1) == 0) {
              *(void *)&v49[0] = v30 & 0xFFFFFFFFFFFFFFFBLL;
            }
            if (a1[3])
            {
              uint64_t v31 = 0;
              uint64_t v32 = &v48;
              uint64_t v33 = 41;
              while (1)
              {
                uint64_t v34 = ((uint64_t (*)(void, __n128 *, uint64_t))a1[3])(*a1, v32, v33);
                if (v34 < 1) {
                  break;
                }
                uint64_t v32 = (__n128 *)((char *)v32 + v34);
                v31 += v34;
                v33 -= v34;
                if (!v33)
                {
                  if (v31 != 41) {
                    break;
                  }
                  __n128 v27 = 0uLL;
                  if (a3 && (v49[0] & 1) != 0)
                  {
                    if (!a1[3]) {
                      goto LABEL_60;
                    }
                    uint64_t v35 = 12 * *(void *)(v28 + 440 * v26 + 56);
                    if (v35)
                    {
                      uint64_t v36 = 0;
                      uint64_t v37 = *(void *)(v28 + 440 * v26 + 384);
                      uint64_t v38 = 12 * *(void *)(v28 + 440 * v26 + 56);
                      while (1)
                      {
                        uint64_t v39 = ((uint64_t (*)(void, uint64_t, uint64_t, __n128))a1[3])(*a1, v37, v38, v27);
                        if (v39 < 1) {
                          break;
                        }
                        v37 += v39;
                        v36 += v39;
                        v38 -= v39;
                        if (!v38) {
                          goto LABEL_40;
                        }
                      }
                      uint64_t v36 = v39;
LABEL_40:
                      __n128 v27 = 0uLL;
                      if (v35 != v36)
                      {
LABEL_60:
                        __int16 v10 = 925;
                        goto LABEL_57;
                      }
                    }
                    if ((v49[0] & 4) != 0)
                    {
                      if (a1[3])
                      {
                        uint64_t v40 = 0;
                        uint64_t v41 = v28 + 440 * v26 + 64;
                        uint64_t v42 = 264;
                        while (1)
                        {
                          uint64_t v43 = ((uint64_t (*)(void, uint64_t, uint64_t, __n128))a1[3])(*a1, v41, v42, v27);
                          if (v43 < 1) {
                            break;
                          }
                          v41 += v43;
                          v40 += v43;
                          v42 -= v43;
                          if (!v42)
                          {
                            if (v40 != 264) {
                              break;
                            }
                            if (a1[3])
                            {
                              uint64_t v44 = 0;
                              uint64_t v45 = v28 + 440 * v26 + 328;
                              uint64_t v46 = 50;
                              while (1)
                              {
                                uint64_t v47 = ((uint64_t (*)(void, uint64_t, uint64_t))a1[3])(*a1, v45, v46);
                                if (v47 < 1) {
                                  break;
                                }
                                v45 += v47;
                                v44 += v47;
                                v46 -= v47;
                                if (!v46)
                                {
                                  __n128 v27 = 0uLL;
                                  if (v44 == 50) {
                                    goto LABEL_42;
                                  }
                                  break;
                                }
                              }
                            }
                            __int16 v10 = 934;
                            goto LABEL_57;
                          }
                        }
                      }
                      __int16 v10 = 932;
                      goto LABEL_57;
                    }
                  }
LABEL_42:
                  uint64_t result = 0;
                  if ((unint64_t)++v26 < *((void *)&v53 + 1)) {
                    goto LABEL_24;
                  }
                  return result;
                }
              }
            }
            __int16 v10 = 917;
LABEL_57:
            uint64_t v9 = "aaByteStreamWriteExpected";
            goto LABEL_19;
          }
        }
      }
      uint64_t v9 = "aaByteStreamWriteExpected";
      __int16 v10 = 888;
    }
    else
    {
      uint64_t v9 = "no chunk info";
      __int16 v10 = 877;
    }
  }
  else
  {
    uint64_t v9 = "no digest info";
    __int16 v10 = 876;
  }
LABEL_19:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_save_to_stream", v10, 138, 0, v9, a7, a8, v48.n128_i8[0]);
  return 0xFFFFFFFFLL;
}

char *rawimg_create_with_stream(void *a1, int a2)
{
  uint64_t v65 = *MEMORY[0x263EF8340];
  unint64_t v4 = (char *)calloc(1uLL, 0x878uLL);
  uint64_t v7 = v4;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  if (!v4)
  {
    int v29 = *__error();
    __n128 v27 = "aaCalloc";
    __int16 v28 = 953;
    goto LABEL_20;
  }
  if (!a1[2]) {
    goto LABEL_17;
  }
  uint64_t v8 = 0;
  uint64_t v9 = v4 + 2120;
  __int16 v10 = &v61;
  uint64_t v11 = 64;
  do
  {
    uint64_t v12 = ((uint64_t (*)(void, long long *, uint64_t))a1[2])(*a1, v10, v11);
    if (v12 < 0) {
      goto LABEL_17;
    }
    if (!v12) {
      break;
    }
    __int16 v10 = (long long *)((char *)v10 + v12);
    v8 += v12;
    v11 -= v12;
  }
  while (v11);
  if (v8 == 64)
  {
    long long v13 = v62;
    *(_OWORD *)(v7 + 2088) = v61;
    *(_OWORD *)(v7 + 2104) = v13;
    long long v14 = v64;
    *uint64_t v9 = v63;
    *(_OWORD *)(v7 + 2152) = v14;
    *((void *)v7 + 267) = pc_array_init(16, v14);
    uint64_t v15 = pc_array_init(440, *((void *)v7 + 270));
    *((void *)v7 + 268) = v15;
    uint64_t v21 = *((void *)v7 + 267);
    if (v21 && v15)
    {
      uint64_t v22 = *((void *)v7 + 269);
      *(void *)(v21 - 64) = v22;
      *(v15 - 8) = *((void *)v7 + 270);
      if (!a1[2]) {
        goto LABEL_62;
      }
      uint64_t v23 = 16 * v22;
      if (!(16 * v22)) {
        goto LABEL_25;
      }
      uint64_t v24 = 0;
      uint64_t v25 = 16 * v22;
      while (1)
      {
        uint64_t v26 = ((uint64_t (*)(void, uint64_t, uint64_t))a1[2])(*a1, v21, v25);
        if (v26 < 0) {
          break;
        }
        if (v26)
        {
          v21 += v26;
          v24 += v26;
          v25 -= v26;
          if (v25) {
            continue;
          }
        }
        goto LABEL_24;
      }
      uint64_t v24 = v26;
LABEL_24:
      if (v23 == v24)
      {
LABEL_25:
        if (!*((void *)&v64 + 1))
        {
LABEL_60:
          if ((rawimg_verify(v7, v16, v17, v18, v19, v20, v5, v6) & 0x80000000) == 0) {
            return v7;
          }
          __n128 v27 = "rawimg_verify";
          __int16 v28 = 1023;
          goto LABEL_18;
        }
        unint64_t v31 = 0;
        long long v32 = 0uLL;
        while (2)
        {
          uint64_t v33 = *((void *)v7 + 268);
          *(_OWORD *)&v60[9] = v32;
          long long v59 = v32;
          *(_OWORD *)size_t v60 = v32;
          if (a1[2])
          {
            uint64_t v34 = 0;
            uint64_t v35 = &v59;
            uint64_t v36 = 41;
            do
            {
              uint64_t v37 = ((uint64_t (*)(void, long long *, uint64_t))a1[2])(*a1, v35, v36);
              if (v37 < 0) {
                goto LABEL_63;
              }
              if (!v37) {
                break;
              }
              uint64_t v35 = (long long *)((char *)v35 + v37);
              v34 += v37;
              v36 -= v37;
            }
            while (v36);
            if (v34 != 41) {
              break;
            }
            uint64_t v38 = v33 + 440 * v31;
            *(void *)(v38 + 432) = 0;
            *(_OWORD *)(v38 + 400) = 0u;
            *(_OWORD *)(v38 + 416) = 0u;
            *(_OWORD *)(v38 + 368) = 0u;
            *(_OWORD *)(v38 + 384) = 0u;
            *(_OWORD *)(v38 + 336) = 0u;
            *(_OWORD *)(v38 + 352) = 0u;
            *(_OWORD *)(v38 + 304) = 0u;
            *(_OWORD *)(v38 + 320) = 0u;
            *(_OWORD *)(v38 + 272) = 0u;
            *(_OWORD *)(v38 + 288) = 0u;
            *(_OWORD *)(v38 + 240) = 0u;
            *(_OWORD *)(v38 + 256) = 0u;
            *(_OWORD *)(v38 + 208) = 0u;
            *(_OWORD *)(v38 + 224) = 0u;
            *(_OWORD *)(v38 + 176) = 0u;
            *(_OWORD *)(v38 + 192) = 0u;
            *(_OWORD *)(v38 + 144) = 0u;
            *(_OWORD *)(v38 + 160) = 0u;
            *(_OWORD *)(v38 + 112) = 0u;
            *(_OWORD *)(v38 + 128) = 0u;
            *(_OWORD *)(v38 + 80) = 0u;
            *(_OWORD *)(v38 + 96) = 0u;
            *(_OWORD *)(v38 + 48) = 0u;
            *(_OWORD *)(v38 + 64) = 0u;
            *(_OWORD *)(v38 + 16) = 0u;
            *(_OWORD *)(v38 + 32) = 0u;
            *(_OWORD *)uint64_t v38 = 0u;
            uint64_t v39 = v59;
            *(_OWORD *)(v38 + 392) = v59;
            uint64_t v40 = (unsigned char *)(v38 + 408);
            char v41 = v60[0];
            *(_OWORD *)(v38 + 408) = *(_OWORD *)v60;
            *(void *)(v38 + 424) = *(void *)&v60[16];
            *(unsigned char *)(v38 + 432) = v60[24];
            if (a2 && (v41 & 1) != 0)
            {
              size_t v42 = (unint64_t)(v39 + 0xFFFF) >> 16;
              uint64_t v43 = v33 + 440 * v31;
              *(void *)(v43 + 56) = v42;
              uint64_t v44 = (void *)(v43 + 56);
              if ((unint64_t)(v39 + 0xFFFF) >= 0x2AAAAAAAB0000)
              {
                *__error() = 12;
                *(void *)(v33 + 440 * v31 + 384) = 0;
              }
              else
              {
                uint64_t v45 = (char *)calloc(v42, 0xCuLL);
                *(void *)(v33 + 440 * v31 + 384) = v45;
                if (v45)
                {
                  if (!a1[2]) {
                    goto LABEL_66;
                  }
                  uint64_t v46 = 12 * *v44;
                  if (v46)
                  {
                    uint64_t v47 = v45;
                    uint64_t v48 = 0;
                    uint64_t v49 = 12 * *v44;
                    while (1)
                    {
                      uint64_t v50 = ((uint64_t (*)(void, char *, uint64_t))a1[2])(*a1, v47, v49);
                      if (v50 < 0) {
                        break;
                      }
                      if (v50)
                      {
                        v47 += v50;
                        v48 += v50;
                        v49 -= v50;
                        if (v49) {
                          continue;
                        }
                      }
                      goto LABEL_45;
                    }
                    uint64_t v48 = v50;
LABEL_45:
                    if (v46 != v48)
                    {
LABEL_66:
                      __n128 v27 = "aaByteStreamReadExpected";
                      __int16 v28 = 1008;
                      goto LABEL_18;
                    }
                  }
                  if ((*v40 & 4) != 0)
                  {
                    if (a1[2])
                    {
                      uint64_t v51 = 0;
                      uint64_t v52 = v33 + 440 * v31 + 64;
                      uint64_t v53 = 264;
                      while (1)
                      {
                        uint64_t v54 = ((uint64_t (*)(void, uint64_t, uint64_t))a1[2])(*a1, v52, v53);
                        if (v54 < 0) {
                          break;
                        }
                        if (v54)
                        {
                          v52 += v54;
                          v51 += v54;
                          v53 -= v54;
                          if (v53) {
                            continue;
                          }
                        }
                        if (v51 != 264) {
                          break;
                        }
                        if (a1[2])
                        {
                          uint64_t v55 = 0;
                          uint64_t v56 = v33 + 440 * v31 + 328;
                          uint64_t v57 = 50;
                          while (1)
                          {
                            uint64_t v58 = ((uint64_t (*)(void, uint64_t, uint64_t))a1[2])(*a1, v56, v57);
                            if (v58 < 0) {
                              break;
                            }
                            if (v58)
                            {
                              v56 += v58;
                              v55 += v58;
                              v57 -= v58;
                              if (v57) {
                                continue;
                              }
                            }
                            if (v55 != 50) {
                              break;
                            }
                            goto LABEL_59;
                          }
                        }
                        __n128 v27 = "aaByteStreamReadExpected";
                        __int16 v28 = 1017;
                        goto LABEL_18;
                      }
                    }
                    __n128 v27 = "aaByteStreamReadExpected";
                    __int16 v28 = 1015;
                    goto LABEL_18;
                  }
                  goto LABEL_59;
                }
              }
              int v29 = *__error();
              __n128 v27 = "aaCalloc";
              __int16 v28 = 1003;
              goto LABEL_20;
            }
LABEL_59:
            ++v31;
            long long v32 = 0uLL;
            if (v31 < *((void *)&v64 + 1)) {
              continue;
            }
            goto LABEL_60;
          }
          break;
        }
LABEL_63:
        __n128 v27 = "aaByteStreamReadExpected";
        __int16 v28 = 986;
      }
      else
      {
LABEL_62:
        __n128 v27 = "aaByteStreamReadExpected";
        __int16 v28 = 976;
      }
    }
    else
    {
      __n128 v27 = "pc_array_init";
      __int16 v28 = 969;
    }
  }
  else
  {
LABEL_17:
    __n128 v27 = "aaByteStreamReadExpected";
    __int16 v28 = 957;
  }
LABEL_18:
  int v29 = 0;
LABEL_20:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_create_with_stream", v28, 138, v29, v27, v5, v6, v59);
  rawimg_destroy((uint64_t *)v7);
  return 0;
}

uint64_t compare_forks_by_extent(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 416);
  unint64_t v3 = *(void *)(a2 + 416);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t aggregate_identical_forks(const void *a1, const void *a2)
{
  if (!memcmp(a1, a2, 0x1B8uLL)) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t compare_forks_by_position(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(*(void *)(a1 + 2136) + 16 * *(void *)(a2 + 416)) < *(void *)(*(void *)(a1 + 2136)
                                                                                      + 16 * *(void *)(a3 + 416)))
    return 0xFFFFFFFFLL;
  else {
    return 1;
  }
}

uint64_t BXPatchFile(const char *a1, const char *a2, void *a3, unint64_t a4, uint64_t a5, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  int v8 = a7;
  uint64_t v70 = *MEMORY[0x263EF8340];
  enterThreadErrorContext((uint64_t)a1, (uint64_t)a2, (uint64_t)a3, a4, a5, (uint64_t)a6, a7, a8, v60);
  unint64_t v62 = 0;
  long long v63 = 0;
  if (a6)
  {
    BOOL v16 = *a6 != 0;
    BOOL v17 = a6[1] != 0;
  }
  else
  {
    BOOL v16 = 0;
    BOOL v17 = 0;
  }
  memset(&v65, 0, sizeof(v65));
  memset(&v64, 0, sizeof(v64));
  if (a4 <= 7)
  {
    uint64_t v18 = "Invalid patch";
    __int16 v19 = 25;
LABEL_6:
    int v20 = 0;
LABEL_17:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatchFile.c", (uint64_t)"BXPatchFile", v19, 48, v20, v18, v14, v15, v61);
    unint64_t v31 = 0;
LABEL_18:
    int v32 = 0;
    goto LABEL_19;
  }
  if (*a3 == 0x3034464649445342 || *a3 == 0x3034464649445842 || *a3 == 0x3134464649445842)
  {
    char v21 = 0;
    uint64_t v22 = a3[3];
    if (v22 >= 0) {
      unint64_t v23 = a3[3];
    }
    else {
      unint64_t v23 = 0x8000000000000000 - v22;
    }
  }
  else
  {
    if (*a3 != 0x3035464649445842)
    {
      uint64_t v18 = "Unsupported patch format";
      __int16 v19 = 36;
      goto LABEL_6;
    }
    unint64_t v23 = a3[2];
    char v21 = 1;
  }
  if (lstat(a1, &v65))
  {
    int v20 = *__error();
    char v61 = (char)a1;
    uint64_t v18 = "%s";
    __int16 v19 = 39;
    goto LABEL_17;
  }
  v67.tv_seCC_SHA256_CTX c = v65.st_atimespec.tv_sec;
  v67.tv_useCC_SHA256_CTX c = 0;
  tv_seCC_SHA256_CTX c = v65.st_mtimespec.tv_sec;
  int v69 = 0;
  if (loadFileContents(a1, (char **)&v63, (off_t *)&v62, 0))
  {
    char v61 = (char)a1;
    uint64_t v18 = "opening input file: %s";
    __int16 v19 = 53;
    goto LABEL_6;
  }
  if (!strcmp(a1, a2)) {
    unlink(a1);
  }
  bzero(v66, 0x400uLL);
  size_t v35 = strlen(a2);
  __memcpy_chk();
  makePath(v66, v35);
  if (v23)
  {
    if (statIsCompressed(v65.st_flags)) {
      int v36 = 1;
    }
    else {
      int v36 = v17;
    }
    if (v36) {
      int v37 = 4;
    }
    else {
      int v37 = 0;
    }
  }
  else
  {
    int v37 = 0;
  }
  if (v16) {
    unsigned int v38 = v37 | 0x2B;
  }
  else {
    unsigned int v38 = v37;
  }
  unint64_t v31 = OArchiveFileStreamCreate(a2, v23, v38, -1, 0);
  if (!v31)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatchFile.c", (uint64_t)"BXPatchFile", 81, 48, 0, "OArchiveFileStreamCreate: %s", v39, v40, (char)a2);
    goto LABEL_18;
  }
  if (v21)
  {
    if (BXPatch5((uint64_t)v63, v62, (uint64_t)a3, a4, (uint64_t (*)(uint64_t, void *, uint64_t))OArchiveFileStreamWrite, (uint64_t)v31, v8))
    {
      __int16 v48 = 91;
LABEL_48:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatchFile.c", (uint64_t)"BXPatchFile", v48, 48, 0, "Patch application", v46, v47, v61);
      goto LABEL_18;
    }
  }
  else if (BXPatch4((uint64_t)v63, v62, (uint64_t)a3, a4, (uint64_t)OArchiveFileStreamWrite, (uint64_t)v31, v39, v40))
  {
    __int16 v48 = 87;
    goto LABEL_48;
  }
  OArchiveFileStreamDestroy((unsigned int *)v31, v41, v42, v43, v44, v45, v46, v47);
  if (lstat(a2, &v64))
  {
    int v20 = *__error();
    char v61 = (char)a2;
    uint64_t v18 = "%s";
    __int16 v19 = 101;
    goto LABEL_17;
  }
  if (v64.st_uid == v65.st_uid)
  {
    gid_t st_gid = v65.st_gid;
    if (v64.st_gid == v65.st_gid) {
      goto LABEL_57;
    }
  }
  else
  {
    gid_t st_gid = v65.st_gid;
  }
  if (!chown(a2, v65.st_uid, st_gid))
  {
LABEL_57:
    int v32 = 1;
    goto LABEL_58;
  }
  uint64_t v50 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatchFile.c", (uint64_t)"BXPatchFile", 106, 48, *v50, "%s", v51, v52, (char)a2);
  int v32 = 0;
LABEL_58:
  if (v64.st_mode != v65.st_mode && chmod(a2, v65.st_mode & 0xFFF))
  {
    uint64_t v53 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatchFile.c", (uint64_t)"BXPatchFile", 110, 48, *v53, "%s", v54, v55, (char)a2);
    int v32 = 0;
  }
  __uint32_t v56 = v65.st_flags & 0xFFFFFFDF | (32 * ((v64.st_flags >> 5) & 1));
  if (v64.st_flags != v56 && chflags(a2, v56))
  {
    uint64_t v57 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatchFile.c", (uint64_t)"BXPatchFile", 117, 48, *v57, "%s", v58, v59, (char)a2);
    int v32 = 0;
  }
  if (utimes(a2, &v67))
  {
    int v20 = *__error();
    char v61 = (char)a2;
    uint64_t v18 = "%s";
    __int16 v19 = 120;
    goto LABEL_17;
  }
  unint64_t v31 = 0;
LABEL_19:
  OArchiveFileStreamDestroy((unsigned int *)v31, v24, v25, v26, v27, v28, v29, v30);
  free(v63);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (v32) {
    unsigned int v34 = 0;
  }
  else {
    unsigned int v34 = -1;
  }
  if ((int)result >= 0) {
    return v34;
  }
  else {
    return result;
  }
}

uint64_t BXPatch4(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v92 = *MEMORY[0x263EF8340];
  if (a4 <= 0x1F)
  {
    int v8 = "Invalid patch length";
    __int16 v9 = 129;
LABEL_12:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch4.c", (uint64_t)"BXPatch4", v9, 51, 0, v8, a7, a8, v61.i8[0]);
    return 0xFFFFFFFFLL;
  }
  if (*(void *)a3 != 0x3034464649445342
    && *(void *)a3 != 0x3034464649445842
    && *(void *)a3 != 0x3134464649445842)
  {
    int v8 = "Invalid patch header";
    __int16 v9 = 130;
    goto LABEL_12;
  }
  if (*(void *)a3 == 0x3134464649445842) {
    uint64_t v15 = 20;
  }
  else {
    uint64_t v15 = 0;
  }
  int64x2_t v16 = (int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(*(int64x2_t *)(a3 + 8)), (int8x16_t)vsubq_s64(vdupq_n_s64(0x8000000000000000), *(int64x2_t *)(a3 + 8)), *(int8x16_t *)(a3 + 8));
  uint64_t v17 = vaddvq_s64(v16);
  if (v17 + v15 + 32 > a4)
  {
    int v8 = "Invalid patch header contents";
    __int16 v9 = 144;
    goto LABEL_12;
  }
  int64x2_t v61 = v16;
  __int16 v19 = (void *)(a3 + 32);
  if (*(void *)a3 == 0x3134464649445842) {
    uint64_t v20 = -20;
  }
  else {
    uint64_t v20 = 0;
  }
  uint64_t v21 = *(void *)(a3 + 24);
  unint64_t v22 = 0x8000000000000000 - v21;
  if (v21 >= 0) {
    unint64_t v22 = *(void *)(a3 + 24);
  }
  int64_t v62 = v22;
  data = (void *)a1;
  if (*(void *)a3 == 0x3134464649445842)
  {
    memset(&c, 0, sizeof(c));
    CC_SHA1_Deprecated_Init(&c);
    CC_SHA1_Deprecated_Update(&c, data, a2);
    a1 = CC_SHA1_Deprecated_Final(md, &c);
    BOOL v24 = *(void *)md == *v19 && *(void *)&md[8] == *(void *)(a3 + 40);
    if (!v24 || v83 != (unint64_t)*(unsigned int *)(a3 + 48))
    {
      int v8 = "Input file digest and patch digest do not match";
      __int16 v9 = 164;
      goto LABEL_12;
    }
  }
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v61.i8[0]);
  long long v77 = 0u;
  long long v78 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  memset(&c, 0, sizeof(c));
  long long v90 = 0u;
  long long v91 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  long long v86 = 0u;
  long long v87 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  *(_OWORD *)md = 0u;
  long long v83 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  int v23 = *(void *)a3 == 0x3034464649445842 || *(void *)a3 == 0x3134464649445842;
  uint64_t v26 = (char *)malloc(0x20000uLL);
  if (v26)
  {
    uint64_t v27 = (uint64_t)v19 + v15;
    long long v77 = 0u;
    long long v78 = 0u;
    unint64_t v28 = a4 + v20;
    uint64_t v29 = (uint64_t)v19 + v15 + v61.i64[0];
    long long v75 = 0u;
    long long v76 = 0u;
    uint64_t v30 = v28 - v17 - 32;
    memset(&c, 0, sizeof(c));
    *(_OWORD *)md = 0u;
    long long v83 = 0u;
    long long v84 = 0u;
    long long v85 = 0u;
    long long v86 = 0u;
    long long v87 = 0u;
    long long v88 = 0u;
    long long v89 = 0u;
    long long v90 = 0u;
    long long v91 = 0u;
    long long v72 = 0u;
    long long v73 = 0u;
    long long v70 = 0u;
    long long v71 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    long long v66 = 0u;
    long long v67 = 0u;
    long long v64 = 0u;
    long long v65 = 0u;
    int v31 = BufferDecoderInit((uint64_t)&c, v23, v27, v61.i64[0]);
    int v32 = BufferDecoderInit((uint64_t)md, v23, v29, v61.i64[1]);
    if (!BufferDecoderInit((uint64_t)&v64, v23, v29 + v61.i64[1], v30) && !v32 && !v31)
    {
      int v37 = OBufferedStreamCreate(a5, 0, a6, 0x20000uLL);
      if (v37)
      {
        size_t v38 = BufferDecoderRead((int *)&c, (uint64_t)&v79, 24);
        if ((v38 & 0x8000000000000000) != 0)
        {
LABEL_69:
          __int16 v48 = "BufferDecoderRead";
          __int16 v49 = 196;
        }
        else
        {
          uint64_t v39 = 0;
          int64_t v40 = 0;
          while (v38 == 24)
          {
            if (v79 >= 0) {
              unint64_t v41 = v79;
            }
            else {
              unint64_t v41 = 0x8000000000000000 - v79;
            }
            if (v80 >= 0) {
              unint64_t v42 = v80;
            }
            else {
              unint64_t v42 = 0x8000000000000000 - v80;
            }
            uint64_t v43 = v81;
            if (v81 < 0) {
              uint64_t v43 = 0x8000000000000000 - v81;
            }
            v61.i64[0] = v43;
            if (v41)
            {
              while (1)
              {
                if (v41 >= 0x20000) {
                  unint64_t v44 = 0x20000;
                }
                else {
                  unint64_t v44 = v41;
                }
                if (BufferDecoderRead((int *)md, (uint64_t)v26, v44) != v44)
                {
                  __int16 v48 = "Truncated add stream";
                  __int16 v49 = 208;
                  goto LABEL_74;
                }
                if (v39 < 0)
                {
                  __int16 v48 = "invalid patch, input before buffer";
                  __int16 v49 = 209;
                  goto LABEL_74;
                }
                if ((uint64_t)(v44 + v39) > a2)
                {
                  __int16 v48 = "invalid patch, input after buffer";
                  __int16 v49 = 210;
                  goto LABEL_74;
                }
                v40 += v44;
                if (v40 > v62)
                {
                  __int16 v48 = "invalid patch, output after buffer";
                  __int16 v49 = 211;
                  goto LABEL_74;
                }
                uint64_t v45 = 0;
                uint64_t v46 = v44 <= 1 ? 1 : v44;
                do
                {
                  v26[v45] += *((unsigned char *)data + v39 + v45);
                  ++v45;
                }
                while (v46 != v45);
                if (OBufferedStreamWrite((unint64_t **)v37, v26, v44) != v44) {
                  break;
                }
                v39 += v44;
                v41 -= v44;
                if (!v41) {
                  goto LABEL_60;
                }
              }
              __int16 v48 = "Write";
              __int16 v49 = 213;
              goto LABEL_74;
            }
LABEL_60:
            if (v42)
            {
              while (1)
              {
                if (v42 >= 0x20000) {
                  unint64_t v47 = 0x20000;
                }
                else {
                  unint64_t v47 = v42;
                }
                if (BufferDecoderRead((int *)&v64, (uint64_t)v26, v47) != v47)
                {
                  __int16 v48 = "Truncated lit stream";
                  __int16 v49 = 223;
                  goto LABEL_74;
                }
                v40 += v47;
                if (v40 > v62)
                {
                  __int16 v48 = "invalid patch, output after buffer";
                  __int16 v49 = 224;
                  goto LABEL_74;
                }
                if (OBufferedStreamWrite((unint64_t **)v37, v26, v47) != v47) {
                  break;
                }
                v42 -= v47;
                if (!v42) {
                  goto LABEL_68;
                }
              }
              __int16 v48 = "Write";
              __int16 v49 = 225;
              goto LABEL_74;
            }
LABEL_68:
            v39 += v61.i64[0];
            size_t v38 = BufferDecoderRead((int *)&c, (uint64_t)&v79, 24);
            if ((v38 & 0x8000000000000000) != 0) {
              goto LABEL_69;
            }
          }
          if (v38)
          {
            __int16 v48 = "Truncated control stream";
            __int16 v49 = 198;
          }
          else
          {
            if (v40 == v62)
            {
              unsigned int v53 = 0;
              goto LABEL_76;
            }
            __int16 v48 = "Number of written bytes and expected output size do not match";
            __int16 v49 = 235;
          }
        }
      }
      else
      {
        __int16 v48 = "OBufferedStream creation";
        __int16 v49 = 189;
      }
LABEL_74:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch4.c", (uint64_t)"BXPatch4", v49, 51, 0, v48, v35, v36, v61.i8[0]);
      goto LABEL_75;
    }
    uint64_t v51 = "BufferDecoderInit";
    __int16 v52 = 186;
    int v50 = 0;
  }
  else
  {
    int v50 = *__error();
    uint64_t v51 = "malloc";
    __int16 v52 = 177;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch4.c", (uint64_t)"BXPatch4", v52, 51, v50, v51, v33, v34, v61.i8[0]);
  int v37 = 0;
LABEL_75:
  unsigned int v53 = -1;
LABEL_76:
  free(v26);
  BufferDecoderDestroy(&c);
  BufferDecoderDestroy(md);
  BufferDecoderDestroy(&v64);
  OBufferedStreamDestroy((void ***)v37, v54, v55, v56, v57, v58, v59, v60);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0) {
    return v53;
  }
  else {
    return result;
  }
}

uint64_t BufferDecoderInit(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)a1 = a2;
  BOOL v5 = (bz_stream *)(a1 + 24);
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a4;
  if (a2)
  {
    if (lzma_auto_decoder()) {
      return 0xFFFFFFFFLL;
    }
  }
  else if (BZ2_bzDecompressInit(v5, 0, 0))
  {
    return 0xFFFFFFFFLL;
  }
  return 0;
}

size_t BufferDecoderRead(int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *((void *)a1 + 2);
  if (!v3) {
    return 0;
  }
  int v7 = *a1;
  uint64_t v6 = (bz_stream *)(a1 + 6);
  *((void *)a1 + 6) = a2;
  if (v7)
  {
    *((void *)a1 + 7) = a3;
    *((void *)a1 + 3) = *((void *)a1 + 1);
    *((void *)a1 + 4) = v3;
    unsigned int v8 = lzma_code();
    unsigned int v11 = v8;
    uint64_t v12 = *((void *)a1 + 4);
    *((void *)a1 + 1) = *((void *)a1 + 3);
    *((void *)a1 + 2) = v12;
    if (v8 <= 0xA && ((1 << v8) & 0x403) != 0) {
      size_t result = *((void *)a1 + 6) - a2;
    }
    else {
      size_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch4.c", (uint64_t)"BufferDecoderRead", 106, 51, 0, "lzma_code error %d\n", v9, v10, v8);
    }
    if (v11 > 0xA || ((1 << v11) & 0x403) == 0) {
      return -1;
    }
  }
  else
  {
    a1[14] = a3;
    *((void *)a1 + 3) = *((void *)a1 + 1);
    a1[8] = v3;
    int v14 = BZ2_bzDecompress(v6);
    uint64_t v17 = a1[8];
    *((void *)a1 + 1) = *((void *)a1 + 3);
    *((void *)a1 + 2) = v17;
    if ((v14 & 0xFFFFFFFB) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch4.c", (uint64_t)"BufferDecoderRead", 118, 51, 0, "BZ2_bzDecompress error %d\n", v15, v16, v14);
      return -1;
    }
    return *((void *)a1 + 6) - a2;
  }
  return result;
}

uint64_t BufferDecoderDestroy(_DWORD *a1)
{
  int v2 = *a1;
  size_t v1 = (bz_stream *)(a1 + 6);
  if (v2) {
    return lzma_end();
  }
  else {
    return BZ2_bzDecompressEnd(v1);
  }
}

uint64_t transcodeIThreadProc()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v59 = *MEMORY[0x263EF8340];
  size_t v1 = *(unsigned int **)(v0 + 16);
  uint64_t v2 = *(void *)v0;
  unsigned int v3 = ArchiveTreeSize(v1);
  unsigned int v4 = *(_DWORD *)(v2 + 16);
  uint64_t v10 = (unint64_t *)MemBufferCreate(0x10000uLL);
  if (!v10)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"transcodeIThreadProc", 47, 65, 0, "creating mem buffer", v8, v9, v50);
    unsigned int v11 = 0;
    goto LABEL_36;
  }
  if (!v3)
  {
    int v52 = 0;
    unsigned int v11 = 0;
LABEL_25:
    SharedBufferWrite(*(void *)(v0 + 24), 0, 0, v5, v6, v7, v8, v9);
    if (*(int *)v2 >= 2) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "%12u archive stream switches\n", v52);
    }
    goto LABEL_37;
  }
  unsigned int v11 = 0;
  unsigned int v12 = 0;
  int v52 = 0;
  int v13 = -1;
  while (1)
  {
    unint64_t v53 = 0;
    unint64_t v54 = 0;
    unsigned int v14 = ArchiveTreeNodeArchiveID((uint64_t)v1, v12);
    if (v14 >= v4)
    {
      int64_t v40 = "invalid archive ID";
      __int16 v41 = 54;
      goto LABEL_35;
    }
    unsigned int v15 = v14;
    if ((ArchiveTreeNodeSegment((uint64_t)v1, v12, &v54, &v53) & 0x80000000) != 0)
    {
      int64_t v40 = "get entry segment";
      __int16 v41 = 55;
      goto LABEL_35;
    }
    unint64_t v20 = v54;
    if (v54 != -1 && v53 != -1) {
      break;
    }
    if (ArchiveTreeNodeEntryType((uint64_t)v1, v12) != 68)
    {
      int64_t v40 = "non-directory entry not found in any archive";
      __int16 v41 = 60;
      goto LABEL_35;
    }
    bzero(v58, 0x800uLL);
    bzero(v56, 0x888uLL);
    uint64_t v55 = 0x4400008011;
    v56[3] = 493;
    if (ArchiveTreeNodePath((uint64_t)v1, v12, (uint64_t)&v57, 0x400uLL) < 0)
    {
      int64_t v40 = "getting entry path";
      __int16 v41 = 71;
      goto LABEL_35;
    }
    unint64_t v23 = yaa_encodeHeader((uint64_t)v58, 0x800uLL, (int *)&v55, 0, 0, v22, v8, v9);
    if ((v23 & 0x8000000000000000) != 0)
    {
      int64_t v40 = "encoding directory entry";
      __int16 v41 = 73;
      goto LABEL_35;
    }
    if (SharedBufferWrite(*(void *)(v0 + 24), (uint64_t)v58, v23, v24, v25, v26, v8, v9) < 0)
    {
      int64_t v40 = "writing dir entry";
      __int16 v41 = 77;
      goto LABEL_35;
    }
LABEL_21:
    if (v3 == ++v12) {
      goto LABEL_25;
    }
  }
  if (v15 == v13)
  {
LABEL_19:
    if (ParallelCompressionFileSeek((uint64_t)v11, v20, 0, v17, v18, v19, v8, v9) < 0)
    {
      int64_t v40 = "seeking compressed stream";
      __int16 v41 = 93;
      goto LABEL_35;
    }
    if (MemBufferTransmit(v10, v53, (size_t (*)(int, void *, size_t))pcFileRead, (uint64_t)v11, (uint64_t (*)(uint64_t, uint64_t, uint64_t))SharedBufferWrite, *(void *)(v0 + 24), v8, v9) < 0)
    {
      int64_t v40 = "transmitting entry payload";
      __int16 v41 = 94;
      goto LABEL_35;
    }
    goto LABEL_21;
  }
  ParallelCompressionFileClose(v11, v54, v16, v17, v18, v19, v8, v9);
  unsigned int v11 = ParallelCompressionFileOpen(*(const char **)(*(void *)(v2 + 24) + 24 * v15), "r,c=2", v27, v28, v29, v30, v31, v32);
  if (v11)
  {
    ++v52;
    unint64_t v20 = v54;
    int v13 = v15;
    goto LABEL_19;
  }
  int64_t v40 = "creating compressed stream";
  __int16 v41 = 88;
LABEL_35:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"transcodeIThreadProc", v41, 65, 0, v40, v8, v9, v50);
LABEL_36:
  *(_DWORD *)(v0 + 36) = 0;
  SharedBufferAbort(*(void *)(v0 + 24), v33, v34, v35, v36, v37, v38, v39, v51);
LABEL_37:
  MemBufferDestroy((void **)v10);
  ParallelCompressionFileClose(v11, v42, v43, v44, v45, v46, v47, v48);
  return v0;
}

size_t transcodeOThreadBeginProc(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  unsigned int v8 = *(_DWORD *)(a1 + 32);
  if (v8 >= ArchiveTreeSize(*(unsigned int **)(a1 + 16)))
  {
    unsigned int v14 = "invalid entry index";
    __int16 v15 = 119;
  }
  else
  {
    memcpy(__dst, a2, sizeof(__dst));
    if ((__dst[1] & 0x80) != 0
      && ArchiveTreeNodePath(*(void *)(a1 + 16), *(_DWORD *)(a1 + 32), (uint64_t)&__dst[144], 0x400uLL) < 0)
    {
      unsigned int v14 = "getting new entry path";
      __int16 v15 = 128;
    }
    else
    {
      size_t result = ParallelArchiveWriteEntryHeader(*(void *)(a1 + 8), (uint64_t)__dst, a3, a4, v11, v12, v9, v10);
      if ((result & 0x80000000) == 0) {
        return result;
      }
      unsigned int v14 = "writing entry header";
      __int16 v15 = 133;
    }
  }
  size_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"transcodeOThreadBeginProc", v15, 65, 0, v14, v9, v10, v16);
  *(_DWORD *)(a1 + 36) = 0;
  return result;
}

uint64_t transcodeOThreadEndProc(uint64_t result)
{
  return result;
}

size_t transcodeOThreadPayloadProc(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t result = ParallelArchiveWriteEntryData(*(void *)(a1 + 8), a2, a3, a4, a5, a6, a7, a8);
  if ((result & 0x80000000) != 0)
  {
    size_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"transcodeOThreadPayloadProc", 146, 65, 0, "writing entry data", v10, v11, v12);
    *(_DWORD *)(a1 + 36) = 0;
  }
  return result;
}

uint64_t transcodeOThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v23 = 0u;
  long long v24 = 0u;
  uint64_t v25 = 0;
  uint64_t v26 = a1;
  *(_DWORD *)(a1 + ++*(_DWORD *)(result + 32) = 0;
  v22[0] = 0x100000000;
  uint64_t v9 = *(void *)(a1 + 24);
  v22[1] = SharedBufferRead;
  v22[2] = SharedBufferAbort;
  v22[3] = v9;
  v22[4] = transcodeOThreadBeginProc;
  *((void *)&v24 + 1) = transcodeOThreadEndProc;
  *((void *)&v23 + 1) = transcodeOThreadPayloadProc;
  if ((ParallelArchiveRead((uint64_t)v22, a2, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"transcodeOThreadProc", 169, 65, 0, "reading aggregated entries", v10, v11, v20);
    *(_DWORD *)(a1 + 36) = 0;
    SharedBufferAbort(*(void *)(a1 + 24), v12, v13, v14, v15, v16, v17, v18, v21);
  }
  return a1;
}

uint64_t ParallelArchiveCombine()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v3 = v0;
  uint64_t v126 = *MEMORY[0x263EF8340];
  enterThreadErrorContext(v0, v1, v4, v5, v6, v7, v8, v9, v75);
  uint64_t v10 = *(void *)(v2 + 16);
  pthread_t v89 = 0;
  pthread_t v90 = 0;
  uint64_t v88 = 0;
  long long v86 = 0u;
  long long v87 = 0u;
  uint64_t v11 = ArchiveTreeCreateWithRootEntry();
  uint64_t v14 = v11;
  if (!v11)
  {
    uint64_t v38 = "empty tree creation";
    __int16 v39 = 198;
    goto LABEL_35;
  }
  uint64_t v77 = v3;
  int v78 = v10;
  if (!v10)
  {
    long long v84 = 0;
    size_t v16 = 0;
    goto LABEL_37;
  }
  uint64_t v15 = 0;
  size_t v16 = 0;
  long long v84 = 0;
  size_t v85 = 0;
  uint64_t v79 = v10;
  uint64_t v17 = MEMORY[0x263EF8318];
  uint64_t v80 = (int *)v2;
  uint64_t v81 = (uint64_t)v11;
  do
  {
    uint64_t v18 = *(void *)(v2 + 24);
    bzero(__s, 0x800uLL);
    uint64_t v82 = (const char **)(v18 + 24 * v15);
    uint64_t v19 = IFileStreamCreateWithFilename(*v82, 0, -1);
    if (!v19)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"ParallelArchiveCombine", 207, 65, 0, "opening archive file: %s", v20, v21, (char)*v82);
      goto LABEL_73;
    }
    uint64_t v22 = (char *)v19;
    long long v23 = ArchiveTreeCreateFromArchive((uint64_t)IFileStreamRead, v19, *(_DWORD *)(v2 + 4));
    IFileStreamDestroy(v22);
    if (!v23)
    {
      long long v76 = *v82;
      long long v70 = "reading archive tree: %s";
      __int16 v71 = 211;
LABEL_71:
      int v72 = 0;
      goto LABEL_72;
    }
    if ((ArchiveTreePrune(v23, *(_DWORD *)(v18 + 24 * v15 + 8)) & 0x80000000) != 0)
    {
      long long v76 = *v82;
      long long v70 = "pruning entries: %s (%d)";
      __int16 v71 = 214;
      goto LABEL_71;
    }
    if ((ArchiveTreeInsert((uint64_t)v23, *(char **)(v18 + 24 * v15 + 16)) & 0x80000000) != 0)
    {
      long long v76 = *v82;
      long long v70 = "inserting path to entries: %s (%s)";
      __int16 v71 = 215;
      goto LABEL_71;
    }
    unsigned int v26 = ArchiveTreeSize(v23);
    ArchiveTreeYAF((size_t)v23, __s, 0x800uLL);
    uint64_t v27 = v84;
    if (!v85)
    {
      size_t v85 = (strlen(__s) >> 1) + 1;
      uint64_t v27 = (char *)calloc(v85, 8uLL);
      if (v27)
      {
        size_t v16 = 0;
        goto LABEL_11;
      }
      int v72 = *__error();
      long long v70 = "malloc";
      __int16 v71 = 226;
LABEL_72:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"ParallelArchiveCombine", v71, 65, v72, v70, v24, v25, (char)v76);
      uint64_t v14 = (unsigned int *)v81;
      goto LABEL_73;
    }
LABEL_11:
    long long v83 = v23;
    long long v84 = v27;
    uint64_t v28 = 0;
    uint64_t v29 = v27 + 4;
    do
    {
      for (uint64_t i = 0; ; ++i)
      {
        unsigned int v31 = __s[v28 + i];
        if ((v31 & 0x80000000) != 0) {
          break;
        }
        if ((*(_DWORD *)(v17 + 4 * v31 + 60) & 0x100) == 0) {
          goto LABEL_18;
        }
LABEL_17:
        ;
      }
      if (__maskrune(__s[v28 + i], 0x100uLL)) {
        goto LABEL_17;
      }
LABEL_18:
      if (v15)
      {
        if (v16)
        {
          size_t v32 = v16;
          uint64_t v33 = v29;
          while (((*(_DWORD *)&__s[v28] ^ *(v33 - 1)) & 0xDFDFDF) != 0)
          {
            v33 += 2;
            if (!--v32) {
              goto LABEL_28;
            }
          }
          ++*v33;
        }
      }
      else if (v16 < v85 && i == 3)
      {
        __int16 v34 = *(_WORD *)&__s[v28];
        uint64_t v35 = &v84[8 * v16];
        v35[2] = __s[v28 + 2];
        *(_WORD *)uint64_t v35 = v34;
        *((_DWORD *)v35 + 1) = 1;
        ++v16;
      }
LABEL_28:
      v28 += i + 1;
    }
    while (v31);
    uint64_t v2 = (uint64_t)v80;
    if (*v80 >= 1) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "%12u entries merged from %s\n", v26, *v82);
    }
    uint64_t v14 = (unsigned int *)v81;
    if ((ArchiveTreeMergeAndDestroy(v81, v83, v15) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"ParallelArchiveCombine", 265, 65, 0, "merging archive tree: %s", v36, v37, (char)*v82);
      goto LABEL_73;
    }
    ++v15;
  }
  while (v15 != v79);
LABEL_37:
  unsigned int v40 = ArchiveTreeSize(v14);
  if (*(int *)v2 >= 1)
  {
    unsigned int v41 = v40;
    uint64_t v42 = (FILE **)MEMORY[0x263EF8348];
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12u input archives\n", v78);
    fprintf(*v42, "%12u unique entries\n", v41);
  }
  bzero(v125, 0x800uLL);
  bzero(v124, 0x800uLL);
  long long v123 = 0u;
  long long v122 = 0u;
  long long v121 = 0u;
  long long v120 = 0u;
  long long v119 = 0u;
  long long v118 = 0u;
  long long v117 = 0u;
  long long v116 = 0u;
  long long v115 = 0u;
  long long v114 = 0u;
  long long v113 = 0u;
  long long v112 = 0u;
  long long v111 = 0u;
  long long v110 = 0u;
  long long v109 = 0u;
  long long v108 = 0u;
  long long v107 = 0u;
  long long v106 = 0u;
  long long v105 = 0u;
  long long v104 = 0u;
  long long v103 = 0u;
  long long v102 = 0u;
  long long v101 = 0u;
  long long v100 = 0u;
  long long v99 = 0u;
  long long v98 = 0u;
  long long v97 = 0u;
  long long v96 = 0u;
  long long v95 = 0u;
  long long v94 = 0u;
  long long v93 = 0u;
  *(_OWORD *)__s = 0u;
  memset(v91, 0, 512);
  uint64_t v43 = v84;
  for (size_t j = 0; v16; --v16)
  {
    if ((*(_DWORD *)v43 & 0xDFDFDF) == 0x505954 || *((_DWORD *)v43 + 1) == v78)
    {
      if (j - 2045 <= 0xFFFFFFFFFFFFF7FELL)
      {
        uint64_t v38 = "too many YAF fields";
        __int16 v39 = 290;
        goto LABEL_35;
      }
      if (j)
      {
        size_t v45 = j + 1;
        v125[j] = 44;
      }
      else
      {
        size_t v45 = 0;
      }
      uint64_t v46 = &v125[v45];
      __int16 v47 = *(_WORD *)v43;
      v46[2] = v43[2];
      *(_WORD *)uint64_t v46 = v47;
      size_t j = v45 + 3;
      v125[v45 + 3] = 0;
    }
    v43 += 8;
  }
  bzero(&__s[8], 0x888uLL);
  *(void *)__s = 0x4D00000001;
  bzero((char *)v91 + 3, 0x405uLL);
  qmemcpy(v91, "YAF", 3);
  DWORD1(v91[0]) = 2;
  *((void *)&v91[0] + 1) = j;
  uint64_t v51 = yaa_encodeHeader((uint64_t)v124, 0x800uLL, (int *)__s, (uint64_t)v91, 1uLL, v48, v49, v50);
  if (v51 < 0)
  {
    uint64_t v38 = "encoding metadata entry";
    __int16 v39 = 306;
    goto LABEL_35;
  }
  uint64_t v52 = v51;
  if (2048 - v51 < j)
  {
    uint64_t v38 = "encoding metadata entry";
    __int16 v39 = 309;
    goto LABEL_35;
  }
  memcpy(&v124[v51], v125, j);
  uint64_t v57 = v52 + j;
  if (*(int *)v2 >= 1) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "Output fields: %s\n", v125);
  }
  if ((yaa_writeRawEntryHeader(v77, (uint64_t)v124, v57, 0, v53, v54, v55, v56) & 0x80000000) != 0)
  {
    uint64_t v38 = "writing metadata entry";
    __int16 v39 = 317;
LABEL_35:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"ParallelArchiveCombine", v39, 65, 0, v38, v12, v13, (char)v76);
LABEL_73:
    int v63 = 0;
    goto LABEL_74;
  }
  *((void *)&v87 + 1) = SharedBufferCreate(0x10000uLL, v58, v59, v60, v61, v62, v12, v13);
  if (!*((void *)&v87 + 1))
  {
    uint64_t v38 = "allocating shared buffer";
    __int16 v39 = 322;
    goto LABEL_35;
  }
  *(void *)&long long v86 = v2;
  *((void *)&v86 + 1) = v77;
  *(void *)&long long v87 = v14;
  int v63 = 1;
  HIDWORD(v88) = 1;
  if ((createThread(&v90, (uint64_t)transcodeIThreadProc, (uint64_t)&v86, 0) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"ParallelArchiveCombine", 329, 65, 0, "running transcoder I thread", v64, v65, (char)v76);
    int v63 = 0;
  }
  if ((createThread(&v89, (uint64_t)transcodeOThreadProc, (uint64_t)&v86, 0) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"ParallelArchiveCombine", 330, 65, 0, "running transcoder O thread", v66, v67, (char)v76);
    int v63 = 0;
  }
  if ((joinThread(v89) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"ParallelArchiveCombine", 331, 65, 0, "waiting for O thread", v68, v69, (char)v76);
    int v63 = 0;
  }
  if ((joinThread(v90) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"ParallelArchiveCombine", 332, 65, 0, "waiting for I thread", v12, v13, (char)v76);
    int v63 = 0;
  }
  if (!HIDWORD(v88))
  {
    uint64_t v38 = "transcoding";
    __int16 v39 = 333;
    goto LABEL_35;
  }
LABEL_74:
  ArchiveTreeDestroy((uint64_t)v14);
  SharedBufferDestroy(*((uint64_t *)&v87 + 1));
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (v63) {
    unsigned int v74 = 0;
  }
  else {
    unsigned int v74 = -1;
  }
  if ((int)result >= 0) {
    return v74;
  }
  else {
    return result;
  }
}

uint64_t MemGateReserve(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)a1))
  {
    uint64_t v6 = "MutexLock";
    __int16 v7 = 95;
    goto LABEL_28;
  }
  int v9 = *(_DWORD *)(a1 + 212);
  if (v9) {
    goto LABEL_6;
  }
  uint64_t v16 = *(void *)(a1 + 184);
  int v17 = *(_DWORD *)(a1 + 192);
  BOOL v18 = v16 < a2;
  uint64_t v19 = v16 - a2;
  if (!v18)
  {
    int v20 = v17 + 1;
LABEL_17:
    uint64_t v14 = 0;
    *(void *)(a1 + 184) = v19;
    *(_DWORD *)(a1 + 192) = v20;
    goto LABEL_18;
  }
  if (!v17)
  {
    int v20 = 1;
    goto LABEL_17;
  }
LABEL_6:
  int v10 = *(_DWORD *)(a1 + 208);
  if (v9 == v10
    || ((*(_DWORD *)(a1 + 212) = v9 + 1, uint64_t v11 = *(void *)(a1 + 200), v12 = *(int *)(a1 + 220), v12 + 1 != v10)
      ? (int v13 = v12 + 1)
      : (int v13 = 0),
        *(_DWORD *)(a1 + 220) = v13,
        !v11))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateReserve", 114, 18, 0, "MemGateAllocateRequest", v4, v5, v22);
    uint64_t v14 = 0;
    int v15 = 0;
    goto LABEL_19;
  }
  uint64_t v14 = v11 + (v12 << 7);
  *(void *)(v14 + 120) = a2;
LABEL_18:
  int v15 = 1;
LABEL_19:
  if (pthread_mutex_unlock((pthread_mutex_t *)a1))
  {
    uint64_t v6 = "MutexUnlock";
    __int16 v7 = 123;
  }
  else
  {
    if (!v14) {
      goto LABEL_29;
    }
    if (pthread_mutex_lock((pthread_mutex_t *)(v14 + 8))) {
      goto LABEL_27;
    }
    while (*(int *)v14 <= 0)
    {
      if (pthread_cond_wait((pthread_cond_t *)(v14 + 72), (pthread_mutex_t *)(v14 + 8))) {
        goto LABEL_27;
      }
    }
    --*(_DWORD *)v14;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8)))
    {
LABEL_27:
      uint64_t v6 = "SemAcquire";
      __int16 v7 = 129;
    }
    else
    {
      if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 72)))
      {
        int v21 = *(_DWORD *)(a1 + 64);
        *(_DWORD *)(a1 + 64) = v21 + 1;
        if ((v21 || !pthread_cond_broadcast((pthread_cond_t *)(a1 + 136)))
          && !pthread_mutex_unlock((pthread_mutex_t *)(a1 + 72)))
        {
          goto LABEL_29;
        }
      }
      uint64_t v6 = "SemRelease";
      __int16 v7 = 136;
    }
  }
LABEL_28:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateReserve", v7, 18, 0, v6, v4, v5, v22);
  int v15 = 0;
LABEL_29:
  if (v15) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t MemGateFree(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)a1))
  {
    uint64_t v6 = "MutexLock";
    __int16 v7 = 154;
  }
  else
  {
    *(void *)(a1 + 184) += a2;
    --*(_DWORD *)(a1 + 192);
    if (*(_DWORD *)(a1 + 212))
    {
      while (1)
      {
        uint64_t v9 = *(void *)(a1 + 200);
        if (!v9) {
          goto LABEL_26;
        }
        uint64_t v10 = v9 + ((uint64_t)*(int *)(a1 + 216) << 7);
        uint64_t v11 = *(void *)(a1 + 184);
        uint64_t v12 = *(void *)(v10 + 120);
        int v13 = *(_DWORD *)(a1 + 192);
        BOOL v14 = v11 < v12;
        uint64_t v15 = v11 - v12;
        if (v14 && v13 != 0) {
          goto LABEL_26;
        }
        *(void *)(a1 + 184) = v15;
        *(_DWORD *)(a1 + 192) = v13 + 1;
        if (pthread_mutex_lock((pthread_mutex_t *)(v10 + 8))) {
          break;
        }
        if (!(*(_DWORD *)v10)++)
        {
          if (pthread_cond_broadcast((pthread_cond_t *)(v10 + 72))) {
            break;
          }
        }
        if (pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8))) {
          break;
        }
        if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 72))) {
          goto LABEL_27;
        }
        while (1)
        {
          int v20 = *(_DWORD *)(a1 + 64);
          if (v20 > 0) {
            break;
          }
          if (pthread_cond_wait((pthread_cond_t *)(a1 + 136), (pthread_mutex_t *)(a1 + 72))) {
            goto LABEL_27;
          }
        }
        *(_DWORD *)(a1 + 64) = v20 - 1;
        if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 72)))
        {
LABEL_27:
          unsigned int v26 = "SemAcquire";
          __int16 v27 = 177;
LABEL_28:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateFree", v27, 18, 0, v26, v17, v18, v28);
          int v25 = 0;
          goto LABEL_29;
        }
        int v21 = *(_DWORD *)(a1 + 212);
        if (v21)
        {
          int v22 = v21 - 1;
          int v23 = *(_DWORD *)(a1 + 216);
          int v24 = v23 + 1 == *(_DWORD *)(a1 + 208) ? 0 : v23 + 1;
          *(_DWORD *)(a1 + 212) = v22;
          *(_DWORD *)(a1 + 216) = v24;
          if (v22) {
            continue;
          }
        }
        goto LABEL_26;
      }
      unsigned int v26 = "SemRelease";
      __int16 v27 = 176;
      goto LABEL_28;
    }
LABEL_26:
    int v25 = 1;
LABEL_29:
    if (!pthread_mutex_unlock((pthread_mutex_t *)a1)) {
      goto LABEL_32;
    }
    uint64_t v6 = "MutexUnlock";
    __int16 v7 = 188;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateFree", v7, 18, 0, v6, v4, v5, v28);
  int v25 = 0;
LABEL_32:
  if (v25) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t MemGateDestroy(pthread_mutex_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void **)a1[3].__opaque;
  if (v9)
  {
    if (*(int *)&a1[3].__opaque[8] < 1)
    {
      int v11 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      uint64_t v12 = 72;
      do
      {
        int v13 = (pthread_cond_t *)(*(void *)a1[3].__opaque + v12);
        if (pthread_mutex_destroy((pthread_mutex_t *)&v13[-2].__opaque[24]) || pthread_cond_destroy(v13))
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateDestroy", 205, 18, 0, "SemDestroy", v14, v15, v21);
          int v11 = 0;
        }
        ++v10;
        v12 += 128;
      }
      while (v10 < *(int *)&a1[3].__opaque[8]);
      uint64_t v9 = *(void **)a1[3].__opaque;
    }
    free(v9);
    *(void *)a1[3].__opaque = 0;
  }
  else
  {
    int v11 = 1;
  }
  if (*(int *)&a1[3].__opaque[8] >= 1)
  {
    if (LODWORD(a1[3].__sig))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateDestroy", 216, 18, 0, "memory leak", a7, a8, v21);
      int v11 = 0;
    }
    if (*(_DWORD *)&a1[3].__opaque[12])
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateDestroy", 217, 18, 0, "pending requests", a7, a8, v21);
      int v11 = 0;
    }
    if (pthread_mutex_destroy(a1))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateDestroy", 218, 18, 0, "MutexDestroy", v16, v17, v21);
      int v11 = 0;
    }
    if (pthread_mutex_destroy((pthread_mutex_t *)((char *)a1 + 72))
      || pthread_cond_destroy((pthread_cond_t *)a1[2].__opaque))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateDestroy", 219, 18, 0, "SemDestroy", v18, v19, v21);
      int v11 = 0;
    }
  }
  *(_OWORD *)&a1[3].__int sig = 0u;
  *(_OWORD *)&a1[3].__opaque[8] = 0u;
  *(_OWORD *)&a1[2].__opaque[24] = 0u;
  *(_OWORD *)&a1[2].__opaque[40] = 0u;
  *(_OWORD *)&a1[2].__int sig = 0u;
  *(_OWORD *)&a1[2].__opaque[8] = 0u;
  *(_OWORD *)&a1[1].__opaque[24] = 0u;
  *(_OWORD *)&a1[1].__opaque[40] = 0u;
  *(_OWORD *)&a1[1].__int sig = 0u;
  *(_OWORD *)&a1[1].__opaque[8] = 0u;
  *(_OWORD *)&a1->__opaque[24] = 0u;
  *(_OWORD *)&a1->__opaque[40] = 0u;
  if (v11) {
    uint64_t result = 0;
  }
  else {
    uint64_t result = 0xFFFFFFFFLL;
  }
  *(_OWORD *)&a1->__int sig = 0uLL;
  *(_OWORD *)&a1->__opaque[8] = 0uLL;
  return result;
}

uint64_t MemGateInit(pthread_mutex_t *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_OWORD *)&a1[3].__int sig = 0u;
  *(_OWORD *)&a1[3].__opaque[8] = 0u;
  *(_OWORD *)&a1[2].__opaque[24] = 0u;
  *(_OWORD *)&a1[2].__opaque[40] = 0u;
  *(_OWORD *)&a1[2].__int sig = 0u;
  *(_OWORD *)&a1[2].__opaque[8] = 0u;
  *(_OWORD *)&a1[1].__opaque[24] = 0u;
  *(_OWORD *)&a1[1].__opaque[40] = 0u;
  *(_OWORD *)&a1[1].__int sig = 0u;
  *(_OWORD *)&a1[1].__opaque[8] = 0u;
  *(_OWORD *)&a1->__opaque[24] = 0u;
  *(_OWORD *)&a1->__opaque[40] = 0u;
  *(_OWORD *)&a1->__int sig = 0u;
  *(_OWORD *)&a1->__opaque[8] = 0u;
  if (a3 <= 0)
  {
    int v11 = "bad # of allocation requests";
    __int16 v12 = 236;
  }
  else if (pthread_mutex_init(a1, 0))
  {
    int v11 = "MutexInit";
    __int16 v12 = 239;
  }
  else
  {
    LODWORD(a1[1].__sig) = 0;
    if (pthread_mutex_init((pthread_mutex_t *)((char *)a1 + 72), 0)
      || pthread_cond_init((pthread_cond_t *)a1[2].__opaque, 0))
    {
      int v11 = "SemInit";
      __int16 v12 = 240;
    }
    else
    {
      *(void *)&a1[2].__opaque[48] = a2;
      LODWORD(a1[3].__sig) = 0;
      *(_DWORD *)&a1[3].__opaque[8] = a3;
      *(_DWORD *)&a1[3].__opaque[12] = 0;
      *(void *)&a1[3].__opaque[16] = 0;
      int v22 = calloc(a3, 0x80uLL);
      *(void *)a1[3].__opaque = v22;
      if (!v22)
      {
        int v13 = *__error();
        int v11 = "calloc";
        __int16 v12 = 250;
        goto LABEL_9;
      }
      uint64_t v23 = 0;
      unint64_t v24 = (unint64_t)a3 << 7;
      while (1)
      {
        uint64_t v25 = *(void *)a1[3].__opaque;
        *(_DWORD *)(v25 + v23) = 0;
        if (pthread_mutex_init((pthread_mutex_t *)(v25 + v23 + 8), 0)) {
          break;
        }
        uint64_t result = pthread_cond_init((pthread_cond_t *)(v25 + v23 + 72), 0);
        if (result) {
          break;
        }
        *(void *)(v25 + v23 + 120) = 0;
        v23 += 128;
        if (v24 == v23) {
          return result;
        }
      }
      int v11 = "SemInit";
      __int16 v12 = 257;
    }
  }
  int v13 = 0;
LABEL_9:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateInit", v12, 18, v13, v11, a7, a8, v26);
  MemGateDestroy(a1, v14, v15, v16, v17, v18, v19, v20);
  return 0xFFFFFFFFLL;
}

uint64_t loadDirectoryThreadProc(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void **)(a1 + 8);
  unint64_t v2 = *(void *)(a1 + 16);
  if (v2 >= v1[1]) {
    return 0;
  }
  while (1)
  {
    uint64_t v4 = (const char *)(v1[5] + *(void *)(v1[2] + 184 * v2));
    if ((concatPath(v17, 0x400uLL, *(char **)a1, v4) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectoryThreadProc", 1064, 18, 0, "getting full path: %s", v5, v6, (char)v4);
      return 0xFFFFFFFFLL;
    }
    uint64_t v1 = *(void **)(a1 + 8);
    if ((*(_DWORD *)(v1[2] + 184 * v2 + 56) - 1) > 2) {
      goto LABEL_12;
    }
    uint64_t v7 = *(unsigned int *)(a1 + 32);
    uint64_t FileDiskUsage = getFileDiskUsage(v17);
    uint64_t v11 = FileDiskUsage >= 0 ? (FileDiskUsage + (v7 - 1)) & -v7 : FileDiskUsage;
    uint64_t v1 = *(void **)(a1 + 8);
    uint64_t v12 = v1[2];
    if ((v11 & 0x8000000000000000) == 0) {
      break;
    }
    if (*(_DWORD *)(v12 + 184 * v2 + 56) == 1)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectoryThreadProc", 1078, 18, 0, "getting disk usage: %s", v9, v10, (char)v17);
      return 0xFFFFFFFFLL;
    }
LABEL_12:
    v2 += *(void *)(a1 + 24);
    if (v2 >= v1[1]) {
      return 0;
    }
  }
  uint64_t v13 = v12 + 184 * v2;
  *(void *)(v13 + 152) = v11;
  if (*(_DWORD *)(v13 + 56) != 1) {
    goto LABEL_12;
  }
  if ((getFileSHA1Digest(v17, v12 + 184 * v2 + 128) & 0x80000000) == 0)
  {
    uint64_t v1 = *(void **)(a1 + 8);
    goto LABEL_12;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectoryThreadProc", 1085, 18, 0, "getting SHA1 digest: %s", v14, v15, (char)v17);
  return 0xFFFFFFFFLL;
}

uint64_t InoTableEntryCmpProc(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  if (*a2 < *a1) {
    return 1;
  }
  unint64_t v3 = a1[1];
  unint64_t v4 = a2[1];
  if (v3 < v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v4 < v3;
  }
}

uint64_t loadDirectory(char *a1, signed int DefaultNThreads, size_t a3)
{
  *(void *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + ++*(_DWORD *)(result + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  size_t v6 = strlen(a1);
  do
  {
    size_t v7 = v6;
    if (!v6) {
      break;
    }
    --v6;
  }
  while (a1[v7 - 1] == 47);
  v75[0] = v7;
  v75[1] = a3;
  if (!DefaultNThreads) {
    int DefaultNThreads = getDefaultNThreads();
  }
  if ((loadDirectoryProc(v75, a1) & 0x80000000) != 0)
  {
    char v26 = "inserting root dir";
    __int16 v27 = 1132;
    goto LABEL_29;
  }
  v74[1] = 0;
  v74[2] = 0;
  v74[0] = v75;
  v74[3] = loadDirectoryProc;
  if ((enumerateTree(v74, a1) & 0x80000000) != 0)
  {
    char v73 = (char)a1;
    char v26 = "enumerateTree %s";
    __int16 v27 = 1139;
LABEL_29:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectory", v27, 18, 0, v26, v8, v9, v73);
    uint64_t v11 = 0;
LABEL_30:
    LODWORD(v28) = 0;
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    unsigned int v31 = 0;
    goto LABEL_31;
  }
  qsort_r(*(void **)(a3 + 16), *(void *)(a3 + 8), 0xB8uLL, (void *)a3, (int (__cdecl *)(void *, const void *, const void *))DirectoryEntryPathCompareProc);
  char v10 = 0;
  uint64_t v11 = 0;
  char v12 = 1;
  while (1)
  {
    uint64_t v13 = *(void *)(a3 + 8);
    if (!v13) {
      goto LABEL_46;
    }
    size_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = -v13;
    uint64_t v17 = *(void *)(a3 + 16) + 80;
    while (2)
    {
      uint64_t v18 = (int *)(v17 + 184 * v15++);
      while (*(v18 - 6) == 1)
      {
        uint64_t v19 = v15 - 1;
        if ((v12 & 1) == 0)
        {
          if (*(v18 - 14) >= 2)
          {
            if (v10)
            {
              uint64_t v20 = &v11[16 * v14];
              *(void *)uint64_t v20 = *((void *)v18 - 8);
              *((void *)v20 + 1) = v19;
            }
LABEL_20:
            ++v14;
          }
          break;
        }
        *((void *)v18 - 1) = v19;
        *(void *)uint64_t v18 = -1;
        *((void *)v18 + 1) = -1;
        if (*(v18 - 14) >= 2) {
          goto LABEL_20;
        }
        ++v15;
        v18 += 46;
        if (v16 + v15 == 1) {
          goto LABEL_23;
        }
      }
      if (v16 + v15) {
        continue;
      }
      break;
    }
    if ((v12 & 1) == 0) {
      break;
    }
LABEL_23:
    if (!v14) {
      goto LABEL_46;
    }
    uint64_t v11 = (char *)calloc(v14, 0x10uLL);
    char v12 = 0;
    char v10 = 1;
    if (!v11)
    {
      int v21 = *__error();
      unint64_t v24 = "inoTable allocation";
      __int16 v25 = 1171;
LABEL_26:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectory", v25, 18, v21, v24, v22, v23, v73);
      goto LABEL_30;
    }
  }
  if (v14)
  {
    qsort(v11, v14, 0x10uLL, (int (__cdecl *)(const void *, const void *))InoTableEntryCmpProc);
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    unint64_t v40 = *(void *)(a3 + 8);
    uint64_t v41 = -1;
    uint64_t v42 = v11;
    unint64_t v43 = -1;
    while (1)
    {
      unint64_t v44 = v42[1];
      if (!v38 || *(v42 - 2) != *v42)
      {
        uint64_t v39 = 0;
        ++v41;
        unint64_t v43 = v42[1];
      }
      if (v43 >= v40 || v44 >= v40) {
        break;
      }
      size_t v45 = (void *)(*(void *)(a3 + 16) + 184 * v44);
      v45[9] = v43;
      v45[10] = v41;
      v45[11] = v39++;
      ++v38;
      v42 += 2;
      if (v14 == v38) {
        goto LABEL_46;
      }
    }
    unint64_t v24 = "Invalid index in ino table";
    __int16 v25 = 1187;
    int v21 = 0;
    goto LABEL_26;
  }
LABEL_46:
  uint64_t v46 = DefaultNThreads;
  unsigned int v31 = (char *)calloc(DefaultNThreads, 0x28uLL);
  __int16 v47 = (char *)malloc(8 * DefaultNThreads);
  uint64_t v30 = v47;
  if (v31 && v47)
  {
    if (DefaultNThreads < 1)
    {
      int v72 = ThreadPoolCreate(DefaultNThreads, (uint64_t)v47, (uint64_t)loadDirectoryThreadProc);
      if (v72)
      {
        uint64_t v29 = (uint64_t)v72;
        char v32 = 0;
        LODWORD(v28) = 1;
        goto LABEL_32;
      }
    }
    else
    {
      uint64_t v48 = 0;
      uint64_t v49 = DefaultNThreads;
      uint64_t v50 = v31;
      do
      {
        *(void *)&v47[v48] = v50;
        v48 += 8;
        v50 += 40;
      }
      while (8 * DefaultNThreads != v48);
      uint64_t v51 = ThreadPoolCreate(DefaultNThreads, (uint64_t)v47, (uint64_t)loadDirectoryThreadProc);
      if (v51)
      {
        uint64_t v29 = (uint64_t)v51;
        uint64_t v59 = 0;
        while (1)
        {
          uint64_t Worker = ThreadPoolGetWorker(v29, v52, v53, v54, v55, v56, v57, v58);
          uint64_t v28 = Worker;
          if (!Worker)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectory", 1208, 18, 0, "ThreadPoolGetWorker", v61, v62, v73);
            goto LABEL_31;
          }
          *(void *)uint64_t Worker = a1;
          *(void *)(Worker + 8) = a3;
          *(void *)(Worker + 16) = v59;
          *(void *)(Worker + 24) = v46;
          *(_DWORD *)(Worker + ++*(_DWORD *)(result + 32) = getFilesystemBlockSize(a1);
          if ((ThreadPoolRunWorker(v29, v28, v63, v64, v65, v66, v67, v68) & 0x80000000) != 0) {
            break;
          }
          ++v59;
          LODWORD(v28) = 1;
          if (v49 == v59)
          {
            char v32 = 0;
            goto LABEL_32;
          }
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectory", 1214, 18, 0, "ThreadPoolRunWorker", v57, v58, v73);
        LODWORD(v28) = 0;
        goto LABEL_31;
      }
    }
    long long v70 = "ThreadPoolCreate";
    __int16 v71 = 1201;
    int v69 = 0;
  }
  else
  {
    int v69 = *__error();
    long long v70 = "malloc";
    __int16 v71 = 1198;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectory", v71, 18, v69, v70, v57, v58, v73);
  LODWORD(v28) = 0;
  uint64_t v29 = 0;
LABEL_31:
  char v32 = 1;
LABEL_32:
  unsigned int v33 = ThreadPoolDestroy(v29);
  int v36 = v28 & ~(v33 >> 31);
  if ((v32 & 1) == 0 && (v33 & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectory", 1219, 18, 0, "A LoadDirectory thread reported an error", v34, v35, v73);
    int v36 = 0;
  }
  free(v31);
  free(v30);
  free(v11);
  if (v36) {
    return 0;
  }
  free(*(void **)(a3 + 16));
  BlobBufferFree(a3 + 24);
  *(void *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + ++*(_DWORD *)(result + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  return 0xFFFFFFFFLL;
}

uint64_t loadDirectoryProc(size_t *a1, char *a2)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  size_t v4 = a1[1];
  if (*(void *)(v4 + 8) >= *(void *)v4)
  {
    uint64_t v5 = *(void *)v4 + 0x4000;
    *(void *)size_t v4 = v5;
    size_t v6 = reallocf(*(void **)(v4 + 16), 184 * v5);
    *(void *)(v4 + 16) = v6;
    if (!v6)
    {
      int v9 = *__error();
      char v10 = "reallocf";
      __int16 v11 = 992;
      goto LABEL_23;
    }
  }
  memset(&v25, 0, sizeof(v25));
  if (lstat(a2, &v25))
  {
    int v9 = *__error();
    char v24 = (char)a2;
    char v10 = "%s";
    __int16 v11 = 998;
LABEL_23:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectoryProc", v11, 18, v9, v10, v7, v8, v24);
    return 0xFFFFFFFFLL;
  }
  int v12 = v25.st_mode & 0xF000;
  switch(v12)
  {
    case 16384:
      int v15 = 0;
      int v13 = 0;
      int v14 = 2;
      break;
    case 32768:
      int v15 = 0;
      int v13 = 1;
      int v14 = 1;
      break;
    case 40960:
      int v13 = 0;
      int v14 = 3;
      int v15 = 1;
      break;
    default:
      char v24 = 0;
      char v10 = "Unsupported file type: %07o (%s)";
      __int16 v11 = 1006;
      goto LABEL_22;
  }
  uint64_t v17 = *(void *)(v4 + 8);
  uint64_t v16 = *(void *)(v4 + 16);
  uint64_t v18 = v16 + 184 * v17;
  *(void *)(v4 + 8) = v17 + 1;
  *(void *)(v18 + 176) = 0;
  *(_OWORD *)(v18 + 144) = 0u;
  *(_OWORD *)(v18 + 160) = 0u;
  *(_OWORD *)(v18 + 112) = 0u;
  *(_OWORD *)(v18 + 128) = 0u;
  *(_OWORD *)(v18 + 80) = 0u;
  *(_OWORD *)(v18 + 96) = 0u;
  *(_OWORD *)(v18 + 48) = 0u;
  *(_OWORD *)(v18 + 64) = 0u;
  *(_OWORD *)(v18 + 16) = 0u;
  *(_OWORD *)(v18 + ++*(_DWORD *)(result + 32) = 0u;
  *(_OWORD *)uint64_t v18 = 0u;
  if (strlen(a2) > *a1) {
    uint64_t v19 = &a2[*a1 + 1];
  }
  else {
    uint64_t v19 = (const char *)&unk_2106C9523;
  }
  size_t v20 = strlen(v19);
  if (BlobBufferStore(v4 + 24, v19, v20 + 1, (void *)(v16 + 184 * v17)))
  {
    char v10 = "Storing entry path";
    __int16 v11 = 1018;
LABEL_22:
    int v9 = 0;
    goto LABEL_23;
  }
  if (v15)
  {
    bzero(v26, 0x400uLL);
    ssize_t v21 = readlink(a2, v26, 0x3FFuLL);
    if (v21 < 0)
    {
      int v9 = *__error();
      char v24 = (char)a2;
      char v10 = "%s";
      __int16 v11 = 1024;
      goto LABEL_23;
    }
    v26[v21] = 0;
    if (BlobBufferStore(v4 + 24, v26, v21 + 1, (void *)(v16 + 184 * v17 + 96)))
    {
      char v10 = "Storing symlink path";
      __int16 v11 = 1026;
      goto LABEL_22;
    }
  }
  uint64_t v23 = v16 + 184 * v17;
  *(_DWORD *)(v23 + 56) = v14;
  *(void *)(v23 + 72) = -1;
  *(void *)(v23 + 112) = *(void *)&v25.st_uid;
  *(_DWORD *)(v23 + 120) = v25.st_mode & 0xFFF;
  *(void *)(v23 + 160) = 0x7FFFFFFFLL;
  *(_DWORD *)(v23 + 124) = v25.st_flags;
  *(void *)(v23 + 48) = -1;
  *(void *)(v23 + 16) = v25.st_ino;
  *(_DWORD *)(v23 + 24) = v25.st_nlink;
  uint64_t result = 0;
  if (v13) {
    *(void *)(v16 + 184 * v17 + 64) = v25.st_size;
  }
  return result;
}

uint64_t loadManifest(const char *a1, uint64_t a2)
{
  uint64_t v63 = 0;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v58 = 0u;
  *(void *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + ++*(_DWORD *)(result + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  v55[0] = 0;
  *(_OWORD *)__ptr = 0u;
  uint64_t v57 = 0;
  v55[1] = a2;
  uint64_t v3 = IFileStreamCreateWithFilename(a1, 0, -1);
  __int16 v11 = (char *)v3;
  if (!v3)
  {
    int v12 = "IFileStreamCreateWithFilename";
    __int16 v13 = 1429;
    goto LABEL_7;
  }
  *(void *)&long long v59 = 0;
  *((void *)&v60 + 1) = 0;
  long long v61 = 0u;
  long long v62 = 0u;
  *(void *)&long long v58 = 0;
  *((void *)&v58 + 1) = IFileStreamRead;
  *((void *)&v59 + 1) = v3;
  *(void *)&long long v60 = loadManifestProc;
  uint64_t v63 = v55;
  if (ParallelArchiveRead((uint64_t)&v58, v4, v5, v6, v7, v8, v9, v10))
  {
    int v12 = "ParallelArchiveRead";
    __int16 v13 = 1442;
LABEL_7:
    int v14 = 0;
LABEL_8:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadManifest", v13, 18, v14, v12, v9, v10, v54);
    int v15 = 1;
    goto LABEL_9;
  }
  if (v55[0])
  {
    int v12 = "errors during manifest scan";
    __int16 v13 = 1445;
    goto LABEL_7;
  }
  uint64_t v17 = *(void *)(a2 + 8);
  if (v17)
  {
    unint64_t v18 = 0;
    uint64_t v19 = (unint64_t *)(*(void *)(a2 + 16) + 72);
    do
    {
      if (*((_DWORD *)v19 - 4) == 1)
      {
        *uint64_t v19 = v18;
        if (*(v19 - 4))
        {
          uint64_t v20 = *(void *)(a2 + 40);
          unint64_t v21 = lookupEntry((void *)a2, (char *)(v20 + *(v19 - 5)));
          if ((v21 & 0x8000000000000000) != 0)
          {
            uint64_t v54 = v20 + *(v19 - 9);
            int v12 = "resolving hard link %s -> %s";
            __int16 v13 = 1464;
            goto LABEL_7;
          }
          if (v21 >= v18)
          {
            uint64_t v54 = v20 + *(v19 - 9);
            int v12 = "hard link resolved to a larger index: %s -> %s";
            __int16 v13 = 1465;
            goto LABEL_7;
          }
          *uint64_t v19 = v21;
        }
      }
      ++v18;
      v19 += 23;
    }
    while (v17 != v18);
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    uint64_t v25 = *(void *)(a2 + 16);
    char v26 = (void *)(v25 + 80);
    do
    {
      if (*((_DWORD *)v26 - 6) == 1)
      {
        uint64_t v27 = *(v26 - 1);
        if (v22 != v27)
        {
          if (*v26 == -1) {
            ++v23;
          }
          else {
            ++v24;
          }
          if (*v26 != *(void *)(v25 + 184 * v27 + 80))
          {
            int v12 = "Inconsistent HLC fields in manifest";
            __int16 v13 = 1482;
            goto LABEL_7;
          }
        }
      }
      v26 += 23;
      ++v22;
    }
    while (v17 != v22);
    if (v24 && v23)
    {
      int v12 = "Missing some HLC fields in manifest";
      __int16 v13 = 1484;
      goto LABEL_7;
    }
    if (!v24)
    {
      uint64_t v37 = 0;
      uint64_t v38 = *(void *)(a2 + 16);
      uint64_t v39 = (uint64_t *)(v38 + 80);
      do
      {
        if (*((_DWORD *)v39 - 6) == 1)
        {
          uint64_t v40 = *(v39 - 1);
          if (v24 != v40)
          {
            uint64_t v41 = v38 + 184 * v40;
            uint64_t v44 = *(void *)(v41 + 80);
            unint64_t v43 = (void *)(v41 + 80);
            uint64_t v42 = v44;
            if (v44 == -1)
            {
              *unint64_t v43 = v37;
              uint64_t v42 = v37++;
            }
            *uint64_t v39 = v42;
          }
        }
        v39 += 23;
        ++v24;
      }
      while (v17 != v24);
    }
    unint64_t v28 = 0;
    uint64_t v45 = 0;
    uint64_t v29 = 0;
    uint64_t v46 = (void *)(*(void *)(a2 + 16) + 88);
    do
    {
      if (*((_DWORD *)v46 - 8) == 1)
      {
        unint64_t v47 = *(v46 - 1);
        if (v47 != -1)
        {
          if (v47 > v28) {
            unint64_t v28 = *(v46 - 1);
          }
          if (*v46 == -1) {
            ++v45;
          }
          else {
            ++v29;
          }
        }
      }
      v46 += 23;
      --v17;
    }
    while (v17);
    if (v29 && v45)
    {
      int v12 = "Missing some HLO fields in manifest";
      __int16 v13 = 1516;
      goto LABEL_7;
    }
  }
  else
  {
    unint64_t v28 = 0;
    uint64_t v29 = 0;
  }
  if (__ptr[0] <= (void *)v28)
  {
    __ptr[0] = (void *)(v28 + 1);
    __ptr[1] = reallocf(__ptr[1], 8 * (v28 + 1));
    if (!__ptr[1])
    {
      int v14 = *__error();
      int v12 = "malloc";
      __int16 v13 = 1523;
      goto LABEL_8;
    }
  }
  if (v29)
  {
    if (__ptr[0]) {
      memset(__ptr[1], 255, 8 * (uint64_t)__ptr[0]);
    }
    uint64_t v30 = *(void *)(a2 + 8);
    if (v30)
    {
      uint64_t v31 = 0;
      char v32 = __ptr[1];
      unsigned int v33 = (void *)(*(void *)(a2 + 16) + 88);
      do
      {
        if (*((_DWORD *)v33 - 8) == 1)
        {
          uint64_t v34 = *(v33 - 1);
          if (v34 != -1)
          {
            if (*v33)
            {
              if (*v33 == -1)
              {
                int v12 = "Missing HLO field";
                __int16 v13 = 1552;
                goto LABEL_7;
              }
            }
            else
            {
              if (v32[v34] != -1)
              {
                int v12 = "Multiple HLO = 0 entries for same cluster";
                __int16 v13 = 1555;
                goto LABEL_7;
              }
              v32[v34] = v31;
            }
          }
        }
        v33 += 23;
        ++v31;
      }
      while (v30 != v31);
      uint64_t v35 = __ptr[1];
      int v36 = (void *)(*(void *)(a2 + 16) + 80);
      do
      {
        if (*((_DWORD *)v36 - 6) == 1 && *v36 != -1) {
          *(v36 - 1) = v35[*v36];
        }
        v36 += 23;
        --v30;
      }
      while (v30);
    }
  }
  else
  {
    if (__ptr[0]) {
      memset_pattern16(__ptr[1], &unk_2106D45D0, 8 * (uint64_t)__ptr[0]);
    }
    uint64_t v48 = *(void *)(a2 + 8);
    if (v48)
    {
      uint64_t v49 = 0;
      uint64_t v50 = __ptr[1];
      uint64_t v51 = (void *)(*(void *)(a2 + 16) + 88);
      do
      {
        if (*((_DWORD *)v51 - 8) == 1)
        {
          uint64_t v52 = *(v51 - 1);
          if (v52 != -1)
          {
            if (v49 == *(v51 - 2))
            {
              uint64_t v53 = 0;
            }
            else
            {
              uint64_t v53 = v50[v52];
              v50[v52] = v53 + 1;
            }
            *uint64_t v51 = v53;
          }
        }
        ++v49;
        v51 += 23;
      }
      while (v48 != v49);
    }
  }
  int v15 = 0;
  *(_DWORD *)(a2 + 48) = v57;
LABEL_9:
  IFileStreamDestroy(v11);
  free(__ptr[1]);
  if (v15)
  {
    free(*(void **)(a2 + 16));
    BlobBufferFree(a2 + 24);
    *(void *)(a2 + 48) = 0;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + ++*(_DWORD *)(result + 32) = 0u;
    *(_OWORD *)a2 = 0u;
  }
  return (v15 << 31 >> 31);
}

unint64_t loadManifestProc(unint64_t result, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = result;
  uint64_t v68 = *MEMORY[0x263EF8340];
  uint64_t v9 = a4;
  uint64_t v12 = *(void *)(result + 8);
  int v13 = 2;
  switch(a2[1])
  {
    case 'D':
      goto LABEL_5;
    case 'F':
    case 'H':
      int v13 = 1;
      goto LABEL_5;
    case 'L':
      int v13 = 3;
LABEL_5:
      unint64_t v16 = *(void *)(v12 + 8);
      if (v16 >= *(void *)v12)
      {
        uint64_t v18 = *(void *)v12 + 0x4000;
        *(void *)uint64_t v12 = v18;
        uint64_t v19 = reallocf(*(void **)(v12 + 16), 184 * v18);
        *(void *)(v12 + 16) = v19;
        if (!v19)
        {
          int v24 = *__error();
          int v14 = "reallocf";
          __int16 v15 = 1280;
          goto LABEL_108;
        }
        uint64_t v17 = v19;
        uint64_t v66 = a3;
        unint64_t v16 = *(void *)(v12 + 8);
      }
      else
      {
        uint64_t v66 = a3;
        uint64_t v17 = *(void **)(v12 + 16);
      }
      *(void *)(v12 + 8) = v16 + 1;
      uint64_t v20 = (char *)&v17[23 * v16];
      *((void *)v20 + 22) = 0;
      *((_OWORD *)v20 + 9) = 0u;
      *((_OWORD *)v20 + 10) = 0u;
      *((_OWORD *)v20 + 7) = 0u;
      *((_OWORD *)v20 + 8) = 0u;
      *((_OWORD *)v20 + 5) = 0u;
      *((_OWORD *)v20 + 6) = 0u;
      *((_OWORD *)v20 + 3) = 0u;
      *((_OWORD *)v20 + 4) = 0u;
      *((_OWORD *)v20 + 1) = 0u;
      *((_OWORD *)v20 + 2) = 0u;
      *(_OWORD *)uint64_t v20 = 0u;
      size_t v21 = strlen((const char *)a2 + 144);
      uint64_t result = BlobBufferStore(v12 + 24, a2 + 36, v21 + 1, v20);
      if (result)
      {
        int v14 = "Storing path";
        __int16 v15 = 1287;
LABEL_107:
        int v24 = 0;
        goto LABEL_108;
      }
      int v22 = *a2;
      if ((*a2 & 2) == 0)
      {
        LOBYTE(v57) = (_BYTE)a2 - 112;
        int v14 = "manifest doesn't provide UID for entry %s";
        __int16 v15 = 1288;
        goto LABEL_107;
      }
      if ((v22 & 4) == 0)
      {
        LOBYTE(v57) = (_BYTE)a2 - 112;
        int v14 = "manifest doesn't provide GID for entry %s";
        __int16 v15 = 1289;
        goto LABEL_107;
      }
      if ((v22 & 0x10) == 0)
      {
        LOBYTE(v57) = (_BYTE)a2 - 112;
        int v14 = "manifest doesn't provide MOD for entry %s";
        __int16 v15 = 1290;
        goto LABEL_107;
      }
      if ((v22 & 8) == 0)
      {
        LOBYTE(v57) = (_BYTE)a2 - 112;
        int v14 = "manifest doesn't provide FLG for entry %s";
        __int16 v15 = 1291;
        goto LABEL_107;
      }
      uint64_t v25 = (char *)&v17[23 * v16];
      *((void *)v25 + 14) = *((void *)a2 + 1);
      int v26 = a2[4];
      int v27 = a2[5] & 0xFFF;
      *((void *)v25 + 20) = 0x7FFFFFFFLL;
      v25 += 160;
      *((_DWORD *)v25 - 10) = v27;
      *((_DWORD *)v25 - 9) = v26;
      uint64_t v64 = v25 - 36;
      uint64_t v65 = v25;
      *((_DWORD *)v25 - 26) = v13;
      *((void *)v25 - 11) = -1;
      *((void *)v25 - 14) = -1;
      int v28 = a2[1];
      if (v28 == 72)
      {
        size_t v29 = strlen((const char *)a2 + 1168);
        uint64_t result = BlobBufferStore(v12 + 24, a2 + 292, v29 + 1, &v17[23 * v16 + 4]);
        if (result)
        {
          int v14 = "Storing link path";
          __int16 v15 = 1304;
          goto LABEL_107;
        }
        int v28 = a2[1];
      }
      if (v28 == 76)
      {
        size_t v30 = strlen((const char *)a2 + 1168);
        uint64_t result = BlobBufferStore(v12 + 24, a2 + 292, v30 + 1, &v17[23 * v16 + 12]);
        if (result)
        {
          int v14 = "Storing link path";
          __int16 v15 = 1309;
          goto LABEL_107;
        }
      }
      if (!v9)
      {
        v17[23 * v16 + 10] = -1;
        goto LABEL_51;
      }
      int v31 = 0;
      int v32 = 0;
      unint64_t v33 = 0;
      uint64_t v34 = 0;
      uint64_t v35 = (uint64_t *)(v66 + 8);
      uint64_t v36 = v9;
      do
      {
        int v37 = *(_DWORD *)(v35 - 1) & 0xDFDFDF;
        if (v37 == 5196872)
        {
          if (*((_DWORD *)v35 - 1) == 1)
          {
            uint64_t v34 = *v35;
            int v32 = 1;
          }
        }
        else if (v37 == 4410440 && *((_DWORD *)v35 - 1) == 1)
        {
          unint64_t v33 = *v35;
          int v31 = 1;
        }
        v35 += 129;
        --v36;
      }
      while (v36);
      if (v32 && !v31)
      {
        int v14 = "Invalid manifest, HLO without HLC";
        __int16 v15 = 1323;
        goto LABEL_107;
      }
      if (!v31)
      {
        v17[23 * v16 + 10] = -1;
        if (v32) {
          goto LABEL_52;
        }
        goto LABEL_51;
      }
      unint64_t v39 = *(void *)(v8 + 16);
      if (v33 < v39) {
        goto LABEL_67;
      }
      unint64_t v40 = *(void *)(v8 + 16);
      do
      {
        if (v40) {
          v40 += v40 >> 1;
        }
        else {
          unint64_t v40 = 16;
        }
      }
      while (v33 >= v40);
      if (v40 <= v39)
      {
LABEL_67:
        uint64_t result = *(void *)(v8 + 24);
LABEL_68:
        unint64_t v42 = *(void *)(result + 8 * v33);
        if (v42 != -1)
        {
          if (v42 >= *(void *)(v12 + 8))
          {
            int v14 = "invalid hard link index";
            __int16 v15 = 1352;
            goto LABEL_107;
          }
          unint64_t v43 = v33;
          int v61 = v32;
          uint64_t v63 = v34;
          if ((unint64_t)__strlcpy_chk() >= 0x400)
          {
            int v14 = "path too long";
            __int16 v15 = 1349;
            goto LABEL_107;
          }
          size_t v56 = strlen(__s);
          uint64_t result = BlobBufferStore(v12 + 24, __s, v56 + 1, &v17[23 * v16 + 4]);
          if (result)
          {
            int v14 = "Storing link path";
            __int16 v15 = 1350;
            goto LABEL_107;
          }
          v17[23 * v16 + 10] = v43;
          uint64_t v34 = v63;
          if (!v61) {
            goto LABEL_51;
          }
LABEL_52:
          v17[23 * v16 + 11] = v34;
          int v38 = a2[1];
          if (v38 == 70)
          {
            if ((*(unsigned char *)a2 & 0x80) == 0)
            {
              LOBYTE(v57) = (_BYTE)a2 - 112;
              int v14 = "manifest doesn't provide SIZ for entry %s";
              __int16 v15 = 1361;
              goto LABEL_107;
            }
            v17[23 * v16 + 8] = *((void *)a2 + 5);
            if ((*((unsigned char *)a2 + 1) & 0x20) == 0)
            {
              LOBYTE(v57) = (_BYTE)a2 - 112;
              int v14 = "manifest doesn't provide SH1 for entry %s";
              __int16 v15 = 1365;
              goto LABEL_107;
            }
            uint64_t v44 = (char *)&v17[23 * v16];
            long long v45 = *(_OWORD *)(a2 + 23);
            *((_DWORD *)v44 + 36) = a2[27];
            *((_OWORD *)v44 + 8) = v45;
            int v38 = a2[1];
            if (v38 == 70)
            {
              if ((*v64 & 0x20) == 0) {
                *(void *)uint64_t v65 = 0xFFFFFFFFLL;
              }
              int v38 = 70;
            }
          }
          int v46 = *a2;
          if ((*a2 & 0x400) != 0)
          {
            LODWORD(v17[23 * v16 + 22]) = 1;
            int v46 = *a2;
          }
          if ((v46 & 0x800) != 0) {
            HIDWORD(v17[23 * v16 + 22]) = 1;
          }
          int v47 = 0;
          if (v9)
          {
            uint64_t v48 = (char *)&v17[23 * v16];
            uint64_t v49 = v48 + 152;
            uint64_t v50 = (unint64_t *)(v48 + 168);
            uint64_t v51 = (void *)(v66 + 8);
            do
            {
              int v52 = *((_DWORD *)v51 - 2);
              if ((v52 & 0xDFDFDF) == 0x5A5544)
              {
                *uint64_t v49 = *v51;
                int v52 = *((_DWORD *)v51 - 2);
                int v47 = 1;
              }
              if ((v52 & 0xDFDFDF) == 0x544641)
              {
                *(_DWORD *)uint64_t v65 = *v51;
                int v52 = *((_DWORD *)v51 - 2);
              }
              if ((v52 & 0xDFDFDF) == 0x524641)
              {
                *((_DWORD *)v65 + 1) = *v51;
                int v52 = *((_DWORD *)v51 - 2);
              }
              uint64_t result = v52 & 0xDFDFDF;
              if (result == 4803654)
              {
                uint64_t result = *(unsigned int *)v51;
                *uint64_t v50 = result;
              }
              v51 += 129;
              --v9;
            }
            while (v9);
          }
          if (v38 != 70 || v47)
          {
            if (v38 != 72) {
              return result;
            }
            uint64_t result = lookupEntry((void *)v12, (char *)a2 + 1168);
            if ((result & 0x8000000000000000) == 0)
            {
              uint64_t v53 = *(void *)(v12 + 16) + 184 * result;
              uint64_t v54 = (char *)&v17[23 * v16];
              *((void *)v54 + 8) = *(void *)(v53 + 64);
              *((void *)v54 + 19) = *(void *)(v53 + 152);
              long long v55 = *(_OWORD *)(v53 + 128);
              *((_DWORD *)v54 + 36) = *(_DWORD *)(v53 + 144);
              *((_OWORD *)v54 + 8) = v55;
              return result;
            }
            LOBYTE(v57) = (_BYTE)a2 - 112;
            int v14 = "link path not found: %s -> %s";
            __int16 v15 = 1403;
          }
          else
          {
            LOBYTE(v57) = (_BYTE)a2 - 112;
            int v14 = "manifest doesn't provide DUZ for regular file %s";
            __int16 v15 = 1396;
          }
          goto LABEL_107;
        }
        *(void *)(result + 8 * v33) = 0xD37A6F4DE9BD37A7 * ((uint64_t)&v20[-*(void *)(v12 + 16)] >> 3);
        v17[23 * v16 + 10] = v33;
        if (v32) {
          goto LABEL_52;
        }
LABEL_51:
        uint64_t v34 = -1;
        goto LABEL_52;
      }
      int v60 = v32;
      uint64_t v62 = v34;
      unint64_t v59 = v33;
      uint64_t result = (unint64_t)reallocf(*(void **)(v8 + 24), 8 * v40);
      *(void *)(v8 + 24) = result;
      if (result)
      {
        unint64_t v41 = *(void *)(v8 + 16);
        if (v41 < v40)
        {
          unint64_t v58 = result;
          memset((void *)(result + 8 * v41), 255, 8 * v40 - 8 * v41);
          uint64_t result = v58;
        }
        *(void *)(v8 + 16) = v40;
        uint64_t v34 = v62;
        int v32 = v60;
        unint64_t v33 = v59;
        goto LABEL_68;
      }
      int v24 = *__error();
      int v14 = "malloc";
      __int16 v15 = 1333;
LABEL_108:
      uint64_t result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadManifestProc", v15, 18, v24, v14, a7, a8, v57);
      ++*(void *)v8;
      return result;
    case 'M':
      if (a4)
      {
        uint64_t v23 = (char *)(a3 + 8);
        do
        {
          if ((*((_DWORD *)v23 - 2) & 0xDFDFDF) == 0x464159 && *((_DWORD *)v23 - 1) == 7)
          {
            uint64_t result = (unint64_t)strstr(v23, "XAT");
            if (result)
            {
              uint64_t result = (unint64_t)strstr(v23, "ACL");
              if (result)
              {
                uint64_t result = (unint64_t)strstr(v23, "AFT");
                if (result)
                {
                  uint64_t result = (unint64_t)strstr(v23, "AFR");
                  if (result) {
                    *(_DWORD *)(v8 + ++*(_DWORD *)(result + 32) = 1;
                  }
                }
              }
            }
          }
          v23 += 1032;
          --v9;
        }
        while (v9);
      }
      return result;
    default:
      int v57 = a2[1];
      int v14 = "Unsupported file type: %d";
      __int16 v15 = 1273;
      goto LABEL_107;
  }
}

unint64_t lookupEntry(void *a1, char *__s1)
{
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v4 = (void *)a1[2];
    uint64_t v5 = a1[5];
    int v6 = strcmp(__s1, (const char *)(v5 + *v4));
    if ((v6 & 0x80000000) == 0)
    {
      if (!v6) {
        return 0;
      }
      unint64_t v7 = v2 - 1;
      int v8 = strcmp(__s1, (const char *)(v5 + v4[23 * v2 - 23]));
      if (v8 <= 0)
      {
        if (!v8) {
          return v2 - 1;
        }
        unint64_t v11 = 0;
        while (v11 + 1 < v7)
        {
          unint64_t v9 = (v7 + v11) >> 1;
          int v12 = strcmp(__s1, (const char *)(v5 + v4[23 * v9]));
          if (v12 < 0) {
            unint64_t v7 = (v7 + v11) >> 1;
          }
          else {
            unint64_t v11 = (v7 + v11) >> 1;
          }
          if (!v12) {
            return v9;
          }
        }
      }
    }
  }
  return -1;
}

size_t mergeContents(size_t result, uint64_t a2, void *a3)
{
  *(void *)a3 = result;
  if (result)
  {
    size_t v4 = result;
    uint64_t result = 0;
    uint64_t v5 = (uint64_t *)(a2 + 8);
    size_t v6 = v4;
    do
    {
      uint64_t v7 = *v5;
      v5 += 7;
      result += v7;
      --v6;
    }
    while (v6);
    if (result)
    {
      int v8 = (const char **)calloc(result, 8uLL);
      unint64_t v9 = v8;
      if (v8)
      {
        size_t v10 = 0;
        for (uint64_t i = 0; i != v4; ++i)
        {
          unint64_t v12 = *(void *)(a2 + 56 * i + 8);
          if (v12)
          {
            uint64_t v13 = 0;
            unint64_t v14 = 0;
            uint64_t v15 = a2 + 56 * i;
            unint64_t v16 = (void *)(v15 + 16);
            uint64_t v17 = (void *)(v15 + 40);
            do
            {
              if (v12 <= v14) {
                uint64_t v18 = 0;
              }
              else {
                uint64_t v18 = (const char *)(*v17 + *(void *)(*v16 + v13));
              }
              (&v8[v10])[v14++] = v18;
              v13 += 184;
            }
            while (v12 != v14);
            v10 += v14;
          }
        }
        qsort(v8, v10, 8uLL, (int (__cdecl *)(const void *, const void *))stringCompareProc);
        if (v10)
        {
          size_t v19 = 0;
          uint64_t v20 = v9;
          while (1)
          {
            if (v19)
            {
              size_t v21 = *v20;
              if (!strcmp(v9[v19 - 1], *v20)) {
                goto LABEL_22;
              }
            }
            else
            {
              size_t v21 = *v20;
            }
            v9[v19++] = v21;
LABEL_22:
            ++v20;
            if (!--v10) {
              goto LABEL_26;
            }
          }
        }
        size_t v19 = 0;
LABEL_26:
        *((void *)a3 + 1) = v19;
        int v27 = calloc(v19, 0x4B8uLL);
        *((void *)a3 + 4) = v27;
        if (v27)
        {
          if (v19)
          {
            uint64_t v28 = 0;
            size_t v29 = v9;
            size_t v30 = v19;
            while (1)
            {
              uint64_t v31 = *((void *)a3 + 4) + v28;
              *(_DWORD *)(v31 + 1200) = -1;
              size_t v32 = strlen(*v29);
              if (BlobBufferStore((uint64_t)a3 + 40, *v29, v32 + 1, (void *)v31)) {
                break;
              }
              ++v29;
              v28 += 1208;
              if (!--v30) {
                goto LABEL_31;
              }
            }
            uint64_t v25 = "Storing entry path";
            __int16 v26 = 1640;
          }
          else
          {
LABEL_31:
            uint64_t v33 = 0;
            uint64_t v53 = (uint64_t)a3 + 40;
            while (1)
            {
              long long v55 = (void *)(a2 + 56 * v33 + 8);
              if (*v55) {
                break;
              }
LABEL_45:
              *((_DWORD *)a3 + v33 + 1532++*(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 56 * v33 + 48);
              if (++v33 == v4)
              {
                free(v9);
                return 0;
              }
            }
            uint64_t v34 = 0;
            size_t v35 = 0;
            uint64_t v36 = a2 + 56 * v33;
            size_t v56 = (void *)(v36 + 40);
            int v57 = (uint64_t *)(v36 + 16);
            uint64_t v54 = v33;
            while (1)
            {
              uint64_t v37 = *v57;
              if (v35 < v19)
              {
                int v38 = (const char *)(*v56 + *(void *)(v37 + 184 * v34));
                uint64_t v39 = *((void *)a3 + 7);
                unint64_t v40 = (void *)(*((void *)a3 + 4) + 1208 * v35);
                while (strcmp(v38, (const char *)(v39 + *v40)))
                {
                  v40 += 151;
                  if (v19 == ++v35) {
                    goto LABEL_48;
                  }
                }
              }
              if (v35 == v19)
              {
LABEL_48:
                uint64_t v25 = "unable to locate path in merged array";
                __int16 v26 = 1654;
                goto LABEL_50;
              }
              uint64_t v41 = v37 + 184 * v34;
              *(void *)(v41 + 48) = v35;
              uint64_t v33 = v54;
              uint64_t v42 = *((void *)a3 + 4) + 1208 * v35 + 16 + (v54 << 7);
              long long v43 = *(_OWORD *)(v41 + 120);
              long long v44 = *(_OWORD *)(v41 + 136);
              long long v45 = *(_OWORD *)(v41 + 168);
              *(_OWORD *)(v42 + 96) = *(_OWORD *)(v41 + 152);
              *(_OWORD *)(v42 + 112) = v45;
              *(_OWORD *)(v42 + 64) = v43;
              *(_OWORD *)(v42 + 80) = v44;
              long long v46 = *(_OWORD *)(v41 + 56);
              long long v47 = *(_OWORD *)(v41 + 72);
              long long v48 = *(_OWORD *)(v41 + 104);
              *(_OWORD *)(v42 + ++*(_DWORD *)(result + 32) = *(_OWORD *)(v41 + 88);
              *(_OWORD *)(v42 + 48) = v48;
              *(_OWORD *)uint64_t v42 = v46;
              *(_OWORD *)(v42 + 16) = v47;
              uint64_t v49 = *(void *)(v41 + 72);
              if (v49 != -1) {
                uint64_t v49 = *(void *)(*v57 + 184 * v49 + 48);
              }
              *(void *)(v42 + 40) = 0;
              uint64_t v50 = (void *)(v42 + 40);
              *(v50 - 3) = v49;
              v50[1] = 0;
              if (*(void *)(v37 + 184 * v34 + 104))
              {
                uint64_t v51 = (const char *)(*v56 + *(void *)(v37 + 184 * v34 + 96));
                size_t v52 = strlen(v51);
                if (BlobBufferStore(v53, v51, v52 + 1, v50)) {
                  break;
                }
              }
              if ((unint64_t)++v34 >= *v55) {
                goto LABEL_45;
              }
            }
            uint64_t v25 = "Storing slink path";
            __int16 v26 = 1678;
          }
LABEL_50:
          int v22 = 0;
        }
        else
        {
          int v22 = *__error();
          uint64_t v25 = "malloc";
          __int16 v26 = 1633;
        }
      }
      else
      {
        int v22 = *__error();
        uint64_t v25 = "malloc";
        __int16 v26 = 1610;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"mergeContents", v26, 18, v22, v25, v23, v24, v53);
      free(v9);
      free(*((void **)a3 + 4));
      BlobBufferFree((uint64_t)a3 + 40);
      bzero(a3, 0x989F0uLL);
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t stringCompareProc(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

uint64_t applyRules(const __CFArray *a1, const __CFArray *a2, const __CFArray *a3, const __CFArray *a4, const __CFArray *a5, const __CFArray *a6, const __CFArray *a7, const __CFArray *a8, uint64_t *a9, int a10)
{
  uint64_t v17 = *a9;
  uint64_t v52 = a9[1];
  if ((markFilesMatchingPrefixArray(a9, a1, 1, a10) & 0x80000000) != 0
    || (markFilesMatchingPrefixArray(a9, a2, 2, a10) & 0x80000000) != 0
    || (markFilesMatchingPrefixArray(a9, a3, 4, a10) & 0x80000000) != 0
    || (markFilesMatchingPrefixArray(a9, a4, 16, a10) & 0x80000000) != 0
    || (markFilesMatchingPrefixArray(a9, a5, 32, a10) & 0x80000000) != 0
    || (markFilesMatchingPrefixArray(a9, a6, 64, a10) & 0x80000000) != 0
    || (markFilesMatchingPrefixArray(a9, a7, 512, a10) & 0x80000000) != 0
    || (markFilesMatchingPrefixArray(a9, a8, 1024, a10) & 0x80000000) != 0)
  {
    return 0xFFFFFFFFLL;
  }
  if (!v52) {
    return 0;
  }
  uint64_t v18 = 0;
  for (unint64_t i = 0; i != v52; ++i)
  {
    uint64_t v20 = a9[4];
    int v21 = *(_DWORD *)(v20 + v18 + 1172);
    if ((v21 & 2) != 0 && !*(_DWORD *)(v20 + (v17 << 7) - 112 + v18))
    {
      *(_DWORD *)(v20 + v18 + 1172) = v21 & 0xFFFFFFFD;
      if (a10 >= 2)
      {
        int v22 = "???";
        if ((v21 & 4) != 0) {
          int v22 = "Remove";
        }
        uint64_t v23 = "Include";
        if (v21)
        {
          uint64_t v23 = "Exclude";
          int v22 = "Exclude";
        }
        if ((v21 & 5) != 0) {
          uint64_t v24 = v22;
        }
        else {
          uint64_t v24 = "None";
        }
        if (a9[1] <= i) {
          uint64_t v25 = 0;
        }
        else {
          uint64_t v25 = (const char *)(a9[7] + *(void *)(v20 + v18));
        }
        fprintf((FILE *)*MEMORY[0x263EF8348], "Rules from %s to %s (include not in output): %s\n", v23, v24, v25);
      }
    }
    v18 += 1208;
  }
  uint64_t v26 = 0;
  for (unint64_t j = 0; j != v52; ++j)
  {
    uint64_t v28 = a9[4];
    uint64_t v29 = v28 + v26;
    unsigned int v30 = *(_DWORD *)(v28 + v26 + 1172);
    if (v30)
    {
      unsigned int v31 = v30 & 0xFFFFFFEE;
      if ((v30 & 0x10) == 0) {
        unsigned int v31 = *(_DWORD *)(v28 + v26 + 1172);
      }
      int v32 = v31 & 0x20;
      if ((v31 & 0x20) != 0) {
        v31 &= 0xFFFFFFDD;
      }
      int v33 = *(_DWORD *)(v28 + v26 + 1172) & 0x10 | v32;
      int v34 = v31 & 0x40;
      if ((v31 & 0x40) != 0) {
        v31 &= 0xFFFFFFBB;
      }
      if (v33 | v34) {
        *(_DWORD *)(v29 + 1172) = v31;
      }
      if (a10 >= 2)
      {
        if (v31 != v30)
        {
          size_t v35 = "Remove";
          if ((v30 & 4) == 0) {
            size_t v35 = "???";
          }
          if ((v30 & 2) != 0) {
            size_t v35 = "Include";
          }
          if (v30) {
            size_t v35 = "Exclude";
          }
          if ((v30 & 7) != 0) {
            uint64_t v36 = v35;
          }
          else {
            uint64_t v36 = "None";
          }
          if ((v31 & 7) != 0)
          {
            uint64_t v37 = "Exclude";
            if ((v31 & 1) == 0)
            {
              uint64_t v37 = "Remove";
              if ((v31 & 4) == 0) {
                uint64_t v37 = "???";
              }
              if ((v31 & 2) != 0) {
                uint64_t v37 = "Include";
              }
            }
          }
          else
          {
            uint64_t v37 = "None";
          }
          if (a9[1] <= j) {
            int v38 = 0;
          }
          else {
            int v38 = (const char *)(a9[7] + *(void *)(v28 + v26));
          }
          fprintf((FILE *)*MEMORY[0x263EF8348], "Rules from %s to %s (no-xxx): %s\n", v36, v37, v38);
          unsigned int v30 = *(_DWORD *)(v29 + 1172);
        }
      }
      else
      {
        unsigned int v30 = v31;
      }
      unsigned int v39 = v30 & 0xFFFFFFFA;
      if ((v30 & 2) == 0) {
        unsigned int v39 = v30;
      }
      int v40 = v39 & 1;
      if (v39) {
        v39 &= ~4u;
      }
      if (v30 & 2 | v40) {
        *(_DWORD *)(v29 + 1172) = v39;
      }
      if (a10 >= 2 && v39 != v30)
      {
        uint64_t v41 = "Include";
        if (v30) {
          uint64_t v41 = "Exclude";
        }
        uint64_t v42 = "Remove";
        if ((v30 & 4) == 0) {
          uint64_t v42 = "???";
        }
        if ((v30 & 3) != 0) {
          long long v43 = v41;
        }
        else {
          long long v43 = v42;
        }
        if ((v30 & 7) != 0) {
          long long v44 = v43;
        }
        else {
          long long v44 = "None";
        }
        if ((v39 & 7) != 0)
        {
          long long v45 = "Exclude";
          if ((v39 & 1) == 0)
          {
            long long v45 = "Include";
            if ((v39 & 2) == 0)
            {
              long long v45 = "???";
              if ((v39 & 4) != 0) {
                long long v45 = "Remove";
              }
            }
          }
        }
        else
        {
          long long v45 = "None";
        }
        if (a9[1] <= j) {
          long long v46 = 0;
        }
        else {
          long long v46 = (const char *)(a9[7] + *(void *)(a9[4] + v26));
        }
        fprintf((FILE *)*MEMORY[0x263EF8348], "Rules from %s to %s (priority): %s\n", v44, v45, v46);
      }
    }
    v26 += 1208;
  }
  uint64_t v47 = 0;
  uint64_t v48 = 1172;
  do
  {
    uint64_t v49 = a9[4];
    int v50 = *(_DWORD *)(v49 + v48);
    if ((v50 & 0x200) != 0)
    {
      *(_DWORD *)(v49 + v48) = v50 & 0xFFFFFAFF;
      if (a10 >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Label PREPARE: %s\n");
      }
    }
    else if ((v50 & 0x400) != 0)
    {
      *(_DWORD *)(v49 + v48) = v50 & 0xFFFFFEFF;
      if (a10 >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Label DATA: %s\n");
      }
    }
    else
    {
      *(_DWORD *)(v49 + v48) = v50 | 0x100;
      if (a10 >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Label MAIN: %s\n");
      }
    }
    uint64_t result = 0;
    ++v47;
    v48 += 1208;
  }
  while (v52 != v47);
  return result;
}

CFIndex markFilesMatchingPrefixArray(void *a1, CFArrayRef theArray, int a3, int a4)
{
  int v45 = a4;
  uint64_t v48 = *MEMORY[0x263EF8340];
  if (!theArray) {
    return 0;
  }
  CFArrayRef v5 = theArray;
  CFIndex result = CFArrayGetCount(theArray);
  if (!result) {
    return result;
  }
  CFIndex v8 = result;
  if (result < 1)
  {
LABEL_59:
    uint64_t v36 = a1[1];
    if (v36)
    {
      uint64_t v37 = 0;
      int v38 = (_DWORD *)(a1[4] + 1172);
      do
      {
        if ((*v38 & a3) != 0) {
          ++v37;
        }
        v38 += 302;
        --v36;
      }
      while (v36);
    }
    else
    {
      uint64_t v37 = 0;
    }
    if (v45 > 1)
    {
      if (a3)
      {
        if (a3)
        {
          unsigned int v39 = "Exclude";
        }
        else if ((a3 & 2) != 0)
        {
          unsigned int v39 = "Include";
        }
        else if ((a3 & 4) != 0)
        {
          unsigned int v39 = "Remove";
        }
        else if ((a3 & 0x10) != 0)
        {
          unsigned int v39 = "NoExclude";
        }
        else if ((a3 & 0x20) != 0)
        {
          unsigned int v39 = "NoInclude";
        }
        else if ((a3 & 0x40) != 0)
        {
          unsigned int v39 = "NoRemove";
        }
        else if ((a3 & 0x100) != 0)
        {
          unsigned int v39 = "Main";
        }
        else if ((a3 & 0x200) != 0)
        {
          unsigned int v39 = "Prepare";
        }
        else
        {
          unsigned int v39 = "Data";
          if ((a3 & 0x400) == 0) {
            unsigned int v39 = "???";
          }
        }
      }
      else
      {
        unsigned int v39 = "None";
      }
      fprintf((FILE *)*MEMORY[0x263EF8348], "%s rules: %zu total entries match\n", v39, v37);
    }
    return 0;
  }
  CFIndex v9 = 0;
  size_t v10 = "Data";
  if ((a3 & 0x400) == 0) {
    size_t v10 = "???";
  }
  unint64_t v11 = "Include";
  if (a3) {
    unint64_t v11 = "Exclude";
  }
  if ((a3 & 3) == 0) {
    unint64_t v11 = "Remove";
  }
  if ((a3 & 7) == 0) {
    unint64_t v11 = "NoExclude";
  }
  if ((a3 & 0x17) == 0) {
    unint64_t v11 = "NoInclude";
  }
  if ((a3 & 0x37) == 0) {
    unint64_t v11 = "NoRemove";
  }
  if ((a3 & 0x77) == 0) {
    unint64_t v11 = "Main";
  }
  if ((a3 & 0x200) != 0) {
    size_t v10 = "Prepare";
  }
  if ((a3 & 0x177) != 0) {
    size_t v10 = v11;
  }
  if (!a3) {
    size_t v10 = "None";
  }
  CFArrayRef v42 = v5;
  long long v43 = v10;
  CFIndex v41 = result;
  while (1)
  {
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v5, v9);
    if (!ValueAtIndex)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"markFilesMatchingPrefixArray", 2053, 18, 0, "CFArrayGetValueAtIndex(%ld) returned 0", v13, v14, v9);
      return 0xFFFFFFFFLL;
    }
    CFStringRef v15 = ValueAtIndex;
    bzero(buffer, 0x400uLL);
    CFStringGetCString(v15, buffer, 1024, 0x8000100u);
    size_t v16 = strlen(buffer);
    if (!v16) {
      goto LABEL_58;
    }
    if (buffer[v16 - 1] == 47)
    {
      buffer[v16 - 1] = 0;
      if (v16 == 1) {
        goto LABEL_58;
      }
    }
    unint64_t v17 = a1[1];
    if (!v17) {
      goto LABEL_58;
    }
    bzero(__s2, 0x400uLL);
    size_t v18 = strlen(buffer);
    if (v18 - 1024 <= 0xFFFFFFFFFFFFFC00)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"markFilesMatchingPrefix", 1986, 18, 0, "invalid prefix length", v19, v20, v40);
      break;
    }
    size_t v21 = v18;
    __memcpy_chk();
    int v44 = __s2[v21 - 1];
    if (v44 == 36) {
      __s2[--v21] = 0;
    }
    int v22 = (void *)a1[4];
    uint64_t v23 = a1[7];
    if (strcmp((const char *)(v23 + *v22), __s2) < 0)
    {
      if (v17 < 2)
      {
        unint64_t v30 = 1;
      }
      else
      {
        uint64_t v26 = 0;
        unint64_t v27 = v17;
        unint64_t v28 = v17;
        do
        {
          unint64_t v29 = v26 + (v27 >> 1);
          if (strcmp((const char *)(v23 + v22[151 * v29]), __s2) >= 0) {
            unint64_t v28 = v29;
          }
          else {
            uint64_t v26 = v29;
          }
          unint64_t v27 = v28 - v26;
        }
        while (v28 - v26 > 1);
        unint64_t v30 = v26 + 1;
      }
    }
    else
    {
      unint64_t v30 = 0;
    }
    if (v30 >= v17)
    {
      CFIndex v8 = v41;
      CFArrayRef v5 = v42;
      goto LABEL_58;
    }
    int v31 = 0;
    uint64_t v32 = 1208 * v30;
    do
    {
      if (a1[1] <= v30) {
        break;
      }
      uint64_t v33 = a1[4];
      int v34 = (const char *)(a1[7] + *(void *)(v33 + v32));
      if (strncmp(v34, __s2, v21)) {
        break;
      }
      if (v34[v21])
      {
        if (v44 == 36) {
          goto LABEL_54;
        }
        if (v34[v21] != 47) {
          goto LABEL_54;
        }
        *(_DWORD *)(v33 + v32 + 1172) |= a3;
        ++v31;
        size_t v35 = "%s rule [%s] prefix match: %s\n";
        if (v45 < 2) {
          goto LABEL_54;
        }
LABEL_53:
        fprintf((FILE *)*MEMORY[0x263EF8348], v35, v43, __s2, v34);
        goto LABEL_54;
      }
      *(_DWORD *)(v33 + v32 + 1172) |= a3;
      ++v31;
      size_t v35 = "%s rule [%s] exact match: %s\n";
      if (v45 > 1) {
        goto LABEL_53;
      }
LABEL_54:
      ++v30;
      v32 += 1208;
    }
    while (v17 != v30);
    CFIndex v8 = v41;
    CFArrayRef v5 = v42;
    if (v31 < 0) {
      break;
    }
LABEL_58:
    if (++v9 == v8) {
      goto LABEL_59;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"markFilesMatchingPrefixArray", 2061, 18, 0, "markFilesMatchingPrefix failed", v24, v25, v40);
  return 0xFFFFFFFFLL;
}

uint64_t fixOpsForHardLinkClusters(uint64_t *a1, int a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  unint64_t v6 = *a1 - 1;
  uint64_t v54 = 0;
  memset(v53, 0, sizeof(v53));
  uint64_t v52 = 0;
  memset(v51, 0, sizeof(v51));
  if (v5)
  {
    uint64_t v7 = 0;
    uint64_t v8 = a1[4];
    CFIndex v9 = (unint64_t *)(v8 + 40);
    do
    {
      if (*(_DWORD *)(v8 + 1208 * v7 + (v6 << 7) + 16) == 1
        && (*(unsigned char *)(v8 + 1208 * v7 + 1168) & 0x14) != 0
        && v6 != 0)
      {
        unint64_t v11 = (unint64_t *)v53;
        unint64_t v12 = v9;
        unint64_t v13 = v6;
        do
        {
          unint64_t v14 = *v12;
          if (*((_DWORD *)v12 - 6) == 1 && v14 != -1)
          {
            if (v14 <= *v11) {
              unint64_t v14 = *v11;
            }
            *unint64_t v11 = v14;
          }
          v12 += 16;
          ++v11;
          --v13;
        }
        while (v13);
      }
      ++v7;
      v9 += 151;
    }
    while (v7 != v5);
  }
  if (!v6)
  {
LABEL_24:
    if (v5)
    {
      uint64_t v22 = 0;
      uint64_t v23 = a1[4];
      uint64_t v24 = (void *)(v23 + 40);
      do
      {
        if (*(_DWORD *)(v23 + 1208 * v22 + (v6 << 7) + 16) == 1
          && (*(unsigned char *)(v23 + 1208 * v22 + 1168) & 0x14) != 0
          && v6 != 0)
        {
          uint64_t v26 = v51;
          unint64_t v27 = v24;
          unint64_t v28 = v6;
          do
          {
            uint64_t v29 = *v27;
            if (*((_DWORD *)v27 - 6) == 1 && v29 != -1) {
              ++*(_DWORD *)(*v26 + 4 * v29);
            }
            v27 += 16;
            ++v26;
            --v28;
          }
          while (v28);
        }
        ++v22;
        v24 += 151;
      }
      while (v22 != v5);
    }
    char v31 = 1;
    while (1)
    {
      char v32 = v31;
      if (v5) {
        break;
      }
LABEL_64:
      char v31 = 0;
      int v21 = 0;
      if ((v32 & 1) == 0)
      {
        if (!v6) {
          return (v21 << 31 >> 31);
        }
        goto LABEL_69;
      }
    }
    unint64_t v33 = 0;
    uint64_t v34 = 40;
    while (1)
    {
      uint64_t v35 = a1[4];
      if (*(_DWORD *)(v35 + 1208 * v33 + (v6 << 7) + 16) == 1)
      {
        uint64_t v36 = v35 + 1208 * v33;
        int v37 = *(_DWORD *)(v36 + 1168);
        if (v32)
        {
          if ((v37 & 4) != 0) {
            goto LABEL_47;
          }
        }
        else if ((v37 & 0x10) != 0)
        {
LABEL_47:
          if (v6)
          {
            int v38 = 0;
            unsigned int v39 = (unsigned int *)(v36 + 1168);
            char v40 = (void *)(v35 + v34);
            CFIndex v41 = v51;
            unint64_t v42 = v6;
            do
            {
              uint64_t v43 = *v40;
              if (*((_DWORD *)v40 - 6) == 1 && v43 != -1)
              {
                int v45 = *(_DWORD *)(*v41 + 4 * v43);
                if (v45 >= 2)
                {
                  *(_DWORD *)(*v41 + 4 * v43) = v45 - 1;
                  int v38 = 1;
                }
              }
              v40 += 16;
              ++v41;
              --v42;
            }
            while (v42);
            if (v38)
            {
              if (a2 >= 2)
              {
                if (a1[1] <= v33) {
                  long long v46 = 0;
                }
                else {
                  long long v46 = (const char *)(a1[7] + *(void *)(v35 + 1208 * v33));
                }
                fprintf((FILE *)*MEMORY[0x263EF8348], "ARCHIVE entry with invalid cluster mapping: %s\n", v46);
              }
              *unsigned int v39 = *v39 & 0xFFFFFFEA | 1;
            }
          }
        }
      }
      ++v33;
      v34 += 1208;
      if (v33 == v5) {
        goto LABEL_64;
      }
    }
  }
  *(void *)&v51[0] = calloc(*(void *)&v53[0] + 1, 4uLL);
  if (*(void *)&v51[0])
  {
    unint64_t v18 = 0;
    uint64_t v19 = v4 - 2;
    do
    {
      if (v19 == v18) {
        goto LABEL_24;
      }
      uint64_t v20 = calloc(*((void *)v53 + v18 + 1) + 1, 4uLL);
      *((void *)v51 + ++v18) = v20;
    }
    while (v20);
    int v21 = v18 < v6;
  }
  else
  {
    int v21 = 1;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"fixOpsForHardLinkClusters", 2318, 18, 0, "calloc", v16, v17, v50);
LABEL_69:
  uint64_t v47 = (void **)v51;
  do
  {
    uint64_t v48 = *v47++;
    free(v48);
    --v6;
  }
  while (v6);
  return (v21 << 31 >> 31);
}

uint64_t initOps(unint64_t a1, unint64_t a2, unint64_t a3, int a4, uint64_t *a5, int a6)
{
  uint64_t v8 = a5[1];
  uint64_t v76 = *a5;
  if (v8)
  {
    unint64_t v9 = 0;
    uint64_t v10 = v76 - 1;
    unint64_t v67 = a1 >> 2;
    uint64_t v11 = 16;
    uint64_t v12 = 88;
    uint64_t v13 = 56;
    uint64_t v14 = 140;
    uint64_t v15 = 24;
    uint64_t v75 = a5[1];
    do
    {
      uint64_t v16 = a5[4];
      if (a5[1] <= v9) {
        uint64_t v17 = 0;
      }
      else {
        uint64_t v17 = (const char *)(a5[7] + *(void *)(v16 + 1208 * v9));
      }
      int v18 = *(_DWORD *)(v16 + 1208 * v9 + (v10 << 7) + 16);
      if ((v18 | 2) != 3) {
        goto LABEL_22;
      }
      int v19 = *(_DWORD *)(v16 + 1208 * v9 + 1172);
      if (v19)
      {
        *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 0x20u;
        if (a6 >= 2)
        {
          fprintf((FILE *)*MEMORY[0x263EF8348], "IGNORE excluded entry present in output: %s\n");
          goto LABEL_21;
        }
      }
      else if (v18 == 1 && *(void *)(v16 + 1208 * v9 + (v10 << 7) + 32) != v9)
      {
        *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 8u;
        if (a6 >= 2)
        {
          fprintf((FILE *)*MEMORY[0x263EF8348], "LINK: %s\n");
          goto LABEL_21;
        }
      }
      else if (v76 == 1)
      {
        *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 1u;
        if (a6 >= 2)
        {
          fprintf((FILE *)*MEMORY[0x263EF8348], "ARCHIVE full replacement: %s\n");
          goto LABEL_21;
        }
      }
      else
      {
        if (!*(_DWORD *)(v16 + 1208 * v9 + (v10 << 7) + 140) && !*(_DWORD *)(v16 + 1208 * v9 + (v10 << 7) + 136))
        {
          if ((v19 & 2) != 0)
          {
            *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 1u;
            if (a6 < 2) {
              goto LABEL_22;
            }
            fprintf((FILE *)*MEMORY[0x263EF8348], "ARCHIVE include: %s\n");
          }
          else
          {
            uint64_t v20 = (int *)(v16 + v11);
            uint64_t v21 = v10;
            do
            {
              int v22 = *v20;
              v20 += 32;
              if (v22 != v18)
              {
                *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 1u;
                if (a6 < 2) {
                  goto LABEL_22;
                }
                fprintf((FILE *)*MEMORY[0x263EF8348], "ARCHIVE differing types: %s\n");
                goto LABEL_21;
              }
              --v21;
            }
            while (v21);
            if (v18 == 3)
            {
              if (v10)
              {
                int v62 = a6;
                uint64_t v65 = a5[7];
                uint64_t v63 = v17;
                uint64_t v64 = (const char *)(v65 + *(void *)(v16 + 1208 * v9 + (v10 << 7) + 56));
                uint64_t v23 = (void *)(v16 + v13);
                uint64_t v24 = v10;
                while (1)
                {
                  uint64_t v68 = v23 + 16;
                  int v25 = strcmp(v64, (const char *)(v65 + *v23));
                  BOOL v26 = v25 == 0;
                  if (v25) {
                    goto LABEL_46;
                  }
                  --v24;
                  uint64_t v23 = v68;
                  if (!v24) {
                    goto LABEL_43;
                  }
                }
              }
LABEL_44:
              int v30 = 0;
              int v31 = 0;
              int v32 = 0;
              BOOL v26 = 1;
            }
            else
            {
              if (v18 == 1)
              {
                if (!v10) {
                  goto LABEL_44;
                }
                uint64_t v63 = v17;
                int v62 = a6;
                uint64_t v66 = v16 + 1208 * v9 + (v10 << 7) + 88;
                uint64_t v27 = v16 + v12;
                uint64_t v28 = v10;
                while (1)
                {
                  uint64_t v69 = v27;
                  int v29 = sha1cmp(v66, v27);
                  BOOL v26 = v29 == 0;
                  if (v29) {
                    break;
                  }
                  uint64_t v27 = v69 + 128;
                  if (!--v28)
                  {
LABEL_43:
                    int v30 = 0;
                    goto LABEL_47;
                  }
                }
LABEL_46:
                int v30 = 1;
LABEL_47:
                a6 = v62;
                uint64_t v10 = v76 - 1;
                uint64_t v8 = v75;
                uint64_t v17 = v63;
              }
              else
              {
                int v30 = 0;
                BOOL v26 = 1;
              }
              if (v10)
              {
                int v32 = 0;
                uint64_t v33 = v16 + 1208 * v9 + (v10 << 7);
                int32x4_t v34 = *(int32x4_t *)(v33 + 72);
                uint64_t v35 = *(void *)(v33 + 128);
                uint64_t v36 = (_DWORD *)(v16 + v14);
                uint64_t v37 = v10;
                while (1)
                {
                  if ((vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vceqq_s32(v34, *(int32x4_t *)(v36 - 17))), 0xFuLL))) & (v35 == *(void *)(v36 - 3))) == 0) {
                    int v32 = 1;
                  }
                  if (*v36 || *(v36 - 1)) {
                    break;
                  }
                  v36 += 32;
                  if (!--v37)
                  {
                    int v31 = 0;
                    goto LABEL_58;
                  }
                }
                int v31 = 1;
              }
              else
              {
                int v31 = 0;
                int v32 = 0;
              }
            }
LABEL_58:
            if (v18 == 1 && a4 != 0 || v32 == 0) {
              int v40 = v31;
            }
            else {
              int v40 = 1;
            }
            if (!(v40 | v30))
            {
              *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 0x10u;
              if (a6 >= 2)
              {
                int v44 = (FILE *)*MEMORY[0x263EF8348];
                if (v32) {
                  fprintf(v44, "KEEP WITH FIXUP: %s\n", v26);
                }
                else {
                  fprintf(v44, "KEEP: %s\n", v26);
                }
                uint64_t v10 = v76 - 1;
                uint64_t v8 = v75;
              }
              goto LABEL_22;
            }
            if (v18 == 3)
            {
              CFIndex v41 = (int *)(v16 + 1208 * v9 + 1168);
              int v42 = *v41;
              *v41 |= 1u;
              if (a6 < 2)
              {
                if (v26) {
                  *CFIndex v41 = v42 | 0x101;
                }
                goto LABEL_22;
              }
              BOOL v43 = v26;
              fprintf((FILE *)*MEMORY[0x263EF8348], "ARCHIVE differing symlink: %s\n", v17);
              uint64_t v10 = v76 - 1;
              uint64_t v8 = v75;
              if (!v43) {
                goto LABEL_22;
              }
              *v41 |= 0x100u;
              fprintf((FILE *)*MEMORY[0x263EF8348], "ARCHIVE_NOREMOVE symlink attribute changes only: %s\n");
            }
            else
            {
              uint64_t v45 = *a5;
              if (*a5)
              {
                unint64_t v46 = 0;
                uint64_t v47 = (unint64_t *)(v16 + v15);
                do
                {
                  unint64_t v49 = *v47;
                  v47 += 16;
                  unint64_t v48 = v49;
                  if (v46 <= v49) {
                    unint64_t v46 = v48;
                  }
                  --v45;
                }
                while (v45);
              }
              else
              {
                unint64_t v46 = 0;
              }
              uint64_t v50 = v16 + 1208 * v9 + (v10 << 7);
              unint64_t v52 = *(void *)(v50 + 24);
              uint64_t v51 = (void *)(v50 + 24);
              if (v52 < a1 || v46 >= a2)
              {
                *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 1u;
                if (a6 < 2) {
                  goto LABEL_22;
                }
                fprintf((FILE *)*MEMORY[0x263EF8348], "ARCHIVE different files, not in patch range: %s\n");
              }
              else if (v46 >= a3 {
                     && (int v70 = v40,
              }
                         int IsCompressed = statIsCompressed(*(_DWORD *)(v16 + 1208 * v9 + (v10 << 7) + 84)),
                         int v40 = v70,
                         uint64_t v10 = v76 - 1,
                         uint64_t v8 = v75,
                         IsCompressed))
              {
                *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 1u;
                if (a6 < 2) {
                  goto LABEL_22;
                }
                fprintf((FILE *)*MEMORY[0x263EF8348], "ARCHIVE different files, not in patch range for AFSC-compressed files: %s\n");
              }
              else if (v40)
              {
                *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 1u;
                if (a6 < 2) {
                  goto LABEL_22;
                }
                fprintf((FILE *)*MEMORY[0x263EF8348], "ARCHIVE different files, attributes differ: %s\n");
              }
              else
              {
                if (v67 <= *v51 >> 3) {
                  unint64_t v55 = *v51 >> 3;
                }
                else {
                  unint64_t v55 = v67;
                }
                uint64_t v56 = v16;
                uint64_t v57 = v10;
                if (v10)
                {
                  while (*(void *)(v56 + v15) >= v55)
                  {
                    v56 += 128;
                    if (!--v57) {
                      goto LABEL_106;
                    }
                  }
                  *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 1u;
                  if (a6 >= 2)
                  {
                    fprintf((FILE *)*MEMORY[0x263EF8348], "ARCHIVE one input is too small: %s\n");
                    goto LABEL_21;
                  }
                  goto LABEL_22;
                }
LABEL_106:
                *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 4u;
                if (a6 < 2) {
                  goto LABEL_22;
                }
                fprintf((FILE *)*MEMORY[0x263EF8348], "PATCH different files: %s\n");
              }
            }
          }
LABEL_21:
          uint64_t v10 = v76 - 1;
          uint64_t v8 = v75;
          goto LABEL_22;
        }
        *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 1u;
        if (a6 >= 2)
        {
          fprintf((FILE *)*MEMORY[0x263EF8348], "ARCHIVE entry with XAT/ACL: %s\n");
          goto LABEL_21;
        }
      }
LABEL_22:
      ++v9;
      v11 += 1208;
      v12 += 1208;
      v13 += 1208;
      v14 += 1208;
      v15 += 1208;
    }
    while (v9 != v8);
  }
  if (v76 == 1 || (fixOpsForHardLinkClusters(a5, a6) & 0x80000000) == 0) {
    return 0;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"initOps", 2611, 18, 0, "fixOpsForInPlace", v58, v59, v61);
  return 0xFFFFFFFFLL;
}

uint64_t updateOps(void *a1, int a2, int a3)
{
  unint64_t v90 = a1[1];
  if (v90)
  {
    uint64_t v3 = a1;
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    uint64_t v77 = *a1 - 1;
    uint64_t v6 = *a1 << 7;
    while (1)
    {
      uint64_t v7 = v3[4];
      if (v3[1] <= v5) {
        uint64_t v8 = 0;
      }
      else {
        uint64_t v8 = v3[7] + *(void *)(v7 + v4);
      }
      int v9 = *(_DWORD *)(v7 + v6 - 112 + v4);
      if (v9 == 2) {
        goto LABEL_25;
      }
      int v10 = *(_DWORD *)(v7 + v4 + 1172);
      if (v9 || (*(_DWORD *)(v7 + v4 + 1172) & 1) == 0) {
        break;
      }
      *(_DWORD *)(v7 + v4 + 1168) |= 0x20u;
      uint64_t v17 = "IGNORE excluded entry not present in output: %s\n";
      if (a3 > 1) {
        goto LABEL_24;
      }
LABEL_25:
      ++v5;
      v4 += 1208;
      if (v90 == v5)
      {
        uint64_t v18 = 0;
        unint64_t v19 = 0;
        uint64_t v74 = v6 - 1320;
        uint64_t v20 = -1;
        uint64_t v89 = 16;
        uint64_t v21 = 140;
        uint64_t v87 = 1168;
        uint64_t v86 = 1208;
        uint64_t v80 = v3;
        uint64_t v22 = v77;
        while (1)
        {
          uint64_t v85 = v21;
          uint64_t v23 = v3[4];
          uint64_t v24 = (void *)(v23 + 1208 * v19);
          int v83 = v24[16 * v22 + 2];
          uint64_t v25 = v3[7];
          BOOL v26 = (const char *)(v25 + *v24);
          unint64_t v27 = v19;
          size_t v28 = strlen(v26);
          unint64_t v88 = v27;
          uint64_t v84 = v20;
          if (v28)
          {
            size_t v29 = v28;
            uint64_t v82 = v23;
            long long __s2 = v26;
            if (v22)
            {
              int v30 = 0;
              int v31 = 0;
              unint64_t v32 = v88;
              uint64_t v33 = v23;
              int32x4_t v34 = (int *)(v23 + v89);
              int v35 = 1;
              uint64_t v36 = v22;
              int v37 = v83;
              do
              {
                int v39 = *v34;
                v34 += 32;
                int v38 = v39;
                BOOL v40 = v39 == 2;
                if (v39 == 2) {
                  int v41 = 1;
                }
                else {
                  int v41 = v31;
                }
                if (v40) {
                  int v42 = v35;
                }
                else {
                  int v42 = 0;
                }
                if (v38)
                {
                  int v31 = v41;
                  int v35 = v42;
                  int v30 = 1;
                }
                --v36;
              }
              while (v36);
            }
            else
            {
              int v31 = 0;
              int v30 = 0;
              int v35 = 1;
              unint64_t v32 = v88;
              uint64_t v33 = v23;
              int v37 = v83;
            }
            if (v37 != 2 && !v31) {
              goto LABEL_94;
            }
            uint64_t v78 = v18;
            unint64_t v43 = v32 + 1;
            if (v32 + 1 >= v90)
            {
              int v44 = 0;
              unint64_t v46 = v32 + 1;
            }
            else
            {
              int v44 = 0;
              uint64_t v45 = v33 + v86;
              unint64_t v76 = v32 + 1;
              unint64_t v46 = v32 + 1;
              while (strlen((const char *)(v25 + *(void *)v45)) > v29 && *(unsigned char *)(v25 + *(void *)v45 + v29) == 47)
              {
                if (*(unsigned char *)(v45 + 1168)) {
                  int v44 = 1;
                }
                ++v46;
                v45 += 1208;
                if (v90 == v46)
                {
                  unint64_t v46 = v90;
                  break;
                }
              }
              unint64_t v43 = v76;
              uint64_t v22 = v77;
              unint64_t v32 = v88;
              uint64_t v33 = v82;
              int v37 = v83;
            }
            if (v31) {
              BOOL v47 = v37 == 2;
            }
            else {
              BOOL v47 = 1;
            }
            if (v47 && v35)
            {
              int v48 = *(_DWORD *)(v33 + 1208 * v32 + 1172);
              if (v48)
              {
                *(_DWORD *)(v33 + 1208 * v32 + 1168) |= 0x20u;
                uint64_t v18 = v78;
                if (a3 >= 2)
                {
                  fprintf((FILE *)*MEMORY[0x263EF8348], "IGNORE excluded directory: %s\n");
                  goto LABEL_93;
                }
              }
              else
              {
                int v49 = *(_DWORD *)(v33 + 1208 * v32 + (v22 << 7) + 84);
                if ((v49 & 0x800000) != 0)
                {
                  if (v46 != v43)
                  {
                    fprintf((FILE *)*MEMORY[0x263EF8348], "WARNING: firmlink directory is not empty: %s\n", __s2);
                    uint64_t v33 = v82;
                    unint64_t v32 = v88;
                  }
                  *(_DWORD *)(v33 + 1208 * v32 + 1168) |= 0x200u;
                  uint64_t v18 = v78;
                  if (a3 < 2) {
                    goto LABEL_94;
                  }
                  fprintf((FILE *)*MEMORY[0x263EF8348], "FIRMLINK directory: %s\n");
                  goto LABEL_93;
                }
                if ((v48 & 2) != 0)
                {
                  *(_DWORD *)(v33 + 1208 * v32 + 1168) |= 1u;
                  uint64_t v18 = v78;
                  if (a3 >= 2)
                  {
                    fprintf((FILE *)*MEMORY[0x263EF8348], "ARCHIVE included directory: %s\n");
                    goto LABEL_93;
                  }
                }
                else
                {
                  uint64_t v18 = v78;
                  if (!*(_DWORD *)(v33 + 1208 * v32 + (v22 << 7) + 140)
                    && !*(_DWORD *)(v33 + 1208 * v32 + (v22 << 7) + 136))
                  {
                    if (v30)
                    {
                      if (v22)
                      {
                        uint64_t v55 = v33 + 1208 * v32 + (v22 << 7);
                        uint64_t v56 = (_DWORD *)(v55 + 76);
                        int v57 = *(_DWORD *)(v55 + 72);
                        uint64_t v58 = (_DWORD *)(v55 + 80);
                        uint64_t v59 = (void *)(v55 + 128);
                        int v60 = (_DWORD *)(v33 + v85);
                        uint64_t v61 = v22;
                        while (*(v60 - 17) == v57
                             && *(v60 - 16) == *v56
                             && *(v60 - 15) == *v58
                             && *(v60 - 14) == v49
                             && *(void *)(v60 - 3) == *v59
                             && !*v60
                             && !*(v60 - 1))
                        {
                          v60 += 32;
                          if (!--v61) {
                            goto LABEL_107;
                          }
                        }
                      }
                      else
                      {
LABEL_107:
                        if (!a2)
                        {
                          *(_DWORD *)(v33 + 1208 * v32 + 1168) |= 0x10u;
                          if (a3 < 2) {
                            goto LABEL_94;
                          }
                          fprintf((FILE *)*MEMORY[0x263EF8348], "KEEP dir: %s\n");
                          goto LABEL_93;
                        }
                      }
                      *(_DWORD *)(v33 + 1208 * v32 + 1168) |= 1u;
                      if (a3 < 2) {
                        goto LABEL_94;
                      }
                      fprintf((FILE *)*MEMORY[0x263EF8348], "ARCHIVE directory with different attributes: %s\n");
                      goto LABEL_93;
                    }
                    while (__s2[v29] != 47)
                    {
                      if (!--v29) {
                        goto LABEL_120;
                      }
                    }
                    if (!v32)
                    {
LABEL_120:
                      int v64 = -1;
                      goto LABEL_125;
                    }
                    uint64_t v62 = v33 + v78;
                    uint64_t v63 = v84;
                    while (*(_DWORD *)(v62 + v74) != 2
                         || strlen((const char *)(v25 + *(void *)(v62 - 1208))) != v29
                         || memcmp((const void *)(v25 + *(void *)(v62 - 1208)), __s2, v29))
                    {
                      --v63;
                      v62 -= 1208;
                      if (v63 == -1)
                      {
                        int v64 = -1;
                        goto LABEL_124;
                      }
                    }
                    int v64 = *(_DWORD *)(v62 + v74 + 60);
LABEL_124:
                    uint64_t v18 = v78;
                    unint64_t v32 = v88;
                    uint64_t v33 = v82;
LABEL_125:
                    uint64_t v65 = v33 + 1208 * v32;
                    uint64_t v66 = (_DWORD *)(v65 + (v22 << 7));
                    int v67 = v66[18];
                    int v68 = v66[19];
                    int v69 = v66[20];
                    int v70 = (int *)(v65 + 1168);
                    int v71 = *(_DWORD *)(v65 + 1168);
                    if (!a2 && v44 && !v49 && (!v67 ? (BOOL v72 = v68 == v64) : (BOOL v72 = 0), v72 && v69 == 493))
                    {
                      *int v70 = v71 | 0x40;
                      if (a3 < 2) {
                        goto LABEL_94;
                      }
                      fprintf((FILE *)*MEMORY[0x263EF8348], "AUTO MKDIR new directory uid=%u gid=%u mode=0%04o parent_gid=%u: %s\n");
                    }
                    else
                    {
                      *int v70 = v71 | 1;
                      if (a3 < 2) {
                        goto LABEL_94;
                      }
                      fprintf((FILE *)*MEMORY[0x263EF8348], "ARCHIVE new directory uid=%u gid=%u mode=0%04o flags=0x%08x parent_gid=%u: %s\n");
                    }
LABEL_93:
                    unint64_t v32 = v88;
                    goto LABEL_94;
                  }
                  *(_DWORD *)(v33 + 1208 * v32 + 1168) |= 1u;
                  if (a3 >= 2)
                  {
                    fprintf((FILE *)*MEMORY[0x263EF8348], "ARCHIVE directory with XAT/ACL: %s\n");
                    goto LABEL_93;
                  }
                }
              }
            }
            else
            {
              uint64_t v50 = v87;
              unint64_t v51 = v32;
              if (v32 < v46)
              {
                do
                {
                  uint64_t v52 = v80[4];
                  int v53 = *(_DWORD *)(v52 + v50);
                  if ((v53 & 2) == 0)
                  {
                    uint64_t v54 = v80[1] <= v51 ? 0 : (const char *)(v80[7] + *(void *)(v52 + v50 - 1168));
                    if ((*(unsigned char *)(v52 + v50 + 4) & 3) == 0)
                    {
                      *(_DWORD *)(v52 + v50) = v53 | 2;
                      if (a3 >= 2)
                      {
                        fprintf((FILE *)*MEMORY[0x263EF8348], "REMOVE contents of removed directory: %s\n", v54);
                        uint64_t v33 = v82;
                        unint64_t v32 = v88;
                      }
                    }
                  }
                  ++v51;
                  v50 += 1208;
                }
                while (v46 != v51);
              }
              uint64_t v22 = v77;
              uint64_t v18 = v78;
              if (v37 != 2) {
                goto LABEL_94;
              }
              if ((*(_DWORD *)(v33 + 1208 * v32 + 1172) & 1) == 0)
              {
                if (v44 && !(*(_DWORD *)(v33 + 1208 * v32 + 1172) & 2 | a2)) {
                  goto LABEL_94;
                }
                *(_DWORD *)(v33 + 1208 * v32 + 1168) |= 1u;
                if (a3 < 2) {
                  goto LABEL_94;
                }
                fprintf((FILE *)*MEMORY[0x263EF8348], "ARCHIVE differing types directory: %s\n");
                goto LABEL_93;
              }
              *(_DWORD *)(v33 + 1208 * v32 + 1168) |= 0x20u;
              if (a3 >= 2)
              {
                fprintf((FILE *)*MEMORY[0x263EF8348], "IGNORE excluded directory with type change: %s\n");
                goto LABEL_93;
              }
            }
          }
          else
          {
            *(_DWORD *)(v23 + 1208 * v27 + 1168) |= 1u;
            unint64_t v32 = v27;
            if (a3 >= 2)
            {
              fwrite("ARCHIVE root directory: .\n", 0x1AuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
              goto LABEL_93;
            }
          }
LABEL_94:
          unint64_t v19 = v32 + 1;
          v89 += 1208;
          v86 += 1208;
          uint64_t v21 = v85 + 1208;
          uint64_t v20 = v84 + 1;
          v18 += 1208;
          v87 += 1208;
          uint64_t v3 = v80;
          if (v19 == v90) {
            return 0;
          }
        }
      }
    }
    if ((v10 & 3) != 0) {
      goto LABEL_25;
    }
    uint64_t v12 = v7 + v4;
    int v13 = *(_DWORD *)(v12 + 1168);
    if ((v13 & 0x100) != 0) {
      goto LABEL_25;
    }
    int v14 = v10 & 4;
    BOOL v15 = (v13 & 0x209) != 0 || v9 == 0;
    if (!v15 && v14 == 0) {
      goto LABEL_25;
    }
    *(_DWORD *)(v12 + 1168) = v13 | 2;
    uint64_t v17 = "REMOVE archive, links, firmlinks, remove rule: %s\n";
    if (a3 < 2) {
      goto LABEL_25;
    }
LABEL_24:
    fprintf((FILE *)*MEMORY[0x263EF8348], v17, v8);
    goto LABEL_25;
  }
  return 0;
}

uint64_t checkOps(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[1];
  if (v8)
  {
    unint64_t v10 = 0;
    int v11 = 1;
    uint64_t v12 = 1168;
    int v13 = (FILE **)MEMORY[0x263EF8348];
    while (1)
    {
      uint64_t v14 = a1[4];
      if (a1[1] <= v10) {
        LOBYTE(v15) = 0;
      }
      else {
        uint64_t v15 = a1[7] + *(void *)(v14 + v12 - 1168);
      }
      uint64_t v16 = v14 + v12;
      int v17 = *(_DWORD *)(v14 + v12);
      if (v17)
      {
        if ((~v17 & 5) != 0)
        {
          if ((~v17 & 6) != 0)
          {
            if ((~v17 & 0x12) != 0)
            {
              int v18 = *(_DWORD *)(v16 + 4);
              if ((v17 & 2) != 0 && (v18 & 2) != 0)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"checkOps", 2904, 18, 0, "entry is labelled REMOVE and matches INCLUDE rule: %s", a7, a8, v15);
              }
              else if (v17 & 2) != 0 && (v18)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"checkOps", 2911, 18, 0, "entry is labelled REMOVE and matches EXCLUDE rule: %s", a7, a8, v15);
              }
              else
              {
                if ((v17 & 2) != 0 || (v18 & 4) == 0) {
                  goto LABEL_24;
                }
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"checkOps", 2918, 18, 0, "entry is not labelled REMOVE and matches REMOVE rule: %s", a7, a8, v15);
              }
            }
            else
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"checkOps", 2897, 18, 0, "entry is labelled KEEP + REMOVE: %s", a7, a8, v15);
            }
          }
          else
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"checkOps", 2890, 18, 0, "entry is labelled PATCH + REMOVE: %s", a7, a8, v15);
          }
        }
        else
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"checkOps", 2883, 18, 0, "entry is labelled PATCH + ARCHIVE: %s", a7, a8, v15);
        }
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"checkOps", 2876, 18, 0, "entry is not labelled: %s", a7, a8, v15);
      }
      dumpContentsEntries(*v13, a1, v10);
      int v11 = 0;
LABEL_24:
      ++v10;
      v12 += 1208;
      if (v8 == v10) {
        goto LABEL_27;
      }
    }
  }
  int v11 = 1;
LABEL_27:
  if (v11) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

FILE *dumpContentsEntries(FILE *result, void *a2, unint64_t a3)
{
  uint64_t v3 = a2;
  uint64_t v4 = result;
  uint64_t v5 = *a2;
  if (a3 == -1) {
    unint64_t v6 = 0;
  }
  else {
    unint64_t v6 = a3;
  }
  if (a3 == -1)
  {
    unint64_t v34 = a2[1];
    if (!v34) {
      return result;
    }
  }
  else
  {
    unint64_t v34 = a3 + 1;
  }
  uint64_t v7 = 1208 * v6 + 72;
  do
  {
    uint64_t v8 = v3[4];
    fprintf(v4, "index=%zu", v6);
    uint64_t v35 = v8;
    uint64_t v9 = v8 + 1208 * v6;
    int v10 = *(_DWORD *)(v9 + 1168);
    fwrite(" ops=", 5uLL, 1uLL, v4);
    if (v10) {
      int v11 = 65;
    }
    else {
      int v11 = 45;
    }
    fputc(v11, v4);
    if ((v10 & 2) != 0) {
      int v12 = 82;
    }
    else {
      int v12 = 45;
    }
    fputc(v12, v4);
    if ((v10 & 8) != 0) {
      int v13 = 76;
    }
    else {
      int v13 = 45;
    }
    fputc(v13, v4);
    if ((v10 & 4) != 0) {
      int v14 = 80;
    }
    else {
      int v14 = 45;
    }
    fputc(v14, v4);
    if ((v10 & 0x10) != 0) {
      int v15 = 75;
    }
    else {
      int v15 = 45;
    }
    fputc(v15, v4);
    if ((v10 & 0x40) != 0) {
      int v16 = 77;
    }
    else {
      int v16 = 45;
    }
    fputc(v16, v4);
    if ((v10 & 0x20) != 0) {
      int v17 = 73;
    }
    else {
      int v17 = 45;
    }
    fputc(v17, v4);
    int v18 = *(_DWORD *)(v9 + 1172);
    fwrite(" rules=", 7uLL, 1uLL, v4);
    if (v18) {
      int v19 = 69;
    }
    else {
      int v19 = 45;
    }
    fputc(v19, v4);
    if ((v18 & 2) != 0) {
      int v20 = 73;
    }
    else {
      int v20 = 45;
    }
    fputc(v20, v4);
    if ((v18 & 4) != 0) {
      int v21 = 82;
    }
    else {
      int v21 = 45;
    }
    fputc(v21, v4);
    if ((v18 & 0x10) != 0) {
      int v22 = 101;
    }
    else {
      int v22 = 45;
    }
    fputc(v22, v4);
    if ((v18 & 0x20) != 0) {
      int v23 = 105;
    }
    else {
      int v23 = 45;
    }
    fputc(v23, v4);
    if ((v18 & 0x40) != 0) {
      int v24 = 114;
    }
    else {
      int v24 = 45;
    }
    fputc(v24, v4);
    fwrite(" labels=", 8uLL, 1uLL, v4);
    if ((v18 & 0x100) != 0) {
      int v25 = 77;
    }
    else {
      int v25 = 45;
    }
    fputc(v25, v4);
    if ((v18 & 0x400) != 0) {
      int v26 = 68;
    }
    else {
      int v26 = 45;
    }
    fputc(v26, v4);
    if ((v18 & 0x200) != 0) {
      int v27 = 80;
    }
    else {
      int v27 = 45;
    }
    fputc(v27, v4);
    if (v5)
    {
      uint64_t v28 = 0;
      uint64_t v29 = v35 + v7;
      do
      {
        fprintf(v4, " V%zu[", v28);
        uint64_t v30 = *(int *)(v29 - 56);
        if (v30 > 3) {
          uint64_t v31 = 63;
        }
        else {
          uint64_t v31 = dword_2106D45E0[v30];
        }
        fprintf(v4, "type=%c", v31);
        fprintf(v4, " uid=%u gid=%u mode=0%04o flags=0x%02x duz=%llu size=%llu link=%zu", *(_DWORD *)v29, *(_DWORD *)(v29 + 4), *(_DWORD *)(v29 + 8), *(_DWORD *)(v29 + 12), *(void *)(v29 + 40), *(void *)(v29 - 48), *(void *)(v29 - 40));
        fputc(93, v4);
        ++v28;
        v29 += 128;
      }
      while (v5 != v28);
    }
    uint64_t v3 = a2;
    if (a2[1] <= v6) {
      unint64_t v32 = 0;
    }
    else {
      unint64_t v32 = (const char *)(a2[7] + *(void *)(a2[4] + 1208 * v6));
    }
    CFIndex result = (FILE *)fprintf(v4, " path=%s\n", v32);
    ++v6;
    v7 += 1208;
  }
  while (v6 != v34);
  return result;
}

uint64_t processPatchThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v72 = *MEMORY[0x263EF8340];
  unint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
  int v10 = *(const char **)(a1 + 8);
  if (v10)
  {
    int v60 = patchCacheOpenFromURL(v10, 0, a3, a4, a5, a6, a7, a8);
    if (!v60)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"processPatchThreadProc", 3093, 18, 0, "patchCacheOpenFromURL: %s (continue without cache)", a7, a8, *(void *)(a1 + 8));
      int v60 = 0;
      int v11 = 0;
      goto LABEL_6;
    }
  }
  else
  {
    int v60 = 0;
  }
  int v11 = 1;
LABEL_6:
  unsigned int add = atomic_fetch_add(*(atomic_uint *volatile *)a1, 1u);
  if ((add & 0x80000000) == 0)
  {
    unint64_t v62 = v9;
    do
    {
      if (v9 <= add) {
        break;
      }
      unint64_t v13 = add;
      uint64_t v14 = *(void *)(a1 + 48);
      uint64_t v15 = *(void *)(v14 + 32);
      if ((*(unsigned char *)(v15 + 1208 * add + 1168) & 4) == 0) {
        goto LABEL_62;
      }
      if (*(void *)(a1 + 56))
      {
        uint64_t v16 = *(void *)v14 - 2;
        if (*(void *)v14 >= 2uLL)
        {
          unint64_t v18 = 0;
          uint64_t v19 = *(void *)v14 - 1;
          unint64_t v20 = *(void *)(v15 + 1208 * v13 + (v19 << 7) + 24);
          int v21 = (unint64_t *)(v15 + 1208 * v13 + 24);
          unint64_t v22 = v20;
          do
          {
            unint64_t v24 = *v21;
            v21 += 16;
            unint64_t v23 = v24;
            v22 += v24;
            if (v18 <= v24) {
              unint64_t v18 = v23;
            }
            --v19;
          }
          while (v19);
          int v25 = *(_DWORD *)(a1 + 44);
          if (v18 >> 28) {
            BOOL v26 = v20 >> 28 == 0;
          }
          else {
            BOOL v26 = 1;
          }
          if (v26) {
            unint64_t BXDiffMaxMemoryUsage = GetBXDiffMaxMemoryUsage(v18, v20, v25, *(_DWORD *)(a1 + 36));
          }
          else {
            unint64_t BXDiffMaxMemoryUsage = GetLargeFileMaxMemoryUsage(v18, v20, v25);
          }
          uint64_t v17 = ((unint64_t)((2
                                   * ((3 * v16 * v20) & 0x1FFFFFFFFFFFFFFFLL)
                                   * (unsigned __int128)0x28F5C28F5C28F5C3uLL) >> 64) >> 2)
              + 50 * v16 * v20 / 0x64
              + v22
              + BXDiffMaxMemoryUsage;
        }
        else
        {
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"getPatchMaxMemory", 3039, 18, "too little variants", a6, a7, a8, v59);
          uint64_t v17 = 0;
        }
        if ((MemGateReserve(*(void *)(a1 + 56), v17) & 0x80000000) != 0)
        {
          uint64_t v56 = "MemGateReserve";
          __int16 v57 = 3111;
LABEL_66:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"processPatchThreadProc", v57, 18, 0, v56, a7, a8, v59);
LABEL_67:
          int v11 = 0;
          break;
        }
        uint64_t v64 = v17;
        uint64_t v14 = *(void *)(a1 + 48);
        uint64_t v15 = *(void *)(v14 + 32);
      }
      else
      {
        uint64_t v64 = 0;
      }
      int v65 = v11;
      unint64_t v66 = v13;
      if (*(void *)(v14 + 8) <= v13) {
        uint64_t v28 = 0;
      }
      else {
        uint64_t v28 = (const char *)(*(void *)(v14 + 56) + *(void *)(v15 + 1208 * v13));
      }
      int v63 = *(_DWORD *)(a1 + 16);
      unint64_t v29 = *(void *)v14;
      int v61 = *(_DWORD *)(a1 + 40);
      uint64_t v71 = 0;
      memset(v70, 0, sizeof(v70));
      bzero(__s, 0x400uLL);
      int v68 = 0;
      memset(v67, 0, sizeof(v67));
      if (v29)
      {
        uint64_t v30 = v15 + 1208 * v13 + 88;
        uint64_t v31 = (char *)(v14 + 64);
        unint64_t v32 = v67;
        uint64_t v33 = (char **)v70;
        unint64_t v34 = v29;
        while (1)
        {
          uint64_t v35 = (char *)malloc(0x400uLL);
          if (!v35)
          {
            int v48 = *__error();
            __int16 v47 = 2962;
            int v49 = "malloc";
            goto LABEL_47;
          }
          void *v33 = v35;
          if ((concatPath(v35, 0x400uLL, v31, v28) & 0x80000000) != 0) {
            break;
          }
          long long v38 = *(_OWORD *)v30;
          int v39 = *(_DWORD *)(v30 + 16);
          v30 += 128;
          *((_DWORD *)v32 + 4) = v39;
          *unint64_t v32 = v38;
          unint64_t v32 = (_OWORD *)((char *)v32 + 20);
          v31 += 1024;
          ++v33;
          if (!--v34) {
            goto LABEL_35;
          }
        }
        char v59 = (char)v28;
        __int16 v47 = 2964;
      }
      else
      {
LABEL_35:
        if ((concatPath(__s, 0x400uLL, (char *)(v14 + 611392), v28) & 0x80000000) == 0)
        {
          size_t v40 = strlen(__s);
          makePath(__s, v40);
          unint64_t v41 = v66;
          uint64_t v42 = v15 + 1208 * v66;
          unint64_t v43 = (void *)(v42 + 1184);
          int v44 = (void *)(v42 + 1192);
          int v45 = BXDiffWithCache(v29, (const char **)v70, (uint64_t)v67, __s, v60, v63, a1 + 36, (void *)(v42 + 1184), (void *)(v42 + 1192), (atomic_ullong *)(v14 + 625056));
          if (v45 < 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"createPatch", 2983, 18, 0, "computing patch: %s", a7, a8, (char)__s);
            int v46 = 1;
          }
          else
          {
            if (!v45 || *v43 >= *v44)
            {
              if (v61 >= 2) {
                fprintf((FILE *)*MEMORY[0x263EF8348], "ARCHIVE patch is larger: %s\n", v28);
              }
              *(_DWORD *)(v15 + 1208 * v66 + 1168) = *(_DWORD *)(v15 + 1208 * v66 + 1168) & 0xFFFFFFFA | 1;
              unlink(__s);
            }
            int v46 = 0;
          }
          unint64_t v9 = v62;
          int v50 = v65;
          if (!v29) {
            goto LABEL_53;
          }
          goto LABEL_51;
        }
        char v59 = (char)v28;
        __int16 v47 = 2968;
      }
      int v48 = 0;
      int v49 = "concatPath failed: %s";
LABEL_47:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"createPatch", v47, 18, v48, v49, v36, v37, v59);
      int v46 = 1;
      unint64_t v9 = v62;
      int v50 = v65;
      unint64_t v41 = v66;
      if (!v29) {
        goto LABEL_53;
      }
LABEL_51:
      unint64_t v51 = (void **)v70;
      do
      {
        uint64_t v52 = *v51++;
        free(v52);
        --v29;
      }
      while (v29);
LABEL_53:
      if (v46)
      {
        int v53 = *(void **)(a1 + 48);
        if (v53[1] <= v41) {
          LOBYTE(v54) = 0;
        }
        else {
          uint64_t v54 = v53[7] + *(void *)(v53[4] + 1208 * v41);
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"processPatchThreadProc", 3116, 18, 0, "Patching failed %s", a7, a8, v54);
        int v50 = 0;
      }
      uint64_t v55 = *(void *)(a1 + 56);
      if (v55 && (MemGateFree(v55, v64) & 0x80000000) != 0)
      {
        uint64_t v56 = "MemGateFree";
        __int16 v57 = 3119;
        goto LABEL_66;
      }
      if (!v50) {
        goto LABEL_67;
      }
      int v11 = 1;
LABEL_62:
      unsigned int add = atomic_fetch_add(*(atomic_uint *volatile *)a1, 1u);
    }
    while ((add & 0x80000000) == 0);
  }
  patchCacheClose((uint64_t)v60, a2, a3, a4, a5, a6, a7, a8);
  if (v11) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t computePatches(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a6;
  int v9 = a5;
  int v12 = a2;
  uint64_t v76 = *MEMORY[0x263EF8340];
  int v59 = 0;
  int v14 = *(_DWORD *)(a4 + 4);
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  memset(&v65, 0, sizeof(v65));
  if (a6)
  {
    if (a6 <= 0x64) {
      unint64_t v8 = getInstalledMemorySize() / 0x64uLL * a6;
    }
    if (v8 <= 0x40000000) {
      unint64_t v8 = 0x40000000;
    }
    if ((MemGateInit(&v65, v8, v9, a4, a5, a6, a7, a8) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"computePatches", 3152, 18, 0, "MemGateInit", a7, a8, v58);
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      unint64_t v20 = 0;
      int v21 = 0;
      unint64_t v8 = 1;
      goto LABEL_38;
    }
  }
  if (v14 >= 1)
  {
    uint64_t v15 = *(void *)(a3 + 8);
    if (v15)
    {
      uint64_t v16 = 0;
      uint64_t v17 = (unsigned int *)(*(void *)(a3 + 32) + 1168);
      do
      {
        v16 += ((unint64_t)*v17 >> 2) & 1;
        v17 += 302;
        --v15;
      }
      while (v15);
    }
    else
    {
      LOBYTE(v16) = 0;
    }
    long long v63 = 0u;
    long long v64 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    *(_OWORD *)__str = 0u;
    if (v8) {
      snprintf(__str, 0x50uLL, "(memoryLimit %llu MB)", v8 >> 20);
    }
    pc_info("Generating patches for %zu entries on %d threads %s\n", a2, a3, a4, a5, a6, a7, a8, v16);
  }
  unint64_t v20 = (char *)calloc(v9, 0x40uLL);
  unint64_t v22 = (char *)malloc(8 * v9);
  uint64_t v19 = v22;
  if (!v20 || !v22)
  {
    int v40 = *__error();
    unint64_t v41 = "malloc";
    __int16 v42 = 3171;
LABEL_34:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"computePatches", v42, 18, v40, v41, v31, v32, v58);
    uint64_t v18 = 0;
    int v21 = 0;
    goto LABEL_38;
  }
  if (v9 < 1)
  {
    unint64_t v43 = ThreadPoolCreate(v9, (uint64_t)v22, (uint64_t)processPatchThreadProc);
    if (v43)
    {
      uint64_t v18 = (uint64_t)v43;
      int v21 = 1;
      goto LABEL_38;
    }
    goto LABEL_33;
  }
  uint64_t v23 = 0;
  unint64_t v24 = v20;
  do
  {
    *(void *)&v22[v23] = v24;
    v23 += 8;
    v24 += 64;
  }
  while (8 * v9 != v23);
  int v25 = ThreadPoolCreate(v9, (uint64_t)v22, (uint64_t)processPatchThreadProc);
  if (!v25)
  {
LABEL_33:
    unint64_t v41 = "ThreadPoolCreate";
    __int16 v42 = 3174;
    int v40 = 0;
    goto LABEL_34;
  }
  uint64_t v18 = (uint64_t)v25;
  if (v8) {
    uint64_t v33 = &v65;
  }
  else {
    uint64_t v33 = 0;
  }
  while (1)
  {
    uint64_t Worker = ThreadPoolGetWorker(v18, v26, v27, v28, v29, v30, v31, v32);
    if (!Worker)
    {
      int v44 = "ThreadPoolGetWorker";
      __int16 v45 = 3180;
      goto LABEL_37;
    }
    *(void *)(Worker + 48) = a3;
    *(void *)uint64_t Worker = &v59;
    *(void *)(Worker + 8) = a1;
    *(_DWORD *)(Worker + 16) = v12;
    uint64_t v39 = *(void *)a4;
    *(_DWORD *)(Worker + 44) = *(_DWORD *)(a4 + 8);
    *(void *)(Worker + 36) = v39;
    *(void *)(Worker + 56) = v33;
    if ((ThreadPoolRunWorker(v18, Worker, v35, v36, v37, v38, v31, v32) & 0x80000000) != 0) {
      break;
    }
    if (!--v9)
    {
      int v21 = 1;
      goto LABEL_38;
    }
  }
  int v44 = "ThreadPoolRunWorker";
  __int16 v45 = 3187;
LABEL_37:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"computePatches", v45, 18, 0, v44, v31, v32, v58);
  int v21 = 0;
LABEL_38:
  if ((ThreadPoolDestroy(v18) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"computePatches", 3192, 18, 0, "ThreadPoolDestroy", v46, v47, v58);
    int v21 = 0;
  }
  free(v20);
  free(v19);
  if (v8 && (MemGateDestroy(&v65, v48, v49, v50, v51, v52, v53, v54) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"computePatches", 3195, 18, 0, "MemGateDestroy", v55, v56, v58);
    int v21 = 0;
  }
  if (v21) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t DirectoryDiff(uint64_t DefaultNThreads, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = DefaultNThreads;
  uint64_t v225 = *MEMORY[0x263EF8340];
  uint64_t v10 = *(unsigned int *)(DefaultNThreads + 84);
  int v9 = *(_DWORD *)(DefaultNThreads + 88);
  if (!v10)
  {
    int DefaultNThreads = getDefaultNThreads();
    uint64_t v10 = DefaultNThreads;
  }
  uint64_t v11 = *(void *)v8;
  if (*(void *)v8 >= 9uLL)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5575, 18, 0, "n > %d not supported", a7, a8, 8);
    return 0xFFFFFFFFLL;
  }
  memset(&v222, 0, sizeof(v222));
  unint64_t v13 = (FILE **)*(unsigned int *)(v8 + 92);
  enterThreadErrorContext(DefaultNThreads, a2, a3, a4, a5, a6, a7, a8, v208);
  int v14 = (char *)malloc(0x989F0uLL);
  uint64_t v15 = (uint64_t)v14;
  uint64_t v16 = v14 + 611392;
  if (!v14)
  {
    int v48 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5590, 18, v48, "malloc", v49, v50, v209);
    goto LABEL_54;
  }
  int v217 = (int8x16_t *)(v14 + 611392);
  uint64_t v224 = 0;
  unsigned int v215 = (v13 >> 1) & 1;
  int v216 = v9;
  int v214 = (unint64_t *)(v14 + 625056);
  memset(v223, 0, sizeof(v223));
  bzero(v14, 0x989F0uLL);
  uint64_t v24 = 0;
  uint64_t v25 = v15;
  uint64_t v26 = 0;
  *(_DWORD *)(v25 + 24) = 1;
  uint64_t v27 = (const char **)(v8 + 24);
  uint64_t v219 = v11;
  uint64_t v220 = v8;
  uint64_t v28 = (const char **)(v8 + 32);
  uint64_t v29 = v11 + 1;
  size_t v218 = (char *)v25;
  while (1)
  {
    uint64_t v30 = v27;
    if (v26 < v11) {
      uint64_t v30 = (const char **)(*(void *)(v220 + 8) + v24);
    }
    uint64_t v31 = v13;
    int v32 = v13 & 1;
    uint64_t v33 = *v30;
    if (*v30) {
      BOOL v34 = 1;
    }
    else {
      BOOL v34 = v32 == 0;
    }
    if (v34)
    {
      if (!realpath_DARWIN_EXTSN(*v30, (char *)(v25 + 64)))
      {
        int v52 = *__error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5603, 18, v52, "%s", v53, v54, (char)v33);
LABEL_60:
        unsigned int v51 = -1;
        uint64_t v15 = (uint64_t)v218;
        LODWORD(v11) = v219;
        goto LABEL_61;
      }
      uint64_t v11 = v219;
      if (stat((const char *)(v25 + 64), &v222) || (v222.st_mode & 0xF000) != 0x4000)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5604, 18, 0, "Not a directory: %s", v22, v23, (char)v33);
        goto LABEL_57;
      }
    }
    uint64_t v35 = v28;
    if (v26 >= v11) {
      break;
    }
    uint64_t v36 = *(void *)(v220 + 16);
    if (v36)
    {
      uint64_t v35 = (const char **)(v36 + v24);
      break;
    }
LABEL_24:
    ++v26;
    v25 += 1024;
    v24 += 8;
    unint64_t v13 = v31;
    if (v29 == v26)
    {
      uint64_t v8 = v220;
      if (!*(void *)(v220 + 40))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5616, 18, 0, "Missing patchFilename", v22, v23, v209);
        unsigned int v51 = -1;
        uint64_t v16 = (char *)v217;
        uint64_t v15 = (uint64_t)v218;
        goto LABEL_63;
      }
      int v38 = v216;
      uint64_t v15 = (uint64_t)v218;
      if (v216 >= 1)
      {
        pc_info("DirectoryDiff:\n", v17, v18, v19, v20, v21, v22, v23, v209);
        if ((int)v11 >= 1)
        {
          uint64_t v39 = 0;
          int v40 = (FILE **)MEMORY[0x263EF8348];
          do
          {
            unint64_t v41 = &v218[1024 * v39];
            if (v41[64]) {
              fprintf(*v40, "  input directory %d: %s\n", v39 + 1, v41 + 64);
            }
            ++v39;
            if (v41[9280]) {
              fprintf(*v40, "  input manifest %d: %s\n", v39, v41 + 9280);
            }
          }
          while (v39 != v219);
        }
        LODWORD(v11) = v219;
        __int16 v42 = &v218[1024 * (unint64_t)v219];
        if (v42[64]) {
          fprintf((FILE *)*MEMORY[0x263EF8348], "  output directory: %s\n", v42 + 64);
        }
        if (v42[9280]) {
          fprintf((FILE *)*MEMORY[0x263EF8348], "  output manifest: %s\n", v42 + 9280);
        }
        unint64_t v13 = (FILE **)MEMORY[0x263EF8348];
        unint64_t v43 = "patch file";
        if (v31) {
          unint64_t v43 = "diff list file";
        }
        fprintf((FILE *)*MEMORY[0x263EF8348], "  %s: %s\n", v43, *(const char **)(v220 + 40));
        if (*(void *)(v220 + 48))
        {
          fprintf(*v13, "  cache URL: %s\n", *(const char **)(v220 + 48));
          if (*(_DWORD *)(v220 + 56)) {
            int v44 = "yes";
          }
          else {
            int v44 = "no";
          }
          fprintf(*v13, "  update cache: %s\n", v44);
        }
        unint64_t v45 = *(void *)(v220 + 96);
        int v38 = v216;
        if (v45)
        {
          if (v45 <= 0x64) {
            v45 *= getInstalledMemorySize() / 0x64uLL;
          }
          unint64_t v46 = 0x40000000;
          if (v45 > 0x40000000) {
            unint64_t v46 = v45;
          }
          fprintf(*v13, "  soft memory limit: %llu MB\n", v46 >> 20);
        }
        uint64_t v47 = *v13;
        if (*(_DWORD *)(v220 + 80)) {
          fprintf(v47, "  diff level: %d\n");
        }
        else {
          fprintf(v47, "  diff level: default (%d)\n");
        }
        fprintf(*v13, "  worker threads: %d\n", v10);
        fprintf(*v13, "  patch threads: %d\n", v10);
        fprintf(*v13, "  min patch size: %llu B\n", *(void *)(v220 + 64));
        fprintf(*v13, "  archive block size: %zu B\n", *(void *)(v220 + 72));
        dumpStringArray((uint64_t)"excludeList", *(CFArrayRef *)(v220 + 104), v60, v61, v62, v63, v64, v65, v210);
        dumpStringArray((uint64_t)"includeList", *(CFArrayRef *)(v220 + 112), v66, v67, v68, v69, v70, v71, v211);
        dumpStringArray((uint64_t)"noExcludeList", *(CFArrayRef *)(v220 + 120), v72, v73, v74, v75, v76, v77, v212);
        dumpStringArray((uint64_t)"noIncludeList", *(CFArrayRef *)(v220 + 128), v78, v79, v80, v81, v82, v83, v213);
        LOBYTE(v13) = (_BYTE)v31;
      }
      uint64_t v16 = (char *)v217;
      if ((v13 & 1) == 0)
      {
        snprintf(v218 + 611392, 0x400uLL, "%s_tmp_XXXXXX", *(const char **)(v220 + 40));
        size_t v84 = strlen(v218 + 611392);
        makePath(v218 + 611392, v84);
        if (!mkdtemp(v218 + 611392))
        {
          int v114 = *__error();
          __int16 v115 = 5663;
          long long v116 = v218 + 611392;
          goto LABEL_159;
        }
      }
      uint64_t v85 = (v11 + 1);
      uint64_t v86 = v223;
      uint64_t v87 = v218;
      while (1)
      {
        getRealTime();
        if (v87[9280])
        {
          if ((loadManifest(v87 + 9280, (uint64_t)v86) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5672, 18, 0, "loading manifest %s", v88, v89, (_BYTE)v87 + 64);
LABEL_95:
            unsigned int v51 = -1;
            uint64_t v15 = (uint64_t)v218;
            LODWORD(v11) = v219;
            goto LABEL_62;
          }
          getRealTime();
          if (v38 >= 1)
          {
            pc_info("Loaded manifest:  %s (%.1fs)\n", v90, v91, v92, v93, v94, v95, v96, (_BYTE)v87 + 64);
LABEL_86:
            dumpContentsStats((uint64_t)v86);
          }
        }
        else
        {
          if ((loadDirectory(v87 + 64, v10, (size_t)v86) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5678, 18, 0, "loading directory %s", v97, v98, (_BYTE)v87 + 64);
            goto LABEL_95;
          }
          getRealTime();
          if (v38 >= 1)
          {
            pc_info("Loaded directory: %s (%.1fs)\n", v99, v100, v101, v102, v103, v104, v105, (_BYTE)v87 + 64);
            goto LABEL_86;
          }
        }
        uint64_t v86 = (_OWORD *)((char *)v86 + 56);
        v87 += 1024;
        if (!--v85)
        {
          uint64_t v15 = (uint64_t)v218;
          LODWORD(v11) = v219;
          if ((mergeContents(v219 + 1, (uint64_t)v223, v218) & 0x80000000) != 0)
          {
            long long v116 = "merging contents";
            __int16 v115 = 5686;
            goto LABEL_158;
          }
          if (v38 < 1
            || (pc_info("Merged %zu inputs and 1 output\n", v106, v107, v108, v109, v110, v111, v112, *v218 - 1),
                v38 == 1))
          {
            int v113 = 0;
            goto LABEL_119;
          }
          uint64_t v117 = *((void *)v218 + 1);
          if (v117)
          {
            uint64_t v118 = 0;
            uint64_t v119 = 0;
            uint64_t v11 = 0;
            uint64_t v120 = 0;
            uint64_t v121 = 0;
            uint64_t v122 = *((void *)v218 + 4);
            uint64_t v123 = *(void *)v218;
            unint64_t v124 = *(void *)v218 - 1;
            unint64_t v125 = (int *)(v122 + 144);
            while (1)
            {
              if (*(_DWORD *)(v122 + 1208 * v118 + (v124 << 7) + 16))
              {
                if (*(void *)v218 == 1) {
                  goto LABEL_113;
                }
                if (*(_DWORD *)(v122 + 1208 * v118 + 16))
                {
                  uint64_t v126 = v125;
                  uint64_t v127 = 2;
                  do
                  {
                    uint64_t v128 = v127;
                    if (v123 == v127) {
                      break;
                    }
                    int v129 = *v126;
                    v126 += 32;
                    ++v127;
                  }
                  while (v129);
                  if (v128 - 1 >= v124)
                  {
LABEL_113:
                    ++v119;
                    goto LABEL_115;
                  }
                }
                else
                {
                  uint64_t v130 = 0;
                  uint64_t v131 = 2;
                  do
                  {
                    uint64_t v132 = v131;
                    if (v123 == v131) {
                      break;
                    }
                    int v133 = v125[v130];
                    ++v131;
                    v130 += 32;
                  }
                  while (!v133);
                  if (v132 - 1 >= v124)
                  {
                    ++v120;
                    goto LABEL_115;
                  }
                }
                ++v11;
              }
              else
              {
                ++v121;
              }
LABEL_115:
              ++v118;
              v125 += 302;
              if (v118 == v117) {
                goto LABEL_118;
              }
            }
          }
          uint64_t v121 = 0;
          uint64_t v120 = 0;
          uint64_t v11 = 0;
          uint64_t v119 = 0;
LABEL_118:
          uint64_t v134 = (FILE **)MEMORY[0x263EF8348];
          fprintf((FILE *)*MEMORY[0x263EF8348], "%12zu not in the output\n", v121);
          fprintf(*v134, "%12zu in the output, and in all inputs\n", v119);
          fprintf(*v134, "%12zu in the output, and in some but not all inputs\n", v11);
          fprintf(*v134, "%12zu in the output, and not in any inputs\n", v120);
          int v113 = 1;
          LODWORD(v11) = v219;
LABEL_119:
          if ((applyRules(*(const __CFArray **)(v220 + 104), *(const __CFArray **)(v220 + 112), 0, *(const __CFArray **)(v220 + 120), *(const __CFArray **)(v220 + 128), 0, 0, 0, (uint64_t *)v218, v38) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5720, 18, 0, "applyRules", v135, v136, v209);
            unsigned int v51 = -1;
            uint64_t v8 = v220;
            goto LABEL_63;
          }
          if ((initOps(*(void *)(v220 + 64), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, v215, (uint64_t *)v218, v38) & 0x80000000) != 0)
          {
            long long v116 = "initOps";
            __int16 v115 = 5723;
            goto LABEL_158;
          }
          if (v113)
          {
            pc_info("Initial labels (regular files / symbolic links)\n", v137, v138, v139, v140, v141, v111, v112, v209);
            dumpContentsStats((uint64_t)v218);
          }
          uint64_t v142 = *((void *)v218 + 1);
          if (v142)
          {
            uint64_t v143 = 0;
            __int16 v144 = (unsigned int *)(*((void *)v218 + 4) + 1168);
            do
            {
              v143 += ((unint64_t)*v144 >> 2) & 1;
              v144 += 302;
              --v142;
            }
            while (v142);
            if ((v31 & 1) == 0)
            {
              if (!v143) {
                goto LABEL_148;
              }
              v221.st_dev = *(_DWORD *)(v220 + 80);
              *(_DWORD *)&v221.char st_mode = v38;
              LODWORD(v221.st_ino) = v10;
              double RealTime = getRealTime();
              if ((computePatches(*(void *)(v220 + 48), *(unsigned int *)(v220 + 56), (uint64_t)v218, (uint64_t)&v221, v10, *(void *)(v220 + 96), v146, v147) & 0x80000000) != 0)
              {
                long long v116 = "computePatches";
                __int16 v115 = 5755;
              }
              else
              {
                if (v38 >= 1)
                {
                  unint64_t v153 = v214;
                  uint64_t v154 = v214 + 1;
                  unint64_t v155 = atomic_load(v214 + 1);
                  unint64_t v156 = atomic_load(v153 + 4);
                  unint64_t v157 = atomic_load(v153);
                  unint64_t v158 = atomic_load(v153 + 3);
                  uint64_t v159 = v158 + v157;
                  double v160 = getRealTime() - RealTime;
                  pc_info("Generated patches (%.1f s)\n", v161, v162, v163, v164, v165, v166, v167, SLOBYTE(v160));
                  uint64_t v168 = (FILE **)MEMORY[0x263EF8348];
                  uint64_t v169 = (FILE *)*MEMORY[0x263EF8348];
                  unint64_t v170 = atomic_load(v153);
                  fprintf(v169, "%12lld 1:1 patches cache lookups\n", v170);
                  BOOL v171 = *v168;
                  unint64_t v172 = atomic_load(v154);
                  int v38 = v216;
                  fprintf(v171, "%12lld 1:1 patches cache hits\n", v172);
                  unsigned int v173 = *v168;
                  unint64_t v174 = atomic_load(v153 + 2);
                  fprintf(v173, "%12lld 1:1 patches cache updates\n", v174);
                  int v175 = *v168;
                  unint64_t v176 = atomic_load(v153 + 6);
                  fprintf(v175, "%12lld 1:1 patches created\n", v176);
                  uint64_t v177 = *v168;
                  unint64_t v178 = atomic_load(v153 + 3);
                  fprintf(v177, "%12lld combo patches cache lookups\n", v178);
                  uint64_t v179 = *v168;
                  unint64_t v180 = atomic_load(v153 + 4);
                  fprintf(v179, "%12lld combo patches cache hits\n", v180);
                  uint64_t v181 = *v168;
                  unint64_t v182 = atomic_load(v153 + 5);
                  fprintf(v181, "%12lld combo patches cache updates\n", v182);
                  unint64_t v183 = *v168;
                  unint64_t v184 = atomic_load(v153 + 7);
                  fprintf(v183, "%12lld combo patches created\n", v184);
                  unint64_t v185 = *v168;
                  unint64_t v186 = atomic_load(v153 + 8);
                  fprintf(v185, "%12lld cache lookups FAILED\n", v186);
                  int v187 = *v168;
                  unint64_t v188 = atomic_load(v153 + 9);
                  fprintf(v187, "%12lld cache updates FAILED\n", v188);
                  if (v159 >= 1) {
                    fprintf(*v168, "%11.0f%% cache hits\n", (double)(uint64_t)(v156 + v155) * 100.0 / (double)v159);
                  }
                }
                uint64_t v15 = (uint64_t)v218;
                if (v113)
                {
                  pc_info("Updated labels after patch generation\n", v148, v149, v150, v151, v152, v111, v112, v209);
                  dumpContentsStats((uint64_t)v218);
                }
                LODWORD(v11) = v219;
LABEL_148:
                updateOps((void *)v15, 0, v38);
                if (v38 >= 1)
                {
                  pc_info("Final labels (all entries)\n", v195, v196, v197, v198, v199, v200, v201, v209);
                  dumpContentsStats(v15);
                }
                if ((checkOps((void *)v15, v195, v196, v197, v198, v199, v200, v201) & 0x80000000) == 0)
                {
                  if ((generatePatch() & 0x80000000) != 0)
                  {
                    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5797, 18, 0, "generatePatch", v202, v203, v209);
                    unsigned int v51 = -1;
                    uint64_t v8 = v220;
                  }
                  else
                  {
                    uint64_t v204 = *(int8x16_t **)(v220 + 136);
                    uint64_t v8 = v220;
                    unsigned int v51 = 0;
                    if (v204)
                    {
                      *uint64_t v204 = v217[852];
                      v204[1] = vextq_s8(v217[853], v217[853], 8uLL);
                    }
                  }
                  goto LABEL_63;
                }
                long long v116 = "checkOps";
                __int16 v115 = 5794;
              }
LABEL_158:
              int v114 = 0;
LABEL_159:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", v115, 18, v114, v116, v111, v112, v209);
              unsigned int v51 = -1;
              goto LABEL_62;
            }
          }
          else
          {
            if ((v31 & 1) == 0) {
              goto LABEL_148;
            }
            LOBYTE(v143) = 0;
          }
          if (v38 >= 1) {
            pc_info("Generating diff list, %zu entries\n", v137, v138, v139, v140, v141, v111, v112, v143);
          }
          uint64_t v8 = v220;
          uint64_t v189 = fopen(*(const char **)(v220 + 40), "w");
          if (v189)
          {
            uint64_t v190 = v189;
            unint64_t v191 = *((void *)v218 + 1);
            if (v191)
            {
              unint64_t v192 = 0;
              uint64_t v193 = 1168;
              do
              {
                uint64_t v194 = *((void *)v218 + 4);
                if ((*(unsigned char *)(v194 + v193) & 4) != 0)
                {
                  fprintf(v190, "%s\n", (const char *)(*((void *)v218 + 7) + *(void *)(v194 + v193 - 1168)));
                  unint64_t v191 = *((void *)v218 + 1);
                }
                ++v192;
                v193 += 1208;
              }
              while (v192 < v191);
            }
            fclose(v190);
            unsigned int v51 = 0;
            goto LABEL_62;
          }
          int v205 = *__error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5740, 18, v205, "%s", v206, v207, *(void *)(v220 + 40));
LABEL_54:
          unsigned int v51 = -1;
          goto LABEL_63;
        }
      }
    }
  }
  uint64_t v37 = *v35;
  if (!*v35) {
    goto LABEL_24;
  }
  if (!realpath_DARWIN_EXTSN(*v35, (char *)(v25 + 9280)))
  {
    int v55 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5612, 18, v55, "%s", v56, v57, (char)v37);
    goto LABEL_60;
  }
  uint64_t v11 = v219;
  if (!stat((const char *)(v25 + 9280), &v222) && (v222.st_mode & 0xF000) == 0x8000) {
    goto LABEL_24;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5613, 18, 0, "Not a regular file: %s", v22, v23, (char)v37);
LABEL_57:
  unsigned int v51 = -1;
  uint64_t v15 = (uint64_t)v218;
LABEL_61:
  uint64_t v16 = (char *)v217;
LABEL_62:
  uint64_t v8 = v220;
LABEL_63:
  memset(&v221, 0, sizeof(v221));
  if (*v16 && !stat(v16, &v221) && (v221.st_mode & 0xF000) == 0x4000) {
    removeTree(v16);
  }
  if ((v11 & 0x80000000) == 0)
  {
    uint64_t v58 = (v11 + 1);
    int v59 = (void **)&v223[1] + 1;
    do
    {
      free(*(v59 - 1));
      BlobBufferFree((uint64_t)v59);
      v59 += 7;
      --v58;
    }
    while (v58);
  }
  free(*(void **)(v15 + 32));
  BlobBufferFree(v15 + 40);
  free((void *)v15);
  LODWORD(result) = leaveThreadErrorContext(*(__CFError ***)(v8 + 144), 0, 0);
  if ((int)result >= 0) {
    return v51;
  }
  else {
    return result;
  }
}

uint64_t generatePatch()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  unsigned int v8 = v4;
  int v9 = v3;
  uint64_t v10 = (char *)v2;
  uint64_t v118 = (char *)v1;
  uint64_t v11 = (const char *)v0;
  v137[3] = *MEMORY[0x263EF8340];
  uint64_t v13 = *v2;
  uint64_t v12 = v2[1];
  int v14 = v2 + 78128;
  unint64_t v124 = 0;
  unint64_t v125 = 0;
  if ((int)v4 >= 1)
  {
    uint64_t v15 = "combo delta";
    if (v13 == 2) {
      uint64_t v15 = "delta";
    }
    if (v13 == 1) {
      uint64_t v15 = "full replacement";
    }
    pc_info("Generating %s directory patch\n", v1, (uint64_t)v2, v3, v4, v5, v6, v7, (char)v15);
  }
  long long v122 = 0u;
  long long v123 = 0u;
  memset(v137, 0, 20);
  uint64_t __buf = 0;
  v14[2] = 0;
  v14[3] = 0;
  uint64_t v16 = v14 + 2;
  uint64_t v17 = 0;
  if (v12)
  {
    uint64_t v18 = *((void *)v10 + 4) - 112;
    uint64_t v19 = v12;
    do
    {
      if (*(_DWORD *)(v18 + (v13 << 7)) == 1) {
        v17 += *(_DWORD *)(v18 + 1280) & 1;
      }
      v18 += 1208;
      --v19;
    }
    while (v19);
  }
  uint64_t v20 = OFileStreamCreateWithFilename(v11, -1);
  uint64_t v23 = v20;
  if (!v20)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4502, 18, 0, "creating output file: %s", v21, v22, (char)v11);
LABEL_45:
    uint64_t v56 = 0;
    uint64_t v57 = 0;
LABEL_46:
    uint64_t v58 = 0;
    uint64_t v59 = 0;
LABEL_47:
    uint64_t v60 = 0xFFFFFFFFLL;
    goto LABEL_48;
  }
  memset(v137, 0, 20);
  uint64_t __buf = 0x3031464649444944;
  if (OFileStreamWrite((uint64_t)v20, (char *)&__buf, 0x1CuLL) != 28)
  {
    uint64_t v54 = "write DIDIFF10 header";
    __int16 v55 = 4508;
LABEL_44:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", v55, 18, 0, v54, v24, v25, v110);
    goto LABEL_45;
  }
  off_t Pos = OFileStreamGetPos(v23);
  *(void *)&long long v123 = 0;
  *((void *)&v123 + 1) = v23;
  *((void *)&v122 + 1) = OFileStreamWrite;
  *(void *)&long long v122 = v8;
  uint64_t v27 = ParallelArchiveWriterCreateLegacy(&v122);
  if (!v27)
  {
    uint64_t v54 = "creating YAA writer";
    __int16 v55 = 4519;
    goto LABEL_44;
  }
  int v112 = v9;
  int v113 = v14;
  uint64_t v114 = v13;
  off_t v111 = Pos;
  uint64_t v119 = v27;
  long long v116 = v23;
  int v115 = v8;
  uint64_t v121 = v12;
  if (v12)
  {
    uint64_t v28 = 0;
    uint64_t v120 = 0;
    unint64_t v29 = 0;
    uint64_t v30 = v114 << 7;
    while (1)
    {
      uint64_t v31 = *((void *)v10 + 4);
      if (*((void *)v10 + 1) <= v29) {
        int v32 = 0;
      }
      else {
        int v32 = (const char *)(*((void *)v10 + 7) + *(void *)(v31 + v28));
      }
      int v33 = *(_DWORD *)(v31 + v30 + v28 - 112);
      if (!v33 || v33 == 1 && (*(_DWORD *)(v31 + v28 + 1168) & 9) == 1) {
        goto LABEL_39;
      }
      bzero(&v130, 0x890uLL);
      bzero(v127, 0x408uLL);
      LODWORD(v130) = 1;
      if (v33 != 1) {
        break;
      }
      if ((*(unsigned char *)(v31 + v28 + 1168) & 8) != 0)
      {
        uint64_t v130 = 0x4800010001;
LABEL_31:
        __strlcpy_chk();
        goto LABEL_32;
      }
      uint64_t v130 = 0x4600002001;
      uint64_t v36 = v31 + v30 + v28;
      long long v37 = *(_OWORD *)(v36 - 40);
      int v135 = *(_DWORD *)(v36 - 24);
      long long v134 = v37;
      LODWORD(v130) = 8321;
      uint64_t v132 = *(void *)(v36 - 104);
LABEL_32:
      LODWORD(v130) = v130 | 0x8000;
      __strlcpy_chk();
      LODWORD(v130) = v130 | 0x1E;
      int32x4_t v42 = vrev64q_s32(*(int32x4_t *)(v31 + v28 + v30 - 56));
      v42.i64[0] = *(void *)(v31 + v28 + v30 - 56);
      v131[0] = v42;
      if ((*(unsigned char *)(v31 + v28 + 1168) & 4) != 0)
      {
        bzero(v126, 0x400uLL);
        concatPath(v126, 0x400uLL, v10 + 611392, v32);
        *v16 += *(void *)(v31 + v30 + v28 - 16);
        if (loadFileContents(v126, (char **)&v125, (off_t *)&v124, 0))
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4597, 18, 0, "load patch: %s", v47, v48, (char)v126);
          goto LABEL_84;
        }
        qmemcpy(v127, "BXP", 3);
        int v128 = 2;
        unint64_t v129 = v124;
        if (ParallelArchiveWriteEntryHeader((uint64_t)v119, (uint64_t)&v130, (uint64_t)v127, 1, v45, v46, v47, v48))
        {
LABEL_75:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4605, 18, 0, "write entry header: %s", v43, v44, (char)v32);
LABEL_84:
          uint64_t v56 = 0;
          uint64_t v57 = 0;
          uint64_t v59 = 0;
          goto LABEL_85;
        }
        if (ParallelArchiveWriteEntryData((uint64_t)v119, (uint64_t)v125, v124, v49, v50, v51, v43, v44))
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4608, 18, 0, "write entry data: %s", v52, v53, (char)v32);
          goto LABEL_84;
        }
      }
      else if (ParallelArchiveWriteEntryHeader((uint64_t)v119, (uint64_t)&v130, (uint64_t)v127, 0, v38, v39, v40, v41))
      {
        goto LABEL_75;
      }
      ++v120;
      free(v125);
      unint64_t v125 = 0;
LABEL_39:
      ++v29;
      v28 += 1208;
      if (v121 == v29) {
        goto LABEL_50;
      }
    }
    if (v33 != 3)
    {
      if (v33 != 2)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4574, 18, 0, "invalid entry type: %s", v34, v35, (char)v32);
        goto LABEL_84;
      }
      HIDWORD(v130) = 68;
      goto LABEL_32;
    }
    uint64_t v130 = 0x4C00010001;
    goto LABEL_31;
  }
  uint64_t v120 = 0;
LABEL_50:
  ParallelArchiveWriterDestroy(v119);
  uint64_t v23 = v116;
  off_t v69 = OFileStreamGetPos(v116);
  int v70 = v8;
  if (!v17)
  {
    uint64_t v57 = 0;
    goto LABEL_69;
  }
  uint64_t v71 = OEncoderStreamCreate((uint64_t)OFileStreamWrite, (uint64_t)OFileStreamAbort, (uint64_t)v116, (unint64_t)v118, 1, (uint64_t)v118, v112);
  uint64_t v59 = v71;
  if (!v71)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4624, 18, 0, "create archive encoder", v72, v73, v110);
    uint64_t v56 = 0;
    uint64_t v57 = 0;
    uint64_t v58 = 0;
    goto LABEL_47;
  }
  *(void *)&long long v123 = 0;
  *((void *)&v123 + 1) = v71;
  *((void *)&v122 + 1) = OEncoderStreamWrite;
  *(void *)&long long v122 = v8;
  uint64_t v58 = ParallelArchiveWriterCreateLegacy(&v122);
  if (!v58)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4632, 18, 0, "create YAA writer", v74, v75, v110);
    uint64_t v56 = 0;
    uint64_t v57 = 0;
    goto LABEL_47;
  }
  uint64_t v57 = (unint64_t *)MemBufferCreate(0x100000uLL);
  if (!v57)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4636, 18, 0, "create DAT buffer", v76, v77, v110);
    uint64_t v56 = 0;
    goto LABEL_47;
  }
  off_t v117 = v69;
  uint64_t v119 = v58;
  if (!v121)
  {
LABEL_67:
    ParallelArchiveWriterDestroy(v119);
    OEncoderStreamDestroy(v59, v97, v98, v99, v100, v101, v102, v103);
    uint64_t v23 = v116;
    off_t v69 = v117;
    int v70 = v115;
LABEL_69:
    off_t v104 = OFileStreamGetPos(v23);
    if (OFileStreamSetPos(v23, 0) < 0)
    {
      uint64_t v108 = "seek to patch beginning";
      __int16 v109 = 4700;
    }
    else
    {
      *(void *)((char *)v137 + 4) = v69 - v111;
      *(void *)((char *)&v137[1] + 4) = v104 - v69;
      if (OFileStreamWrite((uint64_t)v23, (char *)&__buf, 0x1CuLL) == 28)
      {
        *int v113 = v104;
        v113[1] = v104 - v69;
        if (v70 >= 1)
        {
          uint64_t v107 = (FILE **)MEMORY[0x263EF8348];
          fprintf((FILE *)*MEMORY[0x263EF8348], "%12lld header size\n", v111);
          fprintf(*v107, "%12zu entries in diff payload\n", v120);
          fprintf(*v107, "%12lld diff payload size\n", v69 - v111);
          fprintf(*v107, "%12zu entries in archive payload\n", v17);
          fprintf(*v107, "%12llu archive payload size\n", v113[1]);
          fprintf(*v107, "%12llu patch size\n", *v113);
          fprintf(*v107, "%12llu patched files disk usage\n", v113[2]);
          fprintf(*v107, "%12llu archived files disk usage\n", v113[3]);
        }
        uint64_t v56 = 0;
        uint64_t v58 = 0;
        uint64_t v59 = 0;
        uint64_t v60 = 0;
        goto LABEL_48;
      }
      uint64_t v108 = "update DIDIFF10 header";
      __int16 v109 = 4703;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", v109, 18, 0, v108, v105, v106, v110);
    uint64_t v56 = 0;
    goto LABEL_46;
  }
  uint64_t v78 = 0;
  unint64_t v79 = 0;
  uint64_t v80 = v114 << 7;
  while (1)
  {
    uint64_t v81 = *((void *)v10 + 4);
    if (*((void *)v10 + 1) <= v79) {
      uint64_t v82 = 0;
    }
    else {
      uint64_t v82 = (const char *)(*((void *)v10 + 7) + *(void *)(v81 + v78));
    }
    bzero(v127, 0x400uLL);
    if (*(_DWORD *)(v81 + v80 + v78 - 112) != 1 || (*(_DWORD *)(v81 + v78 + 1168) & 9) != 1) {
      goto LABEL_66;
    }
    concatPath((char *)v127, 0x400uLL, &v10[1024 * v114 - 960], v82);
    uint64_t v83 = v81 + v80 + v78;
    v113[3] += *(void *)(v83 - 16);
    bzero(v131, 0x888uLL);
    uint64_t v130 = 0x4600002001;
    long long v84 = *(_OWORD *)(v83 - 40);
    int v135 = *(_DWORD *)(v83 - 24);
    long long v134 = v84;
    LODWORD(v130) = 8705;
    uint64_t v133 = *(void *)(v83 - 104);
    LODWORD(v130) = 41473;
    __strlcpy_chk();
    LODWORD(v130) = v130 | 0x1E;
    int32x4_t v85 = vrev64q_s32(*(int32x4_t *)(v83 - 56));
    v85.i64[0] = *(void *)(v83 - 56);
    v131[0] = v85;
    if (ParallelArchiveWriteEntryHeader((uint64_t)v119, (uint64_t)&v130, 0, 0, v86, v87, v88, v89))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4679, 18, 0, "write entry header: %s", v90, v91, (char)v82);
      uint64_t v56 = 0;
      goto LABEL_85;
    }
    uint64_t v56 = (char *)IFileStreamCreateWithFilename((const char *)v127, 0, -1);
    if (!v56) {
      break;
    }
    uint64_t v94 = MemBufferTransmit(v57, 0xFFFFFFFFFFFFFFFFLL, (size_t (*)(int, void *, size_t))IFileStreamRead, (uint64_t)v56, (uint64_t (*)(uint64_t, uint64_t, uint64_t))parallelArchiveWrite, (uint64_t)v119, v92, v93);
    if (v94 < 0 || v94 != *(void *)(v83 - 104))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4686, 18, 0, "write DAT blob: %s", v95, v96, (char)v127);
      goto LABEL_85;
    }
    IFileStreamDestroy(v56);
LABEL_66:
    ++v79;
    v78 += 1208;
    if (v121 == v79) {
      goto LABEL_67;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4683, 18, 0, "open archived file: %s", v92, v93, (char)v127);
LABEL_85:
  uint64_t v60 = 0xFFFFFFFFLL;
  uint64_t v23 = v116;
  uint64_t v58 = v119;
LABEL_48:
  ParallelArchiveWriterDestroy(v58);
  OEncoderStreamDestroy(v59, v61, v62, v63, v64, v65, v66, v67);
  OFileStreamDestroy(v23);
  IFileStreamDestroy(v56);
  MemBufferDestroy((void **)v57);
  free(v125);
  return v60;
}

uint64_t parallelArchiveWrite(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (ParallelArchiveWriteEntryData(a1, a2, a3, a4, a5, a6, a7, a8)) {
    return -1;
  }
  else {
    return a3;
  }
}

uint64_t dumpStringArray(uint64_t result, CFArrayRef theArray, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (theArray)
  {
    uint64_t v10 = (const char *)result;
    uint64_t result = CFArrayGetCount(theArray);
    if (result)
    {
      uint64_t v11 = result;
      uint64_t v12 = (FILE **)MEMORY[0x263EF8348];
      uint64_t result = fprintf((FILE *)*MEMORY[0x263EF8348], "  %s:\n", v10);
      if (v11 >= 1)
      {
        CFIndex v13 = 0;
        while (1)
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v13);
          if (!ValueAtIndex) {
            return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"dumpStringArray", 884, 18, 0, "CFArrayGetValueAtIndex(%ld) returned 0", v15, v16, v13);
          }
          CStringPtr = CFStringGetCStringPtr(ValueAtIndex, 0x8000100u);
          if (!CStringPtr) {
            break;
          }
          uint64_t result = fprintf(*v12, "  - %s\n", CStringPtr);
          if (v11 == ++v13) {
            return result;
          }
        }
        return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"dumpStringArray", 886, 18, 0, "CFStringGetCStringPtr returned 0", v18, v19, a9);
      }
    }
  }
  return result;
}

uint64_t dumpContentsStats(uint64_t a1)
{
  uint64_t v2 = (FILE **)MEMORY[0x263EF8348];
  fprintf((FILE *)*MEMORY[0x263EF8348], "%12zu entries\n", *(void *)(a1 + 8));
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = (void *)(*(void *)(a1 + 16) + 72);
    do
    {
      int v11 = *((_DWORD *)v10 - 4);
      switch(v11)
      {
        case 3:
          ++v7;
          break;
        case 2:
          ++v8;
          break;
        case 1:
          if (v4 == *v10) {
            ++v9;
          }
          else {
            ++v6;
          }
          break;
        default:
          ++v5;
          break;
      }
      v10 += 23;
      ++v4;
    }
    while (v3 != v4);
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v8 = 0;
    uint64_t v7 = 0;
    uint64_t v6 = 0;
    uint64_t v5 = 0;
  }
  fprintf(*v2, "%12zu regular files\n", v9);
  fprintf(*v2, "%12zu directories\n", v8);
  fprintf(*v2, "%12zu symbolic links\n", v7);
  uint64_t result = fprintf(*v2, "%12zu hard links\n", v6);
  if (v5) {
    return fprintf(*v2, "%12zu invalid entries\n", v5);
  }
  return result;
}

{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t v13;
  unint64_t v14;
  FILE **v15;

  uint64_t v1 = *(void *)(a1 + 8);
  if (v1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    int v11 = 0;
    uint64_t v12 = (_DWORD *)(*(void *)(a1 + 32) + 1168);
    CFIndex v13 = *(void *)(a1 + 8);
    do
    {
      int v14 = *v12;
      if (*v12) {
        ++v8;
      }
      else {
        ++v6;
      }
      v11 += v14 & 1;
      v2 += (v14 >> 2) & 1;
      v10 += (v14 >> 3) & 1;
      v3 += (v14 >> 9) & 1;
      v9 += (v14 >> 4) & 1;
      v7 += (v14 >> 1) & 1;
      v5 += (v14 >> 6) & 1;
      v4 += (v14 >> 5) & 1;
      v12 += 302;
      --v13;
    }
    while (v13);
  }
  else
  {
    int v11 = 0;
    uint64_t v10 = 0;
    uint64_t v9 = 0;
    uint64_t v8 = 0;
    uint64_t v7 = 0;
    uint64_t v6 = 0;
    uint64_t v5 = 0;
    uint64_t v4 = 0;
    uint64_t v3 = 0;
    uint64_t v2 = 0;
  }
  fprintf((FILE *)*MEMORY[0x263EF8348], "%12zu entries\n", v1);
  fprintf((FILE *)*MEMORY[0x263EF8348], "%12zu resolved entries\n", v8);
  uint64_t v15 = (FILE **)MEMORY[0x263EF8348];
  fprintf((FILE *)*MEMORY[0x263EF8348], "%12zu non resolved entries\n", v6);
  fprintf(*v15, "%12zu ARCHIVE\n", v11);
  fprintf(*v15, "%12zu PATCH\n", v2);
  fprintf(*v15, "%12zu LINK\n", v10);
  fprintf(*v15, "%12zu FIRMLINK\n", v3);
  fprintf(*v15, "%12zu KEEP\n", v9);
  fprintf(*v15, "%12zu REMOVE\n", v7);
  fprintf(*v15, "%12zu AUTO MKDIR\n", v5);
  return fprintf(*v15, "%12zu IGNORE\n", v4);
}

uint64_t DirectoryEntryPathCompareProc(uint64_t a1, void *a2, void *a3)
{
  return strcmp((const char *)(*(void *)(a1 + 40) + *a2), (const char *)(*(void *)(a1 + 40) + *a3));
}

size_t PCompressLZFSEEncode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_encode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZFSE);
  if (!result) {
    return -1;
  }
  return result;
}

size_t PCompressLZFSEDecode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_decode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZFSE);
  if (!result) {
    return -1;
  }
  return result;
}

void pc_log_error_cold_1(uint64_t a1, int a2)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  v2[0] = 67109378;
  v2[1] = a2;
  __int16 v3 = 2080;
  uint64_t v4 = a1;
  _os_log_error_impl(&dword_21066E000, MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR, "[0x%08x] %s", (uint8_t *)v2, 0x12u);
}

int BZ2_bzDecompress(bz_stream *strm)
{
  return MEMORY[0x270F981C0](strm);
}

int BZ2_bzDecompressEnd(bz_stream *strm)
{
  return MEMORY[0x270F981C8](strm);
}

int BZ2_bzDecompressInit(bz_stream *strm, int verbosity, int small)
{
  return MEMORY[0x270F981D0](strm, *(void *)&verbosity, *(void *)&small);
}

int CC_SHA1_Final(unsigned __int8 *md, CC_SHA1_CTX *c)
{
  return MEMORY[0x270ED7AF8](md, c);
}

int CC_SHA1_Init(CC_SHA1_CTX *c)
{
  return MEMORY[0x270ED7B00](c);
}

int CC_SHA1_Update(CC_SHA1_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x270ED7B08](c, data, *(void *)&len);
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return MEMORY[0x270ED7B30](md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return MEMORY[0x270ED7B38](c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x270ED7B40](c, data, *(void *)&len);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x270EE4320](theArray);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x270EE4360](theArray, idx);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x270EE49A0](err);
}

CFErrorRef CFErrorCreateWithUserInfoKeysAndValues(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, const void *const *userInfoKeys, const void *const *userInfoValues, CFIndex numUserInfoValues)
{
  return (CFErrorRef)MEMORY[0x270EE49C8](allocator, domain, code, userInfoKeys, userInfoValues, numUserInfoValues);
}

void CFRelease(CFTypeRef cf)
{
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x270EE50E0](alloc, cStr, *(void *)&encoding);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x270EE5178](theString, buffer, bufferSize, *(void *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x270EE5180](theString, *(void *)&encoding);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x270EE51D8](theString);
}

void _Block_release(const void *aBlock)
{
}

int *__error(void)
{
  return (int *)MEMORY[0x270ED7DC0]();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x270ED7E28](*(void *)&a1, a2);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x270ED7E38]();
}

uint64_t __memset_chk()
{
  return MEMORY[0x270ED7E48]();
}

uint64_t __strlcat_chk()
{
  return MEMORY[0x270ED7ED8]();
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x270ED7EE0]();
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x270ED7F00](*(void *)&a1);
}

__darwin_ct_rune_t __toupper(__darwin_ct_rune_t a1)
{
  return MEMORY[0x270ED7F08](*(void *)&a1);
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

int acl_add_flag_np(acl_flagset_t flagset_d, acl_flag_t flag)
{
  return MEMORY[0x270ED8488](flagset_d, *(void *)&flag);
}

int acl_create_entry(acl_t *acl_p, acl_entry_t *entry_p)
{
  return MEMORY[0x270ED84B8](acl_p, entry_p);
}

int acl_free(void *obj_p)
{
  return MEMORY[0x270ED84C8](obj_p);
}

int acl_get_entry(acl_t acl, int entry_id, acl_entry_t *entry_p)
{
  return MEMORY[0x270ED84D8](acl, *(void *)&entry_id, entry_p);
}

acl_t acl_get_file(const char *path_p, acl_type_t type)
{
  return (acl_t)MEMORY[0x270ED84F0](path_p, *(void *)&type);
}

int acl_get_flag_np(acl_flagset_t flagset_d, acl_flag_t flag)
{
  return MEMORY[0x270ED84F8](flagset_d, *(void *)&flag);
}

int acl_get_flagset_np(void *obj_p, acl_flagset_t *flagset_p)
{
  return MEMORY[0x270ED8500](obj_p, flagset_p);
}

int acl_get_permset_mask_np(acl_entry_t entry_d, acl_permset_mask_t *mask_p)
{
  return MEMORY[0x270ED8520](entry_d, mask_p);
}

void *__cdecl acl_get_qualifier(acl_entry_t entry_d)
{
  return (void *)MEMORY[0x270ED8528](entry_d);
}

int acl_get_tag_type(acl_entry_t entry_d, acl_tag_t *tag_type_p)
{
  return MEMORY[0x270ED8530](entry_d, tag_type_p);
}

acl_t acl_init(int count)
{
  return (acl_t)MEMORY[0x270ED8538](*(void *)&count);
}

int acl_set_file(const char *path_p, acl_type_t type, acl_t acl)
{
  return MEMORY[0x270ED8550](path_p, *(void *)&type, acl);
}

int acl_set_permset_mask_np(acl_entry_t entry_d, acl_permset_mask_t mask)
{
  return MEMORY[0x270ED8560](entry_d, mask);
}

int acl_set_qualifier(acl_entry_t entry_d, const void *tag_qualifier_p)
{
  return MEMORY[0x270ED8568](entry_d, tag_qualifier_p);
}

int acl_set_tag_type(acl_entry_t entry_d, acl_tag_t tag_type)
{
  return MEMORY[0x270ED8570](entry_d, *(void *)&tag_type);
}

int bind(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x270ED8758](*(void *)&a1, a2, *(void *)&a3);
}

void *__cdecl bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  return (void *)MEMORY[0x270ED8798](__key, __base, __nel, __width, __compar);
}

void bzero(void *a1, size_t a2)
{
}

void *__cdecl calloc(size_t __count, size_t __size)
{
  return (void *)MEMORY[0x270ED87B0](__count, __size);
}

int chdir(const char *a1)
{
  return MEMORY[0x270ED8EB8](a1);
}

int chflags(const char *a1, __uint32_t a2)
{
  return MEMORY[0x270ED8EC0](a1, *(void *)&a2);
}

int chmod(const char *a1, mode_t a2)
{
  return MEMORY[0x270ED8EC8](a1, a2);
}

int chown(const char *a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x270ED8ED0](a1, *(void *)&a2, *(void *)&a3);
}

int clonefile(const char *a1, const char *a2, uint32_t a3)
{
  return MEMORY[0x270ED8F00](a1, a2, *(void *)&a3);
}

int close(int a1)
{
  return MEMORY[0x270ED8F18](*(void *)&a1);
}

int closedir(DIR *a1)
{
  return MEMORY[0x270ED8F30](a1);
}

size_t compression_decode_buffer(uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  return MEMORY[0x270F98F48](dst_buffer, dst_size, src_buffer, src_size, scratch_buffer, *(void *)&algorithm);
}

size_t compression_decode_scratch_buffer_size(compression_algorithm algorithm)
{
  return MEMORY[0x270F98F50](*(void *)&algorithm);
}

size_t compression_encode_buffer(uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  return MEMORY[0x270F98F58](dst_buffer, dst_size, src_buffer, src_size, scratch_buffer, *(void *)&algorithm);
}

size_t compression_encode_scratch_buffer_size(compression_algorithm algorithm)
{
  return MEMORY[0x270F98F60](*(void *)&algorithm);
}

compression_status compression_stream_destroy(compression_stream *stream)
{
  return MEMORY[0x270F98F68](stream);
}

uint64_t compression_stream_identify_algorithm()
{
  return MEMORY[0x270F98F70]();
}

compression_status compression_stream_init(compression_stream *stream, compression_stream_operation operation, compression_algorithm algorithm)
{
  return MEMORY[0x270F98F78](stream, *(void *)&operation, *(void *)&algorithm);
}

compression_status compression_stream_process(compression_stream *stream, int flags)
{
  return MEMORY[0x270F98F80](stream, *(void *)&flags);
}

size_t confstr(int a1, char *a2, size_t a3)
{
  return MEMORY[0x270ED8F50](*(void *)&a1, a2, a3);
}

char *__cdecl ctime_r(const time_t *a1, char *a2)
{
  return (char *)MEMORY[0x270ED9170](a1, a2);
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x270ED9278](flags, block);
}

int fchflags(int a1, __uint32_t a2)
{
  return MEMORY[0x270ED9898](*(void *)&a1, *(void *)&a2);
}

int fchmod(int a1, mode_t a2)
{
  return MEMORY[0x270ED98A0](*(void *)&a1, a2);
}

int fchown(int a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x270ED98B0](*(void *)&a1, *(void *)&a2, *(void *)&a3);
}

int fclose(FILE *a1)
{
  return MEMORY[0x270ED98C8](a1);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x270ED98D0](*(void *)&a1, *(void *)&a2);
}

int feof(FILE *a1)
{
  return MEMORY[0x270ED9910](a1);
}

int ferror(FILE *a1)
{
  return MEMORY[0x270ED9918](a1);
}

ssize_t fgetxattr(int fd, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x270ED9970](*(void *)&fd, name, value, size, *(void *)&position, *(void *)&options);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x270ED99F0](__filename, __mode);
}

uint64_t fpathconf(int a1, int a2)
{
  return MEMORY[0x270ED9A00](*(void *)&a1, *(void *)&a2);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x270ED9A08](a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x270ED9A18](*(void *)&a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x270ED9A28](__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
}

int fremovexattr(int fd, const char *name, int options)
{
  return MEMORY[0x270ED9A60](*(void *)&fd, name, *(void *)&options);
}

int fsctl(const char *a1, unint64_t a2, void *a3, unsigned int a4)
{
  return MEMORY[0x270ED9AB8](a1, a2, a3, *(void *)&a4);
}

int fsetattrlist(int a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x270ED9AD0](*(void *)&a1, a2, a3, a4, *(void *)&a5);
}

int fsetxattr(int fd, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x270ED9AE0](*(void *)&fd, name, value, size, *(void *)&position, *(void *)&options);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x270ED9AF0](*(void *)&a1, a2);
}

int fsync(int a1)
{
  return MEMORY[0x270ED9B10](*(void *)&a1);
}

int ftruncate(int a1, off_t a2)
{
  return MEMORY[0x270ED9B30](*(void *)&a1, a2);
}

int futimes(int a1, const timeval *a2)
{
  return MEMORY[0x270ED9B80](*(void *)&a1, a2);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x270ED9B88](__ptr, __size, __nitems, __stream);
}

int getattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x270ED9BA0](a1, a2, a3, a4, *(void *)&a5);
}

char *__cdecl getcwd(char *a1, size_t a2)
{
  return (char *)MEMORY[0x270ED9BD0](a1, a2);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x270ED9BE8](a1);
}

int getgrgid_r(gid_t a1, group *a2, char *a3, size_t a4, group **a5)
{
  return MEMORY[0x270ED9C20](*(void *)&a1, a2, a3, a4, a5);
}

int getgrnam_r(const char *a1, group *a2, char *a3, size_t a4, group **a5)
{
  return MEMORY[0x270ED9C30](a1, a2, a3, a4, a5);
}

int getpagesize(void)
{
  return MEMORY[0x270ED9CC8]();
}

pid_t getpid(void)
{
  return MEMORY[0x270ED9CE0]();
}

int getpwnam_r(const char *a1, passwd *a2, char *a3, size_t a4, passwd **a5)
{
  return MEMORY[0x270ED9D30](a1, a2, a3, a4, a5);
}

int getpwuid_r(uid_t a1, passwd *a2, char *a3, size_t a4, passwd **a5)
{
  return MEMORY[0x270ED9D40](*(void *)&a1, a2, a3, a4, a5);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x270ED9D98](a1, a2);
}

ssize_t getxattr(const char *path, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x270ED9DC0](path, name, value, size, *(void *)&position, *(void *)&options);
}

int issetugid(void)
{
  return MEMORY[0x270ED9F18]();
}

int lchflags(const char *a1, __uint32_t a2)
{
  return MEMORY[0x270EDA010](a1, *(void *)&a2);
}

int lchmod(const char *a1, mode_t a2)
{
  return MEMORY[0x270EDA018](a1, a2);
}

int lchown(const char *a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x270EDA020](a1, *(void *)&a2, *(void *)&a3);
}

int link(const char *a1, const char *a2)
{
  return MEMORY[0x270EDA068](a1, a2);
}

ssize_t listxattr(const char *path, char *namebuff, size_t size, int options)
{
  return MEMORY[0x270EDA080](path, namebuff, size, *(void *)&options);
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x270EDA118](*(void *)&a1, a2, *(void *)&a3);
}

int lstat(const char *a1, stat *a2)
{
  return MEMORY[0x270EDA120](a1, a2);
}

uint64_t lzma_auto_decoder()
{
  return MEMORY[0x270F99BA8]();
}

uint64_t lzma_code()
{
  return MEMORY[0x270F99BB0]();
}

uint64_t lzma_end()
{
  return MEMORY[0x270F99BD0]();
}

uint64_t lzma_stream_buffer_bound()
{
  return MEMORY[0x270F99C10]();
}

uint64_t lzma_stream_decoder()
{
  return MEMORY[0x270F99C20]();
}

void *__cdecl malloc(size_t __size)
{
  return (void *)MEMORY[0x270EDA328](__size);
}

int mbr_gid_to_uuid(gid_t gid, uuid_t uu)
{
  return MEMORY[0x270EDA3F8](*(void *)&gid, uu);
}

int mbr_sid_to_string(const nt_sid_t *sid, char *string)
{
  return MEMORY[0x270EDA408](sid, string);
}

int mbr_sid_to_uuid(const nt_sid_t *sid, uuid_t uu)
{
  return MEMORY[0x270EDA410](sid, uu);
}

int mbr_string_to_sid(const char *string, nt_sid_t *sid)
{
  return MEMORY[0x270EDA418](string, sid);
}

int mbr_uid_to_uuid(uid_t uid, uuid_t uu)
{
  return MEMORY[0x270EDA420](*(void *)&uid, uu);
}

int mbr_uuid_to_id(const uuid_t uu, id_t *uid_or_gid, int *id_type)
{
  return MEMORY[0x270EDA428](uu, uid_or_gid, id_type);
}

int mbr_uuid_to_sid(const uuid_t uu, nt_sid_t *sid)
{
  return MEMORY[0x270EDA430](uu, sid);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x270EDA458](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x270EDA468](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDA470](__dst, __src, __n);
}

void *__cdecl memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
{
  return (void *)MEMORY[0x270EDA480](__big, __big_len, __little, __little_len);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDA488](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x270EDA498](__b, *(void *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  return MEMORY[0x270EDA4B8](__s, __smax, *(void *)&__c, __n);
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x270EDA518](a1, a2);
}

char *__cdecl mkdtemp(char *a1)
{
  return (char *)MEMORY[0x270EDA528](a1);
}

int mkfifo(const char *a1, mode_t a2)
{
  return MEMORY[0x270EDA538](a1, a2);
}

int mknod(const char *a1, mode_t a2, dev_t a3)
{
  return MEMORY[0x270EDA540](a1, a2, *(void *)&a3);
}

int mkostemp(char *path, int oflags)
{
  return MEMORY[0x270EDA548](path, *(void *)&oflags);
}

int mkstemp(char *a1)
{
  return MEMORY[0x270EDA560](a1);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x270EDA598](a1, a2, *(void *)&a3, *(void *)&a4, *(void *)&a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x270EDA5F8](a1, a2);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x270EDA828](a1, *(void *)&a2);
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return MEMORY[0x270EDA830](a1, *(void *)&a2, *(void *)&a3, *(void *)&a4);
}

DIR *__cdecl opendir(const char *a1)
{
  return (DIR *)MEMORY[0x270EDA858](a1);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDA9D0](oslog, type);
}

int pclose(FILE *a1)
{
  return MEMORY[0x270EDAC08](a1);
}

FILE *__cdecl popen(const char *a1, const char *a2)
{
  return (FILE *)MEMORY[0x270EDAC48](a1, a2);
}

ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x270EDAD10](*(void *)&__fd, __buf, __nbyte, a4);
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return MEMORY[0x270EDADF8](a1);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x270EDAE10](a1);
}

int pthread_attr_set_qos_class_np(pthread_attr_t *__attr, qos_class_t __qos_class, int __relative_priority)
{
  return MEMORY[0x270EDAE18](__attr, *(void *)&__qos_class, *(void *)&__relative_priority);
}

int pthread_attr_setstacksize(pthread_attr_t *a1, size_t a2)
{
  return MEMORY[0x270EDAE40](a1, a2);
}

int pthread_cond_broadcast(pthread_cond_t *a1)
{
  return MEMORY[0x270EDAE50](a1);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return MEMORY[0x270EDAE58](a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return MEMORY[0x270EDAE60](a1, a2);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return MEMORY[0x270EDAE88](a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x270EDAEA0](a1, a2, a3, a4);
}

int pthread_get_qos_class_np(pthread_t __pthread, qos_class_t *__qos_class, int *__relative_priority)
{
  return MEMORY[0x270EDAEC8](__pthread, __qos_class, __relative_priority);
}

void *__cdecl pthread_getspecific(pthread_key_t a1)
{
  return (void *)MEMORY[0x270EDAEF0](a1);
}

int pthread_join(pthread_t a1, void **a2)
{
  return MEMORY[0x270EDAF10](a1, a2);
}

int pthread_key_create(pthread_key_t *a1, void (__cdecl *a2)(void *))
{
  return MEMORY[0x270EDAF18](a1, a2);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x270EDAF50](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x270EDAF58](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x270EDAF60](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x270EDAF70](a1);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x270EDAFA0](a1, a2);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x270EDB010]();
}

int pthread_setspecific(pthread_key_t a1, const void *a2)
{
  return MEMORY[0x270EDB048](a1, a2);
}

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x270EDB0A0](*(void *)&__fd, __buf, __nbyte, a4);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

void qsort_r(void *__base, size_t __nel, size_t __width, void *a4, int (__cdecl *__compar)(void *, const void *, const void *))
{
}

int rand(void)
{
  return MEMORY[0x270EDB0D8]();
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x270EDB120](*(void *)&a1, a2, a3);
}

int readdir_r(DIR *a1, dirent *a2, dirent **a3)
{
  return MEMORY[0x270EDB130](a1, a2, a3);
}

ssize_t readlink(const char *a1, char *a2, size_t a3)
{
  return MEMORY[0x270EDB138](a1, a2, a3);
}

void *__cdecl realloc(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x270EDB150](__ptr, __size);
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x270EDB158](__ptr, __size);
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  return (char *)MEMORY[0x270EDB170](a1, a2);
}

int removexattr(const char *path, const char *name, int options)
{
  return MEMORY[0x270EDB218](path, name, *(void *)&options);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
}

int rmdir(const char *a1)
{
  return MEMORY[0x270EDB268](a1);
}

int setattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x270EDB3C8](a1, a2, a3, a4, *(void *)&a5);
}

int setxattr(const char *path, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x270EDB460](path, name, value, size, *(void *)&position, *(void *)&options);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x270EDB510](__str, __size, __format);
}

int socket(int a1, int a2, int a3)
{
  return MEMORY[0x270EDB520](*(void *)&a1, *(void *)&a2, *(void *)&a3);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x270EDB568](a1, a2);
}

int statfs(const char *a1, statfs *a2)
{
  return MEMORY[0x270EDB570](a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x270EDB5A8](__s, *(void *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x270EDB5B0](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x270EDB5D0](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x270EDB5D8](*(void *)&__errnum);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x270EDB600](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x270EDB610](__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return MEMORY[0x270EDB620](a1, a2, a3);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x270EDB638](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x270EDB648](__dst, __src, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x270EDB680](__s, *(void *)&__c);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x270EDB6A0](__s1, __s2);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x270EDB6D8](__str, __endptr, *(void *)&__base);
}

unint64_t strtoull(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x270EDB718](__str, __endptr, *(void *)&__base);
}

int symlink(const char *a1, const char *a2)
{
  return MEMORY[0x270EDB770](a1, a2);
}

uint64_t sysconf(int a1)
{
  return MEMORY[0x270EDB7C8](*(void *)&a1);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x270EDB7D8](a1, a2, a3, a4, a5);
}

time_t time(time_t *a1)
{
  return MEMORY[0x270EDB930](a1);
}

int truncate(const char *a1, off_t a2)
{
  return MEMORY[0x270EDB978](a1, a2);
}

int unlink(const char *a1)
{
  return MEMORY[0x270EDB9A8](a1);
}

int usleep(useconds_t a1)
{
  return MEMORY[0x270EDB9E8](*(void *)&a1);
}

int utimes(const char *a1, const timeval *a2)
{
  return MEMORY[0x270EDB9F8](a1, a2);
}

int uuid_parse(const uuid_string_t in, uuid_t uu)
{
  return MEMORY[0x270EDBA30](in, uu);
}

void uuid_unparse_upper(const uuid_t uu, uuid_string_t out)
{
}

void *__cdecl valloc(size_t a1)
{
  return (void *)MEMORY[0x270EDBA50](a1);
}

int vfprintf(FILE *a1, const char *a2, va_list a3)
{
  return MEMORY[0x270EDBA70](a1, a2, a3);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x270EDBB18](__str, __size, __format, a4);
}