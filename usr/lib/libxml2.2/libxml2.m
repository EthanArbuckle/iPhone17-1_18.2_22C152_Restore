int xmlNodeIsText(const xmlNode *node)
{
  if (node) {
    LODWORD(node) = node->type == XML_TEXT_NODE;
  }
  return (int)node;
}

xmlChar *__cdecl xmlParseEncName(xmlParserCtxtPtr ctxt)
{
  int v2 = *ctxt->input->cur;
  if ((v2 & 0xFFFFFFDF) - 65 > 0x19)
  {
    xmlFatalErr(ctxt, 79, 0);
    return 0;
  }
  else
  {
    v3 = xmlMallocAtomic(0xAuLL);
    v4 = v3;
    if (v3)
    {
      unsigned char *v3 = v2;
      xmlNextChar(ctxt);
      xmlChar v5 = *ctxt->input->cur;
      int v6 = 10;
      for (uint64_t i = 1; ; ++i)
      {
        BOOL v8 = (v5 - 48) >= 0xAu && ((v5 & 0xDF) - 65) >= 0x1Au;
        if (v8 && (v5 - 45 > 0x32 || ((1 << (v5 - 45)) & 0x4000000000003) == 0)) {
          break;
        }
        if (v6 <= (int)i + 1)
        {
          v6 *= 2;
          v9 = xmlRealloc(v4, v6);
          if (!v9)
          {
            htmlErrMemory(ctxt, 0);
            xmlFree(v4);
            return 0;
          }
          v4 = v9;
        }
        *((unsigned char *)v4 + i) = v5;
        xmlNextChar(ctxt);
        xmlParserInputPtr input = ctxt->input;
        cur = (xmlChar *)input->cur;
        xmlChar v5 = *cur;
        if (!*cur)
        {
          if (!ctxt->progressive)
          {
            if (cur - input->base < 501
              || input->end - (const xmlChar *)cur > 499
              || (xmlSHRINK((uint64_t)ctxt), xmlParserInputPtr input = ctxt->input, !ctxt->progressive))
            {
              if (input->end - input->cur <= 249)
              {
                xmlGROW((uint64_t)ctxt);
                xmlParserInputPtr input = ctxt->input;
              }
            }
          }
          xmlChar v5 = *input->cur;
        }
      }
      *((unsigned char *)v4 + i) = 0;
    }
    else
    {
      htmlErrMemory(ctxt, 0);
    }
  }
  return (xmlChar *)v4;
}

void xmlParseEndTag2(uint64_t a1, void *a2)
{
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40) - *(void *)(*(void *)(a1 + 56) + 32)) <= 249)
  {
    xmlGROW(a1);
  }
  v4 = *(xmlParserInput **)(a1 + 56);
  cur = v4->cur;
  if (*cur == 60 && cur[1] == 47)
  {
    v4->cur = cur + 2;
    v4->col += 2;
    if (!cur[2]) {
      xmlParserInputGrow(v4, 250);
    }
    int v6 = (const xmlChar *)*a2;
    v7 = *(const xmlChar **)(a1 + 288);
    if (*a2)
    {
      uint64_t v8 = *(void *)(a1 + 56);
      if (!*(_DWORD *)(a1 + 452) && (uint64_t)(*(void *)(v8 + 40) - *(void *)(v8 + 32)) <= 249)
      {
        xmlGROW(a1);
        uint64_t v8 = *(void *)(a1 + 56);
      }
      v30 = 0;
      v9 = *(unsigned char **)(v8 + 32);
      int v10 = *v9;
      if (!*v9) {
        goto LABEL_32;
      }
      v11 = v9 + 2;
      v12 = v6;
      while (v10 == *v12)
      {
        ++v12;
        int v10 = *(v11++ - 1);
        if (!v10) {
          goto LABEL_32;
        }
      }
      if (v10 != 58 || *v12) {
        goto LABEL_32;
      }
      uint64_t v14 = (uint64_t)(v11 - 1);
      unsigned int v15 = *(v11 - 1);
      if (*(v11 - 1))
      {
        uint64_t v16 = 0;
        while (1)
        {
          int v17 = v7[v16];
          if (v15 != v17) {
            break;
          }
          unsigned int v15 = v11[v16++];
          if (!v15)
          {
            uint64_t v14 = (uint64_t)&v11[v16 - 1];
            v18 = &v7[v16];
            goto LABEL_29;
          }
        }
        uint64_t v14 = (uint64_t)&v11[v16 - 1];
      }
      else
      {
        v18 = v7;
LABEL_29:
        unsigned int v15 = 0;
        int v17 = *v18;
      }
      if (!v17 && v15 <= 0x3E && ((1 << v15) & 0x4000000100002600) != 0)
      {
        *(_DWORD *)(v8 + 56) += v14 - v9;
        *(void *)(v8 + 32) = v14;
        uint64_t v13 = 1;
      }
      else
      {
LABEL_32:
        v19 = xmlParseQName(a1, &v30);
        if (v30 == v6 && v19 == v7) {
          uint64_t v13 = 1;
        }
        else {
          uint64_t v13 = (uint64_t)v19;
        }
      }
    }
    else
    {
      uint64_t v13 = xmlParseNameAndCompare(a1, *(unsigned __int8 **)(a1 + 288));
    }
    if (!*(_DWORD *)(a1 + 452)
      && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40) - *(void *)(*(void *)(a1 + 56) + 32)) <= 249)
    {
      xmlGROW(a1);
    }
    if (*(_DWORD *)(a1 + 272) != -1)
    {
      xmlSkipBlankChars((xmlParserCtxtPtr)a1);
      v21 = *(xmlParserInput **)(a1 + 56);
      v22 = v21->cur;
      if (*v22 == 62)
      {
        ++v21->col;
        v21->cur = v22 + 1;
        if (!v22[1]) {
          xmlParserInputGrow(v21, 250);
        }
      }
      else
      {
        xmlFatalErr((_DWORD *)a1, 73, 0);
      }
      if (v13 != 1)
      {
        if (v13) {
          v23 = (xmlChar *)v13;
        }
        else {
          v23 = (xmlChar *)"unparsable";
        }
        xmlFatalErrMsgStrIntStr((_DWORD *)a1, 76, "Opening and ending tag mismatch: %s line %d and %s\n", *(const xmlChar **)(a1 + 288), *((_DWORD *)a2 + 4), v23);
      }
      if (*(void *)a1)
      {
        v24 = *(void (**)(void, void, void, void))(*(void *)a1 + 240);
        if (v24)
        {
          if (!*(_DWORD *)(a1 + 332)) {
            v24(*(void *)(a1 + 8), *(void *)(a1 + 288), *a2, a2[1]);
          }
        }
      }
      int v25 = *(_DWORD *)(a1 + 376);
      if (v25 >= 1)
      {
        unsigned int v26 = v25 - 2;
        unsigned int v27 = v25 - 1;
        *(_DWORD *)(a1 + 376) = v27;
        uint64_t v28 = *(void *)(a1 + 384);
        if (!v27) {
          unsigned int v26 = 0;
        }
        *(void *)(a1 + 368) = v28 + 4 * v26;
        *(_DWORD *)(v28 + 4 * v27) = -1;
      }
      int v29 = *((_DWORD *)a2 + 5);
      if (v29)
      {
        nsPop(a1, v29);
      }
    }
  }
  else
  {
    xmlFatalErr((_DWORD *)a1, 74, 0);
  }
}

xmlChar *xmlParseStartTag2(uint64_t a1, const xmlChar **a2, uint64_t *a3, _DWORD *a4)
{
  xmlChar v5 = *(xmlParserInput **)(a1 + 56);
  cur = v5->cur;
  if (*cur != 60) {
    return 0;
  }
  uint64_t v10 = *(void *)(a1 + 464);
  int v132 = *(_DWORD *)(a1 + 472);
  int v11 = *(_DWORD *)(a1 + 508);
  ++v5->col;
  v5->cur = cur + 1;
  if (!cur[1])
  {
    xmlParserInputGrow(v5, 250);
    xmlChar v5 = *(xmlParserInput **)(a1 + 56);
  }
  if (!*(_DWORD *)(a1 + 452))
  {
    v12 = v5->cur;
    if (v12 - v5->base >= 501 && v5->end - v12 <= 499)
    {
      xmlSHRINK(a1);
      xmlChar v5 = *(xmlParserInput **)(a1 + 56);
    }
  }
  v139 = 0;
  base = v5->base;
  uint64_t v13 = v5->cur;
  int id = v5->id;
  *(_DWORD *)(a1 + 508) = v11;
  uint64_t v16 = (xmlChar *)xmlParseQName(a1, &v139);
  if (!v16)
  {
    xmlFatalErrMsg((_DWORD *)a1, 68, (char)"StartTag: invalid element name\n");
    return v16;
  }
  int v129 = id;
  v127 = a2;
  v128 = a3;
  *a4 = base
      + *(_DWORD *)(*(void *)(a1 + 56) + 32)
      - (v13
       + *(_DWORD *)(*(void *)(a1 + 56) + 24));
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40) - *(void *)(*(void *)(a1 + 56) + 32)) <= 249)
  {
    xmlGROW(a1);
  }
  int v133 = 0;
  uint64_t v17 = 0;
  int v134 = 0;
  int v130 = 0;
  name2 = 0;
  v135 = (const xmlChar **)(a1 + 496);
  v18 = &xmlFree;
  v131 = v16;
  while (1)
  {
    uint64_t v19 = *(void *)(a1 + 56);
    v20 = *(unsigned __int8 **)(v19 + 32);
    unsigned int v21 = *v20;
    if (v21 == 47)
    {
      if (v20[1] == 62) {
        goto LABEL_162;
      }
    }
    else
    {
      if (v21 == 62) {
        goto LABEL_162;
      }
      BOOL v22 = v21 - 9 < 2 || v21 == 13;
      if (!v22 && v21 < 0x20) {
        goto LABEL_162;
      }
    }
    if (*(_DWORD *)(a1 + 272) == -1) {
      goto LABEL_162;
    }
    uint64_t v23 = *(unsigned int *)(v19 + 64);
    int v136 = 0;
    int len = -1;
    v24 = v139;
    if (!*(_DWORD *)(a1 + 452) && (uint64_t)(*(void *)(v19 + 40) - (void)v20) <= 249) {
      xmlGROW(a1);
    }
    int v25 = xmlParseQName(a1, (const xmlChar **)&name2);
    if (!v25)
    {
      xmlFatalErrMsg((_DWORD *)a1, 68, (char)"error parsing attribute name\n");
LABEL_41:
      v30 = 0;
      char v35 = 1;
      goto LABEL_42;
    }
    unsigned int v26 = (xmlChar *)v25;
    unsigned int v27 = *(xmlHashTable **)(a1 + 552);
    if (v27) {
      BOOL v28 = xmlHashQLookup2(v27, v24, v16, name2, v26) != 0;
    }
    else {
      BOOL v28 = 0;
    }
    xmlSkipBlankChars((xmlParserCtxtPtr)a1);
    if (**(unsigned char **)(*(void *)(a1 + 56) + 32) != 61)
    {
      xmlFatalErrMsgStr((_DWORD *)a1, 41, "Specification mandates value for attribute %s\n", v26);
      goto LABEL_41;
    }
    xmlNextChar((xmlParserCtxtPtr)a1);
    xmlSkipBlankChars((xmlParserCtxtPtr)a1);
    int v29 = xmlParseAttValueInternal(a1, &len, &v136, v28);
    v30 = v29;
    if (v28)
    {
      if (v136)
      {
        if (v29)
        {
          int v31 = len;
          if (len >= 1)
          {
            int v32 = *v29;
            if (v32 == 32)
            {
              uint64_t v33 = 0;
              do
                int v32 = v29[++v33];
              while (v32 == 32);
              v34 = &v29[v33];
            }
            else
            {
              LODWORD(v33) = 0;
              v34 = v29;
            }
            do
            {
              while (v32 != 32)
              {
                if (!v32)
                {
                  if (v33)
                  {
                    len -= v33;
                    memmove(v29, &v29[v33], v31 - (int)v33 + 1);
                  }
                  goto LABEL_70;
                }
                int v40 = *++v34;
                int v32 = v40;
              }
              int v41 = *++v34;
              int v32 = v41;
            }
            while ((v41 | 0x20) != 0x20);
            v42 = xmlStrndup(&v29[v33], len - (int)v33 + 1);
            if (v42)
            {
              v43 = (const char *)v42;
              xmlAttrNormalizeSpace((uint64_t)v42, v42);
              int len = strlen(v43);
              if (v43 != (const char *)v30)
              {
                ((void (*)(const xmlChar *))*v18)(v30);
                v30 = (const xmlChar *)v43;
              }
            }
            else
            {
              htmlErrMemory((_DWORD *)a1, 0);
            }
          }
        }
      }
    }
LABEL_70:
    *(_DWORD *)(a1 + 272) = 7;
    if (name2 == *(xmlChar **)(a1 + 480))
    {
      if (*(_DWORD *)(a1 + 420) && xmlStrEqual(v26, (const xmlChar *)"lang"))
      {
        v44 = xmlStrndup(v30, len);
        if (!xmlCheckLanguageID(v44)) {
          xmlWarningMsg((_DWORD *)a1, 98, "Malformed value for xml:lang : %s\n", v44);
        }
      }
      else
      {
        v44 = 0;
      }
      if (xmlStrEqual(v26, (const xmlChar *)"space"))
      {
        v44 = xmlStrndup(v30, len);
        if (xmlStrEqual(v44, (const xmlChar *)"default"))
        {
          **(_DWORD **)(a1 + 368) = 0;
        }
        else if (xmlStrEqual(v44, (const xmlChar *)"preserve"))
        {
          **(_DWORD **)(a1 + 368) = 1;
        }
        else
        {
          xmlWarningMsg((_DWORD *)a1, 102, "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n", v44);
        }
      }
      if (v44) {
        ((void (*)(xmlChar *))*v18)(v44);
      }
    }
    if (v30)
    {
      v45 = v18;
      int v46 = len;
      if (len < 0)
      {
        int v46 = xmlStrlen(v30);
        int len = v46;
      }
      v47 = *(xmlChar **)(a1 + 488);
      if (v26 == v47 && !name2)
      {
        v48 = (const char *)xmlDictLookup(*(xmlDictPtr *)(a1 + 456), v30, v46);
        if (!v48)
        {
          htmlErrMemory((_DWORD *)a1, (const xmlChar *)"dictionary allocation failure");
          v18 = v45;
          if (v136) {
            ((void (*)(const xmlChar *))*v45)(v30);
          }
          uint64_t v16 = 0;
LABEL_270:
          int v73 = v133;
          goto LABEL_258;
        }
        v49 = (const xmlChar *)v48;
        v18 = v45;
        if (!*v48) {
          goto LABEL_115;
        }
        xmlURIPtr v50 = xmlParseURI(v48);
        if (v50)
        {
          v51 = v50;
          if (!v50->scheme) {
            xmlNsWarn((_DWORD *)a1, "xmlns: URI %s is not absolute\n", v49, 0);
          }
          xmlFreeURI(v51);
        }
        else
        {
          xmlNsErr((_DWORD *)a1, 99, "xmlns: '%s' is not a valid URI\n", v49, 0, 0);
        }
        v18 = v45;
        if (v49 != *v135)
        {
          if (len == 29 && xmlStrEqual(v49, (const xmlChar *)"http://www.w3.org/2000/xmlns/"))
          {
            v59 = (_DWORD *)a1;
            v60 = "reuse of the xmlns namespace name is forbidden\n";
LABEL_129:
            xmlNsErr(v59, 200, v60, 0, 0, 0);
            goto LABEL_142;
          }
LABEL_115:
          uint64_t v16 = v131;
          if (v134 < 1)
          {
LABEL_119:
            int v63 = nsPush(a1, 0, (uint64_t)v49);
            int v64 = v134;
            if (v63 > 0) {
              int v64 = v134 + 1;
            }
            int v134 = v64;
          }
          else
          {
            v61 = (void *)(*(void *)(a1 + 520) + 8 * *(int *)(a1 + 508) - 16);
            uint64_t v62 = (v134 + 1) - 1;
            while (*v61)
            {
              v61 -= 2;
              if (!--v62) {
                goto LABEL_119;
              }
            }
            xmlErrAttributeDup((_DWORD *)a1, 0, v26);
          }
          goto LABEL_143;
        }
        if (v26 != *(xmlChar **)(a1 + 480))
        {
          v59 = (_DWORD *)a1;
          v60 = "xml namespace URI cannot be the default namespace\n";
          goto LABEL_129;
        }
LABEL_142:
        uint64_t v16 = v131;
LABEL_143:
        if (!v136)
        {
          char v35 = 0;
          goto LABEL_42;
        }
        ((void (*)(const xmlChar *))*v18)(v30);
        char v35 = 0;
        goto LABEL_145;
      }
      if (name2 != v47)
      {
        if (v10 && (int)v17 + 5 <= v132)
        {
          v18 = v45;
        }
        else
        {
          v18 = v45;
          if ((xmlCtxtGrowAttrs(a1, (int)v17 + 5) & 0x80000000) != 0) {
            goto LABEL_142;
          }
          int v132 = *(_DWORD *)(a1 + 472);
          uint64_t v10 = *(void *)(a1 + 464);
        }
        uint64_t v16 = v131;
        *(_DWORD *)(*(void *)(a1 + 528) + 4 * v133) = v136;
        v57 = (xmlChar **)(v10 + 8 * (int)v17);
        *v57 = v26;
        v57[1] = name2;
        if (v136)
        {
          uint64_t v58 = 0;
          int v130 = 1;
        }
        else
        {
          uint64_t v58 = *(void *)(*(void *)(a1 + 56) + 24);
        }
        char v35 = 0;
        ++v133;
        *(void *)(v10 + 8 * ((int)v17 + 2)) = v58;
        uint64_t v65 = v10 + 8 * (int)v17;
        v66 = &v30[len];
        *(void *)(v65 + 24) = v30;
        *(void *)(v65 + 32) = v66;
        uint64_t v17 = (v17 + 5);
LABEL_145:
        v30 = 0;
        goto LABEL_42;
      }
      v52 = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), v30, v46);
      v53 = (char *)v52;
      v54 = *(const xmlChar **)(a1 + 496);
      if (v26 == *(xmlChar **)(a1 + 480))
      {
        v18 = v45;
        if (v52 != v54)
        {
          v59 = (_DWORD *)a1;
          v60 = "xml namespace prefix mapped to wrong URI\n";
          goto LABEL_129;
        }
        goto LABEL_142;
      }
      if (v52 == v54)
      {
        v55 = (_DWORD *)a1;
        v56 = "xml namespace URI mapped to wrong prefix\n";
      }
      else if (v26 == *(xmlChar **)(a1 + 488))
      {
        v55 = (_DWORD *)a1;
        v56 = "redefinition of the xmlns prefix is forbidden\n";
      }
      else
      {
        if (len != 29 || !xmlStrEqual(v52, (const xmlChar *)"http://www.w3.org/2000/xmlns/"))
        {
          if (v53 && *v53)
          {
            xmlURIPtr v67 = xmlParseURI(v53);
            if (v67)
            {
              if (*(_DWORD *)(a1 + 420) && !v67->scheme)
              {
                uruint64_t i = v67;
                xmlNsWarn((_DWORD *)a1, "xmlns:%s: URI %s is not absolute\n", v26, (xmlChar *)v53);
                xmlURIPtr v67 = uri;
              }
              xmlFreeURI(v67);
            }
            else
            {
              xmlNsErr((_DWORD *)a1, 99, "xmlns:%s: '%s' is not a valid URI\n", v26, (xmlChar *)v53, 0);
            }
            if (v134 < 1)
            {
LABEL_153:
              int v71 = nsPush(a1, (uint64_t)v26, (uint64_t)v53);
              int v72 = v134;
              if (v71 > 0) {
                int v72 = v134 + 1;
              }
              int v134 = v72;
            }
            else
            {
              v69 = (xmlChar **)(*(void *)(a1 + 520) + 8 * *(int *)(a1 + 508) - 16);
              uint64_t v70 = (v134 + 1) - 1;
              while (*v69 != v26)
              {
                v69 -= 2;
                if (!--v70) {
                  goto LABEL_153;
                }
              }
              xmlErrAttributeDup((_DWORD *)a1, v47, v26);
            }
            goto LABEL_141;
          }
          v55 = (_DWORD *)a1;
          v56 = "xmlns:%s: Empty XML namespace is not allowed\n";
          v68 = v26;
LABEL_140:
          xmlNsErr(v55, 200, v56, v68, 0, 0);
LABEL_141:
          v18 = v45;
          goto LABEL_142;
        }
        v55 = (_DWORD *)a1;
        v56 = "reuse of the xmlns namespace name is forbidden\n";
      }
      v68 = 0;
      goto LABEL_140;
    }
    char v35 = 0;
    uint64_t v16 = v131;
LABEL_42:
    if (!*(_DWORD *)(a1 + 452)
      && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40) - *(void *)(*(void *)(a1 + 56) + 32)) <= 249)
    {
      xmlGROW(a1);
    }
    if (*(_DWORD *)(a1 + 272) == -1) {
      goto LABEL_161;
    }
    v36 = *(unsigned __int8 **)(*(void *)(a1 + 56) + 32);
    int v37 = *v36;
    if (v37 == 47)
    {
      if (v36[1] == 62) {
        goto LABEL_161;
      }
    }
    else if (v37 == 62)
    {
      goto LABEL_161;
    }
    if (!xmlSkipBlankChars((xmlParserCtxtPtr)a1)) {
      break;
    }
    v38 = *(void **)(a1 + 56);
    if (v23 == v38[8])
    {
      char v39 = v35 ^ 1;
      if (v20 != (unsigned __int8 *)v38[4]) {
        char v39 = 1;
      }
      if ((v39 & 1) == 0 && !v30)
      {
        xmlFatalErr((_DWORD *)a1, 1, (const xmlChar *)"xmlParseStartTag: problem parsing attributes\n");
        goto LABEL_161;
      }
    }
    if (!*(_DWORD *)(a1 + 452) && (uint64_t)(v38[5] - v38[4]) <= 249) {
      xmlGROW(a1);
    }
  }
  xmlFatalErrMsg((_DWORD *)a1, 65, (char)"attributes construct error\n");
LABEL_161:
  uint64_t v19 = *(void *)(a1 + 56);
LABEL_162:
  int v73 = v133;
  if (*(_DWORD *)(v19 + 100) == v129)
  {
    if (v133 >= 1)
    {
      v74 = (void *)(v10 + 32);
      int v75 = v133;
      do
      {
        uint64_t v76 = *(v74 - 2);
        if (v76)
        {
          *(v74 - 2) = 0;
          *(v74 - 1) = *(void *)(*(void *)(a1 + 56) + 24) + *(v74 - 1) - v76;
          void *v74 = *(void *)(*(void *)(a1 + 56) + 24) + *v74 - v76;
        }
        v74 += 5;
        --v75;
      }
      while (v75);
    }
    v77 = *(xmlHashTable **)(a1 + 544);
    if (v77)
    {
      v78 = (int *)xmlHashLookup2(v77, v16, v139);
      if (v78)
      {
        v79 = v78;
        if (*v78 >= 1)
        {
          uint64_t v80 = 0;
          uint64_t v81 = 0;
          uint64_t v82 = v17;
          while (1)
          {
            v83 = &v79[10 * v80];
            v85 = (const xmlChar *)*((void *)v83 + 1);
            v84 = (xmlChar *)*((void *)v83 + 2);
            name2 = v84;
            v86 = *(const xmlChar **)(a1 + 488);
            if (v85 == v86 && v84 == 0) {
              break;
            }
            int v88 = v134;
            if (v84 == v86)
            {
              if (v134 >= 1)
              {
                v101 = (const xmlChar **)(*(void *)(a1 + 520) + 8 * *(int *)(a1 + 508) - 16);
                uint64_t v102 = (v134 + 1) - 1;
                while (*v101 != v85)
                {
                  v101 -= 2;
                  if (!--v102) {
                    goto LABEL_207;
                  }
                }
                goto LABEL_215;
              }
LABEL_207:
              if (xmlGetNamespace(a1, (uint64_t)v85) != *((void *)v79 + 3))
              {
                uint64_t v103 = *(void *)&v79[10 * v80 + 6];
                uint64_t v104 = a1;
                uint64_t v105 = (uint64_t)v85;
                goto LABEL_212;
              }
              goto LABEL_215;
            }
            if ((int)v82 >= 1)
            {
              uint64_t v89 = 0;
              while (v85 != *(const xmlChar **)(v10 + 8 * v89) || v84 != *(xmlChar **)(v10 + 8 * v89 + 8))
              {
                v89 += 5;
                if ((int)v82 <= (int)v89) {
                  goto LABEL_182;
                }
              }
              goto LABEL_215;
            }
LABEL_182:
            uint64_t v17 = (v82 + 5);
            if (!v10 || (int)v17 > v132)
            {
              if ((xmlCtxtGrowAttrs(a1, (int)v82 + 5) & 0x80000000) != 0)
              {
                uint64_t v16 = 0;
                v18 = &xmlFree;
                goto LABEL_270;
              }
              int v132 = *(_DWORD *)(a1 + 472);
              uint64_t v10 = *(void *)(a1 + 464);
            }
            v90 = (const xmlChar **)(v10 + 8 * (int)v82);
            *v90 = v85;
            v90[1] = name2;
            v91 = name2;
            if (name2)
            {
              v92 = (xmlChar **)(a1 + 496);
              if (*(xmlChar **)(a1 + 480) == name2)
              {
LABEL_192:
                v91 = *v92;
              }
              else
              {
                int v93 = *(_DWORD *)(a1 + 508);
                while (1)
                {
                  BOOL v94 = __OFSUB__(v93, 2);
                  v93 -= 2;
                  if (v93 < 0 != v94) {
                    break;
                  }
                  uint64_t v95 = *(void *)(a1 + 520);
                  if (*(xmlChar **)(v95 + 8 * v93) == name2)
                  {
                    v92 = (xmlChar **)(v95 + 8 * (v93 + 1));
                    goto LABEL_192;
                  }
                }
                v91 = 0;
              }
            }
            *(void *)(v10 + 8 * ((int)v82 + 2)) = v91;
            v106 = &v79[10 * v80];
            uint64_t v107 = v10 + 8 * (int)v82;
            *(void *)(v107 + 24) = *((void *)v106 + 3);
            *(void *)(v107 + 32) = *((void *)v106 + 4);
            if (*(_DWORD *)(a1 + 48) == 1 && *((void *)v106 + 5)) {
              xmlValidityError((_DWORD *)a1, 538, "standalone: attribute %s on %s defaulted from external subset\n", v85, v16);
            }
            uint64_t v81 = (v81 + 1);
LABEL_221:
            ++v80;
            uint64_t v82 = v17;
            if (v80 >= *v79) {
              goto LABEL_225;
            }
          }
          int v88 = v134;
          if (v134 >= 1)
          {
            v96 = (void *)(*(void *)(a1 + 520) + 8 * *(int *)(a1 + 508) - 16);
            uint64_t v97 = (v134 + 1) - 1;
            while (*v96)
            {
              v96 -= 2;
              if (!--v97) {
                goto LABEL_197;
              }
            }
            goto LABEL_215;
          }
LABEL_197:
          if (*(void *)(a1 + 480))
          {
            int v98 = *(_DWORD *)(a1 + 508);
            while (1)
            {
              BOOL v94 = __OFSUB__(v98, 2);
              v98 -= 2;
              if (v98 < 0 != v94) {
                break;
              }
              uint64_t v99 = *(void *)(a1 + 520);
              if (!*(void *)(v99 + 8 * v98))
              {
                v100 = *(const xmlChar **)(v99 + 8 * (v98 + 1));
                if (*v100) {
                  goto LABEL_210;
                }
                break;
              }
            }
            v100 = 0;
          }
          else
          {
            v100 = *v135;
          }
LABEL_210:
          uint64_t v103 = *(void *)&v79[10 * v80 + 6];
          if (v100 != (const xmlChar *)v103)
          {
            uint64_t v104 = a1;
            uint64_t v105 = 0;
LABEL_212:
            if ((int)nsPush(v104, v105, v103) > 0) {
              ++v88;
            }
            int v134 = v88;
          }
LABEL_215:
          uint64_t v17 = v82;
          goto LABEL_221;
        }
      }
    }
    uint64_t v81 = 0;
LABEL_225:
    if ((int)v17 >= 1)
    {
      unint64_t v108 = 0;
      while (1)
      {
        v109 = *(const xmlChar **)(v10 + 8 * (v108 + 1));
        if (v109) {
          break;
        }
        v113 = 0;
        if (v108)
        {
LABEL_238:
          unint64_t v114 = 0;
          v115 = *(const xmlChar **)(v10 + 8 * v108);
          while (1)
          {
            if (v115 == *(const xmlChar **)(v10 + 8 * v114))
            {
              v116 = *(const xmlChar **)(v10 + 8 * (v108 + 1));
              if (v116 == *(const xmlChar **)(v10 + 8 * v114 + 8))
              {
                xmlErrAttributeDup((_DWORD *)a1, v116, *(xmlChar **)(v10 + 8 * v108));
                goto LABEL_247;
              }
              if (v113 && *(xmlChar **)(v10 + 8 * v114 + 16) == v113) {
                break;
              }
            }
            v114 += 5;
            if (v114 >= v108) {
              goto LABEL_247;
            }
          }
          xmlNsErr((_DWORD *)a1, 203, "Namespaced Attribute %s in '%s' redefined\n", v115, v113, 0);
        }
LABEL_247:
        v108 += 5;
        if ((int)v17 <= (int)v108) {
          goto LABEL_248;
        }
      }
      v110 = (xmlChar **)(a1 + 496);
      if (*(const xmlChar **)(a1 + 480) == v109)
      {
LABEL_233:
        v113 = *v110;
        if (!*v110) {
          goto LABEL_234;
        }
      }
      else
      {
        int v111 = *(_DWORD *)(a1 + 508);
        while (1)
        {
          BOOL v94 = __OFSUB__(v111, 2);
          v111 -= 2;
          if (v111 < 0 != v94) {
            break;
          }
          uint64_t v112 = *(void *)(a1 + 520);
          if (*(const xmlChar **)(v112 + 8 * v111) == v109)
          {
            v110 = (xmlChar **)(v112 + 8 * (v111 + 1));
            goto LABEL_233;
          }
        }
LABEL_234:
        xmlNsErr((_DWORD *)a1, 201, "Namespace prefix %s for %s on %s is not defined\n", v109, *(xmlChar **)(v10 + 8 * v108), v16);
        v113 = 0;
      }
      *(void *)(v10 + 8 * v108 + 16) = v113;
      if (v108) {
        goto LABEL_238;
      }
      goto LABEL_247;
    }
LABEL_248:
    v117 = v139;
    uint64_t Namespace = xmlGetNamespace(a1, (uint64_t)v139);
    uint64_t v119 = Namespace;
    if (v117 && !Namespace) {
      xmlNsErr((_DWORD *)a1, 201, "Namespace prefix %s on %s is not defined\n", v117, v16, 0);
    }
    *v127 = v117;
    uint64_t *v128 = v119;
    int v73 = v133;
    if (*(void *)a1)
    {
      v120 = *(void (**)(uint64_t, xmlChar *, const xmlChar *, uint64_t, void, uint64_t, void, uint64_t, uint64_t))(*(void *)a1 + 232);
      if (v120)
      {
        if (!*(_DWORD *)(a1 + 332))
        {
          uint64_t v121 = *(void *)(a1 + 8);
          if (v134 < 1) {
            v120(v121, v16, v117, v119, 0, 0, ((int)v17 / 5), v81, v10);
          }
          else {
            v120(v121, v16, v117, v119, v134, *(void *)(a1 + 520) + 8 * (*(_DWORD *)(a1 + 508) - 2 * v134), ((int)v17 / 5), v81, v10);
          }
        }
      }
    }
    v18 = &xmlFree;
  }
  else
  {
    xmlFatalErr((_DWORD *)a1, 1, (const xmlChar *)"Unexpected change of input\n");
    uint64_t v16 = 0;
  }
LABEL_258:
  if (v130 && v73 >= 1)
  {
    uint64_t v122 = 0;
    v123 = (void *)(v10 + 24);
    uint64_t v124 = 4 * v73;
    do
    {
      if (*(_DWORD *)(*(void *)(a1 + 528) + v122) && *v123) {
        ((void (*)(void))*v18)();
      }
      v122 += 4;
      v123 += 5;
    }
    while (v124 != v122);
  }
  return v16;
}

int xmlSkipBlankChars(xmlParserCtxtPtr ctxt)
{
  xmlParserInputState instate = ctxt->instate;
  if (ctxt->inputNr == 1)
  {
    if (instate == XML_PARSER_DTD)
    {
      BOOL v3 = ctxt->external == 0;
      goto LABEL_22;
    }
    goto LABEL_6;
  }
  if (instate == XML_PARSER_EOF)
  {
    unint64_t v4 = 0;
    goto LABEL_18;
  }
  if (instate == XML_PARSER_START)
  {
LABEL_6:
    unint64_t v4 = 0;
LABEL_7:
    xmlParserInputPtr input = ctxt->input;
    cur = input->cur;
    while (1)
    {
      int v7 = *cur;
      if (v7 == 32) {
        goto LABEL_13;
      }
      if ((v7 - 9) >= 2) {
        break;
      }
      if (v7 != 10) {
        goto LABEL_13;
      }
      ++input->line;
      input->col = 1;
LABEL_14:
      int v8 = *++cur;
      ++v4;
      if (!v8)
      {
        input->cur = cur;
        xmlParserInputGrow(input, 250);
        goto LABEL_7;
      }
    }
    if (v7 != 13)
    {
      input->cur = cur;
      goto LABEL_18;
    }
LABEL_13:
    ++input->col;
    goto LABEL_14;
  }
  BOOL v3 = 0;
LABEL_22:
  unint64_t v4 = 0;
  do
  {
    uint64_t v10 = ctxt->input->cur;
    uint64_t v11 = *v10;
    if (v11 > 0x25) {
      break;
    }
    if (((1 << v11) & 0x100002600) != 0)
    {
      xmlNextChar(ctxt);
    }
    else if (*v10)
    {
      if (v11 != 37 || v3) {
        break;
      }
      unsigned int v12 = v10[1];
      BOOL v13 = v12 > 0x20;
      uint64_t v14 = (1 << v12) & 0x100002601;
      if (!v13 && v14 != 0) {
        break;
      }
      xmlParsePEReference(ctxt);
    }
    else
    {
      if (ctxt->inputNr < 2) {
        break;
      }
      xmlPopInput(ctxt);
    }
    ++v4;
  }
  while (ctxt->instate != XML_PARSER_EOF);
LABEL_18:
  if (v4 >= 0x7FFFFFFF) {
    return 0x7FFFFFFF;
  }
  else {
    return v4;
  }
}

void xmlNextChar(xmlParserCtxtPtr ctxt)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (!ctxt) {
    return;
  }
  if (ctxt->instate == XML_PARSER_EOF) {
    return;
  }
  xmlParserInputPtr input = ctxt->input;
  if (!input) {
    return;
  }
  cur = input->cur;
  end = input->end;
  if (cur > end)
  {
    xmlErrInternal(ctxt, "Parser input data memory error\n", 0);
    ctxt->errNo = 1;
    xmlStopParser(ctxt);
    return;
  }
  if (end - cur <= 0 && xmlParserInputGrow(input, 250) < 1) {
    return;
  }
  xmlParserInputPtr v5 = ctxt->input;
  int v6 = v5->cur;
  int v7 = *v6;
  if (ctxt->charset != 1)
  {
    if (v7 == 10)
    {
      ++v5->line;
      v5->col = 1;
    }
    else
    {
      ++v5->col;
    }
LABEL_33:
    BOOL v13 = v6 + 1;
    goto LABEL_34;
  }
  if (v7 == 10)
  {
    ++v5->line;
    v5->col = 1;
  }
  else
  {
    ++v5->col;
  }
  if ((*(char *)v6 & 0x80000000) == 0) {
    goto LABEL_33;
  }
  int v8 = *v6;
  if (v8 == 192) {
    goto LABEL_39;
  }
  unint64_t v9 = v5->end - v6;
  if (v9 <= 1)
  {
    xmlParserInputGrow(v5, 250);
    xmlParserInputPtr v5 = ctxt->input;
    int v6 = v5->cur;
    unint64_t v9 = v5->end - v6;
    if (v9 < 2) {
      goto LABEL_39;
    }
  }
  if ((v6[1] & 0xC0) != 0x80) {
    goto LABEL_39;
  }
  if ((~v8 & 0xE0) == 0)
  {
    if (v9 > 2 || (xmlParserInputGrow(v5, 250), xmlParserInputPtr v5 = ctxt->input, v6 = v5->cur, v9 = v5->end - v6, v9 >= 3))
    {
      uint64_t v10 = v6 + 2;
      if ((v6[2] & 0xC0) == 0x80)
      {
        if ((~v8 & 0xF0) != 0)
        {
          v5->cur += 3;
          int v12 = (*v6 & 0xF) << 12;
          int v11 = (v6[1] & 0x3F) << 6;
LABEL_46:
          unsigned int v17 = v11 | v12 | *v10 & 0x3F;
          if ((v11 | v12) >> 11 == 27
            || HIWORD(v17) > 0x10u
            || ((v11 | v12) & 0x1FFFFE | *v10 & 0x3E) == 65534)
          {
            xmlErrEncodingInt(ctxt, "Char 0x%X out of allowed range\n", v17);
            xmlParserInputPtr v5 = ctxt->input;
          }
          goto LABEL_35;
        }
        if (v9 <= 3)
        {
          xmlParserInputGrow(v5, 250);
          xmlParserInputPtr v5 = ctxt->input;
          int v6 = v5->cur;
          unint64_t v9 = v5->end - v6;
        }
        if ((v8 & 0xF8) == 0xF0 && v9 >= 4)
        {
          uint64_t v10 = v6 + 3;
          if ((v6[3] & 0xC0) == 0x80)
          {
            v5->cur += 4;
            int v11 = ((*v6 & 7) << 18) | ((v6[1] & 0x3F) << 12);
            int v12 = (v6[2] & 0x3F) << 6;
            goto LABEL_46;
          }
        }
      }
    }
LABEL_39:
    if (v5->end - v5->cur > 3)
    {
      long long v27 = 0u;
      memset(v28, 0, sizeof(v28));
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      *(_OWORD *)__str = 0u;
      snprintf(__str, 0x95uLL, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n", *v5->cur, *((unsigned __int8 *)v5->cur + 1), *((unsigned __int8 *)v5->cur + 2), *((unsigned __int8 *)v5->cur + 3));
      uint64_t v14 = "Input is not proper UTF-8, indicate encoding !\n%s";
      uint64_t v16 = __str;
      xmlParserCtxtPtr v15 = ctxt;
    }
    else
    {
      uint64_t v14 = "Input is not proper UTF-8, indicate encoding !\n";
      xmlParserCtxtPtr v15 = ctxt;
      uint64_t v16 = 0;
    }
    __xmlErrEncoding(v15, 9, v14, (const xmlChar *)v16, 0);
    ctxt->charset = 10;
    ++ctxt->input->cur;
    return;
  }
  BOOL v13 = v6 + 2;
LABEL_34:
  v5->cur = v13;
LABEL_35:
  if (v5->end - v5->cur <= 0)
  {
    xmlParserInputGrow(v5, 250);
  }
}

const xmlChar *xmlParseQName(uint64_t a1, const xmlChar **a2)
{
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40) - *(void *)(*(void *)(a1 + 56) + 32)) <= 249)
  {
    xmlGROW(a1);
  }
  unint64_t v4 = xmlParseNCName(a1);
  int v5 = **(unsigned __int8 **)(*(void *)(a1 + 56) + 32);
  if (v4)
  {
    int v6 = v4;
    if (v5 == 58)
    {
      xmlNextChar((xmlParserCtxtPtr)a1);
      int v7 = (xmlChar *)xmlParseNCName(a1);
      if (v7)
      {
        int v8 = v7;
        if (**(unsigned char **)(*(void *)(a1 + 56) + 32) == 58)
        {
          xmlNsErr((_DWORD *)a1, 202, "Failed to parse QName '%s:%s:'\n", v6, v7, 0);
          xmlNextChar((xmlParserCtxtPtr)a1);
          unint64_t v9 = xmlParseName((xmlParserCtxtPtr)a1);
          if (v9)
          {
LABEL_11:
            uint64_t v10 = xmlBuildQName(v9, v8, 0, 0);
            int v11 = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), v10, -1);
            if (v10) {
              xmlFree(v10);
            }
            int v12 = v6;
            int v6 = v11;
            goto LABEL_26;
          }
          if (*(_DWORD *)(a1 + 272) != -1)
          {
            unint64_t v9 = (const xmlChar *)"";
            goto LABEL_11;
          }
          return 0;
        }
        int v12 = v6;
        int v6 = v7;
LABEL_26:
        *a2 = v12;
        return v6;
      }
      if (*(_DWORD *)(a1 + 272) == -1) {
        return 0;
      }
      xmlNsErr((_DWORD *)a1, 202, "Failed to parse QName '%s:'\n", v6, 0, 0);
      BOOL v13 = xmlParseNmtoken((xmlParserCtxtPtr)a1);
      if (v13)
      {
        uint64_t v14 = v13;
        xmlParserCtxtPtr v15 = xmlBuildQName(v13, v6, 0, 0);
        xmlFree(v14);
      }
      else
      {
        if (*(_DWORD *)(a1 + 272) == -1) {
          return 0;
        }
        xmlParserCtxtPtr v15 = xmlBuildQName((const xmlChar *)"", v6, 0, 0);
      }
      int v6 = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), v15, -1);
      if (v15) {
        xmlFree(v15);
      }
    }
LABEL_25:
    int v12 = 0;
    goto LABEL_26;
  }
  if (v5 != 58) {
    return 0;
  }
  int v6 = xmlParseName((xmlParserCtxtPtr)a1);
  if (v6)
  {
    xmlNsErr((_DWORD *)a1, 202, "Failed to parse QName '%s'\n", v6, 0, 0);
    goto LABEL_25;
  }
  return v6;
}

const xmlChar *xmlParseNCName(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 564);
  if ((v2 & 0x80000) != 0) {
    unint64_t v3 = 10000000;
  }
  else {
    unint64_t v3 = 50000;
  }
  unint64_t v4 = *(void **)(a1 + 56);
  int v6 = (const xmlChar *)v4[4];
  unint64_t v5 = v4[5];
  int v7 = *v6;
  if ((v7 & 0xFFFFFFDF) - 65 >= 0x1A)
  {
    if (v7 != 95 || (unint64_t)v6 >= v5) {
      goto LABEL_27;
    }
  }
  else if ((unint64_t)v6 >= v5)
  {
    goto LABEL_27;
  }
  uint64_t v9 = 0;
  do
  {
    uint64_t v10 = v9;
    int v11 = v6[v9 + 1];
    if ((v11 - 48) >= 0xA
      && (v11 & 0xFFFFFFDF) - 65 >= 0x1A
      && ((v11 - 45) > 0x32 || ((1 << (v11 - 45)) & 0x4000000000003) == 0))
    {
      break;
    }
    ++v9;
  }
  while ((unint64_t)&v6[v10 + 1] < v5);
  unint64_t v14 = (unint64_t)&v6[v10 + 1];
  if (v14 < v5 && (char)v11 >= 1)
  {
    if (v10 + 1 <= v3)
    {
      result = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), v6, (int)v10 + 1);
      uint64_t v16 = *(void *)(a1 + 56);
      *(void *)(v16 + 32) = v14;
      *(_DWORD *)(v16 + 56) += v10 + 1;
      if (result) {
        return result;
      }
      htmlErrMemory((_DWORD *)a1, 0);
      return 0;
    }
    goto LABEL_65;
  }
LABEL_27:
  if ((v2 & 0x80000) != 0) {
    int v17 = 10000000;
  }
  else {
    int v17 = 50000;
  }
  if (!*(_DWORD *)(a1 + 452) && (uint64_t)(v5 - (void)v6) <= 249)
  {
    xmlGROW(a1);
    unint64_t v4 = *(void **)(a1 + 56);
    int v6 = (const xmlChar *)v4[4];
  }
  int len = 0;
  uint64_t v18 = v4[3];
  unsigned int v19 = xmlCurrentChar((xmlParserCtxtPtr)a1, &len);
  unsigned int v20 = v19;
  if (v19 <= 0x3E && ((1 << v19) & 0x4000800100000000) != 0) {
    return 0;
  }
  xmlIsNameStartChar(a1, v19);
  int v22 = v21;
  result = 0;
  if (v20 != 58 && v22)
  {
    int v23 = 0;
    int v24 = 0;
    long long v25 = &v6[-v18];
    while (v20 > 0x3E || ((1 << v20) & 0x4000800100000000) == 0)
    {
      xmlIsNameChar(a1, v20);
      if (v20 == 58 || !v26) {
        break;
      }
      if (v24 < 101)
      {
        ++v24;
      }
      else
      {
        if (!*(_DWORD *)(a1 + 452)
          && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40) - *(void *)(*(void *)(a1 + 56) + 32)) <= 249)
        {
          xmlGROW(a1);
        }
        if (*(_DWORD *)(a1 + 272) == -1) {
          return 0;
        }
        int v24 = 0;
      }
      if (v23 <= (len ^ 0x7FFFFFFF)) {
        int v27 = len;
      }
      else {
        int v27 = 0;
      }
      uint64_t v28 = *(void *)(a1 + 56);
      uint64_t v29 = *(unsigned char **)(v28 + 32);
      v30 = &v29[len];
      if ((unint64_t)v30 <= *(void *)(v28 + 40))
      {
        if (*v29 == 10)
        {
          ++*(_DWORD *)(v28 + 52);
          *(_DWORD *)(v28 + 56) = 1;
        }
        else
        {
          ++*(_DWORD *)(v28 + 56);
        }
        *(void *)(v28 + 32) = v30;
      }
      v23 += v27;
      unsigned int v20 = xmlCurrentChar((xmlParserCtxtPtr)a1, &len);
      if (!v20)
      {
        if (*(_DWORD *)(a1 + 272) == -1) {
          return 0;
        }
        uint64_t v31 = len;
        uint64_t v32 = *(void *)(a1 + 56);
        uint64_t v33 = *(void *)(v32 + 32) - len;
        *(void *)(v32 + 32) = v33;
        if (!*(_DWORD *)(a1 + 452) && *(void *)(v32 + 40) - v33 <= 249)
        {
          xmlGROW(a1);
          if (*(_DWORD *)(a1 + 272) == -1) {
            return 0;
          }
          uint64_t v31 = len;
          uint64_t v32 = *(void *)(a1 + 56);
          uint64_t v33 = *(void *)(v32 + 32);
        }
        *(void *)(v32 + 32) = v33 + v31;
        unsigned int v20 = xmlCurrentChar((xmlParserCtxtPtr)a1, &len);
        int v24 = 0;
      }
    }
    if (v23 <= v17) {
      return xmlDictLookup(*(xmlDictPtr *)(a1 + 456), &v25[*(void *)(*(void *)(a1 + 56) + 24)], v23);
    }
LABEL_65:
    xmlFatalErr((_DWORD *)a1, 110, (const xmlChar *)"NCName");
    return 0;
  }
  return result;
}

xmlChar *xmlParseAttValueInternal(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v7 = a1;
  if ((*(unsigned char *)(a1 + 566) & 8) != 0) {
    uint64_t v8 = 1000000000;
  }
  else {
    uint64_t v8 = 10000000;
  }
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40) - *(void *)(*(void *)(a1 + 56) + 32)) <= 249)
  {
    uint64_t v9 = v8;
    xmlGROW(a1);
    uint64_t v8 = v9;
  }
  uint64_t v10 = *(void *)(v7 + 56);
  int v11 = *(unsigned __int8 **)(v10 + 32);
  int v12 = *(_DWORD *)(v10 + 52);
  int v13 = *v11;
  if (v13 != 34 && v13 != 39) {
    goto LABEL_236;
  }
  int v14 = *(_DWORD *)(v10 + 56);
  int v15 = 12;
  *(_DWORD *)(v7 + 272) = 12;
  uint64_t v16 = v11 + 1;
  uint64_t v17 = *v11;
  unint64_t v18 = *(void *)(v10 + 40);
  unint64_t v114 = a3;
  if ((unint64_t)(v11 + 1) >= v18)
  {
    uint64_t v19 = *(void *)(v10 + 24);
    if ((uint64_t)(v18 - (void)v11) <= 249 && *(_DWORD *)(v7 + 452) == 0)
    {
      uint64_t v21 = v8;
      xmlGROW(v7);
      uint64_t v8 = v21;
      int v15 = *(_DWORD *)(v7 + 272);
      if (v15 == -1) {
        return 0;
      }
    }
    else
    {
      int v15 = 12;
    }
    uint64_t v10 = *(void *)(v7 + 56);
    uint64_t v22 = *(void *)(v10 + 24) - v19;
    if (!v22) {
      uint64_t v22 = 0;
    }
    v16 += v22;
    unint64_t v18 = *(void *)(v10 + 40);
  }
  int v23 = v14 + 1;
  if (a4)
  {
    while ((unint64_t)v16 < v18)
    {
      unsigned int v24 = *v16;
      if (v24 == v17) {
        break;
      }
      if (v24 > 0x20 || ((1 << v24) & 0x100002600) == 0) {
        break;
      }
      if (v24 == 10)
      {
        ++v12;
        int v23 = 1;
      }
      else
      {
        ++v23;
      }
      if ((unint64_t)++v16 >= v18)
      {
        uint64_t v26 = *(void *)(v10 + 24);
        if (!*(_DWORD *)(v7 + 452) && (uint64_t)(*(void *)(v10 + 40) - *(void *)(v10 + 32)) <= 249)
        {
          uint64_t v27 = v7;
          uint64_t v28 = v17;
          uint64_t v29 = v7;
          uint64_t v30 = a4;
          uint64_t v31 = a2;
          uint64_t v32 = v8;
          xmlGROW(v27);
          uint64_t v8 = v32;
          a2 = v31;
          a4 = v30;
          uint64_t v7 = v29;
          uint64_t v17 = v28;
          int v15 = *(_DWORD *)(v7 + 272);
        }
        if (v15 == -1) {
          return 0;
        }
        uint64_t v10 = *(void *)(v7 + 56);
        uint64_t v33 = *(void *)(v10 + 24) - v26;
        if (!v33) {
          uint64_t v33 = 0;
        }
        v16 += v33;
        unint64_t v18 = *(void *)(v10 + 40);
      }
    }
    uint64_t v112 = a2;
    int v113 = a4;
    uint64_t i = v16;
    if ((unint64_t)v16 < v18)
    {
      while (1)
      {
        int v35 = v23;
        int v36 = *v16;
        if ((char)*v16 < 32 || v36 == v17) {
          break;
        }
        if (v36 == 38) {
          break;
        }
        if (v36 == 60) {
          break;
        }
        ++v23;
        ++v16;
        if (v36 == 32 && *v16 == 32) {
          break;
        }
        if ((unint64_t)v16 >= v18)
        {
          uint64_t v38 = *(void *)(v10 + 24);
          if (!*(_DWORD *)(v7 + 452) && (uint64_t)(*(void *)(v10 + 40) - *(void *)(v10 + 32)) <= 249)
          {
            uint64_t v39 = v7;
            int v110 = v17;
            uint64_t v17 = v7;
            uint64_t v40 = a4;
            int v41 = a2;
            uint64_t v42 = v8;
            xmlGROW(v39);
            uint64_t v8 = v42;
            a2 = v41;
            a4 = v40;
            uint64_t v7 = v17;
            LODWORD(v17) = v110;
            int v15 = *(_DWORD *)(v7 + 272);
          }
          if (v15 == -1) {
            return 0;
          }
          uint64_t v10 = *(void *)(v7 + 56);
          uint64_t v43 = *(void *)(v10 + 24) - v38;
          if (!v43) {
            uint64_t v43 = 0;
          }
          i += v43;
          v16 += v43;
          if (v16 - i > v8) {
            goto LABEL_102;
          }
          unint64_t v18 = *(void *)(v10 + 40);
        }
        if ((unint64_t)v16 >= v18)
        {
          int v23 = v35 + 1;
          break;
        }
      }
    }
    xmlURIPtr v50 = v16;
    v51 = v16;
    v52 = v16;
    do
    {
      int v53 = *--v52;
      BOOL v54 = v53 == 32 && v51 > i;
      v51 = v52;
    }
    while (v54);
    LODWORD(v16) = v52 + 1;
    while ((unint64_t)v50 < v18)
    {
      unsigned int v55 = *v50;
      if (v55 == v17) {
        break;
      }
      if (v55 > 0x20 || ((1 << v55) & 0x100002600) == 0) {
        break;
      }
      if (v55 == 10)
      {
        ++v12;
        int v23 = 1;
      }
      else
      {
        ++v23;
      }
      if ((unint64_t)++v50 >= v18)
      {
        uint64_t v57 = *(void *)(v10 + 24);
        if (!*(_DWORD *)(v7 + 452) && (uint64_t)(*(void *)(v10 + 40) - *(void *)(v10 + 32)) <= 249)
        {
          uint64_t v58 = v8;
          xmlGROW(v7);
          uint64_t v8 = v58;
          int v15 = *(_DWORD *)(v7 + 272);
        }
        if (v15 == -1) {
          return 0;
        }
        uint64_t v10 = *(void *)(v7 + 56);
        uint64_t v59 = *(void *)(v10 + 24) - v57;
        if (!v59) {
          uint64_t v59 = 0;
        }
        i += v59;
        v50 += v59;
        if (v50 - i > v8) {
          goto LABEL_102;
        }
        LODWORD(v16) = v16 + v59;
        unint64_t v18 = *(void *)(v10 + 40);
      }
    }
    if (v50 - i > v8) {
      goto LABEL_102;
    }
    int v49 = *v50;
  }
  else
  {
    for (uint64_t i = v16; (unint64_t)v16 < v18; ++v23)
    {
      int v44 = *v16;
      BOOL v45 = (char)*v16 < 32 || v44 == v17;
      if (v45 || v44 == 38 || v44 == 60) {
        break;
      }
      if ((unint64_t)++v16 >= v18)
      {
        uint64_t v46 = *(void *)(v10 + 24);
        if (!*(_DWORD *)(v7 + 452) && (uint64_t)(*(void *)(v10 + 40) - *(void *)(v10 + 32)) <= 249)
        {
          uint64_t v47 = v8;
          xmlGROW(v7);
          uint64_t v8 = v47;
          int v15 = *(_DWORD *)(v7 + 272);
        }
        if (v15 == -1) {
          return 0;
        }
        uint64_t v10 = *(void *)(v7 + 56);
        uint64_t v48 = *(void *)(v10 + 24) - v46;
        if (!v48) {
          uint64_t v48 = 0;
        }
        i += v48;
        v16 += v48;
        if (v16 - i > v8) {
          goto LABEL_102;
        }
        unint64_t v18 = *(void *)(v10 + 40);
      }
    }
    if (v16 - i > v8)
    {
LABEL_102:
      xmlFatalErrMsg((_DWORD *)v7, 40, (char)"AttValue length too long\n");
      return 0;
    }
    int v113 = 0;
    uint64_t v112 = a2;
    int v49 = *v16;
    xmlURIPtr v50 = v16;
  }
  if (v49 == v17)
  {
    if (v112)
    {
      *uint64_t v112 = v16 - i;
      v60 = v114;
    }
    else
    {
      v60 = v114;
      if (v114) {
        *unint64_t v114 = 1;
      }
      uint64_t i = xmlStrndup(i, (int)v16 - (int)i);
      uint64_t v10 = *(void *)(v7 + 56);
    }
    *(void *)(v10 + 32) = v50 + 1;
    *(_DWORD *)(v10 + 52) = v12;
    *(_DWORD *)(v10 + 56) = v23 + 1;
    if (v60) {
      _DWORD *v60 = 0;
    }
    return i;
  }
  if (v114) {
    *unint64_t v114 = 1;
  }
  unint64_t v61 = (*(_DWORD *)(v7 + 564) & 0x80000) != 0 ? 1000000000 : 10000000;
  int len = 0;
  int v62 = **(unsigned __int8 **)(v10 + 32);
  if (v62 != 34 && v62 != 39)
  {
LABEL_236:
    xmlFatalErr((_DWORD *)v7, 39, 0);
    return 0;
  }
  *(_DWORD *)(v7 + 272) = 12;
  xmlNextChar((xmlParserCtxtPtr)v7);
  int v63 = (xmlChar *)xmlMallocAtomic(0x64uLL);
  if (!v63)
  {
    int v72 = 0;
LABEL_245:
    v66 = 0;
    goto LABEL_246;
  }
  uint64_t i = v63;
  int v64 = xmlCurrentChar((xmlParserCtxtPtr)v7, &len);
  unint64_t v65 = 0;
  LODWORD(v66) = 0;
  unint64_t v67 = 100;
  while (1)
  {
    v68 = *(unsigned __int8 **)(*(void *)(v7 + 56) + 32);
    if (v62 == *v68)
    {
LABEL_250:
      if (*(_DWORD *)(v7 + 272) == -1)
      {
LABEL_257:
        v66 = 0;
        goto LABEL_247;
      }
      if (v113)
      {
        uint64_t v102 = v112;
        if (v66 && v65)
        {
          do
          {
            if (i[v65 - 1] != 32) {
              break;
            }
            --v65;
          }
          while (v65);
        }
      }
      else
      {
        uint64_t v102 = v112;
      }
      i[v65] = 0;
      int v103 = **(unsigned __int8 **)(*(void *)(v7 + 56) + 32);
      if (v103 == 60)
      {
        xmlFatalErr((_DWORD *)v7, 38, 0);
        goto LABEL_277;
      }
      if (v62 == v103)
      {
        xmlNextChar((xmlParserCtxtPtr)v7);
        goto LABEL_277;
      }
      if (v64)
      {
        if (v64 > 255)
        {
          if ((v64 - 0x10000) >= 0x100000
            && v64 >> 11 >= 0x1B
            && (v64 - 57344) >> 1 >= 0xFFF)
          {
            goto LABEL_274;
          }
        }
        else if (v64 <= 31 && (v64 > 0xD || ((1 << v64) & 0x2600) == 0))
        {
LABEL_274:
          uint64_t v104 = "invalid character in attribute value\n";
          uint64_t v105 = (_DWORD *)v7;
          int v106 = 9;
LABEL_276:
          xmlFatalErrMsg(v105, v106, (char)v104);
LABEL_277:
          if (v102) {
            *uint64_t v102 = v65;
          }
          return i;
        }
      }
      uint64_t v104 = "AttValue: ' expected\n";
      uint64_t v105 = (_DWORD *)v7;
      int v106 = 40;
      goto LABEL_276;
    }
    if (v64 > 255)
    {
      if ((v64 - 0x10000) >= 0x100000
        && v64 >> 11 >= 0x1B
        && (v64 - 57344) >> 1 >= 0xFFF)
      {
        goto LABEL_250;
      }
    }
    else if (v64 <= 31)
    {
      if (v64 > 0xD || ((1 << v64) & 0x2600) == 0) {
        goto LABEL_250;
      }
    }
    else if (v64 == 60)
    {
      goto LABEL_250;
    }
    if (*(_DWORD *)(v7 + 272) == -1) {
      goto LABEL_257;
    }
    if (v64 > 0x26)
    {
LABEL_147:
      if (len == 1) {
        i[v65++] = v64;
      }
      else {
        v65 += xmlCopyCharMultiByte(&i[v65], v64);
      }
      if (v65 + 10 <= v67)
      {
        LODWORD(v66) = 0;
      }
      else
      {
        if (2 * v67 + 10 < v67) {
          goto LABEL_258;
        }
        int v73 = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
        if (!v73) {
          goto LABEL_258;
        }
        LODWORD(v66) = 0;
        uint64_t i = v73;
        unint64_t v67 = 2 * v67 + 10;
      }
      goto LABEL_167;
    }
    if (((1 << v64) & 0x100002600) != 0)
    {
      if (!v113 || v65)
      {
        if (v113 && v66)
        {
          LODWORD(v66) = 1;
        }
        else
        {
          if (len == 1) {
            i[v65++] = 32;
          }
          else {
            v65 += xmlCopyCharMultiByte(&i[v65], 32);
          }
          while (1)
          {
            int v72 = i;
            if (v65 + 10 <= v67) {
              break;
            }
            if (2 * v67 + 10 >= v67)
            {
              uint64_t i = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
              unint64_t v67 = 2 * v67 + 10;
              if (i) {
                continue;
              }
            }
            goto LABEL_245;
          }
          LODWORD(v66) = 1;
        }
      }
LABEL_167:
      uint64_t v74 = *(void *)(v7 + 56);
      int v75 = *(unsigned char **)(v74 + 32);
      uint64_t v76 = &v75[len];
      if ((unint64_t)v76 <= *(void *)(v74 + 40))
      {
        if (*v75 == 10)
        {
          ++*(_DWORD *)(v74 + 52);
          *(_DWORD *)(v74 + 56) = 1;
        }
        else
        {
          ++*(_DWORD *)(v74 + 56);
        }
        *(void *)(v74 + 32) = v76;
      }
      goto LABEL_172;
    }
    if (v64 != 38) {
      goto LABEL_147;
    }
    if (v68[1] == 35)
    {
      int v69 = xmlParseCharRef((xmlParserCtxtPtr)v7);
      LODWORD(v66) = v69;
      if (!v69) {
        goto LABEL_172;
      }
      if (v69 == 38)
      {
        if (!*(_DWORD *)(v7 + 28))
        {
          if (v65 + 10 > v67)
          {
            if (2 * v67 + 10 < v67) {
              goto LABEL_258;
            }
            uint64_t v95 = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
            unint64_t v67 = 2 * v67 + 10;
            if (!v95) {
              goto LABEL_258;
            }
          }
          else
          {
            uint64_t v95 = i;
          }
          goto LABEL_220;
        }
        if (v65 + 10 > v67)
        {
          if (2 * v67 + 10 < v67) {
            goto LABEL_258;
          }
          uint64_t v95 = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
          unint64_t v67 = 2 * v67 + 10;
          if (!v95) {
            goto LABEL_258;
          }
        }
        else
        {
          uint64_t v95 = i;
        }
        LODWORD(v66) = 0;
        LOBYTE(v85) = 38;
LABEL_218:
        v95[v65++] = v85;
LABEL_221:
        uint64_t i = v95;
        goto LABEL_172;
      }
      if (v65 + 10 <= v67)
      {
        v77 = i;
      }
      else
      {
        if (2 * v67 + 10 < v67)
        {
          v66 = 0;
          int v72 = i;
          goto LABEL_246;
        }
        v77 = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
        unint64_t v67 = 2 * v67 + 10;
        if (!v77) {
          goto LABEL_258;
        }
      }
      int v84 = xmlCopyChar(0, &v77[v65], (int)v66);
      LODWORD(v66) = 0;
      v65 += v84;
      uint64_t i = v77;
      goto LABEL_172;
    }
    xmlEntityPtr v70 = xmlParseEntityRef((xmlParserCtxtPtr)v7);
    v66 = (unsigned __int8 **)v70;
    uint64_t v71 = *(void *)(v7 + 696) + 1;
    *(void *)(v7 + 696) = v71;
    if (!v70) {
      goto LABEL_172;
    }
    *(void *)(v7 + 696) = v71 + v70->owner;
    if (v70->etype == XML_INTERNAL_PREDEFINED_ENTITY)
    {
      if (v65 + 10 <= v67)
      {
        uint64_t v95 = i;
      }
      else
      {
        if (2 * v67 + 10 < v67) {
          goto LABEL_258;
        }
        uint64_t v95 = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
        unint64_t v67 = 2 * v67 + 10;
        if (!v95) {
          goto LABEL_258;
        }
      }
      int v85 = *v66[10];
      if (*(_DWORD *)(v7 + 28) || v85 != 38)
      {
        LODWORD(v66) = 0;
        goto LABEL_218;
      }
LABEL_220:
      LODWORD(v66) = 0;
      v96 = &v95[v65];
      *(_DWORD *)v96 = 942875430;
      v65 += 5;
      v96[4] = 59;
      goto LABEL_221;
    }
    if (!*(_DWORD *)(v7 + 28))
    {
      unint64_t v108 = v61;
      int v86 = xmlStrlen(v70->name);
      v87 = v66[2];
      int v107 = v86;
      if (*((_DWORD *)v66 + 23) != 6)
      {
        int v88 = v66[10];
        if (v88)
        {
          if (!*((_DWORD *)v66 + 33))
          {
            uint64_t v89 = *(void *)(v7 + 696);
            ++*(_DWORD *)(v7 + 392);
            int v90 = xmlStrlen(v88);
            v91 = xmlStringLenDecodeEntities((xmlParserCtxtPtr)v7, v88, v90, 1, 0, 0, 0);
            --*(_DWORD *)(v7 + 392);
            uint64_t v92 = *(void *)(v7 + 696) - v89;
            if ((unint64_t)(v92 + 1) < 0x3FFFFFFF) {
              int v93 = v92 + 1;
            }
            else {
              int v93 = 0x3FFFFFFF;
            }
            *((_DWORD *)v66 + 33) = 2 * v93;
            if (v91)
            {
              BOOL v94 = v91;
              if (xmlStrchr(v91, 0x3Cu)) {
                *((_DWORD *)v66 + 33) |= 1u;
              }
              ((void (*)(xmlChar *))xmlFree)(v94);
            }
            else
            {
              *v66[10] = 0;
            }
            int v86 = v107;
          }
        }
      }
      unint64_t v97 = v65 + 1;
      i[v65] = 38;
      uint64_t v109 = v86 + 10;
      unint64_t v111 = v65 + v86 + 11;
      while (1)
      {
        int v72 = i;
        if (v111 <= v67) {
          break;
        }
        if (v109 + 2 * v67 < v67)
        {
          v66 = 0;
          goto LABEL_246;
        }
        uint64_t i = (xmlChar *)xmlRealloc(i, v109 + 2 * v67);
        v66 = 0;
        unint64_t v67 = v109 + 2 * v67;
        if (!i) {
          goto LABEL_246;
        }
      }
      if (v107 < 1)
      {
        unint64_t v100 = v65 + 1;
      }
      else
      {
        unsigned int v98 = v107 + 1;
        do
        {
          xmlChar v99 = *v87++;
          unint64_t v100 = v97 + 1;
          i[v97] = v99;
          --v98;
          ++v97;
        }
        while (v98 > 1);
      }
      LODWORD(v66) = 0;
      unint64_t v65 = v100 + 1;
      i[v100] = 59;
LABEL_235:
      unint64_t v61 = v108;
      goto LABEL_172;
    }
    ++*(_DWORD *)(v7 + 392);
    v78 = xmlStringDecodeEntities((xmlParserCtxtPtr)v7, v70->content, 1, 0, 0, 0);
    v66 = (unsigned __int8 **)v78;
    --*(_DWORD *)(v7 + 392);
    if (v78) {
      break;
    }
LABEL_172:
    if (!*(_DWORD *)(v7 + 452)
      && (uint64_t)(*(void *)(*(void *)(v7 + 56) + 40) - *(void *)(*(void *)(v7 + 56) + 32)) <= 249)
    {
      xmlGROW(v7);
    }
    int v64 = xmlCurrentChar((xmlParserCtxtPtr)v7, &len);
    if (v65 > v61)
    {
      xmlFatalErrMsg((_DWORD *)v7, 40, (char)"AttValue length too long\n");
LABEL_258:
      v66 = 0;
      int v72 = i;
      goto LABEL_246;
    }
  }
  unint64_t v108 = v61;
  v79 = v78;
  do
  {
    int v72 = i;
    unint64_t v80 = v65;
    do
    {
      int v81 = *v79;
      if ((v81 - 9) < 2 || v81 == 13)
      {
        LOBYTE(v81) = 32;
      }
      else if (!*v79)
      {
        ((void (*)(unsigned __int8 **))xmlFree)(v66);
        LODWORD(v66) = 0;
        unint64_t v65 = v80;
        goto LABEL_235;
      }
      i[v80] = v81;
      ++v79;
      unint64_t v65 = v80 + 1;
      unint64_t v83 = v80 + 11;
      ++v80;
    }
    while (v83 <= v67);
    if (2 * v67 + 10 < v67) {
      break;
    }
    uint64_t i = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
    unint64_t v67 = 2 * v67 + 10;
  }
  while (i);
LABEL_246:
  htmlErrMemory((_DWORD *)v7, 0);
  uint64_t i = v72;
  if (v72) {
LABEL_247:
  }
    ((void (*)(xmlChar *))xmlFree)(i);
  if (v66) {
    ((void (*)(unsigned __int8 **))xmlFree)(v66);
  }
  return 0;
}

char *xmlSAX2TextNode(uint64_t a1, char *__src, int len)
{
  int v6 = *(char **)(a1 + 576);
  if (v6)
  {
    *(void *)(a1 + 576) = *((void *)v6 + 6);
    --*(_DWORD *)(a1 + 572);
  }
  else
  {
    int v6 = (char *)xmlMalloc(0x78uLL);
    if (!v6)
    {
      htmlErrMemory((_DWORD *)a1, (const xmlChar *)"xmlSAX2Characters");
      return v6;
    }
  }
  *((void *)v6 + 14) = 0;
  *((_OWORD *)v6 + 5) = 0u;
  *((_OWORD *)v6 + 6) = 0u;
  *((_OWORD *)v6 + 3) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  *((_OWORD *)v6 + 1) = 0u;
  *((_OWORD *)v6 + 2) = 0u;
  *(_OWORD *)int v6 = 0u;
  if (!*(_DWORD *)(a1 + 568)) {
    goto LABEL_22;
  }
  int v7 = __src[len];
  if (len > 15) {
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 566))
  {
    uint64_t v9 = (const xmlChar *)(v6 + 88);
    memcpy(v6 + 88, __src, len);
    v6[len + 88] = 0;
    *((_DWORD *)v6 + 2) = 3;
    *((void *)v6 + 2) = "text";
    goto LABEL_33;
  }
  if (len > 3 || v7 != 34 && v7 != 39 && (v7 != 60 || __src[len + 1] == 33))
  {
LABEL_12:
    unsigned int v8 = *__src;
    if (v8 <= 0x20 && ((1 << v8) & 0x100000600) != 0)
    {
      if (len > 59)
      {
LABEL_22:
        *((_DWORD *)v6 + 2) = 3;
        *((void *)v6 + 2) = "text";
        goto LABEL_23;
      }
    }
    else if (len > 59 || v8 != 13)
    {
      goto LABEL_22;
    }
    if (v7 != 60 || __src[len + 1] == 33) {
      goto LABEL_22;
    }
    if (len >= 2)
    {
      int v11 = (unsigned __int8 *)(__src + 1);
      uint64_t v12 = len - 1;
      do
      {
        unsigned int v13 = *v11++;
        uint64_t v14 = (1 << v13) & 0x100002600;
        if (v13 > 0x20 || v14 == 0) {
          goto LABEL_22;
        }
      }
      while (--v12);
    }
  }
  uint64_t v9 = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), (const xmlChar *)__src, len);
  *((_DWORD *)v6 + 2) = 3;
  *((void *)v6 + 2) = "text";
  if (!v9)
  {
LABEL_23:
    uint64_t v10 = xmlStrndup((const xmlChar *)__src, len);
    *((void *)v6 + 10) = v10;
    if (!v10)
    {
      xmlSAX2ErrMemory((uint64_t *)a1, "xmlSAX2TextNode");
      xmlFree(v6);
      return 0;
    }
    goto LABEL_34;
  }
LABEL_33:
  *((void *)v6 + 10) = v9;
LABEL_34:
  if (*(_DWORD *)(a1 + 436))
  {
    uint64_t v16 = *(void *)(a1 + 56);
    if (v16)
    {
      uint64_t v17 = *(unsigned int *)(v16 + 52);
      if ((int)v17 > 65534)
      {
        *((_WORD *)v6 + 56) = -1;
        if ((*(unsigned char *)(a1 + 566) & 0x40) != 0) {
          *((void *)v6 + 13) = v17;
        }
      }
      else
      {
        *((_WORD *)v6 + 56) = v17;
      }
    }
  }
  if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
  {
    unint64_t v18 = __xmlRegisterNodeDefaultValue();
    ((void (*)(char *))*v18)(v6);
  }
  return v6;
}

xmlChar *__cdecl xmlStrndup(const xmlChar *cur, int len)
{
  int v2 = 0;
  if (cur)
  {
    if ((len & 0x80000000) == 0)
    {
      size_t v4 = len;
      unint64_t v5 = (xmlChar *)xmlMallocAtomic(len + 1);
      int v2 = v5;
      if (v5)
      {
        memcpy(v5, cur, v4);
        v2[v4] = 0;
      }
    }
  }
  return v2;
}

void *xmlMallocZero(size_t size)
{
  result = malloc_type_calloc(1uLL, size, 0x298F6196uLL);
  if (!result) {
    abort();
  }
  return result;
}

const xmlChar *__cdecl xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len)
{
  unint64_t v3 = 0;
  if (!dict || !name) {
    return v3;
  }
  if (len < 0) {
    size_t v6 = strlen((const char *)name);
  }
  else {
    size_t v6 = len;
  }
  size_t v7 = *((void *)dict + 7);
  if (v7)
  {
    unint64_t v3 = 0;
    if (v6 >> 30 || v6 >= v7) {
      return v3;
    }
  }
  else if (v6 >> 30)
  {
    return 0;
  }
  unint64_t v8 = *((void *)dict + 2);
  if (v8 == 128)
  {
    unint64_t v9 = xmlDictComputeFastKey((unsigned __int8 *)name, v6, *((_DWORD *)dict + 12));
  }
  else
  {
    if (v6)
    {
      unsigned int v10 = *((_DWORD *)dict + 12);
      int v11 = name;
      size_t v12 = v6;
      do
      {
        int v13 = *v11++;
        unsigned int v10 = (1025 * (v10 + v13)) ^ ((1025 * (v10 + v13)) >> 6);
        --v12;
      }
      while (v12);
      unsigned int v14 = 32769 * ((9 * v10) ^ ((9 * v10) >> 11));
    }
    else
    {
      unsigned int v14 = 0;
    }
    unint64_t v9 = v14;
  }
  uint64_t v15 = *((void *)dict + 1) + 32 * (v9 % v8);
  unint64_t v41 = v9 % v8;
  if (!*(_DWORD *)(v15 + 20))
  {
    unint64_t v17 = 0;
    uint64_t v15 = 0;
LABEL_32:
    uint64_t v19 = *((void *)dict + 5);
    if (v19)
    {
      unint64_t v20 = *(void *)(v19 + 16);
      if (v8 == 128)
      {
        if (v20 == 128)
        {
          unint64_t v21 = v9;
        }
        else if ((int)v6 < 1)
        {
          unint64_t v21 = 0;
        }
        else
        {
          unsigned int v22 = *(_DWORD *)(v19 + 48);
          uint64_t v23 = v6;
          unsigned int v24 = name;
          do
          {
            int v25 = *v24++;
            unsigned int v22 = (1025 * (v22 + v25)) ^ ((1025 * (v22 + v25)) >> 6);
            --v23;
          }
          while (v23);
          unint64_t v21 = 32769 * ((9 * v22) ^ ((9 * v22) >> 11));
        }
      }
      else
      {
        unint64_t v21 = v9;
        if (v20 == 128)
        {
          unint64_t v21 = xmlDictComputeFastKey((unsigned __int8 *)name, v6, *(_DWORD *)(v19 + 48));
          unint64_t v20 = 128;
        }
      }
      uint64_t v26 = *(void *)(v19 + 8) + 32 * (v21 % v20);
      if (*(_DWORD *)(v26 + 20))
      {
        while (*(void *)v26)
        {
          uint64_t v27 = v26;
          uint64_t v26 = *(void *)v26;
          if (*(void *)(v27 + 24) == v21 && v6 == *(_DWORD *)(v27 + 16))
          {
            unint64_t v3 = *(xmlChar **)(v27 + 8);
            if (!memcmp(v3, name, v6)) {
              return v3;
            }
          }
          ++v17;
        }
        if (*(void *)(v26 + 24) == v21 && v6 == *(_DWORD *)(v26 + 16))
        {
          unint64_t v3 = *(xmlChar **)(v26 + 8);
          if (!memcmp(v3, name, v6)) {
            return v3;
          }
        }
      }
    }
    uint64_t v28 = (void *)*((void *)dict + 4);
    if (v28)
    {
      size_t v29 = 0;
      unint64_t v30 = 0;
      size_t v31 = v6;
      while (1)
      {
        unint64_t v3 = (xmlChar *)v28[1];
        if (v28[2] - (void)v3 > (unint64_t)v6) {
          break;
        }
        unint64_t v32 = v28[3];
        if (v32 > v30) {
          unint64_t v30 = v28[3];
        }
        v29 += v32;
        uint64_t v28 = (void *)*v28;
        if (!v28)
        {
          if (v7 && v29 > v7) {
            return 0;
          }
          if (!v30) {
            goto LABEL_62;
          }
          unint64_t v33 = 4 * v30;
          goto LABEL_63;
        }
      }
    }
    else
    {
LABEL_62:
      unint64_t v33 = 1000;
LABEL_63:
      if (v33 <= (4 * v6)) {
        unint64_t v34 = (4 * v6);
      }
      else {
        unint64_t v34 = v33;
      }
      int v35 = xmlMalloc(v34 + 48);
      if (!v35) {
        return 0;
      }
      uint64_t v28 = v35;
      v35[3] = v34;
      v35[4] = 0;
      unint64_t v3 = (xmlChar *)(v35 + 5);
      v35[2] = (char *)v35 + v34 + 40;
      *int v35 = *((void *)dict + 4);
      v35[1] = v35 + 5;
      *((void *)dict + 4) = v35;
      size_t v31 = v6;
    }
    memcpy(v3, name, v31);
    int v36 = (unsigned char *)(v28[1] + v31);
    v28[1] = v36 + 1;
    unsigned char *v36 = 0;
    ++v28[4];
    if (!v3) {
      return v3;
    }
    if (v15)
    {
      int v37 = xmlMalloc(0x20uLL);
      if (!v37) {
        return 0;
      }
      *int v37 = 0;
      v37[1] = v3;
      *((_DWORD *)v37 + 4) = v6;
      *((_DWORD *)v37 + 5) = 1;
      v37[3] = v9;
      *(void *)uint64_t v15 = v37;
    }
    else
    {
      uint64_t v38 = *((void *)dict + 1) + 32 * v41;
      *(void *)uint64_t v38 = 0;
      *(void *)(v38 + 8) = v3;
      *(_DWORD *)(v38 + 16) = v6;
      *(_DWORD *)(v38 + 20) = 1;
      *(void *)(v38 + 24) = v9;
    }
    ++*((_DWORD *)dict + 6);
    if (v17 < 4) {
      return v3;
    }
    unint64_t v39 = *((void *)dict + 2);
    if (v39 > 0xAAA || !xmlDictGrow((uint64_t)dict, 6 * v39)) {
      return v3;
    }
    return 0;
  }
  uint64_t v16 = *(void *)v15;
  if (*(void *)v15)
  {
    unint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = v15;
      uint64_t v15 = v16;
      if (*(void *)(v18 + 24) == v9 && v6 == *(_DWORD *)(v18 + 16))
      {
        unint64_t v3 = *(xmlChar **)(v18 + 8);
        if (!memcmp(v3, name, v6)) {
          return v3;
        }
      }
      ++v17;
      uint64_t v16 = *(void *)v15;
      if (!*(void *)v15) {
        goto LABEL_29;
      }
    }
  }
  unint64_t v17 = 0;
LABEL_29:
  if (*(void *)(v15 + 24) != v9) {
    goto LABEL_32;
  }
  if (v6 != *(_DWORD *)(v15 + 16)) {
    goto LABEL_32;
  }
  unint64_t v3 = *(xmlChar **)(v15 + 8);
  if (memcmp(v3, name, v6)) {
    goto LABEL_32;
  }
  return v3;
}

uint64_t xmlDictComputeFastKey(unsigned __int8 *a1, int a2, int a3)
{
  uint64_t result = a3;
  if (a1 && a2 >= 1)
  {
    uint64_t result = 32 * (*a1 + (uint64_t)a3);
    if (a2 < 0xB)
    {
      switch(a2)
      {
        case 2:
          goto LABEL_13;
        case 3:
          goto LABEL_12;
        case 4:
          goto LABEL_11;
        case 5:
          goto LABEL_10;
        case 6:
          goto LABEL_9;
        case 7:
          goto LABEL_8;
        case 8:
          goto LABEL_7;
        case 9:
          goto LABEL_6;
        case 10:
          goto LABEL_5;
        default:
          return result;
      }
    }
    else
    {
      result += a1[a2 - 1];
LABEL_5:
      result += a1[9];
LABEL_6:
      result += a1[8];
LABEL_7:
      result += a1[7];
LABEL_8:
      result += a1[6];
LABEL_9:
      result += a1[5];
LABEL_10:
      result += a1[4];
LABEL_11:
      result += a1[3];
LABEL_12:
      result += a1[2];
LABEL_13:
      result += a1[1];
    }
  }
  return result;
}

void xmlGROW(uint64_t a1)
{
  int v2 = *(xmlParserInput **)(a1 + 56);
  cur = v2->cur;
  uint64_t v4 = v2->end - cur;
  uint64_t v5 = cur - v2->base;
  BOOL v6 = v4 <= 10000000 && v5 <= 10000000;
  if (v6
    || !v2->buf
    || (uint64_t (*)())v2->buf->readcallback == xmlInputReadCallbackNop
    || (*(unsigned char *)(a1 + 566) & 8) != 0)
  {
    xmlParserInputGrow(v2, 250);
    size_t v7 = *(xmlParserInput **)(a1 + 56);
    unint64_t v8 = v7->cur;
    if (v8 <= v7->end && v8 >= v7->base)
    {
      if (v8 && !*v8)
      {
        xmlParserInputGrow(v7, 250);
      }
    }
    else
    {
      xmlHaltParser((xmlParserCtxtPtr)a1);
      xmlFatalErr((_DWORD *)a1, 1, (const xmlChar *)"cur index out of bound");
    }
  }
  else
  {
    xmlFatalErr((_DWORD *)a1, 1, (const xmlChar *)"Huge input lookup");
    xmlHaltParser((xmlParserCtxtPtr)a1);
  }
}

int xmlParserInputGrow(xmlParserInputPtr in, int len)
{
  int result = -1;
  if (in)
  {
    if ((len & 0x80000000) == 0)
    {
      if (in->buf)
      {
        base = in->base;
        if (base)
        {
          cur = in->cur;
          if (cur)
          {
            buffer = in->buf->buffer;
            if (buffer)
            {
              int64_t v8 = cur - base;
              if (xmlBufUse(buffer) <= (cur - base + 250) && in->buf->readcallback)
              {
                int v9 = xmlParserInputBufferGrow(in->buf, len);
                unsigned int v10 = xmlBufContent(in->buf->buffer);
                in->base = v10;
                in->cur = &v10[v8];
                in->end = xmlBufEnd(in->buf->buffer);
                return v9;
              }
              else
              {
                return 0;
              }
            }
            else
            {
              return -1;
            }
          }
        }
      }
    }
  }
  return result;
}

size_t xmlBufUse(const xmlBufPtr buf)
{
  if (!buf || *((_DWORD *)buf + 14)) {
    return 0;
  }
  uint64_t v3 = *((unsigned int *)buf + 3);
  if (v3 <= 0x7FFFFFFE && *((void *)buf + 5) != v3) {
    *((void *)buf + 5) = v3;
  }
  size_t v1 = *((void *)buf + 4);
  size_t v5 = *((unsigned int *)buf + 2);
  if (v5 <= 0x7FFFFFFE && v1 != v5)
  {
    *((void *)buf + 4) = v5;
    return v5;
  }
  return v1;
}

xmlChar *__cdecl xmlBufContent(xmlChar *buf)
{
  if (buf)
  {
    if (*((_DWORD *)buf + 14)) {
      return 0;
    }
    else {
      return *(xmlChar **)buf;
    }
  }
  return buf;
}

int xmlParserInputBufferGrow(xmlParserInputBufferPtr in, int len)
{
  if (!in || in->error) {
    goto LABEL_23;
  }
  if (len != 4 && len < 4001) {
    uint64_t v4 = 4000;
  }
  else {
    uint64_t v4 = len;
  }
  if ((xmlBufGrow((uint64_t)in->buffer, (int)v4 + 1) & 0x80000000) != 0)
  {
    int v13 = "growing input buffer";
    int v14 = 2;
    int v15 = 2;
    uint64_t v16 = 0;
LABEL_22:
    __xmlSimpleError(8, v15, 0, (uint64_t)v16, (uint64_t)v13);
    in->error = v14;
LABEL_23:
    LODWORD(v9) = -1;
    return v9;
  }
  size_t v5 = xmlBufEnd(in->buffer);
  xmlInputReadCallback readcallback = in->readcallback;
  if (!readcallback)
  {
    uint64_t v16 = "no input";
    int v14 = 1547;
    int v15 = 1547;
LABEL_21:
    int v13 = 0;
    goto LABEL_22;
  }
  size_t v7 = v5;
  uint64_t v8 = ((uint64_t (*)(void *, xmlChar *, uint64_t))readcallback)(in->context, v5, v4);
  size_t v9 = v8;
  if ((int)v8 < 1)
  {
    in->xmlInputReadCallback readcallback = (xmlInputReadCallback)endOfInput;
    if ((v8 & 0x80000000) != 0) {
      goto LABEL_23;
    }
  }
  if (!in->encoder)
  {
    xmlBufAddLen((uint64x2_t *)in->buffer, v8);
    return v9;
  }
  raw = in->raw;
  if (!raw)
  {
    raw = (xmlBuf *)xmlBufCreate();
    in->raw = raw;
  }
  if (xmlBufAdd((uint64x2_t *)raw, v7, v9)) {
    goto LABEL_23;
  }
  unsigned int v11 = xmlBufUse(in->raw);
  int v12 = xmlCharEncInput((uint64_t)in, 1);
  if (v12 < 0)
  {
    uint64_t v16 = "encoder error";
    int v14 = 1544;
    int v15 = 1544;
    goto LABEL_21;
  }
  LODWORD(v9) = v12;
  in->rawconsumed = in->rawconsumed - xmlBufUse(in->raw) + v11;
  return v9;
}

xmlChar *__cdecl xmlBufEnd(xmlChar *buf)
{
  if (buf)
  {
    if (*((_DWORD *)buf + 14))
    {
      return 0;
    }
    else
    {
      uint64_t v1 = *((unsigned int *)buf + 3);
      if (v1 <= 0x7FFFFFFE && *((void *)buf + 5) != v1) {
        *((void *)buf + 5) = v1;
      }
      uint64_t v3 = *((void *)buf + 4);
      uint64_t v4 = *((unsigned int *)buf + 2);
      if (v4 <= 0x7FFFFFFE && v3 != v4)
      {
        *((void *)buf + 4) = v4;
        uint64_t v3 = v4;
      }
      return (xmlChar *)(*(void *)buf + v3);
    }
  }
  return buf;
}

uint64_t xmlBufAddLen(uint64x2_t *a1, unint64_t a2)
{
  if (!a1 || a1[3].i32[2]) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = a1[2].i64[1];
  uint64_t v3 = a1->u32[3];
  if (v3 <= 0x7FFFFFFE && v2 != v3)
  {
    a1[2].i64[1] = v3;
    uint64_t v2 = v3;
  }
  uint64_t v5 = a1[2].i64[0];
  uint64_t v6 = a1->u32[2];
  if (v6 <= 0x7FFFFFFE && v5 != v6)
  {
    a1[2].i64[0] = v6;
    uint64_t v5 = v6;
  }
  if (v2 - v5 <= a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = 0;
  uint64_t v9 = v5 + a2;
  a1[2].i64[0] = v9;
  *(unsigned char *)(a1->i64[0] + v9) = 0;
  int8x16_t v10 = (int8x16_t)vdupq_n_s64(0x7FFFFFFFuLL);
  a1->u64[1] = (unint64_t)vmovn_s64((int64x2_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v10, a1[2]), (int8x16_t)a1[2], v10));
  return v8;
}

uint64_t xmlBufGrow(uint64_t a1, unsigned int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (a2)
    {
      LODWORD(result) = xmlBufGrowInternal(a1, a2);
      if (*(_DWORD *)(a1 + 56)) {
        return 0xFFFFFFFFLL;
      }
      else {
        return result;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

unint64_t xmlBufGrowInternal(uint64_t a1, unint64_t a2)
{
  if (*(_DWORD *)(a1 + 56)) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(unsigned int *)(a1 + 12);
  if (v5 <= 0x7FFFFFFE && v4 != v5)
  {
    *(void *)(a1 + 40) = v5;
    uint64_t v4 = v5;
  }
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = *(unsigned int *)(a1 + 8);
  if (v8 <= 0x7FFFFFFE && v7 != v8)
  {
    *(void *)(a1 + 32) = v8;
    uint64_t v7 = v8;
  }
  int v10 = *(_DWORD *)(a1 + 16);
  if (v10 == 2) {
    return 0;
  }
  if (v4 - v7 > a2)
  {
    *(unsigned char *)(*(void *)a1 + v7 + a2) = 0;
    return *(void *)(a1 + 40) + ~*(void *)(a1 + 32);
  }
  if (-2 - v7 < a2)
  {
    int v12 = "growing buffer past SIZE_MAX";
    goto LABEL_44;
  }
  uint64_t v13 = v7 + a2 + 100;
  if (v7 + a2 >= 0xFFFFFFFFFFFFFF9CLL) {
    uint64_t v13 = -1;
  }
  uint64_t v14 = 2 * v4;
  if (v4 < 0) {
    uint64_t v14 = -1;
  }
  if (v4 > a2) {
    size_t v15 = v14;
  }
  else {
    size_t v15 = v13;
  }
  if (v10 != 3)
  {
    if (v10 == 5)
    {
      if ((unint64_t)v4 > 0x98967F || a2 + v7 - 9999999 < 0xFFFFFFFFFF676980)
      {
        xmlBufMemoryError(a1, (uint64_t)"buffer error: text too long\n");
        return 0;
      }
      if (v15 >= 0x989680) {
        size_t v15 = 10000000;
      }
    }
LABEL_36:
    uint64_t v19 = (char *)xmlRealloc(*(void **)a1, v15);
    if (v19) {
      goto LABEL_37;
    }
LABEL_43:
    int v12 = "growing buffer";
LABEL_44:
    __xmlSimpleError(29, 2, 0, 0, (uint64_t)v12);
    unint64_t result = 0;
    if (!*(_DWORD *)(a1 + 56))
    {
      unint64_t result = 0;
      *(_DWORD *)(a1 + 56) = 2;
    }
    return result;
  }
  uint64_t v16 = *(void **)(a1 + 24);
  if (!v16) {
    goto LABEL_36;
  }
  uint64_t v17 = *(void *)a1 - (void)v16;
  uint64_t v18 = (char *)xmlRealloc(v16, v17 + v15);
  if (!v18) {
    goto LABEL_43;
  }
  *(void *)(a1 + 24) = v18;
  uint64_t v19 = &v18[v17];
LABEL_37:
  *(void *)a1 = v19;
  *(void *)(a1 + 40) = v15;
  v19[*(void *)(a1 + 32)] = 0;
  *(unsigned char *)(*(void *)a1 + *(void *)(a1 + 32) + a2) = 0;
  LODWORD(v20) = 0x7FFFFFFF;
  unint64_t v22 = *(void *)(a1 + 32);
  unint64_t v21 = *(void *)(a1 + 40);
  if (v21 >= 0x7FFFFFFF) {
    LODWORD(v23) = 0x7FFFFFFF;
  }
  else {
    uint64_t v23 = *(void *)(a1 + 40);
  }
  if (v22 < 0x7FFFFFFF) {
    uint64_t v20 = *(void *)(a1 + 32);
  }
  *(_DWORD *)(a1 + 8) = v20;
  *(_DWORD *)(a1 + 12) = v23;
  return v21 + ~v22;
}

uint64_t endOfInput()
{
  return 0;
}

uint64_t xmlGetNamespace(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 480) == a2)
  {
    uint64_t v6 = a1 + 496;
    return *(void *)v6;
  }
  else
  {
    int v2 = *(_DWORD *)(a1 + 508);
    while (1)
    {
      BOOL v3 = __OFSUB__(v2, 2);
      v2 -= 2;
      if (v2 < 0 != v3) {
        break;
      }
      uint64_t v4 = *(void *)(a1 + 520);
      if (*(void *)(v4 + 8 * v2) == a2)
      {
        uint64_t v5 = (v2 + 1);
        if (a2 || **(unsigned char **)(v4 + 8 * v5))
        {
          uint64_t v6 = v4 + 8 * v5;
          return *(void *)v6;
        }
        return 0;
      }
    }
    return 0;
  }
}

void xmlSAX2EndElementNs(void *ctx, const xmlChar *localname, const xmlChar *prefix, const xmlChar *URI)
{
  if (ctx)
  {
    *((_DWORD *)ctx + 104) = -1;
    if (*((_DWORD *)ctx + 39))
    {
      if (*((_DWORD *)ctx + 6))
      {
        uint64_t v5 = (xmlDoc *)*((void *)ctx + 2);
        if (v5)
        {
          if (v5->intSubset) {
            *((_DWORD *)ctx + 38) &= xmlValidateOneElement((xmlValidCtxtPtr)((char *)ctx + 160), v5, *((xmlNodePtr *)ctx + 10));
          }
        }
      }
    }
    nodePop((xmlParserCtxtPtr)ctx);
  }
}

xmlNodePtr nodePop(xmlNodePtr ctxt)
{
  if (ctxt)
  {
    int properties = (int)ctxt->properties;
    unsigned int v2 = properties - 1;
    if (properties < 1)
    {
      return 0;
    }
    else
    {
      LODWORD(ctxt->properties) = v2;
      nsDef = ctxt->nsDef;
      if (properties == 1) {
        uint64_t v4 = 0;
      }
      else {
        uint64_t v4 = (xmlChar *)*((void *)&nsDef->next + (properties - 2));
      }
      ctxt->content = v4;
      ctxt = (xmlNodePtr)*((void *)&nsDef->next + v2);
      *((void *)&nsDef->next + v2) = 0;
    }
  }
  return ctxt;
}

uint64_t xmlParseNameAndCompare(uint64_t a1, unsigned __int8 *a2)
{
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40) - *(void *)(*(void *)(a1 + 56) + 32)) <= 249)
  {
    xmlGROW(a1);
  }
  if (*(_DWORD *)(a1 + 272) == -1) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = *(unsigned char **)(v4 + 32);
  unsigned int v6 = *v5;
  uint64_t v7 = a2;
  uint64_t v8 = v5;
  if (*v5)
  {
    uint64_t v8 = *(unsigned char **)(v4 + 32);
    uint64_t v7 = a2;
    while (1)
    {
      int v9 = *v7;
      if (v6 != v9) {
        break;
      }
      unsigned int v10 = *++v8;
      unsigned int v6 = v10;
      ++v7;
      if (!v10) {
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    unsigned int v6 = 0;
    int v9 = *v7;
  }
  if (v9 || v6 > 0x3E || ((1 << v6) & 0x4000000100002600) == 0)
  {
    uint64_t result = (uint64_t)xmlParseName((xmlParserCtxtPtr)a1);
    if ((unsigned __int8 *)result == a2) {
      return 1;
    }
  }
  else
  {
    *(_DWORD *)(v4 + 56) += v8 - v5;
    *(void *)(v4 + 32) = v8;
    return 1;
  }
  return result;
}

int xmlCurrentChar(xmlParserCtxtPtr ctxt, int *len)
{
  unsigned int v2 = 0;
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!ctxt || !len) {
    return v2;
  }
  xmlParserInputPtr input = ctxt->input;
  if (!input || ctxt->instate == XML_PARSER_EOF) {
    return 0;
  }
  cur = input->cur;
  int v7 = *(char *)cur;
  if (v7 >= 32)
  {
    *int len = 1;
    return *cur;
  }
  if (ctxt->charset != 1)
  {
    *int len = 1;
    goto LABEL_19;
  }
  int v8 = *cur;
  if ((v7 & 0x80) != 0)
  {
    if (v8 == 192 || (v7 & 0x40) == 0) {
      goto LABEL_44;
    }
    unint64_t v13 = input->end - cur;
    if (v13 <= 1)
    {
      xmlParserInputGrow(input, 250);
      xmlParserInputPtr input = ctxt->input;
      cur = input->cur;
      unint64_t v13 = input->end - cur;
      if (v13 < 2) {
        goto LABEL_44;
      }
    }
    if ((cur[1] & 0xC0) != 0x80) {
      goto LABEL_44;
    }
    if ((~v8 & 0xE0) != 0)
    {
      *int len = 2;
      unsigned int v2 = cur[1] & 0x3F | ((*cur & 0x1F) << 6);
      if (v2 < 0x80) {
        goto LABEL_44;
      }
    }
    else
    {
      if (v13 <= 2)
      {
        xmlParserInputGrow(input, 250);
        xmlParserInputPtr input = ctxt->input;
        cur = input->cur;
        unint64_t v13 = input->end - cur;
        if (v13 < 3) {
          goto LABEL_44;
        }
      }
      if ((cur[2] & 0xC0) != 0x80) {
        goto LABEL_44;
      }
      if ((~v8 & 0xF0) != 0)
      {
        *int len = 3;
        unsigned int v2 = ((*cur & 0xF) << 12) | ((cur[1] & 0x3F) << 6) | cur[2] & 0x3F;
        if (v2 < 0x800) {
          goto LABEL_44;
        }
      }
      else
      {
        if (v13 <= 3)
        {
          xmlParserInputGrow(input, 250);
          xmlParserInputPtr input = ctxt->input;
          cur = input->cur;
          unint64_t v13 = input->end - cur;
        }
        if ((v8 & 0xF8) != 0xF0) {
          goto LABEL_44;
        }
        if (v13 < 4) {
          goto LABEL_44;
        }
        if ((cur[3] & 0xC0) != 0x80) {
          goto LABEL_44;
        }
        *int len = 4;
        unsigned int v2 = ((*cur & 7) << 18) | ((cur[1] & 0x3F) << 12) | ((cur[2] & 0x3F) << 6) | cur[3] & 0x3F;
        if (v2 < 0x10000) {
          goto LABEL_44;
        }
      }
    }
    if (v2 >> 11 < 0x1B) {
      return v2;
    }
    if ((v2 - 57344) >> 1 < 0xFFF) {
      return v2;
    }
    if (v2 - 0x10000 < 0x100000) {
      return v2;
    }
    xmlErrEncodingInt(ctxt, "Char 0x%X out of allowed range\n", v2);
    if (ctxt->instate != XML_PARSER_EOF) {
      return v2;
    }
    xmlParserInputPtr input = ctxt->input;
LABEL_44:
    if (input->end - input->cur <= 3)
    {
      unsigned int v2 = 0;
      *int len = 0;
      return v2;
    }
    long long v21 = 0u;
    memset(v22, 0, sizeof(v22));
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    *(_OWORD *)__str = 0u;
    snprintf(__str, 0x95uLL, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n", *input->cur, *((unsigned __int8 *)input->cur + 1), *((unsigned __int8 *)input->cur + 2), *((unsigned __int8 *)input->cur + 3));
    __xmlErrEncoding(ctxt, 9, "Input is not proper UTF-8, indicate encoding !\n%s", (const xmlChar *)__str, 0);
    ctxt->charset = 10;
    *int len = 1;
    cur = ctxt->input->cur;
    return *cur;
  }
  *int len = 1;
  if (input->end - cur <= 0)
  {
    xmlParserInputGrow(input, 250);
    xmlParserInputPtr input = ctxt->input;
    cur = input->cur;
  }
  unsigned int v2 = *cur;
  if (*cur) {
    goto LABEL_20;
  }
  if (input->end <= cur) {
    return 0;
  }
  xmlErrEncodingInt(ctxt, "Char 0x0 out of allowed range\n", 0);
  xmlParserInputPtr input = ctxt->input;
  if (ctxt->instate == XML_PARSER_EOF) {
    goto LABEL_44;
  }
  cur = input->cur;
LABEL_19:
  unsigned int v2 = *cur;
LABEL_20:
  if (v2 == 13)
  {
    int v11 = cur[1];
    unsigned int v10 = cur + 1;
    if (v11 == 10) {
      input->cur = v10;
    }
    return 10;
  }
  return v2;
}

uint64_t xmlInputReadCallbackNop()
{
  return 0;
}

uint64_t xmlCtxtGrowAttrs(uint64_t a1, int a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 472);
  if (a2 + 5 <= (int)v2) {
    return v2;
  }
  if (v2) {
    uint64_t v2 = (2 * (a2 + 5));
  }
  else {
    uint64_t v2 = 55;
  }
  uint64_t v4 = xmlMalloc(8 * (int)v2);
  if (!v4)
  {
LABEL_14:
    htmlErrMemory((_DWORD *)a1, 0);
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = v4;
  unsigned int v6 = *(void **)(a1 + 528);
  size_t v7 = 4 * ((int)v2 / 5);
  if (v6) {
    int v8 = xmlRealloc(v6, v7);
  }
  else {
    int v8 = xmlMalloc(v7);
  }
  int v9 = v8;
  if (!v8)
  {
    xmlFree(v5);
    goto LABEL_14;
  }
  uint64_t v10 = *(unsigned int *)(a1 + 472);
  if ((int)v10 >= 1) {
    memcpy(v5, *(const void **)(a1 + 464), 8 * v10);
  }
  xmlFree(*(void **)(a1 + 464));
  *(void *)(a1 + 464) = v5;
  *(void *)(a1 + 528) = v9;
  *(_DWORD *)(a1 + 472) = v2;
  return v2;
}

int xmlParseCharRef(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur != 38 || cur[1] != 35)
  {
    xmlFatalErr(ctxt, 8, 0);
    int v7 = 0;
    goto LABEL_40;
  }
  uint64_t v4 = cur + 2;
  if (cur[2] == 120)
  {
    input->cur = cur + 3;
    input->col += 3;
    if (!cur[3])
    {
      xmlParserInputGrow(input, 250);
      xmlParserInputPtr input = ctxt->input;
    }
    if (!ctxt->progressive && input->end - input->cur <= 249)
    {
      xmlGROW((uint64_t)ctxt);
      xmlParserInputPtr input = ctxt->input;
    }
    uint64_t v5 = input->cur;
    if (*v5 != 59)
    {
      int v6 = 0;
      int v7 = 0;
      while (1)
      {
        if (v6 < 21)
        {
          int v8 = v6 + 1;
        }
        else
        {
          if (!ctxt->progressive && input->end - v5 <= 249) {
            xmlGROW((uint64_t)ctxt);
          }
          if (ctxt->instate == XML_PARSER_EOF) {
            return 0;
          }
          int v8 = 0;
          xmlParserInputPtr input = ctxt->input;
        }
        unsigned int v9 = *input->cur;
        if (v9 - 48 >= 0xA)
        {
          if (v9 < 0x61)
          {
            if (v9 < 0x41 || (v9 <= 0x46 ? (BOOL v12 = v8 <= 19) : (BOOL v12 = 0), !v12))
            {
LABEL_76:
              xmlParserCtxtPtr v20 = ctxt;
              int v21 = 6;
LABEL_77:
              xmlFatalErr(v20, v21, 0);
              int v7 = 0;
              xmlParserInputPtr input = ctxt->input;
              uint64_t v5 = input->cur;
              if (*v5 == 59) {
                goto LABEL_51;
              }
LABEL_40:
              uint64_t v14 = "xmlParseCharRef: invalid xmlChar value %d\n";
LABEL_41:
              xmlFatalErrMsgInt(ctxt, 9, v14, v7);
              return 0;
            }
            int v10 = -55;
          }
          else
          {
            if (v9 > 0x66 || v8 >= 20) {
              goto LABEL_76;
            }
            int v10 = -87;
          }
        }
        else
        {
          int v10 = -48;
        }
        int v13 = v10 + 16 * v7 + v9;
        if (v13 >= 1114112) {
          int v7 = 1114112;
        }
        else {
          int v7 = v13;
        }
        xmlNextChar(ctxt);
        int v6 = v8 + 1;
        xmlParserInputPtr input = ctxt->input;
        uint64_t v5 = input->cur;
        if (*v5 == 59) {
          goto LABEL_51;
        }
      }
    }
LABEL_50:
    int v7 = 0;
    goto LABEL_51;
  }
  input->cur = v4;
  input->col += 2;
  if (!*v4)
  {
    xmlParserInputGrow(input, 250);
    xmlParserInputPtr input = ctxt->input;
  }
  if (!ctxt->progressive && input->end - input->cur <= 249)
  {
    xmlGROW((uint64_t)ctxt);
    xmlParserInputPtr input = ctxt->input;
  }
  uint64_t v5 = input->cur;
  if (*v5 == 59) {
    goto LABEL_50;
  }
  int v16 = 0;
  int v7 = 0;
  do
  {
    if (v16 < 21)
    {
      int v17 = v16 + 1;
    }
    else
    {
      if (!ctxt->progressive && input->end - v5 <= 249) {
        xmlGROW((uint64_t)ctxt);
      }
      if (ctxt->instate == XML_PARSER_EOF) {
        return 0;
      }
      int v17 = 0;
      xmlParserInputPtr input = ctxt->input;
    }
    int v18 = *input->cur;
    if ((v18 - 48) > 9)
    {
      xmlParserCtxtPtr v20 = ctxt;
      int v21 = 7;
      goto LABEL_77;
    }
    int v19 = v18 + 10 * v7 - 48;
    if (v19 >= 1114112) {
      int v7 = 1114112;
    }
    else {
      int v7 = v19;
    }
    xmlNextChar(ctxt);
    int v16 = v17 + 1;
    xmlParserInputPtr input = ctxt->input;
    uint64_t v5 = input->cur;
  }
  while (*v5 != 59);
LABEL_51:
  ++input->col;
  input->cur = v5 + 1;
  if (v7 >= 1114112)
  {
    uint64_t v14 = "xmlParseCharRef: character reference out of bounds\n";
    goto LABEL_41;
  }
  if (v7 > 255)
  {
    if ((v7 - 0x10000) >= 0xFFFFD800 && (v7 - 57344) >> 1 >= 0xFFF) {
      goto LABEL_40;
    }
  }
  else if (v7 <= 31 && (v7 > 0xD || ((1 << v7) & 0x2600) == 0))
  {
    goto LABEL_40;
  }
  return v7;
}

uint64_t __xmlSimpleError(int a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a2 != 2) {
    return __xmlRaiseError(0, 0, 0, 0, a3, a1, a2, 2, 0, 0, a5, 0, 0, 0, (unsigned __int128)0 >> 96, a4);
  }
  if (a5)
  {
    int v8 = "Memory allocation failed : %s\n";
    long long v7 = 0uLL;
    *(_OWORD *)int v6 = (unint64_t)a5;
  }
  else
  {
    int v8 = "Memory allocation failed\n";
    *(_OWORD *)int v6 = 0u;
    long long v7 = 0u;
  }
  return __xmlRaiseError(0, 0, 0, 0, a3, a1, 2, 3, 0, 0, v6[0], (xmlChar *)v6[1], (xmlChar *)v7, SDWORD2(v7), SHIDWORD(v7), (uint64_t)v8);
}

_DWORD *xmlFatalErr(_DWORD *result, int a2, const xmlChar *a3)
{
  BOOL v3 = result;
  if (result && result[83] && result[68] == -1) {
    return result;
  }
  if ((a2 - 1) <= 0x6D)
  {
    uint64_t v4 = off_1E60CE098[a2 - 1];
    if (!result) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  uint64_t v4 = "Unregistered error message";
  if (result) {
LABEL_8:
  }
    result[34] = a2;
LABEL_9:
  if (a3) {
    uint64_t result = __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 3, 0, 0, a3, 0, 0, 0, (unsigned __int128)0 >> 96, "%s: %s\n", (char)v4);
  }
  else {
    uint64_t result = __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 3, 0, 0, 0, 0, 0, 0, 0, "%s\n", (char)v4);
  }
  if (v3)
  {
    v3[6] = 0;
    if (!v3[112]) {
      v3[83] = 1;
    }
  }
  return result;
}

xmlURIPtr xmlParseURI(const char *str)
{
  if (!str) {
    return 0;
  }
  xmlURIPtr URI = xmlCreateURI();
  BOOL v3 = URI;
  if (URI && xmlParse3986URIReference((uint64_t)URI, (unsigned __int8 *)str))
  {
    xmlFreeURI(v3);
    return 0;
  }
  return v3;
}

uint64_t xmlParse3986URIReference(uint64_t a1, unsigned __int8 *a2)
{
  if (a2)
  {
    xmlCleanURI(a1);
    int v36 = a2;
    if ((*a2 & 0xDFu) - 65 > 0x19) {
      goto LABEL_68;
    }
    for (uint64_t i = 0; ; ++i)
    {
      unsigned int v5 = a2[i + 1];
      if (v5 - 48 >= 0xA && (v5 & 0xFFFFFFDF) - 65 >= 0x1A && (v5 > 0x2E || ((1 << v5) & 0x680000000000) == 0)) {
        break;
      }
    }
    if (a1)
    {
      if (*(void *)a1) {
        xmlFree(*(void **)a1);
      }
      *(void *)a1 = xmlStrndup(a2, (int)i + 1);
      unsigned int v5 = a2[i + 1];
    }
    if (v5 != 58) {
      goto LABEL_68;
    }
    int v10 = &a2[i + 2];
    int v9 = *v10;
    int v37 = v10;
    if (v9 == 47)
    {
      if (a2[i + 3] == 47)
      {
        int v37 = &a2[i + 4];
        if (xmlParse3986Authority(a1, (const xmlChar **)&v37)) {
          goto LABEL_68;
        }
        if (!*(void *)(a1 + 24)) {
          *(_DWORD *)(a1 + 40) = -1;
        }
        if (xmlParse3986PathAbEmpty(a1, (const xmlChar **)&v37)) {
          goto LABEL_68;
        }
      }
      else if (xmlParse3986PathAbsolute(a1, &v37))
      {
        goto LABEL_68;
      }
      int v10 = v37;
      goto LABEL_60;
    }
    if ((v9 - 48) >= 0xA && (v9 & 0xFFFFFFDF) - 65 >= 0x1A)
    {
      uint64_t v11 = (v9 - 33);
      if (v11 > 0x3E) {
        goto LABEL_52;
      }
      if (((1 << (v9 - 33)) & 0x4000000096003FE9) != 0) {
        goto LABEL_31;
      }
      if (v11 == 4)
      {
        if ((a2[i + 3] - 48) >= 0xAu
          && ((unsigned int v17 = a2[i + 3] - 65, v17 > 0x25) || ((1 << v17) & 0x3F0000003FLL) == 0)
          || (a2[i + 4] - 48) >= 0xAu
          && ((unsigned int v18 = a2[i + 4] - 65, v18 > 0x25) || ((1 << v18) & 0x3F0000003FLL) == 0))
        {
LABEL_53:
          if (a1)
          {
            int v19 = *(void **)(a1 + 48);
            if (v19) {
              xmlFree(v19);
            }
            *(void *)(a1 + 48) = 0;
          }
LABEL_60:
          int v36 = v10;
          int v20 = *v10;
          if (v20 == 63)
          {
            int v36 = v10 + 1;
            if (xmlParse3986Query(a1, (const xmlChar **)&v36)) {
              goto LABEL_68;
            }
            int v10 = v36;
            int v20 = *v36;
          }
          if (v20 == 35)
          {
            int v36 = v10 + 1;
            if (xmlParse3986Fragment(a1, (const xmlChar **)&v36)) {
              goto LABEL_68;
            }
            int v20 = *v36;
          }
          if (!v20) {
            return 0;
          }
          xmlCleanURI(a1);
LABEL_68:
          xmlCleanURI(a1);
          int v37 = a2;
          int v21 = *a2;
          if (v21 == 47)
          {
            if (a2[1] == 47)
            {
              int v37 = a2 + 2;
              uint64_t v8 = xmlParse3986Authority(a1, (const xmlChar **)&v37);
              if (v8)
              {
LABEL_119:
                xmlCleanURI(a1);
                return v8;
              }
              if (!xmlParse3986PathAbEmpty(a1, (const xmlChar **)&v37))
              {
LABEL_109:
                unint64_t v33 = v37;
                int v34 = *v37;
                if (v34 == 63)
                {
                  ++v37;
                  if (xmlParse3986Query(a1, (const xmlChar **)&v37))
                  {
LABEL_114:
                    uint64_t v8 = 0xFFFFFFFFLL;
                    goto LABEL_119;
                  }
                  unint64_t v33 = v37;
                  int v34 = *v37;
                }
                if (v34 == 35)
                {
                  int v37 = v33 + 1;
                  if (xmlParse3986Fragment(a1, (const xmlChar **)&v37)) {
                    goto LABEL_114;
                  }
                  int v34 = *v37;
                }
                if (v34)
                {
                  xmlCleanURI(a1);
                  goto LABEL_118;
                }
                return 0;
              }
            }
            else if (!xmlParse3986PathAbsolute(a1, &v37))
            {
              goto LABEL_109;
            }
LABEL_118:
            uint64_t v8 = 1;
            goto LABEL_119;
          }
          if ((v21 - 48) < 0xA || (v21 & 0xFFFFFFDF) - 65 < 0x1A)
          {
LABEL_80:
            uint64_t v38 = a2;
            unsigned __int8 v24 = 58;
            for (int j = 0; !xmlParse3986Segment(&v38, v24, j); int j = 1)
            {
              uint64_t v26 = v38;
              if (*v38 != 47)
              {
                if (a1)
                {
                  uint64_t v27 = *(void **)(a1 + 48);
                  if (v27) {
                    xmlFree(v27);
                  }
                  if (v26 == a2)
                  {
                    size_t v29 = 0;
                  }
                  else
                  {
                    int v28 = v26 - a2;
                    if ((*(unsigned char *)(a1 + 72) & 2) != 0) {
                      size_t v29 = xmlStrndup(a2, v28);
                    }
                    else {
                      size_t v29 = xmlURIUnescapeString((const char *)a2, v28, 0);
                    }
                  }
                  *(void *)(a1 + 48) = v29;
                }
                int v37 = v26;
                goto LABEL_109;
              }
              ++v38;
              unsigned __int8 v24 = 0;
            }
            goto LABEL_118;
          }
          uint64_t v23 = (v21 - 33);
          if (v23 > 0x3E) {
            goto LABEL_101;
          }
          if (((1 << (v21 - 33)) & 0x4000000096003FE9) != 0) {
            goto LABEL_80;
          }
          if (v23 == 4)
          {
            if ((a2[1] - 48) < 0xAu
              || (unsigned int v30 = a2[1] - 65, v30 <= 0x25) && ((1 << v30) & 0x3F0000003FLL) != 0)
            {
              if ((a2[2] - 48) < 0xAu) {
                goto LABEL_80;
              }
              unsigned int v31 = a2[2] - 65;
              if (v31 <= 0x25 && ((1 << v31) & 0x3F0000003FLL) != 0) {
                goto LABEL_80;
              }
            }
          }
          else
          {
LABEL_101:
            if (v21 == 126) {
              goto LABEL_80;
            }
          }
          if (a1)
          {
            unint64_t v32 = *(void **)(a1 + 48);
            if (v32) {
              xmlFree(v32);
            }
            *(void *)(a1 + 48) = 0;
          }
          goto LABEL_109;
        }
      }
      else
      {
LABEL_52:
        if (v9 != 126) {
          goto LABEL_53;
        }
      }
    }
LABEL_31:
    uint64_t v38 = &a2[i + 2];
    for (int k = 0; !xmlParse3986Segment(&v38, 0, k); int k = 1)
    {
      int v13 = v38;
      if (*v38 != 47)
      {
        if (a1)
        {
          uint64_t v14 = *(void **)(a1 + 48);
          if (v14) {
            xmlFree(v14);
          }
          if (v10 == v13)
          {
            int v16 = 0;
          }
          else
          {
            int v15 = v13 + -2 - a2 - i;
            if ((*(unsigned char *)(a1 + 72) & 2) != 0) {
              int v16 = xmlStrndup(&a2[i + 2], v15);
            }
            else {
              int v16 = xmlURIUnescapeString((const char *)&a2[i + 2], v15, 0);
            }
          }
          *(void *)(a1 + 48) = v16;
        }
        int v10 = v13;
        goto LABEL_60;
      }
      ++v38;
    }
    goto LABEL_68;
  }
  return 0xFFFFFFFFLL;
}

void xmlFreeURI(xmlURIPtr uri)
{
  if (uri)
  {
    scheme = uri->scheme;
    if (scheme) {
      xmlFree(scheme);
    }
    server = uri->server;
    if (server) {
      xmlFree(server);
    }
    user = uri->user;
    if (user) {
      xmlFree(user);
    }
    path = uri->path;
    if (path) {
      xmlFree(path);
    }
    fragment = uri->fragment;
    if (fragment) {
      xmlFree(fragment);
    }
    opaque = uri->opaque;
    if (opaque) {
      xmlFree(opaque);
    }
    authority = uri->authority;
    if (authority) {
      xmlFree(authority);
    }
    query = uri->query;
    if (query) {
      xmlFree(query);
    }
    query_raw = uri->query_raw;
    if (query_raw) {
      xmlFree(query_raw);
    }
    xmlFreeFunc v11 = xmlFree;
    ((void (*)(xmlURIPtr))v11)(uri);
  }
}

xmlURIPtr xmlCreateURI(void)
{
  v0 = (xmlURI *)xmlMalloc(0x58uLL);
  uint64_t v1 = v0;
  if (v0)
  {
    v0->query_raw = 0;
    *(_OWORD *)&v0->path = 0u;
    *(_OWORD *)&v0->fragment = 0u;
    *(_OWORD *)&v0->authority = 0u;
    *(_OWORD *)&v0->user = 0u;
    *(_OWORD *)&v0->scheme = 0u;
  }
  else
  {
    xmlURIErrMemory((const xmlChar *)"creating URI structure\n");
  }
  return v1;
}

void xmlCleanURI(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void **)a1;
    if (v2) {
      xmlFree(v2);
    }
    *(void *)a1 = 0;
    BOOL v3 = *(void **)(a1 + 24);
    if (v3) {
      xmlFree(v3);
    }
    *(void *)(a1 + 24) = 0;
    uint64_t v4 = *(void **)(a1 + 32);
    if (v4) {
      xmlFree(v4);
    }
    *(void *)(a1 + 32) = 0;
    unsigned int v5 = *(void **)(a1 + 48);
    if (v5) {
      xmlFree(v5);
    }
    *(void *)(a1 + 48) = 0;
    int v6 = *(void **)(a1 + 64);
    if (v6) {
      xmlFree(v6);
    }
    *(void *)(a1 + 64) = 0;
    long long v7 = *(void **)(a1 + 8);
    if (v7) {
      xmlFree(v7);
    }
    *(void *)(a1 + 8) = 0;
    uint64_t v8 = *(void **)(a1 + 16);
    if (v8) {
      xmlFree(v8);
    }
    *(void *)(a1 + 16) = 0;
    int v9 = *(void **)(a1 + 56);
    if (v9) {
      xmlFree(v9);
    }
    *(void *)(a1 + 56) = 0;
    int v10 = *(void **)(a1 + 80);
    if (v10) {
      xmlFree(v10);
    }
    *(void *)(a1 + 80) = 0;
  }
}

uint64_t nsPush(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned char *)(a1 + 565) & 0x20) != 0)
  {
    int v6 = *(_DWORD *)(a1 + 508);
    while (1)
    {
      BOOL v7 = __OFSUB__(v6, 2);
      v6 -= 2;
      if (v6 < 0 != v7) {
        break;
      }
      uint64_t v8 = *(void *)(a1 + 520);
      if (*(void *)(v8 + 8 * v6) == a2)
      {
        if (*(void *)(v8 + 8 * (v6 + 1)) != a3) {
          break;
        }
        return 4294967294;
      }
    }
  }
  uint64_t v9 = *(int *)(a1 + 512);
  if (v9 && (int v10 = *(void **)(a1 + 520)) != 0)
  {
    if (*(_DWORD *)(a1 + 508) < (int)v9)
    {
LABEL_12:
      uint64_t v11 = *(int *)(a1 + 508);
      v10[v11] = a2;
      uint64_t v12 = *(void *)(a1 + 520);
      uint64_t result = (v11 + 2);
      *(_DWORD *)(a1 + 508) = result;
      *(void *)(v12 + 8 * ((int)v11 + 1)) = a3;
      return result;
    }
    *(_DWORD *)(a1 + 512) = 2 * v9;
    int v10 = xmlRealloc(v10, 16 * v9);
    if (v10)
    {
      *(void *)(a1 + 520) = v10;
      goto LABEL_12;
    }
    htmlErrMemory((_DWORD *)a1, 0);
    *(int *)(a1 + 512) /= 2;
  }
  else
  {
    *(void *)(a1 + 508) = 0xA00000000;
    int v10 = xmlMalloc(0x50uLL);
    *(void *)(a1 + 520) = v10;
    if (v10) {
      goto LABEL_12;
    }
    htmlErrMemory((_DWORD *)a1, 0);
    *(_DWORD *)(a1 + 512) = 0;
  }
  return 0xFFFFFFFFLL;
}

void xmlFreeNode(xmlNodePtr cur)
{
  if (!cur) {
    return;
  }
  xmlElementType type = cur->type;
  if (type != XML_ATTRIBUTE_NODE)
  {
    if (type == XML_NAMESPACE_DECL)
    {
      name = (xmlChar *)cur->name;
      if (name) {
        xmlFree(name);
      }
      children = cur->children;
      if (children) {
        xmlFree(children);
      }
      xmlFreeFunc v5 = xmlFree;
      goto LABEL_71;
    }
    if (type == XML_DTD_NODE)
    {
      xmlFreeDtd((xmlDtdPtr)cur);
      return;
    }
    if (__xmlRegisterCallbacks && *__xmlDeregisterNodeDefaultValue())
    {
      int v6 = __xmlDeregisterNodeDefaultValue();
      ((void (*)(xmlNodePtr))*v6)(cur);
    }
    doc = cur->doc;
    if (doc) {
      dict = doc->dict;
    }
    else {
      dict = 0;
    }
    xmlElementType v9 = cur->type;
    if (v9 != XML_ENTITY_DECL)
    {
LABEL_35:
      uint64_t v12 = cur->children;
      if (v12)
      {
        if (v9 == XML_ENTITY_REF_NODE)
        {
LABEL_44:
          content = cur->content;
          if (v9 - 19 >= 2 && v9 != XML_ENTITY_REF_NODE && content != 0 && content != (xmlChar *)&cur->properties)
          {
            if (dict)
            {
              if (xmlDictOwns(dict, content)) {
                goto LABEL_58;
              }
              content = cur->content;
            }
            xmlFree(content);
          }
LABEL_58:
          int v19 = (xmlChar *)cur->name;
          if (v19)
          {
            xmlElementType v20 = cur->type;
            if (v20 == XML_TEXT_NODE || v20 == XML_COMMENT_NODE) {
              goto LABEL_66;
            }
            if (!dict) {
              goto LABEL_64;
            }
            if (!xmlDictOwns(dict, v19))
            {
              int v19 = (xmlChar *)cur->name;
LABEL_64:
              xmlFree(v19);
            }
          }
          xmlElementType v20 = cur->type;
LABEL_66:
          if (v20 <= XML_XINCLUDE_END && ((1 << v20) & 0x180002) != 0)
          {
            nsDef = cur->nsDef;
            if (nsDef) {
              xmlFreeNsList(nsDef);
            }
          }
          xmlFreeFunc v5 = xmlFree;
LABEL_71:
          ((void (*)(xmlNodePtr))v5)(cur);
          return;
        }
        xmlFreeNodeList(v12);
        xmlElementType v9 = cur->type;
      }
      if (v9 <= XML_XINCLUDE_END && ((1 << v9) & 0x180002) != 0)
      {
        int properties = cur->properties;
        if (properties)
        {
          do
          {
            next = properties->next;
            xmlFreeProp(properties);
            int properties = next;
          }
          while (next);
          xmlElementType v9 = cur->type;
        }
      }
      if (v9 == XML_ELEMENT_NODE) {
        goto LABEL_58;
      }
      goto LABEL_44;
    }
    psvuint64_t i = (xmlChar *)cur->psvi;
    if (psvi)
    {
      if (dict)
      {
        if (xmlDictOwns(dict, psvi)) {
          goto LABEL_29;
        }
        psvuint64_t i = (xmlChar *)cur->psvi;
      }
      xmlFree(psvi);
    }
LABEL_29:
    uint64_t v11 = cur->nsDef;
    if (v11)
    {
      if (!dict)
      {
LABEL_33:
        xmlFree(v11);
        goto LABEL_34;
      }
      if (!xmlDictOwns(dict, (const xmlChar *)v11))
      {
        uint64_t v11 = cur->nsDef;
        goto LABEL_33;
      }
    }
LABEL_34:
    xmlElementType v9 = cur->type;
    goto LABEL_35;
  }

  xmlFreeProp((xmlAttrPtr)cur);
}

void xmlFreeDoc(xmlDocPtr cur)
{
  if (!cur) {
    return;
  }
  dict = cur->dict;
  if (__xmlRegisterCallbacks && *__xmlDeregisterNodeDefaultValue())
  {
    BOOL v3 = __xmlDeregisterNodeDefaultValue();
    ((void (*)(xmlDocPtr))*v3)(cur);
  }
  ids = (xmlIDTable *)cur->ids;
  if (ids) {
    xmlFreeIDTable(ids);
  }
  cur->ids = 0;
  refs = (xmlRefTable *)cur->refs;
  if (refs) {
    xmlFreeRefTable(refs);
  }
  cur->refs = 0;
  intSubset = cur->intSubset;
  extSubset = cur->extSubset;
  if (extSubset && intSubset != extSubset)
  {
    xmlUnlinkNode((xmlNodePtr)cur->extSubset);
    cur->extSubset = 0;
    xmlFreeDtd(extSubset);
  }
  if (intSubset)
  {
    xmlUnlinkNode((xmlNodePtr)cur->intSubset);
    cur->intSubset = 0;
    xmlFreeDtd(intSubset);
  }
  children = cur->children;
  if (children) {
    xmlFreeNodeList(children);
  }
  oldNs = cur->oldNs;
  if (oldNs) {
    xmlFreeNsList(oldNs);
  }
  version = (xmlChar *)cur->version;
  if (version)
  {
    if (dict)
    {
      if (xmlDictOwns(dict, version)) {
        goto LABEL_23;
      }
      version = (xmlChar *)cur->version;
    }
    xmlFree(version);
  }
LABEL_23:
  name = cur->name;
  if (!name) {
    goto LABEL_28;
  }
  if (dict)
  {
    if (xmlDictOwns(dict, (const xmlChar *)name)) {
      goto LABEL_28;
    }
    name = cur->name;
  }
  xmlFree(name);
LABEL_28:
  encoding = (xmlChar *)cur->encoding;
  if (!encoding) {
    goto LABEL_33;
  }
  if (dict)
  {
    if (xmlDictOwns(dict, encoding)) {
      goto LABEL_33;
    }
    encoding = (xmlChar *)cur->encoding;
  }
  xmlFree(encoding);
LABEL_33:
  URL = (xmlChar *)cur->URL;
  if (!URL) {
    goto LABEL_39;
  }
  if (!dict)
  {
LABEL_38:
    xmlFree(URL);
LABEL_39:
    xmlFree(cur);
    if (!dict) {
      return;
    }
    goto LABEL_40;
  }
  if (!xmlDictOwns(dict, URL))
  {
    URL = (xmlChar *)cur->URL;
    goto LABEL_38;
  }
  xmlFree(cur);
LABEL_40:

  xmlDictFree(dict);
}

void xmlFreeProp(xmlAttrPtr cur)
{
  if (!cur) {
    return;
  }
  doc = cur->doc;
  if (doc) {
    dict = doc->dict;
  }
  else {
    dict = 0;
  }
  if (__xmlRegisterCallbacks && *__xmlDeregisterNodeDefaultValue())
  {
    uint64_t v4 = __xmlDeregisterNodeDefaultValue();
    ((void (*)(xmlAttrPtr))*v4)(cur);
  }
  xmlFreeFunc v5 = cur->doc;
  if (v5 && cur->atype == XML_ATTRIBUTE_ID) {
    xmlRemoveID(v5, cur);
  }
  children = cur->children;
  if (children) {
    xmlFreeNodeList(children);
  }
  name = (xmlChar *)cur->name;
  if (name)
  {
    if (!dict)
    {
LABEL_18:
      xmlFree(name);
      goto LABEL_19;
    }
    if (!xmlDictOwns(dict, name))
    {
      name = (xmlChar *)cur->name;
      goto LABEL_18;
    }
  }
LABEL_19:
  xmlFreeFunc v8 = xmlFree;

  ((void (*)(xmlAttrPtr))v8)(cur);
}

void xmlFreeNodeList(xmlNodePtr cur)
{
  if (!cur) {
    return;
  }
  xmlNodePtr next = cur;
  if (cur->type != XML_NAMESPACE_DECL)
  {
    doc = cur->doc;
    if (doc) {
      dict = doc->dict;
    }
    else {
      dict = 0;
    }
    uint64_t v3 = 0;
    uint64_t v4 = &unk_1E9D47000;
    while (1)
    {
      children = next->children;
      if (children)
      {
        while (1)
        {
          xmlNodePtr v6 = children;
          unsigned int type = next->type;
          BOOL v8 = type > 0x15;
          int v9 = (1 << type) & 0x206220;
          if (!v8 && v9 != 0) {
            break;
          }
          ++v3;
          children = v6->children;
          xmlNodePtr next = v6;
          if (!children) {
            goto LABEL_19;
          }
        }
      }
      xmlNodePtr v6 = next;
LABEL_19:
      parent = v6->parent;
      xmlNodePtr next = v6->next;
      unsigned int v12 = v6->type;
      if ((int)v12 > 13)
      {
        if (v12 == 14) {
          goto LABEL_56;
        }
        if (v12 != 21) {
          goto LABEL_28;
        }
      }
      else if (v12 != 9 && v12 != 13)
      {
LABEL_28:
        if (v4[414])
        {
          if (*__xmlDeregisterNodeDefaultValue())
          {
            uint64_t v14 = __xmlDeregisterNodeDefaultValue();
            ((void (*)(xmlNodePtr))*v14)(v6);
          }
          unsigned int v12 = v6->type;
        }
        if (v12 <= 0x14 && ((1 << v12) & 0x180002) != 0)
        {
          int properties = v6->properties;
          if (properties)
          {
            int v16 = v4;
            do
            {
              unsigned int v17 = properties->next;
              xmlFreeProp(properties);
              int properties = v17;
            }
            while (v17);
            unsigned int v12 = v6->type;
            uint64_t v4 = v16;
          }
        }
        if (v12 <= 0x14 && ((1 << v12) & 0x180022) != 0)
        {
LABEL_42:
          BOOL v8 = v12 > 0x14;
          int v19 = (1 << v12) & 0x180002;
          if (!v8 && v19 != 0)
          {
            nsDef = v6->nsDef;
            if (nsDef) {
              xmlFreeNsList(nsDef);
            }
          }
          name = (xmlChar *)v6->name;
          if (name)
          {
            xmlElementType v23 = v6->type;
            if (v23 != XML_TEXT_NODE && v23 != XML_COMMENT_NODE)
            {
              if (!dict) {
                goto LABEL_54;
              }
              if (!xmlDictOwns(dict, name))
              {
                name = (xmlChar *)v6->name;
LABEL_54:
                xmlFree(name);
              }
            }
          }
          xmlFree(v6);
          goto LABEL_56;
        }
        content = (_xmlAttr **)v6->content;
        if (content != &v6->properties && content != 0)
        {
          if (!dict) {
            goto LABEL_67;
          }
          if (!xmlDictOwns(dict, (const xmlChar *)content))
          {
            content = (_xmlAttr **)v6->content;
LABEL_67:
            xmlFree(content);
          }
        }
        unsigned int v12 = v6->type;
        goto LABEL_42;
      }
      xmlFreeDoc((xmlDocPtr)v6);
LABEL_56:
      if (!next)
      {
        if (!v3 || !parent) {
          return;
        }
        --v3;
        parent->children = 0;
        xmlNodePtr next = parent;
      }
    }
  }

  xmlFreeNsList((xmlNsPtr)cur);
}

int xmlDictOwns(xmlDictPtr dict, const xmlChar *str)
{
  if (str)
  {
    while (dict)
    {
      uint64_t v2 = (void *)*((void *)dict + 4);
      if (v2)
      {
        while (v2 + 5 > (void *)str || v2[1] < (unint64_t)str)
        {
          uint64_t v2 = (void *)*v2;
          if (!v2) {
            goto LABEL_7;
          }
        }
        LODWORD(dict) = 1;
        return (int)dict;
      }
LABEL_7:
      dict = (xmlDictPtr)*((void *)dict + 5);
      if (!dict) {
        return (int)dict;
      }
    }
  }
  LODWORD(dict) = -1;
  return (int)dict;
}

xmlNodePtr xmlDocGetRootElement(xmlNodePtr doc)
{
  if (doc)
  {
    for (doc = doc->children; doc; doc = doc->next)
    {
      if (doc->type == XML_ELEMENT_NODE) {
        break;
      }
    }
  }
  return doc;
}

xmlChar *xmlGetPropNodeValueInternal(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (v1 == 16)
  {
    uint64_t v3 = *(const xmlChar **)(a1 + 88);
    goto LABEL_11;
  }
  if (v1 != 2) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2)
  {
LABEL_10:
    uint64_t v3 = (const xmlChar *)"";
    goto LABEL_11;
  }
  if (*(void *)(v2 + 48) || (*(_DWORD *)(v2 + 8) - 3) > 1)
  {
    uint64_t result = xmlNodeListGetStringInternal(*(xmlDoc **)(a1 + 64), v2, 1, 0);
    if (result) {
      return result;
    }
    goto LABEL_10;
  }
  uint64_t v3 = *(const xmlChar **)(v2 + 80);
LABEL_11:

  return xmlStrdup(v3);
}

int xmlCopyError(xmlErrorPtr from, xmlErrorPtr to)
{
  int result = -1;
  if (from && to)
  {
    xmlFreeFunc v5 = (char *)xmlStrdup((const xmlChar *)from->message);
    xmlNodePtr v6 = (char *)xmlStrdup((const xmlChar *)from->file);
    BOOL v7 = (char *)xmlStrdup((const xmlChar *)from->str1);
    BOOL v8 = (char *)xmlStrdup((const xmlChar *)from->str2);
    int v9 = (char *)xmlStrdup((const xmlChar *)from->str3);
    message = to->message;
    if (message) {
      xmlFree(message);
    }
    file = to->file;
    if (file) {
      xmlFree(file);
    }
    str1 = to->str1;
    if (str1) {
      xmlFree(str1);
    }
    str2 = to->str2;
    if (str2) {
      xmlFree(str2);
    }
    str3 = to->str3;
    if (str3) {
      xmlFree(str3);
    }
    int result = 0;
    *(void *)&to->domain = *(void *)&from->domain;
    to->level = from->level;
    to->line = from->line;
    to->node = from->node;
    *(void *)&to->int1 = *(void *)&from->int1;
    *(_OWORD *)&to->ctxt = *(_OWORD *)&from->ctxt;
    to->message = v5;
    to->file = v6;
    to->str1 = v7;
    to->str2 = v8;
    to->str3 = v9;
  }
  return result;
}

xmlNodePtr xmlStringLenGetNodeList(const xmlDoc *doc, const xmlChar *value, int len)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (!value) {
    return 0;
  }
  uint64_t v4 = value;
  Size = (uint64x2_t *)xmlBufCreateSize(0);
  if (!Size) {
    return 0;
  }
  BOOL v7 = Size;
  xmlBufSetAllocationScheme((uint64_t)Size, 4u);
  if (len >= 1)
  {
    Sibling = 0;
    int v9 = 0;
    uint64_t v10 = len;
    unint64_t v11 = (unint64_t)&v4[len];
    uint64_t v12 = (uint64_t)&v4[v10 - 2];
    int v13 = v4;
    while (1)
    {
      if (*v13 != 38)
      {
        if (!*v13) {
          goto LABEL_88;
        }
        ++v13;
        goto LABEL_87;
      }
      if (v13 != v4 && xmlBufAdd(v7, v4, (v13 - v4))) {
        goto LABEL_103;
      }
      uint64_t v14 = (unsigned __int8 *)(v13 + 2);
      if ((unint64_t)(v13 + 2) < v11 && v13[1] == 35 && *v14 == 120)
      {
        int v15 = (unsigned __int8 *)(v13 + 3);
        if ((unint64_t)(v13 + 3) >= v11)
        {
          int v16 = 0;
LABEL_46:
          int v17 = 0;
          int v28 = (unsigned __int8 *)(v13 + 4);
          while (1)
          {
            if ((v16 - 48) < 0xA)
            {
              int v29 = -48;
            }
            else if ((v16 - 97) < 6)
            {
              int v29 = -87;
            }
            else
            {
              if ((v16 - 65) >= 6)
              {
                __xmlSimpleError(2, 1300, (int)doc, (uint64_t)"invalid hexadecimal character value\n", 0);
                uint64_t v30 = 0;
                int v17 = 0;
                int v15 = v28 - 1;
                goto LABEL_66;
              }
              int v29 = -55;
            }
            int v17 = v29 + 16 * v17 + v16;
            if (v17 >= 1114112) {
              int v17 = 1114112;
            }
            if ((unint64_t)v28 >= v11) {
              int v16 = 0;
            }
            else {
              int v16 = *v28;
            }
            ++v28;
            if (v16 == 59)
            {
              int v15 = v28 - 1;
              goto LABEL_60;
            }
          }
        }
        int v16 = *v15;
        if (v16 != 59) {
          goto LABEL_46;
        }
        int v17 = 0;
LABEL_60:
        uint64_t v30 = 1;
LABEL_66:
        int v13 = &v15[v30];
        if (v17)
        {
LABEL_67:
          __int16 v45 = 0;
          *(void *)out = 0;
          if (v17 < 1114112) {
            int v34 = v17;
          }
          else {
            int v34 = 65533;
          }
          out[xmlCopyCharMultiByte(out, v34)] = 0;
          uint64_t v4 = v13;
          if (xmlBufCat(v7, out)) {
            goto LABEL_103;
          }
          goto LABEL_87;
        }
        goto LABEL_86;
      }
      unsigned int v18 = v13 + 1;
      if ((unint64_t)(v13 + 1) >= v11) {
        goto LABEL_94;
      }
      int v19 = *v18;
      if (v19 == 35) {
        break;
      }
      uint64_t v21 = 0;
      if (!*v18)
      {
LABEL_94:
        __xmlSimpleError(2, 1302, (int)doc, (uint64_t)"unterminated entity reference %15s\n", (uint64_t)v18);
        goto LABEL_103;
      }
      while (v19 != 59)
      {
        if (v12 - (void)v13 != v21)
        {
          int v19 = v13[v21++ + 2];
          if (v19) {
            continue;
          }
        }
        goto LABEL_94;
      }
      if (v21)
      {
        uint64_t v42 = v12;
        cur = Sibling;
        unsigned __int8 v24 = xmlStrndup(v13 + 1, v21);
        xmlEntityPtr DocEntity = xmlGetDocEntity(doc, v24);
        xmlEntityPtr v26 = DocEntity;
        if (DocEntity && DocEntity->etype == XML_INTERNAL_PREDEFINED_ENTITY)
        {
          uint64_t v27 = v24;
          uint64_t v12 = v42;
          Sibling = cur;
          if (xmlBufCat(v7, DocEntity->content)) {
            goto LABEL_103;
          }
        }
        else
        {
          if (!xmlBufIsEmpty((uint64_t)v7))
          {
            unsigned int v31 = v24;
            xmlNodePtr v32 = xmlNewText(0);
            if (!v32)
            {
              if (!v24) {
                goto LABEL_103;
              }
              goto LABEL_108;
            }
            unint64_t v33 = v32;
            v32->doc = (_xmlDoc *)doc;
            v32->content = (xmlChar *)xmlBufDetach(v7->i64);
            if (cur)
            {
              cur = xmlAddNextSibling(cur, v33);
            }
            else
            {
              int v9 = v33;
              cur = v33;
            }
            unsigned __int8 v24 = v31;
          }
          uint64_t v27 = v24;
          xmlNodePtr v35 = xmlNewReference(doc, v24);
          if (!v35)
          {
            if (!v24) {
              goto LABEL_103;
            }
LABEL_108:
            ((void (*)(xmlChar *))xmlFree)(v24);
            goto LABEL_103;
          }
          Sibling = v35;
          if (v26)
          {
            if (!v26->children)
            {
              v26->children = (_xmlNode *)-1;
              xmlNodePtr NodeList = xmlStringGetNodeList(doc, v35->content);
              v26->children = NodeList;
              v26->owner = 1;
              if (NodeList)
              {
                do
                {
                  xmlNodePtr v37 = NodeList;
                  NodeList->parent = (_xmlNode *)v26;
                  xmlNodePtr NodeList = NodeList->next;
                }
                while (NodeList);
                v26->last = v37;
              }
            }
          }
          if (cur) {
            Sibling = xmlAddNextSibling(cur, Sibling);
          }
          else {
            int v9 = Sibling;
          }
          uint64_t v12 = v42;
        }
        xmlFree(v27);
      }
      v13 += v21 + 2;
LABEL_86:
      uint64_t v4 = v13;
LABEL_87:
      if ((unint64_t)v13 >= v11)
      {
LABEL_88:
        if (v13 == v4 || !xmlBufAdd(v7, v4, (v13 - v4)))
        {
          if (!xmlBufIsEmpty((uint64_t)v7)) {
            goto LABEL_99;
          }
          if (!v9)
          {
LABEL_96:
            xmlNodePtr v38 = xmlNewText((const xmlChar *)"");
            int v9 = v38;
            if (v38) {
              v38->doc = (_xmlDoc *)doc;
            }
          }
        }
        goto LABEL_103;
      }
    }
    if ((unint64_t)v14 >= v11)
    {
      int v20 = 0;
    }
    else
    {
      int v20 = *v14;
      if (v20 == 59)
      {
        int v17 = 0;
LABEL_36:
        uint64_t v23 = 1;
        goto LABEL_38;
      }
    }
    int v17 = 0;
    unint64_t v22 = (unsigned __int8 *)(v13 + 3);
    while ((v20 - 48) <= 9)
    {
      int v17 = v20 + 10 * v17 - 48;
      if (v17 >= 1114112) {
        int v17 = 1114112;
      }
      if ((unint64_t)v22 >= v11) {
        int v20 = 0;
      }
      else {
        int v20 = *v22;
      }
      ++v22;
      if (v20 == 59)
      {
        uint64_t v14 = v22 - 1;
        goto LABEL_36;
      }
    }
    __xmlSimpleError(2, 1301, (int)doc, (uint64_t)"invalid decimal character value\n", 0);
    uint64_t v23 = 0;
    int v17 = 0;
    uint64_t v14 = v22 - 1;
LABEL_38:
    int v13 = &v14[v23];
    if (v17) {
      goto LABEL_67;
    }
    goto LABEL_86;
  }
  if (xmlBufIsEmpty((uint64_t)v7)) {
    goto LABEL_96;
  }
  int v9 = 0;
  Sibling = 0;
LABEL_99:
  xmlNodePtr v39 = xmlNewText(0);
  if (v39)
  {
    uint64_t v40 = v39;
    v39->doc = (_xmlDoc *)doc;
    v39->content = (xmlChar *)xmlBufDetach(v7->i64);
    if (Sibling) {
      xmlAddNextSibling(Sibling, v40);
    }
    else {
      int v9 = v40;
    }
  }
LABEL_103:
  xmlBufFree((uint64_t)v7);
  return v9;
}

xmlNodePtr xmlStringGetNodeList(const xmlDoc *doc, const xmlChar *value)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (!value) {
    return 0;
  }
  uint64_t v2 = value;
  Size = (uint64x2_t *)xmlBufCreateSize(0);
  if (!Size) {
    return 0;
  }
  xmlFreeFunc v5 = Size;
  xmlBufSetAllocationScheme((uint64_t)Size, 4u);
  xmlNodePtr v6 = 0;
  Sibling = 0;
LABEL_4:
  for (uint64_t i = v2; *i; ++i)
  {
    if (*i == 38)
    {
      if (i != v2 && xmlBufAdd(v5, v2, (i - v2))) {
        goto LABEL_73;
      }
      int v9 = i[1];
      if (v9 != 35)
      {
        uint64_t v22 = 2;
        if (!i[1])
        {
LABEL_80:
          __xmlSimpleError(2, 1302, (int)doc, (uint64_t)"unterminated entity reference %15s\n", (uint64_t)(i + 1));
          goto LABEL_73;
        }
        while (v9 != 59)
        {
          int v9 = i[v22++];
          if (!v9) {
            goto LABEL_80;
          }
        }
        if (v22 == 2) {
          goto LABEL_67;
        }
        name = xmlStrndup(i + 1, (int)v22 - 2);
        xmlEntityPtr DocEntity = xmlGetDocEntity(doc, name);
        if (DocEntity && DocEntity->etype == XML_INTERNAL_PREDEFINED_ENTITY)
        {
          if (xmlBufCat(v5, DocEntity->content)) {
            goto LABEL_73;
          }
LABEL_66:
          xmlFree(name);
LABEL_67:
          uint64_t v2 = &i[v22];
          goto LABEL_4;
        }
        xmlEntityPtr v34 = DocEntity;
        if (xmlBufIsEmpty((uint64_t)v5))
        {
LABEL_57:
          xmlNodePtr v25 = xmlNewReference(doc, name);
          if (v25)
          {
            xmlEntityPtr v26 = v25;
            if (v34)
            {
              if (!v34->children)
              {
                v34->children = (_xmlNode *)-1;
                xmlNodePtr elema = v25;
                xmlNodePtr NodeList = xmlStringGetNodeList(doc, v25->content);
                xmlEntityPtr v26 = elema;
                v34->children = NodeList;
                v34->owner = 1;
                if (NodeList)
                {
                  do
                  {
                    xmlNodePtr v28 = NodeList;
                    NodeList->parent = (_xmlNode *)v34;
                    xmlNodePtr NodeList = NodeList->next;
                  }
                  while (NodeList);
                  v34->last = v28;
                }
              }
            }
            if (Sibling)
            {
              Sibling = xmlAddNextSibling(Sibling, v26);
            }
            else
            {
              xmlNodePtr v6 = v26;
              Sibling = v26;
            }
            goto LABEL_66;
          }
        }
        else
        {
          xmlNodePtr v24 = xmlNewText(0);
          if (v24)
          {
            v24->doc = (_xmlDoc *)doc;
            elem = v24;
            v24->content = (xmlChar *)xmlBufDetach(v5->i64);
            if (Sibling)
            {
              Sibling = xmlAddNextSibling(Sibling, elem);
            }
            else
            {
              xmlNodePtr v6 = elem;
              Sibling = elem;
            }
            goto LABEL_57;
          }
        }
        if (name) {
          xmlFree(name);
        }
        goto LABEL_73;
      }
      unint64_t v11 = i + 2;
      int v10 = i[2];
      if (v10 == 59)
      {
        int v15 = 0;
LABEL_21:
        uint64_t v17 = 1;
      }
      else
      {
        if (v10 == 120)
        {
          int v14 = i[3];
          int v13 = i + 3;
          int v12 = v14;
          if (v14 != 59)
          {
            int v15 = 0;
            while (1)
            {
              if ((v12 - 48) >= 0xA)
              {
                if ((v12 - 97) >= 6)
                {
                  if ((v12 - 65) >= 6)
                  {
                    __xmlSimpleError(2, 1300, (int)doc, (uint64_t)"invalid hexadecimal character value\n", 0);
                    uint64_t v20 = 0;
                    int v15 = 0;
                    goto LABEL_36;
                  }
                  int v18 = -55;
                }
                else
                {
                  int v18 = -87;
                }
              }
              else
              {
                int v18 = -48;
              }
              int v15 = v18 + 16 * v15 + v12;
              if (v15 >= 1114112) {
                int v15 = 1114112;
              }
              int v19 = *++v13;
              int v12 = v19;
              if (v19 == 59) {
                goto LABEL_35;
              }
            }
          }
          int v15 = 0;
LABEL_35:
          uint64_t v20 = 1;
LABEL_36:
          uint64_t v2 = &v13[v20];
          if (v15) {
            goto LABEL_37;
          }
          goto LABEL_4;
        }
        int v15 = 0;
        while ((v10 - 48) <= 9)
        {
          int v15 = v10 + 10 * v15 - 48;
          if (v15 >= 1114112) {
            int v15 = 1114112;
          }
          int v16 = *++v11;
          int v10 = v16;
          if (v16 == 59) {
            goto LABEL_21;
          }
        }
        __xmlSimpleError(2, 1301, (int)doc, (uint64_t)"invalid decimal character value\n", 0);
        uint64_t v17 = 0;
        int v15 = 0;
      }
      uint64_t v2 = &v11[v17];
      if (!v15) {
        goto LABEL_4;
      }
LABEL_37:
      __int16 v37 = 0;
      *(void *)out = 0;
      if (v15 < 1114112) {
        int v21 = v15;
      }
      else {
        int v21 = 65533;
      }
      out[xmlCopyCharMultiByte(out, v21)] = 0;
      if (xmlBufCat(v5, out)) {
        goto LABEL_73;
      }
      goto LABEL_4;
    }
  }
  if (i != v2 || !v6) {
    xmlBufAdd(v5, v2, (i - v2));
  }
  if (!xmlBufIsEmpty((uint64_t)v5))
  {
    xmlNodePtr v30 = xmlNewText(0);
    if (v30)
    {
      unsigned int v31 = v30;
      v30->doc = (_xmlDoc *)doc;
      v30->content = (xmlChar *)xmlBufDetach(v5->i64);
      if (Sibling) {
        xmlAddNextSibling(Sibling, v31);
      }
      else {
        xmlNodePtr v6 = v31;
      }
    }
    else
    {
      xmlNodePtr v6 = 0;
    }
  }
LABEL_73:
  xmlBufFree((uint64_t)v5);
  return v6;
}

xmlChar *__cdecl xmlNodeGetContent(const xmlNode *cur)
{
  if (!cur) {
    return 0;
  }
  switch(cur->type)
  {
    case XML_ELEMENT_NODE:
    case XML_DOCUMENT_FRAG_NODE:
      Size = (xmlBuf *)xmlBufCreateSize(64);
      if (!Size) {
        return 0;
      }
      goto LABEL_12;
    case XML_ATTRIBUTE_NODE:
      return xmlGetPropNodeValueInternal((uint64_t)cur);
    case XML_TEXT_NODE:
    case XML_CDATA_SECTION_NODE:
    case XML_PI_NODE:
    case XML_COMMENT_NODE:
      content = cur->content;
      if (!content) {
        return 0;
      }
      goto LABEL_15;
    case XML_ENTITY_REF_NODE:
      if (!xmlGetDocEntity(cur->doc, cur->name)) {
        return 0;
      }
      goto LABEL_11;
    case XML_DOCUMENT_NODE:
    case XML_HTML_DOCUMENT_NODE:
    case XML_DOCB_DOCUMENT_NODE:
LABEL_11:
      Size = (xmlBuf *)xmlBufCreate();
      if (!Size) {
        return 0;
      }
LABEL_12:
      xmlFreeFunc v5 = (uint64_t *)Size;
      xmlBufGetNodeContent(Size, cur);
      xmlNodePtr v6 = (xmlChar *)xmlBufDetach(v5);
      xmlBufFree((uint64_t)v5);
      int result = v6;
      break;
    case XML_NAMESPACE_DECL:
      content = cur->name;
LABEL_15:
      return xmlStrdup(content);
    default:
      return 0;
  }
  return result;
}

uint64_t xmlBufDetach(uint64_t *a1)
{
  if (!a1 || *((_DWORD *)a1 + 4) == 2 || a1[6] || *((_DWORD *)a1 + 14)) {
    return 0;
  }
  uint64_t v1 = *a1;
  *a1 = 0;
  a1[1] = 0;
  a1[4] = 0;
  a1[5] = 0;
  return v1;
}

int xmlBufGetNodeContent(xmlBufPtr buf, const xmlNode *cur)
{
  int result = -1;
  if (buf && cur)
  {
    int result = 0;
    switch(cur->type)
    {
      case XML_ELEMENT_NODE:
      case XML_DOCUMENT_FRAG_NODE:
        children = cur;
        while (1)
        {
          do
          {
            int v12 = children;
            xmlElementType type = children->type;
            if (type - 3 >= 2)
            {
              if (type == XML_ENTITY_REF_NODE) {
                xmlBufGetNodeContent(buf, v12);
              }
            }
            else
            {
              content = v12->content;
              if (content) {
                xmlBufCat((uint64x2_t *)buf, content);
              }
            }
            children = v12->children;
          }
          while (children && children->type != XML_ENTITY_DECL);
          if (v12 == cur) {
            goto LABEL_29;
          }
          while (1)
          {
            children = v12->next;
            if (children) {
              break;
            }
            int v12 = v12->parent;
            if (v12) {
              BOOL v15 = v12 == cur;
            }
            else {
              BOOL v15 = 1;
            }
            if (v15) {
              goto LABEL_29;
            }
          }
        }
      case XML_ATTRIBUTE_NODE:
        int v16 = cur->children;
        if (!v16) {
          goto LABEL_29;
        }
        do
        {
          if (v16->type == XML_TEXT_NODE) {
            xmlBufCat((uint64x2_t *)buf, v16->content);
          }
          else {
            xmlBufGetNodeContent(buf, v16);
          }
          int result = 0;
          int v16 = v16->next;
        }
        while (v16);
        return result;
      case XML_TEXT_NODE:
      case XML_CDATA_SECTION_NODE:
      case XML_PI_NODE:
      case XML_COMMENT_NODE:
        p_content = (const xmlChar **)&cur->content;
        goto LABEL_5;
      case XML_ENTITY_REF_NODE:
        xmlEntityPtr DocEntity = xmlGetDocEntity(cur->doc, cur->name);
        if (DocEntity)
        {
          int v18 = DocEntity->children;
          if (v18)
          {
            do
            {
              xmlBufGetNodeContent(buf, v18);
              int result = 0;
              int v18 = v18->next;
            }
            while (v18);
          }
          else
          {
LABEL_29:
            int result = 0;
          }
        }
        else
        {
          int result = -1;
        }
        break;
      case XML_DOCUMENT_NODE:
      case XML_HTML_DOCUMENT_NODE:
      case XML_DOCB_DOCUMENT_NODE:
        for (uint64_t i = cur->children; i; uint64_t i = i->next)
        {
          unsigned int v7 = i->type;
          BOOL v8 = v7 > 4;
          int v9 = (1 << v7) & 0x1A;
          if (!v8 && v9 != 0) {
            xmlBufGetNodeContent(buf, i);
          }
        }
        goto LABEL_29;
      case XML_NAMESPACE_DECL:
        p_content = &cur->name;
LABEL_5:
        xmlBufCat((uint64x2_t *)buf, *p_content);
        goto LABEL_29;
      default:
        return result;
    }
  }
  return result;
}

uint64_t xmlBufCat(uint64x2_t *a1, const xmlChar *a2)
{
  if (!a1 || a1[3].i32[2]) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = a1->u32[3];
  if (v3 <= 0x7FFFFFFE && a1[2].i64[1] != v3) {
    a1[2].i64[1] = v3;
  }
  uint64_t v5 = a1->u32[2];
  if (v5 <= 0x7FFFFFFE && a1[2].i64[0] != v5) {
    a1[2].i64[0] = v5;
  }
  if (!a2 || a1[1].i32[0] == 2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return xmlBufAdd(a1, a2, 0xFFFFFFFFuLL);
  }
}

xmlNodePtr xmlNewText(const xmlChar *content)
{
  uint64_t v2 = (xmlNode *)xmlMalloc(0x78uLL);
  uint64_t v3 = v2;
  if (v2)
  {
    *(_OWORD *)&v2->_private = 0u;
    *(_OWORD *)&v2->name = 0u;
    *(void *)&v2->line = 0;
    *(_OWORD *)&v2->content = 0u;
    *(_OWORD *)&v2->nsDef = 0u;
    *(_OWORD *)&v2->xmlNodePtr next = 0u;
    *(_OWORD *)&v2->doc = 0u;
    *(_OWORD *)&v2->last = 0u;
    v2->xmlElementType type = XML_TEXT_NODE;
    v2->name = "text";
    if (content) {
      v2->content = xmlStrdup(content);
    }
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      uint64_t v4 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v4)(v3);
    }
  }
  else
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building text");
  }
  return v3;
}

uint64_t xmlBufIsEmpty(uint64_t a1)
{
  if (!a1 || *(_DWORD *)(a1 + 56)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *(unsigned int *)(a1 + 12);
  if (v2 <= 0x7FFFFFFE && *(void *)(a1 + 40) != v2) {
    *(void *)(a1 + 40) = v2;
  }
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  if (v5 <= 0x7FFFFFFE && v4 != v5)
  {
    *(void *)(a1 + 32) = v5;
    uint64_t v4 = v5;
  }
  return v4 == 0;
}

void htmlParseContentInternal(uint64_t a1)
{
  uint64_t v2 = xmlStrdup(*(const xmlChar **)(a1 + 288));
  int v3 = *(_DWORD *)(a1 + 296);
  while (1)
  {
    if (!*(_DWORD *)(a1 + 452))
    {
      uint64_t v4 = *(xmlParserInput **)(a1 + 56);
      if (v4->end - v4->cur <= 249) {
        xmlParserInputGrow(v4, 250);
      }
    }
    if (*(_DWORD *)(a1 + 272) == -1) {
      break;
    }
    uint64_t v5 = *(unsigned char **)(*(void *)(a1 + 56) + 32);
    if (*v5 != 60) {
      goto LABEL_15;
    }
    int v6 = v5[1];
    if (v6 == 47)
    {
      if (htmlParseEndTag((xmlParserCtxt *)a1))
      {
        if (v2) {
          goto LABEL_32;
        }
        if (!*(_DWORD *)(a1 + 296))
        {
LABEL_33:
          uint64_t v2 = xmlStrdup(*(const xmlChar **)(a1 + 288));
          int v3 = *(_DWORD *)(a1 + 296);
        }
      }
    }
    else
    {
      if ((v6 & 0xFFFFFFDF) - 65 >= 0x1A && v6 != 95 && v6 != 58) {
        goto LABEL_15;
      }
      unsigned int v7 = htmlParseHTMLName_nonInvasive(a1);
      if (!v7)
      {
        htmlParseErr((_DWORD *)a1, 68, "htmlParseStartTag: invalid element name\n", 0, 0);
        while (!**(unsigned char **)(*(void *)(a1 + 56) + 32))
          xmlNextChar((xmlParserCtxtPtr)a1);
LABEL_31:
        htmlParserFinishElementParsing((xmlParserCtxtPtr)a1);
        if (!v2) {
          goto LABEL_33;
        }
LABEL_32:
        xmlFree(v2);
        goto LABEL_33;
      }
      if (*(void *)(a1 + 288)
        && (uint64_t v8 = (uint64_t)v7,
            *(void *)&long long v33 = *(void *)(a1 + 288),
            *((void *)&v33 + 1) = v7,
            bsearch(&v33, htmlStartClose, 0xFBuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))htmlCompareStartClose)))
      {
        htmlAutoClose((int *)a1, v8);
      }
      else
      {
LABEL_15:
        int v9 = *(_DWORD *)(a1 + 296);
        BOOL v10 = v9 < 1 || v3 < v9;
        if (!v10 && !xmlStrEqual(v2, *(const xmlChar **)(a1 + 288))) {
          goto LABEL_31;
        }
        if (**(unsigned char **)(*(void *)(a1 + 56) + 32))
        {
          if (xmlStrEqual(v2, (const xmlChar *)"script") || xmlStrEqual(v2, (const xmlChar *)"style"))
          {
            htmlParseScript(a1);
            goto LABEL_93;
          }
          unint64_t v11 = *(unsigned char **)(*(void *)(a1 + 56) + 32);
          if (*v11 == 60
            && v11[1] == 33
            && __toupper(v11[2]) == 68
            && __toupper(v11[3]) == 79
            && __toupper(v11[4]) == 67
            && __toupper(v11[5]) == 84
            && __toupper(v11[6]) == 89
            && __toupper(v11[7]) == 80
            && __toupper(v11[8]) == 69)
          {
            htmlParseErr((_DWORD *)a1, 800, "Misplaced DOCTYPE declaration\n", (const xmlChar *)"DOCTYPE", 0);
            htmlParseDocTypeDecl((xmlParserCtxt *)a1);
          }
        }
        uint64_t v12 = *(void *)(a1 + 56);
        int v13 = *(unsigned __int8 **)(v12 + 32);
        int v14 = *v13;
        if (v14 == 38)
        {
          htmlParseReference(a1);
        }
        else if (v14 == 60)
        {
          int v15 = v13[1];
          if (v15 == 63)
          {
            htmlParsePI(a1);
          }
          else
          {
            if (v15 != 33 || v13[2] != 45 || v13[3] != 45)
            {
              uint64_t v35 = 0;
              long long v33 = 0u;
              long long v34 = 0u;
              if (*(_DWORD *)(a1 + 272) == -1) {
                goto LABEL_90;
              }
              if (*(_DWORD *)(a1 + 104))
              {
                int v16 = &v13[*(void *)(v12 + 64) - *(void *)(v12 + 24)];
                uint64_t v17 = *(int *)(v12 + 52);
                *((void *)&v33 + 1) = v16;
                *(void *)&long long v34 = v17;
              }
              if (htmlParseStartTag(a1) == -1 || (int v18 = *(const xmlChar **)(a1 + 288)) == 0)
              {
                if (**(unsigned char **)(*(void *)(a1 + 56) + 32) != 62) {
                  goto LABEL_90;
                }
                xmlNextChar((xmlParserCtxtPtr)a1);
                if (v2) {
                  goto LABEL_91;
                }
              }
              else
              {
                int v19 = bsearch(*(const void **)(a1 + 288), &html40ElementTable, 0x5CuLL, 0x40uLL, (int (__cdecl *)(const void *, const void *))htmlCompareTags);
                if (!v19) {
                  htmlParseErr((_DWORD *)a1, 801, "Tag %s invalid\n", v18, 0);
                }
                uint64_t v20 = *(void *)(a1 + 56);
                int v21 = *(unsigned __int8 **)(v20 + 32);
                int v22 = *v21;
                if (v22 == 62)
                {
                  xmlNextChar((xmlParserCtxtPtr)a1);
                  if (v19 && v19[11])
                  {
LABEL_76:
                    if (*(void *)a1)
                    {
                      xmlEntityPtr v26 = *(void (**)(void, const xmlChar *))(*(void *)a1 + 120);
                      if (v26) {
                        v26(*(void *)(a1 + 8), v18);
                      }
                    }
                    int v27 = *(_DWORD *)(a1 + 296);
                    unsigned int v28 = v27 - 1;
                    if (v27 < 1) {
                      goto LABEL_90;
                    }
                    *(_DWORD *)(a1 + 296) = v28;
                    uint64_t v29 = *(void *)(a1 + 304);
                    if (v27 == 1) {
                      uint64_t v32 = 0;
                    }
                    else {
                      uint64_t v32 = *(void *)(v29 + 8 * (v27 - 2));
                    }
                    *(void *)(a1 + 288) = v32;
                    *(void *)(v29 + 8 * v28) = 0;
                    if (v2) {
LABEL_91:
                    }
                      xmlFree(v2);
                  }
                  else
                  {
                    if (!*(_DWORD *)(a1 + 104)) {
                      goto LABEL_90;
                    }
                    htmlNodeInfoPush(a1, &v33);
                    if (v2) {
                      goto LABEL_91;
                    }
                  }
                }
                else
                {
                  if (v22 == 47 && v21[1] == 62)
                  {
                    *(void *)(v20 + 32) = v21 + 2;
                    *(_DWORD *)(v20 + 56) += 2;
                    goto LABEL_76;
                  }
                  htmlParseErr((_DWORD *)a1, 73, "Couldn't find end of Start Tag %s\n", v18, 0);
                  if (xmlStrEqual(v18, *(const xmlChar **)(a1 + 288)))
                  {
                    nodePop((xmlParserCtxtPtr)a1);
                    int v23 = *(_DWORD *)(a1 + 296);
                    unsigned int v24 = v23 - 1;
                    if (v23 >= 1)
                    {
                      *(_DWORD *)(a1 + 296) = v24;
                      uint64_t v25 = *(void *)(a1 + 304);
                      if (v23 == 1) {
                        uint64_t v30 = 0;
                      }
                      else {
                        uint64_t v30 = *(void *)(v25 + 8 * (v23 - 2));
                      }
                      *(void *)(a1 + 288) = v30;
                      *(void *)(v25 + 8 * v24) = 0;
                    }
                  }
                  if (*(_DWORD *)(a1 + 104)) {
                    htmlNodeInfoPush(a1, &v33);
                  }
                  htmlParserFinishElementParsing((xmlParserCtxtPtr)a1);
LABEL_90:
                  if (v2) {
                    goto LABEL_91;
                  }
                }
              }
              uint64_t v2 = xmlStrdup(*(const xmlChar **)(a1 + 288));
              int v3 = *(_DWORD *)(a1 + 296);
              goto LABEL_93;
            }
            htmlParseComment(a1);
          }
        }
        else
        {
          if (!*v13)
          {
            htmlAutoCloseOnEnd(a1);
            break;
          }
          htmlParseCharData(a1);
        }
LABEL_93:
        if (!*(_DWORD *)(a1 + 452))
        {
          unsigned int v31 = *(xmlParserInput **)(a1 + 56);
          if (v31->end - v31->cur <= 249) {
            xmlParserInputGrow(v31, 250);
          }
        }
      }
    }
  }
  if (v2) {
    xmlFree(v2);
  }
}

xmlNodePtr xmlNewChild(xmlNodePtr parent, xmlNsPtr ns, const xmlChar *name, const xmlChar *content)
{
  xmlNodePtr result = 0;
  if (parent && name)
  {
    xmlNodePtr result = 0;
    HIDWORD(v6) = parent->type - 1;
    LODWORD(v6) = HIDWORD(v6);
    switch((v6 >> 1))
    {
      case 0u:
        doc = parent->doc;
        if (!ns) {
          ns = parent->ns;
        }
        goto LABEL_8;
      case 4u:
      case 6u:
        doc = (xmlDoc *)parent;
        goto LABEL_8;
      case 5u:
        doc = parent->doc;
LABEL_8:
        xmlNodePtr result = xmlNewDocNode(doc, ns, name, content);
        if (result)
        {
          result->xmlElementType type = XML_ELEMENT_NODE;
          result->parent = parent;
          result->doc = parent->doc;
          if (parent->children)
          {
            last = parent->last;
            p_last = &parent->last;
            last->xmlNodePtr next = result;
            result->prev = last;
          }
          else
          {
            parent->children = result;
            p_last = &parent->last;
          }
          *p_last = result;
        }
        break;
      default:
        return result;
    }
  }
  return result;
}

xmlNodePtr xmlNewDocNode(xmlDocPtr doc, xmlNsPtr ns, const xmlChar *name, const xmlChar *content)
{
  if (doc && (dict = doc->dict) != 0)
  {
    uint64_t v8 = (xmlChar *)xmlDictLookup(dict, name, -1);
    xmlNodePtr v9 = xmlNewNodeEatName(ns, v8);
  }
  else
  {
    xmlNodePtr v9 = xmlNewNode(ns, name);
  }
  BOOL v10 = v9;
  if (v9)
  {
    v9->doc = doc;
    if (content)
    {
      xmlNodePtr NodeList = xmlStringGetNodeList(doc, content);
      v10->children = NodeList;
      if (NodeList)
      {
        xmlNodePtr next = NodeList->next;
        if (next)
        {
          do
          {
            xmlNodePtr v13 = next;
            NodeList->parent = v10;
            xmlNodePtr next = next->next;
            xmlNodePtr NodeList = v13;
          }
          while (next);
        }
        else
        {
          xmlNodePtr v13 = NodeList;
        }
        v13->parent = v10;
      }
      else
      {
        xmlNodePtr v13 = 0;
      }
      v10->last = v13;
    }
  }
  return v10;
}

xmlNodePtr xmlNewNode(xmlNsPtr ns, const xmlChar *name)
{
  if (!name) {
    return 0;
  }
  uint64_t v4 = (xmlNode *)xmlMalloc(0x78uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    *(void *)&v4->line = 0;
    *(_OWORD *)&v4->content = 0u;
    *(_OWORD *)&v4->nsDef = 0u;
    *(_OWORD *)&v4->xmlNodePtr next = 0u;
    *(_OWORD *)&v4->doc = 0u;
    *(_OWORD *)&v4->name = 0u;
    *(_OWORD *)&v4->last = 0u;
    *(_OWORD *)&v4->_private = 0u;
    v4->xmlElementType type = XML_ELEMENT_NODE;
    v4->name = xmlStrdup(name);
    v5->ns = ns;
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      unint64_t v6 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v6)(v5);
    }
  }
  else
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building node");
  }
  return v5;
}

xmlDocPtr xmlNewDoc(const xmlChar *version)
{
  uint64_t v2 = (xmlDoc *)xmlMalloc(0xB0uLL);
  int v3 = v2;
  if (v2)
  {
    *(_OWORD *)&v2->charset = 0u;
    *(_OWORD *)&v2->psvuint64_t i = 0u;
    if (version) {
      uint64_t v4 = version;
    }
    else {
      uint64_t v4 = (const xmlChar *)"1.0";
    }
    *(_OWORD *)&v3->encoding = 0uLL;
    *(_OWORD *)&v3->refs = 0uLL;
    *(_OWORD *)&v3->intSubset = 0uLL;
    *(_OWORD *)&v3->oldNs = 0uLL;
    *(_OWORD *)&v3->xmlNodePtr next = 0uLL;
    *(_OWORD *)&v3->doc = 0uLL;
    *(_OWORD *)&v3->name = 0uLL;
    *(_OWORD *)&v3->last = 0uLL;
    *(_OWORD *)&v3->_private = 0uLL;
    v3->xmlElementType type = XML_DOCUMENT_NODE;
    uint64_t v5 = xmlStrdup(v4);
    v3->version = v5;
    if (v5)
    {
      *(void *)&v3->compression = -1;
      v3->doc = v3;
      *(void *)&v3->parseFlags = 0x2000000000;
      v3->charset = 1;
      if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
      {
        unint64_t v6 = __xmlRegisterNodeDefaultValue();
        ((void (*)(xmlDoc *))*v6)(v3);
      }
    }
    else
    {
      __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building doc");
      xmlFree(v3);
      return 0;
    }
  }
  else
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building doc");
  }
  return v3;
}

void xmlSAX2StartElementNs(void *ctx, const xmlChar *localname, const xmlChar *prefix, const xmlChar *URI, int nb_namespaces, const xmlChar **namespaces, int nb_attributes, int nb_defaulted, const xmlChar **attributes)
{
  if (!ctx) {
    return;
  }
  int v16 = (xmlNode *)*((void *)ctx + 10);
  if (*((_DWORD *)ctx + 39))
  {
    uint64_t v17 = *((void *)ctx + 2);
    if (!*(void *)(v17 + 88))
    {
      int v22 = *(void **)(v17 + 80);
      if (!v22 || !v22[9] && !v22[10] && !v22[11] && !v22[12])
      {
        xmlErrValid(ctx, 522, "Validation failed: no DTD found !", 0, 0);
        *((_DWORD *)ctx + 39) = 0;
      }
    }
  }
  if (startElementNSNeedsUndeclaredPrefixQuirk_hasEvaluatedQuirk != -1) {
    dispatch_once(&startElementNSNeedsUndeclaredPrefixQuirk_hasEvaluatedQuirk, &__block_literal_global_0);
  }
  int v18 = 0;
  if (!startElementNSNeedsUndeclaredPrefixQuirk_needsQuirk && prefix && !URI)
  {
    if (*((_DWORD *)ctx + 142))
    {
      uint64_t v20 = xmlDictQLookup(*((xmlDictPtr *)ctx + 57), prefix, localname);
      int v18 = 0;
      if (v20) {
        localname = v20;
      }
    }
    else
    {
      int v18 = xmlBuildQName(localname, prefix, 0, 0);
    }
  }
  xmlNodePtr v19 = (xmlNodePtr)*((void *)ctx + 72);
  if (v19)
  {
    *((void *)ctx + 72) = v19->next;
    --*((_DWORD *)ctx + 143);
    *(_OWORD *)&v19->content = 0u;
    *(_OWORD *)&v19->nsDef = 0u;
    *(void *)&v19->line = 0;
    *(_OWORD *)&v19->xmlNodePtr next = 0u;
    *(_OWORD *)&v19->doc = 0u;
    *(_OWORD *)&v19->name = 0u;
    *(_OWORD *)&v19->last = 0u;
    *(_OWORD *)&v19->_private = 0u;
    v19->doc = (_xmlDoc *)*((void *)ctx + 2);
    v19->xmlElementType type = XML_ELEMENT_NODE;
    if (*((_DWORD *)ctx + 142))
    {
      int v18 = (xmlChar *)localname;
    }
    else if (!v18)
    {
      uint64_t v40 = xmlStrdup(localname);
      v19->name = v40;
      if (!v40) {
        goto LABEL_76;
      }
      goto LABEL_26;
    }
    v19->name = v18;
LABEL_26:
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      int v23 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNodePtr))*v23)(v19);
    }
    goto LABEL_32;
  }
  if (*((_DWORD *)ctx + 142))
  {
    int v21 = (xmlDoc *)*((void *)ctx + 2);
    int v18 = (xmlChar *)localname;
LABEL_30:
    xmlNodePtr v24 = xmlNewDocNodeEatName(v21, 0, v18, 0);
    goto LABEL_31;
  }
  int v21 = (xmlDoc *)*((void *)ctx + 2);
  if (v18) {
    goto LABEL_30;
  }
  xmlNodePtr v24 = xmlNewDocNode(v21, 0, localname, 0);
LABEL_31:
  xmlNodePtr v19 = v24;
  if (!v24) {
    goto LABEL_76;
  }
LABEL_32:
  int v55 = nb_defaulted;
  if (*((_DWORD *)ctx + 109))
  {
    uint64_t v25 = *((void *)ctx + 7);
    if (v25)
    {
      int v26 = *(_DWORD *)(v25 + 52);
      if (v26 >= 0xFFFF) {
        LOWORD(v26) = -1;
      }
      v19->line = v26;
    }
  }
  int v27 = prefix;
  xmlNodePtr parent = v16;
  if (!v16) {
    xmlAddChild(*((xmlNodePtr *)ctx + 2), v19);
  }
  xmlNodePtr elem = v19;
  if (nb_namespaces >= 1)
  {
    unsigned int v28 = 0;
    p_nsDef = &v19->nsDef;
    uint64_t v30 = namespaces + 1;
    do
    {
      unsigned int v31 = *(v30 - 1);
      uint64_t v32 = *v30;
      long long v33 = xmlNewNs(0, *v30, v31);
      if (v33)
      {
        long long v34 = v33;
        if (v28) {
          p_xmlNodePtr next = &v28->next;
        }
        else {
          p_xmlNodePtr next = p_nsDef;
        }
        *p_xmlNodePtr next = v33;
        if (URI && v31 == v27) {
          elem->xmlNsPtr ns = v33;
        }
        if (!*((_DWORD *)ctx + 13))
        {
          if (*((_DWORD *)ctx + 39))
          {
            if (*((_DWORD *)ctx + 6))
            {
              int v36 = (xmlDoc *)*((void *)ctx + 2);
              if (v36)
              {
                if (v36->intSubset) {
                  *((_DWORD *)ctx + 38) &= xmlValidateOneNamespace((xmlValidCtxtPtr)((char *)ctx + 160), v36, elem, v27, v33, v32);
                }
              }
            }
          }
        }
      }
      else
      {
        long long v34 = v28;
      }
      v30 += 2;
      unsigned int v28 = v34;
      --nb_namespaces;
    }
    while (nb_namespaces);
  }
  *((_DWORD *)ctx + 104) = -1;
  if (nodePush((xmlParserCtxtPtr)ctx, elem) < 0)
  {
    xmlUnlinkNode(elem);
    xmlFreeNode(elem);
    return;
  }
  if (parent)
  {
    if (parent->type != XML_ELEMENT_NODE)
    {
      xmlAddSibling(parent, elem);
      if (!v55) {
        goto LABEL_65;
      }
      goto LABEL_61;
    }
    xmlAddChild(parent, elem);
  }
  if (!v55) {
    goto LABEL_65;
  }
LABEL_61:
  if ((*((unsigned char *)ctx + 432) & 4) != 0) {
    int v37 = 0;
  }
  else {
    int v37 = v55;
  }
  nb_attributes -= v37;
LABEL_65:
  if (!URI) {
    goto LABEL_88;
  }
  if (elem->ns) {
    goto LABEL_88;
  }
  xmlNsPtr v38 = xmlSearchNs(*((xmlDocPtr *)ctx + 2), parent, v27);
  elem->xmlNsPtr ns = v38;
  if (v38) {
    goto LABEL_88;
  }
  if (xmlStrEqual(v27, (const xmlChar *)"xml"))
  {
    xmlNsPtr ns = xmlSearchNs(*((xmlDocPtr *)ctx + 2), elem, v27);
    elem->xmlNsPtr ns = ns;
  }
  else
  {
    xmlNsPtr ns = elem->ns;
  }
  if (ns) {
    goto LABEL_88;
  }
  if (!xmlNewNs(elem, 0, v27))
  {
LABEL_76:
    xmlSAX2ErrMemory((uint64_t *)ctx, "xmlSAX2StartElementNs");
    return;
  }
  if (v27)
  {
    unint64_t v41 = "Namespace prefix %s was not found\n";
    uint64_t v42 = ctx;
    uint64_t v43 = v27;
  }
  else
  {
    unint64_t v41 = "Namespace default prefix was not found\n";
    uint64_t v42 = ctx;
    uint64_t v43 = 0;
  }
  xmlNsWarnMsg(v42, 201, v41, v43, 0);
LABEL_88:
  if (nb_attributes >= 1)
  {
    int v44 = attributes + 4;
    do
    {
      __int16 v45 = *(v44 - 3);
      if (v45 && !*(v44 - 2))
      {
        if (*((_DWORD *)ctx + 142))
        {
          v51 = xmlDictQLookup(*((xmlDictPtr *)ctx + 57), v45, *(v44 - 4));
          if (v51)
          {
            uint64_t v46 = (xmlChar *)v51;
            uint64_t v48 = (char *)*(v44 - 1);
            int v49 = (xmlChar *)*v44;
            xmlURIPtr v50 = ctx;
            uint64_t v47 = 0;
            goto LABEL_93;
          }
        }
        else
        {
          v52 = xmlBuildQName(*(v44 - 4), v45, 0, 0);
          if (v52)
          {
            int v53 = v52;
            xmlSAX2AttributeNs((uint64_t)ctx, v52, 0, (char *)*(v44 - 1), *v44);
            xmlFree(v53);
            goto LABEL_94;
          }
        }
      }
      uint64_t v46 = (xmlChar *)*(v44 - 4);
      uint64_t v47 = (xmlChar *)*(v44 - 3);
      uint64_t v48 = (char *)*(v44 - 1);
      int v49 = (xmlChar *)*v44;
      xmlURIPtr v50 = ctx;
LABEL_93:
      xmlSAX2AttributeNs((uint64_t)v50, v46, v47, v48, v49);
LABEL_94:
      v44 += 5;
      --nb_attributes;
    }
    while (nb_attributes);
  }
  if (*((_DWORD *)ctx + 39) && *((_DWORD *)ctx + 52) == -1412623820)
  {
    int v54 = xmlValidateDtdFinal((xmlValidCtxtPtr)((char *)ctx + 160), *((xmlDocPtr *)ctx + 2));
    if (v54 <= 0)
    {
      *((_DWORD *)ctx + 38) = 0;
      if (v54 < 0) {
        *((_DWORD *)ctx + 6) = 0;
      }
    }
    *((_DWORD *)ctx + 38) &= xmlValidateRoot((xmlValidCtxtPtr)((char *)ctx + 160), *((xmlDocPtr *)ctx + 2));
    *((_DWORD *)ctx + 52) = -1412623819;
  }
}

void xmlSAX2AttributeNs(uint64_t a1, xmlChar *a2, xmlChar *nameSpace, char *a4, unsigned char *a5)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (nameSpace) {
    BOOL v10 = xmlSearchNs(*(xmlDocPtr *)(a1 + 16), *(xmlNodePtr *)(a1 + 80), nameSpace);
  }
  else {
    BOOL v10 = 0;
  }
  xmlAttrPtr v11 = *(xmlAttrPtr *)(a1 + 592);
  if (v11)
  {
    *(void *)(a1 + 592) = v11->next;
    --*(_DWORD *)(a1 + 584);
    *(_OWORD *)&v11->_private = 0u;
    *(_OWORD *)&v11->name = 0u;
    *(_OWORD *)&v11->doc = 0u;
    *(_OWORD *)&v11->axmlElementType type = 0u;
    *(_OWORD *)&v11->last = 0u;
    *(_OWORD *)&v11->xmlNodePtr next = 0u;
    v11->xmlElementType type = XML_ATTRIBUTE_NODE;
    v11->xmlNodePtr parent = *(_xmlNode **)(a1 + 80);
    v11->doc = *(_xmlDoc **)(a1 + 16);
    v11->xmlNsPtr ns = v10;
    uint64_t v12 = a2;
    if (!*(_DWORD *)(a1 + 568)) {
      uint64_t v12 = xmlStrdup(a2);
    }
    v11->name = v12;
    uint64_t v13 = *(void *)(a1 + 80);
    int v14 = *(_xmlAttr **)(v13 + 88);
    if (v14)
    {
      do
      {
        int v15 = v14;
        int v14 = v14->next;
      }
      while (v14);
      v15->xmlNodePtr next = v11;
      v11->prev = v15;
    }
    else
    {
      *(void *)(v13 + 88) = v11;
    }
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      int v18 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlAttrPtr))*v18)(v11);
    }
  }
  else
  {
    int v16 = *(xmlNode **)(a1 + 80);
    if (*(_DWORD *)(a1 + 568)) {
      xmlAttrPtr v17 = xmlNewNsPropEatName(v16, v10, a2, 0);
    }
    else {
      xmlAttrPtr v17 = xmlNewNsProp(v16, v10, a2, 0);
    }
    xmlAttrPtr v11 = v17;
    if (!v17)
    {
      htmlErrMemory((_DWORD *)a1, (const xmlChar *)"xmlSAX2AttributeNs");
      return;
    }
  }
  if (*(_DWORD *)(a1 + 28) || *(_DWORD *)(a1 + 52))
  {
    if (!a4) {
      goto LABEL_23;
    }
    goto LABEL_21;
  }
  if (*a5)
  {
LABEL_21:
    xmlNodePtr v19 = xmlSAX2TextNode(a1, a4, (int)a5 - (int)a4);
    v11->children = (_xmlNode *)v19;
    v11->last = (_xmlNode *)v19;
    if (v19)
    {
      *((void *)v19 + 8) = v11->doc;
      *((void *)v19 + 5) = v11;
    }
    goto LABEL_23;
  }
  xmlNodePtr NodeList = xmlStringLenGetNodeList(*(const xmlDoc **)(a1 + 16), (const xmlChar *)a4, (int)a5 - (int)a4);
  v11->children = NodeList;
  if (NodeList)
  {
    doc = v11->doc;
    do
    {
      xmlNodePtr v24 = NodeList;
      NodeList->doc = doc;
      NodeList->xmlNodePtr parent = (_xmlNode *)v11;
      xmlNodePtr NodeList = NodeList->next;
    }
    while (NodeList);
    v11->last = v24;
  }
LABEL_23:
  if (!*(_DWORD *)(a1 + 52))
  {
    if (*(_DWORD *)(a1 + 156))
    {
      if (*(_DWORD *)(a1 + 24))
      {
        uint64_t v20 = *(void *)(a1 + 16);
        if (v20)
        {
          if (*(void *)(v20 + 80))
          {
            if (!*(_DWORD *)(a1 + 28))
            {
              uint64_t v25 = xmlSAX2DecodeAttrEntities((xmlParserCtxtPtr)a1, (const xmlChar *)a4, (unint64_t)a5);
              if (v25)
              {
                int v21 = v25;
                if (*(void *)(a1 + 552))
                {
                  __int16 v30 = 0;
                  memset(v29, 0, sizeof(v29));
                  int v26 = xmlBuildQName(a2, nameSpace, (xmlChar *)v29, 50);
                  if (!v26) {
                    goto LABEL_69;
                  }
                  int v27 = v26;
                  *(_DWORD *)(a1 + 224) = 1;
                  unsigned int v28 = xmlValidCtxtNormalizeAttributeValue((xmlValidCtxtPtr)(a1 + 160), *(xmlDocPtr *)(a1 + 16), *(xmlNodePtr *)(a1 + 80), v26, v21);
                  if (*(_DWORD *)(a1 + 224) != 1) {
                    *(_DWORD *)(a1 + 152) = 0;
                  }
                  if (v27 != (xmlChar *)v29 && v27 != a2) {
                    xmlFree(v27);
                  }
                  if (v28) {
                    xmlFree(v21);
                  }
                  else {
LABEL_69:
                  }
                    unsigned int v28 = v21;
                  int v21 = v28;
                }
                *(_DWORD *)(a1 + 152) &= xmlValidateOneAttribute((xmlValidCtxtPtr)(a1 + 160), *(xmlDocPtr *)(a1 + 16), *(xmlNodePtr *)(a1 + 80), v11, v21);
                goto LABEL_72;
              }
              if (!*a5)
              {
                *(_DWORD *)(a1 + 152) &= xmlValidateOneAttribute((xmlValidCtxtPtr)(a1 + 160), *(xmlDocPtr *)(a1 + 16), *(xmlNodePtr *)(a1 + 80), v11, (const xmlChar *)a4);
                return;
              }
            }
            int v21 = xmlStrndup((const xmlChar *)a4, (int)a5 - (int)a4);
            *(_DWORD *)(a1 + 152) &= xmlValidateOneAttribute((xmlValidCtxtPtr)(a1 + 160), *(xmlDocPtr *)(a1 + 16), *(xmlNodePtr *)(a1 + 80), v11, v21);
            if (!v21) {
              return;
            }
LABEL_72:
            xmlFree(v21);
            return;
          }
        }
      }
    }
  }
  if ((*(unsigned char *)(a1 + 432) & 8) != 0) {
    return;
  }
  if (*(_DWORD *)(a1 + 28))
  {
    if (*(_DWORD *)(a1 + 336)) {
      return;
    }
  }
  else if (*(_DWORD *)(a1 + 148) == 2)
  {
    return;
  }
  if (*(xmlChar **)(a1 + 480) == nameSpace && *a2 == 105 && a2[1] == 100 && !a2[2])
  {
    int v21 = xmlStrndup((const xmlChar *)a4, (int)a5 - (int)a4);
    if (xmlValidateNCName(v21, 1)) {
      xmlErrValid((_DWORD *)a1, 539, "xml:id : attribute value %s is not an NCName\n", v21, 0);
    }
  }
  else
  {
    if (!xmlIsID(*(xmlDocPtr *)(a1 + 16), *(xmlNodePtr *)(a1 + 80), v11))
    {
      if (xmlIsRef(*(xmlDocPtr *)(a1 + 16), *(xmlNodePtr *)(a1 + 80), v11))
      {
        int v21 = xmlStrndup((const xmlChar *)a4, (int)a5 - (int)a4);
        xmlAddRef((xmlValidCtxtPtr)(a1 + 160), *(xmlDocPtr *)(a1 + 16), v21, v11);
        if (v21) {
          goto LABEL_72;
        }
      }
      return;
    }
    int v21 = xmlStrndup((const xmlChar *)a4, (int)a5 - (int)a4);
  }
  xmlAddID((xmlValidCtxtPtr)(a1 + 160), *(xmlDocPtr *)(a1 + 16), v21, v11);
  if (v21) {
    goto LABEL_72;
  }
}

int xmlIsID(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!attr) {
    return 0;
  }
  name = attr->name;
  if (!name) {
    return 0;
  }
  xmlNsPtr ns = attr->ns;
  if (ns)
  {
    prefix = (const char *)ns->prefix;
    if (prefix)
    {
      if (!strcmp((const char *)attr->name, "id") && !strcmp(prefix, "xml")) {
        return 1;
      }
    }
  }
  if (!doc || !doc->intSubset && !doc->extSubset && doc->type != XML_HTML_DOCUMENT_NODE) {
    return 0;
  }
  if (doc->type != XML_HTML_DOCUMENT_NODE)
  {
    if (!elem) {
      return 0;
    }
    __int16 v22 = 0;
    long long v20 = 0u;
    long long v21 = 0u;
    *(_OWORD *)memory = 0u;
    __int16 v18 = 0;
    memset(v17, 0, sizeof(v17));
    xmlNodePtr v9 = elem->ns;
    if (!v9) {
      goto LABEL_21;
    }
    BOOL v10 = v9->prefix;
    if (v10)
    {
      xmlAttrPtr v11 = xmlBuildQName(elem->name, v10, memory, 50);
      xmlNsPtr ns = attr->ns;
    }
    else
    {
LABEL_21:
      xmlAttrPtr v11 = (xmlChar *)elem->name;
    }
    if (ns)
    {
      uint64_t v12 = ns->prefix;
      uint64_t v13 = (xmlChar *)attr->name;
      if (v12) {
        uint64_t v13 = xmlBuildQName(attr->name, v12, (xmlChar *)v17, 50);
      }
    }
    else
    {
      uint64_t v13 = (xmlChar *)attr->name;
    }
    xmlAttributePtr DtdAttrDesc = 0;
    if (v11)
    {
      if (v13)
      {
        xmlAttributePtr DtdAttrDesc = xmlGetDtdAttrDesc(doc->intSubset, v11, v13);
        if (!DtdAttrDesc)
        {
          extSubset = doc->extSubset;
          if (extSubset) {
            xmlAttributePtr DtdAttrDesc = xmlGetDtdAttrDesc(extSubset, v11, v13);
          }
          else {
            xmlAttributePtr DtdAttrDesc = 0;
          }
        }
      }
    }
    if (v13 != (xmlChar *)v17 && v13 != attr->name) {
      xmlFree(v13);
    }
    if (v11 != memory && v11 != elem->name) {
      xmlFree(v11);
    }
    return DtdAttrDesc && DtdAttrDesc->atype == XML_ATTRIBUTE_ID;
  }
  return xmlStrEqual((const xmlChar *)"id", name)
      || xmlStrEqual((const xmlChar *)"name", attr->name) && (!elem || xmlStrEqual(elem->name, (const xmlChar *)"a"));
}

xmlAttr *xmlNewPropInternal(uint64_t a1, xmlNs *a2, xmlChar *str, const xmlChar *a4, int a5)
{
  unsigned int v7 = str;
  if (a1 && *(_DWORD *)(a1 + 8) != 1)
  {
    if (a5 == 1)
    {
      uint64_t v15 = *(void *)(a1 + 64);
      if (!v15 || !xmlDictOwns(*(xmlDictPtr *)(v15 + 152), str)) {
        xmlFree(v7);
      }
    }
    return 0;
  }
  BOOL v10 = (xmlAttr *)xmlMalloc(0x60uLL);
  if (!v10)
  {
    if (a5 == 1 && (!a1 || (uint64_t v16 = *(void *)(a1 + 64)) == 0 || !xmlDictOwns(*(xmlDictPtr *)(v16 + 152), v7))) {
      xmlFree(v7);
    }
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building attribute");
    return 0;
  }
  xmlAttrPtr v11 = v10;
  *(_OWORD *)&v10->doc = 0u;
  *(_OWORD *)&v10->axmlElementType type = 0u;
  *(_OWORD *)&v10->last = 0u;
  *(_OWORD *)&v10->xmlNodePtr next = 0u;
  *(_OWORD *)&v10->_private = 0u;
  *(_OWORD *)&v10->name = 0u;
  v10->xmlElementType type = XML_ATTRIBUTE_NODE;
  v10->xmlNodePtr parent = (_xmlNode *)a1;
  if (!a1)
  {
    uint64_t v12 = 0;
    v10->xmlNsPtr ns = a2;
    if (a5) {
      goto LABEL_23;
    }
    goto LABEL_21;
  }
  uint64_t v12 = *(_xmlDoc **)(a1 + 64);
  v10->doc = v12;
  v10->xmlNsPtr ns = a2;
  if (a5) {
    goto LABEL_23;
  }
  if (!v12 || (dict = v12->dict) == 0)
  {
LABEL_21:
    int v14 = xmlStrdup(v7);
    goto LABEL_22;
  }
  int v14 = (xmlChar *)xmlDictLookup(dict, v7, -1);
LABEL_22:
  unsigned int v7 = v14;
LABEL_23:
  v11->name = v7;
  if (!a4) {
    goto LABEL_28;
  }
  xmlNodePtr v17 = xmlNewText(a4);
  if (v17)
  {
    v17->doc = v12;
    v11->children = v17;
    do
    {
      __int16 v18 = v17;
      v17->xmlNodePtr parent = (_xmlNode *)v11;
      xmlNodePtr v17 = v17->next;
    }
    while (v17);
    v11->last = v18;
LABEL_28:
    if (!a1) {
      goto LABEL_38;
    }
    goto LABEL_29;
  }
  v11->children = 0;
  v11->last = 0;
  if (!a1) {
    goto LABEL_38;
  }
LABEL_29:
  xmlNodePtr v19 = *(_xmlAttr **)(a1 + 88);
  if (v19)
  {
    do
    {
      long long v20 = v19;
      xmlNodePtr v19 = v19->next;
    }
    while (v19);
    v20->xmlNodePtr next = v11;
    v11->prev = v20;
    if (!a4) {
      goto LABEL_38;
    }
LABEL_36:
    if (xmlIsID(*(xmlDocPtr *)(a1 + 64), (xmlNodePtr)a1, v11) == 1) {
      xmlAddID(0, *(xmlDocPtr *)(a1 + 64), a4, v11);
    }
    goto LABEL_38;
  }
  *(void *)(a1 + 88) = v11;
  if (a4) {
    goto LABEL_36;
  }
LABEL_38:
  if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
  {
    long long v21 = __xmlRegisterNodeDefaultValue();
    ((void (*)(xmlAttr *))*v21)(v11);
  }
  return v11;
}

int xmlIsRef(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr)
{
  if (!attr)
  {
    LODWORD(DtdAttrDesc) = 0;
    return (int)DtdAttrDesc;
  }
  xmlDocPtr v5 = doc;
  if (!doc)
  {
    xmlDocPtr v5 = attr->doc;
    if (!v5) {
      goto LABEL_11;
    }
  }
  intSubset = v5->intSubset;
  if (!intSubset && !v5->extSubset) {
    goto LABEL_11;
  }
  if (v5->type == XML_HTML_DOCUMENT_NODE || !elem) {
    goto LABEL_11;
  }
  xmlAttributePtr DtdAttrDesc = xmlGetDtdAttrDesc(intSubset, elem->name, attr->name);
  if (DtdAttrDesc
    || (xmlAttributePtr DtdAttrDesc = (xmlAttributePtr)v5->extSubset) != 0
    && (xmlAttributePtr DtdAttrDesc = xmlGetDtdAttrDesc((xmlDtdPtr)DtdAttrDesc, elem->name, attr->name)) != 0)
  {
    if (DtdAttrDesc->atype - 3 <= 1)
    {
      LODWORD(DtdAttrDesc) = 1;
      return (int)DtdAttrDesc;
    }
LABEL_11:
    LODWORD(DtdAttrDesc) = 0;
  }
  return (int)DtdAttrDesc;
}

xmlChar *__cdecl xmlStrdup(xmlChar *cur)
{
  if (cur)
  {
    uint64_t v1 = 0;
    while (cur[v1++])
      ;
    return xmlStrndup(cur, (int)v1 - 1);
  }
  return cur;
}

xmlAttrPtr xmlNewNsProp(xmlNodePtr node, xmlNsPtr ns, const xmlChar *name, const xmlChar *value)
{
  if (name) {
    return xmlNewPropInternal((uint64_t)node, ns, (xmlChar *)name, value, 0);
  }
  else {
    return 0;
  }
}

xmlAttrPtr xmlNewNsPropEatName(xmlNodePtr node, xmlNsPtr ns, xmlChar *name, const xmlChar *value)
{
  if (name) {
    return xmlNewPropInternal((uint64_t)node, ns, name, value, 1);
  }
  else {
    return 0;
  }
}

xmlNodePtr xmlAddChild(xmlNodePtr parent, xmlNodePtr cur)
{
  if (parent)
  {
    xmlNodePtr v3 = parent;
    xmlNodePtr parent = 0;
    if (cur)
    {
      xmlElementType type = v3->type;
      if (type != XML_NAMESPACE_DECL)
      {
        xmlNodePtr parent = 0;
        if (v3 != cur)
        {
          xmlElementType v5 = cur->type;
          if (v5 != XML_NAMESPACE_DECL)
          {
            if (v5 == XML_TEXT_NODE)
            {
              if (type == XML_TEXT_NODE && v3->content && v3->name == cur->name) {
                goto LABEL_20;
              }
              last = v3->last;
              if (last && last->type == XML_TEXT_NODE && last != cur && last->name == cur->name)
              {
                xmlNodeAddContent(last, cur->content);
                xmlFreeNode(cur);
                return v3->last;
              }
            }
            unsigned int v7 = cur->parent;
            cur->xmlNodePtr parent = v3;
            doc = cur->doc;
            xmlNodePtr v9 = v3->doc;
            if (doc != v9) {
              xmlSetTreeDoc(cur, v9);
            }
            if (v7 == v3) {
              return cur;
            }
            xmlElementType v10 = v3->type;
            if (v10 == XML_TEXT_NODE)
            {
              if (v3->content)
              {
LABEL_20:
                xmlNodeAddContent(v3, cur->content);
                xmlFreeNode(cur);
                return v3;
              }
              if (cur->type == XML_ATTRIBUTE_NODE) {
                return 0;
              }
            }
            else if (cur->type == XML_ATTRIBUTE_NODE)
            {
              if (v10 != XML_ELEMENT_NODE) {
                return 0;
              }
              if (!v3->properties) {
                goto LABEL_43;
              }
              xmlNsPtr ns = cur->ns;
              if (ns) {
                href = ns->href;
              }
              else {
                href = 0;
              }
              xmlAttributePtr PropNodeInternal = xmlGetPropNodeInternal((uint64_t)v3, (xmlChar *)cur->name, href, 1);
              uint64_t v15 = (xmlAttr *)PropNodeInternal;
              if (PropNodeInternal
                && PropNodeInternal != (xmlAttributePtr)cur
                && PropNodeInternal->type != XML_ATTRIBUTE_DECL)
              {
                xmlUnlinkNode((xmlNodePtr)PropNodeInternal);
                xmlFreeProp(v15);
              }
              if (v15 == (xmlAttr *)cur) {
                return cur;
              }
              int properties = (_xmlNode *)v3->properties;
              if (properties)
              {
                do
                {
                  xmlNodePtr v17 = properties;
                  int properties = properties->next;
                }
                while (properties);
                v17->xmlNodePtr next = cur;
                cur->prev = v17;
              }
              else
              {
LABEL_43:
                v3->int properties = (_xmlAttr *)cur;
              }
              return cur;
            }
            if (v3->children)
            {
              uint64_t v13 = v3->last;
              v13->xmlNodePtr next = cur;
              cur->prev = v13;
            }
            else
            {
              v3->children = cur;
            }
            v3->last = cur;
            return cur;
          }
        }
      }
    }
  }
  return parent;
}

int nodePush(xmlParserCtxtPtr ctxt, xmlNodePtr value)
{
  if (ctxt)
  {
    xmlParserCtxtPtr v3 = ctxt;
    LODWORD(ctxt) = ctxt->nodeNr;
    uint64_t nodeMax = v3->nodeMax;
    if ((int)ctxt >= (int)nodeMax)
    {
      ctxt = (xmlParserCtxtPtr)xmlRealloc(v3->nodeTab, 16 * nodeMax);
      if (!ctxt)
      {
        htmlErrMemory(v3, 0);
        goto LABEL_10;
      }
      v3->nodeTab = (xmlNodePtr *)ctxt;
      LODWORD(ctxt) = v3->nodeNr;
      v3->nodeMax *= 2;
    }
    if (ctxt > xmlParserMaxDepth && (v3->options & 0x80000) == 0)
    {
      xmlFatalErrMsgInt(v3, 1, "Excessive depth in document: %d use XML_PARSE_HUGE option\n", xmlParserMaxDepth);
      xmlHaltParser(v3);
LABEL_10:
      LODWORD(ctxt) = -1;
      return (int)ctxt;
    }
    v3->nodeTab[(int)ctxt] = value;
    v3->node = value;
    v3->nodeNr = ctxt + 1;
  }
  return (int)ctxt;
}

xmlNodePtr xmlNewDocNodeEatName(xmlDocPtr doc, xmlNsPtr ns, xmlChar *name, const xmlChar *content)
{
  xmlNodePtr v7 = xmlNewNodeEatName(ns, name);
  uint64_t v8 = v7;
  if (v7)
  {
    v7->doc = doc;
    if (content)
    {
      xmlNodePtr NodeList = xmlStringGetNodeList(doc, content);
      v8->children = NodeList;
      if (NodeList)
      {
        xmlNodePtr next = NodeList->next;
        if (next)
        {
          do
          {
            xmlNodePtr v11 = next;
            NodeList->xmlNodePtr parent = v8;
            xmlNodePtr next = next->next;
            xmlNodePtr NodeList = v11;
          }
          while (next);
        }
        else
        {
          xmlNodePtr v11 = NodeList;
        }
        v11->xmlNodePtr parent = v8;
        v8->last = v11;
      }
      else
      {
        v8->last = 0;
      }
    }
  }
  else if (doc && name && !xmlDictOwns(doc->dict, name))
  {
    xmlFree(name);
  }
  return v8;
}

xmlNodePtr xmlNewNodeEatName(xmlNsPtr ns, xmlChar *name)
{
  if (!name) {
    return 0;
  }
  uint64_t v4 = (xmlNode *)xmlMalloc(0x78uLL);
  xmlElementType v5 = v4;
  if (v4)
  {
    *(_OWORD *)&v4->_private = 0u;
    *(_OWORD *)&v4->name = 0u;
    *(void *)&v4->line = 0;
    *(_OWORD *)&v4->content = 0u;
    *(_OWORD *)&v4->nsDef = 0u;
    *(_OWORD *)&v4->xmlNodePtr next = 0u;
    *(_OWORD *)&v4->doc = 0u;
    *(_OWORD *)&v4->last = 0u;
    v4->xmlElementType type = XML_ELEMENT_NODE;
    v4->name = name;
    v4->xmlNsPtr ns = ns;
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      unint64_t v6 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v6)(v5);
    }
  }
  else
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building node");
  }
  return v5;
}

uint64_t htmlParseCharData(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  bzero(v22, 0x3EEuLL);
  uint64_t v2 = *(xmlParserInput **)(a1 + 56);
  cur = v2->cur;
  if (cur - v2->base >= 501 && v2->end - cur <= 499) {
    xmlParserInputShrink(v2);
  }
  int len = 0;
  uint64_t result = htmlCurrentChar(a1, &len);
  int v5 = result;
  uint64_t v6 = 0;
  int v7 = 0;
  while (1)
  {
    if (v5 == 38)
    {
      if (*(_DWORD *)(a1 + 276) != 38) {
        goto LABEL_56;
      }
      goto LABEL_16;
    }
    if (v5 == 60)
    {
      if (*(_DWORD *)(a1 + 276) != 60)
      {
LABEL_56:
        if (!v6) {
          return result;
        }
        goto LABEL_59;
      }
      goto LABEL_16;
    }
    if (!v5) {
      break;
    }
    if (v5 > 255)
    {
      if ((v5 - 0x10000) >= 0x100000
        && v5 >> 11 >= 0x1B
        && (v5 - 57344) >> 1 >= 0xFFF)
      {
LABEL_29:
        htmlParseErrInt((_DWORD *)a1, "Invalid char in CDATA 0x%X\n", v5);
        int v8 = len;
        goto LABEL_34;
      }
    }
    else if (v5 <= 31 && (v5 > 0xD || ((1 << v5) & 0x2600) == 0))
    {
      goto LABEL_29;
    }
LABEL_16:
    int v8 = len;
    if (len == 1)
    {
      v22[(int)v6] = v5;
      uint64_t v6 = (v6 + 1);
    }
    else
    {
      uint64_t v6 = (xmlCopyChar(len, &v22[(int)v6], v5) + v6);
    }
    if ((int)v6 >= 1000)
    {
      v22[v6] = 0;
      if (!*(void *)a1 || *(_DWORD *)(a1 + 332)) {
        goto LABEL_33;
      }
      if (areBlanks(a1, v22, v6))
      {
        uint64_t v9 = *(void *)a1;
        if (!*(_DWORD *)(a1 + 328))
        {
          xmlElementType v10 = *(void (**)(void, unsigned __int8 *, uint64_t))(v9 + 144);
          if (!v10) {
            goto LABEL_33;
          }
LABEL_32:
          v10(*(void *)(a1 + 8), v22, v6);
LABEL_33:
          uint64_t v6 = 0;
          goto LABEL_34;
        }
      }
      else
      {
        htmlCheckParagraph(a1);
        uint64_t v9 = *(void *)a1;
      }
      xmlElementType v10 = *(void (**)(void, unsigned __int8 *, uint64_t))(v9 + 136);
      if (v10) {
        goto LABEL_32;
      }
      goto LABEL_33;
    }
LABEL_34:
    xmlNodePtr v11 = *(xmlParserInput **)(a1 + 56);
    uint64_t v13 = v11->cur;
    end = v11->end;
    int v14 = &v13[v8];
    if (v14 <= end)
    {
      if (*v13 == 10)
      {
        ++v11->line;
        v11->col = 1;
      }
      else
      {
        ++v11->col;
      }
      *(_DWORD *)(a1 + 276) = 0;
      v11->cur = v14;
      ++*(void *)(a1 + 312);
      v13 += v8;
    }
    if (v7 < 100)
    {
      ++v7;
    }
    else
    {
      if (end - v13 <= 499 && v13 - v11->base >= 501) {
        xmlParserInputShrink(v11);
      }
      if (!*(_DWORD *)(a1 + 452))
      {
        uint64_t v15 = *(xmlParserInput **)(a1 + 56);
        if (v15->end - v15->cur <= 249) {
          xmlParserInputGrow(v15, 250);
        }
      }
      int v7 = 0;
    }
    uint64_t result = htmlCurrentChar(a1, &len);
    int v5 = result;
    if (!result)
    {
      uint64_t v16 = *(xmlParserInput **)(a1 + 56);
      xmlNodePtr v17 = v16->cur;
      if (v17 - v16->base >= 501 && v16->end - v17 <= 499) {
        xmlParserInputShrink(v16);
      }
      if (!*(_DWORD *)(a1 + 452))
      {
        __int16 v18 = *(xmlParserInput **)(a1 + 56);
        if (v18->end - v18->cur <= 249) {
          xmlParserInputGrow(v18, 250);
        }
      }
      uint64_t result = htmlCurrentChar(a1, &len);
      int v5 = result;
    }
  }
  if (!v6)
  {
    *(_DWORD *)(a1 + 272) = -1;
    return result;
  }
LABEL_59:
  v22[(int)v6] = 0;
  if (!*(void *)a1 || *(_DWORD *)(a1 + 332)) {
    return result;
  }
  uint64_t result = areBlanks(a1, v22, v6);
  if (!result)
  {
    uint64_t result = htmlCheckParagraph(a1);
    uint64_t v19 = *(void *)a1;
LABEL_67:
    long long v20 = *(uint64_t (**)(void, unsigned __int8 *, uint64_t))(v19 + 136);
    if (v20) {
      return v20(*(void *)(a1 + 8), v22, v6);
    }
    return result;
  }
  uint64_t v19 = *(void *)a1;
  if (*(_DWORD *)(a1 + 328)) {
    goto LABEL_67;
  }
  long long v20 = *(uint64_t (**)(void, unsigned __int8 *, uint64_t))(v19 + 144);
  if (!v20) {
    return result;
  }
  return v20(*(void *)(a1 + 8), v22, v6);
}

uint64_t htmlCurrentChar(uint64_t a1, _DWORD *a2)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 272) == -1) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 276))
  {
    *a2 = 0;
    return *(unsigned int *)(a1 + 276);
  }
  if (*(_DWORD *)(a1 + 408) == 1)
  {
LABEL_18:
    xmlNodePtr v11 = *(xmlParserInput **)(a1 + 56);
    cur = v11->cur;
    int v13 = *cur;
    if ((*(char *)cur & 0x80000000) == 0)
    {
      if (!*cur && cur < v11->end)
      {
        htmlParseErrInt((_DWORD *)a1, "Char 0x%X out of allowed range\n", 0);
        *a2 = 1;
        return 32;
      }
      *a2 = 1;
      return *cur;
    }
    if ((v13 & 0x40) == 0) {
      goto LABEL_62;
    }
    unint64_t v14 = v11->end - cur;
    if (v14 <= 1)
    {
      xmlParserInputGrow(v11, 250);
      xmlNodePtr v11 = *(xmlParserInput **)(a1 + 56);
      cur = v11->cur;
      unint64_t v14 = v11->end - cur;
      if (v14 < 2) {
        goto LABEL_62;
      }
    }
    if ((cur[1] & 0xC0) != 0x80) {
      goto LABEL_62;
    }
    if ((~v13 & 0xE0) != 0)
    {
      *a2 = 2;
      uint64_t v4 = cur[1] & 0x3F | ((*cur & 0x1F) << 6);
      if (v4 < 0x80) {
        goto LABEL_62;
      }
    }
    else
    {
      if (v14 <= 2)
      {
        xmlParserInputGrow(v11, 250);
        xmlNodePtr v11 = *(xmlParserInput **)(a1 + 56);
        cur = v11->cur;
        unint64_t v14 = v11->end - cur;
        if (v14 < 3) {
          goto LABEL_62;
        }
      }
      if ((cur[2] & 0xC0) != 0x80) {
        goto LABEL_62;
      }
      if ((~v13 & 0xF0) == 0)
      {
        if (v14 <= 3)
        {
          xmlParserInputGrow(v11, 250);
          xmlNodePtr v11 = *(xmlParserInput **)(a1 + 56);
          cur = v11->cur;
          unint64_t v14 = v11->end - cur;
        }
        if ((v13 & 0xF8) == 0xF0 && v14 >= 4 && (cur[3] & 0xC0) == 0x80)
        {
          *a2 = 4;
          uint64_t v4 = ((*cur & 7) << 18) | ((cur[1] & 0x3F) << 12) | ((cur[2] & 0x3F) << 6) | cur[3] & 0x3Fu;
          if (v4 >= 0x10000) {
            goto LABEL_72;
          }
        }
LABEL_62:
        long long v42 = 0u;
        memset(v43, 0, sizeof(v43));
        long long v40 = 0u;
        long long v41 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        *(_OWORD *)__str = 0u;
        if (v11->end - v11->cur < 4) {
          snprintf(__str, 0x95uLL, "Bytes: 0x%02X\n");
        }
        else {
          snprintf(__str, 0x95uLL, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n");
        }
        htmlParseErr((_DWORD *)a1, 81, "Input is not proper UTF-8, indicate encoding !\n", (const xmlChar *)__str, 0);
        int v27 = *(void **)(a1 + 56);
        if (*v27 && !*(void *)(*v27 + 24))
        {
          xmlSwitchEncoding((xmlParserCtxtPtr)a1, XML_CHAR_ENCODING_8859_1);
          int v27 = *(void **)(a1 + 56);
        }
        *a2 = 1;
        cur = (const xmlChar *)v27[4];
        return *cur;
      }
      *a2 = 3;
      uint64_t v4 = ((*cur & 0xF) << 12) | ((cur[1] & 0x3F) << 6) | cur[2] & 0x3Fu;
      if (v4 < 0x800) {
        goto LABEL_62;
      }
    }
LABEL_72:
    if (v4 >> 11 >= 0x1B
      && (v4 - 57344) >> 1 >= 0xFFF
      && (v4 - 0x10000) >= 0x100000)
    {
      htmlParseErrInt((_DWORD *)a1, "Char 0x%X out of allowed range\n", v4);
    }
    return v4;
  }
  int v5 = *(void **)(a1 + 56);
  uint64_t v6 = (const xmlChar *)v5[4];
  if (*(char *)v6 < 0)
  {
    if (v5[10]) {
      goto LABEL_11;
    }
    if (!*v5) {
      goto LABEL_11;
    }
    if (*(void *)(*v5 + 24)) {
      goto LABEL_11;
    }
    uint64_t v16 = (unsigned char *)v5[5];
    if (!v16) {
      goto LABEL_11;
    }
    if (*v16) {
      goto LABEL_11;
    }
    xmlNodePtr v17 = xmlStrcasestr(v6, (const xmlChar *)"HTTP-EQUIV");
    if (!v17) {
      goto LABEL_11;
    }
    __int16 v18 = xmlStrcasestr(v17, (const xmlChar *)"CONTENT");
    if (!v18) {
      goto LABEL_11;
    }
    uint64_t v19 = xmlStrcasestr(v18, (const xmlChar *)"CHARSET=");
    if (!v19) {
      goto LABEL_11;
    }
    for (uint64_t i = 0; ; ++i)
    {
      int v21 = v19[i + 8];
      if ((v21 - 48) >= 0xA && (v21 & 0xFFFFFFDF) - 65 >= 0x1A)
      {
        unsigned int v23 = v21 - 45;
        BOOL v24 = v23 > 0x32;
        uint64_t v25 = (1 << v23) & 0x4000000002005;
        if (v24 || v25 == 0) {
          break;
        }
      }
    }
    if (i && (uint64_t v29 = xmlStrndup(v19 + 8, i)) != 0)
    {
      __int16 v30 = (const char *)v29;
      uint64_t v31 = *(void *)(a1 + 56);
      uint64_t v32 = *(void **)(v31 + 80);
      if (v32)
      {
        xmlFree(v32);
        uint64_t v31 = *(void *)(a1 + 56);
      }
      *(void *)(v31 + 80) = v30;
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler(v30);
      if (CharEncodingHandler)
      {
        handler = CharEncodingHandler;
        if (xmlStrEqual((const xmlChar *)CharEncodingHandler->name, (const xmlChar *)"UTF-8")
          || (xmlSwitchToEncoding((xmlParserCtxtPtr)a1, handler) & 0x80000000) == 0)
        {
          goto LABEL_17;
        }
        if (*(_DWORD *)(a1 + 136)) {
          int v7 = *(_DWORD *)(a1 + 136);
        }
        else {
          int v7 = 6003;
        }
        int v8 = "htmlCheckEncoding: error switching to encoding '%s'\n";
        uint64_t v9 = (_DWORD *)a1;
      }
      else
      {
        int v8 = "Unsupported encoding %s";
        uint64_t v9 = (_DWORD *)a1;
        int v7 = 81;
      }
      xmlElementType v10 = (const xmlChar *)v30;
    }
    else
    {
LABEL_11:
      if ((xmlSwitchEncoding((xmlParserCtxtPtr)a1, XML_CHAR_ENCODING_8859_1) & 0x80000000) == 0)
      {
LABEL_17:
        *(_DWORD *)(a1 + 408) = 1;
        goto LABEL_18;
      }
      if (*(_DWORD *)(a1 + 136)) {
        int v7 = *(_DWORD *)(a1 + 136);
      }
      else {
        int v7 = 6003;
      }
      int v8 = "htmlCheckEncoding: error switching to encoding 'ISO-8859-1'\n";
      uint64_t v9 = (_DWORD *)a1;
      xmlElementType v10 = 0;
    }
    htmlParseErr(v9, v7, v8, v10, 0);
    goto LABEL_17;
  }
  *a2 = 1;
  uint64_t v4 = *v6;
  if (!*v6 && (unint64_t)v6 < v5[5])
  {
    htmlParseErrInt((_DWORD *)a1, "Char 0x%X out of allowed range\n", 0);
    return 32;
  }
  return v4;
}

int xmlCopyChar(int len, xmlChar *out, int val)
{
  if (!out) {
    return 0;
  }
  if (val >= 128) {
    return xmlCopyCharMultiByte(out, val);
  }
  *out = val;
  return 1;
}

uint64_t htmlCheckParagraph(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(const xmlChar **)(result + 288);
  if (v2)
  {
    if (!htmlOmittedDefaultValue) {
      return result;
    }
    uint64_t v3 = 0;
    while (1)
    {
      uint64_t result = xmlStrEqual(v2, (const xmlChar *)htmlNoContentElements[v3]);
      if (result) {
        break;
      }
      if (++v3 == 2) {
        return result;
      }
    }
  }
  htmlAutoClose((int *)v1, (uint64_t)"p");
  htmlCheckImplied(v1, (xmlChar *)"p");
  uint64_t result = (uint64_t)htmlnamePush(v1, (xmlChar *)"p");
  if (*(void *)v1)
  {
    uint64_t v4 = *(uint64_t (**)(uint64_t, const char *, void))(*(void *)v1 + 112);
    if (v4)
    {
      uint64_t v5 = *(void *)(v1 + 8);
      return v4(v5, "p", 0);
    }
  }
  return result;
}

_DWORD *htmlnamePush(uint64_t a1, xmlChar *str1)
{
  int v4 = *(_DWORD *)(a1 + 52);
  if (v4 > 2)
  {
LABEL_5:
    if (v4 > 9) {
      goto LABEL_8;
    }
    goto LABEL_6;
  }
  if (!xmlStrEqual(str1, (const xmlChar *)"head"))
  {
    int v4 = *(_DWORD *)(a1 + 52);
    goto LABEL_5;
  }
  *(_DWORD *)(a1 + 52) = 3;
LABEL_6:
  if (xmlStrEqual(str1, (const xmlChar *)"body")) {
    *(_DWORD *)(a1 + 52) = 10;
  }
LABEL_8:
  int v5 = *(_DWORD *)(a1 + 296);
  uint64_t v6 = *(int *)(a1 + 300);
  if (v5 < (int)v6)
  {
    uint64_t result = *(_DWORD **)(a1 + 304);
LABEL_12:
    *(void *)&result[2 * v5] = str1;
    *(void *)(a1 + 288) = str1;
    *(_DWORD *)(a1 + 296) = v5 + 1;
    return result;
  }
  *(_DWORD *)(a1 + 300) = 2 * v6;
  uint64_t result = xmlRealloc(*(void **)(a1 + 304), 16 * v6);
  *(void *)(a1 + 304) = result;
  if (result)
  {
    int v5 = *(_DWORD *)(a1 + 296);
    goto LABEL_12;
  }

  return htmlErrMemory((_DWORD *)a1, 0);
}

uint64_t htmlCheckImplied(uint64_t result, xmlChar *str1)
{
  if ((*(unsigned char *)(result + 565) & 0x20) != 0) {
    return result;
  }
  if (!htmlOmittedDefaultValue) {
    return result;
  }
  uint64_t v3 = result;
  uint64_t result = xmlStrEqual(str1, (const xmlChar *)"html");
  if (result) {
    return result;
  }
  if (*(int *)(v3 + 296) <= 0)
  {
    htmlnamePush(v3, (xmlChar *)"html");
    if (*(void *)v3)
    {
      int v4 = *(void (**)(void, const char *, void))(*(void *)v3 + 112);
      if (v4) {
        v4(*(void *)(v3 + 8), "html", 0);
      }
    }
  }
  uint64_t result = xmlStrEqual(str1, (const xmlChar *)"body");
  if (result) {
    return result;
  }
  uint64_t result = xmlStrEqual(str1, (const xmlChar *)"head");
  if (result) {
    return result;
  }
  if (*(int *)(v3 + 296) <= 1)
  {
    uint64_t result = xmlStrEqual(str1, (const xmlChar *)"script");
    if (result
      || (uint64_t result = xmlStrEqual(str1, (const xmlChar *)"style"), result)
      || (uint64_t result = xmlStrEqual(str1, (const xmlChar *)"meta"), result)
      || (uint64_t result = xmlStrEqual(str1, (const xmlChar *)"link"), result)
      || (uint64_t result = xmlStrEqual(str1, (const xmlChar *)"title"), result)
      || (uint64_t result = xmlStrEqual(str1, (const xmlChar *)"base"), result))
    {
      if (*(int *)(v3 + 52) > 2) {
        return result;
      }
      uint64_t result = (uint64_t)htmlnamePush(v3, (xmlChar *)"head");
      if (!*(void *)v3) {
        return result;
      }
      int v5 = *(uint64_t (**)(uint64_t, const char *, void))(*(void *)v3 + 112);
      if (!v5) {
        return result;
      }
      uint64_t v6 = *(void *)(v3 + 8);
      int v7 = "head";
LABEL_22:
      return v5(v6, v7, 0);
    }
  }
  uint64_t result = xmlStrEqual(str1, (const xmlChar *)"noframes");
  if (result) {
    return result;
  }
  uint64_t result = xmlStrEqual(str1, (const xmlChar *)"frame");
  if (result) {
    return result;
  }
  uint64_t result = xmlStrEqual(str1, (const xmlChar *)"frameset");
  if (result || *(int *)(v3 + 52) > 9) {
    return result;
  }
  if (*(int *)(v3 + 296) < 1)
  {
LABEL_34:
    uint64_t result = (uint64_t)htmlnamePush(v3, (xmlChar *)"body");
    if (!*(void *)v3) {
      return result;
    }
    int v5 = *(uint64_t (**)(uint64_t, const char *, void))(*(void *)v3 + 112);
    if (!v5) {
      return result;
    }
    uint64_t v6 = *(void *)(v3 + 8);
    int v7 = "body";
    goto LABEL_22;
  }
  uint64_t v8 = 0;
  while (1)
  {
    uint64_t result = xmlStrEqual(*(const xmlChar **)(*(void *)(v3 + 304) + 8 * v8), (const xmlChar *)"body");
    if (result) {
      return result;
    }
    uint64_t result = xmlStrEqual(*(const xmlChar **)(*(void *)(v3 + 304) + 8 * v8), (const xmlChar *)"head");
    if (result) {
      return result;
    }
    if (++v8 >= *(int *)(v3 + 296)) {
      goto LABEL_34;
    }
  }
}

int *htmlAutoClose(int *result, uint64_t a2)
{
  uint64_t v2 = result;
  if (a2)
  {
    for (uint64_t i = *((void *)result + 36); i; uint64_t i = *((void *)v2 + 36))
    {
      v10[0] = i;
      v10[1] = a2;
      uint64_t result = (int *)bsearch(v10, htmlStartClose, 0xFBuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))htmlCompareStartClose);
      if (!result) {
        break;
      }
      if (*(void *)v2)
      {
        int v5 = *(uint64_t (**)(void, void))(*(void *)v2 + 120);
        if (v5) {
          uint64_t result = (int *)v5(*((void *)v2 + 1), *((void *)v2 + 36));
        }
      }
      int v6 = v2[74];
      unsigned int v7 = v6 - 1;
      if (v6 >= 1)
      {
        v2[74] = v7;
        uint64_t v8 = *((void *)v2 + 38);
        if (v6 == 1) {
          uint64_t v9 = 0;
        }
        else {
          uint64_t v9 = *(void *)(v8 + 8 * (v6 - 2));
        }
        *((void *)v2 + 36) = v9;
        *(void *)(v8 + 8 * v7) = 0;
      }
    }
  }
  else
  {
    return (int *)htmlAutoCloseOnEnd((uint64_t)result);
  }
  return result;
}

int htmlParseDocument(htmlParserCtxtPtr ctxt)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  xmlInitParser();
  htmlDefaultSAXHandlerInit();
  if (ctxt && (xmlParserInputPtr input = ctxt->input) != 0)
  {
    ctxt->html = 1;
    ctxt->linenumbers = 1;
    if (!ctxt->progressive && input->end - input->cur <= 249) {
      xmlParserInputGrow(input, 250);
    }
    if (ctxt->sax)
    {
      setDocumentLocatorSAXFunc setDocumentLocator = ctxt->sax->setDocumentLocator;
      if (setDocumentLocator)
      {
        userData = ctxt->userData;
        int v5 = __xmlDefaultSAXLocator();
        ((void (*)(void *, xmlSAXLocator *))setDocumentLocator)(userData, v5);
      }
    }
    *(_DWORD *)in = 0;
    if (!ctxt->encoding)
    {
      cur = ctxt->input->cur;
      if (ctxt->input->end - cur >= 4)
      {
        char v7 = ctxt->token ? -1 : *cur;
        in[0] = v7;
        in[1] = cur[1];
        in[2] = cur[2];
        in[3] = cur[3];
        xmlCharEncoding v9 = xmlDetectCharEncoding(in, 4);
        if (v9)
        {
          if (xmlSwitchEncoding(ctxt, v9) < 0)
          {
            *(void *)__str = 0;
            memset(v21, 0, 11);
            snprintf(__str, 0x14uLL, "0x%02X 0x%02X 0x%02X 0x%02X", in[0], in[1], in[2], in[3]);
            v21[11] = 0;
            if (ctxt->errNo) {
              int errNo = ctxt->errNo;
            }
            else {
              int errNo = 6003;
            }
            htmlParseErr(ctxt, errNo, "htmlCheckEncoding: error switching to encoding, bytes %s\n", (const xmlChar *)__str, 0);
          }
        }
      }
    }
    htmlSkipBlankChars((uint64_t)ctxt);
    if (!*ctxt->input->cur) {
      htmlParseErr(ctxt, 4, "Document is empty\n", 0, 0);
    }
    if (ctxt->sax)
    {
      startDocumentSAXFunc startDocument = ctxt->sax->startDocument;
      if (startDocument)
      {
        if (!ctxt->disableSAX) {
          ((void (*)(void *))startDocument)(ctxt->userData);
        }
      }
    }
    while (1)
    {
      uint64_t v12 = ctxt->input->cur;
      if (*v12 != 60) {
        break;
      }
      int v13 = v12[1];
      if (v13 != 63)
      {
        if (v13 != 33) {
          break;
        }
        if (v12[2] != 45 || v12[3] != 45)
        {
          if (__toupper(v12[2]) == 68
            && __toupper(v12[3]) == 79
            && __toupper(v12[4]) == 67
            && __toupper(v12[5]) == 84
            && __toupper(v12[6]) == 89
            && __toupper(v12[7]) == 80
            && __toupper(v12[8]) == 69)
          {
            htmlParseDocTypeDecl(ctxt);
          }
          break;
        }
      }
      htmlParseComment((uint64_t)ctxt);
      htmlParsePI((uint64_t)ctxt);
      htmlSkipBlankChars((uint64_t)ctxt);
    }
    while (1)
    {
      htmlSkipBlankChars((uint64_t)ctxt);
      uint64_t v15 = ctxt->input->cur;
      if (*v15 != 60) {
        break;
      }
      int v14 = v15[1];
      if (v14 != 63 && (v14 != 33 || v15[2] != 45 || v15[3] != 45)) {
        break;
      }
      htmlParseComment((uint64_t)ctxt);
      htmlParsePI((uint64_t)ctxt);
    }
    htmlParseContentInternal((uint64_t)ctxt);
    if (!*ctxt->input->cur) {
      htmlAutoCloseOnEnd((uint64_t)ctxt);
    }
    if (ctxt->sax)
    {
      endDocumentSAXFunc endDocument = ctxt->sax->endDocument;
      if (endDocument) {
        ((void (*)(void *))endDocument)(ctxt->userData);
      }
    }
    if ((ctxt->options & 4) == 0)
    {
      myDoc = ctxt->myDoc;
      if (myDoc)
      {
        if (!xmlGetIntSubset(myDoc)) {
          ctxt->myDoc->intSubset = xmlCreateIntSubset(ctxt->myDoc, (const xmlChar *)"html", (const xmlChar *)"-//W3C//DTD HTML 4.0 Transitional//EN", (const xmlChar *)"http://www.w3.org/TR/REC-html40/loose.dtd");
        }
      }
    }
    if (ctxt->wellFormed) {
      return 0;
    }
    else {
      return -1;
    }
  }
  else
  {
    int v8 = 1;
    htmlParseErr(ctxt, 1, "htmlParseDocument: context error\n", 0, 0);
  }
  return v8;
}

xmlParserInput *htmlSkipBlankChars(uint64_t a1)
{
  while (1)
  {
    uint64_t result = *(xmlParserInput **)(a1 + 56);
    cur = result->cur;
    unsigned int v4 = *cur;
    if (v4 > 0xC) {
      break;
    }
    if (v4 == 9) {
      goto LABEL_7;
    }
    if (v4 != 10) {
      return result;
    }
    ++result->line;
    result->col = 1;
LABEL_8:
    result->cur = cur + 1;
    if (!cur[1]) {
      xmlParserInputGrow(result, 250);
    }
  }
  if (v4 == 13 || v4 == 32)
  {
LABEL_7:
    ++result->col;
    goto LABEL_8;
  }
  return result;
}

uint64_t htmlAutoCloseOnEnd(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 296);
  if (v1 >= 1)
  {
    uint64_t v2 = result;
    unsigned int v3 = v1 + 1;
    do
    {
      if (*(void *)v2)
      {
        unsigned int v4 = *(uint64_t (**)(void, void))(*(void *)v2 + 120);
        if (v4)
        {
          uint64_t result = v4(*(void *)(v2 + 8), *(void *)(v2 + 288));
          int v1 = *(_DWORD *)(v2 + 296);
        }
      }
      unsigned int v5 = v1 - 1;
      if (v1 >= 1)
      {
        *(_DWORD *)(v2 + 296) = v5;
        uint64_t v6 = *(void *)(v2 + 304);
        if (v1 == 1) {
          uint64_t v7 = 0;
        }
        else {
          uint64_t v7 = *(void *)(v6 + 8 * (v1 - 2));
        }
        *(void *)(v2 + 288) = v7;
        *(void *)(v6 + 8 * v5) = 0;
        int v1 = v5;
      }
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

int xmlCopyCharMultiByte(xmlChar *out, int val)
{
  if (out)
  {
    if (val < 128)
    {
      *out = val;
      LODWORD(v5) = 1;
    }
    else
    {
      if (val >= 0x800)
      {
        if (val >= 0x10000)
        {
          if (val >= 0x110000)
          {
            __xmlRaiseError(0, 0, 0, 0, 0, 1u, 9, 3, 0, 0, 0, 0, 0, val, 0, "Internal error, xmlCopyCharMultiByte 0x%X out of bound\n", val);
            LODWORD(v5) = 0;
            return v5;
          }
          unsigned int v2 = 12;
          char v3 = -16;
          char v4 = 18;
        }
        else
        {
          unsigned int v2 = 6;
          char v3 = -32;
          char v4 = 12;
        }
      }
      else
      {
        unsigned int v2 = 0;
        char v3 = -64;
        char v4 = 6;
      }
      *out = v3 | (val >> v4);
      uint64_t v5 = 1;
      do
      {
        out[v5++] = (val >> v2) & 0x3F | 0x80;
        BOOL v6 = v2 > 5;
        v2 -= 6;
      }
      while (v6);
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  return v5;
}

uint64_t htmlParseStartTag(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  if (!v2)
  {
    htmlParseErr((_DWORD *)a1, 1, "htmlParseStartTag: context error\n", 0, 0);
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(a1 + 272) == -1 || **(unsigned char **)(v2 + 32) != 60) {
    return 0xFFFFFFFFLL;
  }
  xmlNextChar((xmlParserCtxtPtr)a1);
  char v3 = *(const xmlChar ***)(a1 + 464);
  int v4 = *(_DWORD *)(a1 + 472);
  if (!*(_DWORD *)(a1 + 452))
  {
    uint64_t v5 = *(xmlParserInput **)(a1 + 56);
    if (v5->end - v5->cur <= 249) {
      xmlParserInputGrow(v5, 250);
    }
  }
  BOOL v6 = htmlParseHTMLName((xmlParserCtxtPtr)a1);
  if (!v6)
  {
    htmlParseErr((_DWORD *)a1, 68, "htmlParseStartTag: invalid element name\n", 0, 0);
    uint64_t v9 = 0xFFFFFFFFLL;
    while (1)
    {
      if (!**(unsigned char **)(*(void *)(a1 + 56) + 32) || **(unsigned char **)(*(void *)(a1 + 56) + 32) == 62) {
        return v9;
      }
      if (*(_DWORD *)(a1 + 272) == -1) {
        break;
      }
      xmlNextChar((xmlParserCtxtPtr)a1);
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = (xmlChar *)v6;
  int v8 = xmlStrEqual(v6, (const xmlChar *)"meta");
  htmlAutoClose((int *)a1, (uint64_t)v7);
  htmlCheckImplied(a1, v7);
  if (*(int *)(a1 + 296) < 1)
  {
    uint64_t v9 = 0;
    goto LABEL_22;
  }
  if (xmlStrEqual(v7, (const xmlChar *)"html"))
  {
    htmlParseErr((_DWORD *)a1, 800, "htmlParseStartTag: misplaced <html> tag\n", v7, 0);
    ++*(_DWORD *)(a1 + 392);
    uint64_t v9 = 1;
  }
  else
  {
    uint64_t v9 = 0;
  }
  if (*(_DWORD *)(a1 + 296) != 1)
  {
LABEL_22:
    if (xmlStrEqual(v7, (const xmlChar *)"head"))
    {
      htmlParseErr((_DWORD *)a1, 800, "htmlParseStartTag: misplaced <head> tag\n", v7, 0);
      ++*(_DWORD *)(a1 + 392);
      uint64_t v9 = 1;
    }
  }
  int v38 = v8;
  if (xmlStrEqual(v7, (const xmlChar *)"body") && *(int *)(a1 + 296) >= 1)
  {
    uint64_t v11 = 0;
    do
    {
      if (xmlStrEqual(*(const xmlChar **)(*(void *)(a1 + 304) + 8 * v11), (const xmlChar *)"body"))
      {
        htmlParseErr((_DWORD *)a1, 800, "htmlParseStartTag: misplaced <body> tag\n", v7, 0);
        ++*(_DWORD *)(a1 + 392);
        uint64_t v9 = 1;
      }
      ++v11;
    }
    while (v11 < *(int *)(a1 + 296));
  }
  str1 = v7;
  htmlSkipBlankChars(a1);
  LODWORD(v12) = 0;
  while (1)
  {
    int v13 = *(xmlParserInput **)(a1 + 56);
    cur = v13->cur;
    int v15 = *cur;
    if (v15 == 47)
    {
      int v15 = cur[1];
    }
    else if (!*cur)
    {
      break;
    }
    if (v15 == 62) {
      break;
    }
    if (!*(_DWORD *)(a1 + 452) && v13->end - cur <= 249) {
      xmlParserInputGrow(v13, 250);
    }
    uint64_t v16 = htmlParseHTMLName((xmlParserCtxtPtr)a1);
    if (!v16)
    {
      htmlParseErr((_DWORD *)a1, 68, "error parsing attribute name\n", 0, 0);
      while (1)
      {
        unsigned int v23 = *(unsigned __int8 **)(*(void *)(a1 + 56) + 32);
        int v24 = *v23;
        if ((v24 | 0x20) == 0x20 || (v24 - 9) < 2) {
          goto LABEL_77;
        }
        switch(v24)
        {
          case 47:
            int v24 = v23[1];
            break;
          case 13:
            goto LABEL_77;
          case 62:
            goto LABEL_77;
        }
        xmlNextChar((xmlParserCtxtPtr)a1);
      }
    }
    xmlNodePtr v17 = v16;
    htmlSkipBlankChars(a1);
    if (**(unsigned char **)(*(void *)(a1 + 56) + 32) != 61)
    {
      uint64_t v19 = 0;
      goto LABEL_61;
    }
    xmlNextChar((xmlParserCtxtPtr)a1);
    htmlSkipBlankChars(a1);
    int v18 = **(unsigned __int8 **)(*(void *)(a1 + 56) + 32);
    if (v18 == 39)
    {
      xmlNextChar((xmlParserCtxtPtr)a1);
      uint64_t v19 = htmlParseHTMLAttribute(a1, 39);
      if (**(unsigned char **)(*(void *)(a1 + 56) + 32) == 39)
      {
LABEL_56:
        xmlNextChar((xmlParserCtxtPtr)a1);
        goto LABEL_61;
      }
      long long v20 = (_DWORD *)a1;
      int v21 = 40;
      uint64_t v22 = "AttValue: ' expected\n";
    }
    else if (v18 == 34)
    {
      xmlNextChar((xmlParserCtxtPtr)a1);
      uint64_t v19 = htmlParseHTMLAttribute(a1, 34);
      if (**(unsigned char **)(*(void *)(a1 + 56) + 32) == 34) {
        goto LABEL_56;
      }
      long long v20 = (_DWORD *)a1;
      int v21 = 40;
      uint64_t v22 = "AttValue: \" expected\n";
    }
    else
    {
      uint64_t v19 = htmlParseHTMLAttribute(a1, 0);
      if (v19) {
        goto LABEL_61;
      }
      long long v20 = (_DWORD *)a1;
      int v21 = 41;
      uint64_t v22 = "AttValue: no value found\n";
    }
    htmlParseErr(v20, v21, v22, 0, 0);
LABEL_61:
    if ((int)v12 < 1)
    {
      if (v3)
      {
LABEL_67:
        if ((int)v12 + 4 <= v4) {
          goto LABEL_76;
        }
        v4 *= 2;
        int v26 = (const xmlChar **)xmlRealloc(v3, 8 * v4);
        if (v26) {
          goto LABEL_75;
        }
        htmlErrMemory((_DWORD *)a1, 0);
        if (v19) {
          goto LABEL_72;
        }
      }
      else
      {
        int v26 = (const xmlChar **)xmlMalloc(0xB0uLL);
        if (v26)
        {
          int v4 = 22;
LABEL_75:
          *(void *)(a1 + 464) = v26;
          *(_DWORD *)(a1 + 472) = v4;
          char v3 = v26;
LABEL_76:
          int v27 = &v3[(int)v12];
          *int v27 = v17;
          v27[1] = v19;
          uint64_t v12 = (int)v12 + 2;
          v3[v12] = 0;
          v27[3] = 0;
          goto LABEL_77;
        }
        htmlErrMemory((_DWORD *)a1, 0);
        if (v19) {
          xmlFree(v19);
        }
        char v3 = 0;
        int v4 = 22;
      }
    }
    else
    {
      uint64_t v25 = 0;
      while (!xmlStrEqual(v3[v25], v17))
      {
        v25 += 2;
        if ((int)v12 <= (int)v25) {
          goto LABEL_67;
        }
      }
      htmlParseErr((_DWORD *)a1, 42, "Attribute %s redefined\n", v17, 0);
      if (v19) {
LABEL_72:
      }
        xmlFree(v19);
    }
LABEL_77:
    htmlSkipBlankChars(a1);
  }
  if (v38)
  {
    if (v12)
    {
      if (v3)
      {
        unsigned int v28 = *v3;
        if (*v3)
        {
          uint64_t v29 = 0;
          int v39 = 0;
          __int16 v30 = v3 + 2;
          do
          {
            uint64_t v31 = (xmlChar *)*(v30 - 1);
            if (v31)
            {
              if (xmlStrcasecmp(v28, (const xmlChar *)"http-equiv")
                || xmlStrcasecmp(v31, (const xmlChar *)"Content-Type"))
              {
                if (xmlStrcasecmp(v28, (const xmlChar *)"charset"))
                {
                  if (!xmlStrcasecmp(v28, (const xmlChar *)"content")) {
                    uint64_t v29 = v31;
                  }
                }
                else
                {
                  htmlCheckEncodingDirect(a1, v31);
                }
              }
              else
              {
                int v39 = 1;
              }
            }
            uint64_t v32 = *v30;
            v30 += 2;
            unsigned int v28 = v32;
          }
          while (v32);
          if (v39 && v29) {
            htmlCheckEncoding(a1, v29);
          }
        }
      }
    }
  }
  if (!v9
    && (htmlnamePush(a1, str1), *(void *)a1)
    && (uint64_t v35 = *(void (**)(uint64_t, xmlChar *, const xmlChar **))(*(void *)a1 + 112)) != 0)
  {
    uint64_t v36 = *(void *)(a1 + 8);
    if (v12)
    {
      v35(v36, str1, v3);
      goto LABEL_100;
    }
    v35(v36, str1, 0);
    return 0;
  }
  else
  {
LABEL_100:
    if (v3 && (int)v12 >= 2)
    {
      uint64_t v33 = 1;
      do
      {
        long long v34 = (xmlChar *)v3[v33];
        if (v34) {
          xmlFree(v34);
        }
        v33 += 2;
      }
      while ((int)v12 > (int)v33);
    }
  }
  return v9;
}

const xmlChar *htmlParseHTMLName_nonInvasive(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  int v10 = 0;
  memset(v9, 0, sizeof(v9));
  uint64_t v1 = *(void *)(*(void *)(a1 + 56) + 32);
  int v2 = *(unsigned __int8 *)(v1 + 1);
  if ((v2 & 0xFFFFFFDF) - 65 < 0x1A || v2 == 95 || v2 == 58)
  {
    uint64_t v3 = 0;
    uint64_t v4 = v1 + 1;
    while (1)
    {
      int v5 = *(unsigned __int8 *)(v4 + v3);
      if ((v5 - 65) >= 0x1A)
      {
        if ((v5 - 97) >= 0x1A
          && (v5 - 48) >= 0xA
          && ((v5 - 45) > 0x32 || ((1 << (v5 - 45)) & 0x4000000002001) == 0))
        {
          return xmlDictLookup(*(xmlDictPtr *)(a1 + 456), (const xmlChar *)v9, v3);
        }
      }
      else
      {
        LOBYTE(v5) = v5 + 32;
      }
      *((unsigned char *)v9 + v3++) = v5;
      if (v3 == 100) {
        return xmlDictLookup(*(xmlDictPtr *)(a1 + 456), (const xmlChar *)v9, v3);
      }
    }
  }
  return 0;
}

const xmlChar *htmlParseHTMLName(xmlParserCtxtPtr ctxt)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  int v13 = 0;
  memset(v12, 0, sizeof(v12));
  int v2 = *ctxt->input->cur;
  if ((v2 & 0xFFFFFFDF) - 65 < 0x1A
    || ((v3 = v2 - 46, v4 = v3 > 0x31, uint64_t v5 = (1 << v3) & 0x2000000001001, !v4) ? (v6 = v5 == 0) : (v6 = 1), !v6))
  {
    uint64_t v7 = 0;
    while (1)
    {
      int v8 = *ctxt->input->cur;
      if ((v8 - 65) >= 0x1A)
      {
        if ((v8 - 97) >= 0x1A
          && (v8 - 48) >= 0xA
          && ((v8 - 45) > 0x32 || ((1 << (v8 - 45)) & 0x4000000002003) == 0))
        {
          return xmlDictLookup(ctxt->dict, (const xmlChar *)v12, v7);
        }
      }
      else
      {
        LOBYTE(v8) = v8 + 32;
      }
      *((unsigned char *)v12 + v7++) = v8;
      xmlNextChar(ctxt);
      if (v7 == 100) {
        return xmlDictLookup(ctxt->dict, (const xmlChar *)v12, v7);
      }
    }
  }
  return 0;
}

uint64_t htmlParseReference(uint64_t ctxt)
{
  __int16 v21 = 0;
  int v20 = 0;
  str = 0;
  uint64_t v1 = *(unsigned char **)(*(void *)(ctxt + 56) + 32);
  if (*v1 != 38) {
    return ctxt;
  }
  int v2 = (void *)ctxt;
  if (v1[1] == 35)
  {
    ctxt = htmlParseCharRef((htmlParserCtxtPtr)ctxt);
    if (!ctxt) {
      return ctxt;
    }
    if (ctxt >= 0x80)
    {
      if (ctxt > 0x7FF)
      {
        if (WORD1(ctxt))
        {
          LOBYTE(v20) = (ctxt >> 18) & 7 | 0xF0;
          unsigned int v3 = 12;
        }
        else
        {
          LOBYTE(v20) = (ctxt >> 12) | 0xE0;
          unsigned int v3 = 6;
        }
      }
      else
      {
        unsigned int v3 = 0;
        LOBYTE(v20) = (ctxt >> 6) | 0xC0;
      }
      uint64_t v17 = 1;
      do
      {
        *((unsigned char *)&v20 + v17++) = (ctxt >> v3) & 0x3F | 0x80;
        BOOL v18 = v3 > 5;
        v3 -= 6;
      }
      while (v18);
      goto LABEL_33;
    }
    LOBYTE(v20) = ctxt;
    goto LABEL_23;
  }
  BOOL v4 = htmlParseEntityRef((htmlParserCtxtPtr)ctxt, (const xmlChar **)&str);
  if (str)
  {
    if (!v4 || (unsigned int value = v4->value) == 0)
    {
      ctxt = htmlCheckParagraph((uint64_t)v2);
      if (*v2)
      {
        uint64_t v7 = *(void (**)(void, const char *, uint64_t))(*v2 + 136);
        if (v7)
        {
          v7(v2[1], "&", 1);
          uint64_t v8 = *v2;
          uint64_t v9 = v2[1];
          int v10 = *(uint64_t (**)(uint64_t, xmlChar *, uint64_t))(v8 + 136);
          uint64_t v11 = str;
          uint64_t v12 = xmlStrlen(str);
          return v10(v9, v11, v12);
        }
      }
      return ctxt;
    }
    if (value >= 0x80)
    {
      if (value > 0x7FF)
      {
        if (HIWORD(value))
        {
          LOBYTE(v20) = (value >> 18) & 7 | 0xF0;
          unsigned int v6 = 12;
        }
        else
        {
          LOBYTE(v20) = (value >> 12) | 0xE0;
          unsigned int v6 = 6;
        }
      }
      else
      {
        unsigned int v6 = 0;
        LOBYTE(v20) = (value >> 6) | 0xC0;
      }
      uint64_t v17 = 1;
      do
      {
        *((unsigned char *)&v20 + v17++) = (value >> v6) & 0x3F | 0x80;
        BOOL v18 = v6 > 5;
        v6 -= 6;
      }
      while (v18);
LABEL_33:
      *((unsigned char *)&v20 + v17) = 0;
      ctxt = htmlCheckParagraph((uint64_t)v2);
      if (*v2)
      {
        int v13 = *(uint64_t (**)(uint64_t, const char *, uint64_t))(*v2 + 136);
        if (v13)
        {
          uint64_t v14 = v2[1];
          int v15 = (const char *)&v20;
          uint64_t v16 = v17;
          return v13(v14, v15, v16);
        }
      }
      return ctxt;
    }
    LOBYTE(v20) = v4->value;
LABEL_23:
    uint64_t v17 = 1;
    goto LABEL_33;
  }
  ctxt = htmlCheckParagraph((uint64_t)v2);
  if (*v2)
  {
    int v13 = *(uint64_t (**)(uint64_t, const char *, uint64_t))(*v2 + 136);
    if (v13)
    {
      uint64_t v14 = v2[1];
      int v15 = "&";
      uint64_t v16 = 1;
      return v13(v14, v15, v16);
    }
  }
  return ctxt;
}

xmlMutexPtr _xmlInitGlobalsOnce()
{
  xmlMutexPtr result = xmlNewMutex();
  xmlThrDefMutex = (uint64_t)result;
  return result;
}

void _xmlInitializeDictMutex()
{
  xmlDictMutex = (uint64_t)xmlNewRMutex();
  xmlRMutexLock((xmlRMutexPtr)xmlDictMutex);
  rand_seed = time(0);
  rand_r((unsigned int *)&rand_seed);
  v0 = (xmlRMutex *)xmlDictMutex;

  xmlRMutexUnlock(v0);
}

xmlRMutexPtr xmlNewRMutex(void)
{
  v0 = (pthread_mutex_t *)malloc_type_malloc(0x80uLL, 0x1020040C717CFCDuLL);
  uint64_t v1 = v0;
  if (v0)
  {
    pthread_mutex_init(v0, 0);
    v1[1].__sig = 0;
    pthread_cond_init((pthread_cond_t *)&v1[1].__opaque[8], 0);
  }
  return (xmlRMutexPtr)v1;
}

htmlParserCtxtPtr htmlNewParserCtxt(void)
{
  v0 = (xmlParserCtxt *)xmlMalloc(0x2F0uLL);
  uint64_t v1 = v0;
  if (!v0)
  {
    htmlErrMemory(0, (const xmlChar *)"NewParserCtxt: out of memory\n");
    return v1;
  }
  bzero(v0, 0x2F0uLL);
  bzero(v1, 0x2F0uLL);
  int v2 = xmlDictCreate();
  v1->dict = v2;
  if (!v2 || (int v2 = (xmlDict *)xmlMalloc(0x100uLL)) == 0)
  {
    htmlErrMemory(v2, (const xmlChar *)"htmlInitParserCtxt: out of memory\n");
LABEL_9:
    xmlFreeParserCtxt(v1);
    return 0;
  }
  unsigned int v3 = (_xmlSAXHandler *)v2;
  *((_OWORD *)v2 + 14) = 0u;
  *((_OWORD *)v2 + 15) = 0u;
  *((_OWORD *)v2 + 12) = 0u;
  *((_OWORD *)v2 + 13) = 0u;
  *((_OWORD *)v2 + 10) = 0u;
  *((_OWORD *)v2 + 11) = 0u;
  *((_OWORD *)v2 + 8) = 0u;
  *((_OWORD *)v2 + 9) = 0u;
  *((_OWORD *)v2 + 6) = 0u;
  *((_OWORD *)v2 + 7) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *((_OWORD *)v2 + 5) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *(_OWORD *)int v2 = 0u;
  *((_OWORD *)v2 + 1) = 0u;
  BOOL v4 = (xmlParserInputPtr *)xmlMalloc(0x28uLL);
  v1->inputTab = v4;
  if (!v4)
  {
    htmlErrMemory(0, (const xmlChar *)"htmlInitParserCtxt: out of memory\n");
    v1->xmlParserInputPtr input = 0;
    *(void *)&v1->inputNr = 0;
    goto LABEL_9;
  }
  v1->xmlParserInputPtr input = 0;
  p_xmlParserInputPtr input = &v1->input;
  *(void *)&v1->inputNr = 0x500000000;
  v1->version = 0;
  v1->encoding = 0;
  v1->standalone = -1;
  v1->xmlParserInputState instate = XML_PARSER_START;
  unsigned int v6 = (xmlNodePtr *)xmlMalloc(0x50uLL);
  v1->nodeTab = v6;
  if (!v6)
  {
    htmlErrMemory(0, (const xmlChar *)"htmlInitParserCtxt: out of memory\n");
    *p_xmlParserInputPtr input = 0;
    *(void *)&v1->inputNr = 0;
    v1->node = 0;
    *(void *)&v1->nodeNr = 0;
    goto LABEL_9;
  }
  v1->node = 0;
  *(void *)&v1->nodeNr = 0xA00000000;
  uint64_t v7 = (const xmlChar **)xmlMalloc(0x50uLL);
  v1->nameTab = v7;
  if (!v7)
  {
    htmlErrMemory(0, (const xmlChar *)"htmlInitParserCtxt: out of memory\n");
    *p_xmlParserInputPtr input = 0;
    *(void *)&v1->inputNr = 0;
    v1->node = 0;
    *(void *)&v1->nodeNr = 0;
    v1->name = 0;
    *(void *)&v1->nameNr = 0;
    goto LABEL_9;
  }
  *(void *)&v1->nameNr = 0xA00000000;
  v1->name = 0;
  *(_OWORD *)&v1->nodeInfoNr = 0u;
  v1->sax = v3;
  uint64_t v8 = __htmlDefaultSAXHandler();
  long long v9 = *(_OWORD *)&v8->hasInternalSubset;
  *(_OWORD *)&v3->internalSubset = *(_OWORD *)&v8->internalSubset;
  *(_OWORD *)&v3->hasInternalSubset = v9;
  long long v10 = *(_OWORD *)&v8->unparsedEntityDecl;
  long long v12 = *(_OWORD *)&v8->resolveEntity;
  long long v11 = *(_OWORD *)&v8->entityDecl;
  *(_OWORD *)&v3->attributeDecl = *(_OWORD *)&v8->attributeDecl;
  *(_OWORD *)&v3->unparsedEntityDecl = v10;
  *(_OWORD *)&v3->resolveEntity = v12;
  *(_OWORD *)&v3->entityDecl = v11;
  long long v13 = *(_OWORD *)&v8->ignorableWhitespace;
  long long v15 = *(_OWORD *)&v8->startDocument;
  long long v14 = *(_OWORD *)&v8->startElement;
  *(_OWORD *)&v3->reference = *(_OWORD *)&v8->reference;
  *(_OWORD *)&v3->ignorableWhitespace = v13;
  *(_OWORD *)&v3->startDocumentSAXFunc startDocument = v15;
  *(_OWORD *)&v3->startElement = v14;
  long long v16 = *(_OWORD *)&v8->externalSubset;
  long long v18 = *(_OWORD *)&v8->comment;
  long long v17 = *(_OWORD *)&v8->error;
  *(_OWORD *)&v3->getParameterEntity = *(_OWORD *)&v8->getParameterEntity;
  *(_OWORD *)&v3->externalSubset = v16;
  *(_OWORD *)&v3->comment = v18;
  *(_OWORD *)&v3->error = v17;
  v1->userData = v1;
  v1->myDoc = 0;
  *(void *)&v1->wellFormed = 1;
  v1->linenumbers = *__xmlLineNumbersDefaultValue();
  v1->keepBlanks = *__xmlKeepBlanksDefaultValue();
  v1->html = 1;
  v1->vctxt.finishDtd = -1412623820;
  v1->vctxt.userData = v1;
  v1->vctxt.error = xmlParserValidityError;
  v1->vctxt.warning = xmlParserValidityWarning;
  v1->record_info = 0;
  v1->validate = 0;
  v1->checkIndex = 0;
  v1->catalogs = 0;
  xmlInitNodeInfoSeq(&v1->node_seq);
  return v1;
}

htmlParserCtxtPtr htmlCreateMemoryParserCtxt(const char *buffer, int size)
{
  int v2 = 0;
  if (buffer)
  {
    if (size >= 1)
    {
      int v2 = htmlNewParserCtxt();
      if (v2)
      {
        xmlParserInputBufferPtr Mem = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
        if (Mem)
        {
          xmlParserInputBufferPtr v6 = Mem;
          xmlParserInputPtr v7 = xmlNewInputStream(v2);
          if (v7)
          {
            uint64_t v8 = v7;
            v7->buf = v6;
            v7->filename = 0;
            xmlBufResetInput((uint64_t *)v6->buffer, v7);
            inputPush(v2, v8);
            return v2;
          }
          xmlFreeParserInputBuffer(v6);
          xmlFreeParserCtxt(v2);
        }
        return 0;
      }
    }
  }
  return v2;
}

xmlDocPtr xmlReadMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)
{
  uint64_t v5 = *(void *)&options;
  xmlInitParser();
  xmlDocPtr result = (xmlDocPtr)xmlCreateMemoryParserCtxt(buffer, size);
  if (result)
  {
    return xmlDoRead((xmlParserCtxt *)result, (const xmlChar *)URL, (xmlChar *)encoding, v5, 0);
  }
  return result;
}

xmlParserCtxtPtr xmlCreateMemoryParserCtxt(const char *buffer, int size)
{
  int v2 = 0;
  if (buffer)
  {
    if (size >= 1)
    {
      int v2 = xmlNewParserCtxt();
      if (v2)
      {
        xmlParserInputBufferPtr Mem = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
        if (Mem)
        {
          xmlParserInputBufferPtr v6 = Mem;
          xmlParserInputPtr v7 = xmlNewInputStream(v2);
          if (v7)
          {
            uint64_t v8 = v7;
            v7->buf = v6;
            v7->filename = 0;
            xmlBufResetInput((uint64_t *)v6->buffer, v7);
            inputPush(v2, v8);
            return v2;
          }
          xmlFreeParserInputBuffer(v6);
        }
        xmlFreeParserCtxt(v2);
        return 0;
      }
    }
  }
  return v2;
}

xmlParserInputPtr xmlNewInputStream(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr result = (xmlParserInputPtr)xmlMalloc(0x68uLL);
  if (!result)
  {
    unsigned int v3 = "couldn't allocate a new input stream\n";
    goto LABEL_6;
  }
  *(void *)&result->standalone = 0;
  *(_OWORD *)&result->consumed = 0u;
  *(_OWORD *)&result->encoding = 0u;
  *(_OWORD *)&result->cur = 0u;
  *(_OWORD *)&result->length = 0u;
  *(_OWORD *)&result->buf = 0u;
  *(_OWORD *)&result->directory = 0u;
  *(void *)&result->line = 0x100000001;
  result->standalone = -1;
  if (!ctxt) {
    return result;
  }
  if (result->id == 0x7FFFFFFF)
  {
    unsigned int v3 = "Input ID overflow\n";
LABEL_6:
    htmlErrMemory(ctxt, (const xmlChar *)v3);
    return 0;
  }
  input_int id = ctxt->input_id;
  ctxt->input_int id = input_id + 1;
  result->int id = input_id;
  return result;
}

uint64_t xmlBufResetInput(uint64_t *a1, void *a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  if (!a1 || *((_DWORD *)a1 + 14))
  {
    a2[4] = "";
    a2[5] = "";
    a2[3] = "";
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *((unsigned int *)a1 + 3);
  if (v4 <= 0x7FFFFFFE && a1[5] != v4) {
    a1[5] = v4;
  }
  uint64_t v6 = a1[4];
  uint64_t v7 = *((unsigned int *)a1 + 2);
  if (v7 <= 0x7FFFFFFE && v6 != v7)
  {
    a1[4] = v7;
    uint64_t v6 = v7;
  }
  uint64_t v2 = 0;
  uint64_t v8 = *a1;
  a2[3] = *a1;
  a2[4] = v8;
  a2[5] = v8 + v6;
  return v2;
}

int inputPush(xmlParserCtxtPtr ctxt, xmlParserInputPtr value)
{
  int result = -1;
  if (ctxt && value)
  {
    int result = ctxt->inputNr;
    uint64_t inputMax = ctxt->inputMax;
    if (result < (int)inputMax)
    {
      inputTab = ctxt->inputTab;
LABEL_7:
      inputTab[result] = value;
      ctxt->xmlParserInputPtr input = value;
      ctxt->inputNr = result + 1;
      return result;
    }
    uint64_t v7 = (xmlParserInputPtr *)xmlRealloc(ctxt->inputTab, 16 * inputMax);
    if (v7)
    {
      inputTab = v7;
      ctxt->inputTab = v7;
      ctxt->uint64_t inputMax = 2 * inputMax;
      int result = ctxt->inputNr;
      goto LABEL_7;
    }
    htmlErrMemory(ctxt, 0);
    return -1;
  }
  return result;
}

xmlParserInputBufferPtr xmlParserInputBufferCreateMem(const char *mem, int size, xmlCharEncoding enc)
{
  unsigned int v3 = 0;
  if (mem)
  {
    size_t v4 = *(void *)&size;
    if ((size & 0x80000000) == 0)
    {
      xmlParserInputBufferPtr v6 = xmlAllocParserInputBuffer(enc);
      unsigned int v3 = v6;
      if (v6)
      {
        v6->context = (void *)mem;
        v6->xmlInputReadCallback readcallback = (xmlInputReadCallback)xmlInputReadCallbackNop;
        v6->closecallbacint k = 0;
        if (xmlBufAdd((uint64x2_t *)v6->buffer, (const xmlChar *)mem, v4))
        {
          xmlFree(v3);
          return 0;
        }
      }
    }
  }
  return v3;
}

xmlParserInputBufferPtr xmlAllocParserInputBuffer(xmlCharEncoding enc)
{
  uint64_t v2 = (xmlParserInputBuffer *)xmlMalloc(0x40uLL);
  unsigned int v3 = v2;
  if (v2)
  {
    *(_OWORD *)&v2->buffer = 0u;
    *(_OWORD *)&v2->compressed = 0u;
    *(_OWORD *)&v2->context = 0u;
    *(_OWORD *)&v2->closecallbacint k = 0u;
    size_t v4 = __xmlDefaultBufferSize();
    Size = (xmlBuf *)xmlBufCreateSize(2 * *v4);
    v3->buffer = Size;
    if (Size)
    {
      xmlBufSetAllocationScheme((uint64_t)Size, 0);
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlGetCharEncodingHandler(enc);
      v3->encoder = CharEncodingHandler;
      if (CharEncodingHandler)
      {
        uint64_t v7 = __xmlDefaultBufferSize();
        xmlCharEncodingHandlerPtr CharEncodingHandler = (xmlCharEncodingHandlerPtr)xmlBufCreateSize(2 * *v7);
      }
      v3->raw = (xmlBufPtr)CharEncodingHandler;
      v3->xmlInputReadCallback readcallback = 0;
      v3->closecallbacint k = 0;
      v3->context = 0;
      v3->compressed = -1;
      v3->rawconsumed = 0;
    }
    else
    {
      xmlFree(v3);
      return 0;
    }
  }
  else
  {
    __xmlSimpleError(8, 2, 0, 0, (uint64_t)"creating input buffer");
  }
  return v3;
}

uint64_t xmlBufSetAllocationScheme(uint64_t a1, unsigned int a2)
{
  if (!a1 || *(_DWORD *)(a1 + 56) || (*(_DWORD *)(a1 + 16) & 0xFFFFFFFE) == 2 || a2 > 5) {
    return 0xFFFFFFFFLL;
  }
  if (a2 == 3)
  {
    *(_DWORD *)(a1 + 16) = 3;
    *(void *)(a1 + 24) = *(void *)a1;
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 16) = a2;
  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t result = 0;
  if (v3) {
    *(_DWORD *)(v3 + 16) = a2;
  }
  return result;
}

int *__xmlDefaultBufferSize(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlDefaultBufferSize;
  }
  else {
    return &xmlGetGlobalState()->xmlDefaultBufferSize;
  }
}

xmlCharEncodingHandlerPtr xmlGetCharEncodingHandler(xmlCharEncoding enc)
{
  if (!handlers) {
    xmlInitCharEncodingHandlers();
  }
  xmlCharEncodingHandlerPtr result = 0;
  switch(enc)
  {
    case XML_CHAR_ENCODING_ERROR:
    case XML_CHAR_ENCODING_NONE:
    case XML_CHAR_ENCODING_UTF8:
      return result;
    case XML_CHAR_ENCODING_UTF16LE:
      return (xmlCharEncodingHandlerPtr)xmlUTF16LEHandler;
    case XML_CHAR_ENCODING_UTF16BE:
      return (xmlCharEncodingHandlerPtr)xmlUTF16BEHandler;
    case XML_CHAR_ENCODING_UCS4LE:
    case XML_CHAR_ENCODING_UCS4BE:
      xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler("ISO-10646-UCS-4");
      if (!result)
      {
        xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler("UCS-4");
        if (!result)
        {
          uint64_t v3 = "UCS4";
          goto LABEL_30;
        }
      }
      return result;
    case XML_CHAR_ENCODING_EBCDIC:
      xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler("EBCDIC");
      if (!result)
      {
        xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler("ebcdic");
        if (!result)
        {
          xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler("EBCDIC-US");
          if (!result)
          {
            uint64_t v3 = "IBM-037";
            goto LABEL_30;
          }
        }
      }
      return result;
    case XML_CHAR_ENCODING_UCS2:
      xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler("ISO-10646-UCS-2");
      if (!result)
      {
        xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler("UCS-2");
        if (!result)
        {
          uint64_t v3 = "UCS2";
          goto LABEL_30;
        }
      }
      return result;
    case XML_CHAR_ENCODING_8859_1:
      uint64_t v3 = "ISO-8859-1";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_2:
      uint64_t v3 = "ISO-8859-2";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_3:
      uint64_t v3 = "ISO-8859-3";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_4:
      uint64_t v3 = "ISO-8859-4";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_5:
      uint64_t v3 = "ISO-8859-5";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_6:
      uint64_t v3 = "ISO-8859-6";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_7:
      uint64_t v3 = "ISO-8859-7";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_8:
      uint64_t v3 = "ISO-8859-8";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_9:
      uint64_t v3 = "ISO-8859-9";
      goto LABEL_30;
    case XML_CHAR_ENCODING_2022_JP:
      uint64_t v3 = "ISO-2022-JP";
      goto LABEL_30;
    case XML_CHAR_ENCODING_SHIFT_JIS:
      xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler("SHIFT-JIS");
      if (result) {
        return result;
      }
      xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler("SHIFT_JIS");
      if (result) {
        return result;
      }
      uint64_t v3 = "Shift_JIS";
LABEL_30:
      xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler(v3);
      if (!result) {
        return 0;
      }
      return result;
    case XML_CHAR_ENCODING_EUC_JP:
      uint64_t v3 = "EUC-JP";
      goto LABEL_30;
    default:
      return 0;
  }
}

xmlParserCtxtPtr xmlNewParserCtxt(void)
{
  v0 = (xmlParserCtxt *)xmlMalloc(0x2F0uLL);
  uint64_t v1 = v0;
  if (v0)
  {
    bzero(v0, 0x2F0uLL);
    if (xmlInitParserCtxt(v1) < 0)
    {
      xmlFreeParserCtxt(v1);
      return 0;
    }
  }
  else
  {
    htmlErrMemory(0, (const xmlChar *)"cannot allocate parser context\n");
  }
  return v1;
}

xmlDocPtr xmlDoRead(xmlParserCtxt *a1, const xmlChar *a2, xmlChar *a3, uint64_t a4, int a5)
{
  xmlCtxtUseOptionsInternal((uint64_t *)a1, a4, a3);
  if (a3)
  {
    xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler((const char *)a3);
    if (CharEncodingHandler) {
      xmlSwitchToEncoding(a1, CharEncodingHandler);
    }
  }
  if (a2)
  {
    xmlParserInputPtr input = a1->input;
    if (input)
    {
      if (!input->filename) {
        a1->input->filename = (const char *)xmlStrdup(a2);
      }
    }
  }
  xmlParseDocument(a1);
  if (a1->wellFormed || a1->recovery)
  {
    xmlDocPtr myDoc = a1->myDoc;
  }
  else
  {
    long long v13 = a1->myDoc;
    if (v13) {
      xmlFreeDoc(v13);
    }
    xmlDocPtr myDoc = 0;
  }
  a1->xmlDocPtr myDoc = 0;
  if (!a5) {
    xmlFreeParserCtxt(a1);
  }
  return myDoc;
}

int xmlParseDocument(xmlParserCtxtPtr ctxt)
{
  xmlInitParser();
  if (!ctxt) {
    return -1;
  }
  xmlParserInputPtr input = ctxt->input;
  if (!input) {
    return -1;
  }
  if (!ctxt->progressive && input->end - input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  xmlDetectSAX2((const xmlChar *)ctxt);
  if (ctxt->sax)
  {
    setDocumentLocatorSAXFunc setDocumentLocator = ctxt->sax->setDocumentLocator;
    if (setDocumentLocator)
    {
      userData = ctxt->userData;
      uint64_t v5 = __xmlDefaultSAXLocator();
      ((void (*)(void *, xmlSAXLocator *))setDocumentLocator)(userData, v5);
    }
  }
  if (ctxt->instate == XML_PARSER_EOF) {
    return -1;
  }
  *(_DWORD *)in = 0;
  if (!ctxt->encoding)
  {
    cur = ctxt->input->cur;
    if (ctxt->input->end - cur >= 4)
    {
      *(_DWORD *)in = *(_DWORD *)cur;
      xmlCharEncoding v7 = xmlDetectCharEncoding(in, 4);
      if (v7) {
        xmlSwitchEncoding(ctxt, v7);
      }
    }
  }
  xmlParserInputPtr v8 = ctxt->input;
  long long v9 = v8->cur;
  int v10 = *v9;
  if (!*v9)
  {
    xmlFatalErr(ctxt, 4, 0);
    return -1;
  }
  if (v8->end - v9 <= 34 && !ctxt->progressive)
  {
    xmlGROW((uint64_t)ctxt);
    long long v9 = ctxt->input->cur;
    int v10 = *v9;
  }
  if (v10 == 60
    && v9[1] == 63
    && v9[2] == 120
    && v9[3] == 109
    && v9[4] == 108
    && (unsigned int v11 = v9[5], v11 <= 0x20)
    && ((1 << v11) & 0x100002600) != 0)
  {
    xmlParseXMLDecl(ctxt);
    if (ctxt->errNo == 32 || ctxt->instate == XML_PARSER_EOF) {
      return -1;
    }
    ctxt->standalone = ctxt->input->standalone;
    xmlSkipBlankChars(ctxt);
  }
  else
  {
    ctxt->version = xmlCharStrdup("1.0");
  }
  if (ctxt->sax)
  {
    startDocumentSAXFunc startDocument = ctxt->sax->startDocument;
    if (startDocument)
    {
      if (!ctxt->disableSAX) {
        ((void (*)(void *))startDocument)(ctxt->userData);
      }
    }
  }
  if (ctxt->instate == XML_PARSER_EOF) {
    return -1;
  }
  xmlDocPtr myDoc = ctxt->myDoc;
  if (myDoc)
  {
    xmlParserInputPtr v14 = ctxt->input;
    if (v14)
    {
      xmlParserInputBufferPtr buf = v14->buf;
      if (buf)
      {
        int compressed = buf->compressed;
        if ((compressed & 0x80000000) == 0) {
          myDoc->compression = compressed;
        }
      }
    }
  }
  xmlParseMisc(ctxt);
  xmlParserInputPtr v17 = ctxt->input;
  if (!ctxt->progressive && v17->end - v17->cur <= 249)
  {
    xmlGROW((uint64_t)ctxt);
    xmlParserInputPtr v17 = ctxt->input;
  }
  long long v18 = v17->cur;
  if (*v18 == 60
    && v18[1] == 33
    && v18[2] == 68
    && v18[3] == 79
    && v18[4] == 67
    && v18[5] == 84
    && v18[6] == 89
    && v18[7] == 80
    && v18[8] == 69)
  {
    ctxt->inSubset = 1;
    xmlParseDocTypeDecl(ctxt);
    if (*ctxt->input->cur == 91)
    {
      ctxt->xmlParserInputState instate = XML_PARSER_DTD;
      xmlParseInternalSubset((uint64_t)ctxt);
      if (ctxt->instate == XML_PARSER_EOF) {
        return -1;
      }
    }
    ctxt->inSubset = 2;
    if (ctxt->sax)
    {
      externalSubsetSAXFunc externalSubset = ctxt->sax->externalSubset;
      if (externalSubset)
      {
        if (!ctxt->disableSAX) {
          ((void (*)(void *, const xmlChar *, xmlChar *, xmlChar *))externalSubset)(ctxt->userData, ctxt->intSubName, ctxt->extSubSystem, ctxt->extSubURI);
        }
      }
    }
    if (ctxt->instate == XML_PARSER_EOF) {
      return -1;
    }
    ctxt->inSubset = 0;
    xmlCleanSpecialAttr(ctxt);
    ctxt->xmlParserInputState instate = XML_PARSER_PROLOG;
    xmlParseMisc(ctxt);
    xmlParserInputPtr v17 = ctxt->input;
  }
  if (!ctxt->progressive && v17->end - v17->cur <= 249)
  {
    xmlGROW((uint64_t)ctxt);
    xmlParserInputPtr v17 = ctxt->input;
  }
  if (*v17->cur == 60)
  {
    ctxt->xmlParserInputState instate = XML_PARSER_CONTENT;
    xmlParseElement(ctxt);
    ctxt->xmlParserInputState instate = XML_PARSER_EPILOG;
    xmlParseMisc(ctxt);
    if (*ctxt->input->cur) {
      xmlFatalErr(ctxt, 5, 0);
    }
    ctxt->xmlParserInputState instate = XML_PARSER_EOF;
  }
  else
  {
    xmlFatalErrMsg(ctxt, 4, (char)"Start tag expected, '<' not found\n");
  }
  if (ctxt->sax)
  {
    endDocumentSAXFunc endDocument = ctxt->sax->endDocument;
    if (endDocument) {
      ((void (*)(void *))endDocument)(ctxt->userData);
    }
  }
  xmlDocPtr v21 = ctxt->myDoc;
  if (v21 && xmlStrEqual(v21->version, (const xmlChar *)"SAX compatibility mode document"))
  {
    xmlFreeDoc(ctxt->myDoc);
    ctxt->xmlDocPtr myDoc = 0;
  }
  if (!ctxt->wellFormed)
  {
    ctxt->valint id = 0;
    return -1;
  }
  xmlDocPtr v22 = ctxt->myDoc;
  if (!v22) {
    return 0;
  }
  int properties = v22->properties;
  int v24 = properties | 1;
  v22->int properties = properties | 1;
  if (ctxt->valid)
  {
    int v24 = properties | 9;
    v22->int properties = properties | 9;
  }
  if (ctxt->nsWellFormed)
  {
    v24 |= 2u;
    v22->int properties = v24;
  }
  if ((ctxt->options & 0x20000) == 0) {
    return 0;
  }
  int result = 0;
  v22->int properties = v24 | 4;
  return result;
}

xmlChar *__cdecl xmlGetProp(const xmlNode *node, const xmlChar *name)
{
  int result = (xmlChar *)xmlHasProp(node, name);
  if (result)
  {
    return xmlGetPropNodeValueInternal((uint64_t)result);
  }
  return result;
}

xmlAttrPtr xmlHasProp(const xmlNode *node, const xmlChar *name)
{
  if (!node) {
    return 0;
  }
  int properties = 0;
  if (!name || node->type != XML_ELEMENT_NODE) {
    return properties;
  }
  int properties = node->properties;
  if (!properties)
  {
LABEL_7:
    doc = node->doc;
    if (doc)
    {
      intSubset = doc->intSubset;
      if (intSubset)
      {
        int properties = (xmlAttr *)xmlGetDtdAttrDesc(intSubset, node->name, name);
        if (properties
          || (extSubset = doc->extSubset) != 0
          && (int properties = (xmlAttr *)xmlGetDtdAttrDesc(extSubset, node->name, name)) != 0)
        {
          if (properties->psvi) {
            return properties;
          }
        }
      }
    }
    return 0;
  }
  while (!xmlStrEqual(properties->name, name))
  {
    int properties = properties->next;
    if (!properties) {
      goto LABEL_7;
    }
  }
  return properties;
}

int xmlStrEqual(const xmlChar *str1, const xmlChar *str2)
{
  if (str1 == str2) {
    return 1;
  }
  int v2 = 0;
  if (str1 && str2)
  {
    while (1)
    {
      int v3 = *str1;
      if (v3 != *str2) {
        break;
      }
      ++str1;
      ++str2;
      if (!v3) {
        return 1;
      }
    }
    return 0;
  }
  return v2;
}

void xmlInitParser(void)
{
  if ((xmlParserInitialized & 1) == 0)
  {
    __xmlGlobalInitMutexLock();
    if ((xmlParserInitialized & 1) == 0)
    {
      xmlInitThreads();
      xmlInitGlobals();
      if ((char *)*__xmlGenericError() == (char *)xmlGenericErrorDefaultFunc || !*__xmlGenericError()) {
        initGenericErrorDefaultFunc(0);
      }
      xmlInitMemory();
      xmlInitializeDict();
      xmlInitCharEncodingHandlers();
      xmlDefaultSAXHandlerInit();
      xmlRegisterDefaultInputCallbacks();
      xmlRegisterDefaultOutputCallbacks();
      htmlInitAutoClose();
      htmlDefaultSAXHandlerInit();
      xmlXPathInit();
      xmlParserInitialized = 1;
    }
    __xmlGlobalInitMutexUnlock();
  }
}

void xmlParseMisc(xmlParserCtxtPtr ctxt)
{
  while (ctxt->instate != XML_PARSER_EOF)
  {
    xmlSkipBlankChars(ctxt);
    xmlParserInputPtr input = ctxt->input;
    if (!ctxt->progressive && input->end - input->cur <= 249)
    {
      xmlGROW((uint64_t)ctxt);
      xmlParserInputPtr input = ctxt->input;
    }
    cur = input->cur;
    if (*cur != 60) {
      break;
    }
    int v4 = cur[1];
    if (v4 == 33)
    {
      if (cur[2] != 45 || cur[3] != 45) {
        return;
      }
      xmlParseComment(ctxt);
    }
    else
    {
      if (v4 != 63) {
        return;
      }
      xmlParsePI(ctxt);
    }
  }
}

int xmlInitParserCtxt(xmlParserCtxtPtr ctxt)
{
  if (!ctxt)
  {
    __xmlRaiseError(0, 0, 0, 0, 0, 1u, 1, 3, 0, 0, 0, 0, 0, 0, 0, "Got NULL parser context\n", 0);
    return -1;
  }
  xmlDefaultSAXHandlerInit();
  dict = ctxt->dict;
  if (!dict && (dict = xmlDictCreate(), (ctxt->dict = dict) == 0)
    || (xmlDictSetLimit(dict, 0x989680uLL), (dict = (xmlDict *)ctxt->sax) == 0)
    && (dict = (xmlDict *)xmlMalloc(0x100uLL), (ctxt->sax = (_xmlSAXHandler *)dict) == 0))
  {
    htmlErrMemory(dict, (const xmlChar *)"cannot initialize parser context\n");
    return -1;
  }
  xmlSAXVersion((xmlSAXHandler *)dict, 2);
  ctxt->maxatts = 0;
  ctxt->atts = 0;
  if (!ctxt->inputTab)
  {
    int v3 = (xmlParserInputPtr *)xmlMalloc(0x28uLL);
    ctxt->inputTab = v3;
    ctxt->uint64_t inputMax = 5;
    if (!v3)
    {
      htmlErrMemory(0, (const xmlChar *)"cannot initialize parser context\n");
      ctxt->xmlParserInputPtr input = 0;
      *(void *)&ctxt->inputNr = 0;
      return -1;
    }
  }
  while (1)
  {
    int v4 = inputPop(ctxt);
    if (!v4) {
      break;
    }
    xmlFreeInputStream(v4);
  }
  ctxt->xmlParserInputPtr input = 0;
  p_xmlParserInputPtr input = &ctxt->input;
  ctxt->inputNr = 0;
  ctxt->version = 0;
  ctxt->encoding = 0;
  *(void *)&ctxt->hasPErefs = 0;
  ctxt->hasExternalSubset = 0;
  *(void *)&ctxt->standalone = 0xFFFFFFFFLL;
  *(void *)&ctxt->xmlParserInputState instate = 0;
  ctxt->directory = 0;
  if (ctxt->nodeTab || (xmlParserInputBufferPtr v6 = (xmlNodePtr *)xmlMalloc(0x50uLL), ctxt->nodeTab = v6, ctxt->nodeMax = 10, v6))
  {
    ctxt->node = 0;
    p_node = &ctxt->node;
    ctxt->nodeNr = 0;
    if (ctxt->nameTab || (xmlParserInputPtr v8 = (const xmlChar **)xmlMalloc(0x50uLL), ctxt->nameTab = v8, ctxt->nameMax = 10, v8))
    {
      ctxt->nameNr = 0;
      ctxt->name = 0;
      spaceTab = ctxt->spaceTab;
      if (spaceTab || (spaceTab = (int *)xmlMalloc(0x28uLL), ctxt->spaceTab = spaceTab, ctxt->spaceMax = 10, spaceTab))
      {
        *(void *)&ctxt->spaceNr = 0xA00000001;
        int *spaceTab = -1;
        ctxt->space = spaceTab;
        ctxt->userData = ctxt;
        ctxt->xmlDocPtr myDoc = 0;
        ctxt->wellFormed = 1;
        ctxt->nsWellFormed = 1;
        ctxt->valint id = 1;
        ExtDtdDefaultValue = __xmlLoadExtDtdDefaultValue();
        int v11 = *ExtDtdDefaultValue;
        ctxt->loadsubset = *ExtDtdDefaultValue;
        if (v11) {
          ctxt->options |= 4u;
        }
        ctxt->validate = *__xmlDoValidityCheckingDefaultValue();
        long long v12 = __xmlPedanticParserDefaultValue();
        int v13 = *v12;
        ctxt->pedantic = *v12;
        if (v13) {
          ctxt->options |= 0x80u;
        }
        ctxt->linenumbers = *__xmlLineNumbersDefaultValue();
        xmlParserInputPtr v14 = __xmlKeepBlanksDefaultValue();
        int v15 = *v14;
        ctxt->keepBlanks = *v14;
        if (!v15)
        {
          ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
          ctxt->options |= 0x100u;
        }
        ctxt->vctxt.finishDtd = -1412623820;
        ctxt->vctxt.userData = ctxt;
        ctxt->vctxt.error = xmlParserValidityError;
        ctxt->vctxt.warning = xmlParserValidityWarning;
        if (ctxt->validate)
        {
          if (*__xmlGetWarningsDefaultValue()) {
            long long v16 = xmlParserValidityWarning;
          }
          else {
            long long v16 = 0;
          }
          ctxt->vctxt.warning = v16;
          ctxt->vctxt.uint64_t nodeMax = 0;
          ctxt->options |= 0x10u;
        }
        xmlParserInputPtr v17 = __xmlSubstituteEntitiesDefaultValue();
        int v18 = *v17;
        ctxt->replaceEntities = *v17;
        if (v18) {
          ctxt->options |= 2u;
        }
        int result = 0;
        ctxt->record_info = 0;
        ctxt->checkIndex = 0;
        ctxt->inSubset = 0;
        ctxt->int errNo = 0;
        ctxt->depth = 0;
        *(_OWORD *)&ctxt->nbentities = 0u;
        ctxt->charset = 1;
        ctxt->catalogs = 0;
        ctxt->sizeentcopy = 0;
        ctxt->input_int id = 1;
        ctxt->node_seq.length = 0;
        ctxt->node_seq.buffer = 0;
        ctxt->node_seq.maximum = 0;
      }
      else
      {
        htmlErrMemory(0, (const xmlChar *)"cannot initialize parser context\n");
        *p_xmlParserInputPtr input = 0;
        *(void *)&ctxt->inputNr = 0;
        xmlNodePtr *p_node = 0;
        *(void *)&ctxt->nodeNr = 0;
        ctxt->name = 0;
        *(void *)&ctxt->nameNr = 0;
        int result = -1;
        ctxt->space = 0;
        *(void *)&ctxt->spaceNr = 0;
      }
    }
    else
    {
      htmlErrMemory(0, (const xmlChar *)"cannot initialize parser context\n");
      *p_xmlParserInputPtr input = 0;
      *(void *)&ctxt->inputNr = 0;
      xmlNodePtr *p_node = 0;
      *(void *)&ctxt->nodeNr = 0;
      int result = -1;
      ctxt->name = 0;
      *(void *)&ctxt->nameNr = 0;
    }
  }
  else
  {
    htmlErrMemory(0, (const xmlChar *)"cannot initialize parser context\n");
    *p_xmlParserInputPtr input = 0;
    *(void *)&ctxt->inputNr = 0;
    int result = -1;
    ctxt->node = 0;
    *(void *)&ctxt->nodeNr = 0;
  }
  return result;
}

int xmlSAXVersion(xmlSAXHandler *hdlr, int version)
{
  if (hdlr)
  {
    if (version == 1)
    {
      hdlr->startElement = xmlSAX2StartElement;
      hdlr->endElement = xmlSAX2EndElement;
      unsigned int v2 = 1;
      goto LABEL_7;
    }
    if (version == 2)
    {
      hdlr->startElement = 0;
      hdlr->endElement = 0;
      hdlr->startElementNs = xmlSAX2StartElementNs;
      hdlr->endElementNs = xmlSAX2EndElementNs;
      hdlr->serror = 0;
      unsigned int v2 = -554844497;
LABEL_7:
      int v3 = 0;
      hdlr->initialized = v2;
      hdlr->internalSubset = xmlSAX2InternalSubset;
      hdlr->externalSubsetSAXFunc externalSubset = xmlSAX2ExternalSubset;
      hdlr->isStandalone = xmlSAX2IsStandalone;
      hdlr->hasInternalSubset = xmlSAX2HasInternalSubset;
      hdlr->hasExternalSubset = xmlSAX2HasExternalSubset;
      hdlr->resolveEntity = xmlSAX2ResolveEntity;
      hdlr->getEntity = xmlSAX2GetEntity;
      hdlr->getParameterEntity = xmlSAX2GetParameterEntity;
      hdlr->entityDecl = xmlSAX2EntityDecl;
      hdlr->attributeDecl = xmlSAX2AttributeDecl;
      hdlr->elementDecl = xmlSAX2ElementDecl;
      hdlr->notationDecl = xmlSAX2NotationDecl;
      hdlr->unparsedEntityDecl = xmlSAX2UnparsedEntityDecl;
      hdlr->setDocumentLocatorSAXFunc setDocumentLocator = xmlSAX2SetDocumentLocator;
      hdlr->startDocumentSAXFunc startDocument = xmlSAX2StartDocument;
      hdlr->endDocumentSAXFunc endDocument = xmlSAX2EndDocument;
      hdlr->reference = xmlSAX2Reference;
      hdlr->characters = xmlSAX2Characters;
      hdlr->ignorableWhitespace = xmlSAX2Characters;
      hdlr->cdataBlocint k = xmlSAX2CDataBlock;
      hdlr->processingInstruction = xmlSAX2ProcessingInstruction;
      hdlr->comment = xmlSAX2Comment;
      hdlr->warning = xmlParserWarning;
      hdlr->error = xmlParserError;
      hdlr->fatalError = xmlParserError;
      return v3;
    }
  }
  return -1;
}

void xmlDefaultSAXHandlerInit(void)
{
  v0 = (xmlSAXHandler *)__xmlDefaultSAXHandler();

  xmlSAXVersion(v0, 1);
}

int *__xmlLineNumbersDefaultValue(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlLineNumbersDefaultValue;
  }
  else {
    return &xmlGetGlobalState()->xmlLineNumbersDefaultValue;
  }
}

int *__xmlKeepBlanksDefaultValue(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlKeepBlanksDefaultValue;
  }
  else {
    return &xmlGetGlobalState()->xmlKeepBlanksDefaultValue;
  }
}

xmlDictPtr xmlDictCreate(void)
{
  if (!xmlDictMutex)
  {
    pthread_once(&once_control_0, _xmlInitializeDictMutex);
    if (!xmlDictMutex) {
      return 0;
    }
  }
  v0 = xmlMalloc(0x40uLL);
  uint64_t v1 = v0;
  if (v0)
  {
    *(_DWORD *)v0 = 1;
    v0[7] = 0;
    v0[2] = 128;
    *((_DWORD *)v0 + 6) = 0;
    unsigned int v2 = xmlMalloc(0x1000uLL);
    v1[1] = v2;
    v1[4] = 0;
    v1[5] = 0;
    if (v2)
    {
      bzero(v2, 0x1000uLL);
      *((_DWORD *)v1 + 12) = __xmlRandom();
      return (xmlDictPtr)v1;
    }
    xmlFree(v1);
    return 0;
  }
  return (xmlDictPtr)v1;
}

void xmlFreeParserCtxt(xmlParserCtxtPtr ctxt)
{
  if (ctxt)
  {
    while (1)
    {
      unsigned int v2 = inputPop(ctxt);
      if (!v2) {
        break;
      }
      xmlFreeInputStream(v2);
    }
    spaceTab = ctxt->spaceTab;
    if (spaceTab) {
      xmlFree(spaceTab);
    }
    nameTab = ctxt->nameTab;
    if (nameTab) {
      xmlFree(nameTab);
    }
    nodeTab = ctxt->nodeTab;
    if (nodeTab) {
      xmlFree(nodeTab);
    }
    nodeInfoTab = ctxt->nodeInfoTab;
    if (nodeInfoTab) {
      xmlFree(nodeInfoTab);
    }
    inputTab = ctxt->inputTab;
    if (inputTab) {
      xmlFree(inputTab);
    }
    version = (xmlChar *)ctxt->version;
    if (version) {
      xmlFree(version);
    }
    encoding = (xmlChar *)ctxt->encoding;
    if (encoding) {
      xmlFree(encoding);
    }
    extSubxmlURIPtr URI = ctxt->extSubURI;
    if (extSubURI) {
      xmlFree(extSubURI);
    }
    extSubSystem = ctxt->extSubSystem;
    if (extSubSystem) {
      xmlFree(extSubSystem);
    }
    if (ctxt->sax)
    {
      sax = ctxt->sax;
      if (sax != (_xmlSAXHandler *)__xmlDefaultSAXHandler()) {
        xmlFree(ctxt->sax);
      }
    }
    directory = ctxt->directory;
    if (directory) {
      xmlFree(directory);
    }
    xmlParserInputPtr v14 = ctxt->vctxt.nodeTab;
    if (v14) {
      xmlFree(v14);
    }
    atts = ctxt->atts;
    if (atts) {
      xmlFree(atts);
    }
    dict = ctxt->dict;
    if (dict) {
      xmlDictFree(dict);
    }
    nsTab = ctxt->nsTab;
    if (nsTab) {
      xmlFree(nsTab);
    }
    pushTab = ctxt->pushTab;
    if (pushTab) {
      xmlFree(pushTab);
    }
    attallocs = ctxt->attallocs;
    if (attallocs) {
      xmlFree(attallocs);
    }
    attsDefault = ctxt->attsDefault;
    if (attsDefault) {
      xmlHashFree(attsDefault, xmlHashDefaultDeallocator);
    }
    attsSpecial = ctxt->attsSpecial;
    if (attsSpecial) {
      xmlHashFree(attsSpecial, 0);
    }
    xmlNodePtr freeElems = ctxt->freeElems;
    if (freeElems)
    {
      do
      {
        xmlNodePtr next = freeElems->next;
        xmlFree(freeElems);
        xmlNodePtr freeElems = next;
      }
      while (next);
    }
    xmlAttrPtr freeAttrs = ctxt->freeAttrs;
    if (freeAttrs)
    {
      do
      {
        uint64_t v25 = freeAttrs->next;
        xmlFree(freeAttrs);
        xmlAttrPtr freeAttrs = v25;
      }
      while (v25);
    }
    message = ctxt->lastError.message;
    if (message) {
      xmlFree(message);
    }
    file = ctxt->lastError.file;
    if (file) {
      xmlFree(file);
    }
    str1 = ctxt->lastError.str1;
    if (str1) {
      xmlFree(str1);
    }
    str2 = ctxt->lastError.str2;
    if (str2) {
      xmlFree(str2);
    }
    str3 = ctxt->lastError.str3;
    if (str3) {
      xmlFree(str3);
    }
    catalogs = ctxt->catalogs;
    if (catalogs) {
      xmlCatalogFreeLocal(catalogs);
    }
    xmlFreeFunc v32 = xmlFree;
    ((void (*)(xmlParserCtxtPtr))v32)(ctxt);
  }
}

xmlParserInputPtr inputPop(xmlParserInputPtr ctxt)
{
  if (ctxt)
  {
    int consumed = ctxt->consumed;
    unsigned int v2 = consumed - 1;
    if (consumed < 1)
    {
      return 0;
    }
    else
    {
      LODWORD(ctxt->consumed) = v2;
      xmlParserInputDeallocate free = ctxt->free;
      if (consumed == 1) {
        uint64_t v4 = 0;
      }
      else {
        uint64_t v4 = *((void *)free + (consumed - 2));
      }
      *(void *)&ctxt->col = v4;
      ctxt = (xmlParserInputPtr)*((void *)free + v2);
      *((void *)free + v2) = 0;
    }
  }
  return ctxt;
}

void xmlFreeInputStream(xmlParserInputPtr input)
{
  if (input)
  {
    filename = (char *)input->filename;
    if (filename) {
      xmlFree(filename);
    }
    directory = (char *)input->directory;
    if (directory) {
      xmlFree(directory);
    }
    encoding = (xmlChar *)input->encoding;
    if (encoding) {
      xmlFree(encoding);
    }
    version = (xmlChar *)input->version;
    if (version) {
      xmlFree(version);
    }
    xmlParserInputDeallocate free = (void (*)(void))input->free;
    if (free && input->base) {
      free();
    }
    if (input->buf) {
      xmlFreeParserInputBuffer(input->buf);
    }
    xmlFreeFunc v7 = xmlFree;
    ((void (*)(xmlParserInputPtr))v7)(input);
  }
}

void xmlFreeParserInputBuffer(xmlParserInputBufferPtr in)
{
  if (in)
  {
    xmlBufPtr raw = in->raw;
    if (raw)
    {
      xmlBufFree((uint64_t)raw);
      in->xmlBufPtr raw = 0;
    }
    encoder = in->encoder;
    if (encoder) {
      xmlCharEncCloseFunc(encoder);
    }
    closecallbacint k = in->closecallback;
    if (closecallback) {
      ((void (*)(void *))closecallback)(in->context);
    }
    xmlBufPtr buffer = in->buffer;
    if (buffer)
    {
      xmlBufFree((uint64_t)buffer);
      in->xmlBufPtr buffer = 0;
    }
    xmlFreeFunc v6 = xmlFree;
    ((void (*)(xmlParserInputBufferPtr))v6)(in);
  }
}

uint64_t xmlBufFree(uint64_t result)
{
  if (!result) {
    return result;
  }
  uint64_t v1 = (void **)result;
  int v2 = *(_DWORD *)(result + 16);
  if (v2 != 3)
  {
    int v3 = *(void **)result;
    if (v2 == 2 || v3 == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  int v3 = *(void **)(result + 24);
  if (v3 || (int v3 = *v1) != 0) {
LABEL_11:
  }
    xmlFree(v3);
LABEL_12:
  xmlFreeFunc v5 = xmlFree;

  return ((uint64_t (*)(void **))v5)(v1);
}

int *__xmlLoadExtDtdDefaultValue(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlLoadExtDtdDefaultValue;
  }
  else {
    return &xmlGetGlobalState()->xmlLoadExtDtdDefaultValue;
  }
}

size_t xmlDictSetLimit(size_t dict, size_t limit)
{
  if (dict)
  {
    size_t v2 = dict;
    dict = *(void *)(dict + 56);
    *(void *)(v2 + 56) = limit;
  }
  return dict;
}

int *__xmlSubstituteEntitiesDefaultValue(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlSubstituteEntitiesDefaultValue;
  }
  else {
    return &xmlGetGlobalState()->xmlSubstituteEntitiesDefaultValue;
  }
}

int *__xmlPedanticParserDefaultValue(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlPedanticParserDefaultValue;
  }
  else {
    return &xmlGetGlobalState()->xmlPedanticParserDefaultValue;
  }
}

int *__xmlDoValidityCheckingDefaultValue(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlDoValidityCheckingDefaultValue;
  }
  else {
    return &xmlGetGlobalState()->xmlDoValidityCheckingDefaultValue;
  }
}

const xmlChar *xmlDetectSAX2(const xmlChar *result)
{
  if (result)
  {
    uint64_t v1 = (xmlChar *)result;
    uint64_t v2 = *(void *)result;
    if (*(void *)result
      && *(_DWORD *)(v2 + 216) == -554844497
      && ((*(void *)(v2 + 232) || !*(void *)(v2 + 112)) && (*(void *)(v2 + 240) || !*(void *)(v2 + 120))
       || *((_DWORD *)result + 13)
       || !os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)
       || xmlDetectSAX2_cold_1((_DWORD *)(v2 + 216)))
      && (*(void *)(v2 + 232) || *(void *)(v2 + 240) || !*(void *)(v2 + 112) && !*(void *)(v2 + 120)))
    {
      *((_DWORD *)v1 + 126) = 1;
    }
    *((void *)v1 + 60) = xmlDictLookup(*((xmlDictPtr *)v1 + 57), (const xmlChar *)"xml", 3);
    *((void *)v1 + 61) = xmlDictLookup(*((xmlDictPtr *)v1 + 57), (const xmlChar *)"xmlns", 5);
    int result = xmlDictLookup(*((xmlDictPtr *)v1 + 57), (const xmlChar *)"http://www.w3.org/XML/1998/namespace", 36);
    *((void *)v1 + 62) = result;
    if (!*((void *)v1 + 60) || !*((void *)v1 + 61) || !result) {
      return (const xmlChar *)htmlErrMemory(v1, 0);
    }
  }
  return result;
}

xmlCharEncoding xmlDetectCharEncoding(const unsigned __int8 *in, int len)
{
  if (in)
  {
    if (len < 4)
    {
      if (len != 3)
      {
        if (len < 2) {
          goto LABEL_46;
        }
        int v2 = *in;
LABEL_19:
        if (v2 != 255)
        {
          if (v2 != 254 || in[1] != 255) {
            goto LABEL_46;
          }
          goto LABEL_22;
        }
        if (in[1] != 254) {
          goto LABEL_46;
        }
        goto LABEL_35;
      }
      int v2 = *in;
    }
    else
    {
      int v2 = *in;
      if (v2 == 76)
      {
        if (in[1] == 111 && in[2] == 167 && in[3] == 148)
        {
          LODWORD(in) = 6;
          return (int)in;
        }
        goto LABEL_46;
      }
      if (v2 == 60)
      {
        if (in[1] == 63)
        {
          if (in[2] != 120 || in[3] != 109) {
            goto LABEL_46;
          }
          goto LABEL_16;
        }
        if (in[1]) {
          goto LABEL_46;
        }
        if (!in[2] && !in[3])
        {
          LODWORD(in) = 4;
          return (int)in;
        }
        if (in[2] != 63 || in[3]) {
          goto LABEL_46;
        }
LABEL_35:
        LODWORD(in) = 2;
        return (int)in;
      }
      if (!*in)
      {
        if (in[1] != 60)
        {
          if (!in[1])
          {
            if (!in[2] && in[3] == 60)
            {
              LODWORD(in) = 5;
              return (int)in;
            }
            if (in[2] == 60 && !in[3])
            {
              LODWORD(in) = 7;
              return (int)in;
            }
          }
LABEL_46:
          LODWORD(in) = 0;
          return (int)in;
        }
        if (!in[2] && !in[3])
        {
          LODWORD(in) = 8;
          return (int)in;
        }
        if (in[2] || in[3] != 63) {
          goto LABEL_46;
        }
LABEL_22:
        LODWORD(in) = 3;
        return (int)in;
      }
    }
    if (v2 == 239)
    {
      if (in[1] != 187 || in[2] != 191) {
        goto LABEL_46;
      }
LABEL_16:
      LODWORD(in) = 1;
      return (int)in;
    }
    goto LABEL_19;
  }
  return (int)in;
}

uint64_t xmlCtxtUseOptionsInternal(uint64_t *a1, uint64_t a2, xmlChar *cur)
{
  if (a1)
  {
    if (cur)
    {
      xmlFreeFunc v6 = (void *)a1[5];
      if (v6) {
        xmlFree(v6);
      }
      a1[5] = (uint64_t)xmlStrdup(cur);
    }
    if (a2)
    {
      a2 = (a2 - 1);
      *((_DWORD *)a1 + 141) |= 1u;
      int v7 = 1;
    }
    else
    {
      int v7 = 0;
    }
    *((_DWORD *)a1 + 112) = v7;
    if ((a2 & 4) != 0)
    {
      a2 = (a2 - 4);
      *((_DWORD *)a1 + 141) |= 4u;
      int v8 = 2;
    }
    else
    {
      int v8 = 0;
    }
    *((_DWORD *)a1 + 108) = v8;
    if ((a2 & 8) != 0)
    {
      *((_DWORD *)a1 + 108) = v8 | 4;
      a2 = (a2 - 8);
      *((_DWORD *)a1 + 141) |= 8u;
    }
    if ((a2 & 2) != 0)
    {
      a2 = (a2 - 2);
      *((_DWORD *)a1 + 141) |= 2u;
      int v9 = 1;
    }
    else
    {
      int v9 = 0;
    }
    *((_DWORD *)a1 + 7) = v9;
    if ((a2 & 0x80) != 0)
    {
      a2 = (a2 - 128);
      *((_DWORD *)a1 + 141) |= 0x80u;
      int v10 = 1;
    }
    else
    {
      int v10 = 0;
    }
    *((_DWORD *)a1 + 105) = v10;
    if ((a2 & 0x100) != 0)
    {
      int v11 = 0;
      *(void *)(*a1 + 144) = xmlSAX2IgnorableWhitespace;
      a2 = (a2 - 256);
      *((_DWORD *)a1 + 141) |= 0x100u;
    }
    else
    {
      int v11 = 1;
    }
    *((_DWORD *)a1 + 82) = v11;
    if ((a2 & 0x10) != 0)
    {
      *((_DWORD *)a1 + 39) = 1;
      if ((a2 & 0x40) != 0) {
        a1[22] = 0;
      }
      if ((a2 & 0x20) != 0) {
        a1[21] = 0;
      }
      a2 = (a2 - 16);
      *((_DWORD *)a1 + 141) |= 0x10u;
      if ((a2 & 0x40) == 0)
      {
LABEL_33:
        if ((a2 & 0x20) != 0)
        {
          uint64_t v13 = *a1;
          a2 = (a2 - 32);
          *(void *)(v13 + 176) = 0;
          *(void *)(v13 + 184) = 0;
          if ((a2 & 0x200) == 0)
          {
LABEL_35:
            if ((a2 & 0x1000) == 0)
            {
LABEL_36:
              int v12 = 1;
              goto LABEL_40;
            }
LABEL_39:
            int v12 = 0;
            a2 = (a2 - 4096);
            *((_DWORD *)a1 + 141) |= 0x1000u;
LABEL_40:
            *((_DWORD *)a1 + 142) = v12;
            if ((a2 & 0x4000) != 0)
            {
              *(void *)(*a1 + 200) = 0;
              a2 = (a2 - 0x4000);
              *((_DWORD *)a1 + 141) |= 0x4000u;
              if ((a2 & 0x2000) == 0)
              {
LABEL_42:
                if ((a2 & 0x800) == 0) {
                  goto LABEL_43;
                }
                goto LABEL_50;
              }
            }
            else if ((a2 & 0x2000) == 0)
            {
              goto LABEL_42;
            }
            *((_DWORD *)a1 + 141) |= 0x2000u;
            a2 = (a2 - 0x2000);
            if ((a2 & 0x800) == 0)
            {
LABEL_43:
              if ((a2 & 0x10000) == 0) {
                goto LABEL_44;
              }
              goto LABEL_51;
            }
LABEL_50:
            *((_DWORD *)a1 + 141) |= 0x800u;
            a2 = (a2 - 2048);
            if ((a2 & 0x10000) == 0)
            {
LABEL_44:
              if ((a2 & 0x20000) == 0) {
                goto LABEL_45;
              }
              goto LABEL_52;
            }
LABEL_51:
            *((_DWORD *)a1 + 141) |= 0x10000u;
            a2 = (a2 - 0x10000);
            if ((a2 & 0x20000) == 0)
            {
LABEL_45:
              if ((a2 & 0x40000) == 0) {
                goto LABEL_46;
              }
              goto LABEL_53;
            }
LABEL_52:
            *((_DWORD *)a1 + 141) |= 0x20000u;
            a2 = (a2 - 0x20000);
            if ((a2 & 0x40000) == 0)
            {
LABEL_46:
              if ((a2 & 0x80000) == 0) {
                goto LABEL_56;
              }
              goto LABEL_54;
            }
LABEL_53:
            *((_DWORD *)a1 + 141) |= 0x40000u;
            a2 = (a2 - 0x40000);
            if ((a2 & 0x80000) == 0) {
              goto LABEL_56;
            }
LABEL_54:
            *((_DWORD *)a1 + 141) |= 0x80000u;
            a2 = (a2 - 0x80000);
            int v15 = (xmlDict *)a1[57];
            if (v15) {
              xmlDictSetLimit(v15, 0);
            }
LABEL_56:
            if ((a2 & 0x100000) != 0)
            {
              *((_DWORD *)a1 + 141) |= 0x100000u;
              a2 = (a2 - 0x100000);
              if ((a2 & 0x200000) == 0)
              {
LABEL_58:
                if ((a2 & 0x400000) == 0)
                {
LABEL_60:
                  *((_DWORD *)a1 + 109) = 1;
                  return a2;
                }
LABEL_59:
                *((_DWORD *)a1 + 141) |= 0x400000u;
                a2 = (a2 - 0x400000);
                goto LABEL_60;
              }
            }
            else if ((a2 & 0x200000) == 0)
            {
              goto LABEL_58;
            }
            *((_DWORD *)a1 + 141) |= 0x200000u;
            a2 = (a2 - 0x200000);
            if ((a2 & 0x400000) == 0) {
              goto LABEL_60;
            }
            goto LABEL_59;
          }
        }
        else if ((a2 & 0x200) == 0)
        {
          goto LABEL_35;
        }
        uint64_t v14 = *a1;
        *(void *)(v14 + 112) = xmlSAX2StartElement;
        *(void *)(v14 + 120) = xmlSAX2EndElement;
        *(void *)(v14 + 232) = 0;
        *(void *)(v14 + 240) = 0;
        *(_DWORD *)(v14 + 216) = 1;
        a2 = (a2 - 512);
        *((_DWORD *)a1 + 141) |= 0x200u;
        if ((a2 & 0x1000) == 0) {
          goto LABEL_36;
        }
        goto LABEL_39;
      }
    }
    else
    {
      *((_DWORD *)a1 + 39) = 0;
      if ((a2 & 0x40) == 0) {
        goto LABEL_33;
      }
    }
    *(void *)(*a1 + 168) = 0;
    a2 = (a2 - 64);
    goto LABEL_33;
  }
  return 0xFFFFFFFFLL;
}

xmlSAXLocator *__xmlDefaultSAXLocator(void)
{
  if (xmlIsMainThread()) {
    return (xmlSAXLocator *)xmlDefaultSAXLocator;
  }
  else {
    return &xmlGetGlobalState()->xmlDefaultSAXLocator;
  }
}

int xmlSwitchEncoding(xmlParserCtxtPtr ctxt, xmlCharEncoding enc)
{
  if (!ctxt) {
    return -1;
  }
  switch(enc)
  {
    case XML_CHAR_ENCODING_ERROR:
      __xmlErrEncoding(ctxt, 31, "encoding unknown\n", 0, 0);
      return -1;
    case XML_CHAR_ENCODING_NONE:
LABEL_22:
      int v8 = 0;
      ctxt->charset = 1;
      return v8;
    case XML_CHAR_ENCODING_UTF8:
      ctxt->charset = 1;
      xmlParserInputPtr input = ctxt->input;
      if (!input) {
        goto LABEL_29;
      }
      cur = input->cur;
      if (*cur != 239 || cur[1] != 187 || cur[2] != 191) {
        goto LABEL_29;
      }
      int v8 = 0;
      input->cur = cur + 3;
      return v8;
    case XML_CHAR_ENCODING_UTF16LE:
    case XML_CHAR_ENCODING_UTF16BE:
      xmlParserInputPtr v5 = ctxt->input;
      if (v5)
      {
        xmlFreeFunc v6 = v5->cur;
        if (v6)
        {
          if (*v6 == 239 && v6[1] == 187 && v6[2] == 191) {
            v5->cur = v6 + 3;
          }
        }
      }
      goto LABEL_11;
    case XML_CHAR_ENCODING_UCS4LE:
    case XML_CHAR_ENCODING_UCS4BE:
    case XML_CHAR_ENCODING_UCS4_2143:
    case XML_CHAR_ENCODING_UCS4_3412:
      int v4 = 180;
      goto LABEL_13;
    case XML_CHAR_ENCODING_EBCDIC:
    case XML_CHAR_ENCODING_8859_1:
    case XML_CHAR_ENCODING_8859_2:
    case XML_CHAR_ENCODING_8859_3:
    case XML_CHAR_ENCODING_8859_4:
    case XML_CHAR_ENCODING_8859_5:
    case XML_CHAR_ENCODING_8859_6:
    case XML_CHAR_ENCODING_8859_7:
    case XML_CHAR_ENCODING_8859_8:
    case XML_CHAR_ENCODING_8859_9:
    case XML_CHAR_ENCODING_2022_JP:
    case XML_CHAR_ENCODING_SHIFT_JIS:
    case XML_CHAR_ENCODING_EUC_JP:
    case XML_CHAR_ENCODING_ASCII:
      int v4 = 45;
      goto LABEL_13;
    case XML_CHAR_ENCODING_UCS2:
LABEL_11:
      int v4 = 90;
      goto LABEL_13;
    default:
      int v4 = -1;
LABEL_13:
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlGetCharEncodingHandler(enc);
      if (!CharEncodingHandler)
      {
        int v9 = "USC4 little endian";
        switch(enc)
        {
          case XML_CHAR_ENCODING_UCS4LE:
            goto LABEL_41;
          case XML_CHAR_ENCODING_UCS4BE:
            int v9 = "USC4 big endian";
            goto LABEL_41;
          case XML_CHAR_ENCODING_EBCDIC:
            int v9 = "EBCDIC";
            goto LABEL_41;
          case XML_CHAR_ENCODING_UCS4_2143:
            int v9 = "UCS4 2143";
            goto LABEL_41;
          case XML_CHAR_ENCODING_UCS4_3412:
            int v9 = "UCS4 3412";
            goto LABEL_41;
          case XML_CHAR_ENCODING_UCS2:
            int v9 = "UCS2";
            goto LABEL_41;
          case XML_CHAR_ENCODING_8859_1:
          case XML_CHAR_ENCODING_8859_2:
          case XML_CHAR_ENCODING_8859_3:
          case XML_CHAR_ENCODING_8859_4:
          case XML_CHAR_ENCODING_8859_5:
          case XML_CHAR_ENCODING_8859_6:
          case XML_CHAR_ENCODING_8859_7:
          case XML_CHAR_ENCODING_8859_8:
          case XML_CHAR_ENCODING_8859_9:
            if (ctxt->inputNr == 1 && !ctxt->encoding)
            {
              xmlParserInputPtr v12 = ctxt->input;
              if (v12)
              {
                encoding = v12->encoding;
                if (encoding) {
                  ctxt->encoding = xmlStrdup(encoding);
                }
              }
            }
            int v8 = 0;
            ctxt->charset = enc;
            return v8;
          case XML_CHAR_ENCODING_2022_JP:
            int v9 = "ISO-2022-JP";
            goto LABEL_41;
          case XML_CHAR_ENCODING_SHIFT_JIS:
            int v9 = "Shift_JIS";
            goto LABEL_41;
          case XML_CHAR_ENCODING_EUC_JP:
            int v9 = "EUC-JP";
LABEL_41:
            __xmlErrEncoding(ctxt, 32, "encoding not supported %s\n", (const xmlChar *)v9, 0);
            break;
          case XML_CHAR_ENCODING_ASCII:
            goto LABEL_22;
          default:
            break;
        }
        xmlStopParser(ctxt);
        return -1;
      }
      ctxt->charset = 1;
      int v8 = xmlSwitchToEncodingInt(ctxt, CharEncodingHandler, v4);
      if (v8 < 0 || ctxt->errNo == 6003)
      {
        if (!ctxt->html)
        {
          xmlStopParser(ctxt);
          ctxt->int errNo = 6003;
        }
      }
      else
      {
LABEL_29:
        int v8 = 0;
      }
      break;
  }
  return v8;
}

void xmlParseXMLDecl(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  input->standalone = -2;
  cur = input->cur;
  input->cur = cur + 5;
  input->col += 5;
  unsigned int v4 = cur[5];
  if (!v4)
  {
    xmlParserInputGrow(input, 250);
    unsigned int v4 = *ctxt->input->cur;
  }
  BOOL v5 = v4 > 0x20;
  uint64_t v6 = (1 << v4) & 0x100002600;
  if (v5 || v6 == 0) {
    xmlFatalErrMsg(ctxt, 65, (char)"Blank needed after '<?xml'\n");
  }
  xmlSkipBlankChars(ctxt);
  int v8 = xmlParseVersionInfo(ctxt);
  if (v8)
  {
    int v9 = v8;
    if (!xmlStrEqual(v8, (const xmlChar *)"1.0"))
    {
      if ((ctxt->options & 0x20000) == 0 && *v9 == 49 && v9[1] == 46) {
        xmlWarningMsg(ctxt, 97, "Unsupported version '%s'\n", v9);
      }
      else {
        xmlFatalErrMsgStr(ctxt, 108, "Unsupported version '%s'\n", v9);
      }
    }
    version = (xmlChar *)ctxt->version;
    if (version) {
      xmlFree(version);
    }
    ctxt->version = v9;
  }
  else
  {
    xmlFatalErr(ctxt, 96, 0);
  }
  xmlParserInputPtr v11 = ctxt->input;
  xmlParserInputPtr v12 = v11->cur;
  uint64_t v13 = *v12;
  if (v13 <= 0x3F)
  {
    if (((1 << v13) & 0x100002600) != 0) {
      goto LABEL_25;
    }
    if (v13 == 63 && v12[1] == 62) {
      goto LABEL_39;
    }
  }
  xmlFatalErrMsg(ctxt, 65, (char)"Blank needed here\n");
LABEL_25:
  xmlParseEncodingDecl(ctxt);
  if (ctxt->errNo == 32 || ctxt->instate == XML_PARSER_EOF) {
    return;
  }
  xmlParserInputPtr v11 = ctxt->input;
  if (v11->encoding)
  {
    xmlParserInputPtr v12 = v11->cur;
    uint64_t v14 = *v12;
    if (v14 > 0x3F)
    {
LABEL_32:
      xmlFatalErrMsg(ctxt, 65, (char)"Blank needed here\n");
      goto LABEL_33;
    }
    if (((1 << v14) & 0x100002600) == 0)
    {
      if (v14 != 63 || v12[1] != 62) {
        goto LABEL_32;
      }
LABEL_39:
      v11->cur = v12 + 2;
      v11->col += 2;
      if (!v12[2])
      {
        xmlParserInputGrow(v11, 250);
      }
      return;
    }
  }
LABEL_33:
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  xmlSkipBlankChars(ctxt);
  ctxt->input->standalone = xmlParseSDDecl(ctxt);
  xmlSkipBlankChars(ctxt);
  xmlParserInputPtr v11 = ctxt->input;
  xmlParserInputPtr v12 = v11->cur;
  int v15 = *v12;
  if (v15 == 62)
  {
    xmlFatalErr(ctxt, 57, 0);
  }
  else
  {
    if (v15 == 63 && v12[1] == 62) {
      goto LABEL_39;
    }
    xmlFatalErr(ctxt, 57, 0);
    xmlParserInputPtr v16 = ctxt->input;
    for (uint64_t i = v16->cur; *i++ && *(i - 1) != 62; v16->cur = i)
      ;
  }

  xmlNextChar(ctxt);
}

xmlChar *__cdecl xmlParseVersionInfo(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur != 118 || cur[1] != 101 || cur[2] != 114 || cur[3] != 115 || cur[4] != 105 || cur[5] != 111 || cur[6] != 110) {
    return 0;
  }
  input->cur = cur + 7;
  input->col += 7;
  if (!cur[7]) {
    xmlParserInputGrow(input, 250);
  }
  xmlSkipBlankChars(ctxt);
  if (*ctxt->input->cur != 61)
  {
    xmlParserCtxtPtr v6 = ctxt;
    int v7 = 75;
LABEL_19:
    xmlFatalErr(v6, v7, 0);
    return 0;
  }
  xmlNextChar(ctxt);
  xmlSkipBlankChars(ctxt);
  int v4 = *ctxt->input->cur;
  if (v4 == 39)
  {
    xmlNextChar(ctxt);
    BOOL v5 = xmlParseVersionNum(ctxt);
    if (*ctxt->input->cur == 39) {
      goto LABEL_14;
    }
LABEL_17:
    xmlFatalErr(ctxt, 34, 0);
    return v5;
  }
  if (v4 != 34)
  {
    xmlParserCtxtPtr v6 = ctxt;
    int v7 = 33;
    goto LABEL_19;
  }
  xmlNextChar(ctxt);
  BOOL v5 = xmlParseVersionNum(ctxt);
  if (*ctxt->input->cur != 34) {
    goto LABEL_17;
  }
LABEL_14:
  xmlNextChar(ctxt);
  return v5;
}

xmlChar *__cdecl xmlParseVersionNum(xmlParserCtxtPtr ctxt)
{
  int v2 = (xmlChar *)xmlMallocAtomic(0xAuLL);
  int v3 = v2;
  if (!v2)
  {
    htmlErrMemory(ctxt, 0);
    return v3;
  }
  int v4 = *ctxt->input->cur;
  if ((v4 - 48) >= 0xA || (*int v2 = v4, xmlNextChar(ctxt), *ctxt->input->cur != 46))
  {
    xmlFree(v3);
    return 0;
  }
  v3[1] = 46;
  xmlNextChar(ctxt);
  int v5 = *ctxt->input->cur;
  if ((v5 - 48) > 9)
  {
    uint64_t v10 = 2;
LABEL_15:
    v3[v10] = 0;
    return v3;
  }
  int v6 = 10;
  uint64_t v7 = 2;
  while (1)
  {
    unsigned int v8 = v7 + 1;
    if (v7 + 1 >= v6) {
      break;
    }
LABEL_9:
    v3[v7] = v5;
    xmlNextChar(ctxt);
    int v5 = *ctxt->input->cur;
    ++v7;
    if ((v5 - 48) >= 0xA)
    {
      uint64_t v10 = v8;
      goto LABEL_15;
    }
  }
  v6 *= 2;
  int v9 = (xmlChar *)xmlRealloc(v3, v6);
  if (v9)
  {
    int v3 = v9;
    goto LABEL_9;
  }
  xmlFree(v3);
  htmlErrMemory(ctxt, 0);
  return 0;
}

int xmlParseSDDecl(xmlParserCtxtPtr ctxt)
{
  xmlSkipBlankChars(ctxt);
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur != 115
    || cur[1] != 116
    || cur[2] != 97
    || cur[3] != 110
    || cur[4] != 100
    || cur[5] != 97
    || cur[6] != 108
    || cur[7] != 111
    || cur[8] != 110
    || cur[9] != 101)
  {
    return -2;
  }
  input->cur = cur + 10;
  input->col += 10;
  if (!cur[10]) {
    xmlParserInputGrow(input, 250);
  }
  xmlSkipBlankChars(ctxt);
  if (*ctxt->input->cur == 61)
  {
    xmlNextChar(ctxt);
    xmlSkipBlankChars(ctxt);
    int v4 = *ctxt->input->cur;
    if (v4 != 34)
    {
      if (v4 == 39)
      {
        xmlNextChar(ctxt);
        xmlParserInputPtr v5 = ctxt->input;
        int v6 = v5->cur;
        int v7 = *v6;
        if (v7 == 121)
        {
          if (v6[1] == 101 && v6[2] == 115)
          {
            v5->cur = v6 + 3;
            v5->col += 3;
            if (!v6[3]) {
              xmlParserInputGrow(v5, 250);
            }
            int v8 = 1;
LABEL_39:
            if (*ctxt->input->cur == 39)
            {
LABEL_40:
              xmlNextChar(ctxt);
              return v8;
            }
LABEL_48:
            xmlFatalErr(ctxt, 34, 0);
            return v8;
          }
        }
        else if (v7 == 110 && v6[1] == 111)
        {
          v5->cur = v6 + 2;
          v5->col += 2;
          if (!v6[2]) {
            xmlParserInputGrow(v5, 250);
          }
          int v8 = 0;
          goto LABEL_39;
        }
        xmlFatalErr(ctxt, 78, 0);
        int v8 = -2;
        goto LABEL_39;
      }
      xmlParserCtxtPtr v9 = ctxt;
      int v10 = 33;
      goto LABEL_30;
    }
    xmlNextChar(ctxt);
    xmlParserInputPtr v11 = ctxt->input;
    xmlParserInputPtr v12 = v11->cur;
    int v13 = *v12;
    if (v13 == 121)
    {
      if (v12[1] == 101 && v12[2] == 115)
      {
        v11->cur = v12 + 3;
        v11->col += 3;
        if (!v12[3]) {
          xmlParserInputGrow(v11, 250);
        }
        int v8 = 1;
LABEL_47:
        if (*ctxt->input->cur == 34) {
          goto LABEL_40;
        }
        goto LABEL_48;
      }
    }
    else if (v13 == 110 && v12[1] == 111)
    {
      v11->cur = v12 + 2;
      v11->col += 2;
      if (!v12[2]) {
        xmlParserInputGrow(v11, 250);
      }
      int v8 = 0;
      goto LABEL_47;
    }
    xmlFatalErr(ctxt, 78, 0);
    int v8 = -2;
    goto LABEL_47;
  }
  xmlParserCtxtPtr v9 = ctxt;
  int v10 = 75;
LABEL_30:
  xmlFatalErr(v9, v10, 0);
  return -2;
}

const xmlChar *__cdecl xmlParseEncodingDecl(xmlParserCtxtPtr ctxt)
{
  xmlSkipBlankChars(ctxt);
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur != 101
    || cur[1] != 110
    || cur[2] != 99
    || cur[3] != 111
    || cur[4] != 100
    || cur[5] != 105
    || cur[6] != 110
    || cur[7] != 103)
  {
    return 0;
  }
  input->cur = cur + 8;
  input->col += 8;
  if (!cur[8]) {
    xmlParserInputGrow(input, 250);
  }
  xmlSkipBlankChars(ctxt);
  if (*ctxt->input->cur != 61)
  {
    xmlFatalErr(ctxt, 75, 0);
    return 0;
  }
  xmlNextChar(ctxt);
  xmlSkipBlankChars(ctxt);
  int v4 = *ctxt->input->cur;
  if (v4 == 39)
  {
    xmlNextChar(ctxt);
    xmlParserInputPtr v5 = xmlParseEncName(ctxt);
    if (*ctxt->input->cur == 39) {
      goto LABEL_15;
    }
LABEL_28:
    xmlFatalErr(ctxt, 34, 0);
    goto LABEL_30;
  }
  if (v4 != 34)
  {
    xmlFatalErr(ctxt, 33, 0);
    xmlParserInputPtr v5 = 0;
    if ((ctxt->options & 0x200000) == 0) {
      return v5;
    }
    goto LABEL_30;
  }
  xmlNextChar(ctxt);
  xmlParserInputPtr v5 = xmlParseEncName(ctxt);
  if (*ctxt->input->cur != 34) {
    goto LABEL_28;
  }
LABEL_15:
  xmlNextChar(ctxt);
  if ((ctxt->options & 0x200000) != 0)
  {
LABEL_30:
    xmlFree(v5);
    return 0;
  }
  if (!v5) {
    return v5;
  }
  if (!xmlStrcasecmp(v5, (const xmlChar *)"UTF-16") || !xmlStrcasecmp(v5, (const xmlChar *)"UTF16"))
  {
    encoding = (xmlChar *)ctxt->encoding;
    if (encoding) {
      goto LABEL_38;
    }
    xmlParserInputBufferPtr buf = ctxt->input->buf;
    if (!buf || buf->encoder) {
      goto LABEL_39;
    }
    xmlFatalErrMsg(ctxt, 81, (char)"Document labelled UTF-16 but has UTF-8 content\n");
LABEL_37:
    encoding = (xmlChar *)ctxt->encoding;
    if (!encoding)
    {
LABEL_39:
      ctxt->encoding = v5;
      return v5;
    }
LABEL_38:
    xmlFree(encoding);
    goto LABEL_39;
  }
  if (!xmlStrcasecmp(v5, (const xmlChar *)"UTF-8") || !xmlStrcasecmp(v5, (const xmlChar *)"UTF8")) {
    goto LABEL_37;
  }
  xmlParserInputPtr v6 = ctxt->input;
  int v7 = (xmlChar *)v6->encoding;
  if (v7)
  {
    xmlFree(v7);
    xmlParserInputPtr v6 = ctxt->input;
  }
  v6->encoding = v5;
  xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler((const char *)v5);
  if (!CharEncodingHandler)
  {
    xmlFatalErrMsgStr(ctxt, 32, "Unsupported encoding %s\n", v5);
    return 0;
  }
  if (xmlSwitchToEncoding(ctxt, CharEncodingHandler) < 0)
  {
    xmlParserInputPtr v5 = 0;
    ctxt->int errNo = 32;
  }
  return v5;
}

int xmlStrcasecmp(const xmlChar *str1, const xmlChar *str2)
{
  if (str1 == str2) {
    return 0;
  }
  if (!str1) {
    return -1;
  }
  if (!str2) {
    return 1;
  }
  while (1)
  {
    uint64_t v2 = *str2;
    int v3 = casemap[*str1] - casemap[v2];
    if (v3) {
      break;
    }
    ++str1;
    ++str2;
    if (!v2) {
      return 0;
    }
  }
  return v3;
}

int xmlDictReference(xmlDictPtr dict)
{
  uint64_t v2 = (xmlRMutex *)xmlDictMutex;
  if (xmlDictMutex)
  {
    if (!dict) {
      return -1;
    }
    goto LABEL_6;
  }
  pthread_once(&once_control_0, _xmlInitializeDictMutex);
  int result = -1;
  if (dict)
  {
    uint64_t v2 = (xmlRMutex *)xmlDictMutex;
    if (xmlDictMutex)
    {
LABEL_6:
      xmlRMutexLock(v2);
      ++*(_DWORD *)dict;
      xmlRMutexUnlock((xmlRMutexPtr)xmlDictMutex);
      return 0;
    }
  }
  return result;
}

uint64_t __xmlRandom()
{
  v0 = (xmlRMutex *)xmlDictMutex;
  if (!xmlDictMutex)
  {
    pthread_once(&once_control_0, _xmlInitializeDictMutex);
    v0 = (xmlRMutex *)xmlDictMutex;
  }
  xmlRMutexLock(v0);
  uint64_t v1 = rand_r((unsigned int *)&rand_seed);
  xmlRMutexUnlock((xmlRMutexPtr)xmlDictMutex);
  return v1;
}

void xmlDictFree(xmlDictPtr dict)
{
  if (dict)
  {
    uint64_t v2 = (xmlRMutex *)xmlDictMutex;
    if (xmlDictMutex
      || (pthread_once(&once_control_0, _xmlInitializeDictMutex), (uint64_t v2 = (xmlRMutex *)xmlDictMutex) != 0))
    {
      xmlRMutexLock(v2);
      int v3 = (*(_DWORD *)dict)--;
      xmlRMutexUnlock((xmlRMutexPtr)xmlDictMutex);
      if (v3 <= 1)
      {
        int v4 = (xmlDict *)*((void *)dict + 5);
        if (v4) {
          xmlDictFree(v4);
        }
        xmlParserInputPtr v5 = (char *)*((void *)dict + 1);
        if (v5)
        {
          unint64_t v6 = *((void *)dict + 2);
          if (v6)
          {
            uint64_t v7 = 0;
            int v8 = *((_DWORD *)dict + 6);
            while (1)
            {
              xmlParserInputPtr v5 = (char *)*((void *)dict + 1);
              if (!v8) {
                break;
              }
              xmlParserCtxtPtr v9 = &v5[32 * v7];
              if (*((_DWORD *)v9 + 5)) {
                BOOL v10 = v5 == 0;
              }
              else {
                BOOL v10 = 1;
              }
              if (!v10)
              {
                char v11 = 0;
                do
                {
                  xmlParserInputPtr v12 = *(char **)v9;
                  if (v11)
                  {
                    xmlFree(v9);
                    int v8 = *((_DWORD *)dict + 6);
                  }
                  *((_DWORD *)dict + 6) = --v8;
                  char v11 = 1;
                  xmlParserCtxtPtr v9 = v12;
                }
                while (v12);
                unint64_t v6 = *((void *)dict + 2);
              }
              if (++v7 >= v6)
              {
                xmlParserInputPtr v5 = (char *)*((void *)dict + 1);
                break;
              }
            }
          }
          xmlFree(v5);
        }
        int v13 = (void *)*((void *)dict + 4);
        if (v13)
        {
          do
          {
            uint64_t v14 = (void *)*v13;
            xmlFree(v13);
            int v13 = v14;
          }
          while (v14);
        }
        xmlFreeFunc v15 = xmlFree;
        ((void (*)(xmlDictPtr))v15)(dict);
      }
    }
  }
}

void xmlRMutexUnlock(xmlRMutexPtr tok)
{
  if (tok)
  {
    pthread_mutex_lock((pthread_mutex_t *)tok);
    int v2 = *((_DWORD *)tok + 16) - 1;
    *((_DWORD *)tok + 16) = v2;
    if (!v2)
    {
      if (*((_DWORD *)tok + 17)) {
        pthread_cond_signal((pthread_cond_t *)((char *)tok + 80));
      }
      *((void *)tok + 9) = 0;
    }
    pthread_mutex_unlock((pthread_mutex_t *)tok);
  }
}

void xmlRMutexLock(xmlRMutexPtr tok)
{
  if (!tok) {
    return;
  }
  pthread_mutex_lock((pthread_mutex_t *)tok);
  if (!*((_DWORD *)tok + 16)) {
    goto LABEL_10;
  }
  int v2 = (_opaque_pthread_t *)*((void *)tok + 9);
  int v3 = pthread_self();
  if (!pthread_equal(v2, v3))
  {
    int v6 = *((_DWORD *)tok + 16);
    int v5 = *((_DWORD *)tok + 17);
    *((_DWORD *)tok + 17) = v5 + 1;
    if (v6)
    {
      do
        pthread_cond_wait((pthread_cond_t *)((char *)tok + 80), (pthread_mutex_t *)tok);
      while (*((_DWORD *)tok + 16));
      int v5 = *((_DWORD *)tok + 17) - 1;
    }
    *((_DWORD *)tok + 17) = v5;
LABEL_10:
    *((void *)tok + 9) = pthread_self();
    int v4 = 1;
    goto LABEL_11;
  }
  int v4 = *((_DWORD *)tok + 16) + 1;
LABEL_11:
  *((_DWORD *)tok + 16) = v4;

  pthread_mutex_unlock((pthread_mutex_t *)tok);
}

void xmlParseElement(xmlParserCtxtPtr ctxt)
{
  if (!xmlParseElementStart((uint64_t)ctxt))
  {
    xmlParseContentInternal((uint64_t)ctxt);
    if (ctxt->instate != XML_PARSER_EOF)
    {
      if (*ctxt->input->cur)
      {
        xmlParseElementEnd(ctxt);
      }
      else
      {
        uint64_t v2 = ctxt->nameNr - 1;
        int v3 = ctxt->nameTab[v2];
        int v4 = *((_DWORD *)ctxt->pushTab + 6 * v2 + 4);
        xmlFatalErrMsgStrIntStr(ctxt, 77, "Premature end of data in tag %s line %d\n", v3, v4, 0);
      }
    }
  }
}

void xmlSAX2EndDocument(void *ctx)
{
  if (ctx)
  {
    if (*((_DWORD *)ctx + 39))
    {
      if (*((_DWORD *)ctx + 6))
      {
        uint64_t v2 = (xmlDoc *)*((void *)ctx + 2);
        if (v2)
        {
          if (v2->intSubset) {
            *((_DWORD *)ctx + 38) &= xmlValidateDocumentFinal((xmlValidCtxtPtr)((char *)ctx + 160), v2);
          }
        }
      }
    }
    uint64_t v3 = *((void *)ctx + 5);
    if (v3)
    {
      uint64_t v4 = *((void *)ctx + 2);
      if (v4)
      {
        if (!*(void *)(v4 + 112))
        {
          *(void *)(v4 + 112) = v3;
          *((void *)ctx + 5) = 0;
        }
      }
    }
    int v5 = (uint64_t *)*((void *)ctx + 9);
    if (v5)
    {
      if (*((int *)ctx + 16) >= 1)
      {
        uint64_t v6 = *v5;
        if (v6)
        {
          uint64_t v7 = *(const xmlChar **)(v6 + 80);
          if (v7)
          {
            uint64_t v8 = *((void *)ctx + 2);
            if (v8)
            {
              if (!*(void *)(v8 + 112)) {
                *(void *)(*((void *)ctx + 2) + 112) = xmlStrdup(v7);
              }
            }
          }
        }
      }
    }
    int v9 = *((_DWORD *)ctx + 102);
    if (v9)
    {
      uint64_t v10 = *((void *)ctx + 2);
      if (v10)
      {
        if (!*(_DWORD *)(v10 + 144)) {
          *(_DWORD *)(v10 + 144) = v9;
        }
      }
    }
  }
}

void xmlSAX2StartDocument(void *ctx)
{
  if (!ctx) {
    return;
  }
  if (*((_DWORD *)ctx + 13))
  {
    htmlDocPtr v2 = (htmlDocPtr)*((void *)ctx + 2);
    if (v2 || (htmlDocPtr v2 = htmlNewDocNoDtD(0, 0), (*((void *)ctx + 2) = v2) != 0))
    {
      v2->parseFlags = *((_DWORD *)ctx + 141);
      v2->int properties = 128;
      goto LABEL_11;
    }
  }
  else
  {
    xmlDocPtr v3 = xmlNewDoc(*((const xmlChar **)ctx + 4));
    *((void *)ctx + 2) = v3;
    if (v3)
    {
      xmlDocPtr v4 = v3;
      v3->int properties = (*((_DWORD *)ctx + 141) >> 15) & 4;
      v3->parseFlags = *((_DWORD *)ctx + 141);
      int v5 = (xmlChar *)*((void *)ctx + 5);
      if (v5) {
        int v5 = xmlStrdup(v5);
      }
      v4->encoding = v5;
      v4->standalone = *((_DWORD *)ctx + 12);
      if (*((_DWORD *)ctx + 142))
      {
        uint64_t v6 = (xmlDict *)*((void *)ctx + 57);
        v4->dict = v6;
        xmlDictReference(v6);
      }
LABEL_11:
      uint64_t v7 = *((void *)ctx + 2);
      if (!v7) {
        return;
      }
      if (*(void *)(v7 + 136)) {
        return;
      }
      uint64_t v8 = *((void *)ctx + 7);
      if (!v8) {
        return;
      }
      int v9 = *(const xmlChar **)(v8 + 8);
      if (!v9) {
        return;
      }
      uint64_t v10 = xmlPathToURI(v9);
      *(void *)(*((void *)ctx + 2) + 136) = v10;
      if (v10) {
        return;
      }
    }
  }

  xmlSAX2ErrMemory((uint64_t *)ctx, "xmlSAX2StartDocument");
}

xmlGlobalStatePtr xmlGetGlobalState(void)
{
  pthread_once(&once_control_2, (void (*)(void))xmlOnceInit);
  v0 = (xmlGlobalState *)pthread_getspecific(globalkey);
  if (!v0)
  {
    uint64_t v1 = (xmlGlobalState *)malloc_type_malloc(0x3C8uLL, 0x10D00409EF9DAF4uLL);
    if (v1)
    {
      v0 = v1;
      bzero(v1, 0x3C8uLL);
      xmlInitializeGlobalState(v0);
      pthread_setspecific(globalkey, v0);
    }
    else
    {
      xmlGenericErrorFunc v2 = *__xmlGenericError();
      xmlDocPtr v3 = __xmlGenericErrorContext();
      v2(*v3, "xmlGetGlobalState: out of memory\n");
      return 0;
    }
  }
  return v0;
}

xmlGenericErrorFunc *__xmlGenericError(void)
{
  if (xmlIsMainThread()) {
    return (xmlGenericErrorFunc *)xmlGenericError;
  }
  else {
    return &xmlGetGlobalState()->xmlGenericError;
  }
}

void xmlSAX2InitHtmlDefaultSAXHandler(xmlSAXHandler *hdlr)
{
  if (hdlr)
  {
    if (!hdlr->initialized)
    {
      hdlr->internalSubset = xmlSAX2InternalSubset;
      hdlr->externalSubsetSAXFunc externalSubset = 0;
      *(_OWORD *)&hdlr->isStandalone = 0u;
      *(_OWORD *)&hdlr->hasExternalSubset = 0u;
      hdlr->getEntity = xmlSAX2GetEntity;
      *(_OWORD *)&hdlr->entityDecl = 0u;
      *(_OWORD *)&hdlr->attributeDecl = 0u;
      hdlr->unparsedEntityDecl = 0;
      hdlr->setDocumentLocatorSAXFunc setDocumentLocator = xmlSAX2SetDocumentLocator;
      hdlr->startDocumentSAXFunc startDocument = xmlSAX2StartDocument;
      hdlr->endDocumentSAXFunc endDocument = xmlSAX2EndDocument;
      hdlr->startElement = xmlSAX2StartElement;
      hdlr->endElement = xmlSAX2EndElement;
      hdlr->reference = 0;
      hdlr->characters = xmlSAX2Characters;
      hdlr->getParameterEntity = 0;
      hdlr->cdataBlocint k = xmlSAX2CDataBlock;
      hdlr->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
      hdlr->processingInstruction = xmlSAX2ProcessingInstruction;
      hdlr->comment = xmlSAX2Comment;
      hdlr->warning = xmlParserWarning;
      hdlr->error = xmlParserError;
      hdlr->fatalError = xmlParserError;
      hdlr->initialized = 1;
    }
  }
}

void htmlDefaultSAXHandlerInit(void)
{
  v0 = (xmlSAXHandler *)__htmlDefaultSAXHandler();

  xmlSAX2InitHtmlDefaultSAXHandler(v0);
}

xmlSAXHandlerV1 *__htmlDefaultSAXHandler(void)
{
  if (xmlIsMainThread()) {
    return (xmlSAXHandlerV1 *)&htmlDefaultSAXHandler;
  }
  else {
    return &xmlGetGlobalState()->htmlDefaultSAXHandler;
  }
}

void xmlXPathInit(void)
{
  xmlXPathNAN = NAN;
  xmlXPathPINF = INFINITY;
  xmlXPathNINF = -INFINITY;
}

void xmlRegisterDefaultOutputCallbacks(void)
{
  if ((xmlOutputCallbackInitialized & 1) == 0)
  {
    uint64_t v0 = xmlOutputCallbackNr;
    if (xmlOutputCallbackNr <= 14)
    {
      uint64_t v1 = (int (__cdecl **)(const char *))((char *)&xmlOutputCallbackTable + 32 * xmlOutputCallbackNr);
      *uint64_t v1 = xmlFileMatch;
      v1[1] = (int (__cdecl *)(const char *))xmlFileOpenW;
      v1[2] = (int (__cdecl *)(const char *))xmlFileWrite;
      v1[3] = (int (__cdecl *)(const char *))xmlFileClose;
      xmlOutputCallbackNr = v0 + 1;
      if (v0 != 14)
      {
        xmlGenericErrorFunc v2 = (int (__cdecl **)(const char *))((char *)&xmlOutputCallbackTable + 32 * v0 + 32);
        *xmlGenericErrorFunc v2 = xmlIOHTTPMatch;
        v2[1] = (int (__cdecl *)(const char *))xmlIOHTTPDfltOpenW;
        v2[2] = (int (__cdecl *)(const char *))xmlIOHTTPWrite;
        v2[3] = (int (__cdecl *)(const char *))xmlIOHTTPClosePut;
        xmlOutputCallbackNr = v0 + 2;
      }
    }
    xmlOutputCallbackInitialized = 1;
  }
}

void xmlRegisterDefaultInputCallbacks(void)
{
  if ((xmlInputCallbackInitialized & 1) == 0)
  {
    uint64_t v0 = xmlInputCallbackNr;
    if (xmlInputCallbackNr <= 14)
    {
      uint64_t v1 = (int (__cdecl **)(const char *))((char *)&xmlInputCallbackTable + 32 * xmlInputCallbackNr);
      *uint64_t v1 = xmlFileMatch;
      v1[1] = (int (__cdecl *)(const char *))xmlFileOpen;
      v1[2] = (int (__cdecl *)(const char *))xmlFileRead;
      v1[3] = (int (__cdecl *)(const char *))xmlFileClose;
      xmlInputCallbackNr = v0 + 1;
      if (v0 != 14)
      {
        xmlGenericErrorFunc v2 = (uint64_t (**)())((char *)&xmlInputCallbackTable + 32 * v0 + 32);
        *xmlGenericErrorFunc v2 = xmlGzfileMatch;
        v2[1] = (uint64_t (*)())xmlGzfileOpen;
        v2[2] = (uint64_t (*)())xmlGzfileRead;
        v2[3] = (uint64_t (*)())xmlGzfileClose;
        xmlInputCallbackNr = v0 + 2;
        if ((int)v0 <= 12)
        {
          xmlDocPtr v3 = (int (__cdecl **)(const char *))((char *)&xmlInputCallbackTable + 32 * v0 + 64);
          const xmlChar *v3 = xmlIOHTTPMatch;
          v3[1] = (int (__cdecl *)(const char *))xmlIOHTTPOpen;
          v3[2] = (int (__cdecl *)(const char *))xmlIOHTTPRead;
          v3[3] = (int (__cdecl *)(const char *))xmlIOHTTPClose;
          xmlInputCallbackNr = v0 + 3;
          if (v0 != 12)
          {
            xmlDocPtr v4 = (int (__cdecl **)(const char *))((char *)&xmlInputCallbackTable + 32 * v0 + 96);
            xmlDict *v4 = xmlIOFTPMatch;
            v4[1] = (int (__cdecl *)(const char *))xmlIOFTPOpen;
            v4[2] = (int (__cdecl *)(const char *))xmlIOFTPRead;
            v4[3] = (int (__cdecl *)(const char *))xmlIOFTPClose;
            xmlInputCallbackNr = v0 + 4;
          }
        }
      }
    }
    xmlInputCallbackInitialized = 1;
  }
}

int xmlInitializeDict(void)
{
  return 0;
}

int xmlInitMemory(void)
{
  if (xmlMemInitialized)
  {
    LODWORD(v0) = -1;
  }
  else
  {
    xmlMemInitialized = 1;
    xmlMemMutex = (uint64_t)xmlNewMutex();
    uint64_t v1 = getenv("XML_MEM_BREAKPOINT");
    if (v1) {
      sscanf(v1, "%ud", &xmlMemStopAtBlock);
    }
    uint64_t v0 = getenv("XML_MEM_TRACE");
    if (v0)
    {
      sscanf(v0, "%p", &xmlMemTraceBlockAt);
      LODWORD(v0) = 0;
    }
  }
  return (int)v0;
}

xmlMutexPtr xmlNewMutex(void)
{
  uint64_t v0 = (pthread_mutex_t *)malloc_type_malloc(0x40uLL, 0x1000040FA0F61DDuLL);
  uint64_t v1 = (xmlMutex *)v0;
  if (v0) {
    pthread_mutex_init(v0, 0);
  }
  return v1;
}

void xmlInitGlobals(void)
{
}

void initGenericErrorDefaultFunc(xmlGenericErrorFunc *handler)
{
  if (handler) {
    uint64_t v1 = *handler;
  }
  else {
    uint64_t v1 = (void (*)(void *, const char *, ...))xmlGenericErrorDefaultFunc;
  }
  *__xmlGenericError() = v1;
}

uint64_t __xmlGlobalInitMutexLock()
{
  return pthread_mutex_lock(&global_init_lock);
}

void xmlInitNodeInfoSeq(xmlParserNodeInfoSeqPtr seq)
{
  if (seq)
  {
    seq->maximum = 0;
    seq->length = 0;
    seq->xmlBufPtr buffer = 0;
  }
}

void xmlMutexUnlock(xmlMutexPtr tok)
{
  if (tok) {
    pthread_mutex_unlock((pthread_mutex_t *)tok);
  }
}

int xmlOutputBufferClose(xmlOutputBufferPtr out)
{
  if (!out) {
    return -1;
  }
  if (out->writecallback) {
    xmlOutputBufferFlush(out);
  }
  closecallbacint k = out->closecallback;
  if (closecallback) {
    int v3 = ((uint64_t (*)(void *))closecallback)(out->context);
  }
  else {
    int v3 = 0;
  }
  int written = out->written;
  xmlBufPtr conv = out->conv;
  if (conv)
  {
    xmlBufFree((uint64_t)conv);
    out->xmlBufPtr conv = 0;
  }
  encoder = out->encoder;
  if (encoder) {
    xmlCharEncCloseFunc(encoder);
  }
  xmlBufPtr buffer = out->buffer;
  if (buffer)
  {
    xmlBufFree((uint64_t)buffer);
    out->xmlBufPtr buffer = 0;
  }
  if (out->error) {
    int v3 = -1;
  }
  xmlFree(out);
  if (v3) {
    return v3;
  }
  else {
    return written;
  }
}

int xmlOutputBufferFlush(xmlOutputBufferPtr out)
{
  if (!out || out->error) {
    return -1;
  }
  p_xmlBufPtr conv = &out->conv;
  if (out->conv && out->encoder)
  {
    do
    {
      int v5 = xmlCharEncOutput(out, 0);
      if (v5 < 0)
      {
        __xmlSimpleError(8, 1544, 0, (uint64_t)"encoder error", 0);
        out->error = 1544;
        return -1;
      }
    }
    while (v5);
    if (*p_conv)
    {
      if (out->encoder)
      {
        writecallbacint k = out->writecallback;
        if (writecallback)
        {
          context = out->context;
          uint64_t v8 = xmlBufContent(*p_conv);
          xmlBufPtr conv = out->conv;
          goto LABEL_15;
        }
      }
    }
  }
  writecallbacint k = out->writecallback;
  if (writecallback)
  {
    context = out->context;
    p_xmlBufPtr conv = &out->buffer;
    uint64_t v8 = xmlBufContent(out->buffer);
    xmlBufPtr conv = out->buffer;
LABEL_15:
    size_t v10 = xmlBufUse(conv);
    unsigned int v2 = ((uint64_t (*)(void *, xmlChar *, size_t))writecallback)(context, v8, v10);
    if ((v2 & 0x80000000) != 0)
    {
      __xmlSimpleError(8, 1545, 0, (uint64_t)"flush error", 0);
      out->error = 1545;
      return v2;
    }
    xmlBufShrink(*p_conv, v2);
  }
  else
  {
    unsigned int v2 = 0;
  }
  int written = out->written;
  if (written <= (int)(v2 ^ 0x7FFFFFFF)) {
    int v12 = written + v2;
  }
  else {
    int v12 = 0x7FFFFFFF;
  }
  out->int written = v12;
  return v2;
}

void xmlParseTryOrFinish(uint64_t a1, int a2)
{
  uint64_t v168 = *MEMORY[0x1E4F143B8];
  int v158 = 0;
  uint64_t v2 = *(void *)(a1 + 56);
  if (!v2) {
    return;
  }
  if ((uint64_t)(*(void *)(v2 + 32) - *(void *)(v2 + 24)) > 4096)
  {
    xmlSHRINK(a1);
    *(void *)(a1 + 320) = 0;
  }
  unint64_t v156 = 0;
  unint64_t v157 = 0;
  xmlParseGetLasts(a1, &v157, &v156);
  int v5 = *(_DWORD *)(a1 + 272);
  if (v5 == -1) {
    return;
  }
  int v154 = 0;
  while (2)
  {
    if (*(_DWORD *)(a1 + 24) != 1 && *(_DWORD *)(a1 + 332) == 1) {
      return;
    }
    uint64_t v6 = *(xmlParserInput **)(a1 + 56);
    if (!v6) {
      return;
    }
    if (v6->buf)
    {
      if (v5)
      {
        uint64_t raw = (uint64_t)v6->buf->raw;
        if (raw)
        {
          int IsEmpty = xmlBufIsEmpty(raw);
          uint64_t v6 = *(xmlParserInput **)(a1 + 56);
          if (!IsEmpty)
          {
            unint64_t InputBase = xmlBufGetInputBase((uint64_t)v6->buf->buffer, (uint64_t)v6);
            uint64_t v10 = *(void *)(a1 + 56);
            uint64_t v11 = *(void *)(v10 + 32) - *(void *)(v10 + 24);
            xmlParserInputBufferPush(*(xmlParserInputBufferPtr *)v10, 0, "");
            xmlBufSetInputBaseCur(*(uint64_t **)(**(void **)(a1 + 56) + 32), *(void **)(a1 + 56), InputBase, v11);
            uint64_t v6 = *(xmlParserInput **)(a1 + 56);
          }
        }
      }
      size_t length = xmlBufUse(v6->buf->buffer);
      uint64_t v6 = *(xmlParserInput **)(a1 + 56);
    }
    else
    {
      size_t length = v6->length;
    }
    base = v6->base;
    cur = v6->cur;
    unint64_t v15 = (unint64_t)&base[length - (void)cur];
    if (!v15) {
      return;
    }
    int v5 = *(_DWORD *)(a1 + 272);
    switch(v5)
    {
      case -1:
        return;
      case 0:
        if (!*(_DWORD *)(a1 + 408))
        {
          *(_DWORD *)in = 0;
          if (v15 >= 4)
          {
            *(_DWORD *)in = *(_DWORD *)cur;
            xmlCharEncoding v71 = xmlDetectCharEncoding(in, 4);
            xmlSwitchEncoding((xmlParserCtxtPtr)a1, v71);
            goto LABEL_289;
          }
          return;
        }
        if (v15 < 2) {
          return;
        }
        if (*cur)
        {
          if (*cur == 60 && cur[1] == 63)
          {
            if (v15 < 5 || !a2 && (xmlParseLookupSequence(a1, 63, 62, 0) & 0x80000000) != 0) {
              return;
            }
            if (*(void *)a1)
            {
              xmlParserInputPtr v16 = *(void (**)(uint64_t, xmlSAXLocator *))(*(void *)a1 + 88);
              if (v16)
              {
                uint64_t v17 = *(void *)(a1 + 8);
                int v18 = __xmlDefaultSAXLocator();
                v16(v17, v18);
              }
            }
            uint64_t v19 = *(unsigned char **)(*(void *)(a1 + 56) + 32);
            if (v19[2] == 120 && v19[3] == 109 && v19[4] == 108)
            {
              unsigned int v20 = v19[5];
              if (v20 <= 0x20 && ((1 << v20) & 0x100002600) != 0)
              {
                xmlParseXMLDecl((xmlParserCtxtPtr)a1);
                if (*(_DWORD *)(a1 + 136) == 32)
                {
                  xmlHaltParser((xmlParserCtxtPtr)a1);
                  return;
                }
                uint64_t v21 = *(void *)(a1 + 56);
                *(_DWORD *)(a1 + 48) = *(_DWORD *)(v21 + 96);
                if (!*(void *)(a1 + 40))
                {
                  xmlDocPtr v22 = *(const xmlChar **)(v21 + 80);
                  if (v22) {
                    *(void *)(a1 + 40) = xmlStrdup(v22);
                  }
                }
                if (*(void *)a1)
                {
                  unsigned int v23 = *(void (**)(void))(*(void *)a1 + 96);
                  if (v23)
                  {
                    if (!*(_DWORD *)(a1 + 332)) {
                      v23(*(void *)(a1 + 8));
                    }
                  }
                }
                v154 += 5;
LABEL_199:
                int v5 = 1;
                goto LABEL_338;
              }
            }
            *(void *)(a1 + 32) = xmlCharStrdup("1.0");
          }
          else
          {
            if (*(void *)a1)
            {
              int v85 = *(void (**)(uint64_t, xmlSAXLocator *))(*(void *)a1 + 88);
              if (v85)
              {
                uint64_t v86 = *(void *)(a1 + 8);
                v87 = __xmlDefaultSAXLocator();
                v85(v86, v87);
              }
            }
            int v88 = xmlCharStrdup("1.0");
            *(void *)(a1 + 32) = v88;
            if (!v88)
            {
              htmlErrMemory((_DWORD *)a1, 0);
              goto LABEL_289;
            }
          }
          if (*(void *)a1)
          {
            uint64_t v89 = *(void (**)(void))(*(void *)a1 + 96);
            if (v89)
            {
              if (!*(_DWORD *)(a1 + 332)) {
                v89(*(void *)(a1 + 8));
              }
            }
          }
          goto LABEL_199;
        }
        if (*(void *)a1)
        {
          v150 = *(void (**)(uint64_t, xmlSAXLocator *))(*(void *)a1 + 88);
          if (v150)
          {
            uint64_t v151 = *(void *)(a1 + 8);
            v152 = __xmlDefaultSAXLocator();
            v150(v151, v152);
          }
        }
LABEL_389:
        v143 = (_DWORD *)a1;
        int v144 = 4;
        goto LABEL_390;
      case 1:
        xmlSkipBlankChars((xmlParserCtxtPtr)a1);
        uint64_t v24 = *(void *)(a1 + 56);
        if (*(void *)v24)
        {
          size_t v25 = xmlBufUse(*(const xmlBufPtr *)(*(void *)v24 + 32));
          uint64_t v24 = *(void *)(a1 + 56);
        }
        else
        {
          size_t v25 = *(int *)(v24 + 48);
        }
        int v72 = *(unsigned __int8 **)(v24 + 32);
        unint64_t v73 = v25 - (void)v72 + *(void *)(v24 + 24);
        if (v73 < 2) {
          return;
        }
        int v74 = *v72;
        int v75 = v72[1];
        if (v74 == 60 && v75 == 63)
        {
          if (a2 || (xmlParseLookupSequence(a1, 63, 62, 0) & 0x80000000) == 0)
          {
            xmlParsePI((xmlParserCtxtPtr)a1);
            goto LABEL_146;
          }
          goto LABEL_385;
        }
        if (v74 != 60 || v75 != 33) {
          goto LABEL_287;
        }
        int v76 = v72[2];
        if (v76 == 68)
        {
          if (v72[3] != 79 || v72[4] != 67 || v72[5] != 84 || v72[6] != 89 || v72[7] != 80 || v72[8] != 69) {
            goto LABEL_286;
          }
          if (!a2 && (xmlParseLookupSequence(a1, 62, 0, 0) & 0x80000000) != 0)
          {
            int v149 = 3;
            goto LABEL_397;
          }
          *(_DWORD *)(a1 + 336) = 1;
          *(_DWORD *)(a1 + 452) = 0;
          *(void *)(a1 + 320) = 0;
          xmlParseDocTypeDecl((xmlParserCtxtPtr)a1);
          if (*(_DWORD *)(a1 + 272) == -1) {
            return;
          }
          if (**(unsigned char **)(*(void *)(a1 + 56) + 32) == 91)
          {
LABEL_123:
            int v5 = 3;
          }
          else
          {
            *(_DWORD *)(a1 + 336) = 2;
            if (*(void *)a1)
            {
              if (!*(_DWORD *)(a1 + 332))
              {
                v117 = *(void (**)(void, void, void, void))(*(void *)a1 + 208);
                if (v117) {
                  v117(*(void *)(a1 + 8), *(void *)(a1 + 344), *(void *)(a1 + 360), *(void *)(a1 + 352));
                }
              }
            }
            *(_DWORD *)(a1 + 336) = 0;
            xmlCleanSpecialAttr((void *)a1);
            int v5 = 4;
          }
LABEL_338:
          *(_DWORD *)(a1 + 272) = v5;
          goto LABEL_339;
        }
        if (v76 != 45 || v72[3] != 45)
        {
LABEL_286:
          if (v73 < 9) {
            return;
          }
LABEL_287:
          *(_DWORD *)(a1 + 272) = 6;
          *(_DWORD *)(a1 + 452) = 6;
          goto LABEL_288;
        }
        if (!a2 && (xmlParseLookupSequence(a1, 45, 45, 62) & 0x80000000) != 0)
        {
LABEL_396:
          int v149 = 5;
          goto LABEL_397;
        }
        xmlParseComment((xmlParserCtxtPtr)a1);
LABEL_146:
        if (*(_DWORD *)(a1 + 272) != -1)
        {
          int v5 = 1;
          *(_DWORD *)(a1 + 272) = 1;
          *(_DWORD *)(a1 + 452) = 1;
          goto LABEL_148;
        }
        return;
      case 2:
        xmlGenericErrorFunc v26 = *__xmlGenericError();
        int v27 = *__xmlGenericErrorContext();
        unsigned int v28 = "PP: internal error, state == PI\n";
        goto LABEL_117;
      case 3:
        unsigned int v29 = cur - base;
        if (cur - base < 0) {
          return;
        }
        uint64_t v30 = *(void *)(a1 + 320);
        if (v30 <= v29) {
          size_t v31 = v29;
        }
        else {
          size_t v31 = v30;
        }
        LODWORD(v32) = v31;
        uint64_t v33 = xmlBufContent(v6->buf->buffer);
        size_t v34 = xmlBufUse(*(const xmlBufPtr *)(**(void **)(a1 + 56) + 32));
        if (v34 <= v31) {
          goto LABEL_358;
        }
        unsigned __int8 v35 = 0;
        uint64_t v36 = v33 + 1;
        while (2)
        {
          int v37 = v33[(int)v32];
          if (v35)
          {
            if (v37 == v35) {
              unsigned __int8 v35 = 0;
            }
            goto LABEL_82;
          }
          if (v34 > (v32 + 4) && v37 == 60)
          {
            uint64_t v38 = (int)v32;
            int v39 = &v33[(int)v32];
            if (v39[1] != 33 || v39[2] != 45 || v33[(int)v32 + 3] != 45) {
              goto LABEL_81;
            }
            if (v34 <= (v32 + 3)) {
              goto LABEL_358;
            }
            while (v33[v38] != 45 || v36[v38] != 45 || v36[v38 + 1] != 62)
            {
              size_t v40 = (v38++ + 4);
              if (v34 <= v40)
              {
                LODWORD(v32) = v38;
                goto LABEL_358;
              }
            }
            unsigned __int8 v35 = 0;
            LODWORD(v32) = v38 + 2;
            goto LABEL_82;
          }
          if (v37 == 34)
          {
            unsigned __int8 v35 = 34;
            goto LABEL_82;
          }
          if (v37 != 93)
          {
            if (v37 == 39)
            {
              unsigned __int8 v35 = 39;
              goto LABEL_82;
            }
LABEL_81:
            unsigned __int8 v35 = 0;
LABEL_82:
            size_t v32 = (v32 + 1);
            if (v34 <= v32)
            {
              if (v35) {
                uint64_t v130 = 0;
              }
              else {
LABEL_358:
              }
                uint64_t v130 = (int)v32;
              *(void *)(a1 + 320) = v130;
              return;
            }
            continue;
          }
          break;
        }
        size_t v41 = (v32 + 1);
        if (v34 <= v41) {
          goto LABEL_358;
        }
        if (v33[(int)v41] == 93)
        {
          unsigned __int8 v35 = 0;
          LODWORD(v32) = v32 + 1;
          goto LABEL_82;
        }
        LODWORD(v42) = v32 + 1;
        while (1)
        {
          uint64_t v43 = v33[(int)v42];
          if (v43 > 0x3E) {
            goto LABEL_81;
          }
          if (((1 << v43) & 0x100002600) == 0) {
            break;
          }
          size_t v42 = (v42 + 1);
          if (v34 <= v42) {
            goto LABEL_358;
          }
        }
        if (v43 != 62) {
          goto LABEL_81;
        }
        *(void *)(a1 + 320) = 0;
        xmlParseInternalSubset(a1);
        if (*(_DWORD *)(a1 + 272) == -1) {
          return;
        }
        *(_DWORD *)(a1 + 336) = 2;
        if (*(void *)a1)
        {
          if (!*(_DWORD *)(a1 + 332))
          {
            v123 = *(void (**)(void, void, void, void))(*(void *)a1 + 208);
            if (v123) {
              v123(*(void *)(a1 + 8), *(void *)(a1 + 344), *(void *)(a1 + 360), *(void *)(a1 + 352));
            }
          }
        }
        *(_DWORD *)(a1 + 336) = 0;
        xmlCleanSpecialAttr((void *)a1);
        if (*(_DWORD *)(a1 + 272) == -1) {
          return;
        }
        int v5 = 4;
        *(_DWORD *)(a1 + 272) = 4;
LABEL_148:
        *(void *)(a1 + 320) = 0;
LABEL_339:
        if (v5 == -1) {
          return;
        }
        continue;
      case 4:
        xmlSkipBlankChars((xmlParserCtxtPtr)a1);
        uint64_t v44 = *(void *)(a1 + 56);
        if (*(void *)v44)
        {
          size_t v45 = xmlBufUse(*(const xmlBufPtr *)(*(void *)v44 + 32));
          uint64_t v44 = *(void *)(a1 + 56);
        }
        else
        {
          size_t v45 = *(int *)(v44 + 48);
        }
        v77 = *(unsigned __int8 **)(v44 + 32);
        unint64_t v78 = v45 - (void)v77 + *(void *)(v44 + 24);
        if (v78 < 2) {
          return;
        }
        int v79 = *v77;
        int v80 = v77[1];
        if (v79 != 60 || v80 != 63)
        {
          if (v79 == 60 && v80 == 33)
          {
            if (v77[2] == 45 && v77[3] == 45)
            {
              if (!a2 && (xmlParseLookupSequence(a1, 45, 45, 62) & 0x80000000) != 0) {
                goto LABEL_396;
              }
              xmlParseComment((xmlParserCtxtPtr)a1);
              goto LABEL_164;
            }
            if (v78 < 4) {
              return;
            }
          }
          *(_DWORD *)(a1 + 272) = 6;
          if (!*(_DWORD *)(a1 + 452)) {
            *(_DWORD *)(a1 + 452) = 6;
          }
LABEL_288:
          xmlParseGetLasts(a1, &v157, &v156);
LABEL_289:
          int v5 = *(_DWORD *)(a1 + 272);
          goto LABEL_339;
        }
        if (a2 || (xmlParseLookupSequence(a1, 63, 62, 0) & 0x80000000) == 0)
        {
          xmlParsePI((xmlParserCtxtPtr)a1);
LABEL_164:
          if (*(_DWORD *)(a1 + 272) == -1) {
            return;
          }
          int v5 = 4;
          goto LABEL_270;
        }
        goto LABEL_385;
      case 5:
        xmlGenericErrorFunc v26 = *__xmlGenericError();
        int v27 = *__xmlGenericErrorContext();
        unsigned int v28 = "PP: internal error, state == COMMENT\n";
        goto LABEL_117;
      case 6:
        *(void *)in = 0;
        uint64_t v155 = 0;
        int line = v6->line;
        int v47 = *(_DWORD *)(a1 + 508);
        if (v15 <= 1 && *(_DWORD *)(a1 + 64) == 1) {
          return;
        }
        if (*cur != 60) {
          goto LABEL_389;
        }
        if (a2) {
          goto LABEL_231;
        }
        if (*(_DWORD *)(a1 + 452))
        {
          if ((unint64_t)cur >= v156) {
            return;
          }
        }
        else if ((xmlParseLookupSequence(a1, 62, 0, 0) & 0x80000000) != 0)
        {
          return;
        }
LABEL_231:
        if (*(_DWORD *)(a1 + 376))
        {
          if (**(_DWORD **)(a1 + 368) == -2) {
            int v98 = -1;
          }
          else {
            int v98 = **(_DWORD **)(a1 + 368);
          }
        }
        else
        {
          int v98 = -1;
        }
        spacePush(a1, v98);
        if (*(_DWORD *)(a1 + 504)) {
          started = xmlParseStartTag2(a1, (const xmlChar **)in, &v155, &v158);
        }
        else {
          started = (xmlChar *)xmlParseStartTag((xmlParserCtxtPtr)a1);
        }
        unint64_t v100 = started;
        if (*(_DWORD *)(a1 + 272) == -1) {
          return;
        }
        if (started)
        {
          if (*(_DWORD *)(a1 + 156))
          {
            if (*(_DWORD *)(a1 + 24))
            {
              v101 = *(xmlDoc **)(a1 + 16);
              if (v101)
              {
                uint64_t v102 = *(_xmlNode **)(a1 + 80);
                if (v102)
                {
                  if (v102 == v101->children) {
                    *(_DWORD *)(a1 + 152) &= xmlValidateRoot((xmlValidCtxtPtr)(a1 + 160), v101);
                  }
                }
              }
            }
          }
          int v103 = *(xmlParserInput **)(a1 + 56);
          uint64_t v104 = v103->cur;
          int v105 = *v104;
          if (v105 == 62)
          {
            xmlNextChar((xmlParserCtxtPtr)a1);
          }
          else
          {
            if (v105 == 47 && v104[1] == 62)
            {
              v103->cur = v104 + 2;
              v103->col += 2;
              if (!v104[2]) {
                xmlParserInputGrow(v103, 250);
              }
              uint64_t v106 = *(void *)a1;
              if (*(_DWORD *)(a1 + 504))
              {
                if (v106)
                {
                  int v107 = *(void (**)(void, xmlChar *, void, uint64_t))(v106 + 240);
                  if (v107)
                  {
                    if (!*(_DWORD *)(a1 + 332)) {
                      v107(*(void *)(a1 + 8), v100, *(void *)in, v155);
                    }
                  }
                }
                int v108 = *(_DWORD *)(a1 + 508) - v47;
                if (v108 >= 1) {
                  nsPop(a1, v108);
                }
              }
              else if (v106)
              {
                v118 = *(void (**)(void, xmlChar *))(v106 + 120);
                if (v118)
                {
                  if (!*(_DWORD *)(a1 + 332)) {
                    v118(*(void *)(a1 + 8), v100);
                  }
                }
              }
              if (*(_DWORD *)(a1 + 272) == -1) {
                return;
              }
              int v119 = *(_DWORD *)(a1 + 376);
              if (v119 >= 1)
              {
                unsigned int v120 = v119 - 2;
                unsigned int v121 = v119 - 1;
                *(_DWORD *)(a1 + 376) = v121;
                uint64_t v122 = *(void *)(a1 + 384);
                if (!v121) {
                  unsigned int v120 = 0;
                }
                *(void *)(a1 + 368) = v122 + 4 * v120;
                *(_DWORD *)(v122 + 4 * v121) = -1;
              }
              if (*(_DWORD *)(a1 + 296)) {
                int v5 = 7;
              }
              else {
                int v5 = 14;
              }
LABEL_270:
              *(_DWORD *)(a1 + 272) = v5;
              *(_DWORD *)(a1 + 452) = 1;
              goto LABEL_339;
            }
            xmlFatalErrMsgStr((_DWORD *)a1, 73, "Couldn't find end of Start Tag %s\n", v100);
            int v109 = *(_DWORD *)(a1 + 88);
            unsigned int v110 = v109 - 1;
            if (v109 >= 1)
            {
              *(_DWORD *)(a1 + 88) = v110;
              uint64_t v111 = *(void *)(a1 + 96);
              if (v109 == 1) {
                uint64_t v112 = 0;
              }
              else {
                uint64_t v112 = *(void *)(v111 + 8 * (v109 - 2));
              }
              *(void *)(a1 + 80) = v112;
              *(void *)(v111 + 8 * v110) = 0;
            }
            int v113 = *(_DWORD *)(a1 + 376);
            if (v113 >= 1)
            {
              unsigned int v114 = v113 - 2;
              unsigned int v115 = v113 - 1;
              *(_DWORD *)(a1 + 376) = v115;
              uint64_t v116 = *(void *)(a1 + 384);
              if (!v115) {
                unsigned int v114 = 0;
              }
              *(void *)(a1 + 368) = v116 + 4 * v114;
              *(_DWORD *)(v116 + 4 * v115) = -1;
            }
          }
          nameNsPush((void **)a1, v100, *(uint64_t *)in, v155, line, *(_DWORD *)(a1 + 508) - v47);
          int v5 = 7;
          goto LABEL_270;
        }
        int v145 = *(_DWORD *)(a1 + 376);
        if (v145 >= 1)
        {
          unsigned int v146 = v145 - 2;
          unsigned int v147 = v145 - 1;
          *(_DWORD *)(a1 + 376) = v147;
          uint64_t v148 = *(void *)(a1 + 384);
          if (!v147) {
            unsigned int v146 = 0;
          }
          *(void *)(a1 + 368) = v148 + 4 * v146;
          *(_DWORD *)(v148 + 4 * v147) = -1;
        }
        goto LABEL_391;
      case 7:
        if (v15 <= 1 && *(_DWORD *)(a1 + 64) == 1) {
          return;
        }
        int v48 = *cur;
        int v49 = cur[1];
        uint64_t consumed_low = LODWORD(v6->consumed);
        if (v48 == 60 && v49 == 47)
        {
          int v5 = 9;
          goto LABEL_338;
        }
        if (v48 == 60 && v49 == 63)
        {
          if (a2 || (xmlParseLookupSequence(a1, 63, 62, 0) & 0x80000000) == 0)
          {
            xmlParsePI((xmlParserCtxtPtr)a1);
LABEL_131:
            *(_DWORD *)(a1 + 272) = 7;
            *(_DWORD *)(a1 + 452) = 1;
LABEL_353:
            uint64_t v129 = *(void *)(a1 + 56);
            if (consumed_low == *(void *)(v129 + 64) && cur == *(const xmlChar **)(v129 + 32))
            {
              xmlFatalErr((_DWORD *)a1, 1, (const xmlChar *)"detected an error in element content\n");
              xmlHaltParser((xmlParserCtxtPtr)a1);
            }
            goto LABEL_289;
          }
LABEL_385:
          int v149 = 2;
LABEL_397:
          *(_DWORD *)(a1 + 452) = v149;
          return;
        }
        if (v48 == 60 && v49 != 33)
        {
LABEL_125:
          int v5 = 6;
          goto LABEL_338;
        }
        BOOL v90 = v48 == 60 && v49 == 33;
        char v91 = v90;
        if (v90)
        {
          int v92 = cur[2];
          if (v92 == 45)
          {
            if (cur[3] == 45)
            {
              if (v15 < 4) {
                return;
              }
              v6->cur = cur + 4;
              int v93 = xmlParseLookupSequence(a1, 45, 45, 62);
              *(void *)(*(void *)(a1 + 56) + 32) -= 4;
              if (!a2 && v93 < 0) {
                goto LABEL_396;
              }
              xmlParseComment((xmlParserCtxtPtr)a1);
              goto LABEL_131;
            }
            goto LABEL_303;
          }
        }
        else
        {
          if (v48 != 60)
          {
            if (v48 == 38)
            {
              if (!a2 && (xmlParseLookupSequence(a1, 59, 0, 0) & 0x80000000) != 0) {
                return;
              }
              xmlParseReference((xmlParserCtxtPtr)a1);
              goto LABEL_353;
            }
            goto LABEL_345;
          }
          if (v49 != 33)
          {
LABEL_345:
            if (!a2 && v15 <= 0x12B && *(_DWORD *)(a1 + 64) == 1)
            {
              if (*(_DWORD *)(a1 + 452))
              {
                if ((unint64_t)cur > v157) {
                  return;
                }
              }
              else if ((xmlParseLookupSequence(a1, 60, 0, 0) & 0x80000000) != 0)
              {
                return;
              }
            }
            *(void *)(a1 + 320) = 0;
            xmlParseCharData((xmlParserCtxtPtr)a1, 0);
            goto LABEL_353;
          }
          int v92 = cur[2];
        }
        if (v92 == 91 && cur[3] == 67 && cur[4] == 68 && cur[5] == 65 && cur[6] == 84 && cur[7] == 65 && cur[8] == 91)
        {
          v6->cur = cur + 9;
          v6->col += 9;
          if (!cur[9]) {
            xmlParserInputGrow(v6, 250);
          }
          int v5 = 8;
          goto LABEL_338;
        }
LABEL_303:
        if (v15 >= 9) {
          char v91 = 0;
        }
        if (v91) {
          return;
        }
        goto LABEL_345;
      case 8:
        uint64_t v51 = xmlParseLookupSequence(a1, 93, 93, 62);
        if ((v51 & 0x80000000) != 0)
        {
          if (v15 < 0x12E) {
            return;
          }
          int v53 = *(void **)(a1 + 56);
          uint64_t v131 = v53[4];
          uint64_t v132 = xmlCheckCdataPush(v131, 300, 0);
          int v133 = v132;
          if ((v132 & 0x80000000) == 0)
          {
            uint64_t v134 = *(void *)a1;
            if (*(void *)a1)
            {
              if (!*(_DWORD *)(a1 + 332))
              {
                v135 = *(void (**)(void, uint64_t, uint64_t))(v134 + 200);
                if (v135 || (v135 = *(void (**)(void, uint64_t, uint64_t))(v134 + 136)) != 0) {
                  v135(*(void *)(a1 + 8), v131, v132);
                }
              }
            }
            if (*(_DWORD *)(a1 + 272) != -1)
            {
              int v136 = *(xmlParserInput **)(a1 + 56);
              if (v133)
              {
                v137 = v136->cur;
                int col = v136->col;
                do
                {
                  if (*v137 == 10)
                  {
                    ++v136->line;
                    int col = 1;
                  }
                  else
                  {
                    ++col;
                  }
                  v136->int col = col;
                  v136->cur = ++v137;
                  --v133;
                }
                while (v133);
              }
              else
              {
                v137 = v136->cur;
              }
              if (!*v137) {
                xmlParserInputGrow(v136, 250);
              }
              *(void *)(a1 + 320) = 0;
            }
            return;
          }
          v139 = (unsigned __int8 *)(v131 + -(int)v132);
        }
        else
        {
          uint64_t v52 = v51;
          int v53 = *(void **)(a1 + 56);
          uint64_t v54 = v53[4];
          int v55 = xmlCheckCdataPush(v54, v51, 1);
          if ((v55 & 0x80000000) == 0 && v55 == v52)
          {
            uint64_t v56 = *(void *)a1;
            if (v52 || !v56)
            {
              if (v52 && v56 && !*(_DWORD *)(a1 + 332))
              {
                xmlEntityPtr v70 = *(void (**)(void, uint64_t, uint64_t))(v56 + 200);
                if (v70)
                {
                  v70(*(void *)(a1 + 8), v54, v52);
                }
                else
                {
                  uint64_t v124 = *(void (**)(void, uint64_t, uint64_t))(v56 + 136);
                  if (v124) {
                    v124(*(void *)(a1 + 8), v54, v52);
                  }
                }
              }
            }
            else
            {
              uint64_t v57 = *(void (**)(void, const char *, void))(v56 + 200);
              if (v57
                && !*(_DWORD *)(a1 + 332)
                && v54 - v53[3] >= 9
                && !strncmp((const char *)(v54 - 9), "<![CDATA[", 9uLL))
              {
                v57(*(void *)(a1 + 8), "", 0);
              }
            }
            if (*(_DWORD *)(a1 + 272) == -1) {
              return;
            }
            v125 = *(xmlParserInput **)(a1 + 56);
            int v126 = v125->col;
            uint64_t v127 = (uint64_t)(v125->cur + 1);
            int v128 = ((v52 + 2) & ~(((int)v52 + 2) >> 31)) + 1;
            do
            {
              if (*(unsigned char *)(v127 - 1) == 10)
              {
                ++v125->line;
                int v126 = 1;
              }
              else
              {
                ++v126;
              }
              v125->int col = v126;
              v125->cur = (const xmlChar *)v127++;
              --v128;
            }
            while (v128);
            if (!*(unsigned char *)(v127 - 1)) {
              xmlParserInputGrow(v125, 250);
            }
            *(void *)(a1 + 320) = 0;
LABEL_337:
            int v5 = 7;
            goto LABEL_338;
          }
          v139 = (unsigned __int8 *)(v54 + -v55);
        }
        v53[4] = v139;
        if ((uint64_t)(v53[5] - (void)v139) > 3)
        {
          long long v166 = 0u;
          memset(v167, 0, sizeof(v167));
          long long v164 = 0u;
          long long v165 = 0u;
          long long v162 = 0u;
          long long v163 = 0u;
          long long v160 = 0u;
          long long v161 = 0u;
          *(_OWORD *)in = 0u;
          snprintf((char *)in, 0x95uLL, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n", *v139, v139[1], v139[2], v139[3]);
          v140 = "Input is not proper UTF-8, indicate encoding !\n%s";
          v142 = in;
          v141 = (_DWORD *)a1;
        }
        else
        {
          v140 = "Input is not proper UTF-8, indicate encoding !\n";
          v141 = (_DWORD *)a1;
          v142 = 0;
        }
        __xmlErrEncoding(v141, 9, v140, v142, 0);
        return;
      case 9:
        if (v15 < 2) {
          return;
        }
        if (a2) {
          goto LABEL_220;
        }
        if (*(_DWORD *)(a1 + 452))
        {
          if ((unint64_t)cur >= v156) {
            return;
          }
        }
        else if ((xmlParseLookupSequence(a1, 62, 0, 0) & 0x80000000) != 0)
        {
          return;
        }
LABEL_220:
        if (*(_DWORD *)(a1 + 504))
        {
          xmlParseEndTag2(a1, (void *)(*(void *)(a1 + 536) + 24 * *(int *)(a1 + 296) - 24));
          int v94 = *(_DWORD *)(a1 + 296);
          unsigned int v95 = v94 - 1;
          if (v94 >= 1)
          {
            *(_DWORD *)(a1 + 296) = v95;
            uint64_t v96 = *(void *)(a1 + 304);
            if (v94 == 1) {
              uint64_t v97 = 0;
            }
            else {
              uint64_t v97 = *(void *)(v96 + 8 * (v94 - 2));
            }
            *(void *)(a1 + 288) = v97;
            *(void *)(v96 + 8 * v95) = 0;
          }
        }
        else
        {
          xmlParseEndTag1((xmlParserCtxt *)a1);
        }
        if (*(_DWORD *)(a1 + 272) == -1) {
          return;
        }
        if (*(_DWORD *)(a1 + 296)) {
          goto LABEL_337;
        }
        int v5 = 14;
        goto LABEL_338;
      case 10:
        xmlGenericErrorFunc v58 = *__xmlGenericError();
        uint64_t v59 = *__xmlGenericErrorContext();
        v58(v59, "PP: internal error, state == ENTITY_DECL\n");
        goto LABEL_123;
      case 11:
        xmlGenericErrorFunc v26 = *__xmlGenericError();
        int v27 = *__xmlGenericErrorContext();
        unsigned int v28 = "PP: internal error, state == ENTITY_VALUE\n";
LABEL_117:
        v26(v27, v28);
        goto LABEL_337;
      case 12:
        xmlGenericErrorFunc v60 = *__xmlGenericError();
        unint64_t v61 = *__xmlGenericErrorContext();
        v60(v61, "PP: internal error, state == ATTRIBUTE_VALUE\n");
        goto LABEL_125;
      case 13:
        xmlGenericErrorFunc v62 = *__xmlGenericError();
        int v63 = *__xmlGenericErrorContext();
        v62(v63, "PP: internal error, state == SYSTEM_LITERAL\n");
        goto LABEL_125;
      case 14:
        xmlSkipBlankChars((xmlParserCtxtPtr)a1);
        uint64_t v64 = *(void *)(a1 + 56);
        if (*(void *)v64)
        {
          size_t v65 = xmlBufUse(*(const xmlBufPtr *)(*(void *)v64 + 32));
          uint64_t v64 = *(void *)(a1 + 56);
        }
        else
        {
          size_t v65 = *(int *)(v64 + 48);
        }
        int v81 = *(unsigned __int8 **)(v64 + 32);
        unint64_t v82 = v65 - (void)v81 + *(void *)(v64 + 24);
        if (v82 < 2) {
          return;
        }
        int v83 = *v81;
        int v84 = v81[1];
        if (v83 == 60 && v84 == 63)
        {
          if (!a2 && (xmlParseLookupSequence(a1, 63, 62, 0) & 0x80000000) != 0) {
            goto LABEL_385;
          }
          xmlParsePI((xmlParserCtxtPtr)a1);
LABEL_187:
          if (*(_DWORD *)(a1 + 272) == -1) {
            return;
          }
          int v5 = 14;
          goto LABEL_270;
        }
        if (v83 == 60 && v84 == 33)
        {
          if (v81[2] == 45 && v81[3] == 45)
          {
            if (!a2 && (xmlParseLookupSequence(a1, 45, 45, 62) & 0x80000000) != 0) {
              goto LABEL_396;
            }
            xmlParseComment((xmlParserCtxtPtr)a1);
            goto LABEL_187;
          }
          if (v82 < 4) {
            return;
          }
        }
        v143 = (_DWORD *)a1;
        int v144 = 5;
LABEL_390:
        xmlFatalErr(v143, v144, 0);
LABEL_391:
        xmlHaltParser((xmlParserCtxtPtr)a1);
        if (*(void *)a1)
        {
          v153 = *(void (**)(void))(*(void *)a1 + 104);
          if (v153) {
            v153(*(void *)(a1 + 8));
          }
        }
        return;
      case 15:
        xmlGenericErrorFunc v66 = *__xmlGenericError();
        unint64_t v67 = *__xmlGenericErrorContext();
        v66(v67, "PP: internal error, state == IGNORE");
        goto LABEL_123;
      case 16:
        xmlGenericErrorFunc v68 = *__xmlGenericError();
        int v69 = *__xmlGenericErrorContext();
        v68(v69, "PP: internal error, state == PUBLIC_LITERAL\n");
        goto LABEL_125;
      default:
        goto LABEL_339;
    }
  }
}

void xmlParseContentInternal(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 296);
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40) - *(void *)(*(void *)(a1 + 56) + 32)) <= 249)
  {
    xmlGROW(a1);
  }
  uint64_t v3 = *(void *)(a1 + 56);
  xmlDocPtr v4 = *(unsigned __int8 **)(v3 + 32);
  int v5 = *v4;
  if (*v4)
  {
    do
    {
      if (*(_DWORD *)(a1 + 272) == -1) {
        return;
      }
      uint64_t v6 = *(unsigned int *)(v3 + 64);
      if (v5 == 38)
      {
        xmlParseReference((xmlParserCtxtPtr)a1);
        goto LABEL_29;
      }
      if (v5 != 60)
      {
        xmlParseCharData((xmlParserCtxtPtr)a1, 0);
        goto LABEL_29;
      }
      int v7 = v4[1];
      switch(v7)
      {
        case '!':
          if (v4[2] == 91 && v4[3] == 67 && v4[4] == 68 && v4[5] == 65 && v4[6] == 84 && v4[7] == 65 && v4[8] == 91)
          {
            xmlParseCDSect((xmlParserCtxtPtr)a1);
            break;
          }
          if (v4[2] != 45 || v4[3] != 45) {
            goto LABEL_28;
          }
          xmlParseComment((xmlParserCtxtPtr)a1);
          if (*(_DWORD *)(a1 + 272) != -1) {
            *(_DWORD *)(a1 + 272) = 7;
          }
          break;
        case '/':
          if (*(_DWORD *)(a1 + 296) <= v2) {
            return;
          }
          xmlParseElementEnd((xmlParserCtxt *)a1);
          break;
        case '?':
          xmlParsePI((xmlParserCtxtPtr)a1);
          break;
        default:
LABEL_28:
          xmlParseElementStart(a1);
          break;
      }
LABEL_29:
      uint64_t v3 = *(void *)(a1 + 56);
      if (!*(_DWORD *)(a1 + 452))
      {
        if ((uint64_t)(*(void *)(v3 + 40) - *(void *)(v3 + 32)) > 249
          || (xmlGROW(a1), uint64_t v3 = *(void *)(a1 + 56), !*(_DWORD *)(a1 + 452)))
        {
          uint64_t v10 = *(void *)(v3 + 32);
          if (v10 - *(void *)(v3 + 24) >= 501 && *(void *)(v3 + 40) - v10 <= 499)
          {
            xmlSHRINK(a1);
            uint64_t v3 = *(void *)(a1 + 56);
          }
        }
      }
      uint64_t v8 = *(unsigned __int8 **)(v3 + 32);
      if (v6 == *(void *)(v3 + 64) && v4 == v8)
      {
        xmlFatalErr((_DWORD *)a1, 1, (const xmlChar *)"detected an error in element content\n");
        xmlHaltParser((xmlParserCtxtPtr)a1);
        return;
      }
      int v5 = *v8;
      xmlDocPtr v4 = *(unsigned __int8 **)(v3 + 32);
    }
    while (*v8);
  }
}

uint64_t xmlParseElementStart(uint64_t a1)
{
  uint64_t v52 = 0;
  int v53 = 0;
  int v2 = *(_DWORD *)(a1 + 508);
  if (*(_DWORD *)(a1 + 296) > xmlParserMaxDepth && (*(unsigned char *)(a1 + 566) & 8) == 0)
  {
    xmlFatalErrMsgInt((_DWORD *)a1, 1, "Excessive depth in document: %d use XML_PARSE_HUGE option\n", xmlParserMaxDepth);
    xmlHaltParser((xmlParserCtxtPtr)a1);
    return 0xFFFFFFFFLL;
  }
  memset(&info, 0, sizeof(info));
  if (*(_DWORD *)(a1 + 104))
  {
    uint64_t v3 = *(void *)(a1 + 56);
    unint64_t v4 = *(void *)(v3 + 64) + *(void *)(v3 + 32) - *(void *)(v3 + 24);
    unint64_t v5 = *(int *)(v3 + 52);
    info.begin_pos = v4;
    info.begin_int line = v5;
  }
  if (*(_DWORD *)(a1 + 376))
  {
    if (**(_DWORD **)(a1 + 368) == -2) {
      int v6 = -1;
    }
    else {
      int v6 = **(_DWORD **)(a1 + 368);
    }
  }
  else
  {
    int v6 = -1;
  }
  spacePush(a1, v6);
  int v7 = *(_DWORD *)(*(void *)(a1 + 56) + 52);
  if (*(_DWORD *)(a1 + 504)) {
    started = xmlParseStartTag2(a1, &v53, &v52, &v50);
  }
  else {
    started = (xmlChar *)xmlParseStartTag((xmlParserCtxtPtr)a1);
  }
  int v9 = started;
  if (*(_DWORD *)(a1 + 272) == -1) {
    return 0xFFFFFFFFLL;
  }
  if (started)
  {
    uint64_t v11 = v52;
    uint64_t v10 = v53;
    nameNsPush((void **)a1, started, (uint64_t)v53, v52, v7, *(_DWORD *)(a1 + 508) - v2);
    int v12 = *(const _xmlNode **)(a1 + 80);
    if (*(_DWORD *)(a1 + 156))
    {
      if (*(_DWORD *)(a1 + 24))
      {
        int v13 = *(xmlDoc **)(a1 + 16);
        if (v13)
        {
          if (v12 && v12 == v13->children) {
            *(_DWORD *)(a1 + 152) &= xmlValidateRoot((xmlValidCtxtPtr)(a1 + 160), v13);
          }
        }
      }
    }
    uint64_t v14 = *(xmlParserInput **)(a1 + 56);
    cur = v14->cur;
    int v16 = *cur;
    if (v16 == 62)
    {
      ++v14->col;
      v14->cur = cur + 1;
      if (!cur[1]) {
        xmlParserInputGrow(v14, 250);
      }
      if (v12 && *(_DWORD *)(a1 + 104))
      {
        info.end_pos = 0;
        info.end_int line = 0;
        info.node = v12;
        xmlParserAddNodeInfo((xmlParserCtxtPtr)a1, &info);
      }
      return 0;
    }
    else
    {
      if (v16 != 47 || cur[1] != 62)
      {
        xmlFatalErrMsgStrIntStr((_DWORD *)a1, 73, "Couldn't find end of Start Tag %s line %d\n", v9, v7, 0);
        int v24 = *(_DWORD *)(a1 + 88);
        unsigned int v25 = v24 - 1;
        if (v24 >= 1)
        {
          *(_DWORD *)(a1 + 88) = v25;
          uint64_t v26 = *(void *)(a1 + 96);
          if (v24 == 1) {
            uint64_t v27 = 0;
          }
          else {
            uint64_t v27 = *(void *)(v26 + 8 * (v24 - 2));
          }
          *(void *)(a1 + 80) = v27;
          *(void *)(v26 + 8 * v25) = 0;
        }
        int v28 = *(_DWORD *)(a1 + 296);
        unsigned int v29 = v28 - 1;
        if (v28 >= 1)
        {
          *(_DWORD *)(a1 + 296) = v29;
          uint64_t v30 = *(void *)(a1 + 304);
          if (v28 == 1) {
            uint64_t v31 = 0;
          }
          else {
            uint64_t v31 = *(void *)(v30 + 8 * (v28 - 2));
          }
          *(void *)(a1 + 288) = v31;
          *(void *)(v30 + 8 * v29) = 0;
        }
        int v32 = *(_DWORD *)(a1 + 376);
        if (v32 >= 1)
        {
          unsigned int v33 = v32 - 2;
          unsigned int v34 = v32 - 1;
          *(_DWORD *)(a1 + 376) = v34;
          uint64_t v35 = *(void *)(a1 + 384);
          if (!v34) {
            unsigned int v33 = 0;
          }
          *(void *)(a1 + 368) = v35 + 4 * v33;
          *(_DWORD *)(v35 + 4 * v34) = -1;
        }
        int v36 = *(_DWORD *)(a1 + 508);
        if (v36 != v2) {
          nsPop(a1, v36 - v2);
        }
        return 0xFFFFFFFFLL;
      }
      v14->cur = cur + 2;
      v14->col += 2;
      if (!cur[2]) {
        xmlParserInputGrow(v14, 250);
      }
      uint64_t v17 = *(void *)a1;
      if (*(_DWORD *)(a1 + 504))
      {
        if (v17)
        {
          int v18 = *(void (**)(void, const xmlChar *, const xmlChar *, uint64_t))(v17 + 240);
          if (v18)
          {
            if (!*(_DWORD *)(a1 + 332)) {
              v18(*(void *)(a1 + 8), v9, v10, v11);
            }
          }
        }
      }
      else if (v17)
      {
        int v37 = *(void (**)(void, const xmlChar *))(v17 + 120);
        if (v37)
        {
          if (!*(_DWORD *)(a1 + 332)) {
            v37(*(void *)(a1 + 8), v9);
          }
        }
      }
      int v38 = *(_DWORD *)(a1 + 296);
      unsigned int v39 = v38 - 1;
      if (v38 >= 1)
      {
        *(_DWORD *)(a1 + 296) = v39;
        uint64_t v40 = *(void *)(a1 + 304);
        if (v38 == 1) {
          uint64_t v41 = 0;
        }
        else {
          uint64_t v41 = *(void *)(v40 + 8 * (v38 - 2));
        }
        *(void *)(a1 + 288) = v41;
        *(void *)(v40 + 8 * v39) = 0;
      }
      int v42 = *(_DWORD *)(a1 + 376);
      if (v42 >= 1)
      {
        unsigned int v43 = v42 - 2;
        unsigned int v44 = v42 - 1;
        *(_DWORD *)(a1 + 376) = v44;
        uint64_t v45 = *(void *)(a1 + 384);
        if (!v44) {
          unsigned int v43 = 0;
        }
        *(void *)(a1 + 368) = v45 + 4 * v43;
        *(_DWORD *)(v45 + 4 * v44) = -1;
      }
      int v46 = *(_DWORD *)(a1 + 508);
      if (v46 != v2) {
        nsPop(a1, v46 - v2);
      }
      if (v12)
      {
        if (*(_DWORD *)(a1 + 104))
        {
          uint64_t v47 = *(void *)(a1 + 56);
          unint64_t v48 = *(void *)(v47 + 64) + *(void *)(v47 + 32) - *(void *)(v47 + 24);
          info.node = v12;
          unint64_t v49 = *(int *)(v47 + 52);
          info.end_pos = v48;
          info.end_int line = v49;
          xmlParserAddNodeInfo((xmlParserCtxtPtr)a1, &info);
        }
      }
      return 1;
    }
  }
  else
  {
    int v19 = *(_DWORD *)(a1 + 376);
    uint64_t result = 0xFFFFFFFFLL;
    if (v19 >= 1)
    {
      unsigned int v21 = v19 - 2;
      unsigned int v22 = v19 - 1;
      *(_DWORD *)(a1 + 376) = v22;
      uint64_t v23 = *(void *)(a1 + 384);
      if (!v22) {
        unsigned int v21 = 0;
      }
      *(void *)(a1 + 368) = v23 + 4 * v21;
      *(_DWORD *)(v23 + 4 * v22) = -1;
    }
  }
  return result;
}

_DWORD *spacePush(uint64_t a1, int a2)
{
  int v4 = *(_DWORD *)(a1 + 376);
  uint64_t v5 = *(int *)(a1 + 380);
  if (v4 < (int)v5)
  {
    uint64_t result = *(_DWORD **)(a1 + 384);
LABEL_5:
    result[v4] = a2;
    uint64_t v7 = *(int *)(a1 + 376);
    *(void *)(a1 + 368) = &result[v7];
    *(_DWORD *)(a1 + 376) = v7 + 1;
    return result;
  }
  *(_DWORD *)(a1 + 380) = 2 * v5;
  uint64_t result = xmlRealloc(*(void **)(a1 + 384), 8 * v5);
  if (result)
  {
    *(void *)(a1 + 384) = result;
    int v4 = *(_DWORD *)(a1 + 376);
    goto LABEL_5;
  }
  uint64_t result = htmlErrMemory((_DWORD *)a1, 0);
  *(int *)(a1 + 380) /= 2;
  return result;
}

void **nameNsPush(void **result, void *a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  uint64_t v11 = result;
  uint64_t v12 = *((int *)result + 75);
  if (*((_DWORD *)result + 74) >= (int)v12)
  {
    *((_DWORD *)result + 75) = 2 * v12;
    int v13 = xmlRealloc(result[38], 16 * v12);
    if (!v13 || (v11[38] = v13, (uint64_t result = (void **)xmlRealloc(v11[67], 24 * *((int *)v11 + 75))) == 0))
    {
      *((int *)v11 + 75) /= 2;
      goto LABEL_10;
    }
    v11[67] = result;
LABEL_8:
    uint64_t v14 = *((int *)v11 + 74);
    *((void *)v11[38] + v14) = a2;
    v11[36] = a2;
    uint64_t v15 = (uint64_t)v11[67] + 24 * (int)v14;
    *(void *)uint64_t v15 = a3;
    *(void *)(v15 + 8) = a4;
    *(_DWORD *)(v15 + 16) = a5;
    *(_DWORD *)(v15 + 20) = a6;
    *((_DWORD *)v11 + 74) = v14 + 1;
    return result;
  }
  if (result[67]) {
    goto LABEL_8;
  }
  uint64_t result = (void **)xmlMalloc(24 * v12);
  v11[67] = result;
  if (result) {
    goto LABEL_8;
  }
LABEL_10:

  return (void **)htmlErrMemory(v11, 0);
}

void xmlParseElementEnd(xmlParserCtxt *a1)
{
  int nameNr = a1->nameNr;
  BOOL v2 = __OFSUB__(nameNr, 1);
  int v3 = nameNr - 1;
  if (v3 < 0 != v2) {
    return;
  }
  node = a1->node;
  if (!a1->sax2)
  {
    xmlParseEndTag1(a1);
LABEL_8:
    if (!node) {
      return;
    }
    goto LABEL_11;
  }
  xmlParseEndTag2((uint64_t)a1, (void *)a1->pushTab + 3 * v3);
  int v6 = a1->nameNr;
  unsigned int v7 = v6 - 1;
  if (v6 < 1) {
    goto LABEL_8;
  }
  a1->int nameNr = v7;
  nameTab = a1->nameTab;
  if (v6 == 1) {
    int v9 = 0;
  }
  else {
    int v9 = nameTab[v6 - 2];
  }
  a1->name = v9;
  nameTab[v7] = 0;
  if (node)
  {
LABEL_11:
    if (a1->record_info)
    {
      NodeInfo = xmlParserFindNodeInfo(a1, node);
      if (NodeInfo)
      {
        xmlParserInputPtr input = a1->input;
        unint64_t v12 = &input->cur[input->consumed] - input->base;
        unint64_t line = input->line;
        NodeInfo->end_pos = v12;
        NodeInfo->end_unint64_t line = line;
      }
    }
  }
}

void xmlParseCharData(xmlParserCtxtPtr ctxt, int cdata)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  xmlParserInputPtr input = ctxt->input;
  int line = input->line;
  int col = input->col;
  if (!ctxt->progressive)
  {
    cur = input->cur;
    if (cur - input->base < 501
      || input->end - cur > 499
      || (xmlSHRINK((uint64_t)ctxt), xmlParserInputPtr input = ctxt->input, !ctxt->progressive))
    {
      if (input->end - input->cur <= 249)
      {
        xmlGROW((uint64_t)ctxt);
        xmlParserInputPtr input = ctxt->input;
      }
    }
  }
  if (!cdata)
  {
    unsigned int v25 = input->cur;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v26 = *v25;
          if (v26 != 10) {
            break;
          }
          int v27 = input->line + 1;
          do
          {
            input->int line = v27;
            input->int col = 1;
            int v28 = *++v25;
            ++v27;
          }
          while (v28 == 10);
        }
        if (v26 != 32) {
          break;
        }
        ++v25;
        ++input->col;
      }
      if (v26 == 60)
      {
        unint64_t v48 = (unsigned __int8 *)input->cur;
        if ((int)v25 - (int)v48 < 1) {
          return;
        }
        input->cur = v25;
        sax = ctxt->sax;
        if (!ctxt->sax) {
          return;
        }
        ignorableWhitespace = (void (*)(void, void, void))sax->ignorableWhitespace;
        if (ignorableWhitespace != (void (*)(void, void, void))sax->characters)
        {
          int v51 = areBlanks_0(ctxt, v48, (int)v25 - (int)v48, 1);
          uint64_t v52 = ctxt->sax;
          if (!v51)
          {
            characters = (void (*)(void, void, void))v52->characters;
            if (characters) {
              characters(ctxt->userData, v48, (v25 - v48));
            }
            space = ctxt->space;
            if (*space == -1) {
              int *space = -2;
            }
            return;
          }
          ignorableWhitespace = (void (*)(void, void, void))v52->ignorableWhitespace;
        }
        if (ignorableWhitespace)
        {
          userData = ctxt->userData;
          ignorableWhitespace(userData, v48, (v25 - v48));
        }
        return;
      }
      int v29 = input->col;
      while (1)
      {
        while (1)
        {
          if (test_char_data[v26])
          {
            uint64_t v30 = v25;
            do
            {
              int v31 = *++v30;
              ++v29;
            }
            while (test_char_data[v31]);
          }
          else
          {
            uint64_t v30 = v25;
          }
          input->int col = v29;
          int v32 = *v30;
          if (v32 != 93) {
            break;
          }
          unsigned int v25 = v30 + 1;
          if (v30[1] == 93 && v30[2] == 62)
          {
            xmlFatalErr(ctxt, 62, 0);
            if (ctxt->instate != XML_PARSER_EOF) {
              ctxt->input->cur = v25;
            }
            return;
          }
          input->int col = ++v29;
          uint64_t v26 = *v25;
        }
        if (v32 != 10) {
          break;
        }
        int v33 = input->line + 1;
        do
        {
          int v29 = 1;
          input->int line = v33;
          input->int col = 1;
          unsigned int v34 = *++v30;
          uint64_t v26 = v34;
          ++v33;
        }
        while (v34 == 10);
        unsigned int v25 = v30;
      }
      uint64_t v35 = (unsigned __int8 *)input->cur;
      if ((int)v30 - (int)v35 >= 1)
      {
        int v36 = ctxt->sax;
        if (ctxt->sax)
        {
          p_characters = &v36->characters;
          int v37 = (void (*)(void, void, void))v36->characters;
          if ((char *)p_characters[1] == (char *)v37
            || ((v39 = *v35, BOOL v17 = v39 > 0x20, v40 = (1 << v39) & 0x100002600, !v17) ? (v41 = v40 == 0) : (v41 = 1),
                v41))
          {
            if (v37)
            {
              v37(ctxt->userData, input->cur, (v30 - v35));
              xmlParserInputPtr input = ctxt->input;
              int v29 = input->col;
            }
            int line = input->line;
            int col = v29;
          }
          else
          {
            input->cur = v30;
            int v42 = areBlanks_0(ctxt, v35, (int)v30 - (int)v35, 0);
            unsigned int v43 = ctxt->sax;
            if (v42)
            {
              unsigned int v44 = (void (*)(void, void, void))v43->ignorableWhitespace;
              if (v44) {
                v44(ctxt->userData, v35, (v30 - v35));
              }
            }
            else
            {
              uint64_t v45 = (void (*)(void, void, void))v43->characters;
              if (v45) {
                v45(ctxt->userData, v35, (v30 - v35));
              }
              int v46 = ctxt->space;
              if (*v46 == -1) {
                *int v46 = -2;
              }
            }
            xmlParserInputPtr input = ctxt->input;
            int line = input->line;
            int col = input->col;
          }
        }
        if (ctxt->instate == XML_PARSER_EOF) {
          return;
        }
      }
      input->cur = v30;
      int v47 = *v30;
      if (v47 != 13) {
        break;
      }
      if (v30[1] != 10) {
        goto LABEL_117;
      }
      input->cur = v30 + 1;
      unsigned int v25 = v30 + 2;
      ++input->line;
      input->int col = 1;
LABEL_125:
      if (*(char *)v25 <= 31 && *v25 - 9 >= 2) {
        goto LABEL_8;
      }
    }
    if (v47 == 38 || v47 == 60) {
      return;
    }
LABEL_117:
    if (!ctxt->progressive)
    {
      if (v30 - input->base < 501 || input->end - v30 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
      {
        if (ctxt->input->end - ctxt->input->cur <= 249) {
          xmlGROW((uint64_t)ctxt);
        }
      }
    }
    if (ctxt->instate == XML_PARSER_EOF) {
      return;
    }
    xmlParserInputPtr input = ctxt->input;
    unsigned int v25 = input->cur;
    goto LABEL_125;
  }
LABEL_8:
  input->int line = line;
  input->int col = col;
  char v66 = 0;
  memset(v65, 0, sizeof(v65));
  if (!ctxt->progressive)
  {
    uint64_t v8 = input->cur;
    if (v8 - input->base < 501 || input->end - v8 > 499)
    {
LABEL_13:
      if (input->end - v8 <= 249) {
        xmlGROW((uint64_t)ctxt);
      }
      goto LABEL_15;
    }
    xmlSHRINK((uint64_t)ctxt);
    if (!ctxt->progressive)
    {
      xmlParserInputPtr input = ctxt->input;
      uint64_t v8 = input->cur;
      goto LABEL_13;
    }
  }
LABEL_15:
  int len = 0;
  int v9 = xmlCurrentChar(ctxt, &len);
  uint64_t v10 = 0;
  int v11 = 0;
  while (v9 != 38 && v9 != 60)
  {
    if (v9 > 255)
    {
      if (v9 >> 11 >= 0x1B
        && (v9 - 57344) >> 1 >= 0xFFF
        && (v9 - 0x10000) >= 0x100000)
      {
        break;
      }
    }
    else if (v9 > 0xD || ((1 << v9) & 0x2600) == 0)
    {
      if (v9 <= 31) {
        break;
      }
      if (v9 == 93)
      {
        unint64_t v12 = ctxt->input->cur;
        if (v12[1] == 93 && v12[2] == 62)
        {
          if (cdata) {
            break;
          }
          xmlFatalErr(ctxt, 62, 0);
        }
      }
    }
    if (len == 1)
    {
      *((unsigned char *)v65 + (int)v10) = v9;
      uint64_t v10 = (v10 + 1);
      int v13 = 1;
    }
    else
    {
      uint64_t v10 = (xmlCopyCharMultiByte((xmlChar *)v65 + (int)v10, v9) + v10);
      int v13 = len;
    }
    xmlParserInputPtr v14 = ctxt->input;
    uint64_t v15 = v14->cur;
    int v16 = &v15[v13];
    if (v16 <= v14->end)
    {
      if (*v15 == 10)
      {
        ++v14->line;
        v14->int col = 1;
      }
      else
      {
        ++v14->col;
      }
      v14->cur = v16;
    }
    int v9 = xmlCurrentChar(ctxt, &len);
    if ((int)v10 >= 300)
    {
      *((unsigned char *)v65 + v10) = 0;
      if (ctxt->sax && !ctxt->disableSAX)
      {
        int v20 = areBlanks_0(ctxt, (unsigned __int8 *)v65, v10, 0);
        unsigned int v21 = ctxt->sax;
        if (v20)
        {
          unsigned int v22 = (void (*)(void, void, void))v21->ignorableWhitespace;
          if (v22) {
            v22(ctxt->userData, v65, v10);
          }
        }
        else
        {
          charactersSAXFunc v23 = v21->characters;
          if (v23)
          {
            ((void (*)(void *, _OWORD *, uint64_t))v23)(ctxt->userData, v65, v10);
            unsigned int v21 = ctxt->sax;
            charactersSAXFunc v23 = ctxt->sax->characters;
          }
          if (v23 != v21->ignorableWhitespace)
          {
            int v24 = ctxt->space;
            if (*v24 == -1) {
              int *v24 = -2;
            }
          }
        }
      }
      if (ctxt->instate != XML_PARSER_CONTENT) {
        return;
      }
      uint64_t v10 = 0;
    }
    BOOL v17 = v11++ < 50;
    if (!v17)
    {
      if (!ctxt->progressive)
      {
        xmlParserInputPtr v18 = ctxt->input;
        int v19 = v18->cur;
        if (v19 - v18->base < 501 || v18->end - v19 > 499) {
          goto LABEL_49;
        }
        xmlSHRINK((uint64_t)ctxt);
        if (!ctxt->progressive)
        {
          xmlParserInputPtr v18 = ctxt->input;
          int v19 = v18->cur;
LABEL_49:
          if (v18->end - v19 <= 249) {
            xmlGROW((uint64_t)ctxt);
          }
        }
      }
      int v11 = 0;
      if (ctxt->instate == XML_PARSER_EOF) {
        return;
      }
    }
  }
  if (v10)
  {
    *((unsigned char *)v65 + (int)v10) = 0;
    if (ctxt->sax)
    {
      if (!ctxt->disableSAX)
      {
        int v57 = areBlanks_0(ctxt, (unsigned __int8 *)v65, v10, 0);
        xmlGenericErrorFunc v58 = ctxt->sax;
        if (v57)
        {
          uint64_t v59 = (void (*)(void, void, void))v58->ignorableWhitespace;
          if (v59) {
            v59(ctxt->userData, v65, v10);
          }
        }
        else
        {
          charactersSAXFunc v60 = v58->characters;
          if (v60)
          {
            ((void (*)(void *, _OWORD *, uint64_t))v60)(ctxt->userData, v65, v10);
            xmlGenericErrorFunc v58 = ctxt->sax;
            charactersSAXFunc v60 = ctxt->sax->characters;
          }
          if (v60 != v58->ignorableWhitespace)
          {
            unint64_t v61 = ctxt->space;
            if (*v61 == -1) {
              int *v61 = -2;
            }
          }
        }
      }
    }
  }
  if (v9)
  {
    if (v9 > 255)
    {
      if ((v9 - 57344) >> 1 >= 0xFFF && (v9 - 0x10000) >= 0x100000) {
        goto LABEL_139;
      }
    }
    else if (v9 <= 31 && (v9 > 0xD || ((1 << v9) & 0x2600) == 0))
    {
LABEL_139:
      xmlFatalErrMsgInt(ctxt, 9, "PCDATA invalid Char value %d\n", v9);
      xmlParserInputPtr v54 = ctxt->input;
      int v55 = v54->cur;
      uint64_t v56 = &v55[len];
      if (v56 <= v54->end)
      {
        if (*v55 == 10)
        {
          ++v54->line;
          v54->int col = 1;
        }
        else
        {
          ++v54->col;
        }
        v54->cur = v56;
      }
    }
  }
}

xmlParserInput *xmlSHRINK(uint64_t a1)
{
  xmlParserInputShrink(*(xmlParserInputPtr *)(a1 + 56));
  uint64_t result = *(xmlParserInput **)(a1 + 56);
  if (!*result->cur)
  {
    return (xmlParserInput *)xmlParserInputGrow(result, 250);
  }
  return result;
}

void xmlParserInputShrink(xmlParserInputPtr in)
{
  if (in)
  {
    if (in->buf)
    {
      base = in->base;
      if (base)
      {
        cur = in->cur;
        if (cur)
        {
          xmlBufPtr buffer = in->buf->buffer;
          if (buffer)
          {
            int64_t v5 = cur - base;
            if ((unint64_t)(cur - base) >= 0xFB)
            {
              size_t v6 = xmlBufShrink(buffer, v5 - 80);
              if (v6)
              {
                v5 -= v6;
                in->consumed += v6;
              }
            }
            if (xmlBufUse(in->buf->buffer) <= 0xFA) {
              xmlParserInputBufferRead(in->buf, 500);
            }
            unsigned int v7 = xmlBufContent(in->buf->buffer);
            in->base = v7;
            in->cur = &v7[v5];
            in->end = xmlBufEnd(in->buf->buffer);
          }
        }
      }
    }
  }
}

size_t xmlBufShrink(xmlBufPtr buf, size_t len)
{
  if (!buf || *((_DWORD *)buf + 14)) {
    return 0;
  }
  size_t v3 = len;
  uint64_t v4 = *((void *)buf + 5);
  uint64_t v5 = *((unsigned int *)buf + 3);
  if (v5 <= 0x7FFFFFFE && v4 != v5)
  {
    *((void *)buf + 5) = v5;
    uint64_t v4 = v5;
  }
  size_t v7 = *((void *)buf + 4);
  size_t v8 = *((unsigned int *)buf + 2);
  if (v8 <= 0x7FFFFFFE && v7 != v8)
  {
    *((void *)buf + 4) = v8;
    size_t v7 = v8;
  }
  if (len - 1 >= v7) {
    return 0;
  }
  size_t v10 = v7 - len;
  *((void *)buf + 4) = v7 - len;
  int v11 = *((_DWORD *)buf + 4);
  if (v11 == 2)
  {
    *(void *)buf += len;
    unint64_t v14 = v4 - len;
    goto LABEL_23;
  }
  if (v11 == 3 && (unint64_t v12 = (unsigned char *)*((void *)buf + 3)) != 0)
  {
    int v13 = (unsigned char *)(*(void *)buf + len);
    *(void *)xmlParserInputBufferPtr buf = v13;
    unint64_t v14 = v4 - v3;
    *((void *)buf + 5) = v14;
    int64_t v15 = v13 - v12;
    if (v13 - v12 >= v14)
    {
      memmove(v12, v13, v10);
      uint64_t v16 = *((void *)buf + 3);
      uint64_t v17 = *((void *)buf + 4);
      *(void *)xmlParserInputBufferPtr buf = v16;
      *(unsigned char *)(v16 + v17) = 0;
      unint64_t v14 = *((void *)buf + 5) + v15;
LABEL_23:
      *((void *)buf + 5) = v14;
    }
  }
  else
  {
    memmove(*(void **)buf, (const void *)(*(void *)buf + len), v10);
    *(unsigned char *)(*(void *)buf + *((void *)buf + 4)) = 0;
    unint64_t v14 = *((void *)buf + 5);
  }
  LODWORD(v19) = 0x7FFFFFFF;
  if (v14 >= 0x7FFFFFFF) {
    LODWORD(v14) = 0x7FFFFFFF;
  }
  if (*((void *)buf + 4) < 0x7FFFFFFFuLL) {
    uint64_t v19 = *((void *)buf + 4);
  }
  *((_DWORD *)buf + 2) = v19;
  *((_DWORD *)buf + 3) = v14;
  return v3;
}

uint64_t xmlSAX2Text(uint64_t result, char *__src, int len, int a4)
{
  if (!result) {
    return result;
  }
  uint64_t v4 = result;
  uint64_t v5 = *(void *)(result + 80);
  if (!v5) {
    return result;
  }
  uint64_t v8 = *(void *)(v5 + 32);
  if (!v8)
  {
    if (a4 == 3)
    {
      uint64_t result = (uint64_t)xmlSAX2TextNode(result, __src, len);
      if (!result) {
        goto LABEL_46;
      }
    }
    else
    {
      uint64_t result = (uint64_t)xmlNewCDataBlock(*(xmlDocPtr *)(result + 16), (const xmlChar *)__src, len);
      if (!result) {
        goto LABEL_46;
      }
    }
    unint64_t v12 = *(void **)(v4 + 80);
    v12[3] = result;
    v12[4] = result;
    *(void *)(result + 40) = v12;
    *(void *)(result + 64) = v12[8];
    goto LABEL_22;
  }
  if (*(_DWORD *)(v8 + 8) != a4)
  {
    if (a4 != 3)
    {
      uint64_t result = (uint64_t)xmlNewCDataBlock(*(xmlDocPtr *)(result + 16), (const xmlChar *)__src, len);
      goto LABEL_20;
    }
LABEL_16:
    uint64_t result = (uint64_t)xmlSAX2TextNode(result, __src, len);
LABEL_20:
    if (!result) {
      return result;
    }
    uint64_t result = (uint64_t)xmlAddChild(*(xmlNodePtr *)(v4 + 80), (xmlNodePtr)result);
    if (!*(void *)(*(void *)(v4 + 80) + 24)) {
      return result;
    }
LABEL_22:
    *(_DWORD *)(v4 + 412) = len;
    int v13 = len + 1;
LABEL_23:
    *(_DWORD *)(v4 + 416) = v13;
    return result;
  }
  if (a4 == 3 && *(const xmlChar **)(v8 + 16) != "text") {
    goto LABEL_16;
  }
  int v9 = *(_DWORD *)(result + 416);
  if (v9)
  {
    size_t v10 = *(xmlChar **)(v8 + 80);
    if (v10 == (xmlChar *)(v8 + 88))
    {
      unint64_t v14 = xmlStrdup(*(const xmlChar **)(v8 + 80));
      *(void *)size_t v10 = 0;
      *(void *)(v8 + 80) = v14;
      size_t v10 = v14;
    }
    else if (v9 == *(_DWORD *)(result + 412) + 1)
    {
      int v11 = xmlDictOwns(*(xmlDictPtr *)(result + 456), *(const xmlChar **)(v8 + 80));
      size_t v10 = *(xmlChar **)(v8 + 80);
      if (v11)
      {
        size_t v10 = xmlStrdup(*(const xmlChar **)(v8 + 80));
        *(void *)(v8 + 80) = v10;
      }
    }
    if (!v10)
    {
      uint64_t v16 = "xmlSAX2Characters: xmlStrdup returned NULL";
      goto LABEL_47;
    }
    int v15 = *(_DWORD *)(v4 + 412);
    if (v15 > (len ^ 0x7FFFFFFF))
    {
      uint64_t v16 = "xmlSAX2Characters overflow prevented";
LABEL_47:
      return (uint64_t)xmlSAX2ErrMemory((uint64_t *)v4, v16);
    }
    if (v15 + len >= 10000001 && (*(unsigned char *)(v4 + 566) & 8) == 0)
    {
      uint64_t v16 = "xmlSAX2Characters: huge text node";
      goto LABEL_47;
    }
    int v17 = *(_DWORD *)(v4 + 416);
    if (v15 + len < v17)
    {
LABEL_45:
      uint64_t result = (uint64_t)memcpy(&v10[v15], __src, len);
      uint64_t v21 = *(int *)(v4 + 412) + (uint64_t)len;
      *(_DWORD *)(v4 + 412) = v21;
      *(unsigned char *)(*(void *)(v8 + 80) + v21) = 0;
      return result;
    }
    int v18 = v17 + len;
    if (v17 > (len ^ 0x7FFFFFFF)) {
      int v18 = 0x7FFFFFFF;
    }
    if (v18 <= 0x3FFFFFFF) {
      int v19 = 2 * v18;
    }
    else {
      int v19 = 0x7FFFFFFF;
    }
    int v20 = (xmlChar *)xmlRealloc(v10, v19);
    if (v20)
    {
      size_t v10 = v20;
      *(_DWORD *)(v4 + 416) = v19;
      *(void *)(v8 + 80) = v20;
      int v15 = *(_DWORD *)(v4 + 412);
      goto LABEL_45;
    }
LABEL_46:
    uint64_t v16 = "xmlSAX2Characters";
    goto LABEL_47;
  }
  uint64_t result = xmlTextConcat((xmlNodePtr)v8, (const xmlChar *)__src, len);
  if (result) {
    uint64_t result = (uint64_t)xmlSAX2ErrMemory((uint64_t *)v4, "xmlSAX2Characters");
  }
  if (*(void *)(*(void *)(v4 + 80) + 24))
  {
    uint64_t result = xmlStrlen(*(const xmlChar **)(v8 + 80));
    *(_DWORD *)(v4 + 412) = result;
    int v13 = result + 1;
    goto LABEL_23;
  }
  return result;
}

void xmlSAX2Characters(void *ctx, const xmlChar *ch, int len)
{
}

int xmlParserInputBufferRead(xmlParserInputBufferPtr in, int len)
{
  if (!in || in->error) {
    return -1;
  }
  if (in->readcallback)
  {
    return xmlParserInputBufferGrow(in, len);
  }
  else if (xmlBufGetAllocationScheme((uint64_t)in->buffer) == 2)
  {
    return 0;
  }
  else
  {
    return -1;
  }
}

uint64_t areBlanks(uint64_t a1, unsigned __int8 *a2, int a3)
{
  if (a3 >= 1)
  {
    uint64_t v4 = a3;
    do
    {
      unsigned int v5 = *a2++;
      uint64_t v6 = (1 << v5) & 0x100002600;
      if (v5 > 0x20 || v6 == 0) {
        return 0;
      }
    }
    while (--v4);
  }
  if (!**(unsigned char **)(*(void *)(a1 + 56) + 32)) {
    return 1;
  }
  if (**(unsigned char **)(*(void *)(a1 + 56) + 32) != 60) {
    return 0;
  }
  uint64_t v8 = *(const xmlChar **)(a1 + 288);
  if (!v8) {
    return 1;
  }
  if (xmlStrEqual(v8, (const xmlChar *)"html")) {
    return 1;
  }
  if (xmlStrEqual(*(const xmlChar **)(a1 + 288), (const xmlChar *)"head")) {
    return 1;
  }
  if (xmlStrEqual(*(const xmlChar **)(a1 + 288), (const xmlChar *)"body"))
  {
    size_t v10 = *(const xmlDoc **)(a1 + 16);
    if (v10)
    {
      xmlDtdPtr IntSubset = xmlGetIntSubset(v10);
      if (IntSubset)
      {
        xmlDtdPtr v12 = IntSubset;
        ExternalID = IntSubset->ExternalID;
        if (ExternalID)
        {
          if (!xmlStrcasecmp(ExternalID, (const xmlChar *)"-//W3C//DTD HTML 4.01//EN")
            || !xmlStrcasecmp(v12->ExternalID, (const xmlChar *)"-//W3C//DTD HTML 4//EN"))
          {
            return 1;
          }
        }
      }
    }
  }
  uint64_t result = *(void *)(a1 + 80);
  if (!result) {
    return result;
  }
  xmlNodePtr LastChild = xmlGetLastChild((const xmlNode *)result);
  if (LastChild)
  {
    xmlNodePtr v15 = LastChild;
    while (v15->type == XML_COMMENT_NODE)
    {
      xmlNodePtr v15 = v15->prev;
      if (!v15) {
        goto LABEL_25;
      }
    }
    if (!xmlNodeIsText(v15))
    {
      uint64_t v18 = 0;
      while (!xmlStrEqual(v15->name, (const xmlChar *)allowPCData[v18]))
      {
        ++v18;
        uint64_t result = 1;
        if (v18 == 53) {
          return result;
        }
      }
    }
  }
  else
  {
LABEL_25:
    uint64_t v16 = *(void *)(a1 + 80);
    if (*(_DWORD *)(v16 + 8) == 1 || !*(void *)(v16 + 80))
    {
      uint64_t v17 = 0;
      while (!xmlStrEqual(*(const xmlChar **)(a1 + 288), (const xmlChar *)allowPCData[v17]))
      {
        ++v17;
        uint64_t result = 1;
        if (v17 == 53) {
          return result;
        }
      }
    }
  }
  return 0;
}

uint64_t areBlanks_0(void *a1, unsigned __int8 *a2, int a3, int a4)
{
  if (*(void *)(*a1 + 144) == *(void *)(*a1 + 136)) {
    return 0;
  }
  unsigned int v5 = (int *)a1[46];
  if (!v5) {
    return 0;
  }
  int v6 = *v5;
  if (v6 == -2 || v6 == 1) {
    return 0;
  }
  if (!a4 && a3 >= 1)
  {
    uint64_t v9 = a3;
    do
    {
      unsigned int v10 = *a2++;
      uint64_t v11 = (1 << v10) & 0x100002600;
      if (v10 > 0x20 || v11 == 0) {
        return 0;
      }
    }
    while (--v9);
  }
  uint64_t v13 = a1[10];
  if (!v13) {
    return 0;
  }
  unint64_t v14 = (xmlDoc *)a1[2];
  if (!v14)
  {
LABEL_21:
    uint64_t v16 = *(unsigned __int8 **)(a1[7] + 32);
    int v17 = *v16;
    if (v17 == 60 || v17 == 13)
    {
      int v19 = (const xmlNode *)a1[10];
      BOOL v20 = v17 == 60 && v19->children == 0;
      if (!v20 || v16[1] != 47)
      {
        xmlNodePtr LastChild = xmlGetLastChild(v19);
        if (LastChild)
        {
          if (!xmlNodeIsText(LastChild))
          {
            unsigned int v22 = *(const xmlNode **)(a1[10] + 24);
            if (!v22 || !xmlNodeIsText(v22)) {
              return 1;
            }
          }
        }
        else
        {
          uint64_t v23 = a1[10];
          if (*(_DWORD *)(v23 + 8) == 1 || !*(void *)(v23 + 80)) {
            return 1;
          }
        }
      }
    }
    return 0;
  }
  int IsMixedElement = xmlIsMixedElement(v14, *(const xmlChar **)(v13 + 16));
  if (IsMixedElement)
  {
    if (IsMixedElement == 1) {
      return 0;
    }
    goto LABEL_21;
  }
  return 1;
}

void xmlInitCharEncodingHandlers(void)
{
  if (!handlers)
  {
    handlers = (uint64_t)xmlMalloc(0x190uLL);
    if (handlers)
    {
      xmlNewCharEncodingHandler("UTF-8", (xmlCharEncodingInputFunc)UTF8ToUTF8, (xmlCharEncodingOutputFunc)UTF8ToUTF8);
      xmlUTF16LEHandler = (uint64_t)xmlNewCharEncodingHandler("UTF-16LE", (xmlCharEncodingInputFunc)UTF16LEToUTF8, (xmlCharEncodingOutputFunc)UTF8ToUTF16LE);
      xmlUTF16BEHandler = (uint64_t)xmlNewCharEncodingHandler("UTF-16BE", (xmlCharEncodingInputFunc)UTF16BEToUTF8, (xmlCharEncodingOutputFunc)UTF8ToUTF16BE);
      xmlNewCharEncodingHandler("UTF-16", (xmlCharEncodingInputFunc)UTF16LEToUTF8, (xmlCharEncodingOutputFunc)UTF8ToUTF16);
      xmlNewCharEncodingHandler("ISO-8859-1", isolat1ToUTF8, UTF8Toisolat1);
      xmlNewCharEncodingHandler("ASCII", (xmlCharEncodingInputFunc)asciiToUTF8, (xmlCharEncodingOutputFunc)UTF8Toascii);
      xmlNewCharEncodingHandler("US-ASCII", (xmlCharEncodingInputFunc)asciiToUTF8, (xmlCharEncodingOutputFunc)UTF8Toascii);
      xmlNewCharEncodingHandler("HTML", 0, UTF8ToHtml);
    }
    else
    {
      __xmlSimpleError(27, 2, 0, 0, (uint64_t)"xmlInitCharEncodingHandlers : out of memory !\n");
    }
  }
}

xmlCharEncodingHandlerPtr xmlNewCharEncodingHandler(const char *name, xmlCharEncodingInputFunc input, xmlCharEncodingOutputFunc output)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  EncodingAlias = xmlGetEncodingAlias(name);
  if (EncodingAlias) {
    size_t v7 = EncodingAlias;
  }
  else {
    size_t v7 = name;
  }
  if (!v7)
  {
    __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6000, 3, 0, 0, 0, 0, 0, 0, 0, "xmlNewCharEncodingHandler : no name !\n", 0);
    return 0;
  }
  uint64_t v8 = 0;
  int v46 = 0;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  *(_OWORD *)cur = 0u;
  do
  {
    char v9 = __toupper(v7[v8]);
    cur[v8] = v9;
    if (!v9) {
      break;
    }
    ++v8;
  }
  while (v8 != 499);
  cur[v8] = 0;
  unsigned int v10 = xmlMemStrdup(cur);
  if (!v10)
  {
    __xmlSimpleError(27, 2, 0, 0, (uint64_t)"xmlNewCharEncodingHandler : out of memory !\n");
    return 0;
  }
  uint64_t v11 = v10;
  xmlDtdPtr v12 = (xmlCharEncodingHandler *)xmlMalloc(0x28uLL);
  uint64_t v13 = v12;
  if (v12)
  {
    *(_OWORD *)&v12->name = 0u;
    *(_OWORD *)&v12->output = 0u;
    v12->uconv_in = 0;
    v12->uconv_out = 0;
    v12->name = v11;
    v12->xmlParserInputPtr input = input;
    v12->output = output;
    xmlRegisterCharEncodingHandler(v12);
  }
  else
  {
    xmlFree(v11);
    __xmlSimpleError(27, 2, 0, 0, (uint64_t)"xmlNewCharEncodingHandler : out of memory !\n");
  }
  return v13;
}

xmlChar *__cdecl xmlCharStrndup(const char *cur, int len)
{
  uint64_t result = 0;
  if (cur)
  {
    if ((len & 0x80000000) == 0)
    {
      uint64_t result = (xmlChar *)xmlMallocAtomic(len + 1);
      if (result)
      {
        if (len)
        {
          uint64_t v5 = 0;
          while (1)
          {
            int v6 = cur[v5];
            result[v5] = v6;
            if (!v6) {
              break;
            }
            if (len == ++v5) {
              goto LABEL_8;
            }
          }
        }
        else
        {
LABEL_8:
          result[len] = 0;
        }
      }
    }
  }
  return result;
}

xmlChar *__cdecl xmlCharStrdup(xmlChar *cur)
{
  if (cur)
  {
    uint64_t v1 = 0;
    while (cur[v1++])
      ;
    return xmlCharStrndup((const char *)cur, (int)v1 - 1);
  }
  return cur;
}

void xmlRegisterCharEncodingHandler(xmlCharEncodingHandlerPtr handler)
{
  uint64_t v2 = handlers;
  if (handlers)
  {
    if (!handler)
    {
LABEL_8:
      __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6001, 3, 0, 0, 0, 0, 0, 0, 0, "xmlRegisterCharEncodingHandler: NULL handler !\n", 0);
      if (!handler) {
        return;
      }
      goto LABEL_9;
    }
  }
  else
  {
    xmlInitCharEncodingHandlers();
    uint64_t v2 = handlers;
    if (!handler) {
      goto LABEL_8;
    }
  }
  if (!v2) {
    goto LABEL_8;
  }
  uint64_t v3 = nbCharEncodingHandler;
  if (nbCharEncodingHandler < 50)
  {
    ++nbCharEncodingHandler;
    *(void *)(v2 + 8 * vxmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = handler;
    return;
  }
  __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6002, 3, 0, 0, (const xmlChar *)"MAX_ENCODING_HANDLERS", 0, 0, 0, 0, "xmlRegisterCharEncodingHandler: Too many handler registered, see %s\n", (char)"MAX_ENCODING_HANDLERS");
LABEL_9:
  if (handler->name) {
    xmlFree(handler->name);
  }
  xmlFreeFunc v4 = xmlFree;

  ((void (*)(xmlCharEncodingHandlerPtr))v4)(handler);
}

const char *__cdecl xmlGetEncodingAlias(const char *alias)
{
  uint64_t result = 0;
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (alias && xmlCharEncodingAliases)
  {
    uint64_t v3 = 0;
    int v8 = 0;
    memset(v7, 0, sizeof(v7));
    do
    {
      char v4 = __toupper(alias[v3]);
      *((unsigned char *)v7 + vxmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = v4;
      if (!v4) {
        break;
      }
      ++v3;
    }
    while (v3 != 99);
    *((unsigned char *)v7 + vxmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0;
    uint64_t v5 = xmlCharEncodingAliasesNb;
    if (xmlCharEncodingAliasesNb < 1)
    {
      return 0;
    }
    else
    {
      for (uint64_t i = (const char **)(xmlCharEncodingAliases + 8); strcmp(*i, (const char *)v7); i += 2)
      {
        if (!--v5) {
          return 0;
        }
      }
      return *(i - 1);
    }
  }
  return result;
}

uint64_t xmlParseGetLasts(uint64_t result, void *a2, void *a3)
{
  if (!a2 || !a3)
  {
    xmlGenericErrorFunc v16 = *__xmlGenericError();
    uint64_t v13 = *__xmlGenericErrorContext();
    return ((uint64_t (*)(void *, const char *))v16)(v13, "Internal error: xmlParseGetLasts\n");
  }
  if (!*(_DWORD *)(result + 452) || *(_DWORD *)(result + 64) != 1)
  {
LABEL_27:
    *a2 = 0;
    goto LABEL_28;
  }
  uint64_t v3 = *(void *)(result + 56);
  unint64_t v4 = *(void *)(v3 + 24);
  uint64_t v5 = (unsigned __int8 *)(*(void *)(v3 + 40) - 1);
  do
  {
    if ((unint64_t)v5 < v4) {
      goto LABEL_27;
    }
    int v6 = *v5--;
  }
  while (v6 != 60);
  *a2 = v5 + 1;
  uint64_t v7 = *(void *)(result + 56);
  unint64_t v8 = *(void *)(v7 + 40);
  uint64_t v9 = v5 + 2;
  while ((unint64_t)v9 < v8)
  {
    int v10 = *v9;
    switch(v10)
    {
      case '""':
        uint64_t v11 = v9 + 1;
        do
        {
          uint64_t v9 = v11;
          if ((unint64_t)v11 >= v8) {
            break;
          }
          ++v11;
        }
        while (*v9 != 34);
LABEL_21:
        if ((unint64_t)v9 < v8) {
          ++v9;
        }
        break;
      case '\'':
        xmlDtdPtr v12 = v9 + 1;
        do
        {
          uint64_t v9 = v12;
          if ((unint64_t)v12 >= v8) {
            break;
          }
          ++v12;
        }
        while (*v9 != 39);
        goto LABEL_21;
      case '>':
        *a3 = v9;
        return result;
      default:
        ++v9;
        break;
    }
  }
  unint64_t v14 = *(void *)(v7 + 24);
  while ((unint64_t)v5 >= v14)
  {
    int v15 = *v5--;
    if (v15 == 62)
    {
      *a3 = v5 + 1;
      return result;
    }
  }
LABEL_28:
  *a3 = 0;
  return result;
}

const xmlChar *__cdecl xmlParseStartTag(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur != 60) {
    return 0;
  }
  atts = ctxt->atts;
  int maxatts = ctxt->maxatts;
  ++input->col;
  input->cur = cur + 1;
  if (!cur[1]) {
    xmlParserInputGrow(input, 250);
  }
  int v6 = xmlParseName(ctxt);
  if (!v6)
  {
    xmlFatalErrMsg(ctxt, 68, (char)"xmlParseStartTag: invalid element name\n");
    return v6;
  }
  xmlSkipBlankChars(ctxt);
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  LODWORD(v7) = 0;
  unsigned int value = 0;
  while (1)
  {
    xmlParserInputPtr v8 = ctxt->input;
    uint64_t v9 = v8->cur;
    unsigned int v10 = *v9;
    if (v10 == 47)
    {
      if (v9[1] == 62) {
        goto LABEL_62;
      }
    }
    else
    {
      if (v10 == 62) {
        goto LABEL_62;
      }
      BOOL v11 = v10 - 9 < 2 || v10 == 13;
      if (!v11 && v10 < 0x20) {
        goto LABEL_62;
      }
    }
    if (ctxt->instate == XML_PARSER_EOF) {
      goto LABEL_62;
    }
    uint64_t consumed_low = LODWORD(v8->consumed);
    uint64_t v13 = (xmlChar *)xmlParseAttribute(ctxt, &value);
    unint64_t v14 = value;
    if (v13 && value)
    {
      if ((int)v7 < 1)
      {
        if (!atts)
        {
          xmlGenericErrorFunc v16 = (const xmlChar **)xmlMalloc(0xB0uLL);
          if (!v16)
          {
            htmlErrMemory(ctxt, 0);
            xmlFree(v14);
            atts = 0;
            int maxatts = 22;
            goto LABEL_39;
          }
          int maxatts = 22;
LABEL_37:
          ctxt->atts = v16;
          ctxt->int maxatts = maxatts;
          atts = v16;
LABEL_38:
          long long v17 = (xmlChar **)&atts[(int)v7];
          *long long v17 = v13;
          v17[1] = value;
          uint64_t v7 = (int)v7 + 2;
          atts[v7] = 0;
          _OWORD v17[3] = 0;
          goto LABEL_39;
        }
LABEL_29:
        if ((int)v7 + 4 <= maxatts) {
          goto LABEL_38;
        }
        maxatts *= 2;
        xmlGenericErrorFunc v16 = (const xmlChar **)xmlRealloc(atts, 8 * maxatts);
        if (v16) {
          goto LABEL_37;
        }
        htmlErrMemory(ctxt, 0);
      }
      else
      {
        uint64_t v15 = 0;
        while (!xmlStrEqual(atts[v15], v13))
        {
          v15 += 2;
          if ((int)v7 <= (int)v15) {
            goto LABEL_29;
          }
        }
        xmlErrAttributeDup(ctxt, 0, v13);
      }
    }
    else if (!value)
    {
      goto LABEL_39;
    }
    xmlFree(v14);
LABEL_39:
    xmlParserInputPtr v18 = ctxt->input;
    if (!ctxt->progressive && v18->end - v18->cur <= 249)
    {
      xmlGROW((uint64_t)ctxt);
      xmlParserInputPtr v18 = ctxt->input;
    }
    long long v19 = v18->cur;
    int v20 = *v19;
    if (v20 == 47)
    {
      if (v19[1] == 62) {
        goto LABEL_62;
      }
    }
    else if (v20 == 62)
    {
      goto LABEL_62;
    }
    if (!xmlSkipBlankChars(ctxt)) {
      xmlFatalErrMsg(ctxt, 65, (char)"attributes construct error\n");
    }
    xmlParserInputPtr v21 = ctxt->input;
    if (consumed_low == v21->consumed && !v13 && v9 == v21->cur && !value) {
      break;
    }
    if (!ctxt->progressive)
    {
      long long v22 = v21->cur;
      if (v22 - v21->base < 501 || v21->end - v22 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
      {
        if (ctxt->input->end - ctxt->input->cur <= 249) {
          xmlGROW((uint64_t)ctxt);
        }
      }
    }
  }
  xmlFatalErrMsg(ctxt, 1, (char)"xmlParseStartTag: problem parsing attributes\n");
LABEL_62:
  if (ctxt->sax && (startElementSAXFunc startElement = ctxt->sax->startElement) != 0 && !ctxt->disableSAX)
  {
    userData = ctxt->userData;
    if ((int)v7 >= 1)
    {
      ((void (*)(void *, const xmlChar *, const xmlChar **))startElement)(userData, v6, atts);
      goto LABEL_67;
    }
    ((void (*)(void *, const xmlChar *, void))startElement)(userData, v6, 0);
  }
  else
  {
LABEL_67:
    if (atts && (int)v7 >= 2)
    {
      uint64_t v25 = 1;
      do
      {
        long long v26 = (xmlChar *)atts[v25];
        if (v26) {
          xmlFree(v26);
        }
        v25 += 2;
      }
      while ((int)v7 > (int)v25);
    }
  }
  return v6;
}

const xmlChar *__cdecl xmlParseName(xmlParserCtxtPtr ctxt)
{
  if ((ctxt->options & 0x80000) != 0) {
    unint64_t v2 = 10000000;
  }
  else {
    unint64_t v2 = 50000;
  }
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  int v5 = *cur;
  if ((v5 & 0xFFFFFFDF) - 65 >= 0x1A && v5 != 95 && v5 != 58) {
    goto LABEL_26;
  }
  for (unint64_t i = 1; ; ++i)
  {
    int v7 = cur[i];
    if ((v7 - 48) >= 0xA
      && (v7 & 0xFFFFFFDF) - 65 >= 0x1A
      && ((v7 - 45) > 0x32 || ((1 << (v7 - 45)) & 0x4000000002003) == 0))
    {
      break;
    }
  }
  if (!cur[i] || (v7 & 0x80) != 0)
  {
LABEL_26:
    if ((ctxt->options & 0x80000) != 0) {
      int v13 = 10000000;
    }
    else {
      int v13 = 50000;
    }
    if (!ctxt->progressive && input->end - cur <= 249) {
      xmlGROW((uint64_t)ctxt);
    }
    if (ctxt->instate == XML_PARSER_EOF) {
      return 0;
    }
    int len = 0;
    signed int v14 = xmlCurrentChar(ctxt, &len);
    signed int v15 = v14;
    if ((ctxt->options & 0x20000) == 0)
    {
      if (v14 <= 0x3E && ((1 << v14) & 0x4000800100000000) != 0) {
        return 0;
      }
      if ((v14 & 0xFFFFFFDF) - 65 >= 0x1A && v14 != 58 && v14 != 95)
      {
        int32x4_t v16 = vdupq_n_s32(v14);
        unsigned __int8 v17 = vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)xmmword_1B51A8110, (uint32x4_t)vaddq_s32(v16, (int32x4_t)xmmword_1B51A80F0)), (int16x8_t)vcgtq_u32((uint32x4_t)xmmword_1B51A8120, (uint32x4_t)vaddq_s32(v16, (int32x4_t)xmmword_1B51A8100)))));
        BOOL v18 = (v14 - 65008) >= 0x20E && (v14 - 0x10000) >= 0xE0000;
        BOOL v19 = !v18;
        if (!(v17 & 1 | ((v14 - 63744) < 0x4D0) | v19) && (v14 & 0xFFFFFFFE) != 0x200C) {
          return 0;
        }
      }
      int v20 = len;
      xmlParserInputPtr v21 = ctxt->input;
      long long v22 = v21->cur;
      long long v23 = &v22[len];
      if (v23 <= v21->end)
      {
        if (*v22 == 10)
        {
          ++v21->line;
          v21->int col = 1;
        }
        else
        {
          ++v21->col;
        }
        v21->cur = v23;
      }
      unsigned int v27 = xmlCurrentChar(ctxt, &len);
      int v28 = 0;
      while (v27 > 0x3E || ((1 << v27) & 0x4000800100000000) == 0)
      {
        if (v27 - 48 >= 0xB
          && (v27 & 0xFFFFFFDF) - 65 >= 0x1A
          && (v27 - 45 > 0x32 || ((1 << (v27 - 45)) & 0x4000000000003) == 0)
          && v27 != 183)
        {
          int32x4_t v29 = vdupq_n_s32(v27);
          if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)xmmword_1B51A8150, (uint32x4_t)vaddq_s32(v29, (int32x4_t)xmmword_1B51A8130)), (int16x8_t)vcgtq_u32((uint32x4_t)xmmword_1B51A8160, (uint32x4_t)vaddq_s32(v29, (int32x4_t)xmmword_1B51A8140))))) & 1) == 0&& v27 - 63744 >= 0x4D0&& v27 - 65008 >= 0x20E&& v27 - 0x10000 >= 0xE0000&& (v27 & 0xFFFFFFFE) != 0x200C)
          {
            break;
          }
        }
        if (v28 < 101)
        {
          ++v28;
        }
        else
        {
          if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
            xmlGROW((uint64_t)ctxt);
          }
          if (ctxt->instate == XML_PARSER_EOF) {
            return 0;
          }
          int v28 = 0;
        }
        if (v20 <= (len ^ 0x7FFFFFFF)) {
          int v30 = len;
        }
        else {
          int v30 = 0;
        }
        xmlParserInputPtr v31 = ctxt->input;
        long long v32 = v31->cur;
        long long v33 = &v32[len];
        if (v33 <= v31->end)
        {
          if (*v32 == 10)
          {
            ++v31->line;
            v31->int col = 1;
          }
          else
          {
            ++v31->col;
          }
          v31->cur = v33;
        }
        v20 += v30;
        unsigned int v27 = xmlCurrentChar(ctxt, &len);
        if (!v27)
        {
          BOOL v11 = 0;
          if (ctxt->instate == XML_PARSER_EOF) {
            return v11;
          }
        }
      }
LABEL_139:
      if (v20 <= v13)
      {
        uint64_t v47 = ctxt->input->cur;
        if (v47 - ctxt->input->base >= v20)
        {
          if (*v47 == 10 && *(v47 - 1) == 13)
          {
            dict = ctxt->dict;
            unint64_t v49 = &v47[~v20];
          }
          else
          {
            dict = ctxt->dict;
            unint64_t v49 = &v47[-v20];
          }
          return xmlDictLookup(dict, v49, v20);
        }
        long long v43 = "unexpected change of input buffer";
        xmlParserCtxtPtr v44 = ctxt;
        int v45 = 1;
LABEL_141:
        xmlFatalErr(v44, v45, (const xmlChar *)v43);
        return 0;
      }
LABEL_140:
      long long v43 = "Name";
      xmlParserCtxtPtr v44 = ctxt;
      int v45 = 110;
      goto LABEL_141;
    }
    if (v14 <= 0x3E && ((1 << v14) & 0x4000800100000000) != 0) {
      return 0;
    }
    if (v14 > 255)
    {
      if (!xmlCharInRange(v14, &xmlIsBaseCharGroup)
        && (v15 - 12321) >= 9
        && v15 != 12295
        && (v15 - 19968) >= 0x51A6)
      {
        return 0;
      }
    }
    else if ((v14 & 0xFFFFFFDF) - 65 >= 0x1A {
           && (v14 - 192) >= 0x17
    }
           && v14 <= 247
           && (v14 - 216) >= 0x1F
           && v14 != 95
           && v14 != 58)
    {
      return 0;
    }
    int v20 = len;
    xmlParserInputPtr v24 = ctxt->input;
    uint64_t v25 = v24->cur;
    long long v26 = &v25[len];
    if (v26 <= v24->end)
    {
      if (*v25 == 10)
      {
        ++v24->line;
        v24->int col = 1;
      }
      else
      {
        ++v24->col;
      }
      v24->cur = v26;
    }
    int v34 = 0;
    while (1)
    {
      signed int v35 = xmlCurrentChar(ctxt, &len);
      if (v35 <= 0x3E && ((1 << v35) & 0x4000800100000000) != 0) {
        goto LABEL_139;
      }
      signed int v37 = v35;
      if (v35 > 255)
      {
        if (xmlCharInRange(v35, &xmlIsBaseCharGroup)
          || (v37 - 12321) < 9
          || v37 == 12295
          || (v37 - 19968) < 0x51A6
          || xmlCharInRange(v37, &xmlIsDigitGroup))
        {
          goto LABEL_119;
        }
      }
      else if ((v35 - 192) < 0x17 {
             || (v35 & 0xFFFFFFDF) - 65 < 0x1A
      }
             || (v35 - 48) < 0xA
             || v35 > 247
             || (v35 - 216) < 0x1F)
      {
        goto LABEL_119;
      }
      if ((v37 - 45) > 0x32 || ((1 << (v37 - 45)) & 0x4000000002003) == 0)
      {
        if (v37 >= 256)
        {
          if (xmlCharInRange(v37, &xmlIsCombiningGroup)) {
            goto LABEL_119;
          }
          int v42 = xmlCharInRange(v37, &xmlIsExtenderGroup);
        }
        else
        {
          int v42 = v37 == 183;
        }
        if (!v42) {
          goto LABEL_139;
        }
      }
LABEL_119:
      if (v34 < 101)
      {
        ++v34;
      }
      else
      {
        if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
          xmlGROW((uint64_t)ctxt);
        }
        if (ctxt->instate == XML_PARSER_EOF) {
          return 0;
        }
        int v34 = 0;
      }
      if (v20 <= (len ^ 0x7FFFFFFF)) {
        int v38 = len;
      }
      else {
        int v38 = 0;
      }
      v20 += v38;
      xmlParserInputPtr v39 = ctxt->input;
      long long v40 = v39->cur;
      long long v41 = &v40[len];
      if (v41 <= v39->end)
      {
        if (*v40 == 10)
        {
          ++v39->line;
          v39->int col = 1;
        }
        else
        {
          ++v39->col;
        }
        v39->cur = v41;
      }
    }
  }
  if (i > v2) {
    goto LABEL_140;
  }
  unsigned int v10 = &cur[i];
  BOOL v11 = xmlDictLookup(ctxt->dict, cur, i);
  xmlParserInputPtr v12 = ctxt->input;
  v12->cur = v10;
  v12->col += i;
  if (!v11)
  {
    htmlErrMemory(ctxt, 0);
    return 0;
  }
  return v11;
}

uint64_t xmlParseLookupSequence(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 56);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  int v5 = *(xmlChar **)(v4 + 24);
  uint64_t v6 = *(void *)(v4 + 32) - (void)v5;
  if ((v6 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(a1 + 320) <= (uint64_t)v6) {
    int v11 = *(_DWORD *)(v4 + 32) - v5;
  }
  else {
    int v11 = *(void *)(a1 + 320);
  }
  if (*(void *)v4)
  {
    int v5 = xmlBufContent(*(const xmlBuf **)(*(void *)v4 + 32));
    int v12 = xmlBufUse(*(const xmlBufPtr *)(*(void *)v4 + 32));
  }
  else
  {
    int v12 = *(_DWORD *)(v4 + 48);
  }
  if (a3) {
    int v13 = -1;
  }
  else {
    int v13 = 0;
  }
  if (a4) {
    int v13 = -2;
  }
  int v14 = v12 + v13;
  uint64_t v15 = v11;
  if (v11 >= v14)
  {
LABEL_25:
    *(void *)(a1 + 320) = v15;
    return 0xFFFFFFFFLL;
  }
  while (1)
  {
    if (v5[v15] != a2)
    {
      uint64_t v16 = v15 + 1;
      goto LABEL_23;
    }
    if (!a4) {
      break;
    }
    uint64_t v16 = v15 + 1;
    if (v5[v15 + 1] == a3 && v5[v15 + 2] == a4) {
      goto LABEL_27;
    }
LABEL_23:
    uint64_t v15 = v16;
    if (v16 == v14)
    {
      uint64_t v15 = v14;
      goto LABEL_25;
    }
  }
  if (a3)
  {
    uint64_t v16 = v15 + 1;
    if (v5[v15 + 1] != a3) {
      goto LABEL_23;
    }
  }
LABEL_27:
  *(void *)(a1 + 320) = 0;
  return (v15 + *(_DWORD *)(v4 + 24) - *(_DWORD *)(v4 + 32));
}

uint64_t nsPop(uint64_t result, int a2)
{
  if (*(void *)(result + 520))
  {
    int v2 = a2;
    uint64_t v3 = result;
    int v4 = *(_DWORD *)(result + 508);
    if (v4 < a2)
    {
      xmlGenericErrorFunc v5 = *__xmlGenericError();
      uint64_t v6 = __xmlGenericErrorContext();
      uint64_t result = ((uint64_t (*)(void *, const char *, ...))v5)(*v6, "Pbm popping %d NS\n", v2);
      int v4 = *(_DWORD *)(v3 + 508);
      int v2 = v4;
    }
    if (v4 >= 1 && v2 >= 1)
    {
      uint64_t v8 = 8 * v4 - 8;
      do
      {
        *(void *)(*(void *)(v3 + 520) + v8) = 0;
        --v4;
        v8 -= 8;
        --v2;
      }
      while (v2);
      *(_DWORD *)(v3 + 508) = v4;
    }
  }
  return result;
}

xmlParserCtxtPtr xmlCreatePushParserCtxt(xmlSAXHandlerPtr sax, void *user_data, const char *chunk, int size, const char *filename)
{
  xmlCharEncoding v10 = XML_CHAR_ENCODING_NONE;
  if (chunk && size >= 4) {
    xmlCharEncoding v10 = xmlDetectCharEncoding((const unsigned __int8 *)chunk, size);
  }
  xmlParserInputBufferPtr v11 = xmlAllocParserInputBuffer(v10);
  if (!v11) {
    return 0;
  }
  xmlParserInputBufferPtr v12 = v11;
  xmlParserCtxtPtr v13 = xmlNewParserCtxt();
  int v14 = v13;
  if (v13)
  {
    v13->dictNames = 1;
    if (sax)
    {
      uint64_t v15 = (xmlSAXHandlerV1 *)v13->sax;
      if (v15 != __xmlDefaultSAXHandler()) {
        xmlFree(v14->sax);
      }
      uint64_t v16 = (_xmlSAXHandler *)xmlMalloc(0x100uLL);
      v14->sax = v16;
      if (!v16)
      {
        htmlErrMemory(v14, 0);
        xmlFreeParserInputBuffer(v12);
        xmlFreeParserCtxt(v14);
        return 0;
      }
      *(_OWORD *)&v16->_private = 0u;
      *(_OWORD *)&v16->endElementNs = 0u;
      *(_OWORD *)&v16->getParameterEntity = 0u;
      *(_OWORD *)&v16->externalSubsetSAXFunc externalSubset = 0u;
      *(_OWORD *)&v16->comment = 0u;
      *(_OWORD *)&v16->error = 0u;
      *(_OWORD *)&v16->reference = 0u;
      *(_OWORD *)&v16->ignorableWhitespace = 0u;
      *(_OWORD *)&v16->startDocumentSAXFunc startDocument = 0u;
      *(_OWORD *)&v16->startElementSAXFunc startElement = 0u;
      *(_OWORD *)&v16->attributeDecl = 0u;
      *(_OWORD *)&v16->unparsedEntityDecl = 0u;
      *(_OWORD *)&v16->resolveEntity = 0u;
      *(_OWORD *)&v16->entityDecl = 0u;
      *(_OWORD *)&v16->internalSubset = 0u;
      *(_OWORD *)&v16->hasInternalSubset = 0u;
      if (sax->initialized == -554844497) {
        size_t v17 = 256;
      }
      else {
        size_t v17 = 224;
      }
      memcpy(v14->sax, sax, v17);
      if (user_data) {
        v14->userData = user_data;
      }
    }
    if (filename)
    {
      v14->directory = xmlParserGetDirectory(filename);
      xmlParserInputPtr v18 = xmlNewInputStream(v14);
      if (!v18) {
        goto LABEL_27;
      }
      BOOL v19 = v18;
      int v20 = xmlCanonicPath((const xmlChar *)filename);
      v19->filename = (const char *)v20;
      if (!v20) {
        goto LABEL_27;
      }
    }
    else
    {
      v14->directory = 0;
      xmlParserInputPtr v21 = xmlNewInputStream(v14);
      if (!v21)
      {
LABEL_27:
        xmlFreeParserCtxt(v14);
        xmlFreeParserInputBuffer(v12);
        return 0;
      }
      BOOL v19 = v21;
      v21->filename = 0;
    }
    v19->xmlParserInputBufferPtr buf = v12;
    xmlBufResetInput((uint64_t *)v12->buffer, v19);
    inputPush(v14, v19);
    if (chunk && size)
    {
      uint64_t input = (uint64_t)v14->input;
      if (input && *(void *)input)
      {
        unint64_t InputBase = xmlBufGetInputBase(*(void *)(*(void *)input + 32), input);
        xmlParserInputPtr v24 = v14->input;
        uint64_t v25 = v24->cur - v24->base;
        xmlParserInputBufferPush(v24->buf, size, chunk);
        xmlBufSetInputBaseCur((uint64_t *)v14->input->buf->buffer, &v14->input->buf, InputBase, v25);
      }
    }
    else
    {
      v14->charset = 0;
    }
    if (v10) {
      xmlSwitchEncoding(v14, v10);
    }
  }
  else
  {
    htmlErrMemory(0, (const xmlChar *)"creating parser: out of memory\n");
    xmlFreeParserInputBuffer(v12);
  }
  return v14;
}

const htmlEntityDesc *__cdecl htmlParseEntityRef(htmlParserCtxtPtr ctxt, const xmlChar **str)
{
  if (str) {
    xmlChar *str = 0;
  }
  if (!ctxt) {
    return 0;
  }
  xmlParserInputPtr input = ctxt->input;
  if (!input || *input->cur != 38) {
    return 0;
  }
  xmlNextChar(ctxt);
  xmlGenericErrorFunc v5 = htmlParseName((uint64_t)ctxt);
  if (!v5)
  {
    htmlParseErr(ctxt, 68, "htmlParseEntityRef: no name\n", 0, 0);
    return 0;
  }
  uint64_t v6 = v5;
  xmlParserInputPtr v7 = ctxt->input;
  if (!ctxt->progressive && v7->end - v7->cur <= 249)
  {
    xmlParserInputGrow(v7, 250);
    xmlParserInputPtr v7 = ctxt->input;
  }
  if (*v7->cur != 59)
  {
    htmlParseErr(ctxt, 23, "htmlParseEntityRef: expecting ';'\n", 0, 0);
    if (str)
    {
      uint64_t result = 0;
      xmlChar *str = v6;
      return result;
    }
    return 0;
  }
  if (str) {
    xmlChar *str = v6;
  }
  uint64_t v8 = (const htmlEntityDesc *)html40EntitiesTable;
  uint64_t v9 = 253;
  while (!xmlStrEqual(v6, (const xmlChar *)v8->name))
  {
    uint64_t result = 0;
    ++v8;
    if (!--v9) {
      return result;
    }
  }
  xmlNextChar(ctxt);
  return v8;
}

const xmlChar *htmlParseNameComplex(uint64_t a1)
{
_htmlParseNameComplex:
  uint64_t v1 = a1;
  int v2 = *(xmlParserInput **)(a1 + 56);
  base = v2->base;
  if (!*(_DWORD *)(v1 + 452) && v2->end - v2->cur <= 249) {
    xmlParserInputGrow(v2, 250);
  }
  int v22 = 0;
  signed int v4 = htmlCurrentChar(v1, &v22);
  signed int v5 = v4;
  if (v4 <= 0x3E && ((1 << v4) & 0x4000800100000000) != 0) {
    return 0;
  }
  if (v4 > 255)
  {
    if (xmlCharInRange(v4, &xmlIsBaseCharGroup)) {
      BOOL v7 = 1;
    }
    else {
      BOOL v7 = (v5 - 12330) > 0xFFFFFFF6;
    }
    if (!v7 && v5 != 12295 && (v5 - 40870) < 0xFFFFAE5A) {
      return 0;
    }
  }
  else if ((v4 - 192) >= 0x17 {
         && (v4 & 0xFFFFFFDF) - 65 >= 0x1A
  }
         && v4 <= 247
         && (v4 - 216) >= 0x1F
         && v4 != 95
         && v4 != 58)
  {
    return 0;
  }
  int v10 = 0;
  int v11 = 0;
  while (v5 > 0x3E || ((1 << v5) & 0x4000800100000000) == 0)
  {
    if (v5 > 255)
    {
      if (xmlCharInRange(v5, &xmlIsBaseCharGroup)) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = (v5 - 12321) >= 9;
      }
      BOOL v14 = v12 && v5 != 12295 && (v5 - 19968) >= 0x51A6;
      if (!v14 || xmlCharInRange(v5, &xmlIsDigitGroup)) {
        goto LABEL_50;
      }
    }
    else if ((v5 - 192) < 0x17 {
           || (v5 & 0xFFFFFFDF) - 65 < 0x1A
    }
           || (v5 - 48) < 0xA
           || v5 > 247
           || (v5 - 216) < 0x1F)
    {
      goto LABEL_50;
    }
    if ((v5 - 45) > 0x32 || ((1 << (v5 - 45)) & 0x4000000002003) == 0)
    {
      if (v5 >= 256)
      {
        if (!xmlCharInRange(v5, &xmlIsCombiningGroup) && !xmlCharInRange(v5, &xmlIsExtenderGroup)) {
          break;
        }
      }
      else if (v5 != 183)
      {
        break;
      }
    }
LABEL_50:
    if (v11 >= 101)
    {
      if (!*(_DWORD *)(v1 + 452))
      {
        uint64_t v15 = *(xmlParserInput **)(v1 + 56);
        if (v15->end - v15->cur <= 249) {
          xmlParserInputGrow(v15, 250);
        }
      }
      int v11 = 0;
    }
    else
    {
      ++v11;
    }
    int v16 = v22;
    uint64_t v17 = *(void *)(v1 + 56);
    xmlParserInputPtr v18 = *(unsigned char **)(v17 + 32);
    BOOL v19 = &v18[v22];
    if ((unint64_t)v19 <= *(void *)(v17 + 40))
    {
      if (*v18 == 10)
      {
        ++*(_DWORD *)(v17 + 52);
        *(_DWORD *)(v17 + 56) = 1;
      }
      else
      {
        ++*(_DWORD *)(v17 + 56);
      }
      *(_DWORD *)(v1 + 276) = 0;
      *(void *)(v17 + 32) = v19;
      ++*(void *)(v1 + 312);
    }
    v10 += v16;
    signed int v5 = htmlCurrentChar(v1, &v22);
    if (*(const xmlChar **)(*(void *)(v1 + 56) + 24) != base)
    {
      a1 = v1;
      goto _htmlParseNameComplex;
    }
  }
  uint64_t v20 = *(void *)(*(void *)(v1 + 56) + 32);
  if (v20 - *(void *)(*(void *)(v1 + 56) + 24) < v10)
  {
    htmlParseErr((_DWORD *)v1, 1, "unexpected change of input buffer", 0, 0);
    return 0;
  }
  xmlParserInputPtr v21 = *(xmlDict **)(v1 + 456);

  return xmlDictLookup(v21, (const xmlChar *)(v20 - v10), v10);
}

const xmlChar *htmlParseName(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 452))
  {
    int v2 = *(xmlParserInput **)(a1 + 56);
    if (v2->end - v2->cur <= 249) {
      xmlParserInputGrow(v2, 250);
    }
  }
  uint64_t v3 = *(void *)(a1 + 56);
  signed int v4 = *(const xmlChar **)(v3 + 32);
  int v5 = *v4;
  if ((v5 & 0xFFFFFFDF) - 65 < 0x1A || v5 == 95 || v5 == 58)
  {
    for (uint64_t i = 1; ; ++i)
    {
      int v7 = v4[i];
      if ((v7 - 48) >= 0xA
        && (v7 & 0xFFFFFFDF) - 65 >= 0x1A
        && ((v7 - 45) > 0x32 || ((1 << (v7 - 45)) & 0x4000000002003) == 0))
      {
        break;
      }
    }
    int v10 = &v4[i];
    if (&v4[i] == *(const xmlChar **)(v3 + 40)) {
      return 0;
    }
    if ((char)v7 >= 1)
    {
      uint64_t result = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), v4, i);
      uint64_t v12 = *(void *)(a1 + 56);
      *(void *)(v12 + 32) = v10;
      *(_DWORD *)(v12 + 56) += i;
      return result;
    }
  }

  return htmlParseNameComplex(a1);
}

_DWORD *htmlParseErr(_DWORD *result, int a2, const char *a3, const xmlChar *a4, xmlChar *a5)
{
  if (!result) {
    return __xmlRaiseError(0, 0, 0, 0, 0, 5u, a2, 2, 0, 0, a4, a5, 0, 0, 0, a3, (char)a4);
  }
  int v5 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    uint64_t result = __xmlRaiseError(0, 0, 0, result, 0, 5u, a2, 2, 0, 0, a4, a5, 0, 0, 0, a3, (char)a4);
    v5[6] = 0;
  }
  return result;
}

int xmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size, int terminate)
{
  if (!ctxt) {
    return 1;
  }
  if (ctxt->wellFormed != 1 && ctxt->disableSAX == 1) {
    return ctxt->errNo;
  }
  xmlParserInputState instate = ctxt->instate;
  if (instate != XML_PARSER_EOF)
  {
    if (instate == XML_PARSER_START) {
      xmlDetectSAX2((const xmlChar *)ctxt);
    }
    if (!chunk || (int v9 = size - 1, size < 1) || terminate)
    {
      BOOL v55 = 0;
    }
    else
    {
      BOOL v55 = chunk[v9] == 13;
      if (chunk[v9] == 13) {
        --size;
      }
    }
    size_t v10 = 0;
    size_t v11 = 0;
    while (1)
    {
      if (size >= 1)
      {
        if (chunk)
        {
          xmlParserInputPtr input = ctxt->input;
          if (input)
          {
            if (input->buf) {
              break;
            }
          }
        }
      }
      if (ctxt->instate == XML_PARSER_EOF) {
        goto LABEL_46;
      }
      xmlParserInputPtr v22 = ctxt->input;
      if (v22)
      {
        uint64_t buf = (uint64_t)v22->buf;
        if (v22->buf)
        {
          if (*(void *)(buf + 24))
          {
            uint64_t v24 = *(void *)(buf + 32);
            if (v24)
            {
              if (*(void *)(buf + 40))
              {
                unint64_t InputBase = xmlBufGetInputBase(v24, (uint64_t)v22);
                uint64_t v26 = ctxt->input->cur - ctxt->input->base;
                int v27 = xmlCharEncInput(buf, terminate);
                xmlBufSetInputBaseCur(*(uint64_t **)(buf + 32), &ctxt->input->buf, InputBase, v26);
                if (v27 < 0)
                {
                  xmlGenericErrorFunc v53 = *__xmlGenericError();
                  xmlParserInputPtr v54 = __xmlGenericErrorContext();
                  v53(*v54, "xmlParseChunk: encoder error\n");
                  xmlHaltParser(ctxt);
                  return 81;
                }
              }
            }
          }
LABEL_46:
          xmlParserInputPtr v32 = ctxt->input;
          if (v32)
          {
            xmlParserInputBufferPtr v33 = v32->buf;
            if (v33) {
              size_t v11 = xmlBufUse(v33->buffer);
            }
          }
        }
      }
      if (terminate
        || v11 > 0x989680
        || !v10
        || !v11
        || v11 - v10 < 0
        || (base = ctxt->input->base) == 0
        || (xmlParserInputState v35 = ctxt->instate, v35 != XML_PARSER_START_TAG)
        && v35 != XML_PARSER_END_TAG
        && (int progressive = ctxt->progressive, progressive != 2)
        && v35 != XML_PARSER_CDATA_SECTION
        && progressive != 5
        && v35 != XML_PARSER_DTD
        && progressive != 3
        || memchr((void *)&base[v10], 62, (v11 - v10)))
      {
        xmlParseTryOrFinish((uint64_t)ctxt, terminate);
      }
      int v18 = 0;
      char v21 = 1;
LABEL_59:
      if (ctxt->instate == XML_PARSER_EOF) {
        return ctxt->errNo;
      }
      xmlParserInputPtr v36 = ctxt->input;
      if (v36)
      {
        cur = v36->cur;
        if ((v36->end - cur > 10000000 || cur - v36->base > 10000000) && (ctxt->options & 0x80000) == 0)
        {
          xmlFatalErr(ctxt, 1, (const xmlChar *)"Huge input lookup");
          xmlHaltParser(ctxt);
        }
      }
      if (ctxt->wellFormed != 1 && ctxt->disableSAX == 1) {
        return ctxt->errNo;
      }
      if (v21)
      {
        if (v55)
        {
          xmlParserInputPtr v39 = ctxt->input;
          if (v39)
          {
            if (v39->buf)
            {
              unint64_t v40 = xmlBufGetInputBase((uint64_t)v39->buf->buffer, (uint64_t)v39);
              xmlParserInputPtr v41 = ctxt->input;
              uint64_t v42 = v41->cur - v41->base;
              xmlParserInputBufferPush(v41->buf, 1, "\r");
              xmlBufSetInputBaseCur((uint64_t *)ctxt->input->buf->buffer, &ctxt->input->buf, v40, v42);
            }
          }
        }
        if (terminate)
        {
          xmlParserInputPtr v43 = ctxt->input;
          if (v43)
          {
            if (v43->buf)
            {
              int v44 = xmlBufUse(v43->buf->buffer);
              xmlParserInputPtr v45 = ctxt->input;
              int v46 = (int)v45->cur;
              int v47 = (int)v45->base;
              int length = v44 - v46;
            }
            else
            {
              int length = v43->length;
              int v47 = LODWORD(v43->base) - LODWORD(v43->cur);
            }
            int v49 = length + v47;
          }
          else
          {
            int v49 = 0;
          }
          xmlParserInputState v50 = ctxt->instate;
          if (v50 != XML_PARSER_EOF && v50 != XML_PARSER_EPILOG)
          {
            xmlFatalErr(ctxt, 5, 0);
            xmlParserInputState v50 = ctxt->instate;
          }
          if (v50 == XML_PARSER_EPILOG && v49 >= 1)
          {
            xmlFatalErr(ctxt, 5, 0);
            xmlParserInputState v50 = ctxt->instate;
          }
          if (v50 != XML_PARSER_EOF)
          {
            if (ctxt->sax)
            {
              endDocumentSAXFunc endDocument = ctxt->sax->endDocument;
              if (endDocument) {
                ((void (*)(void *))endDocument)(ctxt->userData);
              }
            }
          }
          ctxt->xmlParserInputState instate = XML_PARSER_EOF;
        }
        if (ctxt->wellFormed) {
          return 0;
        }
        return ctxt->errNo;
      }
      chunk += size;
      size = v18;
    }
    if (ctxt->instate != XML_PARSER_EOF)
    {
      unint64_t v13 = xmlBufGetInputBase((uint64_t)input->buf->buffer, (uint64_t)input);
      xmlParserInputPtr v14 = ctxt->input;
      int v16 = v14->base;
      uint64_t v15 = v14->cur;
      size_t v10 = xmlBufUse(v14->buf->buffer);
      xmlParserInputPtr v17 = ctxt->input;
      if (ctxt->instate == XML_PARSER_START && v17->buf && (encoder = (const xmlChar **)v17->buf->encoder) != 0)
      {
        if (xmlStrcasestr(*encoder, (const xmlChar *)"UTF-16")
          || xmlStrcasestr((const xmlChar *)ctxt->input->buf->encoder->name, (const xmlChar *)"UTF16"))
        {
          unsigned int v29 = 90;
        }
        else if (xmlStrcasestr((const xmlChar *)ctxt->input->buf->encoder->name, (const xmlChar *)"UCS-4") {
               || xmlStrcasestr((const xmlChar *)ctxt->input->buf->encoder->name, (const xmlChar *)"UCS4"))
        }
        {
          unsigned int v29 = 180;
        }
        else
        {
          unsigned int v29 = 45;
        }
        xmlParserInputPtr v17 = ctxt->input;
        rawint consumed = v17->buf->rawconsumed;
        if (rawconsumed >= v29) {
          LODWORD(rawconsumed) = 0;
        }
        unsigned int v31 = v29 - rawconsumed;
        if (size >= v31) {
          int v18 = size - v31;
        }
        else {
          int v18 = 0;
        }
        if (size >= v31) {
          size = v31;
        }
      }
      else
      {
        int v18 = 0;
      }
      uint64_t v19 = v15 - v16;
      int v20 = xmlParserInputBufferPush(v17->buf, size, chunk);
      xmlBufSetInputBaseCur((uint64_t *)ctxt->input->buf->buffer, &ctxt->input->buf, v13, v19);
      if (v20 < 0)
      {
        xmlParserInputState instate = XML_PARSER_EOF;
        ctxt->int errNo = -1;
        xmlHaltParser(ctxt);
        return instate;
      }
      if (v18)
      {
        xmlParseTryOrFinish((uint64_t)ctxt, 0);
        char v21 = 0;
        goto LABEL_59;
      }
    }
    goto LABEL_46;
  }
  return instate;
}

int xmlParserInputBufferPush(xmlParserInputBufferPtr in, int len, const char *buf)
{
  if (len < 0)
  {
    LODWORD(v4) = 0;
  }
  else
  {
    if (in && !in->error)
    {
      size_t v4 = *(void *)&len;
      if (in->encoder)
      {
        uint64_t raw = in->raw;
        if (!raw)
        {
          uint64_t raw = (xmlBuf *)xmlBufCreate();
          in->uint64_t raw = raw;
        }
        if (!xmlBufAdd((uint64x2_t *)raw, (const xmlChar *)buf, v4))
        {
          unsigned int v8 = xmlBufUse(in->raw);
          int v9 = xmlCharEncInput((uint64_t)in, 1);
          if ((v9 & 0x80000000) == 0)
          {
            LODWORD(v4) = v9;
            in->rawint consumed = in->rawconsumed - xmlBufUse(in->raw) + v8;
            return v4;
          }
          __xmlSimpleError(8, 1544, 0, (uint64_t)"encoder error", 0);
          in->error = 1544;
        }
      }
      else if (!xmlBufAdd((uint64x2_t *)in->buffer, (const xmlChar *)buf, *(size_t *)&len))
      {
        return v4;
      }
    }
    LODWORD(v4) = -1;
  }
  return v4;
}

uint64_t xmlBufSetInputBaseCur(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  if (!a1 || *((_DWORD *)a1 + 14))
  {
    a2[4] = "";
    a2[5] = "";
    a2[3] = "";
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = *((unsigned int *)a1 + 3);
  if (v6 <= 0x7FFFFFFE && a1[5] != v6) {
    a1[5] = v6;
  }
  uint64_t v8 = a1[4];
  uint64_t v9 = *((unsigned int *)a1 + 2);
  if (v9 <= 0x7FFFFFFE && v8 != v9)
  {
    a1[4] = v9;
    uint64_t v8 = v9;
  }
  uint64_t v4 = 0;
  uint64_t v10 = *a1;
  uint64_t v11 = *a1 + a3;
  a2[3] = v11;
  a2[4] = v11 + a4;
  a2[5] = v10 + v8;
  return v4;
}

unint64_t xmlBufGetInputBase(uint64_t a1, uint64_t a2)
{
  unint64_t result = 0;
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 56))
    {
      return 0;
    }
    else
    {
      unint64_t v4 = *(void *)(a1 + 40);
      unint64_t v5 = *(unsigned int *)(a1 + 12);
      if (v5 <= 0x7FFFFFFE && v4 != v5)
      {
        *(void *)(a1 + 40) = v5;
        unint64_t v4 = v5;
      }
      uint64_t v7 = *(unsigned int *)(a1 + 8);
      if (v7 <= 0x7FFFFFFE && *(void *)(a1 + 32) != v7) {
        *(void *)(a1 + 32) = v7;
      }
      unint64_t result = *(void *)(a2 + 24) - *(void *)a1;
      if (result > v4)
      {
        __xmlSimpleError(29, 7000, 0, 0, (uint64_t)"Input reference outside of the buffer");
        unint64_t result = 0;
        if (!*(_DWORD *)(a1 + 56))
        {
          unint64_t result = 0;
          *(_DWORD *)(a1 + 56) = 7000;
        }
      }
    }
  }
  return result;
}

xmlOutputBufferPtr xmlOutputBufferCreateIO(xmlOutputBufferPtr iowrite, xmlOutputCloseCallback ioclose, void *ioctx, xmlCharEncodingHandlerPtr encoder)
{
  if (iowrite)
  {
    uint64_t v6 = (int (__cdecl *)(void *, const char *, int))iowrite;
    iowrite = (xmlOutputBufferPtr)xmlAllocOutputBufferInternal((uint64_t)encoder);
    if (iowrite)
    {
      iowrite->context = ioctx;
      iowrite->writecallbacint k = v6;
      iowrite->closecallbacint k = ioclose;
    }
  }
  return iowrite;
}

void *xmlAllocOutputBufferInternal(uint64_t a1)
{
  int v2 = xmlMalloc(0x38uLL);
  uint64_t v3 = v2;
  if (v2)
  {
    v2[6] = 0;
    *((_OWORD *)v2 + 1) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *(_OWORD *)int v2 = 0u;
    unint64_t v4 = xmlBufCreate();
    v3[4] = v4;
    if (v4)
    {
      xmlBufSetAllocationScheme((uint64_t)v4, 3u);
      v3[3] = a1;
      if (!a1)
      {
        v3[5] = 0;
        goto LABEL_8;
      }
      Size = xmlBufCreateSize(4000);
      v3[5] = Size;
      if (Size)
      {
        xmlCharEncOutput(v3, 1);
LABEL_8:
        *((_DWORD *)v3 + 12) = 0;
        v3[1] = 0;
        v3[2] = 0;
        void *v3 = 0;
        return v3;
      }
      xmlBufFree(v3[4]);
    }
    xmlFree(v3);
    return 0;
  }
  __xmlSimpleError(8, 2, 0, 0, (uint64_t)"creating output buffer");
  return v3;
}

void *xmlBufCreate()
{
  uint64_t v0 = xmlMalloc(0x40uLL);
  uint64_t v1 = v0;
  if (v0)
  {
    v0[4] = 0;
    *((_DWORD *)v0 + 14) = 0;
    v0[6] = 0;
    uint64_t v2 = *__xmlDefaultBufferSize();
    v1[5] = v2;
    LODWORD(vxmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0x7FFFFFFF;
    if (v2 >= 0x7FFFFFFF) {
      LODWORD(v2) = 0x7FFFFFFF;
    }
    if (v1[4] < 0x7FFFFFFFuLL) {
      uint64_t v3 = v1[4];
    }
    *((_DWORD *)v1 + 2) = v3;
    *((_DWORD *)v1 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = v2;
    *((xmlBufferAllocationScheme *)v1 + 4) = *__xmlBufferAllocScheme();
    unint64_t v4 = xmlMallocAtomic(v1[5]);
    *uint64_t v1 = v4;
    if (v4)
    {
      bzero(v4, v1[5]);
      v1[3] = 0;
    }
    else
    {
      __xmlSimpleError(29, 2, 0, 0, (uint64_t)"creating buffer");
      if (!*((_DWORD *)v1 + 14)) {
        *((_DWORD *)v1 + 14) = 2;
      }
      xmlFree(v1);
      return 0;
    }
  }
  else
  {
    __xmlSimpleError(29, 2, 0, 0, (uint64_t)"creating buffer");
  }
  return v1;
}

void xmlSetStructuredErrorFunc(void *ctx, xmlStructuredErrorFunc handler)
{
  *__xmlStructuredErrorContext() = ctx;
  *__xmlStructuredError() = handler;
}

void **__xmlStructuredErrorContext(void)
{
  if (xmlIsMainThread()) {
    return (void **)&xmlStructuredErrorContext;
  }
  else {
    return &xmlGetGlobalState()->xmlStructuredErrorContext;
  }
}

_DWORD *__xmlRaiseError(xmlStructuredErrorFunc a1, void (*a2)(void *, const char *, ...), void *a3, void *a4, uint64_t a5, unsigned int a6, int a7, int a8, uint64_t a9, int a10, const xmlChar *a11, xmlChar *cur, xmlChar *a13, int a14, int a15, const char *a16, char a17)
{
  unint64_t result = __xmlLastError();
  if (!a7) {
    return result;
  }
  uint64_t v26 = (uint64_t)result;
  unint64_t result = __xmlGetWarningsDefaultValue();
  if (a8 == 1 && !*result) {
    return result;
  }
  int v27 = 0;
  if (a6 <= 0x17 && ((1 << a6) & 0x80013A) != 0 && (int v27 = a4, !a1) && (int v27 = a4) != 0)
  {
    uint64_t v28 = *a4;
    int v27 = a4;
    if (*a4)
    {
      int v27 = a4;
      if (*(_DWORD *)(v28 + 216) == -554844497)
      {
        a1 = *(xmlStructuredErrorFunc *)(v28 + 248);
        int v27 = a4;
        if (a1)
        {
          unsigned int v29 = (void **)(a4 + 1);
          int v27 = a4;
LABEL_15:
          a3 = *v29;
          goto LABEL_16;
        }
      }
    }
  }
  else if (a1)
  {
    goto LABEL_16;
  }
  a1 = *__xmlStructuredError();
  if (a1)
  {
    unsigned int v29 = __xmlStructuredErrorContext();
    goto LABEL_15;
  }
LABEL_16:
  int LineNo = a10;
  size_t v65 = (uint64_t (*)(void *, uint64_t))a1;
  char v66 = a4;
  unsigned int v64 = a6;
  if (a16)
  {
    int v30 = (char *)xmlMalloc(0x96uLL);
    if (v30)
    {
      int v31 = -1;
      int v32 = 150;
      do
      {
        xmlParserInputBufferPtr v33 = (xmlChar *)v30;
        if (v32 > 63999) {
          break;
        }
        int v34 = vsnprintf(v30, v32, a16, &a17);
        if ((v34 & 0x80000000) == 0 && v34 < v32)
        {
          BOOL v55 = v31 == v34;
          int v31 = v34;
          if (v55) {
            break;
          }
        }
        int v35 = v34 >= 0 ? v34 + 1 : 100;
        v32 += v35;
        int v30 = (char *)xmlRealloc(v33, v32);
      }
      while (v30);
    }
    else
    {
      xmlParserInputBufferPtr v33 = 0;
    }
  }
  else
  {
    xmlParserInputBufferPtr v33 = xmlStrdup((const xmlChar *)"No error message provided");
  }
  uint64_t v36 = a9;
  if (v27)
  {
    if (!a9)
    {
      uint64_t v37 = v27[7];
      if (v37)
      {
        uint64_t v36 = *(void *)(v37 + 8);
        if (v36)
        {
LABEL_67:
          int LineNo = *(_DWORD *)(v37 + 52);
          a15 = *(_DWORD *)(v37 + 56);
          goto LABEL_68;
        }
        int v38 = *((_DWORD *)v27 + 16);
        BOOL v39 = __OFSUB__(v38, 2);
        int v40 = v38 - 2;
        if (v40 < 0 != v39)
        {
          uint64_t v36 = 0;
          goto LABEL_67;
        }
        uint64_t v37 = *(void *)(v27[9] + 8 * v40);
        if (v37)
        {
          uint64_t v36 = *(void *)(v37 + 8);
          goto LABEL_67;
        }
      }
      uint64_t v36 = 0;
    }
LABEL_68:
    uint64_t v41 = 0;
    uint64_t v26 = (uint64_t)(v27 + 75);
    goto LABEL_69;
  }
  uint64_t v41 = 0;
  if (!a5 || a9) {
    goto LABEL_69;
  }
  uint64_t v42 = *(void *)(a5 + 64);
  if (v42)
  {
    if (*(void *)(v42 + 136)) {
      uint64_t v41 = a5;
    }
    else {
      uint64_t v41 = 0;
    }
  }
  else
  {
    uint64_t v41 = 0;
  }
  unsigned int v43 = 0;
  do
  {
    if (*(_DWORD *)(a5 + 8) == 1)
    {
      int v44 = a10;
      if (v41) {
        goto LABEL_59;
      }
      goto LABEL_54;
    }
    a5 = *(void *)(a5 + 40);
    if (v43 > 8) {
      break;
    }
    ++v43;
  }
  while (a5);
  int v44 = a10;
  if (!v41 && a5)
  {
LABEL_54:
    uint64_t v45 = *(void *)(a5 + 64);
    if (v45)
    {
      if (*(void *)(v45 + 136)) {
        uint64_t v41 = a5;
      }
      else {
        uint64_t v41 = 0;
      }
    }
    else
    {
      uint64_t v41 = 0;
    }
    goto LABEL_59;
  }
  if (!a5) {
    goto LABEL_61;
  }
LABEL_59:
  if (*(_DWORD *)(a5 + 8) == 1) {
    int v44 = *(unsigned __int16 *)(a5 + 112);
  }
LABEL_61:
  if (v44 != 0xFFFF && v44) {
    int LineNo = v44;
  }
  else {
    int LineNo = xmlGetLineNo((const xmlNode *)a5);
  }
  uint64_t v36 = 0;
LABEL_69:
  xmlResetError((xmlErrorPtr)v26);
  *(_DWORD *)uint64_t v26 = v64;
  *(_DWORD *)(v26 + 4) = a7;
  *(void *)(v26 + 8) = v33;
  *(_DWORD *)(v26 + 16) = a8;
  if (v36)
  {
    int v46 = (const xmlChar *)v36;
LABEL_71:
    *(void *)(v26 + 24) = xmlStrdup(v46);
  }
  else if (v41)
  {
    int v63 = a8;
    unint64_t v48 = a3;
    int v49 = 0;
    uint64_t v50 = v41;
    do
    {
      uint64_t v51 = *(void *)(v50 + 56);
      if (v51)
      {
        int v52 = *(_DWORD *)(v51 + 8);
        if (v52 == 20)
        {
          ++v49;
        }
        else if (v52 == 19)
        {
          if (v49 < 1)
          {
            Prop = xmlGetProp((const xmlNode *)v51, (const xmlChar *)"href");
            if (Prop)
            {
              *(void *)(v26 + 24) = Prop;
              a3 = v48;
              a8 = v63;
              goto LABEL_72;
            }
          }
          else
          {
            --v49;
          }
        }
      }
      else
      {
        uint64_t v51 = *(void *)(v50 + 40);
      }
      uint64_t v50 = v51;
    }
    while (v51);
    xmlParserInputPtr v54 = xmlStrdup(*(const xmlChar **)(*(void *)(v41 + 64) + 136));
    *(void *)(v26 + 24) = v54;
    if (v54) {
      BOOL v55 = 1;
    }
    else {
      BOOL v55 = a5 == 0;
    }
    a3 = v48;
    a8 = v63;
    if (!v55)
    {
      uint64_t v56 = *(void *)(a5 + 64);
      if (v56)
      {
        int v46 = *(const xmlChar **)(v56 + 136);
        goto LABEL_71;
      }
    }
  }
LABEL_72:
  *(_DWORD *)(v26 + 32) = LineNo;
  if (a11) {
    *(void *)(v26 + 40) = xmlStrdup(a11);
  }
  if (cur) {
    *(void *)(v26 + 48) = xmlStrdup(cur);
  }
  if (a13) {
    *(void *)(v26 + 56) = xmlStrdup(a13);
  }
  *(_DWORD *)(v26 + 64) = a14;
  *(_DWORD *)(v26 + 68) = a15;
  *(void *)(v26 + 72) = v66;
  *(void *)(v26 + 80) = a5;
  if ((xmlError *)v26 != __xmlLastError())
  {
    Error = __xmlLastError();
    xmlCopyError((xmlErrorPtr)v26, Error);
  }
  if (v65) {
    return (_DWORD *)v65(a3, v26);
  }
  if (a2 || !v27)
  {
    if (a2) {
      goto LABEL_107;
    }
    unint64_t result = __xmlGenericError();
    a2 = *(void (**)(void *, const char *, ...))result;
    if (!v27)
    {
      unint64_t result = __xmlGenericErrorContext();
      a3 = *(void **)result;
      goto LABEL_106;
    }
LABEL_105:
    a3 = v27;
    goto LABEL_106;
  }
  unint64_t result = __xmlStructuredError();
  if (*(void *)result || !*v27)
  {
    unint64_t result = __xmlGenericError();
    a2 = *(void (**)(void *, const char *, ...))result;
    goto LABEL_105;
  }
  uint64_t v62 = 176;
  if (a8 == 1) {
    uint64_t v62 = 168;
  }
  a2 = *(void (**)(void *, const char *, ...))(*v27 + v62);
  a3 = (void *)v27[1];
LABEL_106:
  if (a2)
  {
LABEL_107:
    if (a2 == xmlParserValidityWarning
      || a2 == xmlParserValidityError
      || a2 == xmlParserError
      || a2 == xmlParserWarning)
    {
      uint64_t v57 = v26;
      uint64_t v58 = (uint64_t)v27;
      uint64_t v59 = v33;
      charactersSAXFunc v60 = 0;
      uint64_t v61 = 0;
    }
    else
    {
      if (a2 != (void (*)(void *, const char *, ...))MEMORY[0x1E4F14830]
        && (char *)a2 != (char *)xmlGenericErrorDefaultFunc)
      {
        return (_DWORD *)((uint64_t (*)(void *, const char *, ...))a2)(a3, "%s", (const char *)v33);
      }
      uint64_t v57 = v26;
      uint64_t v58 = (uint64_t)v27;
      uint64_t v59 = v33;
      charactersSAXFunc v60 = a2;
      uint64_t v61 = (uint64_t)a3;
    }
    return (_DWORD *)xmlReportError(v57, v58, v59, v60, v61);
  }
  return result;
}

xmlStructuredErrorFunc *__xmlStructuredError(void)
{
  if (xmlIsMainThread()) {
    return (xmlStructuredErrorFunc *)&xmlStructuredError;
  }
  else {
    return &xmlGetGlobalState()->xmlStructuredError;
  }
}

xmlError *__xmlLastError(void)
{
  if (xmlIsMainThread()) {
    return (xmlError *)&xmlLastError;
  }
  else {
    return &xmlGetGlobalState()->xmlLastError;
  }
}

void xmlResetError(xmlErrorPtr err)
{
  if (err && err->code)
  {
    message = err->message;
    if (message) {
      xmlFree(message);
    }
    file = err->file;
    if (file) {
      xmlFree(file);
    }
    str1 = err->str1;
    if (str1) {
      xmlFree(str1);
    }
    str2 = err->str2;
    if (str2) {
      xmlFree(str2);
    }
    str3 = err->str3;
    if (str3) {
      xmlFree(str3);
    }
    err->node = 0;
    *(_OWORD *)&err->str2 = 0u;
    *(_OWORD *)&err->int1 = 0u;
    *(_OWORD *)&err->level = 0u;
    *(_OWORD *)&err->int line = 0u;
    *(_OWORD *)&err->domain = 0u;
    err->code = 0;
  }
}

int *__xmlGetWarningsDefaultValue(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlGetWarningsDefaultValue;
  }
  else {
    return &xmlGetGlobalState()->xmlGetWarningsDefaultValue;
  }
}

void xmlNodeDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur, int level, int format, const char *encoding)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  xmlInitParser();
  if (buf && cur)
  {
    uint64_t v12 = "UTF-8";
    long long v17 = 0u;
    long long v18 = 0u;
    if (encoding) {
      uint64_t v12 = encoding;
    }
    uint64_t v24 = 0;
    long long v22 = 0uLL;
    long long v23 = 0uLL;
    long long v20 = 0uLL;
    long long v21 = 0uLL;
    long long v19 = 0uLL;
    long long v14 = 0uLL;
    uint64_t v15 = 0;
    *((void *)&v17 + 1) = buf;
    DWORD1(v18) = level;
    DWORD2(v18) = format != 0;
    int v16 = v12;
    xmlSaveCtxtInit((int *)&v14);
    LODWORD(v18) = v18 | 0x20;
    xmlDtdPtr IntSubset = xmlGetIntSubset(doc);
    if (IntSubset && xmlIsXHTML(IntSubset->SystemID, IntSubset->ExternalID) >= 1) {
      xhtmlNodeDumpOutput((uint64_t)&v14, (uint64_t)cur);
    }
    else {
      xmlNodeDumpOutputInternal((uint64_t)&v14, (uint64_t)cur);
    }
  }
}

uint64_t __xmlGlobalInitMutexUnlock()
{
  return pthread_mutex_unlock(&global_init_lock);
}

xmlDtdPtr xmlGetIntSubset(xmlDtdPtr doc)
{
  if (doc)
  {
    xmlDtdPtr v1 = doc;
    doc = (xmlDtdPtr)doc->children;
    if (doc)
    {
      while (doc->type != XML_DTD_NODE)
      {
        doc = (xmlDtdPtr)doc->next;
        if (!doc) {
          return (xmlDtdPtr)v1->elements;
        }
      }
    }
    else
    {
      return (xmlDtdPtr)v1->elements;
    }
  }
  return doc;
}

uint64_t xmlAttrDumpOutput(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(xmlOutputBuffer **)(result + 40);
    if (v2)
    {
      if (*(_DWORD *)(result + 56) == 2) {
        xmlOutputBufferWriteWSNonSig((xmlBufPtr)result, 2);
      }
      else {
        xmlOutputBufferWrite(*(xmlOutputBufferPtr *)(result + 40), 1, " ");
      }
      uint64_t v4 = *(void *)(a2 + 72);
      if (v4)
      {
        unint64_t v5 = *(const char **)(v4 + 24);
        if (v5)
        {
          xmlOutputBufferWriteString(v2, v5);
          xmlOutputBufferWrite(v2, 1, ":");
        }
      }
      xmlOutputBufferWriteString(v2, *(const char **)(a2 + 16));
      xmlOutputBufferWrite(v2, 2, "=\"");
      xmlAttrSerializeContent((uint64_t)v2, a2);
      return xmlOutputBufferWrite(v2, 1, "\"");
    }
  }
  return result;
}

uint64_t xmlNodeDumpOutputInternal(uint64_t result, uint64_t a2)
{
  if (!a2) {
    return result;
  }
  uint64_t v3 = result;
  uint64_t v4 = 0;
  uint64_t v5 = *(unsigned int *)(result + 56);
  uint64_t v6 = "\n";
  uint64_t v7 = "</";
  uint64_t v8 = *(void *)(result + 40);
  uint64_t v9 = *(void *)(a2 + 40);
  uint64_t buf = (char *)(result + 60);
  uint64_t v10 = a2;
LABEL_3:
  while (2)
  {
    while (1)
    {
      uint64_t v11 = v9;
      uint64_t v9 = v10;
      int v12 = *(_DWORD *)(v10 + 8);
      if (v12 != 11) {
        break;
      }
      if (*(void *)(v9 + 40) == v11)
      {
        uint64_t v10 = *(void *)(v9 + 24);
        if (v10) {
          continue;
        }
      }
      goto LABEL_106;
    }
    switch(v12)
    {
      case 1:
        if (v9 != a2 && *(_DWORD *)(v3 + 56) == 1 && *__xmlIndentTreeOutput())
        {
          int v13 = *(_DWORD *)(v3 + 52);
          if (v13 >= *(_DWORD *)(v3 + 124)) {
            int v13 = *(_DWORD *)(v3 + 124);
          }
          xmlOutputBufferWrite((xmlOutputBufferPtr)v8, v13 * *(_DWORD *)(v3 + 128), buf);
        }
        if (*(void *)(v9 + 40) != v11 && *(void *)(v9 + 24))
        {
          unint64_t result = xmlNodeDumpOutputInternal(v3, v9);
          goto LABEL_106;
        }
        uint64_t v29 = v5;
        xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 1, "<");
        uint64_t v30 = *(void *)(v9 + 72);
        if (v30)
        {
          int v31 = *(const char **)(v30 + 24);
          if (v31)
          {
            xmlOutputBufferWriteString((xmlOutputBufferPtr)v8, v31);
            xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 1, ":");
          }
        }
        xmlOutputBufferWriteString((xmlOutputBufferPtr)v8, *(const char **)(v9 + 16));
        for (uint64_t i = *(void **)(v9 + 96); i; uint64_t i = (void *)*i)
          xmlNsDumpOutput(*(void *)(v3 + 40), (uint64_t)i, v3);
        for (uint64_t j = *(void *)(v9 + 88); j; uint64_t j = *(void *)(j + 48))
          xmlAttrDumpOutput(v3, j);
        uint64_t v34 = *(void *)(v9 + 24);
        if (v34)
        {
          int v35 = *(_DWORD *)(v3 + 56);
          uint64_t v5 = v29;
          if (v35 == 2)
          {
            xmlOutputBufferWriteWSNonSig((xmlBufPtr)v3, 1);
          }
          else if (v35 == 1)
          {
            while ((*(_DWORD *)(v34 + 8) - 3) > 2)
            {
              uint64_t v34 = *(void *)(v34 + 48);
              if (!v34) {
                goto LABEL_113;
              }
            }
            *(_DWORD *)(v3 + 56) = 0;
            uint64_t v4 = v9;
          }
LABEL_113:
          unint64_t result = xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 1, ">");
          if (*(_DWORD *)(v3 + 56) == 1) {
            unint64_t result = xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 1, v6);
          }
          int v48 = *(_DWORD *)(v3 + 52);
          if ((v48 & 0x80000000) == 0) {
            *(_DWORD *)(v3 + 52) = v48 + 1;
          }
          uint64_t v10 = *(void *)(v9 + 24);
          continue;
        }
        int v38 = *(_DWORD *)(v3 + 56);
        if ((*(unsigned char *)(v3 + 48) & 4) != 0)
        {
          uint64_t v5 = v29;
          if (v38 == 2) {
            xmlOutputBufferWriteWSNonSig((xmlBufPtr)v3, 1);
          }
          xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 3, "></");
          uint64_t v39 = *(void *)(v9 + 72);
          if (v39)
          {
            int v40 = *(const char **)(v39 + 24);
            if (v40)
            {
              xmlOutputBufferWriteString((xmlOutputBufferPtr)v8, v40);
              xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 1, ":");
            }
          }
          xmlOutputBufferWriteString((xmlOutputBufferPtr)v8, *(const char **)(v9 + 16));
          if (*(_DWORD *)(v3 + 56) == 2) {
            xmlOutputBufferWriteWSNonSig((xmlBufPtr)v3, 0);
          }
          unint64_t result = xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 1, ">");
        }
        else
        {
          uint64_t v5 = v29;
          if (v38 == 2) {
            xmlOutputBufferWriteWSNonSig((xmlBufPtr)v3, 0);
          }
          unint64_t result = xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 2, "/>");
        }
        goto LABEL_106;
      case 2:
        unint64_t result = xmlAttrDumpOutput(v3, v9);
        goto LABEL_106;
      case 3:
        long long v14 = *(const char **)(v9 + 80);
        if (v14)
        {
          if (*(const xmlChar **)(v9 + 16) == "textnoenc") {
            unint64_t result = xmlOutputBufferWriteString((xmlOutputBufferPtr)v8, v14);
          }
          else {
            unint64_t result = xmlOutputBufferWriteEscape((xmlOutputBufferPtr)v8, (const xmlChar *)v14, *(xmlCharEncodingOutputFunc *)(v3 + 136));
          }
        }
        goto LABEL_106;
      case 4:
        uint64_t v15 = *(const char **)(v9 + 80);
        if (!v15 || (int v16 = *(unsigned __int8 *)v15, v17 = *(const char **)(v9 + 80), v49 = v4, !*v15))
        {
          unint64_t result = xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 12, "<![CDATA[]]>");
          goto LABEL_106;
        }
        while (2)
        {
          if (v16 == 93)
          {
            if (v17[1] == 93)
            {
              long long v18 = v7;
              long long v19 = v6;
              uint64_t v20 = v5;
              long long v21 = v17 + 2;
              if (v17[2] == 62)
              {
                long long v22 = v15;
                xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 9, "<![CDATA[");
                int v23 = v21 - v22;
                uint64_t v24 = v22;
                uint64_t v4 = v49;
                xmlOutputBufferWrite((xmlOutputBufferPtr)v8, v23, v24);
                unint64_t result = xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 3, "]]>");
                uint64_t v15 = v21;
                long long v17 = v21;
              }
              uint64_t v5 = v20;
              uint64_t v6 = v19;
              uint64_t v7 = v18;
            }
            goto LABEL_31;
          }
          if (v16)
          {
LABEL_31:
            int v25 = *(unsigned __int8 *)++v17;
            int v16 = v25;
            continue;
          }
          break;
        }
        if (v15 != v17)
        {
          uint64_t v36 = v15;
          xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 9, "<![CDATA[");
          uint64_t v37 = v36;
          uint64_t v4 = v49;
          xmlOutputBufferWriteString((xmlOutputBufferPtr)v8, v37);
          unint64_t result = xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 3, "]]>");
        }
LABEL_106:
        while (v9 != a2)
        {
          uint64_t v47 = v9;
          uint64_t v9 = v11;
          if (*(_DWORD *)(v3 + 56) == 1 && (*(_DWORD *)(v47 + 8) - 19) >= 2) {
            unint64_t result = xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 1, v6);
          }
          uint64_t v10 = *(void *)(v47 + 48);
          if (v10) {
            goto LABEL_3;
          }
          uint64_t v11 = *(void *)(v11 + 40);
          if (*(_DWORD *)(v9 + 8) == 1)
          {
            int v41 = *(_DWORD *)(v3 + 52);
            BOOL v42 = __OFSUB__(v41, 1);
            int v43 = v41 - 1;
            if (v43 < 0 == v42) {
              *(_DWORD *)(v3 + 52) = v43;
            }
            if (*__xmlIndentTreeOutput() && *(_DWORD *)(v3 + 56) == 1)
            {
              int v44 = *(_DWORD *)(v3 + 52);
              if (v44 >= *(_DWORD *)(v3 + 124)) {
                int v44 = *(_DWORD *)(v3 + 124);
              }
              xmlOutputBufferWrite((xmlOutputBufferPtr)v8, v44 * *(_DWORD *)(v3 + 128), buf);
            }
            xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 2, v7);
            uint64_t v45 = *(void *)(v9 + 72);
            if (v45)
            {
              int v46 = *(const char **)(v45 + 24);
              if (v46)
              {
                xmlOutputBufferWriteString((xmlOutputBufferPtr)v8, v46);
                xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 1, ":");
              }
            }
            xmlOutputBufferWriteString((xmlOutputBufferPtr)v8, *(const char **)(v9 + 16));
            if (*(_DWORD *)(v3 + 56) == 2) {
              xmlOutputBufferWriteWSNonSig((xmlBufPtr)v3, 0);
            }
            unint64_t result = xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 1, ">");
            if (v9 == v4)
            {
              uint64_t v4 = 0;
              *(_DWORD *)(v3 + 56) = v5;
            }
          }
        }
        return result;
      case 5:
        xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 1, "&");
        xmlOutputBufferWriteString((xmlOutputBufferPtr)v8, *(const char **)(v9 + 16));
        unint64_t result = xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 1, ";");
        goto LABEL_106;
      case 7:
        if (v9 != a2 && *(_DWORD *)(v3 + 56) == 1 && *__xmlIndentTreeOutput())
        {
          int v26 = *(_DWORD *)(v3 + 52);
          if (v26 >= *(_DWORD *)(v3 + 124)) {
            int v26 = *(_DWORD *)(v3 + 124);
          }
          xmlOutputBufferWrite((xmlOutputBufferPtr)v8, v26 * *(_DWORD *)(v3 + 128), buf);
        }
        uint64_t v27 = *(void *)(v9 + 80);
        xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 2, "<?");
        xmlOutputBufferWriteString((xmlOutputBufferPtr)v8, *(const char **)(v9 + 16));
        if (v27)
        {
          if (*(void *)(v9 + 80))
          {
            if (*(_DWORD *)(v3 + 56) == 2) {
              xmlOutputBufferWriteWSNonSig((xmlBufPtr)v3, 0);
            }
            else {
              xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 1, " ");
            }
            xmlOutputBufferWriteString((xmlOutputBufferPtr)v8, *(const char **)(v9 + 80));
          }
        }
        else if (*(_DWORD *)(v3 + 56) == 2)
        {
          xmlOutputBufferWriteWSNonSig((xmlBufPtr)v3, 0);
        }
        unint64_t result = xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 2, "?>");
        goto LABEL_106;
      case 8:
        if (v9 != a2 && *(_DWORD *)(v3 + 56) == 1)
        {
          unint64_t result = (uint64_t)__xmlIndentTreeOutput();
          if (*(_DWORD *)result)
          {
            int v28 = *(_DWORD *)(v3 + 52);
            if (v28 >= *(_DWORD *)(v3 + 124)) {
              int v28 = *(_DWORD *)(v3 + 124);
            }
            unint64_t result = xmlOutputBufferWrite((xmlOutputBufferPtr)v8, v28 * *(_DWORD *)(v3 + 128), buf);
          }
        }
        if (*(void *)(v9 + 80))
        {
          xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 4, "<!--");
          xmlOutputBufferWriteString((xmlOutputBufferPtr)v8, *(const char **)(v9 + 80));
          unint64_t result = xmlOutputBufferWrite((xmlOutputBufferPtr)v8, 3, "-->");
        }
        goto LABEL_106;
      case 9:
      case 13:
        unint64_t result = xmlDocContentDumpOutput(v3, v9);
        goto LABEL_106;
      case 14:
        unint64_t result = xmlDtdDumpOutput(v3, v9);
        goto LABEL_106;
      case 15:
        unint64_t result = (uint64_t)xmlBufDumpElementDecl(*(uint64x2_t **)(v8 + 32), (xmlElement *)v9);
        goto LABEL_106;
      case 16:
        unint64_t result = (uint64_t)xmlBufDumpAttributeDecl(*(uint64x2_t **)(v8 + 32), (xmlAttribute *)v9);
        goto LABEL_106;
      case 17:
        unint64_t result = (uint64_t)xmlBufDumpEntityDecl(*(uint64x2_t **)(v8 + 32), (xmlEntity *)v9);
        goto LABEL_106;
      case 18:
        unint64_t result = xmlNsDumpOutput(*(void *)(v3 + 40), v9, v3);
        goto LABEL_106;
      default:
        goto LABEL_106;
    }
  }
}

int xmlOutputBufferWrite(xmlOutputBufferPtr out, int len, const char *buf)
{
  if (!out || out->error) {
    return -1;
  }
  int v6 = len;
  if (len < 0) {
    return 0;
  }
  int v4 = 0;
  p_xmlBufPtr conv = &out->conv;
  p_xmlBufPtr buffer = (uint64x2_t **)&out->buffer;
  while (1)
  {
    size_t v10 = v6 >= 16000 ? 16000 : v6;
    if (out->encoder)
    {
      if (!*p_conv) {
        *p_xmlBufPtr conv = (xmlBufPtr)xmlBufCreate();
      }
      if (xmlBufAdd(*p_buffer, (const xmlChar *)buf, v10)) {
        return -1;
      }
      if (xmlBufUse((const xmlBufPtr)*p_buffer) <= 0xF9F && v6 < 0x3E81) {
        return v4;
      }
      int v12 = xmlCharEncOutput(out, 0);
      if (v12 < 0 && v12 != -3)
      {
        int v24 = 1544;
        __xmlSimpleError(8, 1544, 0, (uint64_t)"encoder error", 0);
        unsigned int v19 = -1;
        goto LABEL_42;
      }
      int v13 = &out->conv;
      if (!out->writecallback)
      {
        LODWORD(v14) = v12 & ~(v12 >> 31);
LABEL_31:
        buf += v10;
        v6 -= v10;
        goto LABEL_37;
      }
    }
    else
    {
      if (xmlBufAdd(*p_buffer, (const xmlChar *)buf, v10)) {
        return -1;
      }
      LODWORD(v14) = v10;
      int v13 = &out->buffer;
      if (!out->writecallback) {
        goto LABEL_31;
      }
    }
    size_t v15 = xmlBufUse(*v13);
    size_t v14 = v15;
    writecallbacint k = out->writecallback;
    buf += v10;
    v6 -= v10;
    if (writecallback) {
      break;
    }
LABEL_37:
    v4 += v14;
    if (v6 <= 0) {
      return v4;
    }
  }
  if ((int)v15 <= 3999 && v6 < 1) {
    return v4;
  }
  context = out->context;
  if (out->encoder)
  {
    long long v18 = xmlBufContent(*p_conv);
    unsigned int v19 = ((uint64_t (*)(void *, xmlChar *, size_t))writecallback)(context, v18, v14);
    uint64_t v20 = &out->conv;
    if ((v19 & 0x80000000) != 0) {
      goto LABEL_41;
    }
    goto LABEL_33;
  }
  long long v21 = xmlBufContent((const xmlBuf *)*p_buffer);
  unsigned int v19 = ((uint64_t (*)(void *, xmlChar *, size_t))writecallback)(context, v21, v14);
  uint64_t v20 = &out->buffer;
  if ((v19 & 0x80000000) == 0)
  {
LABEL_33:
    xmlBufShrink(*v20, v19);
    int written = out->written;
    if (written <= (int)(v19 ^ 0x7FFFFFFF)) {
      int v23 = written + v19;
    }
    else {
      int v23 = 0x7FFFFFFF;
    }
    out->int written = v23;
    goto LABEL_37;
  }
LABEL_41:
  int v24 = 1546;
  __xmlSimpleError(8, 1546, 0, (uint64_t)"write error", 0);
LABEL_42:
  out->error = v24;
  return v19;
}

uint64_t xmlBufAdd(uint64x2_t *a1, const xmlChar *__src, size_t __len)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && __src && !a1[3].i32[2])
  {
    uint64_t v6 = a1->u32[3];
    if (v6 <= 0x7FFFFFFE && a1[2].i64[1] != v6) {
      a1[2].i64[1] = v6;
    }
    uint64_t v8 = a1->u32[2];
    if (v8 <= 0x7FFFFFFE && a1[2].i64[0] != v8) {
      a1[2].i64[0] = v8;
    }
    if ((int)__len >= -1 && a1[1].i32[0] != 2)
    {
      if (!__len) {
        return 0;
      }
      if ((__len & 0x80000000) != 0)
      {
        LODWORD(__len) = xmlStrlen(__src);
        if ((__len & 0x80000000) != 0) {
          return 0xFFFFFFFFLL;
        }
      }
      if (!__len) {
        return 0;
      }
      size_t v9 = __len;
      uint64_t v10 = a1[2].i64[0];
      if (a1[2].i64[1] - v10 > (unint64_t)__len)
      {
LABEL_20:
        memmove((void *)(a1->i64[0] + v10), __src, v9);
        uint64_t result = 0;
        size_t v11 = a1[2].i64[0] + v9;
        a1[2].i64[0] = v11;
        *(unsigned char *)(a1->i64[0] + v11) = 0;
        int8x16_t v12 = (int8x16_t)vdupq_n_s64(0x7FFFFFFFuLL);
        a1->u64[1] = (unint64_t)vmovn_s64((int64x2_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v12, a1[2]), (int8x16_t)a1[2], v12));
        return result;
      }
      if (__len >= (unint64_t)~v10)
      {
        size_t v14 = "growing buffer past SIZE_MAX";
        goto LABEL_27;
      }
      size_t v13 = __len + v10 + 1;
      if (v13 >= 0x989680 && a1[1].i32[0] == 5)
      {
        size_t v14 = "buffer error: text too long\n";
LABEL_27:
        xmlBufMemoryError((uint64_t)a1, (uint64_t)v14);
        return 0xFFFFFFFFLL;
      }
      if (xmlBufResize((uint64_t)a1, v13))
      {
        uint64_t v10 = a1[2].i64[0];
        goto LABEL_20;
      }
      xmlBufMemoryError((uint64_t)a1, (uint64_t)"growing buffer");
      return 2;
    }
  }
  return result;
}

uint64_t xmlBufResize(uint64_t result, size_t size)
{
  if (result)
  {
    uint64_t v2 = result;
    if (*(_DWORD *)(result + 56)) {
      return 0;
    }
    size_t v3 = *(void *)(result + 40);
    size_t v4 = *(unsigned int *)(result + 12);
    if (v4 <= 0x7FFFFFFE && v3 != v4)
    {
      *(void *)(result + 40) = v4;
      size_t v3 = v4;
    }
    size_t v6 = *(void *)(result + 32);
    size_t v7 = *(unsigned int *)(result + 8);
    if (v7 <= 0x7FFFFFFE && v6 != v7)
    {
      *(void *)(result + 32) = v7;
      size_t v6 = v7;
    }
    int v9 = *(_DWORD *)(result + 16);
    if (v9 == 2) {
      return 0;
    }
    if (size >= 0x989680 && v9 == 5)
    {
      uint64_t v10 = "buffer error: text too long\n";
      goto LABEL_17;
    }
    if (v3 > size) {
      return 1;
    }
    switch(v9)
    {
      case 0:
      case 3:
        uint64_t v11 = size + 10;
        if (size >= 0xFFFFFFFFFFFFFFF6) {
          uint64_t v11 = -1;
        }
        if (v3) {
          size_t v12 = v3;
        }
        else {
          size_t v12 = v11;
        }
        while (1)
        {
          if (v12 >= size) {
            goto LABEL_39;
          }
          if ((v12 & 0x8000000000000000) != 0) {
            goto LABEL_56;
          }
          v12 *= 2;
        }
      case 1:
        if (size >= 0xFFFFFFFFFFFFFFF6) {
          size_t v12 = -1;
        }
        else {
          size_t v12 = size + 10;
        }
        goto LABEL_48;
      case 4:
        if (v6 >= 0x1000)
        {
          size_t v12 = v3;
          if (v3 < size)
          {
            size_t v12 = v3;
            do
            {
              if ((v12 & 0x8000000000000000) != 0)
              {
LABEL_56:
                xmlBufMemoryError(result, (uint64_t)"growing buffer");
                return 0;
              }
              v12 *= 2;
            }
            while (v12 < size);
LABEL_39:
            if (v9 == 3)
            {
              size_t v13 = *(void **)(result + 24);
              if (v13)
              {
                size_t v14 = *(void *)v2 - (void)v13;
                if (v14 > v12)
                {
                  memmove(v13, *(const void **)v2, v6);
                  size_t v15 = *(char **)(v2 + 24);
                  goto LABEL_59;
                }
                long long v18 = (char *)xmlRealloc(v13, v14 + v12);
                if (v18)
                {
                  *(void *)(v2 + 24) = v18;
                  size_t v15 = &v18[v14];
                  goto LABEL_59;
                }
                goto LABEL_61;
              }
            }
          }
        }
        else
        {
          size_t v12 = size;
        }
LABEL_48:
        if (!*(void *)v2)
        {
          int v16 = (char *)xmlMallocAtomic(v12);
LABEL_52:
          size_t v15 = v16;
          if (!v16) {
            goto LABEL_61;
          }
LABEL_59:
          *(void *)uint64_t v2 = v15;
          *(void *)(v2 + 40) = v12;
          v15[*(void *)(v2 + 32)] = 0;
          int8x16_t v19 = (int8x16_t)vdupq_n_s64(0x7FFFFFFFuLL);
          *(int32x2_t *)(v2 + 8) = vmovn_s64((int64x2_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v19, *(uint64x2_t *)(v2 + 32)), *(int8x16_t *)(v2 + 32), v19));
          return 1;
        }
        if (v3 - v6 <= 0x63)
        {
          int v16 = (char *)xmlRealloc(*(void **)v2, v12);
          goto LABEL_52;
        }
        long long v17 = (char *)xmlMallocAtomic(v12);
        if (v17)
        {
          size_t v15 = v17;
          memcpy(v17, *(const void **)v2, *(void *)(v2 + 32));
          xmlFree(*(void **)v2);
          goto LABEL_59;
        }
LABEL_61:
        uint64_t v10 = "growing buffer";
LABEL_17:
        __xmlSimpleError(29, 2, 0, 0, (uint64_t)v10);
        if (!*(_DWORD *)(v2 + 56))
        {
          uint64_t result = 0;
          *(_DWORD *)(v2 + 56) = 2;
          return result;
        }
        return 0;
      default:
        if (size >= 0xFFFFFFFFFFFFFFF6) {
          size_t v12 = -1;
        }
        else {
          size_t v12 = size + 10;
        }
        goto LABEL_39;
    }
  }
  return result;
}

int xmlStrlen(const xmlChar *str)
{
  if (str)
  {
    if (*str)
    {
      unint64_t v1 = 0;
      while (str[++v1])
        ;
      if (v1 >> 31) {
        LODWORD(str) = 0;
      }
      else {
        LODWORD(str) = v1;
      }
    }
    else
    {
      LODWORD(str) = 0;
    }
  }
  return (int)str;
}

void *xmlReallocChecked(void *a1, size_t a2)
{
  uint64_t result = malloc_type_realloc(a1, a2, 0xF6A93640uLL);
  if (!result) {
    abort();
  }
  return result;
}

int xmlOutputBufferWriteString(xmlOutputBufferPtr out, const char *str)
{
  if (!out) {
    return -1;
  }
  int v3 = -1;
  if (!str) {
    return v3;
  }
  if (out->error) {
    return v3;
  }
  int v3 = strlen(str);
  if (v3 < 1) {
    return v3;
  }

  return xmlOutputBufferWrite(out, v3, str);
}

int *__xmlIndentTreeOutput(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlIndentTreeOutput;
  }
  else {
    return &xmlGetGlobalState()->xmlIndentTreeOutput;
  }
}

int xmlOutputBufferWriteEscape(xmlOutputBufferPtr out, const xmlChar *str, xmlCharEncodingOutputFunc escaping)
{
  if (!out) {
    return -1;
  }
  int v3 = (const char *)str;
  unsigned int v4 = -1;
  if (str)
  {
    if (!out->error)
    {
      p_xmlBufPtr buffer = (unint64_t *)&out->buffer;
      xmlBufPtr buffer = out->buffer;
      if (buffer)
      {
        if (xmlBufGetAllocationScheme((uint64_t)buffer) != 2)
        {
          int v9 = strlen(v3);
          if (v9 < 0) {
            return 0;
          }
          if (!out->error)
          {
            uint64_t v10 = 0;
            int v34 = 0;
            if (escaping) {
              uint64_t v11 = (uint64_t (*)(xmlChar *, int *, const char *, int *))escaping;
            }
            else {
              uint64_t v11 = (uint64_t (*)(xmlChar *, int *, const char *, int *))xmlEscapeContent;
            }
            p_xmlBufPtr conv = &out->conv;
            while (1)
            {
              int v33 = v9;
              int v34 = xmlBufAvail(*p_buffer);
              if (v34 > 39) {
                break;
              }
              int v13 = xmlBufGrow(*p_buffer, 0x64u);
              unsigned int v4 = -1;
              uint64_t v14 = v10;
              LODWORD(v10) = -1;
              if (v13 < 0) {
                return v4;
              }
LABEL_45:
              if (v9 < 1) {
                return v14;
              }
              unsigned int v4 = v14;
              BOOL v28 = v10 == v14;
              uint64_t v10 = v14;
              if (v28) {
                return v4;
              }
            }
            if (out->encoder)
            {
              if (!*p_conv) {
                *p_xmlBufPtr conv = (xmlBufPtr)xmlBufCreate();
              }
              size_t v15 = xmlBufEnd((xmlBufPtr)*p_buffer);
              unsigned int v4 = -1;
              if ((v11(v15, &v34, v3, &v33) & 0x80000000) != 0 || !v34) {
                return v4;
              }
              xmlBufAddLen((uint64x2_t *)*p_buffer, v34);
              if (xmlBufUse((const xmlBufPtr)*p_buffer) <= 0xF9F && v33 == v9) {
                return v10;
              }
              int v16 = xmlCharEncOutput(out, 0);
              if (v16 < 0 && v16 != -3)
              {
                uint64_t v30 = "encoder error";
                int v31 = 1544;
                int v32 = 1544;
                goto LABEL_56;
              }
              long long v17 = &out->conv;
              if (!out->writecallback)
              {
                LODWORD(v18) = v16 & ~(v16 >> 31);
LABEL_36:
                v3 += v33;
                v9 -= v33;
                goto LABEL_37;
              }
            }
            else
            {
              int8x16_t v19 = xmlBufEnd((xmlBufPtr)*p_buffer);
              unsigned int v4 = -1;
              if ((v11(v19, &v34, v3, &v33) & 0x80000000) != 0 || !v34) {
                return v4;
              }
              xmlBufAddLen((uint64x2_t *)out->buffer, v34);
              long long v17 = &out->buffer;
              if (!out->writecallback)
              {
                LODWORD(v18) = v34;
                goto LABEL_36;
              }
            }
            size_t v20 = xmlBufUse(*v17);
            size_t v18 = v20;
            writecallbacint k = out->writecallback;
            v3 += v33;
            v9 -= v33;
            if (writecallback)
            {
              if ((int)v20 <= 3999 && v9 < 1) {
                return v10;
              }
              context = out->context;
              if (out->encoder)
              {
                int v23 = xmlBufContent(*p_conv);
                unsigned int v4 = ((uint64_t (*)(void *, xmlChar *, size_t))writecallback)(context, v23, v18);
                int v24 = &out->conv;
                if ((v4 & 0x80000000) != 0) {
                  goto LABEL_55;
                }
              }
              else
              {
                int v25 = xmlBufContent((const xmlBuf *)*p_buffer);
                unsigned int v4 = ((uint64_t (*)(void *, xmlChar *, size_t))writecallback)(context, v25, v18);
                int v24 = &out->buffer;
                if ((v4 & 0x80000000) != 0)
                {
LABEL_55:
                  uint64_t v30 = "write error";
                  int v31 = 1546;
                  int v32 = 1546;
LABEL_56:
                  __xmlSimpleError(8, v32, 0, (uint64_t)v30, 0);
                  out->error = v31;
                  return v4;
                }
              }
              xmlBufShrink(*v24, v4);
              int written = out->written;
              if (written <= (int)(v4 ^ 0x7FFFFFFF)) {
                int v27 = written + v4;
              }
              else {
                int v27 = 0x7FFFFFFF;
              }
              out->int written = v27;
              goto LABEL_44;
            }
LABEL_37:
            if (xmlBufAvail(*p_buffer) <= 0xF9F) {
              xmlBufGrow(*p_buffer, 0xFA0u);
            }
LABEL_44:
            uint64_t v14 = (v18 + v10);
            goto LABEL_45;
          }
        }
      }
    }
  }
  return v4;
}

uint64_t xmlBufGetAllocationScheme(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 16);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t xmlEscapeContent(unsigned char *a1, int *a2, unsigned __int8 *a3, int *a4)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *a4;
  BOOL v6 = (int)v5 < 1 || (int)v4 < 1;
  LODWORD(i) = a3;
  LODWORD(v8) = a1;
  if (!v6)
  {
    unint64_t v9 = (unint64_t)&a1[v4];
    unint64_t v10 = (unint64_t)&a3[v5];
    uint64_t v8 = a1;
    for (uint64_t i = a3; (unint64_t)i < v10 && (unint64_t)v8 < v9; ++i)
    {
      unsigned int v11 = *i;
      if (v11 > 0x3B)
      {
        if (v11 == 62)
        {
          if ((uint64_t)(v9 - (void)v8) < 4) {
            break;
          }
          *(_DWORD *)uint64_t v8 = 997484326;
          v8 += 4;
          continue;
        }
        if (v11 == 60)
        {
          if ((uint64_t)(v9 - (void)v8) < 4) {
            break;
          }
          *(_DWORD *)uint64_t v8 = 997485606;
          v8 += 4;
          continue;
        }
      }
      else
      {
        if (v11 == 13)
        {
          if ((uint64_t)(v9 - (void)v8) < 5) {
            break;
          }
          *(_DWORD *)uint64_t v8 = 858858278;
          goto LABEL_17;
        }
        if (v11 == 38)
        {
          if ((uint64_t)(v9 - (void)v8) < 5) {
            break;
          }
          *(_DWORD *)uint64_t v8 = 1886216486;
LABEL_17:
          v8[4] = 59;
          v8 += 5;
          continue;
        }
      }
      *v8++ = v11;
    }
  }
  *a2 = v8 - a1;
  *a4 = i - a3;
  return 0;
}

unint64_t xmlBufAvail(unint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 56))
    {
      return 0;
    }
    else
    {
      unint64_t v1 = *(void *)(result + 40);
      unint64_t v2 = *(unsigned int *)(result + 12);
      if (v2 <= 0x7FFFFFFE && v1 != v2)
      {
        *(void *)(result + 40) = v2;
        unint64_t v1 = v2;
      }
      unint64_t v4 = *(void *)(result + 32);
      unint64_t v5 = *(unsigned int *)(result + 8);
      if (v5 <= 0x7FFFFFFE && v4 != v5)
      {
        *(void *)(result + 32) = v5;
        unint64_t v4 = v5;
      }
      if (v1 <= v4) {
        return 0;
      }
      else {
        return v1 + ~v4;
      }
    }
  }
  return result;
}

int *xmlSaveCtxtInit(int *result)
{
  if (result)
  {
    unint64_t v1 = result;
    if (!*((void *)result + 3) && !*((void *)result + 17)) {
      *((void *)result + 17) = xmlEscapeEntities;
    }
    unint64_t v2 = __xmlTreeIndentString();
    int v3 = xmlStrlen((const xmlChar *)*v2);
    if (*__xmlTreeIndentString() && v3)
    {
      int v4 = 60 / v3;
      v1[31] = 60 / v3;
      v1[32] = v3;
      if (60 / v3 >= 1)
      {
        int v5 = 0;
        do
        {
          BOOL v6 = (char *)v1 + v1[32] * (uint64_t)v5 + 60;
          size_t v7 = (const void **)__xmlTreeIndentString();
          memcpy(v6, *v7, v1[32]);
          ++v5;
          int v4 = v1[31];
        }
        while (v5 < v4);
        int v3 = v1[32];
      }
      *((unsigned char *)v1 + v3 * v4 + 60) = 0;
    }
    else
    {
      *(_OWORD *)((char *)v1 + 105) = 0u;
      *(_OWORD *)(v1 + 2xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0u;
      *(_OWORD *)(v1 + 19) = 0u;
      *(_OWORD *)(v1 + 15) = 0u;
    }
    uint64_t result = __xmlSaveNoEmptyTags();
    if (*result) {
      v1[12] |= 4u;
    }
  }
  return result;
}

const char **__xmlTreeIndentString(void)
{
  if (xmlIsMainThread()) {
    return (const char **)&xmlTreeIndentString;
  }
  else {
    return &xmlGetGlobalState()->xmlTreeIndentString;
  }
}

xmlSAXHandlerV1 *__xmlDefaultSAXHandler(void)
{
  if (xmlIsMainThread()) {
    return (xmlSAXHandlerV1 *)xmlDefaultSAXHandler;
  }
  else {
    return &xmlGetGlobalState()->xmlDefaultSAXHandler;
  }
}

void *xmlBufCreateSize(uint64_t a1)
{
  if (a1 == -1) {
    return 0;
  }
  unint64_t v2 = xmlMalloc(0x40uLL);
  int v3 = v2;
  if (v2)
  {
    v2[4] = 0;
    *((_DWORD *)v2 + 14) = 0;
    v2[6] = 0;
    xmlBufferAllocationScheme v4 = *__xmlBufferAllocScheme();
    if (a1) {
      unint64_t v5 = a1 + 1;
    }
    else {
      unint64_t v5 = 0;
    }
    v3[5] = v5;
    LODWORD(v6) = 0x7FFFFFFF;
    if (v5 >= 0x7FFFFFFF) {
      LODWORD(v5) = 0x7FFFFFFF;
    }
    if (v3[4] < 0x7FFFFFFFuLL) {
      uint64_t v6 = v3[4];
    }
    *((_DWORD *)v3 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = v5;
    *((_DWORD *)v3 + 4) = v4;
    *((_DWORD *)v3 + 2) = v6;
    if (!a1)
    {
      void *v3 = 0;
      goto LABEL_15;
    }
    size_t v7 = xmlMallocAtomic(a1 + 1);
    void *v3 = v7;
    if (v7)
    {
      bzero(v7, v3[5]);
LABEL_15:
      v3[3] = 0;
      return v3;
    }
    __xmlSimpleError(29, 2, 0, 0, (uint64_t)"creating buffer");
    if (!*((_DWORD *)v3 + 14)) {
      *((_DWORD *)v3 + 14) = 2;
    }
    xmlFree(v3);
    return 0;
  }
  __xmlSimpleError(29, 2, 0, 0, (uint64_t)"creating buffer");
  return v3;
}

xmlBufferAllocationScheme *__xmlBufferAllocScheme(void)
{
  if (xmlIsMainThread()) {
    return (xmlBufferAllocationScheme *)&xmlBufferAllocScheme;
  }
  else {
    return &xmlGetGlobalState()->xmlBufferAllocScheme;
  }
}

int xmlIsMainThread(void)
{
  return pthread_main_np() == 1;
}

uint64_t xmlAttrSerializeContent(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 24);
  if (v2)
  {
    uint64_t v4 = result;
    do
    {
      int v5 = *(_DWORD *)(v2 + 8);
      if (v5 == 5)
      {
        xmlBufAdd(*(uint64x2_t **)(v4 + 32), (const xmlChar *)"&", 1uLL);
        uint64_t v6 = *(uint64x2_t **)(v4 + 32);
        size_t v7 = *(const xmlChar **)(v2 + 16);
        size_t v8 = xmlStrlen(v7);
        xmlBufAdd(v6, v7, v8);
        uint64_t result = xmlBufAdd(*(uint64x2_t **)(v4 + 32), (const xmlChar *)";", 1uLL);
      }
      else if (v5 == 3)
      {
        uint64_t result = (uint64_t)xmlBufAttrSerializeTxtContent(*(uint64x2_t **)(v4 + 32), *(void *)(a2 + 64), a2, *(const xmlChar **)(v2 + 80));
      }
      uint64_t v2 = *(void *)(v2 + 48);
    }
    while (v2);
  }
  return result;
}

uint64x2_t *xmlBufAttrSerializeTxtContent(uint64x2_t *result, uint64_t a2, int a3, const xmlChar *__src)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!__src) {
    return result;
  }
  uint64_t v4 = result;
  int v5 = __src;
  while (1)
  {
    unsigned int v6 = *v5;
    if (v6 <= 0x21) {
      break;
    }
    if (*v5 > 0x3Bu)
    {
      if (v6 == 60)
      {
        if (__src != v5) {
          xmlBufAdd(v4, __src, (v5 - __src));
        }
        size_t v7 = v4;
        size_t v8 = "&lt;";
        goto LABEL_35;
      }
      if (v6 == 62)
      {
        if (__src != v5) {
          xmlBufAdd(v4, __src, (v5 - __src));
        }
        size_t v7 = v4;
        size_t v8 = "&gt;";
LABEL_35:
        size_t v9 = 4;
        goto LABEL_36;
      }
LABEL_38:
      if (((char)v6 & 0x80000000) == 0 || (unint64_t v10 = (xmlChar *)(v5 + 1), !v5[1]) || a2 && *(void *)(a2 + 112))
      {
        ++v5;
      }
      else
      {
        int v23 = 0;
        uint64_t __srca = 0;
        if (__src != v5) {
          xmlBufAdd(v4, __src, (v5 - __src));
        }
        unsigned int v11 = *v5;
        if (v11 <= 0xBF)
        {
          int v12 = 1400;
          int v13 = a3;
          uint64_t v14 = "string is not in UTF-8\n";
          goto LABEL_65;
        }
        if (v11 <= 0xDF)
        {
          int v15 = (v11 & 0x1F) << 6;
          xmlChar v16 = *v10;
          uint64_t v17 = 2;
          goto LABEL_56;
        }
        if (v11 > 0xEF)
        {
          if (v11 > 0xF7) {
            goto LABEL_64;
          }
          if (!v5[2]) {
            goto LABEL_64;
          }
          xmlChar v16 = v5[3];
          if (!v16) {
            goto LABEL_64;
          }
          int v15 = (((v11 & 7) << 12) | ((*v10 & 0x3F) << 6) | v5[2] & 0x3F) << 6;
          uint64_t v17 = 4;
LABEL_56:
          unsigned int v18 = v15 | v16 & 0x3F;
          if (v18 > 0xFF)
          {
            if (v18 - 0x10000 >= 0x100000 && v18 >> 11 >= 0x1B && (v18 - 57344) >> 1 >= 0xFFF) {
              goto LABEL_64;
            }
          }
          else if (v18 <= 0x1F && (v18 > 0xD || ((1 << v18) & 0x2600) == 0))
          {
            goto LABEL_64;
          }
          uint64_t v19 = v17;
          xmlSerializeHexCharRef((uint64_t)&__srca, v18);
          uint64_t result = (uint64x2_t *)xmlBufAdd(v4, (const xmlChar *)&__srca, 0xFFFFFFFFuLL);
          __src = &v5[v19];
          v5 += v19;
        }
        else
        {
          xmlChar v16 = v5[2];
          if (v16)
          {
            int v15 = (*v10 & 0x3F | ((v11 & 0xF) << 6)) << 6;
            uint64_t v17 = 3;
            goto LABEL_56;
          }
LABEL_64:
          int v12 = 1401;
          int v13 = a3;
          uint64_t v14 = "invalid character value\n";
LABEL_65:
          __xmlSimpleError(7, v12, v13, (uint64_t)v14, 0);
          xmlSerializeHexCharRef((uint64_t)&__srca, *v5);
          uint64_t result = (uint64x2_t *)xmlBufAdd(v4, (const xmlChar *)&__srca, 0xFFFFFFFFuLL);
          __src = ++v5;
        }
      }
    }
    else
    {
      if (v6 != 34)
      {
        if (v6 == 38)
        {
          if (__src != v5) {
            xmlBufAdd(v4, __src, (v5 - __src));
          }
          size_t v7 = v4;
          size_t v8 = "&amp;";
LABEL_31:
          size_t v9 = 5;
          goto LABEL_36;
        }
        goto LABEL_38;
      }
      if (__src != v5) {
        xmlBufAdd(v4, __src, (v5 - __src));
      }
      size_t v7 = v4;
      size_t v8 = "&quot;";
      size_t v9 = 6;
LABEL_36:
      uint64_t result = (uint64x2_t *)xmlBufAdd(v7, (const xmlChar *)v8, v9);
      __src = ++v5;
    }
  }
  if (*v5 > 9u)
  {
    if (v6 == 10)
    {
      if (__src != v5) {
        xmlBufAdd(v4, __src, (v5 - __src));
      }
      size_t v7 = v4;
      size_t v8 = "&#10;";
      goto LABEL_31;
    }
    if (v6 == 13)
    {
      if (__src != v5) {
        xmlBufAdd(v4, __src, (v5 - __src));
      }
      size_t v7 = v4;
      size_t v8 = "&#13;";
      goto LABEL_31;
    }
    goto LABEL_38;
  }
  if (v6 == 9)
  {
    if (__src != v5) {
      xmlBufAdd(v4, __src, (v5 - __src));
    }
    size_t v7 = v4;
    size_t v8 = "&#9;";
    goto LABEL_35;
  }
  if (*v5) {
    goto LABEL_38;
  }
  if (__src != v5) {
    return (uint64x2_t *)xmlBufAdd(v4, __src, (v5 - __src));
  }
  return result;
}

int *__xmlSaveNoEmptyTags(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlSaveNoEmptyTags;
  }
  else {
    return &xmlGetGlobalState()->xmlSaveNoEmptyTags;
  }
}

uint64_t htmlCompareTags(const xmlChar *a1, const xmlChar **a2)
{
  return xmlStrcasecmp(a1, *a2);
}

BOOL xmlOnceInit()
{
  pthread_key_create((pthread_key_t *)&globalkey, (void (__cdecl *)(void *))xmlFreeGlobalState);

  return __xmlInitializeDict();
}

BOOL __xmlInitializeDict()
{
  if (xmlDictMutex) {
    return 1;
  }
  pthread_once(&once_control_0, _xmlInitializeDictMutex);
  return xmlDictMutex != 0;
}

uint64_t htmlCompareStartClose(const char **a1, const char **a2)
{
  uint64_t result = strcmp(*a1, *a2);
  if (!result)
  {
    int v5 = a1[1];
    unsigned int v6 = a2[1];
    return strcmp(v5, v6);
  }
  return result;
}

xmlAttrPtr xmlNewProp(xmlNodePtr node, const xmlChar *name, const xmlChar *value)
{
  if (name) {
    return xmlNewPropInternal((uint64_t)node, 0, (xmlChar *)name, value, 0);
  }
  else {
    return 0;
  }
}

xmlErrorPtr xmlCtxtGetLastError(xmlErrorPtr ctx)
{
  if (ctx)
  {
    if (HIDWORD(ctx[6].ctxt)) {
      return (xmlErrorPtr)((char *)ctx + 600);
    }
    else {
      return 0;
    }
  }
  return ctx;
}

int htmlCtxtUseOptions(htmlParserCtxtPtr ctxt, int options)
{
  if (!ctxt) {
    return -1;
  }
  if (htmlParserNeedsNoBlankQuirk_hasEvaluatedQuirk != -1) {
    dispatch_once(&htmlParserNeedsNoBlankQuirk_hasEvaluatedQuirk, &__block_literal_global);
  }
  if (htmlParserNeedsNoBlankQuirk_needsQuirk) {
    int v4 = options | 0x100;
  }
  else {
    int v4 = options;
  }
  if ((v4 & 0x40) == 0)
  {
    if ((v4 & 0x20) == 0) {
      goto LABEL_9;
    }
LABEL_13:
    sax = ctxt->sax;
    ctxt->vctxt.error = 0;
    sax->error = 0;
    sax->fatalError = 0;
    v4 -= 32;
    ctxt->options |= 0x20u;
    if ((v4 & 0x80) == 0) {
      goto LABEL_10;
    }
    goto LABEL_14;
  }
  ctxt->sax->warning = 0;
  ctxt->vctxt.warning = 0;
  v4 -= 64;
  ctxt->options |= 0x40u;
  if ((v4 & 0x20) != 0) {
    goto LABEL_13;
  }
LABEL_9:
  if ((v4 & 0x80) == 0)
  {
LABEL_10:
    int v5 = 0;
    goto LABEL_15;
  }
LABEL_14:
  v4 -= 128;
  ctxt->options |= 0x80u;
  int v5 = 1;
LABEL_15:
  ctxt->pedantic = v5;
  if ((v4 & 0x100) != 0)
  {
    int v8 = 0;
    ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
    v4 -= 256;
    ctxt->options |= 0x100u;
  }
  else
  {
    int v8 = 1;
  }
  ctxt->keepBlanks = v8;
  int result = v4 & 0xFFFFFFFE;
  ctxt->recovery = v4 & 1;
  if ((v4 & 0x10000) != 0)
  {
    ctxt->options |= 0x10000u;
    result -= 0x10000;
    if ((result & 0x80000) == 0)
    {
LABEL_20:
      if ((result & 4) == 0) {
        goto LABEL_21;
      }
      goto LABEL_27;
    }
  }
  else if ((v4 & 0x80000) == 0)
  {
    goto LABEL_20;
  }
  ctxt->options |= 0x80000u;
  result -= 0x80000;
  if ((result & 4) == 0)
  {
LABEL_21:
    if ((result & 0x200000) == 0) {
      goto LABEL_22;
    }
LABEL_28:
    ctxt->options |= 0x200000u;
    result -= 0x200000;
    if ((result & 0x2000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
LABEL_27:
  ctxt->options |= 4u;
  result -= 4;
  if ((result & 0x200000) != 0) {
    goto LABEL_28;
  }
LABEL_22:
  if ((result & 0x2000) != 0)
  {
LABEL_23:
    ctxt->options |= 0x2000u;
    result -= 0x2000;
  }
LABEL_24:
  ctxt->dictNames = 0;
  return result;
}

uint64_t __startElementNSNeedsUndeclaredPrefixQuirk_block_invoke()
{
  uint64_t result = (uint64_t)_dyld_get_image_name(0);
  if (result
    && (uint64_t result = (uint64_t)strrchr((char *)result, 47)) != 0
    && (uint64_t result = strcmp((const char *)(result + 1), "Microsoft Document Connection"), !result))
  {
    uint64_t result = dyld_get_program_sdk_version();
    BOOL v1 = result >> 8 < 0xA09;
  }
  else
  {
    BOOL v1 = 0;
  }
  startElementNSNeedsUndeclaredPrefixQuirk_needsQuirint k = v1;
  return result;
}

int xmlCtxtUseOptions(xmlParserCtxtPtr ctxt, int options)
{
  return xmlCtxtUseOptionsInternal((uint64_t *)ctxt, *(uint64_t *)&options, 0);
}

int xmlStrncmp(const xmlChar *str1, const xmlChar *str2, int len)
{
  int result = 0;
  if (str1 != str2)
  {
    int v5 = len - 1;
    if (len >= 1)
    {
      if (str1)
      {
        if (str2)
        {
          do
          {
            int v6 = *str1;
            int v7 = *str2;
            int result = v6 - v7;
            if (v6 != v7) {
              break;
            }
            if (!v5) {
              break;
            }
            ++str1;
            ++str2;
            --v5;
          }
          while (v7);
        }
        else
        {
          return 1;
        }
      }
      else
      {
        return -1;
      }
    }
  }
  return result;
}

void xmlSetExternalEntityLoader(xmlExternalEntityLoader f)
{
  xmlCurrentExternalEntityLoader = (uint64_t (*)(char *, char *, xmlParserCtxtPtr))f;
}

xmlExternalEntityLoader xmlGetExternalEntityLoader(void)
{
  return (xmlExternalEntityLoader)xmlCurrentExternalEntityLoader;
}

void xmlInitializeGlobalState(xmlGlobalStatePtr gs)
{
  uint64_t v2 = (xmlMutex *)xmlThrDefMutex;
  if (!xmlThrDefMutex)
  {
    pthread_once(&once_control_1, (void (*)(void))_xmlInitGlobalsOnce);
    uint64_t v2 = (xmlMutex *)xmlThrDefMutex;
  }
  xmlMutexLock(v2);
  initdocbDefaultSAXHandler(&gs->docbDefaultSAXHandler);
  inithtmlDefaultSAXHandler(&gs->htmlDefaultSAXHandler);
  gs->oldXMLWDcompatibility = 0;
  gs->xmlBufferAllocScheme = xmlBufferAllocSchemeThrDef;
  gs->xmlDefaultBufferSize = xmlDefaultBufferSizeThrDef;
  initxmlDefaultSAXHandler(&gs->xmlDefaultSAXHandler, 1);
  gs->xmlDefaultSAXLocator.getPublicId = xmlSAX2GetPublicId;
  gs->xmlDefaultSAXLocator.getSystemId = xmlSAX2GetSystemId;
  gs->xmlDefaultSAXLocator.getLineNumber = xmlSAX2GetLineNumber;
  gs->xmlDefaultSAXLocator.getColumnNumber = xmlSAX2GetColumnNumber;
  gs->xmlDoValidityCheckingDefaultValue = xmlDoValidityCheckingDefaultValueThrDef;
  gs->xmlFree = (xmlFreeFunc)MEMORY[0x1E4F14838];
  gs->xmlMalloc = (xmlMallocFunc)xmlMallocZero;
  gs->xmlMallocAtomic = (xmlMallocFunc)xmlMallocZero;
  gs->xmlRealloc = (xmlReallocFunc)xmlReallocChecked;
  gs->xmlMemStrdup = (xmlStrdupFunc)xmlStrdup;
  gs->xmlGetWarningsDefaultValue = xmlGetWarningsDefaultValueThrDef;
  gs->xmlIndentTreeOutput = xmlIndentTreeOutputThrDef;
  gs->xmlTreeIndentString = (const char *)xmlTreeIndentStringThrDef;
  gs->xmlKeepBlanksDefaultValue = xmlKeepBlanksDefaultValueThrDef;
  gs->xmlLineNumbersDefaultValue = xmlLineNumbersDefaultValueThrDef;
  gs->xmlLoadExtDtdDefaultValue = xmlLoadExtDtdDefaultValueThrDef;
  gs->xmlParserDebugEntities = xmlParserDebugEntitiesThrDef;
  gs->xmlParserVersion = "20913";
  gs->xmlPedanticParserDefaultValue = xmlPedanticParserDefaultValueThrDef;
  gs->xmlSaveNoEmptyTags = xmlSaveNoEmptyTagsThrDef;
  gs->xmlSubstituteEntitiesDefaultValue = xmlSubstituteEntitiesDefaultValueThrDef;
  gs->xmlGenericError = (xmlGenericErrorFunc)xmlGenericErrorThrDef;
  gs->xmlStructuredError = (xmlStructuredErrorFunc)xmlStructuredErrorThrDef;
  gs->xmlGenericErrorContext = (void *)xmlGenericErrorContextThrDef;
  gs->xmlStructuredErrorContext = (void *)xmlStructuredErrorContextThrDef;
  gs->xmlRegisterNodeDefaultValue = (xmlRegisterNodeFunc)xmlRegisterNodeDefaultValueThrDef;
  gs->xmlDeregisterNodeDefaultValue = (xmlDeregisterNodeFunc)xmlDeregisterNodeDefaultValueThrDef;
  gs->xmlParserInputBufferCreateFilenameValue = (xmlParserInputBufferCreateFilenameFunc)xmlParserInputBufferCreateFilenameValueThrDef;
  gs->xmlOutputBufferCreateFilenameValue = (xmlOutputBufferCreateFilenameFunc)xmlOutputBufferCreateFilenameValueThrDef;
  gs->xmlLastError.node = 0;
  *(_OWORD *)&gs->xmlLastError.str2 = 0u;
  *(_OWORD *)&gs->xmlLastError.int1 = 0u;
  *(_OWORD *)&gs->xmlLastError.level = 0u;
  *(_OWORD *)&gs->xmlLastError.int line = 0u;
  *(_OWORD *)&gs->xmlLastError.domain = 0u;
  int v3 = (xmlMutex *)xmlThrDefMutex;

  xmlMutexUnlock(v3);
}

void xmlMutexLock(xmlMutexPtr tok)
{
  if (tok) {
    pthread_mutex_lock((pthread_mutex_t *)tok);
  }
}

void initxmlDefaultSAXHandler(xmlSAXHandlerV1 *hdlr, int warning)
{
  if (hdlr->initialized != 1)
  {
    hdlr->internalSubset = xmlSAX2InternalSubset;
    hdlr->externalSubsetSAXFunc externalSubset = xmlSAX2ExternalSubset;
    hdlr->isStandalone = xmlSAX2IsStandalone;
    hdlr->hasInternalSubset = xmlSAX2HasInternalSubset;
    hdlr->hasExternalSubset = xmlSAX2HasExternalSubset;
    hdlr->resolveEntity = xmlSAX2ResolveEntity;
    hdlr->getEntity = xmlSAX2GetEntity;
    hdlr->getParameterEntity = xmlSAX2GetParameterEntity;
    hdlr->entityDecl = xmlSAX2EntityDecl;
    hdlr->attributeDecl = xmlSAX2AttributeDecl;
    hdlr->elementDecl = xmlSAX2ElementDecl;
    hdlr->notationDecl = xmlSAX2NotationDecl;
    hdlr->unparsedEntityDecl = xmlSAX2UnparsedEntityDecl;
    hdlr->setDocumentLocatorSAXFunc setDocumentLocator = xmlSAX2SetDocumentLocator;
    hdlr->startDocumentSAXFunc startDocument = xmlSAX2StartDocument;
    hdlr->endDocumentSAXFunc endDocument = xmlSAX2EndDocument;
    hdlr->startElementSAXFunc startElement = xmlSAX2StartElement;
    hdlr->endElement = xmlSAX2EndElement;
    hdlr->reference = xmlSAX2Reference;
    hdlr->characters = xmlSAX2Characters;
    hdlr->ignorableWhitespace = xmlSAX2Characters;
    hdlr->cdataBlocint k = xmlSAX2CDataBlock;
    hdlr->processingInstruction = xmlSAX2ProcessingInstruction;
    if (warning) {
      uint64_t v2 = xmlParserWarning;
    }
    else {
      uint64_t v2 = 0;
    }
    hdlr->warning = v2;
    hdlr->error = xmlParserError;
    hdlr->fatalError = xmlParserError;
    hdlr->initialized = 1;
  }
}

void inithtmlDefaultSAXHandler(xmlSAXHandlerV1 *hdlr)
{
  if (hdlr->initialized != 1)
  {
    hdlr->internalSubset = xmlSAX2InternalSubset;
    hdlr->externalSubsetSAXFunc externalSubset = 0;
    *(_OWORD *)&hdlr->isStandalone = 0u;
    *(_OWORD *)&hdlr->hasExternalSubset = 0u;
    hdlr->getEntity = xmlSAX2GetEntity;
    *(_OWORD *)&hdlr->entityDecl = 0u;
    *(_OWORD *)&hdlr->attributeDecl = 0u;
    hdlr->unparsedEntityDecl = 0;
    hdlr->setDocumentLocatorSAXFunc setDocumentLocator = xmlSAX2SetDocumentLocator;
    hdlr->startDocumentSAXFunc startDocument = xmlSAX2StartDocument;
    hdlr->endDocumentSAXFunc endDocument = xmlSAX2EndDocument;
    hdlr->startElementSAXFunc startElement = xmlSAX2StartElement;
    hdlr->endElement = xmlSAX2EndElement;
    hdlr->reference = 0;
    hdlr->characters = xmlSAX2Characters;
    hdlr->getParameterEntity = 0;
    hdlr->cdataBlocint k = xmlSAX2CDataBlock;
    hdlr->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
    hdlr->processingInstruction = xmlSAX2ProcessingInstruction;
    hdlr->comment = xmlSAX2Comment;
    hdlr->warning = xmlParserWarning;
    hdlr->error = xmlParserError;
    hdlr->fatalError = xmlParserError;
    hdlr->initialized = 1;
  }
}

void initdocbDefaultSAXHandler(xmlSAXHandlerV1 *hdlr)
{
  if (hdlr->initialized != 1)
  {
    hdlr->internalSubset = xmlSAX2InternalSubset;
    hdlr->externalSubsetSAXFunc externalSubset = 0;
    hdlr->isStandalone = xmlSAX2IsStandalone;
    hdlr->hasInternalSubset = xmlSAX2HasInternalSubset;
    hdlr->hasExternalSubset = xmlSAX2HasExternalSubset;
    hdlr->resolveEntity = xmlSAX2ResolveEntity;
    hdlr->getEntity = xmlSAX2GetEntity;
    hdlr->entityDecl = xmlSAX2EntityDecl;
    *(_OWORD *)&hdlr->notationDecl = 0u;
    *(_OWORD *)&hdlr->elementDecl = 0u;
    hdlr->setDocumentLocatorSAXFunc setDocumentLocator = xmlSAX2SetDocumentLocator;
    hdlr->startDocumentSAXFunc startDocument = xmlSAX2StartDocument;
    hdlr->endDocumentSAXFunc endDocument = xmlSAX2EndDocument;
    hdlr->startElementSAXFunc startElement = xmlSAX2StartElement;
    hdlr->endElement = xmlSAX2EndElement;
    hdlr->reference = xmlSAX2Reference;
    hdlr->characters = xmlSAX2Characters;
    hdlr->getParameterEntity = 0;
    hdlr->cdataBlocint k = 0;
    hdlr->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
    hdlr->processingInstruction = 0;
    hdlr->comment = xmlSAX2Comment;
    hdlr->warning = xmlParserWarning;
    hdlr->error = xmlParserError;
    hdlr->fatalError = xmlParserError;
    hdlr->initialized = 1;
  }
}

xmlDocPtr xmlParseMemory(const char *buffer, int size)
{
  return xmlSAXParseMemoryWithData(0, buffer, size, 0, 0);
}

uint64_t __htmlParserNeedsNoBlankQuirk_block_invoke()
{
  uint64_t result = (uint64_t)_dyld_get_image_name(0);
  if (result
    && (uint64_t result = (uint64_t)strrchr((char *)result, 47)) != 0
    && (uint64_t result = strcmp((const char *)(result + 1), "TaxCut.real"), !result))
  {
    uint64_t result = dyld_get_program_sdk_version();
    BOOL v1 = result >> 8 < 0xA09;
  }
  else
  {
    BOOL v1 = 0;
  }
  htmlParserNeedsNoBlankQuirk_needsQuirint k = v1;
  return result;
}

uint64_t xmlParse3986Authority(uint64_t a1, const xmlChar **a2)
{
  int v4 = *a2;
  int v5 = *a2;
  while (1)
  {
    int v6 = *v5;
    if ((v6 - 48) < 0xA || (v6 & 0xFFFFFFDF) - 65 < 0x1A) {
      goto LABEL_9;
    }
    uint64_t v8 = (v6 - 33);
    if (v8 > 0x3E) {
      goto LABEL_21;
    }
    if (((1 << (v6 - 33)) & 0x4000000016003FE9) != 0) {
      goto LABEL_9;
    }
    if (v8 != 4) {
      break;
    }
    if ((v5[1] - 48) >= 0xAu)
    {
      unsigned int v9 = v5[1] - 65;
      if (v9 > 0x25 || ((1 << v9) & 0x3F0000003FLL) == 0) {
        goto LABEL_32;
      }
    }
    if ((v5[2] - 48) >= 0xAu)
    {
      unsigned int v10 = v5[2] - 65;
      if (v10 > 0x25 || ((1 << v10) & 0x3F0000003FLL) == 0) {
        goto LABEL_32;
      }
    }
LABEL_9:
    if (v6 == 37) {
      v5 += 3;
    }
    else {
      ++v5;
    }
  }
  if (v8 != 31)
  {
LABEL_21:
    if (v6 != 126) {
      goto LABEL_32;
    }
    goto LABEL_9;
  }
  if (!a1) {
    goto LABEL_30;
  }
  unsigned int v11 = *(void **)(a1 + 32);
  if (v11) {
    xmlFree(v11);
  }
  int v12 = v5 - v4;
  int v13 = (*(unsigned char *)(a1 + 72) & 2) != 0
      ? xmlStrndup(v4, v12)
      : (xmlChar *)xmlURIUnescapeString((const char *)v4, v12, 0);
  *(void *)(a1 + 32) = v13;
  if (*v5 != 64) {
    int v4 = *a2;
  }
  else {
LABEL_30:
  }
    int v4 = v5 + 1;
LABEL_32:
  int v33 = (unsigned __int8 *)v4;
  unsigned int v14 = *v4;
  if (v14 == 91)
  {
    int v15 = (unsigned __int8 *)(v4 + 1);
    while (1)
    {
      int v17 = *v15++;
      int v16 = v17;
      if (!v17) {
        return 1;
      }
      if (v16 == 93)
      {
        int v33 = v15;
        goto LABEL_64;
      }
    }
  }
  if (v14 - 48 > 9
    || xmlParse3986DecOctet(&v33)
    || *v33 != 46
    || (++v33, xmlParse3986DecOctet(&v33))
    || *v33 != 46
    || xmlParse3986DecOctet(&v33)
    || *v33 != 46
    || xmlParse3986DecOctet(&v33))
  {
    for (uint64_t i = (unsigned __int8 *)v4; ; v14 = *i)
    {
      if (v14 - 48 < 0xA || (v14 & 0xDF) - 65 < 0x1A) {
        goto LABEL_50;
      }
      uint64_t v19 = v14 - 33;
      if (v19 > 0x3E) {
        goto LABEL_62;
      }
      if (((1 << (v14 - 33)) & 0x4000000014003FE9) != 0) {
        goto LABEL_50;
      }
      if (v19 == 4)
      {
        if ((i[1] - 48) >= 0xAu
          && ((unsigned int v20 = i[1] - 65, v20 > 0x25) || ((1 << v20) & 0x3F0000003FLL) == 0)
          || (i[2] - 48) >= 0xAu
          && ((unsigned int v21 = i[2] - 65, v21 > 0x25) || ((1 << v21) & 0x3F0000003FLL) == 0))
        {
LABEL_63:
          int v33 = i;
          break;
        }
      }
      else
      {
LABEL_62:
        if (v14 != 126) {
          goto LABEL_63;
        }
      }
LABEL_50:
      if (v14 == 37) {
        i += 3;
      }
      else {
        ++i;
      }
    }
  }
LABEL_64:
  if (a1)
  {
    long long v22 = *(void **)(a1 + 16);
    if (v22) {
      xmlFree(v22);
    }
    *(void *)(a1 + 16) = 0;
    int v23 = *(void **)(a1 + 24);
    if (v23) {
      xmlFree(v23);
    }
    uint64_t v24 = v33;
    if (v33 == v4)
    {
      *(void *)(a1 + 24) = 0;
      uint64_t v24 = (unsigned __int8 *)v4;
    }
    else
    {
      int v25 = v33 - v4;
      if ((*(unsigned char *)(a1 + 72) & 2) != 0) {
        int v26 = xmlStrndup(v4, v25);
      }
      else {
        int v26 = xmlURIUnescapeString((const char *)v4, v25, 0);
      }
      *(void *)(a1 + 24) = v26;
    }
  }
  else
  {
    uint64_t v24 = v33;
  }
  if (*v24 == 58)
  {
    int v28 = *++v24;
    int v27 = v28;
    if ((v28 - 48) <= 9)
    {
      int v29 = 0;
      while (v29 <= 214748364)
      {
        int v30 = 10 * v29;
        if (v30 > -2147483601 - v27) {
          break;
        }
        int v29 = v27 + v30 - 48;
        int v31 = *++v24;
        int v27 = v31;
        if ((v31 - 48) >= 0xA)
        {
          if (a1) {
            *(_DWORD *)(a1 + 40) = v29;
          }
          goto LABEL_84;
        }
      }
    }
    return 1;
  }
LABEL_84:
  uint64_t result = 0;
  *a2 = v24;
  return result;
}

uint64_t xmlParse3986PathAbEmpty(uint64_t a1, const xmlChar **a2)
{
  int v4 = *a2;
  unsigned int v11 = (unsigned __int8 *)*a2;
  uint64_t v5 = 1;
  while (1)
  {
    int v6 = v11;
    if (*v11 != 47) {
      break;
    }
    ++v11;
    if (xmlParse3986Segment(&v11, 0, 1)) {
      return v5;
    }
  }
  if (a1)
  {
    int v7 = *(void **)(a1 + 48);
    if (v7)
    {
      xmlFree(v7);
      int v4 = *a2;
    }
    if (v4 == v6)
    {
      unsigned int v9 = 0;
    }
    else
    {
      int v8 = v6 - v4;
      if ((*(unsigned char *)(a1 + 72) & 2) != 0) {
        unsigned int v9 = xmlStrndup(v4, v8);
      }
      else {
        unsigned int v9 = xmlURIUnescapeString((const char *)v4, v8, 0);
      }
    }
    *(void *)(a1 + 48) = v9;
  }
  uint64_t v5 = 0;
  *a2 = v6;
  return v5;
}

BOOL xmlParse3986Segment(unsigned __int8 **a1, unsigned __int8 a2, int a3)
{
  int v3 = *a1;
  int v4 = **a1;
  if ((v4 - 48) < 0xA || (v4 & 0xFFFFFFDF) - 65 < 0x1A) {
    goto LABEL_8;
  }
  uint64_t v6 = (v4 - 33);
  if (v6 > 0x3E) {
    goto LABEL_42;
  }
  if (((1 << (v4 - 33)) & 0x4000000096003FE9) != 0) {
    goto LABEL_8;
  }
  if (v6 != 4)
  {
LABEL_42:
    if (v4 == 126) {
      goto LABEL_8;
    }
    return a3 == 0;
  }
  if ((v3[1] - 48) >= 0xAu)
  {
    unsigned int v12 = v3[1] - 65;
    BOOL v13 = v12 > 0x25;
    uint64_t v14 = (1 << v12) & 0x3F0000003FLL;
    if (v13 || v14 == 0) {
      return a3 == 0;
    }
  }
  if ((v3[2] - 48) >= 0xAu)
  {
    unsigned int v16 = v3[2] - 65;
    BOOL v13 = v16 > 0x25;
    uint64_t v17 = (1 << v16) & 0x3F0000003FLL;
    if (v13 || v17 == 0) {
      return a3 == 0;
    }
  }
  while (1)
  {
LABEL_8:
    if ((v4 - 48) < 0xA || (v4 & 0xDFu) - 65 < 0x1A) {
      goto LABEL_12;
    }
    uint64_t v7 = (v4 - 33);
    if (v7 > 0x3E) {
      goto LABEL_26;
    }
    if (((1 << (v4 - 33)) & 0x4000000096003FE9) != 0) {
      goto LABEL_12;
    }
    if (v7 != 4)
    {
LABEL_26:
      if (v4 != 126) {
        break;
      }
LABEL_12:
      if (v4 == a2) {
        break;
      }
      goto LABEL_13;
    }
    if ((v3[1] - 48) >= 0xAu)
    {
      unsigned int v8 = v3[1] - 65;
      if (v8 > 0x25 || ((1 << v8) & 0x3F0000003FLL) == 0) {
        break;
      }
    }
    int v9 = v3[2];
    if ((v9 - 48) < 0xA || (v9 - 97) < 6) {
      goto LABEL_12;
    }
    if (a2 == 37 || (v9 - 71) < 0xFFFFFFFA) {
      break;
    }
LABEL_13:
    if (v4 == 37) {
      v3 += 3;
    }
    else {
      ++v3;
    }
    int v4 = *v3;
  }
  uint64_t v10 = 0;
  *a1 = v3;
  return v10;
}

char *__cdecl xmlURIUnescapeString(const char *str, int len, char *target)
{
  if (!str) {
    return 0;
  }
  unsigned int v4 = len;
  uint64_t v5 = str;
  if (len <= 0)
  {
    unsigned int v4 = strlen(str);
    if ((v4 & 0x80000000) != 0) {
      return 0;
    }
  }
  if (target || (target = (char *)xmlMallocAtomic(v4 + 1)) != 0)
  {
    uint64_t v6 = target;
    if (v4)
    {
      uint64_t v6 = target;
      do
      {
        int v7 = *(unsigned __int8 *)v5;
        if (v4 >= 3
          && v7 == 37
          && ((int v8 = v5[1], (v5[1] - 58) > 0xF5u) || ((v8 & 0xDF) - 71) >= 0xFAu)
          && ((int v9 = *((unsigned __int8 *)v5 + 2), (v9 - 58) <= 0xFFFFFFF5)
            ? (BOOL v10 = (v9 & 0xFFFFFFDF) - 71 >= 0xFFFFFFFA)
            : (BOOL v10 = 1),
              v10))
        {
          unsigned int v11 = v8 - 48;
          unsigned int v12 = v8 - 97;
          if ((v8 - 65) >= 6) {
            char v13 = 0;
          }
          else {
            char v13 = v8 - 55;
          }
          char v14 = v8 - 87;
          if (v12 > 5) {
            char v14 = v13;
          }
          if (v11 > 9) {
            LOBYTE(v11) = v14;
          }
          unsigned int v15 = v9 - 48;
          unsigned int v16 = v9 - 97;
          unsigned int v17 = v9 - 65;
          char v18 = v9 + 16 * v11;
          if (v17 <= 5) {
            LOBYTE(v11) = v18 - 55;
          }
          if (v16 <= 5) {
            LOBYTE(v11) = v18 - 87;
          }
          char v19 = v18 - 48;
          if (v15 <= 9) {
            LOBYTE(v11) = v19;
          }
          v5 += 3;
          *uint64_t v6 = v11;
          v4 -= 3;
        }
        else
        {
          ++v5;
          *uint64_t v6 = v7;
          --v4;
        }
        ++v6;
      }
      while (v4);
    }
    *uint64_t v6 = 0;
  }
  else
  {
    xmlURIErrMemory((const xmlChar *)"unescaping URI value\n");
  }
  return target;
}

xmlDocPtr xmlSAXParseMemoryWithData(xmlSAXHandlerPtr sax, const char *buffer, int size, int recovery, void *data)
{
  xmlInitParser();
  xmlParserCtxtPtr MemoryParserCtxt = xmlCreateMemoryParserCtxt(buffer, size);
  if (!MemoryParserCtxt) {
    return 0;
  }
  xmlParserCtxtPtr v11 = MemoryParserCtxt;
  if (sax)
  {
    unsigned int v12 = MemoryParserCtxt->sax;
    if (v11->sax) {
      xmlFree(v12);
    }
    v11->sax = sax;
  }
  xmlDetectSAX2((const xmlChar *)v11);
  if (data) {
    v11->_private = data;
  }
  v11->recovery = recovery;
  xmlParseDocument(v11);
  xmlDocPtr myDoc = v11->myDoc;
  if (!(v11->wellFormed | recovery))
  {
    xmlFreeDoc(v11->myDoc);
    xmlDocPtr myDoc = 0;
    v11->xmlDocPtr myDoc = 0;
    if (!sax) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  if (sax) {
LABEL_10:
  }
    v11->sax = 0;
LABEL_11:
  xmlFreeParserCtxt(v11);
  return myDoc;
}

uint64_t xmlBufMemoryError(uint64_t a1, uint64_t a2)
{
  uint64_t result = __xmlSimpleError(29, 2, 0, 0, a2);
  if (a1)
  {
    if (!*(_DWORD *)(a1 + 56)) {
      *(_DWORD *)(a1 + 56) = 2;
    }
  }
  return result;
}

void *xmlBufCreateStatic(void *result, unint64_t a2)
{
  if (result)
  {
    int v3 = result;
    uint64_t result = xmlMalloc(0x40uLL);
    if (result)
    {
      result[4] = a2;
      result[5] = a2;
      int v4 = 0x7FFFFFFF;
      if (a2 < 0x7FFFFFFF) {
        int v4 = a2;
      }
      *((_DWORD *)result + 2) = v4;
      *((_DWORD *)result + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = v4;
      *((_DWORD *)result + 4) = 2;
      void *result = v3;
      *((_DWORD *)result + 14) = 0;
      result[6] = 0;
    }
    else
    {
      __xmlSimpleError(29, 2, 0, 0, (uint64_t)"creating buffer");
      return 0;
    }
  }
  return result;
}

uint64_t xmlBufEmpty(uint64_t result)
{
  if (result)
  {
    if (!*(_DWORD *)(result + 56))
    {
      BOOL v1 = *(unsigned char **)result;
      if (*(void *)result)
      {
        unint64_t v2 = *(void *)(result + 40);
        unint64_t v3 = *(unsigned int *)(result + 12);
        if (v3 <= 0x7FFFFFFE && v2 != v3)
        {
          *(void *)(result + 40) = v3;
          unint64_t v2 = v3;
        }
        *(void *)(result + 32) = 0;
        int v5 = *(_DWORD *)(result + 16);
        if (v5 == 3)
        {
          int v7 = *(unsigned char **)(result + 24);
          if (v7)
          {
            *(void *)(result + 40) = v1 - v7 + v2;
            *(void *)uint64_t result = v7;
            BOOL v1 = v7;
          }
        }
        else if (v5 == 2)
        {
          LODWORD(v6) = 0;
          *(void *)uint64_t result = "";
          if (v2 >= 0x7FFFFFFF) {
            LODWORD(v2) = 0x7FFFFFFF;
          }
          *(_DWORD *)(result + 12) = v2;
LABEL_20:
          int v9 = v6;
LABEL_21:
          *(_DWORD *)(result + 8) = v9;
          return result;
        }
        *BOOL v1 = 0;
        unint64_t v6 = *(void *)(result + 32);
        unint64_t v8 = *(void *)(result + 40);
        int v9 = 0x7FFFFFFF;
        if (v8 >= 0x7FFFFFFF) {
          LODWORD(v8) = 0x7FFFFFFF;
        }
        *(_DWORD *)(result + 12) = v8;
        if (v6 > 0x7FFFFFFE) {
          goto LABEL_21;
        }
        goto LABEL_20;
      }
    }
  }
  return result;
}

uint64_t xmlBufLength(uint64_t a1)
{
  if (!a1 || *(_DWORD *)(a1 + 56)) {
    return 0;
  }
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  if (v3 <= 0x7FFFFFFE && *(void *)(a1 + 40) != v3) {
    *(void *)(a1 + 40) = v3;
  }
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  if (v5 <= 0x7FFFFFFE && v1 != v5)
  {
    *(void *)(a1 + 32) = v5;
    return v5;
  }
  return v1;
}

uint64_t xmlBufWriteQuotedString(uint64x2_t *a1, xmlChar *str)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (a1[3].i32[2]) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = str;
  uint64_t v4 = a1->u32[3];
  if (v4 <= 0x7FFFFFFE && a1[2].i64[1] != v4) {
    a1[2].i64[1] = v4;
  }
  uint64_t v6 = a1->u32[2];
  if (v6 <= 0x7FFFFFFE && a1[2].i64[0] != v6) {
    a1[2].i64[0] = v6;
  }
  if (a1[1].i32[0] == 2) {
    return 0xFFFFFFFFLL;
  }
  if (xmlStrchr(str, 0x22u))
  {
    if (xmlStrchr(v3, 0x27u))
    {
      xmlBufCat(a1, (const xmlChar *)"\"");
LABEL_19:
      for (size_t i = 0; v3[i]; ++i)
      {
        if (v3[i] == 34)
        {
          if (i) {
            xmlBufAdd(a1, v3, i);
          }
          xmlBufAdd(a1, (const xmlChar *)"&quot;", 6uLL);
          v3 += i + 1;
          goto LABEL_19;
        }
      }
      if (i) {
        xmlBufAdd(a1, v3, i);
      }
      BOOL v10 = "\"";
      goto LABEL_32;
    }
    BOOL v10 = "'";
  }
  else
  {
    BOOL v10 = "\"";
  }
  xmlBufCat(a1, (const xmlChar *)v10);
  xmlBufCat(a1, v3);
LABEL_32:
  xmlBufCat(a1, (const xmlChar *)v10);
  return 0;
}

uint32x2_t *xmlBufFromBuffer(uint32x2_t *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = (uint32x2_t *)xmlMalloc(0x40uLL);
    if (result)
    {
      uint32x2_t v2 = v1[1];
      result[1] = vmin_u32(v2, (uint32x2_t)0x8000000080000000);
      result[2].i32[0] = v1[2].i32[0];
      void *result = *v1;
      result[7].i32[0] = 0;
      result[5] = (uint32x2_t)v2.u32[1];
      result[6] = (uint32x2_t)v1;
      result[3] = v1[3];
      result[4] = (uint32x2_t)v2.u32[0];
    }
    else
    {
      __xmlSimpleError(29, 2, 0, 0, (uint64_t)"creating buffer");
      return 0;
    }
  }
  return result;
}

uint64_t xmlBufBackToBuffer(void *a1)
{
  if (!a1) {
    return 0;
  }
  unint64_t v2 = a1[5];
  unint64_t v3 = *((unsigned int *)a1 + 3);
  if (v3 <= 0x7FFFFFFE && v2 != v3)
  {
    a1[5] = v3;
    unint64_t v2 = v3;
  }
  unint64_t v5 = a1[4];
  unint64_t v6 = *((unsigned int *)a1 + 2);
  if (v6 <= 0x7FFFFFFE && v5 != v6)
  {
    a1[4] = v6;
    unint64_t v5 = v6;
  }
  uint64_t v8 = a1[6];
  if (*((_DWORD *)a1 + 14) || !v8)
  {
    xmlBufFree((uint64_t)a1);
    if (!v8) {
      return v8;
    }
    *(void *)(v8 + 24) = 0;
    *(void *)uint64_t v8 = 0;
    *(void *)(v8 + 8) = 0;
    return 0;
  }
  if (v5 >> 31)
  {
    __xmlSimpleError(29, 7000, 0, 0, (uint64_t)"Used size too big for xmlBuffer");
    if (!*((_DWORD *)a1 + 14)) {
      *((_DWORD *)a1 + 14) = 7000;
    }
    LODWORD(v2) = 0x7FFFFFFF;
    *(_DWORD *)(v8 + 8) = 0x7FFFFFFF;
  }
  else if (v2 >> 31)
  {
    __xmlSimpleError(29, 7000, 0, 0, (uint64_t)"Allocated size too big for xmlBuffer");
    if (!*((_DWORD *)a1 + 14)) {
      *((_DWORD *)a1 + 14) = 7000;
    }
    *(_DWORD *)(v8 + 8) = a1[4];
    LODWORD(v2) = 0x7FFFFFFF;
  }
  else
  {
    *(_DWORD *)(v8 + 8) = v5;
  }
  int v9 = *((_DWORD *)a1 + 4);
  *(_DWORD *)(v8 + 12) = v2;
  *(_DWORD *)(v8 + 16) = v9;
  *(void *)uint64_t v8 = *a1;
  *(void *)(v8 + 24) = a1[3];
  xmlFree(a1);
  return v8;
}

uint64_t xmlBufMergeBuffer(uint64x2_t *a1, xmlBufferPtr buf)
{
  if (a1 && !a1[3].i32[2])
  {
    uint64_t v5 = a1->u32[3];
    if (v5 <= 0x7FFFFFFE && a1[2].i64[1] != v5) {
      a1[2].i64[1] = v5;
    }
    uint64_t v7 = a1->u32[2];
    if (v7 <= 0x7FFFFFFE && a1[2].i64[0] != v7) {
      a1[2].i64[0] = v7;
    }
    if (buf && (content = buf->content) != 0 && (size_t use = buf->use, use)) {
      uint64_t v3 = xmlBufAdd(a1, content, use);
    }
    else {
      uint64_t v3 = 0;
    }
  }
  else
  {
    uint64_t v3 = 0xFFFFFFFFLL;
  }
  xmlBufferFree(buf);
  return v3;
}

int xmlC14NExecute(xmlDocPtr doc, xmlC14NIsVisibleCallback is_visible_callback, void *user_data, int mode, xmlChar **inclusive_ns_prefixes, int with_comments, xmlOutputBufferPtr buf)
{
  if (!doc || !buf)
  {
    BOOL v10 = "executing c14n";
LABEL_8:
    xmlC14NErrParam((const xmlChar *)v10);
    return -1;
  }
  if (mode > 2)
  {
    BOOL v10 = "invalid mode for executing c14n";
    goto LABEL_8;
  }
  if (buf->encoder)
  {
    __xmlRaiseError(0, 0, 0, 0, (uint64_t)doc, 0x15u, 1951, 2, 0, 0, 0, 0, 0, 0, 0, "%s", (char)"xmlC14NExecute: output buffer encoder != NULL but C14N requires UTF8 output\n");
    return -1;
  }
  unsigned int v15 = xmlMalloc(0x50uLL);
  if (!v15)
  {
    xmlC14NErrMemory((const xmlChar *)"creating context");
LABEL_19:
    __xmlRaiseError(0, 0, 0, 0, (uint64_t)doc, 0x15u, 1950, 2, 0, 0, 0, 0, 0, 0, 0, "%s", (char)"xmlC14NExecute: unable to create C14N context\n");
    return -1;
  }
  uint64_t v16 = (uint64_t)v15;
  *unsigned int v15 = 0u;
  v15[1] = 0u;
  v15[3] = 0u;
  v15[4] = 0u;
  v15[2] = 0u;
  *((_DWORD *)v15 + 6) = with_comments;
  *(void *)unsigned int v15 = doc;
  *((void *)v15 + 1) = is_visible_callback;
  *((void *)v15 + 2) = user_data;
  *((void *)v15 + 4) = buf;
  *((void *)v15 + 5) = 0x100000000;
  unsigned int v17 = xmlMalloc(0x20uLL);
  if (!v17)
  {
    xmlC14NErrMemory((const xmlChar *)"creating namespaces stack");
    *(void *)(v16 + 48) = 0;
    *(_DWORD *)(v16 + 72) = 1952;
    __xmlRaiseError(0, 0, 0, (void *)v16, (uint64_t)doc, 0x15u, 1952, 2, 0, 0, 0, 0, 0, 0, 0, "%s", (char)"xmlC14NNewCtx: xmlC14NVisibleNsStackCreate failed\n");
    xmlC14NFreeCtx(v16);
    goto LABEL_19;
  }
  *unsigned int v17 = 0u;
  v17[1] = 0u;
  *(void *)(v16 + 48) = v17;
  *(_DWORD *)(v16 + 56) = mode;
  if (mode == 1) {
    *(void *)(v16 + 64) = inclusive_ns_prefixes;
  }
  children = doc->children;
  if (children && (xmlC14NProcessNodeList((xmlDocPtr *)v16, (uint64_t)children, (__n128)0) & 0x80000000) != 0)
  {
    long long v22 = "processing docs children list";
    goto LABEL_24;
  }
  int v19 = xmlOutputBufferFlush(buf);
  if (v19 < 0)
  {
    long long v22 = "flushing output buffer";
LABEL_24:
    xmlC14NErrInternal((const xmlChar *)v22);
    xmlC14NFreeCtx(v16);
    return -1;
  }
  int v20 = v19;
  xmlC14NFreeCtx(v16);
  return v20;
}

_DWORD *xmlC14NErrParam(const xmlChar *a1)
{
  return __xmlRaiseError(0, 0, 0, 0, 0, 0x15u, 1, 2, 0, 0, a1, 0, 0, 0, 0, "Invalid parameter : %s\n", (char)a1);
}

uint64_t xmlC14NProcessNodeList(xmlDocPtr *a1, uint64_t a2, __n128 a3)
{
  if (!a2) {
    return 0;
  }
  uint64_t v3 = a2;
  uint64_t v5 = (const xmlChar *)"lang";
  while (2)
  {
    unint64_t v6 = (uint64_t (*)(void, void, void))a1[1];
    if (v6) {
      int v7 = v6(a1[2], v3, *(void *)(v3 + 40));
    }
    else {
      int v7 = 1;
    }
    uint64_t result = 0;
    switch(*(_DWORD *)(v3 + 8))
    {
      case 1:
        xmlParserCtxtPtr v11 = *(uint64_t ***)(v3 + 96);
        if (!v11) {
          goto LABEL_19;
        }
        do
        {
          if (xmlStrlen((const xmlChar *)v11[2]) < 1) {
            goto LABEL_18;
          }
          xmlURIPtr v12 = xmlParseURI((const char *)v11[2]);
          if (!v12)
          {
            xmlC14NErrInternal((const xmlChar *)"parsing namespace uri");
LABEL_252:
            BOOL v90 = "checking for relative namespaces";
            goto LABEL_253;
          }
          char v13 = v12;
          if (!xmlStrlen((const xmlChar *)v12->scheme))
          {
            __xmlRaiseError(0, 0, 0, 0, 0, 0x15u, 1955, 2, 0, 0, 0, 0, 0, 0, 0, "Relative namespace UR is invalid here : %s\n", (char)v13->scheme);
            xmlFreeURI(v13);
            goto LABEL_252;
          }
          xmlFreeURI(v13);
LABEL_18:
          xmlParserCtxtPtr v11 = (uint64_t **)*v11;
        }
        while (v11);
LABEL_19:
        xmlDocPtr v14 = a1[6];
        if (v14)
        {
          a3.n128_u64[0] = (unint64_t)v14->_private;
          __n128 v94 = a3;
          xmlElementType type = v14->type;
          if (v7) {
            goto LABEL_21;
          }
LABEL_48:
          int v96 = 0;
        }
        else
        {
          xmlC14NErrParam((const xmlChar *)"saving namespaces stack");
          xmlElementType type = 0;
          __n128 v94 = 0u;
          if (!v7) {
            goto LABEL_48;
          }
LABEL_21:
          int v96 = *((_DWORD *)a1 + 11);
          if (v96) {
            a1[5] = (xmlDocPtr)1;
          }
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], "<");
          uint64_t v16 = *(void *)(v3 + 72);
          if (v16 && xmlStrlen(*(const xmlChar **)(v16 + 24)) >= 1)
          {
            xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], *(const char **)(*(void *)(v3 + 72) + 24));
            xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], ":");
          }
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], *(const char **)(v3 + 16));
        }
        int v27 = *(_DWORD *)(v3 + 8);
        xmlElementType v95 = type;
        if (*((_DWORD *)a1 + 14) != 1)
        {
          if (v27 == 1)
          {
            xmlListPtr v39 = xmlListCreate(0, (xmlListDataCompare)xmlC14NNsCompare);
            if (v39)
            {
              int v29 = v39;
              int v40 = v5;
              int v41 = 0;
              uint64_t v42 = v3;
              do
              {
                for (size_t i = *(xmlNs **)(v42 + 96); i; size_t i = i->next)
                {
                  if (xmlSearchNs(*(xmlDocPtr *)(v3 + 64), (xmlNodePtr)v3, i->prefix) == i
                    && !xmlC14NIsXmlNs((uint64_t)i))
                  {
                    int v44 = (unsigned int (*)(xmlDocPtr, xmlNs *, uint64_t))a1[1];
                    if (!v44 || v44(a1[2], i, v3))
                    {
                      BOOL v45 = xmlC14NVisibleNsStackFind((uint64_t)a1[6], (uint64_t)i);
                      if (v7) {
                        xmlC14NVisibleNsStackAdd((int *)a1[6], (uint64_t)i, v3);
                      }
                      if (!v45) {
                        xmlListInsert(v29, i);
                      }
                      if (!xmlStrlen(i->prefix)) {
                        int v41 = 1;
                      }
                    }
                  }
                }
                uint64_t v42 = *(void *)(v42 + 40);
              }
              while (v42);
              uint64_t v5 = v40;
              if (!v7) {
                goto LABEL_137;
              }
              if (v41) {
                goto LABEL_137;
              }
              int v46 = &xmlC14NProcessNamespacesAxis_ns_default;
              xmmword_1E9D46A60 = 0u;
              unk_1E9D46A70 = 0u;
              xmlC14NProcessNamespacesAxis_ns_default = 0u;
              if (xmlC14NVisibleNsStackFind((uint64_t)a1[6], (uint64_t)&xmlC14NProcessNamespacesAxis_ns_default)) {
                goto LABEL_137;
              }
LABEL_130:
              BOOL v55 = v46;
LABEL_131:
              xmlC14NPrintNamespaces((uint64_t)v55, (uint64_t)a1);
              goto LABEL_137;
            }
            int v93 = "creating namespaces list (c14n)";
            goto LABEL_272;
          }
          int v92 = "processing namespaces axis (c14n)";
LABEL_269:
          xmlC14NErrParam((const xmlChar *)v92);
LABEL_273:
          BOOL v90 = "processing namespaces axis";
          break;
        }
        if (v27 != 1)
        {
          int v92 = "processing namespaces axis (exc c14n)";
          goto LABEL_269;
        }
        xmlListPtr v28 = xmlListCreate(0, (xmlListDataCompare)xmlC14NNsCompare);
        if (!v28)
        {
          int v93 = "creating namespaces list (exc c14n)";
LABEL_272:
          xmlC14NErrInternal((const xmlChar *)v93);
          goto LABEL_273;
        }
        int v29 = v28;
        int v30 = (const xmlChar **)a1[8];
        if (v30 && (int v31 = *v30) != 0)
        {
          int v32 = 0;
          int v33 = 0;
          uint64_t v34 = 8;
          do
          {
            if (xmlStrEqual(v31, (const xmlChar *)"#default") || xmlStrEqual(v31, (const xmlChar *)""))
            {
              int v31 = 0;
              int v32 = 1;
            }
            xmlNsPtr v35 = xmlSearchNs(*(xmlDocPtr *)(v3 + 64), (xmlNodePtr)v3, v31);
            if (v35)
            {
              uint64_t v36 = (const xmlChar **)v35;
              if (!xmlC14NIsXmlNs((uint64_t)v35))
              {
                uint64_t v37 = (unsigned int (*)(xmlDocPtr, const xmlChar **, uint64_t))a1[1];
                if (!v37 || v37(a1[2], v36, v3))
                {
                  BOOL v38 = xmlC14NVisibleNsStackFind((uint64_t)a1[6], (uint64_t)v36);
                  if (v7) {
                    xmlC14NVisibleNsStackAdd((int *)a1[6], (uint64_t)v36, v3);
                  }
                  if (!v38) {
                    xmlListInsert(v29, v36);
                  }
                  if (!xmlStrlen(v36[3])) {
                    int v33 = 1;
                  }
                }
              }
            }
            int v31 = *(const xmlChar **)((char *)&a1[8]->_private + v34);
            v34 += 8;
          }
          while (v31);
        }
        else
        {
          int v33 = 0;
          int v32 = 0;
        }
        xmlNsPtr v47 = *(xmlNsPtr *)(v3 + 72);
        if (v47)
        {
          int v48 = 0;
LABEL_101:
          if (!xmlC14NIsXmlNs((uint64_t)v47))
          {
            if (v7)
            {
              uint64_t v49 = (unsigned int (*)(xmlDocPtr, xmlNsPtr, uint64_t))a1[1];
              if ((!v49 || v49(a1[2], v47, v3))
                && !xmlExcC14NVisibleNsStackFind((unsigned int *)a1[6], (uint64_t)v47, (uint64_t)a1))
              {
                xmlListInsert(v29, v47);
              }
              xmlC14NVisibleNsStackAdd((int *)a1[6], (uint64_t)v47, v3);
            }
            if (!xmlStrlen(v47->prefix)) {
              int v33 = 1;
            }
          }
        }
        else
        {
          xmlNsPtr v47 = xmlSearchNs(*(xmlDocPtr *)(v3 + 64), (xmlNodePtr)v3, 0);
          int v48 = 1;
          if (v47) {
            goto LABEL_101;
          }
        }
        for (uint64_t j = *(void *)(v3 + 88); j; uint64_t j = *(void *)(j + 48))
        {
          uint64_t v51 = *(void *)(j + 72);
          if (v51)
          {
            if (xmlC14NIsXmlNs(v51)
              || (xmlGenericErrorFunc v53 = (unsigned int (*)(xmlDocPtr, uint64_t, uint64_t))a1[1]) != 0 && !v53(a1[2], j, v3))
            {
              uint64_t v52 = *(void *)(j + 72);
              if (v52
                && !xmlStrlen(*(const xmlChar **)(v52 + 24))
                && !xmlStrlen(*(const xmlChar **)(*(void *)(j + 72) + 16)))
              {
                int v48 = 1;
              }
            }
            else
            {
              int v54 = xmlExcC14NVisibleNsStackFind((unsigned int *)a1[6], *(void *)(j + 72), (uint64_t)a1);
              xmlC14NVisibleNsStackAdd((int *)a1[6], *(void *)(j + 72), v3);
              if (v7 && !v54) {
                xmlListInsert(v29, *(void **)(j + 72));
              }
              if (!xmlStrlen(*(const xmlChar **)(*(void *)(j + 72) + 24))) {
                int v33 = 1;
              }
            }
          }
        }
        if (!v7 || !v48 || v33 || v32)
        {
          if (!v7
            || v33
            || !v32
            || (xmmword_1E9D46AC0 = 0u,
                unk_1E9D46AD0 = 0u,
                xmlExcC14NProcessNamespacesAxis_ns_default_66 = 0u,
                xmlC14NVisibleNsStackFind((uint64_t)a1[6], (uint64_t)&xmlExcC14NProcessNamespacesAxis_ns_default_66)))
          {
            uint64_t v5 = (const xmlChar *)"lang";
            goto LABEL_137;
          }
          BOOL v55 = &xmlExcC14NProcessNamespacesAxis_ns_default_66;
          uint64_t v5 = (const xmlChar *)"lang";
          goto LABEL_131;
        }
        int v46 = &xmlExcC14NProcessNamespacesAxis_ns_default;
        xmmword_1E9D46A90 = 0u;
        unk_1E9D46AA0 = 0u;
        xmlExcC14NProcessNamespacesAxis_ns_default = 0u;
        uint64_t v5 = (const xmlChar *)"lang";
        if (!xmlExcC14NVisibleNsStackFind((unsigned int *)a1[6], (uint64_t)&xmlExcC14NProcessNamespacesAxis_ns_default, (uint64_t)a1))goto LABEL_130; {
LABEL_137:
        }
        xmlListWalk(v29, (xmlListWalker)xmlC14NPrintNamespacesWalker, a1);
        xmlListDelete(v29);
        if (v7)
        {
          uint64_t v56 = (int *)a1[6];
          if (v56)
          {
            int v57 = *v56;
            v56[1] = v56[2];
            v56[2] = v57;
          }
          else
          {
            xmlC14NErrParam((const xmlChar *)"shifting namespaces stack");
          }
        }
        if (*(_DWORD *)(v3 + 8) != 1)
        {
          xmlC14NErrParam((const xmlChar *)"processing attributes axis");
LABEL_265:
          BOOL v90 = "processing attributes axis";
          break;
        }
        xmlListPtr v58 = xmlListCreate(0, (xmlListDataCompare)xmlC14NAttrsCompare);
        if (!v58)
        {
          xmlC14NErrInternal((const xmlChar *)"creating attributes list");
          goto LABEL_265;
        }
        uint64_t v59 = v58;
        int v60 = *((_DWORD *)a1 + 14);
        if (v60 != 2)
        {
          if (v60 == 1)
          {
            for (int k = *(void **)(v3 + 88); k; int k = (void *)k[6])
            {
              int v76 = (unsigned int (*)(void, void, void))a1[1];
              if (!v76 || v76(a1[2], k, v3)) {
                xmlListInsert(v59, k);
              }
            }
            goto LABEL_228;
          }
          if (v60)
          {
LABEL_228:
            xmlAttrPtr v68 = 0;
            goto LABEL_229;
          }
          for (m = *(void **)(v3 + 88); m; m = (void *)m[6])
          {
            uint64_t v62 = (unsigned int (*)(void, void, void))a1[1];
            if (!v62 || v62(a1[2], m, v3)) {
              xmlListInsert(v59, m);
            }
          }
          if (v7)
          {
            uint64_t v63 = *(void *)(v3 + 40);
            if (v63)
            {
              unsigned int v64 = (unsigned int (*)(void, void, void))a1[1];
              if (v64)
              {
                if (!v64(a1[2], v63, *(void *)(v63 + 40)))
                {
                  uint64_t v65 = *(void *)(v3 + 40);
                  if (v65)
                  {
                    do
                    {
                      for (n = *(void **)(v65 + 88); n; n = (void *)n[6])
                      {
                        uint64_t v67 = n[9];
                        if (v67 && xmlC14NIsXmlNs(v67) && !xmlListSearch(v59, n)) {
                          xmlListInsert(v59, n);
                        }
                      }
                      xmlAttrPtr v68 = 0;
                      uint64_t v65 = *(void *)(v65 + 40);
                    }
                    while (v65);
                    goto LABEL_229;
                  }
                }
              }
            }
            goto LABEL_228;
          }
          goto LABEL_224;
        }
        uint64_t v69 = *(void *)(v3 + 88);
        if (!v69)
        {
          if (v7)
          {
            xmlAttrPtr v68 = 0;
            xmlAttrPtr v70 = 0;
            goto LABEL_201;
          }
LABEL_224:
          xmlListWalk(v59, (xmlListWalker)xmlC14NPrintAttrs, a1);
          xmlFreePropList(0);
          xmlListDelete(v59);
          goto LABEL_231;
        }
        xmlAttrPtr v70 = 0;
        xmlAttrPtr v71 = 0;
        xmlAttrPtr v68 = 0;
        while (2)
        {
          if (!v7) {
            goto LABEL_186;
          }
          uint64_t v72 = *(void *)(v69 + 72);
          if (!v72 || !xmlC14NIsXmlNs(v72)) {
            goto LABEL_186;
          }
          if (!v71 && xmlStrEqual(*(const xmlChar **)(v69 + 16), v5))
          {
            xmlAttrPtr v71 = (xmlAttrPtr)v69;
            goto LABEL_189;
          }
          if (v70)
          {
            if (!v68) {
              goto LABEL_180;
            }
LABEL_186:
            int v74 = (unsigned int (*)(xmlDocPtr, uint64_t, uint64_t))a1[1];
            if (!v74 || v74(a1[2], v69, v3)) {
              xmlListInsert(v59, (void *)v69);
            }
          }
          else
          {
            int v73 = xmlStrEqual(*(const xmlChar **)(v69 + 16), (const xmlChar *)"space");
            if (v73) {
              xmlAttrPtr v70 = (xmlAttrPtr)v69;
            }
            else {
              xmlAttrPtr v70 = 0;
            }
            if (v73 || v68)
            {
              if (!v73)
              {
                xmlAttrPtr v70 = 0;
                goto LABEL_186;
              }
              xmlAttrPtr v70 = (xmlAttrPtr)v69;
            }
            else
            {
LABEL_180:
              if (!xmlStrEqual(*(const xmlChar **)(v69 + 16), (const xmlChar *)"base"))
              {
                xmlAttrPtr v68 = 0;
                goto LABEL_186;
              }
              xmlAttrPtr v68 = (xmlAttrPtr)v69;
            }
          }
LABEL_189:
          uint64_t v69 = *(void *)(v69 + 48);
          if (v69) {
            continue;
          }
          break;
        }
        if (!v7) {
          goto LABEL_224;
        }
        if (v71) {
          goto LABEL_202;
        }
LABEL_201:
        xmlAttrPtr v71 = xmlC14NFindHiddenParentAttr((uint64_t)a1, *(const xmlNode **)(v3 + 40), v5);
        if (v71) {
LABEL_202:
        }
          xmlListInsert(v59, v71);
        if (v70
          || (xmlAttrPtr v70 = xmlC14NFindHiddenParentAttr((uint64_t)a1, *(const xmlNode **)(v3 + 40), (const xmlChar *)"space")) != 0)
        {
          xmlListInsert(v59, v70);
        }
        if (v68
          || (xmlAttrPtr v68 = xmlC14NFindHiddenParentAttr((uint64_t)a1, *(const xmlNode **)(v3 + 40), (const xmlChar *)"base")) != 0)
        {
          if (v68->parent)
          {
            String = xmlNodeListGetString(*a1, v68->children, 1);
            if (String)
            {
              unint64_t v78 = String;
              for (isize_t i = v68->parent->parent; ii; isize_t i = ii->parent)
              {
                int v80 = (unsigned int (*)(xmlDocPtr, const xmlNode *, _xmlNode *))a1[1];
                if (!v80 || v80(a1[2], ii, ii->parent)) {
                  break;
                }
                xmlAttrPtr v81 = xmlHasNsProp(ii, (const xmlChar *)"base", (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
                if (v81)
                {
                  unint64_t v82 = xmlNodeListGetString(*a1, v81->children, 1);
                  if (!v82)
                  {
                    xmlFree(v78);
                    uint64_t v89 = "processing xml:base attribute - can't get attr value";
                    goto LABEL_247;
                  }
                  int v83 = v82;
                  int v84 = xmlStrlen(v82);
                  if (v84 >= 2 && v83[v84 - 2] == 46)
                  {
                    int v85 = xmlStrcat(v83, (const xmlChar *)"/");
                    if (!v85)
                    {
                      xmlFree(v83);
                      xmlFree(v78);
                      uint64_t v89 = "processing xml:base attribute - can't modify uri";
LABEL_247:
                      xmlC14NErrInternal((const xmlChar *)v89);
                      goto LABEL_248;
                    }
                  }
                  else
                  {
                    int v85 = v83;
                  }
                  uint64_t v86 = xmlBuildURI(v78, v85);
                  xmlFree(v85);
                  xmlFree(v78);
                  unint64_t v78 = v86;
                  if (!v86)
                  {
                    uint64_t v89 = "processing xml:base attribute - can't construct uri";
                    goto LABEL_247;
                  }
                }
              }
              if (xmlStrEqual(v78, (const xmlChar *)""))
              {
                xmlFree(v78);
LABEL_248:
                xmlAttrPtr v68 = 0;
                uint64_t v5 = (const xmlChar *)"lang";
              }
              else
              {
                xmlAttrPtr v68 = xmlNewNsProp(0, v68->ns, (const xmlChar *)"base", v78);
                xmlFree(v78);
                uint64_t v5 = (const xmlChar *)"lang";
                if (v68)
                {
                  xmlListInsert(v59, v68);
                  v68->xmlNodePtr next = 0;
                }
                else
                {
                  xmlC14NErrInternal((const xmlChar *)"processing xml:base attribute - can't construct attribute");
                }
              }
              goto LABEL_229;
            }
            xmlC14NErrInternal((const xmlChar *)"processing xml:base attribute - can't get attr value");
          }
          else
          {
            xmlC14NErrParam((const xmlChar *)"processing xml:base attribute");
          }
          goto LABEL_228;
        }
LABEL_229:
        xmlListWalk(v59, (xmlListWalker)xmlC14NPrintAttrs, a1);
        xmlFreePropList(v68);
        xmlListDelete(v59);
        if (v7) {
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], ">");
        }
LABEL_231:
        if (*(void *)(v3 + 24) && (xmlC14NProcessNodeList(a1) & 0x80000000) != 0)
        {
          BOOL v90 = "processing childrens list";
          break;
        }
        if (v7)
        {
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], "</");
          uint64_t v87 = *(void *)(v3 + 72);
          if (v87 && xmlStrlen(*(const xmlChar **)(v87 + 24)) >= 1)
          {
            xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], *(const char **)(*(void *)(v3 + 72) + 24));
            xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], ":");
          }
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], *(const char **)(v3 + 16));
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], ">");
          if (v96)
          {
            *((_DWORD *)a1 + 10) = 2;
            *((_DWORD *)a1 + 11) = v96;
          }
        }
        xmlDocPtr v88 = a1[6];
        if (v88)
        {
          uint64_t result = 0;
          a3.n128_u64[1] = v94.n128_u64[1];
          v88->_private = (void *)v94.n128_u64[0];
          v88->xmlElementType type = v95;
        }
        else
        {
          xmlC14NErrParam((const xmlChar *)"restoring namespaces stack");
          uint64_t result = 0;
        }
LABEL_97:
        uint64_t v3 = *(void *)(v3 + 48);
        if (v3 && (result & 0x80000000) == 0) {
          continue;
        }
        return result;
      case 2:
        char v91 = "XML_ATTRIBUTE_NODE";
        goto LABEL_259;
      case 3:
      case 4:
        if (!v7) {
          goto LABEL_96;
        }
        uint64_t result = *(void *)(v3 + 80);
        if (!result) {
          goto LABEL_97;
        }
        int v9 = xmlC11NNormalizeString((unsigned char *)result, 3u);
        if (!v9)
        {
          BOOL v90 = "normalizing text node";
          goto LABEL_253;
        }
        BOOL v10 = v9;
        xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], v9);
        xmlFree(v10);
        goto LABEL_96;
      case 5:
        char v91 = "XML_ENTITY_REF_NODE";
        goto LABEL_259;
      case 6:
        char v91 = "XML_ENTITY_NODE";
        goto LABEL_259;
      case 7:
        if (!v7) {
          goto LABEL_96;
        }
        if (*((_DWORD *)a1 + 10) == 2) {
          unsigned int v17 = "\n<?";
        }
        else {
          unsigned int v17 = "<?";
        }
        xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], v17);
        xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], *(const char **)(v3 + 16));
        char v18 = *(unsigned char **)(v3 + 80);
        if (!v18 || !*v18) {
          goto LABEL_35;
        }
        xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], " ");
        int v19 = xmlC11NNormalizeString(*(unsigned char **)(v3 + 80), 2u);
        if (v19)
        {
          int v20 = v19;
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], v19);
          xmlFree(v20);
LABEL_35:
          unsigned int v21 = (xmlOutputBuffer *)a1[4];
          if (*((_DWORD *)a1 + 10)) {
            long long v22 = "?>";
          }
          else {
            long long v22 = "?>\n";
          }
LABEL_95:
          xmlOutputBufferWriteString(v21, v22);
LABEL_96:
          uint64_t result = 0;
          goto LABEL_97;
        }
        BOOL v90 = "normalizing pi node";
        break;
      case 8:
        if (!v7 || !*((_DWORD *)a1 + 6)) {
          goto LABEL_96;
        }
        if (*((_DWORD *)a1 + 10) == 2) {
          int v23 = "\n<!--";
        }
        else {
          int v23 = "<!--";
        }
        xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], v23);
        uint64_t v24 = *(unsigned char **)(v3 + 80);
        if (!v24) {
          goto LABEL_45;
        }
        int v25 = xmlC11NNormalizeString(v24, 1u);
        if (v25)
        {
          int v26 = v25;
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], v25);
          xmlFree(v26);
LABEL_45:
          unsigned int v21 = (xmlOutputBuffer *)a1[4];
          if (*((_DWORD *)a1 + 10)) {
            long long v22 = "-->";
          }
          else {
            long long v22 = "-->\n";
          }
          goto LABEL_95;
        }
        BOOL v90 = "normalizing comment node";
        break;
      case 9:
      case 0xB:
      case 0xD:
      case 0x15:
        if (!*(void *)(v3 + 24)) {
          goto LABEL_96;
        }
        a1[5] = (xmlDocPtr)0x100000000;
        uint64_t result = xmlC14NProcessNodeList(a1);
        goto LABEL_97;
      case 0xA:
      case 0xC:
      case 0xE:
      case 0xF:
      case 0x10:
      case 0x11:
      case 0x13:
      case 0x14:
        goto LABEL_97;
      case 0x12:
        char v91 = "XML_NAMESPACE_DECL";
LABEL_259:
        xmlC14NErrInvalidNode((char)v91);
        return 0xFFFFFFFFLL;
      default:
        __xmlRaiseError(0, 0, 0, 0, 0, 0x15u, 1954, 2, 0, 0, (const xmlChar *)"processing node", 0, 0, 0, 0, "Unknown node type %d found : %s\n", *(_DWORD *)(v3 + 8));
        return 0xFFFFFFFFLL;
    }
    break;
  }
LABEL_253:
  xmlC14NErrInternal((const xmlChar *)v90);
  return 0xFFFFFFFFLL;
}

_DWORD *xmlC14NErrInternal(const xmlChar *a1)
{
  return __xmlRaiseError(0, 0, 0, 0, 0, 0x15u, 1, 2, 0, 0, a1, 0, 0, 0, 0, "Internal error : %s\n", (char)a1);
}

uint64_t xmlC14NFreeCtx(uint64_t a1)
{
  unint64_t v2 = *(int **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = (void *)*((void *)v2 + 2);
    if (v3)
    {
      bzero(v3, 8 * v2[3]);
      xmlFree(*((void **)v2 + 2));
    }
    uint64_t v4 = (void *)*((void *)v2 + 3);
    if (v4)
    {
      bzero(v4, 8 * v2[3]);
      xmlFree(*((void **)v2 + 3));
    }
    *(_OWORD *)unint64_t v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    xmlFree(v2);
  }
  xmlFreeFunc v5 = xmlFree;

  return ((uint64_t (*)(uint64_t))v5)(a1);
}

int xmlC14NDocSaveTo(xmlDocPtr doc, xmlNodeSetPtr nodes, int mode, xmlChar **inclusive_ns_prefixes, int with_comments, xmlOutputBufferPtr buf)
{
  return xmlC14NExecute(doc, (xmlC14NIsVisibleCallback)xmlC14NIsNodeInNodeset, nodes, mode, inclusive_ns_prefixes, with_comments, buf);
}

uint64_t xmlC14NIsNodeInNodeset(xmlNodeSet *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 1;
  if (!a1 || !a2) {
    return v3;
  }
  if (*(_DWORD *)(a2 + 8) == 18)
  {
    long long v4 = *(_OWORD *)(a2 + 16);
    v6[0] = *(_OWORD *)a2;
    v6[1] = v4;
    uint64_t v6[2] = *(_OWORD *)(a2 + 32);
    if (a3)
    {
      if (*(_DWORD *)(a3 + 8) == 2) {
        a3 = *(void *)(a3 + 40);
      }
    }
    *(void *)&v6[0] = a3;
    return xmlXPathNodeSetContains(a1, (xmlNodePtr)v6);
  }

  return xmlXPathNodeSetContains(a1, (xmlNodePtr)a2);
}

int xmlC14NDocDumpMemory(xmlDocPtr doc, xmlNodeSetPtr nodes, int mode, xmlChar **inclusive_ns_prefixes, int with_comments, xmlChar **doc_txt_ptr)
{
  if (!doc_txt_ptr)
  {
    xmlC14NErrParam((const xmlChar *)"dumping doc to memory");
    return -1;
  }
  *doc_txt_ptr = 0;
  xmlURIPtr v12 = xmlAllocOutputBuffer(0);
  if (!v12)
  {
    uint64_t v16 = "creating output buffer";
    goto LABEL_11;
  }
  char v13 = v12;
  if (xmlC14NExecute(doc, (xmlC14NIsVisibleCallback)xmlC14NIsNodeInNodeset, nodes, mode, inclusive_ns_prefixes, with_comments, v12) < 0)
  {
    xmlC14NErrInternal((const xmlChar *)"saving doc to output buffer");
    xmlOutputBufferClose(v13);
    return -1;
  }
  int v14 = xmlBufUse(v13->buffer);
  if ((v14 & 0x80000000) == 0)
  {
    unsigned int v15 = xmlBufContent(v13->buffer);
    *doc_txt_ptr = xmlStrndup(v15, v14);
  }
  xmlOutputBufferClose(v13);
  if ((v14 & 0x80000000) == 0 && !*doc_txt_ptr)
  {
    uint64_t v16 = "copying canonicalized document";
LABEL_11:
    xmlC14NErrMemory((const xmlChar *)v16);
    return -1;
  }
  return v14;
}

_DWORD *xmlC14NErrMemory(const xmlChar *a1)
{
  return __xmlRaiseError(0, 0, 0, 0, 0, 0x15u, 2, 2, 0, 0, a1, 0, 0, 0, 0, "Memory allocation failed : %s\n", (char)a1);
}

int xmlC14NDocSave(xmlDocPtr doc, xmlNodeSetPtr nodes, int mode, xmlChar **inclusive_ns_prefixes, int with_comments, const char *filename, int compression)
{
  if (!filename)
  {
    xmlC14NErrParam((const xmlChar *)"saving doc");
    return -1;
  }
  if (compression < 0) {
    compression = xmlGetCompressMode();
  }
  char v13 = xmlOutputBufferCreateFilename(filename, 0, compression);
  if (!v13)
  {
    xmlC14NErrInternal((const xmlChar *)"creating temporary filename");
    return -1;
  }
  int v14 = v13;
  if (xmlC14NExecute(doc, (xmlC14NIsVisibleCallback)xmlC14NIsNodeInNodeset, nodes, mode, inclusive_ns_prefixes, with_comments, v13) < 0)
  {
    xmlC14NErrInternal((const xmlChar *)"canonize document to buffer");
    xmlOutputBufferClose(v14);
    return -1;
  }

  return xmlOutputBufferClose(v14);
}

char *xmlC11NNormalizeString(unsigned char *a1, unsigned int a2)
{
  if (!a1) {
    return 0;
  }
  long long v4 = (char *)xmlMallocAtomic(0x3E8uLL);
  if (!v4)
  {
    int v14 = "allocating buffer";
    goto LABEL_41;
  }
  int v5 = *a1;
  if (!*a1)
  {
    uint64_t v8 = v4;
LABEL_39:
    char *v4 = 0;
    return v8;
  }
  unint64_t v6 = a1 + 1;
  int v7 = 1000;
  uint64_t v8 = v4;
  while (1)
  {
    int v9 = v4 - v8;
    if (v4 - v8 <= v7 - 10) {
      goto LABEL_8;
    }
    v7 *= 2;
    BOOL v10 = (char *)xmlRealloc(v8, v7);
    if (!v10) {
      break;
    }
    uint64_t v8 = v10;
    long long v4 = &v10[v9];
    int v5 = *(v6 - 1);
LABEL_8:
    if (v5 == 60)
    {
      if (a2 != 3 && a2) {
        goto LABEL_33;
      }
      int v11 = 997485606;
      goto LABEL_15;
    }
    if (a2 == 3 && v5 == 62)
    {
      int v11 = 997484326;
LABEL_15:
      *(_DWORD *)long long v4 = v11;
      v4 += 4;
      goto LABEL_34;
    }
    if (v5 == 38)
    {
      if (a2 != 3 && a2) {
        goto LABEL_33;
      }
      int v12 = 1886216486;
LABEL_32:
      *(_DWORD *)long long v4 = v12;
      v4[4] = 59;
      v4 += 5;
      goto LABEL_34;
    }
    if (a2 || v5 != 34)
    {
      if (a2 || v5 != 9)
      {
        if (a2 || v5 != 10)
        {
          if (a2 > 3 || v5 != 13)
          {
LABEL_33:
            *v4++ = v5;
            goto LABEL_34;
          }
          int v12 = 1148724006;
        }
        else
        {
          int v12 = 1098392358;
        }
      }
      else
      {
        int v12 = 964174630;
      }
      goto LABEL_32;
    }
    *(_DWORD *)long long v4 = 1869967654;
    *((_WORD *)v4 + 2) = 15220;
    v4 += 6;
LABEL_34:
    int v13 = *v6++;
    int v5 = v13;
    if (!v13) {
      goto LABEL_39;
    }
  }
  int v14 = "growing buffer";
LABEL_41:
  xmlC14NErrMemory((const xmlChar *)v14);
  return 0;
}

_DWORD *xmlC14NErrInvalidNode(char a1)
{
  return __xmlRaiseError(0, 0, 0, 0, 0, 0x15u, 1953, 2, 0, 0, (const xmlChar *)"processing node", 0, 0, 0, 0, "Node %s is invalid here : %s\n", a1);
}

uint64_t xmlC14NNsCompare(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 0;
  }
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (a2) {
    return xmlStrcmp(*(const xmlChar **)(a1 + 24), *(const xmlChar **)(a2 + 24));
  }
  return 1;
}

uint64_t xmlC14NIsXmlNs(uint64_t a1)
{
  uint64_t result = xmlStrEqual(*(const xmlChar **)(a1 + 24), (const xmlChar *)"xml");
  if (result) {
    return xmlStrEqual(*(const xmlChar **)(a1 + 16), (const xmlChar *)"http://www.w3.org/XML/1998/namespace") != 0;
  }
  return result;
}

BOOL xmlC14NVisibleNsStackFind(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    xmlC14NErrParam((const xmlChar *)"searching namespaces stack (c14n)");
    return 0;
  }
  uint64_t v2 = a1;
  uint64_t v3 = "";
  if (a2)
  {
    if (*(void *)(a2 + 24)) {
      long long v4 = *(const char **)(a2 + 24);
    }
    else {
      long long v4 = "";
    }
    if (*(void *)(a2 + 16)) {
      int v5 = *(const char **)(a2 + 16);
    }
    else {
      int v5 = "";
    }
    uint64_t v3 = v4;
  }
  else
  {
    int v5 = "";
  }
  if (*v3)
  {
    uint64_t v6 = *(void *)(a1 + 16);
    if (!v6) {
      return 0;
    }
  }
  else
  {
    int v8 = *(unsigned __int8 *)v5;
    BOOL result = *v5 == 0;
    uint64_t v6 = *(void *)(v2 + 16);
    if (!v6) {
      return result;
    }
    if (!*v5)
    {
      BOOL result = 1;
      goto LABEL_18;
    }
  }
  BOOL result = 0;
  int v8 = *(_DWORD *)(v2 + 4);
LABEL_18:
  LODWORD(v2) = *(_DWORD *)v2;
  while (2)
  {
    if ((int)v2 > v8)
    {
      uint64_t v2 = (int)v2;
      while (1)
      {
        --v2;
        uint64_t v9 = *(void *)(v6 + 8 * v2);
        if (!v9) {
          break;
        }
        BOOL v10 = *(const char **)(v9 + 24);
        if (v3 == v10) {
          goto LABEL_32;
        }
        if (!v10) {
          break;
        }
        int v11 = v3;
        while (1)
        {
          int v12 = *(unsigned __int8 *)v11;
          if (v12 != *(unsigned __int8 *)v10) {
            break;
          }
          ++v11;
          ++v10;
          if (!v12) {
            goto LABEL_32;
          }
        }
        if (v2 <= v8) {
          return result;
        }
      }
      if (*v3) {
        continue;
      }
      if (v9)
      {
LABEL_32:
        int v13 = *(const char **)(v9 + 16);
        if (v5 == v13) {
          return 1;
        }
        if (v13)
        {
          while (1)
          {
            int v14 = *(unsigned __int8 *)v5;
            if (v14 != *(unsigned __int8 *)v13) {
              break;
            }
            ++v5;
            ++v13;
            if (!v14) {
              return 1;
            }
          }
          return 0;
        }
      }
      return *v5 == 0;
    }
    return result;
  }
}

_DWORD *xmlC14NVisibleNsStackAdd(int *a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    BOOL result = (_DWORD *)*((void *)a1 + 2);
    uint64_t v7 = *((void *)a1 + 3);
    if (result)
    {
      if (v7)
      {
        uint64_t v8 = a1[3];
        if (v8 != *a1)
        {
LABEL_16:
          uint64_t v13 = *a1;
          *(void *)(*((void *)a1 + 2) + 8 * v1xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = a2;
          *(void *)(*((void *)a1 + 3) + 8 * v1xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = a3;
          *a1 = v13 + 1;
          return result;
        }
        uint64_t v9 = xmlRealloc(result, 16 * v8);
        if (v9)
        {
          *((void *)a1 + 2) = v9;
          BOOL result = xmlRealloc(*((void **)a1 + 3), 16 * v8);
          if (result)
          {
            int v10 = 2 * v8;
            *((void *)a1 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = result;
LABEL_15:
            a1[3] = v10;
            goto LABEL_16;
          }
        }
LABEL_17:
        return xmlC14NErrMemory((const xmlChar *)"adding node to stack");
      }
    }
    else if (!v7)
    {
      *((void *)a1 + 2) = xmlMalloc(0x80uLL);
      BOOL result = xmlMalloc(0x80uLL);
      *((void *)a1 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = result;
      int v11 = (_OWORD *)*((void *)a1 + 2);
      if (v11 && result)
      {
        v11[6] = 0u;
        v11[7] = 0u;
        v11[4] = 0u;
        v11[5] = 0u;
        v11[2] = 0u;
        v11[3] = 0u;
        _OWORD *v11 = 0u;
        v11[1] = 0u;
        int v12 = (_OWORD *)*((void *)a1 + 3);
        _OWORD v12[6] = 0u;
        v12[7] = 0u;
        v12[4] = 0u;
        v12[5] = 0u;
        v12[2] = 0u;
        v12[3] = 0u;
        _OWORD *v12 = 0u;
        v12[1] = 0u;
        int v10 = 16;
        goto LABEL_15;
      }
      goto LABEL_17;
    }
  }

  return xmlC14NErrParam((const xmlChar *)"adding namespace to stack");
}

uint64_t xmlC14NPrintNamespaces(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    uint64_t v4 = *(void *)(a1 + 24);
    int v5 = *(xmlOutputBuffer **)(a2 + 32);
    if (v4)
    {
      xmlOutputBufferWriteString(v5, " xmlns:");
      xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), *(const char **)(a1 + 24));
      int v5 = *(xmlOutputBuffer **)(a2 + 32);
      uint64_t v6 = "=";
    }
    else
    {
      uint64_t v6 = " xmlns=";
    }
    xmlOutputBufferWriteString(v5, v6);
    uint64_t v8 = *(xmlChar **)(a1 + 16);
    uint64_t v9 = *(void *)(a2 + 32);
    if (v8) {
      xmlBufWriteQuotedString(*(uint64x2_t **)(v9 + 32), v8);
    }
    else {
      xmlOutputBufferWriteString((xmlOutputBufferPtr)v9, "\"\"");
    }
    return 1;
  }
  else
  {
    xmlC14NErrParam((const xmlChar *)"writing namespaces");
    return 0;
  }
}

uint64_t xmlExcC14NVisibleNsStackFind(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    xmlC14NErrParam((const xmlChar *)"searching namespaces stack (exc c14n)");
    return 0;
  }
  uint64_t v3 = "";
  if (a2)
  {
    int v5 = *(const char **)(a2 + 16);
    uint64_t v4 = *(const char **)(a2 + 24);
    if (!v4) {
      uint64_t v4 = "";
    }
    if (!v5) {
      int v5 = "";
    }
    uint64_t v3 = v4;
  }
  else
  {
    int v5 = "";
  }
  if (*v3) {
    BOOL v6 = 0;
  }
  else {
    BOOL v6 = *v5 == 0;
  }
  uint64_t v7 = *((void *)a1 + 2);
  if (!v7) {
    return v6;
  }
  uint64_t v8 = *a1;
  while (2)
  {
    if ((int)v8 < 1) {
      return v6;
    }
    while (1)
    {
      uint64_t v9 = *(void *)(v7 + 8 * (v8 - 1));
      if (!v9) {
        break;
      }
      int v10 = *(const char **)(v9 + 24);
      if (v3 == v10) {
        goto LABEL_29;
      }
      if (!v10) {
        break;
      }
      int v11 = v3;
      while (1)
      {
        int v12 = *(unsigned __int8 *)v11;
        if (v12 != *(unsigned __int8 *)v10) {
          break;
        }
        ++v11;
        ++v10;
        if (!v12) {
          goto LABEL_29;
        }
      }
      if (v8-- < 2) {
        return v6;
      }
    }
    uint64_t v8 = (v8 - 1);
    if (*v3) {
      continue;
    }
    break;
  }
  if (!v9) {
    goto LABEL_34;
  }
LABEL_29:
  int v14 = *(const char **)(v9 + 16);
  if (v5 == v14) {
    goto LABEL_35;
  }
  if (v14)
  {
    while (1)
    {
      int v15 = *(unsigned __int8 *)v5;
      if (v15 != *(unsigned __int8 *)v14) {
        return 0;
      }
      ++v5;
      ++v14;
      if (!v15) {
        goto LABEL_35;
      }
    }
  }
LABEL_34:
  if (*v5) {
    return 0;
  }
LABEL_35:
  uint64_t v16 = *(uint64_t (**)(uint64_t))(a3 + 8);
  if (!v16) {
    return 1;
  }
  uint64_t v17 = *(void *)(a3 + 16);

  return v16(v17);
}

uint64_t xmlC14NAttrsCompare(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 0;
  }
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (!a2) {
    return 1;
  }
  uint64_t v4 = *(void *)(a1 + 72);
  uint64_t v5 = *(void *)(a2 + 72);
  if (v4 != v5)
  {
    if (v4)
    {
      if (!v5) {
        return 1;
      }
      if (*(void *)(v4 + 24))
      {
        if (*(void *)(v5 + 24))
        {
          uint64_t result = xmlStrcmp(*(const xmlChar **)(v4 + 16), *(const xmlChar **)(v5 + 16));
          if (result) {
            return result;
          }
          goto LABEL_10;
        }
        return 1;
      }
    }
    return 0xFFFFFFFFLL;
  }
LABEL_10:
  uint64_t v7 = *(const xmlChar **)(a1 + 16);
  uint64_t v8 = *(const xmlChar **)(a2 + 16);

  return xmlStrcmp(v7, v8);
}

xmlAttrPtr xmlC14NFindHiddenParentAttr(uint64_t a1, const xmlNode *a2, const xmlChar *a3)
{
  if (!a2) {
    return 0;
  }
  uint64_t v4 = a2;
  do
  {
    BOOL v6 = *(unsigned int (**)(void, const xmlNode *, _xmlNode *))(a1 + 8);
    if (!v6 || v6(*(void *)(a1 + 16), v4, v4->parent)) {
      break;
    }
    xmlAttrPtr result = xmlHasNsProp(v4, a3, (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
    if (result) {
      return result;
    }
    uint64_t v4 = v4->parent;
  }
  while (v4);
  return 0;
}

uint64_t xmlC14NPrintAttrs(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), " ");
    uint64_t v4 = *(void *)(a1 + 72);
    if (v4)
    {
      if (xmlStrlen(*(const xmlChar **)(v4 + 24)) >= 1)
      {
        xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), *(const char **)(*(void *)(a1 + 72) + 24));
        xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), ":");
      }
    }
    xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), *(const char **)(a1 + 16));
    xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), "=\"");
    String = xmlNodeListGetString(*(xmlDocPtr *)a2, *(const xmlNode **)(a1 + 24), 1);
    if (!String) {
      goto LABEL_9;
    }
    BOOL v6 = String;
    uint64_t v7 = xmlC11NNormalizeString(String, 0);
    xmlFree(v6);
    if (v7)
    {
      xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), v7);
      xmlFree(v7);
LABEL_9:
      xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), "\"");
      return 1;
    }
    xmlC14NErrInternal((const xmlChar *)"normalizing attributes axis");
  }
  else
  {
    xmlC14NErrParam((const xmlChar *)"writing attributes");
  }
  return 0;
}

void xmlFreeCatalog(xmlCatalogPtr catal)
{
  if (catal)
  {
    uint64_t v2 = (void *)*((void *)catal + 14);
    if (v2)
    {
      do
      {
        uint64_t v3 = (void *)*v2;
        xmlFreeCatalogEntry((uint64_t)v2);
        uint64_t v2 = v3;
      }
      while (v3);
    }
    uint64_t v4 = (xmlHashTable *)*((void *)catal + 12);
    if (v4) {
      xmlHashFree(v4, (xmlHashDeallocator)xmlFreeCatalogEntry);
    }
    xmlFreeFunc v5 = xmlFree;
    ((void (*)(xmlCatalogPtr))v5)(catal);
  }
}

uint64_t xmlFreeCatalogEntry(uint64_t result)
{
  if (!result) {
    return result;
  }
  uint64_t v1 = (void *)result;
  if (*(_DWORD *)(result + 60) == 1) {
    return result;
  }
  if (xmlDebugCatalogs)
  {
    if (*(void *)(result + 32))
    {
      xmlGenericErrorFunc v2 = *__xmlGenericError();
      uint64_t v3 = *__xmlGenericErrorContext();
    }
    else
    {
      uint64_t v4 = *(void *)(result + 40);
      xmlGenericErrorFunc v2 = *__xmlGenericError();
      uint64_t v3 = *__xmlGenericErrorContext();
      if (!v4)
      {
        xmlFreeFunc v5 = "Free catalog entry\n";
        goto LABEL_9;
      }
    }
    xmlFreeFunc v5 = "Free catalog entry %s\n";
LABEL_9:
    v2(v3, v5);
  }
  BOOL v6 = (void *)v1[4];
  if (v6) {
    xmlFree(v6);
  }
  uint64_t v7 = (void *)v1[5];
  if (v7) {
    xmlFree(v7);
  }
  uint64_t v8 = (void *)v1[6];
  if (v8) {
    xmlFree(v8);
  }
  xmlFreeFunc v9 = xmlFree;

  return ((uint64_t (*)(void *))v9)(v1);
}

int xmlConvertSGMLCatalog(xmlCatalogPtr catal)
{
  xmlCatalogPtr data = catal;
  if (!catal || *(_DWORD *)catal != 2) {
    return -1;
  }
  if (xmlDebugCatalogs)
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    uint64_t v3 = __xmlGenericErrorContext();
    v2(*v3, "Converting SGML catalog to XML\n");
  }
  xmlHashScan(*((xmlHashTablePtr *)catal + 12), (xmlHashScanner)xmlCatalogConvertEntry, &data);
  return 0;
}

xmlHashTable *xmlCatalogConvertEntry(xmlHashTable *result, uint64_t a2)
{
  if (result)
  {
    if (a2)
    {
      uint64_t v3 = result;
      xmlAttrPtr result = *(xmlHashTable **)(a2 + 96);
      if (result)
      {
        if (*(void *)(a2 + 112))
        {
          int v4 = *((_DWORD *)v3 + 6) - 13;
          if v4 < 0xA && ((0x2FFu >> v4))
          {
            *((_DWORD *)v3 + 6) = dword_1B51A79E0[v4];
            xmlAttrPtr result = (xmlHashTable *)xmlHashRemoveEntry(result, *((const xmlChar **)v3 + 4), 0);
            uint64_t v6 = *(void *)(a2 + 112);
            *(void *)uint64_t v3 = 0;
            *((void *)v3 + 1) = v6;
            uint64_t v7 = *(xmlHashTable **)(v6 + 16);
            if (v7)
            {
              do
              {
                uint64_t v8 = (xmlHashTable **)v7;
                uint64_t v7 = *(xmlHashTable **)v7;
              }
              while (v7);
              *uint64_t v8 = v3;
            }
            else
            {
              *(void *)(v6 + 16) = v3;
            }
          }
          else
          {
            xmlFreeFunc v5 = (const xmlChar *)*((void *)v3 + 4);
            return (xmlHashTable *)xmlHashRemoveEntry(result, v5, (xmlHashDeallocator)xmlFreeCatalogEntry);
          }
        }
      }
    }
  }
  return result;
}

xmlDocPtr xmlParseCatalogFile(const char *filename)
{
  xmlParserCtxtPtr v2 = xmlNewParserCtxt();
  if (!v2)
  {
    if (__xmlDefaultSAXHandler()->error)
    {
      int v11 = __xmlDefaultSAXHandler();
      v11->error(0, "out of memory\n");
    }
    return 0;
  }
  xmlParserCtxtPtr v3 = v2;
  xmlParserInputBufferPtr v4 = xmlParserInputBufferCreateFilename(filename, XML_CHAR_ENCODING_NONE);
  if (!v4)
  {
LABEL_14:
    xmlFreeParserCtxt(v3);
    return 0;
  }
  xmlParserInputBufferPtr v5 = v4;
  xmlParserInputPtr v6 = xmlNewInputStream(v3);
  if (!v6)
  {
    xmlFreeParserInputBuffer(v5);
    goto LABEL_14;
  }
  uint64_t v7 = v6;
  uint64_t v8 = xmlCanonicPath((const xmlChar *)filename);
  v7->uint64_t buf = v5;
  v7->filename = (const char *)v8;
  xmlBufResetInput((uint64_t *)v5->buffer, v7);
  inputPush(v3, v7);
  if (!v3->directory)
  {
    Directory = xmlParserGetDirectory(filename);
    if (!v3->directory)
    {
      if (Directory) {
        v3->directory = Directory;
      }
    }
  }
  *(void *)&v3->valint id = 0;
  v3->loadsubset = 0;
  v3->pedantic = 0;
  v3->dictNames = 1;
  xmlParseDocument(v3);
  xmlDocPtr myDoc = v3->myDoc;
  if (!v3->wellFormed)
  {
    xmlFreeDoc(v3->myDoc);
    xmlDocPtr myDoc = 0;
    v3->xmlDocPtr myDoc = 0;
  }
  xmlFreeParserCtxt(v3);
  return myDoc;
}

xmlCatalogPtr xmlLoadSGMLSuperCatalog(const char *filename)
{
  FileContent = xmlLoadFileContent((char *)filename);
  if (!FileContent) {
    return 0;
  }
  xmlParserCtxtPtr v3 = FileContent;
  NewCatalog = (xmlCatalog *)xmlCreateNewCatalog(2, xmlCatalogDefaultPrefer);
  xmlParserInputBufferPtr v5 = NewCatalog;
  if (!NewCatalog)
  {
    xmlFree(v3);
    return v5;
  }
  int v6 = xmlParseSGMLCatalog((uint64_t)NewCatalog, (unsigned __int8 *)v3, (xmlChar *)filename, 1);
  xmlFree(v3);
  if (v6 < 0)
  {
    xmlFreeCatalog(v5);
    return 0;
  }
  return v5;
}

char *xmlLoadFileContent(char *a1)
{
  uint64_t v1 = a1;
  if (a1)
  {
    memset(&v7, 0, sizeof(v7));
    if ((stat(a1, &v7) & 0x80000000) == 0)
    {
      int v2 = open(v1, 0);
      if ((v2 & 0x80000000) == 0)
      {
        int v3 = v2;
        size_t st_size = v7.st_size;
        uint64_t v1 = (char *)xmlMallocAtomic(v7.st_size + 10);
        if (!v1)
        {
          xmlCatalogErrMemory((const xmlChar *)"allocating catalog data");
          close(v3);
          return v1;
        }
        int v5 = read(v3, v1, st_size);
        close(v3);
        if ((v5 & 0x80000000) == 0)
        {
          v1[v5] = 0;
          return v1;
        }
        xmlFree(v1);
      }
    }
    return 0;
  }
  return v1;
}

_OWORD *xmlCreateNewCatalog(int a1, int a2)
{
  xmlParserInputBufferPtr v4 = xmlMalloc(0x78uLL);
  int v5 = v4;
  if (v4)
  {
    v4[5] = 0u;
    v4[6] = 0u;
    *((void *)v4 + 14) = 0;
    v4[3] = 0u;
    v4[4] = 0u;
    v4[1] = 0u;
    v4[2] = 0u;
    _OWORD *v4 = 0u;
    *(_DWORD *)xmlParserInputBufferPtr v4 = a1;
    *((void *)v4 + 11) = 0xA00000000;
    *((_DWORD *)v4 + 26) = a2;
    if (a1 == 2) {
      *((void *)v4 + 12) = xmlHashCreate(10);
    }
  }
  else
  {
    xmlCatalogErrMemory((const xmlChar *)"allocating catalog");
  }
  return v5;
}

uint64_t xmlParseSGMLCatalog(uint64_t a1, unsigned __int8 *a2, xmlChar *cur, int a4)
{
  if (!cur) {
    return 0xFFFFFFFFLL;
  }
  stat v7 = xmlStrdup(cur);
  if (!a2) {
    goto LABEL_100;
  }
  while (1)
  {
LABEL_3:
    unsigned int v8 = *a2;
    if (!*a2) {
      break;
    }
    xmlFreeFunc v9 = a2 + 2;
    a2 += 4;
    while (v8 <= 0x2D)
    {
      if (((1 << v8) & 0x100002600) == 0)
      {
        if (!v8)
        {
          a2 = v9 - 2;
          goto LABEL_100;
        }
        if (v8 == 45 && *(v9 - 1) == 45)
        {
          while (1)
          {
            if (*(a2 - 2) == 45)
            {
              if (*(a2 - 1) == 45) {
                goto LABEL_3;
              }
            }
            else if (!*(a2 - 2))
            {
              a2 = 0;
              goto LABEL_100;
            }
            ++a2;
          }
        }
        break;
      }
      unsigned int v8 = *(v9++ - 1);
      ++a2;
    }
    str1 = 0;
    cura = 0;
    int v10 = xmlParseSGMLCatalogName(v9 - 2, &str1);
    a2 = v10;
    if (!v10) {
      break;
    }
    int v11 = str1;
    if (!str1) {
      break;
    }
    unsigned int v12 = *v10;
    if (v12 > 0x20 || ((1 << v12) & 0x100002600) == 0) {
      goto LABEL_108;
    }
    while (v12 <= 0x20u && ((1 << v12) & 0x100002600) != 0)
    {
      char v14 = *++a2;
      LOBYTE(v12) = v14;
    }
    int v15 = xmlStrEqual(str1, (const xmlChar *)"SYSTEM");
    if (v15)
    {
      int v17 = 13;
LABEL_43:
      int v42 = v17;
      xmlFree(v11);
      str1 = 0;
      char v18 = xmlParseSGMLCatalogPubid(a2, &str1);
      if (!v18) {
        goto LABEL_105;
      }
      a2 = v18;
      if (!v15)
      {
        long long v22 = str1;
        int v23 = xmlCatalogNormalizePublic(str1);
        if (v23)
        {
          uint64_t v24 = v23;
          if (v22) {
            xmlFree(v22);
          }
          if (*v24)
          {
            str1 = v24;
          }
          else
          {
            xmlFree(v24);
            str1 = 0;
          }
        }
      }
      unsigned int v19 = *a2;
      if (v19 > 0x20 || ((1 << v19) & 0x100002600) == 0)
      {
LABEL_71:
        int v30 = v42;
LABEL_82:
        if ((v30 - 13) > 1)
        {
          if (v30 == 22)
          {
            uint64_t v37 = cura;
            if (a4)
            {
              BOOL v38 = xmlNewCatalogEntry(22, cura, 0, 0, 0, 0);
              if (xmlHashAddEntry(*(xmlHashTablePtr *)(a1 + 96), v37, v38) < 0) {
                xmlFreeCatalogEntry((uint64_t)v38);
              }
            }
            else
            {
              xmlListPtr v39 = (char *)xmlBuildURI(cura, v7);
              if (v39)
              {
                int v40 = v39;
                xmlExpandCatalog(a1, v39);
                xmlFree(v40);
              }
            }
          }
        }
        else
        {
          int v33 = xmlBuildURI(cura, v7);
          if (v33)
          {
            uint64_t v34 = v33;
            xmlNsPtr v35 = str1;
            uint64_t v36 = xmlNewCatalogEntry(v30, str1, v33, 0, 0, 0);
            if (xmlHashAddEntry(*(xmlHashTablePtr *)(a1 + 96), v35, v36) < 0) {
              xmlFreeCatalogEntry((uint64_t)v36);
            }
            xmlFree(v34);
          }
        }
        goto LABEL_93;
      }
      while (v19 <= 0x20u && ((1 << v19) & 0x100002600) != 0)
      {
        char v21 = *++a2;
        LOBYTE(v19) = v21;
      }
LABEL_77:
      int v32 = xmlParseSGMLCatalogPubid(a2, &cura);
      if (!v32)
      {
LABEL_105:
        if (str1) {
          xmlFree(str1);
        }
        a2 = 0;
        int v11 = cura;
        if (cura)
        {
LABEL_108:
          xmlFree(v11);
          break;
        }
        break;
      }
      a2 = v32;
      int v30 = v42;
      if (v42 != 21) {
        goto LABEL_82;
      }
      if (v7) {
        xmlFree(v7);
      }
      stat v7 = xmlStrdup(cura);
LABEL_93:
      if (str1) {
        xmlFree(str1);
      }
LABEL_95:
      if (cura) {
        xmlFree(cura);
      }
    }
    else
    {
      if (xmlStrEqual(v11, (const xmlChar *)"PUBLIC"))
      {
        int v17 = 14;
        goto LABEL_43;
      }
      if (xmlStrEqual(v11, (const xmlChar *)"DELEGATE"))
      {
        int v17 = 20;
        goto LABEL_43;
      }
      if (xmlStrEqual(v11, (const xmlChar *)"ENTITY"))
      {
        xmlFree(v11);
        str1 = 0;
        if (*a2 == 37) {
          int v25 = 16;
        }
        else {
          int v25 = 15;
        }
        int v42 = v25;
        goto LABEL_65;
      }
      if (xmlStrEqual(v11, (const xmlChar *)"DOCTYPE"))
      {
        int v26 = 17;
        goto LABEL_64;
      }
      if (xmlStrEqual(v11, (const xmlChar *)"LINKTYPE"))
      {
        int v26 = 18;
        goto LABEL_64;
      }
      if (xmlStrEqual(v11, (const xmlChar *)"NOTATION"))
      {
        int v26 = 19;
LABEL_64:
        int v42 = v26;
        xmlFree(v11);
        str1 = 0;
LABEL_65:
        int v27 = xmlParseSGMLCatalogName(a2, &str1);
        if (!v27) {
          goto LABEL_105;
        }
        a2 = v27;
        unsigned int v28 = *v27;
        if (v28 > 0x20 || ((1 << v28) & 0x100002600) == 0) {
          goto LABEL_71;
        }
        while (v28 <= 0x20u && ((1 << v28) & 0x100002600) != 0)
        {
          char v29 = *++a2;
          LOBYTE(v28) = v29;
        }
        goto LABEL_77;
      }
      if (xmlStrEqual(v11, (const xmlChar *)"SGMLDECL"))
      {
        int v31 = 24;
LABEL_76:
        int v42 = v31;
        xmlFree(v11);
        str1 = 0;
        goto LABEL_77;
      }
      if (xmlStrEqual(v11, (const xmlChar *)"DOCUMENT"))
      {
        int v31 = 23;
        goto LABEL_76;
      }
      if (xmlStrEqual(v11, (const xmlChar *)"CATALOG"))
      {
        int v31 = 22;
        goto LABEL_76;
      }
      if (xmlStrEqual(v11, (const xmlChar *)"BASE"))
      {
        int v31 = 21;
        goto LABEL_76;
      }
      int v16 = xmlStrEqual(v11, (const xmlChar *)"OVERRIDE");
      xmlFree(v11);
      if (!v16) {
        goto LABEL_95;
      }
      a2 = xmlParseSGMLCatalogName(a2, &str1);
      if (!str1) {
        break;
      }
      xmlFree(str1);
      if (!a2) {
        break;
      }
    }
  }
LABEL_100:
  if (v7) {
    xmlFree(v7);
  }
  if (a2) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

xmlCatalogPtr xmlLoadACatalog(const char *filename)
{
  FileContent = xmlLoadFileContent((char *)filename);
  if (!FileContent) {
    return 0;
  }
  int v3 = (unsigned __int8 *)FileContent;
  xmlParserInputBufferPtr v4 = FileContent;
  while (1)
  {
    int v5 = *v4;
    if (!*v4 || v5 == 45)
    {
LABEL_7:
      NewCatalog = (xmlCatalog *)xmlCreateNewCatalog(2, xmlCatalogDefaultPrefer);
      stat v7 = NewCatalog;
      if (NewCatalog && (xmlParseSGMLCatalog((uint64_t)NewCatalog, v3, (xmlChar *)filename, 0) & 0x80000000) != 0)
      {
        xmlFreeCatalog(v7);
        stat v7 = 0;
      }
      goto LABEL_13;
    }
    if (v5 == 60) {
      break;
    }
    ++v4;
    if ((v5 & 0xFFFFFFDF) - 65 <= 0x19) {
      goto LABEL_7;
    }
  }
  stat v7 = (xmlCatalog *)xmlCreateNewCatalog(1, xmlCatalogDefaultPrefer);
  if (v7) {
    *((void *)v7 + 14) = xmlNewCatalogEntry(1, 0, 0, (xmlChar *)filename, xmlCatalogDefaultPrefer, 0);
  }
LABEL_13:
  xmlFree(v3);
  return v7;
}

void *xmlNewCatalogEntry(int a1, xmlChar *a2, const xmlChar *a3, xmlChar *a4, int a5, uint64_t a6)
{
  unsigned int v12 = xmlMalloc(0x50uLL);
  uint64_t v13 = v12;
  if (!v12)
  {
    xmlCatalogErrMemory((const xmlChar *)"allocating catalog entry");
    return v13;
  }
  void *v12 = 0;
  v12[1] = 0;
  v12[2] = 0;
  *((_DWORD *)v12 + 6) = a1;
  if (a1 == 8 || a1 == 5)
  {
    char v14 = xmlCatalogNormalizePublic(a2);
    if (v14)
    {
      int v15 = v14;
      if (!*v14)
      {
        int v16 = 0;
        goto LABEL_11;
      }
      a2 = v14;
      goto LABEL_9;
    }
  }
  int v15 = 0;
  int v16 = 0;
  if (a2) {
LABEL_9:
  }
    int v16 = xmlStrdup(a2);
LABEL_11:
  v13[4] = v16;
  if (v15) {
    xmlFree(v15);
  }
  if (a3) {
    int v17 = xmlStrdup(a3);
  }
  else {
    int v17 = 0;
  }
  v13[5] = v17;
  if (a4) {
    char v18 = a4;
  }
  else {
    char v18 = (xmlChar *)a3;
  }
  if (v18) {
    char v18 = xmlStrdup(v18);
  }
  v13[6] = v18;
  *((_DWORD *)v13 + 15) = 0;
  *((_DWORD *)v13 + 16) = 0;
  *((_DWORD *)v13 + 14) = a5;
  v13[9] = a6;
  return v13;
}

xmlChar *__cdecl xmlACatalogResolveSystem(xmlCatalogPtr catal, const xmlChar *sysID)
{
  xmlAttrPtr result = 0;
  if (catal && sysID)
  {
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v5 = *__xmlGenericError();
      int v6 = __xmlGenericErrorContext();
      v5(*v6, "Resolve sysID %s\n", (const char *)sysID);
    }
    if (*(_DWORD *)catal == 1)
    {
      xmlAttrPtr result = (xmlChar *)xmlCatalogListXMLResolve(*((void *)catal + 14), 0, (uint64_t)sysID);
      if (result == (xmlChar *)-1) {
        return 0;
      }
    }
    else
    {
      xmlAttrPtr result = (xmlChar *)*((void *)catal + 12);
      if (result)
      {
        xmlAttrPtr result = (xmlChar *)xmlHashLookup((xmlHashTablePtr)result, sysID);
        if (result)
        {
          if (*((_DWORD *)result + 6) == 13)
          {
            xmlAttrPtr result = (xmlChar *)*((void *)result + 6);
            if (result)
            {
              return xmlStrdup(result);
            }
          }
          else
          {
            return 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t xmlCatalogListXMLResolve(uint64_t a1, xmlChar *a2, uint64_t a3)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  xmlParserInputBufferPtr v4 = (const char *)a2;
  if (!((unint64_t)a2 | a3)) {
    return 0;
  }
  uint64_t v6 = a1;
  stat v7 = xmlCatalogNormalizePublic(a2);
  unsigned int v8 = v7;
  if (v7)
  {
    if (*v7) {
      xmlParserInputBufferPtr v4 = (const char *)v7;
    }
    else {
      xmlParserInputBufferPtr v4 = 0;
    }
  }
  if (!xmlStrncmp((const xmlChar *)v4, (const xmlChar *)"urn:publicid:", 13))
  {
    xmlListPtr v58 = xmlCatalogUnWrapURN((uint64_t)v4);
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v59 = *__xmlGenericError();
      int v60 = *__xmlGenericErrorContext();
      if (!v58)
      {
        v59(v60, "Public URN ID %s expanded to NULL\n", v4);
        uint64_t v5 = xmlCatalogListXMLResolve(v6, 0, a3);
        goto LABEL_135;
      }
      v59(v60, "Public URN ID expanded to %s\n", (const char *)v58);
      uint64_t v5 = xmlCatalogListXMLResolve(v6, v58, a3);
LABEL_134:
      xmlFree(v58);
      goto LABEL_135;
    }
    uint64_t v64 = v6;
    uint64_t v65 = v58;
    uint64_t v66 = a3;
    goto LABEL_133;
  }
  if (!xmlStrncmp((const xmlChar *)a3, (const xmlChar *)"urn:publicid:", 13))
  {
    xmlListPtr v58 = xmlCatalogUnWrapURN(a3);
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v61 = *__xmlGenericError();
      uint64_t v62 = *__xmlGenericErrorContext();
      if (v58) {
        uint64_t v63 = "System URN ID expanded to %s\n";
      }
      else {
        uint64_t v63 = "System URN ID %s expanded to NULL\n";
      }
      v61(v62, v63);
    }
    if (!v4)
    {
      uint64_t v64 = v6;
      uint64_t v65 = v58;
      goto LABEL_131;
    }
    if (xmlStrEqual((const xmlChar *)v4, v58))
    {
      uint64_t v64 = v6;
      uint64_t v65 = (void *)v4;
LABEL_131:
      uint64_t v66 = 0;
      goto LABEL_133;
    }
    uint64_t v64 = v6;
    uint64_t v65 = (void *)v4;
    uint64_t v66 = (uint64_t)v58;
LABEL_133:
    uint64_t v5 = xmlCatalogListXMLResolve(v64, v65, v66);
    if (!v58) {
      goto LABEL_135;
    }
    goto LABEL_134;
  }
  xmlAttrPtr v68 = v8;
  while (1)
  {
    if (*(_DWORD *)(v6 + 24) == 1)
    {
      uint64_t v9 = *(void *)(v6 + 16);
      if (v9) {
        break;
      }
      xmlFetchXMLCatalogFile(v6);
      uint64_t v9 = *(void *)(v6 + 16);
      if (v9) {
        break;
      }
    }
LABEL_114:
    uint64_t v6 = *(void *)v6;
    if (!v6)
    {
LABEL_115:
      uint64_t v5 = 0;
      goto LABEL_116;
    }
  }
  int v10 = *(_DWORD *)(v9 + 64);
  if (v10 >= 51)
  {
    __xmlRaiseError(0, 0, 0, (void *)v9, 0, 0x14u, 1654, 2, 0, 0, *(const xmlChar **)(v9 + 32), 0, 0, 0, 0, "Detected recursion in catalog %s\n", *(void *)(v9 + 32));
    goto LABEL_113;
  }
  *(_DWORD *)(v9 + 64) = v10 + 1;
  if (a3)
  {
    int v11 = 0;
    uint64_t v12 = 0;
    int v13 = 0;
    int v14 = 0;
    uint64_t v15 = v9;
    while (2)
    {
      switch(*(_DWORD *)(v15 + 24))
      {
        case 3:
          ++v13;
          goto LABEL_28;
        case 6:
          if (!xmlStrEqual((const xmlChar *)a3, *(const xmlChar **)(v15 + 32))) {
            goto LABEL_28;
          }
          if (xmlDebugCatalogs)
          {
            xmlGenericErrorFunc v53 = *__xmlGenericError();
            int v54 = __xmlGenericErrorContext();
            v53(*v54, "Found system match %s, using %s\n", *(const char **)(v15 + 32), *(const char **)(v15 + 48));
          }
          --*(_DWORD *)(v9 + 64);
          BOOL v55 = *(const xmlChar **)(v15 + 48);
          goto LABEL_111;
        case 7:
          int v16 = xmlStrlen(*(const xmlChar **)(v15 + 32));
          if (v16 > v11)
          {
            int v17 = v16;
            if (!xmlStrncmp((const xmlChar *)a3, *(const xmlChar **)(v15 + 32), v16))
            {
              uint64_t v12 = v15;
              int v11 = v17;
            }
          }
          goto LABEL_28;
        case 9:
          char v18 = *(const xmlChar **)(v15 + 32);
          int v19 = xmlStrlen(v18);
          if (!xmlStrncmp((const xmlChar *)a3, v18, v19)) {
            ++v14;
          }
          goto LABEL_28;
        default:
LABEL_28:
          uint64_t v15 = *(void *)v15;
          if (v15) {
            continue;
          }
          if (v12)
          {
            if (xmlDebugCatalogs)
            {
              xmlGenericErrorFunc v20 = *__xmlGenericError();
              char v21 = __xmlGenericErrorContext();
              v20(*v21, "Using rewriting rule %s\n", *(const char **)(v12 + 32));
            }
            long long v22 = xmlStrdup(*(const xmlChar **)(v12 + 48));
            if (!v22)
            {
              uint64_t v5 = 0;
LABEL_104:
              --*(_DWORD *)(v9 + 64);
LABEL_112:
              if (v5) {
                goto LABEL_116;
              }
LABEL_113:
              if (*(int *)(*(void *)(v6 + 16) + 64) > 50) {
                goto LABEL_115;
              }
              goto LABEL_114;
            }
            int v23 = xmlStrcat(v22, (const xmlChar *)(a3 + v11));
LABEL_34:
            uint64_t v5 = (uint64_t)v23;
            goto LABEL_104;
          }
          if (v14)
          {
            int v43 = 0;
            long long v92 = 0u;
            long long v93 = 0u;
            long long v90 = 0u;
            long long v91 = 0u;
            long long v88 = 0u;
            long long v89 = 0u;
            long long v86 = 0u;
            long long v87 = 0u;
            long long v84 = 0u;
            long long v85 = 0u;
            long long v82 = 0u;
            long long v83 = 0u;
            long long v80 = 0u;
            long long v81 = 0u;
            long long v78 = 0u;
            long long v79 = 0u;
            long long v76 = 0u;
            long long v77 = 0u;
            long long v74 = 0u;
            long long v75 = 0u;
            long long v72 = 0u;
            long long v73 = 0u;
            long long v70 = 0u;
            long long v71 = 0u;
            uint64_t v44 = v9;
            long long v69 = 0u;
            while (1)
            {
              uint64_t v45 = v44;
LABEL_83:
              if (*(_DWORD *)(v45 + 24) == 9)
              {
                int v46 = *(const xmlChar **)(v45 + 32);
                int v47 = xmlStrlen(v46);
                if (!xmlStrncmp((const xmlChar *)a3, v46, v47))
                {
                  if (v43 < 1)
                  {
                    uint64_t v45 = v44;
                  }
                  else
                  {
                    int v48 = (const xmlChar **)&v69;
                    uint64_t v49 = v43;
                    do
                    {
                      if (xmlStrEqual(*(const xmlChar **)(v45 + 48), *v48))
                      {
                        uint64_t v45 = *(void *)v45;
                        if (v45) {
                          goto LABEL_83;
                        }
                        goto LABEL_102;
                      }
                      ++v48;
                      --v49;
                    }
                    while (v49);
                    if (v43 > 49) {
                      goto LABEL_94;
                    }
                  }
                  *((void *)&v69 + v43++) = *(void *)(v45 + 48);
LABEL_94:
                  uint64_t v50 = *(void *)(v45 + 16);
                  if (v50 || (xmlFetchXMLCatalogFile(v45), (uint64_t v50 = *(void *)(v45 + 16)) != 0))
                  {
                    if (xmlDebugCatalogs)
                    {
                      xmlGenericErrorFunc v51 = *__xmlGenericError();
                      uint64_t v52 = __xmlGenericErrorContext();
                      v51(*v52, "Trying system delegate %s\n", *(const char **)(v45 + 48));
                      uint64_t v50 = *(void *)(v45 + 16);
                    }
                    int v23 = (xmlChar *)xmlCatalogListXMLResolve(v50, 0, a3);
                    if (v23) {
                      goto LABEL_34;
                    }
                  }
                }
              }
              uint64_t v44 = *(void *)v45;
              if (!*(void *)v45) {
                goto LABEL_102;
              }
            }
          }
          break;
      }
      break;
    }
  }
  else
  {
    int v13 = 0;
  }
  if (v4)
  {
    int v24 = 0;
    uint64_t v25 = v9;
    do
    {
      int v26 = *(_DWORD *)(v25 + 24);
      if (v26 == 3)
      {
        v13 += a3 == 0;
      }
      else if (v26 == 8)
      {
        int v27 = *(const xmlChar **)(v25 + 32);
        int v28 = xmlStrlen(v27);
        if (!xmlStrncmp((const xmlChar *)v4, v27, v28) && *(_DWORD *)(v25 + 56) == 1) {
          ++v24;
        }
      }
      else if (v26 == 5 && xmlStrEqual((const xmlChar *)v4, *(const xmlChar **)(v25 + 32)))
      {
        if (xmlDebugCatalogs)
        {
          xmlGenericErrorFunc v56 = *__xmlGenericError();
          int v57 = __xmlGenericErrorContext();
          v56(*v57, "Found public match %s\n", *(const char **)(v25 + 32));
        }
        --*(_DWORD *)(v9 + 64);
        BOOL v55 = *(const xmlChar **)(v25 + 48);
LABEL_111:
        uint64_t v5 = (uint64_t)xmlStrdup(v55);
        goto LABEL_112;
      }
      uint64_t v25 = *(void *)v25;
    }
    while (v25);
    if (v24)
    {
      long long v92 = 0u;
      long long v93 = 0u;
      long long v90 = 0u;
      long long v91 = 0u;
      long long v88 = 0u;
      long long v89 = 0u;
      long long v86 = 0u;
      long long v87 = 0u;
      long long v84 = 0u;
      long long v85 = 0u;
      long long v82 = 0u;
      long long v83 = 0u;
      long long v80 = 0u;
      long long v81 = 0u;
      long long v78 = 0u;
      long long v79 = 0u;
      long long v76 = 0u;
      long long v77 = 0u;
      long long v74 = 0u;
      long long v75 = 0u;
      long long v72 = 0u;
      long long v73 = 0u;
      long long v70 = 0u;
      long long v71 = 0u;
      long long v69 = 0u;
      int v29 = 0;
      uint64_t v30 = v9;
      while (1)
      {
        uint64_t v31 = v30;
LABEL_51:
        if (*(_DWORD *)(v31 + 24) == 8 && *(_DWORD *)(v31 + 56) == 1)
        {
          int v32 = *(const xmlChar **)(v31 + 32);
          int v33 = xmlStrlen(v32);
          if (!xmlStrncmp((const xmlChar *)v4, v32, v33))
          {
            if (v29 < 1)
            {
              uint64_t v31 = v30;
            }
            else
            {
              uint64_t v34 = (const xmlChar **)&v69;
              uint64_t v35 = v29;
              do
              {
                if (xmlStrEqual(*(const xmlChar **)(v31 + 48), *v34))
                {
                  uint64_t v31 = *(void *)v31;
                  if (v31) {
                    goto LABEL_51;
                  }
                  goto LABEL_102;
                }
                ++v34;
                --v35;
              }
              while (v35);
              if (v29 > 49) {
                goto LABEL_63;
              }
            }
            *((void *)&v69 + v29++) = *(void *)(v31 + 48);
LABEL_63:
            uint64_t v36 = *(void *)(v31 + 16);
            if (v36 || (xmlFetchXMLCatalogFile(v31), (uint64_t v36 = *(void *)(v31 + 16)) != 0))
            {
              if (xmlDebugCatalogs)
              {
                xmlGenericErrorFunc v37 = *__xmlGenericError();
                BOOL v38 = __xmlGenericErrorContext();
                v37(*v38, "Trying public delegate %s\n", *(const char **)(v31 + 48));
                uint64_t v36 = *(void *)(v31 + 16);
              }
              int v23 = (xmlChar *)xmlCatalogListXMLResolve(v36, v4, 0);
              if (v23) {
                goto LABEL_34;
              }
            }
          }
        }
        uint64_t v30 = *(void *)v31;
        if (!*(void *)v31)
        {
LABEL_102:
          uint64_t v5 = -1;
          goto LABEL_104;
        }
      }
    }
  }
  if (!v13)
  {
LABEL_79:
    --*(_DWORD *)(v9 + 64);
    goto LABEL_113;
  }
  uint64_t v39 = v9;
  while (1)
  {
    if (*(_DWORD *)(v39 + 24) == 3)
    {
      uint64_t v40 = *(void *)(v39 + 16);
      if (v40) {
        break;
      }
      xmlFetchXMLCatalogFile(v39);
      uint64_t v40 = *(void *)(v39 + 16);
      if (v40) {
        break;
      }
    }
LABEL_78:
    uint64_t v39 = *(void *)v39;
    if (!v39) {
      goto LABEL_79;
    }
  }
  uint64_t v41 = xmlCatalogListXMLResolve(v40, v4, a3);
  int v42 = *(_DWORD *)(v9 + 64);
  if (!v41)
  {
    if (v42 > 50) {
      goto LABEL_113;
    }
    goto LABEL_78;
  }
  uint64_t v5 = v41;
  *(_DWORD *)(v9 + 64) = v42 - 1;
LABEL_116:
  unsigned int v8 = v68;
LABEL_135:
  if (v8) {
    xmlFree(v8);
  }
  return v5;
}

xmlChar *__cdecl xmlACatalogResolvePublic(xmlCatalogPtr catal, const xmlChar *pubID)
{
  xmlAttrPtr result = 0;
  if (catal && pubID)
  {
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v5 = *__xmlGenericError();
      uint64_t v6 = __xmlGenericErrorContext();
      v5(*v6, "Resolve pubID %s\n", (const char *)pubID);
    }
    if (*(_DWORD *)catal == 1)
    {
      xmlAttrPtr result = (xmlChar *)xmlCatalogListXMLResolve(*((void *)catal + 14), (xmlChar *)pubID, 0);
      if (result == (xmlChar *)-1) {
        return 0;
      }
    }
    else
    {
      xmlAttrPtr result = (xmlChar *)xmlCatalogGetSGMLPublic(*((xmlHashTable **)catal + 12), (xmlChar *)pubID);
      if (result)
      {
        return xmlStrdup(result);
      }
    }
  }
  return result;
}

xmlHashTable *xmlCatalogGetSGMLPublic(xmlHashTable *result, xmlChar *cur)
{
  if (result)
  {
    int v3 = result;
    xmlParserInputBufferPtr v4 = xmlCatalogNormalizePublic(cur);
    if (v4)
    {
      xmlGenericErrorFunc v5 = v4;
      if (*v4) {
        uint64_t v6 = v4;
      }
      else {
        uint64_t v6 = 0;
      }
      stat v7 = (xmlHashTable *)xmlHashLookup(v3, v6);
      if (!v7)
      {
        xmlFree(v5);
        return 0;
      }
      unsigned int v8 = v7;
      int v9 = *((_DWORD *)v7 + 6);
      xmlFree(v5);
      if (v9 != 14) {
        return 0;
      }
    }
    else
    {
      xmlAttrPtr result = (xmlHashTable *)xmlHashLookup(v3, cur);
      if (!result) {
        return result;
      }
      unsigned int v8 = result;
      if (*((_DWORD *)result + 6) != 14) {
        return 0;
      }
    }
    return (xmlHashTable *)*((void *)v8 + 6);
  }
  return result;
}

xmlChar *__cdecl xmlACatalogResolve(xmlCatalogPtr catal, const xmlChar *pubID, const xmlChar *sysID)
{
  xmlAttrPtr result = 0;
  if (catal && (unint64_t)pubID | (unint64_t)sysID)
  {
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v7 = *__xmlGenericError();
      unsigned int v8 = *__xmlGenericErrorContext();
      if (pubID && sysID)
      {
        int v9 = "Resolve: pubID %s sysID %s\n";
      }
      else if (pubID)
      {
        int v9 = "Resolve: pubID %s\n";
      }
      else
      {
        int v9 = "Resolve: sysID %s\n";
      }
      v7(v8, v9);
    }
    if (*(_DWORD *)catal == 1)
    {
      xmlAttrPtr result = (xmlChar *)xmlCatalogListXMLResolve(*((void *)catal + 14), (xmlChar *)pubID, (uint64_t)sysID);
      if (result == (xmlChar *)-1) {
        return 0;
      }
    }
    else
    {
      xmlAttrPtr result = (xmlChar *)xmlCatalogSGMLResolve((uint64_t)catal, (xmlChar *)pubID, (xmlChar *)sysID);
      if (result)
      {
        return xmlStrdup(result);
      }
    }
  }
  return result;
}

xmlHashTable *xmlCatalogSGMLResolve(uint64_t a1, xmlChar *a2, xmlChar *name)
{
  xmlAttrPtr result = *(xmlHashTable **)(a1 + 96);
  if (result)
  {
    if (!a2 || (xmlAttrPtr result = xmlCatalogGetSGMLPublic(result, a2)) == 0)
    {
      if (!name) {
        return 0;
      }
      xmlAttrPtr result = *(xmlHashTable **)(a1 + 96);
      if (result)
      {
        xmlAttrPtr result = (xmlHashTable *)xmlHashLookup(result, name);
        if (result)
        {
          if (*((_DWORD *)result + 6) == 13) {
            return (xmlHashTable *)*((void *)result + 6);
          }
          return 0;
        }
      }
    }
  }
  return result;
}

xmlChar *__cdecl xmlACatalogResolveURI(xmlCatalogPtr catal, const xmlChar *URI)
{
  xmlAttrPtr result = 0;
  if (catal && URI)
  {
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v5 = *__xmlGenericError();
      uint64_t v6 = __xmlGenericErrorContext();
      v5(*v6, "Resolve URI %s\n", (const char *)URI);
    }
    if (*(_DWORD *)catal == 1)
    {
      xmlAttrPtr result = (xmlChar *)xmlCatalogListXMLResolveURI(*((void *)catal + 14), (const char *)URI);
      if (result == (xmlChar *)-1) {
        return 0;
      }
    }
    else
    {
      xmlAttrPtr result = (xmlChar *)xmlCatalogSGMLResolve((uint64_t)catal, 0, (xmlChar *)URI);
      if (result)
      {
        return xmlStrdup(result);
      }
    }
  }
  return result;
}

uint64_t xmlCatalogListXMLResolveURI(uint64_t a1, const char *a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  uint64_t v3 = a1;
  if (!xmlStrncmp((const xmlChar *)a2, (const xmlChar *)"urn:publicid:", 13))
  {
    uint64_t v34 = xmlCatalogUnWrapURN((uint64_t)a2);
    if (!xmlDebugCatalogs)
    {
      uint64_t v31 = xmlCatalogListXMLResolve(v3, v34, 0);
      if (!v34) {
        return v31;
      }
LABEL_70:
      xmlFree(v34);
      return v31;
    }
    xmlGenericErrorFunc v35 = *__xmlGenericError();
    uint64_t v36 = *__xmlGenericErrorContext();
    if (v34)
    {
      v35(v36, "URN ID expanded to %s\n", (const char *)v34);
      uint64_t v31 = xmlCatalogListXMLResolve(v3, v34, 0);
      goto LABEL_70;
    }
    v35(v36, "URN ID %s expanded to NULL\n", a2);
    return 0;
  }
LABEL_3:
  if (*(_DWORD *)(v3 + 24) != 1) {
    goto LABEL_56;
  }
  uint64_t v4 = *(void *)(v3 + 16);
  if (!v4)
  {
    xmlFetchXMLCatalogFile(v3);
    uint64_t v4 = *(void *)(v3 + 16);
    if (!v4) {
      goto LABEL_56;
    }
  }
  if (*(int *)(v4 + 64) > 50)
  {
    __xmlRaiseError(0, 0, 0, (void *)v4, 0, 0x14u, 1654, 2, 0, 0, *(const xmlChar **)(v4 + 32), 0, 0, 0, 0, "Detected recursion in catalog %s\n", *(void *)(v4 + 32));
    goto LABEL_56;
  }
  int v5 = 0;
  uint64_t v6 = 0;
  int v7 = 0;
  int v8 = 0;
  uint64_t v9 = v4;
  while (2)
  {
    switch(*(_DWORD *)(v9 + 24))
    {
      case 3:
        ++v7;
        goto LABEL_19;
      case 0xA:
        if (!xmlStrEqual((const xmlChar *)a2, *(const xmlChar **)(v9 + 32))) {
          goto LABEL_19;
        }
        if (xmlDebugCatalogs)
        {
          xmlGenericErrorFunc v29 = *__xmlGenericError();
          uint64_t v30 = __xmlGenericErrorContext();
          v29(*v30, "Found URI match %s\n", *(const char **)(v9 + 32));
        }
        int v17 = xmlStrdup(*(const xmlChar **)(v9 + 48));
        goto LABEL_54;
      case 0xB:
        int v10 = xmlStrlen(*(const xmlChar **)(v9 + 32));
        if (v10 > v5)
        {
          int v11 = v10;
          if (!xmlStrncmp((const xmlChar *)a2, *(const xmlChar **)(v9 + 32), v10))
          {
            uint64_t v6 = v9;
            int v5 = v11;
          }
        }
        goto LABEL_19;
      case 0xC:
        uint64_t v12 = *(const xmlChar **)(v9 + 32);
        int v13 = xmlStrlen(v12);
        if (!xmlStrncmp((const xmlChar *)a2, v12, v13)) {
          ++v8;
        }
        goto LABEL_19;
      default:
LABEL_19:
        uint64_t v9 = *(void *)v9;
        if (v9) {
          continue;
        }
        if (v6)
        {
          if (xmlDebugCatalogs)
          {
            xmlGenericErrorFunc v14 = *__xmlGenericError();
            uint64_t v15 = __xmlGenericErrorContext();
            v14(*v15, "Using rewriting rule %s\n", *(const char **)(v6 + 32));
          }
          int v16 = xmlStrdup(*(const xmlChar **)(v6 + 48));
          if (!v16) {
            goto LABEL_56;
          }
          int v17 = xmlStrcat(v16, (const xmlChar *)&a2[v5]);
          goto LABEL_54;
        }
        if (v8)
        {
          int v18 = 0;
          memset(v38, 0, sizeof(v38));
          while (1)
          {
            uint64_t v19 = v4;
LABEL_28:
            int v20 = *(_DWORD *)(v19 + 24);
            if (v20 == 12 || v20 == 9)
            {
              long long v22 = *(const xmlChar **)(v19 + 32);
              int v23 = xmlStrlen(v22);
              if (!xmlStrncmp((const xmlChar *)a2, v22, v23))
              {
                if (v18 < 1)
                {
                  uint64_t v19 = v4;
                }
                else
                {
                  int v24 = (const xmlChar **)v38;
                  uint64_t v25 = v18;
                  do
                  {
                    if (xmlStrEqual(*(const xmlChar **)(v19 + 48), *v24))
                    {
                      uint64_t v19 = *(void *)v19;
                      if (v19) {
                        goto LABEL_28;
                      }
                      goto LABEL_58;
                    }
                    ++v24;
                    --v25;
                  }
                  while (v25);
                  if (v18 > 49) {
                    goto LABEL_43;
                  }
                }
                *((void *)v38 + v18++) = *(void *)(v19 + 48);
LABEL_43:
                uint64_t v26 = *(void *)(v19 + 16);
                if (v26 || (xmlFetchXMLCatalogFile(v19), (uint64_t v26 = *(void *)(v19 + 16)) != 0))
                {
                  if (xmlDebugCatalogs)
                  {
                    xmlGenericErrorFunc v27 = *__xmlGenericError();
                    int v28 = __xmlGenericErrorContext();
                    v27(*v28, "Trying URI delegate %s\n", *(const char **)(v19 + 48));
                    uint64_t v26 = *(void *)(v19 + 16);
                  }
                  int v17 = (xmlChar *)xmlCatalogListXMLResolveURI(v26, a2);
                  if (v17) {
                    break;
                  }
                }
              }
            }
            uint64_t v4 = *(void *)v19;
            if (!*(void *)v19)
            {
LABEL_58:
              uint64_t v31 = -1;
              goto LABEL_55;
            }
          }
LABEL_54:
          uint64_t v31 = (uint64_t)v17;
LABEL_55:
          if (v31) {
            return v31;
          }
LABEL_56:
          uint64_t v3 = *(void *)v3;
          if (!v3) {
            return 0;
          }
          goto LABEL_3;
        }
        if (!v7) {
          goto LABEL_56;
        }
        while (1)
        {
          if (*(_DWORD *)(v4 + 24) == 3)
          {
            uint64_t v32 = *(void *)(v4 + 16);
            if (v32 || (xmlFetchXMLCatalogFile(v4), (uint64_t v32 = *(void *)(v4 + 16)) != 0))
            {
              uint64_t v33 = xmlCatalogListXMLResolveURI(v32, a2);
              if (v33) {
                return v33;
              }
            }
          }
          uint64_t v4 = *(void *)v4;
          if (!v4) {
            goto LABEL_56;
          }
        }
    }
  }
}

void xmlACatalogDump(xmlCatalogPtr catal, FILE *out)
{
  if (catal && out)
  {
    if (*(_DWORD *)catal == 1)
    {
      uint64_t v3 = (xmlNode *)*((void *)catal + 14);
      uint64_t v4 = xmlNewDoc(0);
      if (v4)
      {
        int v5 = (xmlNode *)v4;
        uint64_t v6 = (xmlNode *)xmlNewDtd(v4, (const xmlChar *)"catalog", (const xmlChar *)"-//OASIS//DTD Entity Resolution XML Catalog V1.0//EN", (const xmlChar *)"http://www.oasis-open.org/committees/entity/release/1.0/catalog.dtd");
        xmlAddChild(v5, v6);
        int v7 = xmlNewNs(0, (const xmlChar *)"urn:oasis:names:tc:entity:xmlns:xml:catalog", 0);
        if (v7)
        {
          int v8 = v7;
          xmlNodePtr v9 = xmlNewDocNode((xmlDocPtr)v5, v7, (const xmlChar *)"catalog", 0);
          if (v9)
          {
            int v10 = v9;
            v9->nsDef = v8;
            xmlAddChild(v5, v9);
            xmlDumpXMLCatalogNode(v3, v10, (xmlDoc *)v5, v8, 0);
            File = xmlOutputBufferCreateFile(out, 0);
            if (File) {
              xmlSaveFormatFileTo(File, (xmlDocPtr)v5, 0, 1);
            }
          }
          else
          {
            xmlFreeNs(v8);
          }
        }
        xmlFreeDoc((xmlDocPtr)v5);
      }
    }
    else
    {
      uint64_t v12 = (xmlHashTable *)*((void *)catal + 12);
      xmlHashScan(v12, (xmlHashScanner)xmlCatalogDumpEntry, out);
    }
  }
}

uint64_t xmlCatalogDumpEntry(uint64_t result, FILE *__stream)
{
  if (result && __stream)
  {
    uint64_t v3 = result;
    switch(*(_DWORD *)(result + 24))
    {
      case 0xD:
        uint64_t v4 = "SYSTEM ";
        goto LABEL_8;
      case 0xE:
        uint64_t v4 = "PUBLIC ";
        goto LABEL_8;
      case 0xF:
        uint64_t v4 = "ENTITY ";
LABEL_8:
        size_t v5 = 7;
        goto LABEL_20;
      case 0x10:
        fprintf(__stream, "ENTITY %%");
        goto LABEL_21;
      case 0x11:
        uint64_t v4 = "DOCTYPE ";
        goto LABEL_16;
      case 0x12:
        uint64_t v4 = "LINKTYPE ";
        goto LABEL_19;
      case 0x13:
        uint64_t v4 = "NOTATION ";
        goto LABEL_19;
      case 0x14:
        uint64_t v4 = "DELEGATE ";
        goto LABEL_19;
      case 0x15:
        uint64_t v4 = "BASE ";
        size_t v5 = 5;
        goto LABEL_20;
      case 0x16:
        uint64_t v4 = "CATALOG ";
LABEL_16:
        size_t v5 = 8;
        goto LABEL_20;
      case 0x17:
        uint64_t v4 = "DOCUMENT ";
        goto LABEL_19;
      case 0x18:
        uint64_t v4 = "SGMLDECL ";
LABEL_19:
        size_t v5 = 9;
LABEL_20:
        fwrite(v4, v5, 1uLL, __stream);
LABEL_21:
        unsigned int v6 = *(_DWORD *)(v3 + 24);
        if (v6 <= 0x18)
        {
          int v7 = 1 << v6;
          if ((v7 & 0x1F06000) != 0)
          {
            fprintf(__stream, "\"%s\"", *(const char **)(v3 + 32));
          }
          else if ((v7 & 0xF8000) != 0)
          {
            fputs(*(const char **)(v3 + 32), __stream);
          }
        }
        if ((*(_DWORD *)(v3 + 24) - 13) <= 7) {
          fprintf(__stream, " \"%s\"", *(const char **)(v3 + 40));
        }
        xmlAttrPtr result = fputc(10, __stream);
        break;
      default:
        return result;
    }
  }
  return result;
}

int xmlACatalogAdd(xmlCatalogPtr catal, const xmlChar *type, const xmlChar *orig, const xmlChar *replace)
{
  if (!catal) {
    goto LABEL_79;
  }
  if (*(_DWORD *)catal != 1)
  {
    if (xmlStrEqual(type, (const xmlChar *)"SYSTEM"))
    {
      int v12 = 13;
    }
    else if (xmlStrEqual(type, (const xmlChar *)"PUBLIC"))
    {
      int v12 = 14;
    }
    else if (xmlStrEqual(type, (const xmlChar *)"DELEGATE"))
    {
      int v12 = 20;
    }
    else if (xmlStrEqual(type, (const xmlChar *)"ENTITY"))
    {
      int v12 = 15;
    }
    else if (xmlStrEqual(type, (const xmlChar *)"DOCTYPE"))
    {
      int v12 = 17;
    }
    else if (xmlStrEqual(type, (const xmlChar *)"LINKTYPE"))
    {
      int v12 = 18;
    }
    else if (xmlStrEqual(type, (const xmlChar *)"NOTATION"))
    {
      int v12 = 19;
    }
    else if (xmlStrEqual(type, (const xmlChar *)"SGMLDECL"))
    {
      int v12 = 24;
    }
    else if (xmlStrEqual(type, (const xmlChar *)"DOCUMENT"))
    {
      int v12 = 23;
    }
    else if (xmlStrEqual(type, (const xmlChar *)"CATALOG"))
    {
      int v12 = 22;
    }
    else
    {
      if (!xmlStrEqual(type, (const xmlChar *)"BASE"))
      {
LABEL_79:
        LODWORD(v15) = -1;
        return (int)v15;
      }
      int v12 = 21;
    }
    int v13 = xmlNewCatalogEntry(v12, (xmlChar *)orig, replace, 0, 0, 0);
    xmlGenericErrorFunc v14 = (xmlHashTable *)*((void *)catal + 12);
    if (!v14)
    {
      xmlGenericErrorFunc v14 = xmlHashCreate(10);
      *((void *)catal + 12) = v14;
    }
    LODWORD(v15) = xmlHashAddEntry(v14, orig, v13);
    return (int)v15;
  }
  uint64_t v8 = *((void *)catal + 14);
  if (!v8 || (*(_DWORD *)(v8 + 24) - 1) > 1) {
    goto LABEL_79;
  }
  xmlNodePtr v9 = (uint64_t *)(v8 + 16);
  uint64_t v10 = *(void *)(v8 + 16);
  if (!v10)
  {
    xmlFetchXMLCatalogFile(v8);
    uint64_t v10 = *(void *)(v8 + 16);
  }
  if (xmlStrEqual(type, (const xmlChar *)"system"))
  {
    int v11 = 6;
    goto LABEL_54;
  }
  if (xmlStrEqual(type, (const xmlChar *)"public"))
  {
    int v11 = 5;
    goto LABEL_54;
  }
  if (xmlStrEqual(type, (const xmlChar *)"rewriteSystem"))
  {
    int v11 = 7;
    goto LABEL_54;
  }
  if (xmlStrEqual(type, (const xmlChar *)"delegatePublic"))
  {
    int v11 = 8;
    goto LABEL_54;
  }
  if (xmlStrEqual(type, (const xmlChar *)"delegateSystem"))
  {
    int v11 = 9;
    goto LABEL_54;
  }
  if (xmlStrEqual(type, (const xmlChar *)"uri"))
  {
    int v11 = 10;
    goto LABEL_54;
  }
  if (xmlStrEqual(type, (const xmlChar *)"rewriteURI"))
  {
    int v11 = 11;
    goto LABEL_54;
  }
  if (xmlStrEqual(type, (const xmlChar *)"delegateURI"))
  {
    int v11 = 12;
    goto LABEL_54;
  }
  if (xmlStrEqual(type, (const xmlChar *)"nextCatalog"))
  {
    int v11 = 3;
    goto LABEL_54;
  }
  if (!xmlStrEqual(type, (const xmlChar *)"catalog"))
  {
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v28 = *__xmlGenericError();
      xmlGenericErrorFunc v29 = __xmlGenericErrorContext();
      v28(*v29, "Failed to add unknown element %s to catalog\n", (const char *)type);
    }
    goto LABEL_79;
  }
  int v11 = 1;
LABEL_54:
  uint64_t v16 = *v9;
  if (*v9)
  {
    while (1)
    {
      int v17 = (void *)v16;
      if (orig)
      {
        if (*(_DWORD *)(v16 + 24) == v11 && xmlStrEqual(orig, *(const xmlChar **)(v16 + 32))) {
          break;
        }
      }
      uint64_t v16 = *v17;
      if (!*v17) {
        goto LABEL_61;
      }
    }
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v23 = *__xmlGenericError();
      int v24 = __xmlGenericErrorContext();
      v23(*v24, "Updating element %s to catalog\n", (const char *)type);
    }
    uint64_t v25 = (void *)v17[5];
    if (v25) {
      xmlFree(v25);
    }
    uint64_t v26 = (void *)v17[6];
    if (v26) {
      xmlFree(v26);
    }
    v17[5] = xmlStrdup(replace);
    xmlGenericErrorFunc v27 = xmlStrdup(replace);
    LODWORD(v15) = 0;
    v17[6] = v27;
  }
  else
  {
    int v17 = 0;
LABEL_61:
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v18 = *__xmlGenericError();
      uint64_t v19 = __xmlGenericErrorContext();
      v18(*v19, "Adding element %s to catalog\n", (const char *)type);
    }
    int v20 = xmlNewCatalogEntry(v11, (xmlChar *)orig, replace, 0, *(_DWORD *)(v8 + 56), 0);
    if (v17) {
      char v21 = v17;
    }
    else {
      char v21 = (void *)(v8 + 16);
    }
    void *v21 = v20;
    if (v10)
    {
      LODWORD(v15) = 0;
    }
    else
    {
      *(_DWORD *)(v8 + 24) = 1;
      uint64_t v15 = xmlHashLookup((xmlHashTablePtr)xmlCatalogXMLFiles, *(const xmlChar **)(v8 + 48));
      if (v15)
      {
        long long v22 = v15;
        LODWORD(v15) = 0;
        v22[2] = *v9;
      }
    }
  }
  return (int)v15;
}

int xmlACatalogRemove(xmlCatalogPtr catal, const xmlChar *value)
{
  int result = -1;
  if (catal && value)
  {
    if (*(_DWORD *)catal == 1)
    {
      uint64_t v5 = *((void *)catal + 14);
      if (v5 && (*(_DWORD *)(v5 + 24) - 1) <= 1)
      {
        unsigned int v6 = *(uint64_t **)(v5 + 16);
        if (v6 || (xmlFetchXMLCatalogFile(v5), (unsigned int v6 = *(uint64_t **)(v5 + 16)) != 0))
        {
          do
          {
            int v7 = (const xmlChar *)v6[4];
            if (v7 && xmlStrEqual(value, v7) || xmlStrEqual(value, (const xmlChar *)v6[5]))
            {
              if (xmlDebugCatalogs)
              {
                uint64_t v8 = v6[4];
                xmlGenericErrorFunc v9 = *__xmlGenericError();
                uint64_t v10 = *__xmlGenericErrorContext();
                if (v8) {
                  uint64_t v11 = 4;
                }
                else {
                  uint64_t v11 = 5;
                }
                v9(v10, "Removing element %s from catalog\n", (const char *)v6[v11]);
              }
              *((_DWORD *)v6 + 6) = -1;
            }
            unsigned int v6 = (uint64_t *)*v6;
          }
          while (v6);
        }
        return 0;
      }
    }
    else
    {
      int result = xmlHashRemoveEntry(*((xmlHashTablePtr *)catal + 12), value, (xmlHashDeallocator)xmlFreeCatalogEntry);
      if (result <= 1) {
        return 1;
      }
    }
  }
  return result;
}

xmlCatalogPtr xmlNewCatalog(int sgml)
{
  int v1 = xmlCatalogDefaultPrefer;
  if (sgml)
  {
    NewCatalog = (xmlCatalog *)xmlCreateNewCatalog(2, xmlCatalogDefaultPrefer);
    uint64_t v3 = NewCatalog;
    if (NewCatalog)
    {
      if (!*((void *)NewCatalog + 12)) {
        *((void *)NewCatalog + 12) = xmlHashCreate(10);
      }
    }
    return v3;
  }
  else
  {
    return (xmlCatalogPtr)xmlCreateNewCatalog(1, v1);
  }
}

int xmlCatalogIsEmpty(xmlCatalogPtr catal)
{
  if (!catal) {
    return -1;
  }
  if (*(_DWORD *)catal == 1)
  {
    uint64_t v1 = *((void *)catal + 14);
    if (v1)
    {
      if ((*(_DWORD *)(v1 + 24) - 1) > 1) {
        return -1;
      }
      else {
        return *(void *)(v1 + 16) == 0;
      }
    }
    return 1;
  }
  uint64_t v3 = (xmlHashTable *)*((void *)catal + 12);
  if (!v3) {
    return 1;
  }
  int v4 = xmlHashSize(v3);
  if (v4) {
    return v4 >> 31;
  }
  else {
    return 1;
  }
}

void xmlInitializeCatalog(void)
{
  uint64_t v0 = (xmlRMutex *)xmlCatalogMutex;
  if (!xmlCatalogMutex)
  {
    pthread_once(&once_control, (void (*)(void))_xmlInitializeCatalogData);
    uint64_t v0 = (xmlRMutex *)xmlCatalogMutex;
  }
  xmlRMutexLock(v0);
  if (getenv("XML_DEBUG_CATALOG")) {
    xmlDebugCatalogs = 1;
  }
  if (!xmlDefaultCatalog)
  {
    uint64_t v1 = getenv("XML_CATALOG_FILES");
    NewCatalog = xmlCreateNewCatalog(1, xmlCatalogDefaultPrefer);
    if (NewCatalog)
    {
      uint64_t v3 = (uint64_t)NewCatalog;
      if (!v1) {
        uint64_t v1 = "file:///etc/xml/catalog";
      }
      unsigned int v4 = *v1;
      if (*v1)
      {
        uint64_t v5 = NewCatalog + 7;
        do
        {
          unsigned int v6 = v1;
          while (v4 <= 0x20)
          {
            if (((1 << v4) & 0x100002600) == 0)
            {
              if (!v4) {
                goto LABEL_24;
              }
              break;
            }
            unsigned int v7 = *++v1;
            unsigned int v4 = v7;
            ++v6;
          }
          uint64_t v8 = 0;
          while (v4 > 0x20 || ((1 << v4) & 0x100002601) == 0)
            unsigned int v4 = v1[++v8];
          xmlGenericErrorFunc v9 = xmlStrndup((const xmlChar *)v1, v8);
          v1 += v8;
          if (v9)
          {
            uint64_t v10 = v9;
            uint64_t v11 = xmlNewCatalogEntry(1, 0, 0, v9, xmlCatalogDefaultPrefer, 0);
            *uint64_t v5 = v11;
            if (v11) {
              uint64_t v5 = v11;
            }
            xmlFree(v10);
          }
LABEL_24:
          unsigned int v4 = *v1;
        }
        while (*v1);
      }
      xmlDefaultCatalog = v3;
    }
  }
  int v12 = (xmlRMutex *)xmlCatalogMutex;

  xmlRMutexUnlock(v12);
}

int xmlLoadCatalog(const char *filename)
{
  int v2 = (xmlRMutex *)xmlCatalogMutex;
  if (!xmlCatalogMutex)
  {
    pthread_once(&once_control, (void (*)(void))_xmlInitializeCatalogData);
    int v2 = (xmlRMutex *)xmlCatalogMutex;
  }
  xmlRMutexLock(v2);
  if (xmlDefaultCatalog)
  {
    int v3 = xmlExpandCatalog(xmlDefaultCatalog, (char *)filename);
  }
  else
  {
    xmlCatalogPtr ACatalog = xmlLoadACatalog(filename);
    if (ACatalog)
    {
      int v3 = 0;
      xmlDefaultCatalog = (uint64_t)ACatalog;
    }
    else
    {
      int v3 = -1;
    }
  }
  xmlRMutexUnlock((xmlRMutexPtr)xmlCatalogMutex);
  return v3;
}

uint64_t xmlExpandCatalog(uint64_t a1, char *a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 == 2)
  {
    FileContent = xmlLoadFileContent(a2);
    if (FileContent)
    {
      uint64_t v5 = FileContent;
      int v6 = xmlParseSGMLCatalog(a1, (int)FileContent, (xmlChar *)a2);
      xmlFree(v5);
      return (v6 >> 31);
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    uint64_t v8 = xmlNewCatalogEntry(1, 0, 0, (xmlChar *)a2, xmlCatalogDefaultPrefer, 0);
    xmlGenericErrorFunc v9 = *(void **)(a1 + 112);
    if (v9)
    {
      do
      {
        uint64_t v10 = v9;
        xmlGenericErrorFunc v9 = (void *)*v9;
      }
      while (v9);
      uint64_t result = 0;
      *uint64_t v10 = v8;
    }
    else
    {
      uint64_t result = 0;
      *(void *)(a1 + 112) = v8;
    }
  }
  return result;
}

void xmlLoadCatalogs(const char *paths)
{
  if (paths)
  {
    uint64_t v1 = paths;
    unsigned int v2 = *(unsigned __int8 *)paths;
    if (*paths)
    {
      while (v2 <= 0x20)
      {
        if (((1 << v2) & 0x100002600) != 0)
        {
          unsigned int v3 = *(unsigned __int8 *)++v1;
          unsigned int v2 = v3;
        }
        else
        {
          if (v2) {
            break;
          }
LABEL_13:
          --v1;
          do
          {
            unsigned int v7 = *(unsigned __int8 *)++v1;
            unsigned int v2 = v7;
          }
          while (v7 == 58);
          if (!v2) {
            return;
          }
        }
      }
      uint64_t v4 = 0;
      while (v2 > 0x3A || ((1 << v2) & 0x400000100002601) == 0)
        unsigned int v2 = v1[++v4];
      uint64_t v5 = xmlStrndup((const xmlChar *)v1, v4);
      v1 += v4;
      if (v5)
      {
        int v6 = v5;
        xmlLoadCatalog((const char *)v5);
        xmlFree(v6);
      }
      goto LABEL_13;
    }
  }
}

void xmlCatalogCleanup(void)
{
  if (xmlCatalogMutex)
  {
    xmlRMutexLock((xmlRMutexPtr)xmlCatalogMutex);
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v0 = *__xmlGenericError();
      uint64_t v1 = __xmlGenericErrorContext();
      v0(*v1, "Catalogs cleanup\n");
    }
    if (xmlCatalogXMLFiles) {
      xmlHashFree((xmlHashTablePtr)xmlCatalogXMLFiles, (xmlHashDeallocator)xmlFreeCatalogHashEntryList);
    }
    xmlCatalogXMLFiles = 0;
    if (xmlDefaultCatalog) {
      xmlFreeCatalog((xmlCatalogPtr)xmlDefaultCatalog);
    }
    xmlDefaultCatalog = 0;
    xmlDebugCatalogs = 0;
    unsigned int v2 = (xmlRMutex *)xmlCatalogMutex;
    xmlRMutexUnlock(v2);
  }
}

uint64_t xmlFreeCatalogHashEntryList(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)(result + 16);
    if (v2)
    {
      do
      {
        uint64_t v3 = *(void *)v2;
        *(_DWORD *)(v2 + 60) = 0;
        *(void *)(v2 + 16) = 0;
        xmlFreeCatalogEntry(v2);
        uint64_t v2 = v3;
      }
      while (v3);
    }
    *(_DWORD *)(v1 + 60) = 0;
    return xmlFreeCatalogEntry(v1);
  }
  return result;
}

xmlChar *__cdecl xmlCatalogResolveSystem(const xmlChar *sysID)
{
  if (!xmlCatalogMutex) {
    xmlInitializeCatalog();
  }
  uint64_t v2 = (xmlCatalog *)xmlDefaultCatalog;

  return xmlACatalogResolveSystem(v2, sysID);
}

xmlChar *__cdecl xmlCatalogResolvePublic(const xmlChar *pubID)
{
  if (!xmlCatalogMutex) {
    xmlInitializeCatalog();
  }
  uint64_t v2 = (xmlCatalog *)xmlDefaultCatalog;

  return xmlACatalogResolvePublic(v2, pubID);
}

xmlChar *__cdecl xmlCatalogResolve(const xmlChar *pubID, const xmlChar *sysID)
{
  if (!xmlCatalogMutex) {
    xmlInitializeCatalog();
  }
  uint64_t v4 = (xmlCatalog *)xmlDefaultCatalog;

  return xmlACatalogResolve(v4, pubID, sysID);
}

xmlChar *__cdecl xmlCatalogResolveURI(const xmlChar *URI)
{
  if (!xmlCatalogMutex) {
    xmlInitializeCatalog();
  }
  uint64_t v2 = (xmlCatalog *)xmlDefaultCatalog;

  return xmlACatalogResolveURI(v2, URI);
}

void xmlCatalogDump(FILE *out)
{
  if (out)
  {
    if (!xmlCatalogMutex) {
      xmlInitializeCatalog();
    }
    uint64_t v2 = (xmlCatalog *)xmlDefaultCatalog;
    xmlACatalogDump(v2, out);
  }
}

int xmlCatalogAdd(const xmlChar *type, const xmlChar *orig, const xmlChar *replace)
{
  int v6 = (xmlRMutex *)xmlCatalogMutex;
  if (!xmlCatalogMutex)
  {
    pthread_once(&once_control, (void (*)(void))_xmlInitializeCatalogData);
    int v6 = (xmlRMutex *)xmlCatalogMutex;
  }
  xmlRMutexLock(v6);
  unsigned int v7 = (xmlCatalog *)xmlDefaultCatalog;
  if (xmlDefaultCatalog) {
    goto LABEL_4;
  }
  if (!xmlStrEqual(type, (const xmlChar *)"catalog"))
  {
    unsigned int v7 = (xmlCatalog *)xmlDefaultCatalog;
LABEL_4:
    int v8 = xmlACatalogAdd(v7, type, orig, replace);
    goto LABEL_5;
  }
  xmlDefaultCatalog = (uint64_t)xmlCreateNewCatalog(1, xmlCatalogDefaultPrefer);
  if (xmlDefaultCatalog)
  {
    uint64_t v10 = xmlNewCatalogEntry(1, 0, orig, 0, xmlCatalogDefaultPrefer, 0);
    int v8 = 0;
    *(void *)(xmlDefaultCatalog + 112) = v10;
  }
  else
  {
    int v8 = 0;
  }
LABEL_5:
  xmlRMutexUnlock((xmlRMutexPtr)xmlCatalogMutex);
  return v8;
}

int xmlCatalogRemove(const xmlChar *value)
{
  uint64_t v2 = (xmlRMutex *)xmlCatalogMutex;
  if (!xmlCatalogMutex)
  {
    xmlInitializeCatalog();
    uint64_t v2 = (xmlRMutex *)xmlCatalogMutex;
  }
  xmlRMutexLock(v2);
  int v3 = xmlACatalogRemove((xmlCatalogPtr)xmlDefaultCatalog, value);
  xmlRMutexUnlock((xmlRMutexPtr)xmlCatalogMutex);
  return v3;
}

int xmlCatalogConvert(void)
{
  xmlGenericErrorFunc v0 = (xmlRMutex *)xmlCatalogMutex;
  if (!xmlCatalogMutex)
  {
    xmlInitializeCatalog();
    xmlGenericErrorFunc v0 = (xmlRMutex *)xmlCatalogMutex;
  }
  xmlRMutexLock(v0);
  int v1 = xmlConvertSGMLCatalog((xmlCatalogPtr)xmlDefaultCatalog);
  xmlRMutexUnlock((xmlRMutexPtr)xmlCatalogMutex);
  return v1;
}

xmlCatalogAllow xmlCatalogGetDefaults(void)
{
  return xmlCatalogDefaultAllow;
}

void xmlCatalogSetDefaults(xmlCatalogAllow allow)
{
  if (xmlDebugCatalogs) {
    BOOL v2 = allow > XML_CATA_ALLOW_ALL;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2)
  {
    int v3 = (&off_1E60C7018)[allow];
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    uint64_t v5 = __xmlGenericErrorContext();
    v4(*v5, v3);
  }
  xmlCatalogDefaultAllow = allow;
}

xmlCatalogPrefer xmlCatalogSetDefaultPrefer(xmlCatalogPrefer prefer)
{
  xmlCatalogPrefer v1 = xmlCatalogDefaultPrefer;
  if (prefer)
  {
    if (!xmlDebugCatalogs)
    {
LABEL_8:
      xmlCatalogDefaultPrefer = prefer;
      return v1;
    }
    if (prefer == XML_CATA_PREFER_PUBLIC)
    {
      int v3 = "Setting catalog preference to PUBLIC\n";
      goto LABEL_7;
    }
    if (prefer == XML_CATA_PREFER_SYSTEM)
    {
      int v3 = "Setting catalog preference to SYSTEM\n";
LABEL_7:
      xmlGenericErrorFunc v4 = *__xmlGenericError();
      uint64_t v5 = __xmlGenericErrorContext();
      v4(*v5, v3);
      goto LABEL_8;
    }
  }
  return v1;
}

int xmlCatalogSetDebug(int level)
{
  int v1 = xmlDebugCatalogs;
  xmlDebugCatalogs = level & ~(level >> 31);
  return v1;
}

void xmlCatalogFreeLocal(void *catalogs)
{
  int v1 = catalogs;
  if (xmlCatalogMutex)
  {
    if (!catalogs) {
      return;
    }
  }
  else
  {
    xmlInitializeCatalog();
    if (!v1) {
      return;
    }
  }
  do
  {
    BOOL v2 = (void *)*v1;
    xmlFreeCatalogEntry((uint64_t)v1);
    int v1 = v2;
  }
  while (v2);
}

void *__cdecl xmlCatalogAddLocal(void *catalogs, const xmlChar *URL)
{
  if (!xmlCatalogMutex) {
    xmlInitializeCatalog();
  }
  if (URL)
  {
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v4 = *__xmlGenericError();
      uint64_t v5 = __xmlGenericErrorContext();
      v4(*v5, "Adding document catalog %s\n", (const char *)URL);
    }
    int v6 = xmlNewCatalogEntry(1, 0, URL, 0, xmlCatalogDefaultPrefer, 0);
    if (v6)
    {
      if (catalogs)
      {
        unsigned int v7 = catalogs;
        do
        {
          int v8 = v7;
          unsigned int v7 = (void *)*v7;
        }
        while (v7);
        *int v8 = v6;
      }
      else
      {
        return v6;
      }
    }
  }
  return catalogs;
}

xmlChar *__cdecl xmlCatalogLocalResolve(void *catalogs, const xmlChar *pubID, const xmlChar *sysID)
{
  if (!xmlCatalogMutex) {
    xmlInitializeCatalog();
  }
  if (!((unint64_t)pubID | (unint64_t)sysID)) {
    return 0;
  }
  if (xmlDebugCatalogs)
  {
    xmlGenericErrorFunc v6 = *__xmlGenericError();
    unsigned int v7 = *__xmlGenericErrorContext();
    if (pubID && sysID)
    {
      int v8 = "Local Resolve: pubID %s sysID %s\n";
    }
    else if (pubID)
    {
      int v8 = "Local Resolve: pubID %s\n";
    }
    else
    {
      int v8 = "Local Resolve: sysID %s\n";
    }
    v6(v7, v8);
  }
  if (!catalogs) {
    return 0;
  }
  uint64_t result = (xmlChar *)xmlCatalogListXMLResolve((uint64_t)catalogs, (xmlChar *)pubID, (uint64_t)sysID);
  if ((unint64_t)(result + 1) <= 1) {
    return 0;
  }
  return result;
}

xmlChar *__cdecl xmlCatalogLocalResolveURI(void *catalogs, const xmlChar *URI)
{
  if (xmlCatalogMutex)
  {
    if (!URI) {
      return 0;
    }
  }
  else
  {
    xmlInitializeCatalog();
    if (!URI) {
      return 0;
    }
  }
  if (xmlDebugCatalogs)
  {
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    uint64_t v5 = __xmlGenericErrorContext();
    v4(*v5, "Resolve URI %s\n", (const char *)URI);
  }
  if (!catalogs) {
    return 0;
  }
  uint64_t result = (xmlChar *)xmlCatalogListXMLResolveURI((uint64_t)catalogs, (const char *)URI);
  if ((unint64_t)(result + 1) <= 1) {
    return 0;
  }
  return result;
}

const xmlChar *__cdecl xmlCatalogGetSystem(const xmlChar *sysID)
{
  if (!xmlCatalogMutex) {
    xmlInitializeCatalog();
  }
  if (!xmlCatalogGetSystem_msg)
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    int v3 = __xmlGenericErrorContext();
    v2(*v3, "Use of deprecated xmlCatalogGetSystem() call\n");
    ++xmlCatalogGetSystem_msg;
  }
  if (sysID)
  {
    if (!xmlDefaultCatalog) {
      return 0;
    }
    xmlGenericErrorFunc v4 = (const char *)xmlCatalogListXMLResolve(*(void *)(xmlDefaultCatalog + 112), 0, (uint64_t)sysID);
    if ((unint64_t)(v4 + 1) >= 2)
    {
      sysID = (const xmlChar *)xmlCatalogGetSystem_result;
      snprintf(xmlCatalogGetSystem_result, 0x3E7uLL, "%s", v4);
      byte_1E9D46EE7 = 0;
      return sysID;
    }
    if (xmlDefaultCatalog
      && (uint64_t v5 = *(xmlHashTable **)(xmlDefaultCatalog + 96)) != 0
      && (xmlGenericErrorFunc v6 = xmlHashLookup(v5, sysID)) != 0
      && *((_DWORD *)v6 + 6) == 13)
    {
      return (const xmlChar *)*((void *)v6 + 6);
    }
    else
    {
      return 0;
    }
  }
  return sysID;
}

const xmlChar *__cdecl xmlCatalogGetPublic(const xmlChar *pubID)
{
  if (!xmlCatalogMutex) {
    xmlInitializeCatalog();
  }
  if (xmlCatalogGetPublic_msg)
  {
    if (!pubID) {
      return pubID;
    }
  }
  else
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    int v3 = __xmlGenericErrorContext();
    v2(*v3, "Use of deprecated xmlCatalogGetPublic() call\n");
    ++xmlCatalogGetPublic_msg;
    if (!pubID) {
      return pubID;
    }
  }
  if (!xmlDefaultCatalog) {
    return 0;
  }
  xmlGenericErrorFunc v4 = (const char *)xmlCatalogListXMLResolve(*(void *)(xmlDefaultCatalog + 112), (xmlChar *)pubID, 0);
  if ((unint64_t)(v4 + 1) >= 2)
  {
    pubID = (const xmlChar *)xmlCatalogGetPublic_result;
    snprintf(xmlCatalogGetPublic_result, 0x3E7uLL, "%s", v4);
    byte_1E9D472D3 = 0;
    return pubID;
  }
  if (!xmlDefaultCatalog) {
    return 0;
  }
  uint64_t v5 = *(xmlHashTable **)(xmlDefaultCatalog + 96);

  return (const xmlChar *)xmlCatalogGetSGMLPublic(v5, (xmlChar *)pubID);
}

_DWORD *xmlCatalogErrMemory(const xmlChar *a1)
{
  return __xmlRaiseError(0, 0, 0, 0, 0, 0x14u, 2, 2, 0, 0, a1, 0, 0, 0, 0, "Memory allocation failed : %s\n", (char)a1);
}

unsigned __int8 *xmlParseSGMLCatalogName(unsigned __int8 *a1, xmlChar **a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  *a2 = 0;
  unsigned __int8 v3 = *a1;
  if ((*a1 + 40) >= 0x1Fu
    && (*a1 + 64) >= 0x17u
    && ((*a1 & 0xDF) - 65) >= 0x1Au)
  {
    int v6 = *a1;
    if ((v6 - 248) >= 8 && v6 != 95 && v6 != 58) {
      return 0;
    }
  }
  uint64_t v7 = 0;
  memset(v10, 0, 105);
  while (1)
  {
    BOOL v8 = (v3 & 0xDFu) - 65 >= 0x1A && v3 - 192 >= 0x17;
    if (v8
      && v3 <= 0xF7u
      && v3 - 216 >= 0x1F
      && v3 - 48 >= 0xA
      && v3 - 45 >= 2
      && v3 != 95
      && v3 != 58)
    {
      break;
    }
    *((unsigned char *)v10 + v7) = v3;
    unsigned __int8 v3 = a1[++v7];
    if (v7 == 100) {
      return 0;
    }
  }
  *a2 = xmlStrndup((const xmlChar *)v10, v7);
  return &a1[v7];
}

unsigned __int8 *xmlParseSGMLCatalogPubid(unsigned __int8 *a1, void *a2)
{
  xmlGenericErrorFunc v2 = a2;
  *a2 = 0;
  int v3 = *a1;
  if (v3 == 34) {
    xmlGenericErrorFunc v4 = a1 + 1;
  }
  else {
    xmlGenericErrorFunc v4 = a1;
  }
  if (v3 == 34) {
    int v5 = 34;
  }
  else {
    int v5 = 32;
  }
  if (v3 == 39) {
    int v6 = a1 + 1;
  }
  else {
    int v6 = v4;
  }
  BOOL v7 = v3 != 39 && v3 != 34;
  BOOL v8 = v3 == 39 || v3 == 34;
  if (v3 == 39) {
    int v9 = 39;
  }
  else {
    int v9 = v5;
  }
  uint64_t v10 = xmlMallocAtomic(0x32uLL);
  if (!v10)
  {
    xmlCatalogErrMemory((const xmlChar *)"allocating public ID");
    return 0;
  }
  uint64_t v11 = v10;
  uint64_t v12 = 0;
  unsigned int v13 = *v6;
  BOOL v14 = v9 == v13 && v8;
  if (xmlIsPubidChar_tab[*v6]) {
    BOOL v15 = 1;
  }
  else {
    BOOL v15 = v13 == 63;
  }
  if (v15 && !v14)
  {
    xmlGenericErrorFunc v27 = v2;
    uint64_t v16 = 0;
    int v17 = 50;
    while (1)
    {
      if (v7 && v13 <= 0x20 && ((1 << v13) & 0x100002600) != 0)
      {
        v11[v16] = 0;
        v6 += v16;
        xmlGenericErrorFunc v2 = v27;
        goto LABEL_51;
      }
      uint64_t v18 = v16 + 1;
      if (v17 <= (int)v16 + 1)
      {
        v17 *= 2;
        uint64_t v19 = xmlRealloc(v11, v17);
        if (!v19)
        {
          xmlCatalogErrMemory((const xmlChar *)"allocating public ID");
          goto LABEL_57;
        }
        LOBYTE(v1xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = v6[v16];
        uint64_t v11 = v19;
      }
      v11[v16] = v13;
      unsigned int v13 = v6[v16 + 1];
      BOOL v20 = v9 == v13 && v8;
      if (xmlIsPubidChar_tab[v6[v16 + 1]]) {
        BOOL v21 = 1;
      }
      else {
        BOOL v21 = v13 == 63;
      }
      if (v21)
      {
        ++v16;
        if (!v20) {
          continue;
        }
      }
      uint64_t v12 = v18;
      v6 += v18;
      xmlGenericErrorFunc v2 = v27;
      break;
    }
  }
  v11[v12] = 0;
  if (!v7)
  {
    if (v9 != *v6) {
      goto LABEL_57;
    }
    ++v6;
    goto LABEL_55;
  }
LABEL_51:
  unsigned int v22 = *v6;
  BOOL v23 = v22 > 0x20;
  uint64_t v24 = (1 << v22) & 0x100002600;
  if (v23 || v24 == 0)
  {
LABEL_57:
    xmlFree(v11);
    return 0;
  }
LABEL_55:
  *xmlGenericErrorFunc v2 = v11;
  return v6;
}

xmlChar *xmlCatalogNormalizePublic(xmlChar *cur)
{
  if (cur)
  {
    int v1 = cur;
    unsigned int v2 = *cur;
    if (*cur)
    {
      int v3 = cur + 1;
      int v4 = 1;
      do
      {
        uint64_t v5 = 1 << v2;
        BOOL v6 = v2 == 32 && v4 == 0;
        if (v2 == 32 && v4 == 0) {
          int v4 = 1;
        }
        BOOL v7 = (v5 & 0x100002600) == 0;
        int v8 = (v5 & 0x100002600) == 0 || v6;
        if (v7) {
          int v4 = 0;
        }
        if (v2 > 0x20)
        {
          int v8 = 1;
          int v4 = 0;
        }
        if (!v8) {
          break;
        }
        unsigned int v9 = *v3++;
        unsigned int v2 = v9;
      }
      while (v9);
      if (v8 && !v4) {
        return 0;
      }
    }
    cur = xmlStrdup(cur);
    int v10 = 0;
    uint64_t v11 = cur;
    while (1)
    {
      unsigned int v12 = *v1;
      if (v12 <= 0x20)
      {
        if (((1 << v12) & 0x100002600) != 0)
        {
          if (v11 != cur) {
            int v10 = 1;
          }
          goto LABEL_24;
        }
        if (!*v1)
        {
          xmlChar *v11 = 0;
          return cur;
        }
      }
      if (v10)
      {
        *v11++ = 32;
        LOBYTE(v12) = *v1;
      }
      int v10 = 0;
      *v11++ = v12;
LABEL_24:
      ++v1;
    }
  }
  return cur;
}

xmlChar *xmlCatalogUnWrapURN(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (xmlStrncmp((const xmlChar *)a1, (const xmlChar *)"urn:publicid:", 13)) {
    return 0;
  }
  bzero(cur, 0x7D0uLL);
  int v5 = *(unsigned __int8 *)(a1 + 13);
  int v4 = (unsigned __int8 *)(a1 + 13);
  int v3 = v5;
  if (v5)
  {
    uint64_t v6 = 0;
    LODWORD(v7) = 0;
    while (1)
    {
      if (v3 > 57)
      {
        if (v3 == 58)
        {
          uint64_t v7 = v7 + 1;
          cur[v6] = 47;
          cur[v7] = 47;
          goto LABEL_21;
        }
        if (v3 == 59)
        {
          uint64_t v7 = v7 + 1;
          cur[v6] = 58;
          cur[v7] = 58;
          ++v4;
          goto LABEL_22;
        }
LABEL_20:
        cur[v6] = v3;
        goto LABEL_21;
      }
      if (v3 != 37)
      {
        if (v3 == 43)
        {
          cur[v6] = 32;
LABEL_21:
          ++v4;
          goto LABEL_22;
        }
        goto LABEL_20;
      }
      int v8 = v4[1];
      if (v8 == 51)
      {
        int v12 = v4[2];
        switch(v12)
        {
          case 'A':
            xmlChar v10 = 58;
            break;
          case 'B':
            xmlChar v10 = 59;
            break;
          case 'F':
            xmlChar v10 = 63;
            break;
          default:
            goto LABEL_33;
        }
      }
      else
      {
        if (v8 != 50) {
          goto LABEL_33;
        }
        unsigned int v9 = v4[2];
        if (v9 <= 0x36)
        {
          if (v9 == 51)
          {
            xmlChar v10 = 35;
          }
          else
          {
            if (v9 != 53)
            {
LABEL_33:
              cur[v6] = 37;
              ++v4;
              goto LABEL_22;
            }
            xmlChar v10 = 37;
          }
        }
        else
        {
          switch(v9)
          {
            case '7':
              xmlChar v10 = 39;
              break;
            case 'B':
              xmlChar v10 = 43;
              break;
            case 'F':
              xmlChar v10 = 47;
              break;
            default:
              goto LABEL_33;
          }
        }
      }
      cur[v6] = v10;
      v4 += 3;
LABEL_22:
      uint64_t v6 = (v7 + 1);
      int v3 = *v4;
      if (*v4)
      {
        BOOL v11 = v7 > 0x7CB;
        LODWORD(v7) = v7 + 1;
        if (!v11) {
          continue;
        }
      }
      goto LABEL_41;
    }
  }
  uint64_t v6 = 0;
LABEL_41:
  cur[v6] = 0;
  return xmlStrdup(cur);
}

void xmlFetchXMLCatalogFile(uint64_t a1)
{
  if (!*(void *)(a1 + 48)) {
    return;
  }
  xmlRMutexLock((xmlRMutexPtr)xmlCatalogMutex);
  if (!*(void *)(a1 + 16))
  {
    if (xmlCatalogXMLFiles)
    {
      unsigned int v2 = xmlHashLookup((xmlHashTablePtr)xmlCatalogXMLFiles, *(const xmlChar **)(a1 + 48));
      if (v2)
      {
        int v3 = v2;
        if (xmlDebugCatalogs)
        {
          xmlGenericErrorFunc v4 = *__xmlGenericError();
          int v5 = __xmlGenericErrorContext();
          v4(*v5, "Found %s in file hash\n", *(const char **)(a1 + 48));
        }
        if (*(_DWORD *)(a1 + 24) == 1) {
          int v3 = (void *)v3[2];
        }
        *(void *)(a1 + 16) = v3;
        *(_DWORD *)(a1 + 60) = 0;
        goto LABEL_31;
      }
      if (xmlDebugCatalogs)
      {
        xmlGenericErrorFunc v6 = *__xmlGenericError();
        uint64_t v7 = __xmlGenericErrorContext();
        v6(*v7, "%s not found in file hash\n", *(const char **)(a1 + 48));
      }
    }
    int v8 = *(const char **)(a1 + 48);
    if (v8)
    {
      uint64_t v9 = *(unsigned int *)(a1 + 56);
      xmlDocPtr v10 = xmlParseCatalogFile(*(const char **)(a1 + 48));
      if (v10)
      {
        BOOL v11 = v10;
        if (xmlDebugCatalogs)
        {
          xmlGenericErrorFunc v12 = *__xmlGenericError();
          unsigned int v13 = *__xmlGenericErrorContext();
          int ThreadId = xmlGetThreadId();
          v12(v13, "%d Parsing catalog %s\n", ThreadId, v8);
        }
        xmlNodePtr RootElement = xmlDocGetRootElement(v11);
        if (RootElement
          && (uint64_t v16 = RootElement, xmlStrEqual(RootElement->name, (const xmlChar *)"catalog"))
          && (xmlNsPtr ns = v16->ns) != 0
          && (href = ns->href) != 0
          && xmlStrEqual(href, (const xmlChar *)"urn:oasis:names:tc:entity:xmlns:xml:catalog"))
        {
          uint64_t v19 = xmlNewCatalogEntry(1, 0, (const xmlChar *)v8, 0, v9, 0);
          if (v19)
          {
            BOOL v20 = v19;
            Prop = xmlGetProp(v16, (const xmlChar *)"prefer");
            if (Prop)
            {
              unsigned int v22 = Prop;
              if (xmlStrEqual(Prop, (const xmlChar *)"system"))
              {
                uint64_t v9 = 2;
              }
              else if (xmlStrEqual(v22, (const xmlChar *)"public"))
              {
                uint64_t v9 = 1;
              }
              else
              {
                xmlCatalogErr(0, (uint64_t)v16, 1652, "Invalid value for prefer: '%s'\n", v22, 0, 0);
              }
              xmlFree(v22);
            }
            xmlParseXMLCatalogNodeList(v16->children, v9, v20, 0);
            xmlFreeDoc(v11);
            uint64_t v26 = v20;
            if (*(_DWORD *)(a1 + 24) == 1) {
              uint64_t v26 = (void *)v20[2];
            }
            *(void *)(a1 + 16) = v26;
            *((_DWORD *)v20 + 15) = 1;
            xmlGenericErrorFunc v27 = (xmlHashTable *)xmlCatalogXMLFiles;
            if (xmlCatalogXMLFiles || (xmlGenericErrorFunc v27 = xmlHashCreate(10), (xmlCatalogXMLFiles = (uint64_t)v27) != 0))
            {
              if (xmlDebugCatalogs)
              {
                xmlGenericErrorFunc v28 = *__xmlGenericError();
                xmlGenericErrorFunc v29 = __xmlGenericErrorContext();
                v28(*v29, "%s added to file hash\n", *(const char **)(a1 + 48));
                xmlGenericErrorFunc v27 = (xmlHashTable *)xmlCatalogXMLFiles;
              }
              xmlHashAddEntry(v27, *(const xmlChar **)(a1 + 48), v20);
            }
            goto LABEL_31;
          }
        }
        else
        {
          __xmlRaiseError(0, 0, 0, 0, (uint64_t)v11, 0x14u, 1653, 2, 0, 0, (const xmlChar *)v8, 0, 0, 0, 0, "File %s is not an XML Catalog\n", (char)v8);
        }
        xmlFreeDoc(v11);
      }
      else if (xmlDebugCatalogs)
      {
        xmlGenericErrorFunc v23 = *__xmlGenericError();
        uint64_t v24 = __xmlGenericErrorContext();
        v23(*v24, "Failed to parse catalog %s\n", v8);
      }
    }
    *(_DWORD *)(a1 + 24) = 2;
  }
LABEL_31:
  uint64_t v25 = (xmlRMutex *)xmlCatalogMutex;

  xmlRMutexUnlock(v25);
}

_DWORD *xmlCatalogErr(void *a1, uint64_t a2, int a3, const char *a4, const xmlChar *a5, xmlChar *a6, xmlChar *a7)
{
  return __xmlRaiseError(0, 0, 0, a1, a2, 0x14u, a3, 2, 0, 0, a5, a6, a7, 0, 0, a4, (char)a5);
}

void xmlParseXMLCatalogNodeList(const xmlNode *a1, uint64_t a2, void *a3, uint64_t a4)
{
  if (a1)
  {
    uint64_t v7 = a1;
    xmlGenericErrorFunc v23 = a3 + 2;
    while (1)
    {
      xmlNsPtr ns = v7->ns;
      if (!ns) {
        goto LABEL_29;
      }
      href = ns->href;
      if (!href || !xmlStrEqual(href, (const xmlChar *)"urn:oasis:names:tc:entity:xmlns:xml:catalog")) {
        goto LABEL_29;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"group"))
      {
        Prop = xmlGetProp(v7, (const xmlChar *)"prefer");
        BOOL v11 = Prop;
        if (Prop)
        {
          if (xmlStrEqual(Prop, (const xmlChar *)"system"))
          {
            uint64_t v12 = 2;
          }
          else if (xmlStrEqual(v11, (const xmlChar *)"public"))
          {
            uint64_t v12 = 1;
          }
          else
          {
            __xmlRaiseError(0, 0, 0, a3, (uint64_t)v7, 0x14u, 1652, 2, 0, 0, v11, 0, 0, 0, 0, "Invalid value for prefer: '%s'\n", (char)v11);
            uint64_t v12 = a2;
          }
          xmlFree(v11);
          LODWORD(v11) = v12;
        }
        else
        {
          uint64_t v12 = a2;
        }
        BOOL v20 = xmlGetProp(v7, (const xmlChar *)"id");
        NsProp = xmlGetNsProp(v7, (const xmlChar *)"base", (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
        uint64_t v18 = xmlNewCatalogEntry(4, v20, NsProp, 0, (int)v11, a4);
        xmlFree(v20);
        if (!v18) {
          goto LABEL_27;
        }
        goto LABEL_23;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"public"))
      {
        unsigned int v13 = (xmlNode *)v7;
        int v14 = 5;
        BOOL v15 = "public";
        uint64_t v16 = "publicId";
        goto LABEL_17;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"system"))
      {
        unsigned int v13 = (xmlNode *)v7;
        int v14 = 6;
        BOOL v15 = "system";
        uint64_t v16 = "systemId";
        goto LABEL_17;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"rewriteSystem"))
      {
        unsigned int v13 = (xmlNode *)v7;
        int v14 = 7;
        BOOL v15 = "rewriteSystem";
        uint64_t v16 = "systemIdStartString";
        goto LABEL_33;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"delegatePublic"))
      {
        unsigned int v13 = (xmlNode *)v7;
        int v14 = 8;
        BOOL v15 = "delegatePublic";
        uint64_t v16 = "publicIdStartString";
        goto LABEL_38;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"delegateSystem"))
      {
        unsigned int v13 = (xmlNode *)v7;
        int v14 = 9;
        BOOL v15 = "delegateSystem";
        uint64_t v16 = "systemIdStartString";
        goto LABEL_38;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"uri"))
      {
        unsigned int v13 = (xmlNode *)v7;
        int v14 = 10;
        BOOL v15 = "uri";
        uint64_t v16 = "name";
LABEL_17:
        int v17 = "uri";
        goto LABEL_18;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"rewriteURI"))
      {
        unsigned int v13 = (xmlNode *)v7;
        int v14 = 11;
        BOOL v15 = "rewriteURI";
        uint64_t v16 = "uriStartString";
LABEL_33:
        int v17 = "rewritePrefix";
LABEL_18:
        uint64_t v18 = xmlParseXMLCatalogOneNode(v13, v14, (const xmlChar *)v15, (xmlChar *)v16, (xmlChar *)v17, a2, a4);
        NsProp = 0;
        uint64_t v12 = a2;
        if (!v18)
        {
LABEL_27:
          if (NsProp) {
            xmlFree(NsProp);
          }
          goto LABEL_29;
        }
LABEL_23:
        v18[1] = a3;
        BOOL v21 = (void *)a3[2];
        for (size_t i = v23; v21; v21 = (void *)*v21)
          size_t i = v21;
        *size_t i = v18;
        if (*((_DWORD *)v18 + 6) == 4) {
          xmlParseXMLCatalogNodeList(v7->children, v12, a3, v18);
        }
        goto LABEL_27;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"delegateURI")) {
        break;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"nextCatalog"))
      {
        unsigned int v13 = (xmlNode *)v7;
        int v14 = 3;
        BOOL v15 = "nextCatalog";
        uint64_t v16 = 0;
        goto LABEL_38;
      }
LABEL_29:
      uint64_t v7 = v7->next;
      if (!v7) {
        return;
      }
    }
    unsigned int v13 = (xmlNode *)v7;
    int v14 = 12;
    BOOL v15 = "delegateURI";
    uint64_t v16 = "uriStartString";
LABEL_38:
    int v17 = "catalog";
    goto LABEL_18;
  }
}

void *xmlParseXMLCatalogOneNode(xmlNode *node, int a2, const xmlChar *a3, xmlChar *name, xmlChar *a5, int a6, uint64_t a7)
{
  if (name)
  {
    Prop = xmlGetProp(node, name);
    if (!Prop)
    {
      __xmlRaiseError(0, 0, 0, 0, (uint64_t)node, 0x14u, 1650, 2, 0, 0, a3, name, 0, 0, 0, "%s entry lacks '%s'\n", (char)a3);
      BOOL v15 = xmlGetProp(node, a5);
      if (v15) {
        ((void (*)(xmlChar *))xmlFree)(v15);
      }
      else {
        __xmlRaiseError(0, 0, 0, 0, (uint64_t)node, 0x14u, 1650, 2, 0, 0, a3, a5, 0, 0, 0, "%s entry lacks '%s'\n", (char)a3);
      }
      return 0;
    }
  }
  else
  {
    Prop = 0;
  }
  uint64_t v16 = xmlGetProp(node, a5);
  if (!v16)
  {
    __xmlRaiseError(0, 0, 0, 0, (uint64_t)node, 0x14u, 1650, 2, 0, 0, a3, a5, 0, 0, 0, "%s entry lacks '%s'\n", (char)a3);
    if (Prop) {
      ((void (*)(xmlChar *))xmlFree)(Prop);
    }
    return 0;
  }
  int v17 = v16;
  Base = xmlNodeGetBase(node->doc, node);
  uint64_t v19 = xmlBuildURI(v17, Base);
  if (v19)
  {
    if (xmlDebugCatalogs >= 2)
    {
      xmlGenericErrorFunc v20 = *__xmlGenericError();
      BOOL v21 = *__xmlGenericErrorContext();
      if (Prop) {
        unsigned int v22 = "Found %s: '%s' '%s'\n";
      }
      else {
        unsigned int v22 = "Found %s: '%s'\n";
      }
      v20(v21, v22);
    }
    xmlGenericErrorFunc v23 = xmlNewCatalogEntry(a2, Prop, v17, v19, a6, a7);
    if (!Prop) {
      goto LABEL_21;
    }
  }
  else
  {
    __xmlRaiseError(0, 0, 0, 0, (uint64_t)node, 0x14u, 1651, 2, 0, 0, a3, a5, v17, 0, 0, "%s entry '%s' broken ?: %s\n", (char)a3);
    xmlGenericErrorFunc v23 = 0;
    if (!Prop) {
      goto LABEL_21;
    }
  }
  xmlFree(Prop);
LABEL_21:
  xmlFree(v17);
  if (Base) {
    xmlFree(Base);
  }
  if (v19) {
    xmlFree(v19);
  }
  return v23;
}

xmlNodePtr xmlDumpXMLCatalogNode(xmlNodePtr result, xmlNode *a2, xmlDoc *a3, xmlNs *a4, xmlNs *a5)
{
  if (result)
  {
    xmlNodePtr v9 = result;
    p_name = &result->name;
    xmlNodePtr v11 = result;
    do
    {
      if (v11->ns == a5)
      {
        switch(LODWORD(v11->children))
        {
          case 1:
          case 2:
            if (v11 == v9) {
              xmlNodePtr v11 = (xmlNodePtr)p_name;
            }
            break;
          case 3:
            unsigned int v22 = xmlNewDocNode(a3, a4, (const xmlChar *)"nextCatalog", 0);
            unsigned int v13 = v22;
            xmlNodePtr parent = (const xmlChar *)v11->parent;
            goto LABEL_22;
          case 4:
            unsigned int v13 = xmlNewDocNode(a3, a4, (const xmlChar *)"group", 0);
            xmlSetProp(v13, (const xmlChar *)"id", (const xmlChar *)v11->last);
            if (v11->parent)
            {
              uint64_t v24 = xmlSearchNsByHref(a3, v13, (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
              if (v24) {
                xmlSetNsProp(v13, v24, (const xmlChar *)"base", (const xmlChar *)v11->parent);
              }
            }
            int prev = (int)v11->prev;
            if (prev == 1)
            {
              uint64_t v26 = "public";
            }
            else
            {
              if (prev != 2) {
                goto LABEL_33;
              }
              uint64_t v26 = "system";
            }
            xmlSetProp(v13, (const xmlChar *)"prefer", (const xmlChar *)v26);
LABEL_33:
            xmlDumpXMLCatalogNode(v11->_private, v13, a3, a4, v11);
LABEL_28:
            uint64_t result = xmlAddChild(a2, v13);
            break;
          case 5:
            uint64_t v12 = xmlNewDocNode(a3, a4, (const xmlChar *)"public", 0);
            unsigned int v13 = v12;
            last = (const xmlChar *)v11->last;
            BOOL v15 = "publicId";
            goto LABEL_24;
          case 6:
            uint64_t v12 = xmlNewDocNode(a3, a4, (const xmlChar *)"system", 0);
            unsigned int v13 = v12;
            last = (const xmlChar *)v11->last;
            BOOL v15 = "systemId";
            goto LABEL_24;
          case 7:
            uint64_t v16 = xmlNewDocNode(a3, a4, (const xmlChar *)"rewriteSystem", 0);
            unsigned int v13 = v16;
            int v17 = (const xmlChar *)v11->last;
            uint64_t v18 = "systemIdStartString";
            goto LABEL_26;
          case 8:
            uint64_t v19 = xmlNewDocNode(a3, a4, (const xmlChar *)"delegatePublic", 0);
            unsigned int v13 = v19;
            xmlGenericErrorFunc v20 = (const xmlChar *)v11->last;
            BOOL v21 = "publicIdStartString";
            goto LABEL_21;
          case 9:
            uint64_t v19 = xmlNewDocNode(a3, a4, (const xmlChar *)"delegateSystem", 0);
            unsigned int v13 = v19;
            xmlGenericErrorFunc v20 = (const xmlChar *)v11->last;
            BOOL v21 = "systemIdStartString";
            goto LABEL_21;
          case 0xA:
            uint64_t v12 = xmlNewDocNode(a3, a4, (const xmlChar *)"uri", 0);
            unsigned int v13 = v12;
            last = (const xmlChar *)v11->last;
            BOOL v15 = "name";
LABEL_24:
            xmlSetProp(v12, (const xmlChar *)v15, last);
            xmlNodePtr parent = (const xmlChar *)v11->parent;
            unsigned int v22 = v13;
            xmlGenericErrorFunc v27 = "uri";
            goto LABEL_27;
          case 0xB:
            uint64_t v16 = xmlNewDocNode(a3, a4, (const xmlChar *)"rewriteURI", 0);
            unsigned int v13 = v16;
            int v17 = (const xmlChar *)v11->last;
            uint64_t v18 = "uriStartString";
LABEL_26:
            xmlSetProp(v16, (const xmlChar *)v18, v17);
            xmlNodePtr parent = (const xmlChar *)v11->parent;
            unsigned int v22 = v13;
            xmlGenericErrorFunc v27 = "rewritePrefix";
            goto LABEL_27;
          case 0xC:
            uint64_t v19 = xmlNewDocNode(a3, a4, (const xmlChar *)"delegateURI", 0);
            unsigned int v13 = v19;
            xmlGenericErrorFunc v20 = (const xmlChar *)v11->last;
            BOOL v21 = "uriStartString";
LABEL_21:
            xmlSetProp(v19, (const xmlChar *)v21, v20);
            xmlNodePtr parent = (const xmlChar *)v11->parent;
            unsigned int v22 = v13;
LABEL_22:
            xmlGenericErrorFunc v27 = "catalog";
LABEL_27:
            xmlSetProp(v22, (const xmlChar *)v27, parent);
            goto LABEL_28;
          default:
            break;
        }
      }
      xmlNodePtr v11 = (xmlNodePtr)v11->_private;
    }
    while (v11);
  }
  return result;
}

xmlRMutexPtr _xmlInitializeCatalogData()
{
  if (getenv("XML_DEBUG_CATALOG")) {
    xmlDebugCatalogs = 1;
  }
  xmlRMutexPtr result = xmlNewRMutex();
  xmlCatalogMutex = (uint64_t)result;
  return result;
}

int xmlCharInRange(unsigned int val, const xmlChRangeGroup *group)
{
  if (!group) {
    return 0;
  }
  if (!HIWORD(val))
  {
    int nbShortRange = group->nbShortRange;
    if (group->nbShortRange)
    {
      BOOL v3 = __OFSUB__(nbShortRange, 1);
      int v4 = nbShortRange - 1;
      if (v4 < 0 == v3)
      {
        int v5 = 0;
        shortRange = group->shortRange;
        do
        {
          int v7 = v4 + v5;
          if (v4 + v5 < 0 != __OFADD__(v4, v5)) {
            ++v7;
          }
          int v8 = v7 >> 1;
          uint64_t v9 = (uint64_t)v7 >> 1;
          if (shortRange[v8].low <= val)
          {
            if (shortRange[v9].high >= (unsigned __int16)val) {
              return 1;
            }
            int v5 = v9 + 1;
          }
          else
          {
            int v4 = v9 - 1;
          }
        }
        while (v5 <= v4);
      }
    }
    return 0;
  }
  int nbLongRange = group->nbLongRange;
  if (!nbLongRange) {
    return 0;
  }
  BOOL v3 = __OFSUB__(nbLongRange, 1);
  int v11 = nbLongRange - 1;
  if (v11 < 0 != v3) {
    return 0;
  }
  int v12 = 0;
  longRange = group->longRange;
  while (1)
  {
    int v14 = v11 + v12;
    if (v11 + v12 < 0 != __OFADD__(v11, v12)) {
      ++v14;
    }
    int v15 = v14 >> 1;
    uint64_t v16 = (uint64_t)v14 >> 1;
    if (longRange[v15].low <= val) {
      break;
    }
    int v11 = v16 - 1;
LABEL_23:
    if (v12 > v11) {
      return 0;
    }
  }
  if (longRange[v16].high < val)
  {
    int v12 = v16 + 1;
    goto LABEL_23;
  }
  return 1;
}

int xmlIsBaseChar(unsigned int ch)
{
  if (ch > 0xFF) {
    return xmlCharInRange(ch, &xmlIsBaseCharGroup);
  }
  return ch - 192 < 0x17 || (ch & 0xFFFFFFDF) - 65 < 0x1A || ch - 216 < 0x1F || ch > 0xF7;
}

int xmlIsBlank(unsigned int ch)
{
  BOOL v3 = ch == 32 || ch - 9 < 2 || ch == 13;
  return ch <= 0xFF && v3;
}

int xmlIsChar(unsigned int ch)
{
  if (ch > 0xFF) {
    return ch >> 11 < 0x1B || (ch - 57344) >> 1 < 0xFFF || ch - 0x10000 < 0x100000;
  }
  if (ch > 0xD) {
    return ch > 0x1F;
  }
  int v1 = 1;
  if (((1 << ch) & 0x2600) == 0) {
    return ch > 0x1F;
  }
  return v1;
}

int xmlIsCombining(unsigned int ch)
{
  if (ch >= 0x100) {
    return xmlCharInRange(ch, &xmlIsCombiningGroup);
  }
  else {
    return 0;
  }
}

int xmlIsDigit(unsigned int ch)
{
  if (ch > 0xFF) {
    return xmlCharInRange(ch, &xmlIsDigitGroup);
  }
  else {
    return ch - 48 < 0xA;
  }
}

int xmlIsExtender(unsigned int ch)
{
  if (ch > 0xFF) {
    return xmlCharInRange(ch, &xmlIsExtenderGroup);
  }
  else {
    return ch == 183;
  }
}

int xmlIsIdeographic(unsigned int ch)
{
  BOOL v3 = ch == 12295 || ch - 19968 < 0x51A6 || ch - 12321 < 9;
  return ch >= 0x100 && v3;
}

int xmlIsPubidChar(unsigned int ch)
{
  if (ch > 0xFF) {
    return 0;
  }
  else {
    return xmlIsPubidChar_tab[ch];
  }
}

void xmlDebugDumpString(FILE *output, const xmlChar *str)
{
  if (output) {
    unsigned int v2 = output;
  }
  else {
    unsigned int v2 = (FILE *)*MEMORY[0x1E4F143D8];
  }
  if (!str)
  {
    int v7 = "(NULL)";
    size_t v8 = 6;
    goto LABEL_20;
  }
  for (uint64_t i = 0; i != 40; ++i)
  {
    int v5 = str[i];
    if (v5 == 32) {
      goto LABEL_13;
    }
    if (!str[i]) {
      return;
    }
    if ((v5 - 9) < 2 || v5 == 13)
    {
LABEL_13:
      int v5 = 32;
LABEL_14:
      fputc(v5, v2);
      continue;
    }
    if ((v5 & 0x80) == 0) {
      goto LABEL_14;
    }
    fprintf(v2, "#%X", str[i]);
  }
  int v7 = "...";
  size_t v8 = 3;
LABEL_20:

  fwrite(v7, v8, 1uLL, v2);
}

void xmlDebugDumpAttr(FILE *output, xmlAttrPtr attr, int depth)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (output)
  {
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v13 = 0;
    *(void *)&long long v3 = 0x2020202020202020;
    *((void *)&v3 + 1) = 0x2020202020202020;
    long long v5 = v3;
    long long v6 = v3;
    long long v7 = v3;
    long long v8 = v3;
    long long v9 = v3;
    long long v10 = v3;
    int v4 = output;
    uint64_t v11 = 538976288;
    uint64_t v12 = depth;
    xmlCtxtDumpAttr((size_t)&v4, (uint64_t)attr);
  }
}

size_t xmlCtxtDumpAttr(size_t a1, uint64_t a2)
{
  size_t result = xmlCtxtDumpSpaces(a1);
  int v5 = *(_DWORD *)(a1 + 144);
  if (a2)
  {
    if (!v5)
    {
      fwrite("ATTRIBUTE ", 0xAuLL, 1uLL, *(FILE **)a1);
      xmlCtxtDumpString(a1, *(void *)(a2 + 16));
      fputc(10, *(FILE **)a1);
      uint64_t v6 = *(void *)(a2 + 24);
      if (v6)
      {
        ++*(_DWORD *)(a1 + 112);
        do
        {
          xmlCtxtDumpNode(a1, v6);
          uint64_t v6 = *(void *)(v6 + 48);
        }
        while (v6);
        --*(_DWORD *)(a1 + 112);
      }
    }
    if (!*(void *)(a2 + 16)) {
      xmlDebugErr(a1, 5015, (char)"Attribute has no name");
    }
    return xmlCtxtGenericNodeCheck(a1, a2);
  }
  else if (!v5)
  {
    long long v7 = *(FILE **)a1;
    return fwrite("Attr is NULL", 0xCuLL, 1uLL, v7);
  }
  return result;
}

void xmlDebugDumpEntities(FILE *output, xmlDocPtr doc)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (output)
  {
    uint64_t v16 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v17 = 0;
    *(void *)&long long v3 = 0x2020202020202020;
    *((void *)&v3 + 1) = 0x2020202020202020;
    long long v9 = v3;
    long long v10 = v3;
    long long v11 = v3;
    long long v12 = v3;
    long long v13 = v3;
    long long v14 = v3;
    uint64_t v15 = 538976288;
    __stream = output;
    if (doc)
    {
      xmlCtxtDumpDocHead(&__stream, (uint64_t)doc);
      intSubset = doc->intSubset;
      if (intSubset && (entities = (xmlHashTable *)intSubset->entities) != 0)
      {
        if (!v20) {
          fwrite("Entities in internal subset\n", 0x1CuLL, 1uLL, __stream);
        }
        xmlHashScan(entities, (xmlHashScanner)xmlCtxtDumpEntityCallback, &__stream);
      }
      else
      {
        fwrite("No entities in internal subset\n", 0x1FuLL, 1uLL, __stream);
      }
      extSubset = doc->extSubset;
      if (extSubset && (long long v7 = (xmlHashTable *)extSubset->entities) != 0)
      {
        if (!v20) {
          fwrite("Entities in external subset\n", 0x1CuLL, 1uLL, __stream);
        }
        xmlHashScan(v7, (xmlHashScanner)xmlCtxtDumpEntityCallback, &__stream);
      }
      else if (!v20)
      {
        fwrite("No entities in external subset\n", 0x1FuLL, 1uLL, __stream);
      }
    }
  }
}

void xmlDebugDumpAttrList(FILE *output, xmlAttrPtr attr, int depth)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (output)
  {
    xmlAttrPtr v3 = attr;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    uint64_t v14 = 0;
    *(void *)&long long v4 = 0x2020202020202020;
    *((void *)&v4 + 1) = 0x2020202020202020;
    long long v6 = v4;
    long long v7 = v4;
    long long v8 = v4;
    long long v9 = v4;
    long long v10 = v4;
    long long v11 = v4;
    int v5 = output;
    uint64_t v12 = 538976288;
    for (uint64_t i = depth; v3; v3 = v3->next)
      xmlCtxtDumpAttr((size_t)&v5, (uint64_t)v3);
  }
}

void xmlDebugDumpOneNode(FILE *output, xmlNodePtr node, int depth)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (output)
  {
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v13 = 0;
    *(void *)&long long v3 = 0x2020202020202020;
    *((void *)&v3 + 1) = 0x2020202020202020;
    long long v5 = v3;
    long long v6 = v3;
    long long v7 = v3;
    long long v8 = v3;
    long long v9 = v3;
    long long v10 = v3;
    long long v4 = output;
    uint64_t v11 = 538976288;
    uint64_t v12 = depth;
    xmlCtxtDumpOneNode((uint64_t)&v4, (uint64_t)node);
  }
}

_DWORD *xmlCtxtDumpOneNode(uint64_t a1, uint64_t a2)
{
  size_t result = (_DWORD *)MEMORY[0x1F4188790](a1, a2);
  size_t v4 = (size_t)result;
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (!v3)
  {
    if (!result[36])
    {
      xmlCtxtDumpSpaces((uint64_t)result);
      long long v10 = *(FILE **)v4;
      uint64_t v11 = "node is NULL\n";
      size_t v12 = 13;
LABEL_9:
      return (_DWORD *)fwrite(v11, v12, 1uLL, v10);
    }
    return result;
  }
  uint64_t v5 = v3;
  *((void *)result + 16) = v3;
  int v6 = *(_DWORD *)(v3 + 8);
  switch(v6)
  {
    case 1:
      if (result[36]) {
        goto LABEL_96;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      fwrite("ELEMENT ", 8uLL, 1uLL, *(FILE **)v4);
      uint64_t v13 = *(void *)(v5 + 72);
      if (v13)
      {
        uint64_t v14 = *(void *)(v13 + 24);
        if (v14)
        {
          xmlCtxtDumpString(v4, v14);
          fputc(58, *(FILE **)v4);
        }
      }
      xmlCtxtDumpString(v4, *(void *)(v5 + 16));
      goto LABEL_94;
    case 2:
      if (!result[36]) {
        xmlCtxtDumpSpaces((uint64_t)result);
      }
      long long v7 = *(FILE **)v4;
      long long v8 = "Error, ATTRIBUTE found here\n";
      size_t v9 = 28;
      goto LABEL_25;
    case 3:
      if (result[36]) {
        goto LABEL_96;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      if (*(const xmlChar **)(v5 + 16) == "textnoenc")
      {
        uint64_t v15 = "TEXT no enc";
        size_t v16 = 11;
      }
      else
      {
        uint64_t v15 = "TEXT";
        size_t v16 = 4;
      }
      fwrite(v15, v16, 1uLL, *(FILE **)v4);
      if (*(unsigned char *)(v4 + 156))
      {
        uint64_t v40 = *(const xmlChar **)(v5 + 80);
        if (v40 == (const xmlChar *)(v5 + 88))
        {
          uint64_t v17 = *(FILE **)v4;
          uint64_t v18 = " compact\n";
LABEL_46:
          size_t v19 = 9;
        }
        else
        {
          int v41 = xmlDictOwns(*(xmlDictPtr *)(v4 + 136), v40);
          uint64_t v17 = *(FILE **)v4;
          if (v41 != 1)
          {
            uint64_t v30 = *(FILE **)v4;
            goto LABEL_95;
          }
          uint64_t v18 = " interned\n";
          size_t v19 = 10;
        }
LABEL_47:
        fwrite(v18, v19, 1uLL, v17);
        goto LABEL_96;
      }
LABEL_94:
      uint64_t v30 = *(FILE **)v4;
LABEL_95:
      fputc(10, v30);
LABEL_96:
      if (!*(void *)(v5 + 64))
      {
        if (!*(_DWORD *)(v4 + 144)) {
          xmlCtxtDumpSpaces(v4);
        }
        fwrite("PBM: doc == NULL !!!\n", 0x15uLL, 1uLL, *(FILE **)v4);
      }
      ++*(_DWORD *)(v4 + 112);
      int v31 = *(_DWORD *)(v5 + 8);
      if (v31 == 1)
      {
        uint64_t v32 = *(void **)(v5 + 96);
        if (!v32) {
          goto LABEL_104;
        }
        do
        {
          xmlCtxtDumpNamespace(v4, (uint64_t)v32);
          uint64_t v32 = (void *)*v32;
        }
        while (v32);
        int v31 = *(_DWORD *)(v5 + 8);
        if (v31 == 1)
        {
LABEL_104:
          uint64_t v33 = *(void *)(v5 + 88);
          if (!v33) {
            goto LABEL_116;
          }
          do
          {
            xmlCtxtDumpAttr(v4, v33);
            uint64_t v33 = *(void *)(v33 + 48);
          }
          while (v33);
          int v31 = *(_DWORD *)(v5 + 8);
        }
      }
      if (v31 != 1)
      {
        if (v31 == 5)
        {
          xmlEntityPtr DocEntity = xmlGetDocEntity(*(const xmlDoc **)(v5 + 64), *(const xmlChar **)(v5 + 16));
          if (!DocEntity) {
            goto LABEL_116;
          }
          xmlEntityPtr v35 = DocEntity;
          xmlCtxtDumpSpaces(v4);
          if (*(_DWORD *)(v4 + 144)) {
            goto LABEL_116;
          }
          switch(v35->etype)
          {
            case XML_INTERNAL_GENERAL_ENTITY:
              uint64_t v36 = *(FILE **)v4;
              xmlGenericErrorFunc v37 = "INTERNAL_GENERAL_ENTITY ";
              size_t v38 = 24;
              goto LABEL_129;
            case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
              uint64_t v36 = *(FILE **)v4;
              xmlGenericErrorFunc v37 = "EXTERNAL_GENERAL_PARSED_ENTITY ";
              size_t v38 = 31;
              goto LABEL_129;
            case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
              uint64_t v36 = *(FILE **)v4;
              xmlGenericErrorFunc v37 = "EXTERNAL_GENERAL_UNPARSED_ENTITY ";
              size_t v38 = 33;
              goto LABEL_129;
            case XML_INTERNAL_PARAMETER_ENTITY:
              uint64_t v36 = *(FILE **)v4;
              xmlGenericErrorFunc v37 = "INTERNAL_PARAMETER_ENTITY ";
              goto LABEL_128;
            case XML_EXTERNAL_PARAMETER_ENTITY:
              uint64_t v36 = *(FILE **)v4;
              xmlGenericErrorFunc v37 = "EXTERNAL_PARAMETER_ENTITY ";
LABEL_128:
              size_t v38 = 26;
LABEL_129:
              fwrite(v37, v38, 1uLL, v36);
              break;
            default:
              fprintf(*(FILE **)v4, "ENTITY_%d ! ", v35->etype);
              break;
          }
          fprintf(*(FILE **)v4, "%s\n", (const char *)v35->name);
          if (v35->ExternalID)
          {
            xmlCtxtDumpSpaces(v4);
            fprintf(*(FILE **)v4, "ExternalID=%s\n", (const char *)v35->ExternalID);
          }
          if (v35->SystemID)
          {
            xmlCtxtDumpSpaces(v4);
            fprintf(*(FILE **)v4, "SystemID=%s\n", (const char *)v35->SystemID);
          }
          if (v35->URI)
          {
            xmlCtxtDumpSpaces(v4);
            fprintf(*(FILE **)v4, "URI=%s\n", (const char *)v35->URI);
          }
          content = v35->content;
          p_content = (uint64_t *)&v35->content;
          if (!content) {
            goto LABEL_116;
          }
        }
        else
        {
          p_content = (uint64_t *)(v5 + 80);
          if (!*(void *)(v5 + 80) || *(_DWORD *)(v4 + 144)) {
            goto LABEL_116;
          }
        }
        xmlCtxtDumpSpaces(v4);
        fwrite("content=", 8uLL, 1uLL, *(FILE **)v4);
        xmlCtxtDumpString(v4, *p_content);
        fputc(10, *(FILE **)v4);
      }
LABEL_116:
      --*(_DWORD *)(v4 + 112);
LABEL_117:
      return (_DWORD *)xmlCtxtGenericNodeCheck(v4, v5);
    case 4:
      if (result[36]) {
        goto LABEL_96;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      uint64_t v17 = *(FILE **)v4;
      uint64_t v18 = "CDATA_SECTION\n";
      goto LABEL_43;
    case 5:
      if (!result[36])
      {
        xmlCtxtDumpSpaces((uint64_t)result);
        fprintf(*(FILE **)v4, "ENTITY_REF(%s)\n");
      }
      goto LABEL_96;
    case 6:
      if (result[36]) {
        goto LABEL_96;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      uint64_t v17 = *(FILE **)v4;
      uint64_t v18 = "ENTITY\n";
      size_t v19 = 7;
      goto LABEL_47;
    case 7:
      if (!result[36])
      {
        xmlCtxtDumpSpaces((uint64_t)result);
        fprintf(*(FILE **)v4, "PI %s\n");
      }
      goto LABEL_96;
    case 8:
      if (result[36]) {
        goto LABEL_96;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      uint64_t v17 = *(FILE **)v4;
      uint64_t v18 = "COMMENT\n";
      size_t v19 = 8;
      goto LABEL_47;
    case 9:
    case 13:
      if (!result[36]) {
        xmlCtxtDumpSpaces((uint64_t)result);
      }
      long long v7 = *(FILE **)v4;
      long long v8 = "Error, DOCUMENT found here\n";
      size_t v9 = 27;
LABEL_25:
      fwrite(v8, v9, 1uLL, v7);
      goto LABEL_117;
    case 10:
      if (result[36]) {
        goto LABEL_96;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      uint64_t v17 = *(FILE **)v4;
      uint64_t v18 = "DOCUMENT_TYPE\n";
      goto LABEL_43;
    case 11:
      if (result[36]) {
        goto LABEL_96;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      uint64_t v17 = *(FILE **)v4;
      uint64_t v18 = "DOCUMENT_FRAG\n";
LABEL_43:
      size_t v19 = 14;
      goto LABEL_47;
    case 12:
      if (result[36]) {
        goto LABEL_96;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      uint64_t v17 = *(FILE **)v4;
      uint64_t v18 = "NOTATION\n";
      goto LABEL_46;
    case 14:
      return xmlCtxtDumpDtdNode((uint64_t)result, v3);
    case 15:
      xmlCtxtDumpSpaces((uint64_t)result);
      if (*(_DWORD *)(v5 + 8) != 15)
      {
        uint64_t v20 = "Node is not an element declaration";
        uint64_t v21 = v4;
        int v22 = 5025;
        goto LABEL_73;
      }
      if (*(void *)(v5 + 16))
      {
        if (!*(_DWORD *)(v4 + 144))
        {
          fwrite("ELEMDECL(", 9uLL, 1uLL, *(FILE **)v4);
          xmlCtxtDumpString(v4, *(void *)(v5 + 16));
          fputc(41, *(FILE **)v4);
        }
      }
      else
      {
        xmlDebugErr(v4, 5015, (char)"Element declaration has no name");
      }
      if (!*(_DWORD *)(v4 + 144))
      {
        switch(*(_DWORD *)(v5 + 72))
        {
          case 0:
            xmlGenericErrorFunc v23 = *(FILE **)v4;
            uint64_t v24 = ", UNDEFINED";
            size_t v25 = 11;
            goto LABEL_143;
          case 1:
            xmlGenericErrorFunc v23 = *(FILE **)v4;
            uint64_t v24 = ", EMPTY";
            size_t v25 = 7;
            goto LABEL_143;
          case 2:
            xmlGenericErrorFunc v23 = *(FILE **)v4;
            uint64_t v24 = ", ANY";
            size_t v25 = 5;
            goto LABEL_143;
          case 3:
          case 4:
            xmlGenericErrorFunc v23 = *(FILE **)v4;
            uint64_t v24 = ", MIXED ";
            size_t v25 = 8;
LABEL_143:
            fwrite(v24, v25, 1uLL, v23);
            break;
          default:
            break;
        }
        if (*(_DWORD *)(v5 + 8) != 1)
        {
          int v43 = *(xmlElementContent **)(v5 + 80);
          if (v43)
          {
            bzero(buf, 0x1389uLL);
            xmlSnprintfElementContent(buf, 5000, v43, 1);
            buf[5000] = 0;
            fputs(buf, *(FILE **)v4);
          }
        }
        fputc(10, *(FILE **)v4);
      }
      return (_DWORD *)xmlCtxtGenericNodeCheck(v4, v5);
    case 16:
      xmlCtxtDumpSpaces((uint64_t)result);
      if (*(_DWORD *)(v5 + 8) != 16)
      {
        uint64_t v20 = "Node is not an attribute declaration";
        uint64_t v21 = v4;
        int v22 = 5024;
        goto LABEL_73;
      }
      if (*(void *)(v5 + 16))
      {
        if (!*(_DWORD *)(v4 + 144)) {
          fprintf(*(FILE **)v4, "ATTRDECL(%s)", *(const char **)(v5 + 16));
        }
      }
      else
      {
        xmlDebugErr(v4, 5015, (char)"Node attribute declaration has no name");
      }
      if (*(void *)(v5 + 112))
      {
        if (!*(_DWORD *)(v4 + 144)) {
          fprintf(*(FILE **)v4, " for %s", *(const char **)(v5 + 112));
        }
      }
      else
      {
        xmlDebugErr(v4, 5016, (char)"Node attribute declaration has no element name");
      }
      if (*(_DWORD *)(v4 + 144)) {
        goto LABEL_117;
      }
      switch(*(_DWORD *)(v5 + 80))
      {
        case 1:
          xmlGenericErrorFunc v28 = *(FILE **)v4;
          xmlGenericErrorFunc v29 = " CDATA";
          goto LABEL_166;
        case 2:
          xmlGenericErrorFunc v28 = *(FILE **)v4;
          xmlGenericErrorFunc v29 = " ID";
          size_t v45 = 3;
          goto LABEL_176;
        case 3:
          xmlGenericErrorFunc v28 = *(FILE **)v4;
          xmlGenericErrorFunc v29 = " IDREF";
LABEL_166:
          size_t v45 = 6;
          goto LABEL_176;
        case 4:
          xmlGenericErrorFunc v28 = *(FILE **)v4;
          xmlGenericErrorFunc v29 = " IDREFS";
          goto LABEL_169;
        case 5:
          xmlGenericErrorFunc v28 = *(FILE **)v4;
          xmlGenericErrorFunc v29 = " ENTITY";
LABEL_169:
          size_t v45 = 7;
          goto LABEL_176;
        case 6:
          xmlGenericErrorFunc v28 = *(FILE **)v4;
          xmlGenericErrorFunc v29 = " ENTITIES";
          goto LABEL_173;
        case 7:
          xmlGenericErrorFunc v28 = *(FILE **)v4;
          xmlGenericErrorFunc v29 = " NMTOKEN";
          size_t v45 = 8;
          goto LABEL_176;
        case 8:
          xmlGenericErrorFunc v28 = *(FILE **)v4;
          xmlGenericErrorFunc v29 = " NMTOKENS";
LABEL_173:
          size_t v45 = 9;
          goto LABEL_176;
        case 9:
          xmlGenericErrorFunc v28 = *(FILE **)v4;
          xmlGenericErrorFunc v29 = " ENUMERATION";
          size_t v45 = 12;
          goto LABEL_176;
        case 0xA:
          xmlGenericErrorFunc v28 = *(FILE **)v4;
          xmlGenericErrorFunc v29 = " NOTATION ";
          size_t v45 = 10;
LABEL_176:
          fwrite(v29, v45, 1uLL, v28);
          break;
        default:
          break;
      }
      int v46 = *(void **)(v5 + 96);
      if (!v46) {
        goto LABEL_186;
      }
      int v47 = 5;
      while (1)
      {
        int v48 = *(FILE **)v4;
        if (v47 == 5) {
          fprintf(v48, " (%s");
        }
        else {
          fprintf(v48, "|%s");
        }
        int v46 = (void *)*v46;
        if (!v46) {
          break;
        }
        if (!--v47)
        {
          fwrite("...)", 4uLL, 1uLL, *(FILE **)v4);
          goto LABEL_186;
        }
      }
      fputc(41, *(FILE **)v4);
LABEL_186:
      int v49 = *(_DWORD *)(v5 + 84);
      switch(v49)
      {
        case 4:
          uint64_t v50 = *(FILE **)v4;
          xmlGenericErrorFunc v51 = " FIXED";
          size_t v52 = 6;
          break;
        case 3:
          uint64_t v50 = *(FILE **)v4;
          xmlGenericErrorFunc v51 = " IMPLIED";
          size_t v52 = 8;
          break;
        case 2:
          uint64_t v50 = *(FILE **)v4;
          xmlGenericErrorFunc v51 = " REQUIRED";
          size_t v52 = 9;
          break;
        default:
          goto LABEL_193;
      }
      fwrite(v51, v52, 1uLL, v50);
LABEL_193:
      if (*(void *)(v5 + 88))
      {
        fputc(34, *(FILE **)v4);
        xmlCtxtDumpString(v4, *(void *)(v5 + 88));
        fputc(34, *(FILE **)v4);
      }
LABEL_195:
      fputc(10, *(FILE **)v4);
      goto LABEL_117;
    case 17:
      xmlCtxtDumpSpaces((uint64_t)result);
      if (*(_DWORD *)(v5 + 8) != 17)
      {
        uint64_t v20 = "Node is not an entity declaration";
        uint64_t v21 = v4;
        int v22 = 5026;
LABEL_73:
        return xmlDebugErr(v21, v22, (char)v20);
      }
      if (*(void *)(v5 + 16))
      {
        if (!*(_DWORD *)(v4 + 144))
        {
          fwrite("ENTITYDECL(", 0xBuLL, 1uLL, *(FILE **)v4);
          xmlCtxtDumpString(v4, *(void *)(v5 + 16));
          fputc(41, *(FILE **)v4);
        }
      }
      else
      {
        xmlDebugErr(v4, 5015, (char)"Entity declaration has no name");
      }
      if (!*(_DWORD *)(v4 + 144))
      {
        switch(*(_DWORD *)(v5 + 92))
        {
          case 1:
            uint64_t v26 = *(FILE **)v4;
            xmlGenericErrorFunc v27 = ", internal\n";
            goto LABEL_151;
          case 2:
            uint64_t v26 = *(FILE **)v4;
            xmlGenericErrorFunc v27 = ", external parsed\n";
            size_t v44 = 18;
            goto LABEL_155;
          case 3:
            uint64_t v26 = *(FILE **)v4;
            xmlGenericErrorFunc v27 = ", unparsed\n";
LABEL_151:
            size_t v44 = 11;
            goto LABEL_155;
          case 4:
            uint64_t v26 = *(FILE **)v4;
            xmlGenericErrorFunc v27 = ", parameter\n";
            size_t v44 = 12;
            goto LABEL_155;
          case 5:
            uint64_t v26 = *(FILE **)v4;
            xmlGenericErrorFunc v27 = ", external parameter\n";
            size_t v44 = 21;
            goto LABEL_155;
          case 6:
            uint64_t v26 = *(FILE **)v4;
            xmlGenericErrorFunc v27 = ", predefined\n";
            size_t v44 = 13;
LABEL_155:
            fwrite(v27, v44, 1uLL, v26);
            break;
          default:
            break;
        }
        if (*(void *)(v5 + 96))
        {
          xmlCtxtDumpSpaces(v4);
          fprintf(*(FILE **)v4, " ExternalID=%s\n", *(const char **)(v5 + 96));
        }
        if (*(void *)(v5 + 104))
        {
          xmlCtxtDumpSpaces(v4);
          fprintf(*(FILE **)v4, " SystemID=%s\n", *(const char **)(v5 + 104));
        }
        if (*(void *)(v5 + 120))
        {
          xmlCtxtDumpSpaces(v4);
          fprintf(*(FILE **)v4, " URI=%s\n", *(const char **)(v5 + 120));
        }
        if (*(void *)(v5 + 80))
        {
          xmlCtxtDumpSpaces(v4);
          fwrite(" content=", 9uLL, 1uLL, *(FILE **)v4);
          xmlCtxtDumpString(v4, *(void *)(v5 + 80));
          goto LABEL_195;
        }
      }
      goto LABEL_117;
    case 18:
      return xmlCtxtDumpNamespace((size_t)result, v3);
    case 19:
      if (result[36]) {
        return result;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      long long v10 = *(FILE **)v4;
      uint64_t v11 = "INCLUDE START\n";
      size_t v12 = 14;
      goto LABEL_9;
    case 20:
      if (result[36]) {
        return result;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      long long v10 = *(FILE **)v4;
      uint64_t v11 = "INCLUDE END\n";
      size_t v12 = 12;
      goto LABEL_9;
    default:
      if (!result[36])
      {
        xmlCtxtDumpSpaces((uint64_t)result);
        int v6 = *(_DWORD *)(v5 + 8);
      }
      return xmlDebugErr3(v4, 5011, "Unknown node type %d\n", v6);
  }
}

void xmlDebugDumpNode(FILE *output, xmlNodePtr node, int depth)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v3 = (FILE *)*MEMORY[0x1E4F143D8];
  if (output) {
    uint64_t v3 = output;
  }
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v14 = 0;
  *(void *)&long long v4 = 0x2020202020202020;
  *((void *)&v4 + 1) = 0x2020202020202020;
  long long v6 = v4;
  long long v7 = v4;
  long long v8 = v4;
  long long v9 = v4;
  long long v10 = v4;
  long long v11 = v4;
  uint64_t v5 = v3;
  LODWORD(v12) = 538976288;
  LODWORD(v1xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = depth;
  xmlCtxtDumpNode(&v5, (uint64_t)node);
}

_DWORD *xmlCtxtDumpNode(_DWORD *result, uint64_t a2)
{
  unsigned int v2 = result;
  if (a2)
  {
    size_t result = xmlCtxtDumpOneNode((uint64_t)result, a2);
    int v4 = *(_DWORD *)(a2 + 8);
    if (v4 != 18)
    {
      uint64_t v5 = *(void *)(a2 + 24);
      if (v4 != 5 && v5 != 0)
      {
        ++v2[28];
        do
        {
          size_t result = (_DWORD *)xmlCtxtDumpNode(v2, v5);
          uint64_t v5 = *(void *)(v5 + 48);
        }
        while (v5);
        --v2[28];
      }
    }
  }
  else if (!result[36])
  {
    xmlCtxtDumpSpaces((uint64_t)result);
    long long v7 = *(FILE **)v2;
    return (_DWORD *)fwrite("node is NULL\n", 0xDuLL, 1uLL, v7);
  }
  return result;
}

void xmlDebugDumpNodeList(FILE *output, xmlNodePtr node, int depth)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v3 = (FILE *)*MEMORY[0x1E4F143D8];
  if (output) {
    uint64_t v3 = output;
  }
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  *(void *)&long long v4 = 0x2020202020202020;
  *((void *)&v4 + 1) = 0x2020202020202020;
  long long v7 = v4;
  long long v8 = v4;
  long long v9 = v4;
  long long v10 = v4;
  long long v11 = v4;
  long long v12 = v4;
  long long v6 = v3;
  LODWORD(v1xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 538976288;
  LODWORD(v14) = depth;
  if (node)
  {
    xmlNodePtr v5 = node;
    do
    {
      xmlCtxtDumpNode(&v6, (uint64_t)v5);
      xmlNodePtr v5 = v5->next;
    }
    while (v5);
  }
}

void xmlDebugDumpDocumentHead(FILE *output, xmlDocPtr doc)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  unsigned int v2 = (FILE *)*MEMORY[0x1E4F143D8];
  if (output) {
    unsigned int v2 = output;
  }
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = 0;
  *(void *)&long long v3 = 0x2020202020202020;
  *((void *)&v3 + 1) = 0x2020202020202020;
  long long v5 = v3;
  long long v6 = v3;
  long long v7 = v3;
  long long v8 = v3;
  long long v9 = v3;
  long long v10 = v3;
  LODWORD(v11) = 538976288;
  long long v16 = xmmword_1B51A8020;
  long long v4 = v2;
  xmlCtxtDumpDocumentHead((size_t)&v4, (uint64_t)doc);
}

size_t xmlCtxtDumpDocumentHead(size_t result, uint64_t a2)
{
  if (a2)
  {
    size_t v3 = result;
    size_t result = (size_t)xmlCtxtDumpDocHead((_DWORD *)result, a2);
    if (!*(_DWORD *)(v3 + 144))
    {
      if (*(void *)(a2 + 16))
      {
        fwrite("name=", 5uLL, 1uLL, *(FILE **)v3);
        xmlCtxtDumpString(v3, *(void *)(a2 + 16));
        size_t result = fputc(10, *(FILE **)v3);
      }
      if (*(void *)(a2 + 104))
      {
        fwrite("version=", 8uLL, 1uLL, *(FILE **)v3);
        xmlCtxtDumpString(v3, *(void *)(a2 + 104));
        size_t result = fputc(10, *(FILE **)v3);
      }
      if (*(void *)(a2 + 112))
      {
        fwrite("encoding=", 9uLL, 1uLL, *(FILE **)v3);
        xmlCtxtDumpString(v3, *(void *)(a2 + 112));
        size_t result = fputc(10, *(FILE **)v3);
      }
      if (*(void *)(a2 + 136))
      {
        fwrite("URL=", 4uLL, 1uLL, *(FILE **)v3);
        xmlCtxtDumpString(v3, *(void *)(a2 + 136));
        size_t result = fputc(10, *(FILE **)v3);
      }
      if (*(_DWORD *)(a2 + 76)) {
        size_t result = fwrite("standalone=true\n", 0x10uLL, 1uLL, *(FILE **)v3);
      }
    }
    for (uint64_t i = *(void **)(a2 + 96); i; uint64_t i = (void *)*i)
      size_t result = (size_t)xmlCtxtDumpNamespace(v3, (uint64_t)i);
  }
  return result;
}

void xmlDebugDumpDocument(FILE *output, xmlDocPtr doc)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  unsigned int v2 = (FILE *)*MEMORY[0x1E4F143D8];
  if (output) {
    unsigned int v2 = output;
  }
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = 0;
  *(void *)&long long v3 = 0x2020202020202020;
  *((void *)&v3 + 1) = 0x2020202020202020;
  long long v5 = v3;
  long long v6 = v3;
  long long v7 = v3;
  long long v8 = v3;
  long long v9 = v3;
  long long v10 = v3;
  LODWORD(v11) = 538976288;
  long long v16 = xmmword_1B51A8020;
  long long v4 = v2;
  xmlCtxtDumpDocument((size_t)&v4, (uint64_t)doc);
}

size_t xmlCtxtDumpDocument(size_t result, uint64_t a2)
{
  unsigned int v2 = (_DWORD *)result;
  if (a2)
  {
    size_t result = xmlCtxtDumpDocumentHead(result, a2);
    if ((*(_DWORD *)(a2 + 8) | 4) == 0xD)
    {
      uint64_t v4 = *(void *)(a2 + 24);
      if (v4)
      {
        ++v2[28];
        do
        {
          size_t result = (size_t)xmlCtxtDumpNode(v2, v4);
          uint64_t v4 = *(void *)(v4 + 48);
        }
        while (v4);
        --v2[28];
      }
    }
  }
  else if (!*(_DWORD *)(result + 144))
  {
    long long v5 = *(FILE **)result;
    return fwrite("DOCUMENT == NULL !\n", 0x13uLL, 1uLL, v5);
  }
  return result;
}

void xmlDebugDumpDTD(FILE *output, xmlDtdPtr dtd)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  if (output) {
    unsigned int v2 = output;
  }
  else {
    unsigned int v2 = (FILE *)*MEMORY[0x1E4F143D8];
  }
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v17 = 0;
  *(void *)&long long v3 = 0x2020202020202020;
  *((void *)&v3 + 1) = 0x2020202020202020;
  long long v9 = v3;
  long long v10 = v3;
  long long v11 = v3;
  long long v12 = v3;
  long long v13 = v3;
  long long v14 = v3;
  LODWORD(v15) = 538976288;
  long long v20 = xmmword_1B51A8020;
  __stream = v2;
  if (dtd)
  {
    xmlCtxtDumpDtdNode((uint64_t)&__stream, (uint64_t)dtd);
    children = dtd->children;
    if (children)
    {
      LODWORD(v16) = v16 + 1;
      do
      {
        xmlCtxtDumpNode(&__stream, (uint64_t)children);
        children = children->next;
      }
      while (children);
      return;
    }
    unsigned int v2 = __stream;
    long long v6 = "    DTD is empty\n";
    size_t v7 = 17;
  }
  else
  {
    long long v6 = "DTD is NULL\n";
    size_t v7 = 12;
  }

  fwrite(v6, v7, 1uLL, v2);
}

int xmlDebugCheckDocument(FILE *output, xmlDocPtr doc)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  unsigned int v2 = (FILE *)*MEMORY[0x1E4F143D8];
  if (output) {
    unsigned int v2 = output;
  }
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v14 = 0;
  *(void *)&long long v3 = 0x2020202020202020;
  *((void *)&v3 + 1) = 0x2020202020202020;
  long long v6 = v3;
  long long v7 = v3;
  long long v8 = v3;
  long long v9 = v3;
  long long v10 = v3;
  long long v11 = v3;
  LODWORD(v12) = 538976288;
  long long v5 = v2;
  long long v17 = xmmword_1B51A8030;
  xmlCtxtDumpDocument((size_t)&v5, (uint64_t)doc);
  return DWORD1(v17);
}

int xmlLsCountNode(xmlNodePtr node)
{
  if (node)
  {
    switch(node->type)
    {
      case XML_ELEMENT_NODE:
      case XML_ATTRIBUTE_NODE:
      case XML_DOCUMENT_NODE:
      case XML_HTML_DOCUMENT_NODE:
      case XML_DOCB_DOCUMENT_NODE:
        children = node->children;
        if (!children) {
          goto LABEL_11;
        }
        LODWORD(node) = 0;
        do
        {
          children = children->next;
          LODWORD(node) = node + 1;
        }
        while (children);
        break;
      case XML_TEXT_NODE:
      case XML_CDATA_SECTION_NODE:
      case XML_PI_NODE:
      case XML_COMMENT_NODE:
        node = (xmlNodePtr)node->content;
        if (node) {
          LODWORD(node) = xmlStrlen((const xmlChar *)node);
        }
        break;
      case XML_ENTITY_REF_NODE:
      case XML_ENTITY_NODE:
      case XML_DOCUMENT_TYPE_NODE:
      case XML_DOCUMENT_FRAG_NODE:
      case XML_NOTATION_NODE:
      case XML_DTD_NODE:
      case XML_ELEMENT_DECL:
      case XML_ATTRIBUTE_DECL:
      case XML_ENTITY_DECL:
      case XML_NAMESPACE_DECL:
      case XML_XINCLUDE_START:
      case XML_XINCLUDE_END:
        LODWORD(node) = 1;
        break;
      default:
LABEL_11:
        LODWORD(node) = 0;
        break;
    }
  }
  return (int)node;
}

void xmlLsOneNode(FILE *output, xmlNodePtr node)
{
  if (output)
  {
    if (node)
    {
      unsigned __int32 v4 = node->type - 1;
      if (v4 > 0x11) {
        int v5 = 63;
      }
      else {
        int v5 = dword_1B51A8048[v4];
      }
      fputc(v5, output);
      if (node->type != XML_NAMESPACE_DECL)
      {
        if (node->properties) {
          int v6 = 97;
        }
        else {
          int v6 = 45;
        }
        fputc(v6, output);
        if (node->nsDef) {
          int v7 = 110;
        }
        else {
          int v7 = 45;
        }
        fputc(v7, output);
      }
      int v8 = xmlLsCountNode(node);
      fprintf(output, " %8d ", v8);
      switch(node->type)
      {
        case XML_ELEMENT_NODE:
          name = (const char *)node->name;
          if (name)
          {
            xmlNsPtr ns = node->ns;
            if (ns)
            {
              prefix = (const char *)ns->prefix;
              if (prefix)
              {
                fprintf(output, "%s:", prefix);
                name = (const char *)node->name;
              }
            }
            goto LABEL_20;
          }
          break;
        case XML_TEXT_NODE:
          content = node->content;
          if (content) {
            xmlDebugDumpString(output, content);
          }
          break;
        case XML_CDATA_SECTION_NODE:
        case XML_COMMENT_NODE:
        case XML_DOCUMENT_NODE:
        case XML_DOCUMENT_TYPE_NODE:
        case XML_DOCUMENT_FRAG_NODE:
        case XML_NOTATION_NODE:
        case XML_HTML_DOCUMENT_NODE:
          break;
        case XML_NAMESPACE_DECL:
          if (node->children) {
            fprintf(output, "%s -> %s");
          }
          else {
            fprintf(output, "default -> %s");
          }
          break;
        default:
          name = (const char *)node->name;
          if (name) {
LABEL_20:
          }
            fputs(name, output);
          break;
      }
      fputc(10, output);
    }
    else
    {
      fwrite("NULL\n", 5uLL, 1uLL, output);
    }
  }
}

const char *__cdecl xmlBoolToText(int BOOLval)
{
  if (BOOLval) {
    return "True";
  }
  else {
    return "False";
  }
}

void xmlShellPrintXPathError(int errorType, const char *arg)
{
  if errorType <= 9 && ((0x3FDu >> errorType))
  {
    unsigned int v2 = off_1E60C70C8[errorType];
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    unsigned __int32 v4 = __xmlGenericErrorContext();
    v3(*v4, v2);
  }
}

void xmlShellPrintNode(xmlNodePtr node)
{
  if (node)
  {
    int v1 = (FILE *)*MEMORY[0x1E4F143D8];
    xmlElementType type = node->type;
    if (type == XML_ATTRIBUTE_NODE)
    {
      xmlDebugDumpAttrList((FILE *)*MEMORY[0x1E4F143D8], (xmlAttrPtr)node, 0);
    }
    else if (type == XML_DOCUMENT_NODE)
    {
      xmlDocDump((FILE *)*MEMORY[0x1E4F143D8], (xmlDocPtr)node);
    }
    else
    {
      xmlElemDump((FILE *)*MEMORY[0x1E4F143D8], node->doc, node);
    }
    fputc(10, v1);
  }
}

int xmlShellList(xmlShellCtxtPtr ctxt, char *arg, xmlNodePtr node, xmlNodePtr node2)
{
  if (ctxt)
  {
    if (node)
    {
      xmlElementType type = node->type;
      if (type == XML_DOCUMENT_NODE || type == XML_HTML_DOCUMENT_NODE)
      {
        children = node->children;
        if (!children) {
          return 0;
        }
      }
      else if (type == XML_NAMESPACE_DECL || (children = node->children) == 0)
      {
        xmlLsOneNode(ctxt->output, node);
        return 0;
      }
      do
      {
        xmlLsOneNode(ctxt->output, children);
        children = children->next;
      }
      while (children);
    }
    else
    {
      fwrite("NULL\n", 5uLL, 1uLL, ctxt->output);
    }
  }
  return 0;
}

int xmlShellBase(xmlShellCtxtPtr ctxt, char *arg, xmlNodePtr node, xmlNodePtr node2)
{
  if (ctxt)
  {
    if (node)
    {
      Base = xmlNodeGetBase(node->doc, node);
      output = ctxt->output;
      if (Base)
      {
        int v7 = Base;
        fprintf(output, "%s\n", (const char *)Base);
        xmlFree(v7);
        return 0;
      }
      int v8 = " No base found !!!\n";
      size_t v9 = 19;
    }
    else
    {
      output = ctxt->output;
      int v8 = "NULL\n";
      size_t v9 = 5;
    }
    fwrite(v8, v9, 1uLL, output);
  }
  return 0;
}

int xmlShellDir(xmlShellCtxtPtr ctxt, char *arg, xmlNodePtr node, xmlNodePtr node2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (ctxt)
  {
    if (node)
    {
      xmlElementType type = node->type;
      if (type == XML_ATTRIBUTE_NODE)
      {
        xmlDebugDumpAttr(ctxt->output, (xmlAttrPtr)node, 0);
      }
      else if (type == XML_HTML_DOCUMENT_NODE || type == XML_DOCUMENT_NODE)
      {
        output = ctxt->output;
        uint64_t v16 = 0;
        uint64_t v17 = 0;
        if (!output) {
          output = (FILE *)*MEMORY[0x1E4F143D8];
        }
        long long v18 = 0u;
        long long v19 = 0u;
        uint64_t v20 = 0x100000000;
        *(void *)&long long v7 = 0x2020202020202020;
        *((void *)&v7 + 1) = 0x2020202020202020;
        long long v10 = v7;
        long long v11 = v7;
        long long v12 = v7;
        long long v13 = v7;
        long long v14 = v7;
        long long v15 = v7;
        LODWORD(v16) = 538976288;
        size_t v9 = output;
        xmlCtxtDumpDocumentHead((size_t)&v9, (uint64_t)node);
      }
      else
      {
        xmlDebugDumpOneNode(ctxt->output, node, 0);
      }
    }
    else
    {
      fwrite("NULL\n", 5uLL, 1uLL, ctxt->output);
    }
  }
  return 0;
}

int xmlShellCat(xmlShellCtxtPtr ctxt, char *arg, xmlNodePtr node, xmlNodePtr node2)
{
  if (ctxt)
  {
    if (node)
    {
      xmlDocPtr doc = ctxt->doc;
      xmlElementType type = node->type;
      output = ctxt->output;
      if (doc->type == XML_HTML_DOCUMENT_NODE)
      {
        if (type == XML_HTML_DOCUMENT_NODE) {
          htmlDocDump(output, (xmlDocPtr)node);
        }
        else {
          htmlNodeDumpFile(output, doc, node);
        }
      }
      else if (type == XML_DOCUMENT_NODE)
      {
        xmlDocDump(output, (xmlDocPtr)node);
      }
      else
      {
        xmlElemDump(output, doc, node);
      }
      fputc(10, ctxt->output);
    }
    else
    {
      fwrite("NULL\n", 5uLL, 1uLL, ctxt->output);
    }
  }
  return 0;
}

int xmlShellLoad(xmlShellCtxtPtr ctxt, char *filename, xmlNodePtr node, xmlNodePtr node2)
{
  int result = -1;
  if (ctxt && filename)
  {
    xmlDocPtr doc = ctxt->doc;
    if (doc && doc->type == XML_HTML_DOCUMENT_NODE) {
      htmlDocPtr File = htmlParseFile(filename, 0);
    }
    else {
      htmlDocPtr File = xmlReadFile(filename, 0, 0);
    }
    size_t v9 = File;
    if (File)
    {
      if (ctxt->loaded == 1) {
        xmlFreeDoc(ctxt->doc);
      }
      ctxt->loaded = 1;
      xmlXPathFreeContext(ctxt->pctxt);
      xmlFree(ctxt->filename);
      ctxt->xmlDocPtr doc = v9;
      ctxt->node = (xmlNodePtr)v9;
      ctxt->pctxt = xmlXPathNewContext(v9);
      long long v10 = (char *)xmlCanonicPath((const xmlChar *)filename);
      int result = 0;
      ctxt->filename = v10;
    }
    else
    {
      return -1;
    }
  }
  return result;
}

int xmlShellWrite(xmlShellCtxtPtr ctxt, char *filename, xmlNodePtr node, xmlNodePtr node2)
{
  int result = -1;
  if (filename && node && *filename)
  {
    xmlElementType type = node->type;
    if (type == XML_HTML_DOCUMENT_NODE)
    {
      if (htmlSaveFile(filename, ctxt->doc) < 0) {
        goto LABEL_13;
      }
    }
    else if (type == XML_DOCUMENT_NODE)
    {
      if (xmlSaveFile(filename, ctxt->doc) <= -2) {
        goto LABEL_13;
      }
    }
    else
    {
      size_t v9 = fopen(filename, "w");
      if (!v9)
      {
LABEL_13:
        xmlGenericErrorFunc v11 = *__xmlGenericError();
        long long v12 = __xmlGenericErrorContext();
        v11(*v12, "Failed to write to %s\n", filename);
        return -1;
      }
      long long v10 = v9;
      xmlElemDump(v9, ctxt->doc, node);
      fclose(v10);
    }
    return 0;
  }
  return result;
}

int xmlShellSave(xmlShellCtxtPtr ctxt, char *filename, xmlNodePtr node, xmlNodePtr node2)
{
  if (!ctxt) {
    return -1;
  }
  xmlDocPtr doc = ctxt->doc;
  if (doc)
  {
    if (filename && *filename || (filename = ctxt->filename) != 0)
    {
      xmlElementType type = doc->type;
      if (type == XML_HTML_DOCUMENT_NODE)
      {
        if ((htmlSaveFile(filename, doc) & 0x80000000) == 0) {
          return 0;
        }
        goto LABEL_9;
      }
      if (type == XML_DOCUMENT_NODE)
      {
        if ((xmlSaveFile(filename, doc) & 0x80000000) == 0) {
          return 0;
        }
LABEL_9:
        xmlGenericErrorFunc v7 = *__xmlGenericError();
        int v8 = __xmlGenericErrorContext();
        v7(*v8, "Failed to save to %s\n", filename);
        return 0;
      }
      xmlGenericErrorFunc v10 = *__xmlGenericError();
      xmlGenericErrorFunc v11 = __xmlGenericErrorContext();
      v10(*v11, "To save to subparts of a document use the 'write' command\n");
    }
  }
  return -1;
}

int xmlShellValidate(xmlShellCtxtPtr ctxt, char *dtd, xmlNodePtr node, xmlNodePtr node2)
{
  if (!ctxt || !ctxt->doc) {
    return -1;
  }
  memset(&v10, 0, sizeof(v10));
  v10.error = *__xmlGenericError();
  v10.warning = *__xmlGenericError();
  if (!dtd || !*dtd) {
    return xmlValidateDocument(&v10, ctxt->doc);
  }
  int v6 = xmlParseDTD(0, (const xmlChar *)dtd);
  if (!v6) {
    return -1;
  }
  xmlGenericErrorFunc v7 = v6;
  int v8 = xmlValidateDtd(&v10, ctxt->doc, v6);
  xmlFreeDtd(v7);
  return v8;
}

int xmlShellDu(xmlShellCtxtPtr ctxt, char *arg, xmlNodePtr tree, xmlNodePtr node2)
{
  int result = -1;
  if (!ctxt || !tree) {
    return result;
  }
  int v7 = 0;
  xmlNodePtr v8 = tree;
  while (1)
  {
    xmlElementType type = v8->type;
    if (type == XML_HTML_DOCUMENT_NODE || type == XML_DOCUMENT_NODE)
    {
      fwrite("/\n", 2uLL, 1uLL, ctxt->output);
    }
    else
    {
      if (type != XML_ELEMENT_NODE) {
        goto LABEL_18;
      }
      int v11 = v7;
      if (v7 >= 1)
      {
        do
        {
          fwrite("  ", 2uLL, 1uLL, ctxt->output);
          --v11;
        }
        while (v11);
      }
      xmlNsPtr ns = v8->ns;
      if (ns)
      {
        prefix = (const char *)ns->prefix;
        if (prefix) {
          fprintf(ctxt->output, "%s:", prefix);
        }
      }
      fprintf(ctxt->output, "%s\n", (const char *)v8->name);
    }
    xmlElementType type = v8->type;
LABEL_18:
    if ((type | 4) == 0xD)
    {
      children = v8->children;
      goto LABEL_20;
    }
    children = v8->children;
    if (type != XML_ENTITY_REF_NODE && children != 0)
    {
      ++v7;
      goto LABEL_20;
    }
    if (v8 == tree) {
      return 0;
    }
    children = v8->next;
    if (!children) {
      break;
    }
LABEL_20:
    xmlNodePtr v8 = children;
    if (!children) {
      return 0;
    }
  }
  while (v8 != tree)
  {
    xmlNodePtr parent = v8->parent;
    if (parent) {
      xmlNodePtr v8 = v8->parent;
    }
    v7 -= parent != 0;
    if (v8 == tree)
    {
      children = 0;
LABEL_37:
      if (children != tree) {
        goto LABEL_20;
      }
      return 0;
    }
    children = v8->next;
    if (!children)
    {
      children = v8->parent;
      if (children) {
        continue;
      }
    }
    goto LABEL_37;
  }
  return 0;
}

int xmlShellPwd(xmlShellCtxtPtr ctxt, char *buffer, xmlNodePtr node, xmlNodePtr node2)
{
  int result = -1;
  if (buffer && node)
  {
    NodePath = xmlGetNodePath(node);
    if (NodePath)
    {
      int v7 = NodePath;
      snprintf(buffer, 0x1F3uLL, "%s", (const char *)NodePath);
      buffer[499] = 48;
      xmlFree(v7);
      return 0;
    }
    else
    {
      return -1;
    }
  }
  return result;
}

void xmlShell(xmlDocPtr doc, char *filename, xmlShellReadlineFunc input, FILE *output)
{
  uint64_t v229 = *MEMORY[0x1E4F143B8];
  long long v227 = 0u;
  long long v228 = 0u;
  long long v225 = 0u;
  long long v226 = 0u;
  long long v223 = 0u;
  long long v224 = 0u;
  long long v221 = 0u;
  long long v222 = 0u;
  long long v219 = 0u;
  long long v220 = 0u;
  long long v217 = 0u;
  long long v218 = 0u;
  long long v215 = 0u;
  long long v216 = 0u;
  long long v214 = 0u;
  long long v213 = 0u;
  long long v212 = 0u;
  long long v211 = 0u;
  long long v210 = 0u;
  long long v209 = 0u;
  long long v208 = 0u;
  long long v207 = 0u;
  long long v206 = 0u;
  long long v205 = 0u;
  long long v204 = 0u;
  long long v203 = 0u;
  long long v202 = 0u;
  long long v201 = 0u;
  long long v200 = 0u;
  long long v199 = 0u;
  *(_OWORD *)&__str[4] = 0u;
  *(_DWORD *)__str = 540942383;
  if (!doc) {
    return;
  }
  if (!filename) {
    return;
  }
  if (!input) {
    return;
  }
  xmlNodePtr v8 = (FILE *)*MEMORY[0x1E4F143D8];
  size_t v9 = xmlMalloc(0x38uLL);
  if (!v9) {
    return;
  }
  uint64_t v10 = (uint64_t)v9;
  int v197 = 0;
  memset(v196, 0, sizeof(v196));
  *(_OWORD *)dtd = 0u;
  long long v172 = 0u;
  long long v173 = 0u;
  long long v174 = 0u;
  long long v175 = 0u;
  long long v176 = 0u;
  long long v177 = 0u;
  long long v178 = 0u;
  long long v179 = 0u;
  long long v180 = 0u;
  long long v181 = 0u;
  long long v182 = 0u;
  long long v183 = 0u;
  long long v184 = 0u;
  long long v185 = 0u;
  long long v186 = 0u;
  long long v187 = 0u;
  long long v188 = 0u;
  long long v189 = 0u;
  long long v190 = 0u;
  long long v191 = 0u;
  long long v192 = 0u;
  long long v193 = 0u;
  long long v194 = 0u;
  long long v195 = 0u;
  if (output) {
    int v11 = output;
  }
  else {
    int v11 = v8;
  }
  v9[8] = 0;
  *((void *)v9 + 1) = doc;
  *((void *)v9 + 5) = v11;
  *((void *)v9 + 6) = input;
  *(void *)size_t v9 = xmlStrdup((const xmlChar *)filename);
  long long v12 = *(xmlDoc **)(v10 + 8);
  *(void *)(v10 + 16) = v12;
  xmlXPathContextPtr v13 = xmlXPathNewContext(v12);
  *(void *)(v10 + 24) = v13;
  if (v13)
  {
    while (1)
    {
      uint64_t v14 = *(void *)(v10 + 16);
      if (v14 == *(void *)(v10 + 8)) {
        break;
      }
      if (v14 && *(void *)(v14 + 16))
      {
        uint64_t v15 = *(void *)(v14 + 72);
        if (!v15 || !*(void *)(v15 + 24)) {
          break;
        }
        snprintf(__str, 0x1F4uLL, "%s:%s > ");
      }
      else
      {
        strcpy(__str, "? > ");
      }
LABEL_17:
      HIBYTE(v228) = 0;
      uint64_t v16 = (xmlShellCtxt *)(*(uint64_t (**)(unsigned char *))(v10 + 48))(__str);
      uint64_t v20 = v16;
      if (!v16) {
        goto LABEL_229;
      }
      for (uint64_t i = v16; ; uint64_t i = (xmlShellCtxt *)((char *)i + 1))
      {
        int filename_low = LOBYTE(i->filename);
        if (filename_low != 9 && filename_low != 32) {
          break;
        }
      }
      uint64_t v23 = 0;
      while (filename_low > 0x20u || ((1 << filename_low) & 0x100002601) == 0)
      {
        uint64_t v24 = (unsigned __int8 *)i + v23;
        *((unsigned char *)v196 + v23++) = filename_low;
        LOBYTE(filename_low) = v24[1];
      }
      *((unsigned char *)v196 + v2xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0;
      if (v23)
      {
        for (uint64_t j = (unsigned __int8 *)i + v23; ; ++j)
        {
          int v26 = *j;
          if (v26 != 9 && v26 != 32) {
            break;
          }
        }
        for (uint64_t k = 0; v26 > 0xDu || ((1 << v26) & 0x2401) == 0; ++k)
        {
          xmlGenericErrorFunc v29 = &j[k];
          dtd[k] = v26;
          LOBYTE(v26) = v29[1];
        }
        dtd[k] = 0;
        if (!(LODWORD(v196[0]) ^ 0x74697865 | BYTE4(v196[0]))
          || !(LODWORD(v196[0]) ^ 0x74697571 | BYTE4(v196[0]))
          || LODWORD(v196[0]) == 6650210)
        {
LABEL_229:
          xmlXPathFreeContext(*(xmlXPathContextPtr *)(v10 + 24));
          if (*(_DWORD *)(v10 + 32)) {
            xmlFreeDoc(*(xmlDocPtr *)(v10 + 8));
          }
          if (*(void *)v10) {
            xmlFree(*(void **)v10);
          }
          xmlFree((void *)v10);
          if (v20) {
            free(v20);
          }
          return;
        }
        if (!(LODWORD(v196[0]) ^ 0x706C6568 | BYTE4(v196[0])))
        {
          fwrite("\tbase         display XML base of the node\n", 0x2BuLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\tsetbase URI  change the XML base of the node\n", 0x2EuLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\tbye          leave shell\n", 0x1AuLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\tcat [node]   display node or current node\n", 0x2BuLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\tcd [path]    change directory to path or to root\n", 0x32uLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\tdir [path]   dumps information about the node (namespace, attributes, content)\n", 0x50uLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\tdu [path]    show the structure of the subtree under path or the current node\n", 0x4FuLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\texit         leave shell\n", 0x1AuLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\thelp         display this help\n", 0x20uLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\tfree         display memory usage\n", 0x23uLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\tload [name]  load a new document with name\n", 0x2CuLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\tls [path]    list contents of path or the current directory\n", 0x3DuLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\tset xml_fragment replace the current node content with the fragment parsed in context\n", 0x57uLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\txpath expr   evaluate the XPath expression in that context and print the result\n", 0x51uLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\tsetns nsreg  register a namespace to a prefix in the XPath evaluation context\n", 0x4FuLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\t             format for nsreg is: prefix=[nsuri] (i.e. prefix= unsets a prefix)\n", 0x51uLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\tsetrootns    register all namespace found on the root element\n", 0x3FuLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\t             the default namespace if any uses 'defaultns' prefix\n", 0x43uLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\tpwd          display current working directory\n", 0x30uLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\twhereis      display absolute path of [path] or current working directory\n", 0x4BuLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\tquit         leave shell\n", 0x1AuLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\tsave [name]  save this document to name or the original name\n", 0x3EuLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\twrite [name] write the current node to the filename\n", 0x35uLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\tvalidate     check the document for errors\n", 0x2CuLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\trelaxng rng  validate the document against the Relax-NG schemas\n", 0x41uLL, 1uLL, *(FILE **)(v10 + 40));
          fwrite("\tgrep string  search for a string in the subtree\n", 0x31uLL, 1uLL, *(FILE **)(v10 + 40));
          goto LABEL_120;
        }
        if (!(*(void *)&v196[0] ^ 0x65746164696C6176 | BYTE8(v196[0])))
        {
          xmlShellValidate((xmlShellCtxtPtr)v10, dtd, v18, v19);
          goto LABEL_120;
        }
        if (!(LODWORD(v196[0]) ^ 0x64616F6C | BYTE4(v196[0])))
        {
          xmlShellLoad((xmlShellCtxtPtr)v10, dtd, v18, v19);
          goto LABEL_120;
        }
        if (*(void *)&v196[0] == 0x676E78616C6572)
        {
          xmlGenericErrorFunc v37 = xmlRelaxNGNewParserCtxt(dtd);
          size_t v38 = *__xmlGenericError();
          uint64_t v39 = __xmlGenericError();
          xmlRelaxNGSetParserErrors(v37, v38, *v39, 0);
          uint64_t v40 = xmlRelaxNGParse(v37);
          xmlRelaxNGFreeParserCtxt(v37);
          if (v40)
          {
            int v41 = xmlRelaxNGNewValidCtxt(v40);
            int v42 = *__xmlGenericError();
            int v43 = __xmlGenericError();
            xmlRelaxNGSetValidErrors(v41, v42, *v43, 0);
            int v44 = xmlRelaxNGValidateDoc(v41, *(xmlDocPtr *)(v10 + 8));
            if (v44)
            {
              int v45 = v44;
              int v46 = (FILE *)*MEMORY[0x1E4F143C8];
              if (v45 < 1) {
                fprintf(v46, "%s validation generated an internal error\n");
              }
              else {
                fprintf(v46, "%s fails to validate\n");
              }
            }
            else
            {
              fprintf((FILE *)*MEMORY[0x1E4F143C8], "%s validates\n");
            }
            xmlRelaxNGFreeValidCtxt(v41);
            xmlRelaxNGFree(v40);
          }
          else
          {
            xmlGenericErrorFunc v47 = *__xmlGenericError();
            int v48 = __xmlGenericErrorContext();
            v47(*v48, "Relax-NG schema %s failed to compile\n", dtd);
          }
        }
        else
        {
          if (!(LODWORD(v196[0]) ^ 0x65766173 | BYTE4(v196[0])))
          {
            xmlShellSave((xmlShellCtxtPtr)v10, dtd, v18, v19);
            goto LABEL_120;
          }
          if (LODWORD(v196[0]) == 1953067639 && WORD2(v196[0]) == 101)
          {
            if (dtd[0])
            {
              xmlShellWrite((xmlShellCtxtPtr)v10, dtd, *(xmlNodePtr *)(v10 + 16), v19);
              goto LABEL_120;
            }
            xmlGenericErrorFunc v34 = *__xmlGenericError();
            xmlEntityPtr v35 = *__xmlGenericErrorContext();
            uint64_t v36 = "Write command requires a filename argument\n";
            goto LABEL_122;
          }
          if (!(LODWORD(v196[0]) ^ 0x70657267 | BYTE4(v196[0])))
          {
            uint64_t v49 = *(void *)(v10 + 16);
            if (!v49) {
              goto LABEL_120;
            }
            if (!xmlStrchr((const xmlChar *)dtd, 0x3Fu)
              && !xmlStrchr((const xmlChar *)dtd, 0x2Au)
              && !xmlStrchr((const xmlChar *)dtd, 0x2Eu))
            {
              xmlStrchr((const xmlChar *)dtd, 0x5Bu);
            }
            while (2)
            {
              int v50 = *(_DWORD *)(v49 + 8);
              if (v50 == 3)
              {
                if (xmlStrstr(*(const xmlChar **)(v49 + 80), (const xmlChar *)dtd))
                {
                  int v57 = *(FILE **)(v10 + 40);
                  NodePath = xmlGetNodePath(*(const xmlNode **)(v49 + 40));
                  fprintf(v57, "%s : ", (const char *)NodePath);
                  xmlGenericErrorFunc v56 = *(xmlNode **)(v49 + 40);
                  BOOL v55 = (xmlShellCtxt *)v10;
LABEL_97:
                  xmlShellList(v55, v53, v56, v54);
                }
LABEL_98:
                int v50 = *(_DWORD *)(v49 + 8);
              }
              else if (v50 == 8)
              {
                if (xmlStrstr(*(const xmlChar **)(v49 + 80), (const xmlChar *)dtd))
                {
                  xmlGenericErrorFunc v51 = *(FILE **)(v10 + 40);
                  size_t v52 = xmlGetNodePath((const xmlNode *)v49);
                  fprintf(v51, "%s : ", (const char *)v52);
                  BOOL v55 = (xmlShellCtxt *)v10;
                  xmlGenericErrorFunc v56 = (xmlNode *)v49;
                  goto LABEL_97;
                }
                goto LABEL_98;
              }
              if ((v50 | 4) == 0xD)
              {
                uint64_t v59 = *(void *)(v49 + 24);
              }
              else
              {
                uint64_t v59 = *(void *)(v49 + 24);
                if (v50 == 5 || v59 == 0)
                {
                  uint64_t v59 = *(void *)(v49 + 48);
                  if (!v59)
                  {
                    uint64_t v61 = *(void *)(v49 + 40);
                    while (1)
                    {
                      if (v61) {
                        uint64_t v49 = v61;
                      }
                      uint64_t v59 = *(void *)(v49 + 48);
                      if (v59) {
                        break;
                      }
                      uint64_t v61 = *(void *)(v49 + 40);
                      if (!v61) {
                        goto LABEL_120;
                      }
                    }
                  }
                }
              }
              uint64_t v49 = v59;
              if (!v59) {
                goto LABEL_120;
              }
              continue;
            }
          }
          if (LODWORD(v196[0]) ^ 0x65657266 | BYTE4(v196[0]))
          {
            if (LODWORD(v196[0]) == 6584176)
            {
              int v170 = 0;
              long long v168 = 0u;
              long long v169 = 0u;
              long long v166 = 0u;
              long long v167 = 0u;
              long long v164 = 0u;
              long long v165 = 0u;
              long long v162 = 0u;
              long long v163 = 0u;
              long long v160 = 0u;
              long long v161 = 0u;
              long long v158 = 0u;
              long long v159 = 0u;
              long long v156 = 0u;
              long long v157 = 0u;
              long long v154 = 0u;
              long long v155 = 0u;
              long long v152 = 0u;
              long long v153 = 0u;
              long long v150 = 0u;
              long long v151 = 0u;
              long long v148 = 0u;
              long long v149 = 0u;
              long long v146 = 0u;
              long long v147 = 0u;
              long long v144 = 0u;
              long long v145 = 0u;
              long long v142 = 0u;
              long long v143 = 0u;
              long long v140 = 0u;
              long long v141 = 0u;
              *(_OWORD *)xmlBufPtr buffer = 0u;
              if (xmlShellPwd(v16, buffer, *(xmlNodePtr *)(v10 + 16), v19)) {
                goto LABEL_120;
              }
LABEL_124:
              fprintf(*(FILE **)(v10 + 40), "%s\n", buffer);
              goto LABEL_120;
            }
            if (!(LOWORD(v196[0]) ^ 0x7564 | BYTE2(v196[0])))
            {
              uint64_t v64 = *(xmlNode **)(v10 + 16);
              if (!dtd[0])
              {
                xmlShellDu((xmlShellCtxtPtr)v10, v17, v64, v19);
                goto LABEL_120;
              }
              uint64_t v65 = *(xmlXPathContext **)(v10 + 24);
              v65->node = v64;
              xmlXPathObjectPtr v66 = xmlXPathEval((const xmlChar *)dtd, v65);
              if (v66)
              {
                long long v69 = v66;
                long long v70 = "%s: no such node\n";
                switch(v66->type)
                {
                  case XPATH_UNDEFINED:
                    goto LABEL_159;
                  case XPATH_NODESET:
                    p_nodeNr = &v66->nodesetval->nodeNr;
                    if (p_nodeNr && *p_nodeNr >= 1)
                    {
                      uint64_t v88 = 0;
                      do
                      {
                        xmlShellDu((xmlShellCtxtPtr)v10, v67, *(xmlNodePtr *)(*((void *)p_nodeNr + 1) + 8 * v88++), v68);
                        p_nodeNr = &v69->nodesetval->nodeNr;
                      }
                      while (v88 < *p_nodeNr);
                    }
                    break;
                  case XPATH_BOOLEAN:
LABEL_153:
                    long long v70 = "%s is a Boolean\n";
                    goto LABEL_159;
                  case XPATH_NUMBER:
LABEL_154:
                    long long v70 = "%s is a number\n";
                    goto LABEL_159;
                  case XPATH_STRING:
LABEL_155:
                    long long v70 = "%s is a string\n";
                    goto LABEL_159;
                  case XPATH_POINT:
LABEL_156:
                    long long v70 = "%s is a point\n";
                    goto LABEL_159;
                  case XPATH_RANGE:
                  case XPATH_LOCATIONSET:
LABEL_128:
                    long long v70 = "%s is a range\n";
                    goto LABEL_159;
                  case XPATH_USERS:
LABEL_157:
                    long long v70 = "%s is user-defined\n";
                    goto LABEL_159;
                  case XPATH_XSLT_TREE:
LABEL_158:
                    long long v70 = "%s is an XSLT value tree\n";
LABEL_159:
                    xmlGenericErrorFunc v85 = *__xmlGenericError();
                    long long v86 = __xmlGenericErrorContext();
                    v85(*v86, v70);
                    break;
                  default:
                    break;
                }
LABEL_160:
                xmlXPathFreeObject(v69);
LABEL_161:
                *(void *)(*(void *)(v10 + 24) + 8) = 0;
                goto LABEL_120;
              }
LABEL_151:
              xmlGenericErrorFunc v83 = *__xmlGenericError();
              long long v84 = __xmlGenericErrorContext();
              v83(*v84, "%s: no such node\n", dtd);
              goto LABEL_161;
            }
            if (!(LODWORD(v196[0]) ^ 0x65736162 | BYTE4(v196[0])))
            {
              xmlShellBase((xmlShellCtxtPtr)v10, v17, *(xmlNodePtr *)(v10 + 16), v19);
              goto LABEL_120;
            }
            if (LODWORD(v196[0]) == 7628147)
            {
              xmlShellSetContent(v10, dtd, *(xmlNode **)(v10 + 16));
              goto LABEL_120;
            }
            if (LODWORD(v196[0]) == 1853121907 && WORD2(v196[0]) == 115)
            {
              if (!dtd[0])
              {
                xmlGenericErrorFunc v34 = *__xmlGenericError();
                xmlEntityPtr v35 = *__xmlGenericErrorContext();
                uint64_t v36 = "setns: prefix=[nsuri] required\n";
                goto LABEL_122;
              }
              xmlShellRegisterNamespace(v10, (xmlChar *)dtd);
            }
            else
            {
              if (*(void *)&v196[0] == 0x6E746F6F72746573 && WORD4(v196[0]) == 115)
              {
                xmlNodePtr RootElement = xmlDocGetRootElement(*(const xmlDoc **)(v10 + 8));
                xmlShellRegisterRootNamespaces(v10, (uint64_t)RootElement);
                goto LABEL_120;
              }
              if (LODWORD(v196[0]) == 1952542840 && WORD2(v196[0]) == 104)
              {
                if (!dtd[0])
                {
                  xmlGenericErrorFunc v34 = *__xmlGenericError();
                  xmlEntityPtr v35 = *__xmlGenericErrorContext();
                  uint64_t v36 = "xpath: expression required\n";
                  goto LABEL_122;
                }
                long long v72 = *(xmlXPathContext **)(v10 + 24);
                v72->node = *(xmlNodePtr *)(v10 + 16);
                long long v73 = xmlXPathEval((const xmlChar *)dtd, v72);
                xmlXPathDebugDumpObject(*(FILE **)(v10 + 40), v73, 0);
                xmlXPathFreeObject(v73);
              }
              else
              {
                if (*(void *)&v196[0] == 0x65736162746573)
                {
                  xmlNodeSetBase(*(xmlNodePtr *)(v10 + 16), (const xmlChar *)dtd);
                  goto LABEL_120;
                }
                if (!(LOWORD(v196[0]) ^ 0x736C | BYTE2(v196[0])) || LODWORD(v196[0]) == 7498084)
                {
                  BOOL v74 = LODWORD(v196[0]) != 7498084;
                  long long v75 = *(xmlNode **)(v10 + 16);
                  if (dtd[0])
                  {
                    long long v76 = *(xmlXPathContext **)(v10 + 24);
                    v76->node = v75;
                    xmlXPathObjectPtr v77 = xmlXPathEval((const xmlChar *)dtd, v76);
                    if (v77)
                    {
                      long long v69 = v77;
                      long long v70 = "%s: no such node\n";
                      switch(v77->type)
                      {
                        case XPATH_UNDEFINED:
                          goto LABEL_159;
                        case XPATH_NODESET:
                          long long v80 = &v77->nodesetval->nodeNr;
                          if (v80 && *v80 >= 1)
                          {
                            uint64_t v81 = 0;
                            do
                            {
                              long long v82 = *(xmlNode **)(*((void *)v80 + 1) + 8 * v81);
                              if (v74) {
                                xmlShellList((xmlShellCtxtPtr)v10, v78, v82, v79);
                              }
                              else {
                                xmlShellDir((xmlShellCtxtPtr)v10, v78, v82, v79);
                              }
                              ++v81;
                              long long v80 = &v69->nodesetval->nodeNr;
                            }
                            while (v81 < *v80);
                          }
                          break;
                        case XPATH_BOOLEAN:
                          goto LABEL_153;
                        case XPATH_NUMBER:
                          goto LABEL_154;
                        case XPATH_STRING:
                          goto LABEL_155;
                        case XPATH_POINT:
                          goto LABEL_156;
                        case XPATH_RANGE:
                        case XPATH_LOCATIONSET:
                          goto LABEL_128;
                        case XPATH_USERS:
                          goto LABEL_157;
                        case XPATH_XSLT_TREE:
                          goto LABEL_158;
                        default:
                          goto LABEL_160;
                      }
                      goto LABEL_160;
                    }
                    goto LABEL_151;
                  }
                  if (LODWORD(v196[0]) == 7498084) {
                    xmlShellDir((xmlShellCtxtPtr)v10, v17, v75, v19);
                  }
                  else {
                    xmlShellList((xmlShellCtxtPtr)v10, v17, v75, v19);
                  }
                }
                else
                {
                  if (*(void *)&v196[0] != 0x73696572656877)
                  {
                    if (LOWORD(v196[0]) ^ 0x6463 | BYTE2(v196[0]))
                    {
                      if (LODWORD(v196[0]) != 7627107)
                      {
                        xmlGenericErrorFunc v34 = *__xmlGenericError();
                        xmlEntityPtr v35 = *__xmlGenericErrorContext();
                        uint64_t v36 = "Unknown command %s\n";
LABEL_122:
                        v34(v35, v36);
                        goto LABEL_120;
                      }
                      uint64_t v104 = *(xmlNode **)(v10 + 16);
                      if (!dtd[0])
                      {
                        xmlShellCat((xmlShellCtxtPtr)v10, v17, v104, v19);
                        goto LABEL_120;
                      }
                      int v105 = *(xmlXPathContext **)(v10 + 24);
                      v105->node = v104;
                      xmlXPathObjectPtr v106 = xmlXPathEval((const xmlChar *)dtd, v105);
                      if (v106)
                      {
                        xmlXPathObjectPtr v93 = v106;
                        uint64_t v94 = "%s: no such node\n";
                        switch(v106->type)
                        {
                          case XPATH_UNDEFINED:
                            goto LABEL_203;
                          case XPATH_NODESET:
                            uint64_t v132 = &v106->nodesetval->nodeNr;
                            if (v132 && *v132 >= 1)
                            {
                              uint64_t v133 = 0;
                              do
                              {
                                if (k)
                                {
                                  fwrite(" -------\n", 9uLL, 1uLL, *(FILE **)(v10 + 40));
                                  uint64_t v132 = &v93->nodesetval->nodeNr;
                                }
                                xmlShellCat((xmlShellCtxtPtr)v10, v107, *(xmlNodePtr *)(*((void *)v132 + 1) + 8 * v133++), v108);
                                uint64_t v132 = &v93->nodesetval->nodeNr;
                              }
                              while (v133 < *v132);
                            }
                            break;
                          case XPATH_BOOLEAN:
                            goto LABEL_197;
                          case XPATH_NUMBER:
                            goto LABEL_198;
                          case XPATH_STRING:
                            goto LABEL_199;
                          case XPATH_POINT:
                            goto LABEL_200;
                          case XPATH_RANGE:
                          case XPATH_LOCATIONSET:
                            goto LABEL_191;
                          case XPATH_USERS:
                            goto LABEL_201;
                          case XPATH_XSLT_TREE:
                            goto LABEL_202;
                          default:
                            goto LABEL_204;
                        }
                        goto LABEL_204;
                      }
                    }
                    else
                    {
                      if (!dtd[0])
                      {
                        *(void *)(v10 + 16) = *(void *)(v10 + 8);
                        goto LABEL_120;
                      }
                      uint64_t v97 = *(xmlXPathContext **)(v10 + 24);
                      v97->node = *(xmlNodePtr *)(v10 + 16);
                      int v98 = strlen(dtd);
                      if (v98 >= 2)
                      {
                        uint64_t v99 = (v98 - 1);
                        if (dtd[v99] == 47)
                        {
                          dtd[v99] = 0;
                          uint64_t v97 = *(xmlXPathContext **)(v10 + 24);
                        }
                      }
                      xmlXPathObjectPtr v100 = xmlXPathEval((const xmlChar *)dtd, v97);
                      if (v100)
                      {
                        v101 = v100;
                        switch(v100->type)
                        {
                          case XPATH_UNDEFINED:
                            xmlGenericErrorFunc v114 = *__xmlGenericError();
                            unsigned int v115 = *__xmlGenericErrorContext();
                            v114(v115, "%s: no such node\n");
                            break;
                          case XPATH_NODESET:
                            xmlNodeSetPtr nodesetval = v100->nodesetval;
                            if (nodesetval)
                            {
                              if (nodesetval->nodeNr == 1)
                              {
                                xmlNodePtr v117 = *nodesetval->nodeTab;
                                *(void *)(v10 + 16) = v117;
                                if (v117 && v117->type == XML_NAMESPACE_DECL)
                                {
                                  xmlGenericErrorFunc v118 = *__xmlGenericError();
                                  int v119 = __xmlGenericErrorContext();
                                  v118(*v119, "cannot cd to namespace\n");
                                  *(void *)(v10 + 16) = 0;
                                }
                              }
                              else
                              {
                                xmlGenericErrorFunc v136 = *__xmlGenericError();
                                v137 = *__xmlGenericErrorContext();
                                v136(v137, "%s is a %d Node Set\n");
                              }
                            }
                            else
                            {
                              xmlGenericErrorFunc v134 = *__xmlGenericError();
                              v135 = *__xmlGenericErrorContext();
                              v134(v135, "%s is an empty Node Set\n");
                            }
                            break;
                          case XPATH_BOOLEAN:
                            xmlGenericErrorFunc v120 = *__xmlGenericError();
                            unsigned int v121 = *__xmlGenericErrorContext();
                            v120(v121, "%s is a Boolean\n");
                            break;
                          case XPATH_NUMBER:
                            xmlGenericErrorFunc v122 = *__xmlGenericError();
                            v123 = *__xmlGenericErrorContext();
                            v122(v123, "%s is a number\n");
                            break;
                          case XPATH_STRING:
                            xmlGenericErrorFunc v124 = *__xmlGenericError();
                            v125 = *__xmlGenericErrorContext();
                            v124(v125, "%s is a string\n");
                            break;
                          case XPATH_POINT:
                            xmlGenericErrorFunc v126 = *__xmlGenericError();
                            uint64_t v127 = *__xmlGenericErrorContext();
                            v126(v127, "%s is a point\n");
                            break;
                          case XPATH_RANGE:
                          case XPATH_LOCATIONSET:
                            xmlGenericErrorFunc v102 = *__xmlGenericError();
                            int v103 = *__xmlGenericErrorContext();
                            v102(v103, "%s is a range\n");
                            break;
                          case XPATH_USERS:
                            xmlGenericErrorFunc v128 = *__xmlGenericError();
                            uint64_t v129 = *__xmlGenericErrorContext();
                            v128(v129, "%s is user-defined\n");
                            break;
                          case XPATH_XSLT_TREE:
                            xmlGenericErrorFunc v130 = *__xmlGenericError();
                            uint64_t v131 = *__xmlGenericErrorContext();
                            v130(v131, "%s is an XSLT value tree\n");
                            break;
                          default:
                            break;
                        }
                        int v113 = v101;
                        goto LABEL_227;
                      }
                    }
                    goto LABEL_192;
                  }
                  int v170 = 0;
                  long long v168 = 0u;
                  long long v169 = 0u;
                  long long v166 = 0u;
                  long long v167 = 0u;
                  long long v164 = 0u;
                  long long v165 = 0u;
                  long long v162 = 0u;
                  long long v163 = 0u;
                  long long v160 = 0u;
                  long long v161 = 0u;
                  long long v158 = 0u;
                  long long v159 = 0u;
                  long long v156 = 0u;
                  long long v157 = 0u;
                  long long v154 = 0u;
                  long long v155 = 0u;
                  long long v152 = 0u;
                  long long v153 = 0u;
                  long long v150 = 0u;
                  long long v151 = 0u;
                  long long v148 = 0u;
                  long long v149 = 0u;
                  long long v146 = 0u;
                  long long v147 = 0u;
                  long long v144 = 0u;
                  long long v145 = 0u;
                  long long v142 = 0u;
                  long long v143 = 0u;
                  long long v140 = 0u;
                  long long v141 = 0u;
                  *(_OWORD *)xmlBufPtr buffer = 0u;
                  long long v89 = *(xmlNode **)(v10 + 16);
                  if (dtd[0])
                  {
                    long long v90 = *(xmlXPathContext **)(v10 + 24);
                    v90->node = v89;
                    xmlXPathObjectPtr v91 = xmlXPathEval((const xmlChar *)dtd, v90);
                    if (v91)
                    {
                      xmlXPathObjectPtr v93 = v91;
                      uint64_t v94 = "%s: no such node\n";
                      switch(v91->type)
                      {
                        case XPATH_UNDEFINED:
                          goto LABEL_203;
                        case XPATH_NODESET:
                          xmlElementType v95 = &v91->nodesetval->nodeNr;
                          if (v95 && *v95 >= 1)
                          {
                            uint64_t v96 = 0;
                            do
                            {
                              LODWORD(v91) = xmlShellPwd((xmlShellCtxtPtr)v91, buffer, *(xmlNodePtr *)(*((void *)v95 + 1) + 8 * v96), v92);
                              if (!v91) {
                                xmlXPathObjectPtr v91 = (xmlXPathObjectPtr)fprintf(*(FILE **)(v10 + 40), "%s\n", buffer);
                              }
                              ++v96;
                              xmlElementType v95 = &v93->nodesetval->nodeNr;
                            }
                            while (v96 < *v95);
                          }
                          break;
                        case XPATH_BOOLEAN:
LABEL_197:
                          uint64_t v94 = "%s is a Boolean\n";
                          goto LABEL_203;
                        case XPATH_NUMBER:
LABEL_198:
                          uint64_t v94 = "%s is a number\n";
                          goto LABEL_203;
                        case XPATH_STRING:
LABEL_199:
                          uint64_t v94 = "%s is a string\n";
                          goto LABEL_203;
                        case XPATH_POINT:
LABEL_200:
                          uint64_t v94 = "%s is a point\n";
                          goto LABEL_203;
                        case XPATH_RANGE:
                        case XPATH_LOCATIONSET:
LABEL_191:
                          uint64_t v94 = "%s is a range\n";
                          goto LABEL_203;
                        case XPATH_USERS:
LABEL_201:
                          uint64_t v94 = "%s is user-defined\n";
                          goto LABEL_203;
                        case XPATH_XSLT_TREE:
LABEL_202:
                          uint64_t v94 = "%s is an XSLT value tree\n";
LABEL_203:
                          xmlGenericErrorFunc v111 = *__xmlGenericError();
                          uint64_t v112 = __xmlGenericErrorContext();
                          v111(*v112, v94);
                          break;
                        default:
                          break;
                      }
LABEL_204:
                      int v113 = v93;
LABEL_227:
                      xmlXPathFreeObject(v113);
LABEL_228:
                      *(void *)(*(void *)(v10 + 24) + 8) = 0;
                      goto LABEL_120;
                    }
LABEL_192:
                    xmlGenericErrorFunc v109 = *__xmlGenericError();
                    unsigned int v110 = __xmlGenericErrorContext();
                    v109(*v110, "%s: no such node\n", dtd);
                    goto LABEL_228;
                  }
                  if (!xmlShellPwd(v16, buffer, v89, v19)) {
                    goto LABEL_124;
                  }
                }
              }
            }
          }
          else
          {
            if (dtd[0])
            {
              *(_DWORD *)xmlBufPtr buffer = 0;
              sscanf(dtd, "%d", buffer);
              uint64_t v62 = *(FILE **)(v10 + 40);
              int v63 = *(_DWORD *)buffer;
            }
            else
            {
              uint64_t v62 = *(FILE **)(v10 + 40);
              int v63 = 0;
            }
            xmlMemShow(v62, v63);
          }
        }
LABEL_120:
        free(v20);
      }
    }
    snprintf(__str, 0x1F4uLL, "%s > ");
    goto LABEL_17;
  }
  xmlFreeFunc v138 = xmlFree;

  ((void (*)(uint64_t))v138)(v10);
}

xmlNodePtr xmlShellSetContent(uint64_t a1, char *__s, xmlNode *a3)
{
  if (a3 && __s)
  {
    xmlNodePtr lst = 0;
    int v6 = strlen(__s);
    if (xmlParseInNodeContext(a3, __s, v6, 0, &lst))
    {
      return (xmlNodePtr)fwrite("failed to parse content\n", 0x18uLL, 1uLL, *(FILE **)(a1 + 40));
    }
    else
    {
      children = a3->children;
      if (children)
      {
        xmlFreeNodeList(children);
        a3->children = 0;
        a3->last = 0;
      }
      return xmlAddChildList(a3, lst);
    }
  }
  else
  {
    xmlNodePtr v8 = *(FILE **)(a1 + 40);
    return (xmlNodePtr)fwrite("NULL\n", 5uLL, 1uLL, v8);
  }
}

uint64_t xmlShellRegisterNamespace(uint64_t a1, xmlChar *cur)
{
  xmlGenericErrorFunc v3 = xmlStrdup(cur);
  unsigned __int32 v4 = v3;
  while (v4)
  {
    int v5 = (const char *)v4;
    if (!*v4) {
      break;
    }
    int v6 = xmlStrchr(v4, 0x3Du);
    if (!v6)
    {
      fwrite("setns: prefix=[nsuri] required\n", 0x1FuLL, 1uLL, *(FILE **)(a1 + 40));
      break;
    }
    *int v6 = 0;
    int v7 = (const char *)(v6 + 1);
    xmlNodePtr v8 = xmlStrchr(v6 + 1, 0x20u);
    unsigned __int32 v4 = v8;
    if (v8)
    {
      *xmlNodePtr v8 = 0;
      unsigned __int32 v4 = v8 + 1;
    }
    if (xmlXPathRegisterNs(*(xmlXPathContextPtr *)(a1 + 24), (const xmlChar *)v5, (const xmlChar *)v7))
    {
      fprintf(*(FILE **)(a1 + 40), "Error: unable to register NS with prefix=\"%s\" and href=\"%s\"\n", v5, v7);
      break;
    }
  }
  xmlFreeFunc v9 = xmlFree;

  return ((uint64_t (*)(xmlChar *))v9)(v3);
}

uint64_t xmlShellRegisterRootNamespaces(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    if (*(_DWORD *)(a2 + 8) == 1)
    {
      unsigned int v2 = *(uint64_t ***)(a2 + 96);
      if (v2)
      {
        uint64_t v3 = result;
        if (*(void *)(result + 24))
        {
          do
          {
            if (v2[3]) {
              unsigned __int32 v4 = (const xmlChar *)v2[3];
            }
            else {
              unsigned __int32 v4 = (const xmlChar *)"defaultns";
            }
            int result = xmlXPathRegisterNs(*(xmlXPathContextPtr *)(v3 + 24), v4, (const xmlChar *)v2[2]);
            unsigned int v2 = (uint64_t **)*v2;
          }
          while (v2);
        }
      }
    }
  }
  return result;
}

uint64_t xmlCtxtDumpSpaces(uint64_t result)
{
  if (!*(_DWORD *)(result + 144))
  {
    int v1 = *(FILE **)result;
    if (*(void *)result)
    {
      uint64_t v2 = *(unsigned int *)(result + 112);
      if ((int)v2 >= 1)
      {
        if (v2 >= 0x32) {
          uint64_t v3 = (const char *)(result + 8);
        }
        else {
          uint64_t v3 = (const char *)(result + 8 - 2 * v2 + 100);
        }
        return fputs(v3, v1);
      }
    }
  }
  return result;
}

size_t xmlCtxtDumpString(size_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 144)) {
    return result;
  }
  uint64_t v3 = (FILE **)result;
  if (a2)
  {
    uint64_t v4 = 0;
    while (1)
    {
      int result = *(unsigned __int8 *)(a2 + v4);
      if (result == 32) {
        goto LABEL_12;
      }
      if (!*(unsigned char *)(a2 + v4)) {
        return result;
      }
      if ((result - 9) < 2 || result == 13)
      {
LABEL_12:
        int v6 = *v3;
        LODWORD(result) = 32;
      }
      else
      {
        int v6 = *v3;
        if ((result & 0x80) != 0)
        {
          fprintf(v6, "#%X", *(unsigned __int8 *)(a2 + v4));
          goto LABEL_14;
        }
      }
      fputc(result, v6);
LABEL_14:
      if (++v4 == 40)
      {
        int v7 = *v3;
        xmlNodePtr v8 = "...";
        size_t v9 = 3;
        goto LABEL_19;
      }
    }
  }
  int v7 = *(FILE **)result;
  xmlNodePtr v8 = "(NULL)";
  size_t v9 = 6;
LABEL_19:

  return fwrite(v8, v9, 1uLL, v7);
}

_DWORD *xmlDebugErr(uint64_t a1, int a2, char a3)
{
  return __xmlRaiseError(0, 0, 0, 0, *(void *)(a1 + 128), 0x18u, a2, 2, 0, 0, 0, 0, 0, 0, 0, "%s", a3);
}

uint64_t xmlCtxtGenericNodeCheck(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 64);
  if (*(void *)(a2 + 40))
  {
    if (*(void *)(a2 + 64)) {
      goto LABEL_3;
    }
LABEL_11:
    int result = (uint64_t)xmlDebugErr(v3, 5014, (char)"Node has no doc\n");
    goto LABEL_12;
  }
  int result = (uint64_t)xmlDebugErr(result, 5013, (char)"Node has no parent\n");
  if (!*(void *)(a2 + 64)) {
    goto LABEL_11;
  }
LABEL_3:
  uint64_t v5 = *(void *)(v4 + 152);
  if (!v5 && !*(_DWORD *)(v3 + 152)) {
    *(_DWORD *)(v3 + 152) = 1;
  }
  if (!*(void *)(v3 + 120)) {
    *(void *)(v3 + 120) = v4;
  }
  if (!*(void *)(v3 + 136)) {
    *(void *)(v3 + 136) = v5;
  }
LABEL_12:
  uint64_t v6 = *(void *)(a2 + 40);
  if (v6)
  {
    if (*(void *)(a2 + 64) != *(void *)(v6 + 64))
    {
      int result = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"pseudoroot");
      if (!result) {
        int result = (uint64_t)xmlDebugErr(v3, 5017, (char)"Node doc differs from parent's one\n");
      }
    }
  }
  uint64_t v7 = *(void *)(a2 + 56);
  if (v7)
  {
    if (*(void *)(v7 + 48) == a2) {
      goto LABEL_28;
    }
    xmlNodePtr v8 = "Node prev->next : back link wrong\n";
    uint64_t v9 = v3;
    int v10 = 5019;
    goto LABEL_27;
  }
  uint64_t v11 = *(void *)(a2 + 40);
  if (*(_DWORD *)(a2 + 8) == 2)
  {
    if (v11 && *(void *)(v11 + 88) != a2)
    {
      xmlNodePtr v8 = "Attr has no prev and not first of attr list\n";
LABEL_26:
      uint64_t v9 = v3;
      int v10 = 5018;
LABEL_27:
      int result = (uint64_t)xmlDebugErr(v9, v10, (char)v8);
    }
  }
  else if (v11 && *(void *)(v11 + 24) != a2)
  {
    xmlNodePtr v8 = "Node has no prev and not first of parent list\n";
    goto LABEL_26;
  }
LABEL_28:
  uint64_t v12 = *(void *)(a2 + 48);
  if (v12)
  {
    if (*(void *)(v12 + 56) != a2)
    {
      int result = (uint64_t)xmlDebugErr(v3, 5021, (char)"Node next->prev : forward link wrong\n");
      uint64_t v12 = *(void *)(a2 + 48);
    }
    if (*(void *)(v12 + 40) != *(void *)(a2 + 40))
    {
      xmlXPathContextPtr v13 = "Node next->prev : forward link wrong\n";
      uint64_t v14 = v3;
      int v15 = 5029;
LABEL_33:
      int result = (uint64_t)xmlDebugErr(v14, v15, (char)v13);
    }
  }
  else
  {
    uint64_t v16 = *(void *)(a2 + 40);
    if (v16 && *(_DWORD *)(a2 + 8) != 2 && *(void *)(v16 + 32) != a2 && *(_DWORD *)(v16 + 8) == 1)
    {
      xmlXPathContextPtr v13 = "Node has no next and not last of parent list\n";
      uint64_t v14 = v3;
      int v15 = 5020;
      goto LABEL_33;
    }
  }
  unsigned int v17 = *(_DWORD *)(a2 + 8);
  if (v17 == 2)
  {
    uint64_t v19 = *(void *)(a2 + 72);
    if (!v19)
    {
LABEL_53:
      uint64_t v23 = *(xmlChar **)(a2 + 16);
      return xmlCtxtCheckName(v3, v23);
    }
LABEL_46:
    int result = xmlCtxtNsCheckScope(v3, a2, v19);
LABEL_47:
    unsigned int v17 = *(_DWORD *)(a2 + 8);
    goto LABEL_48;
  }
  if (v17 == 1)
  {
    for (uint64_t i = *(void **)(a2 + 96); i; uint64_t i = (void *)*i)
      int result = xmlCtxtNsCheckScope(v3, a2, (uint64_t)i);
    uint64_t v19 = *(void *)(a2 + 72);
    if (!v19) {
      goto LABEL_47;
    }
    goto LABEL_46;
  }
LABEL_48:
  BOOL v20 = v17 > 0x10;
  int v21 = (1 << v17) & 0x1E206;
  if (v20 || v21 == 0)
  {
    uint64_t v30 = *(void *)(a2 + 80);
    if (v30)
    {
      if (*(_DWORD *)(v3 + 144))
      {
        int result = xmlCheckUTF8(*(const unsigned __int8 **)(a2 + 80));
        if (!result) {
          int result = (uint64_t)xmlDebugErr3(v3, 5032, "String is not UTF-8 %s", v30);
        }
      }
    }
  }
  switch(*(_DWORD *)(a2 + 8))
  {
    case 1:
    case 2:
    case 7:
      goto LABEL_53;
    case 3:
      uint64_t v24 = *(const xmlChar **)(a2 + 16);
      if (v24 == "text" || v24 == "textnoenc") {
        return result;
      }
      size_t v25 = *(xmlDict **)(v3 + 136);
      if (!v25) {
        goto LABEL_61;
      }
      int result = (uint64_t)xmlDictLookup(v25, (const xmlChar *)"nbktext", 7);
      if (v24 != (const xmlChar *)result)
      {
        uint64_t v24 = *(const xmlChar **)(a2 + 16);
LABEL_61:
        int v26 = "Text node has wrong name '%s'";
        uint64_t v27 = v3;
        int v28 = 5036;
        LOBYTE(v29) = (_BYTE)v24;
LABEL_66:
        int result = (uint64_t)xmlDebugErr3(v27, v28, v26, (char)v29);
      }
      break;
    case 4:
      xmlGenericErrorFunc v29 = *(const xmlChar **)(a2 + 16);
      if (!v29) {
        return result;
      }
      int v26 = "CData section has non NULL name '%s'";
      uint64_t v27 = v3;
      int v28 = 5037;
      goto LABEL_66;
    case 8:
      xmlGenericErrorFunc v29 = *(const xmlChar **)(a2 + 16);
      if (v29 == "comment") {
        return result;
      }
      int v26 = "Comment node has wrong name '%s'";
      uint64_t v27 = v3;
      int v28 = 5036;
      goto LABEL_66;
    default:
      return result;
  }
  return result;
}

uint64_t xmlCtxtNsCheckScope(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  unsigned int v5 = *(_DWORD *)(a2 + 8);
  BOOL v6 = v5 > 0x13;
  int v7 = (1 << v5) & 0x8220E;
  if (!v6 && v7 != 0)
  {
    uint64_t v9 = a2;
    do
    {
      unsigned int v10 = *(_DWORD *)(v9 + 8);
      if (v10 > 0x13) {
        break;
      }
      if (((1 << v10) & 0xC) == 0)
      {
        if (((1 << v10) & 0x80002) == 0)
        {
          if (((1 << v10) & 0x2200) != 0 && *(void *)(v9 + 96) == a3) {
            return result;
          }
          break;
        }
        uint64_t v11 = (uint64_t *)(v9 + 96);
        while (1)
        {
          uint64_t v11 = (uint64_t *)*v11;
          if (!v11) {
            break;
          }
          if (v11 == (uint64_t *)a3) {
            return result;
          }
          int result = xmlStrEqual((const xmlChar *)v11[3], *(const xmlChar **)(a3 + 24));
          if (result) {
            goto LABEL_16;
          }
        }
      }
      uint64_t v9 = *(void *)(v9 + 40);
    }
    while (v9);
    uint64_t v12 = *(void *)(a3 + 24);
    if (v12)
    {
      xmlXPathContextPtr v13 = "Reference to namespace '%s' not on ancestor\n";
      uint64_t v14 = v4;
      int v15 = 5031;
      goto LABEL_18;
    }
    uint64_t v16 = "Reference to default namespace not on ancestor\n";
    uint64_t v17 = v4;
    int v18 = 5031;
    goto LABEL_22;
  }
LABEL_16:
  uint64_t v12 = *(void *)(a3 + 24);
  if (!v12)
  {
    uint64_t v16 = "Reference to default namespace not in scope\n";
    uint64_t v17 = v4;
    int v18 = 5030;
LABEL_22:
    return (uint64_t)xmlDebugErr(v17, v18, (char)v16);
  }
  xmlXPathContextPtr v13 = "Reference to namespace '%s' not in scope\n";
  uint64_t v14 = v4;
  int v15 = 5030;
LABEL_18:

  return (uint64_t)xmlDebugErr3(v14, v15, v13, v12);
}

uint64_t xmlCtxtCheckName(uint64_t result, xmlChar *value)
{
  if (*(_DWORD *)(result + 144))
  {
    uint64_t v3 = result;
    if (value)
    {
      if (xmlValidateName(value, 0)) {
        xmlDebugErr3(v3, 5034, "Name is not an NCName '%s'", (char)value);
      }
      int result = *(void *)(v3 + 136);
      if (result)
      {
        int result = xmlDictOwns((xmlDictPtr)result, value);
        if (!result)
        {
          uint64_t v4 = *(void *)(v3 + 120);
          if (!v4 || (*(unsigned char *)(v4 + 169) & 0x12) == 0)
          {
            return (uint64_t)xmlDebugErr3(v3, 5035, "Name is not from the document dictionary '%s'", (char)value);
          }
        }
      }
    }
    else
    {
      return (uint64_t)xmlDebugErr(result, 5015, (char)"Name is NULL");
    }
  }
  return result;
}

_DWORD *xmlDebugErr3(uint64_t a1, int a2, const char *a3, char a4)
{
  return __xmlRaiseError(0, 0, 0, 0, *(void *)(a1 + 128), 0x18u, a2, 2, 0, 0, 0, 0, 0, 0, 0, a3, a4);
}

_DWORD *xmlCtxtDumpDocHead(_DWORD *result, uint64_t a2)
{
  *((void *)result + 16) = a2;
  int v2 = *(_DWORD *)(a2 + 8);
  switch(v2)
  {
    case 1:
      uint64_t v3 = "Misplaced ELEMENT node\n";
      int v4 = 5000;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 2:
      uint64_t v3 = "Misplaced ATTRIBUTE node\n";
      int v4 = 5001;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 3:
      uint64_t v3 = "Misplaced TEXT node\n";
      int v4 = 5002;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 4:
      uint64_t v3 = "Misplaced CDATA node\n";
      int v4 = 5003;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 5:
      uint64_t v3 = "Misplaced ENTITYREF node\n";
      int v4 = 5004;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 6:
      uint64_t v3 = "Misplaced ENTITY node\n";
      int v4 = 5005;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 7:
      uint64_t v3 = "Misplaced PI node\n";
      int v4 = 5006;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 8:
      uint64_t v3 = "Misplaced COMMENT node\n";
      int v4 = 5007;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 9:
      if (result[36]) {
        return result;
      }
      unsigned int v5 = *(FILE **)result;
      BOOL v6 = "DOCUMENT\n";
      size_t v7 = 9;
      return (_DWORD *)fwrite(v6, v7, 1uLL, v5);
    case 10:
      uint64_t v3 = "Misplaced DOCTYPE node\n";
      int v4 = 5008;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 11:
      uint64_t v3 = "Misplaced FRAGMENT node\n";
      int v4 = 5009;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 12:
      uint64_t v3 = "Misplaced NOTATION node\n";
      int v4 = 5010;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 13:
      if (result[36]) {
        return result;
      }
      unsigned int v5 = *(FILE **)result;
      BOOL v6 = "HTML DOCUMENT\n";
      size_t v7 = 14;
      return (_DWORD *)fwrite(v6, v7, 1uLL, v5);
    default:
      return xmlDebugErr3((uint64_t)result, 5011, "Unknown node type %d\n", v2);
  }
}

size_t xmlCtxtDumpEntityCallback(size_t result, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 144);
  if (result)
  {
    if (!v3)
    {
      size_t v4 = result;
      fprintf(*(FILE **)a2, "%s : ", *(const char **)(result + 16));
      int v5 = *(_DWORD *)(v4 + 92);
      switch(v5)
      {
        case 1:
          BOOL v6 = *(FILE **)a2;
          size_t v7 = "INTERNAL GENERAL, ";
          size_t v8 = 18;
          goto LABEL_16;
        case 2:
          BOOL v6 = *(FILE **)a2;
          size_t v7 = "EXTERNAL PARSED, ";
          size_t v8 = 17;
          goto LABEL_16;
        case 3:
          BOOL v6 = *(FILE **)a2;
          size_t v7 = "EXTERNAL UNPARSED, ";
          size_t v8 = 19;
          goto LABEL_16;
        case 4:
          BOOL v6 = *(FILE **)a2;
          size_t v7 = "INTERNAL PARAMETER, ";
          goto LABEL_15;
        case 5:
          BOOL v6 = *(FILE **)a2;
          size_t v7 = "EXTERNAL PARAMETER, ";
LABEL_15:
          size_t v8 = 20;
LABEL_16:
          fwrite(v7, v8, 1uLL, v6);
          break;
        default:
          xmlDebugErr3(a2, 5012, "Unknown entity type %d\n", v5);
          break;
      }
      if (*(void *)(v4 + 96)) {
        fprintf(*(FILE **)a2, "ID \"%s\"", *(const char **)(v4 + 96));
      }
      if (*(void *)(v4 + 104)) {
        fprintf(*(FILE **)a2, "SYSTEM \"%s\"", *(const char **)(v4 + 104));
      }
      if (*(void *)(v4 + 72)) {
        fprintf(*(FILE **)a2, "\n orig \"%s\"", *(const char **)(v4 + 72));
      }
      if (*(_DWORD *)(v4 + 8) != 1 && *(void *)(v4 + 80)) {
        fprintf(*(FILE **)a2, "\n content \"%s\"", *(const char **)(v4 + 80));
      }
      unsigned int v10 = *(FILE **)a2;
      return fputc(10, v10);
    }
  }
  else if (!v3)
  {
    uint64_t v9 = *(FILE **)a2;
    return fwrite("Entity is NULL", 0xEuLL, 1uLL, v9);
  }
  return result;
}

_DWORD *xmlCtxtDumpDtdNode(uint64_t a1, uint64_t a2)
{
  xmlCtxtDumpSpaces(a1);
  if (*(_DWORD *)(a2 + 8) == 14)
  {
    if (!*(_DWORD *)(a1 + 144))
    {
      size_t v4 = *(FILE **)a1;
      if (*(void *)(a2 + 16)) {
        fprintf(v4, "DTD(%s)", *(const char **)(a2 + 16));
      }
      else {
        fwrite("DTD", 3uLL, 1uLL, v4);
      }
      if (*(void *)(a2 + 104)) {
        fprintf(*(FILE **)a1, ", PUBLIC %s", *(const char **)(a2 + 104));
      }
      if (*(void *)(a2 + 112)) {
        fprintf(*(FILE **)a1, ", SYSTEM %s", *(const char **)(a2 + 112));
      }
      fputc(10, *(FILE **)a1);
    }
    return (_DWORD *)xmlCtxtGenericNodeCheck(a1, a2);
  }
  else
  {
    return xmlDebugErr(a1, 5022, (char)"Node is not a DTD");
  }
}

_DWORD *xmlCtxtDumpNamespace(size_t a1, uint64_t a2)
{
  int result = (_DWORD *)xmlCtxtDumpSpaces(a1);
  if (*(_DWORD *)(a2 + 8) == 18)
  {
    if (*(void *)(a2 + 16))
    {
      if (!*(_DWORD *)(a1 + 144))
      {
        uint64_t v9 = *(FILE **)a1;
        if (*(void *)(a2 + 24)) {
          fprintf(v9, "namespace %s href=", *(const char **)(a2 + 24));
        }
        else {
          fwrite("default namespace href=", 0x17uLL, 1uLL, v9);
        }
        xmlCtxtDumpString(a1, *(void *)(a2 + 16));
        unsigned int v10 = *(FILE **)a1;
        return (_DWORD *)fputc(10, v10);
      }
      return result;
    }
    uint64_t v8 = *(void *)(a2 + 24);
    if (v8)
    {
      return xmlDebugErr3(a1, 5028, "Incomplete namespace %s href=NULL\n", v8);
    }
    int v5 = "Incomplete default namespace href=NULL\n";
    uint64_t v6 = a1;
    int v7 = 5028;
  }
  else
  {
    int v5 = "Node is not a namespace declaration";
    uint64_t v6 = a1;
    int v7 = 5027;
  }

  return xmlDebugErr(v6, v7, (char)v5);
}

xmlDictPtr xmlDictCreateSub(xmlDictPtr sub)
{
  xmlDictPtr v2 = xmlDictCreate();
  int v3 = v2;
  if (sub && v2)
  {
    *((_DWORD *)v2 + 12) = *((_DWORD *)sub + 12);
    *((void *)v2 + 5) = sub;
    xmlDictReference(sub);
  }
  return v3;
}

uint64_t xmlDictGrow(uint64_t a1, unint64_t a2)
{
  if (a2 < 8) {
    return 0xFFFFFFFFLL;
  }
  int v3 = *(void **)(a1 + 8);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  size_t v6 = 32 * a2;
  int v7 = xmlMalloc(32 * a2);
  *(void *)(a1 + 8) = v7;
  if (!v7)
  {
    *(void *)(a1 + 8) = v3;
    return 0xFFFFFFFFLL;
  }
  bzero(v7, v6);
  *(void *)(a1 + 16) = a2;
  uint64_t v8 = 0;
  if (v5)
  {
    for (uint64_t i = 0; i != v5; ++i)
    {
      unsigned int v10 = (char *)&v3[4 * i];
      if (*((_DWORD *)v10 + 5))
      {
        if (v5 == 128)
        {
          unint64_t v11 = *(void *)(a1 + 16);
          uint64_t v12 = (char *)&v3[4 * i];
          xmlXPathContextPtr v13 = (unsigned __int8 *)*((void *)v12 + 1);
          uint64_t v14 = *((unsigned int *)v12 + 4);
          if (v11 == 128)
          {
            unint64_t v15 = xmlDictComputeFastKey(v13, v14, *(_DWORD *)(a1 + 48));
            unint64_t v11 = 128;
          }
          else
          {
            if (v13) {
              BOOL v16 = (int)v14 < 1;
            }
            else {
              BOOL v16 = 1;
            }
            if (v16)
            {
              unsigned int v17 = 0;
            }
            else
            {
              unsigned int v18 = *(_DWORD *)(a1 + 48);
              do
              {
                int v19 = *v13++;
                unsigned int v18 = (1025 * (v18 + v19)) ^ ((1025 * (v18 + v19)) >> 6);
                --v14;
              }
              while (v14);
              unsigned int v17 = 32769 * ((9 * v18) ^ ((9 * v18) >> 11));
            }
            unint64_t v15 = v17;
          }
        }
        else
        {
          unint64_t v15 = v3[4 * i + 3];
          unint64_t v11 = *(void *)(a1 + 16);
        }
        unint64_t v20 = v15 % v11;
        uint64_t v21 = *(void *)(a1 + 8) + 32 * (v15 % v11);
        if (*(_DWORD *)(v21 + 20))
        {
          int v22 = xmlMalloc(0x20uLL);
          if (v22)
          {
            uint64_t v23 = (char *)&v3[4 * i];
            uint64_t v24 = *((void *)v23 + 1);
            LODWORD(v2xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = *((_DWORD *)v23 + 4);
            v22[3] = v15;
            uint64_t v25 = *(void *)(a1 + 8);
            void *v22 = *(void *)(v25 + 32 * v20);
            v22[1] = v24;
            *((_DWORD *)v22 + 4) = v23;
            *((_DWORD *)v22 + 5) = 1;
            *(void *)(v25 + 32 * v20) = v22;
          }
          else
          {
            uint64_t v8 = 0xFFFFFFFFLL;
          }
        }
        else
        {
          long long v26 = *((_OWORD *)v10 + 1);
          *(_OWORD *)uint64_t v21 = *(_OWORD *)v10;
          *(_OWORD *)(v21 + 16) = v26;
          uint64_t v27 = (void *)(*(void *)(a1 + 8) + 32 * v20);
          *uint64_t v27 = 0;
          v27[3] = v15;
        }
      }
    }
    for (uint64_t j = 0; j != v5; ++j)
    {
      xmlGenericErrorFunc v29 = (unsigned int *)v3[4 * j];
      if (v29)
      {
        do
        {
          uint64_t v30 = *(unsigned int **)v29;
          if (v5 == 128)
          {
            unint64_t v31 = *(void *)(a1 + 16);
            uint64_t v32 = (unsigned __int8 *)*((void *)v29 + 1);
            uint64_t v33 = v29[4];
            if (v31 == 128)
            {
              unint64_t v34 = xmlDictComputeFastKey(v32, v33, *(_DWORD *)(a1 + 48));
              unint64_t v31 = 128;
            }
            else
            {
              if (v32) {
                BOOL v35 = (int)v33 < 1;
              }
              else {
                BOOL v35 = 1;
              }
              if (v35)
              {
                unsigned int v36 = 0;
              }
              else
              {
                unsigned int v37 = *(_DWORD *)(a1 + 48);
                do
                {
                  int v38 = *v32++;
                  unsigned int v37 = (1025 * (v37 + v38)) ^ ((1025 * (v37 + v38)) >> 6);
                  --v33;
                }
                while (v33);
                unsigned int v36 = 32769 * ((9 * v37) ^ ((9 * v37) >> 11));
              }
              unint64_t v34 = v36;
            }
          }
          else
          {
            unint64_t v34 = *((void *)v29 + 3);
            unint64_t v31 = *(void *)(a1 + 16);
          }
          unint64_t v39 = v34 % v31;
          uint64_t v40 = *(void *)(a1 + 8) + 32 * (v34 % v31);
          if (*(_DWORD *)(v40 + 20))
          {
            *(void *)xmlGenericErrorFunc v29 = *(void *)v40;
            *((void *)v29 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = v34;
            *(void *)uint64_t v40 = v29;
          }
          else
          {
            long long v41 = *((_OWORD *)v29 + 1);
            *(_OWORD *)uint64_t v40 = *(_OWORD *)v29;
            *(_OWORD *)(v40 + 16) = v41;
            uint64_t v42 = *(void *)(a1 + 8) + 32 * v39;
            *(void *)uint64_t v42 = 0;
            *(_DWORD *)(v42 + 20) = 1;
            *(void *)(v42 + 24) = v34;
            xmlFree(v29);
          }
          xmlGenericErrorFunc v29 = v30;
        }
        while (v30);
      }
    }
  }
  xmlFree(v3);
  return v8;
}

const xmlChar *__cdecl xmlDictExists(xmlDictPtr dict, const xmlChar *name, int len)
{
  int v3 = 0;
  if (dict && name)
  {
    if (len < 0) {
      size_t v6 = strlen((const char *)name);
    }
    else {
      size_t v6 = len;
    }
    size_t v7 = *((void *)dict + 7);
    if (v7)
    {
      int v3 = 0;
      if (v6 >> 30 || v6 >= v7) {
        return v3;
      }
    }
    else if (v6 >> 30)
    {
      return 0;
    }
    unint64_t v8 = *((void *)dict + 2);
    if (v8 == 128)
    {
      unint64_t v9 = xmlDictComputeFastKey((unsigned __int8 *)name, v6, *((_DWORD *)dict + 12));
    }
    else if (v6)
    {
      unsigned int v10 = *((_DWORD *)dict + 12);
      unint64_t v11 = name;
      size_t v12 = v6;
      do
      {
        int v13 = *v11++;
        unsigned int v10 = (1025 * (v10 + v13)) ^ ((1025 * (v10 + v13)) >> 6);
        --v12;
      }
      while (v12);
      unint64_t v9 = 32769 * ((9 * v10) ^ ((9 * v10) >> 11));
    }
    else
    {
      unint64_t v9 = 0;
    }
    uint64_t v14 = *((void *)dict + 1) + 32 * (v9 % v8);
    if (!*(_DWORD *)(v14 + 20)) {
      goto LABEL_50;
    }
    while (*(void *)v14)
    {
      uint64_t v15 = v14;
      uint64_t v14 = *(void *)v14;
      if (*(void *)(v15 + 24) == v9 && v6 == *(_DWORD *)(v15 + 16))
      {
        int v3 = *(const xmlChar **)(v15 + 8);
        if (!memcmp(v3, name, v6)) {
          return v3;
        }
      }
    }
    if (*(void *)(v14 + 24) != v9
      || v6 != *(_DWORD *)(v14 + 16)
      || (int v3 = *(const xmlChar **)(v14 + 8), memcmp(v3, name, v6)))
    {
LABEL_50:
      uint64_t v16 = *((void *)dict + 5);
      if (!v16) {
        return 0;
      }
      unint64_t v17 = *(void *)(v16 + 16);
      if (v8 == 128)
      {
        if (v17 != 128)
        {
          if ((int)v6 < 1)
          {
            unint64_t v9 = 0;
          }
          else
          {
            unsigned int v18 = *(_DWORD *)(v16 + 48);
            uint64_t v19 = v6;
            unint64_t v20 = name;
            do
            {
              int v21 = *v20++;
              unsigned int v18 = (1025 * (v18 + v21)) ^ ((1025 * (v18 + v21)) >> 6);
              --v19;
            }
            while (v19);
            unint64_t v9 = 32769 * ((9 * v18) ^ ((9 * v18) >> 11));
          }
        }
      }
      else if (v17 == 128)
      {
        unint64_t v9 = xmlDictComputeFastKey((unsigned __int8 *)name, v6, *(_DWORD *)(v16 + 48));
        unint64_t v17 = 128;
      }
      uint64_t v22 = *(void *)(v16 + 8) + 32 * (v9 % v17);
      if (!*(_DWORD *)(v22 + 20)) {
        return 0;
      }
      while (*(void *)v22)
      {
        uint64_t v23 = v22;
        uint64_t v22 = *(void *)v22;
        if (*(void *)(v23 + 24) == v9 && v6 == *(_DWORD *)(v23 + 16))
        {
          int v3 = *(const xmlChar **)(v23 + 8);
          if (!memcmp(v3, name, v6)) {
            return v3;
          }
        }
      }
      if (*(void *)(v22 + 24) != v9) {
        return 0;
      }
      if (v6 != *(_DWORD *)(v22 + 16)) {
        return 0;
      }
      int v3 = *(const xmlChar **)(v22 + 8);
      if (memcmp(v3, name, v6)) {
        return 0;
      }
    }
  }
  return v3;
}

const xmlChar *__cdecl xmlDictQLookup(xmlDictPtr dict, const xmlChar *prefix, const xmlChar *name)
{
  int v3 = 0;
  if (!dict || !name) {
    return v3;
  }
  if (prefix)
  {
    size_t v7 = strlen((const char *)name);
    size_t v8 = strlen((const char *)prefix);
    int v3 = 0;
    if (v7 >> 30 || v8 >> 30) {
      return v3;
    }
    size_t v9 = v8 + v7;
    unint64_t v10 = *((void *)dict + 2);
    unsigned int v11 = *((_DWORD *)dict + 12);
    unsigned int v42 = v8;
    if (v10 == 128) {
      unint64_t v12 = xmlDictComputeFastQKey((unsigned __int8 *)prefix, v8, (unsigned __int8 *)name, v7, v11);
    }
    else {
      unint64_t v12 = xmlDictComputeBigQKey((unsigned __int8 *)prefix, v8, (unsigned __int8 *)name, v7, v11);
    }
    unint64_t v14 = v12;
    int v41 = v9;
    size_t v15 = v9 + 1;
    unint64_t v16 = v12 % v10;
    uint64_t v17 = *((void *)dict + 1) + 32 * v16;
    unsigned int v43 = v7;
    if (*(_DWORD *)(v17 + 20))
    {
      unsigned int v18 = *(void **)v17;
      if (*(void *)v17)
      {
        unint64_t v19 = 0;
        do
        {
          if (*(void *)(v17 + 24) == v14 && v15 == *(_DWORD *)(v17 + 16))
          {
            if (xmlStrQEqual(prefix, name, *(const xmlChar **)(v17 + 8))) {
              return *(const xmlChar **)(v17 + 8);
            }
            unsigned int v18 = *(void **)v17;
          }
          uint64_t v17 = (uint64_t)v18;
          ++v19;
          unsigned int v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        unint64_t v19 = 0;
      }
      if (*(void *)(v17 + 24) == v14
        && v15 == *(_DWORD *)(v17 + 16)
        && xmlStrQEqual(prefix, name, *(const xmlChar **)(v17 + 8)))
      {
        return *(const xmlChar **)(v17 + 8);
      }
    }
    else
    {
      unint64_t v19 = 0;
      uint64_t v17 = 0;
    }
    uint64_t v20 = *((void *)dict + 5);
    if (!v20)
    {
LABEL_47:
      long long v26 = (void *)*((void *)dict + 4);
      if (v26)
      {
        unint64_t v27 = 0;
        unint64_t v28 = 0;
        do
        {
          int v3 = (xmlChar *)v26[1];
          if (v26[2] - (void)v3 > (unint64_t)v15)
          {
            unint64_t v40 = v16;
            goto LABEL_66;
          }
          unint64_t v29 = v26[3];
          if (v29 > v28) {
            unint64_t v28 = v26[3];
          }
          v27 += v29;
          long long v26 = (void *)*v26;
        }
        while (v26);
        unint64_t v30 = *((void *)dict + 7);
        if (v30) {
          BOOL v31 = v27 > v30;
        }
        else {
          BOOL v31 = 0;
        }
        if (v31) {
          return 0;
        }
        if (!v28) {
          goto LABEL_59;
        }
        unint64_t v40 = v16;
        unint64_t v32 = 4 * v28;
      }
      else
      {
LABEL_59:
        unint64_t v40 = v16;
        unint64_t v32 = 1000;
      }
      if (v32 <= (4 * v41 + 4)) {
        unint64_t v33 = (4 * v41 + 4);
      }
      else {
        unint64_t v33 = v32;
      }
      unint64_t v34 = xmlMalloc(v33 + 48);
      if (v34)
      {
        long long v26 = v34;
        v34[3] = v33;
        v34[4] = 0;
        int v3 = (xmlChar *)(v34 + 5);
        v34[2] = (char *)v34 + v33 + 40;
        void *v34 = *((void *)dict + 4);
        v34[1] = v34 + 5;
        *((void *)dict + 4) = v34;
LABEL_66:
        memcpy(v3, prefix, v42);
        BOOL v35 = (unsigned char *)(v26[1] + v42);
        v26[1] = v35 + 1;
        *BOOL v35 = 58;
        memcpy((void *)v26[1], name, v43);
        unsigned int v36 = (unsigned char *)(v26[1] + v43);
        v26[1] = v36 + 1;
        unsigned char *v36 = 0;
        ++v26[4];
        if (!v3) {
          return v3;
        }
        if (!v17)
        {
          uint64_t v38 = *((void *)dict + 1) + 32 * v40;
          *(void *)uint64_t v38 = 0;
          *(void *)(v38 + 8) = v3;
          *(_DWORD *)(v38 + 16) = v15;
          *(_DWORD *)(v38 + 20) = 1;
          *(void *)(v38 + 24) = v14;
LABEL_72:
          ++*((_DWORD *)dict + 6);
          if (v19 >= 4)
          {
            unint64_t v39 = *((void *)dict + 2);
            if (v39 <= 0xAAA) {
              xmlDictGrow((uint64_t)dict, 6 * v39);
            }
          }
          return v3;
        }
        unsigned int v37 = xmlMalloc(0x20uLL);
        if (v37)
        {
          *unsigned int v37 = 0;
          v37[1] = v3;
          *((_DWORD *)v37 + 4) = v15;
          *((_DWORD *)v37 + 5) = 1;
          v37[3] = v14;
          *(void *)uint64_t v17 = v37;
          goto LABEL_72;
        }
      }
      return 0;
    }
    unint64_t v21 = *(void *)(v20 + 16);
    if (*((void *)dict + 2) == 128)
    {
      if (v21 == 128)
      {
        unint64_t v22 = v14;
        goto LABEL_35;
      }
      uint64_t v23 = xmlDictComputeBigQKey((unsigned __int8 *)prefix, v42, (unsigned __int8 *)name, v43, *(_DWORD *)(v20 + 48));
    }
    else
    {
      unint64_t v22 = v14;
      if (v21 != 128) {
        goto LABEL_35;
      }
      uint64_t v23 = xmlDictComputeFastQKey((unsigned __int8 *)prefix, v42, (unsigned __int8 *)name, v43, *(_DWORD *)(v20 + 48));
    }
    unint64_t v22 = v23;
LABEL_35:
    uint64_t v24 = *(void *)(v20 + 8) + 32 * (v22 % v21);
    if (*(_DWORD *)(v24 + 20))
    {
      uint64_t v25 = *(void **)v24;
      if (*(void *)v24)
      {
        do
        {
          if (*(void *)(v24 + 24) == v22 && v15 == *(_DWORD *)(v24 + 16))
          {
            if (xmlStrQEqual(prefix, name, *(const xmlChar **)(v24 + 8))) {
              return *(const xmlChar **)(v24 + 8);
            }
            uint64_t v25 = *(void **)v24;
          }
          uint64_t v24 = (uint64_t)v25;
          ++v19;
          uint64_t v25 = (void *)*v25;
        }
        while (v25);
      }
      if (*(void *)(v24 + 24) == v22
        && v15 == *(_DWORD *)(v24 + 16)
        && xmlStrQEqual(prefix, name, *(const xmlChar **)(v24 + 8)))
      {
        return *(const xmlChar **)(v24 + 8);
      }
    }
    unint64_t v16 = v14 % *((void *)dict + 2);
    goto LABEL_47;
  }

  return xmlDictLookup(dict, name, -1);
}

uint64_t xmlDictComputeFastQKey(unsigned __int8 *a1, int a2, unsigned __int8 *a3, int a4, int a5)
{
  if (a2) {
    uint64_t v5 = a5 + 30 * *a1;
  }
  else {
    uint64_t v5 = a5 + 1740;
  }
  unsigned int v6 = a4 - 11;
  if (a4 >= 11)
  {
    if (a4 - a2 - 2 >= 0) {
      unsigned int v6 = a4 - a2 - 2;
    }
    v5 += a3[v6];
    a4 = 10;
    if (a2 >= 10) {
      a2 = 10;
    }
  }
  switch(a2)
  {
    case 1:
      goto LABEL_19;
    case 2:
      goto LABEL_18;
    case 3:
      goto LABEL_17;
    case 4:
      goto LABEL_16;
    case 5:
      goto LABEL_15;
    case 6:
      goto LABEL_14;
    case 7:
      goto LABEL_13;
    case 8:
      goto LABEL_12;
    case 9:
      goto LABEL_11;
    case 10:
      v5 += a1[9];
LABEL_11:
      v5 += a1[8];
LABEL_12:
      v5 += a1[7];
LABEL_13:
      v5 += a1[6];
LABEL_14:
      v5 += a1[5];
LABEL_15:
      v5 += a1[4];
LABEL_16:
      v5 += a1[3];
LABEL_17:
      v5 += a1[2];
LABEL_18:
      v5 += a1[1];
LABEL_19:
      v5 += *a1;
      break;
    default:
      break;
  }
  if (a4 <= a2) {
    uint64_t result = v5;
  }
  else {
    uint64_t result = v5 + 58;
  }
  switch(~(a4 > a2) + a4 - a2)
  {
    case 0:
      goto LABEL_32;
    case 1:
      goto LABEL_31;
    case 2:
      goto LABEL_30;
    case 3:
      goto LABEL_29;
    case 4:
      goto LABEL_28;
    case 5:
      goto LABEL_27;
    case 6:
      goto LABEL_26;
    case 7:
      goto LABEL_25;
    case 8:
      result += a3[8];
LABEL_25:
      result += a3[7];
LABEL_26:
      result += a3[6];
LABEL_27:
      result += a3[5];
LABEL_28:
      result += a3[4];
LABEL_29:
      result += a3[3];
LABEL_30:
      result += a3[2];
LABEL_31:
      result += a3[1];
LABEL_32:
      result += *a3;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t xmlDictComputeBigQKey(unsigned __int8 *a1, int a2, unsigned __int8 *a3, int a4, unsigned int a5)
{
  if (a2 >= 1)
  {
    uint64_t v5 = a2;
    do
    {
      int v6 = *a1++;
      a5 = (1025 * (a5 + v6)) ^ ((1025 * (a5 + v6)) >> 6);
      --v5;
    }
    while (v5);
  }
  unsigned int v7 = (1025 * a5 + 59450) ^ ((1025 * a5 + 59450) >> 6);
  if (a4 >= 1)
  {
    uint64_t v8 = a4;
    do
    {
      int v9 = *a3++;
      unsigned int v7 = (1025 * (v7 + v9)) ^ ((1025 * (v7 + v9)) >> 6);
      --v8;
    }
    while (v8);
  }
  return 32769 * ((9 * v7) ^ ((9 * v7) >> 11));
}

int xmlDictSize(xmlDictPtr dict)
{
  if (!dict) {
    return -1;
  }
  uint64_t v1 = *((void *)dict + 5);
  int result = *((_DWORD *)dict + 6);
  if (v1) {
    result += *(_DWORD *)(v1 + 24);
  }
  return result;
}

size_t xmlDictGetUsage(size_t dict)
{
  if (dict)
  {
    uint64_t v1 = *(void **)(dict + 32);
    if (v1)
    {
      dict = 0;
      do
      {
        dict += v1[3];
        uint64_t v1 = (void *)*v1;
      }
      while (v1);
    }
    else
    {
      return 0;
    }
  }
  return dict;
}

int docbEncodeEntities(unsigned __int8 *out, int *outlen, const unsigned __int8 *in, int *inlen, int quoteChar)
{
  if ((docbEncodeEntities_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v5 = *__xmlGenericError();
    int v6 = __xmlGenericErrorContext();
    v5(*v6, "docbEncodeEntities() deprecated function reached\n");
    docbEncodeEntities_deprecated = 1;
  }
  return -1;
}

int docbParseDocument(docbParserCtxtPtr ctxt)
{
  if ((docbParseDocument_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    int v3 = __xmlGenericErrorContext();
    v2(*v3, "docbParseDocument() deprecated function reached\n");
    docbParseDocument_deprecated = 1;
  }

  return xmlParseDocument(ctxt);
}

void docbFreeParserCtxt(docbParserCtxtPtr ctxt)
{
  if ((docbFreeParserCtxt_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    int v3 = __xmlGenericErrorContext();
    v2(*v3, "docbFreeParserCtxt() deprecated function reached\n");
    docbFreeParserCtxt_deprecated = 1;
  }

  xmlFreeParserCtxt(ctxt);
}

int docbParseChunk(docbParserCtxtPtr ctxt, const char *chunk, int size, int terminate)
{
  if ((docbParseChunk_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v8 = *__xmlGenericError();
    int v9 = __xmlGenericErrorContext();
    v8(*v9, "docbParseChunk() deprecated function reached\n");
    docbParseChunk_deprecated = 1;
  }

  return xmlParseChunk(ctxt, chunk, size, terminate);
}

docbParserCtxtPtr docbCreatePushParserCtxt(docbSAXHandlerPtr sax, void *user_data, const char *chunk, int size, const char *filename, xmlCharEncoding enc)
{
  if ((docbCreatePushParserCtxt_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v11 = *__xmlGenericError();
    unint64_t v12 = __xmlGenericErrorContext();
    v11(*v12, "docbParseChunk() deprecated function reached\n");
    docbCreatePushParserCtxt_deprecated = 1;
  }

  return xmlCreatePushParserCtxt(sax, user_data, chunk, size, filename);
}

docbDocPtr docbSAXParseDoc(xmlChar *cur, const char *encoding, docbSAXHandlerPtr sax, void *userData)
{
  if ((docbSAXParseDoc_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v7 = *__xmlGenericError();
    xmlGenericErrorFunc v8 = __xmlGenericErrorContext();
    v7(*v8, "docbParseChunk() deprecated function reached\n");
    docbSAXParseDoc_deprecated = 1;
  }
  int v9 = xmlStrlen(cur);

  return xmlSAXParseMemoryWithData(sax, (const char *)cur, v9, 0, userData);
}

docbDocPtr docbParseDoc(xmlChar *cur, const char *encoding)
{
  if ((docbParseDoc_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    size_t v4 = __xmlGenericErrorContext();
    v3(*v4, "docbParseChunk() deprecated function reached\n");
    docbParseDoc_deprecated = 1;
  }

  return xmlParseDoc(cur);
}

docbParserCtxtPtr docbCreateFileParserCtxt(const char *filename, const char *encoding)
{
  if ((docbCreateFileParserCtxt_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    size_t v4 = __xmlGenericErrorContext();
    v3(*v4, "docbCreateFileParserCtxt() deprecated function reached\n");
    docbCreateFileParserCtxt_deprecated = 1;
  }

  return xmlCreateFileParserCtxt(filename);
}

docbDocPtr docbSAXParseFile(const char *filename, const char *encoding, docbSAXHandlerPtr sax, void *userData)
{
  if ((docbSAXParseFile_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v7 = *__xmlGenericError();
    xmlGenericErrorFunc v8 = __xmlGenericErrorContext();
    v7(*v8, "docbSAXParseFile() deprecated function reached\n");
    docbSAXParseFile_deprecated = 1;
  }

  return xmlSAXParseFileWithData(sax, filename, 0, userData);
}

docbDocPtr docbParseFile(const char *filename, const char *encoding)
{
  if ((docbParseFile_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    size_t v4 = __xmlGenericErrorContext();
    v3(*v4, "docbParseFile() deprecated function reached\n");
    docbParseFile_deprecated = 1;
  }

  return xmlParseFile(filename);
}

int isolat1ToUTF8(unsigned __int8 *out, int *outlen, const unsigned __int8 *in, int *inlen)
{
  int v4 = -1;
  if (inlen && outlen && out && in)
  {
    xmlGenericErrorFunc v5 = &out[*outlen];
    uint64_t v6 = *inlen;
    BOOL v7 = v6 > 0;
    if ((int)v6 < 1)
    {
      xmlGenericErrorFunc v8 = out;
      int v9 = in;
    }
    else
    {
      xmlGenericErrorFunc v8 = out;
      int v9 = in;
      if (v5 - 1 > out)
      {
        unint64_t v10 = &in[v6];
        xmlGenericErrorFunc v11 = v10;
        int v9 = in;
        xmlGenericErrorFunc v8 = out;
        do
        {
          int v12 = *(char *)v9;
          if (v12 < 0)
          {
            *xmlGenericErrorFunc v8 = (v12 >> 6) | 0xC0;
            char v13 = *v9++;
            v8[1] = v13 & 0x3F | 0x80;
            v8 += 2;
          }
          if (v11 - v9 > v5 - v8) {
            xmlGenericErrorFunc v11 = &v9[v5 - v8];
          }
          if (v9 < v11)
          {
            int64_t v14 = v11 - v9;
            while (1)
            {
              int v15 = *(char *)v9;
              if (v15 < 0) {
                break;
              }
              ++v9;
              *v8++ = v15;
              if (!--v14)
              {
                int v9 = v11;
                break;
              }
            }
          }
          BOOL v7 = v9 < v10;
        }
        while (v9 < v10 && v8 < v5 - 1);
      }
    }
    if (v7 && v8 < v5)
    {
      int v16 = *(char *)v9;
      if ((v16 & 0x80000000) == 0)
      {
        LODWORD(v9) = v9 + 1;
        *xmlGenericErrorFunc v8 = v16;
        LODWORD(v8) = v8 + 1;
      }
    }
    *outint len = v8 - out;
    *inint len = v9 - in;
    return *outlen;
  }
  return v4;
}

int UTF8Toisolat1(unsigned __int8 *out, int *outlen, const unsigned __int8 *in, int *inlen)
{
  int v4 = -1;
  if (out && outlen && inlen)
  {
    if (in)
    {
      uint64_t v5 = *inlen;
      LODWORD(v6) = out;
      LODWORD(v7) = in;
      if ((int)v5 >= 1)
      {
        xmlGenericErrorFunc v8 = &in[v5];
        int v9 = &out[*outlen];
        int v10 = (int)in;
        uint64_t v6 = out;
        BOOL v7 = in;
        while (1)
        {
          int v11 = *(char *)v7++;
          unsigned int v12 = v11;
          if (v11 < 0)
          {
            if (v12 <= 0xBF) {
              goto LABEL_31;
            }
            if (v12 > 0xDF)
            {
              if (v12 > 0xEF)
              {
                if (v12 > 0xF7) {
                  goto LABEL_31;
                }
                int v14 = v12 & 7;
                unsigned int v13 = 3;
              }
              else
              {
                int v14 = v12 & 0xF;
                unsigned int v13 = 2;
              }
            }
            else
            {
              int v14 = v12 & 0x1F;
              unsigned int v13 = 1;
            }
          }
          else
          {
            unsigned int v13 = 0;
            int v14 = v12;
          }
          if (v8 - v7 < v13) {
            break;
          }
          if ((v12 & 0x80) != 0 && v7 < v8)
          {
            unsigned int v15 = v13 - 1;
            while (1)
            {
              unsigned __int8 v16 = *v7;
              if ((*v7 & 0xC0) != 0x80) {
                break;
              }
              ++v7;
              unsigned int v17 = v16 & 0x3F | (v14 << 6);
              if (v15-- != 0)
              {
                int v14 = v17;
                if (v7 < v8) {
                  continue;
                }
              }
              if (v17 <= 0xFF) {
                goto LABEL_27;
              }
              break;
            }
LABEL_31:
            *outint len = v6 - out;
            *inint len = v10 - in;
            return -2;
          }
          LOBYTE(v17) = v14;
LABEL_27:
          if (v6 >= v9) {
            break;
          }
          *v6++ = v17;
          int v10 = (int)v7;
          if (v7 >= v8) {
            goto LABEL_33;
          }
        }
        LODWORD(v7) = v10;
      }
LABEL_33:
      *outint len = v6 - out;
      *inint len = v7 - in;
      return *outlen;
    }
    else
    {
      int v4 = 0;
      *outint len = 0;
      *inint len = 0;
    }
  }
  return v4;
}

void xmlCleanupEncodingAliases(void)
{
  xmlGenericErrorFunc v0 = (char *)xmlCharEncodingAliases;
  if (xmlCharEncodingAliases)
  {
    if (xmlCharEncodingAliasesNb >= 1)
    {
      uint64_t v1 = 0;
      uint64_t v2 = 0;
      do
      {
        if (*(void *)&v0[v1])
        {
          xmlFree(*(void **)&v0[v1]);
          xmlGenericErrorFunc v0 = (char *)xmlCharEncodingAliases;
        }
        if (*(void *)&v0[v1 + 8])
        {
          xmlFree(*(void **)&v0[v1 + 8]);
          xmlGenericErrorFunc v0 = (char *)xmlCharEncodingAliases;
        }
        ++v2;
        v1 += 16;
      }
      while (v2 < xmlCharEncodingAliasesNb);
    }
    xmlCharEncodingAliasesNb = 0;
    xmlCharEncodingAliasesMax = 0;
    xmlFree(v0);
    xmlCharEncodingAliases = 0;
  }
}

int xmlAddEncodingAlias(const char *name, const char *alias)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  int result = -1;
  if (!name || !alias) {
    return result;
  }
  uint64_t v5 = 0;
  int v16 = 0;
  memset(v15, 0, sizeof(v15));
  do
  {
    char v6 = __toupper(alias[v5]);
    *((unsigned char *)v15 + v5) = v6;
    if (!v6) {
      break;
    }
    ++v5;
  }
  while (v5 != 99);
  *((unsigned char *)v15 + v5) = 0;
  BOOL v7 = (char *)xmlCharEncodingAliases;
  if (xmlCharEncodingAliases)
  {
    int v8 = xmlCharEncodingAliasesNb;
    uint64_t v9 = xmlCharEncodingAliasesMax;
    if (xmlCharEncodingAliasesNb < xmlCharEncodingAliasesMax) {
      goto LABEL_11;
    }
    xmlCharEncodingAliasesMax *= 2;
    BOOL v7 = (char *)xmlRealloc((void *)xmlCharEncodingAliases, 32 * v9);
    xmlCharEncodingAliases = (uint64_t)v7;
  }
  else
  {
    xmlCharEncodingAliasesNb = 0;
    xmlCharEncodingAliasesMax = 20;
    BOOL v7 = (char *)xmlMalloc(0x140uLL);
    xmlCharEncodingAliases = (uint64_t)v7;
    if (!v7) {
      return -1;
    }
  }
  int v8 = xmlCharEncodingAliasesNb;
LABEL_11:
  if (v8 < 1)
  {
LABEL_15:
    *(void *)(xmlCharEncodingAliases + 16 * xmlCharEncodingAliasesNb) = xmlMemStrdup(name);
    unsigned int v12 = xmlMemStrdup((const char *)v15);
    int result = 0;
    int v13 = xmlCharEncodingAliasesNb;
    *(void *)(xmlCharEncodingAliases + 16 * xmlCharEncodingAliasesNb + 8) = v12;
    xmlCharEncodingAliasesNb = v13 + 1;
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v11 = 16 * v8;
    while (strcmp(*(const char **)&v7[v10 + 8], (const char *)v15))
    {
      v10 += 16;
      if (v11 == v10) {
        goto LABEL_15;
      }
    }
    xmlFree(*(void **)&v7[v10]);
    int v14 = xmlMemStrdup(name);
    int result = 0;
    *(void *)(xmlCharEncodingAliases + v10) = v14;
  }
  return result;
}

int xmlDelEncodingAlias(const char *alias)
{
  int result = -1;
  if (alias)
  {
    uint64_t v3 = xmlCharEncodingAliases;
    if (xmlCharEncodingAliases)
    {
      uint64_t v4 = xmlCharEncodingAliasesNb;
      if (xmlCharEncodingAliasesNb >= 1)
      {
        uint64_t v5 = 0;
        for (uint64_t i = 8; strcmp(*(const char **)(v3 + i), alias); i += 16)
        {
          if (v4 == ++v5) {
            return -1;
          }
        }
        xmlFree(*(void **)(v3 + i - 8));
        xmlFree(*(void **)(xmlCharEncodingAliases + i));
        uint64_t v7 = xmlCharEncodingAliasesNb--;
        memmove((void *)(xmlCharEncodingAliases + i - 8), (const void *)(xmlCharEncodingAliases + i + 8), 16 * (v7 - v5) - 16);
        return 0;
      }
    }
  }
  return result;
}

xmlCharEncoding xmlParseCharEncoding(const char *name)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (name)
  {
    uint64_t v1 = name;
    int v29 = 0;
    memset(v28, 0, sizeof(v28));
    EncodingAlias = xmlGetEncodingAlias(name);
    uint64_t v3 = 0;
    if (EncodingAlias) {
      uint64_t v1 = EncodingAlias;
    }
    do
    {
      char v4 = __toupper(v1[v3]);
      *((unsigned char *)v28 + vxmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = v4;
      if (!v4) {
        break;
      }
      ++v3;
    }
    while (v3 != 499);
    *((unsigned char *)v28 + vxmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0;
    if (LOBYTE(v28[0]))
    {
      BOOL v5 = LODWORD(v28[0]) == 759583829 && WORD2(v28[0]) == 56;
      if (v5 || !(LODWORD(v28[0]) ^ 0x38465455 | BYTE4(v28[0])))
      {
        LODWORD(name) = 1;
      }
      else
      {
        BOOL v6 = LODWORD(v28[0]) == 759583829 && *(_DWORD *)((char *)v28 + 3) == 3551533;
        if (v6 || (LODWORD(v28[0]) == 826692693 ? (BOOL v7 = WORD2(v28[0]) == 54) : (BOOL v7 = 0), v7))
        {
          LODWORD(name) = 2;
        }
        else
        {
          BOOL v8 = *(void *)&v28[0] == 0x343630312D4F5349 && *((void *)&v28[0] + 1) == 0x322D5343552D36;
          if (v8
            || (LODWORD(v28[0]) == 760431445 ? (BOOL v9 = WORD2(v28[0]) == 50) : (BOOL v9 = 0),
                v9 || !(LODWORD(v28[0]) ^ 0x32534355 | BYTE4(v28[0]))))
          {
            LODWORD(name) = 9;
          }
          else
          {
            BOOL v10 = *(void *)&v28[0] == 0x343630312D4F5349 && *((void *)&v28[0] + 1) == 0x342D5343552D36;
            if (v10
              || (LODWORD(v28[0]) == 760431445 ? (BOOL v11 = WORD2(v28[0]) == 52) : (BOOL v11 = 0),
                  v11 || !(LODWORD(v28[0]) ^ 0x34534355 | BYTE4(v28[0]))))
            {
              LODWORD(name) = 4;
            }
            else
            {
              BOOL v12 = *(void *)&v28[0] == 0x393538382D4F5349 && *(void *)((char *)v28 + 3) == 0x312D393538382DLL;
              if (v12
                || (*(void *)&v28[0] == 0x4954414C2D4F5349 ? (BOOL v13 = DWORD2(v28[0]) == 3222862) : (BOOL v13 = 0),
                    v13
                 || (*(void *)&v28[0] == 0x4954414C204F5349 ? (BOOL v14 = DWORD2(v28[0]) == 3219534) : (BOOL v14 = 0), v14)))
              {
                LODWORD(name) = 10;
              }
              else
              {
                BOOL v15 = *(void *)&v28[0] == 0x393538382D4F5349 && *(void *)((char *)v28 + 3) == 0x322D393538382DLL;
                if (v15
                  || (*(void *)&v28[0] == 0x4954414C2D4F5349 ? (BOOL v16 = DWORD2(v28[0]) == 3288398) : (BOOL v16 = 0),
                      v16
                   || (*(void *)&v28[0] == 0x4954414C204F5349 ? (BOOL v17 = DWORD2(v28[0]) == 3285070) : (BOOL v17 = 0), v17)))
                {
                  LODWORD(name) = 11;
                }
                else if (*(void *)&v28[0] == 0x393538382D4F5349 {
                       && *(void *)((char *)v28 + 3) == 0x332D393538382DLL)
                }
                {
                  LODWORD(name) = 12;
                }
                else if (*(void *)&v28[0] == 0x393538382D4F5349 {
                       && *(void *)((char *)v28 + 3) == 0x342D393538382DLL)
                }
                {
                  LODWORD(name) = 13;
                }
                else if (*(void *)&v28[0] == 0x393538382D4F5349 {
                       && *(void *)((char *)v28 + 3) == 0x352D393538382DLL)
                }
                {
                  LODWORD(name) = 14;
                }
                else if (*(void *)&v28[0] == 0x393538382D4F5349 {
                       && *(void *)((char *)v28 + 3) == 0x362D393538382DLL)
                }
                {
                  LODWORD(name) = 15;
                }
                else if (*(void *)&v28[0] == 0x393538382D4F5349 {
                       && *(void *)((char *)v28 + 3) == 0x372D393538382DLL)
                }
                {
                  LODWORD(name) = 16;
                }
                else if (*(void *)&v28[0] == 0x393538382D4F5349 {
                       && *(void *)((char *)v28 + 3) == 0x382D393538382DLL)
                }
                {
                  LODWORD(name) = 17;
                }
                else if (*(void *)&v28[0] == 0x393538382D4F5349 {
                       && *(void *)((char *)v28 + 3) == 0x392D393538382DLL)
                }
                {
                  LODWORD(name) = 18;
                }
                else if (*(void *)&v28[0] == 0x323230322D4F5349 && DWORD2(v28[0]) == 5261869)
                {
                  LODWORD(name) = 19;
                }
                else if (*(void *)&v28[0] == 0x494A5F5446494853 && WORD4(v28[0]) == 83)
                {
                  LODWORD(name) = 20;
                }
                else if (LODWORD(v28[0]) ^ 0x2D435545 | *(_DWORD *)((char *)v28 + 3) ^ 0x504A2D)
                {
                  LODWORD(name) = -1;
                }
                else
                {
                  LODWORD(name) = 21;
                }
              }
            }
          }
        }
      }
    }
    else
    {
      LODWORD(name) = 0;
    }
  }
  return (int)name;
}

const char *__cdecl xmlGetCharEncodingName(xmlCharEncoding enc)
{
  if ((enc - 1) > 0x14) {
    return 0;
  }
  else {
    return off_1E60C7118[enc - 1];
  }
}

uint64_t UTF8ToUTF8(void *__dst, unsigned int *a2, void *__src, _DWORD *a4)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (__dst && a2 && a4)
  {
    if (__src)
    {
      if ((signed int)*a2 >= *a4) {
        size_t v8 = *a4;
      }
      else {
        size_t v8 = *a2;
      }
      if ((v8 & 0x80000000) != 0)
      {
        return 0xFFFFFFFFLL;
      }
      else
      {
        memcpy(__dst, __src, v8);
        *a2 = v8;
        *a4 = v8;
        return *a2;
      }
    }
    else
    {
      uint64_t result = 0;
      *a2 = 0;
      *a4 = 0;
    }
  }
  return result;
}

uint64_t UTF16LEToUTF8(unsigned char *a1, unsigned int *a2, unsigned __int16 *a3, int *a4)
{
  uint64_t v4 = (int)*a2;
  if (!v4)
  {
    uint64_t result = 0;
    *a4 = 0;
    return result;
  }
  int v5 = *a4;
  if ((*a4 & 0x80000001) == 1) {
    *a4 = --v5;
  }
  if (v5 >= 0) {
    int v6 = v5;
  }
  else {
    int v6 = v5 + 1;
  }
  unsigned int v7 = v5 + 1;
  LODWORD(v8) = a1;
  LODWORD(v9) = a3;
  if (v7 < 3)
  {
LABEL_39:
    *a2 = v8 - a1;
    *a4 = v9 - a3;
    return *a2;
  }
  unint64_t v10 = (unint64_t)&a1[v4];
  BOOL v9 = a3;
  size_t v8 = a1;
  unint64_t v11 = (unint64_t)&a3[v6 >> 1];
  while (1)
  {
    BOOL v12 = v9;
    if (v8 - a1 + 5 >= (int)*a2)
    {
LABEL_38:
      LODWORD(v9) = v12;
      goto LABEL_39;
    }
    ++v9;
    unsigned int v13 = *v12;
    if ((v13 & 0xFC00) == 0xD800) {
      break;
    }
LABEL_14:
    if ((unint64_t)v8 >= v10) {
      goto LABEL_38;
    }
    if (v13 <= 0x7F)
    {
      *v8++ = v13;
    }
    else
    {
      if (v13 >= 0x10000) {
        char v15 = 18;
      }
      else {
        char v15 = 12;
      }
      if (v13 >= 0x10000) {
        char v16 = -16;
      }
      else {
        char v16 = -32;
      }
      if (v13 < 0x800)
      {
        char v15 = 6;
        char v16 = -64;
      }
      *v8++ = v16 | (v13 >> v15);
      if ((unint64_t)v8 < v10)
      {
        if (v13 >= 0x10000) {
          unsigned int v17 = 12;
        }
        else {
          unsigned int v17 = 6;
        }
        if (v13 < 0x800) {
          unsigned int v17 = 0;
        }
        do
        {
          *v8++ = (v13 >> v17) & 0x3F | 0x80;
          BOOL v18 = v17 >= 6;
          v17 -= 6;
        }
        while (v18 && (unint64_t)v8 < v10);
      }
    }
    if ((unint64_t)v9 >= v11) {
      goto LABEL_39;
    }
  }
  if ((unint64_t)v9 >= v11) {
    goto LABEL_38;
  }
  unsigned __int16 v14 = *v9;
  if ((*v9 & 0xFC00) == 0xDC00)
  {
    BOOL v9 = v12 + 2;
    unsigned int v13 = (v14 & 0x3FF | ((v13 & 0x3FF) << 10)) + 0x10000;
    goto LABEL_14;
  }
  *a2 = v8 - a1;
  *a4 = v12 - a3;
  return 4294967294;
}

uint64_t UTF8ToUTF16LE(_WORD *a1, int *a2, char *a3, int *a4)
{
  uint64_t v4 = 0xFFFFFFFFLL;
  if (a1 && a2 && a4)
  {
    if (a3)
    {
      uint64_t v5 = *a4;
      if (*a2 >= 0) {
        int v6 = *a2;
      }
      else {
        int v6 = *a2 + 1;
      }
      LODWORD(v7) = a1;
      LODWORD(v8) = a3;
      if ((int)v5 >= 1)
      {
        unint64_t v9 = (unint64_t)&a3[v5];
        unint64_t v10 = (unint64_t)&a1[v6 >> 1];
        unint64_t v11 = a3;
        unsigned int v7 = a1;
        size_t v8 = a3;
        do
        {
          int v12 = *v8++;
          unsigned int v13 = v12;
          if (v12 < 0)
          {
            if (v13 <= 0xBF) {
              goto LABEL_38;
            }
            if (v13 > 0xDF)
            {
              if (v13 > 0xEF)
              {
                if (v13 > 0xF7)
                {
LABEL_38:
                  *a2 = v7 - a1;
                  *a4 = v11 - a3;
                  return 4294967294;
                }
                unsigned int v15 = v13 & 7;
                uint64_t v14 = 3;
              }
              else
              {
                unsigned int v15 = v13 & 0xF;
                uint64_t v14 = 2;
              }
            }
            else
            {
              unsigned int v15 = v13 & 0x1F;
              uint64_t v14 = 1;
            }
          }
          else
          {
            uint64_t v14 = 0;
            unsigned int v15 = v13;
          }
          if ((uint64_t)(v9 - (void)v8) < v14) {
            goto LABEL_35;
          }
          if ((v13 & 0x80) == 0 || (unint64_t)v8 >= v9) {
            goto LABEL_27;
          }
          uint64_t v16 = 0;
          int v17 = v14 - 1;
          do
          {
            size_t v8 = &v11[v16 + 2];
            char v18 = v11[v16 + 1];
            if ((v18 & 0xC0) != 0x80) {
              break;
            }
            unsigned int v15 = v18 & 0x3F | (v15 << 6);
            if (v17 == v16) {
              break;
            }
            ++v16;
          }
          while ((unint64_t)v8 < v9);
          if (HIWORD(v15))
          {
            if (HIWORD(v15) > 0x10u || (unint64_t)(v7 + 1) >= v10)
            {
LABEL_35:
              LODWORD(v8) = v11;
              break;
            }
            _WORD *v7 = ((v15 + 16711680) >> 10) | 0xD800;
            v7[1] = v15 & 0x3FF | 0xDC00;
            v7 += 2;
          }
          else
          {
LABEL_27:
            if ((unint64_t)v7 >= v10) {
              goto LABEL_35;
            }
            *v7++ = v15;
          }
          unint64_t v11 = v8;
        }
        while ((unint64_t)v8 < v9);
      }
      *a2 = v7 - a1;
      *a4 = v8 - a3;
      return *a2;
    }
    else
    {
      uint64_t v4 = 0;
      *a2 = 0;
      *a4 = 0;
    }
  }
  return v4;
}

uint64_t UTF16BEToUTF8(unsigned char *a1, unsigned int *a2, unsigned __int8 *a3, int *a4)
{
  uint64_t v4 = (int)*a2;
  if (!v4)
  {
    uint64_t result = 0;
    *a4 = 0;
    return result;
  }
  int v5 = *a4;
  if ((*a4 & 0x80000001) == 1) {
    *a4 = --v5;
  }
  if (v5 >= 0) {
    int v6 = v5;
  }
  else {
    int v6 = v5 + 1;
  }
  unsigned int v7 = v5 + 1;
  LODWORD(v8) = a1;
  LODWORD(v9) = a3;
  if (v7 < 3)
  {
LABEL_39:
    *a2 = v8 - a1;
    *a4 = v9 - a3;
    return *a2;
  }
  unint64_t v10 = (unint64_t)&a1[v4];
  unint64_t v9 = a3;
  size_t v8 = a1;
  unint64_t v11 = (unint64_t)&a3[2 * (v6 >> 1)];
  while (1)
  {
    int v12 = v9;
    if (v8 - a1 + 5 >= (int)*a2)
    {
LABEL_38:
      LODWORD(v9) = v12;
      goto LABEL_39;
    }
    int v13 = *v9;
    unsigned int v14 = v9[1] | (v13 << 8);
    v9 += 2;
    if ((v13 & 0xFC) == 0xD8) {
      break;
    }
LABEL_14:
    if ((unint64_t)v8 >= v10) {
      goto LABEL_38;
    }
    if (v14 <= 0x7F)
    {
      *v8++ = v14;
    }
    else
    {
      if (v14 >= 0x10000) {
        char v16 = 18;
      }
      else {
        char v16 = 12;
      }
      if (v14 >= 0x10000) {
        char v17 = -16;
      }
      else {
        char v17 = -32;
      }
      if (v14 < 0x800)
      {
        char v16 = 6;
        char v17 = -64;
      }
      *v8++ = v17 | (v14 >> v16);
      if ((unint64_t)v8 < v10)
      {
        if (v14 >= 0x10000) {
          unsigned int v18 = 12;
        }
        else {
          unsigned int v18 = 6;
        }
        if (v14 < 0x800) {
          unsigned int v18 = 0;
        }
        do
        {
          *v8++ = (v14 >> v18) & 0x3F | 0x80;
          BOOL v19 = v18 >= 6;
          v18 -= 6;
        }
        while (v19 && (unint64_t)v8 < v10);
      }
    }
    if ((unint64_t)v9 >= v11) {
      goto LABEL_39;
    }
  }
  if ((unint64_t)v9 >= v11) {
    goto LABEL_38;
  }
  unsigned __int8 v15 = *v9;
  if ((*v9 & 0xFC) == 0xDC)
  {
    unint64_t v9 = v12 + 4;
    unsigned int v14 = (v12[3] | ((v15 & 3) << 8) & 0x3FF | ((v14 & 0x3FF) << 10)) + 0x10000;
    goto LABEL_14;
  }
  *a2 = v8 - a1;
  *a4 = v12 - a3;
  return 4294967294;
}

uint64_t UTF8ToUTF16BE(unsigned char *a1, int *a2, char *a3, int *a4)
{
  uint64_t v4 = 0xFFFFFFFFLL;
  if (a1 && a2 && a4)
  {
    if (a3)
    {
      uint64_t v5 = *a4;
      if (*a2 >= 0) {
        int v6 = *a2;
      }
      else {
        int v6 = *a2 + 1;
      }
      LODWORD(v7) = a1;
      LODWORD(v8) = a3;
      if ((int)v5 >= 1)
      {
        unint64_t v9 = (unint64_t)&a3[v5];
        unint64_t v10 = (unint64_t)&a1[2 * (v6 >> 1)];
        unint64_t v11 = a3;
        unsigned int v7 = a1;
        size_t v8 = a3;
        do
        {
          int v12 = *v8++;
          unsigned int v13 = v12;
          if (v12 < 0)
          {
            if (v13 <= 0xBF) {
              goto LABEL_38;
            }
            if (v13 > 0xDF)
            {
              if (v13 > 0xEF)
              {
                if (v13 > 0xF7)
                {
LABEL_38:
                  *a2 = (unint64_t)(v7 - a1) >> 1;
                  *a4 = v11 - a3;
                  return 4294967294;
                }
                unsigned int v15 = v13 & 7;
                uint64_t v14 = 3;
              }
              else
              {
                unsigned int v15 = v13 & 0xF;
                uint64_t v14 = 2;
              }
            }
            else
            {
              unsigned int v15 = v13 & 0x1F;
              uint64_t v14 = 1;
            }
          }
          else
          {
            uint64_t v14 = 0;
            unsigned int v15 = v13;
          }
          if ((uint64_t)(v9 - (void)v8) < v14) {
            goto LABEL_35;
          }
          if ((v13 & 0x80) == 0 || (unint64_t)v8 >= v9) {
            goto LABEL_27;
          }
          uint64_t v16 = 0;
          int v17 = v14 - 1;
          do
          {
            size_t v8 = &v11[v16 + 2];
            char v18 = v11[v16 + 1];
            if ((v18 & 0xC0) != 0x80) {
              break;
            }
            unsigned int v15 = v18 & 0x3F | (v15 << 6);
            if (v17 == v16) {
              break;
            }
            ++v16;
          }
          while ((unint64_t)v8 < v9);
          if (HIWORD(v15))
          {
            if (HIWORD(v15) > 0x10u || (unint64_t)(v7 + 2) >= v10)
            {
LABEL_35:
              LODWORD(v8) = v11;
              break;
            }
            unsigned char *v7 = ((v15 - 0x10000) >> 18) | 0xD8;
            v7[1] = (v15 - 0x10000) >> 10;
            v7[2] = BYTE1(v15) & 3 | 0xDC;
            uint64_t v19 = 3;
            uint64_t v20 = 2;
          }
          else
          {
LABEL_27:
            if ((unint64_t)v7 >= v10) {
              goto LABEL_35;
            }
            unsigned char *v7 = BYTE1(v15);
            uint64_t v19 = 1;
            uint64_t v20 = 1;
          }
          v7[v19] = v15;
          unint64_t v11 = v8;
          v7 += 2 * v20;
        }
        while ((unint64_t)v8 < v9);
      }
      *a2 = v7 - a1;
      *a4 = v8 - a3;
      return *a2;
    }
    else
    {
      uint64_t v4 = 0;
      *a2 = 0;
      *a4 = 0;
    }
  }
  return v4;
}

uint64_t UTF8ToUTF16(_WORD *a1, int *a2, char *a3, int *a4)
{
  if (a3) {
    return UTF8ToUTF16LE(a1, a2, a3, a4);
  }
  if (*a2 < 2)
  {
    uint64_t result = 0;
    *a2 = 0;
  }
  else
  {
    *a1 = -257;
    uint64_t result = 2;
    *a2 = 2;
  }
  *a4 = 0;
  return result;
}

uint64_t asciiToUTF8(uint64_t a1, unsigned int *a2, uint64_t a3, int *a4)
{
  uint64_t v4 = *a4;
  if ((int)v4 < 1)
  {
    LODWORD(v8) = a1;
    int v10 = a3;
LABEL_10:
    *a2 = v8 - a1;
    *a4 = v10 - a3;
    return *a2;
  }
  else
  {
    uint64_t v5 = 0;
    unint64_t v6 = a1 + (int)*a2;
    unint64_t v7 = a3 + v4;
    while (1)
    {
      size_t v8 = (unsigned char *)(a1 + v5);
      if (v5 + 5 >= (int)*a2 || (unint64_t)v8 >= v6)
      {
        int v10 = a3 + v5;
        goto LABEL_10;
      }
      int v9 = *(char *)(a3 + v5);
      if (v9 < 0) {
        break;
      }
      *size_t v8 = v9;
      int v10 = a3 + ++v5;
      if (a3 + v5 >= v7)
      {
        LODWORD(v8) = a1 + v5;
        goto LABEL_10;
      }
    }
    *a2 = v5;
    *a4 = v5;
    return 4294967294;
  }
}

uint64_t UTF8Toascii(unsigned char *a1, unsigned int *a2, char *a3, int *a4)
{
  uint64_t v4 = 0xFFFFFFFFLL;
  if (a1 && a2 && a4)
  {
    if (a3)
    {
      uint64_t v5 = *a4;
      LODWORD(v6) = a1;
      LODWORD(v7) = a3;
      if ((int)v5 < 1)
      {
LABEL_30:
        *a2 = v6 - a1;
        *a4 = v7 - a3;
        return *a2;
      }
      else
      {
        unint64_t v8 = (unint64_t)&a3[v5];
        unint64_t v9 = (unint64_t)&a1[*a2];
        int v10 = a3;
        unint64_t v6 = a1;
        unint64_t v7 = a3;
        while (1)
        {
          int v11 = *v7++;
          unsigned int v12 = v11;
          if (v11 < 0)
          {
            if (v12 <= 0xBF) {
              break;
            }
            if (v12 > 0xDF)
            {
              if (v12 > 0xEF)
              {
                if (v12 > 0xF7) {
                  break;
                }
                unsigned int v14 = v12 & 7;
                unsigned int v13 = 3;
              }
              else
              {
                unsigned int v14 = v12 & 0xF;
                unsigned int v13 = 2;
              }
            }
            else
            {
              unsigned int v14 = v12 & 0x1F;
              unsigned int v13 = 1;
            }
          }
          else
          {
            unsigned int v13 = 0;
            unsigned int v14 = v12;
          }
          if ((uint64_t)(v8 - (void)v7) < v13)
          {
LABEL_29:
            LODWORD(v7) = v10;
            goto LABEL_30;
          }
          if ((v12 & 0x80) != 0 && (unint64_t)v7 < v8)
          {
            unsigned int v15 = v13 - 1;
            uint64_t v16 = v10 + 2;
            do
            {
              unint64_t v7 = v16;
              char v17 = *(v16 - 1);
              if ((v17 & 0xC0) != 0x80) {
                break;
              }
              unsigned int v14 = v17 & 0x3F | (v14 << 6);
              if (v15-- == 0) {
                break;
              }
              uint64_t v16 = v7 + 1;
            }
            while ((unint64_t)v7 < v8);
          }
          if (v14 > 0x7F) {
            break;
          }
          if ((unint64_t)v6 >= v9) {
            goto LABEL_29;
          }
          *v6++ = v14;
          int v10 = v7;
          if ((unint64_t)v7 >= v8) {
            goto LABEL_30;
          }
        }
        *a2 = v6 - a1;
        *a4 = v10 - a3;
        return 4294967294;
      }
    }
    else
    {
      uint64_t v4 = 0;
      *a2 = 0;
      *a4 = 0;
    }
  }
  return v4;
}

void xmlCleanupCharEncodingHandlers(void)
{
  xmlCleanupEncodingAliases();
  xmlGenericErrorFunc v0 = (void *)handlers;
  if (handlers)
  {
    int v1 = nbCharEncodingHandler;
    if (nbCharEncodingHandler >= 1)
    {
      do
      {
        nbxmlCharEncodingHandlerPtr CharEncodingHandler = --v1;
        uint64_t v2 = (void **)v0[v1];
        if (v2)
        {
          uint64_t v3 = *v2;
          if (v3)
          {
            xmlFree(v3);
            xmlGenericErrorFunc v0 = (void *)handlers;
            int v1 = nbCharEncodingHandler;
          }
          xmlFree((void *)v0[v1]);
          xmlGenericErrorFunc v0 = (void *)handlers;
          int v1 = nbCharEncodingHandler;
        }
      }
      while (v1 > 0);
    }
    xmlFree(v0);
    handlers = 0;
    nbxmlCharEncodingHandlerPtr CharEncodingHandler = 0;
  }
}

xmlCharEncodingHandlerPtr xmlFindCharEncodingHandler(const char *name)
{
  while (1)
  {
    int v1 = name;
    uint64_t v24 = *MEMORY[0x1E4F143B8];
    if (handlers)
    {
      if (!name) {
        return 0;
      }
    }
    else
    {
      xmlInitCharEncodingHandlers();
      if (!v1) {
        return 0;
      }
    }
    if (!*v1) {
      return 0;
    }
    int v23 = 0;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    *(_OWORD *)__s1 = 0u;
    long long v18 = 0u;
    EncodingAlias = xmlGetEncodingAlias(v1);
    uint64_t v3 = 0;
    uint64_t v4 = EncodingAlias ? EncodingAlias : v1;
    do
    {
      char v5 = __toupper(v4[v3]);
      __s1[v3] = v5;
      if (!v5) {
        break;
      }
      ++v3;
    }
    while (v3 != 99);
    __s1[v3] = 0;
    unint64_t v6 = (const char ***)handlers;
    if (handlers)
    {
      uint64_t v7 = nbCharEncodingHandler;
      if (nbCharEncodingHandler >= 1) {
        break;
      }
    }
LABEL_15:
    uint64_t v9 = (uint64_t)openIcuConverter((uint64_t)v4, 1);
    unint64_t v10 = (unint64_t)openIcuConverter((uint64_t)v4, 0);
    int v11 = (uconv_t *)v10;
    if (v9 && v10)
    {
      unsigned int v12 = (xmlCharEncodingHandler *)xmlMalloc(0x28uLL);
      unint64_t v8 = v12;
      if (v12)
      {
        v12->uconv_out = 0;
        *(_OWORD *)&v12->name = 0u;
        *(_OWORD *)&v12->output = 0u;
        v12->name = xmlMemStrdup(v4);
        v8->xmlParserInputPtr input = 0;
        v8->output = 0;
        v8->uconv_in = (uconv_t *)v9;
        v8->uconv_out = v11;
      }
      else
      {
        ucnv_close();
        ucnv_close();
        xmlFree((void *)v9);
        ucnv_close();
        ucnv_close();
        xmlFree(v11);
      }
      return v8;
    }
    if (v9 | v10)
    {
      closeIcuConverter(v9);
      closeIcuConverter((uint64_t)v11);
      __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 1, 3, 0, 0, (const xmlChar *)v4, 0, 0, 0, 0, "ICU converter : problems with filters for '%s'\n", (char)v4);
    }
    xmlCharEncoding v13 = xmlParseCharEncoding(v1);
    if (v13 == XML_CHAR_ENCODING_ERROR) {
      return 0;
    }
    CharEncodingName = xmlGetCharEncodingName(v13);
    if (!CharEncodingName) {
      return 0;
    }
    unsigned int v15 = CharEncodingName;
    if (!strcmp(v4, CharEncodingName)) {
      return 0;
    }
    name = v15;
  }
  while (1)
  {
    unint64_t v8 = (xmlCharEncodingHandler *)*v6;
    if (!strcmp(__s1, **v6)) {
      return v8;
    }
    ++v6;
    if (!--v7) {
      goto LABEL_15;
    }
  }
}

void *openIcuConverter(uint64_t a1, int a2)
{
  uint64_t v3 = xmlMalloc(0x820uLL);
  if (v3)
  {
    if (linkedOnOrAfterFall2022OSVersions())
    {
      v3[258] = v3 + 2;
      v3[259] = v3 + 2;
    }
    void *v3 = ucnv_open();
    if (a2) {
      ucnv_setToUCallBack();
    }
    else {
      ucnv_setFromUCallBack();
    }
    v3[1] = ucnv_open();
  }
  return v3;
}

uint64_t closeIcuConverter(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    ucnv_close();
    ucnv_close();
    xmlFreeFunc v2 = xmlFree;
    return ((uint64_t (*)(uint64_t))v2)(v1);
  }
  return result;
}

uint64_t xmlCharEncFirstLineInt(uint64_t a1, xmlBufferPtr buf, uint64_t a3, signed int a4)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && buf && a3)
  {
    unsigned int use = buf->use;
    signed int v9 = buf->size + ~use;
    signed int v10 = *(_DWORD *)(a3 + 8);
    unsigned int len = v10;
    unsigned int v15 = v9;
    if (a4 < 0)
    {
      if (v10 >= 181)
      {
        signed int v10 = 180;
        unsigned int len = 180;
      }
    }
    else if (v10 > a4)
    {
      unsigned int len = a4;
      signed int v10 = a4;
    }
    if (2 * v10 >= v9)
    {
      xmlBufferGrow(buf, 2 * v10);
      unsigned int use = buf->use;
      unsigned int v15 = buf->size + ~use;
    }
    unsigned int v11 = xmlEncInputChunk(a1, (uint64_t)&buf->content[use], &v15, *(void *)a3, &len, 0);
    xmlBufferShrink((xmlBufferPtr)a3, len);
    unsigned int v12 = buf->use + v15;
    buf->unsigned int use = v12;
    buf->content[v12] = 0;
    if (v11 == -1) {
      unsigned int v13 = -3;
    }
    else {
      unsigned int v13 = v11;
    }
    if (v13 == -3) {
      unsigned int v13 = 0;
    }
    if (v15) {
      return v15;
    }
    else {
      return v13;
    }
  }
  return result;
}

uint64_t xmlEncInputChunk(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, _DWORD *a5, int a6)
{
  unint64_t v6 = *(uint64_t (**)(uint64_t, _DWORD *, uint64_t, _DWORD *))(a1 + 8);
  if (v6)
  {
    int v7 = v6(a2, a3, a4, a5);
    return v7 & (v7 >> 31);
  }
  else
  {
    uint64_t v9 = *(void *)(a1 + 24);
    if (v9)
    {
      return xmlUconvWrapper(v9, 1, a2, a3, a4, a5, a6);
    }
    else
    {
      *a3 = 0;
      *a5 = 0;
      return 4294967294;
    }
  }
}

int xmlCharEncFirstLine(xmlCharEncodingHandler *handler, xmlBufferPtr out, xmlBufferPtr in)
{
  return xmlCharEncFirstLineInt((uint64_t)handler, out, (uint64_t)in, -1);
}

size_t xmlCharEncFirstLineInput(uint64_t a1, int a2)
{
  *(void *)&len[60] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (!*(void *)(a1 + 24)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(xmlBuf **)(a1 + 32);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *(const xmlBuf **)(a1 + 40);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  size_t result = xmlBufUse(*(const xmlBufPtr *)(a1 + 40));
  if (result)
  {
    size_t v7 = result;
    unint64_t v8 = xmlBufAvail((unint64_t)v3);
    if (a2 >= 0) {
      unint64_t v9 = a2;
    }
    else {
      unint64_t v9 = 180;
    }
    if (v9 >= v7) {
      unint64_t v10 = v7;
    }
    else {
      unint64_t v10 = v9;
    }
    if (2 * v10 >= v8)
    {
      xmlBufGrow((uint64_t)v3, 2 * v10);
      unint64_t v8 = xmlBufAvail((unint64_t)v3);
    }
    int v11 = 360;
    if (v8 < 0x168) {
      int v11 = v8;
    }
    int v19 = v11;
    *(_DWORD *)unsigned int len = v10;
    uint64_t v12 = *(void *)(a1 + 24);
    unsigned int v13 = xmlBufEnd(v3);
    unsigned int v14 = xmlBufContent(v4);
    int v15 = xmlEncInputChunk(v12, (uint64_t)v13, &v19, (uint64_t)v14, len, 0);
    xmlBufShrink(v4, *(int *)len);
    xmlBufAddLen((uint64x2_t *)v3, v19);
    if (v15 == -1) {
      int v16 = -3;
    }
    else {
      int v16 = v15;
    }
    if (v16 == -2)
    {
      memset(&len[4], 0, 49);
      char v17 = xmlBufContent(v4);
      snprintf(&len[4], 0x31uLL, "0x%02X 0x%02X 0x%02X 0x%02X", *v17, v17[1], v17[2], v17[3]);
      len[53] = 0;
      __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6003, 3, 0, 0, &len[4], 0, 0, 0, 0, "input conversion failed due to input error, bytes %s\n", (char)&len[4]);
    }
    if (v16 == -3) {
      unsigned int v18 = 0;
    }
    else {
      unsigned int v18 = v16;
    }
    if (v19) {
      return v19;
    }
    else {
      return v18;
    }
  }
  return result;
}

size_t xmlCharEncInput(uint64_t a1, int a2)
{
  *(void *)&len[60] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (!*(void *)(a1 + 24)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(xmlBuf **)(a1 + 32);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *(const xmlBuf **)(a1 + 40);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  size_t result = xmlBufUse(*(const xmlBufPtr *)(a1 + 40));
  if (result)
  {
    if (result > 0x10000 && a2 == 0) {
      uint64_t v8 = 0x10000;
    }
    else {
      uint64_t v8 = result;
    }
    unint64_t v9 = xmlBufAvail((unint64_t)v3);
    if (2 * v8 >= v9)
    {
      xmlBufGrow((uint64_t)v3, 2 * v8);
      unint64_t v9 = xmlBufAvail((unint64_t)v3);
    }
    if (v9 > 0x20000 && a2 == 0) {
      int v11 = 0x20000;
    }
    else {
      int v11 = v9;
    }
    int v19 = v11;
    *(_DWORD *)unsigned int len = v8;
    uint64_t v12 = *(void *)(a1 + 24);
    unsigned int v13 = xmlBufEnd(v3);
    unsigned int v14 = xmlBufContent(v4);
    int v15 = xmlEncInputChunk(v12, (uint64_t)v13, &v19, (uint64_t)v14, len, a2);
    xmlBufShrink(v4, *(int *)len);
    xmlBufAddLen((uint64x2_t *)v3, v19);
    if (v15 == -1) {
      int v16 = -3;
    }
    else {
      int v16 = v15;
    }
    if (v16 == -2)
    {
      memset(&len[4], 0, 49);
      char v17 = xmlBufContent(v4);
      snprintf(&len[4], 0x31uLL, "0x%02X 0x%02X 0x%02X 0x%02X", *v17, v17[1], v17[2], v17[3]);
      len[53] = 0;
      __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6003, 3, 0, 0, &len[4], 0, 0, 0, 0, "input conversion failed due to input error, bytes %s\n", (char)&len[4]);
    }
    if (v16 == -3) {
      int v18 = 0;
    }
    else {
      int v18 = v16;
    }
    if (v18 >= 0) {
      return v19;
    }
    else {
      return v18;
    }
  }
  return result;
}

int xmlCharEncInFunc(xmlCharEncodingHandler *handler, xmlBufferPtr out, xmlBufferPtr in)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  int result = -1;
  if (handler && out && in)
  {
    unsigned int use = in->use;
    unsigned int len = use;
    if (use)
    {
      unsigned int v8 = out->use;
      unsigned int size = out->size;
      int v16 = size + ~v8;
      int v10 = 2 * use;
      if (v10 >= v16)
      {
        xmlBufferGrow(out, size + v10);
        unsigned int v8 = out->use;
        int v16 = out->size + ~v8;
      }
      int v11 = xmlEncInputChunk((uint64_t)handler, (uint64_t)&out->content[v8], &v16, (uint64_t)in->content, &len, 1);
      xmlBufferShrink(in, len);
      unsigned int v12 = out->use + v16;
      out->unsigned int use = v12;
      out->content[v12] = 0;
      if (v11 == -1) {
        int v13 = -3;
      }
      else {
        int v13 = v11;
      }
      if (v13 == -2)
      {
        char v20 = 0;
        long long v18 = 0u;
        long long v19 = 0u;
        *(_OWORD *)__str = 0u;
        snprintf(__str, 0x31uLL, "0x%02X 0x%02X 0x%02X 0x%02X", *in->content, in->content[1], in->content[2], in->content[3]);
        char v21 = 0;
        __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6003, 3, 0, 0, (const xmlChar *)__str, 0, 0, 0, 0, "input conversion failed due to input error, bytes %s\n", (char)__str);
      }
      if (v13 == -3) {
        int v14 = 0;
      }
      else {
        int v14 = v13;
      }
      if (v16) {
        return v16;
      }
      else {
        return v14;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t xmlCharEncOutput(void *a1, int a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (!a1[3]) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = (xmlBuf *)a1[4];
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = (xmlBuf *)a1[5];
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  *(void *)&len[1] = 0;
  unint64_t v6 = xmlBufAvail((unint64_t)v4);
  unint64_t v7 = v6;
  if (a2)
  {
    *(void *)&len[1] = v6;
    uint64_t v8 = a1[3];
    unint64_t v9 = xmlBufEnd(v4);
    xmlEncOutputChunk(v8, (uint64_t)v9, &len[1], 0, &len[2]);
    xmlBufAddLen((uint64x2_t *)v4, len[1]);
    return len[1];
  }
  size_t v12 = xmlBufUse(v3);
  uint64_t v10 = 0;
  if (!v12) {
    return v10;
  }
  while (1)
  {
    if (v12 >= 0x10000) {
      uint64_t v13 = 0x10000;
    }
    else {
      uint64_t v13 = v12;
    }
    if (4 * v13 >= v7)
    {
      xmlBufGrow((uint64_t)v4, 4 * v13);
      unint64_t v7 = xmlBufAvail((unint64_t)v4);
    }
    unsigned int v14 = v7 >= 0x40000 ? 0x40000 : v7;
    *(void *)&len[1] = __PAIR64__(v13, v14);
    uint64_t v15 = a1[3];
    int v16 = xmlBufEnd(v4);
    char v17 = xmlBufContent(v3);
    unsigned int v18 = xmlEncOutputChunk(v15, (uint64_t)v16, &len[1], (uint64_t)v17, &len[2]);
    xmlBufShrink(v3, len[2]);
    xmlBufAddLen((uint64x2_t *)v4, len[1]);
    uint64_t v10 = (len[1] + v10);
    if (v18 == -2) {
      break;
    }
    if (v18 != -1)
    {
      if (v18 == -4)
      {
        __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6004, 3, 0, 0, 0, 0, 0, 0, 0, "xmlCharEncOutFunc: no output function !\n", 0);
        unsigned int v18 = -1;
      }
      goto LABEL_33;
    }
    if (len[1] < 1)
    {
      unsigned int v18 = -3;
      goto LABEL_33;
    }
LABEL_26:
    unint64_t v7 = xmlBufAvail((unint64_t)v4);
    size_t v12 = xmlBufUse(v3);
    if (!v12) {
      return v10;
    }
  }
  *(void *)__str = 0;
  uint64_t v31 = 0;
  int v32 = 0;
  len[0] = 0;
  len[0] = xmlBufUse(v3);
  long long v19 = xmlBufContent(v3);
  int UTF8Char = xmlGetUTF8Char(v19, len);
  if (UTF8Char < 1)
  {
    unsigned int v18 = -2;
    goto LABEL_33;
  }
  int v21 = snprintf(__str, 0x14uLL, "&#%d;", UTF8Char);
  xmlBufShrink(v3, len[0]);
  xmlBufGrow((uint64_t)v4, 4 * v21);
  len[1] = xmlBufAvail((unint64_t)v4);
  len[2] = v21;
  uint64_t v22 = a1[3];
  int v23 = xmlBufEnd(v4);
  unsigned int v18 = xmlEncOutputChunk(v22, (uint64_t)v23, &len[1], (uint64_t)__str, &len[2]);
  if ((v18 & 0x80000000) == 0 && len[2] == v21)
  {
    xmlBufAddLen((uint64x2_t *)v4, len[1]);
    uint64_t v10 = (len[1] + v10);
    goto LABEL_26;
  }
  char v28 = 0;
  long long v26 = 0u;
  long long v27 = 0u;
  *(_OWORD *)uint64_t v25 = 0u;
  snprintf(v25, 0x31uLL, "0x%02X 0x%02X 0x%02X 0x%02X", *v19, v19[1], v19[2], v19[3]);
  char v29 = 0;
  __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6003, 3, 0, 0, (const xmlChar *)v25, 0, 0, 0, 0, "output conversion failed due to conv error, bytes %s\n", (char)v25);
  if (xmlBufGetAllocationScheme((uint64_t)v3) != 2) {
    xmlChar *v19 = 32;
  }
LABEL_33:
  if (v10) {
    return v10;
  }
  else {
    return v18;
  }
}

uint64_t xmlEncOutputChunk(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, _DWORD *a5)
{
  char v5 = *(uint64_t (**)(uint64_t, _DWORD *, uint64_t, _DWORD *))(a1 + 16);
  if (v5)
  {
    int v6 = v5(a2, a3, a4, a5);
    return v6 & (v6 >> 31);
  }
  else
  {
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
      return xmlUconvWrapper(v8, 0, a2, a3, a4, a5, 1);
    }
    else
    {
      *a3 = 0;
      *a5 = 0;
      return 4294967292;
    }
  }
}

int xmlCharEncOutFunc(xmlCharEncodingHandler *handler, xmlBufferPtr out, xmlBufferPtr in)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  int result = -1;
  if (!handler || !out) {
    return result;
  }
  uint64_t use = out->use;
  int v8 = out->size - use - ((signed int)(out->size - use) > 0);
  signed int v23 = v8;
  if (!in)
  {
    unsigned int len = 0;
    xmlEncOutputChunk((uint64_t)handler, (uint64_t)&out->content[use], &v23, 0, &len);
    int result = 0;
    unsigned int v20 = out->use + v23;
    out->uint64_t use = v20;
    out->content[v20] = 0;
    return result;
  }
  unsigned int v9 = in->use;
  unsigned int len = v9;
  if (!v9) {
    return 0;
  }
  int v10 = 0;
  while (1)
  {
    if ((int)(4 * v9) >= v8)
    {
      xmlBufferGrow(out, 4 * v9);
      LODWORD(use) = out->use;
      signed int v23 = out->size + ~use;
    }
    int v11 = xmlEncOutputChunk((uint64_t)handler, (uint64_t)&out->content[use], &v23, (uint64_t)in->content, &len);
    xmlBufferShrink(in, len);
    signed int v12 = v23;
    unsigned int v13 = out->use + v23;
    out->uint64_t use = v13;
    v10 += v12;
    out->content[v13] = 0;
    if (v11 == -2) {
      break;
    }
    if (v11 != -1)
    {
      if (v11 == -4)
      {
        __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6004, 3, 0, 0, 0, 0, 0, 0, 0, "xmlCharEncOutFunc: no output function !\n", 0);
        int v11 = -1;
      }
      goto LABEL_24;
    }
    if (v23 < 1)
    {
      int v11 = -3;
      goto LABEL_24;
    }
LABEL_16:
    LODWORD(use) = out->use;
    int v8 = out->size - use - ((signed int)(out->size - use) > 0);
    unsigned int v9 = in->use;
    unsigned int len = v9;
    signed int v23 = v8;
    if (!v9) {
      return 0;
    }
  }
  *(void *)__str = 0;
  uint64_t v30 = 0;
  int v31 = 0;
  unsigned int v21 = in->use;
  int UTF8Char = xmlGetUTF8Char(in->content, (int *)&v21);
  if (UTF8Char < 1)
  {
    int v11 = -2;
    goto LABEL_24;
  }
  unsigned int v15 = snprintf(__str, 0x14uLL, "&#%d;", UTF8Char);
  xmlBufferShrink(in, v21);
  xmlBufferGrow(out, 4 * v15);
  uint64_t v16 = out->use;
  unsigned int v17 = out->size + ~v16;
  unsigned int len = v15;
  signed int v23 = v17;
  int v11 = xmlEncOutputChunk((uint64_t)handler, (uint64_t)&out->content[v16], &v23, (uint64_t)__str, &len);
  if ((v11 & 0x80000000) == 0 && len == v15)
  {
    signed int v18 = v23;
    unsigned int v19 = out->use + v23;
    out->uint64_t use = v19;
    v10 += v18;
    out->content[v19] = 0;
    goto LABEL_16;
  }
  char v27 = 0;
  long long v25 = 0u;
  long long v26 = 0u;
  *(_OWORD *)uint64_t v24 = 0u;
  snprintf(v24, 0x31uLL, "0x%02X 0x%02X 0x%02X 0x%02X", *in->content, in->content[1], in->content[2], in->content[3]);
  char v28 = 0;
  __xmlRaiseError(0, 0, 0, 0, 0, 0x1Bu, 6003, 3, 0, 0, (const xmlChar *)v24, 0, 0, 0, 0, "output conversion failed due to conv error, bytes %s\n", (char)v24);
  if (in->alloc != XML_BUFFER_ALLOC_IMMUTABLE) {
    *in->content = 32;
  }
LABEL_24:
  if (v10) {
    return v10;
  }
  else {
    return v11;
  }
}

int xmlCharEncCloseFunc(xmlCharEncodingHandler *handler)
{
  if (!handler) {
    return -1;
  }
  if (!handler->name) {
    return -1;
  }
  xmlFreeFunc v2 = (xmlCharEncodingHandler **)handlers;
  if (handlers)
  {
    uint64_t v3 = nbCharEncodingHandler;
    if (nbCharEncodingHandler >= 1)
    {
      while (*v2 != handler)
      {
        ++v2;
        if (!--v3) {
          goto LABEL_7;
        }
      }
      return 0;
    }
  }
LABEL_7:
  uconv_out = handler->uconv_out;
  if (uconv_out)
  {
    ucnv_close();
    ucnv_close();
    xmlFree(uconv_out);
    handler->uconv_out = 0;
    uconv_in = handler->uconv_in;
    if (!uconv_in) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  uconv_in = handler->uconv_in;
  if (uconv_in)
  {
LABEL_13:
    ucnv_close();
    ucnv_close();
    xmlFree(uconv_in);
    handler->uconv_in = 0;
LABEL_14:
    if (handler->name) {
      xmlFree(handler->name);
    }
    handler->name = 0;
    xmlFree(handler);
  }
  return 0;
}

uint64_t xmlByteConsumed(xmlParserCtxtPtr ctxt)
{
  uint64_t v1 = ((uint64_t (*)(xmlParserCtxtPtr))MEMORY[0x1F4188790])(ctxt);
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!v1) {
    return -1;
  }
  xmlFreeFunc v2 = *(void **)(v1 + 56);
  if (!v2) {
    return -1;
  }
  uint64_t v3 = *v2;
  if (!*v2) {
    return v2[8] + v2[4] - v2[3];
  }
  uint64_t v4 = *(void *)(v3 + 24);
  if (!v4) {
    return v2[8] + v2[4] - v2[3];
  }
  uint64_t v6 = v2[4];
  uint64_t v5 = v2[5];
  int v7 = v5 - v6;
  if (v5 - v6 >= 1)
  {
    bzero(v17, 0x7D00uLL);
    int v15 = 32000;
    int v16 = v7;
    int v8 = 0;
    if ((xmlEncOutputChunk(v4, (uint64_t)v17, &v15, v6, &v16) & 0x80000000) == 0)
    {
LABEL_7:
      unint64_t v9 = (v15 + v8);
      uint64_t v3 = *v2;
      goto LABEL_13;
    }
    while (v15 >= 1)
    {
      v8 += v15;
      v6 += v16;
      int v10 = *((_DWORD *)v2 + 10) - v6;
      int v15 = 32000;
      int v16 = v10;
      if ((xmlEncOutputChunk(v4, (uint64_t)v17, &v15, v6, &v16) & 0x80000000) == 0) {
        goto LABEL_7;
      }
    }
    return -1;
  }
  unint64_t v9 = 0;
LABEL_13:
  unint64_t v12 = *(void *)(v3 + 56);
  BOOL v13 = v12 >= v9;
  uint64_t v14 = v12 - v9;
  if (v13) {
    return v14;
  }
  else {
    return -1;
  }
}

uint64_t xmlUconvWrapper(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, _DWORD *a6, int a7)
{
  int v15 = a3;
  int v16 = a5;
  if (a4 && (int v8 = a5, a5) && (v9 = a3, a3) && a6)
  {
    linkedOnOrAfterFall2022OSVersions();
    ucnv_convertEx();
    *a6 = v16 - v8;
    *a4 = v15 - v9;
    int v14 = linkedOnOrAfterFall2022OSVersions();
    uint64_t result = 0;
    if (a7)
    {
      if (v14)
      {
        uint64_t result = 0;
        *(void *)(a1 + 2072) = a1 + 16;
        *(void *)(a1 + 2064) = a1 + 16;
      }
    }
  }
  else
  {
    if (a4) {
      *a4 = 0;
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

xmlEntityPtr xmlGetPredefinedEntity(xmlEntityPtr name)
{
  if (name)
  {
    uint64_t v1 = (const xmlChar *)name;
    unsigned int private_low = LOBYTE(name->_private);
    if (private_low > 0x6B)
    {
      if (private_low == 113)
      {
        if (xmlStrEqual((const xmlChar *)name, (const xmlChar *)"quot")) {
          return (xmlEntityPtr)&xmlEntityQuot;
        }
      }
      else if (private_low == 108 && xmlStrEqual((const xmlChar *)name, (const xmlChar *)"lt"))
      {
        return (xmlEntityPtr)&xmlEntityLt;
      }
    }
    else if (private_low == 97)
    {
      if (xmlStrEqual((const xmlChar *)name, (const xmlChar *)"amp")) {
        return (xmlEntityPtr)&xmlEntityAmp;
      }
      if (xmlStrEqual(v1, (const xmlChar *)"apos")) {
        return (xmlEntityPtr)&xmlEntityApos;
      }
    }
    else if (private_low == 103 && xmlStrEqual((const xmlChar *)name, (const xmlChar *)"gt"))
    {
      return (xmlEntityPtr)&xmlEntityGt;
    }
    return 0;
  }
  return name;
}

xmlEntityPtr xmlAddDtdEntity(xmlDocPtr doc, const xmlChar *name, int type, const xmlChar *ExternalID, const xmlChar *SystemID, const xmlChar *content)
{
  if (!doc)
  {
    int v9 = "xmlAddDtdEntity: document is NULL";
    int v10 = 521;
LABEL_9:
    __xmlSimpleError(2, v10, 0, (uint64_t)v9, 0);
    return 0;
  }
  extSubset = doc->extSubset;
  if (!extSubset)
  {
    int v9 = "xmlAddDtdEntity: document without external subset";
    int v10 = 522;
    goto LABEL_9;
  }
  xmlEntityPtr result = (xmlEntityPtr)xmlAddEntity(&doc->extSubset->_private, (xmlChar *)name, type, ExternalID, SystemID, content);
  if (result)
  {
    result->xmlNodePtr parent = extSubset;
    result->xmlDocPtr doc = extSubset->doc;
    last = extSubset->last;
    if (last)
    {
      last->xmlNodePtr next = (_xmlNode *)result;
      result->int prev = last;
    }
    else
    {
      extSubset->children = (_xmlNode *)result;
    }
    extSubset->last = (_xmlNode *)result;
  }
  return result;
}

uint64_t xmlAddEntity(void *a1, xmlChar *name, int a3, const xmlChar *a4, const xmlChar *a5, const xmlChar *a6)
{
  if (!name) {
    return 0;
  }
  uint64_t v12 = a1[8];
  if (v12) {
    BOOL v13 = *(xmlDict **)(v12 + 152);
  }
  else {
    BOOL v13 = 0;
  }
  if ((a3 - 1) >= 3)
  {
    if ((a3 - 4) >= 2) {
      return 0;
    }
    Dict = (xmlHashTable *)a1[15];
    if (!Dict)
    {
      Dict = xmlHashCreateDict(0, v13);
      a1[15] = Dict;
      if (!Dict) {
        return 0;
      }
    }
    goto LABEL_29;
  }
  xmlEntityPtr PredefinedEntity = xmlGetPredefinedEntity(name);
  if (PredefinedEntity)
  {
    if (a3 == 1 && a6)
    {
      unint64_t v15 = *PredefinedEntity->content;
      int v16 = *a6;
      if (v16 == v15 && !a6[1] && v15 <= 0x3E && ((1 << v15) & 0x4000008400000000) != 0) {
        goto LABEL_27;
      }
      if (v16 == 38 && a6[1] == 35)
      {
        if (a6[2] == 120)
        {
          strcpy((char *)&v23[4], "00;");
          v23[4] = a0123456789abcd[v15 >> 4];
          v23[5] = a0123456789abcd[v15 & 0xF];
          if (!xmlStrcasecmp(a6 + 3, &v23[4])) {
            goto LABEL_27;
          }
        }
        else
        {
          strcpy((char *)&v23[2], ";");
          unsigned int v19 = (205 * v15) >> 11;
          v23[0] = (v19 - 10 * ((unsigned __int16)(26 * v19) >> 8)) | 0x30;
          v23[1] = (v15 - 10 * v19) | 0x30;
          if (xmlStrEqual(a6 + 2, v23)) {
            goto LABEL_27;
          }
        }
      }
    }
    __xmlSimpleError(2, 104, 0, (uint64_t)"xmlAddEntity: invalid redeclaration of predefined entity", 0);
    return 0;
  }
LABEL_27:
  Dict = (xmlHashTable *)a1[12];
  if (!Dict)
  {
    Dict = xmlHashCreateDict(0, v13);
    a1[12] = Dict;
    if (!Dict) {
      return 0;
    }
  }
LABEL_29:
  Entity = xmlCreateEntity(v13, name, a3, a4, a5, a6);
  uint64_t v21 = (uint64_t)Entity;
  if (Entity)
  {
    Entity[8] = a1[8];
    if (xmlHashAddEntry(Dict, name, Entity))
    {
      xmlFreeEntity(v21);
      return 0;
    }
  }
  return v21;
}

xmlEntityPtr xmlAddDocEntity(xmlDocPtr doc, const xmlChar *name, int type, const xmlChar *ExternalID, const xmlChar *SystemID, const xmlChar *content)
{
  if (!doc)
  {
    int v9 = "xmlAddDocEntity: document is NULL";
    int v10 = 521;
LABEL_9:
    __xmlSimpleError(2, v10, 0, (uint64_t)v9, 0);
    return 0;
  }
  intSubset = doc->intSubset;
  if (!intSubset)
  {
    int v9 = "xmlAddDocEntity: document without internal subset";
    int v10 = 522;
    goto LABEL_9;
  }
  xmlEntityPtr result = (xmlEntityPtr)xmlAddEntity(&doc->intSubset->_private, (xmlChar *)name, type, ExternalID, SystemID, content);
  if (result)
  {
    result->xmlNodePtr parent = intSubset;
    result->xmlDocPtr doc = intSubset->doc;
    last = intSubset->last;
    if (last)
    {
      last->xmlNodePtr next = (_xmlNode *)result;
      result->int prev = last;
    }
    else
    {
      intSubset->children = (_xmlNode *)result;
    }
    intSubset->last = (_xmlNode *)result;
  }
  return result;
}

xmlEntityPtr xmlNewEntity(xmlDocPtr doc, const xmlChar *name, int type, const xmlChar *ExternalID, const xmlChar *SystemID, const xmlChar *content)
{
  uint64_t v6 = doc;
  if (doc)
  {
    if (doc->intSubset)
    {
      return xmlAddDocEntity(doc, name, type, ExternalID, SystemID, content);
    }
    xmlDocPtr doc = (xmlDocPtr)doc->dict;
  }
  xmlEntityPtr result = (xmlEntityPtr)xmlCreateEntity((xmlDict *)doc, name, type, ExternalID, SystemID, content);
  if (result) {
    result->xmlDocPtr doc = v6;
  }
  return result;
}

void *xmlCreateEntity(xmlDict *a1, const xmlChar *a2, int a3, const xmlChar *a4, const xmlChar *a5, const xmlChar *a6)
{
  uint64_t v12 = xmlMalloc(0x88uLL);
  BOOL v13 = v12;
  if (!v12)
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"xmlCreateEntity: malloc failed");
    return v13;
  }
  v12[16] = 0;
  *((_OWORD *)v12 + 6) = 0u;
  *((_OWORD *)v12 + 7) = 0u;
  *((_OWORD *)v12 + 4) = 0u;
  *((_OWORD *)v12 + 5) = 0u;
  *((_OWORD *)v12 + 2) = 0u;
  *((_OWORD *)v12 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0u;
  *(_OWORD *)uint64_t v12 = 0u;
  *((_OWORD *)v12 + 1) = 0u;
  *((_DWORD *)v12 + 2) = 17;
  *((_DWORD *)v12 + 3xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0;
  *((_DWORD *)v12 + 2xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = a3;
  if (a1)
  {
    v12[2] = xmlDictLookup(a1, a2, -1);
    v13[12] = xmlStrdup(a4);
  }
  else
  {
    v12[2] = xmlStrdup(a2);
    if (a4) {
      v13[12] = xmlStrdup(a4);
    }
    if (!a5) {
      goto LABEL_9;
    }
  }
  v13[13] = xmlStrdup(a5);
LABEL_9:
  if (a6)
  {
    int v14 = xmlStrlen(a6);
    *((_DWORD *)v13 + 22) = v14;
    unint64_t v15 = xmlStrndup(a6, v14);
  }
  else
  {
    unint64_t v15 = 0;
    *((_DWORD *)v13 + 22) = 0;
  }
  v13[15] = 0;
  v13[9] = 0;
  v13[10] = v15;
  *((_DWORD *)v13 + 32) = 0;
  return v13;
}

xmlEntityPtr xmlGetParameterEntity(xmlEntityPtr doc, const xmlChar *name)
{
  if (doc)
  {
    xmlEntityPtr v3 = doc;
    content = doc->content;
    if (!content
      || (uint64_t v5 = (xmlHashTable *)*((void *)content + 15)) == 0
      || (xmlDocPtr doc = (xmlEntityPtr)xmlHashLookup(v5, name)) == 0)
    {
      uint64_t v6 = *(void *)&v3->length;
      if (v6)
      {
        xmlDocPtr doc = *(xmlEntityPtr *)(v6 + 120);
        if (doc)
        {
          return (xmlEntityPtr)xmlHashLookup((xmlHashTablePtr)doc, name);
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return doc;
}

xmlEntityPtr xmlGetDtdEntity(xmlDocPtr doc, const xmlChar *name)
{
  if (doc && (extSubset = doc->extSubset) != 0 && (entities = (xmlHashTable *)extSubset->entities) != 0) {
    return (xmlEntityPtr)xmlHashLookup(entities, name);
  }
  else {
    return 0;
  }
}

xmlEntityPtr xmlGetDocEntity(const xmlDoc *doc, const xmlChar *name)
{
  if (!doc
    || ((intSubset = doc->intSubset) == 0
     || (entities = (xmlHashTable *)intSubset->entities) == 0
     || (xmlEntityPtr result = (xmlEntityPtr)xmlHashLookup(entities, name)) == 0)
    && (doc->standalone == 1
     || (extSubset = doc->extSubset) == 0
     || (int v8 = (xmlHashTable *)extSubset->entities) == 0
     || (xmlEntityPtr result = (xmlEntityPtr)xmlHashLookup(v8, name)) == 0))
  {
    return xmlGetPredefinedEntity(name);
  }
  return result;
}

char *xmlEncodeAttributeEntities(uint64_t a1, char *a2)
{
  return xmlEncodeEntitiesInternal(a1, a2, 1);
}

char *xmlEncodeEntitiesInternal(uint64_t a1, char *a2, int a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  uint64_t v4 = a2;
  if (a1) {
    BOOL v6 = *(_DWORD *)(a1 + 8) == 13;
  }
  else {
    BOOL v6 = 0;
  }
  int v7 = (char *)xmlMalloc(0x3E8uLL);
  if (!v7)
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"xmlEncodeEntities: malloc failed");
    return 0;
  }
  int v8 = v7;
  unsigned int v9 = *v4;
  if (*v4)
  {
    if (a3) {
      BOOL v10 = !v6;
    }
    else {
      BOOL v10 = 1;
    }
    int v11 = !v10;
    size_t v12 = 1000;
    BOOL v13 = v7;
    while (1)
    {
      if (v8 - v13 + 100 > v12)
      {
        if ((v12 & 0x8000000000000000) != 0 || (v12 *= 2, (int v14 = (char *)xmlRealloc(v13, v12)) == 0))
        {
LABEL_111:
          __xmlSimpleError(2, 2, 0, 0, (uint64_t)"xmlEncodeEntities: realloc failed");
          xmlFree(v13);
          return 0;
        }
        int v8 = &v14[v8 - v13];
        unsigned int v9 = *v4;
        BOOL v13 = v14;
      }
      if (v9 == 38)
      {
        if (v11 && v4[1] == 123 && strchr(v4, 125))
        {
          ++v4;
          char v20 = 38;
          do
          {
            *v8++ = v20;
            if (v8 - v13 + 100 > v12)
            {
              if ((v12 & 0x8000000000000000) != 0) {
                goto LABEL_111;
              }
              v12 *= 2;
              uint64_t v21 = (char *)xmlRealloc(v13, v12);
              if (!v21) {
                goto LABEL_111;
              }
              int v8 = &v21[v8 - v13];
              BOOL v13 = v21;
            }
            int v22 = *v4++;
            char v20 = v22;
          }
          while (v22 != 125);
          *v8++ = v20;
          goto LABEL_79;
        }
        *(_DWORD *)int v8 = 1886216486;
        v8[4] = 59;
        v8 += 5;
        goto LABEL_78;
      }
      if (v9 == 62) {
        break;
      }
      if (v9 == 60)
      {
        if (v11)
        {
          if (v4[1] == 33 && v4[2] == 45 && v4[3] == 45)
          {
            unint64_t v15 = xmlStrstr((const xmlChar *)v4, (const xmlChar *)"-->");
            if (v15)
            {
              int v16 = (char *)v15;
              if (v4 != (char *)v15)
              {
                do
                {
                  char v17 = *v4++;
                  *v8++ = v17;
                  if (v8 - v13 + 100 > v12)
                  {
                    if ((v12 & 0x8000000000000000) != 0) {
                      goto LABEL_111;
                    }
                    v12 *= 2;
                    uint64_t v18 = (char *)xmlRealloc(v13, v12);
                    if (!v18) {
                      goto LABEL_111;
                    }
                    int v8 = &v18[v8 - v13];
                    BOOL v13 = v18;
                  }
                }
                while (v4 != v16);
                uint64_t v4 = v16;
              }
              *int v8 = *v4;
              v8[1] = v4[1];
              char v19 = v4[2];
              v4 += 3;
              v8[2] = v19;
              v8 += 3;
              goto LABEL_79;
            }
          }
        }
        int v23 = 997485606;
        goto LABEL_62;
      }
      int v25 = v6 && v9 == 13;
      if ((char)v9 <= 31 && v9 - 9 >= 2 && !v25)
      {
        if ((v9 & 0x80) == 0)
        {
          if (v9 <= 0xD && ((1 << v9) & 0x2600) != 0)
          {
            memset(__str, 0, 11);
            snprintf(__str, 0xBuLL, "&#%d;", *v4);
            __str[10] = 0;
            char v26 = __str[0];
            if (__str[0])
            {
              char v27 = &__str[1];
              do
              {
                *v8++ = v26;
                int v28 = *v27++;
                char v26 = v28;
              }
              while (v28);
            }
          }
          goto LABEL_78;
        }
        if (a1)
        {
          if (!v6 && !*(void *)(a1 + 112))
          {
LABEL_67:
            memset(__str, 0, 11);
            unsigned int v29 = *v4;
            if ((~v29 & 0xC0) == 0)
            {
              int v31 = v4 + 1;
              char v30 = v4[1];
              if ((v30 & 0xC0) == 0x80 && ((~v29 & 0xE0) != 0 || (v4[2] & 0xC0) == 0x80))
              {
                if (v29 < 0xF0)
                {
                  if ((~v29 & 0xF8) != 0)
                  {
                    __int16 v38 = (_WORD)v29 << 6;
                    int v39 = v30 & 0x3F;
                    if (v29 > 0xDF)
                    {
                      unsigned int v33 = v4[2] & 0x3F | ((v38 & 0x3C0 | v39) << 6);
                      uint64_t v34 = 3;
                    }
                    else
                    {
                      unsigned int v33 = v38 & 0x7C0 | v39;
                      uint64_t v34 = 2;
                    }
LABEL_92:
                    if (v33 > 0xFF)
                    {
                      if (v33 >> 11 >= 0x1B && (v33 - 57344) >> 1 >= 0xFFF && v33 - 0x10000 >= 0x100000) {
                        goto LABEL_100;
                      }
                    }
                    else if (v33 <= 0x1F && (v33 > 0xD || ((1 << v33) & 0x2600) == 0))
                    {
                      goto LABEL_100;
                    }
                    snprintf(__str, 0xBuLL, "&#x%X;", v33);
                    __str[10] = 0;
                    char v43 = __str[0];
                    if (__str[0])
                    {
                      int v44 = &__str[1];
                      do
                      {
                        *v8++ = v43;
                        int v45 = *v44++;
                        char v43 = v45;
                      }
                      while (v45);
                    }
                    int v31 = &v4[v34];
LABEL_88:
                    uint64_t v4 = v31;
                    goto LABEL_79;
                  }
                }
                else if ((~v29 & 0xF8) != 0)
                {
                  char v32 = v4[3];
                  if ((v32 & 0xC0) == 0x80)
                  {
                    if (v29 <= 0xF7)
                    {
                      unsigned int v33 = ((v30 & 0x3F | ((v29 & 7) << 6)) << 12) | ((v4[2] & 0x3F) << 6) | v32 & 0x3F;
                      uint64_t v34 = 4;
                      goto LABEL_92;
                    }
LABEL_100:
                    __xmlSimpleError(2, 9, 0, (uint64_t)"xmlEncodeEntities: char out of range\n", 0);
                    if (a1) {
                      *(void *)(a1 + 112) = xmlStrdup((const xmlChar *)"ISO-8859-1");
                    }
                    snprintf(__str, 0xBuLL, "&#%d;", *v4);
                    __str[10] = 0;
                    char v40 = __str[0];
                    if (__str[0])
                    {
                      int v41 = &__str[1];
                      do
                      {
                        *v8++ = v40;
                        int v42 = *v41++;
                        char v40 = v42;
                      }
                      while (v42);
                    }
                    goto LABEL_88;
                  }
                }
              }
            }
            __xmlSimpleError(2, 5032, 0, (uint64_t)"xmlEncodeEntities: input not UTF-8", 0);
            if (a1) {
              *(void *)(a1 + 112) = xmlStrdup((const xmlChar *)"ISO-8859-1");
            }
            snprintf(__str, 0xBuLL, "&#%d;", *v4);
            __str[10] = 0;
            char v35 = __str[0];
            if (__str[0])
            {
              unsigned int v36 = &__str[1];
              do
              {
                *v8++ = v35;
                int v37 = *v36++;
                char v35 = v37;
              }
              while (v37);
            }
            int v31 = v4 + 1;
            goto LABEL_88;
          }
        }
        else if (!v6)
        {
          goto LABEL_67;
        }
      }
      *v8++ = v9;
LABEL_78:
      ++v4;
LABEL_79:
      unsigned int v9 = *v4;
      if (!*v4) {
        goto LABEL_114;
      }
    }
    int v23 = 997484326;
LABEL_62:
    *(_DWORD *)int v8 = v23;
    v8 += 4;
    goto LABEL_78;
  }
  BOOL v13 = v7;
LABEL_114:
  *int v8 = 0;
  return v13;
}

xmlChar *__cdecl xmlEncodeEntitiesReentrant(xmlDocPtr doc, const xmlChar *input)
{
  return (xmlChar *)xmlEncodeEntitiesInternal((uint64_t)doc, (char *)input, 0);
}

xmlChar *__cdecl xmlEncodeSpecialChars(const xmlDoc *doc, const xmlChar *input)
{
  if (!input) {
    return 0;
  }
  xmlFreeFunc v2 = input;
  xmlEntityPtr v3 = (xmlChar *)xmlMalloc(0x3E8uLL);
  uint64_t v4 = v3;
  if (v3)
  {
    unint64_t v5 = 1000;
    BOOL v6 = v3;
    while (1)
    {
      int v7 = *v2;
      if (!*v2)
      {
        *BOOL v6 = 0;
        return v4;
      }
      if (v6 - v4 + 10 > v5)
      {
        if ((v5 & 0x8000000000000000) != 0 || (int v8 = (xmlChar *)xmlRealloc(v4, 2 * v5)) == 0)
        {
          __xmlSimpleError(2, 2, 0, 0, (uint64_t)"xmlEncodeSpecialChars: realloc failed");
          xmlFree(v4);
          return 0;
        }
        BOOL v6 = &v8[v6 - v4];
        int v7 = *v2;
        uint64_t v4 = v8;
        v5 *= 2;
      }
      if (v7 <= 37)
      {
        if (v7 == 13)
        {
          int v10 = 858858278;
          goto LABEL_22;
        }
        if (v7 == 34)
        {
          *(_DWORD *)BOOL v6 = 1869967654;
          *((_WORD *)v6 + 2) = 15220;
          v6 += 6;
          goto LABEL_24;
        }
      }
      else
      {
        switch(v7)
        {
          case '&':
            int v10 = 1886216486;
LABEL_22:
            *(_DWORD *)BOOL v6 = v10;
            v6[4] = 59;
            v6 += 5;
            goto LABEL_24;
          case '>':
            int v9 = 997484326;
            goto LABEL_20;
          case '<':
            int v9 = 997485606;
LABEL_20:
            *(_DWORD *)BOOL v6 = v9;
            v6 += 4;
            goto LABEL_24;
        }
      }
      *v6++ = v7;
LABEL_24:
      ++v2;
    }
  }
  __xmlSimpleError(2, 2, 0, 0, (uint64_t)"xmlEncodeSpecialChars: malloc failed");
  return v4;
}

xmlEntitiesTablePtr xmlCreateEntitiesTable(void)
{
  return xmlHashCreate(0);
}

void xmlFreeEntitiesTable(xmlEntitiesTablePtr table)
{
}

uint64_t xmlFreeEntityWrapper(uint64_t a1)
{
  if (a1) {
    return xmlFreeEntity(a1);
  }
  return a1;
}

xmlEntitiesTablePtr xmlCopyEntitiesTable(xmlEntitiesTablePtr table)
{
  return xmlHashCopy(table, (xmlHashCopier)xmlCopyEntity);
}

void *xmlCopyEntity(uint64_t a1)
{
  xmlFreeFunc v2 = xmlMalloc(0x88uLL);
  xmlEntityPtr v3 = v2;
  if (v2)
  {
    v2[16] = 0;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0u;
    *(_OWORD *)xmlFreeFunc v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((_DWORD *)v2 + 2) = 17;
    *((_DWORD *)v2 + 2xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = *(_DWORD *)(a1 + 92);
    uint64_t v4 = *(const xmlChar **)(a1 + 16);
    if (v4) {
      v3[2] = xmlStrdup(v4);
    }
    unint64_t v5 = *(const xmlChar **)(a1 + 96);
    if (v5) {
      v3[12] = xmlStrdup(v5);
    }
    BOOL v6 = *(const xmlChar **)(a1 + 104);
    if (v6) {
      v3[13] = xmlStrdup(v6);
    }
    int v7 = *(const xmlChar **)(a1 + 80);
    if (v7) {
      v3[10] = xmlStrdup(v7);
    }
    int v8 = *(const xmlChar **)(a1 + 72);
    if (v8) {
      v3[9] = xmlStrdup(v8);
    }
    int v9 = *(const xmlChar **)(a1 + 120);
    if (v9) {
      v3[15] = xmlStrdup(v9);
    }
  }
  else
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"xmlCopyEntity:: malloc failed");
  }
  return v3;
}

void xmlDumpEntityDecl(xmlBufferPtr buf, xmlEntityPtr ent)
{
  if (buf && ent)
  {
    switch(ent->etype)
    {
      case XML_INTERNAL_GENERAL_ENTITY:
        uint64_t v4 = "<!ENTITY ";
        goto LABEL_13;
      case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
        unint64_t v5 = "<!ENTITY ";
        goto LABEL_16;
      case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
        xmlBufferWriteChar(buf, "<!ENTITY ");
        xmlBufferWriteCHAR(buf, ent->name);
        if (ent->ExternalID)
        {
          xmlBufferWriteChar(buf, " PUBLIC ");
          xmlBufferWriteQuotedString(buf, ent->ExternalID);
          BOOL v6 = " ";
        }
        else
        {
          BOOL v6 = " SYSTEM ";
        }
        xmlBufferWriteChar(buf, v6);
        xmlBufferWriteQuotedString(buf, ent->SystemID);
        if (ent->content)
        {
          xmlBufferWriteChar(buf, " NDATA ");
          orig = ent->orig;
          if (!orig) {
            orig = ent->content;
          }
          xmlBufferWriteCHAR(buf, orig);
        }
        goto LABEL_21;
      case XML_INTERNAL_PARAMETER_ENTITY:
        uint64_t v4 = "<!ENTITY % ";
LABEL_13:
        xmlBufferWriteChar(buf, v4);
        xmlBufferWriteCHAR(buf, ent->name);
        xmlBufferWriteChar(buf, " ");
        SystemID = ent->orig;
        if (SystemID) {
          goto LABEL_20;
        }
        xmlDumpEntityContent((uint64_t)buf, ent->content);
        goto LABEL_21;
      case XML_EXTERNAL_PARAMETER_ENTITY:
        unint64_t v5 = "<!ENTITY % ";
LABEL_16:
        xmlBufferWriteChar(buf, v5);
        xmlBufferWriteCHAR(buf, ent->name);
        if (ent->ExternalID)
        {
          xmlBufferWriteChar(buf, " PUBLIC ");
          xmlBufferWriteQuotedString(buf, ent->ExternalID);
          int v8 = " ";
        }
        else
        {
          int v8 = " SYSTEM ";
        }
        xmlBufferWriteChar(buf, v8);
        SystemID = ent->SystemID;
LABEL_20:
        xmlBufferWriteQuotedString(buf, SystemID);
LABEL_21:
        xmlBufferWriteChar(buf, ">\n");
        break;
      default:
        __xmlSimpleError(2, 535, 0, (uint64_t)"xmlDumpEntitiesDecl: internal: unknown type entity type", 0);
        break;
    }
  }
}

void xmlDumpEntityContent(uint64_t a1, xmlChar *str)
{
  if (*(_DWORD *)(a1 + 16) != 2)
  {
    xmlFreeFunc v2 = str;
    if (xmlStrchr(str, 0x25u))
    {
      xmlBufferCCat((xmlBufferPtr)a1, "\"");
LABEL_4:
      for (uint64_t i = 0; ; ++i)
      {
        int v5 = v2[i];
        if (!v2[i]) {
          break;
        }
        if (v5 == 37)
        {
          BOOL v6 = "&#x25;";
          if (i) {
            goto LABEL_10;
          }
          goto LABEL_11;
        }
        if (v5 == 34)
        {
          BOOL v6 = "&quot;";
          if (!i) {
            goto LABEL_11;
          }
LABEL_10:
          xmlBufferAdd((xmlBufferPtr)a1, v2, i);
LABEL_11:
          xmlBufferAdd((xmlBufferPtr)a1, (const xmlChar *)v6, 6);
          v2 += i + 1;
          goto LABEL_4;
        }
      }
      if (i) {
        xmlBufferAdd((xmlBufferPtr)a1, v2, i);
      }
      xmlBufferCCat((xmlBufferPtr)a1, "\"");
    }
    else
    {
      xmlBufferWriteQuotedString((xmlBufferPtr)a1, v2);
    }
  }
}

void xmlDumpEntitiesTable(xmlBufferPtr buf, xmlEntitiesTablePtr table)
{
}

void xmlDumpEntityDeclScan(xmlEntityPtr ent, xmlBufferPtr buf)
{
}

uint64_t xmlFreeEntity(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (v2) {
    xmlEntityPtr v3 = *(xmlDict **)(v2 + 152);
  }
  else {
    xmlEntityPtr v3 = 0;
  }
  uint64_t v4 = *(xmlNode **)(a1 + 24);
  if (v4 && *(_DWORD *)(a1 + 128) == 1 && v4->parent == (_xmlNode *)a1) {
    xmlFreeNodeList(v4);
  }
  int v5 = *(xmlChar **)(a1 + 16);
  if (v5)
  {
    if (v3)
    {
      if (xmlDictOwns(v3, v5)) {
        goto LABEL_13;
      }
      int v5 = *(xmlChar **)(a1 + 16);
    }
    xmlFree(v5);
  }
LABEL_13:
  BOOL v6 = *(void **)(a1 + 96);
  if (v6) {
    xmlFree(v6);
  }
  int v7 = *(void **)(a1 + 104);
  if (v7) {
    xmlFree(v7);
  }
  int v8 = *(void **)(a1 + 120);
  if (v8) {
    xmlFree(v8);
  }
  int v9 = *(void **)(a1 + 80);
  if (v9) {
    xmlFree(v9);
  }
  int v10 = *(void **)(a1 + 72);
  if (v10) {
    xmlFree(v10);
  }
  xmlFreeFunc v11 = xmlFree;

  return ((uint64_t (*)(uint64_t))v11)(a1);
}

uint64_t xmlGenericErrorDefaultFunc(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (!*__xmlGenericErrorContext())
  {
    int v10 = (void *)*MEMORY[0x1E4F143C8];
    *__xmlGenericErrorContext() = v10;
  }
  xmlFreeFunc v11 = __xmlGenericErrorContext();
  return vfprintf((FILE *)*v11, a2, &a9);
}

void xmlSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler)
{
  *__xmlGenericErrorContext() = ctx;
  xmlEntityPtr v3 = __xmlGenericError();
  if (handler) {
    uint64_t v4 = handler;
  }
  else {
    uint64_t v4 = (void (*)(void *, const char *, ...))xmlGenericErrorDefaultFunc;
  }
  xmlGenericErrorFunc *v3 = v4;
}

void xmlParserPrintFileInfo(xmlParserInputPtr input)
{
  if (input)
  {
    filename = input->filename;
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    xmlEntityPtr v3 = *__xmlGenericErrorContext();
    if (filename) {
      uint64_t v4 = "%s:%d: ";
    }
    else {
      uint64_t v4 = "Entity: line %d: ";
    }
    v2(v3, v4);
  }
}

void xmlParserPrintFileContext(xmlParserInputPtr input)
{
  xmlGenericErrorFunc v2 = (void (*)(uint64_t, const char *, ...))*__xmlGenericError();
  xmlEntityPtr v3 = *__xmlGenericErrorContext();

  xmlParserPrintFileContextInternal((uint64_t)input, v2, (uint64_t)v3);
}

uint64_t xmlParserPrintFileContextInternal(uint64_t result, void (*a2)(uint64_t, const char *, ...), uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    xmlEntityPtr v3 = *(unsigned __int8 **)(result + 32);
    if (v3)
    {
      char v22 = 0;
      memset(v21, 0, sizeof(v21));
      unint64_t v6 = *(void *)(result + 24);
      int v7 = v3;
      if ((unint64_t)v3 > v6)
      {
        int v7 = v3;
        while (1)
        {
          int v8 = *v7;
          if (v8 != 13 && v8 != 10) {
            break;
          }
          if ((unint64_t)--v7 <= v6)
          {
            int v7 = *(unsigned __int8 **)(result + 24);
            break;
          }
        }
      }
      if ((unint64_t)v7 <= v6)
      {
LABEL_20:
        int v11 = *v7;
      }
      else
      {
        unsigned int v10 = 1;
        while (1)
        {
          int v11 = *v7;
          if (v11 == 10 || v11 == 13) {
            break;
          }
          --v7;
          if (v10 <= 0x4F)
          {
            ++v10;
            if ((unint64_t)v7 > v6) {
              continue;
            }
          }
          goto LABEL_20;
        }
      }
      uint64_t v13 = 0;
      if (v11 == 13 || v11 == 10) {
        ++v7;
      }
      int v15 = v3 - v7;
      while (1)
      {
        int v16 = v7[v13];
        BOOL v17 = !v7[v13] || v16 == 10;
        BOOL v18 = v17 || v16 == 13;
        if (v18 || v13 > 0x4F) {
          break;
        }
        *((unsigned char *)v21 + v13++) = v16;
      }
      *((unsigned char *)v21 + v1xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0;
      a2(a3, "%s\n", (const char *)v21);
      if (v15)
      {
        uint64_t v19 = 0;
        char v20 = v21;
        do
        {
          if (v19 == 79) {
            break;
          }
          if (*((unsigned char *)v21 + v19) != 9)
          {
            if (!*((unsigned char *)v21 + v19)) {
              goto LABEL_45;
            }
            *((unsigned char *)v21 + v19) = 32;
          }
          char v20 = (_WORD *)((char *)v20 + 1);
          ++v19;
        }
        while (v15 != v19);
        char v20 = (_WORD *)((char *)v21 + v19);
      }
      else
      {
        char v20 = v21;
      }
LABEL_45:
      _WORD *v20 = 94;
      return ((uint64_t (*)(uint64_t, const char *, ...))a2)(a3, "%s\n", (const char *)v21);
    }
  }
  return result;
}

void xmlParserError(void *ctx, const char *msg, ...)
{
  va_start(va, msg);
  if (ctx)
  {
    uint64_t v4 = (xmlParserInput *)*((void *)ctx + 7);
    if (v4)
    {
      if (v4->filename || (int v5 = *((_DWORD *)ctx + 16), v6 = __OFSUB__(v5, 2), v7 = v5 - 2, (v7 < 0) ^ v6))
      {
        int v8 = (xmlParserInput *)*((void *)ctx + 7);
        uint64_t v4 = 0;
      }
      else
      {
        int v8 = *(xmlParserInput **)(*((void *)ctx + 9) + 8 * v7);
      }
    }
    else
    {
      int v8 = 0;
    }
    xmlParserInputPtr input = v8;
    xmlParserPrintFileInfo(v8);
  }
  else
  {
    xmlParserInputPtr input = 0;
    uint64_t v4 = 0;
  }
  xmlGenericErrorFunc v9 = *__xmlGenericError();
  unsigned int v10 = __xmlGenericErrorContext();
  v9(*v10, "error: ");
  int v11 = (char *)xmlMalloc(0x96uLL);
  if (v11)
  {
    int v12 = -1;
    int v13 = 150;
    do
    {
      int v14 = v11;
      if (v13 > 63999) {
        break;
      }
      int v15 = vsnprintf(v11, v13, msg, va);
      if ((v15 & 0x80000000) == 0 && v15 < v13)
      {
        BOOL v16 = v12 == v15;
        int v12 = v15;
        if (v16) {
          break;
        }
      }
      int v17 = v15 >= 0 ? v15 + 1 : 100;
      v13 += v17;
      int v11 = (char *)xmlRealloc(v14, v13);
    }
    while (v11);
  }
  else
  {
    int v14 = 0;
  }
  xmlGenericErrorFunc v18 = *__xmlGenericError();
  uint64_t v19 = __xmlGenericErrorContext();
  v18(*v19, "%s", v14);
  if (v14) {
    xmlFree(v14);
  }
  if (ctx)
  {
    xmlParserPrintFileContext(input);
    if (v4)
    {
      xmlParserPrintFileInfo(v4);
      xmlGenericErrorFunc v20 = *__xmlGenericError();
      uint64_t v21 = __xmlGenericErrorContext();
      v20(*v21, "\n");
      xmlParserPrintFileContext(v4);
    }
  }
}

void xmlParserWarning(void *ctx, const char *msg, ...)
{
  va_start(va, msg);
  if (ctx)
  {
    uint64_t v4 = (xmlParserInput *)*((void *)ctx + 7);
    if (v4)
    {
      if (v4->filename || (int v5 = *((_DWORD *)ctx + 16), v6 = __OFSUB__(v5, 2), v7 = v5 - 2, (v7 < 0) ^ v6))
      {
        int v8 = (xmlParserInput *)*((void *)ctx + 7);
        uint64_t v4 = 0;
      }
      else
      {
        int v8 = *(xmlParserInput **)(*((void *)ctx + 9) + 8 * v7);
      }
    }
    else
    {
      int v8 = 0;
    }
    xmlParserInputPtr input = v8;
    xmlParserPrintFileInfo(v8);
  }
  else
  {
    xmlParserInputPtr input = 0;
    uint64_t v4 = 0;
  }
  xmlGenericErrorFunc v9 = *__xmlGenericError();
  unsigned int v10 = __xmlGenericErrorContext();
  v9(*v10, "warning: ");
  int v11 = (char *)xmlMalloc(0x96uLL);
  if (v11)
  {
    int v12 = -1;
    int v13 = 150;
    do
    {
      int v14 = v11;
      if (v13 > 63999) {
        break;
      }
      int v15 = vsnprintf(v11, v13, msg, va);
      if ((v15 & 0x80000000) == 0 && v15 < v13)
      {
        BOOL v16 = v12 == v15;
        int v12 = v15;
        if (v16) {
          break;
        }
      }
      int v17 = v15 >= 0 ? v15 + 1 : 100;
      v13 += v17;
      int v11 = (char *)xmlRealloc(v14, v13);
    }
    while (v11);
  }
  else
  {
    int v14 = 0;
  }
  xmlGenericErrorFunc v18 = *__xmlGenericError();
  uint64_t v19 = __xmlGenericErrorContext();
  v18(*v19, "%s", v14);
  if (v14) {
    xmlFree(v14);
  }
  if (ctx)
  {
    xmlParserPrintFileContext(input);
    if (v4)
    {
      xmlParserPrintFileInfo(v4);
      xmlGenericErrorFunc v20 = *__xmlGenericError();
      uint64_t v21 = __xmlGenericErrorContext();
      v20(*v21, "\n");
      xmlParserPrintFileContext(v4);
    }
  }
}

void xmlParserValidityError(void *ctx, const char *msg, ...)
{
  va_start(va, msg);
  int v4 = xmlStrlen((const xmlChar *)msg);
  if (v4 < 2 || msg[v4 - 2] == 58)
  {
    int v5 = 0;
    char v6 = 1;
  }
  else
  {
    if (ctx)
    {
      int v5 = (xmlParserInput *)*((void *)ctx + 7);
      if (!v5->filename)
      {
        int v7 = *((_DWORD *)ctx + 16);
        BOOL v8 = __OFSUB__(v7, 2);
        int v9 = v7 - 2;
        if (v9 < 0 == v8) {
          int v5 = *(xmlParserInput **)(*((void *)ctx + 9) + 8 * v9);
        }
      }
      if ((xmlParserValidityError_had_info & 1) == 0) {
        xmlParserPrintFileInfo(v5);
      }
    }
    else
    {
      int v5 = 0;
    }
    xmlGenericErrorFunc v10 = *__xmlGenericError();
    int v11 = __xmlGenericErrorContext();
    v10(*v11, "validity error: ");
    char v6 = 0;
  }
  xmlParserValidityError_had_xmlParserNodeInfo info = v6;
  int v12 = (char *)xmlMalloc(0x96uLL);
  if (v12)
  {
    int v13 = -1;
    int v14 = 150;
    do
    {
      int v15 = v12;
      if (v14 > 63999) {
        break;
      }
      int v16 = vsnprintf(v12, v14, msg, va);
      if ((v16 & 0x80000000) == 0 && v16 < v14)
      {
        BOOL v17 = v13 == v16;
        int v13 = v16;
        if (v17) {
          break;
        }
      }
      int v18 = v16 >= 0 ? v16 + 1 : 100;
      v14 += v18;
      int v12 = (char *)xmlRealloc(v15, v14);
    }
    while (v12);
  }
  else
  {
    int v15 = 0;
  }
  xmlGenericErrorFunc v19 = *__xmlGenericError();
  xmlGenericErrorFunc v20 = __xmlGenericErrorContext();
  v19(*v20, "%s", v15);
  if (v15) {
    xmlFree(v15);
  }
  if (ctx)
  {
    if (v5) {
      xmlParserPrintFileContext(v5);
    }
  }
}

void xmlParserValidityWarning(void *ctx, const char *msg, ...)
{
  va_start(va, msg);
  int v4 = xmlStrlen((const xmlChar *)msg);
  int v5 = 0;
  if (ctx && v4)
  {
    if (msg[v4 - 1] == 58)
    {
      int v5 = 0;
    }
    else
    {
      int v5 = (xmlParserInput *)*((void *)ctx + 7);
      if (!v5->filename)
      {
        int v6 = *((_DWORD *)ctx + 16);
        BOOL v7 = __OFSUB__(v6, 2);
        int v8 = v6 - 2;
        if (v8 < 0 == v7) {
          int v5 = *(xmlParserInput **)(*((void *)ctx + 9) + 8 * v8);
        }
      }
      xmlParserPrintFileInfo(v5);
    }
  }
  xmlGenericErrorFunc v9 = *__xmlGenericError();
  xmlGenericErrorFunc v10 = __xmlGenericErrorContext();
  v9(*v10, "validity warning: ");
  int v11 = (char *)xmlMalloc(0x96uLL);
  if (v11)
  {
    int v12 = -1;
    int v13 = 150;
    do
    {
      int v14 = v11;
      if (v13 > 63999) {
        break;
      }
      int v15 = vsnprintf(v11, v13, msg, va);
      if ((v15 & 0x80000000) == 0 && v15 < v13)
      {
        BOOL v16 = v12 == v15;
        int v12 = v15;
        if (v16) {
          break;
        }
      }
      int v17 = v15 >= 0 ? v15 + 1 : 100;
      v13 += v17;
      int v11 = (char *)xmlRealloc(v14, v13);
    }
    while (v11);
  }
  else
  {
    int v14 = 0;
  }
  xmlGenericErrorFunc v18 = *__xmlGenericError();
  xmlGenericErrorFunc v19 = __xmlGenericErrorContext();
  v18(*v19, "%s", v14);
  if (v14) {
    xmlFree(v14);
  }
  if (ctx) {
    xmlParserPrintFileContext(v5);
  }
}

uint64_t xmlReportError(uint64_t result, uint64_t a2, const xmlChar *a3, void (*a4)(void *, const char *, ...), uint64_t a5)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    xmlGenericErrorFunc v6 = a4;
    uint64_t v9 = result;
    if (!a4)
    {
      xmlGenericErrorFunc v6 = *__xmlGenericError();
      xmlEntityPtr result = (uint64_t)__xmlGenericErrorContext();
      a5 = *(void *)result;
    }
    if (*(_DWORD *)(v9 + 4))
    {
      int v10 = *(_DWORD *)(v9 + 32);
      uint64_t v11 = *(void *)(v9 + 80);
      if (v11 && *(_DWORD *)(v11 + 8) == 1) {
        int v12 = *(const char **)(v11 + 16);
      }
      else {
        int v12 = 0;
      }
      unsigned int v13 = *(_DWORD *)v9;
      uint64_t v14 = *(int *)(v9 + 16);
      int v28 = *(_DWORD *)(v9 + 32);
      if (a2)
      {
        uint64_t v15 = *(void *)(a2 + 56);
        if (!v15)
        {
          uint64_t v16 = 0;
          goto LABEL_28;
        }
        if (*(void *)(v15 + 8))
        {
          uint64_t v16 = *(void *)(a2 + 56);
          uint64_t v15 = 0;
LABEL_13:
          int v17 = "%s:%d: ";
LABEL_14:
          v6((void *)a5, v17);
          goto LABEL_28;
        }
        int v19 = *(_DWORD *)(a2 + 64);
        BOOL v20 = __OFSUB__(v19, 2);
        int v21 = v19 - 2;
        if (v21 < 0 != v20)
        {
          uint64_t v16 = *(void *)(a2 + 56);
          uint64_t v15 = 0;
        }
        else
        {
          uint64_t v16 = *(void *)(*(void *)(a2 + 72) + 8 * v21);
          if (!v16) {
            goto LABEL_28;
          }
          if (*(void *)(v16 + 8)) {
            goto LABEL_13;
          }
        }
        if (v10 && v13 == 1)
        {
          int v17 = "Entity: line %d: ";
          goto LABEL_14;
        }
LABEL_28:
        if (v12) {
          v6((void *)a5, "element %s: ", v12);
        }
        unsigned int v22 = v13 - 1;
        if (v13 - 1 <= 0x1D && ((0x3E7FBCFDu >> v22) & 1) != 0) {
          v6((void *)a5, off_1E60C71C0[v22]);
        }
        if (v14 <= 3) {
          v6((void *)a5, off_1E60C72B0[v14]);
        }
        if (a3 && ((int v23 = xmlStrlen(a3), v23 < 1) || a3[v23 - 1] == 10)) {
          uint64_t v24 = "%s";
        }
        else {
          uint64_t v24 = "%s\n";
        }
        xmlEntityPtr result = ((uint64_t (*)(uint64_t, const char *))v6)(a5, v24);
        if (!a2) {
          goto LABEL_49;
        }
        xmlEntityPtr result = xmlParserPrintFileContextInternal(v16, (void (*)(uint64_t, const char *, ...))v6, a5);
        if (!v15) {
          goto LABEL_49;
        }
        if (*(void *)(v15 + 8))
        {
          int v25 = "%s:%d: \n";
        }
        else
        {
          if (!v28 || v13 != 1) {
            goto LABEL_48;
          }
          int v25 = "Entity: line %d: \n";
        }
        v6((void *)a5, v25);
LABEL_48:
        xmlEntityPtr result = xmlParserPrintFileContextInternal(v15, (void (*)(uint64_t, const char *, ...))v6, a5);
LABEL_49:
        if (v13 == 12)
        {
          xmlEntityPtr result = *(void *)(v9 + 40);
          if (result)
          {
            int v26 = *(_DWORD *)(v9 + 64);
            if (v26 <= 99)
            {
              xmlEntityPtr result = xmlStrlen((const xmlChar *)result);
              if (v26 < (int)result)
              {
                memset(__b, 0, 150);
                v6((void *)a5, "%s\n", *(const char **)(v9 + 40));
                size_t v27 = *(unsigned int *)(v9 + 64);
                if ((int)v27 < 1) {
                  LODWORD(v27) = 0;
                }
                else {
                  memset(__b, 32, v27);
                }
                *(_WORD *)((char *)__b + v27) = 94;
                return ((uint64_t (*)(uint64_t, const char *, ...))v6)(a5, "%s\n", (const char *)__b);
              }
            }
          }
        }
        return result;
      }
      if (*(void *)(v9 + 24))
      {
        xmlGenericErrorFunc v18 = "%s:%d: ";
      }
      else
      {
        if (!v10)
        {
LABEL_27:
          uint64_t v16 = 0;
          uint64_t v15 = 0;
          goto LABEL_28;
        }
        uint64_t v16 = 0;
        if (v13 > 0x13)
        {
          uint64_t v15 = 0;
          goto LABEL_28;
        }
        uint64_t v15 = 0;
        if (((1 << v13) & 0xF0012) == 0) {
          goto LABEL_28;
        }
        xmlGenericErrorFunc v18 = "Entity: line %d: ";
      }
      v6((void *)a5, v18);
      goto LABEL_27;
    }
  }
  return result;
}

xmlErrorPtr xmlGetLastError(void)
{
  if (!__xmlLastError()->code) {
    return 0;
  }

  return __xmlLastError();
}

void xmlResetLastError(void)
{
  if (__xmlLastError()->code)
  {
    Error = __xmlLastError();
    xmlResetError(Error);
  }
}

void xmlCtxtResetLastError(void *ctx)
{
  if (ctx)
  {
    *((_DWORD *)ctx + 34) = 0;
    if (*((_DWORD *)ctx + 151)) {
      xmlResetError((xmlErrorPtr)((char *)ctx + 600));
    }
  }
}

void xmlCleanupGlobals(void)
{
  if (xmlThrDefMutex)
  {
    xmlFreeMutex((xmlMutexPtr)xmlThrDefMutex);
    xmlThrDefMutex = 0;
  }

  __xmlGlobalInitMutexDestroy();
}

void xmlThrDefSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  xmlGenericErrorContextThrDef = (uint64_t)ctx;
  if (handler) {
    int v4 = handler;
  }
  else {
    int v4 = xmlGenericErrorDefaultFunc;
  }
  xmlGenericErrorThrDef = (uint64_t)v4;
  int v5 = (xmlMutex *)xmlThrDefMutex;

  xmlMutexUnlock(v5);
}

void xmlThrDefSetStructuredErrorFunc(void *ctx, xmlStructuredErrorFunc handler)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  xmlStructuredErrorContextThrDef = (uint64_t)ctx;
  xmlStructuredErrorThrDef = (uint64_t)handler;
  int v4 = (xmlMutex *)xmlThrDefMutex;

  xmlMutexUnlock(v4);
}

xmlRegisterNodeFunc xmlRegisterNodeDefault(xmlRegisterNodeFunc func)
{
  uint64_t v1 = (void (__cdecl *)(xmlNodePtr))xmlRegisterNodeDefaultValue;
  __xmlRegisterCallbacks = 1;
  xmlRegisterNodeDefaultValue = (uint64_t)func;
  return v1;
}

xmlRegisterNodeFunc xmlThrDefRegisterNodeDefault(xmlRegisterNodeFunc func)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  xmlGenericErrorFunc v2 = (void (__cdecl *)(xmlNodePtr))xmlRegisterNodeDefaultValueThrDef;
  __xmlRegisterCallbacks = 1;
  xmlRegisterNodeDefaultValueThrDef = (uint64_t)func;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

xmlDeregisterNodeFunc xmlDeregisterNodeDefault(xmlDeregisterNodeFunc func)
{
  uint64_t v1 = (void (__cdecl *)(xmlNodePtr))xmlDeregisterNodeDefaultValue;
  __xmlRegisterCallbacks = 1;
  xmlDeregisterNodeDefaultValue = (uint64_t)func;
  return v1;
}

xmlDeregisterNodeFunc xmlThrDefDeregisterNodeDefault(xmlDeregisterNodeFunc func)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  xmlGenericErrorFunc v2 = (void (__cdecl *)(xmlNodePtr))xmlDeregisterNodeDefaultValueThrDef;
  __xmlRegisterCallbacks = 1;
  xmlDeregisterNodeDefaultValueThrDef = (uint64_t)func;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

xmlParserInputBufferCreateFilenameFunc xmlThrDefParserInputBufferCreateFilenameDefault(xmlParserInputBufferCreateFilenameFunc func)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  if (xmlParserInputBufferCreateFilenameValueThrDef) {
    xmlGenericErrorFunc v2 = (xmlParserInputBufferPtr (__cdecl *)(const char *, xmlCharEncoding))xmlParserInputBufferCreateFilenameValueThrDef;
  }
  else {
    xmlGenericErrorFunc v2 = __xmlParserInputBufferCreateFilename;
  }
  xmlParserInputBufferCreateFilenameValueThrDef = (uint64_t)func;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

xmlOutputBufferCreateFilenameFunc xmlThrDefOutputBufferCreateFilenameDefault(xmlOutputBufferCreateFilenameFunc func)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  if (xmlOutputBufferCreateFilenameValueThrDef) {
    xmlGenericErrorFunc v2 = (xmlOutputBufferPtr (__cdecl *)(const char *, xmlCharEncodingHandlerPtr, int))xmlOutputBufferCreateFilenameValueThrDef;
  }
  else {
    xmlGenericErrorFunc v2 = __xmlOutputBufferCreateFilename;
  }
  xmlOutputBufferCreateFilenameValueThrDef = (uint64_t)func;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

xmlSAXHandlerV1 *__docbDefaultSAXHandler(void)
{
  if (xmlIsMainThread()) {
    return (xmlSAXHandlerV1 *)docbDefaultSAXHandler;
  }
  else {
    return &xmlGetGlobalState()->docbDefaultSAXHandler;
  }
}

int *__oldXMLWDcompatibility(void)
{
  if (xmlIsMainThread()) {
    return (int *)&oldXMLWDcompatibility;
  }
  else {
    return &xmlGetGlobalState()->oldXMLWDcompatibility;
  }
}

xmlBufferAllocationScheme xmlThrDefBufferAllocScheme(xmlBufferAllocationScheme v)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  xmlBufferAllocationScheme v2 = xmlBufferAllocSchemeThrDef;
  xmlBufferAllocSchemeThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int xmlThrDefDefaultBufferSize(int v)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  int v2 = xmlDefaultBufferSizeThrDef;
  xmlDefaultBufferSizeThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int xmlThrDefDoValidityCheckingDefaultValue(int v)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  int v2 = xmlDoValidityCheckingDefaultValueThrDef;
  xmlDoValidityCheckingDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

void **__xmlGenericErrorContext(void)
{
  if (xmlIsMainThread()) {
    return (void **)&xmlGenericErrorContext;
  }
  else {
    return &xmlGetGlobalState()->xmlGenericErrorContext;
  }
}

int xmlThrDefGetWarningsDefaultValue(int v)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  int v2 = xmlGetWarningsDefaultValueThrDef;
  xmlGetWarningsDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int xmlThrDefIndentTreeOutput(int v)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  int v2 = xmlIndentTreeOutputThrDef;
  xmlIndentTreeOutputThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

const char *__cdecl xmlThrDefTreeIndentString(const char *v)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  int v2 = (const char *)xmlTreeIndentStringThrDef;
  xmlTreeIndentStringThrDef = (uint64_t)v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int xmlThrDefKeepBlanksDefaultValue(int v)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  int v2 = xmlKeepBlanksDefaultValueThrDef;
  xmlKeepBlanksDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int xmlThrDefLineNumbersDefaultValue(int v)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  int v2 = xmlLineNumbersDefaultValueThrDef;
  xmlLineNumbersDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int xmlThrDefLoadExtDtdDefaultValue(int v)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  int v2 = xmlLoadExtDtdDefaultValueThrDef;
  xmlLoadExtDtdDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int *__xmlParserDebugEntities(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlParserDebugEntities;
  }
  else {
    return &xmlGetGlobalState()->xmlParserDebugEntities;
  }
}

int xmlThrDefParserDebugEntities(int v)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  int v2 = xmlParserDebugEntitiesThrDef;
  xmlParserDebugEntitiesThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

const char **__xmlParserVersion(void)
{
  if (xmlIsMainThread()) {
    return (const char **)&xmlParserVersion;
  }

  return (const char **)xmlGetGlobalState();
}

int xmlThrDefPedanticParserDefaultValue(int v)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  int v2 = xmlPedanticParserDefaultValueThrDef;
  xmlPedanticParserDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int xmlThrDefSaveNoEmptyTags(int v)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  int v2 = xmlSaveNoEmptyTagsThrDef;
  xmlSaveNoEmptyTagsThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int xmlThrDefSubstituteEntitiesDefaultValue(int v)
{
  xmlMutexLock((xmlMutexPtr)xmlThrDefMutex);
  int v2 = xmlSubstituteEntitiesDefaultValueThrDef;
  xmlSubstituteEntitiesDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

xmlRegisterNodeFunc *__xmlRegisterNodeDefaultValue(void)
{
  if (xmlIsMainThread()) {
    return (xmlRegisterNodeFunc *)&xmlRegisterNodeDefaultValue;
  }
  else {
    return &xmlGetGlobalState()->xmlRegisterNodeDefaultValue;
  }
}

xmlDeregisterNodeFunc *__xmlDeregisterNodeDefaultValue(void)
{
  if (xmlIsMainThread()) {
    return (xmlDeregisterNodeFunc *)&xmlDeregisterNodeDefaultValue;
  }
  else {
    return &xmlGetGlobalState()->xmlDeregisterNodeDefaultValue;
  }
}

xmlParserInputBufferCreateFilenameFunc *__xmlParserInputBufferCreateFilenameValue(void)
{
  if (xmlIsMainThread()) {
    return (xmlParserInputBufferCreateFilenameFunc *)&xmlParserInputBufferCreateFilenameValue;
  }
  else {
    return &xmlGetGlobalState()->xmlParserInputBufferCreateFilenameValue;
  }
}

xmlOutputBufferCreateFilenameFunc *__xmlOutputBufferCreateFilenameValue(void)
{
  if (xmlIsMainThread()) {
    return (xmlOutputBufferCreateFilenameFunc *)&xmlOutputBufferCreateFilenameValue;
  }
  else {
    return &xmlGetGlobalState()->xmlOutputBufferCreateFilenameValue;
  }
}

xmlHashTablePtr xmlHashCreate(int size)
{
  int v2 = xmlMalloc(0x20uLL);
  xmlEntityPtr v3 = v2;
  if (v2)
  {
    if (size >= 1) {
      unsigned int v4 = size;
    }
    else {
      unsigned int v4 = 256;
    }
    *((void *)v2 + 2) = 0;
    v2[2] = v4;
    v2[3] = 0;
    size_t v5 = 48 * v4;
    xmlGenericErrorFunc v6 = xmlMalloc(v5);
    *(void *)xmlEntityPtr v3 = v6;
    if (v6)
    {
      bzero(v6, v5);
      v3[6] = __xmlRandom();
    }
    else
    {
      xmlFree(v3);
      return 0;
    }
  }
  return (xmlHashTablePtr)v3;
}

xmlHashTablePtr xmlHashCreateDict(int size, xmlDictPtr dict)
{
  xmlHashTablePtr v3 = xmlHashCreate(size);
  unsigned int v4 = v3;
  if (v3)
  {
    *((void *)v3 + 2) = dict;
    xmlDictReference(dict);
  }
  return v4;
}

void xmlHashFree(xmlHashTablePtr table, xmlHashDeallocator f)
{
  if (table)
  {
    xmlHashTablePtr v3 = *(char **)table;
    if (v3)
    {
      int v4 = *((_DWORD *)table + 2);
      int v5 = *((_DWORD *)table + 3);
      if (v4 >= 1 && v5 >= 1)
      {
        uint64_t v8 = 0;
        do
        {
          uint64_t v9 = *(char **)table;
          if (*(_DWORD *)(*(void *)table + 48 * v8 + 40)) {
            BOOL v10 = v9 == 0;
          }
          else {
            BOOL v10 = 1;
          }
          if (!v10)
          {
            char v11 = 0;
            int v12 = &v9[48 * v8];
            do
            {
              unsigned int v13 = *(char **)v12;
              if (f)
              {
                uint64_t v14 = *((void *)v12 + 4);
                if (v14) {
                  ((void (*)(uint64_t, void))f)(v14, *((void *)v12 + 1));
                }
              }
              if (!*((void *)table + 2))
              {
                uint64_t v15 = (void *)*((void *)v12 + 1);
                if (v15) {
                  xmlFree(v15);
                }
                uint64_t v16 = (void *)*((void *)v12 + 2);
                if (v16) {
                  xmlFree(v16);
                }
                int v17 = (void *)*((void *)v12 + 3);
                if (v17) {
                  xmlFree(v17);
                }
              }
              *((void *)v12 + 4) = 0;
              if (v11) {
                xmlFree(v12);
              }
              --v5;
              char v11 = 1;
              int v12 = v13;
            }
            while (v13);
            int v4 = *((_DWORD *)table + 2);
          }
          ++v8;
        }
        while (v8 < v4 && v5 > 0);
        xmlHashTablePtr v3 = *(char **)table;
      }
      xmlFree(v3);
    }
    xmlGenericErrorFunc v18 = (xmlDict *)*((void *)table + 2);
    if (v18) {
      xmlDictFree(v18);
    }
    xmlFreeFunc v19 = xmlFree;
    ((void (*)(xmlHashTablePtr))v19)(table);
  }
}

void xmlHashDefaultDeallocator(void *entry, const xmlChar *name)
{
}

int xmlHashAddEntry(xmlHashTablePtr table, const xmlChar *name, void *userdata)
{
  return xmlHashAddEntry3(table, name, 0, 0, userdata);
}

int xmlHashAddEntry3(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, const xmlChar *name3, void *userdata)
{
  int v5 = -1;
  if (table)
  {
    xmlGenericErrorFunc v6 = (xmlChar *)name;
    if (name)
    {
      if (*((_DWORD *)table + 3) != 0x7FFFFFFF)
      {
        char v11 = (xmlDict *)*((void *)table + 2);
        if (!v11
          || (xmlDictOwns(v11, name) || (xmlGenericErrorFunc v6 = (xmlChar *)xmlDictLookup(*((xmlDictPtr *)table + 2), v6, -1)) != 0)
          && (!name2
           || xmlDictOwns(*((xmlDictPtr *)table + 2), name2)
           || (name2 = xmlDictLookup(*((xmlDictPtr *)table + 2), name2, -1)) != 0)
          && (!name3
           || xmlDictOwns(*((xmlDictPtr *)table + 2), name3)
           || (name3 = xmlDictLookup(*((xmlDictPtr *)table + 2), name3, -1)) != 0))
        {
          int v12 = (void *)(*(void *)table + 48 * xmlHashComputeKey((uint64_t)table, v6, name2, name3));
          int v13 = *((_DWORD *)v12 + 10);
          if (v13)
          {
            uint64_t v14 = *(void **)v12;
            unint64_t v15 = 0;
            if (*((void *)table + 2))
            {
              if (v14)
              {
                do
                {
                  uint64_t v16 = (xmlChar **)v12;
                  int v12 = v14;
                  if (v16[1] == v6 && v16[2] == name2 && v16[3] == name3) {
                    return -1;
                  }
                  ++v15;
                  uint64_t v14 = (void *)*v14;
                }
                while (*(void *)v12);
              }
              if (*((xmlChar **)v12 + 1) == v6
                && *((const xmlChar **)v12 + 2) == name2
                && *((const xmlChar **)v12 + 3) == name3)
              {
                return -1;
              }
            }
            else
            {
              if (v14)
              {
                while (!xmlStrEqual(*((const xmlChar **)v12 + 1), v6)
                     || !xmlStrEqual(*((const xmlChar **)v12 + 2), name2)
                     || !xmlStrEqual(*((const xmlChar **)v12 + 3), name3))
                {
                  ++v15;
                  int v12 = *(void **)v12;
                  if (!*(void *)v12) {
                    goto LABEL_30;
                  }
                }
                return -1;
              }
LABEL_30:
              if (xmlStrEqual(*((const xmlChar **)v12 + 1), v6)
                && xmlStrEqual(*((const xmlChar **)v12 + 2), name2)
                && xmlStrEqual(*((const xmlChar **)v12 + 3), name3))
              {
                return -1;
              }
            }
            int v17 = v12;
            int v12 = xmlMalloc(0x30uLL);
            if (!v12) {
              return -1;
            }
          }
          else
          {
            int v17 = 0;
            unint64_t v15 = 0;
          }
          if (*((void *)table + 2))
          {
            *((void *)v12 + 1) = v6;
            *((void *)v12 + 2) = name2;
          }
          else
          {
            *((void *)v12 + 1) = xmlStrdup(v6);
            *((void *)v12 + 2) = xmlStrdup(name2);
            name3 = xmlStrdup(name3);
          }
          *((void *)v12 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = name3;
          *((void *)v12 + 4) = userdata;
          *(void *)int v12 = 0;
          *((_DWORD *)v12 + 10) = 1;
          if (v13) {
            *int v17 = v12;
          }
          ++*((_DWORD *)table + 3);
          if (v15 >= 9)
          {
            uint64_t v18 = *((unsigned int *)table + 2);
            if ((8 * v18 - 16385) >= 0xFFFFC007)
            {
              xmlFreeFunc v19 = *(char **)table;
              if (*(void *)table)
              {
                unsigned int v20 = 8 * v18;
                int v21 = xmlMalloc(48 * (8 * v18));
                *(void *)table = v21;
                if (!v21)
                {
                  int v5 = 0;
                  *(void *)table = v19;
                  return v5;
                }
                bzero(v21, 48 * v20);
                *((_DWORD *)table + 2) = v20;
                if ((int)v18 >= 1)
                {
                  unsigned int v22 = v19 + 24;
                  uint64_t v23 = v18;
                  do
                  {
                    if (*((_DWORD *)v22 + 4))
                    {
                      unint64_t v24 = xmlHashComputeKey((uint64_t)table, *((unsigned char **)v22 - 2), *((unsigned char **)v22 - 1), *(unsigned char **)v22);
                      int v25 = (_OWORD *)(*(void *)table + 48 * v24);
                      long long v26 = *(_OWORD *)(v22 - 24);
                      long long v27 = *(_OWORD *)(v22 + 8);
                      v25[1] = *(_OWORD *)(v22 - 8);
                      v25[2] = v27;
                      *int v25 = v26;
                      *(void *)(*(void *)table + 48 * v24) = 0;
                    }
                    v22 += 48;
                    --v23;
                  }
                  while (v23);
                  do
                  {
                    int v28 = *(unsigned char ***)&v19[48 * v23];
                    if (v28)
                    {
                      do
                      {
                        unsigned int v29 = *v28;
                        unint64_t v30 = xmlHashComputeKey((uint64_t)table, v28[1], v28[2], v28[3]);
                        uint64_t v31 = *(void *)table + 48 * v30;
                        if (*(_DWORD *)(v31 + 40))
                        {
                          *int v28 = *(unsigned char **)v31;
                          *(void *)uint64_t v31 = v28;
                        }
                        else
                        {
                          long long v32 = *(_OWORD *)v28;
                          long long v33 = *((_OWORD *)v28 + 2);
                          *(_OWORD *)(v31 + 16) = *((_OWORD *)v28 + 1);
                          *(_OWORD *)(v31 + 32) = v33;
                          *(_OWORD *)uint64_t v31 = v32;
                          *(void *)(*(void *)table + 48 * v30) = 0;
                          xmlFree(v28);
                        }
                        int v28 = (unsigned char **)v29;
                      }
                      while (v29);
                    }
                    ++v23;
                  }
                  while (v23 != v18);
                }
                xmlFree(v19);
              }
            }
          }
          return 0;
        }
      }
    }
  }
  return v5;
}

int xmlHashAddEntry2(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, void *userdata)
{
  return xmlHashAddEntry3(table, name, name2, 0, userdata);
}

int xmlHashUpdateEntry(xmlHashTablePtr table, const xmlChar *name, void *userdata, xmlHashDeallocator f)
{
  return xmlHashUpdateEntry3(table, name, 0, 0, userdata, f);
}

int xmlHashUpdateEntry3(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, const xmlChar *name3, void *userdata, xmlHashDeallocator f)
{
  int v6 = -1;
  if (!table) {
    return v6;
  }
  BOOL v7 = (xmlChar *)name;
  if (!name || *((_DWORD *)table + 3) == 0x7FFFFFFF) {
    return v6;
  }
  int v13 = (xmlDict *)*((void *)table + 2);
  if (v13)
  {
    if (!xmlDictOwns(v13, name))
    {
      BOOL v7 = (xmlChar *)xmlDictLookup(*((xmlDictPtr *)table + 2), v7, -1);
      if (!v7) {
        return v6;
      }
    }
    if (name2)
    {
      if (!xmlDictOwns(*((xmlDictPtr *)table + 2), name2))
      {
        name2 = xmlDictLookup(*((xmlDictPtr *)table + 2), name2, -1);
        if (!name2) {
          return v6;
        }
      }
    }
    if (name3)
    {
      if (!xmlDictOwns(*((xmlDictPtr *)table + 2), name3))
      {
        name3 = xmlDictLookup(*((xmlDictPtr *)table + 2), name3, -1);
        if (!name3) {
          return v6;
        }
      }
    }
  }
  uint64_t v14 = (void *)(*(void *)table + 48 * xmlHashComputeKey((uint64_t)table, v7, name2, name3));
  int v6 = *((_DWORD *)v14 + 10);
  if (!v6)
  {
    xmlFreeFunc v19 = 0;
LABEL_39:
    if (*((void *)table + 2))
    {
      *((void *)v14 + 1) = v7;
      *((void *)v14 + 2) = name2;
    }
    else
    {
      *((void *)v14 + 1) = xmlStrdup(v7);
      *((void *)v14 + 2) = xmlStrdup(name2);
      name3 = xmlStrdup(name3);
    }
    *((void *)v14 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = name3;
    *((void *)v14 + 4) = userdata;
    *(void *)uint64_t v14 = 0;
    *((_DWORD *)v14 + 10) = 1;
    ++*((_DWORD *)table + 3);
    if (v6)
    {
      int v6 = 0;
      void *v19 = v14;
    }
    return v6;
  }
  unint64_t v15 = *(void **)v14;
  if (!*((void *)table + 2))
  {
    if (v15)
    {
      while (!xmlStrEqual(*((const xmlChar **)v14 + 1), v7)
           || !xmlStrEqual(*((const xmlChar **)v14 + 2), name2)
           || !xmlStrEqual(*((const xmlChar **)v14 + 3), name3))
      {
        uint64_t v14 = *(void **)v14;
        if (!*(void *)v14) {
          goto LABEL_31;
        }
      }
    }
    else
    {
LABEL_31:
      if (!xmlStrEqual(*((const xmlChar **)v14 + 1), v7)
        || !xmlStrEqual(*((const xmlChar **)v14 + 2), name2)
        || !xmlStrEqual(*((const xmlChar **)v14 + 3), name3))
      {
LABEL_38:
        xmlFreeFunc v19 = v14;
        uint64_t v14 = xmlMalloc(0x30uLL);
        if (!v14) {
          return -1;
        }
        goto LABEL_39;
      }
    }
    if (f)
    {
      uint64_t v17 = *((void *)v14 + 4);
      uint64_t v18 = (xmlChar *)*((void *)v14 + 1);
      goto LABEL_36;
    }
LABEL_37:
    int v6 = 0;
    *((void *)v14 + 4) = userdata;
    return v6;
  }
  if (!v15)
  {
LABEL_20:
    if (*((xmlChar **)v14 + 1) == v7 && *((const xmlChar **)v14 + 2) == name2 && *((const xmlChar **)v14 + 3) == name3)
    {
      if (f)
      {
        uint64_t v17 = *((void *)v14 + 4);
        uint64_t v18 = v7;
LABEL_36:
        ((void (*)(uint64_t, xmlChar *))f)(v17, v18);
        goto LABEL_37;
      }
      goto LABEL_37;
    }
    goto LABEL_38;
  }
  while (1)
  {
    uint64_t v16 = (xmlChar **)v14;
    uint64_t v14 = v15;
    if (v16[1] == v7 && v16[2] == name2 && v16[3] == name3) {
      break;
    }
    unint64_t v15 = (void *)*v15;
    if (!*(void *)v14) {
      goto LABEL_20;
    }
  }
  if (f) {
    ((void (*)(xmlChar *, xmlChar *))f)(v16[4], v7);
  }
  int v6 = 0;
  v16[4] = (xmlChar *)userdata;
  return v6;
}

int xmlHashUpdateEntry2(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, void *userdata, xmlHashDeallocator f)
{
  return xmlHashUpdateEntry3(table, name, name2, 0, userdata, f);
}

void *__cdecl xmlHashLookup(xmlHashTablePtr table, const xmlChar *name)
{
  return xmlHashLookup3(table, name, 0, 0);
}

void *__cdecl xmlHashLookup3(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, const xmlChar *name3)
{
  xmlEntityPtr result = 0;
  if (table && name)
  {
    unint64_t v9 = xmlHashComputeKey((uint64_t)table, name, name2, name3);
    uint64_t v10 = *(void *)table + 48 * v9;
    if (*(_DWORD *)(v10 + 40))
    {
      if (*((void *)table + 2))
      {
        uint64_t v11 = *(void *)table + 48 * v9;
        while (*(const xmlChar **)(v11 + 8) != name
             || *(const xmlChar **)(v11 + 16) != name2
             || *(const xmlChar **)(v11 + 24) != name3)
        {
          uint64_t v11 = *(void *)v11;
          if (!v11)
          {
            if (*(void *)table) {
              goto LABEL_11;
            }
            return 0;
          }
        }
      }
      else
      {
LABEL_11:
        while (!xmlStrEqual(*(const xmlChar **)(v10 + 8), name)
             || !xmlStrEqual(*(const xmlChar **)(v10 + 16), name2)
             || !xmlStrEqual(*(const xmlChar **)(v10 + 24), name3))
        {
          uint64_t v10 = *(void *)v10;
          if (!v10) {
            return 0;
          }
        }
        uint64_t v11 = v10;
      }
      return *(void **)(v11 + 32);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *__cdecl xmlHashLookup2(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2)
{
  return xmlHashLookup3(table, name, name2, 0);
}

void *__cdecl xmlHashQLookup(xmlHashTablePtr table, const xmlChar *name, const xmlChar *prefix)
{
  return xmlHashQLookup3(table, name, prefix, 0, 0, 0, 0);
}

void *__cdecl xmlHashQLookup3(xmlHashTablePtr table, const xmlChar *name, const xmlChar *prefix, const xmlChar *name2, const xmlChar *prefix2, const xmlChar *name3, const xmlChar *prefix3)
{
  BOOL v7 = 0;
  if (table && prefix)
  {
    if (name) {
      uint64_t v14 = name;
    }
    else {
      uint64_t v14 = prefix;
    }
    unint64_t v15 = *((int *)table + 6) + 30 * *v14;
    if (name)
    {
      unsigned int v16 = *name;
      if (*name)
      {
        uint64_t v17 = name + 1;
        do
        {
          v15 ^= (v15 >> 3) + v16 + 32 * v15;
          unsigned int v18 = *v17++;
          unsigned int v16 = v18;
        }
        while (v18);
      }
      v15 ^= (v15 >> 3) + 32 * v15 + 58;
    }
    unsigned int v19 = *prefix;
    if (*prefix)
    {
      unsigned int v20 = prefix + 1;
      do
      {
        v15 ^= (v15 >> 3) + v19 + 32 * v15;
        unsigned int v21 = *v20++;
        unsigned int v19 = v21;
      }
      while (v21);
    }
    unint64_t v22 = (32 * v15 + (v15 >> 3)) ^ v15;
    if (name2)
    {
      unsigned int v23 = *name2;
      if (*name2)
      {
        unint64_t v24 = name2 + 1;
        do
        {
          v22 ^= (v22 >> 3) + v23 + 32 * v22;
          unsigned int v25 = *v24++;
          unsigned int v23 = v25;
        }
        while (v25);
      }
      v22 ^= (v22 >> 3) + 32 * v22 + 58;
    }
    if (prefix2)
    {
      unsigned int v26 = *prefix2;
      if (*prefix2)
      {
        long long v27 = prefix2 + 1;
        do
        {
          v22 ^= (v22 >> 3) + v26 + 32 * v22;
          unsigned int v28 = *v27++;
          unsigned int v26 = v28;
        }
        while (v28);
      }
    }
    unint64_t v29 = (32 * v22 + (v22 >> 3)) ^ v22;
    if (name3)
    {
      unsigned int v30 = *name3;
      if (*name3)
      {
        uint64_t v31 = name3 + 1;
        do
        {
          v29 ^= (v29 >> 3) + v30 + 32 * v29;
          unsigned int v32 = *v31++;
          unsigned int v30 = v32;
        }
        while (v32);
      }
      v29 ^= (v29 >> 3) + 32 * v29 + 58;
    }
    if (prefix3)
    {
      unsigned int v33 = *prefix3;
      if (*prefix3)
      {
        uint64_t v34 = prefix3 + 1;
        do
        {
          v29 ^= (v29 >> 3) + v33 + 32 * v29;
          unsigned int v35 = *v34++;
          unsigned int v33 = v35;
        }
        while (v35);
      }
    }
    unint64_t v36 = v29 % *((int *)table + 2);
    uint64_t v37 = *(void *)table;
    if (*(_DWORD *)(*(void *)table + 48 * v36 + 40)) {
      BOOL v38 = v37 == 0;
    }
    else {
      BOOL v38 = 1;
    }
    if (v38)
    {
      return 0;
    }
    else
    {
      int v39 = (uint64_t **)(v37 + 48 * v36);
      while (!xmlStrQEqual(name, prefix, (const xmlChar *)v39[1])
           || !xmlStrQEqual(name2, prefix2, (const xmlChar *)v39[2])
           || !xmlStrQEqual(name3, prefix3, (const xmlChar *)v39[3]))
      {
        int v39 = (uint64_t **)*v39;
        if (!v39) {
          return 0;
        }
      }
      return v39[4];
    }
  }
  return v7;
}

void *__cdecl xmlHashQLookup2(xmlHashTablePtr table, const xmlChar *name, const xmlChar *prefix, const xmlChar *name2, const xmlChar *prefix2)
{
  return xmlHashQLookup3(table, name, prefix, name2, prefix2, 0, 0);
}

unint64_t xmlHashComputeKey(uint64_t a1, unsigned char *a2, unsigned char *a3, unsigned char *a4)
{
  unint64_t v4 = *(int *)(a1 + 24);
  if (a2)
  {
    unsigned int v5 = *a2;
    v4 += 30 * *a2;
    if (*a2)
    {
      int v6 = a2 + 1;
      do
      {
        v4 ^= (v4 >> 3) + v5 + 32 * v4;
        unsigned int v7 = *v6++;
        unsigned int v5 = v7;
      }
      while (v7);
    }
  }
  unint64_t v8 = (32 * v4 + (v4 >> 3)) ^ v4;
  if (a3)
  {
    unsigned int v9 = *a3;
    if (*a3)
    {
      uint64_t v10 = a3 + 1;
      do
      {
        v8 ^= 32 * v8 + (v8 >> 3) + v9;
        unsigned int v11 = *v10++;
        unsigned int v9 = v11;
      }
      while (v11);
    }
  }
  unint64_t v12 = (32 * v8 + (v8 >> 3)) ^ v8;
  if (a4)
  {
    unsigned int v13 = *a4;
    if (*a4)
    {
      uint64_t v14 = a4 + 1;
      do
      {
        v12 ^= 32 * v12 + (v12 >> 3) + v13;
        unsigned int v15 = *v14++;
        unsigned int v13 = v15;
      }
      while (v15);
    }
  }
  return v12 % *(int *)(a1 + 8);
}

void xmlHashScan(xmlHashTablePtr table, xmlHashScanner f, void *data)
{
  v3[0] = f;
  v3[1] = data;
  xmlHashScanFull(table, (xmlHashScannerFull)stubHashScannerFull, v3);
}

void xmlHashScanFull(xmlHashTablePtr table, xmlHashScannerFull f, void *data)
{
  if (table)
  {
    if (f)
    {
      if (*(void *)table)
      {
        int v5 = *((_DWORD *)table + 2);
        if (v5 >= 1)
        {
          for (uint64_t i = 0; i < v5; ++i)
          {
            uint64_t v8 = *(void *)table;
            if (*(_DWORD *)(*(void *)table + 48 * i + 40)) {
              BOOL v9 = v8 == 0;
            }
            else {
              BOOL v9 = 1;
            }
            if (!v9)
            {
              uint64_t v10 = (void *)(v8 + 48 * i);
              int v11 = *((_DWORD *)table + 3);
              do
              {
                int v12 = v11;
                unsigned int v13 = (void *)*v10;
                uint64_t v14 = v10[4];
                if (v14)
                {
                  ((void (*)(uint64_t, void *, void, void, void))f)(v14, data, v10[1], v10[2], v10[3]);
                  int v11 = *((_DWORD *)table + 3);
                }
                if (v12 != v11 && v10 == (void *)(*(void *)table + 48 * i))
                {
                  if ((void *)*v10 == v13)
                  {
                    unsigned int v13 = v10;
                    if (!*(_DWORD *)(*(void *)table + 48 * i + 40)) {
                      break;
                    }
                  }
                  else
                  {
                    unsigned int v13 = v10;
                  }
                }
                uint64_t v10 = v13;
              }
              while (v13);
              int v5 = *((_DWORD *)table + 2);
            }
          }
        }
      }
    }
  }
}

uint64_t stubHashScannerFull(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))a2)(a1, *(void *)(a2 + 8));
}

void xmlHashScan3(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, const xmlChar *name3, xmlHashScanner f, void *data)
{
  v6[0] = f;
  v6[1] = data;
  xmlHashScanFull3(table, name, name2, name3, (xmlHashScannerFull)stubHashScannerFull, v6);
}

void xmlHashScanFull3(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, const xmlChar *name3, xmlHashScannerFull f, void *data)
{
  if (table)
  {
    if (f)
    {
      if (*(void *)table)
      {
        int v8 = *((_DWORD *)table + 2);
        if (v8 >= 1)
        {
          for (uint64_t i = 0; i < v8; ++i)
          {
            uint64_t v14 = *(void *)table;
            if (*(_DWORD *)(*(void *)table + 48 * i + 40)) {
              BOOL v15 = v14 == 0;
            }
            else {
              BOOL v15 = 1;
            }
            if (!v15)
            {
              unsigned int v16 = (void *)(v14 + 48 * i);
              do
              {
                uint64_t v17 = v16;
                unsigned int v16 = (void *)*v16;
                if ((!name || xmlStrEqual(name, (const xmlChar *)v17[1]))
                  && (!name2 || xmlStrEqual(name2, (const xmlChar *)v17[2]))
                  && (!name3 || xmlStrEqual(name3, (const xmlChar *)v17[3])))
                {
                  uint64_t v18 = v17[4];
                  if (v18) {
                    ((void (*)(uint64_t, void *, void, void, void))f)(v18, data, v17[1], v17[2], v17[3]);
                  }
                }
              }
              while (v16);
              int v8 = *((_DWORD *)table + 2);
            }
          }
        }
      }
    }
  }
}

xmlHashTablePtr xmlHashCopy(xmlHashTablePtr table, xmlHashCopier f)
{
  xmlHashTablePtr v2 = 0;
  if (table)
  {
    if (f)
    {
      xmlHashTablePtr v2 = xmlHashCreate(*((_DWORD *)table + 2));
      if (v2)
      {
        if (*(void *)table)
        {
          int v5 = *((_DWORD *)table + 2);
          if (v5 >= 1)
          {
            for (uint64_t i = 0; i < v5; ++i)
            {
              uint64_t v7 = *(void *)table;
              if (*(_DWORD *)(*(void *)table + 48 * i + 40)) {
                BOOL v8 = v7 == 0;
              }
              else {
                BOOL v8 = 1;
              }
              if (!v8)
              {
                BOOL v9 = (void *)(v7 + 48 * i);
                do
                {
                  int v11 = (void *)*v9;
                  uint64_t v10 = (const xmlChar *)v9[1];
                  int v12 = (const xmlChar *)v9[2];
                  unsigned int v13 = (const xmlChar *)v9[3];
                  uint64_t v14 = (void *)((uint64_t (*)(void, const xmlChar *))f)(v9[4], v10);
                  xmlHashAddEntry3(v2, v10, v12, v13, v14);
                  BOOL v9 = v11;
                }
                while (v11);
                int v5 = *((_DWORD *)table + 2);
              }
            }
          }
        }
        *((_DWORD *)v2 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = *((_DWORD *)table + 3);
      }
    }
  }
  return v2;
}

int xmlHashSize(xmlHashTablePtr table)
{
  if (table) {
    return *((_DWORD *)table + 3);
  }
  else {
    return -1;
  }
}

int xmlHashRemoveEntry(xmlHashTablePtr table, const xmlChar *name, xmlHashDeallocator f)
{
  return xmlHashRemoveEntry3(table, name, 0, 0, f);
}

int xmlHashRemoveEntry3(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, const xmlChar *name3, xmlHashDeallocator f)
{
  int result = -1;
  if (table && name)
  {
    unint64_t v11 = xmlHashComputeKey((uint64_t)table, name, name2, name3);
    uint64_t v12 = *(void *)table;
    if (*(_DWORD *)(*(void *)table + 48 * v11 + 40)) {
      BOOL v13 = v12 == 0;
    }
    else {
      BOOL v13 = 1;
    }
    if (v13)
    {
      return -1;
    }
    else
    {
      unint64_t v14 = v11;
      BOOL v15 = 0;
      unsigned int v16 = (long long *)(v12 + 48 * v11);
      while (!xmlStrEqual(*((const xmlChar **)v16 + 1), name)
           || !xmlStrEqual(*((const xmlChar **)v16 + 2), name2)
           || !xmlStrEqual(*((const xmlChar **)v16 + 3), name3))
      {
        BOOL v15 = (long long **)v16;
        unsigned int v16 = *(long long **)v16;
        if (!v16) {
          return -1;
        }
      }
      if (f)
      {
        uint64_t v17 = *((void *)v16 + 4);
        if (v17) {
          ((void (*)(uint64_t, void))f)(v17, *((void *)v16 + 1));
        }
      }
      *((void *)v16 + 4) = 0;
      if (!*((void *)table + 2))
      {
        uint64_t v18 = (void *)*((void *)v16 + 1);
        if (v18) {
          xmlFree(v18);
        }
        unsigned int v19 = (void *)*((void *)v16 + 2);
        if (v19) {
          xmlFree(v19);
        }
        unsigned int v20 = (void *)*((void *)v16 + 3);
        if (v20) {
          xmlFree(v20);
        }
      }
      unsigned int v21 = *(long long **)v16;
      if (v15)
      {
        *BOOL v15 = v21;
        ((void (*)(long long *))xmlFree)(v16);
      }
      else if (v21)
      {
        unint64_t v22 = (_OWORD *)(*(void *)table + 48 * v14);
        long long v23 = *v21;
        long long v24 = v21[2];
        v22[1] = v21[1];
        v22[2] = v24;
        _OWORD *v22 = v23;
        ((void (*)(long long *))xmlFree)(v21);
      }
      else
      {
        *((_DWORD *)v16 + 10) = 0;
      }
      int result = 0;
      --*((_DWORD *)table + 3);
    }
  }
  return result;
}

int xmlHashRemoveEntry2(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, xmlHashDeallocator f)
{
  return xmlHashRemoveEntry3(table, name, name2, 0, f);
}

const htmlElemDesc *__cdecl htmlTagLookup(const htmlElemDesc *tag)
{
  if (tag) {
    return (const htmlElemDesc *)bsearch(tag, &html40ElementTable, 0x5CuLL, 0x40uLL, (int (__cdecl *)(const void *, const void *))htmlCompareTags);
  }
  return tag;
}

int htmlAutoCloseTag(htmlDocPtr doc, const xmlChar *name, htmlNodePtr elem)
{
  if (!elem) {
    return 1;
  }
  if (xmlStrEqual(name, elem->name)) {
    return 0;
  }
  uint64_t v7 = elem->name;
  v9[0] = name;
  v9[1] = v7;
  if (!bsearch(v9, htmlStartClose, 0xFBuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))htmlCompareStartClose))
  {
    children = elem->children;
    if (!children) {
      return 0;
    }
    while (1)
    {
      int result = htmlAutoCloseTag(doc, name, children);
      if (result) {
        break;
      }
      children = children->next;
      if (!children) {
        return result;
      }
    }
  }
  return 1;
}

int htmlIsAutoClosed(htmlDocPtr doc, htmlNodePtr elem)
{
  if (!elem) {
    return 1;
  }
  children = elem->children;
  if (!children) {
    return 0;
  }
  while (!htmlAutoCloseTag(doc, elem->name, children))
  {
    children = children->next;
    if (!children) {
      return 0;
    }
  }
  return 1;
}

int htmlIsScriptAttribute(const xmlChar *name)
{
  if (name)
  {
    uint64_t v1 = name;
    if (*name == 111 && name[1] == 110)
    {
      uint64_t v2 = 0;
      while (!xmlStrEqual(v1, (const xmlChar *)htmlScriptAttributes[v2]))
      {
        if (++v2 == 18) {
          goto LABEL_7;
        }
      }
      LODWORD(name) = 1;
    }
    else
    {
LABEL_7:
      LODWORD(name) = 0;
    }
  }
  return (int)name;
}

const htmlEntityDesc *__cdecl htmlEntityLookup(const xmlChar *name)
{
  uint64_t v2 = (const htmlEntityDesc *)html40EntitiesTable;
  uint64_t v3 = 253;
  while (!xmlStrEqual(name, (const xmlChar *)v2->name))
  {
    ++v2;
    if (!--v3) {
      return 0;
    }
  }
  return v2;
}

const htmlEntityDesc *__cdecl htmlEntityValueLookup(unsigned int value)
{
  int result = (const htmlEntityDesc *)&html40EntitiesTable;
  uint64_t v3 = 253;
  while (result->value < value)
  {
    ++result;
    if (!--v3) {
      return 0;
    }
  }
  if (result->value <= value) {
    return result;
  }
  return 0;
}

int UTF8ToHtml(unsigned __int8 *out, int *outlen, const unsigned __int8 *in, int *inlen)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  int result = -1;
  if (!out || !outlen || !inlen) {
    return result;
  }
  int v7 = (int)in;
  if (!in)
  {
    int v29 = 0;
    int result = 0;
    *outunsigned int len = 0;
    goto LABEL_42;
  }
  unsigned int v30 = inlen;
  uint64_t v8 = *inlen;
  LODWORD(v9) = out;
  LODWORD(v10) = in;
  if ((int)v8 < 1)
  {
LABEL_40:
    int result = 0;
    *outunsigned int len = v9 - out;
    int v29 = v10 - v7;
    goto LABEL_41;
  }
  unint64_t v11 = &in[v8];
  uint64_t v12 = &out[*outlen];
  BOOL v13 = in;
  BOOL v9 = out;
  uint64_t v10 = in;
  while (1)
  {
    int v14 = *(char *)v10++;
    unsigned int v15 = v14;
    if ((v14 & 0x80000000) == 0)
    {
      unsigned int v16 = 0;
      unsigned int v17 = v15;
      goto LABEL_16;
    }
    if (v15 <= 0xBF) {
      break;
    }
    if (v15 <= 0xDF)
    {
      unsigned int v17 = v15 & 0x1F;
      unsigned int v16 = 1;
      goto LABEL_16;
    }
    if (v15 <= 0xEF)
    {
      unsigned int v17 = v15 & 0xF;
      unsigned int v16 = 2;
      goto LABEL_16;
    }
    if (v15 > 0xF7) {
      break;
    }
    unsigned int v17 = v15 & 7;
    unsigned int v16 = 3;
LABEL_16:
    if (v11 - v10 < v16) {
      goto LABEL_39;
    }
    if ((v15 & 0x80) != 0 && v10 < v11)
    {
      unsigned int v18 = v16 - 1;
      unsigned int v19 = v13 + 2;
      do
      {
        uint64_t v10 = v19;
        char v20 = *(v19 - 1);
        if ((v20 & 0xC0) != 0x80) {
          break;
        }
        unsigned int v17 = v20 & 0x3F | (v17 << 6);
        if (v18-- == 0) {
          break;
        }
        unsigned int v19 = v10 + 1;
      }
      while (v10 < v11);
    }
    if (v17 > 0x7F)
    {
      *(void *)__str = 0;
      uint64_t v32 = 0;
      unint64_t v22 = 0x3FFFFFFFFFFFFA12uLL;
      while (1)
      {
        unsigned int v23 = html40EntitiesTable[v22 + 1518];
        if (v23 >= v17) {
          break;
        }
        v22 += 6;
        if (!(v22 * 4)) {
          goto LABEL_33;
        }
      }
      if (v23 <= v17)
      {
        long long v24 = *(char **)&html40EntitiesTable[v22 + 1520];
        goto LABEL_34;
      }
LABEL_33:
      long long v24 = __str;
      snprintf(__str, 0x10uLL, "#%u", v17);
LABEL_34:
      int v25 = strlen(v24);
      if (&v9[v25 + 2] >= v12)
      {
LABEL_39:
        LODWORD(v10) = v13;
        goto LABEL_40;
      }
      uint64_t v26 = v25;
      unsigned __int8 *v9 = 38;
      long long v27 = (char *)(v9 + 1);
      memcpy(v27, v24, v25);
      unsigned int v28 = &v27[v26];
      *unsigned int v28 = 59;
      BOOL v9 = (unsigned __int8 *)(v28 + 1);
    }
    else
    {
      if (v9 + 1 >= v12) {
        goto LABEL_39;
      }
      *v9++ = v17;
    }
    BOOL v13 = v10;
    if (v10 >= v11) {
      goto LABEL_40;
    }
  }
  *outunsigned int len = v9 - out;
  int v29 = v13 - v7;
  int result = -2;
LABEL_41:
  inunsigned int len = v30;
LABEL_42:
  *inunsigned int len = v29;
  return result;
}

int htmlEncodeEntities(unsigned __int8 *out, int *outlen, const unsigned __int8 *in, int *inlen, int quoteChar)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  int result = -1;
  if (in && out && outlen && inlen)
  {
    int v8 = (int)in;
    uint64_t v9 = *inlen;
    if ((int)v9 < 1)
    {
      int result = 0;
      LODWORD(v1xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = out;
      LODWORD(v12) = in;
LABEL_46:
      *outunsigned int len = v13 - out;
      *inunsigned int len = v12 - v8;
      return result;
    }
    int v29 = outlen;
    unsigned int v30 = &out[*outlen];
    unint64_t v11 = &in[v9];
    uint64_t v12 = in;
    BOOL v13 = out;
    int v14 = in;
    while (1)
    {
      unsigned __int8 v15 = *v14++;
      unsigned int v16 = v15;
      if ((v15 & 0x80) != 0) {
        break;
      }
      if (v11 - v14 < 0) {
        goto LABEL_44;
      }
LABEL_21:
      BOOL v21 = v16 > 0x7F || v16 == quoteChar;
      if (!v21 && (v16 <= 0x3E ? (BOOL v22 = ((1 << v16) & 0x5000004000000000) == 0) : (BOOL v22 = 1), v22))
      {
        if (v13 >= v30) {
          goto LABEL_44;
        }
        *BOOL v13 = v16;
      }
      else
      {
        *(void *)__str = 0;
        uint64_t v32 = 0;
        unint64_t v23 = 0x3FFFFFFFFFFFFA12uLL;
        while (1)
        {
          unsigned int v24 = html40EntitiesTable[v23 + 1518];
          if (v24 >= v16) {
            break;
          }
          v23 += 6;
          if (!(v23 * 4)) {
            goto LABEL_35;
          }
        }
        if (v24 <= v16)
        {
          int v25 = *(char **)&html40EntitiesTable[v23 + 1520];
          goto LABEL_36;
        }
LABEL_35:
        int v25 = __str;
        snprintf(__str, 0x10uLL, "#%u", v16);
LABEL_36:
        size_t v26 = strlen(v25);
        if (v30 - v13 < (uint64_t)((v26 << 32) + 0x200000000) >> 32) {
          goto LABEL_44;
        }
        uint64_t v27 = v26 << 32;
        *BOOL v13 = 38;
        unsigned int v28 = (char *)(v13 + 1);
        memcpy(v28, v25, (int)v26);
        BOOL v13 = (unsigned __int8 *)&v28[v27 >> 32];
        *BOOL v13 = 59;
      }
      ++v13;
      uint64_t v12 = v14;
      if (v14 >= v11)
      {
        int result = 0;
        LODWORD(v12) = v14;
        goto LABEL_45;
      }
    }
    if (v16 >= 0xC0)
    {
      if (v16 < 0xE0)
      {
        unsigned int v17 = 1;
        int v18 = 31;
LABEL_17:
        if (v11 - v14 >= v17)
        {
          uint64_t v19 = 0;
          v16 &= v18;
          int v14 = &v12[v17 + 1];
          while (1)
          {
            unsigned __int8 v20 = v12[v19 + 1];
            if ((v20 & 0xC0) != 0x80) {
              goto LABEL_42;
            }
            unsigned int v16 = v20 & 0x3F | (v16 << 6);
            if (v17 == ++v19) {
              goto LABEL_21;
            }
          }
        }
LABEL_44:
        int result = 0;
LABEL_45:
        outunsigned int len = v29;
        goto LABEL_46;
      }
      if (v16 < 0xF0)
      {
        unsigned int v17 = 2;
        int v18 = 15;
        goto LABEL_17;
      }
      if (v16 <= 0xF7)
      {
        unsigned int v17 = 3;
        int v18 = 7;
        goto LABEL_17;
      }
    }
LABEL_42:
    int result = -2;
    goto LABEL_45;
  }
  return result;
}

htmlDocPtr htmlNewDocNoDtD(const xmlChar *URI, const xmlChar *ExternalID)
{
  unint64_t v4 = (char *)xmlMalloc(0xB0uLL);
  int v5 = (xmlDoc *)v4;
  if (v4)
  {
    *(_OWORD *)unint64_t v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
    *((_OWORD *)v4 + 6) = 0u;
    *((_OWORD *)v4 + 7) = 0u;
    *((_OWORD *)v4 + 9) = 0u;
    *((_OWORD *)v4 + 10) = 0u;
    *((_OWORD *)v4 + 8) = 0u;
    *((_OWORD *)v4 + 2) = 0u;
    *((_OWORD *)v4 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0u;
    *((_DWORD *)v4 + 2) = 13;
    *((_OWORD *)v4 + 4) = 0u;
    *((_OWORD *)v4 + 5) = 0u;
    *((void *)v4 + 8) = v4;
    *(_OWORD *)(v4 + 104) = 0u;
    *((void *)v4 + 12) = 0;
    *((void *)v4 + 9) = 0x100000000;
    *(void *)unint64_t v4 = 0;
    *(_OWORD *)(v4 + 120) = 0u;
    *((_DWORD *)v4 + 36) = 1;
    *((_DWORD *)v4 + 4xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 160;
    if ((unint64_t)URI | (unint64_t)ExternalID) {
      xmlCreateIntSubset((xmlDocPtr)v4, (const xmlChar *)"html", ExternalID, URI);
    }
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      int v6 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlDoc *))*v6)(v5);
    }
  }
  else
  {
    htmlErrMemory(0, (const xmlChar *)"HTML document creation failed\n");
  }
  return v5;
}

_DWORD *htmlErrMemory(_DWORD *result, const xmlChar *a2)
{
  if (!result) {
    goto LABEL_5;
  }
  if (!result[83] || result[68] != -1)
  {
    result[34] = 2;
    result[68] = -1;
    result[83] = 1;
LABEL_5:
    if (a2) {
      return __xmlRaiseError(0, 0, 0, result, 0, 1u, 2, 3, 0, 0, a2, 0, 0, 0, (unsigned __int128)0 >> 96, "Memory allocation failed : %s\n", (char)a2);
    }
    else {
      return __xmlRaiseError(0, 0, 0, result, 0, 1u, 2, 3, 0, 0, 0, 0, 0, 0, 0, "Memory allocation failed\n", v2);
    }
  }
  return result;
}

htmlDocPtr htmlNewDoc(const xmlChar *URI, const xmlChar *ExternalID)
{
  if (!((unint64_t)URI | (unint64_t)ExternalID))
  {
    xmlURIPtr URI = (const xmlChar *)"http://www.w3.org/TR/REC-html40/loose.dtd";
    ExternalID = (const xmlChar *)"-//W3C//DTD HTML 4.0 Transitional//EN";
  }
  return htmlNewDocNoDtD(URI, ExternalID);
}

int htmlParseCharRef(htmlParserCtxtPtr ctxt)
{
  htmlParserCtxtPtr v1 = ctxt;
  if (!ctxt || (xmlParserInputPtr input = ctxt->input) == 0)
  {
    int v8 = "htmlParseCharRef: context error\n";
    int v9 = 1;
    goto LABEL_19;
  }
  cur = input->cur;
  if (*cur != 38 || cur[1] != 35)
  {
    htmlParseErr(ctxt, 8, "htmlParseCharRef: invalid value\n", 0, 0);
    int v6 = 0;
    goto LABEL_21;
  }
  unint64_t v4 = cur + 2;
  if ((cur[2] | 0x20) != 0x78)
  {
    input->cur = v4;
    input->col += 2;
    int v11 = *v4;
    if (v11 != 59)
    {
      int v6 = 0;
      do
      {
        if ((v11 - 48) > 9)
        {
          BOOL v13 = v1;
          int v14 = 7;
          goto LABEL_45;
        }
        int v12 = v11 + 10 * v6 - 48;
        if (v6 < 1114112) {
          int v6 = v12;
        }
        xmlNextChar(v1);
        int v11 = *v1->input->cur;
      }
      while (v11 != 59);
      goto LABEL_26;
    }
    goto LABEL_25;
  }
  input->cur = cur + 3;
  input->col += 3;
  int v5 = cur[3];
  if (v5 == 59)
  {
LABEL_25:
    int v6 = 0;
    goto LABEL_26;
  }
  int v6 = 0;
  while ((v5 - 48) <= 9)
  {
    int v7 = v5 + 16 * v6 - 48;
LABEL_14:
    if (v6 < 1114112) {
      int v6 = v7;
    }
    xmlNextChar(v1);
    int v5 = *v1->input->cur;
    if (v5 == 59) {
      goto LABEL_26;
    }
  }
  if ((v5 - 97) <= 5)
  {
    int v7 = v5 + 16 * v6 - 87;
    goto LABEL_14;
  }
  if ((v5 - 65) <= 5)
  {
    int v7 = v5 + 16 * v6 - 55;
    goto LABEL_14;
  }
  BOOL v13 = v1;
  int v14 = 6;
LABEL_45:
  htmlParseErr(v13, v14, "htmlParseCharRef: missing semicolon\n", 0, 0);
  if (*v1->input->cur == 59) {
LABEL_26:
  }
    xmlNextChar(v1);
  if (v6 > 255)
  {
    if ((v6 - 0x10000) < 0x100000
      || v6 >> 11 < 0x1B
      || (v6 - 57344) >> 1 < 0xFFF)
    {
      return v6;
    }
    if (v6 < 0x110000) {
      goto LABEL_21;
    }
    int v8 = "htmlParseCharRef: value too large\n";
    ctxt = v1;
    int v9 = 9;
LABEL_19:
    htmlParseErr(ctxt, v9, v8, 0, 0);
    return 0;
  }
  if (v6 <= 31 && (v6 > 0xD || ((1 << v6) & 0x2600) == 0))
  {
LABEL_21:
    htmlParseErrInt(v1, "htmlParseCharRef: invalid xmlChar value %d\n", v6);
    return 0;
  }
  return v6;
}

_DWORD *htmlParseErrInt(_DWORD *result, const char *a2, int a3)
{
  uint64_t v3 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = 9;
    int result = __xmlRaiseError(0, 0, 0, result, 0, 5u, 9, 2, 0, 0, 0, 0, 0, a3, 0, a2, a3);
    v3[6] = 0;
  }
  return result;
}

void htmlParseElement(htmlParserCtxtPtr ctxt)
{
  if (ctxt && (xmlParserInputPtr v2 = ctxt->input) != 0)
  {
    if (ctxt->instate == XML_PARSER_EOF) {
      return;
    }
    memset(&v42, 0, sizeof(v42));
    if (ctxt->record_info)
    {
      unint64_t v3 = &v2->cur[v2->consumed] - v2->base;
      unint64_t line = v2->line;
      v42.begin_pos = v3;
      v42.begin_unint64_t line = line;
    }
    if (htmlParseStartTag((uint64_t)ctxt) != -1)
    {
      name = ctxt->name;
      if (name)
      {
        int v6 = bsearch(ctxt->name, &html40ElementTable, 0x5CuLL, 0x40uLL, (int (__cdecl *)(const void *, const void *))htmlCompareTags);
        if (!v6) {
          htmlParseErr(ctxt, 801, "Tag %s invalid\n", name, 0);
        }
        xmlParserInputPtr input = ctxt->input;
        cur = input->cur;
        int v9 = *cur;
        if (v9 != 62)
        {
          if (v9 != 47 || cur[1] != 62)
          {
            htmlParseErr(ctxt, 73, "Couldn't find end of Start Tag %s\n", name, 0);
            if (xmlStrEqual(name, ctxt->name))
            {
              nodePop(ctxt);
              int nameNr = ctxt->nameNr;
              unsigned int v11 = nameNr - 1;
              if (nameNr >= 1)
              {
                ctxt->int nameNr = v11;
                nameTab = ctxt->nameTab;
                if (nameNr == 1) {
                  uint64_t v37 = 0;
                }
                else {
                  uint64_t v37 = nameTab[nameNr - 2];
                }
                ctxt->name = v37;
                nameTab[v11] = 0;
              }
            }
            if (ctxt->record_info)
            {
              xmlParserInputPtr v38 = ctxt->input;
              unint64_t v39 = &v38->cur[v38->consumed] - v38->base;
              unint64_t v40 = v38->line;
              v42.end_pos = v39;
              v42.end_unint64_t line = v40;
              v42.node = ctxt->node;
              xmlParserAddNodeInfo(ctxt, &v42);
            }
            return;
          }
          input->cur = cur + 2;
          input->col += 2;
LABEL_28:
          if (ctxt->sax)
          {
            endElementSAXFunc endElement = ctxt->sax->endElement;
            if (endElement) {
              ((void (*)(void *, const xmlChar *))endElement)(ctxt->userData, name);
            }
          }
          int v14 = ctxt->nameNr;
          unsigned int v15 = v14 - 1;
          if (v14 >= 1)
          {
            ctxt->int nameNr = v15;
            unsigned int v16 = ctxt->nameTab;
            if (v14 == 1) {
              int v41 = 0;
            }
            else {
              int v41 = v16[v14 - 2];
            }
            ctxt->name = v41;
            v16[v15] = 0;
          }
          return;
        }
        xmlNextChar(ctxt);
        if (v6 && v6[11]) {
          goto LABEL_28;
        }
        unsigned int v17 = xmlStrdup(ctxt->name);
        xmlParserInputPtr v18 = ctxt->input;
        uint64_t v19 = v18->cur;
        if (!*v19) {
          goto LABEL_99;
        }
        int v20 = ctxt->nameNr;
LABEL_37:
        BOOL v21 = xmlStrdup(ctxt->name);
        int v22 = ctxt->nameNr;
        while (1)
        {
          while (1)
          {
            if (!ctxt->progressive)
            {
              xmlParserInputPtr v23 = ctxt->input;
              if (v23->end - v23->cur <= 249) {
                xmlParserInputGrow(v23, 250);
              }
            }
            if (ctxt->instate == XML_PARSER_EOF)
            {
LABEL_94:
              if (!v21) {
                goto LABEL_96;
              }
LABEL_95:
              xmlFree(v21);
LABEL_96:
              xmlParserInputPtr v18 = ctxt->input;
              if (v19 == v18->cur || (uint64_t v19 = v18->cur, ctxt->nameNr < v20) || !*v19)
              {
LABEL_99:
                if (v17 && ctxt->record_info)
                {
                  unint64_t v35 = &v19[v18->consumed] - v18->base;
                  unint64_t v36 = v18->line;
                  v42.end_pos = v35;
                  v42.end_unint64_t line = v36;
                  v42.node = ctxt->node;
                  xmlParserAddNodeInfo(ctxt, &v42);
                  xmlParserInputPtr v18 = ctxt->input;
                }
                if (!*v18->cur) {
                  htmlAutoCloseOnEnd((uint64_t)ctxt);
                }
                if (v17) {
                  xmlFree(v17);
                }
                return;
              }
              goto LABEL_37;
            }
            unsigned int v24 = ctxt->input->cur;
            if (*v24 == 60) {
              break;
            }
LABEL_55:
            int v28 = ctxt->nameNr;
            BOOL v29 = v28 < 1 || v22 < v28;
            if (!v29 && !xmlStrEqual(v21, ctxt->name)) {
              goto LABEL_94;
            }
            if (*ctxt->input->cur)
            {
              if (xmlStrEqual(v21, (const xmlChar *)"script") || xmlStrEqual(v21, (const xmlChar *)"style"))
              {
                htmlParseScript((uint64_t)ctxt);
                goto LABEL_86;
              }
              unsigned int v30 = ctxt->input->cur;
              if (*v30 == 60
                && v30[1] == 33
                && __toupper(v30[2]) == 68
                && __toupper(v30[3]) == 79
                && __toupper(v30[4]) == 67
                && __toupper(v30[5]) == 84
                && __toupper(v30[6]) == 89
                && __toupper(v30[7]) == 80
                && __toupper(v30[8]) == 69)
              {
                htmlParseErr(ctxt, 800, "Misplaced DOCTYPE declaration\n", (const xmlChar *)"DOCTYPE", 0);
                htmlParseDocTypeDecl(ctxt);
              }
            }
            uint64_t v31 = ctxt->input->cur;
            int v32 = *v31;
            if (v32 == 38)
            {
              htmlParseReference((uint64_t)ctxt);
            }
            else if (v32 == 60)
            {
              int v33 = v31[1];
              if (v33 == 63)
              {
                htmlParsePI((uint64_t)ctxt);
              }
              else if (v33 == 33 && v31[2] == 45 && v31[3] == 45)
              {
                htmlParseComment((uint64_t)ctxt);
              }
              else
              {
                htmlParseElement(ctxt);
              }
            }
            else
            {
              if (!*v31)
              {
                htmlAutoCloseOnEnd((uint64_t)ctxt);
                goto LABEL_94;
              }
              htmlParseCharData((uint64_t)ctxt);
            }
LABEL_86:
            if (!ctxt->progressive)
            {
              xmlParserInputPtr v34 = ctxt->input;
              if (v34->end - v34->cur <= 249) {
                xmlParserInputGrow(v34, 250);
              }
            }
          }
          int v25 = v24[1];
          if (v25 == 47)
          {
            if (htmlParseEndTag(ctxt))
            {
              if (v21) {
                goto LABEL_95;
              }
              if (!ctxt->nameNr) {
                goto LABEL_96;
              }
            }
          }
          else
          {
            if ((v25 & 0xFFFFFFDF) - 65 >= 0x1A && v25 != 95 && v25 != 58) {
              goto LABEL_55;
            }
            size_t v26 = htmlParseHTMLName_nonInvasive((uint64_t)ctxt);
            if (!v26)
            {
              htmlParseErr(ctxt, 68, "htmlParseStartTag: invalid element name\n", 0, 0);
              while (*ctxt->input->cur && *ctxt->input->cur != 62)
                xmlNextChar(ctxt);
              goto LABEL_94;
            }
            if (!ctxt->name) {
              goto LABEL_55;
            }
            uint64_t v27 = (uint64_t)v26;
            __key[0] = ctxt->name;
            __key[1] = v26;
            if (!bsearch(__key, htmlStartClose, 0xFBuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))htmlCompareStartClose))goto LABEL_55; {
            htmlAutoClose((int *)ctxt, v27);
            }
          }
        }
      }
    }
    if (*ctxt->input->cur == 62)
    {
      xmlNextChar(ctxt);
    }
  }
  else
  {
    htmlParseErr(ctxt, 1, "htmlParseElement: context error\n", 0, 0);
  }
}

void __htmlParseContent(uint64_t a1)
{
  if (a1) {
    htmlParseContentInternal(a1);
  }
}

void htmlParseComment(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 276)) {
    return;
  }
  xmlParserInputPtr v2 = *(xmlParserInput **)(a1 + 56);
  cur = v2->cur;
  if (*cur != 60 || cur[1] != 33 || cur[2] != 45 || cur[3] != 45) {
    return;
  }
  int v4 = *(_DWORD *)(a1 + 272);
  *(_DWORD *)(a1 + 272) = 5;
  int v5 = cur + 4;
  v2->cur = v5;
  v2->col += 4;
  if (v5 - v2->base >= 501 && v2->end - v5 <= 499) {
    xmlParserInputShrink(v2);
  }
  int v6 = (xmlChar *)xmlMallocAtomic(0x64uLL);
  if (!v6)
  {
    htmlErrMemory((_DWORD *)a1, (const xmlChar *)"buffer allocation failed\n");
    *(_DWORD *)(a1 + 272) = v4;
    return;
  }
  int v7 = v6;
  int v38 = 0;
  *int v6 = 0;
  int v8 = htmlCurrentChar(a1, &v38);
  if (!v8) {
    goto LABEL_64;
  }
  int v9 = v8;
  uint64_t v10 = *(void *)(a1 + 56);
  int v11 = v38;
  int v12 = *(unsigned char **)(v10 + 32);
  BOOL v13 = &v12[v38];
  if ((unint64_t)v13 <= *(void *)(v10 + 40))
  {
    if (*v12 == 10)
    {
      ++*(_DWORD *)(v10 + 52);
      *(_DWORD *)(v10 + 56) = 1;
    }
    else
    {
      ++*(_DWORD *)(v10 + 56);
    }
    *(_DWORD *)(a1 + 276) = 0;
    *(void *)(v10 + 32) = v13;
    ++*(void *)(a1 + 312);
  }
  int v37 = 0;
  int v35 = htmlCurrentChar(a1, &v37);
  if (!v35) {
    goto LABEL_64;
  }
  uint64_t v14 = *(void *)(a1 + 56);
  int v15 = v37;
  unsigned int v16 = *(unsigned char **)(v14 + 32);
  unsigned int v17 = &v16[v37];
  if ((unint64_t)v17 <= *(void *)(v14 + 40))
  {
    if (*v16 == 10)
    {
      ++*(_DWORD *)(v14 + 52);
      *(_DWORD *)(v14 + 56) = 1;
    }
    else
    {
      ++*(_DWORD *)(v14 + 56);
    }
    *(_DWORD *)(a1 + 276) = 0;
    *(void *)(v14 + 32) = v17;
    ++*(void *)(a1 + 312);
  }
  uint64_t v36 = 0;
  int v18 = htmlCurrentChar(a1, (_DWORD *)&v36 + 1);
  if (!v18)
  {
    int v20 = 0;
LABEL_63:
    v7[v20] = 0;
LABEL_64:
    htmlParseErr((_DWORD *)a1, 45, "Comment not terminated \n<!--%.50s\n", v7, 0);
    xmlFreeFunc v32 = xmlFree;
    ((void (*)(xmlChar *))v32)(v7);
    return;
  }
  int v19 = v18;
  int v34 = v4;
  int v20 = 0;
  int v21 = 100;
  while (1)
  {
    int v22 = v35;
    int v35 = v19;
    if (v9 == 45 && v22 == 45 && v19 == 62) {
      break;
    }
    uint64_t v23 = *(void *)(a1 + 56);
    int v24 = HIDWORD(v36);
    int v25 = *(unsigned char **)(v23 + 32);
    size_t v26 = &v25[SHIDWORD(v36)];
    if ((unint64_t)v26 <= *(void *)(v23 + 40))
    {
      if (*v25 == 10)
      {
        ++*(_DWORD *)(v23 + 52);
        int v27 = 1;
      }
      else
      {
        int v27 = *(_DWORD *)(v23 + 56) + 1;
      }
      *(_DWORD *)(v23 + 56) = v27;
      *(_DWORD *)(a1 + 276) = 0;
      *(void *)(v23 + 32) = v26;
      ++*(void *)(a1 + 312);
    }
    int v19 = htmlCurrentChar(a1, &v36);
    if (!v19)
    {
      int v28 = *(xmlParserInput **)(a1 + 56);
      BOOL v29 = v28->cur;
      if (v29 - v28->base >= 501 && v28->end - v29 <= 499) {
        xmlParserInputShrink(v28);
      }
      if (!*(_DWORD *)(a1 + 452))
      {
        unsigned int v30 = *(xmlParserInput **)(a1 + 56);
        if (v30->end - v30->cur <= 249) {
          xmlParserInputGrow(v30, 250);
        }
      }
      int v19 = htmlCurrentChar(a1, &v36);
    }
    if (v9 == 45 && v22 == 45 && v35 == 33 && v19 == 62)
    {
      htmlParseErr((_DWORD *)a1, 45, "Comment incorrectly closed by '--!>'", 0, 0);
      break;
    }
    if (v20 + 5 >= v21)
    {
      v21 *= 2;
      uint64_t v31 = (xmlChar *)xmlRealloc(v7, v21);
      if (!v31)
      {
        xmlFree(v7);
        htmlErrMemory((_DWORD *)a1, (const xmlChar *)"growing buffer failed\n");
        goto LABEL_74;
      }
      int v7 = v31;
    }
    if (v9 > 255)
    {
      if ((v9 - 0x10000) < 0x100000
        || v9 >> 11 < 0x1B
        || (v9 - 57344) >> 1 <= 0xFFE)
      {
LABEL_57:
        if (v11 == 1)
        {
          v7[v20++] = v9;
          int v24 = HIDWORD(v36);
          int v15 = v37;
        }
        else
        {
          v20 += xmlCopyChar(v11, &v7[v20], v9);
        }
        goto LABEL_60;
      }
    }
    else if (v9 > 31 || v9 <= 0xD && ((1 << v9) & 0x2600) != 0)
    {
      goto LABEL_57;
    }
    htmlParseErrInt((_DWORD *)a1, "Invalid char in comment 0x%X\n", v9);
LABEL_60:
    int v11 = v15;
    HIDWORD(v36) = v36;
    int v37 = v24;
    int v15 = v24;
    int v9 = v22;
    if (!v19) {
      goto LABEL_63;
    }
  }
  v7[v20] = 0;
  xmlNextChar((xmlParserCtxtPtr)a1);
  if (*(void *)a1)
  {
    int v33 = *(void (**)(void, xmlChar *))(*(void *)a1 + 160);
    if (v33)
    {
      if (!*(_DWORD *)(a1 + 332)) {
        v33(*(void *)(a1 + 8), v7);
      }
    }
  }
  xmlFree(v7);
LABEL_74:
  *(_DWORD *)(a1 + 272) = v34;
}

void htmlParsePI(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 276)) {
    return;
  }
  xmlParserInputPtr v2 = *(xmlParserInput **)(a1 + 56);
  cur = v2->cur;
  if (*cur != 60 || cur[1] != 63) {
    return;
  }
  int v4 = *(_DWORD *)(a1 + 272);
  *(_DWORD *)(a1 + 272) = 2;
  int v5 = cur + 2;
  v2->cur = v5;
  v2->col += 2;
  if (v5 - v2->base >= 501 && v2->end - v5 <= 499) {
    xmlParserInputShrink(v2);
  }
  int v6 = htmlParseName(a1);
  if (!v6)
  {
    htmlParseErr((_DWORD *)a1, 46, "PI is not started correctly", 0, 0);
    goto LABEL_68;
  }
  int v7 = v6;
  if (!*(_DWORD *)(a1 + 276))
  {
    uint64_t v8 = *(void *)(a1 + 56);
    int v9 = *(unsigned char **)(v8 + 32);
    if (*v9 == 62)
    {
      *(void *)(v8 + 32) = v9 + 1;
      ++*(_DWORD *)(v8 + 56);
      if (*(void *)a1 && !*(_DWORD *)(a1 + 332))
      {
        uint64_t v10 = *(void (**)(void, const xmlChar *, void))(*(void *)a1 + 152);
        if (v10) {
          v10(*(void *)(a1 + 8), v6, 0);
        }
      }
      goto LABEL_68;
    }
  }
  int v11 = xmlMallocAtomic(0x64uLL);
  if (!v11)
  {
    htmlErrMemory((_DWORD *)a1, 0);
    goto LABEL_68;
  }
  int v12 = v11;
  unsigned int v13 = **(unsigned __int8 **)(*(void *)(a1 + 56) + 32);
  BOOL v14 = v13 > 0x20;
  uint64_t v15 = (1 << v13) & 0x100002600;
  if (v14 || v15 == 0) {
    htmlParseErr((_DWORD *)a1, 65, "ParsePI: PI %s space expected\n", v7, 0);
  }
  int len = 0;
  htmlSkipBlankChars(a1);
  int v17 = htmlCurrentChar(a1, &len);
  int v18 = 0;
  int v19 = 0;
  int v20 = 100;
  while (v17 && v17 != 62)
  {
    if (v18 + 5 >= v20)
    {
      v20 *= 2;
      int v21 = xmlRealloc(v12, v20);
      if (!v21)
      {
        htmlErrMemory((_DWORD *)a1, 0);
        goto LABEL_67;
      }
      int v12 = v21;
    }
    if (v19 >= 50)
    {
      if (!*(_DWORD *)(a1 + 452))
      {
        int v22 = *(xmlParserInput **)(a1 + 56);
        if (v22->end - v22->cur <= 249) {
          xmlParserInputGrow(v22, 250);
        }
      }
      int v19 = 0;
    }
    else
    {
      ++v19;
    }
    if (v17 > 255)
    {
      if ((v17 - 0x10000) >= 0x100000
        && v17 >> 11 >= 0x1B
        && (v17 - 57344) >> 1 > 0xFFE)
      {
LABEL_41:
        htmlParseErrInt((_DWORD *)a1, "Invalid char in processing instruction 0x%X\n", v17);
        goto LABEL_45;
      }
    }
    else if (v17 <= 31 && (v17 > 0xD || ((1 << v17) & 0x2600) == 0))
    {
      goto LABEL_41;
    }
    if (len == 1) {
      *((unsigned char *)v12 + v18++) = v17;
    }
    else {
      v18 += xmlCopyChar(len, (xmlChar *)v12 + v18, v17);
    }
LABEL_45:
    uint64_t v23 = *(void *)(a1 + 56);
    int v24 = *(unsigned char **)(v23 + 32);
    int v25 = &v24[len];
    if ((unint64_t)v25 <= *(void *)(v23 + 40))
    {
      if (*v24 == 10)
      {
        ++*(_DWORD *)(v23 + 52);
        *(_DWORD *)(v23 + 56) = 1;
      }
      else
      {
        ++*(_DWORD *)(v23 + 56);
      }
      *(_DWORD *)(a1 + 276) = 0;
      *(void *)(v23 + 32) = v25;
      ++*(void *)(a1 + 312);
    }
    int v17 = htmlCurrentChar(a1, &len);
    if (!v17)
    {
      size_t v26 = *(xmlParserInput **)(a1 + 56);
      int v27 = v26->cur;
      if (v27 - v26->base >= 501 && v26->end - v27 <= 499) {
        xmlParserInputShrink(v26);
      }
      if (!*(_DWORD *)(a1 + 452))
      {
        int v28 = *(xmlParserInput **)(a1 + 56);
        if (v28->end - v28->cur <= 249) {
          xmlParserInputGrow(v28, 250);
        }
      }
      int v17 = htmlCurrentChar(a1, &len);
    }
  }
  *((unsigned char *)v12 + v18) = 0;
  if (v17 == 62)
  {
    uint64_t v29 = *(void *)(a1 + 56);
    ++*(void *)(v29 + 32);
    ++*(_DWORD *)(v29 + 56);
    if (*(void *)a1)
    {
      if (!*(_DWORD *)(a1 + 332))
      {
        unsigned int v30 = *(void (**)(void, const xmlChar *, void *))(*(void *)a1 + 152);
        if (v30) {
          v30(*(void *)(a1 + 8), v7, v12);
        }
      }
    }
  }
  else
  {
    htmlParseErr((_DWORD *)a1, 47, "ParsePI: PI %s never end ...\n", v7, 0);
  }
LABEL_67:
  xmlFree(v12);
LABEL_68:
  *(_DWORD *)(a1 + 272) = v4;
}

void htmlParseDocTypeDecl(xmlParserCtxt *a1)
{
  xmlParserInputPtr input = a1->input;
  input->cur += 9;
  input->col += 9;
  htmlSkipBlankChars((uint64_t)a1);
  unint64_t v3 = htmlParseName((uint64_t)a1);
  if (!v3) {
    htmlParseErr(a1, 68, "htmlParseDocTypeDecl : no DOCTYPE name !\n", 0, 0);
  }
  htmlSkipBlankChars((uint64_t)a1);
  xmlParserInputPtr v4 = a1->input;
  cur = (unsigned __int8 *)v4->cur;
  if (__toupper(*cur) == 83
    && __toupper(cur[1]) == 89
    && __toupper(cur[2]) == 83
    && __toupper(cur[3]) == 84
    && __toupper(cur[4]) == 69
    && __toupper(cur[5]) == 77)
  {
    v4->cur = cur + 6;
    xmlParserInputPtr v6 = a1->input;
    v6->col += 6;
    LODWORD(v6) = *v6->cur;
    BOOL v7 = v6 > 0x20;
    uint64_t v8 = (1 << (char)v6) & 0x100002600;
    if (v7 || v8 == 0) {
      htmlParseErr(a1, 65, "Space required after 'SYSTEM'\n", 0, 0);
    }
    htmlSkipBlankChars((uint64_t)a1);
    uint64_t v10 = htmlParseSystemLiteral(a1);
    if (!v10) {
      htmlParseErr(a1, 70, "htmlParseExternalID: SYSTEM, no URI\n", 0, 0);
    }
    int v11 = 0;
  }
  else
  {
    xmlParserInputPtr v12 = a1->input;
    unsigned int v13 = (unsigned __int8 *)v12->cur;
    if (__toupper(*v13) == 80
      && __toupper(v13[1]) == 85
      && __toupper(v13[2]) == 66
      && __toupper(v13[3]) == 76
      && __toupper(v13[4]) == 73
      && __toupper(v13[5]) == 67)
    {
      v12->cur = v13 + 6;
      xmlParserInputPtr v14 = a1->input;
      v14->col += 6;
      unsigned int v15 = *v14->cur;
      if (v15 > 0x20 || ((1 << v15) & 0x100002600) == 0) {
        htmlParseErr(a1, 65, "Space required after 'PUBLIC'\n", 0, 0);
      }
      htmlSkipBlankChars((uint64_t)a1);
      int v11 = htmlParsePubidLiteral(a1);
      if (!v11) {
        htmlParseErr(a1, 71, "htmlParseExternalID: PUBLIC, no Public Identifier\n", 0, 0);
      }
      htmlSkipBlankChars((uint64_t)a1);
      int v16 = *a1->input->cur;
      if (v16 == 39 || v16 == 34)
      {
        uint64_t v10 = htmlParseSystemLiteral(a1);
        goto LABEL_34;
      }
    }
    else
    {
      int v11 = 0;
    }
    uint64_t v10 = 0;
  }
LABEL_34:
  htmlSkipBlankChars((uint64_t)a1);
  if (*a1->input->cur == 62)
  {
LABEL_35:
    xmlNextChar(a1);
  }
  else
  {
    htmlParseErr(a1, 61, "DOCTYPE improperly terminated\n", 0, 0);
    while (*a1->input->cur)
    {
      if (*a1->input->cur == 62) {
        goto LABEL_35;
      }
      xmlNextChar(a1);
    }
  }
  if (a1->sax)
  {
    internalSubset = (void (*)(void *, const xmlChar *, xmlChar *, xmlChar *))a1->sax->internalSubset;
    if (internalSubset)
    {
      if (!a1->disableSAX) {
        internalSubset(a1->userData, v3, v11, v10);
      }
    }
  }
  if (v10) {
    xmlFree(v10);
  }
  if (v11)
  {
    xmlFreeFunc v18 = xmlFree;
    ((void (*)(xmlChar *))v18)(v11);
  }
}

int htmlParseChunk(htmlParserCtxtPtr ctxt, const char *chunk, int size, int terminate)
{
  htmlParserCtxtPtr v4 = ctxt;
  if (!ctxt || (xmlParserInputPtr input = ctxt->input) == 0)
  {
    xmlParserInputPtr v14 = "htmlParseChunk: context error\n";
    int v13 = 1;
    int v15 = 1;
LABEL_10:
    htmlParseErr(ctxt, v15, v14, 0, 0);
    return v13;
  }
  if (chunk && size >= 1 && input->buf && ctxt->instate != XML_PARSER_EOF)
  {
    unint64_t InputBase = xmlBufGetInputBase((uint64_t)input->buf->buffer, (uint64_t)input);
    xmlParserInputPtr v10 = v4->input;
    uint64_t v11 = v10->cur - v10->base;
    int v12 = xmlParserInputBufferPush(v10->buf, size, chunk);
    xmlBufSetInputBaseCur((uint64_t *)v4->input->buf->buffer, &v4->input->buf, InputBase, v11);
    if (v12 < 0)
    {
      int v13 = -1;
      v4->int errNo = -1;
      v4->disableSAX = 1;
      return v13;
    }
    goto LABEL_17;
  }
  if (ctxt->instate != XML_PARSER_EOF)
  {
    uint64_t buf = (uint64_t)input->buf;
    if (input->buf)
    {
      if (*(void *)(buf + 24))
      {
        uint64_t v17 = *(void *)(buf + 32);
        if (v17)
        {
          if (*(void *)(buf + 40))
          {
            unint64_t v18 = xmlBufGetInputBase(v17, (uint64_t)input);
            uint64_t v19 = v4->input->cur - v4->input->base;
            int v20 = xmlCharEncInput(buf, terminate);
            xmlBufSetInputBaseCur(*(uint64_t **)(buf + 32), &v4->input->buf, v18, v19);
            if (v20 < 0)
            {
              xmlParserInputPtr v14 = "encoder error\n";
              int v13 = 81;
              ctxt = v4;
              int v15 = 81;
              goto LABEL_10;
            }
          }
        }
      }
    }
  }
LABEL_17:
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  xmlParserInputPtr v21 = v4->input;
  if (!v21) {
    goto LABEL_272;
  }
  BOOL v22 = terminate != 0;
  while (1)
  {
LABEL_19:
    if (v21->buf) {
      size_t length = xmlBufUse(v21->buf->buffer);
    }
    else {
      size_t length = v21->length;
    }
    base = v21->base;
    cur = v21->cur;
    uint64_t v26 = (uint64_t)&base[length - (void)cur];
    if (terminate && !v26)
    {
      htmlAutoCloseOnEnd((uint64_t)v4);
      if (!v4->nameNr && v4->instate != XML_PARSER_EOF)
      {
        v4->xmlParserInputState instate = XML_PARSER_EOF;
        if (v4->sax)
        {
          endDocumentSAXFunc endDocument = (void (*)(void *))v4->sax->endDocument;
          if (endDocument) {
            endDocument(v4->userData);
          }
        }
      }
LABEL_272:
      uint64_t v26 = 0;
LABEL_273:
      BOOL v22 = terminate != 0;
      if (terminate && !v26)
      {
        htmlAutoCloseOnEnd((uint64_t)v4);
        if (!v4->nameNr && v4->instate != XML_PARSER_EOF)
        {
          v4->xmlParserInputState instate = XML_PARSER_EOF;
          if (v4->sax)
          {
            uint64_t v94 = (void (*)(void *))v4->sax->endDocument;
            if (v94) {
              v94(v4->userData);
            }
          }
        }
        BOOL v22 = 1;
      }
      goto LABEL_277;
    }
    if (v26 < 1) {
      goto LABEL_273;
    }
    unsigned int v27 = *cur;
    if (*cur) {
      break;
    }
    xmlParserInputPtr v30 = v4->input;
    ++v30->cur;
    ++v30->col;
LABEL_78:
    xmlParserInputPtr v21 = v4->input;
    if (!v21) {
      goto LABEL_273;
    }
  }
  switch(v4->instate)
  {
    case XML_PARSER_EOF:
      goto LABEL_277;
    case XML_PARSER_START:
      if (v27 <= 0x20 && ((1 << v27) & 0x100002600) != 0)
      {
        htmlSkipBlankChars((uint64_t)v4);
        if (v21->buf) {
          size_t v29 = xmlBufUse(v21->buf->buffer);
        }
        else {
          size_t v29 = v21->length;
        }
        uint64_t v26 = (uint64_t)&v21->base[v29 - (unint64_t)v21->cur];
      }
      sax = v4->sax;
      if (v4->sax)
      {
        setDocumentLocatorSAXFunc setDocumentLocator = (void (*)(void *, xmlSAXLocator *))sax->setDocumentLocator;
        if (!setDocumentLocator
          || (userData = v4->userData,
              xmlListPtr v58 = __xmlDefaultSAXLocator(),
              setDocumentLocator(userData, v58),
              (sax = v4->sax) != 0))
        {
          startDocumentSAXFunc startDocument = (void (*)(void *))sax->startDocument;
          if (startDocument)
          {
            if (!v4->disableSAX) {
              startDocument(v4->userData);
            }
          }
        }
      }
      int v60 = v21->cur;
      if (*v60 == 60 && v60[1] == 33)
      {
        uint64_t v61 = (unsigned __int8 *)v4->input->cur;
        if (__toupper(v61[2]) == 68
          && __toupper(v61[3]) == 79
          && __toupper(v61[4]) == 67
          && __toupper(v61[5]) == 84
          && __toupper(v61[6]) == 89
          && __toupper(v61[7]) == 80
          && __toupper(v61[8]) == 69)
        {
          goto LABEL_174;
        }
      }
      v4->xmlParserInputState instate = XML_PARSER_MISC;
      goto LABEL_78;
    case XML_PARSER_MISC:
      htmlSkipBlankChars((uint64_t)v4);
      if (v21->buf) {
        size_t v31 = xmlBufUse(v21->buf->buffer);
      }
      else {
        size_t v31 = v21->length;
      }
      int v46 = (unsigned __int8 *)v21->cur;
      uint64_t v26 = (uint64_t)&v21->base[v31 - (void)v46];
      if (v26 < 1) {
        goto LABEL_273;
      }
      if (v26 == 1)
      {
        if (!terminate) {
          goto LABEL_304;
        }
        goto LABEL_255;
      }
      int v47 = v46[1];
      int v48 = *v46;
      if (v48 != 60 || v47 != 33)
      {
        if (v48 == 60 && v47 == 63)
        {
          if (!terminate && (htmlParseLookupSequence((uint64_t)v4, 62, 0, 0) & 0x80000000) != 0) {
            goto LABEL_304;
          }
          htmlParsePI((uint64_t)v4);
          goto LABEL_166;
        }
LABEL_255:
        v4->xmlParserInputState instate = XML_PARSER_CONTENT;
        goto LABEL_78;
      }
      if (v46[2] == 45 && v46[3] == 45)
      {
        if (!terminate && (htmlParseLookupCommentEnd((uint64_t)v4) & 0x80000000) != 0) {
          goto LABEL_304;
        }
        htmlParseComment((uint64_t)v4);
LABEL_166:
        v4->xmlParserInputState instate = XML_PARSER_MISC;
        goto LABEL_78;
      }
      uint64_t v62 = (unsigned __int8 *)v4->input->cur;
      if (__toupper(v62[2]) != 68
        || __toupper(v62[3]) != 79
        || __toupper(v62[4]) != 67
        || __toupper(v62[5]) != 84
        || __toupper(v62[6]) != 89
        || __toupper(v62[7]) != 80
        || __toupper(v62[8]) != 69)
      {
        if ((unint64_t)v26 < 9) {
          goto LABEL_277;
        }
        goto LABEL_255;
      }
LABEL_174:
      if (!terminate && (htmlParseLookupSequence((uint64_t)v4, 62, 0, 1) & 0x80000000) != 0) {
        goto LABEL_304;
      }
      htmlParseDocTypeDecl(v4);
      v4->xmlParserInputState instate = XML_PARSER_PROLOG;
      goto LABEL_78;
    case XML_PARSER_PI:
      xmlFreeFunc v32 = v4;
      int v33 = "HPP: internal error, state == PI\n";
      goto LABEL_76;
    case XML_PARSER_DTD:
      xmlFreeFunc v32 = v4;
      int v33 = "HPP: internal error, state == DTD\n";
      goto LABEL_76;
    case XML_PARSER_PROLOG:
      htmlSkipBlankChars((uint64_t)v4);
      if (v21->buf) {
        size_t v34 = xmlBufUse(v21->buf->buffer);
      }
      else {
        size_t v34 = v21->length;
      }
      uint64_t v49 = (unsigned __int8 *)v21->cur;
      uint64_t v26 = (uint64_t)&v21->base[v34 - (void)v49];
      if (v26 < 2) {
        goto LABEL_273;
      }
      int v50 = *v49;
      int v51 = v49[1];
      if (v50 == 60 && v51 == 33)
      {
        if (v49[2] != 45 || v49[3] != 45)
        {
          if ((unint64_t)v26 < 4) {
            goto LABEL_277;
          }
          goto LABEL_255;
        }
        if (!terminate && (htmlParseLookupCommentEnd((uint64_t)v4) & 0x80000000) != 0) {
          goto LABEL_304;
        }
        htmlParseComment((uint64_t)v4);
      }
      else
      {
        if (v50 != 60 || v51 != 63) {
          goto LABEL_255;
        }
        if (!terminate && (htmlParseLookupSequence((uint64_t)v4, 62, 0, 0) & 0x80000000) != 0) {
          goto LABEL_304;
        }
        htmlParsePI((uint64_t)v4);
      }
      v4->xmlParserInputState instate = XML_PARSER_PROLOG;
      goto LABEL_78;
    case XML_PARSER_COMMENT:
      xmlFreeFunc v32 = v4;
      int v33 = "HPP: internal error, state == COMMENT\n";
      goto LABEL_76;
    case XML_PARSER_START_TAG:
      if ((unint64_t)v26 > 1)
      {
        if (v27 != 60) {
          goto LABEL_255;
        }
        if (cur[1] == 47)
        {
          int v39 = 9;
LABEL_70:
          v4->xmlParserInputState instate = v39;
LABEL_77:
          v4->checkIndex = 0;
          goto LABEL_78;
        }
        if (!terminate && (htmlParseLookupSequence((uint64_t)v4, 62, 0, 1) & 0x80000000) != 0) {
          goto LABEL_304;
        }
      }
      else
      {
        if (!terminate) {
          goto LABEL_304;
        }
        if (v27 != 60) {
          goto LABEL_255;
        }
      }
      if (v4->record_info)
      {
        xmlParserInputPtr v63 = v4->input;
        int64_t v64 = &v63->cur[v63->consumed] - v63->base;
        uint64_t line = v63->line;
        *((void *)&v98 + 1) = v64;
        *(void *)&long long v99 = line;
      }
      int started = htmlParseStartTag((uint64_t)v4);
      if (v4->instate == XML_PARSER_EOF) {
        goto LABEL_307;
      }
      if (started == -1 || (name = v4->name) == 0)
      {
        xmlParserInputPtr v21 = v4->input;
        if (*v21->cur == 62)
        {
          xmlNextChar(v4);
          goto LABEL_78;
        }
        if (!v21) {
          goto LABEL_273;
        }
        goto LABEL_19;
      }
      xmlAttrPtr v68 = bsearch(v4->name, &html40ElementTable, 0x5CuLL, 0x40uLL, (int (__cdecl *)(const void *, const void *))htmlCompareTags);
      if (!v68) {
        htmlParseErr(v4, 801, "Tag %s invalid\n", name, 0);
      }
      xmlParserInputPtr v69 = v4->input;
      long long v70 = v69->cur;
      int v71 = *v70;
      if (v71 != 62)
      {
        if (v71 == 47 && v70[1] == 62)
        {
          v69->cur = v70 + 2;
          v69->col += 2;
          if (v4->sax)
          {
            endElementSAXFunc endElement = (void (*)(void *, const xmlChar *))v4->sax->endElement;
            if (endElement) {
              endElement(v4->userData, name);
            }
          }
          int nameNr = v4->nameNr;
          unsigned int v74 = nameNr - 1;
          if (nameNr >= 1)
          {
            v4->int nameNr = v74;
            nameTab = v4->nameTab;
            if (nameNr == 1) {
              long long v86 = 0;
            }
            else {
              long long v86 = nameTab[nameNr - 2];
            }
            v4->name = v86;
            nameTab[v74] = 0;
          }
        }
        else
        {
          htmlParseErr(v4, 73, "Couldn't find end of Start Tag %s\n", name, 0);
          if (xmlStrEqual(name, v4->name))
          {
            nodePop(v4);
            int v76 = v4->nameNr;
            unsigned int v77 = v76 - 1;
            if (v76 >= 1)
            {
              v4->int nameNr = v77;
              long long v78 = v4->nameTab;
              if (v76 == 1) {
                xmlGenericErrorFunc v85 = 0;
              }
              else {
                xmlGenericErrorFunc v85 = v78[v76 - 2];
              }
              v4->name = v85;
              v78[v77] = 0;
            }
          }
          if (v4->record_info) {
            htmlNodeInfoPush((uint64_t)v4, &v98);
          }
        }
        goto LABEL_255;
      }
      xmlNextChar(v4);
      if (v68 && v68[11])
      {
        if (v4->sax)
        {
          long long v80 = (void (*)(void *, const xmlChar *))v4->sax->endElement;
          if (v80) {
            v80(v4->userData, name);
          }
        }
        int v81 = v4->nameNr;
        unsigned int v82 = v81 - 1;
        if (v81 >= 1)
        {
          v4->int nameNr = v82;
          xmlGenericErrorFunc v83 = v4->nameTab;
          if (v81 == 1) {
            long long v87 = 0;
          }
          else {
            long long v87 = v83[v81 - 2];
          }
          v4->name = v87;
          v83[v82] = 0;
        }
      }
      if (v4->record_info) {
        htmlNodeInfoPush((uint64_t)v4, &v98);
      }
      v4->xmlParserInputState instate = XML_PARSER_CONTENT;
      goto LABEL_78;
    case XML_PARSER_CONTENT:
      __int16 v97 = 0;
      if (v4->token)
      {
        LOBYTE(v97) = v4->token;
        htmlCheckParagraph((uint64_t)v4);
        if (v4->sax)
        {
          characters = (void (*)(void *, __int16 *, uint64_t))v4->sax->characters;
          if (characters) {
            characters(v4->userData, &v97, 1);
          }
        }
        v4->token = 0;
        v4->checkIndex = 0;
      }
      if (terminate && v26 == 1)
      {
        unsigned int v36 = *v21->cur;
        if (v36 == 38 || v36 == 60) {
          goto LABEL_277;
        }
        int v37 = v4->sax;
        if (!v4->sax) {
          goto LABEL_231;
        }
        LOBYTE(v97) = *v21->cur;
        if (v36 <= 0x20 && ((1 << v36) & 0x100002600) != 0)
        {
          if (!v4->keepBlanks)
          {
            ignorableWhitespace = (void (*)(void *, __int16 *, uint64_t))v37->ignorableWhitespace;
            if (!ignorableWhitespace) {
              goto LABEL_231;
            }
LABEL_230:
            ignorableWhitespace(v4->userData, &v97, 1);
LABEL_231:
            v4->token = 0;
            v4->checkIndex = 0;
            ++v21->cur;
            goto LABEL_78;
          }
        }
        else
        {
          htmlCheckParagraph((uint64_t)v4);
          int v37 = v4->sax;
        }
        ignorableWhitespace = (void (*)(void *, __int16 *, uint64_t))v37->characters;
        if (ignorableWhitespace) {
          goto LABEL_230;
        }
        goto LABEL_231;
      }
      if ((unint64_t)v26 < 2) {
        goto LABEL_277;
      }
      int v41 = v21->cur;
      int v42 = *v41;
      int v43 = v41[1];
      if (xmlStrEqual(v4->name, (const xmlChar *)"script") || xmlStrEqual(v4->name, (const xmlChar *)"style"))
      {
        if (!terminate)
        {
          int v44 = htmlParseLookupSequence((uint64_t)v4, 60, 47, 0);
          if (v44 < 0) {
            goto LABEL_277;
          }
          if (!v21->cur[v44 + 2])
          {
LABEL_304:
            BOOL v22 = 0;
            goto LABEL_277;
          }
        }
        htmlParseScript((uint64_t)v4);
        if (v42 == 60 && v43 == 47)
        {
LABEL_91:
          int v45 = 9;
          goto LABEL_92;
        }
      }
      else if (v42 == 60 && v43 == 33)
      {
        long long v79 = (unsigned __int8 *)v4->input->cur;
        if (__toupper(v79[2]) != 68
          || __toupper(v79[3]) != 79
          || __toupper(v79[4]) != 67
          || __toupper(v79[5]) != 84
          || __toupper(v79[6]) != 89
          || __toupper(v79[7]) != 80
          || __toupper(v79[8]) != 69)
        {
          long long v84 = v21->cur;
          if (v84[2] != 45 || v84[3] != 45)
          {
            if ((unint64_t)v26 < 4) {
              goto LABEL_277;
            }
            goto LABEL_245;
          }
          if (!terminate && (htmlParseLookupCommentEnd((uint64_t)v4) & 0x80000000) != 0) {
            goto LABEL_277;
          }
          htmlParseComment((uint64_t)v4);
          goto LABEL_243;
        }
        if (!terminate && (htmlParseLookupSequence((uint64_t)v4, 62, 0, 1) & 0x80000000) != 0) {
          goto LABEL_277;
        }
        htmlParseErr(v4, 800, "Misplaced DOCTYPE declaration\n", (const xmlChar *)"DOCTYPE", 0);
        htmlParseDocTypeDecl(v4);
      }
      else
      {
        if (v42 == 60 && v43 == 63)
        {
          if (!terminate && (htmlParseLookupSequence((uint64_t)v4, 62, 0, 0) & 0x80000000) != 0) {
            goto LABEL_277;
          }
          htmlParsePI((uint64_t)v4);
LABEL_243:
          v4->xmlParserInputState instate = XML_PARSER_CONTENT;
          goto LABEL_78;
        }
        if (v42 == 60 && v43 == 47) {
          goto LABEL_91;
        }
        if (v42 == 60)
        {
          if (!(terminate | v43)) {
            goto LABEL_277;
          }
LABEL_245:
          int v45 = 6;
LABEL_92:
          v4->xmlParserInputState instate = v45;
          v4->checkIndex = 0;
          goto LABEL_78;
        }
        if (!terminate && (htmlParseLookupSequence((uint64_t)v4, 60, 0, 0) & 0x80000000) != 0) {
          goto LABEL_277;
        }
        v4->checkIndex = 0;
        if (v4->instate != XML_PARSER_EOF)
        {
          uint64_t v88 = v21->cur;
          do
          {
            if (v88 >= v21->end) {
              break;
            }
            if (v42 == 38) {
              htmlParseReference((uint64_t)v4);
            }
            else {
              htmlParseCharData((uint64_t)v4);
            }
            if (v4->instate == XML_PARSER_EOF) {
              break;
            }
            uint64_t v88 = v21->cur;
            int v42 = *v88;
          }
          while (v42 != 60);
        }
      }
      goto LABEL_78;
    case XML_PARSER_CDATA_SECTION:
      xmlFreeFunc v32 = v4;
      int v33 = "HPP: internal error, state == CDATA\n";
      goto LABEL_76;
    case XML_PARSER_END_TAG:
      if ((unint64_t)v26 < 2) {
        goto LABEL_277;
      }
      if (!terminate && (htmlParseLookupSequence((uint64_t)v4, 62, 0, 0) & 0x80000000) != 0) {
        goto LABEL_304;
      }
      htmlParseEndTag(v4);
      if (v4->nameNr) {
        int v39 = 7;
      }
      else {
        int v39 = 14;
      }
      goto LABEL_70;
    case XML_PARSER_ENTITY_DECL:
      xmlFreeFunc v32 = v4;
      int v33 = "HPP: internal error, state == ENTITY_DECL\n";
      goto LABEL_76;
    case XML_PARSER_ENTITY_VALUE:
      xmlFreeFunc v32 = v4;
      int v33 = "HPP: internal error, state == ENTITY_VALUE\n";
      goto LABEL_76;
    case XML_PARSER_ATTRIBUTE_VALUE:
      htmlParseErr(v4, 1, "HPP: internal error, state == ATTRIBUTE_VALUE\n", 0, 0);
      int v39 = 6;
      goto LABEL_70;
    case XML_PARSER_SYSTEM_LITERAL:
      xmlFreeFunc v32 = v4;
      int v33 = "HPP: internal error, state == XML_PARSER_SYSTEM_LITERAL\n";
      goto LABEL_76;
    case XML_PARSER_EPILOG:
      if (v21->buf)
      {
        size_t v40 = xmlBufUse(v21->buf->buffer);
        base = v21->base;
        cur = v21->cur;
      }
      else
      {
        size_t v40 = v21->length;
      }
      uint64_t v26 = (uint64_t)&base[v40 - (void)cur];
      if (v26 < 1) {
        goto LABEL_273;
      }
      unsigned int v52 = *cur;
      if (v52 <= 0x20 && ((1 << v52) & 0x100002600) != 0)
      {
        htmlParseCharData((uint64_t)v4);
        goto LABEL_277;
      }
      if ((unint64_t)v26 < 2) {
        goto LABEL_277;
      }
      int v54 = cur[1];
      if (v52 != 60 || v54 != 33)
      {
        if (v52 != 60 || v54 != 63) {
          goto LABEL_306;
        }
        if (!terminate && (htmlParseLookupSequence((uint64_t)v4, 62, 0, 0) & 0x80000000) != 0) {
          goto LABEL_304;
        }
        htmlParsePI((uint64_t)v4);
        goto LABEL_140;
      }
      if (cur[2] == 45 && cur[3] == 45)
      {
        if (!terminate && (htmlParseLookupCommentEnd((uint64_t)v4) & 0x80000000) != 0) {
          goto LABEL_304;
        }
        htmlParseComment((uint64_t)v4);
LABEL_140:
        v4->xmlParserInputState instate = XML_PARSER_EPILOG;
        goto LABEL_78;
      }
      if ((unint64_t)v26 >= 4)
      {
LABEL_306:
        v4->int errNo = 5;
        v4->wellFormed = 0;
        v4->xmlParserInputState instate = XML_PARSER_EOF;
LABEL_307:
        if (v4->sax)
        {
          uint64_t v96 = (void (*)(void *))v4->sax->endDocument;
          if (v96) {
            v96(v4->userData);
          }
        }
      }
LABEL_277:
      if ((v4->options & 4) == 0)
      {
        xmlDocPtr myDoc = v4->myDoc;
        if (myDoc)
        {
          if (v22 || (xmlParserInputState instate = v4->instate, instate == XML_PARSER_EPILOG) || instate == XML_PARSER_EOF)
          {
            if (!xmlGetIntSubset(myDoc)) {
              v4->myDoc->intSubset = xmlCreateIntSubset(v4->myDoc, (const xmlChar *)"html", (const xmlChar *)"-//W3C//DTD HTML 4.0 Transitional//EN", (const xmlChar *)"http://www.w3.org/TR/REC-html40/loose.dtd");
            }
          }
        }
      }
      if (terminate)
      {
        xmlParserInputState v91 = v4->instate;
        if (v91 != XML_PARSER_EOF)
        {
          if (v91 != XML_PARSER_MISC && v91 != XML_PARSER_EPILOG)
          {
            v4->int errNo = 5;
            v4->wellFormed = 0;
          }
          if (v4->sax)
          {
            long long v92 = (void (*)(void *))v4->sax->endDocument;
            if (v92) {
              v92(v4->userData);
            }
          }
        }
        v4->xmlParserInputState instate = XML_PARSER_EOF;
      }
      return v4->errNo;
    case XML_PARSER_IGNORE:
      xmlFreeFunc v32 = v4;
      int v33 = "HPP: internal error, state == XML_PARSER_IGNORE\n";
      goto LABEL_76;
    case XML_PARSER_PUBLIC_LITERAL:
      xmlFreeFunc v32 = v4;
      int v33 = "HPP: internal error, state == XML_PARSER_LITERAL\n";
LABEL_76:
      htmlParseErr(v32, 1, v33, 0, 0);
      v4->xmlParserInputState instate = XML_PARSER_CONTENT;
      goto LABEL_77;
    default:
      goto LABEL_78;
  }
}

htmlParserCtxtPtr htmlCreatePushParserCtxt(htmlSAXHandlerPtr sax, void *user_data, const char *chunk, int size, const char *filename, xmlCharEncoding enc)
{
  xmlInitParser();
  xmlParserInputBufferPtr v12 = xmlAllocParserInputBuffer(enc);
  if (!v12) {
    return 0;
  }
  xmlParserInputBufferPtr v13 = v12;
  htmlParserCtxtPtr v14 = htmlNewParserCtxt();
  int v15 = v14;
  if (!v14)
  {
    xmlFreeParserInputBuffer(v13);
    return v15;
  }
  if (enc == XML_CHAR_ENCODING_UTF8 || v13->encoder) {
    v14->charset = 1;
  }
  if (sax)
  {
    int v16 = (xmlSAXHandlerV1 *)v14->sax;
    if (v16 != __htmlDefaultSAXHandler()) {
      xmlFree(v15->sax);
    }
    uint64_t v17 = (_xmlSAXHandler *)xmlMalloc(0x100uLL);
    v15->sax = v17;
    if (!v17)
    {
      xmlFree(v13);
      ((void (*)(xmlParserCtxt *))xmlFree)(v15);
      return 0;
    }
    long long v18 = *(_OWORD *)&sax->internalSubset;
    long long v19 = *(_OWORD *)&sax->hasInternalSubset;
    long long v20 = *(_OWORD *)&sax->entityDecl;
    *(_OWORD *)&v17->resolveEntity = *(_OWORD *)&sax->resolveEntity;
    *(_OWORD *)&v17->entityDecl = v20;
    *(_OWORD *)&v17->internalSubset = v18;
    *(_OWORD *)&v17->hasInternalSubset = v19;
    long long v21 = *(_OWORD *)&sax->attributeDecl;
    long long v22 = *(_OWORD *)&sax->unparsedEntityDecl;
    long long v23 = *(_OWORD *)&sax->startElement;
    *(_OWORD *)&v17->startDocumentSAXFunc startDocument = *(_OWORD *)&sax->startDocument;
    *(_OWORD *)&v17->startElementSAXFunc startElement = v23;
    *(_OWORD *)&v17->attributeDecl = v21;
    *(_OWORD *)&v17->unparsedEntityDecl = v22;
    long long v24 = *(_OWORD *)&sax->reference;
    long long v25 = *(_OWORD *)&sax->ignorableWhitespace;
    long long v26 = *(_OWORD *)&sax->error;
    *(_OWORD *)&v17->comment = *(_OWORD *)&sax->comment;
    *(_OWORD *)&v17->error = v26;
    *(_OWORD *)&v17->reference = v24;
    *(_OWORD *)&v17->ignorableWhitespace = v25;
    long long v27 = *(_OWORD *)&sax->getParameterEntity;
    long long v28 = *(_OWORD *)&sax->externalSubset;
    long long v29 = *(_OWORD *)&sax->endElementNs;
    *(_OWORD *)&v17->_private = *(_OWORD *)&sax->_private;
    *(_OWORD *)&v17->endElementNs = v29;
    *(_OWORD *)&v17->getParameterEntity = v27;
    *(_OWORD *)&v17->externalSubsetSAXFunc externalSubset = v28;
    if (user_data) {
      v15->userData = user_data;
    }
  }
  if (filename) {
    Directory = xmlParserGetDirectory(filename);
  }
  else {
    Directory = 0;
  }
  v15->directory = Directory;
  size_t v31 = (char *)xmlMalloc(0x68uLL);
  if (!v31)
  {
    htmlErrMemory(v15, (const xmlChar *)"couldn't allocate a new input stream\n");
    xmlFreeParserCtxt(v15);
    ((void (*)(xmlParserInputBufferPtr))xmlFree)(v13);
    return 0;
  }
  xmlFreeFunc v32 = (xmlParserInput *)v31;
  *(_OWORD *)size_t v31 = 0u;
  *((_OWORD *)v31 + 1) = 0u;
  *((_OWORD *)v31 + 2) = 0u;
  *((_OWORD *)v31 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0u;
  *((_OWORD *)v31 + 4) = 0u;
  *((_OWORD *)v31 + 5) = 0u;
  *(_OWORD *)(v31 + 8) = 0u;
  *(_OWORD *)(v31 + 24) = 0u;
  *((_DWORD *)v31 + 14) = 1;
  *(void *)size_t v31 = 0;
  *((void *)v31 + 11) = 0;
  *((void *)v31 + 12) = 0;
  *((void *)v31 + 6) = 0x100000000;
  *((void *)v31 + 8) = 0;
  *((void *)v31 + 9) = 0;
  if (filename) {
    int v33 = xmlCanonicPath((const xmlChar *)filename);
  }
  else {
    int v33 = 0;
  }
  v32->uint64_t buf = v13;
  v32->filename = (const char *)v33;
  xmlBufResetInput((uint64_t *)v13->buffer, v32);
  inputPush(v15, v32);
  if (chunk)
  {
    if (size >= 1)
    {
      uint64_t input = (uint64_t)v15->input;
      if (input)
      {
        if (*(void *)input)
        {
          unint64_t InputBase = xmlBufGetInputBase(*(void *)(*(void *)input + 32), input);
          xmlParserInputPtr v36 = v15->input;
          uint64_t v37 = v36->cur - v36->base;
          xmlParserInputBufferPush(v36->buf, size, chunk);
          xmlBufSetInputBaseCur((uint64_t *)v15->input->buf->buffer, &v15->input->buf, InputBase, v37);
        }
      }
    }
  }
  v15->int progressive = 1;
  return v15;
}

htmlDocPtr htmlSAXParseDoc(const xmlChar *cur, const char *encoding, htmlSAXHandlerPtr sax, void *userData)
{
  xmlInitParser();
  if (!cur) {
    return 0;
  }
  DocParserCtxt = htmlCreateDocParserCtxt(cur, (const xmlChar *)encoding);
  if (!DocParserCtxt) {
    return 0;
  }
  int v9 = DocParserCtxt;
  if (sax)
  {
    xmlParserInputPtr v10 = DocParserCtxt->sax;
    if (v9->sax) {
      xmlFree(v10);
    }
    v9->sax = sax;
    v9->userData = userData;
    htmlParseDocument(v9);
    xmlDocPtr myDoc = v9->myDoc;
    v9->sax = 0;
    v9->userData = 0;
  }
  else
  {
    htmlParseDocument(DocParserCtxt);
    xmlDocPtr myDoc = v9->myDoc;
  }
  xmlFreeParserCtxt(v9);
  return myDoc;
}

xmlParserCtxt *htmlCreateDocParserCtxt(const xmlChar *a1, const xmlChar *a2)
{
  int v4 = xmlStrlen(a1);
  htmlParserCtxtPtr MemoryParserCtxt = htmlCreateMemoryParserCtxt((const char *)a1, v4);
  xmlParserInputPtr v6 = MemoryParserCtxt;
  if (!a2 || !MemoryParserCtxt) {
    return v6;
  }
  encoding = (xmlChar *)MemoryParserCtxt->input->encoding;
  if (encoding) {
    xmlFree(encoding);
  }
  v6->input->encoding = xmlStrdup(a2);
  xmlCharEncoding v8 = xmlParseCharEncoding((const char *)a2);
  if (v8 != XML_CHAR_ENCODING_ERROR)
  {
    int v9 = xmlSwitchEncoding(v6, v8);
    int errNo = v6->errNo;
    if (errNo != 32)
    {
      if (v9 < 0) {
        goto LABEL_12;
      }
      return v6;
    }
LABEL_16:
    xmlParserInputBufferPtr v13 = "Unsupported encoding %s\n";
    htmlParserCtxtPtr v14 = v6;
    int v12 = 32;
LABEL_17:
    htmlParseErr(v14, v12, v13, a2, 0);
    return v6;
  }
  xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler((const char *)a2);
  if (!CharEncodingHandler) {
    goto LABEL_16;
  }
  if (xmlSwitchToEncoding(v6, CharEncodingHandler) < 0)
  {
    int errNo = v6->errNo;
LABEL_12:
    if (errNo) {
      int v12 = errNo;
    }
    else {
      int v12 = 6003;
    }
    xmlParserInputBufferPtr v13 = "htmlCheckEncoding: error switching to encoding '%s'\n";
    htmlParserCtxtPtr v14 = v6;
    goto LABEL_17;
  }
  return v6;
}

htmlDocPtr htmlParseDoc(const xmlChar *cur, const char *encoding)
{
  return htmlSAXParseDoc(cur, encoding, 0, 0);
}

htmlParserCtxtPtr htmlCreateFileParserCtxt(const char *filename, const char *encoding)
{
  if (!filename) {
    return 0;
  }
  int v4 = htmlNewParserCtxt();
  if (!v4) {
    return v4;
  }
  int v5 = xmlCanonicPath((const xmlChar *)filename);
  if (!v5)
  {
    if (__xmlDefaultSAXHandler()->error)
    {
      int v12 = __xmlDefaultSAXHandler();
      v12->error(0, "out of memory\n");
    }
    goto LABEL_11;
  }
  xmlParserInputPtr v6 = v5;
  ExternalEntity = xmlLoadExternalEntity((const char *)v5, 0, v4);
  xmlFree(v6);
  if (!ExternalEntity)
  {
LABEL_11:
    xmlFreeParserCtxt(v4);
    return 0;
  }
  inputPush(v4, ExternalEntity);
  if (encoding)
  {
    size_t v8 = strlen(encoding);
    if (v8 <= 0x3E7)
    {
      size_t v9 = v8 + xmlStrlen((const xmlChar *)"charset=") + 1;
      xmlParserInputPtr v10 = (char *)xmlMallocAtomic(v9);
      if (v10)
      {
        uint64_t v11 = (xmlChar *)v10;
        snprintf(v10, v9, "%s%s", "charset=", encoding);
        htmlCheckEncoding((uint64_t)v4, v11);
        xmlFree(v11);
      }
    }
  }
  return v4;
}

const xmlChar *htmlCheckEncoding(uint64_t a1, xmlChar *str)
{
  int result = xmlStrcasestr(str, (const xmlChar *)"charset");
  if (result)
  {
    unsigned int v6 = result[7];
    result += 7;
    unsigned int v5 = v6;
    uint64_t v7 = (1 << v6) & 0x100002600;
    if (v6 <= 0x20 && v7 != 0)
    {
      int result = xmlStrcasestr(str, (const xmlChar *)"=");
      if (!result) {
        return result;
      }
      unsigned int v5 = *result;
    }
    if (v5 == 61)
    {
      return (const xmlChar *)htmlCheckEncodingDirect(a1, (xmlChar *)result + 1);
    }
  }
  return result;
}

htmlDocPtr htmlSAXParseFile(const char *filename, const char *encoding, htmlSAXHandlerPtr sax, void *userData)
{
  xmlInitParser();
  htmlParserCtxtPtr FileParserCtxt = htmlCreateFileParserCtxt(filename, encoding);
  if (!FileParserCtxt) {
    return 0;
  }
  size_t v9 = FileParserCtxt;
  if (sax)
  {
    xmlParserInputPtr v10 = FileParserCtxt->sax;
    FileParserCtxt->sax = sax;
    FileParserCtxt->userData = userData;
    htmlParseDocument(FileParserCtxt);
    xmlDocPtr myDoc = v9->myDoc;
    v9->sax = v10;
    v9->userData = 0;
  }
  else
  {
    htmlParseDocument(FileParserCtxt);
    xmlDocPtr myDoc = v9->myDoc;
  }
  xmlFreeParserCtxt(v9);
  return myDoc;
}

htmlDocPtr htmlParseFile(const char *filename, const char *encoding)
{
  return htmlSAXParseFile(filename, encoding, 0, 0);
}

int htmlHandleOmittedElem(int val)
{
  int v1 = htmlOmittedDefaultValue;
  htmlOmittedDefaultValue = val;
  return v1;
}

int htmlElementAllowedHere(const htmlElemDesc *a1, const xmlChar *a2)
{
  xmlParserInputPtr v2 = a1;
  LODWORD(a1) = 0;
  if (v2 && a2)
  {
    subelts = (const htmlElemDesc **)v2->subelts;
    if (subelts)
    {
      a1 = *subelts;
      if (*subelts)
      {
        unsigned int v5 = subelts + 1;
        while (xmlStrcmp((const xmlChar *)a1, a2))
        {
          unsigned int v6 = *v5++;
          a1 = v6;
          if (!v6) {
            return (int)a1;
          }
        }
        LODWORD(a1) = 1;
      }
    }
    else
    {
      LODWORD(a1) = 0;
    }
  }
  return (int)a1;
}

htmlStatus htmlElementStatusHere(const htmlElemDesc *a1, const htmlElemDesc *a2)
{
  htmlStatus result = HTML_INVALID;
  if (a1 && a2)
  {
    if (htmlElementAllowedHere(a1, (const xmlChar *)a2->name))
    {
      if (a2->dtd) {
        return 2;
      }
      else {
        return 4;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

htmlStatus htmlAttrAllowed(const htmlElemDesc *a1, const xmlChar *a2, int a3)
{
  htmlStatus result = HTML_INVALID;
  if (a1 && a2)
  {
    attrs_req = a1->attrs_req;
    if (attrs_req && (size_t v8 = (const xmlChar *)*attrs_req) != 0)
    {
      size_t v9 = (const xmlChar **)(attrs_req + 1);
      while (xmlStrcmp(v8, a2))
      {
        xmlParserInputPtr v10 = *v9++;
        size_t v8 = v10;
        if (!v10) {
          goto LABEL_8;
        }
      }
      return 12;
    }
    else
    {
LABEL_8:
      attrs_opt = a1->attrs_opt;
      if (attrs_opt && (int v12 = (const xmlChar *)*attrs_opt) != 0)
      {
        xmlParserInputBufferPtr v13 = (const xmlChar **)(attrs_opt + 1);
        while (xmlStrcmp(v12, a2))
        {
          htmlParserCtxtPtr v14 = *v13++;
          int v12 = v14;
          if (!v14) {
            goto LABEL_13;
          }
        }
        return 4;
      }
      else
      {
LABEL_13:
        if (a3 && (attrs_depr = a1->attrs_depr) != 0 && (int v16 = (const xmlChar *)*attrs_depr) != 0)
        {
          uint64_t v17 = (const xmlChar **)(attrs_depr + 1);
          while (xmlStrcmp(v16, a2))
          {
            long long v18 = *v17++;
            int v16 = v18;
            if (!v18) {
              return 1;
            }
          }
          return 2;
        }
        else
        {
          return 1;
        }
      }
    }
  }
  return result;
}

htmlStatus htmlNodeStatus(const htmlNodePtr a1, int a2)
{
  if (!a1) {
    return 1;
  }
  xmlElementType type = a1->type;
  if (type == XML_ATTRIBUTE_NODE)
  {
    name = (const htmlElemDesc *)a1->parent->name;
    if (name) {
      name = (const htmlElemDesc *)bsearch(name, &html40ElementTable, 0x5CuLL, 0x40uLL, (int (__cdecl *)(const void *, const void *))htmlCompareTags);
    }
    size_t v8 = a1->name;
    return htmlAttrAllowed(name, v8, a2);
  }
  else if (type == XML_ELEMENT_NODE)
  {
    unsigned int v5 = (const htmlElemDesc *)a1->parent->name;
    if (a2)
    {
      if (v5) {
        unsigned int v5 = (const htmlElemDesc *)bsearch(v5, &html40ElementTable, 0x5CuLL, 0x40uLL, (int (__cdecl *)(const void *, const void *))htmlCompareTags);
      }
      if (htmlElementAllowedHere(v5, a1->name)) {
        return 4;
      }
      else {
        return 1;
      }
    }
    else
    {
      if (v5) {
        size_t v9 = (const htmlElemDesc *)bsearch(v5, &html40ElementTable, 0x5CuLL, 0x40uLL, (int (__cdecl *)(const void *, const void *))htmlCompareTags);
      }
      else {
        size_t v9 = 0;
      }
      xmlParserInputPtr v10 = a1->name;
      if (v10) {
        uint64_t v11 = (const htmlElemDesc *)bsearch(v10, &html40ElementTable, 0x5CuLL, 0x40uLL, (int (__cdecl *)(const void *, const void *))htmlCompareTags);
      }
      else {
        uint64_t v11 = 0;
      }
      return htmlElementStatusHere(v9, v11);
    }
  }
  else
  {
    return 0;
  }
}

void htmlCtxtReset(htmlParserCtxtPtr ctxt)
{
  if (!ctxt) {
    return;
  }
  xmlInitParser();
  dict = ctxt->dict;
  while (1)
  {
    unint64_t v3 = inputPop(ctxt);
    if (!v3) {
      break;
    }
    xmlFreeInputStream(v3);
  }
  ctxt->inputNr = 0;
  ctxt->uint64_t input = 0;
  ctxt->spaceNr = 0;
  spaceTab = ctxt->spaceTab;
  if (spaceTab) {
    int *spaceTab = -1;
  }
  ctxt->space = spaceTab;
  ctxt->nodeNr = 0;
  ctxt->node = 0;
  ctxt->int nameNr = 0;
  ctxt->name = 0;
  ctxt->nsNr = 0;
  version = (xmlChar *)ctxt->version;
  if (version)
  {
    if (dict)
    {
      if (xmlDictOwns(dict, version)) {
        goto LABEL_12;
      }
      version = (xmlChar *)ctxt->version;
    }
    xmlFree(version);
  }
LABEL_12:
  ctxt->version = 0;
  encoding = (xmlChar *)ctxt->encoding;
  if (!encoding) {
    goto LABEL_17;
  }
  if (dict)
  {
    if (xmlDictOwns(dict, encoding)) {
      goto LABEL_17;
    }
    encoding = (xmlChar *)ctxt->encoding;
  }
  xmlFree(encoding);
LABEL_17:
  ctxt->encoding = 0;
  directory = ctxt->directory;
  if (!directory) {
    goto LABEL_22;
  }
  if (dict)
  {
    if (xmlDictOwns(dict, (const xmlChar *)directory)) {
      goto LABEL_22;
    }
    directory = ctxt->directory;
  }
  xmlFree(directory);
LABEL_22:
  ctxt->directory = 0;
  extSubxmlURIPtr URI = ctxt->extSubURI;
  if (!extSubURI) {
    goto LABEL_27;
  }
  if (dict)
  {
    if (xmlDictOwns(dict, extSubURI)) {
      goto LABEL_27;
    }
    extSubxmlURIPtr URI = ctxt->extSubURI;
  }
  xmlFree(extSubURI);
LABEL_27:
  ctxt->extSubxmlURIPtr URI = 0;
  extSubSystem = ctxt->extSubSystem;
  if (extSubSystem)
  {
    if (!dict)
    {
LABEL_31:
      xmlFree(extSubSystem);
      goto LABEL_32;
    }
    if (!xmlDictOwns(dict, extSubSystem))
    {
      extSubSystem = ctxt->extSubSystem;
      goto LABEL_31;
    }
  }
LABEL_32:
  ctxt->extSubSystem = 0;
  xmlDocPtr myDoc = ctxt->myDoc;
  if (myDoc) {
    xmlFreeDoc(myDoc);
  }
  ctxt->xmlDocPtr myDoc = 0;
  *(void *)&ctxt->standalone = 0x1FFFFFFFFLL;
  *(void *)&ctxt->xmlParserInputState instate = 0;
  ctxt->wellFormed = 1;
  ctxt->nsWellFormed = 1;
  *(void *)&ctxt->disableSAX = 0;
  ctxt->valint id = 1;
  ctxt->vctxt.finishDtd = -1412623820;
  ctxt->vctxt.userData = ctxt;
  ctxt->vctxt.error = xmlParserValidityError;
  ctxt->vctxt.warning = xmlParserValidityWarning;
  ctxt->record_xmlParserNodeInfo info = 0;
  ctxt->checkIndex = 0;
  *(void *)&ctxt->int errNo = 0;
  *(void *)&ctxt->hasPErefs = 0;
  ctxt->depth = 0;
  ctxt->charset = 0;
  ctxt->catalogs = 0;
  xmlInitNodeInfoSeq(&ctxt->node_seq);
  attsDefault = ctxt->attsDefault;
  if (attsDefault)
  {
    xmlHashFree(attsDefault, xmlHashDefaultDeallocator);
    ctxt->attsDefault = 0;
  }
  attsSpecial = ctxt->attsSpecial;
  if (attsSpecial)
  {
    xmlHashFree(attsSpecial, 0);
    ctxt->attsSpecial = 0;
  }
}

htmlDocPtr htmlReadDoc(const xmlChar *cur, const char *URL, const char *encoding, int options)
{
  if (!cur) {
    return 0;
  }
  xmlInitParser();
  int v8 = xmlStrlen(cur);
  htmlParserCtxtPtr MemoryParserCtxt = htmlCreateMemoryParserCtxt((const char *)cur, v8);
  if (!MemoryParserCtxt) {
    return 0;
  }

  return htmlDoRead(MemoryParserCtxt, (const xmlChar *)URL, encoding, options, 0);
}

xmlDocPtr htmlDoRead(xmlParserCtxt *a1, const xmlChar *a2, const char *a3, int options, int a5)
{
  htmlCtxtUseOptions(a1, options);
  a1->html = 1;
  if (a3)
  {
    xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler(a3);
    if (CharEncodingHandler)
    {
      if (xmlSwitchToEncoding(a1, CharEncodingHandler) < 0)
      {
        if (a1->errNo) {
          int errNo = a1->errNo;
        }
        else {
          int errNo = 6003;
        }
        htmlParseErr(a1, errNo, "htmlCheckEncoding: error switching to encoding '%s'\n", (const xmlChar *)a3, 0);
        if (!a2) {
          goto LABEL_15;
        }
        goto LABEL_8;
      }
      encoding = (xmlChar *)a1->input->encoding;
      if (encoding) {
        xmlFree(encoding);
      }
      a1->input->encoding = xmlStrdup((const xmlChar *)a3);
    }
  }
  if (!a2) {
    goto LABEL_15;
  }
LABEL_8:
  xmlParserInputPtr input = a1->input;
  if (input && !input->filename) {
    a1->input->filename = (const char *)xmlStrdup(a2);
  }
LABEL_15:
  htmlParseDocument(a1);
  xmlDocPtr myDoc = a1->myDoc;
  a1->xmlDocPtr myDoc = 0;
  if (!a5)
  {
    if (a1->dictNames && myDoc && myDoc->dict == a1->dict) {
      a1->dict = 0;
    }
    xmlFreeParserCtxt(a1);
  }
  return myDoc;
}

htmlDocPtr htmlReadFile(const char *URL, const char *encoding, int options)
{
  xmlInitParser();
  htmlDocPtr result = (htmlDocPtr)htmlCreateFileParserCtxt(URL, encoding);
  if (result)
  {
    return htmlDoRead((xmlParserCtxt *)result, 0, 0, options, 0);
  }
  return result;
}

htmlDocPtr htmlReadMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)
{
  xmlInitParser();
  htmlDocPtr result = (htmlDocPtr)xmlCreateMemoryParserCtxt(buffer, size);
  if (result)
  {
    uint64_t v11 = (xmlParserCtxt *)result;
    htmlDefaultSAXHandlerInit();
    sax = v11->sax;
    if (v11->sax)
    {
      xmlParserInputBufferPtr v13 = __htmlDefaultSAXHandler();
      long long v14 = *(_OWORD *)&v13->hasInternalSubset;
      *(_OWORD *)&sax->internalSubset = *(_OWORD *)&v13->internalSubset;
      *(_OWORD *)&sax->hasInternalSubset = v14;
      long long v15 = *(_OWORD *)&v13->unparsedEntityDecl;
      long long v17 = *(_OWORD *)&v13->resolveEntity;
      long long v16 = *(_OWORD *)&v13->entityDecl;
      *(_OWORD *)&sax->attributeDecl = *(_OWORD *)&v13->attributeDecl;
      *(_OWORD *)&sax->unparsedEntityDecl = v15;
      *(_OWORD *)&sax->resolveEntity = v17;
      *(_OWORD *)&sax->entityDecl = v16;
      long long v18 = *(_OWORD *)&v13->ignorableWhitespace;
      long long v20 = *(_OWORD *)&v13->startDocument;
      long long v19 = *(_OWORD *)&v13->startElement;
      *(_OWORD *)&sax->reference = *(_OWORD *)&v13->reference;
      *(_OWORD *)&sax->ignorableWhitespace = v18;
      *(_OWORD *)&sax->startDocumentSAXFunc startDocument = v20;
      *(_OWORD *)&sax->startElementSAXFunc startElement = v19;
      long long v21 = *(_OWORD *)&v13->externalSubset;
      long long v23 = *(_OWORD *)&v13->comment;
      long long v22 = *(_OWORD *)&v13->error;
      *(_OWORD *)&sax->getParameterEntity = *(_OWORD *)&v13->getParameterEntity;
      *(_OWORD *)&sax->externalSubsetSAXFunc externalSubset = v21;
      *(_OWORD *)&sax->comment = v23;
      *(_OWORD *)&sax->error = v22;
    }
    return htmlDoRead(v11, (const xmlChar *)URL, encoding, options, 0);
  }
  return result;
}

htmlDocPtr htmlReadFd(int fd, const char *URL, const char *encoding, int options)
{
  if (fd < 0) {
    return 0;
  }
  xmlInitParser();
  xmlParserInputBufferPtr v8 = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
  if (!v8) {
    return 0;
  }
  size_t v9 = v8;
  v8->closecallbacuint64_t k = 0;
  xmlParserInputPtr v10 = htmlNewParserCtxt();
  if (!v10)
  {
    xmlFreeParserInputBuffer(v9);
    return 0;
  }
  uint64_t v11 = v10;
  int v12 = xmlNewIOInputStream(v10, v9, XML_CHAR_ENCODING_NONE);
  if (!v12)
  {
    xmlFreeParserInputBuffer(v9);
    xmlFreeParserCtxt(v11);
    return 0;
  }
  inputPush(v11, v12);

  return htmlDoRead(v11, (const xmlChar *)URL, encoding, options, 0);
}

htmlDocPtr htmlReadIO(xmlInputReadCallback ioread, xmlInputCloseCallback ioclose, void *ioctx, const char *URL, const char *encoding, int options)
{
  if (!ioread) {
    return 0;
  }
  xmlInitParser();
  xmlParserInputBufferPtr IO = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, XML_CHAR_ENCODING_NONE);
  if (!IO)
  {
    if (ioclose) {
      ((void (*)(void *))ioclose)(ioctx);
    }
    return 0;
  }
  xmlParserInputBufferPtr v13 = IO;
  long long v14 = htmlNewParserCtxt();
  if (!v14)
  {
    xmlFreeParserInputBuffer(v13);
    return 0;
  }
  long long v15 = v14;
  long long v16 = xmlNewIOInputStream(v14, v13, XML_CHAR_ENCODING_NONE);
  if (!v16)
  {
    xmlFreeParserInputBuffer(v13);
    xmlFreeParserCtxt(v15);
    return 0;
  }
  inputPush(v15, v16);

  return htmlDoRead(v15, (const xmlChar *)URL, encoding, options, 0);
}

htmlDocPtr htmlCtxtReadDoc(xmlParserCtxtPtr ctxt, const xmlChar *cur, const char *URL, const char *encoding, int options)
{
  if (!ctxt) {
    return 0;
  }
  if (!cur) {
    return 0;
  }
  xmlInitParser();
  htmlCtxtReset(ctxt);
  xmlParserInputPtr v10 = xmlNewStringInputStream(ctxt, cur);
  if (!v10) {
    return 0;
  }
  inputPush(ctxt, v10);

  return htmlDoRead(ctxt, (const xmlChar *)URL, encoding, options, 1);
}

htmlDocPtr htmlCtxtReadFile(xmlParserCtxtPtr ctxt, const char *filename, const char *encoding, int options)
{
  if (!ctxt) {
    return 0;
  }
  if (!filename) {
    return 0;
  }
  xmlInitParser();
  htmlCtxtReset(ctxt);
  ExternalEntity = xmlLoadExternalEntity(filename, 0, ctxt);
  if (!ExternalEntity) {
    return 0;
  }
  inputPush(ctxt, ExternalEntity);

  return htmlDoRead(ctxt, 0, encoding, options, 1);
}

htmlDocPtr htmlCtxtReadMemory(xmlParserCtxtPtr ctxt, const char *buffer, int size, const char *URL, const char *encoding, int options)
{
  if (!ctxt) {
    return 0;
  }
  if (!buffer) {
    return 0;
  }
  xmlInitParser();
  htmlCtxtReset(ctxt);
  xmlParserInputBufferPtr Mem = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
  if (!Mem) {
    return 0;
  }
  xmlParserInputBufferPtr v13 = Mem;
  long long v14 = xmlNewIOInputStream(ctxt, Mem, XML_CHAR_ENCODING_NONE);
  if (!v14)
  {
    xmlFreeParserInputBuffer(v13);
    return 0;
  }
  inputPush(ctxt, v14);

  return htmlDoRead(ctxt, (const xmlChar *)URL, encoding, options, 1);
}

htmlDocPtr htmlCtxtReadFd(xmlParserCtxtPtr ctxt, int fd, const char *URL, const char *encoding, int options)
{
  if (!ctxt) {
    return 0;
  }
  if (fd < 0) {
    return 0;
  }
  xmlInitParser();
  htmlCtxtReset(ctxt);
  xmlParserInputPtr v10 = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
  if (!v10) {
    return 0;
  }
  uint64_t v11 = v10;
  int v12 = xmlNewIOInputStream(ctxt, v10, XML_CHAR_ENCODING_NONE);
  if (!v12)
  {
    xmlFreeParserInputBuffer(v11);
    return 0;
  }
  inputPush(ctxt, v12);

  return htmlDoRead(ctxt, (const xmlChar *)URL, encoding, options, 1);
}

htmlDocPtr htmlCtxtReadIO(xmlParserCtxtPtr ctxt, xmlInputReadCallback ioread, xmlInputCloseCallback ioclose, void *ioctx, const char *URL, const char *encoding, int options)
{
  if (!ctxt || !ioread) {
    return 0;
  }
  xmlInitParser();
  htmlCtxtReset(ctxt);
  xmlParserInputBufferPtr IO = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, XML_CHAR_ENCODING_NONE);
  if (!IO)
  {
    if (ioclose) {
      ((void (*)(void *))ioclose)(ioctx);
    }
    return 0;
  }
  long long v15 = IO;
  long long v16 = xmlNewIOInputStream(ctxt, IO, XML_CHAR_ENCODING_NONE);
  if (!v16)
  {
    xmlFreeParserInputBuffer(v15);
    return 0;
  }
  inputPush(ctxt, v16);

  return htmlDoRead(ctxt, (const xmlChar *)URL, encoding, options, 1);
}

xmlChar *htmlParseHTMLAttribute(uint64_t a1, int a2)
{
  str = 0;
  int v4 = (xmlChar *)xmlMallocAtomic(0x64uLL);
  if (v4)
  {
    unsigned int v5 = v4;
    unsigned int v6 = *(unsigned __int8 **)(*(void *)(a1 + 56) + 32);
    unsigned int v7 = *v6;
    if (*v6) {
      BOOL v8 = v7 == a2;
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8)
    {
      int v9 = 100;
      xmlParserInputPtr v10 = v4;
      while (1)
      {
        if (!a2 && v7 == 62) {
          goto LABEL_8;
        }
        if (a2)
        {
          if (v7 != 38) {
            goto LABEL_51;
          }
        }
        else
        {
          if (v7 > 0x26) {
            goto LABEL_51;
          }
          if (v7 != 38)
          {
            if (((1 << v7) & 0x100002600) != 0) {
              goto LABEL_8;
            }
LABEL_51:
            int v38 = 0;
            if (v5 - v10 > v9 - 100)
            {
              v9 *= 2;
              long long v25 = (xmlChar *)xmlRealloc(v10, v9);
              if (!v25) {
                goto LABEL_88;
              }
              unsigned int v5 = &v25[(int)v5 - (int)v10];
              xmlParserInputPtr v10 = v25;
            }
            unsigned int v26 = htmlCurrentChar(a1, &v38);
            if (*(_DWORD *)(a1 + 272) == -1) {
              goto LABEL_89;
            }
            if (v26 < 0x80)
            {
              *v5++ = v26;
            }
            else
            {
              if (HIWORD(v26)) {
                char v27 = (v26 >> 18) & 7 | 0xF0;
              }
              else {
                char v27 = (v26 >> 12) | 0xE0;
              }
              if (HIWORD(v26)) {
                int v28 = 12;
              }
              else {
                int v28 = 6;
              }
              unsigned int v29 = (v26 >> 6) | 0xFFFFFFC0;
              if (v26 <= 0x7FF)
              {
                unsigned int v30 = 0;
              }
              else
              {
                LOBYTE(v29) = v27;
                unsigned int v30 = v28;
              }
              *v5++ = v29;
              do
              {
                *v5++ = (v26 >> v30) & 0x3F | 0x80;
                BOOL v16 = v30 > 5;
                v30 -= 6;
              }
              while (v16);
            }
            xmlNextChar((xmlParserCtxtPtr)a1);
            goto LABEL_82;
          }
        }
        if (v6[1] == 35)
        {
          unsigned int v11 = htmlParseCharRef((htmlParserCtxtPtr)a1);
          if (v11 < 0x80)
          {
            *v5++ = v11;
          }
          else
          {
            if (HIWORD(v11)) {
              char v12 = (v11 >> 18) & 7 | 0xF0;
            }
            else {
              char v12 = (v11 >> 12) | 0xE0;
            }
            if (HIWORD(v11)) {
              int v13 = 12;
            }
            else {
              int v13 = 6;
            }
            unsigned int v14 = (v11 >> 6) | 0xFFFFFFC0;
            if (v11 <= 0x7FF)
            {
              unsigned int v15 = 0;
            }
            else
            {
              LOBYTE(v14) = v12;
              unsigned int v15 = v13;
            }
            *v5++ = v14;
            do
            {
              *v5++ = (v11 >> v15) & 0x3F | 0x80;
              BOOL v16 = v15 > 5;
              v15 -= 6;
            }
            while (v16);
          }
        }
        else
        {
          long long v17 = htmlParseEntityRef((htmlParserCtxtPtr)a1, (const xmlChar **)&str);
          if (str)
          {
            long long v18 = v17;
            if (v17)
            {
              if (v5 - v10 > v9 - 100)
              {
                v9 *= 2;
                long long v19 = (xmlChar *)xmlRealloc(v10, v9);
                if (!v19) {
                  goto LABEL_88;
                }
                unsigned int v5 = &v19[(int)v5 - (int)v10];
                xmlParserInputPtr v10 = v19;
              }
              unsigned int value = v18->value;
              if (v18->value < 0x80)
              {
                *v5++ = value;
              }
              else
              {
                if (HIWORD(value)) {
                  char v21 = (value >> 18) & 7 | 0xF0;
                }
                else {
                  char v21 = (value >> 12) | 0xE0;
                }
                if (HIWORD(value)) {
                  int v22 = 12;
                }
                else {
                  int v22 = 6;
                }
                unsigned int v23 = (value >> 6) | 0xFFFFFFC0;
                if (value <= 0x7FF)
                {
                  unsigned int v24 = 0;
                }
                else
                {
                  LOBYTE(v2xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = v21;
                  unsigned int v24 = v22;
                }
                *v5++ = v23;
                do
                {
                  *v5++ = (value >> v24) & 0x3F | 0x80;
                  BOOL v16 = v24 > 5;
                  v24 -= 6;
                }
                while (v16);
              }
            }
            else
            {
              *v5++ = 38;
              xmlChar v32 = *str;
              if (*str)
              {
                int v33 = str + 1;
                do
                {
                  if (v5 - v10 > v9 - 100)
                  {
                    v9 *= 2;
                    size_t v34 = (xmlChar *)xmlRealloc(v10, v9);
                    if (!v34) {
                      goto LABEL_88;
                    }
                    unsigned int v5 = &v34[(int)v5 - (int)v10];
                    xmlChar v32 = *(v33 - 1);
                    xmlParserInputPtr v10 = v34;
                  }
                  *v5++ = v32;
                  int v35 = *v33++;
                  xmlChar v32 = v35;
                }
                while (v35);
              }
            }
            goto LABEL_82;
          }
          *v5++ = 38;
        }
        if (v5 - v10 > v9 - 100)
        {
          v9 *= 2;
          size_t v31 = (xmlChar *)xmlRealloc(v10, v9);
          if (!v31)
          {
LABEL_88:
            htmlErrMemory((_DWORD *)a1, (const xmlChar *)"growing buffer\n");
LABEL_89:
            xmlFree(v10);
            return 0;
          }
          unsigned int v5 = &v31[(int)v5 - (int)v10];
          xmlParserInputPtr v10 = v31;
        }
LABEL_82:
        unsigned int v6 = *(unsigned __int8 **)(*(void *)(a1 + 56) + 32);
        unsigned int v7 = *v6;
        if (*v6) {
          BOOL v36 = v7 == a2;
        }
        else {
          BOOL v36 = 1;
        }
        if (v36) {
          goto LABEL_8;
        }
      }
    }
    xmlParserInputPtr v10 = v4;
LABEL_8:
    *unsigned int v5 = 0;
  }
  else
  {
    htmlErrMemory((_DWORD *)a1, (const xmlChar *)"buffer allocation failed\n");
    return 0;
  }
  return v10;
}

uint64_t htmlCheckEncodingDirect(uint64_t result, xmlChar *cur)
{
  if (!cur) {
    return result;
  }
  uint64_t v2 = result;
  if ((*(unsigned char *)(result + 566) & 0x20) != 0 || *(void *)(*(void *)(result + 56) + 80)) {
    return result;
  }
  for (uint64_t i = cur; ; ++i)
  {
    int v4 = *i;
    if (v4 != 32 && v4 != 9) {
      break;
    }
  }
  *(void *)(*(void *)(result + 56) + 80) = xmlStrdup(i);
  xmlCharEncoding v6 = xmlParseCharEncoding((const char *)i);
  if ((v6 - 2) >= 4)
  {
    if (v6 == XML_CHAR_ENCODING_ERROR)
    {
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler((const char *)i);
      if (!CharEncodingHandler)
      {
        htmlDocPtr result = (uint64_t)htmlParseErr((_DWORD *)v2, 32, "htmlCheckEncoding: unknown encoding %s\n", i, 0);
        goto LABEL_27;
      }
      htmlDocPtr result = xmlSwitchToEncoding((xmlParserCtxtPtr)v2, CharEncodingHandler);
      if ((result & 0x80000000) != 0) {
        goto LABEL_21;
      }
      goto LABEL_26;
    }
  }
  else
  {
    uint64_t v7 = **(void **)(v2 + 56);
    if (v7 && !*(void *)(v7 + 24))
    {
      BOOL v8 = "htmlCheckEncoding: wrong encoding meta\n";
      int v9 = (_DWORD *)v2;
      int v10 = 81;
      unsigned int v11 = 0;
LABEL_25:
      htmlDocPtr result = (uint64_t)htmlParseErr(v9, v10, v8, v11, 0);
      goto LABEL_26;
    }
  }
  htmlDocPtr result = xmlSwitchEncoding((xmlParserCtxtPtr)v2, v6);
  if ((result & 0x80000000) != 0)
  {
LABEL_21:
    if (*(_DWORD *)(v2 + 136)) {
      int v10 = *(_DWORD *)(v2 + 136);
    }
    else {
      int v10 = 6003;
    }
    BOOL v8 = "htmlCheckEncoding: error switching to encoding '%s'\n";
    int v9 = (_DWORD *)v2;
    unsigned int v11 = i;
    goto LABEL_25;
  }
LABEL_26:
  *(_DWORD *)(v2 + 408) = 1;
LABEL_27:
  int v13 = *(void **)(v2 + 56);
  unsigned int v14 = (void *)*v13;
  if (*v13)
  {
    if (v14[3])
    {
      if (v14[5])
      {
        htmlDocPtr result = v14[4];
        if (result)
        {
          xmlBufShrink((xmlBufPtr)result, v13[4] - v13[3]);
          int v15 = xmlCharEncInput(**(void **)(v2 + 56), 1);
          htmlDocPtr result = xmlBufResetInput(*(uint64_t **)(**(void **)(v2 + 56) + 32), *(void **)(v2 + 56));
          if (v15 < 0)
          {
            return (uint64_t)htmlParseErr((_DWORD *)v2, 81, "htmlCheckEncoding: encoder error\n", 0, 0);
          }
        }
      }
    }
  }
  return result;
}

xmlChar *htmlParseEndTag(xmlParserCtxt *a1)
{
  int v1 = a1;
  xmlParserInputPtr input = a1->input;
  cur = input->cur;
  if (*cur == 60 && cur[1] == 47)
  {
    input->cur = cur + 2;
    input->col += 2;
    htmlDocPtr result = (xmlChar *)htmlParseHTMLName(a1);
    if (result)
    {
      unsigned int v5 = result;
      htmlSkipBlankChars((uint64_t)v1);
      if (*v1->input->cur == 62)
      {
LABEL_5:
        xmlNextChar(v1);
      }
      else
      {
        htmlParseErr(v1, 73, "End tag : expected '>'\n", 0, 0);
        while (*v1->input->cur)
        {
          if (*v1->input->cur == 62) {
            goto LABEL_5;
          }
          xmlNextChar(v1);
        }
      }
      if (v1->depth >= 1
        && (xmlStrEqual(v5, (const xmlChar *)"html")
         || xmlStrEqual(v5, (const xmlChar *)"body")
         || xmlStrEqual(v5, (const xmlChar *)"head")))
      {
        htmlDocPtr result = 0;
        --v1->depth;
      }
      else
      {
        uint64_t nameNr = v1->nameNr;
        do
        {
          if ((int)nameNr < 1)
          {
            xmlCharEncoding v6 = "Unexpected end tag : %s\n";
            a1 = v1;
            int v7 = 76;
            BOOL v8 = v5;
            goto LABEL_12;
          }
          uint64_t v10 = nameNr - 1;
          int v11 = xmlStrEqual(v5, v1->nameTab[nameNr - 1]);
          uint64_t nameNr = v10;
        }
        while (!v11);
        int EndPriority = htmlGetEndPriority(v5);
        uint64_t v13 = v1->nameNr - 1;
        while ((int)v13 + 1 >= 1)
        {
          if (xmlStrEqual(v5, v1->nameTab[v13]))
          {
            while (!xmlStrEqual(v5, v1->name))
            {
              name = v1->name;
              if (name)
              {
                BOOL v16 = bsearch(name, &html40ElementTable, 0x5CuLL, 0x40uLL, (int (__cdecl *)(const void *, const void *))htmlCompareTags);
                if (v16)
                {
                  if (v16[9] == 3) {
                    htmlParseErr(v1, 76, "Opening and ending tag mismatch: %s and %s\n", v5, (xmlChar *)v1->name);
                  }
                }
              }
              if (v1->sax)
              {
                endElementSAXFunc endElement = (void (*)(void *, const xmlChar *))v1->sax->endElement;
                if (endElement) {
                  endElement(v1->userData, v1->name);
                }
              }
              int v18 = v1->nameNr;
              unsigned int v19 = v18 - 1;
              if (v18 >= 1)
              {
                v1->uint64_t nameNr = v19;
                nameTab = v1->nameTab;
                if (v18 == 1) {
                  char v21 = 0;
                }
                else {
                  char v21 = nameTab[v18 - 2];
                }
                v1->name = v21;
                nameTab[v19] = 0;
              }
            }
            break;
          }
          int v14 = htmlGetEndPriority((xmlChar *)v1->nameTab[v13--]);
          if (v14 > EndPriority) {
            break;
          }
        }
        htmlDocPtr result = (xmlChar *)v1->name;
        if (result)
        {
          if (!xmlStrEqual(result, v5)) {
            htmlParseErr(v1, 76, "Opening and ending tag mismatch: %s and %s\n", v5, (xmlChar *)v1->name);
          }
          htmlDocPtr result = (xmlChar *)v1->name;
          if (result)
          {
            htmlDocPtr result = (xmlChar *)xmlStrEqual(result, v5);
            if (result)
            {
              if (v1->sax)
              {
                int v22 = (void (*)(void *, xmlChar *))v1->sax->endElement;
                if (v22) {
                  v22(v1->userData, v5);
                }
              }
              int nodeInfoNr = v1->nodeInfoNr;
              if (nodeInfoNr >= 1)
              {
                int v24 = nodeInfoNr - 2;
                int v26 = nodeInfoNr - 1;
                BOOL v25 = v26 == 0;
                v1->int nodeInfoNr = v26;
                uint64_t v27 = (uint64_t)&v1->nodeInfoTab[v24];
                if (v25) {
                  uint64_t v27 = 0;
                }
                v1->nodeInfo = (xmlParserNodeInfo *)v27;
              }
              int v28 = v1->nameNr;
              unsigned int v29 = v28 - 1;
              if (v28 >= 1)
              {
                v1->uint64_t nameNr = v29;
                unsigned int v30 = v1->nameTab;
                if (v28 == 1) {
                  size_t v31 = 0;
                }
                else {
                  size_t v31 = v30[v28 - 2];
                }
                v1->name = v31;
                v30[v29] = 0;
              }
              return (xmlChar *)1;
            }
          }
        }
      }
    }
  }
  else
  {
    xmlCharEncoding v6 = "htmlParseEndTag: '</' not found\n";
    int v7 = 74;
    BOOL v8 = 0;
LABEL_12:
    htmlParseErr(a1, v7, v6, v8, 0);
    return 0;
  }
  return result;
}

uint64_t htmlParseScript(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  bzero(v20, 0x3EDuLL);
  uint64_t v2 = *(xmlParserInput **)(a1 + 56);
  cur = v2->cur;
  if (cur - v2->base >= 501 && v2->end - cur <= 499) {
    xmlParserInputShrink(v2);
  }
  int len = 0;
  uint64_t result = htmlCurrentChar(a1, &len);
  int v5 = result;
  uint64_t v6 = 0;
  while (1)
  {
    if (v5 != 60)
    {
      if (!v5) {
        break;
      }
      if (v5 > 255)
      {
        if ((v5 - 0x10000) >= 0x100000
          && v5 >> 11 >= 0x1B
          && (v5 - 57344) >> 1 > 0xFFE)
        {
LABEL_19:
          htmlParseErrInt((_DWORD *)a1, "Invalid char in CDATA 0x%X\n", v5);
          int v11 = len;
          goto LABEL_24;
        }
      }
      else if (v5 <= 31 && (v5 > 0xD || ((1 << v5) & 0x2600) == 0))
      {
        goto LABEL_19;
      }
      goto LABEL_21;
    }
    uint64_t v7 = *(void *)(*(void *)(a1 + 56) + 32);
    if (*(unsigned char *)(v7 + 1) == 47)
    {
      if (*(_DWORD *)(a1 + 448))
      {
        BOOL v8 = *(const xmlChar **)(a1 + 288);
        int v9 = (const xmlChar *)(v7 + 2);
        int v10 = xmlStrlen(v8);
        uint64_t result = xmlStrncasecmp(v8, v9, v10);
        if (!result) {
          break;
        }
        htmlParseErr((_DWORD *)a1, 76, "Element %s embeds close tag\n", *(const xmlChar **)(a1 + 288), 0);
        goto LABEL_21;
      }
      if ((*(unsigned char *)(v7 + 2) & 0xDFu) - 65 < 0x1A) {
        break;
      }
    }
LABEL_21:
    int v11 = len;
    if (len == 1)
    {
      v20[(int)v6] = v5;
      uint64_t v6 = (v6 + 1);
    }
    else
    {
      uint64_t v6 = (xmlCopyChar(len, &v20[(int)v6], v5) + v6);
    }
LABEL_24:
    uint64_t v12 = *(void *)(a1 + 56);
    uint64_t v13 = *(unsigned char **)(v12 + 32);
    int v14 = &v13[v11];
    if ((unint64_t)v14 <= *(void *)(v12 + 40))
    {
      if (*v13 == 10)
      {
        ++*(_DWORD *)(v12 + 52);
        *(_DWORD *)(v12 + 56) = 1;
      }
      else
      {
        ++*(_DWORD *)(v12 + 56);
      }
      *(_DWORD *)(a1 + 276) = 0;
      *(void *)(v12 + 32) = v14;
      ++*(void *)(a1 + 312);
    }
    if ((int)v6 >= 1000)
    {
      v20[v6] = 0;
      int v15 = *(void (**)(void, xmlChar *, uint64_t))(*(void *)a1 + 200);
      if (v15 || (int v15 = *(void (**)(void, xmlChar *, uint64_t))(*(void *)a1 + 136)) != 0) {
        v15(*(void *)(a1 + 8), v20, v6);
      }
      uint64_t v6 = 0;
    }
    if (!*(_DWORD *)(a1 + 452))
    {
      BOOL v16 = *(xmlParserInput **)(a1 + 56);
      if (v16->end - v16->cur <= 249) {
        xmlParserInputGrow(v16, 250);
      }
    }
    uint64_t result = htmlCurrentChar(a1, &len);
    int v5 = result;
  }
  if (v6)
  {
    uint64_t v17 = *(void *)a1;
    if (*(void *)a1)
    {
      if (!*(_DWORD *)(a1 + 332))
      {
        v20[(int)v6] = 0;
        int v18 = *(uint64_t (**)(void, xmlChar *, uint64_t))(v17 + 200);
        if (v18) {
          return v18(*(void *)(a1 + 8), v20, v6);
        }
        int v18 = *(uint64_t (**)(void, xmlChar *, uint64_t))(v17 + 136);
        if (v18) {
          return v18(*(void *)(a1 + 8), v20, v6);
        }
      }
    }
  }
  return result;
}

uint64_t htmlGetEndPriority(xmlChar *str2)
{
  uint64_t v2 = 0;
  unint64_t v3 = (const xmlChar *)"div";
  int v4 = &off_1E60CDC30;
  do
  {
    if (xmlStrEqual(v3, str2)) {
      break;
    }
    ++v2;
    int v5 = *v4;
    v4 += 2;
    unint64_t v3 = (const xmlChar *)v5;
  }
  while (v2 != 11);
  return LODWORD((&htmlEndPriority)[2 * v2 + 1]);
}

void htmlParserFinishElementParsing(xmlParserCtxtPtr ctxt)
{
  xmlNodePtr node = ctxt->node;
  if (node)
  {
    if (ctxt->record_info)
    {
      xmlParserInputPtr input = ctxt->input;
      unint64_t v4 = &input->cur[input->consumed] - input->base;
      nodeInfo = ctxt->nodeInfo;
      unint64_t line = input->line;
      nodeInfo->end_pos = v4;
      nodeInfo->end_unint64_t line = line;
      nodeInfo->xmlNodePtr node = node;
      xmlParserAddNodeInfo(ctxt, nodeInfo);
      int nodeInfoNr = ctxt->nodeInfoNr;
      if (nodeInfoNr >= 1)
      {
        int v8 = nodeInfoNr - 2;
        int v10 = nodeInfoNr - 1;
        BOOL v9 = v10 == 0;
        ctxt->int nodeInfoNr = v10;
        int v11 = &ctxt->nodeInfoTab[v8];
        if (v9) {
          int v11 = 0;
        }
        ctxt->nodeInfo = v11;
      }
    }
  }
  if (!*ctxt->input->cur)
  {
    htmlAutoCloseOnEnd((uint64_t)ctxt);
  }
}

_DWORD *htmlNodeInfoPush(uint64_t a1, long long *a2)
{
  int v4 = *(_DWORD *)(a1 + 720);
  int v5 = *(_DWORD *)(a1 + 724);
  if (v4 < v5)
  {
    uint64_t result = *(_DWORD **)(a1 + 728);
LABEL_7:
    int v8 = &result[10 * v4];
    long long v9 = *a2;
    long long v10 = a2[1];
    *((void *)v8 + 4) = *((void *)a2 + 4);
    *(_OWORD *)int v8 = v9;
    *((_OWORD *)v8 + 1) = v10;
    int v11 = *(_DWORD *)(a1 + 720);
    *(void *)(a1 + 712) = *(void *)(a1 + 728) + 40 * v11;
    *(_DWORD *)(a1 + 720) = v11 + 1;
    return result;
  }
  int v7 = 2 * v5;
  if (!v5) {
    int v7 = 10;
  }
  *(_DWORD *)(a1 + 724) = v7;
  uint64_t result = xmlRealloc(*(void **)(a1 + 728), 40 * v7);
  *(void *)(a1 + 728) = result;
  if (result)
  {
    int v4 = *(_DWORD *)(a1 + 720);
    goto LABEL_7;
  }

  return htmlErrMemory((_DWORD *)a1, 0);
}

xmlChar *htmlParseSystemLiteral(xmlParserCtxtPtr ctxt)
{
  xmlParserCtxtPtr v1 = ctxt;
  int v2 = *ctxt->input->cur;
  if (v2 != 34 && v2 != 39)
  {
    long long v9 = "SystemLiteral \" or ' expected\n";
    int v10 = 43;
LABEL_29:
    htmlParseErr(ctxt, v10, v9, 0, 0);
    return 0;
  }
  xmlNextChar(ctxt);
  xmlParserInputPtr input = v1->input;
  unint64_t base = (unint64_t)input->base;
  cur = input->cur;
  unint64_t v6 = (unint64_t)&cur[-base];
  if ((unint64_t)cur >= base)
  {
    unsigned int v7 = *cur;
    if (*cur) {
      BOOL v8 = v7 == v2;
    }
    else {
      BOOL v8 = 1;
    }
    if (v8)
    {
      if (v7 == v2)
      {
        int v12 = 0;
        goto LABEL_32;
      }
    }
    else
    {
      int v11 = 0;
      int v12 = 0;
      do
      {
        if (v7 - 9 >= 2 && v7 != 13 && v7 <= 0x1F)
        {
          htmlParseErrInt(v1, "Invalid char in SystemLiteral 0x%X\n", v7);
          int v11 = 1;
        }
        xmlNextChar(v1);
        ++v12;
        xmlParserInputPtr input = v1->input;
        int v15 = input->cur;
        unsigned int v7 = *v15;
        if (*v15) {
          BOOL v16 = v7 == v2;
        }
        else {
          BOOL v16 = 1;
        }
      }
      while (!v16);
      if (v7 == v2)
      {
        if (v11)
        {
          uint64_t v17 = 0;
LABEL_33:
          xmlNextChar(v1);
          return v17;
        }
LABEL_32:
        uint64_t v17 = xmlStrndup(&input->base[v6], v12);
        goto LABEL_33;
      }
    }
    long long v9 = "Unfinished SystemLiteral\n";
    ctxt = v1;
    int v10 = 44;
    goto LABEL_29;
  }
  return 0;
}

xmlChar *htmlParsePubidLiteral(xmlParserCtxtPtr ctxt)
{
  xmlParserCtxtPtr v1 = ctxt;
  int v2 = *ctxt->input->cur;
  if (v2 != 34 && v2 != 39)
  {
    long long v9 = "PubidLiteral \" or ' expected\n";
    int v10 = 43;
LABEL_23:
    htmlParseErr(ctxt, v10, v9, 0, 0);
    return 0;
  }
  xmlNextChar(ctxt);
  xmlParserInputPtr input = v1->input;
  unint64_t base = (unint64_t)input->base;
  cur = input->cur;
  unint64_t v6 = (unint64_t)&cur[-base];
  if ((unint64_t)cur >= base)
  {
    int v7 = *cur;
    if (*cur) {
      BOOL v8 = v7 == v2;
    }
    else {
      BOOL v8 = 1;
    }
    if (v8)
    {
      if (v7 == v2)
      {
        int v12 = 0;
        goto LABEL_26;
      }
    }
    else
    {
      int v11 = 0;
      int v12 = 0;
      do
      {
        if (!xmlIsPubidChar_tab[v7])
        {
          htmlParseErrInt(v1, "Invalid char in PubidLiteral 0x%X\n", v7);
          int v11 = 1;
        }
        ++v12;
        xmlNextChar(v1);
        xmlParserInputPtr input = v1->input;
        uint64_t v13 = input->cur;
        int v7 = *v13;
        if (*v13) {
          BOOL v14 = v7 == v2;
        }
        else {
          BOOL v14 = 1;
        }
      }
      while (!v14);
      if (v7 == v2)
      {
        if (v11)
        {
          int v15 = 0;
LABEL_27:
          xmlNextChar(v1);
          return v15;
        }
LABEL_26:
        int v15 = xmlStrndup(&input->base[v6], v12);
        goto LABEL_27;
      }
    }
    long long v9 = "Unfinished PubidLiteral\n";
    ctxt = v1;
    int v10 = 44;
    goto LABEL_23;
  }
  return 0;
}

uint64_t htmlParseLookupSequence(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 56);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  int v5 = *(xmlChar **)(v4 + 24);
  LODWORD(v6) = *(void *)(v4 + 32) - v5;
  if ((v6 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(a1 + 320) <= (uint64_t)v6)
  {
    int v11 = 0;
  }
  else
  {
    int v11 = *(_DWORD *)(a1 + 144) & 1;
    uint64_t v6 = *(void *)(a1 + 320);
  }
  if (*(void *)v4)
  {
    int v5 = xmlBufContent(*(const xmlBuf **)(*(void *)v4 + 32));
    int v12 = xmlBufUse(*(const xmlBufPtr *)(*(void *)v4 + 32));
  }
  else
  {
    int v12 = *(_DWORD *)(v4 + 48);
  }
  LODWORD(v1xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = v12 - (a3 != 0);
  if ((int)v6 >= (int)v13)
  {
    uint64_t v13 = (int)v6;
LABEL_26:
    *(void *)(a1 + 320) = v13;
    int v19 = *(_DWORD *)(a1 + 144);
    if (v11) {
      unsigned int v20 = v19 | 1;
    }
    else {
      unsigned int v20 = v19 & 0xFFFFFFFE;
    }
    *(_DWORD *)(a1 + 144) = v20;
    return 0xFFFFFFFFLL;
  }
  char v14 = 0;
  uint64_t v13 = (int)v13;
  int v15 = -(int)v6;
  BOOL v16 = &v5[(int)v6 + 1];
  unint64_t v17 = v12 - (unint64_t)(a3 != 0) - (int)v6;
  while (1)
  {
    int v18 = *(v16 - 1);
    if (!a4) {
      break;
    }
    if (v18 == 39 || v18 == 34)
    {
      if (v11)
      {
        if (v18 != v14) {
          break;
        }
        int v11 = 0;
      }
      else
      {
        int v11 = 1;
        char v14 = *(v16 - 1);
      }
    }
    else
    {
      if (!v11) {
        break;
      }
      int v11 = 1;
    }
LABEL_23:
    ++v16;
    --v15;
    if (!--v17) {
      goto LABEL_26;
    }
  }
  if (v18 != a2 || a3 && *v16 != a3) {
    goto LABEL_23;
  }
  *(void *)(a1 + 320) = 0;
  return (*(_DWORD *)(v4 + 24) - *(_DWORD *)(v4 + 32) - v15);
}

uint64_t htmlParseLookupCommentEnd(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v4 = *(void *)(v2 + 24);
  uint64_t v3 = *(void *)(v2 + 32);
  uint64_t result = htmlParseLookupSequence(a1, 45, 45, 0);
  if ((result & 0x80000000) == 0)
  {
    int v6 = v3 - v4 + 1;
    do
    {
      uint64_t v7 = *(void *)(*(void *)(a1 + 56) + 32) + result;
      int v8 = *(unsigned __int8 *)(v7 + 2);
      if (v8 == 33)
      {
        if (*(unsigned char *)(v7 + 3) == 62) {
          return result;
        }
      }
      else if (v8 == 62)
      {
        return result;
      }
      *(void *)(a1 + 320) = v6 + (int)result;
      uint64_t result = htmlParseLookupSequence(a1, 45, 45, 0);
    }
    while ((result & 0x80000000) == 0);
  }
  return result;
}

const xmlChar *__cdecl htmlGetMetaEncoding(const xmlChar *doc)
{
  if (!doc) {
    return doc;
  }
  uint64_t v1 = *((void *)doc + 3);
  if (!v1) {
    return 0;
  }
  while (1)
  {
    if (*(_DWORD *)(v1 + 8) != 1) {
      goto LABEL_8;
    }
    uint64_t v2 = *(const xmlChar **)(v1 + 16);
    if (!v2) {
      goto LABEL_8;
    }
    if (xmlStrEqual(v2, (const xmlChar *)"html"))
    {
      uint64_t v1 = *(void *)(v1 + 24);
      if (v1)
      {
        while (1)
        {
          if (*(_DWORD *)(v1 + 8) == 1)
          {
            uint64_t v3 = *(const xmlChar **)(v1 + 16);
            if (v3)
            {
              if (xmlStrEqual(v3, (const xmlChar *)"head")) {
                goto LABEL_17;
              }
              if (xmlStrEqual(*(const xmlChar **)(v1 + 16), (const xmlChar *)"meta")) {
                goto LABEL_18;
              }
            }
          }
          xmlDocPtr doc = 0;
          uint64_t v1 = *(void *)(v1 + 48);
          if (!v1) {
            return doc;
          }
        }
      }
      return 0;
    }
    if (xmlStrEqual(*(const xmlChar **)(v1 + 16), (const xmlChar *)"head"))
    {
LABEL_17:
      uint64_t v1 = *(void *)(v1 + 24);
      if (v1) {
        break;
      }
      return 0;
    }
    if (xmlStrEqual(*(const xmlChar **)(v1 + 16), (const xmlChar *)"meta")) {
      break;
    }
LABEL_8:
    uint64_t v1 = *(void *)(v1 + 48);
    if (!v1) {
      return 0;
    }
  }
LABEL_18:
  while (1)
  {
    if (*(_DWORD *)(v1 + 8) == 1)
    {
      uint64_t v4 = *(const xmlChar **)(v1 + 16);
      if (v4)
      {
        if (xmlStrEqual(v4, (const xmlChar *)"meta"))
        {
          uint64_t v5 = *(void *)(v1 + 88);
          if (v5) {
            break;
          }
        }
      }
    }
LABEL_36:
    uint64_t v1 = *(void *)(v1 + 48);
    if (!v1) {
      return 0;
    }
  }
  int v6 = 0;
  uint64_t v7 = 0;
  while (2)
  {
    uint64_t v8 = *(void *)(v5 + 24);
    if (!v8 || *(_DWORD *)(v8 + 8) != 3 || *(void *)(v8 + 48)) {
      goto LABEL_33;
    }
    long long v9 = *(const xmlChar **)(v8 + 80);
    if (!xmlStrcasecmp(*(const xmlChar **)(v5 + 16), (const xmlChar *)"http-equiv")
      && !xmlStrcasecmp(v9, (const xmlChar *)"Content-Type"))
    {
      int v6 = 1;
      break;
    }
    if (v9 && !xmlStrcasecmp(*(const xmlChar **)(v5 + 16), (const xmlChar *)"content")) {
      uint64_t v7 = v9;
    }
    if (!v6)
    {
LABEL_33:
      uint64_t v5 = *(void *)(v5 + 48);
      if (!v5) {
        goto LABEL_36;
      }
      continue;
    }
    break;
  }
  if (!v7) {
    goto LABEL_33;
  }
  int v10 = xmlStrstr(v7, (const xmlChar *)"charset=");
  if (v10
    || (int v10 = xmlStrstr(v7, (const xmlChar *)"Charset=")) != 0
    || (int v10 = xmlStrstr(v7, (const xmlChar *)"CHARSET=")) != 0)
  {
    xmlDocPtr doc = v10 + 8;
LABEL_48:
    while (1)
    {
      int v11 = *doc;
      if (v11 != 32 && v11 != 9) {
        break;
      }
      ++doc;
    }
  }
  else
  {
    xmlDocPtr doc = xmlStrstr(v7, (const xmlChar *)"charset =");
    if (doc
      || (xmlDocPtr doc = xmlStrstr(v7, (const xmlChar *)"Charset =")) != 0
      || (xmlDocPtr doc = xmlStrstr(v7, (const xmlChar *)"CHARSET =")) != 0)
    {
      doc += 9;
      goto LABEL_48;
    }
  }
  return doc;
}

int htmlSetMetaEncoding(htmlDocPtr doc, const xmlChar *encoding)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  int v23 = 0;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  *(_OWORD *)__str = 0u;
  long long v18 = 0u;
  if (!doc || !xmlStrcasecmp(encoding, (const xmlChar *)"html")) {
    return -1;
  }
  if (encoding)
  {
    snprintf(__str, 0x64uLL, "text/html; charset=%s", (const char *)encoding);
    HIBYTE(v2xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0;
  }
  children = doc->children;
  if (!children) {
    return -1;
  }
  while (1)
  {
    if (children->type == XML_ELEMENT_NODE)
    {
      name = children->name;
      if (name) {
        break;
      }
    }
LABEL_11:
    children = children->next;
    if (!children) {
      return -1;
    }
  }
  if (!xmlStrcasecmp(name, (const xmlChar *)"html"))
  {
    children = children->children;
    if (children)
    {
      while (1)
      {
        if (children->type == XML_ELEMENT_NODE)
        {
          uint64_t v7 = children->name;
          if (v7)
          {
            if (!xmlStrcasecmp(v7, (const xmlChar *)"head")) {
              goto LABEL_21;
            }
            if (!xmlStrcasecmp(children->name, (const xmlChar *)"meta"))
            {
              xmlNodePtr parent = children->parent;
              goto LABEL_27;
            }
          }
        }
        children = children->next;
        int result = -1;
        if (!children) {
          return result;
        }
      }
    }
    return -1;
  }
  if (xmlStrcasecmp(children->name, (const xmlChar *)"head"))
  {
    if (!xmlStrcasecmp(children->name, (const xmlChar *)"meta"))
    {
      xmlNodePtr parent = 0;
      goto LABEL_27;
    }
    goto LABEL_11;
  }
LABEL_21:
  xmlNodePtr parent = children;
  children = children->children;
  if (!children) {
    goto LABEL_22;
  }
LABEL_27:
  while (2)
  {
    if (children->type != XML_ELEMENT_NODE) {
      goto LABEL_30;
    }
    int v11 = children->name;
    if (!v11) {
      goto LABEL_30;
    }
    if (xmlStrcasecmp(v11, (const xmlChar *)"meta")) {
      goto LABEL_30;
    }
    int properties = children->properties;
    if (!properties) {
      goto LABEL_30;
    }
    int v13 = 0;
    char v14 = 0;
    while (2)
    {
      int v15 = properties->children;
      if (!v15 || v15->type != XML_TEXT_NODE || v15->next) {
        goto LABEL_44;
      }
      content = v15->content;
      if (!xmlStrcasecmp(properties->name, (const xmlChar *)"http-equiv")
        && !xmlStrcasecmp(content, (const xmlChar *)"Content-Type"))
      {
        int v13 = 1;
        break;
      }
      if (content && !xmlStrcasecmp(properties->name, (const xmlChar *)"content")) {
        char v14 = content;
      }
      if (!v13)
      {
LABEL_44:
        int properties = properties->next;
        if (!properties) {
          goto LABEL_48;
        }
        continue;
      }
      break;
    }
    if (!v14) {
      goto LABEL_44;
    }
    int v13 = 1;
LABEL_48:
    if (v13 && v14)
    {
      if (encoding)
      {
        if (!xmlStrcasestr(v14, encoding)) {
          xmlSetProp(children, (const xmlChar *)"content", (const xmlChar *)__str);
        }
      }
      else
      {
        xmlUnlinkNode(children);
        xmlFreeNode(children);
      }
      return 0;
    }
LABEL_30:
    children = children->next;
    if (children) {
      continue;
    }
    break;
  }
LABEL_22:
  int result = 0;
  if (encoding && parent)
  {
    long long v9 = xmlNewDocNode(doc, 0, (const xmlChar *)"meta", 0);
    int v10 = parent->children;
    if (v10) {
      xmlAddPrevSibling(v10, v9);
    }
    else {
      xmlAddChild(parent, v9);
    }
    xmlNewProp(v9, (const xmlChar *)"http-equiv", (const xmlChar *)"Content-Type");
    xmlNewProp(v9, (const xmlChar *)"content", (const xmlChar *)__str);
    return 0;
  }
  return result;
}

int htmlIsBooleanAttr(const xmlChar *name)
{
  uint64_t v2 = 0;
  while (xmlStrcasecmp((const xmlChar *)htmlBooleanAttrs[v2], name))
  {
    if (++v2 == 13) {
      return 0;
    }
  }
  return 1;
}

int htmlNodeDump(xmlBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur)
{
  LODWORD(vxmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = -1;
  if (buf && cur)
  {
    xmlInitParser();
    uint64_t v7 = xmlBufFromBuffer((uint32x2_t *)buf);
    if (v7)
    {
      uint64_t v8 = (xmlBuf *)v7;
      long long v9 = (xmlOutputBuffer *)xmlMalloc(0x38uLL);
      if (v9)
      {
        int v10 = v9;
        *(_OWORD *)&v9->closecallbacuint64_t k = 0u;
        *(_OWORD *)&v9->xmlBufPtr buffer = 0u;
        *(void *)&v9->int written = 0;
        *(_OWORD *)&v9->context = 0u;
        v9->xmlBufPtr buffer = v8;
        v9->int written = 0;
        size_t v11 = xmlBufUse(v8);
        htmlNodeDumpFormatOutput(v10, doc, cur, 0, 1);
        xmlFree(v10);
        size_t v3 = xmlBufUse(v8) - v11;
        xmlBufBackToBuffer(v8);
        if ((v3 & 0x80000000) == 0) {
          return v3;
        }
      }
      else
      {
        __xmlSimpleError(7, 2, 0, 0, (uint64_t)"allocating HTML output buffer");
        xmlBufBackToBuffer(v8);
      }
    }
    LODWORD(vxmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = -1;
  }
  return v3;
}

int htmlNodeDumpFileFormat(FILE *out, xmlDocPtr doc, xmlNodePtr cur, const char *encoding, int format)
{
  xmlInitParser();
  if (encoding)
  {
    if (xmlParseCharEncoding(encoding) != XML_CHAR_ENCODING_UTF8)
    {
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler(encoding);
      if (CharEncodingHandler) {
        goto LABEL_8;
      }
      __xmlSimpleError(7, 1403, 0, (uint64_t)"unknown encoding %s\n", (uint64_t)encoding);
    }
    xmlCharEncodingHandlerPtr CharEncodingHandler = 0;
  }
  else
  {
    xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("HTML");
    if (!CharEncodingHandler) {
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("ascii");
    }
  }
LABEL_8:
  htmlDocPtr File = xmlOutputBufferCreateFile(out, CharEncodingHandler);
  if (File)
  {
    int v12 = File;
    htmlNodeDumpFormatOutput(File, doc, cur, 0, format);
    LODWORD(File) = xmlOutputBufferClose(v12);
  }
  return (int)File;
}

void htmlNodeDumpFormatOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur, const char *encoding, int format)
{
  xmlInitParser();
  if (buf && cur)
  {
    xmlNodePtr parent = cur->parent;
    xmlNodePtr children = cur;
LABEL_4:
    while (2)
    {
      int v10 = parent;
      xmlNodePtr parent = children;
      switch(children->type)
      {
        case XML_ELEMENT_NODE:
          if (children->parent != v10 && children->children)
          {
            htmlNodeDumpFormatOutput(buf, doc, children, encoding, format);
            goto LABEL_87;
          }
          if (children->ns) {
            long long v22 = 0;
          }
          else {
            long long v22 = htmlTagLookup(children->name);
          }
          xmlOutputBufferWriteString(buf, "<");
          xmlNsPtr ns = parent->ns;
          if (ns)
          {
            prefix = (const char *)ns->prefix;
            if (prefix)
            {
              xmlOutputBufferWriteString(buf, prefix);
              xmlOutputBufferWriteString(buf, ":");
            }
          }
          int v48 = v22;
          xmlOutputBufferWriteString(buf, (const char *)parent->name);
          nsDef = parent->nsDef;
          if (nsDef) {
            xmlNsListDumpOutput((uint64_t)buf, nsDef);
          }
          for (uint64_t i = (uint64_t)parent->properties; i; uint64_t i = *(void *)(i + 48))
            htmlAttrDumpOutput(buf, doc, i);
          if (!v48)
          {
            p_xmlNodePtr children = &parent->children;
            if (parent->children)
            {
              int v33 = ">";
LABEL_66:
              xmlOutputBufferWriteString(buf, v33);
LABEL_67:
              xmlNodePtr children = *p_children;
              continue;
            }
            goto LABEL_72;
          }
          if (!v48->empty)
          {
            p_xmlNodePtr children = &parent->children;
            if (parent->children)
            {
              xmlOutputBufferWriteString(buf, ">");
              if (!format || v48->isinline) {
                goto LABEL_67;
              }
              xmlElementType type = (*p_children)->type;
              if (type == XML_TEXT_NODE || type == XML_ENTITY_REF_NODE) {
                goto LABEL_67;
              }
              if (*p_children == parent->last) {
                goto LABEL_67;
              }
              name = parent->name;
              if (!name) {
                goto LABEL_67;
              }
              int v33 = "\n";
              if (*name == 112) {
                goto LABEL_67;
              }
              goto LABEL_66;
            }
            if (!v48->saveEndTag
              || !xmlStrcmp((const xmlChar *)v48->name, (const xmlChar *)"html")
              || !xmlStrcmp((const xmlChar *)v48->name, (const xmlChar *)"body"))
            {
LABEL_72:
              xmlOutputBufferWriteString(buf, "></");
              size_t v34 = parent->ns;
              if (v34)
              {
                int v35 = (const char *)v34->prefix;
                if (v35)
                {
                  xmlOutputBufferWriteString(buf, v35);
                  xmlOutputBufferWriteString(buf, ":");
                }
              }
              xmlOutputBufferWriteString(buf, (const char *)parent->name);
            }
          }
          xmlOutputBufferWriteString(buf, ">");
          if (!format) {
            goto LABEL_87;
          }
          if (!v48) {
            goto LABEL_87;
          }
          xmlNodePtr next = parent->next;
          if (!next || v48->isinline) {
            goto LABEL_87;
          }
LABEL_80:
          xmlElementType v37 = next->type;
          if (v37 == XML_TEXT_NODE) {
            goto LABEL_87;
          }
          if (v37 == XML_ENTITY_REF_NODE) {
            goto LABEL_87;
          }
          if (!v10) {
            goto LABEL_87;
          }
          int v38 = v10->name;
          if (!v38 || *v38 == 112) {
            goto LABEL_87;
          }
LABEL_85:
          long long v21 = buf;
          content = "\n";
LABEL_86:
          xmlOutputBufferWriteString(v21, content);
LABEL_87:
          while (parent != cur)
          {
            xmlNodePtr children = parent->next;
            xmlNodePtr parent = v10;
            if (children) {
              goto LABEL_4;
            }
            int v10 = v10->parent;
            if ((parent->type | 4) == 0xD) {
              goto LABEL_85;
            }
            if (format && !parent->ns)
            {
              int v43 = htmlTagLookup(parent->name);
              size_t v40 = v43;
              if (v43)
              {
                if (!v43->isinline)
                {
                  last = parent->last;
                  xmlElementType v45 = last->type;
                  if (v45 != XML_TEXT_NODE && v45 != XML_ENTITY_REF_NODE && parent->children != last)
                  {
                    int v47 = parent->name;
                    if (v47)
                    {
                      if (*v47 != 112) {
                        xmlOutputBufferWriteString(buf, "\n");
                      }
                    }
                  }
                }
                int v39 = 1;
              }
              else
              {
                int v39 = 0;
              }
            }
            else
            {
              int v39 = 0;
              size_t v40 = 0;
            }
            xmlOutputBufferWriteString(buf, "</");
            int v41 = parent->ns;
            if (v41)
            {
              int v42 = (const char *)v41->prefix;
              if (v42)
              {
                xmlOutputBufferWriteString(buf, v42);
                xmlOutputBufferWriteString(buf, ":");
              }
            }
            xmlOutputBufferWriteString(buf, (const char *)parent->name);
            xmlOutputBufferWriteString(buf, ">");
            if (v39)
            {
              if (!v40->isinline)
              {
                xmlNodePtr next = parent->next;
                if (next) {
                  goto LABEL_80;
                }
              }
            }
          }
          break;
        case XML_ATTRIBUTE_NODE:
          htmlAttrDumpOutput(buf, doc, (uint64_t)children);
          goto LABEL_87;
        case XML_TEXT_NODE:
          content = (const char *)children->content;
          if (!content) {
            goto LABEL_87;
          }
          if (children->name == "textnoenc" && "text" != "textnoenc") {
            goto LABEL_25;
          }
          if (!v10) {
            goto LABEL_22;
          }
          if (xmlStrcasecmp(v10->name, (const xmlChar *)"script"))
          {
            int v18 = xmlStrcasecmp(v10->name, (const xmlChar *)"style");
            content = (const char *)parent->content;
            if (v18)
            {
LABEL_22:
              long long v19 = xmlEncodeEntitiesReentrant(doc, (const xmlChar *)content);
              if (v19)
              {
                long long v20 = v19;
                xmlOutputBufferWriteString(buf, (const char *)v19);
                xmlFree(v20);
              }
              goto LABEL_87;
            }
          }
          else
          {
            content = (const char *)parent->content;
          }
LABEL_25:
          long long v21 = buf;
          goto LABEL_86;
        case XML_CDATA_SECTION_NODE:
          content = (const char *)children->content;
          if (content) {
            goto LABEL_25;
          }
          goto LABEL_87;
        case XML_ENTITY_REF_NODE:
          xmlOutputBufferWriteString(buf, "&");
          xmlOutputBufferWriteString(buf, (const char *)parent->name);
          long long v21 = buf;
          content = ";";
          goto LABEL_86;
        case XML_PI_NODE:
          if (!children->name) {
            goto LABEL_87;
          }
          xmlOutputBufferWriteString(buf, "<?");
          xmlOutputBufferWriteString(buf, (const char *)parent->name);
          if (parent->content)
          {
            xmlOutputBufferWriteString(buf, " ");
            xmlOutputBufferWriteString(buf, (const char *)parent->content);
          }
          long long v21 = buf;
          content = ">";
          goto LABEL_86;
        case XML_COMMENT_NODE:
          if (!children->content) {
            goto LABEL_87;
          }
          xmlOutputBufferWriteString(buf, "<!--");
          xmlOutputBufferWriteString(buf, (const char *)parent->content);
          long long v21 = buf;
          content = "-->";
          goto LABEL_86;
        case XML_DOCUMENT_NODE:
        case XML_HTML_DOCUMENT_NODE:
          size_t v11 = children->content;
          if (!v11) {
            goto LABEL_40;
          }
          xmlOutputBufferWriteString(buf, "<!DOCTYPE ");
          xmlOutputBufferWriteString(buf, *((const char **)v11 + 2));
          if (*((void *)v11 + 13))
          {
            xmlOutputBufferWriteString(buf, " PUBLIC ");
            xmlBufWriteQuotedString((uint64x2_t *)buf->buffer, *((xmlChar **)v11 + 13));
            uint64_t v13 = *((void *)v11 + 14);
            int v12 = (xmlChar **)(v11 + 112);
            if (!v13) {
              goto LABEL_39;
            }
            char v14 = buf;
            int v15 = " ";
            goto LABEL_38;
          }
          uint64_t v24 = (const xmlChar *)*((void *)v11 + 14);
          int v12 = (xmlChar **)(v11 + 112);
          int v23 = v24;
          if (v24 && xmlStrcmp(v23, (const xmlChar *)"about:legacy-compat"))
          {
            char v14 = buf;
            int v15 = " SYSTEM ";
LABEL_38:
            xmlOutputBufferWriteString(v14, v15);
            xmlBufWriteQuotedString((uint64x2_t *)buf->buffer, *v12);
          }
LABEL_39:
          xmlOutputBufferWriteString(buf, ">\n");
LABEL_40:
          xmlNodePtr children = parent->children;
          if (!children) {
            goto LABEL_85;
          }
          if (parent->parent != v10) {
            goto LABEL_87;
          }
          continue;
        default:
          goto LABEL_87;
      }
      break;
    }
  }
}

void htmlNodeDumpFile(FILE *out, xmlDocPtr doc, xmlNodePtr cur)
{
}

void htmlDocDumpMemoryFormat(xmlDocPtr cur, xmlChar **mem, int *size, int format)
{
  xmlInitParser();
  if (!mem || !size) {
    return;
  }
  if (!cur)
  {
LABEL_17:
    *mem = 0;
    *unsigned int size = 0;
    return;
  }
  MetaEncoding = (const char *)htmlGetMetaEncoding(cur);
  if (MetaEncoding)
  {
    long long v9 = MetaEncoding;
    if (xmlParseCharEncoding(MetaEncoding) != XML_CHAR_ENCODING_UTF8)
    {
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler(v9);
      if (CharEncodingHandler) {
        goto LABEL_11;
      }
      __xmlSimpleError(7, 1403, 0, (uint64_t)"unknown encoding %s\n", (uint64_t)v9);
    }
    xmlCharEncodingHandlerPtr CharEncodingHandler = 0;
  }
  else
  {
    xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("HTML");
    if (!CharEncodingHandler) {
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("ascii");
    }
  }
LABEL_11:
  size_t v11 = (xmlOutputBuffer *)xmlAllocOutputBufferInternal((uint64_t)CharEncodingHandler);
  if (!v11) {
    goto LABEL_17;
  }
  int v12 = v11;
  xmlElementType type = cur->type;
  cur->xmlElementType type = XML_HTML_DOCUMENT_NODE;
  htmlNodeDumpFormatOutput(v11, cur, (xmlNodePtr)cur, 0, format);
  cur->xmlElementType type = type;
  xmlOutputBufferFlush(v12);
  p_xmlBufPtr conv = &v12->conv;
  xmlBufPtr conv = v12->conv;
  if (!conv)
  {
    p_xmlBufPtr conv = &v12->buffer;
    xmlBufPtr conv = v12->buffer;
  }
  *unsigned int size = xmlBufUse(conv);
  BOOL v16 = xmlBufContent(*p_conv);
  *mem = xmlStrndup(v16, *size);

  xmlOutputBufferClose(v12);
}

void htmlDocContentDumpFormatOutput(xmlOutputBufferPtr buf, xmlDocPtr cur, const char *encoding, int format)
{
  if (cur)
  {
    xmlElementType type = cur->type;
    cur->xmlElementType type = XML_HTML_DOCUMENT_NODE;
    htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, format);
    cur->xmlElementType type = type;
  }
  else
  {
    htmlNodeDumpFormatOutput(buf, 0, 0, 0, format);
  }
}

void htmlDocDumpMemory(xmlDocPtr cur, xmlChar **mem, int *size)
{
}

xmlOutputBuffer *htmlAttrDumpOutput(xmlOutputBuffer *result, xmlDoc *a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v5 = result;
    xmlOutputBufferWriteString(result, " ");
    uint64_t v6 = *(void *)(a3 + 72);
    if (v6)
    {
      uint64_t v7 = *(const char **)(v6 + 24);
      if (v7)
      {
        xmlOutputBufferWriteString(v5, v7);
        xmlOutputBufferWriteString(v5, ":");
      }
    }
    int result = (xmlOutputBuffer *)xmlOutputBufferWriteString(v5, *(const char **)(a3 + 16));
    if (*(void *)(a3 + 24))
    {
      uint64_t v8 = 0;
      long long v9 = *(const xmlChar **)(a3 + 16);
      do
      {
        int result = (xmlOutputBuffer *)xmlStrcasecmp((const xmlChar *)htmlBooleanAttrs[v8], v9);
        if (!result) {
          return result;
        }
        ++v8;
      }
      while (v8 != 13);
      String = xmlNodeListGetString(a2, *(const xmlNode **)(a3 + 24), 0);
      if (String)
      {
        size_t v11 = String;
        xmlOutputBufferWriteString(v5, "=");
        if (*(void *)(a3 + 72)
          || (uint64_t v14 = *(void *)(a3 + 40)) == 0
          || *(void *)(v14 + 72)
          || xmlStrcasecmp(*(const xmlChar **)(a3 + 16), (const xmlChar *)"href")
          && xmlStrcasecmp(*(const xmlChar **)(a3 + 16), (const xmlChar *)"action")
          && xmlStrcasecmp(*(const xmlChar **)(a3 + 16), (const xmlChar *)"src")
          && (xmlStrcasecmp(*(const xmlChar **)(a3 + 16), (const xmlChar *)"name")
           || xmlStrcasecmp(*(const xmlChar **)(*(void *)(a3 + 40) + 16), (const xmlChar *)"a")))
        {
          xmlBufPtr buffer = (uint64x2_t *)v5->buffer;
        }
        else
        {
          for (uint64_t i = v11; ; ++i)
          {
            unsigned int v16 = *i;
            BOOL v17 = v16 > 0x20;
            uint64_t v18 = (1 << v16) & 0x100002600;
            if (v17 || v18 == 0) {
              break;
            }
          }
          long long v20 = xmlURIEscapeStr(i, (const xmlChar *)"@/:=?;#%&,+<>");
          xmlBufPtr buffer = (uint64x2_t *)v5->buffer;
          if (v20)
          {
            xmlBufWriteQuotedString(buffer, v20);
            xmlFree(v20);
            goto LABEL_13;
          }
        }
        xmlBufWriteQuotedString(buffer, v11);
LABEL_13:
        xmlFreeFunc v13 = xmlFree;
        return (xmlOutputBuffer *)((uint64_t (*)(xmlChar *))v13)(v11);
      }
      return (xmlOutputBuffer *)xmlOutputBufferWriteString(v5, "=\"\"");
    }
  }
  return result;
}

void htmlNodeDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur, const char *encoding)
{
}

void htmlDocContentDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr cur, const char *encoding)
{
}

int htmlDocDump(FILE *f, xmlDocPtr cur)
{
  xmlInitParser();
  if (!f || !cur) {
    return -1;
  }
  MetaEncoding = (const char *)htmlGetMetaEncoding(cur);
  if (MetaEncoding)
  {
    uint64_t v5 = MetaEncoding;
    if (xmlParseCharEncoding(MetaEncoding) != XML_CHAR_ENCODING_UTF8)
    {
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler(v5);
      if (CharEncodingHandler) {
        goto LABEL_10;
      }
      __xmlSimpleError(7, 1403, 0, (uint64_t)"unknown encoding %s\n", (uint64_t)v5);
    }
    xmlCharEncodingHandlerPtr CharEncodingHandler = 0;
  }
  else
  {
    xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("HTML");
    if (!CharEncodingHandler) {
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("ascii");
    }
  }
LABEL_10:
  htmlDocPtr File = xmlOutputBufferCreateFile(f, CharEncodingHandler);
  if (!File) {
    return -1;
  }
  uint64_t v8 = File;
  htmlNodeDumpFormatOutput(File, cur, (xmlNodePtr)cur, 0, 1);

  return xmlOutputBufferClose(v8);
}

int htmlSaveFile(const char *filename, xmlDocPtr cur)
{
  uint64_t v2 = filename;
  LODWORD(filename) = -1;
  if (!v2 || !cur) {
    return (int)filename;
  }
  xmlInitParser();
  MetaEncoding = (const char *)htmlGetMetaEncoding(cur);
  if (!MetaEncoding)
  {
    xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("HTML");
    if (!CharEncodingHandler) {
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("ascii");
    }
    goto LABEL_10;
  }
  uint64_t v5 = MetaEncoding;
  if (xmlParseCharEncoding(MetaEncoding) != XML_CHAR_ENCODING_UTF8)
  {
    xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler(v5);
    if (CharEncodingHandler) {
      goto LABEL_10;
    }
    __xmlSimpleError(7, 1403, 0, (uint64_t)"unknown encoding %s\n", (uint64_t)v5);
  }
  xmlCharEncodingHandlerPtr CharEncodingHandler = 0;
LABEL_10:
  filename = (const char *)xmlOutputBufferCreateFilename(v2, CharEncodingHandler, cur->compression);
  if (filename)
  {
    uint64_t v7 = (xmlOutputBuffer *)filename;
    htmlNodeDumpFormatOutput((xmlOutputBufferPtr)filename, cur, (xmlNodePtr)cur, 0, 1);
    LODWORD(filename) = xmlOutputBufferClose(v7);
  }
  return (int)filename;
}

int htmlSaveFileFormat(const char *filename, xmlDocPtr cur, const char *encoding, int format)
{
  uint64_t v4 = filename;
  LODWORD(filename) = -1;
  if (v4 && cur)
  {
    xmlInitParser();
    if (encoding)
    {
      if (xmlParseCharEncoding(encoding) == XML_CHAR_ENCODING_UTF8)
      {
        xmlCharEncodingHandlerPtr CharEncodingHandler = 0;
      }
      else
      {
        xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler(encoding);
        if (!CharEncodingHandler) {
          __xmlSimpleError(7, 1403, 0, (uint64_t)"unknown encoding %s\n", (uint64_t)encoding);
        }
      }
      htmlSetMetaEncoding(cur, (const xmlChar *)encoding);
    }
    else
    {
      htmlSetMetaEncoding(cur, (const xmlChar *)"UTF-8");
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("HTML");
      if (!CharEncodingHandler) {
        xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("ascii");
      }
    }
    filename = (const char *)xmlOutputBufferCreateFilename(v4, CharEncodingHandler, 0);
    if (filename)
    {
      int v10 = (xmlOutputBuffer *)filename;
      htmlDocContentDumpFormatOutput((xmlOutputBufferPtr)filename, cur, v9, format);
      LODWORD(filename) = xmlOutputBufferClose(v10);
    }
  }
  return (int)filename;
}

int htmlSaveFileEnc(const char *filename, xmlDocPtr cur, const char *encoding)
{
  return htmlSaveFileFormat(filename, cur, encoding, 1);
}

int xmlGetFeaturesList(int *len, const char **result)
{
  int v3 = 42;
  if (len && result)
  {
    unsigned int v4 = *len;
    if (*len > 0x3E7) {
      return -1;
    }
    if (v4 < 0x2B)
    {
      if (!v4) {
        return 42;
      }
    }
    else
    {
      unsigned int v4 = 42;
      *int len = 42;
    }
    memcpy(result, xmlFeaturesList, 8 * v4);
    return 42;
  }
  return v3;
}

int xmlGetFeature(xmlParserCtxtPtr ctxt, const char *name, void *result)
{
  int v4 = -1;
  if (ctxt && name && result)
  {
    int v4 = strcmp(name, "validate");
    if (v4)
    {
      int v4 = strcmp(name, "keep blanks");
      if (v4)
      {
        int v4 = strcmp(name, "disable SAX");
        if (v4)
        {
          int v4 = strcmp(name, "fetch external entities");
          if (v4)
          {
            int v4 = strcmp(name, "substitute entities");
            if (v4)
            {
              int v4 = strcmp(name, "gather line info");
              if (v4)
              {
                int v4 = strcmp(name, "user data");
                if (!v4)
                {
                  userData = ctxt->userData;
                  goto LABEL_52;
                }
                int v4 = strcmp(name, "is html");
                if (v4)
                {
                  int v4 = strcmp(name, "is standalone");
                  if (v4)
                  {
                    int v4 = strcmp(name, "document");
                    if (v4)
                    {
                      int v4 = strcmp(name, "is well formed");
                      if (v4)
                      {
                        int v4 = strcmp(name, "is valid");
                        if (v4)
                        {
                          int v4 = strcmp(name, "SAX block");
                          if (v4)
                          {
                            int v4 = strcmp(name, "SAX function internalSubset");
                            if (v4)
                            {
                              int v4 = strcmp(name, "SAX function isStandalone");
                              if (v4)
                              {
                                int v4 = strcmp(name, "SAX function hasInternalSubset");
                                if (v4)
                                {
                                  int v4 = strcmp(name, "SAX function hasExternalSubset");
                                  if (v4)
                                  {
                                    int v4 = strcmp(name, "SAX function resolveEntity");
                                    if (v4)
                                    {
                                      int v4 = strcmp(name, "SAX function getEntity");
                                      if (v4)
                                      {
                                        int v4 = strcmp(name, "SAX function entityDecl");
                                        if (v4)
                                        {
                                          int v4 = strcmp(name, "SAX function notationDecl");
                                          if (v4)
                                          {
                                            int v4 = strcmp(name, "SAX function attributeDecl");
                                            if (v4)
                                            {
                                              int v4 = strcmp(name, "SAX function elementDecl");
                                              if (v4)
                                              {
                                                int v4 = strcmp(name, "SAX function unparsedEntityDecl");
                                                if (v4)
                                                {
                                                  int v4 = strcmp(name, "SAX function setDocumentLocator");
                                                  if (v4)
                                                  {
                                                    int v4 = strcmp(name, "SAX function startDocument");
                                                    if (v4)
                                                    {
                                                      int v4 = strcmp(name, "SAX function endDocument");
                                                      if (v4)
                                                      {
                                                        int v4 = strcmp(name, "SAX function startElement");
                                                        if (v4)
                                                        {
                                                          int v4 = strcmp(name, "SAX function endElement");
                                                          if (v4)
                                                          {
                                                            int v4 = strcmp(name, "SAX function reference");
                                                            if (v4)
                                                            {
                                                              int v4 = strcmp(name, "SAX function characters");
                                                              if (v4)
                                                              {
                                                                int v4 = strcmp(name, "SAX function ignorableWhitespace");
                                                                if (v4)
                                                                {
                                                                  int v4 = strcmp(name, "SAX function processingInstruction");
                                                                  if (v4)
                                                                  {
                                                                    int v4 = strcmp(name, "SAX function comment");
                                                                    if (v4)
                                                                    {
                                                                      int v4 = strcmp(name, "SAX function warning");
                                                                      if (v4)
                                                                      {
                                                                        int v4 = strcmp(name, "SAX function error");
                                                                        if (v4)
                                                                        {
                                                                          int v4 = strcmp(name, "SAX function fatalError");
                                                                          if (v4)
                                                                          {
                                                                            int v4 = strcmp(name, "SAX function getParameterEntity");
                                                                            if (v4)
                                                                            {
                                                                              int v4 = strcmp(name, "SAX function cdataBlock");
                                                                              if (v4)
                                                                              {
                                                                                int v4 = strcmp(name, "SAX function externalSubset");
                                                                                if (v4) {
                                                                                  return -1;
                                                                                }
                                                                                userData = ctxt->sax->externalSubset;
                                                                              }
                                                                              else
                                                                              {
                                                                                userData = ctxt->sax->cdataBlock;
                                                                              }
                                                                            }
                                                                            else
                                                                            {
                                                                              userData = ctxt->sax->getParameterEntity;
                                                                            }
                                                                          }
                                                                          else
                                                                          {
                                                                            userData = ctxt->sax->fatalError;
                                                                          }
                                                                        }
                                                                        else
                                                                        {
                                                                          userData = ctxt->sax->error;
                                                                        }
                                                                      }
                                                                      else
                                                                      {
                                                                        userData = ctxt->sax->warning;
                                                                      }
                                                                    }
                                                                    else
                                                                    {
                                                                      userData = ctxt->sax->comment;
                                                                    }
                                                                  }
                                                                  else
                                                                  {
                                                                    userData = ctxt->sax->processingInstruction;
                                                                  }
                                                                }
                                                                else
                                                                {
                                                                  userData = ctxt->sax->ignorableWhitespace;
                                                                }
                                                              }
                                                              else
                                                              {
                                                                userData = ctxt->sax->characters;
                                                              }
                                                            }
                                                            else
                                                            {
                                                              userData = ctxt->sax->reference;
                                                            }
                                                          }
                                                          else
                                                          {
                                                            userData = ctxt->sax->endElement;
                                                          }
                                                        }
                                                        else
                                                        {
                                                          userData = ctxt->sax->startElement;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        userData = ctxt->sax->endDocument;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      userData = ctxt->sax->startDocument;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    userData = ctxt->sax->setDocumentLocator;
                                                  }
                                                }
                                                else
                                                {
                                                  userData = ctxt->sax->unparsedEntityDecl;
                                                }
                                              }
                                              else
                                              {
                                                userData = ctxt->sax->elementDecl;
                                              }
                                            }
                                            else
                                            {
                                              userData = ctxt->sax->attributeDecl;
                                            }
                                          }
                                          else
                                          {
                                            userData = ctxt->sax->notationDecl;
                                          }
                                        }
                                        else
                                        {
                                          userData = ctxt->sax->entityDecl;
                                        }
                                      }
                                      else
                                      {
                                        userData = ctxt->sax->getEntity;
                                      }
                                    }
                                    else
                                    {
                                      userData = ctxt->sax->resolveEntity;
                                    }
                                  }
                                  else
                                  {
                                    userData = ctxt->sax->hasExternalSubset;
                                  }
                                }
                                else
                                {
                                  userData = ctxt->sax->hasInternalSubset;
                                }
                              }
                              else
                              {
                                userData = ctxt->sax->isStandalone;
                              }
                            }
                            else
                            {
                              userData = ctxt->sax->internalSubset;
                            }
                          }
                          else
                          {
                            userData = ctxt->sax;
                          }
                          goto LABEL_52;
                        }
                        valint id = ctxt->valid;
                      }
                      else
                      {
                        valint id = ctxt->wellFormed;
                      }
                      goto LABEL_58;
                    }
                    userData = ctxt->myDoc;
LABEL_52:
                    *(void *)int result = userData;
                    return v4;
                  }
                  valint id = ctxt->standalone;
                }
                else
                {
                  valint id = ctxt->html;
                }
              }
              else
              {
                valint id = ctxt->record_info;
              }
            }
            else
            {
              valint id = ctxt->replaceEntities;
            }
          }
          else
          {
            valint id = ctxt->loadsubset;
          }
        }
        else
        {
          valint id = ctxt->disableSAX;
        }
      }
      else
      {
        valint id = ctxt->keepBlanks;
      }
    }
    else
    {
      valint id = ctxt->validate;
    }
LABEL_58:
    *(_DWORD *)int result = valid;
  }
  return v4;
}

int xmlSetFeature(xmlParserCtxtPtr ctxt, const char *name, void *value)
{
  int result = -1;
  if (ctxt && name && value)
  {
    if (!strcmp(name, "validate"))
    {
      int v7 = *(_DWORD *)value;
      if (!ctxt->validate && v7)
      {
        if (!ctxt->vctxt.warning) {
          ctxt->vctxt.warning = xmlParserValidityWarning;
        }
        if (!ctxt->vctxt.error) {
          ctxt->vctxt.error = xmlParserValidityError;
        }
        ctxt->vctxt.uint64_t nodeMax = 0;
      }
      int result = 0;
      ctxt->validate = v7;
    }
    else
    {
      int result = strcmp(name, "keep blanks");
      if (result)
      {
        int result = strcmp(name, "disable SAX");
        if (result)
        {
          int result = strcmp(name, "fetch external entities");
          if (result)
          {
            int result = strcmp(name, "substitute entities");
            if (result)
            {
              int result = strcmp(name, "gather line info");
              if (result)
              {
                int result = strcmp(name, "user data");
                if (result)
                {
                  int result = strcmp(name, "is html");
                  if (result)
                  {
                    int result = strcmp(name, "is standalone");
                    if (result)
                    {
                      int result = strcmp(name, "document");
                      if (result)
                      {
                        int result = strcmp(name, "is well formed");
                        if (result)
                        {
                          int result = strcmp(name, "is valid");
                          if (result)
                          {
                            int result = strcmp(name, "SAX block");
                            if (result)
                            {
                              int result = strcmp(name, "SAX function internalSubset");
                              if (result)
                              {
                                int result = strcmp(name, "SAX function isStandalone");
                                if (result)
                                {
                                  int result = strcmp(name, "SAX function hasInternalSubset");
                                  if (result)
                                  {
                                    int result = strcmp(name, "SAX function hasExternalSubset");
                                    if (result)
                                    {
                                      int result = strcmp(name, "SAX function resolveEntity");
                                      if (result)
                                      {
                                        int result = strcmp(name, "SAX function getEntity");
                                        if (result)
                                        {
                                          int result = strcmp(name, "SAX function entityDecl");
                                          if (result)
                                          {
                                            int result = strcmp(name, "SAX function notationDecl");
                                            if (result)
                                            {
                                              int result = strcmp(name, "SAX function attributeDecl");
                                              if (result)
                                              {
                                                int result = strcmp(name, "SAX function elementDecl");
                                                if (result)
                                                {
                                                  int result = strcmp(name, "SAX function unparsedEntityDecl");
                                                  if (result)
                                                  {
                                                    int result = strcmp(name, "SAX function setDocumentLocator");
                                                    if (result)
                                                    {
                                                      int result = strcmp(name, "SAX function startDocument");
                                                      if (result)
                                                      {
                                                        int result = strcmp(name, "SAX function endDocument");
                                                        if (result)
                                                        {
                                                          int result = strcmp(name, "SAX function startElement");
                                                          if (result)
                                                          {
                                                            int result = strcmp(name, "SAX function endElement");
                                                            if (result)
                                                            {
                                                              int result = strcmp(name, "SAX function reference");
                                                              if (result)
                                                              {
                                                                int result = strcmp(name, "SAX function characters");
                                                                if (result)
                                                                {
                                                                  int result = strcmp(name, "SAX function ignorableWhitespace");
                                                                  if (result)
                                                                  {
                                                                    int result = strcmp(name, "SAX function processingInstruction");
                                                                    if (result)
                                                                    {
                                                                      int result = strcmp(name, "SAX function comment");
                                                                      if (result)
                                                                      {
                                                                        int result = strcmp(name, "SAX function warning");
                                                                        if (result)
                                                                        {
                                                                          int result = strcmp(name, "SAX function error");
                                                                          if (result)
                                                                          {
                                                                            int result = strcmp(name, "SAX function fatalError");
                                                                            if (result)
                                                                            {
                                                                              int result = strcmp(name, "SAX function getParameterEntity");
                                                                              if (result)
                                                                              {
                                                                                int result = strcmp(name, "SAX function cdataBlock");
                                                                                if (result)
                                                                                {
                                                                                  int result = strcmp(name, "SAX function externalSubset");
                                                                                  if (result) {
                                                                                    return -1;
                                                                                  }
                                                                                  else {
                                                                                    ctxt->sax->externalSubsetSAXFunc externalSubset = *(externalSubsetSAXFunc *)value;
                                                                                  }
                                                                                }
                                                                                else
                                                                                {
                                                                                  ctxt->sax->cdataBlocuint64_t k = *(cdataBlockSAXFunc *)value;
                                                                                }
                                                                              }
                                                                              else
                                                                              {
                                                                                ctxt->sax->getParameterEntity = *(getParameterEntitySAXFunc *)value;
                                                                              }
                                                                            }
                                                                            else
                                                                            {
                                                                              ctxt->sax->fatalError = *(fatalErrorSAXFunc *)value;
                                                                            }
                                                                          }
                                                                          else
                                                                          {
                                                                            ctxt->sax->error = *(errorSAXFunc *)value;
                                                                          }
                                                                        }
                                                                        else
                                                                        {
                                                                          ctxt->sax->warning = *(warningSAXFunc *)value;
                                                                        }
                                                                      }
                                                                      else
                                                                      {
                                                                        ctxt->sax->comment = *(commentSAXFunc *)value;
                                                                      }
                                                                    }
                                                                    else
                                                                    {
                                                                      ctxt->sax->processingInstruction = *(processingInstructionSAXFunc *)value;
                                                                    }
                                                                  }
                                                                  else
                                                                  {
                                                                    ctxt->sax->ignorableWhitespace = *(ignorableWhitespaceSAXFunc *)value;
                                                                  }
                                                                }
                                                                else
                                                                {
                                                                  ctxt->sax->characters = *(charactersSAXFunc *)value;
                                                                }
                                                              }
                                                              else
                                                              {
                                                                ctxt->sax->reference = *(referenceSAXFunc *)value;
                                                              }
                                                            }
                                                            else
                                                            {
                                                              ctxt->sax->endElementSAXFunc endElement = *(endElementSAXFunc *)value;
                                                            }
                                                          }
                                                          else
                                                          {
                                                            ctxt->sax->startElementSAXFunc startElement = *(startElementSAXFunc *)value;
                                                          }
                                                        }
                                                        else
                                                        {
                                                          ctxt->sax->endDocumentSAXFunc endDocument = *(endDocumentSAXFunc *)value;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        ctxt->sax->startDocumentSAXFunc startDocument = *(startDocumentSAXFunc *)value;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      ctxt->sax->setDocumentLocatorSAXFunc setDocumentLocator = *(setDocumentLocatorSAXFunc *)value;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    ctxt->sax->unparsedEntityDecl = *(unparsedEntityDeclSAXFunc *)value;
                                                  }
                                                }
                                                else
                                                {
                                                  ctxt->sax->elementDecl = *(elementDeclSAXFunc *)value;
                                                }
                                              }
                                              else
                                              {
                                                ctxt->sax->attributeDecl = *(attributeDeclSAXFunc *)value;
                                              }
                                            }
                                            else
                                            {
                                              ctxt->sax->notationDecl = *(notationDeclSAXFunc *)value;
                                            }
                                          }
                                          else
                                          {
                                            ctxt->sax->entityDecl = *(entityDeclSAXFunc *)value;
                                          }
                                        }
                                        else
                                        {
                                          ctxt->sax->getEntity = *(getEntitySAXFunc *)value;
                                        }
                                      }
                                      else
                                      {
                                        ctxt->sax->resolveEntity = *(resolveEntitySAXFunc *)value;
                                      }
                                    }
                                    else
                                    {
                                      ctxt->sax->hasExternalSubset = *(hasExternalSubsetSAXFunc *)value;
                                    }
                                  }
                                  else
                                  {
                                    ctxt->sax->hasInternalSubset = *(hasInternalSubsetSAXFunc *)value;
                                  }
                                }
                                else
                                {
                                  ctxt->sax->isStandalone = *(isStandaloneSAXFunc *)value;
                                }
                              }
                              else
                              {
                                ctxt->sax->internalSubset = *(internalSubsetSAXFunc *)value;
                              }
                            }
                            else
                            {
                              ctxt->sax = *(_xmlSAXHandler **)value;
                            }
                          }
                          else
                          {
                            ctxt->valint id = *(_DWORD *)value;
                          }
                        }
                        else
                        {
                          ctxt->wellFormed = *(_DWORD *)value;
                        }
                      }
                      else
                      {
                        ctxt->xmlDocPtr myDoc = *(xmlDocPtr *)value;
                      }
                    }
                    else
                    {
                      ctxt->standalone = *(_DWORD *)value;
                    }
                  }
                  else
                  {
                    ctxt->html = *(_DWORD *)value;
                  }
                }
                else
                {
                  ctxt->userData = *(void **)value;
                }
              }
              else
              {
                ctxt->record_xmlParserNodeInfo info = *(_DWORD *)value;
              }
            }
            else
            {
              ctxt->replaceEntities = *(_DWORD *)value;
            }
          }
          else
          {
            ctxt->loadsubset = *(_DWORD *)value;
          }
        }
        else
        {
          ctxt->disableSAX = *(_DWORD *)value;
        }
      }
      else
      {
        ctxt->keepBlanks = *(_DWORD *)value;
      }
    }
  }
  return result;
}

xmlChar *__cdecl xmlDecodeEntities(xmlParserCtxtPtr ctxt, int len, int what, xmlChar end, xmlChar end2, xmlChar end3)
{
  if ((xmlDecodeEntities_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v6 = *__xmlGenericError();
    int v7 = __xmlGenericErrorContext();
    v6(*v7, "xmlDecodeEntities() deprecated function reached\n");
    xmlDecodeEntities_deprecated = 1;
  }
  return 0;
}

xmlChar *__cdecl xmlNamespaceParseNCName(xmlParserCtxtPtr ctxt)
{
  if ((xmlNamespaceParseNCName_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v1 = *__xmlGenericError();
    uint64_t v2 = __xmlGenericErrorContext();
    v1(*v2, "xmlNamespaceParseNCName() deprecated function reached\n");
    xmlNamespaceParseNCName_deprecated = 1;
  }
  return 0;
}

xmlChar *__cdecl xmlNamespaceParseQName(xmlParserCtxtPtr ctxt, xmlChar **prefix)
{
  if ((xmlNamespaceParseQName_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    int v3 = __xmlGenericErrorContext();
    v2(*v3, "xmlNamespaceParseQName() deprecated function reached\n");
    xmlNamespaceParseQName_deprecated = 1;
  }
  return 0;
}

xmlChar *__cdecl xmlNamespaceParseNSDef(xmlParserCtxtPtr ctxt)
{
  if ((xmlNamespaceParseNSDef_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v1 = *__xmlGenericError();
    xmlGenericErrorFunc v2 = __xmlGenericErrorContext();
    v1(*v2, "xmlNamespaceParseNSDef() deprecated function reached\n");
    xmlNamespaceParseNSDef_deprecated = 1;
  }
  return 0;
}

xmlChar *__cdecl xmlParseQuotedString(xmlParserCtxtPtr ctxt)
{
  if ((xmlParseQuotedString_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v1 = *__xmlGenericError();
    xmlGenericErrorFunc v2 = __xmlGenericErrorContext();
    v1(*v2, "xmlParseQuotedString() deprecated function reached\n");
    xmlParseQuotedString_deprecated = 1;
  }
  return 0;
}

void xmlParseNamespace(xmlParserCtxtPtr ctxt)
{
  if ((xmlParseNamespace_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v1 = *__xmlGenericError();
    xmlGenericErrorFunc v2 = __xmlGenericErrorContext();
    v1(*v2, "xmlParseNamespace() deprecated function reached\n");
    xmlParseNamespace_deprecated = 1;
  }
}

xmlChar *__cdecl xmlScanName(xmlParserCtxtPtr ctxt)
{
  if ((xmlScanName_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v1 = *__xmlGenericError();
    xmlGenericErrorFunc v2 = __xmlGenericErrorContext();
    v1(*v2, "xmlScanName() deprecated function reached\n");
    xmlScanName_deprecated = 1;
  }
  return 0;
}

void xmlParserHandleReference(xmlParserCtxtPtr ctxt)
{
  if ((xmlParserHandleReference_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v1 = *__xmlGenericError();
    xmlGenericErrorFunc v2 = __xmlGenericErrorContext();
    v1(*v2, "xmlParserHandleReference() deprecated function reached\n");
    xmlParserHandleReference_deprecated = 1;
  }
}

void xmlHandleEntity(xmlParserCtxtPtr ctxt, xmlEntityPtr entity)
{
  if ((xmlHandleEntity_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    int v3 = __xmlGenericErrorContext();
    v2(*v3, "xmlHandleEntity() deprecated function reached\n");
    xmlHandleEntity_deprecated = 1;
  }
}

xmlNsPtr xmlNewGlobalNs(xmlDocPtr doc, const xmlChar *href, const xmlChar *prefix)
{
  if ((xmlNewGlobalNs_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    int v4 = __xmlGenericErrorContext();
    v3(*v4, "xmlNewGlobalNs() deprecated function reached\n");
    xmlNewGlobalNs_deprecated = 1;
  }
  return 0;
}

const xmlChar *__cdecl xmlEncodeEntities(xmlDocPtr doc, const xmlChar *input)
{
  if ((xmlEncodeEntities_warning & 1) == 0)
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    xmlGenericErrorFunc v3 = __xmlGenericErrorContext();
    v2(*v3, "Deprecated API xmlEncodeEntities() used\n");
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    uint64_t v5 = __xmlGenericErrorContext();
    v4(*v5, "   change code to use xmlEncodeEntitiesReentrant()\n");
    xmlEncodeEntities_warning = 1;
  }
  return 0;
}

const xmlChar *__cdecl getPublicId(void *ctx)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    xmlGenericErrorFunc v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "getPublicId");
    int v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;

  return xmlSAX2GetPublicId(ctx);
}

const xmlChar *__cdecl getSystemId(void *ctx)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    xmlGenericErrorFunc v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "getSystemId");
    int v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;

  return xmlSAX2GetSystemId(ctx);
}

int getLineNumber(void *ctx)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    xmlGenericErrorFunc v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "getLineNumber");
    int v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;

  return xmlSAX2GetLineNumber(ctx);
}

int getColumnNumber(void *ctx)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    xmlGenericErrorFunc v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "getColumnNumber");
    int v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;

  return xmlSAX2GetColumnNumber(ctx);
}

int isStandalone(void *ctx)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    xmlGenericErrorFunc v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "isStandalone");
    int v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;

  return xmlSAX2IsStandalone(ctx);
}

int hasInternalSubset(void *ctx)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    xmlGenericErrorFunc v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "hasInternalSubset");
    int v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;

  return xmlSAX2HasInternalSubset(ctx);
}

int hasExternalSubset(void *ctx)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    xmlGenericErrorFunc v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "hasExternalSubset");
    int v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;

  return xmlSAX2HasExternalSubset(ctx);
}

void internalSubset(void *ctx, const xmlChar *name, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  int v8 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v9 = *__xmlGenericError();
    int v10 = __xmlGenericErrorContext();
    v9(*v10, "Use of deprecated SAXv1 function %s\n", "internalSubset");
    int v8 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v8 + 1;

  xmlSAX2InternalSubset(ctx, name, ExternalID, SystemID);
}

void externalSubset(void *ctx, const xmlChar *name, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  int v8 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v9 = *__xmlGenericError();
    int v10 = __xmlGenericErrorContext();
    v9(*v10, "Use of deprecated SAXv1 function %s\n", "externalSubset");
    int v8 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v8 + 1;

  xmlSAX2ExternalSubset(ctx, name, ExternalID, SystemID);
}

xmlParserInputPtr resolveEntity(void *ctx, const xmlChar *publicId, const xmlChar *systemId)
{
  int v6 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v7 = *__xmlGenericError();
    int v8 = __xmlGenericErrorContext();
    v7(*v8, "Use of deprecated SAXv1 function %s\n", "resolveEntity");
    int v6 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v6 + 1;

  return xmlSAX2ResolveEntity(ctx, publicId, systemId);
}

xmlEntityPtr getEntity(void *ctx, const xmlChar *name)
{
  int v4 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v5 = *__xmlGenericError();
    int v6 = __xmlGenericErrorContext();
    v5(*v6, "Use of deprecated SAXv1 function %s\n", "getEntity");
    int v4 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v4 + 1;

  return xmlSAX2GetEntity(ctx, name);
}

xmlEntityPtr getParameterEntity(void *ctx, const xmlChar *name)
{
  int v4 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v5 = *__xmlGenericError();
    int v6 = __xmlGenericErrorContext();
    v5(*v6, "Use of deprecated SAXv1 function %s\n", "getParameterEntity");
    int v4 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v4 + 1;

  return xmlSAX2GetParameterEntity(ctx, name);
}

void entityDecl(void *ctx, const xmlChar *name, int type, const xmlChar *publicId, const xmlChar *systemId, xmlChar *content)
{
  int v12 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v13 = *__xmlGenericError();
    uint64_t v14 = __xmlGenericErrorContext();
    v13(*v14, "Use of deprecated SAXv1 function %s\n", "entityDecl");
    int v12 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v12 + 1;

  xmlSAX2EntityDecl(ctx, name, type, publicId, systemId, content);
}

void attributeDecl(void *ctx, const xmlChar *elem, const xmlChar *fullname, int type, int def, const xmlChar *defaultValue, xmlEnumerationPtr tree)
{
  int v14 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v15 = *__xmlGenericError();
    unsigned int v16 = __xmlGenericErrorContext();
    v15(*v16, "Use of deprecated SAXv1 function %s\n", "attributeDecl");
    int v14 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v14 + 1;

  xmlSAX2AttributeDecl(ctx, elem, fullname, type, def, defaultValue, tree);
}

void elementDecl(void *ctx, const xmlChar *name, int type, xmlElementContentPtr content)
{
  int v8 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v9 = *__xmlGenericError();
    int v10 = __xmlGenericErrorContext();
    v9(*v10, "Use of deprecated SAXv1 function %s\n", "elementDecl");
    int v8 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v8 + 1;

  xmlSAX2ElementDecl(ctx, name, type, content);
}

void notationDecl(void *ctx, const xmlChar *name, const xmlChar *publicId, const xmlChar *systemId)
{
  int v8 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v9 = *__xmlGenericError();
    int v10 = __xmlGenericErrorContext();
    v9(*v10, "Use of deprecated SAXv1 function %s\n", "notationDecl");
    int v8 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v8 + 1;

  xmlSAX2NotationDecl(ctx, name, publicId, systemId);
}

void unparsedEntityDecl(void *ctx, const xmlChar *name, const xmlChar *publicId, const xmlChar *systemId, const xmlChar *notationName)
{
  int v10 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v11 = *__xmlGenericError();
    int v12 = __xmlGenericErrorContext();
    v11(*v12, "Use of deprecated SAXv1 function %s\n", "unparsedEntityDecl");
    int v10 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v10 + 1;

  xmlSAX2UnparsedEntityDecl(ctx, name, publicId, systemId, notationName);
}

void setDocumentLocator(void *ctx, xmlSAXLocatorPtr loc)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    int v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "setDocumentLocator");
    int v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;
}

void endDocument(void *ctx)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    int v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "endDocument");
    int v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;

  xmlSAX2EndDocument(ctx);
}

void attribute(void *ctx, const xmlChar *fullname, const xmlChar *value)
{
  int v3 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    xmlGenericErrorFunc v5 = __xmlGenericErrorContext();
    v4(*v5, "Use of deprecated SAXv1 function %s\n", "attribute");
    int v3 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v3 + 1;
}

void endElement(void *ctx, const xmlChar *name)
{
  int v4 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v5 = *__xmlGenericError();
    int v6 = __xmlGenericErrorContext();
    v5(*v6, "Use of deprecated SAXv1 function %s\n", "endElement");
    int v4 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v4 + 1;

  xmlSAX2EndElement(ctx, name);
}

void reference(void *ctx, const xmlChar *name)
{
  int v4 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v5 = *__xmlGenericError();
    int v6 = __xmlGenericErrorContext();
    v5(*v6, "Use of deprecated SAXv1 function %s\n", "reference");
    int v4 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v4 + 1;

  xmlSAX2Reference(ctx, name);
}

void characters(void *ctx, const xmlChar *ch, int len)
{
  int v6 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v7 = *__xmlGenericError();
    int v8 = __xmlGenericErrorContext();
    v7(*v8, "Use of deprecated SAXv1 function %s\n", "characters");
    int v6 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v6 + 1;

  xmlSAX2Characters(ctx, ch, len);
}

void ignorableWhitespace(void *ctx, const xmlChar *ch, int len)
{
  int v3 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    xmlGenericErrorFunc v5 = __xmlGenericErrorContext();
    v4(*v5, "Use of deprecated SAXv1 function %s\n", "ignorableWhitespace");
    int v3 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v3 + 1;
}

void processingInstruction(void *ctx, const xmlChar *target, const xmlChar *data)
{
  int v6 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v7 = *__xmlGenericError();
    int v8 = __xmlGenericErrorContext();
    v7(*v8, "Use of deprecated SAXv1 function %s\n", "processingInstruction");
    int v6 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v6 + 1;

  xmlSAX2ProcessingInstruction(ctx, target, data);
}

void globalNamespace(void *ctx, const xmlChar *href, const xmlChar *prefix)
{
  int v3 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    xmlGenericErrorFunc v5 = __xmlGenericErrorContext();
    v4(*v5, "Use of deprecated SAXv1 function %s\n", "globalNamespace");
    int v3 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v3 + 1;
}

void setNamespace(void *ctx, const xmlChar *name)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    xmlGenericErrorFunc v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "setNamespace");
    int v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;
}

xmlNsPtr getNamespace(void *ctx)
{
  int v1 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    xmlGenericErrorFunc v3 = __xmlGenericErrorContext();
    v2(*v3, "Use of deprecated SAXv1 function %s\n", "getNamespace");
    int v1 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v1 + 1;
  return 0;
}

int checkNamespace(void *ctx, xmlChar *nameSpace)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    xmlGenericErrorFunc v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "checkNamespace");
    int v2 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v2 + 1;
  return 0;
}

void namespaceDecl(void *ctx, const xmlChar *href, const xmlChar *prefix)
{
  int v3 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    xmlGenericErrorFunc v5 = __xmlGenericErrorContext();
    v4(*v5, "Use of deprecated SAXv1 function %s\n", "namespaceDecl");
    int v3 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v3 + 1;
}

void comment(void *ctx, const xmlChar *value)
{
  int v4 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v5 = *__xmlGenericError();
    int v6 = __xmlGenericErrorContext();
    v5(*v6, "Use of deprecated SAXv1 function %s\n", "comment");
    int v4 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v4 + 1;

  xmlSAX2Comment(ctx, value);
}

void cdataBlock(void *ctx, const xmlChar *value, int len)
{
  int v6 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v7 = *__xmlGenericError();
    int v8 = __xmlGenericErrorContext();
    v7(*v8, "Use of deprecated SAXv1 function %s\n", "cdataBlock");
    int v6 = deprecated_v1_msg;
  }
  deprecated_v1_msg = v6 + 1;

  xmlSAX2CDataBlock(ctx, value, len);
}

xmlListPtr xmlListCreate(xmlListDeallocator deallocator, xmlListDataCompare compare)
{
  int v4 = xmlMalloc(0x18uLL);
  if (!v4)
  {
    xmlGenericErrorFunc v7 = *__xmlGenericError();
    int v8 = __xmlGenericErrorContext();
    v7(*v8, "Cannot initialize memory for list");
    return 0;
  }
  xmlGenericErrorFunc v5 = v4;
  void *v4 = 0;
  v4[1] = 0;
  v4[2] = 0;
  int v6 = xmlMalloc(0x18uLL);
  *xmlGenericErrorFunc v5 = v6;
  if (!v6)
  {
    xmlGenericErrorFunc v9 = *__xmlGenericError();
    int v10 = __xmlGenericErrorContext();
    v9(*v10, "Cannot initialize memory for sentinel");
    xmlFree(v5);
    return 0;
  }
  *int v6 = v6;
  v6[1] = v6;
  void v6[2] = 0;
  if (deallocator) {
    v5[1] = deallocator;
  }
  if (compare) {
    v5[2] = compare;
  }
  else {
    v5[2] = xmlLinkCompare;
  }
  return (xmlListPtr)v5;
}

uint64_t xmlLinkCompare(unint64_t a1, unint64_t a2)
{
  if (a1 < a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return a1 != a2;
  }
}

void *__cdecl xmlListSearch(void *l, void *data)
{
  if (l)
  {
    l = xmlListLinkSearch((uint64_t)l, (uint64_t)data);
    if (l) {
      return (void *)*((void *)l + 2);
    }
  }
  return l;
}

void *xmlListLinkSearch(uint64_t a1, uint64_t a2)
{
  int v4 = *(void **)a1;
  do
  {
    int v4 = (void *)*v4;
    if (v4 == *(void **)a1) {
      return 0;
    }
  }
  while (((*(uint64_t (**)(void, uint64_t))(a1 + 16))(v4[2], a2) & 0x80000000) != 0);
  if (v4 == *(void **)a1) {
    return 0;
  }
  if ((*(unsigned int (**)(void, uint64_t))(a1 + 16))(v4[2], a2)) {
    return 0;
  }
  else {
    return v4;
  }
}

void *__cdecl xmlListReverseSearch(void *l, void *data)
{
  if (l)
  {
    l = (void *)xmlListLinkReverseSearch((uint64_t *)l, (uint64_t)data);
    if (l) {
      return (void *)*((void *)l + 2);
    }
  }
  return l;
}

uint64_t xmlListLinkReverseSearch(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  do
  {
    uint64_t v4 = *(void *)(v4 + 8);
    if (v4 == *a1) {
      return 0;
    }
  }
  while (((int (*)(void, uint64_t))a1[2])(*(void *)(v4 + 16), a2) > 0);
  if (v4 == *a1) {
    return 0;
  }
  if (((unsigned int (*)(void, uint64_t))a1[2])(*(void *)(v4 + 16), a2)) {
    return 0;
  }
  else {
    return v4;
  }
}

int xmlListInsert(xmlListPtr l, void *data)
{
  if (!l) {
    return 1;
  }
  uint64_t v4 = *(void **)l;
  do
    uint64_t v4 = (void *)*v4;
  while (v4 != *(void **)l && ((*((uint64_t (**)(void, void *))l + 2))(v4[2], data) & 0x80000000) != 0);
  xmlGenericErrorFunc v5 = xmlMalloc(0x18uLL);
  if (v5)
  {
    int v6 = v5;
    int result = 0;
    uint64_t v8 = v4[1];
    *int v6 = *(void *)v8;
    *(void *)(*(void *)v8 + 8) = v6;
    *(void *)uint64_t v8 = v6;
    v6[1] = v8;
    void v6[2] = data;
  }
  else
  {
    xmlGenericErrorFunc v9 = *__xmlGenericError();
    int v10 = __xmlGenericErrorContext();
    v9(*v10, "Cannot initialize memory for new link");
    return 1;
  }
  return result;
}

int xmlListAppend(xmlListPtr l, void *data)
{
  if (!l) {
    return 1;
  }
  uint64_t v4 = *(void **)l;
  do
    uint64_t v4 = (void *)v4[1];
  while (v4 != *(void **)l && (*((int (**)(void, void *))l + 2))(v4[2], data) > 0);
  xmlGenericErrorFunc v5 = xmlMalloc(0x18uLL);
  if (v5)
  {
    int v6 = v5;
    int result = 0;
    *int v6 = *v4;
    *(void *)(*v4 + 8) = v6;
    void *v4 = v6;
    v6[1] = v4;
    void v6[2] = data;
  }
  else
  {
    xmlGenericErrorFunc v8 = *__xmlGenericError();
    xmlGenericErrorFunc v9 = __xmlGenericErrorContext();
    v8(*v9, "Cannot initialize memory for new link");
    return 1;
  }
  return result;
}

void xmlListDelete(xmlListPtr l)
{
  if (l)
  {
    xmlListClear(l);
    xmlFree(*(void **)l);
    xmlFreeFunc v2 = xmlFree;
    ((void (*)(xmlListPtr))v2)(l);
  }
}

void xmlListClear(xmlListPtr l)
{
  if (l)
  {
    xmlFreeFunc v2 = **(void ***)l;
    if (v2 != *(void **)l)
    {
      do
      {
        uint64_t v4 = (void *)*v2;
        int v3 = (void *)v2[1];
        void *v3 = *v2;
        *(void *)(*v2 + 8) = v3;
        xmlGenericErrorFunc v5 = (void (*)(void *))*((void *)l + 1);
        if (v5) {
          v5(v2);
        }
        xmlFree(v2);
        xmlFreeFunc v2 = v4;
      }
      while (v4 != *(void **)l);
    }
  }
}

int xmlListRemoveFirst(xmlListPtr l, void *data)
{
  if (l)
  {
    xmlListPtr v2 = l;
    l = (xmlListPtr)xmlListLinkSearch((uint64_t)l, (uint64_t)data);
    if (l)
    {
      xmlListPtr v3 = l;
      uint64_t v4 = (void *)*((void *)l + 1);
      void *v4 = *(void *)l;
      *(void *)(*(void *)l + 8) = v4;
      xmlGenericErrorFunc v5 = (void (*)(xmlListPtr))*((void *)v2 + 1);
      if (v5) {
        v5(l);
      }
      xmlFree(v3);
      LODWORD(l) = 1;
    }
  }
  return (int)l;
}

int xmlListRemoveLast(xmlListPtr l, void *data)
{
  if (l)
  {
    xmlListPtr v2 = l;
    l = (xmlListPtr)xmlListLinkReverseSearch((uint64_t *)l, (uint64_t)data);
    if (l)
    {
      xmlListPtr v3 = l;
      uint64_t v4 = (void *)*((void *)l + 1);
      void *v4 = *(void *)l;
      *(void *)(*(void *)l + 8) = v4;
      xmlGenericErrorFunc v5 = (void (*)(xmlListPtr))*((void *)v2 + 1);
      if (v5) {
        v5(l);
      }
      xmlFree(v3);
      LODWORD(l) = 1;
    }
  }
  return (int)l;
}

int xmlListRemoveAll(xmlListPtr l, void *data)
{
  if (!l) {
    return 0;
  }
  int v4 = -1;
  do
    ++v4;
  while (xmlListRemoveFirst(l, data));
  return v4;
}

int xmlListEmpty(xmlListPtr l)
{
  if (l) {
    return **(void **)l == *(void *)l;
  }
  else {
    return -1;
  }
}

xmlLinkPtr xmlListFront(xmlLinkPtr l)
{
  if (l) {
    return **(xmlLinkPtr **)l;
  }
  return l;
}

xmlLinkPtr xmlListEnd(xmlLinkPtr l)
{
  if (l) {
    return *(xmlLinkPtr *)(*(void *)l + 8);
  }
  return l;
}

int xmlListSize(xmlListPtr l)
{
  if (!l) {
    return -1;
  }
  int v1 = *(void **)l;
  int result = -1;
  xmlListPtr v3 = v1;
  do
  {
    xmlListPtr v3 = (void *)*v3;
    ++result;
  }
  while (v3 != v1);
  return result;
}

void xmlListPopFront(xmlListPtr l)
{
  if (l)
  {
    int v1 = **(void ***)l;
    if (v1 != *(void **)l)
    {
      xmlListPtr v2 = (void *)v1[1];
      *xmlListPtr v2 = *v1;
      *(void *)(*v1 + 8) = v2;
      xmlListPtr v3 = (void (*)(void *))*((void *)l + 1);
      if (v3) {
        v3(v1);
      }
      xmlFreeFunc v4 = xmlFree;
      ((void (*)(void *))v4)(v1);
    }
  }
}

void xmlListPopBack(xmlListPtr l)
{
  if (l && **(void **)l != *(void *)l)
  {
    int v1 = *(void **)(*(void *)l + 8);
    xmlListPtr v2 = (void *)v1[1];
    *xmlListPtr v2 = *v1;
    *(void *)(*v1 + 8) = v2;
    xmlListPtr v3 = (void (*)(void *))*((void *)l + 1);
    if (v3) {
      v3(v1);
    }
    xmlFreeFunc v4 = xmlFree;
    ((void (*)(void *))v4)(v1);
  }
}

int xmlListPushFront(xmlListPtr l, void *data)
{
  if (l)
  {
    uint64_t v3 = *(void *)l;
    l = (xmlListPtr)xmlMalloc(0x18uLL);
    if (l)
    {
      *(void *)l = *(void *)v3;
      *(void *)(*(void *)v3 + 8) = l;
      *(void *)uint64_t v3 = l;
      *((void *)l + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v3;
      *((void *)l + 2) = data;
      LODWORD(l) = 1;
    }
    else
    {
      xmlGenericErrorFunc v4 = *__xmlGenericError();
      xmlGenericErrorFunc v5 = __xmlGenericErrorContext();
      v4(*v5, "Cannot initialize memory for new link");
      LODWORD(l) = 0;
    }
  }
  return (int)l;
}

int xmlListPushBack(xmlListPtr l, void *data)
{
  if (l)
  {
    uint64_t v3 = *(void *)(*(void *)l + 8);
    l = (xmlListPtr)xmlMalloc(0x18uLL);
    if (l)
    {
      *(void *)l = *(void *)v3;
      *(void *)(*(void *)v3 + 8) = l;
      *(void *)uint64_t v3 = l;
      *((void *)l + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v3;
      *((void *)l + 2) = data;
      LODWORD(l) = 1;
    }
    else
    {
      xmlGenericErrorFunc v4 = *__xmlGenericError();
      xmlGenericErrorFunc v5 = __xmlGenericErrorContext();
      v4(*v5, "Cannot initialize memory for new link");
      LODWORD(l) = 0;
    }
  }
  return (int)l;
}

void *__cdecl xmlLinkGetData(void *lk)
{
  if (lk) {
    return (void *)*((void *)lk + 2);
  }
  return lk;
}

void xmlListReverse(xmlListPtr l)
{
  if (l)
  {
    int v1 = *(void ***)l;
    xmlListPtr v2 = **(void ***)l;
    uint64_t v3 = *(void **)l;
    if (v2 != *(void **)l)
    {
      xmlGenericErrorFunc v4 = *(void **)l;
      do
      {
        uint64_t v3 = v2;
        void *v4 = v4[1];
        v4[1] = v2;
        xmlListPtr v2 = (void *)*v2;
        xmlGenericErrorFunc v4 = v3;
      }
      while (v2 != v1);
    }
    void *v3 = v3[1];
    v3[1] = v1;
  }
}

void xmlListSort(xmlListPtr l)
{
  if (l)
  {
    if (**(void **)l != *(void *)l)
    {
      xmlListPtr v2 = xmlListDup(l);
      if (v2)
      {
        uint64_t v3 = v2;
        xmlListClear(l);
        xmlListCopy(l, v3);
        xmlListClear(v3);
        xmlListClear(v3);
        xmlFree(*(void **)v3);
        xmlFreeFunc v4 = xmlFree;
        ((void (*)(xmlList *))v4)(v3);
      }
    }
  }
}

xmlListPtr xmlListDup(xmlListPtr old)
{
  if (old)
  {
    int v1 = old;
    old = xmlListCreate(0, *((xmlListDataCompare *)old + 2));
    if (old)
    {
      xmlListPtr v2 = old;
      if (xmlListCopy(old, v1)) {
        return 0;
      }
      else {
        return v2;
      }
    }
  }
  return old;
}

void xmlListMerge(xmlListPtr l1, xmlListPtr l2)
{
  xmlListCopy(l1, l2);

  xmlListClear(l2);
}

void xmlListWalk(xmlListPtr l, xmlListWalker walker, void *user)
{
  if (l && walker)
  {
    int v6 = *(void **)l;
    do
      int v6 = (void *)*v6;
    while (v6 != *(void **)l && ((unsigned int (*)(void, void *))walker)(v6[2], user));
  }
}

void xmlListReverseWalk(xmlListPtr l, xmlListWalker walker, void *user)
{
  if (l && walker)
  {
    uint64_t v6 = *(void *)l;
    do
      uint64_t v6 = *(void *)(v6 + 8);
    while (v6 != *(void *)l && ((unsigned int (*)(void, void *))walker)(*(void *)(v6 + 16), user));
  }
}

int xmlListCopy(xmlListPtr cur, const xmlListPtr old)
{
  int result = 1;
  if (cur && old)
  {
    xmlGenericErrorFunc v5 = *(uint64_t **)old;
    while (1)
    {
      xmlGenericErrorFunc v5 = (uint64_t *)*v5;
      if (v5 == *(uint64_t **)old) {
        break;
      }
      if (xmlListInsert(cur, (void *)v5[2]))
      {
        xmlListClear(cur);
        xmlFree(*(void **)cur);
        xmlFree(cur);
        return 1;
      }
    }
    return 0;
  }
  return result;
}

void xmlNanoFTPInit(void)
{
  if ((initialized & 1) == 0)
  {
    proxyPort = 21;
    xmlGenericErrorFunc v0 = getenv("no_proxy");
    if (!v0 || *v0 != 42 || v0[1])
    {
      int v1 = getenv("ftp_proxy");
      if (v1 || (int v1 = getenv("FTP_PROXY")) != 0) {
        xmlNanoFTPScanProxy(v1);
      }
      xmlListPtr v2 = getenv("ftp_proxy_user");
      if (v2) {
        proxyUser = (uint64_t)xmlMemStrdup(v2);
      }
      uint64_t v3 = getenv("ftp_proxy_password");
      if (v3) {
        proxyPasswd = (uint64_t)xmlMemStrdup(v3);
      }
      initialized = 1;
    }
  }
}

void xmlNanoFTPScanProxy(const char *URL)
{
  if (proxy)
  {
    xmlFree((void *)proxy);
    proxy = 0;
  }
  proxyPort = 0;
  if (URL)
  {
    xmlURIPtr v2 = xmlParseURIRaw(URL, 1);
    if (v2)
    {
      uint64_t v3 = v2;
      scheme = v2->scheme;
      if (scheme && !strcmp(scheme, "ftp") && (server = v3->server) != 0)
      {
        proxy = (uint64_t)xmlMemStrdup(server);
        if (v3->port) {
          proxyPort = v3->port;
        }
      }
      else
      {
        __xmlIOErr(9, 2003, (uint64_t)"Syntax Error\n");
      }
      xmlFreeURI(v3);
    }
    else
    {
      __xmlIOErr(9, 2003, (uint64_t)"Syntax Error\n");
    }
  }
}

void xmlNanoFTPCleanup(void)
{
  if (proxy)
  {
    xmlFree((void *)proxy);
    proxy = 0;
  }
  if (proxyUser)
  {
    xmlFree((void *)proxyUser);
    proxyUser = 0;
  }
  if (proxyPasswd)
  {
    xmlFree((void *)proxyPasswd);
    proxyPasswd = 0;
  }
  initialized = 0;
}

void xmlNanoFTPProxy(const char *host, int port, const char *user, const char *passwd, int type)
{
  if (proxy)
  {
    xmlFree((void *)proxy);
    proxy = 0;
  }
  if (proxyUser)
  {
    xmlFree((void *)proxyUser);
    proxyUser = 0;
  }
  if (proxyPasswd)
  {
    xmlFree((void *)proxyPasswd);
    proxyPasswd = 0;
  }
  if (host) {
    proxy = (uint64_t)xmlMemStrdup(host);
  }
  if (user) {
    proxyUser = (uint64_t)xmlMemStrdup(user);
  }
  if (passwd) {
    proxyPasswd = (uint64_t)xmlMemStrdup(passwd);
  }
  proxyPort = port;
  proxyType = type;
}

int xmlNanoFTPUpdateURL(void *ctx, const char *URL)
{
  int v2 = -1;
  if (ctx)
  {
    if (URL)
    {
      if (*(void *)ctx)
      {
        if (*((void *)ctx + 1))
        {
          xmlURIPtr v4 = xmlParseURIRaw(URL, 1);
          if (v4)
          {
            xmlGenericErrorFunc v5 = v4;
            if (!v4->scheme)
            {
LABEL_11:
              xmlFreeURI(v5);
              return v2;
            }
            server = v4->server;
            if (!server || strcmp(*(const char **)ctx, v4->scheme) || strcmp(*((const char **)ctx + 1), server))
            {
LABEL_10:
              int v2 = -1;
              goto LABEL_11;
            }
            int port = v5->port;
            if (port)
            {
              if (*((_DWORD *)ctx + 4) != port) {
                goto LABEL_10;
              }
              *((_DWORD *)ctx + 4) = port;
            }
            xmlGenericErrorFunc v9 = (void *)*((void *)ctx + 3);
            if (v9)
            {
              xmlFree(v9);
              *((void *)ctx + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0;
            }
            if (v5->path) {
              path = v5->path;
            }
            else {
              path = "/";
            }
            int v2 = 0;
            *((void *)ctx + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = xmlMemStrdup(path);
            goto LABEL_11;
          }
        }
      }
    }
  }
  return v2;
}

void *__cdecl xmlNanoFTPNewCtxt(const char *URL)
{
  int v2 = xmlMalloc(0x4D8uLL);
  uint64_t v3 = (uint64_t)v2;
  if (v2)
  {
    bzero(v2, 0x4D8uLL);
    *(_DWORD *)(v3 + 16) = 21;
    *(_DWORD *)(v3 + 192) = 0;
    *(void *)(v3 + 1224) = 0;
    *(void *)(v3 + 176) = 0xFFFFFFFF00000001;
    xmlURIPtr v4 = xmlURIUnescapeString(URL, 0, 0);
    if (v4)
    {
      xmlGenericErrorFunc v5 = v4;
      xmlNanoFTPScanURL(v3, v4);
      xmlFree(v5);
    }
    else if (URL)
    {
      xmlNanoFTPScanURL(v3, (char *)URL);
    }
  }
  else
  {
    __xmlSimpleError(9, 2, 0, 0, (uint64_t)"allocating FTP context");
  }
  return (void *)v3;
}

void xmlNanoFTPScanURL(uint64_t a1, char *str)
{
  xmlURIPtr v4 = *(void **)a1;
  if (v4)
  {
    xmlFree(v4);
    *(void *)a1 = 0;
  }
  xmlGenericErrorFunc v5 = *(void **)(a1 + 8);
  if (v5)
  {
    xmlFree(v5);
    *(void *)(a1 + 8) = 0;
  }
  uint64_t v6 = *(void **)(a1 + 24);
  if (v6)
  {
    xmlFree(v6);
    *(void *)(a1 + 24) = 0;
  }
  xmlURIPtr v7 = xmlParseURIRaw(str, 1);
  if (v7)
  {
    xmlGenericErrorFunc v8 = v7;
    scheme = v7->scheme;
    if (scheme && v8->server)
    {
      *(void *)a1 = xmlMemStrdup(scheme);
      *(void *)(a1 + 8) = xmlMemStrdup(v8->server);
      if (v8->path) {
        path = v8->path;
      }
      else {
        path = "/";
      }
      *(void *)(a1 + 24) = xmlMemStrdup(path);
      int port = v8->port;
      if (port) {
        *(_DWORD *)(a1 + 16) = port;
      }
      user = (const xmlChar *)v8->user;
      if (user)
      {
        xmlGenericErrorFunc v13 = strchr(v8->user, 58);
        if (v13)
        {
          int v14 = v13;
          *(void *)(a1 + 32) = xmlStrndup(user, (int)v13 - (int)user);
          *(void *)(a1 + 40) = xmlMemStrdup(v14 + 1);
        }
        else
        {
          *(void *)(a1 + 32) = xmlMemStrdup((const char *)user);
        }
      }
    }
    xmlFreeURI(v8);
  }
}

void xmlNanoFTPFreeCtxt(void *ctx)
{
  if (ctx)
  {
    int v2 = (void *)*((void *)ctx + 1);
    if (v2) {
      xmlFree(v2);
    }
    if (*(void *)ctx) {
      xmlFree(*(void **)ctx);
    }
    uint64_t v3 = (void *)*((void *)ctx + 3);
    if (v3) {
      xmlFree(v3);
    }
    xmlURIPtr v4 = (void *)*((void *)ctx + 4);
    if (v4) {
      xmlFree(v4);
    }
    xmlGenericErrorFunc v5 = (void *)*((void *)ctx + 5);
    if (v5) {
      xmlFree(v5);
    }
    *((_DWORD *)ctx + 44) = 1;
    int v6 = *((_DWORD *)ctx + 45);
    if (v6 != -1) {
      close(v6);
    }
    *((_DWORD *)ctx + 45) = -1;
    *((void *)ctx + 15xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = -1;
    xmlFreeFunc v7 = xmlFree;
    ((void (*)(void *))v7)(ctx);
  }
}

unint64_t xmlNanoFTPReadResponse(int *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (a1[45] != -1)
  {
    int v2 = a1 + 196;
    signed int v3 = a1[306];
    do
    {
      if (v3 > 0x400) {
        break;
      }
      int v4 = a1[307];
      if (v4 > 0x400 || v4 < v3) {
        break;
      }
      if (v3)
      {
        memmove(a1 + 49, (char *)a1 + v3 + 196, v4 - v3);
        int v4 = a1[307] - a1[306];
        a1[307] = v4;
        a1[306] = 0;
      }
      if (v4 == 1024)
      {
        int v6 = 0;
        signed int v3 = 1024;
      }
      else
      {
        int v6 = recv(a1[45], a1 + 49, 1024 - v4, 0);
        if (v6 < 0)
        {
          __xmlIOErr(9, 0, (uint64_t)"recv failed");
          close(a1[45]);
          unint64_t result = 0xFFFFFFFFLL;
          a1[45] = -1;
          return result;
        }
        uint64_t v7 = a1[307] + (uint64_t)v6;
        a1[307] = v7;
        *((unsigned char *)a1 + v7 + 196) = 0;
        signed int v3 = a1[307];
      }
      if (!(v3 | v6)) {
        return 0xFFFFFFFFLL;
      }
      signed int v8 = a1[306];
      if (v8 < v3)
      {
        unint64_t v9 = (unint64_t)a1 + v3 + 196;
        int v10 = (unsigned __int8 *)a1 + v8 + 196;
        while (1)
        {
          unint64_t v11 = v9 - (void)v10;
          if ((int)v9 - (int)v10 >= 3)
          {
            int v12 = (char)*v10;
            if ((v12 - 48) <= 9)
            {
              int v13 = v10[1];
              if ((v13 - 48) <= 9)
              {
                int v14 = v10[2];
                if ((v14 - 48) <= 9)
                {
                  int v15 = v14 + 10 * (v13 + 10 * v12);
                  int v16 = 5328 - v15;
                  int v17 = v15 - 5328;
                  if (v10[3] == 45) {
                    int v17 = v16;
                  }
                  if (v17 > 0) {
                    break;
                  }
                }
              }
            }
          }
          if ((unint64_t)v10 >= v9)
          {
LABEL_32:
            a1[306] = v3;
            goto LABEL_33;
          }
          ++v10;
          while (*(v10 - 1) != 10)
          {
            ++v10;
            if (!--v11) {
              goto LABEL_32;
            }
          }
          if ((unint64_t)v10 >= v9) {
            goto LABEL_31;
          }
        }
        long long v19 = v10 + 3;
        a1[308] = v10 + 3 - v2;
        while ((unint64_t)v19 < v9 && *v19 != 10)
          ++v19;
        if (*v19 == 10) {
          ++v19;
        }
        if (*v19 == 13) {
          LODWORD(v19) = v19 + 1;
        }
        a1[306] = v19 - v2;
        return v17 / 0x64uLL;
      }
LABEL_31:
      signed int v3 = a1[306];
LABEL_33:
      ;
    }
    while (a1[45] != -1);
  }
  return 0xFFFFFFFFLL;
}

int xmlNanoFTPCheckResponse(void *ctx)
{
  if (!ctx) {
    return -1;
  }
  unint64_t v2 = *((int *)ctx + 45);
  if (v2 == -1) {
    return -1;
  }
  v4.tv_sec = 0;
  *(void *)&v4.tv_usec = 0;
  memset(&v5, 0, sizeof(v5));
  if (__darwin_check_fd_set_overflow(v2, &v5, 0)) {
    *(__int32_t *)((char *)v5.fds_bits + ((v2 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v2;
  }
  int result = select(*((_DWORD *)ctx + 45) + 1, &v5, 0, 0, &v4);
  if (result)
  {
    if (result == -1)
    {
      __xmlIOErr(9, 0, (uint64_t)"select");
      return -1;
    }
    return xmlNanoFTPReadResponse((int *)ctx);
  }
  return result;
}

int xmlNanoFTPQuit(void *ctx)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!ctx) {
    return -1;
  }
  int v1 = *((_DWORD *)ctx + 45);
  if (v1 == -1) {
    return -1;
  }
  char v17 = 0;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  *(_OWORD *)&v5[7] = 0u;
  long long v6 = 0u;
  strcpy(v5, "QUIT\r\n");
  int v2 = strlen(v5);
  int v3 = send(v1, v5, v2, 0);
  int result = 0;
  if (v3 < 0)
  {
    __xmlIOErr(9, 0, (uint64_t)"send failed");
    return v3;
  }
  return result;
}

int xmlNanoFTPConnect(void *ctx)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (!ctx || !*((void *)ctx + 1)) {
    return -1;
  }
  uint64_t v2 = proxy;
  *((_OWORD *)ctx + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0u;
  if (v2) {
    int v3 = &proxyPort;
  }
  else {
    int v3 = (int *)((char *)ctx + 16);
  }
  unsigned int v4 = *v3;
  *((_OWORD *)ctx + 4) = 0uLL;
  *((_OWORD *)ctx + 5) = 0uLL;
  if (v4) {
    unsigned int v5 = v4;
  }
  else {
    unsigned int v5 = 21;
  }
  *((_OWORD *)ctx + 6) = 0uLL;
  *((_OWORD *)ctx + 7) = 0uLL;
  *((_OWORD *)ctx + 8) = 0uLL;
  *((_OWORD *)ctx + 9) = 0uLL;
  *((_OWORD *)ctx + 10) = 0uLL;
  int v6 = socket(30, 1, 0);
  if (v6 == -1)
  {
    long long v10 = (const char *)proxy;
    if (!proxy) {
      long long v10 = (const char *)*((void *)ctx + 1);
    }
    long long v11 = gethostbyname(v10);
    if (v11)
    {
      h_size_t length = v11->h_length;
      if (h_length < 5)
      {
        *((unsigned char *)ctx + 49) = 2;
        memcpy((char *)ctx + 52, *(const void **)v11->h_addr_list, h_length);
        *((_WORD *)ctx + 25) = bswap32(v5) >> 16;
        int v16 = socket(2, 1, 0);
        *((_DWORD *)ctx + 45) = v16;
        socklen_t v17 = 16;
LABEL_37:
        if (v16 != -1)
        {
          if (connect(v16, (const sockaddr *)ctx + 3, v17) < 0)
          {
            BOOL v25 = "Failed to create a connection";
            goto LABEL_53;
          }
          if (xmlNanoFTPReadResponse((int *)ctx) != 2) {
            goto LABEL_55;
          }
          if (!proxy)
          {
LABEL_66:
            long long v43 = 0u;
            memset(v44, 0, 23);
            long long v41 = 0u;
            long long v42 = 0u;
            long long v39 = 0u;
            long long v40 = 0u;
            long long v37 = 0u;
            long long v38 = 0u;
            long long v36 = 0u;
            memset(&v35, 0, sizeof(v35));
            if (*((void *)ctx + 4)) {
              snprintf((char *)&v35, 0xC8uLL, "USER %s\r\n", *((const char **)ctx + 4));
            }
            else {
              strcpy((char *)&v35, "USER anonymous\r\n");
            }
            v44[23] = 0;
            int v29 = strlen((const char *)&v35);
            if ((send(*((_DWORD *)ctx + 45), &v35, v29, 0) & 0x80000000) == 0)
            {
              int v30 = xmlNanoFTPReadResponse((int *)ctx);
              if (v30 == 2) {
                return 0;
              }
              if (v30 != 3 || (xmlNanoFTPSendPasswd((uint64_t)ctx) & 0x80000000) != 0) {
                goto LABEL_55;
              }
              int v31 = xmlNanoFTPReadResponse((int *)ctx);
              if (v31 == 2) {
                return 0;
              }
              if (v31 == 3)
              {
                BOOL v25 = "FTP server asking for ACCNT on anonymous\n";
                int v26 = 2002;
                goto LABEL_54;
              }
LABEL_55:
              close(*((_DWORD *)ctx + 45));
              int v21 = -1;
              *((_DWORD *)ctx + 45) = -1;
              return v21;
            }
            BOOL v25 = "send failed";
LABEL_53:
            int v26 = 0;
LABEL_54:
            __xmlIOErr(9, v26, (uint64_t)v25);
            goto LABEL_55;
          }
          long long v55 = 0u;
          long long v56 = 0u;
          long long v53 = 0u;
          long long v54 = 0u;
          long long v51 = 0u;
          long long v52 = 0u;
          long long v49 = 0u;
          long long v50 = 0u;
          long long v47 = 0u;
          long long v48 = 0u;
          long long v45 = 0u;
          long long v46 = 0u;
          memset(v44, 0, sizeof(v44));
          long long v42 = 0u;
          long long v43 = 0u;
          long long v41 = 0u;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v36 = 0u;
          memset(&v35, 0, sizeof(v35));
          if (!proxyUser) {
            goto LABEL_62;
          }
          snprintf((char *)&v35, 0x190uLL, "USER %s\r\n", (const char *)proxyUser);
          HIBYTE(v56) = 0;
          int v20 = strlen((const char *)&v35);
          int v21 = send(*((_DWORD *)ctx + 45), &v35, v20, 0);
          if (v21 < 0) {
            goto LABEL_56;
          }
          int v22 = xmlNanoFTPReadResponse((int *)ctx);
          switch(v22)
          {
            case 1:
LABEL_62:
              if (proxyType >= 2)
              {
                if (proxyType != 2) {
                  goto LABEL_55;
                }
              }
              else
              {
                snprintf((char *)&v35, 0x190uLL, "SITE %s\r\n", *((const char **)ctx + 1));
                HIBYTE(v56) = 0;
                int v28 = strlen((const char *)&v35);
                int v21 = send(*((_DWORD *)ctx + 45), &v35, v28, 0);
                if (v21 < 0) {
                  goto LABEL_56;
                }
                if (xmlNanoFTPReadResponse((int *)ctx) == 2)
                {
                  proxyType = 1;
                  goto LABEL_66;
                }
                if (proxyType == 1) {
                  goto LABEL_55;
                }
              }
              if (*((void *)ctx + 4)) {
                snprintf((char *)&v35, 0x190uLL, "USER %s@%s\r\n");
              }
              else {
                snprintf((char *)&v35, 0x190uLL, "USER anonymous@%s\r\n");
              }
              HIBYTE(v56) = 0;
              int v32 = strlen((const char *)&v35);
              int v21 = send(*((_DWORD *)ctx + 45), &v35, v32, 0);
              if ((v21 & 0x80000000) == 0)
              {
                if (xmlNanoFTPReadResponse((int *)ctx) - 1 <= 1) {
                  goto LABEL_91;
                }
                if (*((void *)ctx + 5)) {
                  snprintf((char *)&v35, 0x190uLL, "PASS %s\r\n", *((const char **)ctx + 5));
                }
                else {
                  strcpy((char *)&v35, "PASS anonymous@\r\n");
                }
                HIBYTE(v56) = 0;
                int v33 = strlen((const char *)&v35);
                int v21 = send(*((_DWORD *)ctx + 45), &v35, v33, 0);
                if ((v21 & 0x80000000) == 0)
                {
                  if (xmlNanoFTPReadResponse((int *)ctx) - 1 > 1) {
                    goto LABEL_55;
                  }
LABEL_91:
                  int v21 = 0;
                  proxyType = 2;
                  return v21;
                }
              }
LABEL_56:
              __xmlIOErr(9, 0, (uint64_t)"send failed");
              close(*((_DWORD *)ctx + 45));
              *((_DWORD *)ctx + 45) = -1;
              return v21;
            case 3:
              int v23 = (const char *)proxyPasswd;
              if (!proxyPasswd)
              {
                strcpy((char *)&v35, "PASS anonymous@\r\n");
                goto LABEL_60;
              }
              break;
            case 2:
              int v23 = (const char *)proxyPasswd;
              if (!proxyPasswd) {
                goto LABEL_62;
              }
              break;
            default:
              goto LABEL_55;
          }
          snprintf((char *)&v35, 0x190uLL, "PASS %s\r\n", v23);
LABEL_60:
          HIBYTE(v56) = 0;
          int v27 = strlen((const char *)&v35);
          int v21 = send(*((_DWORD *)ctx + 45), &v35, v27, 0);
          if (v21 < 0) {
            goto LABEL_56;
          }
          if ((int)xmlNanoFTPReadResponse((int *)ctx) >= 4) {
            goto LABEL_55;
          }
          goto LABEL_62;
        }
        long long v9 = "socket failed";
        goto LABEL_49;
      }
      long long v9 = "gethostbyname address mismatch";
    }
    else
    {
      long long v9 = "gethostbyname failed";
    }
  }
  else
  {
    close(v6);
    size_t v34 = 0;
    memset(&v35, 0, sizeof(v35));
    v35.ai_sockxmlElementType type = 1;
    long long v7 = (const char *)proxy;
    if (!proxy) {
      long long v7 = (const char *)*((void *)ctx + 1);
    }
    if (!getaddrinfo(v7, 0, &v35, &v34) && v34)
    {
      long long v13 = v34;
      while (1)
      {
        int ai_family = v13->ai_family;
        if (ai_family == 2 || ai_family == 30) {
          break;
        }
        long long v13 = v13->ai_next;
        if (!v13)
        {
          long long v8 = "getaddrinfo failed";
LABEL_32:
          freeaddrinfo(v34);
          goto LABEL_14;
        }
      }
      ai_addrint len = v13->ai_addrlen;
      if (ai_addrlen > 0x80)
      {
        long long v8 = "gethostbyname address mismatch";
        goto LABEL_32;
      }
      memcpy((char *)ctx + 48, v13->ai_addr, ai_addrlen);
      *((_WORD *)ctx + 25) = bswap32(v5) >> 16;
      if (ai_family == 30) {
        int v19 = 30;
      }
      else {
        int v19 = 2;
      }
      *((_DWORD *)ctx + 45) = socket(v19, 1, 0);
      socklen_t v17 = v13->ai_addrlen;
      freeaddrinfo(v34);
      int v16 = *((_DWORD *)ctx + 45);
      goto LABEL_37;
    }
    long long v8 = "getaddrinfo failed";
LABEL_14:
    long long v9 = v8;
  }
LABEL_49:
  __xmlIOErr(9, 0, (uint64_t)v9);
  return -1;
}

ssize_t xmlNanoFTPSendPasswd(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  long long v14 = 0u;
  memset(v15, 0, 23);
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v6 = 0u;
  long long v7 = 0u;
  memset(__str, 0, sizeof(__str));
  if (*(void *)(a1 + 40)) {
    snprintf(__str, 0xC8uLL, "PASS %s\r\n", *(const char **)(a1 + 40));
  }
  else {
    strcpy(__str, "PASS anonymous@\r\n");
  }
  v15[23] = 0;
  int v2 = strlen(__str);
  ssize_t v3 = send(*(_DWORD *)(a1 + 180), __str, v2, 0);
  ssize_t result = 0;
  if ((v3 & 0x80000000) != 0)
  {
    __xmlIOErr(9, 0, (uint64_t)"send failed");
    return v3;
  }
  return result;
}

void *__cdecl xmlNanoFTPConnectTo(const char *server, int port)
{
  xmlNanoFTPInit();
  unsigned int v4 = 0;
  if (server)
  {
    if (port >= 1)
    {
      unsigned int v4 = xmlNanoFTPNewCtxt(0);
      if (v4)
      {
        unsigned int v5 = xmlMemStrdup(server);
        v4[1] = v5;
        if (!v5 || (*((_DWORD *)v4 + 4) = port, xmlNanoFTPConnect(v4) < 0))
        {
          xmlNanoFTPFreeCtxt(v4);
          return 0;
        }
      }
    }
  }
  return v4;
}

int xmlNanoFTPCwd(void *ctx, const char *directory)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (!ctx || *((_DWORD *)ctx + 45) == -1) {
    return -1;
  }
  if (!directory) {
    return 0;
  }
  long long v29 = 0u;
  memset(v30, 0, 31);
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  *(_OWORD *)__str = 0u;
  long long v8 = 0u;
  snprintf(__str, 0x190uLL, "CWD %s\r\n", directory);
  v30[31] = 0;
  int v3 = strlen(__str);
  int v4 = send(*((_DWORD *)ctx + 45), __str, v3, 0);
  if (v4 < 0)
  {
    __xmlIOErr(9, 0, (uint64_t)"send failed");
    return v4;
  }
  uint64_t v5 = (int)xmlNanoFTPReadResponse((int *)ctx) - 2;
  if (v5 <= 3) {
    return dword_1B51A80E0[v5];
  }
  else {
    return 0;
  }
}

int xmlNanoFTPDele(void *ctx, const char *file)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  int v2 = -1;
  if (ctx && file && *((_DWORD *)ctx + 45) != -1)
  {
    long long v29 = 0u;
    memset(v30, 0, 31);
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    long long v9 = 0u;
    long long v10 = 0u;
    *(_OWORD *)__str = 0u;
    long long v8 = 0u;
    snprintf(__str, 0x190uLL, "DELE %s\r\n", file);
    v30[31] = 0;
    int v4 = strlen(__str);
    int v2 = send(*((_DWORD *)ctx + 45), __str, v4, 0);
    if (v2 < 0)
    {
      __xmlIOErr(9, 0, (uint64_t)"send failed");
    }
    else
    {
      uint64_t v5 = (int)xmlNanoFTPReadResponse((int *)ctx) - 2;
      if (v5 > 3) {
        return 0;
      }
      else {
        return dword_1B51A80E0[v5];
      }
    }
  }
  return v2;
}

int xmlNanoFTPGetConnection(void *ctx)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (ctx)
  {
    memset(v23, 0, sizeof(v23));
    if (*((unsigned char *)ctx + 49) == 30)
    {
      int v2 = socket(30, 1, 6);
      *((_DWORD *)ctx + 46) = v2;
      v23[0].sa_family = 30;
      socklen_t v3 = 28;
    }
    else
    {
      int v2 = socket(2, 1, 6);
      *((_DWORD *)ctx + 46) = v2;
      v23[0].sa_family = 2;
      socklen_t v3 = 16;
    }
    socklen_t v20 = v3;
    if (v2 != -1)
    {
      uint64_t v28 = 0;
      memset(__s, 0, sizeof(__s));
      uint64_t v25 = 0;
      uint64_t v26 = 0;
      uint64_t v24 = 0;
      if (*((_DWORD *)ctx + 44))
      {
        if (*((unsigned char *)ctx + 49) == 30)
        {
          *(_DWORD *)((char *)__s + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 658774;
          unsigned __int16 v4 = 20549;
        }
        else
        {
          *(_DWORD *)((char *)__s + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 658774;
          unsigned __int16 v4 = 16720;
        }
        LODWORD(__s[0]) = v4 | 0x56530000;
        int v6 = strlen((const char *)__s);
        if ((send(*((_DWORD *)ctx + 45), __s, v6, 0) & 0x80000000) == 0)
        {
          int v7 = xmlNanoFTPReadResponse((int *)ctx);
          if (v7 == 2)
          {
LABEL_20:
            long long v8 = (char *)ctx + *((int *)ctx + 308) + 195;
            do
            {
              int v9 = *(unsigned __int8 *)++v8;
              unsigned int v10 = v9 - 48;
              if (v9) {
                BOOL v11 = v10 > 9;
              }
              else {
                BOOL v11 = 0;
              }
            }
            while (v11);
            if (*((unsigned char *)ctx + 49) == 30)
            {
              if (sscanf(v8, "%u", &v24) == 1)
              {
                *(sockaddr *)&v23[0].sa_data[6] = *(sockaddr *)((char *)ctx + 56);
                unsigned int v12 = bswap32((unsigned __int16)v24) >> 16;
                goto LABEL_33;
              }
              long long v17 = "Invalid answer to EPSV\n";
              int v18 = 2001;
            }
            else
            {
              if (sscanf(v8, "%u,%u,%u,%u,%u,%u", &v24, (char *)&v24 + 4, &v25, (char *)&v25 + 4, &v26, (char *)&v26 + 4) == 6)
              {
                uint64_t v14 = 0;
                *(_WORD *)&v21[4] = 0;
                *(_DWORD *)long long v21 = 0;
                do
                {
                  v21[v14] = *((_DWORD *)&v24 + v14);
                  ++v14;
                }
                while (v14 != 6);
                *(_DWORD *)&v23[0].sa_data[2] = *(_DWORD *)v21;
                LOWORD(v12) = *(_WORD *)&v21[4];
LABEL_33:
                *(_WORD *)v23[0].sa_xmlCatalogPtr data = v12;
                if (connect(*((_DWORD *)ctx + 46), v23, v3) < 0)
                {
                  long long v13 = "Failed to create a data connection";
                  goto LABEL_41;
                }
                return *((_DWORD *)ctx + 46);
              }
              long long v17 = "Invalid answer to PASV\n";
              int v18 = 2000;
            }
            __xmlIOErr(9, v18, (uint64_t)v17);
            int v19 = *((_DWORD *)ctx + 46);
            int v5 = -1;
            if (v19 == -1) {
              return v5;
            }
            close(v19);
            goto LABEL_43;
          }
          if (v7 != 5)
          {
            close(*((_DWORD *)ctx + 46));
            *((_DWORD *)ctx + 46) = -1;
            *((_DWORD *)ctx + 44) = 0;
            goto LABEL_20;
          }
LABEL_42:
          close(*((_DWORD *)ctx + 46));
          int v5 = -1;
LABEL_43:
          *((_DWORD *)ctx + 46) = -1;
          return v5;
        }
      }
      else
      {
        getsockname(v2, v23, &v20);
        *(_WORD *)v23[0].sa_xmlCatalogPtr data = 0;
        if (bind(*((_DWORD *)ctx + 46), v23, v20) < 0)
        {
          long long v13 = "bind failed";
LABEL_41:
          __xmlIOErr(9, 0, (uint64_t)v13);
          goto LABEL_42;
        }
        getsockname(*((_DWORD *)ctx + 46), v23, &v20);
        if (listen(*((_DWORD *)ctx + 46), 1) < 0)
        {
          long long v13 = "listen failed";
          goto LABEL_41;
        }
        if (*((unsigned char *)ctx + 49) == 30)
        {
          *(_OWORD *)long long v21 = 0u;
          memset(v22, 0, sizeof(v22));
          inet_ntop(30, &v23[0].sa_data[6], v21, 0x2Eu);
          snprintf((char *)__s, 0xC8uLL, "EPRT |2|%s|%s|\r\n");
        }
        else
        {
          snprintf((char *)__s, 0xC8uLL, "PORT %d,%d,%d,%d,%d,%d\r\n", v23[0].sa_data[2]);
        }
        HIBYTE(v28) = 0;
        int v15 = strlen((const char *)__s);
        if ((send(*((_DWORD *)ctx + 45), __s, v15, 0) & 0x80000000) == 0)
        {
          if (xmlNanoFTPReadResponse((int *)ctx) == 2) {
            return *((_DWORD *)ctx + 46);
          }
          goto LABEL_42;
        }
      }
      long long v13 = "send failed";
      goto LABEL_41;
    }
    __xmlIOErr(9, 0, (uint64_t)"socket failed");
  }
  return -1;
}

int xmlNanoFTPCloseConnection(void *ctx)
{
  if (!ctx) {
    return -1;
  }
  int v2 = -1;
  if (*((_DWORD *)ctx + 45) != -1)
  {
    close(*((_DWORD *)ctx + 46));
    *((_DWORD *)ctx + 46) = -1;
    long long v7 = xmmword_1B51A80D0;
    DWORD2(v7) = 0;
    memset(&v9, 0, sizeof(v9));
    int v3 = *((_DWORD *)ctx + 45);
    if (__darwin_check_fd_set_overflow(v3, &v9, 0)) {
      *(__int32_t *)((char *)v9.fds_bits + (((unint64_t)v3 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v3;
    }
    memset(&v8, 0, sizeof(v8));
    int v4 = *((_DWORD *)ctx + 45);
    if (__darwin_check_fd_set_overflow(v4, &v8, 0)) {
      *(__int32_t *)((char *)v8.fds_bits + (((unint64_t)v4 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v4;
    }
    int v5 = select(*((_DWORD *)ctx + 45) + 1, &v9, 0, &v8, (timeval *)&v7);
    if ((v5 & 0x80000000) == 0)
    {
      if (!v5)
      {
        int v2 = 0;
        goto LABEL_14;
      }
      if (xmlNanoFTPReadResponse((int *)ctx) == 2) {
        return 0;
      }
    }
    int v2 = -1;
LABEL_14:
    close(*((_DWORD *)ctx + 45));
    *((_DWORD *)ctx + 45) = -1;
  }
  return v2;
}

int xmlNanoFTPList(void *ctx, ftpListCallback callback, void *userData, const char *filename)
{
  uint64_t v4 = MEMORY[0x1F4188790](ctx, callback);
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  if (!v4) {
    return -1;
  }
  fd_set v8 = v7;
  uint64_t v9 = v6;
  unsigned int v10 = v5;
  uint64_t v11 = v4;
  bzero(__str, 0x1001uLL);
  memset(&v77, 0, sizeof(v77));
  *(void *)&v76.tv_usec = 0;
  if (v8)
  {
    if (*v8 == 47 || xmlNanoFTPCwd((void *)v11, *(const char **)(v11 + 24)) >= 1)
    {
      int v12 = xmlNanoFTPGetConnection((void *)v11);
      *(_DWORD *)(v11 + 184) = v12;
      if (v12 != -1)
      {
        snprintf(__str, 0x1001uLL, "LIST -L %s\r\n", v8);
        goto LABEL_10;
      }
    }
    return -1;
  }
  if (xmlNanoFTPCwd((void *)v11, *(const char **)(v11 + 24)) < 1) {
    return -1;
  }
  int v13 = xmlNanoFTPGetConnection((void *)v11);
  *(_DWORD *)(v11 + 184) = v13;
  if (v13 == -1) {
    return -1;
  }
  strcpy(__str, "LIST -L\r\n");
LABEL_10:
  __str[4096] = 0;
  int v14 = strlen(__str);
  int v15 = send(*(_DWORD *)(v11 + 180), __str, v14, 0);
  if (v15 < 0)
  {
    __xmlIOErr(9, 0, (uint64_t)"send failed");
    close(*(_DWORD *)(v11 + 184));
    goto LABEL_156;
  }
  int v16 = xmlNanoFTPReadResponse((int *)v11);
  if (v16 != 1)
  {
    int v73 = v16;
    close(*(_DWORD *)(v11 + 184));
    *(_DWORD *)(v11 + 184) = -1;
    return -v73;
  }
  uint64_t v74 = v9;
  long long v75 = v10;
  int v17 = 0;
  do
  {
    v76.tv_sec = 1;
    v76.tv_usec = 0;
    memset(&v78, 0, sizeof(v78));
    int v18 = *(_DWORD *)(v11 + 184);
    if (__darwin_check_fd_set_overflow(v18, &v78, 0)) {
      *(__int32_t *)((char *)v78.fds_bits + (((unint64_t)v18 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v18;
    }
    memset(&v77, 0, sizeof(v77));
    int v19 = *(_DWORD *)(v11 + 184);
    if (__darwin_check_fd_set_overflow(v19, &v77, 0)) {
      *(__int32_t *)((char *)v77.fds_bits + (((unint64_t)v19 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v19;
    }
    int v20 = select(*(_DWORD *)(v11 + 184) + 1, &v78, 0, &v77, &v76);
    if (v20 < 0) {
      goto LABEL_159;
    }
    if (!v20)
    {
      int v71 = xmlNanoFTPCheckResponse((void *)v11);
      if (v71 < 0)
      {
LABEL_159:
        close(*(_DWORD *)(v11 + 184));
        int v15 = -1;
        *(_DWORD *)(v11 + 184) = -1;
        return v15;
      }
      if (v71 != 2) {
        continue;
      }
      close(*(_DWORD *)(v11 + 184));
      int v15 = 0;
LABEL_156:
      *(_DWORD *)(v11 + 184) = -1;
      return v15;
    }
    int v21 = recv(*(_DWORD *)(v11 + 184), &__str[v17], 4097 - (v17 + 1), 0);
    int v14 = v21;
    if (v21 < 0)
    {
      __xmlIOErr(9, 0, (uint64_t)"recv");
      goto LABEL_159;
    }
    int v22 = 0;
    uint64_t v23 = v17 + (uint64_t)v21;
    __str[v23] = 0;
    while (1)
    {
      uint64_t v24 = &__str[v22];
      memset(v84, 0, sizeof(v84));
      memset(v83, 0, 11);
      memset(v82, 0, 11);
      memset(v81, 0, 11);
      int v79 = 0;
      if (strncmp(v24, "total", 5uLL)) {
        break;
      }
      uint64_t v26 = &__str[v22 + 4];
      do
      {
        unsigned int v31 = *++v26;
        unsigned int v30 = v31;
      }
      while (v31 == 32);
      if (v30 - 48 <= 9)
      {
        do
        {
          unsigned int v32 = *++v26;
          unsigned int v30 = v32;
        }
        while (v32 - 48 < 0xA);
      }
      while (v30 <= 0x20 && ((1 << v30) & 0x100002400) != 0)
      {
        unsigned int v33 = *++v26;
        unsigned int v30 = v33;
      }
LABEL_147:
      v22 += v26 - v24;
      if ((int)v26 - (int)v24 <= 0) {
        goto LABEL_148;
      }
    }
    int v25 = *(unsigned __int8 *)v24;
    if (v25 == 43) {
      goto LABEL_148;
    }
    uint64_t v26 = &__str[v22];
    while (v25 > 12)
    {
      if (v25 != 13 && v25 != 32) {
        goto LABEL_31;
      }
LABEL_29:
      int v27 = *++v26;
      int v25 = v27;
    }
    if (v25 == 10) {
      goto LABEL_29;
    }
    if (!v25) {
      goto LABEL_148;
    }
LABEL_31:
    int v28 = 0;
    while (v25 != 32)
    {
      if (v28 <= 9) {
        v83[v28++] = v25;
      }
      int v29 = *++v26;
      int v25 = v29;
      if (!v29) {
        goto LABEL_148;
      }
    }
    v83[10] = 0;
    while (v25 == 32)
    {
      int v34 = *++v26;
      int v25 = v34;
    }
    if (v25)
    {
      if ((v25 - 48) > 9)
      {
        uint64_t v35 = 0;
      }
      else
      {
        LODWORD(v35) = 0;
        int v36 = v25;
        do
        {
          int v37 = *++v26;
          int v25 = v37;
          uint64_t v35 = (v36 + 10 * v35 - 48);
          int v36 = v37;
        }
        while ((v37 - 48) < 0xA);
      }
      while (v25 == 32)
      {
        int v38 = *++v26;
        int v25 = v38;
      }
      if (v25)
      {
        int v39 = 0;
        while (v25 != 32)
        {
          if (v39 <= 9) {
            v82[v39++] = v25;
          }
          int v40 = *++v26;
          int v25 = v40;
          if (!v40) {
            goto LABEL_148;
          }
        }
        v82[v39] = 0;
        while (1)
        {
          int v41 = *v26;
          if (v41 != 32) {
            break;
          }
          ++v26;
        }
        if (*v26)
        {
          int v42 = 0;
          while (v41 != 32)
          {
            if (v42 <= 9) {
              v81[v42++] = v41;
            }
            int v43 = *++v26;
            int v41 = v43;
            if (!v43) {
              goto LABEL_148;
            }
          }
          v81[v42] = 0;
          while (1)
          {
            int v44 = *v26;
            if (v44 != 32) {
              break;
            }
            ++v26;
          }
          if (*v26)
          {
            if ((v44 - 48) > 9)
            {
              uint64_t v45 = 0;
            }
            else
            {
              uint64_t v45 = 0;
              int v46 = *v26;
              do
              {
                int v47 = *++v26;
                int v44 = v47;
                uint64_t v45 = (v46 - 48) + 10 * v45;
                int v46 = v47;
              }
              while ((v47 - 48) < 0xA);
            }
            while (v44 == 32)
            {
              int v48 = *++v26;
              int v44 = v48;
            }
            if (v44)
            {
              int v49 = 0;
              while (v44 != 32)
              {
                if (v49 <= 2) {
                  __str[v49++ - 4] = v44;
                }
                int v50 = *++v26;
                int v44 = v50;
                if (!v50) {
                  goto LABEL_148;
                }
              }
              __str[v49 - 4] = 0;
              while (1)
              {
                int v51 = *v26;
                if (v51 != 32) {
                  break;
                }
                ++v26;
              }
              if (*v26)
              {
                if ((v51 - 48) > 9)
                {
                  int v52 = 0;
                }
                else
                {
                  int v52 = 0;
                  int v53 = *v26;
                  do
                  {
                    int v54 = *++v26;
                    int v51 = v54;
                    int v52 = v53 + 10 * v52 - 48;
                    int v53 = v54;
                  }
                  while ((v54 - 48) < 0xA);
                }
                while (v51 == 32)
                {
                  int v55 = *++v26;
                  int v51 = v55;
                }
                if (v51 && v26[1] && v26[2])
                {
                  unsigned int v56 = v51 - 48;
                  if (v26[1] == 58 || v26[2] == 58)
                  {
                    if (v56 > 9)
                    {
                      int v59 = 0;
                    }
                    else
                    {
                      int v59 = 0;
                      int v60 = v51;
                      do
                      {
                        int v61 = *++v26;
                        int v51 = v61;
                        int v59 = v60 + 10 * v59 - 48;
                        int v60 = v61;
                      }
                      while ((v61 - 48) < 0xA);
                    }
                    if (v51 == 58) {
                      ++v26;
                    }
                    int v51 = *v26;
                    if ((v51 - 48) > 9)
                    {
                      uint64_t v57 = 0;
                      int v62 = 0;
                    }
                    else
                    {
                      int v62 = 0;
                      do
                      {
                        int v63 = *++v26;
                        int v62 = v51 + 10 * v62 - 48;
                        int v51 = v63;
                      }
                      while ((v63 - 48) < 0xA);
                      uint64_t v57 = 0;
                    }
                  }
                  else
                  {
                    if (v56 > 9)
                    {
                      uint64_t v57 = 0;
                    }
                    else
                    {
                      LODWORD(v57) = 0;
                      do
                      {
                        int v58 = *++v26;
                        uint64_t v57 = (v51 + 10 * v57 - 48);
                        int v51 = v58;
                      }
                      while ((v58 - 48) < 0xA);
                    }
                    int v62 = 0;
                    int v59 = 0;
                  }
                  while (v51 == 32)
                  {
                    int v64 = *++v26;
                    int v51 = v64;
                  }
                  if (v51)
                  {
                    int v65 = 0;
                    while (v51 != 10 && v51 != 13)
                    {
                      if (v65 <= 149) {
                        v84[v65++] = v51;
                      }
                      int v66 = *++v26;
                      int v51 = v66;
                      if (!v66) {
                        goto LABEL_148;
                      }
                    }
                    v84[v65] = 0;
                    int v67 = *v26;
                    if (v67 == 13 || v67 == 10)
                    {
                      while (v67 == 13 || v67 == 10)
                      {
                        char v70 = *++v26;
                        LOBYTE(v67) = v70;
                      }
                      if (v75) {
                        v75(v74, v84, v83, v82, v81, v45, v35, v57, &v79, __PAIR64__(v59, v52), v62);
                      }
                      goto LABEL_147;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_148:
    int v17 = v23 - v22;
    __memmove_chk();
  }
  while (v14);
  xmlNanoFTPCloseConnection((void *)v11);
  return 0;
}

int xmlNanoFTPGetSocket(void *ctx, const char *filename)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (!ctx || !filename && !*((void *)ctx + 3)) {
    return -1;
  }
  int result = xmlNanoFTPGetConnection(ctx);
  *((_DWORD *)ctx + 46) = result;
  if (result == -1) {
    return result;
  }
  long long v25 = 0u;
  memset(v26, 0, sizeof(v26));
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  strcpy(__s, "TYPE I\r\n");
  int v5 = strlen(__s);
  if ((send(*((_DWORD *)ctx + 45), __s, v5, 0) & 0x80000000) != 0) {
    goto LABEL_14;
  }
  if (xmlNanoFTPReadResponse((int *)ctx) != 2)
  {
LABEL_15:
    int result = *((_DWORD *)ctx + 46);
    goto LABEL_16;
  }
  if (filename) {
    snprintf(__s, 0x12CuLL, "RETR %s\r\n", filename);
  }
  else {
    snprintf(__s, 0x12CuLL, "RETR %s\r\n", *((const char **)ctx + 3));
  }
  v26[18] = 0;
  int v6 = strlen(__s);
  if ((send(*((_DWORD *)ctx + 45), __s, v6, 0) & 0x80000000) != 0)
  {
LABEL_14:
    __xmlIOErr(9, 0, (uint64_t)"send failed");
    goto LABEL_15;
  }
  int v7 = xmlNanoFTPReadResponse((int *)ctx);
  int result = *((_DWORD *)ctx + 46);
  if (v7 != 1)
  {
LABEL_16:
    close(result);
    int result = -1;
    *((_DWORD *)ctx + 46) = -1;
  }
  return result;
}

int xmlNanoFTPGet(void *ctx, ftpDataCallback callback, void *userData, const char *filename)
{
  uint64_t v4 = MEMORY[0x1F4188790](ctx, callback);
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (!v4) {
    return -1;
  }
  uint64_t v8 = v6;
  long long v9 = v5;
  uint64_t v10 = v4;
  if (v7)
  {
    if (!v5) {
      return -1;
    }
  }
  else
  {
    int result = -1;
    if (!v5 || !*(void *)(v10 + 24)) {
      return result;
    }
  }
  int result = xmlNanoFTPGetSocket((void *)v10, v7);
  if (result != -1)
  {
    bzero(v18, 0x1000uLL);
    LODWORD(v12) = 0;
    *(void *)&v16.tv_usec = 0;
    while (1)
    {
      v16.tv_sec = 1;
      v16.tv_usec = 0;
      memset(&v17, 0, sizeof(v17));
      int v13 = *(_DWORD *)(v10 + 184);
      if (__darwin_check_fd_set_overflow(v13, &v17, 0)) {
        *(__int32_t *)((char *)v17.fds_bits + (((unint64_t)v13 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v13;
      }
      int v14 = select(*(_DWORD *)(v10 + 184) + 1, &v17, 0, 0, &v16);
      if (v14 < 0) {
        goto LABEL_20;
      }
      if (v14)
      {
        ssize_t v12 = recv(*(_DWORD *)(v10 + 184), v18, 0x1000uLL, 0);
        if ((v12 & 0x80000000) != 0)
        {
          __xmlIOErr(9, 0, (uint64_t)"recv failed");
          v9(v8, v18, v12);
LABEL_20:
          close(*(_DWORD *)(v10 + 184));
          int result = -1;
          *(_DWORD *)(v10 + 184) = -1;
          return result;
        }
        v9(v8, v18, v12);
      }
      else
      {
        int v15 = xmlNanoFTPCheckResponse((void *)v10);
        if (v15 < 0) {
          goto LABEL_20;
        }
        if (v15 == 2)
        {
          close(*(_DWORD *)(v10 + 184));
          int result = 0;
          *(_DWORD *)(v10 + 184) = -1;
          return result;
        }
      }
      if (!v12) {
        return xmlNanoFTPCloseConnection((void *)v10);
      }
    }
  }
  return result;
}

int xmlNanoFTPRead(void *ctx, void *dest, int len)
{
  if (!ctx) {
    return -1;
  }
  int v4 = *((_DWORD *)ctx + 46);
  if (v4 == -1) {
    return 0;
  }
  if (!dest) {
    return -1;
  }
  if (len < 1) {
    return 0;
  }
  int v5 = recv(v4, dest, len, 0);
  int v6 = v5;
  if (v5 <= 0)
  {
    if (v5 < 0) {
      __xmlIOErr(9, 0, (uint64_t)"recv failed");
    }
    xmlNanoFTPCloseConnection(ctx);
  }
  return v6;
}

void *__cdecl xmlNanoFTPOpen(const char *URL)
{
  xmlNanoFTPInit();
  if (URL)
  {
    if (strncmp("ftp://", URL, 6uLL)) {
      return 0;
    }
    int v3 = (char *)xmlNanoFTPNewCtxt(URL);
    URL = v3;
    if (v3 && (xmlNanoFTPConnect(v3) < 0 || xmlNanoFTPGetSocket((void *)URL, *((const char **)URL + 3)) == -1))
    {
      xmlNanoFTPFreeCtxt((void *)URL);
      return 0;
    }
  }
  return (void *)URL;
}

int xmlNanoFTPClose(void *ctx)
{
  if (!ctx) {
    return -1;
  }
  int v2 = *((_DWORD *)ctx + 46);
  if (v2 != -1)
  {
    close(v2);
    *((_DWORD *)ctx + 46) = -1;
  }
  if (*((_DWORD *)ctx + 45) != -1)
  {
    xmlNanoFTPQuit(ctx);
    close(*((_DWORD *)ctx + 45));
    *((_DWORD *)ctx + 45) = -1;
  }
  xmlNanoFTPFreeCtxt(ctx);
  return 0;
}

void xmlNanoHTTPInit(void)
{
  if ((initialized_0 & 1) == 0)
  {
    if (!proxy_0)
    {
      proxyPort_0 = 80;
      xmlGenericErrorFunc v0 = getenv("no_proxy");
      if (!v0 || *v0 != 42 || v0[1])
      {
        int v1 = getenv("http_proxy");
        if (v1 || (int v1 = getenv("HTTP_PROXY")) != 0) {
          xmlNanoHTTPScanProxy(v1);
        }
      }
    }
    initialized_0 = 1;
  }
}

void xmlNanoHTTPScanProxy(const char *URL)
{
  if (proxy_0)
  {
    xmlFree((void *)proxy_0);
    proxy_0 = 0;
  }
  proxyPort_0 = 0;
  if (URL)
  {
    xmlURIPtr v2 = xmlParseURIRaw(URL, 1);
    if (v2)
    {
      int v3 = v2;
      scheme = v2->scheme;
      if (scheme && !strcmp(scheme, "http") && (server = v3->server) != 0)
      {
        proxy_0 = (uint64_t)xmlMemStrdup(server);
        if (v3->port) {
          proxyPort_0 = v3->port;
        }
      }
      else
      {
        __xmlIOErr(10, 2020, (uint64_t)"Syntax Error\n");
      }
      xmlFreeURI(v3);
    }
    else
    {
      __xmlIOErr(10, 2020, (uint64_t)"Syntax Error\n");
    }
  }
}

void xmlNanoHTTPCleanup(void)
{
  if (proxy_0)
  {
    xmlFree((void *)proxy_0);
    proxy_0 = 0;
  }
  initialized_0 = 0;
}

void *__cdecl xmlNanoHTTPOpen(const char *URL, char **contentType)
{
  if (contentType) {
    *contentType = 0;
  }
  return xmlNanoHTTPMethodRedir(URL, 0, 0, contentType, 0, 0, 0);
}

void *__cdecl xmlNanoHTTPMethod(const char *URL, const char *method, const char *input, char **contentType, const char *headers, int ilen)
{
  return xmlNanoHTTPMethodRedir(URL, method, input, contentType, 0, headers, ilen);
}

void *__cdecl xmlNanoHTTPOpenRedir(const char *URL, char **contentType, char **redir)
{
  if (contentType) {
    *contentType = 0;
  }
  if (redir) {
    *redir = 0;
  }
  return xmlNanoHTTPMethodRedir(URL, 0, 0, contentType, redir, 0, 0);
}

void *__cdecl xmlNanoHTTPMethodRedir(const char *URL, const char *method, const char *input, char **contentType, char **redir, const char *headers, int ilen)
{
  uint64_t v7 = MEMORY[0x1F4188790](URL, method);
  xmlGenericErrorFunc v124 = v13;
  *(void *)&v127[1] = *MEMORY[0x1E4F143B8];
  int v119 = (const char *)v7;
  if (!v7) {
    return 0;
  }
  int v14 = v12;
  uint64_t v125 = v9;
  xmlGenericErrorFunc v118 = v10;
  int v15 = "GET";
  if (v8) {
    int v15 = v8;
  }
  xmlGenericErrorFunc v122 = (char *)v15;
  __s = v11;
  xmlNanoHTTPInit();
  int v16 = 0;
  fd_set v17 = 0;
  long long v18 = &xmlMemStrdup;
  uint64_t v19 = &xmlFree;
  while (2)
  {
    long long v20 = xmlNanoHTTPNewCtxt(v119);
    if (!v20) {
      return v20;
    }
LABEL_8:
    if (!*(void *)v20 || strcmp(*(const char **)v20, "http"))
    {
      int v113 = "Not a valid HTTP URI";
      int v114 = 2020;
LABEL_218:
      __xmlIOErr(10, v114, (uint64_t)v113);
LABEL_219:
      xmlNanoHTTPFreeCtxt((uint64_t)v20);
      if (v17) {
        ((void (*)(const char *))*v19)(v17);
      }
      return 0;
    }
    long long v21 = v18;
    long long v22 = (const char *)*((void *)v20 + 1);
    if (!v22)
    {
      int v113 = "Failed to identify host in URI";
      int v114 = 2022;
      goto LABEL_218;
    }
    int v121 = v16;
    long long v23 = v17;
    long long v24 = v19;
    int v25 = strlen(v22);
    int v26 = v25;
    if (proxy_0)
    {
      int v26 = 2 * v25 + 16;
      unsigned int v27 = proxyPort_0;
      int v28 = (const char *)proxy_0;
    }
    else
    {
      unsigned int v27 = *((_DWORD *)v20 + 4);
      int v28 = (const char *)*((void *)v20 + 1);
    }
    int v29 = xmlNanoHTTPConnectHost(v28, v27);
    if (v29 == -1)
    {
      xmlNanoHTTPFreeCtxt((uint64_t)v20);
      if (v23) {
        ((void (*)(const char *))*v19)(v23);
      }
      return 0;
    }
    *((_DWORD *)v20 + 10) = v29;
    if (v125) {
      int v30 = v14;
    }
    else {
      int v30 = 0;
    }
    if (v125) {
      int v31 = v26 + 36;
    }
    else {
      int v31 = v26;
    }
    if (__s) {
      v31 += strlen(__s) + 2;
    }
    if (v124 && *v124) {
      v31 += strlen(*v124) + 16;
    }
    unsigned int v32 = (const char *)*((void *)v20 + 4);
    if (v32) {
      v31 += strlen(v32) + 1;
    }
    int v33 = strlen(v122);
    int v34 = v31 + v33 + strlen(*((const char **)v20 + 3));
    int v120 = v30;
    if (*((_DWORD *)v20 + 4) == 80)
    {
      int v35 = v34 + 47;
    }
    else
    {
      int v36 = v34 + 24;
      int v37 = v36 + 34;
      int v35 = v36 + 40;
      if (!proxy_0) {
        int v35 = v37;
      }
    }
    size_t v38 = v35;
    int v39 = (char *)xmlMallocAtomic(v35);
    if (!v39)
    {
      xmlNanoHTTPFreeCtxt((uint64_t)v20);
      __xmlSimpleError(10, 2, 0, 0, (uint64_t)"allocating header buffer");
      return 0;
    }
    int v40 = v39;
    if (proxy_0)
    {
      if (*((_DWORD *)v20 + 4) == 80) {
        int v41 = snprintf(v39, v38, "%s http://%s%s");
      }
      else {
        int v41 = snprintf(v39, v38, "%s http://%s:%d%s");
      }
    }
    else
    {
      int v41 = snprintf(v39, v38, "%s %s");
    }
    int v42 = (char *)&v40[v41];
    if (*((void *)v20 + 4)) {
      v42 += snprintf((char *)&v40[v41], v38 - v41, "?%s", *((const char **)v20 + 4));
    }
    int v43 = &v40[v38];
    size_t v44 = v43 - v42;
    if (*((_DWORD *)v20 + 4) == 80) {
      int v45 = snprintf(v42, v44, " HTTP/1.0\r\nHost: %s\r\n");
    }
    else {
      int v45 = snprintf(v42, v44, " HTTP/1.0\r\nHost: %s:%d\r\n");
    }
    int v46 = &v42[v45 + snprintf(&v42[v45], v43 - &v42[v45], "Accept-Encoding: gzip\r\n")];
    if (v124 && *v124) {
      v46 += snprintf(v46, v43 - v46, "Content-Type: %s\r\n", *v124);
    }
    if (__s) {
      v46 += snprintf(v46, v43 - v46, "%s", __s);
    }
    size_t v47 = v43 - v46;
    if (v125) {
      snprintf(v46, v47, "Content-Length: %d\r\n\r\n");
    }
    else {
      snprintf(v46, v47, "\r\n");
    }
    long long v18 = v21;
    *((void *)v20 + 6) = v40;
    *((void *)v20 + 7) = v40;
    *((_DWORD *)v20 + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 1;
    int v48 = strlen(v40);
    xmlNanoHTTPSend((uint64_t)v20, (uint64_t)v40, v48);
    if (v125) {
      xmlNanoHTTPSend((uint64_t)v20, v125, v14);
    }
    *((_DWORD *)v20 + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 2;
    uint64_t v19 = v24;
    fd_set v17 = v23;
    while (2)
    {
      int v49 = cur;
      bzero(cur, 0x1000uLL);
      while (1)
      {
        int v50 = (unsigned __int8 *)*((void *)v20 + 11);
        if (v50 == *((unsigned __int8 **)v20 + 10)) {
          break;
        }
LABEL_59:
        *((void *)v20 + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v50 + 1;
        int v52 = *v50;
        char *v49 = v52;
        if (v52 != 13)
        {
          if (v52 == 10) {
            goto LABEL_65;
          }
          ++v49;
        }
        if (v49 - cur >= 4095)
        {
          int v49 = v127;
          goto LABEL_65;
        }
      }
      int v51 = xmlNanoHTTPRecv((uint64_t)v20);
      if (v51 == -1) {
        break;
      }
      if (v51)
      {
        int v50 = (unsigned __int8 *)*((void *)v20 + 11);
        goto LABEL_59;
      }
      if (v49 == cur) {
        break;
      }
LABEL_65:
      char *v49 = 0;
      int v53 = (const char *)((uint64_t (*)(char *))*v18)(cur);
      if (v53)
      {
        int v54 = v53;
        if (*v53)
        {
          if (!strncmp(v53, "HTTP/", 5uLL))
          {
            int v55 = v54 + 5;
            unsigned int v56 = *((unsigned __int8 *)v54 + 5);
            if (v56 - 48 > 9)
            {
              int v57 = 0;
            }
            else
            {
              int v57 = 0;
              do
              {
                int v57 = v56 + 10 * v57 - 48;
                unsigned int v58 = *(unsigned __int8 *)++v55;
                unsigned int v56 = v58;
              }
              while (v58 - 48 < 0xA);
            }
            if (v56 == 46)
            {
              int v76 = v55[1];
              uint64_t v74 = v55 + 1;
              int v75 = v76;
              unsigned __int8 v77 = v76 - 48;
              if ((v76 - 48) < 0xA) {
                ++v74;
              }
              int v55 = v74 - 1;
              do
              {
                unsigned int v78 = *(unsigned __int8 *)++v55;
                unsigned int v56 = v78;
              }
              while (v78 - 48 < 0xA);
              int v79 = 10 * v57 + v75 - 48;
              if (v77 < 0xAu) {
                int v57 = v79;
              }
            }
            else
            {
              v57 *= 10;
            }
            if (v56 == 32 || v56 == 9)
            {
              while (v56 == 32 || v56 == 9)
              {
                unsigned int v81 = *(unsigned __int8 *)++v55;
                unsigned int v56 = v81;
              }
              if (v56 - 58 >= 0xFFFFFFF6)
              {
                int v82 = 0;
                uint64_t v83 = 1;
                do
                {
                  int v82 = v56 + 10 * v82 - 48;
                  unsigned int v56 = v55[v83++];
                }
                while (v56 - 48 < 0xA);
                if (v56 <= 0x20 && ((1 << v56) & 0x100000201) != 0)
                {
                  *((_DWORD *)v20 + 26) = v82;
                  *((_DWORD *)v20 + 27) = v57;
                }
              }
            }
            goto LABEL_189;
          }
          if (xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"Content-Type:", 13))
          {
            if (xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"ContentType:", 12))
            {
              if (!xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"Location:", 9))
              {
                for (uint64_t i = (const xmlChar *)(v54 + 9); ; ++i)
                {
                  int v90 = *i;
                  if (v90 != 32 && v90 != 9) {
                    break;
                  }
                }
                if (*((void *)v20 + 16))
                {
                  ((void (*)(void))*v19)();
                  int v90 = *i;
                }
                if (v90 == 47)
                {
                  long long v92 = xmlStrdup((const xmlChar *)"http://");
                  xmlXPathObjectPtr v93 = xmlStrcat(v92, *((const xmlChar **)v20 + 1));
                  uint64_t v94 = xmlStrcat(v93, i);
                }
                else
                {
                  uint64_t v94 = (xmlChar *)((uint64_t (*)(const xmlChar *))*v18)(i);
                }
                *((void *)v20 + 16) = v94;
                goto LABEL_189;
              }
              if (xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"WWW-Authenticate:", 17))
              {
                if (xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"Proxy-Authenticate:", 19))
                {
                  if (xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"Content-Encoding:", 17))
                  {
                    if (!xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"Content-Length:", 15)) {
                      *((_DWORD *)v20 + 28) = strtol(v54 + 15, 0, 10);
                    }
                  }
                  else
                  {
                    for (uint64_t j = (const xmlChar *)(v54 + 17); ; ++j)
                    {
                      int v110 = *j;
                      if (v110 != 32 && v110 != 9) {
                        break;
                      }
                    }
                    if (!xmlStrncasecmp(j, (const xmlChar *)"gzip", 4))
                    {
                      *((_DWORD *)v20 + 42) = 1;
                      uint64_t v112 = (z_stream *)xmlMalloc(0x70uLL);
                      *((void *)v20 + 20) = v112;
                      if (v112)
                      {
                        v112->avail_in = 0;
                        v112->next_in = 0;
                        v112->zxmlParserInputDeallocate free = 0;
                        v112->opaque = 0;
                        v112->zalloc = 0;
                        inflateInit2_(v112, 31, "1.2.12", 112);
                      }
                    }
                  }
LABEL_189:
                  ((void (*)(const char *))*v19)(v54);
                  continue;
                }
                for (uint64_t k = (unsigned __int8 *)(v54 + 19); ; ++k)
                {
                  int v107 = *k;
                  if (v107 != 32 && v107 != 9) {
                    break;
                  }
                }
              }
              else
              {
                for (uint64_t k = (unsigned __int8 *)(v54 + 17); ; ++k)
                {
                  int v96 = *k;
                  if (v96 != 32 && v96 != 9) {
                    break;
                  }
                }
              }
              if (*((void *)v20 + 17)) {
                ((void (*)(void))*v19)();
              }
              *((void *)v20 + 17) = ((uint64_t (*)(unsigned __int8 *))*v18)(k);
              goto LABEL_189;
            }
            if (*((void *)v20 + 15)) {
              goto LABEL_189;
            }
            uint64_t v85 = v54 + 12;
            for (m = (const xmlChar *)(v54 + 12); ; ++m)
            {
              int v87 = *m;
              if (v87 != 32 && v87 != 9) {
                break;
              }
              ++v85;
            }
            uint64_t v98 = ((uint64_t (*)(const xmlChar *))*v18)(m);
            uint64_t v99 = 0;
            *((void *)v20 + 15) = v98;
            while (1)
            {
              unsigned int v100 = m[v99];
              BOOL v65 = v100 > 0x3B;
              uint64_t v101 = (1 << v100) & 0x800100100000201;
              if (!v65 && v101 != 0) {
                break;
              }
              ++v99;
            }
            if (*((void *)v20 + 19)) {
              ((void (*)(void))*v19)();
            }
            *((void *)v20 + 19) = xmlStrndup(m, v99);
            int v103 = xmlStrstr(*((const xmlChar **)v20 + 15), (const xmlChar *)"charset=");
            long long v18 = v21;
            if (!v103) {
              goto LABEL_189;
            }
            uint64_t v69 = 0;
            char v70 = v103 + 8;
            while (1)
            {
              unsigned int v104 = v70[v69];
              BOOL v65 = v104 > 0x3B;
              uint64_t v105 = (1 << v104) & 0x800100100000201;
              if (!v65 && v105 != 0) {
                break;
              }
              ++v69;
            }
          }
          else
          {
            int v59 = v54 + 13;
            for (n = (const xmlChar *)(v54 + 13); ; ++n)
            {
              int v61 = *n;
              if (v61 != 32 && v61 != 9) {
                break;
              }
              ++v59;
            }
            if (*((void *)v20 + 15)) {
              ((void (*)(void))*v19)();
            }
            uint64_t v63 = 0;
            *((void *)v20 + 15) = ((uint64_t (*)(const xmlChar *))*v21)(n);
            while (1)
            {
              unsigned int v64 = n[v63];
              BOOL v65 = v64 > 0x3B;
              uint64_t v66 = (1 << v64) & 0x800100100000201;
              if (!v65 && v66 != 0) {
                break;
              }
              ++v63;
            }
            if (*((void *)v20 + 19)) {
              ((void (*)(void))*v19)();
            }
            *((void *)v20 + 19) = xmlStrndup(n, v63);
            xmlAttrPtr v68 = xmlStrstr(*((const xmlChar **)v20 + 15), (const xmlChar *)"charset=");
            long long v18 = v21;
            if (!v68) {
              goto LABEL_189;
            }
            uint64_t v69 = 0;
            char v70 = v68 + 8;
            while (1)
            {
              unsigned int v71 = v70[v69];
              BOOL v65 = v71 > 0x3B;
              uint64_t v72 = (1 << v71) & 0x800100100000201;
              if (!v65 && v72 != 0) {
                break;
              }
              ++v69;
            }
          }
          if (*((void *)v20 + 18)) {
            ((void (*)(void))*v19)();
          }
          *((void *)v20 + 18) = xmlStrndup(v70, v69);
          long long v18 = v21;
          goto LABEL_189;
        }
        *((void *)v20 + 9) = *((void *)v20 + 11);
        ((void (*)(const char *))*v19)(v53);
      }
      break;
    }
    if (!*((void *)v20 + 16) || (*((_DWORD *)v20 + 26) - 300) > 0x63)
    {
      unsigned int v115 = v124;
      if (v124)
      {
        uint64_t v116 = *((void *)v20 + 15);
        if (v116)
        {
          uint64_t v116 = ((uint64_t (*)(void))*v18)();
          unsigned int v115 = v124;
        }
        void *v115 = v116;
      }
      if (v118 && v23)
      {
        *xmlGenericErrorFunc v118 = v23;
      }
      else
      {
        if (v23) {
          ((void (*)(const char *))*v19)(v23);
        }
        if (v118) {
          *xmlGenericErrorFunc v118 = 0;
        }
      }
      return v20;
    }
    while ((int)xmlNanoHTTPRecv((uint64_t)v20) > 0)
      ;
    if (v121 == 10) {
      goto LABEL_219;
    }
    if (v23) {
      ((void (*)(const char *))*v19)(v23);
    }
    int v16 = v121 + 1;
    fd_set v17 = (const char *)((uint64_t (*)(void))*v18)(*((void *)v20 + 16));
    xmlNanoHTTPFreeCtxt((uint64_t)v20);
    int v14 = v120;
    if (!v17) {
      continue;
    }
    break;
  }
  long long v20 = xmlNanoHTTPNewCtxt(v17);
  if (v20)
  {
    *((void *)v20 + 16) = ((uint64_t (*)(const char *))*v18)(v17);
    goto LABEL_8;
  }
  return v20;
}

int xmlNanoHTTPRead(void *ctx, void *dest, int len)
{
  int v3 = -1;
  if (!ctx || !dest) {
    return v3;
  }
  if (len < 1) {
    return 0;
  }
  if (*((_DWORD *)ctx + 42) == 1)
  {
    uint64_t v7 = (z_stream *)*((void *)ctx + 20);
    if (v7)
    {
      int v8 = 0;
      v7->next_out = (Bytef *)dest;
      v7->avail_out = len;
      int avail_in = *((_DWORD *)ctx + 20) - *((_DWORD *)ctx + 22);
      v7->int avail_in = avail_in;
      do
      {
        if (!v7->avail_out) {
          break;
        }
        if (!avail_in)
        {
          int v10 = xmlNanoHTTPRecv((uint64_t)ctx);
          uint64_t v7 = (z_stream *)*((void *)ctx + 20);
          if (v10 < 1) {
            break;
          }
        }
        uint64_t v11 = *((void *)ctx + 11);
        uInt v12 = *((_DWORD *)ctx + 20) - (v8 + v11);
        v7->int avail_in = v12;
        v7->next_in = (Bytef *)(v11 + v8);
        int v13 = inflate(v7, 0);
        uint64_t v7 = (z_stream *)*((void *)ctx + 20);
        int avail_in = v7->avail_in;
        v8 += v12 - avail_in;
      }
      while (!v13);
      *((void *)ctx + 11) += v8;
      return len - v7->avail_out;
    }
    return 0;
  }
  while (1)
  {
    int v14 = (const void *)*((void *)ctx + 11);
    uint64_t v15 = *((void *)ctx + 10) - (void)v14;
    if (v15 >= len) {
      break;
    }
    if ((int)xmlNanoHTTPRecv((uint64_t)ctx) <= 0)
    {
      int v14 = (const void *)*((void *)ctx + 11);
      uint64_t v15 = *((void *)ctx + 10) - (void)v14;
      break;
    }
  }
  if (v15 >= len) {
    int v3 = len;
  }
  else {
    int v3 = v15;
  }
  memcpy(dest, v14, v3);
  *((void *)ctx + 11) += v3;
  return v3;
}

ssize_t xmlNanoHTTPRecv(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 44) & 2) == 0) {
    return 0;
  }
  pollfd v12 = 0;
  while (1)
  {
    int v3 = *(char **)(a1 + 64);
    if (v3)
    {
      int v4 = *(char **)(a1 + 80);
      int v5 = *(char **)(a1 + 88);
    }
    else
    {
      int v6 = (char *)xmlMallocAtomic(0xFDE8uLL);
      *(void *)(a1 + 64) = v6;
      if (!v6)
      {
        __xmlSimpleError(10, 2, 0, 0, (uint64_t)"allocating input");
        goto LABEL_29;
      }
      int v4 = v6;
      *(_DWORD *)(a1 + 96) = 65000;
      *(void *)(a1 + 80) = v6;
      *(void *)(a1 + 88) = v6;
      int v3 = v6;
      int v5 = v6;
      *(void *)(a1 + 72) = v6;
    }
    if (v5 > v3 + 4096)
    {
      int v7 = v5 - v3;
      memmove(v3, v5, (int)v4 - (int)v5);
      int v5 = (char *)(*(void *)(a1 + 88) - ((int)v5 - (int)v3));
      int v3 = *(char **)(a1 + 64);
      int v4 = (char *)(*(void *)(a1 + 80) - v7);
      *(void *)(a1 + 72) -= v7;
      *(void *)(a1 + 80) = v4;
      *(void *)(a1 + 88) = v5;
    }
    uint64_t v8 = *(int *)(a1 + 96);
    if (&v3[v8] < v4 + 4096)
    {
      uint64_t v9 = *(void *)(a1 + 72);
      *(_DWORD *)(a1 + 96) = 2 * v8;
      int v10 = (char *)xmlRealloc(v3, 2 * v8);
      *(void *)(a1 + 64) = v10;
      if (v10)
      {
        int v4 = &v10[(int)v4 - (int)v3];
        *(void *)(a1 + 72) = &v10[(int)v9 - (int)v3];
        *(void *)(a1 + 80) = v4;
        *(void *)(a1 + 88) = &v10[(int)v5 - (int)v3];
        goto LABEL_14;
      }
      __xmlSimpleError(10, 2, 0, 0, (uint64_t)"allocating input buffer");
      xmlFree(v3);
LABEL_29:
      ssize_t result = 0xFFFFFFFFLL;
      *(_DWORD *)(a1 + 100) = -1;
      return result;
    }
LABEL_14:
    ssize_t result = recv(*(_DWORD *)(a1 + 40), v4, 0x1000uLL, 0);
    *(_DWORD *)(a1 + 100) = result;
    if ((int)result >= 1)
    {
      *(void *)(a1 + 80) += result;
      return result;
    }
    if (result != -1)
    {
      if (!result) {
        return result;
      }
      goto LABEL_19;
    }
    int v11 = *__error();
    if ((v11 - 35) >= 2) {
      break;
    }
LABEL_19:
    v12.fd = *(_DWORD *)(a1 + 40);
    v12.events = 1;
    if (poll(&v12, 1u, 60000) <= 0 && *__error() != 4 || (*(unsigned char *)(a1 + 44) & 2) == 0) {
      return 0;
    }
  }
  ssize_t result = 0;
  if (v11 != 54 && v11 != 58)
  {
    __xmlIOErr(10, 0, (uint64_t)"recv failed\n");
    return 0xFFFFFFFFLL;
  }
  return result;
}

void xmlNanoHTTPClose(void *ctx)
{
  if (ctx) {
    xmlNanoHTTPFreeCtxt((uint64_t)ctx);
  }
}

uint64_t xmlNanoHTTPFreeCtxt(uint64_t a1)
{
  xmlURIPtr v2 = *(void **)(a1 + 8);
  if (v2) {
    xmlFree(v2);
  }
  if (*(void *)a1) {
    xmlFree(*(void **)a1);
  }
  int v3 = *(void **)(a1 + 24);
  if (v3) {
    xmlFree(v3);
  }
  int v4 = *(void **)(a1 + 32);
  if (v4) {
    xmlFree(v4);
  }
  int v5 = *(void **)(a1 + 48);
  if (v5) {
    xmlFree(v5);
  }
  int v6 = *(void **)(a1 + 64);
  if (v6) {
    xmlFree(v6);
  }
  int v7 = *(void **)(a1 + 120);
  if (v7) {
    xmlFree(v7);
  }
  uint64_t v8 = *(void **)(a1 + 144);
  if (v8) {
    xmlFree(v8);
  }
  uint64_t v9 = *(void **)(a1 + 152);
  if (v9) {
    xmlFree(v9);
  }
  int v10 = *(void **)(a1 + 128);
  if (v10) {
    xmlFree(v10);
  }
  int v11 = *(void **)(a1 + 136);
  if (v11) {
    xmlFree(v11);
  }
  pollfd v12 = *(z_stream **)(a1 + 160);
  if (v12)
  {
    inflateEnd(v12);
    xmlFree(*(void **)(a1 + 160));
  }
  *(_DWORD *)(a1 + 44) = 4;
  int v13 = *(_DWORD *)(a1 + 40);
  if (v13 != -1) {
    close(v13);
  }
  *(_DWORD *)(a1 + 40) = -1;
  xmlFreeFunc v14 = xmlFree;

  return ((uint64_t (*)(uint64_t))v14)(a1);
}

_OWORD *xmlNanoHTTPNewCtxt(const char *a1)
{
  xmlURIPtr v2 = xmlMalloc(0xB0uLL);
  int v3 = v2;
  if (v2)
  {
    v2[6] = 0u;
    v2[7] = 0u;
    *xmlURIPtr v2 = 0u;
    v2[1] = 0u;
    v2[9] = 0u;
    v2[10] = 0u;
    v2[8] = 0u;
    v2[4] = 0u;
    v2[5] = 0u;
    v2[2] = 0u;
    v2[3] = 0u;
    *((_DWORD *)v2 + 4) = 80;
    *((_DWORD *)v2 + 26) = 0;
    *((_DWORD *)v2 + 10) = -1;
    *((_DWORD *)v2 + 28) = -1;
    int v4 = *(void **)v2;
    if (*(void *)v3)
    {
      xmlFree(v4);
      *(void *)int v3 = 0;
    }
    int v5 = (void *)*((void *)v3 + 1);
    if (v5)
    {
      xmlFree(v5);
      *((void *)v3 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0;
    }
    int v6 = (void *)*((void *)v3 + 3);
    if (v6)
    {
      xmlFree(v6);
      *((void *)v3 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0;
    }
    int v7 = (void *)*((void *)v3 + 4);
    if (v7)
    {
      xmlFree(v7);
      *((void *)v3 + 4) = 0;
    }
    xmlURIPtr v8 = xmlParseURIRaw(a1, 1);
    if (v8)
    {
      uint64_t v9 = v8;
      scheme = v8->scheme;
      if (scheme && v9->server)
      {
        *(void *)int v3 = xmlMemStrdup(scheme);
        server = v9->server;
        if (server && *server == 91 && (int v12 = strlen(v9->server), v12 >= 3) && server[v12 - 1] == 93) {
          int v13 = xmlCharStrndup(server + 1, v12 - 2);
        }
        else {
          int v13 = xmlMemStrdup(server);
        }
        *((void *)v3 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v13;
        if (v9->path) {
          path = v9->path;
        }
        else {
          path = "/";
        }
        *((void *)v3 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = xmlMemStrdup(path);
        query = v9->query;
        if (query) {
          *((void *)v3 + 4) = xmlMemStrdup(query);
        }
        int port = v9->port;
        if (port) {
          *((_DWORD *)v3 + 4) = port;
        }
      }
      xmlFreeURI(v9);
    }
  }
  else
  {
    __xmlSimpleError(10, 2, 0, 0, (uint64_t)"allocating context");
  }
  return v3;
}

uint64_t xmlNanoHTTPConnectHost(const char *a1, unsigned int a2)
{
  v25[2] = *MEMORY[0x1E4F143B8];
  long long v24 = 0uLL;
  v25[0] = 0;
  v25[1] = 0;
  long long v22 = 0uLL;
  uint64_t v21 = 0;
  int v23 = 0;
  if (!have_ipv6())
  {
    v20.ai_flags = 0;
    int v5 = gethostbyname(a1);
    if (!v5)
    {
      int v4 = "Failed to resolve host";
      goto LABEL_35;
    }
    int v6 = v5;
    if (*v5->h_addr_list)
    {
      uint64_t v7 = 0;
      unsigned int v8 = bswap32(a2) >> 16;
      do
      {
        if (v6->h_addrtype == 2)
        {
          if (v6->h_length >= 5u) {
            goto LABEL_34;
          }
          __memcpy_chk();
          BYTE1(v25[0]) = 2;
          HIDWORD(v25[0]) = v20.ai_flags;
          uint64_t v9 = v25;
        }
        else
        {
          if (!have_ipv6() || v6->h_addrtype != 30) {
            return 0xFFFFFFFFLL;
          }
          if (v6->h_length >= 0x11u)
          {
LABEL_34:
            int v4 = "address size mismatch\n";
LABEL_35:
            __xmlIOErr(10, 0, (uint64_t)v4);
            return 0xFFFFFFFFLL;
          }
          __memcpy_chk();
          BYTE1(v2htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 30;
          long long v22 = v24;
          uint64_t v9 = &v21;
        }
        *((_WORD *)v9 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v8;
        uint64_t v10 = xmlNanoHTTPConnectAttempt((const sockaddr *)v9);
        if (v10 != -1) {
          return v10;
        }
      }
      while (v6->h_addr_list[++v7]);
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v19 = 0;
  memset(&v20, 0, sizeof(v20));
  v20.ai_sockxmlElementType type = 1;
  if (getaddrinfo(a1, 0, &v20, &v19))
  {
    int v4 = "getaddrinfo failed\n";
    goto LABEL_35;
  }
  int v12 = v19;
  if (!v19) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v13 = bswap32(a2) >> 16;
  while (1)
  {
    if (v12->ai_family == 2)
    {
      if (v12->ai_addrlen >= 0x11) {
        goto LABEL_31;
      }
      xmlFreeFunc v14 = v25;
    }
    else
    {
      if (!have_ipv6() || v12->ai_family != 30) {
        goto LABEL_27;
      }
      if (v12->ai_addrlen >= 0x1D)
      {
LABEL_31:
        __xmlIOErr(10, 0, (uint64_t)"address size mismatch\n");
        int v16 = v19;
LABEL_32:
        freeaddrinfo(v16);
        return 0xFFFFFFFFLL;
      }
      xmlFreeFunc v14 = &v21;
    }
    __memcpy_chk();
    *((_WORD *)v14 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v13;
    uint64_t v15 = xmlNanoHTTPConnectAttempt((const sockaddr *)v14);
    if (v15 != -1) {
      break;
    }
LABEL_27:
    int v12 = v12->ai_next;
    if (!v12)
    {
      int v16 = v19;
      if (!v19) {
        return 0xFFFFFFFFLL;
      }
      goto LABEL_32;
    }
  }
  uint64_t v17 = v15;
  freeaddrinfo(v19);
  return v17;
}

uint64_t xmlNanoHTTPSend(uint64_t result, uint64_t a2, int a3)
{
  if (a2)
  {
    uint64_t v4 = result;
    if ((*(_DWORD *)(result + 44) & 1) != 0 && a3 >= 1)
    {
      int v7 = 0;
      pollfd v8 = 0;
      do
      {
        ssize_t result = send(*(_DWORD *)(v4 + 40), (const void *)(a2 + v7), a3 - v7, 0);
        if ((int)result < 1)
        {
          if (result == -1 && *__error() != 35) {
            return __xmlIOErr(10, 0, (uint64_t)"send failed\n");
          }
          v8.fd = *(_DWORD *)(v4 + 40);
          v8.events = 4;
          ssize_t result = poll(&v8, 1u, 60000);
        }
        else
        {
          v7 += result;
        }
      }
      while (v7 < a3);
    }
  }
  return result;
}

int xmlNanoHTTPFetch(const char *URL, const char *filename, char **contentType)
{
  *(void *)&__nbyte[1] = 0;
  if (!filename) {
    return -1;
  }
  if (contentType) {
    *contentType = 0;
  }
  int v5 = xmlNanoHTTPMethodRedir(URL, 0, 0, contentType, 0, 0, 0);
  if (!v5) {
    return -1;
  }
  uint64_t v6 = (uint64_t)v5;
  if (!strcmp(filename, "-"))
  {
    int v7 = 0;
  }
  else
  {
    int v7 = open(filename, 513, 420);
    if (v7 < 0)
    {
      xmlNanoHTTPFreeCtxt(v6);
      if (contentType && *contentType)
      {
        xmlFree(*contentType);
        *contentType = 0;
      }
      return -1;
    }
  }
  __nbyte[0] = 0;
  xmlNanoHTTPFetchContent(v6, &__nbyte[1], __nbyte);
  if (__nbyte[0] < 1)
  {
    int v8 = 0;
  }
  else if (write(v7, *(const void **)&__nbyte[1], __nbyte[0]) == -1)
  {
    int v8 = -1;
  }
  else
  {
    int v8 = 0;
  }
  xmlNanoHTTPFreeCtxt(v6);
  close(v7);
  return v8;
}

ssize_t xmlNanoHTTPFetchContent(ssize_t result, void *a2, int *a3)
{
  uint64_t v5 = *(void *)(result + 72);
  if (v5)
  {
    uint64_t v6 = result;
    int v7 = *(_DWORD *)(result + 80) - v5;
    do
    {
      ssize_t result = xmlNanoHTTPRecv(v6);
      if ((int)result < 1) {
        break;
      }
      v7 += result;
      int v8 = *(_DWORD *)(v6 + 112);
    }
    while (v8 < 1 || v7 < v8);
    if (a2) {
      *a2 = *(void *)(v6 + 72);
    }
    if (a3) {
      *a3 = v7;
    }
  }
  else
  {
    if (a3) {
      *a3 = 0;
    }
    if (a2) {
      *a2 = 0;
    }
  }
  return result;
}

int xmlNanoHTTPSave(void *ctxt, const char *filename)
{
  *(void *)&__nbyte[1] = 0;
  int v2 = -1;
  if (ctxt && filename)
  {
    if (!strcmp(filename, "-"))
    {
      int v5 = 0;
    }
    else
    {
      int v5 = open(filename, 513, 438);
      if (v5 < 0)
      {
        xmlNanoHTTPFreeCtxt((uint64_t)ctxt);
        return v2;
      }
    }
    __nbyte[0] = 0;
    xmlNanoHTTPFetchContent((ssize_t)ctxt, &__nbyte[1], __nbyte);
    if (__nbyte[0] < 1)
    {
      int v2 = 0;
    }
    else if (write(v5, *(const void **)&__nbyte[1], __nbyte[0]) == -1)
    {
      int v2 = -1;
    }
    else
    {
      int v2 = 0;
    }
    xmlNanoHTTPFreeCtxt((uint64_t)ctxt);
    close(v5);
  }
  return v2;
}

int xmlNanoHTTPReturnCode(void *ctx)
{
  if (ctx) {
    return *((_DWORD *)ctx + 26);
  }
  else {
    return -1;
  }
}

const char *__cdecl xmlNanoHTTPAuthHeader(const char *ctx)
{
  if (ctx) {
    return (const char *)*((void *)ctx + 17);
  }
  return ctx;
}

int xmlNanoHTTPContentLength(void *ctx)
{
  if (ctx) {
    return *((_DWORD *)ctx + 28);
  }
  else {
    return -1;
  }
}

const char *__cdecl xmlNanoHTTPRedir(const char *ctx)
{
  if (ctx) {
    return (const char *)*((void *)ctx + 16);
  }
  return ctx;
}

const char *__cdecl xmlNanoHTTPEncoding(const char *ctx)
{
  if (ctx) {
    return (const char *)*((void *)ctx + 18);
  }
  return ctx;
}

const char *__cdecl xmlNanoHTTPMimeType(const char *ctx)
{
  if (ctx) {
    return (const char *)*((void *)ctx + 19);
  }
  return ctx;
}

uint64_t have_ipv6()
{
  int v0 = socket(30, 1, 0);
  if (v0 == -1) {
    return 0;
  }
  close(v0);
  return 1;
}

uint64_t xmlNanoHTTPConnectAttempt(const sockaddr *a1)
{
  int sa_family = a1->sa_family;
  if (sa_family == 30) {
    int v3 = 30;
  }
  else {
    int v3 = 2;
  }
  if (sa_family == 30) {
    socklen_t v4 = 28;
  }
  else {
    socklen_t v4 = 16;
  }
  uint64_t v5 = socket(v3, 1, 6);
  uint64_t v6 = v5;
  if (v5 == -1)
  {
    __xmlIOErr(10, 0, (uint64_t)"socket failed\n");
    return v6;
  }
  int v7 = fcntl(v5, 3, 0);
  if (v7 == -1 || (int v13 = fcntl(v6, 4, v7 | 4u), v13 < 0))
  {
    uint64_t v9 = "error setting non-blocking IO\n";
  }
  else
  {
    pollfd v14 = 0;
    if (connect(v6, a1, v4) == -1 && (*__error() - 35) >= 2)
    {
      uint64_t v9 = "error connecting to HTTP server";
    }
    else
    {
      v14.fd = v6;
      v14.events = 4;
      int v8 = poll(&v14, 1u, 60000);
      if (v8 == -1)
      {
        uint64_t v9 = "Connect failed";
      }
      else if (v8)
      {
        if (v14.revents == 4)
        {
          socklen_t revents = (unsigned __int16)v14.revents;
          if ((getsockopt(v6, 0xFFFF, 4103, &v13, &revents) & 0x80000000) == 0)
          {
            if (!v13) {
              return v6;
            }
            __xmlIOErr(10, 0, (uint64_t)"Error connecting to remote host");
            close(v6);
            int v11 = v13;
            *__error() = v11;
            return 0xFFFFFFFFLL;
          }
          uint64_t v9 = "getsockopt failed\n";
        }
        else
        {
          uint64_t v9 = "select failed\n";
        }
      }
      else
      {
        uint64_t v9 = "Connect attempt timed out";
      }
    }
  }
  __xmlIOErr(10, 0, (uint64_t)v9);
  close(v6);
  return 0xFFFFFFFFLL;
}

int xmlHasFeature(xmlFeature feature)
{
  if (feature - 1 > 0x20) {
    return 0;
  }
  else {
    return dword_1B51A8284[feature - 1];
  }
}

int xmlCheckLanguageID(const xmlChar *lang)
{
  if (lang)
  {
    unsigned int v1 = *lang;
    if (v1 > 0x68)
    {
      if (v1 != 120 && v1 != 105) {
        goto LABEL_12;
      }
    }
    else if (v1 != 73 && v1 != 88)
    {
LABEL_12:
      uint64_t v6 = 0;
      do
        int v7 = lang[v6++];
      while ((v7 & 0xFFFFFFDF) - 65 < 0x1A);
      uint64_t v8 = v6 - 1;
      if (v6 - 1 >= 4)
      {
        BOOL v5 = (unint64_t)v8 < 9 && v7 == 0;
LABEL_18:
        LODWORD(lang) = v5;
        return (int)lang;
      }
      if (v8 >= 2)
      {
        if (!v7) {
          goto LABEL_59;
        }
        if (v7 == 45)
        {
          uint64_t v9 = &lang[v6];
          int v10 = lang[v6];
          if ((v10 - 48) < 0xA) {
            goto LABEL_26;
          }
          if ((v10 & 0xFFFFFFDF) - 65 <= 0x19)
          {
            do
            {
              int v12 = *++v9;
              int v10 = v12;
            }
            while ((v12 & 0xFFFFFFDF) - 65 < 0x1A);
          }
          uint64_t v13 = v9 - lang - v6;
          if (v13 == 2) {
            goto LABEL_53;
          }
          if (v13 == 4) {
            goto LABEL_33;
          }
          if ((unint64_t)(v13 - 5) < 4) {
            goto LABEL_60;
          }
          if (v9 - lang - 3 == v6)
          {
            if (!v10) {
              goto LABEL_59;
            }
            if (v10 == 45)
            {
              pollfd v14 = v9 + 1;
              if (v9[1] - 48 < 0xA) {
                goto LABEL_36;
              }
              uint64_t v15 = 0;
              do
                int v10 = v9[++v15];
              while ((v10 & 0xFFFFFFDF) - 65 < 0x1A);
              v9 += v15;
              if (v15 == 3) {
                goto LABEL_53;
              }
              if ((unint64_t)(v15 - 6) < 4) {
                goto LABEL_60;
              }
              if (v15 == 5)
              {
LABEL_33:
                if (!v10) {
                  goto LABEL_59;
                }
                if (v10 == 45)
                {
                  pollfd v14 = v9 + 1;
                  if (v9[1] - 48 < 0xA)
                  {
LABEL_36:
                    uint64_t v9 = v14;
LABEL_26:
                    if (v9[1] - 48 > 9 || v9[2] - 48 > 9) {
                      goto LABEL_58;
                    }
                    int v11 = v9[3];
                    v9 += 3;
                    int v10 = v11;
LABEL_53:
                    if (v10)
                    {
                      if (v10 != 45) {
                        goto LABEL_58;
                      }
                      uint64_t v17 = 1;
                      do
                        int v10 = v9[v17++];
                      while ((v10 & 0xFFFFFFDF) - 65 < 0x1A);
                      if ((unint64_t)(v17 - 11) < 0xFFFFFFFFFFFFFFFCLL) {
                        goto LABEL_58;
                      }
LABEL_60:
                      if (v10) {
                        BOOL v5 = v10 == 45;
                      }
                      else {
                        BOOL v5 = 1;
                      }
                      goto LABEL_18;
                    }
LABEL_59:
                    LODWORD(lang) = 1;
                    return (int)lang;
                  }
                  uint64_t v16 = 0;
                  do
                    int v10 = v9[++v16];
                  while ((v10 & 0xFFFFFFDF) - 65 < 0x1A);
                  if ((unint64_t)(v16 - 6) < 4) {
                    goto LABEL_60;
                  }
                  if (v16 == 3)
                  {
                    v9 += 3;
                    goto LABEL_53;
                  }
                }
              }
            }
          }
        }
      }
LABEL_58:
      LODWORD(lang) = 0;
      return (int)lang;
    }
    if (lang[1] == 45)
    {
      int v2 = lang + 2;
      do
      {
        int v4 = *v2++;
        int v3 = v4;
      }
      while ((v4 & 0xFFFFFFDF) - 65 < 0x1A);
      BOOL v5 = v3 == 0;
      goto LABEL_18;
    }
    goto LABEL_12;
  }
  return (int)lang;
}

_DWORD *xmlFatalErrMsgInt(_DWORD *result, int a2, const char *a3, int a4)
{
  if (!result) {
    return __xmlRaiseError(0, 0, 0, 0, 0, 1u, a2, 3, 0, 0, 0, 0, 0, a4, 0, a3, a4);
  }
  int v4 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    ssize_t result = __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 3, 0, 0, 0, 0, 0, a4, 0, a3, a4);
    v4[6] = 0;
    if (!v4[112]) {
      v4[83] = 1;
    }
  }
  return result;
}

int namePush(xmlParserCtxtPtr ctxt, const xmlChar *value)
{
  if (!ctxt) {
    return -1;
  }
  int result = ctxt->nameNr;
  uint64_t nameMax = ctxt->nameMax;
  if (result < (int)nameMax)
  {
    nameTab = ctxt->nameTab;
LABEL_7:
    nameTab[result] = value;
    ctxt->name = value;
    ctxt->uint64_t nameNr = result + 1;
    return result;
  }
  int v7 = (const xmlChar **)xmlRealloc(ctxt->nameTab, 16 * nameMax);
  if (v7)
  {
    nameTab = v7;
    ctxt->nameTab = v7;
    ctxt->nameMax *= 2;
    int result = ctxt->nameNr;
    goto LABEL_7;
  }
  htmlErrMemory(ctxt, 0);
  return -1;
}

const xmlChar *__cdecl namePop(const xmlChar *ctxt)
{
  if (ctxt)
  {
    int v1 = *((_DWORD *)ctxt + 74);
    unsigned int v2 = v1 - 1;
    if (v1 < 1)
    {
      return 0;
    }
    else
    {
      *((_DWORD *)ctxt + 74) = v2;
      uint64_t v3 = *((void *)ctxt + 38);
      if (v1 == 1) {
        uint64_t v4 = 0;
      }
      else {
        uint64_t v4 = *(void *)(v3 + 8 * (v1 - 2));
      }
      *((void *)ctxt + 36) = v4;
      ctxt = *(const xmlChar **)(v3 + 8 * v2);
      *(void *)(v3 + 8 * v2) = 0;
    }
  }
  return ctxt;
}

void xmlParsePEReference(xmlParserCtxtPtr ctxt)
{
  if (*ctxt->input->cur == 37)
  {
    xmlNextChar(ctxt);
    unsigned int v2 = xmlParseName(ctxt);
    if (v2)
    {
      uint64_t v3 = (const char *)v2;
      if (*__xmlParserDebugEntities())
      {
        xmlGenericErrorFunc v4 = *__xmlGenericError();
        BOOL v5 = __xmlGenericErrorContext();
        v4(*v5, "PEReference: %s\n", v3);
      }
      if (*ctxt->input->cur == 59)
      {
        xmlNextChar(ctxt);
        ++ctxt->nbentities;
        if (ctxt->sax && (getParameterEntitySAXFunc getParameterEntity = ctxt->sax->getParameterEntity) != 0) {
          uint64_t v7 = ((uint64_t (*)(void *, const char *))getParameterEntity)(ctxt->userData, v3);
        }
        else {
          uint64_t v7 = 0;
        }
        if (ctxt->instate != XML_PARSER_EOF)
        {
          if (!v7)
          {
            if (ctxt->standalone != 1 && (ctxt->hasExternalSubset || ctxt->hasPErefs))
            {
              if (ctxt->validate && ctxt->vctxt.error) {
                xmlValidityError(ctxt, 27, "PEReference: %%%s; not found\n", (const xmlChar *)v3, 0);
              }
              else {
                xmlWarningMsg(ctxt, 27, "PEReference: %%%s; not found\n", (const xmlChar *)v3);
              }
              ctxt->valint id = 0;
            }
            else
            {
              xmlFatalErrMsgStr(ctxt, 26, "PEReference: %%%s; not found\n", (const xmlChar *)v3);
            }
            xmlParserEntityCheck((uint64_t)ctxt, 0, 0, 0);
            goto LABEL_52;
          }
          if ((*(_DWORD *)(v7 + 92) & 0xFFFFFFFE) != 4)
          {
            xmlWarningMsg(ctxt, 27, "Internal: %%%s; is not a parameter entity\n", (const xmlChar *)v3);
LABEL_52:
            ctxt->hasPErefs = 1;
            return;
          }
          *(_DWORD *)in = 0;
          if (!xmlParserEntityCheck((uint64_t)ctxt, 0, v7, 0)
            && (*(_DWORD *)(v7 + 92) != 5 || (ctxt->options & 0x1E) != 0 || ctxt->replaceEntities || ctxt->validate))
          {
            uint64_t v8 = xmlNewEntityInputStream(ctxt, (xmlEntityPtr)v7);
            if (xmlPushInput(ctxt, v8) < 0)
            {
              xmlFreeInputStream(v8);
              return;
            }
            if (*(_DWORD *)(v7 + 92) != 5) {
              goto LABEL_52;
            }
            if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
              xmlGROW((uint64_t)ctxt);
            }
            if (ctxt->instate != XML_PARSER_EOF)
            {
              cur = ctxt->input->cur;
              if (ctxt->input->end - cur >= 4)
              {
                *(_DWORD *)in = *(_DWORD *)cur;
                xmlCharEncoding v10 = xmlDetectCharEncoding(in, 4);
                if (v10) {
                  xmlSwitchEncoding(ctxt, v10);
                }
              }
              int v11 = ctxt->input->cur;
              if (*v11 == 60 && v11[1] == 63 && v11[2] == 120 && v11[3] == 109 && v11[4] == 108)
              {
                unsigned int v12 = v11[5];
                if (v12 <= 0x20 && ((1 << v12) & 0x100002600) != 0) {
                  xmlParseTextDecl(ctxt);
                }
              }
              goto LABEL_52;
            }
          }
        }
      }
      else
      {
        xmlFatalErr(ctxt, 25, 0);
      }
    }
    else
    {
      xmlFatalErrMsg(ctxt, 24, (char)"PEReference: no name\n");
    }
  }
}

xmlChar xmlPopInput(xmlParserCtxtPtr ctxt)
{
  if (!ctxt) {
    return ctxt;
  }
  xmlParserCtxtPtr v1 = ctxt;
  if (ctxt->inputNr < 2)
  {
    LOBYTE(ctxt) = 0;
    return ctxt;
  }
  if (*__xmlParserDebugEntities())
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    uint64_t v3 = __xmlGenericErrorContext();
    v2(*v3, "Popping input %d\n", v1->inputNr);
  }
  int inputNr = v1->inputNr;
  unsigned int v5 = inputNr - 1;
  if (inputNr > 1)
  {
    if (v1->inSubset || v1->instate == XML_PARSER_EOF)
    {
      v1->int inputNr = v5;
      inputTab = v1->inputTab;
      goto LABEL_14;
    }
    xmlFatalErr(v1, 1, (const xmlChar *)"Unfinished entity outside the DTD");
    int inputNr = v1->inputNr;
  }
  unsigned int v5 = inputNr - 1;
  if (inputNr >= 1)
  {
    v1->int inputNr = v5;
    inputTab = v1->inputTab;
    if (inputNr == 1)
    {
      unsigned int v5 = 0;
      uint64_t v7 = 0;
LABEL_15:
      v1->xmlParserInputPtr input = v7;
      uint64_t v8 = inputTab[v5];
      inputTab[v5] = 0;
      goto LABEL_17;
    }
LABEL_14:
    uint64_t v7 = inputTab[inputNr - 2];
    goto LABEL_15;
  }
  uint64_t v8 = 0;
LABEL_17:
  xmlFreeInputStream(v8);
  LOBYTE(ctxt) = *v1->input->cur;
  if (!(_BYTE)ctxt)
  {
    xmlParserInputGrow(v1->input, 250);
    LOBYTE(ctxt) = *v1->input->cur;
  }
  return ctxt;
}

int xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input)
{
  if (!input) {
    return -1;
  }
  if (*__xmlParserDebugEntities())
  {
    xmlParserInputPtr v4 = ctxt->input;
    if (v4 && v4->filename)
    {
      xmlGenericErrorFunc v5 = *__xmlGenericError();
      uint64_t v6 = __xmlGenericErrorContext();
      v5(*v6, "%s(%d): ", ctxt->input->filename, ctxt->input->line);
    }
    xmlGenericErrorFunc v7 = *__xmlGenericError();
    uint64_t v8 = __xmlGenericErrorContext();
    v7(*v8, "Pushing input %d : %.30s\n", ctxt->inputNr + 1, (const char *)input->cur);
  }
  int inputNr = ctxt->inputNr;
  if (inputNr >= 41 && (inputNr > 0x400 || (ctxt->options & 0x80000) == 0))
  {
    xmlFatalErr(ctxt, 89, 0);
    int v11 = ctxt->inputNr;
    if (v11 >= 2)
    {
      do
      {
        unsigned int v12 = v11 - 1;
        inputTab = ctxt->inputTab;
        pollfd v14 = inputTab[v11 - 2];
        ctxt->int inputNr = v12;
        ctxt->xmlParserInputPtr input = v14;
        uint64_t v15 = inputTab[v12];
        inputTab[v12] = 0;
        xmlFreeInputStream(v15);
        int v11 = ctxt->inputNr;
      }
      while (v11 > 1);
    }
    return -1;
  }
  if (ctxt->instate == XML_PARSER_EOF) {
    return -1;
  }
  int v10 = inputPush(ctxt, input);
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  return v10;
}

void xmlParserHandlePEReference(xmlParserCtxtPtr ctxt)
{
  switch(ctxt->instate)
  {
    case XML_PARSER_EOF:
      int v1 = 18;
      goto LABEL_14;
    case XML_PARSER_START:
    case XML_PARSER_MISC:
    case XML_PARSER_PROLOG:
      int v1 = 19;
      goto LABEL_14;
    case XML_PARSER_PI:
    case XML_PARSER_COMMENT:
    case XML_PARSER_START_TAG:
    case XML_PARSER_CONTENT:
    case XML_PARSER_CDATA_SECTION:
    case XML_PARSER_END_TAG:
    case XML_PARSER_ENTITY_DECL:
    case XML_PARSER_ENTITY_VALUE:
    case XML_PARSER_ATTRIBUTE_VALUE:
    case XML_PARSER_SYSTEM_LITERAL:
    case XML_PARSER_IGNORE:
    case XML_PARSER_PUBLIC_LITERAL:
      return;
    case XML_PARSER_DTD:
      if (!ctxt->external && ctxt->inputNr == 1) {
        return;
      }
      unsigned int v2 = *((unsigned __int8 *)ctxt->input->cur + 1);
      BOOL v3 = v2 > 0x20;
      uint64_t v4 = (1 << v2) & 0x100002601;
      if (!v3 && v4 != 0) {
        return;
      }
      goto LABEL_12;
    case XML_PARSER_EPILOG:
      int v1 = 20;
LABEL_14:
      xmlFatalErr(ctxt, v1, 0);
      break;
    default:
LABEL_12:
      xmlParsePEReference(ctxt);
      break;
  }
}

xmlChar *__cdecl xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len, int what, xmlChar end, xmlChar end2, xmlChar end3)
{
  xmlGenericErrorFunc v7 = 0;
  int lena = 0;
  if (!ctxt) {
    return v7;
  }
  uint64_t v8 = str;
  if (!str || len < 0) {
    return v7;
  }
  int v10 = end3;
  int v11 = end2;
  int v12 = end;
  xmlParserCtxtPtr v14 = ctxt;
  int depth = ctxt->depth;
  if (depth >= 41 && (depth > 0x400 || (ctxt->options & 0x80000) == 0))
  {
    xmlFatalErr(ctxt, 89, 0);
    return 0;
  }
  uint64_t v16 = (xmlChar *)xmlMallocAtomic(0x12CuLL);
  if (!v16) {
    goto LABEL_252;
  }
  if (len) {
    int v17 = xmlStringCurrentChar(v14, v8, &lena);
  }
  else {
    int v17 = 0;
  }
  uint64_t v18 = 0;
  if (v17 == v10 || v17 == v11 || !v17 || v17 == v12)
  {
LABEL_259:
    xmlGenericErrorFunc v7 = v16;
    goto LABEL_260;
  }
  uint64_t v18 = 0;
  int v96 = &v8[len];
  unint64_t v97 = 300;
  int v95 = what;
LABEL_17:
  if (v14->instate == XML_PARSER_EOF) {
    goto LABEL_259;
  }
  uint64_t v98 = v18;
  if (v17 == 38)
  {
    if (v8[1] == 35)
    {
      if (*v8 != 38)
      {
        xmlFatalErr(v14, 8, 0);
        goto LABEL_256;
      }
      addrinfo v20 = v8 + 2;
      int v19 = v8[2];
      if (v19 == 59)
      {
        int v24 = 0;
        uint64_t v42 = 1;
      }
      else
      {
        if (v19 == 120)
        {
          int v23 = v8[3];
          long long v22 = v8 + 3;
          int v21 = v23;
          if (v23 == 59)
          {
            int v24 = 0;
            uint64_t v25 = 1;
            unint64_t v26 = v97;
            goto LABEL_98;
          }
          int v24 = 0;
          unint64_t v26 = v97;
          while (1)
          {
            if ((v21 - 48) >= 0xA)
            {
              if ((v21 - 97) >= 6)
              {
                if ((v21 - 65) >= 6)
                {
                  xmlFatalErr(v14, 6, 0);
                  uint64_t v25 = 0;
                  int v24 = 0;
LABEL_98:
                  int v31 = &v22[v25];
LABEL_99:
                  if (v24 >= 1114112)
                  {
                    long long v89 = "xmlParseStringCharRef: character reference out of bounds\n";
                  }
                  else
                  {
                    if (v24 <= 255)
                    {
                      if (v24 <= 31 && (v24 > 0xD || ((1 << v24) & 0x2600) == 0)) {
                        goto LABEL_264;
                      }
LABEL_107:
                      v18 += xmlCopyCharMultiByte(&v16[v18], v24);
LABEL_108:
                      if (v18 + 100 > v26)
                      {
                        size_t v55 = 2 * v26 + 100;
                        if (v55 >= v26) {
                          goto LABEL_110;
                        }
LABEL_252:
                        uint64_t v74 = 0;
                        goto LABEL_253;
                      }
LABEL_204:
                      xmlGenericErrorFunc v7 = v16;
LABEL_205:
                      if (v31 >= v96) {
                        int v17 = 0;
                      }
                      else {
                        int v17 = xmlStringCurrentChar(v14, v31, &lena);
                      }
                      if (v17 == v10 || v17 == v11 || !v17 || (v16 = v7, uint64_t v8 = v31, v17 == v12))
                      {
LABEL_260:
                        v7[v18] = 0;
                        return v7;
                      }
                      goto LABEL_17;
                    }
                    if ((v24 - 0x10000) < 0xFFFFD800 || (v24 - 57344) >> 1 < 0xFFF) {
                      goto LABEL_107;
                    }
LABEL_264:
                    long long v89 = "xmlParseStringCharRef: invalid xmlChar value %d\n";
                  }
                  xmlFatalErrMsgInt(v14, 9, v89, v24);
                  goto LABEL_256;
                }
                int v45 = -55;
              }
              else
              {
                int v45 = -87;
              }
            }
            else
            {
              int v45 = -48;
            }
            int v46 = v21 + 16 * v24 + v45;
            if (v46 >= 1114112) {
              int v24 = 1114112;
            }
            else {
              int v24 = v46;
            }
            int v47 = *++v22;
            int v21 = v47;
            if (v47 == 59)
            {
              uint64_t v25 = 1;
              goto LABEL_98;
            }
          }
        }
        int v24 = 0;
        do
        {
          if ((v19 - 48) > 9)
          {
            xmlFatalErr(v14, 7, 0);
            uint64_t v42 = 0;
            int v24 = 0;
            goto LABEL_60;
          }
          int v43 = v19 + 10 * v24 - 48;
          if (v43 >= 1114112) {
            int v24 = 1114112;
          }
          else {
            int v24 = v43;
          }
          int v44 = *++v20;
          int v19 = v44;
        }
        while (v44 != 59);
        uint64_t v42 = 1;
      }
LABEL_60:
      int v31 = &v20[v42];
      unint64_t v26 = v97;
      goto LABEL_99;
    }
    if ((what & 1) == 0)
    {
LABEL_37:
      unint64_t v26 = v97;
      if (lena == 1)
      {
        v16[v18++] = v17;
        what = v95;
      }
      else
      {
        v18 += xmlCopyCharMultiByte(&v16[v18], v17);
      }
      int v31 = &v8[lena];
      goto LABEL_108;
    }
    if (*__xmlParserDebugEntities())
    {
      xmlGenericErrorFunc v34 = *__xmlGenericError();
      int v35 = __xmlGenericErrorContext();
      v34(*v35, "String decoding Entity Reference: %.30s\n", (const char *)v8);
    }
    *(void *)uint64_t v101 = v8;
    if (*v8 == 38)
    {
      *(void *)uint64_t v101 = v8 + 1;
      int v36 = xmlParseStringName(v14, (const xmlChar **)v101);
      if (v36)
      {
        int v37 = v36;
        size_t v38 = *(const xmlChar **)v101;
        if (**(unsigned char **)v101 == 59)
        {
          int v31 = (const xmlChar *)(*(void *)v101 + 1);
          if ((v14->options & 0x100000) == 0)
          {
            xmlEntityPtr PredefinedEntity = xmlGetPredefinedEntity(v36);
            if (PredefinedEntity)
            {
              xmlEntityPtr v40 = PredefinedEntity;
              xmlFree(v37);
              xmlParserEntityCheck((int)v14);
              xmlEntityPtr v41 = v40;
              uint64_t v18 = v98;
LABEL_199:
              v14->nbentities += v41->checked / 2;
              content = v41->content;
              if (v41->etype == XML_INTERNAL_PREDEFINED_ENTITY)
              {
                if (content)
                {
                  v18 += xmlCopyCharMultiByte(&v16[v18], *content);
                  if (v18 + 100 <= v97) {
                    goto LABEL_204;
                  }
                  size_t v55 = 2 * v97 + 100;
                  if (v55 < v97) {
                    goto LABEL_252;
                  }
LABEL_110:
                  xmlGenericErrorFunc v7 = (xmlChar *)xmlRealloc(v16, v55);
                  unint64_t v97 = v55;
                  if (!v7) {
                    goto LABEL_252;
                  }
                  goto LABEL_205;
                }
                xmlFatalErrMsg(v14, 1, (char)"predefined entity has no content\n");
                goto LABEL_256;
              }
              if (!content)
              {
                int v99 = v11;
                int v77 = xmlStrlen(v41->name);
                uint64_t v78 = v18;
                name = v41->name;
                uint64_t v80 = v78 + 1;
                v16[v78] = 38;
                int v81 = v77;
                if (v78 + 1 + v77 + 100 <= v97)
                {
                  xmlGenericErrorFunc v7 = v16;
                }
                else
                {
                  size_t v82 = v77 + 2 * v97 + 100;
                  if (v82 < v97) {
                    goto LABEL_252;
                  }
                  xmlGenericErrorFunc v7 = (xmlChar *)xmlRealloc(v16, v82);
                  unint64_t v97 = v82;
                  if (!v7) {
                    goto LABEL_252;
                  }
                }
                if (v81 < 1)
                {
                  uint64_t v85 = v80;
                  what = v95;
                }
                else
                {
                  unsigned int v83 = v81 + 1;
                  what = v95;
                  do
                  {
                    xmlChar v84 = *name++;
                    uint64_t v85 = v80 + 1;
                    v7[v80] = v84;
                    --v83;
                    ++v80;
                  }
                  while (v83 > 1);
                }
                uint64_t v18 = v85 + 1;
                v7[v85] = 59;
                int v11 = v99;
                goto LABEL_205;
              }
              ++v14->depth;
              int v72 = xmlStrlen(content);
              int v73 = xmlStringLenDecodeEntities(v14, content, v72, what, 0, 0, 0);
              --v14->depth;
              if (v73)
              {
                uint64_t v74 = v73;
                LOBYTE(v75) = *v73;
                if (*v73)
                {
                  uint64_t v76 = 0;
                  int v93 = v10;
                  do
                  {
                    v16[v98 + v76] = v75;
                    if (v98 + v76 + 101 <= v97)
                    {
                      xmlGenericErrorFunc v7 = v16;
                    }
                    else
                    {
                      if (xmlParserEntityCheck((int)v14)) {
                        goto LABEL_254;
                      }
                      if (2 * v97 + 100 < v97) {
                        goto LABEL_253;
                      }
                      xmlGenericErrorFunc v7 = (xmlChar *)xmlRealloc(v16, 2 * v97 + 100);
                      unint64_t v97 = 2 * v97 + 100;
                      int v10 = v93;
                      if (!v7) {
                        goto LABEL_253;
                      }
                    }
                    int v75 = v74[++v76];
                    uint64_t v16 = v7;
                  }
                  while (v75);
LABEL_249:
                  uint64_t v18 = v98 + v76;
LABEL_251:
                  xmlFree(v74);
                  what = v95;
                  goto LABEL_205;
                }
LABEL_250:
                xmlGenericErrorFunc v7 = v16;
                goto LABEL_251;
              }
              int v90 = v41->content;
LABEL_271:
              *int v90 = 0;
              goto LABEL_256;
            }
          }
          ++v14->nbentities;
          uint64_t v18 = v98;
          if (!v14->sax) {
            goto LABEL_92;
          }
          getxmlEntityPtr Entity = (uint64_t (*)(void *, xmlChar *))v14->sax->getEntity;
          if (getEntity)
          {
            xmlEntityPtr Entity = (xmlEntityPtr)getEntity(v14->userData, v37);
            if (Entity) {
              goto LABEL_93;
            }
          }
          if ((v14->options & 0x100000) != 0)
          {
            xmlEntityPtr Entity = xmlGetPredefinedEntity(v37);
            if (Entity) {
              goto LABEL_93;
            }
          }
          if (v14->userData == v14) {
            xmlEntityPtr Entity = xmlSAX2GetEntity(v14, v37);
          }
          else {
LABEL_92:
          }
            xmlEntityPtr Entity = 0;
LABEL_93:
          xmlParserInputState instate = v14->instate;
          if (instate != XML_PARSER_EOF)
          {
            xmlEntityPtr v41 = Entity;
            if (!Entity)
            {
              if (v14->standalone != 1 && (v14->hasExternalSubset || v14->hasPErefs)) {
                xmlErrMsgStr(v14, 27, "Entity '%s' not defined\n", v37);
              }
              else {
                xmlFatalErrMsgStr(v14, 26, "Entity '%s' not defined\n", v37);
              }
              xmlParserEntityCheck((int)v14);
LABEL_198:
              xmlFree(v37);
              xmlParserEntityCheck((int)v14);
              if (!v41) {
                goto LABEL_204;
              }
              goto LABEL_199;
            }
            exmlElementType type = Entity->etype;
            if (etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY)
            {
              int v52 = v14;
              int v53 = 28;
              int v54 = "Entity reference to unparsed entity %s\n";
            }
            else
            {
              if (instate != XML_PARSER_ATTRIBUTE_VALUE || etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY)
              {
                if (instate == XML_PARSER_ATTRIBUTE_VALUE && etype != XML_INTERNAL_PREDEFINED_ENTITY)
                {
                  int v62 = Entity->content;
                  if (v62)
                  {
                    if (xmlStrchr(v62, 0x3Cu))
                    {
                      int v52 = v14;
                      int v53 = 38;
                      int v54 = "'<' in entity '%s' is not allowed in attributes values\n";
                      goto LABEL_197;
                    }
                    exmlElementType type = v41->etype;
                  }
                }
                if ((etype & 0xFFFFFFFE) != 4) {
                  goto LABEL_198;
                }
                int v52 = v14;
                int v53 = 30;
                int v54 = "Attempt to reference the parameter entity '%s'\n";
                goto LABEL_197;
              }
              int v52 = v14;
              int v53 = 29;
              int v54 = "Attribute references external entity '%s'\n";
            }
LABEL_197:
            xmlFatalErrMsgStr(v52, v53, v54, v37);
            goto LABEL_198;
          }
          xmlFree(v37);
LABEL_78:
          xmlParserEntityCheck((int)v14);
          int v31 = v8;
          goto LABEL_204;
        }
        xmlFatalErr(v14, 23, 0);
        xmlFree(v37);
        uint64_t v8 = v38;
      }
      else
      {
        xmlFatalErrMsg(v14, 68, (char)"xmlParseStringEntityRef: no name\n");
        uint64_t v8 = *(const xmlChar **)v101;
      }
    }
    uint64_t v18 = v98;
    goto LABEL_78;
  }
  if ((what & 2) == 0 || v17 != 37) {
    goto LABEL_37;
  }
  if (*__xmlParserDebugEntities())
  {
    xmlGenericErrorFunc v27 = *__xmlGenericError();
    int v28 = __xmlGenericErrorContext();
    v27(*v28, "String decoding PE Reference: %.30s\n", (const char *)v8);
  }
  if (!v8)
  {
    int v31 = 0;
    uint64_t v18 = v98;
LABEL_85:
    xmlParserEntityCheck((int)v14);
    goto LABEL_204;
  }
  *(void *)uint64_t v101 = v8;
  uint64_t v18 = v98;
  if (*v8 != 37)
  {
    int v31 = v8;
    goto LABEL_85;
  }
  *(void *)uint64_t v101 = v8 + 1;
  int v29 = xmlParseStringName(v14, (const xmlChar **)v101);
  if (!v29)
  {
    xmlFatalErrMsg(v14, 68, (char)"xmlParseStringPEReference: no name\n");
    int v31 = *(const xmlChar **)v101;
    goto LABEL_85;
  }
  int v30 = v29;
  int v31 = *(const xmlChar **)v101;
  if (**(unsigned char **)v101 != 59)
  {
    xmlFatalErr(v14, 23, 0);
LABEL_84:
    xmlFree(v30);
    goto LABEL_85;
  }
  ++v14->nbentities;
  if (v14->sax && (getParameterEntitySAXFunc getParameterEntity = (uint64_t (*)(void *, xmlChar *))v14->sax->getParameterEntity) != 0) {
    uint64_t v33 = getParameterEntity(v14->userData, v29);
  }
  else {
    uint64_t v33 = 0;
  }
  ++v31;
  if (v14->instate == XML_PARSER_EOF) {
    goto LABEL_84;
  }
  if (v33)
  {
    if ((*(_DWORD *)(v33 + 92) & 0xFFFFFFFE) != 4) {
      xmlWarningMsg(v14, 27, "%%%s; is not a parameter entity\n", v30);
    }
  }
  else
  {
    if (v14->standalone != 1 && (v14->hasExternalSubset || v14->hasPErefs))
    {
      xmlWarningMsg(v14, 27, "PEReference: %%%s; not found\n", v30);
      v14->valint id = 0;
    }
    else
    {
      xmlFatalErrMsgStr(v14, 26, "PEReference: %%%s; not found\n", v30);
    }
    xmlParserEntityCheck((int)v14);
  }
  v14->hasPErefs = 1;
  xmlFree(v30);
  xmlParserEntityCheck((int)v14);
  if (!v33) {
    goto LABEL_204;
  }
  v14->nbentities += *(_DWORD *)(v33 + 132) / 2;
  if (*(void *)(v33 + 80)) {
    goto LABEL_239;
  }
  if ((v14->options & 0x12) != 0 || v14->validate)
  {
    int v56 = *(_DWORD *)(v33 + 92);
    if (v56 == 2 || v56 == 5)
    {
      v101[0] = 0;
      if (*__xmlParserDebugEntities())
      {
        xmlGenericErrorFunc v57 = *__xmlGenericError();
        unsigned int v58 = __xmlGenericErrorContext();
        v57(*v58, "Reading %s entity content input\n", *(const char **)(v33 + 16));
        uint64_t v18 = v98;
      }
      uint64_t buf = xmlBufferCreate();
      if (buf)
      {
        int v59 = xmlNewEntityInputStream(v14, (xmlEntityPtr)v33);
        if (v59)
        {
          int v60 = v59;
          if ((xmlPushInput(v14, v59) & 0x80000000) == 0)
          {
            if (!v14->progressive && v14->input->end - v14->input->cur <= 249) {
              xmlGROW((uint64_t)v14);
            }
            uint64_t v91 = v33;
            int v61 = xmlCurrentChar(v14, v101);
            if (v14->input == v60)
            {
              int v64 = 0;
              while (1)
              {
                cur = v60->cur;
                if (cur >= v60->end) {
                  break;
                }
                if (v61 > 255)
                {
                  if (v61 >> 11 >= 0x1B)
                  {
                    unsigned int v66 = v61 - 57344;
                    if ((v61 - 57344) >> 1 >= 0xFFF)
                    {
                      unsigned int v67 = v61 - 0x10000;
                      if ((v61 - 0x10000) >> 20) {
                        goto LABEL_189;
                      }
                    }
                  }
                }
                else if ((v61 > 0xD || ((1 << v61) & 0x2600) == 0) && v61 <= 31)
                {
                  goto LABEL_138;
                }
                xmlBufferAdd(buf, cur, v101[0]);
                if (v64 < 101)
                {
                  ++v64;
                }
                else
                {
                  if (!v14->progressive && v14->input->end - v14->input->cur <= 249) {
                    xmlGROW((uint64_t)v14);
                  }
                  if (v14->instate == XML_PARSER_EOF) {
                    goto LABEL_193;
                  }
                  int v64 = 0;
                }
                xmlParserInputPtr input = v14->input;
                uint64_t v69 = input->cur;
                char v70 = &v69[v101[0]];
                if (v70 <= input->end)
                {
                  if (*v69 == 10)
                  {
                    ++input->line;
                    input->int col = 1;
                  }
                  else
                  {
                    ++input->col;
                  }
                  input->cur = v70;
                }
                int v61 = xmlCurrentChar(v14, v101);
                if (!v61)
                {
                  if (!v14->progressive && v14->input->end - v14->input->cur <= 249) {
                    xmlGROW((uint64_t)v14);
                  }
                  if (v14->instate == XML_PARSER_EOF) {
                    goto LABEL_193;
                  }
                  int v61 = xmlCurrentChar(v14, v101);
                  int v64 = 0;
                }
                if (v14->input != v60) {
                  goto LABEL_136;
                }
              }
              xmlPopInput(v14);
            }
            else
            {
LABEL_136:
              if (v61 >= 256)
              {
                unsigned int v66 = v61 - 57344;
                unsigned int v67 = v61 - 0x10000;
LABEL_189:
                if (v67 >= 0x100000 && v66 >> 1 >= 0xFFF && v61 >> 11 >= 0x1B)
                {
LABEL_192:
                  xmlFatalErrMsgInt(v14, 9, "xmlLoadEntityContent: invalid char value %d\n", v61);
LABEL_193:
                  xmlBufferFree(buf);
                  uint64_t v33 = v91;
                  goto LABEL_239;
                }
              }
              else if (v61 <= 31)
              {
LABEL_138:
                if (v61 > 0xD || ((1 << v61) & 0x2600) == 0) {
                  goto LABEL_192;
                }
              }
            }
            uint64_t v33 = v91;
            uint64_t v63 = buf;
            *(void *)(v91 + 80) = buf->content;
            buf->content = 0;
            goto LABEL_238;
          }
        }
        else
        {
          xmlFatalErr(v14, 1, (const xmlChar *)"xmlLoadEntityContent input error");
        }
        uint64_t v63 = buf;
LABEL_238:
        xmlBufferFree(v63);
        goto LABEL_239;
      }
    }
    xmlFatalErr(v14, 1, (const xmlChar *)"xmlLoadEntityContent parameter error");
  }
  else
  {
    xmlWarningMsg(v14, 104, "not validating will not read content for PE entity %s\n", *(const xmlChar **)(v33 + 16));
  }
LABEL_239:
  ++v14->depth;
  long long v86 = xmlStringDecodeEntities(v14, *(const xmlChar **)(v33 + 80), what, 0, 0, 0);
  --v14->depth;
  if (!v86)
  {
    int v90 = *(xmlChar **)(v33 + 80);
    if (!v90) {
      goto LABEL_256;
    }
    goto LABEL_271;
  }
  uint64_t v74 = v86;
  LOBYTE(v87) = *v86;
  if (!*v86) {
    goto LABEL_250;
  }
  uint64_t v76 = 0;
  uint64_t v94 = v14;
  while (1)
  {
    v16[v98 + v76] = v87;
    if (v98 + v76 + 101 > v97) {
      break;
    }
    xmlGenericErrorFunc v7 = v16;
LABEL_248:
    int v87 = v74[++v76];
    uint64_t v16 = v7;
    if (!v87) {
      goto LABEL_249;
    }
  }
  if (xmlParserEntityCheck((int)v14)) {
    goto LABEL_254;
  }
  if (2 * v97 + 100 < v97)
  {
    xmlParserCtxtPtr v14 = v94;
    goto LABEL_253;
  }
  xmlGenericErrorFunc v7 = (xmlChar *)xmlRealloc(v16, 2 * v97 + 100);
  unint64_t v97 = 2 * v97 + 100;
  xmlParserCtxtPtr v14 = v94;
  if (v7) {
    goto LABEL_248;
  }
LABEL_253:
  htmlErrMemory(v14, 0);
LABEL_254:
  if (v74) {
    xmlFree(v74);
  }
LABEL_256:
  if (v16) {
    xmlFree(v16);
  }
  return 0;
}

uint64_t xmlParserEntityCheck(uint64_t result, unint64_t a2, uint64_t a3, unint64_t a4)
{
  if (result)
  {
    uint64_t v4 = result;
    if ((*(unsigned char *)(result + 566) & 8) == 0)
    {
      if (*(_DWORD *)(result + 604) == 89) {
        return 1;
      }
      if (a3)
      {
        if (*(_DWORD *)(a3 + 92) != 6)
        {
          uint64_t v8 = *(const xmlChar **)(a3 + 80);
          if (v8)
          {
            if (!*(_DWORD *)(a3 + 132) && *(_DWORD *)(result + 136) != 89)
            {
              uint64_t v9 = *(void *)(result + 696);
              *(_DWORD *)(a3 + 132) = 1;
              ++*(_DWORD *)(result + 392);
              int v10 = xmlStrlen(v8);
              int v11 = xmlStringLenDecodeEntities((xmlParserCtxtPtr)v4, v8, v10, 1, 0, 0, 0);
              int v12 = v11;
              --*(_DWORD *)(v4 + 392);
              if (!v11 || *(_DWORD *)(v4 + 136) == 89) {
                **(unsigned char **)(a3 + 80) = 0;
              }
              uint64_t v13 = *(void *)(v4 + 696) - v9;
              if ((unint64_t)(v13 + 1) < 0x3FFFFFFF) {
                int v14 = v13 + 1;
              }
              else {
                int v14 = 0x3FFFFFFF;
              }
              *(_DWORD *)(a3 + 132) = 2 * v14;
              if (v11)
              {
                if (xmlStrchr(v11, 0x3Cu)) {
                  *(_DWORD *)(a3 + 132) |= 1u;
                }
                xmlFree(v12);
              }
            }
          }
        }
      }
      if (*(_DWORD *)(v4 + 272) == 3)
      {
        unint64_t v15 = *(void *)(v4 + 696);
        if (v15 >= 0x2711 && (v15 & 0x3FF) == 0)
        {
          uint64_t v16 = *(unsigned int *)(v4 + 64);
          if ((int)v16 < 1) {
            goto LABEL_26;
          }
          uint64_t v17 = 0;
          uint64_t v18 = *(void **)(v4 + 72);
          do
          {
            int v19 = (void *)*v18++;
            uint64_t v17 = v19[8] + v17 + v19[4] - v19[3];
            --v16;
          }
          while (v16);
          if (v15 > 10 * v17)
          {
LABEL_26:
            xmlFatalErr((_DWORD *)v4, 89, 0);
            *(_DWORD *)(v4 + 272) = -1;
            return 1;
          }
        }
      }
      if (a4)
      {
        if (a4 >= 0x989680)
        {
          addrinfo v20 = *(void **)(v4 + 56);
          if (v20) {
            addrinfo v20 = (void *)(v20[8] + v20[4] - v20[3]);
          }
          if (10 * ((uint64_t)v20 + *(void *)(v4 + 704)) <= a4) {
            goto LABEL_48;
          }
        }
      }
      else if (a2)
      {
        if (a2 >= 0x3E8)
        {
          int v21 = *(void **)(v4 + 56);
          if (v21) {
            int v21 = (void *)(v21[8] + v21[4] - v21[3]);
          }
          unint64_t v22 = 10 * ((void)v21 + *(void *)(v4 + 704));
          if (v22 <= a2 || 3 * *(void *)(v4 + 696) >= v22) {
            goto LABEL_48;
          }
        }
      }
      else if (a3)
      {
        int v23 = *(void **)(v4 + 56);
        if (v23) {
          int v23 = (void *)(v23[8] + v23[4] - v23[3]);
        }
        if (3 * ((uint64_t)(*(_DWORD *)(a3 + 132) + (*(int *)(a3 + 132) < 0)) >> 1) >= (unint64_t)(10 * ((void)v23 + *(void *)(v4 + 704)))) {
          goto LABEL_48;
        }
      }
      else if ((*(_DWORD *)(v4 + 604) & 0xFFFFFFFE) == 0x1A && *(void *)(v4 + 696) >= 0x2711uLL)
      {
LABEL_48:
        xmlFatalErr((_DWORD *)v4, 89, 0);
        return 1;
      }
    }
    return 0;
  }
  return result;
}

_DWORD *xmlFatalErrMsg(_DWORD *result, int a2, char a3)
{
  if (!result) {
    return __xmlRaiseError(0, 0, 0, 0, 0, 1u, a2, 3, 0, 0, 0, 0, 0, 0, 0, "%s", a3);
  }
  BOOL v3 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    int result = __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 3, 0, 0, 0, 0, 0, 0, 0, "%s", a3);
    v3[6] = 0;
    if (!v3[112]) {
      v3[83] = 1;
    }
  }
  return result;
}

xmlChar *__cdecl xmlStringDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int what, xmlChar end, xmlChar end2, xmlChar end3)
{
  if (!ctxt || !str) {
    return 0;
  }
  int v12 = xmlStrlen(str);

  return xmlStringLenDecodeEntities(ctxt, str, v12, what, end, end2, end3);
}

_DWORD *xmlWarningMsg(_DWORD *result, int a2, const char *a3, const xmlChar *a4)
{
  if (!result) {
    return __xmlRaiseError(0, 0, 0, 0, 0, 1u, a2, 1, 0, 0, a4, 0, 0, 0, 0, a3, (char)a4);
  }
  uint64_t v5 = (uint64_t)result;
  if (!result[83] || result[68] != -1)
  {
    uint64_t v6 = *(void *)result;
    if (*(void *)result)
    {
      if (*(_DWORD *)(v6 + 216) == -554844497) {
        xmlGenericErrorFunc v7 = *(void (__cdecl **)(void *, xmlErrorPtr))(v6 + 248);
      }
      else {
        xmlGenericErrorFunc v7 = 0;
      }
      uint64_t v8 = *(void (**)(void *, const char *, ...))(v6 + 168);
    }
    else
    {
      xmlGenericErrorFunc v7 = 0;
      uint64_t v8 = 0;
    }
    return __xmlRaiseError(v7, v8, *(void **)(v5 + 8), (void *)v5, 0, 1u, a2, 1, 0, 0, a4, 0, 0, 0, 0, a3, (char)a4);
  }
  return result;
}

xmlChar *__cdecl xmlSplitQName(xmlParserCtxtPtr ctxt, const xmlChar *name, xmlChar **prefix)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (!prefix) {
    return 0;
  }
  const char *prefix = 0;
  if (!name) {
    return 0;
  }
  int v5 = *name;
  if (v5 != 58)
  {
    uint64_t v8 = 0;
    memset(__src, 0, 105);
    if (v5)
    {
      while (v5 != 58)
      {
        if (v8 == 100)
        {
          unsigned int v9 = 100;
          goto LABEL_15;
        }
        *((unsigned char *)__src + v8) = v5;
        int v5 = name[++v8];
        if (!v5) {
          break;
        }
      }
    }
    if (v8 <= 0x63)
    {
      int v10 = 0;
      int v11 = &name[v8 + 1];
      int v12 = 100;
      int v13 = v8;
    }
    else
    {
      unsigned int v9 = v8;
LABEL_15:
      int v14 = (xmlChar *)xmlMallocAtomic(2 * v9);
      int v10 = v14;
      if (!v14) {
        goto LABEL_73;
      }
      xmlParserCtxtPtr v30 = ctxt;
      memcpy(v14, __src, v9);
      uint64_t v15 = 0;
      int v12 = 2 * v9;
      while ((_BYTE)v5 && v5 != 58)
      {
        if ((int)(v9 + v15 + 10) > v12)
        {
          v12 *= 2;
          uint64_t v16 = (xmlChar *)xmlRealloc(v10, v12);
          if (!v16)
          {
            xmlFree(v10);
            htmlErrMemory(v30, 0);
            return 0;
          }
          int v10 = v16;
        }
        v10[v9 + v15] = v5;
        int v5 = name[++v15 + v8];
      }
      int v13 = v9 + v15;
      v10[v9 + v15] = 0;
      int v11 = &name[v8 + 1 + v15];
      ctxt = v30;
    }
    if (v5 == 58 && !*v11)
    {
      if (v10) {
        xmlFree(v10);
      }
      const char *prefix = 0;
      goto LABEL_4;
    }
    if (v10) {
      int v12 = 100;
    }
    else {
      int v10 = xmlStrndup((const xmlChar *)__src, v13);
    }
    if (v5 == 58)
    {
      LOBYTE(v17) = *v11;
      const char *prefix = v10;
      if (!(_BYTE)v17)
      {
        addrinfo v20 = (const xmlChar *)"";
        int v21 = 0;
        return xmlStrndup(v20, v21);
      }
      if (((v17 & 0xDF) - 65) < 0x1Au || v17 == 58 || v17 == 95) {
        goto LABEL_53;
      }
      int len = 0;
      signed int v18 = xmlStringCurrentChar(ctxt, v11, &len);
      signed int v19 = v18;
      if (v18 > 255)
      {
        if (xmlCharInRange(v18, &xmlIsBaseCharGroup)
          || (v19 - 12330) > 0xFFFFFFF6
          || v19 == 12295
          || (v19 - 40870) > 0xFFFFAE59)
        {
          goto LABEL_53;
        }
      }
      else if ((v18 - 192) < 0x17 {
             || (v18 & 0xFFFFFFDF) - 65 < 0x1A
      }
             || v18 == 95
             || v18 > 247
             || (v18 - 216) < 0x1F)
      {
        goto LABEL_53;
      }
      xmlFatalErrMsgStr(ctxt, 202, "Name %s is not XML Namespace compliant\n", name);
LABEL_53:
      unint64_t v22 = (unsigned __int8 *)(v11 + 1);
      if (v12 < 1)
      {
        LODWORD(v2xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0;
      }
      else
      {
        unint64_t v23 = 0;
        do
        {
          *((unsigned char *)__src + v2xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = v17;
          int v17 = v22[v23++];
          if (v17) {
            BOOL v24 = v23 >= v12;
          }
          else {
            BOOL v24 = 1;
          }
        }
        while (!v24);
        if (v23 < v12)
        {
          addrinfo v20 = (const xmlChar *)__src;
          int v21 = v23;
          return xmlStrndup(v20, v21);
        }
        v22 += v23;
      }
      int v25 = 2 * v23;
      unint64_t v26 = (xmlChar *)xmlMallocAtomic((2 * v23));
      int v10 = v26;
      if (v26)
      {
        unint64_t v23 = v23;
        memcpy(v26, __src, v23);
        if ((_BYTE)v17)
        {
          while (1)
          {
            if ((int)v23 + 10 > v25)
            {
              v25 *= 2;
              xmlGenericErrorFunc v27 = (xmlChar *)xmlRealloc(v10, v25);
              if (!v27)
              {
                htmlErrMemory(ctxt, 0);
                xmlFree(v10);
                return 0;
              }
              int v10 = v27;
            }
            unsigned int v28 = v23 + 1;
            v10[v23] = v17;
            int v29 = *v22++;
            LOBYTE(v17) = v29;
            ++v23;
            if (!v29)
            {
              unint64_t v23 = v28;
              break;
            }
          }
        }
        v10[v23] = 0;
        return v10;
      }
LABEL_73:
      htmlErrMemory(ctxt, 0);
    }
    return v10;
  }
LABEL_4:

  return xmlStrdup(name);
}

_DWORD *xmlFatalErrMsgStr(_DWORD *result, int a2, const char *a3, const xmlChar *a4)
{
  if (!result) {
    return __xmlRaiseError(0, 0, 0, 0, 0, 1u, a2, 3, 0, 0, a4, 0, 0, 0, 0, a3, (char)a4);
  }
  uint64_t v4 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    int result = __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 3, 0, 0, a4, 0, 0, 0, 0, a3, (char)a4);
    v4[6] = 0;
    if (!v4[112]) {
      v4[83] = 1;
    }
  }
  return result;
}

xmlChar *__cdecl xmlParseNmtoken(xmlParserCtxtPtr ctxt)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  memset(__src, 0, 105);
  if ((ctxt->options & 0x80000) != 0) {
    int v2 = 10000000;
  }
  else {
    int v2 = 50000;
  }
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  if (ctxt->instate == XML_PARSER_EOF) {
    return 0;
  }
  int len = 0;
  signed int v3 = xmlCurrentChar(ctxt, &len);
  int v4 = 0;
  int v5 = 0;
  do
  {
    xmlIsNameChar((uint64_t)ctxt, v3);
    if (!v6)
    {
      if (!v4) {
        return 0;
      }
      return xmlStrndup((const xmlChar *)__src, v4);
    }
    if (v5 >= 101)
    {
      if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
        xmlGROW((uint64_t)ctxt);
      }
      int v5 = 0;
    }
    else
    {
      ++v5;
    }
    if (len == 1)
    {
      *((unsigned char *)__src + v4++) = v3;
      int v7 = 1;
    }
    else
    {
      v4 += xmlCopyCharMultiByte((xmlChar *)__src + v4, v3);
      int v7 = len;
    }
    xmlParserInputPtr input = ctxt->input;
    cur = input->cur;
    int v10 = &cur[v7];
    if (v10 <= input->end)
    {
      if (*cur == 10)
      {
        ++input->line;
        input->int col = 1;
      }
      else
      {
        ++input->col;
      }
      input->cur = v10;
    }
    signed int v3 = xmlCurrentChar(ctxt, &len);
    if (!v3)
    {
      if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
        xmlGROW((uint64_t)ctxt);
      }
      if (ctxt->instate == XML_PARSER_EOF) {
        return 0;
      }
      signed int v3 = xmlCurrentChar(ctxt, &len);
      int v5 = 0;
    }
  }
  while (v4 < 100);
  int v11 = 2 * v4;
  int v12 = (xmlChar *)xmlMallocAtomic((2 * v4));
  int v13 = v12;
  if (!v12)
  {
    htmlErrMemory(ctxt, 0);
    return v13;
  }
  memcpy(v12, __src, v4);
  while (1)
  {
    xmlIsNameChar((uint64_t)ctxt, v3);
    if (!v14)
    {
      v13[v4] = 0;
      return v13;
    }
    if (v5 < 101)
    {
      ++v5;
    }
    else
    {
      if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
        xmlGROW((uint64_t)ctxt);
      }
      if (ctxt->instate == XML_PARSER_EOF) {
        goto LABEL_59;
      }
      int v5 = 0;
    }
    if (v4 + 10 <= v11) {
      goto LABEL_44;
    }
    v11 *= 2;
    uint64_t v15 = (xmlChar *)xmlRealloc(v13, v11);
    if (!v15) {
      break;
    }
    int v13 = v15;
LABEL_44:
    if (len == 1) {
      v13[v4++] = v3;
    }
    else {
      v4 += xmlCopyCharMultiByte(&v13[v4], v3);
    }
    xmlParserInputPtr v16 = ctxt->input;
    int v17 = v16->cur;
    signed int v18 = &v17[len];
    if (v18 <= v16->end)
    {
      if (*v17 == 10)
      {
        ++v16->line;
        v16->int col = 1;
      }
      else
      {
        ++v16->col;
      }
      v16->cur = v18;
    }
    signed int v3 = xmlCurrentChar(ctxt, &len);
    if (v4 > v2)
    {
      xmlFatalErr(ctxt, 110, (const xmlChar *)"NmToken");
      goto LABEL_59;
    }
  }
  htmlErrMemory(ctxt, 0);
LABEL_59:
  xmlFree(v13);
  return 0;
}

__n128 xmlIsNameChar(uint64_t a1, signed int val)
{
  if ((*(unsigned char *)(a1 + 566) & 2) != 0)
  {
    if (val > 255)
    {
      if (xmlCharInRange(val, &xmlIsBaseCharGroup)
        || (val - 12321) < 9
        || val == 12295
        || (val - 19968) < 0x51A6
        || xmlCharInRange(val, &xmlIsDigitGroup))
      {
        return result;
      }
    }
    else if ((val - 192) < 0x17 {
           || (val & 0xFFFFFFDF) - 65 < 0x1A
    }
           || (val - 48) < 0xA
           || val > 247
           || (val - 216) < 0x1F)
    {
      return result;
    }
    if (((val - 45) > 0x32 || ((1 << (val - 45)) & 0x4000000002003) == 0)
      && val >= 256
      && !xmlCharInRange(val, &xmlIsCombiningGroup))
    {
      xmlCharInRange(val, &xmlIsExtenderGroup);
    }
  }
  else if ((val > 0x3E || ((1 << val) & 0x4000800100000000) == 0) {
         && (val - 48) >= 0xB
  }
         && (val & 0xFFFFFFDF) - 65 >= 0x1A
         && ((val - 45) > 0x32 || ((1 << (val - 45)) & 0x4000000000003) == 0)
         && val != 183)
  {
    int32x4_t v4 = vdupq_n_s32(val);
    result.n128_u8[0] = vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)xmmword_1B51A8150, (uint32x4_t)vaddq_s32(v4, (int32x4_t)xmmword_1B51A8130)), (int16x8_t)vcgtq_u32((uint32x4_t)xmmword_1B51A8160, (uint32x4_t)vaddq_s32(v4, (int32x4_t)xmmword_1B51A8140)))));
  }
  return result;
}

xmlChar *__cdecl xmlParseEntityValue(xmlParserCtxtPtr ctxt, xmlChar **orig)
{
  int len = 0;
  if ((ctxt->options & 0x80000) != 0) {
    int v4 = 1000000000;
  }
  else {
    int v4 = 10000000;
  }
  uint64_t v22 = 0;
  int v5 = *ctxt->input->cur;
  if (v5 != 34 && v5 != 39)
  {
    xmlFatalErr(ctxt, 36, 0);
    return 0;
  }
  int v6 = xmlMallocAtomic(0x64uLL);
  if (!v6)
  {
    htmlErrMemory(ctxt, 0);
    return 0;
  }
  int v7 = v6;
  ctxt->xmlParserInputState instate = XML_PARSER_ENTITY_VALUE;
  xmlParserInputPtr input = ctxt->input;
  if (!ctxt->progressive && input->end - input->cur <= 249)
  {
    xmlGROW((uint64_t)ctxt);
    if (ctxt->instate == XML_PARSER_EOF) {
      goto LABEL_62;
    }
  }
  xmlNextChar(ctxt);
  int v9 = xmlCurrentChar(ctxt, &len);
  int v10 = 0;
  int v11 = 100;
  while (1)
  {
    if (v9 > 255)
    {
      if ((v9 - 0x10000) >= 0x100000
        && v9 >> 11 >= 0x1B
        && (v9 - 57344) >> 1 > 0xFFE)
      {
        goto LABEL_47;
      }
    }
    else if (v9 <= 31 && (v9 > 0xD || ((1 << v9) & 0x2600) == 0))
    {
      goto LABEL_47;
    }
    if (v9 == v5 && ctxt->input == input) {
      break;
    }
    if (ctxt->instate == XML_PARSER_EOF) {
      goto LABEL_47;
    }
    if (v10 + 5 >= v11)
    {
      v11 *= 2;
      int v12 = xmlRealloc(v7, v11);
      if (!v12)
      {
        htmlErrMemory(ctxt, 0);
        goto LABEL_65;
      }
      int v7 = v12;
    }
    if (len == 1) {
      *((unsigned char *)v7 + v10++) = v9;
    }
    else {
      v10 += xmlCopyCharMultiByte((xmlChar *)v7 + v10, v9);
    }
    xmlParserInputPtr v13 = ctxt->input;
    cur = v13->cur;
    end = v13->end;
    xmlParserInputPtr v16 = &cur[len];
    if (v16 <= end)
    {
      if (*cur == 10)
      {
        ++v13->line;
        v13->int col = 1;
      }
      else
      {
        ++v13->col;
      }
      v13->cur = v16;
      cur = v16;
    }
    if (!ctxt->progressive && end - cur <= 249) {
      xmlGROW((uint64_t)ctxt);
    }
    int v9 = xmlCurrentChar(ctxt, &len);
    if (!v9)
    {
      if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
        xmlGROW((uint64_t)ctxt);
      }
      int v9 = xmlCurrentChar(ctxt, &len);
    }
    if (v10 > v4)
    {
      xmlFatalErrMsg(ctxt, 37, (char)"entity value too long\n");
LABEL_65:
      int v17 = 0;
      goto LABEL_66;
    }
  }
  int v9 = v5;
LABEL_47:
  *((unsigned char *)v7 + v10) = 0;
  if (ctxt->instate == XML_PARSER_EOF)
  {
LABEL_62:
    int v17 = 0;
    goto LABEL_66;
  }
  if (v9 != v5)
  {
    xmlFatalErr(ctxt, 37, 0);
    goto LABEL_62;
  }
  xmlNextChar(ctxt);
  for (uint64_t i = (const xmlChar *)v7; ; ++i)
  {
    uint64_t v22 = i;
    int v19 = *i;
    if (v19 != 37) {
      break;
    }
LABEL_55:
    uint64_t v22 = i + 1;
    addrinfo v20 = xmlParseStringName(ctxt, &v22);
    if (!v20 || (xmlFree(v20), uint64_t i = v22, *v22 != 59))
    {
      xmlFatalErrMsgInt(ctxt, 87, "EntityValue: '%c' forbidden except for entities references\n", v19);
      goto LABEL_65;
    }
    if (v19 == 37 && ctxt->inSubset == 1 && ctxt->inputNr == 1)
    {
      xmlFatalErr(ctxt, 88, 0);
      goto LABEL_65;
    }
LABEL_60:
    ;
  }
  if (v19 == 38)
  {
    if (i[1] == 35) {
      goto LABEL_60;
    }
    goto LABEL_55;
  }
  if (*i) {
    goto LABEL_60;
  }
  ++ctxt->depth;
  int v17 = xmlStringDecodeEntities(ctxt, (const xmlChar *)v7, 2, 0, 0, 0);
  --ctxt->depth;
  if (orig)
  {
    xmlChar *orig = (xmlChar *)v7;
    return v17;
  }
LABEL_66:
  xmlFree(v7);
  return v17;
}

xmlChar *xmlParseStringName(xmlParserCtxt *a1, const xmlChar **a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  long long v25 = 0u;
  memset(v26, 0, sizeof(v26));
  long long v23 = 0u;
  long long v24 = 0u;
  *(_OWORD *)out = 0u;
  long long v22 = 0u;
  int v4 = *a2;
  int len = 0;
  if ((a1->options & 0x80000) != 0) {
    int v5 = 10000000;
  }
  else {
    int v5 = 50000;
  }
  signed int v6 = xmlStringCurrentChar(a1, v4, &len);
  xmlIsNameStartChar((uint64_t)a1, v6);
  if (!v7) {
    return 0;
  }
  if (len == 1)
  {
    out[0] = v6;
    uint64_t v8 = 1;
    int v9 = 1;
  }
  else
  {
    int v9 = xmlCopyCharMultiByte(out, v6);
    uint64_t v8 = len;
  }
  int v10 = &v4[v8];
  signed int v11 = xmlStringCurrentChar(a1, v10, &len);
  do
  {
    xmlIsNameChar((uint64_t)a1, v11);
    if (!v12)
    {
      if (v9 > v5)
      {
        xmlFatalErr(a1, 110, (const xmlChar *)"NCName");
        return 0;
      }
      *a2 = v10;
      return xmlStrndup(out, v9);
    }
    int v13 = len;
    if (len == 1)
    {
      out[v9++] = v11;
    }
    else
    {
      v9 += xmlCopyCharMultiByte(&out[v9], v11);
      int v13 = len;
    }
    v10 += v13;
    signed int v11 = xmlStringCurrentChar(a1, v10, &len);
  }
  while (v9 < 100);
  int v14 = 2 * v9;
  uint64_t v15 = xmlMallocAtomic((2 * v9));
  xmlParserInputPtr v16 = v15;
  if (!v15)
  {
    htmlErrMemory(a1, 0);
    return v16;
  }
  memcpy(v15, out, v9);
  while (1)
  {
    xmlIsNameChar((uint64_t)a1, v11);
    if (!v17)
    {
      v16[v9] = 0;
      *a2 = v10;
      return v16;
    }
    if (v9 + 10 <= v14) {
      goto LABEL_20;
    }
    v14 *= 2;
    signed int v18 = xmlRealloc(v16, v14);
    if (!v18) {
      break;
    }
    xmlParserInputPtr v16 = v18;
LABEL_20:
    if (len == 1) {
      v16[v9++] = v11;
    }
    else {
      v9 += xmlCopyCharMultiByte(&v16[v9], v11);
    }
    v10 += len;
    signed int v11 = xmlStringCurrentChar(a1, v10, &len);
    if (v9 > v5)
    {
      xmlFatalErr(a1, 110, (const xmlChar *)"NCName");
      goto LABEL_31;
    }
  }
  htmlErrMemory(a1, 0);
LABEL_31:
  xmlFree(v16);
  return 0;
}

xmlChar *__cdecl xmlParseAttValue(xmlParserCtxtPtr ctxt)
{
  if (ctxt && ctxt->input) {
    return xmlParseAttValueInternal((uint64_t)ctxt, 0, 0, 0);
  }
  else {
    return 0;
  }
}

xmlChar *__cdecl xmlParseSystemLiteral(xmlParserCtxtPtr ctxt)
{
  if ((ctxt->options & 0x80000) != 0) {
    int v2 = 10000000;
  }
  else {
    int v2 = 50000;
  }
  xmlParserInputState instate = ctxt->instate;
  if (!ctxt->progressive)
  {
    xmlParserInputPtr input = ctxt->input;
    cur = input->cur;
    if (cur - input->base >= 501 && input->end - cur <= 499) {
      xmlSHRINK((uint64_t)ctxt);
    }
  }
  int len = 0;
  int v6 = *ctxt->input->cur;
  if (v6 != 34 && v6 != 39)
  {
    xmlFatalErr(ctxt, 43, 0);
    return 0;
  }
  xmlNextChar(ctxt);
  int v7 = (xmlChar *)xmlMallocAtomic(0x64uLL);
  if (!v7)
  {
    htmlErrMemory(ctxt, 0);
    return v7;
  }
  xmlParserInputState v25 = instate;
  ctxt->xmlParserInputState instate = XML_PARSER_SYSTEM_LITERAL;
  int v8 = xmlCurrentChar(ctxt, &len);
  int v9 = 0;
  int v10 = 0;
  int v11 = 100;
  while (1)
  {
    if (v8 > 255)
    {
      BOOL v14 = v8 >> 11 < 0x1B
         || (v8 - 57344) >> 1 < 0xFFF
         || (v8 - 0x10000) < 0x100000;
      if (v8 != v6 && v14) {
        goto LABEL_29;
      }
      v7[v9] = 0;
      ctxt->xmlParserInputState instate = v25;
      if (v14) {
        goto LABEL_64;
      }
LABEL_70:
      xmlFatalErr(ctxt, 44, 0);
      return v7;
    }
    if (v8 <= 31 && (v8 > 0xD || ((1 << v8) & 0x2600) == 0))
    {
      v7[v9] = 0;
      ctxt->xmlParserInputState instate = v25;
      goto LABEL_70;
    }
    if (v8 == v6)
    {
      v7[v9] = 0;
      ctxt->xmlParserInputState instate = v25;
LABEL_64:
      xmlNextChar(ctxt);
      return v7;
    }
LABEL_29:
    if (v9 + 5 >= v11)
    {
      v11 *= 2;
      uint64_t v15 = (xmlChar *)xmlRealloc(v7, v11);
      if (!v15)
      {
        xmlFree(v7);
        htmlErrMemory(ctxt, 0);
        goto LABEL_66;
      }
      int v7 = v15;
    }
    if (v10 < 50)
    {
      ++v10;
      goto LABEL_42;
    }
    if (!ctxt->progressive)
    {
      xmlParserInputPtr v16 = ctxt->input;
      int v17 = v16->cur;
      if (v17 - v16->base < 501 || v16->end - v17 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
      {
        if (ctxt->input->end - ctxt->input->cur <= 249) {
          xmlGROW((uint64_t)ctxt);
        }
      }
    }
    if (ctxt->instate == XML_PARSER_EOF) {
      break;
    }
    int v10 = 0;
LABEL_42:
    if (len == 1) {
      v7[v9++] = v8;
    }
    else {
      v9 += xmlCopyCharMultiByte(&v7[v9], v8);
    }
    xmlParserInputPtr v18 = ctxt->input;
    int v19 = v18->cur;
    addrinfo v20 = &v19[len];
    if (v20 <= v18->end)
    {
      if (*v19 == 10)
      {
        ++v18->line;
        int v21 = 1;
      }
      else
      {
        int v21 = v18->col + 1;
      }
      v18->int col = v21;
      v18->cur = v20;
    }
    int v8 = xmlCurrentChar(ctxt, &len);
    if (!v8)
    {
      if (!ctxt->progressive)
      {
        if (ctxt->input->end - ctxt->input->cur > 249 || (xmlGROW((uint64_t)ctxt), !ctxt->progressive))
        {
          xmlParserInputPtr v22 = ctxt->input;
          long long v23 = v22->cur;
          if (v23 - v22->base >= 501 && v22->end - v23 <= 499) {
            xmlSHRINK((uint64_t)ctxt);
          }
        }
      }
      int v8 = xmlCurrentChar(ctxt, &len);
    }
    if (v9 > v2)
    {
      xmlFatalErr(ctxt, 110, (const xmlChar *)"SystemLiteral");
      xmlFree(v7);
LABEL_66:
      int v7 = 0;
      ctxt->xmlParserInputState instate = v25;
      return v7;
    }
  }
  xmlFree(v7);
  return 0;
}

xmlChar *__cdecl xmlParsePubidLiteral(xmlParserCtxtPtr ctxt)
{
  optioxmlNsPtr ns = ctxt->options;
  xmlParserInputState instate = ctxt->instate;
  if (!ctxt->progressive)
  {
    xmlParserInputPtr input = ctxt->input;
    cur = input->cur;
    if (cur - input->base >= 501 && input->end - cur <= 499) {
      xmlSHRINK((uint64_t)ctxt);
    }
  }
  int v6 = *ctxt->input->cur;
  if (v6 == 34 || v6 == 39)
  {
    xmlNextChar(ctxt);
    int v7 = xmlMallocAtomic(0x64uLL);
    if (v7)
    {
      xmlParserInputState v21 = instate;
      uint64_t v8 = 0;
      int v9 = 0;
      ctxt->xmlParserInputState instate = XML_PARSER_PUBLIC_LITERAL;
      uint64_t v10 = *ctxt->input->cur;
      if ((options & 0x80000) != 0) {
        uint64_t v11 = 10000001;
      }
      else {
        uint64_t v11 = 50001;
      }
      int v12 = 100;
      while (v6 != v10 && xmlIsPubidChar_tab[v10])
      {
        uint64_t v13 = v8 + 1;
        if (v8 + 1 >= v12)
        {
          v12 *= 2;
          BOOL v14 = xmlRealloc(v7, v12);
          if (!v14)
          {
            htmlErrMemory(ctxt, 0);
            goto LABEL_42;
          }
          int v7 = v14;
        }
        *((unsigned char *)v7 + v8) = v10;
        if (v9 < 50)
        {
          ++v9;
        }
        else
        {
          if (!ctxt->progressive)
          {
            xmlParserInputPtr v15 = ctxt->input;
            xmlParserInputPtr v16 = v15->cur;
            if (v16 - v15->base < 501 || v15->end - v16 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
            {
              if (ctxt->input->end - ctxt->input->cur <= 249) {
                xmlGROW((uint64_t)ctxt);
              }
            }
          }
          if (ctxt->instate == XML_PARSER_EOF) {
            goto LABEL_42;
          }
          int v9 = 0;
        }
        xmlNextChar(ctxt);
        xmlParserInputPtr v17 = ctxt->input;
        xmlParserInputPtr v18 = v17->cur;
        uint64_t v10 = *v18;
        if (!*v18)
        {
          if (!ctxt->progressive)
          {
            if (v17->end - v18 > 249 || (xmlGROW((uint64_t)ctxt), xmlParserInputPtr v17 = ctxt->input, !ctxt->progressive))
            {
              int v19 = v17->cur;
              if (v19 - v17->base >= 501 && v17->end - v19 <= 499)
              {
                xmlSHRINK((uint64_t)ctxt);
                xmlParserInputPtr v17 = ctxt->input;
              }
            }
          }
          uint64_t v10 = *v17->cur;
        }
        ++v8;
        if (v11 == v13)
        {
          xmlFatalErr(ctxt, 110, (const xmlChar *)"Public ID");
LABEL_42:
          xmlFree(v7);
          return 0;
        }
      }
      *((unsigned char *)v7 + v8) = 0;
      if (v6 == v10) {
        xmlNextChar(ctxt);
      }
      else {
        xmlFatalErr(ctxt, 44, 0);
      }
      ctxt->xmlParserInputState instate = v21;
    }
    else
    {
      htmlErrMemory(ctxt, 0);
    }
  }
  else
  {
    xmlFatalErr(ctxt, 43, 0);
    return 0;
  }
  return (xmlChar *)v7;
}

xmlChar *__cdecl xmlParseExternalID(xmlParserCtxtPtr ctxt, xmlChar **publicID, int strict)
{
  if (!ctxt->progressive)
  {
    xmlParserInputPtr input = ctxt->input;
    cur = input->cur;
    if (cur - input->base >= 501 && input->end - cur <= 499) {
      xmlSHRINK((uint64_t)ctxt);
    }
  }
  *publicID = 0;
  xmlParserInputPtr v8 = ctxt->input;
  int v9 = v8->cur;
  int v10 = *v9;
  if (v10 == 80)
  {
    if (v9[1] != 85 || v9[2] != 66 || v9[3] != 76 || v9[4] != 73 || v9[5] != 67) {
      return 0;
    }
    v8->cur = v9 + 6;
    v8->col += 6;
    if (!v9[6]) {
      xmlParserInputGrow(v8, 250);
    }
    if (!xmlSkipBlankChars(ctxt)) {
      xmlFatalErrMsg(ctxt, 65, (char)"Space required after 'PUBLIC'\n");
    }
    uint64_t v13 = xmlParsePubidLiteral(ctxt);
    *publicID = v13;
    if (!v13) {
      xmlFatalErr(ctxt, 71, 0);
    }
    int v14 = xmlSkipBlankChars(ctxt);
    if (strict)
    {
      if (v14) {
        goto LABEL_31;
      }
      int v12 = "Space required after the Public Identifier\n";
      goto LABEL_30;
    }
    if (!v14) {
      return 0;
    }
    int v16 = *ctxt->input->cur;
    if (v16 != 39 && v16 != 34) {
      return 0;
    }
  }
  else
  {
    uint64_t v11 = 0;
    if (v10 != 83) {
      return v11;
    }
    if (v9[1] != 89 || v9[2] != 83 || v9[3] != 84 || v9[4] != 69 || v9[5] != 77) {
      return 0;
    }
    v8->cur = v9 + 6;
    v8->col += 6;
    if (!v9[6]) {
      xmlParserInputGrow(v8, 250);
    }
    if (!xmlSkipBlankChars(ctxt))
    {
      int v12 = "Space required after 'SYSTEM'\n";
LABEL_30:
      xmlFatalErrMsg(ctxt, 65, (char)v12);
    }
  }
LABEL_31:
  uint64_t v11 = xmlParseSystemLiteral(ctxt);
  if (!v11)
  {
    xmlFatalErr(ctxt, 70, 0);
    return 0;
  }
  return v11;
}

void xmlParseComment(xmlParserCtxtPtr ctxt)
{
  if ((ctxt->options & 0x80000) != 0) {
    unint64_t v2 = 1000000000;
  }
  else {
    unint64_t v2 = 10000000;
  }
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur == 60 && cur[1] == 33 && cur[2] == 45 && cur[3] == 45)
  {
    xmlParserInputState instate = ctxt->instate;
    ctxt->xmlParserInputState instate = XML_PARSER_COMMENT;
    int id = input->id;
    input->cur = cur + 4;
    input->col += 4;
    if (!cur[4])
    {
      xmlParserInputGrow(input, 250);
      xmlParserInputPtr input = ctxt->input;
    }
    xmlParserInputState v35 = instate;
    if (!ctxt->progressive)
    {
      int v7 = input->cur;
      if (v7 - input->base < 501
        || input->end - v7 > 499
        || (xmlSHRINK((uint64_t)ctxt), xmlParserInputPtr input = ctxt->input, !ctxt->progressive))
      {
        if (input->end - input->cur <= 249)
        {
          xmlGROW((uint64_t)ctxt);
          xmlParserInputPtr input = ctxt->input;
        }
      }
    }
    xmlParserInputPtr v8 = 0;
    unint64_t v9 = 0;
    int v10 = input->cur;
    int v11 = *v10;
    size_t v12 = 100;
LABEL_17:
    if (v11 == 10)
    {
      int v13 = input->line + 1;
      do
      {
        input->unint64_t line = v13;
        input->int col = 1;
        int v14 = *++v10;
        ++v13;
      }
      while (v14 == 10);
    }
    while (1)
    {
      int col = input->col;
      while (1)
      {
        while (1)
        {
          if (*(char *)v10 <= 45)
          {
            int v16 = *v10;
            if (v16 != 9 && (v16 - 32) > 0xC) {
              break;
            }
          }
          ++v10;
          ++col;
        }
        input->int col = col;
        int v18 = *v10;
        if (v18 != 10) {
          break;
        }
        int v19 = input->line + 1;
        do
        {
          int col = 1;
          input->unint64_t line = v19;
          input->int col = 1;
          int v20 = *++v10;
          ++v19;
        }
        while (v20 == 10);
      }
      xmlParserInputState v21 = (unsigned __int8 *)input->cur;
      size_t v22 = v10 - v21;
      if (v10 != v21 && ctxt->sax && ctxt->sax->comment)
      {
        if (v8)
        {
          if (v22 + v9 + 1 >= v12)
          {
            v12 += v22 + v9 + 100;
            long long v23 = (char *)xmlRealloc(v8, v12);
            if (!v23)
            {
              xmlFree(v8);
LABEL_90:
              htmlErrMemory(ctxt, 0);
              goto LABEL_91;
            }
            xmlParserInputPtr v8 = v23;
          }
        }
        else
        {
          if (v18 == 45 && v10[1] == 45) {
            uint64_t v24 = 1;
          }
          else {
            uint64_t v24 = 100;
          }
          size_t v12 = v22 + v24;
          xmlParserInputState v25 = (char *)xmlMallocAtomic(v22 + v24);
          if (!v25) {
            goto LABEL_90;
          }
          xmlParserInputPtr v8 = v25;
          unint64_t v9 = 0;
        }
        memcpy(&v8[v9], ctxt->input->cur, v22);
        v9 += v22;
        v8[v9] = 0;
      }
      if (v9 > v2) {
        break;
      }
      xmlParserInputPtr input = ctxt->input;
      input->cur = v10;
      int v26 = *v10;
      uint64_t v27 = (unsigned __int8 *)v10;
      if (v26 == 10)
      {
        ++input->line;
        input->int col = 1;
        uint64_t v27 = (unsigned __int8 *)(v10 + 1);
        int v26 = v10[1];
      }
      if (v26 == 13 && v27[1] == 10)
      {
        input->cur = v27 + 1;
        int v10 = v27 + 2;
        ++input->line;
        input->int col = 1;
      }
      else
      {
        if (!ctxt->progressive)
        {
          if (v10 - input->base < 501 || input->end - v10 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
          {
            if (ctxt->input->end - ctxt->input->cur <= 249) {
              xmlGROW((uint64_t)ctxt);
            }
          }
        }
        if (ctxt->instate == XML_PARSER_EOF) {
          goto LABEL_75;
        }
        xmlParserInputPtr input = ctxt->input;
        int v10 = input->cur;
        int v11 = *v10;
        if (v11 != 45)
        {
          if ((char)v11 > 31 || (v11 - 9) < 2) {
            goto LABEL_17;
          }
          xmlParseCommentComplex((uint64_t)ctxt, v8, v9, v12);
LABEL_87:
          if (ctxt->instate == XML_PARSER_EOF) {
            return;
          }
LABEL_91:
          ctxt->xmlParserInputState instate = v35;
          return;
        }
        if (v10[1] == 45)
        {
          if (v10[2] == 62)
          {
            if (input->id != id)
            {
              xmlFatalErrMsg(ctxt, 90, (char)"comment doesn't start and stop in the same entity\n");
              xmlParserInputPtr input = ctxt->input;
              int v10 = input->cur;
            }
            input->cur = v10 + 3;
            input->col += 3;
            if (!v10[3]) {
              xmlParserInputGrow(input, 250);
            }
            if (ctxt->sax && (commentSAXFunc comment = ctxt->sax->comment) != 0 && !ctxt->disableSAX)
            {
              userData = ctxt->userData;
              if (!v8)
              {
                ((void (*)(void *, const char *))comment)(userData, "");
                goto LABEL_87;
              }
              ((void (*)(void *, char *))comment)(userData, v8);
            }
            else if (!v8)
            {
              goto LABEL_87;
            }
            xmlFree(v8);
            goto LABEL_87;
          }
          if (v8)
          {
            unsigned int v28 = "Double hyphen within comment: <!--%.50s\n";
            int v29 = (const xmlChar *)v8;
          }
          else
          {
            unsigned int v28 = "Double hyphen within comment\n";
            int v29 = 0;
          }
          xmlFatalErrMsgStr(ctxt, 80, v28, v29);
          if (ctxt->instate == XML_PARSER_EOF) {
            goto LABEL_75;
          }
          xmlParserInputPtr input = ctxt->input;
          int v30 = input->col + 1;
          input->int col = v30;
          ++v10;
        }
        else
        {
          int v30 = input->col;
        }
        ++v10;
        input->int col = v30 + 1;
      }
    }
    xmlFatalErrMsgStr(ctxt, 45, "Comment too big found", 0);
LABEL_75:
    xmlFreeFunc v32 = xmlFree;
    ((void (*)(char *))v32)(v8);
  }
}

void xmlParseCommentComplex(uint64_t a1, unsigned char *a2, unint64_t a3, size_t a4)
{
  int v6 = a2;
  if ((*(unsigned char *)(a1 + 566) & 8) != 0) {
    unint64_t v8 = 1000000000;
  }
  else {
    unint64_t v8 = 10000000;
  }
  int v9 = *(_DWORD *)(*(void *)(a1 + 56) + 100);
  if (!a2)
  {
    a4 = 100;
    int v10 = xmlMallocAtomic(0x64uLL);
    if (!v10)
    {
      htmlErrMemory((_DWORD *)a1, 0);
      return;
    }
    int v6 = v10;
    a3 = 0;
  }
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40) - *(void *)(*(void *)(a1 + 56) + 32)) <= 249)
  {
    xmlGROW(a1);
  }
  *(void *)int len = 0;
  int v42 = 0;
  int v11 = xmlCurrentChar((xmlParserCtxtPtr)a1, &len[1]);
  if (!v11) {
    goto LABEL_91;
  }
  int v12 = v11;
  if (v11 > 255)
  {
    if ((v11 - 0x10000) >= 0x100000
      && v11 >> 11 >= 0x1B
      && (v11 - 57344) >> 1 >= 0xFFF)
    {
LABEL_36:
      int v18 = (_DWORD *)a1;
      int v19 = v12;
LABEL_37:
      xmlFatalErrMsgInt(v18, 9, "xmlParseComment: invalid xmlChar value %d\n", v19);
      goto LABEL_94;
    }
  }
  else if (v11 <= 31 && (v11 > 0xD || ((1 << v11) & 0x2600) == 0))
  {
    goto LABEL_36;
  }
  uint64_t v13 = *(void *)(a1 + 56);
  int v14 = *(unsigned char **)(v13 + 32);
  xmlParserInputPtr v15 = &v14[len[1]];
  if ((unint64_t)v15 <= *(void *)(v13 + 40))
  {
    if (*v14 == 10)
    {
      ++*(_DWORD *)(v13 + 52);
      *(_DWORD *)(v13 + 56) = 1;
    }
    else
    {
      ++*(_DWORD *)(v13 + 56);
    }
    *(void *)(v13 + 32) = v15;
  }
  int v16 = xmlCurrentChar((xmlParserCtxtPtr)a1, len);
  if (!v16) {
    goto LABEL_91;
  }
  int v17 = v16;
  if (v16 > 255)
  {
    if ((v16 - 0x10000) >= 0x100000
      && v16 >> 11 >= 0x1B
      && (v16 - 57344) >> 1 >= 0xFFF)
    {
      goto LABEL_36;
    }
  }
  else if (v16 <= 31 && (v16 > 0xD || ((1 << v16) & 0x2600) == 0))
  {
    goto LABEL_36;
  }
  uint64_t v20 = *(void *)(a1 + 56);
  xmlParserInputState v21 = *(unsigned char **)(v20 + 32);
  size_t v22 = &v21[len[0]];
  if ((unint64_t)v22 <= *(void *)(v20 + 40))
  {
    if (*v21 == 10)
    {
      ++*(_DWORD *)(v20 + 52);
      *(_DWORD *)(v20 + 56) = 1;
    }
    else
    {
      ++*(_DWORD *)(v20 + 56);
    }
    *(void *)(v20 + 32) = v22;
  }
  int v23 = xmlCurrentChar((xmlParserCtxtPtr)a1, &v42);
  if (!v23)
  {
LABEL_91:
    size_t v38 = "Comment not terminated\n";
LABEL_92:
    int v39 = (_DWORD *)a1;
    xmlEntityPtr v40 = 0;
    goto LABEL_93;
  }
  int v24 = v23;
  unint64_t v25 = 0;
  while (1)
  {
    if (v24 > 255)
    {
      if ((v24 - 0x10000) >= 0x100000
        && v24 >> 11 >= 0x1B
        && (v24 - 57344) >> 1 >= 0xFFF)
      {
        v6[a3] = 0;
LABEL_95:
        int v18 = (_DWORD *)a1;
        int v19 = v24;
        goto LABEL_37;
      }
      goto LABEL_57;
    }
    if (v24 <= 31) {
      break;
    }
    if (v12 == 45 && v17 == 45 && v24 == 62)
    {
      v6[a3] = 0;
      if (v9 != *(_DWORD *)(*(void *)(a1 + 56) + 100)) {
        xmlFatalErrMsg((_DWORD *)a1, 90, (char)"Comment doesn't start and stop in the same entity\n");
      }
      xmlNextChar((xmlParserCtxtPtr)a1);
      if (*(void *)a1)
      {
        xmlEntityPtr v41 = *(void (**)(void, unsigned char *))(*(void *)a1 + 160);
        if (v41)
        {
          if (!*(_DWORD *)(a1 + 332)) {
            v41(*(void *)(a1 + 8), v6);
          }
        }
      }
      goto LABEL_94;
    }
LABEL_57:
    if (v12 == 45 && v17 == 45) {
      xmlFatalErr((_DWORD *)a1, 80, 0);
    }
    if (a3 + 5 >= a4)
    {
      a4 *= 2;
      int v26 = xmlRealloc(v6, a4);
      if (!v26)
      {
        xmlFree(v6);
        htmlErrMemory((_DWORD *)a1, 0);
        return;
      }
      int v6 = v26;
    }
    if (len[1] == 1) {
      v6[a3++] = v12;
    }
    else {
      a3 += xmlCopyCharMultiByte(&v6[a3], v12);
    }
    int v28 = v42;
    int v27 = len[0];
    len[0] = v42;
    len[1] = v27;
    if (v25 < 0x32)
    {
      ++v25;
    }
    else
    {
      if (!*(_DWORD *)(a1 + 452))
      {
        int v29 = *(void **)(a1 + 56);
        uint64_t v30 = v29[4];
        if (v30 - v29[3] < 501 || v29[5] - v30 > 499 || (xmlSHRINK(a1), !*(_DWORD *)(a1 + 452)))
        {
          if ((uint64_t)(*(void *)(*(void *)(a1 + 56) + 40) - *(void *)(*(void *)(a1 + 56) + 32)) <= 249) {
            xmlGROW(a1);
          }
        }
      }
      if (*(_DWORD *)(a1 + 272) == -1) {
        goto LABEL_94;
      }
      unint64_t v25 = 0;
      int v28 = v42;
    }
    uint64_t v31 = *(void *)(a1 + 56);
    xmlFreeFunc v32 = *(unsigned char **)(v31 + 32);
    uint64_t v33 = &v32[v28];
    if ((unint64_t)v33 <= *(void *)(v31 + 40))
    {
      if (*v32 == 10)
      {
        ++*(_DWORD *)(v31 + 52);
        int v34 = 1;
      }
      else
      {
        int v34 = *(_DWORD *)(v31 + 56) + 1;
      }
      *(_DWORD *)(v31 + 56) = v34;
      *(void *)(v31 + 32) = v33;
    }
    int v35 = xmlCurrentChar((xmlParserCtxtPtr)a1, &v42);
    if (!v35)
    {
      if (!*(_DWORD *)(a1 + 452))
      {
        int v36 = *(void **)(a1 + 56);
        uint64_t v37 = v36[4];
        if (v37 - v36[3] < 501 || v36[5] - v37 > 499 || (xmlSHRINK(a1), !*(_DWORD *)(a1 + 452)))
        {
          if ((uint64_t)(*(void *)(*(void *)(a1 + 56) + 40) - *(void *)(*(void *)(a1 + 56) + 32)) <= 249) {
            xmlGROW(a1);
          }
        }
      }
      int v35 = xmlCurrentChar((xmlParserCtxtPtr)a1, &v42);
    }
    int v12 = v17;
    int v17 = v24;
    int v24 = v35;
    if (a3 > v8)
    {
      size_t v38 = "Comment too big found";
      goto LABEL_92;
    }
  }
  if (v24 <= 0xD && ((1 << v24) & 0x2600) != 0) {
    goto LABEL_57;
  }
  v6[a3] = 0;
  if (v24) {
    goto LABEL_95;
  }
  size_t v38 = "Comment not terminated \n<!--%.50s\n";
  int v39 = (_DWORD *)a1;
  xmlEntityPtr v40 = v6;
LABEL_93:
  xmlFatalErrMsgStr(v39, 45, v38, v40);
LABEL_94:
  xmlFree(v6);
}

const xmlChar *__cdecl xmlParsePITarget(xmlParserCtxtPtr ctxt)
{
  unint64_t v2 = xmlParseName(ctxt);
  signed int v3 = v2;
  if (v2)
  {
    int v4 = *v2;
    if ((v4 | 0x20) == 0x78 && (int v5 = v2[1], (v5 | 0x20) == 0x6D) && (v6 = v2[2], (v6 | 0x20) == 0x6C))
    {
      if (v4 == 120 && v5 == 109 && v6 == 108)
      {
        if (!v2[3])
        {
          xmlFatalErrMsg(ctxt, 64, (char)"XML declaration allowed only at the start of the document\n");
          return v3;
        }
      }
      else if (!v2[3])
      {
        xmlFatalErr(ctxt, 64, 0);
        return v3;
      }
      uint64_t v7 = 0;
      while (!xmlStrEqual(v3, (const xmlChar *)xmlW3CPIs[v7]))
      {
        if (++v7 == 2)
        {
          xmlWarningMsg(ctxt, 64, "xmlParsePITarget: invalid name prefix 'xml'\n", 0);
          goto LABEL_15;
        }
      }
    }
    else
    {
LABEL_15:
      if (xmlStrchr(v3, 0x3Au)) {
        xmlNsErr(ctxt, 205, "colons are forbidden from PI names '%s'\n", v3, 0, 0);
      }
    }
  }
  return v3;
}

_DWORD *xmlNsErr(_DWORD *result, int a2, const char *a3, const xmlChar *a4, xmlChar *a5, xmlChar *a6)
{
  if (!result) {
    return __xmlRaiseError(0, 0, 0, 0, 0, 3u, a2, 2, 0, 0, a4, a5, a6, 0, 0, a3, (char)a4);
  }
  int v6 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    __n128 result = __xmlRaiseError(0, 0, 0, result, 0, 3u, a2, 2, 0, 0, a4, a5, a6, 0, 0, a3, (char)a4);
    v6[140] = 0;
  }
  return result;
}

void xmlParsePI(xmlParserCtxtPtr ctxt)
{
  if ((ctxt->options & 0x80000) != 0) {
    unint64_t v2 = 1000000000;
  }
  else {
    unint64_t v2 = 10000000;
  }
  int len = 0;
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur == 60 && cur[1] == 63)
  {
    int id = input->id;
    xmlParserInputState instate = ctxt->instate;
    ctxt->xmlParserInputState instate = XML_PARSER_PI;
    input->cur = cur + 2;
    input->col += 2;
    if (!cur[2]) {
      xmlParserInputGrow(input, 250);
    }
    if (!ctxt->progressive)
    {
      xmlParserInputPtr v7 = ctxt->input;
      unint64_t v8 = v7->cur;
      if (v8 - v7->base >= 501 && v7->end - v8 <= 499) {
        xmlSHRINK((uint64_t)ctxt);
      }
    }
    int v9 = xmlParsePITarget(ctxt);
    if (v9)
    {
      int v10 = v9;
      xmlParserInputPtr v11 = ctxt->input;
      int v12 = v11->cur;
      if (*v12 != 63 || v12[1] != 62)
      {
        int v14 = xmlMallocAtomic(0x64uLL);
        if (v14)
        {
          xmlParserInputPtr v15 = v14;
          int v31 = id;
          xmlParserInputState v32 = instate;
          if (!xmlSkipBlankChars(ctxt)) {
            xmlFatalErrMsgStr(ctxt, 65, "ParsePI: PI %s space expected\n", v10);
          }
          int v16 = xmlCurrentChar(ctxt, &len);
          unint64_t v17 = 0;
          int v18 = 0;
          size_t v19 = 100;
          while (1)
          {
            if (v16 > 255)
            {
              if ((v16 - 0x10000) >= 0x100000
                && v16 >> 11 >= 0x1B
                && (v16 - 57344) >> 1 >= 0xFFF)
              {
LABEL_74:
                v15[v17] = 0;
                xmlFatalErrMsgStr(ctxt, 47, "ParsePI: PI %s never end ...\n", v10);
                xmlParserInputState instate = v32;
LABEL_75:
                xmlFree(v15);
                goto LABEL_70;
              }
            }
            else if (v16 <= 31)
            {
              if (v16 > 0xD || ((1 << v16) & 0x2600) == 0) {
                goto LABEL_74;
              }
            }
            else if (v16 == 63 && *((unsigned char *)ctxt->input->cur + 1) == 62)
            {
              v15[v17] = 0;
              xmlParserInputPtr v28 = ctxt->input;
              if (v31 != v28->id)
              {
                xmlFatalErrMsg(ctxt, 90, (char)"PI declaration doesn't start and stop in the same entity\n");
                xmlParserInputPtr v28 = ctxt->input;
              }
              int v29 = v28->cur;
              v28->cur = v29 + 2;
              v28->col += 2;
              xmlParserInputState instate = v32;
              if (!v29[2]) {
                xmlParserInputGrow(v28, 250);
              }
              if (v32 <= XML_PARSER_MISC
                && xmlStrEqual(v10, (const xmlChar *)"oasis-xml-catalog")
                && (xmlCatalogGetDefaults() & 0xFFFFFFFE) == 2)
              {
                xmlParseCatalogPI((uint64_t)ctxt, v15);
              }
              if (ctxt->sax)
              {
                if (!ctxt->disableSAX)
                {
                  processingInstructionSAXFunc processingInstruction = ctxt->sax->processingInstruction;
                  if (processingInstruction) {
                    ((void (*)(void *, const xmlChar *, unsigned char *))processingInstruction)(ctxt->userData, v10, v15);
                  }
                }
              }
              goto LABEL_75;
            }
            if (v17 + 5 >= v19)
            {
              v19 *= 2;
              uint64_t v20 = xmlRealloc(v15, v19);
              if (!v20)
              {
                htmlErrMemory(ctxt, 0);
                goto LABEL_77;
              }
              xmlParserInputPtr v15 = v20;
            }
            if (v18 < 50)
            {
              ++v18;
            }
            else
            {
              if (!ctxt->progressive)
              {
                xmlParserInputPtr v21 = ctxt->input;
                size_t v22 = v21->cur;
                if (v22 - v21->base < 501 || v21->end - v22 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
                {
                  if (ctxt->input->end - ctxt->input->cur <= 249) {
                    xmlGROW((uint64_t)ctxt);
                  }
                }
              }
              if (ctxt->instate == XML_PARSER_EOF)
              {
                xmlFree(v15);
                return;
              }
              int v18 = 0;
            }
            if (len == 1) {
              v15[v17++] = v16;
            }
            else {
              v17 += xmlCopyCharMultiByte(&v15[v17], v16);
            }
            xmlParserInputPtr v23 = ctxt->input;
            int v24 = v23->cur;
            unint64_t v25 = &v24[len];
            if (v25 <= v23->end)
            {
              if (*v24 == 10)
              {
                ++v23->line;
                v23->int col = 1;
              }
              else
              {
                ++v23->col;
              }
              v23->cur = v25;
            }
            int v16 = xmlCurrentChar(ctxt, &len);
            if (!v16)
            {
              if (!ctxt->progressive)
              {
                xmlParserInputPtr v26 = ctxt->input;
                int v27 = v26->cur;
                if (v27 - v26->base < 501 || v26->end - v27 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
                {
                  if (ctxt->input->end - ctxt->input->cur <= 249) {
                    xmlGROW((uint64_t)ctxt);
                  }
                }
              }
              int v16 = xmlCurrentChar(ctxt, &len);
            }
            if (v17 > v2)
            {
              xmlFatalErrMsgStr(ctxt, 47, "PI %s too big found", v10);
LABEL_77:
              xmlFree(v15);
              ctxt->xmlParserInputState instate = v32;
              return;
            }
          }
        }
        htmlErrMemory(ctxt, 0);
LABEL_73:
        ctxt->xmlParserInputState instate = instate;
        return;
      }
      if (id != v11->id)
      {
        xmlFatalErrMsg(ctxt, 90, (char)"PI declaration doesn't start and stop in the same entity\n");
        xmlParserInputPtr v11 = ctxt->input;
        int v12 = v11->cur;
      }
      v11->cur = v12 + 2;
      v11->col += 2;
      if (!v12[2]) {
        xmlParserInputGrow(v11, 250);
      }
      if (ctxt->sax && !ctxt->disableSAX)
      {
        processingInstructionSAXFunc v13 = ctxt->sax->processingInstruction;
        if (v13) {
          ((void (*)(void *, const xmlChar *, void))v13)(ctxt->userData, v10, 0);
        }
      }
    }
    else
    {
      xmlFatalErr(ctxt, 46, 0);
    }
LABEL_70:
    if (ctxt->instate == XML_PARSER_EOF) {
      return;
    }
    goto LABEL_73;
  }
}

const xmlChar *xmlParseCatalogPI(uint64_t a1, xmlChar *str1)
{
  for (uint64_t i = str1; ; ++i)
  {
    unsigned int v5 = *i;
    BOOL v6 = v5 > 0x20;
    uint64_t v7 = (1 << v5) & 0x100002600;
    if (v6 || v7 == 0) {
      break;
    }
  }
  if (xmlStrncmp(i, (const xmlChar *)"catalog", 7))
  {
LABEL_8:
    return (const xmlChar *)xmlWarningMsg((_DWORD *)a1, 93, "Catalog PI syntax error: %s\n", str1);
  }
  else
  {
    for (__n128 result = i + 9; ; ++result)
    {
      uint64_t v10 = *(result - 2);
      if (v10 > 0x3D) {
        break;
      }
      if (((1 << v10) & 0x100002600) == 0)
      {
        if (v10 != 61) {
          return result;
        }
        while (1)
        {
          unsigned int v11 = *(result - 1);
          if (v11 > 0x27) {
            goto LABEL_8;
          }
          if (((1 << v11) & 0x100002600) == 0)
          {
            if (((1 << v11) & 0x8400000000) == 0) {
              goto LABEL_8;
            }
            int v12 = -1;
            processingInstructionSAXFunc v13 = result;
            do
            {
              int v15 = *v13++;
              int v14 = v15;
              ++v12;
              if (v15) {
                BOOL v16 = v14 == v11;
              }
              else {
                BOOL v16 = 1;
              }
            }
            while (!v16);
            if (!v14) {
              goto LABEL_8;
            }
            __n128 result = xmlStrndup(result, v12);
            unint64_t v17 = result;
            for (uint64_t j = 0; ; ++j)
            {
              unsigned int v19 = v13[j];
              if (v19 > 0x20) {
                break;
              }
              if (((1 << v19) & 0x100002600) == 0)
              {
                if (!v13[j])
                {
                  if (!result) {
                    return result;
                  }
                  *(void *)(a1 + 440) = xmlCatalogAddLocal(*(void **)(a1 + 440), result);
                  goto LABEL_35;
                }
                break;
              }
            }
            __n128 result = (const xmlChar *)xmlWarningMsg((_DWORD *)a1, 93, "Catalog PI syntax error: %s\n", str1);
            if (!v17) {
              return result;
            }
LABEL_35:
            xmlFreeFunc v20 = xmlFree;
            return (const xmlChar *)((uint64_t (*)(const xmlChar *))v20)(v17);
          }
          ++result;
        }
      }
    }
  }
  return result;
}

void xmlParseNotationDecl(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur != 60
    || cur[1] != 33
    || cur[2] != 78
    || cur[3] != 79
    || cur[4] != 84
    || cur[5] != 65
    || cur[6] != 84
    || cur[7] != 73
    || cur[8] != 79
    || cur[9] != 78)
  {
    return;
  }
  int id = input->id;
  input->cur = cur + 10;
  input->col += 10;
  if (!cur[10]) {
    xmlParserInputGrow(input, 250);
  }
  if (!ctxt->progressive)
  {
    xmlParserInputPtr v5 = ctxt->input;
    BOOL v6 = v5->cur;
    if (v6 - v5->base >= 501 && v5->end - v6 <= 499) {
      xmlSHRINK((uint64_t)ctxt);
    }
  }
  if (!xmlSkipBlankChars(ctxt))
  {
    int v12 = "Space required after '<!NOTATION'\n";
LABEL_34:
    xmlFatalErrMsg(ctxt, 65, (char)v12);
    return;
  }
  uint64_t v7 = xmlParseName(ctxt);
  if (v7)
  {
    unint64_t v8 = v7;
    if (xmlStrchr(v7, 0x3Au)) {
      xmlNsErr(ctxt, 205, "colons are forbidden from notation names '%s'\n", v8, 0, 0);
    }
    if (xmlSkipBlankChars(ctxt))
    {
      publicID = 0;
      int v9 = xmlParseExternalID(ctxt, &publicID, 0);
      xmlSkipBlankChars(ctxt);
      xmlParserInputPtr v10 = ctxt->input;
      if (*v10->cur == 62)
      {
        if (id != v10->id) {
          xmlFatalErrMsg(ctxt, 90, (char)"Notation declaration doesn't start and stop in the same entity\n");
        }
        xmlNextChar(ctxt);
        if (ctxt->sax)
        {
          if (!ctxt->disableSAX)
          {
            notationDeclSAXFunc notationDecl = ctxt->sax->notationDecl;
            if (notationDecl) {
              ((void (*)(void *, const xmlChar *, xmlChar *, xmlChar *))notationDecl)(ctxt->userData, v8, publicID, v9);
            }
          }
        }
      }
      else
      {
        xmlFatalErr(ctxt, 49, 0);
      }
      if (v9) {
        xmlFree(v9);
      }
      if (publicID)
      {
        processingInstructionSAXFunc v13 = (void (*)(void))xmlFree;
        v13();
      }
      return;
    }
    int v12 = "Space required after the NOTATION name'\n";
    goto LABEL_34;
  }

  xmlFatalErr(ctxt, 48, 0);
}

void xmlParseEntityDecl(xmlParserCtxtPtr ctxt)
{
  int v36 = 0;
  publicID = 0;
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur != 60
    || cur[1] != 33
    || cur[2] != 69
    || cur[3] != 78
    || cur[4] != 84
    || cur[5] != 73
    || cur[6] != 84
    || cur[7] != 89)
  {
    return;
  }
  int id = input->id;
  input->cur = cur + 8;
  input->col += 8;
  if (!cur[8]) {
    xmlParserInputGrow(input, 250);
  }
  if (!ctxt->progressive)
  {
    xmlParserInputPtr v5 = ctxt->input;
    BOOL v6 = v5->cur;
    if (v6 - v5->base >= 501 && v5->end - v6 <= 499) {
      xmlSHRINK((uint64_t)ctxt);
    }
  }
  if (!xmlSkipBlankChars(ctxt)) {
    xmlFatalErrMsg(ctxt, 65, (char)"Space required after '<!ENTITY'\n");
  }
  int v7 = *ctxt->input->cur;
  if (v7 == 37)
  {
    xmlNextChar(ctxt);
    if (!xmlSkipBlankChars(ctxt)) {
      xmlFatalErrMsg(ctxt, 65, (char)"Space required after '%%'\n");
    }
  }
  unint64_t v8 = xmlParseName(ctxt);
  if (v8)
  {
    int v9 = v8;
    if (xmlStrchr(v8, 0x3Au)) {
      xmlNsErr(ctxt, 205, "colons are forbidden from entities names '%s'\n", v9, 0, 0);
    }
    if (!xmlSkipBlankChars(ctxt)) {
      xmlFatalErrMsg(ctxt, 65, (char)"Space required after the entity name\n");
    }
    ctxt->xmlParserInputState instate = XML_PARSER_ENTITY_DECL;
    int v10 = *ctxt->input->cur;
    if (v7 == 37)
    {
      if (v10 == 39 || v10 == 34)
      {
        unsigned int v11 = (xmlURI *)xmlParseEntityValue(ctxt, &v36);
        if (v11)
        {
          if (ctxt->sax)
          {
            if (!ctxt->disableSAX)
            {
              entityDeclSAXFunc entityDecl = ctxt->sax->entityDecl;
              if (entityDecl) {
                ((void (*)(void *, const xmlChar *, uint64_t, void, void, xmlURI *))entityDecl)(ctxt->userData, v9, 4, 0, 0, v11);
              }
            }
          }
        }
        goto LABEL_50;
      }
      int v18 = xmlParseExternalID(ctxt, &publicID, 1);
      BOOL v16 = publicID;
      if (!((unint64_t)v18 | (unint64_t)publicID))
      {
        xmlFatalErr(ctxt, 84, 0);
        BOOL v16 = 0;
        unsigned int v11 = 0;
        goto LABEL_51;
      }
      unint64_t v17 = v18;
      if (v18)
      {
        xmlURIPtr v20 = xmlParseURI((const char *)v18);
        unsigned int v11 = v20;
        if (!v20)
        {
          xmlErrMsgStr(ctxt, 91, "Invalid URI: %s\n", v17);
          goto LABEL_99;
        }
        if (v20->fragment)
        {
          xmlFatalErr(ctxt, 92, 0);
        }
        else if (ctxt->sax)
        {
          if (!ctxt->disableSAX)
          {
            entityDeclSAXFunc v35 = ctxt->sax->entityDecl;
            if (v35) {
              ((void (*)(void *, const xmlChar *, uint64_t, xmlChar *, xmlChar *, void))v35)(ctxt->userData, v9, 5, v16, v17, 0);
            }
          }
        }
        xmlFreeURI(v11);
      }
LABEL_98:
      unsigned int v11 = 0;
      goto LABEL_99;
    }
    if (v10 == 39 || v10 == 34)
    {
      unsigned int v11 = (xmlURI *)xmlParseEntityValue(ctxt, &v36);
      if (ctxt->sax)
      {
        if (!ctxt->disableSAX)
        {
          entityDeclSAXFunc v13 = ctxt->sax->entityDecl;
          if (v13) {
            ((void (*)(void *, const xmlChar *, uint64_t, void, void, xmlURI *))v13)(ctxt->userData, v9, 1, 0, 0, v11);
          }
        }
      }
      xmlDocPtr myDoc = ctxt->myDoc;
      if (!myDoc) {
        goto LABEL_45;
      }
      if (!xmlStrEqual(myDoc->version, (const xmlChar *)"SAX compatibility mode document"))
      {
LABEL_50:
        BOOL v16 = 0;
LABEL_51:
        unint64_t v17 = 0;
LABEL_99:
        if (ctxt->instate == XML_PARSER_EOF) {
          goto LABEL_118;
        }
        xmlSkipBlankChars(ctxt);
        xmlParserInputPtr v30 = ctxt->input;
        if (*v30->cur == 62)
        {
          if (id != v30->id) {
            xmlFatalErrMsg(ctxt, 90, (char)"Entity declaration doesn't start and stop in the same entity\n");
          }
          xmlNextChar(ctxt);
        }
        else
        {
          xmlFatalErrMsgStr(ctxt, 37, "xmlParseEntityDecl: entity %s not terminated\n", v9);
          xmlHaltParser(ctxt);
        }
        if (!v36) {
          goto LABEL_118;
        }
        sax = ctxt->sax;
        if (v7 == 37)
        {
          if (!sax) {
            goto LABEL_118;
          }
          getParameterEntitySAXFunc getParameterEntity = (uint64_t (*)(void *, const xmlChar *))sax->getParameterEntity;
          if (!getParameterEntity) {
            goto LABEL_118;
          }
          xmlEntityPtr Entity = (xmlEntityPtr)getParameterEntity(ctxt->userData, v9);
        }
        else
        {
          if (sax)
          {
            getxmlEntityPtr Entity = (uint64_t (*)(void *, const xmlChar *))sax->getEntity;
            if (getEntity)
            {
              xmlEntityPtr Entity = (xmlEntityPtr)getEntity(ctxt->userData, v9);
              if (Entity)
              {
LABEL_116:
                if (!Entity->orig)
                {
                  Entity->orig = v36;
                  int v36 = 0;
                }
                goto LABEL_118;
              }
            }
          }
          if (ctxt->userData != ctxt)
          {
LABEL_118:
            if (v11) {
              xmlFree(v11);
            }
            if (v17) {
              xmlFree(v17);
            }
            if (v16) {
              xmlFree(v16);
            }
            if (v36) {
              xmlFree(v36);
            }
            return;
          }
          xmlEntityPtr Entity = xmlSAX2GetEntity(ctxt, v9);
        }
        if (Entity) {
          goto LABEL_116;
        }
        goto LABEL_118;
      }
      xmlDocPtr v15 = ctxt->myDoc;
      if (!v15)
      {
LABEL_45:
        xmlDocPtr v15 = xmlNewDoc((const xmlChar *)"SAX compatibility mode document");
        ctxt->xmlDocPtr myDoc = v15;
        if (!v15)
        {
          htmlErrMemory(ctxt, (const xmlChar *)"New Doc failed");
          return;
        }
        v15->int properties = 64;
      }
      if (!v15->intSubset) {
        ctxt->myDoc->intSubset = xmlNewDtd(v15, (const xmlChar *)"fake", 0, 0);
      }
      xmlSAX2EntityDecl(ctxt, v9, 1, 0, 0, (xmlChar *)v11);
      goto LABEL_50;
    }
    unsigned int v19 = xmlParseExternalID(ctxt, &publicID, 1);
    unint64_t v17 = v19;
    BOOL v16 = publicID;
    if ((unint64_t)v19 | (unint64_t)publicID)
    {
      if (v19)
      {
        xmlURIPtr v21 = xmlParseURI((const char *)v19);
        if (v21)
        {
          size_t v22 = v21;
          if (v21->fragment) {
            xmlFatalErr(ctxt, 92, 0);
          }
          xmlFreeURI(v22);
        }
        else
        {
          xmlErrMsgStr(ctxt, 91, "Invalid URI: %s\n", v17);
        }
      }
    }
    else
    {
      xmlFatalErr(ctxt, 84, 0);
    }
    if (*ctxt->input->cur != 62 && !xmlSkipBlankChars(ctxt)) {
      xmlFatalErrMsg(ctxt, 65, (char)"Space required before 'NDATA'\n");
    }
    xmlParserInputPtr v23 = ctxt->input;
    int v24 = v23->cur;
    if (*v24 == 78 && v24[1] == 68 && v24[2] == 65 && v24[3] == 84 && v24[4] == 65)
    {
      v23->cur = v24 + 5;
      v23->col += 5;
      if (!v24[5]) {
        xmlParserInputGrow(v23, 250);
      }
      if (!xmlSkipBlankChars(ctxt)) {
        xmlFatalErrMsg(ctxt, 65, (char)"Space required after 'NDATA'\n");
      }
      unint64_t v25 = xmlParseName(ctxt);
      if (ctxt->sax)
      {
        if (!ctxt->disableSAX)
        {
          unparsedEntityDeclSAXFunc unparsedEntityDecl = ctxt->sax->unparsedEntityDecl;
          if (unparsedEntityDecl) {
            ((void (*)(void *, const xmlChar *, xmlChar *, xmlChar *, const xmlChar *))unparsedEntityDecl)(ctxt->userData, v9, v16, v17, v25);
          }
        }
      }
      goto LABEL_98;
    }
    if (ctxt->sax)
    {
      if (!ctxt->disableSAX)
      {
        entityDeclSAXFunc v27 = ctxt->sax->entityDecl;
        if (v27) {
          ((void (*)(void *, const xmlChar *, uint64_t, xmlChar *, xmlChar *, void))v27)(ctxt->userData, v9, 2, v16, v17, 0);
        }
      }
    }
    if (!ctxt->replaceEntities) {
      goto LABEL_98;
    }
    xmlDocPtr v28 = ctxt->myDoc;
    if (v28)
    {
      if (!xmlStrEqual(v28->version, (const xmlChar *)"SAX compatibility mode document")) {
        goto LABEL_98;
      }
      xmlDocPtr v29 = ctxt->myDoc;
      if (v29)
      {
LABEL_95:
        if (!v29->intSubset) {
          ctxt->myDoc->intSubset = xmlNewDtd(v29, (const xmlChar *)"fake", 0, 0);
        }
        xmlSAX2EntityDecl(ctxt, v9, 2, v16, v17, 0);
        goto LABEL_98;
      }
    }
    xmlDocPtr v29 = xmlNewDoc((const xmlChar *)"SAX compatibility mode document");
    ctxt->xmlDocPtr myDoc = v29;
    if (v29)
    {
      v29->int properties = 64;
      goto LABEL_95;
    }
    htmlErrMemory(ctxt, (const xmlChar *)"New Doc failed");
  }
  else
  {
    xmlFatalErrMsg(ctxt, 68, (char)"xmlParseEntityDecl: no name\n");
  }
}

_DWORD *xmlErrMsgStr(_DWORD *result, int a2, const char *a3, const xmlChar *a4)
{
  if (!result) {
    return __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 2, 0, 0, a4, 0, 0, 0, 0, a3, (char)a4);
  }
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    return __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 2, 0, 0, a4, 0, 0, 0, 0, a3, (char)a4);
  }
  return result;
}

int xmlParseDefaultDecl(xmlParserCtxtPtr ctxt, xmlChar **value)
{
  *unsigned int value = 0;
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur != 35)
  {
    int v7 = 1;
    goto LABEL_36;
  }
  int v6 = cur[1];
  if (v6 == 70)
  {
    if (cur[2] == 73 && cur[3] == 88 && cur[4] == 69 && cur[5] == 68)
    {
      input->cur = cur + 6;
      input->col += 6;
      if (!cur[6]) {
        xmlParserInputGrow(input, 250);
      }
      if (!xmlSkipBlankChars(ctxt)) {
        xmlFatalErrMsg(ctxt, 65, (char)"Space required after '#FIXED'\n");
      }
      int v7 = 4;
LABEL_35:
      if (!ctxt->input)
      {
        ctxt->xmlParserInputState instate = XML_PARSER_DTD;
        goto LABEL_39;
      }
LABEL_36:
      unint64_t v8 = xmlParseAttValueInternal((uint64_t)ctxt, 0, 0, 0);
      ctxt->xmlParserInputState instate = XML_PARSER_DTD;
      if (v8)
      {
        *unsigned int value = v8;
        return v7;
      }
LABEL_39:
      xmlFatalErrMsg(ctxt, ctxt->errNo, (char)"Attribute default value declaration error\n");
      return v7;
    }
    goto LABEL_34;
  }
  if (v6 != 73)
  {
    if (v6 == 82
      && cur[2] == 69
      && cur[3] == 81
      && cur[4] == 85
      && cur[5] == 73
      && cur[6] == 82
      && cur[7] == 69
      && cur[8] == 68)
    {
      input->cur = cur + 9;
      input->col += 9;
      if (!cur[9]) {
        xmlParserInputGrow(input, 250);
      }
      return 2;
    }
    goto LABEL_34;
  }
  if (cur[2] != 77 || cur[3] != 80 || cur[4] != 76 || cur[5] != 73 || cur[6] != 69 || cur[7] != 68)
  {
LABEL_34:
    int v7 = 1;
    goto LABEL_35;
  }
  input->cur = cur + 8;
  input->col += 8;
  if (!cur[8]) {
    xmlParserInputGrow(input, 250);
  }
  return 3;
}

xmlEnumerationPtr xmlParseNotationType(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur == 40)
  {
    if (!ctxt->progressive && cur - input->base >= 501 && input->end - cur <= 499) {
      xmlSHRINK((uint64_t)ctxt);
    }
    int v4 = 0;
    p_xmlNodePtr next = 0;
    do
    {
      xmlNextChar(ctxt);
      xmlSkipBlankChars(ctxt);
      int v6 = xmlParseName(ctxt);
      if (!v6)
      {
        xmlFatalErrMsg(ctxt, 68, (char)"Name expected in NOTATION declaration\n");
        goto LABEL_24;
      }
      int v7 = (xmlChar *)v6;
      unint64_t v8 = v4;
      if (v4)
      {
        while (!xmlStrEqual(v7, v8->name))
        {
          unint64_t v8 = v8->next;
          if (!v8) {
            goto LABEL_11;
          }
        }
        xmlValidityError(ctxt, 541, "standalone: attribute notation value token %s duplicated\n", v7, 0);
        if (!xmlDictOwns(ctxt->dict, v7)) {
          xmlFree(v7);
        }
      }
      else
      {
LABEL_11:
        xmlEnumerationPtr Enumeration = xmlCreateEnumeration(v7);
        if (!Enumeration) {
          goto LABEL_24;
        }
        if (p_next) {
          *p_xmlNodePtr next = Enumeration;
        }
        else {
          int v4 = Enumeration;
        }
        p_xmlNodePtr next = &Enumeration->next;
      }
      xmlSkipBlankChars(ctxt);
      int v10 = *ctxt->input->cur;
    }
    while (v10 == 124);
    if (v10 == 41)
    {
      xmlNextChar(ctxt);
      return v4;
    }
    xmlFatalErr(ctxt, 49, 0);
LABEL_24:
    xmlFreeEnumeration(v4);
  }
  else
  {
    xmlFatalErr(ctxt, 48, 0);
  }
  return 0;
}

_DWORD *xmlValidityError(_DWORD *result, int a2, const char *a3, const xmlChar *a4, xmlChar *a5)
{
  if (!result) {
    return __xmlRaiseError(0, 0, 0, 0, 0, 4u, a2, 2, 0, 0, a4, a5, 0, 0, 0, a3, (char)a4);
  }
  uint64_t v5 = (uint64_t)result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    uint64_t v6 = *(void *)result;
    if (*(void *)result && *(_DWORD *)(v6 + 216) == -554844497) {
      int v7 = *(void (__cdecl **)(void *, xmlErrorPtr))(v6 + 248);
    }
    else {
      int v7 = 0;
    }
    __n128 result = __xmlRaiseError(v7, *(void (**)(void *, const char *, ...))(v5 + 168), *(void **)(v5 + 160), (void *)v5, 0, 4u, a2, 2, 0, 0, a4, a5, 0, 0, 0, a3, (char)a4);
    *(_DWORD *)(v5 + 152) = 0;
  }
  return result;
}

xmlEnumerationPtr xmlParseEnumerationType(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur == 40)
  {
    if (!ctxt->progressive && cur - input->base >= 501 && input->end - cur <= 499) {
      xmlSHRINK((uint64_t)ctxt);
    }
    int v4 = 0;
    p_xmlNodePtr next = 0;
    while (1)
    {
      xmlNextChar(ctxt);
      xmlSkipBlankChars(ctxt);
      uint64_t v6 = xmlParseNmtoken(ctxt);
      if (!v6) {
        break;
      }
      int v7 = v6;
      unint64_t v8 = v4;
      if (v4)
      {
        while (!xmlStrEqual(v7, v8->name))
        {
          unint64_t v8 = v8->next;
          if (!v8) {
            goto LABEL_11;
          }
        }
        xmlValidityError(ctxt, 541, "standalone: attribute enumeration value token %s duplicated\n", v7, 0);
        if (!xmlDictOwns(ctxt->dict, v7)) {
          xmlFree(v7);
        }
      }
      else
      {
LABEL_11:
        xmlEnumerationPtr Enumeration = xmlCreateEnumeration(v7);
        if (!xmlDictOwns(ctxt->dict, v7)) {
          xmlFree(v7);
        }
        if (!Enumeration)
        {
          xmlFreeEnumeration(v4);
          return 0;
        }
        if (p_next) {
          *p_xmlNodePtr next = Enumeration;
        }
        else {
          int v4 = Enumeration;
        }
        p_xmlNodePtr next = &Enumeration->next;
      }
      xmlSkipBlankChars(ctxt);
      int v10 = *ctxt->input->cur;
      if (v10 != 124)
      {
        xmlParserCtxtPtr v11 = ctxt;
        if (v10 == 41)
        {
          xmlNextChar(ctxt);
          return v4;
        }
        int v12 = 51;
        goto LABEL_27;
      }
    }
    xmlParserCtxtPtr v11 = ctxt;
    int v12 = 67;
LABEL_27:
    xmlFatalErr(v11, v12, 0);
    return v4;
  }
  xmlFatalErr(ctxt, 50, 0);
  return 0;
}

int xmlParseEnumeratedType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree)
{
  xmlParserInputPtr input = ctxt->input;
  cur = (unsigned __int8 *)input->cur;
  if (__PAIR64__(cur[1], *cur) == 0x4F0000004ELL
    && cur[2] == 84
    && cur[3] == 65
    && cur[4] == 84
    && cur[5] == 73
    && cur[6] == 79
    && cur[7] == 78)
  {
    input->cur = cur + 8;
    input->col += 8;
    if (!cur[8]) {
      xmlParserInputGrow(input, 250);
    }
    if (!xmlSkipBlankChars(ctxt))
    {
      xmlFatalErrMsg(ctxt, 65, (char)"Space required after 'NOTATION'\n");
      return 0;
    }
    uint64_t v6 = xmlParseNotationType(ctxt);
    *tree = v6;
    BOOL v7 = v6 == 0;
    int v8 = 10;
  }
  else
  {
    int v9 = xmlParseEnumerationType(ctxt);
    *tree = v9;
    BOOL v7 = v9 == 0;
    int v8 = 9;
  }
  if (v7) {
    return 0;
  }
  else {
    return v8;
  }
}

int xmlParseAttributeType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree)
{
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  unsigned int v5 = *cur;
  if (v5 > 0x48)
  {
    if (v5 == 73)
    {
      if (cur[1] != 68) {
        goto LABEL_56;
      }
      BOOL v7 = cur + 2;
      if (cur[2] == 82 && cur[3] == 69 && cur[4] == 70 && cur[5] == 83)
      {
        input->cur = cur + 6;
        input->col += 6;
        if (!cur[6]) {
          xmlParserInputGrow(input, 250);
        }
        int v6 = 4;
      }
      else if (*v7 == 82 && cur[3] == 69 && cur[4] == 70)
      {
        input->cur = cur + 5;
        input->col += 5;
        if (!cur[5]) {
          xmlParserInputGrow(input, 250);
        }
        int v6 = 3;
      }
      else
      {
        input->cur = v7;
        input->col += 2;
        if (!*v7) {
          xmlParserInputGrow(input, 250);
        }
        int v6 = 2;
      }
    }
    else
    {
      if (v5 != 78 || cur[1] != 77) {
        goto LABEL_56;
      }
      if (cur[2] == 84 && cur[3] == 79 && cur[4] == 75 && cur[5] == 69 && cur[6] == 78 && cur[7] == 83)
      {
        input->cur = cur + 8;
        input->col += 8;
        if (!cur[8]) {
          xmlParserInputGrow(input, 250);
        }
        int v6 = 8;
      }
      else
      {
        if (cur[2] != 84 || cur[3] != 79 || cur[4] != 75 || cur[5] != 69 || cur[6] != 78) {
          goto LABEL_56;
        }
        input->cur = cur + 7;
        input->col += 7;
        if (!cur[7]) {
          xmlParserInputGrow(input, 250);
        }
        int v6 = 7;
      }
    }
  }
  else
  {
    if (v5 != 67)
    {
      if (v5 == 69 && cur[1] == 78)
      {
        if (cur[2] == 84 && cur[3] == 73 && cur[4] == 84 && cur[5] == 89)
        {
          input->cur = cur + 6;
          input->col += 6;
          if (!cur[6]) {
            xmlParserInputGrow(input, 250);
          }
          int v6 = 5;
          goto LABEL_57;
        }
        if (cur[2] == 84 && cur[3] == 73 && cur[4] == 84 && cur[5] == 73 && cur[6] == 69 && cur[7] == 83)
        {
          input->cur = cur + 8;
          input->col += 8;
          if (!cur[8]) {
            xmlParserInputGrow(input, 250);
          }
          int v6 = 6;
          goto LABEL_57;
        }
      }
LABEL_56:
      int v6 = xmlParseEnumeratedType(ctxt, tree);
      goto LABEL_57;
    }
    if (cur[1] != 68 || cur[2] != 65 || cur[3] != 84 || cur[4] != 65) {
      goto LABEL_56;
    }
    input->cur = cur + 5;
    input->col += 5;
    if (!cur[5]) {
      xmlParserInputGrow(input, 250);
    }
    int v6 = 1;
  }
LABEL_57:
  if (!ctxt->progressive)
  {
    xmlParserInputPtr v8 = ctxt->input;
    int v9 = v8->cur;
    if (v9 - v8->base >= 501 && v8->end - v9 <= 499) {
      xmlSHRINK((uint64_t)ctxt);
    }
  }
  return v6;
}

void xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur == 60
    && cur[1] == 33
    && cur[2] == 65
    && cur[3] == 84
    && cur[4] == 84
    && cur[5] == 76
    && cur[6] == 73
    && cur[7] == 83
    && cur[8] == 84)
  {
    int id = input->id;
    input->cur = cur + 9;
    input->col += 9;
    if (!cur[9]) {
      xmlParserInputGrow(input, 250);
    }
    if (!xmlSkipBlankChars(ctxt)) {
      xmlFatalErrMsg(ctxt, 65, (char)"Space required after '<!ATTLIST'\n");
    }
    unsigned int v5 = xmlParseName(ctxt);
    if (v5)
    {
      int v6 = (xmlChar *)v5;
      xmlSkipBlankChars(ctxt);
      xmlParserInputPtr v7 = ctxt->input;
      if (!ctxt->progressive && v7->end - v7->cur <= 249)
      {
        xmlGROW((uint64_t)ctxt);
        xmlParserInputPtr v7 = ctxt->input;
      }
      xmlParserInputPtr v8 = v7->cur;
      if (*v8 != 62)
      {
        while (1)
        {
          if (ctxt->instate == XML_PARSER_EOF) {
            goto LABEL_73;
          }
          xmlURIPtr v21 = 0;
          if (!ctxt->progressive && v7->end - v8 <= 249) {
            xmlGROW((uint64_t)ctxt);
          }
          xmlEnumerationPtr tree = 0;
          int v9 = xmlParseName(ctxt);
          if (!v9) {
            break;
          }
          int v10 = (xmlChar *)v9;
          if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
            xmlGROW((uint64_t)ctxt);
          }
          if (!xmlSkipBlankChars(ctxt))
          {
            int v18 = "Space required after the attribute name\n";
            xmlParserCtxtPtr v19 = ctxt;
            int v20 = 65;
            goto LABEL_66;
          }
          uint64_t v11 = xmlParseAttributeType(ctxt, &tree);
          if ((int)v11 < 1) {
            goto LABEL_72;
          }
          uint64_t v12 = v11;
          if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
            xmlGROW((uint64_t)ctxt);
          }
          if (!xmlSkipBlankChars(ctxt))
          {
            xmlFatalErrMsg(ctxt, 65, (char)"Space required after the attribute type\n");
            goto LABEL_70;
          }
          uint64_t v13 = xmlParseDefaultDecl(ctxt, &v21);
          int v14 = v21;
          if (v12 != 1 && v21) {
            xmlAttrNormalizeSpace((uint64_t)v21, v21);
          }
          xmlParserInputPtr v15 = ctxt->input;
          if (!ctxt->progressive && v15->end - v15->cur <= 249)
          {
            xmlGROW((uint64_t)ctxt);
            xmlParserInputPtr v15 = ctxt->input;
          }
          if (*v15->cur != 62 && !xmlSkipBlankChars(ctxt))
          {
            xmlFatalErrMsg(ctxt, 65, (char)"Space required after the attribute default value\n");
            if (v14) {
              xmlFree(v14);
            }
LABEL_70:
            if (tree) {
              xmlFreeEnumeration(tree);
            }
LABEL_72:
            xmlParserInputPtr v7 = ctxt->input;
            goto LABEL_73;
          }
          if (ctxt->sax && !ctxt->disableSAX && (attributeDeclSAXFunc attributeDecl = ctxt->sax->attributeDecl) != 0)
          {
            ((void (*)(void *, xmlChar *, xmlChar *, uint64_t, uint64_t, xmlChar *, xmlEnumerationPtr))attributeDecl)(ctxt->userData, v6, v10, v12, v13, v14, tree);
          }
          else if (tree)
          {
            xmlFreeEnumeration(tree);
          }
          int sax2 = ctxt->sax2;
          if (sax2 && v14 && v13 != 3 && v13 != 2)
          {
            xmlAddDefAttrs((uint64_t)ctxt, v6, v10, v14);
            int sax2 = ctxt->sax2;
          }
          if (sax2) {
            xmlAddSpecialAttr((uint64_t)ctxt, v6, v10, v12);
          }
          if (v14) {
            xmlFree(v14);
          }
          xmlParserInputPtr v7 = ctxt->input;
          if (!ctxt->progressive && v7->end - v7->cur <= 249)
          {
            xmlGROW((uint64_t)ctxt);
            xmlParserInputPtr v7 = ctxt->input;
          }
          xmlParserInputPtr v8 = v7->cur;
          if (*v8 == 62) {
            goto LABEL_73;
          }
        }
        int v18 = "ATTLIST: no name for Attribute\n";
        xmlParserCtxtPtr v19 = ctxt;
        int v20 = 68;
LABEL_66:
        xmlFatalErrMsg(v19, v20, (char)v18);
        goto LABEL_72;
      }
LABEL_73:
      if (*v7->cur == 62)
      {
        if (id != v7->id) {
          xmlFatalErrMsg(ctxt, 90, (char)"Attribute list declaration doesn't start and stop in the same entity\n");
        }
        xmlNextChar(ctxt);
      }
    }
    else
    {
      xmlFatalErrMsg(ctxt, 68, (char)"ATTLIST: no name for Element\n");
    }
  }
}

uint64_t xmlAttrNormalizeSpace(uint64_t result, unsigned char *a2)
{
  unint64_t v2 = (unsigned __int8 *)(result - 1);
  do
  {
    int v4 = *++v2;
    int v3 = v4;
  }
  while (v4 == 32);
  while (v3 == 32)
  {
    while (v3 == 32)
    {
      int v5 = *++v2;
      int v3 = v5;
    }
    if (v3)
    {
      LOBYTE(vxmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 32;
      goto LABEL_9;
    }
LABEL_10:
    int v3 = *v2;
  }
  if (v3)
  {
    ++v2;
LABEL_9:
    *a2++ = v3;
    goto LABEL_10;
  }
  *a2 = 0;
  return result;
}

_DWORD *xmlAddDefAttrs(uint64_t a1, xmlChar *name, xmlChar *name2, const xmlChar *a4)
{
  xmlParserInputPtr v8 = *(xmlHashTable **)(a1 + 552);
  if (v8)
  {
    __n128 result = xmlHashLookup2(v8, name, name2);
    if (result) {
      return result;
    }
  }
  int len = 0;
  if (!*(void *)(a1 + 544))
  {
    xmlHashTablePtr Dict = xmlHashCreateDict(10, *(xmlDictPtr *)(a1 + 456));
    *(void *)(a1 + 544) = Dict;
    if (!Dict) {
      return htmlErrMemory((_DWORD *)a1, 0);
    }
  }
  uint64_t v11 = xmlSplitQName3(name, &len);
  uint64_t v12 = *(xmlDict **)(a1 + 456);
  if (v11)
  {
    uint64_t v13 = xmlDictLookup(v12, v11, -1);
    int v14 = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), name, len);
  }
  else
  {
    uint64_t v13 = xmlDictLookup(v12, name, -1);
    int v14 = 0;
  }
  xmlParserInputPtr v15 = (int *)xmlHashLookup2(*(xmlHashTablePtr *)(a1 + 544), v13, v14);
  if (!v15)
  {
    xmlParserCtxtPtr v19 = (int *)xmlMalloc(0xA8uLL);
    if (!v19) {
      return htmlErrMemory((_DWORD *)a1, 0);
    }
    BOOL v16 = v19;
    *(void *)xmlParserCtxtPtr v19 = 0x400000000;
LABEL_14:
    if ((xmlHashUpdateEntry2(*(xmlHashTablePtr *)(a1 + 544), v13, v14, v16, 0) & 0x80000000) == 0) {
      goto LABEL_15;
    }
    xmlFree(v16);
    return htmlErrMemory((_DWORD *)a1, 0);
  }
  BOOL v16 = v15;
  int v17 = v15[1];
  if (*v15 >= v17)
  {
    int v18 = (int *)xmlRealloc(v15, (16 * ((unint64_t)(10 * v17) >> 1)) | 8);
    if (!v18) {
      return htmlErrMemory((_DWORD *)a1, 0);
    }
    BOOL v16 = v18;
    v18[1] *= 2;
    goto LABEL_14;
  }
LABEL_15:
  int v20 = xmlSplitQName3(name2, &len);
  xmlURIPtr v21 = *(xmlDict **)(a1 + 456);
  if (v20)
  {
    size_t v22 = xmlDictLookup(v21, v20, -1);
    xmlParserInputPtr v23 = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), name2, len);
  }
  else
  {
    size_t v22 = xmlDictLookup(v21, name2, -1);
    xmlParserInputPtr v23 = 0;
  }
  int v24 = 5 * *v16;
  unint64_t v25 = v16 + 2;
  *(void *)&v16[10 * *v16 + 2] = v22;
  *(void *)&v16[2 * v24 + 4] = v23;
  int len = xmlStrlen(a4);
  __n128 result = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), a4, len);
  int v26 = *v16;
  *(void *)&v25[10 * v26 + 4] = result;
  *(void *)&v25[10 * v26 + 6] = (char *)result + len;
  if (*(_DWORD *)(a1 + 148)) {
    entityDeclSAXFunc v27 = "external";
  }
  else {
    entityDeclSAXFunc v27 = 0;
  }
  *(void *)&v25[10 * v26 + 8] = v27;
  *BOOL v16 = v26 + 1;
  return result;
}

_DWORD *xmlAddSpecialAttr(uint64_t a1, xmlChar *name, xmlChar *name2, unsigned int a4)
{
  xmlHashTablePtr Dict = *(xmlHashTable **)(a1 + 552);
  if (Dict || (xmlHashTablePtr Dict = xmlHashCreateDict(10, *(xmlDictPtr *)(a1 + 456)), (*(void *)(a1 + 552) = Dict) != 0))
  {
    __n128 result = xmlHashLookup2(Dict, name, name2);
    if (!result)
    {
      int v10 = *(xmlHashTable **)(a1 + 552);
      return (_DWORD *)xmlHashAddEntry2(v10, name, name2, (void *)a4);
    }
  }
  else
  {
    return htmlErrMemory((_DWORD *)a1, 0);
  }
  return result;
}

xmlElementContentPtr xmlParseElementMixedContentDecl(xmlParserCtxtPtr ctxt, int inputchk)
{
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur == 35 && cur[1] == 80 && cur[2] == 67 && cur[3] == 68 && cur[4] == 65 && cur[5] == 84 && cur[6] == 65)
  {
    input->cur = cur + 7;
    input->col += 7;
    if (!cur[7]) {
      xmlParserInputGrow(input, 250);
    }
    xmlSkipBlankChars(ctxt);
    xmlParserInputPtr v6 = ctxt->input;
    if (!ctxt->progressive)
    {
      xmlParserInputPtr v7 = v6->cur;
      if (v7 - v6->base >= 501 && v6->end - v7 <= 499)
      {
        xmlSHRINK((uint64_t)ctxt);
        xmlParserInputPtr v6 = ctxt->input;
      }
    }
    int v8 = *v6->cur;
    if (v8 == 40 || v8 == 124)
    {
      xmlElementContentPtr v10 = xmlNewDocElementContent(ctxt->myDoc, 0, XML_ELEMENT_CONTENT_PCDATA);
      if (!v10) {
        return v10;
      }
    }
    else
    {
      if (v8 == 41)
      {
        if (v6->id != inputchk) {
          xmlFatalErrMsg(ctxt, 90, (char)"Element content declaration doesn't start and stop in the same entity\n");
        }
        xmlNextChar(ctxt);
        xmlElementContentPtr v9 = xmlNewDocElementContent(ctxt->myDoc, 0, XML_ELEMENT_CONTENT_PCDATA);
        xmlElementContentPtr v10 = v9;
        if (v9 && *ctxt->input->cur == 42)
        {
          v9->ocur = XML_ELEMENT_CONTENT_MULT;
          xmlNextChar(ctxt);
        }
        return v10;
      }
      xmlElementContentPtr v10 = 0;
    }
    int v14 = 0;
    xmlElementContentPtr v15 = v10;
    while (1)
    {
      BOOL v16 = ctxt->input->cur;
      int v17 = *v16;
      if (v17 != 124)
      {
        if (v17 != 41 || v16[1] != 42)
        {
LABEL_58:
          xmlFreeDocElementContent(ctxt->myDoc, v10);
          xmlParserCtxtPtr v11 = ctxt;
          int v12 = 52;
          goto LABEL_26;
        }
        if (v14)
        {
          xmlElementContentPtr v25 = xmlNewDocElementContent(ctxt->myDoc, v14, XML_ELEMENT_CONTENT_ELEMENT);
          v15->c2 = v25;
          if (v25) {
            v25->xmlNodePtr parent = v15;
          }
        }
        if (v10) {
          v10->ocur = XML_ELEMENT_CONTENT_MULT;
        }
        xmlParserInputPtr v26 = ctxt->input;
        if (v26->id != inputchk)
        {
          xmlFatalErrMsg(ctxt, 90, (char)"Element content declaration doesn't start and stop in the same entity\n");
          xmlParserInputPtr v26 = ctxt->input;
        }
        entityDeclSAXFunc v27 = v26->cur;
        v26->cur = v27 + 2;
        v26->col += 2;
        if (!v27[2]) {
          xmlParserInputGrow(v26, 250);
        }
        return v10;
      }
      if (ctxt->instate == XML_PARSER_EOF) {
        goto LABEL_58;
      }
      xmlNextChar(ctxt);
      xmlElementContentPtr v18 = xmlNewDocElementContent(ctxt->myDoc, 0, XML_ELEMENT_CONTENT_OR);
      xmlElementContentPtr v19 = v18;
      if (v14) {
        break;
      }
      if (!v18)
      {
        xmlDocPtr myDoc = ctxt->myDoc;
        xmlDocPtr v28 = v15;
        goto LABEL_61;
      }
      v18->c1 = v15;
      xmlElementContentPtr v22 = v15;
      xmlElementContentPtr v23 = v18;
      xmlElementContentPtr v10 = v18;
      if (v15) {
        goto LABEL_42;
      }
LABEL_43:
      xmlSkipBlankChars(ctxt);
      int v24 = xmlParseName(ctxt);
      if (!v24)
      {
        xmlFatalErrMsg(ctxt, 68, (char)"xmlParseElementMixedContentDecl : Name expected\n");
        xmlDocPtr myDoc = ctxt->myDoc;
LABEL_60:
        xmlDocPtr v28 = v10;
LABEL_61:
        xmlFreeDocElementContent(myDoc, v28);
        return 0;
      }
      int v14 = v24;
      xmlSkipBlankChars(ctxt);
      xmlElementContentPtr v15 = v19;
      if (!ctxt->progressive)
      {
        xmlElementContentPtr v15 = v19;
        if (ctxt->input->end - ctxt->input->cur <= 249)
        {
          xmlGROW((uint64_t)ctxt);
          xmlElementContentPtr v15 = v19;
        }
      }
    }
    xmlDocPtr myDoc = ctxt->myDoc;
    if (!v19) {
      goto LABEL_60;
    }
    xmlElementContentPtr v21 = xmlNewDocElementContent(myDoc, v14, XML_ELEMENT_CONTENT_ELEMENT);
    v19->c1 = v21;
    if (v21) {
      v21->xmlNodePtr parent = v19;
    }
    v15->c2 = v19;
    xmlElementContentPtr v22 = v19;
    xmlElementContentPtr v23 = v15;
LABEL_42:
    v22->xmlNodePtr parent = v23;
    goto LABEL_43;
  }
  xmlParserCtxtPtr v11 = ctxt;
  int v12 = 69;
LABEL_26:
  xmlFatalErr(v11, v12, 0);
  return 0;
}

xmlElementContentPtr xmlParseElementChildrenContentDecl(xmlParserCtxtPtr ctxt, int inputchk)
{
  return xmlParseElementChildrenContentDeclPriv((uint64_t)ctxt, inputchk, 1);
}

xmlElementContentPtr xmlParseElementChildrenContentDeclPriv(uint64_t a1, int a2, int a3)
{
  if (a3 >= 129 && (a3 > 0x800 || (*(_DWORD *)(a1 + 564) & 0x80000) == 0))
  {
    xmlFatalErrMsgInt((_DWORD *)a1, 55, "xmlParseElementChildrenContentDecl : depth %d too deep, use XML_PARSE_HUGE\n", a3);
    return 0;
  }
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40) - *(void *)(*(void *)(a1 + 56) + 32)) <= 249)
  {
    xmlGROW(a1);
  }
  uint64_t v6 = *(void *)(a1 + 56);
  if (**(unsigned char **)(v6 + 32) != 40)
  {
    xmlElementContentPtr v9 = xmlParseName((xmlParserCtxtPtr)a1);
    if (!v9)
    {
      xmlFatalErr((_DWORD *)a1, 54, 0);
      return 0;
    }
    xmlElementContentPtr v8 = xmlNewDocElementContent(*(xmlDocPtr *)(a1 + 16), v9, XML_ELEMENT_CONTENT_ELEMENT);
    if (!v8)
    {
      htmlErrMemory((_DWORD *)a1, 0);
      return v8;
    }
    uint64_t v10 = *(void *)(a1 + 56);
    if (!*(_DWORD *)(a1 + 452) && (uint64_t)(*(void *)(v10 + 40) - *(void *)(v10 + 32)) <= 249)
    {
      xmlGROW(a1);
      uint64_t v10 = *(void *)(a1 + 56);
    }
    int v11 = **(unsigned __int8 **)(v10 + 32);
    switch(v11)
    {
      case '*':
        int v12 = 3;
        break;
      case '+':
        int v12 = 4;
        break;
      case '?':
        int v12 = 2;
        break;
      default:
        v8->ocur = XML_ELEMENT_CONTENT_ONCE;
        goto LABEL_28;
    }
    v8->ocur = v12;
    xmlNextChar((xmlParserCtxtPtr)a1);
LABEL_28:
    if (*(_DWORD *)(a1 + 452)
      || (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40) - *(void *)(*(void *)(a1 + 56) + 32)) > 249)
    {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v7 = *(unsigned int *)(v6 + 100);
  xmlNextChar((xmlParserCtxtPtr)a1);
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  xmlElementContentPtr v8 = (xmlElementContentPtr)xmlParseElementChildrenContentDeclPriv(a1, v7, (a3 + 1));
  if (!v8) {
    return v8;
  }
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  if (*(_DWORD *)(a1 + 452)
    || (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40) - *(void *)(*(void *)(a1 + 56) + 32)) >= 250)
  {
    goto LABEL_31;
  }
LABEL_30:
  xmlGROW(a1);
LABEL_31:
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  uint64_t v13 = *(void *)(a1 + 56);
  if (!*(_DWORD *)(a1 + 452))
  {
    uint64_t v14 = *(void *)(v13 + 32);
    if (v14 - *(void *)(v13 + 24) >= 501 && *(void *)(v13 + 40) - v14 <= 499)
    {
      xmlSHRINK(a1);
      uint64_t v13 = *(void *)(a1 + 56);
    }
  }
  int v15 = **(unsigned __int8 **)(v13 + 32);
  if (v15 == 41)
  {
    xmlElementContentPtr v16 = v8;
    goto LABEL_80;
  }
  if (*(_DWORD *)(a1 + 272) == -1)
  {
    int v17 = 0;
    xmlElementContentPtr v16 = v8;
LABEL_78:
    if (v17)
    {
LABEL_79:
      v16->c2 = v17;
      v17->xmlNodePtr parent = v16;
    }
LABEL_80:
    if (*(_DWORD *)(v13 + 100) != a2) {
      xmlFatalErrMsg((_DWORD *)a1, 90, (char)"Element content declaration doesn't start and stop in the same entity\n");
    }
    xmlNextChar((xmlParserCtxtPtr)a1);
    int v30 = **(unsigned __int8 **)(*(void *)(a1 + 56) + 32);
    switch(v30)
    {
      case '*':
        v8->ocur = XML_ELEMENT_CONTENT_MULT;
        if (v8->type == XML_ELEMENT_CONTENT_OR)
        {
          xmlElementContentPtr v32 = v8;
          do
          {
            c1 = v32->c1;
            if (c1 && (c1->ocur & 0xFFFFFFFE) == 2) {
              c1->ocur = XML_ELEMENT_CONTENT_ONCE;
            }
            xmlElementContentPtr v32 = v32->c2;
            if (!v32) {
              break;
            }
            if ((v32->ocur & 0xFFFFFFFE) == 2) {
              v32->ocur = XML_ELEMENT_CONTENT_ONCE;
            }
          }
          while (v32->type == XML_ELEMENT_CONTENT_OR);
        }
        goto LABEL_115;
      case '+':
        if ((v8->ocur & 0xFFFFFFFE) == 2) {
          int v34 = 3;
        }
        else {
          int v34 = 4;
        }
        v8->ocur = v34;
        if (v16->type == XML_ELEMENT_CONTENT_OR)
        {
          int v35 = 0;
          do
          {
            int v36 = v16->c1;
            if (v36 && (v36->ocur & 0xFFFFFFFE) == 2)
            {
              int v35 = 1;
              v36->ocur = XML_ELEMENT_CONTENT_ONCE;
            }
            xmlElementContentPtr v16 = v16->c2;
            if (!v16) {
              break;
            }
            if ((v16->ocur & 0xFFFFFFFE) == 2)
            {
              int v35 = 1;
              v16->ocur = XML_ELEMENT_CONTENT_ONCE;
            }
          }
          while (v16->type == XML_ELEMENT_CONTENT_OR);
        }
        else
        {
          int v35 = 0;
        }
        if (!v35) {
          goto LABEL_115;
        }
        int v31 = 3;
        break;
      case '?':
        if (v8->ocur - 3 >= 2) {
          int v31 = 2;
        }
        else {
          int v31 = 3;
        }
        break;
      default:
        return v8;
    }
    v8->ocur = v31;
LABEL_115:
    xmlNextChar((xmlParserCtxtPtr)a1);
    return v8;
  }
  int v17 = 0;
  int v18 = 0;
  uint64_t v19 = (a3 + 1);
  xmlElementContentPtr v16 = v8;
  xmlElementContentPtr v20 = v8;
  while (1)
  {
    if (v15 == 124)
    {
      if (v18 && v18 != 124)
      {
LABEL_120:
        xmlFatalErrMsgInt((_DWORD *)a1, 66, "xmlParseElementChildrenContentDecl : '%c' expected\n", v18);
        goto LABEL_121;
      }
      xmlNextChar((xmlParserCtxtPtr)a1);
      xmlElementContentPtr v21 = xmlNewDocElementContent(*(xmlDocPtr *)(a1 + 16), 0, XML_ELEMENT_CONTENT_OR);
      if (!v21) {
        goto LABEL_121;
      }
    }
    else
    {
      if (v15 != 44)
      {
        xmlFatalErr((_DWORD *)a1, 55, 0);
LABEL_121:
        if (v17 && v17 != v20) {
LABEL_123:
        }
          xmlFreeDocElementContent(*(xmlDocPtr *)(a1 + 16), v17);
LABEL_124:
        uint64_t v37 = *(xmlDoc **)(a1 + 16);
        size_t v38 = v20;
        goto LABEL_127;
      }
      if (v18 && v18 != 44) {
        goto LABEL_120;
      }
      xmlNextChar((xmlParserCtxtPtr)a1);
      xmlElementContentPtr v21 = xmlNewDocElementContent(*(xmlDocPtr *)(a1 + 16), 0, XML_ELEMENT_CONTENT_SEQ);
      if (!v21)
      {
        if (v17 && v17 != v20) {
          goto LABEL_123;
        }
        goto LABEL_124;
      }
    }
    xmlElementContentPtr v22 = v21;
    if (v17)
    {
      v16->c2 = v21;
      v21->xmlNodePtr parent = v16;
      xmlElementContentPtr v21 = v20;
      v22->c1 = v17;
    }
    else
    {
      v21->c1 = v20;
      int v17 = v20;
    }
    v17->xmlNodePtr parent = v22;
    xmlElementContentPtr v16 = v22;
    xmlElementContentPtr v8 = v21;
    if (!*(_DWORD *)(a1 + 452)
      && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40) - *(void *)(*(void *)(a1 + 56) + 32)) <= 249)
    {
      xmlGROW(a1);
    }
    xmlSkipBlankChars((xmlParserCtxtPtr)a1);
    uint64_t v23 = *(void *)(a1 + 56);
    if (!*(_DWORD *)(a1 + 452) && (uint64_t)(*(void *)(v23 + 40) - *(void *)(v23 + 32)) <= 249)
    {
      xmlGROW(a1);
      uint64_t v23 = *(void *)(a1 + 56);
    }
    if (**(unsigned char **)(v23 + 32) == 40)
    {
      uint64_t v24 = *(unsigned int *)(v23 + 100);
      xmlNextChar((xmlParserCtxtPtr)a1);
      xmlSkipBlankChars((xmlParserCtxtPtr)a1);
      uint64_t v25 = xmlParseElementChildrenContentDeclPriv(a1, v24, v19);
      if (!v25) {
        goto LABEL_126;
      }
      int v17 = (xmlElementContent *)v25;
      xmlSkipBlankChars((xmlParserCtxtPtr)a1);
      goto LABEL_71;
    }
    xmlParserInputPtr v26 = xmlParseName((xmlParserCtxtPtr)a1);
    if (!v26) {
      break;
    }
    xmlElementContentPtr v27 = xmlNewDocElementContent(*(xmlDocPtr *)(a1 + 16), v26, XML_ELEMENT_CONTENT_ELEMENT);
    if (!v27) {
      goto LABEL_126;
    }
    int v17 = v27;
    int v28 = **(unsigned __int8 **)(*(void *)(a1 + 56) + 32);
    if (v28 == 42)
    {
      v27->ocur = XML_ELEMENT_CONTENT_MULT;
    }
    else
    {
      if (v28 == 43)
      {
        int v29 = 4;
      }
      else
      {
        if (v28 != 63)
        {
          v27->ocur = XML_ELEMENT_CONTENT_ONCE;
          goto LABEL_71;
        }
        int v29 = 2;
      }
      v27->ocur = v29;
    }
    xmlNextChar((xmlParserCtxtPtr)a1);
LABEL_71:
    xmlSkipBlankChars((xmlParserCtxtPtr)a1);
    uint64_t v13 = *(void *)(a1 + 56);
    if (!*(_DWORD *)(a1 + 452) && (uint64_t)(*(void *)(v13 + 40) - *(void *)(v13 + 32)) <= 249)
    {
      xmlGROW(a1);
      uint64_t v13 = *(void *)(a1 + 56);
    }
    if (**(unsigned char **)(v13 + 32) == 41) {
      goto LABEL_79;
    }
    int v18 = v15;
    xmlElementContentPtr v20 = v8;
    int v15 = **(unsigned __int8 **)(v13 + 32);
    if (*(_DWORD *)(a1 + 272) == -1) {
      goto LABEL_78;
    }
  }
  xmlFatalErr((_DWORD *)a1, 54, 0);
LABEL_126:
  uint64_t v37 = *(xmlDoc **)(a1 + 16);
  size_t v38 = v8;
LABEL_127:
  xmlFreeDocElementContent(v37, v38);
  return 0;
}

int xmlParseElementContentDecl(xmlParserCtxtPtr ctxt, const xmlChar *name, xmlElementContentPtr *result)
{
  int id = ctxt->input->id;
  _DWORD *result = 0;
  if (*ctxt->input->cur != 40)
  {
    xmlFatalErrMsgStr(ctxt, 54, "xmlParseElementContentDecl : %s '(' expected\n", name);
    return -1;
  }
  xmlNextChar(ctxt);
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  if (ctxt->instate == XML_PARSER_EOF) {
    return -1;
  }
  xmlSkipBlankChars(ctxt);
  cur = ctxt->input->cur;
  if (*cur == 35 && cur[1] == 80 && cur[2] == 67 && cur[3] == 68 && cur[4] == 65 && cur[5] == 84 && cur[6] == 65)
  {
    uint64_t v7 = xmlParseElementMixedContentDecl(ctxt, id);
    int v8 = 3;
  }
  else
  {
    uint64_t v7 = xmlParseElementChildrenContentDeclPriv((uint64_t)ctxt, id, 1);
    int v8 = 4;
  }
  xmlSkipBlankChars(ctxt);
  _DWORD *result = v7;
  return v8;
}

int xmlParseElementDecl(xmlParserCtxtPtr ctxt)
{
  xmlElementContentPtr result = 0;
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur != 60
    || cur[1] != 33
    || cur[2] != 69
    || cur[3] != 76
    || cur[4] != 69
    || cur[5] != 77
    || cur[6] != 69
    || cur[7] != 78
    || cur[8] != 84)
  {
    goto LABEL_50;
  }
  int id = input->id;
  input->cur = cur + 9;
  input->col += 9;
  if (!cur[9]) {
    xmlParserInputGrow(input, 250);
  }
  if (!xmlSkipBlankChars(ctxt))
  {
    xmlElementContentPtr v16 = "Space required after 'ELEMENT'\n";
    xmlParserCtxtPtr v17 = ctxt;
    int v18 = 65;
LABEL_49:
    xmlFatalErrMsg(v17, v18, (char)v16);
LABEL_50:
    LODWORD(v10) = -1;
    return v10;
  }
  int v5 = xmlParseName(ctxt);
  if (!v5)
  {
    xmlElementContentPtr v16 = "xmlParseElementDecl: no name for Element\n";
    xmlParserCtxtPtr v17 = ctxt;
    int v18 = 68;
    goto LABEL_49;
  }
  uint64_t v6 = v5;
  if (!xmlSkipBlankChars(ctxt)) {
    xmlFatalErrMsg(ctxt, 65, (char)"Space required after the element name\n");
  }
  xmlParserInputPtr v7 = ctxt->input;
  int v8 = v7->cur;
  unsigned int v9 = *v8;
  if (v9 <= 0x40)
  {
    if (v9 != 37)
    {
      if (v9 == 40)
      {
        xmlElementContentPtr v20 = v6;
        uint64_t v10 = xmlParseElementContentDecl(ctxt, v6, &result);
        goto LABEL_20;
      }
      goto LABEL_48;
    }
    if (!ctxt->external && ctxt->inputNr == 1)
    {
      xmlElementContentPtr v16 = "PEReference: forbidden within markup decl in internal subset\n";
      xmlParserCtxtPtr v17 = ctxt;
      int v18 = 21;
      goto LABEL_49;
    }
LABEL_48:
    xmlElementContentPtr v16 = "xmlParseElementDecl: 'EMPTY', 'ANY' or '(' expected\n";
    xmlParserCtxtPtr v17 = ctxt;
    int v18 = 54;
    goto LABEL_49;
  }
  if (v9 == 65)
  {
    if (v8[1] != 78 || v8[2] != 89) {
      goto LABEL_48;
    }
    xmlElementContentPtr v20 = v6;
    v7->cur = v8 + 3;
    v7->col += 3;
    if (!v8[3]) {
      xmlParserInputGrow(v7, 250);
    }
    uint64_t v10 = 2;
  }
  else
  {
    if (v9 != 69 || v8[1] != 77 || v8[2] != 80 || v8[3] != 84 || v8[4] != 89) {
      goto LABEL_48;
    }
    xmlElementContentPtr v20 = v6;
    v7->cur = v8 + 5;
    v7->col += 5;
    if (!v8[5]) {
      xmlParserInputGrow(v7, 250);
    }
    uint64_t v10 = 1;
  }
LABEL_20:
  xmlSkipBlankChars(ctxt);
  xmlParserInputPtr v11 = ctxt->input;
  if (*v11->cur == 62)
  {
    if (id != v11->id) {
      xmlFatalErrMsg(ctxt, 90, (char)"Element declaration doesn't start and stop in the same entity\n");
    }
    xmlNextChar(ctxt);
    if (ctxt->sax)
    {
      if (!ctxt->disableSAX)
      {
        elementDeclSAXFunc elementDecl = ctxt->sax->elementDecl;
        if (elementDecl)
        {
          xmlElementContentPtr v13 = result;
          if (!result)
          {
            ((void (*)(void *, const xmlChar *, uint64_t, void))elementDecl)(ctxt->userData, v20, v10, 0);
            return v10;
          }
          result->xmlNodePtr parent = 0;
          ((void (*)(void *, const xmlChar *, uint64_t, xmlElementContentPtr))elementDecl)(ctxt->userData, v20, v10, v13);
          if (!v13->parent)
          {
            xmlDocPtr myDoc = ctxt->myDoc;
            int v15 = v13;
LABEL_55:
            xmlFreeDocElementContent(myDoc, v15);
            return v10;
          }
          return v10;
        }
      }
    }
  }
  else
  {
    xmlFatalErr(ctxt, 73, 0);
  }
  int v15 = result;
  if (result)
  {
    xmlDocPtr myDoc = ctxt->myDoc;
    goto LABEL_55;
  }
  return v10;
}

void xmlParseMarkupDecl(xmlParserCtxtPtr ctxt)
{
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  cur = ctxt->input->cur;
  if (*cur == 60)
  {
    int v3 = cur[1];
    if (v3 == 63)
    {
      xmlParsePI(ctxt);
    }
    else if (v3 == 33)
    {
      unsigned int v4 = cur[2];
      if (v4 > 0x44)
      {
        if (v4 == 78)
        {
          xmlParseNotationDecl(ctxt);
        }
        else if (v4 == 69)
        {
          int v5 = cur[3];
          if (v5 == 78)
          {
            xmlParseEntityDecl(ctxt);
          }
          else if (v5 == 76)
          {
            xmlParseElementDecl(ctxt);
          }
        }
      }
      else if (v4 == 45)
      {
        xmlParseComment(ctxt);
      }
      else if (v4 == 65)
      {
        xmlParseAttributeListDecl(ctxt);
      }
    }
  }
  if (ctxt->instate != XML_PARSER_EOF) {
    ctxt->xmlParserInputState instate = XML_PARSER_DTD;
  }
}

void xmlParseTextDecl(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur == 60 && cur[1] == 63 && cur[2] == 120 && cur[3] == 109 && cur[4] == 108)
  {
    unsigned int v5 = cur[5];
    unsigned int v4 = cur + 5;
    uint64_t v6 = (1 << v5) & 0x100002600;
    if (v5 <= 0x20 && v6 != 0)
    {
      input->cur = v4;
      input->col += 5;
      if (!*v4) {
        xmlParserInputGrow(input, 250);
      }
      xmlParserInputState instate = ctxt->instate;
      ctxt->xmlParserInputState instate = XML_PARSER_START;
      if (!xmlSkipBlankChars(ctxt)) {
        xmlFatalErrMsg(ctxt, 65, (char)"Space needed after '<?xml'\n");
      }
      unsigned int v9 = xmlParseVersionInfo(ctxt);
      if (v9)
      {
        uint64_t v10 = v9;
        if (!xmlSkipBlankChars(ctxt)) {
          xmlFatalErrMsg(ctxt, 65, (char)"Space needed here\n");
        }
      }
      else
      {
        uint64_t v10 = xmlCharStrdup("1.0");
      }
      ctxt->input->version = v10;
      xmlParserInputPtr v11 = xmlParseEncodingDecl(ctxt);
      int errNo = ctxt->errNo;
      if (errNo == 32) {
        goto LABEL_36;
      }
      if (!v11 && !errNo) {
        xmlFatalErrMsg(ctxt, 101, (char)"Missing encoding in text declaration\n");
      }
      xmlSkipBlankChars(ctxt);
      xmlParserInputPtr v13 = ctxt->input;
      uint64_t v14 = v13->cur;
      int v15 = *v14;
      if (v15 == 62)
      {
        xmlFatalErr(ctxt, 57, 0);
      }
      else
      {
        if (v15 == 63 && v14[1] == 62)
        {
          v13->cur = v14 + 2;
          v13->col += 2;
          if (!v14[2]) {
            xmlParserInputGrow(v13, 250);
          }
          goto LABEL_36;
        }
        xmlFatalErr(ctxt, 57, 0);
        xmlParserInputPtr v16 = ctxt->input;
        for (uint64_t i = v16->cur; *i++ && *(i - 1) != 62; v16->cur = i)
          ;
      }
      xmlNextChar(ctxt);
LABEL_36:
      ctxt->xmlParserInputState instate = instate;
      return;
    }
  }

  xmlFatalErr(ctxt, 56, 0);
}

void xmlParseExternalSubset(xmlParserCtxtPtr ctxt, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  xmlDetectSAX2((const xmlChar *)ctxt);
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  if (!ctxt->encoding)
  {
    cur = ctxt->input->cur;
    if (ctxt->input->end - cur >= 4)
    {
      *(_DWORD *)in = *(_DWORD *)cur;
      xmlCharEncoding v7 = xmlDetectCharEncoding(in, 4);
      if (v7) {
        xmlSwitchEncoding(ctxt, v7);
      }
    }
  }
  int v8 = ctxt->input->cur;
  if (*v8 == 60 && v8[1] == 63 && v8[2] == 120 && v8[3] == 109 && v8[4] == 108)
  {
    xmlParseTextDecl(ctxt);
    if (ctxt->errNo == 32)
    {
      xmlHaltParser(ctxt);
      return;
    }
  }
  xmlDocPtr myDoc = ctxt->myDoc;
  if (!myDoc)
  {
    xmlDocPtr myDoc = xmlNewDoc((const xmlChar *)"1.0");
    ctxt->xmlDocPtr myDoc = myDoc;
    if (!myDoc)
    {
      htmlErrMemory(ctxt, (const xmlChar *)"New Doc failed");
      return;
    }
    myDoc->int properties = 64;
  }
  if (!myDoc->intSubset) {
    xmlCreateIntSubset(myDoc, 0, ExternalID, SystemID);
  }
  ctxt->xmlParserInputState instate = XML_PARSER_DTD;
  ctxt->external = 1;
  xmlSkipBlankChars(ctxt);
  xmlParserInputPtr input = ctxt->input;
  xmlParserInputPtr v11 = input->cur;
  while (1)
  {
    int v12 = *v11;
    if (v12 != 37)
    {
      if (v12 != 60) {
        goto LABEL_38;
      }
      int v13 = v11[1];
      if (v13 != 63 && v13 != 33) {
        goto LABEL_39;
      }
    }
    uint64_t consumed_low = LODWORD(input->consumed);
    if (ctxt->progressive)
    {
      int v15 = v11;
    }
    else
    {
      uint64_t v16 = input->end - v11;
      int v15 = v11;
      if (v16 <= 249)
      {
        xmlGROW((uint64_t)ctxt);
        int v15 = ctxt->input->cur;
        int v12 = *v15;
      }
    }
    if (v12 == 60 && v15[1] == 33 && v15[2] == 91) {
      xmlParseConditionalSections((uint64_t)ctxt);
    }
    else {
      xmlParseMarkupDecl(ctxt);
    }
    xmlSkipBlankChars(ctxt);
    xmlParserInputPtr input = ctxt->input;
    BOOL v17 = input->cur == v11;
    xmlParserInputPtr v11 = input->cur;
    if (v17)
    {
      xmlParserInputPtr v11 = input->cur;
      if (consumed_low == input->consumed) {
        break;
      }
    }
  }
  xmlFatalErr(ctxt, 60, 0);
  int v12 = *ctxt->input->cur;
LABEL_38:
  if (!v12) {
    return;
  }
LABEL_39:
  xmlFatalErr(ctxt, 60, 0);
}

uint64_t xmlParseConditionalSections(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 272) == -1)
  {
    unint64_t v2 = 0;
    goto LABEL_84;
  }
  unint64_t v2 = 0;
  unint64_t v3 = 0;
  unint64_t v4 = 0;
  while (1)
  {
    uint64_t v5 = *(void *)(a1 + 56);
    uint64_t v6 = *(unsigned __int8 **)(v5 + 32);
    int v7 = *v6;
    if (v7 == 60) {
      break;
    }
    if (!v3 || v7 != 93 || v6[1] != 93 || v6[2] != 62) {
      goto LABEL_36;
    }
    if (*(_DWORD *)(v5 + 100) != v2[--v3])
    {
      xmlFatalErrMsg((_DWORD *)a1, 90, (char)"All markup of the conditional section is not in the same entity\n");
      uint64_t v5 = *(void *)(a1 + 56);
      uint64_t v6 = *(unsigned __int8 **)(v5 + 32);
    }
    *(void *)(v5 + 32) = v6 + 3;
    *(_DWORD *)(v5 + 56) += 3;
    if (!v6[3]) {
LABEL_78:
    }
      xmlParserInputGrow((xmlParserInputPtr)v5, 250);
LABEL_38:
    if (v3)
    {
      xmlSkipBlankChars((xmlParserCtxtPtr)a1);
      if (!*(_DWORD *)(a1 + 452)
        && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40) - *(void *)(*(void *)(a1 + 56) + 32)) <= 249)
      {
        xmlGROW(a1);
      }
      if (*(_DWORD *)(a1 + 272) != -1) {
        continue;
      }
    }
    goto LABEL_84;
  }
  if (v6[1] != 33 || v6[2] != 91)
  {
LABEL_36:
    uint64_t v14 = *(unsigned int *)(v5 + 64);
    xmlParseMarkupDecl((xmlParserCtxtPtr)a1);
    uint64_t v15 = *(void *)(a1 + 56);
    if (*(unsigned __int8 **)(v15 + 32) != v6 || v14 != *(void *)(v15 + 64)) {
      goto LABEL_38;
    }
    uint64_t v23 = (_DWORD *)a1;
    int v24 = 60;
    goto LABEL_83;
  }
  int v8 = *(_DWORD *)(v5 + 100);
  *(void *)(v5 + 32) = v6 + 3;
  *(_DWORD *)(v5 + 56) += 3;
  if (!v6[3]) {
    xmlParserInputGrow((xmlParserInputPtr)v5, 250);
  }
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  unsigned int v9 = *(xmlParserInput **)(a1 + 56);
  cur = v9->cur;
  if (*cur != 73) {
    goto LABEL_80;
  }
  int v11 = cur[1];
  if (v11 != 71)
  {
    if (v11 == 78 && cur[2] == 67 && cur[3] == 76 && cur[4] == 85 && cur[5] == 68 && cur[6] == 69)
    {
      v9->cur = cur + 7;
      v9->col += 7;
      if (!cur[7]) {
        xmlParserInputGrow(v9, 250);
      }
      xmlSkipBlankChars((xmlParserCtxtPtr)a1);
      uint64_t v12 = *(void *)(a1 + 56);
      if (**(unsigned char **)(v12 + 32) == 91)
      {
        if (*(_DWORD *)(v12 + 100) != v8) {
          xmlFatalErrMsg((_DWORD *)a1, 90, (char)"All markup of the conditional section is not in the same entity\n");
        }
        xmlNextChar((xmlParserCtxtPtr)a1);
        if (v4 <= v3)
        {
          if (v4) {
            v4 *= 2;
          }
          else {
            unint64_t v4 = 4;
          }
          int v13 = xmlRealloc(v2, 4 * v4);
          if (!v13)
          {
LABEL_87:
            htmlErrMemory((_DWORD *)a1, 0);
            goto LABEL_84;
          }
          unint64_t v2 = v13;
        }
        v2[v3++] = v8;
        goto LABEL_38;
      }
      goto LABEL_82;
    }
LABEL_80:
    uint64_t v23 = (_DWORD *)a1;
    int v24 = 95;
LABEL_83:
    xmlFatalErr(v23, v24, 0);
    xmlHaltParser((xmlParserCtxtPtr)a1);
    goto LABEL_84;
  }
  if (cur[2] != 78 || cur[3] != 79 || cur[4] != 82 || cur[5] != 69) {
    goto LABEL_80;
  }
  v9->cur = cur + 6;
  v9->col += 6;
  if (!cur[6]) {
    xmlParserInputGrow(v9, 250);
  }
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  uint64_t v16 = *(void *)(a1 + 56);
  if (**(unsigned char **)(v16 + 32) != 91)
  {
LABEL_82:
    uint64_t v23 = (_DWORD *)a1;
    int v24 = 83;
    goto LABEL_83;
  }
  if (*(_DWORD *)(v16 + 100) != v8) {
    xmlFatalErrMsg((_DWORD *)a1, 90, (char)"All markup of the conditional section is not in the same entity\n");
  }
  xmlNextChar((xmlParserCtxtPtr)a1);
  int v17 = *(_DWORD *)(a1 + 332);
  int v18 = *(_DWORD *)(a1 + 272);
  if (!*(_DWORD *)(a1 + 448)) {
    *(_DWORD *)(a1 + 332) = 1;
  }
  uint64_t v19 = 0;
  *(_DWORD *)(a1 + 272) = 15;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v5 = *(void *)(a1 + 56);
        xmlElementContentPtr v20 = *(unsigned __int8 **)(v5 + 32);
        int v21 = *v20;
        if (v21 != 60) {
          break;
        }
        if (v20[1] != 33 || v20[2] != 91) {
          goto LABEL_69;
        }
        *(void *)(v5 + 32) = v20 + 3;
        *(_DWORD *)(v5 + 56) += 3;
        if (!v20[3]) {
          xmlParserInputGrow((xmlParserInputPtr)v5, 250);
        }
        if (__CFADD__(v19++, 1)) {
          goto LABEL_87;
        }
      }
      if (v21 == 93) {
        break;
      }
      if (!*v20) {
        goto LABEL_74;
      }
LABEL_69:
      xmlNextChar((xmlParserCtxtPtr)a1);
    }
    if (v20[1] != 93 || v20[2] != 62) {
      goto LABEL_69;
    }
    if (!v19) {
      break;
    }
    *(void *)(v5 + 32) = v20 + 3;
    *(_DWORD *)(v5 + 56) += 3;
    if (!v20[3]) {
      xmlParserInputGrow((xmlParserInputPtr)v5, 250);
    }
    --v19;
  }
LABEL_74:
  *(_DWORD *)(a1 + 332) = v17;
  *(_DWORD *)(a1 + 272) = v18;
  if (*v20)
  {
    if (*(_DWORD *)(v5 + 100) != v8)
    {
      xmlFatalErrMsg((_DWORD *)a1, 90, (char)"All markup of the conditional section is not in the same entity\n");
      uint64_t v5 = *(void *)(a1 + 56);
      xmlElementContentPtr v20 = *(unsigned __int8 **)(v5 + 32);
    }
    *(void *)(v5 + 32) = v20 + 3;
    *(_DWORD *)(v5 + 56) += 3;
    if (!v20[3]) {
      goto LABEL_78;
    }
    goto LABEL_38;
  }
  xmlFatalErr((_DWORD *)a1, 59, 0);
LABEL_84:
  xmlFreeFunc v25 = xmlFree;

  return ((uint64_t (*)(_DWORD *))v25)(v2);
}

void xmlParseReference(xmlParserCtxtPtr ctxt)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  xmlNodePtr cur = 0;
  int v1 = ctxt->input->cur;
  if (*v1 != 38) {
    return;
  }
  if (v1[1] != 35)
  {
    xmlEntityPtr v9 = xmlParseEntityRef(ctxt);
    if (!v9 || !ctxt->wellFormed) {
      return;
    }
    uint64_t v10 = (uint64_t)v9;
    if (!v9->name || (exmlElementType type = v9->etype, etype == XML_INTERNAL_PREDEFINED_ENTITY))
    {
      content = v9->content;
      if (content && ctxt->sax && ctxt->sax->characters && !ctxt->disableSAX)
      {
        charactersSAXFunc characters = ctxt->sax->characters;
        userData = ctxt->userData;
        uint64_t v14 = xmlStrlen(content);
        ((void (*)(void *, const xmlChar *, uint64_t))characters)(userData, content, v14);
      }
      return;
    }
    int checked = v9->checked;
    if (!checked || !v9->children && (ctxt->options & 2) != 0)
    {
      if (etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY)
      {
        p_unint64_t nbentities = &ctxt->nbentities;
        unint64_t nbentities = ctxt->nbentities;
        if (etype != XML_INTERNAL_GENERAL_ENTITY)
        {
          xmlErrMsgStr(ctxt, 1, "invalid entity type found\n", 0);
          int v31 = 88;
LABEL_78:
          unint64_t v35 = *p_nbentities - nbentities;
          if (v35 + 1 < 0x3FFFFFFF) {
            int v36 = v35 + 1;
          }
          else {
            int v36 = 0x3FFFFFFF;
          }
          *(_DWORD *)(v10 + 132) = 2 * v36;
          uint64_t v37 = *(const xmlChar **)(v10 + 80);
          if (v37 && xmlStrchr(v37, 0x3Cu)) {
            *(_DWORD *)(v10 + 132) |= 1u;
          }
          if (v31 == 111 || v31 == 89)
          {
            xmlFatalErr(ctxt, v31, 0);
            xmlHaltParser(ctxt);
LABEL_88:
            xmlFreeNodeList(cur);
            return;
          }
          if (xmlParserEntityCheck((uint64_t)ctxt, 0, v10, 0)) {
            goto LABEL_88;
          }
          xmlNodePtr v43 = cur;
          if (v31 || !cur)
          {
            if (v31 && v31 != 27)
            {
              xmlFatalErrMsgStr(ctxt, 26, "Entity '%s' failed to parse\n", *(const xmlChar **)(v10 + 16));
              int v59 = *(unsigned char **)(v10 + 80);
              if (v59) {
                unsigned char *v59 = 0;
              }
              xmlParserEntityCheck((uint64_t)ctxt, 0, v10, 0);
LABEL_137:
              if (!*(_DWORD *)(v10 + 132)) {
                *(_DWORD *)(v10 + 132) = 2;
              }
              p_xmlNodePtr children = (xmlNode **)(v10 + 24);
              if (!*(void *)(v10 + 24)) {
                goto LABEL_140;
              }
              goto LABEL_49;
            }
            if (!cur) {
              goto LABEL_137;
            }
          }
          else
          {
            int v44 = *(_DWORD *)(v10 + 92);
            if ((v44 - 1) <= 1 && !*(void *)(v10 + 24))
            {
              *(void *)(v10 + 24) = cur;
              if (ctxt->replaceEntities
                && ctxt->parseMode != XML_PARSE_READER
                && (v43->type != XML_TEXT_NODE || v43->next))
              {
                *(_DWORD *)(v10 + 128) = 0;
                xmlNodePtr node = ctxt->node;
                xmlDocPtr myDoc = ctxt->myDoc;
                p_private = &v43->_private;
                do
                {
                  uint64_t v63 = p_private;
                  p_private[5] = node;
                  p_private[8] = myDoc;
                  p_private = (void *)p_private[6];
                }
                while (p_private);
                *(void *)(v10 + 32) = v63;
                if (v44 == 2 && xmlEntityRefFunc) {
                  xmlEntityRefFunc(v10, v43, 0);
                }
                goto LABEL_137;
              }
              *(_DWORD *)(v10 + 128) = 1;
              v43->xmlNodePtr parent = (_xmlNode *)v10;
              int v45 = *(xmlDoc **)(v10 + 64);
              xmlNodePtr next = v43;
              while (1)
              {
                xmlSetTreeDoc(next, v45);
                xmlNodePtr next = cur->next;
                if (!next) {
                  break;
                }
                xmlNodePtr cur = cur->next;
                next->xmlNodePtr parent = (_xmlNode *)v10;
                int v45 = *(xmlDoc **)(v10 + 64);
              }
              *(void *)(v10 + 32) = cur;
LABEL_136:
              xmlNodePtr cur = 0;
              goto LABEL_137;
            }
          }
          xmlFreeNodeList(cur);
          goto LABEL_136;
        }
        if (ctxt->userData == ctxt) {
          int v30 = 0;
        }
        else {
          int v30 = (xmlParserCtxt *)ctxt->userData;
        }
        ++ctxt->depth;
        int v24 = xmlParseBalancedChunkMemoryInternal((uint64_t)ctxt, v9->content, v30, &cur);
LABEL_69:
        int v31 = v24;
        --ctxt->depth;
        goto LABEL_78;
      }
      if ((ctxt->options & 0x12) != 0)
      {
        p_unint64_t nbentities = &ctxt->nbentities;
        unint64_t nbentities = ctxt->nbentities;
        sax = ctxt->sax;
        if (ctxt->userData == ctxt) {
          xmlElementContentPtr v22 = 0;
        }
        else {
          xmlElementContentPtr v22 = ctxt->userData;
        }
        int v23 = ctxt->depth + 1;
        ctxt->int depth = v23;
        int v24 = xmlParseExternalEntityPrivate((uint64_t)ctxt->myDoc, (uint64_t)ctxt, sax, v22, v23, v9->URI, (const char *)v9->ExternalID, &cur);
        goto LABEL_69;
      }
    }
    if (checked != 1)
    {
      if (checked >= 0) {
        int v25 = v9->checked;
      }
      else {
        int v25 = checked + 1;
      }
      ctxt->nbentities += v25 >> 1;
    }
    p_xmlNodePtr children = &v9->children;
    if (!v9->children)
    {
      if (checked)
      {
        if (ctxt->userData == ctxt) {
          xmlElementContentPtr v32 = 0;
        }
        else {
          xmlElementContentPtr v32 = (xmlParserCtxt *)ctxt->userData;
        }
        if (etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
        {
          p_int depth = &ctxt->depth;
          int v47 = ctxt->depth + 1;
          ctxt->int depth = v47;
          int v34 = xmlParseExternalEntityPrivate((uint64_t)ctxt->myDoc, (uint64_t)ctxt, ctxt->sax, v32, v47, v9->URI, (const char *)v9->ExternalID, 0);
        }
        else
        {
          if (etype != XML_INTERNAL_GENERAL_ENTITY)
          {
            xmlErrMsgStr(ctxt, 1, "invalid entity type found\n", 0);
            goto LABEL_140;
          }
          p_int depth = &ctxt->depth;
          ++ctxt->depth;
          int v34 = xmlParseBalancedChunkMemoryInternal((uint64_t)ctxt, v9->content, v32, 0);
        }
        --*p_depth;
        if (v34 == 89)
        {
          xmlFatalErr(ctxt, 89, 0);
          return;
        }
      }
LABEL_140:
      if (!ctxt->sax) {
        return;
      }
      referenceSAXFunc reference = ctxt->sax->reference;
      if (!reference || ctxt->replaceEntities || ctxt->disableSAX) {
        return;
      }
      goto LABEL_144;
    }
LABEL_49:
    if (ctxt->sax)
    {
      referenceSAXFunc reference = ctxt->sax->reference;
      if (reference)
      {
        if (!ctxt->replaceEntities && !ctxt->disableSAX)
        {
LABEL_144:
          uint64_t v16 = ctxt->userData;
          int v17 = *(xmlChar **)(v10 + 16);
          goto LABEL_33;
        }
      }
    }
    if (!ctxt->replaceEntities || !ctxt->node) {
      return;
    }
    if (cur)
    {
      if (ctxt->parseMode != XML_PARSE_READER)
      {
        if (ctxt->inputNr < 1)
        {
          xmlElementContentPtr v27 = xmlDictLookup(ctxt->dict, (const xmlChar *)"nbktext", -1);
          int v28 = *p_children;
          if ((*p_children)->type == XML_TEXT_NODE) {
            v28->name = v27;
          }
          uint64_t v29 = *(void *)(v10 + 32);
          if ((xmlNode *)v29 != v28 && *(_DWORD *)(v29 + 8) == 3) {
            *(void *)(v29 + 16) = v27;
          }
          xmlAddChildList(ctxt->node, v28);
          goto LABEL_166;
        }
LABEL_120:
        unint64_t v48 = *(int *)(v10 + 88) + ctxt->sizeentcopy + 5;
        ctxt->sizeentcopy = v48;
        if (xmlParserEntityCheck((uint64_t)ctxt, 0, v10, v48)) {
          return;
        }
        int v49 = *(xmlNode **)(v10 + 24);
        int v50 = *(xmlNode **)(v10 + 32);
        *(void *)(v10 + 24) = 0;
        *(void *)(v10 + 32) = 0;
        if (v49)
        {
          int v51 = 0;
          do
          {
            int v52 = v49->next;
            v49->xmlNodePtr parent = 0;
            v49->xmlNodePtr next = 0;
            xmlNodePtr v53 = xmlDocCopyNode(v49, ctxt->myDoc, 1);
            int v54 = v53;
            if (v53)
            {
              if (!v53->_private) {
                v53->_private = v49->_private;
              }
              if (!v51) {
                int v51 = v49;
              }
              xmlAddChild((xmlNodePtr)v10, v53);
              xmlAddChild(ctxt->node, v49);
            }
            if (v49 == v50) {
              break;
            }
            int v49 = v52;
          }
          while (v52);
        }
        else
        {
          int v54 = 0;
          int v51 = 0;
        }
        if (!*(_DWORD *)(v10 + 128)) {
          *(_DWORD *)(v10 + 128) = 1;
        }
        if (*(_DWORD *)(v10 + 92) == 2)
        {
          int v56 = (void (*)(uint64_t, xmlNode *, xmlNodePtr))xmlEntityRefFunc;
          if (xmlEntityRefFunc)
          {
            uint64_t v57 = v10;
            unsigned int v58 = v51;
            xmlNodePtr v42 = v54;
            goto LABEL_165;
          }
        }
        goto LABEL_166;
      }
    }
    else if (*(_DWORD *)(v10 + 128) && ctxt->parseMode != XML_PARSE_READER)
    {
      goto LABEL_120;
    }
    unint64_t v38 = *(int *)(v10 + 88) + ctxt->sizeentcopy + 5;
    ctxt->sizeentcopy = v38;
    if (xmlParserEntityCheck((uint64_t)ctxt, 0, v10, v38)) {
      return;
    }
    int v39 = *p_children;
    if (*p_children)
    {
      xmlNodePtr v40 = 0;
      while (1)
      {
        xmlNodePtr v41 = xmlDocCopyNode(v39, ctxt->myDoc, 1);
        if (v41)
        {
          if (!v41->_private) {
            v41->_private = v39->_private;
          }
          if (!v40) {
            xmlNodePtr v40 = v41;
          }
          xmlNodePtr v42 = xmlAddChild(ctxt->node, v41);
        }
        else
        {
          xmlNodePtr v42 = 0;
        }
        if (v39 == *(xmlNode **)(v10 + 32)) {
          break;
        }
        int v39 = v39->next;
        if (!v39) {
          goto LABEL_153;
        }
      }
      BOOL v55 = ctxt->parseMode != XML_PARSE_READER || v42 == 0;
      if (!v55 && v42->type == XML_ELEMENT_NODE && !v42->children) {
        v42->extra = 1;
      }
    }
    else
    {
      xmlNodePtr v42 = 0;
      xmlNodePtr v40 = 0;
    }
LABEL_153:
    if (*(_DWORD *)(v10 + 92) == 2)
    {
      int v56 = (void (*)(uint64_t, xmlNode *, xmlNodePtr))xmlEntityRefFunc;
      if (xmlEntityRefFunc)
      {
        uint64_t v57 = v10;
        unsigned int v58 = v40;
LABEL_165:
        v56(v57, v58, v42);
      }
    }
LABEL_166:
    *(void *)&ctxt->nodeint len = 0;
    return;
  }
  *(void *)out = 0;
  uint64_t v67 = 0;
  int v3 = v1[2];
  int v4 = xmlParseCharRef(ctxt);
  if (!v4) {
    return;
  }
  if (ctxt->charset == 1)
  {
    uint64_t v5 = xmlCopyCharMultiByte(out, v4);
    out[(int)v5] = 0;
    if (ctxt->sax)
    {
      charactersSAXFunc v6 = ctxt->sax->characters;
      if (v6)
      {
        if (!ctxt->disableSAX)
        {
          uint64_t v7 = v5;
          int v8 = ctxt->userData;
LABEL_25:
          ((void (*)(void *, xmlChar *, uint64_t))v6)(v8, out, v7);
          return;
        }
      }
    }
    return;
  }
  if (v4 > 255)
  {
    if ((v3 & 0xFFFFFFDF) == 0x58) {
      snprintf((char *)out, 0x10uLL, "#x%X");
    }
    else {
      snprintf((char *)out, 0x10uLL, "#%d");
    }
    if (!ctxt->sax) {
      return;
    }
    referenceSAXFunc reference = ctxt->sax->reference;
    if (!reference || ctxt->disableSAX) {
      return;
    }
    uint64_t v16 = ctxt->userData;
    int v17 = out;
LABEL_33:
    ((void (*)(void *, xmlChar *))reference)(v16, v17);
    return;
  }
  out[0] = v4;
  out[1] = 0;
  if (ctxt->sax)
  {
    charactersSAXFunc v6 = ctxt->sax->characters;
    if (v6)
    {
      if (!ctxt->disableSAX)
      {
        int v8 = ctxt->userData;
        uint64_t v7 = 1;
        goto LABEL_25;
      }
    }
  }
}

xmlEntityPtr xmlParseEntityRef(xmlParserCtxtPtr ctxt)
{
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  if (ctxt->instate == XML_PARSER_EOF || *ctxt->input->cur != 38) {
    return 0;
  }
  xmlNextChar(ctxt);
  unint64_t v2 = xmlParseName(ctxt);
  if (!v2)
  {
    xmlFatalErrMsg(ctxt, 68, (char)"xmlParseEntityRef: no name\n");
    return 0;
  }
  if (*ctxt->input->cur != 59)
  {
    xmlFatalErr(ctxt, 23, 0);
    return 0;
  }
  int v3 = v2;
  xmlNextChar(ctxt);
  if ((ctxt->options & 0x100000) == 0)
  {
    xmlEntityPtr PredefinedEntity = xmlGetPredefinedEntity(v3);
    if (PredefinedEntity) {
      return PredefinedEntity;
    }
  }
  ++ctxt->nbentities;
  if (!ctxt->sax) {
    goto LABEL_24;
  }
  getxmlEntityPtr Entity = ctxt->sax->getEntity;
  if (getEntity) {
    xmlEntityPtr PredefinedEntity = (xmlEntityPtr)((uint64_t (*)(void *, const xmlChar *))getEntity)(ctxt->userData, v3);
  }
  else {
    xmlEntityPtr PredefinedEntity = 0;
  }
  int wellFormed = ctxt->wellFormed;
  if (wellFormed == 1 && !PredefinedEntity)
  {
    if ((ctxt->options & 0x100000) != 0)
    {
      xmlEntityPtr PredefinedEntity = xmlGetPredefinedEntity(v3);
      int wellFormed = ctxt->wellFormed;
    }
    else
    {
      xmlEntityPtr PredefinedEntity = 0;
      int wellFormed = 1;
    }
  }
  if (wellFormed == 1 && !PredefinedEntity)
  {
    if (ctxt->userData != ctxt)
    {
LABEL_24:
      xmlEntityPtr PredefinedEntity = 0;
      goto LABEL_25;
    }
    xmlEntityPtr PredefinedEntity = xmlSAX2GetEntity(ctxt, v3);
  }
LABEL_25:
  xmlParserInputState instate = ctxt->instate;
  if (instate == XML_PARSER_EOF) {
    return 0;
  }
  if (PredefinedEntity)
  {
    exmlElementType type = PredefinedEntity->etype;
    if (etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY)
    {
      xmlEntityPtr v9 = "Entity reference to unparsed entity %s\n";
      xmlParserCtxtPtr v10 = ctxt;
      int v11 = 28;
LABEL_36:
      xmlFatalErrMsgStr(v10, v11, v9, v3);
      return PredefinedEntity;
    }
    if (instate == XML_PARSER_ATTRIBUTE_VALUE && etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
    {
      xmlEntityPtr v9 = "Attribute references external entity '%s'\n";
      xmlParserCtxtPtr v10 = ctxt;
      int v11 = 29;
      goto LABEL_36;
    }
    if (instate != XML_PARSER_ATTRIBUTE_VALUE)
    {
      if ((etype & 0xFFFFFFFE) != 4) {
        return PredefinedEntity;
      }
      xmlEntityPtr v9 = "Attempt to reference the parameter entity '%s'\n";
      xmlParserCtxtPtr v10 = ctxt;
      int v11 = 30;
      goto LABEL_36;
    }
    if (etype != XML_INTERNAL_PREDEFINED_ENTITY)
    {
      int checked = PredefinedEntity->checked;
      if (!checked || (checked & 1) != 0)
      {
        content = PredefinedEntity->content;
        if (content)
        {
          if (xmlStrchr(content, 0x3Cu))
          {
            xmlEntityPtr v9 = "'<' in entity '%s' is not allowed in attributes values\n";
            xmlParserCtxtPtr v10 = ctxt;
            int v11 = 38;
            goto LABEL_36;
          }
        }
      }
    }
  }
  else
  {
    if (ctxt->standalone != 1 && (ctxt->hasExternalSubset || ctxt->hasPErefs))
    {
      xmlErrMsgStr(ctxt, 27, "Entity '%s' not defined\n", v3);
      if (!ctxt->inSubset)
      {
        if (ctxt->sax)
        {
          referenceSAXFunc reference = ctxt->sax->reference;
          if (reference) {
            ((void (*)(void *, const xmlChar *))reference)(ctxt->userData, v3);
          }
        }
      }
    }
    else
    {
      xmlFatalErrMsgStr(ctxt, 26, "Entity '%s' not defined\n", v3);
    }
    xmlParserEntityCheck((uint64_t)ctxt, 0, 0, 0);
    xmlEntityPtr PredefinedEntity = 0;
    ctxt->valint id = 0;
  }
  return PredefinedEntity;
}

uint64_t xmlParseBalancedChunkMemoryInternal(uint64_t a1, xmlChar *str, xmlParserCtxt *a3, void *a4)
{
  uint64_t v4 = (uint64_t)a4;
  int v8 = *(_DWORD *)(a1 + 392);
  if (v8 >= 41 && (v8 > 0x400 || (*(_DWORD *)(a1 + 564) & 0x80000) == 0)) {
    return 89;
  }
  if (a4) {
    *a4 = 0;
  }
  if (!str) {
    return 1;
  }
  int v10 = xmlStrlen(str);
  xmlParserCtxtPtr MemoryParserCtxt = xmlCreateMemoryParserCtxt((const char *)str, v10);
  if (!MemoryParserCtxt) {
    return 27;
  }
  uint64_t v12 = (uint64_t)MemoryParserCtxt;
  if (a3) {
    xmlParserCtxtPtr v13 = a3;
  }
  else {
    xmlParserCtxtPtr v13 = MemoryParserCtxt;
  }
  MemoryParserCtxt->userData = v13;
  dict = MemoryParserCtxt->dict;
  if (dict) {
    xmlDictFree(dict);
  }
  uint64_t v15 = *(xmlDict **)(a1 + 456);
  *(void *)(v12 + 456) = v15;
  *(_DWORD *)(v12 + 736) = *(_DWORD *)(a1 + 736) + 1;
  *(void *)(v12 + 480) = xmlDictLookup(v15, (const xmlChar *)"xml", 3);
  *(void *)(v12 + 488) = xmlDictLookup(*(xmlDictPtr *)(v12 + 456), (const xmlChar *)"xmlns", 5);
  *(void *)(v12 + 496) = xmlDictLookup(*(xmlDictPtr *)(v12 + 456), (const xmlChar *)"http://www.w3.org/XML/1998/namespace", 36);
  if (*(int *)(a1 + 508) >= 1)
  {
    uint64_t v16 = 0;
    do
    {
      nsPush(v12, *(void *)(*(void *)(a1 + 520) + 8 * v16), *(void *)(*(void *)(a1 + 520) + 8 * v16 + 8));
      v16 += 2;
    }
    while (*(_DWORD *)(a1 + 508) > (int)v16);
  }
  uint64_t v17 = *(void *)v12;
  *(void *)uint64_t v12 = *(void *)a1;
  xmlDetectSAX2((const xmlChar *)v12);
  *(_DWORD *)(v12 + 28) = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(v12 + 564) = *(_DWORD *)(a1 + 564);
  *(void *)(v12 + 424) = *(void *)(a1 + 424);
  xmlDocPtr v18 = *(xmlDocPtr *)(a1 + 16);
  if (v18)
  {
    uint64_t v19 = 0;
    *(void *)(v12 + 16) = v18;
    long long v34 = *(_OWORD *)&v18->children;
    goto LABEL_25;
  }
  xmlDocPtr v20 = xmlNewDoc((const xmlChar *)"1.0");
  if (!v20)
  {
    *(void *)uint64_t v12 = v17;
    *(void *)(v12 + 456) = 0;
    xmlFreeParserCtxt((xmlParserCtxtPtr)v12);
    return 1;
  }
  xmlDocPtr v18 = v20;
  v20->int properties = 64;
  int v21 = *(xmlDict **)(v12 + 456);
  v18->dict = v21;
  xmlDictReference(v21);
  *(void *)(v12 + 16) = v18;
  long long v34 = 0u;
  uint64_t v19 = v18;
LABEL_25:
  xmlNodePtr v22 = xmlNewDocNode(v18, 0, (const xmlChar *)"pseudoroot", 0);
  if (!v22)
  {
    *(void *)uint64_t v12 = v17;
    *(void *)(v12 + 456) = 0;
    xmlFreeParserCtxt((xmlParserCtxtPtr)v12);
    if (v19) {
      xmlFreeDoc(v19);
    }
    return 1;
  }
  int v23 = v22;
  int v24 = *(xmlNode **)(v12 + 16);
  v24->xmlNodePtr children = 0;
  v24->last = 0;
  xmlAddChild(v24, v23);
  nodePush((xmlParserCtxtPtr)v12, *(xmlNodePtr *)(*(void *)(v12 + 16) + 24));
  *(_DWORD *)(v12 + 272) = 7;
  *(_DWORD *)(v12 + 392) = *(_DWORD *)(a1 + 392) + 1;
  *(_DWORD *)(v12 + 156) = 0;
  int v25 = *(_DWORD *)(a1 + 432);
  *(_DWORD *)(v12 + 432) = v25;
  if (*(_DWORD *)(a1 + 156) || *(_DWORD *)(a1 + 28)) {
    *(_DWORD *)(v12 + 432) = v25 | 8;
  }
  *(_DWORD *)(v12 + 568) = *(_DWORD *)(a1 + 568);
  *(_OWORD *)(v12 + 544) = *(_OWORD *)(a1 + 544);
  xmlParseContent((xmlParserCtxtPtr)v12);
  xmlParserInputPtr v26 = *(unsigned char **)(*(void *)(v12 + 56) + 32);
  if (*v26)
  {
    if (*v26 == 60 && v26[1] == 47) {
      int v27 = 85;
    }
    else {
      int v27 = 86;
    }
    xmlFatalErr((_DWORD *)v12, v27, 0);
  }
  if (*(void *)(v12 + 80) != *(void *)(*(void *)(v12 + 16) + 24)) {
    xmlFatalErr((_DWORD *)v12, 85, 0);
  }
  if (*(_DWORD *)(v12 + 24))
  {
    uint64_t v28 = *(void *)(v12 + 16);
    if (v4)
    {
      uint64_t v29 = *(void *)(*(void *)(v28 + 24) + 24);
      for (*(void *)v4 = v29; v29; uint64_t v29 = *(void *)(v29 + 48))
      {
        if (*(_DWORD *)(a1 + 156))
        {
          if (*(_DWORD *)(a1 + 24))
          {
            int v30 = *(xmlDoc **)(a1 + 16);
            if (v30)
            {
              if (v30->intSubset && *(_DWORD *)(v29 + 8) == 1) {
                *(_DWORD *)(a1 + 152) &= xmlValidateElement((xmlValidCtxtPtr)(a1 + 160), v30, (xmlNodePtr)v29);
              }
            }
          }
        }
        *(void *)(v29 + 40) = 0;
      }
      uint64_t v4 = 0;
      int v31 = *(xmlNode **)(*(void *)(v12 + 16) + 24);
      v31->xmlNodePtr children = 0;
      goto LABEL_56;
    }
  }
  else
  {
    unsigned int v32 = *(_DWORD *)(v12 + 136);
    if (v32 <= 1) {
      uint64_t v4 = 1;
    }
    else {
      uint64_t v4 = v32;
    }
    uint64_t v28 = *(void *)(v12 + 16);
  }
  if (v28)
  {
    int v31 = *(xmlNode **)(v28 + 24);
LABEL_56:
    xmlFreeNode(v31);
    *(_OWORD *)(*(void *)(v12 + 16) + 24) = v34;
  }
  *(void *)(a1 + 696) += *(void *)(v12 + 696);
  if (*(_DWORD *)(v12 + 604)) {
    xmlCopyError((xmlErrorPtr)(v12 + 600), (xmlErrorPtr)(a1 + 600));
  }
  *(void *)uint64_t v12 = v17;
  *(void *)(v12 + 456) = 0;
  *(void *)(v12 + 544) = 0;
  *(void *)(v12 + 552) = 0;
  xmlFreeParserCtxt((xmlParserCtxtPtr)v12);
  if (v19) {
    xmlFreeDoc(v19);
  }
  return v4;
}

uint64_t xmlParseExternalEntityPrivate(uint64_t a1, uint64_t a2, _xmlSAXHandler *a3, void *a4, int a5, const xmlChar *a6, const char *a7, _xmlNode **a8)
{
  if (a5 < 41 || (uint64_t v14 = 89, a2) && a5 <= 0x400 && (*(_DWORD *)(a2 + 564) & 0x80000) != 0)
  {
    if (a8) {
      *a8 = 0;
    }
    uint64_t v14 = 1;
    if (a1)
    {
      if ((unint64_t)a6 | (unint64_t)a7)
      {
        EntityParserCtxtInternal = xmlCreateEntityParserCtxtInternal(a6, a7, 0, a2);
        if (EntityParserCtxtInternal)
        {
          uint64_t v16 = (uint64_t)EntityParserCtxtInternal;
          EntityParserCtxtInternal->userData = EntityParserCtxtInternal;
          if (a3)
          {
            sax = EntityParserCtxtInternal->sax;
            EntityParserCtxtInternal->sax = a3;
            if (a4) {
              EntityParserCtxtInternal->userData = a4;
            }
          }
          else
          {
            sax = 0;
          }
          xmlDetectSAX2((const xmlChar *)EntityParserCtxtInternal);
          xmlDocPtr v18 = xmlNewDoc((const xmlChar *)"1.0");
          if (v18)
          {
            uint64_t v19 = v18;
            *(_OWORD *)&v18->intSubset = *(_OWORD *)(a1 + 80);
            p_intSubset = &v18->intSubset;
            v18->int properties = 64;
            int v21 = *(xmlDict **)(a1 + 152);
            if (v21)
            {
              v19->dict = v21;
              xmlDictReference(v21);
            }
            xmlNodePtr v22 = *(const xmlChar **)(a1 + 136);
            if (v22) {
              v19->URL = xmlStrdup(v22);
            }
            int v23 = xmlNewDocNode(v19, 0, (const xmlChar *)"pseudoroot", 0);
            if (!v23)
            {
              if (a3) {
                *(void *)uint64_t v16 = sax;
              }
              goto LABEL_77;
            }
            int v24 = v23;
            xmlAddChild((xmlNodePtr)v19, v23);
            nodePush((xmlParserCtxtPtr)v16, v19->children);
            *(void *)(v16 + 16) = a1;
            v24->xmlDocPtr doc = (_xmlDoc *)a1;
            if (!*(_DWORD *)(v16 + 452)
              && (uint64_t)(*(void *)(*(void *)(v16 + 56) + 40) - *(void *)(*(void *)(v16 + 56) + 32)) <= 249)
            {
              xmlGROW(v16);
            }
            *(_DWORD *)in = 0;
            int v25 = *(_DWORD **)(*(void *)(v16 + 56) + 32);
            if ((uint64_t)(*(void *)(*(void *)(v16 + 56) + 40) - (void)v25) >= 4)
            {
              *(_DWORD *)in = *v25;
              xmlCharEncoding v26 = xmlDetectCharEncoding(in, 4);
              if (v26) {
                xmlSwitchEncoding((xmlParserCtxtPtr)v16, v26);
              }
            }
            int v27 = *(unsigned char **)(*(void *)(v16 + 56) + 32);
            if (*v27 == 60
              && v27[1] == 63
              && v27[2] == 120
              && v27[3] == 109
              && v27[4] == 108
              && (unsigned int v28 = v27[5], v28 <= 0x20)
              && ((1 << v28) & 0x100002600) != 0)
            {
              xmlParseTextDecl((xmlParserCtxtPtr)v16);
              if (xmlStrEqual(*(const xmlChar **)(a2 + 32), (const xmlChar *)"1.0")
                && !xmlStrEqual(*(const xmlChar **)(*(void *)(v16 + 56) + 88), (const xmlChar *)"1.0"))
              {
                xmlFatalErrMsg((_DWORD *)v16, 109, (char)"Version mismatch between document and entity\n");
              }
              *(_DWORD *)(v16 + 272) = 7;
              *(_DWORD *)(v16 + 392) = a5;
            }
            else
            {
              *(_DWORD *)(v16 + 272) = 7;
              *(_DWORD *)(v16 + 392) = a5;
              if (!a2)
              {
                int v31 = 0;
                *(void *)(v16 + 424) = 0;
                *(_DWORD *)(v16 + 156) = 0;
                *(_DWORD *)(v16 + 148) = 2;
                *(_DWORD *)(v16 + 432) = 0;
                goto LABEL_48;
              }
            }
            *(void *)(v16 + 424) = *(void *)(a2 + 424);
            *(_DWORD *)(v16 + 432) = *(_DWORD *)(a2 + 432);
            *(void *)(v16 + 152) = *(void *)(a2 + 152);
            *(_DWORD *)(v16 + 28) = *(_DWORD *)(a2 + 28);
            if (*(_DWORD *)(a2 + 156))
            {
              *(void *)(v16 + 176) = *(void *)(a2 + 176);
              *(_OWORD *)(v16 + 160) = *(_OWORD *)(a2 + 160);
              *(_DWORD *)(v16 + 208) = *(_DWORD *)(a2 + 208);
            }
            *(_DWORD *)(v16 + 148) = *(_DWORD *)(a2 + 148);
            uint64_t v29 = *(xmlDict **)(v16 + 456);
            if (v29) {
              xmlDictFree(v29);
            }
            int v30 = *(xmlDict **)(a2 + 456);
            *(void *)(v16 + 456) = v30;
            *(void *)(v16 + 480) = xmlDictLookup(v30, (const xmlChar *)"xml", 3);
            *(void *)(v16 + 488) = xmlDictLookup(*(xmlDictPtr *)(v16 + 456), (const xmlChar *)"xmlns", 5);
            *(void *)(v16 + 496) = xmlDictLookup(*(xmlDictPtr *)(v16 + 456), (const xmlChar *)"http://www.w3.org/XML/1998/namespace", 36);
            *(_DWORD *)(v16 + 568) = *(_DWORD *)(a2 + 568);
            *(_OWORD *)(v16 + 544) = *(_OWORD *)(a2 + 544);
            *(_DWORD *)(v16 + 436) = *(_DWORD *)(a2 + 436);
            *(_DWORD *)(v16 + 104) = *(_DWORD *)(a2 + 104);
            *(_OWORD *)(v16 + 112) = *(_OWORD *)(a2 + 112);
            *(void *)(v16 + 128) = *(void *)(a2 + 128);
            int v31 = 1;
LABEL_48:
            xmlParseContent((xmlParserCtxtPtr)v16);
            unsigned int v32 = *(unsigned char **)(*(void *)(v16 + 56) + 32);
            if (*v32)
            {
              if (*v32 == 60 && v32[1] == 47) {
                int v33 = 85;
              }
              else {
                int v33 = 86;
              }
              xmlFatalErr((_DWORD *)v16, v33, 0);
            }
            if (*(_xmlNode **)(v16 + 80) != v19->children) {
              xmlFatalErr((_DWORD *)v16, 85, 0);
            }
            if (*(_DWORD *)(v16 + 24))
            {
              if (a8)
              {
                xmlNodePtr children = v19->children->children;
                for (*a8 = children; children; xmlNodePtr children = children->next)
                  children->xmlNodePtr parent = 0;
                uint64_t v14 = 0;
                v19->children->xmlNodePtr children = 0;
                if (!v31) {
                  goto LABEL_72;
                }
                goto LABEL_68;
              }
              uint64_t v14 = 0;
              if (v31)
              {
LABEL_68:
                *(void *)(a2 + 696) += *(void *)(v16 + 696);
                int v36 = *(void **)(v16 + 56);
                if (v36) {
                  *(void *)(a2 + 704) = *(void *)(a2 + 704) + v36[8] + v36[4] - v36[3];
                }
                if (*(_DWORD *)(v16 + 604)) {
                  xmlCopyError((xmlErrorPtr)(v16 + 600), (xmlErrorPtr)(a2 + 600));
                }
              }
            }
            else
            {
              unsigned int v35 = *(_DWORD *)(v16 + 136);
              if (v35 <= 1) {
                uint64_t v14 = 1;
              }
              else {
                uint64_t v14 = v35;
              }
              if (v31) {
                goto LABEL_68;
              }
            }
LABEL_72:
            if (a3) {
              *(void *)uint64_t v16 = sax;
            }
            if (v31)
            {
              *(void *)(v16 + 456) = 0;
              *(_OWORD *)(v16 + 544) = 0u;
              *(void *)(a2 + 152) = *(void *)(v16 + 152);
              *(_OWORD *)(a2 + 112) = *(_OWORD *)(v16 + 112);
              *(void *)(a2 + 128) = *(void *)(v16 + 128);
            }
            *(void *)(v16 + 112) = 0;
            *(void *)(v16 + 120) = 0;
            *(void *)(v16 + 128) = 0;
LABEL_77:
            xmlFreeParserCtxt((xmlParserCtxtPtr)v16);
            *p_intSubset = 0;
            p_intSubset[1] = 0;
            xmlFreeDoc(v19);
            return v14;
          }
          xmlFreeParserCtxt((xmlParserCtxtPtr)v16);
        }
        else
        {
          return 27;
        }
      }
    }
  }
  return v14;
}

void xmlParseDocTypeDecl(xmlParserCtxtPtr ctxt)
{
  publicID = 0;
  xmlParserInputPtr input = ctxt->input;
  xmlNodePtr cur = input->cur;
  input->xmlNodePtr cur = cur + 9;
  input->col += 9;
  if (!cur[9]) {
    xmlParserInputGrow(input, 250);
  }
  xmlSkipBlankChars(ctxt);
  uint64_t v4 = xmlParseName(ctxt);
  if (!v4) {
    xmlFatalErrMsg(ctxt, 68, (char)"xmlParseDocTypeDecl : no DOCTYPE name !\n");
  }
  ctxt->intSubName = v4;
  xmlSkipBlankChars(ctxt);
  uint64_t v5 = xmlParseExternalID(ctxt, &publicID, 1);
  charactersSAXFunc v6 = v5;
  uint64_t v7 = publicID;
  if ((unint64_t)v5 | (unint64_t)publicID) {
    ctxt->hasExternalSubset = 1;
  }
  ctxt->extSubxmlURIPtr URI = v5;
  ctxt->extSubSystem = v7;
  xmlSkipBlankChars(ctxt);
  if (ctxt->sax)
  {
    internalSubsetSAXFunc internalSubset = ctxt->sax->internalSubset;
    if (internalSubset)
    {
      if (!ctxt->disableSAX) {
        ((void (*)(void *, const xmlChar *, xmlChar *, xmlChar *))internalSubset)(ctxt->userData, v4, v7, v6);
      }
    }
  }
  if (ctxt->instate != XML_PARSER_EOF)
  {
    int v9 = *ctxt->input->cur;
    if (v9 != 62)
    {
      if (v9 == 91) {
        return;
      }
      xmlFatalErr(ctxt, 61, 0);
    }
    xmlNextChar(ctxt);
  }
}

const xmlChar *__cdecl xmlParseAttribute(xmlParserCtxtPtr ctxt, xmlChar **value)
{
  *unsigned int value = 0;
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  uint64_t v4 = xmlParseName(ctxt);
  if (v4)
  {
    xmlSkipBlankChars(ctxt);
    if (*ctxt->input->cur == 61)
    {
      xmlNextChar(ctxt);
      xmlSkipBlankChars(ctxt);
      if (ctxt->input) {
        uint64_t v5 = xmlParseAttValueInternal((uint64_t)ctxt, 0, 0, 0);
      }
      else {
        uint64_t v5 = 0;
      }
      ctxt->xmlParserInputState instate = XML_PARSER_CONTENT;
      if (ctxt->pedantic && xmlStrEqual(v4, (const xmlChar *)"xml:lang") && !xmlCheckLanguageID(v5)) {
        xmlWarningMsg(ctxt, 98, "Malformed value for xml:lang : %s\n", v5);
      }
      if (xmlStrEqual(v4, (const xmlChar *)"xml:space"))
      {
        if (xmlStrEqual(v5, (const xmlChar *)"default"))
        {
          *ctxt->space = 0;
        }
        else if (xmlStrEqual(v5, (const xmlChar *)"preserve"))
        {
          *ctxt->space = 1;
        }
        else
        {
          xmlWarningMsg(ctxt, 102, "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n", v5);
        }
      }
      *unsigned int value = v5;
    }
    else
    {
      xmlFatalErrMsgStr(ctxt, 41, "Specification mandates value for attribute %s\n", v4);
      return 0;
    }
  }
  else
  {
    xmlFatalErrMsg(ctxt, 68, (char)"error parsing attribute name\n");
  }
  return v4;
}

_DWORD *xmlErrAttributeDup(_DWORD *result, const xmlChar *a2, xmlChar *a3)
{
  int v3 = result;
  if (result)
  {
    if (result[83] && result[68] == -1) {
      return result;
    }
    result[34] = 42;
  }
  if (a2) {
    xmlElementContentPtr result = __xmlRaiseError(0, 0, 0, result, 0, 1u, 42, 3, 0, 0, a2, a3, 0, 0, 0, "Attribute %s:%s redefined\n", (char)a2);
  }
  else {
    xmlElementContentPtr result = __xmlRaiseError(0, 0, 0, result, 0, 1u, 42, 3, 0, 0, a3, 0, 0, 0, 0, "Attribute %s redefined\n", (char)a3);
  }
  if (v3)
  {
    v3[6] = 0;
    if (!v3[112]) {
      v3[83] = 1;
    }
  }
  return result;
}

xmlParserInput *xmlParseEndTag1(xmlParserCtxt *a1)
{
  if (!a1->progressive && a1->input->end - a1->input->cur <= 249) {
    xmlGROW((uint64_t)a1);
  }
  xmlParserInputPtr input = a1->input;
  xmlNodePtr cur = input->cur;
  if (*cur == 60 && cur[1] == 47)
  {
    input->xmlNodePtr cur = cur + 2;
    input->col += 2;
    if (!cur[2]) {
      xmlParserInputGrow(input, 250);
    }
    uint64_t v4 = xmlParseNameAndCompare((uint64_t)a1, (unsigned __int8 *)a1->name);
    if (!a1->progressive && a1->input->end - a1->input->cur <= 249) {
      xmlGROW((uint64_t)a1);
    }
    xmlSkipBlankChars(a1);
    xmlElementContentPtr result = a1->input;
    charactersSAXFunc v6 = result->cur;
    if (*v6 == 62)
    {
      ++result->col;
      result->xmlNodePtr cur = v6 + 1;
      if (!v6[1]) {
        xmlElementContentPtr result = (xmlParserInput *)xmlParserInputGrow(result, 250);
      }
    }
    else
    {
      xmlElementContentPtr result = (xmlParserInput *)xmlFatalErr(a1, 73, 0);
    }
    if (v4 != 1)
    {
      if (v4) {
        uint64_t v7 = (xmlChar *)v4;
      }
      else {
        uint64_t v7 = (xmlChar *)"unparsable";
      }
      xmlElementContentPtr result = (xmlParserInput *)xmlFatalErrMsgStrIntStr(a1, 76, "Opening and ending tag mismatch: %s line %d and %s\n", a1->name, 0, v7);
    }
    if (a1->sax)
    {
      endElementSAXFunc endElement = (uint64_t (*)(void *, const xmlChar *))a1->sax->endElement;
      if (endElement)
      {
        if (!a1->disableSAX) {
          xmlElementContentPtr result = (xmlParserInput *)endElement(a1->userData, a1->name);
        }
      }
    }
    int nameNr = a1->nameNr;
    unsigned int v10 = nameNr - 1;
    if (nameNr >= 1)
    {
      a1->int nameNr = v10;
      nameTab = a1->nameTab;
      if (nameNr == 1) {
        uint64_t v12 = 0;
      }
      else {
        uint64_t v12 = nameTab[nameNr - 2];
      }
      a1->name = v12;
      nameTab[v10] = 0;
    }
    int spaceNr = a1->spaceNr;
    if (spaceNr >= 1)
    {
      unsigned int v14 = spaceNr - 2;
      unsigned int v15 = spaceNr - 1;
      a1->int spaceNr = v15;
      spaceTab = a1->spaceTab;
      if (!v15) {
        unsigned int v14 = 0;
      }
      a1->space = &spaceTab[v14];
      spaceTab[v15] = -1;
    }
  }
  else
  {
    return (xmlParserInput *)xmlFatalErrMsg(a1, 74, (char)"xmlParseEndTag: '</' not found\n");
  }
  return result;
}

void xmlParseCDSect(xmlParserCtxtPtr ctxt)
{
  *(void *)int len = 0;
  int v35 = 0;
  if ((ctxt->options & 0x80000) != 0) {
    int v2 = 1000000000;
  }
  else {
    int v2 = 10000000;
  }
  xmlParserInputPtr input = ctxt->input;
  xmlNodePtr cur = input->cur;
  if (*cur == 60
    && cur[1] == 33
    && cur[2] == 91
    && cur[3] == 67
    && cur[4] == 68
    && cur[5] == 65
    && cur[6] == 84
    && cur[7] == 65
    && cur[8] == 91)
  {
    input->xmlNodePtr cur = cur + 9;
    input->col += 9;
    if (!cur[9]) {
      xmlParserInputGrow(input, 250);
    }
    ctxt->xmlParserInputState instate = XML_PARSER_CDATA_SECTION;
    int v5 = xmlCurrentChar(ctxt, &len[1]);
    int v6 = v5;
    if (v5 > 255)
    {
      if ((v5 - 0x10000) >= 0x100000
        && v5 >> 11 >= 0x1B
        && (v5 - 57344) >> 1 >= 0xFFF)
      {
        goto LABEL_36;
      }
    }
    else if (v5 <= 31 && (v5 > 0xD || ((1 << v5) & 0x2600) == 0))
    {
      goto LABEL_36;
    }
    xmlParserInputPtr v7 = ctxt->input;
    int v8 = v7->cur;
    int v9 = &v8[len[1]];
    if (v9 <= v7->end)
    {
      if (*v8 == 10)
      {
        ++v7->line;
        v7->int col = 1;
      }
      else
      {
        ++v7->col;
      }
      v7->xmlNodePtr cur = v9;
    }
    int v10 = xmlCurrentChar(ctxt, len);
    int v11 = v10;
    if (v10 > 255)
    {
      if ((v10 - 0x10000) >= 0x100000
        && v10 >> 11 >= 0x1B
        && (v10 - 57344) >> 1 >= 0xFFF)
      {
        goto LABEL_36;
      }
    }
    else if (v10 <= 31 && (v10 > 0xD || ((1 << v10) & 0x2600) == 0))
    {
LABEL_36:
      xmlFatalErr(ctxt, 63, 0);
      ctxt->xmlParserInputState instate = XML_PARSER_CONTENT;
      return;
    }
    xmlParserInputPtr v12 = ctxt->input;
    xmlParserCtxtPtr v13 = v12->cur;
    unsigned int v14 = &v13[len[0]];
    if (v14 <= v12->end)
    {
      if (*v13 == 10)
      {
        ++v12->line;
        v12->int col = 1;
      }
      else
      {
        ++v12->col;
      }
      v12->xmlNodePtr cur = v14;
    }
    int v15 = xmlCurrentChar(ctxt, &v35);
    uint64_t v16 = (xmlChar *)xmlMallocAtomic(0x64uLL);
    if (v16)
    {
      uint64_t v17 = v16;
      uint64_t v18 = 0;
      int v19 = 0;
      int v20 = 100;
      while (1)
      {
        if (v15 > 255)
        {
          if ((v15 - 0x10000) >= 0x100000
            && v15 >> 11 >= 0x1B
            && (v15 - 57344) >> 1 >= 0xFFF)
          {
LABEL_79:
            v17[(int)v18] = 0;
            ctxt->xmlParserInputState instate = XML_PARSER_CONTENT;
            xmlFatalErrMsgStr(ctxt, 63, "CData section not finished\n%.50s\n", v17);
            goto LABEL_80;
          }
        }
        else if (v15 <= 31)
        {
          if (v15 > 0xD || ((1 << v15) & 0x2600) == 0) {
            goto LABEL_79;
          }
        }
        else if (v6 == 93 && v11 == 93 && v15 == 62)
        {
          v17[(int)v18] = 0;
          ctxt->xmlParserInputState instate = XML_PARSER_CONTENT;
          xmlParserInputPtr v30 = ctxt->input;
          int v31 = v30->cur;
          unsigned int v32 = &v31[v35];
          if (v32 <= v30->end)
          {
            if (*v31 == 10)
            {
              ++v30->line;
              v30->int col = 1;
            }
            else
            {
              ++v30->col;
            }
            v30->xmlNodePtr cur = v32;
          }
          sax = ctxt->sax;
          if (ctxt->sax)
          {
            if (!ctxt->disableSAX)
            {
              cdataBlocuint64_t k = (void (*)(void *, xmlChar *, uint64_t))sax->cdataBlock;
              if (cdataBlock || (cdataBlocuint64_t k = (void (*)(void *, xmlChar *, uint64_t))sax->characters) != 0) {
                cdataBlock(ctxt->userData, v17, v18);
              }
            }
          }
          goto LABEL_80;
        }
        if ((int)v18 + 5 >= v20)
        {
          v20 *= 2;
          int v21 = (xmlChar *)xmlRealloc(v17, v20);
          if (!v21)
          {
            xmlFree(v17);
            break;
          }
          uint64_t v17 = v21;
        }
        if (len[1] == 1)
        {
          v17[(int)v18] = v6;
          uint64_t v18 = (v18 + 1);
        }
        else
        {
          uint64_t v18 = (xmlCopyCharMultiByte(&v17[(int)v18], v6) + v18);
        }
        int v23 = v35;
        int v22 = len[0];
        len[0] = v35;
        len[1] = v22;
        if (v19 < 50)
        {
          ++v19;
        }
        else
        {
          if (!ctxt->progressive)
          {
            xmlParserInputPtr v24 = ctxt->input;
            int v25 = v24->cur;
            if (v25 - v24->base < 501 || v24->end - v25 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
            {
              if (ctxt->input->end - ctxt->input->cur <= 249) {
                xmlGROW((uint64_t)ctxt);
              }
            }
          }
          if (ctxt->instate == XML_PARSER_EOF) {
            goto LABEL_80;
          }
          int v19 = 0;
          int v23 = v35;
        }
        xmlParserInputPtr v26 = ctxt->input;
        int v27 = v26->cur;
        unsigned int v28 = &v27[v23];
        if (v28 <= v26->end)
        {
          if (*v27 == 10)
          {
            ++v26->line;
            int v29 = 1;
          }
          else
          {
            int v29 = v26->col + 1;
          }
          v26->int col = v29;
          v26->xmlNodePtr cur = v28;
        }
        int v6 = v11;
        int v11 = v15;
        int v15 = xmlCurrentChar(ctxt, &v35);
        if ((int)v18 > v2)
        {
          xmlFatalErrMsg(ctxt, 63, (char)"CData section too big found\n");
LABEL_80:
          xmlFree(v17);
          return;
        }
      }
    }
    htmlErrMemory(ctxt, 0);
  }
}

void xmlParseContent(xmlParserCtxtPtr ctxt)
{
  int nameNr = ctxt->nameNr;
  xmlParseContentInternal((int)ctxt);
  if (ctxt->instate != XML_PARSER_EOF)
  {
    int v3 = ctxt->nameNr;
    if (v3 > nameNr)
    {
      int v4 = v3 - 1;
      int v5 = ctxt->nameTab[v4];
      int v6 = *((_DWORD *)ctxt->pushTab + 6 * v4 + 4);
      xmlFatalErrMsgStrIntStr(ctxt, 77, "Premature end of data in tag %s line %d\n", v5, v6, 0);
    }
  }
}

_DWORD *xmlFatalErrMsgStrIntStr(_DWORD *result, int a2, const char *a3, const xmlChar *a4, int a5, xmlChar *cur)
{
  if (!result) {
    return __xmlRaiseError(0, 0, 0, 0, 0, 1u, a2, 3, 0, 0, a4, cur, 0, a5, 0, a3, (char)a4);
  }
  int v6 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    xmlElementContentPtr result = __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 3, 0, 0, a4, cur, 0, a5, 0, a3, (char)a4);
    v6[6] = 0;
    if (!v6[112]) {
      v6[83] = 1;
    }
  }
  return result;
}

void xmlParseInternalSubset(uint64_t a1)
{
  int v2 = **(unsigned __int8 **)(*(void *)(a1 + 56) + 32);
  if (v2 == 91)
  {
    int v3 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)(a1 + 272) = 3;
    xmlNextChar((xmlParserCtxtPtr)a1);
    while (1)
    {
      uint64_t v4 = *(void *)(a1 + 56);
      int v5 = *(unsigned __int8 **)(v4 + 32);
      int v2 = *v5;
      if (v2 == 93 && *(_DWORD *)(a1 + 64) <= v3) {
        break;
      }
      if (*(_DWORD *)(a1 + 272) == -1) {
        goto LABEL_17;
      }
      uint64_t v6 = *(unsigned int *)(v4 + 64);
      xmlSkipBlankChars((xmlParserCtxtPtr)a1);
      xmlParseMarkupDecl((xmlParserCtxtPtr)a1);
      xmlParsePEReference((xmlParserCtxtPtr)a1);
      xmlParserInputPtr v7 = *(void **)(a1 + 56);
      if (*(int *)(a1 + 64) >= 2)
      {
        if (v7[1])
        {
          int v8 = (unsigned char *)v7[4];
          if (*v8 == 60 && v8[1] == 33 && v8[2] == 91)
          {
            xmlParseConditionalSections(a1);
            xmlParserInputPtr v7 = *(void **)(a1 + 56);
          }
        }
      }
      if ((unsigned __int8 *)v7[4] == v5 && v6 == v7[8])
      {
        xmlFatalErr((_DWORD *)a1, 1, (const xmlChar *)"xmlParseInternalSubset: error detected in Markup declaration\n");
        if (*(_DWORD *)(a1 + 64) <= v3)
        {
          int v2 = **(unsigned __int8 **)(*(void *)(a1 + 56) + 32);
LABEL_17:
          if (v2 != 93) {
            goto LABEL_19;
          }
          break;
        }
        xmlPopInput((xmlParserCtxtPtr)a1);
      }
    }
    xmlNextChar((xmlParserCtxtPtr)a1);
    xmlSkipBlankChars((xmlParserCtxtPtr)a1);
    int v2 = **(unsigned __int8 **)(*(void *)(a1 + 56) + 32);
  }
LABEL_19:
  if (v2 == 62)
  {
    xmlNextChar((xmlParserCtxtPtr)a1);
  }
  else
  {
    xmlFatalErr((_DWORD *)a1, 61, 0);
  }
}

void xmlCleanSpecialAttr(void *data)
{
  int v2 = (xmlHashTable *)*((void *)data + 69);
  if (v2)
  {
    xmlHashScanFull(v2, (xmlHashScannerFull)xmlCleanSpecialAttrCallback, data);
    if (!xmlHashSize(*((xmlHashTablePtr *)data + 69)))
    {
      xmlHashFree(*((xmlHashTablePtr *)data + 69), 0);
      *((void *)data + 69) = 0;
    }
  }
}

int xmlParseExtParsedEnt(xmlParserCtxtPtr ctxt)
{
  if (!ctxt) {
    return -1;
  }
  if (!ctxt->input) {
    return -1;
  }
  xmlDefaultSAXHandlerInit();
  xmlDetectSAX2((const xmlChar *)ctxt);
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  if (ctxt->sax)
  {
    setDocumentLocatorSAXFunc setDocumentLocator = ctxt->sax->setDocumentLocator;
    if (setDocumentLocator)
    {
      userData = ctxt->userData;
      uint64_t v4 = __xmlDefaultSAXLocator();
      ((void (*)(void *, xmlSAXLocator *))setDocumentLocator)(userData, v4);
    }
  }
  *(_DWORD *)in = 0;
  xmlNodePtr cur = ctxt->input->cur;
  if (ctxt->input->end - cur >= 4)
  {
    *(_DWORD *)in = *(_DWORD *)cur;
    xmlCharEncoding v6 = xmlDetectCharEncoding(in, 4);
    if (v6) {
      xmlSwitchEncoding(ctxt, v6);
    }
  }
  xmlParserInputPtr input = ctxt->input;
  if (!*input->cur)
  {
    xmlFatalErr(ctxt, 4, 0);
    xmlParserInputPtr input = ctxt->input;
  }
  if (!ctxt->progressive && input->end - input->cur <= 249)
  {
    xmlGROW((uint64_t)ctxt);
    xmlParserInputPtr input = ctxt->input;
  }
  int v8 = input->cur;
  if (*v8 != 60
    || v8[1] != 63
    || v8[2] != 120
    || v8[3] != 109
    || v8[4] != 108
    || (unsigned int v9 = v8[5], v9 > 0x20)
    || ((1 << v9) & 0x100002600) == 0)
  {
    ctxt->version = xmlCharStrdup("1.0");
    goto LABEL_27;
  }
  xmlParseXMLDecl(ctxt);
  if (ctxt->errNo == 32) {
    return -1;
  }
  xmlSkipBlankChars(ctxt);
LABEL_27:
  if (ctxt->sax)
  {
    startDocumentSAXFunc startDocument = ctxt->sax->startDocument;
    if (startDocument)
    {
      if (!ctxt->disableSAX) {
        ((void (*)(void *))startDocument)(ctxt->userData);
      }
    }
  }
  if (ctxt->instate == XML_PARSER_EOF) {
    return -1;
  }
  ctxt->xmlParserInputState instate = XML_PARSER_CONTENT;
  ctxt->validate = 0;
  ctxt->loadsubset = 0;
  ctxt->int depth = 0;
  xmlParseContent(ctxt);
  if (ctxt->instate == XML_PARSER_EOF) {
    return -1;
  }
  int v11 = ctxt->input->cur;
  if (*v11)
  {
    if (*v11 == 60 && v11[1] == 47) {
      int v12 = 85;
    }
    else {
      int v12 = 86;
    }
    xmlFatalErr(ctxt, v12, 0);
  }
  if (ctxt->sax)
  {
    endDocumentSAXFunc endDocument = ctxt->sax->endDocument;
    if (endDocument) {
      ((void (*)(void *))endDocument)(ctxt->userData);
    }
  }
  if (ctxt->wellFormed) {
    return 0;
  }
  else {
    return -1;
  }
}

void xmlStopParser(xmlParserCtxtPtr ctxt)
{
  if (ctxt)
  {
    xmlHaltParser(ctxt);
    ctxt->int errNo = 111;
  }
}

xmlParserCtxtPtr xmlCreateIOParserCtxt(xmlSAXHandlerPtr sax, void *user_data, xmlInputReadCallback ioread, xmlInputCloseCallback ioclose, void *ioctx, xmlCharEncoding enc)
{
  if (!ioread) {
    return 0;
  }
  int v8 = (xmlParserCtxt *)ioclose;
  xmlParserInputBufferPtr IO = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, enc);
  if (!IO)
  {
    if (!v8) {
      return v8;
    }
    ((void (*)(void *))v8)(ioctx);
    return 0;
  }
  int v12 = IO;
  xmlParserCtxtPtr v13 = xmlNewParserCtxt();
  int v8 = v13;
  if (!v13)
  {
    xmlFreeParserInputBuffer(v12);
    return v8;
  }
  if (sax)
  {
    unsigned int v14 = (xmlSAXHandlerV1 *)v13->sax;
    if (v14 != __xmlDefaultSAXHandler()) {
      xmlFree(v8->sax);
    }
    int v15 = (_xmlSAXHandler *)xmlMalloc(0x100uLL);
    v8->sax = v15;
    if (!v15)
    {
      xmlFreeParserInputBuffer(v12);
      htmlErrMemory(v8, 0);
      goto LABEL_19;
    }
    *(_OWORD *)&v15->_private = 0u;
    *(_OWORD *)&v15->endElementNs = 0u;
    *(_OWORD *)&v15->getParameterEntitySAXFunc getParameterEntity = 0u;
    *(_OWORD *)&v15->externalSubsetSAXFunc externalSubset = 0u;
    *(_OWORD *)&v15->commentSAXFunc comment = 0u;
    *(_OWORD *)&v15->error = 0u;
    *(_OWORD *)&v15->referenceSAXFunc reference = 0u;
    *(_OWORD *)&v15->ignorableWhitespace = 0u;
    *(_OWORD *)&v15->startDocumentSAXFunc startDocument = 0u;
    *(_OWORD *)&v15->startElementSAXFunc startElement = 0u;
    *(_OWORD *)&v15->attributeDeclSAXFunc attributeDecl = 0u;
    *(_OWORD *)&v15->unparsedEntityDeclSAXFunc unparsedEntityDecl = 0u;
    *(_OWORD *)&v15->resolvexmlEntityPtr Entity = 0u;
    *(_OWORD *)&v15->entityDeclSAXFunc entityDecl = 0u;
    *(_OWORD *)&v15->internalSubsetSAXFunc internalSubset = 0u;
    *(_OWORD *)&v15->hasInternalSubset = 0u;
    if (sax->initialized == -554844497) {
      size_t v16 = 256;
    }
    else {
      size_t v16 = 224;
    }
    memcpy(v8->sax, sax, v16);
    if (user_data) {
      v8->userData = user_data;
    }
  }
  uint64_t v17 = xmlNewIOInputStream(v8, v12, enc);
  if (!v17)
  {
LABEL_19:
    xmlFreeParserCtxt(v8);
    return 0;
  }
  inputPush(v8, v17);
  return v8;
}

xmlDtdPtr xmlIOParseDTD(xmlSAXHandlerPtr sax, xmlParserInputBufferPtr input, xmlCharEncoding enc)
{
  if (!input) {
    return 0;
  }
  xmlParserCtxtPtr v6 = xmlNewParserCtxt();
  if (!v6)
  {
    xmlFreeParserInputBuffer(input);
    return 0;
  }
  xmlParserCtxtPtr v7 = v6;
  v6->options |= 4u;
  if (sax)
  {
    int v8 = v6->sax;
    if (v7->sax) {
      xmlFree(v8);
    }
    v7->sax = sax;
    v7->userData = v7;
  }
  xmlDetectSAX2((const xmlChar *)v7);
  unsigned int v9 = xmlNewIOInputStream(v7, input, XML_CHAR_ENCODING_NONE);
  if (!v9)
  {
    if (sax) {
      v7->sax = 0;
    }
    xmlFreeParserInputBuffer(input);
    goto LABEL_28;
  }
  int v10 = v9;
  if (xmlPushInput(v7, v9) < 0)
  {
    if (sax) {
      v7->sax = 0;
    }
LABEL_28:
    xmlFreeParserCtxt(v7);
    return 0;
  }
  if (enc) {
    xmlSwitchEncoding(v7, enc);
  }
  v10->filename = 0;
  *(void *)&v10->unint64_t line = 0x100000001;
  xmlNodePtr cur = v7->input->cur;
  v10->unint64_t base = cur;
  v10->xmlNodePtr cur = cur;
  v10->xmlParserInputDeallocate free = 0;
  v7->inSubset = 2;
  xmlDocPtr v12 = xmlNewDoc((const xmlChar *)"1.0");
  v7->xmlDocPtr myDoc = v12;
  if (!v12)
  {
    htmlErrMemory(v7, (const xmlChar *)"New Doc failed");
    return 0;
  }
  *(_DWORD *)in = 0;
  v12->int properties = 64;
  v7->myDoc->extSubset = xmlNewDtd(v12, (const xmlChar *)"none", (const xmlChar *)"none", (const xmlChar *)"none");
  if (enc == XML_CHAR_ENCODING_NONE)
  {
    xmlParserCtxtPtr v13 = v7->input->cur;
    if (v7->input->end - v13 >= 4)
    {
      *(_DWORD *)in = *(_DWORD *)v13;
      xmlCharEncoding v14 = xmlDetectCharEncoding(in, 4);
      if (v14) {
        xmlSwitchEncoding(v7, v14);
      }
    }
  }
  xmlParseExternalSubset(v7, (const xmlChar *)"none", (const xmlChar *)"none");
  xmlDocPtr myDoc = v7->myDoc;
  if (myDoc)
  {
    if (v7->wellFormed)
    {
      extSubset = myDoc->extSubset;
      myDoc->extSubset = 0;
      if (extSubset)
      {
        extSubset->xmlDocPtr doc = 0;
        for (uint64_t i = extSubset->children; i; uint64_t i = i->next)
          i->xmlDocPtr doc = 0;
      }
    }
    else
    {
      extSubset = 0;
    }
    xmlFreeDoc(myDoc);
    v7->xmlDocPtr myDoc = 0;
  }
  else
  {
    extSubset = 0;
  }
  if (sax) {
    v7->sax = 0;
  }
  xmlFreeParserCtxt(v7);
  return extSubset;
}

xmlDtdPtr xmlSAXParseDTD(xmlSAXHandlerPtr sax, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  if (!((unint64_t)ExternalID | (unint64_t)SystemID)) {
    return 0;
  }
  xmlParserCtxtPtr v6 = xmlNewParserCtxt();
  if (!v6) {
    return 0;
  }
  xmlParserCtxtPtr v7 = v6;
  v6->options |= 4u;
  if (sax)
  {
    int v8 = v6->sax;
    if (v7->sax) {
      xmlFree(v8);
    }
    v7->sax = sax;
    v7->userData = v7;
  }
  unsigned int v9 = xmlCanonicPath(SystemID);
  int v10 = v9;
  if (SystemID && !v9)
  {
LABEL_9:
    xmlFreeParserCtxt(v7);
    return 0;
  }
  if (!v7->sax
    || (resolvexmlEntityPtr Entity = (uint64_t (*)(void *, const xmlChar *, xmlChar *))v7->sax->resolveEntity) == 0
    || (xmlDocPtr v12 = (xmlParserInput *)resolveEntity(v7->userData, ExternalID, v9)) == 0
    || (xmlParserCtxtPtr v13 = v12, xmlPushInput(v7, v12) < 0))
  {
    if (sax) {
      v7->sax = 0;
    }
    xmlFreeParserCtxt(v7);
    if (v10) {
      xmlFree(v10);
    }
    return 0;
  }
  xmlParserInputPtr input = v7->input;
  xmlNodePtr cur = input->cur;
  if (input->end - cur >= 4)
  {
    xmlCharEncoding v16 = xmlDetectCharEncoding(cur, 4);
    xmlSwitchEncoding(v7, v16);
  }
  if (v13->filename) {
    xmlFree(v10);
  }
  else {
    v13->filename = (const char *)v10;
  }
  *(void *)&v13->unint64_t line = 0x100000001;
  int v19 = v7->input->cur;
  v13->unint64_t base = v19;
  v13->xmlNodePtr cur = v19;
  v13->xmlParserInputDeallocate free = 0;
  v7->inSubset = 2;
  xmlDocPtr v20 = xmlNewDoc((const xmlChar *)"1.0");
  v7->xmlDocPtr myDoc = v20;
  if (!v20)
  {
    htmlErrMemory(v7, (const xmlChar *)"New Doc failed");
    if (sax) {
      v7->sax = 0;
    }
    goto LABEL_9;
  }
  v20->int properties = 64;
  v7->myDoc->extSubset = xmlNewDtd(v20, (const xmlChar *)"none", ExternalID, SystemID);
  xmlParseExternalSubset(v7, ExternalID, SystemID);
  xmlDocPtr myDoc = v7->myDoc;
  if (myDoc)
  {
    if (v7->wellFormed)
    {
      extSubset = myDoc->extSubset;
      myDoc->extSubset = 0;
      if (extSubset)
      {
        extSubset->xmlDocPtr doc = 0;
        for (uint64_t i = extSubset->children; i; uint64_t i = i->next)
          i->xmlDocPtr doc = 0;
      }
    }
    else
    {
      extSubset = 0;
    }
    xmlFreeDoc(myDoc);
    v7->xmlDocPtr myDoc = 0;
  }
  else
  {
    extSubset = 0;
  }
  if (sax) {
    v7->sax = 0;
  }
  xmlFreeParserCtxt(v7);
  return extSubset;
}

xmlDtdPtr xmlParseDTD(const xmlChar *ExternalID, const xmlChar *SystemID)
{
  return xmlSAXParseDTD(0, ExternalID, SystemID);
}

int xmlParseCtxtExternalEntity(xmlParserCtxtPtr ctx, const xmlChar *URL, const xmlChar *ID, xmlNodePtr *lst)
{
  if (!ctx) {
    return -1;
  }
  if (ctx->userData == ctx) {
    userData = 0;
  }
  else {
    userData = ctx->userData;
  }
  return xmlParseExternalEntityPrivate((uint64_t)ctx->myDoc, (uint64_t)ctx, ctx->sax, userData, ctx->depth + 1, URL, (const char *)ID, lst);
}

int xmlParseExternalEntity(xmlDocPtr doc, xmlSAXHandlerPtr sax, void *user_data, int depth, const xmlChar *URL, const xmlChar *ID, xmlNodePtr *lst)
{
  return xmlParseExternalEntityPrivate((uint64_t)doc, 0, sax, user_data, depth, URL, (const char *)ID, lst);
}

int xmlParseBalancedChunkMemory(xmlDocPtr doc, xmlSAXHandlerPtr sax, void *user_data, int depth, const xmlChar *string, xmlNodePtr *lst)
{
  return xmlParseBalancedChunkMemoryRecover(doc, sax, user_data, depth, string, lst, 0);
}

int xmlParseBalancedChunkMemoryRecover(xmlDocPtr doc, xmlSAXHandlerPtr sax, void *user_data, int depth, const xmlChar *string, xmlNodePtr *lst, int recover)
{
  if (depth > 40) {
    return 89;
  }
  if (lst) {
    *xmlNodePtr lst = 0;
  }
  if (!string) {
    return -1;
  }
  int v15 = xmlStrlen(string);
  xmlParserCtxtPtr MemoryParserCtxt = xmlCreateMemoryParserCtxt((const char *)string, v15);
  if (!MemoryParserCtxt) {
    return -1;
  }
  xmlParserCtxtPtr v17 = MemoryParserCtxt;
  MemoryParserCtxt->userData = MemoryParserCtxt;
  if (sax)
  {
    uint64_t v18 = MemoryParserCtxt->sax;
    MemoryParserCtxt->sax = sax;
    if (user_data) {
      MemoryParserCtxt->userData = user_data;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  xmlDocPtr v19 = xmlNewDoc((const xmlChar *)"1.0");
  if (!v19)
  {
    xmlFreeParserCtxt(v17);
    return -1;
  }
  xmlDocPtr v20 = v19;
  v19->int properties = 64;
  if (doc && doc->dict)
  {
    xmlDictFree(v17->dict);
    dict = doc->dict;
    v17->dict = dict;
    xmlDictReference(dict);
    v17->str_xml = xmlDictLookup(v17->dict, (const xmlChar *)"xml", 3);
    v17->str_xmlxmlNsPtr ns = xmlDictLookup(v17->dict, (const xmlChar *)"xmlns", 5);
    v17->str_xml_xmlNsPtr ns = xmlDictLookup(v17->dict, (const xmlChar *)"http://www.w3.org/XML/1998/namespace", 36);
    v17->dictNames = 1;
  }
  else
  {
    v17->recovery = 0;
    v17->replaceEntities = 0;
    v17->pedantic = 0;
    v17->keepBlanks = 1;
    v17->validate = 0;
    v17->options |= 0x1000u;
    v17->dictNames = 0;
    *(void *)&v17->loadsubset = 0x100000000;
    if (!doc) {
      goto LABEL_18;
    }
  }
  *(_OWORD *)&v20->intSubset = *(_OWORD *)&doc->intSubset;
LABEL_18:
  int v22 = xmlNewDocNode(v20, 0, (const xmlChar *)"pseudoroot", 0);
  if (!v22)
  {
    if (sax) {
      v17->sax = v18;
    }
    xmlFreeParserCtxt(v17);
    v20->intSubset = 0;
    v20->extSubset = 0;
    xmlFreeDoc(v20);
    return -1;
  }
  int v23 = v22;
  xmlAddChild((xmlNodePtr)v20, v22);
  nodePush(v17, v23);
  v17->xmlDocPtr myDoc = v20;
  if (doc)
  {
    v20->children->xmlDocPtr doc = doc;
    xmlSearchNsByHref(doc, (xmlNodePtr)doc, (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
    v20->oldNs = doc->oldNs;
  }
  v17->xmlParserInputState instate = XML_PARSER_CONTENT;
  v17->input_int id = 2;
  v17->int depth = depth;
  v17->validate = 0;
  v17->loadsubset = 0;
  xmlDetectSAX2((const xmlChar *)v17);
  if (doc)
  {
    xmlNodePtr children = doc->children;
    doc->xmlNodePtr children = 0;
    xmlParseContent(v17);
    doc->xmlNodePtr children = children;
  }
  else
  {
    xmlParseContent(v17);
  }
  xmlNodePtr cur = v17->input->cur;
  if (*cur)
  {
    if (*cur == 60 && cur[1] == 47) {
      int v27 = 85;
    }
    else {
      int v27 = 86;
    }
    xmlFatalErr(v17, v27, 0);
  }
  if (v17->node != v20->children) {
    xmlFatalErr(v17, 85, 0);
  }
  if (v17->wellFormed)
  {
    int errNo = 0;
    if (!lst) {
      goto LABEL_49;
    }
LABEL_44:
    if (recover == 1 || !errNo)
    {
      unsigned int v28 = v20->children->children;
      for (*lst = v28; v28; unsigned int v28 = v28->next)
      {
        xmlSetTreeDoc(v28, doc);
        v28->xmlNodePtr parent = 0;
      }
      v20->children->xmlNodePtr children = 0;
    }
    goto LABEL_49;
  }
  if (v17->errNo <= 1u) {
    int errNo = 1;
  }
  else {
    int errNo = v17->errNo;
  }
  if (lst) {
    goto LABEL_44;
  }
LABEL_49:
  if (sax) {
    v17->sax = v18;
  }
  xmlFreeParserCtxt(v17);
  v20->intSubset = 0;
  v20->extSubset = 0;
  v20->oldNs = 0;
  xmlFreeDoc(v20);
  return errNo;
}

xmlParserErrors xmlParseInNodeContext(xmlNodePtr node, const char *data, int datalen, int options, xmlNodePtr *lst)
{
  xmlParserErrors errNo = XML_ERR_INTERNAL_ERROR;
  if (datalen < 0) {
    return errNo;
  }
  if (!data) {
    return errNo;
  }
  xmlNodePtr v6 = node;
  if (!node) {
    return errNo;
  }
  if (!lst) {
    return errNo;
  }
  xmlElementType type = node->type;
  if (type > XML_HTML_DOCUMENT_NODE || ((1 << type) & 0x23BE) == 0) {
    return errNo;
  }
  uint64_t v9 = *(void *)&options;
  while (1)
  {
    xmlElementType v10 = v6->type;
    if (v10 == XML_ELEMENT_NODE) {
      break;
    }
    if (v10 == XML_DOCUMENT_NODE || v10 == XML_HTML_DOCUMENT_NODE)
    {
      xmlDocPtr doc = (xmlDoc *)v6;
      goto LABEL_17;
    }
    xmlNodePtr v6 = v6->parent;
    if (!v6) {
      return 1;
    }
  }
  xmlDocPtr doc = v6->doc;
  if (!doc) {
    return 1;
  }
LABEL_17:
  xmlElementType v13 = doc->type;
  if (v13 != XML_HTML_DOCUMENT_NODE)
  {
    if (v13 == XML_DOCUMENT_NODE)
    {
      xmlParserCtxtPtr MemoryParserCtxt = xmlCreateMemoryParserCtxt(data, datalen);
      if (!MemoryParserCtxt) {
        return 2;
      }
      goto LABEL_23;
    }
    return 1;
  }
  xmlParserCtxtPtr MemoryParserCtxt = htmlCreateMemoryParserCtxt(data, datalen);
  uint64_t v9 = v9 | 0x2000;
  if (!MemoryParserCtxt) {
    return 2;
  }
LABEL_23:
  dict = doc->dict;
  if (dict)
  {
    xmlCharEncoding v16 = MemoryParserCtxt->dict;
    if (v16)
    {
      xmlDictFree(v16);
      dict = doc->dict;
    }
    MemoryParserCtxt->dict = dict;
  }
  else
  {
    uint64_t v9 = v9 | 0x1000;
  }
  encoding = doc->encoding;
  if (encoding)
  {
    if (MemoryParserCtxt->encoding)
    {
      xmlFree((void *)MemoryParserCtxt->encoding);
      encoding = doc->encoding;
    }
    MemoryParserCtxt->encoding = xmlStrdup(encoding);
    xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler((const char *)doc->encoding);
    if (!CharEncodingHandler) {
      return 32;
    }
    xmlSwitchToEncoding(MemoryParserCtxt, CharEncodingHandler);
  }
  xmlCtxtUseOptionsInternal((uint64_t *)MemoryParserCtxt, v9, 0);
  xmlDetectSAX2((const xmlChar *)MemoryParserCtxt);
  MemoryParserCtxt->xmlDocPtr myDoc = doc;
  MemoryParserCtxt->input_int id = 2;
  MemoryParserCtxt->xmlParserInputState instate = XML_PARSER_CONTENT;
  xmlDocPtr v19 = xmlNewComment(0);
  if (!v19)
  {
    xmlFreeParserCtxt(MemoryParserCtxt);
    return 2;
  }
  xmlDocPtr v20 = v19;
  xmlAddChild(v6, v19);
  if (v6->type == XML_ELEMENT_NODE)
  {
    nodePush(MemoryParserCtxt, v6);
    int v21 = 0;
    xmlNodePtr v22 = v6;
    do
    {
      if (v22->type != XML_ELEMENT_NODE) {
        break;
      }
      for (uint64_t i = v22->nsDef; i; uint64_t i = i->next)
      {
        xmlParserInputPtr v24 = MemoryParserCtxt->dict;
        prefix = i->prefix;
        if (v24)
        {
          prefix = xmlDictLookup(v24, i->prefix, -1);
          href = xmlDictLookup(MemoryParserCtxt->dict, i->href, -1);
        }
        else
        {
          href = i->href;
        }
        if (!xmlGetNamespace((uint64_t)MemoryParserCtxt, (uint64_t)prefix))
        {
          nsPush((uint64_t)MemoryParserCtxt, (uint64_t)prefix, (uint64_t)href);
          ++v21;
        }
      }
      xmlNodePtr v22 = v22->parent;
    }
    while (v22);
  }
  else
  {
    int v21 = 0;
  }
  if (MemoryParserCtxt->validate || MemoryParserCtxt->replaceEntities) {
    MemoryParserCtxt->loadsubset |= 8u;
  }
  if (doc->type == XML_HTML_DOCUMENT_NODE) {
    __htmlParseContent((uint64_t)MemoryParserCtxt);
  }
  else {
    xmlParseContent(MemoryParserCtxt);
  }
  nsPop((uint64_t)MemoryParserCtxt, v21);
  xmlNodePtr cur = MemoryParserCtxt->input->cur;
  if (*cur)
  {
    if (*cur == 60 && cur[1] == 47) {
      int v28 = 85;
    }
    else {
      int v28 = 86;
    }
    xmlFatalErr(MemoryParserCtxt, v28, 0);
  }
  int v29 = MemoryParserCtxt->node;
  if (!v29 || v29 == v6)
  {
    if (MemoryParserCtxt->wellFormed)
    {
      xmlParserErrors errNo = XML_ERR_OK;
      goto LABEL_70;
    }
  }
  else
  {
    xmlFatalErr(MemoryParserCtxt, 85, 0);
    MemoryParserCtxt->int wellFormed = 0;
  }
  if (MemoryParserCtxt->errNo <= 1u) {
    xmlParserErrors errNo = XML_ERR_INTERNAL_ERROR;
  }
  else {
    xmlParserErrors errNo = MemoryParserCtxt->errNo;
  }
LABEL_70:
  xmlNodePtr next = v20->next;
  v20->xmlNodePtr next = 0;
  v6->last = v20;
  if (next)
  {
    next->int prev = 0;
    *xmlNodePtr lst = next;
    do
    {
      next->xmlNodePtr parent = 0;
      xmlNodePtr next = next->next;
    }
    while (next);
  }
  else
  {
    *xmlNodePtr lst = 0;
  }
  xmlUnlinkNode(v20);
  xmlFreeNode(v20);
  if (errNo)
  {
    xmlFreeNodeList(*lst);
    *xmlNodePtr lst = 0;
  }
  if (doc->dict) {
    MemoryParserCtxt->dict = 0;
  }
  xmlFreeParserCtxt(MemoryParserCtxt);
  return errNo;
}

xmlDocPtr xmlSAXParseEntity(xmlSAXHandlerPtr sax, const char *filename)
{
  xmlParserCtxtPtr URLParserCtxt = xmlCreateURLParserCtxt(filename, 0);
  if (!URLParserCtxt) {
    return 0;
  }
  uint64_t v4 = URLParserCtxt;
  if (sax)
  {
    int v5 = URLParserCtxt->sax;
    if (v4->sax) {
      xmlFree(v5);
    }
    v4->sax = sax;
    v4->userData = 0;
  }
  xmlParseExtParsedEnt(v4);
  xmlDocPtr myDoc = v4->myDoc;
  if (!v4->wellFormed)
  {
    xmlFreeDoc(v4->myDoc);
    xmlDocPtr myDoc = 0;
    v4->xmlDocPtr myDoc = 0;
    if (!sax) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  if (sax) {
LABEL_8:
  }
    v4->sax = 0;
LABEL_9:
  xmlFreeParserCtxt(v4);
  return myDoc;
}

xmlParserCtxtPtr xmlCreateFileParserCtxt(const char *filename)
{
  return xmlCreateURLParserCtxt(filename, 0);
}

xmlDocPtr xmlParseEntity(const char *filename)
{
  return xmlSAXParseEntity(0, filename);
}

xmlParserCtxtPtr xmlCreateEntityParserCtxt(const xmlChar *URL, const xmlChar *ID, const xmlChar *base)
{
  return xmlCreateEntityParserCtxtInternal(URL, (const char *)ID, base, 0);
}

xmlParserCtxt *xmlCreateEntityParserCtxtInternal(const xmlChar *a1, const char *a2, const xmlChar *a3, uint64_t a4)
{
  xmlParserCtxtPtr v8 = xmlNewParserCtxt();
  uint64_t v9 = v8;
  if (!v8) {
    return v9;
  }
  if (a4)
  {
    v8->optioxmlNsPtr ns = *(_DWORD *)(a4 + 564);
    v8->_private = *(void **)(a4 + 424);
    v8->input_int id = *(_DWORD *)(a4 + 736) + 1;
  }
  if (!xmlStrcmp(a1, (const xmlChar *)"-")) {
    a1 = (const xmlChar *)"./-";
  }
  xmlElementType v10 = xmlBuildURI(a1, a3);
  if (v10)
  {
    int v11 = (char *)v10;
    ExternalxmlEntityPtr Entity = xmlLoadExternalEntity((const char *)v10, a2, v9);
    if (ExternalEntity)
    {
      inputPush(v9, ExternalEntity);
      if (!v9->directory)
      {
        Directory = xmlParserGetDirectory(v11);
        if (!v9->directory)
        {
          if (Directory) {
            v9->directory = Directory;
          }
        }
      }
      xmlFree(v11);
      return v9;
    }
    xmlFree(v11);
LABEL_19:
    xmlFreeParserCtxt(v9);
    return 0;
  }
  xmlCharEncoding v14 = xmlLoadExternalEntity((const char *)a1, a2, v9);
  if (!v14) {
    goto LABEL_19;
  }
  inputPush(v9, v14);
  if (!v9->directory)
  {
    int v15 = xmlParserGetDirectory((const char *)a1);
    if (!v9->directory)
    {
      if (v15) {
        v9->directory = v15;
      }
    }
  }
  return v9;
}

xmlParserCtxtPtr xmlCreateURLParserCtxt(const char *filename, int options)
{
  uint64_t v2 = *(void *)&options;
  uint64_t v4 = (uint64_t *)xmlNewParserCtxt();
  int v5 = (xmlParserCtxt *)v4;
  if (v4)
  {
    if (v2) {
      xmlCtxtUseOptionsInternal(v4, v2, 0);
    }
    v5->linenumbers = 1;
    ExternalxmlEntityPtr Entity = xmlLoadExternalEntity(filename, 0, v5);
    if (ExternalEntity)
    {
      inputPush(v5, ExternalEntity);
      if (!v5->directory)
      {
        Directory = xmlParserGetDirectory(filename);
        if (!v5->directory)
        {
          if (Directory) {
            v5->directory = Directory;
          }
        }
      }
    }
    else
    {
      xmlFreeParserCtxt(v5);
      return 0;
    }
  }
  else
  {
    htmlErrMemory(0, (const xmlChar *)"cannot allocate parser context");
  }
  return v5;
}

xmlDocPtr xmlSAXParseFileWithData(xmlSAXHandlerPtr sax, const char *filename, int recovery, void *data)
{
  xmlInitParser();
  xmlParserCtxtPtr URLParserCtxt = xmlCreateURLParserCtxt(filename, 0);
  if (!URLParserCtxt) {
    return 0;
  }
  xmlParserCtxtPtr v9 = URLParserCtxt;
  if (sax)
  {
    xmlElementType v10 = URLParserCtxt->sax;
    if (v9->sax) {
      xmlFree(v10);
    }
    v9->sax = sax;
  }
  xmlDetectSAX2((const xmlChar *)v9);
  if (data) {
    v9->_private = data;
  }
  if (!v9->directory) {
    v9->directory = xmlParserGetDirectory(filename);
  }
  v9->recovery = recovery;
  xmlParseDocument(v9);
  xmlDocPtr myDoc = v9->myDoc;
  if (v9->wellFormed | recovery)
  {
    if (myDoc)
    {
      xmlParserInputBufferPtr buf = v9->input->buf;
      if (buf)
      {
        int compressed = buf->compressed;
        if (compressed >= 1) {
          int compressed = 9;
        }
        myDoc->compression = compressed;
      }
    }
  }
  else
  {
    xmlFreeDoc(v9->myDoc);
    xmlDocPtr myDoc = 0;
    v9->xmlDocPtr myDoc = 0;
  }
  if (sax) {
    v9->sax = 0;
  }
  xmlFreeParserCtxt(v9);
  return myDoc;
}

xmlDocPtr xmlSAXParseFile(xmlSAXHandlerPtr sax, const char *filename, int recovery)
{
  return xmlSAXParseFileWithData(sax, filename, recovery, 0);
}

xmlDocPtr xmlRecoverDoc(const xmlChar *cur)
{
  return xmlSAXParseDoc(0, cur, 1);
}

xmlDocPtr xmlSAXParseDoc(xmlSAXHandlerPtr sax, const xmlChar *cur, int recovery)
{
  if (!cur) {
    return 0;
  }
  int v6 = xmlStrlen(cur);
  xmlParserCtxtPtr MemoryParserCtxt = xmlCreateMemoryParserCtxt((const char *)cur, v6);
  if (!MemoryParserCtxt) {
    return 0;
  }
  xmlParserCtxtPtr v8 = MemoryParserCtxt;
  if (sax)
  {
    xmlParserCtxtPtr v9 = MemoryParserCtxt->sax;
    MemoryParserCtxt->sax = sax;
    MemoryParserCtxt->userData = 0;
  }
  else
  {
    xmlParserCtxtPtr v9 = 0;
  }
  xmlDetectSAX2((const xmlChar *)MemoryParserCtxt);
  xmlParseDocument(v8);
  xmlDocPtr myDoc = v8->myDoc;
  if (!(v8->wellFormed | recovery))
  {
    xmlFreeDoc(v8->myDoc);
    xmlDocPtr myDoc = 0;
    v8->xmlDocPtr myDoc = 0;
  }
  if (sax) {
    v8->sax = v9;
  }
  xmlFreeParserCtxt(v8);
  return myDoc;
}

xmlDocPtr xmlParseFile(const char *filename)
{
  return xmlSAXParseFileWithData(0, filename, 0, 0);
}

xmlDocPtr xmlRecoverFile(const char *filename)
{
  return xmlSAXParseFileWithData(0, filename, 1, 0);
}

void xmlSetupParserForBuffer(xmlParserCtxtPtr ctxt, const xmlChar *buffer, const char *filename)
{
  if (ctxt && buffer)
  {
    xmlParserInputPtr v6 = xmlNewInputStream(ctxt);
    if (v6)
    {
      xmlParserCtxtPtr v7 = v6;
      xmlClearParserCtxt(ctxt);
      if (filename) {
        v7->filename = (const char *)xmlCanonicPath((const xmlChar *)filename);
      }
      v7->unint64_t base = buffer;
      v7->xmlNodePtr cur = buffer;
      v7->end = &buffer[xmlStrlen(buffer)];
      inputPush(ctxt, v7);
    }
    else
    {
      htmlErrMemory(0, (const xmlChar *)"parsing new buffer: out of memory\n");
      xmlClearParserCtxt(ctxt);
    }
  }
}

int xmlSAXUserParseFile(xmlSAXHandlerPtr sax, void *user_data, const char *filename)
{
  xmlParserCtxtPtr URLParserCtxt = xmlCreateURLParserCtxt(filename, 0);
  if (!URLParserCtxt) {
    return -1;
  }
  xmlParserInputPtr v6 = URLParserCtxt;
  xmlParserCtxtPtr v7 = (xmlSAXHandlerV1 *)URLParserCtxt->sax;
  if (v7 != __xmlDefaultSAXHandler()) {
    xmlFree(v6->sax);
  }
  v6->sax = sax;
  xmlDetectSAX2((const xmlChar *)v6);
  if (user_data) {
    v6->userData = user_data;
  }
  xmlParseDocument(v6);
  if (v6->wellFormed)
  {
    int errNo = 0;
    if (sax) {
LABEL_8:
    }
      v6->sax = 0;
  }
  else
  {
    if (v6->errNo) {
      int errNo = v6->errNo;
    }
    else {
      int errNo = -1;
    }
    if (sax) {
      goto LABEL_8;
    }
  }
  xmlDocPtr myDoc = v6->myDoc;
  if (myDoc)
  {
    xmlFreeDoc(myDoc);
    v6->xmlDocPtr myDoc = 0;
  }
  xmlFreeParserCtxt(v6);
  return errNo;
}

xmlDocPtr xmlSAXParseMemory(xmlSAXHandlerPtr sax, const char *buffer, int size, int recovery)
{
  return xmlSAXParseMemoryWithData(sax, buffer, size, recovery, 0);
}

xmlDocPtr xmlRecoverMemory(const char *buffer, int size)
{
  return xmlSAXParseMemoryWithData(0, buffer, size, 1, 0);
}

int xmlSAXUserParseMemory(xmlSAXHandlerPtr sax, void *user_data, const char *buffer, int size)
{
  xmlInitParser();
  xmlParserCtxtPtr MemoryParserCtxt = xmlCreateMemoryParserCtxt(buffer, size);
  if (!MemoryParserCtxt) {
    return -1;
  }
  xmlParserCtxtPtr v9 = MemoryParserCtxt;
  xmlElementType v10 = (xmlSAXHandlerV1 *)MemoryParserCtxt->sax;
  if (v10 != __xmlDefaultSAXHandler()) {
    xmlFree(v9->sax);
  }
  v9->sax = sax;
  xmlDetectSAX2((const xmlChar *)v9);
  if (user_data) {
    v9->userData = user_data;
  }
  xmlParseDocument(v9);
  if (v9->wellFormed)
  {
    int errNo = 0;
    if (sax) {
LABEL_8:
    }
      v9->sax = 0;
  }
  else
  {
    if (v9->errNo) {
      int errNo = v9->errNo;
    }
    else {
      int errNo = -1;
    }
    if (sax) {
      goto LABEL_8;
    }
  }
  xmlDocPtr myDoc = v9->myDoc;
  if (myDoc)
  {
    xmlFreeDoc(myDoc);
    v9->xmlDocPtr myDoc = 0;
  }
  xmlFreeParserCtxt(v9);
  return errNo;
}

xmlParserCtxtPtr xmlCreateDocParserCtxt(xmlParserCtxtPtr cur)
{
  if (cur)
  {
    int v1 = (const char *)cur;
    int v2 = xmlStrlen((const xmlChar *)cur);
    return xmlCreateMemoryParserCtxt(v1, v2);
  }
  return cur;
}

xmlDocPtr xmlParseDoc(const xmlChar *cur)
{
  return xmlSAXParseDoc(0, cur, 0);
}

void xmlSetEntityReferenceFunc(xmlEntityReferenceFunc func)
{
  xmlEntityRefFunc = func;
}

void xmlCleanupParser(void)
{
  if (xmlParserInitialized == 1)
  {
    xmlCleanupCharEncodingHandlers();
    xmlCatalogCleanup();
    xmlDictCleanup();
    xmlCleanupInputCallbacks();
    xmlCleanupOutputCallbacks();
    xmlSchemaCleanupTypes();
    xmlRelaxNGCleanupTypes();
    xmlResetLastError();
    xmlCleanupGlobals();
    xmlCleanupThreads();
    xmlCleanupMemory();
    xmlParserInitialized = 0;
  }
}

void xmlCtxtReset(xmlParserCtxtPtr ctxt)
{
  if (!ctxt) {
    return;
  }
  dict = ctxt->dict;
  int inputNr = ctxt->inputNr;
  if (inputNr >= 1)
  {
    do
    {
      inputTab = ctxt->inputTab;
      int v5 = inputNr - 1;
      ctxt->int inputNr = inputNr - 1;
      if (inputNr == 1) {
        xmlParserInputPtr v6 = 0;
      }
      else {
        xmlParserInputPtr v6 = inputTab[inputNr - 2];
      }
      ctxt->xmlParserInputPtr input = v6;
      xmlParserCtxtPtr v7 = inputTab[v5];
      inputTab[v5] = 0;
      if (!v7) {
        break;
      }
      xmlFreeInputStream(v7);
      int inputNr = ctxt->inputNr;
    }
    while (inputNr > 0);
  }
  ctxt->int inputNr = 0;
  ctxt->xmlParserInputPtr input = 0;
  ctxt->int spaceNr = 0;
  spaceTab = ctxt->spaceTab;
  if (spaceTab) {
    int *spaceTab = -1;
  }
  ctxt->space = spaceTab;
  ctxt->nodeNr = 0;
  ctxt->xmlNodePtr node = 0;
  ctxt->int nameNr = 0;
  ctxt->name = 0;
  ctxt->nsNr = 0;
  version = (xmlChar *)ctxt->version;
  if (version)
  {
    if (dict)
    {
      if (xmlDictOwns(dict, version)) {
        goto LABEL_15;
      }
      version = (xmlChar *)ctxt->version;
    }
    xmlFree(version);
  }
LABEL_15:
  ctxt->version = 0;
  encoding = (xmlChar *)ctxt->encoding;
  if (!encoding) {
    goto LABEL_20;
  }
  if (dict)
  {
    if (xmlDictOwns(dict, encoding)) {
      goto LABEL_20;
    }
    encoding = (xmlChar *)ctxt->encoding;
  }
  xmlFree(encoding);
LABEL_20:
  ctxt->encoding = 0;
  directory = ctxt->directory;
  if (!directory) {
    goto LABEL_25;
  }
  if (dict)
  {
    if (xmlDictOwns(dict, (const xmlChar *)directory)) {
      goto LABEL_25;
    }
    directory = ctxt->directory;
  }
  xmlFree(directory);
LABEL_25:
  ctxt->directory = 0;
  extSubxmlURIPtr URI = ctxt->extSubURI;
  if (!extSubURI) {
    goto LABEL_30;
  }
  if (dict)
  {
    if (xmlDictOwns(dict, extSubURI)) {
      goto LABEL_30;
    }
    extSubxmlURIPtr URI = ctxt->extSubURI;
  }
  xmlFree(extSubURI);
LABEL_30:
  ctxt->extSubxmlURIPtr URI = 0;
  extSubSystem = ctxt->extSubSystem;
  if (extSubSystem)
  {
    if (!dict)
    {
LABEL_34:
      xmlFree(extSubSystem);
      goto LABEL_35;
    }
    if (!xmlDictOwns(dict, extSubSystem))
    {
      extSubSystem = ctxt->extSubSystem;
      goto LABEL_34;
    }
  }
LABEL_35:
  ctxt->extSubSystem = 0;
  xmlDocPtr myDoc = ctxt->myDoc;
  if (myDoc) {
    xmlFreeDoc(myDoc);
  }
  ctxt->xmlDocPtr myDoc = 0;
  *(void *)&ctxt->standalone = 0xFFFFFFFFLL;
  *(void *)&ctxt->xmlParserInputState instate = 0;
  ctxt->int wellFormed = 1;
  ctxt->nsWellFormed = 1;
  *(void *)&ctxt->disableSAX = 0;
  ctxt->valint id = 1;
  ctxt->record_xmlParserNodeInfo info = 0;
  ctxt->checkIndex = 0;
  *(void *)&ctxt->int errNo = 0;
  *(void *)&ctxt->hasPErefs = 0;
  ctxt->int depth = 0;
  ctxt->charset = 1;
  ctxt->catalogs = 0;
  ctxt->sizeentcopy = 0;
  *(_OWORD *)&ctxt->unint64_t nbentities = 0u;
  xmlInitNodeInfoSeq(&ctxt->node_seq);
  attsDefault = ctxt->attsDefault;
  if (attsDefault)
  {
    xmlHashFree(attsDefault, xmlHashDefaultDeallocator);
    ctxt->attsDefault = 0;
  }
  attsSpecial = ctxt->attsSpecial;
  if (attsSpecial)
  {
    xmlHashFree(attsSpecial, 0);
    ctxt->attsSpecial = 0;
  }
  catalogs = ctxt->catalogs;
  if (catalogs) {
    xmlCatalogFreeLocal(catalogs);
  }
  if (ctxt->lastError.code)
  {
    xmlResetError(&ctxt->lastError);
  }
}

int xmlCtxtResetPush(xmlParserCtxtPtr ctxt, const char *chunk, int size, const char *filename, const char *encoding)
{
  if (!ctxt) {
    return 1;
  }
  xmlCharEncoding v10 = XML_CHAR_ENCODING_NONE;
  if (chunk && size >= 4 && !encoding) {
    xmlCharEncoding v10 = xmlDetectCharEncoding((const unsigned __int8 *)chunk, size);
  }
  xmlParserInputBufferPtr v11 = xmlAllocParserInputBuffer(v10);
  if (!v11) {
    return 1;
  }
  xmlParserInputBufferPtr v12 = v11;
  xmlCtxtReset(ctxt);
  if (filename)
  {
    ctxt->directory = xmlParserGetDirectory(filename);
    xmlParserInputPtr v13 = xmlNewInputStream(ctxt);
    if (v13)
    {
      xmlCharEncoding v14 = v13;
      int v15 = xmlCanonicPath((const xmlChar *)filename);
      goto LABEL_13;
    }
    goto LABEL_23;
  }
  ctxt->directory = 0;
  xmlParserInputPtr v17 = xmlNewInputStream(ctxt);
  if (!v17)
  {
LABEL_23:
    xmlFreeParserInputBuffer(v12);
    return 1;
  }
  xmlCharEncoding v14 = v17;
  int v15 = 0;
LABEL_13:
  v14->xmlParserInputBufferPtr buf = v12;
  v14->filename = (const char *)v15;
  xmlBufResetInput((uint64_t *)v12->buffer, v14);
  inputPush(ctxt, v14);
  if (chunk)
  {
    if (size >= 1)
    {
      xmlParserInputPtr input = ctxt->input;
      if (input)
      {
        if (input->buf)
        {
          unint64_t InputBase = xmlBufGetInputBase((uint64_t)input->buf->buffer, (uint64_t)input);
          xmlParserInputPtr v20 = ctxt->input;
          uint64_t v21 = v20->cur - v20->base;
          xmlParserInputBufferPush(v20->buf, size, chunk);
          xmlBufSetInputBaseCur((uint64_t *)ctxt->input->buf->buffer, &ctxt->input->buf, InputBase, v21);
        }
      }
    }
  }
  if (encoding)
  {
    xmlNodePtr v22 = (xmlChar *)ctxt->encoding;
    if (v22) {
      xmlFree(v22);
    }
    ctxt->encoding = xmlStrdup((const xmlChar *)encoding);
    xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler(encoding);
    if (CharEncodingHandler) {
      xmlSwitchToEncoding(ctxt, CharEncodingHandler);
    }
    else {
      xmlFatalErrMsgStr(ctxt, 32, "Unsupported encoding %s\n", (const xmlChar *)encoding);
    }
  }
  else if (v10)
  {
    xmlSwitchEncoding(ctxt, v10);
  }
  return 0;
}

xmlDocPtr xmlReadDoc(const xmlChar *cur, const char *URL, const char *encoding, int options)
{
  if (!cur) {
    return 0;
  }
  uint64_t v4 = *(void *)&options;
  xmlInitParser();
  int v8 = xmlStrlen(cur);
  xmlParserCtxtPtr MemoryParserCtxt = xmlCreateMemoryParserCtxt((const char *)cur, v8);
  if (!MemoryParserCtxt) {
    return 0;
  }

  return xmlDoRead(MemoryParserCtxt, (const xmlChar *)URL, (xmlChar *)encoding, v4, 0);
}

xmlDocPtr xmlReadFile(const char *URL, const char *encoding, int options)
{
  uint64_t v3 = *(void *)&options;
  xmlInitParser();
  xmlDocPtr result = (xmlDocPtr)xmlCreateURLParserCtxt(URL, v3);
  if (result)
  {
    return xmlDoRead((xmlParserCtxt *)result, 0, (xmlChar *)encoding, v3, 0);
  }
  return result;
}

xmlDocPtr xmlReadFd(int fd, const char *URL, const char *encoding, int options)
{
  if (fd < 0) {
    return 0;
  }
  uint64_t v4 = *(void *)&options;
  xmlInitParser();
  xmlParserInputBufferPtr v8 = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
  if (!v8) {
    return 0;
  }
  xmlParserCtxtPtr v9 = v8;
  v8->closecallbacuint64_t k = 0;
  xmlCharEncoding v10 = xmlNewParserCtxt();
  if (!v10)
  {
    xmlFreeParserInputBuffer(v9);
    return 0;
  }
  xmlParserInputBufferPtr v11 = v10;
  xmlParserInputBufferPtr v12 = xmlNewIOInputStream(v10, v9, XML_CHAR_ENCODING_NONE);
  if (!v12)
  {
    xmlFreeParserInputBuffer(v9);
    xmlFreeParserCtxt(v11);
    return 0;
  }
  inputPush(v11, v12);

  return xmlDoRead(v11, (const xmlChar *)URL, (xmlChar *)encoding, v4, 0);
}

xmlDocPtr xmlReadIO(xmlInputReadCallback ioread, xmlInputCloseCallback ioclose, void *ioctx, const char *URL, const char *encoding, int options)
{
  if (!ioread) {
    return 0;
  }
  uint64_t v6 = *(void *)&options;
  xmlInitParser();
  xmlParserInputBufferPtr IO = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, XML_CHAR_ENCODING_NONE);
  if (!IO)
  {
    if (ioclose) {
      ((void (*)(void *))ioclose)(ioctx);
    }
    return 0;
  }
  xmlParserInputPtr v13 = IO;
  xmlCharEncoding v14 = xmlNewParserCtxt();
  if (!v14)
  {
    xmlFreeParserInputBuffer(v13);
    return 0;
  }
  int v15 = v14;
  xmlCharEncoding v16 = xmlNewIOInputStream(v14, v13, XML_CHAR_ENCODING_NONE);
  if (!v16)
  {
    xmlFreeParserInputBuffer(v13);
    xmlFreeParserCtxt(v15);
    return 0;
  }
  inputPush(v15, v16);

  return xmlDoRead(v15, (const xmlChar *)URL, (xmlChar *)encoding, v6, 0);
}

xmlDocPtr xmlCtxtReadDoc(xmlParserCtxtPtr ctxt, const xmlChar *cur, const char *URL, const char *encoding, int options)
{
  if (!ctxt) {
    return 0;
  }
  if (!cur) {
    return 0;
  }
  uint64_t v6 = *(void *)&options;
  xmlInitParser();
  xmlCtxtReset(ctxt);
  xmlCharEncoding v10 = xmlNewStringInputStream(ctxt, cur);
  if (!v10) {
    return 0;
  }
  inputPush(ctxt, v10);

  return xmlDoRead(ctxt, (const xmlChar *)URL, (xmlChar *)encoding, v6, 1);
}

xmlDocPtr xmlCtxtReadFile(xmlParserCtxtPtr ctxt, const char *filename, const char *encoding, int options)
{
  if (!ctxt) {
    return 0;
  }
  if (!filename) {
    return 0;
  }
  uint64_t v5 = *(void *)&options;
  xmlInitParser();
  xmlCtxtReset(ctxt);
  ExternalxmlEntityPtr Entity = xmlLoadExternalEntity(filename, 0, ctxt);
  if (!ExternalEntity) {
    return 0;
  }
  inputPush(ctxt, ExternalEntity);

  return xmlDoRead(ctxt, 0, (xmlChar *)encoding, v5, 1);
}

xmlDocPtr xmlCtxtReadMemory(xmlParserCtxtPtr ctxt, const char *buffer, int size, const char *URL, const char *encoding, int options)
{
  if (!ctxt) {
    return 0;
  }
  if (!buffer) {
    return 0;
  }
  uint64_t v7 = *(void *)&options;
  xmlInitParser();
  xmlCtxtReset(ctxt);
  xmlParserInputBufferPtr Mem = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
  if (!Mem) {
    return 0;
  }
  xmlParserInputPtr v13 = Mem;
  xmlCharEncoding v14 = xmlNewIOInputStream(ctxt, Mem, XML_CHAR_ENCODING_NONE);
  if (!v14)
  {
    xmlFreeParserInputBuffer(v13);
    return 0;
  }
  inputPush(ctxt, v14);

  return xmlDoRead(ctxt, (const xmlChar *)URL, (xmlChar *)encoding, v7, 1);
}

xmlDocPtr xmlCtxtReadFd(xmlParserCtxtPtr ctxt, int fd, const char *URL, const char *encoding, int options)
{
  if (!ctxt) {
    return 0;
  }
  if (fd < 0) {
    return 0;
  }
  uint64_t v6 = *(void *)&options;
  xmlInitParser();
  xmlCtxtReset(ctxt);
  xmlParserInputBufferPtr v10 = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
  if (!v10) {
    return 0;
  }
  xmlParserInputBufferPtr v11 = v10;
  v10->closecallbacuint64_t k = 0;
  xmlParserInputBufferPtr v12 = xmlNewIOInputStream(ctxt, v10, XML_CHAR_ENCODING_NONE);
  if (!v12)
  {
    xmlFreeParserInputBuffer(v11);
    return 0;
  }
  inputPush(ctxt, v12);

  return xmlDoRead(ctxt, (const xmlChar *)URL, (xmlChar *)encoding, v6, 1);
}

xmlDocPtr xmlCtxtReadIO(xmlParserCtxtPtr ctxt, xmlInputReadCallback ioread, xmlInputCloseCallback ioclose, void *ioctx, const char *URL, const char *encoding, int options)
{
  if (!ctxt || !ioread) {
    return 0;
  }
  uint64_t v8 = *(void *)&options;
  xmlInitParser();
  xmlCtxtReset(ctxt);
  xmlParserInputBufferPtr IO = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, XML_CHAR_ENCODING_NONE);
  if (!IO)
  {
    if (ioclose) {
      ((void (*)(void *))ioclose)(ioctx);
    }
    return 0;
  }
  int v15 = IO;
  xmlCharEncoding v16 = xmlNewIOInputStream(ctxt, IO, XML_CHAR_ENCODING_NONE);
  if (!v16)
  {
    xmlFreeParserInputBuffer(v15);
    return 0;
  }
  inputPush(ctxt, v16);

  return xmlDoRead(ctxt, (const xmlChar *)URL, (xmlChar *)encoding, v8, 1);
}

__n128 xmlIsNameStartChar(uint64_t a1, signed int val)
{
  if ((*(unsigned char *)(a1 + 566) & 2) != 0)
  {
    if (val > 255) {
      xmlCharInRange(val, &xmlIsBaseCharGroup);
    }
  }
  else if ((val > 0x3E || ((1 << val) & 0x4000800100000000) == 0) {
         && (val & 0xFFFFFFDF) - 65 >= 0x1A
  }
         && val != 58
         && val != 95)
  {
    int32x4_t v3 = vdupq_n_s32(val);
    result.n128_u8[0] = vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)xmmword_1B51A8110, (uint32x4_t)vaddq_s32(v3, (int32x4_t)xmmword_1B51A80F0)), (int16x8_t)vcgtq_u32((uint32x4_t)xmmword_1B51A8120, (uint32x4_t)vaddq_s32(v3, (int32x4_t)xmmword_1B51A8100)))));
  }
  return result;
}

_DWORD *xmlNsWarn(_DWORD *result, const char *a2, const xmlChar *a3, xmlChar *a4)
{
  if (!result || !result[83] || result[68] != -1) {
    return __xmlRaiseError(0, 0, 0, result, 0, 3u, 100, 1, 0, 0, a3, a4, 0, 0, 0, a2, (char)a3);
  }
  return result;
}

uint64_t xmlCleanSpecialAttrCallback(uint64_t result, uint64_t a2, xmlChar *name, xmlChar *name2)
{
  if (result == 1) {
    return xmlHashRemoveEntry2(*(xmlHashTablePtr *)(a2 + 552), name, name2, 0);
  }
  return result;
}

uint64_t xmlCheckCdataPush(uint64_t a1, int a2, int a3)
{
  uint64_t result = 0;
  if (a1 && a2 >= 1)
  {
    LODWORD(result) = 0;
    do
    {
      uint64_t v5 = (int)result;
      unsigned int v6 = *(unsigned __int8 *)(a1 + (int)result);
      if (*(char *)(a1 + (int)result) < 0)
      {
        if ((v6 & 0xE0) == 0xC0)
        {
          uint64_t result = (result + 2);
          if ((int)result > a2) {
            goto LABEL_50;
          }
          char v10 = *(unsigned char *)(v5 + a1 + 1);
          if ((v10 & 0xC0) != 0x80) {
            return -(int)v5;
          }
          unsigned int v11 = v10 & 0x3F | ((v6 & 0x1F) << 6);
          if (v11 <= 0x1F && (v11 > 0xD || ((1 << v11) & 0x2600) == 0)) {
            return -(int)v5;
          }
        }
        else if ((v6 & 0xF0) == 0xE0)
        {
          uint64_t result = (result + 3);
          if ((int)result > a2) {
            goto LABEL_50;
          }
          char v13 = *(unsigned char *)(v5 + a1 + 1);
          if ((v13 & 0xC0) != 0x80) {
            return -(int)v5;
          }
          char v14 = *(unsigned char *)(v5 + a1 + 2);
          if ((v14 & 0xC0) != 0x80) {
            return -(int)v5;
          }
          unsigned int v15 = ((v6 & 0xF) << 12) | ((v13 & 0x3F) << 6) | v14 & 0x3F;
          if (v15 <= 0xFF)
          {
            if (v15 > 0x1F) {
              continue;
            }
            if (v15 > 0xD) {
              return -(int)v5;
            }
            int v16 = 1 << v15;
            goto LABEL_40;
          }
          if (v15 >> 11 >= 0x1B && (v15 - 57344) >> 1 >= 0xFFF) {
            return -(int)v5;
          }
        }
        else
        {
          if ((v6 & 0xF8) != 0xF0) {
            return -(int)v5;
          }
          uint64_t result = (result + 4);
          if ((int)result > a2)
          {
LABEL_50:
            if (a3) {
              return -(int)v5;
            }
            else {
              return v5;
            }
          }
          char v17 = *(unsigned char *)(v5 + a1 + 1);
          if ((v17 & 0xC0) != 0x80) {
            return -(int)v5;
          }
          char v18 = *(unsigned char *)(v5 + a1 + 2);
          if ((v18 & 0xC0) != 0x80) {
            return -(int)v5;
          }
          char v19 = *(unsigned char *)(v5 + a1 + 3);
          if ((v19 & 0xC0) != 0x80) {
            return -(int)v5;
          }
          int v20 = ((v6 & 7) << 18) | ((v17 & 0x3F) << 12);
          unsigned int v21 = v19 & 0x3F | ((v18 & 0x3F) << 6) | v20;
          if (v21 <= 0xFF)
          {
            if (v21 > 0x1F) {
              continue;
            }
            if (v21 > 0xD) {
              return -(int)v5;
            }
            int v16 = 1 << v21;
LABEL_40:
            if ((v16 & 0x2600) == 0) {
              return -(int)v5;
            }
            continue;
          }
          if (v21 >> 11 >= 0x1B && (v21 - 57344) >> 1 >= 0xFFF && (v20 - 0x10000) >= 0x100000) {
            return -(int)v5;
          }
        }
      }
      else
      {
        if (v6 < 0x20)
        {
          BOOL v7 = v6 > 0xD;
          int v8 = (1 << v6) & 0x2600;
          if (v7 || v8 == 0) {
            return -(int)v5;
          }
        }
        uint64_t result = (result + 1);
      }
    }
    while ((int)result < a2);
  }
  return result;
}

void xmlCheckVersion(int version)
{
  xmlInitParser();
  if ((version - 20000) >> 4 >= 0x271)
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    int32x4_t v3 = __xmlGenericErrorContext();
    v2(*v3, "Fatal: program compiled against libxml %d using libxml %d\n", version / 10000, 2);
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "Fatal: program compiled against libxml %d using libxml %d\n", version / 10000, 2);
  }
  if (version >= 21000)
  {
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    uint64_t v5 = __xmlGenericErrorContext();
    v4(*v5, "Warning: program compiled against libxml %d using older %d\n", version / 0x64u, 209);
  }
}

_DWORD *__xmlErrEncoding(_DWORD *result, int a2, const char *a3, const xmlChar *a4, xmlChar *a5)
{
  if (!result) {
    return __xmlRaiseError(0, 0, 0, 0, 0, 1u, a2, 3, 0, 0, a4, a5, 0, 0, 0, a3, (char)a4);
  }
  uint64_t v5 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    uint64_t result = __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 3, 0, 0, a4, a5, 0, 0, 0, a3, (char)a4);
    v5[6] = 0;
    if (!v5[112]) {
      v5[83] = 1;
    }
  }
  return result;
}

int xmlIsLetter(int c)
{
  if (c > 255)
  {
    return xmlCharInRange(c, &xmlIsBaseCharGroup)
        || c == 12295
        || (c - 19968) < 0x51A6
        || (c - 12321) < 9;
  }
  else
  {
    unsigned int v2 = c - 192;
    int result = 1;
    if (v2 >= 0x17 && (c & 0xFFFFFFDF) - 65 >= 0x1A && c <= 247) {
      return (c - 216) < 0x1F;
    }
  }
  return result;
}

void xmlHaltParser(xmlParserCtxtPtr ctxt)
{
  if (ctxt)
  {
    ctxt->xmlParserInputState instate = XML_PARSER_EOF;
    ctxt->disableSAX = 1;
    if (ctxt->inputNr >= 2)
    {
      do
      {
        unsigned int v2 = inputPop(ctxt);
        xmlFreeInputStream(v2);
      }
      while (ctxt->inputNr > 1);
    }
    xmlParserInputPtr input = ctxt->input;
    if (input)
    {
      xmlParserInputDeallocate free = (void (*)(const xmlChar *))input->free;
      if (free)
      {
        free(input->base);
        xmlParserInputPtr input = ctxt->input;
        input->xmlParserInputDeallocate free = 0;
      }
      if (input->buf)
      {
        xmlFreeParserInputBuffer(input->buf);
        xmlParserInputPtr input = ctxt->input;
        input->xmlParserInputBufferPtr buf = 0;
      }
      input->size_t length = 0;
      input->unint64_t base = (const xmlChar *)"";
      input->xmlNodePtr cur = (const xmlChar *)"";
      input->end = (const xmlChar *)"";
    }
  }
}

int xmlParserInputRead(xmlParserInputPtr in, int len)
{
  return -1;
}

_DWORD *xmlErrInternal(_DWORD *result, const char *a2, const xmlChar *a3)
{
  if (!result) {
    return __xmlRaiseError(0, 0, 0, 0, 0, 1u, 1, 3, 0, 0, a3, 0, 0, 0, 0, a2, (char)a3);
  }
  int32x4_t v3 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = 1;
    int result = __xmlRaiseError(0, 0, 0, result, 0, 1u, 1, 3, 0, 0, a3, 0, 0, 0, 0, a2, (char)a3);
    v3[6] = 0;
    if (!v3[112]) {
      v3[83] = 1;
    }
  }
  return result;
}

_DWORD *xmlErrEncodingInt(_DWORD *result, const char *a2, int a3)
{
  if (!result) {
    return __xmlRaiseError(0, 0, 0, 0, 0, 1u, 9, 3, 0, 0, 0, 0, 0, a3, 0, a2, a3);
  }
  int32x4_t v3 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = 9;
    int result = __xmlRaiseError(0, 0, 0, result, 0, 1u, 9, 3, 0, 0, 0, 0, 0, a3, 0, a2, a3);
    v3[6] = 0;
    if (!v3[112]) {
      v3[83] = 1;
    }
  }
  return result;
}

int xmlStringCurrentChar(xmlParserCtxtPtr ctxt, const xmlChar *cur, int *len)
{
  unsigned int v3 = 0;
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!cur || !len) {
    return v3;
  }
  if (ctxt && ctxt->charset != 1 || (*(char *)cur & 0x80000000) == 0)
  {
LABEL_6:
    *int len = 1;
    return *cur;
  }
  int v8 = cur + 1;
  if ((cur[1] & 0xC0) != 0x80) {
    goto LABEL_34;
  }
  int v9 = *cur;
  if ((~v9 & 0xE0) != 0)
  {
    *int len = 2;
    unsigned int v15 = (*cur & 0x1F) << 6;
    goto LABEL_23;
  }
  int v8 = cur + 2;
  if ((cur[2] & 0xC0) != 0x80) {
    goto LABEL_34;
  }
  if ((~v9 & 0xF0) != 0)
  {
    *int len = 3;
    int v10 = (*cur & 0xF) << 12;
    xmlChar v11 = cur[1];
    goto LABEL_22;
  }
  if ((v9 & 0xF8) != 0xF0 || (int v8 = cur + 3, (cur[3] & 0xC0) != 0x80))
  {
LABEL_34:
    if (!ctxt
      || (xmlParserInputPtr input = ctxt->input) == 0
      || (p_cur = &input->cur, char v13 = (unsigned __int8 *)input->cur, p_cur[1] - v13 <= 3))
    {
      unsigned int v3 = 0;
      *int len = 0;
      return v3;
    }
    long long v23 = 0u;
    memset(v24, 0, sizeof(v24));
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    *(_OWORD *)__str = 0u;
    snprintf(__str, 0x95uLL, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n", *v13, v13[1], v13[2], v13[3]);
    __xmlErrEncoding(ctxt, 9, "Input is not proper UTF-8, indicate encoding !\n%s", (const xmlChar *)__str, 0);
    goto LABEL_6;
  }
  *int len = 4;
  int v10 = ((*cur & 7) << 18) | ((cur[1] & 0x3F) << 12);
  xmlChar v11 = cur[2];
LABEL_22:
  unsigned int v15 = v10 & 0xFFFFF03F | ((v11 & 0x3F) << 6);
LABEL_23:
  unsigned int v3 = v15 | *v8 & 0x3F;
  if (v3 > 0xFF)
  {
    if (v3 >> 11 >= 0x1B && (v3 - 57344) >> 1 >= 0xFFF && v3 - 0x10000 >= 0x100000) {
      goto LABEL_31;
    }
  }
  else if (v3 <= 0x1F && (v3 > 0xD || ((1 << v3) & 0x2600) == 0))
  {
LABEL_31:
    xmlErrEncodingInt(ctxt, "Char 0x%X out of allowed range\n", v3);
  }
  return v3;
}

uint64_t xmlSwitchToEncodingInt(xmlParserCtxt *a1, xmlCharEncodingHandler *handler, int a3)
{
  if (handler)
  {
    xmlParserInputPtr input = (uint64_t *)a1->input;
    if (input)
    {
      uint64_t result = xmlSwitchInputEncodingInt(a1, input, handler, a3);
      a1->charset = 1;
      return result;
    }
    xmlErrInternal(a1, "xmlSwitchToEncoding : no input\n", 0);
  }
  return 0xFFFFFFFFLL;
}

int xmlSwitchInputEncoding(xmlParserCtxtPtr ctxt, xmlParserInputPtr input, xmlCharEncodingHandlerPtr handler)
{
  return xmlSwitchInputEncodingInt(ctxt, (uint64_t *)input, handler, -1);
}

uint64_t xmlSwitchInputEncodingInt(xmlParserCtxt *a1, uint64_t *a2, xmlCharEncodingHandler *handler, int a4)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 && handler)
  {
    uint64_t v8 = *a2;
    if (*a2)
    {
      int v9 = *(xmlCharEncodingHandler **)(v8 + 24);
      if (v9)
      {
        if (v9 != handler)
        {
          xmlCharEncCloseFunc(v9);
          uint64_t result = 0;
          *(void *)(*a2 + 24) = handler;
          return result;
        }
        return 0;
      }
      *(void *)(v8 + 24) = handler;
      if (xmlBufIsEmpty(*(void *)(v8 + 32))) {
        return 0;
      }
      xmlChar v11 = xmlBufCreate();
      if (v11)
      {
        xmlParserInputBufferPtr v12 = v11;
        name = handler->name;
        if (name)
        {
          if (!strcmp(name, "UTF-16LE") || !strcmp(name, "UTF-16"))
          {
            char v14 = (unsigned __int8 *)a2[4];
            if (*v14 == 255 && v14[1] == 254) {
              a2[4] = (uint64_t)(v14 + 2);
            }
          }
          if (!strcmp(name, "UTF-16BE"))
          {
            unsigned int v15 = (unsigned __int8 *)a2[4];
            if (*v15 == 254 && v15[1] == 255) {
              a2[4] = (uint64_t)(v15 + 2);
            }
          }
          if (!strcmp(name, "UTF-8"))
          {
            int v16 = (unsigned __int8 *)a2[4];
            if (*v16 == 239 && v16[1] == 187 && v16[2] == 191) {
              a2[4] = (uint64_t)(v16 + 3);
            }
          }
        }
        size_t v17 = *((_DWORD *)a2 + 8) - *((_DWORD *)a2 + 6);
        xmlBufShrink(*(xmlBufPtr *)(*a2 + 32), v17);
        long long v18 = (void *)*a2;
        long long v19 = *(xmlBuf **)(*a2 + 32);
        v18[4] = v12;
        v18[5] = v19;
        v18[7] = v17;
        unsigned int v20 = xmlBufUse(v19);
        uint64_t v21 = *a2;
        if (a1->html) {
          int LineInput = xmlCharEncInput(v21, 1);
        }
        else {
          int LineInput = xmlCharEncFirstLineInput(v21, a4);
        }
        int v23 = LineInput;
        xmlBufResetInput(*(uint64_t **)(*a2 + 32), a2);
        if ((v23 & 0x80000000) == 0)
        {
          size_t v24 = xmlBufUse(*(const xmlBufPtr *)(*a2 + 40));
          uint64_t result = 0;
          *(void *)(*a2 + 56) = *(void *)(*a2 + 56) - v24 + v20;
          return result;
        }
        if (!a1->html)
        {
          xmlErrInternal(a1, "switching encoding: encoder error\n", 0);
          xmlHaltParser(a1);
        }
      }
      else
      {
        htmlErrMemory(a1, 0);
      }
    }
    else
    {
      if (*((_DWORD *)a2 + 12))
      {
        xmlCharEncCloseFunc(handler);
        return 0;
      }
      xmlErrInternal(a1, "switching encoding : no input\n", 0);
      xmlCharEncCloseFunc(handler);
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

int xmlSwitchToEncoding(xmlParserCtxtPtr ctxt, xmlCharEncodingHandlerPtr handler)
{
  return xmlSwitchToEncodingInt(ctxt, handler, -1);
}

xmlParserInputPtr xmlNewIOInputStream(xmlParserCtxtPtr ctxt, xmlParserInputBufferPtr input, xmlCharEncoding enc)
{
  if (!input) {
    return 0;
  }
  if (*__xmlParserDebugEntities())
  {
    xmlGenericErrorFunc v6 = *__xmlGenericError();
    BOOL v7 = __xmlGenericErrorContext();
    v6(*v7, "new input from I/O\n");
  }
  xmlParserInputPtr v8 = xmlNewInputStream(ctxt);
  int v9 = v8;
  if (v8)
  {
    v8->xmlParserInputBufferPtr buf = input;
    v8->filename = 0;
    xmlBufResetInput((uint64_t *)input->buffer, v8);
    if (enc) {
      xmlSwitchEncoding(ctxt, enc);
    }
  }
  return v9;
}

xmlParserInputPtr xmlNewEntityInputStream(xmlParserCtxtPtr ctxt, xmlEntityPtr entity)
{
  unsigned int v2 = ctxt;
  if (!entity)
  {
    int v10 = "xmlNewEntityInputStream entity = NULL\n";
    name = 0;
LABEL_21:
    xmlErrInternal(ctxt, v10, name);
    return 0;
  }
  if (*__xmlParserDebugEntities())
  {
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    uint64_t v5 = __xmlGenericErrorContext();
    v4(*v5, "new input from entity: %s\n", (const char *)entity->name);
  }
  if (!entity->content)
  {
    switch(entity->etype)
    {
      case XML_INTERNAL_GENERAL_ENTITY:
        name = entity->name;
        int v10 = "Internal entity %s without content !\n";
        goto LABEL_20;
      case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
      case XML_EXTERNAL_PARAMETER_ENTITY:
        xmlURIPtr URI = (const char *)entity->URI;
        ExternalID = (const char *)entity->ExternalID;
        return xmlLoadExternalEntity(URI, ExternalID, v2);
      case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
        name = entity->name;
        int v10 = "Cannot parse entity %s\n";
        goto LABEL_20;
      case XML_INTERNAL_PARAMETER_ENTITY:
        name = entity->name;
        int v10 = "Internal parameter entity %s without content !\n";
        goto LABEL_20;
      case XML_INTERNAL_PREDEFINED_ENTITY:
        name = entity->name;
        int v10 = "Predefined entity %s without content !\n";
LABEL_20:
        ctxt = v2;
        break;
      default:
        return 0;
    }
    goto LABEL_21;
  }
  xmlParserInputPtr v6 = xmlNewInputStream(v2);
  if (v6)
  {
    BOOL v7 = entity->URI;
    if (v7) {
      v6->filename = (const char *)xmlStrdup(v7);
    }
    content = entity->content;
    v6->unint64_t base = content;
    int length = entity->length;
    if (!length)
    {
      int length = xmlStrlen(content);
      entity->int length = length;
      content = entity->content;
    }
    v6->int length = length;
    v6->xmlNodePtr cur = content;
    v6->end = &content[length];
  }
  return v6;
}

xmlParserInputPtr xmlNewStringInputStream(xmlParserCtxtPtr ctxt, const xmlChar *buffer)
{
  if (buffer)
  {
    if (*__xmlParserDebugEntities())
    {
      xmlGenericErrorFunc v4 = *__xmlGenericError();
      uint64_t v5 = __xmlGenericErrorContext();
      v4(*v5, "new fixed input: %.30s\n", (const char *)buffer);
    }
    xmlParserInputPtr v6 = xmlNewInputStream(ctxt);
    BOOL v7 = v6;
    if (v6)
    {
      v6->unint64_t base = buffer;
      v6->xmlNodePtr cur = buffer;
      int v8 = xmlStrlen(buffer);
      v7->int length = v8;
      v7->end = &buffer[v8];
    }
    else
    {
      htmlErrMemory(ctxt, (const xmlChar *)"couldn't allocate a new input stream\n");
    }
  }
  else
  {
    xmlErrInternal(ctxt, "xmlNewStringInputStream string = NULL\n", 0);
    return 0;
  }
  return v7;
}

xmlParserInputPtr xmlNewInputFromFile(xmlParserCtxtPtr ctxt, const char *filename)
{
  if (*__xmlParserDebugEntities())
  {
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    uint64_t v5 = __xmlGenericErrorContext();
    v4(*v5, "new input from file: %s\n", filename);
  }
  if (!ctxt) {
    return 0;
  }
  xmlParserInputBufferPtr v6 = xmlParserInputBufferCreateFilename(filename, XML_CHAR_ENCODING_NONE);
  if (!v6)
  {
    if (filename)
    {
      unsigned int v15 = "failed to load external entity \"%s\"\n";
      xmlParserCtxtPtr v16 = ctxt;
      size_t v17 = filename;
    }
    else
    {
      unsigned int v15 = "failed to load external entity: NULL filename \n";
      xmlParserCtxtPtr v16 = ctxt;
      size_t v17 = 0;
    }
    __xmlLoaderErr(v16, v15, (const xmlChar *)v17);
    return 0;
  }
  BOOL v7 = v6;
  xmlParserInputPtr v8 = xmlNewInputStream(ctxt);
  if (!v8)
  {
    xmlFreeParserInputBuffer(v7);
    return 0;
  }
  v8->xmlParserInputBufferPtr buf = v7;
  xmlParserInputPtr v9 = xmlCheckHTTPInput(ctxt, v8);
  int v10 = v9;
  if (v9)
  {
    xmlChar v11 = v9->filename;
    if (!v11) {
      xmlChar v11 = filename;
    }
    xmlParserInputBufferPtr v12 = xmlStrdup((const xmlChar *)v11);
    Directory = xmlParserGetDirectory((const char *)v12);
    char v14 = (char *)v10->filename;
    if (v14) {
      xmlFree(v14);
    }
    v10->filename = (const char *)xmlCanonicPath(v12);
    if (v12) {
      xmlFree(v12);
    }
    v10->directory = Directory;
    xmlBufResetInput((uint64_t *)v10->buf->buffer, v10);
    if (!ctxt->directory && Directory) {
      ctxt->directory = (char *)xmlStrdup((const xmlChar *)Directory);
    }
  }
  return v10;
}

void xmlClearParserCtxt(xmlParserCtxtPtr ctxt)
{
  if (ctxt)
  {
    p_node_seq = &ctxt->node_seq;
    xmlBufPtr buffer = ctxt->node_seq.buffer;
    if (buffer) {
      xmlFree(buffer);
    }
    p_node_seq->maximum = 0;
    p_node_seq->int length = 0;
    p_node_seq->xmlBufPtr buffer = 0;
    xmlCtxtReset(ctxt);
  }
}

void xmlClearNodeInfoSeq(xmlParserNodeInfoSeqPtr seq)
{
  if (seq)
  {
    xmlBufPtr buffer = seq->buffer;
    if (buffer) {
      xmlFree(buffer);
    }
    seq->maximum = 0;
    seq->int length = 0;
    seq->xmlBufPtr buffer = 0;
  }
}

const xmlParserNodeInfo *__cdecl xmlParserFindNodeInfo(const xmlParserCtxtPtr ctxt, const xmlNodePtr node)
{
  uint64_t result = 0;
  if (ctxt)
  {
    if (node)
    {
      unint64_t NodeInfoIndex = xmlParserFindNodeInfoIndex(&ctxt->node_seq, node);
      if (NodeInfoIndex >= ctxt->node_seq.length) {
        return 0;
      }
      uint64_t result = &ctxt->node_seq.buffer[NodeInfoIndex];
      if (result->node != node) {
        return 0;
      }
    }
  }
  return result;
}

unint64_t xmlParserFindNodeInfoIndex(const xmlParserNodeInfoSeqPtr seq, const xmlNodePtr node)
{
  unint64_t length = -1;
  if (seq)
  {
    if (node)
    {
      unint64_t length = seq->length;
      if (length)
      {
        unint64_t v3 = 1;
        do
        {
          unint64_t v4 = v3 + ((length - v3) >> 1);
          uint64_t v5 = seq->buffer[v4 - 1].node;
          if (v5 > node) {
            unint64_t length = v4 - 1;
          }
          if (v5 < node) {
            unint64_t v3 = v4 + 1;
          }
        }
        while (v3 <= length && v5 != node);
        if (v4)
        {
          if (seq->buffer[v4 - 1].node >= node) {
            return v4 - 1;
          }
          else {
            return v4;
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return length;
}

void xmlParserAddNodeInfo(xmlParserCtxtPtr ctxt, const xmlParserNodeInfoPtr info)
{
  if (!ctxt || !info) {
    return;
  }
  p_node_seq = &ctxt->node_seq;
  xmlNodePtr node = info->node;
  unint64_t NodeInfoIndex = xmlParserFindNodeInfoIndex(&ctxt->node_seq, (const xmlNodePtr)info->node);
  unint64_t v7 = NodeInfoIndex;
  unint64_t length = ctxt->node_seq.length;
  if (NodeInfoIndex < length)
  {
    xmlBufPtr buffer = ctxt->node_seq.buffer;
    if (buffer)
    {
      int v10 = &buffer[NodeInfoIndex];
      if (v10->node == node)
      {
        long long v20 = *(_OWORD *)&info->node;
        long long v21 = *(_OWORD *)&info->begin_line;
        v10->end_unint64_t line = info->end_line;
        *(_OWORD *)&v10->xmlNodePtr node = v20;
        *(_OWORD *)&v10->begin_unint64_t line = v21;
        return;
      }
    }
  }
  unint64_t maximum = p_node_seq->maximum;
  if (length + 1 <= p_node_seq->maximum)
  {
    xmlParserInputBufferPtr v12 = ctxt->node_seq.buffer;
    if (v12) {
      goto LABEL_13;
    }
  }
  if (!maximum)
  {
    LODWORD(maximum) = 2;
    p_node_seq->unint64_t maximum = 2;
  }
  char v13 = ctxt->node_seq.buffer;
  if (v13)
  {
    xmlParserInputBufferPtr v12 = (xmlParserNodeInfo *)xmlRealloc(v13, (80 * maximum));
    if (v12)
    {
LABEL_12:
      ctxt->node_seq.xmlBufPtr buffer = v12;
      unint64_t length = ctxt->node_seq.length;
      ctxt->node_seq.maximum *= 2;
LABEL_13:
      if (length > v7)
      {
        unint64_t v14 = length;
        do
        {
          unsigned int v15 = &ctxt->node_seq.buffer[v14];
          --length;
          long long v16 = *(_OWORD *)&v15[-1].begin_line;
          *(_OWORD *)&v15->xmlNodePtr node = *(_OWORD *)&v15[-1].node;
          *(_OWORD *)&v15->begin_unint64_t line = v16;
          v15->end_unint64_t line = v15[-1].end_line;
          --v14;
        }
        while (length > v7);
        xmlParserInputBufferPtr v12 = ctxt->node_seq.buffer;
      }
      size_t v17 = &v12[v7];
      long long v18 = *(_OWORD *)&info->node;
      long long v19 = *(_OWORD *)&info->begin_line;
      v17->end_unint64_t line = info->end_line;
      *(_OWORD *)&v17->xmlNodePtr node = v18;
      *(_OWORD *)&v17->begin_unint64_t line = v19;
      ++ctxt->node_seq.length;
      return;
    }
  }
  else
  {
    xmlParserInputBufferPtr v12 = (xmlParserNodeInfo *)xmlMalloc((80 * maximum));
    if (v12) {
      goto LABEL_12;
    }
  }

  htmlErrMemory(ctxt, (const xmlChar *)"failed to allocate buffer\n");
}

int xmlPedanticParserDefault(int val)
{
  int v2 = *__xmlPedanticParserDefaultValue();
  *__xmlPedanticParserDefaultValue() = val;
  return v2;
}

int xmlLineNumbersDefault(int val)
{
  int v2 = *__xmlLineNumbersDefaultValue();
  *__xmlLineNumbersDefaultValue() = val;
  return v2;
}

int xmlSubstituteEntitiesDefault(int val)
{
  int v2 = *__xmlSubstituteEntitiesDefaultValue();
  *__xmlSubstituteEntitiesDefaultValue() = val;
  return v2;
}

int xmlKeepBlanksDefault(int val)
{
  int v2 = *__xmlKeepBlanksDefaultValue();
  *__xmlKeepBlanksDefaultValue() = val;
  if (!val) {
    *__xmlIndentTreeOutput() = 1;
  }
  return v2;
}

void xmlFreePatternList(xmlPatternPtr comp)
{
  if (comp)
  {
    xmlPatternPtr v1 = comp;
    do
    {
      int v2 = (xmlPattern *)*((void *)v1 + 2);
      *((void *)v1 + 2) = 0;
      uint64_t v3 = *((void *)v1 + 7);
      if (v3) {
        xmlFreeStreamComp(v3);
      }
      unint64_t v4 = (void *)*((void *)v1 + 3);
      if (v4) {
        xmlFree(v4);
      }
      uint64_t v5 = (void *)*((void *)v1 + 6);
      if (v5)
      {
        if (!*((void *)v1 + 1) && *((int *)v1 + 9) >= 1)
        {
          uint64_t v6 = 0;
          uint64_t v7 = 0;
          do
          {
            uint64_t v8 = *((void *)v1 + 6) + v6;
            xmlParserInputPtr v9 = *(void **)(v8 + 8);
            if (v9) {
              xmlFree(v9);
            }
            int v10 = *(void **)(v8 + 16);
            if (v10) {
              xmlFree(v10);
            }
            ++v7;
            v6 += 24;
          }
          while (v7 < *((int *)v1 + 9));
          uint64_t v5 = (void *)*((void *)v1 + 6);
        }
        xmlFree(v5);
      }
      xmlChar v11 = (xmlDict *)*((void *)v1 + 1);
      if (v11) {
        xmlDictFree(v11);
      }
      *(void *)&long long v12 = -1;
      *((void *)&v12 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = -1;
      *((_OWORD *)v1 + 2) = v12;
      *((_OWORD *)v1 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = v12;
      *(_OWORD *)xmlPatternPtr v1 = v12;
      *((_OWORD *)v1 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v12;
      xmlFree(v1);
      xmlPatternPtr v1 = v2;
    }
    while (v2);
  }
}

void xmlFreeStreamCtxt(xmlStreamCtxtPtr stream)
{
  if (stream)
  {
    xmlStreamCtxtPtr v1 = stream;
    do
    {
      int v2 = *(xmlStreamCtxt **)v1;
      uint64_t v3 = (void *)*((void *)v1 + 4);
      if (v3) {
        xmlFree(v3);
      }
      xmlFree(v1);
      xmlStreamCtxtPtr v1 = v2;
    }
    while (v2);
  }
}

int xmlStreamPush(xmlStreamCtxtPtr stream, const xmlChar *name, const xmlChar *ns)
{
  return xmlStreamPushInternal((uint64_t)stream, (xmlChar *)name, (xmlChar *)ns, 1);
}

uint64_t xmlStreamPushInternal(uint64_t a1, xmlChar *a2, xmlChar *a3, int a4)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = a1;
  uint64_t v5 = 0xFFFFFFFFLL;
  if ((*(_DWORD *)(a1 + 16) & 0x80000000) == 0)
  {
    uint64_t v7 = a3;
    uint64_t v8 = a2;
    int v9 = 0;
    uint64_t v10 = 0;
    if (a2) {
      BOOL v11 = 0;
    }
    else {
      BOOL v11 = a4 == 1;
    }
    int v13 = v11 && a3 == 0;
    unsigned int v64 = a4 - 3;
    while (1)
    {
      uint64_t v14 = 0;
      uint64_t v15 = v10;
      uint64_t v16 = v4;
      while (1)
      {
        uint64_t v17 = *(void *)(v16 + 8);
        if (v13) {
          break;
        }
        if (*(_DWORD *)(v17 + 8))
        {
          if (*(_DWORD *)(v16 + 44) != -1 || v64 <= 0xFFFFFFFD && (*(unsigned char *)(v17 + 25) & 0x40) == 0)
          {
LABEL_79:
            ++*(_DWORD *)(v16 + 24);
            goto LABEL_17;
          }
          unsigned int v60 = v10;
          int v61 = v9;
          str2 = v8;
          uint64_t v63 = v7;
          int v19 = *(_DWORD *)(v16 + 16);
          if (v19 >= 1)
          {
            int v20 = 0;
            int v21 = *(_DWORD *)(v17 + 24);
            do
            {
              uint64_t v22 = *(void *)(v16 + 32);
              if ((v21 & 0x10000) != 0)
              {
                uint64_t v25 = *(unsigned int *)(v22 + 8 * v20);
                if ((v25 & 0x80000000) != 0) {
                  goto LABEL_67;
                }
                int v34 = *(_DWORD *)(v22 + ((8 * v20) | 4));
                int v24 = *(_DWORD *)(v16 + 24);
                if (v34 > v24) {
                  goto LABEL_67;
                }
                uint64_t v26 = *(void *)(v17 + 16);
                if (v34 < v24 && (*(_DWORD *)(v26 + 32 * v25) & 1) == 0) {
                  goto LABEL_67;
                }
              }
              else
              {
                int v23 = 2 * *(_DWORD *)(v16 + 16);
                int v24 = *(_DWORD *)(v16 + 24);
                if (*(_DWORD *)(v22 + 4 * (v23 - 1)) < v24) {
                  return 0xFFFFFFFFLL;
                }
                LODWORD(v25) = *(_DWORD *)(v22 + 4 * (v23 - 2));
                uint64_t v26 = *(void *)(v17 + 16);
                int v20 = v19;
              }
              int v27 = (int *)(v26 + 32 * (int)v25);
              unsigned int v28 = *v27;
              int v29 = v27[6];
              if (v29 == a4)
              {
                if (a4 != 100)
                {
                  xmlParserInputPtr v30 = (const xmlChar *)*((void *)v27 + 1);
                  int v31 = (const xmlChar *)*((void *)v27 + 2);
                  if (v30)
                  {
                    int v32 = 1;
                    if (!str2 || (v63 != 0) == (v31 == 0)) {
                      goto LABEL_60;
                    }
                    if (*v30 != *str2) {
                      goto LABEL_59;
                    }
                    unsigned int v56 = v14;
                    unsigned int v57 = v15;
                    if (!xmlStrEqual(v30, str2))
                    {
                      int v32 = 1;
                      uint64_t v14 = v56;
                      uint64_t v15 = v57;
                      goto LABEL_60;
                    }
                    LODWORD(v15) = v57;
                    if (v31 != v63)
                    {
                      int v33 = xmlStrEqual(v31, v63);
                      uint64_t v14 = v56;
                      uint64_t v15 = v57;
                      if (!v33) {
                        goto LABEL_59;
                      }
                    }
                  }
                  else if (v31)
                  {
                    if (!v63) {
                      goto LABEL_59;
                    }
                    unsigned int v58 = v15;
                    uint64_t v36 = v14;
                    int v37 = xmlStrEqual(*((const xmlChar **)v27 + 2), v63);
                    uint64_t v15 = v58;
                    if (!v37)
                    {
                      uint64_t v14 = v36;
LABEL_59:
                      int v32 = 1;
                      goto LABEL_60;
                    }
                  }
                }
              }
              else if (v29 != 100)
              {
                if (v29 != 2 || (v21 & 0x10000) != 0) {
                  goto LABEL_67;
                }
LABEL_65:
                *(_DWORD *)(v16 + 44) = v24 + 1;
                goto LABEL_67;
              }
              if ((v28 & 2) != 0)
              {
                int v32 = 0;
                uint64_t v14 = v28 & 2;
                uint64_t v15 = 1;
              }
              else
              {
                int v38 = v25 + 1;
                int v39 = v15;
                xmlStreamCtxtAddState(v16, v38, *(_DWORD *)(v16 + 24) + 1);
                int v32 = 0;
                if (v39 == 1) {
                  uint64_t v15 = 1;
                }
                else {
                  uint64_t v15 = (v28 >> 5) & 1;
                }
                uint64_t v14 = 0;
              }
LABEL_60:
              int v21 = *(_DWORD *)(v17 + 24);
              if ((v21 & 0x10000) == 0)
              {
                if (v14) {
                  int v32 = 1;
                }
                if (v32 != 1)
                {
                  uint64_t v14 = 0;
                  goto LABEL_67;
                }
                int v24 = *(_DWORD *)(v16 + 24);
                goto LABEL_65;
              }
LABEL_67:
              ++v20;
            }
            while (v20 < v19);
          }
          int v40 = *(_DWORD *)(v16 + 24);
          *(_DWORD *)(v16 + 24) = v40 + 1;
          xmlNodePtr v41 = *(int **)(v17 + 16);
          unsigned int v42 = *v41;
          if ((*v41 & 4) != 0)
          {
            int v9 = v61;
            uint64_t v7 = v63;
          }
          else
          {
            xmlNodePtr v43 = (const xmlChar *)*((void *)v41 + 1);
            int v44 = (const xmlChar *)*((void *)v41 + 2);
            int v45 = v41[6];
            int v46 = *(_DWORD *)(v16 + 40);
            uint64_t v7 = v63;
            if ((v46 & 7) != 0)
            {
              if (v40)
              {
                if ((v42 & 1) == 0 && (v40 != 1 || (v46 & 6) == 0)) {
                  goto LABEL_96;
                }
              }
              else if ((v46 & 6) != 0)
              {
                goto LABEL_96;
              }
            }
            if (v45 == a4)
            {
              if (a4 == 100) {
                goto LABEL_94;
              }
              if (v43)
              {
                if (!str2
                  || (v63 != 0) == (v44 == 0)
                  || *v43 != *str2
                  || (v47 = v15, v48 = xmlStrEqual(v43, str2), uint64_t v15 = v47, !v48)
                  || v44 != v63 && (v49 = xmlStrEqual(v44, v63), uint64_t v15 = v47, !v49))
                {
LABEL_105:
                  uint64_t v14 = v42 & 2;
                  int v50 = 1;
                  goto LABEL_106;
                }
LABEL_94:
                uint64_t v14 = v42 & 2;
                if ((v42 & 2) != 0)
                {
LABEL_95:
                  int v50 = 0;
                  uint64_t v15 = 1;
                  goto LABEL_106;
                }
LABEL_102:
                int v52 = v15;
                xmlStreamCtxtAddState(v16, 1, *(_DWORD *)(v16 + 24));
                int v50 = 0;
                uint64_t v14 = 0;
                if (v52 == 1) {
                  uint64_t v15 = 1;
                }
                else {
                  uint64_t v15 = (v42 >> 5) & 1;
                }
LABEL_106:
                uint64_t v10 = v60;
                int v9 = v61;
                uint64_t v8 = str2;
              }
              else
              {
                if (!v44) {
                  goto LABEL_94;
                }
                if (!v63) {
                  goto LABEL_105;
                }
                unsigned int v59 = v15;
                int v51 = xmlStrEqual(v44, v63);
                uint64_t v14 = v42 & 2;
                if (v51)
                {
                  LODWORD(v15) = v59;
                  if ((v42 & 2) != 0) {
                    goto LABEL_95;
                  }
                  goto LABEL_102;
                }
                int v50 = 1;
                uint64_t v10 = v60;
                int v9 = v61;
                uint64_t v8 = str2;
                uint64_t v15 = v59;
              }
              if ((*(unsigned char *)(v17 + 26) & 1) == 0)
              {
                if (((v14 == 0) & ~v50) != 0) {
                  uint64_t v14 = 0;
                }
                else {
                  *(_DWORD *)(v16 + 44) = *(_DWORD *)(v16 + 24);
                }
              }
              goto LABEL_17;
            }
            if (a4 != 2 && v45 == 100) {
              goto LABEL_94;
            }
LABEL_96:
            int v9 = v61;
          }
          uint64_t v8 = str2;
          uint64_t v10 = v60;
          goto LABEL_17;
        }
        int v18 = *(_DWORD *)(v16 + 40);
        if ((v18 & 1) == 0)
        {
          if (a4 != 2 && ((v18 & 7) == 0 || !*(_DWORD *)(v16 + 24))) {
            uint64_t v15 = 1;
          }
          goto LABEL_79;
        }
LABEL_17:
        uint64_t v16 = *(void *)v16;
        if (!v16)
        {
          LODWORD(v10) = v15;
LABEL_124:
          if (v9 > 0) {
            return 0xFFFFFFFFLL;
          }
          else {
            return v10;
          }
        }
      }
      *(_DWORD *)(v4 + 16) = 0;
      *(_DWORD *)(v4 + 24) = 0;
      *(_DWORD *)(v4 + 44) = -1;
      if ((*(unsigned char *)(v17 + 25) & 0x80) != 0)
      {
        int v53 = *(_DWORD *)(v17 + 8);
        if (v53)
        {
          if (v53 != 1)
          {
            uint64_t v54 = *(void *)(v17 + 16);
LABEL_119:
            if ((*(unsigned char *)v54 & 4) != 0) {
              v9 += xmlStreamCtxtAddState(v4, 0, 0) >> 31;
            }
            goto LABEL_121;
          }
          uint64_t v54 = *(void *)(v17 + 16);
          if (*(_DWORD *)(v54 + 24) != 100 || (*(unsigned char *)v54 & 1) == 0) {
            goto LABEL_119;
          }
        }
        uint64_t v10 = 1;
      }
LABEL_121:
      uint64_t v4 = *(void *)v4;
      if (!v4) {
        goto LABEL_124;
      }
    }
  }
  return v5;
}

int xmlStreamPushAttr(xmlStreamCtxtPtr stream, const xmlChar *name, const xmlChar *ns)
{
  return xmlStreamPushInternal((uint64_t)stream, (xmlChar *)name, (xmlChar *)ns, 2);
}

int xmlStreamPop(xmlStreamCtxtPtr stream)
{
  int result = -1;
  if (stream)
  {
    do
    {
      int v3 = *((_DWORD *)stream + 6);
      if (*((_DWORD *)stream + 11) == v3) {
        *((_DWORD *)stream + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = -1;
      }
      if (v3) {
        *((_DWORD *)stream + 6) = --v3;
      }
      uint64_t v4 = *((unsigned int *)stream + 4);
      if ((int)v4 >= 1)
      {
        uint64_t v5 = *((void *)stream + 4);
        int v6 = v4 - 1;
        unint64_t v7 = v4 + 1;
        int v8 = 2 * v4 - 2;
        do
        {
          if (*(_DWORD *)(v5 + 4 * (v8 & 0xFFFFFFFE) + 4) <= v3) {
            break;
          }
          *((_DWORD *)stream + 4) = v6--;
          --v7;
          v8 -= 2;
        }
        while (v7 > 1);
      }
      stream = *(xmlStreamCtxtPtr *)stream;
    }
    while (stream);
    return 0;
  }
  return result;
}

int xmlStreamWantsAnyNode(xmlStreamCtxtPtr stream)
{
  if (stream)
  {
    while ((*(unsigned char *)(*((void *)stream + 1) + 25) & 0x40) == 0)
    {
      stream = *(xmlStreamCtxtPtr *)stream;
      if (!stream) {
        return (int)stream;
      }
    }
    LODWORD(stream) = 1;
  }
  else
  {
    LODWORD(stream) = -1;
  }
  return (int)stream;
}

xmlPatternPtr xmlPatterncompile(const xmlChar *pattern, xmlDict *dict, int flags, const xmlChar **namespaces)
{
  if (!pattern) {
    return 0;
  }
  uint64_t v4 = (xmlChar *)pattern;
  unsigned int v5 = *pattern;
  if (!*pattern) {
    return 0;
  }
  unint64_t v7 = 0;
  int v97 = flags & 6;
  int v98 = 0;
  int v95 = flags | 0x100;
  int v96 = flags | 0x200;
  int v94 = flags & 7;
  BOOL v101 = 1;
  do
  {
    uint64_t v8 = 0;
    int v9 = v7;
    if (v5)
    {
      while (v5 != 124)
      {
        unsigned int v5 = v4[++v8];
        if (!v5) {
          goto LABEL_7;
        }
      }
      long long v12 = xmlStrndup(v4, v8);
      BOOL v11 = v12;
      if (v12) {
        uint64_t v10 = xmlNewPatParserContext(v12, (uint64_t)dict, (uint64_t *)namespaces);
      }
      else {
        uint64_t v10 = 0;
      }
      v4 += v8 + 1;
      if (!v10) {
        goto LABEL_239;
      }
    }
    else
    {
LABEL_7:
      uint64_t v10 = xmlNewPatParserContext(v4, (uint64_t)dict, (uint64_t *)namespaces);
      BOOL v11 = 0;
      v4 += v8;
      if (!v10) {
        goto LABEL_239;
      }
    }
    int v13 = xmlMalloc(0x40uLL);
    if (!v13) {
      goto LABEL_238;
    }
    uint64_t v14 = (uint64_t)v13;
    v13[2] = 0u;
    v13[3] = 0u;
    *int v13 = 0u;
    v13[1] = 0u;
    *((_DWORD *)v13 + 10) = 10;
    uint64_t v15 = xmlMalloc(0xF0uLL);
    *(void *)(v14 + 48) = v15;
    if (!v15)
    {
      xmlFree((void *)v14);
      goto LABEL_238;
    }
    if (dict)
    {
      *(void *)(v14 + 8) = dict;
      xmlDictReference(dict);
    }
    unint64_t v7 = (xmlPattern *)v14;
    if (v9)
    {
      *(void *)(v14 + 16) = *((void *)v9 + 2);
      *((void *)v9 + 2) = v14;
      unint64_t v7 = v9;
    }
    *(_DWORD *)(v14 + 32) = flags;
    *((void *)v10 + 4) = v14;
    uint64_t v16 = *(unsigned char **)v10;
    if (v97)
    {
      for (uint64_t i = v16 + 1; ; ++i)
      {
        uint64_t v18 = *v16;
        if (v18 > 0x2F) {
          break;
        }
        if (((1 << v18) & 0x100002600) == 0)
        {
          if (v18 == 47) {
            goto LABEL_107;
          }
          break;
        }
        *(void *)uint64_t v10 = ++v16;
      }
      *(_DWORD *)(v14 + 32) = v96;
      if (*v16 == 46)
      {
        while (1)
        {
          *(void *)uint64_t v10 = i;
          uint64_t v19 = *i;
          if (v19 > 0x2F) {
            break;
          }
          if (((1 << v19) & 0x100002600) == 0)
          {
            if (*i)
            {
              if (v19 != 47) {
                break;
              }
              while (1)
              {
                *(void *)uint64_t v10 = ++i;
                uint64_t v23 = *i;
                if (v23 > 0x2F) {
                  break;
                }
                if (((1 << v23) & 0x100002600) == 0)
                {
                  if (v23 != 47) {
                    break;
                  }
                  unsigned int v24 = *(i - 1);
                  BOOL v25 = v24 > 0x20;
                  uint64_t v26 = (1 << v24) & 0x100002600;
                  BOOL v27 = v25 || v26 == 0;
                  if (!v27 || xmlPatternAdd(v14, 6, 0, 0)) {
                    goto LABEL_107;
                  }
                  unsigned int v28 = *(unsigned __int8 **)v10;
                  if (**(unsigned char **)v10) {
                    goto LABEL_103;
                  }
                  while (1)
                  {
                    LODWORD(v2xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = *v28;
                    if (v23 > 0x20 || ((1 << v23) & 0x100002600) == 0) {
                      goto LABEL_82;
                    }
LABEL_103:
                    *(void *)uint64_t v10 = ++v28;
                  }
                }
              }
LABEL_82:
              if (!v23) {
                break;
              }
              goto LABEL_83;
            }
            if (xmlPatternAdd(v14, 2, 0, 0)) {
              break;
            }
            goto LABEL_109;
          }
          ++i;
        }
      }
      else
      {
LABEL_83:
        xmlCompileStepPattern((uint64_t *)v10);
        uint64_t v36 = v10 + 1;
        if (!*((_DWORD *)v10 + 4))
        {
LABEL_91:
          for (j = *(unsigned __int8 **)v10; ; *(void *)uint64_t v10 = j)
          {
            uint64_t v40 = *j++;
            if (v40 > 0x2F) {
              break;
            }
            if (((1 << v40) & 0x100002600) == 0)
            {
              if (!*(j - 1)) {
                goto LABEL_109;
              }
              if (v40 != 47) {
                goto LABEL_108;
              }
              if (xmlPatternAdd(*((void *)v10 + 4), 5, 0, 0)) {
                goto LABEL_107;
              }
              int v37 = *(unsigned char **)v10;
              if (**(unsigned char **)v10) {
                goto LABEL_85;
              }
              while (1)
              {
                uint64_t v38 = *v37;
                if (v38 > 0x2F) {
                  goto LABEL_100;
                }
                if (((1 << v38) & 0x100002600) == 0) {
                  break;
                }
LABEL_85:
                *(void *)uint64_t v10 = ++v37;
              }
              if (!*v37 || v38 == 47) {
                goto LABEL_107;
              }
LABEL_100:
              xmlCompileStepPattern((uint64_t *)v10);
              if (!*((_DWORD *)v10 + 4)) {
                goto LABEL_91;
              }
              goto LABEL_107;
            }
          }
          goto LABEL_108;
        }
      }
LABEL_107:
      uint64_t v36 = v10 + 1;
LABEL_108:
      _DWORD *v36 = 1;
      goto LABEL_109;
    }
    for (uint64_t k = v16 + 1; ; ++k)
    {
      uint64_t v21 = *(k - 1);
      if (v21 > 0x2F) {
        break;
      }
      if (((1 << v21) & 0x100002600) == 0)
      {
        if (v21 == 46)
        {
          int v22 = v96;
          goto LABEL_51;
        }
        int v22 = v95;
        if (v21 == 47) {
          goto LABEL_51;
        }
        break;
      }
      *(void *)uint64_t v10 = k;
    }
    int v22 = v96;
    if (!v94) {
      goto LABEL_52;
    }
LABEL_51:
    *(_DWORD *)(v14 + 32) = v22;
    LODWORD(v2htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = *(k - 1);
LABEL_52:
    if (v21 == 46)
    {
      if (*k != 47 || k[1] != 47) {
        goto LABEL_207;
      }
      if (xmlPatternAdd(v14, 6, 0, 0)) {
        goto LABEL_109;
      }
      xmlParserInputPtr v30 = *(unsigned __int8 **)v10;
      if (**(unsigned char **)v10)
      {
        int v31 = v30 + 1;
        *(void *)uint64_t v10 = v30 + 1;
        if (v30[1])
        {
          int v31 = v30 + 2;
          *(void *)uint64_t v10 = v30 + 2;
          if (v30[2])
          {
            v30 += 3;
            goto LABEL_197;
          }
        }
        xmlParserInputPtr v30 = v31;
      }
      while (1)
      {
        LODWORD(v2htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = *v30;
        if (v21 > 0x20) {
          goto LABEL_67;
        }
        if (((1 << v21) & 0x100002600) == 0) {
          break;
        }
        ++v30;
LABEL_197:
        *(void *)uint64_t v10 = v30;
      }
      if (!*v30) {
        goto LABEL_107;
      }
    }
    else if (v21 == 47)
    {
      uint64_t v29 = v14;
      if (*k != 47) {
        goto LABEL_70;
      }
      if (xmlPatternAdd(v14, 6, 0, 0)) {
        goto LABEL_109;
      }
      uint64_t v21 = *(void *)v10;
      if (!**(unsigned char **)v10) {
        goto LABEL_207;
      }
      *(void *)uint64_t v10 = v21 + 1;
      if (!*(unsigned char *)(v21 + 1)) {
        goto LABEL_207;
      }
      xmlParserInputPtr v30 = (unsigned __int8 *)(v21 + 2);
      *(void *)uint64_t v10 = v21 + 2;
      LODWORD(v2htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = *(unsigned __int8 *)(v21 + 2);
    }
    else
    {
      xmlParserInputPtr v30 = k - 1;
    }
LABEL_67:
    if (v21 != 64)
    {
      if (v21 == 47)
      {
        uint64_t v29 = *((void *)v10 + 4);
LABEL_70:
        if (xmlPatternAdd(v29, 1, 0, 0)) {
          goto LABEL_109;
        }
        int v32 = *(unsigned char **)v10;
        if (**(unsigned char **)v10) {
          goto LABEL_203;
        }
        while (1)
        {
          unsigned int v80 = *v32;
          if (v80 > 0x20) {
            goto LABEL_207;
          }
          if (((1 << v80) & 0x100002600) == 0) {
            break;
          }
LABEL_203:
          *(void *)uint64_t v10 = ++v32;
        }
        if (!*v32) {
          goto LABEL_107;
        }
      }
LABEL_207:
      xmlCompileStepPattern((uint64_t *)v10);
      uint64_t v36 = v10 + 1;
      if (*((_DWORD *)v10 + 4)) {
        goto LABEL_109;
      }
      for (m = *(unsigned __int8 **)v10; ; *(void *)uint64_t v10 = m)
      {
        uint64_t v35 = *m;
        if (v35 > 0x2F) {
          goto LABEL_234;
        }
        if (((1 << v35) & 0x100002600) == 0) {
          break;
        }
        ++m;
      }
      if (v35 == 47)
      {
        while (1)
        {
          uint64_t v82 = *((void *)v10 + 4);
          if (m[1] == 47)
          {
            if (xmlPatternAdd(v82, 6, 0, 0)) {
              goto LABEL_109;
            }
            unsigned int v83 = *(unsigned __int8 **)v10;
            if (**(unsigned char **)v10)
            {
              *(void *)uint64_t v10 = v83 + 1;
              if (v83[1])
              {
                v83 += 2;
                goto LABEL_222;
              }
              ++v83;
            }
            while (1)
            {
              unsigned int v85 = *v83;
              BOOL v25 = v85 > 0x20;
              uint64_t v86 = (1 << v85) & 0x100002600;
              if (v25 || v86 == 0) {
                break;
              }
              ++v83;
LABEL_222:
              *(void *)uint64_t v10 = v83;
            }
            goto LABEL_232;
          }
          if (xmlPatternAdd(v82, 5, 0, 0)) {
            goto LABEL_109;
          }
          xmlChar v84 = *(unsigned char **)v10;
          if (**(unsigned char **)v10) {
LABEL_228:
          }
            *(void *)uint64_t v10 = ++v84;
          unsigned int v88 = *v84;
          if (v88 <= 0x20)
          {
            if (((1 << v88) & 0x100002600) == 0)
            {
              if (!*v84) {
                goto LABEL_108;
              }
              goto LABEL_232;
            }
            goto LABEL_228;
          }
LABEL_232:
          xmlCompileStepPattern((uint64_t *)v10);
          if (*((_DWORD *)v10 + 4)) {
            goto LABEL_109;
          }
          m = *(unsigned __int8 **)v10;
          LODWORD(v35) = **(unsigned __int8 **)v10;
          if (v35 != 47) {
            goto LABEL_234;
          }
        }
      }
      goto LABEL_234;
    }
    *(void *)uint64_t v10 = v30 + 1;
    xmlCompileAttributeTest((uint64_t *)v10);
    for (n = *(unsigned __int8 **)v10; ; *(void *)uint64_t v10 = n)
    {
      unsigned int v34 = *n++;
      if (v34 > 0x20) {
        break;
      }
      if (((1 << v34) & 0x100002600) == 0)
      {
        if (!*(n - 1)) {
          goto LABEL_109;
        }
        break;
      }
    }
    xmlCompileStepPattern((uint64_t *)v10);
    if (*((_DWORD *)v10 + 4)) {
      goto LABEL_109;
    }
    LODWORD(v35) = **(unsigned __int8 **)v10;
LABEL_234:
    if (v35) {
      goto LABEL_107;
    }
LABEL_109:
    if (*((_DWORD *)v10 + 4))
    {
      int v9 = v7;
LABEL_238:
      *(void *)&long long v89 = -1;
      *((void *)&v89 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = -1;
      void v10[2] = v89;
      v10[3] = v89;
      *uint64_t v10 = v89;
      v10[1] = v89;
      xmlFree(v10);
LABEL_239:
      unint64_t v7 = v9;
      if (v9) {
LABEL_240:
      }
        xmlFreePatternList(v7);
      if (v11) {
        xmlFree(v11);
      }
      return 0;
    }
    *(void *)&long long v41 = -1;
    *((void *)&v41 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = -1;
    void v10[2] = v41;
    v10[3] = v41;
    *uint64_t v10 = v41;
    v10[1] = v41;
    xmlFree(v10);
    if (v101)
    {
      if (v98 == 512)
      {
        int v61 = *(_DWORD *)(v14 + 32);
        BOOL v101 = !(v61 & 0x100);
        int v98 = 512;
        if ((v61 & 0x100) != 0) {
          goto LABEL_168;
        }
      }
      else if (v98 == 256)
      {
        BOOL v101 = (*(_DWORD *)(v14 + 32) & 0x200) == 0;
        int v98 = 256;
        if ((*(_DWORD *)(v14 + 32) & 0x200) != 0) {
          goto LABEL_168;
        }
      }
      else
      {
        if (!v98) {
          int v98 = *(_DWORD *)(v14 + 32) & 0x300;
        }
        BOOL v101 = 1;
      }
      uint64_t v42 = *(void *)(v14 + 48);
      if (v42)
      {
        int v43 = *(_DWORD *)(v14 + 36);
        if (v43 == 1 && *(_DWORD *)v42 == 2 && !*(void *)(v42 + 8) && !*(void *)(v42 + 16))
        {
          int v79 = xmlNewStreamComp(0);
          if (v79)
          {
            *((_DWORD *)v79 + 6) |= 0x4000u;
            *(void *)(v14 + 56) = v79;
          }
        }
        else
        {
          int v44 = xmlNewStreamComp(v43 / 2 + 1);
          if (v44)
          {
            uint64_t v45 = (uint64_t)v44;
            int v46 = *(xmlDict **)(v14 + 8);
            if (v46)
            {
              *(void *)uint64_t v45 = v46;
              xmlDictReference(v46);
            }
            int v47 = *(_DWORD *)(v14 + 32);
            if ((v47 & 0x100) != 0) {
              *(_DWORD *)(v45 + 24) |= 0x8000u;
            }
            LODWORD(v48) = *(_DWORD *)(v14 + 36);
            if ((int)v48 < 1)
            {
              int v52 = 0;
LABEL_162:
              if ((v47 & 7) != 0)
              {
                int v62 = *(_DWORD *)(v45 + 8);
              }
              else
              {
                int v77 = *(_DWORD *)(v45 + 24);
                if ((v77 & 0x10000) == 0) {
                  *(_DWORD *)(v45 + 24) = v77 | 0x10000;
                }
                int v62 = *(_DWORD *)(v45 + 8);
                if (v62 >= 1)
                {
                  uint64_t v78 = *(_DWORD **)(v45 + 16);
                  if ((*v78 & 1) == 0) {
                    *v78 |= 1u;
                  }
                }
              }
              if (v62 <= v52)
              {
LABEL_167:
                xmlFreeStreamComp(v45);
                goto LABEL_168;
              }
              unsigned int v59 = (_DWORD *)(*(void *)(v45 + 16) + 32 * v52);
              int v60 = 2;
            }
            else
            {
              uint64_t v49 = 0;
              int v50 = 0;
              int v51 = 0;
              int v52 = 0;
              int v53 = -1;
              do
              {
                while (2)
                {
                  uint64_t v54 = *(void *)(v14 + 48) + 24 * v49;
                  if (*(_DWORD *)v54 != 1)
                  {
                    switch(*(_DWORD *)v54)
                    {
                      case 2:
                        uint64_t v55 = *(void *)(v54 + 8);
                        uint64_t v56 = *(void *)(v54 + 16);
                        if (*(_OWORD *)(v54 + 8) != 0) {
                          goto LABEL_140;
                        }
                        if (v49 + 1 != v48 || (v50 & 1) == 0) {
                          goto LABEL_152;
                        }
                        *(_DWORD *)(v45 + 24) |= 0x4000u;
                        unsigned int v93 = v53;
                        int v52 = xmlStreamCompAddStep(v45, 0, 0, 100, v50 | 0x10u);
                        if (v52 < 0) {
                          goto LABEL_167;
                        }
                        if (v93 == -1) {
                          goto LABEL_142;
                        }
                        int v50 = 0;
                        *(_DWORD *)(*(void *)(v45 + 16) + 32 * v93) |= 0x20u;
                        goto LABEL_143;
                      case 3:
                        uint64_t v55 = *(void *)(v54 + 8);
                        uint64_t v56 = *(void *)(v54 + 16);
LABEL_140:
                        uint64_t v57 = v45;
                        goto LABEL_150;
                      case 4:
                        int v52 = xmlStreamCompAddStep(v45, *(void *)(v54 + 8), *(void *)(v54 + 16), 2, v50 | 8u);
                        if (v52 < 0) {
                          goto LABEL_167;
                        }
LABEL_142:
                        int v50 = 0;
LABEL_143:
                        int v53 = -1;
                        goto LABEL_152;
                      case 6:
                        if ((v50 & 1) == 0)
                        {
                          int v58 = *(_DWORD *)(v45 + 24);
                          if ((v58 & 0x10000) == 0) {
                            *(_DWORD *)(v45 + 24) = v58 | 0x10000;
                          }
                          int v50 = 1;
                        }
                        goto LABEL_152;
                      case 7:
                        uint64_t v56 = *(void *)(v54 + 8);
                        uint64_t v57 = v45;
                        uint64_t v55 = 0;
                        goto LABEL_150;
                      case 8:
                        uint64_t v57 = v45;
                        uint64_t v55 = 0;
                        uint64_t v56 = 0;
LABEL_150:
                        int v52 = xmlStreamCompAddStep(v57, v55, v56, 1, v50);
                        if (v52 < 0) {
                          goto LABEL_167;
                        }
                        int v50 = 0;
                        int v53 = v52;
LABEL_152:
                        ++v49;
                        uint64_t v48 = *(int *)(v14 + 36);
                        if (v49 < v48) {
                          continue;
                        }
                        if (v51) {
                          goto LABEL_154;
                        }
                        int v47 = *(_DWORD *)(v14 + 32);
                        break;
                      default:
                        goto LABEL_152;
                    }
                    goto LABEL_162;
                  }
                  break;
                }
                if (v49) {
                  goto LABEL_167;
                }
                uint64_t v49 = 1;
                int v51 = 1;
              }
              while ((int)v48 > 1);
LABEL_154:
              if (*(_DWORD *)(v45 + 8) <= v52) {
                goto LABEL_167;
              }
              unsigned int v59 = *(_DWORD **)(v45 + 16);
              v59[8 * v52] |= 2u;
              int v60 = 4;
            }
            *v59 |= v60;
            *(void *)(v14 + 56) = v45;
          }
        }
      }
    }
    else
    {
      BOOL v101 = 0;
    }
LABEL_168:
    int v63 = *(_DWORD *)(v14 + 36);
    unsigned int v64 = *(_DWORD **)(v14 + 48);
    uint64_t v65 = (v63 - 1);
    if (v63 >= 1 && *v64 == 6)
    {
      if (v63 < 2)
      {
        LODWORD(v65) = 0;
      }
      else
      {
        unsigned int v66 = v64 + 6;
        uint64_t v67 = v65;
        do
        {
          *((_OWORD *)v66 - htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = *(_OWORD *)(v66 + 2);
          *(v66 - 6) = *v66;
          v66 += 6;
          --v67;
        }
        while (v67);
      }
      *(_DWORD *)(v14 + 36) = v65;
      int v63 = v65;
    }
    uint64_t v68 = *(int *)(v14 + 40);
    if (v63 >= (int)v68)
    {
      unsigned int v64 = xmlRealloc(v64, 48 * v68);
      if (!v64) {
        goto LABEL_240;
      }
      *(void *)(v14 + 48) = v64;
      int v63 = *(_DWORD *)(v14 + 36);
      *(_DWORD *)(v14 + 40) *= 2;
    }
    if (v63 <= 1)
    {
      uint64_t v70 = v63;
    }
    else
    {
      uint64_t v69 = 0;
      uint64_t v70 = v63;
      unsigned int v71 = v64 + 2;
      uint64_t v72 = v63 - 2;
      uint64_t v73 = (uint64_t)&v64[6 * v63 - 6];
      do
      {
        long long v74 = *v71;
        *unsigned int v71 = *(_OWORD *)(v73 + 8);
        *(_OWORD *)(v73 + 8) = v74;
        int v75 = *((_DWORD *)v71 - 2);
        *((_DWORD *)v71 - 2) = *(_DWORD *)v73;
        *(_DWORD *)uint64_t v73 = v75;
        v73 -= 24;
        ++v69;
        unsigned int v71 = (_OWORD *)((char *)v71 + 24);
        BOOL v25 = v72-- <= v69;
      }
      while (!v25);
    }
    uint64_t v76 = &v64[6 * v70];
    *((void *)v76 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0;
    *((void *)v76 + 2) = 0;
    *(_DWORD *)(v14 + 36) = v63 + 1;
    *uint64_t v76 = 0;
    if (v11) {
      xmlFree(v11);
    }
    unsigned int v5 = *v4;
  }
  while (*v4);
  if (!v101)
  {
    uint64_t v91 = v7;
    do
    {
      uint64_t v92 = *((void *)v91 + 7);
      if (v92)
      {
        xmlFreeStreamComp(v92);
        *((void *)v91 + 7) = 0;
      }
      uint64_t v91 = (xmlPattern *)*((void *)v91 + 2);
    }
    while (v91);
  }
  return v7;
}

_OWORD *xmlNewPatParserContext(_OWORD *result, uint64_t a2, uint64_t *a3)
{
  if (result)
  {
    unsigned int v5 = result;
    int result = xmlMalloc(0x40uLL);
    if (result)
    {
      const xmlParserNodeInfo *result = 0u;
      result[1] = 0u;
      result[2] = 0u;
      result[3] = 0u;
      *((void *)result + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = a2;
      *(void *)int result = v5;
      *((void *)result + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v5;
      if (a3)
      {
        int v6 = -1;
        unint64_t v7 = a3;
        do
        {
          uint64_t v8 = *v7;
          v7 += 2;
          ++v6;
        }
        while (v8);
      }
      else
      {
        int v6 = 0;
      }
      *((_DWORD *)result + 14) = v6;
      *((void *)result + 6) = a3;
    }
  }
  return result;
}

uint64_t xmlFreeStreamComp(uint64_t a1)
{
  int v2 = *(void **)(a1 + 16);
  if (v2) {
    xmlFree(v2);
  }
  if (*(void *)a1) {
    xmlDictFree(*(xmlDictPtr *)a1);
  }
  xmlFreeFunc v3 = xmlFree;

  return ((uint64_t (*)(uint64_t))v3)(a1);
}

int xmlPatternMatch(xmlPatternPtr comp, xmlNodePtr node)
{
  int result = -1;
  if (!comp || !node) {
    return result;
  }
  while (2)
  {
    if (*((int *)comp + 9) < 1) {
      return 1;
    }
    int v5 = 0;
    int v50 = 0;
    int v6 = 0;
    LODWORD(v7) = 0;
    xmlNodePtr v8 = node;
LABEL_5:
    uint64_t v9 = *((void *)comp + 6);
    uint64_t v10 = v9 + 24 * (int)v7;
    uint64_t v11 = (int)v7;
    switch(*(_DWORD *)v10)
    {
      case 0:
        goto LABEL_97;
      case 1:
        if (v8->type != XML_NAMESPACE_DECL)
        {
          xmlNodePtr v8 = v8->parent;
          unsigned int type = v8->type;
          BOOL v13 = type > 0x15;
          int v14 = (1 << type) & 0x202200;
          if (!v13 && v14 != 0) {
            goto LABEL_92;
          }
        }
        goto LABEL_74;
      case 2:
        if (v8->type == XML_ELEMENT_NODE) {
          goto LABEL_13;
        }
        goto LABEL_74;
      case 3:
        HIDWORD(v22) = v8->type - 1;
        LODWORD(v22) = HIDWORD(v22);
        unsigned int v21 = v22 >> 2;
        BOOL v13 = v21 > 5;
        int v23 = (1 << v21) & 0x2D;
        if (v13 || v23 == 0) {
          goto LABEL_74;
        }
        uint64_t v25 = v9 + 24 * (int)v7;
        uint64_t v27 = *(void *)(v25 + 8);
        uint64_t v26 = (const xmlChar **)(v25 + 8);
        if (!v27) {
          goto LABEL_74;
        }
        xmlNodePtr children = v8->children;
        if (!children) {
          goto LABEL_74;
        }
        while (1)
        {
          if (children->type == XML_ELEMENT_NODE)
          {
            name = children->name;
            if (**v26 == *name)
            {
              if (xmlStrEqual(*v26, name)) {
                goto LABEL_92;
              }
            }
          }
          xmlNodePtr children = children->next;
          if (!children) {
            goto LABEL_74;
          }
        }
      case 4:
        if (v8->type != XML_ATTRIBUTE_NODE) {
          goto LABEL_74;
        }
        xmlParserInputPtr v30 = *(const xmlChar **)(v9 + 24 * (int)v7 + 8);
        if (v30)
        {
          int v31 = v8->name;
          if (*v30 != *v31 || !xmlStrEqual(v30, v31)) {
            goto LABEL_74;
          }
        }
        xmlNsPtr ns = v8->ns;
        int v20 = *(const xmlChar **)(v9 + 24 * (int)v7 + 16);
        if (ns)
        {
          if (!v20) {
            goto LABEL_92;
          }
          href = ns->href;
LABEL_71:
          if (xmlStrEqual(v20, href)) {
            goto LABEL_92;
          }
          goto LABEL_74;
        }
        if (v20) {
          goto LABEL_74;
        }
        goto LABEL_92;
      case 5:
        unsigned int v33 = v8->type;
        BOOL v13 = v33 > 0x15;
        int v34 = (1 << v33) & 0x242200;
        if (!v13 && v34 != 0) {
          goto LABEL_74;
        }
        xmlNodePtr v8 = v8->parent;
        if (!v8) {
          goto LABEL_74;
        }
LABEL_13:
        uint64_t v16 = *(const xmlChar **)(v9 + 24 * (int)v7 + 8);
        if (!v16) {
          goto LABEL_92;
        }
        uint64_t v17 = v8->name;
        if (*v16 != *v17 || !xmlStrEqual(v16, v17)) {
          goto LABEL_74;
        }
        uint64_t v18 = v8->ns;
        if (v18)
        {
          href = v18->href;
          if (!href) {
            goto LABEL_92;
          }
          int v20 = *(const xmlChar **)(v9 + 24 * (int)v7 + 16);
          if (!v20) {
            goto LABEL_74;
          }
          goto LABEL_71;
        }
        if (*(void *)(v9 + 24 * (int)v7 + 16)) {
          goto LABEL_74;
        }
        goto LABEL_92;
      case 6:
        if (!*(void *)(v9 + 24 * (int)v7 + 8))
        {
          uint64_t v7 = (int)v7 + 1;
          uint64_t v10 = v9 + 24 * (v11 + 1);
          if (*(_DWORD *)v10 != 2)
          {
            if (*(_DWORD *)v10 == 1) {
              goto LABEL_97;
            }
            goto LABEL_74;
          }
          if (!*(void *)(v9 + 24 * v7 + 8)) {
            return -1;
          }
          if (v8) {
            goto LABEL_47;
          }
LABEL_74:
          if (!v6) {
            goto LABEL_95;
          }
          BOOL v47 = __OFSUB__(v5--, 1);
          if (v5 < 0 != v47)
          {
            xmlFree(v6);
LABEL_95:
            comp = (xmlPatternPtr)*((void *)comp + 2);
            if (!comp) {
              return 0;
            }
            continue;
          }
          uint64_t v48 = &v6[16 * v5];
          LODWORD(v7) = *(_DWORD *)v48;
          xmlNodePtr v8 = (xmlNodePtr)*((void *)v48 + 1);
          if (*(_DWORD *)v48 >= *((_DWORD *)comp + 9)) {
            goto LABEL_98;
          }
          goto LABEL_5;
        }
        if (!v8) {
          goto LABEL_74;
        }
LABEL_47:
        unsigned int v36 = v8->type;
        BOOL v13 = v36 > 0x15;
        int v37 = (1 << v36) & 0x242200;
        if (!v13 && v37 != 0) {
          goto LABEL_74;
        }
        while (1)
        {
          while (1)
          {
            while (1)
            {
              xmlNodePtr v8 = v8->parent;
              if (!v8) {
                goto LABEL_74;
              }
              if (v8->type == XML_ELEMENT_NODE)
              {
                int v39 = *(const xmlChar **)(v10 + 8);
                uint64_t v40 = v8->name;
                if (*v39 == *v40)
                {
                  if (xmlStrEqual(v39, v40)) {
                    break;
                  }
                }
              }
            }
            long long v41 = v8->ns;
            if (v41) {
              break;
            }
            if (!*(void *)(v10 + 16)) {
              goto LABEL_62;
            }
          }
          uint64_t v42 = v41->href;
          if (v42)
          {
            int v43 = *(const xmlChar **)(v10 + 16);
            if (v43)
            {
              if (xmlStrEqual(v43, v42)) {
                break;
              }
            }
          }
        }
LABEL_62:
        BOOL v44 = *(_DWORD *)v10 != 6;
        if (v6 && v50 > 0)
        {
          if (v50 <= v5)
          {
            uint64_t v45 = (char *)xmlRealloc(v6, 16 * (2 * v50));
            if (!v45) {
              goto LABEL_92;
            }
            v50 *= 2;
            int v6 = v45;
          }
        }
        else
        {
          int v6 = (char *)xmlMalloc(0x40uLL);
          int v5 = 0;
          int v50 = 4;
        }
        uint64_t v49 = &v6[16 * v5];
        *(_DWORD *)uint64_t v49 = v7 - v44;
        ++v5;
        *((void *)v49 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v8;
LABEL_92:
        LODWORD(v7) = v7 + 1;
        if ((int)v7 < *((_DWORD *)comp + 9)) {
          goto LABEL_5;
        }
LABEL_97:
        if (v6) {
LABEL_98:
        }
          xmlFree(v6);
        return 1;
      case 7:
        if (v8->type != XML_ELEMENT_NODE) {
          goto LABEL_74;
        }
        int v46 = v8->ns;
        if (v46)
        {
          href = v46->href;
          if (!href) {
            goto LABEL_92;
          }
          int v20 = *(const xmlChar **)(v9 + 24 * (int)v7 + 8);
          if (!v20) {
            goto LABEL_74;
          }
          goto LABEL_71;
        }
        if (*(void *)(v9 + 24 * (int)v7 + 8)) {
          goto LABEL_74;
        }
        goto LABEL_92;
      case 8:
        if (v8->type != XML_ELEMENT_NODE) {
          goto LABEL_74;
        }
        goto LABEL_92;
      default:
        goto LABEL_92;
    }
  }
}

xmlStreamCtxtPtr xmlPatternGetStreamCtxt(xmlStreamCtxtPtr comp)
{
  if (comp)
  {
    xmlStreamCtxtPtr v1 = comp;
    if (*((void *)comp + 7))
    {
      xmlStreamCtxtPtr v2 = 0;
      while (1)
      {
        uint64_t v3 = *((void *)v1 + 7);
        if (!v3) {
          break;
        }
        uint64_t v4 = xmlMalloc(0x30uLL);
        if (!v4) {
          break;
        }
        int v5 = v4;
        v4[1] = 0u;
        v4[2] = 0u;
        _OWORD *v4 = 0u;
        int v6 = xmlMalloc(0x20uLL);
        v5[4] = v6;
        if (!v6)
        {
          xmlFree(v5);
          break;
        }
        v5[2] = 0x400000000;
        *((_DWORD *)v5 + 6) = 0;
        v5[1] = v3;
        comp = (xmlStreamCtxtPtr)v5;
        *((_DWORD *)v5 + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = -1;
        if (v2)
        {
          *int v5 = *(void *)v2;
          *(void *)xmlStreamCtxtPtr v2 = v5;
          comp = v2;
        }
        *((_DWORD *)v5 + 10) = *((_DWORD *)v1 + 8);
        xmlStreamCtxtPtr v1 = (xmlStreamCtxtPtr)*((void *)v1 + 2);
        xmlStreamCtxtPtr v2 = comp;
        if (!v1) {
          return comp;
        }
      }
      if (v2)
      {
        do
        {
          uint64_t v7 = *(xmlStreamCtxt **)v2;
          xmlNodePtr v8 = (void *)*((void *)v2 + 4);
          if (v8) {
            xmlFree(v8);
          }
          xmlFree(v2);
          xmlStreamCtxtPtr v2 = v7;
        }
        while (v7);
      }
    }
    return 0;
  }
  return comp;
}

int xmlPatternStreamable(xmlPatternPtr comp)
{
  if (!comp) {
    return -1;
  }
  while (*((void *)comp + 7))
  {
    comp = (xmlPatternPtr)*((void *)comp + 2);
    if (!comp) {
      return 1;
    }
  }
  return 0;
}

int xmlPatternMaxDepth(xmlPatternPtr comp)
{
  if (comp)
  {
    xmlPatternPtr v1 = comp;
    int result = 0;
    while (1)
    {
      uint64_t v3 = *((void *)v1 + 7);
      if (!v3) {
        break;
      }
      uint64_t v4 = *(unsigned int *)(v3 + 8);
      if ((int)v4 >= 1)
      {
        int v5 = *(char **)(v3 + 16);
        uint64_t v6 = v4;
        do
        {
          char v7 = *v5;
          v5 += 32;
          if (v7) {
            return -2;
          }
        }
        while (--v6);
      }
      if ((int)v4 > result) {
        int result = v4;
      }
      xmlPatternPtr v1 = (xmlPatternPtr)*((void *)v1 + 2);
      if (!v1) {
        return result;
      }
    }
  }
  return -1;
}

int xmlPatternMinDepth(xmlPatternPtr comp)
{
  if (comp)
  {
    xmlPatternPtr v1 = comp;
    int result = 12345678;
    while (1)
    {
      uint64_t v3 = *((void *)v1 + 7);
      if (!v3) {
        break;
      }
      int v4 = *(_DWORD *)(v3 + 8);
      if (v4 < result) {
        int result = v4;
      }
      if (result)
      {
        xmlPatternPtr v1 = (xmlPatternPtr)*((void *)v1 + 2);
        if (v1) {
          continue;
        }
      }
      return result;
    }
  }
  return -1;
}

int xmlPatternFromRoot(xmlPatternPtr comp)
{
  if (comp)
  {
    while (*((void *)comp + 7))
    {
      if (*((unsigned char *)comp + 33))
      {
        LODWORD(comp) = 1;
        return (int)comp;
      }
      comp = (xmlPatternPtr)*((void *)comp + 2);
      if (!comp) {
        return (int)comp;
      }
    }
  }
  LODWORD(comp) = -1;
  return (int)comp;
}

uint64_t xmlStreamCtxtAddState(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if ((int)v6 < 1)
  {
LABEL_5:
    uint64_t v9 = *(int *)(a1 + 20);
    if ((int)v6 >= (int)v9)
    {
      uint64_t v10 = xmlRealloc(*(void **)(a1 + 32), 16 * v9);
      if (!v10) {
        return 0xFFFFFFFFLL;
      }
      *(void *)(a1 + 32) = v10;
      LODWORD(v6) = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 20) *= 2;
    }
    else
    {
      uint64_t v10 = *(_DWORD **)(a1 + 32);
    }
    v10[2 * v6] = a2;
    int v11 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = v11 + 1;
    v10[(2 * v11) | 1] = a3;
    return (*(_DWORD *)(a1 + 16) - 1);
  }
  uint64_t result = 0;
  xmlNodePtr v8 = *(_DWORD **)(a1 + 32);
  while ((*v8 & 0x80000000) == 0)
  {
    ++result;
    v8 += 2;
    if (v6 == result) {
      goto LABEL_5;
    }
  }
  *xmlNodePtr v8 = a2;
  v8[1] = a3;
  return result;
}

uint64_t xmlPatternAdd(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  int v8 = *(_DWORD *)(a1 + 36);
  uint64_t v9 = *(int *)(a1 + 40);
  if (v8 >= (int)v9)
  {
    uint64_t v10 = (char *)xmlRealloc(*(void **)(a1 + 48), 48 * v9);
    if (!v10) {
      return 0xFFFFFFFFLL;
    }
    *(void *)(a1 + 48) = v10;
    int v8 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 40) *= 2;
  }
  else
  {
    uint64_t v10 = *(char **)(a1 + 48);
  }
  uint64_t v11 = 0;
  long long v12 = &v10[24 * v8];
  *(_DWORD *)long long v12 = a2;
  *((void *)v12 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = a3;
  *((void *)v12 + 2) = a4;
  *(_DWORD *)(a1 + 36) = v8 + 1;
  return v11;
}

void xmlCompileStepPattern(uint64_t *a1)
{
  for (uint64_t i = *a1 + 1; ; ++i)
  {
    uint64_t v3 = *(unsigned __int8 *)(i - 1) - 9;
    if (v3 > 0x37) {
      goto LABEL_16;
    }
    if (((1 << (*(unsigned char *)(i - 1) - 9)) & 0x800013) == 0) {
      break;
    }
    *a1 = i;
  }
  if (v3 != 37)
  {
    if (v3 == 55)
    {
      if ((*(unsigned char *)(a1[4] + 32) & 2) == 0)
      {
        *a1 = i;
LABEL_9:
        xmlCompileAttributeTest(a1);
        return;
      }
LABEL_71:
      *((_DWORD *)a1 + 4) = 1;
      return;
    }
LABEL_16:
    uint64_t v6 = (const xmlChar *)xmlPatScanNCName((const xmlChar **)a1);
    uint64_t v7 = *a1;
    unsigned int v8 = *(unsigned __int8 *)*a1;
    if (v6)
    {
      uint64_t v9 = (xmlChar *)v6;
      if (v8 > 0x20 || ((1 << v8) & 0x100002600) == 0)
      {
        char v13 = 0;
      }
      else
      {
        uint64_t v11 = (unsigned __int8 *)(v7 + 1);
        while (v8 <= 0x20 && ((1 << v8) & 0x100002600) != 0)
        {
          *a1 = (uint64_t)v11;
          unsigned int v12 = *v11++;
          unsigned int v8 = v12;
        }
        uint64_t v7 = (uint64_t)(v11 - 1);
        char v13 = 1;
      }
      if (v8 != 42)
      {
        if (v8 != 58)
        {
          if (!xmlPatternAdd(a1[4], 2, (uint64_t)v6, 0)) {
            return;
          }
LABEL_64:
          if (!v9) {
            return;
          }
          goto LABEL_65;
        }
        *a1 = v7 + 1;
        unsigned int v15 = *(unsigned __int8 *)(v7 + 1);
        if (v15 == 58)
        {
          *a1 = v7 + 2;
          if (xmlStrEqual(v6, (const xmlChar *)"child"))
          {
            if (!*(void *)(a1[4] + 8)) {
              xmlFree(v9);
            }
            uint64_t v16 = (xmlChar *)xmlPatScanName((const xmlChar **)a1);
            uint64_t v17 = *a1;
            int v18 = *(unsigned __int8 *)*a1;
            if (v16)
            {
              uint64_t v9 = v16;
              if (v18 != 58)
              {
                if (!xmlPatternAdd(a1[4], 3, (uint64_t)v16, 0)) {
                  return;
                }
                goto LABEL_65;
              }
              *a1 = v17 + 1;
              unsigned int v19 = *(unsigned __int8 *)(v17 + 1);
              if (v19 <= 0x20 && ((1 << v19) & 0x100002600) != 0)
              {
                *((_DWORD *)a1 + 4) = 1;
LABEL_65:
                if (!*(void *)(a1[4] + 8))
                {
                  xmlFreeFunc v25 = xmlFree;
                  ((void (*)(xmlChar *))v25)(v9);
                }
                return;
              }
              unsigned int v21 = xmlPatScanName((const xmlChar **)a1);
              if (*v9 == 120 && v9[1] == 109 && v9[2] == 108 && !v9[3])
              {
                int v39 = *(xmlDict **)(a1[4] + 8);
                if (v39) {
                  uint64_t v40 = (void *)xmlDictLookup(v39, (const xmlChar *)"http://www.w3.org/XML/1998/namespace", -1);
                }
                else {
                  uint64_t v40 = xmlStrdup((const xmlChar *)"http://www.w3.org/XML/1998/namespace");
                }
                uint64_t v26 = v40;
                goto LABEL_104;
              }
              if (*((int *)a1 + 14) < 1)
              {
                LODWORD(v28) = 0;
LABEL_96:
                uint64_t v26 = 0;
              }
              else
              {
                uint64_t v27 = 0;
                uint64_t v28 = 0;
                while (!xmlStrEqual(*(const xmlChar **)(a1[6] + v27 + 8), v9))
                {
                  ++v28;
                  v27 += 16;
                  if (v28 >= *((int *)a1 + 14)) {
                    goto LABEL_96;
                  }
                }
                int v34 = *(xmlDict **)(a1[4] + 8);
                uint64_t v35 = (unsigned __int8 *)a1[6];
                if (v34) {
                  unsigned int v36 = (void *)xmlDictLookup(v34, *(const xmlChar **)&v35[v27], -1);
                }
                else {
                  unsigned int v36 = xmlStrdup(*(const xmlChar **)&v35[v27]);
                }
                uint64_t v26 = v36;
              }
              if ((int)v28 < *((_DWORD *)a1 + 14))
              {
LABEL_104:
                if (!*(void *)(a1[4] + 8)) {
                  xmlFree(v9);
                }
                if (v21)
                {
                  uint64_t v32 = a1[4];
                  int v33 = 3;
                  goto LABEL_108;
                }
LABEL_110:
                if (*(unsigned char *)*a1 == 42)
                {
                  ++*a1;
                  unsigned int v21 = 0;
                  uint64_t v9 = 0;
                  if (!xmlPatternAdd(a1[4], 7, (uint64_t)v26, 0)) {
                    return;
                  }
                  goto LABEL_115;
                }
                unsigned int v21 = 0;
                uint64_t v9 = 0;
              }
LABEL_114:
              *((_DWORD *)a1 + 4) = 1;
LABEL_115:
              if (v26 && !*(void *)(a1[4] + 8)) {
                xmlFree(v26);
              }
              if (v21 && !*(void *)(a1[4] + 8)) {
                xmlFree(v21);
              }
              goto LABEL_64;
            }
            if (v18 != 42) {
              goto LABEL_71;
            }
            int v14 = (unsigned __int8 *)(v17 + 1);
            goto LABEL_28;
          }
          if (xmlStrEqual(v9, (const xmlChar *)"attribute"))
          {
            unsigned int v24 = (unsigned __int8 *)a1[4];
            if (!*((void *)v24 + 1))
            {
              xmlFree(v9);
              unsigned int v24 = (unsigned __int8 *)a1[4];
            }
            if ((v24[32] & 2) == 0) {
              goto LABEL_9;
            }
            goto LABEL_71;
          }
        }
        else
        {
          if (v15 == 32) {
            char v20 = 1;
          }
          else {
            char v20 = v13;
          }
          if ((v20 & 1) == 0 && (v15 > 0xD || ((1 << v15) & 0x2600) == 0))
          {
            unsigned int v21 = xmlPatScanName((const xmlChar **)a1);
            if (*v9 == 120 && v9[1] == 109 && v9[2] == 108 && !v9[3])
            {
              int v37 = *(xmlDict **)(a1[4] + 8);
              if (v37) {
                uint64_t v38 = (void *)xmlDictLookup(v37, (const xmlChar *)"http://www.w3.org/XML/1998/namespace", -1);
              }
              else {
                uint64_t v38 = xmlStrdup((const xmlChar *)"http://www.w3.org/XML/1998/namespace");
              }
              uint64_t v26 = v38;
            }
            else
            {
              if (*((int *)a1 + 14) < 1)
              {
                LODWORD(v2xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0;
LABEL_76:
                uint64_t v26 = 0;
              }
              else
              {
                uint64_t v22 = 0;
                uint64_t v23 = 0;
                while (!xmlStrEqual(*(const xmlChar **)(a1[6] + v22 + 8), v9))
                {
                  ++v23;
                  v22 += 16;
                  if (v23 >= *((int *)a1 + 14)) {
                    goto LABEL_76;
                  }
                }
                uint64_t v29 = *(xmlDict **)(a1[4] + 8);
                xmlParserInputPtr v30 = (unsigned __int8 *)a1[6];
                if (v29) {
                  int v31 = (void *)xmlDictLookup(v29, *(const xmlChar **)&v30[v22], -1);
                }
                else {
                  int v31 = xmlStrdup(*(const xmlChar **)&v30[v22]);
                }
                uint64_t v26 = v31;
              }
              if ((int)v23 >= *((_DWORD *)a1 + 14)) {
                goto LABEL_114;
              }
            }
            if (!*(void *)(a1[4] + 8)) {
              xmlFree(v9);
            }
            if (v21)
            {
              uint64_t v32 = a1[4];
              int v33 = 2;
LABEL_108:
              if (!xmlPatternAdd(v32, v33, (uint64_t)v21, (uint64_t)v26)) {
                return;
              }
              uint64_t v9 = 0;
              goto LABEL_115;
            }
            goto LABEL_110;
          }
        }
      }
      *((_DWORD *)a1 + 4) = 1;
      goto LABEL_64;
    }
    if (v8 != 42) {
      goto LABEL_71;
    }
    int v14 = (unsigned __int8 *)(v7 + 1);
LABEL_28:
    *a1 = (uint64_t)v14;
    uint64_t v4 = a1[4];
    int v5 = 8;
    goto LABEL_13;
  }
  *a1 = i;
  uint64_t v4 = a1[4];
  int v5 = 2;
LABEL_13:

  xmlPatternAdd(v4, v5, 0, 0);
}

void xmlCompileAttributeTest(uint64_t *a1)
{
  for (uint64_t i = *a1 + 1; ; ++i)
  {
    unsigned int v3 = *(unsigned __int8 *)(i - 1);
    BOOL v4 = v3 > 0x20;
    uint64_t v5 = (1 << v3) & 0x100002600;
    if (v4 || v5 == 0) {
      break;
    }
    *a1 = i;
  }
  uint64_t v7 = xmlPatScanNCName((const xmlChar **)a1);
  unsigned int v8 = (const xmlChar *)*a1;
  int v9 = *(unsigned __int8 *)*a1;
  if (v7)
  {
    uint64_t v10 = (uint64_t)v7;
    if (v9 == 58)
    {
      *a1 = (uint64_t)(v8 + 1);
      unsigned int v11 = v8[1];
      BOOL v4 = v11 > 0x20;
      uint64_t v12 = (1 << v11) & 0x100002600;
      if (!v4 && v12 != 0)
      {
        if (!*(void *)(a1[4] + 8)) {
          xmlFree(v7);
        }
        goto LABEL_19;
      }
      unsigned int v15 = xmlPatScanName((const xmlChar **)a1);
      if (*(unsigned char *)v10 == 120 && *(unsigned char *)(v10 + 1) == 109 && *(unsigned char *)(v10 + 2) == 108 && !*(unsigned char *)(v10 + 3))
      {
        uint64_t v23 = *(xmlDict **)(a1[4] + 8);
        if (v23) {
          unsigned int v24 = (void *)xmlDictLookup(v23, (const xmlChar *)"http://www.w3.org/XML/1998/namespace", -1);
        }
        else {
          unsigned int v24 = xmlStrdup((const xmlChar *)"http://www.w3.org/XML/1998/namespace");
        }
        int v18 = v24;
      }
      else
      {
        if (*((int *)a1 + 14) < 1)
        {
          LODWORD(v17) = 0;
LABEL_34:
          int v18 = 0;
        }
        else
        {
          uint64_t v16 = 0;
          uint64_t v17 = 0;
          while (!xmlStrEqual(*(const xmlChar **)(a1[6] + v16 + 8), (const xmlChar *)v10))
          {
            ++v17;
            v16 += 16;
            if (v17 >= *((int *)a1 + 14)) {
              goto LABEL_34;
            }
          }
          unsigned int v19 = *(xmlDict **)(a1[4] + 8);
          char v20 = (unsigned __int8 *)a1[6];
          if (v19) {
            unsigned int v21 = (void *)xmlDictLookup(v19, *(const xmlChar **)&v20[v16], -1);
          }
          else {
            unsigned int v21 = xmlStrdup(*(const xmlChar **)&v20[v16]);
          }
          int v18 = v21;
        }
        if ((int)v17 >= *((_DWORD *)a1 + 14))
        {
          if (!*(void *)(a1[4] + 8)) {
            xmlFree((void *)v10);
          }
          goto LABEL_51;
        }
      }
      if (!*(void *)(a1[4] + 8)) {
        xmlFree((void *)v10);
      }
      if (v15)
      {
        if (!xmlPatternAdd(a1[4], 4, (uint64_t)v15, (uint64_t)v18)) {
          return;
        }
        goto LABEL_52;
      }
      if (*(unsigned char *)*a1 == 42)
      {
        ++*a1;
        unsigned int v15 = 0;
        if (!xmlPatternAdd(a1[4], 4, 0, (uint64_t)v18)) {
          return;
        }
        goto LABEL_52;
      }
      unsigned int v15 = 0;
LABEL_51:
      *((_DWORD *)a1 + 4) = 1;
LABEL_52:
      if (v18 && !*(void *)(a1[4] + 8)) {
        xmlFree(v18);
      }
      if (v15 && !*(void *)(a1[4] + 8))
      {
        xmlFreeFunc v22 = xmlFree;
        ((void (*)(void *))v22)(v15);
      }
      return;
    }
    uint64_t v14 = a1[4];
    xmlPatternAdd(v14, 4, v10, 0);
  }
  else
  {
    if (v9 != 42)
    {
LABEL_19:
      *((_DWORD *)a1 + 4) = 1;
      return;
    }
    if (!xmlPatternAdd(a1[4], 4, 0, 0) && *(unsigned char *)*a1) {
      ++*a1;
    }
  }
}

void *xmlPatScanNCName(const xmlChar **a1)
{
  int len = 0;
  xmlStreamCtxtPtr v2 = *a1;
  unsigned int v3 = *a1;
  while (1)
  {
    unsigned int v4 = *v3;
    BOOL v10 = v4 > 0x20;
    uint64_t v5 = (1 << v4) & 0x100002600;
    if (v10 || v5 == 0) {
      break;
    }
    *a1 = ++v3;
    LODWORD(v2) = v2 + 1;
  }
  signed int v7 = xmlStringCurrentChar(0, v3, &len);
  signed int v8 = v7;
  if (v7 > 255)
  {
    if (xmlCharInRange(v7, &xmlIsBaseCharGroup)) {
      BOOL v10 = 1;
    }
    else {
      BOOL v10 = (v8 - 12330) > 0xFFFFFFF6;
    }
    if (!v10 && v8 != 12295 && (v8 - 40870) < 0xFFFFAE5A) {
      return 0;
    }
  }
  else if ((v7 - 192) >= 0x17 {
         && (v7 & 0xFFFFFFDF) - 65 >= 0x1A
  }
         && v7 != 95
         && v7 <= 247
         && (v7 - 216) >= 0x1F)
  {
    return 0;
  }
  for (uint64_t i = v3; ; v8 = xmlStringCurrentChar(0, i, &len))
  {
    if (v8 > 255)
    {
      if (xmlCharInRange(v8, &xmlIsBaseCharGroup)) {
        BOOL v14 = 0;
      }
      else {
        BOOL v14 = (v8 - 12321) >= 9;
      }
      BOOL v16 = v14 && v8 != 12295 && (v8 - 19968) >= 0x51A6;
      if (!v16 || xmlCharInRange(v8, &xmlIsDigitGroup)) {
        goto LABEL_47;
      }
    }
    else if ((v8 - 192) < 0x17 {
           || (v8 & 0xFFFFFFDF) - 65 < 0x1A
    }
           || (v8 - 48) < 0xA
           || v8 > 247
           || (v8 - 216) < 0x1F)
    {
      goto LABEL_47;
    }
    if ((v8 - 45) <= 0x32 && ((1 << (v8 - 45)) & 0x4000000000003) != 0) {
      goto LABEL_47;
    }
    if (v8 >= 256) {
      break;
    }
    if (v8 != 183) {
      goto LABEL_53;
    }
LABEL_47:
    i += len;
  }
  if (xmlCharInRange(v8, &xmlIsCombiningGroup) || xmlCharInRange(v8, &xmlIsExtenderGroup)) {
    goto LABEL_47;
  }
LABEL_53:
  uint64_t v17 = (xmlDict *)a1[3];
  if (v17) {
    uint64_t result = (void *)xmlDictLookup(v17, v3, (int)i - (int)v2);
  }
  else {
    uint64_t result = xmlStrndup(v3, (int)i - (int)v2);
  }
  *a1 = i;
  return result;
}

void *xmlPatScanName(const xmlChar **a1)
{
  int len = 0;
  xmlStreamCtxtPtr v2 = *a1;
  unsigned int v3 = *a1;
  while (1)
  {
    unsigned int v4 = *v3;
    BOOL v10 = v4 > 0x20;
    uint64_t v5 = (1 << v4) & 0x100002600;
    if (v10 || v5 == 0) {
      break;
    }
    *a1 = ++v3;
    LODWORD(v2) = v2 + 1;
  }
  signed int v7 = xmlStringCurrentChar(0, v3, &len);
  signed int v8 = v7;
  if (v7 > 255)
  {
    if (xmlCharInRange(v7, &xmlIsBaseCharGroup)) {
      BOOL v10 = 1;
    }
    else {
      BOOL v10 = (v8 - 12330) > 0xFFFFFFF6;
    }
    if (!v10 && v8 != 12295 && (v8 - 40870) < 0xFFFFAE5A) {
      return 0;
    }
  }
  else if ((v7 - 192) >= 0x17 {
         && (v7 & 0xFFFFFFDF) - 65 >= 0x1A
  }
         && v7 <= 247
         && (v7 - 216) >= 0x1F
         && v7 != 95
         && v7 != 58)
  {
    return 0;
  }
  for (uint64_t i = v3; ; v8 = xmlStringCurrentChar(0, i, &len))
  {
    if (v8 > 255)
    {
      if (xmlCharInRange(v8, &xmlIsBaseCharGroup)) {
        BOOL v14 = 0;
      }
      else {
        BOOL v14 = (v8 - 12321) >= 9;
      }
      BOOL v16 = v14 && v8 != 12295 && (v8 - 19968) >= 0x51A6;
      if (!v16 || xmlCharInRange(v8, &xmlIsDigitGroup)) {
        goto LABEL_48;
      }
    }
    else if ((v8 - 192) < 0x17 {
           || (v8 & 0xFFFFFFDF) - 65 < 0x1A
    }
           || (v8 - 48) < 0xA
           || v8 > 247
           || (v8 - 216) < 0x1F)
    {
      goto LABEL_48;
    }
    if ((v8 - 45) <= 0x32 && ((1 << (v8 - 45)) & 0x4000000000003) != 0) {
      goto LABEL_48;
    }
    if (v8 >= 256) {
      break;
    }
    if (v8 != 183) {
      goto LABEL_54;
    }
LABEL_48:
    i += len;
  }
  if (xmlCharInRange(v8, &xmlIsCombiningGroup) || xmlCharInRange(v8, &xmlIsExtenderGroup)) {
    goto LABEL_48;
  }
LABEL_54:
  uint64_t v17 = (xmlDict *)a1[3];
  if (v17) {
    uint64_t result = (void *)xmlDictLookup(v17, v3, (int)i - (int)v2);
  }
  else {
    uint64_t result = xmlStrndup(v3, (int)i - (int)v2);
  }
  *a1 = i;
  return result;
}

_OWORD *xmlNewStreamComp(int a1)
{
  if (a1 <= 4) {
    unsigned int v1 = 4;
  }
  else {
    unsigned int v1 = a1;
  }
  xmlStreamCtxtPtr v2 = xmlMalloc(0x20uLL);
  unsigned int v3 = v2;
  if (v2)
  {
    *xmlStreamCtxtPtr v2 = 0u;
    v2[1] = 0u;
    unsigned int v4 = xmlMalloc(32 * v1);
    *((void *)v3 + 2) = v4;
    if (v4)
    {
      *((_DWORD *)v3 + 2) = 0;
      *((_DWORD *)v3 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = v1;
    }
    else
    {
      xmlFree(v3);
      return 0;
    }
  }
  return v3;
}

uint64_t xmlStreamCompAddStep(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t result = *(unsigned int *)(a1 + 8);
  uint64_t v11 = *(int *)(a1 + 12);
  if ((int)result < (int)v11)
  {
    uint64_t v12 = *(char **)(a1 + 16);
LABEL_5:
    *(_DWORD *)(a1 + 8) = result + 1;
    BOOL v14 = &v12[32 * (int)result];
    *(_DWORD *)BOOL v14 = a5;
    *((void *)v14 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = a2;
    *((void *)v14 + 2) = a3;
    *((_DWORD *)v14 + 6) = a4;
    return result;
  }
  char v13 = (char *)xmlRealloc(*(void **)(a1 + 16), v11 << 6);
  if (v13)
  {
    uint64_t v12 = v13;
    *(void *)(a1 + 16) = v13;
    uint64_t result = *(unsigned int *)(a1 + 8);
    *(_DWORD *)(a1 + 12) *= 2;
    goto LABEL_5;
  }
  return 0xFFFFFFFFLL;
}

void xmlRelaxNGFree(xmlRelaxNGPtr schema)
{
  if (schema)
  {
    xmlStreamCtxtPtr v2 = (void *)*((void *)schema + 1);
    if (v2) {
      xmlRelaxNGFreeGrammar(v2);
    }
    unsigned int v3 = (xmlDoc *)*((void *)schema + 2);
    if (v3) {
      xmlFreeDoc(v3);
    }
    unsigned int v4 = (void *)*((void *)schema + 6);
    if (v4)
    {
      do
      {
        uint64_t v5 = (void *)*v4;
        xmlRelaxNGFreeDocument(v4);
        unsigned int v4 = v5;
      }
      while (v5);
    }
    uint64_t v6 = (void *)*((void *)schema + 7);
    if (v6)
    {
      do
      {
        signed int v7 = (void *)*v6;
        xmlRelaxNGFreeInclude(v6);
        uint64_t v6 = v7;
      }
      while (v7);
    }
    signed int v8 = (void *)*((void *)schema + 9);
    if (v8)
    {
      if (*((int *)schema + 16) >= 1)
      {
        uint64_t v9 = 0;
        do
          xmlRelaxNGFreeDefine(*(void *)(*((void *)schema + 9) + 8 * v9++));
        while (v9 < *((int *)schema + 16));
        signed int v8 = (void *)*((void *)schema + 9);
      }
      xmlFree(v8);
    }
    xmlFreeFunc v10 = xmlFree;
    ((void (*)(xmlRelaxNGPtr))v10)(schema);
  }
}

uint64_t xmlRelaxNGFreeGrammar(void *a1)
{
  if (a1[1]) {
    xmlRelaxNGFreeGrammar();
  }
  if (a1[2]) {
    xmlRelaxNGFreeGrammar();
  }
  xmlStreamCtxtPtr v2 = (xmlHashTable *)a1[7];
  if (v2) {
    xmlHashFree(v2, 0);
  }
  unsigned int v3 = (xmlHashTable *)a1[6];
  if (v3) {
    xmlHashFree(v3, 0);
  }
  xmlFreeFunc v4 = xmlFree;

  return ((uint64_t (*)(void *))v4)(a1);
}

uint64_t xmlRelaxNGFreeDefine(uint64_t result)
{
  if (!result) {
    return result;
  }
  uint64_t v1 = result;
  if (*(_DWORD *)result == 7)
  {
    if (*(void *)(result + 72))
    {
      uint64_t v2 = *(void *)(result + 40);
      if (v2)
      {
        unsigned int v3 = *(void (**)(void))(v2 + 48);
        if (v3) {
          v3(*(void *)(v2 + 8));
        }
      }
    }
  }
  xmlFreeFunc v4 = *(xmlHashTable **)(v1 + 40);
  if (v4)
  {
    int v5 = *(_DWORD *)v1;
    if (*(_DWORD *)v1 != 19) {
      goto LABEL_11;
    }
    xmlRelaxNGFreePartition((uint64_t)v4);
    xmlFreeFunc v4 = *(xmlHashTable **)(v1 + 40);
    if (v4)
    {
      int v5 = *(_DWORD *)v1;
LABEL_11:
      if (v5 == 17) {
        xmlHashFree(v4, 0);
      }
    }
  }
  uint64_t v6 = *(void **)(v1 + 16);
  if (v6) {
    xmlFree(v6);
  }
  signed int v7 = *(void **)(v1 + 24);
  if (v7) {
    xmlFree(v7);
  }
  signed int v8 = *(void **)(v1 + 32);
  if (v8) {
    xmlFree(v8);
  }
  uint64_t v9 = *(xmlRegexp **)(v1 + 104);
  if (v9) {
    xmlRegFreeRegexp(v9);
  }
  xmlFreeFunc v10 = xmlFree;

  return ((uint64_t (*)(uint64_t))v10)(v1);
}

int xmlRelaxParserSetFlag(xmlRelaxNGParserCtxtPtr ctxt, int flag)
{
  if (!ctxt) {
    return -1;
  }
  if (flag)
  {
    *((_DWORD *)ctxt + 62) |= 1u;
    --flag;
  }
  if ((flag & 2) != 0)
  {
    *((_DWORD *)ctxt + 62) |= 2u;
    flag -= 2;
  }
  if (flag) {
    return -1;
  }
  else {
    return 0;
  }
}

int xmlRelaxNGInitTypes(void)
{
  if (xmlRelaxNGTypeInitialized) {
    return 0;
  }
  xmlRelaxNGRegisteredTypes = (uint64_t)xmlHashCreate(10);
  if (xmlRelaxNGRegisteredTypes)
  {
    xmlRelaxNGRegisterTypeLibrary((uint64_t)"http://www.w3.org/2001/XMLSchema-datatypes", xmlRelaxNGSchemaTypeHave, xmlRelaxNGSchemaTypeCheck, xmlRelaxNGSchemaTypeCompare, xmlRelaxNGSchemaFacetCheck, xmlRelaxNGSchemaFreeValue);
    xmlRelaxNGRegisterTypeLibrary((uint64_t)"http://relaxng.org/ns/structure/1.0", xmlRelaxNGDefaultTypeHave, xmlRelaxNGDefaultTypeCheck, xmlRelaxNGDefaultTypeCompare, 0, 0);
    int result = 0;
    xmlRelaxNGTypeInitialized = 1;
  }
  else
  {
    xmlGenericErrorFunc v1 = *__xmlGenericError();
    uint64_t v2 = __xmlGenericErrorContext();
    v1(*v2, "Failed to allocate sh table for Relax-NG types\n");
    return -1;
  }
  return result;
}

uint64_t xmlRelaxNGRegisterTypeLibrary(uint64_t name, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  if (a4)
  {
    if (a3)
    {
      signed int v7 = (const char *)name;
      if (name)
      {
        name = xmlRelaxNGRegisteredTypes;
        if (xmlRelaxNGRegisteredTypes)
        {
          if (xmlHashLookup((xmlHashTablePtr)xmlRelaxNGRegisteredTypes, (const xmlChar *)v7))
          {
            xmlGenericErrorFunc v12 = *__xmlGenericError();
            char v13 = __xmlGenericErrorContext();
            return ((uint64_t (*)(void *, const char *, ...))v12)(*v13, "Relax-NG types library '%s' already registered\n", v7);
          }
          else
          {
            BOOL v14 = (void **)xmlMalloc(0x38uLL);
            if (v14)
            {
              unsigned int v15 = v14;
              v14[6] = 0;
              *((_OWORD *)v14 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0u;
              *((_OWORD *)v14 + 2) = 0u;
              *(_OWORD *)BOOL v14 = 0u;
              *BOOL v14 = xmlStrdup((const xmlChar *)v7);
              v15[1] = 0;
              v15[2] = a2;
              v15[3] = a3;
              v15[4] = a4;
              v15[5] = a5;
              _OWORD v15[6] = a6;
              name = xmlHashAddEntry((xmlHashTablePtr)xmlRelaxNGRegisteredTypes, (const xmlChar *)v7, v15);
              if ((name & 0x80000000) != 0)
              {
                xmlGenericErrorFunc v16 = *__xmlGenericError();
                uint64_t v17 = __xmlGenericErrorContext();
                v16(*v17, "Relax-NG types library failed to register '%s'\n", v7);
                if (*v15) {
                  xmlFree(*v15);
                }
                xmlFreeFunc v18 = xmlFree;
                return ((uint64_t (*)(void **))v18)(v15);
              }
            }
            else
            {
              return (uint64_t)xmlRngVErrMemory(0, (const xmlChar *)"adding types library\n");
            }
          }
        }
      }
    }
  }
  return name;
}

uint64_t xmlRelaxNGSchemaTypeHave(int a1, xmlChar *name)
{
  if (name) {
    return xmlSchemaGetPredefinedType(name, (const xmlChar *)"http://www.w3.org/2001/XMLSchema") != 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t xmlRelaxNGSchemaTypeCheck(int a1, xmlChar *name, const xmlChar *a3, xmlSchemaValPtr *a4, xmlNode *a5)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (name && a3)
  {
    PredefinedType = xmlSchemaGetPredefinedType(name, (const xmlChar *)"http://www.w3.org/2001/XMLSchema");
    if (PredefinedType)
    {
      int v10 = xmlSchemaValPredefTypeNode(PredefinedType, a3, a4, a5);
      if (v10 >= 1) {
        unsigned int v11 = 0;
      }
      else {
        unsigned int v11 = -1;
      }
      if (!v10) {
        unsigned int v11 = 1;
      }
      if (v10 == 2) {
        return 2;
      }
      else {
        return v11;
      }
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t xmlRelaxNGSchemaTypeCompare(int a1, xmlChar *name, const xmlChar *a3, xmlNode *a4, xmlSchemaVal *a5, const xmlChar *a6, xmlNode *a7)
{
  xmlSchemaValPtr y = 0;
  xmlSchemaValPtr val = 0;
  uint64_t result = 0xFFFFFFFFLL;
  if (name && a3 && a6)
  {
    PredefinedType = xmlSchemaGetPredefinedType(name, (const xmlChar *)"http://www.w3.org/2001/XMLSchema");
    if (!PredefinedType) {
      return 0xFFFFFFFFLL;
    }
    BOOL v14 = PredefinedType;
    if (a5)
    {
      xmlSchemaValPtr val = a5;
    }
    else
    {
      int v15 = xmlSchemaValPredefTypeNode(PredefinedType, a3, &val, a4);
      uint64_t result = 0xFFFFFFFFLL;
      if (v15 || !val) {
        return result;
      }
    }
    if (xmlSchemaValPredefTypeNode(v14, a6, &y, a7))
    {
      if (val != a5) {
        xmlSchemaFreeValue(val);
      }
      return 0xFFFFFFFFLL;
    }
    int v16 = xmlSchemaCompareValues(val, y);
    if (val != a5) {
      xmlSchemaFreeValue(val);
    }
    xmlSchemaFreeValue(y);
    if (v16 == -2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return v16 == 0;
    }
  }
  return result;
}

uint64_t xmlRelaxNGSchemaFacetCheck(int a1, xmlChar *name, const xmlChar *a3, const xmlChar *a4, const xmlChar *a5, xmlSchemaVal *a6)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (name && a5)
  {
    xmlSchemaTypePtr PredefinedType = xmlSchemaGetPredefinedType(name, (const xmlChar *)"http://www.w3.org/2001/XMLSchema");
    if (!PredefinedType) {
      return 0xFFFFFFFFLL;
    }
    char v13 = PredefinedType;
    xmlSchemaFacetPtr v14 = xmlSchemaNewFacet();
    if (!v14) {
      return 0xFFFFFFFFLL;
    }
    int v15 = v14;
    if (xmlStrEqual(a3, (const xmlChar *)"minInclusive"))
    {
      int v16 = 1000;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"minExclusive"))
    {
      int v16 = 1001;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"maxInclusive"))
    {
      int v16 = 1002;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"maxExclusive"))
    {
      int v16 = 1003;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"totalDigits"))
    {
      int v16 = 1004;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"fractionDigits"))
    {
      int v16 = 1005;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"pattern"))
    {
      int v16 = 1006;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"enumeration"))
    {
      int v16 = 1007;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"whiteSpace"))
    {
      int v16 = 1008;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"length"))
    {
      int v16 = 1009;
    }
    else if (xmlStrEqual(a3, (const xmlChar *)"maxLength"))
    {
      int v16 = 1010;
    }
    else
    {
      if (!xmlStrEqual(a3, (const xmlChar *)"minLength"))
      {
LABEL_30:
        xmlSchemaFreeFacet(v15);
        return 0xFFFFFFFFLL;
      }
      int v16 = 1011;
    }
    v15->unsigned int type = v16;
    v15->unsigned int value = a4;
    if (xmlSchemaCheckFacet(v15, v13, 0, name)) {
      goto LABEL_30;
    }
    int v17 = xmlSchemaValidateFacet(v13, v15, a5, a6);
    xmlSchemaFreeFacet(v15);
    if (v17) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
  return result;
}

void xmlRelaxNGSchemaFreeValue(int a1, xmlSchemaValPtr val)
{
}

uint64_t xmlRelaxNGDefaultTypeHave(int a1, xmlChar *str1)
{
  if (!str1) {
    return 0xFFFFFFFFLL;
  }
  if (xmlStrEqual(str1, (const xmlChar *)"string")) {
    return 1;
  }
  return xmlStrEqual(str1, (const xmlChar *)"token") != 0;
}

uint64_t xmlRelaxNGDefaultTypeCheck(int a1, xmlChar *str1, uint64_t a3)
{
  if (!a3) {
    return 0xFFFFFFFFLL;
  }
  if (xmlStrEqual(str1, (const xmlChar *)"string")) {
    return 1;
  }
  return xmlStrEqual(str1, (const xmlChar *)"token") != 0;
}

uint64_t xmlRelaxNGDefaultTypeCompare(int a1, xmlChar *str1, xmlChar *a3, uint64_t a4, uint64_t a5, xmlChar *a6)
{
  if (!xmlStrEqual(str1, (const xmlChar *)"string"))
  {
    if (!xmlStrEqual(str1, (const xmlChar *)"token")) {
      return 0xFFFFFFFFLL;
    }
    if (xmlStrEqual(a3, a6)) {
      return 1;
    }
    unsigned int v11 = xmlRelaxNGNormalize(0, a3);
    xmlGenericErrorFunc v12 = xmlRelaxNGNormalize(0, a6);
    char v13 = (xmlChar *)v12;
    if (v11 && v12)
    {
      uint64_t v10 = xmlStrEqual(v11, v12) != 0;
    }
    else
    {
      uint64_t v10 = 0xFFFFFFFFLL;
      if (!v11) {
        goto LABEL_14;
      }
    }
    xmlFree(v11);
LABEL_14:
    if (v13) {
      xmlFree(v13);
    }
    return v10;
  }

  return xmlStrEqual(a3, a6);
}

void xmlRelaxNGCleanupTypes(void)
{
  if (xmlRelaxNGTypeInitialized == 1)
  {
    xmlHashFree((xmlHashTablePtr)xmlRelaxNGRegisteredTypes, (xmlHashDeallocator)xmlRelaxNGFreeTypeLibrary);
    xmlRelaxNGTypeInitialized = 0;
  }
}

void **xmlRelaxNGFreeTypeLibrary(void **result)
{
  if (result)
  {
    xmlGenericErrorFunc v1 = result;
    uint64_t v2 = *result;
    if (v2) {
      xmlFree(v2);
    }
    xmlFreeFunc v3 = xmlFree;
    return (void **)((uint64_t (*)(void **))v3)(v1);
  }
  return result;
}

xmlRelaxNGParserCtxtPtr xmlRelaxNGNewParserCtxt(const char *URL)
{
  if (!URL) {
    return 0;
  }
  uint64_t v2 = xmlMalloc(0x100uLL);
  xmlFreeFunc v3 = v2;
  if (v2)
  {
    v2[14] = 0u;
    v2[15] = 0u;
    v2[12] = 0u;
    v2[13] = 0u;
    v2[10] = 0u;
    v2[11] = 0u;
    v2[8] = 0u;
    v2[9] = 0u;
    v2[6] = 0u;
    v2[7] = 0u;
    v2[4] = 0u;
    v2[5] = 0u;
    v2[2] = 0u;
    v2[3] = 0u;
    *uint64_t v2 = 0u;
    v2[1] = 0u;
    *((void *)v2 + 16) = xmlStrdup((const xmlChar *)URL);
    *((void *)v3 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = *__xmlGenericError();
    *(void *)xmlFreeFunc v3 = *__xmlGenericErrorContext();
  }
  else
  {
    xmlRngPErrMemory(0, (const xmlChar *)"building parser\n");
  }
  return (xmlRelaxNGParserCtxtPtr)v3;
}

_DWORD *xmlRngPErrMemory(uint64_t a1, const xmlChar *a2)
{
  if (a1)
  {
    uint64_t v3 = a1;
    a1 = *(void *)(a1 + 24);
    if (a1) {
      xmlFreeFunc v4 = 0;
    }
    else {
      xmlFreeFunc v4 = *(void (**)(void *, const char *, ...))(v3 + 8);
    }
    int v5 = *(void **)v3;
    ++*(_DWORD *)(v3 + 68);
    if (a2) {
      return __xmlRaiseError((xmlStructuredErrorFunc)a1, v4, v5, 0, 0, 0x12u, 2, 3, 0, 0, a2, 0, 0, 0, 0, "Memory allocation failed : %s\n", (char)a2);
    }
    return __xmlRaiseError((xmlStructuredErrorFunc)a1, v4, v5, 0, 0, 0x12u, 2, 3, 0, 0, 0, 0, 0, 0, 0, "Memory allocation failed\n", v7);
  }
  xmlFreeFunc v4 = 0;
  int v5 = 0;
  if (!a2) {
    return __xmlRaiseError((xmlStructuredErrorFunc)a1, v4, v5, 0, 0, 0x12u, 2, 3, 0, 0, 0, 0, 0, 0, 0, "Memory allocation failed\n", v7);
  }
  return __xmlRaiseError((xmlStructuredErrorFunc)a1, v4, v5, 0, 0, 0x12u, 2, 3, 0, 0, a2, 0, 0, 0, 0, "Memory allocation failed : %s\n", (char)a2);
}

xmlRelaxNGParserCtxtPtr xmlRelaxNGNewMemParserCtxt(const char *buffer, int size)
{
  uint64_t v2 = 0;
  if (buffer && size >= 1)
  {
    int v5 = (xmlRelaxNGParserCtxt *)xmlMalloc(0x100uLL);
    uint64_t v2 = v5;
    if (v5)
    {
      *((_OWORD *)v5 + 14) = 0u;
      *((_OWORD *)v5 + 15) = 0u;
      *((_OWORD *)v5 + 12) = 0u;
      *((_OWORD *)v5 + 1xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0u;
      *((_OWORD *)v5 + 10) = 0u;
      *((_OWORD *)v5 + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0u;
      *((_OWORD *)v5 + 8) = 0u;
      *((_OWORD *)v5 + 9) = 0u;
      *((_OWORD *)v5 + 6) = 0u;
      *((_OWORD *)v5 + 7) = 0u;
      *((_OWORD *)v5 + 4) = 0u;
      *((_OWORD *)v5 + 5) = 0u;
      *((_OWORD *)v5 + 2) = 0u;
      *((_OWORD *)v5 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0u;
      *(_OWORD *)int v5 = 0u;
      *((_OWORD *)v5 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0u;
      *((void *)v5 + 20) = buffer;
      *((_DWORD *)v5 + 42) = size;
      *((void *)v5 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = *__xmlGenericError();
      *(void *)uint64_t v2 = *__xmlGenericErrorContext();
    }
    else
    {
      xmlRngPErrMemory(0, (const xmlChar *)"building parser\n");
    }
  }
  return v2;
}

xmlRelaxNGParserCtxtPtr xmlRelaxNGNewDocParserCtxt(xmlDocPtr doc)
{
  if (!doc) {
    return 0;
  }
  xmlDocPtr v1 = xmlCopyDoc(doc, 1);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = v1;
  uint64_t v3 = (xmlRelaxNGParserCtxt *)xmlMalloc(0x100uLL);
  xmlFreeFunc v4 = v3;
  if (v3)
  {
    *((_OWORD *)v3 + 14) = 0u;
    *((_OWORD *)v3 + 15) = 0u;
    *((_OWORD *)v3 + 12) = 0u;
    *((_OWORD *)v3 + 1xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0u;
    *((_OWORD *)v3 + 10) = 0u;
    *((_OWORD *)v3 + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0u;
    *((_OWORD *)v3 + 8) = 0u;
    *((_OWORD *)v3 + 9) = 0u;
    *((_OWORD *)v3 + 6) = 0u;
    *((_OWORD *)v3 + 7) = 0u;
    *((_OWORD *)v3 + 4) = 0u;
    *((_OWORD *)v3 + 5) = 0u;
    *((_OWORD *)v3 + 2) = 0u;
    *((_OWORD *)v3 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0u;
    *(_OWORD *)uint64_t v3 = 0u;
    *((_OWORD *)v3 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0u;
    *((void *)v3 + 17) = v2;
    *((_DWORD *)v3 + 6xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 1;
    *(void *)uint64_t v3 = *__xmlGenericErrorContext();
  }
  else
  {
    xmlRngPErrMemory(0, (const xmlChar *)"building parser\n");
    xmlFreeDoc(v2);
  }
  return v4;
}

void xmlRelaxNGFreeParserCtxt(xmlRelaxNGParserCtxtPtr ctxt)
{
  if (ctxt)
  {
    uint64_t v2 = (void *)*((void *)ctxt + 16);
    if (v2) {
      xmlFree(v2);
    }
    uint64_t v3 = (void *)*((void *)ctxt + 22);
    if (v3) {
      xmlRelaxNGFreeDocument(v3);
    }
    xmlFreeFunc v4 = (xmlHashTable *)*((void *)ctxt + 13);
    if (v4) {
      xmlHashFree(v4, 0);
    }
    int v5 = (void *)*((void *)ctxt + 14);
    if (v5)
    {
      do
      {
        uint64_t v6 = (void *)*v5;
        xmlRelaxNGFreeDocument(v5);
        int v5 = v6;
      }
      while (v6);
    }
    char v7 = (void *)*((void *)ctxt + 15);
    if (v7)
    {
      do
      {
        signed int v8 = (void *)*v7;
        xmlRelaxNGFreeInclude(v7);
        char v7 = v8;
      }
      while (v8);
    }
    uint64_t v9 = (void *)*((void *)ctxt + 24);
    if (v9) {
      xmlFree(v9);
    }
    uint64_t v10 = (void *)*((void *)ctxt + 27);
    if (v10) {
      xmlFree(v10);
    }
    unsigned int v11 = (void *)*((void *)ctxt + 19);
    if (v11)
    {
      if (*((int *)ctxt + 36) >= 1)
      {
        uint64_t v12 = 0;
        do
          xmlRelaxNGFreeDefine(*(void *)(*((void *)ctxt + 19) + 8 * v12++));
        while (v12 < *((int *)ctxt + 36));
        unsigned int v11 = (void *)*((void *)ctxt + 19);
      }
      xmlFree(v11);
    }
    char v13 = (xmlDoc *)*((void *)ctxt + 17);
    if (v13 && *((_DWORD *)ctxt + 63)) {
      xmlFreeDoc(v13);
    }
    xmlFreeFunc v14 = xmlFree;
    ((void (*)(xmlRelaxNGParserCtxtPtr))v14)(ctxt);
  }
}

uint64_t xmlRelaxNGFreeDocument(void *a1)
{
  uint64_t v2 = (void *)a1[1];
  if (v2) {
    xmlFree(v2);
  }
  uint64_t v3 = (xmlDoc *)a1[2];
  if (v3) {
    xmlFreeDoc(v3);
  }
  uint64_t v4 = a1[4];
  if (v4)
  {
    int v5 = *(xmlDoc **)(v4 + 16);
    if (v5) {
      xmlFreeDoc(v5);
    }
    uint64_t v6 = *(void **)(v4 + 72);
    if (v6)
    {
      if (*(int *)(v4 + 64) >= 1)
      {
        uint64_t v7 = 0;
        do
          xmlRelaxNGFreeDefine(*(void *)(*(void *)(v4 + 72) + 8 * v7++));
        while (v7 < *(int *)(v4 + 64));
        uint64_t v6 = *(void **)(v4 + 72);
      }
      xmlFree(v6);
    }
    xmlFree((void *)v4);
  }
  xmlFreeFunc v8 = xmlFree;

  return ((uint64_t (*)(void *))v8)(a1);
}

xmlRelaxNGPtr xmlRelaxNGParse(xmlRelaxNGParserCtxtPtr ctxt)
{
  xmlRelaxNGInitTypes();
  if (!ctxt) {
    return 0;
  }
  uint64_t v2 = (const char *)*((void *)ctxt + 16);
  if (!v2)
  {
    xmlFreeFunc v8 = (const char *)*((void *)ctxt + 20);
    if (v8)
    {
      MemorxmlSchemaValPtr y = xmlReadMemory(v8, *((_DWORD *)ctxt + 42), 0, 0, 0);
      if (Memory)
      {
        Memory->URL = xmlStrdup((const xmlChar *)"in_memory_buffer");
        *((void *)ctxt + 16) = xmlStrdup((const xmlChar *)"in_memory_buffer");
        goto LABEL_9;
      }
      int v5 = "xmlRelaxNGParse: could not parse schemas\n";
      xmlRelaxNGParserCtxtPtr v6 = ctxt;
      int v7 = 1065;
    }
    else
    {
      MemorxmlSchemaValPtr y = (xmlDoc *)*((void *)ctxt + 17);
      if (Memory) {
        goto LABEL_9;
      }
      int v5 = "xmlRelaxNGParse: nothing to parse\n";
      xmlRelaxNGParserCtxtPtr v6 = ctxt;
      int v7 = 1022;
    }
    uint64_t v4 = 0;
    goto LABEL_32;
  }
  MemorxmlSchemaValPtr y = xmlReadFile(v2, 0, 0);
  if (!Memory)
  {
    uint64_t v4 = (const xmlChar *)*((void *)ctxt + 16);
    int v5 = "xmlRelaxNGParse: could not load %s\n";
    xmlRelaxNGParserCtxtPtr v6 = ctxt;
    int v7 = 1065;
LABEL_32:
    xmlRngPErr((uint64_t)v6, 0, v7, v5, v4, 0);
    return (xmlRelaxNGPtr)Memory;
  }
LABEL_9:
  *((void *)ctxt + 17) = Memory;
  uint64_t v9 = xmlRelaxNGCleanupDoc((uint64_t)ctxt, Memory);
  if (!v9)
  {
LABEL_21:
    xmlFreeDoc(*((xmlDocPtr *)ctxt + 17));
    MemorxmlSchemaValPtr y = 0;
LABEL_22:
    *((void *)ctxt + 17) = 0;
    return (xmlRelaxNGPtr)Memory;
  }
  uint64_t v10 = v9;
  xmlNodePtr RootElement = xmlDocGetRootElement(v9);
  if (!RootElement)
  {
    if (*((void *)ctxt + 16)) {
      char v13 = (const xmlChar *)*((void *)ctxt + 16);
    }
    else {
      char v13 = (const xmlChar *)"schemas";
    }
    xmlRngPErr((uint64_t)ctxt, (uint64_t)v10, 1022, "xmlRelaxNGParse: %s is empty\n", v13, 0);
    goto LABEL_21;
  }
  MemorxmlSchemaValPtr y = (xmlDoc *)xmlRelaxNGParseDocument((uint64_t)ctxt, (uint64_t)RootElement);
  if (!Memory)
  {
    xmlFreeDoc(*((xmlDocPtr *)ctxt + 17));
    goto LABEL_22;
  }
  uint64_t v12 = (xmlHashTable *)*((void *)ctxt + 13);
  if (v12) {
    xmlHashScan(v12, (xmlHashScanner)xmlRelaxNGComputeInterleaves, ctxt);
  }
  if (*((int *)ctxt + 17) >= 1)
  {
    xmlRelaxNGFree((xmlRelaxNGPtr)Memory);
    *((void *)ctxt + 17) = 0;
    xmlFreeDoc(v10);
    return 0;
  }
  uint64_t v14 = *(void *)&Memory->type;
  if (v14)
  {
    int v15 = *(_DWORD **)(v14 + 24);
    if (v15)
    {
      if (*v15 != 20)
      {
        int v16 = xmlRelaxNGNewDefine((uint64_t)ctxt, 0);
        uint64_t v17 = *(void *)&Memory->type;
        if (v16)
        {
          int v15 = v16;
          *(_DWORD *)int v16 = 20;
          *((void *)v16 + 6) = *(void *)(v17 + 24);
          *(void *)(v17 + 24) = v16;
        }
        else
        {
          int v15 = *(_DWORD **)(v17 + 24);
        }
      }
      xmlRelaxNGTryCompile((uint64_t)ctxt, (uint64_t)v15);
    }
  }
  Memory->name = (char *)v10;
  *((void *)ctxt + 17) = 0;
  long long v19 = *((_OWORD *)ctxt + 7);
  *((void *)ctxt + 14) = 0;
  *(_OWORD *)&Memory->xmlNodePtr next = v19;
  *((void *)ctxt + 15) = 0;
  LODWORD(Memory->doc) = *((_DWORD *)ctxt + 36);
  *(void *)&Memory->compression = *((void *)ctxt + 19);
  *((void *)ctxt + 19) = 0;
  if (*((_DWORD *)ctxt + 56) == 1) {
    LODWORD(Memory->children) = 1;
  }
  return (xmlRelaxNGPtr)Memory;
}

_DWORD *xmlRngPErr(uint64_t a1, uint64_t a2, int a3, const char *a4, const xmlChar *a5, xmlChar *a6)
{
  if (a1)
  {
    uint64_t v8 = a1;
    a1 = *(void *)(a1 + 24);
    if (a1) {
      uint64_t v9 = 0;
    }
    else {
      uint64_t v9 = *(void (**)(void *, const char *, ...))(v8 + 8);
    }
    uint64_t v10 = *(void **)v8;
    ++*(_DWORD *)(v8 + 68);
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
  }
  return __xmlRaiseError((xmlStructuredErrorFunc)a1, v9, v10, 0, a2, 0x12u, a3, 2, 0, 0, a5, a6, 0, 0, 0, a4, (char)a5);
}

xmlDoc *xmlRelaxNGCleanupDoc(uint64_t a1, xmlDoc *doc)
{
  uint64_t v2 = doc;
  xmlNodePtr RootElement = xmlDocGetRootElement(doc);
  if (RootElement)
  {
    xmlRelaxNGCleanupTree(a1, (uint64_t)RootElement);
  }
  else
  {
    xmlRngPErr(a1, (uint64_t)v2, 1022, "xmlRelaxNGParse: %s is empty\n", *(const xmlChar **)(a1 + 128), 0);
    return 0;
  }
  return v2;
}

_OWORD *xmlRelaxNGParseDocument(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = xmlMalloc(0x50uLL);
  int v5 = v4;
  if (v4)
  {
    v4[3] = 0u;
    v4[4] = 0u;
    v4[1] = 0u;
    v4[2] = 0u;
    _OWORD *v4 = 0u;
    uint64_t v6 = *(void *)(a1 + 80);
    *(void *)(a1 + 80) = 0;
    if (*(void *)(a2 + 72)
      && *(_DWORD *)(a2 + 8) == 1
      && xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"grammar")
      && xmlStrEqual(*(const xmlChar **)(*(void *)(a2 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      int v7 = xmlRelaxNGParseGrammar(a1, *(void *)(a2 + 24));
      *((void *)v5 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v7;
      if (!v7) {
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v8 = xmlRelaxNGNewGrammar(a1);
      *((void *)v5 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v8;
      if (!v8)
      {
LABEL_14:
        xmlRelaxNGFree((xmlRelaxNGPtr)v5);
        return 0;
      }
      uint64_t v9 = *(void *)(a1 + 48);
      *(void *)uint64_t v8 = v9;
      if (v9)
      {
        uint64_t v10 = *(void *)(v9 + 8);
        if (v10)
        {
          do
          {
            uint64_t v11 = v10;
            uint64_t v10 = *(void *)(v10 + 16);
          }
          while (v10);
          *(void *)(v11 + 16) = v8;
        }
        else
        {
          *(void *)(v9 + 8) = v8;
        }
        *(void *)(a1 + 48) = v8;
        xmlRelaxNGParseStart(a1, a2);
        *(void *)(a1 + 48) = v9;
      }
      else
      {
        *(void *)(a1 + 48) = v8;
        xmlRelaxNGParseStart(a1, a2);
      }
    }
    *(void *)(a1 + 80) = v6;
    uint64_t v12 = *(int **)(*((void *)v5 + 1) + 24);
    if (v12)
    {
      xmlRelaxNGCheckCycles(a1, v12, 0);
      if ((*(unsigned char *)(a1 + 64) & 0x80) == 0)
      {
        xmlRelaxNGSimplify(a1, *(void *)(*((void *)v5 + 1) + 24), 0);
        uint64_t v13 = *((void *)v5 + 1);
        for (uint64_t i = *(void *)(v13 + 24); i; *(void *)(v13 + 24) = i)
        {
          if (*(_DWORD *)i != -1) {
            break;
          }
          if (!*(void *)(i + 64)) {
            break;
          }
          uint64_t i = *(void *)(i + 48);
        }
        xmlRelaxNGCheckRules(a1, (unsigned int *)i, 16, -1);
      }
    }
  }
  else
  {
    xmlRngPErrMemory(a1, 0);
  }
  return v5;
}

uint64_t xmlRelaxNGComputeInterleaves(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 68)) {
    return result;
  }
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 48);
  if (v4)
  {
    size_t v5 = 0;
    do
    {
      uint64_t v4 = *(void *)(v4 + 64);
      v5 += 8;
    }
    while (v4);
  }
  else
  {
    size_t v5 = 0;
  }
  uint64_t v6 = (void ***)xmlMalloc(v5);
  if (v6)
  {
    int v7 = v6;
    uint64_t v8 = *(void **)(v3 + 48);
    if (v8)
    {
      uint64_t v9 = 0;
      int v10 = 0;
      while (1)
      {
        uint64_t v11 = (void **)xmlMalloc(0x18uLL);
        v7[v9] = v11;
        if (!v11) {
          break;
        }
        if (*(_DWORD *)v8 == 3) {
          ++v10;
        }
        void *v11 = v8;
        v7[v9][1] = xmlRelaxNGGetElements(a2, v8, 2);
        v7[v9++][2] = xmlRelaxNGGetElements(a2, v8, 1);
        uint64_t v8 = (void *)v8[8];
        if (!v8) {
          goto LABEL_20;
        }
      }
LABEL_62:
      xmlRngPErrMemory(a2, (const xmlChar *)"in interleave computation\n");
      if (v9)
      {
        uint64_t v30 = v9;
        int v31 = v7;
        do
        {
          uint64_t v32 = *v31;
          if (*v31)
          {
            if (v32[1])
            {
              xmlFree(v32[1]);
              uint64_t v32 = *v31;
            }
            xmlFree(v32);
          }
          ++v31;
          --v30;
        }
        while (v30);
      }
      xmlFreeFunc v33 = xmlFree;
      return ((uint64_t (*)(void ***))v33)(v7);
    }
    LODWORD(v9) = 0;
    int v10 = 0;
LABEL_20:
    uint64_t v12 = xmlMalloc(0x20uLL);
    if (!v12) {
      goto LABEL_62;
    }
    uint64_t v13 = v12;
    _OWORD *v12 = 0u;
    v12[1] = 0u;
    *(_DWORD *)uint64_t v12 = v9;
    uint64_t result = (uint64_t)xmlHashCreate(v9);
    *((void *)v13 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = result;
    int v35 = v10;
    if (!v9)
    {
      int v17 = 1;
LABEL_73:
      *((void *)v13 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = v7;
      *(void *)(v3 + 40) = v13;
      if (v35) {
        *(_WORD *)(v3 + 98) |= 8u;
      }
      if (v17 == 2)
      {
        int v34 = 3;
      }
      else
      {
        if (v17 != 1) {
          return result;
        }
        int v34 = 1;
      }
      *((_DWORD *)v13 + 4) = v34;
      return result;
    }
    unint64_t v14 = 0;
    unint64_t v15 = v9;
    unsigned int v36 = v7;
    int v37 = v7 + 1;
    uint64_t v16 = 1;
    int v17 = 1;
    while (1)
    {
      xmlFreeFunc v18 = v7[v14++];
      unint64_t v19 = v15;
      if (v14 < v15)
      {
        char v20 = v37;
        do
        {
          if (*v20)
          {
            if (!xmlRelaxNGCompareElemDefLists((uint64_t)v18[1], (void **)(*v20)[1])) {
              xmlRngPErr(a2, *(void *)(v3 + 8), 1021, "Element or text conflicts in interleave\n", 0, 0);
            }
            uint64_t result = xmlRelaxNGCompareElemDefLists((uint64_t)v18[2], (void **)(*v20)[2]);
            if (!result) {
              uint64_t result = (uint64_t)xmlRngPErr(a2, *(void *)(v3 + 8), 1001, "Attributes conflicts in interleave\n", 0, 0);
            }
          }
          ++v20;
          --v15;
        }
        while (v16 != v15);
      }
      unsigned int v21 = (uint64_t *)v18[1];
      if (v21)
      {
        uint64_t v22 = *v21;
        if (*v21) {
          break;
        }
      }
      int v17 = 0;
      unint64_t v15 = v19;
LABEL_60:
      ++v16;
      int v7 = v36;
      ++v37;
      if (v14 == v15) {
        goto LABEL_73;
      }
    }
    uint64_t v23 = v21 + 1;
    unint64_t v15 = v19;
    while (*(_DWORD *)v22 != 4)
    {
      if (*(_DWORD *)v22 == 3)
      {
        unsigned int v24 = (xmlHashTable *)*((void *)v13 + 1);
        xmlFreeFunc v25 = (const xmlChar *)"#text";
        goto LABEL_37;
      }
      int v17 = -1;
LABEL_57:
      uint64_t v29 = *v23++;
      uint64_t v22 = v29;
      if (!v29) {
        goto LABEL_60;
      }
    }
    xmlFreeFunc v25 = *(const xmlChar **)(v22 + 16);
    uint64_t v26 = *(const xmlChar **)(v22 + 24);
    if (v25)
    {
      if (v26)
      {
        unsigned int v24 = (xmlHashTable *)*((void *)v13 + 1);
        if (!*v26) {
LABEL_37:
        }
          uint64_t v26 = 0;
        uint64_t result = xmlHashAddEntry2(v24, v25, v26, (void *)v14);
        if (result) {
          int v17 = -1;
        }
        goto LABEL_57;
      }
      unsigned int v24 = (xmlHashTable *)*((void *)v13 + 1);
      goto LABEL_37;
    }
    if (v26)
    {
      uint64_t v27 = (xmlHashTable *)*((void *)v13 + 1);
      if (*v26) {
        goto LABEL_51;
      }
    }
    else
    {
      uint64_t v27 = (xmlHashTable *)*((void *)v13 + 1);
    }
    uint64_t v26 = 0;
LABEL_51:
    uint64_t result = xmlHashAddEntry2(v27, (const xmlChar *)"#any", v26, (void *)v14);
    if (*(void *)(*(v23 - 1) + 80)) {
      int v28 = 2;
    }
    else {
      int v28 = v17;
    }
    if (result) {
      int v17 = -1;
    }
    else {
      int v17 = v28;
    }
    goto LABEL_57;
  }

  return (uint64_t)xmlRngPErrMemory(a2, (const xmlChar *)"in interleave computation\n");
}

_OWORD *xmlRelaxNGNewDefine(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(int *)(a1 + 148);
  if (v4)
  {
    if ((int)v4 <= *(_DWORD *)(a1 + 144))
    {
      *(_DWORD *)(a1 + 148) = 2 * v4;
      size_t v5 = xmlRealloc(*(void **)(a1 + 152), 16 * v4);
      if (!v5) {
        goto LABEL_8;
      }
      *(void *)(a1 + 152) = v5;
    }
  }
  else
  {
    *(void *)(a1 + 144) = 0x1000000000;
    uint64_t v6 = xmlMalloc(0x80uLL);
    *(void *)(a1 + 152) = v6;
    if (!v6) {
      goto LABEL_8;
    }
  }
  uint64_t result = xmlMalloc(0x70uLL);
  if (result)
  {
    result[5] = 0u;
    result[6] = 0u;
    result[3] = 0u;
    result[4] = 0u;
    result[1] = 0u;
    result[2] = 0u;
    _OWORD *result = 0u;
    uint64_t v8 = *(void *)(a1 + 152);
    uint64_t v9 = *(int *)(a1 + 144);
    *(_DWORD *)(a1 + 144) = v9 + 1;
    *(void *)(v8 + 8 * v9) = result;
    *((void *)result + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = a2;
    *((_WORD *)result + 48) = -1;
    return result;
  }
LABEL_8:
  xmlRngPErrMemory(a1, (const xmlChar *)"allocating define\n");
  return 0;
}

uint64_t xmlRelaxNGTryCompile(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = a2;
  while (1)
  {
    int v4 = *(_DWORD *)v2;
    if ((*(_DWORD *)v2 | 0x10) == 0x14)
    {
      uint64_t result = xmlRelaxNGIsCompilable((int *)v2);
      if ((*(_WORD *)(v2 + 98) & 0x40) != 0 && *(__int16 *)(v2 + 96) != -25)
      {
        *(void *)(a1 + 232) = 0;
        return xmlRelaxNGCompile(a1, v2);
      }
      int v4 = *(_DWORD *)v2;
    }
    else
    {
      uint64_t result = 0;
    }
    unsigned int v6 = v4 + 1;
    if (v6 > 0x15) {
      return result;
    }
    if (v6) {
      break;
    }
    uint64_t v2 = *(void *)(v2 + 48);
    if (!v2) {
      return 0xFFFFFFFFLL;
    }
  }
  if (((1 << v6) & 0x1007FE) != 0) {
    return 0;
  }
  uint64_t v7 = *(void *)(v2 + 48);
  if (v7)
  {
    while (1)
    {
      uint64_t result = xmlRelaxNGTryCompile(a1, v7);
      if (result) {
        break;
      }
      uint64_t v7 = *(void *)(v7 + 64);
      if (!v7) {
        return 0;
      }
    }
  }
  return result;
}

void xmlRelaxNGSetParserErrors(xmlRelaxNGParserCtxtPtr ctxt, xmlRelaxNGValidityErrorFunc err, xmlRelaxNGValidityWarningFunc warn, void *ctx)
{
  if (ctxt)
  {
    *((void *)ctxt + 2) = warn;
    *((void *)ctxt + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0;
    *(void *)ctxt = ctx;
    *((void *)ctxt + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = err;
  }
}

int xmlRelaxNGGetParserErrors(xmlRelaxNGParserCtxtPtr ctxt, xmlRelaxNGValidityErrorFunc *err, xmlRelaxNGValidityWarningFunc *warn, void **ctx)
{
  if (!ctxt) {
    return -1;
  }
  if (err) {
    *err = (xmlRelaxNGValidityErrorFunc)*((void *)ctxt + 1);
  }
  if (warn) {
    *warn = (xmlRelaxNGValidityWarningFunc)*((void *)ctxt + 2);
  }
  int v4 = 0;
  if (ctx) {
    *ctx = *(void **)ctxt;
  }
  return v4;
}

void xmlRelaxNGSetParserStructuredErrors(xmlRelaxNGParserCtxtPtr ctxt, xmlStructuredErrorFunc serror, void *ctx)
{
  if (ctxt)
  {
    *((void *)ctxt + 2) = 0;
    *((void *)ctxt + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = serror;
    *(void *)ctxt = ctx;
    *((void *)ctxt + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0;
  }
}

void xmlRelaxNGDump(FILE *output, xmlRelaxNGPtr schema)
{
  if (output)
  {
    if (schema)
    {
      fwrite("RelaxNG: ", 9uLL, 1uLL, output);
      uint64_t v4 = *((void *)schema + 2);
      if (v4)
      {
        size_t v5 = *(const char **)(v4 + 136);
        if (v5) {
          fprintf(output, "%s\n", v5);
        }
        else {
          fputc(10, output);
        }
      }
      else
      {
        fwrite("no document\n", 0xCuLL, 1uLL, output);
      }
      uint64_t v8 = *((void *)schema + 1);
      if (v8)
      {
        fwrite("<grammar", 8uLL, 1uLL, output);
        fwrite(" xmlns=\"http://relaxng.org/ns/structure/1.0\"", 0x2CuLL, 1uLL, output);
        int v9 = *(_DWORD *)(v8 + 32);
        if (v9)
        {
          if (v9 == 2)
          {
            int v10 = " combine=\"interleave\"";
            size_t v11 = 21;
          }
          else if (v9 == 1)
          {
            int v10 = " combine=\"choice\"";
            size_t v11 = 17;
          }
          else
          {
            int v10 = " <!-- invalid combine value -->";
            size_t v11 = 31;
          }
          fwrite(v10, v11, 1uLL, output);
        }
        fwrite(">\n", 2uLL, 1uLL, output);
        if (*(void *)(v8 + 24))
        {
          fwrite("<start>\n", 8uLL, 1uLL, output);
          xmlRelaxNGDumpDefine(output, *(void *)(v8 + 24));
          uint64_t v12 = "</start>\n";
          size_t v13 = 9;
        }
        else
        {
          uint64_t v12 = " <!-- grammar had no start -->";
          size_t v13 = 30;
        }
        fwrite(v12, v13, 1uLL, output);
        unsigned int v6 = "</grammar>\n";
        size_t v7 = 11;
      }
      else
      {
        unsigned int v6 = "RelaxNG has no top grammar\n";
        size_t v7 = 27;
      }
    }
    else
    {
      unsigned int v6 = "RelaxNG empty or failed to compile\n";
      size_t v7 = 35;
    }
    fwrite(v6, v7, 1uLL, output);
  }
}

void xmlRelaxNGDumpTree(FILE *output, xmlRelaxNGPtr schema)
{
  if (output)
  {
    if (schema)
    {
      uint64_t v3 = (xmlDoc *)*((void *)schema + 2);
      if (v3)
      {
        xmlDocDump(output, v3);
        return;
      }
      uint64_t v4 = "no document\n";
      size_t v5 = 12;
    }
    else
    {
      uint64_t v4 = "RelaxNG empty or failed to compile\n";
      size_t v5 = 35;
    }
    fwrite(v4, v5, 1uLL, output);
  }
}

int xmlRelaxNGValidatePushElement(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr elem)
{
  int v3 = -1;
  if (ctxt && elem)
  {
    xmlRelaxNGValidCtxtPtr v5 = ctxt;
    if (*((void *)ctxt + 17))
    {
LABEL_4:
      *((void *)v5 + 2htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = elem;
      *((_DWORD *)v5 + 40) = 0;
      xmlNsPtr ns = elem->ns;
      size_t v7 = (xmlRegExecCtxt *)*((void *)v5 + 17);
      name = elem->name;
      if (ns) {
        int v9 = xmlRegExecPushString2(v7, name, ns->href, v5);
      }
      else {
        int v9 = xmlRegExecPushString(v7, name, v5);
      }
      int v3 = v9;
      if ((v9 & 0x80000000) == 0)
      {
        int v17 = *((_DWORD *)v5 + 40);
        if (v17) {
          return (v17 >> 31) | 1;
        }
        else {
          return 0;
        }
      }
      uint64_t v16 = (xmlChar *)elem->name;
      ctxt = v5;
      int v15 = 38;
LABEL_19:
      xmlRelaxNGAddValidError((uint64_t)ctxt, v15, v16, 0, 0);
      return v3;
    }
    uint64_t v10 = *((void *)ctxt + 5);
    if (!v10 || (uint64_t v11 = *(void *)(v10 + 8)) == 0 || (v12 = *(void *)(v11 + 24)) == 0)
    {
      int v15 = 34;
      uint64_t v16 = 0;
      goto LABEL_19;
    }
    size_t v13 = *(xmlRegexp **)(v12 + 104);
    if (!v13)
    {
      int v3 = 0;
      *((void *)v5 + 22) = v12;
      return v3;
    }
    xmlRegExecCtxtPtr v14 = xmlRegNewExecCtxt(v13, (xmlRegExecCallbacks)xmlRelaxNGValidateProgressiveCallback, v5);
    if (v14)
    {
      xmlRelaxNGElemPush((uint64_t)v5, (uint64_t)v14);
      goto LABEL_4;
    }
  }
  return v3;
}

void xmlRelaxNGAddValidError(uint64_t a1, int a2, xmlChar *cur, xmlChar *a4, int a5)
{
  if (!a1 || (*(_DWORD *)(a1 + 56) & 8) != 0) {
    return;
  }
  if ((*(_DWORD *)(a1 + 56) & 3) == 1)
  {
    uint64_t v10 = *(char **)(a1 + 88);
    if (!v10)
    {
      *(void *)(a1 + 80) = 0x800000000;
      uint64_t v11 = (char *)xmlMalloc(0x140uLL);
      *(void *)(a1 + 88) = v11;
      if (!v11)
      {
LABEL_27:
        xmlRngVErrMemory(a1, (const xmlChar *)"pushing error\n");
        return;
      }
      uint64_t v10 = v11;
      *(void *)(a1 + 72) = 0;
    }
    int v12 = *(_DWORD *)(a1 + 80);
    uint64_t v13 = *(int *)(a1 + 84);
    if (v12 < (int)v13)
    {
      xmlRegExecCtxtPtr v14 = *(char **)(a1 + 72);
      if (!v14) {
        goto LABEL_19;
      }
      goto LABEL_16;
    }
    *(_DWORD *)(a1 + 84) = 2 * v13;
    xmlFreeFunc v18 = (char *)xmlRealloc(v10, 80 * v13);
    *(void *)(a1 + 88) = v18;
    if (v18)
    {
      uint64_t v10 = v18;
      int v12 = *(_DWORD *)(a1 + 80);
      xmlRegExecCtxtPtr v14 = &v18[40 * v12 - 40];
      *(void *)(a1 + 72) = v14;
      if (!v14)
      {
LABEL_19:
        int v20 = v12;
        unsigned int v21 = (int *)&v10[40 * v12];
        int *v21 = a2;
        if (a5)
        {
          *(void *)&v10[40 * v12 + 24] = xmlStrdup(cur);
          a4 = xmlStrdup(a4);
          int v22 = 1;
        }
        else
        {
          int v22 = 0;
          *(void *)&v10[40 * v20 + 24] = cur;
        }
        uint64_t v23 = &v10[40 * v20];
        *((void *)v23 + 4) = a4;
        *((_DWORD *)v23 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v22;
        unsigned int v24 = *(long long **)(a1 + 96);
        if (v24) {
          long long v25 = *v24;
        }
        else {
          long long v25 = 0uLL;
        }
        *(_OWORD *)&v10[40 * v20 + 8] = v25;
        *(void *)(a1 + 72) = v21;
        ++*(_DWORD *)(a1 + 80);
        return;
      }
LABEL_16:
      unint64_t v19 = *(void **)(a1 + 96);
      if (v19 && *((void *)v14 + 1) == *v19 && *(_DWORD *)v14 == a2) {
        return;
      }
      goto LABEL_19;
    }
    goto LABEL_27;
  }
  if (*(_DWORD *)(a1 + 80)) {
    xmlRelaxNGDumpValidError(a1);
  }
  int v15 = *(uint64_t **)(a1 + 96);
  if (v15)
  {
    uint64_t v16 = *v15;
    uint64_t v17 = v15[1];
  }
  else
  {
    uint64_t v16 = 0;
    uint64_t v17 = 0;
  }
  if (!(v16 | v17)) {
    uint64_t v16 = *(void *)(a1 + 168);
  }

  xmlRelaxNGShowValidError(a1, a2, v16, v17, cur, a4);
}

void xmlRelaxNGValidateProgressiveCallback(int a1, const char *a2, uint64_t a3, uint64_t a4)
{
  if (!a4)
  {
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "callback on %s missing context\n", a2);
    return;
  }
  uint64_t v6 = *(void *)(a4 + 168);
  *(_DWORD *)(a4 + 160) = 1;
  if (!a3)
  {
    if (*a2 == 35) {
      return;
    }
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "callback on %s missing define\n");
    goto LABEL_23;
  }
  if (*(_DWORD *)a3 != 4)
  {
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "callback on %s define is not element\n");
LABEL_23:
    if (!*(_DWORD *)(a4 + 68)) {
      *(_DWORD *)(a4 + 68) = 37;
    }
    goto LABEL_27;
  }
  if (*(_DWORD *)(v6 + 8) != 1)
  {
    xmlRelaxNGAddValidError(a4, 23, 0, 0, 0);
    if ((*(unsigned char *)(a4 + 56) & 1) == 0) {
      xmlRelaxNGDumpValidError(a4);
    }
LABEL_27:
    *(_DWORD *)(a4 + 160) = -1;
    return;
  }
  size_t v7 = *(xmlRegexp **)(a3 + 104);
  if (!v7)
  {
    *(_DWORD *)(a4 + 160) = 0;
    *(void *)(a4 + 176) = a3;
    return;
  }
  xmlRegExecCtxtPtr v8 = xmlRegNewExecCtxt(v7, (xmlRegExecCallbacks)xmlRelaxNGValidateProgressiveCallback, (void *)a4);
  if (!v8) {
    goto LABEL_27;
  }
  xmlRelaxNGElemPush(a4, (uint64_t)v8);
  int v9 = xmlRelaxNGNewValidState(a4, v6);
  if (!v9) {
    goto LABEL_27;
  }
  uint64_t v10 = *(void *)(a4 + 96);
  *(void *)(a4 + 96) = v9;
  uint64_t v11 = *(void *)(a3 + 72);
  if (!v11) {
    goto LABEL_12;
  }
  int v12 = xmlRelaxNGValidateAttributeList(a4, v11);
  if (v12)
  {
    *(_DWORD *)(a4 + 160) = -1;
    xmlRelaxNGAddValidError(a4, 24, *(xmlChar **)(v6 + 16), 0, 0);
  }
  int v9 = *(void **)(a4 + 96);
  if (!v9)
  {
    uint64_t v13 = *(int **)(a4 + 104);
    if (v13)
    {
      int v14 = *(_DWORD *)(a4 + 56);
      int v15 = v14;
      if (*v13 < 1)
      {
LABEL_36:
        *(_DWORD *)(a4 + 56) = v15 | 1;
        xmlRelaxNGLogBestError(a4);
        char v18 = 1;
      }
      else
      {
        uint64_t v16 = 0;
        while (1)
        {
          uint64_t v17 = *(void *)(*((void *)v13 + 1) + 8 * v16);
          *(void *)(a4 + 96) = v17;
          *(void *)(v17 + 8) = 0;
          if (!xmlRelaxNGValidateElementEnd(a4, 0)) {
            break;
          }
          ++v16;
          uint64_t v13 = *(int **)(a4 + 104);
          if (v16 >= *v13)
          {
            int v15 = *(_DWORD *)(a4 + 56);
            goto LABEL_36;
          }
        }
        char v18 = 0;
      }
      unint64_t v19 = *(int **)(a4 + 104);
      if (*v19 >= 1)
      {
        uint64_t v20 = 0;
        do
        {
          xmlRelaxNGFreeValidState((_DWORD *)a4, *(void *)(*((void *)v19 + 1) + 8 * v20++));
          unint64_t v19 = *(int **)(a4 + 104);
        }
        while (v20 < *v19);
      }
      xmlRelaxNGFreeStates((void *)a4, (uint64_t)v19);
      *(void *)(a4 + 104) = 0;
      char v21 = v18 ^ 1;
      if (v12) {
        char v21 = 1;
      }
      if ((v21 & 1) == 0) {
        *(_DWORD *)(a4 + 160) = -1;
      }
      *(_DWORD *)(a4 + 56) = v14;
    }
  }
  else
  {
LABEL_12:
    v9[1] = 0;
    if (xmlRelaxNGValidateElementEnd(a4, 1)) {
      *(_DWORD *)(a4 + 160) = -1;
    }
    xmlRelaxNGFreeValidState((_DWORD *)a4, *(void *)(a4 + 96));
  }
  if (*(_DWORD *)(a4 + 160) == -1 && (*(unsigned char *)(a4 + 56) & 1) == 0) {
    xmlRelaxNGDumpValidError(a4);
  }
  *(void *)(a4 + 96) = v10;
}

_DWORD *xmlRelaxNGElemPush(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(_DWORD **)(a1 + 152);
  if (result || (*(_DWORD *)(a1 + 148) = 10, uint64_t result = xmlMalloc(0x50uLL), (*(void *)(a1 + 152) = result) != 0))
  {
    int v5 = *(_DWORD *)(a1 + 144);
    uint64_t v6 = *(int *)(a1 + 148);
    if (v5 < (int)v6)
    {
LABEL_6:
      *(_DWORD *)(a1 + 144) = v5 + 1;
      *(void *)&result[2 * v5] = a2;
      *(void *)(a1 + 136) = a2;
      return result;
    }
    *(_DWORD *)(a1 + 148) = 2 * v6;
    uint64_t result = xmlRealloc(result, 16 * v6);
    *(void *)(a1 + 152) = result;
    if (result)
    {
      int v5 = *(_DWORD *)(a1 + 144);
      goto LABEL_6;
    }
  }

  return xmlRngVErrMemory(a1, (const xmlChar *)"validating\n");
}

int xmlRelaxNGValidatePushCData(xmlRelaxNGValidCtxtPtr ctxt, const xmlChar *data, int len)
{
  int v3 = -1;
  if (ctxt)
  {
    if (data)
    {
      int v5 = (xmlRegExecCtxt *)*((void *)ctxt + 17);
      if (v5)
      {
        while (1)
        {
          unsigned int v6 = *data;
          if (v6 > 0x20) {
            goto LABEL_8;
          }
          if (((1 << v6) & 0x100002600) == 0) {
            break;
          }
          ++data;
        }
        if (!*data) {
          return 1;
        }
LABEL_8:
        if ((xmlRegExecPushString(v5, (const xmlChar *)"#text", ctxt) & 0x80000000) == 0) {
          return 1;
        }
        xmlRelaxNGAddValidError((uint64_t)ctxt, 39, (xmlChar *)" TODO ", 0, 0);
        return -1;
      }
    }
  }
  return v3;
}

int xmlRelaxNGValidatePopElement(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr elem)
{
  int v3 = -1;
  if (ctxt && elem && *((void *)ctxt + 17))
  {
    int v5 = *((_DWORD *)ctxt + 36);
    unsigned int v6 = v5 - 1;
    if (v5 < 1)
    {
      xmlRegExecCtxtPtr v8 = 0;
    }
    else
    {
      *((_DWORD *)ctxt + 36) = v6;
      uint64_t v7 = *((void *)ctxt + 19);
      xmlRegExecCtxtPtr v8 = *(xmlRegExecCtxt **)(v7 + 8 * v6);
      *(void *)(v7 + 8 * v6) = 0;
      if (v5 == 1) {
        uint64_t v9 = 0;
      }
      else {
        uint64_t v9 = *(void *)(*((void *)ctxt + 19) + 8 * (v5 - 2));
      }
      *((void *)ctxt + 17) = v9;
    }
    int v10 = xmlRegExecPushString(v8, 0, 0);
    if (v10) {
      int v3 = (v10 >> 31) | 1;
    }
    else {
      xmlRelaxNGAddValidError((uint64_t)ctxt, 22, (xmlChar *)"", 0, 0);
    }
    xmlRegFreeExecCtxt(v8);
  }
  return v3;
}

int xmlRelaxNGValidateFullElement(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr elem)
{
  if (!ctxt) {
    return -1;
  }
  int v4 = -1;
  if (elem)
  {
    if (*((void *)ctxt + 22))
    {
      unsigned int v6 = xmlRelaxNGNewValidState((uint64_t)ctxt, (uint64_t)elem->parent);
      if (v6)
      {
        v6[1] = elem;
        *((void *)ctxt + 12) = v6;
        *((_DWORD *)ctxt + 17) = 0;
        if (!xmlRelaxNGValidateDefinition((uint64_t)ctxt, *((void *)ctxt + 22)))
        {
          if (*((_DWORD *)ctxt + 17)) {
            int v4 = -1;
          }
          else {
            int v4 = 1;
          }
        }
        xmlRelaxNGFreeValidState(ctxt, *((void *)ctxt + 12));
        *((void *)ctxt + 12) = 0;
      }
    }
  }
  return v4;
}

void *xmlRelaxNGNewValidState(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  memset(v18, 0, sizeof(v18));
  if (a2)
  {
    uint64_t v4 = *(void *)(a2 + 88);
    if (v4)
    {
      unint64_t v5 = 0;
      do
      {
        if (v5 <= 0x13) {
          *((void *)v18 + v5) = v4;
        }
        ++v5;
        uint64_t v4 = *(void *)(v4 + 48);
      }
      while (v4);
      xmlNodePtr v6 = 0;
    }
    else
    {
      LODWORD(v5) = 0;
      xmlNodePtr v6 = 0;
    }
  }
  else
  {
    xmlNodePtr RootElement = xmlDocGetRootElement(*(const xmlDoc **)(a1 + 48));
    if (!RootElement) {
      return 0;
    }
    xmlNodePtr v6 = RootElement;
    LODWORD(v5) = 0;
  }
  uint64_t v8 = *(void *)(a1 + 112);
  if (v8 && (unsigned int v9 = *(_DWORD *)v8 - 1, *(int *)v8 >= 1))
  {
    *(_DWORD *)uint64_t v8 = v9;
    int v10 = *(void **)(*(void *)(v8 + 8) + 8 * v9);
  }
  else
  {
    uint64_t v11 = xmlMalloc(0x38uLL);
    int v10 = v11;
    if (!v11) {
      goto LABEL_30;
    }
    v11[6] = 0;
    *((_OWORD *)v11 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0u;
    *((_OWORD *)v11 + 2) = 0u;
    *(_OWORD *)uint64_t v11 = 0u;
  }
  v10[4] = 0;
  v10[5] = 0;
  if (a2)
  {
    xmlNodePtr v6 = *(xmlNodePtr *)(a2 + 24);
    uint64_t v12 = a2;
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 48);
  }
  *int v10 = v12;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = 0;
  if (!v5) {
    goto LABEL_34;
  }
  uint64_t v13 = (void *)v10[6];
  if (v13)
  {
    if (*((_DWORD *)v10 + 5) >= (int)v5) {
      goto LABEL_28;
    }
    uint64_t v13 = xmlRealloc(v13, 8 * v5);
    if (v13)
    {
      v10[6] = v13;
      *((_DWORD *)v10 + 5) = v5;
LABEL_28:
      *((_DWORD *)v10 + 4) = v5;
      if (v5 > 0x13)
      {
        uint64_t v15 = *(void *)(a2 + 88);
        if (v15)
        {
          uint64_t v16 = 0;
          do
          {
            *(void *)(v10[6] + v16) = v15;
            uint64_t v15 = *(void *)(v15 + 48);
            v16 += 8;
          }
          while (v15);
        }
      }
      else
      {
        memcpy(v13, v18, 8 * v5);
        LODWORD(v5) = *((_DWORD *)v10 + 4);
      }
LABEL_34:
      *((_DWORD *)v10 + 6) = v5;
      return v10;
    }
  }
  else
  {
    if (v5 <= 4) {
      int v14 = 4;
    }
    else {
      int v14 = v5;
    }
    *((_DWORD *)v10 + 5) = v14;
    uint64_t v13 = xmlMalloc(8 * v14);
    v10[6] = v13;
    if (v13) {
      goto LABEL_28;
    }
  }
LABEL_30:
  xmlRngVErrMemory(a1, (const xmlChar *)"allocating states\n");
  return v10;
}

uint64_t xmlRelaxNGValidateDefinition(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (uint64_t *)(a1 + 96);
  if (*(void *)(a1 + 96) && *(void *)(a1 + 104))
  {
    xmlGenericErrorFunc v5 = *__xmlGenericError();
    xmlNodePtr v6 = __xmlGenericErrorContext();
    v5(*v6, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 10667);
    xmlRelaxNGFreeValidState((_DWORD *)a1, *(void *)(a1 + 96));
    *(void *)(a1 + 96) = 0;
  }
  uint64_t v8 = (uint64_t *)(a1 + 104);
  uint64_t v7 = *(int **)(a1 + 104);
  if (!v7) {
    goto LABEL_7;
  }
  int v9 = *v7;
  if (*v7 != 1)
  {
    *(void *)(a1 + 104) = 0;
    int v14 = *(_DWORD *)(a1 + 56);
    *(_DWORD *)(a1 + 56) = v14 | 1;
    if (v9 <= 0)
    {
      *(_DWORD *)(a1 + 56) = v14;
      goto LABEL_47;
    }
    int v33 = v14;
    uint64_t v15 = 0;
    int v16 = 0;
    uint64_t v17 = 0;
    while (1)
    {
      *(void *)(a1 + 96) = *(void *)(*((void *)v7 + 1) + 8 * v15);
      *(void *)(a1 + 104) = 0;
      int v18 = xmlRelaxNGValidateState(a1, a2);
      uint64_t v19 = *(void *)(a1 + 96);
      if (v19 && *v8)
      {
        xmlGenericErrorFunc v20 = *__xmlGenericError();
        char v21 = __xmlGenericErrorContext();
        v20(*v21, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 10704);
        xmlRelaxNGFreeValidState((_DWORD *)a1, *(void *)(a1 + 96));
        uint64_t v19 = 0;
        *(void *)(a1 + 96) = 0;
      }
      if (!v18) {
        break;
      }
      if (v19)
      {
        xmlRelaxNGFreeValidState((_DWORD *)a1, v19);
        goto LABEL_21;
      }
      uint64_t v26 = (int *)*v8;
      if (*v8)
      {
        if (*v26 >= 1)
        {
          uint64_t v27 = 0;
          do
          {
            xmlRelaxNGFreeValidState((_DWORD *)a1, *(void *)(*((void *)v26 + 1) + 8 * v27++));
            uint64_t v26 = *(int **)(a1 + 104);
          }
          while (v27 < *v26);
        }
        long long v25 = (void *)a1;
        goto LABEL_33;
      }
LABEL_35:
      if (++v15 >= *v7)
      {
        *(_DWORD *)(a1 + 56) = v33;
        if (v17)
        {
          xmlRelaxNGFreeStates((void *)a1, (uint64_t)v7);
          uint64_t v10 = 0;
          *(void *)(a1 + 104) = v17;
          goto LABEL_54;
        }
        if (v16 >= 2)
        {
          uint64_t v10 = 0;
          int *v7 = v16;
          *uint64_t v8 = (uint64_t)v7;
          goto LABEL_54;
        }
        if (v16 == 1)
        {
          *(void *)(a1 + 96) = **((void **)v7 + 1);
          xmlRelaxNGFreeStates((void *)a1, (uint64_t)v7);
          uint64_t v10 = 0;
          goto LABEL_54;
        }
LABEL_47:
        xmlRelaxNGFreeStates((void *)a1, (uint64_t)v7);
        uint64_t v29 = *(void *)(a1 + 104);
        if (v29)
        {
          xmlRelaxNGFreeStates((void *)a1, v29);
          *(void *)(a1 + 104) = 0;
        }
        uint64_t v10 = 0xFFFFFFFFLL;
LABEL_54:
        if (*v4 && *v8)
        {
          xmlGenericErrorFunc v30 = *__xmlGenericError();
          int v31 = __xmlGenericErrorContext();
          v30(*v31, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 10770);
          xmlRelaxNGFreeValidState((_DWORD *)a1, *(void *)(a1 + 96));
          uint64_t v8 = v4;
LABEL_57:
          *uint64_t v8 = 0;
        }
        return v10;
      }
    }
    uint64_t v23 = (int *)*v8;
    if (*v8)
    {
      if (!v17)
      {
        *uint64_t v8 = 0;
        if (v16 >= 1)
        {
          uint64_t v28 = 0;
          do
          {
            xmlRelaxNGAddStates((_DWORD *)a1, v23, *(void *)(*((void *)v7 + 1) + v28));
            v28 += 8;
          }
          while (8 * v16 != v28);
        }
        uint64_t v17 = v23;
        goto LABEL_35;
      }
      if (*v23 >= 1)
      {
        uint64_t v24 = 0;
        do
        {
          xmlRelaxNGAddStates((_DWORD *)a1, v17, *(void *)(*((void *)v23 + 1) + 8 * v24++));
          uint64_t v23 = *(int **)(a1 + 104);
        }
        while (v24 < *v23);
      }
      long long v25 = (void *)a1;
      uint64_t v26 = v23;
LABEL_33:
      xmlRelaxNGFreeStates(v25, (uint64_t)v26);
      int v22 = (uint64_t *)(a1 + 104);
    }
    else if (v17)
    {
      xmlRelaxNGAddStates((_DWORD *)a1, v17, v19);
LABEL_21:
      int v22 = v4;
    }
    else
    {
      *(void *)(*((void *)v7 + 1) + 8 * v16) = v19;
      int v22 = v4;
      ++v16;
    }
    uint64_t *v22 = 0;
    goto LABEL_35;
  }
  *(void *)(a1 + 96) = **((void **)v7 + 1);
  xmlRelaxNGFreeStates((void *)a1, (uint64_t)v7);
  *(void *)(a1 + 104) = 0;
LABEL_7:
  uint64_t v10 = xmlRelaxNGValidateState(a1, a2);
  if (*(void *)(a1 + 96))
  {
    if (!*v8) {
      return v10;
    }
    xmlGenericErrorFunc v11 = *__xmlGenericError();
    uint64_t v12 = __xmlGenericErrorContext();
    v11(*v12, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 10679);
    xmlRelaxNGFreeValidState((_DWORD *)a1, *(void *)(a1 + 96));
    *(void *)(a1 + 96) = 0;
  }
  uint64_t v13 = *v8;
  if (*v8 && *(_DWORD *)v13 == 1)
  {
    *(void *)(a1 + 96) = **(void **)(v13 + 8);
    xmlRelaxNGFreeStates((void *)a1, v13);
    goto LABEL_57;
  }
  return v10;
}

_DWORD *xmlRelaxNGFreeValidState(_DWORD *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = (uint64_t)result;
    if (result
      && ((uint64_t v4 = (void *)*((void *)result + 14)) != 0
       || (uint64_t v4 = xmlRelaxNGNewStates((uint64_t)result, 40), (*(void *)(v3 + 112) = v4) != 0)))
    {
      int v5 = *(_DWORD *)v4;
      uint64_t v6 = *((int *)v4 + 1);
      if (*(_DWORD *)v4 < (int)v6)
      {
        uint64_t result = (_DWORD *)v4[1];
LABEL_14:
        *(_DWORD *)uint64_t v4 = v5 + 1;
        *(void *)&result[2 * v5] = a2;
        return result;
      }
      uint64_t result = xmlRealloc((void *)v4[1], 16 * v6);
      if (result)
      {
        v4[1] = result;
        *((_DWORD *)v4 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 2 * v6;
        int v5 = *(_DWORD *)v4;
        goto LABEL_14;
      }
      return xmlRngVErrMemory(v3, (const xmlChar *)"adding states\n");
    }
    else
    {
      uint64_t v7 = *(void **)(a2 + 48);
      if (v7) {
        xmlFree(v7);
      }
      xmlFreeFunc v8 = xmlFree;
      return (_DWORD *)((uint64_t (*)(uint64_t))v8)(a2);
    }
  }
  return result;
}

xmlRelaxNGValidCtxtPtr xmlRelaxNGNewValidCtxt(xmlRelaxNGPtr schema)
{
  uint64_t v2 = xmlMalloc(0xC0uLL);
  uint64_t v3 = v2;
  if (v2)
  {
    v2[10] = 0u;
    v2[11] = 0u;
    v2[8] = 0u;
    v2[9] = 0u;
    v2[6] = 0u;
    v2[7] = 0u;
    v2[4] = 0u;
    v2[5] = 0u;
    v2[2] = 0u;
    v2[3] = 0u;
    *uint64_t v2 = 0u;
    v2[1] = 0u;
    *((void *)v2 + 5) = schema;
    *((void *)v2 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = *__xmlGenericError();
    *(void *)uint64_t v3 = *__xmlGenericErrorContext();
    *((void *)v3 + 10) = 0;
    *((void *)v3 + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0;
    *((void *)v3 + 9) = 0;
    if (schema) {
      *((_DWORD *)v3 + 16) = *((_DWORD *)schema + 6);
    }
    *((void *)v3 + 16) = 0;
    *((_DWORD *)v3 + 17) = 0;
    *((void *)v3 + 1xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0;
    *((void *)v3 + 14) = 0;
  }
  else
  {
    xmlRngVErrMemory(0, (const xmlChar *)"building context\n");
  }
  return (xmlRelaxNGValidCtxtPtr)v3;
}

_DWORD *xmlRngVErrMemory(uint64_t a1, const xmlChar *a2)
{
  if (a1)
  {
    uint64_t v3 = a1;
    a1 = *(void *)(a1 + 24);
    if (a1) {
      uint64_t v4 = 0;
    }
    else {
      uint64_t v4 = *(void (**)(void *, const char *, ...))(v3 + 8);
    }
    int v5 = *(void **)v3;
    ++*(_DWORD *)(v3 + 32);
    if (a2) {
      return __xmlRaiseError((xmlStructuredErrorFunc)a1, v4, v5, 0, 0, 0x13u, 2, 3, 0, 0, a2, 0, 0, 0, 0, "Memory allocation failed : %s\n", (char)a2);
    }
    return __xmlRaiseError((xmlStructuredErrorFunc)a1, v4, v5, 0, 0, 0x13u, 2, 3, 0, 0, 0, 0, 0, 0, 0, "Memory allocation failed\n", v7);
  }
  uint64_t v4 = 0;
  int v5 = 0;
  if (!a2) {
    return __xmlRaiseError((xmlStructuredErrorFunc)a1, v4, v5, 0, 0, 0x13u, 2, 3, 0, 0, 0, 0, 0, 0, 0, "Memory allocation failed\n", v7);
  }
  return __xmlRaiseError((xmlStructuredErrorFunc)a1, v4, v5, 0, 0, 0x13u, 2, 3, 0, 0, a2, 0, 0, 0, 0, "Memory allocation failed : %s\n", (char)a2);
}

void xmlRelaxNGFreeValidCtxt(xmlRelaxNGValidCtxtPtr ctxt)
{
  if (ctxt)
  {
    uint64_t v2 = (void **)*((void *)ctxt + 13);
    if (v2)
    {
      xmlFree(v2[1]);
      xmlFree(v2);
    }
    uint64_t v3 = (void *)*((void *)ctxt + 14);
    if (v3)
    {
      int v4 = *(_DWORD *)v3;
      if (*(int *)v3 >= 1)
      {
        uint64_t v5 = 0;
        do
        {
          uint64_t v6 = *(void **)(*((void *)v3 + 1) + 8 * v5);
          if (v6)
          {
            char v7 = (void *)v6[6];
            if (v7) {
              xmlFree(v7);
            }
            xmlFree(v6);
            uint64_t v3 = (void *)*((void *)ctxt + 14);
            int v4 = *(_DWORD *)v3;
          }
          ++v5;
        }
        while (v5 < v4);
      }
      xmlFree(*((void **)v3 + 1));
      xmlFree(v3);
    }
    xmlFreeFunc v8 = (void *)*((void *)ctxt + 16);
    if (v8)
    {
      int v9 = *((_DWORD *)ctxt + 30);
      if (v9 >= 1)
      {
        for (uint64_t i = 0; i < v9; ++i)
        {
          xmlGenericErrorFunc v11 = *(void ***)(*((void *)ctxt + 16) + 8 * i);
          if (v11)
          {
            xmlFree(v11[1]);
            xmlFree(v11);
            int v9 = *((_DWORD *)ctxt + 30);
          }
        }
        xmlFreeFunc v8 = (void *)*((void *)ctxt + 16);
      }
      xmlFree(v8);
    }
    uint64_t v12 = (void *)*((void *)ctxt + 11);
    if (v12) {
      xmlFree(v12);
    }
    uint64_t v13 = *((void *)ctxt + 19);
    if (v13)
    {
      int v14 = *((_DWORD *)ctxt + 36);
      unsigned int v15 = v14 - 1;
      if (v14 >= 1)
      {
        *((_DWORD *)ctxt + 36) = v15;
        int v16 = *(xmlRegExecCtxt **)(v13 + 8 * v15);
        *(void *)(v13 + 8 * v15) = 0;
        if (v14 == 1) {
          goto LABEL_28;
        }
        uint64_t v17 = *(void *)(*((void *)ctxt + 19) + 8 * (v14 - 2));
        while (1)
        {
          *((void *)ctxt + 17) = v17;
          if (!v16) {
            break;
          }
          xmlRegFreeExecCtxt(v16);
          int v18 = *((_DWORD *)ctxt + 36);
          unsigned int v19 = v18 - 1;
          if (v18 < 1) {
            break;
          }
          *((_DWORD *)ctxt + 36) = v19;
          uint64_t v20 = *((void *)ctxt + 19);
          int v16 = *(xmlRegExecCtxt **)(v20 + 8 * v19);
          *(void *)(v20 + 8 * v19) = 0;
          if (v18 == 1) {
LABEL_28:
          }
            uint64_t v17 = 0;
          else {
            uint64_t v17 = *(void *)(*((void *)ctxt + 19) + 8 * (v18 - 2));
          }
        }
      }
      xmlFree(*((void **)ctxt + 19));
    }
    xmlFreeFunc v21 = xmlFree;
    ((void (*)(xmlRelaxNGValidCtxtPtr))v21)(ctxt);
  }
}

void *xmlRelaxNGFreeStates(void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = (uint64_t)result;
    if (result)
    {
      uint64_t result = (void *)result[16];
      if (result)
      {
        uint64_t v4 = *(int *)(v3 + 124);
        if (*(_DWORD *)(v3 + 120) < (int)v4)
        {
LABEL_9:
          uint64_t v5 = *(int *)(v3 + 120);
          *(_DWORD *)(v3 + 120) = v5 + 1;
          result[v5] = a2;
          return result;
        }
        uint64_t result = xmlRealloc(result, 16 * v4);
        if (result)
        {
          *(void *)(v3 + 128) = result;
          *(_DWORD *)(v3 + 124) *= 2;
          goto LABEL_9;
        }
        xmlRngVErrMemory(v3, (const xmlChar *)"storing states\n");
      }
      else
      {
        *(void *)(v3 + 120) = 0x2800000000;
        uint64_t result = xmlMalloc(0x140uLL);
        *(void *)(v3 + 128) = result;
        if (result) {
          goto LABEL_9;
        }
        xmlRngVErrMemory(v3, (const xmlChar *)"storing states\n");
        uint64_t result = *(void **)(v3 + 128);
        if (result) {
          goto LABEL_9;
        }
      }
    }
    xmlFree(*(void **)(a2 + 8));
    xmlFreeFunc v6 = xmlFree;
    return (void *)((uint64_t (*)(uint64_t))v6)(a2);
  }
  return result;
}

void xmlRelaxNGSetValidErrors(xmlRelaxNGValidCtxtPtr ctxt, xmlRelaxNGValidityErrorFunc err, xmlRelaxNGValidityWarningFunc warn, void *ctx)
{
  if (ctxt)
  {
    *(void *)ctxt = ctx;
    *((void *)ctxt + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = err;
    *((void *)ctxt + 2) = warn;
    *((void *)ctxt + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0;
  }
}

void xmlRelaxNGSetValidStructuredErrors(xmlRelaxNGValidCtxtPtr ctxt, xmlStructuredErrorFunc serror, void *ctx)
{
  if (ctxt)
  {
    *((void *)ctxt + 2) = 0;
    *((void *)ctxt + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = serror;
    *(void *)ctxt = ctx;
    *((void *)ctxt + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0;
  }
}

int xmlRelaxNGGetValidErrors(xmlRelaxNGValidCtxtPtr ctxt, xmlRelaxNGValidityErrorFunc *err, xmlRelaxNGValidityWarningFunc *warn, void **ctx)
{
  if (!ctxt) {
    return -1;
  }
  if (err) {
    *err = (xmlRelaxNGValidityErrorFunc)*((void *)ctxt + 1);
  }
  if (warn) {
    *warn = (xmlRelaxNGValidityWarningFunc)*((void *)ctxt + 2);
  }
  int v4 = 0;
  if (ctx) {
    *ctx = *(void **)ctxt;
  }
  return v4;
}

int xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
  int result = -1;
  if (ctxt && doc)
  {
    *((void *)ctxt + 6) = doc;
    uint64_t v5 = *((void *)ctxt + 5);
    if (v5)
    {
      *((_DWORD *)ctxt + 17) = 0;
      uint64_t v6 = *(void *)(v5 + 8);
      if (v6)
      {
        char v7 = xmlRelaxNGNewValidState((uint64_t)ctxt, 0);
        *((void *)ctxt + 12) = v7;
        int v8 = xmlRelaxNGValidateDefinition((uint64_t)ctxt, *(void *)(v6 + 24));
        uint64_t v9 = *((void *)ctxt + 12);
        if (v9 && v7[1])
        {
          if (!xmlRelaxNGSkipIgnored((uint64_t)ctxt, *(void *)(v9 + 8)) || v8 == -1) {
            goto LABEL_25;
          }
        }
        else
        {
          uint64_t v10 = (int *)*((void *)ctxt + 13);
          if (!v10) {
            goto LABEL_25;
          }
          if (*v10 < 1)
          {
            BOOL v14 = 1;
          }
          else
          {
            uint64_t v11 = 0;
            int v12 = -1;
            do
            {
              uint64_t v13 = *(void *)(*((void *)v10 + 1) + 8 * v11);
              if (!xmlRelaxNGSkipIgnored((uint64_t)ctxt, *(void *)(v13 + 8))) {
                int v12 = 0;
              }
              xmlRelaxNGFreeValidState(ctxt, v13);
              ++v11;
              uint64_t v10 = (int *)*((void *)ctxt + 13);
            }
            while (v11 < *v10);
            BOOL v14 = v12 == -1;
          }
          if (!v14 || v8 == -1)
          {
LABEL_25:
            uint64_t v17 = *((void *)ctxt + 12);
            if (v17)
            {
              xmlRelaxNGFreeValidState(ctxt, v17);
              *((void *)ctxt + 12) = 0;
            }
            if (v8)
            {
              xmlRelaxNGDumpValidError((uint64_t)ctxt);
              if (*((_DWORD *)ctxt + 16) != 1)
              {
                int v15 = v8;
                goto LABEL_39;
              }
            }
            else if (*((_DWORD *)ctxt + 16) != 1)
            {
              goto LABEL_36;
            }
            memset(&v24.node, 0, 88);
            v24.valint id = 1;
            v24.warning = (xmlValidityWarningFunc)*((void *)ctxt + 2);
            *(_OWORD *)&v24.userData = *(_OWORD *)ctxt;
            int v18 = xmlValidateDocumentFinal(&v24, doc);
            if (v18 == 1) {
              int v15 = v8;
            }
            else {
              int v15 = -1;
            }
            if (v8 || v18 != 1)
            {
LABEL_39:
              xmlElementType type = doc->type;
              if (type != XML_HTML_DOCUMENT_NODE && type != XML_DOCUMENT_NODE)
              {
                if (type != XML_ELEMENT_NODE)
                {
LABEL_54:
                  if (v15 == -1) {
                    return 1;
                  }
                  else {
                    return v15;
                  }
                }
                doc->version = 0;
              }
              xmlNodePtr children = doc->children;
              if (children)
              {
                while (1)
                {
                  do
                  {
                    xmlDocPtr v22 = (xmlDocPtr)children;
                    if (children->type != XML_ELEMENT_NODE) {
                      break;
                    }
                    children->psvuint64_t i = 0;
                    xmlNodePtr children = children->children;
                  }
                  while (children);
                  while (1)
                  {
                    xmlNodePtr children = v22->next;
                    if (children) {
                      break;
                    }
                    xmlDocPtr v22 = (xmlDocPtr)v22->parent;
                    if (v22) {
                      BOOL v23 = v22 == doc;
                    }
                    else {
                      BOOL v23 = 1;
                    }
                    if (v23) {
                      goto LABEL_54;
                    }
                  }
                }
              }
              goto LABEL_54;
            }
LABEL_36:
            if (*((_DWORD *)ctxt + 17)) {
              int v15 = -1;
            }
            else {
              int v15 = 0;
            }
            goto LABEL_39;
          }
        }
        xmlRelaxNGAddValidError((uint64_t)ctxt, 35, 0, 0, 0);
        int v8 = -1;
        goto LABEL_25;
      }
      xmlRelaxNGAddValidError((uint64_t)ctxt, 34, 0, 0, 0);
    }
    int v15 = -1;
    goto LABEL_39;
  }
  return result;
}

uint64_t xmlRelaxNGFreeInclude(void *a1)
{
  uint64_t v2 = (void *)a1[1];
  if (v2) {
    xmlFree(v2);
  }
  uint64_t v3 = (xmlDoc *)a1[2];
  if (v3) {
    xmlFreeDoc(v3);
  }
  int v4 = (xmlRelaxNG *)a1[4];
  if (v4) {
    xmlRelaxNGFree(v4);
  }
  xmlFreeFunc v5 = xmlFree;

  return ((uint64_t (*)(void *))v5)(a1);
}

uint64_t xmlRelaxNGFreePartition(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void **)(result + 24);
    if (v2)
    {
      int v3 = *(_DWORD *)v1;
      if (*(int *)v1 >= 1)
      {
        uint64_t v4 = 0;
        do
        {
          xmlFreeFunc v5 = *(void **)(*(void *)(v1 + 24) + 8 * v4);
          if (v5)
          {
            uint64_t v6 = (void *)v5[1];
            if (v6) {
              xmlFree(v6);
            }
            char v7 = (void *)v5[2];
            if (v7) {
              xmlFree(v7);
            }
            xmlFree(v5);
            int v3 = *(_DWORD *)v1;
          }
          ++v4;
        }
        while (v4 < v3);
        uint64_t v2 = *(void **)(v1 + 24);
      }
      xmlFree(v2);
    }
    int v8 = *(xmlHashTable **)(v1 + 8);
    if (v8) {
      xmlHashFree(v8, 0);
    }
    xmlFreeFunc v9 = xmlFree;
    return ((uint64_t (*)(uint64_t))v9)(v1);
  }
  return result;
}

unsigned char *xmlRelaxNGNormalize(uint64_t a1, unsigned char *a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = a2;
  uint64_t v4 = 0;
  xmlFreeFunc v5 = a2;
  do
  {
    int v6 = *v5++;
    v4 += 0x100000000;
  }
  while (v6);
  int result = xmlMallocAtomic(v4 >> 32);
  if (result)
  {
    while (1)
    {
      unsigned int v8 = *v2;
      if (v8 > 0x20 || ((1 << v8) & 0x100002600) == 0) {
        break;
      }
      ++v2;
    }
    for (uint64_t i = result; ; ++i)
    {
      if (v8 > 0x20u) {
        goto LABEL_19;
      }
      if (((1 << v8) & 0x100002600) == 0) {
        break;
      }
      while (v8 <= 0x20u)
      {
        if (((1 << v8) & 0x100002600) == 0)
        {
          if (!(_BYTE)v8) {
            goto LABEL_21;
          }
          break;
        }
        char v11 = *++v2;
        LOBYTE(v8) = v11;
      }
      LOBYTE(v8) = 32;
LABEL_20:
      *uint64_t i = v8;
      LOBYTE(v8) = *v2;
    }
    if (!(_BYTE)v8)
    {
LABEL_21:
      *uint64_t i = 0;
      return result;
    }
LABEL_19:
    ++v2;
    goto LABEL_20;
  }
  xmlRngVErrMemory(a1, (const xmlChar *)"validating\n");
  return 0;
}

void xmlRelaxNGCleanupTree(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return;
  }
  uint64_t v4 = 0;
  uint64_t v5 = a2;
  while (1)
  {
LABEL_3:
    uint64_t v6 = v5;
    if (v4)
    {
      xmlUnlinkNode(v4);
      xmlFreeNode(v4);
    }
    int v7 = *(_DWORD *)(v6 + 8);
    if ((v7 - 3) >= 2) {
      break;
    }
    unsigned int v8 = *(unsigned char **)(v6 + 80);
    if (v8)
    {
      while (1)
      {
        unsigned int v9 = *v8;
        if (v9 > 0x20) {
          break;
        }
        if (((1 << v9) & 0x100002600) == 0)
        {
          if (*v8) {
            break;
          }
          goto LABEL_51;
        }
        ++v8;
      }
LABEL_54:
      uint64_t v4 = 0;
      goto LABEL_55;
    }
LABEL_51:
    uint64_t v28 = *(void *)(v6 + 40);
    uint64_t v4 = (xmlNode *)v6;
    if (!v28) {
      goto LABEL_257;
    }
    uint64_t v4 = (xmlNode *)v6;
    if (*(_DWORD *)(v28 + 8) != 1) {
      goto LABEL_257;
    }
    if (xmlStrEqual(*(const xmlChar **)(v28 + 16), (const xmlChar *)"value")) {
      goto LABEL_54;
    }
    if (xmlStrEqual(*(const xmlChar **)(*(void *)(v6 + 40) + 16), (const xmlChar *)"param")) {
      uint64_t v4 = 0;
    }
    else {
      uint64_t v4 = (xmlNode *)v6;
    }
LABEL_55:
    uint64_t v5 = *(void *)(v6 + 24);
    if (v5)
    {
      unsigned int v29 = *(_DWORD *)(v5 + 8);
      BOOL v30 = v29 > 0x11;
      int v31 = (1 << v29) & 0x20060;
      if (v30 || v31 == 0) {
        continue;
      }
    }
    goto LABEL_257;
  }
  uint64_t v4 = (xmlNode *)v6;
  if (v7 != 1) {
    goto LABEL_257;
  }
  uint64_t v10 = *(void *)(v6 + 72);
  if (!v10 || !xmlStrEqual(*(const xmlChar **)(v10 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
  {
    uint64_t v33 = *(void *)(v6 + 40);
    uint64_t v4 = (xmlNode *)v6;
    if (!v33) {
      goto LABEL_257;
    }
    uint64_t v4 = (xmlNode *)v6;
    if (*(_DWORD *)(v33 + 8) != 1) {
      goto LABEL_257;
    }
    if (!xmlStrEqual(*(const xmlChar **)(v33 + 16), (const xmlChar *)"name")
      && !xmlStrEqual(*(const xmlChar **)(*(void *)(v6 + 40) + 16), (const xmlChar *)"value"))
    {
      uint64_t v4 = (xmlNode *)v6;
      if (!xmlStrEqual(*(const xmlChar **)(*(void *)(v6 + 40) + 16), (const xmlChar *)"param")) {
        goto LABEL_257;
      }
    }
    int v34 = *(const xmlChar **)(*(void *)(v6 + 40) + 16);
    uint64_t v35 = a1;
    uint64_t v36 = v6;
    int v37 = 1035;
    uint64_t v38 = "element %s doesn't allow foreign elements\n";
    goto LABEL_68;
  }
  uint64_t v11 = *(void *)(v6 + 88);
  if (v11)
  {
    while (1)
    {
      uint64_t v12 = v11;
      uint64_t v11 = *(void *)(v11 + 48);
      uint64_t v13 = *(void *)(v12 + 72);
      if (v13 && !xmlStrEqual(*(const xmlChar **)(v13 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0")) {
        goto LABEL_35;
      }
      if (xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"name")) {
        break;
      }
      if (xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"type"))
      {
        if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"value")) {
          goto LABEL_35;
        }
        int v16 = *(const xmlChar **)(v6 + 16);
        uint64_t v17 = "data";
        goto LABEL_32;
      }
      if (xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"href"))
      {
        if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"externalRef")) {
          goto LABEL_35;
        }
        int v16 = *(const xmlChar **)(v6 + 16);
        uint64_t v17 = "include";
        goto LABEL_32;
      }
      if (xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"combine"))
      {
        BOOL v14 = *(const xmlChar **)(v6 + 16);
        int v15 = "start";
        goto LABEL_30;
      }
      if (xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"datatypeLibrary"))
      {
        String = xmlNodeListGetString(*(xmlDocPtr *)(v6 + 64), *(const xmlNode **)(v12 + 24), 1);
        if (String)
        {
          long long v25 = String;
          if (*String)
          {
            xmlURIPtr v26 = xmlParseURI((const char *)String);
            if (v26)
            {
              uint64_t v27 = v26;
              if (!v26->scheme) {
                xmlRngPErr(a1, v6, 1118, "Attribute %s URI %s is not absolute\n", *(const xmlChar **)(v12 + 16), v25);
              }
              if (v27->fragment) {
                xmlRngPErr(a1, v6, 1117, "Attribute %s URI %s has a fragment ID\n", *(const xmlChar **)(v12 + 16), v25);
              }
              xmlFreeURI(v27);
            }
            else
            {
              xmlRngPErr(a1, v6, 1050, "Attribute %s contains invalid URI %s\n", *(const xmlChar **)(v12 + 16), v25);
            }
          }
          xmlFree(v25);
        }
        goto LABEL_35;
      }
      if (!xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"ns"))
      {
        int v18 = *(const xmlChar **)(v12 + 16);
        unsigned int v19 = *(xmlChar **)(v6 + 16);
        uint64_t v20 = a1;
        uint64_t v21 = v6;
        int v22 = 1113;
        BOOL v23 = "Unknown attribute %s on %s\n";
        goto LABEL_34;
      }
LABEL_35:
      if (!v11) {
        goto LABEL_69;
      }
    }
    if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"element")
      || xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"attribute")
      || xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"ref")
      || xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"parentRef"))
    {
      goto LABEL_35;
    }
    BOOL v14 = *(const xmlChar **)(v6 + 16);
    int v15 = "param";
LABEL_30:
    if (xmlStrEqual(v14, (const xmlChar *)v15)) {
      goto LABEL_35;
    }
    int v16 = *(const xmlChar **)(v6 + 16);
    uint64_t v17 = "define";
LABEL_32:
    if (!xmlStrEqual(v16, (const xmlChar *)v17))
    {
      int v18 = *(const xmlChar **)(v12 + 16);
      unsigned int v19 = *(xmlChar **)(v6 + 16);
      uint64_t v20 = a1;
      uint64_t v21 = v6;
      int v22 = 1034;
      BOOL v23 = "Attribute %s is not allowed on %s\n";
LABEL_34:
      xmlRngPErr(v20, v21, v22, v23, v18, v19);
      goto LABEL_35;
    }
    goto LABEL_35;
  }
LABEL_69:
  if (!xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"externalRef"))
  {
    if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"include"))
    {
      Prop = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"href");
      if (Prop)
      {
        int v43 = Prop;
        Base = xmlNodeGetBase(*(const xmlDoc **)(v6 + 64), (const xmlNode *)v6);
        BOOL v44 = xmlBuildURI(v43, Base);
        if (!v44)
        {
          xmlRngPErr(a1, v6, 1041, "Failed to compute URL for include %s\n", v43, 0);
          xmlFree(v43);
          uint64_t v4 = (xmlNode *)v6;
          if (!Base) {
            goto LABEL_257;
          }
          goto LABEL_98;
        }
        xmlDocPtr doc = (xmlDoc *)v44;
        xmlFree(v43);
        if (Base) {
          xmlFree(Base);
        }
        uint64_t v45 = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"ns");
        int v46 = (xmlChar *)doc;
        if (!v45)
        {
          uint64_t v47 = v6;
          while (1)
          {
            uint64_t v47 = *(void *)(v47 + 40);
            if (!v47 || *(_DWORD *)(v47 + 8) != 1) {
              break;
            }
            uint64_t v48 = xmlGetProp((const xmlNode *)v47, (const xmlChar *)"ns");
            if (v48)
            {
              uint64_t v45 = v48;
              goto LABEL_144;
            }
          }
          uint64_t v45 = 0;
        }
LABEL_144:
        if (*(int *)(a1 + 208) >= 1)
        {
          uint64_t v75 = 0;
          while (!xmlStrEqual(*(const xmlChar **)(*(void *)(*(void *)(a1 + 216) + 8 * v75) + 8), (const xmlChar *)doc))
          {
            if (++v75 >= *(int *)(a1 + 208)) {
              goto LABEL_148;
            }
          }
          uint64_t v84 = a1;
          uint64_t v85 = 0;
          int v86 = 1044;
          int v87 = "Detected an Include recursion for %s\n";
          goto LABEL_220;
        }
LABEL_148:
        xmlDocPtr cura = xmlReadFile((const char *)doc, 0, 0);
        if (!cura)
        {
          uint64_t v84 = a1;
          uint64_t v85 = v6;
          int v86 = 1065;
          int v87 = "xmlRelaxNG: could not load %s\n";
          goto LABEL_220;
        }
        uint64_t v76 = xmlMalloc(0x28uLL);
        int v77 = v76;
        if (!v76)
        {
          xmlRngPErrMemory(a1, (const xmlChar *)"allocating include\n");
          xmlFreeDoc(cura);
          goto LABEL_221;
        }
        v76[4] = 0;
        *(_OWORD *)uint64_t v76 = 0u;
        *((_OWORD *)v76 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0u;
        v76[2] = cura;
        uint64_t v78 = xmlStrdup((const xmlChar *)doc);
        void *v77 = *(void *)(a1 + 120);
        v77[1] = v78;
        long long v140 = v77;
        *(void *)(a1 + 120) = v77;
        if (v45)
        {
          xmlNodePtr RootElement = xmlDocGetRootElement(cura);
          if (RootElement)
          {
            unsigned int v80 = (xmlNode *)RootElement;
            if (!xmlHasProp(RootElement, (const xmlChar *)"ns")) {
              xmlSetProp(v80, (const xmlChar *)"ns", v45);
            }
          }
        }
        int v81 = *(void **)(a1 + 216);
        if (v81
          || (*(void *)(a1 + 208) = 0x400000000, int v81 = xmlMalloc(0x20uLL), (*(void *)(a1 + 216) = v81) != 0))
        {
          int v82 = *(_DWORD *)(a1 + 208);
          uint64_t v83 = *(int *)(a1 + 212);
          if (v82 < (int)v83) {
            goto LABEL_175;
          }
          *(_DWORD *)(a1 + 212) = 2 * v83;
          int v81 = xmlRealloc(v81, 16 * v83);
          *(void *)(a1 + 216) = v81;
          if (v81)
          {
            int v82 = *(_DWORD *)(a1 + 208);
LABEL_175:
            *((void *)v81 + v82) = v140;
            *(void *)(a1 + 200) = v140;
            *(_DWORD *)(a1 + 208) = v82 + 1;
            goto LABEL_176;
          }
        }
        xmlRngPErrMemory(a1, (const xmlChar *)"allocating include\n");
LABEL_176:
        int v94 = (const xmlDoc *)xmlRelaxNGCleanupDoc(a1, cura);
        if (!v94)
        {
          int v77 = 0;
          *(void *)(a1 + 200) = 0;
          goto LABEL_221;
        }
        int v95 = *(_DWORD *)(a1 + 208);
        unsigned int v96 = v95 - 1;
        if (v95 >= 1)
        {
          *(_DWORD *)(a1 + 208) = v96;
          uint64_t v97 = *(void *)(a1 + 216);
          if (v95 == 1) {
            uint64_t v98 = 0;
          }
          else {
            uint64_t v98 = *(void *)(v97 + 8 * (v95 - 2));
          }
          *(void *)(a1 + 200) = v98;
          *(void *)(v97 + 8 * v96) = 0;
        }
        xmlNodePtr v99 = xmlDocGetRootElement(v94);
        if (v99)
        {
          if (v99->ns)
          {
            if (v99->type == XML_ELEMENT_NODE)
            {
              xmlDocPtr curb = (xmlDocPtr)v99;
              if (xmlStrEqual(v99->name, (const xmlChar *)"grammar"))
              {
                if (xmlStrEqual(*(const xmlChar **)(*(void *)&curb->compression + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                {
                  xmlNodePtr children = *(_xmlNode **)(v6 + 24);
                  if (children)
                  {
                    while (1)
                    {
                      BOOL v101 = children;
                      if (!children->ns) {
                        goto LABEL_215;
                      }
                      xmlNodePtr node = children;
                      if (children->type != XML_ELEMENT_NODE) {
                        goto LABEL_210;
                      }
                      int v102 = xmlStrEqual(children->name, (const xmlChar *)"start");
                      BOOL v101 = node;
                      xmlNsPtr ns = node->ns;
                      if (!v102) {
                        goto LABEL_200;
                      }
                      if (!xmlStrEqual(ns->href, (const xmlChar *)"http://relaxng.org/ns/structure/1.0")) {
                        break;
                      }
                      int v104 = xmlRelaxNGRemoveRedefine((uint64_t)curb->children, 0);
                      BOOL v101 = node;
                      if (v104) {
                        goto LABEL_210;
                      }
                      xmlRngPErr(a1, v6, 1107, "xmlRelaxNG: include %s has a start but not the included grammar\n", v46, 0);
LABEL_209:
                      BOOL v101 = node;
LABEL_210:
                      if (v101->ns)
                      {
                        if (v101->type == XML_ELEMENT_NODE)
                        {
                          int v109 = xmlStrEqual(v101->name, (const xmlChar *)"div");
                          BOOL v101 = node;
                          if (v109)
                          {
                            int v110 = xmlStrEqual(node->ns->href, (const xmlChar *)"http://relaxng.org/ns/structure/1.0");
                            BOOL v101 = node;
                            if (v110)
                            {
                              xmlNodePtr children = node->children;
                              if (children) {
                                continue;
                              }
                            }
                          }
                        }
                      }
LABEL_215:
                      while (1)
                      {
                        xmlNodePtr children = v101->next;
                        if (children) {
                          break;
                        }
                        BOOL v101 = v101->parent;
                        if (v101 == (xmlNode *)v6) {
                          goto LABEL_217;
                        }
                      }
                    }
                    BOOL v101 = node;
                    xmlNsPtr ns = node->ns;
LABEL_200:
                    if (!ns) {
                      goto LABEL_215;
                    }
                    if (v101->type != XML_ELEMENT_NODE) {
                      goto LABEL_210;
                    }
                    int v105 = xmlStrEqual(v101->name, (const xmlChar *)"define");
                    BOOL v101 = node;
                    if (!v105) {
                      goto LABEL_210;
                    }
                    int v106 = xmlStrEqual(node->ns->href, (const xmlChar *)"http://relaxng.org/ns/structure/1.0");
                    BOOL v101 = node;
                    if (!v106) {
                      goto LABEL_210;
                    }
                    int v107 = xmlGetProp(node, (const xmlChar *)"name");
                    if (v107)
                    {
                      int v108 = v107;
                      xmlRelaxNGNormExtSpace(v107);
                      if (!xmlRelaxNGRemoveRedefine((uint64_t)curb->children, v108)) {
                        xmlRngPErr(a1, v6, 1013, "xmlRelaxNG: include %s has a define %s but not the included grammar\n", (const xmlChar *)doc, v108);
                      }
                      xmlFree(v108);
                      int v46 = (xmlChar *)doc;
                    }
                    else
                    {
                      int v46 = (xmlChar *)doc;
                      xmlRngPErr(a1, v6, 1053, "xmlRelaxNG: include %s has define without name\n", (const xmlChar *)doc, 0);
                    }
                    goto LABEL_209;
                  }
LABEL_217:
                  int v77 = v140;
LABEL_221:
                  if (v45) {
                    xmlFree(v45);
                  }
                  if (v77)
                  {
                    xmlFree(v46);
                    *(void *)(v6 + 104) = v77;
                    goto LABEL_225;
                  }
                  xmlRngPErr(a1, v6, 1043, "Failed to load include %s\n", v46, 0);
                  ((void (*)(xmlChar *))xmlFree)(v46);
LABEL_256:
                  uint64_t v4 = (xmlNode *)v6;
                  goto LABEL_257;
                }
              }
            }
          }
          uint64_t v84 = a1;
          uint64_t v85 = v6;
          int v86 = 1038;
          int v87 = "xmlRelaxNG: included document %s root is not a grammar\n";
        }
        else
        {
          uint64_t v84 = a1;
          uint64_t v85 = v6;
          int v86 = 1022;
          int v87 = "xmlRelaxNG: included document is empty %s\n";
        }
LABEL_220:
        xmlRngPErr(v84, v85, v86, v87, (const xmlChar *)doc, 0);
        int v77 = 0;
        goto LABEL_221;
      }
      uint64_t v35 = a1;
      uint64_t v36 = v6;
      int v37 = 1052;
      uint64_t v38 = "xmlRelaxNGParse: include has no href attribute\n";
      int v34 = 0;
LABEL_68:
      xmlRngPErr(v35, v36, v37, v38, v34, 0);
      uint64_t v4 = (xmlNode *)v6;
      goto LABEL_257;
    }
    if (!xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"element")
      && !xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"attribute"))
    {
      if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"name")
        || xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"nsName")
        || xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"value"))
      {
        if (!xmlHasProp((const xmlNode *)v6, (const xmlChar *)"ns"))
        {
          uint64_t v88 = v6;
          while (1)
          {
            uint64_t v88 = *(void *)(v88 + 40);
            if (!v88 || *(_DWORD *)(v88 + 8) != 1) {
              break;
            }
            long long v89 = xmlGetProp((const xmlNode *)v88, (const xmlChar *)"ns");
            if (v89)
            {
              int v90 = v89;
              xmlSetProp((xmlNodePtr)v6, (const xmlChar *)"ns", v89);
              xmlFree(v90);
              goto LABEL_241;
            }
          }
          xmlSetProp((xmlNodePtr)v6, (const xmlChar *)"ns", (const xmlChar *)"");
        }
LABEL_241:
        if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"name"))
        {
          prefix = 0;
          Content = xmlNodeGetContent((const xmlNode *)v6);
          if (Content)
          {
            int v120 = Content;
            int v121 = xmlSplitQName2(Content, &prefix);
            if (v121)
            {
              xmlGenericErrorFunc v122 = v121;
              xmlNsPtr v123 = xmlSearchNs(*(xmlDocPtr *)(v6 + 64), (xmlNodePtr)v6, prefix);
              if (v123)
              {
                xmlSetProp((xmlNodePtr)v6, (const xmlChar *)"ns", v123->href);
                xmlNodeSetContent((xmlNodePtr)v6, v122);
              }
              else
              {
                xmlRngPErr(a1, v6, 1097, "xmlRelaxNGParse: no namespace for prefix %s\n", prefix, 0);
              }
              xmlFree(v122);
              xmlFree(prefix);
            }
            xmlFree(v120);
          }
        }
        if (!xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"nsName") || (*(unsigned char *)(a1 + 65) & 2) == 0) {
          goto LABEL_225;
        }
        uint64_t v129 = a1;
        uint64_t v130 = v6;
        int v131 = 1085;
        uint64_t v132 = "Found nsName/except//nsName forbidden construct\n";
      }
      else
      {
        int v133 = xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"except");
        if (v6 != a2 && v133)
        {
          uint64_t v134 = *(void *)(v6 + 40);
          if (!v134) {
            goto LABEL_225;
          }
          int v135 = *(_DWORD *)(a1 + 64);
          if (xmlStrEqual(*(const xmlChar **)(v134 + 16), (const xmlChar *)"anyName"))
          {
            int v136 = *(_DWORD *)(a1 + 64) | 0x100;
          }
          else
          {
            uint64_t v138 = *(void *)(v6 + 40);
            if (!v138 || !xmlStrEqual(*(const xmlChar **)(v138 + 16), (const xmlChar *)"nsName")) {
              goto LABEL_225;
            }
            int v136 = *(_DWORD *)(a1 + 64) | 0x200;
          }
          *(_DWORD *)(a1 + 64) = v136;
          xmlRelaxNGCleanupTree(a1, v6);
          uint64_t v4 = 0;
          *(_DWORD *)(a1 + 64) = v135;
          goto LABEL_257;
        }
        if (!xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"anyName")) {
          goto LABEL_225;
        }
        int v137 = *(_DWORD *)(a1 + 64);
        if ((v137 & 0x100) != 0)
        {
          uint64_t v129 = a1;
          uint64_t v130 = v6;
          int v131 = 1066;
          uint64_t v132 = "Found anyName/except//anyName forbidden construct\n";
        }
        else
        {
          if ((v137 & 0x200) == 0) {
            goto LABEL_225;
          }
          uint64_t v129 = a1;
          uint64_t v130 = v6;
          int v131 = 1084;
          uint64_t v132 = "Found nsName/except//anyName forbidden construct\n";
        }
      }
      xmlRngPErr(v129, v130, v131, v132, 0, 0);
      goto LABEL_225;
    }
    int v53 = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"name");
    if (!v53) {
      goto LABEL_225;
    }
    uint64_t v54 = v53;
    if (*(void *)(v6 + 24))
    {
      uint64_t v55 = xmlNewDocNode(*(xmlDocPtr *)(v6 + 64), *(xmlNsPtr *)(v6 + 72), (const xmlChar *)"name", 0);
      if (v55)
      {
        uint64_t v56 = v55;
        xmlAddPrevSibling(*(xmlNodePtr *)(v6 + 24), v55);
        uint64_t v57 = xmlNewText(v54);
        xmlAddChild(v56, v57);
LABEL_135:
        char v72 = 0;
        goto LABEL_137;
      }
    }
    else
    {
      xmlNodePtr v71 = xmlNewChild((xmlNodePtr)v6, *(xmlNsPtr *)(v6 + 72), (const xmlChar *)"name", v53);
      if (v71)
      {
        uint64_t v56 = v71;
        goto LABEL_135;
      }
    }
    xmlRngPErr(a1, v6, 1008, "Failed to create a name %s element\n", v54, 0);
    uint64_t v56 = 0;
    char v72 = 1;
LABEL_137:
    xmlUnsetProp((xmlNodePtr)v6, (const xmlChar *)"name");
    xmlFree(v54);
    uint64_t v73 = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"ns");
    if (v73)
    {
      long long v74 = v73;
      if ((v72 & 1) == 0) {
        xmlSetProp(v56, (const xmlChar *)"ns", v73);
      }
      xmlFree(v74);
    }
    else if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"attribute"))
    {
      xmlSetProp(v56, (const xmlChar *)"ns", (const xmlChar *)"");
    }
    goto LABEL_225;
  }
  Base = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"ns");
  if (!Base)
  {
    uint64_t v40 = v6;
    while (1)
    {
      uint64_t v40 = *(void *)(v40 + 40);
      if (!v40 || *(_DWORD *)(v40 + 8) != 1) {
        break;
      }
      long long v41 = xmlGetProp((const xmlNode *)v40, (const xmlChar *)"ns");
      if (v41)
      {
        Base = v41;
        goto LABEL_91;
      }
    }
    Base = 0;
  }
LABEL_91:
  uint64_t v49 = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"href");
  if (!v49)
  {
    xmlRngPErr(a1, v6, 1052, "xmlRelaxNGParse: externalRef has no href attribute\n", 0, 0);
    uint64_t v4 = (xmlNode *)v6;
    if (!Base) {
      goto LABEL_257;
    }
LABEL_98:
    ((void (*)(xmlChar *))xmlFree)(Base);
    goto LABEL_256;
  }
  int v50 = v49;
  xmlURIPtr v51 = xmlParseURI((const char *)v49);
  if (!v51)
  {
    xmlRngPErr(a1, v6, 1041, "Incorrect URI for externalRef %s\n", v50, 0);
    if (Base) {
      xmlFree(Base);
    }
    ((void (*)(xmlChar *))xmlFree)(v50);
    goto LABEL_102;
  }
  int v52 = v51;
  if (v51->fragment)
  {
    xmlRngPErr(a1, v6, 1041, "Fragment forbidden in URI for externalRef %s\n", v50, 0);
    if (Base) {
      xmlFree(Base);
    }
    xmlFreeURI(v52);
    ((void (*)(xmlChar *))xmlFree)(v50);
LABEL_102:
    uint64_t v4 = (xmlNode *)v6;
    goto LABEL_257;
  }
  xmlFreeURI(v51);
  int v58 = xmlNodeGetBase(*(const xmlDoc **)(v6 + 64), (const xmlNode *)v6);
  unsigned int v59 = xmlBuildURI(v50, v58);
  if (v59)
  {
    int v60 = v59;
    xmlFree(v50);
    if (v58) {
      xmlFree(v58);
    }
    if (*(int *)(a1 + 184) >= 1)
    {
      uint64_t v61 = 0;
      while (!xmlStrEqual(*(const xmlChar **)(*(void *)(*(void *)(a1 + 192) + 8 * v61) + 8), v60))
      {
        if (++v61 >= *(int *)(a1 + 184)) {
          goto LABEL_116;
        }
      }
      uint64_t v91 = a1;
      int v92 = 1033;
      unsigned int v93 = "Detected an externalRef recursion for %s\n";
      goto LABEL_171;
    }
LABEL_116:
    xmlDocPtr doca = xmlReadFile((const char *)v60, 0, 0);
    if (!doca)
    {
      uint64_t v91 = a1;
      int v92 = 1065;
      unsigned int v93 = "xmlRelaxNG: could not load %s\n";
LABEL_171:
      xmlRngPErr(v91, 0, v92, v93, v60, 0);
LABEL_253:
      xmlRngPErr(a1, v6, 1032, "Failed to load externalRef %s\n", v60, 0);
      if (Base) {
        xmlFree(Base);
      }
      ((void (*)(xmlChar *))xmlFree)(v60);
      goto LABEL_256;
    }
    int v62 = (xmlDoc *)xmlMalloc(0x30uLL);
    if (!v62)
    {
      xmlRngPErr(a1, (uint64_t)doca, 2, "xmlRelaxNG: allocate memory for doc %s\n", v60, 0);
      xmlFreeDoc(doca);
      goto LABEL_253;
    }
    int v63 = v62;
    *(_OWORD *)&v62->name = 0u;
    *(_OWORD *)&v62->last = 0u;
    *(_OWORD *)&v62->_private = 0u;
    v62->name = (char *)doca;
    unsigned int v64 = xmlStrdup(v60);
    v63->_private = *(void **)(a1 + 112);
    *(void *)&v63->xmlElementType type = v64;
    LODWORD(v63->parxmlDumpEntityDecl(buf, ent) = 1;
    xmlDocPtr cur = v63;
    *(void *)(a1 + 112) = v63;
    if (Base)
    {
      uint64_t v65 = xmlDocGetRootElement(doca);
      if (v65)
      {
        unsigned int v66 = (xmlNode *)v65;
        if (!xmlHasProp(v65, (const xmlChar *)"ns")) {
          xmlSetProp(v66, (const xmlChar *)"ns", Base);
        }
      }
    }
    uint64_t v67 = *(void **)(a1 + 192);
    if (v67 || (*(void *)(a1 + 184) = 0x400000000, uint64_t v67 = xmlMalloc(0x20uLL), (*(void *)(a1 + 192) = v67) != 0))
    {
      int v68 = *(_DWORD *)(a1 + 184);
      uint64_t v69 = *(int *)(a1 + 188);
      if (v68 < (int)v69)
      {
        xmlDocPtr v70 = cur;
LABEL_185:
        v67[v68] = v70;
        *(void *)(a1 + 176) = v70;
        *(_DWORD *)(a1 + 184) = v68 + 1;
LABEL_247:
        if (!xmlRelaxNGCleanupDoc(a1, doca))
        {
          *(void *)(a1 + 176) = 0;
          goto LABEL_253;
        }
        int v124 = *(_DWORD *)(a1 + 184);
        unsigned int v125 = v124 - 1;
        if (v124 >= 1)
        {
          *(_DWORD *)(a1 + 184) = v125;
          uint64_t v126 = *(void *)(a1 + 192);
          if (v124 == 1) {
            uint64_t v128 = 0;
          }
          else {
            uint64_t v128 = *(void *)(v126 + 8 * (v124 - 2));
          }
          *(void *)(a1 + 176) = v128;
          *(void *)(v126 + 8 * v125) = 0;
        }
        if (Base) {
          xmlFree(Base);
        }
        xmlFree(v60);
        *(void *)(v6 + 104) = cur;
LABEL_225:
        if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"div"))
        {
          xmlGenericErrorFunc v111 = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"ns");
          uint64_t v112 = *(xmlNode **)(v6 + 24);
          if (v112)
          {
            Sibling = (xmlNode *)v6;
            do
            {
              if (v111 && !xmlHasProp(v112, (const xmlChar *)"ns")) {
                xmlSetProp(v112, (const xmlChar *)"ns", v111);
              }
              xmlNodePtr next = v112->next;
              xmlUnlinkNode(v112);
              Sibling = xmlAddNextSibling(Sibling, v112);
              uint64_t v112 = next;
            }
            while (next);
          }
          if (v111) {
            xmlFree(v111);
          }
          uint64_t v115 = *(void *)(v6 + 96);
          uint64_t v4 = (xmlNode *)v6;
          if (v115)
          {
            uint64_t v116 = *(void *)(v6 + 40);
            uint64_t v4 = (xmlNode *)v6;
            if (v116)
            {
              xmlNodePtr v117 = (void *)(v116 + 96);
              do
              {
                xmlGenericErrorFunc v118 = v117;
                xmlNodePtr v117 = (void *)*v117;
              }
              while (v117);
              *xmlGenericErrorFunc v118 = v115;
              *(void *)(v6 + 96) = 0;
              uint64_t v4 = (xmlNode *)v6;
            }
          }
          goto LABEL_257;
        }
        goto LABEL_54;
      }
      *(_DWORD *)(a1 + 188) = 2 * v69;
      uint64_t v67 = xmlRealloc(v67, 16 * v69);
      *(void *)(a1 + 192) = v67;
      xmlDocPtr v70 = cur;
      if (v67)
      {
        int v68 = *(_DWORD *)(a1 + 184);
        goto LABEL_185;
      }
    }
    xmlRngPErrMemory(a1, (const xmlChar *)"adding document\n");
    goto LABEL_247;
  }
  xmlRngPErr(a1, v6, 1041, "Failed to compute URL for externalRef %s\n", v50, 0);
  if (Base) {
    xmlFree(Base);
  }
  xmlFree(v50);
  uint64_t v4 = (xmlNode *)v6;
  if (v58)
  {
    ((void (*)(xmlChar *))xmlFree)(v58);
    goto LABEL_256;
  }
  do
  {
LABEL_257:
    uint64_t v5 = *(void *)(v6 + 48);
    if (v5) {
      goto LABEL_3;
    }
    uint64_t v6 = *(void *)(v6 + 40);
    if (v6) {
      BOOL v127 = v6 == a2;
    }
    else {
      BOOL v127 = 1;
    }
  }
  while (!v127);
  if (v4)
  {
    xmlUnlinkNode(v4);
    xmlFreeNode(v4);
  }
}

uint64_t xmlRelaxNGRemoveRedefine(uint64_t a1, const xmlChar *a2)
{
  if (a1)
  {
    uint64_t v3 = a1;
    uint64_t v4 = 0;
    while (1)
    {
      uint64_t v5 = v3;
      uint64_t v3 = *(void *)(v3 + 48);
      uint64_t v6 = *(void *)(v5 + 72);
      if (a2)
      {
        if (!v6
          || *(_DWORD *)(v5 + 8) != 1
          || !xmlStrEqual(*(const xmlChar **)(v5 + 16), (const xmlChar *)"define")
          || !xmlStrEqual(*(const xmlChar **)(*(void *)(v5 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
          goto LABEL_17;
        }
        Prop = xmlGetProp((const xmlNode *)v5, (const xmlChar *)"name");
        xmlRelaxNGNormExtSpace(Prop);
        if (Prop)
        {
          if (xmlStrEqual(a2, Prop))
          {
            xmlUnlinkNode((xmlNodePtr)v5);
            xmlFreeNode((xmlNodePtr)v5);
            uint64_t v4 = 1;
          }
          xmlFree(Prop);
        }
      }
      else
      {
        if (!v6
          || *(_DWORD *)(v5 + 8) != 1
          || !xmlStrEqual(*(const xmlChar **)(v5 + 16), (const xmlChar *)"start")
          || !xmlStrEqual(*(const xmlChar **)(*(void *)(v5 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
LABEL_17:
          if (*(void *)(v5 + 72)
            && *(_DWORD *)(v5 + 8) == 1
            && xmlStrEqual(*(const xmlChar **)(v5 + 16), (const xmlChar *)"include")
            && xmlStrEqual(*(const xmlChar **)(*(void *)(v5 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
          {
            uint64_t v8 = *(void *)(v5 + 104);
            if (v8)
            {
              uint64_t v9 = *(void *)(v8 + 16);
              if (v9)
              {
                uint64_t v10 = *(void *)(v9 + 24);
                if (v10)
                {
                  if (xmlStrEqual(*(const xmlChar **)(v10 + 16), (const xmlChar *)"grammar"))
                  {
                    xmlNodePtr RootElement = xmlDocGetRootElement(*(const xmlDoc **)(v8 + 16));
                    if (xmlRelaxNGRemoveRedefine(RootElement->children, a2) == 1) {
                      LODWORD(v4) = 1;
                    }
                  }
                }
              }
            }
            if (xmlRelaxNGRemoveRedefine(*(void *)(v5 + 24), a2) == 1) {
              uint64_t v4 = 1;
            }
            else {
              uint64_t v4 = v4;
            }
          }
          goto LABEL_30;
        }
        xmlUnlinkNode((xmlNodePtr)v5);
        xmlFreeNode((xmlNodePtr)v5);
        uint64_t v4 = 1;
      }
LABEL_30:
      if (!v3) {
        return v4;
      }
    }
  }
  return 0;
}

unsigned __int8 *xmlRelaxNGNormExtSpace(unsigned __int8 *result)
{
  if (!result) {
    return result;
  }
  for (uint64_t i = 0; ; ++i)
  {
    unsigned int v2 = result[i];
    BOOL v3 = v2 > 0x20;
    uint64_t v4 = (1 << v2) & 0x100002600;
    if (v3 || v4 == 0) {
      break;
    }
  }
  if (i)
  {
    for (uint64_t j = &result[i]; ; ++j)
    {
      uint64_t v7 = *j;
      if (v7 > 0x20)
      {
        unsigned __int8 k = *j;
      }
      else if (((1 << v7) & 0x100002600) != 0)
      {
        for (unsigned __int8 k = *j; k <= 0x20u; unsigned __int8 k = v9)
        {
          uint64_t v7 = k;
          if (((1 << k) & 0x100002600) == 0) {
            goto LABEL_17;
          }
          unsigned __int8 v9 = *++j;
        }
      }
      else
      {
        unsigned __int8 k = *j;
LABEL_17:
        if (!v7) {
          goto LABEL_30;
        }
      }
      *result++ = k;
    }
  }
  while (1)
  {
LABEL_21:
    unsigned int v10 = *result;
    if (v10 > 0x20) {
      goto LABEL_29;
    }
    unsigned __int8 v11 = *result;
    uint64_t v12 = result;
    if (((1 << v10) & 0x100002600) != 0) {
      break;
    }
    if (!*result) {
      return result;
    }
LABEL_29:
    ++result;
  }
  while (1)
  {
    if (v11 > 0x20u) {
      goto LABEL_27;
    }
    if (((1 << v11) & 0x100002600) == 0) {
      break;
    }
    unsigned __int8 v13 = *++v12;
    unsigned __int8 v11 = v13;
  }
  if (v11)
  {
LABEL_27:
    int result = v12;
    goto LABEL_21;
  }
LABEL_30:
  unsigned char *result = 0;
  return result;
}

void *xmlRelaxNGParseGrammar(uint64_t a1, uint64_t a2)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = xmlRelaxNGNewGrammar(a1);
  uint64_t v5 = v4;
  if (!v4) {
    return v5;
  }
  uint64_t v6 = *(void *)(a1 + 48);
  *(void *)uint64_t v4 = v6;
  if (v6)
  {
    uint64_t v7 = (void *)(v6 + 8);
    uint64_t v8 = *(void *)(v6 + 8);
    if (v8)
    {
      do
      {
        uint64_t v9 = v8;
        uint64_t v8 = *(void *)(v8 + 16);
      }
      while (v8);
      uint64_t v7 = (void *)(v9 + 16);
    }
    void *v7 = v4;
  }
  *(void *)(a1 + 48) = v4;
  xmlRelaxNGParseGrammarContent(a1, a2);
  *(void *)(a1 + 48) = v5;
  uint64_t v10 = v5[3];
  if (!v10)
  {
    xmlRngPErr(a1, a2, 1039, "Element <grammar> has no <start>\n", 0, 0);
    uint64_t v10 = v5[3];
    if (!v10) {
      goto LABEL_42;
    }
  }
  if (!*(void *)(v10 + 64)) {
    goto LABEL_42;
  }
  int v11 = 0;
  int v12 = -1;
  uint64_t v13 = v10;
  do
  {
    uint64_t v14 = *(void *)(v13 + 8);
    if (v14
      && (uint64_t v15 = *(void *)(v14 + 40)) != 0
      && (v16 = xmlStrEqual(*(const xmlChar **)(v15 + 16), (const xmlChar *)"start"), uint64_t v14 = *(void *)(v13 + 8), v16))
    {
      Prop = xmlGetProp(*(const xmlNode **)(v14 + 40), (const xmlChar *)"combine");
      if (Prop)
      {
        int v18 = Prop;
        if (xmlStrEqual(Prop, (const xmlChar *)"choice"))
        {
          if (v12)
          {
            int v12 = 1;
LABEL_29:
            xmlFree(v18);
            goto LABEL_22;
          }
        }
        else
        {
          if (!xmlStrEqual(v18, (const xmlChar *)"interleave"))
          {
            uint64_t v19 = *(void *)(v13 + 8);
            uint64_t v20 = a1;
            int v21 = 1114;
            int v22 = "<start> uses unknown combine value '%s''\n";
            BOOL v23 = v18;
            goto LABEL_28;
          }
          if (v12 != 1)
          {
            int v12 = 0;
            goto LABEL_29;
          }
        }
        uint64_t v19 = *(void *)(v13 + 8);
        uint64_t v20 = a1;
        int v21 = 1104;
        int v22 = "<start> use both 'choice' and 'interleave'\n";
        BOOL v23 = 0;
LABEL_28:
        xmlRngPErr(v20, v19, v21, v22, v23, 0);
        goto LABEL_29;
      }
    }
    else
    {
      xmlRngPErr(a1, v14, 1107, "Internal error: start element not found\n", 0, 0);
    }
    if (v11) {
      xmlRngPErr(a1, *(void *)(v13 + 8), 1054, "Some <start> element miss the combine attribute\n", 0, 0);
    }
    int v11 = 1;
LABEL_22:
    uint64_t v13 = *(void *)(v13 + 64);
  }
  while (v13);
  xmlValidCtxt v24 = xmlRelaxNGNewDefine(a1, *(void *)(v10 + 8));
  if (v24)
  {
    long long v25 = v24;
    int v26 = (v12 + 1) >= 2 ? 17 : 19;
    *(_DWORD *)xmlValidCtxt v24 = v26;
    *((void *)v24 + 6) = v5[3];
    v5[3] = v24;
    if ((v12 + 1) <= 1)
    {
      if (*(void *)(a1 + 104) || (xmlHashTablePtr v27 = xmlHashCreate(10), (*(void *)(a1 + 104) = v27) != 0))
      {
        *(_OWORD *)__str = 0u;
        long long v37 = 0u;
        int v28 = *(_DWORD *)(a1 + 96);
        *(_DWORD *)(a1 + 96) = v28 + 1;
        snprintf(__str, 0x20uLL, "interleave%d", v28);
        if (xmlHashAddEntry(*(xmlHashTablePtr *)(a1 + 104), (const xmlChar *)__str, v25) < 0)
        {
          uint64_t v29 = v25[1];
          BOOL v30 = "Failed to add %s to hash table\n";
          int v31 = __str;
          uint64_t v32 = a1;
          goto LABEL_41;
        }
      }
      else
      {
        uint64_t v29 = v25[1];
        BOOL v30 = "Failed to create interleaves hash table\n";
        uint64_t v32 = a1;
        int v31 = 0;
LABEL_41:
        xmlRngPErr(v32, v29, 1046, v30, (const xmlChar *)v31, 0);
      }
    }
  }
LABEL_42:
  uint64_t v33 = (xmlHashTable *)v5[6];
  if (v33) {
    xmlHashScan(v33, (xmlHashScanner)xmlRelaxNGCheckCombine, (void *)a1);
  }
  int v34 = (xmlHashTable *)v5[7];
  if (v34) {
    xmlHashScan(v34, (xmlHashScanner)xmlRelaxNGCheckReference, (void *)a1);
  }
  *(void *)(a1 + 48) = v6;
  return v5;
}

_OWORD *xmlRelaxNGNewGrammar(uint64_t a1)
{
  unsigned int v2 = xmlMalloc(0x40uLL);
  BOOL v3 = v2;
  if (v2)
  {
    v2[2] = 0u;
    v2[3] = 0u;
    *unsigned int v2 = 0u;
    v2[1] = 0u;
  }
  else
  {
    xmlRngPErrMemory(a1, 0);
  }
  return v3;
}

uint64_t xmlRelaxNGParseStart(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a2 + 72) || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_17;
  }
  int v4 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"empty");
  uint64_t v5 = *(void *)(a2 + 72);
  if (v4)
  {
    if (xmlStrEqual(*(const xmlChar **)(v5 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      uint64_t v6 = (uint64_t *)xmlRelaxNGNewDefine(a1, a2);
      if (v6)
      {
        uint64_t v7 = v6;
        *(_DWORD *)uint64_t v6 = 0;
        if (!*(void *)(a2 + 24)) {
          goto LABEL_18;
        }
        uint64_t v8 = "element empty is not empty\n";
        uint64_t v9 = a1;
        uint64_t v10 = a2;
        int v11 = 1024;
        goto LABEL_8;
      }
      return 0xFFFFFFFFLL;
    }
    uint64_t v5 = *(void *)(a2 + 72);
  }
  if (v5
    && *(_DWORD *)(a2 + 8) == 1
    && xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"notAllowed")
    && xmlStrEqual(*(const xmlChar **)(*(void *)(a2 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
  {
    int v12 = (uint64_t *)xmlRelaxNGNewDefine(a1, a2);
    if (!v12) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v7 = v12;
    *(_DWORD *)int v12 = 1;
    if (*(void *)(a2 + 24))
    {
      uint64_t v8 = "element notAllowed is not empty\n";
      uint64_t v9 = a1;
      uint64_t v10 = a2;
      int v11 = 1055;
LABEL_8:
      xmlRngPErr(v9, v10, v11, v8, 0, 0);
    }
  }
  else
  {
LABEL_17:
    uint64_t v7 = xmlRelaxNGParsePatterns(a1, a2, 1);
  }
LABEL_18:
  uint64_t v13 = *(void *)(a1 + 48);
  uint64_t v16 = *(void *)(v13 + 24);
  uint64_t v14 = (uint64_t **)(v13 + 24);
  uint64_t v15 = v16;
  if (v16)
  {
    do
    {
      uint64_t v17 = v15;
      uint64_t v15 = *(void *)(v15 + 64);
    }
    while (v15);
    uint64_t v14 = (uint64_t **)(v17 + 64);
  }
  *uint64_t v14 = v7;
  uint64_t v18 = *(void *)(a2 + 48);
  if (v18)
  {
    xmlRngPErr(a1, v18, 1105, "start more than one children\n", 0, 0);
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t xmlRelaxNGCheckCycles(uint64_t a1, int *a2, uint64_t a3)
{
  if (!a2) {
    return 0;
  }
  int v4 = a2;
  uint64_t v6 = (a3 + 1);
  while (1)
  {
    int v7 = *v4;
    if (*v4 == 4)
    {
      uint64_t v11 = *((void *)v4 + 6);
      uint64_t v12 = a1;
      uint64_t v13 = v6;
      goto LABEL_13;
    }
    if (v7 != 13 && v7 != 11)
    {
      uint64_t v11 = *((void *)v4 + 6);
      uint64_t v12 = a1;
      uint64_t v13 = a3;
LABEL_13:
      uint64_t result = xmlRelaxNGCheckCycles(v12, v11, v13);
      goto LABEL_15;
    }
    int v9 = *((__int16 *)v4 + 48);
    if (v9 == -1)
    {
      *((_WORD *)v4 + 48) = a3;
      uint64_t result = xmlRelaxNGCheckCycles(a1, *((void *)v4 + 6), a3);
      *((_WORD *)v4 + 48) = -2;
      goto LABEL_15;
    }
    if (v9 == a3) {
      break;
    }
    uint64_t result = 0;
LABEL_15:
    int v4 = (int *)*((void *)v4 + 8);
    if (result) {
      BOOL v14 = 1;
    }
    else {
      BOOL v14 = v4 == 0;
    }
    if (v14) {
      return result;
    }
  }
  xmlRngPErr(a1, *((void *)v4 + 1), 1099, "Detected a cycle in %s references\n", *((const xmlChar **)v4 + 2), 0);
  return 0xFFFFFFFFLL;
}

uint64_t xmlRelaxNGSimplify(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (!a2) {
    return result;
  }
  uint64_t v4 = a2;
  uint64_t v5 = result;
  uint64_t v6 = 0;
  while (1)
  {
    int v7 = *(_DWORD *)v4;
    if (*(int *)v4 > 10)
    {
      if (v7 == 13 || v7 == 11)
      {
        if (*(__int16 *)(v4 + 96) != -3)
        {
          *(_WORD *)(v4 + 96) = -3;
          uint64_t result = xmlRelaxNGSimplify(v5, *(void *)(v4 + 48), v4);
        }
        goto LABEL_64;
      }
    }
    else
    {
      if (!v7)
      {
        *(void *)(v4 + 56) = a3;
        if (a3)
        {
          if ((*(_DWORD *)a3 - 15) < 2) {
            goto LABEL_73;
          }
          if ((*(_DWORD *)a3 & 0xFFFFFFFE) == 0x12)
          {
LABEL_61:
            if (v6)
            {
              *(void *)(v6 + 64) = *(void *)(v4 + 64);
            }
            else if (*(void *)(a3 + 48) == v4)
            {
              uint64_t v6 = 0;
              *(void *)(a3 + 48) = *(void *)(v4 + 64);
            }
            else if (*(void *)(a3 + 72) == v4)
            {
              uint64_t v6 = 0;
              *(void *)(a3 + 72) = *(void *)(v4 + 64);
            }
            else
            {
              uint64_t v6 = 0;
              if (*(void *)(a3 + 80) == v4) {
                *(void *)(a3 + 80) = *(void *)(v4 + 64);
              }
            }
            goto LABEL_64;
          }
        }
        goto LABEL_63;
      }
      if (v7 == 1)
      {
        *(void *)(v4 + 56) = a3;
LABEL_7:
        if (!a3) {
          goto LABEL_63;
        }
        int v8 = *(_DWORD *)a3;
        if (*(_DWORD *)a3 > 0x13u) {
          goto LABEL_63;
        }
        if (v8 == 17) {
          goto LABEL_61;
        }
        uint64_t v6 = v4;
        if (((1 << v8) & 0xD8300) != 0)
        {
          int v20 = 1;
          goto LABEL_74;
        }
        goto LABEL_64;
      }
    }
    *(void *)(v4 + 56) = a3;
    uint64_t v10 = *(void *)(v4 + 48);
    if (v10)
    {
      uint64_t result = xmlRelaxNGSimplify(v5, v10, v4);
      int v7 = *(_DWORD *)v4;
    }
    if (v7 != 7)
    {
      uint64_t v11 = *(void *)(v4 + 72);
      if (v11) {
        uint64_t result = xmlRelaxNGSimplify(v5, v11, v4);
      }
    }
    uint64_t v12 = *(void *)(v4 + 80);
    if (v12) {
      uint64_t result = xmlRelaxNGSimplify(v5, v12, v4);
    }
    if (*(_DWORD *)v4 == 4)
    {
      uint64_t v13 = *(void *)(v4 + 48);
      if (v13)
      {
        while (1)
        {
          uint64_t result = xmlRelaxNGGenerateAttributes(v5, v13);
          uint64_t v14 = *(void *)(v4 + 48);
          if (result != 1) {
            break;
          }
          uint64_t v13 = *(void *)(v14 + 64);
          *(void *)(v4 + 48) = v13;
          *(void *)(v14 + 64) = *(void *)(v4 + 72);
          *(void *)(v4 + 72) = v14;
          if (!v13) {
            goto LABEL_41;
          }
        }
        if (v14)
        {
          while (1)
          {
            uint64_t v15 = *(void *)(v14 + 64);
            if (!v15) {
              break;
            }
            uint64_t result = xmlRelaxNGGenerateAttributes(v5, *(void *)(v14 + 64));
            if (result == 1)
            {
              *(void *)(v14 + 64) = *(void *)(v15 + 64);
              *(void *)(v15 + 64) = *(void *)(v4 + 72);
              *(void *)(v4 + 72) = v15;
            }
            else
            {
              uint64_t v14 = v15;
            }
          }
        }
      }
    }
LABEL_41:
    int v16 = *(_DWORD *)v4;
    if ((*(_DWORD *)v4 & 0xFFFFFFFE) == 0x12) {
      break;
    }
LABEL_52:
    if (!v16) {
      goto LABEL_58;
    }
    if (v16 == 1) {
      goto LABEL_7;
    }
    if (v16 != 2) {
      goto LABEL_63;
    }
    uint64_t v19 = *(_DWORD **)(v4 + 48);
    if (!v19 || *v19 != 1) {
      goto LABEL_63;
    }
    uint64_t result = xmlRelaxNGTryUnlink(v4, (void *)a3, v6);
    uint64_t v6 = result;
LABEL_64:
    uint64_t v4 = *(void *)(v4 + 64);
    if (!v4) {
      return result;
    }
  }
  uint64_t v17 = *(void *)(v4 + 48);
  if (v17)
  {
    if (!*(void *)(v17 + 64))
    {
      if (!(a3 | v6))
      {
        *(_DWORD *)uint64_t v4 = -1;
        goto LABEL_63;
      }
      if (v6)
      {
        *(void *)(v17 + 64) = *(void *)(v4 + 64);
        uint64_t v18 = v6;
        uint64_t v4 = v17;
      }
      else
      {
        *(void *)(a3 + 48) = v17;
        uint64_t v17 = *(void *)(v4 + 64);
        uint64_t v18 = *(void *)(v4 + 48);
        uint64_t v4 = v18;
      }
      *(void *)(v18 + 64) = v17;
    }
    int v16 = *(_DWORD *)v4;
    goto LABEL_52;
  }
  *(_DWORD *)uint64_t v4 = 0;
LABEL_58:
  if (!a3)
  {
LABEL_63:
    uint64_t v6 = v4;
    goto LABEL_64;
  }
  if ((*(_DWORD *)a3 - 15) >= 2)
  {
    if ((*(_DWORD *)a3 - 17) <= 2) {
      goto LABEL_61;
    }
    goto LABEL_63;
  }
LABEL_73:
  int v20 = 0;
LABEL_74:
  *(_DWORD *)a3 = v20;
  return result;
}

uint64_t xmlRelaxNGCheckRules(uint64_t a1, unsigned int *a2, uint64_t a3, int a4)
{
  if (!a2) {
    return 0;
  }
  uint64_t v6 = a2;
  uint64_t v8 = 0;
  unsigned int v9 = a3 | 8;
  uint64_t v10 = (32 * a3) & 0x40 | a3;
  uint64_t v11 = (16 * a3) & 0x20 | a3;
  unsigned int v63 = a3 | 4;
  unsigned int v64 = a3 | 2;
  unsigned int v62 = a3 | 1;
  while (2)
  {
    uint64_t v12 = *v6;
    switch((int)v12)
    {
      case 0:
        if ((a3 & 8) != 0) {
          xmlRngPErr(a1, *((void *)v6 + 1), 1071, "Found forbidden pattern data/except//empty\n", 0, 0);
        }
        if ((a3 & 0x10) != 0) {
          xmlRngPErr(a1, *((void *)v6 + 1), 1090, "Found forbidden pattern start//empty\n", 0, 0);
        }
        goto LABEL_171;
      case 2:
        int v22 = (_DWORD *)*((void *)v6 + 7);
        uint64_t v21 = a3;
        if (v22)
        {
          if (*v22 == 5) {
            uint64_t v21 = v9;
          }
          else {
            uint64_t v21 = a3;
          }
        }
        uint64_t v19 = *((void *)v6 + 6);
        uint64_t v20 = a1;
        uint64_t v12 = 2;
        goto LABEL_167;
      case 3:
        if ((a3 & 4) != 0)
        {
          xmlRngPErr(a1, *((void *)v6 + 1), 1083, "Found forbidden pattern list//text\n", 0, 0);
          if ((a3 & 8) == 0)
          {
LABEL_33:
            if ((a3 & 0x10) == 0) {
              goto LABEL_80;
            }
            goto LABEL_79;
          }
        }
        else if ((a3 & 8) == 0)
        {
          goto LABEL_33;
        }
        xmlRngPErr(a1, *((void *)v6 + 1), 1077, "Found forbidden pattern data/except//text\n", 0, 0);
        if ((a3 & 0x10) == 0) {
          goto LABEL_80;
        }
LABEL_79:
        xmlRngPErr(a1, *((void *)v6 + 1), 1095, "Found forbidden pattern start//text\n", 0, 0);
        goto LABEL_80;
      case 4:
        xmlRelaxNGCheckGroupAttrs(a1, (uint64_t)v6);
        if ((a3 & 8) != 0)
        {
          xmlRngPErr(a1, *((void *)v6 + 1), 1070, "Found forbidden pattern data/except//element(ref)\n", 0, 0);
          if ((a3 & 4) == 0)
          {
LABEL_37:
            if ((a3 & 1) == 0) {
              goto LABEL_39;
            }
            goto LABEL_38;
          }
        }
        else if ((a3 & 4) == 0)
        {
          goto LABEL_37;
        }
        xmlRngPErr(a1, *((void *)v6 + 1), 1079, "Found forbidden pattern list//element(ref)\n", 0, 0);
        if ((a3 & 1) == 0)
        {
LABEL_39:
          if (xmlRelaxNGCheckRules(a1, *((void *)v6 + 9), 0, *v6)) {
            xmlRngPErr(a1, *((void *)v6 + 1), 1015, "Element %s attributes have a content type error\n", *((const xmlChar **)v6 + 2), 0);
          }
          if (xmlRelaxNGCheckRules(a1, *((void *)v6 + 6), 0, *v6) == -1)
          {
            xmlRngPErr(a1, *((void *)v6 + 1), 1016, "Element %s has a content type error\n", *((const xmlChar **)v6 + 2), 0);
            int v18 = -1;
            goto LABEL_172;
          }
LABEL_80:
          int v18 = 2;
          goto LABEL_172;
        }
LABEL_38:
        xmlRngPErr(a1, *((void *)v6 + 1), 1068, "Found forbidden pattern attribute//element(ref)\n", 0, 0);
        xmlRngPErr(a1, *((void *)v6 + 1), 1068, "Found forbidden pattern attribute//element(ref)\n", 0, 0);
        goto LABEL_39;
      case 5:
        if ((a3 & 0x10) == 0)
        {
          uint64_t v23 = 5;
          goto LABEL_87;
        }
        uint64_t v30 = *((void *)v6 + 1);
        uint64_t v31 = a1;
        int v32 = 1089;
        uint64_t v33 = "Found forbidden pattern start//data\n";
        goto LABEL_86;
      case 7:
        if ((a3 & 0x10) != 0)
        {
          uint64_t v30 = *((void *)v6 + 1);
          uint64_t v31 = a1;
          int v32 = 1096;
          uint64_t v33 = "Found forbidden pattern start//value\n";
LABEL_86:
          xmlRngPErr(v31, v30, v32, v33, 0, 0);
          uint64_t v23 = *v6;
        }
        else
        {
          uint64_t v23 = 7;
        }
LABEL_87:
        xmlRelaxNGCheckRules(a1, *((void *)v6 + 6), a3, v23);
        int v18 = 1;
        goto LABEL_172;
      case 8:
        if ((a3 & 4) != 0)
        {
          xmlRngPErr(a1, *((void *)v6 + 1), 1081, "Found forbidden pattern list//list\n", 0, 0);
          if ((a3 & 8) == 0)
          {
LABEL_49:
            if ((a3 & 0x10) == 0) {
              goto LABEL_51;
            }
            goto LABEL_50;
          }
        }
        else if ((a3 & 8) == 0)
        {
          goto LABEL_49;
        }
        xmlRngPErr(a1, *((void *)v6 + 1), 1074, "Found forbidden pattern data/except//list\n", 0, 0);
        if ((a3 & 0x10) == 0)
        {
LABEL_51:
          uint64_t v19 = *((void *)v6 + 6);
          uint64_t v12 = *v6;
          uint64_t v20 = a1;
          uint64_t v21 = v63;
          goto LABEL_167;
        }
LABEL_50:
        xmlRngPErr(a1, *((void *)v6 + 1), 1093, "Found forbidden pattern start//list\n", 0, 0);
        goto LABEL_51;
      case 9:
        if (a3)
        {
          xmlRngPErr(a1, *((void *)v6 + 1), 1067, "Found forbidden pattern attribute//attribute\n", 0, 0);
          if ((a3 & 4) == 0)
          {
LABEL_54:
            if ((a3 & 0x20) == 0) {
              goto LABEL_55;
            }
            goto LABEL_93;
          }
        }
        else if ((a3 & 4) == 0)
        {
          goto LABEL_54;
        }
        xmlRngPErr(a1, *((void *)v6 + 1), 1078, "Found forbidden pattern list//attribute\n", 0, 0);
        if ((a3 & 0x20) == 0)
        {
LABEL_55:
          if ((a3 & 0x40) == 0) {
            goto LABEL_56;
          }
          goto LABEL_94;
        }
LABEL_93:
        xmlRngPErr(a1, *((void *)v6 + 1), 1086, "Found forbidden pattern oneOrMore//group//attribute\n", 0, 0);
        if ((a3 & 0x40) == 0)
        {
LABEL_56:
          if ((a3 & 8) == 0) {
            goto LABEL_57;
          }
          goto LABEL_95;
        }
LABEL_94:
        xmlRngPErr(a1, *((void *)v6 + 1), 1087, "Found forbidden pattern oneOrMore//interleave//attribute\n", 0, 0);
        if ((a3 & 8) == 0)
        {
LABEL_57:
          if ((a3 & 0x10) == 0) {
            goto LABEL_58;
          }
          goto LABEL_96;
        }
LABEL_95:
        xmlRngPErr(a1, *((void *)v6 + 1), 1069, "Found forbidden pattern data/except//attribute\n", 0, 0);
        if ((a3 & 0x10) == 0)
        {
LABEL_58:
          if ((a3 & 2) != 0) {
            goto LABEL_170;
          }
          goto LABEL_97;
        }
LABEL_96:
        xmlRngPErr(a1, *((void *)v6 + 1), 1088, "Found forbidden pattern start//attribute\n", 0, 0);
        if ((a3 & 2) != 0) {
          goto LABEL_170;
        }
LABEL_97:
        if (!*((void *)v6 + 2) && !*((void *)v6 + 10))
        {
          if (*((void *)v6 + 3))
          {
            int v34 = 1056;
            uint64_t v35 = "Found nsName attribute without oneOrMore ancestor\n";
          }
          else
          {
            int v34 = 1000;
            uint64_t v35 = "Found anyName attribute without oneOrMore ancestor\n";
          }
          xmlRngPErr(a1, *((void *)v6 + 1), v34, v35, 0, 0);
        }
LABEL_170:
        xmlRelaxNGCheckRules(a1, *((void *)v6 + 6), v62, *v6);
LABEL_171:
        int v18 = 0;
        goto LABEL_172;
      case 11:
      case 13:
        if ((a3 & 8) != 0) {
          xmlRngPErr(a1, *((void *)v6 + 1), 1076, "Found forbidden pattern data/except//ref\n", 0, 0);
        }
        if (!*((void *)v6 + 6))
        {
          if (*v6 == 13)
          {
            uint64_t v13 = a1;
            uint64_t v14 = "Internal found no define for parent refs\n";
            uint64_t v15 = 0;
          }
          else
          {
            if (*((void *)v6 + 2)) {
              uint64_t v15 = (const xmlChar *)*((void *)v6 + 2);
            }
            else {
              uint64_t v15 = (const xmlChar *)"null";
            }
            uint64_t v13 = a1;
            uint64_t v14 = "Internal found no define for ref %s\n";
          }
          xmlRngPErr(v13, *((void *)v6 + 1), 1101, v14, v15, 0);
        }
        int v36 = *((__int16 *)v6 + 48);
        if (v36 < -3)
        {
          if (v36 == -4) {
            int v18 = 2;
          }
          else {
            int v18 = v36 + 15;
          }
        }
        else
        {
          *((_WORD *)v6 + 48) = -4;
          int v18 = xmlRelaxNGCheckRules(a1, *((void *)v6 + 6), a3, *v6);
          *((_WORD *)v6 + 48) = v18 - 15;
        }
        goto LABEL_172;
      case 15:
      case 16:
        if ((a3 & 8) != 0) {
          xmlRngPErr(a1, *((void *)v6 + 1), 1075, "Found forbidden pattern data/except//oneOrMore\n", 0, 0);
        }
        if ((a3 & 0x10) != 0) {
          xmlRngPErr(a1, *((void *)v6 + 1), 1094, "Found forbidden pattern start//oneOrMore\n", 0, 0);
        }
        int v16 = xmlRelaxNGCheckRules(a1, *((void *)v6 + 6), v64, *v6);
        if (v16 == 2) {
          int v17 = 2;
        }
        else {
          int v17 = -1;
        }
        if (!v16) {
          int v17 = 0;
        }
        if (v16 == -1) {
          int v18 = -1;
        }
        else {
          int v18 = v17;
        }
        goto LABEL_172;
      case 17:
        if ((*((_WORD *)v6 + 49) & 0x20) != 0 || *(_DWORD *)(a1 + 68)) {
          goto LABEL_166;
        }
        unsigned int v60 = v10;
        int v24 = xmlRelaxNGIsNullable((int *)v6);
        uint64_t v25 = *((void *)v6 + 6);
        unsigned int v59 = v11;
        for (uint64_t i = 0; v25; v25 = *(void *)(v25 + 64))
          ++i;
        uint64_t v65 = 8 * i;
        xmlHashTablePtr v27 = xmlMalloc(8 * i);
        if (!v27)
        {
          xmlRngPErrMemory(a1, (const xmlChar *)"building choice\n");
          uint64_t v11 = v11;
          uint64_t v10 = v60;
          goto LABEL_166;
        }
        int v28 = v27;
        unsigned int v58 = v9;
        if (v24)
        {
          uint64_t v29 = 0;
          int v66 = 0;
        }
        else
        {
          uint64_t v29 = xmlHashCreate(10);
          int v66 = 1;
        }
        uint64_t v37 = *((void *)v6 + 6);
        uint64_t v61 = a1;
        if (!v37) {
          goto LABEL_144;
        }
        uint64_t v38 = 0;
        do
        {
          int v39 = xmlRelaxNGGetElements(a1, (_DWORD *)v37, 0);
          v28[v38] = v39;
          if (!v39 || (uint64_t v40 = *v39) == 0)
          {
            int v66 = 0;
            goto LABEL_143;
          }
          if (v66 != 1) {
            goto LABEL_143;
          }
          long long v41 = v39 + 1;
          do
          {
            if (*(_DWORD *)v40 != 4)
            {
              if (*(_DWORD *)v40 != 3)
              {
                int v47 = -1;
                goto LABEL_142;
              }
              uint64_t v42 = v29;
              int v43 = "#text";
              goto LABEL_134;
            }
            int v43 = *(const char **)(v40 + 16);
            BOOL v44 = *(const xmlChar **)(v40 + 24);
            if (v43)
            {
              if (!v44 || !*v44)
              {
                uint64_t v42 = v29;
LABEL_134:
                BOOL v44 = 0;
                goto LABEL_135;
              }
              uint64_t v42 = v29;
            }
            else
            {
              if (!v44 || !*v44)
              {
                uint64_t v42 = v29;
                int v43 = "#any";
                goto LABEL_134;
              }
              uint64_t v42 = v29;
              int v43 = "#any";
            }
LABEL_135:
            int v45 = xmlHashAddEntry2(v42, (const xmlChar *)v43, v44, (void *)v37);
            if (v45) {
              break;
            }
            uint64_t v46 = *v41++;
            uint64_t v40 = v46;
          }
          while (v46);
          if (v45) {
            int v47 = -1;
          }
          else {
            int v47 = 1;
          }
LABEL_142:
          int v66 = v47;
          a1 = v61;
LABEL_143:
          ++v38;
          uint64_t v37 = *(void *)(v37 + 64);
        }
        while (v37);
LABEL_144:
        if (i)
        {
          uint64_t v48 = 0;
          int v49 = 0;
          do
          {
            if (v48 && v28[v48])
            {
              for (uint64_t j = 0; j != v48; ++j)
              {
                xmlURIPtr v51 = (void **)v28[j];
                if (v51 && !xmlRelaxNGCompareElemDefLists(v28[v48], v51)) {
                  int v49 = 1;
                }
              }
            }
            ++v48;
          }
          while (v48 != i);
          unint64_t v52 = 0;
          unsigned int v9 = v58;
          do
          {
            int v53 = (void *)v28[v52 / 8];
            if (v53) {
              xmlFree(v53);
            }
            v52 += 8;
          }
          while (v65 != v52);
          xmlFree(v28);
          if (v49) {
            *((_WORD *)v6 + 49) |= 4u;
          }
        }
        else
        {
          xmlFree(v28);
          unsigned int v9 = v58;
        }
        uint64_t v11 = v59;
        uint64_t v10 = v60;
        if (v66 == 1)
        {
          *((_WORD *)v6 + 49) |= 0x10u;
          *((void *)v6 + 5) = v29;
          a1 = v61;
        }
        else
        {
          a1 = v61;
          if (v29) {
            xmlHashFree(v29, 0);
          }
        }
        *((_WORD *)v6 + 49) |= 0x20u;
LABEL_166:
        uint64_t v19 = *((void *)v6 + 6);
        uint64_t v12 = *v6;
        uint64_t v20 = a1;
        uint64_t v21 = a3;
LABEL_167:
        int v18 = xmlRelaxNGCheckRules(v20, v19, v21, v12);
LABEL_172:
        uint64_t v6 = (unsigned int *)*((void *)v6 + 8);
        if (a4 <= 16)
        {
          if (a4 == 2)
          {
            if (v18 == -1) {
              uint64_t v8 = 0xFFFFFFFFLL;
            }
            else {
              uint64_t v8 = 1;
            }
            if (!v6) {
              return v8;
            }
          }
          else
          {
            if (a4 != 8) {
              goto LABEL_180;
            }
            uint64_t v8 = 1;
            if (!v6) {
              return v8;
            }
          }
          continue;
        }
        if (a4 == 17)
        {
          if (v18 == 2 || v8 == 2) {
            unsigned int v55 = 2;
          }
          else {
            unsigned int v55 = 0;
          }
          if (v18 == 1) {
            unsigned int v55 = 1;
          }
          if (v8 == 1) {
            unsigned int v55 = 1;
          }
LABEL_201:
          if (v18 == -1) {
            unsigned int v55 = -1;
          }
          if (v8 == -1) {
            uint64_t v8 = 0xFFFFFFFFLL;
          }
          else {
            uint64_t v8 = v55;
          }
        }
        else if (a4 != 19)
        {
LABEL_180:
          if (v18 == 2 && v8 == 2) {
            unsigned int v55 = 2;
          }
          else {
            unsigned int v55 = -1;
          }
          if (!v18) {
            unsigned int v55 = v8;
          }
          if (!v8) {
            unsigned int v55 = v18;
          }
          goto LABEL_201;
        }
        if (v6) {
          continue;
        }
        return v8;
      case 18:
        if ((a3 & 8) != 0) {
          xmlRngPErr(a1, *((void *)v6 + 1), 1072, "Found forbidden pattern data/except//group\n", 0, 0);
        }
        if ((a3 & 0x10) != 0) {
          xmlRngPErr(a1, *((void *)v6 + 1), 1091, "Found forbidden pattern start//group\n", 0, 0);
        }
        int v18 = xmlRelaxNGCheckRules(a1, *((void *)v6 + 6), v11, *v6);
        xmlRelaxNGCheckGroupAttrs(a1, (uint64_t)v6);
        goto LABEL_172;
      case 19:
        if ((a3 & 4) != 0)
        {
          xmlRngPErr(a1, *((void *)v6 + 1), 1080, "Found forbidden pattern list//interleave\n", 0, 0);
          if ((a3 & 8) == 0)
          {
LABEL_74:
            if ((a3 & 0x10) == 0) {
              goto LABEL_76;
            }
            goto LABEL_75;
          }
        }
        else if ((a3 & 8) == 0)
        {
          goto LABEL_74;
        }
        xmlRngPErr(a1, *((void *)v6 + 1), 1073, "Found forbidden pattern data/except//interleave\n", 0, 0);
        if ((a3 & 0x10) == 0)
        {
LABEL_76:
          uint64_t v19 = *((void *)v6 + 6);
          uint64_t v12 = *v6;
          uint64_t v20 = a1;
          uint64_t v21 = v10;
          goto LABEL_167;
        }
LABEL_75:
        xmlRngPErr(a1, *((void *)v6 + 1), 1073, "Found forbidden pattern start//interleave\n", 0, 0);
        goto LABEL_76;
      default:
        uint64_t v19 = *((void *)v6 + 6);
        uint64_t v20 = a1;
        uint64_t v21 = a3;
        goto LABEL_167;
    }
  }
}

uint64_t xmlRelaxNGParseGrammarContent(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = a2;
    uint64_t v4 = 0;
    uint64_t v5 = (const xmlChar *)"define";
    uint64_t v6 = (const xmlChar *)"include";
    while (1)
    {
      if (!*(void *)(v3 + 72) || *(_DWORD *)(v3 + 8) != 1) {
        goto LABEL_35;
      }
      int v7 = xmlStrEqual(*(const xmlChar **)(v3 + 16), (const xmlChar *)"start");
      uint64_t v8 = *(void *)(v3 + 72);
      if (v7)
      {
        if (xmlStrEqual(*(const xmlChar **)(v8 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
          uint64_t v9 = *(void *)(v3 + 24);
          if (v9)
          {
            if (xmlRelaxNGParseStart(a1, v9)) {
              uint64_t v4 = 0xFFFFFFFFLL;
            }
            else {
              uint64_t v4 = v4;
            }
          }
          else
          {
            xmlRngPErr(a1, v3, 1106, "start has no children\n", 0, 0);
          }
          goto LABEL_37;
        }
        uint64_t v8 = *(void *)(v3 + 72);
      }
      if (!v8 || *(_DWORD *)(v3 + 8) != 1) {
        goto LABEL_35;
      }
      int v10 = xmlStrEqual(*(const xmlChar **)(v3 + 16), v5);
      uint64_t v11 = *(void *)(v3 + 72);
      if (!v10) {
        goto LABEL_24;
      }
      if (!xmlStrEqual(*(const xmlChar **)(v11 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0")) {
        break;
      }
      Prop = xmlGetProp((const xmlNode *)v3, (const xmlChar *)"name");
      if (Prop)
      {
        uint64_t v13 = Prop;
        xmlRelaxNGNormExtSpace(Prop);
        if (xmlValidateNCName(v13, 0)) {
          xmlRngPErr(a1, v3, 1049, "define name '%s' is not an NCName\n", v13, 0);
        }
        uint64_t v14 = xmlRelaxNGNewDefine(a1, v3);
        if (!v14)
        {
          xmlFree(v13);
LABEL_52:
          uint64_t v4 = 0xFFFFFFFFLL;
          goto LABEL_37;
        }
        uint64_t v15 = v14;
        *(_DWORD *)uint64_t v14 = 10;
        *((void *)v14 + 2) = v13;
        uint64_t v16 = *(void *)(v3 + 24);
        if (v16)
        {
          int v17 = v5;
          int v18 = v6;
          uint64_t v19 = *(void *)(a1 + 80);
          *(void *)(a1 + 80) = v13;
          *((void *)v14 + 6) = xmlRelaxNGParsePatterns(a1, v16, 0);
          *(void *)(a1 + 80) = v19;
          uint64_t v6 = v18;
          uint64_t v5 = v17;
        }
        else
        {
          xmlRngPErr(a1, v3, 1012, "define has no children\n", 0, 0);
        }
        uint64_t v29 = *(xmlHashTable **)(*(void *)(a1 + 48) + 48);
        if (!v29)
        {
          uint64_t v29 = xmlHashCreate(10);
          *(void *)(*(void *)(a1 + 48) + 48) = v29;
          if (!v29)
          {
            uint64_t v32 = a1;
            uint64_t v33 = v3;
            int v34 = "Could not create definition hash\n";
            uint64_t v35 = 0;
LABEL_51:
            xmlRngPErr(v32, v33, 1011, v34, v35, 0);
            goto LABEL_52;
          }
        }
        if (xmlHashAddEntry(v29, v13, v15) < 0)
        {
          uint64_t v30 = xmlHashLookup(*(xmlHashTablePtr *)(*(void *)(a1 + 48) + 48), v13);
          if (v30)
          {
            do
            {
              uint64_t v31 = v30;
              uint64_t v30 = (void *)v30[11];
            }
            while (v30);
            v31[11] = v15;
            goto LABEL_37;
          }
          uint64_t v32 = a1;
          uint64_t v33 = v3;
          int v34 = "Internal error on define aggregation of %s\n";
          uint64_t v35 = v13;
          goto LABEL_51;
        }
      }
      else
      {
        xmlRngPErr(a1, v3, 1014, "define has no name\n", 0, 0);
      }
LABEL_37:
      uint64_t v3 = *(void *)(v3 + 48);
      if (!v3) {
        return v4;
      }
    }
    uint64_t v11 = *(void *)(v3 + 72);
LABEL_24:
    if (v11
      && *(_DWORD *)(v3 + 8) == 1
      && xmlStrEqual(*(const xmlChar **)(v3 + 16), v6)
      && xmlStrEqual(*(const xmlChar **)(*(void *)(v3 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      uint64_t v20 = *(void *)(v3 + 104);
      if (v20)
      {
        xmlNodePtr RootElement = xmlDocGetRootElement(*(const xmlDoc **)(v20 + 16));
        if (RootElement)
        {
          xmlNodePtr v22 = RootElement;
          if (xmlStrEqual(RootElement->name, (const xmlChar *)"grammar"))
          {
            if (v22->children)
            {
              if (xmlRelaxNGParseGrammarContent(a1)) {
                int v23 = -1;
              }
              else {
                int v23 = 0;
              }
            }
            else
            {
              int v23 = 0;
            }
            if (!*(void *)(v3 + 24) || !xmlRelaxNGParseGrammarContent(a1))
            {
              if (v23) {
                uint64_t v4 = 0xFFFFFFFFLL;
              }
              else {
                uint64_t v4 = v4;
              }
              goto LABEL_37;
            }
            goto LABEL_60;
          }
          uint64_t v36 = a1;
          uint64_t v37 = v3;
          int v38 = 1038;
          int v39 = "Include document root is not a grammar\n";
        }
        else
        {
          uint64_t v36 = a1;
          uint64_t v37 = v3;
          int v38 = 1022;
          int v39 = "Include document is empty\n";
        }
        xmlRngPErr(v36, v37, v38, v39, 0, 0);
LABEL_60:
        uint64_t v4 = 0xFFFFFFFFLL;
        goto LABEL_37;
      }
      uint64_t v25 = a1;
      uint64_t v26 = v3;
      int v27 = 1042;
      int v28 = "Include node has no data\n";
      int v24 = 0;
    }
    else
    {
LABEL_35:
      int v24 = *(const xmlChar **)(v3 + 16);
      uint64_t v25 = a1;
      uint64_t v26 = v3;
      int v27 = 1036;
      int v28 = "grammar has unexpected child %s\n";
    }
    xmlRngPErr(v25, v26, v27, v28, v24, 0);
    uint64_t v4 = 0xFFFFFFFFLL;
    goto LABEL_37;
  }
  xmlRngPErr(a1, 0, 1037, "grammar has no children\n", 0, 0);
  return 0xFFFFFFFFLL;
}

_OWORD *xmlRelaxNGCheckCombine(_OWORD *result, uint64_t a2, const xmlChar *a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (!*((void *)result + 11)) {
    return result;
  }
  uint64_t v5 = result;
  int v6 = 0;
  int v7 = -1;
  uint64_t v8 = (const xmlNode **)result;
  do
  {
    Prop = xmlGetProp(v8[1], (const xmlChar *)"combine");
    if (Prop)
    {
      int v10 = Prop;
      if (xmlStrEqual(Prop, (const xmlChar *)"choice"))
      {
        if (v7)
        {
          int v7 = 1;
LABEL_15:
          xmlFree(v10);
          goto LABEL_16;
        }
      }
      else
      {
        if (!xmlStrEqual(v10, (const xmlChar *)"interleave"))
        {
          uint64_t v11 = *((void *)v5 + 1);
          uint64_t v12 = a2;
          int v13 = 1114;
          uint64_t v14 = "Defines for %s use unknown combine value '%s''\n";
          uint64_t v15 = a3;
          uint64_t v16 = v10;
          goto LABEL_14;
        }
        if (v7 != 1)
        {
          int v7 = 0;
          goto LABEL_15;
        }
      }
      uint64_t v11 = *((void *)v5 + 1);
      uint64_t v12 = a2;
      int v13 = 1010;
      uint64_t v14 = "Defines for %s use both 'choice' and 'interleave'\n";
      uint64_t v15 = a3;
      uint64_t v16 = 0;
LABEL_14:
      xmlRngPErr(v12, v11, v13, v14, v15, v16);
      goto LABEL_15;
    }
    if (v6) {
      xmlRngPErr(a2, *((void *)v5 + 1), 1054, "Some defines for %s needs the combine attribute\n", a3, 0);
    }
    int v6 = 1;
LABEL_16:
    uint64_t v8 = (const xmlNode **)v8[11];
  }
  while (v8);
  uint64_t result = xmlRelaxNGNewDefine(a2, *((void *)v5 + 1));
  if (result)
  {
    int v17 = result;
    int v18 = 0;
    unsigned int v19 = v7 + 1;
    if ((v7 + 1) >= 2) {
      int v20 = 17;
    }
    else {
      int v20 = 19;
    }
    *(_DWORD *)uint64_t result = v20;
    uint64_t v21 = result + 3;
    xmlNodePtr v22 = v5;
    do
    {
      uint64_t result = (_OWORD *)*((void *)v22 + 6);
      if (result)
      {
        if (*((void *)result + 8))
        {
          uint64_t result = xmlRelaxNGNewDefine(a2, *((void *)result + 1));
          if (!result) {
            break;
          }
          *(_DWORD *)uint64_t result = 18;
          *((void *)result + 6) = *((void *)v22 + 6);
        }
        int v23 = v18 + 4;
        if (!v18) {
          int v23 = v21;
        }
        void *v23 = result;
        int v18 = result;
      }
      *((void *)v22 + 6) = v17;
      xmlNodePtr v22 = (_OWORD *)*((void *)v22 + 11);
    }
    while (v22);
    *((void *)v5 + 6) = v17;
    if (v19 <= 1)
    {
      if (*(void *)(a2 + 104) || (xmlHashTablePtr v24 = xmlHashCreate(10), (*(void *)(a2 + 104) = v24) != 0))
      {
        *(_OWORD *)__str = 0u;
        long long v28 = 0u;
        int v25 = *(_DWORD *)(a2 + 96);
        *(_DWORD *)(a2 + 96) = v25 + 1;
        snprintf(__str, 0x20uLL, "interleave%d", v25);
        uint64_t result = (_OWORD *)xmlHashAddEntry(*(xmlHashTablePtr *)(a2 + 104), (const xmlChar *)__str, v17);
        if ((result & 0x80000000) != 0) {
          return xmlRngPErr(a2, *((void *)v5 + 1), 1046, "Failed to add %s to hash table\n", (const xmlChar *)__str, 0);
        }
      }
      else
      {
        uint64_t v26 = *((void *)v5 + 1);
        return xmlRngPErr(a2, v26, 1046, "Failed to create interleaves hash table\n", 0, 0);
      }
    }
  }
  return result;
}

_DWORD *xmlRelaxNGCheckReference(_DWORD *result, uint64_t a2, const xmlChar *a3)
{
  if ((*((_WORD *)result + 49) & 0x100) != 0) {
    return result;
  }
  uint64_t v5 = result;
  uint64_t v6 = *(void *)(a2 + 48);
  if (v6)
  {
    if (!*((void *)result + 6))
    {
      uint64_t v11 = *(xmlHashTable **)(v6 + 48);
      if (v11)
      {
        uint64_t result = xmlHashLookup(v11, a3);
        if (result)
        {
          do
          {
            v5[6] = result;
            uint64_t v5 = (void *)v5[11];
          }
          while (v5);
          return result;
        }
      }
      uint64_t v7 = v5[1];
      uint64_t v8 = "Reference %s has no matching definition\n";
      uint64_t v9 = a2;
      int v10 = 1101;
      goto LABEL_7;
    }
    uint64_t v7 = *((void *)result + 1);
    uint64_t v8 = "Internal error: reference has content in CheckReference %s\n";
  }
  else
  {
    uint64_t v7 = *((void *)result + 1);
    uint64_t v8 = "Internal error: no grammar in CheckReference %s\n";
  }
  uint64_t v9 = a2;
  int v10 = 1;
LABEL_7:

  return xmlRngPErr(v9, v7, v10, v8, a3, 0);
}

uint64_t *xmlRelaxNGParsePatterns(uint64_t a1, uint64_t a2, int a3)
{
  if (!a2) {
    return 0;
  }
  uint64_t v4 = a2;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = *(void *)(a1 + 88);
  do
  {
    if (*(void *)(v4 + 72)
      && *(_DWORD *)(v4 + 8) == 1
      && xmlStrEqual(*(const xmlChar **)(v4 + 16), (const xmlChar *)"element")
      && xmlStrEqual(*(const xmlChar **)(*(void *)(v4 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      uint64_t v9 = (uint64_t *)xmlRelaxNGParseElement(a1, v4);
      if (!v9) {
        return 0;
      }
      int v10 = v9;
      if (v7)
      {
        if (a3 == 1 && *(_DWORD *)v7 == 4 && v7 == v6)
        {
          uint64_t v11 = (uint64_t *)xmlRelaxNGNewDefine(a1, v4);
          uint64_t v7 = v11;
          if (!v11) {
            return v7;
          }
          *(_DWORD *)uint64_t v11 = 18;
          v11[6] = (uint64_t)v6;
        }
        v6[8] = (uint64_t)v10;
        uint64_t v9 = v7;
      }
      _OWORD v10[7] = v8;
      uint64_t v7 = v9;
    }
    else
    {
      uint64_t v12 = xmlRelaxNGParsePattern(a1, v4);
      if (v12)
      {
        int v10 = v12;
        if (v7) {
          v6[8] = (uint64_t)v12;
        }
        else {
          uint64_t v7 = v12;
        }
      }
      else
      {
        int v10 = v6;
      }
    }
    uint64_t v4 = *(void *)(v4 + 48);
    uint64_t v6 = v10;
  }
  while (v4);
  return v7;
}

_OWORD *xmlRelaxNGParseElement(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = xmlRelaxNGNewDefine(a1, a2);
  uint64_t v5 = v4;
  if (!v4) {
    return v5;
  }
  *(_DWORD *)uint64_t v4 = 4;
  *((void *)v4 + 7) = *(void *)(a1 + 88);
  uint64_t v6 = *(void *)(a2 + 24);
  if (!v6)
  {
    int v17 = "xmlRelaxNGParseElement: element has no children\n";
    uint64_t v18 = a1;
    uint64_t v19 = a2;
    int v20 = 1017;
LABEL_27:
    xmlRngPErr(v18, v19, v20, v17, 0, 0);
    return v5;
  }
  if (xmlRelaxNGParseNameClass(a1, *(void *)(a2 + 24), (uint64_t)v4))
  {
    uint64_t v6 = *(void *)(v6 + 48);
    if (!v6)
    {
      int v17 = "xmlRelaxNGParseElement: element has no content\n";
      uint64_t v18 = a1;
      uint64_t v19 = a2;
      int v20 = 1020;
      goto LABEL_27;
    }
  }
  uint64_t v7 = 0;
  uint64_t v8 = (uint64_t **)(v5 + 3);
  uint64_t v9 = *(void *)(a1 + 80);
  *(void *)(a1 + 80) = 0;
  do
  {
    int v10 = xmlRelaxNGParsePattern(a1, v6);
    if (v10)
    {
      uint64_t v11 = v10;
      _OWORD v10[7] = (uint64_t)v5;
      switch(*(_DWORD *)v10)
      {
        case 0xFFFFFFFF:
          uint64_t v14 = a1;
          uint64_t v15 = a2;
          uint64_t v16 = "RNG Internal error, noop found in element\n";
          goto LABEL_21;
        case 0:
        case 1:
        case 3:
        case 4:
        case 5:
        case 7:
        case 8:
        case 0xA:
        case 0xB:
        case 0xC:
        case 0xD:
        case 0xE:
        case 0xF:
        case 0x10:
        case 0x11:
        case 0x12:
        case 0x13:
          if (v7)
          {
            if (*(_DWORD *)v7 == 4 && *v8 == v7)
            {
              uint64_t v12 = (uint64_t *)xmlRelaxNGNewDefine(a1, a2);
              *uint64_t v8 = v12;
              int v13 = (uint64_t **)(v5 + 3);
              if (v12)
              {
                *(_DWORD *)uint64_t v12 = 18;
                int v13 = (uint64_t **)(v12 + 6);
              }
              *int v13 = v7;
            }
            v7[8] = (uint64_t)v11;
          }
          else
          {
            *uint64_t v8 = v10;
          }
          goto LABEL_23;
        case 2:
          uint64_t v14 = a1;
          uint64_t v15 = a2;
          uint64_t v16 = "RNG Internal error, except found in element\n";
          goto LABEL_21;
        case 6:
          uint64_t v14 = a1;
          uint64_t v15 = a2;
          uint64_t v16 = "RNG Internal error, param found in element\n";
          goto LABEL_21;
        case 9:
          v10[8] = *((void *)v5 + 9);
          *((void *)v5 + 9) = v10;
          break;
        case 0x14:
          uint64_t v14 = a1;
          uint64_t v15 = a2;
          uint64_t v16 = "RNG Internal error, start found in element\n";
LABEL_21:
          xmlRngPErr(v14, v15, 1018, v16, 0, 0);
          break;
        default:
          break;
      }
    }
    uint64_t v11 = v7;
LABEL_23:
    uint64_t v6 = *(void *)(v6 + 48);
    uint64_t v7 = v11;
  }
  while (v6);
  *(void *)(a1 + 80) = v9;
  return v5;
}

uint64_t *xmlRelaxNGParsePattern(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a2 + 72) || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_263;
  }
  int v4 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"element");
  uint64_t v5 = *(void *)(a2 + 72);
  if (v4)
  {
    if (xmlStrEqual(*(const xmlChar **)(v5 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      return (uint64_t *)xmlRelaxNGParseElement(a1, a2);
    }
    uint64_t v5 = *(void *)(a2 + 72);
  }
  if (!v5 || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_263;
  }
  int v7 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"attribute");
  uint64_t v8 = *(void *)(a2 + 72);
  if (v7)
  {
    if (xmlStrEqual(*(const xmlChar **)(v8 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      uint64_t v9 = xmlRelaxNGNewDefine(a1, a2);
      int v10 = v9;
      if (!v9) {
        return (uint64_t *)v10;
      }
      *(_DWORD *)uint64_t v9 = 9;
      *((void *)v9 + 7) = *(void *)(a1 + 88);
      uint64_t v11 = *(void *)(a2 + 24);
      if (v11)
      {
        int v12 = *(_DWORD *)(a1 + 64);
        *(_DWORD *)(a1 + 64) = v12 | 1;
        if (!xmlRelaxNGParseNameClass(a1, v11, (uint64_t)v9) || (uint64_t v11 = *(void *)(v11 + 48)) != 0)
        {
          uint64_t v13 = xmlRelaxNGParsePattern(a1, v11);
          if (v13)
          {
            unsigned int v14 = *(_DWORD *)v13 + 1;
            if (v14 <= 0x15)
            {
              int v15 = 1 << v14;
              if ((v15 & 0x1FFF76) != 0)
              {
                *((void *)v10 + 6) = v13;
                *(void *)(v13 + 56) = v10;
              }
              else
              {
                if ((v15 & 0x200088) != 0)
                {
                  long long v28 = "attribute has invalid content\n";
                  uint64_t v29 = a1;
                  uint64_t v30 = a2;
                  int v31 = 1003;
                }
                else
                {
                  long long v28 = "RNG Internal error, noop found in attribute\n";
                  uint64_t v29 = a1;
                  uint64_t v30 = a2;
                  int v31 = 1005;
                }
                xmlRngPErr(v29, v30, v31, v28, 0, 0);
              }
            }
          }
          if (*(void *)(v11 + 48)) {
            xmlRngPErr(a1, a2, 1002, "attribute has multiple children\n", 0, 0);
          }
        }
        *(_DWORD *)(a1 + 64) = v12;
        return (uint64_t *)v10;
      }
      uint64_t v19 = "xmlRelaxNGParseattribute: attribute has no children\n";
      uint64_t v20 = a1;
      uint64_t v21 = a2;
      int v22 = 1004;
      goto LABEL_33;
    }
    uint64_t v8 = *(void *)(a2 + 72);
  }
  if (!v8 || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_263;
  }
  int v16 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"empty");
  uint64_t v17 = *(void *)(a2 + 72);
  if (v16)
  {
    if (xmlStrEqual(*(const xmlChar **)(v17 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      uint64_t v18 = xmlRelaxNGNewDefine(a1, a2);
      int v10 = v18;
      if (!v18) {
        return (uint64_t *)v10;
      }
      *(_DWORD *)uint64_t v18 = 0;
      if (!*(void *)(a2 + 24)) {
        return (uint64_t *)v10;
      }
      uint64_t v19 = "empty: had a child node\n";
      uint64_t v20 = a1;
      uint64_t v21 = a2;
      int v22 = 1025;
      goto LABEL_33;
    }
    uint64_t v17 = *(void *)(a2 + 72);
  }
  if (!v17 || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_263;
  }
  int v25 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"text");
  uint64_t v26 = *(void *)(a2 + 72);
  if (v25)
  {
    if (xmlStrEqual(*(const xmlChar **)(v26 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      int v27 = xmlRelaxNGNewDefine(a1, a2);
      int v10 = v27;
      if (!v27) {
        return (uint64_t *)v10;
      }
      *(_DWORD *)int v27 = 3;
      if (!*(void *)(a2 + 24)) {
        return (uint64_t *)v10;
      }
      uint64_t v19 = "text: had a child node\n";
      uint64_t v20 = a1;
      uint64_t v21 = a2;
      int v22 = 1109;
      goto LABEL_33;
    }
    uint64_t v26 = *(void *)(a2 + 72);
  }
  if (!v26 || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_263;
  }
  int v32 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"zeroOrMore");
  uint64_t v33 = *(void *)(a2 + 72);
  if (v32)
  {
    if (xmlStrEqual(*(const xmlChar **)(v33 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      int v10 = xmlRelaxNGNewDefine(a1, a2);
      if (!v10) {
        return (uint64_t *)v10;
      }
      int v34 = 15;
LABEL_53:
      *(_DWORD *)int v10 = v34;
      if (*(void *)(a2 + 24))
      {
        uint64_t v35 = a1;
LABEL_55:
        uint64_t v36 = (_OWORD *)xmlRelaxNGParsePatterns(v35);
LABEL_56:
        *((void *)v10 + 6) = v36;
        return (uint64_t *)v10;
      }
      goto LABEL_82;
    }
    uint64_t v33 = *(void *)(a2 + 72);
  }
  if (!v33 || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_263;
  }
  int v37 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"oneOrMore");
  uint64_t v38 = *(void *)(a2 + 72);
  if (v37)
  {
    if (xmlStrEqual(*(const xmlChar **)(v38 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      int v10 = xmlRelaxNGNewDefine(a1, a2);
      if (!v10) {
        return (uint64_t *)v10;
      }
      int v34 = 16;
      goto LABEL_53;
    }
    uint64_t v38 = *(void *)(a2 + 72);
  }
  if (!v38 || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_263;
  }
  int v39 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"optional");
  uint64_t v40 = *(void *)(a2 + 72);
  if (v39)
  {
    if (xmlStrEqual(*(const xmlChar **)(v40 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      int v10 = xmlRelaxNGNewDefine(a1, a2);
      if (!v10) {
        return (uint64_t *)v10;
      }
      int v34 = 14;
      goto LABEL_53;
    }
    uint64_t v40 = *(void *)(a2 + 72);
  }
  if (!v40 || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_263;
  }
  int v41 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"choice");
  uint64_t v42 = *(void *)(a2 + 72);
  if (v41)
  {
    if (xmlStrEqual(*(const xmlChar **)(v42 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      int v10 = xmlRelaxNGNewDefine(a1, a2);
      if (!v10) {
        return (uint64_t *)v10;
      }
      int v43 = 17;
LABEL_80:
      *(_DWORD *)int v10 = v43;
      if (*(void *)(a2 + 24))
      {
        uint64_t v35 = a1;
        goto LABEL_55;
      }
LABEL_82:
      name = *(const xmlChar **)(a2 + 16);
      uint64_t v19 = "Element %s is empty\n";
      uint64_t v20 = a1;
      uint64_t v21 = a2;
      int v22 = 1023;
      goto LABEL_34;
    }
    uint64_t v42 = *(void *)(a2 + 72);
  }
  if (!v42 || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_263;
  }
  int v44 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"group");
  uint64_t v45 = *(void *)(a2 + 72);
  if (v44)
  {
    if (xmlStrEqual(*(const xmlChar **)(v45 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      int v10 = xmlRelaxNGNewDefine(a1, a2);
      if (!v10) {
        return (uint64_t *)v10;
      }
      int v43 = 18;
      goto LABEL_80;
    }
    uint64_t v45 = *(void *)(a2 + 72);
  }
  if (!v45 || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_263;
  }
  int v46 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"ref");
  uint64_t v47 = *(void *)(a2 + 72);
  if (v46)
  {
    if (xmlStrEqual(*(const xmlChar **)(v47 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      uint64_t v48 = xmlRelaxNGNewDefine(a1, a2);
      int v10 = v48;
      if (!v48) {
        return (uint64_t *)v10;
      }
      *(_DWORD *)uint64_t v48 = 11;
      Prop = xmlGetProp((const xmlNode *)a2, (const xmlChar *)"name");
      *((void *)v10 + 2) = Prop;
      if (Prop)
      {
        xmlRelaxNGNormExtSpace(Prop);
        if (!xmlValidateNCName(*((const xmlChar **)v10 + 2), 0))
        {
LABEL_119:
          if (*(void *)(a2 + 24)) {
            xmlRngPErr(a1, a2, 1103, "ref is not empty\n", 0, 0);
          }
          unsigned int v63 = *(xmlHashTable **)(*(void *)(a1 + 48) + 56);
          if (v63 || (unsigned int v63 = xmlHashCreate(10), (*(void *)(*(void *)(a1 + 48) + 56) = v63) != 0))
          {
            if ((xmlHashAddEntry(v63, *((const xmlChar **)v10 + 2), v10) & 0x80000000) == 0) {
              return (uint64_t *)v10;
            }
            unsigned int v64 = xmlHashLookup(*(xmlHashTablePtr *)(*(void *)(a1 + 48) + 56), *((const xmlChar **)v10 + 2));
            if (v64)
            {
LABEL_125:
              *((void *)v10 + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v64[11];
              v64[11] = v10;
              return (uint64_t *)v10;
            }
            uint64_t v78 = (const xmlChar *)*((void *)v10 + 2);
            if (v78) {
              long long v74 = "Error refs definitions '%s'\n";
            }
            else {
              long long v74 = "Error refs definitions\n";
            }
            uint64_t v75 = a1;
            uint64_t v76 = a2;
            int v77 = 1098;
            goto LABEL_264;
          }
          long long v74 = "Could not create references hash\n";
          uint64_t v75 = a1;
          uint64_t v76 = a2;
          int v77 = 1098;
          goto LABEL_145;
        }
        int v50 = (const xmlChar *)*((void *)v10 + 2);
        xmlURIPtr v51 = "ref name '%s' is not an NCName\n";
        uint64_t v52 = a1;
        uint64_t v53 = a2;
        int v54 = 1100;
      }
      else
      {
        xmlURIPtr v51 = "ref has no name\n";
        uint64_t v52 = a1;
        uint64_t v53 = a2;
        int v54 = 1102;
        int v50 = 0;
      }
      xmlRngPErr(v52, v53, v54, v51, v50, 0);
      goto LABEL_119;
    }
    uint64_t v47 = *(void *)(a2 + 72);
  }
  if (!v47 || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_263;
  }
  int v55 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"data");
  uint64_t v56 = *(void *)(a2 + 72);
  if (v55)
  {
    if (xmlStrEqual(*(const xmlChar **)(v56 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      uint64_t v57 = xmlGetProp((const xmlNode *)a2, (const xmlChar *)"type");
      if (v57)
      {
        unsigned int v58 = v57;
        xmlRelaxNGNormExtSpace(v57);
        if (xmlValidateNCName(v58, 0)) {
          xmlRngPErr(a1, a2, 1112, "data type '%s' is not an NCName\n", v58, 0);
        }
        unsigned int v59 = xmlRelaxNGGetDataTypeLibrary(a2);
        if (!v59) {
          unsigned int v59 = xmlStrdup((const xmlChar *)"http://relaxng.org/ns/structure/1.0");
        }
        unsigned int v60 = xmlRelaxNGNewDefine(a1, a2);
        int v10 = v60;
        if (!v60)
        {
          xmlFree(v59);
          xmlFree(v58);
          return (uint64_t *)v10;
        }
        *(_DWORD *)unsigned int v60 = 5;
        *((void *)v60 + 2) = v58;
        *((void *)v60 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = v59;
        uint64_t v61 = xmlHashLookup((xmlHashTablePtr)xmlRelaxNGRegisteredTypes, v59);
        if (!v61)
        {
          xmlRngPErr(a1, a2, 1116, "Use of unregistered type library '%s'\n", v59, 0);
          *((void *)v10 + 5) = 0;
          goto LABEL_160;
        }
        *((void *)v10 + 5) = v61;
        unsigned int v62 = (unsigned int (*)(void, void))v61[2];
        if (v62)
        {
          if (v62(v61[1], *((void *)v10 + 2)) == 1)
          {
            if (xmlStrEqual(v59, (const xmlChar *)"http://www.w3.org/2001/XMLSchema-datatypes")
              && (xmlStrEqual(*((const xmlChar **)v10 + 2), (const xmlChar *)"IDREF")
               || xmlStrEqual(*((const xmlChar **)v10 + 2), (const xmlChar *)"IDREFS")))
            {
              *(_DWORD *)(a1 + 224) = 1;
            }
LABEL_160:
            int v87 = *(const xmlNode **)(a2 + 24);
            if (v87)
            {
              uint64_t v88 = 0;
              while (xmlStrEqual(v87->name, (const xmlChar *)"param"))
              {
                if (xmlStrEqual(v59, (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                {
                  xmlRngPErr(a1, a2, 1058, "Type library '%s' does not allow type parameters\n", v59, 0);
                  while (1)
                  {
                    int v87 = v87->next;
                    if (!v87) {
                      return (uint64_t *)v10;
                    }
                    if (!xmlStrEqual(v87->name, (const xmlChar *)"param")) {
                      goto LABEL_175;
                    }
                  }
                }
                long long v89 = xmlRelaxNGNewDefine(a1, a2);
                if (v89)
                {
                  int v90 = v89;
                  *(_DWORD *)long long v89 = 6;
                  uint64_t v91 = xmlGetProp(v87, (const xmlChar *)"name");
                  *((void *)v90 + 2) = v91;
                  if (!v91) {
                    xmlRngPErr(a1, a2, 1059, "param has no name\n", 0, 0);
                  }
                  *((void *)v90 + 4) = xmlNodeGetContent(v87);
                  int v92 = v88 + 4;
                  if (!v88) {
                    int v92 = (void *)v10 + 9;
                  }
                  *int v92 = v90;
                  uint64_t v88 = v90;
                }
                int v87 = v87->next;
LABEL_175:
                if (!v87) {
                  return (uint64_t *)v10;
                }
              }
              if (!xmlStrEqual(v87->name, (const xmlChar *)"except")) {
                goto LABEL_221;
              }
              int v95 = xmlRelaxNGNewDefine(a1, a2);
              if (v95)
              {
                *(_DWORD *)int v95 = 2;
                xmlNodePtr children = v87->children;
                *((void *)v10 + 6) = v95;
                if (children)
                {
                  uint64_t v97 = 0;
                  uint64_t v98 = (uint64_t *)(v95 + 3);
                  do
                  {
                    uint64_t v99 = xmlRelaxNGParsePattern(a1, children);
                    if (v99)
                    {
                      unsigned int v100 = (uint64_t *)(v97 + 64);
                      if (!v97) {
                        unsigned int v100 = v98;
                      }
                      uint64_t *v100 = v99;
                      uint64_t v97 = v99;
                    }
                    xmlNodePtr children = children->next;
                  }
                  while (children);
                }
                else
                {
                  xmlRngPErr(a1, (uint64_t)v87, 1030, "except has no content\n", 0, 0);
                }
                int v87 = v87->next;
                if (v87)
                {
LABEL_221:
                  name = v87->name;
                  uint64_t v19 = "Element data has unexpected content %s\n";
                  uint64_t v20 = a1;
                  uint64_t v21 = (uint64_t)v87;
                  int v22 = 1009;
                  goto LABEL_34;
                }
              }
            }
            return (uint64_t *)v10;
          }
          uint64_t v85 = (const xmlChar *)*((void *)v10 + 2);
          int v81 = "Error type '%s' is not exported by type library '%s'\n";
          uint64_t v82 = a1;
          uint64_t v83 = a2;
          int v84 = 1111;
          int v86 = v59;
        }
        else
        {
          int v81 = "Internal error with type library '%s': no 'have'\n";
          uint64_t v82 = a1;
          uint64_t v83 = a2;
          int v84 = 1026;
          uint64_t v85 = v59;
          int v86 = 0;
        }
        xmlRngPErr(v82, v83, v84, v81, v85, v86);
        goto LABEL_160;
      }
      long long v74 = "data has no type\n";
      uint64_t v75 = a1;
      uint64_t v76 = a2;
      int v77 = 1110;
LABEL_145:
      uint64_t v78 = 0;
LABEL_264:
      xmlRngPErr(v75, v76, v77, v74, v78, 0);
      return 0;
    }
    uint64_t v56 = *(void *)(a2 + 72);
  }
  if (!v56 || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_263;
  }
  int v65 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"value");
  uint64_t v66 = *(void *)(a2 + 72);
  if (v65)
  {
    if (xmlStrEqual(*(const xmlChar **)(v66 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      uint64_t v67 = xmlRelaxNGNewDefine(a1, a2);
      int v10 = v67;
      if (!v67) {
        return (uint64_t *)v10;
      }
      *(_DWORD *)uint64_t v67 = 7;
      int v68 = xmlGetProp((const xmlNode *)a2, (const xmlChar *)"type");
      uint64_t v69 = v68;
      if (v68)
      {
        xmlRelaxNGNormExtSpace(v68);
        if (xmlValidateNCName(v69, 0)) {
          xmlRngPErr(a1, a2, 1112, "value type '%s' is not an NCName\n", v69, 0);
        }
        xmlDocPtr v70 = xmlRelaxNGGetDataTypeLibrary(a2);
        if (!v70) {
          xmlDocPtr v70 = xmlStrdup((const xmlChar *)"http://relaxng.org/ns/structure/1.0");
        }
        *((void *)v10 + 2) = v69;
        *((void *)v10 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = v70;
        xmlNodePtr v71 = (unsigned __int8 *)xmlHashLookup((xmlHashTablePtr)xmlRelaxNGRegisteredTypes, v70);
        uint64_t v69 = v71;
        if (!v71)
        {
          xmlRngPErr(a1, a2, 1116, "Use of unregistered type library '%s'\n", v70, 0);
          int v73 = 0;
          *((void *)v10 + 5) = 0;
          goto LABEL_198;
        }
        *((void *)v10 + 5) = v71;
        char v72 = (uint64_t (*)(void, void))*((void *)v71 + 2);
        if (v72)
        {
          int v73 = v72(*((void *)v71 + 1), *((void *)v10 + 2));
          if (v73 != 1) {
            xmlRngPErr(a1, a2, 1111, "Error type '%s' is not exported by type library '%s'\n", *((const xmlChar **)v10 + 2), v70);
          }
LABEL_198:
          uint64_t v101 = *(void *)(a2 + 24);
          if (!v101)
          {
            *((void *)v10 + 4) = xmlStrdup((const xmlChar *)"");
            return (uint64_t *)v10;
          }
          if ((*(_DWORD *)(v101 + 8) - 3) > 1 || *(void *)(v101 + 48))
          {
            uint64_t v19 = "Expecting a single text value for <value>content\n";
            uint64_t v20 = a1;
            uint64_t v21 = a2;
            int v22 = 1108;
          }
          else
          {
            Content = xmlNodeGetContent((const xmlNode *)a2);
            *((void *)v10 + 4) = Content;
            if (Content)
            {
              if (!v69) {
                return (uint64_t *)v10;
              }
              if (v73 != 1) {
                return (uint64_t *)v10;
              }
              int v103 = (unsigned int (*)(void, void, xmlChar *, uint64_t *, uint64_t))*((void *)v69 + 3);
              if (!v103) {
                return (uint64_t *)v10;
              }
              uint64_t v128 = 0;
              if (v103(*((void *)v69 + 1), *((void *)v10 + 2), Content, &v128, a2) == 1)
              {
                if (v128) {
                  *((void *)v10 + 9) = v128;
                }
                return (uint64_t *)v10;
              }
              name = (const xmlChar *)*((void *)v10 + 4);
              xmlHashTablePtr v24 = (xmlChar *)*((void *)v10 + 2);
              uint64_t v19 = "Value '%s' is not acceptable for type '%s'\n";
              uint64_t v20 = a1;
              uint64_t v21 = a2;
              int v22 = 1051;
              goto LABEL_35;
            }
            uint64_t v19 = "Element <value> has no content\n";
            uint64_t v20 = a1;
            uint64_t v21 = a2;
            int v22 = 1120;
          }
          goto LABEL_33;
        }
        xmlRngPErr(a1, a2, 1026, "Internal error with type library '%s': no 'have'\n", v70, 0);
      }
      int v73 = 0;
      goto LABEL_198;
    }
    uint64_t v66 = *(void *)(a2 + 72);
  }
  if (!v66 || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_263;
  }
  int v79 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"list");
  uint64_t v80 = *(void *)(a2 + 72);
  if (v79)
  {
    if (xmlStrEqual(*(const xmlChar **)(v80 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      int v10 = xmlRelaxNGNewDefine(a1, a2);
      if (!v10) {
        return (uint64_t *)v10;
      }
      int v43 = 8;
      goto LABEL_80;
    }
    uint64_t v80 = *(void *)(a2 + 72);
  }
  if (!v80 || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_263;
  }
  int v93 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"interleave");
  uint64_t v94 = *(void *)(a2 + 72);
  if (v93)
  {
    if (xmlStrEqual(*(const xmlChar **)(v94 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      return xmlRelaxNGParseInterleave(a1, a2);
    }
    uint64_t v94 = *(void *)(a2 + 72);
  }
  if (!v94 || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_263;
  }
  int v104 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"externalRef");
  uint64_t v105 = *(void *)(a2 + 72);
  if (!v104)
  {
LABEL_224:
    if (v105 && *(_DWORD *)(a2 + 8) == 1)
    {
      int v106 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"notAllowed");
      uint64_t v107 = *(void *)(a2 + 72);
      if (v106)
      {
        if (xmlStrEqual(*(const xmlChar **)(v107 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
          int v108 = xmlRelaxNGNewDefine(a1, a2);
          int v10 = v108;
          if (!v108) {
            return (uint64_t *)v10;
          }
          *(_DWORD *)int v108 = 1;
          if (!*(void *)(a2 + 24)) {
            return (uint64_t *)v10;
          }
          uint64_t v19 = "xmlRelaxNGParse: notAllowed element is not empty\n";
          uint64_t v20 = a1;
          uint64_t v21 = a2;
          int v22 = 1055;
LABEL_33:
          name = 0;
LABEL_34:
          xmlHashTablePtr v24 = 0;
LABEL_35:
          xmlRngPErr(v20, v21, v22, v19, name, v24);
          return (uint64_t *)v10;
        }
        uint64_t v107 = *(void *)(a2 + 72);
      }
      if (v107 && *(_DWORD *)(a2 + 8) == 1)
      {
        int v109 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"grammar");
        uint64_t v110 = *(void *)(a2 + 72);
        if (v109)
        {
          if (xmlStrEqual(*(const xmlChar **)(v110 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
          {
            uint64_t v111 = *(void *)(a1 + 48);
            long long v127 = *(_OWORD *)(a1 + 48);
            *(void *)(a1 + 56) = v127;
            uint64_t v112 = xmlRelaxNGParseGrammar(a1, *(void *)(a2 + 24));
            if (v111) {
              *(_OWORD *)(a1 + 48) = v127;
            }
            if (v112) {
              return *(uint64_t **)(v112 + 24);
            }
            return 0;
          }
          uint64_t v110 = *(void *)(a2 + 72);
        }
        if (v110 && *(_DWORD *)(a2 + 8) == 1)
        {
          int v113 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"parentRef");
          uint64_t v114 = *(void *)(a2 + 72);
          if (v113)
          {
            if (xmlStrEqual(*(const xmlChar **)(v114 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
            {
              if (!*(void *)(a1 + 56))
              {
                long long v74 = "Use of parentRef without a parent grammar\n";
                uint64_t v75 = a1;
                uint64_t v76 = a2;
                int v77 = 1063;
                goto LABEL_145;
              }
              uint64_t v115 = xmlRelaxNGNewDefine(a1, a2);
              int v10 = v115;
              if (!v115) {
                return (uint64_t *)v10;
              }
              *(_DWORD *)uint64_t v115 = 13;
              uint64_t v116 = xmlGetProp((const xmlNode *)a2, (const xmlChar *)"name");
              *((void *)v10 + 2) = v116;
              if (v116)
              {
                xmlRelaxNGNormExtSpace(v116);
                if (!xmlValidateNCName(*((const xmlChar **)v10 + 2), 0))
                {
LABEL_270:
                  if (*(void *)(a2 + 24)) {
                    xmlRngPErr(a1, a2, 1064, "parentRef is not empty\n", 0, 0);
                  }
                  unsigned int v125 = *(xmlHashTable **)(*(void *)(a1 + 56) + 56);
                  if (v125 || (unsigned int v125 = xmlHashCreate(10), (*(void *)(*(void *)(a1 + 56) + 56) = v125) != 0))
                  {
                    uint64_t v126 = (const xmlChar *)*((void *)v10 + 2);
                    if (!v126 || (xmlHashAddEntry(v125, v126, v10) & 0x80000000) == 0) {
                      return (uint64_t *)v10;
                    }
                    unsigned int v64 = xmlHashLookup(*(xmlHashTablePtr *)(*(void *)(a1 + 56) + 56), *((const xmlChar **)v10 + 2));
                    if (v64) {
                      goto LABEL_125;
                    }
                    uint64_t v78 = (const xmlChar *)*((void *)v10 + 2);
                    long long v74 = "Internal error parentRef definitions '%s'\n";
                    uint64_t v75 = a1;
                    uint64_t v76 = a2;
                    int v77 = 1060;
                    goto LABEL_264;
                  }
                  long long v74 = "Could not create references hash\n";
                  uint64_t v75 = a1;
                  uint64_t v76 = a2;
                  int v77 = 1060;
                  goto LABEL_145;
                }
                xmlNodePtr v117 = (const xmlChar *)*((void *)v10 + 2);
                xmlGenericErrorFunc v118 = "parentRef name '%s' is not an NCName\n";
                uint64_t v119 = a1;
                uint64_t v120 = a2;
                int v121 = 1061;
              }
              else
              {
                xmlGenericErrorFunc v118 = "parentRef has no name\n";
                uint64_t v119 = a1;
                uint64_t v120 = a2;
                int v121 = 1062;
                xmlNodePtr v117 = 0;
              }
              xmlRngPErr(v119, v120, v121, v118, v117, 0);
              goto LABEL_270;
            }
            uint64_t v114 = *(void *)(a2 + 72);
          }
          if (v114
            && *(_DWORD *)(a2 + 8) == 1
            && xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"mixed")
            && xmlStrEqual(*(const xmlChar **)(*(void *)(a2 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
          {
            if (*(void *)(a2 + 24))
            {
              xmlGenericErrorFunc v122 = xmlRelaxNGParseInterleave(a1, a2);
              int v10 = v122;
              if (!v122) {
                return (uint64_t *)v10;
              }
              uint64_t v123 = v122[6];
              if (v123)
              {
                if (*(void *)(v123 + 64))
                {
                  int v124 = xmlRelaxNGNewDefine(a1, a2);
                  if (v124)
                  {
                    *(_DWORD *)int v124 = 18;
                    *((void *)v124 + 6) = *((void *)v10 + 6);
                    *((void *)v10 + 6) = v124;
                  }
                }
              }
              uint64_t v36 = xmlRelaxNGNewDefine(a1, a2);
              if (!v36) {
                return (uint64_t *)v10;
              }
              *(_DWORD *)uint64_t v36 = 3;
              *((void *)v36 + 8) = *((void *)v10 + 6);
              goto LABEL_56;
            }
            long long v74 = "Mixed is empty\n";
            uint64_t v75 = a1;
            uint64_t v76 = a2;
            int v77 = 1023;
            goto LABEL_145;
          }
        }
      }
    }
LABEL_263:
    uint64_t v78 = *(const xmlChar **)(a2 + 16);
    long long v74 = "Unexpected node %s is not a pattern\n";
    uint64_t v75 = a1;
    uint64_t v76 = a2;
    int v77 = 1115;
    goto LABEL_264;
  }
  if (!xmlStrEqual(*(const xmlChar **)(v105 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
  {
    uint64_t v105 = *(void *)(a2 + 72);
    goto LABEL_224;
  }

  return (uint64_t *)xmlRelaxNGProcessExternalRef(a1, a2);
}

_OWORD *xmlRelaxNGParseNameClass(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(void *)(a2 + 72)) {
    goto LABEL_83;
  }
  uint64_t v6 = (_OWORD *)a3;
  if (*(_DWORD *)(a2 + 8) == 1)
  {
    int v7 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"name");
    uint64_t v8 = *(void *)(a2 + 72);
    if (v7)
    {
      if (xmlStrEqual(*(const xmlChar **)(v8 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
      {
LABEL_5:
        uint64_t v6 = (_OWORD *)a3;
        if (*(_DWORD *)a3 != 4)
        {
          uint64_t v6 = (_OWORD *)a3;
          if (*(_DWORD *)a3 != 9)
          {
            uint64_t v9 = xmlRelaxNGNewDefine(a1, a2);
            uint64_t v6 = v9;
            if (!v9) {
              return v6;
            }
            *((void *)v9 + 7) = a3;
            if (*(_DWORD *)(a1 + 64)) {
              int v10 = 9;
            }
            else {
              int v10 = 4;
            }
            *(_DWORD *)uint64_t v9 = v10;
          }
        }
        goto LABEL_22;
      }
      uint64_t v8 = *(void *)(a2 + 72);
    }
    if (!v8) {
      goto LABEL_83;
    }
    uint64_t v6 = (_OWORD *)a3;
    if (*(_DWORD *)(a2 + 8) == 1)
    {
      int v11 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"anyName");
      uint64_t v12 = *(void *)(a2 + 72);
      if (v11)
      {
        if (xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0")) {
          goto LABEL_5;
        }
        uint64_t v12 = *(void *)(a2 + 72);
      }
      if (!v12) {
        goto LABEL_83;
      }
      uint64_t v6 = (_OWORD *)a3;
      if (*(_DWORD *)(a2 + 8) == 1)
      {
        uint64_t v6 = (_OWORD *)a3;
        if (xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"nsName"))
        {
          uint64_t v6 = (_OWORD *)a3;
          if (xmlStrEqual(*(const xmlChar **)(*(void *)(a2 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
          {
            goto LABEL_5;
          }
        }
      }
    }
  }
LABEL_22:
  if (!*(void *)(a2 + 72) || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_83;
  }
  int v13 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"name");
  uint64_t v14 = *(void *)(a2 + 72);
  if (!v13) {
    goto LABEL_30;
  }
  if (!xmlStrEqual(*(const xmlChar **)(v14 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
  {
    uint64_t v14 = *(void *)(a2 + 72);
LABEL_30:
    if (v14 && *(_DWORD *)(a2 + 8) == 1)
    {
      int v22 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"anyName");
      uint64_t v23 = *(void *)(a2 + 72);
      if (v22)
      {
        if (xmlStrEqual(*(const xmlChar **)(v23 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
          *((void *)v6 + 2) = 0;
          *((void *)v6 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0;
LABEL_35:
          uint64_t v24 = *(void *)(a2 + 24);
          if (v24) {
            *((void *)v6 + 10) = xmlRelaxNGParseExceptNameClass(a1, v24, *(_DWORD *)a3 == 9);
          }
          goto LABEL_49;
        }
        uint64_t v23 = *(void *)(a2 + 72);
      }
      if (v23 && *(_DWORD *)(a2 + 8) == 1)
      {
        int v34 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"nsName");
        uint64_t v35 = *(void *)(a2 + 72);
        if (v34)
        {
          if (xmlStrEqual(*(const xmlChar **)(v35 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
          {
            *((void *)v6 + 2) = 0;
            Prop = xmlGetProp((const xmlNode *)a2, (const xmlChar *)"ns");
            *((void *)v6 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = Prop;
            if (!Prop) {
              xmlRngPErr(a1, a2, 1057, "nsName has no ns attribute\n", 0, 0);
            }
            if (*(unsigned char *)(a1 + 64))
            {
              int v37 = (const xmlChar *)*((void *)v6 + 3);
              if (v37)
              {
                if (xmlStrEqual(v37, (const xmlChar *)"http://www.w3.org/2000/xmlns")) {
                  xmlRngPErr(a1, a2, 1122, "Attribute with namespace '%s' is not allowed\n", *((const xmlChar **)v6 + 3), 0);
                }
              }
            }
            goto LABEL_35;
          }
          uint64_t v35 = *(void *)(a2 + 72);
        }
        if (v35
          && *(_DWORD *)(a2 + 8) == 1
          && xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"choice")
          && xmlStrEqual(*(const xmlChar **)(*(void *)(a2 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
          uint64_t v6 = (_OWORD *)a3;
          if (*(_DWORD *)a3 != 17)
          {
            uint64_t v38 = xmlRelaxNGNewDefine(a1, a2);
            uint64_t v6 = v38;
            if (!v38) {
              return v6;
            }
            *((void *)v38 + 7) = a3;
            *(_DWORD *)uint64_t v38 = 17;
          }
          uint64_t v39 = *(void *)(a2 + 24);
          if (!v39)
          {
            int v27 = "Element choice is empty\n";
            uint64_t v28 = a1;
            uint64_t v29 = a2;
            int v30 = 1007;
            int v31 = 0;
            goto LABEL_48;
          }
          uint64_t v40 = 0;
          while (1)
          {
            uint64_t v41 = xmlRelaxNGParseNameClass(a1, v39, v6);
            if (!v41) {
              break;
            }
            if (v40)
            {
              if ((_OWORD *)v41 == v6) {
                break;
              }
              *(void *)(v40 + 64) = v41;
            }
LABEL_81:
            uint64_t v39 = *(void *)(v39 + 48);
            uint64_t v40 = v41;
            if (!v39) {
              goto LABEL_49;
            }
          }
          uint64_t v41 = v40;
          goto LABEL_81;
        }
      }
    }
LABEL_83:
    xmlRngPErr(a1, a2, 1006, "expecting name, anyName, nsName or choice : got %s\n", *(const xmlChar **)(a2 + 16), 0);
    return 0;
  }
  Content = xmlNodeGetContent((const xmlNode *)a2);
  xmlRelaxNGNormExtSpace(Content);
  if (xmlValidateNCName(Content, 0))
  {
    uint64_t v16 = *(void *)(a2 + 40);
    if (v16)
    {
      uint64_t v17 = *(const xmlChar **)(v16 + 16);
      uint64_t v18 = "Element %s name '%s' is not an NCName\n";
      uint64_t v19 = a1;
      uint64_t v20 = a2;
      uint64_t v21 = Content;
    }
    else
    {
      uint64_t v18 = "name '%s' is not an NCName\n";
      uint64_t v19 = a1;
      uint64_t v20 = a2;
      uint64_t v17 = Content;
      uint64_t v21 = 0;
    }
    xmlRngPErr(v19, v20, 1019, v18, v17, v21);
  }
  *((void *)v6 + 2) = Content;
  int v25 = xmlGetProp((const xmlNode *)a2, (const xmlChar *)"ns");
  uint64_t v26 = v25;
  *((void *)v6 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = v25;
  if ((*(unsigned char *)(a1 + 64) & 1) != 0 && v25 && xmlStrEqual(v25, (const xmlChar *)"http://www.w3.org/2000/xmlns")) {
    xmlRngPErr(a1, a2, 1122, "Attribute with namespace '%s' is not allowed\n", v26, 0);
  }
  if ((*(unsigned char *)(a1 + 64) & 1) == 0
    || !v26
    || *v26
    || !xmlStrEqual(*((const xmlChar **)v6 + 2), (const xmlChar *)"xmlns"))
  {
    goto LABEL_49;
  }
  int v27 = "Attribute with QName 'xmlns' is not allowed\n";
  uint64_t v28 = a1;
  uint64_t v29 = a2;
  int v30 = 1121;
  int v31 = v26;
LABEL_48:
  xmlRngPErr(v28, v29, v30, v27, v31, 0);
LABEL_49:
  if (v6 == (_OWORD *)a3) {
    return (_OWORD *)a3;
  }
  uint64_t v32 = *(void *)(a3 + 80);
  if (v32)
  {
    do
    {
      uint64_t v33 = v32;
      uint64_t v32 = *(void *)(v32 + 64);
    }
    while (v32);
    *(void *)(v33 + 64) = v6;
  }
  else
  {
    *(void *)(a3 + 80) = v6;
  }
  return v6;
}

_OWORD *xmlRelaxNGParseExceptNameClass(uint64_t a1, uint64_t a2, int a3)
{
  if (!*(void *)(a2 + 72)
    || *(_DWORD *)(a2 + 8) != 1
    || !xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"except")
    || !xmlStrEqual(*(const xmlChar **)(*(void *)(a2 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
  {
    uint64_t v14 = "Expecting an except node\n";
    uint64_t v15 = a1;
    uint64_t v16 = a2;
    int v17 = 1028;
LABEL_21:
    xmlRngPErr(v15, v16, v17, v14, 0, 0);
    return 0;
  }
  if (*(void *)(a2 + 48)) {
    xmlRngPErr(a1, a2, 1029, "exceptNameClass allows only a single except node\n", 0, 0);
  }
  if (!*(void *)(a2 + 24))
  {
    uint64_t v14 = "except has no content\n";
    uint64_t v15 = a1;
    uint64_t v16 = a2;
    int v17 = 1027;
    goto LABEL_21;
  }
  uint64_t v6 = xmlRelaxNGNewDefine(a1, a2);
  int v7 = v6;
  if (v6)
  {
    *(_DWORD *)uint64_t v6 = 2;
    uint64_t v8 = *(void *)(a2 + 24);
    if (v8)
    {
      uint64_t v9 = 0;
      if (a3) {
        int v10 = 9;
      }
      else {
        int v10 = 4;
      }
      do
      {
        int v11 = xmlRelaxNGNewDefine(a1, v8);
        if (!v11) {
          break;
        }
        uint64_t v12 = v11;
        *(_DWORD *)int v11 = v10;
        if (xmlRelaxNGParseNameClass(a1, v8, v11))
        {
          int v13 = v9 + 4;
          if (!v9) {
            int v13 = v7 + 3;
          }
          *int v13 = v12;
          uint64_t v9 = v12;
        }
        uint64_t v8 = *(void *)(v8 + 48);
      }
      while (v8);
    }
  }
  return v7;
}

uint64_t *xmlRelaxNGParseInterleave(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  int v4 = (uint64_t *)xmlRelaxNGNewDefine(a1, a2);
  uint64_t v5 = v4;
  if (v4)
  {
    *(_DWORD *)int v4 = 19;
    if (*(void *)(a1 + 104) || (xmlHashTablePtr v6 = xmlHashCreate(10), (*(void *)(a1 + 104) = v6) != 0))
    {
      *(_OWORD *)__str = 0u;
      long long v14 = 0u;
      int v7 = *(_DWORD *)(a1 + 96);
      *(_DWORD *)(a1 + 96) = v7 + 1;
      snprintf(__str, 0x20uLL, "interleave%d", v7);
      if (xmlHashAddEntry(*(xmlHashTablePtr *)(a1 + 104), (const xmlChar *)__str, v5) < 0) {
        xmlRngPErr(a1, a2, 1045, "Failed to add %s to hash table\n", (const xmlChar *)__str, 0);
      }
    }
    else
    {
      xmlRngPErrMemory(a1, (const xmlChar *)"create interleaves\n");
    }
    uint64_t v8 = *(void *)(a2 + 24);
    if (v8)
    {
      uint64_t v9 = 0;
      while (1)
      {
        if (*(void *)(v8 + 72)
          && *(_DWORD *)(v8 + 8) == 1
          && xmlStrEqual(*(const xmlChar **)(v8 + 16), (const xmlChar *)"element")
          && xmlStrEqual(*(const xmlChar **)(*(void *)(v8 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
          uint64_t v10 = xmlRelaxNGParseElement(a1, v8);
          if (v10) {
            goto LABEL_16;
          }
        }
        else
        {
          uint64_t v10 = xmlRelaxNGParsePattern(a1, v8);
          if (v10)
          {
LABEL_16:
            *(void *)(v10 + 56) = v5;
            int v11 = (uint64_t *)(v9 + 64);
            if (!v9) {
              int v11 = v5 + 6;
            }
            uint64_t *v11 = v10;
            uint64_t v9 = v10;
          }
        }
        uint64_t v8 = *(void *)(v8 + 48);
        if (!v8) {
          return v5;
        }
      }
    }
    xmlRngPErr(a1, a2, 1048, "Element interleave is empty\n", 0, 0);
  }
  return v5;
}

_OWORD *xmlRelaxNGProcessExternalRef(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 104);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = a2;
  uint64_t v5 = xmlRelaxNGNewDefine(a1, a2);
  xmlHashTablePtr v6 = v5;
  if (v5)
  {
    *(_DWORD *)uint64_t v5 = 12;
    if (*(void *)(v2 + 24))
    {
LABEL_4:
      *((void *)v6 + 6) = *(void *)(v2 + 24);
      return v6;
    }
    xmlNodePtr RootElement = xmlDocGetRootElement(*(const xmlDoc **)(v2 + 16));
    if (RootElement)
    {
      uint64_t v8 = (xmlNode *)RootElement;
      Prop = xmlGetProp(RootElement, (const xmlChar *)"ns");
      BOOL v10 = Prop == 0;
      if (!Prop)
      {
        while (1)
        {
          if (*(_DWORD *)(v3 + 8) != 1)
          {
LABEL_14:
            BOOL v10 = 0;
            goto LABEL_15;
          }
          uint64_t v12 = xmlGetProp((const xmlNode *)v3, (const xmlChar *)"ns");
          if (v12) {
            break;
          }
          uint64_t v3 = *(void *)(v3 + 40);
          if (!v3) {
            goto LABEL_14;
          }
        }
        Prop = v12;
        xmlSetProp(v8, (const xmlChar *)"ns", v12);
      }
      xmlFree(Prop);
LABEL_15:
      int v13 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(a1 + 64) = v13 | 0x80;
      uint64_t v14 = xmlRelaxNGParseDocument(a1, v8);
      *(void *)(v2 + 32) = v14;
      *(_DWORD *)(a1 + 64) = v13;
      if (v14)
      {
        uint64_t v15 = *(void *)(v14 + 8);
        if (v15)
        {
          *(void *)(v2 + 24) = *(void *)(v15 + 24);
          uint64_t v16 = *(xmlHashTable **)(v15 + 56);
          if (v16)
          {
            uint64_t v17 = *(void *)(a1 + 48);
            if (v17)
            {
              if (!*(void *)(v17 + 56))
              {
                xmlHashTablePtr v18 = xmlHashCreate(10);
                *(void *)(*(void *)(a1 + 48) + 56) = v18;
                if (!v18)
                {
                  xmlRngPErr(a1, 0, 1098, "Could not create references hash\n", 0, 0);
                  if (!v10) {
                    goto LABEL_4;
                  }
                  goto LABEL_24;
                }
                uint64_t v16 = *(xmlHashTable **)(v15 + 56);
              }
              xmlHashScan(v16, (xmlHashScanner)xmlRelaxNGParseImportRef, (void *)a1);
            }
          }
        }
      }
      if (!v10) {
        goto LABEL_4;
      }
LABEL_24:
      xmlUnsetProp(v8, (const xmlChar *)"ns");
      goto LABEL_4;
    }
    xmlRngPErr(a1, v3, 1031, "xmlRelaxNGParse: %s is empty\n", *(const xmlChar **)(a1 + 128), 0);
    return 0;
  }
  return v6;
}

xmlChar *xmlRelaxNGGetDataTypeLibrary(uint64_t a1)
{
  uint64_t v1 = a1;
  if (!*(void *)(a1 + 72) || *(_DWORD *)(a1 + 8) != 1) {
    goto LABEL_11;
  }
  int v2 = xmlStrEqual(*(const xmlChar **)(a1 + 16), (const xmlChar *)"data");
  uint64_t v3 = *(void *)(v1 + 72);
  if (v2)
  {
    if (xmlStrEqual(*(const xmlChar **)(v3 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0")) {
      goto LABEL_10;
    }
    uint64_t v3 = *(void *)(v1 + 72);
  }
  if (!v3
    || *(_DWORD *)(v1 + 8) != 1
    || !xmlStrEqual(*(const xmlChar **)(v1 + 16), (const xmlChar *)"value")
    || !xmlStrEqual(*(const xmlChar **)(*(void *)(v1 + 72) + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
  {
    goto LABEL_11;
  }
LABEL_10:
  while (1)
  {
    Prop = xmlGetProp((const xmlNode *)v1, (const xmlChar *)"datatypeLibrary");
    if (Prop) {
      break;
    }
LABEL_11:
    uint64_t v1 = *(void *)(v1 + 40);
    if (!v1 || *(_DWORD *)(v1 + 8) != 1) {
      return 0;
    }
  }
  uint64_t v5 = Prop;
  if (*Prop)
  {
    xmlHashTablePtr v6 = xmlURIEscapeStr(Prop, (const xmlChar *)":/#?");
    if (!v6) {
      return v5;
    }
  }
  else
  {
    xmlHashTablePtr v6 = 0;
  }
  xmlFree(v5);
  return v6;
}

uint64_t xmlRelaxNGParseImportRef(void *userdata, uint64_t a2, xmlChar *name)
{
  *((_WORD *)userdata + 49) |= 0x100u;
  uint64_t result = xmlHashAddEntry(*(xmlHashTablePtr *)(*(void *)(a2 + 48) + 56), name, userdata);
  if ((result & 0x80000000) != 0)
  {
    uint64_t result = (uint64_t)xmlHashLookup(*(xmlHashTablePtr *)(*(void *)(a2 + 48) + 56), *((const xmlChar **)userdata + 2));
    if (result)
    {
      *((void *)userdata + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = *(void *)(result + 88);
      *(void *)(result + 88) = userdata;
    }
    else
    {
      xmlHashTablePtr v6 = (const xmlChar *)*((void *)userdata + 2);
      if (v6) {
        int v7 = "Error refs definitions '%s'\n";
      }
      else {
        int v7 = "Error refs definitions\n";
      }
      return (uint64_t)xmlRngPErr(a2, 0, 1098, v7, v6, 0);
    }
  }
  return result;
}

uint64_t xmlRelaxNGTryUnlink(uint64_t a1, void *a2, uint64_t a3)
{
  if (a3)
  {
    *(void *)(a3 + 64) = *(void *)(a1 + 64);
  }
  else if (a2)
  {
    if (a2[6] == a1)
    {
      a3 = 0;
      a2[6] = *(void *)(a1 + 64);
    }
    else if (a2[9] == a1)
    {
      a3 = 0;
      a2[9] = *(void *)(a1 + 64);
    }
    else
    {
      a3 = 0;
      if (a2[10] == a1) {
        a2[10] = *(void *)(a1 + 64);
      }
    }
  }
  else
  {
    *(_DWORD *)a1 = -1;
    return a1;
  }
  return a3;
}

uint64_t xmlRelaxNGGenerateAttributes(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 68)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 1;
  if (a2)
  {
    for (uint64_t i = a2; ; uint64_t i = v5)
    {
      unsigned int v4 = *(_DWORD *)i;
      if ((*(_DWORD *)i - 10) >= 0xA)
      {
        BOOL v7 = v4 > 8;
        int v8 = (1 << v4) & 0x1F9;
        if (!v7 && v8 != 0) {
          return 0;
        }
      }
      else
      {
        uint64_t v5 = *(void *)(i + 48);
        if (v5)
        {
          uint64_t v6 = *(void *)(i + 48);
          do
          {
            *(void *)(v6 + 56) = i;
            uint64_t v6 = *(void *)(v6 + 64);
          }
          while (v6);
          continue;
        }
      }
      if (i == a2) {
        return 1;
      }
      while (1)
      {
        uint64_t v5 = *(void *)(i + 64);
        if (v5) {
          break;
        }
        uint64_t i = *(void *)(i + 56);
        if (i) {
          BOOL v10 = i == a2;
        }
        else {
          BOOL v10 = 1;
        }
        if (v10) {
          return 1;
        }
      }
    }
  }
  return result;
}

void xmlRelaxNGCheckGroupAttrs(uint64_t a1, uint64_t a2)
{
  BOOL v2 = *(_DWORD *)a2 == 18 || *(_DWORD *)a2 == 4;
  if (v2 && (*(_WORD *)(a2 + 98) & 0x20) == 0 && !*(_DWORD *)(a1 + 68))
  {
    uint64_t v5 = *(void *)(a2 + 72);
    if (v5)
    {
      unsigned int v6 = 0;
      do
      {
        ++v6;
        uint64_t v5 = *(void *)(v5 + 64);
      }
      while (v5);
    }
    else
    {
      unsigned int v6 = 0;
    }
    for (uint64_t i = *(void *)(a2 + 48); i; uint64_t i = *(void *)(i + 64))
      ++v6;
    int v8 = (void **)xmlMalloc(8 * v6);
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = v6;
      uint64_t v11 = *(void *)(a2 + 72);
      if (v11)
      {
        uint64_t v12 = 0;
        do
        {
          v9[v12++] = xmlRelaxNGGetElements(a1, (_DWORD *)v11, 1);
          uint64_t v11 = *(void *)(v11 + 64);
        }
        while (v11);
        uint64_t v13 = v12;
      }
      else
      {
        uint64_t v13 = 0;
      }
      uint64_t v14 = *(void *)(a2 + 48);
      if (v14)
      {
        uint64_t v15 = &v9[v13];
        do
        {
          *v15++ = xmlRelaxNGGetElements(a1, (_DWORD *)v14, 1);
          uint64_t v14 = *(void *)(v14 + 64);
        }
        while (v14);
      }
      if (v10)
      {
        for (uint64_t j = 0; j != v10; ++j)
        {
          if (v9[j]) {
            BOOL v17 = j == 0;
          }
          else {
            BOOL v17 = 1;
          }
          if (!v17)
          {
            uint64_t v18 = 0;
            do
            {
              uint64_t v19 = (void **)v9[v18];
              if (v19 && !xmlRelaxNGCompareElemDefLists((uint64_t)v9[j], v19)) {
                xmlRngPErr(a1, *(void *)(a2 + 8), 1040, "Attributes conflicts in group\n", 0, 0);
              }
              ++v18;
            }
            while (j != v18);
          }
        }
        uint64_t v20 = v9;
        do
        {
          if (*v20) {
            xmlFree(*v20);
          }
          ++v20;
          --v10;
        }
        while (v10);
      }
      xmlFree(v9);
      *(_WORD *)(a2 + 98) |= 0x20u;
    }
    else
    {
      xmlRngPErrMemory(a1, (const xmlChar *)"building group\n");
    }
  }
}

void *xmlRelaxNGGetElements(uint64_t a1, _DWORD *a2, int a3)
{
  if (*(_DWORD *)(a1 + 68)) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = a2 == 0;
  }
  if (v3) {
    return 0;
  }
  int v7 = 0;
  LODWORD(v8) = 0;
  uint64_t v9 = 0;
  uint64_t v10 = a2;
  while (1)
  {
    uint64_t v11 = v10;
    if (!a3)
    {
      unsigned int v12 = *v10;
      if (v12 - 3 < 2) {
        goto LABEL_14;
      }
      goto LABEL_23;
    }
    if (a3 != 1) {
      break;
    }
    unsigned int v12 = *v10;
    if (v12 == 9) {
      goto LABEL_14;
    }
LABEL_23:
    if (v12 - 10 <= 9 && (uint64_t v10 = (_DWORD *)v11[6]) != 0)
    {
      uint64_t v15 = v11[6];
      do
      {
        *(void *)(v15 + 56) = v11;
        uint64_t v15 = *(void *)(v15 + 64);
      }
      while (v15);
    }
    else
    {
LABEL_31:
      if (v11 == (void *)a2) {
        return v9;
      }
      while (1)
      {
        uint64_t v10 = (_DWORD *)v11[8];
        if (v10) {
          break;
        }
        uint64_t v11 = (void *)v11[7];
        if (v11) {
          BOOL v16 = v11 == (void *)a2;
        }
        else {
          BOOL v16 = 1;
        }
        if (v16) {
          return v9;
        }
      }
    }
  }
  if (a3 != 2)
  {
    unsigned int v12 = *v10;
    goto LABEL_23;
  }
  unsigned int v12 = *v10;
  if (v12 > 8 || ((1 << v12) & 0x1B8) == 0) {
    goto LABEL_23;
  }
LABEL_14:
  if (!v9)
  {
    uint64_t v9 = xmlMalloc(0x58uLL);
    if (!v9)
    {
      xmlRngPErrMemory(a1, (const xmlChar *)"getting element list\n");
      return v9;
    }
    int v7 = 10;
    goto LABEL_30;
  }
  if (v7 > (int)v8)
  {
LABEL_30:
    v9[(int)v8] = v11;
    uint64_t v8 = (int)v8 + 1;
    v9[v8] = 0;
    goto LABEL_31;
  }
  uint64_t v14 = xmlRealloc(v9, 8 * ((2 * v7) | 1));
  if (v14)
  {
    v7 *= 2;
    uint64_t v9 = v14;
    goto LABEL_30;
  }
  xmlRngPErrMemory(a1, (const xmlChar *)"getting element list\n");
  xmlFree(v9);
  return 0;
}

uint64_t xmlRelaxNGCompareElemDefLists(uint64_t a1, void **a2)
{
  uint64_t result = 1;
  if (a1)
  {
    if (a2)
    {
      if (*(void *)a1)
      {
        uint64_t v5 = *a2;
        if (*a2)
        {
          while (1)
          {
            unsigned int v6 = a2 + 1;
            if (v5) {
              break;
            }
LABEL_8:
            uint64_t v8 = *(void *)(a1 + 8);
            a1 += 8;
            if (!v8) {
              return 1;
            }
            uint64_t v5 = *a2;
          }
          while (1)
          {
            uint64_t result = xmlRelaxNGCompareNameClasses(*(void **)a1, v5);
            if (!result) {
              break;
            }
            int v7 = (void *)*v6++;
            uint64_t v5 = v7;
            if (!v7) {
              goto LABEL_8;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t xmlRelaxNGCompareNameClasses(void *a1, void *a2)
{
  uint64_t v34 = 0;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v27 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  DWORD2(v15) = 9;
  int v2 = *(_DWORD *)a1 - 2;
  memset(v14, 0, sizeof(v14));
  switch(v2)
  {
    case 0:
      if (xmlRelaxNGCompareNameClasses(a1[6], a2)) {
        return 0;
      }
      goto LABEL_17;
    case 1:
      return *(_DWORD *)a2 != 3;
    case 2:
    case 7:
      if (*(_DWORD *)a2 == 3) {
        return 1;
      }
      uint64_t v8 = "\x01";
      uint64_t v9 = (unsigned char *)a1[3];
      if (a1[2]) {
        uint64_t v8 = (const char *)a1[2];
      }
      *(void *)&long long v28 = v8;
      if (v9 && *v9)
      {
        *((void *)&v31 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = &v24;
        *(void *)&long long v25 = v9;
      }
      else
      {
        *((void *)&v31 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0;
      }
      if (!xmlRelaxNGElementMatch((uint64_t)v14, a2, (uint64_t)&v27)
        || (uint64_t result = a1[10]) != 0 && (uint64_t result = xmlRelaxNGCompareNameClasses(result, a2), result))
      {
LABEL_17:
        if (*(_DWORD *)a2 == 9 || *(_DWORD *)a2 == 4)
        {
          uint64_t v11 = (const char *)a2[2];
          uint64_t v10 = (unsigned char *)a2[3];
          if (!v11) {
            uint64_t v11 = "\x01";
          }
          *(void *)&long long v28 = v11;
          *((void *)&v31 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = &v24;
          if (v10)
          {
            if (*v10) {
              *(void *)&long long v25 = v10;
            }
            else {
              *((void *)&v31 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0;
            }
          }
          else
          {
            *(void *)&long long v25 = "\x01";
          }
          if (xmlRelaxNGElementMatch((uint64_t)v14, a1, (uint64_t)&v27))
          {
            uint64_t result = a2[10];
            if (result) {
              return xmlRelaxNGCompareNameClasses(result, a1);
            }
          }
          else
          {
            return 1;
          }
        }
        else
        {
          xmlGenericErrorFunc v12 = *__xmlGenericError();
          uint64_t v13 = *__xmlGenericErrorContext();
          v12(v13, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 3886);
          return 0;
        }
      }
      return result;
    default:
      xmlGenericErrorFunc v6 = *__xmlGenericError();
      int v7 = *__xmlGenericErrorContext();
      v6(v7, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 3855);
      return 0;
  }
}

uint64_t xmlRelaxNGElementMatch(uint64_t a1, void *a2, uint64_t a3)
{
  xmlGenericErrorFunc v6 = (const xmlChar *)a2[2];
  if (v6 && !xmlStrEqual(*(const xmlChar **)(a3 + 16), v6))
  {
    uint64_t v9 = (xmlChar *)a2[2];
    uint64_t v10 = *(xmlChar **)(a3 + 16);
    uint64_t v11 = a1;
    int v12 = 13;
    goto LABEL_23;
  }
  int v7 = (const xmlChar *)a2[3];
  if (!v7)
  {
    if (!*(void *)(a3 + 72)) {
      goto LABEL_16;
    }
    uint64_t v9 = (xmlChar *)a2[2];
    if (!v9) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  uint64_t v8 = *(void *)(a3 + 72);
  if (!*v7)
  {
    if (!v8) {
      goto LABEL_16;
    }
    uint64_t v9 = (xmlChar *)a2[2];
    if (!v9) {
      uint64_t v9 = *(xmlChar **)(a3 + 16);
    }
LABEL_15:
    uint64_t v11 = a1;
    int v12 = 19;
LABEL_22:
    uint64_t v10 = 0;
    goto LABEL_23;
  }
  if (!v8)
  {
    uint64_t v9 = *(xmlChar **)(a3 + 16);
    uint64_t v11 = a1;
    int v12 = 15;
    goto LABEL_22;
  }
  if (!xmlStrEqual(*(const xmlChar **)(v8 + 16), v7))
  {
    uint64_t v9 = *(xmlChar **)(a3 + 16);
    uint64_t v10 = (xmlChar *)a2[3];
    uint64_t v11 = a1;
    int v12 = 17;
LABEL_23:
    xmlRelaxNGAddValidError(v11, v12, v9, v10, 0);
    return 0;
  }
LABEL_16:
  uint64_t v13 = a2[10];
  if (!v13) {
    return 1;
  }
  if (*(_DWORD *)v13 == 17)
  {
    if (a1)
    {
      int v14 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)(a1 + 56) = v14 | 1;
    }
    else
    {
      int v14 = 0;
    }
    uint64_t v20 = *(void *)(v13 + 80);
    if (!v20)
    {
LABEL_41:
      if (!a1) {
        return 0;
      }
      if (*(int *)(a1 + 80) >= 1) {
        xmlRelaxNGPopErrors(a1, 0);
      }
      goto LABEL_48;
    }
    while (1)
    {
      int v21 = xmlRelaxNGElementMatch(a1, v20, a3);
      if (v21 == 1) {
        goto LABEL_33;
      }
      if (v21 < 0)
      {
LABEL_44:
        if (a1) {
          *(_DWORD *)(a1 + 56) = v14;
        }
        return 0xFFFFFFFFLL;
      }
      uint64_t v20 = *(void *)(v20 + 64);
      if (!v20) {
        goto LABEL_41;
      }
    }
  }
  if (*(_DWORD *)v13 == 2)
  {
    if (a1)
    {
      int v14 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)(a1 + 56) = v14 | 1;
    }
    else
    {
      int v14 = 0;
    }
    uint64_t v18 = *(void *)(v13 + 48);
    if (v18)
    {
      while (1)
      {
        int v19 = xmlRelaxNGElementMatch(a1, v18, a3);
        if (v19 == 1) {
          break;
        }
        if (v19 < 0) {
          goto LABEL_44;
        }
        uint64_t v18 = *(void *)(v18 + 64);
        if (!v18) {
          goto LABEL_33;
        }
      }
      if (!a1) {
        return 0;
      }
LABEL_48:
      uint64_t result = 0;
      *(_DWORD *)(a1 + 56) = v14;
      return result;
    }
LABEL_33:
    if (a1) {
      *(_DWORD *)(a1 + 56) = v14;
    }
    return 1;
  }
  xmlGenericErrorFunc v16 = *__xmlGenericError();
  long long v17 = __xmlGenericErrorContext();
  v16(*v17, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 9768);
  return 0xFFFFFFFFLL;
}

void xmlRelaxNGDumpValidError(uint64_t a1)
{
  if (*(int *)(a1 + 80) >= 1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    int v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(a1 + 88);
      if (v4 <= 4)
      {
        int v24 = v4;
        xmlGenericErrorFunc v6 = (int *)(v5 + 40 * v3);
        if (v3)
        {
          uint64_t v7 = 0;
          uint64_t v8 = v5 + 40 * v3;
          uint64_t v9 = (void *)(v8 + 8);
          uint64_t v10 = (const xmlChar **)(v8 + 24);
          uint64_t v11 = (const xmlChar **)(v8 + 32);
          while (1)
          {
            uint64_t v12 = *(void *)(a1 + 88);
            if (*v6 == *(_DWORD *)(v12 + v7)
              && *v9 == *(void *)(v12 + v7 + 8)
              && xmlStrEqual(*v10, *(const xmlChar **)(v12 + v7 + 24))
              && xmlStrEqual(*v11, *(const xmlChar **)(v12 + v7 + 32)))
            {
              break;
            }
            v7 += 40;
            if (v2 == v7) {
              goto LABEL_11;
            }
          }
          int v4 = v24;
        }
        else
        {
LABEL_11:
          xmlRelaxNGShowValidError(a1, *v6, *(void *)(v5 + 40 * v3 + 8), *(void *)(v5 + 40 * v3 + 16), *(const xmlChar **)(v5 + 40 * v3 + 24), *(xmlChar **)(v5 + 40 * v3 + 32));
          int v4 = v24 + 1;
        }
      }
      uint64_t v13 = v5 + 40 * v3;
      char v15 = *(unsigned char *)(v13 + 4);
      int v14 = (_DWORD *)(v13 + 4);
      if (v15)
      {
        uint64_t v16 = v5 + 40 * v3;
        int v19 = *(void **)(v16 + 24);
        uint64_t v18 = (void *)(v16 + 24);
        long long v17 = v19;
        if (v19) {
          xmlFree(v17);
        }
        void *v18 = 0;
        uint64_t v20 = v5 + 40 * v3;
        long long v23 = *(void **)(v20 + 32);
        long long v22 = (void *)(v20 + 32);
        int v21 = v23;
        if (v23) {
          xmlFree(v21);
        }
        void *v22 = 0;
        *int v14 = 0;
      }
      ++v3;
      v2 += 40;
    }
    while (v3 < *(int *)(a1 + 80));
  }
  *(_DWORD *)(a1 + 80) = 0;
}

void xmlRelaxNGPopErrors(uint64_t a1, int a2)
{
  int v4 = *(_DWORD *)(a1 + 80);
  if (v4 > a2)
  {
    uint64_t v5 = a2;
    uint64_t v6 = 40 * a2;
    do
    {
      uint64_t v7 = *(void *)(a1 + 88);
      uint64_t v8 = v7 + v6;
      if (*(unsigned char *)(v7 + v6 + 4))
      {
        uint64_t v9 = *(void **)(v8 + 24);
        if (v9) {
          xmlFree(v9);
        }
        *(void *)(v8 + 24) = 0;
        uint64_t v10 = v7 + v6;
        uint64_t v11 = *(void **)(v10 + 32);
        if (v11) {
          xmlFree(v11);
        }
        *(void *)(v10 + 32) = 0;
        *(_DWORD *)(v8 + 4) = 0;
        int v4 = *(_DWORD *)(a1 + 80);
      }
      ++v5;
      v6 += 40;
    }
    while (v5 < v4);
  }
  *(_DWORD *)(a1 + 80) = a2;
  if (a2 <= 0) {
    *(void *)(a1 + 72) = 0;
  }
}

void xmlRelaxNGShowValidError(uint64_t a1, int a2, uint64_t a3, uint64_t a4, const xmlChar *a5, xmlChar *a6)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(a1 + 56) & 8) == 0)
  {
    bzero(v21, 0x3E6uLL);
    char __str = 0;
    switch(a2)
    {
      case 0:
        return;
      case 1:
        uint64_t v12 = "out of memory\n";
        goto LABEL_34;
      case 2:
        snprintf(&__str, 0x3E8uLL, "failed to validate type %s\n");
        goto LABEL_39;
      case 3:
        snprintf(&__str, 0x3E8uLL, "Type %s doesn't allow value '%s'\n");
        goto LABEL_39;
      case 4:
        snprintf(&__str, 0x3E8uLL, "ID %s redefined\n");
        goto LABEL_39;
      case 5:
        snprintf(&__str, 0x3E8uLL, "failed to compare type %s\n");
        goto LABEL_39;
      case 6:
        uint64_t v12 = "Internal error: no state\n";
        goto LABEL_34;
      case 7:
        uint64_t v12 = "Internal error: no define\n";
        goto LABEL_34;
      case 8:
        snprintf(&__str, 0x3E8uLL, "Extra data in list: %s\n");
        goto LABEL_39;
      case 10:
        uint64_t v12 = "Internal: interleave block has no data\n";
        goto LABEL_34;
      case 11:
        uint64_t v12 = "Invalid sequence in interleave\n";
        goto LABEL_34;
      case 12:
        snprintf(&__str, 0x3E8uLL, "Extra element %s in interleave\n");
        goto LABEL_39;
      case 13:
        snprintf(&__str, 0x3E8uLL, "Expecting element %s, got %s\n");
        goto LABEL_39;
      case 15:
        snprintf(&__str, 0x3E8uLL, "Expecting a namespace for element %s\n");
        goto LABEL_39;
      case 17:
        snprintf(&__str, 0x3E8uLL, "Element %s has wrong namespace: expecting %s\n");
        goto LABEL_39;
      case 19:
        snprintf(&__str, 0x3E8uLL, "Expecting no namespace for element %s\n");
        goto LABEL_39;
      case 21:
        snprintf(&__str, 0x3E8uLL, "Expecting element %s to be empty\n");
        goto LABEL_39;
      case 22:
        snprintf(&__str, 0x3E8uLL, "Expecting an element %s, got nothing\n");
        goto LABEL_39;
      case 23:
        uint64_t v12 = "Expecting an element got text\n";
        goto LABEL_34;
      case 24:
        snprintf(&__str, 0x3E8uLL, "Element %s failed to validate attributes\n");
        goto LABEL_39;
      case 25:
        snprintf(&__str, 0x3E8uLL, "Element %s failed to validate content\n");
        goto LABEL_39;
      case 26:
        snprintf(&__str, 0x3E8uLL, "Element %s has extra content: %s\n");
        goto LABEL_39;
      case 27:
        snprintf(&__str, 0x3E8uLL, "Invalid attribute %s for element %s\n");
        goto LABEL_39;
      case 28:
        snprintf(&__str, 0x3E8uLL, "Datatype element %s has child elements\n");
        goto LABEL_39;
      case 29:
        snprintf(&__str, 0x3E8uLL, "Value element %s has child elements\n");
        goto LABEL_39;
      case 30:
        snprintf(&__str, 0x3E8uLL, "List element %s has child elements\n");
        goto LABEL_39;
      case 31:
        snprintf(&__str, 0x3E8uLL, "Error validating datatype %s\n");
        goto LABEL_39;
      case 32:
        snprintf(&__str, 0x3E8uLL, "Error validating value %s\n");
        goto LABEL_39;
      case 33:
        uint64_t v12 = "Error validating list\n";
        goto LABEL_34;
      case 34:
        uint64_t v12 = "No top grammar defined\n";
        goto LABEL_34;
      case 35:
        uint64_t v12 = "Extra data in the document\n";
        goto LABEL_34;
      case 36:
        snprintf(&__str, 0x3E8uLL, "Datatype element %s contains no data\n");
        goto LABEL_39;
      case 37:
        snprintf(&__str, 0x3E8uLL, "Internal error: %s\n");
        goto LABEL_39;
      case 38:
        snprintf(&__str, 0x3E8uLL, "Did not expect element %s there\n");
        goto LABEL_39;
      case 39:
        snprintf(&__str, 0x3E8uLL, "Did not expect text in element %s content\n");
LABEL_39:
        if (!__str) {
          snprintf(&__str, 0x3E8uLL, "Unknown error code %d\n", a2);
        }
        v21[998] = 0;
        int v19 = xmlCharStrdup(&__str);
        uint64_t v13 = xmlEscapeFormatString((void **)&v19);
        break;
      default:
        uint64_t v12 = "Unknown error !\n";
LABEL_34:
        uint64_t v13 = (char *)xmlCharStrdup(v12);
        break;
    }
    int v14 = v13;
    if (v13)
    {
      if (!*(_DWORD *)(a1 + 68)) {
        *(_DWORD *)(a1 + 68) = a2;
      }
      if (a4) {
        uint64_t v15 = a4;
      }
      else {
        uint64_t v15 = a3;
      }
      uint64_t v16 = *(void (__cdecl **)(void *, xmlErrorPtr))(a1 + 24);
      if (v16) {
        long long v17 = 0;
      }
      else {
        long long v17 = *(void (**)(void *, const char *, ...))(a1 + 8);
      }
      uint64_t v18 = *(void **)a1;
      ++*(_DWORD *)(a1 + 32);
      __xmlRaiseError(v16, v17, v18, 0, v15, 0x13u, a2, 2, 0, 0, a5, a6, 0, 0, 0, v14, (char)a5);
      xmlFree(v14);
    }
  }
}

uint64_t xmlRelaxNGIsNullable(int *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  __int16 v2 = *((_WORD *)a1 + 49);
  if (v2) {
    return 1;
  }
  if ((v2 & 2) != 0) {
    return 0;
  }
  int v3 = *a1;
  uint64_t result = 0xFFFFFFFFLL;
  switch(v3)
  {
    case -1:
    case 10:
    case 11:
    case 12:
    case 13:
    case 16:
      uint64_t result = xmlRelaxNGIsNullable(*((void *)a1 + 6));
      goto LABEL_6;
    case 0:
    case 3:
      goto LABEL_9;
    case 1:
    case 2:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      goto LABEL_20;
    case 17:
      uint64_t v7 = *((void *)a1 + 6);
      if (!v7) {
        goto LABEL_20;
      }
      while (1)
      {
        uint64_t result = xmlRelaxNGIsNullable(v7);
        if (result) {
          goto LABEL_6;
        }
        uint64_t v7 = *(void *)(v7 + 64);
        if (!v7) {
          goto LABEL_20;
        }
      }
    case 18:
    case 19:
    case 20:
      uint64_t v6 = *((void *)a1 + 6);
      if (!v6) {
        return 1;
      }
      break;
    default:
      return result;
  }
  while (1)
  {
    uint64_t result = xmlRelaxNGIsNullable(v6);
    if (result != 1) {
      break;
    }
    uint64_t v6 = *(void *)(v6 + 64);
    if (!v6) {
      return result;
    }
  }
LABEL_6:
  if (result)
  {
    if (result != 1) {
      return result;
    }
    __int16 v2 = *((_WORD *)a1 + 49);
LABEL_9:
    __int16 v5 = v2 | 1;
    uint64_t result = 1;
  }
  else
  {
LABEL_20:
    uint64_t result = 0;
    __int16 v5 = *((_WORD *)a1 + 49) | 2;
  }
  *((_WORD *)a1 + 49) = v5;
  return result;
}

uint64_t xmlRelaxNGIsCompilable(int *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  int v2 = *a1;
  __int16 v3 = *((_WORD *)a1 + 49);
  if (*a1 == 4)
  {
    if ((v3 & 0xC0) == 0)
    {
      uint64_t v5 = *((void *)a1 + 6);
      if (v5)
      {
        while (1)
        {
          int v6 = xmlRelaxNGIsCompilable(v5);
          if (v6 != 1) {
            break;
          }
          uint64_t v5 = *(void *)(v5 + 64);
          if (!v5)
          {
            __int16 v7 = *((_WORD *)a1 + 49) & 0x80;
            if ((*((_WORD *)a1 + 49) & 0x80) == 0) {
              __int16 v7 = 64;
            }
            goto LABEL_20;
          }
        }
        if (v6) {
          goto LABEL_4;
        }
        __int16 v7 = *((_WORD *)a1 + 49) & 0xFF3F | 0x80;
LABEL_20:
        *((_WORD *)a1 + 49) = v7;
      }
    }
LABEL_4:
    if (!*((void *)a1 + 10)) {
      return *((void *)a1 + 2) != 0;
    }
    return 0;
  }
  if ((v3 & 0x40) != 0) {
    return 1;
  }
  if ((v3 & 0x80) != 0) {
    return 0;
  }
  uint64_t result = 0xFFFFFFFFLL;
  switch(v2)
  {
    case -1:
      uint64_t result = xmlRelaxNGIsCompilable(*((void *)a1 + 6));
      goto LABEL_31;
    case 0:
    case 3:
      goto LABEL_35;
    case 1:
    case 2:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 19:
      goto LABEL_10;
    case 10:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 20:
      uint64_t v8 = *((void *)a1 + 6);
      if (!v8) {
        return result;
      }
      while (1)
      {
        uint64_t result = xmlRelaxNGIsCompilable(v8);
        if (result != 1) {
          goto LABEL_31;
        }
        uint64_t v8 = *(void *)(v8 + 64);
        if (!v8) {
          goto LABEL_34;
        }
      }
    case 11:
    case 12:
    case 13:
      if (*((__int16 *)a1 + 48) == -20) {
        return 1;
      }
      *((_WORD *)a1 + 48) = -20;
      uint64_t v9 = *((void *)a1 + 6);
      if (!v9) {
        return result;
      }
      break;
    default:
      return result;
  }
  while (1)
  {
    uint64_t result = xmlRelaxNGIsCompilable(v9);
    if (result != 1) {
      break;
    }
    uint64_t v9 = *(void *)(v9 + 64);
    if (!v9) {
      goto LABEL_34;
    }
  }
LABEL_31:
  if (result == 1)
  {
LABEL_34:
    __int16 v3 = *((_WORD *)a1 + 49);
LABEL_35:
    *((_WORD *)a1 + 49) = v3 | 0x40;
    return 1;
  }
  if (!result)
  {
    __int16 v3 = *((_WORD *)a1 + 49);
LABEL_10:
    uint64_t result = 0;
    *((_WORD *)a1 + 49) = v3 | 0x80;
  }
  return result;
}

uint64_t xmlRelaxNGCompile(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = a2;
  while (2)
  {
    switch(*(_DWORD *)v2)
    {
      case 0xFFFFFFFF:
        uint64_t v2 = *(void *)(v2 + 48);
        if (!v2) {
          return 0xFFFFFFFFLL;
        }
        continue;
      case 0:
        uint64_t v8 = *(xmlAutomata **)(a1 + 232);
        uint64_t v9 = *(xmlAutomataState **)(a1 + 240);
        goto LABEL_55;
      case 1:
      case 2:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 0x13:
        unsigned int v5 = *(_DWORD *)v2 - 1;
        if (v5 > 0x12) {
          int v6 = "unknown";
        }
        else {
          int v6 = off_1E60CE408[v5];
        }
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "RNG internal error trying to compile %s\n", v6);
        return 0;
      case 3:
        uint64_t v10 = xmlAutomataNewEpsilon(*(xmlAutomataPtr *)(a1 + 232), *(xmlAutomataStatePtr *)(a1 + 240), 0);
        *(void *)(a1 + 240) = v10;
        xmlRelaxNGCompile(a1, *(void *)(v2 + 48));
        xmlAutomataNewTransition(*(xmlAutomataPtr *)(a1 + 232), *(xmlAutomataStatePtr *)(a1 + 240), *(xmlAutomataStatePtr *)(a1 + 240), (const xmlChar *)"#text", 0);
        goto LABEL_30;
      case 4:
        uint64_t v11 = *(xmlAutomata **)(a1 + 232);
        if (v11)
        {
          uint64_t v12 = *(const xmlChar **)(v2 + 16);
          if (v12) {
            *(void *)(a1 + 240) = xmlAutomataNewTransition2(v11, *(xmlAutomataStatePtr *)(a1 + 240), 0, v12, *(const xmlChar **)(v2 + 24), (void *)v2);
          }
        }
        if ((*(_WORD *)(v2 + 98) & 0x40) == 0)
        {
          uint64_t v13 = *(void *)(a1 + 232);
LABEL_51:
          uint64_t result = xmlRelaxNGTryCompile(a1, v2);
          *(void *)(a1 + 232) = v13;
          return result;
        }
        uint64_t v13 = *(void *)(a1 + 232);
        if (*(__int16 *)(v2 + 96) == -25) {
          goto LABEL_51;
        }
        uint64_t v31 = *(void *)(a1 + 240);
        *(_WORD *)(v2 + 96) = -25;
        uint64_t v32 = *(void *)(v2 + 48);
        xmlAutomataPtr v33 = xmlNewAutomata();
        *(void *)(a1 + 232) = v33;
        if (!v33) {
          return 0xFFFFFFFFLL;
        }
        xmlAutomataSetFlags((uint64_t)v33, 1);
        xmlAutomataStatePtr InitState = xmlAutomataGetInitState(*(xmlAutomataPtr *)(a1 + 232));
        *(void *)(a1 + 240) = InitState;
        if (v32)
        {
          do
          {
            xmlRelaxNGCompile(a1, v32);
            uint64_t v32 = *(void *)(v32 + 64);
          }
          while (v32);
          uint64_t v35 = *(xmlAutomataState **)(a1 + 240);
        }
        else
        {
          uint64_t v35 = InitState;
        }
        xmlAutomataSetFinalState(*(xmlAutomataPtr *)(a1 + 232), v35);
        uint64_t v36 = xmlAutomataCompile(*(xmlAutomataPtr *)(a1 + 232));
        *(void *)(v2 + 104) = v36;
        if (!xmlRegexpIsDeterminist(v36))
        {
          xmlRegFreeRegexp(*(xmlRegexpPtr *)(v2 + 104));
          *(void *)(v2 + 104) = 0;
        }
        xmlFreeAutomata(*(xmlAutomataPtr *)(a1 + 232));
        uint64_t result = 0;
        *(void *)(a1 + 232) = v13;
        *(void *)(a1 + 240) = v31;
        return result;
      case 0xA:
      case 0xB:
      case 0xC:
      case 0xD:
      case 0x12:
        uint64_t v7 = *(void *)(v2 + 48);
        if (!v7) {
          return 0;
        }
        while (1)
        {
          uint64_t result = xmlRelaxNGCompile(a1, v7);
          if (result) {
            break;
          }
          uint64_t v7 = *(void *)(v7 + 64);
          if (!v7) {
            return 0;
          }
        }
        return result;
      case 0xE:
        int v14 = *(xmlAutomataState **)(a1 + 240);
        uint64_t v15 = *(void *)(v2 + 48);
        uint64_t v16 = v14;
        if (v15)
        {
          do
          {
            xmlRelaxNGCompile(a1, v15);
            uint64_t v15 = *(void *)(v15 + 64);
          }
          while (v15);
          uint64_t v16 = *(xmlAutomataState **)(a1 + 240);
        }
        xmlAutomataNewEpsilon(*(xmlAutomataPtr *)(a1 + 232), v14, v16);
        return 0;
      case 0xF:
        uint64_t v10 = xmlAutomataNewEpsilon(*(xmlAutomataPtr *)(a1 + 232), *(xmlAutomataStatePtr *)(a1 + 240), 0);
        *(void *)(a1 + 240) = v10;
        uint64_t v17 = *(void *)(v2 + 48);
        uint64_t v18 = v10;
        if (v17)
        {
          do
          {
            xmlRelaxNGCompile(a1, v17);
            uint64_t v17 = *(void *)(v17 + 64);
          }
          while (v17);
          uint64_t v18 = *(xmlAutomataState **)(a1 + 240);
        }
        xmlAutomataNewEpsilon(*(xmlAutomataPtr *)(a1 + 232), v18, v10);
LABEL_30:
        uint64_t v8 = *(xmlAutomata **)(a1 + 232);
        uint64_t v9 = v10;
        goto LABEL_55;
      case 0x10:
        uint64_t v19 = *(void *)(v2 + 48);
        if (!v19)
        {
          int v21 = *(xmlAutomataState **)(a1 + 240);
LABEL_53:
          uint64_t v22 = v21;
          goto LABEL_54;
        }
        do
        {
          xmlRelaxNGCompile(a1, v19);
          uint64_t v19 = *(void *)(v19 + 64);
        }
        while (v19);
        uint64_t v20 = *(void *)(v2 + 48);
        int v21 = *(xmlAutomataState **)(a1 + 240);
        if (!v20) {
          goto LABEL_53;
        }
        do
        {
          xmlRelaxNGCompile(a1, v20);
          uint64_t v20 = *(void *)(v20 + 64);
        }
        while (v20);
        uint64_t v22 = *(xmlAutomataState **)(a1 + 240);
LABEL_54:
        xmlAutomataNewEpsilon(*(xmlAutomataPtr *)(a1 + 232), v22, v21);
        uint64_t v8 = *(xmlAutomata **)(a1 + 232);
        uint64_t v9 = v21;
LABEL_55:
        xmlAutomataStatePtr v30 = xmlAutomataNewEpsilon(v8, v9, 0);
        uint64_t result = 0;
        *(void *)(a1 + 240) = v30;
        return result;
      case 0x11:
        uint64_t v23 = *(void *)(v2 + 48);
        if (v23)
        {
          int v24 = 0;
          uint64_t v25 = *(void *)(a1 + 240);
          do
          {
            *(void *)(a1 + 240) = v25;
            uint64_t result = xmlRelaxNGCompile(a1, v23);
            if (result) {
              goto LABEL_59;
            }
            if (v24) {
              xmlAutomataNewEpsilon(*(xmlAutomataPtr *)(a1 + 232), *(xmlAutomataStatePtr *)(a1 + 240), v24);
            }
            else {
              int v24 = *(xmlAutomataState **)(a1 + 240);
            }
            uint64_t v23 = *(void *)(v23 + 64);
          }
          while (v23);
        }
        else
        {
          int v24 = 0;
        }
        uint64_t result = 0;
LABEL_59:
        *(void *)(a1 + 240) = v24;
        return result;
      case 0x14:
        if (xmlRelaxNGIsCompilable((int *)v2) != 1 || *(__int16 *)(v2 + 96) == -25) {
          return 0;
        }
        long long v37 = *(_OWORD *)(a1 + 232);
        *(_WORD *)(v2 + 96) = -25;
        uint64_t v26 = *(void *)(v2 + 48);
        xmlAutomataPtr v27 = xmlNewAutomata();
        *(void *)(a1 + 232) = v27;
        if (!v27) {
          return 0xFFFFFFFFLL;
        }
        xmlAutomataSetFlags((uint64_t)v27, 1);
        xmlAutomataStatePtr v28 = xmlAutomataGetInitState(*(xmlAutomataPtr *)(a1 + 232));
        *(void *)(a1 + 240) = v28;
        if (v26)
        {
          do
          {
            xmlRelaxNGCompile(a1, v26);
            uint64_t v26 = *(void *)(v26 + 64);
          }
          while (v26);
          long long v29 = *(xmlAutomataState **)(a1 + 240);
        }
        else
        {
          long long v29 = v28;
        }
        xmlAutomataSetFinalState(*(xmlAutomataPtr *)(a1 + 232), v29);
        if (xmlAutomataIsDeterminist(*(xmlAutomataPtr *)(a1 + 232))) {
          *(void *)(v2 + 104) = xmlAutomataCompile(*(xmlAutomataPtr *)(a1 + 232));
        }
        xmlFreeAutomata(*(xmlAutomataPtr *)(a1 + 232));
        uint64_t result = 0;
        *(_OWORD *)(a1 + 232) = v37;
        return result;
      default:
        return 0;
    }
  }
}

FILE *xmlRelaxNGDumpDefine(FILE *result, uint64_t a2)
{
  if (a2)
  {
    __int16 v3 = result;
    switch(*(_DWORD *)a2)
    {
      case 0xFFFFFFFF:
        for (uint64_t i = *(void *)(a2 + 48); i; uint64_t i = *(void *)(i + 64))
          uint64_t result = (FILE *)xmlRelaxNGDumpDefine(v3, i);
        return result;
      case 0:
        uint64_t v9 = "<empty/>\n";
        goto LABEL_63;
      case 1:
        uint64_t v9 = "<notAllowed/>\n";
        goto LABEL_67;
      case 2:
      case 6:
      case 0x14:
        xmlGenericErrorFunc v4 = *__xmlGenericError();
        unsigned int v5 = *__xmlGenericErrorContext();
        return (FILE *)((uint64_t (*)(void *, const char *, ...))v4)(v5, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 7849);
      case 3:
        uint64_t v9 = "<text/>\n";
        goto LABEL_24;
      case 4:
        fwrite("<element>\n", 0xAuLL, 1uLL, result);
        if (*(void *)(a2 + 16))
        {
          fwrite("<name", 5uLL, 1uLL, v3);
          if (*(void *)(a2 + 24)) {
            fprintf(v3, " ns=\"%s\"", *(const char **)(a2 + 24));
          }
          fprintf(v3, ">%s</name>\n", *(const char **)(a2 + 16));
        }
        for (uint64_t j = *(void *)(a2 + 72); j; uint64_t j = *(void *)(j + 64))
          xmlRelaxNGDumpDefine(v3, j);
        for (uint64_t k = *(void *)(a2 + 48); k; uint64_t k = *(void *)(k + 64))
          xmlRelaxNGDumpDefine(v3, k);
        uint64_t v9 = "</element>\n";
        size_t v12 = 11;
        goto LABEL_68;
      case 5:
      case 7:
        xmlGenericErrorFunc v6 = *__xmlGenericError();
        uint64_t v7 = *__xmlGenericErrorContext();
        return (FILE *)((uint64_t (*)(void *, const char *, ...))v6)(v7, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 7845);
      case 8:
        fwrite("<list>\n", 7uLL, 1uLL, result);
        for (uint64_t m = *(void *)(a2 + 48); m; uint64_t m = *(void *)(m + 64))
          xmlRelaxNGDumpDefine(v3, m);
        uint64_t v9 = "</list>\n";
LABEL_24:
        size_t v12 = 8;
        goto LABEL_68;
      case 9:
        fwrite("<attribute>\n", 0xCuLL, 1uLL, result);
        for (uint64_t n = *(void *)(a2 + 48); n; uint64_t n = *(void *)(n + 64))
          xmlRelaxNGDumpDefine(v3, n);
        uint64_t v9 = "</attribute>\n";
        goto LABEL_55;
      case 0xA:
        fwrite("<define", 7uLL, 1uLL, result);
        if (*(void *)(a2 + 16)) {
          fprintf(v3, " name=\"%s\"", *(const char **)(a2 + 16));
        }
        fwrite(">\n", 2uLL, 1uLL, v3);
        for (iuint64_t i = *(void *)(a2 + 48); ii; iuint64_t i = *(void *)(ii + 64))
          xmlRelaxNGDumpDefine(v3, ii);
        uint64_t v9 = "</define>\n";
        goto LABEL_59;
      case 0xB:
        fwrite("<ref", 4uLL, 1uLL, result);
        if (*(void *)(a2 + 16)) {
          fprintf(v3, " name=\"%s\"", *(const char **)(a2 + 16));
        }
        fwrite(">\n", 2uLL, 1uLL, v3);
        for (juint64_t j = *(void *)(a2 + 48); jj; juint64_t j = *(void *)(jj + 64))
          xmlRelaxNGDumpDefine(v3, jj);
        uint64_t v9 = "</ref>\n";
        size_t v12 = 7;
        goto LABEL_68;
      case 0xC:
        fwrite("<externalRef>", 0xDuLL, 1uLL, result);
        for (kuint64_t k = *(void *)(a2 + 48); kk; kuint64_t k = *(void *)(kk + 64))
          xmlRelaxNGDumpDefine(v3, kk);
        uint64_t v9 = "</externalRef>\n";
        size_t v12 = 15;
        goto LABEL_68;
      case 0xD:
        fwrite("<parentRef", 0xAuLL, 1uLL, result);
        if (*(void *)(a2 + 16)) {
          fprintf(v3, " name=\"%s\"", *(const char **)(a2 + 16));
        }
        fwrite(">\n", 2uLL, 1uLL, v3);
        for (muint64_t m = *(void *)(a2 + 48); mm; muint64_t m = *(void *)(mm + 64))
          xmlRelaxNGDumpDefine(v3, mm);
        uint64_t v9 = "</parentRef>\n";
        goto LABEL_55;
      case 0xE:
        fwrite("<optional>\n", 0xBuLL, 1uLL, result);
        for (nuint64_t n = *(void *)(a2 + 48); nn; nuint64_t n = *(void *)(nn + 64))
          xmlRelaxNGDumpDefine(v3, nn);
        uint64_t v9 = "</optional>\n";
        size_t v12 = 12;
        goto LABEL_68;
      case 0xF:
        fwrite("<zeroOrMore>\n", 0xDuLL, 1uLL, result);
        for (uint64_t i1 = *(void *)(a2 + 48); i1; uint64_t i1 = *(void *)(i1 + 64))
          xmlRelaxNGDumpDefine(v3, i1);
        uint64_t v9 = "</zeroOrMore>\n";
        goto LABEL_67;
      case 0x10:
        fwrite("<oneOrMore>\n", 0xCuLL, 1uLL, result);
        for (uint64_t i2 = *(void *)(a2 + 48); i2; uint64_t i2 = *(void *)(i2 + 64))
          xmlRelaxNGDumpDefine(v3, i2);
        uint64_t v9 = "</oneOrMore>\n";
LABEL_55:
        size_t v12 = 13;
        goto LABEL_68;
      case 0x11:
        fwrite("<choice>\n", 9uLL, 1uLL, result);
        for (uint64_t i3 = *(void *)(a2 + 48); i3; uint64_t i3 = *(void *)(i3 + 64))
          xmlRelaxNGDumpDefine(v3, i3);
        uint64_t v9 = "</choice>\n";
LABEL_59:
        size_t v12 = 10;
        goto LABEL_68;
      case 0x12:
        fwrite("<group>\n", 8uLL, 1uLL, result);
        for (uint64_t i4 = *(void *)(a2 + 48); i4; uint64_t i4 = *(void *)(i4 + 64))
          xmlRelaxNGDumpDefine(v3, i4);
        uint64_t v9 = "</group>\n";
LABEL_63:
        size_t v12 = 9;
        goto LABEL_68;
      case 0x13:
        fwrite("<interleave>\n", 0xDuLL, 1uLL, result);
        for (uint64_t i5 = *(void *)(a2 + 48); i5; uint64_t i5 = *(void *)(i5 + 64))
          xmlRelaxNGDumpDefine(v3, i5);
        uint64_t v9 = "</interleave>\n";
LABEL_67:
        size_t v12 = 14;
LABEL_68:
        uint64_t result = (FILE *)fwrite(v9, v12, 1uLL, v3);
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t xmlRelaxNGValidateAttributeList(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = a2;
  int v4 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = a2;
  do
  {
    if (*(_DWORD *)v6 == 9)
    {
      if (xmlRelaxNGValidateAttribute(a1, v6)) {
        uint64_t v5 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v5 = v5;
      }
    }
    else
    {
      int v4 = 1;
    }
    uint64_t v6 = *(void *)(v6 + 64);
  }
  while (v6);
  if (v4)
  {
    do
    {
      if (*(_DWORD *)v2 != 9)
      {
        if (!*(void *)(a1 + 96) && !*(void *)(a1 + 104))
        {
          xmlRelaxNGAddValidError(a1, 6, 0, 0, 0);
          return 0xFFFFFFFFLL;
        }
        int v7 = xmlRelaxNGValidateDefinition(a1, v2);
        if (v7 < 0) {
          uint64_t v5 = 0xFFFFFFFFLL;
        }
        else {
          uint64_t v5 = v5;
        }
        if (v7 == -1) {
          return v5;
        }
      }
      uint64_t v2 = *(void *)(v2 + 64);
    }
    while (v2);
  }
  return v5;
}

uint64_t xmlRelaxNGValidateElementEnd(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = *(void *)(v4 + 8);
  if (v5 && (uint64_t v6 = xmlRelaxNGSkipIgnored(a1, v5), (*(void *)(v4 + 8) = v6) != 0))
  {
    if (a2) {
      xmlRelaxNGAddValidError(a1, 26, *(xmlChar **)(*(void *)v4 + 16), *(xmlChar **)(v6 + 16), 0);
    }
    return 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v8 = *(unsigned int *)(v4 + 16);
    if ((int)v8 < 1)
    {
      return 0;
    }
    else
    {
      uint64_t v9 = *(void *)(v4 + 48);
      uint64_t v7 = 0xFFFFFFFFLL;
      while (!*(void *)v9)
      {
        uint64_t v7 = (v7 - 1);
        v9 += 8;
        if (!--v8) {
          return 0;
        }
      }
      if (a2) {
        xmlRelaxNGAddValidError(a1, 27, *(xmlChar **)(*(void *)v9 + 16), *(xmlChar **)(*(void *)v4 + 16), 0);
      }
    }
  }
  return v7;
}

uint64_t xmlRelaxNGLogBestError(uint64_t result)
{
  uint64_t v1 = *(unsigned int **)(result + 104);
  if (v1)
  {
    uint64_t v2 = *v1;
    if ((int)v2 >= 1)
    {
      uint64_t v3 = 0;
      uint64_t v4 = *((void *)v1 + 1);
      int v5 = -1;
      int v6 = 1000000;
      do
      {
        uint64_t v7 = *(void *)(v4 + 8 * v3);
        if (v7)
        {
          if (*(void *)(v7 + 8))
          {
            if (v5 == -1 || v6 > 100000)
            {
              int v5 = v3;
              int v6 = 100000;
            }
          }
          else
          {
            int v10 = *(_DWORD *)(v7 + 24);
            if (v5 == -1 || v6 > v10)
            {
              int v5 = v3;
              int v6 = v10;
            }
          }
        }
        ++v3;
      }
      while (v2 != v3);
      if ((v5 & 0x80000000) == 0 && v5 < (int)v2)
      {
        *(void *)(result + 96) = *(void *)(v4 + 8 * v5);
        return xmlRelaxNGValidateElementEnd(result, 1);
      }
    }
  }
  return result;
}

uint64_t xmlRelaxNGValidateAttribute(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 96);
  if (*(int *)(v2 + 24) < 1) {
    return 0xFFFFFFFFLL;
  }
  int v5 = *(_DWORD *)(v2 + 16);
  if (*(void *)(a2 + 16))
  {
    if (v5 >= 1)
    {
      for (uint64_t i = 0; i < *(int *)(v2 + 16); ++i)
      {
        uint64_t v7 = *(void *)(*(void *)(v2 + 48) + 8 * i);
        if (!v7 || !xmlStrEqual(*(const xmlChar **)(a2 + 16), *(const xmlChar **)(v7 + 16))) {
          goto LABEL_13;
        }
        uint64_t v8 = *(const xmlChar **)(a2 + 24);
        if (v8 && *v8)
        {
          uint64_t v9 = *(void *)(v7 + 72);
          if (!v9) {
            goto LABEL_13;
          }
        }
        else
        {
          uint64_t v9 = *(void *)(v7 + 72);
          if (!v9) {
            goto LABEL_23;
          }
        }
        if (xmlStrEqual(v8, *(const xmlChar **)(v9 + 16)))
        {
LABEL_23:
          String = xmlNodeListGetString(*(xmlDocPtr *)(v7 + 64), *(const xmlNode **)(v7 + 24), 1);
          uint64_t v15 = *(void **)(a1 + 96);
          uint64_t v16 = v15[4];
          uint64_t v17 = v15[1];
          v15[1] = v7;
          v15[4] = String;
          v15[5] = 0;
          uint64_t v18 = *(void *)(a2 + 48);
          if (v18)
          {
            do
            {
              uint64_t v12 = xmlRelaxNGValidateValue(a1, v18);
              if (v12) {
                break;
              }
              uint64_t v18 = *(void *)(v18 + 64);
            }
            while (v18);
            goto LABEL_30;
          }
LABEL_31:
          uint64_t v12 = 0;
          uint64_t v20 = String;
          goto LABEL_32;
        }
LABEL_13:
        uint64_t v2 = *(void *)(a1 + 96);
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (v5 < 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t i = 0;
  while (1)
  {
    uint64_t v10 = *(void *)(v2 + 48);
    uint64_t v11 = *(void *)(v10 + 8 * i);
    if (v11) {
      break;
    }
LABEL_20:
    if (++i >= *(int *)(v2 + 16)) {
      return 0xFFFFFFFFLL;
    }
  }
  if (xmlRelaxNGAttributeMatch((void *)a2, *(void *)(v10 + 8 * i)) != 1)
  {
    uint64_t v2 = *(void *)(a1 + 96);
    goto LABEL_20;
  }
  String = xmlNodeListGetString(*(xmlDocPtr *)(v11 + 64), *(const xmlNode **)(v11 + 24), 1);
  uint64_t v15 = *(void **)(a1 + 96);
  uint64_t v16 = v15[4];
  uint64_t v17 = v15[1];
  v15[1] = v11;
  v15[4] = String;
  uint64_t v19 = *(void *)(a2 + 48);
  if (!v19) {
    goto LABEL_31;
  }
  do
  {
    uint64_t v12 = xmlRelaxNGValidateValue(a1, v19);
    if (v12) {
      break;
    }
    uint64_t v19 = *(void *)(v19 + 64);
  }
  while (v19);
LABEL_30:
  uint64_t v15 = *(void **)(a1 + 96);
  uint64_t v20 = (xmlChar *)v15[4];
LABEL_32:
  if (v20) {
    int v21 = v20;
  }
  else {
    int v21 = String;
  }
  if (v21)
  {
    xmlFree(v21);
    uint64_t v15 = *(void **)(a1 + 96);
  }
  v15[4] = v16;
  v15[1] = v17;
  if (!v12)
  {
    uint64_t v12 = 0;
    *(void *)(v15[6] + 8 * i) = 0;
    --*(_DWORD *)(*(void *)(a1 + 96) + 24);
  }
  return v12;
}

uint64_t xmlRelaxNGAttributeMatch(void *a1, uint64_t a2)
{
  uint64_t v4 = (const xmlChar *)a1[2];
  if (v4)
  {
    uint64_t result = xmlStrEqual(v4, *(const xmlChar **)(a2 + 16));
    if (!result) {
      return result;
    }
  }
  int v6 = (const xmlChar *)a1[3];
  if (v6)
  {
    uint64_t v7 = *(void *)(a2 + 72);
    if (*v6)
    {
      if (!v7) {
        return 0;
      }
      uint64_t result = xmlStrEqual(v6, *(const xmlChar **)(v7 + 16));
      if (!result) {
        return result;
      }
    }
    else if (v7)
    {
      return 0;
    }
  }
  uint64_t v8 = a1[10];
  if (!v8) {
    return 1;
  }
  if (*(_DWORD *)v8 != 17)
  {
    if (*(_DWORD *)v8 == 2)
    {
      uint64_t v9 = *(void *)(v8 + 48);
      if (v9)
      {
        while (xmlRelaxNGAttributeMatch(v9, a2) != 1)
        {
          uint64_t v9 = *(void *)(v9 + 64);
          if (!v9) {
            return 1;
          }
        }
        return 0;
      }
    }
    else
    {
      xmlGenericErrorFunc v11 = *__xmlGenericError();
      uint64_t v12 = __xmlGenericErrorContext();
      v11(*v12, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 9117);
    }
    return 1;
  }
  uint64_t v10 = *(void *)(v8 + 80);
  if (!v10) {
    return 0;
  }
  while (1)
  {
    uint64_t result = xmlRelaxNGAttributeMatch(v10, a2);
    if (result == 1) {
      break;
    }
    uint64_t v10 = *(void *)(v10 + 64);
    if (!v10) {
      return 0;
    }
  }
  return result;
}

uint64_t xmlRelaxNGValidateValue(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  while (2)
  {
    uint64_t v4 = *(void *)(a1 + 96);
    int v5 = *(unsigned __int8 **)(v4 + 32);
    switch(*(_DWORD *)a2)
    {
      case 0:
        if (!v5) {
          return 0;
        }
        unsigned int v9 = *v5;
        if (!*v5) {
          return 0;
        }
        for (uint64_t i = v5 + 1; ; ++i)
        {
          if (v9 > 0x20) {
            return 0xFFFFFFFFLL;
          }
          if (((1 << v9) & 0x100002600) == 0) {
            break;
          }
          unsigned int v11 = *i;
          unsigned int v9 = v11;
        }
        if (!v9) {
          return 0;
        }
        return 0xFFFFFFFFLL;
      case 2:
        uint64_t v15 = *(void *)(a2 + 48);
        if (!v15) {
          return 0;
        }
        uint64_t v14 = 0;
        while (xmlRelaxNGValidateValue(v3))
        {
          uint64_t v15 = *(void *)(v15 + 64);
          if (!v15) {
            return v14;
          }
        }
        return 0xFFFFFFFFLL;
      case 3:
        return 0;
      case 5:
        uint64_t v14 = xmlRelaxNGValidateDatatype(a1, *(xmlChar **)(v4 + 32), a2, *(void *)(v4 + 8));
        if (!v14) {
          xmlRelaxNGNextValue(v3);
        }
        return v14;
      case 7:
        if (xmlStrEqual(*(const xmlChar **)(v4 + 32), *(const xmlChar **)(a2 + 32))) {
          goto LABEL_27;
        }
        uint64_t v7 = *(xmlChar **)(a2 + 16);
        if (v7)
        {
          uint64_t v43 = *(void *)(a2 + 40);
          if (v43)
          {
            int v44 = *(uint64_t (**)(void, void, void, void, void, unsigned __int8 *, void))(v43 + 32);
            if (v44)
            {
              int v45 = v44(*(void *)(v43 + 8), *(void *)(a2 + 16), *(void *)(a2 + 32), *(void *)(a2 + 8), *(void *)(a2 + 72), v5, **(void **)(v3 + 96));
              if ((v45 & 0x80000000) == 0)
              {
                if (v45 == 1)
                {
LABEL_27:
                  xmlRelaxNGNextValue(v3);
                  return 0;
                }
                return 0xFFFFFFFFLL;
              }
              uint64_t v7 = *(xmlChar **)(a2 + 16);
            }
          }
          a1 = v3;
          int v6 = 5;
          goto LABEL_6;
        }
        uint64_t v47 = xmlRelaxNGNormalize(v3, *(unsigned char **)(a2 + 32));
        uint64_t v48 = xmlRelaxNGNormalize(v3, v5);
        int v49 = (xmlChar *)v48;
        if (v47 && v48)
        {
          if (xmlStrEqual(v47, v48)) {
            int v50 = 0;
          }
          else {
            int v50 = -1;
          }
        }
        else
        {
          int v50 = -1;
          if (!v47) {
            goto LABEL_103;
          }
        }
        xmlFree(v47);
LABEL_103:
        if (v49) {
          xmlFree(v49);
        }
        if (!v50) {
          goto LABEL_27;
        }
        return 0xFFFFFFFFLL;
      case 8:
        uint64_t v16 = *(void *)(a2 + 48);
        uint64_t v17 = *(void *)(v4 + 40);
        uint64_t v18 = xmlStrdup(*(const xmlChar **)(v4 + 32));
        if (v18 || (uint64_t v18 = xmlStrdup((const xmlChar *)"")) != 0)
        {
          uint64_t v19 = v18;
          while (1)
          {
            unsigned int v20 = *v19;
            if (v20 > 0x20) {
              goto LABEL_40;
            }
            if (((1 << v20) & 0x100002600) != 0)
            {
              do
              {
                *v19++ = 0;
                unsigned int v21 = *v19;
                BOOL v22 = v21 > 0x20;
                uint64_t v23 = (1 << v21) & 0x100002600;
                BOOL v24 = v22 || v23 == 0;
              }
              while (!v24);
            }
            else
            {
              if (!*v19)
              {
                uint64_t v35 = *(void *)(v3 + 96);
                *(void *)(v35 + 40) = v19;
                uint64_t v36 = v18;
                do
                {
                  BOOL v24 = v36 == v19;
                  int v38 = *v36++;
                  int v37 = v38;
                }
                while (!v24 && !v37);
                uint64_t v39 = v36 - 1;
                *(void *)(v35 + 32) = v36 - 1;
                if (v16)
                {
                  do
                  {
                    uint64_t v40 = *(void *)(v3 + 96);
                    if (*(void *)(v40 + 32) == *(void *)(v40 + 40)) {
                      *(void *)(v40 + 32) = 0;
                    }
                    uint64_t v41 = xmlRelaxNGValidateValue(v3);
                    if (v41)
                    {
                      uint64_t v14 = v41;
                      goto LABEL_94;
                    }
                    uint64_t v16 = *(void *)(v16 + 64);
                  }
                  while (v16);
                  uint64_t v35 = *(void *)(v3 + 96);
                  uint64_t v39 = *(xmlChar **)(v35 + 32);
                  if (v39) {
                    goto LABEL_74;
                  }
LABEL_92:
                  uint64_t v14 = 0;
                }
                else
                {
LABEL_74:
                  if (v39 == *(xmlChar **)(v35 + 40)) {
                    goto LABEL_92;
                  }
                  xmlRelaxNGAddValidError(v3, 8, v39, 0, 0);
                  uint64_t v14 = 0xFFFFFFFFLL;
                }
LABEL_94:
                xmlFree(v18);
                uint64_t v46 = *(void *)(v3 + 96);
                *(void *)(v46 + 32) = v5;
                *(void *)(v46 + 40) = v17;
                return v14;
              }
LABEL_40:
              ++v19;
            }
          }
        }
        a1 = v3;
        int v6 = 6;
LABEL_5:
        uint64_t v7 = 0;
LABEL_6:
        xmlRelaxNGAddValidError(a1, v6, v7, 0, 0);
        return 0xFFFFFFFFLL;
      case 0xA:
      case 0x12:
        uint64_t v8 = *(void *)(a2 + 48);
        if (!v8) {
          return 0;
        }
        while (!xmlRelaxNGValidateValue(v3))
        {
          uint64_t v8 = *(void *)(v8 + 64);
          if (!v8) {
            return 0;
          }
        }
        return 0xFFFFFFFFLL;
      case 0xB:
      case 0xD:
        a2 = *(void *)(a2 + 48);
        if (a2) {
          continue;
        }
        int v6 = 7;
        goto LABEL_5;
      case 0xE:
        if (!v5 || !*v5) {
          return 0;
        }
        int v25 = *(_DWORD *)(a1 + 56);
        *(_DWORD *)(a1 + 56) = v25 | 1;
        int v26 = xmlRelaxNGValidateValue(a1);
        *(_DWORD *)(v3 + 56) = v25;
        if (v26) {
          *(void *)(*(void *)(v3 + 96) + 32) = v5;
        }
        goto LABEL_79;
      case 0xF:
        goto LABEL_49;
      case 0x10:
        uint64_t v27 = *(void *)(a2 + 48);
        if (!v27) {
          goto LABEL_49;
        }
        do
        {
          uint64_t v28 = xmlRelaxNGValidateValue(v3);
          if (v28) {
            return v28;
          }
          uint64_t v27 = *(void *)(v27 + 64);
        }
        while (v27);
        uint64_t v4 = *(void *)(v3 + 96);
        int v5 = *(unsigned __int8 **)(v4 + 32);
LABEL_49:
        if (!v5 || !*v5) {
          return 0;
        }
        long long v29 = 0;
        int v30 = *(_DWORD *)(v3 + 56);
        *(_DWORD *)(v3 + 56) = v30 | 1;
        do
        {
          if (v29 == v5) {
            break;
          }
          long long v29 = v5;
          if (v5 == *(unsigned __int8 **)(v4 + 40)) {
            break;
          }
          uint64_t v31 = *(void *)(a2 + 48);
          if (v31)
          {
            while (!xmlRelaxNGValidateValue(v3))
            {
              uint64_t v31 = *(void *)(v31 + 64);
              if (!v31)
              {
                uint64_t v4 = *(void *)(v3 + 96);
                goto LABEL_58;
              }
            }
            *(void *)(*(void *)(v3 + 96) + 32) = v29;
            break;
          }
LABEL_58:
          int v5 = *(unsigned __int8 **)(v4 + 32);
        }
        while (v5);
        *(_DWORD *)(v3 + 56) = v30;
        goto LABEL_79;
      case 0x11:
        uint64_t v32 = *(void *)(a2 + 48);
        int v33 = *(_DWORD *)(a1 + 56);
        *(_DWORD *)(a1 + 56) = v33 | 1;
        if (!v32) {
          goto LABEL_76;
        }
        while (1)
        {
          uint64_t v34 = xmlRelaxNGValidateValue(v3);
          if (!v34) {
            break;
          }
          *(void *)(*(void *)(v3 + 96) + 32) = v5;
          uint64_t v32 = *(void *)(v32 + 64);
          if (!v32)
          {
            uint64_t v14 = v34;
            *(_DWORD *)(v3 + 56) = v33;
            if ((v33 & 1) == 0) {
              xmlRelaxNGDumpValidError(v3);
            }
            return v14;
          }
        }
LABEL_76:
        *(_DWORD *)(v3 + 56) = v33;
LABEL_79:
        if (*(int *)(v3 + 80) >= 1) {
          xmlRelaxNGPopErrors(v3, 0);
        }
        return 0;
      default:
        xmlGenericErrorFunc v12 = *__xmlGenericError();
        uint64_t v13 = __xmlGenericErrorContext();
        v12(*v13, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 9029);
        return 0xFFFFFFFFLL;
    }
  }
}

uint64_t xmlRelaxNGNextValue(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 96);
  uint64_t v4 = *(void *)(v1 + 32);
  uint64_t v2 = (void *)(v1 + 32);
  uint64_t v3 = v4;
  if (v4 && (int v5 = *(unsigned char **)(*(void *)(result + 96) + 40)) != 0)
  {
    int v6 = (unsigned char *)(v3 - 1);
    while (*++v6)
      ;
    while (1)
    {
      if (v6 == v5)
      {
        *uint64_t v2 = 0;
        return result;
      }
      if (*v6) {
        break;
      }
      ++v6;
    }
    *uint64_t v2 = v6;
  }
  else
  {
    *uint64_t v2 = 0;
    v2[1] = 0;
  }
  return result;
}

uint64_t xmlRelaxNGValidateDatatype(uint64_t a1, xmlChar *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v24 = 0;
  if (!a3) {
    return 0xFFFFFFFFLL;
  }
  int v5 = *(void **)(a3 + 40);
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = (uint64_t (*)(uint64_t, uint64_t, xmlChar *, uint64_t *, uint64_t))v5[3];
  if (!v7) {
    goto LABEL_12;
  }
  uint64_t v10 = *(_DWORD **)(a3 + 72);
  if (v10 && *v10 == 6)
  {
    uint64_t v11 = v5[1];
    uint64_t v12 = *(void *)(a3 + 16);
    uint64_t v13 = &v24;
    uint64_t v14 = a2;
  }
  else
  {
    uint64_t v11 = v5[1];
    uint64_t v12 = *(void *)(a3 + 16);
    uint64_t v14 = a2;
    uint64_t v13 = 0;
  }
  int v15 = v7(v11, v12, v14, v13, a4);
  if (v15 < 0)
  {
LABEL_12:
    xmlRelaxNGAddValidError(a1, 2, *(xmlChar **)(a3 + 16), 0, 0);
    if (v24)
    {
      uint64_t v17 = (void (*)(void))v5[6];
      if (v17) {
        v17(v5[1]);
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (v15 == 1)
  {
    uint64_t v19 = *(void *)(a3 + 72);
    if (v19)
    {
      while (*(_DWORD *)v19 == 6)
      {
        unsigned int v20 = (unsigned int (*)(void, void, void, void, xmlChar *, uint64_t))v5[5];
        if (v20)
        {
          if (v20(v5[1], *(void *)(a3 + 16), *(void *)(v19 + 16), *(void *)(v19 + 32), a2, v24)) {
            uint64_t v16 = 0xFFFFFFFFLL;
          }
          else {
            uint64_t v16 = 0;
          }
          if (v16)
          {
LABEL_27:
            if (v16) {
              goto LABEL_32;
            }
            break;
          }
        }
        else
        {
          uint64_t v16 = 0;
        }
        uint64_t v19 = *(void *)(v19 + 64);
        if (!v19) {
          goto LABEL_27;
        }
      }
    }
    if (*(void *)(a3 + 48))
    {
      uint64_t v21 = *(void *)(a1 + 96);
      long long v23 = *(_OWORD *)(v21 + 32);
      *(void *)(v21 + 32) = a2;
      *(void *)(v21 + 40) = 0;
      uint64_t v16 = xmlRelaxNGValidateValue(a1);
      *(_OWORD *)(*(void *)(a1 + 96) + 32) = v23;
    }
    else
    {
      uint64_t v16 = 0;
    }
  }
  else if (v15 == 2)
  {
    xmlRelaxNGAddValidError(a1, 4, a2, 0, 1);
    uint64_t v16 = 2;
  }
  else
  {
    xmlRelaxNGAddValidError(a1, 3, *(xmlChar **)(a3 + 16), a2, 1);
    uint64_t v16 = 0xFFFFFFFFLL;
  }
LABEL_32:
  if (v24)
  {
    BOOL v22 = (void (*)(void))v5[6];
    if (v22) {
      v22(v5[1]);
    }
  }
  return v16;
}

uint64_t xmlRelaxNGSkipIgnored(uint64_t a1, uint64_t a2)
{
  for (; a2; a2 = *(void *)(a2 + 48))
  {
    unsigned int v2 = *(_DWORD *)(a2 + 8);
    if (v2 > 0x14) {
      break;
    }
    int v3 = 1 << v2;
    if ((v3 & 0x180180) == 0)
    {
      if ((v3 & 0x18) == 0) {
        return a2;
      }
      if ((*(unsigned char *)(a1 + 56) & 4) == 0)
      {
        uint64_t v4 = *(unsigned char **)(a2 + 80);
        if (v4)
        {
          while (1)
          {
            unsigned int v5 = *v4;
            if (v5 > 0x20) {
              return a2;
            }
            if (((1 << v5) & 0x100002600) == 0)
            {
              if (*v4) {
                return a2;
              }
              break;
            }
            ++v4;
          }
        }
      }
    }
  }
  return a2;
}

void *xmlRelaxNGNewStates(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 128);
  if (!v3 || (v4 = *(_DWORD *)(a1 + 120), BOOL v5 = __OFSUB__(v4, 1), v6 = v4 - 1, (v6 < 0) ^ v5))
  {
    if (a2 <= 16) {
      unsigned int v8 = 16;
    }
    else {
      unsigned int v8 = a2;
    }
    unsigned int v9 = xmlMalloc(8 * (v8 - 1) + 16);
    uint64_t v7 = v9;
    if (v9)
    {
      _DWORD *v9 = 0;
      v9[1] = v8;
      uint64_t v10 = xmlMalloc(8 * v8);
      v7[1] = v10;
      if (!v10)
      {
        xmlRngVErrMemory(a1, (const xmlChar *)"allocating states\n");
        xmlFree(v7);
        return 0;
      }
    }
    else
    {
      xmlRngVErrMemory(a1, (const xmlChar *)"allocating states\n");
    }
  }
  else
  {
    *(_DWORD *)(a1 + 120) = v6;
    uint64_t v7 = *(void **)(v3 + 8 * v6);
    *(_DWORD *)uint64_t v7 = 0;
  }
  return v7;
}

uint64_t xmlRelaxNGValidateState(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  if (a2)
  {
    BOOL v5 = (uint64_t *)(a1 + 96);
    int v4 = *(long long **)(a1 + 96);
    if (v4) {
      uint64_t v6 = *((void *)v4 + 1);
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = 0;
    ++*(_DWORD *)(a1 + 60);
    switch(*(_DWORD *)a2)
    {
      case 0xFFFFFFFF:
      case 0xB:
      case 0xC:
      case 0xD:
      case 0x14:
        unsigned int v8 = *(void **)(a2 + 48);
        goto LABEL_8;
      case 1:
        goto LABEL_251;
      case 2:
      case 6:
        xmlGenericErrorFunc v10 = *__xmlGenericError();
        uint64_t v11 = __xmlGenericErrorContext();
        v10(*v11, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 10628);
        goto LABEL_251;
      case 3:
        for (; v6; uint64_t v6 = *(void *)(v6 + 48))
        {
          unsigned int v12 = *(_DWORD *)(v6 + 8);
          BOOL v13 = v12 > 8;
          int v14 = (1 << v12) & 0x198;
          if (v13 || v14 == 0) {
            break;
          }
        }
        uint64_t v7 = 0;
        *((void *)v4 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v6;
        goto LABEL_252;
      case 4:
        uint64_t v7 = *(unsigned int *)(a1 + 80);
        uint64_t v16 = xmlRelaxNGSkipIgnored(a1, v6);
        if (v16)
        {
          uint64_t v17 = v16;
          if (*(_DWORD *)(v16 + 8) == 1)
          {
            if (*(void *)(v16 + 104) != a2)
            {
              if ((int)xmlRelaxNGElementMatch(v2, (void *)a2, v16) > 0)
              {
                int v18 = *(_DWORD *)(v2 + 80);
                if (v18)
                {
                  if (v18 > (int)v7) {
                    xmlRelaxNGPopErrors(v2, v7);
                  }
                  while (1)
                  {
                    unsigned int v20 = *(const xmlChar ***)(v2 + 72);
                    if (!v20) {
                      break;
                    }
                    int v19 = *(_DWORD *)v20;
                    if (*(_DWORD *)v20 == 13)
                    {
                      if (xmlStrEqual(v20[4], *(const xmlChar **)(v17 + 16))) {
                        goto LABEL_32;
                      }
                      unsigned int v20 = *(const xmlChar ***)(v2 + 72);
                      int v19 = *(_DWORD *)v20;
                    }
                    if (v19 == 19)
                    {
                      if (xmlStrEqual(v20[3], *(const xmlChar **)(v17 + 16))) {
                        goto LABEL_32;
                      }
                      int v19 = **(_DWORD **)(v2 + 72);
                    }
                    if ((v19 & 0xFFFFFFFE) != 0x16) {
                      break;
                    }
LABEL_32:
                    xmlRelaxNGValidErrorPop(v2);
                  }
                }
                int v21 = *(_DWORD *)(v2 + 56);
                if ((v21 & 4) != 0) {
                  *(_DWORD *)(v2 + 56) = v21 - 4;
                }
                int v22 = *(_DWORD *)(v2 + 80);
                long long v23 = xmlRelaxNGNewValidState(v2, v17);
                if (v23)
                {
                  uint64_t v24 = *v5;
                  *BOOL v5 = (uint64_t)v23;
                  uint64_t v25 = *(void *)(a2 + 72);
                  if (v25 && xmlRelaxNGValidateAttributeList(v2, v25))
                  {
                    xmlRelaxNGAddValidError(v2, 24, *(xmlChar **)(v17 + 16), 0, 0);
                    uint64_t v7 = 0xFFFFFFFFLL;
                  }
                  else
                  {
                    uint64_t v7 = 0;
                  }
                  if (*(void *)(a2 + 104))
                  {
                    int v204 = v21;
                    uint64_t v168 = v24;
                    int v169 = v22;
                    long long v207 = *(_OWORD *)(v2 + 96);
                    int v170 = xmlRelaxNGNewValidState(v2, v17);
                    *(void *)(v2 + 96) = v170;
                    *(void *)(v2 + 104) = 0;
                    int v171 = xmlRelaxNGValidateCompiledContent((_DWORD *)v2, *(xmlRegexpPtr *)(a2 + 104), v170[1]);
                    uint64_t v172 = *(void *)(*(void *)(v2 + 96) + 8);
                    *(_OWORD *)(v2 + 96) = v207;
                    xmlRelaxNGFreeValidState((_DWORD *)v2, (uint64_t)v170);
                    if (v171) {
                      uint64_t v7 = 0xFFFFFFFFLL;
                    }
                    else {
                      uint64_t v7 = v7;
                    }
                    long long v173 = *(int **)(v2 + 104);
                    if (v173)
                    {
                      int v22 = v169;
                      uint64_t v24 = v168;
                      int v21 = v204;
                      if (*v173 < 1)
                      {
LABEL_324:
                        *(_DWORD *)(v2 + 56) |= 1u;
                        xmlRelaxNGLogBestError(v2);
                        char v176 = 1;
                      }
                      else
                      {
                        uint64_t v174 = 0;
                        while (1)
                        {
                          uint64_t v175 = *(void *)(*((void *)v173 + 1) + 8 * v174);
                          *(void *)(v2 + 96) = v175;
                          *(void *)(v175 + 8) = v172;
                          if (!xmlRelaxNGValidateElementEnd(v2, 0)) {
                            break;
                          }
                          ++v174;
                          long long v173 = *(int **)(v2 + 104);
                          if (v174 >= *v173) {
                            goto LABEL_324;
                          }
                        }
                        char v176 = 0;
                      }
                      long long v185 = *(int **)(v2 + 104);
                      if (*v185 >= 1)
                      {
                        uint64_t v186 = 0;
                        do
                        {
                          xmlRelaxNGFreeValidState((_DWORD *)v2, *(void *)(*((void *)v185 + 1) + 8 * v186++));
                          long long v185 = *(int **)(v2 + 104);
                        }
                        while (v186 < *v185);
                      }
                      goto LABEL_381;
                    }
                    uint64_t v184 = *v5;
                    if (*v5) {
                      *(void *)(v184 + 8) = v172;
                    }
                    int v22 = v169;
                    if (v7)
                    {
                      uint64_t v7 = 0xFFFFFFFFLL;
                      uint64_t v24 = v168;
                      int v21 = v204;
LABEL_376:
                      xmlRelaxNGFreeValidState((_DWORD *)v2, v184);
                      goto LABEL_386;
                    }
                    uint64_t v24 = v168;
                    int v21 = v204;
                  }
                  else
                  {
                    uint64_t v177 = *(void *)(a2 + 48);
                    if (v177 && xmlRelaxNGValidateDefinitionList(v2, v177))
                    {
                      if (*v5)
                      {
                        xmlRelaxNGAddValidError(v2, 25, *(xmlChar **)(v17 + 16), 0, 0);
                      }
                      else
                      {
                        *(void *)(v2 + 96) = v24;
                        xmlRelaxNGAddValidError(v2, 25, *(xmlChar **)(v17 + 16), 0, 0);
                        *(void *)(v2 + 96) = 0;
                      }
                      uint64_t v7 = 0xFFFFFFFFLL;
                    }
                    long long v188 = *(int **)(v2 + 104);
                    if (v188)
                    {
                      if (*v188 < 1)
                      {
LABEL_372:
                        *(_DWORD *)(v2 + 56) |= 1u;
                        xmlRelaxNGLogBestError(v2);
                        char v176 = 1;
                      }
                      else
                      {
                        uint64_t v189 = 0;
                        while (1)
                        {
                          *(void *)(v2 + 96) = *(void *)(*((void *)v188 + 1) + 8 * v189);
                          if (!xmlRelaxNGValidateElementEnd(v2, 0)) {
                            break;
                          }
                          ++v189;
                          long long v188 = *(int **)(v2 + 104);
                          if (v189 >= *v188) {
                            goto LABEL_372;
                          }
                        }
                        char v176 = 0;
                      }
                      long long v185 = *(int **)(v2 + 104);
                      if (*v185 >= 1)
                      {
                        uint64_t v190 = 0;
                        do
                        {
                          xmlRelaxNGFreeValidState((_DWORD *)v2, *(void *)(*((void *)v185 + 1) + 8 * v190));
                          *(void *)(*(void *)(*(void *)(v2 + 104) + 8) + 8 * v190++) = 0;
                          long long v185 = *(int **)(v2 + 104);
                        }
                        while (v190 < *v185);
                      }
LABEL_381:
                      xmlRelaxNGFreeStates((void *)v2, (uint64_t)v185);
                      *(void *)(v2 + 104) = 0;
                      if (v7) {
                        char v191 = 0;
                      }
                      else {
                        char v191 = v176;
                      }
                      if (v191)
                      {
                        char v192 = 0;
                        uint64_t v7 = 0xFFFFFFFFLL;
LABEL_389:
                        *(_DWORD *)(v2 + 56) = v21;
                        *(void *)(v2 + 96) = v24;
                        if (v24) {
                          *(void *)(v24 + 8) = xmlRelaxNGSkipIgnored(v2, *(void *)(v17 + 48));
                        }
                        if ((v192 & 1) == 0)
                        {
                          if (v21) {
                            goto LABEL_252;
                          }
                          xmlRelaxNGDumpValidError(v2);
                          goto LABEL_233;
                        }
                        if (*(_DWORD *)(v2 + 80) <= v22)
                        {
LABEL_233:
                          uint64_t v7 = 0;
LABEL_252:
                          --*(_DWORD *)(v2 + 60);
                          return v7;
                        }
                        uint64_t v126 = v2;
                        int v127 = v22;
LABEL_232:
                        xmlRelaxNGPopErrors(v126, v127);
                        goto LABEL_233;
                      }
LABEL_386:
                      if (v7)
                      {
                        char v192 = 0;
                      }
                      else
                      {
                        *(void *)(v17 + 104) = a2;
                        char v192 = 1;
                      }
                      goto LABEL_389;
                    }
                    uint64_t v184 = *v5;
                    if (v7)
                    {
                      uint64_t v7 = 0xFFFFFFFFLL;
                      goto LABEL_376;
                    }
                  }
                  uint64_t v7 = xmlRelaxNGValidateElementEnd(v2, 1);
                  goto LABEL_376;
                }
              }
              goto LABEL_209;
            }
            *((void *)v4 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = xmlRelaxNGSkipIgnored(v2, *(void *)(v16 + 48));
            if (!v7) {
              goto LABEL_252;
            }
            int v136 = *(const xmlChar ***)(v2 + 72);
            if (!v136) {
              goto LABEL_233;
            }
            while (1)
            {
              int v137 = *(_DWORD *)v136;
              if (*(_DWORD *)v136 == 13)
              {
                if (xmlStrEqual(v136[4], *(const xmlChar **)(v17 + 16))) {
                  goto LABEL_247;
                }
                int v136 = *(const xmlChar ***)(v2 + 72);
                int v137 = *(_DWORD *)v136;
              }
              if (v137 != 19) {
                goto LABEL_246;
              }
              if (!xmlStrEqual(v136[3], *(const xmlChar **)(v17 + 16)))
              {
                int v137 = **(_DWORD **)(v2 + 72);
LABEL_246:
                if ((v137 & 0xFFFFFFFE) != 0x16) {
                  goto LABEL_233;
                }
              }
LABEL_247:
              xmlRelaxNGValidErrorPop(v2);
              uint64_t v7 = 0;
              int v136 = *(const xmlChar ***)(v2 + 72);
              if (!v136) {
                goto LABEL_252;
              }
            }
          }
          uint64_t v99 = v2;
          int v100 = 23;
          uint64_t v98 = 0;
        }
        else
        {
          uint64_t v98 = *(xmlChar **)(a2 + 16);
          uint64_t v99 = v2;
          int v100 = 22;
        }
        xmlRelaxNGAddValidError(v99, v100, v98, 0, 0);
LABEL_209:
        if ((*(unsigned char *)(v2 + 56) & 1) == 0) {
          xmlRelaxNGDumpValidError(v2);
        }
LABEL_251:
        uint64_t v7 = 0xFFFFFFFFLL;
        goto LABEL_252;
      case 5:
        if (!v6) {
          goto LABEL_47;
        }
        int v26 = 0;
        uint64_t v27 = v6;
        do
        {
          int v28 = *(_DWORD *)(v27 + 8);
          if ((v28 - 3) >= 2)
          {
            if (v28 == 1)
            {
              uint64_t v128 = *(xmlChar **)(*(void *)(v6 + 40) + 16);
              uint64_t v129 = v2;
              int v130 = 28;
              goto LABEL_226;
            }
          }
          else
          {
            int v26 = xmlStrcat(v26, *(const xmlChar **)(v27 + 80));
          }
          uint64_t v27 = *(void *)(v27 + 48);
        }
        while (v27);
        if (!v26)
        {
LABEL_47:
          int v26 = xmlStrdup((const xmlChar *)"");
          if (!v26) {
            goto LABEL_155;
          }
        }
        uint64_t v29 = xmlRelaxNGValidateDatatype(v2, v26, a2, *(void *)(*(void *)(v2 + 96) + 8));
        uint64_t v7 = v29;
        if (!v29)
        {
          uint64_t v38 = *v5;
          goto LABEL_218;
        }
        if (v29 != -1) {
          goto LABEL_219;
        }
        int v30 = *(xmlChar **)(a2 + 16);
        uint64_t v31 = v2;
        int v32 = 31;
        goto LABEL_216;
      case 7:
        if (!v6) {
          goto LABEL_58;
        }
        int v26 = 0;
        uint64_t v33 = v6;
        do
        {
          int v34 = *(_DWORD *)(v33 + 8);
          if ((v34 - 3) >= 2)
          {
            if (v34 == 1)
            {
              uint64_t v128 = *(xmlChar **)(*(void *)(v6 + 40) + 16);
              uint64_t v129 = v2;
              int v130 = 29;
              goto LABEL_226;
            }
          }
          else
          {
            int v26 = xmlStrcat(v26, *(const xmlChar **)(v33 + 80));
          }
          uint64_t v33 = *(void *)(v33 + 48);
        }
        while (v33);
        if (!v26)
        {
LABEL_58:
          int v26 = xmlStrdup((const xmlChar *)"");
          if (!v26) {
            goto LABEL_155;
          }
        }
        uint64_t v35 = *(void *)(v2 + 96);
        uint64_t v36 = *(void *)(v35 + 32);
        *(void *)(v35 + 32) = v26;
        uint64_t v37 = xmlRelaxNGValidateValue(v2, a2);
        uint64_t v7 = v37;
        uint64_t v38 = *(void *)(v2 + 96);
        *(void *)(v38 + 32) = v36;
        if (!v37)
        {
LABEL_218:
          *(void *)(v38 + 8) = 0;
          goto LABEL_219;
        }
        if (v37 != -1) {
          goto LABEL_219;
        }
        int v30 = *(xmlChar **)(a2 + 16);
        uint64_t v31 = v2;
        int v32 = 32;
        goto LABEL_216;
      case 8:
        if (!v6) {
          goto LABEL_69;
        }
        int v26 = 0;
        uint64_t v39 = v6;
        do
        {
          int v40 = *(_DWORD *)(v39 + 8);
          if ((v40 - 3) >= 2)
          {
            if (v40 == 1)
            {
              uint64_t v128 = *(xmlChar **)(*(void *)(v6 + 40) + 16);
              uint64_t v129 = v2;
              int v130 = 30;
LABEL_226:
              xmlRelaxNGAddValidError(v129, v130, v128, 0, 0);
              if (v26) {
                xmlFree(v26);
              }
              goto LABEL_251;
            }
          }
          else
          {
            int v26 = xmlStrcat(v26, *(const xmlChar **)(v39 + 80));
          }
          uint64_t v39 = *(void *)(v39 + 48);
        }
        while (v39);
        if (!v26)
        {
LABEL_69:
          int v26 = xmlStrdup((const xmlChar *)"");
          if (!v26)
          {
LABEL_155:
            xmlRngVErrMemory(v2, (const xmlChar *)"validating\n");
            goto LABEL_251;
          }
        }
        int v41 = xmlStrlen(v26);
        uint64_t v42 = *(void *)(v2 + 96);
        long long v205 = *(_OWORD *)(v42 + 32);
        *(void *)(v42 + 32) = v26;
        *(void *)(v42 + 40) = &v26[v41];
        uint64_t v43 = xmlRelaxNGValidateValue(v2, a2);
        uint64_t v7 = v43;
        uint64_t v44 = *(void *)(v2 + 96);
        *(_OWORD *)(v44 + 32) = v205;
        if (v43 == -1)
        {
          uint64_t v31 = v2;
          int v32 = 33;
          int v30 = 0;
LABEL_216:
          xmlRelaxNGAddValidError(v31, v32, v30, 0, 0);
        }
        else if (!v43 && v6)
        {
          *(void *)(v44 + 8) = *(void *)(v6 + 48);
        }
LABEL_219:
        ((void (*)(xmlChar *))xmlFree)(v26);
        goto LABEL_252;
      case 9:
        uint64_t v9 = xmlRelaxNGValidateAttribute(a1, a2);
        goto LABEL_75;
      case 0xA:
      case 0x12:
        uint64_t v9 = xmlRelaxNGValidateDefinitionList(a1, *(void *)(a2 + 48));
        goto LABEL_75;
      case 0xE:
        int v45 = *(_DWORD *)(a1 + 80);
        int v46 = *(_DWORD *)(a1 + 56);
        *(_DWORD *)(a1 + 56) = v46 | 1;
        uint64_t v47 = xmlRelaxNGCopyValidState(a1, v4);
        if (xmlRelaxNGValidateDefinitionList(v2, *(void *)(a2 + 48)))
        {
          if (*v5) {
            xmlRelaxNGFreeValidState((_DWORD *)v2, *v5);
          }
          *(void *)(v2 + 96) = v47;
        }
        else
        {
          uint64_t v101 = *(int **)(v2 + 104);
          if (v101)
          {
            xmlRelaxNGAddStates((_DWORD *)v2, v101, (uint64_t)v47);
          }
          else
          {
            int v131 = (int *)xmlRelaxNGNewStates(v2, 1);
            *(void *)(v2 + 104) = v131;
            if (!v131)
            {
              xmlRelaxNGFreeValidState((_DWORD *)v2, (uint64_t)v47);
              *(_DWORD *)(v2 + 56) = v46;
              if (*(_DWORD *)(v2 + 80) > v45) {
                xmlRelaxNGPopErrors(v2, v45);
              }
              goto LABEL_251;
            }
            xmlRelaxNGAddStates((_DWORD *)v2, v131, (uint64_t)v47);
            xmlRelaxNGAddStates((_DWORD *)v2, *(int **)(v2 + 104), *(void *)(v2 + 96));
            *(void *)(v2 + 96) = 0;
          }
        }
        *(_DWORD *)(v2 + 56) = v46;
        if (*(_DWORD *)(v2 + 80) <= v45) {
          goto LABEL_233;
        }
        uint64_t v126 = v2;
        int v127 = v45;
        goto LABEL_232;
      case 0xF:
        goto LABEL_83;
      case 0x10:
        int v48 = *(_DWORD *)(a1 + 80);
        if (xmlRelaxNGValidateDefinitionList(a1, *(void *)(a2 + 48))) {
          goto LABEL_251;
        }
        if (*(_DWORD *)(v2 + 80) > v48) {
          xmlRelaxNGPopErrors(v2, v48);
        }
LABEL_83:
        int v49 = (int *)xmlRelaxNGNewStates(v2, 1);
        if (!v49) {
          goto LABEL_251;
        }
        int v50 = v49;
        if (*v5)
        {
          xmlURIPtr v51 = xmlRelaxNGCopyValidState(v2, (long long *)*v5);
          xmlRelaxNGAddStates((_DWORD *)v2, v50, (uint64_t)v51);
        }
        else
        {
          int v104 = *(int **)(v2 + 104);
          if (*v104 >= 1)
          {
            uint64_t v105 = 0;
            do
            {
              int v106 = xmlRelaxNGCopyValidState(v2, *(long long **)(*((void *)v104 + 1) + 8 * v105));
              xmlRelaxNGAddStates((_DWORD *)v2, v50, (uint64_t)v106);
              ++v105;
              int v104 = *(int **)(v2 + 104);
            }
            while (v105 < *v104);
          }
        }
        uint64_t v107 = 0;
        int v61 = *(_DWORD *)(v2 + 56);
        *(_DWORD *)(v2 + 56) = v61 | 1;
        while (2)
        {
          int v108 = *(int **)(v2 + 104);
          if (v108)
          {
            if (*v108 < 1) {
              goto LABEL_257;
            }
            uint64_t v109 = 0;
            int v110 = 0;
            int v111 = *v50;
            do
            {
              *(void *)(v2 + 96) = *(void *)(*((void *)v108 + 1) + 8 * v109);
              *(void *)(v2 + 104) = 0;
              int v112 = xmlRelaxNGValidateDefinitionList(v2, *(void *)(a2 + 48));
              uint64_t v113 = *(void *)(v2 + 96);
              if (v112)
              {
                if (v113)
                {
                  xmlRelaxNGFreeValidState((_DWORD *)v2, *(void *)(v2 + 96));
                  *(void *)(v2 + 96) = 0;
                }
              }
              else if (v113)
              {
                int v114 = xmlRelaxNGAddStates((_DWORD *)v2, v50, v113);
                *(void *)(v2 + 96) = 0;
                if (v114 == 1) {
                  int v110 = 1;
                }
              }
              else
              {
                uint64_t v115 = *(int **)(v2 + 104);
                if (v115)
                {
                  if (*v115 >= 1)
                  {
                    uint64_t v116 = 0;
                    do
                    {
                      if (xmlRelaxNGAddStates((_DWORD *)v2, v50, *(void *)(*((void *)v115 + 1) + 8 * v116)) == 1)int v110 = 1; {
                      ++v116;
                      }
                      uint64_t v115 = *(int **)(v2 + 104);
                    }
                    while (v116 < *v115);
                  }
                  xmlRelaxNGFreeStates((void *)v2, (uint64_t)v115);
                  *(void *)(v2 + 104) = 0;
                }
              }
              ++v109;
            }
            while (v109 < *v108);
            uint64_t v107 = v108;
            if (!v110)
            {
LABEL_257:
              xmlRelaxNGFreeStates((void *)v2, (uint64_t)v108);
              goto LABEL_258;
            }
LABEL_199:
            int v123 = *v50 - v111;
            if (v123 == 1)
            {
              *(void *)(v2 + 96) = xmlRelaxNGCopyValidState(v2, *(long long **)(*((void *)v50 + 1) + 8 * v111));
              continue;
            }
            if (v107 || (xmlRelaxNGNewStates(v2, v123), (uint64_t v107 = *(int **)(v2 + 104)) != 0))
            {
              *uint64_t v107 = 0;
              if (v111 < *v50)
              {
                uint64_t v124 = v111;
                do
                {
                  unsigned int v125 = xmlRelaxNGCopyValidState(v2, *(long long **)(*((void *)v50 + 1) + 8 * v124));
                  xmlRelaxNGAddStates((_DWORD *)v2, v107, (uint64_t)v125);
                  ++v124;
                }
                while (v124 < *v50);
              }
              *(void *)(v2 + 104) = v107;
              continue;
            }
LABEL_258:
            uint64_t v7 = 0;
            *(void *)(v2 + 104) = v50;
LABEL_259:
            *(_DWORD *)(v2 + 56) = v61;
            goto LABEL_252;
          }
          break;
        }
        int v117 = xmlRelaxNGValidateDefinitionList(v2, *(void *)(a2 + 48));
        uint64_t v118 = *(void *)(v2 + 96);
        if (v117)
        {
          xmlRelaxNGFreeValidState((_DWORD *)v2, *(void *)(v2 + 96));
          *(void *)(v2 + 96) = 0;
        }
        else
        {
          int v111 = *v50;
          if (v118)
          {
            int v119 = xmlRelaxNGAddStates((_DWORD *)v2, v50, v118);
            *(void *)(v2 + 96) = 0;
            if (v119 == 1) {
              goto LABEL_199;
            }
          }
          else
          {
            uint64_t v120 = *(int **)(v2 + 104);
            if (v120)
            {
              if (*v120 < 1)
              {
                int v122 = 0;
              }
              else
              {
                uint64_t v121 = 0;
                int v122 = 0;
                do
                {
                  if (xmlRelaxNGAddStates((_DWORD *)v2, v50, *(void *)(*((void *)v120 + 1) + 8 * v121)) == 1)int v122 = 1; {
                  ++v121;
                  }
                  uint64_t v120 = *(int **)(v2 + 104);
                }
                while (v121 < *v120);
              }
              if (v107) {
                xmlRelaxNGFreeStates((void *)v2, (uint64_t)v120);
              }
              else {
                uint64_t v107 = v120;
              }
              *(void *)(v2 + 104) = 0;
              int v108 = v107;
              if (!v122) {
                goto LABEL_257;
              }
              goto LABEL_199;
            }
          }
        }
        int v108 = v107;
        if (!v107) {
          goto LABEL_258;
        }
        goto LABEL_257;
      case 0x11:
        uint64_t v52 = xmlRelaxNGSkipIgnored(a1, v6);
        int v53 = *(_DWORD *)(v2 + 80);
        if ((*(_WORD *)(a2 + 98) & 0x10) != 0)
        {
          int v54 = *(xmlHashTable **)(a2 + 40);
          if (v54)
          {
            uint64_t v55 = v52;
            if (v52)
            {
              int v56 = *(_DWORD *)(v52 + 8);
              if ((v56 - 3) >= 2)
              {
                if (v56 != 1)
                {
LABEL_249:
                  int v103 = *(xmlChar **)(v55 + 16);
                  a1 = v2;
                  int v102 = 38;
                  goto LABEL_250;
                }
                uint64_t v132 = *(void *)(v52 + 72);
                int v133 = *(const xmlChar **)(v52 + 16);
                if (v132)
                {
                  unsigned int v8 = xmlHashLookup2(*(xmlHashTablePtr *)(a2 + 40), v133, *(const xmlChar **)(v132 + 16));
                  if (v8) {
                    goto LABEL_8;
                  }
                  uint64_t v134 = *(const xmlChar **)(*(void *)(v55 + 72) + 16);
                  int v133 = (const xmlChar *)"#any";
                  int v135 = v54;
                }
                else
                {
                  int v135 = *(xmlHashTable **)(a2 + 40);
                  uint64_t v134 = 0;
                }
                unsigned int v8 = xmlHashLookup2(v135, v133, v134);
                if (v8)
                {
LABEL_8:
                  uint64_t v9 = xmlRelaxNGValidateDefinition(v2, v8);
LABEL_75:
                  uint64_t v7 = v9;
                  goto LABEL_252;
                }
                uint64_t v57 = "#any";
              }
              else
              {
                uint64_t v57 = "#text";
              }
              unsigned int v8 = xmlHashLookup2(v54, (const xmlChar *)v57, 0);
              if (!v8) {
                goto LABEL_249;
              }
              goto LABEL_8;
            }
          }
        }
        uint64_t v66 = *(void *)(a2 + 48);
        int v67 = *(_DWORD *)(v2 + 56);
        *(_DWORD *)(v2 + 56) = v67 | 1;
        int v68 = (int **)(v2 + 104);
        if (v66)
        {
          uint64_t v69 = 0;
          do
          {
            int v4 = (long long *)xmlRelaxNGCopyValidState(v2, v4);
            uint64_t v7 = xmlRelaxNGValidateDefinition(v2, v66);
            if (v7)
            {
              xmlRelaxNGFreeValidState((_DWORD *)v2, *(void *)(v2 + 96));
            }
            else
            {
              if (!v69) {
                uint64_t v69 = (int *)xmlRelaxNGNewStates(v2, 1);
              }
              if (*v5)
              {
                xmlRelaxNGAddStates((_DWORD *)v2, v69, *v5);
              }
              else
              {
                xmlDocPtr v70 = *v68;
                if (*v68)
                {
                  if (*v70 >= 1)
                  {
                    uint64_t v71 = 0;
                    do
                    {
                      xmlRelaxNGAddStates((_DWORD *)v2, v69, *(void *)(*((void *)v70 + 1) + 8 * v71++));
                      xmlDocPtr v70 = *(int **)(v2 + 104);
                    }
                    while (v71 < *v70);
                  }
                  xmlRelaxNGFreeStates((void *)v2, (uint64_t)v70);
                  *(void *)(v2 + 104) = 0;
                }
              }
            }
            *BOOL v5 = (uint64_t)v4;
            uint64_t v66 = *(void *)(v66 + 64);
          }
          while (v66);
          if (!v69)
          {
            *(void *)(v2 + 104) = 0;
            *(_DWORD *)(v2 + 56) = v67;
            if (v7)
            {
              if ((v67 & 1) == 0) {
                xmlRelaxNGDumpValidError(v2);
              }
              goto LABEL_252;
            }
            goto LABEL_213;
          }
          xmlRelaxNGFreeValidState((_DWORD *)v2, (uint64_t)v4);
          *(void *)(v2 + 104) = v69;
        }
        else
        {
          BOOL v5 = (uint64_t *)(v2 + 104);
        }
        *BOOL v5 = 0;
        *(_DWORD *)(v2 + 56) = v67;
LABEL_213:
        if (*(_DWORD *)(v2 + 80) <= v53) {
          goto LABEL_233;
        }
        uint64_t v126 = v2;
        int v127 = v53;
        goto LABEL_232;
      case 0x13:
        unsigned int v58 = *(int **)(a2 + 40);
        if (!v58)
        {
          int v102 = 10;
          int v103 = 0;
LABEL_250:
          xmlRelaxNGAddValidError(a1, v102, v103, 0, 0);
          goto LABEL_251;
        }
        int v59 = *(_DWORD *)(a1 + 80);
        uint64_t v60 = *v58;
        int v61 = *(_DWORD *)(a1 + 56);
        long long v206 = *(int **)(a2 + 40);
        if ((*(_WORD *)(a2 + 98) & 8) != 0)
        {
          *(_DWORD *)(a1 + 56) = v61 | 4;
          if (v60 == 2)
          {
            if (v4)
            {
              uint64_t v62 = xmlRelaxNGSkipIgnored(a1, *((void *)v4 + 1));
              unsigned int v58 = v206;
              *((void *)v4 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v62;
            }
            unsigned int v63 = (void **)*((void *)v58 + 3);
            unsigned int v64 = (_DWORD *)**v63;
            if (*v64 == 3) {
              unsigned int v64 = (_DWORD *)*v63[1];
            }
            uint64_t v7 = xmlRelaxNGValidateDefinition(v2, v64);
            if (!v7 && *v5)
            {
              uint64_t v65 = *v5;
              *(void *)(v65 + 8) = xmlRelaxNGSkipIgnored(v2, *(void *)(v65 + 8));
            }
            goto LABEL_259;
          }
        }
        int v201 = v59;
        char v72 = xmlMalloc(8 * v60);
        if (!v72) {
          goto LABEL_155;
        }
        int v73 = v72;
        bzero(v72, 8 * v60);
        long long v74 = xmlMalloc(8 * v60);
        if (!v74) {
          goto LABEL_155;
        }
        uint64_t v75 = v74;
        bzero(v74, 8 * v60);
        uint64_t v76 = *(void *)(v2 + 96);
        uint64_t v77 = xmlRelaxNGSkipIgnored(v2, *(void *)(v76 + 8));
        long long v202 = v75;
        uint64_t v195 = v77;
        if (!v77)
        {
          uint64_t v79 = 0;
          uint64_t v200 = 0;
          goto LABEL_261;
        }
        uint64_t v78 = v73;
        uint64_t v200 = 0;
        uint64_t v79 = v77;
        break;
      default:
        goto LABEL_252;
    }
    while (1)
    {
      *(void *)(*v5 + 8) = v79;
      uint64_t v80 = v206;
      int v81 = (xmlHashTable *)*((void *)v206 + 1);
      uint64_t v82 = v79;
      if (!v81 || (v206[4] & 1) == 0)
      {
        if ((int)v60 < 1)
        {
          LODWORD(v8xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0;
        }
        else
        {
          uint64_t v83 = 0;
          while (1)
          {
            uint64_t v84 = *(void *)(*((void *)v80 + 3) + 8 * v83);
            if (v84)
            {
              int v85 = xmlRelaxNGNodeMatchesList(v79, *(void ***)(v84 + 8));
              uint64_t v79 = v82;
              uint64_t v80 = v206;
              if (v85) {
                break;
              }
            }
            if (v60 == ++v83) {
              goto LABEL_254;
            }
          }
        }
        goto LABEL_139;
      }
      int v86 = *(_DWORD *)(v79 + 8);
      if ((v86 - 3) < 2)
      {
        int v87 = "#text";
        goto LABEL_133;
      }
      if (v86 != 1) {
        goto LABEL_254;
      }
      uint64_t v95 = *(void *)(v79 + 72);
      unsigned int v96 = *(const xmlChar **)(v79 + 16);
      if (v95)
      {
        uint64_t v88 = xmlHashLookup2(v81, v96, *(const xmlChar **)(v95 + 16));
        long long v89 = v206;
        uint64_t v79 = v82;
        if (v88) {
          goto LABEL_134;
        }
        int v81 = (xmlHashTable *)*((void *)v206 + 1);
        uint64_t v97 = *(const xmlChar **)(*(void *)(v82 + 72) + 16);
        unsigned int v96 = (const xmlChar *)"#any";
      }
      else
      {
        uint64_t v97 = 0;
      }
      uint64_t v88 = xmlHashLookup2(v81, v96, v97);
      long long v89 = v206;
      uint64_t v79 = v82;
      if (!v88)
      {
        int v81 = (xmlHashTable *)*((void *)v206 + 1);
        int v87 = "#any";
LABEL_133:
        uint64_t v88 = xmlHashLookup2(v81, (const xmlChar *)v87, 0);
        long long v89 = v206;
        uint64_t v79 = v82;
        if (!v88) {
          goto LABEL_254;
        }
      }
LABEL_134:
      LODWORD(v8xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = v88 - 1;
      if ((v89[4] & 2) != 0)
      {
        int v90 = xmlRelaxNGNodeMatchesList(v79, *(void ***)(*(void *)(*((void *)v89 + 3) + 8 * (int)v83) + 8));
        uint64_t v79 = v82;
        if (!v90) {
          LODWORD(v8xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = v60;
        }
      }
LABEL_139:
      if ((int)v83 < (int)v60)
      {
        uint64_t v91 = v202[(int)v83];
        int v92 = v91 ? (uint64_t *)(v91 + 48) : &v78[(int)v83];
        *int v92 = v79;
        v202[(int)v83] = v79;
        uint64_t v93 = *(void *)(v79 + 48);
        uint64_t v94 = v93 ? *(void *)(v79 + 48) : v79;
        uint64_t v200 = v94;
        uint64_t v79 = xmlRelaxNGSkipIgnored(v2, v93);
        if (v79) {
          continue;
        }
      }
LABEL_254:
      uint64_t v76 = *v5;
      int v73 = v78;
      uint64_t v75 = v202;
LABEL_261:
      if ((int)v60 < 1)
      {
        char v167 = 1;
        uint64_t v141 = v76;
        goto LABEL_332;
      }
      int v194 = v61;
      uint64_t v139 = 0;
      uint64_t v203 = 0;
      uint64_t v60 = v60;
      uint64_t v193 = v79;
      uint64_t v140 = v79;
      uint64_t v141 = v76;
      uint64_t v196 = v60;
      int v197 = v73;
LABEL_263:
      long long v142 = xmlRelaxNGCopyValidState(v2, (long long *)v141);
      *(void *)(v2 + 96) = v142;
      if (v142)
      {
        long long v143 = *(void **)(*((void *)v206 + 3) + 8 * v139);
        uint64_t v144 = v75[v139];
        if (v144)
        {
          uint64_t v203 = *(void *)(v144 + 48);
          *(void *)(v144 + 48) = 0;
        }
        v142[1] = v73[v139];
        int v145 = xmlRelaxNGValidateDefinition(v2, *v143);
        uint64_t v76 = *(void *)(v2 + 96);
        if (!v145)
        {
          if (v76)
          {
            uint64_t v140 = xmlRelaxNGSkipIgnored(v2, *(void *)(v76 + 8));
            xmlRelaxNGFreeValidState((_DWORD *)v2, v141);
            uint64_t v141 = *(void *)(v2 + 96);
            *(void *)(v2 + 96) = 0;
            if (!v140) {
              goto LABEL_307;
            }
            uint64_t v146 = *(void *)(a2 + 56);
            if (*(_DWORD *)v146 == 10)
            {
              if (xmlStrEqual(*(const xmlChar **)(v146 + 16), (const xmlChar *)"open-name-class")) {
                goto LABEL_307;
              }
            }
            xmlRelaxNGAddValidError(v2, 12, *(xmlChar **)(v140 + 16), 0, 0);
            int v179 = 0;
            *(void *)(v2 + 96) = v141;
            uint64_t v7 = 0xFFFFFFFFLL;
            int v180 = v201;
            uint64_t v181 = v195;
            uint64_t v182 = v200;
            int v61 = v194;
            goto LABEL_338;
          }
          long long v147 = *(unsigned int **)(v2 + 104);
          if (!v147) {
            goto LABEL_325;
          }
          uint64_t v148 = *v147;
          if ((int)v148 <= 0)
          {
            xmlRelaxNGFreeStates((void *)v2, (uint64_t)v147);
            *(void *)(v2 + 104) = 0;
            int v73 = v197;
LABEL_360:
            if (v140) {
              long long v187 = *(xmlChar **)(v140 + 16);
            }
            else {
              long long v187 = (xmlChar *)"noname";
            }
            xmlRelaxNGAddValidError(v2, 12, v187, 0, 0);
            uint64_t v181 = v195;
            uint64_t v182 = v200;
            int v61 = v194;
            int v179 = 0;
            *BOOL v5 = v141;
            uint64_t v7 = 0xFFFFFFFFLL;
            int v180 = v201;
LABEL_338:
            *(_DWORD *)(v2 + 56) = v61;
            if (v182 && v182 != v181)
            {
              do
              {
                uint64_t v183 = *(void *)(v182 + 56);
                if (!v183) {
                  break;
                }
                *(void *)(v183 + 48) = v182;
                uint64_t v182 = v183;
              }
              while (v183 != v181);
            }
            if (v179 && *(_DWORD *)(v2 + 80) > v180) {
              xmlRelaxNGPopErrors(v2, v180);
            }
            xmlFree(v73);
            ((void (*)(void *))xmlFree)(v75);
            goto LABEL_252;
          }
          uint64_t v198 = v139;
          uint64_t v199 = v141;
          uint64_t v149 = 0;
          int v150 = 0;
          uint64_t v151 = *((void *)v147 + 1);
          int v152 = -1;
          int v153 = -1;
          while (1)
          {
            uint64_t v154 = *(void *)(v151 + 8 * v149);
            uint64_t v155 = xmlRelaxNGSkipIgnored(v2, *(void *)(v154 + 8));
            if (v155)
            {
              if (v150)
              {
                int v150 = 1;
              }
              else
              {
                int v159 = *(_DWORD *)(v154 + 24);
                if (v152 == -1)
                {
                  int v150 = 0;
                  int v153 = v149;
                  int v152 = *(_DWORD *)(v154 + 24);
                }
                else
                {
                  int v150 = 0;
                  if (v159 <= v152) {
                    int v153 = v149;
                  }
                  if (v159 < v152) {
                    int v152 = *(_DWORD *)(v154 + 24);
                  }
                }
              }
            }
            else
            {
              int v156 = *(_DWORD *)(v154 + 24);
              if (v150) {
                int v157 = v153;
              }
              else {
                int v157 = v149;
              }
              if (v150) {
                int v158 = v152;
              }
              else {
                int v158 = *(_DWORD *)(v154 + 24);
              }
              if (v156 <= v158) {
                int v153 = v149;
              }
              else {
                int v153 = v157;
              }
              if (v156 >= v158) {
                int v152 = v158;
              }
              else {
                int v152 = *(_DWORD *)(v154 + 24);
              }
              int v150 = 1;
              if (!v152)
              {
LABEL_300:
                uint64_t v140 = v155;
                xmlRelaxNGFreeValidState((_DWORD *)v2, v199);
                long long v160 = *(int **)(v2 + 104);
                uint64_t v161 = *((void *)v160 + 1);
                if (v153 == -1)
                {
                  uint64_t v164 = v161 + 8 * *v160;
                  uint64_t v141 = *(void *)(v164 - 8);
                  *(void *)(v164 - 8) = 0;
                  long long v162 = *(int **)(v2 + 104);
                  int v163 = *v162 - 1;
                  *long long v162 = v163;
                }
                else
                {
                  uint64_t v141 = *(void *)(v161 + 8 * v153);
                  *(void *)(v161 + 8 * v15xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0;
                  long long v162 = *(int **)(v2 + 104);
                  int v163 = *v162;
                }
                uint64_t v60 = v196;
                int v73 = v197;
                uint64_t v75 = v202;
                if (v163 >= 1)
                {
                  uint64_t v165 = 0;
                  do
                  {
                    xmlRelaxNGFreeValidState((_DWORD *)v2, *(void *)(*((void *)v162 + 1) + 8 * v165++));
                    long long v162 = *(int **)(v2 + 104);
                  }
                  while (v165 < *v162);
                }
                xmlRelaxNGFreeStates((void *)v2, (uint64_t)v162);
                *(void *)(v2 + 104) = 0;
                uint64_t v139 = v198;
                if (!v150) {
                  goto LABEL_360;
                }
LABEL_307:
                uint64_t v166 = v75[v139];
                if (v166) {
                  *(void *)(v166 + 48) = v203;
                }
                if (++v139 == v60)
                {
                  uint64_t v76 = *v5;
                  char v167 = 1;
                  goto LABEL_331;
                }
                goto LABEL_263;
              }
            }
            if (v148 == ++v149) {
              goto LABEL_300;
            }
          }
        }
        char v167 = 0;
LABEL_331:
        uint64_t v79 = v193;
        int v61 = v194;
LABEL_332:
        if (v76)
        {
          uint64_t v178 = v79;
          xmlRelaxNGFreeValidState((_DWORD *)v2, v76);
          uint64_t v79 = v178;
        }
        *BOOL v5 = v141;
        *(void *)(v141 + 8) = v79;
        if (v167)
        {
          uint64_t v7 = 0;
          int v179 = 1;
LABEL_337:
          int v180 = v201;
          uint64_t v181 = v195;
          uint64_t v182 = v200;
          goto LABEL_338;
        }
      }
      else
      {
LABEL_325:
        *BOOL v5 = v141;
        *(void *)(v141 + 8) = v193;
        int v61 = v194;
      }
      xmlRelaxNGAddValidError(v2, 11, 0, 0, 0);
      int v179 = 0;
      uint64_t v7 = 0xFFFFFFFFLL;
      goto LABEL_337;
    }
  }
  xmlRelaxNGAddValidError(a1, 7, 0, 0, 0);
  return 0xFFFFFFFFLL;
}

uint64_t xmlRelaxNGAddStates(_DWORD *a1, int *a2, uint64_t a3)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 && a3)
  {
    int v7 = *a2;
    uint64_t v8 = a2[1];
    if (*a2 >= (int)v8)
    {
      uint64_t v9 = xmlRealloc(*((void **)a2 + 1), 16 * v8);
      if (!v9)
      {
        xmlRngVErrMemory((uint64_t)a1, (const xmlChar *)"adding states\n");
        return 0xFFFFFFFFLL;
      }
      *((void *)a2 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v9;
      a2[1] = 2 * v8;
      int v7 = *a2;
    }
    if (v7 > 0)
    {
      uint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *(void *)(*((void *)a2 + 1) + 8 * v10);
        if (v11)
        {
          if (v11 == a3) {
            goto LABEL_24;
          }
          if (*(void *)a3 == *(void *)v11
            && *(void *)(a3 + 8) == *(void *)(v11 + 8)
            && *(_DWORD *)(a3 + 24) == *(_DWORD *)(v11 + 24))
          {
            uint64_t v12 = *(unsigned int *)(a3 + 16);
            if (v12 == *(_DWORD *)(v11 + 16) && *(void *)(a3 + 40) == *(void *)(v11 + 40))
            {
              BOOL v13 = *(const xmlChar **)(a3 + 32);
              int v14 = *(const xmlChar **)(v11 + 32);
              if (v13 != v14)
              {
                if (!xmlStrEqual(v13, v14)) {
                  goto LABEL_15;
                }
                uint64_t v12 = *(unsigned int *)(a3 + 16);
              }
              if ((int)v12 < 1)
              {
LABEL_24:
                xmlRelaxNGFreeValidState(a1, a3);
                return 0;
              }
              int v15 = *(void **)(a3 + 48);
              uint64_t v16 = *(void **)(v11 + 48);
              while (*v15 == *v16)
              {
                ++v16;
                ++v15;
                if (!--v12) {
                  goto LABEL_24;
                }
              }
            }
          }
        }
LABEL_15:
        ++v10;
        int v7 = *a2;
        if (v10 >= *a2)
        {
          uint64_t v17 = v7;
          goto LABEL_26;
        }
      }
    }
    uint64_t v17 = v7;
LABEL_26:
    uint64_t v18 = *((void *)a2 + 1);
    *a2 = v7 + 1;
    *(void *)(v18 + 8 * v17) = a3;
    return 1;
  }
  return result;
}

void xmlRelaxNGValidErrorPop(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 80);
  if (v1 <= 0)
  {
    *(void *)(a1 + 72) = 0;
  }
  else
  {
    unsigned int v2 = v1 - 1;
    *(_DWORD *)(a1 + 80) = v1 - 1;
    uint64_t v3 = *(void *)(a1 + 88);
    uint64_t v4 = v3 + 40 * (v1 - 2);
    if (v1 == 1) {
      uint64_t v4 = 0;
    }
    *(void *)(a1 + 72) = v4;
    uint64_t v5 = v3 + 40 * v2;
    char v7 = *(unsigned char *)(v5 + 4);
    uint64_t v6 = (_DWORD *)(v5 + 4);
    if (v7)
    {
      uint64_t v8 = v3 + 40 * v2;
      uint64_t v11 = *(void **)(v8 + 24);
      uint64_t v10 = (void *)(v8 + 24);
      uint64_t v9 = v11;
      if (v11) {
        xmlFree(v9);
      }
      *uint64_t v10 = 0;
      uint64_t v12 = v3 + 40 * v2;
      int v15 = *(void **)(v12 + 32);
      int v14 = (void *)(v12 + 32);
      BOOL v13 = v15;
      if (v15) {
        xmlFree(v13);
      }
      *int v14 = 0;
      *uint64_t v6 = 0;
    }
  }
}

uint64_t xmlRelaxNGValidateCompiledContent(_DWORD *data, xmlRegexpPtr comp, uint64_t a3)
{
  if (!comp) {
    return 0xFFFFFFFFLL;
  }
  int v5 = data[46];
  uint64_t v6 = xmlRegNewExecCtxt(comp, (xmlRegExecCallbacks)xmlRelaxNGValidateCompiledCallback, data);
  data[46] = 0;
  if (!a3) {
    goto LABEL_17;
  }
  while (1)
  {
    *(void *)(*((void *)data + 12) + 8) = a3;
    int v7 = *(_DWORD *)(a3 + 8);
    if ((v7 - 3) < 2)
    {
      if (!xmlIsBlankNode((const xmlNode *)a3) && xmlRegExecPushString(v6, (const xmlChar *)"#text", data) < 0)
      {
        a3 = *(void *)(a3 + 40);
        int v11 = 39;
        goto LABEL_16;
      }
      goto LABEL_12;
    }
    if (v7 != 1) {
      goto LABEL_12;
    }
    uint64_t v8 = *(void *)(a3 + 72);
    uint64_t v9 = *(const xmlChar **)(a3 + 16);
    if (!v8) {
      break;
    }
    if (xmlRegExecPushString2(v6, v9, *(const xmlChar **)(v8 + 16), data) < 0) {
      goto LABEL_15;
    }
LABEL_12:
    a3 = *(void *)(a3 + 48);
    if (!a3) {
      goto LABEL_17;
    }
  }
  if ((xmlRegExecPushString(v6, v9, data) & 0x80000000) == 0) {
    goto LABEL_12;
  }
LABEL_15:
  int v11 = 38;
LABEL_16:
  xmlRelaxNGAddValidError((uint64_t)data, v11, *(xmlChar **)(a3 + 16), 0, 0);
LABEL_17:
  int v12 = xmlRegExecPushString(v6, 0, 0);
  if (v12 == 1)
  {
    *(void *)(*((void *)data + 12) + 8) = 0;
    xmlRegFreeExecCtxt(v6);
    uint64_t result = data[46];
  }
  else
  {
    if (!v12)
    {
      xmlRelaxNGAddValidError((uint64_t)data, 22, (xmlChar *)"", 0, 0);
      if ((data[14] & 1) == 0) {
        xmlRelaxNGDumpValidError((uint64_t)data);
      }
    }
    xmlRegFreeExecCtxt(v6);
    uint64_t result = 0xFFFFFFFFLL;
  }
  data[46] = v5;
  return result;
}

uint64_t xmlRelaxNGValidateDefinitionList(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  if (a2)
  {
    uint64_t v3 = a2;
    LODWORD(v4) = 0;
    while (*(void *)(v2 + 96) || *(void *)(v2 + 104))
    {
      int v5 = xmlRelaxNGValidateDefinition(v2, v3);
      if (v5 < 0) {
        uint64_t v4 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v4 = v4;
      }
      if (v5 != -1)
      {
        uint64_t v3 = *(void *)(v3 + 64);
        if (v3) {
          continue;
        }
      }
      return v4;
    }
    a1 = v2;
    int v7 = 6;
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = (xmlChar *)"NULL definition list";
    int v7 = 37;
  }
  xmlRelaxNGAddValidError(a1, v7, v6, 0, 0);
  return 0xFFFFFFFFLL;
}

void *xmlRelaxNGCopyValidState(uint64_t a1, long long *a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 112);
  if (v4 && (unsigned int v5 = *(_DWORD *)v4 - 1, *(int *)v4 >= 1))
  {
    *(_DWORD *)uint64_t v4 = v5;
    uint64_t v6 = *(void **)(*(void *)(v4 + 8) + 8 * v5);
  }
  else
  {
    int v7 = xmlMalloc(0x38uLL);
    uint64_t v6 = v7;
    if (!v7)
    {
      xmlRngVErrMemory(a1, (const xmlChar *)"allocating states\n");
      return v6;
    }
    _OWORD v7[6] = 0;
    *((_OWORD *)v7 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0u;
    *((_OWORD *)v7 + 2) = 0u;
    *(_OWORD *)int v7 = 0u;
  }
  uint64_t v8 = (void *)v6[6];
  int v9 = *((_DWORD *)v6 + 5);
  long long v11 = a2[1];
  long long v10 = a2[2];
  long long v12 = *a2;
  v6[6] = *((void *)a2 + 6);
  *((_OWORD *)v6 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v11;
  *((_OWORD *)v6 + 2) = v10;
  *(_OWORD *)uint64_t v6 = v12;
  v6[6] = v8;
  *((_DWORD *)v6 + 5) = v9;
  int v13 = *((_DWORD *)a2 + 4);
  if (v13 >= 1)
  {
    if (v8)
    {
      if (v9 >= v13)
      {
LABEL_15:
        memcpy(v8, *((const void **)a2 + 6), 8 * *((int *)a2 + 4));
        return v6;
      }
      uint64_t v8 = xmlRealloc(v8, 8 * *((int *)a2 + 5));
      if (v8)
      {
        *((_DWORD *)v6 + 5) = *((_DWORD *)a2 + 5);
        v6[6] = v8;
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v14 = *((int *)a2 + 5);
      *((_DWORD *)v6 + 5) = v14;
      uint64_t v8 = xmlMalloc(8 * v14);
      v6[6] = v8;
      if (v8) {
        goto LABEL_15;
      }
    }
    xmlRngVErrMemory(a1, (const xmlChar *)"allocating states\n");
    *((_DWORD *)v6 + 4) = 0;
  }
  return v6;
}

void xmlRelaxNGValidateCompiledCallback(uint64_t a1, const char *a2, _DWORD *a3, uint64_t a4)
{
  if (!a4)
  {
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "callback on %s missing context\n", a2);
    return;
  }
  if (a3)
  {
    if (*a3 == 4)
    {
      int v5 = xmlRelaxNGValidateDefinition(a4, a3);
      if (v5) {
        *(_DWORD *)(a4 + 184) = v5;
      }
      return;
    }
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "callback on %s define is not element\n");
  }
  else
  {
    if (*a2 == 35) {
      return;
    }
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "callback on %s missing define\n");
  }
  if (!*(_DWORD *)(a4 + 68)) {
    *(_DWORD *)(a4 + 68) = 37;
  }
}

uint64_t xmlRelaxNGNodeMatchesList(uint64_t a1, void **a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v3 = *a2;
  if (!v3) {
    return 0;
  }
  for (uint64_t i = a2 + 1; ; ++i)
  {
    int v6 = *(_DWORD *)(a1 + 8);
    if (v6 != 1) {
      break;
    }
    if (*(_DWORD *)v3 == 4)
    {
      uint64_t result = xmlRelaxNGElementMatch(0, v3, a1);
      if (result == 1) {
        return result;
      }
    }
LABEL_11:
    int v9 = (void *)*i;
    uint64_t v3 = v9;
    if (!v9) {
      return 0;
    }
  }
  if ((v6 - 3) > 1) {
    goto LABEL_11;
  }
  unsigned int v8 = *(_DWORD *)v3 - 3;
  if (v8 >= 6 || ((0x35u >> v8) & 1) == 0) {
    goto LABEL_11;
  }
  return 1;
}

const xmlChar *__cdecl xmlSAX2GetPublicId(void *ctx)
{
  return 0;
}

const xmlChar *__cdecl xmlSAX2GetSystemId(const xmlChar *ctx)
{
  if (ctx)
  {
    uint64_t v1 = *((void *)ctx + 7);
    if (v1) {
      return *(const xmlChar **)(v1 + 8);
    }
    else {
      return 0;
    }
  }
  return ctx;
}

int xmlSAX2GetLineNumber(void *ctx)
{
  if (ctx)
  {
    uint64_t v1 = *((void *)ctx + 7);
    if (v1) {
      LODWORD(ctx) = *(_DWORD *)(v1 + 52);
    }
    else {
      LODWORD(ctx) = 0;
    }
  }
  return (int)ctx;
}

int xmlSAX2GetColumnNumber(void *ctx)
{
  if (ctx)
  {
    uint64_t v1 = *((void *)ctx + 7);
    if (v1) {
      LODWORD(ctx) = *(_DWORD *)(v1 + 56);
    }
    else {
      LODWORD(ctx) = 0;
    }
  }
  return (int)ctx;
}

int xmlSAX2IsStandalone(void *ctx)
{
  if (ctx)
  {
    uint64_t v1 = *((void *)ctx + 2);
    if (v1) {
      LODWORD(ctx) = *(_DWORD *)(v1 + 76) == 1;
    }
    else {
      LODWORD(ctx) = 0;
    }
  }
  return (int)ctx;
}

int xmlSAX2HasInternalSubset(void *ctx)
{
  if (ctx)
  {
    uint64_t v1 = *((void *)ctx + 2);
    if (v1) {
      LODWORD(ctx) = *(void *)(v1 + 80) != 0;
    }
    else {
      LODWORD(ctx) = 0;
    }
  }
  return (int)ctx;
}

int xmlSAX2HasExternalSubset(void *ctx)
{
  if (ctx)
  {
    uint64_t v1 = *((void *)ctx + 2);
    if (v1) {
      LODWORD(ctx) = *(void *)(v1 + 88) != 0;
    }
    else {
      LODWORD(ctx) = 0;
    }
  }
  return (int)ctx;
}

void xmlSAX2InternalSubset(void *ctx, const xmlChar *name, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  if (ctx)
  {
    int v5 = (const xmlDoc *)*((void *)ctx + 2);
    if (v5)
    {
      xmlDtdPtr IntSubset = (xmlNode *)xmlGetIntSubset(v5);
      if (IntSubset)
      {
        if (*((_DWORD *)ctx + 13)) {
          return;
        }
        long long v10 = (xmlDtd *)IntSubset;
        xmlUnlinkNode(IntSubset);
        xmlFreeDtd(v10);
        long long v11 = (xmlDoc *)*((void *)ctx + 2);
        v11->intSubset = 0;
      }
      else
      {
        long long v11 = (xmlDoc *)*((void *)ctx + 2);
      }
      xmlDtdPtr v12 = xmlCreateIntSubset(v11, name, ExternalID, SystemID);
      *(void *)(*((void *)ctx + 2) + 80) = v12;
      if (!v12)
      {
        xmlSAX2ErrMemory((uint64_t *)ctx, "xmlSAX2InternalSubset");
      }
    }
  }
}

_DWORD *xmlSAX2ErrMemory(uint64_t *a1, const char *a2)
{
  *((_DWORD *)a1 + 34) = 2;
  uint64_t v3 = *a1;
  if (*a1 && *(_DWORD *)(v3 + 216) == -554844497) {
    uint64_t v4 = *(void (__cdecl **)(void *, xmlErrorPtr))(v3 + 248);
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t result = __xmlRaiseError(v4, (void (*)(void *, const char *, ...))a1[21], (void *)a1[20], a1, 0, 1u, 2, 2, 0, 0, (const xmlChar *)"out of memory\n", 0, 0, 0, 0, a2, (char)"out of memory\n");
  *((_DWORD *)a1 + 34) = 2;
  *((_DWORD *)a1 + 68) = -1;
  *((_DWORD *)a1 + 8xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 1;
  return result;
}

void xmlSAX2ExternalSubset(void *ctx, const xmlChar *name, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  if (ctx
    && (unint64_t)ExternalID | (unint64_t)SystemID
    && (*((_DWORD *)ctx + 39) || *((_DWORD *)ctx + 108)))
  {
    if (*((_DWORD *)ctx + 6))
    {
      if (*((void *)ctx + 2))
      {
        if (*(void *)ctx)
        {
          unsigned int v8 = *(uint64_t (**)(void, const xmlChar *, const xmlChar *))(*(void *)ctx + 32);
          if (v8)
          {
            uint64_t v9 = v8(*((void *)ctx + 1), ExternalID, SystemID);
            if (v9)
            {
              uint64_t v10 = v9;
              xmlNewDtd(*((xmlDocPtr *)ctx + 2), name, ExternalID, SystemID);
              uint64_t v11 = *((void *)ctx + 7);
              int v13 = *((_DWORD *)ctx + 16);
              int v12 = *((_DWORD *)ctx + 17);
              uint64_t v14 = *((void *)ctx + 9);
              int v15 = *((_DWORD *)ctx + 102);
              uint64_t v16 = *((void *)ctx + 5);
              *((void *)ctx + 5) = 0;
              uint64_t v17 = xmlMalloc(0x28uLL);
              *((void *)ctx + 9) = v17;
              if (!v17)
              {
                xmlSAX2ErrMemory((uint64_t *)ctx, "xmlSAX2ExternalSubset");
                *((void *)ctx + 7) = v11;
                *((_DWORD *)ctx + 16) = v13;
                *((_DWORD *)ctx + 17) = v12;
                *((void *)ctx + 9) = v14;
                *((_DWORD *)ctx + 102) = v15;
                goto LABEL_23;
              }
              *((void *)ctx + 8) = 0x500000000;
              *((void *)ctx + 7) = 0;
              xmlPushInput((xmlParserCtxtPtr)ctx, (xmlParserInputPtr)v10);
              uint64_t v18 = *((void *)ctx + 7);
              if (*(int *)(v18 + 48) >= 4)
              {
                xmlCharEncoding v19 = xmlDetectCharEncoding(*(const unsigned __int8 **)(v18 + 32), 4);
                xmlSwitchEncoding((xmlParserCtxtPtr)ctx, v19);
              }
              if (!*(void *)(v10 + 8)) {
                *(void *)(v10 + 8) = xmlCanonicPath(SystemID);
              }
              *(void *)(v10 + 52) = 0x100000001;
              uint64_t v20 = *(void *)(*((void *)ctx + 7) + 32);
              *(void *)(v10 + 24) = v20;
              *(void *)(v10 + 32) = v20;
              *(void *)(v10 + 72) = 0;
              xmlParseExternalSubset((xmlParserCtxtPtr)ctx, ExternalID, SystemID);
              if (*((int *)ctx + 16) >= 2)
              {
                do
                  xmlPopInput((xmlParserCtxtPtr)ctx);
                while (*((int *)ctx + 16) > 1);
              }
              xmlFreeInputStream(*((xmlParserInputPtr *)ctx + 7));
              xmlFree(*((void **)ctx + 9));
              *((void *)ctx + 7) = v11;
              *((_DWORD *)ctx + 16) = v13;
              *((_DWORD *)ctx + 17) = v12;
              *((void *)ctx + 9) = v14;
              *((_DWORD *)ctx + 102) = v15;
              int v21 = (xmlChar *)*((void *)ctx + 5);
              if (!v21) {
                goto LABEL_23;
              }
              int v22 = (xmlDict *)*((void *)ctx + 57);
              if (v22)
              {
                if (xmlDictOwns(v22, v21))
                {
LABEL_23:
                  *((void *)ctx + 5) = v16;
                  return;
                }
                int v21 = (xmlChar *)*((void *)ctx + 5);
              }
              xmlFree(v21);
              goto LABEL_23;
            }
          }
        }
      }
    }
  }
}

xmlParserInputPtr xmlSAX2ResolveEntity(void *ctx, const xmlChar *publicId, const xmlChar *systemId)
{
  ExternalxmlEntityPtr Entity = (xmlParserCtxt *)ctx;
  if (ctx)
  {
    uint64_t v5 = *((void *)ctx + 7);
    if (!v5 || (int v6 = *(const xmlChar **)(v5 + 8)) == 0) {
      int v6 = (const xmlChar *)*((void *)ctx + 35);
    }
    int v7 = xmlBuildURI(systemId, v6);
    ExternalxmlEntityPtr Entity = (xmlParserCtxt *)xmlLoadExternalEntity((const char *)v7, (const char *)publicId, ExternalEntity);
    if (v7) {
      xmlFree(v7);
    }
  }
  return (xmlParserInputPtr)ExternalEntity;
}

xmlEntityPtr xmlSAX2GetEntity(void *ctx, const xmlChar *name)
{
  if (!ctx) {
    return 0;
  }
  if (!*((_DWORD *)ctx + 84))
  {
    xmlEntityPtr PredefinedEntity = xmlGetPredefinedEntity(name);
    if (PredefinedEntity) {
      return PredefinedEntity;
    }
  }
  uint64_t v4 = (const xmlDoc *)*((void *)ctx + 2);
  if (v4 && v4->standalone == 1)
  {
    if (*((_DWORD *)ctx + 84) == 2)
    {
      v4->standalone = 0;
      xmlEntityPtr result = xmlGetDocEntity(v4, name);
      *(_DWORD *)(*((void *)ctx + 2) + 76) = 1;
      return result;
    }
    xmlEntityPtr PredefinedEntity = xmlGetDocEntity(v4, name);
    if (!PredefinedEntity)
    {
      int v7 = (const xmlDoc *)*((void *)ctx + 2);
      v7->standalone = 0;
      xmlEntityPtr PredefinedEntity = xmlGetDocEntity(v7, name);
      if (PredefinedEntity) {
        xmlFatalErrMsg_0(ctx, 103, "Entity(%s) document marked standalone but requires external subset\n", name);
      }
      *(_DWORD *)(*((void *)ctx + 2) + 76) = 1;
    }
    return PredefinedEntity;
  }

  return xmlGetDocEntity(v4, name);
}

_DWORD *xmlFatalErrMsg_0(_DWORD *result, int a2, const char *a3, const xmlChar *a4)
{
  uint64_t v4 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    xmlEntityPtr result = __xmlRaiseError(0, 0, 0, result, 0, 1u, a2, 3, 0, 0, a4, 0, 0, 0, 0, a3, (char)a4);
    v4[6] = 0;
    v4[38] = 0;
    if (!v4[112]) {
      v4[83] = 1;
    }
  }
  return result;
}

xmlEntityPtr xmlSAX2GetParameterEntity(xmlEntityPtr ctx, const xmlChar *name)
{
  if (ctx) {
    return xmlGetParameterEntity((xmlDocPtr)ctx->name, name);
  }
  return ctx;
}

void xmlSAX2EntityDecl(void *ctx, const xmlChar *name, int type, const xmlChar *publicId, const xmlChar *systemId, xmlChar *content)
{
  if (!ctx) {
    return;
  }
  int v9 = *((_DWORD *)ctx + 84);
  if (v9 == 2)
  {
    xmlEntityPtr v10 = xmlAddDtdEntity(*((xmlDocPtr *)ctx + 2), name, type, publicId, systemId, content);
    if (v10)
    {
LABEL_10:
      if (systemId && !v10->URI)
      {
        uint64_t v11 = *((void *)ctx + 7);
        if (!v11 || (int v12 = *(const xmlChar **)(v11 + 8)) == 0) {
          int v12 = (const xmlChar *)*((void *)ctx + 35);
        }
        v10->xmlURIPtr URI = xmlBuildURI(systemId, v12);
      }
      return;
    }
    if (*((_DWORD *)ctx + 105))
    {
      if (*(void *)ctx)
      {
        int v13 = *(void (**)(void, const char *, ...))(*(void *)ctx + 168);
        if (v13) {
          v13(*((void *)ctx + 1), "Entity(%s) already defined in the external subset\n", (const char *)name);
        }
      }
    }
  }
  else
  {
    if (v9 == 1)
    {
      xmlEntityPtr v10 = xmlAddDocEntity(*((xmlDocPtr *)ctx + 2), name, type, publicId, systemId, content);
      if (!v10)
      {
        if (*((_DWORD *)ctx + 105) && (!*((_DWORD *)ctx + 83) || *((_DWORD *)ctx + 68) != -1))
        {
          *((_DWORD *)ctx + 34) = 107;
          __xmlRaiseError(0, 0, 0, ctx, 0, 1u, 107, 1, 0, 0, name, 0, 0, 0, 0, "Entity(%s) already defined in the internal subset\n", (char)name);
        }
        return;
      }
      goto LABEL_10;
    }
    xmlFatalErrMsg_0(ctx, 104, "SAX.xmlSAX2EntityDecl(%s) called while not in subset\n", name);
  }
}

void xmlSAX2AttributeDecl(void *ctx, const xmlChar *elem, const xmlChar *fullname, int type, int def, const xmlChar *defaultValue, xmlEnumerationPtr tree)
{
  prefix = 0;
  if (ctx && *((void *)ctx + 2))
  {
    int v14 = xmlStrEqual(fullname, (const xmlChar *)"xml:id");
    if (type != 2 && v14)
    {
      int v15 = *((_DWORD *)ctx + 38);
      xmlErrValid(ctx, 540, "xml:id : attribute type should be ID\n", 0, 0);
      *((_DWORD *)ctx + 38) = v15;
    }
    uint64_t v16 = xmlSplitQName((xmlParserCtxtPtr)ctx, fullname, &prefix);
    *((_DWORD *)ctx + 56) = 1;
    int v17 = *((_DWORD *)ctx + 84);
    if (v17 == 2)
    {
      uint64_t v18 = *(xmlDtd **)(*((void *)ctx + 2) + 88);
    }
    else
    {
      if (v17 != 1)
      {
        xmlFatalErrMsg_0(ctx, 1, "SAX.xmlSAX2AttributeDecl(%s) called while not in subset\n", v16);
        xmlFree(v16);
        xmlFreeEnumeration(tree);
        return;
      }
      uint64_t v18 = *(xmlDtd **)(*((void *)ctx + 2) + 80);
    }
    xmlCharEncoding v19 = xmlAddAttributeDecl((xmlValidCtxtPtr)((char *)ctx + 160), v18, elem, v16, prefix, (xmlAttributeType)type, (xmlAttributeDefault)def, defaultValue, tree);
    if (!*((_DWORD *)ctx + 56)) {
      *((_DWORD *)ctx + 38) = 0;
    }
    if (v19)
    {
      if (*((_DWORD *)ctx + 39))
      {
        if (*((_DWORD *)ctx + 6))
        {
          uint64_t v20 = (xmlDoc *)*((void *)ctx + 2);
          if (v20->intSubset) {
            *((_DWORD *)ctx + 38) &= xmlValidateAttributeDecl((xmlValidCtxtPtr)((char *)ctx + 160), v20, v19);
          }
        }
      }
    }
    if (prefix) {
      xmlFree(prefix);
    }
    if (v16) {
      xmlFree(v16);
    }
  }
}

_DWORD *xmlErrValid(_DWORD *result, int a2, const char *a3, const xmlChar *a4, xmlChar *a5)
{
  uint64_t v5 = (uint64_t)result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    uint64_t v6 = *(void *)result;
    if (*(void *)result && *(_DWORD *)(v6 + 216) == -554844497) {
      int v7 = *(void (__cdecl **)(void *, xmlErrorPtr))(v6 + 248);
    }
    else {
      int v7 = 0;
    }
    xmlEntityPtr result = __xmlRaiseError(v7, *(void (**)(void *, const char *, ...))(v5 + 168), *(void **)(v5 + 160), (void *)v5, 0, 4u, a2, 2, 0, 0, a4, a5, 0, 0, 0, a3, (char)a4);
    *(_DWORD *)(v5 + 152) = 0;
  }
  return result;
}

void xmlSAX2ElementDecl(void *ctx, const xmlChar *name, int type, xmlElementContentPtr content)
{
  if (!ctx) {
    return;
  }
  uint64_t v5 = *((void *)ctx + 2);
  if (!v5) {
    return;
  }
  int v6 = *((_DWORD *)ctx + 84);
  if (v6 == 2)
  {
    int v7 = (xmlDtdPtr *)(v5 + 88);
    goto LABEL_7;
  }
  if (v6 == 1)
  {
    int v7 = (xmlDtdPtr *)(v5 + 80);
LABEL_7:
    unsigned int v8 = xmlAddElementDecl((xmlValidCtxtPtr)((char *)ctx + 160), *v7, name, (xmlElementTypeVal)type, content);
    if (!v8) {
      *((_DWORD *)ctx + 38) = 0;
    }
    if (*((_DWORD *)ctx + 39))
    {
      if (*((_DWORD *)ctx + 6))
      {
        int v9 = (xmlDoc *)*((void *)ctx + 2);
        if (v9)
        {
          if (v9->intSubset) {
            *((_DWORD *)ctx + 38) &= xmlValidateElementDecl((xmlValidCtxtPtr)((char *)ctx + 160), v9, v8);
          }
        }
      }
    }
    return;
  }

  xmlFatalErrMsg_0(ctx, 1, "SAX.xmlSAX2ElementDecl(%s) called while not in subset\n", name);
}

void xmlSAX2NotationDecl(void *ctx, const xmlChar *name, const xmlChar *publicId, const xmlChar *systemId)
{
  if (!ctx) {
    return;
  }
  uint64_t v5 = *((void *)ctx + 2);
  if (!v5) {
    return;
  }
  if (!((unint64_t)publicId | (unint64_t)systemId))
  {
    int v6 = "SAX.xmlSAX2NotationDecl(%s) externalID or PublicID missing\n";
LABEL_17:
    xmlFatalErrMsg_0(ctx, 105, v6, name);
    return;
  }
  int v7 = *((_DWORD *)ctx + 84);
  if (v7 == 2)
  {
    unsigned int v8 = (xmlDtdPtr *)(v5 + 88);
  }
  else
  {
    if (v7 != 1)
    {
      int v6 = "SAX.xmlSAX2NotationDecl(%s) called while not in subset\n";
      goto LABEL_17;
    }
    unsigned int v8 = (xmlDtdPtr *)(v5 + 80);
  }
  int v9 = xmlAddNotationDecl((xmlValidCtxtPtr)((char *)ctx + 160), *v8, name, publicId, systemId);
  if (!v9) {
    *((_DWORD *)ctx + 38) = 0;
  }
  if (*((_DWORD *)ctx + 39))
  {
    if (*((_DWORD *)ctx + 6))
    {
      xmlEntityPtr v10 = (xmlDoc *)*((void *)ctx + 2);
      if (v10->intSubset) {
        *((_DWORD *)ctx + 38) &= xmlValidateNotationDecl((xmlValidCtxtPtr)((char *)ctx + 160), v10, v9);
      }
    }
  }
}

void xmlSAX2UnparsedEntityDecl(void *ctx, const xmlChar *name, const xmlChar *publicId, const xmlChar *systemId, const xmlChar *notationName)
{
  if (!ctx) {
    return;
  }
  int v7 = *((_DWORD *)ctx + 84);
  if (v7 != 2)
  {
    if (v7 != 1)
    {
      xmlFatalErrMsg_0(ctx, 1, "SAX.xmlSAX2UnparsedEntityDecl(%s) called while not in subset\n", name);
      return;
    }
    xmlEntityPtr v8 = xmlAddDocEntity(*((xmlDocPtr *)ctx + 2), name, 3, publicId, systemId, notationName);
    if (!v8)
    {
      if (*((_DWORD *)ctx + 105))
      {
        if (*(void *)ctx)
        {
          int v9 = *(void (**)(uint64_t, const char *))(*(void *)ctx + 168);
          if (v9)
          {
            uint64_t v10 = *((void *)ctx + 1);
            uint64_t v11 = "Entity(%s) already defined in the internal subset\n";
LABEL_23:
            v9(v10, v11);
            return;
          }
        }
      }
      return;
    }
LABEL_10:
    if (systemId && !v8->URI)
    {
      uint64_t v12 = *((void *)ctx + 7);
      if (!v12 || (int v13 = *(const xmlChar **)(v12 + 8)) == 0) {
        int v13 = (const xmlChar *)*((void *)ctx + 35);
      }
      v8->xmlURIPtr URI = xmlBuildURI(systemId, v13);
    }
    return;
  }
  xmlEntityPtr v8 = xmlAddDtdEntity(*((xmlDocPtr *)ctx + 2), name, 3, publicId, systemId, notationName);
  if (v8) {
    goto LABEL_10;
  }
  if (*((_DWORD *)ctx + 105))
  {
    if (*(void *)ctx)
    {
      int v9 = *(void (**)(uint64_t, const char *))(*(void *)ctx + 168);
      if (v9)
      {
        uint64_t v10 = *((void *)ctx + 1);
        uint64_t v11 = "Entity(%s) already defined in the external subset\n";
        goto LABEL_23;
      }
    }
  }
}

void xmlSAX2StartElement(void *ctx, const xmlChar *fullname, const xmlChar **atts)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  if (ctx)
  {
    if (fullname)
    {
      uint64_t v5 = *((void *)ctx + 2);
      if (v5)
      {
        xmlNodePtr children = (_xmlNode *)*((void *)ctx + 10);
        if (*((_DWORD *)ctx + 39))
        {
          if (!*(void *)(v5 + 88))
          {
            uint64_t v12 = *(void **)(v5 + 80);
            if (!v12 || !v12[9] && !v12[10] && !v12[11] && !v12[12])
            {
              xmlErrValid(ctx, 94, "Validation failed: no DTD found !", 0, 0);
              *((_DWORD *)ctx + 39) = 0;
            }
          }
        }
        prefix = 0;
        xmlEntityPtr v8 = xmlSplitQName((xmlParserCtxtPtr)ctx, fullname, &prefix);
        xmlNodePtr v9 = xmlNewDocNodeEatName(*((xmlDocPtr *)ctx + 2), 0, v8, 0);
        if (v9)
        {
          uint64_t v10 = v9;
          uint64_t v11 = (xmlNode *)*((void *)ctx + 2);
          if (v11->children)
          {
            if (!children) {
              xmlNodePtr children = v11->children;
            }
          }
          else
          {
            xmlAddChild(v11, v10);
          }
          *((_DWORD *)ctx + 104) = -1;
          if (*((_DWORD *)ctx + 109))
          {
            uint64_t v13 = *((void *)ctx + 7);
            if (v13)
            {
              int v14 = *(_DWORD *)(v13 + 52);
              if (v14 >= 0xFFFF) {
                LOWORD(v14) = -1;
              }
              v10->unint64_t line = v14;
            }
          }
          if (nodePush((xmlParserCtxtPtr)ctx, v10) < 0)
          {
            xmlUnlinkNode(v10);
            xmlFreeNode(v10);
LABEL_63:
            if (prefix) {
              xmlFree(prefix);
            }
            return;
          }
          if (children)
          {
            if (children->type == XML_ELEMENT_NODE) {
              xmlAddChild(children, v10);
            }
            else {
              xmlAddSibling(children, v10);
            }
          }
          if (*((_DWORD *)ctx + 13))
          {
LABEL_33:
            if (atts)
            {
              int v15 = (xmlChar *)*atts;
              uint64_t v16 = (xmlChar *)atts[1];
              if (*((_DWORD *)ctx + 13))
              {
                if (v15)
                {
                  int v17 = (xmlChar **)(atts + 3);
                  do
                  {
                    xmlSAX2AttributeInternal((uint64_t *)ctx, v15, v16, 0);
                    int v15 = *(v17 - 1);
                    uint64_t v16 = *v17;
                    v17 += 2;
                  }
                  while (v15);
                }
              }
              else if (v15 && v16)
              {
                uint64_t v24 = (xmlChar **)(atts + 3);
                do
                {
                  if (*v15 != 120 || v15[1] != 109 || v15[2] != 108 || v15[3] != 110 || v15[4] != 115) {
                    xmlSAX2AttributeInternal((uint64_t *)ctx, v15, v16, 0);
                  }
                  int v15 = *(v24 - 1);
                  uint64_t v16 = *v24;
                  v24 += 2;
                  if (v15) {
                    BOOL v25 = v16 == 0;
                  }
                  else {
                    BOOL v25 = 1;
                  }
                }
                while (!v25);
              }
            }
            if (*((_DWORD *)ctx + 39) && *((_DWORD *)ctx + 52) == -1412623820)
            {
              int v26 = xmlValidateDtdFinal((xmlValidCtxtPtr)((char *)ctx + 160), *((xmlDocPtr *)ctx + 2));
              if (v26 <= 0)
              {
                *((_DWORD *)ctx + 38) = 0;
                if (v26 < 0) {
                  *((_DWORD *)ctx + 6) = 0;
                }
              }
              *((_DWORD *)ctx + 38) &= xmlValidateRoot((xmlValidCtxtPtr)((char *)ctx + 160), *((xmlDocPtr *)ctx + 2));
              *((_DWORD *)ctx + 52) = -1412623819;
            }
            goto LABEL_63;
          }
          xmlNodePtr node = children;
          uint64_t v18 = *((void *)ctx + 2);
          xmlCharEncoding v19 = *(xmlDtd **)(v18 + 80);
          if (v19 || *(void *)(v18 + 88))
          {
            uint64_t v20 = prefix;
            xmlElementPtr DtdQElementDesc = xmlGetDtdQElementDesc(v19, v8, prefix);
            if (DtdQElementDesc)
            {
              xmlElementPtr v22 = DtdQElementDesc;
              int v23 = 1;
              goto LABEL_68;
            }
            xmlElementPtr v27 = xmlGetDtdQElementDesc(*(xmlDtdPtr *)(*((void *)ctx + 2) + 88), v8, v20);
            if (v27)
            {
              xmlElementPtr v22 = v27;
              int v23 = 0;
LABEL_68:
              int v28 = atts + 2;
              while (1)
              {
                int v57 = v23;
                attributes = v22->attributes;
                uint64_t v30 = *((void *)ctx + 2);
                if (*(_DWORD *)(v30 + 76) == 1)
                {
                  if (*(void *)(v30 + 88))
                  {
                    if (*((_DWORD *)ctx + 39) && attributes != 0)
                    {
                      int v56 = v28;
                      do
                      {
                        if (attributes->defaultValue
                          && xmlGetDtdQAttrDesc(*(xmlDtdPtr *)(*((void *)ctx + 2) + 88), attributes->elem, attributes->name, attributes->prefix) == attributes&& !xmlGetDtdQAttrDesc(*(xmlDtdPtr *)(*((void *)ctx + 2) + 80), attributes->elem, attributes->name, attributes->prefix))
                        {
                          int v32 = attributes->prefix;
                          if (v32)
                          {
                            uint64_t v33 = xmlStrdup(v32);
                            int v34 = xmlStrcat(v33, (const xmlChar *)":");
                            uint64_t v35 = xmlStrcat(v34, attributes->name);
                          }
                          else
                          {
                            uint64_t v35 = xmlStrdup(attributes->name);
                          }
                          uint64_t v36 = v35;
                          if (!v35)
                          {
                            xmlSAX2ErrMemory((uint64_t *)ctx, "xmlSAX2StartElement");
                            int v28 = v56;
                            break;
                          }
                          if (atts && (uint64_t v37 = *atts) != 0)
                          {
                            uint64_t v38 = v56;
                            while (!xmlStrEqual(v37, v36))
                            {
                              uint64_t v39 = *v38;
                              v38 += 2;
                              uint64_t v37 = v39;
                              if (!v39) {
                                goto LABEL_88;
                              }
                            }
                          }
                          else
                          {
LABEL_88:
                            xmlErrValid(ctx, 538, "standalone: attribute %s on %s defaulted from external subset\n", v36, (xmlChar *)attributes->elem);
                          }
                          xmlFree(v36);
                          int v28 = v56;
                        }
                        attributes = attributes->nexth;
                      }
                      while (attributes);
                    }
                  }
                  attributes = v22->attributes;
                }
                if (attributes) {
                  break;
                }
LABEL_115:
                if (v57 == 1)
                {
                  xmlElementPtr v22 = xmlGetDtdQElementDesc(*(xmlDtdPtr *)(*((void *)ctx + 2) + 88), v8, v20);
                  int v23 = 0;
                  if (v22) {
                    continue;
                  }
                }
                goto LABEL_120;
              }
              while (1)
              {
                if (!attributes->defaultValue) {
                  goto LABEL_114;
                }
                int v40 = attributes->prefix;
                if (v40)
                {
                  if (xmlStrEqual(v40, (const xmlChar *)"xmlns")) {
                    goto LABEL_99;
                  }
                  if (attributes->prefix) {
                    goto LABEL_98;
                  }
                }
                if (!xmlStrEqual(attributes->name, (const xmlChar *)"xmlns"))
                {
LABEL_98:
                  if ((*((unsigned char *)ctx + 432) & 4) == 0) {
                    goto LABEL_114;
                  }
                }
LABEL_99:
                xmlAttributePtr DtdQAttrDesc = xmlGetDtdQAttrDesc(*(xmlDtdPtr *)(*((void *)ctx + 2) + 80), attributes->elem, attributes->name, attributes->prefix);
                if (DtdQAttrDesc == attributes || DtdQAttrDesc == 0)
                {
                  __int16 v62 = 0;
                  long long v60 = 0u;
                  long long v61 = 0u;
                  *(_OWORD *)memorxmlSchemaValPtr y = 0u;
                  uint64_t v43 = xmlBuildQName(attributes->name, attributes->prefix, memory, 50);
                  if (!v43)
                  {
                    xmlSAX2ErrMemory((uint64_t *)ctx, "xmlSAX2StartElement");
                    break;
                  }
                  uint64_t v44 = v43;
                  if (atts && (int v45 = *atts) != 0)
                  {
                    int v46 = v28;
                    while (!xmlStrEqual(v45, v44))
                    {
                      uint64_t v47 = *v46;
                      v46 += 2;
                      int v45 = v47;
                      if (!v47) {
                        goto LABEL_110;
                      }
                    }
                  }
                  else
                  {
LABEL_110:
                    xmlSAX2AttributeInternal((uint64_t *)ctx, v44, (xmlChar *)attributes->defaultValue, v20);
                  }
                  if (v44 != memory && v44 != attributes->name) {
                    xmlFree(v44);
                  }
                }
LABEL_114:
                attributes = attributes->nexth;
                if (!attributes) {
                  goto LABEL_115;
                }
              }
            }
          }
LABEL_120:
          if (atts)
          {
            int v48 = (xmlChar *)*atts;
            if (*atts)
            {
              int v49 = (xmlChar *)atts[1];
              if (v49)
              {
                int v50 = (xmlChar **)(atts + 3);
                do
                {
                  if (*v48 == 120 && v48[1] == 109 && v48[2] == 108 && v48[3] == 110 && v48[4] == 115) {
                    xmlSAX2AttributeInternal((uint64_t *)ctx, v48, v49, prefix);
                  }
                  int v48 = *(v50 - 1);
                  int v49 = *v50;
                  v50 += 2;
                  if (v48) {
                    BOOL v51 = v49 == 0;
                  }
                  else {
                    BOOL v51 = 1;
                  }
                }
                while (!v51);
              }
            }
          }
          xmlNsPtr v52 = xmlSearchNs(*((xmlDocPtr *)ctx + 2), v10, prefix);
          xmlNsPtr v53 = v52;
          if (node && !v52) {
            xmlNsPtr v53 = xmlSearchNs(*((xmlDocPtr *)ctx + 2), node, prefix);
          }
          if (prefix && !v53)
          {
            xmlNsPtr v53 = xmlNewNs(v10, 0, prefix);
            xmlNsWarnMsg(ctx, 201, "Namespace prefix %s is not defined\n", prefix, 0);
          }
          if (v53)
          {
            href = v53->href;
            if (href)
            {
              if (*href || v53->prefix) {
                xmlSetNs(v10, v53);
              }
            }
          }
          goto LABEL_33;
        }
        if (prefix) {
          xmlFree(prefix);
        }
        xmlSAX2ErrMemory((uint64_t *)ctx, "xmlSAX2StartElement");
      }
    }
  }
}

void xmlSAX2AttributeInternal(uint64_t *ctxt, xmlChar *name, xmlChar *a3, const xmlChar *a4)
{
  prefix = 0;
  if (*((_DWORD *)ctxt + 13))
  {
    xmlEntityPtr v8 = xmlStrdup(name);
    prefix = 0;
    if (!v8)
    {
LABEL_16:
      xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");
      goto LABEL_104;
    }
  }
  else
  {
    xmlNodePtr v9 = xmlSplitQName((xmlParserCtxtPtr)ctxt, name, &prefix);
    if (!v9) {
      goto LABEL_16;
    }
    xmlEntityPtr v8 = v9;
    if (!*v9)
    {
      if (xmlStrEqual(prefix, (const xmlChar *)"xmlns")) {
        xmlNsErrMsg(ctxt, 35, "invalid namespace declaration '%s'\n", name, 0);
      }
      else {
        xmlNsWarnMsg(ctxt, 106, "Avoid attribute ending with ':' like '%s'\n", name, 0);
      }
      if (prefix) {
        xmlFree(prefix);
      }
      prefix = 0;
      xmlFree(v8);
      xmlEntityPtr v8 = xmlStrdup(name);
      if (!v8) {
        goto LABEL_16;
      }
    }
  }
  if (!a3 && *((_DWORD *)ctxt + 13) && htmlIsBooleanAttr(name))
  {
    a3 = xmlStrdup(name);
    uint64_t v10 = a3;
  }
  else
  {
    *((_DWORD *)ctxt + 56) = 1;
    uint64_t v11 = xmlValidCtxtNormalizeAttributeValue((xmlValidCtxtPtr)(ctxt + 20), (xmlDocPtr)ctxt[2], (xmlNodePtr)ctxt[10], name, a3);
    uint64_t v10 = v11;
    if (*((_DWORD *)ctxt + 56) != 1) {
      *((_DWORD *)ctxt + 38) = 0;
    }
    if (v11) {
      a3 = v11;
    }
  }
  int v12 = *((_DWORD *)ctxt + 13);
  if (!v12 && !prefix)
  {
    if (*v8 == 120 && v8[1] == 109 && v8[2] == 108 && v8[3] == 110 && v8[4] == 115 && !v8[5])
    {
      uint64_t v13 = a3;
      if (*((_DWORD *)ctxt + 7)
        || (++*((_DWORD *)ctxt + 98),
            uint64_t v13 = xmlStringDecodeEntities((xmlParserCtxtPtr)ctxt, a3, 1, 0, 0, 0),
            --*((_DWORD *)ctxt + 98),
            v13))
      {
        if (*v13)
        {
          xmlURIPtr v14 = xmlParseURI((const char *)v13);
          if (v14)
          {
            int v15 = v14;
            if (!v14->scheme)
            {
              if (*ctxt)
              {
                warningSAXFunc v34 = *(warningSAXFunc *)(*ctxt + 168);
                if (v34) {
                  v34((void *)ctxt[1], "xmlns: URI %s is not absolute\n", (const char *)v13);
                }
              }
            }
            xmlFreeURI(v15);
          }
          else if (*ctxt)
          {
            warningSAXFunc v33 = *(warningSAXFunc *)(*ctxt + 168);
            if (v33) {
              v33((void *)ctxt[1], "xmlns: %s not a valid URI\n", (const char *)v13);
            }
          }
        }
        uint64_t v16 = xmlNewNs((xmlNodePtr)ctxt[10], v13, 0);
        if (v16)
        {
          if (*((_DWORD *)ctxt + 39))
          {
            if (*((_DWORD *)ctxt + 6))
            {
              xmlDocPtr v17 = (xmlDocPtr)ctxt[2];
              if (v17)
              {
                if (v17->intSubset) {
                  *((_DWORD *)ctxt + 38) &= xmlValidateOneNamespace((xmlValidCtxtPtr)(ctxt + 20), v17, (xmlNodePtr)ctxt[10], a4, v16, v13);
                }
              }
            }
          }
        }
        xmlFree(v8);
        if (v10) {
LABEL_132:
        }
          ((void (*)(xmlChar *))xmlFree)(v10);
LABEL_133:
        if (v13 == a3) {
          return;
        }
        goto LABEL_105;
      }
      xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");
      ((void (*)(xmlChar *))xmlFree)(v8);
      goto LABEL_122;
    }
    goto LABEL_70;
  }
  if (v12 || !prefix)
  {
    if (!prefix)
    {
LABEL_70:
      xmlNsPtr v20 = 0;
      goto LABEL_72;
    }
LABEL_62:
    xmlNsPtr v20 = xmlSearchNs((xmlDocPtr)ctxt[2], (xmlNodePtr)ctxt[10], prefix);
    if (v20)
    {
      int v21 = *(_xmlAttr **)(ctxt[10] + 88);
      if (v21)
      {
        while (1)
        {
          if (v21->ns)
          {
            if (xmlStrEqual(v8, v21->name))
            {
              xmlNsPtr ns = v21->ns;
              if (v20 == ns || xmlStrEqual(v20->href, ns->href)) {
                break;
              }
            }
          }
          int v21 = v21->next;
          if (!v21) {
            goto LABEL_72;
          }
        }
        xmlNsErrMsg(ctxt, 42, "Attribute %s in %s redefined\n", v8, (xmlChar *)v20->href);
        *((_DWORD *)ctxt + 6) = 0;
        if (!*((_DWORD *)ctxt + 112)) {
          *((_DWORD *)ctxt + 8xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 1;
        }
        ((void (*)(xmlChar *))xmlFree)(v8);
        goto LABEL_102;
      }
    }
    else
    {
      xmlNsErrMsg(ctxt, 201, "Namespace prefix %s of attribute %s is not defined\n", prefix, v8);
    }
LABEL_72:
    xmlAttrPtr v23 = xmlNewNsPropEatName((xmlNodePtr)ctxt[10], v20, v8, 0);
    if (v23)
    {
      if (*((_DWORD *)ctxt + 7) || *((_DWORD *)ctxt + 13))
      {
        if (a3)
        {
          xmlNodePtr v24 = xmlNewDocText((const xmlDoc *)ctxt[2], a3);
          v23->xmlNodePtr children = v24;
          v23->last = v24;
          if (v24) {
            v24->xmlNodePtr parent = (_xmlNode *)v23;
          }
        }
      }
      else
      {
        xmlNodePtr NodeList = xmlStringGetNodeList((const xmlDoc *)ctxt[2], a3);
        v23->xmlNodePtr children = NodeList;
        if (NodeList)
        {
          do
          {
            int v26 = NodeList;
            NodeList->xmlNodePtr parent = (_xmlNode *)v23;
            xmlNodePtr NodeList = NodeList->next;
          }
          while (NodeList);
          v23->last = v26;
        }
      }
    }
    if (!*((_DWORD *)ctxt + 13)
      && *((_DWORD *)ctxt + 39)
      && *((_DWORD *)ctxt + 6)
      && (xmlDocPtr v27 = (xmlDocPtr)ctxt[2]) != 0
      && v27->intSubset)
    {
      if (*((_DWORD *)ctxt + 7))
      {
        int v28 = (xmlValidCtxt *)(ctxt + 20);
      }
      else
      {
        ++*((_DWORD *)ctxt + 98);
        uint64_t v29 = xmlStringDecodeEntities((xmlParserCtxtPtr)ctxt, a3, 1, 0, 0, 0);
        --*((_DWORD *)ctxt + 98);
        if (v29)
        {
          uint64_t v30 = v29;
          uint64_t v31 = xmlValidNormalizeAttributeValue((xmlDocPtr)ctxt[2], (xmlNodePtr)ctxt[10], name, v29);
          if (v31)
          {
            int v32 = v31;
            xmlFree(v30);
            uint64_t v30 = v32;
          }
          *((_DWORD *)ctxt + 38) &= xmlValidateOneAttribute((xmlValidCtxtPtr)(ctxt + 20), (xmlDocPtr)ctxt[2], (xmlNodePtr)ctxt[10], v23, v30);
          ((void (*)(xmlChar *))xmlFree)(v30);
          goto LABEL_102;
        }
        int v28 = (xmlValidCtxt *)(ctxt + 20);
        xmlDocPtr v27 = (xmlDocPtr)ctxt[2];
      }
      *((_DWORD *)ctxt + 38) &= xmlValidateOneAttribute(v28, v27, (xmlNodePtr)ctxt[10], v23, a3);
    }
    else
    {
      if ((ctxt[54] & 8) != 0) {
        goto LABEL_102;
      }
      if (*((_DWORD *)ctxt + 7))
      {
        if (*((_DWORD *)ctxt + 84)) {
          goto LABEL_102;
        }
      }
      else if (*((_DWORD *)ctxt + 37) == 2)
      {
        goto LABEL_102;
      }
      if (xmlStrEqual(name, (const xmlChar *)"xml:id"))
      {
        if (xmlValidateNCName(a3, 1)) {
          xmlErrValid(ctxt, 539, "xml:id : attribute value %s is not an NCName\n", a3, 0);
        }
      }
      else if (!xmlIsID((xmlDocPtr)ctxt[2], (xmlNodePtr)ctxt[10], v23))
      {
        if (xmlIsRef((xmlDocPtr)ctxt[2], (xmlNodePtr)ctxt[10], v23)) {
          xmlAddRef((xmlValidCtxtPtr)(ctxt + 20), (xmlDocPtr)ctxt[2], a3, v23);
        }
        goto LABEL_102;
      }
      xmlAddID((xmlValidCtxtPtr)(ctxt + 20), (xmlDocPtr)ctxt[2], a3, v23);
    }
LABEL_102:
    if (v10) {
      xmlFree(v10);
    }
LABEL_104:
    uint64_t v13 = prefix;
    if (!prefix) {
      return;
    }
    goto LABEL_105;
  }
  if (*prefix != 120 || prefix[1] != 109 || prefix[2] != 108 || prefix[3] != 110 || prefix[4] != 115 || prefix[5]) {
    goto LABEL_62;
  }
  uint64_t v13 = a3;
  if (*((_DWORD *)ctxt + 7)
    || (++*((_DWORD *)ctxt + 98),
        uint64_t v13 = xmlStringDecodeEntities((xmlParserCtxtPtr)ctxt, a3, 1, 0, 0, 0),
        --*((_DWORD *)ctxt + 98),
        v13))
  {
    if (!*v13) {
      xmlNsErrMsg(ctxt, 204, "Empty namespace name for prefix %s\n", v8, 0);
    }
    if (*((_DWORD *)ctxt + 105) && *v13)
    {
      xmlURIPtr v18 = xmlParseURI((const char *)v13);
      if (v18)
      {
        xmlCharEncoding v19 = v18;
        if (!v18->scheme) {
          xmlNsWarnMsg(ctxt, 100, "xmlns:%s: URI %s is not absolute\n", v8, a3);
        }
        xmlFreeURI(v19);
      }
      else
      {
        xmlNsWarnMsg(ctxt, 99, "xmlns:%s: %s not a valid URI\n", v8, a3);
      }
    }
    uint64_t v35 = xmlNewNs((xmlNodePtr)ctxt[10], v13, v8);
    xmlFree(prefix);
    if (v35)
    {
      if (*((_DWORD *)ctxt + 39))
      {
        if (*((_DWORD *)ctxt + 6))
        {
          xmlDocPtr v36 = (xmlDocPtr)ctxt[2];
          if (v36)
          {
            if (v36->intSubset) {
              *((_DWORD *)ctxt + 38) &= xmlValidateOneNamespace((xmlValidCtxtPtr)(ctxt + 20), v36, (xmlNodePtr)ctxt[10], a4, v35, a3);
            }
          }
        }
      }
    }
    xmlFree(v8);
    if (v10) {
      goto LABEL_132;
    }
    goto LABEL_133;
  }
  xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");
  xmlFree(prefix);
  ((void (*)(xmlChar *))xmlFree)(v8);
LABEL_122:
  uint64_t v13 = v10;
  if (v10) {
LABEL_105:
  }
    xmlFree(v13);
}

_DWORD *xmlNsWarnMsg(_DWORD *result, int a2, const char *a3, const xmlChar *a4, xmlChar *a5)
{
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    return __xmlRaiseError(0, 0, 0, result, 0, 3u, a2, 1, 0, 0, a4, a5, 0, 0, 0, a3, (char)a4);
  }
  return result;
}

void xmlSAX2EndElement(void *ctx, const xmlChar *name)
{
  if (ctx)
  {
    uint64_t v3 = (xmlNode *)*((void *)ctx + 10);
    *((_DWORD *)ctx + 104) = -1;
    if (*((_DWORD *)ctx + 39))
    {
      if (*((_DWORD *)ctx + 6))
      {
        uint64_t v4 = (xmlDoc *)*((void *)ctx + 2);
        if (v4)
        {
          if (v4->intSubset) {
            *((_DWORD *)ctx + 38) &= xmlValidateOneElement((xmlValidCtxtPtr)((char *)ctx + 160), v4, v3);
          }
        }
      }
    }
    nodePop((xmlParserCtxtPtr)ctx);
  }
}

void xmlSAX2Reference(void *ctx, const xmlChar *name)
{
  if (ctx)
  {
    uint64_t v3 = (xmlDoc *)*((void *)ctx + 2);
    uint64_t v4 = *name == 35 ? xmlNewCharRef(v3, name) : xmlNewReference(v3, name);
    uint64_t v5 = v4;
    if (!xmlAddChild(*((xmlNodePtr *)ctx + 10), v4))
    {
      xmlFreeNode(v5);
    }
  }
}

void xmlSAX2ProcessingInstruction(void *ctx, const xmlChar *target, const xmlChar *data)
{
  if (!ctx) {
    return;
  }
  uint64_t v4 = *((void *)ctx + 10);
  xmlNodePtr v5 = xmlNewDocPI(*((xmlDocPtr *)ctx + 2), target, data);
  if (!v5) {
    return;
  }
  int v6 = v5;
  if (*((_DWORD *)ctx + 109))
  {
    uint64_t v7 = *((void *)ctx + 7);
    if (v7)
    {
      int v8 = *(_DWORD *)(v7 + 52);
      if (v8 >= 0xFFFF) {
        LOWORD(v8) = -1;
      }
      v5->unint64_t line = v8;
    }
  }
  int v9 = *((_DWORD *)ctx + 84);
  if (v9 == 2)
  {
    uint64_t v10 = *(xmlNode **)(*((void *)ctx + 2) + 88);
    goto LABEL_19;
  }
  if (v9 == 1)
  {
    uint64_t v10 = *(xmlNode **)(*((void *)ctx + 2) + 80);
    goto LABEL_19;
  }
  if (!v4)
  {
    uint64_t v10 = (xmlNode *)*((void *)ctx + 2);
    goto LABEL_19;
  }
  uint64_t v10 = (xmlNode *)v4;
  if (*(_DWORD *)(v4 + 8) == 1)
  {
LABEL_19:
    xmlAddChild(v10, v6);
    return;
  }

  xmlAddSibling((xmlNodePtr)v4, v6);
}

void xmlSAX2Comment(void *ctx, const xmlChar *value)
{
  if (!ctx) {
    return;
  }
  uint64_t v3 = *((void *)ctx + 10);
  xmlNodePtr v4 = xmlNewDocComment(*((xmlDocPtr *)ctx + 2), value);
  if (!v4) {
    return;
  }
  xmlNodePtr v5 = v4;
  if (*((_DWORD *)ctx + 109))
  {
    uint64_t v6 = *((void *)ctx + 7);
    if (v6)
    {
      int v7 = *(_DWORD *)(v6 + 52);
      if (v7 >= 0xFFFF) {
        LOWORD(v7) = -1;
      }
      v4->unint64_t line = v7;
    }
  }
  int v8 = *((_DWORD *)ctx + 84);
  if (v8 == 2)
  {
    int v9 = *(xmlNode **)(*((void *)ctx + 2) + 88);
    goto LABEL_19;
  }
  if (v8 == 1)
  {
    int v9 = *(xmlNode **)(*((void *)ctx + 2) + 80);
    goto LABEL_19;
  }
  if (!v3)
  {
    int v9 = (xmlNode *)*((void *)ctx + 2);
    goto LABEL_19;
  }
  int v9 = (xmlNode *)v3;
  if (*(_DWORD *)(v3 + 8) == 1)
  {
LABEL_19:
    xmlAddChild(v9, v5);
    return;
  }

  xmlAddSibling((xmlNodePtr)v3, v5);
}

void xmlSAX2CDataBlock(void *ctx, const xmlChar *value, int len)
{
}

int xmlSAXDefaultVersion(int version)
{
  if ((version - 3) < 0xFFFFFFFE) {
    return -1;
  }
  int result = xmlSAX2DefaultVersionValue;
  xmlSAX2DefaultVersionValue = version;
  return result;
}

void xmlSAX2InitDefaultSAXHandler(xmlSAXHandler *hdlr, int warning)
{
  if (hdlr && !hdlr->initialized)
  {
    xmlSAXVersion(hdlr, xmlSAX2DefaultVersionValue);
    if (warning) {
      xmlNodePtr v4 = xmlParserWarning;
    }
    else {
      xmlNodePtr v4 = 0;
    }
    hdlr->warning = v4;
  }
}

void xmlSAX2InitDocbDefaultSAXHandler(xmlSAXHandler *hdlr)
{
  if (hdlr)
  {
    if (!hdlr->initialized)
    {
      hdlr->internalSubsetSAXFunc internalSubset = xmlSAX2InternalSubset;
      hdlr->externalSubsetSAXFunc externalSubset = 0;
      hdlr->isStandalone = xmlSAX2IsStandalone;
      hdlr->hasInternalSubset = xmlSAX2HasInternalSubset;
      hdlr->hasExternalSubset = xmlSAX2HasExternalSubset;
      hdlr->resolvexmlEntityPtr Entity = xmlSAX2ResolveEntity;
      hdlr->getxmlEntityPtr Entity = xmlSAX2GetEntity;
      hdlr->entityDeclSAXFunc entityDecl = xmlSAX2EntityDecl;
      *(_OWORD *)&hdlr->notationDeclSAXFunc notationDecl = 0u;
      *(_OWORD *)&hdlr->elementDeclSAXFunc elementDecl = 0u;
      hdlr->setDocumentLocatorSAXFunc setDocumentLocator = xmlSAX2SetDocumentLocator;
      hdlr->startDocumentSAXFunc startDocument = xmlSAX2StartDocument;
      hdlr->endDocumentSAXFunc endDocument = xmlSAX2EndDocument;
      hdlr->startElementSAXFunc startElement = xmlSAX2StartElement;
      hdlr->endElementSAXFunc endElement = xmlSAX2EndElement;
      hdlr->referenceSAXFunc reference = xmlSAX2Reference;
      hdlr->charactersSAXFunc characters = xmlSAX2Characters;
      hdlr->getParameterEntitySAXFunc getParameterEntity = 0;
      hdlr->cdataBlocuint64_t k = 0;
      hdlr->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
      hdlr->processingInstructionSAXFunc processingInstruction = 0;
      hdlr->commentSAXFunc comment = xmlSAX2Comment;
      hdlr->warning = xmlParserWarning;
      hdlr->error = xmlParserError;
      hdlr->fatalError = xmlParserError;
      hdlr->initialized = 1;
    }
  }
}

void docbDefaultSAXHandlerInit(void)
{
  int v0 = (xmlSAXHandler *)__docbDefaultSAXHandler();

  xmlSAX2InitDocbDefaultSAXHandler(v0);
}

_DWORD *xmlNsErrMsg(_DWORD *result, int a2, const char *a3, const xmlChar *a4, xmlChar *a5)
{
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    return __xmlRaiseError(0, 0, 0, result, 0, 3u, a2, 2, 0, 0, a4, a5, 0, 0, 0, a3, (char)a4);
  }
  return result;
}

xmlChar *xmlSAX2DecodeAttrEntities(xmlParserCtxtPtr ctxt, const xmlChar *a2, unint64_t a3)
{
  xmlNodePtr v4 = a2;
  while ((unint64_t)v4 < a3)
  {
    int v5 = *v4++;
    if (v5 == 38)
    {
      ++ctxt->depth;
      int result = xmlStringLenDecodeEntities(ctxt, a2, (int)a3 - (int)a2, 1, 0, 0, 0);
      --ctxt->depth;
      return result;
    }
  }
  return 0;
}

void xmlSchematronFree(xmlSchematronPtr schema)
{
  if (schema)
  {
    uint64_t v2 = (xmlDoc *)*((void *)schema + 2);
    if (v2 && !*((_DWORD *)schema + 2)) {
      xmlFreeDoc(v2);
    }
    uint64_t v3 = (void *)*((void *)schema + 11);
    if (v3) {
      xmlFree(v3);
    }
    xmlNodePtr v4 = (void *)*((void *)schema + 9);
    if (v4)
    {
      do
      {
        int v5 = (void *)*v4;
        uint64_t v6 = (void *)v4[4];
        if (v6)
        {
          do
          {
            int v7 = (void *)*v6;
            int v8 = (void *)v6[3];
            if (v8) {
              xmlFree(v8);
            }
            int v9 = (xmlXPathCompExpr *)v6[4];
            if (v9) {
              xmlXPathFreeCompExpr(v9);
            }
            uint64_t v10 = (void *)v6[5];
            if (v10) {
              xmlFree(v10);
            }
            xmlFree(v6);
            uint64_t v6 = v7;
          }
          while (v7);
        }
        uint64_t v11 = (void *)v4[3];
        if (v11) {
          xmlFree(v11);
        }
        int v12 = (xmlPattern *)v4[5];
        if (v12) {
          xmlFreePattern(v12);
        }
        uint64_t v13 = (void *)v4[6];
        if (v13) {
          xmlFree(v13);
        }
        xmlFree(v4);
        xmlNodePtr v4 = v5;
      }
      while (v5);
    }
    xmlURIPtr v14 = (void *)*((void *)schema + 8);
    if (v14)
    {
      do
      {
        int v15 = (void *)*v14;
        uint64_t v16 = (void *)v14[2];
        if (v16) {
          xmlFree(v16);
        }
        xmlFree(v14);
        xmlURIPtr v14 = v15;
      }
      while (v15);
    }
    xmlDictFree(*((xmlDictPtr *)schema + 5));
    xmlFreeFunc v17 = xmlFree;
    ((void (*)(xmlSchematronPtr))v17)(schema);
  }
}

xmlSchematronParserCtxtPtr xmlSchematronNewParserCtxt(const char *URL)
{
  if (!URL) {
    return 0;
  }
  uint64_t v2 = (xmlSchematronParserCtxt *)xmlMalloc(0x90uLL);
  uint64_t v3 = v2;
  if (!v2)
  {
    __xmlSimpleError(16, 2, 0, 0, (uint64_t)"allocating schema parser context");
    return v3;
  }
  *((_OWORD *)v2 + 7) = 0u;
  *((_OWORD *)v2 + 8) = 0u;
  *((_OWORD *)v2 + 5) = 0u;
  *((_OWORD *)v2 + 6) = 0u;
  *((_OWORD *)v2 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0u;
  *((_OWORD *)v2 + xmlSAX2Text((uint64_t)ctx, (char *)value, len, 4) = 0u;
  *((_OWORD *)v2 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *(_OWORD *)uint64_t v2 = 0u;
  *(_DWORD *)uint64_t v2 = 1;
  xmlNodePtr v4 = xmlDictCreate();
  *((void *)v3 + 6) = v4;
  *((void *)v3 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = xmlDictLookup(v4, (const xmlChar *)URL, -1);
  *((void *)v3 + 1xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0;
  xmlXPathContextPtr v5 = xmlXPathNewContext(0);
  *((void *)v3 + 8) = v5;
  if (!v5)
  {
    __xmlSimpleError(16, 2, 0, 0, (uint64_t)"allocating schema parser XPath context");
    xmlSchematronFreeParserCtxt(v3);
    return 0;
  }
  v5->flags = 1;
  return v3;
}

void xmlSchematronFreeParserCtxt(xmlSchematronParserCtxtPtr ctxt)
{
  if (ctxt)
  {
    uint64_t v2 = (xmlDoc *)*((void *)ctxt + 2);
    if (v2 && !*((_DWORD *)ctxt + 6)) {
      xmlFreeDoc(v2);
    }
    uint64_t v3 = (xmlXPathContext *)*((void *)ctxt + 8);
    if (v3) {
      xmlXPathFreeContext(v3);
    }
    xmlNodePtr v4 = (void *)*((void *)ctxt + 11);
    if (v4) {
      xmlFree(v4);
    }
    xmlDictFree(*((xmlDictPtr *)ctxt + 6));
    xmlFreeFunc v5 = xmlFree;
    ((void (*)(xmlSchematronParserCtxtPtr))v5)(ctxt);
  }
}

xmlSchematronParserCtxtPtr xmlSchematronNewMemParserCtxt(const char *buffer, int size)
{
  uint64_t v2 = 0;
  if (buffer && size >= 1)
  {
    xmlFreeFunc v5 = xmlMalloc(0x90uLL);
    uint64_t v2 = v5;
    if (v5)
    {
      v5[7] = 0u;
      v5[8] = 0u;
      v5[5] = 0u;
      v5[6] = 0u;
      v5[3] = 0u;
      v5[4] = 0u;
      v5[1] = 0u;
      v5[2] = 0u;
      *xmlFreeFunc v5 = 0u;
      *((void *)v5 + xmlSAX2Text((uint64_t)ctx, (char *)value, len, 4) = buffer;
      *((_DWORD *)v5 + 10) = size;
      *((void *)v5 + 6) = xmlDictCreate();
      xmlXPathContextPtr v6 = xmlXPathNewContext(0);
      *((void *)v2 + 8) = v6;
      if (!v6)
      {
        __xmlSimpleError(16, 2, 0, 0, (uint64_t)"allocating schema parser XPath context");
        xmlSchematronFreeParserCtxt((xmlSchematronParserCtxtPtr)v2);
        return 0;
      }
    }
    else
    {
      __xmlSimpleError(16, 2, 0, 0, (uint64_t)"allocating schema parser context");
    }
  }
  return (xmlSchematronParserCtxtPtr)v2;
}

xmlSchematronParserCtxtPtr xmlSchematronNewDocParserCtxt(xmlDocPtr doc)
{
  if (!doc) {
    return 0;
  }
  uint64_t v2 = (xmlSchematronParserCtxt *)xmlMalloc(0x90uLL);
  uint64_t v3 = v2;
  if (!v2)
  {
    __xmlSimpleError(16, 2, 0, 0, (uint64_t)"allocating schema parser context");
    return v3;
  }
  *((_OWORD *)v2 + 7) = 0u;
  *((_OWORD *)v2 + 8) = 0u;
  *((_OWORD *)v2 + 5) = 0u;
  *((_OWORD *)v2 + 6) = 0u;
  *((_OWORD *)v2 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0u;
  *((_OWORD *)v2 + xmlSAX2Text((uint64_t)ctx, (char *)value, len, 4) = 0u;
  *((_OWORD *)v2 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *(_OWORD *)uint64_t v2 = 0u;
  *((void *)v2 + 2) = doc;
  *((void *)v2 + 6) = xmlDictCreate();
  *((_DWORD *)v3 + 6) = 1;
  xmlXPathContextPtr v4 = xmlXPathNewContext(doc);
  *((void *)v3 + 8) = v4;
  if (!v4)
  {
    __xmlSimpleError(16, 2, 0, 0, (uint64_t)"allocating schema parser XPath context");
    xmlSchematronFreeParserCtxt(v3);
    return 0;
  }
  return v3;
}

xmlSchematronPtr xmlSchematronParse(xmlSchematronParserCtxtPtr ctxt)
{
  if (!ctxt) {
    return 0;
  }
  *((_DWORD *)ctxt + 1xmlSAX2Text((uint64_t)ctx, (char *)value, len, 4) = 0;
  uint64_t v2 = (const char *)*((void *)ctxt + 1);
  if (v2)
  {
    xmlDocPtr File = xmlReadFile(v2, 0, 2);
    if (File)
    {
      xmlXPathContextPtr v4 = File;
      int v5 = 0;
LABEL_8:
      int v9 = 1;
      goto LABEL_9;
    }
    xmlFreeFunc v17 = (const xmlChar *)*((void *)ctxt + 1);
    xmlURIPtr v18 = "xmlSchematronParse: could not load '%s'.\n";
    xmlSchematronParserCtxtPtr v19 = ctxt;
    int v20 = 1757;
LABEL_40:
    xmlSchematronPErr((uint64_t)v19, 0, v20, v18, v17);
    return 0;
  }
  xmlXPathContextPtr v6 = (const char *)*((void *)ctxt + 4);
  if (v6)
  {
    MemorxmlSchemaValPtr y = xmlReadMemory(v6, *((_DWORD *)ctxt + 10), 0, 0, 2);
    if (Memory)
    {
      xmlXPathContextPtr v4 = Memory;
      Memory->URL = xmlStrdup((const xmlChar *)"in_memory_buffer");
      int v8 = xmlDictLookup(*((xmlDictPtr *)ctxt + 6), (const xmlChar *)"in_memory_buffer", -1);
      int v5 = 0;
      *((void *)ctxt + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v8;
      goto LABEL_8;
    }
    xmlURIPtr v18 = "xmlSchematronParse: could not parse.\n";
    xmlSchematronParserCtxtPtr v19 = ctxt;
    int v20 = 1766;
    goto LABEL_39;
  }
  xmlXPathContextPtr v4 = (xmlDoc *)*((void *)ctxt + 2);
  if (!v4)
  {
    xmlURIPtr v18 = "xmlSchematronParse: could not parse.\n";
    xmlSchematronParserCtxtPtr v19 = ctxt;
    int v20 = 1758;
LABEL_39:
    xmlFreeFunc v17 = 0;
    goto LABEL_40;
  }
  int v9 = 0;
  int v5 = 1;
LABEL_9:
  *((_DWORD *)ctxt + 6) = v5;
  xmlNodePtr RootElement = xmlDocGetRootElement(v4);
  if (!RootElement)
  {
    xmlSchematronPErr((uint64_t)ctxt, (uint64_t)v4, 1759, "The schema has no document element.\n", 0);
    uint64_t v13 = 0;
    if (!v9) {
      return (xmlSchematronPtr)v13;
    }
    xmlFreeDoc(v4);
    return 0;
  }
  uint64_t v11 = (uint64_t)RootElement;
  if (RootElement->type != XML_ELEMENT_NODE
    || !RootElement->ns
    || !xmlStrEqual(RootElement->name, (const xmlChar *)"schema")
    || !xmlStrEqual(*(const xmlChar **)(*(void *)(v11 + 72) + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")&& !xmlStrEqual(*(const xmlChar **)(*(void *)(v11 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
  {
    xmlSchematronPErr((uint64_t)ctxt, v11, 1759, "The XML document '%s' is not a XML schematron document", *((const xmlChar **)ctxt + 1));
    uint64_t v13 = 0;
    goto LABEL_26;
  }
  int v12 = xmlMalloc(0x60uLL);
  uint64_t v13 = v12;
  if (!v12)
  {
    ++*((_DWORD *)ctxt + 14);
    __xmlSimpleError(16, 2, 0, 0, (uint64_t)"allocating schema");
    goto LABEL_26;
  }
  v12[4] = 0u;
  v12[5] = 0u;
  v12[2] = 0u;
  v12[3] = 0u;
  _OWORD *v12 = 0u;
  v12[1] = 0u;
  xmlURIPtr v14 = (xmlDict *)*((void *)ctxt + 6);
  *((void *)v13 + 5) = v14;
  xmlDictReference(v14);
  *((void *)ctxt + 9) = v13;
  uint64_t v15 = *(void *)(v11 + 24);
  if (!v15) {
    goto LABEL_22;
  }
  while (1)
  {
    if (*(_DWORD *)(v15 + 8) == 1)
    {
      uint64_t v16 = *(void *)(v15 + 72);
      if (v16)
      {
        if (xmlStrEqual(*(const xmlChar **)(v16 + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
          || xmlStrEqual(*(const xmlChar **)(*(void *)(v15 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
        {
          break;
        }
      }
    }
    uint64_t v15 = *(void *)(v15 + 48);
    if (!v15) {
      goto LABEL_22;
    }
  }
  if (*(_DWORD *)(v15 + 8) == 1
    && *(void *)(v15 + 72)
    && xmlStrEqual(*(const xmlChar **)(v15 + 16), (const xmlChar *)"title")
    && (xmlStrEqual(*(const xmlChar **)(*(void *)(v15 + 72) + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")|| xmlStrEqual(*(const xmlChar **)(*(void *)(v15 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron")))
  {
    Content = xmlNodeGetContent((const xmlNode *)v15);
    if (Content)
    {
      xmlAttrPtr v23 = Content;
      *((void *)v13 + 6) = xmlDictLookup(*((xmlDictPtr *)v13 + 5), Content, -1);
      xmlFree(v23);
    }
    uint64_t v15 = *(void *)(v15 + 48);
    if (!v15) {
      goto LABEL_22;
    }
    while (1)
    {
      if (*(_DWORD *)(v15 + 8) == 1)
      {
        uint64_t v24 = *(void *)(v15 + 72);
        if (v24)
        {
          if (xmlStrEqual(*(const xmlChar **)(v24 + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
            || xmlStrEqual(*(const xmlChar **)(*(void *)(v15 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
          {
            break;
          }
        }
      }
      uint64_t v15 = *(void *)(v15 + 48);
      if (!v15) {
        goto LABEL_22;
      }
    }
  }
  while (*(_DWORD *)(v15 + 8) == 1)
  {
    if (!*(void *)(v15 + 72)
      || !xmlStrEqual(*(const xmlChar **)(v15 + 16), (const xmlChar *)"ns")
      || !xmlStrEqual(*(const xmlChar **)(*(void *)(v15 + 72) + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")&& !xmlStrEqual(*(const xmlChar **)(*(void *)(v15 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
    {
      break;
    }
    NoNsProp = xmlGetNoNsProp((const xmlNode *)v15, (const xmlChar *)"prefix");
    int v26 = xmlGetNoNsProp((const xmlNode *)v15, (const xmlChar *)"uri");
    xmlDocPtr v27 = v26;
    if (!v26 || !*v26) {
      xmlSchematronPErr((uint64_t)ctxt, v15, 1759, "ns element has no uri", 0);
    }
    if (!NoNsProp || !*NoNsProp) {
      xmlSchematronPErr((uint64_t)ctxt, v15, 1759, "ns element has no prefix", 0);
    }
    if (!NoNsProp || !v27)
    {
      if (!v27) {
        goto LABEL_84;
      }
      goto LABEL_83;
    }
    xmlXPathRegisterNs(*((xmlXPathContextPtr *)ctxt + 8), NoNsProp, v27);
    int v28 = (void *)*((void *)ctxt + 11);
    if (v28)
    {
      uint64_t v29 = *((int *)ctxt + 21);
      if (*((_DWORD *)ctxt + 20) + 2 >= (int)v29)
      {
        uint64_t v30 = xmlRealloc(v28, 32 * v29);
        if (!v30) {
          goto LABEL_81;
        }
        *((void *)ctxt + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v30;
        *((_DWORD *)ctxt + 21) *= 2;
      }
    }
    else
    {
      *((_DWORD *)ctxt + 2htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 10;
      uint64_t v31 = xmlMalloc(0xA0uLL);
      *((void *)ctxt + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = v31;
      if (!v31)
      {
LABEL_81:
        __xmlSimpleError(16, 2, 0, 0, (uint64_t)"allocating parser namespaces");
        goto LABEL_82;
      }
      *((_DWORD *)ctxt + 20) = 0;
    }
    *(void *)(*((void *)ctxt + 11) + 16 * *((int *)ctxt + 20)) = xmlDictLookup(*((xmlDictPtr *)ctxt + 6), v27, -1);
    int v32 = xmlDictLookup(*((xmlDictPtr *)ctxt + 6), NoNsProp, -1);
    int v33 = *((_DWORD *)ctxt + 20);
    *(void *)(*((void *)ctxt + 11) + 8 * ((2 * v33) | 1)) = v32;
    *((_DWORD *)ctxt + 20) = v33 + 1;
    *(void *)(*((void *)ctxt + 11) + 16 * (v33 + 1)) = 0;
    *(void *)(*((void *)ctxt + 11) + 16 * (v33 + 1) + 8) = 0;
LABEL_82:
    ++*((_DWORD *)v13 + 14);
LABEL_83:
    xmlFree(v27);
LABEL_84:
    if (NoNsProp) {
      xmlFree(NoNsProp);
    }
    while (1)
    {
      uint64_t v15 = *(void *)(v15 + 48);
      if (!v15) {
        goto LABEL_22;
      }
      if (*(_DWORD *)(v15 + 8) == 1)
      {
        uint64_t v34 = *(void *)(v15 + 72);
        if (v34)
        {
          if (xmlStrEqual(*(const xmlChar **)(v34 + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
            || xmlStrEqual(*(const xmlChar **)(*(void *)(v15 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
          {
            break;
          }
        }
      }
    }
  }
LABEL_92:
  if (*(_DWORD *)(v15 + 8) != 1
    || !*(void *)(v15 + 72)
    || !xmlStrEqual(*(const xmlChar **)(v15 + 16), (const xmlChar *)"pattern")
    || !xmlStrEqual(*(const xmlChar **)(*(void *)(v15 + 72) + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")&& !xmlStrEqual(*(const xmlChar **)(*(void *)(v15 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
  {
    xmlSchematronPErr((uint64_t)ctxt, v15, 1759, "Expecting a pattern element instead of %s", *(const xmlChar **)(v15 + 16));
    goto LABEL_112;
  }
  uint64_t v35 = xmlGetNoNsProp((const xmlNode *)v15, (const xmlChar *)"id");
  if (!v35) {
    uint64_t v35 = xmlGetNoNsProp((const xmlNode *)v15, (const xmlChar *)"name");
  }
  if (!v35 || (uint64_t v36 = *((void *)ctxt + 9)) == 0)
  {
    if (!v35) {
      goto LABEL_122;
    }
    goto LABEL_121;
  }
  uint64_t v37 = xmlMalloc(0x18uLL);
  if (!v37)
  {
    ++*((_DWORD *)ctxt + 14);
    __xmlSimpleError(16, 2, v15, 0, (uint64_t)"allocating schema pattern");
LABEL_121:
    xmlFree(v35);
    goto LABEL_122;
  }
  uint64_t v38 = v37;
  v37[1] = 0;
  v37[2] = 0;
  *uint64_t v37 = 0;
  v37[2] = v35;
  int v41 = *(void **)(v36 + 64);
  int v40 = (void *)(v36 + 64);
  for (uint64_t i = v41; i; uint64_t i = (void *)*i)
    int v40 = i;
  *int v40 = v37;
  uint64_t k = *(void *)(v15 + 24);
  if (!k) {
    goto LABEL_110;
  }
  while (1)
  {
    if (*(_DWORD *)(k + 8) == 1)
    {
      uint64_t v43 = *(void *)(k + 72);
      if (v43)
      {
        if (xmlStrEqual(*(const xmlChar **)(v43 + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
          || xmlStrEqual(*(const xmlChar **)(*(void *)(k + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
        {
          break;
        }
      }
    }
    uint64_t k = *(void *)(k + 48);
    if (!k) {
      goto LABEL_110;
    }
  }
  int v76 = 0;
  uint64_t v75 = v38 + 1;
LABEL_124:
  if (*(_DWORD *)(k + 8) != 1
    || !*(void *)(k + 72)
    || !xmlStrEqual(*(const xmlChar **)(k + 16), (const xmlChar *)"rule")
    || !xmlStrEqual(*(const xmlChar **)(*(void *)(k + 72) + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")&& !xmlStrEqual(*(const xmlChar **)(*(void *)(k + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
  {
    xmlSchematronPErr((uint64_t)ctxt, k, 1759, "Expecting a rule element instead of %s", *(const xmlChar **)(k + 16));
    goto LABEL_149;
  }
  int v45 = xmlGetNoNsProp((const xmlNode *)k, (const xmlChar *)"context");
  if (!v45)
  {
    xmlSchematronParserCtxtPtr v56 = ctxt;
    uint64_t v57 = k;
    unsigned int v58 = "rule has no context attribute";
    goto LABEL_157;
  }
  int v46 = v45;
  if (!*v45)
  {
    xmlSchematronPErr((uint64_t)ctxt, k, 1759, "rule has an empty context attribute", 0);
LABEL_160:
    xmlFree(v46);
    goto LABEL_161;
  }
  uint64_t v47 = *((void *)ctxt + 9);
  if (!v47) {
    goto LABEL_160;
  }
  xmlPatternPtr v72 = xmlPatterncompile(v45, *((xmlDict **)ctxt + 6), 1, *((const xmlChar ***)ctxt + 11));
  if (!v72) {
    xmlSchematronPErr((uint64_t)ctxt, k, 1759, "Failed to compile context expression %s", v46);
  }
  long long v74 = xmlMalloc(0x38uLL);
  if (!v74)
  {
    ++*((_DWORD *)ctxt + 14);
    __xmlSimpleError(16, 2, k, 0, (uint64_t)"allocating schema rule");
    goto LABEL_160;
  }
  v74[1] = 0u;
  v74[2] = 0u;
  _OWORD *v74 = 0u;
  *((void *)v74 + 2) = k;
  *((void *)v74 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = v46;
  *((void *)v74 + 5) = v72;
  *((void *)v74 + 6) = 0;
  *(void *)long long v74 = 0;
  int v50 = *(void **)(v47 + 72);
  int v49 = (void *)(v47 + 72);
  for (uint64_t j = v50; j; uint64_t j = (void *)*j)
    int v49 = j;
  BOOL v51 = v75;
  void *v49 = v74;
  *((void *)v74 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0;
  uint64_t v52 = *v75;
  if (*v75)
  {
    do
    {
      uint64_t v53 = v52;
      uint64_t v52 = *(void *)(v52 + 8);
    }
    while (v52);
    BOOL v51 = (void *)(v53 + 8);
  }
  void *v51 = v74;
  if (!*(void *)(k + 24))
  {
LABEL_147:
    xmlSchematronParserCtxtPtr v56 = ctxt;
    uint64_t v57 = k;
    unsigned int v58 = "rule has no assert nor report element";
LABEL_157:
    xmlSchematronPErr((uint64_t)v56, v57, 1759, v58, 0);
    goto LABEL_161;
  }
  uint64_t v54 = *(void *)(k + 24);
  while (1)
  {
    if (*(_DWORD *)(v54 + 8) == 1)
    {
      uint64_t v55 = *(void *)(v54 + 72);
      if (v55)
      {
        if (xmlStrEqual(*(const xmlChar **)(v55 + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
          || xmlStrEqual(*(const xmlChar **)(*(void *)(v54 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
        {
          break;
        }
      }
    }
    uint64_t v54 = *(void *)(v54 + 48);
    if (!v54) {
      goto LABEL_147;
    }
  }
  int v73 = 0;
  while (1)
  {
    if (*(_DWORD *)(v54 + 8) != 1)
    {
LABEL_181:
      uint64_t v66 = v54;
      int v67 = *(const xmlChar **)(v54 + 16);
      xmlSchematronParserCtxtPtr v68 = ctxt;
      uint64_t v69 = "Expecting an assert or a report element instead of %s";
LABEL_182:
      xmlSchematronPErr((uint64_t)v68, v66, 1759, v69, v67);
      goto LABEL_183;
    }
    if (*(void *)(v54 + 72)
      && xmlStrEqual(*(const xmlChar **)(v54 + 16), (const xmlChar *)"assert")
      && (xmlStrEqual(*(const xmlChar **)(*(void *)(v54 + 72) + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")|| xmlStrEqual(*(const xmlChar **)(*(void *)(v54 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron")))
    {
      ++v73;
      long long v60 = xmlGetNoNsProp((const xmlNode *)v54, (const xmlChar *)"test");
      if (!v60) {
        goto LABEL_191;
      }
      long long v61 = v60;
      if (*v60)
      {
        uint64_t v71 = v54;
        __int16 v62 = xmlNodeGetContent((const xmlNode *)v54);
        xmlSchematronParserCtxtPtr v63 = ctxt;
        int v64 = 1;
        goto LABEL_179;
      }
    }
    else
    {
      if (*(_DWORD *)(v54 + 8) != 1
        || !*(void *)(v54 + 72)
        || !xmlStrEqual(*(const xmlChar **)(v54 + 16), (const xmlChar *)"report")
        || !xmlStrEqual(*(const xmlChar **)(*(void *)(v54 + 72) + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")&& !xmlStrEqual(*(const xmlChar **)(*(void *)(v54 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
      {
        goto LABEL_181;
      }
      ++v73;
      uint64_t v65 = xmlGetNoNsProp((const xmlNode *)v54, (const xmlChar *)"test");
      if (!v65)
      {
LABEL_191:
        xmlSchematronParserCtxtPtr v68 = ctxt;
        uint64_t v66 = v54;
        uint64_t v69 = "assert has no test attribute";
        int v67 = 0;
        goto LABEL_182;
      }
      long long v61 = v65;
      if (*v65)
      {
        uint64_t v71 = v54;
        __int16 v62 = xmlNodeGetContent((const xmlNode *)v54);
        xmlSchematronParserCtxtPtr v63 = ctxt;
        int v64 = 2;
LABEL_179:
        if (xmlSchematronAddTest((uint64_t)v63, v64, (uint64_t)v74, v71, v61, (uint64_t)v62)) {
          goto LABEL_183;
        }
        goto LABEL_193;
      }
    }
    xmlSchematronPErr((uint64_t)ctxt, v54, 1759, "assert has an empty test attribute", 0);
LABEL_193:
    xmlFree(v61);
LABEL_183:
    if (!*(void *)(v54 + 48)) {
      break;
    }
    uint64_t v54 = *(void *)(v54 + 48);
    while (1)
    {
      if (*(_DWORD *)(v54 + 8) == 1)
      {
        uint64_t v70 = *(void *)(v54 + 72);
        if (v70)
        {
          if (xmlStrEqual(*(const xmlChar **)(v70 + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
            || xmlStrEqual(*(const xmlChar **)(*(void *)(v54 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
          {
            break;
          }
        }
      }
      uint64_t v54 = *(void *)(v54 + 48);
      if (!v54) {
        goto LABEL_194;
      }
    }
  }
LABEL_194:
  if (!v73) {
    goto LABEL_147;
  }
LABEL_161:
  ++v76;
LABEL_149:
  for (uint64_t k = *(void *)(k + 48); k; uint64_t k = *(void *)(k + 48))
  {
    if (*(_DWORD *)(k + 8) == 1)
    {
      uint64_t v59 = *(void *)(k + 72);
      if (v59)
      {
        if (xmlStrEqual(*(const xmlChar **)(v59 + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
          || xmlStrEqual(*(const xmlChar **)(*(void *)(k + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
        {
          goto LABEL_124;
        }
      }
    }
  }
  if (!v76) {
LABEL_110:
  }
    xmlSchematronPErr((uint64_t)ctxt, v15, 1759, "Pattern has no rule element", 0);
LABEL_122:
  ++*((_DWORD *)v13 + 15);
LABEL_112:
  while (1)
  {
    uint64_t v15 = *(void *)(v15 + 48);
    if (!v15) {
      break;
    }
    if (*(_DWORD *)(v15 + 8) == 1)
    {
      uint64_t v44 = *(void *)(v15 + 72);
      if (v44)
      {
        if (xmlStrEqual(*(const xmlChar **)(v44 + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
          || xmlStrEqual(*(const xmlChar **)(*(void *)(v15 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
        {
          goto LABEL_92;
        }
      }
    }
  }
LABEL_22:
  if (*((_DWORD *)v13 + 15))
  {
    *((void *)v13 + 2) = v4;
    if ((v9 & 1) == 0) {
      *((_DWORD *)v13 + 2) = 1;
    }
    goto LABEL_29;
  }
  xmlSchematronPErr((uint64_t)ctxt, v11, 1759, "The schematron document '%s' has no pattern", *((const xmlChar **)ctxt + 1));
LABEL_26:
  if (v9) {
    xmlFreeDoc(v4);
  }
  if (v13)
  {
LABEL_29:
    if (*((_DWORD *)ctxt + 14))
    {
      xmlSchematronFree((xmlSchematronPtr)v13);
      return 0;
    }
    *((void *)v13 + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = *((void *)ctxt + 11);
    *((_DWORD *)v13 + 20) = *((_DWORD *)ctxt + 20);
    *((void *)ctxt + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0;
  }
  return (xmlSchematronPtr)v13;
}

_DWORD *xmlSchematronPErr(uint64_t a1, uint64_t a2, int a3, const char *a4, const xmlChar *a5)
{
  return __xmlRaiseError(*(xmlStructuredErrorFunc *)(a1 + 136), *(void (**)(void *, const char *, ...))(a1 + 120), *(void **)(a1 + 112), (void *)a1, a2, 0x10u, a3, 2, 0, 0, a5, 0, 0, 0, 0, a4, (char)a5);
}

void xmlSchematronSetValidStructuredErrors(xmlSchematronValidCtxtPtr ctxt, xmlStructuredErrorFunc serror, void *ctx)
{
  if (ctxt)
  {
    *((void *)ctxt + 12) = 0;
    *((void *)ctxt + 1xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = serror;
    *((void *)ctxt + 10) = ctx;
    *((void *)ctxt + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0;
  }
}

xmlSchematronValidCtxtPtr xmlSchematronNewValidCtxt(xmlSchematronPtr schema, int options)
{
  xmlXPathContextPtr v4 = xmlMalloc(0x70uLL);
  int v5 = v4;
  if (v4)
  {
    _OWORD *v4 = 0u;
    v4[1] = 0u;
    v4[5] = 0u;
    v4[6] = 0u;
    v4[3] = 0u;
    v4[4] = 0u;
    v4[2] = 0u;
    *(_DWORD *)xmlXPathContextPtr v4 = 2;
    *((void *)v4 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = schema;
    xmlXPathContextPtr v6 = xmlXPathNewContext(0);
    *((void *)v5 + xmlSAX2Text((uint64_t)ctx, (char *)value, len, 4) = v6;
    *((_DWORD *)v5 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = options;
    if (v6)
    {
      if (*((int *)schema + 20) >= 1)
      {
        uint64_t v7 = 0;
        uint64_t v8 = 0;
        do
        {
          uint64_t v9 = *((void *)schema + 11);
          uint64_t v10 = *(const xmlChar **)(v9 + v7);
          if (!v10) {
            break;
          }
          uint64_t v11 = *(const xmlChar **)(v9 + v7 + 8);
          if (!v11) {
            break;
          }
          xmlXPathRegisterNs(*((xmlXPathContextPtr *)v5 + 4), v11, v10);
          ++v8;
          v7 += 16;
        }
        while (v8 < *((int *)schema + 20));
      }
    }
    else
    {
      __xmlSimpleError(16, 2, 0, 0, (uint64_t)"allocating schema parser XPath context");
      xmlSchematronFreeValidCtxt((xmlSchematronValidCtxtPtr)v5);
      return 0;
    }
  }
  else
  {
    __xmlSimpleError(17, 2, 0, 0, (uint64_t)"allocating validation context");
  }
  return (xmlSchematronValidCtxtPtr)v5;
}

void xmlSchematronFreeValidCtxt(xmlSchematronValidCtxtPtr ctxt)
{
  if (ctxt)
  {
    uint64_t v2 = (xmlXPathContext *)*((void *)ctxt + 4);
    if (v2) {
      xmlXPathFreeContext(v2);
    }
    uint64_t v3 = (xmlDict *)*((void *)ctxt + 1);
    if (v3) {
      xmlDictFree(v3);
    }
    xmlFreeFunc v4 = xmlFree;
    ((void (*)(xmlSchematronValidCtxtPtr))v4)(ctxt);
  }
}

int xmlSchematronValidateDoc(xmlSchematronValidCtxtPtr ctxt, xmlDocPtr instance)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!ctxt) {
    return -1;
  }
  uint64_t v3 = *((void *)ctxt + 3);
  if (!v3) {
    return -1;
  }
  int result = -1;
  if (instance && *(void *)(v3 + 72))
  {
    *((_DWORD *)ctxt + xmlSAX2Text((uint64_t)ctx, (char *)value, len, 4) = 0;
    xmlNodePtr RootElement = xmlDocGetRootElement(instance);
    if (RootElement)
    {
      Node = RootElement;
      int v8 = *((_DWORD *)ctxt + 1);
      if (!v8 || (v8 & 1) != 0)
      {
        do
        {
          for (uint64_t i = *(void **)(*((void *)ctxt + 3) + 72); i; uint64_t i = (void *)*i)
          {
            if (xmlPatternMatch((xmlPatternPtr)i[5], Node) == 1)
            {
              for (uint64_t j = (void *)i[4]; j; uint64_t j = (void *)*j)
                xmlSchematronRunTest((uint64_t)ctxt, (uint64_t)j, instance, Node, i[5]);
            }
          }
          Node = (xmlNode *)xmlSchematronNextNode((uint64_t)Node);
        }
        while (Node);
      }
      else
      {
        for (uint64_t k = *(void *)(*((void *)ctxt + 3) + 64); k; uint64_t k = *(void *)k)
        {
          int v10 = *((_DWORD *)ctxt + 1);
          if ((v10 & 9) == 0)
          {
            if ((v10 & 4) != 0)
            {
              xmlGenericErrorFunc v11 = *__xmlGenericError();
              int v12 = __xmlGenericErrorContext();
              v11(*v12, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/schematron.c", 1460);
            }
            else
            {
              bzero(__str, 0x3E8uLL);
              if (*(void *)(k + 16))
              {
                snprintf(__str, 0x3E7uLL, "Pattern: %s\n", *(const char **)(k + 16));
                fputs(__str, (FILE *)*MEMORY[0x1E4F143C8]);
              }
            }
          }
          uint64_t v13 = Node;
          do
          {
            for (uint64_t m = *(void *)(k + 8); m; uint64_t m = *(void *)(m + 8))
            {
              if (xmlPatternMatch(*(xmlPatternPtr *)(m + 40), v13) == 1)
              {
                for (uint64_t n = *(void **)(m + 32); n; uint64_t n = (void *)*n)
                  xmlSchematronRunTest((uint64_t)ctxt, (uint64_t)n, instance, v13, k);
              }
            }
            uint64_t v13 = (xmlNode *)xmlSchematronNextNode((uint64_t)v13);
          }
          while (v13);
        }
      }
      return *((_DWORD *)ctxt + 4);
    }
    else
    {
      xmlGenericErrorFunc v18 = *__xmlGenericError();
      xmlSchematronParserCtxtPtr v19 = __xmlGenericErrorContext();
      v18(*v19, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/schematron.c", 1684);
      ++*((_DWORD *)ctxt + 4);
      return 1;
    }
  }
  return result;
}

void xmlSchematronRunTest(uint64_t a1, uint64_t a2, xmlDoc *a3, const xmlNode *a4, uint64_t a5)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(xmlXPathContext **)(a1 + 32);
  v9->xmlDocPtr doc = a3;
  v9->xmlNodePtr node = (xmlNodePtr)a4;
  xmlXPathObjectPtr v10 = xmlXPathCompiledEval(*(xmlXPathCompExprPtr *)(a2 + 32), v9);
  if (v10)
  {
    xmlGenericErrorFunc v11 = v10;
    switch(v10->type)
    {
      case XPATH_UNDEFINED:
      case XPATH_POINT:
      case XPATH_RANGE:
      case XPATH_LOCATIONSET:
      case XPATH_USERS:
        goto LABEL_3;
      case XPATH_NODESET:
      case XPATH_XSLT_TREE:
        p_nodeNr = &v10->nodesetval->nodeNr;
        if (!p_nodeNr || !*p_nodeNr) {
          goto LABEL_3;
        }
        goto LABEL_19;
      case XPATH_BOOLEAN:
        BOOLxmlSchemaValPtr val = v10->BOOLval;
        xmlXPathFreeObject(v10);
        if (!BOOLval) {
          break;
        }
        goto LABEL_20;
      case XPATH_NUMBER:
        if (!xmlXPathIsNaN(v10->floatval) && v11->floatval != 0.0) {
          goto LABEL_19;
        }
        goto LABEL_3;
      case XPATH_STRING:
        stringxmlSchemaValPtr val = v10->stringval;
        if (stringval && *stringval) {
          goto LABEL_19;
        }
LABEL_3:
        xmlXPathFreeObject(v11);
        break;
      default:
LABEL_19:
        xmlXPathFreeObject(v11);
LABEL_20:
        int v12 = *(_DWORD *)(a2 + 8);
        if (v12 == 2) {
          ++*(_DWORD *)(a1 + 16);
        }
        int v15 = 1;
        goto LABEL_23;
    }
  }
  int v12 = *(_DWORD *)(a2 + 8);
  if (v12 != 1)
  {
    int v15 = 2;
LABEL_23:
    xmlURIPtr v14 = (unsigned char *)(a1 + 4);
    int v13 = *(_DWORD *)(a1 + 4);
    if ((v13 & 5) == 1)
    {
      if (v12 == 2) {
        return;
      }
      goto LABEL_27;
    }
LABEL_26:
    if ((v13 & 4) != 0)
    {
      xmlGenericErrorFunc v38 = *__xmlGenericError();
      uint64_t v39 = __xmlGenericErrorContext();
      v38(*v39, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/schematron.c", 1383);
      return;
    }
LABEL_27:
    bzero(__str, 0x3E8uLL);
    if (v12 == v15) {
      return;
    }
    goto LABEL_28;
  }
  xmlURIPtr v14 = (unsigned char *)(a1 + 4);
  int v13 = *(_DWORD *)(a1 + 4);
  ++*(_DWORD *)(a1 + 16);
  if ((v13 & 5) != 1)
  {
    int v12 = 1;
    int v15 = 2;
    goto LABEL_26;
  }
  bzero(__str, 0x3E8uLL);
LABEL_28:
  uint64_t LineNo = xmlGetLineNo(a4);
  NodePath = xmlGetNodePath(a4);
  if (!NodePath) {
    NodePath = (xmlChar *)a4->name;
  }
  uint64_t v21 = *(void *)(a2 + 16);
  if (!v21 || (uint64_t v22 = *(void *)(v21 + 24)) == 0)
  {
LABEL_72:
    if (*(_DWORD *)(a2 + 8) == 1) {
      int v40 = "node failed assert";
    }
    else {
      int v40 = "node failed report";
    }
    xmlAttrPtr v23 = xmlStrdup((const xmlChar *)v40);
    goto LABEL_76;
  }
  xmlAttrPtr v23 = 0;
  do
  {
    int v24 = *(_DWORD *)(v22 + 8);
    if (v24 == 1)
    {
      if (!*(void *)(v22 + 72)
        || !xmlStrEqual(*(const xmlChar **)(v22 + 16), (const xmlChar *)"name")
        || !xmlStrEqual(*(const xmlChar **)(*(void *)(v22 + 72) + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")&& !xmlStrEqual(*(const xmlChar **)(*(void *)(v22 + 72) + 16), (const xmlChar *)"http://www.ascc.net/xml/schematron"))
      {
        goto LABEL_40;
      }
      uint64_t v46 = a5;
      NoNsProp = xmlGetNoNsProp((const xmlNode *)v22, (const xmlChar *)"path");
      xmlDocPtr v27 = a4;
      if (NoNsProp)
      {
        int v28 = *(xmlXPathContext **)(a1 + 32);
        v28->xmlDocPtr doc = a4->doc;
        v28->xmlNodePtr node = (xmlNodePtr)a4;
        int v45 = NoNsProp;
        xmlXPathObjectPtr v29 = xmlXPathEval(NoNsProp, v28);
        if (v29)
        {
          if (v29->type == XPATH_NODESET && (xmlNodeSetPtr nodesetval = v29->nodesetval) != 0 && nodesetval->nodeNr >= 1) {
            xmlDocPtr v27 = *nodesetval->nodeTab;
          }
          else {
            xmlDocPtr v27 = 0;
          }
          xmlXPathFreeObject(v29);
        }
        else
        {
          xmlDocPtr v27 = 0;
        }
        if (!v27) {
          xmlDocPtr v27 = a4;
        }
        xmlFree(v45);
      }
      xmlNsPtr ns = v27->ns;
      if (ns)
      {
        prefix = ns->prefix;
        if (prefix)
        {
          int v33 = xmlStrcat(v23, prefix);
          xmlAttrPtr v23 = xmlStrcat(v33, (const xmlChar *)":");
        }
      }
      p_name = &v27->name;
      a5 = v46;
    }
    else
    {
      if ((v24 - 3) > 1) {
        goto LABEL_40;
      }
      p_name = (const xmlChar **)(v22 + 80);
    }
    uint64_t v34 = xmlStrcat(v23, *p_name);
    xmlAttrPtr v23 = v34;
    if (v34)
    {
      int v35 = xmlStrlen(v34);
      if (v35 >= 1)
      {
        unsigned int v36 = v23[v35 - 1];
        if (v36 <= 0x20 && ((1 << v36) & 0x100002600) != 0)
        {
          while (v36 <= 0x20u && ((1 << v36) & 0x100002600) != 0)
          {
            if (v35 == 1)
            {
              int v35 = 0;
              break;
            }
            LOBYTE(v36) = v23[v35 - 2];
            --v35;
          }
          v23[v35] = 32;
          v23[v35 + 1] = 0;
        }
      }
    }
LABEL_40:
    uint64_t v22 = *(void *)(v22 + 48);
  }
  while (v22);
  if (!v23) {
    goto LABEL_72;
  }
LABEL_76:
  snprintf(__str, 0x3E7uLL, "%s line %ld: %s\n", (const char *)NodePath, LineNo, (const char *)v23);
  if ((*v14 & 8) != 0)
  {
    int v41 = *(void (__cdecl **)(void *, xmlErrorPtr))(a1 + 104);
    if (v41) {
      uint64_t v42 = 0;
    }
    else {
      uint64_t v42 = *(void (**)(void *, const char *, ...))(a1 + 88);
    }
    if (*(_DWORD *)(a2 + 8) == 1) {
      int v43 = 4000;
    }
    else {
      int v43 = 4001;
    }
    if (a5) {
      uint64_t v44 = *(const xmlChar **)(a5 + 16);
    }
    else {
      uint64_t v44 = 0;
    }
    __xmlRaiseError(v41, v42, *(void **)(a1 + 80), 0, (uint64_t)a4, 0x1Cu, v43, 2, 0, LineNo, v44, NodePath, v23, 0, 0, "%s", (char)__str);
  }
  else
  {
    fputs(__str, (FILE *)*MEMORY[0x1E4F143C8]);
  }
  xmlFree(v23);
  if (NodePath)
  {
    if (NodePath != a4->name) {
      xmlFree(NodePath);
    }
  }
}

uint64_t xmlSchematronNextNode(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    int v3 = *(_DWORD *)(result + 8);
    if (v3 != 17)
    {
      if (v3 != 14) {
        return result;
      }
      uint64_t v1 = result;
    }
  }
  uint64_t v4 = *(void *)(v1 + 48);
  uint64_t result = v1;
  if (!v4) {
    goto LABEL_14;
  }
  while (1)
  {
    uint64_t result = v4;
    int v5 = *(_DWORD *)(v4 + 8);
    if (v5 != 17 && v5 != 14) {
      break;
    }
    uint64_t v4 = *(void *)(v4 + 48);
    if (!v4)
    {
LABEL_14:
      while (1)
      {
        uint64_t result = *(void *)(result + 40);
        if (!result) {
          break;
        }
        if (*(_DWORD *)(result + 8) == 9) {
          return 0;
        }
        if (*(void *)(result + 48)) {
          return *(void *)(result + 48);
        }
      }
      return result;
    }
  }
  return result;
}

_OWORD *xmlSchematronAddTest(uint64_t a1, int a2, uint64_t a3, uint64_t a4, xmlChar *str, uint64_t a6)
{
  xmlXPathCompExprPtr v12 = xmlXPathCtxtCompile(*(xmlXPathContextPtr *)(a1 + 64), str);
  if (!v12)
  {
    xmlSchematronPErr(a1, a4, 1759, "Failed to compile test expression %s", str);
    return 0;
  }
  xmlXPathCompExprPtr v13 = v12;
  uint64_t result = xmlMalloc(0x30uLL);
  if (!result)
  {
    ++*(_DWORD *)(a1 + 56);
    __xmlSimpleError(16, 2, a4, 0, (uint64_t)"allocating schema test");
    return 0;
  }
  _OWORD *result = 0u;
  result[1] = 0u;
  result[2] = 0u;
  *((_DWORD *)result + 2) = a2;
  *((void *)result + 2) = a4;
  *((void *)result + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = str;
  *((void *)result + xmlSAX2Text((uint64_t)ctx, (char *)value, len, 4) = v13;
  *((void *)result + 5) = a6;
  *(void *)uint64_t result = 0;
  int v15 = *(void **)(a3 + 32);
  if (v15)
  {
    do
    {
      uint64_t v16 = v15;
      int v15 = (void *)*v15;
    }
    while (v15);
    *uint64_t v16 = result;
  }
  else
  {
    *(void *)(a3 + 32) = result;
  }
  return result;
}

void xmlFreeMutex(xmlMutexPtr tok)
{
  if (tok)
  {
    pthread_mutex_destroy((pthread_mutex_t *)tok);
    free(tok);
  }
}

void xmlFreeRMutex(xmlRMutexPtr tok)
{
  if (tok)
  {
    pthread_mutex_destroy((pthread_mutex_t *)tok);
    pthread_cond_destroy((pthread_cond_t *)((char *)tok + 80));
    free(tok);
  }
}

int xmlGetThreadId(void)
{
  return pthread_self();
}

void xmlFreeGlobalState(uint64_t a1)
{
  xmlResetError((xmlErrorPtr)(a1 + 856));

  free((void *)a1);
}

xmlChar *__cdecl xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix, xmlChar *memory, int len)
{
  uint64_t v4 = ncname;
  if (ncname && prefix)
  {
    int v8 = strlen((const char *)ncname);
    int v9 = strlen((const char *)prefix);
    int v10 = v9;
    if (memory && v8 + v9 + 2 <= len)
    {
      unint64_t v13 = (unint64_t)(v9 + v8) << 32;
    }
    else
    {
      uint64_t v11 = (v9 + v8);
      xmlXPathCompExprPtr v12 = (xmlChar *)xmlMallocAtomic(((v11 << 32) + 0x200000000) >> 32);
      if (!v12)
      {
        __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building QName");
        return 0;
      }
      memorxmlSchemaValPtr y = v12;
      unint64_t v13 = v11 << 32;
    }
    memcpy(memory, prefix, v10);
    memory[v10] = 58;
    memcpy(&memory[v10 + 1], v4, v8);
    memory[(uint64_t)(v13 + 0x100000000) >> 32] = 0;
    return memory;
  }
  return (xmlChar *)v4;
}

xmlChar *__cdecl xmlSplitQName2(const xmlChar *name, xmlChar **prefix)
{
  if (!prefix) {
    return 0;
  }
  const xmlChar *prefix = 0;
  if (!name) {
    return 0;
  }
  int v4 = *name;
  if (v4 == 58) {
    return 0;
  }
  uint64_t v6 = 1;
  if (!*name) {
    return 0;
  }
  while (v4 != 58)
  {
    int v4 = name[v6++];
    if (!v4) {
      return 0;
    }
  }
  uint64_t v7 = xmlStrndup(name, (int)v6 - 1);
  const xmlChar *prefix = v7;
  if (!v7)
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"QName split");
    return 0;
  }
  uint64_t result = xmlStrdup(&name[v6]);
  if (!result)
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"QName split");
    uint64_t result = *prefix;
    if (*prefix)
    {
      xmlFree(result);
      uint64_t result = 0;
      const xmlChar *prefix = 0;
    }
  }
  return result;
}

const xmlChar *__cdecl xmlSplitQName3(const xmlChar *name, int *len)
{
  uint64_t v2 = 0;
  if (name && len)
  {
    int v3 = *name;
    if (v3 == 58) {
      return 0;
    }
    uint64_t v4 = 1;
    if (!*name)
    {
      return 0;
    }
    else
    {
      while (v3 != 58)
      {
        int v3 = name[v4++];
        if (!v3) {
          return 0;
        }
      }
      *int len = v4 - 1;
      return &name[v4];
    }
  }
  return v2;
}

int xmlValidateNCName(const xmlChar *value, int space)
{
  if (!value) {
    return -1;
  }
  int v3 = value;
  if (space)
  {
    for (uint64_t i = value; ; ++i)
    {
      unsigned int v5 = *i;
      if (v5 > 0x20 || ((1 << v5) & 0x100002600) == 0) {
        break;
      }
    }
  }
  else
  {
    unsigned int v5 = *value;
    uint64_t i = value;
  }
  int len = 0;
  if (v5 - 97 < 0x1A || v5 == 95 || v5 - 65 <= 0x19)
  {
    do
    {
      int v8 = i;
      unsigned int v10 = *++i;
      unsigned int v9 = v10;
      unsigned int v11 = (v10 & 0xFFFFFFDF) - 65;
    }
    while (v10 - 48 < 0xA
         || v11 < 0x1A
         || v9 - 45 <= 0x32 && ((1 << (v9 - 45)) & 0x4000000000003) != 0);
    if (space)
    {
      uint64_t v14 = 2;
      while (v9 <= 0x20 && ((1 << v9) & 0x100002600) != 0)
        unsigned int v9 = v8[v14++];
    }
    if (!v9) {
      return 0;
    }
  }
  int v15 = xmlStringCurrentChar(0, value, &len);
  signed int v16 = v15;
  if (space)
  {
    if (v15 <= 255)
    {
      while (v16 <= 0x20 && ((1 << v16) & 0x100002600) != 0)
      {
        v3 += len;
        signed int v16 = xmlStringCurrentChar(0, v3, &len);
        if (v16 >= 256) {
          goto LABEL_44;
        }
      }
      goto LABEL_38;
    }
  }
  else if (v15 < 256)
  {
LABEL_38:
    if ((v16 - 192) < 0x17
      || (v16 & 0xFFFFFFDF) - 65 < 0x1A
      || v16 > 247
      || (v16 - 216) < 0x1F
      || v16 == 95)
    {
      goto LABEL_55;
    }
    return 1;
  }
LABEL_44:
  if (xmlCharInRange(v16, &xmlIsBaseCharGroup)) {
    BOOL v17 = 1;
  }
  else {
    BOOL v17 = (v16 - 12330) > 0xFFFFFFF6;
  }
  if (!v17 && v16 != 12295 && (v16 - 40870) < 0xFFFFAE5A) {
    return 1;
  }
  do
  {
    while (1)
    {
      do
      {
        do
        {
LABEL_55:
          while (1)
          {
            v3 += len;
            signed int v20 = xmlStringCurrentChar(0, v3, &len);
            signed int v21 = v20;
            if (v20 > 255) {
              break;
            }
            BOOL v22 = (v20 - 192) >= 0x17 && (v20 & 0xFFFFFFDF) - 65 >= 0x1A;
            if (v22 && (v20 - 48) >= 0xA && v20 <= 247 && (v20 - 216) >= 0x1F) {
              goto LABEL_79;
            }
          }
          if (xmlCharInRange(v20, &xmlIsBaseCharGroup)) {
            BOOL v24 = 0;
          }
          else {
            BOOL v24 = (v21 - 12321) >= 9;
          }
          BOOL v26 = v24 && v21 != 12295 && (v21 - 19968) >= 0x51A6;
        }
        while (!v26 || xmlCharInRange(v21, &xmlIsDigitGroup));
LABEL_79:
        ;
      }
      while ((v21 - 45) <= 0x32 && ((1 << (v21 - 45)) & 0x4000000000003) != 0);
      if (v21 >= 256) {
        break;
      }
      if (v21 != 183) {
        goto LABEL_89;
      }
    }
  }
  while (xmlCharInRange(v21, &xmlIsCombiningGroup) || xmlCharInRange(v21, &xmlIsExtenderGroup));
LABEL_89:
  if (space && v21 <= 255)
  {
    do
    {
      if (v21 > 0x20) {
        break;
      }
      if (((1 << v21) & 0x100002600) == 0) {
        break;
      }
      v3 += len;
      signed int v21 = xmlStringCurrentChar(0, v3, &len);
    }
    while (v21 < 256);
  }
  return v21 != 0;
}

int xmlValidateQName(const xmlChar *value, int space)
{
  if (!value) {
    return -1;
  }
  int v3 = value;
  if (space)
  {
    for (uint64_t i = value; ; ++i)
    {
      unsigned int v5 = *i;
      if (v5 > 0x20 || ((1 << v5) & 0x100002600) == 0) {
        break;
      }
    }
  }
  else
  {
    unsigned int v5 = *value;
    uint64_t i = value;
  }
  int len = 0;
  if (v5 - 97 < 0x1A || v5 == 95 || v5 - 65 <= 0x19)
  {
    do
    {
      unsigned int v9 = *++i;
      unsigned int v8 = v9;
      unsigned int v10 = (v9 & 0xFFFFFFDF) - 65;
      BOOL v11 = v9 - 48 >= 0xA && v10 >= 0x1A;
    }
    while (!v11 || v8 - 45 < 2 || v8 == 95);
    if (v8 != 58)
    {
LABEL_34:
      if (space)
      {
        int v15 = (unsigned __int8 *)(i + 1);
        while (v8 <= 0x20 && ((1 << v8) & 0x100002600) != 0)
        {
          unsigned int v16 = *v15++;
          unsigned int v8 = v16;
        }
      }
      if (!v8) {
        return 0;
      }
      goto LABEL_40;
    }
    int v12 = i[1];
    if ((v12 - 97) < 0x1A || v12 == 95 || (v12 - 65) <= 0x19)
    {
      for (i += 2; ; ++i)
      {
        unsigned int v8 = *i;
        if (v8 - 48 >= 0xA
          && (v8 & 0xFFFFFFDF) - 65 >= 0x1A
          && (v8 - 45 > 0x32 || ((1 << (v8 - 45)) & 0x4000000000003) == 0))
        {
          break;
        }
      }
      goto LABEL_34;
    }
  }
LABEL_40:
  int v17 = xmlStringCurrentChar(0, value, &len);
  signed int v18 = v17;
  if (space)
  {
    if (v17 <= 255)
    {
      while (v18 <= 0x20 && ((1 << v18) & 0x100002600) != 0)
      {
        v3 += len;
        signed int v18 = xmlStringCurrentChar(0, v3, &len);
        if (v18 >= 256) {
          goto LABEL_53;
        }
      }
LABEL_47:
      if ((v18 - 192) < 0x17
        || (v18 & 0xFFFFFFDF) - 65 < 0x1A
        || v18 > 247
        || (v18 - 216) < 0x1F
        || v18 == 95)
      {
        goto LABEL_64;
      }
      return 1;
    }
  }
  else if (v17 < 256)
  {
    goto LABEL_47;
  }
LABEL_53:
  if (xmlCharInRange(v18, &xmlIsBaseCharGroup)) {
    BOOL v19 = 1;
  }
  else {
    BOOL v19 = (v18 - 12330) > 0xFFFFFFF6;
  }
  if (!v19 && v18 != 12295 && (v18 - 40870) < 0xFFFFAE5A) {
    return 1;
  }
  do
  {
    while (1)
    {
      do
      {
        do
        {
LABEL_64:
          while (1)
          {
            v3 += len;
            signed int v22 = xmlStringCurrentChar(0, v3, &len);
            signed int v23 = v22;
            if (v22 > 255) {
              break;
            }
            BOOL v24 = (v22 - 192) >= 0x17 && (v22 & 0xFFFFFFDF) - 65 >= 0x1A;
            if (v24 && (v22 - 48) >= 0xA && v22 <= 247 && (v22 - 216) >= 0x1F) {
              goto LABEL_88;
            }
          }
          if (xmlCharInRange(v22, &xmlIsBaseCharGroup)) {
            BOOL v26 = 0;
          }
          else {
            BOOL v26 = (v23 - 12321) >= 9;
          }
          BOOL v28 = v26 && v23 != 12295 && (v23 - 19968) >= 0x51A6;
        }
        while (!v28 || xmlCharInRange(v23, &xmlIsDigitGroup));
LABEL_88:
        ;
      }
      while ((v23 - 45) <= 0x32 && ((1 << (v23 - 45)) & 0x4000000000003) != 0);
      if (v23 >= 256) {
        break;
      }
      if (v23 != 183) {
        goto LABEL_98;
      }
    }
  }
  while (xmlCharInRange(v23, &xmlIsCombiningGroup) || xmlCharInRange(v23, &xmlIsExtenderGroup));
LABEL_98:
  if (v23 == 58)
  {
    v3 += len;
    signed int v30 = xmlStringCurrentChar(0, v3, &len);
    signed int v31 = v30;
    if (v30 <= 255)
    {
      if ((v30 - 192) < 0x17
        || (v30 & 0xFFFFFFDF) - 65 < 0x1A
        || v30 == 95
        || v30 > 247
        || (v30 - 216) < 0x1F)
      {
        goto LABEL_111;
      }
      return 1;
    }
    if (!xmlCharInRange(v30, &xmlIsBaseCharGroup)
      && (v31 - 12330) <= 0xFFFFFFF6
      && v31 != 12295
      && (v31 - 40870) < 0xFFFFAE5A)
    {
      return 1;
    }
    while (1)
    {
LABEL_111:
      v3 += len;
      signed int v32 = xmlStringCurrentChar(0, v3, &len);
      signed int v23 = v32;
      if (v32 > 255)
      {
        if (xmlCharInRange(v32, &xmlIsBaseCharGroup)) {
          BOOL v35 = 0;
        }
        else {
          BOOL v35 = (v23 - 12321) >= 9;
        }
        BOOL v37 = v35 && v23 != 12295 && (v23 - 19968) >= 0x51A6;
        if (!v37 || xmlCharInRange(v23, &xmlIsDigitGroup)) {
          continue;
        }
      }
      else
      {
        BOOL v33 = (v32 - 192) >= 0x17 && (v32 & 0xFFFFFFDF) - 65 >= 0x1A;
        if (!v33 || (v32 - 48) < 0xA) {
          continue;
        }
        if (v32 > 247 || (v32 - 216) < 0x1F) {
          continue;
        }
      }
      if ((v23 - 45) > 0x32 || ((1 << (v23 - 45)) & 0x4000000000003) == 0)
      {
        if (v23 >= 256)
        {
          if (!xmlCharInRange(v23, &xmlIsCombiningGroup) && !xmlCharInRange(v23, &xmlIsExtenderGroup)) {
            break;
          }
        }
        else if (v23 != 183)
        {
          break;
        }
      }
    }
  }
  if (space && v23 <= 255)
  {
    do
    {
      if (v23 > 0x20) {
        break;
      }
      if (((1 << v23) & 0x100002600) == 0) {
        break;
      }
      v3 += len;
      signed int v23 = xmlStringCurrentChar(0, v3, &len);
    }
    while (v23 < 256);
  }
  return v23 != 0;
}

int xmlValidateName(const xmlChar *value, int space)
{
  if (!value) {
    return -1;
  }
  int v3 = value;
  if (space)
  {
    for (uint64_t i = value; ; ++i)
    {
      unsigned int v5 = *i;
      if (v5 > 0x20 || ((1 << v5) & 0x100002600) == 0) {
        break;
      }
    }
  }
  else
  {
    unsigned int v5 = *value;
    uint64_t i = value;
  }
  int len = 0;
  if ((v5 & 0xFFFFFFDF) - 65 < 0x1A || v5 == 95 || v5 == 58)
  {
    do
    {
      unsigned int v8 = i;
      unsigned int v10 = *++i;
      unsigned int v9 = v10;
      unsigned int v11 = (v10 & 0xFFFFFFDF) - 65;
    }
    while (v10 - 48 < 0xA
         || v11 < 0x1A
         || v9 - 45 <= 0x32 && ((1 << (v9 - 45)) & 0x4000000002003) != 0);
    if (space)
    {
      uint64_t v14 = 2;
      while (v9 <= 0x20 && ((1 << v9) & 0x100002600) != 0)
        unsigned int v9 = v8[v14++];
    }
    if (!v9) {
      return 0;
    }
  }
  int v15 = xmlStringCurrentChar(0, value, &len);
  signed int v16 = v15;
  if (space)
  {
    if (v15 <= 255)
    {
      while (v16 <= 0x20 && ((1 << v16) & 0x100002600) != 0)
      {
        v3 += len;
        signed int v16 = xmlStringCurrentChar(0, v3, &len);
        if (v16 >= 256) {
          goto LABEL_45;
        }
      }
      goto LABEL_38;
    }
  }
  else if (v15 < 256)
  {
LABEL_38:
    if ((v16 - 192) < 0x17
      || (v16 & 0xFFFFFFDF) - 65 < 0x1A
      || v16 > 247
      || (v16 - 216) < 0x1F
      || v16 == 95
      || v16 == 58)
    {
      goto LABEL_56;
    }
    return 1;
  }
LABEL_45:
  if (xmlCharInRange(v16, &xmlIsBaseCharGroup)) {
    BOOL v17 = 1;
  }
  else {
    BOOL v17 = (v16 - 12330) > 0xFFFFFFF6;
  }
  if (!v17 && v16 != 12295 && (v16 - 40870) < 0xFFFFAE5A) {
    return 1;
  }
  do
  {
    while (1)
    {
      do
      {
        do
        {
LABEL_56:
          while (1)
          {
            v3 += len;
            signed int v20 = xmlStringCurrentChar(0, v3, &len);
            signed int v21 = v20;
            if (v20 > 255) {
              break;
            }
            BOOL v22 = (v20 - 192) >= 0x17 && (v20 & 0xFFFFFFDF) - 65 >= 0x1A;
            if (v22 && (v20 - 48) >= 0xA && v20 <= 247 && (v20 - 216) >= 0x1F) {
              goto LABEL_80;
            }
          }
          if (xmlCharInRange(v20, &xmlIsBaseCharGroup)) {
            BOOL v24 = 0;
          }
          else {
            BOOL v24 = (v21 - 12321) >= 9;
          }
          BOOL v26 = v24 && v21 != 12295 && (v21 - 19968) >= 0x51A6;
        }
        while (!v26 || xmlCharInRange(v21, &xmlIsDigitGroup));
LABEL_80:
        ;
      }
      while ((v21 - 45) <= 0x32 && ((1 << (v21 - 45)) & 0x4000000002003) != 0);
      if (v21 >= 256) {
        break;
      }
      if (v21 != 183) {
        goto LABEL_90;
      }
    }
  }
  while (xmlCharInRange(v21, &xmlIsCombiningGroup) || xmlCharInRange(v21, &xmlIsExtenderGroup));
LABEL_90:
  if (space && v21 <= 255)
  {
    do
    {
      if (v21 > 0x20) {
        break;
      }
      if (((1 << v21) & 0x100002600) == 0) {
        break;
      }
      v3 += len;
      signed int v21 = xmlStringCurrentChar(0, v3, &len);
    }
    while (v21 < 256);
  }
  return v21 != 0;
}

int xmlValidateNMToken(const xmlChar *value, int space)
{
  if (!value) {
    return -1;
  }
  int v3 = value;
  if (space)
  {
    for (uint64_t i = value; ; ++i)
    {
      unsigned int v5 = *i;
      if (v5 > 0x20 || ((1 << v5) & 0x100002600) == 0) {
        break;
      }
    }
  }
  else
  {
    unsigned int v5 = *value;
    uint64_t i = value;
  }
  int len = 0;
  BOOL v8 = v5 - 48 >= 0xA && (v5 & 0xFFFFFFDF) - 65 >= 0x1A;
  if (!v8
    || ((v9 = v5 - 45, BOOL v10 = v9 > 0x32, v11 = (1 << v9) & 0x4000000002003, !v10) ? (v12 = v11 == 0) : (v12 = 1), !v12))
  {
    do
    {
      unint64_t v13 = i;
      unsigned int v15 = *++i;
      unsigned int v14 = v15;
      unsigned int v16 = (v15 & 0xFFFFFFDF) - 65;
    }
    while (v15 - 48 < 0xA
         || v16 < 0x1A
         || v14 - 45 <= 0x32 && ((1 << (v14 - 45)) & 0x4000000002003) != 0);
    if (space)
    {
      uint64_t v19 = 2;
      while (v14 <= 0x20 && ((1 << v14) & 0x100002600) != 0)
        unsigned int v14 = v13[v19++];
    }
    if (!v14) {
      return 0;
    }
  }
  int v20 = xmlStringCurrentChar(0, value, &len);
  signed int v21 = v20;
  if (space)
  {
    if (v20 <= 255)
    {
      while (v21 <= 0x20 && ((1 << v21) & 0x100002600) != 0)
      {
        v3 += len;
        signed int v21 = xmlStringCurrentChar(0, v3, &len);
        if (v21 >= 256) {
          goto LABEL_50;
        }
      }
      goto LABEL_44;
    }
  }
  else if (v20 < 256)
  {
LABEL_44:
    if ((v21 - 192) < 0x17
      || (v21 & 0xFFFFFFDF) - 65 < 0x1A
      || v21 > 247
      || (v21 - 216) < 0x1F
      || (v21 - 48) < 0xA)
    {
      goto LABEL_60;
    }
    char v22 = 1;
    goto LABEL_102;
  }
LABEL_50:
  if (xmlCharInRange(v21, &xmlIsBaseCharGroup)) {
    BOOL v23 = 0;
  }
  else {
    BOOL v23 = (v21 - 12321) >= 9;
  }
  BOOL v25 = v23 && v21 != 12295 && (v21 - 19968) >= 0x51A6;
  if (!v25 || xmlCharInRange(v21, &xmlIsDigitGroup))
  {
    while (1)
    {
LABEL_60:
      while (1)
      {
        v3 += len;
        signed int v26 = xmlStringCurrentChar(0, v3, &len);
        signed int v27 = v26;
        if (v26 <= 255) {
          break;
        }
        if (xmlCharInRange(v26, &xmlIsBaseCharGroup)) {
          BOOL v30 = 0;
        }
        else {
          BOOL v30 = (v27 - 12321) >= 9;
        }
        BOOL v32 = v30 && v27 != 12295 && (v27 - 19968) >= 0x51A6;
        if (v32 && !xmlCharInRange(v27, &xmlIsDigitGroup)) {
          goto LABEL_84;
        }
      }
      BOOL v28 = (v26 - 192) >= 0x17 && (v26 & 0xFFFFFFDF) - 65 >= 0x1A;
      if (v28 && (v26 - 48) >= 0xA && v26 <= 247 && (v26 - 216) >= 0x1F)
      {
LABEL_84:
        if ((v27 - 45) > 0x32 || ((1 << (v27 - 45)) & 0x4000000002003) == 0)
        {
          if (v27 >= 256)
          {
            if (!xmlCharInRange(v27, &xmlIsCombiningGroup) && !xmlCharInRange(v27, &xmlIsExtenderGroup))
            {
LABEL_94:
              if (space && v27 <= 255)
              {
                do
                {
                  if (v27 > 0x20) {
                    break;
                  }
                  if (((1 << v27) & 0x100002600) == 0) {
                    break;
                  }
                  v3 += len;
                  signed int v27 = xmlStringCurrentChar(0, v3, &len);
                }
                while (v27 < 256);
              }
              return v27 != 0;
            }
          }
          else if (v27 != 183)
          {
            goto LABEL_94;
          }
        }
      }
    }
  }
  char v22 = 0;
LABEL_102:
  if ((v21 - 45) <= 0x32 && ((1 << (v21 - 45)) & 0x4000000002003) != 0) {
    goto LABEL_60;
  }
  if (v22)
  {
    if (v21 == 183) {
      goto LABEL_60;
    }
  }
  else if (xmlCharInRange(v21, &xmlIsCombiningGroup) || xmlCharInRange(v21, &xmlIsExtenderGroup))
  {
    goto LABEL_60;
  }
  return 1;
}

void xmlSetBufferAllocationScheme(xmlBufferAllocationScheme scheme)
{
  if (scheme <= XML_BUFFER_ALLOC_HYBRID && ((1 << scheme) & 0x13) != 0) {
    *__xmlBufferAllocScheme() = scheme;
  }
}

xmlBufferAllocationScheme xmlGetBufferAllocationScheme(void)
{
  return *__xmlBufferAllocScheme();
}

xmlNsPtr xmlNewNs(xmlNodePtr node, const xmlChar *href, const xmlChar *prefix)
{
  if (node && node->type != XML_ELEMENT_NODE
    || prefix
    && xmlStrEqual(prefix, (const xmlChar *)"xml")
    && xmlStrEqual(href, (const xmlChar *)"http://www.w3.org/XML/1998/namespace"))
  {
    return 0;
  }
  uint64_t v6 = (xmlNs *)xmlMalloc(0x30uLL);
  uint64_t v7 = v6;
  if (!v6)
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building namespace");
    return v7;
  }
  *(_OWORD *)&v6->href = 0u;
  *(_OWORD *)&v6->_private = 0u;
  *(_OWORD *)&v6->xmlNodePtr next = 0u;
  v6->xmlElementType type = XML_NAMESPACE_DECL;
  if (href) {
    v6->href = xmlStrdup(href);
  }
  if (prefix) {
    v7->prefix = xmlStrdup(prefix);
  }
  if (node)
  {
    nsDef = node->nsDef;
    if (!nsDef)
    {
      node->nsDef = v7;
      return v7;
    }
    unsigned int v9 = nsDef->prefix;
    BOOL v10 = v7->prefix;
    if ((unint64_t)v9 | (unint64_t)v10 && !xmlStrEqual(v9, v10))
    {
      do
      {
        if (!nsDef->next)
        {
          nsDef->xmlNodePtr next = v7;
          return v7;
        }
        unint64_t v13 = nsDef->next->prefix;
        unsigned int v14 = v7->prefix;
        if (!((unint64_t)v13 | (unint64_t)v14)) {
          break;
        }
        nsDef = nsDef->next;
      }
      while (!xmlStrEqual(v13, v14));
      unsigned int v16 = (xmlChar *)v7->href;
      if (v16) {
        xmlFree(v16);
      }
      BOOL v17 = (xmlChar *)v7->prefix;
      if (v17) {
        xmlFree(v17);
      }
    }
    else
    {
      uint64_t v11 = (xmlChar *)v7->href;
      if (v11) {
        xmlFree(v11);
      }
      BOOL v12 = (xmlChar *)v7->prefix;
      if (v12) {
        xmlFree(v12);
      }
    }
    ((void (*)(xmlNs *))xmlFree)(v7);
    return 0;
  }
  return v7;
}

void xmlFreeNs(xmlNsPtr cur)
{
  if (cur)
  {
    href = (xmlChar *)cur->href;
    if (href) {
      xmlFree(href);
    }
    prefix = (xmlChar *)cur->prefix;
    if (prefix) {
      xmlFree(prefix);
    }
    xmlFreeFunc v4 = xmlFree;
    ((void (*)(xmlNsPtr))v4)(cur);
  }
}

void xmlSetNs(xmlNodePtr node, xmlNsPtr ns)
{
  if (node)
  {
    if (node->type - 1 <= 1) {
      node->xmlNsPtr ns = ns;
    }
  }
}

void xmlFreeNsList(xmlNsPtr cur)
{
  if (cur)
  {
    xmlNsPtr v1 = cur;
    do
    {
      xmlNodePtr next = v1->next;
      href = (xmlChar *)v1->href;
      if (href) {
        xmlFree(href);
      }
      prefix = (xmlChar *)v1->prefix;
      if (prefix) {
        xmlFree(prefix);
      }
      xmlFree(v1);
      xmlNsPtr v1 = next;
    }
    while (next);
  }
}

xmlDtdPtr xmlNewDtd(xmlDocPtr doc, const xmlChar *name, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  if (doc && doc->extSubset) {
    return 0;
  }
  unsigned int v9 = (xmlDtd *)xmlMalloc(0x80uLL);
  BOOL v8 = v9;
  if (v9)
  {
    *(_OWORD *)&v9->entities = 0u;
    *(_OWORD *)&v9->SystemID = 0u;
    *(_OWORD *)&v9->xmlDocPtr doc = 0u;
    *(_OWORD *)&v9->elements = 0u;
    *(_OWORD *)&v9->last = 0u;
    *(_OWORD *)&v9->xmlNodePtr next = 0u;
    *(_OWORD *)&v9->_private = 0u;
    *(_OWORD *)&v9->name = 0u;
    v9->xmlElementType type = XML_DTD_NODE;
    if (name) {
      v9->name = xmlStrdup(name);
    }
    if (ExternalID) {
      v8->ExternalID = xmlStrdup(ExternalID);
    }
    if (SystemID) {
      v8->SystemID = xmlStrdup(SystemID);
    }
    if (doc) {
      doc->extSubset = v8;
    }
    v8->xmlDocPtr doc = doc;
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      BOOL v10 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlDtd *))*v10)(v8);
    }
  }
  else
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building DTD");
  }
  return v8;
}

xmlDtdPtr xmlCreateIntSubset(xmlDocPtr doc, const xmlChar *name, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  if (doc)
  {
    xmlNodePtr children = doc->children;
    if (children)
    {
      while (children->type != XML_DTD_NODE)
      {
        xmlNodePtr children = children->next;
        if (!children) {
          goto LABEL_5;
        }
      }
      return 0;
    }
LABEL_5:
    if (doc->intSubset) {
      return 0;
    }
  }
  unsigned int v9 = (xmlDtd *)xmlMalloc(0x80uLL);
  BOOL v10 = v9;
  if (!v9)
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building internal subset");
    return v10;
  }
  *(_OWORD *)&v9->entities = 0u;
  *(_OWORD *)&v9->SystemID = 0u;
  *(_OWORD *)&v9->xmlDocPtr doc = 0u;
  *(_OWORD *)&v9->elements = 0u;
  *(_OWORD *)&v9->last = 0u;
  *(_OWORD *)&v9->xmlNodePtr next = 0u;
  *(_OWORD *)&v9->_private = 0u;
  *(_OWORD *)&v9->name = 0u;
  v9->xmlElementType type = XML_DTD_NODE;
  if (name)
  {
    uint64_t v11 = xmlStrdup(name);
    v10->name = v11;
    if (!v11)
    {
      __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building internal subset");
      goto LABEL_24;
    }
  }
  if (ExternalID)
  {
    BOOL v12 = xmlStrdup(ExternalID);
    v10->ExternalID = v12;
    if (!v12)
    {
      __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building internal subset");
      BOOL v17 = (xmlChar *)v10->name;
      if (v17) {
LABEL_23:
      }
        xmlFree(v17);
LABEL_24:
      xmlFree(v10);
      return 0;
    }
  }
  if (SystemID)
  {
    unint64_t v13 = xmlStrdup(SystemID);
    v10->SystemID = v13;
    if (!v13)
    {
      __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building internal subset");
      uint64_t v19 = (xmlChar *)v10->name;
      if (v19) {
        xmlFree(v19);
      }
      BOOL v17 = (xmlChar *)v10->ExternalID;
      if (!v17) {
        goto LABEL_24;
      }
      goto LABEL_23;
    }
  }
  if (doc)
  {
    doc->intSubset = v10;
    v10->xmlNodePtr parent = doc;
    v10->xmlDocPtr doc = doc;
    p_xmlNodePtr children = &doc->children;
    unsigned int v15 = doc->children;
    if (v15)
    {
      if (doc->type == XML_HTML_DOCUMENT_NODE)
      {
        v15->int prev = (_xmlNode *)v10;
        v10->xmlNodePtr next = v15;
      }
      else
      {
        while (v15->type != XML_ELEMENT_NODE)
        {
          unsigned int v15 = v15->next;
          if (!v15)
          {
            last = doc->last;
            last->xmlNodePtr next = (_xmlNode *)v10;
            v10->xmlNodePtr next = 0;
            v10->int prev = last;
            p_xmlNodePtr children = &doc->last;
            goto LABEL_35;
          }
        }
        v10->xmlNodePtr next = v15;
        int prev = v15->prev;
        p_int prev = &v15->prev;
        v10->int prev = prev;
        p_xmlNodePtr next = &prev->next;
        if (prev) {
          p_xmlNodePtr children = p_next;
        }
        *p_xmlNodePtr children = (_xmlNode *)v10;
        p_xmlNodePtr children = p_prev;
      }
    }
    else
    {
      doc->xmlNodePtr children = (_xmlNode *)v10;
      p_xmlNodePtr children = &doc->last;
    }
LABEL_35:
    *p_xmlNodePtr children = (_xmlNode *)v10;
  }
  if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
  {
    BOOL v23 = __xmlRegisterNodeDefaultValue();
    ((void (*)(xmlDtd *))*v23)(v10);
  }
  return v10;
}

void xmlFreeDtd(xmlDtdPtr cur)
{
  if (!cur) {
    return;
  }
  xmlDocPtr doc = cur->doc;
  if (doc) {
    dict = doc->dict;
  }
  else {
    dict = 0;
  }
  if (__xmlRegisterCallbacks && *__xmlDeregisterNodeDefaultValue())
  {
    xmlFreeFunc v4 = __xmlDeregisterNodeDefaultValue();
    ((void (*)(xmlDtdPtr))*v4)(cur);
  }
  xmlNodePtr children = cur->children;
  if (children)
  {
    do
    {
      xmlNodePtr next = children->next;
      unsigned int type = children->type;
      BOOL v8 = type > 0x11;
      int v9 = (1 << type) & 0x39000;
      if (v8 || v9 == 0)
      {
        xmlUnlinkNode(children);
        xmlFreeNode(children);
      }
      xmlNodePtr children = next;
    }
    while (next);
  }
  name = (xmlChar *)cur->name;
  if (name)
  {
    if (dict)
    {
      if (xmlDictOwns(dict, name)) {
        goto LABEL_22;
      }
      name = (xmlChar *)cur->name;
    }
    xmlFree(name);
  }
LABEL_22:
  SystemID = (xmlChar *)cur->SystemID;
  if (!SystemID) {
    goto LABEL_27;
  }
  if (dict)
  {
    if (xmlDictOwns(dict, SystemID)) {
      goto LABEL_27;
    }
    SystemID = (xmlChar *)cur->SystemID;
  }
  xmlFree(SystemID);
LABEL_27:
  ExternalID = (xmlChar *)cur->ExternalID;
  if (ExternalID)
  {
    if (!dict)
    {
LABEL_31:
      xmlFree(ExternalID);
      goto LABEL_32;
    }
    if (!xmlDictOwns(dict, ExternalID))
    {
      ExternalID = (xmlChar *)cur->ExternalID;
      goto LABEL_31;
    }
  }
LABEL_32:
  notatioxmlNsPtr ns = (xmlNotationTable *)cur->notations;
  if (notations) {
    xmlFreeNotationTable(notations);
  }
  elements = (xmlElementTable *)cur->elements;
  if (elements) {
    xmlFreeElementTable(elements);
  }
  attributes = (xmlAttributeTable *)cur->attributes;
  if (attributes) {
    xmlFreeAttributeTable(attributes);
  }
  entities = (xmlEntitiesTable *)cur->entities;
  if (entities) {
    xmlFreeEntitiesTable(entities);
  }
  pentities = (xmlEntitiesTable *)cur->pentities;
  if (pentities) {
    xmlFreeEntitiesTable(pentities);
  }
  xmlFreeFunc v19 = xmlFree;

  ((void (*)(xmlDtdPtr))v19)(cur);
}

void xmlUnlinkNode(xmlNodePtr cur)
{
  if (!cur) {
    return;
  }
  xmlElementType type = cur->type;
  switch(type)
  {
    case XML_NAMESPACE_DECL:
      return;
    case XML_ENTITY_DECL:
      xmlDocPtr doc = cur->doc;
      if (doc)
      {
        intSubset = doc->intSubset;
        if (intSubset)
        {
          if (xmlHashLookup((xmlHashTablePtr)intSubset->entities, cur->name) == cur) {
            xmlHashRemoveEntry((xmlHashTablePtr)doc->intSubset->entities, cur->name, 0);
          }
          if (xmlHashLookup((xmlHashTablePtr)doc->intSubset->pentities, cur->name) == cur) {
            xmlHashRemoveEntry((xmlHashTablePtr)doc->intSubset->pentities, cur->name, 0);
          }
        }
        extSubset = doc->extSubset;
        if (extSubset)
        {
          if (xmlHashLookup((xmlHashTablePtr)extSubset->entities, cur->name) == cur) {
            xmlHashRemoveEntry((xmlHashTablePtr)doc->extSubset->entities, cur->name, 0);
          }
          if (xmlHashLookup((xmlHashTablePtr)doc->extSubset->pentities, cur->name) == cur) {
            xmlHashRemoveEntry((xmlHashTablePtr)doc->extSubset->pentities, cur->name, 0);
          }
        }
      }
      break;
    case XML_DTD_NODE:
      int v3 = cur->doc;
      if (v3)
      {
        if ((xmlNodePtr)v3->intSubset == cur) {
          v3->intSubset = 0;
        }
        if ((xmlNodePtr)v3->extSubset == cur) {
          v3->extSubset = 0;
        }
      }
      break;
  }
  xmlNodePtr parent = cur->parent;
  if (parent)
  {
    if (cur->type == XML_ATTRIBUTE_NODE)
    {
      int properties = (xmlNode *)parent->properties;
      p_int properties = &parent->properties;
      if (properties != cur)
      {
LABEL_30:
        cur->xmlNodePtr parent = 0;
        goto LABEL_31;
      }
      p_xmlNodePtr next = &cur->next;
    }
    else
    {
      if (parent->children == cur) {
        parent->xmlNodePtr children = cur->next;
      }
      last = parent->last;
      p_int properties = &parent->last;
      if (last != cur) {
        goto LABEL_30;
      }
      p_xmlNodePtr next = &cur->prev;
    }
    *p_int properties = *p_next;
    goto LABEL_30;
  }
LABEL_31:
  xmlNodePtr next = cur->next;
  if (next) {
    next->int prev = cur->prev;
  }
  int prev = cur->prev;
  if (prev) {
    prev->xmlNodePtr next = next;
  }
  cur->xmlNodePtr next = 0;
  cur->int prev = 0;
}

xmlNodePtr xmlNewDocText(const xmlDoc *doc, const xmlChar *content)
{
  xmlNodePtr result = xmlNewText(content);
  if (result) {
    result->xmlDocPtr doc = (_xmlDoc *)doc;
  }
  return result;
}

xmlNodePtr xmlAddNextSibling(xmlNodePtr cur, xmlNodePtr elem)
{
  if (cur)
  {
    xmlNodePtr v3 = cur;
    xmlDocPtr cur = 0;
    if (elem)
    {
      if (v3->type != XML_NAMESPACE_DECL)
      {
        xmlDocPtr cur = 0;
        if (v3 != elem && elem->type != XML_NAMESPACE_DECL)
        {
          xmlUnlinkNode(elem);
          xmlElementType type = elem->type;
          if (type == XML_ATTRIBUTE_NODE)
          {
            return xmlAddPropSibling((uint64_t)v3, (uint64_t)v3, (uint64_t)elem);
          }
          else
          {
            if (type != XML_TEXT_NODE) {
              goto LABEL_16;
            }
            if (v3->type == XML_TEXT_NODE)
            {
              xmlNodeAddContent(v3, elem->content);
              xmlFreeNode(elem);
              return v3;
            }
            xmlNodePtr next = v3->next;
            if (next && next->type == XML_TEXT_NODE && v3->name == next->name)
            {
              int v9 = xmlStrdup(elem->content);
              BOOL v10 = xmlStrcat(v9, v3->next->content);
              xmlNodeSetContent(v3->next, v10);
              xmlFree(v10);
              xmlFreeNode(elem);
              return v3->next;
            }
            else
            {
LABEL_16:
              xmlDocPtr doc = v3->doc;
              if (elem->doc != doc) {
                xmlSetTreeDoc(elem, doc);
              }
              elem->int prev = v3;
              long long v7 = *(_OWORD *)&v3->parent;
              *(_OWORD *)&elem->xmlNodePtr parent = v7;
              v3->xmlNodePtr next = elem;
              BOOL v8 = elem->next;
              if (v8) {
                v8->int prev = elem;
              }
              if ((void)v7)
              {
                if (*(xmlNodePtr *)(v7 + 32) == v3) {
                  *(void *)(v7 + 32) = elem;
                }
              }
              return elem;
            }
          }
        }
      }
    }
  }
  return cur;
}

xmlNodePtr xmlNewReference(const xmlDoc *doc, const xmlChar *name)
{
  if (!name) {
    return 0;
  }
  xmlFreeFunc v4 = (xmlNode *)xmlMalloc(0x78uLL);
  unsigned int v5 = v4;
  if (v4)
  {
    *(void *)&v4->unint64_t line = 0;
    *(_OWORD *)&v4->content = 0u;
    *(_OWORD *)&v4->nsDef = 0u;
    *(_OWORD *)&v4->xmlNodePtr next = 0u;
    *(_OWORD *)&v4->xmlDocPtr doc = 0u;
    *(_OWORD *)&v4->name = 0u;
    *(_OWORD *)&v4->last = 0u;
    *(_OWORD *)&v4->_private = 0u;
    v4->xmlElementType type = XML_ENTITY_REF_NODE;
    v4->xmlDocPtr doc = (_xmlDoc *)doc;
    if (*name == 38)
    {
      uint64_t v6 = name + 1;
      int v7 = xmlStrlen(v6);
      uint64_t v8 = v7 - 1;
      if (v6[v8] != 59) {
        LODWORD(v8) = v7;
      }
      int v9 = xmlStrndup(v6, v8);
    }
    else
    {
      int v9 = xmlStrdup(name);
    }
    v5->name = v9;
    xmlEntityPtr DocEntity = xmlGetDocEntity(doc, v9);
    if (DocEntity)
    {
      v5->content = DocEntity->content;
      v5->xmlNodePtr children = (_xmlNode *)DocEntity;
      v5->last = (_xmlNode *)DocEntity;
    }
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      uint64_t v11 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v11)(v5);
    }
  }
  else
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building reference");
  }
  return v5;
}

xmlChar *__cdecl xmlNodeListGetString(xmlDocPtr doc, const xmlNode *list, int inLine)
{
  return xmlNodeListGetStringInternal(doc, (uint64_t)list, inLine, 0);
}

xmlChar *xmlNodeListGetStringInternal(xmlDoc *a1, uint64_t a2, int a3, int a4)
{
  xmlFreeFunc v4 = 0;
  if (a2 && a4 <= 40)
  {
    uint64_t v6 = a2;
    uint64_t v8 = *(void *)(a2 + 40);
    BOOL v9 = !v8 || *(_DWORD *)(v8 + 8) != 2;
    xmlFreeFunc v4 = 0;
    uint64_t v10 = (a4 + 1);
    while (1)
    {
      int v11 = *(_DWORD *)(v6 + 8);
      if ((v11 - 3) < 2) {
        break;
      }
      if (v11 == 5)
      {
        if (!a3)
        {
          strcpy((char *)add, "&");
          signed int v18 = xmlStrncat(v4, add, 1);
          xmlFreeFunc v19 = xmlStrcat(v18, *(const xmlChar **)(v6 + 16));
          strcpy((char *)add, ";");
          unint64_t v13 = xmlStrncat(v19, add, 1);
          goto LABEL_19;
        }
        xmlEntityPtr DocEntity = xmlGetDocEntity(a1, *(const xmlChar **)(v6 + 16));
        if (!DocEntity)
        {
          BOOL v12 = *(xmlChar **)(v6 + 80);
          goto LABEL_10;
        }
        uint64_t StringInternal = xmlNodeListGetStringInternal(a1, DocEntity->children, 1, v10);
        if (StringInternal)
        {
          unsigned int v16 = (xmlChar *)StringInternal;
LABEL_22:
          xmlFreeFunc v4 = xmlStrcat(v4, v16);
          xmlFree(v16);
        }
      }
LABEL_23:
      uint64_t v6 = *(void *)(v6 + 48);
      if (!v6) {
        return v4;
      }
    }
    BOOL v12 = *(xmlChar **)(v6 + 80);
    if (!a3)
    {
      if (v9) {
        BOOL v17 = xmlEncodeEntitiesReentrant(a1, v12);
      }
      else {
        BOOL v17 = (xmlChar *)xmlEncodeAttributeEntities((uint64_t)a1, (char *)v12);
      }
      unsigned int v16 = v17;
      if (!v17) {
        goto LABEL_23;
      }
      goto LABEL_22;
    }
LABEL_10:
    unint64_t v13 = xmlStrcat(v4, v12);
LABEL_19:
    xmlFreeFunc v4 = v13;
    goto LABEL_23;
  }
  return v4;
}

xmlChar *__cdecl xmlNodeListGetRawString(const xmlDoc *doc, const xmlNode *list, int inLine)
{
  if (list)
  {
    xmlFreeFunc v4 = list;
    uint64_t v6 = 0;
    while (1)
    {
      xmlElementType type = v4->type;
      if (type - 3 >= 2)
      {
        if (type == XML_ENTITY_REF_NODE)
        {
          if (!inLine)
          {
            strcpy((char *)add, "&");
            unint64_t v13 = xmlStrncat(v6, add, 1);
            unsigned int v14 = xmlStrcat(v13, v4->name);
            strcpy((char *)add, ";");
            BOOL v9 = xmlStrncat(v14, add, 1);
            goto LABEL_14;
          }
          xmlEntityPtr DocEntity = xmlGetDocEntity(doc, v4->name);
          if (!DocEntity)
          {
            content = v4->content;
LABEL_5:
            BOOL v9 = xmlStrcat(v6, content);
LABEL_14:
            uint64_t v6 = v9;
            goto LABEL_15;
          }
          RawString = xmlNodeListGetRawString(doc, DocEntity->children, 1);
          if (!RawString) {
            goto LABEL_15;
          }
LABEL_12:
          BOOL v12 = RawString;
          uint64_t v6 = xmlStrcat(v6, RawString);
          xmlFree(v12);
        }
      }
      else
      {
        content = v4->content;
        if (inLine) {
          goto LABEL_5;
        }
        RawString = xmlEncodeSpecialChars(doc, content);
        if (RawString) {
          goto LABEL_12;
        }
      }
LABEL_15:
      xmlFreeFunc v4 = v4->next;
      if (!v4) {
        return v6;
      }
    }
  }
  return 0;
}

xmlAttrPtr xmlNewDocProp(xmlDocPtr doc, const xmlChar *name, const xmlChar *value)
{
  if (!name) {
    return 0;
  }
  uint64_t v6 = (xmlAttr *)xmlMalloc(0x60uLL);
  int v7 = v6;
  if (v6)
  {
    *(_OWORD *)&v6->xmlDocPtr doc = 0u;
    *(_OWORD *)&v6->axmlElementType type = 0u;
    *(_OWORD *)&v6->last = 0u;
    *(_OWORD *)&v6->xmlNodePtr next = 0u;
    *(_OWORD *)&v6->_private = 0u;
    *(_OWORD *)&v6->name = 0u;
    v6->xmlElementType type = XML_ATTRIBUTE_NODE;
    if (doc && (dict = doc->dict) != 0) {
      BOOL v9 = xmlDictLookup(dict, name, -1);
    }
    else {
      BOOL v9 = xmlStrdup(name);
    }
    v7->name = v9;
    v7->xmlDocPtr doc = doc;
    if (value)
    {
      xmlNodePtr NodeList = xmlStringGetNodeList(doc, value);
      v7->xmlNodePtr children = NodeList;
      v7->last = 0;
      if (NodeList)
      {
        do
        {
          int v11 = NodeList;
          NodeList->xmlNodePtr parent = (_xmlNode *)v7;
          xmlNodePtr NodeList = NodeList->next;
        }
        while (NodeList);
        v7->last = v11;
      }
    }
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      BOOL v12 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlAttr *))*v12)(v7);
    }
  }
  else
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building attribute");
  }
  return v7;
}

void xmlFreePropList(xmlAttrPtr cur)
{
  if (cur)
  {
    do
    {
      xmlNodePtr next = cur->next;
      xmlFreeProp(cur);
      xmlDocPtr cur = next;
    }
    while (next);
  }
}

int xmlRemoveProp(xmlAttrPtr cur)
{
  if (!cur) {
    return -1;
  }
  xmlNodePtr parent = cur->parent;
  if (!parent) {
    return -1;
  }
  int properties = parent->properties;
  if (properties != cur)
  {
    while (properties)
    {
      xmlNodePtr v3 = properties;
      int properties = properties->next;
      if (properties == cur)
      {
        xmlNodePtr next = cur->next;
        v3->xmlNodePtr next = next;
        if (next) {
          goto LABEL_12;
        }
        goto LABEL_13;
      }
    }
    return -1;
  }
  xmlNodePtr next = cur->next;
  parent->int properties = next;
  if (next)
  {
    xmlNodePtr v3 = 0;
LABEL_12:
    next->int prev = v3;
  }
LABEL_13:
  xmlFreeProp(cur);
  return 0;
}

xmlNodePtr xmlNewDocPI(xmlDocPtr doc, const xmlChar *name, const xmlChar *content)
{
  if (!name) {
    return 0;
  }
  uint64_t v6 = (xmlNode *)xmlMalloc(0x78uLL);
  int v7 = v6;
  if (v6)
  {
    *(void *)&v6->unint64_t line = 0;
    *(_OWORD *)&v6->content = 0u;
    *(_OWORD *)&v6->nsDef = 0u;
    *(_OWORD *)&v6->xmlNodePtr next = 0u;
    *(_OWORD *)&v6->xmlDocPtr doc = 0u;
    *(_OWORD *)&v6->name = 0u;
    *(_OWORD *)&v6->last = 0u;
    *(_OWORD *)&v6->_private = 0u;
    v6->xmlElementType type = XML_PI_NODE;
    if (doc && (dict = doc->dict) != 0) {
      BOOL v9 = xmlDictLookup(dict, name, -1);
    }
    else {
      BOOL v9 = xmlStrdup(name);
    }
    v7->name = v9;
    if (content) {
      v7->content = xmlStrdup(content);
    }
    v7->xmlDocPtr doc = doc;
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      uint64_t v10 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v10)(v7);
    }
  }
  else
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building PI");
  }
  return v7;
}

xmlNodePtr xmlNewPI(const xmlChar *name, const xmlChar *content)
{
  return xmlNewDocPI(0, name, content);
}

xmlNodePtr xmlNewDocRawNode(xmlDocPtr doc, xmlNsPtr ns, const xmlChar *name, const xmlChar *content)
{
  xmlNodePtr v6 = xmlNewDocNode(doc, ns, name, 0);
  int v7 = v6;
  if (v6)
  {
    v6->xmlDocPtr doc = doc;
    if (content)
    {
      xmlNodePtr v8 = xmlNewText(content);
      if (v8)
      {
        v8->xmlDocPtr doc = doc;
        v7->xmlNodePtr children = v8;
        xmlNodePtr next = v8->next;
        if (next)
        {
          do
          {
            xmlNodePtr v10 = next;
            v8->xmlNodePtr parent = v7;
            xmlNodePtr next = next->next;
            xmlNodePtr v8 = v10;
          }
          while (next);
        }
        else
        {
          xmlNodePtr v10 = v8;
        }
        v10->xmlNodePtr parent = v7;
        v7->last = v10;
      }
      else
      {
        v7->xmlNodePtr children = 0;
        v7->last = 0;
      }
    }
  }
  return v7;
}

xmlNodePtr xmlNewDocFragment(xmlDocPtr doc)
{
  uint64_t v2 = (xmlNode *)xmlMalloc(0x78uLL);
  xmlNodePtr v3 = v2;
  if (v2)
  {
    *(void *)&v2->unint64_t line = 0;
    *(_OWORD *)&v2->content = 0u;
    *(_OWORD *)&v2->nsDef = 0u;
    *(_OWORD *)&v2->xmlNodePtr next = 0u;
    *(_OWORD *)&v2->xmlDocPtr doc = 0u;
    *(_OWORD *)&v2->name = 0u;
    *(_OWORD *)&v2->last = 0u;
    *(_OWORD *)&v2->_private = 0u;
    v2->xmlElementType type = XML_DOCUMENT_FRAG_NODE;
    v2->xmlDocPtr doc = doc;
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      xmlFreeFunc v4 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v4)(v3);
    }
  }
  else
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building fragment");
  }
  return v3;
}

xmlNodePtr xmlNewTextChild(xmlNodePtr parent, xmlNsPtr ns, const xmlChar *name, const xmlChar *content)
{
  xmlNodePtr result = 0;
  if (parent && name)
  {
    xmlNodePtr result = 0;
    HIDWORD(v6) = parent->type - 1;
    LODWORD(v6) = HIDWORD(v6);
    switch((v6 >> 1))
    {
      case 0u:
        xmlDocPtr doc = parent->doc;
        if (!ns) {
          xmlNsPtr ns = parent->ns;
        }
        goto LABEL_8;
      case 4u:
      case 6u:
        xmlDocPtr doc = (xmlDoc *)parent;
        goto LABEL_8;
      case 5u:
        xmlDocPtr doc = parent->doc;
LABEL_8:
        xmlNodePtr result = xmlNewDocRawNode(doc, ns, name, content);
        if (result)
        {
          result->xmlElementType type = XML_ELEMENT_NODE;
          result->xmlNodePtr parent = parent;
          result->xmlDocPtr doc = parent->doc;
          if (parent->children)
          {
            last = parent->last;
            p_last = &parent->last;
            last->xmlNodePtr next = result;
            result->int prev = last;
          }
          else
          {
            parent->xmlNodePtr children = result;
            p_last = &parent->last;
          }
          *p_last = result;
        }
        break;
      default:
        return result;
    }
  }
  return result;
}

xmlNodePtr xmlNewCharRef(xmlDocPtr doc, const xmlChar *name)
{
  if (!name) {
    return 0;
  }
  xmlFreeFunc v4 = (xmlNode *)xmlMalloc(0x78uLL);
  unsigned int v5 = v4;
  if (v4)
  {
    *(void *)&v4->unint64_t line = 0;
    *(_OWORD *)&v4->content = 0u;
    *(_OWORD *)&v4->nsDef = 0u;
    *(_OWORD *)&v4->xmlNodePtr next = 0u;
    *(_OWORD *)&v4->xmlDocPtr doc = 0u;
    *(_OWORD *)&v4->name = 0u;
    *(_OWORD *)&v4->last = 0u;
    *(_OWORD *)&v4->_private = 0u;
    v4->xmlElementType type = XML_ENTITY_REF_NODE;
    v4->xmlDocPtr doc = doc;
    if (*name == 38)
    {
      unint64_t v6 = name + 1;
      int v7 = xmlStrlen(v6);
      uint64_t v8 = v7 - 1;
      if (v6[v8] != 59) {
        LODWORD(v8) = v7;
      }
      BOOL v9 = xmlStrndup(v6, v8);
    }
    else
    {
      BOOL v9 = xmlStrdup(name);
    }
    v5->name = v9;
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      xmlNodePtr v10 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v10)(v5);
    }
  }
  else
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building character reference");
  }
  return v5;
}

xmlNodePtr xmlNewTextLen(const xmlChar *content, int len)
{
  xmlFreeFunc v4 = (xmlNode *)xmlMalloc(0x78uLL);
  unsigned int v5 = v4;
  if (v4)
  {
    *(_OWORD *)&v4->_private = 0u;
    *(_OWORD *)&v4->name = 0u;
    *(void *)&v4->unint64_t line = 0;
    *(_OWORD *)&v4->content = 0u;
    *(_OWORD *)&v4->nsDef = 0u;
    *(_OWORD *)&v4->xmlNodePtr next = 0u;
    *(_OWORD *)&v4->xmlDocPtr doc = 0u;
    *(_OWORD *)&v4->last = 0u;
    v4->xmlElementType type = XML_TEXT_NODE;
    v4->name = "text";
    if (content) {
      v4->content = xmlStrndup(content, len);
    }
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      unint64_t v6 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v6)(v5);
    }
  }
  else
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building text");
  }
  return v5;
}

xmlNodePtr xmlNewDocTextLen(xmlDocPtr doc, const xmlChar *content, int len)
{
  xmlNodePtr result = xmlNewTextLen(content, len);
  if (result) {
    result->xmlDocPtr doc = doc;
  }
  return result;
}

xmlNodePtr xmlNewComment(const xmlChar *content)
{
  uint64_t v2 = (xmlNode *)xmlMalloc(0x78uLL);
  xmlNodePtr v3 = v2;
  if (v2)
  {
    *(_OWORD *)&v2->_private = 0u;
    *(_OWORD *)&v2->name = 0u;
    *(void *)&v2->unint64_t line = 0;
    *(_OWORD *)&v2->content = 0u;
    *(_OWORD *)&v2->nsDef = 0u;
    *(_OWORD *)&v2->xmlNodePtr next = 0u;
    *(_OWORD *)&v2->xmlDocPtr doc = 0u;
    *(_OWORD *)&v2->last = 0u;
    v2->xmlElementType type = XML_COMMENT_NODE;
    v2->name = "comment";
    if (content) {
      v2->content = xmlStrdup(content);
    }
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      xmlFreeFunc v4 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v4)(v3);
    }
  }
  else
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building comment");
  }
  return v3;
}

xmlNodePtr xmlNewCDataBlock(xmlDocPtr doc, const xmlChar *content, int len)
{
  unint64_t v6 = (xmlNode *)xmlMalloc(0x78uLL);
  int v7 = v6;
  if (v6)
  {
    *(void *)&v6->unint64_t line = 0;
    *(_OWORD *)&v6->content = 0u;
    *(_OWORD *)&v6->nsDef = 0u;
    *(_OWORD *)&v6->xmlNodePtr next = 0u;
    *(_OWORD *)&v6->xmlDocPtr doc = 0u;
    *(_OWORD *)&v6->name = 0u;
    *(_OWORD *)&v6->last = 0u;
    *(_OWORD *)&v6->_private = 0u;
    v6->xmlElementType type = XML_CDATA_SECTION_NODE;
    v6->xmlDocPtr doc = doc;
    if (content) {
      v6->content = xmlStrndup(content, len);
    }
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      uint64_t v8 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlNode *))*v8)(v7);
    }
  }
  else
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"building CDATA");
  }
  return v7;
}

xmlNodePtr xmlNewDocComment(xmlDocPtr doc, const xmlChar *content)
{
  xmlNodePtr result = xmlNewComment(content);
  if (result) {
    result->xmlDocPtr doc = doc;
  }
  return result;
}

void xmlSetTreeDoc(xmlNodePtr tree, xmlDocPtr doc)
{
  if (tree)
  {
    xmlElementType type = tree->type;
    if (type != XML_NAMESPACE_DECL)
    {
      unsigned int v5 = tree->doc;
      if (v5 != doc)
      {
        if (v5)
        {
          dict = v5->dict;
          if (doc)
          {
LABEL_6:
            int v7 = doc->dict;
            goto LABEL_9;
          }
        }
        else
        {
          dict = 0;
          if (doc) {
            goto LABEL_6;
          }
        }
        int v7 = 0;
LABEL_9:
        if (type == XML_ELEMENT_NODE)
        {
          int properties = tree->properties;
          if (!properties) {
            goto LABEL_22;
          }
          do
          {
            if (properties->atype == XML_ATTRIBUTE_ID) {
              xmlRemoveID(tree->doc, properties);
            }
            BOOL v9 = properties->doc;
            if (v9 != doc)
            {
              if (v9) {
                xmlNodePtr v10 = v9->dict;
              }
              else {
                xmlNodePtr v10 = 0;
              }
              properties->name = _copyStringForNewDictIfNeeded(v10, v7, (xmlChar *)properties->name);
              properties->xmlDocPtr doc = doc;
            }
            xmlSetListDoc(properties->children, doc);
            int properties = properties->next;
          }
          while (properties);
          xmlElementType type = tree->type;
        }
        if (type == XML_ENTITY_REF_NODE)
        {
          tree->xmlNodePtr children = 0;
LABEL_27:
          tree->name = _copyStringForNewDictIfNeeded(dict, v7, (xmlChar *)tree->name);
          tree->content = _copyStringForNewDictIfNeeded(dict, 0, tree->content);
          tree->xmlDocPtr doc = doc;
          return;
        }
LABEL_22:
        xmlNodePtr children = tree->children;
        if (children && children->type != XML_NAMESPACE_DECL)
        {
          do
          {
            if (children->doc != doc) {
              xmlSetTreeDoc(children, doc);
            }
            xmlNodePtr children = children->next;
          }
          while (children);
        }
        goto LABEL_27;
      }
    }
  }
}

xmlChar *_copyStringForNewDictIfNeeded(xmlDict *a1, xmlDict *a2, xmlChar *str)
{
  if (!str || !a1 || xmlDictOwns(a1, str) != 1) {
    return str;
  }
  if (a2)
  {
    return (xmlChar *)xmlDictLookup(a2, str, -1);
  }
  else
  {
    return xmlStrdup(str);
  }
}

void xmlSetListDoc(xmlNodePtr list, xmlDocPtr doc)
{
  if (list)
  {
    xmlNodePtr v2 = list;
    if (list->type != XML_NAMESPACE_DECL)
    {
      do
      {
        if (v2->doc != doc) {
          xmlSetTreeDoc(v2, doc);
        }
        xmlNodePtr v2 = v2->next;
      }
      while (v2);
    }
  }
}

void xmlNodeAddContent(xmlNodePtr cur, const xmlChar *content)
{
  if (cur && content)
  {
    int v4 = xmlStrlen(content);
    xmlNodeAddContentLen(cur, content, v4);
  }
}

void xmlNodeSetContent(xmlNodePtr cur, const xmlChar *content)
{
  if (!cur) {
    return;
  }
  xmlElementType type = cur->type;
  if (type > XML_DOCUMENT_FRAG_NODE) {
    return;
  }
  int v5 = 1 << type;
  if ((v5 & 0x1F8) != 0)
  {
    unint64_t v6 = cur->content;
    p_int properties = &cur->properties;
    if (v6) {
      BOOL v8 = v6 == (xmlChar *)p_properties;
    }
    else {
      BOOL v8 = 1;
    }
    if (v8) {
      goto LABEL_13;
    }
    xmlDocPtr doc = cur->doc;
    if (doc)
    {
      dict = doc->dict;
      if (dict)
      {
        if (xmlDictOwns(dict, v6))
        {
LABEL_13:
          xmlNodePtr children = cur->children;
          if (children) {
            xmlFreeNodeList(children);
          }
          cur->xmlNodePtr children = 0;
          cur->last = 0;
          if (content) {
            BOOL v12 = xmlStrdup(content);
          }
          else {
            BOOL v12 = 0;
          }
          cur->content = v12;
          *p_int properties = 0;
          cur->nsDef = 0;
          return;
        }
        unint64_t v6 = cur->content;
      }
    }
    xmlFree(v6);
    goto LABEL_13;
  }
  if ((v5 & 0x806) != 0)
  {
    unint64_t v13 = cur->children;
    if (v13) {
      xmlFreeNodeList(v13);
    }
    xmlNodePtr NodeList = xmlStringGetNodeList(cur->doc, content);
    cur->xmlNodePtr children = NodeList;
    if (NodeList)
    {
      xmlNodePtr next = NodeList->next;
      if (next)
      {
        do
        {
          unsigned int v16 = next;
          NodeList->xmlNodePtr parent = cur;
          xmlNodePtr next = next->next;
          xmlNodePtr NodeList = v16;
        }
        while (next);
      }
      else
      {
        unsigned int v16 = NodeList;
      }
      v16->xmlNodePtr parent = cur;
      cur->last = v16;
    }
    else
    {
      cur->last = 0;
    }
  }
}

xmlNode *xmlAddPropSibling(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a2 + 8) != 2) {
    return 0;
  }
  xmlNodePtr v3 = (xmlNode *)a3;
  if (*(_DWORD *)(a3 + 8) != 2) {
    return 0;
  }
  xmlNodePtr next = (_xmlNode *)a2;
  if (a1)
  {
    if (*(_DWORD *)(a1 + 8) != 2) {
      return 0;
    }
  }
  uint64_t v6 = *(void *)(a3 + 72);
  uint64_t v7 = *(void *)(a2 + 40);
  BOOL v8 = *(xmlChar **)(a3 + 16);
  if (v6) {
    BOOL v9 = *(const xmlChar **)(v6 + 16);
  }
  else {
    BOOL v9 = 0;
  }
  xmlAttributePtr PropNodeInternal = xmlGetPropNodeInternal(v7, v8, v9, 1);
  xmlDocPtr doc = next->doc;
  if (v3->doc != doc) {
    xmlSetTreeDoc(v3, doc);
  }
  xmlNodePtr parent = next->parent;
  v3->xmlNodePtr parent = parent;
  v3->int prev = (_xmlNode *)a1;
  if (!a1)
  {
    v3->xmlNodePtr next = next;
    goto LABEL_16;
  }
  v3->xmlNodePtr next = *(_xmlNode **)(a1 + 48);
  *(void *)(a1 + 48) = v3;
  xmlNodePtr next = v3->next;
  if (next) {
LABEL_16:
  }
    next->int prev = v3;
  if (!v3->prev && parent) {
    parent->int properties = (_xmlAttr *)v3;
  }
  if (PropNodeInternal && PropNodeInternal->type != XML_ATTRIBUTE_DECL) {
    xmlRemoveProp((xmlAttrPtr)PropNodeInternal);
  }
  return v3;
}

xmlNodePtr xmlAddPrevSibling(xmlNodePtr cur, xmlNodePtr elem)
{
  if (cur)
  {
    xmlNodePtr v3 = cur;
    xmlDocPtr cur = 0;
    if (elem)
    {
      if (v3->type != XML_NAMESPACE_DECL)
      {
        xmlDocPtr cur = 0;
        if (v3 != elem && elem->type != XML_NAMESPACE_DECL)
        {
          xmlUnlinkNode(elem);
          xmlElementType type = elem->type;
          if (type == XML_ATTRIBUTE_NODE)
          {
            uint64_t prev = (uint64_t)v3->prev;
            return xmlAddPropSibling(prev, (uint64_t)v3, (uint64_t)elem);
          }
          else
          {
            if (type != XML_TEXT_NODE) {
              goto LABEL_16;
            }
            if (v3->type == XML_TEXT_NODE)
            {
              int v5 = xmlStrdup(elem->content);
              uint64_t v6 = xmlStrcat(v5, v3->content);
              xmlNodeSetContent(v3, v6);
              xmlFree(v6);
              xmlFreeNode(elem);
              return v3;
            }
            BOOL v8 = v3->prev;
            if (v8 && v8->type == XML_TEXT_NODE && v3->name == v8->name)
            {
              xmlNodeAddContent(v8, elem->content);
              xmlFreeNode(elem);
              return v3->prev;
            }
            else
            {
LABEL_16:
              xmlDocPtr doc = v3->doc;
              if (elem->doc != doc) {
                xmlSetTreeDoc(elem, doc);
              }
              xmlNodePtr parent = v3->parent;
              elem->xmlNodePtr parent = parent;
              elem->xmlNodePtr next = v3;
              elem->uint64_t prev = v3->prev;
              v3->uint64_t prev = elem;
              int v11 = elem->prev;
              if (v11) {
                v11->xmlNodePtr next = elem;
              }
              if (parent)
              {
                if (parent->children == v3) {
                  parent->xmlNodePtr children = elem;
                }
              }
              return elem;
            }
          }
        }
      }
    }
  }
  return cur;
}

xmlNodePtr xmlAddSibling(xmlNodePtr cur, xmlNodePtr elem)
{
  if (!cur) {
    return 0;
  }
  xmlNodePtr last = 0;
  if (!elem) {
    return last;
  }
  xmlElementType type = cur->type;
  if (type == XML_NAMESPACE_DECL) {
    return last;
  }
  xmlNodePtr last = 0;
  if (cur == elem || elem->type == XML_NAMESPACE_DECL) {
    return last;
  }
  if (type == XML_ATTRIBUTE_NODE
    || (xmlNodePtr parent = cur->parent) == 0
    || !parent->children
    || (xmlNodePtr last = parent->last) == 0
    || last->next)
  {
    do
    {
      xmlNodePtr last = cur;
      xmlDocPtr cur = cur->next;
    }
    while (cur);
  }
  xmlUnlinkNode(elem);
  xmlElementType v6 = elem->type;
  if (last->type == XML_TEXT_NODE && v6 == XML_TEXT_NODE)
  {
    if (last->name != elem->name) {
      goto LABEL_23;
    }
    xmlNodeAddContent(last, elem->content);
    xmlFreeNode(elem);
    return last;
  }
  if (v6 != XML_ATTRIBUTE_NODE)
  {
LABEL_23:
    xmlDocPtr doc = last->doc;
    if (elem->doc != doc) {
      xmlSetTreeDoc(elem, doc);
    }
    xmlNodePtr v10 = last->parent;
    elem->xmlNodePtr next = 0;
    elem->uint64_t prev = last;
    elem->xmlNodePtr parent = v10;
    last->xmlNodePtr next = elem;
    if (v10) {
      v10->xmlNodePtr last = elem;
    }
    return elem;
  }

  return xmlAddPropSibling((uint64_t)last, (uint64_t)last, (uint64_t)elem);
}

xmlNodePtr xmlAddChildList(xmlNodePtr parent, xmlNodePtr cur)
{
  if (!parent) {
    return 0;
  }
  xmlNodePtr v2 = cur;
  xmlNodePtr v3 = 0;
  if (cur && parent->type != XML_NAMESPACE_DECL)
  {
    xmlElementType type = cur->type;
    if (type == XML_NAMESPACE_DECL) {
      return 0;
    }
    if (parent->children)
    {
      if (type == XML_TEXT_NODE)
      {
        xmlNodePtr last = parent->last;
        if (last->type == XML_TEXT_NODE && cur->name == last->name)
        {
          xmlNodeAddContent(last, cur->content);
          xmlNodePtr next = v2->next;
          xmlFreeNode(v2);
          xmlNodePtr v2 = next;
          if (!next) {
            return parent->last;
          }
        }
      }
      BOOL v8 = parent->last;
      v8->xmlNodePtr next = v2;
      v2->uint64_t prev = v8;
    }
    else
    {
      parent->xmlNodePtr children = cur;
    }
    p_xmlNodePtr next = &v2->next;
    BOOL v9 = v2->next;
    if (v9)
    {
      xmlNodePtr v3 = v2;
      do
      {
        v3->xmlNodePtr parent = parent;
        xmlDocPtr doc = parent->doc;
        if (v3->doc != doc)
        {
          xmlSetTreeDoc(v3, doc);
          BOOL v9 = *p_next;
        }
        xmlNodePtr v3 = v9;
        p_xmlNodePtr next = &v9->next;
        BOOL v9 = v9->next;
      }
      while (v9);
    }
    else
    {
      xmlNodePtr v3 = v2;
    }
    v3->xmlNodePtr parent = parent;
    BOOL v12 = parent->doc;
    if (v3->doc != v12) {
      xmlSetTreeDoc(v3, v12);
    }
    parent->xmlNodePtr last = v3;
  }
  return v3;
}

xmlAttrPtr xmlHasNsProp(const xmlNode *node, const xmlChar *name, const xmlChar *nameSpace)
{
  return (xmlAttrPtr)xmlGetPropNodeInternal((uint64_t)node, (xmlChar *)name, nameSpace, 1);
}

xmlNodePtr xmlGetLastChild(xmlNodePtr parent)
{
  if (parent)
  {
    if (parent->type == XML_NAMESPACE_DECL) {
      return 0;
    }
    else {
      return parent->last;
    }
  }
  return parent;
}

unint64_t xmlChildElementCount(unint64_t parent)
{
  if (parent)
  {
    unsigned int v1 = *(_DWORD *)(parent + 8);
    BOOL v2 = v1 > 0xD;
    int v3 = (1 << v1) & 0x2A42;
    if (v2 || v3 == 0) {
      return 0;
    }
    uint64_t v5 = *(void *)(parent + 24);
    if (!v5)
    {
      return 0;
    }
    else
    {
      xmlNodePtr parent = 0;
      do
      {
        if (*(_DWORD *)(v5 + 8) == 1) {
          ++parent;
        }
        uint64_t v5 = *(void *)(v5 + 48);
      }
      while (v5);
    }
  }
  return parent;
}

xmlNodePtr xmlFirstElementChild(xmlNodePtr parent)
{
  if (parent)
  {
    xmlElementType type = parent->type;
    BOOL v2 = type > XML_HTML_DOCUMENT_NODE;
    int v3 = (1 << type) & 0x2A42;
    if (v2 || v3 == 0)
    {
      return 0;
    }
    else
    {
      for (xmlNodePtr parent = parent->children; parent; xmlNodePtr parent = parent->next)
      {
        if (parent->type == XML_ELEMENT_NODE) {
          break;
        }
      }
    }
  }
  return parent;
}

xmlNodePtr xmlLastElementChild(xmlNodePtr parent)
{
  if (parent)
  {
    xmlElementType type = parent->type;
    BOOL v2 = type > XML_HTML_DOCUMENT_NODE;
    int v3 = (1 << type) & 0x2A42;
    if (v2 || v3 == 0)
    {
      return 0;
    }
    else
    {
      for (xmlNodePtr parent = parent->last; parent; xmlNodePtr parent = parent->prev)
      {
        if (parent->type == XML_ELEMENT_NODE) {
          break;
        }
      }
    }
  }
  return parent;
}

xmlNodePtr xmlPreviousElementSibling(xmlNodePtr node)
{
  if (node)
  {
    xmlElementType type = node->type;
    BOOL v2 = type > XML_XINCLUDE_END;
    int v3 = (1 << type) & 0x1801FA;
    if (v2 || v3 == 0)
    {
      return 0;
    }
    else
    {
      do
        xmlNodePtr node = node->prev;
      while (node && node->type != XML_ELEMENT_NODE);
    }
  }
  return node;
}

xmlNodePtr xmlNextElementSibling(xmlNodePtr node)
{
  if (node)
  {
    xmlElementType type = node->type;
    BOOL v2 = type > XML_XINCLUDE_END;
    int v3 = (1 << type) & 0x1841FA;
    if (v2 || v3 == 0)
    {
      return 0;
    }
    else
    {
      do
        xmlNodePtr node = node->next;
      while (node && node->type != XML_ELEMENT_NODE);
    }
  }
  return node;
}

xmlNodePtr xmlReplaceNode(xmlNodePtr old, xmlNodePtr cur)
{
  xmlNodePtr result = 0;
  if (old && old != cur)
  {
    xmlElementType type = old->type;
    if (type == XML_NAMESPACE_DECL || !old->parent)
    {
      return 0;
    }
    else
    {
      if (!cur || (xmlElementType v6 = cur->type, v6 == XML_NAMESPACE_DECL))
      {
        xmlUnlinkNode(old);
        return old;
      }
      BOOL v7 = type == XML_ATTRIBUTE_NODE;
      char v8 = !v7;
      if (v6 == XML_ATTRIBUTE_NODE) {
        BOOL v7 = v8;
      }
      if (v7) {
        return old;
      }
      xmlUnlinkNode(cur);
      xmlSetTreeDoc(cur, old->doc);
      xmlNodePtr parent = old->parent;
      xmlNodePtr next = old->next;
      cur->xmlNodePtr parent = parent;
      cur->xmlNodePtr next = next;
      if (next) {
        next->uint64_t prev = cur;
      }
      uint64_t prev = old->prev;
      cur->uint64_t prev = prev;
      if (prev) {
        prev->xmlNodePtr next = cur;
      }
      if (parent)
      {
        if (cur->type == XML_ATTRIBUTE_NODE)
        {
          int properties = (xmlNode *)parent->properties;
          p_int properties = &parent->properties;
          unint64_t v13 = properties;
        }
        else
        {
          if (parent->children == old) {
            parent->xmlNodePtr children = cur;
          }
          xmlNodePtr last = parent->last;
          p_int properties = &parent->last;
          unint64_t v13 = last;
        }
        if (v13 == old) {
          *p_int properties = cur;
        }
      }
      old->xmlNodePtr parent = 0;
      old->xmlNodePtr next = 0;
      xmlNodePtr result = old;
      old->uint64_t prev = 0;
    }
  }
  return result;
}

xmlNsPtr xmlCopyNamespace(xmlNsPtr cur)
{
  if (cur && cur->type == XML_NAMESPACE_DECL) {
    return xmlNewNs(0, cur->href, cur->prefix);
  }
  else {
    return 0;
  }
}

xmlNsPtr xmlCopyNamespaceList(xmlNsPtr cur)
{
  if (cur)
  {
    xmlNsPtr v1 = cur;
    BOOL v2 = 0;
    int v3 = 0;
    do
    {
      if (v1->type == XML_NAMESPACE_DECL) {
        int v4 = xmlNewNs(0, v1->href, v1->prefix);
      }
      else {
        int v4 = 0;
      }
      xmlDocPtr cur = v4;
      if (v2)
      {
        v2->xmlNodePtr next = v4;
        xmlDocPtr cur = v3;
      }
      xmlNsPtr v1 = v1->next;
      BOOL v2 = v4;
      int v3 = cur;
    }
    while (v1);
  }
  return cur;
}

xmlAttrPtr xmlCopyProp(xmlNodePtr target, xmlAttrPtr cur)
{
  return xmlCopyPropInternal(0, (uint64_t)target, (uint64_t)cur);
}

xmlAttrPtr xmlCopyPropInternal(xmlDoc *a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  if (a2)
  {
    if (*(_DWORD *)(a2 + 8) == 1)
    {
      a1 = *(xmlDoc **)(a2 + 64);
LABEL_10:
      BOOL v7 = *(const xmlChar **)(a3 + 16);
      goto LABEL_11;
    }
    return 0;
  }
  if (a1) {
    goto LABEL_10;
  }
  uint64_t v6 = *(void *)(a3 + 40);
  if (v6 || (uint64_t v6 = *(void *)(a3 + 24)) != 0)
  {
    a1 = *(xmlDoc **)(v6 + 64);
    goto LABEL_10;
  }
  BOOL v7 = *(const xmlChar **)(a3 + 16);
  a1 = 0;
LABEL_11:
  xmlAttrPtr v8 = xmlNewDocProp(a1, v7, 0);
  xmlAttrPtr v5 = v8;
  if (!v8) {
    return v5;
  }
  xmlNsPtr v9 = 0;
  v8->xmlNodePtr parent = (_xmlNode *)a2;
  if (!a2) {
    goto LABEL_24;
  }
  uint64_t v10 = *(void *)(a3 + 72);
  if (!v10) {
    goto LABEL_24;
  }
  xmlNsPtr v11 = xmlSearchNs(*(xmlDocPtr *)(a2 + 64), (xmlNodePtr)a2, *(const xmlChar **)(v10 + 24));
  if (!v11)
  {
    xmlNsPtr v13 = xmlSearchNs(*(xmlDocPtr *)(a3 + 64), *(xmlNodePtr *)(a3 + 40), *(const xmlChar **)(*(void *)(a3 + 72) + 24));
    if (!v13) {
      goto LABEL_25;
    }
    unsigned int v14 = 0;
    unsigned int v15 = (xmlNode *)a2;
    do
    {
      unsigned int v16 = v14;
      unsigned int v14 = v15;
      unsigned int v15 = v15->parent;
    }
    while (v15);
    if (v14 == *(xmlNode **)(a2 + 64)) {
      unsigned int v14 = v16;
    }
    xmlNsPtr v12 = xmlNewNs(v14, v13->href, v13->prefix);
    goto LABEL_23;
  }
  xmlNsPtr v9 = v11;
  if (!xmlStrEqual(v11->href, *(const xmlChar **)(*(void *)(a3 + 72) + 16)))
  {
    xmlNsPtr v12 = xmlNewReconciledNs(*(xmlDocPtr *)(a2 + 64), (xmlNodePtr)a2, *(void *)(a3 + 72));
LABEL_23:
    xmlNsPtr v9 = v12;
  }
LABEL_24:
  v5->xmlNsPtr ns = v9;
LABEL_25:
  BOOL v17 = *(xmlDtd **)(a3 + 24);
  if (v17)
  {
    signed int v18 = xmlStaticCopyNodeList(v17, (uint64_t)v5->doc, (xmlNodePtr)v5);
    v5->xmlNodePtr children = v18;
    v5->xmlNodePtr last = 0;
    if (v18)
    {
      do
      {
        xmlFreeFunc v19 = v18;
        signed int v18 = v18->next;
      }
      while (v18);
      v5->xmlNodePtr last = v19;
    }
  }
  if (a2)
  {
    if (*(void *)(a2 + 64))
    {
      int v20 = *(xmlDoc **)(a3 + 64);
      if (v20)
      {
        if (v20->ids)
        {
          signed int v21 = *(xmlNode **)(a3 + 40);
          if (v21)
          {
            if (xmlIsID(v20, v21, (xmlAttrPtr)a3))
            {
              uint64_t StringInternal = xmlNodeListGetStringInternal(*(xmlDoc **)(a3 + 64), *(void *)(a3 + 24), 1, 0);
              if (StringInternal)
              {
                BOOL v23 = StringInternal;
                xmlAddID(0, *(xmlDocPtr *)(a2 + 64), StringInternal, v5);
                xmlFree(v23);
              }
            }
          }
        }
      }
    }
  }
  return v5;
}

xmlAttrPtr xmlCopyPropList(xmlNodePtr target, xmlAttrPtr cur)
{
  xmlAttrPtr v2 = cur;
  if (!target)
  {
    if (cur) {
      goto LABEL_9;
    }
    return 0;
  }
  if (target->type != XML_ELEMENT_NODE || cur == 0) {
    return 0;
  }
LABEL_9:
  uint64_t v6 = 0;
  BOOL v7 = 0;
  do
  {
    xmlAttrPtr result = xmlCopyPropInternal(0, (uint64_t)target, (uint64_t)v2);
    if (!result) {
      break;
    }
    xmlAttrPtr v8 = result;
    if (v6)
    {
      v6->xmlNodePtr next = result;
      result->uint64_t prev = v6;
      xmlAttrPtr result = v7;
    }
    xmlAttrPtr v2 = v2->next;
    uint64_t v6 = v8;
    BOOL v7 = result;
  }
  while (v2);
  return result;
}

xmlNodePtr xmlCopyNode(xmlNodePtr node, int recursive)
{
  return xmlStaticCopyNode(node, 0, 0, recursive);
}

xmlNodePtr xmlStaticCopyNode(xmlNodePtr result, xmlDoc *a2, xmlNode *a3, int a4)
{
  if (!result) {
    return result;
  }
  uint64_t v7 = (uint64_t)result;
  int v8 = result->type - 2;
  xmlAttrPtr result = 0;
  switch(v8)
  {
    case 0:
      return (xmlNodePtr)xmlCopyPropInternal(a2, (uint64_t)a3, v7);
    case 7:
    case 11:
    case 19:
      return (xmlNodePtr)xmlCopyDoc((xmlDocPtr)v7, a4);
    case 8:
    case 10:
    case 12:
    case 13:
    case 14:
    case 15:
      return result;
    case 16:
      return (xmlNodePtr)xmlCopyNamespaceList((xmlNsPtr)v7);
    default:
      xmlNsPtr v9 = (xmlNode *)xmlMalloc(0x78uLL);
      if (!v9)
      {
        __xmlSimpleError(2, 2, 0, 0, (uint64_t)"copying node");
        return 0;
      }
      uint64_t v10 = v9;
      *(void *)&v9->unint64_t line = 0;
      *(_OWORD *)&v9->content = 0u;
      *(_OWORD *)&v9->nsDef = 0u;
      *(_OWORD *)&v9->xmlNodePtr next = 0u;
      *(_OWORD *)&v9->xmlDocPtr doc = 0u;
      *(_OWORD *)&v9->name = 0u;
      *(_OWORD *)&v9->xmlNodePtr last = 0u;
      *(_OWORD *)&v9->_private = 0u;
      v9->xmlElementType type = *(_DWORD *)(v7 + 8);
      v9->xmlDocPtr doc = a2;
      v9->xmlNodePtr parent = a3;
      xmlNsPtr v11 = *(const xmlChar **)(v7 + 16);
      xmlNsPtr v12 = "text";
      if (v11 == "text") {
        goto LABEL_24;
      }
      xmlNsPtr v12 = "textnoenc";
      if (v11 == "textnoenc") {
        goto LABEL_24;
      }
      xmlNsPtr v12 = "comment";
      if (v11 == "comment") {
        goto LABEL_24;
      }
      if (v11)
      {
        if (a2 && (dict = a2->dict) != 0) {
          xmlNsPtr v12 = xmlDictLookup(dict, v11, -1);
        }
        else {
          xmlNsPtr v12 = xmlStrdup(*(const xmlChar **)(v7 + 16));
        }
LABEL_24:
        v10->name = v12;
      }
      unsigned int v14 = *(_DWORD *)(v7 + 8);
      if (v14 == 1)
      {
        v10->unint64_t line = *(_WORD *)(v7 + 112);
      }
      else
      {
        unsigned int v15 = *(const xmlChar **)(v7 + 80);
        if (v15 && (v14 > 0x14 || ((1 << v14) & 0x180020) == 0)) {
          v10->content = xmlStrdup(v15);
        }
      }
      if (!a3) {
        goto LABEL_86;
      }
      if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
      {
        unsigned int v16 = __xmlRegisterNodeDefaultValue();
        ((void (*)(xmlNode *))*v16)(v10);
      }
      xmlAttrPtr result = xmlAddChild(a3, v10);
      if (result == v10)
      {
LABEL_86:
        if (!a4) {
          goto LABEL_79;
        }
        int v17 = *(_DWORD *)(v7 + 8);
        if (v17 == 19 || v17 == 1)
        {
          signed int v18 = *(xmlNs **)(v7 + 96);
          if (v18) {
            v10->nsDef = xmlCopyNamespaceList(v18);
          }
        }
        uint64_t v19 = *(void *)(v7 + 72);
        if (v19)
        {
          xmlNsPtr v20 = xmlSearchNs(a2, v10, *(const xmlChar **)(v19 + 24));
          if (!v20)
          {
            xmlNsPtr v21 = xmlSearchNs(*(xmlDocPtr *)(v7 + 64), (xmlNodePtr)v7, *(const xmlChar **)(*(void *)(v7 + 72) + 24));
            if (v21)
            {
              char v22 = v10;
              do
              {
                BOOL v23 = v22;
                char v22 = v22->parent;
              }
              while (v22);
              xmlNsPtr v20 = xmlNewNs(v23, v21->href, v21->prefix);
            }
            else
            {
              xmlNsPtr v20 = xmlNewReconciledNs(a2, v10, *(void *)(v7 + 72));
            }
          }
          v10->xmlNsPtr ns = v20;
        }
        int v24 = *(_DWORD *)(v7 + 8);
        if (v24 == 19 || v24 == 1)
        {
          signed int v26 = *(xmlAttr **)(v7 + 88);
          if (v26)
          {
            v10->int properties = xmlCopyPropList(v10, v26);
            int v24 = *(_DWORD *)(v7 + 8);
          }
        }
        if (v24 == 5)
        {
          if (a2 && *(xmlDoc **)(v7 + 64) == a2) {
            xmlEntityPtr DocEntity = *(xmlEntityPtr *)(v7 + 24);
          }
          else {
            xmlEntityPtr DocEntity = xmlGetDocEntity(a2, v10->name);
          }
          v10->xmlNodePtr children = (_xmlNode *)DocEntity;
          v10->xmlNodePtr last = (_xmlNode *)DocEntity;
          goto LABEL_79;
        }
        if (a4 == 2 || (uint64_t v28 = *(void *)(v7 + 24)) == 0)
        {
LABEL_79:
          if (!a3 && __xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
          {
            uint64_t v34 = __xmlRegisterNodeDefaultValue();
            ((void (*)(xmlNode *))*v34)(v10);
          }
          return v10;
        }
        uint64_t v29 = xmlStaticCopyNode(*(void *)(v7 + 24), a2, v10, 2);
        if (v29)
        {
          p_private = &v10->_private;
          do
          {
            uint64_t v31 = p_private[4];
            if (v31 != v29)
            {
              if (v31)
              {
                *(void *)(v29 + 56) = v31;
                BOOL v32 = (uint64_t *)(v31 + 48);
              }
              else
              {
                BOOL v32 = p_private + 3;
              }
              *BOOL v32 = v29;
              p_private[4] = v29;
            }
            if (*(_DWORD *)(v28 + 8) == 5 || (uint64_t v33 = *(void *)(v28 + 24)) == 0)
            {
              while (1)
              {
                uint64_t v33 = *(void *)(v28 + 48);
                if (v33) {
                  break;
                }
                uint64_t v28 = *(void *)(v28 + 40);
                p_private = (void *)p_private[5];
                if (v28 == v7) {
                  goto LABEL_79;
                }
              }
              uint64_t v29 = (uint64_t)p_private;
            }
            p_private = (void *)v29;
            uint64_t v29 = xmlStaticCopyNode(v33, a2, v29, 2);
            uint64_t v28 = v33;
          }
          while (v29);
        }
        xmlFreeNode(v10);
        return 0;
      }
      return result;
  }
}

xmlNodePtr xmlDocCopyNode(xmlNodePtr node, xmlDocPtr doc, int recursive)
{
  return xmlStaticCopyNode(node, doc, 0, recursive);
}

xmlNodePtr xmlDocCopyNodeList(xmlDocPtr doc, xmlNodePtr node)
{
  return xmlStaticCopyNodeList((xmlDtdPtr)node, (uint64_t)doc, 0);
}

xmlNode *xmlStaticCopyNodeList(xmlDtdPtr dtd, uint64_t a2, xmlNodePtr parent)
{
  if (!dtd) {
    return 0;
  }
  xmlDtdPtr v5 = dtd;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  int v8 = 0;
  while (2)
  {
    xmlDtdPtr v9 = v5;
    while (1)
    {
      if (v9->type != XML_DTD_NODE)
      {
        uint64_t v10 = xmlStaticCopyNode(v9, a2, parent, 1);
        xmlDtdPtr v5 = v9;
        if (!v10)
        {
LABEL_20:
          xmlFreeNodeList(v8);
          return 0;
        }
LABEL_9:
        if (!v8) {
          goto LABEL_15;
        }
        goto LABEL_10;
      }
      if (a2) {
        break;
      }
      xmlDtdPtr v9 = (xmlDtdPtr)v9->next;
      if (!v9) {
        return v8;
      }
    }
    uint64_t v10 = *(void *)(a2 + 80);
    if (v10 | v6)
    {
      xmlAddChild(parent, *(xmlNodePtr *)(a2 + 80));
      if (!v10) {
        goto LABEL_20;
      }
      goto LABEL_9;
    }
    xmlNsPtr v11 = (xmlNode *)xmlCopyDtd(v5);
    if (!v11) {
      goto LABEL_20;
    }
    uint64_t v6 = (uint64_t)v11;
    v11->xmlDocPtr doc = (_xmlDoc *)a2;
    v11->xmlNodePtr parent = parent;
    xmlAddChild(parent, v11);
    uint64_t v10 = v6;
    if (!v8)
    {
LABEL_15:
      uint64_t v7 = 0;
      int v8 = (xmlNode *)v10;
LABEL_16:
      *(void *)(v10 + 56) = v7;
      uint64_t v7 = v10;
      goto LABEL_17;
    }
LABEL_10:
    if (v7 != v10)
    {
      *(void *)(v7 + 48) = v10;
      goto LABEL_16;
    }
LABEL_17:
    xmlDtdPtr v5 = (xmlDtdPtr)v5->next;
    if (v5) {
      continue;
    }
    break;
  }
  if (a2 && v6) {
    *(void *)(a2 + 80) = v6;
  }
  return v8;
}

xmlNodePtr xmlCopyNodeList(xmlNodePtr node)
{
  return xmlStaticCopyNodeList((xmlDtdPtr)node, 0, 0);
}

xmlDtdPtr xmlCopyDtd(xmlDtdPtr dtd)
{
  if (!dtd) {
    return 0;
  }
  xmlDtdPtr v2 = xmlNewDtd(0, dtd->name, dtd->ExternalID, dtd->SystemID);
  if (v2)
  {
    entities = (xmlEntitiesTable *)dtd->entities;
    if (entities) {
      v2->entities = xmlCopyEntitiesTable(entities);
    }
    notatioxmlNsPtr ns = (xmlNotationTable *)dtd->notations;
    if (notations) {
      v2->notatioxmlNsPtr ns = xmlCopyNotationTable(notations);
    }
    elements = (xmlElementTable *)dtd->elements;
    if (elements) {
      v2->elements = xmlCopyElementTable(elements);
    }
    attributes = (xmlAttributeTable *)dtd->attributes;
    if (attributes) {
      v2->attributes = xmlCopyAttributeTable(attributes);
    }
    pentities = (xmlEntitiesTable *)dtd->pentities;
    if (pentities) {
      v2->pentities = xmlCopyEntitiesTable(pentities);
    }
    xmlNodePtr children = dtd->children;
    if (children)
    {
      xmlDtdPtr v9 = 0;
      while (1)
      {
        switch(children->type)
        {
          case XML_COMMENT_NODE:
            xmlElementPtr DtdQElementDesc = (_xmlNode *)xmlStaticCopyNode(children, 0, 0, 0);
            if (!DtdQElementDesc) {
              goto LABEL_28;
            }
            goto LABEL_30;
          case XML_ELEMENT_DECL:
            xmlElementPtr DtdQElementDesc = (_xmlNode *)xmlGetDtdQElementDesc(v2, children->name, (const xmlChar *)children->nsDef);
            if (DtdQElementDesc) {
              goto LABEL_30;
            }
            goto LABEL_28;
          case XML_ATTRIBUTE_DECL:
            xmlElementPtr DtdQElementDesc = (_xmlNode *)xmlGetDtdQAttrDesc(v2, *(const xmlChar **)&children->line, children->name, (const xmlChar *)children->psvi);
            if (DtdQElementDesc) {
              goto LABEL_30;
            }
            goto LABEL_28;
          case XML_ENTITY_DECL:
            int properties_high = HIDWORD(children->properties);
            if ((properties_high - 1) >= 3)
            {
              if ((properties_high - 4) >= 2) {
                goto LABEL_28;
              }
              xmlNsPtr v12 = (xmlHashTable *)v2->pentities;
              if (!v12) {
                goto LABEL_28;
              }
            }
            else
            {
              xmlNsPtr v12 = (xmlHashTable *)v2->entities;
              if (!v12) {
                goto LABEL_28;
              }
            }
            xmlElementPtr DtdQElementDesc = (_xmlNode *)xmlHashLookup(v12, children->name);
            if (DtdQElementDesc)
            {
LABEL_30:
              p_xmlNodePtr next = &v9->next;
              if (!v9) {
                p_xmlNodePtr next = &v2->children;
              }
              *p_xmlNodePtr next = DtdQElementDesc;
              DtdQElementDesc->xmlNodePtr next = 0;
              DtdQElementDesc->uint64_t prev = v9;
              DtdQElementDesc->xmlNodePtr parent = (_xmlNode *)v2;
              v2->xmlNodePtr last = DtdQElementDesc;
              xmlNodePtr children = children->next;
              xmlDtdPtr v9 = DtdQElementDesc;
              if (!children) {
                return v2;
              }
            }
            else
            {
LABEL_28:
              xmlNodePtr children = children->next;
              if (!children) {
                return v2;
              }
            }
            break;
          default:
            goto LABEL_28;
        }
      }
    }
  }
  return v2;
}

xmlDocPtr xmlCopyDoc(xmlDocPtr doc, int recursive)
{
  if (!doc) {
    return 0;
  }
  xmlDocPtr v4 = xmlNewDoc(doc->version);
  uint64_t v5 = (uint64_t)v4;
  if (v4)
  {
    v4->xmlElementType type = doc->type;
    name = doc->name;
    if (name) {
      *(void *)(v5 + 16) = xmlMemStrdup(name);
    }
    encoding = doc->encoding;
    if (encoding) {
      *(void *)(v5 + 112) = xmlStrdup(encoding);
    }
    URL = doc->URL;
    if (URL) {
      *(void *)(v5 + 136) = xmlStrdup(URL);
    }
    *(_DWORD *)(v5 + 14xmlSAX2Text((uint64_t)ctx, (char *)value, len, 4) = doc->charset;
    *(void *)(v5 + 72) = *(void *)&doc->compression;
    if (recursive)
    {
      *(void *)(v5 + 2xmlSAX2Text((uint64_t)ctx, (char *)value, len, 4) = 0;
      *(void *)(v5 + 32) = 0;
      intSubset = doc->intSubset;
      if (!intSubset)
      {
LABEL_13:
        oldNs = doc->oldNs;
        if (oldNs) {
          *(void *)(v5 + 96) = xmlCopyNamespaceList(oldNs);
        }
        xmlNodePtr children = doc->children;
        if (children)
        {
          xmlNsPtr v13 = xmlStaticCopyNodeList((xmlDtdPtr)children, v5, (xmlNodePtr)v5);
          *(void *)(v5 + 2xmlSAX2Text((uint64_t)ctx, (char *)value, len, 4) = v13;
          *(void *)(v5 + 32) = 0;
          if (v13)
          {
            do
            {
              unsigned int v14 = v13;
              xmlNsPtr v13 = v13->next;
            }
            while (v13);
            *(void *)(v5 + 32) = v14;
          }
        }
        return (xmlDocPtr)v5;
      }
      uint64_t v10 = (xmlNode *)xmlCopyDtd(intSubset);
      *(void *)(v5 + 80) = v10;
      if (v10)
      {
        xmlSetTreeDoc(v10, (xmlDocPtr)v5);
        *(void *)(*(void *)(v5 + 80) + 40) = v5;
        goto LABEL_13;
      }
      xmlFreeDoc((xmlDocPtr)v5);
      return 0;
    }
  }
  return (xmlDocPtr)v5;
}

uint64_t xmlGetLineNo(const xmlNode *node)
{
  return xmlGetLineNoInternal((uint64_t)node, 0);
}

uint64_t xmlGetLineNoInternal(uint64_t a1, int a2)
{
  uint64_t v2 = -1;
  if (a1 && a2 <= 4)
  {
    uint64_t v3 = (a2 + 1);
    while (1)
    {
      unsigned int v4 = *(_DWORD *)(a1 + 8);
      if (v4 <= 8 && ((1 << v4) & 0x18A) != 0) {
        break;
      }
      uint64_t v6 = *(void *)(a1 + 56);
      if (v6
        && ((v7 = *(_DWORD *)(v6 + 8), BOOL v8 = v7 > 8, v9 = (1 << v7) & 0x18A, !v8) ? (v10 = v9 == 0) : (v10 = 1), !v10)
        || (uint64_t v6 = *(void *)(a1 + 40)) != 0 && *(_DWORD *)(v6 + 8) == 1)
      {
        uint64_t v3 = (v3 + 1);
        a1 = v6;
        if (v3 != 6) {
          continue;
        }
      }
      return -1;
    }
    uint64_t v2 = *(unsigned __int16 *)(a1 + 112);
    if (v2 == 0xFFFF)
    {
      if (v4 == 1)
      {
        uint64_t v12 = *(void *)(a1 + 24);
        if (v12) {
          goto LABEL_26;
        }
      }
      else if (v4 == 3)
      {
        uint64_t LineNoInternal = *(void *)(a1 + 104);
        if (LineNoInternal)
        {
LABEL_28:
          if (LineNoInternal == -1) {
            uint64_t v14 = 0xFFFFLL;
          }
          else {
            uint64_t v14 = LineNoInternal;
          }
          if (LineNoInternal != 0xFFFF) {
            return v14;
          }
          return v2;
        }
      }
      uint64_t v12 = *(void *)(a1 + 48);
      if (!v12)
      {
        uint64_t v13 = *(void *)(a1 + 56);
        if (!v13) {
          return v2;
        }
        goto LABEL_27;
      }
LABEL_26:
      uint64_t v13 = v12;
LABEL_27:
      uint64_t LineNoInternal = xmlGetLineNoInternal(v13, v3);
      goto LABEL_28;
    }
  }
  return v2;
}

xmlChar *__cdecl xmlGetNodePath(const xmlNode *node)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if (!node) {
    return 0;
  }
  xmlNsPtr v1 = node;
  if (node->type == XML_NAMESPACE_DECL) {
    return 0;
  }
  uint64_t v2 = (xmlChar *)xmlMallocAtomic(0x1F4uLL);
  if (!v2)
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"getting node path");
    return v2;
  }
  uint64_t v3 = xmlMallocAtomic(0x1F4uLL);
  if (!v3)
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"getting node path");
    ((void (*)(xmlChar *))xmlFree)(v2);
    return 0;
  }
  unsigned int v4 = v3;
  int v39 = 0;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  size_t v5 = 500;
  *(_OWORD *)char __str = 0u;
  long long v34 = 0u;
  *uint64_t v2 = 0;
  while (1)
  {
    switch(v1->type)
    {
      case XML_ELEMENT_NODE:
        xmlNsPtr ns = v1->ns;
        if (!ns) {
          goto LABEL_22;
        }
        prefix = (const char *)ns->prefix;
        if (prefix)
        {
          snprintf(__str, 0x63uLL, "%s:%s", prefix, (const char *)v1->name);
          HIBYTE(v39) = 0;
LABEL_22:
          int v12 = 1;
        }
        else
        {
          int v12 = 0;
        }
        xmlNodePtr parent = v1->parent;
        uint64_t prev = v1->prev;
        if (prev)
        {
          int v23 = 0;
          do
          {
            if (prev->type == XML_ELEMENT_NODE)
            {
              if (!v12
                || xmlStrEqual(v1->name, prev->name)
                && ((v24 = prev->ns, BOOL v25 = v1->ns, v24 == v25) || v24 && v25 && xmlStrEqual(v25->prefix, v24->prefix)))
              {
                ++v23;
              }
            }
            uint64_t prev = prev->prev;
          }
          while (prev);
          if (v23)
          {
            int v9 = v23 + 1;
            goto LABEL_85;
          }
        }
        xmlNodePtr next = v1->next;
        if (!next) {
          goto LABEL_79;
        }
        while (1)
        {
          if (next->type == XML_ELEMENT_NODE)
          {
            if (!v12) {
              break;
            }
            if (xmlStrEqual(v1->name, next->name))
            {
              signed int v27 = next->ns;
              uint64_t v28 = v1->ns;
              if (v27 == v28 || v27 && v28 && xmlStrEqual(v28->prefix, v27->prefix)) {
                break;
              }
            }
          }
          xmlNodePtr next = next->next;
          if (!next)
          {
LABEL_79:
            int v9 = 0;
            goto LABEL_85;
          }
        }
        int v9 = 1;
        goto LABEL_85;
      case XML_ATTRIBUTE_NODE:
        uint64_t v13 = v1->ns;
        if (v13)
        {
          if (v13->prefix) {
            snprintf(__str, 0x63uLL, "%s:%s");
          }
          else {
            snprintf(__str, 0x63uLL, "%s");
          }
          HIBYTE(v39) = 0;
        }
        int v9 = 0;
        xmlNodePtr parent = v1->parent;
        goto LABEL_85;
      case XML_TEXT_NODE:
      case XML_CDATA_SECTION_NODE:
        xmlNodePtr parent = v1->parent;
        unsigned int v7 = v1->prev;
        if (v7)
        {
          int v8 = 0;
          do
          {
            if (v7->type - 3 < 2) {
              ++v8;
            }
            unsigned int v7 = v7->prev;
          }
          while (v7);
          if (v8)
          {
            int v9 = v8 + 1;
            goto LABEL_85;
          }
        }
        break;
      case XML_PI_NODE:
        snprintf(__str, 0x63uLL, "processing-instruction('%s')", (const char *)v1->name);
        HIBYTE(v39) = 0;
        xmlNodePtr parent = v1->parent;
        uint64_t v14 = v1->prev;
        if (v14)
        {
          int v15 = 0;
          do
          {
            if (v14->type == XML_PI_NODE && xmlStrEqual(v1->name, v14->name)) {
              ++v15;
            }
            uint64_t v14 = v14->prev;
          }
          while (v14);
          if (v15)
          {
            int v9 = v15 + 1;
            goto LABEL_85;
          }
        }
        signed int v18 = v1->next;
        if (v18)
        {
          do
          {
            if (v18->type == XML_PI_NODE)
            {
              int v9 = xmlStrEqual(v1->name, v18->name) != 0;
              if (v9) {
                goto LABEL_85;
              }
            }
            else
            {
              int v9 = 0;
            }
            signed int v18 = v18->next;
          }
          while (v18);
        }
        else
        {
          int v9 = 0;
        }
        goto LABEL_85;
      case XML_COMMENT_NODE:
        xmlNodePtr parent = v1->parent;
        unsigned int v16 = v1->prev;
        if (!v16) {
          goto LABEL_49;
        }
        int v17 = 0;
        do
        {
          if (v16->type == XML_COMMENT_NODE) {
            ++v17;
          }
          unsigned int v16 = v16->prev;
        }
        while (v16);
        if (v17)
        {
          int v9 = v17 + 1;
        }
        else
        {
LABEL_49:
          uint64_t v19 = v1->next;
          if (v19)
          {
            do
            {
              xmlElementType type = v19->type;
              uint64_t v19 = v19->next;
              if (v19) {
                BOOL v21 = type == XML_COMMENT_NODE;
              }
              else {
                BOOL v21 = 1;
              }
            }
            while (!v21);
            int v9 = type == XML_COMMENT_NODE;
          }
          else
          {
            int v9 = 0;
          }
        }
        goto LABEL_85;
      case XML_DOCUMENT_NODE:
      case XML_HTML_DOCUMENT_NODE:
        if (*v2 == 47) {
          goto LABEL_97;
        }
        xmlNodePtr parent = 0;
        int v9 = 0;
        goto LABEL_85;
      default:
        goto LABEL_99;
    }
    while (1)
    {
      xmlNsPtr v1 = v1->next;
      if (!v1) {
        break;
      }
      if (v1->type - 3 < 2)
      {
        int v9 = 1;
        goto LABEL_85;
      }
    }
    int v9 = 0;
LABEL_85:
    if (xmlStrlen(v2) + 120 <= v5) {
      goto LABEL_89;
    }
    size_t v5 = 2 * v5 + xmlStrlen(v2) + 120;
    uint64_t v29 = (xmlChar *)xmlRealloc(v2, v5);
    if (!v29) {
      break;
    }
    BOOL v30 = v29;
    uint64_t v31 = xmlRealloc(v4, v5);
    if (!v31)
    {
      __xmlSimpleError(2, 2, 0, 0, (uint64_t)"getting node path");
      xmlFree(v4);
      ((void (*)(xmlChar *))xmlFree)(v30);
      return 0;
    }
    uint64_t v2 = v30;
    unsigned int v4 = v31;
LABEL_89:
    if (v9) {
      snprintf((char *)v4, v5, "%s%s[%d]%s");
    }
    else {
      snprintf((char *)v4, v5, "%s%s%s");
    }
    snprintf((char *)v2, v5, "%s", (const char *)v4);
    xmlNsPtr v1 = parent;
    if (!parent)
    {
LABEL_97:
      xmlFree(v4);
      return v2;
    }
  }
  __xmlSimpleError(2, 2, 0, 0, (uint64_t)"getting node path");
LABEL_99:
  xmlFree(v4);
  ((void (*)(xmlChar *))xmlFree)(v2);
  return 0;
}

xmlNodePtr xmlDocSetRootElement(xmlDocPtr doc, xmlNodePtr root)
{
  uint64_t v2 = 0;
  if (doc && root)
  {
    if (root->type == XML_NAMESPACE_DECL)
    {
      return 0;
    }
    else
    {
      xmlUnlinkNode(root);
      xmlSetTreeDoc(root, doc);
      root->xmlNodePtr parent = (_xmlNode *)doc;
      xmlNodePtr children = doc->children;
      if (children)
      {
        uint64_t v2 = doc->children;
        while (v2->type != XML_ELEMENT_NODE)
        {
          uint64_t v2 = v2->next;
          if (!v2)
          {
            xmlAddSibling(children, root);
            return 0;
          }
        }
        xmlReplaceNode(v2, root);
      }
      else
      {
        uint64_t v2 = 0;
        doc->xmlNodePtr children = root;
        doc->xmlNodePtr last = root;
      }
    }
  }
  return v2;
}

void xmlNodeSetLang(xmlNodePtr cur, const xmlChar *lang)
{
  if (cur)
  {
    if (cur->type - 3 >= 0x13)
    {
      unsigned int v4 = xmlSearchNsByHref(cur->doc, cur, (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
      if (v4)
      {
        xmlSetNsProp(cur, v4, (const xmlChar *)"lang", lang);
      }
    }
  }
}

xmlNsPtr xmlSearchNsByHref(xmlDocPtr doc, xmlNodePtr node, const xmlChar *href)
{
  if (!node) {
    return 0;
  }
  oldNs = 0;
  if (!href || node->type == XML_NAMESPACE_DECL) {
    return oldNs;
  }
  if (xmlStrEqual(href, (const xmlChar *)"http://www.w3.org/XML/1998/namespace"))
  {
    if (doc) {
      goto LABEL_6;
    }
    if (node->type == XML_ELEMENT_NODE)
    {
      unsigned int v16 = (_xmlNs *)xmlMalloc(0x30uLL);
      oldNs = v16;
      if (v16)
      {
        *(_OWORD *)&v16->href = 0u;
        *(_OWORD *)&v16->_private = 0u;
        *(_OWORD *)&v16->xmlNodePtr next = 0u;
        v16->xmlElementType type = XML_NAMESPACE_DECL;
        v16->href = xmlStrdup((const xmlChar *)"http://www.w3.org/XML/1998/namespace");
        oldNs->prefix = xmlStrdup((const xmlChar *)"xml");
        oldNs->xmlNodePtr next = node->nsDef;
        node->nsDef = oldNs;
      }
      else
      {
        __xmlSimpleError(2, 2, 0, 0, (uint64_t)"searching namespace");
      }
      return oldNs;
    }
    xmlDocPtr doc = node->doc;
    if (doc)
    {
LABEL_6:
      oldNs = doc->oldNs;
      if (oldNs) {
        return oldNs;
      }
      return (xmlNsPtr)xmlTreeEnsureXMLDecl((uint64_t)doc);
    }
    return 0;
  }
  xmlElementType type = node->type;
  xmlNodePtr v9 = node;
  while (1)
  {
    xmlElementType v10 = v9->type;
    if (v10 != XML_ELEMENT_NODE)
    {
      if (v10 - 5 < 2 || v10 == XML_ENTITY_DECL) {
        return 0;
      }
      goto LABEL_32;
    }
    oldNs = v9->nsDef;
    if (oldNs) {
      break;
    }
LABEL_25:
    if (v9 != node)
    {
      oldNs = v9->ns;
      if (oldNs)
      {
        uint64_t v14 = oldNs->href;
        if (v14)
        {
          if (xmlStrEqual(v14, href))
          {
            prefix = (xmlChar *)oldNs->prefix;
            if ((type != XML_ATTRIBUTE_NODE || prefix)
              && xmlNsInScope((uint64_t)node, (uint64_t)v9, prefix) == 1)
            {
              return oldNs;
            }
          }
        }
      }
    }
LABEL_32:
    oldNs = 0;
    xmlNodePtr v9 = v9->parent;
    if (!v9) {
      return oldNs;
    }
  }
  while (1)
  {
    int v12 = oldNs->href;
    if (v12)
    {
      if (xmlStrEqual(v12, href))
      {
        uint64_t v13 = (xmlChar *)oldNs->prefix;
        if ((type != XML_ATTRIBUTE_NODE || v13) && xmlNsInScope((uint64_t)node, (uint64_t)v9, v13) == 1) {
          return oldNs;
        }
      }
    }
    oldNs = oldNs->next;
    if (!oldNs) {
      goto LABEL_25;
    }
  }
}

xmlAttrPtr xmlSetNsProp(xmlNodePtr node, xmlNsPtr ns, const xmlChar *name, const xmlChar *value)
{
  if (ns)
  {
    href = ns->href;
    if (!href) {
      return 0;
    }
  }
  else
  {
    href = 0;
  }
  xmlAttributePtr PropNodeInternal = xmlGetPropNodeInternal((uint64_t)node, (xmlChar *)name, href, 0);
  if (PropNodeInternal)
  {
    xmlAttributePtr v9 = PropNodeInternal;
    if (PropNodeInternal->atype == XML_ATTRIBUTE_ID)
    {
      xmlRemoveID(node->doc, (xmlAttrPtr)PropNodeInternal);
      v9->axmlElementType type = XML_ATTRIBUTE_ID;
    }
    p_xmlNodePtr children = &v9->children;
    xmlNodePtr children = v9->children;
    if (children) {
      xmlFreeNodeList(children);
    }
    *p_xmlNodePtr children = 0;
    v9->xmlNodePtr last = 0;
    v9->nexth = (_xmlAttribute *)ns;
    if (value)
    {
      xmlDocPtr doc = node->doc;
      xmlNodePtr v14 = xmlNewText(value);
      if (v14)
      {
        v14->xmlDocPtr doc = doc;
        *p_xmlNodePtr children = v14;
        do
        {
          xmlNodePtr v15 = v14;
          v14->xmlNodePtr parent = (_xmlNode *)v9;
          xmlNodePtr v14 = v14->next;
        }
        while (v14);
      }
      else
      {
        xmlNodePtr v15 = 0;
        *p_xmlNodePtr children = 0;
      }
      v9->xmlNodePtr last = v15;
    }
    if (v9->atype == XML_ATTRIBUTE_ID) {
      xmlAddID(0, node->doc, value, (xmlAttrPtr)v9);
    }
    return (xmlAttrPtr)v9;
  }

  return xmlNewPropInternal((uint64_t)node, ns, (xmlChar *)name, value, 0);
}

xmlChar *__cdecl xmlNodeGetLang(xmlChar *cur)
{
  if (cur)
  {
    xmlNsPtr v1 = (const xmlNode *)cur;
    if (*((_DWORD *)cur + 2) == 18)
    {
      return 0;
    }
    else
    {
      while (1)
      {
        xmlDocPtr cur = xmlGetNsProp(v1, (const xmlChar *)"lang", (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
        if (cur) {
          break;
        }
        xmlNsPtr v1 = v1->parent;
        if (!v1) {
          return 0;
        }
      }
    }
  }
  return cur;
}

xmlChar *__cdecl xmlGetNsProp(const xmlNode *node, const xmlChar *name, const xmlChar *nameSpace)
{
  xmlAttrPtr result = (xmlChar *)xmlGetPropNodeInternal((uint64_t)node, (xmlChar *)name, nameSpace, 1);
  if (result)
  {
    return xmlGetPropNodeValueInternal((uint64_t)result);
  }
  return result;
}

void xmlNodeSetSpacePreserve(xmlNodePtr cur, int val)
{
  if (cur)
  {
    if (cur->type - 3 >= 0x13)
    {
      unsigned int v4 = xmlSearchNsByHref(cur->doc, cur, (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
      if (v4)
      {
        if (val)
        {
          if (val != 1) {
            return;
          }
          size_t v5 = "preserve";
        }
        else
        {
          size_t v5 = "default";
        }
        xmlSetNsProp(cur, v4, (const xmlChar *)"space", (const xmlChar *)v5);
      }
    }
  }
}

int xmlNodeGetSpacePreserve(const xmlNode *cur)
{
  if (!cur) {
    return -1;
  }
  xmlNsPtr v1 = cur;
  if (cur->type != XML_ELEMENT_NODE) {
    return -1;
  }
  while (1)
  {
    NsProp = xmlGetNsProp(v1, (const xmlChar *)"space", (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
    if (NsProp) {
      break;
    }
LABEL_7:
    xmlNsPtr v1 = v1->parent;
    if (!v1) {
      return -1;
    }
  }
  uint64_t v3 = NsProp;
  if (xmlStrEqual(NsProp, (const xmlChar *)"preserve"))
  {
    int v4 = 1;
    goto LABEL_12;
  }
  if (!xmlStrEqual(v3, (const xmlChar *)"default"))
  {
    xmlFree(v3);
    goto LABEL_7;
  }
  int v4 = 0;
LABEL_12:
  xmlFree(v3);
  return v4;
}

void xmlNodeSetName(xmlNodePtr cur, const xmlChar *name)
{
  if (cur && name)
  {
    xmlElementType type = cur->type;
    BOOL v5 = type > XML_DOCB_DOCUMENT_NODE;
    int v6 = (1 << type) & 0x3C3D18;
    if (v5 || v6 == 0)
    {
      xmlDocPtr doc = cur->doc;
      if (doc && (dict = doc->dict) != 0)
      {
        xmlElementType v10 = cur->name;
        if (v10 && !xmlDictOwns(doc->dict, v10)) {
          xmlNsPtr v11 = cur->name;
        }
        else {
          xmlNsPtr v11 = 0;
        }
        int v12 = xmlDictLookup(dict, name, -1);
      }
      else
      {
        xmlNsPtr v11 = cur->name;
        int v12 = xmlStrdup(name);
      }
      cur->name = v12;
      if (v11)
      {
        xmlFreeFunc v13 = xmlFree;
        ((void (*)(const xmlChar *))v13)(v11);
      }
    }
  }
}

void xmlNodeSetBase(xmlNodePtr cur, const xmlChar *uri)
{
  if (cur)
  {
    xmlElementType type = cur->type;
    if (type > XML_DOCB_DOCUMENT_NODE) {
      goto LABEL_12;
    }
    int v5 = 1 << type;
    if ((v5 & 0x1FDDF8) != 0) {
      return;
    }
    if ((v5 & 0x202200) != 0)
    {
      name = (xmlChar *)cur[1].name;
      if (name) {
        xmlFree(name);
      }
      if (uri) {
        unsigned int v7 = xmlPathToURI(uri);
      }
      else {
        unsigned int v7 = 0;
      }
      cur[1].name = v7;
    }
    else
    {
LABEL_12:
      xmlNsPtr v8 = xmlSearchNsByHref(cur->doc, cur, (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
      if (v8)
      {
        xmlAttributePtr v9 = v8;
        xmlElementType v10 = xmlPathToURI(uri);
        if (v10)
        {
          xmlNsPtr v11 = v10;
          xmlSetNsProp(cur, v9, (const xmlChar *)"base", v10);
          xmlFreeFunc v12 = xmlFree;
          ((void (*)(xmlChar *))v12)(v11);
        }
        else
        {
          xmlSetNsProp(cur, v9, (const xmlChar *)"base", uri);
        }
      }
    }
  }
}

xmlChar *__cdecl xmlNodeGetBase(const xmlDoc *doc, const xmlNode *cur)
{
  if (!((unint64_t)doc | (unint64_t)cur)) {
    return 0;
  }
  uint64_t v2 = cur;
  uint64_t v3 = doc;
  if (cur)
  {
    if (cur->type == XML_NAMESPACE_DECL) {
      return 0;
    }
  }
  if (!doc)
  {
    uint64_t v3 = cur->doc;
    if (!v3)
    {
      char v16 = 1;
      goto LABEL_24;
    }
  }
  if (v3->type == XML_HTML_DOCUMENT_NODE)
  {
    xmlNodePtr children = v3->children;
    if (children)
    {
      while (1)
      {
        name = children->name;
        if (!name) {
          return 0;
        }
        if (children->type == XML_ELEMENT_NODE)
        {
          if (!xmlStrcasecmp(name, (const xmlChar *)"html") || !xmlStrcasecmp(children->name, (const xmlChar *)"head"))
          {
            p_xmlNodePtr children = &children->children;
            goto LABEL_15;
          }
          if (!xmlStrcasecmp(children->name, (const xmlChar *)"base"))
          {
            return xmlGetProp(children, (const xmlChar *)"href");
          }
        }
        p_xmlNodePtr children = &children->next;
LABEL_15:
        xmlNodePtr children = *p_children;
        if (!*p_children) {
          return 0;
        }
      }
    }
    return 0;
  }
  if (!cur)
  {
    URL = v3->URL;
    if (URL) {
      goto LABEL_20;
    }
    return 0;
  }
  char v16 = 0;
LABEL_24:
  xmlAttributePtr v9 = 0;
  do
  {
    xmlElementType type = v2->type;
    if (type == XML_ELEMENT_NODE)
    {
      NsProp = xmlGetNsProp(v2, (const xmlChar *)"base", (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
      if (NsProp)
      {
        xmlFreeFunc v13 = NsProp;
        if (v9)
        {
          xmlNodePtr v14 = xmlBuildURI(v9, NsProp);
          xmlFree(v9);
          xmlFree(v13);
          xmlAttributePtr v9 = v14;
          if (!v14) {
            return v9;
          }
        }
        else
        {
          xmlAttributePtr v9 = NsProp;
        }
        if (!xmlStrncmp(v9, (const xmlChar *)"http://", 7)
          || !xmlStrncmp(v9, (const xmlChar *)"ftp://", 6)
          || !xmlStrncmp(v9, (const xmlChar *)"urn:", 4))
        {
          return v9;
        }
      }
    }
    else if (type == XML_ENTITY_DECL)
    {
      xmlNsPtr v8 = (const xmlChar *)v2[1]._private;
      goto LABEL_41;
    }
    uint64_t v2 = v2->parent;
  }
  while (v2);
  if (v16) {
    return v9;
  }
  URL = v3->URL;
  if (!URL) {
    return v9;
  }
  if (v9)
  {
    xmlNodePtr v15 = xmlBuildURI(v9, URL);
    xmlFree(v9);
    return v15;
  }
LABEL_20:
  xmlNsPtr v8 = URL;
LABEL_41:

  return xmlStrdup(v8);
}

int xmlNodeBufGetContent(xmlBufferPtr buffer, const xmlNode *cur)
{
  int result = -1;
  if (buffer && cur)
  {
    int v5 = xmlBufFromBuffer((uint32x2_t *)buffer);
    int NodeContent = xmlBufGetNodeContent((xmlBufPtr)v5, cur);
    uint64_t v7 = xmlBufBackToBuffer(v5);
    int v9 = NodeContent < 0 || v7 == 0;
    return v9 << 31 >> 31;
  }
  return result;
}

void xmlNodeSetContentLen(xmlNodePtr cur, const xmlChar *content, int len)
{
  if (!cur) {
    return;
  }
  xmlElementType type = cur->type;
  if (type > XML_NOTATION_NODE) {
    return;
  }
  int v7 = 1 << type;
  if ((v7 & 0x11F8) != 0)
  {
    xmlNsPtr v8 = cur->content;
    p_int properties = &cur->properties;
    if (v8) {
      BOOL v10 = v8 == (xmlChar *)p_properties;
    }
    else {
      BOOL v10 = 1;
    }
    if (v10) {
      goto LABEL_13;
    }
    xmlDocPtr doc = cur->doc;
    if (doc)
    {
      dict = doc->dict;
      if (dict)
      {
        if (xmlDictOwns(dict, v8))
        {
LABEL_13:
          xmlNodePtr children = cur->children;
          if (children) {
            xmlFreeNodeList(children);
          }
          cur->xmlNodePtr children = 0;
          cur->xmlNodePtr last = 0;
          if (content) {
            xmlNodePtr v14 = xmlStrndup(content, len);
          }
          else {
            xmlNodePtr v14 = 0;
          }
          cur->content = v14;
          *p_int properties = 0;
          cur->nsDef = 0;
          return;
        }
        xmlNsPtr v8 = cur->content;
      }
    }
    xmlFree(v8);
    goto LABEL_13;
  }
  if ((v7 & 0x806) != 0)
  {
    xmlNodePtr v15 = cur->children;
    if (v15) {
      xmlFreeNodeList(v15);
    }
    xmlNodePtr NodeList = xmlStringLenGetNodeList(cur->doc, content, len);
    cur->xmlNodePtr children = NodeList;
    if (NodeList)
    {
      xmlNodePtr next = NodeList->next;
      if (next)
      {
        do
        {
          signed int v18 = next;
          NodeList->xmlNodePtr parent = cur;
          xmlNodePtr next = next->next;
          xmlNodePtr NodeList = v18;
        }
        while (next);
      }
      else
      {
        signed int v18 = NodeList;
      }
      v18->xmlNodePtr parent = cur;
      cur->xmlNodePtr last = v18;
    }
    else
    {
      cur->xmlNodePtr last = 0;
    }
  }
}

void xmlNodeAddContentLen(xmlNodePtr cur, const xmlChar *content, int len)
{
  if (cur)
  {
    if (len >= 1)
    {
      xmlElementType type = cur->type;
      if (type <= XML_NOTATION_NODE)
      {
        int v7 = 1 << type;
        if ((v7 & 0x11F8) != 0)
        {
          if (content)
          {
            xmlNsPtr v8 = cur->content;
            p_int properties = &cur->properties;
            if (v8 == (xmlChar *)&cur->properties
              || (xmlDocPtr doc = cur->doc) != 0
              && (dict = doc->dict) != 0
              && (v12 = xmlDictOwns(dict, v8), xmlNsPtr v8 = cur->content, v12))
            {
              cur->content = xmlStrncatNew(v8, content, len);
              *p_int properties = 0;
              cur->nsDef = 0;
            }
            else
            {
              cur->content = xmlStrncat(v8, content, len);
            }
          }
        }
        else if ((v7 & 0x802) != 0)
        {
          xmlNodePtr last = cur->last;
          xmlNodePtr v14 = xmlNewTextLen(content, len);
          if (v14)
          {
            xmlNodePtr v15 = v14;
            if (xmlAddChild(cur, v14) == v14 && last && last->next == v15)
            {
              xmlTextMerge(last, v15);
            }
          }
        }
      }
    }
  }
}

xmlNodePtr xmlTextMerge(xmlNodePtr first, xmlNodePtr second)
{
  if (!first) {
    return second;
  }
  uint64_t v3 = first;
  if (second && first->type == XML_TEXT_NODE && second->type == XML_TEXT_NODE && second->name == first->name)
  {
    xmlNodeAddContent(first, second->content);
    xmlUnlinkNode(second);
    xmlFreeNode(second);
  }
  return v3;
}

xmlNsPtr *__cdecl xmlGetNsList(const xmlDoc *doc, const xmlNode *node)
{
  if (!node) {
    return 0;
  }
  uint64_t v2 = node;
  if (node->type == XML_NAMESPACE_DECL) {
    return 0;
  }
  LODWORD(vxmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0;
  int v4 = 0;
  int v5 = 10;
  do
  {
    if (v2->type == XML_ELEMENT_NODE)
    {
      for (uint64_t i = v2->nsDef; i; uint64_t i = i->next)
      {
        if (!v4)
        {
          int v7 = (char *)xmlMalloc(8 * (v5 + 1));
          if (!v7) {
            goto LABEL_21;
          }
          int v4 = v7;
          *(void *)&v7[8 * (int)v3] = 0;
        }
        if ((int)v3 < 1)
        {
LABEL_14:
          if ((int)v3 >= v5)
          {
            xmlNsPtr v11 = (char *)xmlRealloc(v4, 8 * ((2 * v5) | 1));
            if (!v11)
            {
LABEL_21:
              __xmlSimpleError(2, 2, 0, 0, (uint64_t)"getting namespace list");
              return 0;
            }
            int v4 = v11;
            v5 *= 2;
          }
          *(void *)&v4[8 * (int)v3] = i;
          uint64_t v3 = (int)v3 + 1;
          *(void *)&v4[8 * v3] = 0;
        }
        else
        {
          uint64_t v8 = 0;
          while (1)
          {
            prefix = i->prefix;
            BOOL v10 = *(const xmlChar **)(*(void *)&v4[v8] + 24);
            if (prefix == v10 || xmlStrEqual(prefix, v10)) {
              break;
            }
            v8 += 8;
            if (8 * v3 == v8) {
              goto LABEL_14;
            }
          }
        }
      }
    }
    uint64_t v2 = v2->parent;
  }
  while (v2);
  return (xmlNsPtr *)v4;
}

xmlNsPtr xmlSearchNs(xmlDocPtr doc, xmlNodePtr node, const xmlChar *nameSpace)
{
  if (!node || node->type == XML_NAMESPACE_DECL) {
    return 0;
  }
  if (!nameSpace || !xmlStrEqual(nameSpace, (const xmlChar *)"xml"))
  {
    xmlNodePtr v8 = node;
    while (1)
    {
      xmlElementType type = v8->type;
      if (type == XML_ELEMENT_NODE)
      {
        for (uint64_t i = v8->nsDef; i; uint64_t i = i->next)
        {
          prefix = i->prefix;
          if ((unint64_t)nameSpace | (unint64_t)prefix)
          {
            if (nameSpace && prefix && i->href && xmlStrEqual(prefix, nameSpace)) {
              return i;
            }
          }
          else if (i->href)
          {
            return i;
          }
        }
        if (v8 != node)
        {
          uint64_t i = v8->ns;
          if (i)
          {
            int v12 = i->prefix;
            if ((unint64_t)nameSpace | (unint64_t)v12)
            {
              if (nameSpace && v12 && i->href && xmlStrEqual(v12, nameSpace)) {
                return i;
              }
            }
            else if (i->href)
            {
              return i;
            }
          }
        }
      }
      else if (type - 5 < 2 || type == XML_ENTITY_DECL)
      {
        return 0;
      }
      xmlNodePtr v8 = v8->parent;
      if (!v8) {
        return 0;
      }
    }
  }
  if (!doc)
  {
    if (node->type == XML_ELEMENT_NODE)
    {
      xmlFreeFunc v13 = (xmlNs *)xmlMalloc(0x30uLL);
      uint64_t i = v13;
      if (v13)
      {
        *(_OWORD *)&v13->href = 0u;
        *(_OWORD *)&v13->_private = 0u;
        *(_OWORD *)&v13->xmlNodePtr next = 0u;
        v13->xmlElementType type = XML_NAMESPACE_DECL;
        v13->href = xmlStrdup((const xmlChar *)"http://www.w3.org/XML/1998/namespace");
        i->prefix = xmlStrdup((const xmlChar *)"xml");
        i->xmlNodePtr next = node->nsDef;
        node->nsDef = i;
      }
      else
      {
        __xmlSimpleError(2, 2, 0, 0, (uint64_t)"searching namespace");
      }
      return i;
    }
    xmlDocPtr doc = node->doc;
    if (!doc) {
      return 0;
    }
  }
  uint64_t i = doc->oldNs;
  if (i) {
    return i;
  }

  return (xmlNsPtr)xmlTreeEnsureXMLDecl((uint64_t)doc);
}

_OWORD *xmlTreeEnsureXMLDecl(uint64_t a1)
{
  xmlNsPtr v1 = *(_OWORD **)(a1 + 96);
  if (!v1)
  {
    uint64_t v3 = xmlMalloc(0x30uLL);
    xmlNsPtr v1 = v3;
    if (v3)
    {
      v3[1] = 0u;
      void v3[2] = 0u;
      _OWORD *v3 = 0u;
      *((_DWORD *)v3 + 2) = 18;
      *((void *)v3 + 2) = xmlStrdup((const xmlChar *)"http://www.w3.org/XML/1998/namespace");
      *((void *)v1 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = xmlStrdup((const xmlChar *)"xml");
      *(void *)(a1 + 96) = v1;
    }
    else
    {
      __xmlSimpleError(2, 2, 0, 0, (uint64_t)"allocating the XML namespace");
    }
  }
  return v1;
}

uint64_t xmlNsInScope(uint64_t a1, uint64_t a2, xmlChar *str2)
{
  BOOL v3 = a1 != a2;
  if (!a1 || a1 == a2)
  {
LABEL_22:
    if (v3) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 1;
    }
  }
  uint64_t v6 = a1;
  while (1)
  {
    int v7 = *(_DWORD *)(v6 + 8);
    if (v7 == 1) {
      break;
    }
    if ((v7 - 5) < 2 || v7 == 17) {
      return 0xFFFFFFFFLL;
    }
LABEL_17:
    uint64_t v6 = *(void *)(v6 + 40);
    BOOL v3 = v6 != a2;
    if (v6) {
      BOOL v11 = v6 == a2;
    }
    else {
      BOOL v11 = 1;
    }
    if (v11) {
      goto LABEL_22;
    }
  }
  int v9 = *(void **)(v6 + 96);
  if (!v9) {
    goto LABEL_17;
  }
  while (1)
  {
    BOOL v10 = (const xmlChar *)v9[3];
    if (!((unint64_t)str2 | (unint64_t)v10) || str2 && v10 && xmlStrEqual(v10, str2)) {
      return 0;
    }
    int v9 = (void *)*v9;
    if (!v9) {
      goto LABEL_17;
    }
  }
}

int xmlReconciliateNs(xmlDocPtr doc, xmlNodePtr tree)
{
  if (!tree) {
    return -1;
  }
  int result = -1;
  if (doc && tree->type == XML_ELEMENT_NODE && doc->type == XML_DOCUMENT_NODE && tree->doc == doc)
  {
    int v5 = 0;
    int v6 = 0;
    int v7 = 0;
    xmlNodePtr v8 = 0;
    xmlNodePtr v9 = tree;
    while (1)
    {
      if (v9->ns)
      {
        if (!v6)
        {
          BOOL v10 = xmlMalloc(0x50uLL);
          if (!v10)
          {
LABEL_67:
            __xmlSimpleError(2, 2, 0, 0, (uint64_t)"fixing namespaces");
            return -1;
          }
          xmlNodePtr v8 = v10;
          BOOL v11 = xmlMalloc(0x50uLL);
          if (!v11) {
            goto LABEL_66;
          }
          int v7 = v11;
          int v6 = 10;
        }
        if (v5 < 1)
        {
          LODWORD(v12) = 0;
        }
        else
        {
          uint64_t v12 = 0;
          while ((xmlNs *)v8[v12] != v9->ns)
          {
            if (v5 == ++v12) {
              goto LABEL_20;
            }
          }
          v9->xmlNsPtr ns = (xmlNs *)v7[v12];
        }
        if (v12 == v5)
        {
LABEL_20:
          xmlNsPtr v13 = xmlNewReconciledNs(doc, tree, (uint64_t)v9->ns);
          if (v13)
          {
            xmlNodePtr v14 = v13;
            if (v6 <= v5)
            {
              v6 *= 2;
              xmlNodePtr v15 = xmlRealloc(v8, 8 * v6);
              if (!v15)
              {
LABEL_68:
                __xmlSimpleError(2, 2, 0, 0, (uint64_t)"fixing namespaces");
                ((void (*)(void *))xmlFree)(v7);
                return -1;
              }
              xmlNodePtr v8 = v15;
              char v16 = xmlRealloc(v7, 8 * v6);
              if (!v16)
              {
LABEL_66:
                __xmlSimpleError(2, 2, 0, 0, (uint64_t)"fixing namespaces");
                ((void (*)(void *))xmlFree)(v8);
                return -1;
              }
              int v7 = v16;
            }
            v7[v5] = v14;
            v8[v5++] = v9->ns;
            v9->xmlNsPtr ns = v14;
          }
        }
      }
      if (v9->type == XML_ELEMENT_NODE)
      {
        for (uint64_t i = v9->properties; i; uint64_t i = i->next)
        {
          if (i->ns)
          {
            if (!v6)
            {
              signed int v18 = xmlMalloc(0x50uLL);
              if (!v18) {
                goto LABEL_67;
              }
              xmlNodePtr v8 = v18;
              uint64_t v19 = xmlMalloc(0x50uLL);
              if (!v19) {
                goto LABEL_66;
              }
              int v7 = v19;
              int v6 = 10;
            }
            if (v5 < 1)
            {
              LODWORD(v20) = 0;
            }
            else
            {
              uint64_t v20 = 0;
              while ((xmlNs *)v8[v20] != i->ns)
              {
                if (v5 == ++v20) {
                  goto LABEL_41;
                }
              }
              i->xmlNsPtr ns = (xmlNs *)v7[v20];
            }
            if (v20 == v5)
            {
LABEL_41:
              xmlNsPtr v21 = xmlNewReconciledNs(doc, tree, (uint64_t)i->ns);
              if (v21)
              {
                xmlNsPtr v22 = v21;
                if (v6 <= v5)
                {
                  v6 *= 2;
                  int v23 = xmlRealloc(v8, 8 * v6);
                  if (!v23) {
                    goto LABEL_68;
                  }
                  xmlNodePtr v8 = v23;
                  int v24 = xmlRealloc(v7, 8 * v6);
                  if (!v24) {
                    goto LABEL_66;
                  }
                  int v7 = v24;
                }
                v7[v5] = v22;
                v8[v5++] = i->ns;
                i->xmlNsPtr ns = v22;
              }
            }
          }
        }
      }
      xmlNodePtr children = v9->children;
      if (!children || v9->type == XML_ENTITY_REF_NODE)
      {
        if (v9 == tree) {
          goto LABEL_60;
        }
        xmlNodePtr children = v9->next;
        if (!children)
        {
          while (v9 != tree)
          {
            if (v9->parent) {
              xmlNodePtr v9 = v9->parent;
            }
            if (v9 == tree || (xmlNodePtr children = v9->next) == 0)
            {
              xmlNodePtr children = v9->parent;
              if (children) {
                continue;
              }
            }
            if (children == tree) {
              break;
            }
            goto LABEL_59;
          }
LABEL_60:
          if (v8) {
            xmlFree(v8);
          }
          if (v7) {
            xmlFree(v7);
          }
          return 0;
        }
      }
LABEL_59:
      xmlNodePtr v9 = children;
      if (!children) {
        goto LABEL_60;
      }
    }
  }
  return result;
}

xmlNsPtr xmlNewReconciledNs(xmlDocPtr doc, xmlNodePtr node, uint64_t a3)
{
  xmlNsPtr result = 0;
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a3 && node->type == XML_ELEMENT_NODE)
  {
    if (*(_DWORD *)(a3 + 8) == 18)
    {
      xmlNsPtr result = xmlSearchNsByHref(doc, node, *(const xmlChar **)(a3 + 16));
      if (result) {
        return result;
      }
      __int16 v11 = 0;
      long long v9 = 0u;
      long long v10 = 0u;
      *(_OWORD *)char __str = 0u;
      if (*(void *)(a3 + 24)) {
        snprintf(__str, 0x32uLL, "%.20s", *(const char **)(a3 + 24));
      }
      else {
        strcpy(__str, "default");
      }
      if (!xmlSearchNs(doc, node, (const xmlChar *)__str)) {
        return xmlNewNs(node, *(const xmlChar **)(a3 + 16), (const xmlChar *)__str);
      }
      for (int i = 1; i != 1001; ++i)
      {
        if (*(void *)(a3 + 24)) {
          snprintf(__str, 0x32uLL, "%.20s%d");
        }
        else {
          snprintf(__str, 0x32uLL, "default%d");
        }
        if (!xmlSearchNs(doc, node, (const xmlChar *)__str)) {
          return xmlNewNs(node, *(const xmlChar **)(a3 + 16), (const xmlChar *)__str);
        }
      }
    }
    return 0;
  }
  return result;
}

xmlAttributePtr xmlGetPropNodeInternal(uint64_t a1, xmlChar *str2, const xmlChar *a3, int a4)
{
  if (!a1) {
    return 0;
  }
  xmlAttributePtr v5 = 0;
  if (!str2 || *(_DWORD *)(a1 + 8) != 1) {
    return v5;
  }
  xmlAttributePtr v5 = *(xmlAttributePtr *)(a1 + 88);
  if (!v5)
  {
LABEL_15:
    if (!a4) {
      return 0;
    }
    uint64_t v10 = *(void *)(a1 + 64);
    if (!v10 || !*(void *)(v10 + 80)) {
      return 0;
    }
    uint64_t v11 = *(void *)(a1 + 72);
    if (v11 && (uint64_t v12 = *(const xmlChar **)(v11 + 24)) != 0)
    {
      xmlNsPtr v13 = xmlStrdup(v12);
      xmlNodePtr v14 = xmlStrcat(v13, (const xmlChar *)":");
      xmlNodePtr v15 = xmlStrcat(v14, *(const xmlChar **)(a1 + 16));
      char v16 = v15;
      if (!v15) {
        return 0;
      }
    }
    else
    {
      char v16 = 0;
      xmlNodePtr v15 = *(xmlChar **)(a1 + 16);
    }
    if (a3)
    {
      int v17 = (const xmlDoc *)xmlStrEqual(a3, (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
      if (!v17)
      {
        NsList = xmlGetNsList(v17, (const xmlNode *)a1);
        if (!NsList)
        {
          if (v16) {
            xmlFree(v16);
          }
          return 0;
        }
        int v23 = NsList;
        xmlNsPtr v24 = *NsList;
        if (*NsList)
        {
          BOOL v25 = NsList;
          while (1)
          {
            if (xmlStrEqual(v24->href, a3))
            {
              xmlAttributePtr DtdQAttrDesc = xmlGetDtdQAttrDesc(*(xmlDtdPtr *)(v10 + 80), v15, str2, (*v25)->prefix);
              if (DtdQAttrDesc) {
                break;
              }
              signed int v27 = *(xmlDtd **)(v10 + 88);
              if (v27)
              {
                xmlAttributePtr DtdQAttrDesc = xmlGetDtdQAttrDesc(v27, v15, str2, (*v25)->prefix);
                if (DtdQAttrDesc) {
                  break;
                }
              }
            }
            uint64_t v28 = v25[1];
            ++v25;
            xmlNsPtr v24 = v28;
            if (!v28) {
              goto LABEL_40;
            }
          }
          xmlAttributePtr v5 = DtdQAttrDesc;
        }
        else
        {
LABEL_40:
          xmlAttributePtr v5 = 0;
        }
        xmlFree(v23);
        goto LABEL_46;
      }
      xmlAttributePtr v5 = xmlGetDtdQAttrDesc(*(xmlDtdPtr *)(v10 + 80), v15, str2, (const xmlChar *)"xml");
      if (v5)
      {
LABEL_46:
        if (v16) {
          xmlFree(v16);
        }
        if (!v5 || v5->defaultValue) {
          return v5;
        }
        return 0;
      }
      signed int v18 = *(xmlDtd **)(v10 + 88);
      if (v18)
      {
        uint64_t v19 = (const xmlChar *)"xml";
        uint64_t v20 = v15;
        xmlNsPtr v21 = str2;
LABEL_31:
        xmlAttributePtr v5 = xmlGetDtdQAttrDesc(v18, v20, v21, v19);
        goto LABEL_46;
      }
    }
    else
    {
      xmlAttributePtr v5 = xmlGetDtdQAttrDesc(*(xmlDtdPtr *)(v10 + 80), v15, str2, 0);
      if (v5) {
        goto LABEL_46;
      }
      signed int v18 = *(xmlDtd **)(v10 + 88);
      if (v18)
      {
        uint64_t v20 = v15;
        xmlNsPtr v21 = str2;
        uint64_t v19 = 0;
        goto LABEL_31;
      }
    }
    xmlAttributePtr v5 = 0;
    goto LABEL_46;
  }
  if (a3)
  {
    while (1)
    {
      if (v5->nexth)
      {
        if (xmlStrEqual(v5->name, str2))
        {
          name = v5->nexth->name;
          if (name == a3 || xmlStrEqual(name, a3)) {
            break;
          }
        }
      }
      xmlAttributePtr v5 = (xmlAttributePtr)v5->next;
      if (!v5) {
        goto LABEL_15;
      }
    }
  }
  else
  {
    while (v5->nexth || !xmlStrEqual(v5->name, str2))
    {
      xmlAttributePtr v5 = (xmlAttributePtr)v5->next;
      if (!v5) {
        goto LABEL_15;
      }
    }
  }
  return v5;
}

xmlChar *__cdecl xmlGetNoNsProp(const xmlNode *node, const xmlChar *name)
{
  xmlNsPtr result = (xmlChar *)xmlGetPropNodeInternal((uint64_t)node, (xmlChar *)name, 0, 1);
  if (result)
  {
    return xmlGetPropNodeValueInternal((uint64_t)result);
  }
  return result;
}

int xmlUnsetProp(xmlNodePtr node, const xmlChar *name)
{
  xmlAttributePtr PropNodeInternal = (xmlNode *)xmlGetPropNodeInternal((uint64_t)node, (xmlChar *)name, 0, 0);
  if (!PropNodeInternal) {
    return -1;
  }
  BOOL v3 = (xmlAttr *)PropNodeInternal;
  xmlUnlinkNode(PropNodeInternal);
  xmlFreeProp(v3);
  return 0;
}

int xmlUnsetNsProp(xmlNodePtr node, xmlNsPtr ns, const xmlChar *name)
{
  if (ns) {
    href = ns->href;
  }
  else {
    href = 0;
  }
  xmlAttributePtr PropNodeInternal = (xmlNode *)xmlGetPropNodeInternal((uint64_t)node, (xmlChar *)name, href, 0);
  if (!PropNodeInternal) {
    return -1;
  }
  int v6 = (xmlAttr *)PropNodeInternal;
  xmlUnlinkNode(PropNodeInternal);
  xmlFreeProp(v6);
  return 0;
}

xmlAttrPtr xmlSetProp(xmlNodePtr node, const xmlChar *name, const xmlChar *value)
{
  if (!node || !name || node->type != XML_ELEMENT_NODE) {
    return 0;
  }
  int v6 = *name;
  if (v6 == 58) {
    goto LABEL_5;
  }
  uint64_t v11 = 1;
  if (!*name) {
    goto LABEL_5;
  }
  while (v6 != 58)
  {
    int v6 = name[v11++];
    if (!v6) {
      goto LABEL_5;
    }
  }
  uint64_t v12 = xmlStrndup(name, (int)v11 - 1);
  xmlNsPtr v13 = xmlSearchNs(node->doc, node, v12);
  if (v12) {
    xmlFree(v12);
  }
  if (v13)
  {
    long long v9 = &name[v11];
    int v7 = node;
    xmlNodePtr v8 = v13;
  }
  else
  {
LABEL_5:
    int v7 = node;
    xmlNodePtr v8 = 0;
    long long v9 = name;
  }

  return xmlSetNsProp(v7, v8, v9, value);
}

int xmlIsBlankNode(const xmlNode *node)
{
  if (node)
  {
    if (node->type - 3 <= 1)
    {
      content = node->content;
      if (!content)
      {
LABEL_8:
        LODWORD(node) = 1;
        return (int)node;
      }
      while (1)
      {
        unsigned int v2 = *content;
        if (v2 > 0x20) {
          break;
        }
        if (((1 << v2) & 0x100002600) == 0)
        {
          if (*content) {
            break;
          }
          goto LABEL_8;
        }
        ++content;
      }
    }
    LODWORD(node) = 0;
  }
  return (int)node;
}

int xmlTextConcat(xmlNodePtr node, const xmlChar *content, int len)
{
  if (!node) {
    return -1;
  }
  xmlElementType type = node->type;
  BOOL v5 = type > XML_COMMENT_NODE;
  int v6 = (1 << type) & 0x198;
  if (v5 || v6 == 0) {
    return -1;
  }
  uint64_t v10 = node->content;
  if (v10 == (xmlChar *)&node->properties
    || (doc = node->doc) != 0 && (dict = doc->dict) != 0 && (v13 = xmlDictOwns(dict, v10), uint64_t v10 = node->content, v13))
  {
    xmlNodePtr v14 = xmlStrncatNew(v10, content, len);
  }
  else
  {
    xmlNodePtr v14 = xmlStrncat(v10, content, len);
  }
  node->content = v14;
  node->int properties = 0;
  if (v14) {
    return 0;
  }
  else {
    return -1;
  }
}

xmlBufferPtr xmlBufferCreate(void)
{
  int v0 = (xmlBuffer *)xmlMalloc(0x20uLL);
  xmlNsPtr v1 = v0;
  if (v0)
  {
    v0->uint64_t use = 0;
    v0->unsigned int size = *__xmlDefaultBufferSize();
    v1->alloc = *__xmlBufferAllocScheme();
    unsigned int v2 = (xmlChar *)xmlMallocAtomic(v1->size);
    v1->content = v2;
    if (v2)
    {
      bzero(v2, v1->size);
      v1->contentxmlParserInputBufferPtr IO = 0;
    }
    else
    {
      __xmlSimpleError(2, 2, 0, 0, (uint64_t)"creating buffer");
      xmlFree(v1);
      return 0;
    }
  }
  else
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"creating buffer");
  }
  return v1;
}

xmlBufferPtr xmlBufferCreateSize(size_t size)
{
  if (size > 0x7FFFFFFE) {
    return 0;
  }
  BOOL v3 = (xmlBuffer *)xmlMalloc(0x20uLL);
  xmlNsPtr v1 = v3;
  if (!v3)
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"creating buffer");
    return v1;
  }
  v3->uint64_t use = 0;
  xmlBufferAllocationScheme v4 = *__xmlBufferAllocScheme();
  if (size) {
    unsigned int v5 = size + 1;
  }
  else {
    unsigned int v5 = 0;
  }
  v1->unsigned int size = v5;
  v1->alloc = v4;
  if (!size)
  {
    v1->content = 0;
    goto LABEL_12;
  }
  int v6 = (xmlChar *)xmlMallocAtomic((size + 1));
  v1->content = v6;
  if (v6)
  {
    bzero(v6, v1->size);
LABEL_12:
    v1->contentxmlParserInputBufferPtr IO = 0;
    return v1;
  }
  __xmlSimpleError(2, 2, 0, 0, (uint64_t)"creating buffer");
  xmlFree(v1);
  return 0;
}

xmlChar *__cdecl xmlBufferDetach(xmlChar *buf)
{
  if (buf)
  {
    xmlNsPtr v1 = buf;
    if (*((_DWORD *)buf + 4) == 2)
    {
      return 0;
    }
    else
    {
      xmlParserInputBufferPtr buf = *(xmlChar **)buf;
      *(void *)xmlNsPtr v1 = 0;
      *((void *)v1 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0;
    }
  }
  return buf;
}

xmlBufferPtr xmlBufferCreateStatic(void *mem, size_t size)
{
  xmlBufferPtr result = 0;
  if (mem)
  {
    unsigned int v4 = size;
    if (size - 0x80000000 >= 0xFFFFFFFF80000001)
    {
      xmlBufferPtr result = (xmlBufferPtr)xmlMalloc(0x20uLL);
      if (result)
      {
        result->uint64_t use = v4;
        result->unsigned int size = v4;
        result->alloc = XML_BUFFER_ALLOC_IMMUTABLE;
        result->content = (xmlChar *)mem;
      }
      else
      {
        __xmlSimpleError(2, 2, 0, 0, (uint64_t)"creating buffer");
        return 0;
      }
    }
  }
  return result;
}

void xmlBufferSetAllocationScheme(xmlBufferPtr buf, xmlBufferAllocationScheme scheme)
{
  if (buf)
  {
    if ((buf->alloc & 0xFFFFFFFE) == 2)
    {
      BOOL v2 = 1;
      BOOL v3 = 0;
    }
    else
    {
      BOOL v2 = scheme >= XML_BUFFER_ALLOC_HYBRID;
      BOOL v3 = scheme == XML_BUFFER_ALLOC_HYBRID;
    }
    if ((v3 || !v2) && scheme != XML_BUFFER_ALLOC_IO) {
      buf->alloc = scheme;
    }
  }
}

void xmlBufferFree(xmlBufferPtr buf)
{
  if (!buf) {
    return;
  }
  xmlBufferAllocationScheme alloc = buf->alloc;
  if (alloc != XML_BUFFER_ALLOC_IO)
  {
    content = buf->content;
    if (alloc == XML_BUFFER_ALLOC_IMMUTABLE || content == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  content = buf->contentIO;
  if (content || (content = buf->content) != 0) {
LABEL_11:
  }
    xmlFree(content);
LABEL_12:
  xmlFreeFunc v5 = xmlFree;

  ((void (*)(xmlBufferPtr))v5)(buf);
}

void xmlBufferEmpty(xmlBufferPtr buf)
{
  if (buf)
  {
    content = buf->content;
    if (buf->content)
    {
      buf->uint64_t use = 0;
      xmlBufferAllocationScheme alloc = buf->alloc;
      if (alloc == XML_BUFFER_ALLOC_IO)
      {
        contentxmlParserInputBufferPtr IO = buf->contentIO;
        if (contentIO)
        {
          buf->size += content - contentIO;
          buf->content = contentIO;
          *contentxmlParserInputBufferPtr IO = 0;
          return;
        }
      }
      else if (alloc == XML_BUFFER_ALLOC_IMMUTABLE)
      {
        buf->content = (xmlChar *)"";
        return;
      }
      xmlChar *content = 0;
    }
  }
}

int xmlBufferShrink(xmlBufferPtr buf, unsigned int len)
{
  if (!buf) {
    return -1;
  }
  unsigned int v2 = len;
  if (len)
  {
    unsigned int use = buf->use;
    size_t v5 = use - len;
    if (use < len) {
      return -1;
    }
    buf->unsigned int use = v5;
    xmlBufferAllocationScheme alloc = buf->alloc;
    if (alloc == XML_BUFFER_ALLOC_IMMUTABLE)
    {
      buf->content += len;
      unsigned int v13 = buf->size - len;
      goto LABEL_13;
    }
    if (alloc != XML_BUFFER_ALLOC_IO || (contentxmlParserInputBufferPtr IO = buf->contentIO) == 0)
    {
      memmove(buf->content, &buf->content[len], v5);
      buf->content[buf->use] = 0;
      return v2;
    }
    long long v9 = &buf->content[len];
    buf->content = v9;
    unint64_t v10 = buf->size - v2;
    buf->unsigned int size = v10;
    int v11 = v9 - contentIO;
    if (v9 - contentIO >= v10)
    {
      memmove(contentIO, v9, v5);
      uint64_t v12 = buf->contentIO;
      buf->content = v12;
      v12[buf->use] = 0;
      unsigned int v13 = buf->size + v11;
LABEL_13:
      buf->unsigned int size = v13;
    }
  }
  return v2;
}

int xmlBufferGrow(xmlBufferPtr buf, unsigned int len)
{
  if (!buf) {
    return -1;
  }
  xmlBufferAllocationScheme alloc = buf->alloc;
  if (alloc == XML_BUFFER_ALLOC_IMMUTABLE) {
    return 0;
  }
  unsigned int use = buf->use;
  unsigned int size = buf->size;
  if (size - use > len)
  {
    int result = 0;
    buf->content[use + len] = 0;
    return result;
  }
  if (2147483646 - use >= len)
  {
    unsigned int v9 = use + len;
    unsigned int v10 = v9 + 100;
    if (v9 > 0x7FFFFF9B) {
      unsigned int v10 = 0x7FFFFFFF;
    }
    if (size >> 30) {
      unsigned int v11 = 0x7FFFFFFF;
    }
    else {
      unsigned int v11 = 2 * size;
    }
    if (size > len) {
      size_t v12 = v11;
    }
    else {
      size_t v12 = v10;
    }
    if (alloc == XML_BUFFER_ALLOC_IO && (contentxmlParserInputBufferPtr IO = buf->contentIO) != 0)
    {
      xmlNodePtr v14 = (xmlChar *)(buf->content - contentIO);
      xmlNodePtr v15 = (xmlChar *)xmlRealloc(contentIO, (size_t)&v14[v12]);
      if (v15)
      {
        buf->contentxmlParserInputBufferPtr IO = v15;
        char v16 = &v14[(void)v15];
LABEL_22:
        buf->content = v16;
        buf->unsigned int size = v12;
        v16[buf->use] = 0;
        buf->content[buf->use + len] = 0;
        return buf->size + ~buf->use;
      }
    }
    else
    {
      char v16 = (xmlChar *)xmlRealloc(buf->content, v12);
      if (v16) {
        goto LABEL_22;
      }
    }
    xmlNodePtr v8 = "growing buffer";
    goto LABEL_24;
  }
  xmlNodePtr v8 = "growing buffer past INT_MAX";
LABEL_24:
  __xmlSimpleError(2, 2, 0, 0, (uint64_t)v8);
  return -1;
}

int xmlBufferDump(FILE *file, xmlBufferPtr buf)
{
  if (buf)
  {
    content = buf->content;
    if (buf->content)
    {
      if (file) {
        unsigned int v4 = file;
      }
      else {
        unsigned int v4 = (FILE *)*MEMORY[0x1E4F143D8];
      }
      content = (const void *)fwrite(content, 1uLL, buf->use, v4);
      if ((unint64_t)content >= 0x7FFFFFFF) {
        LODWORD(contxmlDumpEntityDecl(buf, ent) = 0x7FFFFFFF;
      }
    }
  }
  else
  {
    LODWORD(contxmlDumpEntityDecl(buf, ent) = 0;
  }
  return (int)content;
}

const xmlChar *__cdecl xmlBufferContent(const xmlChar *buf)
{
  if (buf) {
    return *(const xmlChar **)buf;
  }
  return buf;
}

int xmlBufferLength(const xmlBuffer *buf)
{
  if (!buf) {
    return 0;
  }
  unsigned int use = buf->use;
  if (use >= 0x7FFFFFFF)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      xmlBufferLength_cold_1(use);
    }
    return 2147483646;
  }
  return use;
}

int xmlBufferResize(xmlBufferPtr buf, unsigned int size)
{
  if (buf)
  {
    xmlBufferPtr v2 = buf;
    xmlBufferAllocationScheme alloc = buf->alloc;
    if (alloc == XML_BUFFER_ALLOC_IMMUTABLE)
    {
LABEL_39:
      LODWORD(xmlHashScan(table, (xmlHashScanner)xmlDumpEntityDeclScan, buf) = 0;
      return (int)buf;
    }
    unsigned int v4 = buf->size;
    if (v4 <= size)
    {
      if (size >= 0x7FFFFFF6)
      {
        size_t v5 = "growing buffer past INT_MAX";
LABEL_38:
        __xmlSimpleError(2, 2, 0, 0, (uint64_t)v5);
        goto LABEL_39;
      }
      switch(alloc)
      {
        case XML_BUFFER_ALLOC_DOUBLEIT:
        case XML_BUFFER_ALLOC_IO:
          if (v4) {
            unsigned int v6 = buf->size;
          }
          else {
            unsigned int v6 = size + 10;
          }
          while (1)
          {
            if (v6 >= size) {
              goto LABEL_15;
            }
            if (v6 >> 30) {
              goto LABEL_37;
            }
            v6 *= 2;
          }
        case XML_BUFFER_ALLOC_EXACT:
          unsigned int v6 = size + 10;
          goto LABEL_25;
        case XML_BUFFER_ALLOC_HYBRID:
          if (buf->use >= 0x1000)
          {
            unsigned int v6 = buf->size;
            if (v4 < size)
            {
              do
              {
                if (v6 >> 30) {
                  goto LABEL_37;
                }
                v6 *= 2;
              }
              while (v6 < size);
LABEL_15:
              if (alloc == XML_BUFFER_ALLOC_IO)
              {
                contentxmlParserInputBufferPtr IO = buf->contentIO;
                if (contentIO)
                {
                  unint64_t v8 = v2->content - contentIO;
                  if (v8 > v6)
                  {
                    memmove(contentIO, v2->content, v2->use);
                    unsigned int v9 = v2->contentIO;
                    goto LABEL_35;
                  }
                  size_t v12 = (xmlChar *)xmlRealloc(contentIO, v8 + v6);
                  if (v12)
                  {
                    v2->contentxmlParserInputBufferPtr IO = v12;
                    unsigned int v9 = &v12[v8];
                    goto LABEL_35;
                  }
                  goto LABEL_37;
                }
              }
            }
          }
          else
          {
            unsigned int v6 = size;
          }
LABEL_25:
          if (!v2->content)
          {
            unsigned int v10 = (xmlChar *)xmlMallocAtomic(v6);
LABEL_29:
            unsigned int v9 = v10;
            if (!v10) {
              goto LABEL_37;
            }
LABEL_35:
            v2->content = v9;
            v2->unsigned int size = v6;
            v9[v2->use] = 0;
            break;
          }
          if (v4 - v2->use <= 0x63)
          {
            unsigned int v10 = (xmlChar *)xmlRealloc(v2->content, v6);
            goto LABEL_29;
          }
          unsigned int v11 = (xmlChar *)xmlMallocAtomic(v6);
          if (v11)
          {
            unsigned int v9 = v11;
            memcpy(v11, v2->content, v2->use);
            xmlFree(v2->content);
            goto LABEL_35;
          }
LABEL_37:
          size_t v5 = "growing buffer";
          goto LABEL_38;
        default:
          unsigned int v6 = size + 10;
          goto LABEL_15;
      }
    }
    LODWORD(xmlHashScan(table, (xmlHashScanner)xmlDumpEntityDeclScan, buf) = 1;
  }
  return (int)buf;
}

int xmlBufferAdd(xmlBufferPtr buf, const xmlChar *str, int len)
{
  int v3 = -1;
  if (buf)
  {
    if (str)
    {
      unsigned int v5 = len;
      if (len >= -1 && buf->alloc != XML_BUFFER_ALLOC_IMMUTABLE)
      {
        if (!len) {
          return 0;
        }
        if ((len & 0x80000000) == 0 || (unsigned int v5 = xmlStrlen(str), (v5 & 0x80000000) == 0))
        {
          if (v5)
          {
            unsigned int use = buf->use;
            if (v5 >= buf->size - use)
            {
              if (v5 >= (use ^ 0x7FFFFFFF))
              {
                unsigned int v10 = "growing buffer past INT_MAX";
              }
              else
              {
                if (xmlBufferResize(buf, v5 + use + 1))
                {
                  unsigned int use = buf->use;
                  goto LABEL_13;
                }
                unsigned int v10 = "growing buffer";
              }
              int v3 = 2;
              __xmlSimpleError(2, 2, 0, 0, (uint64_t)v10);
              return v3;
            }
LABEL_13:
            memmove(&buf->content[use], str, v5);
            int v3 = 0;
            unsigned int v8 = buf->use + v5;
            buf->unsigned int use = v8;
            buf->content[v8] = 0;
            return v3;
          }
          return 0;
        }
      }
    }
  }
  return v3;
}

int xmlBufferAddHead(xmlBufferPtr buf, const xmlChar *str, int len)
{
  if (!buf) {
    return -1;
  }
  unsigned int v3 = len;
  int v4 = -1;
  if (len >= -1 && str && buf->alloc != XML_BUFFER_ALLOC_IMMUTABLE)
  {
    if (!len) {
      return 0;
    }
    if (len < 0) {
      unsigned int v3 = xmlStrlen(str);
    }
    if ((int)v3 >= 1)
    {
      if (buf->alloc == XML_BUFFER_ALLOC_IO)
      {
        contentxmlParserInputBufferPtr IO = buf->contentIO;
        if (contentIO)
        {
          if ((xmlChar *)(buf->content - contentIO) > (xmlChar *)v3)
          {
            unsigned int v8 = &buf->content[-v3];
            buf->content = v8;
            memmove(v8, str, v3);
            int v4 = 0;
            int32x2_t v9 = vadd_s32(*(int32x2_t *)&buf->use, vdup_n_s32(v3));
            *(int32x2_t *)&buf->unsigned int use = v9;
            buf->content[v9.u32[0]] = 0;
            return v4;
          }
        }
      }
      unsigned int use = buf->use;
      if (v3 >= buf->size - use)
      {
        if (v3 >= (use ^ 0x7FFFFFFF))
        {
          size_t v12 = "growing buffer past INT_MAX";
        }
        else
        {
          if (xmlBufferResize(buf, v3 + use + 1))
          {
            unsigned int use = buf->use;
            goto LABEL_19;
          }
          size_t v12 = "growing buffer";
          int v4 = 2;
        }
        __xmlSimpleError(2, 2, 0, 0, (uint64_t)v12);
        return v4;
      }
LABEL_19:
      memmove(&buf->content[v3], buf->content, use);
      memmove(buf->content, str, v3);
      int v4 = 0;
      unsigned int v11 = buf->use + v3;
      buf->unsigned int use = v11;
      buf->content[v11] = 0;
    }
  }
  return v4;
}

int xmlBufferCat(xmlBufferPtr buf, const xmlChar *str)
{
  if (buf && str && buf->alloc != XML_BUFFER_ALLOC_IMMUTABLE) {
    return xmlBufferAdd(buf, str, -1);
  }
  else {
    return -1;
  }
}

int xmlBufferCCat(xmlBufferPtr buf, const char *str)
{
  if (buf && str && buf->alloc != XML_BUFFER_ALLOC_IMMUTABLE) {
    return xmlBufferAdd(buf, (const xmlChar *)str, -1);
  }
  else {
    return -1;
  }
}

void xmlBufferWriteCHAR(xmlBufferPtr buf, const xmlChar *string)
{
  if (buf && string && buf->alloc != XML_BUFFER_ALLOC_IMMUTABLE) {
    xmlBufferAdd(buf, string, -1);
  }
}

void xmlBufferWriteChar(xmlBufferPtr buf, const char *string)
{
  if (buf && string && buf->alloc != XML_BUFFER_ALLOC_IMMUTABLE) {
    xmlBufferAdd(buf, (const xmlChar *)string, -1);
  }
}

void xmlBufferWriteQuotedString(xmlBufferPtr buf, const xmlChar *string)
{
  if (!buf || buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) {
    return;
  }
  unsigned int v3 = string;
  if (!xmlStrchr(string, 0x22u))
  {
    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) {
      return;
    }
    xmlBufferAdd(buf, (const xmlChar *)"\"", -1);
    xmlBufferAllocationScheme alloc = buf->alloc;
    if (!v3 || alloc == XML_BUFFER_ALLOC_IMMUTABLE) {
      goto LABEL_22;
    }
    int v7 = buf;
    unsigned int v8 = v3;
    int v9 = -1;
    goto LABEL_20;
  }
  int v4 = xmlStrchr(v3, 0x27u);
  xmlBufferAllocationScheme v5 = buf->alloc;
  if (v4)
  {
    if (v5 != XML_BUFFER_ALLOC_IMMUTABLE) {
      xmlBufferAdd(buf, (const xmlChar *)"\"", -1);
    }
LABEL_7:
    for (uint64_t i = 0; v3[i]; ++i)
    {
      if (v3[i] == 34)
      {
        if (i) {
          xmlBufferAdd(buf, v3, i);
        }
        xmlBufferAdd(buf, (const xmlChar *)"&quot;", 6);
        v3 += i + 1;
        goto LABEL_7;
      }
    }
    if (!i) {
      goto LABEL_21;
    }
    int v7 = buf;
    unsigned int v8 = v3;
    int v9 = i;
LABEL_20:
    xmlBufferAdd(v7, v8, v9);
LABEL_21:
    xmlBufferAllocationScheme alloc = buf->alloc;
LABEL_22:
    if (alloc == XML_BUFFER_ALLOC_IMMUTABLE) {
      return;
    }
    unsigned int v11 = "\"";
    goto LABEL_24;
  }
  if (v5 != XML_BUFFER_ALLOC_IMMUTABLE)
  {
    xmlBufferAdd(buf, (const xmlChar *)"'", -1);
    xmlBufferAllocationScheme v12 = buf->alloc;
    if (v3 && v12 != XML_BUFFER_ALLOC_IMMUTABLE)
    {
      xmlBufferAdd(buf, v3, -1);
      xmlBufferAllocationScheme v12 = buf->alloc;
    }
    if (v12 != XML_BUFFER_ALLOC_IMMUTABLE)
    {
      unsigned int v11 = "'";
LABEL_24:
      xmlBufferAdd(buf, (const xmlChar *)v11, -1);
    }
  }
}

int xmlGetDocCompressMode(const xmlDoc *doc)
{
  if (doc) {
    return doc->compression;
  }
  else {
    return -1;
  }
}

void xmlSetDocCompressMode(xmlDocPtr doc, int mode)
{
  if (doc)
  {
    if (mode < 0)
    {
      doc->compressiouint64_t n = 0;
    }
    else if (mode < 0xA)
    {
      doc->compressiouint64_t n = mode;
    }
    else
    {
      doc->compressiouint64_t n = 9;
    }
  }
}

int xmlGetCompressMode(void)
{
  return xmlCompressMode;
}

void xmlSetCompressMode(int mode)
{
  if (mode >= 9) {
    int v1 = 9;
  }
  else {
    int v1 = mode;
  }
  if (mode < 0) {
    int v1 = 0;
  }
  xmlCompressMode = v1;
}

xmlDOMWrapCtxtPtr xmlDOMWrapNewCtxt(void)
{
  int v0 = (xmlDOMWrapCtxt *)xmlMalloc(0x20uLL);
  int v1 = v0;
  if (v0)
  {
    *(_OWORD *)&v0->_private = 0u;
    *(_OWORD *)&v0->namespaceMap = 0u;
  }
  else
  {
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)"allocating DOM-wrapper context");
  }
  return v1;
}

void xmlDOMWrapFreeCtxt(xmlDOMWrapCtxtPtr ctxt)
{
  if (ctxt)
  {
    namespaceMap = ctxt->namespaceMap;
    if (namespaceMap) {
      xmlDOMWrapNsMapFree((uint64_t)namespaceMap);
    }
    xmlFreeFunc v3 = xmlFree;
    ((void (*)(xmlDOMWrapCtxtPtr))v3)(ctxt);
  }
}

uint64_t xmlDOMWrapNsMapFree(uint64_t result)
{
  if (result)
  {
    int v1 = (void **)result;
    xmlBufferPtr v2 = *(void **)(result + 16);
    if (v2)
    {
      do
      {
        xmlFreeFunc v3 = (void *)*v2;
        xmlFree(v2);
        xmlBufferPtr v2 = v3;
      }
      while (v3);
    }
    int v4 = *v1;
    if (*v1)
    {
      do
      {
        xmlBufferAllocationScheme v5 = (void *)*v4;
        xmlFree(v4);
        int v4 = v5;
      }
      while (v5);
    }
    xmlFreeFunc v6 = xmlFree;
    return ((uint64_t (*)(void **))v6)(v1);
  }
  return result;
}

int xmlDOMWrapRemoveNode(xmlDOMWrapCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr node, int options)
{
  uint64_t v17 = 0;
  signed int v18 = 0;
  int v4 = -1;
  if (!doc) {
    return v4;
  }
  xmlNodePtr properties = node;
  if (!node || node->doc != doc) {
    return v4;
  }
  if (!node->parent) {
    return 0;
  }
  xmlElementType type = node->type;
  int v4 = 1;
  if (type > XML_COMMENT_NODE) {
    return v4;
  }
  if (((1 << type) & 0x1B8) != 0)
  {
    xmlUnlinkNode(node);
    return 0;
  }
  if (((1 << type) & 6) == 0) {
    return v4;
  }
  xmlUnlinkNode(node);
  int v4 = 0;
  while (1)
  {
    while (1)
    {
      xmlNodePtr v10 = properties;
      xmlElementType v11 = properties->type;
      if (v11 != XML_ATTRIBUTE_NODE)
      {
        if (v11 != XML_ELEMENT_NODE) {
          goto LABEL_38;
        }
        if (!ctxt)
        {
          for (uint64_t i = properties->nsDef; i; uint64_t i = i->next)
          {
            if (xmlDOMWrapNSNormAddNsMapItem2((void **)&v18, (int *)&v17 + 1, (int *)&v17, (uint64_t)i, (uint64_t)i) == -1)int v4 = -1; {
          }
            }
        }
      }
      xmlNsPtr ns = v10->ns;
      if (!ns) {
        goto LABEL_35;
      }
      if (v18)
      {
        int v14 = v17;
        if ((int)v17 >= 1) {
          break;
        }
      }
LABEL_25:
      if (ctxt)
      {
        xmlNsPtr v16 = 0;
      }
      else
      {
        xmlNsPtr v16 = xmlDOMWrapStoreNs((uint64_t)doc, ns->href, ns->prefix);
        if (v16)
        {
          if (xmlDOMWrapNSNormAddNsMapItem2((void **)&v18, (int *)&v17 + 1, (int *)&v17, (uint64_t)v10->ns, (uint64_t)v16) == -1)int v4 = -1; {
        }
          }
        else
        {
          int v4 = -1;
        }
      }
      v10->xmlNsPtr ns = v16;
LABEL_35:
      if (v10->type != XML_ELEMENT_NODE) {
        goto LABEL_38;
      }
      xmlNodePtr properties = (xmlNodePtr)v10->properties;
      if (!properties) {
        goto LABEL_37;
      }
    }
    xmlNodePtr v15 = v18 + 1;
    while (ns != *(v15 - 1))
    {
      v15 += 2;
      if (!--v14) {
        goto LABEL_25;
      }
    }
    v10->xmlNsPtr ns = *v15;
    if (v10->type != XML_ELEMENT_NODE) {
      break;
    }
LABEL_37:
    xmlNodePtr properties = v10->children;
    if (!properties)
    {
LABEL_38:
      while (1)
      {
        xmlNodePtr properties = v10->next;
        if (properties) {
          break;
        }
        xmlNodePtr v10 = v10->parent;
        if (!v10) {
          goto LABEL_40;
        }
      }
    }
  }
  if (v10) {
    goto LABEL_38;
  }
LABEL_40:
  if (v18) {
    xmlFree(v18);
  }
  return v4;
}

uint64_t xmlDOMWrapNSNormAddNsMapItem2(void **a1, int *a2, int *a3, uint64_t a4, uint64_t a5)
{
  int v9 = *a3;
  int v10 = *a2;
  xmlElementType v11 = *a1;
  if (*a3 >= *a2)
  {
    if (v10) {
      int v13 = 2 * v10;
    }
    else {
      int v13 = 3;
    }
    xmlElementType v11 = xmlRealloc(v11, 16 * v13);
    if (!v11)
    {
      __xmlSimpleError(2, 2, 0, 0, (uint64_t)"realloc ns map item");
      return 0xFFFFFFFFLL;
    }
    *a1 = v11;
    *a2 = v13;
    int v9 = *a3;
  }
  uint64_t v14 = 0;
  *((void *)v11 + 2 * v9) = a4;
  *((void *)*a1 + 2 * v9 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = a5;
  *a3 = v9 + 1;
  return v14;
}

xmlNsPtr xmlDOMWrapStoreNs(uint64_t a1, const xmlChar *a2, const xmlChar *a3)
{
  xmlBufferAllocationScheme v5 = (const xmlChar **)xmlTreeEnsureXMLDecl(a1);
  if (v5)
  {
    while (1)
    {
      xmlFreeFunc v6 = *v5;
      if (!*v5) {
        break;
      }
      xmlBufferAllocationScheme v5 = (const xmlChar **)*v5;
      int v7 = (const xmlChar *)*((void *)v6 + 3);
      if ((v7 == a3 || xmlStrEqual(v7, a3)) && xmlStrEqual(v5[2], a2)) {
        return (xmlNsPtr)v5;
      }
    }
    xmlNsPtr v8 = xmlNewNs(0, a2, a3);
    *xmlBufferAllocationScheme v5 = (const xmlChar *)v8;
    return v8;
  }
  return (xmlNsPtr)v5;
}

int xmlDOMWrapReconcileNamespaces(xmlDOMWrapCtxtPtr ctxt, xmlNodePtr elem, int options)
{
  int v49 = 0;
  int v50 = 0;
  uint64_t v48 = 0;
  if (!elem || !elem->doc) {
    return -1;
  }
  xmlElementType type = elem->type;
  int v5 = -1;
  if (type == XML_ELEMENT_NODE)
  {
    char v6 = options;
    xmlDocPtr doc = elem->doc;
    int v7 = 0;
    uint64_t v8 = 0;
    int v5 = 0;
    nsDef = 0;
    int v9 = -1;
    for (xmlNodePtr i = elem; ; xmlNodePtr i = properties)
    {
      if (type != XML_ATTRIBUTE_NODE)
      {
        if (type != XML_ELEMENT_NODE) {
          goto LABEL_81;
        }
        ++v9;
        if (i->nsDef)
        {
          xmlElementType v11 = 0;
          nsDef = i->nsDef;
          BOOL v12 = 1;
          while (1)
          {
            if (!v7)
            {
              xmlNodePtr parent = elem->parent;
              if (parent
                && (_xmlNode *)parent->doc != parent
                && xmlDOMWrapNSNormGatherInScopeNs(&v50, (uint64_t)parent) == -1)
              {
                int v5 = -1;
              }
              int v7 = 1;
            }
            uint64_t v14 = v50;
            if ((v6 & 1) == 0 || !v50 || (uint64_t v15 = *v50) == 0)
            {
LABEL_30:
              xmlNsPtr ns = i->ns;
              uint64_t v23 = (uint64_t)nsDef;
              if (v12 && ns != 0) {
                BOOL v12 = ns != nsDef;
              }
              if (v14)
              {
                uint64_t v25 = *v14;
                if (*v14)
                {
                  do
                  {
                    if (*(int *)(v25 + 36) >= -1 && *(_DWORD *)(v25 + 32) == -1)
                    {
                      prefix = nsDef->prefix;
                      signed int v27 = *(const xmlChar **)(*(void *)(v25 + 24) + 24);
                      if (prefix == v27 || xmlStrEqual(prefix, v27)) {
                        *(_DWORD *)(v25 + 32) = v9;
                      }
                    }
                    uint64_t v25 = *(void *)v25;
                  }
                  while (v25);
                  uint64_t v23 = (uint64_t)nsDef;
                }
              }
              if (!xmlDOMWrapNsMapAddItem(&v50, -1, v23, v23, v9)) {
                int v5 = -1;
              }
              p_xmlNodePtr next = &nsDef->next;
              xmlElementType v11 = nsDef;
LABEL_47:
              xmlNodePtr next = *p_next;
              goto LABEL_48;
            }
            while (1)
            {
              if (*(int *)(v15 + 36) < -1 || *(_DWORD *)(v15 + 32) != -1) {
                goto LABEL_28;
              }
              uint64_t v16 = (uint64_t)nsDef;
              uint64_t v17 = nsDef->prefix;
              uint64_t v18 = *(void *)(v15 + 24);
              uint64_t v19 = *(const xmlChar **)(v18 + 24);
              if (v17 != v19)
              {
                if (!xmlStrEqual(v17, v19)) {
                  goto LABEL_28;
                }
                uint64_t v16 = (uint64_t)nsDef;
                uint64_t v18 = *(void *)(v15 + 24);
              }
              uint64_t v20 = *(const xmlChar **)(v16 + 16);
              xmlNsPtr v21 = *(const xmlChar **)(v18 + 16);
              if (v20 == v21) {
                goto LABEL_26;
              }
              if (xmlStrEqual(v20, v21)) {
                break;
              }
LABEL_28:
              uint64_t v15 = *(void *)v15;
              if (!v15)
              {
                uint64_t v14 = v50;
                goto LABEL_30;
              }
            }
            uint64_t v16 = (uint64_t)nsDef;
            uint64_t v18 = *(void *)(v15 + 24);
LABEL_26:
            if (xmlDOMWrapNSNormAddNsMapItem2((void **)&v49, (int *)&v48 + 1, (int *)&v48, v16, v18) == -1)
            {
              int v5 = -1;
              goto LABEL_28;
            }
            xmlNodePtr next = nsDef->next;
            if (v11)
            {
              v11->xmlNodePtr next = next;
              p_xmlNodePtr next = &nsDef->next;
              goto LABEL_47;
            }
            i->nsDef = next;
LABEL_48:
            nsDef = next;
            if (!next)
            {
              uint64_t v8 = (uint64_t)i;
              if (!v12) {
                goto LABEL_78;
              }
              goto LABEL_56;
            }
          }
        }
        uint64_t v8 = (uint64_t)i;
      }
LABEL_56:
      if (i->ns)
      {
        if (!v7)
        {
          BOOL v30 = elem->parent;
          if (v30
            && (_xmlNode *)v30->doc != v30
            && xmlDOMWrapNSNormGatherInScopeNs(&v50, (uint64_t)v30) == -1)
          {
            int v5 = -1;
          }
          int v7 = 1;
        }
        if (v49)
        {
          int v31 = v48;
          if ((int)v48 >= 1)
          {
            BOOL v32 = v49 + 1;
            while (i->ns != *(v32 - 1))
            {
              v32 += 2;
              if (!--v31) {
                goto LABEL_70;
              }
            }
            i->xmlNsPtr ns = *v32;
          }
        }
LABEL_70:
        uint64_t v33 = v50;
        if (v50)
        {
          while (1)
          {
            uint64_t v33 = (uint64_t *)*v33;
            if (!v33) {
              break;
            }
            if (*((_DWORD *)v33 + 8) == -1 && i->ns == (xmlNs *)v33[2])
            {
              p_nsDef = (xmlNs **)(v33 + 3);
              goto LABEL_77;
            }
          }
        }
        p_nsDef = &nsDef;
        if (xmlDOMWrapNSNormAcquireNormalizedNs((uint64_t)doc, v8, (uint64_t)i->ns, (uint64_t *)&nsDef, &v50, v9, i->type == XML_ATTRIBUTE_NODE) == -1)int v5 = -1; {
LABEL_77:
        }
        i->xmlNsPtr ns = *p_nsDef;
      }
LABEL_78:
      if (i->type != XML_ELEMENT_NODE) {
        goto LABEL_81;
      }
      xmlNodePtr properties = (xmlNode *)i->properties;
      if (!properties)
      {
LABEL_98:
        xmlNodePtr properties = i->children;
        if (!properties)
        {
LABEL_81:
          while (i != elem)
          {
            xmlElementType v36 = i->type;
            if (v36 == XML_ELEMENT_NODE)
            {
              long long v37 = v50;
              if (v50)
              {
                uint64_t v38 = *v50;
                if (*v50)
                {
                  uint64_t v40 = v50 + 1;
                  uint64_t v39 = v50[1];
                  if (!v39) {
                    goto LABEL_111;
                  }
                  do
                  {
                    if (*(_DWORD *)(v39 + 36) < v9) {
                      break;
                    }
                    int v41 = *(uint64_t **)(v39 + 8);
                    *uint64_t v40 = (uint64_t)v41;
                    if (v41) {
                      long long v37 = v41;
                    }
                    *long long v37 = 0;
                    *(void *)uint64_t v39 = v50[2];
                    long long v37 = v50;
                    v50[2] = v39;
                    uint64_t v40 = v37 + 1;
                    uint64_t v39 = v37[1];
                  }
                  while (v39);
                  uint64_t v38 = *v37;
                  if (*v37)
                  {
LABEL_111:
                    do
                    {
                      if (*(_DWORD *)(v38 + 32) >= v9) {
                        *(_DWORD *)(v38 + 32) = -1;
                      }
                      uint64_t v38 = *(void *)v38;
                    }
                    while (v38);
                  }
                }
              }
              --v9;
            }
            xmlNodePtr properties = i->next;
            if (properties) {
              goto LABEL_80;
            }
            xmlNodePtr i = i->parent;
            if (v36 == XML_ATTRIBUTE_NODE && i->type == XML_ELEMENT_NODE) {
              goto LABEL_98;
            }
          }
          int v43 = v49;
          if (v49)
          {
            int v44 = v48;
            if ((int)v48 >= 1)
            {
              int v45 = v49;
              do
              {
                uint64_t v46 = *v45;
                v45 += 2;
                xmlFreeNs(v46);
                --v44;
              }
              while (v44);
            }
            xmlFree(v43);
          }
          if (v50) {
            xmlDOMWrapNsMapFree((uint64_t)v50);
          }
          return v5;
        }
      }
LABEL_80:
      xmlElementType type = properties->type;
    }
  }
  return v5;
}

uint64_t xmlDOMWrapNSNormGatherInScopeNs(uint64_t **a1, uint64_t a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = a2;
  uint64_t v3 = 0xFFFFFFFFLL;
  if (a2 && !*a1 && *(_DWORD *)(a2 + 8) != 18)
  {
    while (1)
    {
      if (v2 == *(void *)(v2 + 64)) {
        return 0;
      }
      if (*(_DWORD *)(v2 + 8) == 1)
      {
        int v5 = *(void **)(v2 + 96);
        if (v5) {
          break;
        }
      }
LABEL_19:
      uint64_t v3 = 0;
      uint64_t v2 = *(void *)(v2 + 40);
      if (!v2) {
        return v3;
      }
    }
    while (1)
    {
      char v6 = *a1;
      if (*a1 && (int v7 = (void *)*v6) != 0)
      {
        while (1)
        {
          uint64_t v8 = (const xmlChar *)v5[3];
          int v9 = *(const xmlChar **)(v7[3] + 24);
          if (v8 == v9 || xmlStrEqual(v8, v9)) {
            break;
          }
          int v7 = (void *)*v7;
          if (!v7) {
            goto LABEL_13;
          }
        }
        char v10 = 0;
      }
      else
      {
LABEL_13:
        char v10 = 1;
      }
      uint64_t v3 = 0xFFFFFFFFLL;
      xmlElementType v11 = xmlDOMWrapNsMapAddItem(a1, 0, 0, (uint64_t)v5, -1);
      if (!v11) {
        break;
      }
      if ((v10 & 1) == 0) {
        *((_DWORD *)v11 + 8) = 0;
      }
      int v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_19;
      }
    }
  }
  return v3;
}

void *xmlDOMWrapNsMapAddItem(uint64_t **a1, int a2, uint64_t a3, uint64_t a4, int a5)
{
  int result = 0;
  if (!a1 || (a2 - 1) < 0xFFFFFFFE) {
    return result;
  }
  xmlElementType v11 = *a1;
  if (!*a1)
  {
    BOOL v12 = (uint64_t *)xmlMalloc(0x18uLL);
    if (!v12)
    {
      uint64_t v15 = "allocating namespace map";
      goto LABEL_17;
    }
    xmlElementType v11 = v12;
    uint64_t *v12 = 0;
    v12[1] = 0;
    v12[2] = 0;
    *a1 = v12;
  }
  int result = (void *)v11[2];
  if (!result)
  {
    int result = xmlMalloc(0x28uLL);
    if (result) {
      goto LABEL_9;
    }
    uint64_t v15 = "allocating namespace map item";
LABEL_17:
    __xmlSimpleError(2, 2, 0, 0, (uint64_t)v15);
    return 0;
  }
  v11[2] = *result;
LABEL_9:
  result[4] = 0;
  *(_OWORD *)int result = 0u;
  *((_OWORD *)result + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0u;
  uint64_t v13 = *v11;
  if (*v11)
  {
    if (a2 == -1)
    {
      uint64_t v14 = (void *)v11[1];
      ++v11;
      result[1] = v14;
      *uint64_t v14 = result;
    }
    else
    {
      *(void *)(v13 + 8) = result;
      void *result = v13;
    }
  }
  else
  {
    *v11++ = (uint64_t)result;
  }
  uint64_t *v11 = (uint64_t)result;
  result[2] = a3;
  result[3] = a4;
  *((_DWORD *)result + 8) = -1;
  *((_DWORD *)result + 9) = a5;
  return result;
}

uint64_t xmlDOMWrapNSNormAcquireNormalizedNs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t **a5, int a6, int a7)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a3 && a4 && a5)
  {
    *a4 = 0;
    uint64_t v15 = *(unsigned char **)(a3 + 24);
    if (v15 && *v15 == 120 && v15[1] == 109 && v15[2] == 108 && !v15[3])
    {
      long long v35 = xmlTreeEnsureXMLDecl(a1);
      *a4 = (uint64_t)v35;
      if (v35) {
        return 0;
      }
      else {
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      uint64_t v16 = *a5;
      if (*a5 && (uint64_t v17 = *v16) != 0)
      {
        while (1)
        {
          if (*(int *)(v17 + 36) >= -1 && *(_DWORD *)(v17 + 32) == -1)
          {
            uint64_t v18 = *(void *)(v17 + 24);
            uint64_t v19 = *(const xmlChar **)(v18 + 16);
            if (v19)
            {
              if (*v19 && (!a7 || *(void *)(v18 + 24)))
              {
                uint64_t v20 = *(const xmlChar **)(a3 + 16);
                if (v19 == v20) {
                  goto LABEL_22;
                }
                if (xmlStrEqual(v19, v20)) {
                  break;
                }
              }
            }
          }
          uint64_t v17 = *(void *)v17;
          if (!v17) {
            goto LABEL_23;
          }
        }
        uint64_t v18 = *(void *)(v17 + 24);
LABEL_22:
        uint64_t result = 0;
        *(void *)(v17 + 16) = a3;
        *a4 = v18;
      }
      else
      {
LABEL_23:
        xmlNsPtr v21 = *(xmlChar **)(a3 + 16);
        xmlNsPtr v22 = *(xmlChar **)(a3 + 24);
        if (a2)
        {
          xmlNsPtr v23 = xmlDOMWrapNSNormDeclareNsForced(a2, v21, v22, 0);
          if (v23)
          {
            uint64_t v24 = (uint64_t)v23;
            uint64_t v25 = *a5;
            if (*a5)
            {
              uint64_t v26 = *v25;
              if (*v25)
              {
                while (1)
                {
                  if (*(_DWORD *)(v26 + 36) < a6 && *(_DWORD *)(v26 + 32) == -1)
                  {
                    signed int v27 = *(const xmlChar **)(a3 + 24);
                    uint64_t v28 = *(const xmlChar **)(*(void *)(v26 + 24) + 24);
                    if (v27 == v28 || xmlStrEqual(v27, v28)) {
                      break;
                    }
                  }
                  uint64_t v26 = *(void *)v26;
                  if (!v26) {
                    goto LABEL_42;
                  }
                }
                *(_DWORD *)(v26 + 32) = a6;
              }
            }
LABEL_42:
            if (xmlDOMWrapNsMapAddItem(a5, -1, a3, v24, a6))
            {
              uint64_t result = 0;
              *a4 = v24;
              return result;
            }
            uint64_t v33 = *(void **)(v24 + 16);
            if (v33) {
              xmlFree(v33);
            }
            long long v34 = *(void **)(v24 + 24);
            if (v34) {
              xmlFree(v34);
            }
            ((void (*)(uint64_t))xmlFree)(v24);
          }
        }
        else
        {
          xmlNsPtr v29 = xmlDOMWrapStoreNs(a1, v21, v22);
          if (v29)
          {
            xmlNsPtr v30 = v29;
            if (xmlDOMWrapNsMapAddItem(a5, -1, a3, (uint64_t)v29, -3))
            {
              uint64_t result = 0;
              *a4 = (uint64_t)v30;
              return result;
            }
            href = (xmlChar *)v30->href;
            if (href) {
              xmlFree(href);
            }
            prefix = (xmlChar *)v30->prefix;
            if (prefix) {
              xmlFree(prefix);
            }
            ((void (*)(xmlNsPtr))xmlFree)(v30);
          }
        }
        return 0xFFFFFFFFLL;
      }
    }
  }
  return result;
}

int xmlDOMWrapCloneNode(xmlDOMWrapCtxtPtr ctxt, xmlDocPtr sourceDoc, xmlNodePtr node, xmlNodePtr *clonedNode, xmlDocPtr destDoc, xmlNodePtr destParent, int deep, int options)
{
  namespaceMap = 0;
  int v8 = -1;
  if (node && clonedNode && destDoc && (!destParent || destParent->doc == destDoc))
  {
    if (node->type != XML_ELEMENT_NODE) {
      return 1;
    }
    p_xmlDocPtr doc = &node->doc;
    xmlDocPtr doc = node->doc;
    if (!doc || doc == sourceDoc || !sourceDoc)
    {
      xmlDocPtr v15 = sourceDoc ? sourceDoc : node->doc;
      if ((unint64_t)sourceDoc | (unint64_t)doc)
      {
        if (ctxt) {
          namespaceMap = (uint64_t *)ctxt->namespaceMap;
        }
        uint64_t v16 = destDoc->dict;
        nsDef = 0;
        *clonedNode = 0;
        if (*p_doc != v15)
        {
          uint64_t v78 = 0;
          goto LABEL_158;
        }
        xmlNodePtr v71 = 0;
        dict = v16;
        uint64_t v18 = 0;
        uint64_t v19 = 0;
        uint64_t v20 = 0;
        int v21 = 0;
        int v22 = -1;
        xmlNodePtr v23 = node;
        long long v74 = v15;
        while (1)
        {
          int v76 = v19;
          xmlElementType type = v23->type;
          BOOL v25 = type - 3 < 6 || type == XML_DOCUMENT_FRAG_NODE;
          int v75 = v21;
          if (!v25)
          {
            if (type == XML_ATTRIBUTE_NODE)
            {
              uint64_t v28 = xmlMalloc(0x60uLL);
              if (!v28)
              {
                uint64_t v78 = v20;
                uint64_t v70 = "xmlDOMWrapCloneNode(): allocating an attr-node";
                goto LABEL_168;
              }
              uint64_t v19 = v28;
              v28[4] = 0u;
              v28[5] = 0u;
              v28[2] = 0u;
              v28[3] = 0u;
              *uint64_t v28 = 0u;
              v28[1] = 0u;
              if (!v20)
              {
LABEL_38:
                uint64_t v20 = (xmlNode *)v19;
                signed int v27 = v76;
                goto LABEL_39;
              }
              signed int v27 = v76;
              v19[5] = v76;
              if (!v18)
              {
                v76[11] = v19;
                goto LABEL_39;
              }
              goto LABEL_29;
            }
            if (type != XML_ELEMENT_NODE)
            {
              uint64_t v78 = v20;
LABEL_169:
              int v8 = -1;
LABEL_158:
              uint64_t v66 = namespaceMap;
              if (!namespaceMap) {
                goto LABEL_162;
              }
              xmlDOMWrapCtxtPtr v67 = ctxt;
              if (ctxt) {
                goto LABEL_160;
              }
              goto LABEL_161;
            }
          }
          uint64_t v26 = xmlMalloc(0x78uLL);
          if (!v26)
          {
            uint64_t v78 = v20;
            uint64_t v70 = "xmlDOMWrapCloneNode(): allocating a node";
LABEL_168:
            __xmlSimpleError(2, 2, 0, 0, (uint64_t)v70);
            goto LABEL_169;
          }
          uint64_t v19 = v26;
          v26[14] = 0;
          *((_OWORD *)v26 + 5) = 0u;
          *((_OWORD *)v26 + 6) = 0u;
          *((_OWORD *)v26 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = 0u;
          *((_OWORD *)v26 + xmlSAX2Text((uint64_t)ctx, (char *)value, len, 4) = 0u;
          *((_OWORD *)v26 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0, 1) = 0u;
          *((_OWORD *)v26 + 2) = 0u;
          *(_OWORD *)uint64_t v26 = 0u;
          if (!v20) {
            goto LABEL_38;
          }
          signed int v27 = v76;
          v19[5] = v76;
          if (!v18)
          {
            v76[3] = v19;
            goto LABEL_39;
          }
LABEL_29:
          v18[6] = v19;
          v19[7] = v18;
LABEL_39:
          *((_DWORD *)v19 + 2) = v23->type;
          v19[8] = destDoc;
          name = v23->name;
          xmlNsPtr v30 = "text";
          if (name == "text" || (xmlNsPtr v30 = "textnoenc", name == "textnoenc") || (xmlNsPtr v30 = "comment", name == "comment"))
          {
            BOOL v32 = v30;
LABEL_47:
            v19[2] = v32;
            goto LABEL_48;
          }
          if (name)
          {
            if (dict)
            {
              int v31 = xmlDictOwns(dict, name);
              BOOL v32 = v23->name;
              if (!v31)
              {
                uint64_t v33 = xmlDictLookup(dict, v32, -1);
                goto LABEL_70;
              }
            }
            else
            {
              uint64_t v33 = xmlStrdup(name);
LABEL_70:
              BOOL v32 = v33;
            }
            signed int v27 = v76;
            goto LABEL_47;
          }
LABEL_48:
          uint64_t v78 = v20;
          int v8 = -1;
          switch(v23->type)
          {
            case XML_ELEMENT_NODE:
              ++v22;
              if (!v23->nsDef) {
                goto LABEL_92;
              }
              if (!destParent || v75 || ctxt)
              {
                nsDef = (uint64_t *)v23->nsDef;
LABEL_74:
                int v75 = 1;
                uint64_t v39 = v19 + 12;
                while (1)
                {
                  uint64_t v40 = xmlMalloc(0x30uLL);
                  if (!v40) {
                    break;
                  }
                  uint64_t v41 = (uint64_t)v40;
                  v40[1] = 0u;
                  v40[2] = 0u;
                  *uint64_t v40 = 0u;
                  *((_DWORD *)v40 + 2) = 18;
                  uint64_t v42 = nsDef;
                  int v43 = (const xmlChar *)nsDef[2];
                  if (v43)
                  {
                    *(void *)(v41 + 16) = xmlStrdup(v43);
                    uint64_t v42 = nsDef;
                  }
                  int v44 = (const xmlChar *)v42[3];
                  if (v44) {
                    *(void *)(v41 + 2xmlSAX2Text((uint64_t)ctx, (char *)value, len, 4) = xmlStrdup(v44);
                  }
                  *uint64_t v39 = v41;
                  if (!ctxt || !ctxt->getNsForNodeFunc)
                  {
                    if (namespaceMap)
                    {
                      for (uint64_t i = *namespaceMap; i; uint64_t i = *(void *)i)
                      {
                        if (*(int *)(i + 36) >= -1 && *(_DWORD *)(i + 32) == -1)
                        {
                          uint64_t v46 = (const xmlChar *)nsDef[3];
                          uint64_t v47 = *(const xmlChar **)(*(void *)(i + 24) + 24);
                          if (v46 == v47 || xmlStrEqual(v46, v47)) {
                            *(_DWORD *)(i + 32) = v22;
                          }
                        }
                      }
                    }
                    int v8 = -1;
                    if (!xmlDOMWrapNsMapAddItem(&namespaceMap, -1, (uint64_t)nsDef, v41, v22)) {
                      goto LABEL_158;
                    }
                  }
                  nsDef = (uint64_t *)*nsDef;
                  uint64_t v39 = (void *)v41;
                  if (!nsDef) {
                    goto LABEL_92;
                  }
                }
                __xmlSimpleError(2, 2, 0, 0, (uint64_t)"xmlDOMWrapCloneNode(): allocating namespace");
                return -1;
              }
              if (xmlDOMWrapNSNormGatherInScopeNs(&namespaceMap, (uint64_t)destParent) == -1) {
                goto LABEL_158;
              }
              nsDef = (uint64_t *)v23->nsDef;
              if (nsDef) {
                goto LABEL_74;
              }
              int v75 = 1;
LABEL_92:
              xmlNodePtr v71 = v23;
LABEL_93:
              if (v23->ns)
              {
                int v48 = 1;
                if (destParent && !v75 && !ctxt)
                {
                  if (xmlDOMWrapNSNormGatherInScopeNs(&namespaceMap, (uint64_t)destParent) == -1) {
                    goto LABEL_169;
                  }
                  int v48 = 1;
                }
                int v49 = namespaceMap;
                if (namespaceMap)
                {
                  do
                  {
                    int v49 = (uint64_t *)*v49;
                    if (!v49) {
                      goto LABEL_104;
                    }
                  }
                  while (*((_DWORD *)v49 + 8) != -1 || v23->ns != (xmlNs *)v49[2]);
                  p_nsDef = (uint64_t **)(v49 + 3);
                }
                else
                {
LABEL_104:
                  if (ctxt)
                  {
                    getNsForNodeFunc = (uint64_t (*)(void))ctxt->getNsForNodeFunc;
                    uint64_t ns = (uint64_t)v23->ns;
                    if (getNsForNodeFunc)
                    {
                      nsDef = (uint64_t *)getNsForNodeFunc();
                      if (!xmlDOMWrapNsMapAddItem(&namespaceMap, -1, (uint64_t)v23->ns, (uint64_t)nsDef, -4))
                      {
                        uint64_t v66 = namespaceMap;
                        int v8 = -1;
                        xmlDOMWrapCtxtPtr v67 = ctxt;
                        if (!namespaceMap) {
                          goto LABEL_162;
                        }
LABEL_160:
                        if (v67->namespaceMap == v66)
                        {
                          uint64_t v68 = *v66;
                          if (*v66)
                          {
                            uint64_t v69 = v66[2];
                            if (v69)
                            {
                              *(void *)v66[1] = v69;
                              uint64_t v66 = namespaceMap;
                              uint64_t v68 = *namespaceMap;
                            }
                            v66[2] = v68;
                            uint64_t *v66 = 0;
                          }
                          goto LABEL_162;
                        }
LABEL_161:
                        xmlDOMWrapNsMapFree((uint64_t)v66);
LABEL_162:
                        *clonedNode = v78;
                        return v8;
                      }
                      p_nsDef = &nsDef;
                      goto LABEL_114;
                    }
                  }
                  else
                  {
                    uint64_t ns = (uint64_t)v23->ns;
                  }
                  if (destParent) {
                    uint64_t v53 = (uint64_t)v71;
                  }
                  else {
                    uint64_t v53 = 0;
                  }
                  p_nsDef = &nsDef;
                  if (xmlDOMWrapNSNormAcquireNormalizedNs((uint64_t)destDoc, v53, ns, (uint64_t *)&nsDef, &namespaceMap, v22, v23->type == XML_ATTRIBUTE_NODE) == -1)goto LABEL_169; {
                }
                  }
LABEL_114:
                v19[9] = *p_nsDef;
                goto LABEL_115;
              }
              int v48 = v75;
LABEL_115:
              if (*((_DWORD *)v19 + 2) == 2)
              {
                uint64_t v54 = (xmlNode *)v19[5];
                if (v54)
                {
                  if (xmlIsID(destDoc, v54, (xmlAttrPtr)v19))
                  {
                    uint64_t StringInternal = xmlNodeListGetStringInternal(*p_doc, (uint64_t)v23->children, 1, 0);
                    if (StringInternal)
                    {
                      xmlSchematronParserCtxtPtr v56 = StringInternal;
                      xmlIDPtr v57 = xmlAddID(0, destDoc, StringInternal, (xmlAttrPtr)v23);
                      xmlFree(v56);
                      if (!v57) {
                        goto LABEL_169;
                      }
                    }
                  }
                }
              }
              if (v23->type == XML_ELEMENT_NODE)
              {
                xmlNodePtr properties = (xmlNode *)v23->properties;
                signed int v27 = v76;
                if (!properties) {
                  goto LABEL_124;
                }
LABEL_127:
                uint64_t v18 = 0;
                goto LABEL_154;
              }
              signed int v27 = v76;
LABEL_124:
              xmlNodePtr properties = v23->children;
              if (properties && (deep || v23->type == XML_ATTRIBUTE_NODE)) {
                goto LABEL_127;
              }
              int v75 = v48;
LABEL_129:
              if (v23 == node)
              {
LABEL_157:
                int v8 = 0;
                goto LABEL_158;
              }
              uint64_t v18 = v19;
              while (1)
              {
                unsigned int v59 = v23->type;
                if (v59 <= 0x14 && ((1 << v59) & 0x180002) != 0)
                {
                  long long v61 = namespaceMap;
                  if (namespaceMap)
                  {
                    uint64_t v62 = *namespaceMap;
                    if (*namespaceMap)
                    {
                      int v64 = namespaceMap + 1;
                      uint64_t v63 = namespaceMap[1];
                      if (!v63) {
                        goto LABEL_176;
                      }
                      do
                      {
                        if (*(_DWORD *)(v63 + 36) < v22) {
                          break;
                        }
                        uint64_t v65 = *(uint64_t **)(v63 + 8);
                        *int v64 = (uint64_t)v65;
                        if (v65) {
                          long long v61 = v65;
                        }
                        uint64_t *v61 = 0;
                        *(void *)uint64_t v63 = namespaceMap[2];
                        long long v61 = namespaceMap;
                        namespaceMap[2] = v63;
                        int v64 = v61 + 1;
                        uint64_t v63 = v61[1];
                      }
                      while (v63);
                      uint64_t v62 = *v61;
                      if (*v61)
                      {
LABEL_176:
                        do
                        {
                          if (*(_DWORD *)(v62 + 32) >= v22) {
                            *(_DWORD *)(v62 + 32) = -1;
                          }
                          uint64_t v62 = *(void *)v62;
                        }
                        while (v62);
                      }
                    }
                  }
                  --v22;
                }
                xmlNodePtr properties = v23->next;
                if (properties) {
                  break;
                }
                uint64_t v19 = (void *)v18[5];
                if (v59 == 2)
                {
                  signed int v27 = (void *)v19[5];
                  xmlNodePtr v23 = v23->parent;
                  int v48 = v75;
                  goto LABEL_124;
                }
                if (v19)
                {
                  v19[4] = v18;
                  signed int v27 = (void *)v19[5];
                }
                xmlNodePtr v23 = v23->parent;
                uint64_t v18 = v19;
                if (v23 == node) {
                  goto LABEL_157;
                }
              }
              int v48 = v75;
              uint64_t v19 = v27;
LABEL_154:
              p_xmlDocPtr doc = &properties->doc;
              int v21 = v48;
              xmlNodePtr v23 = properties;
              uint64_t v20 = v78;
              if (properties->doc != v74) {
                goto LABEL_169;
              }
              break;
            case XML_ATTRIBUTE_NODE:
              goto LABEL_93;
            case XML_TEXT_NODE:
            case XML_CDATA_SECTION_NODE:
            case XML_PI_NODE:
            case XML_COMMENT_NODE:
              content = v23->content;
              if (!content) {
                goto LABEL_129;
              }
              if (dict)
              {
                int v35 = xmlDictOwns(dict, content);
                xmlElementType v36 = v23->content;
                if (v35)
                {
                  v19[10] = v36;
                  goto LABEL_68;
                }
                uint64_t v38 = (void *)xmlDictLookup(dict, v36, -1);
              }
              else
              {
                uint64_t v38 = xmlStrdup(content);
              }
              v19[10] = v38;
              goto LABEL_68;
            case XML_ENTITY_REF_NODE:
              if (v74 == destDoc)
              {
                v19[10] = v23->content;
                *(_OWORD *)(v19 + xmlSAX2Text((uint64_t)ctx, (char *)ch, len, 3) = *(_OWORD *)&v23->children;
              }
              else if (destDoc->intSubset || destDoc->extSubset)
              {
                xmlEntityPtr DocEntity = xmlGetDocEntity(destDoc, v23->name);
                if (DocEntity)
                {
                  v19[10] = DocEntity->content;
                  v19[3] = DocEntity;
                  v19[4] = DocEntity;
                }
LABEL_68:
                signed int v27 = v76;
              }
              goto LABEL_129;
            case XML_ENTITY_NODE:
              goto LABEL_129;
            case XML_XINCLUDE_START:
            case XML_XINCLUDE_END:
              return v8;
            default:
              goto LABEL_158;
          }
        }
      }
    }
  }
  return v8;
}

int xmlDOMWrapAdoptNode(xmlDOMWrapCtxtPtr ctxt, xmlDocPtr sourceDoc, xmlNodePtr node, xmlDocPtr destDoc, xmlNodePtr destParent, int options)
{
  if (!node)
  {
    LODWORD(ctxt) = -1;
    return (int)ctxt;
  }
  xmlDOMWrapCtxtPtr v7 = ctxt;
  LODWORD(ctxt) = -1;
  if (!destDoc) {
    return (int)ctxt;
  }
  xmlElementType type = node->type;
  if (type == XML_NAMESPACE_DECL || destParent && destParent->doc != destDoc) {
    return (int)ctxt;
  }
  xmlDocPtr doc = node->doc;
  if (doc)
  {
    if (doc != sourceDoc && sourceDoc) {
      return (int)ctxt;
    }
  }
  xmlDocPtr v12 = sourceDoc ? sourceDoc : node->doc;
  if (v12 == destDoc) {
    return (int)ctxt;
  }
  if (type > XML_DOCUMENT_FRAG_NODE)
  {
LABEL_32:
    LODWORD(ctxt) = 1;
    return (int)ctxt;
  }
  if (((1 << type) & 0x1BE) == 0)
  {
    if (type == XML_DOCUMENT_FRAG_NODE)
    {
      LODWORD(ctxt) = 2;
      return (int)ctxt;
    }
    goto LABEL_32;
  }
  xmlNodePtr parent = node->parent;
  if (parent && parent != destParent)
  {
    xmlUnlinkNode(node);
    xmlElementType type = node->type;
  }
  if (type == XML_ATTRIBUTE_NODE)
  {
    LODWORD(ctxt) = xmlDOMWrapAdoptAttr((uint64_t)v12, (uint64_t)node, destDoc, (uint64_t)destParent);
  }
  else
  {
    if (type == XML_ELEMENT_NODE)
    {
      LODWORD(ctxt) = xmlDOMWrapAdoptBranch((uint64_t)v7, v12, (uint64_t)node, destDoc, (uint64_t)destParent);
      return (int)ctxt;
    }
    node->xmlDocPtr doc = destDoc;
    if (v12) {
      BOOL v14 = v12->dict == destDoc->dict;
    }
    else {
      BOOL v14 = 0;
    }
    if (type - 3 < 2)
    {
      if (v14) {
        goto LABEL_70;
      }
      goto LABEL_45;
    }
    if (type != XML_ENTITY_REF_NODE)
    {
      if (type != XML_PI_NODE || v14) {
        goto LABEL_70;
      }
      name = (xmlChar *)node->name;
      if (name)
      {
        dict = destDoc->dict;
        if (dict)
        {
          node->name = xmlDictLookup(dict, node->name, -1);
          if (!v12 || (uint64_t v17 = v12->dict) == 0 || !xmlDictOwns(v17, name)) {
            xmlFree(name);
          }
          goto LABEL_45;
        }
        if (v12)
        {
          uint64_t v24 = v12->dict;
          if (v24 && xmlDictOwns(v24, node->name)) {
            node->name = xmlStrdup(node->name);
          }
          goto LABEL_45;
        }
        goto LABEL_70;
      }
LABEL_45:
      LODWORD(ctxt) = 0;
      if (v12)
      {
        content = node->content;
        if (content)
        {
          ctxt = (xmlDOMWrapCtxtPtr)v12->dict;
          if (ctxt)
          {
            LODWORD(ctxt) = xmlDictOwns((xmlDictPtr)ctxt, content);
            if (ctxt)
            {
              uint64_t v19 = destDoc->dict;
              if (v19) {
                ctxt = (xmlDOMWrapCtxtPtr)xmlDictLookup(v19, node->content, -1);
              }
              else {
                ctxt = (xmlDOMWrapCtxtPtr)xmlStrdup(node->content);
              }
              uint64_t v26 = (xmlChar *)ctxt;
              LODWORD(ctxt) = 0;
              node->content = v26;
            }
          }
        }
      }
      return (int)ctxt;
    }
    node->content = 0;
    node->xmlNodePtr children = 0;
    node->xmlNodePtr last = 0;
    if (destDoc->intSubset || destDoc->extSubset)
    {
      xmlEntityPtr DocEntity = (_xmlNode *)xmlGetDocEntity(destDoc, node->name);
      if (DocEntity)
      {
        node->content = DocEntity->content;
        node->xmlNodePtr children = DocEntity;
        node->xmlNodePtr last = DocEntity;
      }
    }
    if (v14) {
      goto LABEL_70;
    }
    int v21 = (xmlChar *)node->name;
    if (!v21) {
      goto LABEL_70;
    }
    int v22 = destDoc->dict;
    if (v22)
    {
      node->name = xmlDictLookup(v22, node->name, -1);
      if (!v12 || (xmlNodePtr v23 = v12->dict) == 0 || !xmlDictOwns(v23, v21)) {
        xmlFree(v21);
      }
      goto LABEL_70;
    }
    if (!v12)
    {
LABEL_70:
      LODWORD(ctxt) = 0;
      return (int)ctxt;
    }
    ctxt = (xmlDOMWrapCtxtPtr)v12->dict;
    if (ctxt)
    {
      LODWORD(ctxt) = xmlDictOwns((xmlDictPtr)ctxt, node->name);
      if (ctxt)
      {
        BOOL v25 = xmlStrdup(node->name);
        LODWORD(ctxt) = 0;
        node->name = v25;
      }
    }
  }
  return (int)ctxt;
}

uint64_t xmlDOMWrapAdoptBranch(uint64_t a1, xmlDocPtr doc, uint64_t a3, const xmlDoc *a4, uint64_t a5)
{
  int v5 = a4;
  xmlDocPtr v7 = doc;
  uint64_t v8 = a1;
  int v106 = 0;
  uint64_t v107 = 0;
  unint64_t v9 = doc && doc->dict == a4->dict;
  if (!a1)
  {
    if (a5) {
      goto LABEL_10;
    }
LABEL_11:
    int v94 = 1;
    goto LABEL_12;
  }
  uint64_t v107 = *(uint64_t **)(a1 + 16);
  if (!a5) {
    goto LABEL_11;
  }
  if (!*(void *)(a1 + 24))
  {
LABEL_10:
    int v94 = 0;
    int v105 = 0;
    goto LABEL_13;
  }
  int v94 = 0;
LABEL_12:
  int v105 = 1;
LABEL_13:
  uint64_t v10 = 0;
  uint64_t v104 = 0;
  uint64_t v11 = a3;
  int v12 = -1;
LABEL_14:
  while (2)
  {
    if (*(xmlDocPtr *)(v11 + 64) == v7)
    {
      int v16 = *(_DWORD *)(v11 + 8);
      uint64_t v15 = v11;
    }
    else
    {
      uint64_t v13 = *(void *)(v11 + 48);
      if (!v13)
      {
        uint64_t v19 = v10;
        uint64_t v15 = v11;
        goto LABEL_119;
      }
      uint64_t v14 = *(void *)(a3 + 64);
      do
      {
        uint64_t v15 = v13;
        int v16 = *(_DWORD *)(v13 + 8);
        uint64_t v17 = *(void *)(v13 + 64);
        if (v16 == 20 || v17 == v14) {
          break;
        }
        uint64_t v13 = *(void *)(v13 + 48);
      }
      while (v13);
      if (v17 != v14)
      {
LABEL_23:
        uint64_t v19 = v10;
        goto LABEL_119;
      }
    }
    *(void *)(v15 + 6xmlSAX2Text((uint64_t)ctx, (char *)value, len, 4) = v5;
    uint64_t v19 = 0xFFFFFFFFLL;
    switch(v16)
    {
      case 1:
        uint64_t v25 = v8;
        uint64_t v83 = v5;
        uint64_t v88 = v7;
        ++v12;
        uint64_t v26 = *(void **)(v15 + 96);
        if (!v26) {
          goto LABEL_77;
        }
        if (v8 && *(void *)(v8 + 24))
        {
          uint64_t v104 = v15;
          goto LABEL_78;
        }
        if (v105)
        {
          int v106 = *(void **)(v15 + 96);
          do
          {
LABEL_64:
            if (v107)
            {
              uint64_t v41 = *v107;
              if (*v107)
              {
                do
                {
                  if (*(int *)(v41 + 36) >= -1 && *(_DWORD *)(v41 + 32) == -1)
                  {
                    uint64_t v42 = (const xmlChar *)v106[3];
                    int v43 = *(const xmlChar **)(*(void *)(v41 + 24) + 24);
                    if (v42 == v43 || xmlStrEqual(v42, v43)) {
                      *(_DWORD *)(v41 + 32) = v12;
                    }
                  }
                  uint64_t v41 = *(void *)v41;
                }
                while (v41);
                uint64_t v26 = v106;
              }
            }
            if (xmlDOMWrapNsMapAddItem(&v107, -1, (uint64_t)v26, (uint64_t)v26, v12)) {
              uint64_t v10 = v10;
            }
            else {
              uint64_t v10 = 0xFFFFFFFFLL;
            }
            uint64_t v26 = (void *)*v106;
            int v106 = v26;
          }
          while (v26);
LABEL_77:
          uint64_t v104 = v15;
          int v5 = v83;
          xmlDocPtr v7 = v88;
          uint64_t v8 = v25;
          goto LABEL_78;
        }
        if (xmlDOMWrapNSNormGatherInScopeNs(&v107, a5) == -1) {
          uint64_t v10 = 0xFFFFFFFFLL;
        }
        else {
          uint64_t v10 = v10;
        }
        uint64_t v26 = *(void **)(v15 + 96);
        int v106 = v26;
        if (v26)
        {
          int v105 = 1;
          goto LABEL_64;
        }
        int v44 = (uint64_t *)(v15 + 72);
        int v105 = 1;
        if (!*(void *)(v15 + 72))
        {
          uint64_t v104 = v15;
          int v5 = v83;
          xmlDocPtr v7 = v88;
          uint64_t v8 = v25;
          goto LABEL_104;
        }
        uint64_t v104 = v15;
        int v5 = v83;
        xmlDocPtr v7 = v88;
        uint64_t v8 = v25;
LABEL_84:
        uint64_t v47 = v107;
        uint64_t v99 = v8;
        unsigned int v92 = v9;
        if (v107)
        {
          while (1)
          {
            uint64_t v47 = (uint64_t *)*v47;
            if (!v47) {
              break;
            }
            if (*((_DWORD *)v47 + 8) == -1 && *v44 == v47[2])
            {
              int v48 = v47 + 3;
              goto LABEL_103;
            }
          }
        }
        long long v89 = v7;
        int v49 = v5;
        if (v8)
        {
          int v50 = *(uint64_t (**)(uint64_t, uint64_t, void, void))(v8 + 24);
          uint64_t v51 = *v44;
          if (v50)
          {
            int v106 = (void *)v50(v8, v15, *(void *)(v51 + 16), *(void *)(v51 + 24));
            if (xmlDOMWrapNsMapAddItem(&v107, -1, *(void *)(v15 + 72), (uint64_t)v106, -4)) {
              uint64_t v10 = v10;
            }
            else {
              uint64_t v10 = 0xFFFFFFFFLL;
            }
            int v48 = (uint64_t *)&v106;
            int v5 = v49;
            goto LABEL_102;
          }
        }
        else
        {
          uint64_t v51 = *v44;
        }
        if (v94) {
          uint64_t v52 = 0;
        }
        else {
          uint64_t v52 = v104;
        }
        int v48 = (uint64_t *)&v106;
        int v53 = xmlDOMWrapNSNormAcquireNormalizedNs((uint64_t)v5, v52, v51, (uint64_t *)&v106, &v107, v12, *(_DWORD *)(v15 + 8) == 2);
        int v5 = v49;
        if (v53 == -1) {
          uint64_t v10 = 0xFFFFFFFFLL;
        }
        else {
          uint64_t v10 = v10;
        }
LABEL_102:
        xmlDocPtr v7 = v89;
LABEL_103:
        uint64_t *v44 = *v48;
        uint64_t v8 = v99;
        unint64_t v9 = v92;
LABEL_104:
        uint64_t v54 = (xmlDoc *)v9;
        if (v9) {
          goto LABEL_111;
        }
        uint64_t v55 = *(void **)(v15 + 16);
        if (!v55) {
          goto LABEL_111;
        }
        dict = v5->dict;
        if (dict)
        {
          int v86 = v5;
          xmlDocPtr v57 = v7;
          uint64_t v100 = v8;
          *(void *)(v15 + 16) = xmlDictLookup(dict, *(const xmlChar **)(v15 + 16), -1);
          if (!v57
            || (unsigned int v58 = v57->dict) == 0
            || (v59 = xmlDictOwns(v58, (const xmlChar *)v55), v8 = v100, v7 = v57, int v5 = v86, !v59))
          {
            xmlFree(v55);
            uint64_t v8 = v100;
            xmlDocPtr v7 = v57;
            int v5 = v86;
          }
        }
        else
        {
          if (!v7)
          {
            if (*(_DWORD *)(v15 + 8) != 1) {
              goto LABEL_117;
            }
            goto LABEL_112;
          }
          uint64_t v69 = v7->dict;
          if (v69)
          {
            uint64_t v70 = v5;
            xmlNodePtr v71 = v7;
            uint64_t v102 = v8;
            int v72 = xmlDictOwns(v69, *(const xmlChar **)(v15 + 16));
            uint64_t v8 = v102;
            xmlDocPtr v7 = v71;
            int v5 = v70;
            if (v72)
            {
              int v73 = xmlStrdup(*(const xmlChar **)(v15 + 16));
              uint64_t v8 = v102;
              xmlDocPtr v7 = v71;
              int v5 = v70;
              *(void *)(v15 + 16) = v73;
            }
          }
        }
LABEL_111:
        if (*(_DWORD *)(v15 + 8) != 1)
        {
          if (v7 && *(_DWORD *)(v15 + 80) == 2)
          {
            long long v60 = v5;
            long long v61 = v7;
            uint64_t v101 = v8;
            xmlRemoveID(v7, (xmlAttrPtr)v15);
            uint64_t v8 = v101;
            xmlDocPtr v7 = v61;
            int v5 = v60;
          }
LABEL_117:
          *(_DWORD *)(v15 + 80) = 0;
          *(void *)(v15 + 88) = 0;
          unint64_t v9 = (unint64_t)v54;
          goto LABEL_118;
        }
LABEL_112:
        *(void *)(v15 + 10xmlSAX2Text((uint64_t)ctx, (char *)value, len, 4) = 0;
        *(_DWORD *)(v15 + 112) = 0;
        uint64_t v11 = *(void *)(v15 + 88);
        unint64_t v9 = (unint64_t)v54;
        if (v11) {
          continue;
        }
LABEL_118:
        uint64_t v11 = *(void *)(v15 + 24);
        uint64_t v19 = v10;
        if (v11) {
          continue;
        }
LABEL_119:
        while (v15 != a3)
        {
          unsigned int v62 = *(_DWORD *)(v15 + 8);
          if (v62 <= 0x14 && ((1 << v62) & 0x180002) != 0)
          {
            int v64 = v107;
            if (v107)
            {
              uint64_t v65 = *v107;
              if (*v107)
              {
                xmlDOMWrapCtxtPtr v67 = v107 + 1;
                uint64_t v66 = v107[1];
                if (!v66) {
                  goto LABEL_172;
                }
                do
                {
                  if (*(_DWORD *)(v66 + 36) < v12) {
                    break;
                  }
                  uint64_t v68 = *(uint64_t **)(v66 + 8);
                  *xmlDOMWrapCtxtPtr v67 = (uint64_t)v68;
                  if (v68) {
                    int v64 = v68;
                  }
                  *int v64 = 0;
                  *(void *)uint64_t v66 = v107[2];
                  int v64 = v107;
                  v107[2] = v66;
                  xmlDOMWrapCtxtPtr v67 = v64 + 1;
                  uint64_t v66 = v64[1];
                }
                while (v66);
                uint64_t v65 = *v64;
                if (*v64)
                {
LABEL_172:
                  do
                  {
                    if (*(_DWORD *)(v65 + 32) >= v12) {
                      *(_DWORD *)(v65 + 32) = -1;
                    }
                    uint64_t v65 = *(void *)v65;
                  }
                  while (v65);
                }
              }
            }
            --v12;
          }
          uint64_t v11 = *(void *)(v15 + 48);
          if (!v11)
          {
            uint64_t v15 = *(void *)(v15 + 40);
            if (v62 != 2) {
              continue;
            }
            uint64_t v11 = *(void *)(v15 + 24);
            if (!v11) {
              continue;
            }
          }
          uint64_t v10 = v19;
          goto LABEL_14;
        }
        uint64_t v79 = v107;
        if (v107)
        {
          if (v8 && *(uint64_t **)(v8 + 16) == v107)
          {
            uint64_t v81 = *v107;
            if (*v107)
            {
              uint64_t v82 = v107[2];
              if (v82)
              {
                *(void *)v107[1] = v82;
                uint64_t v79 = v107;
                uint64_t v81 = *v107;
              }
              v79[2] = v81;
              uint64_t *v79 = 0;
            }
          }
          else
          {
            xmlDOMWrapNsMapFree((uint64_t)v107);
          }
        }
        return v19;
      case 2:
LABEL_78:
        int v44 = (uint64_t *)(v15 + 72);
        if (!*(void *)(v15 + 72)) {
          goto LABEL_104;
        }
        if (!v105)
        {
          int v85 = v5;
          int v91 = v9;
          unint64_t v9 = (unint64_t)v7;
          uint64_t v45 = v8;
          int v46 = xmlDOMWrapNSNormGatherInScopeNs(&v107, a5);
          uint64_t v8 = v45;
          xmlDocPtr v7 = (xmlDocPtr)v9;
          LODWORD(v9) = v91;
          int v5 = v85;
          if (v46 == -1) {
            uint64_t v10 = 0xFFFFFFFFLL;
          }
          else {
            uint64_t v10 = v10;
          }
          int v105 = 1;
        }
        goto LABEL_84;
      case 3:
      case 4:
        if (v9) {
          goto LABEL_23;
        }
        if (!v7) {
          goto LABEL_23;
        }
        uint64_t v20 = *(const xmlChar **)(v15 + 80);
        if (!v20) {
          goto LABEL_23;
        }
        int v21 = v7->dict;
        if (!v21) {
          goto LABEL_23;
        }
        uint64_t v95 = v8;
        int v87 = v7;
        int v22 = v5;
        if (xmlDictOwns(v21, v20))
        {
          xmlNodePtr v23 = v22->dict;
          if (v23) {
            uint64_t v24 = (void *)xmlDictLookup(v23, *(const xmlChar **)(v15 + 80), -1);
          }
          else {
            uint64_t v24 = xmlStrdup(*(const xmlChar **)(v15 + 80));
          }
          int v5 = v22;
          *(void *)(v15 + 80) = v24;
          uint64_t v19 = v10;
        }
        else
        {
          uint64_t v19 = v10;
          int v5 = v22;
        }
        xmlDocPtr v7 = v87;
        uint64_t v8 = v95;
        goto LABEL_119;
      case 5:
        *(void *)(v15 + 80) = 0;
        *(void *)(v15 + 2xmlSAX2Text((uint64_t)ctx, (char *)value, len, 4) = 0;
        *(void *)(v15 + 32) = 0;
        if (!v5->intSubset && !v5->extSubset) {
          goto LABEL_23;
        }
        uint64_t v96 = v8;
        unsigned int v90 = v9;
        signed int v27 = v7;
        uint64_t v28 = v5;
        xmlEntityPtr DocEntity = xmlGetDocEntity(v5, *(const xmlChar **)(v15 + 16));
        if (DocEntity)
        {
          *(void *)(v15 + 80) = DocEntity->content;
          *(void *)(v15 + 2xmlSAX2Text((uint64_t)ctx, (char *)value, len, 4) = DocEntity;
          *(void *)(v15 + 32) = DocEntity;
        }
        uint64_t v19 = v10;
        int v5 = v28;
        xmlDocPtr v7 = v27;
        unint64_t v9 = v90;
        uint64_t v8 = v96;
        goto LABEL_119;
      case 7:
        if (v9) {
          goto LABEL_118;
        }
        xmlNsPtr v30 = *(void **)(v15 + 16);
        if (!v30) {
          goto LABEL_51;
        }
        int v31 = v5->dict;
        if (v31)
        {
          uint64_t v84 = v5;
          xmlDocPtr v32 = v7;
          uint64_t v97 = v8;
          *(void *)(v15 + 16) = xmlDictLookup(v31, *(const xmlChar **)(v15 + 16), -1);
          if (!v32
            || (uint64_t v33 = v32->dict) == 0
            || (v34 = xmlDictOwns(v33, (const xmlChar *)v30), v8 = v97, v7 = v32, int v5 = v84, !v34))
          {
            xmlFree(v30);
            uint64_t v8 = v97;
            xmlDocPtr v7 = v32;
            int v5 = v84;
          }
        }
        else
        {
          if (!v7) {
            goto LABEL_118;
          }
          long long v74 = v7->dict;
          if (v74)
          {
            int v75 = v5;
            int v76 = v7;
            uint64_t v103 = v8;
            int v77 = xmlDictOwns(v74, *(const xmlChar **)(v15 + 16));
            uint64_t v8 = v103;
            xmlDocPtr v7 = v76;
            int v5 = v75;
            if (v77)
            {
              uint64_t v78 = xmlStrdup(*(const xmlChar **)(v15 + 16));
              uint64_t v8 = v103;
              xmlDocPtr v7 = v76;
              int v5 = v75;
              *(void *)(v15 + 16) = v78;
            }
          }
        }
LABEL_51:
        if (v7)
        {
          int v35 = *(const xmlChar **)(v15 + 80);
          if (v35)
          {
            xmlElementType v36 = v7->dict;
            if (v36)
            {
              uint64_t v98 = v8;
              long long v37 = v7;
              uint64_t v38 = v5;
              if (xmlDictOwns(v36, v35))
              {
                uint64_t v39 = v38->dict;
                if (v39) {
                  uint64_t v40 = (void *)xmlDictLookup(v39, *(const xmlChar **)(v15 + 80), -1);
                }
                else {
                  uint64_t v40 = xmlStrdup(*(const xmlChar **)(v15 + 80));
                }
                int v5 = v38;
                *(void *)(v15 + 80) = v40;
              }
              else
              {
                int v5 = v38;
              }
              xmlDocPtr v7 = v37;
              uint64_t v8 = v98;
            }
          }
        }
        goto LABEL_118;
      case 8:
        goto LABEL_118;
      case 19:
      case 20:
        goto LABEL_119;
      default:
        uint64_t v10 = 0xFFFFFFFFLL;
        goto LABEL_118;
    }
  }
}