__n128 ETLDebugRegisterDelegate(__n128 *a1)
{
  __n128 result;

  result = *a1;
  gDelegate = (__int128)*a1;
  return result;
}

uint64_t lz4_decode_fast(int8x16_t **a1, unint64_t a2, unint64_t a3, unsigned __int8 **a4, unint64_t a5)
{
  v5 = *a4;
  v6 = *a1;
  while (1)
  {
    v7 = v6;
    v8 = v5;
    if ((unint64_t)v5 >= a5 || (unint64_t)v6 >= a3) {
      break;
    }
    unsigned int v10 = *v5;
    v9 = v5 + 1;
    unint64_t v11 = (unint64_t)v10 >> 4;
    unint64_t v12 = (v10 & 0xF) + 4;
    if (v11 > 0xE)
    {
      while ((unint64_t)v9 < a5)
      {
        unsigned int v13 = *(unsigned __int8 *)v9;
        v9 = (_OWORD *)((char *)v9 + 1);
        v11 += v13;
        if (v13 != 255)
        {
          v14 = (int8x16_t *)v9;
          v15 = v6;
          v16 = (unsigned __int16 *)((char *)v9 + v11);
          v17 = (int8x16_t *)((char *)v6 + v11);
          if ((unint64_t)v16 < a5 && (unint64_t)v17 < a3)
          {
            int8x16_t v19 = *v14;
            int8x16_t v20 = v14[1];
            v18 = v14 + 2;
            int8x16_t *v15 = v19;
            v15[1] = v20;
            v21 = v15 + 2;
            do
            {
              int8x16_t v22 = *v18;
              int8x16_t v23 = v18[1];
              v18 += 2;
              int8x16_t *v21 = v22;
              v21[1] = v23;
              v21 += 2;
            }
            while (v17 > v21);
            goto LABEL_13;
          }
          goto LABEL_34;
        }
      }
      break;
    }
    int8x16_t *v6 = *(int8x16_t *)v9;
    v16 = (unsigned __int16 *)((char *)v9 + v11);
    v17 = (int8x16_t *)((char *)v6 + v11);
LABEL_13:
    unsigned int v25 = *v16;
    v5 = (unsigned __int8 *)(v16 + 1);
    unint64_t v24 = v25;
    v26 = (int8x16_t *)((char *)v17 - v25);
    if ((unint64_t)v26 < a2)
    {
      uint64_t v47 = -1;
      goto LABEL_35;
    }
    v27 = v17;
    v6 = (int8x16_t *)((char *)v17 + v12);
    if (v12 == 19)
    {
      while ((unint64_t)v5 < a5)
      {
        unsigned int v28 = *v5++;
        v6 = (int8x16_t *)((char *)v6 + v28);
        if (v28 != 255)
        {
          if ((unint64_t)v6 >= a3) {
            goto LABEL_34;
          }
          goto LABEL_22;
        }
      }
      break;
    }
    if (v12 > 0x10)
    {
LABEL_22:
      if (v24 > 0x1F)
      {
        int8x16_t v36 = *v26;
        v35 = v26 + 1;
        int8x16_t *v27 = v36;
        v37 = v27 + 1;
        do
        {
          int8x16_t v38 = *v35;
          int8x16_t v39 = v35[1];
          v35 += 2;
          int8x16_t *v37 = v38;
          v37[1] = v39;
          v37 += 2;
        }
        while (v6 > v37);
      }
      else if (v24 > 0xF)
      {
        int8x16_t v41 = *v26;
        v40 = v26 + 1;
        int8x16_t *v27 = v41;
        v42 = v27 + 1;
        do
        {
          int8x16_t v44 = *v40;
          v43 = v40 + 1;
          int8x16_t *v42 = v44;
          v45 = v42 + 1;
          int8x16_t v46 = *v43;
          v40 = v43 + 1;
          int8x16_t *v45 = v46;
          v42 = v45 + 1;
        }
        while (v6 > v42);
      }
      else
      {
        v29 = (int8x16_t *)&qword_1E454B780[4 * v24];
        int8x16_t v30 = vqtbl1q_s8(*v26, *v29);
        int8x16_t v31 = vqtbl1q_s8(*v26, v29[1]);
        uint64_t v32 = *((unsigned __int8 *)qword_1E454B980 + v24);
        int8x16_t *v27 = v30;
        v27[1] = v31;
        v33 = (int8x16_t *)((char *)v27 + v32);
        do
        {
          int8x16_t *v33 = v30;
          v33[1] = v31;
          v34 = (int8x16_t *)((char *)v33 + v32);
          int8x16_t *v34 = v30;
          v34[1] = v31;
          v33 = (int8x16_t *)((char *)v34 + v32);
        }
        while (v6 > v33);
      }
    }
    else if (v24 <= 0xF)
    {
      int8x16_t *v27 = vqtbl1q_s8(*v26, *(int8x16_t *)&qword_1E454B780[4 * v24]);
    }
    else
    {
      int8x16_t *v27 = *v26;
    }
  }
LABEL_34:
  uint64_t v47 = 0;
LABEL_35:
  *a4 = v8;
  *a1 = v7;
  return v47;
}

uint64_t lz4_decode(char *__dst, unint64_t a2, unsigned __int8 *a3, unint64_t a4)
{
  if (a2 < 0x100 || a4 <= 0xFF) {
    return (int)LZ4_decompress_safe(a3, __dst, a4, a2);
  }
  unsigned int v10 = a3;
  unint64_t v11 = __dst;
  v5 = &__dst[a2];
  unint64_t v6 = (unint64_t)&a3[a4];
  if (lz4_decode_fast((int8x16_t **)&v11, (unint64_t)__dst, (unint64_t)&__dst[a2 - 128], &v10, (unint64_t)&a3[a4 - 128]))
  {
    return 0;
  }
  v8 = v11;
  uint64_t v9 = lz4_decode_safe((void **)&v11, (unint64_t)__dst, v5, (unint64_t *)&v10, v6);
  if (v9) {
    return v8 - __dst + v9;
  }
  else {
    return 0;
  }
}

uint64_t LZ4_compressBound(unsigned int a1)
{
  if (a1 <= 0x7E000000) {
    return a1 + a1 / 0xFF + 16;
  }
  else {
    return 0;
  }
}

uint64_t LZ4_compress()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  int v2 = v1;
  v4 = v3;
  unint64_t v5 = v0;
  uint64_t v113 = *MEMORY[0x1E4F143B8];
  bzero(v112, 0x4000uLL);
  if (v2 > 65546)
  {
    if (v2 <= 0x7E000000)
    {
      int v109 = v2;
      unint64_t v54 = v5 + v2;
      v55 = v4;
      unint64_t v56 = v54 - 12;
      v57 = (_DWORD *)(v5 + 2);
      unint64_t v103 = v54 - 8;
      unint64_t v105 = v54 - 5;
      unint64_t v107 = v54;
      unint64_t v101 = v54 - 6;
      int v111 = (int)v55;
      unint64_t v7 = v5;
LABEL_65:
      unint64_t v58 = v7 + 1;
      int v59 = *(_DWORD *)(v7 + 1);
      unsigned int v60 = 68;
      while (1)
      {
        v61 = v57;
        unsigned int v62 = (-1640531535 * v59) >> 20;
        int v59 = *v57;
        uint64_t v63 = *(unsigned int *)&v112[2 * v62];
        *(_DWORD *)&v112[2 * v62] = v58 - v5;
        if (v5 + v63 + 0xFFFF >= v58 && *(_DWORD *)(v5 + v63) == *(_DWORD *)v58) {
          break;
        }
        uint64_t v64 = v60++ >> 6;
        v57 = (_DWORD *)((char *)v57 + v64);
        unint64_t v58 = (unint64_t)v61;
        if ((unint64_t)v57 > v56) {
          goto LABEL_115;
        }
      }
      uint64_t v65 = 0;
      int v66 = v58 - v7;
      char v67 = v58 - v7 - 14;
      uint64_t v68 = (v58 << 32) - (v7 << 32);
      int v69 = v58 - v7 - 15;
      do
      {
        int v70 = v69;
        uint64_t v71 = v65;
        uint64_t v72 = v68;
        unint64_t v73 = v58 + v65;
        unint64_t v74 = v5 + v63 + v65;
        if (v73 <= v7 || v74 <= v5) {
          break;
        }
        int v76 = *(unsigned __int8 *)(v74 - 1);
        --v69;
        uint64_t v65 = v71 - 1;
        v68 -= 0x100000000;
      }
      while (*(unsigned __int8 *)(v73 - 1) == v76);
      v77 = v55 + 1;
      if (v66 + (int)v71 < 15)
      {
        unsigned char *v55 = 16 * (v73 - v7);
      }
      else
      {
        unsigned char *v55 = -16;
        if ((v66 + v71) <= 0x10D)
        {
          char v80 = v71 + v58 - v7 - 15;
        }
        else
        {
          if (v70 >= 509) {
            int v78 = 509;
          }
          else {
            int v78 = v70;
          }
          unsigned int v79 = v66 - v78 + v71 + 239;
          char v99 = v67;
          memset(v77, 255, v79 / 0xFF + 1);
          v77 = &v55[v79 / 0xFFuLL + 2];
          char v80 = v79 / 0xFF + v99 + v71;
        }
        *(unsigned char *)v77 = v80;
        v77 = (void *)((char *)v77 + 1);
      }
      v81 = (_DWORD *)(v5 + v63 + v71);
      v82 = (_WORD *)((char *)v77 + (v72 >> 32));
      do
      {
        uint64_t v83 = *(void *)v7;
        v7 += 8;
        *v77++ = v83;
      }
      while (v77 < (void *)v82);
      while (1)
      {
        v84 = v55;
        _WORD *v82 = v73 - (_WORD)v81;
        v55 = v82 + 1;
        int v85 = v73 + 4;
        v86 = v81 + 1;
        unint64_t v7 = v73 + 4;
        if (v73 + 4 >= v56)
        {
LABEL_93:
          if (v7 < v103 && *v86 == *(_DWORD *)v7)
          {
            v7 += 4;
            ++v86;
          }
          if (v7 < v101 && *(unsigned __int16 *)v86 == *(unsigned __int16 *)v7)
          {
            v7 += 2;
            v86 = (_DWORD *)((char *)v86 + 2);
          }
          if (v7 < v105 && *(unsigned __int8 *)v86 == *(unsigned __int8 *)v7) {
            ++v7;
          }
        }
        else
        {
          while (1)
          {
            unint64_t v87 = *(void *)v7 ^ *(void *)v86;
            if (v87) {
              break;
            }
            v7 += 8;
            v86 += 2;
            if (v7 >= v56) {
              goto LABEL_93;
            }
          }
          v7 += __clz(__rbit64(v87)) >> 3;
        }
        char v88 = v7 - v85;
        BOOL v42 = __OFSUB__(v7 - v85, 15);
        unsigned int v89 = v7 - v85 - 15;
        if (((v89 & 0x80000000) != 0) != v42)
        {
          *v84 += v88;
        }
        else
        {
          *v84 += 15;
          if (v89 >= 0x1FE)
          {
            unsigned int v90 = v7 - v73 - 529;
            uint64_t v91 = v90 / 0x1FE;
            memset(v82 + 1, 255, v91 * 2 + 2);
            unsigned int v89 = v90 % 0x1FE;
            v55 = &v82[v91 + 2];
          }
          if (v89 >= 0xFF)
          {
            *v55++ = -1;
            LOBYTE(v89) = v89 + 1;
          }
          *v55++ = v89;
        }
        if (v7 > v56) {
          break;
        }
        *(_DWORD *)&v112[2 * ((-1640531535 * *(_DWORD *)(v7 - 2)) >> 20)] = v7 - 2 - v5;
        unsigned int v92 = (-1640531535 * *(_DWORD *)v7) >> 20;
        v81 = (_DWORD *)(v5 + *(unsigned int *)&v112[2 * v92]);
        *(_DWORD *)&v112[2 * v92] = v7 - v5;
        if ((unint64_t)v81 + 0xFFFF < v7 || *v81 != *(_DWORD *)v7)
        {
          v57 = (_DWORD *)(v7 + 2);
          if (v7 + 2 <= v56) {
            goto LABEL_65;
          }
          break;
        }
        unsigned char *v55 = 0;
        v82 = v55 + 1;
        unint64_t v73 = v7;
      }
LABEL_115:
      size_t v48 = v107 - v7;
      int v93 = v107 - v7 - 15;
      LODWORD(v4) = v111;
      if ((int)v107 - (int)v7 < 15)
      {
        unsigned char *v55 = 16 * v48;
      }
      else
      {
        unsigned char *v55 = -16;
        v94 = v55 + 1;
        if (v48 >= 0x10E)
        {
          int v95 = v5 + v109;
          if (v93 >= 509) {
            int v93 = 509;
          }
          unint64_t v96 = (v95 - (v93 + v7) + 239) / 0xFFuLL;
          memset(v94, 255, v96 + 1);
          LOBYTE(v93) = v95 - v7 + v96 - 14;
          v94 = &v55[v96 + 2];
        }
        unsigned char *v94 = v93;
        v55 = v94;
      }
      v97 = v55 + 1;
      goto LABEL_125;
    }
    return 0;
  }
  if (v2 > 0x7E000000) {
    return 0;
  }
  unint64_t v6 = v5 + v2;
  unint64_t v7 = v5;
  v8 = v4;
  if (v2 >= 0xE)
  {
    int v108 = v2;
    v8 = v4;
    unint64_t v9 = v6 - 12;
    unsigned int v10 = (_DWORD *)(v5 + 2);
    unint64_t v102 = v6 - 8;
    unint64_t v104 = v6 - 5;
    unint64_t v106 = v5 + v2;
    unint64_t v100 = v6 - 6;
    int v110 = (int)v8;
    unint64_t v7 = v5;
LABEL_5:
    unint64_t v11 = v7 + 1;
    int v12 = *(_DWORD *)(v7 + 1);
    unsigned int v13 = 68;
    while (1)
    {
      v14 = v10;
      unsigned int v15 = (-1640531535 * v12) >> 19;
      int v12 = *v10;
      uint64_t v16 = (unsigned __int16)v112[v15];
      v112[v15] = v11 - v5;
      if (v5 + v16 + 0xFFFF >= v11 && *(_DWORD *)(v5 + v16) == *(_DWORD *)v11) {
        break;
      }
      uint64_t v17 = v13++ >> 6;
      unsigned int v10 = (_DWORD *)((char *)v10 + v17);
      unint64_t v11 = (unint64_t)v14;
      if ((unint64_t)v10 > v9) {
        goto LABEL_55;
      }
    }
    uint64_t v18 = 0;
    int v19 = v11 - v7;
    char v20 = v11 - v7 - 14;
    uint64_t v21 = (v11 << 32) - (v7 << 32);
    int v22 = v11 - v7 - 15;
    do
    {
      int v23 = v22;
      uint64_t v24 = v18;
      uint64_t v25 = v21;
      unint64_t v26 = v11 + v18;
      unint64_t v27 = v5 + v16 + v18;
      if (v26 <= v7 || v27 <= v5) {
        break;
      }
      int v29 = *(unsigned __int8 *)(v27 - 1);
      --v22;
      uint64_t v18 = v24 - 1;
      v21 -= 0x100000000;
    }
    while (*(unsigned __int8 *)(v26 - 1) == v29);
    int8x16_t v30 = v8 + 1;
    if (v19 + (int)v24 < 15)
    {
      unsigned char *v8 = 16 * (v26 - v7);
    }
    else
    {
      unsigned char *v8 = -16;
      if ((v19 + v24) <= 0x10D)
      {
        char v33 = v24 + v11 - v7 - 15;
      }
      else
      {
        if (v23 >= 509) {
          int v31 = 509;
        }
        else {
          int v31 = v23;
        }
        unsigned int v32 = v19 - v31 + v24 + 239;
        char v98 = v20;
        memset(v30, 255, v32 / 0xFF + 1);
        int8x16_t v30 = &v8[v32 / 0xFFuLL + 2];
        char v33 = v32 / 0xFF + v98 + v24;
      }
      *(unsigned char *)int8x16_t v30 = v33;
      int8x16_t v30 = (void *)((char *)v30 + 1);
    }
    v34 = (_DWORD *)(v5 + v16 + v24);
    v35 = (_WORD *)((char *)v30 + (v25 >> 32));
    do
    {
      uint64_t v36 = *(void *)v7;
      v7 += 8;
      *v30++ = v36;
    }
    while (v30 < (void *)v35);
    while (1)
    {
      v37 = v8;
      _WORD *v35 = v26 - (_WORD)v34;
      v8 = v35 + 1;
      int v38 = v26 + 4;
      int8x16_t v39 = v34 + 1;
      unint64_t v7 = v26 + 4;
      if (v26 + 4 >= v9)
      {
LABEL_33:
        if (v7 < v102 && *v39 == *(_DWORD *)v7)
        {
          v7 += 4;
          ++v39;
        }
        if (v7 < v100 && *(unsigned __int16 *)v39 == *(unsigned __int16 *)v7)
        {
          v7 += 2;
          int8x16_t v39 = (_DWORD *)((char *)v39 + 2);
        }
        if (v7 < v104 && *(unsigned __int8 *)v39 == *(unsigned __int8 *)v7) {
          ++v7;
        }
      }
      else
      {
        while (1)
        {
          unint64_t v40 = *(void *)v7 ^ *(void *)v39;
          if (v40) {
            break;
          }
          v7 += 8;
          v39 += 2;
          if (v7 >= v9) {
            goto LABEL_33;
          }
        }
        v7 += __clz(__rbit64(v40)) >> 3;
      }
      char v41 = v7 - v38;
      BOOL v42 = __OFSUB__(v7 - v38, 15);
      unsigned int v43 = v7 - v38 - 15;
      if (((v43 & 0x80000000) != 0) != v42)
      {
        *v37 += v41;
      }
      else
      {
        *v37 += 15;
        if (v43 >= 0x1FE)
        {
          unsigned int v44 = v7 - v26 - 529;
          uint64_t v45 = v44 / 0x1FE;
          memset(v35 + 1, 255, v45 * 2 + 2);
          unsigned int v43 = v44 % 0x1FE;
          v8 = &v35[v45 + 2];
        }
        if (v43 >= 0xFF)
        {
          *v8++ = -1;
          LOBYTE(v43) = v43 + 1;
        }
        *v8++ = v43;
      }
      if (v7 > v9) {
        break;
      }
      v112[(-1640531535 * *(_DWORD *)(v7 - 2)) >> 19] = v7 - 2 - v5;
      int v46 = *(_DWORD *)v7;
      unsigned int v47 = (-1640531535 * *(_DWORD *)v7) >> 19;
      v34 = (_DWORD *)(v5 + (unsigned __int16)v112[v47]);
      v112[v47] = v7 - v5;
      if ((unint64_t)v34 + 0xFFFF < v7 || *v34 != v46)
      {
        unsigned int v10 = (_DWORD *)(v7 + 2);
        if (v7 + 2 <= v9) {
          goto LABEL_5;
        }
        break;
      }
      unsigned char *v8 = 0;
      v35 = v8 + 1;
      unint64_t v26 = v7;
    }
LABEL_55:
    LODWORD(v4) = v110;
    int v2 = v108;
    unint64_t v6 = v106;
  }
  size_t v48 = v6 - v7;
  BOOL v42 = __OFSUB__(v6 - v7, 15);
  int v49 = v6 - v7 - 15;
  if (v49 < 0 != v42)
  {
    unsigned char *v8 = 16 * v48;
  }
  else
  {
    unsigned char *v8 = -16;
    v50 = v8 + 1;
    if (v48 >= 0x10E)
    {
      int v51 = v5 + v2;
      if (v49 >= 509) {
        int v49 = 509;
      }
      unint64_t v52 = (v51 - (v49 + v7) + 239) / 0xFFuLL;
      memset(v50, 255, v52 + 1);
      LOBYTE(v49) = v51 - v7 + v52 - 14;
      v50 = &v8[v52 + 2];
    }
    unsigned char *v50 = v49;
    v8 = v50;
  }
  v97 = v8 + 1;
LABEL_125:
  memcpy(v97, (const void *)v7, v48);
  return (v97 + v48 - v4);
}

uint64_t LZ4_compress_limitedOutput()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  unsigned int v2 = v1;
  int v4 = v3;
  unint64_t v6 = v5;
  unint64_t v7 = v0;
  uint64_t v120 = *MEMORY[0x1E4F143B8];
  bzero(v119, 0x4000uLL);
  unint64_t v8 = (unint64_t)&v6[v2];
  unint64_t v118 = v8;
  if (v4 <= 65546)
  {
    if (v4 <= 0x7E000000)
    {
      unint64_t v9 = v7 + v4;
      unint64_t v10 = v7;
      unint64_t v11 = v6;
      if (v4 >= 0xE)
      {
        int v114 = v4;
        unsigned int v116 = v2;
        unint64_t v12 = v9 - 12;
        unsigned int v13 = (_DWORD *)(v7 + 2);
        unint64_t v108 = v9 - 8;
        unint64_t v110 = v9 - 5;
        unint64_t v112 = v7 + v4;
        unint64_t v106 = v9 - 6;
        unint64_t v11 = v6;
        unint64_t v10 = v7;
LABEL_5:
        unint64_t v14 = v10 + 1;
        int v15 = *(_DWORD *)(v10 + 1);
        unsigned int v16 = 68;
        while (1)
        {
          uint64_t v17 = v13;
          unsigned int v18 = (-1640531535 * v15) >> 19;
          int v15 = *v13;
          uint64_t v19 = (unsigned __int16)v119[v18];
          v119[v18] = v14 - v7;
          if (v7 + v19 + 0xFFFF >= v14 && *(_DWORD *)(v7 + v19) == *(_DWORD *)v14) {
            break;
          }
          uint64_t v20 = v16++ >> 6;
          unsigned int v13 = (_DWORD *)((char *)v13 + v20);
          unint64_t v14 = (unint64_t)v17;
          if ((unint64_t)v13 > v12)
          {
LABEL_57:
            int v4 = v114;
            unsigned int v2 = v116;
            unint64_t v9 = v112;
            goto LABEL_58;
          }
        }
        uint64_t v21 = 0;
        int v22 = v14 - v10;
        char v23 = v14 - v10 - 15;
        char v24 = v14 - v10 - 14;
        uint64_t v25 = (v14 << 32) - (v10 << 32);
        int v26 = v14 - v10 - 15;
        do
        {
          int v27 = v26;
          uint64_t v28 = v21;
          uint64_t v29 = v25;
          unint64_t v30 = v14 + v21;
          unint64_t v31 = v7 + v19 + v21;
          if (v30 <= v10 || v31 <= v7) {
            break;
          }
          int v33 = *(unsigned __int8 *)(v31 - 1);
          --v26;
          uint64_t v21 = v28 - 1;
          v25 -= 0x100000000;
        }
        while (*(unsigned __int8 *)(v30 - 1) == v33);
        int v34 = v22 + v28;
        v35 = v11 + 1;
        if ((unint64_t)&v11[(v29 >> 32) + 9 + (v22 + (int)v28) / 255] <= v8)
        {
          if (v34 < 15)
          {
            *unint64_t v11 = 16 * (v30 - v10);
          }
          else
          {
            *unint64_t v11 = -16;
            if (v34 <= 0x10D)
            {
              char v38 = v28 + v23;
            }
            else
            {
              if (v27 >= 509) {
                int v36 = 509;
              }
              else {
                int v36 = v27;
              }
              unsigned int v37 = v22 - v36 + v28 + 239;
              char v104 = v24;
              memset(v35, 255, v37 / 0xFF + 1);
              unint64_t v8 = v118;
              v35 = &v11[v37 / 0xFFuLL + 2];
              char v38 = v37 / 0xFF + v104 + v28;
            }
            *(unsigned char *)v35 = v38;
            v35 = (void *)((char *)v35 + 1);
          }
          int8x16_t v39 = (_DWORD *)(v7 + v19 + v28);
          unint64_t v40 = (_WORD *)((char *)v35 + (v29 >> 32));
          do
          {
            uint64_t v41 = *(void *)v10;
            v10 += 8;
            *v35++ = v41;
          }
          while (v35 < (void *)v40);
          while (1)
          {
            BOOL v42 = v11;
            _WORD *v40 = v30 - (_WORD)v39;
            unint64_t v11 = v40 + 1;
            int v43 = v30 + 4;
            unsigned int v44 = v39 + 1;
            unint64_t v10 = v30 + 4;
            if (v30 + 4 >= v12)
            {
LABEL_34:
              if (v10 < v108 && *v44 == *(_DWORD *)v10)
              {
                v10 += 4;
                ++v44;
              }
              if (v10 < v106 && *(unsigned __int16 *)v44 == *(unsigned __int16 *)v10)
              {
                v10 += 2;
                unsigned int v44 = (_DWORD *)((char *)v44 + 2);
              }
              if (v10 < v110 && *(unsigned __int8 *)v44 == *(unsigned __int8 *)v10) {
                ++v10;
              }
            }
            else
            {
              while (1)
              {
                unint64_t v45 = *(void *)v10 ^ *(void *)v44;
                if (v45) {
                  break;
                }
                v10 += 8;
                v44 += 2;
                if (v10 >= v12) {
                  goto LABEL_34;
                }
              }
              v10 += __clz(__rbit64(v45)) >> 3;
            }
            int v46 = v10 - v43;
            if ((unint64_t)v40 + (((int)v10 - v43) >> 8) + 8 > v8) {
              break;
            }
            unsigned int v47 = v46 - 15;
            if (v46 < 15)
            {
              *v42 += v46;
            }
            else
            {
              *v42 += 15;
              if (v47 >= 0x1FE)
              {
                unsigned int v48 = v10 - v30 - 529;
                uint64_t v49 = v48 / 0x1FE;
                memset(v40 + 1, 255, v49 * 2 + 2);
                unint64_t v8 = v118;
                unsigned int v47 = v48 % 0x1FE;
                unint64_t v11 = &v40[v49 + 2];
              }
              if (v47 >= 0xFF)
              {
                *v11++ = -1;
                LOBYTE(v47) = v47 + 1;
              }
              *v11++ = v47;
            }
            if (v10 > v12) {
              goto LABEL_57;
            }
            v119[(-1640531535 * *(_DWORD *)(v10 - 2)) >> 19] = v10 - 2 - v7;
            int v50 = *(_DWORD *)v10;
            unsigned int v51 = (-1640531535 * *(_DWORD *)v10) >> 19;
            int8x16_t v39 = (_DWORD *)(v7 + (unsigned __int16)v119[v51]);
            v119[v51] = v10 - v7;
            if ((unint64_t)v39 + 0xFFFF < v10 || *v39 != v50)
            {
              unsigned int v13 = (_DWORD *)(v10 + 2);
              if (v10 + 2 <= v12) {
                goto LABEL_5;
              }
              goto LABEL_57;
            }
            *unint64_t v11 = 0;
            unint64_t v40 = v11 + 1;
            unint64_t v30 = v10;
          }
        }
        return 0;
      }
LABEL_58:
      size_t v52 = v9 - v10;
      if ((uint64_t)(v11 - v6 + (int)v9 - (int)v10 + (v9 - v10 + 240) / 0xFFuLL + 1) <= v2)
      {
        int v53 = v52 - 15;
        if ((int)v52 < 15)
        {
          *unint64_t v11 = 16 * v52;
        }
        else
        {
          *unint64_t v11 = -16;
          unint64_t v54 = v11 + 1;
          if (v52 >= 0x10E)
          {
            int v55 = v7 + v4;
            if (v53 >= 509) {
              int v53 = 509;
            }
            unint64_t v56 = (v55 - (v53 + v10) + 239) / 0xFFuLL;
            memset(v54, 255, v56 + 1);
            LOBYTE(v53) = v55 - v10 + v56 - 14;
            unint64_t v54 = &v11[v56 + 2];
          }
          *unint64_t v54 = v53;
          unint64_t v11 = v54;
        }
        memcpy(v11 + 1, (const void *)v10, v52);
        return (v11 + 1 + v52 - v6);
      }
    }
    return 0;
  }
  if (v4 > 0x7E000000) {
    return 0;
  }
  int v115 = v4;
  unint64_t v57 = v7 + v4;
  unint64_t v58 = v57 - 12;
  int v59 = (_DWORD *)(v7 + 2);
  unint64_t v109 = v57 - 8;
  unint64_t v111 = v57 - 5;
  unint64_t v113 = v57;
  unint64_t v107 = v57 - 6;
  v117 = v6;
  unint64_t v60 = v7;
LABEL_67:
  unint64_t v61 = v60 + 1;
  int v62 = *(_DWORD *)(v60 + 1);
  unsigned int v63 = 68;
  do
  {
    uint64_t v64 = v59;
    unsigned int v65 = (-1640531535 * v62) >> 20;
    int v62 = *v59;
    uint64_t v66 = *(unsigned int *)&v119[2 * v65];
    *(_DWORD *)&v119[2 * v65] = v61 - v7;
    if (v7 + v66 + 0xFFFF >= v61 && *(_DWORD *)(v7 + v66) == *(_DWORD *)v61)
    {
      uint64_t v68 = 0;
      int v69 = v61 - v60;
      char v70 = v61 - v60 - 15;
      char v71 = v61 - v60 - 14;
      uint64_t v72 = (v61 << 32) - (v60 << 32);
      int v73 = v61 - v60 - 15;
      do
      {
        int v74 = v73;
        uint64_t v75 = v68;
        uint64_t v76 = v72;
        unint64_t v77 = v61 + v68;
        unint64_t v78 = v7 + v66 + v68;
        if (v77 <= v60 || v78 <= v7) {
          break;
        }
        int v80 = *(unsigned __int8 *)(v78 - 1);
        --v73;
        uint64_t v68 = v75 - 1;
        v72 -= 0x100000000;
      }
      while (*(unsigned __int8 *)(v77 - 1) == v80);
      int v81 = v69 + v75;
      v82 = v6 + 1;
      if ((unint64_t)&v6[(v76 >> 32) + 9 + (v69 + (int)v75) / 255] <= v8)
      {
        if (v81 < 15)
        {
          unsigned char *v6 = 16 * (v77 - v60);
        }
        else
        {
          unsigned char *v6 = -16;
          if (v81 <= 0x10D)
          {
            char v85 = v75 + v70;
          }
          else
          {
            if (v74 >= 509) {
              int v83 = 509;
            }
            else {
              int v83 = v74;
            }
            unsigned int v84 = v69 - v83 + v75 + 239;
            char v105 = v71;
            memset(v82, 255, v84 / 0xFF + 1);
            unint64_t v8 = v118;
            v82 = &v6[v84 / 0xFFuLL + 2];
            char v85 = v84 / 0xFF + v105 + v75;
          }
          *(unsigned char *)v82 = v85;
          v82 = (void *)((char *)v82 + 1);
        }
        v86 = (_DWORD *)(v7 + v66 + v75);
        unint64_t v87 = (_WORD *)((char *)v82 + (v76 >> 32));
        do
        {
          uint64_t v88 = *(void *)v60;
          v60 += 8;
          *v82++ = v88;
        }
        while (v82 < (void *)v87);
        while (1)
        {
          unsigned int v89 = v6;
          *unint64_t v87 = v77 - (_WORD)v86;
          unint64_t v6 = v87 + 1;
          int v90 = v77 + 4;
          uint64_t v91 = v86 + 1;
          unint64_t v60 = v77 + 4;
          if (v77 + 4 >= v58)
          {
LABEL_96:
            if (v60 < v109 && *v91 == *(_DWORD *)v60)
            {
              v60 += 4;
              ++v91;
            }
            if (v60 < v107 && *(unsigned __int16 *)v91 == *(unsigned __int16 *)v60)
            {
              v60 += 2;
              uint64_t v91 = (_DWORD *)((char *)v91 + 2);
            }
            if (v60 < v111 && *(unsigned __int8 *)v91 == *(unsigned __int8 *)v60) {
              ++v60;
            }
          }
          else
          {
            while (1)
            {
              unint64_t v92 = *(void *)v60 ^ *(void *)v91;
              if (v92) {
                break;
              }
              v60 += 8;
              v91 += 2;
              if (v60 >= v58) {
                goto LABEL_96;
              }
            }
            v60 += __clz(__rbit64(v92)) >> 3;
          }
          int v93 = v60 - v90;
          if ((unint64_t)v87 + (((int)v60 - v90) >> 8) + 8 > v8) {
            break;
          }
          unsigned int v94 = v93 - 15;
          if (v93 < 15)
          {
            *v89 += v93;
          }
          else
          {
            *v89 += 15;
            if (v94 >= 0x1FE)
            {
              unsigned int v95 = v60 - v77 - 529;
              uint64_t v96 = v95 / 0x1FE;
              memset(v87 + 1, 255, v96 * 2 + 2);
              unint64_t v8 = v118;
              unsigned int v94 = v95 % 0x1FE;
              unint64_t v6 = &v87[v96 + 2];
            }
            if (v94 >= 0xFF)
            {
              *v6++ = -1;
              LOBYTE(v94) = v94 + 1;
            }
            *v6++ = v94;
          }
          if (v60 > v58) {
            goto LABEL_119;
          }
          *(_DWORD *)&v119[2 * ((-1640531535 * *(_DWORD *)(v60 - 2)) >> 20)] = v60 - 2 - v7;
          unsigned int v97 = (-1640531535 * *(_DWORD *)v60) >> 20;
          v86 = (_DWORD *)(v7 + *(unsigned int *)&v119[2 * v97]);
          *(_DWORD *)&v119[2 * v97] = v60 - v7;
          if ((unint64_t)v86 + 0xFFFF < v60 || *v86 != *(_DWORD *)v60)
          {
            int v59 = (_DWORD *)(v60 + 2);
            if (v60 + 2 <= v58) {
              goto LABEL_67;
            }
            goto LABEL_119;
          }
          unsigned char *v6 = 0;
          unint64_t v87 = v6 + 1;
          unint64_t v77 = v60;
        }
      }
      return 0;
    }
    uint64_t v67 = v63++ >> 6;
    int v59 = (_DWORD *)((char *)v59 + v67);
    unint64_t v61 = (unint64_t)v64;
  }
  while ((unint64_t)v59 <= v58);
LABEL_119:
  size_t v98 = v113 - v60;
  if ((uint64_t)(v6 - v117 + (int)v113 - (int)v60 + (v113 - v60 + 240) / 0xFFuLL + 1) > v2) {
    return 0;
  }
  int v100 = v98 - 15;
  if ((int)v98 < 15)
  {
    unsigned char *v6 = 16 * v98;
  }
  else
  {
    unsigned char *v6 = -16;
    unint64_t v101 = v6 + 1;
    if (v98 >= 0x10E)
    {
      int v102 = v7 + v115;
      if (v100 >= 509) {
        int v100 = 509;
      }
      unint64_t v103 = (v102 - (v100 + v60) + 239) / 0xFFuLL;
      memset(v101, 255, v103 + 1);
      LOBYTE(v100) = v102 - v60 + v103 - 14;
      unint64_t v101 = &v6[v103 + 2];
    }
    *unint64_t v101 = v100;
    unint64_t v6 = v101;
  }
  memcpy(v6 + 1, (const void *)v60, v98);
  return (v6 + 1 + v98 - v117);
}

uint64_t LZ4_sizeofState()
{
  return 0x4000;
}

uint64_t LZ4_compress_withState(unsigned int *a1, _DWORD *a2, unsigned char *a3, int a4)
{
  if ((a1 & 3) != 0) {
    return 0;
  }
  bzero(a1, 0x4000uLL);
  if (a4 > 65546)
  {
    if (a4 <= 0x7E000000)
    {
      int v111 = a4;
      unint64_t v56 = (char *)a2 + a4;
      unint64_t v57 = (unint64_t)(v56 - 12);
      unint64_t v58 = (_DWORD *)((char *)a2 + 2);
      a1[(-1640531535 * *a2) >> 20] = 0;
      unint64_t v105 = (unint64_t)(v56 - 8);
      unint64_t v107 = (unint64_t)(v56 - 5);
      unint64_t v109 = v56;
      unint64_t v103 = (unint64_t)(v56 - 6);
      int v113 = (int)a3;
      int v59 = a3;
      unint64_t v10 = (unint64_t)a2;
LABEL_68:
      unint64_t v60 = v10 + 1;
      int v61 = *(_DWORD *)(v10 + 1);
      unsigned int v62 = 68;
      while (1)
      {
        unsigned int v63 = v58;
        unsigned int v64 = (-1640531535 * v61) >> 20;
        int v61 = *v58;
        uint64_t v65 = a1[v64];
        a1[v64] = v60 - a2;
        if ((unint64_t)a2 + v65 + 0xFFFF >= v60 && *(_DWORD *)((char *)a2 + v65) == *(_DWORD *)v60) {
          break;
        }
        uint64_t v66 = v62++ >> 6;
        unint64_t v58 = (_DWORD *)((char *)v58 + v66);
        unint64_t v60 = (unint64_t)v63;
        if ((unint64_t)v58 > v57) {
          goto LABEL_118;
        }
      }
      uint64_t v67 = 0;
      int v68 = v60 - v10;
      char v69 = v60 - v10 - 14;
      uint64_t v70 = (v60 << 32) - (v10 << 32);
      int v71 = v60 - v10 - 15;
      do
      {
        int v72 = v71;
        uint64_t v73 = v67;
        uint64_t v74 = v70;
        unint64_t v75 = v60 + v67;
        uint64_t v76 = (char *)a2 + v65 + v67;
        if (v75 <= v10 || v76 <= (char *)a2) {
          break;
        }
        int v78 = *(v76 - 1);
        --v71;
        uint64_t v67 = v73 - 1;
        v70 -= 0x100000000;
      }
      while (*(unsigned __int8 *)(v75 - 1) == v78);
      unsigned int v79 = v59 + 1;
      if (v68 + (int)v73 < 15)
      {
        *int v59 = 16 * (v75 - v10);
      }
      else
      {
        *int v59 = -16;
        if ((v68 + v73) <= 0x10D)
        {
          char v82 = v73 + v60 - v10 - 15;
        }
        else
        {
          if (v72 >= 509) {
            int v80 = 509;
          }
          else {
            int v80 = v72;
          }
          unsigned int v81 = v68 - v80 + v73 + 239;
          char v101 = v69;
          memset(v79, 255, v81 / 0xFF + 1);
          unsigned int v79 = &v59[v81 / 0xFFuLL + 2];
          char v82 = v81 / 0xFF + v101 + v73;
        }
        *(unsigned char *)unsigned int v79 = v82;
        unsigned int v79 = (void *)((char *)v79 + 1);
      }
      int v83 = (_DWORD *)((char *)a2 + v65 + v73);
      unsigned int v84 = (_WORD *)((char *)v79 + (v74 >> 32));
      do
      {
        uint64_t v85 = *(void *)v10;
        v10 += 8;
        *v79++ = v85;
      }
      while (v79 < (void *)v84);
      while (1)
      {
        v86 = v59;
        _WORD *v84 = v75 - (_WORD)v83;
        int v59 = v84 + 1;
        int v87 = v75 + 4;
        uint64_t v88 = v83 + 1;
        unint64_t v10 = v75 + 4;
        if (v75 + 4 >= v57)
        {
LABEL_96:
          if (v10 < v105 && *v88 == *(_DWORD *)v10)
          {
            v10 += 4;
            ++v88;
          }
          if (v10 < v103 && *(unsigned __int16 *)v88 == *(unsigned __int16 *)v10)
          {
            v10 += 2;
            uint64_t v88 = (_DWORD *)((char *)v88 + 2);
          }
          if (v10 < v107 && *(unsigned __int8 *)v88 == *(unsigned __int8 *)v10) {
            ++v10;
          }
        }
        else
        {
          while (1)
          {
            unint64_t v89 = *(void *)v10 ^ *(void *)v88;
            if (v89) {
              break;
            }
            v10 += 8;
            v88 += 2;
            if (v10 >= v57) {
              goto LABEL_96;
            }
          }
          v10 += __clz(__rbit64(v89)) >> 3;
        }
        char v90 = v10 - v87;
        BOOL v45 = __OFSUB__(v10 - v87, 15);
        unsigned int v91 = v10 - v87 - 15;
        if (((v91 & 0x80000000) != 0) != v45)
        {
          *v86 += v90;
        }
        else
        {
          *v86 += 15;
          if (v91 >= 0x1FE)
          {
            unsigned int v92 = v10 - v75 - 529;
            uint64_t v93 = v92 / 0x1FE;
            memset(v84 + 1, 255, v93 * 2 + 2);
            unsigned int v91 = v92 % 0x1FE;
            int v59 = &v84[v93 + 2];
          }
          if (v91 >= 0xFF)
          {
            *v59++ = -1;
            LOBYTE(v91) = v91 + 1;
          }
          *v59++ = v91;
        }
        if (v10 > v57) {
          break;
        }
        a1[(-1640531535 * *(_DWORD *)(v10 - 2)) >> 20] = v10 - 2 - a2;
        unsigned int v94 = (-1640531535 * *(_DWORD *)v10) >> 20;
        int v83 = (_DWORD *)((char *)a2 + a1[v94]);
        a1[v94] = v10 - a2;
        if ((unint64_t)v83 + 0xFFFF < v10 || *v83 != *(_DWORD *)v10)
        {
          unint64_t v58 = (_DWORD *)(v10 + 2);
          if (v10 + 2 <= v57) {
            goto LABEL_68;
          }
          break;
        }
        *int v59 = 0;
        unsigned int v84 = v59 + 1;
        unint64_t v75 = v10;
      }
LABEL_118:
      size_t v51 = (size_t)&v109[-v10];
      int v95 = v109 - v10 - 15;
      LODWORD(a3) = v113;
      if ((int)v109 - (int)v10 < 15)
      {
        *int v59 = 16 * v51;
      }
      else
      {
        *int v59 = -16;
        uint64_t v96 = v59 + 1;
        if (v51 >= 0x10E)
        {
          int v97 = a2 + v111;
          if (v95 >= 509) {
            int v95 = 509;
          }
          unint64_t v98 = (v97 - (v95 + v10) + 239) / 0xFFuLL;
          memset(v96, 255, v98 + 1);
          LOBYTE(v95) = v97 - v10 + v98 - 14;
          uint64_t v96 = &v59[v98 + 2];
        }
        *uint64_t v96 = v95;
        int v59 = v96;
      }
      char v99 = v59 + 1;
      goto LABEL_128;
    }
    return 0;
  }
  if (a4 > 0x7E000000) {
    return 0;
  }
  unint64_t v9 = (char *)a2 + a4;
  unint64_t v10 = (unint64_t)a2;
  unint64_t v11 = a3;
  if (a4 >= 0xD)
  {
    int v112 = (int)a3;
    *((_WORD *)a1 + ((-1640531535 * *a2) >> 19)) = 0;
    int v110 = a4;
    if (a4 == 13)
    {
      unint64_t v10 = (unint64_t)a2;
      unint64_t v11 = a3;
      a4 = 13;
    }
    else
    {
      unint64_t v12 = (unint64_t)(v9 - 12);
      unsigned int v13 = (_DWORD *)((char *)a2 + 2);
      unint64_t v104 = (unint64_t)(v9 - 8);
      unint64_t v106 = (unint64_t)(v9 - 5);
      unint64_t v108 = (char *)a2 + a4;
      unint64_t v102 = (unint64_t)(v9 - 6);
      unint64_t v11 = a3;
      unint64_t v10 = (unint64_t)a2;
LABEL_8:
      unint64_t v14 = v10 + 1;
      int v15 = *(_DWORD *)(v10 + 1);
      unsigned int v16 = 68;
      while (1)
      {
        uint64_t v17 = v13;
        unsigned int v18 = (-1640531535 * v15) >> 19;
        int v15 = *v13;
        uint64_t v19 = *((unsigned __int16 *)a1 + v18);
        *((_WORD *)a1 + v18) = v14 - (_WORD)a2;
        if ((unint64_t)a2 + v19 + 0xFFFF >= v14 && *(_DWORD *)((char *)a2 + v19) == *(_DWORD *)v14) {
          break;
        }
        uint64_t v20 = v16++ >> 6;
        unsigned int v13 = (_DWORD *)((char *)v13 + v20);
        unint64_t v14 = (unint64_t)v17;
        if ((unint64_t)v13 > v12) {
          goto LABEL_58;
        }
      }
      uint64_t v21 = 0;
      int v22 = v14 - v10;
      char v23 = v14 - v10 - 14;
      uint64_t v24 = (v14 << 32) - (v10 << 32);
      int v25 = v14 - v10 - 15;
      do
      {
        int v26 = v25;
        uint64_t v27 = v21;
        uint64_t v28 = v24;
        unint64_t v29 = v14 + v21;
        unint64_t v30 = (char *)a2 + v19 + v21;
        if (v29 <= v10 || v30 <= (char *)a2) {
          break;
        }
        int v32 = *(v30 - 1);
        --v25;
        uint64_t v21 = v27 - 1;
        v24 -= 0x100000000;
      }
      while (*(unsigned __int8 *)(v29 - 1) == v32);
      int v33 = v11 + 1;
      if (v22 + (int)v27 < 15)
      {
        *unint64_t v11 = 16 * (v29 - v10);
      }
      else
      {
        *unint64_t v11 = -16;
        if ((v22 + v27) <= 0x10D)
        {
          char v36 = v27 + v14 - v10 - 15;
        }
        else
        {
          if (v26 >= 509) {
            int v34 = 509;
          }
          else {
            int v34 = v26;
          }
          unsigned int v35 = v22 - v34 + v27 + 239;
          char v100 = v23;
          memset(v33, 255, v35 / 0xFF + 1);
          int v33 = &v11[v35 / 0xFFuLL + 2];
          char v36 = v35 / 0xFF + v100 + v27;
        }
        *(unsigned char *)int v33 = v36;
        int v33 = (void *)((char *)v33 + 1);
      }
      unsigned int v37 = (_DWORD *)((char *)a2 + v19 + v27);
      char v38 = (_WORD *)((char *)v33 + (v28 >> 32));
      do
      {
        uint64_t v39 = *(void *)v10;
        v10 += 8;
        *v33++ = v39;
      }
      while (v33 < (void *)v38);
      while (1)
      {
        unint64_t v40 = v11;
        *char v38 = v29 - (_WORD)v37;
        unint64_t v11 = v38 + 1;
        int v41 = v29 + 4;
        BOOL v42 = v37 + 1;
        unint64_t v10 = v29 + 4;
        if (v29 + 4 >= v12)
        {
LABEL_36:
          if (v10 < v104 && *v42 == *(_DWORD *)v10)
          {
            v10 += 4;
            ++v42;
          }
          if (v10 < v102 && *(unsigned __int16 *)v42 == *(unsigned __int16 *)v10)
          {
            v10 += 2;
            BOOL v42 = (_DWORD *)((char *)v42 + 2);
          }
          if (v10 < v106 && *(unsigned __int8 *)v42 == *(unsigned __int8 *)v10) {
            ++v10;
          }
        }
        else
        {
          while (1)
          {
            unint64_t v43 = *(void *)v10 ^ *(void *)v42;
            if (v43) {
              break;
            }
            v10 += 8;
            v42 += 2;
            if (v10 >= v12) {
              goto LABEL_36;
            }
          }
          v10 += __clz(__rbit64(v43)) >> 3;
        }
        char v44 = v10 - v41;
        BOOL v45 = __OFSUB__(v10 - v41, 15);
        unsigned int v46 = v10 - v41 - 15;
        if (((v46 & 0x80000000) != 0) != v45)
        {
          *v40 += v44;
        }
        else
        {
          *v40 += 15;
          if (v46 >= 0x1FE)
          {
            unsigned int v47 = v10 - v29 - 529;
            uint64_t v48 = v47 / 0x1FE;
            memset(v38 + 1, 255, v48 * 2 + 2);
            unsigned int v46 = v47 % 0x1FE;
            unint64_t v11 = &v38[v48 + 2];
          }
          if (v46 >= 0xFF)
          {
            *v11++ = -1;
            LOBYTE(v46) = v46 + 1;
          }
          *v11++ = v46;
        }
        if (v10 > v12) {
          break;
        }
        *((_WORD *)a1 + ((-1640531535 * *(_DWORD *)(v10 - 2)) >> 19)) = v10 - 2 - (_WORD)a2;
        int v49 = *(_DWORD *)v10;
        unsigned int v50 = (-1640531535 * *(_DWORD *)v10) >> 19;
        unsigned int v37 = (_DWORD *)((char *)a2 + *((unsigned __int16 *)a1 + v50));
        *((_WORD *)a1 + v50) = v10 - (_WORD)a2;
        if ((unint64_t)v37 + 0xFFFF < v10 || *v37 != v49)
        {
          unsigned int v13 = (_DWORD *)(v10 + 2);
          if (v10 + 2 <= v12) {
            goto LABEL_8;
          }
          break;
        }
        *unint64_t v11 = 0;
        char v38 = v11 + 1;
        unint64_t v29 = v10;
      }
LABEL_58:
      LODWORD(a3) = v112;
      a4 = v110;
      unint64_t v9 = v108;
    }
  }
  size_t v51 = (size_t)&v9[-v10];
  int v52 = v9 - v10 - 15;
  if ((int)v9 - (int)v10 < 15)
  {
    *unint64_t v11 = 16 * v51;
  }
  else
  {
    *unint64_t v11 = -16;
    int v53 = v11 + 1;
    if (v51 >= 0x10E)
    {
      int v54 = a2 + a4;
      if (v52 >= 509) {
        int v52 = 509;
      }
      unint64_t v55 = (v54 - (v52 + v10) + 239) / 0xFFuLL;
      memset(v53, 255, v55 + 1);
      LOBYTE(v52) = v54 - v10 + v55 - 14;
      int v53 = &v11[v55 + 2];
    }
    *int v53 = v52;
    unint64_t v11 = v53;
  }
  char v99 = v11 + 1;
LABEL_128:
  memcpy(v99, (const void *)v10, v51);
  return (v99 + v51 - a3);
}

uint64_t LZ4_compress_limitedOutput_withState(unsigned int *a1, _DWORD *a2, unsigned char *a3, int a4, unsigned int a5)
{
  if ((a1 & 3) != 0) {
    return 0;
  }
  bzero(a1, 0x4000uLL);
  unint64_t v11 = (unint64_t)&a3[a5];
  unint64_t v116 = v11;
  if (a4 > 65546)
  {
    if (a4 <= 0x7E000000)
    {
      unsigned int v111 = a5;
      int v113 = a4;
      int v59 = (char *)a2 + a4;
      unint64_t v60 = (unint64_t)(v59 - 12);
      int v61 = (_DWORD *)((char *)a2 + 2);
      a1[(-1640531535 * *a2) >> 20] = 0;
      unint64_t v105 = (unint64_t)(v59 - 8);
      unint64_t v107 = (unint64_t)(v59 - 5);
      unint64_t v109 = v59;
      unint64_t v103 = (unint64_t)(v59 - 6);
      int v115 = a3;
      unint64_t v14 = a3;
      unint64_t v13 = (unint64_t)a2;
LABEL_67:
      unint64_t v62 = v13 + 1;
      int v63 = *(_DWORD *)(v13 + 1);
      unsigned int v64 = 68;
      do
      {
        uint64_t v65 = v61;
        unsigned int v66 = (-1640531535 * v63) >> 20;
        int v63 = *v61;
        uint64_t v67 = a1[v66];
        a1[v66] = v62 - a2;
        if ((unint64_t)a2 + v67 + 0xFFFF >= v62 && *(_DWORD *)((char *)a2 + v67) == *(_DWORD *)v62)
        {
          uint64_t v69 = 0;
          int v70 = v62 - v13;
          char v71 = v62 - v13 - 15;
          char v72 = v62 - v13 - 14;
          uint64_t v73 = (v62 << 32) - (v13 << 32);
          int v74 = v62 - v13 - 15;
          do
          {
            int v75 = v74;
            uint64_t v76 = v69;
            uint64_t v77 = v73;
            unint64_t v78 = v62 + v69;
            unsigned int v79 = (char *)a2 + v67 + v69;
            if (v78 <= v13 || v79 <= (char *)a2) {
              break;
            }
            int v81 = *(v79 - 1);
            --v74;
            uint64_t v69 = v76 - 1;
            v73 -= 0x100000000;
          }
          while (*(unsigned __int8 *)(v78 - 1) == v81);
          int v82 = v70 + v76;
          int v83 = v14 + 1;
          if ((unint64_t)&v14[(v77 >> 32) + 9 + (v70 + (int)v76) / 255] <= v11)
          {
            if (v82 < 15)
            {
              unsigned char *v14 = 16 * (v78 - v13);
            }
            else
            {
              unsigned char *v14 = -16;
              if (v82 <= 0x10D)
              {
                char v86 = v76 + v71;
              }
              else
              {
                if (v75 >= 509) {
                  int v84 = 509;
                }
                else {
                  int v84 = v75;
                }
                unsigned int v85 = v70 - v84 + v76 + 239;
                char v101 = v72;
                memset(v83, 255, v85 / 0xFF + 1);
                unint64_t v11 = v116;
                int v83 = &v14[v85 / 0xFFuLL + 2];
                char v86 = v85 / 0xFF + v101 + v76;
              }
              *(unsigned char *)int v83 = v86;
              int v83 = (void *)((char *)v83 + 1);
            }
            int v87 = (_DWORD *)((char *)a2 + v67 + v76);
            uint64_t v88 = (_WORD *)((char *)v83 + (v77 >> 32));
            do
            {
              uint64_t v89 = *(void *)v13;
              v13 += 8;
              *v83++ = v89;
            }
            while (v83 < (void *)v88);
            while (1)
            {
              char v90 = v14;
              *uint64_t v88 = v78 - (_WORD)v87;
              unint64_t v14 = v88 + 1;
              int v91 = v78 + 4;
              unsigned int v92 = v87 + 1;
              unint64_t v13 = v78 + 4;
              if (v78 + 4 >= v60)
              {
LABEL_96:
                if (v13 < v105 && *v92 == *(_DWORD *)v13)
                {
                  v13 += 4;
                  ++v92;
                }
                if (v13 < v103 && *(unsigned __int16 *)v92 == *(unsigned __int16 *)v13)
                {
                  v13 += 2;
                  unsigned int v92 = (_DWORD *)((char *)v92 + 2);
                }
                if (v13 < v107 && *(unsigned __int8 *)v92 == *(unsigned __int8 *)v13) {
                  ++v13;
                }
              }
              else
              {
                while (1)
                {
                  unint64_t v93 = *(void *)v13 ^ *(void *)v92;
                  if (v93) {
                    break;
                  }
                  v13 += 8;
                  v92 += 2;
                  if (v13 >= v60) {
                    goto LABEL_96;
                  }
                }
                v13 += __clz(__rbit64(v93)) >> 3;
              }
              int v94 = v13 - v91;
              if ((unint64_t)v88 + (((int)v13 - v91) >> 8) + 8 > v11) {
                break;
              }
              unsigned int v95 = v94 - 15;
              if (v94 < 15)
              {
                *v90 += v94;
              }
              else
              {
                *v90 += 15;
                if (v95 >= 0x1FE)
                {
                  unsigned int v96 = v13 - v78 - 529;
                  uint64_t v97 = v96 / 0x1FE;
                  memset(v88 + 1, 255, v97 * 2 + 2);
                  unint64_t v11 = v116;
                  unsigned int v95 = v96 % 0x1FE;
                  unint64_t v14 = &v88[v97 + 2];
                }
                if (v95 >= 0xFF)
                {
                  *v14++ = -1;
                  LOBYTE(v95) = v95 + 1;
                }
                *v14++ = v95;
              }
              if (v13 > v60) {
                goto LABEL_119;
              }
              a1[(-1640531535 * *(_DWORD *)(v13 - 2)) >> 20] = v13 - 2 - a2;
              unsigned int v98 = (-1640531535 * *(_DWORD *)v13) >> 20;
              int v87 = (_DWORD *)((char *)a2 + a1[v98]);
              a1[v98] = v13 - a2;
              if ((unint64_t)v87 + 0xFFFF < v13 || *v87 != *(_DWORD *)v13)
              {
                int v61 = (_DWORD *)(v13 + 2);
                if (v13 + 2 <= v60) {
                  goto LABEL_67;
                }
                goto LABEL_119;
              }
              unsigned char *v14 = 0;
              uint64_t v88 = v14 + 1;
              unint64_t v78 = v13;
            }
          }
          return 0;
        }
        uint64_t v68 = v64++ >> 6;
        int v61 = (_DWORD *)((char *)v61 + v68);
        unint64_t v62 = (unint64_t)v65;
      }
      while ((unint64_t)v61 <= v60);
LABEL_119:
      size_t v55 = (size_t)&v109[-v13];
      LODWORD(a3) = v115;
      if ((uint64_t)(v14 - v115 + (int)v109 - (int)v13 + (v109 - v13 + 240) / 0xFFuLL + 1) > v111) {
        return 0;
      }
      int v56 = v55 - 15;
      if ((int)v55 >= 15)
      {
        unsigned char *v14 = -16;
        unint64_t v57 = v14 + 1;
        if (v55 < 0x10E) {
          goto LABEL_127;
        }
        int v58 = a2 + v113;
        goto LABEL_124;
      }
LABEL_128:
      unsigned char *v14 = 16 * v55;
      goto LABEL_129;
    }
    return 0;
  }
  if (a4 > 0x7E000000) {
    return 0;
  }
  unint64_t v12 = (char *)a2 + a4;
  unint64_t v13 = (unint64_t)a2;
  unint64_t v14 = a3;
  if (a4 >= 0xD)
  {
    unsigned int v110 = a5;
    int v112 = a4;
    int v114 = a3;
    *((_WORD *)a1 + ((-1640531535 * *a2) >> 19)) = 0;
    if (a4 != 13)
    {
      unint64_t v15 = (unint64_t)(v12 - 12);
      unsigned int v16 = (_DWORD *)((char *)a2 + 2);
      unint64_t v104 = (unint64_t)(v12 - 8);
      unint64_t v106 = (unint64_t)(v12 - 5);
      unint64_t v108 = (char *)a2 + a4;
      unint64_t v102 = (unint64_t)(v12 - 6);
      unint64_t v14 = a3;
      unint64_t v13 = (unint64_t)a2;
LABEL_8:
      unint64_t v17 = v13 + 1;
      int v18 = *(_DWORD *)(v13 + 1);
      unsigned int v19 = 68;
      while (1)
      {
        uint64_t v20 = v16;
        unsigned int v21 = (-1640531535 * v18) >> 19;
        int v18 = *v16;
        uint64_t v22 = *((unsigned __int16 *)a1 + v21);
        *((_WORD *)a1 + v21) = v17 - (_WORD)a2;
        if ((unint64_t)a2 + v22 + 0xFFFF >= v17 && *(_DWORD *)((char *)a2 + v22) == *(_DWORD *)v17) {
          break;
        }
        uint64_t v23 = v19++ >> 6;
        unsigned int v16 = (_DWORD *)((char *)v16 + v23);
        unint64_t v17 = (unint64_t)v20;
        if ((unint64_t)v16 > v15)
        {
LABEL_60:
          a3 = v114;
          a5 = v110;
          a4 = v112;
          unint64_t v12 = v108;
          goto LABEL_61;
        }
      }
      uint64_t v24 = 0;
      int v25 = v17 - v13;
      char v26 = v17 - v13 - 15;
      char v27 = v17 - v13 - 14;
      uint64_t v28 = (v17 << 32) - (v13 << 32);
      int v29 = v17 - v13 - 15;
      do
      {
        int v30 = v29;
        uint64_t v31 = v24;
        uint64_t v32 = v28;
        unint64_t v33 = v17 + v24;
        int v34 = (char *)a2 + v22 + v24;
        if (v33 <= v13 || v34 <= (char *)a2) {
          break;
        }
        int v36 = *(v34 - 1);
        --v29;
        uint64_t v24 = v31 - 1;
        v28 -= 0x100000000;
      }
      while (*(unsigned __int8 *)(v33 - 1) == v36);
      int v37 = v25 + v31;
      char v38 = v14 + 1;
      if ((unint64_t)&v14[(v32 >> 32) + 9 + (v25 + (int)v31) / 255] <= v11)
      {
        if (v37 < 15)
        {
          unsigned char *v14 = 16 * (v33 - v13);
        }
        else
        {
          unsigned char *v14 = -16;
          if (v37 <= 0x10D)
          {
            char v41 = v31 + v26;
          }
          else
          {
            if (v30 >= 509) {
              int v39 = 509;
            }
            else {
              int v39 = v30;
            }
            unsigned int v40 = v25 - v39 + v31 + 239;
            char v100 = v27;
            memset(v38, 255, v40 / 0xFF + 1);
            unint64_t v11 = v116;
            char v38 = &v14[v40 / 0xFFuLL + 2];
            char v41 = v40 / 0xFF + v100 + v31;
          }
          *(unsigned char *)char v38 = v41;
          char v38 = (void *)((char *)v38 + 1);
        }
        BOOL v42 = (_DWORD *)((char *)a2 + v22 + v31);
        unint64_t v43 = (_WORD *)((char *)v38 + (v32 >> 32));
        do
        {
          uint64_t v44 = *(void *)v13;
          v13 += 8;
          *v38++ = v44;
        }
        while (v38 < (void *)v43);
        while (1)
        {
          BOOL v45 = v14;
          _WORD *v43 = v33 - (_WORD)v42;
          unint64_t v14 = v43 + 1;
          int v46 = v33 + 4;
          unsigned int v47 = v42 + 1;
          unint64_t v13 = v33 + 4;
          if (v33 + 4 >= v15)
          {
LABEL_37:
            if (v13 < v104 && *v47 == *(_DWORD *)v13)
            {
              v13 += 4;
              ++v47;
            }
            if (v13 < v102 && *(unsigned __int16 *)v47 == *(unsigned __int16 *)v13)
            {
              v13 += 2;
              unsigned int v47 = (_DWORD *)((char *)v47 + 2);
            }
            if (v13 < v106 && *(unsigned __int8 *)v47 == *(unsigned __int8 *)v13) {
              ++v13;
            }
          }
          else
          {
            while (1)
            {
              unint64_t v48 = *(void *)v13 ^ *(void *)v47;
              if (v48) {
                break;
              }
              v13 += 8;
              v47 += 2;
              if (v13 >= v15) {
                goto LABEL_37;
              }
            }
            v13 += __clz(__rbit64(v48)) >> 3;
          }
          int v49 = v13 - v46;
          if ((unint64_t)v43 + (((int)v13 - v46) >> 8) + 8 > v11) {
            break;
          }
          unsigned int v50 = v49 - 15;
          if (v49 < 15)
          {
            *v45 += v49;
          }
          else
          {
            *v45 += 15;
            if (v50 >= 0x1FE)
            {
              unsigned int v51 = v13 - v33 - 529;
              uint64_t v52 = v51 / 0x1FE;
              memset(v43 + 1, 255, v52 * 2 + 2);
              unint64_t v11 = v116;
              unsigned int v50 = v51 % 0x1FE;
              unint64_t v14 = &v43[v52 + 2];
            }
            if (v50 >= 0xFF)
            {
              *v14++ = -1;
              LOBYTE(v50) = v50 + 1;
            }
            *v14++ = v50;
          }
          if (v13 > v15) {
            goto LABEL_60;
          }
          *((_WORD *)a1 + ((-1640531535 * *(_DWORD *)(v13 - 2)) >> 19)) = v13 - 2 - (_WORD)a2;
          int v53 = *(_DWORD *)v13;
          unsigned int v54 = (-1640531535 * *(_DWORD *)v13) >> 19;
          BOOL v42 = (_DWORD *)((char *)a2 + *((unsigned __int16 *)a1 + v54));
          *((_WORD *)a1 + v54) = v13 - (_WORD)a2;
          if ((unint64_t)v42 + 0xFFFF < v13 || *v42 != v53)
          {
            unsigned int v16 = (_DWORD *)(v13 + 2);
            if (v13 + 2 <= v15) {
              goto LABEL_8;
            }
            goto LABEL_60;
          }
          unsigned char *v14 = 0;
          unint64_t v43 = v14 + 1;
          unint64_t v33 = v13;
        }
      }
      return 0;
    }
    unint64_t v13 = (unint64_t)a2;
    unint64_t v14 = a3;
    a4 = 13;
  }
LABEL_61:
  size_t v55 = (size_t)&v12[-v13];
  if ((uint64_t)(v14 - a3 + (int)v12 - (int)v13 + (v12 - v13 + 240) / 0xFFuLL + 1) > a5) {
    return 0;
  }
  int v56 = v55 - 15;
  if ((int)v55 < 15) {
    goto LABEL_128;
  }
  unsigned char *v14 = -16;
  unint64_t v57 = v14 + 1;
  if (v55 >= 0x10E)
  {
    int v58 = a2 + a4;
LABEL_124:
    if (v56 >= 509) {
      int v56 = 509;
    }
    unint64_t v99 = (v58 - (v56 + v13) + 239) / 0xFFuLL;
    memset(v57, 255, v99 + 1);
    LOBYTE(v56) = v58 - v13 + v99 - 14;
    unint64_t v57 = &v14[v99 + 2];
  }
LABEL_127:
  unsigned char *v57 = v56;
  unint64_t v14 = v57;
LABEL_129:
  memcpy(v14 + 1, (const void *)v13, v55);
  return (v14 + 1 + v55 - a3);
}

uint64_t LZ4_sizeofStreamState()
{
  return 16408;
}

uint64_t LZ4_resetStreamState(void *a1, uint64_t a2)
{
  if ((a1 & 3) != 0) {
    return 1;
  }
  bzero(a1, 0x4000uLL);
  uint64_t result = 0;
  a1[2048] = a2;
  a1[2049] = a2;
  a1[2050] = a2;
  return result;
}

void *LZ4_create(uint64_t a1)
{
  unsigned int v2 = calloc(1uLL, 0x4018uLL);
  bzero(v2, 0x4000uLL);
  v2[2048] = a1;
  v2[2049] = a1;
  v2[2050] = a1;
  return v2;
}

uint64_t LZ4_free(void *a1)
{
  return 0;
}

uint64_t LZ4_slideInputBuffer(void *a1)
{
  uint64_t v2 = a1[2050];
  int v3 = (void *)a1[2048];
  uint64_t v4 = (uint64_t)v3 - v2 + 0x10000;
  uint64_t v5 = a1[2049];
  unint64_t v6 = (const void *)(v2 - 0x10000);
  if (v4 > 0 || (unint64_t)(v2 - v5) >= 0xE0000001)
  {
    uint64_t v8 = 0;
    unint64_t v9 = (unint64_t)v6 - v5;
    uint64x2_t v10 = (uint64x2_t)vdupq_n_s64(v9);
    int32x4_t v11 = vdupq_n_s32(v9);
    do
    {
      int32x4_t v12 = *(int32x4_t *)&a1[v8];
      v13.i64[0] = v12.u32[0];
      v13.i64[1] = v12.u32[1];
      uint64x2_t v14 = v13;
      v13.i64[0] = v12.u32[2];
      v13.i64[1] = v12.u32[3];
      *(int8x16_t *)&a1[v8] = vbicq_s8((int8x16_t)vsubq_s32(v12, v11), (int8x16_t)vuzp1q_s32((int32x4_t)vcgtq_u64(v10, v14), (int32x4_t)vcgtq_u64(v10, v13)));
      v8 += 2;
    }
    while (v8 != 2048);
    memcpy(v3, v6, 0x10000uLL);
    uint64_t v15 = a1[2048];
    a1[2049] = v15;
    uint64_t result = v15 + 0x10000;
    a1[2050] = v15 + 0x10000;
  }
  else
  {
    memcpy(v3, v6, 0x10000uLL);
    uint64_t result = a1[2050] + v4;
    a1[2050] = result;
    a1[2049] += v4;
  }
  return result;
}

uint64_t LZ4_compress_continue(uint64_t a1, char *__src, unsigned char *a3, unsigned int a4)
{
  if (a4 > 0x7E000000) {
    return 0;
  }
  if (*(char **)(a1 + 16400) != __src) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 16392);
  unint64_t v8 = *(void *)(a1 + 0x4000);
  unint64_t v9 = &__src[a4];
  *(void *)(a1 + 16400) = v9;
  int v60 = (int)__src;
  unint64_t v10 = (unint64_t)__src;
  int32x4_t v11 = a3;
  if (a4 >= 0xD)
  {
    int v58 = &__src[a4];
    int v59 = (int)a3;
    unint64_t v10 = (unint64_t)__src;
    *(_DWORD *)(a1 + 4 * ((-1640531535 * *(_DWORD *)__src) >> 20)) = __src - v7;
    unsigned int v57 = a4;
    if (a4 == 13)
    {
      int32x4_t v11 = a3;
    }
    else
    {
      int32x4_t v11 = a3;
      unint64_t v12 = (unint64_t)(v58 - 12);
      uint64x2_t v13 = __src + 2;
      unint64_t v61 = v8;
LABEL_8:
      unint64_t v14 = v10 + 1;
      int v15 = *(_DWORD *)(v10 + 1);
      unsigned int v16 = 68;
      while (1)
      {
        unint64_t v17 = v13;
        unsigned int v18 = (-1640531535 * v15) >> 20;
        int v15 = *v13;
        uint64_t v19 = *(unsigned int *)(a1 + 4 * v18);
        *(_DWORD *)(a1 + 4 * v18) = v14 - v7;
        if (v7 + v19 + 0xFFFF >= v14 && *(_DWORD *)(v7 + v19) == *(_DWORD *)v14) {
          break;
        }
        uint64_t v20 = v16++ >> 6;
        uint64x2_t v13 = (_DWORD *)((char *)v13 + v20);
        unint64_t v14 = (unint64_t)v17;
        if ((unint64_t)v13 > v12) {
          goto LABEL_58;
        }
      }
      uint64_t v21 = 0;
      int v22 = v14 - v10;
      char v23 = v14 - v10 - 14;
      uint64_t v24 = (v14 << 32) - (v10 << 32);
      int v25 = v14 - v10 - 15;
      do
      {
        int v26 = v25;
        uint64_t v27 = v21;
        uint64_t v28 = v24;
        unint64_t v29 = v14 + v21;
        unint64_t v30 = v7 + v19 + v21;
        if (v29 <= v10 || v30 <= v8) {
          break;
        }
        int v32 = *(unsigned __int8 *)(v30 - 1);
        --v25;
        uint64_t v21 = v27 - 1;
        v24 -= 0x100000000;
      }
      while (*(unsigned __int8 *)(v29 - 1) == v32);
      unint64_t v33 = v11 + 1;
      if (v22 + (int)v27 < 15)
      {
        *int32x4_t v11 = 16 * (v29 - v10);
      }
      else
      {
        *int32x4_t v11 = -16;
        if ((v22 + v27) <= 0x10D)
        {
          char v36 = v27 + v14 - v10 - 15;
        }
        else
        {
          if (v26 >= 509) {
            int v34 = 509;
          }
          else {
            int v34 = v26;
          }
          unsigned int v35 = v22 - v34 + v27 + 239;
          char v56 = v23;
          memset(v33, 255, v35 / 0xFF + 1);
          unint64_t v8 = v61;
          unint64_t v33 = &v11[v35 / 0xFFuLL + 2];
          char v36 = v35 / 0xFF + v56 + v27;
        }
        *(unsigned char *)unint64_t v33 = v36;
        unint64_t v33 = (void *)((char *)v33 + 1);
      }
      int v37 = (_DWORD *)(v7 + v19 + v27);
      char v38 = (_WORD *)((char *)v33 + (v28 >> 32));
      do
      {
        uint64_t v39 = *(void *)v10;
        v10 += 8;
        *v33++ = v39;
      }
      while (v33 < (void *)v38);
      while (1)
      {
        unsigned int v40 = v11;
        *char v38 = v29 - (_WORD)v37;
        int32x4_t v11 = v38 + 1;
        int v41 = v29 + 4;
        BOOL v42 = v37 + 1;
        unint64_t v10 = v29 + 4;
        if (v29 + 4 >= v12)
        {
LABEL_36:
          if (v10 < (unint64_t)(v58 - 8) && *v42 == *(_DWORD *)v10)
          {
            v10 += 4;
            ++v42;
          }
          if (v10 < (unint64_t)(v58 - 6) && *(unsigned __int16 *)v42 == *(unsigned __int16 *)v10)
          {
            v10 += 2;
            BOOL v42 = (_DWORD *)((char *)v42 + 2);
          }
          if (v10 < (unint64_t)(v58 - 5) && *(unsigned __int8 *)v42 == *(unsigned __int8 *)v10) {
            ++v10;
          }
        }
        else
        {
          while (1)
          {
            unint64_t v43 = *(void *)v10 ^ *(void *)v42;
            if (v43) {
              break;
            }
            v10 += 8;
            v42 += 2;
            if (v10 >= v12) {
              goto LABEL_36;
            }
          }
          v10 += __clz(__rbit64(v43)) >> 3;
        }
        char v44 = v10 - v41;
        BOOL v45 = __OFSUB__(v10 - v41, 15);
        unsigned int v46 = v10 - v41 - 15;
        if (((v46 & 0x80000000) != 0) != v45)
        {
          *v40 += v44;
        }
        else
        {
          *v40 += 15;
          if (v46 >= 0x1FE)
          {
            unsigned int v47 = v10 - v29 - 529;
            uint64_t v48 = v47 / 0x1FE;
            memset(v38 + 1, 255, v48 * 2 + 2);
            unint64_t v8 = v61;
            unsigned int v46 = v47 % 0x1FE;
            int32x4_t v11 = &v38[v48 + 2];
          }
          if (v46 >= 0xFF)
          {
            *v11++ = -1;
            LOBYTE(v46) = v46 + 1;
          }
          *v11++ = v46;
        }
        if (v10 > v12) {
          break;
        }
        *(_DWORD *)(a1 + 4 * ((-1640531535 * *(_DWORD *)(v10 - 2)) >> 20)) = v10 - 2 - v7;
        unsigned int v49 = (-1640531535 * *(_DWORD *)v10) >> 20;
        int v37 = (_DWORD *)(v7 + *(unsigned int *)(a1 + 4 * v49));
        *(_DWORD *)(a1 + 4 * v49) = v10 - v7;
        if ((unint64_t)v37 + 0xFFFF < v10 || *v37 != *(_DWORD *)v10)
        {
          uint64x2_t v13 = (_DWORD *)(v10 + 2);
          if (v10 + 2 <= v12) {
            goto LABEL_8;
          }
          break;
        }
        *int32x4_t v11 = 0;
        char v38 = v11 + 1;
        unint64_t v29 = v10;
      }
LABEL_58:
      LODWORD(a3) = v59;
    }
    a4 = v57;
    unint64_t v9 = v58;
  }
  size_t v50 = (size_t)&v9[-v10];
  BOOL v45 = __OFSUB__(v9 - v10, 15);
  int v51 = v9 - v10 - 15;
  if (v51 < 0 != v45)
  {
    *int32x4_t v11 = 16 * v50;
  }
  else
  {
    *int32x4_t v11 = -16;
    uint64_t v52 = v11 + 1;
    if (v50 >= 0x10E)
    {
      int v53 = v60 + a4;
      if (v51 >= 509) {
        int v51 = 509;
      }
      unint64_t v54 = (v53 - (v51 + v10) + 239) / 0xFFuLL;
      memset(v52, 255, v54 + 1);
      LOBYTE(v51) = v53 - v10 + v54 - 14;
      uint64_t v52 = &v11[v54 + 2];
    }
    *uint64_t v52 = v51;
    int32x4_t v11 = v52;
  }
  size_t v55 = v11 + 1;
  memcpy(v55, (const void *)v10, v50);
  return (v55 + v50 - a3);
}

uint64_t LZ4_compress_limitedOutput_continue(uint64_t a1, char *__src, unsigned char *a3, unsigned int a4, unsigned int a5)
{
  if (a4 > 0x7E000000) {
    return 0;
  }
  if (*(char **)(a1 + 16400) != __src) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 16392);
  unint64_t v9 = *(void *)(a1 + 0x4000);
  unint64_t v10 = &__src[a4];
  *(void *)(a1 + 16400) = v10;
  unint64_t v11 = (unint64_t)__src;
  unint64_t v12 = a3;
  if (a4 >= 0xD)
  {
    unsigned int v64 = a4;
    unsigned int v65 = a5;
    unsigned int v66 = a3;
    *(_DWORD *)(a1 + 4 * ((-1640531535 * *(_DWORD *)__src) >> 20)) = __src - v8;
    if (a4 != 13)
    {
      unint64_t v13 = (unint64_t)(v10 - 12);
      unint64_t v14 = __src + 2;
      int v60 = v10 - 8;
      unint64_t v61 = v10 - 5;
      unint64_t v62 = &__src[a4];
      int v63 = (int)__src;
      int v59 = v10 - 6;
      unint64_t v12 = a3;
      unint64_t v11 = (unint64_t)__src;
      unint64_t v15 = (unint64_t)&a3[a5];
      unint64_t v67 = v15;
      unint64_t v68 = v9;
LABEL_7:
      unint64_t v16 = v11 + 1;
      int v17 = *(_DWORD *)(v11 + 1);
      unsigned int v18 = 68;
      while (1)
      {
        uint64_t v19 = v14;
        unsigned int v20 = (-1640531535 * v17) >> 20;
        int v17 = *v14;
        uint64_t v21 = *(unsigned int *)(a1 + 4 * v20);
        *(_DWORD *)(a1 + 4 * v20) = v16 - v8;
        if (v8 + v21 + 0xFFFF >= v16 && *(_DWORD *)(v8 + v21) == *(_DWORD *)v16) {
          break;
        }
        uint64_t v22 = v18++ >> 6;
        unint64_t v14 = (_DWORD *)((char *)v14 + v22);
        unint64_t v16 = (unint64_t)v19;
        if ((unint64_t)v14 > v13)
        {
LABEL_59:
          a3 = v66;
          a4 = v64;
          a5 = v65;
          unint64_t v10 = v62;
          LODWORD(__src) = v63;
          goto LABEL_60;
        }
      }
      uint64_t v23 = 0;
      int v24 = v16 - v11;
      char v25 = v16 - v11 - 15;
      char v26 = v16 - v11 - 14;
      uint64_t v27 = (v16 << 32) - (v11 << 32);
      int v28 = v16 - v11 - 15;
      do
      {
        int v29 = v28;
        uint64_t v30 = v23;
        uint64_t v31 = v27;
        unint64_t v32 = v16 + v23;
        unint64_t v33 = v8 + v21 + v23;
        if (v32 <= v11 || v33 <= v9) {
          break;
        }
        int v35 = *(unsigned __int8 *)(v33 - 1);
        --v28;
        uint64_t v23 = v30 - 1;
        v27 -= 0x100000000;
      }
      while (*(unsigned __int8 *)(v32 - 1) == v35);
      int v36 = v24 + v30;
      int v37 = v12 + 1;
      if ((unint64_t)&v12[(v31 >> 32) + 9 + (v24 + (int)v30) / 255] <= v15)
      {
        if (v36 < 15)
        {
          *unint64_t v12 = 16 * (v32 - v11);
        }
        else
        {
          *unint64_t v12 = -16;
          if (v36 <= 0x10D)
          {
            char v40 = v30 + v25;
          }
          else
          {
            if (v29 >= 509) {
              int v38 = 509;
            }
            else {
              int v38 = v29;
            }
            unsigned int v39 = v24 - v38 + v30 + 239;
            char v58 = v26;
            memset(v37, 255, v39 / 0xFF + 1);
            unint64_t v15 = v67;
            unint64_t v9 = v68;
            int v37 = &v12[v39 / 0xFFuLL + 2];
            char v40 = v39 / 0xFF + v58 + v30;
          }
          *(unsigned char *)int v37 = v40;
          int v37 = (void *)((char *)v37 + 1);
        }
        int v41 = (_DWORD *)(v8 + v21 + v30);
        BOOL v42 = (_WORD *)((char *)v37 + (v31 >> 32));
        do
        {
          uint64_t v43 = *(void *)v11;
          v11 += 8;
          *v37++ = v43;
        }
        while (v37 < (void *)v42);
        while (1)
        {
          char v44 = v12;
          _WORD *v42 = v32 - (_WORD)v41;
          unint64_t v12 = v42 + 1;
          int v45 = v32 + 4;
          unsigned int v46 = v41 + 1;
          unint64_t v11 = v32 + 4;
          if (v32 + 4 >= v13)
          {
LABEL_36:
            if (v11 < (unint64_t)v60 && *v46 == *(_DWORD *)v11)
            {
              v11 += 4;
              ++v46;
            }
            if (v11 < (unint64_t)v59 && *(unsigned __int16 *)v46 == *(unsigned __int16 *)v11)
            {
              v11 += 2;
              unsigned int v46 = (_DWORD *)((char *)v46 + 2);
            }
            if (v11 < (unint64_t)v61 && *(unsigned __int8 *)v46 == *(unsigned __int8 *)v11) {
              ++v11;
            }
          }
          else
          {
            while (1)
            {
              unint64_t v47 = *(void *)v11 ^ *(void *)v46;
              if (v47) {
                break;
              }
              v11 += 8;
              v46 += 2;
              if (v11 >= v13) {
                goto LABEL_36;
              }
            }
            v11 += __clz(__rbit64(v47)) >> 3;
          }
          int v48 = v11 - v45;
          if ((unint64_t)v42 + (((int)v11 - v45) >> 8) + 8 > v15) {
            break;
          }
          unsigned int v49 = v48 - 15;
          if (v48 < 15)
          {
            *v44 += v48;
          }
          else
          {
            *v44 += 15;
            if (v49 >= 0x1FE)
            {
              unsigned int v50 = v11 - v32 - 529;
              uint64_t v51 = v50 / 0x1FE;
              memset(v42 + 1, 255, v51 * 2 + 2);
              unint64_t v15 = v67;
              unint64_t v9 = v68;
              unsigned int v49 = v50 % 0x1FE;
              unint64_t v12 = &v42[v51 + 2];
            }
            if (v49 >= 0xFF)
            {
              *v12++ = -1;
              LOBYTE(v49) = v49 + 1;
            }
            *v12++ = v49;
          }
          if (v11 > v13) {
            goto LABEL_59;
          }
          *(_DWORD *)(a1 + 4 * ((-1640531535 * *(_DWORD *)(v11 - 2)) >> 20)) = v11 - 2 - v8;
          unsigned int v52 = (-1640531535 * *(_DWORD *)v11) >> 20;
          int v41 = (_DWORD *)(v8 + *(unsigned int *)(a1 + 4 * v52));
          *(_DWORD *)(a1 + 4 * v52) = v11 - v8;
          if ((unint64_t)v41 + 0xFFFF < v11 || *v41 != *(_DWORD *)v11)
          {
            unint64_t v14 = (_DWORD *)(v11 + 2);
            if (v11 + 2 <= v13) {
              goto LABEL_7;
            }
            goto LABEL_59;
          }
          *unint64_t v12 = 0;
          BOOL v42 = v12 + 1;
          unint64_t v32 = v11;
        }
      }
      return 0;
    }
    unint64_t v11 = (unint64_t)__src;
    unint64_t v12 = a3;
    a4 = 13;
  }
LABEL_60:
  size_t v53 = (size_t)&v10[-v11];
  if ((uint64_t)(v12 - a3 + (int)v10 - (int)v11 + (v10 - v11 + 240) / 0xFFuLL + 1) > a5) {
    return 0;
  }
  int v54 = v53 - 15;
  if ((int)v53 < 15)
  {
    *unint64_t v12 = 16 * v53;
  }
  else
  {
    *unint64_t v12 = -16;
    size_t v55 = v12 + 1;
    if (v53 >= 0x10E)
    {
      unsigned int v56 = __src + a4;
      if (v54 >= 509) {
        int v54 = 509;
      }
      unint64_t v57 = (v56 - (v54 + v11) + 239) / 0xFFuLL;
      memset(v55, 255, v57 + 1);
      LOBYTE(v54) = v56 - v11 + v57 - 14;
      size_t v55 = &v12[v57 + 2];
    }
    unsigned char *v55 = v54;
    unint64_t v12 = v55;
  }
  memcpy(v12 + 1, (const void *)v11, v53);
  return (v12 + 1 + v53 - a3);
}

uint64_t LZ4_decompress_safe(unsigned __int8 *a1, char *__dst, int a3, int a4)
{
  if (a4)
  {
    uint64_t v5 = &a1[a3];
    unint64_t v6 = &__dst[a4];
    uint64_t v7 = v6 - 12;
    uint64_t v8 = __dst;
    unint64_t v9 = a1;
    while (1)
    {
      unsigned int v11 = *v9++;
      char v10 = v11;
      size_t v12 = (unint64_t)v11 >> 4;
      if (v12 == 15)
      {
        size_t v12 = 15;
        if (v9 < v5)
        {
          do
          {
            unsigned int v14 = *v9++;
            unsigned int v13 = v14;
            v12 += v14;
          }
          while (v9 < v5 && v13 == 255);
        }
      }
      unint64_t v15 = &v8[v12];
      unint64_t v16 = (unint64_t)&v9[v12];
      if (&v8[v12] > v7 || v16 > (unint64_t)(v5 - 8)) {
        break;
      }
      do
      {
        uint64_t v18 = *(void *)v9;
        v9 += 8;
        *(void *)uint64_t v8 = v18;
        v8 += 8;
        v12 -= 8;
      }
      while (v8 < v15);
      uint64_t v19 = &v9[v12];
      int v20 = *(unsigned __int16 *)v19;
      unint64_t v9 = v19 + 2;
      uint64_t v21 = &v15[-v20];
      if (v21 < __dst) {
        return (~v9 + a1);
      }
      uint64_t v22 = v10 & 0xF;
      if ((v10 & 0xF) == 0xF)
      {
        uint64_t v22 = 15;
        do
        {
          if (v9 >= v5 - 6) {
            break;
          }
          unsigned int v23 = *v9++;
          v22 += v23;
        }
        while (v23 == 255);
      }
      int64_t v24 = v15 - v21;
      if (v15 - v21 <= 7)
      {
        uint64_t v29 = LZ4_decompress_generic_dec64table[v24];
        char *v15 = *v21;
        v15[1] = v21[1];
        v15[2] = v21[2];
        v15[3] = v21[3];
        uint64_t v30 = &v21[qword_1E458F1A0[v24]];
        *((_DWORD *)v15 + 1) = *(_DWORD *)v30;
        char v25 = &v30[-v29];
      }
      else
      {
        uint64_t v26 = *(void *)v21;
        char v25 = v21 + 8;
        *(void *)unint64_t v15 = v26;
      }
      uint64_t v27 = v15 + 8;
      uint64_t v8 = &v15[v22 + 4];
      if (v8 > v7)
      {
        if (v8 > v6 - 5) {
          return (~v9 + a1);
        }
        while (v27 < (void *)v6 - 1)
        {
          uint64_t v31 = *(void *)v25;
          v25 += 8;
          *v27++ = v31;
        }
        while (v27 < (void *)v8)
        {
          char v32 = *v25++;
          *(unsigned char *)uint64_t v27 = v32;
          uint64_t v27 = (void *)((char *)v27 + 1);
        }
      }
      else
      {
        do
        {
          uint64_t v28 = *(void *)v25;
          v25 += 8;
          *v27++ = v28;
        }
        while (v27 < (void *)v8);
      }
    }
    if ((unsigned __int8 *)v16 == v5 && v15 <= v6)
    {
      memcpy(v8, v9, v12);
      return (v15 - __dst);
    }
    return (~v9 + a1);
  }
  else if (a3 == 1)
  {
    if (*a1) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

uint64_t LZ4_decompress_safe_withPrefix64k(unsigned __int8 *a1, char *__dst, int a3, int a4)
{
  if (a4)
  {
    int v4 = (int)__dst;
    uint64_t v5 = &a1[a3];
    unint64_t v6 = &__dst[a4];
    uint64_t v7 = v6 - 12;
    uint64_t v8 = __dst;
    unint64_t v9 = a1;
    while (1)
    {
      unsigned int v11 = *v9++;
      char v10 = v11;
      size_t v12 = (unint64_t)v11 >> 4;
      if (v12 == 15)
      {
        size_t v12 = 15;
        if (v9 < v5)
        {
          do
          {
            unsigned int v14 = *v9++;
            unsigned int v13 = v14;
            v12 += v14;
          }
          while (v9 < v5 && v13 == 255);
        }
      }
      unint64_t v15 = &v8[v12];
      unint64_t v16 = (unint64_t)&v9[v12];
      if (&v8[v12] > v7 || v16 > (unint64_t)(v5 - 8)) {
        break;
      }
      do
      {
        uint64_t v18 = *(void *)v9;
        v9 += 8;
        *(void *)uint64_t v8 = v18;
        v8 += 8;
        v12 -= 8;
      }
      while (v8 < v15);
      uint64_t v19 = &v9[v12];
      unsigned int v21 = *(unsigned __int16 *)v19;
      unint64_t v9 = v19 + 2;
      uint64_t v20 = v21;
      uint64_t v22 = v10 & 0xF;
      if ((v10 & 0xF) == 0xF)
      {
        uint64_t v22 = 15;
        do
        {
          if (v9 >= v5 - 6) {
            break;
          }
          unsigned int v23 = *v9++;
          v22 += v23;
        }
        while (v23 == 255);
      }
      int64_t v24 = &v15[-v20];
      int64_t v25 = v15 - v24;
      if (v15 - v24 <= 7)
      {
        uint64_t v30 = LZ4_decompress_generic_dec64table[v25];
        char *v15 = *v24;
        v15[1] = v24[1];
        v15[2] = v24[2];
        v15[3] = v24[3];
        uint64_t v31 = &v24[qword_1E458F1A0[v25]];
        *((_DWORD *)v15 + 1) = *(_DWORD *)v31;
        uint64_t v26 = &v31[-v30];
      }
      else
      {
        uint64_t v27 = *(void *)v24;
        uint64_t v26 = v24 + 8;
        *(void *)unint64_t v15 = v27;
      }
      uint64_t v28 = v15 + 8;
      uint64_t v8 = &v15[v22 + 4];
      if (v8 > v7)
      {
        if (v8 > v6 - 5) {
          return (~v9 + a1);
        }
        while (v28 < (void *)v6 - 1)
        {
          uint64_t v32 = *(void *)v26;
          v26 += 8;
          *v28++ = v32;
        }
        while (v28 < (void *)v8)
        {
          char v33 = *v26++;
          *(unsigned char *)uint64_t v28 = v33;
          uint64_t v28 = (void *)((char *)v28 + 1);
        }
      }
      else
      {
        do
        {
          uint64_t v29 = *(void *)v26;
          v26 += 8;
          *v28++ = v29;
        }
        while (v28 < (void *)v8);
      }
    }
    if ((unsigned __int8 *)v16 == v5 && v15 <= v6)
    {
      memcpy(v8, v9, v12);
      return (v15 - v4);
    }
    return (~v9 + a1);
  }
  else if (a3 == 1)
  {
    if (*a1) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

uint64_t LZ4_decompress_safe_partial(unsigned __int8 *a1, char *__dst, int a3, int a4, int a5)
{
  uint64_t v5 = &__dst[a5];
  if (&__dst[a4] <= v5 - 12) {
    unint64_t v6 = &__dst[a4];
  }
  else {
    unint64_t v6 = v5 - 12;
  }
  if (a5)
  {
    uint64_t v8 = &a1[a3];
    unint64_t v9 = __dst;
    char v10 = a1;
    while (1)
    {
      unsigned int v12 = *v10++;
      char v11 = v12;
      size_t v13 = (unint64_t)v12 >> 4;
      if (v13 == 15)
      {
        size_t v13 = 15;
        if (v10 < v8)
        {
          do
          {
            unsigned int v15 = *v10++;
            unsigned int v14 = v15;
            v13 += v15;
          }
          while (v10 < v8 && v14 == 255);
        }
      }
      unint64_t v16 = &v9[v13];
      unint64_t v17 = (unint64_t)&v10[v13];
      if (&v9[v13] > v6 || v17 > (unint64_t)(v8 - 8)) {
        break;
      }
      do
      {
        uint64_t v19 = *(void *)v10;
        v10 += 8;
        *(void *)unint64_t v9 = v19;
        v9 += 8;
        v13 -= 8;
      }
      while (v9 < v16);
      uint64_t v20 = &v10[v13];
      int v21 = *(unsigned __int16 *)v20;
      char v10 = v20 + 2;
      uint64_t v22 = &v16[-v21];
      if (v22 < __dst) {
        return (~v10 + a1);
      }
      uint64_t v23 = v11 & 0xF;
      if ((v11 & 0xF) == 0xF)
      {
        uint64_t v23 = 15;
        do
        {
          if (v10 >= v8 - 6) {
            break;
          }
          unsigned int v24 = *v10++;
          v23 += v24;
        }
        while (v24 == 255);
      }
      int64_t v25 = v16 - v22;
      if (v16 - v22 <= 7)
      {
        uint64_t v30 = LZ4_decompress_generic_dec64table[v25];
        char *v16 = *v22;
        v16[1] = v22[1];
        v16[2] = v22[2];
        v16[3] = v22[3];
        uint64_t v31 = &v22[qword_1E458F1A0[v25]];
        *((_DWORD *)v16 + 1) = *(_DWORD *)v31;
        uint64_t v26 = &v31[-v30];
      }
      else
      {
        uint64_t v27 = *(void *)v22;
        uint64_t v26 = v22 + 8;
        *(void *)unint64_t v16 = v27;
      }
      uint64_t v28 = v16 + 8;
      unint64_t v9 = &v16[v23 + 4];
      if (v9 > v5 - 12)
      {
        if (v9 > v5 - 5) {
          return (~v10 + a1);
        }
        while (v28 < (void *)v5 - 1)
        {
          uint64_t v32 = *(void *)v26;
          v26 += 8;
          *v28++ = v32;
        }
        while (v28 < (void *)v9)
        {
          char v33 = *v26++;
          *(unsigned char *)uint64_t v28 = v33;
          uint64_t v28 = (void *)((char *)v28 + 1);
        }
      }
      else
      {
        do
        {
          uint64_t v29 = *(void *)v26;
          v26 += 8;
          *v28++ = v29;
        }
        while (v28 < (void *)v9);
      }
    }
    if (v16 <= v5 && v17 <= (unint64_t)v8)
    {
      memcpy(v9, v10, v13);
      return (v16 - __dst);
    }
    return (~v10 + a1);
  }
  else if (a3 == 1)
  {
    if (*a1) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

uint64_t LZ4_decompress_fast_withPrefix64k(unsigned __int8 *__src, char *__dst, int a3)
{
  int v3 = (int)__src;
  if (a3)
  {
    int v4 = &__dst[a3];
    uint64_t v5 = v4 - 8;
    unint64_t v6 = __src;
    while (1)
    {
      unsigned int v8 = *v6++;
      char v7 = v8;
      size_t v9 = (unint64_t)v8 >> 4;
      if (v9 == 15)
      {
        size_t v9 = 15;
        do
        {
          unsigned int v10 = *v6++;
          v9 += v10;
        }
        while (v10 == 255);
      }
      char v11 = &__dst[v9];
      if (&__dst[v9] > v5) {
        break;
      }
      do
      {
        uint64_t v12 = *(void *)v6;
        v6 += 8;
        *(void *)__dst = v12;
        __dst += 8;
        v9 -= 8;
      }
      while (__dst < v11);
      size_t v13 = &v6[v9];
      unsigned int v15 = *(unsigned __int16 *)v13;
      unint64_t v6 = v13 + 2;
      uint64_t v14 = v15;
      uint64_t v16 = v7 & 0xF;
      if ((v7 & 0xF) == 0xF)
      {
        uint64_t v16 = 15;
        do
        {
          unsigned int v17 = *v6++;
          v16 += v17;
        }
        while (v17 == 255);
      }
      uint64_t v18 = &v11[-v14];
      if (v14 <= 7)
      {
        uint64_t v23 = LZ4_decompress_generic_dec64table[v14];
        *char v11 = *v18;
        v11[1] = v18[1];
        v11[2] = v18[2];
        v11[3] = v18[3];
        unsigned int v24 = &v18[qword_1E458F1A0[v14]];
        *((_DWORD *)v11 + 1) = *(_DWORD *)v24;
        uint64_t v19 = &v24[-v23];
      }
      else
      {
        uint64_t v20 = *(void *)v18;
        uint64_t v19 = v18 + 8;
        *(void *)char v11 = v20;
      }
      int v21 = v11 + 8;
      __dst = (char *)v21 + v16 - 4;
      if (__dst > v4 - 12)
      {
        if (__dst > v4 - 5) {
          return (~v6 + v3);
        }
        while (v21 < (void *)v5)
        {
          uint64_t v25 = *(void *)v19;
          v19 += 8;
          *v21++ = v25;
        }
        while (v21 < (void *)__dst)
        {
          char v26 = *v19++;
          *(unsigned char *)int v21 = v26;
          int v21 = (void *)((char *)v21 + 1);
        }
      }
      else
      {
        do
        {
          uint64_t v22 = *(void *)v19;
          v19 += 8;
          *v21++ = v22;
        }
        while (v21 < (void *)__dst);
      }
    }
    if (v11 != v4) {
      return (~v6 + v3);
    }
    memcpy(__dst, v6, v9);
    return (v6 + v9 - v3);
  }
  else if (*__src)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 1;
  }
}

uint64_t LZ4_decompress_fast(unsigned __int8 *__src, char *__dst, int a3)
{
  int v3 = (int)__src;
  if (a3)
  {
    int v4 = &__dst[a3];
    uint64_t v5 = v4 - 8;
    unint64_t v6 = __src;
    while (1)
    {
      unsigned int v8 = *v6++;
      char v7 = v8;
      size_t v9 = (unint64_t)v8 >> 4;
      if (v9 == 15)
      {
        size_t v9 = 15;
        do
        {
          unsigned int v10 = *v6++;
          v9 += v10;
        }
        while (v10 == 255);
      }
      char v11 = &__dst[v9];
      if (&__dst[v9] > v5) {
        break;
      }
      do
      {
        uint64_t v12 = *(void *)v6;
        v6 += 8;
        *(void *)__dst = v12;
        __dst += 8;
        v9 -= 8;
      }
      while (__dst < v11);
      size_t v13 = &v6[v9];
      unsigned int v15 = *(unsigned __int16 *)v13;
      unint64_t v6 = v13 + 2;
      uint64_t v14 = v15;
      uint64_t v16 = v7 & 0xF;
      if ((v7 & 0xF) == 0xF)
      {
        uint64_t v16 = 15;
        do
        {
          unsigned int v17 = *v6++;
          v16 += v17;
        }
        while (v17 == 255);
      }
      uint64_t v18 = &v11[-v14];
      if (v14 <= 7)
      {
        uint64_t v23 = LZ4_decompress_generic_dec64table[v14];
        *char v11 = *v18;
        v11[1] = v18[1];
        v11[2] = v18[2];
        v11[3] = v18[3];
        unsigned int v24 = &v18[qword_1E458F1A0[v14]];
        *((_DWORD *)v11 + 1) = *(_DWORD *)v24;
        uint64_t v19 = &v24[-v23];
      }
      else
      {
        uint64_t v20 = *(void *)v18;
        uint64_t v19 = v18 + 8;
        *(void *)char v11 = v20;
      }
      int v21 = v11 + 8;
      __dst = (char *)v21 + v16 - 4;
      if (__dst > v4 - 12)
      {
        if (__dst > v4 - 5) {
          return (~v6 + v3);
        }
        while (v21 < (void *)v5)
        {
          uint64_t v25 = *(void *)v19;
          v19 += 8;
          *v21++ = v25;
        }
        while (v21 < (void *)__dst)
        {
          char v26 = *v19++;
          *(unsigned char *)int v21 = v26;
          int v21 = (void *)((char *)v21 + 1);
        }
      }
      else
      {
        do
        {
          uint64_t v22 = *(void *)v19;
          v19 += 8;
          *v21++ = v22;
        }
        while (v21 < (void *)__dst);
      }
    }
    if (v11 != v4) {
      return (~v6 + v3);
    }
    memcpy(__dst, v6, v9);
    return (v6 + v9 - v3);
  }
  else if (*__src)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 1;
  }
}

uint64_t lz4_decode_safe(void **a1, unint64_t a2, char *a3, unint64_t *a4, unint64_t a5)
{
  unint64_t v6 = (char *)*a1;
  char v7 = (unsigned __int8 *)*a4;
  uint64_t v30 = *a1;
  if (*a4 >= a5)
  {
    uint64_t v20 = (char *)*a1;
    return v20 - v30;
  }
  else
  {
    while (1)
    {
      *a4 = (unint64_t)v7;
      *a1 = v6;
      unsigned int v14 = *v7;
      uint64_t v12 = v7 + 1;
      char v13 = v14;
      size_t v15 = (unint64_t)v14 >> 4;
      if (v15 == 15)
      {
        size_t v15 = 15;
        while ((unint64_t)v12 < a5)
        {
          unsigned int v22 = *v12++;
          v15 += v22;
          if (v22 != 255) {
            goto LABEL_3;
          }
        }
        return 0;
      }
LABEL_3:
      uint64_t v16 = &v12[v15];
      if ((unint64_t)&v12[v15] > a5) {
        return 0;
      }
      unsigned int v17 = &v6[v15];
      if (&v6[v15] > a3) {
        break;
      }
      memcpy(v6, v12, v15);
      if ((unint64_t)v16 >= a5)
      {
        uint64_t v20 = &v6[v15];
        return v20 - v30;
      }
      char v7 = v16 + 2;
      if ((unint64_t)(v16 + 2) > a5) {
        return 0;
      }
      uint64_t v18 = *(unsigned __int16 *)v16;
      if (!*(_WORD *)v16 || (unint64_t)&v17[-v18] < a2) {
        return 0;
      }
      uint64_t v19 = (v13 & 0xF) + 4;
      if ((v13 & 0xF) == 0xF)
      {
        uint64_t v19 = 19;
        while ((unint64_t)v7 < a5)
        {
          unsigned int v23 = *v7++;
          v19 += v23;
          if (v23 != 255) {
            goto LABEL_10;
          }
        }
        return 0;
      }
LABEL_10:
      uint64_t v20 = &v17[v19];
      if (&v17[v19] > a3)
      {
        if (a3 != v17)
        {
          if ((unint64_t)(a3 - v17) <= 1) {
            uint64_t v27 = 1;
          }
          else {
            uint64_t v27 = a3 - v17;
          }
          uint64_t v28 = &v6[v15];
          uint64_t v29 = -v18;
          do
          {
            *uint64_t v28 = v28[v29];
            ++v28;
            --v27;
          }
          while (v27);
        }
        char v26 = a3;
        return v26 - v30;
      }
      if (v19)
      {
        uint64_t v21 = -v18;
        do
        {
          char *v17 = v17[v21];
          ++v17;
          --v19;
        }
        while (v19);
      }
      unint64_t v6 = v20;
      if ((unint64_t)v7 >= a5) {
        return v20 - v30;
      }
    }
    size_t v25 = a3 - v6;
    if (v25) {
      memcpy(v6, v12, v25);
    }
    char v26 = &v6[v25];
    return v26 - v30;
  }
}

uint64_t APPLIB_API_SUBSYS_SendCommand(void *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  bzero(a1, a2);
  if (!HDLCFrameCreateUplink()) {
    return 0xFFFFFFFFLL;
  }
  if ((HDLCFrameInject() & 1) == 0 || a6 && (HDLCFrameInject() & 1) == 0)
  {
    HDLCFrameFree();
    return 0xFFFFFFFFLL;
  }
  unsigned int v7 = HDLCFrameEncode();
  HDLCFrameFree();
  if (v7) {
    return v7;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t APPLIB_API_SUBSYS_ParseHeader(uint64_t a1, unsigned int a2, int a3, _WORD *a4, _DWORD *a5)
{
  if (a2 < 4) {
    return 0;
  }
  if (*(unsigned char *)a1 != 75 || *(unsigned __int8 *)(a1 + 1) != a3) {
    return 0;
  }
  *a4 = *(_WORD *)(a1 + 2);
  *a5 = 4;
  return 1;
}

BOOL APPLIB_API_SUBSYS_ParseGetAntennaConfigResp(uint64_t a1, _DWORD *a2)
{
  int v2 = *(unsigned __int16 *)(a1 + 4);
  if (v2 == 1) {
    *a2 = *(unsigned __int16 *)(a1 + 6);
  }
  return v2 == 1;
}

uint64_t APPLIB_API_SUBSYS_ParseGetRSSIResp(uint64_t a1, int a2, float *a3)
{
  if (a2 > 1 || *(_WORD *)(a1 + 4) != 1) {
    return 0;
  }
  *a3 = (float)(__int16)~*(_WORD *)(a1 + 2 * a2 + 12) * -0.1;
  return 1;
}

uint64_t ETLBBCreateDeassertResetDetectCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLBBParseDeassertResetDetectResponse(unsigned int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((_DWORD *)a1 + 2) < 4u)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    unsigned int v8 = **a1;
    if (v8 == 75)
    {
      if (BYTE1(v8) == 253)
      {
        uint64_t v9 = HIWORD(v8);
        if (v9 == 7)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v9);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v8));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLBBCreatePingCommand()
{
  return HDLCFrameInjectUnsignedChar();
}

BOOL ETLBBParsePingResponse(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = *a2;
  BOOL result = *(_DWORD *)(a1 + 8) != v2 && *(unsigned __int8 *)(*(void *)a1 + v2) == 123;
  *a2 = v2 + 1;
  return result;
}

void *ETLBBEchoParametersInit(void *result)
{
  *BOOL result = 0;
  result[1] = 0;
  return result;
}

uint64_t ETLBBCreateEchoCommand(uint64_t a1, uint64_t a2)
{
  uint64_t result = HDLCFrameInjectUnsignedChar();
  if (result)
  {
    uint64_t v4 = *(unsigned int *)(a2 + 8);
    if (HDLCFrameGetFreeSpace() >= v4)
    {
      if (*(_DWORD *)(a2 + 8))
      {
        return HDLCFrameInject();
      }
      else
      {
        return 1;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v5, v6, v7, v8, v9, v10, v4);
      return 0;
    }
  }
  return result;
}

uint64_t ETLBBParseEchoResponse(uint64_t a1, uint64_t a2, BOOL *a3)
{
  *a3 = 0;
  int v3 = *(_DWORD *)(a1 + 8);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(unsigned char **)a1;
  if (**(unsigned char **)a1 != 123) {
    return 0;
  }
  size_t v6 = (v3 - 1);
  int v7 = *(_DWORD *)(a2 + 8);
  *a3 = v6 == v7;
  if (v7)
  {
    BOOL v8 = v6 == v7 && memcmp(v4 + 1, *(const void **)a2, v6) == 0;
    *a3 = v8;
  }
  return 1;
}

uint64_t ETLBBCreateSimulateCrashCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLBBCreateSimulateCrashCommandExt(uint64_t a1, uint64_t a2)
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v4, v5, v6, v7, v8, v9, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (a2)
    {
      return HDLCFrameInject();
    }
    else
    {
      return 1;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v10, v11, v12, v13, v14, v15, v17);
    return 0;
  }
}

uint64_t ETLBBParseSimulateCrashResponse(unsigned int *a1)
{
  capabilities::etl::supportsBBAppsCrash((capabilities::etl *)a1);
  if (a1[2] < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v2, v3, v4, v5, v6, v7, a1[2]);
    return 0;
  }
  else if (**(unsigned char **)a1 == 75)
  {
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v2, v3, v4, v5, v6, v7, **(unsigned __int8 **)a1);
    return 0;
  }
}

uint64_t ETLBBPing(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void))
{
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLBBPing", (uint64_t)"Failed to create command frame\n", v2, v3, v4, v5, v6, v7, 0);
LABEL_10:
    uint64_t v14 = 0;
    goto LABEL_11;
  }
  if (!HDLCFrameInjectUnsignedChar()) {
    goto LABEL_10;
  }
  uint64_t v8 = malloc(0x20uLL);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = v8;
  uint64_t v10 = HDLCFrameEncode();
  if (v10)
  {
    uint64_t v11 = v10;
    int v12 = -1431655766;
    int v16 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v9, v10);
    }
    if (*a1)
    {
      unsigned int v13 = (*a1)(a1, v9, v11, &v16, 1, 1000, 0);
      int v12 = v16;
    }
    else
    {
      unsigned int v13 = 0;
    }
    if (v12 == v11) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 0;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  free(v9);
LABEL_11:
  HDLCFrameFree();
  return v14;
}

BOOL ETLBBPingCheckResponse(uint64_t a1, unsigned int a2)
{
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  char v7 = 123;
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  int v4 = ETLFindMatchingResponseUsingBuffer(a1, (unsigned __int8 **)v8, (uint64_t)&_ETLResponseRingBuffer, &v7, a2);
  BOOL v5 = 0;
  if (v4 && DWORD2(v8[0])) {
    BOOL v5 = **(unsigned char **)&v8[0] == 123;
  }
  HDLCFrameFree();
  return v5;
}

uint64_t ETLBBSendEcho(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2)
{
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLBBSendEcho", (uint64_t)"Failed to create command frame\n", v4, v5, v6, v7, v8, v9, v25);
    goto LABEL_6;
  }
  if (!HDLCFrameInjectUnsignedChar())
  {
LABEL_6:
    uint64_t v17 = 0;
    goto LABEL_7;
  }
  uint64_t v10 = *(unsigned int *)(a2 + 8);
  if (HDLCFrameGetFreeSpace() < v10)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v11, v12, v13, v14, v15, v16, v10);
    goto LABEL_6;
  }
  if (*(_DWORD *)(a2 + 8) && !HDLCFrameInject()) {
    goto LABEL_6;
  }
  uint64_t v19 = malloc(0x20uLL);
  if (!v19) {
    goto LABEL_6;
  }
  uint64_t v20 = v19;
  uint64_t v21 = HDLCFrameEncode();
  if (v21)
  {
    uint64_t v22 = v21;
    int v23 = -1431655766;
    int v26 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v20, v21);
    }
    if (*a1)
    {
      unsigned int v24 = (*a1)(a1, v20, v22, &v26, 1, 1000, 0);
      int v23 = v26;
    }
    else
    {
      unsigned int v24 = 0;
    }
    if (v23 == v22) {
      uint64_t v17 = v24;
    }
    else {
      uint64_t v17 = 0;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  free(v20);
LABEL_7:
  HDLCFrameFree();
  return v17;
}

uint64_t ETLBBCheckEchoResponse(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  uint64_t v29 = 0;
  memset(v28, 0, sizeof(v28));
  char v27 = 123;
  if (a3)
  {
    while (1)
    {
      if (!_ETLResponseRingBuffer) {
        TelephonyUtilRingBufferInitialize();
      }
      if (!ETLFindMatchingResponseUsingBuffer(a1, (unsigned __int8 **)v28, (uint64_t)&_ETLResponseRingBuffer, &v27, a4)|| !DWORD2(v28[0])|| **(unsigned char **)&v28[0] != 123)
      {
        break;
      }
      int v14 = DWORD2(v28[0]) - 1;
      int v15 = *(_DWORD *)(a2 + 8);
      if (v15 && v14 == v15)
      {
        int v7 = memcmp((const void *)(*(void *)&v28[0] + 1), *(const void **)a2, (DWORD2(v28[0]) - 1));
        HDLCFrameFree();
        if (!v7) {
          return 1;
        }
      }
      else
      {
        HDLCFrameFree();
        if (!v15 && !v14) {
          return 1;
        }
      }
      _ETLDebugPrint((uint64_t)"ETLBBCheckEchoResponse", (uint64_t)"Mismatch, continue\n", v8, v9, v10, v11, v12, v13, v26);
    }
    goto LABEL_24;
  }
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  if (!ETLFindMatchingResponseUsingBuffer(a1, (unsigned __int8 **)v28, (uint64_t)&_ETLResponseRingBuffer, &v27, a4)|| !DWORD2(v28[0])|| **(unsigned char **)&v28[0] != 123)
  {
LABEL_24:
    HDLCFrameFree();
    return 0;
  }
  int v16 = DWORD2(v28[0]) - 1;
  int v17 = *(_DWORD *)(a2 + 8);
  if (!v17 || v16 != v17)
  {
    HDLCFrameFree();
    if (!v17 && !v16) {
      return 1;
    }
LABEL_29:
    _ETLDebugPrint((uint64_t)"ETLBBCheckEchoResponse", (uint64_t)"Mismatch, bail\n", v19, v20, v21, v22, v23, v24, v26);
    return 0;
  }
  int v18 = memcmp((const void *)(*(void *)&v28[0] + 1), *(const void **)a2, (DWORD2(v28[0]) - 1));
  HDLCFrameFree();
  if (v18) {
    goto LABEL_29;
  }
  return 1;
}

uint64_t ETLBBGetVersion(void *a1, _OWORD *a2, unsigned int a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  int v15 = -1431655766;
  long long v46 = 0u;
  memset(v47, 0, sizeof(v47));
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v33 = 0u;
  long long v32 = 0u;
  long long v31 = 0u;
  long long v30 = 0u;
  long long v29 = 0u;
  long long v28 = 0u;
  long long v27 = 0u;
  long long v26 = 0u;
  long long v25 = 0u;
  long long v24 = 0u;
  long long v23 = 0u;
  long long v22 = 0u;
  long long v21 = 0u;
  long long v20 = 0u;
  long long v19 = 0u;
  long long v18 = 0u;
  long long v17 = 0u;
  int v16 = 2118751100;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(void *, void, int *, uint64_t))*(&gDelegate + 1))(&unk_1E4590583, 0, &v16, 4);
  }
  if (!*a1) {
    return 0;
  }
  uint64_t v6 = 0;
  if (((unsigned int (*)(void *, int *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, &v16, 4, &v15, 1, 1000, 0)&& v15 == 4)
  {
    unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v13[0] = v7;
    v13[1] = v7;
    char v12 = 124;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    unsigned int v8 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v13, (uint64_t)&_ETLResponseRingBuffer, &v12, a3);
    if (v12 == 124) {
      uint64_t v6 = v8;
    }
    else {
      uint64_t v6 = 0;
    }
    if (v6 == 1)
    {
      *(_OWORD *)((char *)a2 + 251) = 0u;
      a2[14] = 0u;
      a2[15] = 0u;
      a2[12] = 0u;
      a2[13] = 0u;
      a2[10] = 0u;
      a2[11] = 0u;
      a2[8] = 0u;
      a2[9] = 0u;
      a2[6] = 0u;
      a2[7] = 0u;
      a2[4] = 0u;
      a2[5] = 0u;
      a2[2] = 0u;
      a2[3] = 0u;
      uint64_t v9 = (const void *)(*(void *)&v13[0] + 1);
      if ((unint64_t)DWORD2(v13[0]) - 1 >= 0x10B) {
        size_t v10 = 267;
      }
      else {
        size_t v10 = DWORD2(v13[0]) - 1;
      }
      *a2 = 0uLL;
      a2[1] = 0uLL;
      memcpy(a2, v9, v10);
    }
    HDLCFrameFree();
  }
  return v6;
}

uint64_t ETLBBEnterDownloadMode(void *a1, unsigned int a2)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  int v18 = -1431655766;
  long long v49 = 0u;
  memset(v50, 0, sizeof(v50));
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v36 = 0u;
  long long v35 = 0u;
  long long v34 = 0u;
  long long v33 = 0u;
  long long v32 = 0u;
  long long v31 = 0u;
  long long v30 = 0u;
  long long v29 = 0u;
  long long v28 = 0u;
  long long v27 = 0u;
  long long v26 = 0u;
  long long v25 = 0u;
  long long v24 = 0u;
  long long v23 = 0u;
  long long v22 = 0u;
  long long v21 = 0u;
  long long v20 = 0u;
  int v19 = 2121179450;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(void *, void, int *, uint64_t))*(&gDelegate + 1))(&unk_1E4590583, 0, &v19, 4);
  }
  if (!*a1) {
    return 0;
  }
  uint64_t v4 = 0;
  if (((unsigned int (*)(void *, int *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, &v19, 4, &v18, 1, 1000, 0)&& v18 == 4)
  {
    unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v16[0] = v5;
    v16[1] = v5;
    char v15 = 58;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v16, (uint64_t)&_ETLResponseRingBuffer, &v15, a2))
    {
      if (v15 == 58)
      {
        uint64_t v4 = 1;
LABEL_16:
        HDLCFrameFree();
        return v4;
      }
      uint64_t v14 = 58;
      uint64_t v13 = "Command code expected %u, got %u\n";
    }
    else
    {
      uint64_t v13 = "Failed to get response\n";
    }
    _ETLDebugPrint((uint64_t)"ETLBBEnterDownloadMode", (uint64_t)v13, v6, v7, v8, v9, v10, v11, v14);
    uint64_t v4 = 0;
    goto LABEL_16;
  }
  return v4;
}

uint64_t ETLBBCreateUnlockCommand(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (*(_DWORD *)(a2 + 8) + 2);
  if (HDLCFrameGetFreeSpace() < v2)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v3, v4, v5, v6, v7, v8, v2);
    return 0;
  }
  if (!HDLCFrameInjectUnsignedChar()) {
    return 0;
  }

  return HDLCFrameInject();
}

BOOL ETLBBParseUnlockResponse(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[2] != 1) {
    return *(unsigned char *)(*(void *)a1 + 1) == 1;
  }
  _ETLDebugPrint((uint64_t)"ETLCheckPayloadLength", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 1);
  return 0;
}

unint64_t ETLBBUnlock(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, uint64_t a3)
{
  unint64_t v3 = 0;
  char v30 = 65;
  if (a1 && a2)
  {
    long long v27 = 0u;
    long long v28 = 0u;
    uint64_t v29 = 0;
    memset(v25, 0, sizeof(v25));
    uint64_t v26 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t v7 = (*(_DWORD *)(a2 + 8) + 2);
      if (HDLCFrameGetFreeSpace() >= v7)
      {
        if (HDLCFrameInjectUnsignedChar() && HDLCFrameInject())
        {
          unint64_t v3 = (unint64_t)malloc((2 * DWORD2(v27) + 32));
          if (!v3)
          {
LABEL_21:
            HDLCFrameFree();
            HDLCFrameFree();
            return v3;
          }
          uint64_t v14 = HDLCFrameEncode();
          if (!v14) {
            goto LABEL_19;
          }
          uint64_t v15 = v14;
          int v31 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, unint64_t, uint64_t))*(&gDelegate + 1))("", 0, v3, v14);
          }
          if (*a1)
          {
            int v16 = (*a1)(a1, (void *)v3, v15, &v31, 1, a3, 0);
            int v17 = v31;
            free((void *)v3);
            unint64_t v3 = 0;
            if (!v16 || v17 != v15) {
              goto LABEL_21;
            }
            if (ETLFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v25, &v30, a3))
            {
              if (DWORD2(v25[0]) != 1)
              {
                unint64_t v3 = *(unsigned __int8 *)(*(void *)&v25[0] + 1) == 1;
                goto LABEL_21;
              }
              _ETLDebugPrint((uint64_t)"ETLCheckPayloadLength", (uint64_t)"Need %u bytes, but only have %u\n", v18, v19, v20, v21, v22, v23, 1);
            }
          }
          else
          {
LABEL_19:
            free((void *)v3);
          }
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v8, v9, v10, v11, v12, v13, v7);
      }
    }
    unint64_t v3 = 0;
    goto LABEL_21;
  }
  return v3;
}

uint64_t ETLBBDeAssertResetDetect(void *a1, uint64_t a2)
{
  long long v36 = 0u;
  long long v37 = 0u;
  uint64_t v38 = 0;
  memset(v34, 0, sizeof(v34));
  uint64_t v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    char v30 = "ETLBBDeAssertResetDetect";
    int v31 = "Failed to create command frame\n";
LABEL_23:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v4, v5, v6, v7, v8, v9, v33);
    goto LABEL_24;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_24;
  }
  int v39 = 523595;
  if ((HDLCFrameInject() & 1) == 0)
  {
    char v30 = "ETLSubsysAddHeaderInternal";
    int v31 = "Failed to inject\n";
    goto LABEL_23;
  }
  uint64_t v17 = (uint64_t)malloc((2 * DWORD2(v36) + 32));
  if (v17)
  {
    uint64_t v18 = HDLCFrameEncode();
    if (!v18) {
      goto LABEL_26;
    }
    uint64_t v19 = v18;
    int v39 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v17, v18);
    }
    if (!*a1)
    {
LABEL_26:
      free((void *)v17);
      goto LABEL_24;
    }
    int v20 = ((uint64_t (*)(void *, uint64_t, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v17, v19, &v39, 1, a2, 0);
    int v21 = v39;
    free((void *)v17);
    uint64_t v17 = 0;
    if (v20)
    {
      if (v21 == v19)
      {
        LOBYTE(v39) = 75;
        if (!_ETLResponseRingBuffer) {
          TelephonyUtilRingBufferInitialize();
        }
        uint64_t v17 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a2))
        {
          if (v39 == 75)
          {
            if (DWORD2(v34[0]) < 4)
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v22, v23, v24, v25, v26, v27, DWORD2(v34[0]));
            }
            else
            {
              unsigned int v28 = **(_DWORD **)&v34[0];
              if (**(_DWORD **)&v34[0] == 75)
              {
                if (BYTE1(v28) == 253)
                {
                  uint64_t v29 = HIWORD(v28);
                  if (v29 == 7)
                  {
                    uint64_t v17 = 1;
                    goto LABEL_25;
                  }
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, v29);
                }
                else
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, BYTE1(v28));
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, **(_DWORD **)&v34[0]);
              }
            }
LABEL_24:
            uint64_t v17 = 0;
          }
        }
      }
    }
  }
LABEL_25:
  HDLCFrameFree();
  HDLCFrameFree();
  return v17;
}

uint64_t ETLBBPowerDown(uint64_t (**a1)(void, _OWORD *, uint64_t, int *, uint64_t, uint64_t, void))
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  int v15 = -1431655766;
  *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16[30] = v2;
  v16[31] = v2;
  v16[28] = v2;
  v16[29] = v2;
  v16[26] = v2;
  v16[27] = v2;
  v16[24] = v2;
  v16[25] = v2;
  v16[22] = v2;
  v16[23] = v2;
  v16[20] = v2;
  v16[21] = v2;
  v16[18] = v2;
  v16[19] = v2;
  v16[16] = v2;
  v16[17] = v2;
  v16[14] = v2;
  v16[15] = v2;
  v16[12] = v2;
  v16[13] = v2;
  v16[10] = v2;
  v16[11] = v2;
  v16[8] = v2;
  v16[9] = v2;
  v16[6] = v2;
  v16[7] = v2;
  v16[4] = v2;
  v16[5] = v2;
  _OWORD v16[2] = v2;
  v16[3] = v2;
  v16[0] = v2;
  v16[1] = v2;
  uint64_t v3 = APPLIB_API_SUBSYS_SendCommand(v16, 0x200u, 253, 9, 0, 0);
  if ((int)v3 <= 0)
  {
    _ETLDebugPrint((uint64_t)"ETLBBPowerDown", (uint64_t)"Failed to create unlock command\n", v4, v5, v6, v7, v8, v9, v14);
    return 0;
  }
  else
  {
    uint64_t v10 = v3;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(void *, void, _OWORD *, uint64_t))*(&gDelegate + 1))(&unk_1E4590583, 0, v16, v3);
    }
    if (*a1)
    {
      int v11 = (*a1)(a1, v16, v10, &v15, 1, 1000, 0);
      uint64_t v12 = 0;
      if (v11 && v15 == v10)
      {
        uint64_t v12 = 1;
        sleep(1u);
      }
    }
    else
    {
      return 0;
    }
  }
  return v12;
}

BOOL ETLBBSetCoreDumpMode(unsigned int (**a1)(void, _OWORD *, uint64_t, int *, uint64_t, uint64_t, void), __int16 a2, unsigned int a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  int v27 = -1431655766;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v28[30] = v5;
  v28[31] = v5;
  v28[28] = v5;
  v28[29] = v5;
  v28[26] = v5;
  v28[27] = v5;
  v28[24] = v5;
  v28[25] = v5;
  v28[22] = v5;
  v28[23] = v5;
  v28[20] = v5;
  v28[21] = v5;
  v28[18] = v5;
  v28[19] = v5;
  v28[16] = v5;
  v28[17] = v5;
  v28[14] = v5;
  v28[15] = v5;
  v28[12] = v5;
  v28[13] = v5;
  v28[10] = v5;
  v28[11] = v5;
  v28[8] = v5;
  v28[9] = v5;
  v28[6] = v5;
  v28[7] = v5;
  v28[5] = v5;
  v28[3] = v5;
  v28[4] = v5;
  v28[1] = v5;
  _OWORD v28[2] = v5;
  v28[0] = v5;
  LOWORD(v25[0]) = a2;
  uint64_t v6 = APPLIB_API_SUBSYS_SendCommand(v28, 0x200u, 253, 10, (uint64_t)v25, 2);
  if ((int)v6 <= 0)
  {
    _ETLDebugPrint((uint64_t)"ETLBBSetCoreDumpMode", (uint64_t)"Failed to create set core dump mode command\n", v7, v8, v9, v10, v11, v12, v23);
    return 0;
  }
  else
  {
    uint64_t v13 = v6;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(void *, void, _OWORD *, uint64_t))*(&gDelegate + 1))(&unk_1E4590583, 0, v28, v6);
    }
    if (*a1)
    {
      BOOL v14 = 0;
      if ((*a1)(a1, v28, v13, &v27, 1, 1000, 0) && v27 == v13)
      {
        unint64_t v26 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v25[0] = v15;
        v25[1] = v15;
        char v24 = 75;
        if (!_ETLResponseRingBuffer) {
          TelephonyUtilRingBufferInitialize();
        }
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v25, (uint64_t)&_ETLResponseRingBuffer, &v24, a3))
        {
          BOOL v14 = v24 == 75;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLBBSetCoreDumpMode", (uint64_t)"Did not find matching response\n", v16, v17, v18, v19, v20, v21, v23);
          BOOL v14 = 0;
        }
        HDLCFrameFree();
      }
    }
    else
    {
      return 0;
    }
  }
  return v14;
}

uint64_t ETLBBSimulateCrash(void *a1, uint64_t a2)
{
  return ETLBBSimulateCrashExt(a1, a2, 0);
}

uint64_t ETLBBSimulateCrashExt(void *a1, uint64_t a2, uint64_t a3)
{
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    unint64_t v26 = "ETLBBSimulateCrashExt";
    int v27 = "Failed to create command frame\n";
LABEL_17:
    _ETLDebugPrint((uint64_t)v26, (uint64_t)v27, v6, v7, v8, v9, v10, v11, v29);
    goto LABEL_18;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
LABEL_18:
    uint64_t v25 = 0;
    goto LABEL_19;
  }
  int v30 = 268641611;
  if ((HDLCFrameInject() & 1) == 0)
  {
    unint64_t v26 = "ETLSubsysAddHeaderInternal";
    int v27 = "Failed to inject\n";
    goto LABEL_17;
  }
  if (a3 && !HDLCFrameInject()) {
    goto LABEL_18;
  }
  uint64_t v19 = malloc(0x20uLL);
  if (!v19) {
    goto LABEL_18;
  }
  uint64_t v20 = v19;
  uint64_t v21 = HDLCFrameEncode();
  if (!v21) {
    goto LABEL_20;
  }
  uint64_t v22 = v21;
  int v30 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v20, v21);
  }
  if (!*a1)
  {
LABEL_20:
    free(v20);
    goto LABEL_18;
  }
  int v23 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v20, v22, &v30, 1, a2, 0);
  int v24 = v30;
  free(v20);
  uint64_t v25 = 0;
  if (v23 && v24 == v22)
  {
    usleep(0x30D40u);
    uint64_t v25 = 1;
  }
LABEL_19:
  HDLCFrameFree();
  HDLCFrameFree();
  return v25;
}

uint64_t ETLBBCreateSetModeCommand()
{
  uint64_t result = HDLCFrameInjectUnsignedChar();
  if (result)
  {
    return HDLCFrameInjectUnsignedShort();
  }
  return result;
}

BOOL ETLBBParseSetModeResponse(unsigned __int8 **a1)
{
  return *((_DWORD *)a1 + 2) && **a1 == 41;
}

unint64_t ETLBBSetMode(void *a1, uint64_t a2, uint64_t a3)
{
  long long v21 = 0u;
  long long v22 = 0u;
  uint64_t v23 = 0;
  memset(v19, 0, sizeof(v19));
  uint64_t v20 = 0;
  char v18 = 41;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLBBSetMode", (uint64_t)"Failed to create command frame\n", v5, v6, v7, v8, v9, v10, v17);
LABEL_17:
    unint64_t v11 = 0;
    goto LABEL_18;
  }
  if (!HDLCFrameInjectUnsignedChar() || !HDLCFrameInjectUnsignedShort()) {
    goto LABEL_17;
  }
  unint64_t v11 = (unint64_t)malloc((2 * DWORD2(v21) + 32));
  if (!v11) {
    goto LABEL_18;
  }
  uint64_t v12 = HDLCFrameEncode();
  if (!v12) {
    goto LABEL_19;
  }
  uint64_t v13 = v12;
  int v24 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, unint64_t, uint64_t))*(&gDelegate + 1))("", 0, v11, v12);
  }
  if (!*a1)
  {
LABEL_19:
    free((void *)v11);
    goto LABEL_17;
  }
  int v14 = ((uint64_t (*)(void *, unint64_t, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v11, v13, &v24, 1, a3, 0);
  int v15 = v24;
  free((void *)v11);
  unint64_t v11 = 0;
  if (v14 && v15 == v13)
  {
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    unint64_t v11 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v19, (uint64_t)&_ETLResponseRingBuffer, &v18, a3)&& DWORD2(v19[0]))
    {
      unint64_t v11 = **(unsigned char **)&v19[0] == 41;
    }
  }
LABEL_18:
  HDLCFrameFree();
  HDLCFrameFree();
  return v11;
}

uint64_t ETLBBSetAntennaConfig(void *a1, __int16 a2, unsigned int a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  int v21 = 0;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23[30] = v5;
  v23[31] = v5;
  v23[28] = v5;
  v23[29] = v5;
  v23[26] = v5;
  v23[27] = v5;
  v23[24] = v5;
  v23[25] = v5;
  v23[22] = v5;
  v23[23] = v5;
  v23[20] = v5;
  v23[21] = v5;
  v23[18] = v5;
  v23[19] = v5;
  v23[16] = v5;
  v23[17] = v5;
  v23[14] = v5;
  v23[15] = v5;
  v23[12] = v5;
  v23[13] = v5;
  v23[10] = v5;
  v23[11] = v5;
  v23[8] = v5;
  v23[9] = v5;
  v23[6] = v5;
  v23[7] = v5;
  v23[4] = v5;
  v23[5] = v5;
  v23[2] = v5;
  v23[3] = v5;
  v23[0] = v5;
  v23[1] = v5;
  uint64_t v6 = APPLIB_DIAG_SetOneRx(v23, 512, a2);
  uint64_t v13 = v6;
  if ((int)v6 <= 0)
  {
    _ETLDebugPrint((uint64_t)"ETLBBSetAntennaConfig", (uint64_t)"length %u\n", v7, v8, v9, v10, v11, v12, v6);
    return 0;
  }
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(void *, void, _OWORD *, uint64_t))*(&gDelegate + 1))(&unk_1E4590583, 0, v23, v6);
  }
  if (!*a1)
  {
    unsigned int v14 = 0;
LABEL_15:
    _ETLDebugPrint((uint64_t)"ETLBBSetAntennaConfig", (uint64_t)"Failed to write, success = %u, written = %u of %d\n", v7, v8, v9, v10, v11, v12, v14);
    return 0;
  }
  unsigned int v14 = ((uint64_t (*)(void *, _OWORD *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v23, v13, &v21, 1, 1000, 0);
  if (!v14 || v21 != v13) {
    goto LABEL_15;
  }
  unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v19[0] = v15;
  v19[1] = v15;
  char v22 = 75;
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  unsigned int v16 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v19, (uint64_t)&_ETLResponseRingBuffer, &v22, a3);
  if (v22 == 75) {
    uint64_t v17 = v16;
  }
  else {
    uint64_t v17 = 0;
  }
  HDLCFrameFree();
  return v17;
}

uint64_t ETLBBGetAntennaConfig(void *a1, _DWORD *a2, unsigned int a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  int v22 = 0;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v24[30] = v6;
  v24[31] = v6;
  v24[28] = v6;
  v24[29] = v6;
  v24[26] = v6;
  v24[27] = v6;
  v24[24] = v6;
  v24[25] = v6;
  v24[22] = v6;
  v24[23] = v6;
  v24[20] = v6;
  v24[21] = v6;
  v24[18] = v6;
  v24[19] = v6;
  v24[16] = v6;
  v24[17] = v6;
  v24[14] = v6;
  v24[15] = v6;
  v24[12] = v6;
  v24[13] = v6;
  v24[10] = v6;
  v24[11] = v6;
  v24[8] = v6;
  v24[9] = v6;
  v24[6] = v6;
  v24[7] = v6;
  v24[4] = v6;
  v24[5] = v6;
  v24[2] = v6;
  v24[3] = v6;
  v24[0] = v6;
  v24[1] = v6;
  uint64_t OneRxConfig = APPLIB_DIAG_Get_OneRxConfig(v24, 512);
  if (!a2) {
    return 0;
  }
  uint64_t v14 = OneRxConfig;
  *a2 = 0;
  if ((int)OneRxConfig <= 0)
  {
    _ETLDebugPrint((uint64_t)"ETLBBGetAntennaConfig", (uint64_t)"length %u\n", v8, v9, v10, v11, v12, v13, OneRxConfig);
    return 0;
  }
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(void *, void, _OWORD *, uint64_t))*(&gDelegate + 1))(&unk_1E4590583, 0, v24, OneRxConfig);
  }
  if (!*a1)
  {
    unsigned int v15 = 0;
LABEL_16:
    _ETLDebugPrint((uint64_t)"ETLBBGetAntennaConfig", (uint64_t)"Failed to write, success = %u, written = %u of %d\n", v8, v9, v10, v11, v12, v13, v15);
    return 0;
  }
  unsigned int v15 = ((uint64_t (*)(void *, _OWORD *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v24, v14, &v22, 1, 1000, 0);
  if (!v15 || v22 != v14) {
    goto LABEL_16;
  }
  unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v20[0] = v16;
  v20[1] = v16;
  char v23 = 75;
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  int v17 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v20, (uint64_t)&_ETLResponseRingBuffer, &v23, a3);
  uint64_t v18 = 0;
  if (v17 && v23 == 75)
  {
    if (*(_WORD *)(*(void *)&v20[0] + 4) == 1)
    {
      *a2 = *(unsigned __int16 *)(*(void *)&v20[0] + 6);
      uint64_t v18 = 1;
    }
    else
    {
      uint64_t v18 = 0;
    }
  }
  HDLCFrameFree();
  return v18;
}

uint64_t ETLBBGetRSSI(void *a1, int a2, unsigned int a3, float *a4)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  int v30 = 0;
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v32[30] = v8;
  v32[31] = v8;
  v32[28] = v8;
  v32[29] = v8;
  v32[26] = v8;
  v32[27] = v8;
  v32[24] = v8;
  v32[25] = v8;
  v32[22] = v8;
  v32[23] = v8;
  v32[20] = v8;
  v32[21] = v8;
  v32[18] = v8;
  v32[19] = v8;
  v32[16] = v8;
  v32[17] = v8;
  v32[14] = v8;
  v32[15] = v8;
  v32[12] = v8;
  v32[13] = v8;
  v32[10] = v8;
  v32[11] = v8;
  v32[8] = v8;
  v32[9] = v8;
  v32[6] = v8;
  v32[7] = v8;
  v32[4] = v8;
  v32[5] = v8;
  v32[2] = v8;
  v32[3] = v8;
  v32[0] = v8;
  v32[1] = v8;
  uint64_t RSSI_Channel = APPLIB_DIAG_Get_RSSI_Channel(v32, 512, a2);
  if (!a4) {
    return 0;
  }
  uint64_t v16 = RSSI_Channel;
  *a4 = 0.0;
  if ((int)RSSI_Channel <= 0)
  {
    _ETLDebugPrint((uint64_t)"ETLBBGetRSSI", (uint64_t)"length %u\n", v10, v11, v12, v13, v14, v15, RSSI_Channel);
    return 0;
  }
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(void *, void, _OWORD *, uint64_t))*(&gDelegate + 1))(&unk_1E4590583, 0, v32, RSSI_Channel);
  }
  if (!*a1)
  {
    unsigned int v17 = 0;
LABEL_17:
    _ETLDebugPrint((uint64_t)"ETLBBGetRSSI", (uint64_t)"Failed to write, success = %u, written = %u of %u\n", v10, v11, v12, v13, v14, v15, v17);
    return 0;
  }
  unsigned int v17 = ((uint64_t (*)(void *, _OWORD *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v32, v16, &v30, 1, 1000, 0);
  if (!v17 || v30 != v16) {
    goto LABEL_17;
  }
  unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v28[0] = v18;
  v28[1] = v18;
  char v31 = 75;
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  int v19 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v28, (uint64_t)&_ETLResponseRingBuffer, &v31, a3);
  uint64_t v26 = 0;
  if (v19 && v31 == 75)
  {
    if (a2 <= 1 && *(_WORD *)(*(void *)&v28[0] + 4) == 1)
    {
      *a4 = (float)(__int16)~*(_WORD *)(*(void *)&v28[0] + 2 * a2 + 12) * -0.1;
      uint64_t v26 = 1;
    }
    else
    {
      uint64_t v26 = 0;
    }
    _ETLDebugPrint((uint64_t)"ETLBBGetRSSI", (uint64_t)"Read success rssi %f\n", v20, v21, v22, v23, v24, v25, COERCE__INT64(*a4));
  }
  HDLCFrameFree();
  return v26;
}

uint64_t crc_16_calc(unsigned __int8 *a1, unsigned int a2)
{
  if (a2 < 8)
  {
    int v3 = 0xFFFF;
    if (!(_WORD)a2) {
      return (unsigned __int16)~(_WORD)v3;
    }
  }
  else
  {
    unsigned int v2 = ((unsigned __int16)(a2 - 8) >> 3) + 1;
    int v3 = 0xFFFF;
    uint64_t v4 = a1;
    do
    {
      int v5 = *v4++;
      int v3 = crc16_table[v5 ^ ((unsigned __int16)(v3 & 0xFF00) >> 8)] ^ (v3 << 8);
      LOWORD(a2) = a2 - 8;
    }
    while ((unsigned __int16)a2 > 7u);
    a1 += v2;
    if (!(_WORD)a2) {
      return (unsigned __int16)~(_WORD)v3;
    }
  }
  __int16 v6 = *a1 << 8;
  do
  {
    LOWORD(a2) = a2 - 1;
    __int16 v7 = v6 ^ v3;
    v3 *= 2;
    if (v7 < 0) {
      v3 ^= 0x1021u;
    }
    __int16 v6 = (2 * v6) & 0xFE00;
  }
  while ((_WORD)a2);
  return (unsigned __int16)~(_WORD)v3;
}

uint64_t crc_16_l_calc(char *a1, unsigned int a2)
{
  if (a2 < 8)
  {
    LOWORD(v3) = -1;
    if (!(_WORD)a2) {
      return (unsigned __int16)~(_WORD)v3;
    }
  }
  else
  {
    unsigned int v2 = ((unsigned __int16)(a2 - 8) >> 3) + 1;
    LOWORD(v3) = -1;
    uint64_t v4 = a1;
    do
    {
      char v5 = *v4++;
      int v3 = crc_16_l_table[(v5 ^ v3)] ^ ((unsigned __int16)(v3 & 0xFF00) >> 8);
      LOWORD(a2) = a2 - 8;
    }
    while ((unsigned __int16)a2 > 7u);
    a1 += v2;
    if (!(_WORD)a2) {
      return (unsigned __int16)~(_WORD)v3;
    }
  }
  unsigned __int16 v6 = *a1 << 8;
  do
  {
    LOWORD(a2) = a2 - 1;
    char v7 = v6 ^ v3;
    LOWORD(v3) = (unsigned __int16)v3 >> 1;
    if (v7) {
      LOWORD(v3) = v3 ^ 0x8408;
    }
    v6 >>= 1;
  }
  while ((_WORD)a2);
  return (unsigned __int16)~(_WORD)v3;
}

uint64_t crc_30_calc(char *a1, unsigned int a2)
{
  if (a2 < 8)
  {
    unsigned int v3 = 0x3FFFFFFF;
    if (!(_WORD)a2) {
      return ~v3 & 0x3FFFFFFF;
    }
  }
  else
  {
    unsigned int v2 = ((unsigned __int16)(a2 - 8) >> 3) + 1;
    unsigned int v3 = 0x3FFFFFFF;
    uint64_t v4 = a1;
    do
    {
      char v5 = *v4++;
      unsigned int v3 = crc30_table[(v5 ^ (v3 >> 22))] ^ (v3 << 8);
      LOWORD(a2) = a2 - 8;
    }
    while ((unsigned __int16)a2 > 7u);
    a1 += v2;
    if (!(_WORD)a2) {
      return ~v3 & 0x3FFFFFFF;
    }
  }
  int v6 = *a1 << 22;
  do
  {
    LOWORD(a2) = a2 - 1;
    int v7 = v6 ^ v3;
    v3 *= 2;
    if ((v7 & 0x20000000) != 0) {
      v3 ^= 0x6030B9C7u;
    }
    v6 *= 2;
  }
  while ((_WORD)a2);
  return ~v3 & 0x3FFFFFFF;
}

uint64_t crc_30_step(int a1, char *a2, unsigned int a3)
{
  unsigned int v3 = ~a1 & 0x3FFFFFFF;
  if (a3 >= 8)
  {
    unsigned int v4 = ((unsigned __int16)(a3 - 8) >> 3) + 1;
    char v5 = a2;
    do
    {
      char v6 = *v5++;
      unsigned int v3 = crc30_table[(v6 ^ (v3 >> 22))] ^ (v3 << 8);
      LOWORD(a3) = a3 - 8;
    }
    while ((unsigned __int16)a3 > 7u);
    a2 += v4;
  }
  if ((_WORD)a3)
  {
    int v7 = *a2 << 22;
    do
    {
      LOWORD(a3) = a3 - 1;
      int v8 = v7 ^ v3;
      v3 *= 2;
      if ((v8 & 0x20000000) != 0) {
        v3 ^= 0x6030B9C7u;
      }
      v7 *= 2;
    }
    while ((_WORD)a3);
  }
  return ~v3 & 0x3FFFFFFF;
}

uint64_t crc_16_step(uint64_t result, unsigned __int8 *a2, int a3)
{
  if (a3)
  {
    __int16 v3 = ~(_WORD)result;
    do
    {
      int v4 = *a2++;
      __int16 v3 = crc16_table[v4 ^ ((unsigned __int16)(v3 & 0xFF00) >> 8)] ^ (v3 << 8);
      --a3;
    }
    while ((_WORD)a3);
    LOWORD(result) = ~v3;
  }
  return (unsigned __int16)result;
}

uint64_t crc_16_l_step(uint64_t result, char *a2, int a3)
{
  if (a3)
  {
    LOWORD(v3) = ~(_WORD)result;
    do
    {
      char v4 = *a2++;
      int v3 = crc_16_l_table[(v4 ^ v3)] ^ ((unsigned __int16)(v3 & 0xFF00) >> 8);
      --a3;
    }
    while (a3);
    LOWORD(result) = ~(_WORD)v3;
  }
  return (unsigned __int16)result;
}

uint64_t crc_32_calc(unsigned __int8 *a1, unsigned int a2, uint64_t a3)
{
  if (a2 >= 8)
  {
    unsigned int v3 = ((unsigned __int16)(a2 - 8) >> 3) + 1;
    char v4 = a1;
    do
    {
      int v5 = *v4++;
      a3 = (crc32_table[v5 ^ BYTE3(a3)] ^ (a3 << 8));
      LOWORD(a2) = a2 - 8;
    }
    while ((unsigned __int16)a2 > 7u);
    a1 += v3;
  }
  if ((_WORD)a2)
  {
    int v6 = *a1 << 24;
    do
    {
      LOWORD(a2) = a2 - 1;
      if ((int)(v6 ^ a3) >= 0) {
        a3 = (2 * a3);
      }
      else {
        a3 = (2 * a3) ^ 0x4C11DB7u;
      }
      v6 *= 2;
    }
    while ((_WORD)a2);
  }
  return a3;
}

uint64_t ETLGSDIAddCommandHeader()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLGSDIParseResponseHeader(uint64_t a1, _WORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a3;
  uint64_t v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    int v10 = *(_DWORD *)(*(void *)a1 + v8);
    if (v10 == 75)
    {
      *a2 = HIWORD(v10);
      *a3 = v8 + 4;
      if (BYTE1(v10) == 33)
      {
        return 1;
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLGSDIParseResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v10);
      return 0;
    }
  }
}

uint64_t ETLGSDIAddDelayedCommandHeaderInternal()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLGSDIParseDelayedCommandHeaderInternal(uint64_t *a1, _WORD *a2, _DWORD *a3, _WORD *a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a5;
  uint64_t v9 = (*((_DWORD *)a1 + 2) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    uint64_t v10 = *a1;
    int v11 = *(_DWORD *)(*a1 + v8);
    if (v11 == 128)
    {
      *a2 = HIWORD(v11);
      *a5 = v8 + 4;
      if ((*((_DWORD *)a1 + 2) - (v8 + 4)) <= 5)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsys2ParseHeader", (uint64_t)"Need %u bytes, only have %u\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, 6);
        return 0;
      }
      else
      {
        uint64_t v12 = BYTE1(v11);
        uint64_t v13 = (unsigned int *)(v10 + (v8 + 4));
        *a5 = v8 + 10;
        uint64_t v14 = *v13;
        *a4 = *((_WORD *)v13 + 2);
        if (v12 == 33)
        {
          *a3 = v14;
          if (v14)
          {
            _ETLDebugPrint((uint64_t)"ETLGSDIParseDelayedCommandHeaderInternal", (uint64_t)"Status was %u\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v14);
            return 0;
          }
          else
          {
            return 1;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLGSDIParseDelayedCommandHeaderInternal", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v12);
          return 0;
        }
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v11);
      return 0;
    }
  }
}

uint64_t ETLGSDIAddDelayedCommandHeader()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
  }
  else
  {
    if (HDLCFrameInject())
    {
      if (HDLCFrameGetFreeSpace() > 0x19)
      {
        HDLCFrameInjectUnsignedInt();
        HDLCFrameInjectUnsignedInt();
        HDLCFrameInjectUnsignedChar();
        HDLCFrameInjectUnsignedChar();
        return HDLCFrameInject();
      }
      uint64_t v16 = 26;
      uint64_t v14 = "ETLRequireFreeSpace";
      uint64_t v15 = "Need %u bytes free space, but only have %u\n";
    }
    else
    {
      uint64_t v14 = "ETLSubsysAddHeaderInternal";
      uint64_t v15 = "Failed to inject\n";
    }
    _ETLDebugPrint((uint64_t)v14, (uint64_t)v15, v7, v8, v9, v10, v11, v12, v16);
  }
  return 0;
}

uint64_t ETLGSDIParseDelayedCommandHeader(uint64_t *a1, _WORD *a2, _WORD *a3, uint64_t a4, uint64_t a5, _DWORD *a6, unsigned int *a7, uint64_t a8)
{
  *a6 = 0;
  uint64_t v8 = *a7;
  uint64_t v9 = (*((_DWORD *)a1 + 2) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, v9);
    return 0;
  }
  uint64_t v10 = *a1;
  unsigned int v11 = *(_DWORD *)(*a1 + v8);
  if (v11 != 128)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, *(_DWORD *)(*a1 + v8));
    return 0;
  }
  *a7 = v8 + 4;
  if ((*((_DWORD *)a1 + 2) - (v8 + 4)) <= 5)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsys2ParseHeader", (uint64_t)"Need %u bytes, only have %u\n", (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, 6);
    return 0;
  }
  uint64_t v12 = (unsigned int *)(v10 + (v8 + 4));
  unsigned int v13 = v8 + 10;
  *a7 = v8 + 10;
  uint64_t v14 = *v12;
  *a2 = *((_WORD *)v12 + 2);
  if (BYTE1(v11) != 33)
  {
    _ETLDebugPrint((uint64_t)"ETLGSDIParseDelayedCommandHeaderInternal", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, BYTE1(v11));
    return 0;
  }
  if (v14)
  {
    _ETLDebugPrint((uint64_t)"ETLGSDIParseDelayedCommandHeaderInternal", (uint64_t)"Status was %u\n", (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, v14);
    return 0;
  }
  uint64_t v16 = HIWORD(v11);
  if (v16 != 72)
  {
    _ETLDebugPrint((uint64_t)"ETLGSDIParseDelayedCommandHeader", (uint64_t)"Response subcommand code was 0x%x, expected 0x%x\n", (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, v16);
    return 0;
  }
  if (*((_DWORD *)a1 + 2) - v13 <= 1)
  {
    uint64_t v22 = 2;
LABEL_21:
    _ETLDebugPrint((uint64_t)"ETLGSDIParseDelayedCommandHeader", (uint64_t)"Need %u bytes, only have %u in response\n", (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, v22);
    return 0;
  }
  int v17 = *(unsigned __int16 *)(v10 + v13);
  *a3 = v17;
  unsigned int v18 = v8 + 12;
  *a7 = v18;
  if (v17 != 1) {
    return 1;
  }
  if (*((_DWORD *)a1 + 2) - v18 <= 0xB)
  {
    uint64_t v22 = 12;
    goto LABEL_21;
  }
  int v19 = (unsigned int *)(v10 + v18);
  uint64_t v21 = *v19;
  uint64_t v20 = v19[1];
  *a6 = v19[2];
  if (v21 == a4)
  {
    if (v20 == a5)
    {
      *a7 += 12;
      return 1;
    }
    _ETLDebugPrint((uint64_t)"ETLGSDIParseDelayedCommandHeader", (uint64_t)"Received subcommand 0x%x mismatches expected 0x%x\n", (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, v20);
    return 0;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLGSDIParseDelayedCommandHeader", (uint64_t)"Received status location %u mismatches expected %u\n", (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, v21);
    return 0;
  }
}

uint64_t ETLGSDICreateGetFeatureCommand()
{
  if (!ETLGSDIAddDelayedCommandHeader()) {
    return 0;
  }
  if (HDLCFrameGetFreeSpace() <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v0, v1, v2, v3, v4, v5, 4);
    return 0;
  }

  return HDLCFrameInjectUnsignedInt();
}

uint64_t ETLGSDIParseGetFeatureResponse(uint64_t a1, _WORD *a2, _WORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v21 = 0;
  *a4 = 0;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 128) = 0u;
  *(_OWORD *)(a5 + 144) = 0u;
  *(_OWORD *)(a5 + 160) = 0u;
  *(_OWORD *)(a5 + 176) = 0u;
  *(_OWORD *)(a5 + 192) = 0u;
  *(_OWORD *)(a5 + 208) = 0u;
  *(_OWORD *)(a5 + 224) = 0u;
  *(_OWORD *)(a5 + 240) = 0u;
  *(_DWORD *)(a5 + 256) = 0;
  int v16 = ETLGSDIParseDelayedCommandHeader((uint64_t *)a1, a2, a3, 1, 174, a4, &v21, a8);
  uint64_t result = 0;
  if (v16)
  {
    unsigned int v18 = *(_DWORD *)(a1 + 8) - v21;
    if (v18 <= 3)
    {
      _ETLDebugPrint((uint64_t)"ETLGSDIParseGetFeatureResponse", (uint64_t)"Need %u bytes, only have %u\n", v10, v11, v12, v13, v14, v15, 4);
    }
    else
    {
      int v19 = (unsigned __int16 *)(*(void *)a1 + v21);
      size_t v20 = *v19;
      *(_DWORD *)a5 = v20;
      if (v20 <= v18 - 4)
      {
        memcpy((void *)(a5 + 4), v19 + 2, v20);
        return 1;
      }
      _ETLDebugPrint((uint64_t)"ETLGSDIParseGetFeatureResponse", (uint64_t)"Data length is %u, but only have %u\n", v20, v11, v12, v13, v14, v15, v20);
    }
    return 0;
  }
  return result;
}

uint64_t ETLGSDICreateGetECCCommand()
{
  return ETLGSDIAddDelayedCommandHeader();
}

uint64_t ETLGSDIParseGetECCResponse(uint64_t a1, _WORD *a2, _WORD *a3, _DWORD *a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v18 = 0;
  *a4 = 0;
  int v16 = ETLGSDIParseDelayedCommandHeader((uint64_t *)a1, a2, a3, 1, 85, a4, &v18, a8);
  uint64_t result = 0;
  if (v16)
  {
    if (*(_DWORD *)(a1 + 8) - v18 <= 3)
    {
      _ETLDebugPrint((uint64_t)"ETLGSDIParseGetECCResponse", (uint64_t)"Need %u bytes, only have %u\n", v10, v11, v12, v13, v14, v15, 4);
      return 0;
    }
    else
    {
      *a5 = *(_DWORD *)(*(void *)a1 + v18);
      return 1;
    }
  }
  return result;
}

uint64_t ETLGSDIAddReadTransparentCmdHeader()
{
  if (!ETLGSDIAddDelayedCommandHeader()) {
    return 0;
  }
  if (HDLCFrameGetFreeSpace() <= 0xB)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v0, v1, v2, v3, v4, v5, 12);
    return 0;
  }
  if (!HDLCFrameInjectUnsignedInt() || !HDLCFrameInjectUnsignedInt()) {
    return 0;
  }

  return HDLCFrameInjectUnsignedInt();
}

uint64_t ETLGSDICreateReadTransparentCmdCommand()
{
  if (!ETLGSDIAddDelayedCommandHeader()) {
    return 0;
  }
  if (HDLCFrameGetFreeSpace() <= 0xB)
  {
    uint64_t v7 = 12;
LABEL_14:
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v0, v1, v2, v3, v4, v5, v7);
    return 0;
  }
  if (!HDLCFrameInjectUnsignedInt()
    || !HDLCFrameInjectUnsignedInt()
    || !HDLCFrameInjectUnsignedInt())
  {
    return 0;
  }
  if (HDLCFrameGetFreeSpace() <= 0xF)
  {
    uint64_t v7 = 16;
    goto LABEL_14;
  }
  if (!HDLCFrameInjectUnsignedInt()
    || !HDLCFrameInjectUnsignedInt()
    || !HDLCFrameInjectUnsignedInt())
  {
    return 0;
  }

  return HDLCFrameInjectUnsignedInt();
}

uint64_t ETLGSDIParseReadTransparentCmdResponse(uint64_t a1, _WORD *a2, _WORD *a3, int a4, unsigned int a5, void *a6, uint64_t a7, uint64_t a8)
{
  unsigned int v29 = 0;
  int v19 = ETLGSDIParseDelayedCommandHeader((uint64_t *)a1, a2, a3, 1, 119, &v28, &v29, a8);
  uint64_t result = 0;
  if (v19)
  {
    if (*a3 != 1) {
      return 1;
    }
    unsigned int v21 = *(_DWORD *)(a1 + 8) - v29;
    if (v21 <= 0xB)
    {
      _ETLDebugPrint((uint64_t)"ETLGSDIParseReadTransparentCmdResponse", (uint64_t)"Need %u bytes, only have %u\n", v13, v14, v15, v16, v17, v18, 12);
    }
    else
    {
      uint64_t v22 = (_DWORD *)(*(void *)a1 + v29);
      if (*v22) {
        return 0;
      }
      if (v22[1] == a4)
      {
        unsigned int v23 = v21 - 12;
        if (v21 - 12 < a5 + 4)
        {
          _ETLDebugPrint((uint64_t)"ETLGSDIParseReadTransparentCmdResponse", (uint64_t)"Need %u bytes, only have %u\n", v13, v14, v15, v16, v17, v18, a5 + 4);
          return 0;
        }
        uint64_t v24 = (char *)v22 + a5;
        unsigned int v27 = *((_DWORD *)v24 + 3);
        uint64_t v26 = v24 + 12;
        size_t v25 = v27;
        if (v23 - (a5 + 4) < v27) {
          return 0;
        }
        memcpy(a6, v26 + 4, v25);
        return 1;
      }
    }
    return 0;
  }
  return result;
}

uint64_t ETLGSDICreateGetPINStatusCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
  }
  else
  {
    if (HDLCFrameInject())
    {
      if (HDLCFrameGetFreeSpace() > 0x11)
      {
        HDLCFrameInjectUnsignedChar();
        HDLCFrameInjectUnsignedChar();
        HDLCFrameInject();
        return HDLCFrameInjectUnsignedChar();
      }
      uint64_t v16 = 18;
      uint64_t v14 = "ETLRequireFreeSpace";
      uint64_t v15 = "Need %u bytes free space, but only have %u\n";
    }
    else
    {
      uint64_t v14 = "ETLSubsysAddHeaderInternal";
      uint64_t v15 = "Failed to inject\n";
    }
    _ETLDebugPrint((uint64_t)v14, (uint64_t)v15, v7, v8, v9, v10, v11, v12, v16);
  }
  return 0;
}

uint64_t ETLGSDIParseGetPINStatusReponse(int **a1, _DWORD *a2, _WORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a2 = 0;
  unsigned int v8 = *((_DWORD *)a1 + 2);
  uint64_t v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 33)
      {
        uint64_t v12 = HIWORD(v11);
        if (v12 == 5)
        {
          if (v9 <= 0x18)
          {
            _ETLDebugPrint((uint64_t)"ETLGSDIParseGetPINStatusReponse", (uint64_t)"response has %u bytes, need %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else
          {
            *a2 = v10[1];
            *a3 = *((unsigned __int8 *)v10 + 8);
            if (*a2)
            {
              _ETLDebugPrint((uint64_t)"ETLGSDIParseGetPINStatusReponse", (uint64_t)"Status was %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, *a2);
              return 0;
            }
            else if (*((unsigned __int8 *)v10 + 10) == a4)
            {
              uint64_t v14 = *((unsigned __int8 *)v10 + 28);
              if (v14 == a5)
              {
                return 1;
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLGSDIParseGetPINStatusReponse", (uint64_t)"Received PIN ID %u mismatches %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v14);
                return 0;
              }
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLGSDIParseGetPINStatusReponse", (uint64_t)"Received slot ID %u mismatches %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, *((unsigned __int8 *)v10 + 10));
              return 0;
            }
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLGSDIParseGetPINStatusReponse", (uint64_t)"Received subcommand %u mismatches %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLGSDIParseResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

BOOL ETLGSDIParsePINStatusEvent(uint64_t a1, unsigned int a2, uint64_t a3)
{
  *(_DWORD *)(a3 + 8) = 0;
  *(void *)a3 = 0;
  if (a2 >= 7)
  {
    *(_DWORD *)a3 = *(_DWORD *)a1;
    *(_WORD *)(a3 + 4) = *(_WORD *)(a1 + 4);
    *(_DWORD *)(a3 + 8) = *(unsigned __int8 *)(a1 + 5);
  }
  return a2 > 6;
}

void *ETLGSDIPerformGetFeatureRaw(void *a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  long long v28 = 0u;
  long long v29 = 0u;
  uint64_t v30 = 0;
  memset(v26, 0, sizeof(v26));
  uint64_t v27 = 0;
  if (!HDLCFrameCreateUplink() || !ETLGSDIAddDelayedCommandHeader()) {
    goto LABEL_18;
  }
  if (HDLCFrameGetFreeSpace() <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v10, v11, v12, v13, v14, v15, 4);
    goto LABEL_18;
  }
  if (!HDLCFrameInjectUnsignedInt())
  {
LABEL_18:
    FeatureResponse = 0;
    goto LABEL_19;
  }
  FeatureResponse = malloc((2 * DWORD2(v28) + 32));
  if (!FeatureResponse) {
    goto LABEL_19;
  }
  uint64_t v17 = HDLCFrameEncode();
  if (!v17) {
    goto LABEL_20;
  }
  uint64_t v18 = v17;
  int v31 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, FeatureResponse, v17);
  }
  if (!*a1)
  {
LABEL_20:
    free(FeatureResponse);
    goto LABEL_18;
  }
  int v19 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, FeatureResponse, v18, &v31, 1, a6, 0);
  int v20 = v31;
  free(FeatureResponse);
  FeatureResponse = 0;
  if (v19 && v20 == v18)
  {
    LOBYTE(v31) = 0x80;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    FeatureResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v26, (uint64_t)&_ETLResponseRingBuffer, &v31, a6)&& v31 == 128)
    {
      FeatureResponse = (void *)ETLGSDIParseGetFeatureResponse((uint64_t)v26, &v31, &v25, a4, a5, v21, v22, v23);
    }
  }
LABEL_19:
  HDLCFrameFree();
  HDLCFrameFree();
  return FeatureResponse;
}

uint64_t ETLGSDIPerformGetECC(void *a1, uint64_t a2, _DWORD *a3, _DWORD *a4, uint64_t a5)
{
  long long v37 = 0u;
  long long v38 = 0u;
  uint64_t v39 = 0;
  memset(v35, 0, sizeof(v35));
  uint64_t v36 = 0;
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_22;
  }
  if (!ETLGSDIAddDelayedCommandHeader()) {
    goto LABEL_22;
  }
  uint64_t v9 = malloc((2 * DWORD2(v37) + 32));
  if (!v9) {
    goto LABEL_22;
  }
  uint64_t v10 = v9;
  uint64_t v11 = HDLCFrameEncode();
  if (!v11) {
    goto LABEL_21;
  }
  uint64_t v12 = v11;
  unsigned int v40 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v10, v11);
  }
  if (!*a1)
  {
LABEL_21:
    free(v10);
    goto LABEL_22;
  }
  int v13 = ((uint64_t (*)(void *, void *, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v10, v12, &v40, 1, a5, 0);
  unsigned int v14 = v40;
  free(v10);
  if (!v13 || v14 != v12) {
    goto LABEL_22;
  }
  LOBYTE(v40) = 0x80;
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v35, (uint64_t)&_ETLResponseRingBuffer, &v40, a5)|| v40 != 128|| (unsigned int v40 = 0, *a3 = 0, !ETLGSDIParseDelayedCommandHeader((uint64_t *)v35, &v34, &v33, 1, 85, a3, &v40, v16)))
  {
LABEL_22:
    LOBYTE(v40) = 0x80;
    if (!_ETLResponseRingBuffer) {
      goto LABEL_23;
    }
    goto LABEL_24;
  }
  if (DWORD2(v35[0]) - v40 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLGSDIParseGetECCResponse", (uint64_t)"Need %u bytes, only have %u\n", v17, v18, v19, v20, v21, v22, 4);
    LOBYTE(v40) = 0x80;
    if (_ETLResponseRingBuffer) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  *a4 = *(_DWORD *)(*(void *)&v35[0] + v40);
  LOBYTE(v40) = 0x80;
  if (!_ETLResponseRingBuffer) {
LABEL_23:
  }
    TelephonyUtilRingBufferInitialize();
LABEL_24:
  int v23 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v35, (uint64_t)&_ETLResponseRingBuffer, &v40, a5);
  uint64_t v25 = 0;
  if (v23)
  {
    if (v40 == 128)
    {
      unsigned int v40 = 0;
      *a3 = 0;
      uint64_t v25 = 0;
      if (ETLGSDIParseDelayedCommandHeader((uint64_t *)v35, &v34, &v33, 1, 85, a3, &v40, v24))
      {
        if (DWORD2(v35[0]) - v40 <= 3)
        {
          _ETLDebugPrint((uint64_t)"ETLGSDIParseGetECCResponse", (uint64_t)"Need %u bytes, only have %u\n", v26, v27, v28, v29, v30, v31, 4);
          uint64_t v25 = 0;
        }
        else
        {
          *a4 = *(_DWORD *)(*(void *)&v35[0] + v40);
          uint64_t v25 = 1;
        }
      }
    }
  }
  HDLCFrameFree();
  HDLCFrameFree();
  return v25;
}

uint64_t ETLGSDIPerformGetIccid(void *a1, uint64_t a2, int8x8_t *a3, uint64_t a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  long long v25 = 0u;
  long long v26 = 0u;
  uint64_t v27 = 0;
  memset(v23, 0, sizeof(v23));
  uint64_t v24 = 0;
  __int16 v31 = -21846;
  unint64_t v30 = 0xAAAAAAAAAAAAAAAALL;
  if (!a3 || !HDLCFrameCreateUplink()) {
    goto LABEL_23;
  }
  uint64_t v7 = 0;
  if (!ETLGSDICreateReadTransparentCmdCommand()) {
    goto LABEL_24;
  }
  uint64_t v7 = (uint64_t)malloc((2 * DWORD2(v25) + 32));
  if (!v7) {
    goto LABEL_24;
  }
  uint64_t v8 = HDLCFrameEncode();
  if (!v8) {
    goto LABEL_22;
  }
  uint64_t v9 = v8;
  int v28 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v7, v8);
  }
  if (!*a1)
  {
LABEL_22:
    free((void *)v7);
LABEL_23:
    uint64_t v7 = 0;
    goto LABEL_24;
  }
  int v10 = ((uint64_t (*)(void *, uint64_t, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v7, v9, &v28, 1, a4, 0);
  int v11 = v28;
  free((void *)v7);
  uint64_t v7 = 0;
  if (v10 && v11 == v9)
  {
    LOBYTE(v28) = 0x80;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    uint64_t v7 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v23, (uint64_t)&_ETLResponseRingBuffer, &v28, a4)&& v28 == 128)
    {
      LOWORD(v28) = -21846;
      unsigned __int16 v22 = -21846;
      uint64_t v7 = ETLGSDIParseReadTransparentCmdResponse((uint64_t)v23, &v28, &v22, 1, 0xAu, &v30, v12, v13);
      int v14 = v22;
      if (v7 && v22 != 1)
      {
        int v15 = (unsigned __int16)v28;
        unsigned __int8 v29 = 0x80;
        if (!_ETLResponseRingBuffer) {
          TelephonyUtilRingBufferInitialize();
        }
        int v18 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v23, (uint64_t)&_ETLResponseRingBuffer, &v29, a4);
        unsigned int v19 = 0;
        if (v18)
        {
          int v20 = v15;
          if (v29 == 128)
          {
            unsigned int v19 = ETLGSDIParseReadTransparentCmdResponse((uint64_t)v23, &v28, &v22, 1, 0xAu, &v30, v16, v17);
            int v14 = v22;
            int v20 = (unsigned __int16)v28;
          }
        }
        else
        {
          int v20 = v15;
        }
        if (v15 == v20) {
          uint64_t v7 = v19;
        }
        else {
          uint64_t v7 = 0;
        }
      }
      if (v7 && v14 == 1)
      {
        *a3 = vorr_s8(vshl_n_s8((int8x8_t)v30, 4uLL), (int8x8_t)vshr_n_u8((uint8x8_t)v30, 4uLL));
        a3[1].i8[0] = (v31 >> 4) | (16 * v31);
        a3[1].i8[1] = (HIBYTE(v31) >> 4) | (16 * HIBYTE(v31));
        uint64_t v7 = 1;
      }
    }
  }
LABEL_24:
  HDLCFrameFree();
  HDLCFrameFree();
  return v7;
}

uint64_t ETLGSDIGetICCID(void *a1, int8x8_t *a2, uint64_t a3)
{
  return ETLGSDIPerformGetIccid(a1, 1, a2, a3);
}

uint64_t ETLGSDIMakeStringFromDigit(unint64_t a1, unsigned int a2, uint8x16_t *a3, unsigned int a4)
{
  uint64_t v4 = 0;
  if (!a1 || !a3) {
    return v4;
  }
  if (((2 * a4) | 1) > a2) {
    return 0;
  }
  if (!a4)
  {
    uint64_t v7 = 0;
    goto LABEL_12;
  }
  if (a4 >= 0x20)
  {
    LODWORD(v7) = 0;
    uint64_t v6 = 0;
    if (((unint64_t)a4 - 1) >> 32) {
      goto LABEL_8;
    }
    uint64_t v12 = 2 * (a4 - 1);
    if (a1 + v12 < a1 || a1 + 1 + v12 < a1 + 1) {
      goto LABEL_8;
    }
    if (a1 + 2 * a4 <= (unint64_t)a3 || (unint64_t)a3->u64 + a4 <= a1)
    {
      uint64_t v13 = 0;
      uint64_t v6 = a4 & 0xFFFFFFE0;
      LODWORD(v7) = 2 * (a4 & 0xFFFFFFE0);
      unint64_t v14 = a1 - 1;
      int v15 = a3 + 1;
      v16.i64[0] = 0x3030303030303030;
      v16.i64[1] = 0x3030303030303030;
      v17.i64[0] = 0xF0F0F0F0F0F0F0FLL;
      v17.i64[1] = 0xF0F0F0F0F0F0F0FLL;
      do
      {
        int8x16_t v18 = (int8x16_t)v15[-1];
        v19.i64[0] = 0x3030303030303030;
        v19.i64[1] = 0x3030303030303030;
        v23.val[0] = (int8x16_t)vsraq_n_u8(v19, (uint8x16_t)v18, 4uLL);
        v23.val[1] = vorrq_s8(vandq_s8(v18, v17), v16);
        v20.i64[0] = 0x3030303030303030;
        v20.i64[1] = 0x3030303030303030;
        v24.val[0] = (int8x16_t)vsraq_n_u8(v20, *v15, 4uLL);
        v24.val[1] = vorrq_s8(vandq_s8(*(int8x16_t *)v15, v17), v16);
        uint64_t v21 = (char *)(v14 + (v13 + 1));
        vst2q_s8(v21, v23);
        unsigned __int16 v22 = (char *)(v14 + (v13 + 33));
        vst2q_s8(v22, v24);
        v15 += 2;
        v13 += 64;
      }
      while (((2 * a4) & 0x1FFFFFFC0) != v13);
      if (v6 == a4) {
        goto LABEL_10;
      }
      goto LABEL_8;
    }
  }
  uint64_t v6 = 0;
  LODWORD(v7) = 0;
LABEL_8:
  uint64_t v8 = a4 - v6;
  uint64_t v9 = &a3->u8[v6];
  do
  {
    unsigned int v10 = *v9++;
    unsigned int v11 = v7 + 1;
    *(unsigned char *)(a1 + v7) = (v10 >> 4) | 0x30;
    LODWORD(v7) = v7 + 2;
    *(unsigned char *)(a1 + v11) = v10 & 0xF | 0x30;
    --v8;
  }
  while (v8);
LABEL_10:
  uint64_t v7 = v7;
LABEL_12:
  *(unsigned char *)(a1 + v7) = 0;
  return 1;
}

uint64_t ETLGSDIMakeStringFromICCID(unsigned char *a1, unsigned int a2, char *a3)
{
  if (a1) {
    BOOL v3 = a3 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  BOOL v4 = !v3 && a2 >= 0x15;
  int v5 = !v4;
  if (v4)
  {
    char v6 = *a3;
    *a1 = (*a3 >> 4) | 0x30;
    a1[1] = v6 & 0xF | 0x30;
    unsigned __int8 v7 = a3[1];
    a1[2] = (v7 >> 4) | 0x30;
    a1[3] = v7 & 0xF | 0x30;
    unsigned __int8 v8 = a3[2];
    a1[4] = (v8 >> 4) | 0x30;
    a1[5] = v8 & 0xF | 0x30;
    unsigned __int8 v9 = a3[3];
    a1[6] = (v9 >> 4) | 0x30;
    a1[7] = v9 & 0xF | 0x30;
    unsigned __int8 v10 = a3[4];
    a1[8] = (v10 >> 4) | 0x30;
    a1[9] = v10 & 0xF | 0x30;
    unsigned __int8 v11 = a3[5];
    a1[10] = (v11 >> 4) | 0x30;
    a1[11] = v11 & 0xF | 0x30;
    unsigned __int8 v12 = a3[6];
    a1[12] = (v12 >> 4) | 0x30;
    a1[13] = v12 & 0xF | 0x30;
    unsigned __int8 v13 = a3[7];
    a1[14] = (v13 >> 4) | 0x30;
    a1[15] = v13 & 0xF | 0x30;
    unsigned __int8 v14 = a3[8];
    a1[16] = (v14 >> 4) | 0x30;
    a1[17] = v14 & 0xF | 0x30;
    unsigned __int8 v15 = a3[9];
    a1[18] = (v15 >> 4) | 0x30;
    a1[19] = v15 & 0xF | 0x30;
    a1[20] = 0;
  }
  return v5 ^ 1u;
}

void *ETLGSDIGetPINStatus(void *a1, uint64_t a2, uint64_t a3, _WORD *a4, _DWORD *a5, uint64_t a6)
{
  v42[2] = *MEMORY[0x1E4F143B8];
  long long v39 = 0u;
  long long v40 = 0u;
  uint64_t v41 = 0;
  memset(v37, 0, sizeof(v37));
  uint64_t v38 = 0;
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_22;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
LABEL_22:
    PINStatusReponse = 0;
    goto LABEL_23;
  }
  LODWORD(v42[0]) = 336203;
  if ((HDLCFrameInject() & 1) == 0)
  {
    __int16 v33 = "ETLSubsysAddHeaderInternal";
    __int16 v34 = "Failed to inject\n";
LABEL_21:
    _ETLDebugPrint((uint64_t)v33, (uint64_t)v34, v19, v20, v21, v22, v23, v24, v36);
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 0x11)
  {
    uint64_t v36 = 18;
    __int16 v33 = "ETLRequireFreeSpace";
    __int16 v34 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_21;
  }
  v42[0] = 0;
  v42[1] = 0;
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInject();
  PINStatusReponse = 0;
  if (!HDLCFrameInjectUnsignedChar()) {
    goto LABEL_23;
  }
  PINStatusReponse = malloc((2 * DWORD2(v39) + 32));
  if (!PINStatusReponse) {
    goto LABEL_23;
  }
  uint64_t v26 = HDLCFrameEncode();
  if (!v26) {
    goto LABEL_24;
  }
  uint64_t v27 = v26;
  LODWORD(v42[0]) = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, PINStatusReponse, v26);
  }
  if (!*a1)
  {
LABEL_24:
    free(PINStatusReponse);
    goto LABEL_22;
  }
  int v28 = ((uint64_t (*)(void *, void *, uint64_t, void *, uint64_t, uint64_t, void))*a1)(a1, PINStatusReponse, v27, v42, 1, a6, 0);
  int v29 = v42[0];
  free(PINStatusReponse);
  PINStatusReponse = 0;
  if (v28 && v29 == v27)
  {
    LOBYTE(v42[0]) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    PINStatusReponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v37, (uint64_t)&_ETLResponseRingBuffer, v42, a6)&& LOBYTE(v42[0]) == 75)
    {
      PINStatusReponse = (void *)ETLGSDIParseGetPINStatusReponse((int **)v37, a5, a4, a2, a3, v30, v31, v32);
    }
  }
LABEL_23:
  HDLCFrameFree();
  HDLCFrameFree();
  return PINStatusReponse;
}

uint64_t ETLGSDIWaitForPINStatusEvent(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4, uint64_t a5)
{
  while (1)
  {
    char v35 = 96;
    memset(v36, 0, sizeof(v36));
    uint64_t v37 = 0;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    if (!ETLFindMatchingResponseUsingBuffer(a1, (unsigned __int8 **)v36, (uint64_t)&_ETLResponseRingBuffer, &v35, a5))break; {
    uint64_t v8 = a5;
    }
    v33[0] = 0;
    v33[1] = 0;
    uint64_t v34 = 0;
    if (ETLEVENTParseEventReport((uint64_t)v36, v33))
    {
      uint64_t v15 = v33[0];
      _ETLDebugPrint((uint64_t)"ETLGSDIWaitForPINStatusEvent", (uint64_t)"report has %u items\n", v9, v10, v11, v12, v13, v14, v34);
      char v22 = 0;
      char v23 = 1;
      if (v15)
      {
        do
        {
          if (*(_WORD *)v15 == 1002)
          {
            _ETLDebugPrint((uint64_t)"ETLGSDIWaitForPINStatusEvent", (uint64_t)"Found ID match\n", v16, v17, v18, v19, v20, v21, v30);
            if (*(unsigned __int8 *)(v15 + 24) < 7u)
            {
              char v23 = 0;
            }
            else
            {
              long long v25 = *(unsigned int **)(v15 + 16);
              uint64_t v26 = *v25;
              int v27 = *((unsigned __int8 *)v25 + 5);
              unsigned int v28 = *((unsigned __int8 *)v25 + 4) | (v27 << 8);
              _ETLDebugPrint((uint64_t)"ETLGSDIWaitForPINStatusEvent", (uint64_t)"TransactionID %u, expected %u\n", v16, v17, v18, v19, v20, v21, v28);
              if (v28 == a2)
              {
                *a3 = v26;
                if (v26)
                {
                  _ETLDebugPrint((uint64_t)"ETLGSDIWaitForPINStatusEvent", (uint64_t)"Status was %u\n", v16, v17, v18, v19, v20, v21, v26);
                  char v23 = 0;
                }
                else
                {
                  *a4 = v27;
                  char v23 = 1;
                }
                char v22 = 1;
              }
              else
              {
                char v23 = 1;
              }
            }
          }
          uint64_t v15 = *(void *)(v15 + 32);
          if (v15) {
            BOOL v24 = (v23 & 1) == 0;
          }
          else {
            BOOL v24 = 1;
          }
        }
        while (!v24);
      }
    }
    else
    {
      char v23 = 0;
      char v22 = 0;
    }
    a5 = v8;
    HDLCFrameFree();
    if (v23 & 1) == 0 || (v22) {
      return v23 & 1;
    }
  }
  char v23 = 0;
  HDLCFrameFree();
  return v23 & 1;
}

uint64_t APPLIB_DIAG_FTM_SetRFMode(unsigned __int8 *a1, int a2, __int16 a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xF) {
    return result;
  }
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  int v7 = gModeId;
  a1[2] = gModeId;
  int v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 7;
  *((_WORD *)a1 + 3) = a3;
  char v9 = HIBYTE(a3);
  unsigned __int16 v10 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 7];
  int v11 = a1[5];
  unsigned int v12 = crc_16_l_table[(v11 ^ v10 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]))];
  unsigned int v13 = crc_16_l_table[(v12 ^ HIBYTE(v10) ^ a3)];
  int v14 = crc_16_l_table[HIBYTE(a3) ^ crc_16_l_table[(v12 ^ HIBYTE(v10) ^ a3)] ^ (v12 >> 8)];
  *((_WORD *)a1 + 4) = v14 ^ ~HIBYTE(crc_16_l_table[(v12 ^ HIBYTE(v10) ^ a3)]);
  if (a2 < 20) {
    return 0xFFFFFFFFLL;
  }
  int v26 = v14 ^ ~(v13 >> 8);
  bzero(v28, 0x7FEuLL);
  __int16 __src = 2891;
  if ((v7 - 125) <= 1)
  {
    v28[0] = 125;
    int v15 = 3;
    v28[1] = v7 ^ 0x20;
    uint64_t v16 = 4;
    if ((v8 - 125) > 1) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v15 = 2;
  v28[0] = v7;
  uint64_t v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v28[v16 - 2] = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v16) = v15 + 2;
  }
LABEL_10:
  char v17 = a3;
  uint64_t v18 = &v28[v16 - 2];
  unsigned char *v18 = v8;
  v18[1] = 7;
  uint64_t v19 = v16 + 2;
  if ((v11 - 125) <= 1)
  {
    v28[v19 - 2] = 125;
    LOBYTE(v11) = v11 ^ 0x20;
    LODWORD(v19) = v16 + 3;
  }
  v28[v19 - 2] = v11;
  uint64_t v20 = v19 + 1;
  if (a3 - 125 <= 1)
  {
    v28[v20 - 2] = 125;
    char v17 = a3 ^ 0x20;
    LODWORD(v20) = v19 + 2;
  }
  int v21 = ~(v14 ^ BYTE1(v13));
  v28[v20 - 2] = v17;
  uint64_t v22 = v20 + 1;
  if (HIBYTE(a3) - 125 <= 1)
  {
    v28[v22 - 2] = 125;
    char v9 = HIBYTE(a3) ^ 0x20;
    LODWORD(v22) = v20 + 2;
  }
  char v23 = (unsigned __int16)(v14 ^ ~(unsigned __int16)(v13 >> 8)) >> 8;
  v28[v22 - 2] = v9;
  uint64_t v24 = v22 + 1;
  if ((v21 - 125) <= 1)
  {
    v28[v24 - 2] = 125;
    LOBYTE(v21) = v21 ^ 0x20;
    LODWORD(v24) = v22 + 2;
  }
  v28[v24 - 2] = v21;
  uint64_t v25 = v24 + 1;
  if (BYTE1(v26) - 125 <= 1)
  {
    v28[v25 - 2] = 125;
    char v23 = BYTE1(v26) ^ 0x20;
    LODWORD(v25) = v24 + 2;
  }
  v28[v25 - 2] = v23;
  memcpy(a1, &__src, v25 + 1);
  uint64_t result = (v25 + 2);
  a1[v25 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetChannel(unsigned __int8 *a1, int a2, __int16 a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xF) {
    return result;
  }
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  int v7 = gModeId;
  a1[2] = gModeId;
  int v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 8;
  *((_WORD *)a1 + 3) = a3;
  char v9 = HIBYTE(a3);
  unsigned __int16 v10 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 8];
  int v11 = a1[5];
  unsigned int v12 = crc_16_l_table[(v11 ^ v10 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]))];
  unsigned int v13 = crc_16_l_table[(v12 ^ HIBYTE(v10) ^ a3)];
  int v14 = crc_16_l_table[HIBYTE(a3) ^ crc_16_l_table[(v12 ^ HIBYTE(v10) ^ a3)] ^ (v12 >> 8)];
  *((_WORD *)a1 + 4) = v14 ^ ~HIBYTE(crc_16_l_table[(v12 ^ HIBYTE(v10) ^ a3)]);
  if (a2 < 20) {
    return 0xFFFFFFFFLL;
  }
  int v26 = v14 ^ ~(v13 >> 8);
  bzero(v28, 0x7FEuLL);
  __int16 __src = 2891;
  if ((v7 - 125) <= 1)
  {
    v28[0] = 125;
    int v15 = 3;
    v28[1] = v7 ^ 0x20;
    uint64_t v16 = 4;
    if ((v8 - 125) > 1) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v15 = 2;
  v28[0] = v7;
  uint64_t v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v28[v16 - 2] = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v16) = v15 + 2;
  }
LABEL_10:
  char v17 = a3;
  uint64_t v18 = &v28[v16 - 2];
  unsigned char *v18 = v8;
  v18[1] = 8;
  uint64_t v19 = v16 + 2;
  if ((v11 - 125) <= 1)
  {
    v28[v19 - 2] = 125;
    LOBYTE(v11) = v11 ^ 0x20;
    LODWORD(v19) = v16 + 3;
  }
  v28[v19 - 2] = v11;
  uint64_t v20 = v19 + 1;
  if (a3 - 125 <= 1)
  {
    v28[v20 - 2] = 125;
    char v17 = a3 ^ 0x20;
    LODWORD(v20) = v19 + 2;
  }
  int v21 = ~(v14 ^ BYTE1(v13));
  v28[v20 - 2] = v17;
  uint64_t v22 = v20 + 1;
  if (HIBYTE(a3) - 125 <= 1)
  {
    v28[v22 - 2] = 125;
    char v9 = HIBYTE(a3) ^ 0x20;
    LODWORD(v22) = v20 + 2;
  }
  char v23 = (unsigned __int16)(v14 ^ ~(unsigned __int16)(v13 >> 8)) >> 8;
  v28[v22 - 2] = v9;
  uint64_t v24 = v22 + 1;
  if ((v21 - 125) <= 1)
  {
    v28[v24 - 2] = 125;
    LOBYTE(v21) = v21 ^ 0x20;
    LODWORD(v24) = v22 + 2;
  }
  v28[v24 - 2] = v21;
  uint64_t v25 = v24 + 1;
  if (BYTE1(v26) - 125 <= 1)
  {
    v28[v25 - 2] = 125;
    char v23 = BYTE1(v26) ^ 0x20;
    LODWORD(v25) = v24 + 2;
  }
  v28[v25 - 2] = v23;
  memcpy(a1, &__src, v25 + 1);
  uint64_t result = (v25 + 2);
  a1[v25 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_Tx_On(unsigned __int8 *a1, int a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0xD)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    int v5 = gModeId;
    a1[2] = gModeId;
    int v6 = HIBYTE(gModeId);
    a1[3] = HIBYTE(gModeId);
    a1[4] = 2;
    int v7 = crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC];
    unsigned int v8 = crc_16_l_table[v7 ^ HIBYTE(crc_16_l_table[v5 ^ 0xA5]) ^ 2];
    int v9 = a1[5];
    int v10 = crc_16_l_table[(v9 ^ v8 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC]))];
    int v11 = v10 ^ ~(v8 >> 8);
    *((_WORD *)a1 + 3) = v10 ^ ~HIBYTE(crc_16_l_table[v7 ^ HIBYTE(crc_16_l_table[v5 ^ 0xA5]) ^ 2]);
    if (a2 >= 16)
    {
      bzero(v21, 0x7FEuLL);
      __int16 __src = 2891;
      if ((v5 - 125) > 1)
      {
        unsigned int v12 = 2;
      }
      else
      {
        v21[0] = 125;
        LOBYTE(v5) = v5 ^ 0x20;
        unsigned int v12 = 3;
      }
      v21[v12 - 2] = v5;
      uint64_t v13 = v12 + 1;
      if ((v6 - 125) <= 1)
      {
        v21[v13 - 2] = 125;
        LODWORD(v13) = v12 + 2;
        LOBYTE(v6) = v6 ^ 0x20;
      }
      int v14 = ~(v10 ^ BYTE1(v8));
      int v15 = &v21[v13 - 2];
      char *v15 = v6;
      v15[1] = 2;
      uint64_t v16 = v13 + 2;
      if ((v9 - 125) <= 1)
      {
        v21[v16 - 2] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v16) = v13 + 3;
      }
      char v17 = (unsigned __int16)(v10 ^ ~(unsigned __int16)(v8 >> 8)) >> 8;
      v21[v16 - 2] = v9;
      uint64_t v18 = v16 + 1;
      if ((v14 - 125) <= 1)
      {
        v21[v18 - 2] = 125;
        LOBYTE(v14) = v14 ^ 0x20;
        LODWORD(v18) = v16 + 2;
      }
      v21[v18 - 2] = v14;
      uint64_t v19 = v18 + 1;
      if (BYTE1(v11) - 125 <= 1)
      {
        v21[v19 - 2] = 125;
        char v17 = BYTE1(v11) ^ 0x20;
        LODWORD(v19) = v18 + 2;
      }
      v21[v19 - 2] = v17;
      memcpy(a1, &__src, v19 + 1);
      uint64_t result = (v19 + 2);
      a1[v19 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_Tx_Off(unsigned __int8 *a1, int a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0xD)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    int v5 = gModeId;
    a1[2] = gModeId;
    int v6 = HIBYTE(gModeId);
    a1[3] = HIBYTE(gModeId);
    a1[4] = 3;
    int v7 = crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC];
    unsigned int v8 = crc_16_l_table[v7 ^ HIBYTE(crc_16_l_table[v5 ^ 0xA5]) ^ 3];
    int v9 = a1[5];
    int v10 = crc_16_l_table[(v9 ^ v8 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC]))];
    int v11 = v10 ^ ~(v8 >> 8);
    *((_WORD *)a1 + 3) = v10 ^ ~HIBYTE(crc_16_l_table[v7 ^ HIBYTE(crc_16_l_table[v5 ^ 0xA5]) ^ 3]);
    if (a2 >= 16)
    {
      bzero(v21, 0x7FEuLL);
      __int16 __src = 2891;
      if ((v5 - 125) > 1)
      {
        unsigned int v12 = 2;
      }
      else
      {
        v21[0] = 125;
        LOBYTE(v5) = v5 ^ 0x20;
        unsigned int v12 = 3;
      }
      v21[v12 - 2] = v5;
      uint64_t v13 = v12 + 1;
      if ((v6 - 125) <= 1)
      {
        v21[v13 - 2] = 125;
        LODWORD(v13) = v12 + 2;
        LOBYTE(v6) = v6 ^ 0x20;
      }
      int v14 = ~(v10 ^ BYTE1(v8));
      int v15 = &v21[v13 - 2];
      char *v15 = v6;
      v15[1] = 3;
      uint64_t v16 = v13 + 2;
      if ((v9 - 125) <= 1)
      {
        v21[v16 - 2] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v16) = v13 + 3;
      }
      char v17 = (unsigned __int16)(v10 ^ ~(unsigned __int16)(v8 >> 8)) >> 8;
      v21[v16 - 2] = v9;
      uint64_t v18 = v16 + 1;
      if ((v14 - 125) <= 1)
      {
        v21[v18 - 2] = 125;
        LOBYTE(v14) = v14 ^ 0x20;
        LODWORD(v18) = v16 + 2;
      }
      v21[v18 - 2] = v14;
      uint64_t v19 = v18 + 1;
      if (BYTE1(v11) - 125 <= 1)
      {
        v21[v19 - 2] = 125;
        char v17 = BYTE1(v11) ^ 0x20;
        LODWORD(v19) = v18 + 2;
      }
      v21[v19 - 2] = v17;
      memcpy(a1, &__src, v19 + 1);
      uint64_t result = (v19 + 2);
      a1[v19 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetWaveForm(unsigned __int8 *a1, int a2, int a3, int a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xF) {
    return result;
  }
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  *((_WORD *)a1 + 1) = gModeId;
  if (a3)
  {
    if (a3 != 1) {
      return 0xFFFFFFFFLL;
    }
    if (a4)
    {
      if (a4 == 1)
      {
        a1[4] = -120;
        unsigned int v9 = 10;
        int v10 = 64;
        char v11 = 1;
        uint64_t v12 = 9;
        uint64_t v13 = 8;
        uint64_t v14 = 7;
        uint64_t v15 = 6;
        char v16 = 1;
        goto LABEL_11;
      }
      return 0xFFFFFFFFLL;
    }
    unsigned int v9 = 9;
    int v10 = 56;
    char v16 = 1;
  }
  else
  {
    char v16 = 0;
    unsigned int v9 = 9;
    int v10 = 56;
  }
  char v11 = 50;
  uint64_t v12 = 8;
  uint64_t v13 = 7;
  uint64_t v14 = 6;
  uint64_t v15 = 4;
LABEL_11:
  a1[v15] = v11;
  a1[v14] = v16;
  LOWORD(v17) = -1;
  uint64_t v18 = (char *)a1;
  do
  {
    char v19 = *v18++;
    int v17 = crc_16_l_table[(v19 ^ v17)] ^ ((unsigned __int16)(v17 & 0xFF00) >> 8);
    v10 -= 8;
  }
  while ((_WORD)v10);
  a1[v13] = ~(_BYTE)v17;
  a1[v12] = (unsigned __int16)~(_WORD)v17 >> 8;
  if (a2 < (int)(2 * v9)) {
    return 0xFFFFFFFFLL;
  }
  bzero(__src, 0x800uLL);
  uint64_t v20 = 0;
  LODWORD(v21) = 0;
  uint64_t v22 = v9;
  do
  {
    while (1)
    {
      int v24 = a1[v20];
      if ((v24 - 125) > 1) {
        break;
      }
      int v23 = v21 + 1;
      __src[(int)v21] = 125;
      __src[(int)v21 + 1] = v24 ^ 0x20;
      size_t v21 = (int)v21 + 1 + 1;
      if (v22 == ++v20) {
        goto LABEL_19;
      }
    }
    int v23 = v21;
    __src[(int)v21] = v24;
    size_t v21 = (int)v21 + 1;
    ++v20;
  }
  while (v22 != v20);
LABEL_19:
  memcpy(a1, __src, v21);
  uint64_t result = (v23 + 2);
  a1[v21] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetPARange(unsigned __int8 *a1, int a2, unsigned __int8 a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xF) {
    return result;
  }
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  int v7 = gModeId;
  a1[2] = gModeId;
  int v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 54;
  a1[6] = a3;
  unsigned __int16 v9 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 0x36];
  int v10 = a1[5];
  unsigned __int16 v11 = crc_16_l_table[(v10 ^ v9 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]))];
  unsigned int v12 = crc_16_l_table[(v11 ^ HIBYTE(v9) ^ a3)];
  int v13 = crc_16_l_table[(a1[7] ^ v12 ^ HIBYTE(v11))];
  int v14 = v13 ^ ~(v12 >> 8);
  *((_WORD *)a1 + 4) = v13 ^ ~HIBYTE(crc_16_l_table[(v11 ^ HIBYTE(v9) ^ a3)]);
  if (a2 < 20) {
    return 0xFFFFFFFFLL;
  }
  bzero(v28, 0x7FEuLL);
  __int16 v27 = 2891;
  if ((v7 - 125) <= 1)
  {
    v28[0] = 125;
    int v15 = 3;
    v28[1] = v7 ^ 0x20;
    uint64_t v16 = 4;
    if ((v8 - 125) > 1) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v15 = 2;
  v28[0] = v7;
  uint64_t v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v28[v16 - 2] = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v16) = v15 + 2;
  }
LABEL_10:
  char v17 = a3;
  uint64_t v18 = &v28[v16 - 2];
  unsigned char *v18 = v8;
  v18[1] = 54;
  uint64_t v19 = v16 + 2;
  if ((v10 - 125) <= 1)
  {
    v28[v19 - 2] = 125;
    LOBYTE(v10) = v10 ^ 0x20;
    LODWORD(v19) = v16 + 3;
  }
  v28[v19 - 2] = v10;
  uint64_t v20 = v19 + 1;
  if (a3 - 125 <= 1)
  {
    v28[v20 - 2] = 125;
    LODWORD(v20) = v19 + 2;
    char v17 = a3 ^ 0x20;
  }
  int v21 = ~(v13 ^ BYTE1(v12));
  v28[v20 - 2] = v17;
  uint64_t v22 = v20 + 1;
  int v23 = a1[7];
  if ((v23 - 125) <= 1)
  {
    v28[v22 - 2] = 125;
    LOBYTE(v23) = v23 ^ 0x20;
    LODWORD(v22) = v20 + 2;
  }
  char v24 = (unsigned __int16)(v13 ^ ~(unsigned __int16)(v12 >> 8)) >> 8;
  v28[v22 - 2] = v23;
  uint64_t v25 = v22 + 1;
  if ((v21 - 125) <= 1)
  {
    v28[v25 - 2] = 125;
    LODWORD(v25) = v22 + 2;
    LOBYTE(v21) = v21 ^ 0x20;
  }
  v28[v25 - 2] = v21;
  uint64_t v26 = v25 + 1;
  if (BYTE1(v14) - 125 <= 1)
  {
    v28[v26 - 2] = 125;
    char v24 = BYTE1(v14) ^ 0x20;
    LODWORD(v26) = v25 + 2;
  }
  v28[v26 - 2] = v24;
  memcpy(a1, &v27, v26 + 1);
  uint64_t result = (v26 + 2);
  a1[v26 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetPDM(unsigned __int8 *a1, int a2, unsigned __int8 a3, unsigned __int8 a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0x11) {
    return result;
  }
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  int v9 = gModeId;
  a1[2] = gModeId;
  int v10 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 0;
  a1[6] = a3;
  a1[8] = a4;
  unsigned __int16 v11 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v9 ^ 0xA5])];
  int v12 = a1[5];
  unsigned __int16 v13 = crc_16_l_table[(v12 ^ v11 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC]))];
  unsigned __int16 v14 = crc_16_l_table[(v13 ^ HIBYTE(v11) ^ a3)];
  unsigned __int16 v15 = crc_16_l_table[(a1[7] ^ v14 ^ HIBYTE(v13))];
  unsigned int v16 = crc_16_l_table[(v15 ^ HIBYTE(v14) ^ a4)];
  int v17 = crc_16_l_table[(a1[9] ^ v16 ^ HIBYTE(v15))];
  *((_WORD *)a1 + 5) = v17 ^ ~HIBYTE(crc_16_l_table[(v15 ^ HIBYTE(v14) ^ a4)]);
  if (a2 < 24) {
    return 0xFFFFFFFFLL;
  }
  int v34 = v17 ^ ~(v16 >> 8);
  bzero(v36, 0x7FEuLL);
  __int16 __src = 2891;
  if ((v9 - 125) <= 1)
  {
    v36[0] = 125;
    int v18 = 3;
    v36[1] = v9 ^ 0x20;
    uint64_t v19 = 4;
    if ((v10 - 125) > 1) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v18 = 2;
  v36[0] = v9;
  uint64_t v19 = 3;
  if ((v10 - 125) <= 1)
  {
LABEL_9:
    v36[v19 - 2] = 125;
    LOBYTE(v10) = v10 ^ 0x20;
    LODWORD(v19) = v18 + 2;
  }
LABEL_10:
  char v20 = a3;
  int v21 = &v36[v19 - 2];
  unsigned char *v21 = v10;
  v21[1] = 0;
  uint64_t v22 = v19 + 2;
  if ((v12 - 125) <= 1)
  {
    v36[v22 - 2] = 125;
    LOBYTE(v12) = v12 ^ 0x20;
    LODWORD(v22) = v19 + 3;
  }
  v36[v22 - 2] = v12;
  uint64_t v23 = v22 + 1;
  if (a3 - 125 <= 1)
  {
    v36[v23 - 2] = 125;
    char v20 = a3 ^ 0x20;
    LODWORD(v23) = v22 + 2;
  }
  char v24 = a4;
  v36[v23 - 2] = v20;
  uint64_t v25 = v23 + 1;
  int v26 = a1[7];
  if ((v26 - 125) <= 1)
  {
    v36[v25 - 2] = 125;
    LODWORD(v25) = v23 + 2;
    LOBYTE(v26) = v26 ^ 0x20;
  }
  v36[v25 - 2] = v26;
  uint64_t v27 = v25 + 1;
  if (a4 - 125 <= 1)
  {
    v36[v27 - 2] = 125;
    char v24 = a4 ^ 0x20;
    LODWORD(v27) = v25 + 2;
  }
  int v28 = ~(v17 ^ BYTE1(v16));
  v36[v27 - 2] = v24;
  uint64_t v29 = v27 + 1;
  int v30 = a1[9];
  if ((v30 - 125) <= 1)
  {
    v36[v29 - 2] = 125;
    LOBYTE(v30) = v30 ^ 0x20;
    LODWORD(v29) = v27 + 2;
  }
  char v31 = (unsigned __int16)(v17 ^ ~(unsigned __int16)(v16 >> 8)) >> 8;
  v36[v29 - 2] = v30;
  uint64_t v32 = v29 + 1;
  if ((v28 - 125) <= 1)
  {
    v36[v32 - 2] = 125;
    LODWORD(v32) = v29 + 2;
    LOBYTE(v28) = v28 ^ 0x20;
  }
  v36[v32 - 2] = v28;
  uint64_t v33 = v32 + 1;
  if (BYTE1(v34) - 125 <= 1)
  {
    v36[v33 - 2] = 125;
    char v31 = BYTE1(v34) ^ 0x20;
    LODWORD(v33) = v32 + 2;
  }
  v36[v33 - 2] = v31;
  memcpy(a1, &__src, v33 + 1);
  uint64_t result = (v33 + 2);
  a1[v33 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_ExecuteTxSweep(unsigned __int8 *a1, int a2, unsigned __int8 a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xE) {
    return result;
  }
  int v6 = a3;
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  int v7 = gModeId;
  a1[2] = gModeId;
  int v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 116;
  a1[6] = v6;
  unsigned __int16 v9 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 0x74];
  int v10 = a1[5];
  uint64_t v11 = (v10 ^ v9 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]));
  unsigned int v12 = crc_16_l_table[v11];
  int v13 = crc_16_l_table[(v12 ^ HIBYTE(v9)) ^ v6];
  int v14 = v13 ^ ~(v12 >> 8);
  *(_WORD *)(a1 + 7) = v13 ^ ~HIBYTE(crc_16_l_table[v11]);
  if (a2 < 18) {
    return 0xFFFFFFFFLL;
  }
  bzero(v25, 0x7FEuLL);
  __int16 v24 = 2891;
  if ((v7 - 125) <= 1)
  {
    v25[0] = 125;
    int v15 = 3;
    v25[1] = v7 ^ 0x20;
    uint64_t v16 = 4;
    if ((v8 - 125) > 1) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v15 = 2;
  v25[0] = v7;
  uint64_t v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v25[v16 - 2] = 125;
    LODWORD(v16) = v15 + 2;
    LOBYTE(v8) = v8 ^ 0x20;
  }
LABEL_10:
  int v17 = &v25[v16 - 2];
  unsigned char *v17 = v8;
  v17[1] = 116;
  uint64_t v18 = v16 + 2;
  if ((v10 - 125) <= 1)
  {
    v25[v18 - 2] = 125;
    LOBYTE(v10) = v10 ^ 0x20;
    LODWORD(v18) = v16 + 3;
  }
  int v19 = ~(v13 ^ BYTE1(v12));
  v25[v18 - 2] = v10;
  uint64_t v20 = v18 + 1;
  if ((v6 - 125) <= 1)
  {
    v25[v20 - 2] = 125;
    LOBYTE(v6) = v6 ^ 0x20;
    LODWORD(v20) = v18 + 2;
  }
  char v21 = (unsigned __int16)(v13 ^ ~(unsigned __int16)(v12 >> 8)) >> 8;
  v25[v20 - 2] = v6;
  uint64_t v22 = v20 + 1;
  if ((v19 - 125) <= 1)
  {
    v25[v22 - 2] = 125;
    LODWORD(v22) = v20 + 2;
    LOBYTE(v19) = v19 ^ 0x20;
  }
  v25[v22 - 2] = v19;
  uint64_t v23 = v22 + 1;
  if (BYTE1(v14) - 125 <= 1)
  {
    v25[v23 - 2] = 125;
    char v21 = BYTE1(v14) ^ 0x20;
    LODWORD(v23) = v22 + 2;
  }
  v25[v23 - 2] = v21;
  memcpy(a1, &v24, v23 + 1);
  uint64_t result = (v23 + 2);
  a1[v23 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetPDMStepSize(unsigned __int8 *a1, int a2, unsigned __int8 a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xE) {
    return result;
  }
  int v6 = a3;
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  int v7 = gModeId;
  a1[2] = gModeId;
  int v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = -127;
  a1[6] = v6;
  unsigned __int16 v9 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 0x81];
  int v10 = a1[5];
  uint64_t v11 = (v10 ^ v9 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]));
  unsigned int v12 = crc_16_l_table[v11];
  int v13 = crc_16_l_table[(v12 ^ HIBYTE(v9)) ^ v6];
  int v14 = v13 ^ ~(v12 >> 8);
  *(_WORD *)(a1 + 7) = v13 ^ ~HIBYTE(crc_16_l_table[v11]);
  if (a2 < 18) {
    return 0xFFFFFFFFLL;
  }
  bzero(v25, 0x7FEuLL);
  __int16 v24 = 2891;
  if ((v7 - 125) <= 1)
  {
    v25[0] = 125;
    int v15 = 3;
    v25[1] = v7 ^ 0x20;
    uint64_t v16 = 4;
    if ((v8 - 125) > 1) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v15 = 2;
  v25[0] = v7;
  uint64_t v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v25[v16 - 2] = 125;
    LODWORD(v16) = v15 + 2;
    LOBYTE(v8) = v8 ^ 0x20;
  }
LABEL_10:
  int v17 = &v25[v16 - 2];
  unsigned char *v17 = v8;
  v17[1] = -127;
  uint64_t v18 = v16 + 2;
  if ((v10 - 125) <= 1)
  {
    v25[v18 - 2] = 125;
    LOBYTE(v10) = v10 ^ 0x20;
    LODWORD(v18) = v16 + 3;
  }
  int v19 = ~(v13 ^ BYTE1(v12));
  v25[v18 - 2] = v10;
  uint64_t v20 = v18 + 1;
  if ((v6 - 125) <= 1)
  {
    v25[v20 - 2] = 125;
    LOBYTE(v6) = v6 ^ 0x20;
    LODWORD(v20) = v18 + 2;
  }
  char v21 = (unsigned __int16)(v13 ^ ~(unsigned __int16)(v12 >> 8)) >> 8;
  v25[v20 - 2] = v6;
  uint64_t v22 = v20 + 1;
  if ((v19 - 125) <= 1)
  {
    v25[v22 - 2] = 125;
    LODWORD(v22) = v20 + 2;
    LOBYTE(v19) = v19 ^ 0x20;
  }
  v25[v22 - 2] = v19;
  uint64_t v23 = v22 + 1;
  if (BYTE1(v14) - 125 <= 1)
  {
    v25[v23 - 2] = 125;
    char v21 = BYTE1(v14) ^ 0x20;
    LODWORD(v23) = v22 + 2;
  }
  v25[v23 - 2] = v21;
  memcpy(a1, &v24, v23 + 1);
  uint64_t result = (v23 + 2);
  a1[v23 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_ConfigTxSweep(unsigned __int8 *a1, int a2, __int16 a3, __int16 a4)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x11)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    int v9 = gModeId;
    a1[2] = gModeId;
    int v10 = HIBYTE(gModeId);
    a1[3] = HIBYTE(gModeId);
    a1[4] = 125;
    *((_WORD *)a1 + 3) = a3;
    char v11 = HIBYTE(a3);
    *((_WORD *)a1 + 4) = a4;
    char v12 = HIBYTE(a4);
    unsigned __int16 v13 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v9 ^ 0xA5]) ^ 0x7D];
    int v14 = a1[5];
    unsigned __int16 v15 = crc_16_l_table[(v14 ^ v13 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC]))];
    unsigned __int16 v16 = crc_16_l_table[(v15 ^ HIBYTE(v13) ^ a3)];
    unsigned int v17 = crc_16_l_table[(HIBYTE(a3) ^ v16 ^ HIBYTE(v15))];
    unsigned int v18 = crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))];
    int v19 = crc_16_l_table[HIBYTE(a4) ^ crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))] ^ (v17 >> 8)];
    *((_WORD *)a1 + 5) = v19 ^ ~(unsigned __int16)(v18 >> 8);
    if (a2 >= 24)
    {
      char v38 = v19;
      int v39 = v19 ^ ~(v18 >> 8);
      bzero(__src, 0x800uLL);
      int v20 = *a1;
      if ((v20 - 125) > 1)
      {
        unsigned int v21 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v20) = v20 ^ 0x20;
        unsigned int v21 = 1;
      }
      __src[v21] = v20;
      uint64_t v22 = v21 + 1;
      int v23 = a1[1];
      if ((v23 - 125) <= 1)
      {
        __src[v22] = 125;
        LODWORD(v22) = v21 | 2;
        LOBYTE(v23) = v23 ^ 0x20;
      }
      __src[v22] = v23;
      uint64_t v24 = v22 + 1;
      if ((v9 - 125) <= 1)
      {
        __src[v24] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v24) = v22 + 2;
      }
      __src[v24] = v9;
      uint64_t v25 = v24 + 1;
      if ((v10 - 125) <= 1)
      {
        __src[v25] = 125;
        LOBYTE(v10) = v10 ^ 0x20;
        LODWORD(v25) = v24 + 2;
      }
      char v26 = a3;
      uint64_t v27 = &__src[v25];
      unsigned char *v27 = v10;
      *(_WORD *)(v27 + 1) = 23933;
      uint64_t v28 = v25 + 3;
      if ((v14 - 125) <= 1)
      {
        __src[v28] = 125;
        LOBYTE(v14) = v14 ^ 0x20;
        LODWORD(v28) = v25 + 4;
      }
      __src[v28] = v14;
      uint64_t v29 = v28 + 1;
      if (a3 - 125 <= 1)
      {
        __src[v29] = 125;
        char v26 = a3 ^ 0x20;
        LODWORD(v29) = v28 + 2;
      }
      char v30 = a4;
      __src[v29] = v26;
      uint64_t v31 = v29 + 1;
      if (HIBYTE(a3) - 125 <= 1)
      {
        __src[v31] = 125;
        LODWORD(v31) = v29 + 2;
        char v11 = HIBYTE(a3) ^ 0x20;
      }
      __src[v31] = v11;
      uint64_t v32 = v31 + 1;
      if (a4 - 125 <= 1)
      {
        __src[v32] = 125;
        char v30 = a4 ^ 0x20;
        LODWORD(v32) = v31 + 2;
      }
      int v33 = ~(v38 ^ BYTE1(v18));
      __src[v32] = v30;
      uint64_t v34 = v32 + 1;
      if (HIBYTE(a4) - 125 <= 1)
      {
        __src[v34] = 125;
        char v12 = HIBYTE(a4) ^ 0x20;
        LODWORD(v34) = v32 + 2;
      }
      char v35 = BYTE1(v39);
      __src[v34] = v12;
      uint64_t v36 = v34 + 1;
      if ((v33 - 125) <= 1)
      {
        __src[v36] = 125;
        LODWORD(v36) = v34 + 2;
        LOBYTE(v33) = v33 ^ 0x20;
      }
      __src[v36] = v33;
      uint64_t v37 = v36 + 1;
      if (BYTE1(v39) - 125 <= 1)
      {
        __src[v37] = 125;
        char v35 = BYTE1(v39) ^ 0x20;
        LODWORD(v37) = v36 + 2;
      }
      __src[v37] = v35;
      memcpy(a1, __src, v37 + 1);
      uint64_t result = (v37 + 2);
      a1[v37 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_GetAllHDETValues(unsigned __int8 *a1, int a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x2D)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    *((_WORD *)a1 + 1) = gModeId;
    a1[4] = -112;
    int v5 = 560;
    LOWORD(v6) = -1;
    int v7 = (char *)a1;
    do
    {
      char v8 = *v7++;
      int v6 = crc_16_l_table[(v8 ^ v6)] ^ ((unsigned __int16)(v6 & 0xFF00) >> 8);
      v5 -= 8;
    }
    while ((_WORD)v5);
    *((_WORD *)a1 + 35) = ~(_WORD)v6;
    if (a2 >= 144)
    {
      bzero(__src, 0x800uLL);
      uint64_t v9 = 0;
      LODWORD(v10) = 0;
      do
      {
        while (1)
        {
          int v12 = a1[v9];
          if ((v12 - 125) > 1) {
            break;
          }
          int v11 = v10 + 1;
          __src[(int)v10] = 125;
          __src[(int)v10 + 1] = v12 ^ 0x20;
          size_t v10 = (int)v10 + 1 + 1;
          if (++v9 == 72) {
            goto LABEL_11;
          }
        }
        int v11 = v10;
        __src[(int)v10] = v12;
        size_t v10 = (int)v10 + 1;
        ++v9;
      }
      while (v9 != 72);
LABEL_11:
      memcpy(a1, __src, v10);
      uint64_t result = (v11 + 2);
      a1[v10] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_GetADCValue(unsigned __int8 *a1, int a2, unsigned __int8 a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0x11) {
    return result;
  }
  int v6 = a3;
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  int v7 = gModeId;
  a1[2] = gModeId;
  int v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 59;
  a1[6] = v6;
  *((_WORD *)a1 + 4) = -14636;
  unsigned __int16 v9 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 0x3B];
  int v10 = a1[5];
  unsigned __int16 v11 = crc_16_l_table[(v10 ^ v9 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]))];
  unsigned __int16 v12 = crc_16_l_table[(v11 ^ HIBYTE(v9)) ^ v6];
  unsigned int v13 = crc_16_l_table[(a1[7] ^ v12 ^ HIBYTE(v11))];
  unsigned int v14 = crc_16_l_table[(v13 ^ HIBYTE(v12)) ^ 0xD4];
  int v15 = crc_16_l_table[crc_16_l_table[(v13 ^ HIBYTE(v12)) ^ 0xD4] ^ (v13 >> 8) ^ 0xC6];
  int v16 = v15 ^ ~(v14 >> 8);
  *((_WORD *)a1 + 5) = v15 ^ ~HIBYTE(crc_16_l_table[(v13 ^ HIBYTE(v12)) ^ 0xD4]);
  if (a2 < 24) {
    return 0xFFFFFFFFLL;
  }
  bzero(v30, 0x7FEuLL);
  __int16 v29 = 2891;
  if ((v7 - 125) <= 1)
  {
    v30[0] = 125;
    int v17 = 3;
    v30[1] = v7 ^ 0x20;
    uint64_t v18 = 4;
    if ((v8 - 125) > 1) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v17 = 2;
  v30[0] = v7;
  uint64_t v18 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v30[v18 - 2] = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v18) = v17 + 2;
  }
LABEL_10:
  int v19 = &v30[v18 - 2];
  *int v19 = v8;
  v19[1] = 59;
  uint64_t v20 = v18 + 2;
  if ((v10 - 125) <= 1)
  {
    v30[v20 - 2] = 125;
    LODWORD(v20) = v18 + 3;
    LOBYTE(v10) = v10 ^ 0x20;
  }
  v30[v20 - 2] = v10;
  uint64_t v21 = v20 + 1;
  if ((v6 - 125) <= 1)
  {
    v30[v21 - 2] = 125;
    LOBYTE(v6) = v6 ^ 0x20;
    LODWORD(v21) = v20 + 2;
  }
  int v22 = ~(v15 ^ BYTE1(v14));
  v30[v21 - 2] = v6;
  uint64_t v23 = v21 + 1;
  int v24 = a1[7];
  if ((v24 - 125) <= 1)
  {
    v30[v23 - 2] = 125;
    LOBYTE(v24) = v24 ^ 0x20;
    LODWORD(v23) = v21 + 2;
  }
  char v25 = (unsigned __int16)(v15 ^ ~(unsigned __int16)(v14 >> 8)) >> 8;
  char v26 = &v30[v23 - 2];
  unsigned char *v26 = v24;
  *(_WORD *)(v26 + 1) = -14636;
  uint64_t v27 = v23 + 3;
  if ((v22 - 125) <= 1)
  {
    v30[v27 - 2] = 125;
    LOBYTE(v22) = v22 ^ 0x20;
    LODWORD(v27) = v23 + 4;
  }
  v30[v27 - 2] = v22;
  uint64_t v28 = v27 + 1;
  if (BYTE1(v16) - 125 <= 1)
  {
    v30[v28 - 2] = 125;
    char v25 = BYTE1(v16) ^ 0x20;
    LODWORD(v28) = v27 + 2;
  }
  v30[v28 - 2] = v25;
  memcpy(a1, &v29, v28 + 1);
  uint64_t result = (v28 + 2);
  a1[v28 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetHDETTracking(unsigned __int8 *a1, int a2, __int16 a3, __int16 a4)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x11)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    int v9 = gModeId;
    a1[2] = gModeId;
    int v10 = HIBYTE(gModeId);
    a1[3] = HIBYTE(gModeId);
    a1[4] = 124;
    *((_WORD *)a1 + 3) = a3;
    char v11 = HIBYTE(a3);
    *((_WORD *)a1 + 4) = a4;
    char v12 = HIBYTE(a4);
    unsigned __int16 v13 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v9 ^ 0xA5]) ^ 0x7C];
    int v14 = a1[5];
    unsigned __int16 v15 = crc_16_l_table[(v14 ^ v13 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC]))];
    unsigned __int16 v16 = crc_16_l_table[(v15 ^ HIBYTE(v13) ^ a3)];
    unsigned int v17 = crc_16_l_table[(HIBYTE(a3) ^ v16 ^ HIBYTE(v15))];
    unsigned int v18 = crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))];
    int v19 = crc_16_l_table[HIBYTE(a4) ^ crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))] ^ (v17 >> 8)];
    *((_WORD *)a1 + 5) = v19 ^ ~HIBYTE(crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))]);
    if (a2 >= 24)
    {
      char v38 = v19;
      int v39 = v19 ^ ~(v18 >> 8);
      bzero(__src, 0x800uLL);
      int v20 = *a1;
      if ((v20 - 125) > 1)
      {
        unsigned int v21 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v20) = v20 ^ 0x20;
        unsigned int v21 = 1;
      }
      __src[v21] = v20;
      uint64_t v22 = v21 + 1;
      int v23 = a1[1];
      if ((v23 - 125) <= 1)
      {
        __src[v22] = 125;
        LODWORD(v22) = v21 | 2;
        LOBYTE(v23) = v23 ^ 0x20;
      }
      __src[v22] = v23;
      uint64_t v24 = v22 + 1;
      if ((v9 - 125) <= 1)
      {
        __src[v24] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v24) = v22 + 2;
      }
      __src[v24] = v9;
      uint64_t v25 = v24 + 1;
      if ((v10 - 125) <= 1)
      {
        __src[v25] = 125;
        LOBYTE(v10) = v10 ^ 0x20;
        LODWORD(v25) = v24 + 2;
      }
      char v26 = a3;
      uint64_t v27 = &__src[v25];
      unsigned char *v27 = v10;
      v27[1] = 124;
      uint64_t v28 = v25 + 2;
      if ((v14 - 125) <= 1)
      {
        __src[v28] = 125;
        LOBYTE(v14) = v14 ^ 0x20;
        LODWORD(v28) = v25 + 3;
      }
      __src[v28] = v14;
      uint64_t v29 = v28 + 1;
      if (a3 - 125 <= 1)
      {
        __src[v29] = 125;
        char v26 = a3 ^ 0x20;
        LODWORD(v29) = v28 + 2;
      }
      char v30 = a4;
      __src[v29] = v26;
      uint64_t v31 = v29 + 1;
      if (HIBYTE(a3) - 125 <= 1)
      {
        __src[v31] = 125;
        LODWORD(v31) = v29 + 2;
        char v11 = HIBYTE(a3) ^ 0x20;
      }
      __src[v31] = v11;
      uint64_t v32 = v31 + 1;
      if (a4 - 125 <= 1)
      {
        __src[v32] = 125;
        char v30 = a4 ^ 0x20;
        LODWORD(v32) = v31 + 2;
      }
      int v33 = ~(v38 ^ BYTE1(v18));
      __src[v32] = v30;
      uint64_t v34 = v32 + 1;
      if (HIBYTE(a4) - 125 <= 1)
      {
        __src[v34] = 125;
        char v12 = HIBYTE(a4) ^ 0x20;
        LODWORD(v34) = v32 + 2;
      }
      char v35 = BYTE1(v39);
      __src[v34] = v12;
      uint64_t v36 = v34 + 1;
      if ((v33 - 125) <= 1)
      {
        __src[v36] = 125;
        LODWORD(v36) = v34 + 2;
        LOBYTE(v33) = v33 ^ 0x20;
      }
      __src[v36] = v33;
      uint64_t v37 = v36 + 1;
      if (BYTE1(v39) - 125 <= 1)
      {
        __src[v37] = 125;
        char v35 = BYTE1(v39) ^ 0x20;
        LODWORD(v37) = v36 + 2;
      }
      __src[v37] = v35;
      memcpy(a1, __src, v37 + 1);
      uint64_t result = (v37 + 2);
      a1[v37 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_GetThermistorValue(_DWORD *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 5)
  {
    bzero(a1, a2);
    *a1 = -2115764917;
    if (a2 >= 8)
    {
      *a1 = -2115764917;
      *((unsigned char *)a1 + 4) = 126;
      return 5;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_GetRxAGC(unsigned __int8 *a1, int a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0xF)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    int v5 = gModeId;
    a1[2] = gModeId;
    int v6 = HIBYTE(gModeId);
    a1[3] = HIBYTE(gModeId);
    a1[4] = 53;
    *((_WORD *)a1 + 3) = 0;
    unsigned int v7 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v5 ^ 0xA5]) ^ 0x35];
    int v8 = a1[5];
    int v9 = crc_16_l_table[(v8 ^ v7 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC]))];
    unsigned int v10 = crc_16_l_table[v9 ^ (v7 >> 8)];
    int v11 = crc_16_l_table[crc_16_l_table[v9 ^ (v7 >> 8)] ^ HIBYTE(crc_16_l_table[(v8 ^ v7 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC]))])];
    int v12 = v11 ^ ~(v10 >> 8);
    *((_WORD *)a1 + 4) = v11 ^ ~HIBYTE(crc_16_l_table[v9 ^ (v7 >> 8)]);
    if (a2 >= 20)
    {
      bzero(v23, 0x7FEuLL);
      __int16 __src = 2891;
      if ((v5 - 125) > 1)
      {
        unsigned int v13 = 2;
      }
      else
      {
        v23[0] = 125;
        LOBYTE(v5) = v5 ^ 0x20;
        unsigned int v13 = 3;
      }
      v23[v13 - 2] = v5;
      uint64_t v14 = v13 + 1;
      if ((v6 - 125) <= 1)
      {
        v23[v14 - 2] = 125;
        LODWORD(v14) = v13 + 2;
        LOBYTE(v6) = v6 ^ 0x20;
      }
      int v15 = ~(v11 ^ BYTE1(v10));
      unsigned __int16 v16 = &v23[v14 - 2];
      char *v16 = v6;
      v16[1] = 53;
      uint64_t v17 = v14 + 2;
      if ((v8 - 125) <= 1)
      {
        v23[v17 - 2] = 125;
        LOBYTE(v8) = v8 ^ 0x20;
        LODWORD(v17) = v14 + 3;
      }
      char v18 = (unsigned __int16)(v11 ^ ~(unsigned __int16)(v10 >> 8)) >> 8;
      int v19 = &v23[v17 - 2];
      *int v19 = v8;
      *(_WORD *)(v19 + 1) = 0;
      uint64_t v20 = v17 + 3;
      if ((v15 - 125) <= 1)
      {
        v23[v20 - 2] = 125;
        LOBYTE(v15) = v15 ^ 0x20;
        LODWORD(v20) = v17 + 4;
      }
      v23[v20 - 2] = v15;
      uint64_t v21 = v20 + 1;
      if (BYTE1(v12) - 125 <= 1)
      {
        v23[v21 - 2] = 125;
        char v18 = BYTE1(v12) ^ 0x20;
        LODWORD(v21) = v20 + 2;
      }
      v23[v21 - 2] = v18;
      memcpy(a1, &__src, v21 + 1);
      uint64_t result = (v21 + 2);
      a1[v21 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_GetSynthState(unsigned __int8 *a1, int a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0xF)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    int v5 = gModeId;
    a1[2] = gModeId;
    int v6 = HIBYTE(gModeId);
    a1[3] = HIBYTE(gModeId);
    a1[4] = 16;
    a1[6] = -8;
    unsigned int v7 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v5 ^ 0xA5]) ^ 0x10];
    int v8 = a1[5];
    unsigned int v9 = crc_16_l_table[(v8 ^ v7 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC]))];
    int v10 = crc_16_l_table[crc_16_l_table[(v8 ^ v7 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC]))] ^ (v7 >> 8) ^ 0xF8];
    int v11 = v10 ^ ~(v9 >> 8);
    *(_WORD *)(a1 + 7) = v10 ^ ~HIBYTE(crc_16_l_table[(v8 ^ v7 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v5 ^ 0xA5] ^ v6 ^ 0xEC]))]);
    if (a2 >= 18)
    {
      bzero(v22, 0x7FEuLL);
      __int16 __src = 2891;
      if ((v5 - 125) > 1)
      {
        unsigned int v12 = 2;
      }
      else
      {
        v22[0] = 125;
        LOBYTE(v5) = v5 ^ 0x20;
        unsigned int v12 = 3;
      }
      v22[v12 - 2] = v5;
      uint64_t v13 = v12 + 1;
      if ((v6 - 125) <= 1)
      {
        v22[v13 - 2] = 125;
        LODWORD(v13) = v12 + 2;
        LOBYTE(v6) = v6 ^ 0x20;
      }
      int v14 = ~(v10 ^ BYTE1(v9));
      int v15 = &v22[v13 - 2];
      char *v15 = v6;
      v15[1] = 16;
      uint64_t v16 = v13 + 2;
      if ((v8 - 125) <= 1)
      {
        v22[v16 - 2] = 125;
        LOBYTE(v8) = v8 ^ 0x20;
        LODWORD(v16) = v13 + 3;
      }
      char v17 = (unsigned __int16)(v10 ^ ~(unsigned __int16)(v9 >> 8)) >> 8;
      char v18 = &v22[v16 - 2];
      char *v18 = v8;
      v18[1] = -8;
      uint64_t v19 = v16 + 2;
      if ((v14 - 125) <= 1)
      {
        v22[v19 - 2] = 125;
        LOBYTE(v14) = v14 ^ 0x20;
        LODWORD(v19) = v16 + 3;
      }
      v22[v19 - 2] = v14;
      uint64_t v20 = v19 + 1;
      if (BYTE1(v11) - 125 <= 1)
      {
        v22[v20 - 2] = 125;
        char v17 = BYTE1(v11) ^ 0x20;
        LODWORD(v20) = v19 + 2;
      }
      v22[v20 - 2] = v17;
      memcpy(a1, &__src, v20 + 1);
      uint64_t result = (v20 + 2);
      a1[v20 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetLNARange(unsigned __int8 *a1, int a2, unsigned __int8 a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xF) {
    return result;
  }
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  int v7 = gModeId;
  a1[2] = gModeId;
  int v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 58;
  a1[6] = a3;
  unsigned __int16 v9 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 0x3A];
  int v10 = a1[5];
  unsigned __int16 v11 = crc_16_l_table[(v10 ^ v9 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]))];
  unsigned int v12 = crc_16_l_table[(v11 ^ HIBYTE(v9) ^ a3)];
  int v13 = crc_16_l_table[(a1[7] ^ v12 ^ HIBYTE(v11))];
  int v14 = v13 ^ ~(v12 >> 8);
  *((_WORD *)a1 + 4) = v13 ^ ~HIBYTE(crc_16_l_table[(v11 ^ HIBYTE(v9) ^ a3)]);
  if (a2 < 20) {
    return 0xFFFFFFFFLL;
  }
  bzero(v28, 0x7FEuLL);
  __int16 v27 = 2891;
  if ((v7 - 125) <= 1)
  {
    v28[0] = 125;
    int v15 = 3;
    v28[1] = v7 ^ 0x20;
    uint64_t v16 = 4;
    if ((v8 - 125) > 1) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v15 = 2;
  v28[0] = v7;
  uint64_t v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v28[v16 - 2] = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v16) = v15 + 2;
  }
LABEL_10:
  char v17 = a3;
  char v18 = &v28[v16 - 2];
  unsigned char *v18 = v8;
  v18[1] = 58;
  uint64_t v19 = v16 + 2;
  if ((v10 - 125) <= 1)
  {
    v28[v19 - 2] = 125;
    LOBYTE(v10) = v10 ^ 0x20;
    LODWORD(v19) = v16 + 3;
  }
  v28[v19 - 2] = v10;
  uint64_t v20 = v19 + 1;
  if (a3 - 125 <= 1)
  {
    v28[v20 - 2] = 125;
    LODWORD(v20) = v19 + 2;
    char v17 = a3 ^ 0x20;
  }
  int v21 = ~(v13 ^ BYTE1(v12));
  v28[v20 - 2] = v17;
  uint64_t v22 = v20 + 1;
  int v23 = a1[7];
  if ((v23 - 125) <= 1)
  {
    v28[v22 - 2] = 125;
    LOBYTE(v23) = v23 ^ 0x20;
    LODWORD(v22) = v20 + 2;
  }
  char v24 = (unsigned __int16)(v13 ^ ~(unsigned __int16)(v12 >> 8)) >> 8;
  v28[v22 - 2] = v23;
  uint64_t v25 = v22 + 1;
  if ((v21 - 125) <= 1)
  {
    v28[v25 - 2] = 125;
    LODWORD(v25) = v22 + 2;
    LOBYTE(v21) = v21 ^ 0x20;
  }
  v28[v25 - 2] = v21;
  uint64_t v26 = v25 + 1;
  if (BYTE1(v14) - 125 <= 1)
  {
    v28[v26 - 2] = 125;
    char v24 = BYTE1(v14) ^ 0x20;
    LODWORD(v26) = v25 + 2;
  }
  v28[v26 - 2] = v24;
  memcpy(a1, &v27, v26 + 1);
  uint64_t result = (v26 + 2);
  a1[v26 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_GetDVGAOffset(unsigned __int8 *a1, int a2, __int16 a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xF) {
    return result;
  }
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  int v7 = gModeId;
  a1[2] = gModeId;
  int v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 117;
  *((_WORD *)a1 + 3) = a3;
  char v9 = HIBYTE(a3);
  unsigned __int16 v10 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 0x75];
  int v11 = a1[5];
  unsigned int v12 = crc_16_l_table[(v11 ^ v10 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]))];
  unsigned int v13 = crc_16_l_table[(v12 ^ HIBYTE(v10) ^ a3)];
  int v14 = crc_16_l_table[HIBYTE(a3) ^ crc_16_l_table[(v12 ^ HIBYTE(v10) ^ a3)] ^ (v12 >> 8)];
  *((_WORD *)a1 + 4) = v14 ^ ~HIBYTE(crc_16_l_table[(v12 ^ HIBYTE(v10) ^ a3)]);
  if (a2 < 20) {
    return 0xFFFFFFFFLL;
  }
  int v26 = v14 ^ ~(v13 >> 8);
  bzero(v28, 0x7FEuLL);
  __int16 __src = 2891;
  if ((v7 - 125) <= 1)
  {
    v28[0] = 125;
    int v15 = 3;
    v28[1] = v7 ^ 0x20;
    uint64_t v16 = 4;
    if ((v8 - 125) > 1) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v15 = 2;
  v28[0] = v7;
  uint64_t v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v28[v16 - 2] = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v16) = v15 + 2;
  }
LABEL_10:
  char v17 = a3;
  char v18 = &v28[v16 - 2];
  unsigned char *v18 = v8;
  v18[1] = 117;
  uint64_t v19 = v16 + 2;
  if ((v11 - 125) <= 1)
  {
    v28[v19 - 2] = 125;
    LOBYTE(v11) = v11 ^ 0x20;
    LODWORD(v19) = v16 + 3;
  }
  v28[v19 - 2] = v11;
  uint64_t v20 = v19 + 1;
  if (a3 - 125 <= 1)
  {
    v28[v20 - 2] = 125;
    char v17 = a3 ^ 0x20;
    LODWORD(v20) = v19 + 2;
  }
  int v21 = ~(v14 ^ BYTE1(v13));
  v28[v20 - 2] = v17;
  uint64_t v22 = v20 + 1;
  if (HIBYTE(a3) - 125 <= 1)
  {
    v28[v22 - 2] = 125;
    char v9 = HIBYTE(a3) ^ 0x20;
    LODWORD(v22) = v20 + 2;
  }
  char v23 = (unsigned __int16)(v14 ^ ~(unsigned __int16)(v13 >> 8)) >> 8;
  v28[v22 - 2] = v9;
  uint64_t v24 = v22 + 1;
  if ((v21 - 125) <= 1)
  {
    v28[v24 - 2] = 125;
    LOBYTE(v21) = v21 ^ 0x20;
    LODWORD(v24) = v22 + 2;
  }
  v28[v24 - 2] = v21;
  uint64_t v25 = v24 + 1;
  if (BYTE1(v26) - 125 <= 1)
  {
    v28[v25 - 2] = 125;
    char v23 = BYTE1(v26) ^ 0x20;
    LODWORD(v25) = v24 + 2;
  }
  v28[v25 - 2] = v23;
  memcpy(a1, &__src, v25 + 1);
  uint64_t result = (v25 + 2);
  a1[v25 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetDVGAOffset(unsigned __int8 *a1, int a2, unsigned __int8 a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xF) {
    return result;
  }
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  int v7 = gModeId;
  a1[2] = gModeId;
  int v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 111;
  a1[6] = a3;
  unsigned __int16 v9 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 0x6F];
  int v10 = a1[5];
  unsigned __int16 v11 = crc_16_l_table[(v10 ^ v9 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]))];
  unsigned int v12 = crc_16_l_table[(v11 ^ HIBYTE(v9) ^ a3)];
  int v13 = crc_16_l_table[(a1[7] ^ v12 ^ HIBYTE(v11))];
  int v14 = v13 ^ ~(v12 >> 8);
  *((_WORD *)a1 + 4) = v13 ^ ~HIBYTE(crc_16_l_table[(v11 ^ HIBYTE(v9) ^ a3)]);
  if (a2 < 20) {
    return 0xFFFFFFFFLL;
  }
  bzero(v28, 0x7FEuLL);
  __int16 v27 = 2891;
  if ((v7 - 125) <= 1)
  {
    v28[0] = 125;
    int v15 = 3;
    v28[1] = v7 ^ 0x20;
    uint64_t v16 = 4;
    if ((v8 - 125) > 1) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v15 = 2;
  v28[0] = v7;
  uint64_t v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v28[v16 - 2] = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v16) = v15 + 2;
  }
LABEL_10:
  char v17 = a3;
  char v18 = &v28[v16 - 2];
  unsigned char *v18 = v8;
  v18[1] = 111;
  uint64_t v19 = v16 + 2;
  if ((v10 - 125) <= 1)
  {
    v28[v19 - 2] = 125;
    LOBYTE(v10) = v10 ^ 0x20;
    LODWORD(v19) = v16 + 3;
  }
  v28[v19 - 2] = v10;
  uint64_t v20 = v19 + 1;
  if (a3 - 125 <= 1)
  {
    v28[v20 - 2] = 125;
    LODWORD(v20) = v19 + 2;
    char v17 = a3 ^ 0x20;
  }
  int v21 = ~(v13 ^ BYTE1(v12));
  v28[v20 - 2] = v17;
  uint64_t v22 = v20 + 1;
  int v23 = a1[7];
  if ((v23 - 125) <= 1)
  {
    v28[v22 - 2] = 125;
    LOBYTE(v23) = v23 ^ 0x20;
    LODWORD(v22) = v20 + 2;
  }
  char v24 = (unsigned __int16)(v13 ^ ~(unsigned __int16)(v12 >> 8)) >> 8;
  v28[v22 - 2] = v23;
  uint64_t v25 = v22 + 1;
  if ((v21 - 125) <= 1)
  {
    v28[v25 - 2] = 125;
    LODWORD(v25) = v22 + 2;
    LOBYTE(v21) = v21 ^ 0x20;
  }
  v28[v25 - 2] = v21;
  uint64_t v26 = v25 + 1;
  if (BYTE1(v14) - 125 <= 1)
  {
    v28[v26 - 2] = 125;
    char v24 = BYTE1(v14) ^ 0x20;
    LODWORD(v26) = v25 + 2;
  }
  v28[v26 - 2] = v24;
  memcpy(a1, &v27, v26 + 1);
  uint64_t result = (v26 + 2);
  a1[v26 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_GetLNAOffset(unsigned __int8 *a1, int a2, __int16 a3, __int16 a4)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x11)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    int v9 = gModeId;
    a1[2] = gModeId;
    int v10 = HIBYTE(gModeId);
    a1[3] = HIBYTE(gModeId);
    a1[4] = 118;
    *((_WORD *)a1 + 3) = a3;
    char v11 = HIBYTE(a3);
    *((_WORD *)a1 + 4) = a4;
    char v12 = HIBYTE(a4);
    unsigned __int16 v13 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v9 ^ 0xA5]) ^ 0x76];
    int v14 = a1[5];
    unsigned __int16 v15 = crc_16_l_table[(v14 ^ v13 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC]))];
    unsigned __int16 v16 = crc_16_l_table[(v15 ^ HIBYTE(v13) ^ a3)];
    unsigned int v17 = crc_16_l_table[(HIBYTE(a3) ^ v16 ^ HIBYTE(v15))];
    unsigned int v18 = crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))];
    int v19 = crc_16_l_table[HIBYTE(a4) ^ crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))] ^ (v17 >> 8)];
    *((_WORD *)a1 + 5) = v19 ^ ~(unsigned __int16)(v18 >> 8);
    if (a2 >= 24)
    {
      char v38 = v19;
      int v39 = v19 ^ ~(v18 >> 8);
      bzero(__src, 0x800uLL);
      int v20 = *a1;
      if ((v20 - 125) > 1)
      {
        unsigned int v21 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v20) = v20 ^ 0x20;
        unsigned int v21 = 1;
      }
      __src[v21] = v20;
      uint64_t v22 = v21 + 1;
      int v23 = a1[1];
      if ((v23 - 125) <= 1)
      {
        __src[v22] = 125;
        LODWORD(v22) = v21 | 2;
        LOBYTE(v23) = v23 ^ 0x20;
      }
      __src[v22] = v23;
      uint64_t v24 = v22 + 1;
      if ((v9 - 125) <= 1)
      {
        __src[v24] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v24) = v22 + 2;
      }
      __src[v24] = v9;
      uint64_t v25 = v24 + 1;
      if ((v10 - 125) <= 1)
      {
        __src[v25] = 125;
        LOBYTE(v10) = v10 ^ 0x20;
        LODWORD(v25) = v24 + 2;
      }
      char v26 = a3;
      __int16 v27 = &__src[v25];
      unsigned char *v27 = v10;
      v27[1] = 118;
      uint64_t v28 = v25 + 2;
      if ((v14 - 125) <= 1)
      {
        __src[v28] = 125;
        LOBYTE(v14) = v14 ^ 0x20;
        LODWORD(v28) = v25 + 3;
      }
      __src[v28] = v14;
      uint64_t v29 = v28 + 1;
      if (a3 - 125 <= 1)
      {
        __src[v29] = 125;
        char v26 = a3 ^ 0x20;
        LODWORD(v29) = v28 + 2;
      }
      char v30 = a4;
      __src[v29] = v26;
      uint64_t v31 = v29 + 1;
      if (HIBYTE(a3) - 125 <= 1)
      {
        __src[v31] = 125;
        LODWORD(v31) = v29 + 2;
        char v11 = HIBYTE(a3) ^ 0x20;
      }
      __src[v31] = v11;
      uint64_t v32 = v31 + 1;
      if (a4 - 125 <= 1)
      {
        __src[v32] = 125;
        char v30 = a4 ^ 0x20;
        LODWORD(v32) = v31 + 2;
      }
      int v33 = ~(v38 ^ BYTE1(v18));
      __src[v32] = v30;
      uint64_t v34 = v32 + 1;
      if (HIBYTE(a4) - 125 <= 1)
      {
        __src[v34] = 125;
        char v12 = HIBYTE(a4) ^ 0x20;
        LODWORD(v34) = v32 + 2;
      }
      char v35 = BYTE1(v39);
      __src[v34] = v12;
      uint64_t v36 = v34 + 1;
      if ((v33 - 125) <= 1)
      {
        __src[v36] = 125;
        LODWORD(v36) = v34 + 2;
        LOBYTE(v33) = v33 ^ 0x20;
      }
      __src[v36] = v33;
      uint64_t v37 = v36 + 1;
      if (BYTE1(v39) - 125 <= 1)
      {
        __src[v37] = 125;
        char v35 = BYTE1(v39) ^ 0x20;
        LODWORD(v37) = v36 + 2;
      }
      __src[v37] = v35;
      memcpy(a1, __src, v37 + 1);
      uint64_t result = (v37 + 2);
      a1[v37 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetLNAOffset(unsigned __int8 *a1, int a2, __int16 a3, __int16 a4)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x11)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    int v9 = gModeId;
    a1[2] = gModeId;
    int v10 = HIBYTE(gModeId);
    a1[3] = HIBYTE(gModeId);
    a1[4] = 81;
    *((_WORD *)a1 + 3) = a3;
    char v11 = HIBYTE(a3);
    *((_WORD *)a1 + 4) = a4;
    char v12 = HIBYTE(a4);
    unsigned __int16 v13 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v9 ^ 0xA5]) ^ 0x51];
    int v14 = a1[5];
    unsigned __int16 v15 = crc_16_l_table[(v14 ^ v13 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC]))];
    unsigned __int16 v16 = crc_16_l_table[(v15 ^ HIBYTE(v13) ^ a3)];
    unsigned int v17 = crc_16_l_table[(HIBYTE(a3) ^ v16 ^ HIBYTE(v15))];
    unsigned int v18 = crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))];
    int v19 = crc_16_l_table[HIBYTE(a4) ^ crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))] ^ (v17 >> 8)];
    *((_WORD *)a1 + 5) = v19 ^ ~(unsigned __int16)(v18 >> 8);
    if (a2 >= 24)
    {
      char v38 = v19;
      int v39 = v19 ^ ~(v18 >> 8);
      bzero(__src, 0x800uLL);
      int v20 = *a1;
      if ((v20 - 125) > 1)
      {
        unsigned int v21 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v20) = v20 ^ 0x20;
        unsigned int v21 = 1;
      }
      __src[v21] = v20;
      uint64_t v22 = v21 + 1;
      int v23 = a1[1];
      if ((v23 - 125) <= 1)
      {
        __src[v22] = 125;
        LODWORD(v22) = v21 | 2;
        LOBYTE(v23) = v23 ^ 0x20;
      }
      __src[v22] = v23;
      uint64_t v24 = v22 + 1;
      if ((v9 - 125) <= 1)
      {
        __src[v24] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v24) = v22 + 2;
      }
      __src[v24] = v9;
      uint64_t v25 = v24 + 1;
      if ((v10 - 125) <= 1)
      {
        __src[v25] = 125;
        LOBYTE(v10) = v10 ^ 0x20;
        LODWORD(v25) = v24 + 2;
      }
      char v26 = a3;
      __int16 v27 = &__src[v25];
      unsigned char *v27 = v10;
      v27[1] = 81;
      uint64_t v28 = v25 + 2;
      if ((v14 - 125) <= 1)
      {
        __src[v28] = 125;
        LOBYTE(v14) = v14 ^ 0x20;
        LODWORD(v28) = v25 + 3;
      }
      __src[v28] = v14;
      uint64_t v29 = v28 + 1;
      if (a3 - 125 <= 1)
      {
        __src[v29] = 125;
        char v26 = a3 ^ 0x20;
        LODWORD(v29) = v28 + 2;
      }
      char v30 = a4;
      __src[v29] = v26;
      uint64_t v31 = v29 + 1;
      if (HIBYTE(a3) - 125 <= 1)
      {
        __src[v31] = 125;
        LODWORD(v31) = v29 + 2;
        char v11 = HIBYTE(a3) ^ 0x20;
      }
      __src[v31] = v11;
      uint64_t v32 = v31 + 1;
      if (a4 - 125 <= 1)
      {
        __src[v32] = 125;
        char v30 = a4 ^ 0x20;
        LODWORD(v32) = v31 + 2;
      }
      int v33 = ~(v38 ^ BYTE1(v18));
      __src[v32] = v30;
      uint64_t v34 = v32 + 1;
      if (HIBYTE(a4) - 125 <= 1)
      {
        __src[v34] = 125;
        char v12 = HIBYTE(a4) ^ 0x20;
        LODWORD(v34) = v32 + 2;
      }
      char v35 = BYTE1(v39);
      __src[v34] = v12;
      uint64_t v36 = v34 + 1;
      if ((v33 - 125) <= 1)
      {
        __src[v36] = 125;
        LODWORD(v36) = v34 + 2;
        LOBYTE(v33) = v33 ^ 0x20;
      }
      __src[v36] = v33;
      uint64_t v37 = v36 + 1;
      if (BYTE1(v39) - 125 <= 1)
      {
        __src[v37] = 125;
        char v35 = BYTE1(v39) ^ 0x20;
        LODWORD(v37) = v36 + 2;
      }
      __src[v37] = v35;
      memcpy(a1, __src, v37 + 1);
      uint64_t result = (v37 + 2);
      a1[v37 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetgModeId(unsigned int a1)
{
  if (a1 > 0x8002) {
    return 0xFFFFFFFFLL;
  }
  gModeId = a1;
  return 1;
}

uint64_t APPLIB_DIAG_FTM_SetCalibrationState(_WORD *a1, int a2)
{
  return APPLIB_DIAG_ModeChange(a1, a2, 3u);
}

uint64_t APPLIB_DIAG_FTM_CDMA_API2_CALIBRATE_DVGA(char *a1, int a2, int a3, __int16 a4)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x14)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 1182539;
    a1[4] = 1;
    a1[10] = a3;
    *(_WORD *)(a1 + 11) = a4;
    char v9 = HIBYTE(a4);
    uint64_t v10 = a1[5];
    unsigned __int16 v11 = crc_16_l_table[v10 ^ 0xF7];
    int v12 = a1[6];
    unsigned __int16 v13 = crc_16_l_table[(v12 ^ v11) ^ 0x57];
    unsigned __int16 v14 = crc_16_l_table[(a1[7] ^ v13 ^ HIBYTE(v11))];
    unsigned __int16 v15 = crc_16_l_table[(a1[8] ^ v14 ^ HIBYTE(v13))];
    unsigned __int16 v16 = crc_16_l_table[(a1[9] ^ v15 ^ HIBYTE(v14))];
    unsigned int v17 = crc_16_l_table[(a3 ^ v16 ^ HIBYTE(v15))];
    unsigned int v18 = crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))];
    int v19 = crc_16_l_table[HIBYTE(a4) ^ crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))] ^ (v17 >> 8)];
    int v20 = v19 ^ ~(v18 >> 8);
    *(_WORD *)(a1 + 13) = v19 ^ ~HIBYTE(crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))]);
    if (a2 >= 30)
    {
      bzero(v40, 0x800uLL);
      int v21 = *a1;
      if ((v21 - 125) > 1)
      {
        unsigned int v22 = 0;
      }
      else
      {
        v40[0] = 125;
        LOBYTE(v21) = v21 ^ 0x20;
        unsigned int v22 = 1;
      }
      int v23 = &v40[v22];
      *int v23 = v21;
      *(_DWORD *)(v23 + 1) = 16781835;
      uint64_t v24 = v22 + 5;
      if ((v10 - 125) <= 1)
      {
        v40[v24] = 125;
        LODWORD(v24) = v22 | 6;
        LOBYTE(v10) = v10 ^ 0x20;
      }
      v40[v24] = v10;
      uint64_t v25 = v24 + 1;
      if ((v12 - 125) <= 1)
      {
        v40[v25] = 125;
        LOBYTE(v12) = v12 ^ 0x20;
        LODWORD(v25) = v24 + 2;
      }
      v40[v25] = v12;
      uint64_t v26 = v25 + 1;
      int v27 = a1[7];
      if ((v27 - 125) <= 1)
      {
        v40[v26] = 125;
        LODWORD(v26) = v25 + 2;
        LOBYTE(v27) = v27 ^ 0x20;
      }
      v40[v26] = v27;
      uint64_t v28 = v26 + 1;
      int v29 = a1[8];
      if ((v29 - 125) <= 1)
      {
        v40[v28] = 125;
        LOBYTE(v29) = v29 ^ 0x20;
        LODWORD(v28) = v26 + 2;
      }
      v40[v28] = v29;
      uint64_t v30 = v28 + 1;
      int v31 = a1[9];
      if ((v31 - 125) <= 1)
      {
        v40[v30] = 125;
        LOBYTE(v31) = v31 ^ 0x20;
        LODWORD(v30) = v28 + 2;
      }
      char v32 = a4;
      v40[v30] = v31;
      uint64_t v33 = v30 + 1;
      if ((a3 - 125) <= 1)
      {
        v40[v33] = 125;
        LOBYTE(a3) = a3 ^ 0x20;
        LODWORD(v33) = v30 + 2;
      }
      v40[v33] = a3;
      uint64_t v34 = v33 + 1;
      if (a4 - 125 <= 1)
      {
        v40[v34] = 125;
        LODWORD(v34) = v33 + 2;
        char v32 = a4 ^ 0x20;
      }
      int v35 = ~(v19 ^ BYTE1(v18));
      v40[v34] = v32;
      uint64_t v36 = v34 + 1;
      if (HIBYTE(a4) - 125 <= 1)
      {
        v40[v36] = 125;
        char v9 = HIBYTE(a4) ^ 0x20;
        LODWORD(v36) = v34 + 2;
      }
      char v37 = (unsigned __int16)(v19 ^ ~(unsigned __int16)(v18 >> 8)) >> 8;
      v40[v36] = v9;
      uint64_t v38 = v36 + 1;
      if ((v35 - 125) <= 1)
      {
        v40[v38] = 125;
        LODWORD(v38) = v36 + 2;
        LOBYTE(v35) = v35 ^ 0x20;
      }
      v40[v38] = v35;
      uint64_t v39 = v38 + 1;
      if (BYTE1(v20) - 125 <= 1)
      {
        v40[v39] = 125;
        char v37 = BYTE1(v20) ^ 0x20;
        LODWORD(v39) = v38 + 2;
      }
      v40[v39] = v37;
      memcpy(a1, v40, v39 + 1);
      uint64_t result = (v39 + 2);
      a1[v39 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_CDMA_API2_CALIBRATE_LNA(unsigned __int8 *a1, int a2, unsigned __int8 a3, __int16 a4, unsigned __int8 a5)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x14)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 1182539;
    a1[4] = 2;
    a1[10] = a3;
    a1[11] = a5;
    *((_WORD *)a1 + 6) = a4;
    char v11 = HIBYTE(a4);
    uint64_t v12 = a1[5];
    unsigned __int16 v13 = crc_16_l_table[v12 ^ 0x6C];
    int v14 = a1[6];
    unsigned __int16 v15 = crc_16_l_table[(v14 ^ v13) ^ 0x65];
    unsigned __int16 v16 = crc_16_l_table[(a1[7] ^ v15 ^ HIBYTE(v13))];
    unsigned __int16 v17 = crc_16_l_table[(a1[8] ^ v16 ^ HIBYTE(v15))];
    unsigned __int16 v18 = crc_16_l_table[(a1[9] ^ v17 ^ HIBYTE(v16))];
    unsigned __int16 v19 = crc_16_l_table[(a3 ^ v18 ^ HIBYTE(v17))];
    unsigned int v20 = crc_16_l_table[(a5 ^ v19 ^ HIBYTE(v18))];
    unsigned int v21 = crc_16_l_table[(a4 ^ v20 ^ HIBYTE(v19))];
    int v22 = crc_16_l_table[HIBYTE(a4) ^ crc_16_l_table[(a4 ^ v20 ^ HIBYTE(v19))] ^ (v20 >> 8)];
    int v23 = v22 ^ ~(v21 >> 8);
    *((_WORD *)a1 + 7) = v22 ^ ~HIBYTE(crc_16_l_table[(a4 ^ v20 ^ HIBYTE(v19))]);
    if (a2 >= 32)
    {
      bzero(__src, 0x800uLL);
      int v24 = *a1;
      if ((v24 - 125) > 1)
      {
        unsigned int v25 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v24) = v24 ^ 0x20;
        unsigned int v25 = 1;
      }
      __src[v25] = v24;
      uint64_t v26 = v25 + 1;
      int v27 = a1[1];
      if ((v27 - 125) <= 1)
      {
        __src[v26] = 125;
        LODWORD(v26) = v25 | 2;
        LOBYTE(v27) = v27 ^ 0x20;
      }
      __src[v26] = v27;
      uint64_t v28 = v26 + 1;
      int v29 = a1[2];
      if ((v29 - 125) <= 1)
      {
        __src[v28] = 125;
        LOBYTE(v29) = v29 ^ 0x20;
        LODWORD(v28) = v26 + 2;
      }
      __src[v28] = v29;
      uint64_t v30 = v28 + 1;
      int v31 = a1[3];
      if ((v31 - 125) <= 1)
      {
        __src[v30] = 125;
        LODWORD(v30) = v28 + 2;
        LOBYTE(v31) = v31 ^ 0x20;
      }
      __src[v30] = v31;
      uint64_t v32 = v30 + 1;
      int v33 = a1[4];
      if ((v33 - 125) <= 1)
      {
        __src[v32] = 125;
        LOBYTE(v33) = v33 ^ 0x20;
        LODWORD(v32) = v30 + 2;
      }
      __src[v32] = v33;
      uint64_t v34 = v32 + 1;
      if ((v12 - 125) <= 1)
      {
        __src[v34] = 125;
        LODWORD(v34) = v32 + 2;
        LOBYTE(v12) = v12 ^ 0x20;
      }
      __src[v34] = v12;
      uint64_t v35 = v34 + 1;
      if ((v14 - 125) <= 1)
      {
        __src[v35] = 125;
        LOBYTE(v14) = v14 ^ 0x20;
        LODWORD(v35) = v34 + 2;
      }
      __src[v35] = v14;
      uint64_t v36 = v35 + 1;
      int v37 = a1[7];
      if ((v37 - 125) <= 1)
      {
        __src[v36] = 125;
        LODWORD(v36) = v35 + 2;
        LOBYTE(v37) = v37 ^ 0x20;
      }
      __src[v36] = v37;
      uint64_t v38 = v36 + 1;
      int v39 = a1[8];
      if ((v39 - 125) <= 1)
      {
        __src[v38] = 125;
        LOBYTE(v39) = v39 ^ 0x20;
        LODWORD(v38) = v36 + 2;
      }
      __src[v38] = v39;
      uint64_t v40 = v38 + 1;
      int v41 = a1[9];
      if ((v41 - 125) <= 1)
      {
        __src[v40] = 125;
        LODWORD(v40) = v38 + 2;
        LOBYTE(v41) = v41 ^ 0x20;
      }
      __src[v40] = v41;
      uint64_t v42 = v40 + 1;
      int v43 = a1[10];
      if ((v43 - 125) <= 1)
      {
        __src[v42] = 125;
        LOBYTE(v43) = v43 ^ 0x20;
        LODWORD(v42) = v40 + 2;
      }
      char v44 = a4;
      __src[v42] = v43;
      uint64_t v45 = v42 + 1;
      int v46 = a1[11];
      if ((v46 - 125) <= 1)
      {
        __src[v45] = 125;
        LODWORD(v45) = v42 + 2;
        LOBYTE(v46) = v46 ^ 0x20;
      }
      __src[v45] = v46;
      uint64_t v47 = v45 + 1;
      if (a4 - 125 <= 1)
      {
        __src[v47] = 125;
        char v44 = a4 ^ 0x20;
        LODWORD(v47) = v45 + 2;
      }
      int v48 = ~(v22 ^ BYTE1(v21));
      __src[v47] = v44;
      uint64_t v49 = v47 + 1;
      if (HIBYTE(a4) - 125 <= 1)
      {
        __src[v49] = 125;
        char v11 = HIBYTE(a4) ^ 0x20;
        LODWORD(v49) = v47 + 2;
      }
      char v50 = (unsigned __int16)(v22 ^ ~(unsigned __int16)(v21 >> 8)) >> 8;
      __src[v49] = v11;
      uint64_t v51 = v49 + 1;
      if ((v48 - 125) <= 1)
      {
        __src[v51] = 125;
        LOBYTE(v48) = v48 ^ 0x20;
        LODWORD(v51) = v49 + 2;
      }
      __src[v51] = v48;
      uint64_t v52 = v51 + 1;
      if (BYTE1(v23) - 125 <= 1)
      {
        __src[v52] = 125;
        char v50 = BYTE1(v23) ^ 0x20;
        LODWORD(v52) = v51 + 2;
      }
      __src[v52] = v50;
      memcpy(a1, __src, v52 + 1);
      uint64_t result = (v52 + 2);
      a1[v52 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_SecondChainTestCall(unsigned __int8 *a1, int a2, unsigned __int8 a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xE) {
    return result;
  }
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  int v7 = gModeId;
  a1[2] = gModeId;
  int v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 123;
  a1[6] = a3;
  unsigned __int16 v9 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 0x7B];
  int v10 = a1[5];
  uint64_t v11 = (v10 ^ v9 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]));
  unsigned int v12 = crc_16_l_table[v11];
  int v13 = crc_16_l_table[(v12 ^ HIBYTE(v9) ^ a3)];
  int v14 = v13 ^ ~(v12 >> 8);
  *(_WORD *)(a1 + 7) = v13 ^ ~HIBYTE(crc_16_l_table[v11]);
  if (a2 < 18) {
    return 0xFFFFFFFFLL;
  }
  bzero(v26, 0x7FEuLL);
  __int16 v25 = 2891;
  if ((v7 - 125) <= 1)
  {
    v26[0] = 125;
    int v15 = 3;
    v26[1] = v7 ^ 0x20;
    uint64_t v16 = 4;
    if ((v8 - 125) > 1) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v15 = 2;
  v26[0] = v7;
  uint64_t v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v26[v16 - 2] = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v16) = v15 + 2;
  }
LABEL_10:
  char v17 = a3;
  unsigned __int16 v18 = &v26[v16 - 2];
  unsigned char *v18 = v8;
  v18[1] = 123;
  uint64_t v19 = v16 + 2;
  if ((v10 - 125) <= 1)
  {
    v26[v19 - 2] = 125;
    LOBYTE(v10) = v10 ^ 0x20;
    LODWORD(v19) = v16 + 3;
  }
  int v20 = ~(v13 ^ BYTE1(v12));
  v26[v19 - 2] = v10;
  uint64_t v21 = v19 + 1;
  if (a3 - 125 <= 1)
  {
    v26[v21 - 2] = 125;
    char v17 = a3 ^ 0x20;
    LODWORD(v21) = v19 + 2;
  }
  char v22 = (unsigned __int16)(v13 ^ ~(unsigned __int16)(v12 >> 8)) >> 8;
  v26[v21 - 2] = v17;
  uint64_t v23 = v21 + 1;
  if ((v20 - 125) <= 1)
  {
    v26[v23 - 2] = 125;
    LODWORD(v23) = v21 + 2;
    LOBYTE(v20) = v20 ^ 0x20;
  }
  v26[v23 - 2] = v20;
  uint64_t v24 = v23 + 1;
  if (BYTE1(v14) - 125 <= 1)
  {
    v26[v24 - 2] = 125;
    char v22 = BYTE1(v14) ^ 0x20;
    LODWORD(v24) = v23 + 2;
  }
  v26[v24 - 2] = v22;
  memcpy(a1, &v25, v24 + 1);
  uint64_t result = (v24 + 2);
  a1[v24 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetSecondaryChain(unsigned __int8 *a1, int a2, unsigned __int8 a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0xE) {
    return result;
  }
  bzero(a1, a2);
  *(_WORD *)a1 = 2891;
  int v7 = gModeId;
  a1[2] = gModeId;
  int v8 = HIBYTE(gModeId);
  a1[3] = HIBYTE(gModeId);
  a1[4] = 121;
  a1[6] = a3;
  unsigned __int16 v9 = crc_16_l_table[crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC] ^ HIBYTE(crc_16_l_table[v7 ^ 0xA5]) ^ 0x79];
  int v10 = a1[5];
  uint64_t v11 = (v10 ^ v9 ^ HIBYTE(crc_16_l_table[crc_16_l_table[v7 ^ 0xA5] ^ v8 ^ 0xEC]));
  unsigned int v12 = crc_16_l_table[v11];
  int v13 = crc_16_l_table[(v12 ^ HIBYTE(v9) ^ a3)];
  int v14 = v13 ^ ~(v12 >> 8);
  *(_WORD *)(a1 + 7) = v13 ^ ~HIBYTE(crc_16_l_table[v11]);
  if (a2 < 18) {
    return 0xFFFFFFFFLL;
  }
  bzero(v26, 0x7FEuLL);
  __int16 v25 = 2891;
  if ((v7 - 125) <= 1)
  {
    v26[0] = 125;
    int v15 = 3;
    v26[1] = v7 ^ 0x20;
    uint64_t v16 = 4;
    if ((v8 - 125) > 1) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v15 = 2;
  v26[0] = v7;
  uint64_t v16 = 3;
  if ((v8 - 125) <= 1)
  {
LABEL_9:
    v26[v16 - 2] = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v16) = v15 + 2;
  }
LABEL_10:
  char v17 = a3;
  unsigned __int16 v18 = &v26[v16 - 2];
  unsigned char *v18 = v8;
  v18[1] = 121;
  uint64_t v19 = v16 + 2;
  if ((v10 - 125) <= 1)
  {
    v26[v19 - 2] = 125;
    LOBYTE(v10) = v10 ^ 0x20;
    LODWORD(v19) = v16 + 3;
  }
  int v20 = ~(v13 ^ BYTE1(v12));
  v26[v19 - 2] = v10;
  uint64_t v21 = v19 + 1;
  if (a3 - 125 <= 1)
  {
    v26[v21 - 2] = 125;
    char v17 = a3 ^ 0x20;
    LODWORD(v21) = v19 + 2;
  }
  char v22 = (unsigned __int16)(v13 ^ ~(unsigned __int16)(v12 >> 8)) >> 8;
  v26[v21 - 2] = v17;
  uint64_t v23 = v21 + 1;
  if ((v20 - 125) <= 1)
  {
    v26[v23 - 2] = 125;
    LODWORD(v23) = v21 + 2;
    LOBYTE(v20) = v20 ^ 0x20;
  }
  v26[v23 - 2] = v20;
  uint64_t v24 = v23 + 1;
  if (BYTE1(v14) - 125 <= 1)
  {
    v26[v24 - 2] = 125;
    char v22 = BYTE1(v14) ^ 0x20;
    LODWORD(v24) = v23 + 2;
  }
  v26[v24 - 2] = v22;
  memcpy(a1, &v25, v24 + 1);
  uint64_t result = (v24 + 2);
  a1[v24 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_ChangeFTM_BootMode(char *a1, int a2, char a3)
{
  char __src = a3;
  return APPLIB_DIAG_NvItemWrite(a1, a2, 453, &__src, 1);
}

uint64_t APPLIB_DIAG_FTM_CDMA_API2_CALIBRATE_IM2(unsigned __int8 *a1, int a2, int a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0x14) {
    return result;
  }
  bzero(a1, a2);
  *(_DWORD *)a1 = 1182539;
  a1[4] = 3;
  a1[10] = a3;
  uint64_t v7 = a1[5];
  unsigned __int16 v8 = crc_16_l_table[v7 ^ 0xE5];
  int v9 = a1[6];
  unsigned __int16 v10 = crc_16_l_table[(v9 ^ v8) ^ 0x74];
  unsigned __int16 v11 = crc_16_l_table[(a1[7] ^ v10 ^ HIBYTE(v8))];
  unsigned __int16 v12 = crc_16_l_table[(a1[8] ^ v11 ^ HIBYTE(v10))];
  unsigned int v13 = crc_16_l_table[(a1[9] ^ v12 ^ HIBYTE(v11))];
  int v14 = crc_16_l_table[(v13 ^ HIBYTE(v12)) ^ a3];
  int v15 = v14 ^ ~(v13 >> 8);
  *((_WORD *)a1 + 6) = v14 ^ ~HIBYTE(crc_16_l_table[(a1[9] ^ v12 ^ HIBYTE(v11))]);
  if (a2 < 28) {
    return 0xFFFFFFFFLL;
  }
  bzero(v33, 0x7FBuLL);
  int __src = 1182539;
  char v32 = 3;
  if ((v7 - 125) <= 1)
  {
    v33[0] = 125;
    int v16 = 6;
    v33[1] = v7 ^ 0x20;
    uint64_t v17 = 7;
    if ((v9 - 125) > 1) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v16 = 5;
  v33[0] = v7;
  uint64_t v17 = 6;
  if ((v9 - 125) <= 1)
  {
LABEL_9:
    *((unsigned char *)&__src + v17) = 125;
    LODWORD(v17) = v16 + 2;
    LOBYTE(v9) = v9 ^ 0x20;
  }
LABEL_10:
  *((unsigned char *)&__src + v17) = v9;
  uint64_t v18 = v17 + 1;
  int v19 = a1[7];
  if ((v19 - 125) <= 1)
  {
    *((unsigned char *)&__src + v18) = 125;
    LOBYTE(v19) = v19 ^ 0x20;
    LODWORD(v18) = v17 + 2;
  }
  *((unsigned char *)&__src + v18) = v19;
  uint64_t v20 = v18 + 1;
  int v21 = a1[8];
  if ((v21 - 125) <= 1)
  {
    *((unsigned char *)&__src + v20) = 125;
    LODWORD(v20) = v18 + 2;
    LOBYTE(v21) = v21 ^ 0x20;
  }
  *((unsigned char *)&__src + v20) = v21;
  uint64_t v22 = v20 + 1;
  int v23 = a1[9];
  if ((v23 - 125) <= 1)
  {
    *((unsigned char *)&__src + v22) = 125;
    LODWORD(v22) = v20 + 2;
    LOBYTE(v23) = v23 ^ 0x20;
  }
  *((unsigned char *)&__src + v22) = v23;
  uint64_t v24 = v22 + 1;
  if ((a3 - 125) <= 1)
  {
    *((unsigned char *)&__src + v24) = 125;
    LOBYTE(a3) = a3 ^ 0x20;
    LODWORD(v24) = v22 + 2;
  }
  int v25 = ~(v14 ^ BYTE1(v13));
  *((unsigned char *)&__src + v24) = a3;
  uint64_t v26 = v24 + 1;
  int v27 = a1[11];
  if ((v27 - 125) <= 1)
  {
    *((unsigned char *)&__src + v26) = 125;
    LOBYTE(v27) = v27 ^ 0x20;
    LODWORD(v26) = v24 + 2;
  }
  char v28 = (unsigned __int16)(v14 ^ ~(unsigned __int16)(v13 >> 8)) >> 8;
  *((unsigned char *)&__src + v26) = v27;
  uint64_t v29 = v26 + 1;
  if ((v25 - 125) <= 1)
  {
    *((unsigned char *)&__src + v29) = 125;
    LOBYTE(v25) = v25 ^ 0x20;
    LODWORD(v29) = v26 + 2;
  }
  *((unsigned char *)&__src + v29) = v25;
  uint64_t v30 = v29 + 1;
  if (BYTE1(v15) - 125 <= 1)
  {
    *((unsigned char *)&__src + v30) = 125;
    char v28 = BYTE1(v15) ^ 0x20;
    LODWORD(v30) = v29 + 2;
  }
  *((unsigned char *)&__src + v30) = v28;
  memcpy(a1, &__src, v30 + 1);
  uint64_t result = (v30 + 2);
  a1[v30 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_CDMA_API2_CALIBRATE_INTELLICEIVER(char *a1, int a2, int a3, __int16 a4)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x14)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 1182539;
    a1[4] = 4;
    a1[10] = a3;
    *(_WORD *)(a1 + 11) = a4;
    char v9 = HIBYTE(a4);
    uint64_t v10 = a1[5];
    unsigned __int16 v11 = crc_16_l_table[v10 ^ 0x5A];
    int v12 = a1[6];
    unsigned __int16 v13 = crc_16_l_table[(v12 ^ v11)];
    unsigned __int16 v14 = crc_16_l_table[(a1[7] ^ v13 ^ HIBYTE(v11))];
    unsigned __int16 v15 = crc_16_l_table[(a1[8] ^ v14 ^ HIBYTE(v13))];
    unsigned __int16 v16 = crc_16_l_table[(a1[9] ^ v15 ^ HIBYTE(v14))];
    unsigned int v17 = crc_16_l_table[(a3 ^ v16 ^ HIBYTE(v15))];
    unsigned int v18 = crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))];
    int v19 = crc_16_l_table[HIBYTE(a4) ^ crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))] ^ (v17 >> 8)];
    int v20 = v19 ^ ~(v18 >> 8);
    *(_WORD *)(a1 + 13) = v19 ^ ~HIBYTE(crc_16_l_table[(a4 ^ v17 ^ HIBYTE(v16))]);
    if (a2 >= 30)
    {
      bzero(v40, 0x800uLL);
      int v21 = *a1;
      if ((v21 - 125) > 1)
      {
        unsigned int v22 = 0;
      }
      else
      {
        v40[0] = 125;
        LOBYTE(v21) = v21 ^ 0x20;
        unsigned int v22 = 1;
      }
      int v23 = &v40[v22];
      *int v23 = v21;
      *(_DWORD *)(v23 + 1) = 67113483;
      uint64_t v24 = v22 + 5;
      if ((v10 - 125) <= 1)
      {
        v40[v24] = 125;
        LODWORD(v24) = v22 | 6;
        LOBYTE(v10) = v10 ^ 0x20;
      }
      v40[v24] = v10;
      uint64_t v25 = v24 + 1;
      if ((v12 - 125) <= 1)
      {
        v40[v25] = 125;
        LOBYTE(v12) = v12 ^ 0x20;
        LODWORD(v25) = v24 + 2;
      }
      v40[v25] = v12;
      uint64_t v26 = v25 + 1;
      int v27 = a1[7];
      if ((v27 - 125) <= 1)
      {
        v40[v26] = 125;
        LODWORD(v26) = v25 + 2;
        LOBYTE(v27) = v27 ^ 0x20;
      }
      v40[v26] = v27;
      uint64_t v28 = v26 + 1;
      int v29 = a1[8];
      if ((v29 - 125) <= 1)
      {
        v40[v28] = 125;
        LOBYTE(v29) = v29 ^ 0x20;
        LODWORD(v28) = v26 + 2;
      }
      v40[v28] = v29;
      uint64_t v30 = v28 + 1;
      int v31 = a1[9];
      if ((v31 - 125) <= 1)
      {
        v40[v30] = 125;
        LOBYTE(v31) = v31 ^ 0x20;
        LODWORD(v30) = v28 + 2;
      }
      char v32 = a4;
      v40[v30] = v31;
      uint64_t v33 = v30 + 1;
      if ((a3 - 125) <= 1)
      {
        v40[v33] = 125;
        LOBYTE(a3) = a3 ^ 0x20;
        LODWORD(v33) = v30 + 2;
      }
      v40[v33] = a3;
      uint64_t v34 = v33 + 1;
      if (a4 - 125 <= 1)
      {
        v40[v34] = 125;
        LODWORD(v34) = v33 + 2;
        char v32 = a4 ^ 0x20;
      }
      int v35 = ~(v19 ^ BYTE1(v18));
      v40[v34] = v32;
      uint64_t v36 = v34 + 1;
      if (HIBYTE(a4) - 125 <= 1)
      {
        v40[v36] = 125;
        char v9 = HIBYTE(a4) ^ 0x20;
        LODWORD(v36) = v34 + 2;
      }
      char v37 = (unsigned __int16)(v19 ^ ~(unsigned __int16)(v18 >> 8)) >> 8;
      v40[v36] = v9;
      uint64_t v38 = v36 + 1;
      if ((v35 - 125) <= 1)
      {
        v40[v38] = 125;
        LODWORD(v38) = v36 + 2;
        LOBYTE(v35) = v35 ^ 0x20;
      }
      v40[v38] = v35;
      uint64_t v39 = v38 + 1;
      if (BYTE1(v20) - 125 <= 1)
      {
        v40[v39] = 125;
        char v37 = BYTE1(v20) ^ 0x20;
        LODWORD(v39) = v38 + 2;
      }
      v40[v39] = v37;
      memcpy(a1, v40, v39 + 1);
      uint64_t result = (v39 + 2);
      a1[v39 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_DO_ENH_XO_DC_CAL(char *a1, int a2, long long *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x33)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 1313611;
    a1[4] = -102;
    a1[8] = 12;
    long long v7 = *a3;
    long long v8 = a3[1];
    *(_OWORD *)(a1 + 40) = *(long long *)((char *)a3 + 30);
    *(_OWORD *)(a1 + 26) = v8;
    *(_OWORD *)(a1 + 10) = v7;
    int v9 = 448;
    LOWORD(v10) = -1;
    unsigned __int16 v11 = a1;
    do
    {
      char v12 = *v11++;
      int v10 = crc_16_l_table[(v12 ^ v10)] ^ ((unsigned __int16)(v10 & 0xFF00) >> 8);
      v9 -= 8;
    }
    while ((_WORD)v9);
    *((_WORD *)a1 + 28) = ~(_WORD)v10;
    if (a2 >= 116)
    {
      bzero(__src, 0x800uLL);
      uint64_t v13 = 0;
      LODWORD(v14) = 0;
      do
      {
        while (1)
        {
          int v16 = a1[v13];
          if ((v16 - 125) > 1) {
            break;
          }
          int v15 = v14 + 1;
          __src[(int)v14] = 125;
          __src[(int)v14 + 1] = v16 ^ 0x20;
          size_t v14 = (int)v14 + 1 + 1;
          if (++v13 == 58) {
            goto LABEL_11;
          }
        }
        int v15 = v14;
        __src[(int)v14] = v16;
        size_t v14 = (int)v14 + 1;
        ++v13;
      }
      while (v13 != 58);
LABEL_11:
      memcpy(a1, __src, v14);
      uint64_t result = (v15 + 2);
      a1[v14] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_DO_ENH_XO_FT_CURVE_CAL(char *a1, int a2, long long *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x33)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 1313611;
    a1[4] = -101;
    a1[8] = 12;
    long long v7 = *a3;
    long long v8 = a3[1];
    *(_OWORD *)(a1 + 40) = *(long long *)((char *)a3 + 30);
    *(_OWORD *)(a1 + 26) = v8;
    *(_OWORD *)(a1 + 10) = v7;
    int v9 = 448;
    LOWORD(v10) = -1;
    unsigned __int16 v11 = a1;
    do
    {
      char v12 = *v11++;
      int v10 = crc_16_l_table[(v12 ^ v10)] ^ ((unsigned __int16)(v10 & 0xFF00) >> 8);
      v9 -= 8;
    }
    while ((_WORD)v9);
    *((_WORD *)a1 + 28) = ~(_WORD)v10;
    if (a2 >= 116)
    {
      bzero(__src, 0x800uLL);
      uint64_t v13 = 0;
      LODWORD(v14) = 0;
      do
      {
        while (1)
        {
          int v16 = a1[v13];
          if ((v16 - 125) > 1) {
            break;
          }
          int v15 = v14 + 1;
          __src[(int)v14] = 125;
          __src[(int)v14 + 1] = v16 ^ 0x20;
          size_t v14 = (int)v14 + 1 + 1;
          if (++v13 == 58) {
            goto LABEL_11;
          }
        }
        int v15 = v14;
        __src[(int)v14] = v16;
        size_t v14 = (int)v14 + 1;
        ++v13;
      }
      while (v13 != 58);
LABEL_11:
      memcpy(a1, __src, v14);
      uint64_t result = (v15 + 2);
      a1[v14] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_CDMA2000_PILOT_ACQ(char *a1, int a2, int a3, __int16 a4, int a5)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x1F)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 461643;
    *((_WORD *)a1 + 2) = 100;
    *(_DWORD *)(a1 + 10) = a3;
    *((_WORD *)a1 + 7) = a4;
    *((_DWORD *)a1 + 4) = a5;
    unsigned __int16 v11 = crc_16_l_table[a1[6] ^ 0x7CLL];
    unsigned __int16 v12 = crc_16_l_table[a1[7] ^ 0x35 ^ v11];
    unsigned __int16 v13 = crc_16_l_table[(a1[8] ^ v12 ^ HIBYTE(v11))];
    unsigned __int16 v14 = crc_16_l_table[(a1[9] ^ v13 ^ HIBYTE(v12))];
    unsigned __int16 v15 = crc_16_l_table[(a3 ^ v14 ^ HIBYTE(v13))];
    unsigned __int16 v16 = crc_16_l_table[(BYTE1(a3) ^ v15 ^ HIBYTE(v14))];
    unsigned __int16 v17 = crc_16_l_table[(BYTE2(a3) ^ v16 ^ HIBYTE(v15))];
    unsigned __int16 v18 = crc_16_l_table[(HIBYTE(a3) ^ v17 ^ HIBYTE(v16))];
    unsigned __int16 v19 = crc_16_l_table[(a4 ^ v18 ^ HIBYTE(v17))];
    unsigned __int16 v20 = crc_16_l_table[(HIBYTE(a4) ^ v19 ^ HIBYTE(v18))];
    unsigned __int16 v21 = crc_16_l_table[(v20 ^ HIBYTE(v19) ^ a5)];
    unsigned __int16 v22 = crc_16_l_table[(a1[17] ^ v21 ^ HIBYTE(v20))];
    unsigned int v23 = crc_16_l_table[(a1[18] ^ v22 ^ HIBYTE(v21))];
    unsigned __int16 v24 = crc_16_l_table[(a1[19] ^ v23 ^ HIBYTE(v22))];
    *((_WORD *)a1 + 10) = v24 ^ ~HIBYTE(crc_16_l_table[(a1[18] ^ v22 ^ HIBYTE(v21))]);
    if (a2 >= 44)
    {
      bzero(__src, 0x800uLL);
      int v25 = *a1;
      if ((v25 - 125) > 1)
      {
        unsigned int v26 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v25) = v25 ^ 0x20;
        unsigned int v26 = 1;
      }
      __src[v26] = v25;
      uint64_t v27 = v26 + 1;
      int v28 = a1[1];
      if ((v28 - 125) <= 1)
      {
        __src[v27] = 125;
        LODWORD(v27) = v26 | 2;
        LOBYTE(v28) = v28 ^ 0x20;
      }
      __src[v27] = v28;
      uint64_t v29 = v27 + 1;
      int v30 = a1[2];
      if ((v30 - 125) <= 1)
      {
        __src[v29] = 125;
        LOBYTE(v30) = v30 ^ 0x20;
        LODWORD(v29) = v27 + 2;
      }
      __src[v29] = v30;
      uint64_t v31 = v29 + 1;
      int v32 = a1[3];
      if ((v32 - 125) <= 1)
      {
        __src[v31] = 125;
        LODWORD(v31) = v29 + 2;
        LOBYTE(v32) = v32 ^ 0x20;
      }
      __src[v31] = v32;
      uint64_t v33 = v31 + 1;
      int v34 = a1[4];
      if ((v34 - 125) <= 1)
      {
        __src[v33] = 125;
        LOBYTE(v34) = v34 ^ 0x20;
        LODWORD(v33) = v31 + 2;
      }
      __src[v33] = v34;
      uint64_t v35 = v33 + 1;
      int v36 = a1[5];
      if ((v36 - 125) <= 1)
      {
        __src[v35] = 125;
        LODWORD(v35) = v33 + 2;
        LOBYTE(v36) = v36 ^ 0x20;
      }
      __src[v35] = v36;
      uint64_t v37 = v35 + 1;
      int v38 = a1[6];
      if ((v38 - 125) <= 1)
      {
        __src[v37] = 125;
        LOBYTE(v38) = v38 ^ 0x20;
        LODWORD(v37) = v35 + 2;
      }
      __src[v37] = v38;
      uint64_t v39 = v37 + 1;
      int v40 = a1[7];
      if ((v40 - 125) <= 1)
      {
        __src[v39] = 125;
        LODWORD(v39) = v37 + 2;
        LOBYTE(v40) = v40 ^ 0x20;
      }
      __src[v39] = v40;
      uint64_t v41 = v39 + 1;
      int v42 = a1[8];
      if ((v42 - 125) <= 1)
      {
        __src[v41] = 125;
        LOBYTE(v42) = v42 ^ 0x20;
        LODWORD(v41) = v39 + 2;
      }
      __src[v41] = v42;
      uint64_t v43 = v41 + 1;
      int v44 = a1[9];
      if ((v44 - 125) <= 1)
      {
        __src[v43] = 125;
        LODWORD(v43) = v41 + 2;
        LOBYTE(v44) = v44 ^ 0x20;
      }
      __src[v43] = v44;
      uint64_t v45 = v43 + 1;
      int v46 = a1[10];
      if ((v46 - 125) <= 1)
      {
        __src[v45] = 125;
        LOBYTE(v46) = v46 ^ 0x20;
        LODWORD(v45) = v43 + 2;
      }
      __src[v45] = v46;
      uint64_t v47 = v45 + 1;
      int v48 = a1[11];
      if ((v48 - 125) <= 1)
      {
        __src[v47] = 125;
        LODWORD(v47) = v45 + 2;
        LOBYTE(v48) = v48 ^ 0x20;
      }
      __src[v47] = v48;
      uint64_t v49 = v47 + 1;
      int v50 = a1[12];
      if ((v50 - 125) <= 1)
      {
        __src[v49] = 125;
        LOBYTE(v50) = v50 ^ 0x20;
        LODWORD(v49) = v47 + 2;
      }
      __src[v49] = v50;
      uint64_t v51 = v49 + 1;
      int v52 = a1[13];
      if ((v52 - 125) <= 1)
      {
        __src[v51] = 125;
        LODWORD(v51) = v49 + 2;
        LOBYTE(v52) = v52 ^ 0x20;
      }
      __src[v51] = v52;
      uint64_t v53 = v51 + 1;
      int v54 = a1[14];
      if ((v54 - 125) <= 1)
      {
        __src[v53] = 125;
        LOBYTE(v54) = v54 ^ 0x20;
        LODWORD(v53) = v51 + 2;
      }
      __src[v53] = v54;
      uint64_t v55 = v53 + 1;
      int v56 = a1[15];
      if ((v56 - 125) <= 1)
      {
        __src[v55] = 125;
        LODWORD(v55) = v53 + 2;
        LOBYTE(v56) = v56 ^ 0x20;
      }
      __src[v55] = v56;
      uint64_t v57 = v55 + 1;
      int v58 = a1[16];
      if ((v58 - 125) <= 1)
      {
        __src[v57] = 125;
        LOBYTE(v58) = v58 ^ 0x20;
        LODWORD(v57) = v55 + 2;
      }
      __src[v57] = v58;
      uint64_t v59 = v57 + 1;
      int v60 = a1[17];
      if ((v60 - 125) <= 1)
      {
        __src[v59] = 125;
        LODWORD(v59) = v57 + 2;
        LOBYTE(v60) = v60 ^ 0x20;
      }
      __src[v59] = v60;
      uint64_t v61 = v59 + 1;
      int v62 = a1[18];
      if ((v62 - 125) <= 1)
      {
        __src[v61] = 125;
        LOBYTE(v62) = v62 ^ 0x20;
        LODWORD(v61) = v59 + 2;
      }
      int v63 = ~(v24 ^ BYTE1(v23));
      __src[v61] = v62;
      uint64_t v64 = v61 + 1;
      int v65 = a1[19];
      if ((v65 - 125) <= 1)
      {
        __src[v64] = 125;
        LOBYTE(v65) = v65 ^ 0x20;
        LODWORD(v64) = v61 + 2;
      }
      int v66 = ((unsigned __int16)(v24 ^ ~(unsigned __int16)(v23 >> 8)) >> 8);
      __src[v64] = v65;
      uint64_t v67 = v64 + 1;
      if ((v63 - 125) <= 1)
      {
        __src[v67] = 125;
        LOBYTE(v63) = v63 ^ 0x20;
        LODWORD(v67) = v64 + 2;
      }
      __src[v67] = v63;
      uint64_t v68 = v67 + 1;
      if ((v66 - 125) <= 1)
      {
        __src[v68] = 125;
        LOBYTE(v66) = v66 ^ 0x20;
        LODWORD(v68) = v67 + 2;
      }
      __src[v68] = v66;
      memcpy(a1, __src, v68 + 1);
      uint64_t result = (v68 + 2);
      a1[v68 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_CDMA2000_DEMOD_SYNC(unsigned __int8 *a1, int a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0x15) {
    return result;
  }
  bzero(a1, a2);
  *(_DWORD *)a1 = 461643;
  a1[4] = 101;
  uint64_t v5 = a1[5];
  unsigned __int16 v6 = crc_16_l_table[v5 ^ 0xFD];
  int v7 = a1[6];
  unsigned __int16 v8 = crc_16_l_table[(v7 ^ v6) ^ 0xCE];
  unsigned __int16 v9 = crc_16_l_table[(a1[7] ^ v8 ^ HIBYTE(v6))];
  unsigned int v10 = crc_16_l_table[(a1[8] ^ v9 ^ HIBYTE(v8))];
  unsigned __int16 v11 = crc_16_l_table[(a1[9] ^ v10 ^ HIBYTE(v9))];
  *((_WORD *)a1 + 5) = v11 ^ ~HIBYTE(crc_16_l_table[(a1[8] ^ v9 ^ HIBYTE(v8))]);
  if (a2 < 24) {
    return 0xFFFFFFFFLL;
  }
  bzero(v26, 0x7FBuLL);
  int __src = 461643;
  char v25 = 101;
  if ((v5 - 125) <= 1)
  {
    v26[0] = 125;
    int v12 = 6;
    v26[1] = v5 ^ 0x20;
    uint64_t v13 = 7;
    if ((v7 - 125) > 1) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v12 = 5;
  v26[0] = v5;
  uint64_t v13 = 6;
  if ((v7 - 125) <= 1)
  {
LABEL_9:
    *((unsigned char *)&__src + v13) = 125;
    LOBYTE(v7) = v7 ^ 0x20;
    LODWORD(v13) = v12 + 2;
  }
LABEL_10:
  *((unsigned char *)&__src + v13) = v7;
  uint64_t v14 = v13 + 1;
  int v15 = a1[7];
  if ((v15 - 125) <= 1)
  {
    *((unsigned char *)&__src + v14) = 125;
    LODWORD(v14) = v13 + 2;
    LOBYTE(v15) = v15 ^ 0x20;
  }
  *((unsigned char *)&__src + v14) = v15;
  uint64_t v16 = v14 + 1;
  int v17 = a1[8];
  if ((v17 - 125) <= 1)
  {
    *((unsigned char *)&__src + v16) = 125;
    LOBYTE(v17) = v17 ^ 0x20;
    LODWORD(v16) = v14 + 2;
  }
  int v18 = ~(v11 ^ BYTE1(v10));
  *((unsigned char *)&__src + v16) = v17;
  uint64_t v19 = v16 + 1;
  int v20 = a1[9];
  if ((v20 - 125) <= 1)
  {
    *((unsigned char *)&__src + v19) = 125;
    LOBYTE(v20) = v20 ^ 0x20;
    LODWORD(v19) = v16 + 2;
  }
  int v21 = ((unsigned __int16)(v11 ^ ~(unsigned __int16)(v10 >> 8)) >> 8);
  *((unsigned char *)&__src + v19) = v20;
  uint64_t v22 = v19 + 1;
  if ((v18 - 125) <= 1)
  {
    *((unsigned char *)&__src + v22) = 125;
    LOBYTE(v18) = v18 ^ 0x20;
    LODWORD(v22) = v19 + 2;
  }
  *((unsigned char *)&__src + v22) = v18;
  uint64_t v23 = v22 + 1;
  if ((v21 - 125) <= 1)
  {
    *((unsigned char *)&__src + v23) = 125;
    LOBYTE(v21) = v21 ^ 0x20;
    LODWORD(v23) = v22 + 2;
  }
  *((unsigned char *)&__src + v23) = v21;
  memcpy(a1, &__src, v23 + 1);
  uint64_t result = (v23 + 2);
  a1[v23 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_CDMA2000_DEMOD_FCH(char *a1, int a2, int a3, char a4, char a5, char a6, char a7, char a8, char a9, uint64_t a10, char a11, char a12, char a13, char a14)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x1F)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 461643;
    *((_WORD *)a1 + 2) = 102;
    *(_DWORD *)(a1 + 10) = a3;
    a1[14] = a4;
    a1[15] = a5;
    a1[16] = a6;
    a1[17] = a7;
    a1[18] = a8;
    a1[19] = a9;
    *((_DWORD *)a1 + 5) = a10;
    a1[24] = a11;
    a1[25] = a12;
    a1[26] = a13;
    a1[27] = a14;
    unsigned __int16 v22 = crc_16_l_table[a1[6] ^ 0xCCLL];
    unsigned __int16 v23 = crc_16_l_table[(a1[7] ^ v22) ^ 6];
    unsigned __int16 v24 = crc_16_l_table[(a1[8] ^ v23 ^ HIBYTE(v22))];
    unsigned __int16 v25 = crc_16_l_table[(a1[9] ^ v24 ^ HIBYTE(v23))];
    unsigned __int16 v26 = crc_16_l_table[(a3 ^ v25 ^ HIBYTE(v24))];
    unsigned __int16 v27 = crc_16_l_table[(BYTE1(a3) ^ v26 ^ HIBYTE(v25))];
    unsigned __int16 v28 = crc_16_l_table[(BYTE2(a3) ^ v27 ^ HIBYTE(v26))];
    unsigned __int16 v29 = crc_16_l_table[(HIBYTE(a3) ^ v28 ^ HIBYTE(v27))];
    unsigned __int16 v30 = crc_16_l_table[(a4 ^ v29 ^ HIBYTE(v28))];
    unsigned __int16 v31 = crc_16_l_table[(a5 ^ v30 ^ HIBYTE(v29))];
    unsigned __int16 v32 = crc_16_l_table[(a6 ^ v31 ^ HIBYTE(v30))];
    unsigned __int16 v33 = crc_16_l_table[(a7 ^ v32 ^ HIBYTE(v31))];
    unsigned __int16 v34 = crc_16_l_table[(a8 ^ v33 ^ HIBYTE(v32))];
    unsigned __int16 v35 = crc_16_l_table[(a9 ^ v34 ^ HIBYTE(v33))];
    unsigned __int16 v36 = crc_16_l_table[(a10 ^ v35 ^ HIBYTE(v34))];
    unsigned __int16 v37 = crc_16_l_table[(a1[21] ^ v36 ^ HIBYTE(v35))];
    unsigned __int16 v38 = crc_16_l_table[(a1[22] ^ v37 ^ HIBYTE(v36))];
    unsigned __int16 v39 = crc_16_l_table[(a1[23] ^ v38 ^ HIBYTE(v37))];
    unsigned __int16 v40 = crc_16_l_table[(a11 ^ v39 ^ HIBYTE(v38))];
    unsigned __int16 v41 = crc_16_l_table[(a12 ^ v40 ^ HIBYTE(v39))];
    unsigned int v42 = crc_16_l_table[(a13 ^ v41 ^ HIBYTE(v40))];
    *((_WORD *)a1 + 14) = crc_16_l_table[(a14 ^ v42 ^ HIBYTE(v41))] ^ ~(unsigned __int16)(v42 >> 8);
    if (a2 >= 60)
    {
      bzero(__src, 0x800uLL);
      uint64_t v43 = 0;
      LODWORD(v44) = 0;
      do
      {
        while (1)
        {
          int v46 = a1[v43];
          if ((v46 - 125) > 1) {
            break;
          }
          int v45 = v44 + 1;
          __src[(int)v44] = 125;
          __src[(int)v44 + 1] = v46 ^ 0x20;
          size_t v44 = (int)v44 + 1 + 1;
          if (++v43 == 30) {
            goto LABEL_9;
          }
        }
        int v45 = v44;
        __src[(int)v44] = v46;
        size_t v44 = (int)v44 + 1;
        ++v43;
      }
      while (v43 != 30);
LABEL_9:
      memcpy(a1, __src, v44);
      uint64_t result = (v45 + 2);
      a1[v44] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_CDMA2000_MOD_FCH(char *a1, int a2, int a3, char a4, int a5, char a6, __int16 a7, int a8)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x1F)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 461643;
    *((_WORD *)a1 + 2) = 104;
    *(_DWORD *)(a1 + 10) = a3;
    a1[14] = a4;
    *(_DWORD *)(a1 + 15) = a5;
    a1[19] = a6;
    *((_WORD *)a1 + 10) = a7;
    *((_DWORD *)a1 + 6) = a8;
    unsigned __int16 v17 = crc_16_l_table[a1[6] ^ 0xDCLL];
    unsigned __int16 v18 = crc_16_l_table[a1[7] ^ 0x9C ^ v17];
    unsigned __int16 v19 = crc_16_l_table[(a1[8] ^ v18 ^ HIBYTE(v17))];
    unsigned __int16 v20 = crc_16_l_table[(a1[9] ^ v19 ^ HIBYTE(v18))];
    unsigned __int16 v21 = crc_16_l_table[(a3 ^ v20 ^ HIBYTE(v19))];
    unsigned __int16 v22 = crc_16_l_table[(BYTE1(a3) ^ v21 ^ HIBYTE(v20))];
    unsigned __int16 v23 = crc_16_l_table[(BYTE2(a3) ^ v22 ^ HIBYTE(v21))];
    unsigned __int16 v24 = crc_16_l_table[(HIBYTE(a3) ^ v23 ^ HIBYTE(v22))];
    unsigned __int16 v25 = crc_16_l_table[(a4 ^ v24 ^ HIBYTE(v23))];
    unsigned __int16 v26 = crc_16_l_table[(a5 ^ v25 ^ HIBYTE(v24))];
    unsigned __int16 v27 = crc_16_l_table[(BYTE1(a5) ^ v26 ^ HIBYTE(v25))];
    unsigned __int16 v28 = crc_16_l_table[(BYTE2(a5) ^ v27 ^ HIBYTE(v26))];
    unsigned __int16 v29 = crc_16_l_table[(HIBYTE(a5) ^ v28 ^ HIBYTE(v27))];
    unsigned __int16 v30 = crc_16_l_table[(a6 ^ v29 ^ HIBYTE(v28))];
    unsigned __int16 v31 = crc_16_l_table[(a7 ^ v30 ^ HIBYTE(v29))];
    unsigned __int16 v32 = crc_16_l_table[(HIBYTE(a7) ^ v31 ^ HIBYTE(v30))];
    unsigned __int16 v33 = crc_16_l_table[(a1[22] ^ v32 ^ HIBYTE(v31))];
    unsigned __int16 v34 = crc_16_l_table[(a1[23] ^ v33 ^ HIBYTE(v32))];
    unsigned __int16 v35 = crc_16_l_table[(a8 ^ v34 ^ HIBYTE(v33))];
    unsigned __int16 v36 = crc_16_l_table[(a1[25] ^ v35 ^ HIBYTE(v34))];
    unsigned int v37 = crc_16_l_table[(a1[26] ^ v36 ^ HIBYTE(v35))];
    *((_WORD *)a1 + 14) = crc_16_l_table[(a1[27] ^ v37 ^ HIBYTE(v36))] ^ ~(unsigned __int16)(v37 >> 8);
    if (a2 >= 60)
    {
      bzero(__src, 0x800uLL);
      uint64_t v38 = 0;
      LODWORD(v39) = 0;
      do
      {
        while (1)
        {
          int v41 = a1[v38];
          if ((v41 - 125) > 1) {
            break;
          }
          int v40 = v39 + 1;
          __src[(int)v39] = 125;
          __src[(int)v39 + 1] = v41 ^ 0x20;
          size_t v39 = (int)v39 + 1 + 1;
          if (++v38 == 30) {
            goto LABEL_9;
          }
        }
        int v40 = v39;
        __src[(int)v39] = v41;
        size_t v39 = (int)v39 + 1;
        ++v38;
      }
      while (v38 != 30);
LABEL_9:
      memcpy(a1, __src, v39);
      uint64_t result = (v40 + 2);
      a1[v39] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_CDMA2000_FTM_FWD_HHO_SC(char *a1, int a2, int a3, __int16 a4, __int16 a5)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x1F)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 461643;
    *((_WORD *)a1 + 2) = 128;
    *(_DWORD *)(a1 + 10) = a3;
    *((_WORD *)a1 + 7) = a4;
    *((_WORD *)a1 + 8) = a5;
    unsigned __int16 v11 = crc_16_l_table[a1[6] ^ 0x85];
    unsigned __int16 v12 = crc_16_l_table[(a1[7] ^ v11) ^ 0xBB];
    unsigned __int16 v13 = crc_16_l_table[(a1[8] ^ v12 ^ HIBYTE(v11))];
    unsigned __int16 v14 = crc_16_l_table[(a1[9] ^ v13 ^ HIBYTE(v12))];
    unsigned __int16 v15 = crc_16_l_table[(a3 ^ v14 ^ HIBYTE(v13))];
    unsigned __int16 v16 = crc_16_l_table[(BYTE1(a3) ^ v15 ^ HIBYTE(v14))];
    unsigned __int16 v17 = crc_16_l_table[(BYTE2(a3) ^ v16 ^ HIBYTE(v15))];
    unsigned __int16 v18 = crc_16_l_table[(HIBYTE(a3) ^ v17 ^ HIBYTE(v16))];
    unsigned __int16 v19 = crc_16_l_table[(a4 ^ v18 ^ HIBYTE(v17))];
    unsigned __int16 v20 = crc_16_l_table[(HIBYTE(a4) ^ v19 ^ HIBYTE(v18))];
    unsigned int v21 = crc_16_l_table[(v20 ^ HIBYTE(v19) ^ a5)];
    unsigned __int16 v22 = crc_16_l_table[(a1[17] ^ v21 ^ HIBYTE(v20))];
    *((_WORD *)a1 + 9) = v22 ^ ~HIBYTE(crc_16_l_table[(v20 ^ HIBYTE(v19) ^ a5)]);
    if (a2 >= 40)
    {
      bzero(__src, 0x800uLL);
      int v23 = *a1;
      if ((v23 - 125) > 1)
      {
        unsigned int v24 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v23) = v23 ^ 0x20;
        unsigned int v24 = 1;
      }
      __src[v24] = v23;
      uint64_t v25 = v24 + 1;
      int v26 = a1[1];
      if ((v26 - 125) <= 1)
      {
        __src[v25] = 125;
        LODWORD(v25) = v24 | 2;
        LOBYTE(v26) = v26 ^ 0x20;
      }
      __src[v25] = v26;
      uint64_t v27 = v25 + 1;
      int v28 = a1[2];
      if ((v28 - 125) <= 1)
      {
        __src[v27] = 125;
        LOBYTE(v28) = v28 ^ 0x20;
        LODWORD(v27) = v25 + 2;
      }
      __src[v27] = v28;
      uint64_t v29 = v27 + 1;
      int v30 = a1[3];
      if ((v30 - 125) <= 1)
      {
        __src[v29] = 125;
        LODWORD(v29) = v27 + 2;
        LOBYTE(v30) = v30 ^ 0x20;
      }
      __src[v29] = v30;
      uint64_t v31 = v29 + 1;
      int v32 = a1[4];
      if ((v32 - 125) <= 1)
      {
        __src[v31] = 125;
        LOBYTE(v32) = v32 ^ 0x20;
        LODWORD(v31) = v29 + 2;
      }
      __src[v31] = v32;
      uint64_t v33 = v31 + 1;
      int v34 = a1[5];
      if ((v34 - 125) <= 1)
      {
        __src[v33] = 125;
        LODWORD(v33) = v31 + 2;
        LOBYTE(v34) = v34 ^ 0x20;
      }
      __src[v33] = v34;
      uint64_t v35 = v33 + 1;
      int v36 = a1[6];
      if ((v36 - 125) <= 1)
      {
        __src[v35] = 125;
        LOBYTE(v36) = v36 ^ 0x20;
        LODWORD(v35) = v33 + 2;
      }
      __src[v35] = v36;
      uint64_t v37 = v35 + 1;
      int v38 = a1[7];
      if ((v38 - 125) <= 1)
      {
        __src[v37] = 125;
        LODWORD(v37) = v35 + 2;
        LOBYTE(v38) = v38 ^ 0x20;
      }
      __src[v37] = v38;
      uint64_t v39 = v37 + 1;
      int v40 = a1[8];
      if ((v40 - 125) <= 1)
      {
        __src[v39] = 125;
        LOBYTE(v40) = v40 ^ 0x20;
        LODWORD(v39) = v37 + 2;
      }
      __src[v39] = v40;
      uint64_t v41 = v39 + 1;
      int v42 = a1[9];
      if ((v42 - 125) <= 1)
      {
        __src[v41] = 125;
        LODWORD(v41) = v39 + 2;
        LOBYTE(v42) = v42 ^ 0x20;
      }
      __src[v41] = v42;
      uint64_t v43 = v41 + 1;
      int v44 = a1[10];
      if ((v44 - 125) <= 1)
      {
        __src[v43] = 125;
        LOBYTE(v44) = v44 ^ 0x20;
        LODWORD(v43) = v41 + 2;
      }
      __src[v43] = v44;
      uint64_t v45 = v43 + 1;
      int v46 = a1[11];
      if ((v46 - 125) <= 1)
      {
        __src[v45] = 125;
        LODWORD(v45) = v43 + 2;
        LOBYTE(v46) = v46 ^ 0x20;
      }
      __src[v45] = v46;
      uint64_t v47 = v45 + 1;
      int v48 = a1[12];
      if ((v48 - 125) <= 1)
      {
        __src[v47] = 125;
        LOBYTE(v48) = v48 ^ 0x20;
        LODWORD(v47) = v45 + 2;
      }
      __src[v47] = v48;
      uint64_t v49 = v47 + 1;
      int v50 = a1[13];
      if ((v50 - 125) <= 1)
      {
        __src[v49] = 125;
        LODWORD(v49) = v47 + 2;
        LOBYTE(v50) = v50 ^ 0x20;
      }
      __src[v49] = v50;
      uint64_t v51 = v49 + 1;
      int v52 = a1[14];
      if ((v52 - 125) <= 1)
      {
        __src[v51] = 125;
        LOBYTE(v52) = v52 ^ 0x20;
        LODWORD(v51) = v49 + 2;
      }
      __src[v51] = v52;
      uint64_t v53 = v51 + 1;
      int v54 = a1[15];
      if ((v54 - 125) <= 1)
      {
        __src[v53] = 125;
        LODWORD(v53) = v51 + 2;
        LOBYTE(v54) = v54 ^ 0x20;
      }
      __src[v53] = v54;
      uint64_t v55 = v53 + 1;
      int v56 = a1[16];
      if ((v56 - 125) <= 1)
      {
        __src[v55] = 125;
        LOBYTE(v56) = v56 ^ 0x20;
        LODWORD(v55) = v53 + 2;
      }
      int v57 = ~(v22 ^ BYTE1(v21));
      __src[v55] = v56;
      uint64_t v58 = v55 + 1;
      int v59 = a1[17];
      if ((v59 - 125) <= 1)
      {
        __src[v58] = 125;
        LOBYTE(v59) = v59 ^ 0x20;
        LODWORD(v58) = v55 + 2;
      }
      int v60 = ((unsigned __int16)(v22 ^ ~(unsigned __int16)(v21 >> 8)) >> 8);
      __src[v58] = v59;
      uint64_t v61 = v58 + 1;
      if ((v57 - 125) <= 1)
      {
        __src[v61] = 125;
        LOBYTE(v57) = v57 ^ 0x20;
        LODWORD(v61) = v58 + 2;
      }
      __src[v61] = v57;
      uint64_t v62 = v61 + 1;
      if ((v60 - 125) <= 1)
      {
        __src[v62] = 125;
        LOBYTE(v60) = v60 ^ 0x20;
        LODWORD(v62) = v61 + 2;
      }
      __src[v62] = v60;
      memcpy(a1, __src, v62 + 1);
      uint64_t result = (v62 + 2);
      a1[v62 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_CDMA2000_CMD_RELEASE(unsigned __int8 *a1, int a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0x33) {
    return result;
  }
  bzero(a1, a2);
  *(_DWORD *)a1 = 461643;
  a1[4] = 108;
  uint64_t v5 = a1[5];
  unsigned __int16 v6 = crc_16_l_table[v5 ^ 0x3C];
  int v7 = a1[6];
  unsigned __int16 v8 = crc_16_l_table[(v7 ^ v6) ^ 0x53];
  unsigned __int16 v9 = crc_16_l_table[(a1[7] ^ v8 ^ HIBYTE(v6))];
  unsigned int v10 = crc_16_l_table[(a1[8] ^ v9 ^ HIBYTE(v8))];
  unsigned __int16 v11 = crc_16_l_table[(a1[9] ^ v10 ^ HIBYTE(v9))];
  *((_WORD *)a1 + 5) = v11 ^ ~HIBYTE(crc_16_l_table[(a1[8] ^ v9 ^ HIBYTE(v8))]);
  if (a2 < 24) {
    return 0xFFFFFFFFLL;
  }
  bzero(v26, 0x7FBuLL);
  int __src = 461643;
  char v25 = 108;
  if ((v5 - 125) <= 1)
  {
    v26[0] = 125;
    int v12 = 6;
    v26[1] = v5 ^ 0x20;
    uint64_t v13 = 7;
    if ((v7 - 125) > 1) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v12 = 5;
  v26[0] = v5;
  uint64_t v13 = 6;
  if ((v7 - 125) <= 1)
  {
LABEL_9:
    *((unsigned char *)&__src + v13) = 125;
    LOBYTE(v7) = v7 ^ 0x20;
    LODWORD(v13) = v12 + 2;
  }
LABEL_10:
  *((unsigned char *)&__src + v13) = v7;
  uint64_t v14 = v13 + 1;
  int v15 = a1[7];
  if ((v15 - 125) <= 1)
  {
    *((unsigned char *)&__src + v14) = 125;
    LODWORD(v14) = v13 + 2;
    LOBYTE(v15) = v15 ^ 0x20;
  }
  *((unsigned char *)&__src + v14) = v15;
  uint64_t v16 = v14 + 1;
  int v17 = a1[8];
  if ((v17 - 125) <= 1)
  {
    *((unsigned char *)&__src + v16) = 125;
    LOBYTE(v17) = v17 ^ 0x20;
    LODWORD(v16) = v14 + 2;
  }
  int v18 = ~(v11 ^ BYTE1(v10));
  *((unsigned char *)&__src + v16) = v17;
  uint64_t v19 = v16 + 1;
  int v20 = a1[9];
  if ((v20 - 125) <= 1)
  {
    *((unsigned char *)&__src + v19) = 125;
    LOBYTE(v20) = v20 ^ 0x20;
    LODWORD(v19) = v16 + 2;
  }
  int v21 = ((unsigned __int16)(v11 ^ ~(unsigned __int16)(v10 >> 8)) >> 8);
  *((unsigned char *)&__src + v19) = v20;
  uint64_t v22 = v19 + 1;
  if ((v18 - 125) <= 1)
  {
    *((unsigned char *)&__src + v22) = 125;
    LOBYTE(v18) = v18 ^ 0x20;
    LODWORD(v22) = v19 + 2;
  }
  *((unsigned char *)&__src + v22) = v18;
  uint64_t v23 = v22 + 1;
  if ((v21 - 125) <= 1)
  {
    *((unsigned char *)&__src + v23) = 125;
    LOBYTE(v21) = v21 ^ 0x20;
    LODWORD(v23) = v22 + 2;
  }
  *((unsigned char *)&__src + v23) = v21;
  memcpy(a1, &__src, v23 + 1);
  uint64_t result = (v23 + 2);
  a1[v23 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_PILOT_ACQ(char *a1, int a2, int a3, __int16 a4, int a5, int a6)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x23)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 113;
    *(_DWORD *)(a1 + 10) = a3;
    *((_WORD *)a1 + 7) = a4;
    *((_DWORD *)a1 + 4) = a5;
    *((_DWORD *)a1 + 5) = a6;
    unsigned __int16 v13 = crc_16_l_table[a1[6] ^ 0xACLL];
    unsigned __int16 v14 = crc_16_l_table[a1[7] ^ 0x6C ^ v13];
    unsigned __int16 v15 = crc_16_l_table[(a1[8] ^ v14 ^ HIBYTE(v13))];
    unsigned __int16 v16 = crc_16_l_table[(a1[9] ^ v15 ^ HIBYTE(v14))];
    unsigned __int16 v17 = crc_16_l_table[(a3 ^ v16 ^ HIBYTE(v15))];
    unsigned __int16 v18 = crc_16_l_table[(BYTE1(a3) ^ v17 ^ HIBYTE(v16))];
    unsigned __int16 v19 = crc_16_l_table[(BYTE2(a3) ^ v18 ^ HIBYTE(v17))];
    unsigned __int16 v20 = crc_16_l_table[(HIBYTE(a3) ^ v19 ^ HIBYTE(v18))];
    unsigned __int16 v21 = crc_16_l_table[(a4 ^ v20 ^ HIBYTE(v19))];
    unsigned __int16 v22 = crc_16_l_table[(HIBYTE(a4) ^ v21 ^ HIBYTE(v20))];
    unsigned __int16 v23 = crc_16_l_table[(a5 ^ v22 ^ HIBYTE(v21))];
    unsigned __int16 v24 = crc_16_l_table[(a1[17] ^ v23 ^ HIBYTE(v22))];
    unsigned __int16 v25 = crc_16_l_table[(a1[18] ^ v24 ^ HIBYTE(v23))];
    unsigned __int16 v26 = crc_16_l_table[(a1[19] ^ v25 ^ HIBYTE(v24))];
    unsigned __int16 v27 = crc_16_l_table[(a6 ^ v26 ^ HIBYTE(v25))];
    unsigned __int16 v28 = crc_16_l_table[(a1[21] ^ v27 ^ HIBYTE(v26))];
    unsigned int v29 = crc_16_l_table[(a1[22] ^ v28 ^ HIBYTE(v27))];
    *((_WORD *)a1 + 12) = crc_16_l_table[(a1[23] ^ v29 ^ HIBYTE(v28))] ^ ~(unsigned __int16)(v29 >> 8);
    if (a2 >= 52)
    {
      bzero(__src, 0x800uLL);
      uint64_t v30 = 0;
      LODWORD(v31) = 0;
      do
      {
        while (1)
        {
          int v33 = a1[v30];
          if ((v33 - 125) > 1) {
            break;
          }
          int v32 = v31 + 1;
          __src[(int)v31] = 125;
          __src[(int)v31 + 1] = v33 ^ 0x20;
          size_t v31 = (int)v31 + 1 + 1;
          if (++v30 == 26) {
            goto LABEL_9;
          }
        }
        int v32 = v31;
        __src[(int)v31] = v33;
        size_t v31 = (int)v31 + 1;
        ++v30;
      }
      while (v30 != 26);
LABEL_9:
      memcpy(a1, __src, v31);
      uint64_t result = (v32 + 2);
      a1[v31] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_SYS_TIME_ACQ(unsigned __int8 *a1, int a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x1F)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 114;
    a1[6] = 10;
    unsigned __int16 v5 = crc_16_l_table[a1[7] ^ 0x34];
    unsigned int v6 = crc_16_l_table[a1[8] ^ 0x2F ^ v5];
    unsigned __int16 v7 = crc_16_l_table[(a1[9] ^ v6 ^ HIBYTE(v5))];
    *((_WORD *)a1 + 5) = v7 ^ ~HIBYTE(crc_16_l_table[a1[8] ^ 0x2F ^ v5]);
    if (a2 >= 24)
    {
      bzero(v21, 0x7F9uLL);
      int __src = 527179;
      __int16 v19 = 114;
      char v20 = 10;
      int v8 = a1[7];
      if ((v8 - 125) > 1)
      {
        unsigned int v9 = 7;
      }
      else
      {
        v21[0] = 125;
        LOBYTE(v8) = v8 ^ 0x20;
        unsigned int v9 = 8;
      }
      *((unsigned char *)&__src + v9) = v8;
      uint64_t v10 = v9 + 1;
      int v11 = a1[8];
      if ((v11 - 125) <= 1)
      {
        *((unsigned char *)&__src + v10) = 125;
        LODWORD(v10) = v9 + 2;
        LOBYTE(v11) = v11 ^ 0x20;
      }
      int v12 = ~(v7 ^ BYTE1(v6));
      *((unsigned char *)&__src + v10) = v11;
      uint64_t v13 = v10 + 1;
      int v14 = a1[9];
      if ((v14 - 125) <= 1)
      {
        *((unsigned char *)&__src + v13) = 125;
        LOBYTE(v14) = v14 ^ 0x20;
        LODWORD(v13) = v10 + 2;
      }
      int v15 = ((unsigned __int16)(v7 ^ ~(unsigned __int16)(v6 >> 8)) >> 8);
      *((unsigned char *)&__src + v13) = v14;
      uint64_t v16 = v13 + 1;
      if ((v12 - 125) <= 1)
      {
        *((unsigned char *)&__src + v16) = 125;
        LOBYTE(v12) = v12 ^ 0x20;
        LODWORD(v16) = v13 + 2;
      }
      *((unsigned char *)&__src + v16) = v12;
      uint64_t v17 = v16 + 1;
      if ((v15 - 125) <= 1)
      {
        *((unsigned char *)&__src + v17) = 125;
        LOBYTE(v15) = v15 ^ 0x20;
        LODWORD(v17) = v16 + 2;
      }
      *((unsigned char *)&__src + v17) = v15;
      memcpy(a1, &__src, v17 + 1);
      uint64_t result = (v17 + 2);
      a1[v17 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_DEMOD_CC_MAC_FTC(unsigned __int8 *a1, int a2, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x1B)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 115;
    a1[10] = a3;
    a1[11] = a4;
    a1[12] = a5;
    a1[13] = a6;
    a1[14] = a7;
    a1[15] = a8;
    uint64_t v17 = a1[6];
    unsigned __int16 v18 = crc_16_l_table[v17 ^ 0x1C];
    unsigned __int16 v19 = crc_16_l_table[a1[7] ^ 0x5F ^ v18];
    unsigned __int16 v20 = crc_16_l_table[(a1[8] ^ v19 ^ HIBYTE(v18))];
    unsigned __int16 v21 = crc_16_l_table[(a1[9] ^ v20 ^ HIBYTE(v19))];
    unsigned __int16 v22 = crc_16_l_table[(a3 ^ v21 ^ HIBYTE(v20))];
    unsigned __int16 v23 = crc_16_l_table[(a4 ^ v22 ^ HIBYTE(v21))];
    unsigned __int16 v24 = crc_16_l_table[(a5 ^ v23 ^ HIBYTE(v22))];
    unsigned __int16 v25 = crc_16_l_table[(a6 ^ v24 ^ HIBYTE(v23))];
    unsigned int v26 = crc_16_l_table[(a7 ^ v25 ^ HIBYTE(v24))];
    int v27 = crc_16_l_table[(v26 ^ HIBYTE(v25) ^ a8)];
    int v28 = v27 ^ ~(v26 >> 8);
    *((_WORD *)a1 + 8) = v27 ^ ~(unsigned __int16)(v26 >> 8);
    if (a2 >= 36)
    {
      bzero(__src, 0x800uLL);
      int v29 = *a1;
      if ((v29 - 125) > 1)
      {
        unsigned int v30 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v29) = v29 ^ 0x20;
        unsigned int v30 = 1;
      }
      __src[v30] = v29;
      uint64_t v31 = v30 + 1;
      int v32 = a1[1];
      if ((v32 - 125) <= 1)
      {
        __src[v31] = 125;
        LODWORD(v31) = v30 | 2;
        LOBYTE(v32) = v32 ^ 0x20;
      }
      __src[v31] = v32;
      uint64_t v33 = v31 + 1;
      int v34 = a1[2];
      if ((v34 - 125) <= 1)
      {
        __src[v33] = 125;
        LOBYTE(v34) = v34 ^ 0x20;
        LODWORD(v33) = v31 + 2;
      }
      __src[v33] = v34;
      uint64_t v35 = v33 + 1;
      int v36 = a1[3];
      if ((v36 - 125) <= 1)
      {
        __src[v35] = 125;
        LODWORD(v35) = v33 + 2;
        LOBYTE(v36) = v36 ^ 0x20;
      }
      __src[v35] = v36;
      uint64_t v37 = v35 + 1;
      int v38 = a1[4];
      if ((v38 - 125) <= 1)
      {
        __src[v37] = 125;
        LOBYTE(v38) = v38 ^ 0x20;
        LODWORD(v37) = v35 + 2;
      }
      __src[v37] = v38;
      uint64_t v39 = v37 + 1;
      int v40 = a1[5];
      if ((v40 - 125) <= 1)
      {
        __src[v39] = 125;
        LODWORD(v39) = v37 + 2;
        LOBYTE(v40) = v40 ^ 0x20;
      }
      __src[v39] = v40;
      uint64_t v41 = v39 + 1;
      if ((v17 - 125) <= 1)
      {
        __src[v41] = 125;
        LOBYTE(v17) = v17 ^ 0x20;
        LODWORD(v41) = v39 + 2;
      }
      __src[v41] = v17;
      uint64_t v42 = v41 + 1;
      int v43 = a1[7];
      if ((v43 - 125) <= 1)
      {
        __src[v42] = 125;
        LODWORD(v42) = v41 + 2;
        LOBYTE(v43) = v43 ^ 0x20;
      }
      __src[v42] = v43;
      uint64_t v44 = v42 + 1;
      int v45 = a1[8];
      if ((v45 - 125) <= 1)
      {
        __src[v44] = 125;
        LOBYTE(v45) = v45 ^ 0x20;
        LODWORD(v44) = v42 + 2;
      }
      __src[v44] = v45;
      uint64_t v46 = v44 + 1;
      int v47 = a1[9];
      if ((v47 - 125) <= 1)
      {
        __src[v46] = 125;
        LODWORD(v46) = v44 + 2;
        LOBYTE(v47) = v47 ^ 0x20;
      }
      __src[v46] = v47;
      uint64_t v48 = v46 + 1;
      int v49 = a1[10];
      if ((v49 - 125) <= 1)
      {
        __src[v48] = 125;
        LOBYTE(v49) = v49 ^ 0x20;
        LODWORD(v48) = v46 + 2;
      }
      __src[v48] = v49;
      uint64_t v50 = v48 + 1;
      int v51 = a1[11];
      if ((v51 - 125) <= 1)
      {
        __src[v50] = 125;
        LODWORD(v50) = v48 + 2;
        LOBYTE(v51) = v51 ^ 0x20;
      }
      __src[v50] = v51;
      uint64_t v52 = v50 + 1;
      int v53 = a1[12];
      if ((v53 - 125) <= 1)
      {
        __src[v52] = 125;
        LOBYTE(v53) = v53 ^ 0x20;
        LODWORD(v52) = v50 + 2;
      }
      __src[v52] = v53;
      uint64_t v54 = v52 + 1;
      int v55 = a1[13];
      if ((v55 - 125) <= 1)
      {
        __src[v54] = 125;
        LODWORD(v54) = v52 + 2;
        LOBYTE(v55) = v55 ^ 0x20;
      }
      __src[v54] = v55;
      uint64_t v56 = v54 + 1;
      int v57 = a1[14];
      if ((v57 - 125) <= 1)
      {
        __src[v56] = 125;
        LOBYTE(v57) = v57 ^ 0x20;
        LODWORD(v56) = v54 + 2;
      }
      int v58 = ~(v27 ^ BYTE1(v26));
      __src[v56] = v57;
      uint64_t v59 = v56 + 1;
      int v60 = a1[15];
      if ((v60 - 125) <= 1)
      {
        __src[v59] = 125;
        LOBYTE(v60) = v60 ^ 0x20;
        LODWORD(v59) = v56 + 2;
      }
      char v61 = (unsigned __int16)(v27 ^ ~(unsigned __int16)(v26 >> 8)) >> 8;
      __src[v59] = v60;
      uint64_t v62 = v59 + 1;
      if ((v58 - 125) <= 1)
      {
        __src[v62] = 125;
        LOBYTE(v58) = v58 ^ 0x20;
        LODWORD(v62) = v59 + 2;
      }
      __src[v62] = v58;
      uint64_t v63 = v62 + 1;
      if (BYTE1(v28) - 125 <= 1)
      {
        __src[v63] = 125;
        char v61 = BYTE1(v28) ^ 0x20;
        LODWORD(v63) = v62 + 2;
      }
      __src[v63] = v61;
      memcpy(a1, __src, v63 + 1);
      uint64_t result = (v63 + 2);
      a1[v63 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_MOD_ACC(char *a1, int a2, int a3, int a4, int a5, int a6, int a7, char a8, char a9, char a10, char a11, char a12, char a13)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x2F)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 116;
    *(_DWORD *)(a1 + 10) = a3;
    *(_DWORD *)(a1 + 14) = a4;
    *(_DWORD *)(a1 + 18) = a5;
    *(_DWORD *)(a1 + 22) = a6;
    *(_DWORD *)(a1 + 26) = a7;
    a1[30] = a8;
    a1[31] = a9;
    a1[32] = a10;
    a1[33] = a11;
    a1[34] = a12;
    a1[35] = a13;
    unsigned __int16 v21 = crc_16_l_table[a1[6] ^ 0x14];
    unsigned __int16 v22 = crc_16_l_table[a1[7] ^ 0x12 ^ v21];
    unsigned __int16 v23 = crc_16_l_table[(a1[8] ^ v22 ^ HIBYTE(v21))];
    unsigned __int16 v24 = crc_16_l_table[(a1[9] ^ v23 ^ HIBYTE(v22))];
    unsigned __int16 v25 = crc_16_l_table[(a1[10] ^ v24 ^ HIBYTE(v23))];
    unsigned __int16 v26 = crc_16_l_table[(a1[11] ^ v25 ^ HIBYTE(v24))];
    unsigned __int16 v27 = crc_16_l_table[(a1[12] ^ v26 ^ HIBYTE(v25))];
    unsigned __int16 v28 = crc_16_l_table[(a1[13] ^ v27 ^ HIBYTE(v26))];
    unsigned __int16 v29 = crc_16_l_table[(a1[14] ^ v28 ^ HIBYTE(v27))];
    unsigned __int16 v30 = crc_16_l_table[(a1[15] ^ v29 ^ HIBYTE(v28))];
    unsigned __int16 v31 = crc_16_l_table[(a1[16] ^ v30 ^ HIBYTE(v29))];
    unsigned __int16 v32 = crc_16_l_table[(HIBYTE(a4) ^ v31 ^ HIBYTE(v30))];
    unsigned __int16 v33 = crc_16_l_table[(a5 ^ v32 ^ HIBYTE(v31))];
    unsigned __int16 v34 = crc_16_l_table[(BYTE1(a5) ^ v33 ^ HIBYTE(v32))];
    unsigned __int16 v35 = crc_16_l_table[(BYTE2(a5) ^ v34 ^ HIBYTE(v33))];
    unsigned __int16 v36 = crc_16_l_table[(HIBYTE(a5) ^ v35 ^ HIBYTE(v34))];
    unsigned __int16 v37 = crc_16_l_table[(a6 ^ v36 ^ HIBYTE(v35))];
    unsigned __int16 v38 = crc_16_l_table[(BYTE1(a6) ^ v37 ^ HIBYTE(v36))];
    unsigned __int16 v39 = crc_16_l_table[(BYTE2(a6) ^ v38 ^ HIBYTE(v37))];
    unsigned __int16 v40 = crc_16_l_table[(HIBYTE(a6) ^ v39 ^ HIBYTE(v38))];
    unsigned __int16 v41 = crc_16_l_table[(a7 ^ v40 ^ HIBYTE(v39))];
    unsigned __int16 v42 = crc_16_l_table[(BYTE1(a7) ^ v41 ^ HIBYTE(v40))];
    unsigned __int16 v43 = crc_16_l_table[(BYTE2(a7) ^ v42 ^ HIBYTE(v41))];
    unsigned __int16 v44 = crc_16_l_table[(HIBYTE(a7) ^ v43 ^ HIBYTE(v42))];
    unsigned __int16 v45 = crc_16_l_table[(a8 ^ v44 ^ HIBYTE(v43))];
    unsigned __int16 v46 = crc_16_l_table[(a9 ^ v45 ^ HIBYTE(v44))];
    unsigned __int16 v47 = crc_16_l_table[(a10 ^ v46 ^ HIBYTE(v45))];
    unsigned __int16 v48 = crc_16_l_table[(a11 ^ v47 ^ HIBYTE(v46))];
    unsigned int v49 = crc_16_l_table[(a12 ^ v48 ^ HIBYTE(v47))];
    *((_WORD *)a1 + 18) = crc_16_l_table[(v49 ^ HIBYTE(v48) ^ a13)] ^ ~(unsigned __int16)(v49 >> 8);
    if (a2 >= 76)
    {
      bzero(__src, 0x800uLL);
      uint64_t v50 = 0;
      LODWORD(v51) = 0;
      do
      {
        while (1)
        {
          int v53 = a1[v50];
          if ((v53 - 125) > 1) {
            break;
          }
          int v52 = v51 + 1;
          __src[(int)v51] = 125;
          __src[(int)v51 + 1] = v53 ^ 0x20;
          size_t v51 = (int)v51 + 1 + 1;
          if (++v50 == 38) {
            goto LABEL_9;
          }
        }
        int v52 = v51;
        __src[(int)v51] = v53;
        size_t v51 = (int)v51 + 1;
        ++v50;
      }
      while (v50 != 38);
LABEL_9:
      memcpy(a1, __src, v51);
      uint64_t result = (v52 + 2);
      a1[v51] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_REV_A_CONF_MAC_FOR_FWD_CC_MAC_FTC(unsigned __int8 *a1, int a2, int a3, int a4)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x1B)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 124;
    a1[10] = a3;
    a1[11] = a4;
    uint64_t v9 = a1[6];
    unsigned __int16 v10 = crc_16_l_table[v9 ^ 0xD4];
    unsigned __int16 v11 = crc_16_l_table[a1[7] ^ 0xDC ^ v10];
    unsigned __int16 v12 = crc_16_l_table[(a1[8] ^ v11 ^ HIBYTE(v10))];
    unsigned __int16 v13 = crc_16_l_table[(a1[9] ^ v12 ^ HIBYTE(v11))];
    unsigned int v14 = crc_16_l_table[(a3 ^ v13 ^ HIBYTE(v12))];
    int v15 = crc_16_l_table[(v14 ^ HIBYTE(v13)) ^ a4];
    int v16 = v15 ^ ~(v14 >> 8);
    *((_WORD *)a1 + 6) = v15 ^ ~HIBYTE(crc_16_l_table[(a3 ^ v13 ^ HIBYTE(v12))]);
    if (a2 >= 28)
    {
      bzero(v32, 0x7FAuLL);
      int __src = 527179;
      __int16 v31 = 124;
      if ((v9 - 125) > 1)
      {
        unsigned int v17 = 6;
      }
      else
      {
        v32[0] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        unsigned int v17 = 7;
      }
      *((unsigned char *)&__src + v17) = v9;
      uint64_t v18 = v17 + 1;
      int v19 = a1[7];
      if ((v19 - 125) <= 1)
      {
        *((unsigned char *)&__src + v18) = 125;
        LODWORD(v18) = v17 + 2;
        LOBYTE(v19) = v19 ^ 0x20;
      }
      *((unsigned char *)&__src + v18) = v19;
      uint64_t v20 = v18 + 1;
      int v21 = a1[8];
      if ((v21 - 125) <= 1)
      {
        *((unsigned char *)&__src + v20) = 125;
        LOBYTE(v21) = v21 ^ 0x20;
        LODWORD(v20) = v18 + 2;
      }
      *((unsigned char *)&__src + v20) = v21;
      uint64_t v22 = v20 + 1;
      int v23 = a1[9];
      if ((v23 - 125) <= 1)
      {
        *((unsigned char *)&__src + v22) = 125;
        LODWORD(v22) = v20 + 2;
        LOBYTE(v23) = v23 ^ 0x20;
      }
      *((unsigned char *)&__src + v22) = v23;
      uint64_t v24 = v22 + 1;
      if ((a3 - 125) <= 1)
      {
        *((unsigned char *)&__src + v24) = 125;
        LOBYTE(a3) = a3 ^ 0x20;
        LODWORD(v24) = v22 + 2;
      }
      int v25 = ~(v15 ^ BYTE1(v14));
      *((unsigned char *)&__src + v24) = a3;
      uint64_t v26 = v24 + 1;
      if ((a4 - 125) <= 1)
      {
        *((unsigned char *)&__src + v26) = 125;
        LOBYTE(a4) = a4 ^ 0x20;
        LODWORD(v26) = v24 + 2;
      }
      char v27 = (unsigned __int16)(v15 ^ ~(unsigned __int16)(v14 >> 8)) >> 8;
      *((unsigned char *)&__src + v26) = a4;
      uint64_t v28 = v26 + 1;
      if ((v25 - 125) <= 1)
      {
        *((unsigned char *)&__src + v28) = 125;
        LODWORD(v28) = v26 + 2;
        LOBYTE(v25) = v25 ^ 0x20;
      }
      *((unsigned char *)&__src + v28) = v25;
      uint64_t v29 = v28 + 1;
      if (BYTE1(v16) - 125 <= 1)
      {
        *((unsigned char *)&__src + v29) = 125;
        char v27 = BYTE1(v16) ^ 0x20;
        LODWORD(v29) = v28 + 2;
      }
      *((unsigned char *)&__src + v29) = v27;
      memcpy(a1, &__src, v29 + 1);
      uint64_t result = (v29 + 2);
      a1[v29 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_REV_A_MOD_ACC(char *a1, int a2, int a3, int a4, int a5, int a6, int a7, char a8, char a9, char a10, char a11, char a12, char a13, char a14, char a15, char a16, char a17, char a18)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x35)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 125;
    *(_DWORD *)(a1 + 10) = a3;
    *(_DWORD *)(a1 + 14) = a4;
    *(_DWORD *)(a1 + 18) = a5;
    *(_DWORD *)(a1 + 22) = a6;
    *(_DWORD *)(a1 + 26) = a7;
    a1[30] = a8;
    a1[31] = a9;
    a1[32] = a10;
    a1[33] = a11;
    a1[34] = a12;
    a1[35] = a13;
    a1[36] = a14;
    a1[37] = a15;
    a1[38] = a16;
    a1[39] = a17;
    a1[40] = a18;
    unsigned __int16 v26 = crc_16_l_table[~*a1];
    unsigned __int16 v27 = crc_16_l_table[(a1[1] ^ ~(_BYTE)v26)];
    unsigned __int16 v28 = crc_16_l_table[(a1[2] ^ v27 ^ HIBYTE(v26))];
    unsigned __int16 v29 = crc_16_l_table[(a1[3] ^ v28 ^ HIBYTE(v27))];
    unsigned __int16 v30 = crc_16_l_table[(a1[4] ^ v29 ^ HIBYTE(v28))];
    unsigned __int16 v31 = crc_16_l_table[(a1[5] ^ v30 ^ HIBYTE(v29))];
    unsigned __int16 v32 = crc_16_l_table[(a1[6] ^ v31 ^ HIBYTE(v30))];
    unsigned __int16 v33 = crc_16_l_table[(a1[7] ^ v32 ^ HIBYTE(v31))];
    unsigned __int16 v34 = crc_16_l_table[(a1[8] ^ v33 ^ HIBYTE(v32))];
    unsigned __int16 v35 = crc_16_l_table[(a1[9] ^ v34 ^ HIBYTE(v33))];
    unsigned __int16 v36 = crc_16_l_table[(a1[10] ^ v35 ^ HIBYTE(v34))];
    unsigned __int16 v37 = crc_16_l_table[(a1[11] ^ v36 ^ HIBYTE(v35))];
    unsigned __int16 v38 = crc_16_l_table[(a1[12] ^ v37 ^ HIBYTE(v36))];
    unsigned __int16 v39 = crc_16_l_table[(a1[13] ^ v38 ^ HIBYTE(v37))];
    unsigned __int16 v40 = crc_16_l_table[(a1[14] ^ v39 ^ HIBYTE(v38))];
    unsigned __int16 v41 = crc_16_l_table[(a1[15] ^ v40 ^ HIBYTE(v39))];
    unsigned __int16 v42 = crc_16_l_table[(a1[16] ^ v41 ^ HIBYTE(v40))];
    unsigned __int16 v43 = crc_16_l_table[(a1[17] ^ v42 ^ HIBYTE(v41))];
    unsigned __int16 v44 = crc_16_l_table[(a1[18] ^ v43 ^ HIBYTE(v42))];
    unsigned __int16 v45 = crc_16_l_table[(a1[19] ^ v44 ^ HIBYTE(v43))];
    unsigned __int16 v46 = crc_16_l_table[(a1[20] ^ v45 ^ HIBYTE(v44))];
    unsigned __int16 v47 = crc_16_l_table[(a1[21] ^ v46 ^ HIBYTE(v45))];
    unsigned __int16 v48 = crc_16_l_table[(a6 ^ v47 ^ HIBYTE(v46))];
    unsigned __int16 v49 = crc_16_l_table[(BYTE1(a6) ^ v48 ^ HIBYTE(v47))];
    unsigned __int16 v50 = crc_16_l_table[(BYTE2(a6) ^ v49 ^ HIBYTE(v48))];
    unsigned __int16 v51 = crc_16_l_table[(HIBYTE(a6) ^ v50 ^ HIBYTE(v49))];
    unsigned __int16 v52 = crc_16_l_table[(a7 ^ v51 ^ HIBYTE(v50))];
    unsigned __int16 v53 = crc_16_l_table[(BYTE1(a7) ^ v52 ^ HIBYTE(v51))];
    unsigned __int16 v54 = crc_16_l_table[(BYTE2(a7) ^ v53 ^ HIBYTE(v52))];
    unsigned __int16 v55 = crc_16_l_table[(HIBYTE(a7) ^ v54 ^ HIBYTE(v53))];
    unsigned __int16 v56 = crc_16_l_table[(a8 ^ v55 ^ HIBYTE(v54))];
    unsigned __int16 v57 = crc_16_l_table[(a9 ^ v56 ^ HIBYTE(v55))];
    unsigned __int16 v58 = crc_16_l_table[(a10 ^ v57 ^ HIBYTE(v56))];
    unsigned __int16 v59 = crc_16_l_table[(a11 ^ v58 ^ HIBYTE(v57))];
    unsigned __int16 v60 = crc_16_l_table[(a12 ^ v59 ^ HIBYTE(v58))];
    unsigned __int16 v61 = crc_16_l_table[(a13 ^ v60 ^ HIBYTE(v59))];
    unsigned __int16 v62 = crc_16_l_table[(a14 ^ v61 ^ HIBYTE(v60))];
    unsigned __int16 v63 = crc_16_l_table[(a15 ^ v62 ^ HIBYTE(v61))];
    unsigned __int16 v64 = crc_16_l_table[(a16 ^ v63 ^ HIBYTE(v62))];
    unsigned int v65 = crc_16_l_table[(a17 ^ v64 ^ HIBYTE(v63))];
    *(_WORD *)(a1 + 41) = crc_16_l_table[(v65 ^ HIBYTE(v64) ^ a18)] ^ ~(unsigned __int16)(v65 >> 8);
    if (a2 >= 86)
    {
      bzero(__src, 0x800uLL);
      uint64_t v66 = 0;
      LODWORD(v67) = 0;
      do
      {
        while (1)
        {
          int v69 = a1[v66];
          if ((v69 - 125) > 1) {
            break;
          }
          int v68 = v67 + 1;
          __src[(int)v67] = 125;
          __src[(int)v67 + 1] = v69 ^ 0x20;
          size_t v67 = (int)v67 + 1 + 1;
          if (++v66 == 43) {
            goto LABEL_9;
          }
        }
        int v68 = v67;
        __src[(int)v67] = v69;
        size_t v67 = (int)v67 + 1;
        ++v66;
      }
      while (v66 != 43);
LABEL_9:
      memcpy(a1, __src, v67);
      uint64_t result = (v68 + 2);
      a1[v67] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_REV_A_DEMOD_FWD_WITH_NO_REV(unsigned __int8 *a1, int a2, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, char a9, char a10, char a11)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x35)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 127;
    a1[10] = a3;
    a1[11] = a4;
    a1[12] = a5;
    a1[13] = a6;
    a1[14] = a7;
    a1[15] = a8;
    a1[16] = a9;
    a1[17] = a10;
    a1[18] = a11;
    unsigned __int16 v20 = crc_16_l_table[a1[6] ^ 0xBCLL];
    unsigned __int16 v21 = crc_16_l_table[a1[7] ^ 0xF6 ^ v20];
    unsigned __int16 v22 = crc_16_l_table[(a1[8] ^ v21 ^ HIBYTE(v20))];
    unsigned __int16 v23 = crc_16_l_table[(a1[9] ^ v22 ^ HIBYTE(v21))];
    unsigned __int16 v24 = crc_16_l_table[(a3 ^ v23 ^ HIBYTE(v22))];
    unsigned __int16 v25 = crc_16_l_table[(a4 ^ v24 ^ HIBYTE(v23))];
    unsigned __int16 v26 = crc_16_l_table[(a5 ^ v25 ^ HIBYTE(v24))];
    unsigned __int16 v27 = crc_16_l_table[(a6 ^ v26 ^ HIBYTE(v25))];
    unsigned __int16 v28 = crc_16_l_table[(a7 ^ v27 ^ HIBYTE(v26))];
    unsigned __int16 v29 = crc_16_l_table[(a8 ^ v28 ^ HIBYTE(v27))];
    unsigned __int16 v30 = crc_16_l_table[(a9 ^ v29 ^ HIBYTE(v28))];
    uint64_t v31 = (a10 ^ v30 ^ HIBYTE(v29));
    unsigned int v32 = crc_16_l_table[v31];
    unsigned __int16 v33 = crc_16_l_table[(v32 ^ HIBYTE(v30) ^ a11)];
    *(_WORD *)(a1 + 19) = v33 ^ ~HIBYTE(crc_16_l_table[v31]);
    if (a2 >= 42)
    {
      bzero(__src, 0x800uLL);
      int v34 = *a1;
      if ((v34 - 125) > 1)
      {
        unsigned int v35 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v34) = v34 ^ 0x20;
        unsigned int v35 = 1;
      }
      __src[v35] = v34;
      uint64_t v36 = v35 + 1;
      int v37 = a1[1];
      if ((v37 - 125) <= 1)
      {
        __src[v36] = 125;
        LODWORD(v36) = v35 | 2;
        LOBYTE(v37) = v37 ^ 0x20;
      }
      __src[v36] = v37;
      uint64_t v38 = v36 + 1;
      int v39 = a1[2];
      if ((v39 - 125) <= 1)
      {
        __src[v38] = 125;
        LOBYTE(v39) = v39 ^ 0x20;
        LODWORD(v38) = v36 + 2;
      }
      __src[v38] = v39;
      uint64_t v40 = v38 + 1;
      int v41 = a1[3];
      if ((v41 - 125) <= 1)
      {
        __src[v40] = 125;
        LODWORD(v40) = v38 + 2;
        LOBYTE(v41) = v41 ^ 0x20;
      }
      __src[v40] = v41;
      uint64_t v42 = v40 + 1;
      int v43 = a1[4];
      if ((v43 - 125) <= 1)
      {
        __src[v42] = 125;
        LOBYTE(v43) = v43 ^ 0x20;
        LODWORD(v42) = v40 + 2;
      }
      __src[v42] = v43;
      uint64_t v44 = v42 + 1;
      int v45 = a1[5];
      if ((v45 - 125) <= 1)
      {
        __src[v44] = 125;
        LODWORD(v44) = v42 + 2;
        LOBYTE(v45) = v45 ^ 0x20;
      }
      __src[v44] = v45;
      uint64_t v46 = v44 + 1;
      int v47 = a1[6];
      if ((v47 - 125) <= 1)
      {
        __src[v46] = 125;
        LOBYTE(v47) = v47 ^ 0x20;
        LODWORD(v46) = v44 + 2;
      }
      __src[v46] = v47;
      uint64_t v48 = v46 + 1;
      int v49 = a1[7];
      if ((v49 - 125) <= 1)
      {
        __src[v48] = 125;
        LODWORD(v48) = v46 + 2;
        LOBYTE(v49) = v49 ^ 0x20;
      }
      __src[v48] = v49;
      uint64_t v50 = v48 + 1;
      int v51 = a1[8];
      if ((v51 - 125) <= 1)
      {
        __src[v50] = 125;
        LOBYTE(v51) = v51 ^ 0x20;
        LODWORD(v50) = v48 + 2;
      }
      __src[v50] = v51;
      uint64_t v52 = v50 + 1;
      int v53 = a1[9];
      if ((v53 - 125) <= 1)
      {
        __src[v52] = 125;
        LODWORD(v52) = v50 + 2;
        LOBYTE(v53) = v53 ^ 0x20;
      }
      __src[v52] = v53;
      uint64_t v54 = v52 + 1;
      int v55 = a1[10];
      if ((v55 - 125) <= 1)
      {
        __src[v54] = 125;
        LOBYTE(v55) = v55 ^ 0x20;
        LODWORD(v54) = v52 + 2;
      }
      __src[v54] = v55;
      uint64_t v56 = v54 + 1;
      int v57 = a1[11];
      if ((v57 - 125) <= 1)
      {
        __src[v56] = 125;
        LODWORD(v56) = v54 + 2;
        LOBYTE(v57) = v57 ^ 0x20;
      }
      __src[v56] = v57;
      uint64_t v58 = v56 + 1;
      int v59 = a1[12];
      if ((v59 - 125) <= 1)
      {
        __src[v58] = 125;
        LOBYTE(v59) = v59 ^ 0x20;
        LODWORD(v58) = v56 + 2;
      }
      __src[v58] = v59;
      uint64_t v60 = v58 + 1;
      int v61 = a1[13];
      if ((v61 - 125) <= 1)
      {
        __src[v60] = 125;
        LODWORD(v60) = v58 + 2;
        LOBYTE(v61) = v61 ^ 0x20;
      }
      __src[v60] = v61;
      uint64_t v62 = v60 + 1;
      int v63 = a1[14];
      if ((v63 - 125) <= 1)
      {
        __src[v62] = 125;
        LOBYTE(v63) = v63 ^ 0x20;
        LODWORD(v62) = v60 + 2;
      }
      __src[v62] = v63;
      uint64_t v64 = v62 + 1;
      int v65 = a1[15];
      if ((v65 - 125) <= 1)
      {
        __src[v64] = 125;
        LODWORD(v64) = v62 + 2;
        LOBYTE(v65) = v65 ^ 0x20;
      }
      __src[v64] = v65;
      uint64_t v66 = v64 + 1;
      int v67 = a1[16];
      if ((v67 - 125) <= 1)
      {
        __src[v66] = 125;
        LODWORD(v66) = v64 + 2;
        LOBYTE(v67) = v67 ^ 0x20;
      }
      __src[v66] = v67;
      uint64_t v68 = v66 + 1;
      int v69 = a1[17];
      if ((v69 - 125) <= 1)
      {
        __src[v68] = 125;
        LOBYTE(v69) = v69 ^ 0x20;
        LODWORD(v68) = v66 + 2;
      }
      int v70 = ~(v33 ^ BYTE1(v32));
      __src[v68] = v69;
      uint64_t v71 = v68 + 1;
      int v72 = a1[18];
      if ((v72 - 125) <= 1)
      {
        __src[v71] = 125;
        LOBYTE(v72) = v72 ^ 0x20;
        LODWORD(v71) = v68 + 2;
      }
      int v73 = ((unsigned __int16)(v33 ^ ~(unsigned __int16)(v32 >> 8)) >> 8);
      __src[v71] = v72;
      uint64_t v74 = v71 + 1;
      if ((v70 - 125) <= 1)
      {
        __src[v74] = 125;
        LOBYTE(v70) = v70 ^ 0x20;
        LODWORD(v74) = v71 + 2;
      }
      __src[v74] = v70;
      uint64_t v75 = v74 + 1;
      if ((v73 - 125) <= 1)
      {
        __src[v75] = 125;
        LOBYTE(v73) = v73 ^ 0x20;
        LODWORD(v75) = v74 + 2;
      }
      __src[v75] = v73;
      memcpy(a1, __src, v75 + 1);
      uint64_t result = (v75 + 2);
      a1[v75 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_DEMOD_FWD_WITH_NO_REV(unsigned __int8 *a1, int a2, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, char a9, char a10)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x35)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 122;
    a1[10] = a3;
    a1[11] = a4;
    a1[12] = a5;
    a1[13] = a6;
    a1[14] = a7;
    a1[15] = a8;
    a1[16] = a9;
    a1[17] = a10;
    unsigned __int16 v19 = crc_16_l_table[a1[6] ^ 4];
    unsigned __int16 v20 = crc_16_l_table[(a1[7] ^ v19) ^ 0x88];
    unsigned __int16 v21 = crc_16_l_table[(a1[8] ^ v20 ^ HIBYTE(v19))];
    unsigned __int16 v22 = crc_16_l_table[(a1[9] ^ v21 ^ HIBYTE(v20))];
    unsigned __int16 v23 = crc_16_l_table[(a3 ^ v22 ^ HIBYTE(v21))];
    unsigned __int16 v24 = crc_16_l_table[(a4 ^ v23 ^ HIBYTE(v22))];
    unsigned __int16 v25 = crc_16_l_table[(a5 ^ v24 ^ HIBYTE(v23))];
    unsigned __int16 v26 = crc_16_l_table[(a6 ^ v25 ^ HIBYTE(v24))];
    unsigned __int16 v27 = crc_16_l_table[(a7 ^ v26 ^ HIBYTE(v25))];
    unsigned __int16 v28 = crc_16_l_table[(a8 ^ v27 ^ HIBYTE(v26))];
    unsigned int v29 = crc_16_l_table[(a9 ^ v28 ^ HIBYTE(v27))];
    unsigned __int16 v30 = crc_16_l_table[(v29 ^ HIBYTE(v28) ^ a10)];
    *((_WORD *)a1 + 9) = v30 ^ ~HIBYTE(crc_16_l_table[(a9 ^ v28 ^ HIBYTE(v27))]);
    if (a2 >= 40)
    {
      bzero(v71, 0x800uLL);
      int v31 = *a1;
      if ((v31 - 125) > 1)
      {
        unsigned int v32 = 0;
      }
      else
      {
        v71[0] = 125;
        LOBYTE(v31) = v31 ^ 0x20;
        unsigned int v32 = 1;
      }
      v71[v32] = v31;
      uint64_t v33 = v32 + 1;
      int v34 = a1[1];
      if ((v34 - 125) <= 1)
      {
        v71[v33] = 125;
        LODWORD(v33) = v32 | 2;
        LOBYTE(v34) = v34 ^ 0x20;
      }
      v71[v33] = v34;
      uint64_t v35 = v33 + 1;
      int v36 = a1[2];
      if ((v36 - 125) <= 1)
      {
        v71[v35] = 125;
        LOBYTE(v36) = v36 ^ 0x20;
        LODWORD(v35) = v33 + 2;
      }
      v71[v35] = v36;
      uint64_t v37 = v35 + 1;
      int v38 = a1[3];
      if ((v38 - 125) <= 1)
      {
        v71[v37] = 125;
        LODWORD(v37) = v35 + 2;
        LOBYTE(v38) = v38 ^ 0x20;
      }
      v71[v37] = v38;
      uint64_t v39 = v37 + 1;
      int v40 = a1[4];
      if ((v40 - 125) <= 1)
      {
        v71[v39] = 125;
        LOBYTE(v40) = v40 ^ 0x20;
        LODWORD(v39) = v37 + 2;
      }
      v71[v39] = v40;
      uint64_t v41 = v39 + 1;
      int v42 = a1[5];
      if ((v42 - 125) <= 1)
      {
        v71[v41] = 125;
        LODWORD(v41) = v39 + 2;
        LOBYTE(v42) = v42 ^ 0x20;
      }
      v71[v41] = v42;
      uint64_t v43 = v41 + 1;
      int v44 = a1[6];
      if ((v44 - 125) <= 1)
      {
        v71[v43] = 125;
        LOBYTE(v44) = v44 ^ 0x20;
        LODWORD(v43) = v41 + 2;
      }
      v71[v43] = v44;
      uint64_t v45 = v43 + 1;
      int v46 = a1[7];
      if ((v46 - 125) <= 1)
      {
        v71[v45] = 125;
        LODWORD(v45) = v43 + 2;
        LOBYTE(v46) = v46 ^ 0x20;
      }
      v71[v45] = v46;
      uint64_t v47 = v45 + 1;
      int v48 = a1[8];
      if ((v48 - 125) <= 1)
      {
        v71[v47] = 125;
        LOBYTE(v48) = v48 ^ 0x20;
        LODWORD(v47) = v45 + 2;
      }
      v71[v47] = v48;
      uint64_t v49 = v47 + 1;
      int v50 = a1[9];
      if ((v50 - 125) <= 1)
      {
        v71[v49] = 125;
        LODWORD(v49) = v47 + 2;
        LOBYTE(v50) = v50 ^ 0x20;
      }
      v71[v49] = v50;
      uint64_t v51 = v49 + 1;
      int v52 = a1[10];
      if ((v52 - 125) <= 1)
      {
        v71[v51] = 125;
        LOBYTE(v52) = v52 ^ 0x20;
        LODWORD(v51) = v49 + 2;
      }
      v71[v51] = v52;
      uint64_t v53 = v51 + 1;
      int v54 = a1[11];
      if ((v54 - 125) <= 1)
      {
        v71[v53] = 125;
        LODWORD(v53) = v51 + 2;
        LOBYTE(v54) = v54 ^ 0x20;
      }
      v71[v53] = v54;
      uint64_t v55 = v53 + 1;
      int v56 = a1[12];
      if ((v56 - 125) <= 1)
      {
        v71[v55] = 125;
        LOBYTE(v56) = v56 ^ 0x20;
        LODWORD(v55) = v53 + 2;
      }
      v71[v55] = v56;
      uint64_t v57 = v55 + 1;
      int v58 = a1[13];
      if ((v58 - 125) <= 1)
      {
        v71[v57] = 125;
        LODWORD(v57) = v55 + 2;
        LOBYTE(v58) = v58 ^ 0x20;
      }
      v71[v57] = v58;
      uint64_t v59 = v57 + 1;
      int v60 = a1[14];
      if ((v60 - 125) <= 1)
      {
        v71[v59] = 125;
        LOBYTE(v60) = v60 ^ 0x20;
        LODWORD(v59) = v57 + 2;
      }
      v71[v59] = v60;
      uint64_t v61 = v59 + 1;
      int v62 = a1[15];
      if ((v62 - 125) <= 1)
      {
        v71[v61] = 125;
        LODWORD(v61) = v59 + 2;
        LOBYTE(v62) = v62 ^ 0x20;
      }
      v71[v61] = v62;
      uint64_t v63 = v61 + 1;
      int v64 = a1[16];
      if ((v64 - 125) <= 1)
      {
        v71[v63] = 125;
        LOBYTE(v64) = v64 ^ 0x20;
        LODWORD(v63) = v61 + 2;
      }
      int v65 = ~(v30 ^ BYTE1(v29));
      v71[v63] = v64;
      uint64_t v66 = v63 + 1;
      int v67 = a1[17];
      if ((v67 - 125) <= 1)
      {
        v71[v66] = 125;
        LOBYTE(v67) = v67 ^ 0x20;
        LODWORD(v66) = v63 + 2;
      }
      int v68 = ((unsigned __int16)(v30 ^ ~(unsigned __int16)(v29 >> 8)) >> 8);
      v71[v66] = v67;
      uint64_t v69 = v66 + 1;
      if ((v65 - 125) <= 1)
      {
        v71[v69] = 125;
        LOBYTE(v65) = v65 ^ 0x20;
        LODWORD(v69) = v66 + 2;
      }
      v71[v69] = v65;
      uint64_t v70 = v69 + 1;
      if ((v68 - 125) <= 1)
      {
        v71[v70] = 125;
        LOBYTE(v68) = v68 ^ 0x20;
        LODWORD(v70) = v69 + 2;
      }
      v71[v70] = v68;
      memcpy(a1, v71, v70 + 1);
      uint64_t result = (v70 + 2);
      a1[v70 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_REV_A_MOD_TRA(char *a1, int a2, char a3, char a4, char a5, char a6, char a7, char a8, char a9, char a10, char a11, char a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,char a21,char a22,char a23,char a24,char a25,char a26,char a27,char a28,char a29,char a30)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x3D)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 126;
    a1[6] = 42;
    a1[10] = a3;
    a1[11] = a4;
    a1[12] = a5;
    a1[13] = a6;
    a1[14] = a7;
    a1[15] = a8;
    a1[16] = a9;
    a1[17] = a10;
    a1[18] = a11;
    a1[19] = a12;
    a1[20] = a13;
    a1[21] = a14;
    *(_DWORD *)(a1 + 22) = a15;
    *(_DWORD *)(a1 + 26) = a16;
    *(_DWORD *)(a1 + 30) = a17;
    *(_DWORD *)(a1 + 34) = a18;
    *(_DWORD *)(a1 + 38) = a19;
    a1[42] = a20;
    a1[43] = a21;
    a1[44] = a22;
    a1[45] = a23;
    a1[46] = a24;
    a1[47] = a25;
    a1[48] = a26;
    a1[49] = a27;
    a1[50] = a28;
    a1[51] = a29;
    int v38 = 424;
    a1[52] = a30;
    LOWORD(v39) = -1;
    int v40 = a1;
    do
    {
      char v41 = *v40++;
      int v39 = crc_16_l_table[(v41 ^ v39)] ^ ((unsigned __int16)(v39 & 0xFF00) >> 8);
      v38 -= 8;
    }
    while ((_WORD)v38);
    *(_WORD *)(a1 + 53) = ~(_WORD)v39;
    if (a2 >= 110)
    {
      bzero(__src, 0x800uLL);
      uint64_t v42 = 0;
      LODWORD(v43) = 0;
      do
      {
        while (1)
        {
          int v45 = a1[v42];
          if ((v45 - 125) > 1) {
            break;
          }
          int v44 = v43 + 1;
          __src[(int)v43] = 125;
          __src[(int)v43 + 1] = v45 ^ 0x20;
          size_t v43 = (int)v43 + 1 + 1;
          if (++v42 == 55) {
            goto LABEL_11;
          }
        }
        int v44 = v43;
        __src[(int)v43] = v45;
        size_t v43 = (int)v43 + 1;
        ++v42;
      }
      while (v42 != 55);
LABEL_11:
      memcpy(a1, __src, v43);
      uint64_t result = (v44 + 2);
      a1[v43] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_MOD_REVERSE_TRA(char *a1, int a2, char a3, char a4, char a5, char a6, char a7, char a8, char a9, char a10, char a11, char a12, char a13, char a14, char a15, char a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,char a25)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x3B)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    *((_WORD *)a1 + 2) = 117;
    a1[6] = 47;
    a1[10] = a3;
    a1[11] = a4;
    a1[12] = a5;
    a1[13] = a6;
    a1[14] = a7;
    a1[15] = a8;
    a1[16] = a9;
    a1[17] = a10;
    a1[18] = a11;
    a1[19] = a12;
    a1[20] = a13;
    a1[21] = a14;
    a1[22] = a15;
    a1[23] = a16;
    a1[24] = a17;
    a1[25] = a18;
    *(_DWORD *)(a1 + 26) = a19;
    *(_DWORD *)(a1 + 30) = a20;
    *(_DWORD *)(a1 + 34) = a21;
    *(_DWORD *)(a1 + 38) = a22;
    *(_DWORD *)(a1 + 42) = a23;
    a1[46] = a24;
    int v33 = 384;
    a1[47] = a25;
    LOWORD(v34) = -1;
    uint64_t v35 = a1;
    do
    {
      char v36 = *v35++;
      int v34 = crc_16_l_table[(v36 ^ v34)] ^ ((unsigned __int16)(v34 & 0xFF00) >> 8);
      v33 -= 8;
    }
    while ((_WORD)v33);
    *((_WORD *)a1 + 24) = ~(_WORD)v34;
    if (a2 >= 100)
    {
      bzero(__src, 0x800uLL);
      uint64_t v37 = 0;
      LODWORD(v38) = 0;
      do
      {
        while (1)
        {
          int v40 = a1[v37];
          if ((v40 - 125) > 1) {
            break;
          }
          int v39 = v38 + 1;
          __src[(int)v38] = 125;
          __src[(int)v38 + 1] = v40 ^ 0x20;
          size_t v38 = (int)v38 + 1 + 1;
          if (++v37 == 50) {
            goto LABEL_11;
          }
        }
        int v39 = v38;
        __src[(int)v38] = v40;
        size_t v38 = (int)v38 + 1;
        ++v37;
      }
      while (v37 != 50);
LABEL_11:
      memcpy(a1, __src, v38);
      uint64_t result = (v39 + 2);
      a1[v38] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_EVDO_CMD_RELEASE(unsigned __int8 *a1, int a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x33)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 527179;
    a1[4] = 118;
    a1[6] = 10;
    uint64_t v5 = a1[5];
    unsigned __int16 v6 = crc_16_l_table[crc_16_l_table[v5 ^ 0x20] ^ 0xAC];
    unsigned __int16 v7 = crc_16_l_table[(a1[7] ^ v6 ^ HIBYTE(crc_16_l_table[v5 ^ 0x20]))];
    unsigned int v8 = crc_16_l_table[(a1[8] ^ v7 ^ HIBYTE(v6))];
    unsigned __int16 v9 = crc_16_l_table[(a1[9] ^ v8 ^ HIBYTE(v7))];
    *((_WORD *)a1 + 5) = v9 ^ ~HIBYTE(crc_16_l_table[(a1[8] ^ v7 ^ HIBYTE(v6))]);
    if (a2 >= 24)
    {
      bzero(v24, 0x7FBuLL);
      int __src = 527179;
      char v23 = 118;
      if ((v5 - 125) > 1)
      {
        unsigned int v10 = 5;
      }
      else
      {
        v24[0] = 125;
        unsigned int v10 = 6;
        LOBYTE(v5) = v5 ^ 0x20;
      }
      unsigned __int16 v11 = (char *)&__src + v10;
      *unsigned __int16 v11 = v5;
      v11[1] = 10;
      uint64_t v12 = v10 + 2;
      int v13 = a1[7];
      if ((v13 - 125) <= 1)
      {
        *((unsigned char *)&__src + v12) = 125;
        LODWORD(v12) = v10 + 3;
        LOBYTE(v13) = v13 ^ 0x20;
      }
      *((unsigned char *)&__src + v12) = v13;
      uint64_t v14 = v12 + 1;
      int v15 = a1[8];
      if ((v15 - 125) <= 1)
      {
        *((unsigned char *)&__src + v14) = 125;
        LOBYTE(v15) = v15 ^ 0x20;
        LODWORD(v14) = v12 + 2;
      }
      int v16 = ~(v9 ^ BYTE1(v8));
      *((unsigned char *)&__src + v14) = v15;
      uint64_t v17 = v14 + 1;
      int v18 = a1[9];
      if ((v18 - 125) <= 1)
      {
        *((unsigned char *)&__src + v17) = 125;
        LOBYTE(v18) = v18 ^ 0x20;
        LODWORD(v17) = v14 + 2;
      }
      int v19 = ((unsigned __int16)(v9 ^ ~(unsigned __int16)(v8 >> 8)) >> 8);
      *((unsigned char *)&__src + v17) = v18;
      uint64_t v20 = v17 + 1;
      if ((v16 - 125) <= 1)
      {
        *((unsigned char *)&__src + v20) = 125;
        LOBYTE(v16) = v16 ^ 0x20;
        LODWORD(v20) = v17 + 2;
      }
      *((unsigned char *)&__src + v20) = v16;
      uint64_t v21 = v20 + 1;
      if ((v19 - 125) <= 1)
      {
        *((unsigned char *)&__src + v21) = 125;
        LOBYTE(v19) = v19 ^ 0x20;
        LODWORD(v21) = v20 + 2;
      }
      *((unsigned char *)&__src + v21) = v19;
      memcpy(a1, &__src, v21 + 1);
      uint64_t result = (v21 + 2);
      a1[v21 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_SetPA_DCDC_Levels(unsigned __int8 *a1, int a2, __int16 a3, __int16 a4)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x11)
  {
    bzero(a1, a2);
    *(_WORD *)a1 = 2891;
    int v9 = gModeId;
    a1[2] = gModeId;
    int v10 = HIBYTE(gModeId);
    a1[3] = HIBYTE(gModeId);
    *((_WORD *)a1 + 2) = 183;
    *((_WORD *)a1 + 3) = a3;
    char v11 = HIBYTE(a3);
    *((_WORD *)a1 + 4) = a4;
    char v12 = HIBYTE(a4);
    int v13 = crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC];
    unsigned __int16 v14 = crc_16_l_table[crc_16_l_table[v13 ^ HIBYTE(crc_16_l_table[v9 ^ 0xA5]) ^ 0xB7] ^ HIBYTE(crc_16_l_table[crc_16_l_table[v9 ^ 0xA5] ^ v10 ^ 0xEC])];
    unsigned __int16 v15 = crc_16_l_table[(v14 ^ HIBYTE(crc_16_l_table[v13 ^ HIBYTE(crc_16_l_table[v9 ^ 0xA5]) ^ 0xB7]) ^ a3)];
    unsigned int v16 = crc_16_l_table[(HIBYTE(a3) ^ v15 ^ HIBYTE(v14))];
    unsigned int v17 = crc_16_l_table[(a4 ^ v16 ^ HIBYTE(v15))];
    int v18 = crc_16_l_table[HIBYTE(a4) ^ crc_16_l_table[(a4 ^ v16 ^ HIBYTE(v15))] ^ (v16 >> 8)];
    *((_WORD *)a1 + 5) = v18 ^ ~HIBYTE(crc_16_l_table[(a4 ^ v16 ^ HIBYTE(v15))]);
    if (a2 >= 24)
    {
      int v36 = v18 ^ ~(v17 >> 8);
      bzero(__src, 0x800uLL);
      int v19 = *a1;
      if ((v19 - 125) > 1)
      {
        unsigned int v20 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v19) = v19 ^ 0x20;
        unsigned int v20 = 1;
      }
      __src[v20] = v19;
      uint64_t v21 = v20 + 1;
      int v22 = a1[1];
      if ((v22 - 125) <= 1)
      {
        __src[v21] = 125;
        LODWORD(v21) = v20 | 2;
        LOBYTE(v22) = v22 ^ 0x20;
      }
      __src[v21] = v22;
      uint64_t v23 = v21 + 1;
      if ((v9 - 125) <= 1)
      {
        __src[v23] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v23) = v21 + 2;
      }
      char v24 = a3;
      __src[v23] = v9;
      uint64_t v25 = v23 + 1;
      if ((v10 - 125) <= 1)
      {
        __src[v25] = 125;
        LODWORD(v25) = v23 + 2;
        LOBYTE(v10) = v10 ^ 0x20;
      }
      unsigned __int16 v26 = &__src[v25];
      unsigned char *v26 = v10;
      *(_WORD *)(v26 + 1) = 183;
      uint64_t v27 = v25 + 3;
      if (a3 - 125 <= 1)
      {
        __src[v27] = 125;
        char v24 = a3 ^ 0x20;
        LODWORD(v27) = v25 + 4;
      }
      char v28 = a4;
      __src[v27] = v24;
      uint64_t v29 = v27 + 1;
      if (HIBYTE(a3) - 125 <= 1)
      {
        __src[v29] = 125;
        LODWORD(v29) = v27 + 2;
        char v11 = HIBYTE(a3) ^ 0x20;
      }
      __src[v29] = v11;
      uint64_t v30 = v29 + 1;
      if (a4 - 125 <= 1)
      {
        __src[v30] = 125;
        char v28 = a4 ^ 0x20;
        LODWORD(v30) = v29 + 2;
      }
      int v31 = ~(v18 ^ BYTE1(v17));
      __src[v30] = v28;
      uint64_t v32 = v30 + 1;
      if (HIBYTE(a4) - 125 <= 1)
      {
        __src[v32] = 125;
        char v12 = HIBYTE(a4) ^ 0x20;
        LODWORD(v32) = v30 + 2;
      }
      char v33 = (unsigned __int16)(v18 ^ ~(unsigned __int16)(v17 >> 8)) >> 8;
      __src[v32] = v12;
      uint64_t v34 = v32 + 1;
      if ((v31 - 125) <= 1)
      {
        __src[v34] = 125;
        LOBYTE(v31) = v31 ^ 0x20;
        LODWORD(v34) = v32 + 2;
      }
      __src[v34] = v31;
      uint64_t v35 = v34 + 1;
      if (BYTE1(v36) - 125 <= 1)
      {
        __src[v35] = 125;
        char v33 = BYTE1(v36) ^ 0x20;
        LODWORD(v35) = v34 + 2;
      }
      __src[v35] = v33;
      memcpy(a1, __src, v35 + 1);
      uint64_t result = (v35 + 2);
      a1[v35 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_TX_RX_FREQ_CAL_SWEEP(char *a1, int a2, char *a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0x5D2) {
    return result;
  }
  bzero(a1, a2);
  *(void *)a1 = 0xA8008200140B4BLL;
  *((_WORD *)a1 + 4) = 12;
  a1[10] = *a3;
  a1[11] = a3[1];
  a1[12] = a3[2];
  a1[13] = a3[3];
  a1[14] = a3[4];
  a1[15] = a3[5];
  if (a3[2])
  {
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    do
    {
      uint64_t v9 = (uint64_t)&a3[2 * v8 + 6];
      int v10 = &a1[v7];
      v10[16] = *(_WORD *)v9;
      v10[17] = *(unsigned char *)(v9 + 1);
      ++v8;
      v7 += 2;
    }
    while (v8 < a3[2]);
    LODWORD(v11) = v7 + 16;
    if (!a3[3]) {
      goto LABEL_26;
    }
LABEL_9:
    unint64_t v12 = 0;
    uint64_t v11 = v11;
    uint64_t v13 = ((v11 + 2) & 0x1FFFFFFFELL) - 1;
    uint64_t v14 = v11 | 1;
    do
    {
      uint64_t v15 = (uint64_t)&a3[2 * v12 + 38];
      a1[v11] = *(_WORD *)v15;
      a1[v14] = *(unsigned char *)(v15 + 1);
      v11 += 2;
      ++v12;
      v13 += 2;
      v14 += 2;
    }
    while (v12 < a3[3]);
    if (a3[3])
    {
      unint64_t v16 = 0;
      do
      {
        uint64_t v17 = (uint64_t)&a3[2 * v16 + 78];
        a1[v11] = *(_WORD *)v17;
        v11 += 2;
        a1[v13] = *(unsigned char *)(v17 + 1);
        ++v16;
        v13 += 2;
      }
      while (v16 < a3[3]);
      if (a3[3])
      {
        unint64_t v18 = 0;
        int v19 = &a1[v11];
        do
        {
          *v19++ = a3[v18++ + 118];
          LODWORD(v11) = v11 + 1;
        }
        while (v18 < a3[3]);
        if (a3[3])
        {
          unint64_t v20 = 0;
          do
          {
            *v19++ = a3[v20++ + 138];
            LODWORD(v11) = v11 + 1;
          }
          while (v20 < a3[3]);
          if (a3[3])
          {
            unint64_t v21 = 0;
            do
            {
              *v19++ = a3[v21++ + 158];
              LODWORD(v11) = v11 + 1;
            }
            while (v21 < a3[3]);
            if (a3[3])
            {
              unint64_t v22 = 0;
              do
              {
                *v19++ = a3[v22++ + 178];
                LODWORD(v11) = v11 + 1;
              }
              while (v22 < a3[3]);
            }
          }
        }
      }
    }
    goto LABEL_26;
  }
  LODWORD(v11) = 16;
  if (a3[3]) {
    goto LABEL_9;
  }
LABEL_26:
  int v23 = 8 * v11;
  if (((8 * v11) & 0xFFF8) != 0)
  {
    LOWORD(v24) = -1;
    uint64_t v25 = a1;
    do
    {
      char v26 = *v25++;
      int v24 = crc_16_l_table[(v26 ^ v24)] ^ ((unsigned __int16)(v24 & 0xFF00) >> 8);
      v23 -= 8;
    }
    while ((_WORD)v23);
    *(_WORD *)&a1[(int)v11] = ~(_WORD)v24;
    uint64_t result = 0xFFFFFFFFLL;
    if ((int)v11 > 1022) {
      return result;
    }
  }
  else
  {
    uint64_t v27 = &a1[(int)v11];
    char *v27 = 0;
    v27[1] = 0;
    uint64_t result = 0xFFFFFFFFLL;
    if ((int)v11 > 1022) {
      return result;
    }
  }
  uint64_t v28 = (v11 + 2);
  if (2 * (int)v28 <= a2)
  {
    bzero(__src, 0x800uLL);
    if ((int)v11 < -1)
    {
      int v29 = 0;
    }
    else
    {
      int v29 = 0;
      uint64_t v30 = (unsigned __int8 *)a1;
      do
      {
        int v32 = *v30++;
        char v31 = v32;
        if ((v32 - 125) <= 1)
        {
          __src[v29] = 125;
          v31 ^= 0x20u;
          ++v29;
        }
        __src[v29++] = v31;
        --v28;
      }
      while (v28);
    }
    memcpy(a1, __src, v29);
    uint64_t result = (v29 + 1);
    a1[v29] = 126;
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_TX_RX_FREQ_CAL_SWEEP_PARSE(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned __int8 *)(a3 + 2);
  int v4 = *(unsigned __int8 *)(a3 + 3);
  if (*(unsigned char *)(a3 + 2)) {
    _ZF = v4 == 0;
  }
  else {
    _ZF = 1;
  }
  if (!_ZF)
  {
    uint64_t v6 = 0;
    int v7 = 2 * v4;
    if ((2 * v4) <= 2) {
      unsigned int v8 = 2;
    }
    else {
      unsigned int v8 = 2 * v4;
    }
    uint64_t v9 = ((v8 - 1) >> 1) + 1;
    int v10 = 6 * v4 + (v7 + 2) * v3;
    unsigned int v11 = v10 + 22;
    int v12 = 2 * v4;
    unint64_t v13 = (((v8 - 1) >> 1) + 1) & 0xF;
    if (((((v8 - 1) >> 1) + 1) & 0xF) == 0) {
      unint64_t v13 = 16;
    }
    if (((((v8 - 1) >> 1) + 1) & 7) != 0) {
      uint64_t v14 = (((v8 - 1) >> 1) + 1) & 7;
    }
    else {
      uint64_t v14 = 8;
    }
    uint64_t v15 = v9 - v14;
    uint64_t v16 = 2 * (v9 - v14);
    int v17 = v10 + 23;
    unint64_t v18 = ~(((unint64_t)(v8 - 2) + 1) >> 1);
    unint64_t v19 = v18 + v14;
    unint64_t v20 = (int8x16_t *)(a3 + 838);
    unsigned int v21 = v11;
    do
    {
      if (v8 >= 0x11)
      {
        uint64_t v22 = 0;
        uint64_t v24 = a3 + 838 + 40 * v6 - a1;
        if (v24 - (unint64_t)(v11 + v12 * v6) < 0x20)
        {
          uint64_t v23 = 0;
        }
        else
        {
          unint64_t v25 = v24 - ((v11 | 1) + v12 * v6);
          uint64_t v23 = 0;
          if (v25 >= 0x20)
          {
            if (v8 >= 0x21)
            {
              unint64_t v27 = v18 + v13;
              int v28 = v17;
              int v29 = v20;
              uint64_t v30 = (const char *)(a1 + v21);
              do
              {
                char v31 = (const char *)(a1 + v28);
                _Q0 = (unsigned __int128)vld2q_s8(v31);
                unsigned long long v33 = (unsigned __int128)vld2q_s8(v30);
                v30 += 32;
                __asm { SHLL2           V4.8H, V0.16B, #8 }
                int8x16_t *v29 = vorrq_s8((int8x16_t)vshll_n_s8(*(int8x8_t *)&_Q0, 8uLL), (int8x16_t)vmovl_u8(*(uint8x8_t *)&v33));
                v29[1] = vorrq_s8(_Q4, (int8x16_t)vmovl_high_u8((uint8x16_t)v33));
                v29 += 2;
                v28 += 32;
                v27 += 16;
              }
              while (v27);
              uint64_t v26 = v9 - v13;
              uint64_t v22 = 2 * (v9 - v13);
              uint64_t v23 = v9 - v13;
              if (v13 < 9) {
                goto LABEL_27;
              }
            }
            else
            {
              uint64_t v26 = 0;
            }
            uint64_t v38 = 2 * v26;
            uint64_t v39 = v19 + v26;
            int v40 = v17 + 2 * v26;
            do
            {
              char v41 = (const char *)(a1 + v40);
              int8x8_t v42 = (int8x8_t)*(_OWORD *)vld2_s8(v41).val;
              uint64_t v43 = (const char *)(a1 + v21 + v38);
              uint8x8_t v44 = (uint8x8_t)*(_OWORD *)vld2_s8(v43).val;
              *(int8x16_t *)((char *)v20 + v38) = vorrq_s8((int8x16_t)vshll_n_s8(v42, 8uLL), (int8x16_t)vmovl_u8(v44));
              v38 += 16;
              v40 += 16;
              v39 += 8;
            }
            while (v39);
            uint64_t v22 = v16;
            uint64_t v23 = v15;
          }
        }
      }
      else
      {
        uint64_t v22 = 0;
        uint64_t v23 = 0;
      }
LABEL_27:
      int v45 = (unsigned __int8 *)(a1 + v22 + v21);
      int v46 = v17 + v22;
      do
      {
        __int16 v47 = *v45;
        v45 += 2;
        v20->i16[v23] = v47 | (*(unsigned __int8 *)(a1 + v46) << 8);
        v46 += 2;
        ++v23;
      }
      while (v9 != v23);
      ++v6;
      v21 += v7;
      unint64_t v20 = (int8x16_t *)((char *)v20 + 40);
      v17 += v7;
    }
    while (v6 != v3);
  }
  return 0;
}

uint64_t APPLIB_DIAG_Get_TX_Power_Channel(_DWORD *a1, int a2, __int16 a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 9)
  {
    bzero(a1, a2);
    *a1 = 589131;
    int v7 = a3;
    *((_WORD *)a1 + 2) = a3;
    int v8 = HIBYTE(a3);
    unsigned int v9 = crc_16_l_table[a3 ^ 8];
    int v10 = crc_16_l_table[crc_16_l_table[a3 ^ 8] ^ HIBYTE(a3) ^ 0x68];
    int v11 = v10 ^ ~(v9 >> 8);
    *((unsigned char *)a1 + 6) = v10 ^ ~(v9 >> 8);
    int v12 = BYTE1(v11);
    *((unsigned char *)a1 + 7) = BYTE1(v11);
    if (a2 >= 0x10)
    {
      int v13 = v10 ^ (v9 >> 8);
      bzero(v20, 0x7FCuLL);
      int __src = 589131;
      if ((v7 - 125) > 1)
      {
        unsigned int v14 = 4;
      }
      else
      {
        v20[0] = 125;
        LOBYTE(v7) = v7 ^ 0x20;
        unsigned int v14 = 5;
      }
      int v15 = ~(_BYTE)v13;
      v20[v14 - 4] = v7;
      uint64_t v16 = v14 + 1;
      if ((v8 - 125) <= 1)
      {
        v20[v16 - 4] = 125;
        LODWORD(v16) = v14 | 2;
        LOBYTE(v8) = v8 ^ 0x20;
      }
      v20[v16 - 4] = v8;
      uint64_t v17 = v16 + 1;
      if ((v15 - 125) <= 1)
      {
        v20[v17 - 4] = 125;
        LOBYTE(v15) = v15 ^ 0x20;
        LODWORD(v17) = v16 + 2;
      }
      v20[v17 - 4] = v15;
      uint64_t v18 = v17 + 1;
      if ((v12 - 125) <= 1)
      {
        v20[v18 - 4] = 125;
        LOBYTE(v12) = v12 ^ 0x20;
        LODWORD(v18) = v17 + 2;
      }
      v20[v18 - 4] = v12;
      memcpy(a1, &__src, v18 + 1);
      uint64_t result = (v18 + 2);
      *((unsigned char *)a1 + v18 + 1) = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_GetPmicTherm(_DWORD *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 5)
  {
    bzero(a1, a2);
    *a1 = 64843;
    *((_WORD *)a1 + 2) = 22839;
    if (a2 >= 0xC)
    {
      *a1 = 64843;
      *((_WORD *)a1 + 2) = 22839;
      *((unsigned char *)a1 + 6) = 126;
      return 7;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTM_CDMA2000_FTM_SET_REVERSE_LINK_POWER(char *a1, int a2, int a3, int a4)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x1F)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 461643;
    *((_WORD *)a1 + 2) = 140;
    *(_DWORD *)(a1 + 11) = a4;
    a1[10] = a3;
    uint64_t v9 = a1[6];
    unsigned __int16 v10 = crc_16_l_table[v9 ^ 0x25];
    unsigned __int16 v11 = crc_16_l_table[a1[7] ^ 0x12 ^ v10];
    unsigned __int16 v12 = crc_16_l_table[(a1[8] ^ v11 ^ HIBYTE(v10))];
    unsigned __int16 v13 = crc_16_l_table[(a1[9] ^ v12 ^ HIBYTE(v11))];
    unsigned __int16 v14 = crc_16_l_table[(v13 ^ HIBYTE(v12)) ^ a3];
    unsigned __int16 v15 = crc_16_l_table[(a4 ^ v14 ^ HIBYTE(v13))];
    unsigned __int16 v16 = crc_16_l_table[(a1[12] ^ v15 ^ HIBYTE(v14))];
    unsigned int v17 = crc_16_l_table[(a1[13] ^ v16 ^ HIBYTE(v15))];
    int v18 = crc_16_l_table[(a1[14] ^ v17 ^ HIBYTE(v16))];
    int v19 = v18 ^ ~(v17 >> 8);
    *(_WORD *)(a1 + 15) = v18 ^ ~HIBYTE(crc_16_l_table[(a1[13] ^ v16 ^ HIBYTE(v15))]);
    if (a2 >= 34)
    {
      bzero(__src, 0x800uLL);
      int v20 = *a1;
      if ((v20 - 125) > 1)
      {
        unsigned int v21 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v20) = v20 ^ 0x20;
        unsigned int v21 = 1;
      }
      __src[v21] = v20;
      uint64_t v22 = v21 + 1;
      int v23 = a1[1];
      if ((v23 - 125) <= 1)
      {
        __src[v22] = 125;
        LODWORD(v22) = v21 | 2;
        LOBYTE(v23) = v23 ^ 0x20;
      }
      __src[v22] = v23;
      uint64_t v24 = v22 + 1;
      int v25 = a1[2];
      if ((v25 - 125) <= 1)
      {
        __src[v24] = 125;
        LOBYTE(v25) = v25 ^ 0x20;
        LODWORD(v24) = v22 + 2;
      }
      __src[v24] = v25;
      uint64_t v26 = v24 + 1;
      int v27 = a1[3];
      if ((v27 - 125) <= 1)
      {
        __src[v26] = 125;
        LODWORD(v26) = v24 + 2;
        LOBYTE(v27) = v27 ^ 0x20;
      }
      __src[v26] = v27;
      uint64_t v28 = v26 + 1;
      int v29 = a1[4];
      if ((v29 - 125) <= 1)
      {
        __src[v28] = 125;
        LODWORD(v28) = v26 + 2;
        LOBYTE(v29) = v29 ^ 0x20;
      }
      uint64_t v30 = &__src[v28];
      *uint64_t v30 = v29;
      v30[1] = 0;
      uint64_t v31 = v28 + 2;
      if ((v9 - 125) <= 1)
      {
        __src[v31] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v31) = v28 + 3;
      }
      __src[v31] = v9;
      uint64_t v32 = v31 + 1;
      int v33 = a1[7];
      if ((v33 - 125) <= 1)
      {
        __src[v32] = 125;
        LODWORD(v32) = v31 + 2;
        LOBYTE(v33) = v33 ^ 0x20;
      }
      __src[v32] = v33;
      uint64_t v34 = v32 + 1;
      int v35 = a1[8];
      if ((v35 - 125) <= 1)
      {
        __src[v34] = 125;
        LOBYTE(v35) = v35 ^ 0x20;
        LODWORD(v34) = v32 + 2;
      }
      __src[v34] = v35;
      uint64_t v36 = v34 + 1;
      int v37 = a1[9];
      if ((v37 - 125) <= 1)
      {
        __src[v36] = 125;
        LODWORD(v36) = v34 + 2;
        LOBYTE(v37) = v37 ^ 0x20;
      }
      char v38 = a4;
      __src[v36] = v37;
      uint64_t v39 = v36 + 1;
      if ((a3 - 125) <= 1)
      {
        __src[v39] = 125;
        LOBYTE(a3) = a3 ^ 0x20;
        LODWORD(v39) = v36 + 2;
      }
      char v40 = BYTE1(a4);
      __src[v39] = a3;
      uint64_t v41 = v39 + 1;
      if (a4 - 125 <= 1)
      {
        __src[v41] = 125;
        char v38 = a4 ^ 0x20;
        LODWORD(v41) = v39 + 2;
      }
      char v42 = BYTE2(a4);
      __src[v41] = v38;
      uint64_t v43 = v41 + 1;
      if (BYTE1(a4) - 125 <= 1)
      {
        __src[v43] = 125;
        LODWORD(v43) = v41 + 2;
        char v40 = BYTE1(a4) ^ 0x20;
      }
      __src[v43] = v40;
      uint64_t v44 = v43 + 1;
      if (BYTE2(a4) - 125 <= 1)
      {
        __src[v44] = 125;
        char v42 = BYTE2(a4) ^ 0x20;
        LODWORD(v44) = v43 + 2;
      }
      int v45 = ~(v18 ^ BYTE1(v17));
      __src[v44] = v42;
      uint64_t v46 = v44 + 1;
      int v47 = a1[14];
      if ((v47 - 125) <= 1)
      {
        __src[v46] = 125;
        LOBYTE(v47) = v47 ^ 0x20;
        LODWORD(v46) = v44 + 2;
      }
      char v48 = (unsigned __int16)(v18 ^ ~(unsigned __int16)(v17 >> 8)) >> 8;
      __src[v46] = v47;
      uint64_t v49 = v46 + 1;
      if ((v45 - 125) <= 1)
      {
        __src[v49] = 125;
        LOBYTE(v45) = v45 ^ 0x20;
        LODWORD(v49) = v46 + 2;
      }
      __src[v49] = v45;
      uint64_t v50 = v49 + 1;
      if (BYTE1(v19) - 125 <= 1)
      {
        __src[v50] = 125;
        char v48 = BYTE1(v19) ^ 0x20;
        LODWORD(v50) = v49 + 2;
      }
      __src[v50] = v48;
      memcpy(a1, __src, v50 + 1);
      uint64_t result = (v50 + 2);
      a1[v50 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t ETLDiagCreateGUIDDB(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), unsigned __int16 *a2, unsigned __int16 **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    memset(v83, 0, sizeof(v83));
    uint64_t v84 = 0;
    memset(v81, 0, sizeof(v81));
    uint64_t v82 = 0;
    if (!HDLCFrameCreateUplink() || a2[2]) {
      goto LABEL_20;
    }
    if (HDLCFrameGetFreeSpace() <= 7)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v12, v13, v14, v15, v16, v17, 8);
    }
    else
    {
      __int16 v18 = *a2;
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace >= 4)
      {
        LOWORD(v86) = 4736;
        HIWORD(v86) = v18;
        if (HDLCFrameInject())
        {
          if (!HDLCFrameInjectUnsignedShort()
            || !HDLCFrameInjectUnsignedShort()
            || !ETLSendCommand(a1, (uint64_t)v83, a4)
            || !ETLSubsys2FindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v81, a4))
          {
            goto LABEL_20;
          }
          unsigned int v86 = 0;
          uint64_t v32 = (unsigned __int16 *)malloc(0x1CuLL);
          *a3 = v32;
          *(void *)uint64_t v32 = 0;
          *((void *)v32 + 2) = 0;
          *((_DWORD *)v32 + 6) = 0;
          *((void *)v32 + 1) = 0;
          if (!ETLSubsys2ParseHeader((uint64_t *)v81, &v85, v32, (_DWORD *)v32 + 1, v32 + 4, &v86, v33, v34))goto LABEL_27; {
          uint64_t v35 = (uint64_t)*a3;
          }
          if (**a3 != *a2) {
            goto LABEL_27;
          }
          unsigned int v36 = v86;
          int v37 = DWORD2(v81[0]);
          if (DWORD2(v81[0]) - v86 <= 5)
          {
            _ETLDebugPrint((uint64_t)"ETLDiagParseGetDBDataHeader", (uint64_t)"The required size (%u) is less than the payload length (%u)\n", v26, v27, v28, v29, v30, v31, 6);
LABEL_27:
            if (!(*a3)[7]) {
              goto LABEL_20;
            }
            uint64_t v39 = "ETLDiagParseGetDBData";
            char v40 = "Failed to parse the header while getting GUID\x13.\x13\n";
            goto LABEL_19;
          }
          uint64_t v42 = *(void *)&v81[0];
          uint64_t v43 = (_WORD *)(*(void *)&v81[0] + v86);
          *(_WORD *)(v35 + 10) = *v43;
          uint64_t v44 = (unsigned __int16)v43[1];
          *(_WORD *)(v35 + 12) = v44;
          uint64_t v45 = (unsigned __int16)v43[2];
          *(_WORD *)(v35 + 14) = v45;
          if (v44 != a2[1])
          {
            _ETLDebugPrint((uint64_t)"ETLDiagParseGetDBDataHeader", (uint64_t)"The request version (%u) is not matched with responded version (%u).\n", v26, v27, v28, v29, v30, v31, a2[1]);
            goto LABEL_27;
          }
          if (v45)
          {
            _ETLDebugPrint((uint64_t)"ETLDiagParseGetDBData", (uint64_t)"The op code (%d) is not supported!\n", v26, v27, v28, v29, v30, v31, v45);
            goto LABEL_20;
          }
          if (v37 - (v36 + 6) <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLDiagParseOperationDataFileList", (uint64_t)"Request size (%u) is greater than the payload size (%u).\n", v26, v27, v28, v29, v30, v31, 2);
            goto LABEL_20;
          }
          uint64_t v46 = v44;
          int v47 = (unsigned char *)(v42 + v36 + 6);
          if (v44 == 3)
          {
            *(unsigned char *)(v35 + 16) = *v47;
            uint64_t v48 = v47[1];
            *(unsigned char *)(v35 + 17) = v48;
            unsigned int v49 = 21;
          }
          else
          {
            if (v44 != 1)
            {
              _ETLDebugPrint((uint64_t)"ETLDiagParseOperationDataFileList", (uint64_t)"Unknown version: %u\n", v26, v27, v28, v29, v30, v31, v44);
              goto LABEL_20;
            }
            *(unsigned char *)(v35 + 16) = *v47;
            uint64_t v48 = v47[1];
            *(unsigned char *)(v35 + 17) = v48;
            unsigned int v49 = 20;
          }
          size_t v50 = v48 * (unint64_t)v49;
          uint64_t v51 = malloc(v50);
          *(void *)(v35 + 18) = v51;
          if (v51)
          {
            bzero(v51, v50);
            _ETLDebugPrint((uint64_t)"ETLDiagParseOperationDataFileList", (uint64_t)"Response: Version: %u\n", v52, v53, v54, v55, v56, v57, v46);
            _ETLDebugPrint((uint64_t)"ETLDiagParseOperationDataFileList", (uint64_t)"Response: Number of Files: %u\n", v58, v59, v60, v61, v62, v63, v48);
            if (v48)
            {
              uint64_t v70 = v47 + 2;
              if (v46 == 3) {
                unsigned int v71 = 21;
              }
              else {
                unsigned int v71 = 20;
              }
              if (v46 == 1)
              {
                uint64_t v76 = 0;
                unsigned int v77 = -8 - v36;
                uint64_t v38 = 1;
                while (1)
                {
                  uint64_t v74 = v77 + DWORD2(v81[0]);
                  if (v74 < v71) {
                    goto LABEL_56;
                  }
                  uint64_t v78 = *(void *)(v35 + 18) + v76;
                  *(_DWORD *)uint64_t v78 = *(_DWORD *)&v70[v76];
                  *(_WORD *)(v78 + 4) = *(_WORD *)&v70[v76 + 4];
                  *(_WORD *)(v78 + 6) = *(_WORD *)&v70[v76 + 6];
                  *(void *)(v78 + 8) = *(void *)&v70[v76 + 8];
                  *(_DWORD *)(*(void *)(v35 + 18) + 16) = *(_DWORD *)&v70[v76 + 16];
                  v77 -= v71;
                  v76 += 20;
                  if (20 * v48 == v76) {
                    goto LABEL_21;
                  }
                }
              }
              if (v46 == 3)
              {
                uint64_t v72 = 0;
                unsigned int v73 = -8 - v36;
                uint64_t v38 = 1;
                while (1)
                {
                  uint64_t v74 = v73 + DWORD2(v81[0]);
                  if (v74 < v71) {
                    goto LABEL_56;
                  }
                  uint64_t v75 = *(void *)(v35 + 18) + v72;
                  *(_DWORD *)uint64_t v75 = *(_DWORD *)&v70[v72];
                  *(_WORD *)(v75 + 4) = *(_WORD *)&v70[v72 + 4];
                  *(_WORD *)(v75 + 6) = *(_WORD *)&v70[v72 + 6];
                  *(void *)(v75 + 8) = *(void *)&v70[v72 + 8];
                  *(_DWORD *)(*(void *)(v35 + 18) + 16) = *(_DWORD *)&v70[v72 + 16];
                  *(unsigned char *)(*(void *)(v35 + 18) + 20) = v70[v72 + 20];
                  v73 -= v71;
                  v72 += 21;
                  if (21 * v48 == v72) {
                    goto LABEL_21;
                  }
                }
              }
              uint64_t v74 = DWORD2(v81[0]) - (v36 + 8);
              if (v74 < v71)
              {
LABEL_56:
                _ETLDebugPrint((uint64_t)"ETLDiagParseOperationDataFileList", (uint64_t)"Insufficient payload length( %u). Needed %u bytes more\n", v64, v65, v66, v67, v68, v69, v74);
                goto LABEL_20;
              }
              int v79 = 0;
              while (++v79 < v48)
              {
                uint64_t v74 = v74 - v71;
                if (v74 < v71) {
                  goto LABEL_56;
                }
              }
            }
            uint64_t v38 = 1;
            goto LABEL_21;
          }
          uint64_t v39 = "ETLDiagParseOperationDataFileList";
          char v40 = "Failed to allocate memory for file info.\n";
        }
        else
        {
          uint64_t v39 = "ETLSubsysAddHeaderInternal";
          char v40 = "Failed to inject\n";
        }
LABEL_19:
        _ETLDebugPrint((uint64_t)v39, (uint64_t)v40, v26, v27, v28, v29, v30, v31, v80);
        goto LABEL_20;
      }
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v20, v21, v22, v23, v24, v25, FreeSpace);
    }
LABEL_20:
    uint64_t v38 = 0;
LABEL_21:
    HDLCFrameFree();
    HDLCFrameFree();
    return v38;
  }
  _ETLDebugPrint((uint64_t)"ETLDiagCreateGUIDDB", (uint64_t)"transport cannot be NULL\n", (uint64_t)a3, a4, a5, a6, a7, a8, v80);
  return 0;
}

uint64_t ETLDiagReleaseGUIDDB(void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = (unsigned __int16 *)*a1;
  if (*a1)
  {
    int v10 = v8[6];
    if (v10 == 3 || v10 == 1)
    {
      unsigned __int16 v11 = *(void **)(v8 + 9);
      if (v11) {
        free(v11);
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLDiagReleaseGUIDDB", (uint64_t)"Warning: Version (%u) is not supported to free file list!\n", a3, a4, a5, a6, a7, a8, v8[6]);
    }
    free(*a1);
    *a1 = 0;
  }
  return 1;
}

const char *ETLDiagGetSubsysCmdString(int a1)
{
  if (a1 <= 3599)
  {
    if (a1 == 527) {
      return "APPS";
    }
    if (a1 == 2070) {
      return "MPSS";
    }
  }
  else
  {
    switch(a1)
    {
      case 3600:
        return "ADSP";
      case 5151:
        return "WCNSS";
      case 6680:
        return "SLPI";
    }
  }
  return (const char *)&unk_1E4590583;
}

void ETLFirmwareVersion::ETLFirmwareVersion(ETLFirmwareVersion *this)
{
  *(void *)this = &unk_1F4022FA0;
  *((unsigned char *)this + 31) = 7;
  strcpy((char *)this + 8, "Phoenix");
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0xFFFFFFFF00000000;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
}

{
  *(void *)this = &unk_1F4022FA0;
  *((unsigned char *)this + 31) = 7;
  strcpy((char *)this + 8, "Phoenix");
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0xFFFFFFFF00000000;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
}

void ETLFirmwareVersion::~ETLFirmwareVersion(void **this)
{
  *this = &unk_1F4022FA0;
  if (*((char *)this + 95) < 0)
  {
    operator delete(this[9]);
    if ((*((char *)this + 71) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*((char *)this + 31) & 0x80000000) == 0) {
        return;
      }
LABEL_7:
      operator delete(this[1]);
      return;
    }
  }
  else if ((*((char *)this + 71) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(this[6]);
  if (*((char *)this + 31) < 0) {
    goto LABEL_7;
  }
}

{
  *this = &unk_1F4022FA0;
  if (*((char *)this + 95) < 0)
  {
    operator delete(this[9]);
    if ((*((char *)this + 71) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*((char *)this + 31) & 0x80000000) == 0) {
        return;
      }
LABEL_7:
      operator delete(this[1]);
      return;
    }
  }
  else if ((*((char *)this + 71) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(this[6]);
  if (*((char *)this + 31) < 0) {
    goto LABEL_7;
  }
}

{
  ETLFirmwareVersion *v2;
  uint64_t vars8;

  *this = &unk_1F4022FA0;
  if (*((char *)this + 95) < 0)
  {
    operator delete(this[9]);
    if ((*((char *)this + 71) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*((char *)this + 31) & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if ((*((char *)this + 71) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(this[6]);
  if ((*((char *)this + 31) & 0x80000000) == 0)
  {
LABEL_4:
    uint64_t v2 = (ETLFirmwareVersion *)this;
    goto LABEL_6;
  }
LABEL_9:
  operator delete(this[1]);
  uint64_t v2 = (ETLFirmwareVersion *)this;

LABEL_6:
  operator delete(v2);
}

BOOL ETLFirmwareVersion::initCommon(uint64_t a1)
{
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v68 = 0;
  memset(__p, 170, sizeof(__p));
  ctu::tokenize();
  uint64_t v3 = (void **)__p[0];
  uint64_t v2 = (void **)__p[1];
  if (0xAAAAAAAAAAAAAAABLL * (((char *)__p[1] - (char *)__p[0]) >> 3) < 2) {
    goto LABEL_2;
  }
  uint64_t v4 = *((unsigned __int8 *)__p[0] + 23);
  if ((v4 & 0x80u) == 0) {
    uint64_t v5 = *((unsigned __int8 *)__p[0] + 23);
  }
  else {
    uint64_t v5 = *((void *)__p[0] + 1);
  }
  uint64_t v6 = *(unsigned __int8 *)(a1 + 31);
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *(void *)(a1 + 16);
  }
  if (v5 != v6) {
    goto LABEL_20;
  }
  if (v7 >= 0) {
    int v8 = (unsigned __int8 *)(a1 + 8);
  }
  else {
    int v8 = *(unsigned __int8 **)(a1 + 8);
  }
  if ((v4 & 0x80) != 0)
  {
    if (!memcmp(*(const void **)__p[0], v8, *((void *)__p[0] + 1))) {
      goto LABEL_25;
    }
LABEL_20:
    if (__p[1] == __p[0]) {
      goto LABEL_92;
    }
    do
    {
      if (*((char *)v2 - 1) < 0) {
        operator delete(*(v2 - 3));
      }
      v2 -= 3;
    }
    while (v2 != __p[0]);
LABEL_91:
    uint64_t v2 = (void **)__p[0];
LABEL_92:
    __p[1] = v3;
    operator delete(v2);
    goto LABEL_93;
  }
  if (*((unsigned char *)__p[0] + 23))
  {
    uint64_t v9 = (unsigned __int8 *)__p[0];
    while (*v9 == *v8)
    {
      ++v9;
      ++v8;
      if (!--v4) {
        goto LABEL_25;
      }
    }
LABEL_2:
    if (!__p[0]) {
      goto LABEL_93;
    }
    goto LABEL_20;
  }
LABEL_25:
  if (__dst != (void **)((char *)__p[0] + 24))
  {
    if ((*((char *)__p[0] + 47) & 0x80000000) == 0)
    {
      *(_OWORD *)__dst = *(_OWORD *)((char *)__p[0] + 24);
      uint64_t v68 = *((void *)__p[0] + 5);
      if (__p[1] == __p[0]) {
        goto LABEL_37;
      }
      do
      {
LABEL_34:
        if (*((char *)v2 - 1) < 0) {
          operator delete(*(v2 - 3));
        }
        v2 -= 3;
      }
      while (v2 != v3);
      uint64_t v2 = (void **)__p[0];
      goto LABEL_37;
    }
    std::string::__assign_no_alias<true>(__dst, *((void **)__p[0] + 3), *((void *)__p[0] + 4));
    uint64_t v3 = (void **)__p[0];
  }
  if (!v3) {
    goto LABEL_38;
  }
  uint64_t v2 = (void **)__p[1];
  if (__p[1] != v3) {
    goto LABEL_34;
  }
LABEL_37:
  __p[1] = v3;
  operator delete(v2);
LABEL_38:
  memset(__p, 170, sizeof(__p));
  ctu::tokenize();
  uint64_t v3 = (void **)__p[0];
  uint64_t v2 = (void **)__p[1];
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p[1] - (char *)__p[0]) >> 3);
  if (v10 != 1)
  {
    if (v10 != 2)
    {
      if (__p[0])
      {
        if (__p[1] == __p[0]) {
          goto LABEL_92;
        }
        do
        {
          if (*((char *)v2 - 1) < 0) {
            operator delete(*(v2 - 3));
          }
          v2 -= 3;
        }
        while (v2 != __p[0]);
        goto LABEL_91;
      }
      goto LABEL_93;
    }
    if (__dst != __p[0])
    {
      char v11 = *((unsigned char *)__p[0] + 23);
      if (SHIBYTE(v68) < 0)
      {
        if (v11 >= 0) {
          uint64_t v13 = __p[0];
        }
        else {
          uint64_t v13 = *(void **)__p[0];
        }
        if (v11 >= 0) {
          size_t v14 = *((unsigned __int8 *)__p[0] + 23);
        }
        else {
          size_t v14 = *((void *)__p[0] + 1);
        }
        std::string::__assign_no_alias<false>(__dst, v13, v14);
      }
      else if ((*((unsigned char *)__p[0] + 23) & 0x80) != 0)
      {
        std::string::__assign_no_alias<true>(__dst, *(void **)__p[0], *((void *)__p[0] + 1));
      }
      else
      {
        long long v12 = *(_OWORD *)__p[0];
        uint64_t v68 = *((void *)__p[0] + 2);
        *(_OWORD *)__dst = v12;
      }
    }
    uint64_t v3 = (void **)__p[0];
    uint64_t v15 = (void **)(a1 + 48);
    if ((void *)(a1 + 48) != (char *)__p[0] + 24)
    {
      char v16 = *((unsigned char *)__p[0] + 47);
      if (*(char *)(a1 + 71) < 0)
      {
        if (v16 >= 0) {
          __int16 v18 = (char *)__p[0] + 24;
        }
        else {
          __int16 v18 = (char *)*((void *)__p[0] + 3);
        }
        if (v16 >= 0) {
          size_t v19 = *((unsigned __int8 *)__p[0] + 47);
        }
        else {
          size_t v19 = *((void *)__p[0] + 4);
        }
        std::string::__assign_no_alias<false>(v15, v18, v19);
      }
      else if ((*((unsigned char *)__p[0] + 47) & 0x80) != 0)
      {
        std::string::__assign_no_alias<true>(v15, *((void **)__p[0] + 3), *((void *)__p[0] + 4));
      }
      else
      {
        long long v17 = *(_OWORD *)((char *)__p[0] + 24);
        *(void *)(a1 + 64) = *((void *)__p[0] + 5);
        *(_OWORD *)uint64_t v15 = v17;
      }
      uint64_t v3 = (void **)__p[0];
    }
  }
  if (v3)
  {
    uint64_t v20 = (void **)__p[1];
    uint64_t v21 = v3;
    if (__p[1] != v3)
    {
      do
      {
        if (*((char *)v20 - 1) < 0) {
          operator delete(*(v20 - 3));
        }
        v20 -= 3;
      }
      while (v20 != v3);
      uint64_t v21 = (void **)__p[0];
    }
    __p[1] = v3;
    operator delete(v21);
  }
  memset(__p, 170, sizeof(__p));
  ctu::tokenize();
  uint64_t v3 = (void **)__p[0];
  uint64_t v2 = (void **)__p[1];
  unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p[1] - (char *)__p[0]) >> 3);
  if (v22 == 1) {
    goto LABEL_125;
  }
  if (v22 != 2)
  {
    if (__p[0])
    {
      if (__p[1] == __p[0]) {
        goto LABEL_92;
      }
      do
      {
        if (*((char *)v2 - 1) < 0) {
          operator delete(*(v2 - 3));
        }
        v2 -= 3;
      }
      while (v2 != __p[0]);
      goto LABEL_91;
    }
LABEL_93:
    BOOL v25 = 0;
    goto LABEL_94;
  }
  if (__dst != __p[0])
  {
    char v23 = *((unsigned char *)__p[0] + 23);
    if (SHIBYTE(v68) < 0)
    {
      if (v23 >= 0) {
        uint64_t v27 = __p[0];
      }
      else {
        uint64_t v27 = *(void **)__p[0];
      }
      if (v23 >= 0) {
        size_t v28 = *((unsigned __int8 *)__p[0] + 23);
      }
      else {
        size_t v28 = *((void *)__p[0] + 1);
      }
      std::string::__assign_no_alias<false>(__dst, v27, v28);
    }
    else if ((*((unsigned char *)__p[0] + 23) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>(__dst, *(void **)__p[0], *((void *)__p[0] + 1));
    }
    else
    {
      long long v24 = *(_OWORD *)__p[0];
      uint64_t v68 = *((void *)__p[0] + 2);
      *(_OWORD *)__dst = v24;
    }
  }
  *(_DWORD *)(a1 + 44) = 0;
  uint64_t v29 = __p[0];
  uint64_t v30 = (char **)((char *)__p[0] + 24);
  __endptr = 0;
  int v31 = *((char *)__p[0] + 47);
  if (v31 >= 0) {
    size_t v32 = *((unsigned __int8 *)__p[0] + 47);
  }
  else {
    size_t v32 = *((void *)__p[0] + 4);
  }
  if (!v32
    || (v31 >= 0 ? (uint64_t v33 = (char *)__p[0] + 24) : (uint64_t v33 = *v30),
        (uint64_t v34 = memchr(v33, 45, v32)) != 0 ? (v35 = v34 - v33 == -1) : (v35 = 1),
        v35))
  {
    *__error() = 0;
    unsigned int v36 = *((char *)v29 + 47) >= 0 ? (const char *)v30 : (const char *)v29[3];
    int v37 = strtoul(v36, &__endptr, 10);
    if (!*__error() && __endptr && !*__endptr) {
      *(_DWORD *)(a1 + 44) = v37;
    }
  }
  uint64_t v3 = (void **)__p[0];
LABEL_125:
  if (v3)
  {
    uint64_t v38 = (void **)__p[1];
    uint64_t v39 = v3;
    if (__p[1] != v3)
    {
      do
      {
        if (*((char *)v38 - 1) < 0) {
          operator delete(*(v38 - 3));
        }
        v38 -= 3;
      }
      while (v38 != v3);
      uint64_t v39 = (void **)__p[0];
    }
    __p[1] = v3;
    operator delete(v39);
  }
  memset(__p, 170, sizeof(__p));
  ctu::tokenize();
  char v40 = (void **)__p[0];
  BOOL v25 = (void *)((char *)__p[1] - (char *)__p[0]) == (void *)72;
  if ((void *)((char *)__p[1] - (char *)__p[0]) == (void *)72)
  {
    *(_DWORD *)(a1 + 32) = 0;
    __endptr = 0;
    int v41 = *((char *)v40 + 23);
    if (v41 >= 0) {
      size_t v42 = *((unsigned __int8 *)v40 + 23);
    }
    else {
      size_t v42 = (size_t)v40[1];
    }
    if (!v42
      || (v41 >= 0 ? (uint64_t v43 = v40) : (uint64_t v43 = *v40),
          (uint64_t v44 = memchr(v43, 45, v42)) != 0 ? (v45 = v44 - (unsigned char *)v43 == -1) : (v45 = 1),
          v45))
    {
      *__error() = 0;
      uint64_t v46 = *((char *)v40 + 23) >= 0 ? (const char *)v40 : (const char *)*v40;
      int v47 = strtoul(v46, &__endptr, 10);
      if (!*__error() && __endptr && !*__endptr) {
        *(_DWORD *)(a1 + 32) = v47;
      }
    }
    *(_DWORD *)(a1 + 36) = 0;
    uint64_t v48 = __p[0];
    unsigned int v49 = (char **)((char *)__p[0] + 24);
    __endptr = 0;
    int v50 = *((char *)__p[0] + 47);
    if (v50 >= 0) {
      size_t v51 = *((unsigned __int8 *)__p[0] + 47);
    }
    else {
      size_t v51 = *((void *)__p[0] + 4);
    }
    if (!v51
      || (v50 >= 0 ? (uint64_t v52 = (char *)__p[0] + 24) : (uint64_t v52 = *v49), (v53 = memchr(v52, 45, v51)) == 0 || v53 - v52 == -1))
    {
      *__error() = 0;
      uint64_t v54 = *((char *)v48 + 47) >= 0 ? (const char *)v49 : (const char *)v48[3];
      int v55 = strtoul(v54, &__endptr, 10);
      if (!*__error() && __endptr && !*__endptr) {
        *(_DWORD *)(a1 + 36) = v55;
      }
    }
    *(_DWORD *)(a1 + 40) = 0;
    uint64_t v56 = __p[0];
    uint64_t v57 = (char **)((char *)__p[0] + 48);
    __endptr = 0;
    int v58 = *((char *)__p[0] + 71);
    if (v58 >= 0) {
      size_t v59 = *((unsigned __int8 *)__p[0] + 71);
    }
    else {
      size_t v59 = *((void *)__p[0] + 7);
    }
    if (!v59
      || (v58 >= 0 ? (uint64_t v60 = (char *)__p[0] + 48) : (uint64_t v60 = *v57), (v61 = memchr(v60, 45, v59)) == 0 || v61 - v60 == -1))
    {
      *__error() = 0;
      uint64_t v62 = *((char *)v56 + 71) >= 0 ? (const char *)v57 : (const char *)v56[6];
      int v63 = strtoul(v62, &__endptr, 10);
      if (!*__error() && __endptr && !*__endptr) {
        *(_DWORD *)(a1 + 40) = v63;
      }
    }
    char v40 = (void **)__p[0];
  }
  if (v40)
  {
    uint64_t v64 = (void **)__p[1];
    uint64_t v65 = v40;
    if (__p[1] != v40)
    {
      do
      {
        if (*((char *)v64 - 1) < 0) {
          operator delete(*(v64 - 3));
        }
        v64 -= 3;
      }
      while (v64 != v40);
      uint64_t v65 = (void **)__p[0];
    }
    __p[1] = v40;
    operator delete(v65);
  }
LABEL_94:
  if (SHIBYTE(v68) < 0) {
    operator delete(__dst[0]);
  }
  return v25;
}

void sub_1E455FAD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void **std::vector<std::string>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = (void **)*a1;
  if (*a1)
  {
    uint64_t v3 = (void **)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        if (*((char *)v3 - 1) < 0) {
          operator delete(*(v3 - 3));
        }
        v3 -= 3;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

BOOL ETLFirmwareVersion::initWithVersionString(uint64_t a1, uint64_t a2)
{
  v39[2] = *MEMORY[0x1E4F143B8];
  memset(__p, 0, sizeof(__p));
  char v4 = *(unsigned char *)(a2 + 23);
  uint64_t v5 = *(void **)a2;
  if (v4 >= 0) {
    uint64_t v6 = (const std::string::value_type *)a2;
  }
  else {
    uint64_t v6 = *(const std::string::value_type **)a2;
  }
  __s = v6;
  int v7 = *(char *)(a1 + 31);
  if (v7 >= 0) {
    int v8 = (char *)(a1 + 8);
  }
  else {
    int v8 = *(char **)(a1 + 8);
  }
  if (v7 >= 0) {
    int64_t v9 = *(unsigned __int8 *)(a1 + 31);
  }
  else {
    int64_t v9 = *(void *)(a1 + 16);
  }
  if (v9)
  {
    if (v4 >= 0) {
      int64_t v10 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      int64_t v10 = *(void *)(a2 + 8);
    }
    if (v10 >= v9)
    {
      uint64_t v13 = (std::string::value_type *)v6;
      size_t v14 = &v6[v10];
      int v15 = *v8;
      int64_t v16 = v10;
      do
      {
        int64_t v17 = v16 - v9;
        if (v17 == -1) {
          break;
        }
        __int16 v18 = (const std::string::value_type *)memchr(v13, v15, v17 + 1);
        if (!v18) {
          break;
        }
        size_t v19 = v18;
        if (!memcmp(v18, v8, v9))
        {
          if (v19 == v14 || v19 != __s) {
            break;
          }
          goto LABEL_33;
        }
        uint64_t v13 = (std::string::value_type *)(v19 + 1);
        int64_t v16 = v14 - (v19 + 1);
      }
      while (v16 >= v9);
    }
    unint64_t v11 = v9 + 1;
    if ((unint64_t)(v9 + 1) > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    if (v11 > 0x16)
    {
      uint64_t v20 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v11 | 7) != 0x17) {
        uint64_t v20 = v11 | 7;
      }
      uint64_t v21 = v20 + 1;
      p_dst = (std::string *)operator new(v20 + 1);
      __dst.__r_.__value_.__l.__size_ = v9 + 1;
      __dst.__r_.__value_.__r.__words[2] = v21 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      memset(&__dst, 0, sizeof(__dst));
      p_dst = &__dst;
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v9 + 1;
    }
    memmove(p_dst, v8, v9);
    *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v9) = 32;
    unint64_t v22 = std::string::append(&__dst, __s, v10);
    char v23 = (void *)v22->__r_.__value_.__r.__words[0];
    v39[0] = v22->__r_.__value_.__l.__size_;
    *(void *)((char *)v39 + 7) = *(std::string::size_type *)((char *)&v22->__r_.__value_.__r.__words[1] + 7);
    char v24 = HIBYTE(v22->__r_.__value_.__r.__words[2]);
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    __p[0] = v23;
    __p[1] = (void *)v39[0];
    *(void **)((char *)&__p[1] + 7) = *(void **)((char *)v39 + 7);
    HIBYTE(__p[2]) = v24;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
  }
  else
  {
LABEL_33:
    if (__p != (void **)a2)
    {
      if (v4 < 0)
      {
        std::string::__assign_no_alias<true>(__p, v5, *(void *)(a2 + 8));
      }
      else
      {
        *(_OWORD *)__p = *(_OWORD *)a2;
        __p[2] = *(void **)(a2 + 16);
      }
    }
  }
  int v25 = *(char *)(a2 + 23);
  if (v25 >= 0) {
    size_t v26 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    size_t v26 = *(void *)(a2 + 8);
  }
  unint64_t v27 = v26 + 16;
  memset(&__dst, 170, sizeof(__dst));
  if (v26 + 16 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v27 >= 0x17)
  {
    uint64_t v32 = (v27 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v27 | 7) != 0x17) {
      uint64_t v32 = v27 | 7;
    }
    uint64_t v33 = v32 + 1;
    uint64_t v34 = operator new(v32 + 1);
    __dst.__r_.__value_.__l.__size_ = v26 + 16;
    __dst.__r_.__value_.__r.__words[2] = v33 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v34;
    _OWORD *v34 = *(_OWORD *)"Version String: ";
    size_t v28 = (std::string::value_type *)(v34 + 1);
  }
  else
  {
    size_t v28 = &__dst.__r_.__value_.__s.__data_[16];
    __dst.__r_.__value_.__r.__words[2] = 0;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v26 + 16;
    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)"Version String: ";
    if (!v26)
    {
      __dst.__r_.__value_.__s.__data_[16] = 0;
      uint64_t v29 = (void **)(a1 + 72);
      if ((*(char *)(a1 + 95) & 0x80000000) == 0) {
        goto LABEL_44;
      }
      goto LABEL_54;
    }
  }
  if (v25 >= 0) {
    BOOL v35 = (const void *)a2;
  }
  else {
    BOOL v35 = *(const void **)a2;
  }
  memmove(v28, v35, v26);
  v28[v26] = 0;
  uint64_t v29 = (void **)(a1 + 72);
  if ((*(char *)(a1 + 95) & 0x80000000) == 0) {
    goto LABEL_44;
  }
LABEL_54:
  operator delete(*v29);
LABEL_44:
  *(std::string *)uint64_t v29 = __dst;
  BOOL inited = ETLFirmwareVersion::initCommon(a1);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  return inited;
}

void sub_1E455FF08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0)
  {
    operator delete(__p);
    if ((a23 & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((a23 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a18);
  _Unwind_Resume(exception_object);
}

BOOL ETLFirmwareVersion::initWithFolderName(uint64_t a1, const void **a2)
{
  int v2 = *((char *)a2 + 23);
  if (v2 >= 0) {
    size_t v3 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v3 = (size_t)a2[1];
  }
  unint64_t v4 = v3 + 8;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  if (v3 + 8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v4 >= 0x17)
  {
    uint64_t v10 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v10 = v4 | 7;
    }
    uint64_t v11 = v10 + 1;
    long long v12 = operator new(v10 + 1);
    *long long v12 = 0x203A7265646C6F46;
    int v7 = (char *)(v12 + 1);
    *((void *)&v14 + 1) = v3 + 8;
    unint64_t v15 = v11 | 0x8000000000000000;
    *(void *)&long long v14 = v12;
  }
  else
  {
    int v7 = (char *)&v14 + 8;
    unint64_t v15 = 0;
    HIBYTE(v15) = v3 + 8;
    long long v14 = 0x203A7265646C6F46uLL;
    if (!v3)
    {
      BYTE8(v14) = 0;
      uint64_t v8 = a1 + 72;
      if ((*(char *)(a1 + 95) & 0x80000000) == 0) {
        goto LABEL_8;
      }
      goto LABEL_18;
    }
  }
  if (v2 >= 0) {
    uint64_t v13 = a2;
  }
  else {
    uint64_t v13 = *a2;
  }
  memmove(v7, v13, v3);
  v7[v3] = 0;
  uint64_t v8 = a1 + 72;
  if ((*(char *)(a1 + 95) & 0x80000000) == 0) {
    goto LABEL_8;
  }
LABEL_18:
  operator delete(*(void **)v8);
LABEL_8:
  *(_OWORD *)uint64_t v8 = v14;
  *(void *)(v8 + 16) = v15;

  return ETLFirmwareVersion::initCommon(a1);
}

BOOL ETLFirmwareVersion::isNewerThan(ETLFirmwareVersion *this, const ETLFirmwareVersion *a2)
{
  unsigned int v2 = *((_DWORD *)this + 8);
  unsigned int v3 = *((_DWORD *)a2 + 8);
  if (v2 < v3) {
    return 0;
  }
  if (v2 > v3) {
    return 1;
  }
  unsigned int v5 = *((_DWORD *)this + 9);
  unsigned int v6 = *((_DWORD *)a2 + 9);
  if (v5 < v6) {
    return 0;
  }
  if (v5 > v6) {
    return 1;
  }
  unsigned int v7 = *((_DWORD *)this + 10);
  unsigned int v8 = *((_DWORD *)a2 + 10);
  if (v7 < v8) {
    return 0;
  }
  return v7 > v8 || *((_DWORD *)this + 11) > *((_DWORD *)a2 + 11);
}

BOOL ETLFirmwareVersion::equals(ETLFirmwareVersion *this, const ETLFirmwareVersion *a2)
{
  return *((_DWORD *)this + 8) == *((_DWORD *)a2 + 8)
      && *((_DWORD *)this + 9) == *((_DWORD *)a2 + 9)
      && *((_DWORD *)this + 10) == *((_DWORD *)a2 + 10)
      && *((_DWORD *)this + 11) == *((_DWORD *)a2 + 11);
}

uint64_t ETLFirmwareVersion::getAsString@<X0>(ETLFirmwareVersion *this@<X0>, std::string *a2@<X8>)
{
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  long long v73 = v4;
  long long v72 = v4;
  long long v71 = v4;
  long long v70 = v4;
  long long v69 = v4;
  long long v68 = v4;
  long long v67 = v4;
  long long v66 = v4;
  long long v65 = v4;
  long long v62 = v4;
  long long v60 = v4;
  *(_OWORD *)uint64_t v61 = v4;
  long long v58 = v4;
  long long v59 = v4;
  long long v57 = v4;
  uint64_t v5 = MEMORY[0x1E4FBA498] + 64;
  uint64_t v64 = MEMORY[0x1E4FBA498] + 64;
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA418] + 16);
  uint64_t v56 = *(void *)(MEMORY[0x1E4FBA418] + 8);
  *(uint64_t *)((char *)&v56 + *(void *)(v56 - 24)) = v6;
  unsigned int v7 = (std::ios_base *)((char *)&v56 + *(void *)(v56 - 24));
  std::ios_base::init(v7, &v57);
  uint64_t v8 = MEMORY[0x1E4FBA498] + 24;
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  uint64_t v56 = v8;
  uint64_t v64 = v5;
  std::streambuf::basic_streambuf();
  uint64_t v9 = MEMORY[0x1E4FBA470] + 16;
  *(void *)&long long v57 = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)uint64_t v61 = 0u;
  long long v62 = 0u;
  LODWORD(v63) = 16;
  uint64_t v10 = v56;
  uint64_t v11 = (char *)&v56 + *(void *)(v56 - 24);
  if (*((_DWORD *)v11 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)&v56 + *(void *)(v56 - 24)));
    long long v12 = std::locale::use_facet((const std::locale *)&__dst, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v12->__vftable[2].~facet_0)(v12, 32);
    std::locale::~locale((std::locale *)&__dst);
    uint64_t v10 = v56;
  }
  *((_DWORD *)v11 + 36) = 48;
  *(void *)((char *)&v58 + *(void *)(v10 - 24)) = 2;
  std::ostream::operator<<();
  *(void *)((char *)&v58 + *(void *)(v56 - 24)) = 1;
  __dst.__r_.__value_.__s.__data_[0] = 46;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v56, (uint64_t)&__dst);
  *(void *)((char *)&v58 + *(void *)(v56 - 24)) = 2;
  std::ostream::operator<<();
  *(void *)((char *)&v58 + *(void *)(v56 - 24)) = 1;
  __dst.__r_.__value_.__s.__data_[0] = 46;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v56, (uint64_t)&__dst);
  *(void *)((char *)&v58 + *(void *)(v56 - 24)) = 2;
  std::ostream::operator<<();
  *(void *)((char *)&v58 + *(void *)(v56 - 24)) = 1;
  if (*((_DWORD *)this + 11) != -1)
  {
    __dst.__r_.__value_.__s.__data_[0] = 45;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v56, (uint64_t)&__dst);
    std::ostream::operator<<();
  }
  uint64_t v53 = v9;
  memset(a2, 170, sizeof(std::string));
  int v13 = *((char *)this + 31);
  if (v13 >= 0) {
    size_t v14 = *((unsigned __int8 *)this + 31);
  }
  else {
    size_t v14 = *((void *)this + 2);
  }
  unint64_t v15 = v14 + 1;
  memset(&__dst, 170, sizeof(__dst));
  if (v14 + 1 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v15 >= 0x17)
  {
    uint64_t v17 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17) {
      uint64_t v17 = v15 | 7;
    }
    uint64_t v18 = v17 + 1;
    p_dst = (std::string *)operator new(v17 + 1);
    __dst.__r_.__value_.__l.__size_ = v14 + 1;
    __dst.__r_.__value_.__r.__words[2] = v18 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v14 + 1;
    if (!v14) {
      goto LABEL_19;
    }
  }
  if (v13 >= 0) {
    size_t v19 = (char *)this + 8;
  }
  else {
    size_t v19 = (char *)*((void *)this + 1);
  }
  memmove(p_dst, v19, v14);
LABEL_19:
  *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v14) = 32;
  if ((v63 & 0x10) != 0)
  {
    uint64_t v22 = *((void *)&v62 + 1);
    if (*((void *)&v62 + 1) < (unint64_t)v60)
    {
      *((void *)&v62 + 1) = v60;
      uint64_t v22 = v60;
    }
    char v23 = (const void *)*((void *)&v59 + 1);
    std::string::size_type v20 = v22 - *((void *)&v59 + 1);
    if ((unint64_t)(v22 - *((void *)&v59 + 1)) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_71;
    }
  }
  else
  {
    if ((v63 & 8) == 0)
    {
      std::string::size_type v20 = 0;
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
      p_p = &__p;
      goto LABEL_32;
    }
    char v23 = (const void *)v58;
    std::string::size_type v20 = v59 - v58;
    if ((void)v59 - (void)v58 > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_71:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v20 >= 0x17)
  {
    uint64_t v24 = (v20 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v20 | 7) != 0x17) {
      uint64_t v24 = v20 | 7;
    }
    uint64_t v25 = v24 + 1;
    p_p = (std::string *)operator new(v24 + 1);
    __p.__r_.__value_.__l.__size_ = v20;
    __p.__r_.__value_.__r.__words[2] = v25 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
    goto LABEL_31;
  }
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = v20;
  p_p = &__p;
  if (v20) {
LABEL_31:
  }
    memmove(p_p, v23, v20);
LABEL_32:
  p_p->__r_.__value_.__s.__data_[v20] = 0;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v26 = &__p;
  }
  else {
    size_t v26 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  size_t v28 = std::string::append(&__dst, (const std::string::value_type *)v26, size);
  long long v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
  a2->__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
  *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v29;
  v28->__r_.__value_.__l.__size_ = 0;
  v28->__r_.__value_.__r.__words[2] = 0;
  v28->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_40:
      size_t v30 = *((unsigned __int8 *)this + 71);
      if ((*((char *)this + 71) & 0x80000000) == 0) {
        goto LABEL_41;
      }
LABEL_45:
      if (!*((void *)this + 7)) {
        goto LABEL_67;
      }
      goto LABEL_46;
    }
  }
  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_40;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
  size_t v30 = *((unsigned __int8 *)this + 71);
  if (*((char *)this + 71) < 0) {
    goto LABEL_45;
  }
LABEL_41:
  if (!v30) {
    goto LABEL_67;
  }
LABEL_46:
  if ((v30 & 0x80u) == 0) {
    size_t v31 = v30;
  }
  else {
    size_t v31 = *((void *)this + 7);
  }
  unint64_t v32 = v31 + 1;
  memset(&__dst, 170, sizeof(__dst));
  if (v31 + 1 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v32 >= 0x17)
  {
    uint64_t v34 = (v32 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v32 | 7) != 0x17) {
      uint64_t v34 = v32 | 7;
    }
    uint64_t v35 = v34 + 1;
    unsigned int v36 = operator new(v34 + 1);
    __dst.__r_.__value_.__l.__size_ = v31 + 1;
    __dst.__r_.__value_.__r.__words[2] = v35 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v36;
    *unsigned int v36 = 95;
    uint64_t v33 = v36 + 1;
  }
  else
  {
    __dst.__r_.__value_.__r.__words[2] = 0;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v31 + 1;
    uint64_t v33 = &__dst.__r_.__value_.__s.__data_[1];
    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = 0x5FuLL;
    if (!v31) {
      goto LABEL_60;
    }
  }
  if ((v30 & 0x80u) == 0) {
    int v37 = (char *)this + 48;
  }
  else {
    int v37 = (char *)*((void *)this + 6);
  }
  memmove(v33, v37, v31);
LABEL_60:
  v33[v31] = 0;
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v38 = &__dst;
  }
  else {
    uint64_t v38 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v39 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v39 = __dst.__r_.__value_.__l.__size_;
  }
  std::string::append(a2, (const std::string::value_type *)v38, v39);
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_67:
    size_t v40 = *((unsigned __int8 *)this + 95);
    if ((*((char *)this + 95) & 0x80000000) == 0) {
      goto LABEL_68;
    }
LABEL_73:
    if (!*((void *)this + 10)) {
      goto LABEL_96;
    }
    goto LABEL_74;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
  size_t v40 = *((unsigned __int8 *)this + 95);
  if (*((char *)this + 95) < 0) {
    goto LABEL_73;
  }
LABEL_68:
  if (!v40) {
    goto LABEL_96;
  }
LABEL_74:
  if ((v40 & 0x80u) == 0) {
    size_t v41 = v40;
  }
  else {
    size_t v41 = *((void *)this + 10);
  }
  unint64_t v42 = v41 + 7;
  if (v41 + 7 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v42 >= 0x17)
  {
    uint64_t v44 = (v42 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v42 | 7) != 0x17) {
      uint64_t v44 = v42 | 7;
    }
    uint64_t v45 = v44 + 1;
    uint64_t v46 = operator new(v44 + 1);
    __p.__r_.__value_.__l.__size_ = v41 + 7;
    __p.__r_.__value_.__r.__words[2] = v45 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v46;
    *uint64_t v46 = 1919295528;
    uint64_t v43 = (char *)v46 + 7;
    *(_DWORD *)((char *)v46 + 3) = 544042866;
    goto LABEL_84;
  }
  *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = 0uLL;
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = v41 + 7;
  uint64_t v43 = &__p.__r_.__value_.__s.__data_[7];
  strcpy((char *)&__p, "( from ");
  if (v41)
  {
LABEL_84:
    if ((v40 & 0x80u) == 0) {
      int v47 = (char *)this + 72;
    }
    else {
      int v47 = (char *)*((void *)this + 9);
    }
    memmove(v43, v47, v41);
  }
  v43[v41] = 0;
  uint64_t v48 = std::string::append(&__p, ")", 2uLL);
  long long v49 = *(_OWORD *)&v48->__r_.__value_.__l.__data_;
  __dst.__r_.__value_.__r.__words[2] = v48->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v49;
  v48->__r_.__value_.__l.__size_ = 0;
  v48->__r_.__value_.__r.__words[2] = 0;
  v48->__r_.__value_.__r.__words[0] = 0;
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v50 = &__dst;
  }
  else {
    int v50 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v51 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v51 = __dst.__r_.__value_.__l.__size_;
  }
  std::string::append(a2, (const std::string::value_type *)v50, v51);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_96;
    }
  }
  else if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_96;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
LABEL_96:
  uint64_t v56 = *MEMORY[0x1E4FBA418];
  *(uint64_t *)((char *)&v56 + *(void *)(v56 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  *(void *)&long long v57 = v53;
  if (SBYTE7(v62) < 0) {
    operator delete(v61[0]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E4E81840](&v64);
}

void sub_1E4560A38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (*(char *)(v22 + 23) < 0)
  {
    operator delete(*(void **)v22);
    std::ostringstream::~ostringstream((uint64_t)&a22);
    _Unwind_Resume(a1);
  }
  std::ostringstream::~ostringstream((uint64_t)&a22);
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA418];
  uint64_t v3 = *MEMORY[0x1E4FBA418];
  *(void *)a1 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 8) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1E4E81840](a1 + 112);
  return a1;
}

unsigned char *ETLFirmwareVersion::createWithVersionString(uint64_t a1)
{
  uint64_t v2 = operator new(0x60uLL);
  *(void *)uint64_t v2 = &unk_1F4022FA0;
  v2[31] = 7;
  strcpy(v2 + 8, "Phoenix");
  *((void *)v2 + 4) = 0;
  *((void *)v2 + 5) = 0xFFFFFFFF00000000;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *((_OWORD *)v2 + 5) = 0u;
  if (!ETLFirmwareVersion::initWithVersionString((uint64_t)v2, a1))
  {
    (*(void (**)(unsigned char *))(*(void *)v2 + 8))(v2);
    return 0;
  }
  return v2;
}

unsigned char *ETLFirmwareVersion::createWithFolderName(const void **a1)
{
  uint64_t v2 = operator new(0x60uLL);
  *(void *)uint64_t v2 = &unk_1F4022FA0;
  v2[31] = 7;
  strcpy(v2 + 8, "Phoenix");
  *((void *)v2 + 4) = 0;
  *((void *)v2 + 5) = 0xFFFFFFFF00000000;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *((_OWORD *)v2 + 5) = 0u;
  if (!ETLFirmwareVersion::initWithFolderName((uint64_t)v2, a1))
  {
    (*(void (**)(unsigned char *))(*(void *)v2 + 8))(v2);
    return 0;
  }
  return v2;
}

void std::string::__throw_length_error[abi:ne180100]()
{
}

void std::__throw_length_error[abi:ne180100]()
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception);
  __cxa_throw(exception, (struct type_info *)off_1E6E6FED8, MEMORY[0x1E4FBA1C8]);
}

void sub_1E4560E48(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1)
{
  uint64_t result = std::logic_error::logic_error(a1, "basic_string");
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D0] + 16);
  return result;
}

void __clang_call_terminate(void *a1)
{
}

void *std::string::__assign_no_alias<true>(void *__dst, void *__src, size_t __len)
{
  if (__len > 0x16)
  {
    if (__len - 0x7FFFFFFFFFFFFFF7 <= 0x800000000000001ELL) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    size_t v7 = 44;
    if (__len > 0x2C) {
      size_t v7 = __len;
    }
    size_t v8 = (v7 | 7) + 1;
    uint64_t v6 = operator new(v8);
    memcpy(v6, __src, __len);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    *std::string __dst = v6;
  }
  else
  {
    *((unsigned char *)__dst + 23) = __len;
    uint64_t v6 = __dst;
    if (__len)
    {
      memmove(__dst, __src, __len);
      uint64_t v6 = __dst;
    }
  }
  *((unsigned char *)v6 + __len) = 0;
  return __dst;
}

void **std::string::__assign_no_alias<false>(void **a1, void *__src, size_t __len)
{
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t v7 = v6 & 0x7FFFFFFFFFFFFFFFLL;
  if ((v6 & 0x7FFFFFFFFFFFFFFFLL) > __len)
  {
    size_t v8 = *a1;
    a1[1] = (void *)__len;
    if (__len) {
      memmove(v8, __src, __len);
    }
    goto LABEL_12;
  }
  size_t v9 = 0x7FFFFFFFFFFFFFF7;
  if (0x7FFFFFFFFFFFFFF7 - v7 < __len - v7 + 1) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  unint64_t v10 = v7 - 1;
  uint64_t v11 = a1;
  if ((v6 & 0x8000000000000000) == 0)
  {
    if (v10 > 0x3FFFFFFFFFFFFFF2) {
      goto LABEL_7;
    }
LABEL_14:
    unint64_t v13 = 2 * v10;
    if (__len > 2 * v10) {
      unint64_t v13 = __len;
    }
    uint64_t v14 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17) {
      uint64_t v14 = v13 | 7;
    }
    if (v13 >= 0x17) {
      size_t v9 = v14 + 1;
    }
    else {
      size_t v9 = 23;
    }
    size_t v8 = operator new(v9);
    if (!__len) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  uint64_t v11 = *a1;
  if (v10 <= 0x3FFFFFFFFFFFFFF2) {
    goto LABEL_14;
  }
LABEL_7:
  size_t v8 = operator new(0x7FFFFFFFFFFFFFF7uLL);
  if (__len) {
LABEL_8:
  }
    memcpy(v8, __src, __len);
LABEL_9:
  if (v10 != 22) {
    operator delete(v11);
  }
  a1[1] = (void *)__len;
  a1[2] = (void *)(v9 | 0x8000000000000000);
  *a1 = v8;
LABEL_12:
  *((unsigned char *)v8 + __len) = 0;
  return a1;
}

void *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(void *a1, uint64_t a2)
{
  v22[0] = 0xAAAAAAAAAAAAAAAALL;
  v22[1] = 0xAAAAAAAAAAAAAAAALL;
  MEMORY[0x1E4E81760](v22, a1);
  if (LOBYTE(v22[0]))
  {
    long long v4 = (char *)a1 + *(void *)(*a1 - 24);
    uint64_t v5 = *((void *)v4 + 5);
    int v6 = *((_DWORD *)v4 + 2);
    int v7 = *((_DWORD *)v4 + 36);
    if (v7 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      size_t v9 = std::locale::use_facet(__b, MEMORY[0x1E4FBA258]);
      int v7 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 32);
      std::locale::~locale(__b);
      *((_DWORD *)v4 + 36) = v7;
      if ((v6 & 0xB0) == 0x20) {
        uint64_t v8 = a2 + 1;
      }
      else {
        uint64_t v8 = a2;
      }
      if (!v5) {
        goto LABEL_34;
      }
    }
    else
    {
      if ((*((_DWORD *)v4 + 2) & 0xB0) == 0x20) {
        uint64_t v8 = a2 + 1;
      }
      else {
        uint64_t v8 = a2;
      }
      if (!v5) {
        goto LABEL_34;
      }
    }
    uint64_t v10 = *((void *)v4 + 3);
    BOOL v11 = v10 <= 1;
    size_t v12 = v10 - 1;
    if (v11) {
      size_t v13 = 0;
    }
    else {
      size_t v13 = v12;
    }
    if (v8 - a2 < 1
      || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5 + 96))(v5, a2, v8 - a2) == v8 - a2)
    {
      if ((uint64_t)v13 >= 1)
      {
        memset(__b, 170, sizeof(__b));
        if (v13 >= 0x7FFFFFFFFFFFFFF8) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        if (v13 >= 0x17)
        {
          uint64_t v15 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v13 | 7) != 0x17) {
            uint64_t v15 = v13 | 7;
          }
          uint64_t v16 = v15 + 1;
          uint64_t v14 = (std::locale::__imp *)operator new(v15 + 1);
          __b[1].__locale_ = (std::locale::__imp *)v13;
          __b[2].__locale_ = (std::locale::__imp *)(v16 | 0x8000000000000000);
          __b[0].__locale_ = v14;
        }
        else
        {
          HIBYTE(__b[2].__locale_) = v13;
          uint64_t v14 = (std::locale::__imp *)__b;
        }
        memset(v14, v7, v13);
        *((unsigned char *)v14 + v13) = 0;
        if (SHIBYTE(__b[2].__locale_) >= 0) {
          locale = __b;
        }
        else {
          locale = __b[0].__locale_;
        }
        uint64_t v18 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v5 + 96))(v5, locale, v13);
        uint64_t v19 = v18;
        if (SHIBYTE(__b[2].__locale_) < 0)
        {
          operator delete(__b[0].__locale_);
          if (v19 != v13) {
            goto LABEL_34;
          }
        }
        else if (v18 != v13)
        {
          goto LABEL_34;
        }
      }
      uint64_t v20 = a2 + 1 - v8;
      if (v20 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5 + 96))(v5, v8, v20) == v20)
      {
        *((void *)v4 + 3) = 0;
        goto LABEL_35;
      }
    }
LABEL_34:
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
  }
LABEL_35:
  MEMORY[0x1E4E81770](v22);
  return a1;
}

void sub_1E4561384(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  MEMORY[0x1E4E81770](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v17 + *(void *)(*v17 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x1E4561358);
}

void sub_1E45613F0(_Unwind_Exception *a1)
{
}

uint64_t ETLRouterSequenceGetLast(uint64_t a1)
{
  do
  {
    uint64_t v1 = a1;
    a1 = *(void *)(a1 + 8);
  }
  while (a1);
  return v1;
}

uint64_t ETLRouterCreateRouterSequenceCommand(uint64_t a1, uint64_t a2)
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v4, v5, v6, v7, v8, v9, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v10, v11, v12, v13, v14, v15, v33);
    return 0;
  }
  if (*(_DWORD *)a2) {
    return 0;
  }
  uint64_t v17 = *(int **)(a2 + 8);
  if (!v17) {
    return 1;
  }
  while (2)
  {
    if (HDLCFrameGetFreeSpace() <= 2)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v18, v19, v20, v21, v22, v23, 3);
      uint64_t result = 0;
      int v24 = *v17;
      unsigned int v25 = *v17 - 2;
      if (v25 > 3)
      {
LABEL_19:
        if (v24 != 255) {
          return 0;
        }
        if (!result) {
          return result;
        }
        uint64_t result = HDLCFrameInjectUnsignedShort();
        if (!result) {
          return result;
        }
        if (HDLCFrameGetFreeSpace() <= 3) {
          goto LABEL_43;
        }
        uint64_t result = HDLCFrameInjectUnsignedChar();
        if (!result) {
          return result;
        }
        uint64_t result = HDLCFrameInjectUnsignedChar();
        if (!result) {
          return result;
        }
LABEL_29:
        uint64_t result = HDLCFrameInjectUnsignedShort();
        goto LABEL_30;
      }
    }
    else
    {
      uint64_t result = HDLCFrameInjectUnsignedChar();
      int v24 = *v17;
      unsigned int v25 = *v17 - 2;
    }
    switch(v25)
    {
      case 0u:
      case 2u:
        if (!result) {
          return result;
        }
        uint64_t result = HDLCFrameInjectUnsignedShort();
        if (!result) {
          return result;
        }
        if (HDLCFrameGetFreeSpace() <= 3) {
          goto LABEL_43;
        }
        uint64_t result = HDLCFrameInjectUnsignedShort();
        if (result) {
          goto LABEL_29;
        }
        return result;
      case 1u:
        if (!result) {
          return result;
        }
        uint64_t result = HDLCFrameInjectUnsignedShort();
        if (!result) {
          return result;
        }
        if (HDLCFrameGetFreeSpace() > 1) {
          goto LABEL_29;
        }
        uint64_t v32 = 2;
        goto LABEL_45;
      case 3u:
        if (v17[4])
        {
          if (!result) {
            return result;
          }
          uint64_t result = HDLCFrameInjectUnsignedShort();
          if (!result) {
            return result;
          }
          if (HDLCFrameGetFreeSpace() <= 3)
          {
LABEL_43:
            uint64_t v32 = 4;
            goto LABEL_45;
          }
          uint64_t result = HDLCFrameInjectUnsignedInt();
LABEL_30:
          uint64_t v17 = (int *)*((void *)v17 + 1);
          if (!v17 || (result & 1) == 0) {
            return result;
          }
          continue;
        }
        if (!result) {
          return result;
        }
        uint64_t result = HDLCFrameInjectUnsignedShort();
        if (!result) {
          return result;
        }
        if (HDLCFrameGetFreeSpace())
        {
          uint64_t result = HDLCFrameInjectUnsignedChar();
          goto LABEL_30;
        }
        uint64_t v32 = 1;
LABEL_45:
        _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v26, v27, v28, v29, v30, v31, v32);
        return 0;
      default:
        goto LABEL_19;
    }
  }
}

uint64_t ETLRouterParseRouterSequenceResponse(int **a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = *((_DWORD *)a1 + 2);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_11:
    BOOL v13 = 0;
    *a2 = 1;
    return v13;
  }
  uint64_t v10 = *a1;
  unsigned int v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
    goto LABEL_11;
  }
  if (BYTE1(v11) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
    goto LABEL_11;
  }
  uint64_t v12 = HIWORD(v11);
  if (v12 != 49)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
    goto LABEL_11;
  }
  if (v9 == 4) {
    return 1;
  }
  if (*((unsigned __int8 *)v10 + 4) == 255)
  {
    BOOL v13 = v9 - 11 < 0xFFFFFFFC;
    uint64_t v15 = *((unsigned __int8 *)v10 + 7);
    __memcpy_chk();
    *a2 = 0;
    _ETLDebugPrint((uint64_t)"ETLRouterParseVersionPayload", (uint64_t)"Got version %u.%u.%u, notes '%s'\n", v16, v17, v18, v19, v20, v21, v15);
  }
  else
  {
    *a2 = 0;
    return 1;
  }
  return v13;
}

uint64_t ETLRouterSendRouterSequence(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, int a3, _DWORD *a4, uint64_t a5)
{
  memset(v24, 0, sizeof(v24));
  uint64_t v25 = 0;
  memset(v22, 0, sizeof(v22));
  uint64_t v23 = 0;
  *a4 = 1;
  if (HDLCFrameCreateUplink()
    && ETLRouterCreateRouterSequenceCommand((uint64_t)v24, a2)
    && (uint64_t v10 = malloc((2 * DWORD2(v24[0]) + 32))) != 0)
  {
    unsigned int v11 = v10;
    uint64_t v12 = HDLCFrameEncode();
    if (v12)
    {
      int v13 = -1431655766;
      int v26 = -1431655766;
      if ((_ETLDebugFlags & 2) != 0) {
        ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v11, v12);
      }
      if (*a1)
      {
        unsigned int v14 = (*a1)(a1, v11, v12, &v26, 1, a5, 0);
        int v13 = v26;
      }
      else
      {
        unsigned int v14 = 0;
      }
      if (v13 == v12) {
        uint64_t v12 = v14;
      }
      else {
        uint64_t v12 = 0;
      }
    }
    free(v11);
    if (!a3) {
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v12 = 0;
    if (!a3)
    {
LABEL_21:
      *a4 = 0;
      goto LABEL_22;
    }
  }
  if (v12)
  {
    LOBYTE(v26) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    uint64_t v12 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v22, (uint64_t)&_ETLResponseRingBuffer, &v26, a5)&& v26 == 75)
    {
      uint64_t v12 = ETLRouterParseRouterSequenceResponse((int **)v22, a4, v15, v16, v17, v18, v19, v20);
    }
  }
LABEL_22:
  HDLCFrameFree();
  HDLCFrameFree();
  return v12;
}

unint64_t ETLRouterGetVersion(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), unsigned __int8 *a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  v34[0] = 0;
  v34[1] = 0;
  unsigned int v8 = *(_DWORD *)a2;
  v33[1] = 0;
  v33[0] = 255;
  void v33[2] = v8;
  unsigned int v9 = v34;
  do
  {
    uint64_t v10 = v9;
    unsigned int v9 = (void *)v9[1];
  }
  while (v9);
  v10[1] = v33;
  long long v35 = 0u;
  long long v36 = 0u;
  uint64_t v37 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  uint64_t v41 = 0;
  *a3 = 1;
  if (!HDLCFrameCreateUplink()
    || !ETLRouterCreateRouterSequenceCommand((uint64_t)&v35, (uint64_t)v34))
  {
    goto LABEL_13;
  }
  unint64_t v11 = (unint64_t)malloc((2 * DWORD2(v35) + 32));
  if (!v11)
  {
    *a3 = 0;
    HDLCFrameFree();
    HDLCFrameFree();
    return v11;
  }
  uint64_t v12 = HDLCFrameEncode();
  if (!v12)
  {
    free((void *)v11);
LABEL_13:
    *a3 = 0;
    HDLCFrameFree();
    HDLCFrameFree();
    return 0;
  }
  uint64_t v13 = v12;
  int v14 = -1431655766;
  int v38 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, unint64_t, uint64_t))*(&gDelegate + 1))("", 0, v11, v12);
  }
  if (*a1)
  {
    int v15 = (*a1)(a1, (void *)v11, v13, &v38, 1, a4, 0);
    int v14 = v38;
  }
  else
  {
    int v15 = 0;
  }
  free((void *)v11);
  *a3 = 0;
  HDLCFrameFree();
  HDLCFrameFree();
  unint64_t v11 = 0;
  if (v15 && v14 == v13)
  {
    uint64_t v37 = 0;
    long long v35 = 0u;
    long long v36 = 0u;
    LOBYTE(v39) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    unint64_t v11 = 0;
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)&v35, (uint64_t)&_ETLResponseRingBuffer, &v39, a4)|| v39 != 75)
    {
      goto LABEL_34;
    }
    int v23 = DWORD2(v35);
    if (DWORD2(v35) < 4)
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v17, v18, v19, v20, v21, v22, DWORD2(v35));
    }
    else
    {
      uint64_t v24 = v35;
      unsigned int v25 = *(_DWORD *)v35;
      if (*(_DWORD *)v35 == 75)
      {
        if (BYTE1(v25) == 253)
        {
          uint64_t v26 = HIWORD(v25);
          if (v26 == 49)
          {
            *a3 = 1;
            if (v23 != 4 && *(unsigned __int8 *)(v24 + 4) == 255)
            {
              unint64_t v11 = (v23 - 11) < 0xFFFFFFFC;
              long long v39 = 0u;
              long long v40 = 0u;
              *a2 = *(unsigned char *)(v24 + 7);
              a2[1] = *(unsigned char *)(v24 + 8);
              *((_WORD *)a2 + 1) = *(_WORD *)(v24 + 9);
              __memcpy_chk();
              *a3 = 0;
              _ETLDebugPrint((uint64_t)"ETLRouterParseVersionPayload", (uint64_t)"Got version %u.%u.%u, notes '%s'\n", v27, v28, v29, v30, v31, v32, *a2);
            }
            else
            {
              unint64_t v11 = 0;
            }
            goto LABEL_34;
          }
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v17, v18, v19, v20, v21, v22, v26);
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v17, v18, v19, v20, v21, v22, BYTE1(v25));
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v17, v18, v19, v20, v21, v22, *(_DWORD *)v35);
      }
    }
    unint64_t v11 = 0;
    *a3 = 1;
LABEL_34:
    HDLCFrameFree();
  }
  return v11;
}

double ETLDebugSetDefaults()
{
  double result = *(double *)&gDelegateDefault;
  gDelegate = gDelegateDefault;
  _ETLDebugFlags = 3;
  return result;
}

uint64_t ETLDebugSetFlags(uint64_t result)
{
  _ETLDebugFlags = result;
  return result;
}

uint64_t ETLDebugAddFlags(uint64_t result)
{
  _ETLDebugFlags |= result;
  return result;
}

uint64_t ETLDebugRemoveFlags(unsigned int a1)
{
  uint64_t v1 = _ETLDebugFlags & a1;
  _ETLDebugFlags &= ~a1;
  return v1;
}

uint64_t _ETLDebugPrint(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (_ETLDebugFlags) {
    return gDelegate(result, a2, &a9);
  }
  return result;
}

uint64_t _ETLDebugPrintBinary(uint64_t a1, int a2)
{
  if (a2 == 3 || (_ETLDebugFlags & 2) != 0) {
    return ((uint64_t (*)(void))*(&gDelegate + 1))();
  }
  return result;
}

uint64_t APPLIB_DIAG_SEND_SMS(_OWORD *a1, int a2, unsigned int a3, int a4, uint64_t a5)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)((char *)a1 + 204) = 0u;
  a1[11] = 0u;
  a1[12] = 0u;
  a1[9] = 0u;
  a1[10] = 0u;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  *(_DWORD *)a1 = 130123;
  *((unsigned char *)a1 + 4) = a2;
  if (a2 >= 1)
  {
    unint64_t v7 = a2 + 1;
    do
    {
      *((unsigned char *)a1 + (v7-- - 2) + 5) = a3 % 0xA;
      a3 /= 0xAu;
    }
    while (v7 > 1);
  }
  *((unsigned char *)a1 + 20) = a4;
  if (a4 >= 1)
  {
    if (a4 < 8 || (unint64_t)a1 - a5 + 21 < 0x20)
    {
      uint64_t v8 = 0;
      goto LABEL_8;
    }
    if (a4 >= 0x20)
    {
      uint64_t v8 = a4 & 0xFFFFFFE0;
      uint64_t v24 = (long long *)(a5 + 16);
      unsigned int v25 = (_OWORD *)((char *)a1 + 37);
      uint64_t v26 = v8;
      do
      {
        long long v27 = *v24;
        *(v25 - 1) = *(v24 - 1);
        *unsigned int v25 = v27;
        v24 += 2;
        v25 += 2;
        v26 -= 32;
      }
      while (v26);
      if (v8 == a4) {
        goto LABEL_10;
      }
      if ((a4 & 0x18) == 0)
      {
LABEL_8:
        uint64_t v9 = a4 - v8;
        uint64_t v10 = (char *)a1 + v8 + 21;
        unint64_t v11 = (char *)(a5 + v8);
        do
        {
          char v12 = *v11++;
          *v10++ = v12;
          --v9;
        }
        while (v9);
        goto LABEL_10;
      }
    }
    else
    {
      uint64_t v8 = 0;
    }
    uint64_t v28 = v8;
    uint64_t v8 = a4 & 0xFFFFFFF8;
    uint64_t v29 = (uint64_t *)(a5 + v28);
    uint64_t v30 = (void *)((char *)a1 + v28 + 21);
    uint64_t v31 = v28 - v8;
    do
    {
      uint64_t v32 = *v29++;
      *v30++ = v32;
      v31 += 8;
    }
    while (v31);
    if (v8 != a4) {
      goto LABEL_8;
    }
  }
LABEL_10:
  uint64_t v13 = a4 + 21;
  int v14 = 8 * v13;
  if (((8 * v13) & 0xFFF8) != 0)
  {
    LOWORD(v15) = -1;
    uint64_t v16 = (char *)a1;
    do
    {
      char v17 = *v16++;
      int v15 = crc_16_l_table[(v17 ^ v15)] ^ ((unsigned __int16)(v15 & 0xFF00) >> 8);
      v14 -= 8;
    }
    while ((_WORD)v14);
    *((unsigned char *)a1 + v13) = ~(_BYTE)v15;
    *((unsigned char *)a1 + a4 + 22) = (unsigned __int16)~(_WORD)v15 >> 8;
    if (a4 > 233) {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    *((unsigned char *)a1 + v13) = 0;
    *((unsigned char *)a1 + a4 + 22) = 0;
    if (a4 > 233) {
      return 0xFFFFFFFFLL;
    }
  }
  bzero(__src, 0x800uLL);
  if (a4 < -22)
  {
    int v19 = 0;
  }
  else
  {
    int v19 = 0;
    uint64_t v20 = (a4 + 23);
    uint64_t v21 = (unsigned __int8 *)a1;
    do
    {
      int v23 = *v21++;
      char v22 = v23;
      if ((v23 - 125) <= 1)
      {
        __src[v19] = 125;
        v22 ^= 0x20u;
        ++v19;
      }
      __src[v19++] = v22;
      --v20;
    }
    while (v20);
  }
  memcpy(a1, __src, v19);
  uint64_t result = (v19 + 1);
  *((unsigned char *)a1 + v19) = 126;
  return result;
}

uint64_t APPLIB_DIAG_ENABLE_MT_SMS_STORE(unsigned char *a1, unsigned __int8 a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)a1 = 195659;
  int v3 = a2;
  a1[4] = a2;
  __int16 v4 = crc_16_l_table[a2 ^ 0xA4] ^ 0xFF30;
  int v5 = crc_16_l_table[a2 ^ 0xA4] ^ 0x30;
  a1[5] = crc_16_l_table[a2 ^ 0xA4] ^ 0x30;
  int v6 = HIBYTE(v4);
  a1[6] = HIBYTE(v4);
  bzero(v12, 0x7FCuLL);
  int __src = 195659;
  if ((v3 - 125) > 1)
  {
    int v7 = 4;
    v12[0] = v3;
    uint64_t v8 = 5;
    if ((v5 - 125) > 1) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  v12[0] = 125;
  int v7 = 5;
  v12[1] = v3 ^ 0x20;
  uint64_t v8 = 6;
  if ((v5 - 125) <= 1)
  {
LABEL_5:
    v12[v8 - 4] = 125;
    LODWORD(v8) = v7 | 2;
    LOBYTE(v5) = v5 ^ 0x20;
  }
LABEL_6:
  v12[v8 - 4] = v5;
  uint64_t v9 = v8 + 1;
  if ((v6 - 125) <= 1)
  {
    v12[v9 - 4] = 125;
    LOBYTE(v6) = v6 ^ 0x20;
    LODWORD(v9) = v8 + 2;
  }
  v12[v9 - 4] = v6;
  memcpy(a1, &__src, v9 + 1);
  a1[v9 + 1] = 126;
  return (v9 + 2);
}

uint64_t APPLIB_DIAG_RECV_MT_SMS(uint64_t a1)
{
  *(_DWORD *)a1 = 261195;
  *(_WORD *)(a1 + 4) = 10627;
  *(unsigned char *)(a1 + 6) = 126;
  return 7;
}

uint64_t ETLMaverickAddDataCommandHeader()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLMaverickParseDataResponseHeader(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a2;
  uint64_t v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    unsigned int v10 = *(_DWORD *)(*(void *)a1 + v8);
    if (v10 == 75)
    {
      *a2 = v8 + 4;
      if (BYTE1(v10) == 100)
      {
        if (HIWORD(v10) == a3)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, HIWORD(v10));
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
      return 0;
    }
  }
}

uint64_t ETLMaverickAddBSPCommandHeader()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLMaverickParseBSPResponseHeader(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a2;
  uint64_t v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    unsigned int v10 = *(_DWORD *)(*(void *)a1 + v8);
    if (v10 == 75)
    {
      *a2 = v8 + 4;
      if (BYTE1(v10) == 253)
      {
        if (HIWORD(v10) == a3)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, HIWORD(v10));
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
      return 0;
    }
  }
}

uint64_t ETLMaverickAddBSPExtCommandGetHeader()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
LABEL_7:
    _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandGetHeader", (uint64_t)"Failed on creating BSP Command Heder\n", v20, v21, v22, v23, v24, v25, v27);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v26);
    goto LABEL_7;
  }
  if (HDLCFrameGetFreeSpace())
  {
    HDLCFrameInjectUnsignedChar();
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandGetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v13, v14, v15, v16, v17, v18, 2);
    return 0;
  }
}

uint64_t ETLMaverickAddBSPExtCommandSetHeader()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
LABEL_7:
    _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandSetHeader", (uint64_t)"Failed on creating BSP Command Heder\n", v20, v21, v22, v23, v24, v25, v27);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v26);
    goto LABEL_7;
  }
  if (HDLCFrameGetFreeSpace() > 1)
  {
    HDLCFrameInjectUnsignedChar();
    HDLCFrameInjectUnsignedChar();
    return 1;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandSetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v13, v14, v15, v16, v17, v18, 2);
  return 0;
}

uint64_t ETLMaverickAddRFCommandHeader()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLMaverickParseRFResponseHeader(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a2;
  uint64_t v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    unsigned int v10 = *(_DWORD *)(*(void *)a1 + v8);
    if (v10 == 75)
    {
      *a2 = v8 + 4;
      if (BYTE1(v10) == 251)
      {
        if (HIWORD(v10) == a3)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, HIWORD(v10));
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
      return 0;
    }
  }
}

uint64_t ETLMaverickAddFACTORYCommandHeader()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLMaverickParseFACTORYResponseHeader(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a2;
  uint64_t v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    unsigned int v10 = *(_DWORD *)(*(void *)a1 + v8);
    if (v10 == 75)
    {
      *a2 = v8 + 4;
      if (BYTE1(v10) == 254)
      {
        if (HIWORD(v10) == a3)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, HIWORD(v10));
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
      return 0;
    }
  }
}

uint64_t ETLMaverickAddCDMACommandHeader()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLMaverickParseCDMAResponseHeader(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a2;
  uint64_t v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    unsigned int v10 = *(_DWORD *)(*(void *)a1 + v8);
    if (v10 == 75)
    {
      *a2 = v8 + 4;
      if (BYTE1(v10) == 252)
      {
        if (HIWORD(v10) == a3)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, HIWORD(v10));
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateAPWakeCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickCreateAPWakeCommand", (uint64_t)"Not enough room, need %zu, have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      HDLCFrameInjectUnsignedShort();
      return 1;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickParseAPWakeResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a1[2];
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    unsigned int v9 = **(_DWORD **)a1;
    if (v9 == 75)
    {
      if (BYTE1(v9) == 253)
      {
        uint64_t v10 = HIWORD(v9);
        if (v10 == 13)
        {
          if (v8 - 4 <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseAPWakeResponse", (uint64_t)"response requires %u bytes, got %u\n", a3, a4, a5, a6, a7, a8, 2);
            return 0;
          }
          else if (*(_WORD *)(*(void *)a1 + 4))
          {
            return 1;
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseAPWakeResponse", (uint64_t)"Status was %u\n", a3, a4, a5, a6, a7, a8, 0);
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v9));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateTxModeSwitchCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickCreateTxModeSwitchCommand", (uint64_t)"Not enough room, need %zu, have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      HDLCFrameInjectUnsignedShort();
      return 1;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickParseTxModeSwitchResponse(int **a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  unsigned int v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_15:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseTxModeSwitchResponse", (uint64_t)"Failed to parse BSP header from response\n", v16, v17, v18, v19, v20, v21, v22);
    return 0;
  }
  uint64_t v10 = *a1;
  unsigned int v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
    goto LABEL_15;
  }
  if (BYTE1(v11) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
    goto LABEL_15;
  }
  uint64_t v12 = HIWORD(v11);
  if (v12 != 6)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
    goto LABEL_15;
  }
  if (v9 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseTxModeSwitchResponse", (uint64_t)"response requires %u bytes, got %u\n", a3, a4, a5, a6, a7, a8, 4);
    return 0;
  }
  else if (*((_WORD *)v10 + 2) == 1)
  {
    uint64_t v13 = *((unsigned __int16 *)v10 + 3);
    int v14 = a2 - 3;
    if (a2 <= 2) {
      int v14 = a2;
    }
    if (v13 == v14)
    {
      return 1;
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickParseTxModeSwitchResponse", (uint64_t)"Mode doesn't match %u, expected %u\n", a3, a4, a5, a6, a7, a8, v13);
      return 0;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseTxModeSwitchResponse", (uint64_t)"Status was %u\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v10 + 2));
    return 0;
  }
}

uint64_t ETLMaverickAddRSSICommandHeader()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      HDLCFrameInjectUnsignedShort();
      return 1;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickCreateStartRSSICommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v14 = "ETLSubsysAddHeaderInternal";
    uint64_t v15 = "Failed to inject\n";
LABEL_13:
    _ETLDebugPrint((uint64_t)v14, (uint64_t)v15, v7, v8, v9, v10, v11, v12, v17);
    return 0;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v16 = 2;
LABEL_12:
    uint64_t v17 = v16;
    uint64_t v14 = "ETLRequireFreeSpace";
    uint64_t v15 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_13;
  }
  HDLCFrameInjectUnsignedShort();
  if (HDLCFrameGetFreeSpace() <= 5)
  {
    uint64_t v16 = 6;
    goto LABEL_12;
  }
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();

  return HDLCFrameInjectUnsignedShort();
}

uint64_t ETLMaverickCreateStopRSSICommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v21);
    return 0;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v20 = 2;
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, v20);
    return 0;
  }
  HDLCFrameInjectUnsignedShort();
  if (HDLCFrameGetFreeSpace() <= 5)
  {
    uint64_t v20 = 6;
    goto LABEL_12;
  }
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();

  return HDLCFrameInjectUnsignedShort();
}

uint64_t ETLMaverickCreateReportRSSICommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v21);
    return 0;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v20 = 2;
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, v20);
    return 0;
  }
  HDLCFrameInjectUnsignedShort();
  if (HDLCFrameGetFreeSpace() <= 5)
  {
    uint64_t v20 = 6;
    goto LABEL_12;
  }
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();

  return HDLCFrameInjectUnsignedShort();
}

uint64_t ETLMaverickParseRSSICommandResponse(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a2;
  uint64_t v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    unsigned int v10 = *(_DWORD *)(*(void *)a1 + v8);
    if (v10 == 75)
    {
      unsigned int v11 = v8 + 4;
      *a2 = v11;
      if (BYTE1(v10) == 253)
      {
        uint64_t v12 = HIWORD(v10);
        if (v12 == 15)
        {
          uint64_t v13 = *(_DWORD *)(a1 + 8) - v11;
          if (v13 <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseRSSICommandResponse", (uint64_t)"Only have %u bytes, need %u\n", a3, a4, a5, a6, a7, a8, v13);
            return 0;
          }
          else
          {
            uint64_t v14 = *(unsigned __int16 *)(*(void *)a1 + v11);
            if (v14 == a3)
            {
              return 1;
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseRSSICommandResponse", (uint64_t)"Returned subcommand 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, v14);
              return 0;
            }
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
      return 0;
    }
  }
}

uint64_t ETLMaverickParseStartRSSIResponse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = 0;
  return ETLMaverickParseRSSICommandResponse(a1, &v9, 1, a4, a5, a6, a7, a8);
}

uint64_t ETLMaverickParseStopRSSIResponse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = 0;
  return ETLMaverickParseRSSICommandResponse(a1, &v9, 1, a4, a5, a6, a7, a8);
}

uint64_t ETLMaverickCreateGetTxPowerExtCommand(capabilities::etl *a1, unsigned int a2)
{
  int v3 = capabilities::etl::maverickTxPowerUsesRFSubsys(a1);
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (!v3)
  {
    if (FreeSpace >= 4)
    {
      if (!HDLCFrameInject()) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
LABEL_10:
    uint64_t v19 = FreeSpace;
    unsigned int v11 = "Free space %u not enough for %zu\n";
    goto LABEL_11;
  }
  if (FreeSpace < 4) {
    goto LABEL_10;
  }
  if (!HDLCFrameInject())
  {
LABEL_4:
    unsigned int v11 = "Failed to inject\n";
LABEL_11:
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)v11, v5, v6, v7, v8, v9, v10, v19);
    return 0;
  }
LABEL_7:
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickCreateGetTxPowerExtCommand", (uint64_t)"Not enough room, need %zu, have %u\n", v12, v13, v14, v15, v16, v17, 2);
    return 0;
  }
  if (a2 > 7) {
    return 0;
  }
  HDLCFrameInjectUnsignedShort();
  return 1;
}

uint64_t ETLMaverickParseGetTxPowerExtResponse(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  int v5 = capabilities::etl::maverickTxPowerUsesRFSubsys((capabilities::etl *)a1);
  unsigned int v12 = a1[2];
  if (v5)
  {
    if (v12 >= 4)
    {
      uint64_t v13 = *(unsigned int **)a1;
      unsigned int v14 = **(_DWORD **)a1;
      uint64_t v15 = v14;
      if (v14 == 75)
      {
        uint64_t v16 = BYTE1(v14);
        if (BYTE1(v14) == 251)
        {
          uint64_t v17 = HIWORD(v14);
          if (v17 != 16) {
            goto LABEL_17;
          }
          goto LABEL_11;
        }
LABEL_16:
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v6, v7, v8, v9, v10, v11, v16);
        return 0;
      }
LABEL_15:
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v6, v7, v8, v9, v10, v11, v15);
      return 0;
    }
LABEL_14:
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v6, v7, v8, v9, v10, v11, a1[2]);
    return 0;
  }
  if (v12 < 4) {
    goto LABEL_14;
  }
  uint64_t v13 = *(unsigned int **)a1;
  unsigned int v18 = **(_DWORD **)a1;
  uint64_t v15 = v18;
  if (v18 != 75) {
    goto LABEL_15;
  }
  uint64_t v16 = BYTE1(v18);
  if (BYTE1(v18) != 253) {
    goto LABEL_16;
  }
  uint64_t v17 = HIWORD(v18);
  if (v17 != 8)
  {
LABEL_17:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v6, v7, v8, v9, v10, v11, v17);
    return 0;
  }
LABEL_11:
  if (v12 - 4 <= 9)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetTxPowerExtResponse", (uint64_t)"response requires %u bytes, got %u\n", v6, v7, v8, v9, v10, v11, 10);
    return 0;
  }
  else if (*((_WORD *)v13 + 2))
  {
    *(_WORD *)a3 = *((_WORD *)v13 + 3);
    *(_WORD *)(a3 + 2) = *((_WORD *)v13 + 4);
    *(_WORD *)(a3 + 4) = *((_WORD *)v13 + 5);
    *(_WORD *)(a3 + 6) = *((_WORD *)v13 + 6);
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetTxPowerExtResponse", (uint64_t)"Status was %u\n", v6, v7, v8, v9, v10, v11, 0);
    return 0;
  }
}

uint64_t ETLMaverickCreateGetTxPowerCapCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickCreateGetTxPowerCapCommand", (uint64_t)"Not enough room, need %zu, have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      HDLCFrameInjectUnsignedShort();
      return 1;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickParseGetTxPowerCapResponse(int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_WORD *)(a2 + 4) = 0;
  *(_DWORD *)a2 = 0;
  unsigned int v8 = *((_DWORD *)a1 + 2);
  unsigned int v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 253)
      {
        uint64_t v12 = HIWORD(v11);
        if (v12 == 23)
        {
          if (v9 <= 7)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseGetTxPowerCapResponse", (uint64_t)"response requires %u bytes, got %u\n", a3, a4, a5, a6, a7, a8, 8);
            return 0;
          }
          else if (v10[2])
          {
            *(_WORD *)a2 = v10[3];
            *(_WORD *)(a2 + 2) = v10[4];
            *(_WORD *)(a2 + 4) = v10[5];
            return 1;
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseGetTxPowerCapResponse", (uint64_t)"Status was %u\n", a3, a4, a5, a6, a7, a8, 0);
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateGetMaxTxPowerCommand(capabilities::etl *a1)
{
  int v1 = capabilities::etl::maverickTxPowerUsesRFSubsys(a1);
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (v1)
  {
    if (FreeSpace >= 4)
    {
      uint64_t v15 = HDLCFrameInject();
      if (v15) {
        return v15;
      }
      goto LABEL_7;
    }
  }
  else if (FreeSpace >= 4)
  {
    uint64_t v15 = HDLCFrameInject();
    if (v15) {
      return v15;
    }
LABEL_7:
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v9, v10, v11, v12, v13, v14, v17);
    return v15;
  }
  _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v3, v4, v5, v6, v7, v8, FreeSpace);
  return 0;
}

uint64_t ETLMaverickParseGetMaxTxPowerResponse(capabilities::etl *a1, _WORD *a2, _WORD *a3)
{
  uint64_t v6 = (capabilities::etl *)capabilities::etl::maverickTxPowerUsesRFSubsys(a1);
  unsigned int v13 = *((_DWORD *)a1 + 2);
  if (v6)
  {
    if (v13 >= 4)
    {
      uint64_t v14 = *(unsigned int **)a1;
      unsigned int v15 = *v14;
      uint64_t v16 = *v14;
      if (v16 == 75)
      {
        uint64_t v17 = BYTE1(v15);
        if (BYTE1(v15) == 251)
        {
          uint64_t v18 = HIWORD(v15);
          if (v18 != 20) {
            goto LABEL_20;
          }
          goto LABEL_11;
        }
        goto LABEL_19;
      }
      goto LABEL_18;
    }
LABEL_17:
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v7, v8, v9, v10, v11, v12, *((unsigned int *)a1 + 2));
    return 0;
  }
  if (v13 < 4) {
    goto LABEL_17;
  }
  uint64_t v14 = *(unsigned int **)a1;
  unsigned int v19 = *v14;
  uint64_t v16 = *v14;
  if (v16 != 75)
  {
LABEL_18:
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v7, v8, v9, v10, v11, v12, v16);
    return 0;
  }
  uint64_t v17 = BYTE1(v19);
  if (BYTE1(v19) != 253)
  {
LABEL_19:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v7, v8, v9, v10, v11, v12, v17);
    return 0;
  }
  uint64_t v18 = HIWORD(v19);
  if (v18 != 39)
  {
LABEL_20:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v7, v8, v9, v10, v11, v12, v18);
    return 0;
  }
LABEL_11:
  unsigned int v20 = v13 - 4;
  if (capabilities::etl::maverickTxPowerUsesRFSubsys(v6))
  {
    if (v20 > 5)
    {
      if (*((_WORD *)v14 + 2))
      {
        uint64_t result = 0;
        if (a2 && a3)
        {
          *a3 = *((_WORD *)v14 + 3);
          *a2 = *((_WORD *)v14 + 4);
          return 1;
        }
        return result;
      }
LABEL_28:
      _ETLDebugPrint((uint64_t)"ETLMaverickParseGetMaxTxPowerResponse", (uint64_t)"Status was %u\n", v21, v22, v23, v24, v25, v26, 0);
      return 0;
    }
LABEL_27:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetMaxTxPowerResponse", (uint64_t)"response requires %u bytes, got %u\n", v21, v22, v23, v24, v25, v26, 6);
    return 0;
  }
  if (v20 <= 5) {
    goto LABEL_27;
  }
  if (!*((_WORD *)v14 + 2)) {
    goto LABEL_28;
  }
  uint64_t result = 0;
  if (a2 && a3)
  {
    *a2 = *((_WORD *)v14 + 3);
    *a3 = *((_WORD *)v14 + 4);
    return 1;
  }
  return result;
}

uint64_t ETLMaverickCreateSetAutoAnswerCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
  }
  else
  {
    if (HDLCFrameInject())
    {
      if (HDLCFrameGetFreeSpace() > 1)
      {
        HDLCFrameInjectUnsignedChar();
        HDLCFrameInjectUnsignedChar();
        return 1;
      }
      uint64_t v16 = 2;
      uint64_t v14 = "ETLMaverickCreateSetAutoAnswerCommand";
      unsigned int v15 = "Not enough room, need %zu, have %u\n";
    }
    else
    {
      uint64_t v14 = "ETLSubsysAddHeaderInternal";
      unsigned int v15 = "Failed to inject\n";
    }
    _ETLDebugPrint((uint64_t)v14, (uint64_t)v15, v7, v8, v9, v10, v11, v12, v16);
  }
  return 0;
}

BOOL ETLMaverickParseSetAutoAnswerResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a1[2];
  uint64_t v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    unsigned int v10 = **(_DWORD **)a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 253)
      {
        uint64_t v11 = HIWORD(v10);
        if (v11 == 40)
        {
          if (v9 <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSetAutoAnswerResponse", (uint64_t)"Received response has only %u bytes, need %u\n", a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else
          {
            return *(_WORD *)(*(void *)a1 + 4) != 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateWriteDefaultNVsCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLMaverickParseWriteDefaultNVsResponse(unsigned int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((_DWORD *)a1 + 2) < 4u)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    unsigned int v8 = **a1;
    if (v8 == 75)
    {
      if (BYTE1(v8) == 253)
      {
        uint64_t v9 = HIWORD(v8);
        if (v9 == 25)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v9);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v8));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateWriteFactoryDefaultNVsCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLMaverickParseWriteFactoryDefaultNVsResponse(unsigned int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((_DWORD *)a1 + 2) < 4u)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    unsigned int v8 = **a1;
    if (v8 == 75)
    {
      if (BYTE1(v8) == 254)
      {
        uint64_t v9 = HIWORD(v8);
        if (v9 == 27)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v9);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v8));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateWriteFactoryFATPDefaultNVsCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLMaverickParseWriteFactoryFATPDefaultNVsResponse(unsigned int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((_DWORD *)a1 + 2) < 4u)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    unsigned int v8 = **a1;
    if (v8 == 75)
    {
      if (BYTE1(v8) == 254)
      {
        uint64_t v9 = HIWORD(v8);
        if (v9 == 39)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v9);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v8));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateIsSimPresentCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLMaverickParseIsSimPresentResponse(int **a1, BOOL *a2, BOOL *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  unsigned int v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseIsSimPresentResponse", (uint64_t)"failed parsing factory response from frame\n", v14, v15, v16, v17, v18, v19, v21);
    return 0;
  }
  uint64_t v10 = *a1;
  unsigned int v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, **a1);
    goto LABEL_12;
  }
  if (BYTE1(v11) != 254)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v11));
    goto LABEL_12;
  }
  uint64_t v12 = HIWORD(v11);
  if (v12 != 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v12);
    goto LABEL_12;
  }
  if (v9 <= 5)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseIsSimPresentResponse", (uint64_t)"Need %u bytes, but only have %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, 6);
    return 0;
  }
  else if (*((_WORD *)v10 + 2))
  {
    *a3 = *((_WORD *)v10 + 3) != 0;
    *a2 = *((unsigned __int16 *)v10 + 4) != 0;
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseIsSimPresentResponse", (uint64_t)"SIM Command failed\n", (uint64_t)a3, a4, a5, a6, a7, a8, v20);
    return 0;
  }
}

BOOL ETLMaverickParseGetTxAntenna(uint64_t a1, unsigned int *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a3;
  uint64_t v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, v9);
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetTxAntenna", (uint64_t)"failed parsing BSP response from frame\n", v16, v17, v18, v19, v20, v21, v22);
    return 0;
  }
  unsigned int v10 = *(_DWORD *)(*(void *)a1 + v8);
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v10);
    goto LABEL_12;
  }
  unsigned int v11 = v8 + 4;
  *a3 = v8 + 4;
  if (BYTE1(v10) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v10));
    goto LABEL_12;
  }
  uint64_t v12 = HIWORD(v10);
  if (v12 != 24)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v12);
    goto LABEL_12;
  }
  if (*(_DWORD *)(a1 + 8) - v11 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetTxAntenna", (uint64_t)"Need %u bytes, but only have %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, 4);
    return 0;
  }
  else
  {
    uint64_t v13 = (unsigned __int16 *)(*(void *)a1 + v11);
    if (*v13 == 1)
    {
      unsigned int v14 = v13[1];
      BOOL result = v14 < 5;
      *a2 = v14;
      *a3 = v8 + 8;
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickParseGetTxAntenna", (uint64_t)"status = %d\n", (uint64_t)a3, a4, a5, a6, a7, a8, *v13);
      return 0;
    }
  }
  return result;
}

uint64_t ETLMaverickCreateGetGPIOCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickCreateGetGPIOCommand", (uint64_t)"Not enough room, need %zu, have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

BOOL ETLMaverickParseGetGPIOResponse(int **a1, int a2, BOOL *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  unsigned int v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetGPIOResponse", (uint64_t)"failed parsing factory response from frame\n", v15, v16, v17, v18, v19, v20, v22);
    return 0;
  }
  uint64_t v10 = *a1;
  unsigned int v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, **a1);
    goto LABEL_12;
  }
  if (BYTE1(v11) != 254)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v11));
    goto LABEL_12;
  }
  uint64_t v12 = HIWORD(v11);
  if (v12 != 19)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v12);
    goto LABEL_12;
  }
  if (v9 <= 5)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetGPIOResponse", (uint64_t)"Need %u bytes, but only have %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, 6);
    return 0;
  }
  else if (*((_WORD *)v10 + 2))
  {
    int v13 = *((unsigned __int16 *)v10 + 3);
    *a3 = *((unsigned __int16 *)v10 + 4) != 0;
    return v13 == a2;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetGPIOResponse", (uint64_t)"Get GPIO Status Command failed\n", (uint64_t)a3, a4, a5, a6, a7, a8, v21);
    return 0;
  }
}

uint64_t ETLMaverickCreateSetGPIOCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v14 = "ETLSubsysAddHeaderInternal";
    uint64_t v15 = "Failed to inject\n";
LABEL_11:
    _ETLDebugPrint((uint64_t)v14, (uint64_t)v15, v7, v8, v9, v10, v11, v12, v16);
    return 0;
  }
  if (HDLCFrameGetFreeSpace() <= 3)
  {
    uint64_t v16 = 4;
    uint64_t v14 = "ETLMaverickCreateSetGPIOCommand";
    uint64_t v15 = "Not enough room, need %zu, have %u\n";
    goto LABEL_11;
  }
  if (!HDLCFrameInjectUnsignedShort()) {
    return 0;
  }

  return HDLCFrameInjectUnsignedShort();
}

BOOL ETLMaverickParseSetGPIOResponse(int **a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  unsigned int v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSetGPIOResponse", (uint64_t)"failed parsing factory response from frame\n", v14, v15, v16, v17, v18, v19, v21);
    return 0;
  }
  uint64_t v10 = *a1;
  unsigned int v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
    goto LABEL_12;
  }
  if (BYTE1(v11) != 254)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
    goto LABEL_12;
  }
  uint64_t v12 = HIWORD(v11);
  if (v12 != 20)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
    goto LABEL_12;
  }
  if (v9 <= 5)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSetGPIOResponse", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 6);
    return 0;
  }
  else if (*((_WORD *)v10 + 2))
  {
    return *((unsigned __int16 *)v10 + 3) == a2;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSetGPIOResponse", (uint64_t)"Set GPIO State Command failed\n", a3, a4, a5, a6, a7, a8, v20);
    return 0;
  }
}

uint64_t ETLMaverickCreateBackupBoardSNCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

BOOL ETLMaverickParseBackupBoardSNResponse(int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  unsigned int v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 254)
      {
        uint64_t v12 = HIWORD(v11);
        if (v12 == 12)
        {
          if (v9 <= 3)
          {
            _ETLDebugPrint((uint64_t)"ETLCheckPayloadLength", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
            return 0;
          }
          else if (*((_WORD *)v10 + 2) == 20)
          {
            return *((_WORD *)v10 + 3) == 0;
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseBackupBoardSNResponse", (uint64_t)"Backup Board SN response does not match MAV_SEC_BKP_BOARD_SN [%d]. Received [%d]\n", a3, a4, a5, a6, a7, a8, 20);
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateAnntennaSKU(int *a1, unsigned __int8 a2, int a3)
{
  if ((a2 & ((a3 - 1) < 2)) == 1)
  {
    if (a3 == 1) {
      int v3 = 3;
    }
    else {
      int v3 = 4;
    }
    if (a3 == 1) {
      int v4 = 1;
    }
    else {
      int v4 = 2;
    }
    if ((a2 & 2) == 0) {
      int v3 = v4;
    }
    *a1 = v3;
  }
  return a2 & ((a3 - 1) < 2);
}

uint64_t ETLMaverickCreateSetAntennaSKUCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickParseSetAntennaSKUResponse(int **a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  uint64_t v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
  }
  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 253)
      {
        uint64_t v12 = HIWORD(v11);
        if (v12 == 38)
        {
          if (v9 <= 3)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSetAntennaSKUResponse", (uint64_t)"Received response has only %u bytes, need %u\n", a3, a4, a5, a6, a7, a8, v9);
          }
          else if (*((_WORD *)v10 + 2) == 1)
          {
            if (*((unsigned __int16 *)v10 + 3) == a2) {
              return 1;
            }
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSetAntennaSKUResponse", (uint64_t)"Received SKU %u mismatches sent %u\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v10 + 3));
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
    }
  }
  return 0;
}

uint64_t ETLMaverickCreateSetIMEISwVersionCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace())
    {
      return HDLCFrameInjectUnsignedChar();
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 1);
      return 0;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickParseIMEISwVersionResponse(int **a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  uint64_t v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 253)
      {
        uint64_t v12 = HIWORD(v11);
        if (v12 == a3)
        {
          if (v9 <= 2)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseIMEISwVersionResponse", (uint64_t)"Received response has only %u bytes, need %u\n", a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else if (*((_WORD *)v10 + 2) == 1)
          {
            *a2 = *((unsigned char *)v10 + 6);
            return 1;
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseIMEISwVersionResponse", (uint64_t)"Received response with failure status [%d]\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v10 + 2));
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateGetHWConfigIDCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLMaverickParseGetHWConfigIDResponse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)(a1 + 8);
  unsigned int v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a1 + 8));
LABEL_15:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetHWConfigIDResponse", (uint64_t)"failed parsing factory response from frame\n", v13, v14, v15, v16, v17, v18, v20);
    return 0;
  }
  uint64_t v10 = *(unsigned int **)a1;
  unsigned int v11 = **(_DWORD **)a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
    goto LABEL_15;
  }
  if (BYTE1(v11) != 254)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
    goto LABEL_15;
  }
  if (v11 >= 0x10000)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, HIWORD(v11));
    goto LABEL_15;
  }
  if (v9 <= 0x17)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetHWConfigIDResponse", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 24);
    return 0;
  }
  else if (*((_WORD *)v10 + 2))
  {
    if (a2)
    {
      *(_DWORD *)a2 = *(unsigned int *)((char *)v10 + 6);
      *(_WORD *)(a2 + 4) = *((_WORD *)v10 + 5);
      *(_WORD *)(a2 + 6) = *((_WORD *)v10 + 6);
      *(_WORD *)(a2 + 8) = *((_WORD *)v10 + 7);
      *(_WORD *)(a2 + 10) = *((_WORD *)v10 + 8);
      *(_WORD *)(a2 + 12) = *((_WORD *)v10 + 9);
      *(_WORD *)(a2 + 14) = *((_WORD *)v10 + 10);
      if (v9 < 0x1A) {
        *(_WORD *)(a2 + 22) = -1;
      }
      else {
        *(_WORD *)(a2 + 22) = *((_WORD *)v10 + 14);
      }
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetHWConfigIDResponse", (uint64_t)"Get HW Config ID Command failed\n", a3, a4, a5, a6, a7, a8, v19);
    return 0;
  }
}

uint64_t ETLMaverickCreateCalibrationCheckCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLMaverickCreateCalibrationCheckCommandV2()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLMaverickParseCalibrationCheckResonse(capabilities::radio *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((_DWORD *)a1 + 2) < 4u)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_14:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseCalibrationCheckResonse", (uint64_t)"Parsing BSP Response Header failed.\n", v19, v20, v21, v22, v23, v24, v25);
    return 0;
  }
  unsigned int v9 = **(_DWORD **)a1;
  if (v9 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
    goto LABEL_14;
  }
  if (BYTE1(v9) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v9));
    goto LABEL_14;
  }
  uint64_t v10 = HIWORD(v9);
  if (v10 != 48)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
    goto LABEL_14;
  }
  if (capabilities::radio::mavLegacy(a1)) {
    size_t v17 = 46;
  }
  else {
    size_t v17 = 4;
  }
  if (*((_DWORD *)a1 + 2) - 4 >= v17)
  {
    memcpy(a2, (const void *)(*(void *)a1 + 4), v17);
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseCalibrationCheckResonse", (uint64_t)"Received response has only %u bytes, need %u\n", v17, v12, v13, v14, v15, v16, (*((_DWORD *)a1 + 2) - 4));
    return 0;
  }
}

uint64_t ETLMaverickParseCalibrationCheckResponseV2(capabilities::radio *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((_DWORD *)a1 + 2) < 4u)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_14:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseCalibrationCheckResponseV2", (uint64_t)"Parsing RF Response Header failed.\n", v18, v19, v20, v21, v22, v23, v24);
    return 0;
  }
  unsigned int v9 = **(_DWORD **)a1;
  if (v9 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
    goto LABEL_14;
  }
  if (BYTE1(v9) != 251)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v9));
    goto LABEL_14;
  }
  if (a3 != HIWORD(v9))
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, HIWORD(v9));
    goto LABEL_14;
  }
  if (capabilities::radio::mavLegacy(a1)) {
    size_t v16 = 46;
  }
  else {
    size_t v16 = 4;
  }
  if (*((_DWORD *)a1 + 2) - 4 >= v16)
  {
    memcpy(a2, (const void *)(*(void *)a1 + 4), v16);
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseCalibrationCheckResponseV2", (uint64_t)"Received response has only %u bytes, need %u\n", v16, v11, v12, v13, v14, v15, (*((_DWORD *)a1 + 2) - 4));
    return 0;
  }
}

uint64_t ETLMaverickStartRSSI(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  long long v30 = 0u;
  long long v31 = 0u;
  uint64_t v32 = 0;
  memset(v28, 0, sizeof(v28));
  uint64_t v29 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickStartRSSI", (uint64_t)"Failed to create command frame\n", v7, v8, v9, v10, v11, v12, *(uint64_t *)&v28[0]);
LABEL_19:
    uint64_t v26 = 0;
    goto LABEL_20;
  }
  if (!ETLMaverickCreateStartRSSICommand()) {
    goto LABEL_19;
  }
  uint64_t v13 = malloc((2 * DWORD2(v30) + 32));
  if (!v13) {
    goto LABEL_19;
  }
  uint64_t v14 = v13;
  uint64_t v15 = HDLCFrameEncode();
  if (!v15) {
    goto LABEL_21;
  }
  uint64_t v16 = v15;
  unsigned int v33 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v14, v15);
  }
  if (!*a1)
  {
LABEL_21:
    free(v14);
    goto LABEL_19;
  }
  int v17 = ((uint64_t (*)(void *, void *, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v14, v16, &v33, 1, a5, 0);
  unsigned int v18 = v33;
  free(v14);
  if (v17) {
    BOOL v19 = v18 == v16;
  }
  else {
    BOOL v19 = 0;
  }
  if (!v19) {
    goto LABEL_19;
  }
  LOBYTE(v33) = 75;
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  int v20 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v28, (uint64_t)&_ETLResponseRingBuffer, &v33, a5);
  uint64_t v26 = 0;
  if (v20 && v33 == 75)
  {
    unsigned int v33 = 0;
    uint64_t v26 = ETLMaverickParseRSSICommandResponse((uint64_t)v28, &v33, 1, v21, v22, v23, v24, v25);
  }
LABEL_20:
  HDLCFrameFree();
  HDLCFrameFree();
  return v26;
}

uint64_t ETLMaverickStopRSSI(void *a1, uint64_t a2)
{
  long long v27 = 0u;
  long long v28 = 0u;
  uint64_t v29 = 0;
  memset(v25, 0, sizeof(v25));
  uint64_t v26 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickStopRSSI", (uint64_t)"Failed to create command frame\n", v4, v5, v6, v7, v8, v9, *(uint64_t *)&v25[0]);
LABEL_19:
    uint64_t v23 = 0;
    goto LABEL_20;
  }
  if (!ETLMaverickCreateStopRSSICommand()) {
    goto LABEL_19;
  }
  uint64_t v10 = malloc((2 * DWORD2(v27) + 32));
  if (!v10) {
    goto LABEL_19;
  }
  uint64_t v11 = v10;
  uint64_t v12 = HDLCFrameEncode();
  if (!v12) {
    goto LABEL_21;
  }
  uint64_t v13 = v12;
  unsigned int v30 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v11, v12);
  }
  if (!*a1)
  {
LABEL_21:
    free(v11);
    goto LABEL_19;
  }
  int v14 = ((uint64_t (*)(void *, void *, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v11, v13, &v30, 1, a2, 0);
  unsigned int v15 = v30;
  free(v11);
  if (v14) {
    BOOL v16 = v15 == v13;
  }
  else {
    BOOL v16 = 0;
  }
  if (!v16) {
    goto LABEL_19;
  }
  LOBYTE(v30) = 75;
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  int v17 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v25, (uint64_t)&_ETLResponseRingBuffer, &v30, a2);
  uint64_t v23 = 0;
  if (v17 && v30 == 75)
  {
    unsigned int v30 = 0;
    uint64_t v23 = ETLMaverickParseRSSICommandResponse((uint64_t)v25, &v30, 1, v18, v19, v20, v21, v22);
  }
LABEL_20:
  HDLCFrameFree();
  HDLCFrameFree();
  return v23;
}

uint64_t ETLMaverickReportRSSI(void *a1, uint64_t a2)
{
  unsigned int v30 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  uint64_t v29 = 0;
  memset(v25, 0, sizeof(v25));
  uint64_t v26 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickReportRSSI", (uint64_t)"Failed to create command frame\n", v4, v5, v6, v7, v8, v9, *(uint64_t *)&v25[0]);
LABEL_19:
    uint64_t v23 = 0;
    goto LABEL_20;
  }
  if (!ETLMaverickCreateReportRSSICommand()) {
    goto LABEL_19;
  }
  uint64_t v10 = malloc((2 * DWORD2(v27) + 32));
  if (!v10) {
    goto LABEL_19;
  }
  uint64_t v11 = v10;
  uint64_t v12 = HDLCFrameEncode();
  if (!v12) {
    goto LABEL_21;
  }
  uint64_t v13 = v12;
  int v31 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v11, v12);
  }
  if (!*a1)
  {
LABEL_21:
    free(v11);
    goto LABEL_19;
  }
  int v14 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v11, v13, &v31, 1, a2, 0);
  int v15 = v31;
  free(v11);
  if (v14) {
    BOOL v16 = v15 == v13;
  }
  else {
    BOOL v16 = 0;
  }
  if (!v16) {
    goto LABEL_19;
  }
  LOBYTE(v31) = 75;
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  int v17 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v25, (uint64_t)&_ETLResponseRingBuffer, &v31, a2);
  uint64_t v23 = 0;
  if (v17 && v31 == 75) {
    uint64_t v23 = ETLMaverickParseRSSICommandResponse((uint64_t)v25, &v30, 1, v18, v19, v20, v21, v22);
  }
LABEL_20:
  HDLCFrameFree();
  HDLCFrameFree();
  return v23;
}

void *ETLMaverickSetAPWake(void *a1, uint64_t a2, uint64_t a3)
{
  long long v36 = 0u;
  long long v37 = 0u;
  uint64_t v38 = 0;
  memset(v34, 0, sizeof(v34));
  uint64_t v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    unsigned int v30 = "ETLMaverickSetAPWake";
    int v31 = "Failed to create command frame\n";
LABEL_21:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v5, v6, v7, v8, v9, v10, v33);
    goto LABEL_22;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
LABEL_22:
    uint64_t v18 = 0;
    goto LABEL_23;
  }
  int v39 = 916811;
  if ((HDLCFrameInject() & 1) == 0)
  {
    unsigned int v30 = "ETLSubsysAddHeaderInternal";
    int v31 = "Failed to inject\n";
    goto LABEL_21;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v33 = 2;
    unsigned int v30 = "ETLMaverickCreateAPWakeCommand";
    int v31 = "Not enough room, need %zu, have %u\n";
    goto LABEL_21;
  }
  HDLCFrameInjectUnsignedShort();
  uint64_t v18 = malloc((2 * DWORD2(v36) + 32));
  if (!v18) {
    goto LABEL_23;
  }
  uint64_t v19 = HDLCFrameEncode();
  if (!v19) {
    goto LABEL_24;
  }
  uint64_t v20 = v19;
  int v39 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v18, v19);
  }
  if (!*a1)
  {
LABEL_24:
    free(v18);
    goto LABEL_22;
  }
  int v21 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v18, v20, &v39, 1, a3, 0);
  int v22 = v39;
  free(v18);
  uint64_t v18 = 0;
  if (v21 && v22 == v20)
  {
    LOBYTE(v39) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    uint64_t v18 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a3)&& v39 == 75)
    {
      uint64_t v18 = (void *)ETLMaverickParseAPWakeResponse((unsigned int *)v34, v23, v24, v25, v26, v27, v28, v29);
    }
  }
LABEL_23:
  HDLCFrameFree();
  HDLCFrameFree();
  return v18;
}

uint64_t ETLMaverickEnterEmergencyDownloadMode(void *a1, uint64_t a2)
{
  long long v36 = 0u;
  long long v37 = 0u;
  uint64_t v38 = 0;
  memset(v34, 0, sizeof(v34));
  uint64_t v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    unsigned int v30 = "ETLMaverickEnterEmergencyDownloadMode";
    int v31 = "Failed to create command frame\n";
LABEL_23:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v4, v5, v6, v7, v8, v9, v33);
    goto LABEL_24;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_24;
  }
  int v39 = 982347;
  if ((HDLCFrameInject() & 1) == 0)
  {
    unsigned int v30 = "ETLSubsysAddHeaderInternal";
    int v31 = "Failed to inject\n";
    goto LABEL_23;
  }
  uint64_t v17 = (uint64_t)malloc((2 * DWORD2(v36) + 32));
  if (v17)
  {
    uint64_t v18 = HDLCFrameEncode();
    if (!v18) {
      goto LABEL_26;
    }
    uint64_t v19 = v18;
    int v39 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v17, v18);
    }
    if (!*a1)
    {
LABEL_26:
      free((void *)v17);
      goto LABEL_24;
    }
    int v20 = ((uint64_t (*)(void *, uint64_t, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v17, v19, &v39, 1, a2, 0);
    int v21 = v39;
    free((void *)v17);
    uint64_t v17 = 0;
    if (v20)
    {
      if (v21 == v19)
      {
        LOBYTE(v39) = 75;
        if (!_ETLResponseRingBuffer) {
          TelephonyUtilRingBufferInitialize();
        }
        uint64_t v17 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a2))
        {
          if (v39 == 75)
          {
            if (DWORD2(v34[0]) < 4)
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v22, v23, v24, v25, v26, v27, DWORD2(v34[0]));
            }
            else
            {
              unsigned int v28 = **(_DWORD **)&v34[0];
              if (**(_DWORD **)&v34[0] == 75)
              {
                if (BYTE1(v28) == 253)
                {
                  uint64_t v29 = HIWORD(v28);
                  if (v29 == 14)
                  {
                    uint64_t v17 = 1;
                    goto LABEL_25;
                  }
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, v29);
                }
                else
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, BYTE1(v28));
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, **(_DWORD **)&v34[0]);
              }
            }
LABEL_24:
            uint64_t v17 = 0;
          }
        }
      }
    }
  }
LABEL_25:
  HDLCFrameFree();
  HDLCFrameFree();
  return v17;
}

void *ETLMaverickGetTxPower(void *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v39 = 0u;
  long long v40 = 0u;
  uint64_t v41 = 0;
  memset(v37, 0, sizeof(v37));
  uint64_t v38 = 0;
  if (!a3 || (uint64_t Uplink = HDLCFrameCreateUplink(), (Uplink & 1) == 0))
  {
    int v21 = "ETLMaverickGetTxPower";
    uint64_t v22 = "Failed to create command frame\n";
    goto LABEL_8;
  }
  int v13 = capabilities::etl::maverickTxPowerUsesRFSubsys((capabilities::etl *)Uplink);
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (!v13)
  {
    if (FreeSpace >= 4)
    {
      int v42 = 589131;
      if (!HDLCFrameInject()) {
        goto LABEL_6;
      }
      goto LABEL_13;
    }
LABEL_24:
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v15, v16, v17, v18, v19, v20, FreeSpace);
    goto LABEL_9;
  }
  if (FreeSpace < 4) {
    goto LABEL_24;
  }
  int v42 = 1112907;
  if (!HDLCFrameInject())
  {
LABEL_6:
    int v21 = "ETLSubsysAddHeaderInternal";
    uint64_t v22 = "Failed to inject\n";
LABEL_8:
    _ETLDebugPrint((uint64_t)v21, (uint64_t)v22, a3, a4, a5, a6, a7, a8, v36);
    goto LABEL_9;
  }
LABEL_13:
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickCreateGetTxPowerExtCommand", (uint64_t)"Not enough room, need %zu, have %u\n", v25, v26, v27, v28, v29, v30, 2);
    goto LABEL_9;
  }
  if (a2 > 7)
  {
LABEL_9:
    TxPowerExtResponse = 0;
    goto LABEL_10;
  }
  HDLCFrameInjectUnsignedShort();
  TxPowerExtResponse = malloc((2 * DWORD2(v39) + 32));
  if (!TxPowerExtResponse) {
    goto LABEL_10;
  }
  uint64_t v31 = HDLCFrameEncode();
  if (!v31) {
    goto LABEL_26;
  }
  uint64_t v32 = v31;
  int v42 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, TxPowerExtResponse, v31);
  }
  if (!*a1)
  {
LABEL_26:
    free(TxPowerExtResponse);
    goto LABEL_9;
  }
  int v33 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, TxPowerExtResponse, v32, &v42, 1, a4, 0);
  int v34 = v42;
  free(TxPowerExtResponse);
  TxPowerExtResponse = 0;
  if (v33 && v34 == v32)
  {
    if (ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v37, a4))
    {
      TxPowerExtResponse = (void *)ETLMaverickParseGetTxPowerExtResponse((unsigned int *)v37, v35, a3);
      goto LABEL_10;
    }
    goto LABEL_9;
  }
LABEL_10:
  HDLCFrameFree();
  HDLCFrameFree();
  return TxPowerExtResponse;
}

void *ETLMaverickGetTxPowerCap(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v41 = 0u;
  long long v42 = 0u;
  uint64_t v43 = 0;
  memset(v39, 0, sizeof(v39));
  uint64_t v40 = 0;
  if (!a2 || (HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v35 = "ETLMaverickGetTxPowerCap";
    uint64_t v36 = "Failed to create command frame\n";
LABEL_19:
    _ETLDebugPrint((uint64_t)v35, (uint64_t)v36, a3, a4, a5, a6, a7, a8, v38);
LABEL_20:
    TxPowerCapResponse = 0;
    goto LABEL_21;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
    goto LABEL_20;
  }
  int v44 = 1572171;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v35 = "ETLSubsysAddHeaderInternal";
    uint64_t v36 = "Failed to inject\n";
    goto LABEL_19;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickCreateGetTxPowerCapCommand", (uint64_t)"Not enough room, need %zu, have %u\n", v18, v19, v20, v21, v22, v23, 2);
    goto LABEL_20;
  }
  HDLCFrameInjectUnsignedShort();
  TxPowerCapResponse = malloc((2 * DWORD2(v41) + 32));
  if (!TxPowerCapResponse) {
    goto LABEL_21;
  }
  uint64_t v25 = HDLCFrameEncode();
  if (!v25) {
    goto LABEL_25;
  }
  uint64_t v26 = v25;
  int v44 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, TxPowerCapResponse, v25);
  }
  if (!*a1)
  {
LABEL_25:
    free(TxPowerCapResponse);
    goto LABEL_20;
  }
  int v27 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, TxPowerCapResponse, v26, &v44, 1, a3, 0);
  int v28 = v44;
  free(TxPowerCapResponse);
  TxPowerCapResponse = 0;
  if (v27 && v28 == v26)
  {
    LOBYTE(v44) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    TxPowerCapResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v39, (uint64_t)&_ETLResponseRingBuffer, &v44, a3)&& v44 == 75)
    {
      TxPowerCapResponse = (void *)ETLMaverickParseGetTxPowerCapResponse((int **)v39, a2, v29, v30, v31, v32, v33, v34);
    }
  }
LABEL_21:
  HDLCFrameFree();
  HDLCFrameFree();
  return TxPowerCapResponse;
}

uint64_t ETLMaverickWriteFATPDefaultNVs(void *a1, uint64_t a2)
{
  long long v36 = 0u;
  long long v37 = 0u;
  uint64_t v38 = 0;
  memset(v34, 0, sizeof(v34));
  uint64_t v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v30 = "ETLMaverickWriteFATPDefaultNVs";
    uint64_t v31 = "Failed to create command frame\n";
LABEL_23:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v4, v5, v6, v7, v8, v9, v33);
    goto LABEL_24;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_24;
  }
  int v39 = 2621003;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v30 = "ETLSubsysAddHeaderInternal";
    uint64_t v31 = "Failed to inject\n";
    goto LABEL_23;
  }
  uint64_t v17 = (uint64_t)malloc((2 * DWORD2(v36) + 32));
  if (v17)
  {
    uint64_t v18 = HDLCFrameEncode();
    if (!v18) {
      goto LABEL_26;
    }
    uint64_t v19 = v18;
    int v39 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v17, v18);
    }
    if (!*a1)
    {
LABEL_26:
      free((void *)v17);
      goto LABEL_24;
    }
    int v20 = ((uint64_t (*)(void *, uint64_t, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v17, v19, &v39, 1, a2, 0);
    int v21 = v39;
    free((void *)v17);
    uint64_t v17 = 0;
    if (v20)
    {
      if (v21 == v19)
      {
        LOBYTE(v39) = 75;
        if (!_ETLResponseRingBuffer) {
          TelephonyUtilRingBufferInitialize();
        }
        uint64_t v17 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a2))
        {
          if (v39 == 75)
          {
            if (DWORD2(v34[0]) < 4)
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v22, v23, v24, v25, v26, v27, DWORD2(v34[0]));
            }
            else
            {
              unsigned int v28 = **(_DWORD **)&v34[0];
              if (**(_DWORD **)&v34[0] == 75)
              {
                if (BYTE1(v28) == 254)
                {
                  uint64_t v29 = HIWORD(v28);
                  if (v29 == 39)
                  {
                    uint64_t v17 = 1;
                    goto LABEL_25;
                  }
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, v29);
                }
                else
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, BYTE1(v28));
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, **(_DWORD **)&v34[0]);
              }
            }
LABEL_24:
            uint64_t v17 = 0;
          }
        }
      }
    }
  }
LABEL_25:
  HDLCFrameFree();
  HDLCFrameFree();
  return v17;
}

uint64_t ETLMaverickWriteDefaultNVs(void *a1, uint64_t a2)
{
  long long v36 = 0u;
  long long v37 = 0u;
  uint64_t v38 = 0;
  memset(v34, 0, sizeof(v34));
  uint64_t v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v30 = "ETLMaverickWriteDefaultNVs";
    uint64_t v31 = "Failed to create command frame\n";
LABEL_23:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v4, v5, v6, v7, v8, v9, v33);
    goto LABEL_24;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_24;
  }
  int v39 = 1703243;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v30 = "ETLSubsysAddHeaderInternal";
    uint64_t v31 = "Failed to inject\n";
    goto LABEL_23;
  }
  uint64_t v17 = (uint64_t)malloc((2 * DWORD2(v36) + 32));
  if (v17)
  {
    uint64_t v18 = HDLCFrameEncode();
    if (!v18) {
      goto LABEL_26;
    }
    uint64_t v19 = v18;
    int v39 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v17, v18);
    }
    if (!*a1)
    {
LABEL_26:
      free((void *)v17);
      goto LABEL_24;
    }
    int v20 = ((uint64_t (*)(void *, uint64_t, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v17, v19, &v39, 1, a2, 0);
    int v21 = v39;
    free((void *)v17);
    uint64_t v17 = 0;
    if (v20)
    {
      if (v21 == v19)
      {
        LOBYTE(v39) = 75;
        if (!_ETLResponseRingBuffer) {
          TelephonyUtilRingBufferInitialize();
        }
        uint64_t v17 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a2))
        {
          if (v39 == 75)
          {
            if (DWORD2(v34[0]) < 4)
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v22, v23, v24, v25, v26, v27, DWORD2(v34[0]));
            }
            else
            {
              unsigned int v28 = **(_DWORD **)&v34[0];
              if (**(_DWORD **)&v34[0] == 75)
              {
                if (BYTE1(v28) == 253)
                {
                  uint64_t v29 = HIWORD(v28);
                  if (v29 == 25)
                  {
                    uint64_t v17 = 1;
                    goto LABEL_25;
                  }
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, v29);
                }
                else
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, BYTE1(v28));
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, **(_DWORD **)&v34[0]);
              }
            }
LABEL_24:
            uint64_t v17 = 0;
          }
        }
      }
    }
  }
LABEL_25:
  HDLCFrameFree();
  HDLCFrameFree();
  return v17;
}

uint64_t ETLMaverickWriteFactoryDefaultNVs(void *a1, uint64_t a2)
{
  long long v36 = 0u;
  long long v37 = 0u;
  uint64_t v38 = 0;
  memset(v34, 0, sizeof(v34));
  uint64_t v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v30 = "ETLMaverickWriteFactoryDefaultNVs";
    uint64_t v31 = "Failed to create command frame\n";
LABEL_23:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v4, v5, v6, v7, v8, v9, v33);
    goto LABEL_24;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_24;
  }
  int v39 = 1834571;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v30 = "ETLSubsysAddHeaderInternal";
    uint64_t v31 = "Failed to inject\n";
    goto LABEL_23;
  }
  uint64_t v17 = (uint64_t)malloc((2 * DWORD2(v36) + 32));
  if (v17)
  {
    uint64_t v18 = HDLCFrameEncode();
    if (!v18) {
      goto LABEL_26;
    }
    uint64_t v19 = v18;
    int v39 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v17, v18);
    }
    if (!*a1)
    {
LABEL_26:
      free((void *)v17);
      goto LABEL_24;
    }
    int v20 = ((uint64_t (*)(void *, uint64_t, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v17, v19, &v39, 1, a2, 0);
    int v21 = v39;
    free((void *)v17);
    uint64_t v17 = 0;
    if (v20)
    {
      if (v21 == v19)
      {
        LOBYTE(v39) = 75;
        if (!_ETLResponseRingBuffer) {
          TelephonyUtilRingBufferInitialize();
        }
        uint64_t v17 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a2))
        {
          if (v39 == 75)
          {
            if (DWORD2(v34[0]) < 4)
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v22, v23, v24, v25, v26, v27, DWORD2(v34[0]));
            }
            else
            {
              unsigned int v28 = **(_DWORD **)&v34[0];
              if (**(_DWORD **)&v34[0] == 75)
              {
                if (BYTE1(v28) == 254)
                {
                  uint64_t v29 = HIWORD(v28);
                  if (v29 == 27)
                  {
                    uint64_t v17 = 1;
                    goto LABEL_25;
                  }
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, v29);
                }
                else
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, BYTE1(v28));
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v22, v23, v24, v25, v26, v27, **(_DWORD **)&v34[0]);
              }
            }
LABEL_24:
            uint64_t v17 = 0;
          }
        }
      }
    }
  }
LABEL_25:
  HDLCFrameFree();
  HDLCFrameFree();
  return v17;
}

void *ETLMaverickIsSimPresentExt(void *a1, BOOL *a2, BOOL *a3, uint64_t a4, uint64_t a5)
{
  long long v38 = 0u;
  long long v39 = 0u;
  uint64_t v40 = 0;
  memset(v36, 0, sizeof(v36));
  uint64_t v37 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v32 = "ETLMaverickIsSimPresentExt";
    uint64_t v33 = "Failed to create command frame\n";
LABEL_20:
    _ETLDebugPrint((uint64_t)v32, (uint64_t)v33, v9, v10, v11, v12, v13, v14, v35);
    goto LABEL_21;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v16, v17, v18, v19, v20, v21, FreeSpace);
    goto LABEL_21;
  }
  int v41 = 130635;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v32 = "ETLSubsysAddHeaderInternal";
    uint64_t v33 = "Failed to inject\n";
    goto LABEL_20;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_21:
    IsSimPresentResponse = 0;
    goto LABEL_22;
  }
  IsSimPresentResponse = malloc((2 * DWORD2(v38) + 32));
  if (!IsSimPresentResponse) {
    goto LABEL_22;
  }
  uint64_t v23 = HDLCFrameEncode();
  if (!v23) {
    goto LABEL_23;
  }
  uint64_t v24 = v23;
  int v41 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, IsSimPresentResponse, v23);
  }
  if (!*a1)
  {
LABEL_23:
    free(IsSimPresentResponse);
    goto LABEL_21;
  }
  int v25 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, IsSimPresentResponse, v24, &v41, 1, a5, 0);
  int v26 = v41;
  free(IsSimPresentResponse);
  IsSimPresentResponse = 0;
  if (v25 && v26 == v24)
  {
    LOBYTE(v41) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    IsSimPresentResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v36, (uint64_t)&_ETLResponseRingBuffer, &v41, a5)&& v41 == 75)
    {
      IsSimPresentResponse = (void *)ETLMaverickParseIsSimPresentResponse((int **)v36, a2, a3, v27, v28, v29, v30, v31);
    }
  }
LABEL_22:
  HDLCFrameFree();
  HDLCFrameFree();
  return IsSimPresentResponse;
}

void *ETLMaverickSetTxAntenna(void *a1, int a2, uint64_t a3)
{
  long long v36 = 0u;
  long long v37 = 0u;
  uint64_t v38 = 0;
  memset(v34, 0, sizeof(v34));
  uint64_t v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v30 = "ETLMaverickSetTxAntenna";
    uint64_t v31 = "Failed to create command frame\n";
LABEL_21:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v6, v7, v8, v9, v10, v11, v33);
    goto LABEL_22;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
LABEL_22:
    uint64_t v19 = 0;
    goto LABEL_23;
  }
  int v39 = 458059;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v30 = "ETLSubsysAddHeaderInternal";
    uint64_t v31 = "Failed to inject\n";
    goto LABEL_21;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v33 = 2;
    uint64_t v30 = "ETLMaverickCreateTxModeSwitchCommand";
    uint64_t v31 = "Not enough room, need %zu, have %u\n";
    goto LABEL_21;
  }
  HDLCFrameInjectUnsignedShort();
  uint64_t v19 = malloc((2 * DWORD2(v36) + 32));
  if (!v19) {
    goto LABEL_23;
  }
  uint64_t v20 = HDLCFrameEncode();
  if (!v20) {
    goto LABEL_24;
  }
  uint64_t v21 = v20;
  int v39 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v19, v20);
  }
  if (!*a1)
  {
LABEL_24:
    free(v19);
    goto LABEL_22;
  }
  int v22 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v19, v21, &v39, 1, a3, 0);
  int v23 = v39;
  free(v19);
  uint64_t v19 = 0;
  if (v22 && v23 == v21)
  {
    LOBYTE(v39) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    uint64_t v19 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a3)&& v39 == 75)
    {
      uint64_t v19 = (void *)ETLMaverickParseTxModeSwitchResponse((int **)v34, a2, v24, v25, v26, v27, v28, v29);
    }
  }
LABEL_23:
  HDLCFrameFree();
  HDLCFrameFree();
  return v19;
}

void *ETLMaverickGetTxAntenna(void *a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v37 = 0;
  long long v34 = 0u;
  long long v35 = 0u;
  uint64_t v36 = 0;
  memset(v32, 0, sizeof(v32));
  uint64_t v33 = 0;
  if (!a2 || (HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v28 = "ETLMaverickGetTxAntenna";
    uint64_t v29 = "Failed to create command frame\n";
LABEL_18:
    _ETLDebugPrint((uint64_t)v28, (uint64_t)v29, a3, a4, a5, a6, a7, a8, v31);
LABEL_19:
    TxAntenna = 0;
    goto LABEL_20;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
    goto LABEL_19;
  }
  int v38 = 1637707;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v28 = "ETLSubsysAddHeaderInternal";
    uint64_t v29 = "Failed to inject\n";
    goto LABEL_18;
  }
  TxAntenna = malloc((2 * DWORD2(v34) + 32));
  if (!TxAntenna) {
    goto LABEL_20;
  }
  uint64_t v19 = HDLCFrameEncode();
  if (!v19) {
    goto LABEL_23;
  }
  uint64_t v20 = v19;
  int v38 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, TxAntenna, v19);
  }
  if (!*a1)
  {
LABEL_23:
    free(TxAntenna);
    goto LABEL_19;
  }
  int v21 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, TxAntenna, v20, &v38, 1, a3, 0);
  int v22 = v38;
  free(TxAntenna);
  TxAntenna = 0;
  if (v21 && v22 == v20)
  {
    LOBYTE(v38) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    TxAntenna = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v32, (uint64_t)&_ETLResponseRingBuffer, &v38, a3)&& v38 == 75)
    {
      TxAntenna = (void *)ETLMaverickParseGetTxAntenna((uint64_t)v32, a2, &v37, v23, v24, v25, v26, v27);
    }
  }
LABEL_20:
  HDLCFrameFree();
  HDLCFrameFree();
  return TxAntenna;
}

void *ETLMaverickGetGPIOState(void *a1, int a2, BOOL *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v41 = 0u;
  long long v42 = 0u;
  uint64_t v43 = 0;
  memset(v39, 0, sizeof(v39));
  uint64_t v40 = 0;
  if (!a3 || (HDLCFrameCreateUplink() & 1) == 0)
  {
    long long v35 = "ETLMaverickGetGPIOState";
    uint64_t v36 = "Failed to create command frame\n";
LABEL_17:
    _ETLDebugPrint((uint64_t)v35, (uint64_t)v36, (uint64_t)a3, a4, a5, a6, a7, a8, v38);
    goto LABEL_18;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
    goto LABEL_18;
  }
  int v44 = 1310283;
  if ((HDLCFrameInject() & 1) == 0)
  {
    long long v35 = "ETLSubsysAddHeaderInternal";
    uint64_t v36 = "Failed to inject\n";
    goto LABEL_17;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickCreateGetGPIOCommand", (uint64_t)"Not enough room, need %zu, have %u\n", v19, v20, v21, v22, v23, v24, 2);
    goto LABEL_18;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_18:
    GPIOResponse = 0;
    goto LABEL_19;
  }
  GPIOResponse = malloc((2 * DWORD2(v41) + 32));
  if (GPIOResponse)
  {
    uint64_t v26 = HDLCFrameEncode();
    if (!v26) {
      goto LABEL_23;
    }
    uint64_t v27 = v26;
    int v44 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, GPIOResponse, v26);
    }
    if (!*a1)
    {
LABEL_23:
      free(GPIOResponse);
      goto LABEL_18;
    }
    int v28 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, GPIOResponse, v27, &v44, 1, a4, 0);
    int v29 = v44;
    free(GPIOResponse);
    GPIOResponse = 0;
    if (v28)
    {
      if (v29 == v27)
      {
        if (ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v39, a4))
        {
          GPIOResponse = (void *)ETLMaverickParseGetGPIOResponse((int **)v39, a2, a3, v30, v31, v32, v33, v34);
          goto LABEL_19;
        }
        goto LABEL_18;
      }
    }
  }
LABEL_19:
  HDLCFrameFree();
  HDLCFrameFree();
  return GPIOResponse;
}

void *ETLMaverickSetGPIOState(void *a1, int a2, uint64_t a3, uint64_t a4)
{
  long long v37 = 0u;
  long long v38 = 0u;
  uint64_t v39 = 0;
  memset(v35, 0, sizeof(v35));
  uint64_t v36 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v31 = "ETLMaverickSetGPIOState";
    uint64_t v32 = "Failed to create command frame\n";
LABEL_20:
    _ETLDebugPrint((uint64_t)v31, (uint64_t)v32, v7, v8, v9, v10, v11, v12, v34);
    goto LABEL_21;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v14, v15, v16, v17, v18, v19, FreeSpace);
    goto LABEL_21;
  }
  int v40 = 1375819;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v31 = "ETLSubsysAddHeaderInternal";
    uint64_t v32 = "Failed to inject\n";
    goto LABEL_20;
  }
  if (HDLCFrameGetFreeSpace() <= 3)
  {
    uint64_t v34 = 4;
    uint64_t v31 = "ETLMaverickCreateSetGPIOCommand";
    uint64_t v32 = "Not enough room, need %zu, have %u\n";
    goto LABEL_20;
  }
  if (!HDLCFrameInjectUnsignedShort() || !HDLCFrameInjectUnsignedShort()) {
    goto LABEL_21;
  }
  uint64_t v20 = malloc((2 * DWORD2(v37) + 32));
  if (v20)
  {
    uint64_t v21 = HDLCFrameEncode();
    if (!v21) {
      goto LABEL_23;
    }
    uint64_t v22 = v21;
    int v40 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v20, v21);
    }
    if (!*a1)
    {
LABEL_23:
      free(v20);
      goto LABEL_21;
    }
    int v23 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v20, v22, &v40, 1, a4, 0);
    int v24 = v40;
    free(v20);
    uint64_t v20 = 0;
    if (v23)
    {
      if (v24 == v22)
      {
        if (ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v35, a4))
        {
          uint64_t v20 = (void *)ETLMaverickParseSetGPIOResponse((int **)v35, a2, v25, v26, v27, v28, v29, v30);
          goto LABEL_22;
        }
LABEL_21:
        uint64_t v20 = 0;
      }
    }
  }
LABEL_22:
  HDLCFrameFree();
  HDLCFrameFree();
  return v20;
}

void *ETLMaverickBackupBoardSN(void *a1, uint64_t a2)
{
  long long v35 = 0u;
  long long v36 = 0u;
  uint64_t v37 = 0;
  memset(v33, 0, sizeof(v33));
  uint64_t v34 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v29 = "ETLMaverickBackupBoardSN";
    uint64_t v30 = "Failed to create command frame\n";
LABEL_22:
    _ETLDebugPrint((uint64_t)v29, (uint64_t)v30, v4, v5, v6, v7, v8, v9, v32);
    goto LABEL_23;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_23;
  }
  int v38 = 851531;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v29 = "ETLSubsysAddHeaderInternal";
    uint64_t v30 = "Failed to inject\n";
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v32 = 2;
    uint64_t v29 = "ETLRequireFreeSpace";
    uint64_t v30 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_22;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_23:
    uint64_t v17 = 0;
    goto LABEL_24;
  }
  uint64_t v17 = malloc((2 * DWORD2(v35) + 32));
  if (!v17) {
    goto LABEL_24;
  }
  uint64_t v18 = HDLCFrameEncode();
  if (!v18) {
    goto LABEL_25;
  }
  uint64_t v19 = v18;
  int v38 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v17, v18);
  }
  if (!*a1)
  {
LABEL_25:
    free(v17);
    goto LABEL_23;
  }
  int v20 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v17, v19, &v38, 1, a2, 0);
  int v21 = v38;
  free(v17);
  uint64_t v17 = 0;
  if (v20 && v21 == v19)
  {
    LOBYTE(v38) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    uint64_t v17 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v33, (uint64_t)&_ETLResponseRingBuffer, &v38, a2)&& v38 == 75)
    {
      uint64_t v17 = (void *)ETLMaverickParseBackupBoardSNResponse((int **)v33, v22, v23, v24, v25, v26, v27, v28);
    }
  }
LABEL_24:
  HDLCFrameFree();
  HDLCFrameFree();
  return v17;
}

uint64_t ETLMaverickBackupOrRestoreBBData(uint64_t (**a1)(void, uint64_t, uint64_t, int *, uint64_t, uint64_t, void), int a2, uint64_t a3)
{
  if (a2 <= 13)
  {
    __int16 v5 = a2;
    long long v38 = 0u;
    long long v39 = 0u;
    uint64_t v40 = 0;
    memset(v36, 0, sizeof(v36));
    uint64_t v37 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v14, v15, v16, v17, v18, v19, FreeSpace);
        goto LABEL_26;
      }
      unsigned __int16 v20 = v5 + 21;
      LOWORD(v41) = -437;
      HIWORD(v41) = v5 + 21;
      if (HDLCFrameInject())
      {
        uint64_t v3 = (uint64_t)malloc((2 * DWORD2(v38) + 32));
        if (!v3)
        {
LABEL_27:
          HDLCFrameFree();
          HDLCFrameFree();
          return v3;
        }
        uint64_t v21 = HDLCFrameEncode();
        if (!v21) {
          goto LABEL_29;
        }
        uint64_t v22 = v21;
        int v41 = -1431655766;
        if ((_ETLDebugFlags & 2) != 0) {
          ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v3, v21);
        }
        if (*a1)
        {
          int v23 = (*a1)(a1, v3, v22, &v41, 1, a3, 0);
          int v24 = v41;
          free((void *)v3);
          uint64_t v3 = 0;
          if (!v23 || v24 != v22) {
            goto LABEL_27;
          }
          LOBYTE(v41) = 75;
          if (!_ETLResponseRingBuffer) {
            TelephonyUtilRingBufferInitialize();
          }
          uint64_t v3 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v36, (uint64_t)&_ETLResponseRingBuffer, &v41, a3)|| v41 != 75)
          {
            goto LABEL_27;
          }
          if (DWORD2(v36[0]) < 4)
          {
            _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v25, v26, v27, v28, v29, v30, DWORD2(v36[0]));
          }
          else
          {
            unsigned int v31 = **(_DWORD **)&v36[0];
            if (**(_DWORD **)&v36[0] == 75)
            {
              if (BYTE1(v31) == 254)
              {
                if (v20 == HIWORD(v31))
                {
                  uint64_t v3 = 1;
                  goto LABEL_27;
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v25, v26, v27, v28, v29, v30, HIWORD(v31));
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v25, v26, v27, v28, v29, v30, BYTE1(v31));
              }
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v25, v26, v27, v28, v29, v30, **(_DWORD **)&v36[0]);
            }
          }
        }
        else
        {
LABEL_29:
          free((void *)v3);
        }
LABEL_26:
        uint64_t v3 = 0;
        goto LABEL_27;
      }
      uint64_t v32 = "ETLSubsysAddHeaderInternal";
      uint64_t v33 = "Failed to inject\n";
    }
    else
    {
      uint64_t v32 = "ETLMaverickBackupOrRestoreBBData";
      uint64_t v33 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v32, (uint64_t)v33, v7, v8, v9, v10, v11, v12, v35);
    goto LABEL_26;
  }
  return 0;
}

void *ETLMaverickSetAntennaSKU(void *a1, int a2, uint64_t a3)
{
  long long v36 = 0u;
  long long v37 = 0u;
  uint64_t v38 = 0;
  memset(v34, 0, sizeof(v34));
  uint64_t v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v30 = "ETLMaverickSetAntennaSKU";
    unsigned int v31 = "Failed to create command frame\n";
LABEL_22:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v6, v7, v8, v9, v10, v11, v33);
    goto LABEL_23;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
    goto LABEL_23;
  }
  int v39 = 2555211;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v30 = "ETLSubsysAddHeaderInternal";
    unsigned int v31 = "Failed to inject\n";
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v33 = 2;
    uint64_t v30 = "ETLRequireFreeSpace";
    unsigned int v31 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_22;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_23:
    uint64_t v19 = 0;
    goto LABEL_24;
  }
  uint64_t v19 = malloc((2 * DWORD2(v36) + 32));
  if (!v19) {
    goto LABEL_24;
  }
  uint64_t v20 = HDLCFrameEncode();
  if (!v20) {
    goto LABEL_25;
  }
  uint64_t v21 = v20;
  int v39 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v19, v20);
  }
  if (!*a1)
  {
LABEL_25:
    free(v19);
    goto LABEL_23;
  }
  int v22 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v19, v21, &v39, 1, a3, 0);
  int v23 = v39;
  free(v19);
  uint64_t v19 = 0;
  if (v22 && v23 == v21)
  {
    LOBYTE(v39) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    uint64_t v19 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a3)&& v39 == 75)
    {
      uint64_t v19 = (void *)ETLMaverickParseSetAntennaSKUResponse((int **)v34, a2, v24, v25, v26, v27, v28, v29);
    }
  }
LABEL_24:
  HDLCFrameFree();
  HDLCFrameFree();
  return v19;
}

uint64_t ETLMaverickSetIMEISwVersion(void *a1, int a2, uint64_t a3)
{
  long long v41 = 0u;
  long long v42 = 0u;
  uint64_t v43 = 0;
  memset(v39, 0, sizeof(v39));
  uint64_t v40 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v35 = "ETLMaverickSetIMEISwVersion";
    long long v36 = "Failed to create command frame\n";
LABEL_24:
    _ETLDebugPrint((uint64_t)v35, (uint64_t)v36, v6, v7, v8, v9, v10, v11, v38);
    goto LABEL_25;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
    goto LABEL_25;
  }
  int v44 = 2489675;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v35 = "ETLSubsysAddHeaderInternal";
    long long v36 = "Failed to inject\n";
    goto LABEL_24;
  }
  if (!HDLCFrameGetFreeSpace())
  {
    uint64_t v38 = 1;
    uint64_t v35 = "ETLRequireFreeSpace";
    long long v36 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_24;
  }
  if (!HDLCFrameInjectUnsignedChar()) {
    goto LABEL_25;
  }
  uint64_t v19 = (uint64_t)malloc((2 * DWORD2(v41) + 32));
  if (v19)
  {
    uint64_t v20 = HDLCFrameEncode();
    if (!v20) {
      goto LABEL_27;
    }
    uint64_t v21 = v20;
    int v44 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v19, v20);
    }
    if (!*a1)
    {
LABEL_27:
      free((void *)v19);
      goto LABEL_25;
    }
    int v22 = ((uint64_t (*)(void *, uint64_t, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v19, v21, &v44, 1, a3, 0);
    int v23 = v44;
    free((void *)v19);
    uint64_t v19 = 0;
    if (v22)
    {
      if (v23 == v21)
      {
        LOBYTE(v44) = 75;
        if (!_ETLResponseRingBuffer) {
          TelephonyUtilRingBufferInitialize();
        }
        uint64_t v19 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v39, (uint64_t)&_ETLResponseRingBuffer, &v44, a3))
        {
          if (v44 == 75)
          {
            LOBYTE(v44) = -86;
            if (ETLMaverickParseIMEISwVersionResponse((int **)v39, &v44, 37, v24, v25, v26, v27, v28))
            {
              if (v44 == a2)
              {
                uint64_t v19 = 1;
                goto LABEL_26;
              }
              _ETLDebugPrint((uint64_t)"ETLMaverickSetIMEISwVersion", (uint64_t)"Received SVN %u mismatches sent %u\n", v29, v30, v31, v32, v33, v34, v44);
            }
LABEL_25:
            uint64_t v19 = 0;
          }
        }
      }
    }
  }
LABEL_26:
  HDLCFrameFree();
  HDLCFrameFree();
  return v19;
}

void *ETLMaverickGetIMEISwVersion(void *a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v34 = 0u;
  long long v35 = 0u;
  uint64_t v36 = 0;
  memset(v32, 0, sizeof(v32));
  uint64_t v33 = 0;
  if (!a2 || (HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v28 = "ETLMaverickGetIMEISwVersion";
    uint64_t v29 = "Failed to create command frame\n";
LABEL_18:
    _ETLDebugPrint((uint64_t)v28, (uint64_t)v29, a3, a4, a5, a6, a7, a8, v31);
LABEL_19:
    uint64_t v18 = 0;
    goto LABEL_20;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
    goto LABEL_19;
  }
  int v37 = 2424139;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v28 = "ETLSubsysAddHeaderInternal";
    uint64_t v29 = "Failed to inject\n";
    goto LABEL_18;
  }
  uint64_t v18 = malloc((2 * DWORD2(v34) + 32));
  if (!v18) {
    goto LABEL_20;
  }
  uint64_t v19 = HDLCFrameEncode();
  if (!v19) {
    goto LABEL_23;
  }
  uint64_t v20 = v19;
  int v37 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v18, v19);
  }
  if (!*a1)
  {
LABEL_23:
    free(v18);
    goto LABEL_19;
  }
  int v21 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v18, v20, &v37, 1, a3, 0);
  int v22 = v37;
  free(v18);
  uint64_t v18 = 0;
  if (v21 && v22 == v20)
  {
    LOBYTE(v37) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    uint64_t v18 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v32, (uint64_t)&_ETLResponseRingBuffer, &v37, a3)&& v37 == 75)
    {
      uint64_t v18 = (void *)ETLMaverickParseIMEISwVersionResponse((int **)v32, a2, 36, v23, v24, v25, v26, v27);
    }
  }
LABEL_20:
  HDLCFrameFree();
  HDLCFrameFree();
  return v18;
}

uint64_t ETLMaverickGetHWType(void *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  memset(v10, 170, sizeof(v10));
  if (!a2) {
    return 0;
  }
  uint64_t result = (uint64_t)ETLMaverickGetHWInfo(a1, (uint64_t)v10, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    *a2 = v10[0];
    return 1;
  }
  return result;
}

void *ETLMaverickGetHWInfo(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v35 = 0u;
  long long v36 = 0u;
  uint64_t v37 = 0;
  memset(v33, 0, sizeof(v33));
  uint64_t v34 = 0;
  if (!a2 || (HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v29 = "ETLMaverickGetHWInfo";
    uint64_t v30 = "Failed to create command frame\n";
LABEL_18:
    _ETLDebugPrint((uint64_t)v29, (uint64_t)v30, a3, a4, a5, a6, a7, a8, v32);
LABEL_19:
    HWConfigIDResponse = 0;
    goto LABEL_20;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
    goto LABEL_19;
  }
  int v38 = 65099;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v29 = "ETLSubsysAddHeaderInternal";
    uint64_t v30 = "Failed to inject\n";
    goto LABEL_18;
  }
  HWConfigIDResponse = malloc((2 * DWORD2(v35) + 32));
  if (!HWConfigIDResponse) {
    goto LABEL_20;
  }
  uint64_t v19 = HDLCFrameEncode();
  if (!v19) {
    goto LABEL_23;
  }
  uint64_t v20 = v19;
  int v38 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, HWConfigIDResponse, v19);
  }
  if (!*a1)
  {
LABEL_23:
    free(HWConfigIDResponse);
    goto LABEL_19;
  }
  int v21 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, HWConfigIDResponse, v20, &v38, 1, a3, 0);
  int v22 = v38;
  free(HWConfigIDResponse);
  HWConfigIDResponse = 0;
  if (v21 && v22 == v20)
  {
    LOBYTE(v38) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    HWConfigIDResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v33, (uint64_t)&_ETLResponseRingBuffer, &v38, a3)&& v38 == 75)
    {
      HWConfigIDResponse = (void *)ETLMaverickParseGetHWConfigIDResponse((uint64_t)v33, a2, v23, v24, v25, v26, v27, v28);
    }
  }
LABEL_20:
  HDLCFrameFree();
  HDLCFrameFree();
  return HWConfigIDResponse;
}

uint64_t ETLMaverickGetHWRev(void *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  memset(v10, 170, sizeof(v10));
  if (!a2) {
    return 0;
  }
  uint64_t result = (uint64_t)ETLMaverickGetHWInfo(a1, (uint64_t)v10, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    *a2 = WORD2(v10[0]);
    return 1;
  }
  return result;
}

uint64_t ETLMaverickGetHWConfigId(void *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  memset(v10, 170, sizeof(v10));
  if (!a2) {
    return 0;
  }
  uint64_t result = (uint64_t)ETLMaverickGetHWInfo(a1, (uint64_t)v10, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    *a2 = HIWORD(v10[0]);
    return 1;
  }
  return result;
}

uint64_t ETLMaverickGetPAConfig(void *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  memset(v10, 170, sizeof(v10));
  if (!a2) {
    return 0;
  }
  uint64_t result = (uint64_t)ETLMaverickGetHWInfo(a1, (uint64_t)v10, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    *a2 = v10[1];
    return 1;
  }
  return result;
}

uint64_t ETLMaverickGetAntennaTunerID(void *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  memset(v10, 170, sizeof(v10));
  if (!a2) {
    return 0;
  }
  uint64_t result = (uint64_t)ETLMaverickGetHWInfo(a1, (uint64_t)v10, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    *a2 = WORD1(v10[1]);
    return 1;
  }
  return result;
}

uint64_t ETLMaverickGetSKU(void *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  memset(v10, 170, sizeof(v10));
  if (!a2) {
    return 0;
  }
  uint64_t result = (uint64_t)ETLMaverickGetHWInfo(a1, (uint64_t)v10, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    *a2 = HIWORD(v10[2]);
    return 1;
  }
  return result;
}

void *ETLMaverickGetMaxTxPower(void *a1, _WORD *a2, _WORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v32 = 0u;
  long long v33 = 0u;
  uint64_t v34 = 0;
  memset(v30, 0, sizeof(v30));
  uint64_t v31 = 0;
  if (!a2 || !a3 || (uint64_t Uplink = HDLCFrameCreateUplink(), (Uplink & 1) == 0))
  {
    int v21 = "ETLMaverickGetMaxTxPower";
    int v22 = "Failed to create command frame\n";
    goto LABEL_9;
  }
  int v13 = capabilities::etl::maverickTxPowerUsesRFSubsys((capabilities::etl *)Uplink);
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (!v13)
  {
    if (FreeSpace >= 4)
    {
      int v35 = 2620747;
      if (!HDLCFrameInject()) {
        goto LABEL_7;
      }
      goto LABEL_14;
    }
LABEL_26:
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v15, v16, v17, v18, v19, v20, FreeSpace);
    goto LABEL_10;
  }
  if (FreeSpace < 4) {
    goto LABEL_26;
  }
  int v35 = 1375051;
  if (!HDLCFrameInject())
  {
LABEL_7:
    int v21 = "ETLSubsysAddHeaderInternal";
    int v22 = "Failed to inject\n";
LABEL_9:
    _ETLDebugPrint((uint64_t)v21, (uint64_t)v22, (uint64_t)a3, a4, a5, a6, a7, a8, v29);
LABEL_10:
    MaxTxPowerResponse = 0;
    goto LABEL_11;
  }
LABEL_14:
  MaxTxPowerResponse = malloc((2 * DWORD2(v32) + 32));
  if (!MaxTxPowerResponse) {
    goto LABEL_11;
  }
  uint64_t v25 = HDLCFrameEncode();
  if (!v25) {
    goto LABEL_27;
  }
  uint64_t v26 = v25;
  int v35 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, MaxTxPowerResponse, v25);
  }
  if (!*a1)
  {
LABEL_27:
    free(MaxTxPowerResponse);
    goto LABEL_10;
  }
  int v27 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, MaxTxPowerResponse, v26, &v35, 1, a4, 0);
  int v28 = v35;
  free(MaxTxPowerResponse);
  MaxTxPowerResponse = 0;
  if (v27 && v28 == v26)
  {
    LOBYTE(v35) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    MaxTxPowerResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v30, (uint64_t)&_ETLResponseRingBuffer, &v35, a4)&& v35 == 75)
    {
      MaxTxPowerResponse = (void *)ETLMaverickParseGetMaxTxPowerResponse((capabilities::etl *)v30, a2, a3);
    }
  }
LABEL_11:
  HDLCFrameFree();
  HDLCFrameFree();
  return MaxTxPowerResponse;
}

void *ETLMaverickSetAutoAnswer(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  long long v37 = 0u;
  long long v38 = 0u;
  uint64_t v39 = 0;
  memset(v35, 0, sizeof(v35));
  uint64_t v36 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v31 = "ETLMaverickSetAutoAnswer";
    long long v32 = "Failed to create command frame\n";
LABEL_21:
    _ETLDebugPrint((uint64_t)v31, (uint64_t)v32, v6, v7, v8, v9, v10, v11, v34);
    goto LABEL_22;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
LABEL_22:
    uint64_t v19 = 0;
    goto LABEL_23;
  }
  int v40 = 2686283;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v31 = "ETLSubsysAddHeaderInternal";
    long long v32 = "Failed to inject\n";
    goto LABEL_21;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v34 = 2;
    uint64_t v31 = "ETLMaverickCreateSetAutoAnswerCommand";
    long long v32 = "Not enough room, need %zu, have %u\n";
    goto LABEL_21;
  }
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  uint64_t v19 = malloc((2 * DWORD2(v37) + 32));
  if (!v19) {
    goto LABEL_23;
  }
  uint64_t v20 = HDLCFrameEncode();
  if (!v20) {
    goto LABEL_24;
  }
  uint64_t v21 = v20;
  int v40 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v19, v20);
  }
  if (!*a1)
  {
LABEL_24:
    free(v19);
    goto LABEL_22;
  }
  int v22 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v19, v21, &v40, 1, a4, 0);
  int v23 = v40;
  free(v19);
  uint64_t v19 = 0;
  if (v22 && v23 == v21)
  {
    LOBYTE(v40) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    uint64_t v19 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v35, (uint64_t)&_ETLResponseRingBuffer, &v40, a4)&& v40 == 75)
    {
      uint64_t v19 = (void *)ETLMaverickParseSetAutoAnswerResponse((unsigned int *)v35, v24, v25, v26, v27, v28, v29, v30);
    }
  }
LABEL_23:
  HDLCFrameFree();
  HDLCFrameFree();
  return v19;
}

void *ETLMaverickCheckCalibration(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v43 = 0;
    long long v41 = 0u;
    long long v42 = 0u;
    memset(v39, 0, sizeof(v39));
    uint64_t v40 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
        goto LABEL_22;
      }
      int v44 = 3210571;
      if (HDLCFrameInject())
      {
        uint64_t v24 = malloc((2 * DWORD2(v41) + 32));
        if (!v24)
        {
LABEL_23:
          HDLCFrameFree();
          HDLCFrameFree();
          return v24;
        }
        uint64_t v25 = HDLCFrameEncode();
        if (v25)
        {
          uint64_t v26 = v25;
          int v44 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v24, v25);
          }
          if (*a1)
          {
            int v27 = (*a1)(a1, v24, v26, &v44, 1, a3, 0);
            int v28 = v44;
            free(v24);
            uint64_t v24 = 0;
            if (v27 && v28 == v26)
            {
              LOBYTE(v44) = 75;
              if (!_ETLResponseRingBuffer) {
                TelephonyUtilRingBufferInitialize();
              }
              uint64_t v24 = 0;
              if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v39, (uint64_t)&_ETLResponseRingBuffer, &v44, a3)&& v44 == 75)
              {
                uint64_t v24 = (void *)ETLMaverickParseCalibrationCheckResonse((capabilities::radio *)v39, a2, v29, v30, v31, v32, v33, v34);
              }
            }
            goto LABEL_23;
          }
        }
        free(v24);
LABEL_22:
        uint64_t v24 = 0;
        goto LABEL_23;
      }
      int v35 = "ETLSubsysAddHeaderInternal";
      uint64_t v36 = "Failed to inject\n";
    }
    else
    {
      int v35 = "ETLMaverickCheckCalibration";
      uint64_t v36 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v35, (uint64_t)v36, v11, v12, v13, v14, v15, v16, v38);
    goto LABEL_22;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickCheckCalibration", (uint64_t)"Calibration status pointer is NULL, skipping calibration check\n", a3, a4, a5, a6, a7, a8, v38);
  return 0;
}

void *ETLMaverickCheckCalibrationV2(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v43 = 0;
    long long v41 = 0u;
    long long v42 = 0u;
    memset(v39, 0, sizeof(v39));
    uint64_t v40 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v19, v20, v21, v22, v23, v24, FreeSpace);
        goto LABEL_22;
      }
      LOWORD(v44) = -1205;
      HIWORD(v44) = a4;
      if (HDLCFrameInject())
      {
        uint64_t v25 = malloc((2 * DWORD2(v41) + 32));
        if (!v25)
        {
LABEL_23:
          HDLCFrameFree();
          HDLCFrameFree();
          return v25;
        }
        uint64_t v26 = HDLCFrameEncode();
        if (v26)
        {
          uint64_t v27 = v26;
          int v44 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v25, v26);
          }
          if (*a1)
          {
            int v28 = (*a1)(a1, v25, v27, &v44, 1, a3, 0);
            int v29 = v44;
            free(v25);
            uint64_t v25 = 0;
            if (v28 && v29 == v27)
            {
              LOBYTE(v44) = 75;
              if (!_ETLResponseRingBuffer) {
                TelephonyUtilRingBufferInitialize();
              }
              uint64_t v25 = 0;
              if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v39, (uint64_t)&_ETLResponseRingBuffer, &v44, a3)&& v44 == 75)
              {
                uint64_t v25 = (void *)ETLMaverickParseCalibrationCheckResponseV2((capabilities::radio *)v39, a2, a4, v30, v31, v32, v33, v34);
              }
            }
            goto LABEL_23;
          }
        }
        free(v25);
LABEL_22:
        uint64_t v25 = 0;
        goto LABEL_23;
      }
      int v35 = "ETLSubsysAddHeaderInternal";
      uint64_t v36 = "Failed to inject\n";
    }
    else
    {
      int v35 = "ETLMaverickCheckCalibrationV2";
      uint64_t v36 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v35, (uint64_t)v36, v12, v13, v14, v15, v16, v17, v38);
    goto LABEL_22;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickCheckCalibrationV2", (uint64_t)"Calibration status pointer is NULL, skipping calibration check\n", a3, a4, a5, a6, a7, a8, v38);
  return 0;
}

uint64_t ETLMaverickParseICCIDResponse(int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  uint64_t v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 253)
      {
        uint64_t v12 = HIWORD(v11);
        if (v12 == a3)
        {
          if (v9 <= 0xB)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseICCIDResponse", (uint64_t)"Received response has only %u bytes, need %u\n", a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else if (*((_WORD *)v10 + 2) == 1)
          {
            uint64_t v13 = *(void *)((char *)v10 + 6);
            *(_WORD *)(a2 + 8) = *((_WORD *)v10 + 7);
            *(void *)a2 = v13;
            return 1;
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseICCIDResponse", (uint64_t)"Received response with failure status [%d]\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v10 + 2));
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickParseIMEIResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a2) {
    goto LABEL_16;
  }
  unsigned int v10 = a1[2];
  unsigned int v11 = v10 - 4;
  if (v10 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
LABEL_16:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseIMEIResponse", (uint64_t)"status: %d, success: %s, offset:%d\n", a3, a4, a5, a6, a7, a8, 0);
    return 0;
  }
  uint64_t v12 = *(unsigned int **)a1;
  unsigned int v13 = **(_DWORD **)a1;
  if (v13 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
    goto LABEL_16;
  }
  if (BYTE1(v13) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v13));
    goto LABEL_16;
  }
  uint64_t v14 = HIWORD(v13);
  if (v14 != 12)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v14);
    goto LABEL_16;
  }
  if (v11 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
    goto LABEL_16;
  }
  uint64_t v15 = *((unsigned __int16 *)v12 + 2);
  if (v15 != 34)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, v15);
    goto LABEL_16;
  }
  uint64_t v16 = *((unsigned __int16 *)v12 + 3);
  _ETLDebugPrint((uint64_t)"ETLMaverickParseIMEIResponse", (uint64_t)"status: %d, success: %s, offset:%d\n", a3, a4, a5, a6, a7, a8, v16);
  if (v16)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseIMEIResponse", (uint64_t)"status is %d\n", v17, v18, v19, v20, v21, v22, v16);
    return 0;
  }
  if (a1[2] - 8 < 0xA) {
    return 0;
  }
  if (!*(unsigned char *)(*(void *)a1 + 9))
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseIMEIResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v17, v18, v19, v20, v21, v22, a1[2] - 8);
    return 0;
  }
  uint64_t v24 = *(void *)(*(void *)a1 + 9);
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(*(void *)a1 + 17);
  *(void *)a2 = v24;
  return 1;
}

void *ETLMaverickGetICCIDExt(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v34 = 0u;
  long long v35 = 0u;
  uint64_t v36 = 0;
  memset(v32, 0, sizeof(v32));
  uint64_t v33 = 0;
  if (!a2 || (HDLCFrameCreateUplink() & 1) == 0)
  {
    int v28 = "ETLMaverickGetICCIDExt";
    int v29 = "Failed to create command frame\n";
LABEL_19:
    _ETLDebugPrint((uint64_t)v28, (uint64_t)v29, a3, a4, a5, a6, a7, a8, v31);
    goto LABEL_20;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
    goto LABEL_20;
  }
  int v37 = 5438795;
  if ((HDLCFrameInject() & 1) == 0)
  {
    int v28 = "ETLSubsysAddHeaderInternal";
    int v29 = "Failed to inject\n";
    goto LABEL_19;
  }
  if (!HDLCFrameInjectUnsignedChar())
  {
LABEL_20:
    uint64_t v18 = 0;
    goto LABEL_21;
  }
  uint64_t v18 = malloc((2 * DWORD2(v34) + 32));
  if (!v18) {
    goto LABEL_21;
  }
  uint64_t v19 = HDLCFrameEncode();
  if (!v19) {
    goto LABEL_24;
  }
  uint64_t v20 = v19;
  int v37 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v18, v19);
  }
  if (!*a1)
  {
LABEL_24:
    free(v18);
    goto LABEL_20;
  }
  int v21 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v18, v20, &v37, 1, a4, 0);
  int v22 = v37;
  free(v18);
  uint64_t v18 = 0;
  if (v21 && v22 == v20)
  {
    LOBYTE(v37) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    uint64_t v18 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v32, (uint64_t)&_ETLResponseRingBuffer, &v37, a4)&& v37 == 75)
    {
      uint64_t v18 = (void *)ETLMaverickParseICCIDResponse((int **)v32, a2, 82, v23, v24, v25, v26, v27);
    }
  }
LABEL_21:
  HDLCFrameFree();
  HDLCFrameFree();
  return v18;
}

void *ETLMaverickGetIMEI(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v28 = 0;
    long long v26 = 0u;
    long long v27 = 0u;
    memset(v24, 0, sizeof(v24));
    uint64_t v25 = 0;
    if (HDLCFrameCreateUplink())
    {
      if (ETLMaverickAddSecurityCommandHeader() && HDLCFrameInjectUnsignedChar())
      {
        unsigned int v11 = malloc((2 * DWORD2(v26) + 32));
        if (!v11)
        {
LABEL_22:
          HDLCFrameFree();
          HDLCFrameFree();
          return v11;
        }
        uint64_t v12 = HDLCFrameEncode();
        if (v12)
        {
          uint64_t v13 = v12;
          int v29 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v11, v12);
          }
          if (*a1)
          {
            int v14 = (*a1)(a1, v11, v13, &v29, 1, a4, 0);
            int v15 = v29;
            free(v11);
            unsigned int v11 = 0;
            if (v14 && v15 == v13)
            {
              LOBYTE(v29) = 75;
              if (!_ETLResponseRingBuffer) {
                TelephonyUtilRingBufferInitialize();
              }
              unsigned int v11 = 0;
              if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v24, (uint64_t)&_ETLResponseRingBuffer, &v29, a4)&& v29 == 75)
              {
                unsigned int v11 = (void *)ETLMaverickParseIMEIResponse((unsigned int *)v24, a2, v16, v17, v18, v19, v20, v21);
              }
            }
            goto LABEL_22;
          }
        }
        free(v11);
      }
      unsigned int v11 = 0;
      goto LABEL_22;
    }
    int v22 = "Failed to create command frame\n";
  }
  else
  {
    int v22 = "imei is null\n";
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickGetIMEI", (uint64_t)v22, a3, a4, a5, a6, a7, a8, *(uint64_t *)&v24[0]);
  return 0;
}

uint64_t ETLMaverickGetFactoryCalibrationStatus(void *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v37 = 0u;
  long long v38 = 0u;
  uint64_t v39 = 0;
  memset(v35, 0, sizeof(v35));
  uint64_t v36 = 0;
  if (!a2 || (HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v31 = "ETLMaverickGetFactoryCalibrationStatus";
    uint64_t v32 = "Failed to create command frame\n";
LABEL_24:
    _ETLDebugPrint((uint64_t)v31, (uint64_t)v32, a3, a4, a5, a6, a7, a8, v34);
    goto LABEL_25;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
    goto LABEL_25;
  }
  int v40 = 3734347;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v31 = "ETLSubsysAddHeaderInternal";
    uint64_t v32 = "Failed to inject\n";
    goto LABEL_24;
  }
  uint64_t v18 = (uint64_t)malloc((2 * DWORD2(v37) + 32));
  if (v18)
  {
    uint64_t v19 = HDLCFrameEncode();
    if (!v19) {
      goto LABEL_29;
    }
    uint64_t v20 = v19;
    int v40 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v18, v19);
    }
    if (!*a1)
    {
LABEL_29:
      free((void *)v18);
      goto LABEL_25;
    }
    int v21 = ((uint64_t (*)(void *, uint64_t, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v18, v20, &v40, 1, a3, 0);
    int v22 = v40;
    free((void *)v18);
    uint64_t v18 = 0;
    if (v21)
    {
      if (v22 == v20)
      {
        LOBYTE(v40) = 75;
        if (!_ETLResponseRingBuffer) {
          TelephonyUtilRingBufferInitialize();
        }
        uint64_t v18 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v35, (uint64_t)&_ETLResponseRingBuffer, &v40, a3))
        {
          if (v40 == 75)
          {
            if (DWORD2(v35[0]) < 4)
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v23, v24, v25, v26, v27, v28, DWORD2(v35[0]));
            }
            else
            {
              unsigned int v29 = **(_DWORD **)&v35[0];
              if (**(_DWORD **)&v35[0] == 75)
              {
                if (BYTE1(v29) == 251)
                {
                  uint64_t v30 = HIWORD(v29);
                  if (v30 == 56)
                  {
                    if ((DWORD2(v35[0]) - 4) <= 3)
                    {
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseGetFactoryCalibrationStatus", (uint64_t)"Received response has only %u bytes, need %u\n", v23, v24, v25, v26, v27, v28, (DWORD2(v35[0]) - 4));
                    }
                    else
                    {
                      if (*(_WORD *)(*(void *)&v35[0] + 4) == 1)
                      {
                        *a2 = *(unsigned __int16 *)(*(void *)&v35[0] + 6);
                        uint64_t v18 = 1;
                        goto LABEL_26;
                      }
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseGetFactoryCalibrationStatus", (uint64_t)"Received response with failure status [%d]\n", v23, v24, v25, v26, v27, v28, *(unsigned __int16 *)(*(void *)&v35[0] + 4));
                    }
                  }
                  else
                  {
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v23, v24, v25, v26, v27, v28, v30);
                  }
                }
                else
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v23, v24, v25, v26, v27, v28, BYTE1(v29));
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v23, v24, v25, v26, v27, v28, **(_DWORD **)&v35[0]);
              }
            }
LABEL_25:
            uint64_t v18 = 0;
          }
        }
      }
    }
  }
LABEL_26:
  HDLCFrameFree();
  HDLCFrameFree();
  return v18;
}

uint64_t ETLMaverickGetRAT(void *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && a2)
  {
    long long v54 = 0u;
    long long v55 = 0u;
    uint64_t v56 = 0;
    memset(v52, 0, sizeof(v52));
    uint64_t v53 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        unsigned int v57 = 4521291;
        if (HDLCFrameInject())
        {
          if (!HDLCFrameGetFreeSpace())
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandGetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v30, v31, v32, v33, v34, v35, 2);
            goto LABEL_27;
          }
          HDLCFrameInjectUnsignedChar();
          uint64_t v36 = (uint64_t)malloc((2 * DWORD2(v54) + 32));
          if (!v36)
          {
LABEL_28:
            HDLCFrameFree();
            HDLCFrameFree();
            return v36;
          }
          uint64_t v37 = HDLCFrameEncode();
          if (!v37) {
            goto LABEL_31;
          }
          uint64_t v38 = v37;
          unsigned int v57 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
          }
          if (!*a1)
          {
LABEL_31:
            free((void *)v36);
            goto LABEL_27;
          }
          int v39 = ((uint64_t (*)(void *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v36, v38, &v57, 1, a3, 0);
          unsigned int v40 = v57;
          free((void *)v36);
          uint64_t v36 = 0;
          if (!v39 || v40 != v38) {
            goto LABEL_28;
          }
          LOBYTE(v57) = 75;
          if (!_ETLResponseRingBuffer) {
            TelephonyUtilRingBufferInitialize();
          }
          uint64_t v36 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v52, (uint64_t)&_ETLResponseRingBuffer, &v57, a3)|| v57 != 75)
          {
            goto LABEL_28;
          }
          unsigned int v57 = 0;
          if (ETLMaverickParseBSPExtResponse((uint64_t)v52, &v57, v41, v42, v43, v44, v45, v46))
          {
            uint64_t v47 = DWORD2(v52[0]) - v57;
            if (v47 > 1)
            {
              *a2 = *(_WORD *)(*(void *)&v52[0] + v57);
              uint64_t v36 = 1;
              goto LABEL_28;
            }
            _ETLDebugPrint((uint64_t)"ETLMaverickParseGetRATSelectionResponse", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v11, v12, v13, v14, v15, v16, v47);
LABEL_27:
            uint64_t v36 = 0;
            goto LABEL_28;
          }
          uint64_t v48 = "ETLMaverickParseGetRATSelectionResponse";
          long long v49 = "Failed on parsing BSP Ext Response.\n";
LABEL_26:
          _ETLDebugPrint((uint64_t)v48, (uint64_t)v49, v11, v12, v13, v14, v15, v16, v51);
          goto LABEL_27;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v51);
      }
      uint64_t v48 = "ETLMaverickAddBSPExtCommandGetHeader";
      long long v49 = "Failed on creating BSP Command Heder\n";
      goto LABEL_26;
    }
    uint64_t v48 = "ETLMaverickGetRAT";
    long long v49 = "Failed to create command frame\n";
    goto LABEL_26;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickGetRAT", (uint64_t)"Transport or ratSelection memory cannot be NULL\n", a3, a4, a5, a6, a7, a8, v51);
  return 0;
}

uint64_t ETLMaverickSetRAT(void *a1, unsigned __int16 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    long long v55 = 0u;
    long long v56 = 0u;
    uint64_t v57 = 0;
    memset(v53, 0, sizeof(v53));
    uint64_t v54 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        unsigned int v58 = 4521291;
        if (HDLCFrameInject())
        {
          if (HDLCFrameGetFreeSpace() <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandSetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v30, v31, v32, v33, v34, v35, 2);
            goto LABEL_27;
          }
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInjectUnsignedChar();
          uint64_t v36 = (uint64_t)malloc((2 * DWORD2(v55) + 32));
          if (!v36)
          {
LABEL_28:
            HDLCFrameFree();
            HDLCFrameFree();
            return v36;
          }
          uint64_t v37 = HDLCFrameEncode();
          if (!v37) {
            goto LABEL_31;
          }
          uint64_t v38 = v37;
          unsigned int v58 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
          }
          if (!*a1)
          {
LABEL_31:
            free((void *)v36);
            goto LABEL_27;
          }
          int v39 = ((uint64_t (*)(void *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v36, v38, &v58, 1, a3, 0);
          unsigned int v40 = v58;
          free((void *)v36);
          uint64_t v36 = 0;
          if (!v39 || v40 != v38) {
            goto LABEL_28;
          }
          LOBYTE(v58) = 75;
          if (!_ETLResponseRingBuffer) {
            TelephonyUtilRingBufferInitialize();
          }
          uint64_t v36 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v53, (uint64_t)&_ETLResponseRingBuffer, &v58, a3)|| v58 != 75)
          {
            goto LABEL_28;
          }
          unsigned int v58 = 0;
          if (ETLMaverickParseBSPExtResponse((uint64_t)v53, &v58, v41, v42, v43, v44, v45, v46))
          {
            uint64_t v47 = DWORD2(v53[0]) - v58;
            if (v47 <= 1)
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSetRATSelectionResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v11, v12, v13, v14, v15, v16, v47);
            }
            else
            {
              uint64_t v48 = *(unsigned __int16 *)(*(void *)&v53[0] + v58);
              if (v48 == a2)
              {
                uint64_t v36 = 1;
                goto LABEL_28;
              }
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSetRATSelectionResponse", (uint64_t)"Received rat selection %d doesn't match with %d\n", v11, v12, v13, v14, v15, v16, v48);
            }
LABEL_27:
            uint64_t v36 = 0;
            goto LABEL_28;
          }
          long long v49 = "ETLMaverickParseSetRATSelectionResponse";
          int v50 = "Failed on parsing BSP Ext Response.\n";
LABEL_26:
          _ETLDebugPrint((uint64_t)v49, (uint64_t)v50, v11, v12, v13, v14, v15, v16, v52);
          goto LABEL_27;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v52);
      }
      long long v49 = "ETLMaverickAddBSPExtCommandSetHeader";
      int v50 = "Failed on creating BSP Command Heder\n";
      goto LABEL_26;
    }
    long long v49 = "ETLMaverickSetRAT";
    int v50 = "Failed to create command frame\n";
    goto LABEL_26;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickSetRAT", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v52);
  return 0;
}

uint64_t ETLMaverickGetBBMode(void *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && a2)
  {
    long long v54 = 0u;
    long long v55 = 0u;
    uint64_t v56 = 0;
    memset(v52, 0, sizeof(v52));
    uint64_t v53 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        unsigned int v57 = 4521291;
        if (HDLCFrameInject())
        {
          if (!HDLCFrameGetFreeSpace())
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandGetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v30, v31, v32, v33, v34, v35, 2);
            goto LABEL_27;
          }
          HDLCFrameInjectUnsignedChar();
          uint64_t v36 = (uint64_t)malloc((2 * DWORD2(v54) + 32));
          if (!v36)
          {
LABEL_28:
            HDLCFrameFree();
            HDLCFrameFree();
            return v36;
          }
          uint64_t v37 = HDLCFrameEncode();
          if (!v37) {
            goto LABEL_31;
          }
          uint64_t v38 = v37;
          unsigned int v57 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
          }
          if (!*a1)
          {
LABEL_31:
            free((void *)v36);
            goto LABEL_27;
          }
          int v39 = ((uint64_t (*)(void *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v36, v38, &v57, 1, a3, 0);
          unsigned int v40 = v57;
          free((void *)v36);
          uint64_t v36 = 0;
          if (!v39 || v40 != v38) {
            goto LABEL_28;
          }
          LOBYTE(v57) = 75;
          if (!_ETLResponseRingBuffer) {
            TelephonyUtilRingBufferInitialize();
          }
          uint64_t v36 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v52, (uint64_t)&_ETLResponseRingBuffer, &v57, a3)|| v57 != 75)
          {
            goto LABEL_28;
          }
          unsigned int v57 = 0;
          if (ETLMaverickParseBSPExtResponse((uint64_t)v52, &v57, v41, v42, v43, v44, v45, v46))
          {
            uint64_t v47 = DWORD2(v52[0]) - v57;
            if (v47 > 1)
            {
              *a2 = *(_WORD *)(*(void *)&v52[0] + v57);
              uint64_t v36 = 1;
              goto LABEL_28;
            }
            _ETLDebugPrint((uint64_t)"ETLMaverickParseGetBBModeResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v11, v12, v13, v14, v15, v16, v47);
LABEL_27:
            uint64_t v36 = 0;
            goto LABEL_28;
          }
          uint64_t v48 = "ETLMaverickParseGetBBModeResponse";
          long long v49 = "Failed on parsing BSP Ext Response.\n";
LABEL_26:
          _ETLDebugPrint((uint64_t)v48, (uint64_t)v49, v11, v12, v13, v14, v15, v16, v51);
          goto LABEL_27;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v51);
      }
      uint64_t v48 = "ETLMaverickAddBSPExtCommandGetHeader";
      long long v49 = "Failed on creating BSP Command Heder\n";
      goto LABEL_26;
    }
    uint64_t v48 = "ETLMaverickGetBBMode";
    long long v49 = "Failed to create command frame\n";
    goto LABEL_26;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickGetBBMode", (uint64_t)"Transport or mode memory cannot be NULL\n", a3, a4, a5, a6, a7, a8, v51);
  return 0;
}

uint64_t ETLMaverickSetBBMode(void *a1, unsigned __int8 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    long long v55 = 0u;
    long long v56 = 0u;
    uint64_t v57 = 0;
    memset(v53, 0, sizeof(v53));
    uint64_t v54 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        unsigned int v58 = 4521291;
        if (HDLCFrameInject())
        {
          if (HDLCFrameGetFreeSpace() <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandSetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v30, v31, v32, v33, v34, v35, 2);
            goto LABEL_27;
          }
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInjectUnsignedChar();
          uint64_t v36 = (uint64_t)malloc((2 * DWORD2(v55) + 32));
          if (!v36)
          {
LABEL_28:
            HDLCFrameFree();
            HDLCFrameFree();
            return v36;
          }
          uint64_t v37 = HDLCFrameEncode();
          if (!v37) {
            goto LABEL_31;
          }
          uint64_t v38 = v37;
          unsigned int v58 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
          }
          if (!*a1)
          {
LABEL_31:
            free((void *)v36);
            goto LABEL_27;
          }
          int v39 = ((uint64_t (*)(void *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v36, v38, &v58, 1, a3, 0);
          unsigned int v40 = v58;
          free((void *)v36);
          uint64_t v36 = 0;
          if (!v39 || v40 != v38) {
            goto LABEL_28;
          }
          LOBYTE(v58) = 75;
          if (!_ETLResponseRingBuffer) {
            TelephonyUtilRingBufferInitialize();
          }
          uint64_t v36 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v53, (uint64_t)&_ETLResponseRingBuffer, &v58, a3)|| v58 != 75)
          {
            goto LABEL_28;
          }
          unsigned int v58 = 0;
          if (ETLMaverickParseBSPExtResponse((uint64_t)v53, &v58, v41, v42, v43, v44, v45, v46))
          {
            uint64_t v47 = DWORD2(v53[0]) - v58;
            if (v47 <= 1)
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSetBBModeResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v11, v12, v13, v14, v15, v16, v47);
            }
            else
            {
              uint64_t v48 = *(unsigned __int8 *)(*(void *)&v53[0] + v58);
              if (a2 == v48)
              {
                uint64_t v36 = 1;
                goto LABEL_28;
              }
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSetBBModeResponse", (uint64_t)"Received mode %d doesn't match with %d\n", v11, v12, v13, v14, v15, v16, v48);
            }
LABEL_27:
            uint64_t v36 = 0;
            goto LABEL_28;
          }
          long long v49 = "ETLMaverickParseSetBBModeResponse";
          int v50 = "Failed on parsing BSP Ext Response.\n";
LABEL_26:
          _ETLDebugPrint((uint64_t)v49, (uint64_t)v50, v11, v12, v13, v14, v15, v16, v52);
          goto LABEL_27;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v52);
      }
      long long v49 = "ETLMaverickAddBSPExtCommandSetHeader";
      int v50 = "Failed on creating BSP Command Heder\n";
      goto LABEL_26;
    }
    long long v49 = "ETLMaverickSetBBMode";
    int v50 = "Failed to create command frame\n";
    goto LABEL_26;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickSetBBMode", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v52);
  return 0;
}

uint64_t ETLMaverickGetAutoAnswerBSP(void *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && a2)
  {
    long long v54 = 0u;
    long long v55 = 0u;
    uint64_t v56 = 0;
    memset(v52, 0, sizeof(v52));
    uint64_t v53 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        unsigned int v57 = 4521291;
        if (HDLCFrameInject())
        {
          if (!HDLCFrameGetFreeSpace())
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandGetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v30, v31, v32, v33, v34, v35, 2);
            goto LABEL_27;
          }
          HDLCFrameInjectUnsignedChar();
          uint64_t v36 = (uint64_t)malloc((2 * DWORD2(v54) + 32));
          if (!v36)
          {
LABEL_28:
            HDLCFrameFree();
            HDLCFrameFree();
            return v36;
          }
          uint64_t v37 = HDLCFrameEncode();
          if (!v37) {
            goto LABEL_31;
          }
          uint64_t v38 = v37;
          unsigned int v57 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
          }
          if (!*a1)
          {
LABEL_31:
            free((void *)v36);
            goto LABEL_27;
          }
          int v39 = ((uint64_t (*)(void *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v36, v38, &v57, 1, a3, 0);
          unsigned int v40 = v57;
          free((void *)v36);
          uint64_t v36 = 0;
          if (!v39 || v40 != v38) {
            goto LABEL_28;
          }
          LOBYTE(v57) = 75;
          if (!_ETLResponseRingBuffer) {
            TelephonyUtilRingBufferInitialize();
          }
          uint64_t v36 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v52, (uint64_t)&_ETLResponseRingBuffer, &v57, a3)|| v57 != 75)
          {
            goto LABEL_28;
          }
          unsigned int v57 = 0;
          if (ETLMaverickParseBSPExtResponse((uint64_t)v52, &v57, v41, v42, v43, v44, v45, v46))
          {
            uint64_t v47 = DWORD2(v52[0]) - v57;
            if (v47 > 1)
            {
              *a2 = *(_WORD *)(*(void *)&v52[0] + v57);
              uint64_t v36 = 1;
              goto LABEL_28;
            }
            _ETLDebugPrint((uint64_t)"ETLMaverickParseGetAutoAnswerResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v11, v12, v13, v14, v15, v16, v47);
LABEL_27:
            uint64_t v36 = 0;
            goto LABEL_28;
          }
          uint64_t v48 = "ETLMaverickParseGetAutoAnswerResponse";
          long long v49 = "Failed on parsing BSP Ext Response.\n";
LABEL_26:
          _ETLDebugPrint((uint64_t)v48, (uint64_t)v49, v11, v12, v13, v14, v15, v16, v51);
          goto LABEL_27;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v51);
      }
      uint64_t v48 = "ETLMaverickAddBSPExtCommandGetHeader";
      long long v49 = "Failed on creating BSP Command Heder\n";
      goto LABEL_26;
    }
    uint64_t v48 = "ETLMaverickGetAutoAnswerBSP";
    long long v49 = "Failed to create command frame\n";
    goto LABEL_26;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickGetAutoAnswerBSP", (uint64_t)"Transport or autoAnswer memory cannot be NULL\n", a3, a4, a5, a6, a7, a8, v51);
  return 0;
}

uint64_t ETLMaverickSetAutoAnswerBSP(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    long long v54 = 0u;
    long long v55 = 0u;
    uint64_t v56 = 0;
    memset(v52, 0, sizeof(v52));
    uint64_t v53 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        unsigned int v57 = 4521291;
        if (HDLCFrameInject())
        {
          if (HDLCFrameGetFreeSpace() <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandSetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v30, v31, v32, v33, v34, v35, 2);
            goto LABEL_27;
          }
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInjectUnsignedChar();
          uint64_t v36 = (uint64_t)malloc((2 * DWORD2(v54) + 32));
          if (!v36)
          {
LABEL_28:
            HDLCFrameFree();
            HDLCFrameFree();
            return v36;
          }
          uint64_t v37 = HDLCFrameEncode();
          if (!v37) {
            goto LABEL_31;
          }
          uint64_t v38 = v37;
          unsigned int v57 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
          }
          if (!*a1)
          {
LABEL_31:
            free((void *)v36);
            goto LABEL_27;
          }
          int v39 = ((uint64_t (*)(void *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v36, v38, &v57, 1, a3, 0);
          unsigned int v40 = v57;
          free((void *)v36);
          uint64_t v36 = 0;
          if (!v39 || v40 != v38) {
            goto LABEL_28;
          }
          LOBYTE(v57) = 75;
          if (!_ETLResponseRingBuffer) {
            TelephonyUtilRingBufferInitialize();
          }
          uint64_t v36 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v52, (uint64_t)&_ETLResponseRingBuffer, &v57, a3)|| v57 != 75)
          {
            goto LABEL_28;
          }
          unsigned int v57 = 0;
          if (ETLMaverickParseBSPExtResponse((uint64_t)v52, &v57, v41, v42, v43, v44, v45, v46))
          {
            uint64_t v47 = DWORD2(v52[0]) - v57;
            if (v47 <= 1)
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSetAutoAnswerBSPResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v11, v12, v13, v14, v15, v16, v47);
            }
            else
            {
              if (*(unsigned __int16 *)(*(void *)&v52[0] + v57) == a2)
              {
                uint64_t v36 = 1;
                goto LABEL_28;
              }
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSetAutoAnswerBSPResponse", (uint64_t)"Received mode %d doesn't match with %d\n", v11, v12, v13, v14, v15, v16, *(unsigned __int16 *)(*(void *)&v52[0] + v57));
            }
LABEL_27:
            uint64_t v36 = 0;
            goto LABEL_28;
          }
          uint64_t v48 = "ETLMaverickParseSetAutoAnswerBSPResponse";
          long long v49 = "Failed on parsing BSP Ext Response.\n";
LABEL_26:
          _ETLDebugPrint((uint64_t)v48, (uint64_t)v49, v11, v12, v13, v14, v15, v16, v51);
          goto LABEL_27;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v51);
      }
      uint64_t v48 = "ETLMaverickAddBSPExtCommandSetHeader";
      long long v49 = "Failed on creating BSP Command Heder\n";
      goto LABEL_26;
    }
    uint64_t v48 = "ETLMaverickSetAutoAnswerBSP";
    long long v49 = "Failed to create command frame\n";
    goto LABEL_26;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickSetAutoAnswerBSP", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v51);
  return 0;
}

uint64_t ETLMaverickGetNasSec(void *a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && a2)
  {
    long long v55 = 0u;
    long long v56 = 0u;
    uint64_t v57 = 0;
    memset(v53, 0, sizeof(v53));
    uint64_t v54 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        unsigned int v58 = 4521291;
        if (HDLCFrameInject())
        {
          if (!HDLCFrameGetFreeSpace())
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandGetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v30, v31, v32, v33, v34, v35, 2);
            goto LABEL_28;
          }
          HDLCFrameInjectUnsignedChar();
          uint64_t v36 = (uint64_t)malloc((2 * DWORD2(v55) + 32));
          if (!v36)
          {
LABEL_29:
            HDLCFrameFree();
            HDLCFrameFree();
            return v36;
          }
          uint64_t v37 = HDLCFrameEncode();
          if (!v37) {
            goto LABEL_32;
          }
          uint64_t v38 = v37;
          unsigned int v58 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
          }
          if (!*a1)
          {
LABEL_32:
            free((void *)v36);
            goto LABEL_28;
          }
          int v39 = ((uint64_t (*)(void *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v36, v38, &v58, 1, a3, 0);
          unsigned int v40 = v58;
          free((void *)v36);
          uint64_t v36 = 0;
          if (!v39 || v40 != v38) {
            goto LABEL_29;
          }
          LOBYTE(v58) = 75;
          if (!_ETLResponseRingBuffer) {
            TelephonyUtilRingBufferInitialize();
          }
          uint64_t v36 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v53, (uint64_t)&_ETLResponseRingBuffer, &v58, a3)|| v58 != 75)
          {
            goto LABEL_29;
          }
          unsigned int v58 = 0;
          if (ETLMaverickParseBSPExtResponse((uint64_t)v53, &v58, v41, v42, v43, v44, v45, v46))
          {
            uint64_t v47 = DWORD2(v53[0]) - v58;
            if (v47 <= 1)
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseGetNasSecResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v11, v12, v13, v14, v15, v16, v47);
            }
            else
            {
              uint64_t v48 = (unsigned char *)(*(void *)&v53[0] + v58);
              if (*v48 == 10)
              {
                *a2 = v48[1];
                uint64_t v36 = 1;
                goto LABEL_29;
              }
              _ETLDebugPrint((uint64_t)"ETLMaverickParseGetNasSecResponse", (uint64_t)"Expected NAS Sec ID, %u, does not match with read ID, %u\n", v11, v12, v13, v14, v15, v16, 11);
            }
LABEL_28:
            uint64_t v36 = 0;
            goto LABEL_29;
          }
          long long v49 = "ETLMaverickParseGetNasSecResponse";
          int v50 = "Failed on parsing BSP Ext Response.\n";
LABEL_27:
          _ETLDebugPrint((uint64_t)v49, (uint64_t)v50, v11, v12, v13, v14, v15, v16, v52);
          goto LABEL_28;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v52);
      }
      long long v49 = "ETLMaverickAddBSPExtCommandGetHeader";
      int v50 = "Failed on creating BSP Command Heder\n";
      goto LABEL_27;
    }
    long long v49 = "ETLMaverickGetNasSec";
    int v50 = "Failed to create command frame\n";
    goto LABEL_27;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickGetNasSec", (uint64_t)"Transport or nasStatus memory cannot be NULL\n", a3, a4, a5, a6, a7, a8, v52);
  return 0;
}

uint64_t ETLMaverickSetNasSec(void *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    long long v55 = 0u;
    long long v56 = 0u;
    uint64_t v57 = 0;
    memset(v53, 0, sizeof(v53));
    uint64_t v54 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        unsigned int v58 = 4521291;
        if (HDLCFrameInject())
        {
          if (HDLCFrameGetFreeSpace() <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandSetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v30, v31, v32, v33, v34, v35, 2);
            goto LABEL_28;
          }
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInjectUnsignedChar();
          uint64_t v36 = (uint64_t)malloc((2 * DWORD2(v55) + 32));
          if (!v36)
          {
LABEL_29:
            HDLCFrameFree();
            HDLCFrameFree();
            return v36;
          }
          uint64_t v37 = HDLCFrameEncode();
          if (!v37) {
            goto LABEL_32;
          }
          uint64_t v38 = v37;
          unsigned int v58 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
          }
          if (!*a1)
          {
LABEL_32:
            free((void *)v36);
            goto LABEL_28;
          }
          int v39 = ((uint64_t (*)(void *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v36, v38, &v58, 1, a3, 0);
          unsigned int v40 = v58;
          free((void *)v36);
          uint64_t v36 = 0;
          if (!v39 || v40 != v38) {
            goto LABEL_29;
          }
          LOBYTE(v58) = 75;
          if (!_ETLResponseRingBuffer) {
            TelephonyUtilRingBufferInitialize();
          }
          uint64_t v36 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v53, (uint64_t)&_ETLResponseRingBuffer, &v58, a3)|| v58 != 75)
          {
            goto LABEL_29;
          }
          unsigned int v58 = 0;
          if (ETLMaverickParseBSPExtResponse((uint64_t)v53, &v58, v41, v42, v43, v44, v45, v46))
          {
            uint64_t v47 = DWORD2(v53[0]) - v58;
            if (v47 <= 1)
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSetNasSecResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v11, v12, v13, v14, v15, v16, v47);
            }
            else
            {
              uint64_t v48 = (unsigned char *)(*(void *)&v53[0] + v58);
              if (*v48 == 11)
              {
                if (v48[1] == a2)
                {
                  uint64_t v36 = 1;
                  goto LABEL_29;
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetNasSecResponse", (uint64_t)"Expected NAS Sec status, %u, does not match with read status, %u\n", v11, v12, v13, v14, v15, v16, a2);
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetNasSecResponse", (uint64_t)"Expected NAS Sec ID, %u, does not match with read ID, %u\n", v11, v12, v13, v14, v15, v16, 11);
              }
            }
LABEL_28:
            uint64_t v36 = 0;
            goto LABEL_29;
          }
          long long v49 = "ETLMaverickParseSetNasSecResponse";
          int v50 = "Failed on parsing BSP Ext Response.\n";
LABEL_27:
          _ETLDebugPrint((uint64_t)v49, (uint64_t)v50, v11, v12, v13, v14, v15, v16, v52);
          goto LABEL_28;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v52);
      }
      long long v49 = "ETLMaverickAddBSPExtCommandSetHeader";
      int v50 = "Failed on creating BSP Command Heder\n";
      goto LABEL_27;
    }
    long long v49 = "ETLMaverickSetNasSec";
    int v50 = "Failed to create command frame\n";
    goto LABEL_27;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickSetNasSec", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v52);
  return 0;
}

uint64_t ETLMaverickGetBandlock(void *a1, _WORD *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 && a1 && a3)
  {
    long long v56 = 0u;
    long long v57 = 0u;
    uint64_t v58 = 0;
    memset(v54, 0, sizeof(v54));
    uint64_t v55 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v19, v20, v21, v22, v23, v24, FreeSpace);
      }
      else
      {
        unsigned int v59 = 4521291;
        if (HDLCFrameInject())
        {
          if (!HDLCFrameGetFreeSpace())
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickAddBSPExtCommandGetHeader", (uint64_t)"Not enough room, need %zu, have %u\n", v31, v32, v33, v34, v35, v36, 2);
            goto LABEL_28;
          }
          HDLCFrameInjectUnsignedChar();
          uint64_t v37 = (uint64_t)malloc((2 * DWORD2(v56) + 32));
          if (!v37)
          {
LABEL_29:
            HDLCFrameFree();
            HDLCFrameFree();
            return v37;
          }
          uint64_t v38 = HDLCFrameEncode();
          if (!v38) {
            goto LABEL_32;
          }
          uint64_t v39 = v38;
          unsigned int v59 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v37, v38);
          }
          if (!*a1)
          {
LABEL_32:
            free((void *)v37);
            goto LABEL_28;
          }
          int v40 = ((uint64_t (*)(void *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v37, v39, &v59, 1, a4, 0);
          unsigned int v41 = v59;
          free((void *)v37);
          uint64_t v37 = 0;
          if (!v40 || v41 != v39) {
            goto LABEL_29;
          }
          LOBYTE(v59) = 75;
          if (!_ETLResponseRingBuffer) {
            TelephonyUtilRingBufferInitialize();
          }
          uint64_t v37 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v54, (uint64_t)&_ETLResponseRingBuffer, &v59, a4)|| v59 != 75)
          {
            goto LABEL_29;
          }
          unsigned int v59 = 0;
          if (ETLMaverickParseBSPExtResponse((uint64_t)v54, &v59, v42, v43, v44, v45, v46, v47))
          {
            uint64_t v48 = DWORD2(v54[0]) - v59;
            if (v48 > 0x19)
            {
              uint64_t v49 = *(void *)&v54[0] + v59;
              *a2 = *(_WORD *)v49;
              *a3 = *(void *)(v49 + 2);
              a3[1] = *(void *)(v49 + 10);
              a3[2] = *(void *)(v49 + 18);
              uint64_t v37 = 1;
              goto LABEL_29;
            }
            _ETLDebugPrint((uint64_t)"ETLMaverickParseGetBandLockResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v12, v13, v14, v15, v16, v17, v48);
LABEL_28:
            uint64_t v37 = 0;
            goto LABEL_29;
          }
          int v50 = "ETLMaverickParseGetBandLockResponse";
          uint64_t v51 = "Failed on parsing BSP Ext Response.\n";
LABEL_27:
          _ETLDebugPrint((uint64_t)v50, (uint64_t)v51, v12, v13, v14, v15, v16, v17, v53);
          goto LABEL_28;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v25, v26, v27, v28, v29, v30, v53);
      }
      int v50 = "ETLMaverickAddBSPExtCommandGetHeader";
      uint64_t v51 = "Failed on creating BSP Command Heder\n";
      goto LABEL_27;
    }
    int v50 = "ETLMaverickGetBandlock";
    uint64_t v51 = "Failed to create command frame\n";
    goto LABEL_27;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickGetBandlock", (uint64_t)"Transport or bandLock or errorCode memory cannot be NULL\n", (uint64_t)a3, a4, a5, a6, a7, a8, v53);
  return 0;
}

uint64_t ETLMaverickSetBandlock(uint64_t (**a1)(void, uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, void), _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    long long v105 = 0u;
    long long v106 = 0u;
    uint64_t v107 = 0;
    memset(v103, 0, sizeof(v103));
    uint64_t v104 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v19, v20, v21, v22, v23, v24, FreeSpace);
      }
      else
      {
        LODWORD(v108) = 4521291;
        if (HDLCFrameInject())
        {
          if (HDLCFrameGetFreeSpace() <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickSetBandlockCommand", (uint64_t)"Not enough room, need %zu, have %u\n", v31, v32, v33, v34, v35, v36, 2);
          }
          else
          {
            HDLCFrameInjectUnsignedChar();
            HDLCFrameInject();
            uint64_t v37 = (uint64_t)malloc((2 * DWORD2(v105) + 32));
            if (!v37)
            {
LABEL_27:
              HDLCFrameFree();
              HDLCFrameFree();
              return v37;
            }
            uint64_t v38 = HDLCFrameEncode();
            if (v38)
            {
              uint64_t v39 = v38;
              LODWORD(v108) = -1431655766;
              if ((_ETLDebugFlags & 2) != 0) {
                ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v37, v38);
              }
              if (*a1)
              {
                int v40 = (*a1)(a1, v37, v39, &v108, 1, a4, 0);
                int v41 = v108;
                free((void *)v37);
                uint64_t v37 = 0;
                if (!v40 || v41 != v39) {
                  goto LABEL_27;
                }
                LOBYTE(v108) = 75;
                if (!_ETLResponseRingBuffer) {
                  TelephonyUtilRingBufferInitialize();
                }
                uint64_t v37 = 0;
                if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v103, (uint64_t)&_ETLResponseRingBuffer, &v108, a4)|| v108 != 75)
                {
                  goto LABEL_27;
                }
                long long v101 = *(_OWORD *)a3;
                uint64_t v102 = *(void *)(a3 + 16);
                uint64_t v108 = 0;
                uint64_t v109 = 0;
                uint64_t v110 = 0;
                unsigned int v111 = 0;
                if (ETLMaverickParseBSPExtResponse((uint64_t)v103, &v111, v42, v43, v44, v45, v46, v47))
                {
                  if (DWORD2(v103[0]) - v111 > 0x19)
                  {
                    uint64_t v54 = *(void *)&v103[0] + v111;
                    *a2 = *(_WORD *)v54;
                    uint64_t v55 = *(void *)(v54 + 2);
                    uint64_t v108 = v55;
                    uint64_t v56 = *(void *)(v54 + 10);
                    uint64_t v109 = v56;
                    uint64_t v57 = *(void *)(v54 + 18);
                    uint64_t v110 = v57;
                    goto LABEL_34;
                  }
                  uint64_t v100 = DWORD2(v103[0]) - v111;
                  uint64_t v61 = "Received response has only %u bytes, need %u\n";
                }
                else
                {
                  uint64_t v61 = "Failed on parsing BSP Ext Response.\n";
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseGetBandLockResponse", (uint64_t)v61, v48, v49, v50, v51, v52, v53, v100);
                uint64_t v57 = 0;
                uint64_t v56 = 0;
                uint64_t v55 = 0;
LABEL_34:
                if (!*a2)
                {
                  BOOL v62 = v108 == (void)v101 && v109 == *((void *)&v101 + 1);
                  if (v62 && v110 == v102)
                  {
                    uint64_t v37 = 1;
                    goto LABEL_27;
                  }
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetBandLockResponse", (uint64_t)"Expected locked band values are different read back locked band values.\n", v48, v49, v50, v51, v52, v53, v100);
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetBandLockResponse", (uint64_t)"\tExpected GWC: 0x%016llx\n", v64, v65, v66, v67, v68, v69, v101);
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetBandLockResponse", (uint64_t)"\tExpected LTE: 0x%016llx\n", v70, v71, v72, v73, v74, v75, *((uint64_t *)&v101 + 1));
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetBandLockResponse", (uint64_t)"\tExpected TDS: 0x%016llx\n", v76, v77, v78, v79, v80, v81, v102);
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetBandLockResponse", (uint64_t)"\tRead back GWC: 0x%016llx\n", v82, v83, v84, v85, v86, v87, v55);
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetBandLockResponse", (uint64_t)"\tRead back LTE: 0x%016llx\n", v88, v89, v90, v91, v92, v93, v56);
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetBandLockResponse", (uint64_t)"\tRead back TDS: 0x%016llx\n", v94, v95, v96, v97, v98, v99, v57);
                goto LABEL_26;
              }
            }
            free((void *)v37);
          }
LABEL_26:
          uint64_t v37 = 0;
          goto LABEL_27;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v25, v26, v27, v28, v29, v30, v100);
      }
      uint64_t v58 = "ETLMaverickSetBandlockCommand";
      unsigned int v59 = "Failed on creating BSP Command Heder\n";
    }
    else
    {
      uint64_t v58 = "ETLMaverickSetBandlock";
      unsigned int v59 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v58, (uint64_t)v59, v12, v13, v14, v15, v16, v17, v100);
    goto LABEL_26;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickSetBandlock", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v100);
  return 0;
}

uint64_t ETLMaverickGetBandSupport(void *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    long long v50 = 0u;
    long long v51 = 0u;
    uint64_t v52 = 0;
    memset(v48, 0, sizeof(v48));
    uint64_t v49 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v20, v21, v22, v23, v24, v25, FreeSpace);
        goto LABEL_30;
      }
      int v53 = 3210059;
      if (HDLCFrameInject())
      {
        uint64_t v26 = (uint64_t)malloc((2 * DWORD2(v50) + 32));
        if (!v26)
        {
LABEL_31:
          HDLCFrameFree();
          HDLCFrameFree();
          return v26;
        }
        uint64_t v27 = HDLCFrameEncode();
        if (!v27) {
          goto LABEL_33;
        }
        uint64_t v28 = v27;
        int v53 = -1431655766;
        if ((_ETLDebugFlags & 2) != 0) {
          ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v26, v27);
        }
        if (!*a1)
        {
LABEL_33:
          free((void *)v26);
          goto LABEL_30;
        }
        int v29 = ((uint64_t (*)(void *, uint64_t, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v26, v28, &v53, 1, a5, 0);
        int v30 = v53;
        free((void *)v26);
        uint64_t v26 = 0;
        if (!v29 || v30 != v28) {
          goto LABEL_31;
        }
        LOBYTE(v53) = 75;
        if (!_ETLResponseRingBuffer) {
          TelephonyUtilRingBufferInitialize();
        }
        uint64_t v26 = 0;
        if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v48, (uint64_t)&_ETLResponseRingBuffer, &v53, a5)|| v53 != 75)
        {
          goto LABEL_31;
        }
        uint64_t v37 = (DWORD2(v48[0]) - 4);
        if (DWORD2(v48[0]) < 4)
        {
          _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v31, v32, v33, v34, v35, v36, DWORD2(v48[0]));
        }
        else
        {
          uint64_t v38 = *(void *)&v48[0];
          unsigned int v39 = **(_DWORD **)&v48[0];
          if (**(_DWORD **)&v48[0] == 75)
          {
            if (BYTE1(v39) == 251)
            {
              uint64_t v40 = HIWORD(v39);
              if (v40 == 48)
              {
                if (v37 > 1)
                {
                  uint64_t v41 = *(unsigned __int16 *)(*(void *)&v48[0] + 4);
                  *a2 = v41;
                  if (v41 != 1) {
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetBandSupportResponse", (uint64_t)"Error Code Returned: %d\n", v31, v32, v33, v34, v35, v36, v41);
                  }
                  if (v37 > 0x2D)
                  {
                    long long v42 = *(_OWORD *)(v38 + 6);
                    *(void *)(a3 + 14) = *(void *)(v38 + 20);
                    *(_OWORD *)a3 = v42;
                    long long v43 = *(_OWORD *)(v38 + 28);
                    *(void *)(a4 + 14) = *(void *)(v38 + 42);
                    *(_OWORD *)a4 = v43;
                    uint64_t v26 = 1;
                    goto LABEL_31;
                  }
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseGetBandSupportResponse", (uint64_t)"Received response has only %u bytes, need %u\n", v31, v32, v33, v34, v35, v36, v37);
LABEL_30:
                uint64_t v26 = 0;
                goto LABEL_31;
              }
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v31, v32, v33, v34, v35, v36, v40);
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v31, v32, v33, v34, v35, v36, BYTE1(v39));
            }
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v31, v32, v33, v34, v35, v36, **(_DWORD **)&v48[0]);
          }
        }
        uint64_t v44 = "ETLMaverickParseGetBandSupportResponse";
        uint64_t v45 = "Failed on parsing BSP Ext Response.\n";
      }
      else
      {
        uint64_t v44 = "ETLSubsysAddHeaderInternal";
        uint64_t v45 = "Failed to inject\n";
      }
    }
    else
    {
      uint64_t v44 = "ETLMaverickGetBandSupport";
      uint64_t v45 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v44, (uint64_t)v45, v13, v14, v15, v16, v17, v18, v47);
    goto LABEL_30;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickGetBandSupport", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v47);
  return 0;
}

void *ETLMaverickGetGPIOExt(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, unsigned char *a3, unsigned char *a4, unsigned char *a5, unsigned char *a6, uint64_t a7, uint64_t a8)
{
  if (a1 && a3 && a4 && a5 && a6)
  {
    long long v41 = 0u;
    long long v42 = 0u;
    uint64_t v43 = 0;
    memset(v39, 0, sizeof(v39));
    uint64_t v40 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v22, v23, v24, v25, v26, v27, FreeSpace);
        goto LABEL_27;
      }
      int v44 = 3013963;
      if (HDLCFrameInject())
      {
        if (HDLCFrameInjectUnsignedShort())
        {
          GPIOExtResponse = malloc((2 * DWORD2(v41) + 32));
          if (!GPIOExtResponse)
          {
LABEL_28:
            HDLCFrameFree();
            HDLCFrameFree();
            return GPIOExtResponse;
          }
          uint64_t v29 = HDLCFrameEncode();
          if (v29)
          {
            uint64_t v30 = v29;
            int v44 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0) {
              ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, GPIOExtResponse, v29);
            }
            if (*a1)
            {
              int v31 = (*a1)(a1, GPIOExtResponse, v30, &v44, 1, a7, 0);
              int v38 = v44;
              free(GPIOExtResponse);
              GPIOExtResponse = 0;
              if (v31 && v38 == v30)
              {
                LOBYTE(v44) = 75;
                if (!_ETLResponseRingBuffer) {
                  TelephonyUtilRingBufferInitialize();
                }
                GPIOExtResponse = 0;
                if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v39, (uint64_t)&_ETLResponseRingBuffer, &v44, a7)&& v44 == 75)
                {
                  GPIOExtResponse = (void *)ETLMaverickParseGetGPIOExtResponse((int **)v39, a2, a3, a4, a5, a6, v32, v33);
                }
              }
              goto LABEL_28;
            }
          }
          free(GPIOExtResponse);
        }
LABEL_27:
        GPIOExtResponse = 0;
        goto LABEL_28;
      }
      uint64_t v34 = "ETLSubsysAddHeaderInternal";
      uint64_t v35 = "Failed to inject\n";
    }
    else
    {
      uint64_t v34 = "ETLMaverickGetGPIOExt";
      uint64_t v35 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v34, (uint64_t)v35, v15, v16, v17, v18, v19, v20, v37);
    goto LABEL_27;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickGetGPIOExt", (uint64_t)"Transport, gpioState, direction, value, or function memory cannot be NULL\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, v37);
  return 0;
}

uint64_t ETLMaverickParseGetGPIOExtResponse(int **a1, uint64_t a2, unsigned char *a3, unsigned char *a4, unsigned char *a5, unsigned char *a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  uint64_t v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_13:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetGPIOExtResponse", (uint64_t)"Failed to parse BSP response header\n", v14, v15, v16, v17, v18, v19, v20);
    return 0;
  }
  unsigned int v10 = *a1;
  unsigned int v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, **a1);
    goto LABEL_13;
  }
  if (BYTE1(v11) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, BYTE1(v11));
    goto LABEL_13;
  }
  uint64_t v12 = HIWORD(v11);
  if (v12 != 45)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, v12);
    goto LABEL_13;
  }
  if (v9 <= 5)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetGPIOExtResponse", (uint64_t)"Received response has only %u bytes, need %u\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, v9);
    return 0;
  }
  else if (*((_WORD *)v10 + 2) == 1)
  {
    if (*((unsigned __int16 *)v10 + 3) == a2)
    {
      *a3 = *((unsigned char *)v10 + 8);
      *a4 = *((unsigned char *)v10 + 9);
      *a5 = *((unsigned char *)v10 + 10);
      *a6 = *((unsigned char *)v10 + 11);
      return 1;
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickParseGetGPIOExtResponse", (uint64_t)"Expected gpio id, %u, but got %u\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, a2);
      return 0;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseGetGPIOExtResponse", (uint64_t)"Received response with failure status [%d]\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, *((unsigned __int16 *)v10 + 2));
    return 0;
  }
}

uint64_t ETLMaverickSetGPIOExt(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    memset(v37, 0, sizeof(v37));
    uint64_t v38 = 0;
    memset(v35, 0, sizeof(v35));
    uint64_t v36 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v17, v18, v19, v20, v21, v22, FreeSpace);
        goto LABEL_17;
      }
      int v39 = 3079499;
      if (HDLCFrameInject())
      {
        if (HDLCFrameInjectUnsignedShort()
          && HDLCFrameInjectUnsignedChar()
          && HDLCFrameInjectUnsignedChar()
          && HDLCFrameInjectUnsignedChar()
          && ETLSendCommand(a1, (uint64_t)v37, a6)
          && ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v35, a6))
        {
          uint64_t v30 = ETLMaverickParseSetGPIOExtResponse((unsigned int *)v35, v23, v24, v25, v26, v27, v28, v29);
LABEL_18:
          HDLCFrameFree();
          HDLCFrameFree();
          return v30;
        }
LABEL_17:
        uint64_t v30 = 0;
        goto LABEL_18;
      }
      int v31 = "ETLSubsysAddHeaderInternal";
      uint64_t v32 = "Failed to inject\n";
    }
    else
    {
      int v31 = "ETLMaverickSetGPIOExt";
      uint64_t v32 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v31, (uint64_t)v32, v10, v11, v12, v13, v14, v15, v34);
    goto LABEL_17;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickSetGPIOExt", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v34);
  return 0;
}

uint64_t ETLMaverickParseSetGPIOExtResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a1[2];
  uint64_t v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSetGPIOExtResponse", (uint64_t)"Failed to parse BSP response header\n", v13, v14, v15, v16, v17, v18, v19);
    return 0;
  }
  unsigned int v10 = **(_DWORD **)a1;
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
    goto LABEL_12;
  }
  if (BYTE1(v10) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
    goto LABEL_12;
  }
  uint64_t v11 = HIWORD(v10);
  if (v11 != 46)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
    goto LABEL_12;
  }
  if (v9 <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSetGPIOExtResponse", (uint64_t)"Received response has only %u bytes, need %u\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else if (*(_WORD *)(*(void *)a1 + 4) == 1)
  {
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSetGPIOExtResponse", (uint64_t)"Received response with failure status [%d]\n", a3, a4, a5, a6, a7, a8, *(unsigned __int16 *)(*(void *)a1 + 4));
    return 0;
  }
}

uint64_t ETLMaverickLoopbackMode(void *a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    long long v52 = 0u;
    long long v53 = 0u;
    uint64_t v54 = 0;
    memset(v50, 0, sizeof(v50));
    uint64_t v51 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        unsigned int v57 = 4128075;
        if (HDLCFrameInject())
        {
          if (HDLCFrameGetFreeSpace() <= 4)
          {
            _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v30, v31, v32, v33, v34, v35, 5);
            uint64_t v46 = "ETLMaverickAddLoopbackModeHeader";
            uint64_t v47 = "There is no more free spaces.\n";
          }
          else
          {
            HDLCFrameInjectUnsignedInt();
            HDLCFrameInjectUnsignedChar();
            if (a2 == 3)
            {
              HDLCFrameInjectUnsignedChar();
              HDLCFrameInjectUnsignedChar();
              HDLCFrameInjectUnsignedChar();
              HDLCFrameInjectUnsignedInt();
            }
            uint64_t v36 = (uint64_t)malloc((2 * DWORD2(v52) + 32));
            if (!v36) {
              goto LABEL_32;
            }
            uint64_t v37 = HDLCFrameEncode();
            if (!v37) {
              goto LABEL_35;
            }
            uint64_t v38 = v37;
            unsigned int v57 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0) {
              ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
            }
            if (!*a1)
            {
LABEL_35:
              free((void *)v36);
              goto LABEL_31;
            }
            int v39 = ((uint64_t (*)(void *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v36, v38, &v57, 1, a5, 0);
            unsigned int v40 = v57;
            free((void *)v36);
            uint64_t v36 = 0;
            if (!v39 || v40 != v38) {
              goto LABEL_32;
            }
            LOBYTE(v57) = 75;
            if (!_ETLResponseRingBuffer) {
              TelephonyUtilRingBufferInitialize();
            }
            uint64_t v36 = 0;
            if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v50, (uint64_t)&_ETLResponseRingBuffer, &v57, a5)|| v57 != 75)
            {
              goto LABEL_32;
            }
            unsigned int v57 = 0;
            unsigned __int16 v56 = -21846;
            unsigned __int16 v55 = -21846;
            if (ETLSubsysParseHeader((uint64_t)v50, &v56, &v55, &v57, v41, v42, v43, v44))
            {
              if (v56 == 253)
              {
                if (v55 == 62)
                {
                  uint64_t v45 = DWORD2(v50[0]) - v57;
                  if (v45 <= 1)
                  {
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseResponseLoopbackMode", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v11, v12, v13, v14, v15, v16, v45);
                  }
                  else
                  {
                    if (*(_WORD *)(*(void *)&v50[0] + v57) == 1)
                    {
                      uint64_t v36 = 1;
LABEL_32:
                      HDLCFrameFree();
                      HDLCFrameFree();
                      return v36;
                    }
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseResponseLoopbackMode", (uint64_t)"Received response with failure status [%d]\n", v11, v12, v13, v14, v15, v16, *(unsigned __int16 *)(*(void *)&v50[0] + v57));
                  }
LABEL_31:
                  uint64_t v36 = 0;
                  goto LABEL_32;
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v11, v12, v13, v14, v15, v16, v55);
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v11, v12, v13, v14, v15, v16, v56);
              }
            }
            uint64_t v46 = "ETLMaverickParseResponseLoopbackMode";
            uint64_t v47 = "Failed to parse BSP response header\n";
          }
LABEL_30:
          _ETLDebugPrint((uint64_t)v46, (uint64_t)v47, v11, v12, v13, v14, v15, v16, v49);
          goto LABEL_31;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v49);
      }
      uint64_t v46 = "ETLMaverickAddLoopbackModeHeader";
      uint64_t v47 = "Failed to create command header\n";
      goto LABEL_30;
    }
    uint64_t v46 = "ETLMaverickLoopbackMode";
    uint64_t v47 = "Failed to create command frame\n";
    goto LABEL_30;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickLoopbackMode", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v49);
  return 0;
}

uint64_t ETLMaverickMHILoopbackMode(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    int v9 = a3;
    long long v55 = 0u;
    long long v56 = 0u;
    uint64_t v57 = 0;
    memset(v53, 0, sizeof(v53));
    uint64_t v54 = 0;
    if ((HDLCFrameCreateUplink() & 1) == 0)
    {
      uint64_t v49 = "ETLMaverickMHILoopbackMode";
      long long v50 = "Failed to create command frame\n";
      goto LABEL_30;
    }
    uint64_t v58 = a2;
    int v59 = v9;
    uint64_t FreeSpace = HDLCFrameGetFreeSpace();
    if (FreeSpace < 4)
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v19, v20, v21, v22, v23, v24, FreeSpace);
    }
    else
    {
      int v61 = 5176651;
      if (HDLCFrameInject())
      {
        if (HDLCFrameGetFreeSpace() > 0xC)
        {
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInject();
          uint64_t v37 = (uint64_t)malloc((2 * DWORD2(v55) + 32));
          if (!v37)
          {
LABEL_32:
            HDLCFrameFree();
            HDLCFrameFree();
            return v37;
          }
          uint64_t v38 = HDLCFrameEncode();
          if (!v38) {
            goto LABEL_35;
          }
          uint64_t v39 = v38;
          LODWORD(v58) = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v37, v38);
          }
          if (!*a1)
          {
LABEL_35:
            free((void *)v37);
            goto LABEL_31;
          }
          int v40 = ((uint64_t (*)(void *, uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, void))*a1)(a1, v37, v39, &v58, 1, a4, 0);
          int v41 = v58;
          free((void *)v37);
          uint64_t v37 = 0;
          if (!v40 || v41 != v39) {
            goto LABEL_32;
          }
          LOBYTE(v58) = 75;
          if (!_ETLResponseRingBuffer) {
            TelephonyUtilRingBufferInitialize();
          }
          uint64_t v37 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v53, (uint64_t)&_ETLResponseRingBuffer, &v58, a4)|| v58 != 75)
          {
            goto LABEL_32;
          }
          LODWORD(v58) = 0;
          LOWORD(v61) = -21846;
          unsigned __int16 v60 = -21846;
          if (ETLSubsysParseHeader((uint64_t)v53, &v61, &v60, &v58, v42, v43, v44, v45))
          {
            if ((unsigned __int16)v61 == 253)
            {
              if (v60 == 78)
              {
                uint64_t v46 = (DWORD2(v53[0]) - v58);
                if (v46 <= 4)
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseResponseMHILoopbackMode", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v12, v13, v14, v15, v16, v17, v46);
                }
                else
                {
                  uint64_t v47 = *(void *)&v53[0] + v58;
                  uint64_t v48 = *(unsigned int *)(v47 + 1);
                  uint64_t v37 = 1;
                  if (!v48 || !*(unsigned char *)v47) {
                    goto LABEL_32;
                  }
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseResponseMHILoopbackMode", (uint64_t)"Received response with failure status [%d]\n", v12, v13, v14, v15, v16, v17, v48);
                }
                goto LABEL_31;
              }
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v12, v13, v14, v15, v16, v17, v60);
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v12, v13, v14, v15, v16, v17, (unsigned __int16)v61);
            }
          }
          uint64_t v49 = "ETLMaverickParseResponseMHILoopbackMode";
          long long v50 = "Failed to parse BSP response header\n";
LABEL_30:
          _ETLDebugPrint((uint64_t)v49, (uint64_t)v50, v12, v13, v14, v15, v16, v17, v52);
LABEL_31:
          uint64_t v37 = 0;
          goto LABEL_32;
        }
        _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v31, v32, v33, v34, v35, v36, 13);
        long long v50 = "There is no more free spaces.\n";
LABEL_29:
        uint64_t v49 = "ETLMaverickAddMHILoopbackModeHeader";
        goto LABEL_30;
      }
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v25, v26, v27, v28, v29, v30, v52);
    }
    long long v50 = "Failed to create command header\n";
    goto LABEL_29;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickMHILoopbackMode", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v52);
  return 0;
}

uint64_t ETLMaverickRFSelfTestTrigger(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickRFSelfTestTrigger", (uint64_t)"Transport parameter is NULL\n", a3, a4, a5, a6, a7, a8, v64);
    return 0;
  }
  if (!a2)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickRFSelfTestTrigger", (uint64_t)"Trigger info parameter is NULL\n", a3, a4, a5, a6, a7, a8, v64);
    return 0;
  }
  uint64_t v69 = 0;
  memset(v68, 0, sizeof(v68));
  memset(v66, 0, sizeof(v66));
  uint64_t v67 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    long long v55 = "ETLMaverickRFSelfTestTrigger";
    long long v56 = "Failed to create command frame\n";
LABEL_25:
    _ETLDebugPrint((uint64_t)v55, (uint64_t)v56, v10, v11, v12, v13, v14, v15, v64);
    goto LABEL_26;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v17, v18, v19, v20, v21, v22, FreeSpace);
LABEL_23:
    _ETLDebugPrint((uint64_t)"ETLMaverickAddRFSubCommandHeader", (uint64_t)"Failed on creating RF Command Header\n", v57, v58, v59, v60, v61, v62, v65);
LABEL_24:
    long long v55 = "ETLMaverickAddRFSelfTestTriggerInfo";
    long long v56 = "Failed on creating RF Sub Command Header\n";
    goto LABEL_25;
  }
  unsigned int v72 = 4455243;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v23, v24, v25, v26, v27, v28, v64);
    goto LABEL_23;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickAddRFSubCommandHeader", (uint64_t)"Not enough room, need %zu, have %zu\n", v29, v30, v31, v32, v33, v34, 2);
    goto LABEL_24;
  }
  HDLCFrameInjectUnsignedShort();
  if (HDLCFrameGetFreeSpace() <= 3)
  {
    uint64_t v63 = 4;
LABEL_31:
    _ETLDebugPrint((uint64_t)"ETLMaverickAddRFSelfTestTriggerInfo", (uint64_t)"Not enough room, need %zu, have %zu\n", v35, v36, v37, v38, v39, v40, v63);
    goto LABEL_26;
  }
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  if (HDLCFrameGetFreeSpace() <= 0x103)
  {
    uint64_t v63 = 260;
    goto LABEL_31;
  }
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  uint64_t v41 = 0;
  if (ETLSendCommand(a1, (uint64_t)v68, a3))
  {
    if (ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v66, a3))
    {
      unsigned int v72 = 0;
      unsigned __int16 v71 = -21846;
      unsigned __int16 v70 = -21846;
      if (ETLSubsysParseHeader((uint64_t)v66, &v71, &v70, &v72, v42, v43, v44, v45))
      {
        if (v71 == 251)
        {
          if (v70 == 67)
          {
            uint64_t v52 = DWORD2(v66[0]) - v72;
            if (v52 <= 3)
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseRFSelfTestTriggerResponse", (uint64_t)"Received response has only %zu bytes, need %zu\n", v46, v47, v48, v49, v50, v51, v52);
            }
            else if (*(_WORD *)(*(void *)&v66[0] + v72) == 11)
            {
              uint64_t v53 = *(unsigned __int16 *)(*(void *)&v66[0] + v72 + 2);
              if (v53 == 1)
              {
                uint64_t v41 = 1;
                goto LABEL_27;
              }
              _ETLDebugPrint((uint64_t)"ETLMaverickParseRFSelfTestTriggerResponse", (uint64_t)"Received response with failure status [%d]\n", v46, v47, v48, v49, v50, v51, v53);
            }
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v46, v47, v48, v49, v50, v51, v70);
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v46, v47, v48, v49, v50, v51, v71);
        }
      }
    }
LABEL_26:
    uint64_t v41 = 0;
  }
LABEL_27:
  HDLCFrameFree();
  HDLCFrameFree();
  return v41;
}

uint64_t ETLMaverickRFSelfTestResult(uint64_t (**a1)(void, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, void), _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t v81 = 0;
      long long v79 = 0u;
      long long v80 = 0u;
      memset(v77, 0, sizeof(v77));
      uint64_t v78 = 0;
      if ((HDLCFrameCreateUplink() & 1) == 0)
      {
        uint64_t v66 = "ETLMaverickRFSelfTestResult";
        uint64_t v67 = "Failed to create command frame\n";
LABEL_33:
        _ETLDebugPrint((uint64_t)v66, (uint64_t)v67, v11, v12, v13, v14, v15, v16, v75);
        goto LABEL_34;
      }
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        unsigned int v84 = 4455243;
        if (HDLCFrameInject())
        {
          if (HDLCFrameGetFreeSpace() > 1)
          {
            HDLCFrameInjectUnsignedShort();
            if (HDLCFrameGetFreeSpace() <= 3)
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickAddRFSelfTestResultHeader", (uint64_t)"Not enough room, need %zu, have %zu\n", v36, v37, v38, v39, v40, v41, 4);
            }
            else
            {
              HDLCFrameInjectUnsignedShort();
              HDLCFrameInjectUnsignedShort();
              uint64_t v42 = (uint64_t)malloc((2 * DWORD2(v79) + 32));
              if (!v42)
              {
LABEL_35:
                HDLCFrameFree();
                HDLCFrameFree();
                return v42;
              }
              uint64_t v43 = HDLCFrameEncode();
              if (!v43) {
                goto LABEL_39;
              }
              uint64_t v44 = v43;
              unsigned int v84 = -1431655766;
              if ((_ETLDebugFlags & 2) != 0) {
                ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v42, v43);
              }
              if (*a1)
              {
                int v45 = (*a1)(a1, v42, v44, &v84, 1, a3, 0);
                unsigned int v46 = v84;
                free((void *)v42);
                uint64_t v42 = 0;
                if (!v45 || v46 != v44) {
                  goto LABEL_35;
                }
                if (ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v77, a3))
                {
                  unsigned int v84 = 0;
                  unsigned __int16 v83 = -21846;
                  unsigned __int16 v82 = -21846;
                  if (ETLSubsysParseHeader((uint64_t)v77, &v83, &v82, &v84, v47, v48, v49, v50))
                  {
                    if (v83 == 251)
                    {
                      if (v82 == 67)
                      {
                        uint64_t v57 = v84;
                        uint64_t v58 = DWORD2(v77[0]) - v84;
                        unsigned int v59 = v84 + 6;
                        v84 += 6;
                        if (v58 <= 5)
                        {
                          _ETLDebugPrint((uint64_t)"ETLMaverickParseRFSelfTestResultResponse", (uint64_t)"Received response has only %zu bytes, need %zu\n", v51, v52, v53, v54, v55, v56, v58);
                        }
                        else
                        {
                          uint64_t v60 = *(void *)&v77[0] + v57;
                          uint64_t v61 = *(unsigned __int16 *)(*(void *)&v77[0] + v57);
                          if (v61 == 21)
                          {
                            if (*(_WORD *)(v60 + 4) == 100)
                            {
                              uint64_t v62 = *(unsigned __int16 *)(v60 + 2);
                              if (v62 == 1)
                              {
                                uint64_t v63 = DWORD2(v77[0]) - v59;
                                if (v63 > 0x205)
                                {
                                  uint64_t v64 = (_WORD *)(*(void *)&v77[0] + v59);
                                  *a2 = *v64;
                                  a2[1] = v64[1];
                                  a2[2] = v64[2];
                                  a2[3] = v64[3];
                                  a2[4] = v64[4];
                                  a2[5] = v64[5];
                                  a2[6] = v64[6];
                                  a2[7] = v64[7];
                                  a2[8] = v64[8];
                                  a2[9] = v64[9];
                                  a2[10] = v64[10];
                                  a2[11] = v64[11];
                                  a2[12] = v64[12];
                                  a2[13] = v64[13];
                                  a2[14] = v64[14];
                                  a2[15] = v64[15];
                                  a2[16] = v64[16];
                                  a2[17] = v64[17];
                                  a2[18] = v64[18];
                                  a2[19] = v64[19];
                                  a2[20] = v64[20];
                                  a2[21] = v64[21];
                                  a2[22] = v64[22];
                                  a2[23] = v64[23];
                                  a2[24] = v64[24];
                                  a2[25] = v64[25];
                                  a2[26] = v64[26];
                                  a2[27] = v64[27];
                                  a2[28] = v64[28];
                                  a2[29] = v64[29];
                                  a2[30] = v64[30];
                                  a2[31] = v64[31];
                                  a2[32] = v64[32];
                                  a2[33] = v64[33];
                                  a2[34] = v64[34];
                                  a2[35] = v64[35];
                                  a2[36] = v64[36];
                                  a2[37] = v64[37];
                                  a2[38] = v64[38];
                                  a2[39] = v64[39];
                                  a2[40] = v64[40];
                                  a2[41] = v64[41];
                                  a2[42] = v64[42];
                                  a2[43] = v64[43];
                                  a2[44] = v64[44];
                                  a2[45] = v64[45];
                                  a2[46] = v64[46];
                                  a2[47] = v64[47];
                                  a2[48] = v64[48];
                                  a2[49] = v64[49];
                                  a2[50] = v64[50];
                                  a2[51] = v64[51];
                                  a2[52] = v64[52];
                                  a2[53] = v64[53];
                                  a2[54] = v64[54];
                                  a2[55] = v64[55];
                                  a2[56] = v64[56];
                                  a2[57] = v64[57];
                                  a2[58] = v64[58];
                                  a2[59] = v64[59];
                                  a2[60] = v64[60];
                                  a2[61] = v64[61];
                                  a2[62] = v64[62];
                                  a2[63] = v64[63];
                                  a2[64] = v64[64];
                                  a2[65] = v64[65];
                                  a2[66] = v64[66];
                                  a2[67] = v64[67];
                                  a2[68] = v64[68];
                                  a2[69] = v64[69];
                                  a2[70] = v64[70];
                                  a2[71] = v64[71];
                                  a2[72] = v64[72];
                                  a2[73] = v64[73];
                                  a2[74] = v64[74];
                                  a2[75] = v64[75];
                                  a2[76] = v64[76];
                                  a2[77] = v64[77];
                                  a2[78] = v64[78];
                                  a2[79] = v64[79];
                                  a2[80] = v64[80];
                                  a2[81] = v64[81];
                                  a2[82] = v64[82];
                                  a2[83] = v64[83];
                                  a2[84] = v64[84];
                                  a2[85] = v64[85];
                                  a2[86] = v64[86];
                                  a2[87] = v64[87];
                                  a2[88] = v64[88];
                                  a2[89] = v64[89];
                                  a2[90] = v64[90];
                                  a2[91] = v64[91];
                                  a2[92] = v64[92];
                                  a2[93] = v64[93];
                                  a2[94] = v64[94];
                                  a2[95] = v64[95];
                                  a2[96] = v64[96];
                                  a2[97] = v64[97];
                                  a2[98] = v64[98];
                                  a2[99] = v64[99];
                                  a2[100] = v64[100];
                                  a2[101] = v64[101];
                                  a2[102] = v64[102];
                                  a2[103] = v64[103];
                                  a2[104] = v64[104];
                                  a2[105] = v64[105];
                                  a2[106] = v64[106];
                                  a2[107] = v64[107];
                                  a2[108] = v64[108];
                                  a2[109] = v64[109];
                                  a2[110] = v64[110];
                                  a2[111] = v64[111];
                                  a2[112] = v64[112];
                                  a2[113] = v64[113];
                                  a2[114] = v64[114];
                                  a2[115] = v64[115];
                                  a2[116] = v64[116];
                                  a2[117] = v64[117];
                                  a2[118] = v64[118];
                                  a2[119] = v64[119];
                                  a2[120] = v64[120];
                                  a2[121] = v64[121];
                                  a2[122] = v64[122];
                                  a2[123] = v64[123];
                                  a2[124] = v64[124];
                                  a2[125] = v64[125];
                                  a2[126] = v64[126];
                                  a2[127] = v64[127];
                                  a2[128] = v64[128];
                                  a2[129] = v64[129];
                                  a2[130] = v64[130];
                                  a2[131] = v64[131];
                                  a2[132] = v64[132];
                                  a2[133] = v64[133];
                                  a2[134] = v64[134];
                                  a2[135] = v64[135];
                                  a2[136] = v64[136];
                                  a2[137] = v64[137];
                                  a2[138] = v64[138];
                                  a2[139] = v64[139];
                                  a2[140] = v64[140];
                                  a2[141] = v64[141];
                                  a2[142] = v64[142];
                                  a2[143] = v64[143];
                                  a2[144] = v64[144];
                                  a2[145] = v64[145];
                                  a2[146] = v64[146];
                                  a2[147] = v64[147];
                                  a2[148] = v64[148];
                                  a2[149] = v64[149];
                                  a2[150] = v64[150];
                                  a2[151] = v64[151];
                                  a2[152] = v64[152];
                                  a2[153] = v64[153];
                                  a2[154] = v64[154];
                                  a2[155] = v64[155];
                                  a2[156] = v64[156];
                                  a2[157] = v64[157];
                                  a2[158] = v64[158];
                                  a2[159] = v64[159];
                                  a2[160] = v64[160];
                                  a2[161] = v64[161];
                                  a2[162] = v64[162];
                                  a2[163] = v64[163];
                                  a2[164] = v64[164];
                                  a2[165] = v64[165];
                                  a2[166] = v64[166];
                                  a2[167] = v64[167];
                                  a2[168] = v64[168];
                                  a2[169] = v64[169];
                                  a2[170] = v64[170];
                                  a2[171] = v64[171];
                                  a2[172] = v64[172];
                                  a2[173] = v64[173];
                                  a2[174] = v64[174];
                                  a2[175] = v64[175];
                                  a2[176] = v64[176];
                                  a2[177] = v64[177];
                                  a2[178] = v64[178];
                                  a2[179] = v64[179];
                                  a2[180] = v64[180];
                                  a2[181] = v64[181];
                                  a2[182] = v64[182];
                                  a2[183] = v64[183];
                                  a2[184] = v64[184];
                                  a2[185] = v64[185];
                                  a2[186] = v64[186];
                                  a2[187] = v64[187];
                                  a2[188] = v64[188];
                                  a2[189] = v64[189];
                                  a2[190] = v64[190];
                                  a2[191] = v64[191];
                                  a2[192] = v64[192];
                                  a2[193] = v64[193];
                                  a2[194] = v64[194];
                                  a2[195] = v64[195];
                                  a2[196] = v64[196];
                                  a2[197] = v64[197];
                                  a2[198] = v64[198];
                                  a2[199] = v64[199];
                                  a2[200] = v64[200];
                                  a2[201] = v64[201];
                                  a2[202] = v64[202];
                                  a2[203] = v64[203];
                                  a2[204] = v64[204];
                                  a2[205] = v64[205];
                                  a2[206] = v64[206];
                                  a2[207] = v64[207];
                                  a2[208] = v64[208];
                                  a2[209] = v64[209];
                                  a2[210] = v64[210];
                                  a2[211] = v64[211];
                                  a2[212] = v64[212];
                                  a2[213] = v64[213];
                                  a2[214] = v64[214];
                                  a2[215] = v64[215];
                                  a2[216] = v64[216];
                                  a2[217] = v64[217];
                                  a2[218] = v64[218];
                                  a2[219] = v64[219];
                                  a2[220] = v64[220];
                                  a2[221] = v64[221];
                                  a2[222] = v64[222];
                                  a2[223] = v64[223];
                                  a2[224] = v64[224];
                                  a2[225] = v64[225];
                                  a2[226] = v64[226];
                                  a2[227] = v64[227];
                                  a2[228] = v64[228];
                                  a2[229] = v64[229];
                                  a2[230] = v64[230];
                                  a2[231] = v64[231];
                                  a2[232] = v64[232];
                                  a2[233] = v64[233];
                                  a2[234] = v64[234];
                                  a2[235] = v64[235];
                                  a2[236] = v64[236];
                                  a2[237] = v64[237];
                                  a2[238] = v64[238];
                                  a2[239] = v64[239];
                                  a2[240] = v64[240];
                                  a2[241] = v64[241];
                                  a2[242] = v64[242];
                                  a2[243] = v64[243];
                                  a2[244] = v64[244];
                                  a2[245] = v64[245];
                                  a2[246] = v64[246];
                                  a2[247] = v64[247];
                                  a2[248] = v64[248];
                                  a2[249] = v64[249];
                                  a2[250] = v64[250];
                                  a2[251] = v64[251];
                                  a2[252] = v64[252];
                                  a2[253] = v64[253];
                                  a2[254] = v64[254];
                                  a2[255] = v64[255];
                                  a2[256] = v64[256];
                                  a2[257] = v64[257];
                                  a2[258] = v64[258];
                                  uint64_t v42 = 1;
                                  goto LABEL_35;
                                }
                                _ETLDebugPrint((uint64_t)"ETLMaverickParseRFSelfTestResultResponse", (uint64_t)"Received result has only %zu bytes, need %zu\n", v51, v52, v53, v54, v55, v56, v63);
                              }
                              else
                              {
                                _ETLDebugPrint((uint64_t)"ETLMaverickParseRFSelfTestResultResponse", (uint64_t)"Received response with failure status [%d]\n", v51, v52, v53, v54, v55, v56, v62);
                              }
                            }
                            else
                            {
                              _ETLDebugPrint((uint64_t)"ETLMaverickParseRFSelfTestResultResponse", (uint64_t)"Received response with progress in-complete [%d %%]\n", v51, v52, v53, v54, v55, v56, *(unsigned __int16 *)(v60 + 4));
                            }
                          }
                          else
                          {
                            _ETLDebugPrint((uint64_t)"ETLMaverickParseRFSelfTestResultResponse", (uint64_t)"Received response with invalid sub-command code [%d]\n", v51, v52, v53, v54, v55, v56, v61);
                          }
                        }
                      }
                      else
                      {
                        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v51, v52, v53, v54, v55, v56, v82);
                      }
                    }
                    else
                    {
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v51, v52, v53, v54, v55, v56, v83);
                    }
                  }
                }
              }
              else
              {
LABEL_39:
                free((void *)v42);
              }
            }
LABEL_34:
            uint64_t v42 = 0;
            goto LABEL_35;
          }
          _ETLDebugPrint((uint64_t)"ETLMaverickAddRFSubCommandHeader", (uint64_t)"Not enough room, need %zu, have %zu\n", v30, v31, v32, v33, v34, v35, 2);
          goto LABEL_32;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v75);
      }
      _ETLDebugPrint((uint64_t)"ETLMaverickAddRFSubCommandHeader", (uint64_t)"Failed on creating RF Command Header\n", v68, v69, v70, v71, v72, v73, v76);
LABEL_32:
      uint64_t v66 = "ETLMaverickAddRFSelfTestResultHeader";
      uint64_t v67 = "Failed on creating RF Sub Command Header\n";
      goto LABEL_33;
    }
    uint64_t v65 = "Result info parameter is NULL\n";
  }
  else
  {
    uint64_t v65 = "Transport parameter is NULL\n";
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickRFSelfTestResult", (uint64_t)v65, a3, a4, a5, a6, a7, a8, v75);
  return 0;
}

uint64_t ETLMaverickGetBasebandInitStatusEx(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), _DWORD *a2, uint64_t a3, int a4)
{
  uint64_t inited = 0;
  if (a1 && a2)
  {
    long long v39 = 0u;
    long long v40 = 0u;
    uint64_t v41 = 0;
    memset(v37, 0, sizeof(v37));
    uint64_t v38 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v16, v17, v18, v19, v20, v21, FreeSpace);
        goto LABEL_16;
      }
      int v42 = 5373259;
      if (HDLCFrameInject())
      {
        uint64_t v22 = malloc((2 * DWORD2(v39) + 32));
        if (v22)
        {
          uint64_t v23 = v22;
          uint64_t v24 = HDLCFrameEncode();
          if (v24)
          {
            int v25 = -1431655766;
            int v42 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0) {
              ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v23, v24);
            }
            if (*a1)
            {
              int v26 = (*a1)(a1, v23, v24, &v42, 1, a3, 0);
              int v25 = v42;
            }
            else
            {
              int v26 = 0;
            }
            if (v25 == v24) {
              LODWORD(v24) = v26;
            }
            else {
              LODWORD(v24) = 0;
            }
          }
          free(v23);
          if (!a4)
          {
LABEL_29:
            if (v24)
            {
              LOBYTE(v42) = 75;
              if (!_ETLResponseRingBuffer) {
                TelephonyUtilRingBufferInitialize();
              }
              uint64_t inited = 0;
              if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v37, (uint64_t)&_ETLResponseRingBuffer, &v42, a3)|| v42 != 75)
              {
                goto LABEL_36;
              }
              goto LABEL_34;
            }
            goto LABEL_35;
          }
LABEL_17:
          uint64_t inited = 0;
          LOBYTE(v42) = 75;
          *a2 = 0;
          if (v24)
          {
            if (!_ETLResponseRingBuffer) {
              TelephonyUtilRingBufferInitialize();
            }
            if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v37, (uint64_t)&_ETLResponseRingBuffer, &v42, a3))goto LABEL_35; {
            if (v42 == 75)
            }
            {
LABEL_34:
              uint64_t inited = ETLMaverickParseParseBasebandInitStatusResponse((unsigned int *)v37, a2, v29, v30, v31, v32, v33, v34);
              goto LABEL_36;
            }
            if (v42 != 19)
            {
LABEL_35:
              uint64_t inited = 0;
              goto LABEL_36;
            }
            _ETLDebugPrint((uint64_t)"ETLMaverickGetBasebandInitStatusEx", (uint64_t)"BB Init status handler is not regisered yet. Treat it as not done\n", v29, v30, v31, v32, v33, v34, v36);
            uint64_t inited = 1;
          }
LABEL_36:
          HDLCFrameFree();
          HDLCFrameFree();
          return inited;
        }
LABEL_16:
        LODWORD(v24) = 0;
        if (!a4) {
          goto LABEL_29;
        }
        goto LABEL_17;
      }
      uint64_t v27 = "ETLSubsysAddHeaderInternal";
      uint64_t v28 = "Failed to inject\n";
    }
    else
    {
      uint64_t v27 = "ETLMaverickGetBasebandInitStatusEx";
      uint64_t v28 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v27, (uint64_t)v28, v9, v10, v11, v12, v13, v14, v36);
    goto LABEL_16;
  }
  return inited;
}

uint64_t ETLMaverickParseParseBasebandInitStatusResponse(unsigned int *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a1[2];
  uint64_t v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
LABEL_11:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseParseBasebandInitStatusResponse", (uint64_t)"Failed on parsing BSP Response.\n", v13, v14, v15, v16, v17, v18, v19);
    return 0;
  }
  unsigned int v10 = **(_DWORD **)a1;
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
    goto LABEL_11;
  }
  if (BYTE1(v10) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
    goto LABEL_11;
  }
  uint64_t v11 = HIWORD(v10);
  if (v11 != 81)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
    goto LABEL_11;
  }
  if (v9 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseParseBasebandInitStatusResponse", (uint64_t)"Received response has only %u bytes, need %u bytes\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    *a2 = *(_DWORD *)(*(void *)a1 + 4);
    return 1;
  }
}

uint64_t ETLMaverickGetBasebandInitStatus(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), _DWORD *a2, uint64_t a3)
{
  return ETLMaverickGetBasebandInitStatusEx(a1, a2, a3, 0);
}

unint64_t ETLMaverickIPALoopback(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    long long v51 = 0u;
    long long v52 = 0u;
    uint64_t v53 = 0;
    memset(v49, 0, sizeof(v49));
    uint64_t v50 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v17, v18, v19, v20, v21, v22, FreeSpace);
      }
      else
      {
        unsigned int v56 = 5307723;
        if (HDLCFrameInject())
        {
          if (HDLCFrameGetFreeSpace() <= 0xC)
          {
            _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v29, v30, v31, v32, v33, v34, 13);
            int v45 = "ETLMaverickAddIPALoopbackHeader";
            unsigned int v46 = "There is no more free spaces.\n";
          }
          else
          {
            HDLCFrameInjectUnsignedChar();
            HDLCFrameInjectUnsignedInt();
            HDLCFrameInjectUnsignedInt();
            HDLCFrameInjectUnsignedInt();
            unint64_t v35 = (unint64_t)malloc((2 * DWORD2(v51) + 32));
            if (!v35)
            {
LABEL_29:
              HDLCFrameFree();
              HDLCFrameFree();
              return v35;
            }
            uint64_t v36 = HDLCFrameEncode();
            if (!v36) {
              goto LABEL_32;
            }
            uint64_t v37 = v36;
            unsigned int v56 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0) {
              ((void (*)(const char *, void, unint64_t, uint64_t))*(&gDelegate + 1))("", 0, v35, v36);
            }
            if (!*a1)
            {
LABEL_32:
              free((void *)v35);
              goto LABEL_28;
            }
            int v38 = ((uint64_t (*)(void *, unint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v35, v37, &v56, 1, a5, 0);
            unsigned int v39 = v56;
            free((void *)v35);
            unint64_t v35 = 0;
            if (!v38 || v39 != v37) {
              goto LABEL_29;
            }
            LOBYTE(v56) = 75;
            if (!_ETLResponseRingBuffer) {
              TelephonyUtilRingBufferInitialize();
            }
            unint64_t v35 = 0;
            if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v49, (uint64_t)&_ETLResponseRingBuffer, &v56, a5)|| v56 != 75)
            {
              goto LABEL_29;
            }
            unsigned int v56 = 0;
            unsigned __int16 v55 = -21846;
            unsigned __int16 v54 = -21846;
            if (ETLSubsysParseHeader((uint64_t)v49, &v55, &v54, &v56, v40, v41, v42, v43))
            {
              if (v55 == 253)
              {
                if (v54 == 80)
                {
                  uint64_t v44 = DWORD2(v49[0]) - v56;
                  if (v44 > 4)
                  {
                    unint64_t v35 = (*(unsigned __int8 *)(*(void *)&v49[0] + v56) | *(_DWORD *)(*(void *)&v49[0] + v56 + 1)) == 0;
                    goto LABEL_29;
                  }
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseIPALoopbackResponse", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v10, v11, v12, v13, v14, v15, v44);
LABEL_28:
                  unint64_t v35 = 0;
                  goto LABEL_29;
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v10, v11, v12, v13, v14, v15, v54);
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v10, v11, v12, v13, v14, v15, v55);
              }
            }
            int v45 = "ETLMaverickParseIPALoopbackResponse";
            unsigned int v46 = "Failed on parsing BSP Response.\n";
          }
LABEL_27:
          _ETLDebugPrint((uint64_t)v45, (uint64_t)v46, v10, v11, v12, v13, v14, v15, v48);
          goto LABEL_28;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v23, v24, v25, v26, v27, v28, v48);
      }
      int v45 = "ETLMaverickAddIPALoopbackHeader";
      unsigned int v46 = "Failed to create command header\n";
      goto LABEL_27;
    }
    int v45 = "ETLMaverickIPALoopback";
    unsigned int v46 = "Failed to create command frame\n";
    goto LABEL_27;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickIPALoopback", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v48);
  return 0;
}

uint64_t ETLMaverickIPALoopbackV2(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    int v38 = "Transport cannot be NULL\n";
LABEL_11:
    _ETLDebugPrint((uint64_t)"ETLMaverickIPALoopbackV2", (uint64_t)v38, a3, a4, a5, a6, a7, a8, v59);
    return 0;
  }
  memset(v63, 0, sizeof(v63));
  uint64_t v64 = 0;
  memset(v61, 0, sizeof(v61));
  uint64_t v62 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    int v38 = "Failed to create command frame\n";
    goto LABEL_11;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
LABEL_14:
    _ETLDebugPrint((uint64_t)"ETLMaverickAddDataSubCommandHeader", (uint64_t)"Failed on creating Data Command Header\n", v40, v41, v42, v43, v44, v45, v60);
LABEL_15:
    unsigned int v46 = "ETLMaverickAddIPALoopbackV2Header";
    uint64_t v47 = "Failed to create command header with subcommand\n";
    goto LABEL_16;
  }
  v65[0] = 268461131;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v17, v18, v19, v20, v21, v22, v59);
    goto LABEL_14;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickAddDataSubCommandHeader", (uint64_t)"Not enough room, need %zu, have %zu\n", v23, v24, v25, v26, v27, v28, 2);
    goto LABEL_15;
  }
  uint64_t v29 = (capabilities::etl *)HDLCFrameInjectUnsignedShort();
  int MaverickIPALoopbackV2ParametersType = capabilities::etl::getMaverickIPALoopbackV2ParametersType(v29);
  if (MaverickIPALoopbackV2ParametersType)
  {
    if (MaverickIPALoopbackV2ParametersType == 1)
    {
      int v37 = 23;
      goto LABEL_21;
    }
    uint64_t v47 = "Invalid radio for IPA Loopback V2 Header";
    unsigned int v46 = "ETLMaverickAddIPALoopbackV2Header";
LABEL_16:
    _ETLDebugPrint((uint64_t)v46, (uint64_t)v47, v31, v32, v33, v34, v35, v36, v59);
    goto LABEL_17;
  }
  int v37 = 14;
LABEL_21:
  v65[0] = 1;
  v65[1] = v37;
  v65[2] = 1;
  if (HDLCFrameGetFreeSpace() <= 0xB)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v49, v50, v51, v52, v53, v54, 12);
    uint64_t v47 = "There is no more free space\n";
    unsigned int v46 = "ETLMaverickAddIPALoopbackV2Header";
    goto LABEL_16;
  }
  if (!HDLCFrameInject()
    || !ETLSendCommand(a1, (uint64_t)v63, a2)
    || !ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v61, a2))
  {
    goto LABEL_17;
  }
  v65[0] = 0;
  unsigned __int16 v67 = -21846;
  unsigned __int16 v66 = -21846;
  if (!ETLSubsysParseHeader((uint64_t)v61, &v67, &v66, v65, v55, v56, v57, v58)) {
    goto LABEL_34;
  }
  if (v67 != 100)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v31, v32, v33, v34, v35, v36, v67);
LABEL_34:
    unsigned int v46 = "ETLMaverickParseIPALoopbackV2Response";
    uint64_t v47 = "Failed on parsing Data Response.\n";
    goto LABEL_16;
  }
  if (v66 != 4096)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v31, v32, v33, v34, v35, v36, v66);
    goto LABEL_34;
  }
  if ((DWORD2(v61[0]) - v65[0]) > 4)
  {
    uint64_t v48 = 1;
    goto LABEL_18;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickParseIPALoopbackV2Response", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v31, v32, v33, v34, v35, v36, (DWORD2(v61[0]) - v65[0]));
LABEL_17:
  uint64_t v48 = 0;
LABEL_18:
  HDLCFrameFree();
  HDLCFrameFree();
  return v48;
}

const char *ETLMaverickAPWakeReasonToString(int a1)
{
  uint64_t v1 = "Invalid";
  if (a1 == 2) {
    uint64_t v1 = "Forced";
  }
  if (a1 == 1) {
    return "Data Activity";
  }
  else {
    return v1;
  }
}

uint64_t ETLMaverickMHIPeriodicRemoteWake(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    long long v52 = 0u;
    long long v53 = 0u;
    uint64_t v54 = 0;
    memset(v50, 0, sizeof(v50));
    uint64_t v51 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v17, v18, v19, v20, v21, v22, FreeSpace);
      }
      else
      {
        unsigned int v57 = 5176651;
        if (HDLCFrameInject())
        {
          if (HDLCFrameGetFreeSpace() <= 3)
          {
            _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v29, v30, v31, v32, v33, v34, 4);
            unsigned int v46 = "ETLMaverickAddMHIPeriodicRemoteWakeHeader";
            uint64_t v47 = "There is no more free space.\n";
          }
          else
          {
            HDLCFrameInjectUnsignedChar();
            HDLCFrameInjectUnsignedChar();
            HDLCFrameInjectUnsignedShort();
            uint64_t v35 = (uint64_t)malloc((2 * DWORD2(v52) + 32));
            if (!v35)
            {
LABEL_31:
              HDLCFrameFree();
              HDLCFrameFree();
              return v35;
            }
            uint64_t v36 = HDLCFrameEncode();
            if (!v36) {
              goto LABEL_34;
            }
            uint64_t v37 = v36;
            unsigned int v57 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0) {
              ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v35, v36);
            }
            if (!*a1)
            {
LABEL_34:
              free((void *)v35);
              goto LABEL_30;
            }
            int v38 = ((uint64_t (*)(void *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v35, v37, &v57, 1, a4, 0);
            unsigned int v39 = v57;
            free((void *)v35);
            uint64_t v35 = 0;
            if (!v38 || v39 != v37) {
              goto LABEL_31;
            }
            LOBYTE(v57) = 75;
            if (!_ETLResponseRingBuffer) {
              TelephonyUtilRingBufferInitialize();
            }
            uint64_t v35 = 0;
            if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v50, (uint64_t)&_ETLResponseRingBuffer, &v57, a4)|| v57 != 75)
            {
              goto LABEL_31;
            }
            unsigned int v57 = 0;
            unsigned __int16 v56 = -21846;
            unsigned __int16 v55 = -21846;
            if (ETLSubsysParseHeader((uint64_t)v50, &v56, &v55, &v57, v40, v41, v42, v43))
            {
              if (v56 == 253)
              {
                if (v55 == 78)
                {
                  uint64_t v44 = DWORD2(v50[0]) - v57;
                  if (v44 <= 4)
                  {
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponse", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v10, v11, v12, v13, v14, v15, v44);
                  }
                  else
                  {
                    uint64_t v45 = *(unsigned int *)(*(void *)&v50[0] + v57 + 1);
                    if (v45 == 1 && *(unsigned char *)(*(void *)&v50[0] + v57) == 2)
                    {
                      uint64_t v35 = 1;
                      goto LABEL_31;
                    }
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponse", (uint64_t)"Received response with failure status [%u] and command type [%u]\n", v10, v11, v12, v13, v14, v15, v45);
                  }
LABEL_30:
                  uint64_t v35 = 0;
                  goto LABEL_31;
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v10, v11, v12, v13, v14, v15, v55);
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v10, v11, v12, v13, v14, v15, v56);
              }
            }
            unsigned int v46 = "ETLMaverickParseMHIPeriodicRemoteWakeResponse";
            uint64_t v47 = "Failed to parse BSP response header\n";
          }
LABEL_29:
          _ETLDebugPrint((uint64_t)v46, (uint64_t)v47, v10, v11, v12, v13, v14, v15, v49);
          goto LABEL_30;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v23, v24, v25, v26, v27, v28, v49);
      }
      unsigned int v46 = "ETLMaverickAddMHIPeriodicRemoteWakeHeader";
      uint64_t v47 = "Failed to create command header\n";
      goto LABEL_29;
    }
    unsigned int v46 = "ETLMaverickMHIPeriodicRemoteWake";
    uint64_t v47 = "Failed to create command frame\n";
    goto LABEL_29;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickMHIPeriodicRemoteWake", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v49);
  return 0;
}

uint64_t ETLMaverickMHIPeriodicRemoteWakeV2(void *a1, unsigned __int8 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    long long v84 = 0u;
    long long v85 = 0u;
    uint64_t v86 = 0;
    memset(v82, 0, sizeof(v82));
    uint64_t v83 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
      }
      else
      {
        unsigned int v89 = 916811;
        if (HDLCFrameInject())
        {
          if (HDLCFrameGetFreeSpace() <= 5)
          {
            _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v30, v31, v32, v33, v34, v35, 6);
            unsigned int v46 = "ETLMaverickAddMHIPeriodicRemoteWakeHeaderV2";
            uint64_t v47 = "There is no more free space.\n";
          }
          else
          {
            HDLCFrameInjectUnsignedShort();
            HDLCFrameInjectUnsignedInt();
            uint64_t v36 = (uint64_t)malloc((2 * DWORD2(v84) + 32));
            if (!v36)
            {
LABEL_30:
              HDLCFrameFree();
              HDLCFrameFree();
              return v36;
            }
            uint64_t v37 = HDLCFrameEncode();
            if (!v37) {
              goto LABEL_33;
            }
            uint64_t v38 = v37;
            unsigned int v89 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0) {
              ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v36, v37);
            }
            if (!*a1)
            {
LABEL_33:
              free((void *)v36);
              goto LABEL_29;
            }
            int v39 = ((uint64_t (*)(void *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v36, v38, &v89, 1, a4, 0);
            unsigned int v40 = v89;
            free((void *)v36);
            uint64_t v36 = 0;
            if (!v39 || v40 != v38) {
              goto LABEL_30;
            }
            LOBYTE(v89) = 75;
            if (!_ETLResponseRingBuffer) {
              TelephonyUtilRingBufferInitialize();
            }
            uint64_t v36 = 0;
            if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v82, (uint64_t)&_ETLResponseRingBuffer, &v89, a4)|| v89 != 75)
            {
              goto LABEL_30;
            }
            unsigned int v89 = 0;
            unsigned __int16 v88 = -21846;
            unsigned __int16 v87 = -21846;
            if (ETLSubsysParseHeader((uint64_t)v82, &v88, &v87, &v89, v41, v42, v43, v44))
            {
              if (v88 == 253)
              {
                if (v87 == 13)
                {
                  uint64_t v45 = DWORD2(v82[0]) - v89;
                  if (v45 <= 0x15)
                  {
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v11, v12, v13, v14, v15, v16, v45);
                  }
                  else
                  {
                    if (!*(unsigned char *)(*(void *)&v82[0] + v89))
                    {
                      uint64_t v49 = *(unsigned int *)(*(void *)&v82[0] + v89 + 2);
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"Status: %s\n", v11, v12, v13, v14, v15, v16, (uint64_t)"success");
                      if (a2 == 1)
                      {
                        uint64_t v62 = "Invalid";
                        if (v49 == 2) {
                          uint64_t v62 = "Forced";
                        }
                        if (v49 == 1) {
                          uint64_t v62 = "Data Activity";
                        }
                        _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"Wakeup reason: %s\n", v50, v51, v52, v53, v54, v55, (uint64_t)v62);
                      }
                      else if (a2)
                      {
                        _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"Invalid subCMD: %u\n", v50, v51, v52, v53, v54, v55, a2);
                      }
                      else
                      {
                        _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"Delay: %u ms\n", v50, v51, v52, v53, v54, v55, v49);
                      }
                      uint64_t v36 = 1;
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"MHI channel %d mask: %u\n", v56, v57, v58, v59, v60, v61, 1);
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"MHI channel %d mask: %u\n", v63, v64, v65, v66, v67, v68, 2);
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"MHI channel %d mask: %u\n", v69, v70, v71, v72, v73, v74, 3);
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"MHI channel %d mask: %u\n", v75, v76, v77, v78, v79, v80, 4);
                      goto LABEL_30;
                    }
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseMHIPeriodicRemoteWakeResponseV2", (uint64_t)"Received response with failure status [%u]\n", v11, v12, v13, v14, v15, v16, *(unsigned __int8 *)(*(void *)&v82[0] + v89));
                  }
                  goto LABEL_29;
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v11, v12, v13, v14, v15, v16, v87);
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v11, v12, v13, v14, v15, v16, v88);
              }
            }
            unsigned int v46 = "ETLMaverickParseMHIPeriodicRemoteWakeResponseV2";
            uint64_t v47 = "Failed to parse BSP response header\n";
          }
LABEL_28:
          _ETLDebugPrint((uint64_t)v46, (uint64_t)v47, v11, v12, v13, v14, v15, v16, v81);
LABEL_29:
          uint64_t v36 = 0;
          goto LABEL_30;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v24, v25, v26, v27, v28, v29, v81);
      }
      unsigned int v46 = "ETLMaverickAddMHIPeriodicRemoteWakeHeaderV2";
      uint64_t v47 = "Failed to create command header\n";
      goto LABEL_28;
    }
    unsigned int v46 = "ETLMaverickMHIPeriodicRemoteWakeV2";
    uint64_t v47 = "Failed to create command frame\n";
    goto LABEL_28;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickMHIPeriodicRemoteWakeV2", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v81);
  return 0;
}

uint64_t ETLMaverickADPLEnable(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickADPLEnable", (uint64_t)"transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v39);
    return 0;
  }
  memset(v42, 0, sizeof(v42));
  uint64_t v43 = 0;
  memset(v40, 0, sizeof(v40));
  uint64_t v41 = 0;
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_21;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_21;
  }
  unsigned int v46 = 1073767499;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v17, v18, v19, v20, v21, v22, v39);
    goto LABEL_21;
  }
  if (!HDLCFrameInjectUnsignedChar())
  {
LABEL_21:
    uint64_t v23 = 0;
    goto LABEL_22;
  }
  uint64_t v23 = 0;
  if (HDLCFrameInjectUnsignedChar())
  {
    if (!HDLCFrameInjectUnsignedShort()
      || !HDLCFrameInjectUnsignedInt()
      || !ETLSendCommand(a1, (uint64_t)v42, a3)
      || !ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v40, a3))
    {
      goto LABEL_21;
    }
    unsigned int v46 = 0;
    unsigned __int16 v45 = -21846;
    unsigned __int16 v44 = -21846;
    if (ETLSubsysParseHeader((uint64_t)v40, &v45, &v44, &v46, v24, v25, v26, v27))
    {
      if (v45 == 100)
      {
        if (v44 == 0x4000)
        {
          uint64_t v34 = DWORD2(v40[0]) - v46;
          if (v34 > 1)
          {
            uint64_t v35 = (unsigned __int8 *)(*(void *)&v40[0] + v46);
            uint64_t v36 = *v35;
            if (v36 == 4)
            {
              unsigned int v37 = v35[1];
              if (v37 == 1)
              {
                uint64_t v23 = 1;
                goto LABEL_22;
              }
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickADPLParseResponse", (uint64_t)"Received response with version [%u] while expecting [%u]\n", v28, v29, v30, v31, v32, v33, v36);
              unsigned int v37 = v35[1];
            }
            _ETLDebugPrint((uint64_t)"ETLMaverickADPLParseResponse", (uint64_t)"Received response with failure status [%u]\n", v28, v29, v30, v31, v32, v33, v37);
            goto LABEL_21;
          }
LABEL_26:
          _ETLDebugPrint((uint64_t)"ETLMaverickADPLParseResponse", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v28, v29, v30, v31, v32, v33, v34);
          goto LABEL_21;
        }
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v28, v29, v30, v31, v32, v33, v44);
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v28, v29, v30, v31, v32, v33, v45);
      }
    }
    uint64_t v34 = DWORD2(v40[0]) - v46;
    goto LABEL_26;
  }
LABEL_22:
  HDLCFrameFree();
  HDLCFrameFree();
  return v23;
}

uint64_t ETLMaverickGetResetProperties(uint64_t (**a1)(void, uint64_t, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    long long v44 = 0u;
    long long v45 = 0u;
    uint64_t v46 = 0;
    memset(v42, 0, sizeof(v42));
    uint64_t v43 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
      }
      else
      {
        int v47 = 9436491;
        if (HDLCFrameInject())
        {
          uint64_t v24 = (uint64_t)malloc((2 * DWORD2(v44) + 32));
          if (!v24)
          {
LABEL_26:
            HDLCFrameFree();
            HDLCFrameFree();
            return v24;
          }
          uint64_t v25 = HDLCFrameEncode();
          if (v25)
          {
            uint64_t v26 = v25;
            int v47 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0) {
              ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v24, v25);
            }
            if (*a1)
            {
              int v27 = (*a1)(a1, v24, v26, &v47, 1, a3, 0);
              int v28 = v47;
              free((void *)v24);
              uint64_t v24 = 0;
              if (!v27 || v28 != v26) {
                goto LABEL_26;
              }
              LOBYTE(v47) = 75;
              if (!_ETLResponseRingBuffer) {
                TelephonyUtilRingBufferInitialize();
              }
              uint64_t v24 = 0;
              if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v42, (uint64_t)&_ETLResponseRingBuffer, &v47, a3)|| v47 != 75)
              {
                goto LABEL_26;
              }
              uint64_t v35 = (DWORD2(v42[0]) - 4);
              if (DWORD2(v42[0]) < 4)
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v29, v30, v31, v32, v33, v34, DWORD2(v42[0]));
              }
              else
              {
                uint64_t v36 = *(void *)&v42[0];
                unsigned int v37 = **(_DWORD **)&v42[0];
                if (**(_DWORD **)&v42[0] == 75)
                {
                  if (BYTE1(v37) == 253)
                  {
                    uint64_t v38 = HIWORD(v37);
                    if (v38 == 143)
                    {
                      if (v35 > 6)
                      {
                        *(unsigned char *)a2 = *(unsigned char *)(*(void *)&v42[0] + 4);
                        *(_WORD *)(a2 + 2) = *(_WORD *)(v36 + 5);
                        *(_DWORD *)(a2 + 4) = *(_DWORD *)(v36 + 7);
                        uint64_t v24 = 1;
                        goto LABEL_26;
                      }
                      goto LABEL_33;
                    }
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v29, v30, v31, v32, v33, v34, v38);
                  }
                  else
                  {
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v29, v30, v31, v32, v33, v34, BYTE1(v37));
                  }
                  int v40 = -4;
LABEL_32:
                  uint64_t v35 = (DWORD2(v42[0]) + v40);
LABEL_33:
                  _ETLDebugPrint((uint64_t)"ETLMaverickGetResetPropertiesParseResponse", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v29, v30, v31, v32, v33, v34, v35);
                  goto LABEL_25;
                }
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v29, v30, v31, v32, v33, v34, **(_DWORD **)&v42[0]);
              }
              int v40 = 0;
              goto LABEL_32;
            }
          }
          free((void *)v24);
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v18, v19, v20, v21, v22, v23, v41);
        }
      }
    }
LABEL_25:
    uint64_t v24 = 0;
    goto LABEL_26;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickGetResetProperties", (uint64_t)"transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v41);
  return 0;
}

uint64_t ETLMaverickQDSSEnable(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    long long v61 = 0u;
    long long v62 = 0u;
    uint64_t v63 = 0;
    long long v58 = 0u;
    long long v59 = 0u;
    uint64_t v60 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
      }
      else
      {
        int v66 = 16865867;
        if (HDLCFrameInject())
        {
          if (!HDLCFrameInjectUnsignedChar()) {
            goto LABEL_38;
          }
          uint64_t v23 = malloc((2 * DWORD2(v61) + 32));
          if (!v23) {
            goto LABEL_38;
          }
          uint64_t v24 = v23;
          uint64_t v25 = HDLCFrameEncode();
          if (!v25) {
            goto LABEL_40;
          }
          uint64_t v26 = v25;
          int v66 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v24, v25);
          }
          if (*a1)
          {
            int v27 = (*a1)(a1, v24, v26, &v66, 1, a3, 0);
            int v28 = v66;
            free(v24);
            if (!v27 || v28 != v26) {
              goto LABEL_38;
            }
            LOBYTE(v66) = 75;
            if (!_ETLResponseRingBuffer) {
              TelephonyUtilRingBufferInitialize();
            }
            if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)&v58, (uint64_t)&_ETLResponseRingBuffer, &v66, a3))goto LABEL_38; {
            if (v66 != 75)
            }
              goto LABEL_38;
            int v66 = 0;
            unsigned __int16 v65 = -21846;
            unsigned __int16 v64 = -21846;
            if (!ETLSubsysParseHeader((uint64_t)&v58, &v65, &v64, &v66, v29, v30, v31, v32)) {
              goto LABEL_38;
            }
            uint64_t v39 = v65;
            if (v65 == 90)
            {
              uint64_t v40 = v64;
              if (v64 != 257)
              {
LABEL_42:
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v33, v34, v35, v36, v37, v38, v40);
                goto LABEL_38;
              }
              HDLCFrameFree();
              HDLCFrameFree();
              long long v61 = 0u;
              long long v62 = 0u;
              uint64_t v63 = 0;
              long long v58 = 0u;
              long long v59 = 0u;
              uint64_t v60 = 0;
              if (!HDLCFrameCreateUplink()) {
                goto LABEL_38;
              }
              if (!ETLMaverickQDSSBuildCommand()) {
                goto LABEL_38;
              }
              if (!ETLSendCommand(a1, (uint64_t)&v61, a3)) {
                goto LABEL_38;
              }
              if (!ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)&v58, a3)) {
                goto LABEL_38;
              }
              int v66 = 0;
              unsigned __int16 v65 = -21846;
              unsigned __int16 v64 = -21846;
              if (!ETLSubsysParseHeader((uint64_t)&v58, &v65, &v64, &v66, v41, v42, v43, v44)) {
                goto LABEL_38;
              }
              uint64_t v39 = v65;
              if (v65 == 18)
              {
                uint64_t v40 = v64;
                if (v64 == 548)
                {
                  HDLCFrameFree();
                  HDLCFrameFree();
                  long long v61 = 0u;
                  long long v62 = 0u;
                  uint64_t v63 = 0;
                  long long v58 = 0u;
                  long long v59 = 0u;
                  uint64_t v60 = 0;
                  if (HDLCFrameCreateUplink()
                    && ETLMaverickQDSSBuildCommand()
                    && ETLSendCommand(a1, (uint64_t)&v61, a3)
                    && ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)&v58, a3))
                  {
                    int v66 = 0;
                    unsigned __int16 v65 = -21846;
                    unsigned __int16 v64 = -21846;
                    uint64_t v55 = 0;
                    if (!ETLSubsysParseHeader((uint64_t)&v58, &v65, &v64, &v66, v45, v46, v47, v48))
                    {
LABEL_48:
                      HDLCFrameFree();
                      HDLCFrameFree();
                      return v55;
                    }
                    if (v65 == 18)
                    {
                      if (v64 == 548)
                      {
                        uint64_t v55 = 1;
                        goto LABEL_48;
                      }
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v49, v50, v51, v52, v53, v54, v64);
                    }
                    else
                    {
                      _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v49, v50, v51, v52, v53, v54, v65);
                    }
                  }
                  uint64_t v55 = 0;
                  goto LABEL_48;
                }
                goto LABEL_42;
              }
            }
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v33, v34, v35, v36, v37, v38, v39);
          }
          else
          {
LABEL_40:
            free(v24);
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v17, v18, v19, v20, v21, v22, v57);
        }
      }
    }
LABEL_38:
    HDLCFrameFree();
    HDLCFrameFree();
    return 0;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickQDSSEnable", (uint64_t)"transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v57);
  return 1;
}

uint64_t ETLMaverickQDSSBuildCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v14);
    return 0;
  }
  if (!HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar())
  {
    return 0;
  }

  return HDLCFrameInjectUnsignedChar();
}

uint64_t ETLMaverickSetFlags(void *a1, uint64_t a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    *a4 = 0;
    _ETLDebugPrint((uint64_t)"ETLMaverickSetFlags", (uint64_t)"Setting enabled to 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, a2);
    uint64_t v47 = 0;
    long long v45 = 0u;
    long long v46 = 0u;
    memset(v43, 0, sizeof(v43));
    uint64_t v44 = 0;
    uint64_t v12 = 0;
    if (!HDLCFrameCreateUplink())
    {
LABEL_26:
      HDLCFrameFree();
      HDLCFrameFree();
      return v12;
    }
    uint64_t FreeSpace = HDLCFrameGetFreeSpace();
    if (FreeSpace >= 4)
    {
      unsigned int v50 = 7994699;
      if (HDLCFrameInject())
      {
        if (HDLCFrameGetFreeSpace() <= 1)
        {
          uint64_t v42 = 2;
          uint64_t v38 = "ETLMaverickCreateSetFlagsCommand";
          uint64_t v39 = "Not enough room, need %zu, have %u\n";
        }
        else
        {
          if (!HDLCFrameInjectUnsignedInt()) {
            goto LABEL_25;
          }
          uint64_t v26 = malloc((2 * DWORD2(v45) + 32));
          if (!v26) {
            goto LABEL_25;
          }
          int v27 = v26;
          uint64_t v28 = HDLCFrameEncode();
          if (!v28) {
            goto LABEL_28;
          }
          uint64_t v29 = v28;
          unsigned int v50 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v27, v28);
          }
          if (!*a1)
          {
LABEL_28:
            free(v27);
            goto LABEL_25;
          }
          int v30 = ((uint64_t (*)(void *, void *, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v27, v29, &v50, 1, a5, 0);
          unsigned int v31 = v50;
          free(v27);
          uint64_t v12 = 0;
          if (!v30 || v31 != v29) {
            goto LABEL_26;
          }
          if (!ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v43, a5)) {
            goto LABEL_25;
          }
          unsigned int v50 = 0;
          unsigned __int16 v49 = -21846;
          unsigned __int16 v48 = -21846;
          if (ETLSubsysParseHeader((uint64_t)v43, &v49, &v48, &v50, v32, v33, v34, v35))
          {
            if (v49 == 253)
            {
              if (v48 == 121)
              {
                *a4 = 0;
                uint64_t v36 = DWORD2(v43[0]) - v50;
                if (v36 > 7)
                {
                  uint64_t v37 = (_DWORD *)(*(void *)&v43[0] + v50);
                  *a3 = *v37;
                  *a4 = v37[1];
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSetFlagsResponse", (uint64_t)"Received response w/ flag [%u] and version [%u]\n", v20, v21, v22, v23, v24, v25, *a3);
                  uint64_t v12 = 1;
                  goto LABEL_26;
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSetFlagsResponse", (uint64_t)"Received response has only %u bytes, need %u bytes\n", v20, v21, v22, v23, v24, v25, v36);
LABEL_25:
                uint64_t v12 = 0;
                goto LABEL_26;
              }
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v20, v21, v22, v23, v24, v25, v48);
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v20, v21, v22, v23, v24, v25, v49);
            }
          }
          uint64_t v38 = "ETLMaverickParseSetFlagsResponse";
          uint64_t v39 = "Failed to parse BSP response header\n";
        }
      }
      else
      {
        uint64_t v38 = "ETLSubsysAddHeaderInternal";
        uint64_t v39 = "Failed to inject\n";
      }
      _ETLDebugPrint((uint64_t)v38, (uint64_t)v39, v20, v21, v22, v23, v24, v25, v42);
      goto LABEL_25;
    }
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v14, v15, v16, v17, v18, v19, FreeSpace);
    goto LABEL_25;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickSetFlags", (uint64_t)"transport cannot be NULL\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, v41);
  return 0;
}

uint64_t ETLMaverickParseCSNResponse(unsigned int *a1, _DWORD *a2, unsigned char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a2 = 0;
  *a3 = 0;
  unsigned int v8 = a1[2];
  uint64_t v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    unsigned int v10 = **(_DWORD **)a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 253)
      {
        uint64_t v11 = HIWORD(v10);
        if (v11 == a4)
        {
          if (v9 <= 0x11)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseCSNResponse", (uint64_t)"Received response has only %u bytes, need %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else
          {
            int v12 = *(unsigned __int8 *)(*(void *)a1 + 4);
            *a3 = v12;
            switch(v12)
            {
              case 3:
                uint64_t result = 1;
                *a2 = 1;
                break;
              case 2:
                return 1;
              case 1:
                *a2 = 2;
                return 1;
              default:
                return 0;
            }
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v11);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
  return result;
}

uint64_t ETLMaverickGetCardType(void *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v49 = 0u;
  long long v50 = 0u;
  uint64_t v51 = 0;
  memset(v47, 0, sizeof(v47));
  uint64_t v48 = 0;
  if (!a2 || (HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v29 = "ETLMaverickGetCardType";
    int v30 = "Failed to create command frame\n";
LABEL_20:
    _ETLDebugPrint((uint64_t)v29, (uint64_t)v30, a3, a4, a5, a6, a7, a8, v45);
LABEL_21:
    uint64_t v24 = 0;
    goto LABEL_22;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
    goto LABEL_21;
  }
  int v52 = 5504331;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v29 = "ETLSubsysAddHeaderInternal";
    int v30 = "Failed to inject\n";
    goto LABEL_20;
  }
  char v46 = -86;
  if (!HDLCFrameInjectUnsignedChar()) {
    goto LABEL_21;
  }
  uint64_t v18 = malloc((2 * DWORD2(v49) + 32));
  if (!v18) {
    goto LABEL_21;
  }
  uint64_t v19 = v18;
  uint64_t v20 = HDLCFrameEncode();
  if (!v20) {
    goto LABEL_44;
  }
  uint64_t v21 = v20;
  int v52 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v19, v20);
  }
  if (!*a1)
  {
LABEL_44:
    free(v19);
    goto LABEL_21;
  }
  int v22 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v19, v21, &v52, 1, a4, 0);
  int v23 = v52;
  free(v19);
  uint64_t v24 = 0;
  if (v22 && v23 == v21)
  {
    LOBYTE(v52) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    uint64_t v24 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v47, (uint64_t)&_ETLResponseRingBuffer, &v52, a4))
    {
      if (v52 == 75)
      {
        uint64_t v24 = ETLMaverickParseCSNResponse((unsigned int *)v47, a2, &v46, 83, v25, v26, v27, v28);
        if (v46 == 2)
        {
          while (1)
          {
            while (1)
            {
              do
              {
                do
                {
                  char v32 = v24;
                  usleep(0x186A0u);
                  LOBYTE(v24) = 0;
                }
                while ((v32 & 1) == 0);
                uint64_t v33 = malloc((2 * DWORD2(v49) + 32));
                LOBYTE(v24) = 0;
              }
              while (!v33);
              uint64_t v34 = v33;
              uint64_t v35 = HDLCFrameEncode();
              if (v35) {
                break;
              }
LABEL_23:
              free(v34);
              LOBYTE(v24) = 0;
            }
            uint64_t v36 = v35;
            int v52 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0)
            {
              ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v34, v35);
              uint64_t v37 = (uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1;
              if (!*a1) {
                goto LABEL_23;
              }
            }
            else
            {
              uint64_t v37 = (uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1;
              if (!*a1) {
                goto LABEL_23;
              }
            }
            int v38 = v37(a1, v34, v36, &v52, 1, a4, 0);
            int v39 = v52;
            free(v34);
            LOBYTE(v24) = 0;
            if (v38) {
              BOOL v40 = v39 == v36;
            }
            else {
              BOOL v40 = 0;
            }
            if (v40)
            {
              LOBYTE(v52) = 75;
              if (!_ETLResponseRingBuffer) {
                TelephonyUtilRingBufferInitialize();
              }
              LOBYTE(v24) = 0;
              if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v47, (uint64_t)&_ETLResponseRingBuffer, &v52, a4))
              {
                if (v52 == 75)
                {
                  uint64_t v24 = ETLMaverickParseCSNResponse((unsigned int *)v47, a2, &v46, 83, v41, v42, v43, v44);
                  if (v46 != 2) {
                    break;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_22:
  HDLCFrameFree();
  HDLCFrameFree();
  return v24;
}

uint64_t ETLMaverickParseBSPExtResponse(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a2;
  uint64_t v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, v9);
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseBSPExtResponse", (uint64_t)"Failed to parse BSP response header\n", v15, v16, v17, v18, v19, v20, v21);
    return 0;
  }
  unsigned int v10 = *(_DWORD *)(*(void *)a1 + v8);
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
    goto LABEL_12;
  }
  unsigned int v11 = v8 + 4;
  *a2 = v8 + 4;
  if (BYTE1(v10) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
    goto LABEL_12;
  }
  uint64_t v12 = HIWORD(v10);
  if (v12 != 68)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
    goto LABEL_12;
  }
  if (*(_DWORD *)(a1 + 8) - v11 <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseBSPExtResponse", (uint64_t)"Received response has only %u bytes, need %u bytes\n", a3, a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 8) - v11);
    return 0;
  }
  else
  {
    uint64_t v13 = *(unsigned __int16 *)(*(void *)a1 + v11);
    if (v13 == 1)
    {
      *a2 = v8 + 6;
      return 1;
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickParseBSPExtResponse", (uint64_t)"Received response with failure status [%d]\n", a3, a4, a5, a6, a7, a8, v13);
      return 0;
    }
  }
}

uint64_t ETLCDMAMakeMEID(_DWORD *a1, int *a2)
{
  if (a1) {
    BOOL v2 = a2 == 0;
  }
  else {
    BOOL v2 = 1;
  }
  uint64_t v3 = !v2;
  if (!v2)
  {
    int v4 = *a2;
    *(_DWORD *)((char *)a1 + 3) = *(int *)((char *)a2 + 3);
    *a1 = v4;
  }
  return v3;
}

uint64_t ETLCDMAMakeMEIDFromString(unsigned char *a1, char *__s, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v9 = 0;
  if (a1 && __s && (size_t v9 = strlen(__s), v9 == 14))
  {
    int v10 = TelephonyUtilDecodeHexWithDefault();
    int v11 = TelephonyUtilDecodeHexWithDefault();
    if (((v11 | (16 * v10)) & 0x80000000) == 0)
    {
      *a1 = v11 | (16 * v10);
      int v12 = TelephonyUtilDecodeHexWithDefault();
      int v13 = TelephonyUtilDecodeHexWithDefault();
      if (((v13 | (16 * v12)) & 0x80000000) == 0)
      {
        a1[1] = v13 | (16 * v12);
        int v14 = TelephonyUtilDecodeHexWithDefault();
        int v15 = TelephonyUtilDecodeHexWithDefault();
        if (((v15 | (16 * v14)) & 0x80000000) == 0)
        {
          a1[2] = v15 | (16 * v14);
          int v16 = TelephonyUtilDecodeHexWithDefault();
          int v17 = TelephonyUtilDecodeHexWithDefault();
          if (((v17 | (16 * v16)) & 0x80000000) == 0)
          {
            a1[3] = v17 | (16 * v16);
            int v18 = TelephonyUtilDecodeHexWithDefault();
            int v19 = TelephonyUtilDecodeHexWithDefault();
            if (((v19 | (16 * v18)) & 0x80000000) == 0)
            {
              a1[4] = v19 | (16 * v18);
              int v20 = TelephonyUtilDecodeHexWithDefault();
              int v21 = TelephonyUtilDecodeHexWithDefault();
              if (((v21 | (16 * v20)) & 0x80000000) == 0)
              {
                a1[5] = v21 | (16 * v20);
                int v22 = TelephonyUtilDecodeHexWithDefault();
                int v23 = TelephonyUtilDecodeHexWithDefault() | (16 * v22);
                if ((v23 & 0x80000000) == 0)
                {
                  a1[6] = v23;
                  return 1;
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLCDMAMakeMEIDFromString", (uint64_t)"MEID length is %zu, expected %u\n", a3, a4, a5, a6, a7, a8, v9);
  }
  return 0;
}

uint64_t ETLCDMAMakeStringFromMEID(unsigned char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    BOOL v8 = a3 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  uint64_t v10 = !v8 && a2 > 0xE;
  if (v10 == 1)
  {
    TelephonyUtilEncodeHex();
    *a1 = -86;
    a1[1] = -86;
    TelephonyUtilEncodeHex();
    a1[2] = -86;
    a1[3] = -86;
    TelephonyUtilEncodeHex();
    a1[4] = -86;
    a1[5] = -86;
    TelephonyUtilEncodeHex();
    a1[6] = -86;
    a1[7] = -86;
    TelephonyUtilEncodeHex();
    a1[8] = -86;
    a1[9] = -86;
    TelephonyUtilEncodeHex();
    a1[10] = -86;
    a1[11] = -86;
    TelephonyUtilEncodeHex();
    a1[12] = -86;
    a1[13] = -86;
    a1[14] = 0;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLCDMAMakeStringFromMEID", (uint64_t)"buffer capacity is %u, need %u\n", a3, a4, a5, a6, a7, a8, a2);
  }
  return v10;
}

uint64_t ETLCDMAMakeStringFromMEIDRegular(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (a1) {
    BOOL v3 = a3 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  uint64_t v5 = !v3 && a2 > 0xE;
  if (v5 == 1) {
    TelephonyUtilBinToHex();
  }
  return v5;
}

uint64_t ETLCDMAGetMEID(uint64_t (**a1)(void, void *, uint64_t, _OWORD *, uint64_t, uint64_t, void), _DWORD *a2, uint64_t a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  int v5 = -1431655766;
  unsigned int v6 = -1431655766;
  memset(v7, 0, sizeof(v7));
  uint64_t result = (uint64_t)ETLNVRead(a1, 1943, v7, 128, &v6, &v5, a3);
  if (result)
  {
    if (v5 != 5 && v5 || v6 < 7)
    {
      return 0;
    }
    else
    {
      *a2 = v7[0];
      *(_DWORD *)((char *)a2 + 3) = *(_DWORD *)((char *)v7 + 3);
      return 1;
    }
  }
  return result;
}

BOOL ETLCDMAIsValidMEID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  memset(__s2, 170, 15);
  ETLCDMAMakeStringFromMEID(__s2, 15, a1, a4, a5, a6, a7, a8);
  return strncmp((const char *)kDefaultMEID, __s2, 0xEuLL) != 0;
}

uint64_t ETLCDMASetMEID(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, uint64_t a3)
{
  return ETLNVWriteWithStatus(a1, 1943, a2, 7u, &v4, a3);
}

uint64_t APPLIB_API_MAV_DeAssertResetDetect(void *a1, unsigned int a2)
{
  return APPLIB_API_SUBSYS_SendCommand(a1, a2, 253, 7, 0, 0);
}

uint64_t APPLIB_API_MAV_PowerDown(void *a1, unsigned int a2)
{
  return APPLIB_API_SUBSYS_SendCommand(a1, a2, 253, 9, 0, 0);
}

uint64_t APPLIB_API_MAV_SetCoreDumpMode(void *a1, unsigned int a2, __int16 a3)
{
  __int16 v4 = a3;
  return APPLIB_API_SUBSYS_SendCommand(a1, a2, 253, 10, (uint64_t)&v4, 2);
}

uint64_t APPLIB_API_MAV_SendFuseCommand(void *a1, unsigned int a2, __int16 a3, __int16 a4, int *a5, int a6)
{
  if (a6 != 4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = v6;
  uint64_t v12 = v7;
  v9[0] = a4;
  v9[1] = a3;
  int v10 = *a5;
  return APPLIB_API_SUBSYS_SendCommand(a1, a2, 253, 11, (uint64_t)v9, 8);
}

uint64_t APPLIB_API_MAV_ParseFuseResponse(uint64_t a1, unsigned int a2, _WORD *a3, _DWORD *a4)
{
  if (a2 < 4) {
    return 0;
  }
  uint64_t result = 0;
  if (*(unsigned char *)a1 == 75 && *(unsigned __int8 *)(a1 + 1) == 253)
  {
    if (*(_WORD *)(a1 + 2) == 11)
    {
      *a3 = *(_WORD *)(a1 + 4);
      *a4 = *(_DWORD *)(a1 + 6);
      return 1;
    }
    return 0;
  }
  return result;
}

uint64_t APPLIB_API_MAV_SendAPWakeCommand(void *a1, unsigned int a2, __int16 a3)
{
  __int16 v4 = a3;
  return APPLIB_API_SUBSYS_SendCommand(a1, a2, 253, 13, (uint64_t)&v4, 2);
}

uint64_t APPLIB_API_MAV_ParseAPWakeResponse(uint64_t a1, unsigned int a2, uint64_t a3, _WORD *a4)
{
  *a4 = -1;
  if (a2 < 4) {
    return 0;
  }
  uint64_t result = 0;
  if (*(unsigned char *)a1 == 75 && *(unsigned __int8 *)(a1 + 1) == 253)
  {
    if (*(_WORD *)(a1 + 2) == 13)
    {
      *a4 = *(_WORD *)(a1 + 6);
      return 1;
    }
    return 0;
  }
  return result;
}

uint64_t APPLIB_DIAG_CreateFile(char *a1, int a2, const void *a3, int a4)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a4 <= 32 && a4 + 7 <= a2)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 523851;
    memcpy(a1 + 4, a3, a4);
    unsigned __int16 v9 = crc_16_l_table[a1[4] ^ 0xA4];
    unsigned __int16 v10 = crc_16_l_table[(a1[5] ^ v9) ^ 4];
    unsigned __int16 v11 = crc_16_l_table[(a1[6] ^ v10 ^ HIBYTE(v9))];
    unsigned __int16 v12 = crc_16_l_table[(a1[7] ^ v11 ^ HIBYTE(v10))];
    unsigned __int16 v13 = crc_16_l_table[(a1[8] ^ v12 ^ HIBYTE(v11))];
    unsigned __int16 v14 = crc_16_l_table[(a1[9] ^ v13 ^ HIBYTE(v12))];
    unsigned __int16 v15 = crc_16_l_table[(a1[10] ^ v14 ^ HIBYTE(v13))];
    unsigned __int16 v16 = crc_16_l_table[(a1[11] ^ v15 ^ HIBYTE(v14))];
    unsigned __int16 v17 = crc_16_l_table[(a1[12] ^ v16 ^ HIBYTE(v15))];
    unsigned __int16 v18 = crc_16_l_table[(a1[13] ^ v17 ^ HIBYTE(v16))];
    unsigned __int16 v19 = crc_16_l_table[(a1[14] ^ v18 ^ HIBYTE(v17))];
    unsigned __int16 v20 = crc_16_l_table[(a1[15] ^ v19 ^ HIBYTE(v18))];
    unsigned __int16 v21 = crc_16_l_table[(a1[16] ^ v20 ^ HIBYTE(v19))];
    unsigned __int16 v22 = crc_16_l_table[(a1[17] ^ v21 ^ HIBYTE(v20))];
    unsigned __int16 v23 = crc_16_l_table[(a1[18] ^ v22 ^ HIBYTE(v21))];
    unsigned __int16 v24 = crc_16_l_table[(a1[19] ^ v23 ^ HIBYTE(v22))];
    unsigned __int16 v25 = crc_16_l_table[(a1[20] ^ v24 ^ HIBYTE(v23))];
    unsigned __int16 v26 = crc_16_l_table[(a1[21] ^ v25 ^ HIBYTE(v24))];
    unsigned __int16 v27 = crc_16_l_table[(a1[22] ^ v26 ^ HIBYTE(v25))];
    unsigned __int16 v28 = crc_16_l_table[(a1[23] ^ v27 ^ HIBYTE(v26))];
    unsigned __int16 v29 = crc_16_l_table[(a1[24] ^ v28 ^ HIBYTE(v27))];
    unsigned __int16 v30 = crc_16_l_table[(a1[25] ^ v29 ^ HIBYTE(v28))];
    unsigned __int16 v31 = crc_16_l_table[(a1[26] ^ v30 ^ HIBYTE(v29))];
    unsigned __int16 v32 = crc_16_l_table[(a1[27] ^ v31 ^ HIBYTE(v30))];
    unsigned __int16 v33 = crc_16_l_table[(a1[28] ^ v32 ^ HIBYTE(v31))];
    unsigned __int16 v34 = crc_16_l_table[(a1[29] ^ v33 ^ HIBYTE(v32))];
    unsigned __int16 v35 = crc_16_l_table[(a1[30] ^ v34 ^ HIBYTE(v33))];
    unsigned __int16 v36 = crc_16_l_table[(a1[31] ^ v35 ^ HIBYTE(v34))];
    unsigned __int16 v37 = crc_16_l_table[(a1[32] ^ v36 ^ HIBYTE(v35))];
    unsigned __int16 v38 = crc_16_l_table[(a1[33] ^ v37 ^ HIBYTE(v36))];
    unsigned int v39 = crc_16_l_table[(a1[34] ^ v38 ^ HIBYTE(v37))];
    *((_WORD *)a1 + 18) = crc_16_l_table[(a1[35] ^ v39 ^ HIBYTE(v38))] ^ ~(unsigned __int16)(v39 >> 8);
    if (a2 >= 76)
    {
      bzero(__src, 0x800uLL);
      uint64_t v40 = 0;
      LODWORD(v41) = 0;
      do
      {
        while (1)
        {
          int v43 = a1[v40];
          if ((v43 - 125) > 1) {
            break;
          }
          int v42 = v41 + 1;
          __src[(int)v41] = 125;
          __src[(int)v41 + 1] = v43 ^ 0x20;
          size_t v41 = (int)v41 + 1 + 1;
          if (++v40 == 38) {
            goto LABEL_10;
          }
        }
        int v42 = v41;
        __src[(int)v41] = v43;
        size_t v41 = (int)v41 + 1;
        ++v40;
      }
      while (v40 != 38);
LABEL_10:
      memcpy(a1, __src, v41);
      uint64_t result = (v42 + 2);
      a1[v41] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_GetFileInfo(char *a1, int a2, const void *a3, int a4)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a4 <= 32 && a4 + 7 <= a2)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 785995;
    memcpy(a1 + 4, a3, a4);
    unsigned __int16 v9 = crc_16_l_table[a1[4] ^ 4];
    unsigned __int16 v10 = crc_16_l_table[a1[5] ^ 0xAD ^ v9];
    unsigned __int16 v11 = crc_16_l_table[(a1[6] ^ v10 ^ HIBYTE(v9))];
    unsigned __int16 v12 = crc_16_l_table[(a1[7] ^ v11 ^ HIBYTE(v10))];
    unsigned __int16 v13 = crc_16_l_table[(a1[8] ^ v12 ^ HIBYTE(v11))];
    unsigned __int16 v14 = crc_16_l_table[(a1[9] ^ v13 ^ HIBYTE(v12))];
    unsigned __int16 v15 = crc_16_l_table[(a1[10] ^ v14 ^ HIBYTE(v13))];
    unsigned __int16 v16 = crc_16_l_table[(a1[11] ^ v15 ^ HIBYTE(v14))];
    unsigned __int16 v17 = crc_16_l_table[(a1[12] ^ v16 ^ HIBYTE(v15))];
    unsigned __int16 v18 = crc_16_l_table[(a1[13] ^ v17 ^ HIBYTE(v16))];
    unsigned __int16 v19 = crc_16_l_table[(a1[14] ^ v18 ^ HIBYTE(v17))];
    unsigned __int16 v20 = crc_16_l_table[(a1[15] ^ v19 ^ HIBYTE(v18))];
    unsigned __int16 v21 = crc_16_l_table[(a1[16] ^ v20 ^ HIBYTE(v19))];
    unsigned __int16 v22 = crc_16_l_table[(a1[17] ^ v21 ^ HIBYTE(v20))];
    unsigned __int16 v23 = crc_16_l_table[(a1[18] ^ v22 ^ HIBYTE(v21))];
    unsigned __int16 v24 = crc_16_l_table[(a1[19] ^ v23 ^ HIBYTE(v22))];
    unsigned __int16 v25 = crc_16_l_table[(a1[20] ^ v24 ^ HIBYTE(v23))];
    unsigned __int16 v26 = crc_16_l_table[(a1[21] ^ v25 ^ HIBYTE(v24))];
    unsigned __int16 v27 = crc_16_l_table[(a1[22] ^ v26 ^ HIBYTE(v25))];
    unsigned __int16 v28 = crc_16_l_table[(a1[23] ^ v27 ^ HIBYTE(v26))];
    unsigned __int16 v29 = crc_16_l_table[(a1[24] ^ v28 ^ HIBYTE(v27))];
    unsigned __int16 v30 = crc_16_l_table[(a1[25] ^ v29 ^ HIBYTE(v28))];
    unsigned __int16 v31 = crc_16_l_table[(a1[26] ^ v30 ^ HIBYTE(v29))];
    unsigned __int16 v32 = crc_16_l_table[(a1[27] ^ v31 ^ HIBYTE(v30))];
    unsigned __int16 v33 = crc_16_l_table[(a1[28] ^ v32 ^ HIBYTE(v31))];
    unsigned __int16 v34 = crc_16_l_table[(a1[29] ^ v33 ^ HIBYTE(v32))];
    unsigned __int16 v35 = crc_16_l_table[(a1[30] ^ v34 ^ HIBYTE(v33))];
    unsigned __int16 v36 = crc_16_l_table[(a1[31] ^ v35 ^ HIBYTE(v34))];
    unsigned __int16 v37 = crc_16_l_table[(a1[32] ^ v36 ^ HIBYTE(v35))];
    unsigned __int16 v38 = crc_16_l_table[(a1[33] ^ v37 ^ HIBYTE(v36))];
    unsigned int v39 = crc_16_l_table[(a1[34] ^ v38 ^ HIBYTE(v37))];
    *((_WORD *)a1 + 18) = crc_16_l_table[(a1[35] ^ v39 ^ HIBYTE(v38))] ^ ~(unsigned __int16)(v39 >> 8);
    if (a2 >= 76)
    {
      bzero(__src, 0x800uLL);
      uint64_t v40 = 0;
      LODWORD(v41) = 0;
      do
      {
        while (1)
        {
          int v43 = a1[v40];
          if ((v43 - 125) > 1) {
            break;
          }
          int v42 = v41 + 1;
          __src[(int)v41] = 125;
          __src[(int)v41 + 1] = v43 ^ 0x20;
          size_t v41 = (int)v41 + 1 + 1;
          if (++v40 == 38) {
            goto LABEL_10;
          }
        }
        int v42 = v41;
        __src[(int)v41] = v43;
        size_t v41 = (int)v41 + 1;
        ++v40;
      }
      while (v40 != 38);
LABEL_10:
      memcpy(a1, __src, v41);
      uint64_t result = (v42 + 2);
      a1[v41] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_DeleteFile(char *a1, int a2, const void *a3, int a4)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a4 <= 32 && a4 + 7 <= a2)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 589387;
    memcpy(a1 + 4, a3, a4);
    unsigned __int16 v9 = crc_16_l_table[a1[4] ^ 0x6CLL];
    unsigned __int16 v10 = crc_16_l_table[(a1[5] ^ v9) ^ 0x87];
    unsigned __int16 v11 = crc_16_l_table[(a1[6] ^ v10 ^ HIBYTE(v9))];
    unsigned __int16 v12 = crc_16_l_table[(a1[7] ^ v11 ^ HIBYTE(v10))];
    unsigned __int16 v13 = crc_16_l_table[(a1[8] ^ v12 ^ HIBYTE(v11))];
    unsigned __int16 v14 = crc_16_l_table[(a1[9] ^ v13 ^ HIBYTE(v12))];
    unsigned __int16 v15 = crc_16_l_table[(a1[10] ^ v14 ^ HIBYTE(v13))];
    unsigned __int16 v16 = crc_16_l_table[(a1[11] ^ v15 ^ HIBYTE(v14))];
    unsigned __int16 v17 = crc_16_l_table[(a1[12] ^ v16 ^ HIBYTE(v15))];
    unsigned __int16 v18 = crc_16_l_table[(a1[13] ^ v17 ^ HIBYTE(v16))];
    unsigned __int16 v19 = crc_16_l_table[(a1[14] ^ v18 ^ HIBYTE(v17))];
    unsigned __int16 v20 = crc_16_l_table[(a1[15] ^ v19 ^ HIBYTE(v18))];
    unsigned __int16 v21 = crc_16_l_table[(a1[16] ^ v20 ^ HIBYTE(v19))];
    unsigned __int16 v22 = crc_16_l_table[(a1[17] ^ v21 ^ HIBYTE(v20))];
    unsigned __int16 v23 = crc_16_l_table[(a1[18] ^ v22 ^ HIBYTE(v21))];
    unsigned __int16 v24 = crc_16_l_table[(a1[19] ^ v23 ^ HIBYTE(v22))];
    unsigned __int16 v25 = crc_16_l_table[(a1[20] ^ v24 ^ HIBYTE(v23))];
    unsigned __int16 v26 = crc_16_l_table[(a1[21] ^ v25 ^ HIBYTE(v24))];
    unsigned __int16 v27 = crc_16_l_table[(a1[22] ^ v26 ^ HIBYTE(v25))];
    unsigned __int16 v28 = crc_16_l_table[(a1[23] ^ v27 ^ HIBYTE(v26))];
    unsigned __int16 v29 = crc_16_l_table[(a1[24] ^ v28 ^ HIBYTE(v27))];
    unsigned __int16 v30 = crc_16_l_table[(a1[25] ^ v29 ^ HIBYTE(v28))];
    unsigned __int16 v31 = crc_16_l_table[(a1[26] ^ v30 ^ HIBYTE(v29))];
    unsigned __int16 v32 = crc_16_l_table[(a1[27] ^ v31 ^ HIBYTE(v30))];
    unsigned __int16 v33 = crc_16_l_table[(a1[28] ^ v32 ^ HIBYTE(v31))];
    unsigned __int16 v34 = crc_16_l_table[(a1[29] ^ v33 ^ HIBYTE(v32))];
    unsigned __int16 v35 = crc_16_l_table[(a1[30] ^ v34 ^ HIBYTE(v33))];
    unsigned __int16 v36 = crc_16_l_table[(a1[31] ^ v35 ^ HIBYTE(v34))];
    unsigned __int16 v37 = crc_16_l_table[(a1[32] ^ v36 ^ HIBYTE(v35))];
    unsigned __int16 v38 = crc_16_l_table[(a1[33] ^ v37 ^ HIBYTE(v36))];
    unsigned int v39 = crc_16_l_table[(a1[34] ^ v38 ^ HIBYTE(v37))];
    *((_WORD *)a1 + 18) = crc_16_l_table[(a1[35] ^ v39 ^ HIBYTE(v38))] ^ ~(unsigned __int16)(v39 >> 8);
    if (a2 >= 76)
    {
      bzero(__src, 0x800uLL);
      uint64_t v40 = 0;
      LODWORD(v41) = 0;
      do
      {
        while (1)
        {
          int v43 = a1[v40];
          if ((v43 - 125) > 1) {
            break;
          }
          int v42 = v41 + 1;
          __src[(int)v41] = 125;
          __src[(int)v41 + 1] = v43 ^ 0x20;
          size_t v41 = (int)v41 + 1 + 1;
          if (++v40 == 38) {
            goto LABEL_10;
          }
        }
        int v42 = v41;
        __src[(int)v41] = v43;
        size_t v41 = (int)v41 + 1;
        ++v40;
      }
      while (v40 != 38);
LABEL_10:
      memcpy(a1, __src, v41);
      uint64_t result = (v42 + 2);
      a1[v41] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_WriteFile(char *a1, int a2, const void *a3, int a4, int a5, _OWORD *a6)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a4 <= 32 && a4 + 135 <= a2)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 720459;
    *((_DWORD *)a1 + 1) = a5;
    memcpy(a1 + 8, a3, a4);
    long long v13 = a6[2];
    long long v14 = a6[3];
    long long v15 = a6[1];
    *(_OWORD *)(a1 + 40) = *a6;
    *(_OWORD *)(a1 + 88) = v14;
    *(_OWORD *)(a1 + 72) = v13;
    *(_OWORD *)(a1 + 56) = v15;
    long long v16 = a6[6];
    long long v17 = a6[7];
    long long v18 = a6[5];
    *(_OWORD *)(a1 + 104) = a6[4];
    *(_OWORD *)(a1 + 152) = v17;
    *(_OWORD *)(a1 + 136) = v16;
    *(_OWORD *)(a1 + 120) = v18;
    int v19 = 1344;
    LOWORD(v20) = -1;
    unsigned __int16 v21 = a1;
    do
    {
      char v22 = *v21++;
      int v20 = crc_16_l_table[(v22 ^ v20)] ^ ((unsigned __int16)(v20 & 0xFF00) >> 8);
      v19 -= 8;
    }
    while ((_WORD)v19);
    *((_WORD *)a1 + 84) = ~(_WORD)v20;
    if (a2 >= 340)
    {
      bzero(__src, 0x800uLL);
      uint64_t v23 = 0;
      LODWORD(v24) = 0;
      do
      {
        while (1)
        {
          int v26 = a1[v23];
          if ((v26 - 125) > 1) {
            break;
          }
          int v25 = v24 + 1;
          __src[(int)v24] = 125;
          __src[(int)v24 + 1] = v26 ^ 0x20;
          size_t v24 = (int)v24 + 1 + 1;
          if (++v23 == 170) {
            goto LABEL_12;
          }
        }
        int v25 = v24;
        __src[(int)v24] = v26;
        size_t v24 = (int)v24 + 1;
        ++v23;
      }
      while (v23 != 170);
LABEL_12:
      memcpy(a1, __src, v24);
      uint64_t result = (v25 + 2);
      a1[v24] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_ReadFile(char *a1, int a2, const void *a3, int a4, int a5)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a4 <= 32 && a4 + 135 <= a2)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 654923;
    *((_DWORD *)a1 + 1) = a5;
    memcpy(a1 + 8, a3, a4);
    unsigned __int16 v11 = crc_16_l_table[a5 ^ 0xB4];
    unsigned __int16 v12 = crc_16_l_table[(v11 ^ BYTE1(a5)) ^ 0x9E];
    unsigned __int16 v13 = crc_16_l_table[(v12 ^ HIBYTE(v11) ^ BYTE2(a5))];
    unsigned __int16 v14 = crc_16_l_table[(a1[7] ^ v13 ^ HIBYTE(v12))];
    unsigned __int16 v15 = crc_16_l_table[(a1[8] ^ v14 ^ HIBYTE(v13))];
    unsigned __int16 v16 = crc_16_l_table[(a1[9] ^ v15 ^ HIBYTE(v14))];
    unsigned __int16 v17 = crc_16_l_table[(a1[10] ^ v16 ^ HIBYTE(v15))];
    unsigned __int16 v18 = crc_16_l_table[(a1[11] ^ v17 ^ HIBYTE(v16))];
    unsigned __int16 v19 = crc_16_l_table[(a1[12] ^ v18 ^ HIBYTE(v17))];
    unsigned __int16 v20 = crc_16_l_table[(a1[13] ^ v19 ^ HIBYTE(v18))];
    unsigned __int16 v21 = crc_16_l_table[(a1[14] ^ v20 ^ HIBYTE(v19))];
    unsigned __int16 v22 = crc_16_l_table[(a1[15] ^ v21 ^ HIBYTE(v20))];
    unsigned __int16 v23 = crc_16_l_table[(a1[16] ^ v22 ^ HIBYTE(v21))];
    unsigned __int16 v24 = crc_16_l_table[(a1[17] ^ v23 ^ HIBYTE(v22))];
    unsigned __int16 v25 = crc_16_l_table[(a1[18] ^ v24 ^ HIBYTE(v23))];
    unsigned __int16 v26 = crc_16_l_table[(a1[19] ^ v25 ^ HIBYTE(v24))];
    unsigned __int16 v27 = crc_16_l_table[(a1[20] ^ v26 ^ HIBYTE(v25))];
    unsigned __int16 v28 = crc_16_l_table[(a1[21] ^ v27 ^ HIBYTE(v26))];
    unsigned __int16 v29 = crc_16_l_table[(a1[22] ^ v28 ^ HIBYTE(v27))];
    unsigned __int16 v30 = crc_16_l_table[(a1[23] ^ v29 ^ HIBYTE(v28))];
    unsigned __int16 v31 = crc_16_l_table[(a1[24] ^ v30 ^ HIBYTE(v29))];
    unsigned __int16 v32 = crc_16_l_table[(a1[25] ^ v31 ^ HIBYTE(v30))];
    unsigned __int16 v33 = crc_16_l_table[(a1[26] ^ v32 ^ HIBYTE(v31))];
    unsigned __int16 v34 = crc_16_l_table[(a1[27] ^ v33 ^ HIBYTE(v32))];
    unsigned __int16 v35 = crc_16_l_table[(a1[28] ^ v34 ^ HIBYTE(v33))];
    unsigned __int16 v36 = crc_16_l_table[(a1[29] ^ v35 ^ HIBYTE(v34))];
    unsigned __int16 v37 = crc_16_l_table[(a1[30] ^ v36 ^ HIBYTE(v35))];
    unsigned __int16 v38 = crc_16_l_table[(a1[31] ^ v37 ^ HIBYTE(v36))];
    unsigned __int16 v39 = crc_16_l_table[(a1[32] ^ v38 ^ HIBYTE(v37))];
    unsigned __int16 v40 = crc_16_l_table[(a1[33] ^ v39 ^ HIBYTE(v38))];
    unsigned __int16 v41 = crc_16_l_table[(a1[34] ^ v40 ^ HIBYTE(v39))];
    unsigned __int16 v42 = crc_16_l_table[(a1[35] ^ v41 ^ HIBYTE(v40))];
    unsigned __int16 v43 = crc_16_l_table[(a1[36] ^ v42 ^ HIBYTE(v41))];
    unsigned __int16 v44 = crc_16_l_table[(a1[37] ^ v43 ^ HIBYTE(v42))];
    unsigned int v45 = crc_16_l_table[(a1[38] ^ v44 ^ HIBYTE(v43))];
    *((_WORD *)a1 + 20) = crc_16_l_table[(a1[39] ^ v45 ^ HIBYTE(v44))] ^ ~(unsigned __int16)(v45 >> 8);
    if (a2 >= 84)
    {
      bzero(__src, 0x800uLL);
      uint64_t v46 = 0;
      LODWORD(v47) = 0;
      do
      {
        while (1)
        {
          int v49 = a1[v46];
          if ((v49 - 125) > 1) {
            break;
          }
          int v48 = v47 + 1;
          __src[(int)v47] = 125;
          __src[(int)v47 + 1] = v49 ^ 0x20;
          size_t v47 = (int)v47 + 1 + 1;
          if (++v46 == 42) {
            goto LABEL_10;
          }
        }
        int v48 = v47;
        __src[(int)v47] = v49;
        size_t v47 = (int)v47 + 1;
        ++v46;
      }
      while (v46 != 42);
LABEL_10:
      memcpy(a1, __src, v47);
      uint64_t result = (v48 + 2);
      a1[v47] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_ReadICCID_EFS_File(void *a1, int a2)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if (a2 < 512) {
    return 0xFFFFFFFFLL;
  }
  size_t v3 = a2;
  bzero(a1, a2);
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  bzero(a1, v3);
  *(_OWORD *)(a1 + 1) = *(_OWORD *)"sim.txt";
  *a1 = 654923;
  *(_OWORD *)(a1 + 3) = unk_1E458FEC0;
  unsigned __int16 v4 = crc_16_l_table[*((unsigned char *)a1 + 8) ^ 0x6A ^ LOBYTE(crc_16_l_table[110])];
  unsigned __int16 v5 = crc_16_l_table[(*((unsigned char *)a1 + 9) ^ v4 ^ HIBYTE(crc_16_l_table[110]))];
  unsigned __int16 v6 = crc_16_l_table[(*((unsigned char *)a1 + 10) ^ v5 ^ HIBYTE(v4))];
  unsigned __int16 v7 = crc_16_l_table[(*((unsigned char *)a1 + 11) ^ v6 ^ HIBYTE(v5))];
  unsigned __int16 v8 = crc_16_l_table[(*((unsigned char *)a1 + 12) ^ v7 ^ HIBYTE(v6))];
  unsigned __int16 v9 = crc_16_l_table[(*((unsigned char *)a1 + 13) ^ v8 ^ HIBYTE(v7))];
  unsigned __int16 v10 = crc_16_l_table[(*((unsigned char *)a1 + 14) ^ v9 ^ HIBYTE(v8))];
  unsigned __int16 v11 = crc_16_l_table[(*((unsigned char *)a1 + 15) ^ v10 ^ HIBYTE(v9))];
  unsigned __int16 v12 = crc_16_l_table[(*((unsigned char *)a1 + 16) ^ v11 ^ HIBYTE(v10))];
  unsigned __int16 v13 = crc_16_l_table[(*((unsigned char *)a1 + 17) ^ v12 ^ HIBYTE(v11))];
  unsigned __int16 v14 = crc_16_l_table[(*((unsigned char *)a1 + 18) ^ v13 ^ HIBYTE(v12))];
  unsigned __int16 v15 = crc_16_l_table[(*((unsigned char *)a1 + 19) ^ v14 ^ HIBYTE(v13))];
  unsigned __int16 v16 = crc_16_l_table[(*((unsigned char *)a1 + 20) ^ v15 ^ HIBYTE(v14))];
  unsigned __int16 v17 = crc_16_l_table[(*((unsigned char *)a1 + 21) ^ v16 ^ HIBYTE(v15))];
  unsigned __int16 v18 = crc_16_l_table[(*((unsigned char *)a1 + 22) ^ v17 ^ HIBYTE(v16))];
  unsigned __int16 v19 = crc_16_l_table[(*((unsigned char *)a1 + 23) ^ v18 ^ HIBYTE(v17))];
  unsigned __int16 v20 = crc_16_l_table[(*((unsigned char *)a1 + 24) ^ v19 ^ HIBYTE(v18))];
  unsigned __int16 v21 = crc_16_l_table[(*((unsigned char *)a1 + 25) ^ v20 ^ HIBYTE(v19))];
  unsigned __int16 v22 = crc_16_l_table[(*((unsigned char *)a1 + 26) ^ v21 ^ HIBYTE(v20))];
  unsigned __int16 v23 = crc_16_l_table[(*((unsigned char *)a1 + 27) ^ v22 ^ HIBYTE(v21))];
  unsigned __int16 v24 = crc_16_l_table[(*((unsigned char *)a1 + 28) ^ v23 ^ HIBYTE(v22))];
  unsigned __int16 v25 = crc_16_l_table[(*((unsigned char *)a1 + 29) ^ v24 ^ HIBYTE(v23))];
  unsigned __int16 v26 = crc_16_l_table[(*((unsigned char *)a1 + 30) ^ v25 ^ HIBYTE(v24))];
  unsigned __int16 v27 = crc_16_l_table[(*((unsigned char *)a1 + 31) ^ v26 ^ HIBYTE(v25))];
  unsigned __int16 v28 = crc_16_l_table[(*((unsigned char *)a1 + 32) ^ v27 ^ HIBYTE(v26))];
  unsigned __int16 v29 = crc_16_l_table[(*((unsigned char *)a1 + 33) ^ v28 ^ HIBYTE(v27))];
  unsigned __int16 v30 = crc_16_l_table[(*((unsigned char *)a1 + 34) ^ v29 ^ HIBYTE(v28))];
  unsigned __int16 v31 = crc_16_l_table[(*((unsigned char *)a1 + 35) ^ v30 ^ HIBYTE(v29))];
  unsigned __int16 v32 = crc_16_l_table[(*((unsigned char *)a1 + 36) ^ v31 ^ HIBYTE(v30))];
  unsigned __int16 v33 = crc_16_l_table[(*((unsigned char *)a1 + 37) ^ v32 ^ HIBYTE(v31))];
  unsigned int v34 = crc_16_l_table[(*((unsigned char *)a1 + 38) ^ v33 ^ HIBYTE(v32))];
  *((_WORD *)a1 + 20) = crc_16_l_table[(*((unsigned char *)a1 + 39) ^ v34 ^ HIBYTE(v33))] ^ ~(unsigned __int16)(v34 >> 8);
  bzero(__src, 0x800uLL);
  uint64_t v35 = 0;
  LODWORD(v3) = 0;
  do
  {
    while (1)
    {
      int v37 = *((unsigned __int8 *)a1 + v35);
      if ((v37 - 125) > 1) {
        break;
      }
      int v36 = v3 + 1;
      __src[(int)v3] = 125;
      __src[(int)v3 + 1] = v37 ^ 0x20;
      size_t v3 = (int)v3 + 1 + 1;
      if (++v35 == 42) {
        goto LABEL_7;
      }
    }
    int v36 = v3;
    __src[(int)v3] = v37;
    size_t v3 = (int)v3 + 1;
    ++v35;
  }
  while (v35 != 42);
LABEL_7:
  memcpy(a1, __src, v3);
  uint64_t result = (v36 + 2);
  *((unsigned char *)a1 + v3) = 126;
  return result;
}

uint64_t ETLMaverickAddSecurityCommandHeader()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickParseSecurityResponseHeader(uint64_t a1, int a2, _WORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = ETLMaverickParseBSPResponseHeader(a1, a4, 12, (uint64_t)a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v19 = *a4;
    if ((*(_DWORD *)(a1 + 8) - v19) <= 3)
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", v13, v14, v15, v16, v17, v18, 4);
    }
    else
    {
      uint64_t v20 = (unsigned __int16 *)(*(void *)a1 + v19);
      if (*v20 == a2)
      {
        *a3 = v20[1];
        *a4 = v19 + 4;
        return 1;
      }
      _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", v13, v14, v15, v16, v17, v18, *v20);
    }
    return 0;
  }
  return result;
}

uint64_t ETLMaverickSecurityCreateCheckCalibrationBackupCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickSecurityParseCheckCalibrationBackupResponse(int **a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  unsigned int v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 253)
      {
        uint64_t v12 = HIWORD(v11);
        if (v12 == 12)
        {
          if (v9 <= 3)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
            return 0;
          }
          else
          {
            uint64_t v13 = *((unsigned __int16 *)v10 + 2);
            if (v13 == 13)
            {
              *a2 = *((_WORD *)v10 + 3);
              return 1;
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, v13);
              return 0;
            }
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateNVBackupCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickParseNVBackupResponse(int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  unsigned int v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 253)
      {
        uint64_t v12 = HIWORD(v11);
        if (v12 == 12)
        {
          if (v9 <= 3)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
            return 0;
          }
          else
          {
            uint64_t v13 = *((unsigned __int16 *)v10 + 2);
            if (v13 == 7)
            {
              if (*((_WORD *)v10 + 3))
              {
                _ETLDebugPrint((uint64_t)"ETLMaverickParseNVBackupResponse", (uint64_t)"Status was %u\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v10 + 3));
                return 0;
              }
              else
              {
                return 1;
              }
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, v13);
              return 0;
            }
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickCreateNVRestoreCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickParseNVRestoreResponse(int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  unsigned int v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 253)
      {
        uint64_t v12 = HIWORD(v11);
        if (v12 == 12)
        {
          if (v9 <= 3)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
            return 0;
          }
          else
          {
            uint64_t v13 = *((unsigned __int16 *)v10 + 2);
            if (v13 == 8)
            {
              if (*((_WORD *)v10 + 3))
              {
                _ETLDebugPrint((uint64_t)"ETLMaverickExpectStatus", (uint64_t)"Status was %u\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v10 + 3));
                return 0;
              }
              else
              {
                return 1;
              }
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, v13);
              return 0;
            }
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickSecurityCreateReadSerialNumberAndChipIDCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickSecurityParseReadSerialNumberAndChipIDResponse(int **a1, _DWORD *a2, _DWORD *a3, uint64_t a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  uint64_t v9 = *a1;
  unsigned int v10 = **a1;
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, **a1);
    return 0;
  }
  if (BYTE1(v10) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, BYTE1(v10));
    return 0;
  }
  uint64_t v11 = HIWORD(v10);
  if (v11 != 12)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, v11);
    return 0;
  }
  if (v8 - 4 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, 4);
    return 0;
  }
  if (*((_WORD *)v9 + 2) != 3)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, *((unsigned __int16 *)v9 + 2));
    return 0;
  }
  if (*((_WORD *)v9 + 3))
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickExpectStatus", (uint64_t)"Status was %u\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, *((unsigned __int16 *)v9 + 3));
    return 0;
  }
  uint64_t v13 = v8 - 8;
  if (v13 <= 7)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickSecurityParseReadSerialNumberAndChipIDResponse", (uint64_t)"Only have %u bytes, need %u\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, v13);
  }
  else if (a4 >= 4)
  {
    *a2 = v9[2];
    *a3 = 32;
    *a5 = v9[3];
    return 1;
  }
  return 0;
}

uint64_t ETLMaverickSecurityCreateGetFusingStatusCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickSecurityParseGetFusingStatusResponse(int **a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    uint64_t v9 = *a1;
    unsigned int v10 = **a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 253)
      {
        uint64_t v11 = HIWORD(v10);
        if (v11 == 12)
        {
          if (v8 - 4 <= 3)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
            return 0;
          }
          else if (*((_WORD *)v9 + 2) == 17)
          {
            if (*((_WORD *)v9 + 3))
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickExpectStatus", (uint64_t)"Status was %u\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v9 + 3));
              return 0;
            }
            else if ((v8 & 0xFFFFFFFC) == 8 || v9[2] != 4)
            {
              return 0;
            }
            else
            {
              *a2 = v9[3];
              return 1;
            }
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v9 + 2));
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickSecurityCreateReadPublicKeyHashCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickSecurityParseReadPublicKeyHashResponse(int **a1, void *__dst, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, (uint64_t)a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    uint64_t v9 = *a1;
    unsigned int v10 = **a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 253)
      {
        uint64_t v11 = HIWORD(v10);
        if (v11 == 12)
        {
          if (v8 - 4 <= 3)
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, (uint64_t)a4, a5, a6, a7, a8, 4);
            return 0;
          }
          else if (*((_WORD *)v9 + 2) == 16)
          {
            if (*((_WORD *)v9 + 3))
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickExpectStatus", (uint64_t)"Status was %u\n", a3, (uint64_t)a4, a5, a6, a7, a8, *((unsigned __int16 *)v9 + 3));
              return 0;
            }
            else
            {
              if ((v8 & 0xFFFFFFFC) == 8) {
                return 0;
              }
              size_t v13 = v9[2];
              *a4 = v13;
              if ((int)v13 - 1 >= a3)
              {
                return 0;
              }
              else
              {
                memcpy(__dst, v9 + 3, v13);
                return 1;
              }
            }
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, (uint64_t)a4, a5, a6, a7, a8, *((unsigned __int16 *)v9 + 2));
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, (uint64_t)a4, a5, a6, a7, a8, v11);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, (uint64_t)a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, (uint64_t)a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLMaverickSecurityCreateReadNonceCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickSecurityParseReadNonceResponse(_DWORD **a1, void *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  uint64_t v9 = (unsigned __int16 *)*a1;
  unsigned int v10 = **a1;
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, **a1);
    return 0;
  }
  if (BYTE1(v10) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v10));
    return 0;
  }
  uint64_t v11 = HIWORD(v10);
  if (v11 != 12)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v11);
    return 0;
  }
  if (v8 - 4 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, 4);
    return 0;
  }
  if (v9[2] != 2)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v9[2]);
    return 0;
  }
  if (v9[3])
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickExpectStatus", (uint64_t)"Status was %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v9[3]);
    return 0;
  }
  unsigned int v13 = a4;
  size_t v16 = v8 - 8;
  _ETLDebugPrint((uint64_t)"ETLMaverickSecurityParseReadNonceResponse", (uint64_t)"Nonce is %u bytes\n", (uint64_t)a3, a4, a5, a6, a7, a8, v16);
  if (v16 > v13) {
    return 0;
  }
  memcpy(a2, v9 + 4, v16);
  *a3 = 8 * v16;
  return 1;
}

uint64_t ETLMaverickSecurityCreateReadManifestStatusCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickSecurityParseReadManifestStatusResponse(int **a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  uint64_t v10 = *a1;
  unsigned int v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
    return 0;
  }
  if (BYTE1(v11) != 253)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
    return 0;
  }
  uint64_t v12 = HIWORD(v11);
  if (v12 != 12)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
    return 0;
  }
  if (v8 - 4 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
    return 0;
  }
  uint64_t v13 = *((unsigned __int16 *)v10 + 2);
  if (v13 != 12)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, v13);
    return 0;
  }
  uint64_t v15 = *a2;
  uint64_t v16 = 2 * *a2 + 6;
  unint64_t v17 = v8 - 8;
  if (v16 - 2 > v17) {
    return 0;
  }
  if (v17 >= v16)
  {
    if (*((_WORD *)v10 + 3)) {
      return 0;
    }
    uint64_t v19 = 8;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickSecurityParseReadManifestStatusResponse", (uint64_t)"Manifest response size %u is small %u, ignoring status check\n", a3, a4, a5, a6, a7, a8, v17);
    uint64_t v10 = *a1;
    uint64_t v19 = 6;
  }
  size_t v20 = v15;
  unsigned __int16 v21 = (_WORD *)((char *)v10 + v19);
  *((_WORD *)a2 + 4) = *v21;
  *((_WORD *)a2 + 5) = v21[1];
  *((_WORD *)a2 + 6) = v21[2];
  unsigned __int16 v22 = v21 + 3;
  memcpy((void *)a2[2], v21 + 3, v20);
  memcpy((void *)a2[3], (char *)v22 + v20, v20);
  return 1;
}

uint64_t ETLMaverickSecurityCreateReadCarrierIDCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLMaverickSecurityParseReadCarrierIDResponse(int **a1, unsigned char *__dst, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && __dst)
  {
    unsigned int v9 = *((_DWORD *)a1 + 2);
    if (v9 < 4)
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    }
    else
    {
      uint64_t v10 = *a1;
      unsigned int v11 = **a1;
      if (v11 == 75)
      {
        if (BYTE1(v11) == 253)
        {
          uint64_t v12 = HIWORD(v11);
          if (v12 == 12)
          {
            if (v9 - 4 <= 3)
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
            }
            else if (*((_WORD *)v10 + 2) == 23)
            {
              if (*((_WORD *)v10 + 3) == 6)
              {
LABEL_25:
                uint64_t result = 1;
                __dst[7] = 0;
                return result;
              }
              if (!*((_WORD *)v10 + 3) && (v9 & 0xFFFFFFFC) != 8)
              {
                size_t v13 = v10[2];
                if (v13)
                {
                  if (v13 <= 7)
                  {
                    memcpy(__dst, v10 + 3, v13);
                    uint64_t result = 1;
                    __dst[7] = 1;
                    return result;
                  }
                  _ETLDebugPrint((uint64_t)"ETLMaverickSecurityParseReadCarrierIDResponse", (uint64_t)"received carrier id length %u larger than expected %u\n", v13, a4, a5, a6, a7, a8, v10[2]);
                  goto LABEL_24;
                }
                goto LABEL_25;
              }
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v10 + 2));
            }
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v11));
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
      }
    }
LABEL_24:
    uint64_t result = 0;
    __dst[7] = 0;
    return result;
  }
  uint64_t result = 0;
  if (__dst) {
    __dst[7] = 0;
  }
  return result;
}

uint64_t ETLMaverickNVBackup(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2)
{
  long long v36 = 0u;
  long long v37 = 0u;
  uint64_t v38 = 0;
  memset(v34, 0, sizeof(v34));
  uint64_t v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    unsigned __int16 v31 = "ETLMaverickNVBackup";
    unsigned __int16 v32 = "Failed to create uplink frame\n";
LABEL_22:
    _ETLDebugPrint((uint64_t)v31, (uint64_t)v32, v4, v5, v6, v7, v8, v9, v33);
    return 0;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    return 0;
  }
  int v39 = 851275;
  if ((HDLCFrameInject() & 1) == 0)
  {
    unsigned __int16 v31 = "ETLSubsysAddHeaderInternal";
    unsigned __int16 v32 = "Failed to inject\n";
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v33 = 2;
    unsigned __int16 v31 = "ETLRequireFreeSpace";
    unsigned __int16 v32 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_22;
  }
  uint64_t result = HDLCFrameInjectUnsignedShort();
  if (result)
  {
    uint64_t result = (uint64_t)malloc((2 * DWORD2(v36) + 32));
    if (result)
    {
      uint64_t v18 = (void *)result;
      uint64_t v19 = HDLCFrameEncode();
      if (!v19) {
        goto LABEL_25;
      }
      uint64_t v20 = v19;
      int v39 = -1431655766;
      if ((_ETLDebugFlags & 2) != 0) {
        ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v18, v19);
      }
      if (*a1)
      {
        int v21 = (*a1)(a1, v18, v20, &v39, 1, a2, 0);
        int v22 = v39;
        free(v18);
        uint64_t result = 0;
        if (v21 && v22 == v20)
        {
          LOBYTE(v39) = 75;
          if (!_ETLResponseRingBuffer) {
            TelephonyUtilRingBufferInitialize();
          }
          int v30 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a2);
          uint64_t result = 0;
          if (v30)
          {
            if (v39 == 75) {
              return ETLMaverickParseNVBackupResponse((int **)v34, v23, v24, v25, v26, v27, v28, v29);
            }
          }
        }
      }
      else
      {
LABEL_25:
        free(v18);
        return 0;
      }
    }
  }
  return result;
}

uint64_t ETLMaverickNVRestore(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2)
{
  long long v36 = 0u;
  long long v37 = 0u;
  uint64_t v38 = 0;
  memset(v34, 0, sizeof(v34));
  uint64_t v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    unsigned __int16 v31 = "ETLMaverickNVRestore";
    unsigned __int16 v32 = "Failed to create uplink frame\n";
LABEL_22:
    _ETLDebugPrint((uint64_t)v31, (uint64_t)v32, v4, v5, v6, v7, v8, v9, v33);
    return 0;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    return 0;
  }
  int v39 = 851275;
  if ((HDLCFrameInject() & 1) == 0)
  {
    unsigned __int16 v31 = "ETLSubsysAddHeaderInternal";
    unsigned __int16 v32 = "Failed to inject\n";
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v33 = 2;
    unsigned __int16 v31 = "ETLRequireFreeSpace";
    unsigned __int16 v32 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_22;
  }
  uint64_t result = HDLCFrameInjectUnsignedShort();
  if (result)
  {
    uint64_t result = (uint64_t)malloc((2 * DWORD2(v36) + 32));
    if (result)
    {
      uint64_t v18 = (void *)result;
      uint64_t v19 = HDLCFrameEncode();
      if (!v19) {
        goto LABEL_25;
      }
      uint64_t v20 = v19;
      int v39 = -1431655766;
      if ((_ETLDebugFlags & 2) != 0) {
        ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v18, v19);
      }
      if (*a1)
      {
        int v21 = (*a1)(a1, v18, v20, &v39, 1, a2, 0);
        int v22 = v39;
        free(v18);
        uint64_t result = 0;
        if (v21 && v22 == v20)
        {
          LOBYTE(v39) = 75;
          if (!_ETLResponseRingBuffer) {
            TelephonyUtilRingBufferInitialize();
          }
          int v30 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a2);
          uint64_t result = 0;
          if (v30)
          {
            if (v39 == 75) {
              return ETLMaverickParseNVRestoreResponse((int **)v34, v23, v24, v25, v26, v27, v28, v29);
            }
          }
        }
      }
      else
      {
LABEL_25:
        free(v18);
        return 0;
      }
    }
  }
  return result;
}

void *ETLMaverickReadSerialNumberAndChipID(void *a1, _DWORD *a2, _DWORD *a3, uint64_t a4, _DWORD *a5, uint64_t a6)
{
  long long v39 = 0u;
  long long v40 = 0u;
  uint64_t v41 = 0;
  memset(v37, 0, sizeof(v37));
  uint64_t v38 = 0;
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_22;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
    goto LABEL_22;
  }
  int v42 = 851275;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v33 = "ETLSubsysAddHeaderInternal";
    unsigned int v34 = "Failed to inject\n";
LABEL_21:
    _ETLDebugPrint((uint64_t)v33, (uint64_t)v34, v19, v20, v21, v22, v23, v24, v36);
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v36 = 2;
    uint64_t v33 = "ETLRequireFreeSpace";
    unsigned int v34 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_21;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_22:
    SerialNumberAndChipIDResponse = 0;
    goto LABEL_23;
  }
  SerialNumberAndChipIDResponse = malloc((2 * DWORD2(v39) + 32));
  if (!SerialNumberAndChipIDResponse) {
    goto LABEL_23;
  }
  uint64_t v26 = HDLCFrameEncode();
  if (!v26) {
    goto LABEL_24;
  }
  uint64_t v27 = v26;
  int v42 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, SerialNumberAndChipIDResponse, v26);
  }
  if (!*a1)
  {
LABEL_24:
    free(SerialNumberAndChipIDResponse);
    goto LABEL_22;
  }
  int v28 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, SerialNumberAndChipIDResponse, v27, &v42, 1, a6, 0);
  int v29 = v42;
  free(SerialNumberAndChipIDResponse);
  SerialNumberAndChipIDResponse = 0;
  if (v28 && v29 == v27)
  {
    LOBYTE(v42) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    SerialNumberAndChipIDResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v37, (uint64_t)&_ETLResponseRingBuffer, &v42, a6)&& v42 == 75)
    {
      SerialNumberAndChipIDResponse = (void *)ETLMaverickSecurityParseReadSerialNumberAndChipIDResponse((int **)v37, a2, a3, a4, a5, v30, v31, v32);
    }
  }
LABEL_23:
  HDLCFrameFree();
  HDLCFrameFree();
  return SerialNumberAndChipIDResponse;
}

void *ETLMaverickReadPublicKeyHash(void *a1, void *a2, uint64_t a3, _DWORD *a4, uint64_t a5)
{
  long long v38 = 0u;
  long long v39 = 0u;
  uint64_t v40 = 0;
  memset(v36, 0, sizeof(v36));
  uint64_t v37 = 0;
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_22;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_22;
  }
  int v41 = 851275;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v32 = "ETLSubsysAddHeaderInternal";
    uint64_t v33 = "Failed to inject\n";
LABEL_21:
    _ETLDebugPrint((uint64_t)v32, (uint64_t)v33, v17, v18, v19, v20, v21, v22, v35);
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v35 = 2;
    uint64_t v32 = "ETLRequireFreeSpace";
    uint64_t v33 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_21;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_22:
    PublicKeyHashResponse = 0;
    goto LABEL_23;
  }
  PublicKeyHashResponse = malloc((2 * DWORD2(v38) + 32));
  if (!PublicKeyHashResponse) {
    goto LABEL_23;
  }
  uint64_t v24 = HDLCFrameEncode();
  if (!v24) {
    goto LABEL_24;
  }
  uint64_t v25 = v24;
  int v41 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, PublicKeyHashResponse, v24);
  }
  if (!*a1)
  {
LABEL_24:
    free(PublicKeyHashResponse);
    goto LABEL_22;
  }
  int v26 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, PublicKeyHashResponse, v25, &v41, 1, a5, 0);
  int v27 = v41;
  free(PublicKeyHashResponse);
  PublicKeyHashResponse = 0;
  if (v26 && v27 == v25)
  {
    LOBYTE(v41) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    PublicKeyHashResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v36, (uint64_t)&_ETLResponseRingBuffer, &v41, a5)&& v41 == 75)
    {
      PublicKeyHashResponse = (void *)ETLMaverickSecurityParseReadPublicKeyHashResponse((int **)v36, a2, a3, a4, v28, v29, v30, v31);
    }
  }
LABEL_23:
  HDLCFrameFree();
  HDLCFrameFree();
  return PublicKeyHashResponse;
}

void *ETLMaverickGetFusingStatus(void *a1, _DWORD *a2, uint64_t a3)
{
  long long v36 = 0u;
  long long v37 = 0u;
  uint64_t v38 = 0;
  memset(v34, 0, sizeof(v34));
  uint64_t v35 = 0;
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_22;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v7, v8, v9, v10, v11, v12, FreeSpace);
    goto LABEL_22;
  }
  int v39 = 851275;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v30 = "ETLSubsysAddHeaderInternal";
    uint64_t v31 = "Failed to inject\n";
LABEL_21:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v13, v14, v15, v16, v17, v18, v33);
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v33 = 2;
    uint64_t v30 = "ETLRequireFreeSpace";
    uint64_t v31 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_21;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_22:
    FusingStatusResponse = 0;
    goto LABEL_23;
  }
  FusingStatusResponse = malloc((2 * DWORD2(v36) + 32));
  if (!FusingStatusResponse) {
    goto LABEL_23;
  }
  uint64_t v20 = HDLCFrameEncode();
  if (!v20) {
    goto LABEL_24;
  }
  uint64_t v21 = v20;
  int v39 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, FusingStatusResponse, v20);
  }
  if (!*a1)
  {
LABEL_24:
    free(FusingStatusResponse);
    goto LABEL_22;
  }
  int v22 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, FusingStatusResponse, v21, &v39, 1, a3, 0);
  int v23 = v39;
  free(FusingStatusResponse);
  FusingStatusResponse = 0;
  if (v22 && v23 == v21)
  {
    LOBYTE(v39) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    FusingStatusResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a3)&& v39 == 75)
    {
      FusingStatusResponse = (void *)ETLMaverickSecurityParseGetFusingStatusResponse((int **)v34, a2, v24, v25, v26, v27, v28, v29);
    }
  }
LABEL_23:
  HDLCFrameFree();
  HDLCFrameFree();
  return FusingStatusResponse;
}

void *ETLMaverickReadNonce(void *a1, void *a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  long long v38 = 0u;
  long long v39 = 0u;
  uint64_t v40 = 0;
  memset(v36, 0, sizeof(v36));
  uint64_t v37 = 0;
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_22;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_22;
  }
  int v41 = 851275;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v32 = "ETLSubsysAddHeaderInternal";
    uint64_t v33 = "Failed to inject\n";
LABEL_21:
    _ETLDebugPrint((uint64_t)v32, (uint64_t)v33, v17, v18, v19, v20, v21, v22, v35);
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v35 = 2;
    uint64_t v32 = "ETLRequireFreeSpace";
    uint64_t v33 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_21;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_22:
    NonceResponse = 0;
    goto LABEL_23;
  }
  NonceResponse = malloc((2 * DWORD2(v38) + 32));
  if (!NonceResponse) {
    goto LABEL_23;
  }
  uint64_t v24 = HDLCFrameEncode();
  if (!v24) {
    goto LABEL_24;
  }
  uint64_t v25 = v24;
  int v41 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, NonceResponse, v24);
  }
  if (!*a1)
  {
LABEL_24:
    free(NonceResponse);
    goto LABEL_22;
  }
  int v26 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, NonceResponse, v25, &v41, 1, a5, 0);
  int v27 = v41;
  free(NonceResponse);
  NonceResponse = 0;
  if (v26 && v27 == v25)
  {
    LOBYTE(v41) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    NonceResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v36, (uint64_t)&_ETLResponseRingBuffer, &v41, a5)&& v41 == 75)
    {
      NonceResponse = (void *)ETLMaverickSecurityParseReadNonceResponse((_DWORD **)v36, a2, a3, a4, v28, v29, v30, v31);
    }
  }
LABEL_23:
  HDLCFrameFree();
  HDLCFrameFree();
  return NonceResponse;
}

uint64_t ETLMaverickManifestStatusGetHashSize(capabilities::etl *a1)
{
  if (capabilities::etl::getMavSHAHashLenType(a1)) {
    return 48;
  }
  else {
    return 32;
  }
}

uint64_t ETLMaverickManifestStatusInit(size_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (capabilities::etl::getMavSHAHashLenType((capabilities::etl *)a1)) {
      size_t v9 = 48;
    }
    else {
      size_t v9 = 32;
    }
    *a1 = v9;
    a1[1] = 0;
    uint64_t v10 = malloc(v9);
    a1[3] = (size_t)v10;
    uint64_t v11 = malloc(v9);
    a1[2] = (size_t)v11;
    if (v10 && v11)
    {
      return 1;
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickManifestStatusInit", (uint64_t)"failed allocating data for ckey hash = %p and skey hash = %p\n", v12, v13, v14, v15, v16, v17, (uint64_t)v10);
      uint64_t v19 = (void *)a1[3];
      if (v19)
      {
        free(v19);
        a1[3] = 0;
      }
      uint64_t result = a1[2];
      if (result)
      {
        free((void *)result);
        uint64_t result = 0;
        a1[2] = 0;
      }
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickManifestStatusInit", (uint64_t)"invalid manifest status to initialize, manifest_status = %p\n", a3, a4, a5, a6, a7, a8, 0);
    return 0;
  }
  return result;
}

BOOL ETLMaverickManifestStatusFree(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    size_t v9 = *(void **)(a1 + 24);
    if (v9)
    {
      free(v9);
      *(void *)(a1 + 24) = 0;
    }
    uint64_t v10 = *(void **)(a1 + 16);
    if (v10)
    {
      free(v10);
      *(void *)(a1 + 16) = 0;
    }
    return a1 != 0;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickManifestStatusFree", (uint64_t)"invalid manifest status to initialize, manifest_status = %p\n", a3, a4, a5, a6, a7, a8, 0);
    return 0;
  }
}

void *ETLMaverickGetManifestStatus(void *a1, uint64_t *a2, uint64_t a3)
{
  long long v36 = 0u;
  long long v37 = 0u;
  uint64_t v38 = 0;
  memset(v34, 0, sizeof(v34));
  uint64_t v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v30 = "ETLMaverickGetManifestStatus";
    uint64_t v31 = "Failed to create command frame\n";
LABEL_22:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v6, v7, v8, v9, v10, v11, v33);
    goto LABEL_23;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
    goto LABEL_23;
  }
  int v39 = 851275;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v30 = "ETLSubsysAddHeaderInternal";
    uint64_t v31 = "Failed to inject\n";
    goto LABEL_22;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v33 = 2;
    uint64_t v30 = "ETLRequireFreeSpace";
    uint64_t v31 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_22;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_23:
    ManifestStatusResponse = 0;
    goto LABEL_24;
  }
  ManifestStatusResponse = malloc((2 * DWORD2(v36) + 32));
  if (!ManifestStatusResponse) {
    goto LABEL_24;
  }
  uint64_t v20 = HDLCFrameEncode();
  if (!v20) {
    goto LABEL_25;
  }
  uint64_t v21 = v20;
  int v39 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, ManifestStatusResponse, v20);
  }
  if (!*a1)
  {
LABEL_25:
    free(ManifestStatusResponse);
    goto LABEL_23;
  }
  int v22 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, ManifestStatusResponse, v21, &v39, 1, a3, 0);
  int v23 = v39;
  free(ManifestStatusResponse);
  ManifestStatusResponse = 0;
  if (v22 && v23 == v21)
  {
    LOBYTE(v39) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    ManifestStatusResponse = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v34, (uint64_t)&_ETLResponseRingBuffer, &v39, a3)&& v39 == 75)
    {
      ManifestStatusResponse = (void *)ETLMaverickSecurityParseReadManifestStatusResponse((int **)v34, a2, v24, v25, v26, v27, v28, v29);
    }
  }
LABEL_24:
  HDLCFrameFree();
  HDLCFrameFree();
  return ManifestStatusResponse;
}

uint64_t ETLMaverickGetCarrierID(void *a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v47 = 0u;
  long long v48 = 0u;
  uint64_t v49 = 0;
  memset(v45, 0, sizeof(v45));
  uint64_t v46 = 0;
  if (!a2)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickGetCarrierID", (uint64_t)"Invalid arguments\n", a3, a4, a5, a6, a7, a8, v44);
    goto LABEL_20;
  }
  a2[7] = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
LABEL_20:
    int v41 = "ETLMaverickGetCarrierID";
    int v42 = "Failed to create command frame\n";
LABEL_21:
    _ETLDebugPrint((uint64_t)v41, (uint64_t)v42, v11, v12, v13, v14, v15, v16, v44);
    goto LABEL_22;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
    goto LABEL_22;
  }
  int v50 = 851275;
  if ((HDLCFrameInject() & 1) == 0)
  {
    int v41 = "ETLSubsysAddHeaderInternal";
    int v42 = "Failed to inject\n";
    goto LABEL_21;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v24, v25, v26, v27, v28, v29, 2);
    goto LABEL_22;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
LABEL_22:
    uint64_t CarrierIDResponse = 0;
    goto LABEL_23;
  }
  uint64_t CarrierIDResponse = (uint64_t)malloc((2 * DWORD2(v47) + 32));
  if (!CarrierIDResponse) {
    goto LABEL_23;
  }
  uint64_t v31 = HDLCFrameEncode();
  if (!v31) {
    goto LABEL_27;
  }
  uint64_t v32 = v31;
  int v50 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, CarrierIDResponse, v31);
  }
  if (!*a1)
  {
LABEL_27:
    free((void *)CarrierIDResponse);
    goto LABEL_22;
  }
  int v33 = ((uint64_t (*)(void *, uint64_t, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, CarrierIDResponse, v32, &v50, 1, a3, 0);
  int v34 = v50;
  free((void *)CarrierIDResponse);
  uint64_t CarrierIDResponse = 0;
  if (v33 && v34 == v32)
  {
    LOBYTE(v50) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v45, (uint64_t)&_ETLResponseRingBuffer, &v50, a3)&& v50 == 75)
    {
      uint64_t CarrierIDResponse = ETLMaverickSecurityParseReadCarrierIDResponse((int **)v45, a2, v35, v36, v37, v38, v39, v40);
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLMaverickGetCarrierID", (uint64_t)"Command not implemented\n", v35, v36, v37, v38, v39, v40, v44);
      a2[7] = 0;
      uint64_t CarrierIDResponse = 1;
    }
  }
LABEL_23:
  HDLCFrameFree();
  HDLCFrameFree();
  return CarrierIDResponse;
}

uint64_t ETLMaverickCheckCalibrationBackup(void *a1, _WORD *a2, uint64_t a3)
{
  *a2 = -1;
  long long v42 = 0u;
  long long v43 = 0u;
  uint64_t v44 = 0;
  memset(v40, 0, sizeof(v40));
  uint64_t v41 = 0;
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_25;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v7, v8, v9, v10, v11, v12, FreeSpace);
    goto LABEL_25;
  }
  unsigned int v45 = 851275;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v36 = "ETLSubsysAddHeaderInternal";
    uint64_t v37 = "Failed to inject\n";
LABEL_24:
    _ETLDebugPrint((uint64_t)v36, (uint64_t)v37, v13, v14, v15, v16, v17, v18, v39);
    goto LABEL_25;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v39 = 2;
    uint64_t v36 = "ETLRequireFreeSpace";
    uint64_t v37 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_24;
  }
  if (!HDLCFrameInjectUnsignedShort()) {
    goto LABEL_25;
  }
  uint64_t v19 = (uint64_t)malloc((2 * DWORD2(v42) + 32));
  if (v19)
  {
    uint64_t v20 = HDLCFrameEncode();
    if (!v20) {
      goto LABEL_27;
    }
    uint64_t v21 = v20;
    unsigned int v45 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v19, v20);
    }
    if (!*a1)
    {
LABEL_27:
      free((void *)v19);
      goto LABEL_25;
    }
    int v22 = ((uint64_t (*)(void *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v19, v21, &v45, 1, a3, 0);
    unsigned int v23 = v45;
    free((void *)v19);
    uint64_t v19 = 0;
    if (v22)
    {
      if (v23 == v21)
      {
        LOBYTE(v45) = 75;
        if (!_ETLResponseRingBuffer) {
          TelephonyUtilRingBufferInitialize();
        }
        uint64_t v19 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v40, (uint64_t)&_ETLResponseRingBuffer, &v45, a3))
        {
          if (v45 == 75)
          {
            unsigned int v45 = 0;
            uint64_t v19 = 0;
            if (ETLMaverickParseBSPResponseHeader((uint64_t)v40, &v45, 12, v24, v25, v26, v27, v28))
            {
              if (DWORD2(v40[0]) - v45 <= 3)
              {
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", v29, v30, v31, v32, v33, v34, 4);
              }
              else
              {
                uint64_t v35 = *(unsigned __int16 *)(*(void *)&v40[0] + v45);
                if (v35 == 13)
                {
                  *a2 = *(_WORD *)(*(void *)&v40[0] + v45 + 2);
                  uint64_t v19 = 1;
                  goto LABEL_26;
                }
                _ETLDebugPrint((uint64_t)"ETLMaverickParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", v29, v30, v31, v32, v33, v34, v35);
              }
LABEL_25:
              uint64_t v19 = 0;
            }
          }
        }
      }
    }
  }
LABEL_26:
  HDLCFrameFree();
  HDLCFrameFree();
  return v19;
}

uint64_t ETLFTMRFCallResponse(unsigned int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((_DWORD *)a1 + 2) < 4u)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
  }
  else
  {
    unsigned int v10 = **a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 11)
      {
        uint64_t v11 = HIWORD(v10);
        if (v11 != 251) {
          _ETLDebugPrint((uint64_t)"ETLFTMRFCallResponse", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLFTMRFCallResponse", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
      }
      unsigned int v12 = 1;
      if ((*((_DWORD *)a1 + 2) - 4) <= 3) {
        goto LABEL_15;
      }
      goto LABEL_9;
    }
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
  }
  unsigned int v12 = 0;
  if (*((_DWORD *)a1 + 2) <= 3u)
  {
LABEL_15:
    _ETLDebugPrint((uint64_t)"ETLFTMRFCallResponse", (uint64_t)"response requires %u bytes, got %u\n", a3, a4, a5, a6, a7, a8, 4);
    return 0;
  }
LABEL_9:
  uint64_t v13 = &(*a1)[v12];
  if (*(unsigned __int16 *)v13 == a2)
  {
    if (*((_WORD *)v13 + 1) == 1)
    {
      return 1;
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLFTMRFCallResponse", (uint64_t)"Call got failed. The status returns %u\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v13 + 1));
      return 0;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLFTMRFCallResponse", (uint64_t)"Expect Maverick CMD code %u is not matched with gottne %u\n", a3, a4, a5, a6, a7, a8, a2);
    return 0;
  }
}

uint64_t ETLFTMRFCallSetup(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    _ETLDebugPrint((uint64_t)"ETLFTMRFCallSetup", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v43);
    return 0;
  }
  memset(v46, 0, sizeof(v46));
  uint64_t v47 = 0;
  memset(v44, 0, sizeof(v44));
  uint64_t v45 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v31 = "ETLFTMRFCallSetup";
    uint64_t v32 = "Failed to create command frame\n";
LABEL_20:
    _ETLDebugPrint((uint64_t)v31, (uint64_t)v32, v11, v12, v13, v14, v15, v16, v43);
    goto LABEL_21;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
    goto LABEL_21;
  }
  int v48 = 16452427;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v31 = "ETLSubsysAddHeaderInternal";
    uint64_t v32 = "Failed to inject\n";
    goto LABEL_20;
  }
  if (HDLCFrameGetFreeSpace() <= 0xB)
  {
    uint64_t v43 = 12;
LABEL_19:
    uint64_t v31 = "ETLFTMCreateRFCallSetup";
    uint64_t v32 = "Not enough room, need %u, have %u\n";
    goto LABEL_20;
  }
  if (!HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedShort())
  {
    goto LABEL_21;
  }
  if a2 < 7 && ((0x6Du >> a2))
  {
    uint64_t v34 = 4 * (int)a2;
    uint64_t v35 = *(unsigned int *)((char *)&unk_1E458FED0 + v34);
    uint64_t v36 = *(unsigned int *)((char *)&unk_1E458FEEC + v34);
    if (!HDLCFrameInjectUnsignedShort()) {
      goto LABEL_21;
    }
    if (HDLCFrameGetFreeSpace() >= v35)
    {
      switch(v36)
      {
        case 1:
          if (!HDLCFrameInjectUnsignedShort() || !HDLCFrameInjectUnsignedShort()) {
            goto LABEL_21;
          }
          uint64_t v33 = 0;
          if (HDLCFrameInjectUnsignedShort())
          {
            if (!HDLCFrameInjectUnsignedShort()
              || !HDLCFrameInjectUnsignedShort()
              || (HDLCFrameInjectUnsignedShort() & 1) == 0)
            {
              goto LABEL_21;
            }
            goto LABEL_38;
          }
          break;
        case 2:
          if ((HDLCFrameInjectUnsignedShort() & 1) == 0) {
            goto LABEL_21;
          }
          uint64_t v33 = 0;
          if (HDLCFrameInjectUnsignedShort()) {
            goto LABEL_38;
          }
          break;
        case 3:
          uint64_t v33 = 0;
          if (HDLCFrameInjectUnsignedShort()) {
            goto LABEL_38;
          }
          break;
        default:
LABEL_38:
          if (!ETLSendCommand(a1, (uint64_t)v46, a4)
            || !ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v44, a4))
          {
            goto LABEL_21;
          }
          uint64_t v33 = ETLFTMRFCallResponse((unsigned int **)v44, 82, v37, v38, v39, v40, v41, v42);
          break;
      }
      goto LABEL_22;
    }
    uint64_t v43 = v35;
    goto LABEL_19;
  }
  _ETLDebugPrint((uint64_t)"ETLFTMCreateRFCallSetup", (uint64_t)"The technology cannot be interpreted %u\n", v24, v25, v26, v27, v28, v29, a2);
LABEL_21:
  uint64_t v33 = 0;
LABEL_22:
  HDLCFrameFree();
  HDLCFrameFree();
  return v33;
}

uint64_t ETLFTMRFCallExit(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    _ETLDebugPrint((uint64_t)"ETLFTMRFCallExit", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v33);
    return 0;
  }
  memset(v36, 0, sizeof(v36));
  uint64_t v37 = 0;
  memset(v34, 0, sizeof(v34));
  uint64_t v35 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v31 = "ETLFTMRFCallExit";
    uint64_t v32 = "Failed to create command frame\n";
LABEL_16:
    _ETLDebugPrint((uint64_t)v31, (uint64_t)v32, v10, v11, v12, v13, v14, v15, v33);
    goto LABEL_17;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v17, v18, v19, v20, v21, v22, FreeSpace);
LABEL_17:
    uint64_t v29 = 0;
    goto LABEL_18;
  }
  int v38 = 16452427;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v31 = "ETLSubsysAddHeaderInternal";
    uint64_t v32 = "Failed to inject\n";
    goto LABEL_16;
  }
  if (HDLCFrameGetFreeSpace() <= 3)
  {
    uint64_t v33 = 4;
    uint64_t v31 = "ETLFTMCreateRFCallExit";
    uint64_t v32 = "Not enough room, need %u, have %u\n";
    goto LABEL_16;
  }
  if (!HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedShort()
    || !ETLSendCommand(a1, (uint64_t)v36, a3)
    || !ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v34, a3))
  {
    goto LABEL_17;
  }
  uint64_t v29 = ETLFTMRFCallResponse((unsigned int **)v34, 83, v23, v24, v25, v26, v27, v28);
LABEL_18:
  HDLCFrameFree();
  HDLCFrameFree();
  return v29;
}

uint64_t ETLFTMFEMCommonDispatchResponse(unsigned int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((_DWORD *)a1 + 2) < 4u)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
  }
  else
  {
    unsigned int v10 = **a1;
    if (v10 == 75)
    {
      if (HIWORD(v10) != 20 || BYTE1(v10) != 11) {
        _ETLDebugPrint((uint64_t)"ETLFTMFEMCommonDispatchResponse", (uint64_t)"Received subsys 0x%x command code 0x%x doesn't match expected subsys 0x%x command code 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
      }
      unsigned int v12 = 1;
      if ((*((_DWORD *)a1 + 2) - 4) <= 9) {
        goto LABEL_9;
      }
      goto LABEL_13;
    }
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
  }
  unsigned int v12 = 0;
  if (*((_DWORD *)a1 + 2) <= 9u)
  {
LABEL_9:
    _ETLDebugPrint((uint64_t)"ETLFTMFEMCommonDispatchResponse", (uint64_t)"response requires %u bytes, got %u\n", a3, a4, a5, a6, a7, a8, 10);
    return 0;
  }
LABEL_13:
  uint64_t v14 = (int *)&(*a1)[v12];
  if (*(_WORD *)v14 == 1005)
  {
    *(_WORD *)(a2 + 4) = *(_WORD *)((char *)v14 + 7);
    *(_DWORD *)a2 = *((unsigned __int8 *)v14 + 9);
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLFTMFEMCommonDispatchResponse", (uint64_t)"Expect Maverick CMD code %u is not matched with gottne %u\n", a3, a4, a5, a6, a7, a8, 1005);
    return 0;
  }
}

const char *ETLFTMRfcInitStatusAsString(unsigned int a1)
{
  if (a1 > 3) {
    return "Unknown";
  }
  else {
    return off_1E6E6FF10[a1];
  }
}

uint64_t ETLFTMGetFEMCommonInfo(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    _ETLDebugPrint((uint64_t)"ETLFTMGetFEMCommonInfo", (uint64_t)"Transport cannot be NULL\n", a3, a4, a5, a6, a7, a8, v34);
    return 0;
  }
  memset(v37, 0, sizeof(v37));
  uint64_t v38 = 0;
  memset(v35, 0, sizeof(v35));
  uint64_t v36 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v32 = "ETLFTMGetFEMCommonInfo";
    uint64_t v33 = "Failed to create command frame\n";
LABEL_19:
    _ETLDebugPrint((uint64_t)v32, (uint64_t)v33, v11, v12, v13, v14, v15, v16, v34);
    goto LABEL_20;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
LABEL_20:
    uint64_t v24 = 0;
    goto LABEL_21;
  }
  int v39 = 1313611;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v32 = "ETLSubsysAddHeaderInternal";
    uint64_t v33 = "Failed to inject\n";
    goto LABEL_19;
  }
  if (HDLCFrameGetFreeSpace() <= 7)
  {
    uint64_t v34 = 8;
    uint64_t v32 = "ETLFTMCreateFEMCommonDispatch";
    uint64_t v33 = "Not enough room, need %u, have %u\n";
    goto LABEL_19;
  }
  if (!HDLCFrameInjectUnsignedShort() || !HDLCFrameInjectUnsignedShort()) {
    goto LABEL_20;
  }
  uint64_t v24 = 0;
  if (!HDLCFrameInjectUnsignedShort()) {
    goto LABEL_21;
  }
  uint64_t v24 = 0;
  if (!HDLCFrameInjectUnsignedChar()) {
    goto LABEL_21;
  }
  uint64_t v24 = 0;
  if (!HDLCFrameInjectUnsignedChar()) {
    goto LABEL_21;
  }
  if (!ETLSendCommand(a1, (uint64_t)v37, a3)
    || !ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v35, a3))
  {
    goto LABEL_20;
  }
  uint64_t v24 = ETLFTMFEMCommonDispatchResponse((unsigned int **)v35, a2, v25, v26, v27, v28, v29, v30);
LABEL_21:
  HDLCFrameFree();
  HDLCFrameFree();
  return v24;
}

uint64_t ETLUCalTxCreateCommand(uint64_t a1, int a2)
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v4, v5, v6, v7, v8, v9, FreeSpace);
LABEL_10:
    _ETLDebugPrint((uint64_t)"ETLUCalTxCreateCommand", (uint64_t)"Failed to add command header\n", v24, v25, v26, v27, v28, v29, v32);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v10, v11, v12, v13, v14, v15, v31);
    goto LABEL_10;
  }
  uint64_t v16 = HDLCFrameGetFreeSpace();
  if (a2)
  {
    if (a2 != 1) {
      _ETLDebugPrint((uint64_t)"ETLUCalTxCreateCommand", (uint64_t)"Wrong to arrive here\n", v17, v18, v19, v20, v21, v22, v31);
    }
    return HDLCFrameInjectUnsignedShort() & 1;
  }
  if (v16 <= 9)
  {
    _ETLDebugPrint((uint64_t)"ETLUCalTxCreateCommand", (uint64_t)"Remaining %u not enough %u\n", v17, v18, v19, v20, v21, v22, v16);
    return 0;
  }
  int v30 = HDLCFrameInjectUnsignedShort();
  uint64_t result = 0;
  if (v30)
  {
    return HDLCFrameInject();
  }
  return result;
}

uint64_t ETLUCalTxParseResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a1[2];
  uint64_t v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    unsigned int v10 = **(_DWORD **)a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 253)
      {
        uint64_t v11 = HIWORD(v10);
        if (v11 == 26)
        {
          if (v9 <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLUCalTxParseResponseWithStatus", (uint64_t)"Payload length %u less than needed %u\n", a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else if (*(_WORD *)(*(void *)a1 + 4) == 1)
          {
            return 1;
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLUCalTxParseResponseWithStatus", (uint64_t)"Status returned was %u, expected %u\n", a3, a4, a5, a6, a7, a8, *(unsigned __int16 *)(*(void *)a1 + 4));
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

uint64_t ETLUCalTxOperation(void *a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  if (a5) {
    *a5 = 0;
  }
  uint64_t v40 = 0;
  memset(v39, 0, sizeof(v39));
  memset(v37, 0, sizeof(v37));
  uint64_t v38 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLUCalTxOperation", (uint64_t)"Faild to create uplink frame\n", v9, v10, v11, v12, v13, v14, v36);
    goto LABEL_26;
  }
  if (!ETLUCalTxCreateCommand((uint64_t)v39, a2))
  {
LABEL_26:
    uint64_t v15 = 0;
    goto LABEL_27;
  }
  uint64_t v15 = (uint64_t)malloc((2 * DWORD2(v39[0]) + 32));
  if (v15)
  {
    uint64_t v16 = HDLCFrameEncode();
    if (!v16) {
      goto LABEL_28;
    }
    uint64_t v17 = v16;
    int v41 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v15, v16);
    }
    if (!*a1)
    {
LABEL_28:
      free((void *)v15);
      goto LABEL_26;
    }
    int v18 = ((uint64_t (*)(void *, uint64_t, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v15, v17, &v41, 1, a4, 0);
    int v19 = v41;
    free((void *)v15);
    uint64_t v15 = 0;
    if (v18)
    {
      if (v19 == v17)
      {
        LOBYTE(v41) = 75;
        if (!_ETLResponseRingBuffer) {
          TelephonyUtilRingBufferInitialize();
        }
        uint64_t v15 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v37, (uint64_t)&_ETLResponseRingBuffer, &v41, a4))
        {
          if (v41 == 75)
          {
            _ETLDebugPrint((uint64_t)"ETLUCalTxOperation", (uint64_t)"Read done\n", v20, v21, v22, v23, v24, v25, v36);
            if (DWORD2(v37[0]) < 4)
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v26, v27, v28, v29, v30, v31, DWORD2(v37[0]));
            }
            else
            {
              unsigned int v32 = **(_DWORD **)&v37[0];
              if (**(_DWORD **)&v37[0] == 75)
              {
                if (BYTE1(v32) == 253)
                {
                  uint64_t v33 = HIWORD(v32);
                  if (v33 == 26)
                  {
                    if ((DWORD2(v37[0]) - 4) <= 1)
                    {
                      _ETLDebugPrint((uint64_t)"ETLUCalTxParseResponseWithStatus", (uint64_t)"Payload length %u less than needed %u\n", v26, v27, v28, v29, v30, v31, (DWORD2(v37[0]) - 4));
                    }
                    else
                    {
                      uint64_t v34 = *(unsigned __int16 *)(*(void *)&v37[0] + 4);
                      if (a5) {
                        *a5 = v34;
                      }
                      if (v34 == 1)
                      {
                        uint64_t v15 = 1;
                        goto LABEL_27;
                      }
                      _ETLDebugPrint((uint64_t)"ETLUCalTxParseResponseWithStatus", (uint64_t)"Status returned was %u, expected %u\n", v26, v27, v28, v29, v30, v31, v34);
                    }
                  }
                  else
                  {
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v26, v27, v28, v29, v30, v31, v33);
                  }
                }
                else
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v26, v27, v28, v29, v30, v31, BYTE1(v32));
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v26, v27, v28, v29, v30, v31, **(_DWORD **)&v37[0]);
              }
            }
            goto LABEL_26;
          }
        }
      }
    }
  }
LABEL_27:
  HDLCFrameFree();
  HDLCFrameFree();
  return v15;
}

uint64_t ETLUCalTxStart(void *a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  return ETLUCalTxOperation(a1, 0, a2, a3, a4);
}

uint64_t ETLUCalTxStop(void *a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  return ETLUCalTxOperation(a1, 1, a2, a3, a4);
}

uint64_t ETLGCalTxControl(void *a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  return ETLUCalTxOperation(a1, 5, a2, a3, a4);
}

uint64_t ETLCalGetSKU(uint64_t (**a1)(void, void *, uint64_t, _OWORD *, uint64_t, uint64_t, void), _DWORD *a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      int v8 = 4;
      unsigned int v9 = 0;
      memset(v10, 0, sizeof(v10));
      unsigned int v5 = ETLNVRead(a1, 50020, v10, 256, &v9, &v8, a3);
      uint64_t v3 = 0;
      if (v5)
      {
        if (v8) {
          BOOL v6 = v8 == 5;
        }
        else {
          BOOL v6 = 1;
        }
        uint64_t v3 = v6;
        if (v6 && v9 >= 3)
        {
          *a2 = LOWORD(v10[0]);
          return 1;
        }
      }
    }
  }
  return v3;
}

uint64_t ETLCalGetUmtsBand4Status(uint64_t (**a1)(void, uint64_t, uint64_t, int *, uint64_t, uint64_t, void), BOOL *a2, uint64_t a3)
{
  uint64_t v3 = 0;
  if (a1 && a2)
  {
    uint64_t v45 = 0;
    long long v43 = 0u;
    long long v44 = 0u;
    memset(v41, 0, sizeof(v41));
    uint64_t v42 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v14, v15, v16, v17, v18, v19, FreeSpace);
      }
      else
      {
        int v46 = 3472715;
        if (HDLCFrameInject())
        {
          uint64_t v3 = (uint64_t)malloc((2 * DWORD2(v43) + 32));
          if (!v3)
          {
LABEL_29:
            HDLCFrameFree();
            HDLCFrameFree();
            return v3;
          }
          uint64_t v26 = HDLCFrameEncode();
          if (!v26) {
            goto LABEL_31;
          }
          uint64_t v27 = v26;
          int v46 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v3, v26);
          }
          if (*a1)
          {
            int v28 = (*a1)(a1, v3, v27, &v46, 1, a3, 0);
            int v29 = v46;
            free((void *)v3);
            uint64_t v3 = 0;
            if (!v28 || v29 != v27) {
              goto LABEL_29;
            }
            LOBYTE(v46) = 75;
            if (!_ETLResponseRingBuffer) {
              TelephonyUtilRingBufferInitialize();
            }
            uint64_t v3 = 0;
            if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v41, (uint64_t)&_ETLResponseRingBuffer, &v46, a3)|| v46 != 75)
            {
              goto LABEL_29;
            }
            if (DWORD2(v41[0]) < 4)
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v30, v31, v32, v33, v34, v35, DWORD2(v41[0]));
            }
            else
            {
              unsigned int v36 = **(_DWORD **)&v41[0];
              if (**(_DWORD **)&v41[0] == 75)
              {
                if (BYTE1(v36) == 253)
                {
                  uint64_t v37 = HIWORD(v36);
                  if (v37 == 52)
                  {
                    if ((DWORD2(v41[0]) - 4) > 1)
                    {
                      *a2 = *(_WORD *)(*(void *)&v41[0] + 4) != 0;
                      uint64_t v3 = 1;
                      goto LABEL_29;
                    }
                    _ETLDebugPrint((uint64_t)"ETLCalGetUmtsBand4Status", (uint64_t)"Payload length %u less than needed %u\n", v30, v31, v32, v33, v34, v35, (DWORD2(v41[0]) - 4));
                  }
                  else
                  {
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v30, v31, v32, v33, v34, v35, v37);
                  }
                }
                else
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v30, v31, v32, v33, v34, v35, BYTE1(v36));
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v30, v31, v32, v33, v34, v35, **(_DWORD **)&v41[0]);
              }
            }
          }
          else
          {
LABEL_31:
            free((void *)v3);
          }
LABEL_28:
          uint64_t v3 = 0;
          goto LABEL_29;
        }
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v20, v21, v22, v23, v24, v25, v40);
      }
      uint64_t v38 = "Failed to add command header\n";
    }
    else
    {
      uint64_t v38 = "Failed to create uplink frame\n";
    }
    _ETLDebugPrint((uint64_t)"ETLCalGetUmtsBand4Status", (uint64_t)v38, v7, v8, v9, v10, v11, v12, v40);
    goto LABEL_28;
  }
  return v3;
}

BOOL ETLPM_GetVREGLevel(void *a1, char a2, int *a3, unsigned int a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  int v14 = -1431655766;
  __int16 v20 = -21846;
  memset(v21, 0, sizeof(v21));
  int v18 = 271435;
  char v19 = a2;
  unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v15 = v7;
  long long v16 = v7;
  if (!HDLCFrameCreateUplink()) {
    return 0;
  }
  HDLCFrameInject();
  uint64_t v8 = HDLCFrameEncode();
  if (!v8) {
    return 0;
  }
  uint64_t v9 = v8;
  if ((int)v8 < 1) {
    return 0;
  }
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(void *, void, _OWORD *, uint64_t))*(&gDelegate + 1))(&unk_1E4590583, 0, v21, v8);
  }
  if (!*a1) {
    return 0;
  }
  BOOL v10 = 0;
  if (!((unsigned int (*)(void *, _OWORD *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v21, v9, &v14, 1, 1000, 0)|| v14 != v9)
  {
    return v10;
  }
  unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v15 = v11;
  long long v16 = v11;
  LOBYTE(v18) = 75;
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)&v15, (uint64_t)&_ETLResponseRingBuffer, &v18, a4))return 0; {
  if (v18 == 75)
  }
  {
    BOOL v10 = (DWORD2(v15) - 4) < 0xFFFFFFFD;
    if ((DWORD2(v15) - 4) > 0xFFFFFFFC) {
      int v12 = 43690;
    }
    else {
      int v12 = *(unsigned __int16 *)(v15 + 5);
    }
    *a3 = v12;
  }
  else
  {
    BOOL v10 = 0;
  }
  HDLCFrameFree();
  return v10;
}

uint64_t ETLCMCreateGetModeCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLCMParseGetModeResponse(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)(a1 + 8);
  unsigned int v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a1 + 8));
    return 0;
  }
  uint64_t v10 = *(_OWORD **)a1;
  if (**(_DWORD **)a1 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
    return 0;
  }
  if ((**(_DWORD **)a1 & 0xFFFFFF00) != 0xF00) {
    return 0;
  }
  if (v9 <= 0x2B)
  {
    _ETLDebugPrint((uint64_t)"ETLCMParseGetModeResponse", (uint64_t)"Need %u bytes, only have %u\n", a3, a4, a5, a6, a7, a8, 44);
    return 0;
  }
  else
  {
    long long v11 = *(_OWORD *)((char *)v10 + 4);
    long long v12 = *(_OWORD *)((char *)v10 + 20);
    *(_OWORD *)((char *)a2 + 28) = v10[2];
    *a2 = v11;
    a2[1] = v12;
    return 1;
  }
}

uint64_t ETLCMGetMode(uint64_t (**a1)(void, uint64_t, uint64_t, int *, uint64_t, uint64_t, void), _OWORD *a2, uint64_t a3)
{
  if (a1)
  {
    long long v38 = 0u;
    long long v39 = 0u;
    uint64_t v40 = 0;
    memset(v36, 0, sizeof(v36));
    uint64_t v37 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
        goto LABEL_26;
      }
      int v41 = 3915;
      if (HDLCFrameInject())
      {
        uint64_t v19 = (uint64_t)malloc((2 * DWORD2(v38) + 32));
        if (!v19)
        {
LABEL_27:
          HDLCFrameFree();
          HDLCFrameFree();
          return v19;
        }
        uint64_t v20 = HDLCFrameEncode();
        if (!v20) {
          goto LABEL_29;
        }
        uint64_t v21 = v20;
        int v41 = -1431655766;
        if ((_ETLDebugFlags & 2) != 0) {
          ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v19, v20);
        }
        if (*a1)
        {
          int v22 = (*a1)(a1, v19, v21, &v41, 1, a3, 0);
          int v23 = v41;
          free((void *)v19);
          uint64_t v19 = 0;
          if (!v22 || v23 != v21) {
            goto LABEL_27;
          }
          LOBYTE(v41) = 75;
          if (!_ETLResponseRingBuffer) {
            TelephonyUtilRingBufferInitialize();
          }
          uint64_t v19 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v36, (uint64_t)&_ETLResponseRingBuffer, &v41, a3)|| v41 != 75)
          {
            goto LABEL_27;
          }
          if (DWORD2(v36[0]) < 4)
          {
            _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v24, v25, v26, v27, v28, v29, DWORD2(v36[0]));
          }
          else if (**(_DWORD **)&v36[0] == 75)
          {
            if ((**(_DWORD **)&v36[0] & 0xFFFFFF00) == 0xF00)
            {
              if ((DWORD2(v36[0]) - 4) > 0x2B)
              {
                long long v30 = *(_OWORD *)(*(void *)&v36[0] + 4);
                long long v31 = *(_OWORD *)(*(void *)&v36[0] + 20);
                *(_OWORD *)((char *)a2 + 28) = *(_OWORD *)(*(void *)&v36[0] + 32);
                *a2 = v30;
                a2[1] = v31;
                uint64_t v19 = 1;
                goto LABEL_27;
              }
              _ETLDebugPrint((uint64_t)"ETLCMParseGetModeResponse", (uint64_t)"Need %u bytes, only have %u\n", v24, v25, v26, v27, v28, v29, 44);
            }
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v24, v25, v26, v27, v28, v29, **(_DWORD **)&v36[0]);
          }
        }
        else
        {
LABEL_29:
          free((void *)v19);
        }
LABEL_26:
        uint64_t v19 = 0;
        goto LABEL_27;
      }
      uint64_t v32 = "ETLSubsysAddHeaderInternal";
      uint64_t v33 = "Failed to inject\n";
    }
    else
    {
      uint64_t v32 = "ETLCMGetMode";
      uint64_t v33 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v32, (uint64_t)v33, v6, v7, v8, v9, v10, v11, v35);
    goto LABEL_26;
  }
  return 0;
}

uint64_t ETLEVENTCreateSetMaskCommand(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a3;
  _ETLDebugPrint((uint64_t)"ETLEVENTCreateSetMaskCommand", (uint64_t)"Setting masks of %u bits\n", a3, a4, a5, a6, a7, a8, a3);
  if (v8 > 0x1000) {
    return 0;
  }
  unsigned int v9 = (v8 + 7) >> 3;
  if (HDLCFrameGetFreeSpace() < v9 + 7)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v10, v11, v12, v13, v14, v15, v9 + 7);
    return 0;
  }
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInjectUnsignedShort();
  HDLCFrameInject();

  return HDLCFrameInjectUnsignedChar();
}

uint64_t ETLEVENTParseSetMaskResponse(unsigned __int8 **a1, _DWORD *a2, void *__dst, unsigned int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  if (v8 <= 5)
  {
    _ETLDebugPrint((uint64_t)"ETLEVENTParseSetGetMaskResponseInternal", (uint64_t)"Response has %u bytes, need %u\n", (uint64_t)__dst, (uint64_t)a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    uint64_t v9 = (uint64_t)*a1;
    if (**a1 == 130)
    {
      int v10 = *(unsigned __int8 *)(v9 + 1);
      *a2 = v10;
      if (v10)
      {
        return 0;
      }
      else
      {
        unsigned int v12 = *(unsigned __int16 *)(v9 + 4);
        *a4 = v12;
        if (v12 > 0x1000 || (v12 + 7) >> 3 > v8 - 6)
        {
          _ETLDebugPrint((uint64_t)"ETLEVENTParseSetGetMaskResponseInternal", (uint64_t)"Need %u bytes for mask of %u bits, only have %u\n", (uint64_t)__dst, (uint64_t)a4, a5, a6, a7, a8, (v12 + 7) >> 3);
          return 0;
        }
        else
        {
          memcpy(__dst, (const void *)(v9 + 6), (v12 + 7) >> 3);
          return 1;
        }
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLExpectResponseCode", (uint64_t)"Received response code is %u, expected %u\n", (uint64_t)__dst, (uint64_t)a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLEVENTCreateGetMaskCommand()
{
  if (HDLCFrameGetFreeSpace() <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v0, v1, v2, v3, v4, v5, 4);
    return 0;
  }
  else
  {
    HDLCFrameInjectUnsignedChar();
    HDLCFrameInjectUnsignedChar();
    return HDLCFrameInjectUnsignedShort();
  }
}

uint64_t ETLEVENTParseGetMaskResponse(unsigned __int8 **a1, _DWORD *a2, void *__dst, unsigned int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  if (v8 <= 5)
  {
    _ETLDebugPrint((uint64_t)"ETLEVENTParseSetGetMaskResponseInternal", (uint64_t)"Response has %u bytes, need %u\n", (uint64_t)__dst, (uint64_t)a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    uint64_t v9 = (uint64_t)*a1;
    if (**a1 == 129)
    {
      int v10 = *(unsigned __int8 *)(v9 + 1);
      *a2 = v10;
      if (v10)
      {
        return 0;
      }
      else
      {
        unsigned int v12 = *(unsigned __int16 *)(v9 + 4);
        *a4 = v12;
        if (v12 > 0x1000 || (v12 + 7) >> 3 > v8 - 6)
        {
          _ETLDebugPrint((uint64_t)"ETLEVENTParseSetGetMaskResponseInternal", (uint64_t)"Need %u bytes for mask of %u bits, only have %u\n", (uint64_t)__dst, (uint64_t)a4, a5, a6, a7, a8, (v12 + 7) >> 3);
          return 0;
        }
        else
        {
          memcpy(__dst, (const void *)(v9 + 6), (v12 + 7) >> 3);
          return 1;
        }
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLExpectResponseCode", (uint64_t)"Received response code is %u, expected %u\n", (uint64_t)__dst, (uint64_t)a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLEVENTCreateEnableCommand()
{
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v0, v1, v2, v3, v4, v5, 2);
    return 0;
  }
  else
  {
    HDLCFrameInjectUnsignedChar();
    return HDLCFrameInjectUnsignedChar();
  }
}

uint64_t ETLEVENTParseEnableResponse()
{
  return 1;
}

unint64_t ETLEVENTSetMask(void *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  char v30 = -126;
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __s2[30] = v8;
  __s2[31] = v8;
  __s2[28] = v8;
  __s2[29] = v8;
  __s2[26] = v8;
  __s2[27] = v8;
  __s2[24] = v8;
  __s2[25] = v8;
  __s2[22] = v8;
  __s2[23] = v8;
  __s2[20] = v8;
  __s2[21] = v8;
  __s2[18] = v8;
  __s2[19] = v8;
  char __s2[16] = v8;
  __s2[17] = v8;
  __s2[14] = v8;
  __s2[15] = v8;
  __s2[12] = v8;
  __s2[13] = v8;
  __s2[10] = v8;
  __s2[11] = v8;
  __s2[8] = v8;
  __s2[9] = v8;
  __s2[6] = v8;
  __s2[7] = v8;
  __s2[4] = v8;
  __s2[5] = v8;
  __s2[2] = v8;
  __s2[3] = v8;
  __s2[0] = v8;
  __s2[1] = v8;
  uint64_t v34 = 0;
  memset(v33, 0, sizeof(v33));
  memset(v31, 0, sizeof(v31));
  uint64_t v32 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLEVENTSetMask", (uint64_t)"Failed to create command frame\n", v9, v10, v11, v12, v13, v14, v29);
    goto LABEL_25;
  }
  if (!ETLEVENTCreateSetMaskCommand((uint64_t)v33, (uint64_t)a2, a3, v10, v11, v12, v13, v14))
  {
LABEL_25:
    unint64_t v15 = 0;
    goto LABEL_26;
  }
  unint64_t v15 = (unint64_t)malloc((2 * DWORD2(v33[0]) + 32));
  if (!v15) {
    goto LABEL_26;
  }
  uint64_t v16 = HDLCFrameEncode();
  if (!v16) {
    goto LABEL_27;
  }
  uint64_t v17 = v16;
  int v35 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, unint64_t, uint64_t))*(&gDelegate + 1))("", 0, v15, v16);
  }
  if (!*a1)
  {
LABEL_27:
    free((void *)v15);
    goto LABEL_25;
  }
  int v18 = ((uint64_t (*)(void *, unint64_t, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v15, v17, &v35, 1, a4, 0);
  int v19 = v35;
  free((void *)v15);
  unint64_t v15 = 0;
  if (v18 && v19 == v17)
  {
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v31, (uint64_t)&_ETLResponseRingBuffer, &v30, a4))
    {
      if (DWORD2(v31[0]) <= 5)
      {
        _ETLDebugPrint((uint64_t)"ETLEVENTParseSetGetMaskResponseInternal", (uint64_t)"Response has %u bytes, need %u\n", v20, v21, v22, v23, v24, v25, DWORD2(v31[0]));
      }
      else if (**(unsigned char **)&v31[0] == 130)
      {
        if (!*(unsigned char *)(*(void *)&v31[0] + 1))
        {
          LODWORD(v26) = *(unsigned __int16 *)(*(void *)&v31[0] + 4);
          uint64_t v27 = (v26 + 7) >> 3;
          if (v26 > 0x1000 || v27 > DWORD2(v31[0]) - 6)
          {
            _ETLDebugPrint((uint64_t)"ETLEVENTParseSetGetMaskResponseInternal", (uint64_t)"Need %u bytes for mask of %u bits, only have %u\n", v27, v21, v22, v23, v24, v25, (v26 + 7) >> 3);
          }
          else
          {
            __memcpy_chk();
            if (v26 >= a3) {
              unint64_t v26 = a3;
            }
            else {
              unint64_t v26 = v26;
            }
            if (!memcmp(a2, __s2, v26 >> 3))
            {
              unint64_t v15 = (v26 & 7) == 0
                 || ((*((unsigned __int8 *)__s2 + (v26 >> 3)) ^ a2[v26 >> 3]) & ~(-1 << (v26 & 7))) == 0;
              goto LABEL_26;
            }
          }
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLExpectResponseCode", (uint64_t)"Received response code is %u, expected %u\n", v20, v21, v22, v23, v24, v25, **(unsigned char **)&v31[0]);
      }
    }
    goto LABEL_25;
  }
LABEL_26:
  HDLCFrameFree();
  HDLCFrameFree();
  return v15;
}

uint64_t ETLEVENTGetMask(void *a1, void *a2, unsigned int *a3, uint64_t a4)
{
  char v34 = -127;
  long long v37 = 0u;
  long long v38 = 0u;
  uint64_t v39 = 0;
  memset(v35, 0, sizeof(v35));
  uint64_t v36 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    char v30 = "ETLEVENTGetMask";
    long long v31 = "Failed to create command frame\n";
LABEL_22:
    _ETLDebugPrint((uint64_t)v30, (uint64_t)v31, v8, v9, v10, v11, v12, v13, v33);
    goto LABEL_23;
  }
  if (HDLCFrameGetFreeSpace() <= 3)
  {
    uint64_t v33 = 4;
    char v30 = "ETLRequireFreeSpace";
    long long v31 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_22;
  }
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  uint64_t v14 = 0;
  if (HDLCFrameInjectUnsignedShort())
  {
    uint64_t v14 = (uint64_t)malloc((2 * DWORD2(v37) + 32));
    if (v14)
    {
      uint64_t v15 = HDLCFrameEncode();
      if (!v15) {
        goto LABEL_25;
      }
      uint64_t v16 = v15;
      int v40 = -1431655766;
      if ((_ETLDebugFlags & 2) != 0) {
        ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v14, v15);
      }
      if (!*a1)
      {
LABEL_25:
        free((void *)v14);
        goto LABEL_23;
      }
      int v17 = ((uint64_t (*)(void *, uint64_t, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v14, v16, &v40, 1, a4, 0);
      int v18 = v40;
      free((void *)v14);
      uint64_t v14 = 0;
      if (v17)
      {
        if (v18 == v16)
        {
          if (!_ETLResponseRingBuffer) {
            TelephonyUtilRingBufferInitialize();
          }
          if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v35, (uint64_t)&_ETLResponseRingBuffer, &v34, a4))
          {
            int v25 = DWORD2(v35[0]);
            if (DWORD2(v35[0]) <= 5)
            {
              _ETLDebugPrint((uint64_t)"ETLEVENTParseSetGetMaskResponseInternal", (uint64_t)"Response has %u bytes, need %u\n", v19, v20, v21, v22, v23, v24, DWORD2(v35[0]));
            }
            else
            {
              uint64_t v26 = *(void *)&v35[0];
              if (**(unsigned char **)&v35[0] == 129)
              {
                if (!*(unsigned char *)(*(void *)&v35[0] + 1))
                {
                  unsigned int v27 = *(unsigned __int16 *)(*(void *)&v35[0] + 4);
                  *a3 = v27;
                  unsigned int v28 = v25 - 6;
                  size_t v29 = (v27 + 7) >> 3;
                  if (v27 <= 0x1000 && v29 <= v28)
                  {
                    memcpy(a2, (const void *)(v26 + 6), v29);
                    uint64_t v14 = 1;
                    goto LABEL_24;
                  }
                  _ETLDebugPrint((uint64_t)"ETLEVENTParseSetGetMaskResponseInternal", (uint64_t)"Need %u bytes for mask of %u bits, only have %u\n", v29, v20, v21, v22, v23, v24, (v27 + 7) >> 3);
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLExpectResponseCode", (uint64_t)"Received response code is %u, expected %u\n", v19, v20, v21, v22, v23, v24, **(unsigned char **)&v35[0]);
              }
            }
          }
LABEL_23:
          uint64_t v14 = 0;
        }
      }
    }
  }
LABEL_24:
  HDLCFrameFree();
  HDLCFrameFree();
  return v14;
}

void *ETLEVENTEnable(void *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v25 = 96;
  _ETLDebugPrint((uint64_t)"ETLEVENTEnable", (uint64_t)"enable = %u\n", a3, a4, a5, a6, a7, a8, a2);
  uint64_t v30 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  memset(v26, 0, sizeof(v26));
  uint64_t v27 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v21 = "ETLEVENTEnable";
    uint64_t v22 = "Failed to create command frame\n";
LABEL_16:
    _ETLDebugPrint((uint64_t)v21, (uint64_t)v22, v10, v11, v12, v13, v14, v15, v24);
    goto LABEL_17;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v24 = 2;
    uint64_t v21 = "ETLRequireFreeSpace";
    uint64_t v22 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_16;
  }
  HDLCFrameInjectUnsignedChar();
  if (!HDLCFrameInjectUnsignedChar())
  {
LABEL_17:
    uint64_t v16 = 0;
    goto LABEL_18;
  }
  uint64_t v16 = malloc((2 * DWORD2(v28) + 32));
  if (!v16) {
    goto LABEL_18;
  }
  uint64_t v17 = HDLCFrameEncode();
  if (!v17) {
    goto LABEL_19;
  }
  uint64_t v18 = v17;
  int v31 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
  }
  if (!*a1)
  {
LABEL_19:
    free(v16);
    goto LABEL_17;
  }
  int v19 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v16, v18, &v31, 1, a3, 0);
  int v20 = v31;
  free(v16);
  uint64_t v16 = 0;
  if (v19 && v20 == v18)
  {
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    uint64_t v16 = (void *)ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v26, (uint64_t)&_ETLResponseRingBuffer, &v25, a3);
  }
LABEL_18:
  HDLCFrameFree();
  HDLCFrameFree();
  return v16;
}

uint64_t ETLEVENTGetRangeSize(unsigned __int16 *a1)
{
  return a1[1] - *a1 + 1;
}

uint64_t ETLEVENTProcessEvent(char *__str, size_t __size, unsigned int *a3, char *a4, unsigned int a5, _DWORD *a6)
{
  uint64_t result = 0;
  *a3 = 0;
  *a6 = 0;
  unsigned int v8 = a5 - 2;
  if (a5 < 2) {
    return result;
  }
  unsigned int v10 = __size;
  int v11 = *a4;
  unsigned int v12 = a4[1];
  *a6 = 2;
  uint64_t v13 = a4 + 2;
  if ((v12 & 0x80000000) == 0)
  {
    if (v8 >= 8)
    {
      uint64_t v14 = *v13 >> 8;
      uint64_t v15 = *v13 >> 16;
      unint64_t v16 = *v13 & 0xFFFFFFFFFF000000;
      int v17 = *v13;
      unsigned int v18 = 8;
      goto LABEL_7;
    }
LABEL_26:
    uint64_t result = 0;
    *a6 = 0;
    return result;
  }
  if (v8 < 2) {
    goto LABEL_26;
  }
  int v17 = 0;
  unint64_t v16 = 0;
  LOBYTE(v14) = a4[2];
  LOBYTE(v15) = a4[3];
  unsigned int v18 = 2;
LABEL_7:
  unsigned int v19 = v11 & 0xFFFFF0FF | ((v12 & 0xF) << 8);
  uint64_t v20 = (v12 >> 5) & 3;
  unsigned int v21 = v8 - v18;
  unsigned int v22 = v18 + 2;
  *a6 = v18 + 2;
  switch(v20)
  {
    case 1:
      goto LABEL_9;
    case 2:
      LODWORD(v20) = 2;
LABEL_9:
      if (v21 < v20) {
        goto LABEL_10;
      }
      goto LABEL_14;
    case 3:
      if (!v21) {
        goto LABEL_26;
      }
      unsigned int v23 = *((unsigned __int8 *)v13 + v18);
      unsigned int v22 = v18 + 3;
      *a6 = v18 + 3;
      LODWORD(v20) = v23;
      if (v21 - 1 >= v23) {
        goto LABEL_14;
      }
LABEL_10:
      uint64_t result = 0;
      break;
    default:
LABEL_14:
      *a6 = v20 + v22;
      unint64_t v24 = ((v16 | ((unint64_t)v15 << 16)) >> 14)
          + ((v16 | ((unint64_t)v15 << 16)) >> 16)
          + ((unsigned __int16)(((43685 * (v17 & 0xFFFF00FF | (v14 << 8))) >> 16)
                                            + ((unsigned __int16)(((v17 | (v14 << 8))
                                                                 - ((43685
                                                                   * (v17 & 0xFFFF00FF | (v14 << 8))) >> 16)) & 0xFFFE) >> 1)) >> 13)
          + 2;
      unint64_t v25 = v24 >> 2;
      unint64_t v26 = ((v24 * (unsigned __int128)0x10624DD2F1A9FCuLL) >> 64) + 315964800;
      unsigned int v27 = snprintf(__str, v10, "[%02u:%02u:%02u:%06u] EVENT 0x%04x ", ((v26 * (unsigned __int128)0x123456789ABCE0uLL) >> 64) % 0x18, v26 / 0x3C - 60 * ((unint64_t)((v26 / 0x3C * (unsigned __int128)0x888888888888889uLL) >> 64) >> 1), v26 % 0x3C, 1000 * (v25 - 1000 * ((v25 * (unsigned __int128)0x4189374BC6A7F0uLL) >> 64)), v19);
      if (v27 >= v10) {
        unsigned int v28 = v10;
      }
      else {
        unsigned int v28 = v27;
      }
      *a3 = v28;
      if (v27 < v10)
      {
        if (v10 >= v27) {
          unsigned int v29 = v10 - v27;
        }
        else {
          unsigned int v29 = 0;
        }
        unsigned int v30 = TelephonyUtilBinToHex();
        if (v30 >= v29) {
          unsigned int v31 = v29;
        }
        else {
          unsigned int v31 = v30;
        }
        *a3 += v31;
      }
      uint64_t result = 1;
      break;
  }
  return result;
}

uint64_t ETLEVENTProcessEventItem(unsigned __int8 *a1, unsigned int a2, _DWORD *a3, _WORD *a4, unsigned char *a5, uint64_t a6)
{
  return ETLEVENTProcessEventItemTSLength(a1, a2, a3, a4, a5, a6, 0);
}

uint64_t ETLEVENTProcessEventItemTSLength(unsigned __int8 *a1, unsigned int a2, _DWORD *a3, _WORD *a4, unsigned char *a5, uint64_t a6, unsigned int *a7)
{
  uint64_t v7 = 0;
  *a3 = 0;
  unsigned int v8 = a2 - 2;
  if (a2 < 2) {
    return v7;
  }
  unsigned int v9 = a1[1];
  *a4 = (*a1 | (unsigned __int16)((_WORD)v9 << 8)) & 0xFFF;
  if (a7)
  {
    *a7 = v9 >> 7;
    *a3 += 2;
    unsigned int v10 = a1 + 2;
    if ((v9 & 0x80) == 0) {
      goto LABEL_4;
    }
  }
  else
  {
    *a3 = 2;
    unsigned int v10 = a1 + 2;
    if ((v9 & 0x80) == 0)
    {
LABEL_4:
      if (v8 >= 8)
      {
        *(void *)a6 = *v10;
        unsigned int v11 = 8;
        goto LABEL_10;
      }
      goto LABEL_8;
    }
  }
  if (v8 >= 2)
  {
    *(unsigned char *)(a6 + 1) = a1[2];
    *(unsigned char *)(a6 + 2) = a1[3];
    unsigned int v11 = 2;
LABEL_10:
    uint64_t v13 = (v9 >> 5) & 3;
    uint64_t v7 = v8 - v11;
    *a3 += v11;
    switch(v13)
    {
      case 1:
        unsigned int v14 = 1;
        *a5 = 1;
        if (!v7) {
          return 0;
        }
        goto LABEL_18;
      case 2:
        unsigned int v14 = 2;
        *a5 = 2;
        if (v7 < 2) {
          return 0;
        }
        goto LABEL_18;
      case 3:
        if (v7)
        {
          *a5 = *((unsigned char *)v10 + v11);
          ++*a3;
          unsigned int v14 = *a5;
          if ((int)v7 - 1 < v14) {
            return 0;
          }
LABEL_18:
          unsigned int v12 = *a3 + v14;
          uint64_t v7 = 1;
        }
        else
        {
          unsigned int v12 = 0;
        }
        break;
      default:
        unsigned int v14 = 0;
        *a5 = 0;
        goto LABEL_18;
    }
    goto LABEL_19;
  }
LABEL_8:
  unsigned int v12 = 0;
  uint64_t v7 = 0;
LABEL_19:
  *a3 = v12;
  return v7;
}

uint64_t ETLEVENTProcessHeader(uint64_t a1, unsigned int a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t result = 0;
  *a3 = 0;
  *a4 = 0;
  if (a2 >= 3)
  {
    if (*(unsigned char *)a1 == 96)
    {
      *a3 = *(unsigned __int16 *)(a1 + 1);
      *a4 = 3;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t ETLEVENTParseReport(char *__str, size_t __size, uint64_t a3, unsigned int a4, _DWORD *a5)
{
  uint64_t result = 0;
  *a5 = 0;
  if (a4 >= 3)
  {
    if (*(unsigned char *)a3 == 96)
    {
      unsigned int v8 = *(unsigned __int16 *)(a3 + 1);
      *a5 = 3;
      if (v8)
      {
        unsigned int v10 = (char *)(a3 + 3);
        while (1)
        {
          unsigned int v12 = -1431655766;
          unsigned int v13 = -1431655766;
          if ((ETLEVENTProcessEvent(__str, __size, &v12, v10, v8, &v13) & 1) == 0) {
            break;
          }
          unsigned int v11 = v13;
          v10 += v13;
          *a5 += v13;
          __str += v12;
          __std::string::size_type size = __size - v12;
          v8 -= v11;
          if (!v8) {
            return 1;
          }
        }
        uint64_t result = 0;
        *a5 = 0;
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t ETLEVENTParseEventReport(uint64_t a1, void *a2)
{
  uint64_t v2 = *(unsigned char **)a1;
  unsigned int v3 = *(_DWORD *)(a1 + 8);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (v3 < 3 || *v2 != 96 || *(unsigned __int16 *)(v2 + 1) + 3 != v3) {
    return 0;
  }
  uint64_t result = (uint64_t)malloc(0x28uLL);
  if (!result) {
    return result;
  }
  uint64_t v7 = (void *)result;
  unsigned int v8 = *(unsigned char **)a1;
  int v9 = *(_DWORD *)(a1 + 8);
  *(_OWORD *)uint64_t result = 0u;
  *(_OWORD *)(result + 16) = 0u;
  *(void *)(result + 32) = 0;
  unsigned int v10 = v9 + 1;
  if ((v9 + 1) > 0xFFFFFFFD) {
    goto LABEL_23;
  }
  unsigned int v11 = (char)v8[4];
  *(_WORD *)uint64_t result = (v8[3] | (unsigned __int16)((char)v8[4] << 8)) & 0xFFF;
  unsigned int v12 = v8 + 5;
  if ((v11 & 0x80000000) == 0)
  {
    if (v10 >= 8)
    {
      *(void *)(result + 2) = *v12;
      unsigned int v13 = 8;
      goto LABEL_11;
    }
LABEL_23:
    free(v7);
    return 0;
  }
  if (v10 < 2) {
    goto LABEL_23;
  }
  *(unsigned char *)(result + 3) = v8[5];
  *(unsigned char *)(result + 4) = v8[6];
  unsigned int v13 = 2;
LABEL_11:
  unsigned int v14 = v8 + 3;
  unsigned int v15 = v10 - v13;
  unsigned int v16 = v13 + 2;
  switch((v11 >> 5) & 3)
  {
    case 1u:
      unsigned int v17 = 1;
      *(unsigned char *)(result + 24) = 1;
      break;
    case 2u:
      unsigned int v17 = 2;
      *(unsigned char *)(result + 24) = 2;
      break;
    case 3u:
      if (!v15) {
        goto LABEL_23;
      }
      unsigned int v17 = *((unsigned __int8 *)v12 + v13);
      *(unsigned char *)(result + 24) = v17;
      --v15;
      unsigned int v16 = v13 + 3;
      break;
    default:
      goto LABEL_23;
  }
  if (v15 < v17) {
    goto LABEL_23;
  }
  if (!v17) {
    goto LABEL_23;
  }
  unsigned int v18 = malloc(v17);
  v7[2] = v18;
  if (!v18) {
    goto LABEL_23;
  }
  memcpy(v18, &v14[v16], v17);
  uint64_t v19 = a2[1];
  if (v19) {
    uint64_t v20 = (void *)(v19 + 32);
  }
  else {
    uint64_t v20 = a2;
  }
  *uint64_t v20 = v7;
  a2[1] = v7;
  ++*((_DWORD *)a2 + 4);
  return 1;
}

BOOL ETLEVENTReportFree(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (!*a1)
  {
    int v3 = 0;
    int v5 = *((_DWORD *)a1 + 4);
    if (v5) {
      return v3 == v5;
    }
    goto LABEL_5;
  }
  int v3 = 0;
  do
  {
    uint64_t v4 = *(void *)(v2 + 32);
    free(*(void **)(v2 + 16));
    free((void *)v2);
    ++v3;
    uint64_t v2 = v4;
  }
  while (v4);
  int v5 = *((_DWORD *)a1 + 4);
  if (v3 == v5)
  {
LABEL_5:
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return v3 == v5;
}

uint64_t ETLPRLReadStatusIsSuccess(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 1;
  if (a1 && a1 != 2)
  {
    if (a1 == 1) {
      _ETLDebugPrint((uint64_t)"ETLPRLReadStatusIsSuccess", (uint64_t)"PRL Read status kStatusPRLNVReadFail [%u]\n", a3, a4, a5, a6, a7, a8, 1);
    }
    else {
      _ETLDebugPrint((uint64_t)"ETLPRLReadStatusIsSuccess", (uint64_t)"PRL Read status Invalid [%u]\n", a3, a4, a5, a6, a7, a8, a1);
    }
    return 0;
  }
  return v8;
}

uint64_t ETLPRLWriteStatusIsSuccess(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 < 2) {
    return 1;
  }
  if (a1 == 3)
  {
    _ETLDebugPrint((uint64_t)"ETLPRLWriteStatusIsSuccess", (uint64_t)"PRL Write status kStatusPRLWriteOverflow [%u]\n", a3, a4, a5, a6, a7, a8, 3);
    return 0;
  }
  else
  {
    if (a1 == 2) {
      _ETLDebugPrint((uint64_t)"ETLPRLWriteStatusIsSuccess", (uint64_t)"PRL Write status kStatusPRLWriteOutOfSeq [%u]\n", a3, a4, a5, a6, a7, a8, 2);
    }
    else {
      _ETLDebugPrint((uint64_t)"ETLPRLWriteStatusIsSuccess", (uint64_t)"PRL Write status Invalid [%u]\n", a3, a4, a5, a6, a7, a8, a1);
    }
    return 0;
  }
}

uint64_t ETLPRLCreateReadCommand()
{
  if (HDLCFrameGetFreeSpace() <= 2) {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v0, v1, v2, v3, v4, v5, 3);
  }
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();

  return HDLCFrameInjectUnsignedChar();
}

uint64_t ETLPRLParseReadResponse(uint64_t *a1, unsigned int a2, void *__dst, uint64_t a4, unsigned int *a5, unsigned char *a6, uint64_t a7, uint64_t a8)
{
  *a5 = 0;
  *a6 = 0;
  if (*((_DWORD *)a1 + 2) <= 7u)
  {
    _ETLDebugPrint((uint64_t)"ETLPRLParseReadResponse", (uint64_t)"PRL Read Response size [%u] bytes not enough, need atleast [%u] bytes\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  uint64_t v8 = *a1;
  if (!*a1)
  {
    unsigned int v13 = "PRL Get payload failed\n";
LABEL_19:
    _ETLDebugPrint((uint64_t)"ETLPRLParseReadResponse", (uint64_t)v13, (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, a7, a8, v16);
    return 0;
  }
  int v9 = *(unsigned __int8 *)(v8 + 1);
  if (*(unsigned char *)(v8 + 1)) {
    BOOL v10 = v9 == 2;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10)
  {
    if (v9 == 1) {
      _ETLDebugPrint((uint64_t)"ETLPRLReadStatusIsSuccess", (uint64_t)"PRL Read status kStatusPRLNVReadFail [%u]\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, a7, a8, 1);
    }
    else {
      _ETLDebugPrint((uint64_t)"ETLPRLReadStatusIsSuccess", (uint64_t)"PRL Read status Invalid [%u]\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, a7, a8, *(unsigned __int8 *)(v8 + 1));
    }
    uint64_t v16 = *(unsigned __int16 *)(v8 + 2);
    unsigned int v13 = "PRL NV Read Status [%u]\n";
    goto LABEL_19;
  }
  if (*(unsigned __int8 *)(v8 + 4) != a2)
  {
    _ETLDebugPrint((uint64_t)"ETLPRLParseReadResponse", (uint64_t)"Sequence number out of order Expected[%u] Received[%u]\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, a7, a8, a2);
    return 0;
  }
  *a6 = *(unsigned char *)(v8 + 5);
  unsigned int v11 = *(unsigned __int16 *)(v8 + 6);
  if (*(_WORD *)(v8 + 6))
  {
    unsigned int v12 = v11 >> 3;
    if (v11 >> 3 > a4)
    {
      _ETLDebugPrint((uint64_t)"ETLPRLParseReadResponse", (uint64_t)"PRL Read Destination Buffer not sufficient. Passed[%u] Required[%u]\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, a7, a8, a4);
      return 0;
    }
    memcpy(__dst, (const void *)(v8 + 8), v11 >> 3);
    *a5 = v12;
  }
  return 1;
}

uint64_t ETLPRLCreateWriteCommand(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = (a3 + 6);
  if (HDLCFrameGetFreeSpace() < v3) {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v4, v5, v6, v7, v8, v9, v3);
  }
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedChar();
  HDLCFrameInjectUnsignedShort();

  return HDLCFrameInject();
}

uint64_t ETLPRLParseWriteResponse(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((_DWORD *)a1 + 2) <= 3u)
  {
    _ETLDebugPrint((uint64_t)"ETLPRLParseWriteResponse", (uint64_t)"PRL Write Response size [%u] bytes not enough, need atleast [%u] bytes\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    uint64_t v8 = *a1;
    if (*a1)
    {
      unsigned int v9 = *(unsigned __int8 *)(v8 + 1);
      if (v9 < 2)
      {
        return 1;
      }
      else
      {
        if (v9 == 3)
        {
          _ETLDebugPrint((uint64_t)"ETLPRLWriteStatusIsSuccess", (uint64_t)"PRL Write status kStatusPRLWriteOverflow [%u]\n", a3, a4, a5, a6, a7, a8, 3);
        }
        else if (v9 == 2)
        {
          _ETLDebugPrint((uint64_t)"ETLPRLWriteStatusIsSuccess", (uint64_t)"PRL Write status kStatusPRLWriteOutOfSeq [%u]\n", a3, a4, a5, a6, a7, a8, 2);
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLPRLWriteStatusIsSuccess", (uint64_t)"PRL Write status Invalid [%u]\n", a3, a4, a5, a6, a7, a8, *(unsigned __int8 *)(v8 + 1));
        }
        _ETLDebugPrint((uint64_t)"ETLPRLParseWriteResponse", (uint64_t)"PRL NV Write Status [%u]\n", v10, v11, v12, v13, v14, v15, *(unsigned __int16 *)(v8 + 2));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLPRLParseWriteResponse", (uint64_t)"PRL Get payload failed\n", a3, a4, a5, a6, a7, a8, v17);
      return 0;
    }
  }
}

uint64_t ETLPRLRead(void *a1, char *a2, unsigned int a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v5 = 0;
  if (a1 && a2 && a3 && a4)
  {
    std::string __dst = a2;
    unsigned int v37 = a3;
    unsigned int v38 = 0;
    unsigned __int8 v8 = 0;
    unsigned __int8 v45 = 1;
    unint64_t v41 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v10 = 0x1EAE4A000uLL;
    long long v39 = v9;
    long long v40 = v9;
    *a4 = 0;
    long long v11 = 0uLL;
    while (1)
    {
      uint64_t v44 = 0;
      long long v42 = v11;
      long long v43 = v11;
      if ((HDLCFrameCreateUplink() & 1) == 0) {
        break;
      }
      unint64_t v41 = 0;
      long long v39 = 0u;
      long long v40 = 0u;
      if (HDLCFrameGetFreeSpace() <= 2) {
        _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v18, v19, v20, v21, v22, v23, 3);
      }
      HDLCFrameInjectUnsignedChar();
      HDLCFrameInjectUnsignedChar();
      if (!HDLCFrameInjectUnsignedChar())
      {
        uint64_t v5 = 0;
        HDLCFrameFree();
        HDLCFrameFree();
        return v5;
      }
      uint64_t v5 = (uint64_t)malloc((2 * DWORD2(v42) + 32));
      if (!v5) {
        goto LABEL_24;
      }
      uint64_t v24 = HDLCFrameEncode();
      if (!v24) {
        goto LABEL_23;
      }
      uint64_t v25 = v24;
      int v46 = -1431655766;
      if ((*(unsigned char *)(v10 + 1504) & 2) != 0) {
        ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v5, v24);
      }
      if (!*a1)
      {
LABEL_23:
        free((void *)v5);
        uint64_t v5 = 0;
LABEL_24:
        HDLCFrameFree();
        HDLCFrameFree();
        return v5;
      }
      unint64_t v26 = v10;
      uint64_t v27 = a5;
      int v28 = ((uint64_t (*)(void *, uint64_t, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v5, v25, &v46, 1, a5, 0);
      int v29 = v46;
      free((void *)v5);
      uint64_t v5 = 0;
      if (v28 && v29 == v25)
      {
        LOBYTE(v46) = 73;
        if (!_ETLResponseRingBuffer) {
          TelephonyUtilRingBufferInitialize();
        }
        a5 = v27;
        unint64_t v10 = v26;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)&v39, (uint64_t)&_ETLResponseRingBuffer, &v46, v27)&& ETLPRLParseReadResponse((uint64_t *)&v39, v8, __dst, v37, &v38, &v45, v30, v31))
        {
          __dst += v38;
          v37 -= v38;
          *a4 += v38;
          ++v8;
          uint64_t v5 = 1;
        }
        else
        {
          uint64_t v5 = 0;
        }
      }
      else
      {
        a5 = v27;
        unint64_t v10 = v26;
      }
      HDLCFrameFree();
      int v32 = v45;
      HDLCFrameFree();
      if (v5)
      {
        long long v11 = 0uLL;
        if (v32) {
          continue;
        }
      }
      return v5;
    }
    _ETLDebugPrint((uint64_t)"ETLPRLRead", (uint64_t)"Failed to create command frame\n", v12, v13, v14, v15, v16, v17, v34);
    HDLCFrameFree();
    return 0;
  }
  return v5;
}

void *ETLPRLWrite(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = 0;
  if (a1)
  {
    uint64_t v5 = a2;
    if (a2)
    {
      unsigned int v6 = a3;
      if (a3)
      {
        unsigned __int8 v8 = (uint64_t (**)(void, void, void, void, void, void, void))a1;
        int v9 = 0;
        unint64_t v47 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
        long long v45 = v10;
        long long v46 = v10;
        long long v11 = 0uLL;
        while (1)
        {
          uint64_t v50 = 0;
          long long v48 = v11;
          long long v49 = v11;
          if ((HDLCFrameCreateUplink() & 1) == 0) {
            break;
          }
          unint64_t v47 = 0;
          long long v45 = 0u;
          long long v46 = 0u;
          if (v6 >= 0x78) {
            unsigned int v18 = 120;
          }
          else {
            unsigned int v18 = v6;
          }
          if (v6 <= 0x78) {
            unsigned int v19 = v6;
          }
          else {
            unsigned int v19 = v6 - 120;
          }
          if (HDLCFrameGetFreeSpace() < v18 + 6) {
            _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v20, v21, v22, v23, v24, v25, v18 + 6);
          }
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInjectUnsignedShort();
          uint64_t v4 = 0;
          if (!HDLCFrameInject()) {
            goto LABEL_30;
          }
          uint64_t v4 = malloc((2 * DWORD2(v48) + 32));
          if (!v4) {
            goto LABEL_30;
          }
          uint64_t v26 = HDLCFrameEncode();
          if (!v26) {
            goto LABEL_28;
          }
          uint64_t v27 = v26;
          int v51 = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v4, v26);
          }
          int v28 = (uint64_t (*)(void, void *, uint64_t, int *, uint64_t, uint64_t, void))*v8;
          if (!*v8)
          {
LABEL_28:
            free(v4);
LABEL_29:
            uint64_t v4 = 0;
LABEL_30:
            HDLCFrameFree();
            HDLCFrameFree();
            return v4;
          }
          int v29 = v8;
          uint64_t v30 = a4;
          int v31 = v28(v29, v4, v27, &v51, 1, a4, 0);
          int v32 = v51;
          free(v4);
          uint64_t v4 = 0;
          if (!v31) {
            goto LABEL_30;
          }
          BOOL v33 = v32 == v27;
          a4 = v30;
          unsigned __int8 v8 = (uint64_t (**)(void, void, void, void, void, void, void))a1;
          if (!v33) {
            goto LABEL_30;
          }
          LOBYTE(v51) = 72;
          if (!_ETLResponseRingBuffer) {
            TelephonyUtilRingBufferInitialize();
          }
          if (!ETLFindMatchingResponseUsingBuffer(a1, (unsigned __int8 **)&v45, (uint64_t)&_ETLResponseRingBuffer, &v51, a4))goto LABEL_29; {
          uint64_t v4 = (void *)ETLPRLParseWriteResponse((uint64_t *)&v45, v34, v35, v36, v37, v38, v39, v40);
          }
          HDLCFrameFree();
          HDLCFrameFree();
          if (v4)
          {
            ++v9;
            v5 += v18;
            BOOL v41 = v6 > 0x78;
            unsigned int v6 = v19;
            long long v11 = 0uLL;
            if (v41) {
              continue;
            }
          }
          return v4;
        }
        _ETLDebugPrint((uint64_t)"ETLPRLWrite", (uint64_t)"Failed to create command frame\n", v12, v13, v14, v15, v16, v17, v43);
        HDLCFrameFree();
        return 0;
      }
    }
  }
  return v4;
}

uint64_t ETLFusingCreateReadQfpromFuseCommand()
{
  return ETLFusingCreateQfpromFusingCommand();
}

uint64_t ETLFusingCreateQfpromFusingCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v15 = "ETLSubsysAddHeaderInternal";
    uint64_t v16 = "Failed to inject\n";
LABEL_13:
    _ETLDebugPrint((uint64_t)v15, (uint64_t)v16, v7, v8, v9, v10, v11, v12, v17);
    return 0;
  }
  uint64_t v13 = HDLCFrameGetFreeSpace();
  if (v13 <= 0x23)
  {
    uint64_t v17 = v13;
    uint64_t v15 = "ETLFusingCreateQfpromFusingCommand";
    uint64_t v16 = "Remaining %u not enough %u\n";
    goto LABEL_13;
  }
  if (!HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar())
  {
    return 0;
  }

  return HDLCFrameInject();
}

uint64_t ETLFusingCreateWriteQfpromFuseCommand()
{
  return ETLFusingCreateQfpromFusingCommand();
}

uint64_t ETLFusingCreateVerifyQfpromFuseCommand()
{
  return ETLFusingCreateQfpromFusingCommand();
}

uint64_t ETLFusingParseReadQfpromFuseResponse(int **a1, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  uint64_t v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 253)
      {
        uint64_t v12 = HIWORD(v11);
        if (v12 == 11)
        {
          if (v9 <= 0x21)
          {
            _ETLDebugPrint((uint64_t)"ETLFusingParseQfpromFusingResponse", (uint64_t)"Payload length %u less than needed %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else
          {
            uint64_t v13 = v10[1];
            long long v14 = *(_OWORD *)(v10 + 6);
            *a3 = *(_OWORD *)(v10 + 2);
            a3[1] = v14;
            if (v13)
            {
              _ETLDebugPrint((uint64_t)"ETLFusingParseQfpromFusingResponse", (uint64_t)"Status returned was %u, expected %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v13);
              return 0;
            }
            else
            {
              return 1;
            }
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLFusingParseWriteQfpromFuseResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a1[2];
  uint64_t v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    unsigned int v10 = **(_DWORD **)a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 253)
      {
        uint64_t v11 = HIWORD(v10);
        if (v11 == 11)
        {
          if (v9 <= 0x21)
          {
            _ETLDebugPrint((uint64_t)"ETLFusingParseQfpromFusingResponse", (uint64_t)"Payload length %u less than needed %u\n", a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else if (*(_DWORD *)(*(void *)a1 + 4))
          {
            _ETLDebugPrint((uint64_t)"ETLFusingParseQfpromFusingResponse", (uint64_t)"Status returned was %u, expected %u\n", a3, a4, a5, a6, a7, a8, *(unsigned int *)(*(void *)a1 + 4));
            return 0;
          }
          else
          {
            return 1;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

uint64_t ETLFusingParseVerifyQfpromFuseResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a1[2];
  uint64_t v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    unsigned int v10 = **(_DWORD **)a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 253)
      {
        uint64_t v11 = HIWORD(v10);
        if (v11 == 11)
        {
          if (v9 <= 0x21)
          {
            _ETLDebugPrint((uint64_t)"ETLFusingParseQfpromFusingResponse", (uint64_t)"Payload length %u less than needed %u\n", a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else if (*(_DWORD *)(*(void *)a1 + 4))
          {
            _ETLDebugPrint((uint64_t)"ETLFusingParseQfpromFusingResponse", (uint64_t)"Status returned was %u, expected %u\n", a3, a4, a5, a6, a7, a8, *(unsigned int *)(*(void *)a1 + 4));
            return 0;
          }
          else
          {
            return 1;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

uint64_t ETLFusingProgramQfpromFuse(void *a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long __dst = v13;
  long long v54 = v13;
  v52[0] = v13;
  v52[1] = v13;
  v51[3] = 0xAAAAAAAAAAAAAAAALL;
  memset((char *)v51 + 1, 170, 24);
  if (a5 > 0x1F)
  {
    long long v15 = a4[1];
    long long __dst = *a4;
    long long v54 = v15;
  }
  else
  {
    unsigned int v14 = a5;
    _ETLDebugPrint((uint64_t)"ETLFusingProgramQfpromFuse", (uint64_t)"Data length needed %u  provided %u - padding the rest with zeroes\n", a3, (uint64_t)a4, a5, a6, a7, a8, 32);
    memcpy(&__dst, a4, v14);
    bzero((char *)&__dst + v14, 32 - v14);
  }
  memset(__b, 170, sizeof(__b));
  TelephonyUtilLogBinaryToBuffer();
  _ETLDebugPrint((uint64_t)"ETLFusingShowQfpromFuse", (uint64_t)"%s fuse %u, value: \t%s\n", v16, v17, v18, v19, v20, v21, (uint64_t)"Programming");
  *(void *)&long long v22 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v49 = v22;
  long long v50 = v22;
  if (ETLFusingPerformQfpromFusingOperation(a1, a2, 0, 0, (uint64_t)v52, &v49, a6))
  {
    memset(__b, 170, sizeof(__b));
    TelephonyUtilLogBinaryToBuffer();
    _ETLDebugPrint((uint64_t)"ETLFusingShowQfpromFuse", (uint64_t)"%s fuse %u, value: \t%s\n", v29, v30, v31, v32, v33, v34, (uint64_t)"Read back");
    uint64_t v41 = __dst;
    LOBYTE(v51[0]) = __dst & ~(_BYTE)v49;
    if ((v49 | __dst) == __dst)
    {
      uint64_t v41 = BYTE1(__dst);
      BYTE1(v51[0]) = BYTE1(__dst) & ~BYTE1(v49);
      if ((BYTE1(v49) | BYTE1(__dst)) == BYTE1(__dst))
      {
        uint64_t v41 = BYTE2(__dst);
        BYTE2(v51[0]) = BYTE2(__dst) & ~BYTE2(v49);
        if ((BYTE2(v49) | BYTE2(__dst)) == BYTE2(__dst))
        {
          uint64_t v41 = BYTE3(__dst);
          BYTE3(v51[0]) = BYTE3(__dst) & ~BYTE3(v49);
          if ((BYTE3(v49) | BYTE3(__dst)) == BYTE3(__dst))
          {
            uint64_t v41 = BYTE4(__dst);
            BYTE4(v51[0]) = BYTE4(__dst) & ~BYTE4(v49);
            if ((BYTE4(v49) | BYTE4(__dst)) == BYTE4(__dst))
            {
              uint64_t v41 = BYTE5(__dst);
              BYTE5(v51[0]) = BYTE5(__dst) & ~BYTE5(v49);
              if ((BYTE5(v49) | BYTE5(__dst)) == BYTE5(__dst))
              {
                uint64_t v41 = BYTE6(__dst);
                BYTE6(v51[0]) = BYTE6(__dst) & ~BYTE6(v49);
                if ((BYTE6(v49) | BYTE6(__dst)) == BYTE6(__dst))
                {
                  uint64_t v41 = BYTE7(__dst);
                  HIBYTE(v51[0]) = BYTE7(__dst) & ~BYTE7(v49);
                  if ((BYTE7(v49) | BYTE7(__dst)) == BYTE7(__dst))
                  {
                    uint64_t v41 = BYTE8(__dst);
                    LOBYTE(v51[1]) = BYTE8(__dst) & ~BYTE8(v49);
                    if ((BYTE8(v49) | BYTE8(__dst)) == BYTE8(__dst))
                    {
                      uint64_t v41 = BYTE9(__dst);
                      BYTE1(v51[1]) = BYTE9(__dst) & ~BYTE9(v49);
                      if ((BYTE9(v49) | BYTE9(__dst)) == BYTE9(__dst))
                      {
                        uint64_t v41 = BYTE10(__dst);
                        BYTE2(v51[1]) = BYTE10(__dst) & ~BYTE10(v49);
                        if ((BYTE10(v49) | BYTE10(__dst)) == BYTE10(__dst))
                        {
                          uint64_t v41 = BYTE11(__dst);
                          BYTE3(v51[1]) = BYTE11(__dst) & ~BYTE11(v49);
                          if ((BYTE11(v49) | BYTE11(__dst)) == BYTE11(__dst))
                          {
                            uint64_t v41 = BYTE12(__dst);
                            BYTE4(v51[1]) = BYTE12(__dst) & ~BYTE12(v49);
                            if ((BYTE12(v49) | BYTE12(__dst)) == BYTE12(__dst))
                            {
                              uint64_t v41 = BYTE13(__dst);
                              BYTE5(v51[1]) = BYTE13(__dst) & ~BYTE13(v49);
                              if ((BYTE13(v49) | BYTE13(__dst)) == BYTE13(__dst))
                              {
                                uint64_t v41 = BYTE14(__dst);
                                BYTE6(v51[1]) = BYTE14(__dst) & ~BYTE14(v49);
                                if ((BYTE14(v49) | BYTE14(__dst)) == BYTE14(__dst))
                                {
                                  uint64_t v41 = HIBYTE(__dst);
                                  HIBYTE(v51[1]) = HIBYTE(__dst) & ~HIBYTE(v49);
                                  if ((HIBYTE(v49) | HIBYTE(__dst)) == HIBYTE(__dst))
                                  {
                                    uint64_t v41 = v54;
                                    LOBYTE(v51[2]) = v54 & ~(_BYTE)v50;
                                    if ((v50 | v54) == v54)
                                    {
                                      uint64_t v41 = BYTE1(v54);
                                      BYTE1(v51[2]) = BYTE1(v54) & ~BYTE1(v50);
                                      if ((BYTE1(v50) | BYTE1(v54)) == BYTE1(v54))
                                      {
                                        uint64_t v41 = BYTE2(v54);
                                        BYTE2(v51[2]) = BYTE2(v54) & ~BYTE2(v50);
                                        if ((BYTE2(v50) | BYTE2(v54)) == BYTE2(v54))
                                        {
                                          uint64_t v41 = BYTE3(v54);
                                          BYTE3(v51[2]) = BYTE3(v54) & ~BYTE3(v50);
                                          if ((BYTE3(v50) | BYTE3(v54)) == BYTE3(v54))
                                          {
                                            uint64_t v41 = BYTE4(v54);
                                            BYTE4(v51[2]) = BYTE4(v54) & ~BYTE4(v50);
                                            if ((BYTE4(v50) | BYTE4(v54)) == BYTE4(v54))
                                            {
                                              uint64_t v41 = BYTE5(v54);
                                              BYTE5(v51[2]) = BYTE5(v54) & ~BYTE5(v50);
                                              if ((BYTE5(v50) | BYTE5(v54)) == BYTE5(v54))
                                              {
                                                uint64_t v41 = BYTE6(v54);
                                                BYTE6(v51[2]) = BYTE6(v54) & ~BYTE6(v50);
                                                if ((BYTE6(v50) | BYTE6(v54)) == BYTE6(v54))
                                                {
                                                  uint64_t v41 = BYTE7(v54);
                                                  HIBYTE(v51[2]) = BYTE7(v54) & ~BYTE7(v50);
                                                  if ((BYTE7(v50) | BYTE7(v54)) == BYTE7(v54))
                                                  {
                                                    uint64_t v41 = BYTE8(v54);
                                                    LOBYTE(v51[3]) = BYTE8(v54) & ~BYTE8(v50);
                                                    if ((BYTE8(v50) | BYTE8(v54)) == BYTE8(v54))
                                                    {
                                                      uint64_t v41 = BYTE9(v54);
                                                      BYTE1(v51[3]) = BYTE9(v54) & ~BYTE9(v50);
                                                      if ((BYTE9(v50) | BYTE9(v54)) == BYTE9(v54))
                                                      {
                                                        uint64_t v41 = BYTE10(v54);
                                                        BYTE2(v51[3]) = BYTE10(v54) & ~BYTE10(v50);
                                                        if ((BYTE10(v50) | BYTE10(v54)) == BYTE10(v54))
                                                        {
                                                          uint64_t v41 = BYTE11(v54);
                                                          BYTE3(v51[3]) = BYTE11(v54) & ~BYTE11(v50);
                                                          if ((BYTE11(v50) | BYTE11(v54)) == BYTE11(v54))
                                                          {
                                                            uint64_t v41 = BYTE12(v54);
                                                            BYTE4(v51[3]) = BYTE12(v54) & ~BYTE12(v50);
                                                            if ((BYTE12(v50) | BYTE12(v54)) == BYTE12(v54))
                                                            {
                                                              uint64_t v41 = BYTE13(v54);
                                                              BYTE5(v51[3]) = BYTE13(v54) & ~BYTE13(v50);
                                                              if ((BYTE13(v50) | BYTE13(v54)) == BYTE13(v54))
                                                              {
                                                                uint64_t v41 = BYTE14(v54);
                                                                BYTE6(v51[3]) = BYTE14(v54) & ~BYTE14(v50);
                                                                if ((BYTE14(v50) | BYTE14(v54)) == BYTE14(v54))
                                                                {
                                                                  uint64_t v41 = HIBYTE(v54);
                                                                  HIBYTE(v51[3]) = HIBYTE(v54) & ~HIBYTE(v50);
                                                                  if ((HIBYTE(v50) | HIBYTE(v54)) == HIBYTE(v54))
                                                                  {
                                                                    memset(__b, 170, sizeof(__b));
                                                                    TelephonyUtilLogBinaryToBuffer();
                                                                    _ETLDebugPrint((uint64_t)"ETLFusingShowQfpromFuse", (uint64_t)"%s fuse %u, value: \t%s\n", v42, v43, v44, v45, v46, v47, (uint64_t)"Final write value for Programming");
                                                                    return ETLFusingPerformQfpromFusingOperation(a1, a2, 1, a3, (uint64_t)v51, v52, a6);
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    _ETLDebugPrint((uint64_t)"ETLFusingProgramQfpromFuse", (uint64_t)"Mismatch, expected to write %02x, final value on device will be %02x\n", v35, v36, v37, v38, v39, v40, v41);
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLFusingProgramQfpromFuse", (uint64_t)"Failed to read the fuse %u\n", v23, v24, v25, v26, v27, v28, a2);
  }
  return 0;
}

uint64_t ETLFusingPerformQfpromFusingOperation(void *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, _OWORD *a6, uint64_t a7)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  long long v42 = 0u;
  long long v43 = 0u;
  uint64_t v44 = 0;
  memset(v40, 0, sizeof(v40));
  uint64_t v41 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLFusingPerformQfpromFusingOperation", (uint64_t)"Faild to create uplink frame\n", v11, v12, v13, v14, v15, v16, v39);
    goto LABEL_8;
  }
  if (!a3)
  {
    memset(v45, 0, sizeof(v45));
    uint64_t v17 = 0;
    if (!ETLFusingCreateQfpromFusingCommand()) {
      goto LABEL_9;
    }
    goto LABEL_13;
  }
  if (a3 == 2)
  {
    if (ETLFusingCreateQfpromFusingCommand()) {
      goto LABEL_13;
    }
LABEL_8:
    uint64_t v17 = 0;
    goto LABEL_9;
  }
  if (a3 == 1 && (ETLFusingCreateQfpromFusingCommand() & 1) == 0) {
    goto LABEL_8;
  }
LABEL_13:
  uint64_t v17 = (uint64_t)malloc((2 * DWORD2(v42) + 32));
  if (!v17) {
    goto LABEL_9;
  }
  uint64_t v19 = HDLCFrameEncode();
  if (!v19) {
    goto LABEL_31;
  }
  uint64_t v20 = v19;
  LODWORD(v45[0]) = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v17, v19);
  }
  if (!*a1)
  {
LABEL_31:
    free((void *)v17);
    goto LABEL_8;
  }
  int v21 = ((uint64_t (*)(void *, uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, void))*a1)(a1, v17, v20, v45, 1, a7, 0);
  int v22 = v45[0];
  free((void *)v17);
  uint64_t v17 = 0;
  if (!v21 || v22 != v20) {
    goto LABEL_9;
  }
  LOBYTE(v45[0]) = 75;
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  uint64_t v17 = 0;
  if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v40, (uint64_t)&_ETLResponseRingBuffer, v45, a7)|| LOBYTE(v45[0]) != 75)
  {
    goto LABEL_9;
  }
  if (a3 == 2)
  {
    LODWORD(v45[0]) = 0;
    uint64_t v17 = 0;
    if (!ETLMaverickParseBSPResponseHeader((uint64_t)v40, v45, 11, v23, v24, v25, v26, v27)) {
      goto LABEL_9;
    }
    uint64_t v38 = LODWORD(v45[0]);
    uint64_t v34 = (DWORD2(v40[0]) - LODWORD(v45[0]));
    if (v34 <= 0x21) {
      goto LABEL_38;
    }
    goto LABEL_34;
  }
  if (a3 == 1)
  {
    LODWORD(v45[0]) = 0;
    uint64_t v17 = 0;
    if (!ETLMaverickParseBSPResponseHeader((uint64_t)v40, v45, 11, v23, v24, v25, v26, v27)) {
      goto LABEL_9;
    }
    uint64_t v38 = LODWORD(v45[0]);
    uint64_t v34 = (DWORD2(v40[0]) - LODWORD(v45[0]));
    if (v34 <= 0x21) {
      goto LABEL_38;
    }
LABEL_34:
    uint64_t v36 = *(unsigned int *)(*(void *)&v40[0] + v38);
    if (!v36) {
      goto LABEL_30;
    }
LABEL_35:
    _ETLDebugPrint((uint64_t)"ETLFusingParseQfpromFusingResponse", (uint64_t)"Status returned was %u, expected %u\n", v28, v29, v30, v31, v32, v33, v36);
    goto LABEL_8;
  }
  if (a3)
  {
LABEL_30:
    uint64_t v17 = 1;
    goto LABEL_9;
  }
  LODWORD(v45[0]) = 0;
  uint64_t v17 = 0;
  if (ETLMaverickParseBSPResponseHeader((uint64_t)v40, v45, 11, v23, v24, v25, v26, v27))
  {
    uint64_t v34 = (DWORD2(v40[0]) - LODWORD(v45[0]));
    if (v34 > 0x21)
    {
      uint64_t v35 = (unsigned int *)(*(void *)&v40[0] + LODWORD(v45[0]));
      uint64_t v36 = *v35;
      long long v37 = *(_OWORD *)(v35 + 5);
      *a6 = *(_OWORD *)(v35 + 1);
      a6[1] = v37;
      if (!v36) {
        goto LABEL_30;
      }
      goto LABEL_35;
    }
LABEL_38:
    _ETLDebugPrint((uint64_t)"ETLFusingParseQfpromFusingResponse", (uint64_t)"Payload length %u less than needed %u\n", v28, v29, v30, v31, v32, v33, v34);
    goto LABEL_8;
  }
LABEL_9:
  HDLCFrameFree();
  HDLCFrameFree();
  return v17;
}

uint64_t ETLFusingReadQfpromFuse(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v26[133] = *MEMORY[0x1E4F143B8];
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)uint64_t v26 = v8;
  *(_OWORD *)&_OWORD v26[2] = v8;
  *a5 = 0;
  if (a4 > 0x1F)
  {
    uint64_t v12 = (void *)MEMORY[0x1F4188790](a1, a2, a3, a4);
    long long v24 = v13;
    long long v25 = v13;
    uint64_t v9 = ETLFusingPerformQfpromFusingOperation(v12, v14, 0, 0, (uint64_t)v26, &v24, v15);
    if (v9)
    {
      *a5 = 32;
      long long v16 = v25;
      *a3 = v24;
      a3[1] = v16;
      memset(&v26[5], 170, 0x400uLL);
      TelephonyUtilLogBinaryToBuffer();
      _ETLDebugPrint((uint64_t)"ETLFusingShowQfpromFuse", (uint64_t)"%s fuse %u, value: \t%s\n", v17, v18, v19, v20, v21, v22, (uint64_t)"Read back");
    }
  }
  else
  {
    *((void *)&v25 + 1) = 32;
    _ETLDebugPrint((uint64_t)"ETLFusingReadQfpromFuse", (uint64_t)"Data capacity %u less than required %u\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, a4);
    return 0;
  }
  return v9;
}

uint64_t ETLFusingVerifyQfpromFuse(void *a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long __dst = v13;
  long long v24 = v13;
  if (a5 > 0x1F)
  {
    long long v15 = a4[1];
    long long __dst = *a4;
    long long v24 = v15;
  }
  else
  {
    unsigned int v14 = a5;
    _ETLDebugPrint((uint64_t)"ETLFusingVerifyQfpromFuse", (uint64_t)"Data length needed %u  provided %u - padding the rest with zeroes\n", a3, (uint64_t)a4, a5, a6, a7, a8, 32);
    memcpy(&__dst, a4, v14);
    bzero((char *)&__dst + v14, 32 - v14);
  }
  memset(__b, 170, sizeof(__b));
  TelephonyUtilLogBinaryToBuffer();
  _ETLDebugPrint((uint64_t)"ETLFusingShowQfpromFuse", (uint64_t)"%s fuse %u, value: \t%s\n", v16, v17, v18, v19, v20, v21, (uint64_t)"Verifying");
  return ETLFusingPerformQfpromFusingOperation(a1, a2, 2, a3, (uint64_t)&__dst, __b, a6);
}

uint64_t ETLProvisionAddSecurityCommandHeader()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 2);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedShort();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

uint64_t ETLProvisionParseSecurityResponseHeader(uint64_t a1, int a2, _WORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = ETLMaverickParseFACTORYResponseHeader(a1, a4, 12, (uint64_t)a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v19 = *a4;
    if ((*(_DWORD *)(a1 + 8) - v19) <= 3)
    {
      _ETLDebugPrint((uint64_t)"ETLProvisionParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", v13, v14, v15, v16, v17, v18, 4);
    }
    else
    {
      uint64_t v20 = (unsigned __int16 *)(*(void *)a1 + v19);
      if (*v20 == a2)
      {
        *a3 = v20[1];
        *a4 = v19 + 4;
        return 1;
      }
      _ETLDebugPrint((uint64_t)"ETLProvisionParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", v13, v14, v15, v16, v17, v18, *v20);
    }
    return 0;
  }
  return result;
}

const char *ETLProvisionGetStateAsString(unsigned int a1)
{
  if (a1 > 4) {
    return "???";
  }
  else {
    return off_1E6E6FF30[a1];
  }
}

uint64_t ETLProvisionParseStatus(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _ETLDebugPrint((uint64_t)"ETLProvisionParseStatus", (uint64_t)"Provisioning manifest status %u\n", a3, a4, a5, a6, a7, a8, *(unsigned __int16 *)(a1 + 8));
  int v10 = *(unsigned __int16 *)(a1 + 8);
  unsigned int v11 = v10 - 28;
  if (v10 == 6) {
    int v12 = 2;
  }
  else {
    int v12 = 1;
  }
  if (*(_WORD *)(a1 + 8)) {
    int v13 = v12;
  }
  else {
    int v13 = 0;
  }
  if (v11 < 2) {
    int v13 = 3;
  }
  *(_DWORD *)(a2 + 4) = v13;
  return 1;
}

uint64_t ETLProvisionCreateStartProvisionCommand(uint64_t a1, uint64_t a2)
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v4, v5, v6, v7, v8, v9, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v17 = "ETLSubsysAddHeaderInternal";
    uint64_t v18 = "Failed to inject\n";
LABEL_11:
    _ETLDebugPrint((uint64_t)v17, (uint64_t)v18, v10, v11, v12, v13, v14, v15, v20);
    return 0;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v20 = 2;
    goto LABEL_10;
  }
  if (!HDLCFrameInjectUnsignedShort()) {
    return 0;
  }
  uint64_t v16 = (*(_DWORD *)(a2 + 8) + 2);
  if (HDLCFrameGetFreeSpace() < v16)
  {
    uint64_t v20 = v16;
LABEL_10:
    uint64_t v17 = "ETLRequireFreeSpace";
    uint64_t v18 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_11;
  }
  if (!HDLCFrameInjectUnsignedShort()) {
    return 0;
  }

  return HDLCFrameInject();
}

uint64_t ETLProvisionParseStartProvisionResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a1[2];
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  uint64_t v9 = *(unsigned int **)a1;
  unsigned int v10 = **(_DWORD **)a1;
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
    return 0;
  }
  if (BYTE1(v10) != 254)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
    return 0;
  }
  uint64_t v11 = HIWORD(v10);
  if (v11 != 12)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
    return 0;
  }
  if (v8 - 4 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLProvisionParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
    return 0;
  }
  uint64_t v12 = *((unsigned __int16 *)v9 + 2);
  if (*((_WORD *)v9 + 2))
  {
    _ETLDebugPrint((uint64_t)"ETLProvisionParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v9 + 2));
    return 0;
  }
  if (v8 - 28 > 0xFFFFFFEB || *((_WORD *)v9 + 3)) {
    return v12;
  }
  size_t v14 = v9[6];
  *(_OWORD *)a2 = *(_OWORD *)(v9 + 2);
  *(_DWORD *)(a2 + 16) = v14;
  if (v14 > 0x100 || a1[2] - 28 < v14) {
    return 0;
  }
  memcpy((void *)(a2 + 20), (const void *)(*(void *)a1 + 28), v14);
  return 1;
}

uint64_t ETLProvisionCreateFinishProvisionCommand(uint64_t a1, uint64_t a2)
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v4, v5, v6, v7, v8, v9, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v17 = "ETLSubsysAddHeaderInternal";
    uint64_t v18 = "Failed to inject\n";
LABEL_11:
    _ETLDebugPrint((uint64_t)v17, (uint64_t)v18, v10, v11, v12, v13, v14, v15, v20);
    return 0;
  }
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v20 = 2;
    goto LABEL_10;
  }
  if (!HDLCFrameInjectUnsignedShort()) {
    return 0;
  }
  uint64_t v16 = (*(_DWORD *)(a2 + 8) + 2);
  if (HDLCFrameGetFreeSpace() < v16)
  {
    uint64_t v20 = v16;
LABEL_10:
    uint64_t v17 = "ETLRequireFreeSpace";
    uint64_t v18 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_11;
  }
  if (!HDLCFrameInjectUnsignedShort()) {
    return 0;
  }

  return HDLCFrameInject();
}

uint64_t ETLProvisionParseFinishProvisionResponse(int **a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  uint64_t v9 = *a1;
  unsigned int v10 = **a1;
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
    return 0;
  }
  if (BYTE1(v10) != 254)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
    return 0;
  }
  uint64_t v11 = HIWORD(v10);
  if (v11 != 12)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
    return 0;
  }
  if (v8 - 4 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLProvisionParseSecurityResponseHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 4);
    return 0;
  }
  if (*((_WORD *)v9 + 2) != 1)
  {
    _ETLDebugPrint((uint64_t)"ETLProvisionParseSecurityResponseHeader", (uint64_t)"Received code 0x%x mismatches expected 0x%x\n", a3, a4, a5, a6, a7, a8, *((unsigned __int16 *)v9 + 2));
    return 0;
  }
  uint64_t result = 0;
  if (v8 - 15 <= 0xFFFFFFF8 && !*((_WORD *)v9 + 3))
  {
    int v13 = v9[2];
    *(_DWORD *)((char *)a2 + 3) = *(_DWORD *)((char *)v9 + 11);
    *a2 = v13;
    return 1;
  }
  return result;
}

uint64_t ETLProvisionGetStatus(void *a1, uint64_t a2, uint64_t a3)
{
  memset(v18, 0, sizeof(v18));
  *(void *)a2 = 0;
  if (ETLMaverickGetManifestStatus(a1, (uint64_t *)v18, a3))
  {
    int v10 = WORD4(v18[0]);
    _ETLDebugPrint((uint64_t)"ETLProvisionParseStatus", (uint64_t)"Provisioning manifest status %u\n", v4, v5, v6, v7, v8, v9, WORD4(v18[0]));
    unsigned int v11 = v10 - 28;
    if (v10 == 6) {
      int v12 = 2;
    }
    else {
      int v12 = 1;
    }
    if (v10) {
      BOOL v13 = v10 != 6;
    }
    else {
      BOOL v13 = 0;
    }
    if (!v10) {
      int v12 = 0;
    }
    BOOL v14 = v11 >= 2;
    BOOL v15 = v11 >= 2 && v13;
    if (v14) {
      int v16 = v12;
    }
    else {
      int v16 = 3;
    }
    *(_DWORD *)(a2 + 4) = v16;
    *(unsigned char *)a2 = v15;
    return 1;
  }
  else
  {
    *(_DWORD *)(a2 + 4) = 4;
    return 1;
  }
}

uint64_t ETLProvisionStart(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  memset(v26, 0, sizeof(v26));
  uint64_t v27 = 0;
  memset(v24, 0, sizeof(v24));
  uint64_t v25 = 0;
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_19;
  }
  if (!ETLProvisionCreateStartProvisionCommand((uint64_t)v26, a2)) {
    goto LABEL_19;
  }
  uint64_t v8 = malloc((2 * DWORD2(v26[0]) + 32));
  if (!v8) {
    goto LABEL_19;
  }
  uint64_t v9 = v8;
  uint64_t v10 = HDLCFrameEncode();
  if (!v10) {
    goto LABEL_18;
  }
  uint64_t v11 = v10;
  int v28 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v9, v10);
  }
  if (!*a1)
  {
LABEL_18:
    free(v9);
LABEL_19:
    uint64_t started = 0;
    goto LABEL_20;
  }
  int v12 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v9, v11, &v28, 1, a4, 0);
  int v13 = v28;
  free(v9);
  if (v12) {
    BOOL v14 = v13 == v11;
  }
  else {
    BOOL v14 = 0;
  }
  if (!v14) {
    goto LABEL_19;
  }
  LOBYTE(v28) = 75;
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  int v15 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v24, (uint64_t)&_ETLResponseRingBuffer, &v28, a4);
  uint64_t started = 0;
  if (v15 && v28 == 75) {
    uint64_t started = ETLProvisionParseStartProvisionResponse((unsigned int *)v24, a3, v16, v17, v18, v19, v20, v21);
  }
LABEL_20:
  HDLCFrameFree();
  HDLCFrameFree();
  return started;
}

uint64_t ETLProvisionFinish(void *a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  memset(v27, 0, sizeof(v27));
  uint64_t v28 = 0;
  memset(v25, 0, sizeof(v25));
  uint64_t v26 = 0;
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_19;
  }
  if (!ETLProvisionCreateFinishProvisionCommand((uint64_t)v27, a2)) {
    goto LABEL_19;
  }
  uint64_t v8 = malloc((2 * DWORD2(v27[0]) + 32));
  if (!v8) {
    goto LABEL_19;
  }
  uint64_t v9 = v8;
  uint64_t v10 = HDLCFrameEncode();
  if (!v10) {
    goto LABEL_18;
  }
  uint64_t v11 = v10;
  int v29 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v9, v10);
  }
  if (!*a1)
  {
LABEL_18:
    free(v9);
LABEL_19:
    uint64_t v23 = 0;
    goto LABEL_20;
  }
  int v12 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v9, v11, &v29, 1, a4, 0);
  int v13 = v29;
  free(v9);
  if (v12) {
    BOOL v14 = v13 == v11;
  }
  else {
    BOOL v14 = 0;
  }
  if (!v14) {
    goto LABEL_19;
  }
  unsigned int v15 = 3 * a4;
  LOBYTE(v29) = 75;
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  int v16 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v25, (uint64_t)&_ETLResponseRingBuffer, &v29, v15);
  uint64_t v23 = 0;
  if (v16 && v29 == 75) {
    uint64_t v23 = ETLProvisionParseFinishProvisionResponse((int **)v25, a3, v17, v18, v19, v20, v21, v22);
  }
LABEL_20:
  HDLCFrameFree();
  HDLCFrameFree();
  return v23;
}

uint64_t ETLEFS2PrintError(uint64_t __errnum)
{
  uint64_t v1 = __errnum;
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  long long v22 = 0u;
  memset(v23, 0, sizeof(v23));
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  *(_OWORD *)__strerrbuf = 0u;
  if ((int)__errnum >= 0x8000)
  {
    if ((int)__errnum <= 32769)
    {
      if (__errnum == 0x8000) {
        uint64_t v2 = "End of file. Internal error.";
      }
      else {
        uint64_t v2 = "Untranslated SFAT error code.";
      }
      goto LABEL_26;
    }
    switch(__errnum)
    {
      case 0x8002:
        uint64_t v2 = "Untranslated HFAT error code.";
        goto LABEL_26;
      case 0xFFFF:
        uint64_t v2 = "Internal Error";
        goto LABEL_26;
      case 0x10000:
        uint64_t v2 = "File has no number to EFS file mapping";
        goto LABEL_26;
    }
  }
  else
  {
    if ((int)__errnum > 121)
    {
      switch((int)__errnum)
      {
        case 301:
          uint64_t v2 = "No media present.";
          goto LABEL_26;
        case 302:
          uint64_t v2 = "Bad formatted media.";
          goto LABEL_26;
        case 303:
          uint64_t v2 = "Not an EFS2 item file.";
          goto LABEL_26;
        case 304:
          uint64_t v2 = "Rollback failed while backing orig file.";
          goto LABEL_26;
        default:
          if (__errnum != 122) {
            goto LABEL_19;
          }
          uint64_t v2 = "Writing beyong quota.";
          break;
      }
      goto LABEL_26;
    }
    switch(__errnum)
    {
      case 0:
        return __errnum;
      case 0x22:
        uint64_t v2 = "Parameter out of range.";
        goto LABEL_26;
      case 0x74:
        uint64_t v2 = "Stale remote file handle.";
LABEL_26:
        strncpy(__strerrbuf, v2, 0xFEuLL);
        goto LABEL_27;
    }
  }
LABEL_19:
  strerror_r(__errnum, __strerrbuf, 0xFEuLL);
LABEL_27:
  fprintf((FILE *)*MEMORY[0x1E4F143C8], "Error: [%d] ETL EFS - %s\n", v1, __strerrbuf);
  return _ETLDebugPrint((uint64_t)"ETLEFS2PrintError", (uint64_t)"Error: [%d] ETL EFS - %s\n", v3, v4, v5, v6, v7, v8, v1);
}

uint64_t ETLEFS2CreatePutCommand(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, unsigned int a7)
{
  if (a7 > 0x7C00) {
    return 0;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v10, v11, v12, v13, v14, v15, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v16, v17, v18, v19, v20, v21, v30);
    return 0;
  }
  uint64_t v22 = a7 + strlen(a5) + 1 + 6;
  if (HDLCFrameGetFreeSpace() < v22)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v23, v24, v25, v26, v27, v28, v22);
    return 0;
  }
  if (!HDLCFrameInjectUnsignedInt()
    || !HDLCFrameInjectUnsignedInt()
    || !HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInject())
  {
    return 0;
  }

  return HDLCFrameInject();
}

BOOL ETLEFS2ParsePutResponse(int **a1, int a2, _WORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a4 = 0xFFFF;
  unsigned int v8 = *((_DWORD *)a1 + 2);
  unsigned int v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  uint64_t v10 = *a1;
  unsigned int v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, **a1);
    return 0;
  }
  unsigned int v12 = HIWORD(v11);
  int v13 = BYTE1(v11);
  if (a2) {
    uint64_t v14 = 62;
  }
  else {
    uint64_t v14 = 19;
  }
  if (v13 != v14)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseHeader", (uint64_t)"Subsys mismatch, expected 0x%x, got 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, v14);
    goto LABEL_13;
  }
  if (v12 != 38)
  {
LABEL_13:
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseHeader", (uint64_t)"Command code mismatch, expected 0x%x, got 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, 38);
    return 0;
  }
  if (v9 <= 5)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParsePutResponse", (uint64_t)"Needed %u bytes, available %u\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, 6);
    return 0;
  }
  else
  {
    *a3 = *((_WORD *)v10 + 2);
    int v15 = *(_DWORD *)((char *)v10 + 6);
    *a4 = v15;
    return v15 == 0;
  }
}

uint64_t ETLEFS2CreateGetCommand(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, unsigned int a6)
{
  if (a6 >= 0x7C00) {
    int v7 = 31744;
  }
  else {
    int v7 = a6;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v9, v10, v11, v12, v13, v14, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v15, v16, v17, v18, v19, v20, v29);
    return 0;
  }
  uint64_t v21 = v7 + strlen(a4) + 1 + 6;
  if (HDLCFrameGetFreeSpace() < v21)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v22, v23, v24, v25, v26, v27, v21);
    return 0;
  }
  if (!HDLCFrameInjectUnsignedInt()
    || !HDLCFrameInjectUnsignedInt()
    || !HDLCFrameInjectUnsignedShort())
  {
    return 0;
  }

  return HDLCFrameInject();
}

uint64_t ETLEFS2CreateStatCommand(uint64_t a1, uint64_t a2, const char *a3)
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v5, v6, v7, v8, v9, v10, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v11, v12, v13, v14, v15, v16, v25);
    return 0;
  }
  uint64_t v17 = strlen(a3) + 1;
  if (HDLCFrameGetFreeSpace() < v17)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v18, v19, v20, v21, v22, v23, v17);
    return 0;
  }

  return HDLCFrameInject();
}

uint64_t ETLEFS2ParseGetResponse(int **a1, int a2, void *__dst, uint64_t a4, _WORD *a5, _DWORD *a6, _DWORD *a7, uint64_t a8)
{
  *a6 = 0xFFFF;
  unsigned int v8 = *((_DWORD *)a1 + 2);
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  uint64_t v9 = *a1;
  unsigned int v10 = **a1;
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, **a1);
    return 0;
  }
  unsigned int v11 = HIWORD(v10);
  int v12 = BYTE1(v10);
  if (a2) {
    uint64_t v13 = 62;
  }
  else {
    uint64_t v13 = 19;
  }
  if (v12 != v13)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseHeader", (uint64_t)"Subsys mismatch, expected 0x%x, got 0x%x\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, v13);
    goto LABEL_14;
  }
  if (v11 != 39)
  {
LABEL_14:
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseHeader", (uint64_t)"Command code mismatch, expected 0x%x, got 0x%x\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, 39);
    return 0;
  }
  if (v8 - 4 <= 9)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseGetResponse", (uint64_t)"Needed %u bytes, available %u\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, 10);
    return 0;
  }
  else
  {
    *a7 = v9[1];
    *a6 = v9[2];
    *a5 = *((_WORD *)v9 + 6);
    if (*a6)
    {
      return 0;
    }
    else
    {
      size_t v15 = v8 - 14;
      if (v15 <= a4)
      {
        memcpy(__dst, (char *)v9 + 14, v15);
        return 1;
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLEFS2ParseGetResponse", (uint64_t)"Capacity %u is not enough for response of size %u\n", (uint64_t)__dst, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, a4);
        return 0;
      }
    }
  }
}

uint64_t ETLEFS2ParseStatResponse(int **a1, int a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a3 = 0xFFFF;
  unsigned int v8 = *((_DWORD *)a1 + 2);
  unsigned int v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  unsigned int v10 = *a1;
  unsigned int v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, **a1);
    return 0;
  }
  unsigned int v12 = HIWORD(v11);
  int v13 = BYTE1(v11);
  if (a2) {
    uint64_t v14 = 62;
  }
  else {
    uint64_t v14 = 19;
  }
  if (v13 != v14)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseHeader", (uint64_t)"Subsys mismatch, expected 0x%x, got 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, v14);
    goto LABEL_14;
  }
  if (v12 != 15)
  {
LABEL_14:
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseHeader", (uint64_t)"Command code mismatch, expected 0x%x, got 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, 15);
    return 0;
  }
  if (v9 <= 0x1B)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseStatResponse", (uint64_t)"Needed %u bytes, available %u\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, 28);
    return 0;
  }
  else
  {
    int v15 = v10[1];
    *a3 = v15;
    if (v15)
    {
      return 0;
    }
    else
    {
      *a4 = v10[3];
      return 1;
    }
  }
}

uint64_t ETLEFS2SelectorFromString(const char *a1, _DWORD *a2)
{
  if (!strcmp(a1, "prim") || !strcmp(a1, "primary"))
  {
    *a2 = 0;
    return 1;
  }
  else if (!strcmp(a1, "alt") || !strcmp(a1, "alternate"))
  {
    *a2 = 1;
    return 1;
  }
  else
  {
    return 0;
  }
}

uint64_t ETLEFS2CreateSyncNoWaitCommand(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a3)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2CreateSyncNoWaitCommand", (uint64_t)"invalid arguments:  frame = %p, path = %p\n", (uint64_t)a3, a4, a5, a6, a7, a8, a1);
    return 0;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    uint64_t v38 = FreeSpace;
    uint64_t v16 = "Free space %u not enough for %zu\n";
  }
  else
  {
    if (HDLCFrameInject()) {
      goto LABEL_9;
    }
    uint64_t v16 = "Failed to inject\n";
  }
  _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)v16, v10, v11, v12, v13, v14, v15, v38);
LABEL_9:
  uint64_t v17 = strlen(a3) + 3;
  if (HDLCFrameGetFreeSpace() >= v17)
  {
    if (HDLCFrameInjectUnsignedShort())
    {
      if (HDLCFrameInject()) {
        return 1;
      }
      long long v37 = "failed adding path to HDLC frame\n";
    }
    else
    {
      long long v37 = "failed adding sequenceNumber to HDLC frame\n";
    }
    _ETLDebugPrint((uint64_t)"ETLEFS2CreateSyncNoWaitCommand", (uint64_t)v37, v30, v31, v32, v33, v34, v35, v38);
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v18, v19, v20, v21, v22, v23, v17);
    _ETLDebugPrint((uint64_t)"ETLEFS2CreateSyncNoWaitCommand", (uint64_t)"Needed %u bytes, but not enough free space\n", v24, v25, v26, v27, v28, v29, v17);
  }
  return 0;
}

uint64_t ETLEFS2ParseSyncNoWaitResponse(uint64_t a1, _WORD *a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a4 = 0xFFFF;
  if (!a1 || !a2 || !a3)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseSyncNoWaitResponse", (uint64_t)"invalid arguments:  frame = %p, sequenceNumber = %p, syncToken = %p, resposneErrno = %p\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, a1);
    return 0;
  }
  unsigned int v8 = *(_DWORD *)(a1 + 8);
  unsigned int v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, *(unsigned int *)(a1 + 8));
LABEL_23:
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseSyncNoWaitResponse", (uint64_t)"failed parsing header\n", v16, v17, v18, v19, v20, v21, v22);
    return 0;
  }
  uint64_t v10 = *(unsigned int **)a1;
  unsigned int v11 = **(_DWORD **)a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, **(_DWORD **)a1);
    goto LABEL_23;
  }
  if (BYTE1(v11) != 19)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseHeader", (uint64_t)"Subsys mismatch, expected 0x%x, got 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, 19);
    goto LABEL_22;
  }
  if (HIWORD(v11) != 48)
  {
LABEL_22:
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseHeader", (uint64_t)"Command code mismatch, expected 0x%x, got 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, 48);
    goto LABEL_23;
  }
  if (v9 <= 9)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseSyncNoWaitResponse", (uint64_t)"needed %u bytes, available %u\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, 10);
    return 0;
  }
  *a2 = *((_WORD *)v10 + 2);
  *a3 = *(unsigned int *)((char *)v10 + 6);
  int v12 = *(unsigned int *)((char *)v10 + 10);
  *a4 = v12;
  if (v12) {
    BOOL v13 = v12 == 306;
  }
  else {
    BOOL v13 = 1;
  }
  uint64_t v14 = v13;
  if (v12 && v12 != 306)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2ParseSyncNoWaitResponse", (uint64_t)"sync was not successful, errno %u\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, 0);
    return v14;
  }
  return v14;
}

uint64_t ETLEFS2SyncNoWait(void *a1, uint64_t a2, const char *a3, _DWORD *a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int16 v30 = 0;
  memset(v33, 0, sizeof(v33));
  uint64_t v34 = 0;
  memset(v31, 0, sizeof(v31));
  uint64_t v32 = 0;
  if (!a1 || !a3 || !a4 || !a5)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2SyncNoWait", (uint64_t)"invalid arguments:  transport = %p, path = %p, syncToken = %p, responseErrno = %p\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, (uint64_t)a1);
LABEL_27:
    uint64_t v26 = 0;
    goto LABEL_28;
  }
  *a5 = 0xFFFF;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v27 = "Failed to create command frame\n";
LABEL_26:
    _ETLDebugPrint((uint64_t)"ETLEFS2SyncNoWait", (uint64_t)v27, v14, v15, v16, v17, v18, v19, v29);
    goto LABEL_27;
  }
  if ((ETLEFS2CreateSyncNoWaitCommand((uint64_t)v33, a2, a3, v15, v16, v17, v18, v19) & 1) == 0)
  {
    uint64_t v27 = "failed to create EFS sync command\n";
    goto LABEL_26;
  }
  uint64_t v20 = malloc((2 * DWORD2(v33[0]) + 32));
  if (!v20)
  {
LABEL_25:
    uint64_t v27 = "failed to send EFS sync command\n";
    goto LABEL_26;
  }
  uint64_t v21 = v20;
  uint64_t v22 = HDLCFrameEncode();
  if (!v22) {
    goto LABEL_24;
  }
  uint64_t v23 = v22;
  int v35 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v21, v22);
  }
  if (!*a1)
  {
LABEL_24:
    free(v21);
    goto LABEL_25;
  }
  int v24 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v21, v23, &v35, 1, a6, 0);
  int v25 = v35;
  free(v21);
  if (!v24 || v25 != v23) {
    goto LABEL_25;
  }
  LOBYTE(v35) = 75;
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v31, (uint64_t)&_ETLResponseRingBuffer, &v35, a6)|| v35 != 75)
  {
    uint64_t v27 = "failed to find EFS sync command response\n";
    goto LABEL_26;
  }
  if ((ETLEFS2ParseSyncNoWaitResponse((uint64_t)v31, &v30, a4, a5, v16, v17, v18, v19) & 1) == 0)
  {
    uint64_t v27 = "failed parsing EFS sync response\n";
    goto LABEL_26;
  }
  if (v30 != a2)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2SyncNoWait", (uint64_t)"sequence number out of order, got %u, sent %u\n", v14, v15, v16, v17, v18, v19, v30);
    goto LABEL_27;
  }
  uint64_t v26 = 1;
LABEL_28:
  HDLCFrameFree();
  HDLCFrameFree();
  return v26;
}

uint64_t ETLEFS2Put(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, char *__s, uint64_t a6, unsigned int a7, _DWORD *a8, unsigned int a9)
{
  memset(v46, 0, sizeof(v46));
  uint64_t v47 = 0;
  memset(v44, 0, sizeof(v44));
  uint64_t v45 = 0;
  *a8 = 0xFFFF;
  strlen(__s);
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2Put", (uint64_t)"Failed to create command frame\n", v17, v18, v19, v20, v21, v22, v43);
    goto LABEL_22;
  }
  if (!ETLEFS2CreatePutCommand((uint64_t)v46, a2, a3, a4, __s, a6, a7)) {
    goto LABEL_22;
  }
  uint64_t v23 = malloc((2 * DWORD2(v46[0]) + 32));
  if (!v23) {
    goto LABEL_22;
  }
  int v24 = v23;
  uint64_t v25 = HDLCFrameEncode();
  if (!v25) {
    goto LABEL_24;
  }
  uint64_t v26 = v25;
  int v48 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v24, v25);
  }
  if (!*a1)
  {
LABEL_24:
    free(v24);
    goto LABEL_22;
  }
  int v27 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, void, void))*a1)(a1, v24, v26, &v48, 1, a9, 0);
  int v28 = v48;
  free(v24);
  if (v27) {
    BOOL v29 = v28 == v26;
  }
  else {
    BOOL v29 = 0;
  }
  if (!v29) {
    goto LABEL_22;
  }
  LOBYTE(v48) = 75;
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  int v30 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v44, (uint64_t)&_ETLResponseRingBuffer, &v48, a9);
  uint64_t v35 = 0;
  if (v30 && v48 == 75)
  {
    LOWORD(v48) = -21846;
    if (!ETLEFS2ParsePutResponse((int **)v44, a2, &v48, a8, v31, v32, v33, v34))
    {
LABEL_22:
      uint64_t v35 = 0;
      goto LABEL_23;
    }
    uint64_t v35 = 1;
    if ((unsigned __int16)v48 != a4 && a4 + 1 != (unsigned __int16)v48)
    {
      _ETLDebugPrint((uint64_t)"ETLEFS2Put", (uint64_t)"Sequence number out of order, got %u, sent %u\n", v36, v37, v38, v39, v40, v41, (unsigned __int16)v48);
      goto LABEL_22;
    }
  }
LABEL_23:
  HDLCFrameFree();
  HDLCFrameFree();
  return v35;
}

uint64_t ETLEFS2Get(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, uint64_t a3, char *__s, void *a5, unsigned int a6, unsigned int *a7, unsigned int *a8, unsigned int a9)
{
  unsigned int v54 = 0;
  if (ETLEFS2GetSize(a1, a2, __s, &v54, a7, a9))
  {
    size_t v23 = v54;
    if (v54)
    {
      memset(v52, 0, sizeof(v52));
      uint64_t v53 = 0;
      memset(v50, 0, sizeof(v50));
      uint64_t v51 = 0;
      *a7 = 0xFFFF;
      strlen(__s);
      if ((HDLCFrameCreateUplink() & 1) == 0) {
        _ETLDebugPrint((uint64_t)"ETLEFS2Get", (uint64_t)"Failed to create command frame\n", v24, v25, v26, v27, v28, v29, v45);
      }
      int v30 = calloc(v23, 1uLL);
      if (!v30)
      {
        uint64_t v32 = 0;
LABEL_29:
        HDLCFrameFree();
        HDLCFrameFree();
        return v32;
      }
      int __src = v30;
      if (ETLEFS2CreateGetCommand((uint64_t)v52, a2, a3, __s, v31, v23))
      {
        int v48 = a5;
        uint64_t v32 = (uint64_t)malloc((2 * DWORD2(v52[0]) + 32));
        if (!v32)
        {
LABEL_28:
          free(__src);
          goto LABEL_29;
        }
        uint64_t v33 = HDLCFrameEncode();
        if (!v33) {
          goto LABEL_26;
        }
        uint64_t v34 = v33;
        int v55 = -1431655766;
        if ((_ETLDebugFlags & 2) != 0) {
          ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v32, v33);
        }
        if (*a1)
        {
          int v47 = v34;
          int v35 = (*a1)(a1, (void *)v32, v34, &v55, 1, a9, 0);
          int v46 = v55;
          free((void *)v32);
          uint64_t v32 = 0;
          if (!v35 || v46 != v47) {
            goto LABEL_28;
          }
          LOBYTE(v55) = 75;
          if (!_ETLResponseRingBuffer) {
            TelephonyUtilRingBufferInitialize();
          }
          uint64_t v32 = 0;
          if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v50, (uint64_t)&_ETLResponseRingBuffer, &v55, a9)|| v55 != 75)
          {
            goto LABEL_28;
          }
          LOWORD(v55) = -21846;
          if (ETLEFS2ParseGetResponse((int **)v50, a2, __src, v23, &v55, a7, a8, v36))
          {
            if ((unsigned __int16)v55 == a3 || a3 + 1 == (unsigned __int16)v55)
            {
              if (*a8 >= a6) {
                size_t v44 = a6;
              }
              else {
                size_t v44 = *a8;
              }
              *a8 = v44;
              memcpy(v48, __src, v44);
              uint64_t v32 = 1;
              goto LABEL_28;
            }
            _ETLDebugPrint((uint64_t)"ETLEFS2Get", (uint64_t)"Sequence number out of order, got %u, sent %u\n", v37, v38, v39, v40, v41, v42, (unsigned __int16)v55);
          }
        }
        else
        {
LABEL_26:
          free((void *)v32);
        }
      }
      uint64_t v32 = 0;
      goto LABEL_28;
    }
    _ETLDebugPrint((uint64_t)"ETLEFS2Get", (uint64_t)"NV file size is ZERO\n", v17, v18, v19, v20, v21, v22, v45);
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLEFS2Get", (uint64_t)"Failed to get size of NV item. Error [%d]\n", v17, v18, v19, v20, v21, v22, *a7);
  }
  return 0;
}

uint64_t ETLEFS2GetSize(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), int a2, char *__s, _DWORD *a4, _DWORD *a5, uint64_t a6)
{
  long long v52 = 0u;
  long long v53 = 0u;
  uint64_t v54 = 0;
  memset(v50, 0, sizeof(v50));
  uint64_t v51 = 0;
  *a5 = 0xFFFF;
  strlen(__s);
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v39 = "ETLEFS2GetSize";
    uint64_t v40 = "Failed to create command frame\n";
LABEL_12:
    _ETLDebugPrint((uint64_t)v39, (uint64_t)v40, v12, v13, v14, v15, v16, v17, v49);
    goto LABEL_13;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v19, v20, v21, v22, v23, v24, FreeSpace);
    goto LABEL_13;
  }
  LOBYTE(v55) = 75;
  if (a2) {
    char v25 = 62;
  }
  else {
    char v25 = 19;
  }
  BYTE1(v55) = v25;
  HIWORD(v55) = 15;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v39 = "ETLSubsysAddHeaderInternal";
    uint64_t v40 = "Failed to inject\n";
    goto LABEL_12;
  }
  uint64_t v26 = strlen(__s) + 1;
  if (HDLCFrameGetFreeSpace() >= v26)
  {
    if (HDLCFrameInject())
    {
      uint64_t v43 = malloc((2 * DWORD2(v52) + 32));
      if (v43)
      {
        size_t v44 = v43;
        uint64_t v45 = HDLCFrameEncode();
        if (!v45) {
          goto LABEL_29;
        }
        uint64_t v46 = v45;
        int v55 = -1431655766;
        if ((_ETLDebugFlags & 2) != 0) {
          ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v44, v45);
        }
        if (*a1)
        {
          int v47 = (*a1)(a1, v44, v46, &v55, 1, a6, 0);
          int v48 = v55;
          free(v44);
          if (v47 && v48 == v46)
          {
            LOBYTE(v55) = 75;
            if (!_ETLResponseRingBuffer) {
              TelephonyUtilRingBufferInitialize();
            }
            if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v50, (uint64_t)&_ETLResponseRingBuffer, &v55, a6)&& v55 == 75&& ETLEFS2ParseStatResponse((int **)v50, a2, a5, a4, v35, v36, v37, v38))
            {
              _ETLDebugPrint((uint64_t)"ETLEFS2GetSize", (uint64_t)"NV item [%s] is of size [%d]\n", v33, v34, v35, v36, v37, v38, (uint64_t)__s);
              uint64_t v41 = 1;
              goto LABEL_14;
            }
          }
        }
        else
        {
LABEL_29:
          free(v44);
        }
      }
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v27, v28, v29, v30, v31, v32, v26);
  }
LABEL_13:
  _ETLDebugPrint((uint64_t)"ETLEFS2GetSize", (uint64_t)"Failed to get size of NV item [%s]\n", v33, v34, v35, v36, v37, v38, (uint64_t)__s);
  uint64_t v41 = 0;
LABEL_14:
  HDLCFrameFree();
  HDLCFrameFree();
  return v41;
}

uint64_t APPLIB_DIAG_AUDIO_PCM_14Bit_Start_Loopback(char *a1, int a2)
{
  int v3 = 458315;
  __int16 v4 = 1;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

uint64_t APPLIB_DIAG_AUDIO_PCM_14Bit_Stop_Loopback(char *a1, int a2)
{
  int v3 = 458315;
  __int16 v4 = 2;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

uint64_t APPLIB_DIAG_AUDIO_PCM_16Bit_Start_Loopback(char *a1, int a2)
{
  int v3 = 458315;
  __int16 v4 = 3;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

uint64_t APPLIB_DIAG_AUDIO_PCM_16Bit_Stop_Loopback(char *a1, int a2)
{
  int v3 = 458315;
  __int16 v4 = 4;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

uint64_t APPLIB_DIAG_AUDIO_I2S_Start_Loopback(char *a1, int a2)
{
  int v3 = 458315;
  __int16 v4 = 5;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

uint64_t APPLIB_DIAG_AUDIO_I2S_Stop_Loopback(char *a1, int a2)
{
  int v3 = 458315;
  __int16 v4 = 6;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

uint64_t APPLIB_DIAG_AUDIO_PCM_I2S_PASSTHROUGH_Start(char *a1, int a2)
{
  int v3 = 458315;
  __int16 v4 = 7;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

uint64_t APPLIB_DIAG_AUDIO_PCM_I2S_PASSTHROUGH_Stop(char *a1, int a2)
{
  int v3 = 458315;
  __int16 v4 = 8;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

uint64_t APPLIB_DIAG_AUDIO_I2S_PCM_PASSTHROUGH_Start(char *a1, int a2)
{
  int v3 = 458315;
  __int16 v4 = 9;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

uint64_t APPLIB_DIAG_AUDIO_I2S_PCM_PASSTHROUGH_Stop(char *a1, int a2)
{
  int v3 = 458315;
  __int16 v4 = 10;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 6);
}

BOOL ETLDecompressCheck(unsigned __int8 **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((_DWORD *)a1 + 2) > 6u) {
    return **a1 == 155;
  }
  _ETLDebugPrint((uint64_t)"ETLDecompressCheck", (uint64_t)"Error: Given frame size(%u) is less than the decompress header(%u)!\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
  return 0;
}

uint64_t ETLDecompress(uint64_t *a1, char *__dst, unint64_t a3, uint64_t *a4, BOOL *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a4 = 0;
  uint64_t v8 = *a1;
  *a5 = *(unsigned char *)(*a1 + 3) != 0;
  if (*(unsigned char *)(v8 + 4))
  {
    unsigned int v9 = "Error: ZIP compress type is not supported yet.\n";
LABEL_3:
    _ETLDebugPrint((uint64_t)"ETLDecompress", (uint64_t)v9, a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v13);
    return 0;
  }
  uint64_t v12 = lz4_decode(__dst, a3, (unsigned __int8 *)(v8 + 7), *(unsigned __int16 *)(v8 + 1));
  *a4 = v12;
  if (!v12)
  {
    unsigned int v9 = "Error: Decoded size is none.\n";
    goto LABEL_3;
  }
  return 1;
}

uint64_t ETLDecompressProcessNonHDLCData(uint64_t a1, unint64_t a2, void *a3, void *a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 > 3)
  {
    if (*(unsigned char *)a1 == 126)
    {
      if (*(unsigned char *)(a1 + 1) == 126)
      {
        _ETLDebugPrint((uint64_t)"ETLDecompressProcessNonHDLCData", (uint64_t)"Error: Consecutive data should not contain the flag (0x%x).\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, 126);
        return 0;
      }
      else
      {
        uint64_t v9 = *(unsigned __int16 *)(a1 + 2);
        *a4 = v9;
        *a3 = a1 + 4;
        *a5 = v9 + 5;
        return 1;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLDecompressProcessNonHDLCData", (uint64_t)"Error: Non HDLC Compressed Data expect start code of (0x%x), but it contains 0x%x.\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, 126);
      return 0;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLDecompressProcessNonHDLCData", (uint64_t)"Error: Given buffer size is less than the size of the header\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v10);
    return 0;
  }
}

uint64_t ETLSubsysAddHeader()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLSubsysParseHeader(uint64_t a1, _WORD *a2, _WORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a4;
  uint64_t v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    int v10 = *(_DWORD *)(*(void *)a1 + v8);
    if (v10 == 75)
    {
      *a2 = BYTE1(v10);
      *a3 = HIWORD(v10);
      *a4 = v8 + 4;
      return 1;
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, v10);
      return 0;
    }
  }
}

uint64_t ETLSubsys2AddHeader()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLSubsys2ParseHeader(uint64_t *a1, _WORD *a2, _WORD *a3, _DWORD *a4, _WORD *a5, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a6;
  uint64_t v9 = (*((_DWORD *)a1 + 2) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, v9);
    return 0;
  }
  else
  {
    uint64_t v10 = *a1;
    int v11 = *(_DWORD *)(*a1 + v8);
    if (v11 == 128)
    {
      *a2 = BYTE1(v11);
      *a3 = HIWORD(v11);
      *a6 = v8 + 4;
      if ((*((_DWORD *)a1 + 2) - (v8 + 4)) <= 5)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsys2ParseHeader", (uint64_t)"Need %u bytes, only have %u\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, 6);
        return 0;
      }
      else
      {
        uint64_t v12 = v10 + (v8 + 4);
        *a6 = v8 + 10;
        *a4 = *(_DWORD *)v12;
        *a5 = *(_WORD *)(v12 + 4);
        return 1;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, v11);
      return 0;
    }
  }
}

uint64_t ETLSubsysFindMatchingResponse(uint64_t a1, unsigned __int8 **a2, unsigned int a3)
{
  char v7 = 75;
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  LODWORD(result) = ETLFindMatchingResponseUsingBuffer(a1, a2, (uint64_t)&_ETLResponseRingBuffer, &v7, a3);
  if (v7 == 75) {
    return result;
  }
  else {
    return 0;
  }
}

uint64_t ETLSubsys2FindMatchingResponse(uint64_t a1, unsigned __int8 **a2, unsigned int a3)
{
  unsigned __int8 v7 = 0x80;
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  LODWORD(result) = ETLFindMatchingResponseUsingBuffer(a1, a2, (uint64_t)&_ETLResponseRingBuffer, &v7, a3);
  if (v7 == 128) {
    return result;
  }
  else {
    return 0;
  }
}

BOOL ETLHDLCFrameCheckFreeSpace(uint64_t a1, unsigned int a2)
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  unsigned int v10 = FreeSpace;
  if (FreeSpace < a2) {
    _ETLDebugPrint((uint64_t)"ETLHDLCFrameCheckFreeSpace", (uint64_t)"Remaining %u not enough %u\n", v4, v5, v6, v7, v8, v9, FreeSpace);
  }
  return v10 >= a2;
}

BOOL ETLHDLCFrameCheckRemainedSize(uint64_t a1, unsigned int a2, void *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a4;
  unsigned int v10 = *(_DWORD *)(a1 + 8) - v9;
  if (v10 < a2)
  {
    _ETLDebugPrint((uint64_t)"ETLHDLCFrameCheckRemainedSize", (uint64_t)"Payload length %u less than needed %u\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (*(_DWORD *)(a1 + 8) - v9));
    return v10 >= a2;
  }
  else
  {
    *a3 = *(void *)a1 + v9;
    *a4 = v9 + a2;
    return v10 >= a2;
  }
}

uint64_t ETLFrameCreateDownlink()
{
  return HDLCFrameCreateDownlink();
}

uint64_t ETLFrameCreateUplink()
{
  return HDLCFrameCreateUplink();
}

uint64_t ETLFrameEncode()
{
  return HDLCFrameEncode();
}

uint64_t ETLFrameEncodeAndCache()
{
  return HDLCFrameEncodeAndCache();
}

uint64_t ETLFrameReadFromTransport(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  while (1)
  {
    while (TelephonyUtilRingBufferGetSize())
    {
      TelephonyUtilRingBufferGetSize();
      char Downlink = HDLCFrameCreateDownlink();
      TelephonyUtilRingBufferSkip();
      if (Downlink) {
        return 1;
      }
    }
    if ((int)TelephonyUtilRingBufferInsertTransport() < 1) {
      break;
    }
    TelephonyUtilRingBufferLinearize();
  }
  return 0;
}

uint64_t APPLIB_LOG_DISABLE(unsigned __int8 *a1, int a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x10)
  {
    bzero(a1, a2);
    *a1 = 115;
    *((_DWORD *)a1 + 1) = 0;
    uint64_t v5 = a1[1];
    unsigned __int16 v6 = crc_16_l_table[v5 ^ 0x9B];
    int v7 = a1[2];
    unsigned int v8 = crc_16_l_table[(v7 ^ v6) ^ 0x4E];
    int v9 = a1[3];
    unsigned int v10 = crc_16_l_table[(v9 ^ v8 ^ HIBYTE(v6))];
    unsigned int v11 = crc_16_l_table[v10 ^ (v8 >> 8)];
    unsigned int v12 = crc_16_l_table[v11 ^ (v10 >> 8)];
    unsigned int v13 = crc_16_l_table[v12 ^ (v11 >> 8)];
    int v14 = crc_16_l_table[crc_16_l_table[v12 ^ (v11 >> 8)] ^ (v12 >> 8)];
    int v15 = v14 ^ ~(v13 >> 8);
    *((_WORD *)a1 + 4) = v14 ^ ~HIBYTE(crc_16_l_table[v12 ^ (v11 >> 8)]);
    if (a2 >= 20)
    {
      bzero(v25, 0x7FFuLL);
      char __src = 115;
      if ((v5 - 125) > 1)
      {
        unsigned int v16 = 1;
      }
      else
      {
        v25[0] = 125;
        LOBYTE(v5) = v5 ^ 0x20;
        unsigned int v16 = 2;
      }
      v25[v16 - 1] = v5;
      uint64_t v17 = v16 + 1;
      if ((v7 - 125) <= 1)
      {
        v25[v17 - 1] = 125;
        LODWORD(v17) = v16 + 2;
        LOBYTE(v7) = v7 ^ 0x20;
      }
      int v18 = ~(v14 ^ BYTE1(v13));
      v25[v17 - 1] = v7;
      uint64_t v19 = v17 + 1;
      if ((v9 - 125) <= 1)
      {
        v25[v19 - 1] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v19) = v17 + 2;
      }
      char v20 = (unsigned __int16)(v14 ^ ~(unsigned __int16)(v13 >> 8)) >> 8;
      uint64_t v21 = &v25[v19 - 1];
      char *v21 = v9;
      *(_DWORD *)(v21 + 1) = 0;
      uint64_t v22 = v19 + 5;
      if ((v18 - 125) <= 1)
      {
        v25[v22 - 1] = 125;
        LOBYTE(v18) = v18 ^ 0x20;
        LODWORD(v22) = v19 + 6;
      }
      v25[v22 - 1] = v18;
      uint64_t v23 = v22 + 1;
      if (BYTE1(v15) - 125 <= 1)
      {
        v25[v23 - 1] = 125;
        char v20 = BYTE1(v15) ^ 0x20;
        LODWORD(v23) = v22 + 2;
      }
      v25[v23 - 1] = v20;
      memcpy(a1, &__src, v23 + 1);
      uint64_t result = (v23 + 2);
      a1[v23 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_FTM_LOG_ENABLE(unsigned __int8 *a1, int a2, __int16 a3, int a4, int a5)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x1F)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 592715;
    *((_WORD *)a1 + 5) = a3;
    *((_DWORD *)a1 + 3) = a4;
    *((_DWORD *)a1 + 4) = a5;
    unsigned __int16 v11 = crc_16_l_table[a1[4] ^ 0x3DLL];
    unsigned __int16 v12 = crc_16_l_table[a1[5] ^ 0x2B ^ v11];
    unsigned __int16 v13 = crc_16_l_table[(a1[6] ^ v12 ^ HIBYTE(v11))];
    unsigned __int16 v14 = crc_16_l_table[(a1[7] ^ v13 ^ HIBYTE(v12))];
    unsigned __int16 v15 = crc_16_l_table[(a1[8] ^ v14 ^ HIBYTE(v13))];
    unsigned __int16 v16 = crc_16_l_table[(a1[9] ^ v15 ^ HIBYTE(v14))];
    unsigned __int16 v17 = crc_16_l_table[(a3 ^ v16 ^ HIBYTE(v15))];
    unsigned __int16 v18 = crc_16_l_table[(HIBYTE(a3) ^ v17 ^ HIBYTE(v16))];
    unsigned __int16 v19 = crc_16_l_table[(a4 ^ v18 ^ HIBYTE(v17))];
    unsigned __int16 v20 = crc_16_l_table[(a1[13] ^ v19 ^ HIBYTE(v18))];
    unsigned __int16 v21 = crc_16_l_table[(a1[14] ^ v20 ^ HIBYTE(v19))];
    unsigned __int16 v22 = crc_16_l_table[(a1[15] ^ v21 ^ HIBYTE(v20))];
    unsigned __int16 v23 = crc_16_l_table[(a5 ^ v22 ^ HIBYTE(v21))];
    unsigned __int16 v24 = crc_16_l_table[(a1[17] ^ v23 ^ HIBYTE(v22))];
    unsigned int v25 = crc_16_l_table[(a1[18] ^ v24 ^ HIBYTE(v23))];
    unsigned __int16 v26 = crc_16_l_table[(a1[19] ^ v25 ^ HIBYTE(v24))];
    *((_WORD *)a1 + 10) = v26 ^ ~HIBYTE(crc_16_l_table[(a1[18] ^ v24 ^ HIBYTE(v23))]);
    if (a2 >= 44)
    {
      bzero(__src, 0x800uLL);
      int v27 = *a1;
      if ((v27 - 125) > 1)
      {
        unsigned int v28 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v27) = v27 ^ 0x20;
        unsigned int v28 = 1;
      }
      __src[v28] = v27;
      uint64_t v29 = v28 + 1;
      int v30 = a1[1];
      if ((v30 - 125) <= 1)
      {
        __src[v29] = 125;
        LODWORD(v29) = v28 | 2;
        LOBYTE(v30) = v30 ^ 0x20;
      }
      __src[v29] = v30;
      uint64_t v31 = v29 + 1;
      int v32 = a1[2];
      if ((v32 - 125) <= 1)
      {
        __src[v31] = 125;
        LOBYTE(v32) = v32 ^ 0x20;
        LODWORD(v31) = v29 + 2;
      }
      __src[v31] = v32;
      uint64_t v33 = v31 + 1;
      int v34 = a1[3];
      if ((v34 - 125) <= 1)
      {
        __src[v33] = 125;
        LODWORD(v33) = v31 + 2;
        LOBYTE(v34) = v34 ^ 0x20;
      }
      __src[v33] = v34;
      uint64_t v35 = v33 + 1;
      int v36 = a1[4];
      if ((v36 - 125) <= 1)
      {
        __src[v35] = 125;
        LOBYTE(v36) = v36 ^ 0x20;
        LODWORD(v35) = v33 + 2;
      }
      __src[v35] = v36;
      uint64_t v37 = v35 + 1;
      int v38 = a1[5];
      if ((v38 - 125) <= 1)
      {
        __src[v37] = 125;
        LODWORD(v37) = v35 + 2;
        LOBYTE(v38) = v38 ^ 0x20;
      }
      __src[v37] = v38;
      uint64_t v39 = v37 + 1;
      int v40 = a1[6];
      if ((v40 - 125) <= 1)
      {
        __src[v39] = 125;
        LOBYTE(v40) = v40 ^ 0x20;
        LODWORD(v39) = v37 + 2;
      }
      __src[v39] = v40;
      uint64_t v41 = v39 + 1;
      int v42 = a1[7];
      if ((v42 - 125) <= 1)
      {
        __src[v41] = 125;
        LODWORD(v41) = v39 + 2;
        LOBYTE(v42) = v42 ^ 0x20;
      }
      __src[v41] = v42;
      uint64_t v43 = v41 + 1;
      int v44 = a1[8];
      if ((v44 - 125) <= 1)
      {
        __src[v43] = 125;
        LOBYTE(v44) = v44 ^ 0x20;
        LODWORD(v43) = v41 + 2;
      }
      __src[v43] = v44;
      uint64_t v45 = v43 + 1;
      int v46 = a1[9];
      if ((v46 - 125) <= 1)
      {
        __src[v45] = 125;
        LODWORD(v45) = v43 + 2;
        LOBYTE(v46) = v46 ^ 0x20;
      }
      __src[v45] = v46;
      uint64_t v47 = v45 + 1;
      int v48 = a1[10];
      if ((v48 - 125) <= 1)
      {
        __src[v47] = 125;
        LOBYTE(v48) = v48 ^ 0x20;
        LODWORD(v47) = v45 + 2;
      }
      __src[v47] = v48;
      uint64_t v49 = v47 + 1;
      int v50 = a1[11];
      if ((v50 - 125) <= 1)
      {
        __src[v49] = 125;
        LODWORD(v49) = v47 + 2;
        LOBYTE(v50) = v50 ^ 0x20;
      }
      __src[v49] = v50;
      uint64_t v51 = v49 + 1;
      int v52 = a1[12];
      if ((v52 - 125) <= 1)
      {
        __src[v51] = 125;
        LOBYTE(v52) = v52 ^ 0x20;
        LODWORD(v51) = v49 + 2;
      }
      __src[v51] = v52;
      uint64_t v53 = v51 + 1;
      int v54 = a1[13];
      if ((v54 - 125) <= 1)
      {
        __src[v53] = 125;
        LODWORD(v53) = v51 + 2;
        LOBYTE(v54) = v54 ^ 0x20;
      }
      __src[v53] = v54;
      uint64_t v55 = v53 + 1;
      int v56 = a1[14];
      if ((v56 - 125) <= 1)
      {
        __src[v55] = 125;
        LOBYTE(v56) = v56 ^ 0x20;
        LODWORD(v55) = v53 + 2;
      }
      __src[v55] = v56;
      uint64_t v57 = v55 + 1;
      int v58 = a1[15];
      if ((v58 - 125) <= 1)
      {
        __src[v57] = 125;
        LODWORD(v57) = v55 + 2;
        LOBYTE(v58) = v58 ^ 0x20;
      }
      __src[v57] = v58;
      uint64_t v59 = v57 + 1;
      int v60 = a1[16];
      if ((v60 - 125) <= 1)
      {
        __src[v59] = 125;
        LOBYTE(v60) = v60 ^ 0x20;
        LODWORD(v59) = v57 + 2;
      }
      __src[v59] = v60;
      uint64_t v61 = v59 + 1;
      int v62 = a1[17];
      if ((v62 - 125) <= 1)
      {
        __src[v61] = 125;
        LODWORD(v61) = v59 + 2;
        LOBYTE(v62) = v62 ^ 0x20;
      }
      __src[v61] = v62;
      uint64_t v63 = v61 + 1;
      int v64 = a1[18];
      if ((v64 - 125) <= 1)
      {
        __src[v63] = 125;
        LOBYTE(v64) = v64 ^ 0x20;
        LODWORD(v63) = v61 + 2;
      }
      int v65 = ~(v26 ^ BYTE1(v25));
      __src[v63] = v64;
      uint64_t v66 = v63 + 1;
      int v67 = a1[19];
      if ((v67 - 125) <= 1)
      {
        __src[v66] = 125;
        LOBYTE(v67) = v67 ^ 0x20;
        LODWORD(v66) = v63 + 2;
      }
      int v68 = ((unsigned __int16)(v26 ^ ~(unsigned __int16)(v25 >> 8)) >> 8);
      __src[v66] = v67;
      uint64_t v69 = v66 + 1;
      if ((v65 - 125) <= 1)
      {
        __src[v69] = 125;
        LOBYTE(v65) = v65 ^ 0x20;
        LODWORD(v69) = v66 + 2;
      }
      __src[v69] = v65;
      uint64_t v70 = v69 + 1;
      if ((v68 - 125) <= 1)
      {
        __src[v70] = 125;
        LOBYTE(v68) = v68 ^ 0x20;
        LODWORD(v70) = v69 + 2;
      }
      __src[v70] = v68;
      memcpy(a1, __src, v70 + 1);
      uint64_t result = (v70 + 2);
      a1[v70 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_FTM_LOG_DISABLE(unsigned __int8 *a1, int a2, __int16 a3)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0x1F) {
    return result;
  }
  bzero(a1, a2);
  *(_DWORD *)a1 = 592715;
  a1[4] = 1;
  *((_WORD *)a1 + 5) = a3;
  char v7 = HIBYTE(a3);
  uint64_t v8 = a1[5];
  unsigned __int16 v9 = crc_16_l_table[v8 ^ 0xC4];
  int v10 = a1[6];
  unsigned __int16 v11 = crc_16_l_table[(v10 ^ v9) ^ 0xFB];
  unsigned __int16 v12 = crc_16_l_table[(a1[7] ^ v11 ^ HIBYTE(v9))];
  unsigned __int16 v13 = crc_16_l_table[(a1[8] ^ v12 ^ HIBYTE(v11))];
  unsigned int v14 = crc_16_l_table[(a1[9] ^ v13 ^ HIBYTE(v12))];
  unsigned int v15 = crc_16_l_table[(a3 ^ v14 ^ HIBYTE(v13))];
  int v16 = crc_16_l_table[HIBYTE(a3) ^ crc_16_l_table[(a3 ^ v14 ^ HIBYTE(v13))] ^ (v14 >> 8)];
  int v17 = v16 ^ ~(v15 >> 8);
  *((_WORD *)a1 + 6) = v16 ^ ~HIBYTE(crc_16_l_table[(a3 ^ v14 ^ HIBYTE(v13))]);
  if (a2 < 28) {
    return 0xFFFFFFFFLL;
  }
  bzero(v35, 0x7FBuLL);
  int __src = 592715;
  char v34 = 1;
  if ((v8 - 125) <= 1)
  {
    v35[0] = 125;
    int v18 = 6;
    v35[1] = v8 ^ 0x20;
    uint64_t v19 = 7;
    if ((v10 - 125) > 1) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v18 = 5;
  v35[0] = v8;
  uint64_t v19 = 6;
  if ((v10 - 125) <= 1)
  {
LABEL_9:
    *((unsigned char *)&__src + v19) = 125;
    LODWORD(v19) = v18 + 2;
    LOBYTE(v10) = v10 ^ 0x20;
  }
LABEL_10:
  *((unsigned char *)&__src + v19) = v10;
  uint64_t v20 = v19 + 1;
  int v21 = a1[7];
  if ((v21 - 125) <= 1)
  {
    *((unsigned char *)&__src + v20) = 125;
    LOBYTE(v21) = v21 ^ 0x20;
    LODWORD(v20) = v19 + 2;
  }
  *((unsigned char *)&__src + v20) = v21;
  uint64_t v22 = v20 + 1;
  int v23 = a1[8];
  if ((v23 - 125) <= 1)
  {
    *((unsigned char *)&__src + v22) = 125;
    LOBYTE(v23) = v23 ^ 0x20;
    LODWORD(v22) = v20 + 2;
  }
  char v24 = a3;
  *((unsigned char *)&__src + v22) = v23;
  uint64_t v25 = v22 + 1;
  int v26 = a1[9];
  if ((v26 - 125) <= 1)
  {
    *((unsigned char *)&__src + v25) = 125;
    LOBYTE(v26) = v26 ^ 0x20;
    LODWORD(v25) = v22 + 2;
  }
  *((unsigned char *)&__src + v25) = v26;
  uint64_t v27 = v25 + 1;
  if (a3 - 125 <= 1)
  {
    *((unsigned char *)&__src + v27) = 125;
    char v24 = a3 ^ 0x20;
    LODWORD(v27) = v25 + 2;
  }
  int v28 = ~(v16 ^ BYTE1(v15));
  *((unsigned char *)&__src + v27) = v24;
  uint64_t v29 = v27 + 1;
  if (HIBYTE(a3) - 125 <= 1)
  {
    *((unsigned char *)&__src + v29) = 125;
    char v7 = HIBYTE(a3) ^ 0x20;
    LODWORD(v29) = v27 + 2;
  }
  char v30 = (unsigned __int16)(v16 ^ ~(unsigned __int16)(v15 >> 8)) >> 8;
  *((unsigned char *)&__src + v29) = v7;
  uint64_t v31 = v29 + 1;
  if ((v28 - 125) <= 1)
  {
    *((unsigned char *)&__src + v31) = 125;
    LOBYTE(v28) = v28 ^ 0x20;
    LODWORD(v31) = v29 + 2;
  }
  *((unsigned char *)&__src + v31) = v28;
  uint64_t v32 = v31 + 1;
  if (BYTE1(v17) - 125 <= 1)
  {
    *((unsigned char *)&__src + v32) = 125;
    char v30 = BYTE1(v17) ^ 0x20;
    LODWORD(v32) = v31 + 2;
  }
  *((unsigned char *)&__src + v32) = v30;
  memcpy(a1, &__src, v32 + 1);
  uint64_t result = (v32 + 2);
  a1[v32 + 1] = 126;
  return result;
}

uint64_t APPLIB_LOG_GetIds(unsigned __int8 *a1, int a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x10)
  {
    bzero(a1, a2);
    *a1 = 115;
    *((_DWORD *)a1 + 1) = 1;
    uint64_t v5 = a1[1];
    unsigned __int16 v6 = crc_16_l_table[v5 ^ 0x9B];
    int v7 = a1[2];
    unsigned int v8 = crc_16_l_table[(v7 ^ v6) ^ 0x4E];
    int v9 = a1[3];
    unsigned int v10 = crc_16_l_table[(v9 ^ v8 ^ HIBYTE(v6))];
    unsigned int v11 = crc_16_l_table[v10 ^ (v8 >> 8) ^ 1];
    unsigned int v12 = crc_16_l_table[v11 ^ (v10 >> 8)];
    unsigned int v13 = crc_16_l_table[v12 ^ (v11 >> 8)];
    int v14 = crc_16_l_table[crc_16_l_table[v12 ^ (v11 >> 8)] ^ (v12 >> 8)];
    int v15 = v14 ^ ~(v13 >> 8);
    *((_WORD *)a1 + 4) = v14 ^ ~HIBYTE(crc_16_l_table[v12 ^ (v11 >> 8)]);
    if (a2 >= 20)
    {
      bzero(v25, 0x7FFuLL);
      char __src = 115;
      if ((v5 - 125) > 1)
      {
        unsigned int v16 = 1;
      }
      else
      {
        v25[0] = 125;
        LOBYTE(v5) = v5 ^ 0x20;
        unsigned int v16 = 2;
      }
      v25[v16 - 1] = v5;
      uint64_t v17 = v16 + 1;
      if ((v7 - 125) <= 1)
      {
        v25[v17 - 1] = 125;
        LODWORD(v17) = v16 + 2;
        LOBYTE(v7) = v7 ^ 0x20;
      }
      int v18 = ~(v14 ^ BYTE1(v13));
      v25[v17 - 1] = v7;
      uint64_t v19 = v17 + 1;
      if ((v9 - 125) <= 1)
      {
        v25[v19 - 1] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v19) = v17 + 2;
      }
      char v20 = (unsigned __int16)(v14 ^ ~(unsigned __int16)(v13 >> 8)) >> 8;
      int v21 = &v25[v19 - 1];
      char *v21 = v9;
      *(_DWORD *)(v21 + 1) = 1;
      uint64_t v22 = v19 + 5;
      if ((v18 - 125) <= 1)
      {
        v25[v22 - 1] = 125;
        LOBYTE(v18) = v18 ^ 0x20;
        LODWORD(v22) = v19 + 6;
      }
      v25[v22 - 1] = v18;
      uint64_t v23 = v22 + 1;
      if (BYTE1(v15) - 125 <= 1)
      {
        v25[v23 - 1] = 125;
        char v20 = BYTE1(v15) ^ 0x20;
        LODWORD(v23) = v22 + 2;
      }
      v25[v23 - 1] = v20;
      memcpy(a1, &__src, v23 + 1);
      uint64_t result = (v23 + 2);
      a1[v23 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_LOG_GetMasks(unsigned __int8 *a1, int a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x10)
  {
    bzero(a1, a2);
    *a1 = 115;
    *((_DWORD *)a1 + 1) = 4;
    uint64_t v5 = a1[1];
    unsigned __int16 v6 = crc_16_l_table[v5 ^ 0x9B];
    int v7 = a1[2];
    unsigned int v8 = crc_16_l_table[(v7 ^ v6) ^ 0x4E];
    int v9 = a1[3];
    unsigned int v10 = crc_16_l_table[(v9 ^ v8 ^ HIBYTE(v6))];
    unsigned int v11 = crc_16_l_table[v10 ^ (v8 >> 8) ^ 4];
    unsigned int v12 = crc_16_l_table[v11 ^ (v10 >> 8)];
    unsigned int v13 = crc_16_l_table[v12 ^ (v11 >> 8)];
    int v14 = crc_16_l_table[crc_16_l_table[v12 ^ (v11 >> 8)] ^ (v12 >> 8)];
    int v15 = v14 ^ ~(v13 >> 8);
    *((_WORD *)a1 + 4) = v14 ^ ~HIBYTE(crc_16_l_table[v12 ^ (v11 >> 8)]);
    if (a2 >= 20)
    {
      bzero(v25, 0x7FFuLL);
      char __src = 115;
      if ((v5 - 125) > 1)
      {
        unsigned int v16 = 1;
      }
      else
      {
        v25[0] = 125;
        LOBYTE(v5) = v5 ^ 0x20;
        unsigned int v16 = 2;
      }
      v25[v16 - 1] = v5;
      uint64_t v17 = v16 + 1;
      if ((v7 - 125) <= 1)
      {
        v25[v17 - 1] = 125;
        LODWORD(v17) = v16 + 2;
        LOBYTE(v7) = v7 ^ 0x20;
      }
      int v18 = ~(v14 ^ BYTE1(v13));
      v25[v17 - 1] = v7;
      uint64_t v19 = v17 + 1;
      if ((v9 - 125) <= 1)
      {
        v25[v19 - 1] = 125;
        LOBYTE(v9) = v9 ^ 0x20;
        LODWORD(v19) = v17 + 2;
      }
      char v20 = (unsigned __int16)(v14 ^ ~(unsigned __int16)(v13 >> 8)) >> 8;
      int v21 = &v25[v19 - 1];
      char *v21 = v9;
      *(_DWORD *)(v21 + 1) = 4;
      uint64_t v22 = v19 + 5;
      if ((v18 - 125) <= 1)
      {
        v25[v22 - 1] = 125;
        LOBYTE(v18) = v18 ^ 0x20;
        LODWORD(v22) = v19 + 6;
      }
      v25[v22 - 1] = v18;
      uint64_t v23 = v22 + 1;
      if (BYTE1(v15) - 125 <= 1)
      {
        v25[v23 - 1] = 125;
        char v20 = BYTE1(v15) ^ 0x20;
        LODWORD(v23) = v22 + 2;
      }
      v25[v23 - 1] = v20;
      memcpy(a1, &__src, v23 + 1);
      uint64_t result = (v23 + 2);
      a1[v23 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_LOG_SetMasks(char *a1, int a2, unsigned int a3, unint64_t a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x10)
  {
    bzero(a1, a2);
    *a1 = 115;
    *((_DWORD *)a1 + 1) = 3;
    *((_DWORD *)a1 + 2) = a4 >> 12;
    *((_DWORD *)a1 + 3) = a3;
    if (a3 >= 8)
    {
      uint64_t v13 = a3 >> 3;
      uint64_t v14 = (a4 >> 3) & 0x1FF;
      do
      {
        if (!v14) {
          a1[((a4 >> 3) & 0x1FF) + 16] = 1 << (a4 & 7);
        }
        --v14;
        --v13;
      }
      while (v13);
    }
    int v9 = 1336;
    LOWORD(v10) = -1;
    unsigned int v11 = a1;
    do
    {
      char v12 = *v11++;
      int v10 = crc_16_l_table[(v12 ^ v10)] ^ ((unsigned __int16)(v10 & 0xFF00) >> 8);
      v9 -= 8;
    }
    while ((_WORD)v9);
    *(_WORD *)(a1 + 167) = ~(_WORD)v10;
    if (a2 >= 338)
    {
      bzero(__src, 0x800uLL);
      uint64_t v15 = 0;
      LODWORD(v16) = 0;
      do
      {
        while (1)
        {
          int v18 = a1[v15];
          if ((v18 - 125) > 1) {
            break;
          }
          int v17 = v16 + 1;
          __src[(int)v16] = 125;
          __src[(int)v16 + 1] = v18 ^ 0x20;
          size_t v16 = (int)v16 + 1 + 1;
          if (++v15 == 169) {
            goto LABEL_16;
          }
        }
        int v17 = v16;
        __src[(int)v16] = v18;
        size_t v16 = (int)v16 + 1;
        ++v15;
      }
      while (v15 != 169);
LABEL_16:
      memcpy(a1, __src, v16);
      uint64_t result = (v17 + 2);
      a1[v16] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_LOG_SetMultipleLogMasks(unsigned __int8 *a1, int a2, int a3, unsigned int a4, int a5, uint64_t a6)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x10)
  {
    bzero(a1, a2);
    *a1 = 115;
    *((_DWORD *)a1 + 1) = 3;
    *((_DWORD *)a1 + 2) = a3;
    *((_DWORD *)a1 + 3) = a4;
    LODWORD(v13) = a4 >> 3;
    if ((a4 & 7) != 0) {
      uint64_t v13 = (v13 + 1);
    }
    else {
      uint64_t v13 = v13;
    }
    if (a5 && v13)
    {
      uint64_t v14 = 0;
      do
      {
        unint64_t v15 = *(unsigned __int16 *)(a6 + 2 * v14);
        uint64_t v16 = (v15 >> 3) & 0x1FF;
        int v17 = 1 << (v15 & 7);
        uint64_t v18 = v16;
        uint64_t v19 = v13;
        do
        {
          if (!v18) {
            a1[v16 + 16] |= v17;
          }
          --v18;
          --v19;
        }
        while (v19);
        ++v14;
      }
      while (v14 != a5);
    }
    uint64_t v20 = v13 + 16;
    int v21 = 8 * (v13 + 16);
    if (8 * ((_WORD)v13 + 16))
    {
      LOWORD(v22) = -1;
      uint64_t v23 = (char *)a1;
      do
      {
        char v24 = *v23++;
        int v22 = crc_16_l_table[(v24 ^ v22)] ^ ((unsigned __int16)(v22 & 0xFF00) >> 8);
        v21 -= 8;
      }
      while ((_WORD)v21);
      a1[v20] = ~(_BYTE)v22;
      a1[v13 + 17] = (unsigned __int16)~(_WORD)v22 >> 8;
      uint64_t result = 0xFFFFFFFFLL;
      if (v13 > 0x3EE) {
        return result;
      }
    }
    else
    {
      a1[v20] = 0;
      a1[v13 + 17] = 0;
      uint64_t result = 0xFFFFFFFFLL;
      if (v13 > 0x3EE) {
        return result;
      }
    }
    uint64_t v25 = (v13 + 18);
    if (2 * (int)v25 <= a2)
    {
      bzero(__src, 0x800uLL);
      uint64_t v26 = 0;
      LODWORD(v27) = 0;
      do
      {
        while (1)
        {
          int v29 = a1[v26];
          if ((v29 - 125) > 1) {
            break;
          }
          int v28 = v27 + 1;
          __src[(int)v27] = 125;
          __src[(int)v27 + 1] = v29 ^ 0x20;
          size_t v27 = (int)v27 + 1 + 1;
          if (v25 == ++v26) {
            goto LABEL_25;
          }
        }
        int v28 = v27;
        __src[(int)v27] = v29;
        size_t v27 = (int)v27 + 1;
        ++v26;
      }
      while (v25 != v26);
LABEL_25:
      memcpy(a1, __src, v27);
      uint64_t result = (v28 + 2);
      a1[v27] = 126;
    }
  }
  return result;
}

uint64_t APPLIB_ParseRDALog(uint64_t a1)
{
  if ((*(_WORD *)(a1 + 16) & 0x1C0) != 0) {
    unsigned int v1 = (((*(_WORD *)(a1 + 16) & 0x38) != 0) | (4 * ((*(_WORD *)(a1 + 16) & 7) != 0))) + 1;
  }
  else {
    unsigned int v1 = ((*(_WORD *)(a1 + 16) & 0x38) != 0) | (4 * ((*(_WORD *)(a1 + 16) & 7) != 0));
  }
  unsigned int v2 = *(unsigned __int8 *)(a1 + 19);
  if (v1 > v2 || (*(unsigned char *)(a1 + 18) & 2) == 0) {
    return 0;
  }
  unsigned int v3 = v2 / v1;
  if (v3 <= 1) {
    unsigned int v3 = 1;
  }
  unsigned int v4 = 0;
  unsigned int v5 = 0;
  if ((*(unsigned char *)(a1 + 18) & 8) != 0)
  {
    if ((*(unsigned char *)(a1 + 18) & 4) != 0)
    {
      uint64_t v11 = a1 + 20;
      do
      {
        unint64_t v12 = *(char *)(v11 + 10);
        if (v12 <= 4)
        {
          v4 += dword_1E458FF40[v12];
          v5 += *(unsigned __int16 *)(v11 + qword_1E458FF18[v12]);
        }
        v11 += 98;
        --v3;
      }
      while (v3);
    }
    else
    {
      uint64_t v9 = a1 + 20;
      do
      {
        unint64_t v10 = *(char *)(v9 + 10);
        if (v10 <= 4)
        {
          v4 += dword_1E458FF40[v10];
          v5 += *(unsigned __int16 *)(v9 + qword_1E458FF18[v10]);
        }
        v9 += 72;
        --v3;
      }
      while (v3);
    }
  }
  else
  {
    uint64_t v6 = 74;
    if ((*(unsigned char *)(a1 + 18) & 4) == 0) {
      uint64_t v6 = 48;
    }
    uint64_t v7 = a1 + 20;
    do
    {
      unint64_t v8 = *(char *)(v7 + 10);
      if (v8 <= 4)
      {
        v4 += dword_1E458FF40[v8];
        v5 += *(unsigned __int16 *)(v7 + qword_1E458FF18[v8]);
      }
      v7 += v6;
      --v3;
    }
    while (v3);
  }
  if (v4) {
    return v5 / v4;
  }
  else {
    return 0;
  }
}

uint64_t ETLFusingCreateReadFuseCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    unint64_t v15 = "ETLSubsysAddHeaderInternal";
    uint64_t v16 = "Failed to inject\n";
LABEL_12:
    _ETLDebugPrint((uint64_t)v15, (uint64_t)v16, v7, v8, v9, v10, v11, v12, v17);
    return 0;
  }
  uint64_t v13 = HDLCFrameGetFreeSpace();
  if (v13 <= 7)
  {
    uint64_t v17 = v13;
    unint64_t v15 = "ETLFusingCreateFusingCommand";
    uint64_t v16 = "Remaining %u not enough %u\n";
    goto LABEL_12;
  }
  if (!HDLCFrameInjectUnsignedShort() || !HDLCFrameInjectUnsignedShort()) {
    return 0;
  }

  return HDLCFrameInjectUnsignedInt();
}

uint64_t ETLFusingCreateWriteFuseCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    unint64_t v15 = "ETLSubsysAddHeaderInternal";
    uint64_t v16 = "Failed to inject\n";
LABEL_12:
    _ETLDebugPrint((uint64_t)v15, (uint64_t)v16, v7, v8, v9, v10, v11, v12, v17);
    return 0;
  }
  uint64_t v13 = HDLCFrameGetFreeSpace();
  if (v13 <= 7)
  {
    uint64_t v17 = v13;
    unint64_t v15 = "ETLFusingCreateFusingCommand";
    uint64_t v16 = "Remaining %u not enough %u\n";
    goto LABEL_12;
  }
  if (!HDLCFrameInjectUnsignedShort() || !HDLCFrameInjectUnsignedShort()) {
    return 0;
  }

  return HDLCFrameInjectUnsignedInt();
}

uint64_t ETLFusingParseReadFuseResponse(int **a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  uint64_t v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
    return 0;
  }
  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = **a1;
    if (v11 == 75)
    {
      if (BYTE1(v11) == 253)
      {
        uint64_t v12 = HIWORD(v11);
        if (v12 == 11)
        {
          if (v9 <= 5)
          {
            _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponse", (uint64_t)"Payload length %u less than needed %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else
          {
            uint64_t v13 = *((unsigned __int16 *)v10 + 2);
            *a3 = *(_DWORD *)((char *)v10 + 6);
            if (v13 == 1)
            {
              return 1;
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponse", (uint64_t)"Status returned was %u, expected %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v13);
              return 0;
            }
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v12);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v11));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, **a1);
      return 0;
    }
  }
}

uint64_t ETLFusingParseWriteFuseResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a1[2];
  uint64_t v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    unsigned int v10 = **(_DWORD **)a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 253)
      {
        uint64_t v11 = HIWORD(v10);
        if (v11 == 11)
        {
          if (v9 <= 5)
          {
            _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponse", (uint64_t)"Payload length %u less than needed %u\n", a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else if (*(_WORD *)(*(void *)a1 + 4) == 1)
          {
            return 1;
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponse", (uint64_t)"Status returned was %u, expected %u\n", a3, a4, a5, a6, a7, a8, *(unsigned __int16 *)(*(void *)a1 + 4));
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

uint64_t ETLFusingProgramFuse(void *a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = *a3;
  _ETLDebugPrint((uint64_t)"ETLFusingProgramFuse", (uint64_t)"Programming fuse %u, value %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, a2);
  if (a4 == 4)
  {
    int v33 = -1431655766;
    if (ETLFusingPerformFusingOperation(a1, a2, 0, 0, &v33, a5))
    {
      int v25 = v33;
      _ETLDebugPrint((uint64_t)"ETLFusingProgramFuse", (uint64_t)"Read back fuse %u, value %u\n", v19, v20, v21, v22, v23, v24, a2);
      if ((v25 | v12) == v12)
      {
        _ETLDebugPrint((uint64_t)"ETLFusingProgramFuse", (uint64_t)"Programming fuse %u, final write value %u\n", v26, v27, v28, v29, v30, v31, a2);
        return ETLFusingPerformFusingOperation(a1, a2, 1, v12 & ~v25, &v34, a5);
      }
      _ETLDebugPrint((uint64_t)"ETLFusingProgramFuse", (uint64_t)"Mismatch, expected to be written %u, final value on device will be %u\n", v26, v27, v28, v29, v30, v31, v12);
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLFusingProgramFuse", (uint64_t)"Failed to read the fuse %u\n", v19, v20, v21, v22, v23, v24, a2);
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLFusingProgramFuse", (uint64_t)"Data length %u is not %zu\n", v13, v14, v15, v16, v17, v18, a4);
  }
  return 0;
}

uint64_t ETLFusingPerformFusingOperation(void *a1, uint64_t a2, int a3, uint64_t a4, _DWORD *a5, uint64_t a6)
{
  long long v50 = 0u;
  long long v51 = 0u;
  uint64_t v52 = 0;
  memset(v48, 0, sizeof(v48));
  uint64_t v49 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    int v25 = "ETLFusingPerformFusingOperation";
    uint64_t v26 = "Faild to create uplink frame\n";
LABEL_42:
    _ETLDebugPrint((uint64_t)v25, (uint64_t)v26, v10, v11, v12, v13, v14, v15, v47);
    goto LABEL_43;
  }
  if (a3 != 1)
  {
    if (a3) {
      goto LABEL_18;
    }
    uint64_t FreeSpace = HDLCFrameGetFreeSpace();
    if (FreeSpace >= 4)
    {
      unsigned int v53 = 785739;
      if (HDLCFrameInject())
      {
        uint64_t v23 = HDLCFrameGetFreeSpace();
        if (v23 > 7)
        {
          if (HDLCFrameInjectUnsignedShort())
          {
            uint64_t v24 = 0;
            if (!HDLCFrameInjectUnsignedShort()) {
              goto LABEL_44;
            }
            uint64_t v24 = 0;
            if ((HDLCFrameInjectUnsignedInt() & 1) == 0) {
              goto LABEL_44;
            }
            goto LABEL_18;
          }
LABEL_43:
          uint64_t v24 = 0;
          goto LABEL_44;
        }
        goto LABEL_41;
      }
      goto LABEL_39;
    }
LABEL_38:
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v17, v18, v19, v20, v21, v22, FreeSpace);
    goto LABEL_43;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4) {
    goto LABEL_38;
  }
  unsigned int v53 = 785739;
  if ((HDLCFrameInject() & 1) == 0)
  {
LABEL_39:
    int v25 = "ETLSubsysAddHeaderInternal";
    uint64_t v26 = "Failed to inject\n";
    goto LABEL_42;
  }
  uint64_t v23 = HDLCFrameGetFreeSpace();
  if (v23 <= 7)
  {
LABEL_41:
    uint64_t v47 = v23;
    int v25 = "ETLFusingCreateFusingCommand";
    uint64_t v26 = "Remaining %u not enough %u\n";
    goto LABEL_42;
  }
  if (!HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedInt())
  {
    goto LABEL_43;
  }
LABEL_18:
  uint64_t v24 = (uint64_t)malloc((2 * DWORD2(v50) + 32));
  if (!v24) {
    goto LABEL_44;
  }
  uint64_t v27 = HDLCFrameEncode();
  if (!v27) {
    goto LABEL_40;
  }
  uint64_t v28 = v27;
  unsigned int v53 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v24, v27);
  }
  if (!*a1)
  {
LABEL_40:
    free((void *)v24);
    goto LABEL_43;
  }
  int v29 = ((uint64_t (*)(void *, uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v24, v28, &v53, 1, a6, 0);
  unsigned int v30 = v53;
  free((void *)v24);
  if (v29) {
    BOOL v31 = v30 == v28;
  }
  else {
    BOOL v31 = 0;
  }
  if (!v31) {
    goto LABEL_43;
  }
  LOBYTE(v53) = 75;
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  uint64_t v24 = 0;
  if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v48, (uint64_t)&_ETLResponseRingBuffer, &v53, a6)&& v53 == 75)
  {
    if (a3 == 1)
    {
      unsigned int v53 = 0;
      uint64_t v24 = 0;
      if (!ETLMaverickParseBSPResponseHeader((uint64_t)v48, &v53, 11, v32, v33, v34, v35, v36)) {
        goto LABEL_44;
      }
      uint64_t v43 = DWORD2(v48[0]) - v53;
      if (v43 > 5)
      {
        uint64_t v45 = *(unsigned __int16 *)(*(void *)&v48[0] + v53);
        if (v45 == 1) {
          goto LABEL_37;
        }
LABEL_48:
        _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponse", (uint64_t)"Status returned was %u, expected %u\n", v37, v38, v39, v40, v41, v42, v45);
        goto LABEL_43;
      }
    }
    else
    {
      if (a3)
      {
LABEL_37:
        uint64_t v24 = 1;
        goto LABEL_44;
      }
      unsigned int v53 = 0;
      uint64_t v24 = 0;
      if (!ETLMaverickParseBSPResponseHeader((uint64_t)v48, &v53, 11, v32, v33, v34, v35, v36)) {
        goto LABEL_44;
      }
      uint64_t v43 = DWORD2(v48[0]) - v53;
      if (v43 > 5)
      {
        int v44 = (unsigned __int16 *)(*(void *)&v48[0] + v53);
        uint64_t v45 = *v44;
        *a5 = *(_DWORD *)(v44 + 1);
        if (v45 == 1) {
          goto LABEL_37;
        }
        goto LABEL_48;
      }
    }
    _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponse", (uint64_t)"Payload length %u less than needed %u\n", v37, v38, v39, v40, v41, v42, v43);
    goto LABEL_43;
  }
LABEL_44:
  HDLCFrameFree();
  HDLCFrameFree();
  return v24;
}

uint64_t ETLFusingReadFuse(void *a1, uint64_t a2, int *a3, uint64_t a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a5 = 0;
  if (a4 > 3)
  {
    int v19 = -1431655766;
    int v18 = ETLFusingPerformFusingOperation(a1, a2, 0, 0, &v19, a6);
    uint64_t result = 0;
    if (v18)
    {
      *a5 = 4;
      *a3 = v19;
      _ETLDebugPrint((uint64_t)"ETLFusingReadFuse", (uint64_t)"Read back fuse %u, value %u\n", v12, v13, v14, v15, v16, v17, a2);
      return 1;
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLFusingReadFuse", (uint64_t)"Data capacity %u less than reequired %zu\n", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, a4);
    return 0;
  }
  return result;
}

uint64_t ETLFusingProgramTriggerM20(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a2)
  {
    _ETLDebugPrint((uint64_t)"ETLFusingProgramTriggerM20", (uint64_t)"Transport (%p) and Status (%p) should not be NULL \n", a3, a4, a5, a6, a7, a8, (uint64_t)a1);
    return 0;
  }
  memset(v48, 0, sizeof(v48));
  uint64_t v49 = 0;
  memset(v46, 0, sizeof(v46));
  uint64_t v47 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    uint64_t v42 = "ETLFusingProgramTriggerM20";
    uint64_t v43 = "Faild to create uplink frame\n";
LABEL_24:
    _ETLDebugPrint((uint64_t)v42, (uint64_t)v43, v11, v12, v13, v14, v15, v16, v45);
    goto LABEL_25;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
LABEL_25:
    uint64_t v25 = 0;
LABEL_26:
    HDLCFrameFree();
    HDLCFrameFree();
    return v25;
  }
  unsigned int v51 = 1575755;
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v42 = "ETLSubsysAddHeaderInternal";
    uint64_t v43 = "Failed to inject\n";
    goto LABEL_24;
  }
  uint64_t v24 = HDLCFrameGetFreeSpace();
  if (v24 <= 7)
  {
    uint64_t v45 = v24;
    uint64_t v42 = "ETLHDLCFrameCheckFreeSpace";
    uint64_t v43 = "Remaining %u not enough %u\n";
    goto LABEL_24;
  }
  if (!HDLCFrameInjectUnsignedShort()) {
    goto LABEL_25;
  }
  uint64_t v25 = 0;
  if (!HDLCFrameInjectUnsignedShort()) {
    goto LABEL_26;
  }
  uint64_t v25 = 0;
  if (!HDLCFrameInjectUnsignedShort()) {
    goto LABEL_26;
  }
  uint64_t v25 = 0;
  if (!HDLCFrameInjectUnsignedShort()) {
    goto LABEL_26;
  }
  if (!ETLSendCommand(a1, (uint64_t)v48, a3)
    || !ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v46, a3))
  {
    goto LABEL_25;
  }
  int v50 = 0;
  unsigned int v51 = 0;
  ETLSubsysParseHeader((uint64_t)v46, (_WORD *)&v50 + 1, &v50, &v51, v26, v27, v28, v29);
  if (HIWORD(v50) != 11)
  {
    _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponseM20", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v30, v31, v32, v33, v34, v35, HIWORD(v50));
    uint64_t v36 = (unsigned __int16)v50;
    goto LABEL_34;
  }
  uint64_t v36 = (unsigned __int16)v50;
  if ((unsigned __int16)v50 != 24)
  {
LABEL_34:
    _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponseM20", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v30, v31, v32, v33, v34, v35, v36);
    __break(1u);
    goto LABEL_35;
  }
  uint64_t v37 = DWORD2(v46[0]) - v51;
  if (v37 > 7)
  {
    uint64_t v38 = (_WORD *)(*(void *)&v46[0] + v51);
    if (*v38 == 3)
    {
      uint64_t v39 = DWORD2(v46[0]) - (v51 + 8);
      if (v39 > 3)
      {
        uint64_t v38 = (_WORD *)(*(void *)&v46[0] + v51 + 8);
        unsigned int v40 = 1;
        goto LABEL_30;
      }
      _ETLDebugPrint((uint64_t)"ETLHDLCFrameCheckRemainedSize", (uint64_t)"Payload length %u less than needed %u\n", v30, v31, v32, v33, v34, v35, v39);
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponseM20", (uint64_t)"Received Secboot provisioning trigger code 0x%x doesn't match expected 0x%x\n", v30, v31, v32, v33, v34, v35, *(unsigned __int16 *)(*(void *)&v46[0] + v51));
    }
    unsigned int v40 = 0;
LABEL_30:
    uint64_t v44 = *(unsigned int *)v38;
    *a2 = v44;
    if (v44)
    {
      _ETLDebugPrint((uint64_t)"ETLFusingParseFusingResponseM20", (uint64_t)"Received status 0x%x doesn't match expected 0x%x\n", v30, v31, v32, v33, v34, v35, v44);
      uint64_t v25 = 0;
    }
    else
    {
      uint64_t v25 = v40;
    }
    goto LABEL_26;
  }
LABEL_35:
  uint64_t result = _ETLDebugPrint((uint64_t)"ETLHDLCFrameCheckRemainedSize", (uint64_t)"Payload length %u less than needed %u\n", v30, v31, v32, v33, v34, v35, v37);
  __break(1u);
  return result;
}

unint64_t ETLFusingGetFusedData(capabilities::radio *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && a2)
  {
    capabilities::radio::mav20Plus(a1);
    long long v45 = 0u;
    long long v46 = 0u;
    uint64_t v47 = 0;
    memset(v43, 0, sizeof(v43));
    uint64_t v44 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v18, v19, v20, v21, v22, v23, FreeSpace);
LABEL_35:
        unint64_t v24 = 0;
        goto LABEL_36;
      }
      int v48 = 8781131;
      if (HDLCFrameInject())
      {
        unint64_t v24 = (unint64_t)malloc((2 * DWORD2(v45) + 32));
        if (!v24) {
          goto LABEL_36;
        }
        uint64_t v25 = HDLCFrameEncode();
        if (!v25) {
          goto LABEL_38;
        }
        uint64_t v26 = v25;
        int v48 = -1431655766;
        if ((_ETLDebugFlags & 2) != 0) {
          ((void (*)(const char *, void, unint64_t, uint64_t))*(&gDelegate + 1))("", 0, v24, v25);
        }
        if (!*(void *)a1)
        {
LABEL_38:
          free((void *)v24);
          goto LABEL_35;
        }
        int v27 = (*(uint64_t (**)(capabilities::radio *, unint64_t, uint64_t, int *, uint64_t, uint64_t, void))a1)(a1, v24, v26, &v48, 1, a3, 0);
        int v28 = v48;
        free((void *)v24);
        unint64_t v24 = 0;
        if (!v27 || v28 != v26) {
          goto LABEL_36;
        }
        LOBYTE(v48) = 75;
        if (!_ETLResponseRingBuffer) {
          TelephonyUtilRingBufferInitialize();
        }
        unint64_t v24 = 0;
        if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v43, (uint64_t)&_ETLResponseRingBuffer, &v48, a3)|| v48 != 75)
        {
          goto LABEL_36;
        }
        uint64_t v29 = (DWORD2(v43[0]) - 4);
        if (DWORD2(v43[0]) < 4)
        {
          _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v11, v12, v13, v14, v15, v16, DWORD2(v43[0]));
        }
        else
        {
          unsigned int v30 = **(_DWORD **)&v43[0];
          if (**(_DWORD **)&v43[0] == 75)
          {
            uint64_t v31 = BYTE1(v30);
            if (BYTE1(v30) == 253)
            {
              if (HIWORD(v30) != 133)
              {
                _ETLDebugPrint((uint64_t)"ETLFusingParseGetFusedData", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v11, v12, v13, v14, v15, v16, HIWORD(v30));
                goto LABEL_35;
              }
              *(_DWORD *)(a2 + 44) = 0;
              if (v29 >= 4)
              {
                unsigned int v32 = 0;
                uint64_t v33 = 12;
                int v34 = -12;
                while (1)
                {
                  if (v32 >= *(_DWORD *)(a2 + 8) - 1) {
                    goto LABEL_47;
                  }
                  *(_DWORD *)(*(void *)a2 + 4 * v32) = *(_DWORD *)(*(void *)&v43[0] + (v33 - 8));
                  uint64_t v35 = *(unsigned int *)(a2 + 44);
                  if (v35 >= *(_DWORD *)(a2 + 24) - 1) {
                    goto LABEL_47;
                  }
                  uint64_t v36 = (v34 + DWORD2(v43[0]) + 4);
                  if (v36 <= 3)
                  {
                    _ETLDebugPrint((uint64_t)"ETLHDLCFrameCheckRemainedSize", (uint64_t)"Payload length %u less than needed %u\n", v11, v12, v13, v14, v15, v16, v36);
LABEL_47:
                    uint64_t v42 = (v33 - 4);
                    goto LABEL_51;
                  }
                  *(_DWORD *)(*(void *)(a2 + 16) + 4 * v35) = *(_DWORD *)(*(void *)&v43[0] + (v33 - 4));
                  uint64_t v37 = *(unsigned int *)(a2 + 44);
                  if (v37 >= *(_DWORD *)(a2 + 40) - 1) {
                    goto LABEL_50;
                  }
                  uint64_t v38 = (v34 + DWORD2(v43[0]));
                  if (v38 <= 3) {
                    break;
                  }
                  *(_DWORD *)(*(void *)(a2 + 32) + 4 * v37) = *(_DWORD *)(*(void *)&v43[0] + v33);
                  unsigned int v32 = *(_DWORD *)(a2 + 44) + 1;
                  *(_DWORD *)(a2 + 44) = v32;
                  uint64_t v33 = (v33 + 12);
                  v34 -= 12;
                  uint64_t v29 = (DWORD2(v43[0]) + v34 + 8);
                  if (v29 <= 3) {
                    goto LABEL_29;
                  }
                }
                _ETLDebugPrint((uint64_t)"ETLHDLCFrameCheckRemainedSize", (uint64_t)"Payload length %u less than needed %u\n", v11, v12, v13, v14, v15, v16, v38);
LABEL_50:
                uint64_t v42 = v33;
LABEL_51:
                uint64_t v39 = "ETLFusingParseGetFusedData";
                unsigned int v40 = "Failed to fill address at offset: %d, totalNumber: %d, maxNumberOfAddress: %d\n";
                goto LABEL_34;
              }
LABEL_29:
              _ETLDebugPrint((uint64_t)"ETLHDLCFrameCheckRemainedSize", (uint64_t)"Payload length %u less than needed %u\n", v11, v12, v13, v14, v15, v16, v29);
              unint64_t v24 = *(_DWORD *)(a2 + 44) != 0;
LABEL_36:
              HDLCFrameFree();
              HDLCFrameFree();
              return v24;
            }
LABEL_42:
            _ETLDebugPrint((uint64_t)"ETLFusingParseGetFusedData", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v11, v12, v13, v14, v15, v16, v31);
            goto LABEL_35;
          }
          _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v11, v12, v13, v14, v15, v16, **(_DWORD **)&v43[0]);
        }
        uint64_t v31 = 0;
        goto LABEL_42;
      }
      uint64_t v39 = "ETLSubsysAddHeaderInternal";
      unsigned int v40 = "Failed to inject\n";
    }
    else
    {
      uint64_t v39 = "ETLFusingGetFusedData";
      unsigned int v40 = "Faild to create uplink frame\n";
    }
LABEL_34:
    _ETLDebugPrint((uint64_t)v39, (uint64_t)v40, v11, v12, v13, v14, v15, v16, v42);
    goto LABEL_35;
  }
  _ETLDebugPrint((uint64_t)"ETLFusingGetFusedData", (uint64_t)"Transport (%p) or paraemter (%p) should not be NULL \n", a3, a4, a5, a6, a7, a8, (uint64_t)a1);
  return 0;
}

uint64_t ETLFusingGetSecureState(capabilities::radio *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && a2)
  {
    if (capabilities::radio::mav20Plus(a1))
    {
      long long v47 = 0u;
      long long v48 = 0u;
      uint64_t v49 = 0;
      memset(v45, 0, sizeof(v45));
      uint64_t v46 = 0;
      if (HDLCFrameCreateUplink())
      {
        uint64_t FreeSpace = HDLCFrameGetFreeSpace();
        if (FreeSpace < 4)
        {
          _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v24, v25, v26, v27, v28, v29, FreeSpace);
          goto LABEL_25;
        }
        int v50 = 9502027;
        if (HDLCFrameInject())
        {
          SecureState = malloc((2 * DWORD2(v47) + 32));
          if (!SecureState)
          {
LABEL_26:
            HDLCFrameFree();
            HDLCFrameFree();
            return (uint64_t)SecureState;
          }
          uint64_t v31 = HDLCFrameEncode();
          if (v31)
          {
            uint64_t v32 = v31;
            int v50 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0) {
              ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, SecureState, v31);
            }
            if (*(void *)a1)
            {
              int v33 = (*(uint64_t (**)(capabilities::radio *, void *, uint64_t, int *, uint64_t, uint64_t, void))a1)(a1, SecureState, v32, &v50, 1, a3, 0);
              int v34 = v50;
              free(SecureState);
              SecureState = 0;
              if (v33 && v34 == v32)
              {
                LOBYTE(v50) = 75;
                if (!_ETLResponseRingBuffer) {
                  TelephonyUtilRingBufferInitialize();
                }
                SecureState = 0;
                if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v45, (uint64_t)&_ETLResponseRingBuffer, &v50, a3)&& v50 == 75)
                {
                  SecureState = (void *)ETLFusingParseGetSecureState((int **)v45, a2, v35, v36, v37, v38, v39, v40);
                }
              }
              goto LABEL_26;
            }
          }
          free(SecureState);
LABEL_25:
          SecureState = 0;
          goto LABEL_26;
        }
        uint64_t v41 = "ETLSubsysAddHeaderInternal";
        uint64_t v42 = "Failed to inject\n";
      }
      else
      {
        uint64_t v41 = "ETLFusingGetSecureState";
        uint64_t v42 = "Faild to create uplink frame\n";
      }
      _ETLDebugPrint((uint64_t)v41, (uint64_t)v42, v17, v18, v19, v20, v21, v22, v44);
      goto LABEL_25;
    }
    _ETLDebugPrint((uint64_t)"ETLFusingGetSecureState", (uint64_t)"This does does not support secure state command\n", v11, v12, v13, v14, v15, v16, v44);
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLFusingGetSecureState", (uint64_t)"Transport (%p) and Status (%p) should not be NULL\n", a3, a4, a5, a6, a7, a8, (uint64_t)a1);
    return 0;
  }
}

uint64_t ETLFusingParseGetSecureState(int **a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a1 + 2);
  uint64_t v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_16:
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    goto LABEL_17;
  }
  uint64_t v10 = *a1;
  unsigned int v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **a1);
    goto LABEL_16;
  }
  uint64_t v12 = HIWORD(v11);
  uint64_t v13 = BYTE1(v11);
  if (BYTE1(v11) != 253)
  {
LABEL_17:
    _ETLDebugPrint((uint64_t)"ETLFusingParseGetSecureState", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v13);
    goto LABEL_18;
  }
  if (v12 != 144)
  {
LABEL_18:
    _ETLDebugPrint((uint64_t)"ETLFusingParseGetSecureState", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v12);
    __break(1u);
    goto LABEL_19;
  }
  if (v9 <= 3)
  {
LABEL_19:
    uint64_t result = _ETLDebugPrint((uint64_t)"ETLHDLCFrameCheckRemainedSize", (uint64_t)"Payload length %u less than needed %u\n", a3, a4, a5, a6, a7, a8, v9);
    __break(1u);
    return result;
  }
  uint64_t v15 = v10 + 1;
  if ((unsigned __int16)v10[1])
  {
    _ETLDebugPrint((uint64_t)"ETLFusingParseGetSecureState", (uint64_t)"Received Secboot provisioning trigger code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, (unsigned __int16)v10[1]);
    goto LABEL_10;
  }
  if (v10[1])
  {
LABEL_10:
    uint64_t result = 0;
    *a2 = *v15;
    return result;
  }
  uint64_t v17 = v8 - 8;
  if (v17 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLHDLCFrameCheckRemainedSize", (uint64_t)"Payload length %u less than needed %u\n", a3, a4, a5, a6, a7, a8, v17);
    goto LABEL_10;
  }
  uint64_t result = 1;
  *a2 = v10[2];
  return result;
}

uint64_t ETLDesenseCreateCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLDesenseCreateCommand", (uint64_t)"Failed to add command header\n", v21, v22, v23, v24, v25, v26, v28);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v27);
    goto LABEL_12;
  }
  uint64_t v13 = HDLCFrameGetFreeSpace();
  if (v13 <= 7)
  {
    _ETLDebugPrint((uint64_t)"ETLDesenseCreateCommand", (uint64_t)"Remaining %u not enough %u\n", v14, v15, v16, v17, v18, v19, v13);
    return 0;
  }
  if (!HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedShort())
  {
    return 0;
  }

  return HDLCFrameInjectUnsignedShort();
}

uint64_t ETLDesenseParseResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a1[2];
  uint64_t v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    unsigned int v10 = **(_DWORD **)a1;
    if (v10 == 75)
    {
      if (BYTE1(v10) == 253)
      {
        uint64_t v11 = HIWORD(v10);
        if (v11 == 15)
        {
          if (v9 <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLDesenseParseResponseWithStatus", (uint64_t)"Payload length %u less than needed %u\n", a3, a4, a5, a6, a7, a8, v9);
            return 0;
          }
          else if (*(_WORD *)(*(void *)a1 + 4) == 1)
          {
            return 1;
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLDesenseParseResponseWithStatus", (uint64_t)"Status returned was %u, expected %u\n", a3, a4, a5, a6, a7, a8, *(unsigned __int16 *)(*(void *)a1 + 4));
            return 0;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

uint64_t ETLDesenseOperation(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _DWORD *a7)
{
  if (a7) {
    *a7 = 0;
  }
  uint64_t v42 = 0;
  long long v40 = 0u;
  long long v41 = 0u;
  memset(v38, 0, sizeof(v38));
  uint64_t v39 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLDesenseOperation", (uint64_t)"Faild to create uplink frame\n", v10, v11, v12, v13, v14, v15, v37);
    goto LABEL_26;
  }
  if (!ETLDesenseCreateCommand())
  {
LABEL_26:
    uint64_t v16 = 0;
    goto LABEL_27;
  }
  uint64_t v16 = (uint64_t)malloc((2 * DWORD2(v40) + 32));
  if (v16)
  {
    uint64_t v17 = HDLCFrameEncode();
    if (!v17) {
      goto LABEL_28;
    }
    uint64_t v18 = v17;
    int v43 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
    }
    if (!*a1)
    {
LABEL_28:
      free((void *)v16);
      goto LABEL_26;
    }
    int v19 = ((uint64_t (*)(void *, uint64_t, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v16, v18, &v43, 1, a6, 0);
    int v20 = v43;
    free((void *)v16);
    uint64_t v16 = 0;
    if (v19)
    {
      if (v20 == v18)
      {
        LOBYTE(v43) = 75;
        if (!_ETLResponseRingBuffer) {
          TelephonyUtilRingBufferInitialize();
        }
        uint64_t v16 = 0;
        if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v38, (uint64_t)&_ETLResponseRingBuffer, &v43, a6))
        {
          if (v43 == 75)
          {
            _ETLDebugPrint((uint64_t)"ETLDesenseOperation", (uint64_t)"Read done\n", v21, v22, v23, v24, v25, v26, v37);
            if (DWORD2(v38[0]) < 4)
            {
              _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v27, v28, v29, v30, v31, v32, DWORD2(v38[0]));
            }
            else
            {
              unsigned int v33 = **(_DWORD **)&v38[0];
              if (**(_DWORD **)&v38[0] == 75)
              {
                if (BYTE1(v33) == 253)
                {
                  uint64_t v34 = HIWORD(v33);
                  if (v34 == 15)
                  {
                    if ((DWORD2(v38[0]) - 4) <= 1)
                    {
                      _ETLDebugPrint((uint64_t)"ETLDesenseParseResponseWithStatus", (uint64_t)"Payload length %u less than needed %u\n", v27, v28, v29, v30, v31, v32, (DWORD2(v38[0]) - 4));
                    }
                    else
                    {
                      uint64_t v35 = *(unsigned __int16 *)(*(void *)&v38[0] + 4);
                      if (a7) {
                        *a7 = v35;
                      }
                      if (v35 == 1)
                      {
                        uint64_t v16 = 1;
                        goto LABEL_27;
                      }
                      _ETLDebugPrint((uint64_t)"ETLDesenseParseResponseWithStatus", (uint64_t)"Status returned was %u, expected %u\n", v27, v28, v29, v30, v31, v32, v35);
                    }
                  }
                  else
                  {
                    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v27, v28, v29, v30, v31, v32, v34);
                  }
                }
                else
                {
                  _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v27, v28, v29, v30, v31, v32, BYTE1(v33));
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v27, v28, v29, v30, v31, v32, **(_DWORD **)&v38[0]);
              }
            }
            goto LABEL_26;
          }
        }
      }
    }
  }
LABEL_27:
  HDLCFrameFree();
  HDLCFrameFree();
  return v16;
}

uint64_t ETLDesenseStart(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  return ETLDesenseOperation(a1, 6, a2, a3, a4, a5, a6);
}

uint64_t ETLDesenseStop(void *a1, uint64_t a2, _DWORD *a3)
{
  return ETLDesenseOperation(a1, 7, 0, 0, 0, a2, a3);
}

uint64_t ETLDesenseReset(void *a1, uint64_t a2, _DWORD *a3)
{
  return ETLDesenseOperation(a1, 8, 0, 0, 0, a2, a3);
}

uint64_t ETLDesenseReport(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  return ETLDesenseOperation(a1, 5, a2, a3, 0, a4, a5);
}

uint64_t ETLLOGParseLogRecord(void *a1, _DWORD *a2, void *a3, _WORD *a4, unsigned __int16 *a5, uint64_t a6, _DWORD *a7, uint64_t a8)
{
  if (a6 < 0xC) {
    return 0;
  }
  uint64_t v9 = *a5;
  *a7 = v9;
  if (v9 <= a6 && v9 > 0xB)
  {
    if (a1) {
      *a1 = a5 + 6;
    }
    if (a2) {
      *a2 = v9 - 12;
    }
    if (a3) {
      *a3 = *(void *)(a5 + 2);
    }
    if (a4) {
      *a4 = a5[1];
    }
    return 1;
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLLOGParseLogRecord", (uint64_t)"Packet length is (%u), source buffer length is (%u), LOG header size should be (%u), skipping.\n", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, (uint64_t)a7, a8, v9);
    return 0;
  }
}

uint64_t ETLLOGParseLogHeader(uint64_t a1, unsigned int *a2, void *a3, _WORD *a4, uint64_t a5, unsigned int a6, _DWORD *a7)
{
  uint64_t result = 0;
  *a7 = 0;
  if (a6 >= 4)
  {
    if (*(unsigned char *)a5 == 16 && (unsigned int v8 = *(unsigned __int16 *)(a5 + 2), *a2 = v8, v8 <= a6) && (*a7 = 4, a6 - 4 >= 0xC))
    {
      *a4 = *(_WORD *)(a5 + 6);
      *a3 = *(void *)(a5 + 8);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t ETLLOGParseLog(char *__str, size_t __size, uint64_t a3, unsigned int a4, _DWORD *a5)
{
  *a5 = 0;
  if (a4 < 4 || *(unsigned char *)a3 != 16)
  {
    unint64_t v6 = 0;
    int v7 = 0;
    unsigned int v5 = 0;
    goto LABEL_6;
  }
  unsigned int v5 = *(unsigned __int16 *)(a3 + 2);
  if (v5 > a4)
  {
    unint64_t v6 = 0;
    int v7 = 0;
LABEL_6:
    int v8 = 0;
    goto LABEL_7;
  }
  int v7 = 4;
  *a5 = 4;
  if (a4 - 4 < 0xC)
  {
    unint64_t v6 = 0;
    goto LABEL_6;
  }
  int v8 = *(unsigned __int16 *)(a3 + 6);
  unint64_t v6 = *(void *)(a3 + 8);
LABEL_7:
  *a5 = v5 + v7;
  unint64_t v9 = 5 * (v6 >> 16)
     + ((unsigned __int16)(((43685 * (unsigned __int16)v6) >> 16)
                                       + ((unsigned __int16)((v6 - ((43685 * (unsigned __int16)v6) >> 16)) & 0xFFFE) >> 1)) >> 13)
     + 2;
  unint64_t v10 = v9 >> 2;
  unint64_t v11 = ((v9 * (unsigned __int128)0x10624DD2F1A9FCuLL) >> 64) + 315964800;
  if (__size >= snprintf(__str, __size, "[%02u:%02u:%02u:%06u: %04x] LOG 0x%02x: ", ((v11 * (unsigned __int128)0x123456789ABCE0uLL) >> 64) % 0x18, v11 / 0x3C- 60* ((unint64_t)((v11 / 0x3C * (unsigned __int128)0x888888888888889uLL) >> 64) >> 1), v11 % 0x3C, 1000* (v10 - 1000 * ((v10 * (unsigned __int128)0x4189374BC6A7F0uLL) >> 64)), v8, v5))TelephonyUtilBinToHex(); {
  return 1;
  }
}

uint64_t ETLGSMAddCommandHeader()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else
  {
    uint64_t v13 = HDLCFrameInject();
    if ((v13 & 1) == 0) {
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v15);
    }
    return v13;
  }
}

uint64_t ETLGSMParseSubsysResponseHeader(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a2;
  uint64_t v9 = (*(_DWORD *)(a1 + 8) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    unsigned int v10 = *(_DWORD *)(*(void *)a1 + v8);
    if (v10 == 75)
    {
      *a2 = v8 + 4;
      if (BYTE1(v10) == a3)
      {
        if (HIWORD(v10) == a4)
        {
          return 1;
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLGSMParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, HIWORD(v10));
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLGSMParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
      return 0;
    }
  }
}

uint64_t ETLGSMParseGetIMEI(uint64_t *a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a3;
  uint64_t v9 = (*((_DWORD *)a1 + 2) - v8);
  if (v9 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", (uint64_t)a3, a4, a5, a6, a7, a8, v9);
LABEL_11:
    _ETLDebugPrint((uint64_t)"ETLGSMParseGetIMEI", (uint64_t)"failed parsing GSM response from frame\n", v17, v18, v19, v20, v21, v22, v23);
    return 0;
  }
  uint64_t v10 = *a1;
  unsigned int v11 = *(_DWORD *)(*a1 + v8);
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, *(_DWORD *)(*a1 + v8));
    goto LABEL_11;
  }
  unsigned int v12 = v8 + 4;
  *a3 = v12;
  if (BYTE1(v11) != 8)
  {
    _ETLDebugPrint((uint64_t)"ETLGSMParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v11));
    goto LABEL_11;
  }
  uint64_t v13 = HIWORD(v11);
  if (v13 != 1)
  {
    _ETLDebugPrint((uint64_t)"ETLGSMParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", (uint64_t)a3, a4, a5, a6, a7, a8, v13);
    goto LABEL_11;
  }
  if (*((_DWORD *)a1 + 2) - v12 <= 8)
  {
    _ETLDebugPrint((uint64_t)"ETLGSMParseGetIMEI", (uint64_t)"Need %u bytes, but only have %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, 9);
    return 0;
  }
  else
  {
    uint64_t v14 = (uint64_t *)(v10 + v12);
    uint64_t v15 = *v14;
    *(unsigned char *)(a2 + 8) = *((unsigned char *)v14 + 8);
    *(void *)a2 = v15;
    return 1;
  }
}

uint64_t ETLGSMMakeIMEIFromString(uint64_t a1, char *__s)
{
  uint64_t result = 0;
  if (!a1 || !__s) {
    return result;
  }
  size_t v5 = strlen(__s);
  if (v5 != 15)
  {
    _ETLDebugPrint((uint64_t)"ETLGSMMakeIMEIFromString", (uint64_t)"Length %zu is unrecognized\n", v6, v7, v8, v9, v10, v11, v5);
    return 0;
  }
  int v12 = *__s;
  unsigned int v13 = v12 - 58;
  int v14 = v12 - 48;
  if (v13 < 0xFFFFFFF6) {
    int v14 = -1;
  }
  if (v14 < 0) {
    return 0;
  }
  uint64_t result = 0;
  *(void *)a1 = 0;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)a1 = 8;
  *(unsigned char *)(a1 + 1) = (16 * v14) | 0xA;
  int v15 = __s[1];
  unsigned int v16 = v15 - 58;
  int v17 = v15 - 48;
  if (v16 < 0xFFFFFFF6) {
    int v17 = -1;
  }
  int v18 = __s[2];
  unsigned int v19 = v18 - 58;
  int v20 = v18 - 48;
  if (v19 < 0xFFFFFFF6) {
    int v20 = -1;
  }
  if ((v17 & 0x80000000) == 0 && (v20 & 0x80000000) == 0)
  {
    uint64_t result = 0;
    *(unsigned char *)(a1 + 2) = v17 | (16 * v20);
    int v21 = __s[3];
    unsigned int v22 = v21 - 58;
    int v23 = v21 - 48;
    if (v22 < 0xFFFFFFF6) {
      int v23 = -1;
    }
    int v24 = __s[4];
    unsigned int v25 = v24 - 58;
    int v26 = v24 - 48;
    if (v25 < 0xFFFFFFF6) {
      int v26 = -1;
    }
    if ((v23 & 0x80000000) == 0 && (v26 & 0x80000000) == 0)
    {
      uint64_t result = 0;
      *(unsigned char *)(a1 + 3) = v23 | (16 * v26);
      int v27 = __s[5];
      unsigned int v28 = v27 - 58;
      int v29 = v27 - 48;
      if (v28 < 0xFFFFFFF6) {
        int v29 = -1;
      }
      int v30 = __s[6];
      unsigned int v31 = v30 - 58;
      int v32 = v30 - 48;
      if (v31 < 0xFFFFFFF6) {
        int v32 = -1;
      }
      if ((v29 & 0x80000000) == 0 && (v32 & 0x80000000) == 0)
      {
        uint64_t result = 0;
        *(unsigned char *)(a1 + 4) = v29 | (16 * v32);
        int v33 = __s[7];
        unsigned int v34 = v33 - 58;
        int v35 = v33 - 48;
        if (v34 < 0xFFFFFFF6) {
          int v35 = -1;
        }
        int v36 = __s[8];
        unsigned int v37 = v36 - 58;
        int v38 = v36 - 48;
        if (v37 < 0xFFFFFFF6) {
          int v38 = -1;
        }
        if ((v35 & 0x80000000) == 0 && (v38 & 0x80000000) == 0)
        {
          uint64_t result = 0;
          *(unsigned char *)(a1 + 5) = v35 | (16 * v38);
          int v39 = __s[9];
          unsigned int v40 = v39 - 58;
          int v41 = v39 - 48;
          if (v40 < 0xFFFFFFF6) {
            int v41 = -1;
          }
          int v42 = __s[10];
          unsigned int v43 = v42 - 58;
          int v44 = v42 - 48;
          if (v43 < 0xFFFFFFF6) {
            int v44 = -1;
          }
          if ((v41 & 0x80000000) == 0 && (v44 & 0x80000000) == 0)
          {
            uint64_t result = 0;
            *(unsigned char *)(a1 + 6) = v41 | (16 * v44);
            int v45 = __s[11];
            unsigned int v46 = v45 - 58;
            int v47 = v45 - 48;
            if (v46 < 0xFFFFFFF6) {
              int v47 = -1;
            }
            int v48 = __s[12];
            unsigned int v49 = v48 - 58;
            int v50 = v48 - 48;
            if (v49 < 0xFFFFFFF6) {
              int v50 = -1;
            }
            if ((v47 & 0x80000000) == 0 && (v50 & 0x80000000) == 0)
            {
              uint64_t result = 0;
              *(unsigned char *)(a1 + 7) = v47 | (16 * v50);
              int v51 = __s[13];
              unsigned int v52 = v51 - 58;
              int v53 = v51 - 48;
              if (v52 < 0xFFFFFFF6) {
                int v53 = -1;
              }
              int v54 = __s[14];
              unsigned int v55 = v54 - 58;
              int v56 = v54 - 48;
              if (v55 < 0xFFFFFFF6) {
                int v56 = -1;
              }
              if ((v53 & 0x80000000) == 0 && (v56 & 0x80000000) == 0)
              {
                *(unsigned char *)(a1 + 8) = v53 | (16 * v56);
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t ETLGSMMakeStringFromIMEI(unsigned char *a1, uint64_t a2, unsigned char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 0;
  if (a1 && a3)
  {
    if (a2 < 0x10)
    {
      _ETLDebugPrint((uint64_t)"ETLGSMMakeStringFromIMEI", (uint64_t)"buffer capacity is %u, need %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, a2);
      return 0;
    }
    else
    {
      *a1 = (a3[1] >> 4) | 0x30;
      a1[1] = a3[2] & 0xF | 0x30;
      a1[2] = (a3[2] >> 4) | 0x30;
      a1[3] = a3[3] & 0xF | 0x30;
      a1[4] = (a3[3] >> 4) | 0x30;
      a1[5] = a3[4] & 0xF | 0x30;
      a1[6] = (a3[4] >> 4) | 0x30;
      a1[7] = a3[5] & 0xF | 0x30;
      a1[8] = (a3[5] >> 4) | 0x30;
      a1[9] = a3[6] & 0xF | 0x30;
      a1[10] = (a3[6] >> 4) | 0x30;
      a1[11] = a3[7] & 0xF | 0x30;
      a1[12] = (a3[7] >> 4) | 0x30;
      a1[13] = a3[8] & 0xF | 0x30;
      a1[14] = (a3[8] >> 4) | 0x30;
      a1[15] = 0;
      return 1;
    }
  }
  return v8;
}

void *ETLGSMGetIMEI(void *a1, uint64_t a2, uint64_t a3)
{
  unsigned int v38 = 0;
  long long v35 = 0u;
  long long v36 = 0u;
  uint64_t v37 = 0;
  memset(v33, 0, sizeof(v33));
  uint64_t v34 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    int v29 = "ETLGSMGetIMEI";
    int v30 = "Failed to create command frame\n";
LABEL_19:
    _ETLDebugPrint((uint64_t)v29, (uint64_t)v30, v6, v7, v8, v9, v10, v11, v32);
    goto LABEL_20;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
LABEL_20:
    IMEI = 0;
    goto LABEL_21;
  }
  int v39 = 67659;
  if ((HDLCFrameInject() & 1) == 0)
  {
    int v29 = "ETLSubsysAddHeaderInternal";
    int v30 = "Failed to inject\n";
    goto LABEL_19;
  }
  IMEI = malloc((2 * DWORD2(v35) + 32));
  if (!IMEI) {
    goto LABEL_21;
  }
  uint64_t v20 = HDLCFrameEncode();
  if (!v20) {
    goto LABEL_22;
  }
  uint64_t v21 = v20;
  int v39 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, IMEI, v20);
  }
  if (!*a1)
  {
LABEL_22:
    free(IMEI);
    goto LABEL_20;
  }
  int v22 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, IMEI, v21, &v39, 1, a3, 0);
  int v23 = v39;
  free(IMEI);
  IMEI = 0;
  if (v22 && v23 == v21)
  {
    LOBYTE(v39) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    IMEI = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v33, (uint64_t)&_ETLResponseRingBuffer, &v39, a3)&& v39 == 75)
    {
      IMEI = (void *)ETLGSMParseGetIMEI((uint64_t *)v33, a2, &v38, v24, v25, v26, v27, v28);
    }
  }
LABEL_21:
  HDLCFrameFree();
  HDLCFrameFree();
  return IMEI;
}

uint64_t ETLGSMIsValidIMEI(unsigned char *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  memset(__s2, 170, sizeof(__s2));
  if (a1)
  {
    __s2[0] = (a1[1] >> 4) | 0x30;
    unsigned int v1 = a1[2];
    __s2[1] = v1 & 0xF | 0x30;
    __s2[2] = (v1 >> 4) | 0x30;
    unsigned int v2 = a1[3];
    __s2[3] = v2 & 0xF | 0x30;
    __s2[4] = (v2 >> 4) | 0x30;
    unsigned int v3 = a1[4];
    __s2[5] = v3 & 0xF | 0x30;
    __s2[6] = (v3 >> 4) | 0x30;
    unsigned int v4 = a1[5];
    __s2[7] = v4 & 0xF | 0x30;
    __s2[8] = (v4 >> 4) | 0x30;
    unsigned int v5 = a1[6];
    __s2[9] = v5 & 0xF | 0x30;
    __s2[10] = (v5 >> 4) | 0x30;
    unsigned int v6 = a1[7];
    __s2[11] = v6 & 0xF | 0x30;
    __s2[12] = (v6 >> 4) | 0x30;
    unsigned int v7 = a1[8];
    __s2[13] = v7 & 0xF | 0x30;
    *(_WORD *)&__s2[14] = (v7 >> 4) | 0x30;
  }
  uint64_t result = strncmp((const char *)kDefaultIMEIs, __s2, 0xFuLL);
  if (result) {
    return strncmp((const char *)qword_1EAE4A5F8, __s2, 0xFuLL) != 0;
  }
  return result;
}

uint64_t ETLGSMSetIMEI(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, uint64_t a3)
{
  return ETLNVWriteWithStatus(a1, 550, a2, 9u, &v4, a3);
}

BOOL ETLLOGGetItemIDAndEquipIDFromCode(unsigned int a1, unsigned int *a2, unsigned int *a3)
{
  if (a1 >> 13 <= 6)
  {
    *a2 = a1 >> 12;
    *a3 = a1 & 0xFFF;
  }
  return a1 < 0xE000;
}

uint64_t ETLLOGGetCode(int a1, int a2)
{
  return (a2 + (a1 << 12));
}

unint64_t ETLLOGDisable(void *a1, uint64_t a2)
{
  long long v18 = 0u;
  long long v19 = 0u;
  uint64_t v20 = 0;
  memset(v16, 0, sizeof(v16));
  uint64_t v17 = 0;
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_20;
  }
  if (HDLCFrameGetFreeSpace() <= 7)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v4, v5, v6, v7, v8, v9, 8);
    goto LABEL_20;
  }
  uint64_t v21 = 115;
  if (!HDLCFrameInject())
  {
LABEL_20:
    unint64_t v10 = 0;
    goto LABEL_21;
  }
  unint64_t v10 = (unint64_t)malloc((2 * DWORD2(v18) + 32));
  if (!v10) {
    goto LABEL_21;
  }
  uint64_t v11 = HDLCFrameEncode();
  if (!v11) {
    goto LABEL_22;
  }
  uint64_t v12 = v11;
  LODWORD(v21) = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, unint64_t, uint64_t))*(&gDelegate + 1))("", 0, v10, v11);
  }
  if (!*a1)
  {
LABEL_22:
    free((void *)v10);
    goto LABEL_20;
  }
  int v13 = ((uint64_t (*)(void *, unint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, void))*a1)(a1, v10, v12, &v21, 1, a2, 0);
  int v14 = v21;
  free((void *)v10);
  unint64_t v10 = 0;
  if (v13 && v14 == v12)
  {
    LOBYTE(v21) = 115;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    unint64_t v10 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v16, (uint64_t)&_ETLResponseRingBuffer, &v21, a2))
    {
      if (**(unsigned char **)&v16[0] == 115 && DWORD2(v16[0]) >= 8)
      {
        unint64_t v10 = 0;
        if (!*(_DWORD *)(*(void *)&v16[0] + 4) && (DWORD2(v16[0]) & 0xFFFFFFFC) != 8) {
          unint64_t v10 = *(_DWORD *)(*(void *)&v16[0] + 8) == 0;
        }
      }
    }
  }
LABEL_21:
  HDLCFrameFree();
  HDLCFrameFree();
  return v10;
}

uint64_t ETLLOGGetIDs(void *a1, void *a2, int a3, unsigned int *a4, uint64_t a5)
{
  long long v25 = 0u;
  long long v26 = 0u;
  uint64_t v27 = 0;
  memset(v23, 0, sizeof(v23));
  uint64_t v24 = 0;
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_24;
  }
  if (HDLCFrameGetFreeSpace() <= 7)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v10, v11, v12, v13, v14, v15, 8);
    goto LABEL_24;
  }
  uint64_t v28 = 0x100000073;
  if (!HDLCFrameInject())
  {
LABEL_24:
    uint64_t v16 = 0;
    goto LABEL_25;
  }
  uint64_t v16 = (uint64_t)malloc((2 * DWORD2(v25) + 32));
  if (!v16) {
    goto LABEL_25;
  }
  uint64_t v17 = HDLCFrameEncode();
  if (!v17) {
    goto LABEL_26;
  }
  uint64_t v18 = v17;
  LODWORD(v28) = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
  }
  if (!*a1)
  {
LABEL_26:
    free((void *)v16);
    goto LABEL_24;
  }
  int v19 = ((uint64_t (*)(void *, uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, void))*a1)(a1, v16, v18, &v28, 1, a5, 0);
  int v20 = v28;
  free((void *)v16);
  uint64_t v16 = 0;
  if (v19 && v20 == v18)
  {
    LOBYTE(v28) = 115;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    uint64_t v16 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v23, (uint64_t)&_ETLResponseRingBuffer, &v28, a5))
    {
      if (**(unsigned char **)&v23[0] == 115 && DWORD2(v23[0]) >= 8)
      {
        uint64_t v16 = 0;
        if (*(_DWORD *)(*(void *)&v23[0] + 4) == 1 && (DWORD2(v23[0]) & 0xFFFFFFFC) != 8)
        {
          if (!(*(_DWORD *)(*(void *)&v23[0] + 8) | BYTE8(v23[0]) & 3))
          {
            if (4 * a3 >= (DWORD2(v23[0]) - 12)) {
              size_t v21 = (DWORD2(v23[0]) - 12);
            }
            else {
              size_t v21 = (4 * a3);
            }
            memcpy(a2, (const void *)(*(void *)&v23[0] + 12), v21);
            *a4 = v21 >> 2;
            uint64_t v16 = 1;
            goto LABEL_25;
          }
          goto LABEL_24;
        }
      }
    }
  }
LABEL_25:
  HDLCFrameFree();
  HDLCFrameFree();
  return v16;
}

uint64_t ETLLOGSetMask(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a4;
  uint64_t v13 = (a4 + 7) >> 3;
  _ETLDebugPrint((uint64_t)"ETLLOGSetMask", (uint64_t)"Set Mask for id %u, bits = %u (%u bytes)\n", (uint64_t)a3, a4, a5, a6, a7, a8, a2);
  memset(v47, 0, sizeof(v47));
  uint64_t v48 = 0;
  memset(v45, 0, sizeof(v45));
  uint64_t v46 = 0;
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_11;
  }
  if (HDLCFrameGetFreeSpace() <= 7)
  {
    uint64_t v44 = 8;
    goto LABEL_9;
  }
  uint64_t v49 = 0x300000073;
  if (HDLCFrameInject())
  {
    if (v9 > 0x1000)
    {
      _ETLDebugPrint((uint64_t)"ETLLOGCreateSetMaskCommand", (uint64_t)"Bits %u too large\n", v14, v15, v16, v17, v18, v19, v9);
      goto LABEL_11;
    }
    if (!v9)
    {
      int v20 = "ETLLOGCreateSetMaskCommand";
      size_t v21 = "Bits must be nonzero\n";
      goto LABEL_10;
    }
    if (HDLCFrameGetFreeSpace() < (int)v13 + 8)
    {
      uint64_t v44 = (v13 + 8);
LABEL_9:
      int v20 = "ETLRequireFreeSpace";
      size_t v21 = "Need %u bytes free space, but only have %u\n";
LABEL_10:
      _ETLDebugPrint((uint64_t)v20, (uint64_t)v21, v14, v15, v16, v17, v18, v19, v44);
      goto LABEL_11;
    }
    if (!HDLCFrameInjectUnsignedInt()) {
      goto LABEL_11;
    }
    if (!HDLCFrameInjectUnsignedInt()) {
      goto LABEL_11;
    }
    if (!HDLCFrameInject()) {
      goto LABEL_11;
    }
    if (!ETLSendCommand(a1, (uint64_t)v47, a5)) {
      goto LABEL_11;
    }
    LOBYTE(v49) = 115;
    if (!ETLFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v45, &v49, a5)) {
      goto LABEL_11;
    }
    uint64_t v30 = *(void *)&v45[0];
    if (**(unsigned char **)&v45[0] == 115
      && DWORD2(v45[0]) >= 8
      && *(_DWORD *)(*(void *)&v45[0] + 4) == 3
      && (DWORD2(v45[0]) & 0xFFFFFFFC) != 8
      && !*(_DWORD *)(*(void *)&v45[0] + 8))
    {
      if ((DWORD2(v45[0]) - 12) >= 4)
      {
        if (*(_DWORD *)(*(void *)&v45[0] + 12) == a2)
        {
          if ((DWORD2(v45[0]) - 16) >= 4)
          {
            unsigned int v31 = *(_DWORD *)(*(void *)&v45[0] + 16);
            unsigned int v32 = DWORD2(v45[0]) - 20;
            if (v31 >= v9)
            {
              uint64_t v33 = v13;
            }
            else
            {
              _ETLDebugPrint((uint64_t)"ETLLOGParseSetMaskResponse", (uint64_t)"Warning: response bits %u is less than request %u\n", v24, v25, v26, v27, v28, v29, *(unsigned int *)(*(void *)&v45[0] + 16));
              uint64_t v33 = (v31 + 7) >> 3;
              LODWORD(v9) = v31;
            }
            if (v33 <= v32)
            {
              uint64_t v34 = (unsigned __int8 *)(v30 + 20);
              unint64_t v35 = (unint64_t)v9 >> 3;
              int v36 = memcmp(v34, a3, v35);
              int v43 = (a3[v35] ^ v34[v35]) & ~(-1 << (v9 & 7));
              if (!(v36 | v43))
              {
                uint64_t v22 = 1;
                goto LABEL_12;
              }
              _ETLDebugPrint((uint64_t)"ETLLOGParseSetMaskResponse", (uint64_t)"Error: Mask response mismatch\n", v37, v38, v39, v40, v41, v42, v44);
              if (v43) {
                _ETLDebugPrint((uint64_t)"ETLLOGParseSetMaskResponse", (uint64_t)"Error: Mask[%u]: 0x%x, and Received Mask[%u]: 0x%x\n", v24, v25, v26, v27, v28, v29, v35);
              }
              if ((_ETLDebugFlags & 2) != 0)
              {
                ((void (*)(const char *, uint64_t, unsigned __int8 *, uint64_t))*(&gDelegate + 1))("Sent:", 2, a3, v13);
                if ((_ETLDebugFlags & 2) != 0) {
                  ((void (*)(const char *, uint64_t, unsigned __int8 *, uint64_t))*(&gDelegate + 1))("Received:", 2, v34, v33);
                }
              }
              goto LABEL_32;
            }
            uint64_t v13 = v33;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLLOGParseSetMaskResponse", (uint64_t)"ID mismatch. Requested %u, response %u\n", v24, v25, v26, v27, v28, v29, a2);
        }
      }
      _ETLDebugPrint((uint64_t)"ETLLOGParseSetMaskResponse", (uint64_t)"Error: Received Mask bits upto %u bytes, but the actual payload has %u bytes.\n", v24, v25, v26, v27, v28, v29, v13);
    }
LABEL_32:
    _ETLDebugPrint((uint64_t)"ETLLOGParseSetMaskResponse", (uint64_t)"Failed on ID %u\n", v24, v25, v26, v27, v28, v29, a2);
  }
LABEL_11:
  uint64_t v22 = 0;
LABEL_12:
  HDLCFrameFree();
  HDLCFrameFree();
  return v22;
}

uint64_t ETLLOGSetMaskWithRetry(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a6) {
    return 0;
  }
  int v8 = a6;
  do
  {
    uint64_t v14 = ETLLOGSetMask((uint64_t (**)(void, void *, uint64_t, int *, uint64_t, uint64_t, void))a1, a2, a3, a4, a5, a6, a7, a8);
    if (v14) {
      break;
    }
    TelephonyUtilRingBufferReset();
    size_t v21 = *(void (**)(uint64_t))(a1 + 24);
    if (v21) {
      v21(a1);
    }
    _ETLDebugPrint((uint64_t)"ETLLOGSetMaskWithRetry", (uint64_t)"Trying again\n", v15, v16, v17, v18, v19, v20, v23);
    --v8;
  }
  while (v8);
  return v14;
}

uint64_t ETLLOGClearAllMasksWithRetry(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a3;
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  _OWORD v33[2] = v11;
  void v33[3] = v11;
  v33[0] = v11;
  v33[1] = v11;
  unsigned int v31 = -1431655766;
  _ETLDebugPrint((uint64_t)"ETLLOGClearAllMasksWithRetry", (uint64_t)"Clearing All Masks\n", a3, a4, a5, a6, a7, a8, v29);
  uint64_t result = ETLLOGGetIDs(a1, v33, 16, &v31, a2);
  if (result)
  {
    memset(v32, 0, sizeof(v32));
    if (v8)
    {
      uint64_t v16 = 0;
      int v17 = v31 - 1;
      if (v31 - 1 >= 0xD) {
        int v17 = 13;
      }
      uint64_t v30 = (v17 + 1);
      while (2)
      {
        unsigned int v18 = *((_DWORD *)v33 + v16);
        if (v18 >= 0x1000) {
          unsigned int v19 = 4096;
        }
        else {
          unsigned int v19 = *((_DWORD *)v33 + v16);
        }
        if (v18) {
          uint64_t v20 = v19;
        }
        else {
          uint64_t v20 = 4096;
        }
        unsigned int v21 = v8;
        while ((ETLLOGSetMask((uint64_t (**)(void, void *, uint64_t, int *, uint64_t, uint64_t, void))a1, v16, (unsigned __int8 *)v32, v20, a2, v13, v14, v15) & 1) == 0)
        {
          if (v21 >= 2)
          {
            TelephonyUtilRingBufferReset();
            uint64_t v28 = (void (*)(void *))a1[3];
            if (v28) {
              v28(a1);
            }
            _ETLDebugPrint((uint64_t)"ETLLOGClearAllMasksWithRetry", (uint64_t)"Trying again\n", v22, v23, v24, v25, v26, v27, v30);
          }
          if (!--v21) {
            return 0;
          }
        }
        if (++v16 != v30) {
          continue;
        }
        break;
      }
    }
    return 1;
  }
  return result;
}

uint64_t ETLLOGClearAllEnabledMasksWithRetry(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v34 = a5;
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  _OWORD v37[2] = v12;
  v37[3] = v12;
  v37[0] = v12;
  v37[1] = v12;
  unsigned int v35 = -1431655766;
  _ETLDebugPrint((uint64_t)"ETLLOGClearAllEnabledMasksWithRetry", (uint64_t)"Clearing All Masks\n", a3, a4, a5, a6, a7, a8, v31);
  uint64_t result = ETLLOGGetIDs(a1, v37, 16, &v35, a4);
  if (result)
  {
    int v17 = v35 - 1;
    if (v35 - 1 >= 0xD) {
      int v17 = 13;
    }
    unsigned int v33 = v17;
    memset(v36, 0, sizeof(v36));
    if (a2 && v34)
    {
      uint64_t v18 = 0;
      do
      {
        uint64_t v19 = *(unsigned int *)(a3 + 4 * v18);
        if (v19 <= v33)
        {
          unsigned int v20 = *((_DWORD *)v37 + v19);
          if (v20 >= 0x1000) {
            unsigned int v21 = 4096;
          }
          else {
            unsigned int v21 = *((_DWORD *)v37 + v19);
          }
          if (v20) {
            uint64_t v22 = v21;
          }
          else {
            uint64_t v22 = 4096;
          }
          unsigned int v23 = v34;
          while ((ETLLOGSetMask((uint64_t (**)(void, void *, uint64_t, int *, uint64_t, uint64_t, void))a1, v19, (unsigned __int8 *)v36, v22, a4, v14, v15, v16) & 1) == 0)
          {
            if (v23 >= 2)
            {
              TelephonyUtilRingBufferReset();
              uint64_t v30 = (void (*)(void *))a1[3];
              if (v30) {
                v30(a1);
              }
              _ETLDebugPrint((uint64_t)"ETLLOGClearAllEnabledMasksWithRetry", (uint64_t)"Trying again\n", v24, v25, v26, v27, v28, v29, v32);
            }
            if (!--v23) {
              return 0;
            }
          }
        }
        ++v18;
      }
      while (v18 != a2);
    }
    return 1;
  }
  return result;
}

const char *ETLLOGEquipIDAsString(unsigned int a1)
{
  if (a1 <= 0xD) {
    return off_1E6E6FF58[a1];
  }
  else {
    return "Unknown";
  }
}

uint64_t APPLIB_DIAG_PM_ReadVRegLevel(void *a1, unsigned int a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  bzero(a1, a2);
  if (!HDLCFrameCreateUplink()) {
    return 0xFFFFFFFFLL;
  }
  HDLCFrameInject();
  LODWORD(result) = HDLCFrameEncode();
  if (result) {
    return result;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t APPLIB_DIAG_PM_ParseReadVRegLevelResponse(uint64_t a1, unsigned int a2, unsigned char *a3, _WORD *a4)
{
  if (a2 < 3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *a3 = *(unsigned char *)(a1 + 3);
  *a4 = *(_WORD *)(a1 + 4);
  return result;
}

uint64_t ETLHSICParseCommandHeader(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = ETLMaverickParseFACTORYResponseHeader(a1, a2, 48, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v18 = *a2;
    if ((*(_DWORD *)(a1 + 8) - v18) <= 1)
    {
      _ETLDebugPrint((uint64_t)"ETLHSICParseCommandHeader", (uint64_t)"Need %u bytes, but only have %u\n", v12, v13, v14, v15, v16, v17, 2);
      return 0;
    }
    else
    {
      uint64_t v19 = *(unsigned __int16 *)(*(void *)a1 + v18);
      *a3 = v19;
      if (v19) {
        _ETLDebugPrint((uint64_t)"ETLHSICParseCommandHeader", (uint64_t)"Command status was %u\n", v12, v13, v14, v15, v16, v17, v19);
      }
      return 1;
    }
  }
  return result;
}

uint64_t ETLHSICCreateEchoCommand(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v9, v10, v11, v12, v13, v14, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    uint64_t v22 = "ETLSubsysAddHeaderInternal";
    unsigned int v23 = "Failed to inject\n";
LABEL_16:
    _ETLDebugPrint((uint64_t)v22, (uint64_t)v23, v15, v16, v17, v18, v19, v20, v24);
    return 0;
  }
  if (HDLCFrameGetFreeSpace() <= 0xB)
  {
    uint64_t v24 = 12;
    uint64_t v22 = "ETLRequireFreeSpace";
    unsigned int v23 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_16;
  }
  if (!HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedInt()
    || !HDLCFrameInjectUnsignedInt()
    || !ETLRequireFreeSpace(a1, (a6 + 2))
    || !HDLCFrameInjectUnsignedShort())
  {
    return 0;
  }

  return HDLCFrameInject();
}

uint64_t ETLHSICParseEchoCommand(unsigned int *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a1[2];
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    unsigned int v9 = **(_DWORD **)a1;
    if (v9 == 75)
    {
      if (BYTE1(v9) == 254)
      {
        uint64_t v10 = HIWORD(v9);
        if (v10 == 48)
        {
          if (v8 - 4 <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLHSICParseCommandHeader", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, 2);
            return 0;
          }
          else
          {
            uint64_t v11 = *(unsigned __int16 *)(*(void *)a1 + 4);
            *a2 = v11;
            if (v11) {
              _ETLDebugPrint((uint64_t)"ETLHSICParseCommandHeader", (uint64_t)"Command status was %u\n", a3, a4, a5, a6, a7, a8, v11);
            }
            return 1;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v9));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

uint64_t ETLUARTCreateSetInactivityTimerCommand()
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v1, v2, v3, v4, v5, v6, FreeSpace);
    return 0;
  }
  else if (HDLCFrameInject())
  {
    if (HDLCFrameGetFreeSpace() <= 3)
    {
      _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v13, v14, v15, v16, v17, v18, 4);
      return 0;
    }
    else
    {
      return HDLCFrameInjectUnsignedInt();
    }
  }
  else
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v7, v8, v9, v10, v11, v12, v20);
    return 0;
  }
}

BOOL ETLUARTParseSetInactivityTimerResponse(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a1[2];
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    unsigned int v9 = **(_DWORD **)a1;
    if (v9 == 75)
    {
      if (BYTE1(v9) == 253)
      {
        uint64_t v10 = HIWORD(v9);
        if (v10 == 44)
        {
          if (v8 == 4)
          {
            _ETLDebugPrint((uint64_t)"ETLUARTParseSetInactivityTimerResponse", (uint64_t)"Only have %u bytes, need %u\n", a3, a4, a5, a6, a7, a8, 0);
            return 0;
          }
          else
          {
            return *(unsigned char *)(*(void *)a1 + 4) == 1;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v9));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

unint64_t ETLUARTSetInactivityTimer(void *a1, uint64_t a2, uint64_t a3)
{
  long long v40 = 0u;
  long long v41 = 0u;
  uint64_t v42 = 0;
  memset(v38, 0, sizeof(v38));
  uint64_t v39 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    unsigned int v34 = "ETLUARTSetInactivityTimer";
    unsigned int v35 = "Failed to create command frame\n";
LABEL_24:
    _ETLDebugPrint((uint64_t)v34, (uint64_t)v35, v5, v6, v7, v8, v9, v10, v37);
    goto LABEL_25;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
    goto LABEL_25;
  }
  unsigned int v43 = 2948427;
  if ((HDLCFrameInject() & 1) == 0)
  {
    unsigned int v34 = "ETLSubsysAddHeaderInternal";
    unsigned int v35 = "Failed to inject\n";
    goto LABEL_24;
  }
  if (HDLCFrameGetFreeSpace() <= 3)
  {
    uint64_t v37 = 4;
    unsigned int v34 = "ETLRequireFreeSpace";
    unsigned int v35 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_24;
  }
  if (!HDLCFrameInjectUnsignedInt())
  {
LABEL_25:
    unint64_t v18 = 0;
    goto LABEL_26;
  }
  unint64_t v18 = (unint64_t)malloc((2 * DWORD2(v40) + 32));
  if (!v18) {
    goto LABEL_26;
  }
  uint64_t v19 = HDLCFrameEncode();
  if (!v19) {
    goto LABEL_27;
  }
  uint64_t v20 = v19;
  unsigned int v43 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, unint64_t, uint64_t))*(&gDelegate + 1))("", 0, v18, v19);
  }
  if (!*a1)
  {
LABEL_27:
    free((void *)v18);
    goto LABEL_25;
  }
  int v21 = ((uint64_t (*)(void *, unint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, void))*a1)(a1, v18, v20, &v43, 1, a3, 0);
  unsigned int v22 = v43;
  free((void *)v18);
  unint64_t v18 = 0;
  if (v21 && v22 == v20)
  {
    LOBYTE(v43) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    unint64_t v18 = 0;
    if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v38, (uint64_t)&_ETLResponseRingBuffer, &v43, a3))
    {
      if (v43 == 75)
      {
        unsigned int v43 = 0;
        unint64_t v18 = 0;
        if (ETLMaverickParseBSPResponseHeader((uint64_t)v38, &v43, 44, v23, v24, v25, v26, v27))
        {
          if (DWORD2(v38[0]) != v43)
          {
            unint64_t v18 = *(unsigned __int8 *)(*(void *)&v38[0] + v43) == 1;
            goto LABEL_26;
          }
          _ETLDebugPrint((uint64_t)"ETLUARTParseSetInactivityTimerResponse", (uint64_t)"Only have %u bytes, need %u\n", v28, v29, v30, v31, v32, v33, 0);
          goto LABEL_25;
        }
      }
    }
  }
LABEL_26:
  HDLCFrameFree();
  HDLCFrameFree();
  return v18;
}

uint64_t ETLMESSAGEGetSubsystemRangeSize(unsigned __int16 *a1)
{
  return a1[1] - *a1 + 1;
}

uint64_t ETLMESSAGEGetSubsystemIDRanges(void *a1, unsigned int a2, void *a3, unsigned int *a4, uint64_t a5)
{
  long long v28 = 0u;
  long long v29 = 0u;
  uint64_t v30 = 0;
  memset(v26, 0, sizeof(v26));
  uint64_t v27 = 0;
  *a4 = 0;
  uint64_t v10 = 0;
  if (HDLCFrameCreateUplink())
  {
    LOWORD(v31) = 381;
    if (HDLCFrameGetFreeSpace() <= 1)
    {
      uint64_t v25 = 2;
      unsigned int v22 = "ETLRequireFreeSpace";
      uint64_t v23 = "Need %u bytes free space, but only have %u\n";
      goto LABEL_23;
    }
    if (!HDLCFrameInject()) {
      goto LABEL_24;
    }
    uint64_t v10 = (uint64_t)malloc((2 * DWORD2(v28) + 32));
    if (v10)
    {
      uint64_t v17 = HDLCFrameEncode();
      if (!v17) {
        goto LABEL_26;
      }
      uint64_t v18 = v17;
      int v31 = -1431655766;
      if ((_ETLDebugFlags & 2) != 0) {
        ((void (*)(const char *, void, uint64_t, uint64_t))*(&gDelegate + 1))("", 0, v10, v17);
      }
      if (!*a1)
      {
LABEL_26:
        free((void *)v10);
        goto LABEL_24;
      }
      int v19 = ((uint64_t (*)(void *, uint64_t, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v10, v18, &v31, 1, a5, 0);
      int v20 = v31;
      free((void *)v10);
      uint64_t v10 = 0;
      if (v19)
      {
        if (v20 == v18)
        {
          LOBYTE(v31) = 125;
          if (!_ETLResponseRingBuffer) {
            TelephonyUtilRingBufferInitialize();
          }
          if (ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v26, (uint64_t)&_ETLResponseRingBuffer, &v31, a5))
          {
            if (DWORD2(v26[0]) >= 2)
            {
              if (*(unsigned char *)(*(void *)&v26[0] + 1) == 1)
              {
                if ((DWORD2(v26[0]) - 8) <= 0xFFFFFFF9)
                {
                  if (*(unsigned char *)(*(void *)&v26[0] + 2) == 1)
                  {
                    if (*(_DWORD *)(*(void *)&v26[0] + 4) < a2) {
                      a2 = *(_DWORD *)(*(void *)&v26[0] + 4);
                    }
                    size_t v21 = 4 * a2;
                    if (DWORD2(v26[0]) - 8 >= v21)
                    {
                      memcpy(a3, (const void *)(*(void *)&v26[0] + 8), v21);
                      *a4 = a2;
                      uint64_t v10 = 1;
                      goto LABEL_25;
                    }
                  }
                  else
                  {
                    _ETLDebugPrint((uint64_t)"ETLMESSAGEParseGetSubsystemIDRangesResponse", (uint64_t)"Status was %u\n", v11, v12, v13, v14, v15, v16, *(unsigned __int8 *)(*(void *)&v26[0] + 2));
                  }
                }
              }
              else
              {
                _ETLDebugPrint((uint64_t)"ETLMESSAGEParseGetSubsystemIDRangesResponse", (uint64_t)"Response subcommand %u mismatches expected %u\n", v11, v12, v13, v14, v15, v16, *(unsigned __int8 *)(*(void *)&v26[0] + 1));
              }
            }
LABEL_24:
            uint64_t v10 = 0;
            goto LABEL_25;
          }
          unsigned int v22 = "ETLMESSAGEFindMatchingResponse";
          uint64_t v23 = "Failed to find matching response\n";
LABEL_23:
          _ETLDebugPrint((uint64_t)v22, (uint64_t)v23, v11, v12, v13, v14, v15, v16, v25);
          goto LABEL_24;
        }
      }
    }
  }
LABEL_25:
  HDLCFrameFree();
  HDLCFrameFree();
  return v10;
}

uint64_t ETLMESSAGEGetSubsystemMasksWithRetry(void *a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a6;
  int v9 = *a2;
  unsigned int v10 = a2[1] - v9 + 1;
  unsigned __int16 v61 = *a2;
  *a6 = 0;
  if (a8)
  {
    unsigned int v11 = a8;
    int v12 = a3;
    unsigned int v54 = a7;
    unsigned int v56 = a8;
    while (1)
    {
      unsigned int v59 = a4;
      long long __dst = (void *)a5;
      if (v10 >= 0x3D) {
        __int16 v14 = 61;
      }
      else {
        __int16 v14 = v10;
      }
      unsigned __int16 v62 = v9 + v14 - 1;
      _ETLDebugPrint((uint64_t)"ETLMESSAGEGetSubsystemMasksWithRetry", (uint64_t)"Partition Range to 0x%08X, max 0x%x\n", a3, a4, a5, (uint64_t)a6, a7, a8, (unsigned __int16)v9 | (v62 << 16));
      while (1)
      {
        long long v65 = 0u;
        long long v66 = 0u;
        uint64_t v67 = 0;
        memset(v63, 0, sizeof(v63));
        uint64_t v64 = 0;
        if (!HDLCFrameCreateUplink()) {
          goto LABEL_36;
        }
        if (v12)
        {
          if (v12 != 1)
          {
            _ETLDebugPrint((uint64_t)"ETLMESSAGEGetSubcommandTypeForMaskType", (uint64_t)"Invald mask type %u\n", v15, v16, v17, v18, v19, v20, a3);
            goto LABEL_36;
          }
          char v21 = 3;
        }
        else
        {
          char v21 = 2;
        }
        LOBYTE(v68[0]) = 125;
        BYTE1(v68[0]) = v21;
        if (HDLCFrameGetFreeSpace() <= 1)
        {
          uint64_t v37 = 2;
          goto LABEL_34;
        }
        if (!HDLCFrameInject()) {
          goto LABEL_36;
        }
        if (HDLCFrameGetFreeSpace() <= 3)
        {
          uint64_t v37 = 4;
LABEL_34:
          uint64_t v52 = v37;
          uint64_t v38 = "ETLRequireFreeSpace";
          uint64_t v39 = "Need %u bytes free space, but only have %u\n";
LABEL_35:
          _ETLDebugPrint((uint64_t)v38, (uint64_t)v39, v22, v23, v24, v25, v26, v27, v52);
LABEL_36:
          LODWORD(v28) = 0;
          char v33 = 0;
          goto LABEL_37;
        }
        if (!HDLCFrameInject()) {
          goto LABEL_36;
        }
        unsigned int v55 = v8;
        long long v28 = malloc((2 * DWORD2(v65) + 32));
        if (!v28) {
          goto LABEL_43;
        }
        uint64_t v29 = HDLCFrameEncode();
        if (!v29) {
          goto LABEL_42;
        }
        uint64_t v30 = v29;
        v68[0] = -1431655766;
        if ((_ETLDebugFlags & 2) != 0) {
          ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v28, v29);
        }
        if (!*a1)
        {
LABEL_42:
          free(v28);
          LODWORD(v28) = 0;
LABEL_43:
          char v33 = 0;
          uint64_t v8 = v55;
          goto LABEL_37;
        }
        int v53 = ((uint64_t (*)(void *, void *, uint64_t, _DWORD *, uint64_t, void, void))*a1)(a1, v28, v30, v68, 1, v54, 0);
        int v31 = v68[0];
        free(v28);
        LODWORD(v28) = 0;
        if (v53)
        {
          int v32 = v31;
          char v33 = 0;
          BOOL v34 = v32 == v30;
          uint64_t v8 = v55;
          if (v34)
          {
            LOBYTE(v68[0]) = 125;
            if (!_ETLResponseRingBuffer) {
              TelephonyUtilRingBufferInitialize();
            }
            if ((ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v63, (uint64_t)&_ETLResponseRingBuffer, v68, v54) & 1) == 0)
            {
              uint64_t v38 = "ETLMESSAGEFindMatchingResponse";
              uint64_t v39 = "Failed to find matching response\n";
              goto LABEL_35;
            }
            if (DWORD2(v63[0]) < 2) {
              goto LABEL_36;
            }
            uint64_t v35 = *(unsigned __int8 *)(*(void *)&v63[0] + 1);
            if (v12) {
              int v36 = 3;
            }
            else {
              int v36 = 2;
            }
            if (v36 != v35)
            {
              _ETLDebugPrint((uint64_t)"ETLMESSAGEParseGetSubsystemMasksResponse", (uint64_t)"Response subcommand 0x%x mismatches expected 0x%x\n", v22, v23, v24, v25, v26, v27, v35);
              goto LABEL_36;
            }
            if ((DWORD2(v63[0]) - 8) > 0xFFFFFFF9) {
              goto LABEL_36;
            }
            if (*(unsigned char *)(*(void *)&v63[0] + 6) != 1)
            {
              _ETLDebugPrint((uint64_t)"ETLMESSAGEParseGetSubsystemMasksResponse", (uint64_t)"Status was %u\n", v22, v23, v24, v25, v26, v27, *(unsigned __int8 *)(*(void *)&v63[0] + 6));
              goto LABEL_36;
            }
            int v47 = *(unsigned __int16 *)(*(void *)&v63[0] + 2);
            int v48 = *(unsigned __int16 *)(*(void *)&v63[0] + 4);
            if (v62 != v48 || v61 != v47)
            {
              _ETLDebugPrint((uint64_t)"ETLMESSAGEParseGetSubsystemMasksResponse", (uint64_t)"Returned range 0x%x didn't match requested 0x%x\n", v22, v23, v24, v25, v26, v27, v47 | (v48 << 16));
              goto LABEL_36;
            }
            int v49 = v48 - v47;
            if (v49 + 1 < v59) {
              LODWORD(v28) = v49 + 1;
            }
            else {
              LODWORD(v28) = v59;
            }
            if (DWORD2(v63[0]) - 8 < (4 * v28)) {
              goto LABEL_36;
            }
            memcpy(__dst, (const void *)(*(void *)&v63[0] + 8), (4 * v28));
            char v33 = 1;
          }
        }
        else
        {
          char v33 = 0;
          uint64_t v8 = v55;
        }
LABEL_37:
        HDLCFrameFree();
        HDLCFrameFree();
        if (v33) {
          break;
        }
        if (v11 >= 2)
        {
          TelephonyUtilRingBufferReset();
          uint64_t v46 = (void (*)(void *))a1[3];
          if (v46) {
            v46(a1);
          }
          _ETLDebugPrint((uint64_t)"ETLMESSAGEGetSubsystemMasksWithRetry", (uint64_t)"Trying again\n", v40, v41, v42, v43, v44, v45, v52);
        }
        if (!--v11) {
          goto LABEL_67;
        }
      }
      if (v28)
      {
        *v8 += v28;
        a5 = (uint64_t)__dst + 4 * v28;
        a4 = v59 - v28;
        v10 -= v28;
        LOWORD(v9) = v61 + (_WORD)v28;
        unsigned __int16 v61 = v9;
        unsigned int v11 = v56;
        if (a2[1] >= (unsigned __int16)v9) {
          continue;
        }
      }
      return 1;
    }
  }
  if (v10 >= 0x3D) {
    int v51 = 61;
  }
  else {
    int v51 = v10;
  }
  _ETLDebugPrint((uint64_t)"ETLMESSAGEGetSubsystemMasksWithRetry", (uint64_t)"Partition Range to 0x%08X, max 0x%x\n", a3, a4, a5, (uint64_t)a6, a7, a8, (v9 | ((v9 + v51) << 16)) - 0x10000);
LABEL_67:
  uint64_t result = 0;
  _DWORD *v8 = 0;
  return result;
}

uint64_t ETLMESSAGESetSubsystemRuntimeMasksWithRetry(void *a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *a2;
  unsigned int v9 = a2[1] - v8 + 1;
  unsigned __int16 v46 = *a2;
  if (!a5)
  {
    if (v9 >= 0x3D) {
      unsigned int v9 = 61;
    }
    _ETLDebugPrint((uint64_t)"ETLMESSAGESetSubsystemRuntimeMasksWithRetry", (uint64_t)"Partition Range to 0x%08X, max 0x%x\n", a3, a4, a5, a6, a7, a8, (v8 | ((v8 + v9) << 16)) - 0x10000);
    return 0;
  }
  unsigned int v10 = a5;
  uint64_t v45 = a3;
  unsigned int v44 = a4;
  unsigned int v41 = a5;
  do
  {
    if (v9 >= 0x3D) {
      int v12 = 61;
    }
    else {
      int v12 = v9;
    }
    unsigned int v42 = v9;
    unsigned int v43 = v12;
    unsigned __int16 v47 = v8 + v12 - 1;
    _ETLDebugPrint((uint64_t)"ETLMESSAGESetSubsystemRuntimeMasksWithRetry", (uint64_t)"Partition Range to 0x%08X, max 0x%x\n", a3, a4, a5, a6, a7, a8, (unsigned __int16)v8 | (v47 << 16));
    while (1)
    {
      long long v50 = 0u;
      long long v51 = 0u;
      uint64_t v52 = 0;
      memset(v48, 0, sizeof(v48));
      uint64_t v49 = 0;
      if (HDLCFrameCreateUplink())
      {
        LOWORD(v53[0]) = 1149;
        if (HDLCFrameGetFreeSpace() <= 1)
        {
          uint64_t v37 = 2;
          goto LABEL_15;
        }
        if (HDLCFrameInject())
        {
          int v19 = 4 * (v47 - v46 + 1);
          if (HDLCFrameGetFreeSpace() < v19 + 4)
          {
            uint64_t v37 = (v19 + 4);
LABEL_15:
            uint64_t v20 = "ETLRequireFreeSpace";
            char v21 = "Need %u bytes free space, but only have %u\n";
LABEL_16:
            _ETLDebugPrint((uint64_t)v20, (uint64_t)v21, v13, v14, v15, v16, v17, v18, v37);
            goto LABEL_17;
          }
          if (!HDLCFrameInject()) {
            goto LABEL_17;
          }
          if (!HDLCFrameInjectUnsignedShort()) {
            goto LABEL_17;
          }
          if (!HDLCFrameInject()) {
            goto LABEL_17;
          }
          uint64_t v29 = malloc((2 * DWORD2(v50) + 32));
          if (!v29) {
            goto LABEL_17;
          }
          uint64_t v30 = v29;
          uint64_t v31 = HDLCFrameEncode();
          if (!v31) {
            goto LABEL_38;
          }
          uint64_t v32 = v31;
          v53[0] = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v30, v31);
          }
          if (!*a1)
          {
LABEL_38:
            free(v30);
            goto LABEL_17;
          }
          int v33 = ((uint64_t (*)(void *, void *, uint64_t, _DWORD *, uint64_t, void, void))*a1)(a1, v30, v32, v53, 1, v44, 0);
          int v38 = v53[0];
          int v39 = v33;
          free(v30);
          if (!v39 || v38 != v32) {
            goto LABEL_17;
          }
          LOBYTE(v53[0]) = 125;
          if (!_ETLResponseRingBuffer) {
            TelephonyUtilRingBufferInitialize();
          }
          if ((ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v48, (uint64_t)&_ETLResponseRingBuffer, v53, v44) & 1) == 0)
          {
            uint64_t v20 = "ETLMESSAGEFindMatchingResponse";
            char v21 = "Failed to find matching response\n";
            goto LABEL_16;
          }
          if (DWORD2(v48[0]) >= 2)
          {
            if (*(unsigned char *)(*(void *)&v48[0] + 1) != 4)
            {
              _ETLDebugPrint((uint64_t)"ETLMESSAGEParseSetSubsystemRunTimeMasksResponse", (uint64_t)"Response subcommand 0x%x mismatches expected 0x%x\n", v13, v14, v15, v16, v17, v18, *(unsigned __int8 *)(*(void *)&v48[0] + 1));
              goto LABEL_17;
            }
            if ((DWORD2(v48[0]) - 8) <= 0xFFFFFFF9) {
              break;
            }
          }
        }
      }
LABEL_17:
      HDLCFrameFree();
      HDLCFrameFree();
      if (v10 >= 2)
      {
        TelephonyUtilRingBufferReset();
        long long v28 = (void (*)(void *))a1[3];
        if (v28) {
          v28(a1);
        }
        _ETLDebugPrint((uint64_t)"ETLMESSAGESetSubsystemRuntimeMasksWithRetry", (uint64_t)"Trying again\n", v22, v23, v24, v25, v26, v27, v37);
      }
      if (!--v10) {
        return 0;
      }
    }
    if (*(unsigned char *)(*(void *)&v48[0] + 6) != 1)
    {
      _ETLDebugPrint((uint64_t)"ETLMESSAGEParseSetSubsystemRunTimeMasksResponse", (uint64_t)"Status was %u\n", v13, v14, v15, v16, v17, v18, *(unsigned __int8 *)(*(void *)&v48[0] + 6));
      goto LABEL_17;
    }
    int v34 = *(unsigned __int16 *)(*(void *)&v48[0] + 2);
    int v35 = *(unsigned __int16 *)(*(void *)&v48[0] + 4);
    if (v47 != v35 || v46 != v34) {
      _ETLDebugPrint((uint64_t)"ETLMESSAGEParseSetSubsystemRunTimeMasksResponse", (uint64_t)"Returned range 0x%x didn't match requested 0x%x\n", v13, v14, v15, v16, v17, v18, v34 | (v35 << 16));
    }
    HDLCFrameFree();
    HDLCFrameFree();
    if (!v43) {
      return 1;
    }
    v45 += 4 * v43;
    unsigned int v9 = v42 - v43;
    LOWORD(v8) = v46 + v43;
    unsigned __int16 v46 = v8;
    uint64_t result = 1;
    unsigned int v10 = v41;
  }
  while (a2[1] >= (unsigned __int16)v8);
  return result;
}

uint64_t ETLMESSAGESetAllSubsystemRunTimeMasks(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _ETLDebugPrint((uint64_t)"ETLMESSAGESetAllSubsystemRunTimeMasks", (uint64_t)"to 0x%x\n", a3, a4, a5, a6, a7, a8, a2);
  memset(v31, 0, sizeof(v31));
  uint64_t v32 = 0;
  memset(v29, 0, sizeof(v29));
  uint64_t v30 = 0;
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_11;
  }
  __int16 v33 = 1405;
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v24 = 2;
LABEL_9:
    uint64_t v28 = v24;
    uint64_t v25 = "ETLRequireFreeSpace";
    uint64_t v26 = "Need %u bytes free space, but only have %u\n";
LABEL_10:
    _ETLDebugPrint((uint64_t)v25, (uint64_t)v26, v11, v12, v13, v14, v15, v16, v28);
    goto LABEL_11;
  }
  if (!HDLCFrameInject()) {
    goto LABEL_11;
  }
  if (HDLCFrameGetFreeSpace() <= 5)
  {
    uint64_t v24 = 6;
    goto LABEL_9;
  }
  if (!HDLCFrameInjectUnsignedShort())
  {
    HDLCFrameFree();
    HDLCFrameFree();
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLMESSAGESetAllSubsystemRunTimeMasks", (uint64_t)"Failed to set masks to 0x%x\n", v17, v18, v19, v20, v21, v22, a2);
    return 0;
  }
  if (!HDLCFrameInjectUnsignedInt() || !ETLSendCommand(a1, (uint64_t)v31, a3)) {
    goto LABEL_11;
  }
  LOBYTE(v33) = 125;
  if ((ETLFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v29, &v33, a3) & 1) == 0)
  {
    uint64_t v25 = "ETLMESSAGEFindMatchingResponse";
    uint64_t v26 = "Failed to find matching response\n";
    goto LABEL_10;
  }
  if (DWORD2(v29[0]) < 2) {
    goto LABEL_11;
  }
  if (*(unsigned char *)(*(void *)&v29[0] + 1) != 5)
  {
    _ETLDebugPrint((uint64_t)"ETLMESSAGEParseSetAllSubsystemRunTimeMasksResponse", (uint64_t)"Response subcommand 0x%x mismatches expected 0x%x\n", v11, v12, v13, v14, v15, v16, *(unsigned __int8 *)(*(void *)&v29[0] + 1));
    goto LABEL_11;
  }
  if ((DWORD2(v29[0]) - 8) > 0xFFFFFFF9)
  {
LABEL_11:
    HDLCFrameFree();
    HDLCFrameFree();
    goto LABEL_12;
  }
  if (*(unsigned char *)(*(void *)&v29[0] + 2) != 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMESSAGEParseSetAllSubsystemRunTimeMasksResponse", (uint64_t)"Status was %u\n", v11, v12, v13, v14, v15, v16, *(unsigned __int8 *)(*(void *)&v29[0] + 2));
    goto LABEL_11;
  }
  uint64_t v27 = *(unsigned int *)(*(void *)&v29[0] + 4);
  if (v27 != a2) {
    _ETLDebugPrint((uint64_t)"ETLMESSAGEParseSetAllSubsystemRunTimeMasksResponse", (uint64_t)"Returned mask %u doesn't match requested %u\n", v11, v12, v13, v14, v15, v16, v27);
  }
  HDLCFrameFree();
  HDLCFrameFree();
  return 1;
}

uint64_t ETLMESSAGESetFlags(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a4 = 0;
  _ETLDebugPrint((uint64_t)"ETLMESSAGESetFlags", (uint64_t)"Setting enabled to 0x%x\n", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, a2);
  uint64_t v28 = 0;
  memset(v27, 0, sizeof(v27));
  memset(v25, 0, sizeof(v25));
  uint64_t v26 = 0;
  uint64_t v12 = 0;
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_20;
  }
  __int16 v29 = 1661;
  if (HDLCFrameGetFreeSpace() <= 1)
  {
    uint64_t v20 = 2;
LABEL_17:
    uint64_t v24 = v20;
    uint64_t v21 = "ETLRequireFreeSpace";
    uint64_t v22 = "Need %u bytes free space, but only have %u\n";
LABEL_18:
    _ETLDebugPrint((uint64_t)v21, (uint64_t)v22, v13, v14, v15, v16, v17, v18, v24);
    goto LABEL_19;
  }
  if (!HDLCFrameInject()) {
    goto LABEL_19;
  }
  if (HDLCFrameGetFreeSpace() <= 5)
  {
    uint64_t v20 = 6;
    goto LABEL_17;
  }
  uint64_t v12 = 0;
  if (!HDLCFrameInjectUnsignedShort()) {
    goto LABEL_20;
  }
  if (!HDLCFrameInjectUnsignedInt() || !ETLSendCommand(a1, (uint64_t)v27, a5)) {
    goto LABEL_19;
  }
  LOBYTE(v29) = 125;
  if ((ETLFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v25, &v29, a5) & 1) == 0)
  {
    uint64_t v21 = "ETLMESSAGEFindMatchingResponse";
    uint64_t v22 = "Failed to find matching response\n";
    goto LABEL_18;
  }
  uint64_t v12 = 0;
  *a4 = 0;
  int v19 = DWORD2(v25[0]);
  if (DWORD2(v25[0]) < 2) {
    goto LABEL_20;
  }
  if (*(unsigned char *)(*(void *)&v25[0] + 1) != 6)
  {
    _ETLDebugPrint((uint64_t)"ETLMESSAGEParseSetFlagsResponse", (uint64_t)"Response subcommand 0x%x mismatches expected 0x%x\n", v13, v14, v15, v16, v17, v18, *(unsigned __int8 *)(*(void *)&v25[0] + 1));
    goto LABEL_19;
  }
  if ((DWORD2(v25[0]) - 8) > 0xFFFFFFF9)
  {
LABEL_19:
    uint64_t v12 = 0;
    goto LABEL_20;
  }
  if (*(unsigned char *)(*(void *)&v25[0] + 2) != 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMESSAGEParseSetFlagsResponse", (uint64_t)"Status was %u\n", v13, v14, v15, v16, v17, v18, *(unsigned __int8 *)(*(void *)&v25[0] + 2));
    goto LABEL_19;
  }
  *a3 = *(_DWORD *)(*(void *)&v25[0] + 4);
  if ((v19 - 12) <= 0xFFFFFFFB) {
    *a4 = 0;
  }
  uint64_t v12 = 1;
LABEL_20:
  HDLCFrameFree();
  HDLCFrameFree();
  return v12;
}

uint64_t ETLMESSAGESetEnabled(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  int v11 = 0;
  LODWORD(result) = ETLMESSAGESetFlags(a1, a2, &v11, &v10, a3, a6, a7, a8);
  if (v11 == v8) {
    return result;
  }
  else {
    return 0;
  }
}

uint64_t APPLIB_DIAG_GetRevision(_WORD *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 4)
  {
    bzero(a1, a2);
    *a1 = 30720;
    *((unsigned char *)a1 + 2) = -16;
    if (a2 >= 6)
    {
      *(_DWORD *)a1 = 2129688576;
      return 4;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t DetectAndFixSpecialCharacters(unsigned __int8 *a1, int a2, int a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a3 <= 1024 && 2 * a3 <= a2)
  {
    bzero(__src, 0x800uLL);
    if (a3 < 1)
    {
      int v6 = 0;
    }
    else
    {
      int v6 = 0;
      uint64_t v7 = a1;
      uint64_t v8 = a3;
      do
      {
        int v10 = *v7++;
        char v9 = v10;
        if ((v10 - 125) <= 1)
        {
          __src[v6] = 125;
          v9 ^= 0x20u;
          ++v6;
        }
        __src[v6++] = v9;
        --v8;
      }
      while (v8);
    }
    memcpy(a1, __src, v6);
    uint64_t result = (v6 + 1);
    a1[v6] = 126;
  }
  return result;
}

uint64_t APPLIB_DIAG_PingBaseBand(_WORD *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 4)
  {
    bzero(a1, a2);
    *a1 = 11387;
    *((unsigned char *)a1 + 2) = 61;
    if (a2 >= 6)
    {
      *(_DWORD *)a1 = 2117938299;
      return 4;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_GetBaseBandRevision(_WORD *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 4)
  {
    bzero(a1, a2);
    *a1 = -27780;
    *((unsigned char *)a1 + 2) = 73;
    if (a2 >= 6)
    {
      *(_DWORD *)a1 = 2118751100;
      return 4;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_SetDownloadMode(_WORD *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 4)
  {
    bzero(a1, a2);
    *a1 = -24262;
    *((unsigned char *)a1 + 2) = 110;
    if (a2 >= 6)
    {
      *(_DWORD *)a1 = 2121179450;
      return 4;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_NvItemRead(char *a1, int a2, __int16 a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 140)
  {
    *(_OWORD *)(a1 + 124) = 0u;
    *((_OWORD *)a1 + 6) = 0u;
    *((_OWORD *)a1 + 7) = 0u;
    *((_OWORD *)a1 + 4) = 0u;
    *((_OWORD *)a1 + 5) = 0u;
    *((_OWORD *)a1 + 2) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *a1 = 38;
    *(_WORD *)(a1 + 1) = a3;
    int v5 = 1064;
    LOWORD(v6) = -1;
    uint64_t v7 = a1;
    do
    {
      char v8 = *v7++;
      int v6 = crc_16_l_table[(v8 ^ v6)] ^ ((unsigned __int16)(v6 & 0xFF00) >> 8);
      v5 -= 8;
    }
    while ((_WORD)v5);
    *(_WORD *)(a1 + 133) = ~(_WORD)v6;
    if (a2 >= 0x10E)
    {
      bzero(__src, 0x800uLL);
      uint64_t v9 = 0;
      LODWORD(v10) = 0;
      do
      {
        while (1)
        {
          int v12 = a1[v9];
          if ((v12 - 125) > 1) {
            break;
          }
          int v11 = v10 + 1;
          __src[(int)v10] = 125;
          __src[(int)v10 + 1] = v12 ^ 0x20;
          size_t v10 = (int)v10 + 1 + 1;
          if (++v9 == 135) {
            goto LABEL_11;
          }
        }
        int v11 = v10;
        __src[(int)v10] = v12;
        size_t v10 = (int)v10 + 1;
        ++v9;
      }
      while (v9 != 135);
LABEL_11:
      memcpy(a1, __src, v10);
      uint64_t result = (v11 + 2);
      a1[v10] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_NvItemWrite(char *a1, int a2, __int16 a3, void *__src, int a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 140 && __src && a5 <= 128)
  {
    *(_OWORD *)(a1 + 124) = 0u;
    *((_OWORD *)a1 + 6) = 0u;
    *((_OWORD *)a1 + 7) = 0u;
    *((_OWORD *)a1 + 4) = 0u;
    *((_OWORD *)a1 + 5) = 0u;
    *((_OWORD *)a1 + 2) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *a1 = 39;
    *(_WORD *)(a1 + 1) = a3;
    memcpy(a1 + 3, __src, a5);
    int v8 = 1064;
    LOWORD(v9) = -1;
    size_t v10 = a1;
    do
    {
      char v11 = *v10++;
      int v9 = crc_16_l_table[(v11 ^ v9)] ^ ((unsigned __int16)(v9 & 0xFF00) >> 8);
      v8 -= 8;
    }
    while ((_WORD)v8);
    *(_WORD *)(a1 + 133) = ~(_WORD)v9;
    if (a2 >= 0x10E)
    {
      bzero(__srca, 0x800uLL);
      uint64_t v12 = 0;
      LODWORD(v13) = 0;
      do
      {
        while (1)
        {
          int v15 = a1[v12];
          if ((v15 - 125) > 1) {
            break;
          }
          int v14 = v13 + 1;
          __srca[(int)v13] = 125;
          __srca[(int)v13 + 1] = v15 ^ 0x20;
          size_t v13 = (int)v13 + 1 + 1;
          if (++v12 == 135) {
            goto LABEL_13;
          }
        }
        int v14 = v13;
        __srca[(int)v13] = v15;
        size_t v13 = (int)v13 + 1;
        ++v12;
      }
      while (v12 != 135);
LABEL_13:
      memcpy(a1, __srca, v13);
      uint64_t result = (v14 + 2);
      a1[v13] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTMNvItemRead(char *a1, int a2, unsigned int a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1)
  {
    if (a2 >= 19)
    {
      *(void *)a1 = 0;
      *((void *)a1 + 1) = 0;
      *(_DWORD *)(a1 + 15) = 0;
      *(_WORD *)a1 = 2891;
      *(void *)(a1 + 2) = 0x900000025C0024;
      *((_WORD *)a1 + 5) = a3;
      unsigned __int16 v5 = crc_16_l_table[a1[7] ^ 0x5FLL];
      unsigned __int16 v6 = crc_16_l_table[a1[8] ^ 0xB7 ^ v5];
      unsigned int v7 = crc_16_l_table[(a1[9] ^ v6 ^ HIBYTE(v5))];
      unsigned int v8 = crc_16_l_table[(v7 ^ HIBYTE(v6) ^ a3)];
      unsigned int v9 = a3 >> 8;
      int v10 = crc_16_l_table[(a3 >> 8) ^ crc_16_l_table[(v7 ^ HIBYTE(v6) ^ a3)] ^ (v7 >> 8)];
      int v11 = v10 ^ ~(v8 >> 8);
      *((_WORD *)a1 + 6) = v10 ^ ~(unsigned __int16)(v8 >> 8);
      if (a2 >= 0x1C)
      {
        int v12 = a3;
        int v13 = v10 ^ (v8 >> 8);
        bzero(v22, 0x7F6uLL);
        uint64_t __src = 0x25C00240B4BLL;
        __int16 v21 = 144;
        if ((v12 - 125) > 1)
        {
          unsigned int v14 = 10;
        }
        else
        {
          v22[0] = 125;
          LOBYTE(v12) = v12 ^ 0x20;
          unsigned int v14 = 11;
        }
        int v15 = ~(_BYTE)v13;
        *((unsigned char *)&__src + v14) = v12;
        uint64_t v16 = v14 + 1;
        if (v9 - 125 <= 1)
        {
          *((unsigned char *)&__src + v16) = 125;
          LOBYTE(v9) = v9 ^ 0x20;
          LODWORD(v16) = v14 + 2;
        }
        int v17 = BYTE1(v11);
        *((unsigned char *)&__src + v16) = v9;
        uint64_t v18 = v16 + 1;
        if ((v15 - 125) <= 1)
        {
          *((unsigned char *)&__src + v18) = 125;
          LOBYTE(v15) = v15 ^ 0x20;
          LODWORD(v18) = v16 + 2;
        }
        *((unsigned char *)&__src + v18) = v15;
        uint64_t v19 = v18 + 1;
        if ((v17 - 125) <= 1)
        {
          *((unsigned char *)&__src + v19) = 125;
          LOBYTE(v17) = v17 ^ 0x20;
          LODWORD(v19) = v18 + 2;
        }
        *((unsigned char *)&__src + v19) = v17;
        memcpy(a1, &__src, v19 + 1);
        uint64_t result = (v19 + 2);
        a1[v19 + 1] = 126;
      }
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_FTMNvItemWrite(void *a1, int a2, __int16 a3, void *__src, int a5)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 - a5 >= 21)
  {
    *a1 = 0;
    a1[1] = 0;
    *(void *)((char *)a1 + 13) = 0;
    *(_WORD *)a1 = 2891;
    *(void *)((char *)a1 + 2) = 0xE0000025D0024;
    *((_WORD *)a1 + 5) = a3;
    *((_WORD *)a1 + 6) = a5;
    memcpy((char *)a1 + 14, __src, a5);
    int v10 = 8 * (a5 + 14);
    if (8 * ((_WORD)a5 + 14))
    {
      LOWORD(v11) = -1;
      int v12 = (char *)a1;
      do
      {
        char v13 = *v12++;
        int v11 = crc_16_l_table[(v13 ^ v11)] ^ ((unsigned __int16)(v11 & 0xFF00) >> 8);
        v10 -= 8;
      }
      while ((_WORD)v10);
      char v14 = ~(_BYTE)v11;
      char v15 = (unsigned __int16)~(_WORD)v11 >> 8;
    }
    else
    {
      char v14 = 0;
      char v15 = 0;
    }
    *((unsigned char *)a1 + a5 + 14) = v14;
    *((unsigned char *)a1 + a5 + 15) = v15;
    uint64_t v16 = (a5 + 16);
    uint64_t result = 0xFFFFFFFFLL;
    if ((int)v16 <= 1024 && 2 * (int)v16 <= a2)
    {
      bzero(__srca, 0x800uLL);
      if ((int)v16 < 1)
      {
        int v17 = 0;
      }
      else
      {
        int v17 = 0;
        uint64_t v18 = (unsigned __int8 *)a1;
        do
        {
          int v20 = *v18++;
          char v19 = v20;
          if ((v20 - 125) <= 1)
          {
            __srca[v17] = 125;
            v19 ^= 0x20u;
            ++v17;
          }
          __srca[v17++] = v19;
          --v16;
        }
        while (v16);
      }
      memcpy(a1, __srca, v17);
      uint64_t result = (v17 + 1);
      *((unsigned char *)a1 + v17) = 126;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_ModeChange(_WORD *a1, int a2, unsigned int a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 10)
  {
    *(void *)a1 = 0;
    a1[4] = 0;
    *(unsigned char *)a1 = 41;
    int v5 = a3;
    *((unsigned char *)a1 + 1) = a3;
    unsigned int v6 = a3 >> 8;
    *((unsigned char *)a1 + 2) = BYTE1(a3);
    unsigned int v7 = crc_16_l_table[a3 ^ 0x44];
    int v8 = crc_16_l_table[crc_16_l_table[a3 ^ 0x44] ^ (a3 >> 8) ^ 0xB3];
    int v9 = v8 ^ (v7 >> 8);
    int v10 = v8 ^ ~(v7 >> 8);
    *((unsigned char *)a1 + 3) = v10;
    int v11 = BYTE1(v10);
    *((unsigned char *)a1 + 4) = BYTE1(v10);
    bzero(v18, 0x7FFuLL);
    char __src = 41;
    if ((v5 - 125) > 1)
    {
      unsigned int v12 = 1;
    }
    else
    {
      v18[0] = 125;
      LOBYTE(v5) = v5 ^ 0x20;
      unsigned int v12 = 2;
    }
    int v13 = ~(_BYTE)v9;
    v18[v12 - 1] = v5;
    uint64_t v14 = v12 + 1;
    if (v6 - 125 <= 1)
    {
      v18[v14 - 1] = 125;
      LODWORD(v14) = v12 + 2;
      LOBYTE(v6) = v6 ^ 0x20;
    }
    v18[v14 - 1] = v6;
    uint64_t v15 = v14 + 1;
    if ((v13 - 125) <= 1)
    {
      v18[v15 - 1] = 125;
      LOBYTE(v13) = v13 ^ 0x20;
      LODWORD(v15) = v14 + 2;
    }
    v18[v15 - 1] = v13;
    uint64_t v16 = v15 + 1;
    if ((v11 - 125) <= 1)
    {
      v18[v16 - 1] = 125;
      LOBYTE(v11) = v11 ^ 0x20;
      LODWORD(v16) = v15 + 2;
    }
    v18[v16 - 1] = v11;
    memcpy(a1, &__src, v16 + 1);
    uint64_t result = (v16 + 2);
    *((unsigned char *)a1 + v16 + 1) = 126;
  }
  return result;
}

uint64_t APPLIB_DIAG_GetStatus(_WORD *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 4)
  {
    bzero(a1, a2);
    *a1 = 5132;
    *((unsigned char *)a1 + 2) = 58;
    if (a2 >= 6)
    {
      *(_DWORD *)a1 = 2117735436;
      return 4;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_GetDeviceID(_DWORD *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 5)
  {
    bzero(a1, a2);
    *a1 = 65099;
    *((_WORD *)a1 + 2) = -18861;
    if (a2 >= 0xC)
    {
      *a1 = 65099;
      *((_WORD *)a1 + 2) = -18861;
      *((unsigned char *)a1 + 6) = 126;
      return 7;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_DetectSim(_DWORD *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 5)
  {
    bzero(a1, a2);
    *a1 = 130635;
    *((_WORD *)a1 + 2) = -20597;
    if (a2 >= 0xC)
    {
      *a1 = 130635;
      *((_WORD *)a1 + 2) = -20597;
      *((unsigned char *)a1 + 6) = 126;
      return 7;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t DetectAndStripSpecialCharacters(unsigned char *a1, int a2, int a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = 0xFFFFFFFFLL;
  if (a3 <= 2048 && a3 <= a2)
  {
    bzero(__src, 0x800uLL);
    if (a3 < 1)
    {
      uint64_t v3 = 0;
    }
    else
    {
      uint64_t v3 = 0;
      int v6 = 0;
      do
      {
        uint64_t v7 = v6;
        int v8 = a1[v6];
        if (v8 == 125)
        {
          ++v6;
          LOBYTE(v8) = a1[v7 + 1] ^ 0x20;
        }
        __src[v3++] = v8;
        ++v6;
      }
      while (v6 < a3);
    }
    bzero(a1, a3);
    memcpy(a1, __src, v3);
  }
  return v3;
}

uint64_t APPLIB_DIAG_SendRawRequest(char *a1, int a2, const void *a3, int a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (a3 && a4 + 7 <= a2)
  {
    bzero(a1, a4 + 7);
    memcpy(a1, a3, a4);
    int v9 = 8 * a4;
    if (((8 * a4) & 0xFFF8) != 0)
    {
      LOWORD(v10) = -1;
      uint64_t v11 = a1;
      do
      {
        char v12 = *v11++;
        int v10 = crc_16_l_table[(v12 ^ v10)] ^ ((unsigned __int16)(v10 & 0xFF00) >> 8);
        v9 -= 8;
      }
      while ((_WORD)v9);
      *(_WORD *)&a1[a4] = ~(_WORD)v10;
      uint64_t result = 0xFFFFFFFFLL;
      if (a4 > 1022) {
        return result;
      }
    }
    else
    {
      int v13 = &a1[a4];
      *int v13 = 0;
      v13[1] = 0;
      uint64_t result = 0xFFFFFFFFLL;
      if (a4 > 1022) {
        return result;
      }
    }
    uint64_t v14 = (a4 + 2);
    if (2 * (int)v14 <= a2)
    {
      bzero(__src, 0x800uLL);
      if (a4 < -1)
      {
        int v15 = 0;
      }
      else
      {
        int v15 = 0;
        uint64_t v16 = (unsigned __int8 *)a1;
        do
        {
          int v18 = *v16++;
          char v17 = v18;
          if ((v18 - 125) <= 1)
          {
            __src[v15] = 125;
            v17 ^= 0x20u;
            ++v15;
          }
          __src[v15++] = v17;
          --v14;
        }
        while (v14);
      }
      memcpy(a1, __src, v15);
      uint64_t result = (v15 + 1);
      a1[v15] = 126;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_SetOneRx(_DWORD *a1, int a2, __int16 a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 9)
  {
    bzero(a1, a2);
    *a1 = 195915;
    int v7 = a3;
    *((_WORD *)a1 + 2) = a3;
    int v8 = HIBYTE(a3);
    unsigned int v9 = crc_16_l_table[a3 ^ 0x78];
    int v10 = crc_16_l_table[crc_16_l_table[a3 ^ 0x78] ^ HIBYTE(a3) ^ 0x95];
    int v11 = v10 ^ ~(v9 >> 8);
    *((unsigned char *)a1 + 6) = v10 ^ ~(v9 >> 8);
    int v12 = BYTE1(v11);
    *((unsigned char *)a1 + 7) = BYTE1(v11);
    if (a2 >= 0x10)
    {
      int v13 = v10 ^ (v9 >> 8);
      bzero(v20, 0x7FCuLL);
      int __src = 195915;
      if ((v7 - 125) > 1)
      {
        unsigned int v14 = 4;
      }
      else
      {
        v20[0] = 125;
        LOBYTE(v7) = v7 ^ 0x20;
        unsigned int v14 = 5;
      }
      int v15 = ~(_BYTE)v13;
      v20[v14 - 4] = v7;
      uint64_t v16 = v14 + 1;
      if ((v8 - 125) <= 1)
      {
        v20[v16 - 4] = 125;
        LODWORD(v16) = v14 | 2;
        LOBYTE(v8) = v8 ^ 0x20;
      }
      v20[v16 - 4] = v8;
      uint64_t v17 = v16 + 1;
      if ((v15 - 125) <= 1)
      {
        v20[v17 - 4] = 125;
        LOBYTE(v15) = v15 ^ 0x20;
        LODWORD(v17) = v16 + 2;
      }
      v20[v17 - 4] = v15;
      uint64_t v18 = v17 + 1;
      if ((v12 - 125) <= 1)
      {
        v20[v18 - 4] = 125;
        LOBYTE(v12) = v12 ^ 0x20;
        LODWORD(v18) = v17 + 2;
      }
      v20[v18 - 4] = v12;
      memcpy(a1, &__src, v18 + 1);
      uint64_t result = (v18 + 2);
      *((unsigned char *)a1 + v18 + 1) = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_Get_RSSI_Channel(_DWORD *a1, int a2, __int16 a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 9)
  {
    bzero(a1, a2);
    *a1 = 261451;
    int v7 = a3;
    *((_WORD *)a1 + 2) = a3;
    int v8 = HIBYTE(a3);
    unsigned int v9 = crc_16_l_table[a3 ^ 0xA0];
    int v10 = crc_16_l_table[crc_16_l_table[a3 ^ 0xA0] ^ HIBYTE(a3) ^ 0x8C];
    int v11 = v10 ^ ~(v9 >> 8);
    *((unsigned char *)a1 + 6) = v10 ^ ~(v9 >> 8);
    int v12 = BYTE1(v11);
    *((unsigned char *)a1 + 7) = BYTE1(v11);
    if (a2 >= 0x10)
    {
      int v13 = v10 ^ (v9 >> 8);
      bzero(v20, 0x7FCuLL);
      int __src = 261451;
      if ((v7 - 125) > 1)
      {
        unsigned int v14 = 4;
      }
      else
      {
        v20[0] = 125;
        LOBYTE(v7) = v7 ^ 0x20;
        unsigned int v14 = 5;
      }
      int v15 = ~(_BYTE)v13;
      v20[v14 - 4] = v7;
      uint64_t v16 = v14 + 1;
      if ((v8 - 125) <= 1)
      {
        v20[v16 - 4] = 125;
        LODWORD(v16) = v14 | 2;
        LOBYTE(v8) = v8 ^ 0x20;
      }
      v20[v16 - 4] = v8;
      uint64_t v17 = v16 + 1;
      if ((v15 - 125) <= 1)
      {
        v20[v17 - 4] = 125;
        LOBYTE(v15) = v15 ^ 0x20;
        LODWORD(v17) = v16 + 2;
      }
      v20[v17 - 4] = v15;
      uint64_t v18 = v17 + 1;
      if ((v12 - 125) <= 1)
      {
        v20[v18 - 4] = 125;
        LOBYTE(v12) = v12 ^ 0x20;
        LODWORD(v18) = v17 + 2;
      }
      v20[v18 - 4] = v12;
      memcpy(a1, &__src, v18 + 1);
      uint64_t result = (v18 + 2);
      *((unsigned char *)a1 + v18 + 1) = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_Get_OneRxConfig(_DWORD *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 7)
  {
    bzero(a1, a2);
    *a1 = 326987;
    *((_WORD *)a1 + 2) = 15959;
    if (a2 >= 0xC)
    {
      *a1 = 326987;
      *((_WORD *)a1 + 2) = 15959;
      *((unsigned char *)a1 + 6) = 126;
      return 7;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_Release_BB_RESET_DET_N(_DWORD *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 5)
  {
    bzero(a1, a2);
    *a1 = 523595;
    *((_WORD *)a1 + 2) = 5183;
    if (a2 >= 0xC)
    {
      *a1 = 523595;
      *((_WORD *)a1 + 2) = 5183;
      *((unsigned char *)a1 + 6) = 126;
      return 7;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_PowerDown_BaseBand(_DWORD *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 5)
  {
    bzero(a1, a2);
    *a1 = 654667;
    *((_WORD *)a1 + 2) = -29137;
    if (a2 >= 0xC)
    {
      *a1 = 654667;
      *((_WORD *)a1 + 2) = -29137;
      *((unsigned char *)a1 + 6) = 126;
      return 7;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_EDLOAD(_DWORD *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 5)
  {
    bzero(a1, a2);
    *a1 = 982347;
    *((_WORD *)a1 + 2) = -15577;
    if (a2 >= 0xC)
    {
      *a1 = 982347;
      *((_WORD *)a1 + 2) = -15577;
      *((unsigned char *)a1 + 6) = 126;
      return 7;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t ETLNVCreateReadCommand()
{
  if (HDLCFrameGetFreeSpace() <= 0x84)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v0, v1, v2, v3, v4, v5, 133);
    return 0;
  }
  else
  {
    HDLCFrameInjectUnsignedChar();
    uint64_t result = HDLCFrameInjectUnsignedShort();
    if (result)
    {
      HDLCFrameInject();
      return HDLCFrameInjectUnsignedShort();
    }
  }
  return result;
}

uint64_t ETLNVParseReadResponse(_DWORD *a1, int a2, _DWORD *a3, _OWORD *a4, uint64_t a5, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a1[2];
  *a6 = 0;
  if (v8 <= 0x84)
  {
    _ETLDebugPrint((uint64_t)"ETLNVParseReadResponse", (uint64_t)"Response size %u not enough, need %u\n", (uint64_t)a3, (uint64_t)a4, a5, (uint64_t)a6, a7, a8, 133);
    return 0;
  }
  else
  {
    uint64_t v9 = *(void *)a1;
    if (*(unsigned __int16 *)(*(void *)a1 + 1) == a2)
    {
      if (a5 <= 0x7F)
      {
        _ETLDebugPrint((uint64_t)"ETLNVParseReadResponse", (uint64_t)"Provided buffer has capacity %u, need %u\n", (uint64_t)a3, (uint64_t)a4, a5, (uint64_t)a6, a7, a8, a5);
        return 0;
      }
      else
      {
        long long v10 = *(_OWORD *)(v9 + 3);
        long long v11 = *(_OWORD *)(v9 + 19);
        long long v12 = *(_OWORD *)(v9 + 51);
        a4[2] = *(_OWORD *)(v9 + 35);
        a4[3] = v12;
        *a4 = v10;
        a4[1] = v11;
        long long v13 = *(_OWORD *)(v9 + 67);
        long long v14 = *(_OWORD *)(v9 + 83);
        long long v15 = *(_OWORD *)(v9 + 115);
        a4[6] = *(_OWORD *)(v9 + 99);
        a4[7] = v15;
        a4[4] = v13;
        a4[5] = v14;
        *a6 = 128;
        uint64_t v16 = *(unsigned __int16 *)(v9 + 131);
        if (v16)
        {
          if (v16 == 5)
          {
            *a3 = 5;
            return 1;
          }
          else
          {
            *a3 = v16;
            _ETLDebugPrint((uint64_t)"ETLNVParseReadResponse", (uint64_t)"Return code was %u\n", (uint64_t)a3, (uint64_t)a4, a5, (uint64_t)a6, a7, a8, v16);
            return 0;
          }
        }
        else
        {
          *a3 = 0;
          return 1;
        }
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLNVParseReadResponse", (uint64_t)"Returned item number %u mismatches expected %u\n", (uint64_t)a3, (uint64_t)a4, a5, (uint64_t)a6, a7, a8, *(unsigned __int16 *)(*(void *)a1 + 1));
      return 0;
    }
  }
}

uint64_t ETLNVCreateWriteCommand(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  if (a4 > 0x80) {
    return 0;
  }
  if (HDLCFrameGetFreeSpace() <= 0x87)
  {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v4, v5, v6, v7, v8, v9, 136);
    return 0;
  }
  else
  {
    HDLCFrameInjectUnsignedChar();
    HDLCFrameInjectUnsignedShort();
    uint64_t result = HDLCFrameInject();
    if (result)
    {
      HDLCFrameInject();
      return HDLCFrameInjectUnsignedShort();
    }
  }
  return result;
}

uint64_t ETLNVParseWriteResponseWithStatus(_DWORD *a1, int a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[2] <= 2u)
  {
    _ETLDebugPrint((uint64_t)"ETLNVParseWriteResponseWithStatus", (uint64_t)"Response size %u not enough, need %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, 3);
    return 0;
  }
  else
  {
    uint64_t v9 = *(void *)a1;
    if (*(unsigned __int16 *)(*(void *)a1 + 1) != a2) {
      _ETLDebugPrint((uint64_t)"ETLNVParseWriteResponseWithStatus", (uint64_t)"Returned item number %u mismatches expected %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, *(unsigned __int16 *)(*(void *)a1 + 1));
    }
    uint64_t v10 = *(unsigned __int16 *)(v9 + 131);
    *a3 = v10;
    if (v10)
    {
      _ETLDebugPrint((uint64_t)"ETLNVParseWriteResponseWithStatus", (uint64_t)"NV write response indicates failure with status code %u\n", (uint64_t)a3, a4, a5, a6, a7, a8, v10);
      return 0;
    }
    else
    {
      return 1;
    }
  }
}

uint64_t ETLNVParseWriteResponse(_DWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[2] <= 2u)
  {
    _ETLDebugPrint((uint64_t)"ETLNVParseWriteResponseWithStatus", (uint64_t)"Response size %u not enough, need %u\n", a3, a4, a5, a6, a7, a8, 3);
    return 0;
  }
  else
  {
    uint64_t v8 = *(void *)a1;
    if (*(unsigned __int16 *)(*(void *)a1 + 1) != a2) {
      _ETLDebugPrint((uint64_t)"ETLNVParseWriteResponseWithStatus", (uint64_t)"Returned item number %u mismatches expected %u\n", a3, a4, a5, a6, a7, a8, *(unsigned __int16 *)(*(void *)a1 + 1));
    }
    if (*(_WORD *)(v8 + 131))
    {
      _ETLDebugPrint((uint64_t)"ETLNVParseWriteResponseWithStatus", (uint64_t)"NV write response indicates failure with status code %u\n", a3, a4, a5, a6, a7, a8, *(unsigned __int16 *)(v8 + 131));
      return 0;
    }
    else
    {
      return 1;
    }
  }
}

void *ETLNVRead(uint64_t (**a1)(void, void *, uint64_t, _OWORD *, uint64_t, uint64_t, void), int a2, _OWORD *a3, uint64_t a4, _DWORD *a5, _DWORD *a6, uint64_t a7)
{
  Response = 0;
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (a1 && a3 && a6)
  {
    long long v33 = 0u;
    long long v34 = 0u;
    uint64_t v35 = 0;
    memset(v31, 0, sizeof(v31));
    uint64_t v32 = 0;
    if (HDLCFrameCreateUplink())
    {
      if (HDLCFrameGetFreeSpace() > 0x84)
      {
        HDLCFrameInjectUnsignedChar();
        if (HDLCFrameInjectUnsignedShort())
        {
          memset(v36, 0, sizeof(v36));
          HDLCFrameInject();
          Response = 0;
          if (!HDLCFrameInjectUnsignedShort()) {
            goto LABEL_21;
          }
          Response = malloc((2 * DWORD2(v33) + 32));
          if (!Response) {
            goto LABEL_21;
          }
          uint64_t v21 = HDLCFrameEncode();
          if (!v21) {
            goto LABEL_23;
          }
          uint64_t v22 = v21;
          LODWORD(v36[0]) = -1431655766;
          if ((_ETLDebugFlags & 2) != 0) {
            ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, Response, v21);
          }
          if (*a1)
          {
            int v23 = (*a1)(a1, Response, v22, v36, 1, a7, 0);
            int v30 = v36[0];
            free(Response);
            Response = 0;
            if (!v23 || v30 != v22) {
              goto LABEL_21;
            }
            LOBYTE(v36[0]) = 38;
            if (ETLFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v31, v36, a7))
            {
              Response = (void *)ETLNVParseReadResponse(v31, a2, a6, a3, a4, a5, v24, v25);
LABEL_21:
              HDLCFrameFree();
              HDLCFrameFree();
              return Response;
            }
          }
          else
          {
LABEL_23:
            free(Response);
          }
        }
LABEL_20:
        Response = 0;
        goto LABEL_21;
      }
      uint64_t v29 = 133;
      uint64_t v26 = "ETLRequireFreeSpace";
      uint64_t v27 = "Need %u bytes free space, but only have %u\n";
    }
    else
    {
      uint64_t v26 = "ETLNVRead";
      uint64_t v27 = "Failed to create command frame\n";
    }
    _ETLDebugPrint((uint64_t)v26, (uint64_t)v27, v15, v16, v17, v18, v19, v20, v29);
    goto LABEL_20;
  }
  return Response;
}

uint64_t ETLNVWrite(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), int a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  return ETLNVWriteWithStatus(a1, a2, a3, a4, &v6, a5);
}

uint64_t ETLNVWriteWithStatus(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), int a2, uint64_t a3, unsigned int a4, _DWORD *a5, uint64_t a6)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    memset(v36, 0, sizeof(v36));
    uint64_t v37 = 0;
    memset(v34, 0, sizeof(v34));
    uint64_t v35 = 0;
    if (HDLCFrameCreateUplink())
    {
      if (a4 <= 0x80)
      {
        if (HDLCFrameGetFreeSpace() <= 0x87)
        {
          _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v17, v18, v19, v20, v21, v22, 136);
        }
        else
        {
          HDLCFrameInjectUnsignedChar();
          HDLCFrameInjectUnsignedShort();
          if (HDLCFrameInject())
          {
            memset(v38, 0, sizeof(v38));
            HDLCFrameInject();
            uint64_t v23 = 0;
            if (!HDLCFrameInjectUnsignedShort())
            {
LABEL_18:
              HDLCFrameFree();
              HDLCFrameFree();
              return v23;
            }
            if (ETLSendCommand(a1, (uint64_t)v36, a6))
            {
              LOBYTE(v38[0]) = 39;
              uint64_t v23 = 0;
              if (!ETLFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v34, v38, a6)
                || LOBYTE(v38[0]) != 39)
              {
                goto LABEL_18;
              }
              if (DWORD2(v34[0]) <= 2)
              {
                _ETLDebugPrint((uint64_t)"ETLNVParseWriteResponseWithStatus", (uint64_t)"Response size %u not enough, need %u\n", v24, v25, v26, v27, v28, v29, 3);
              }
              else
              {
                uint64_t v30 = *(void *)&v34[0];
                if (*(unsigned __int16 *)(*(void *)&v34[0] + 1) != a2) {
                  _ETLDebugPrint((uint64_t)"ETLNVParseWriteResponseWithStatus", (uint64_t)"Returned item number %u mismatches expected %u\n", v24, v25, v26, v27, v28, v29, *(unsigned __int16 *)(*(void *)&v34[0] + 1));
                }
                uint64_t v31 = *(unsigned __int16 *)(v30 + 131);
                *a5 = v31;
                if (!v31)
                {
                  uint64_t v23 = 1;
                  goto LABEL_18;
                }
                _ETLDebugPrint((uint64_t)"ETLNVParseWriteResponseWithStatus", (uint64_t)"NV write response indicates failure with status code %u\n", v24, v25, v26, v27, v28, v29, v31);
              }
            }
          }
        }
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLNVWriteWithStatus", (uint64_t)"Failed to create command frame\n", v11, v12, v13, v14, v15, v16, v33);
    }
    uint64_t v23 = 0;
    goto LABEL_18;
  }
  return 0;
}

void *ETLMaverickNVReadFactory(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, void *a3, uint64_t a4, _WORD *a5, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a3 || !a5 || !a6)
  {
    uint64_t v35 = "Transport, destBuffer, amountRead, or status memory cannot be NULL\n";
LABEL_22:
    _ETLDebugPrint((uint64_t)"ETLMaverickNVReadFactory", (uint64_t)v35, (uint64_t)a3, a4, (uint64_t)a5, (uint64_t)a6, a7, a8, v37);
    return 0;
  }
  if (a4 > 0x7F)
  {
    long long v40 = 0u;
    long long v41 = 0u;
    uint64_t v42 = 0;
    memset(v38, 0, sizeof(v38));
    uint64_t v39 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v15, v16, v17, v18, v19, v20, FreeSpace);
      }
      else
      {
        int v43 = 1900107;
        if (HDLCFrameInject())
        {
          if (HDLCFrameInjectUnsignedInt())
          {
            uint64_t v27 = malloc((2 * DWORD2(v40) + 32));
            if (!v27)
            {
LABEL_28:
              HDLCFrameFree();
              HDLCFrameFree();
              return v27;
            }
            uint64_t v28 = HDLCFrameEncode();
            if (!v28) {
              goto LABEL_29;
            }
            uint64_t v29 = v28;
            int v43 = -1431655766;
            if ((_ETLDebugFlags & 2) != 0) {
              ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v27, v28);
            }
            if (*a1)
            {
              int v30 = (*a1)(a1, v27, v29, &v43, 1, a7, 0);
              int v31 = v43;
              free(v27);
              uint64_t v27 = 0;
              if (!v30 || v31 != v29) {
                goto LABEL_28;
              }
              if (ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v38, a7))
              {
                uint64_t v27 = (void *)ETLMaverickParseNVReadFactory((_DWORD **)v38, a3, a4, a5, a6, v32, v33, v34);
                goto LABEL_28;
              }
            }
            else
            {
LABEL_29:
              free(v27);
            }
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v21, v22, v23, v24, v25, v26, v37);
        }
      }
      uint64_t v27 = 0;
      goto LABEL_28;
    }
    uint64_t v35 = "Failed to create command frame\n";
    goto LABEL_22;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickNVReadFactory", (uint64_t)"Buffer size (%u) should be more than %u\n", (uint64_t)a3, a4, (uint64_t)a5, (uint64_t)a6, a7, a8, a4);
  return 0;
}

uint64_t ETLMaverickParseNVReadFactory(_DWORD **a1, void *__dst, uint64_t a3, _WORD *a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a4 = 0;
  *a5 = 4;
  unsigned int v8 = *((_DWORD *)a1 + 2);
  uint64_t v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, *((unsigned int *)a1 + 2));
LABEL_14:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseNVReadFactory", (uint64_t)"Failed on parsing Factory Response Header.\n", v16, v17, v18, v19, v20, v21, v23);
    return 0;
  }
  uint64_t v10 = (unsigned __int16 *)*a1;
  unsigned int v11 = **a1;
  if (v11 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, **a1);
    goto LABEL_14;
  }
  if (BYTE1(v11) != 254)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, BYTE1(v11));
    goto LABEL_14;
  }
  uint64_t v12 = HIWORD(v11);
  if (v12 != 28)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v12);
    goto LABEL_14;
  }
  if (v9 <= 3)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseNVReadFactory", (uint64_t)"Received response has only %u bytes, need %u\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v9);
    return 0;
  }
  else
  {
    int v13 = v10[2];
    if (v13 != 5 && v10[2])
    {
      *a5 = v13;
      _ETLDebugPrint((uint64_t)"ETLMaverickParseNVReadFactory", (uint64_t)"Failed on NV Read via Factory command.\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v22);
      return 0;
    }
    else
    {
      *a5 = v13;
      size_t v14 = v10[3];
      *a4 = v14;
      if (v14 <= a3)
      {
        memcpy(__dst, v10 + 4, v14);
        return 1;
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseNVReadFactory", (uint64_t)"Read amount, %u, is greater than the destination buffer size (%u)\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v14);
        return 0;
      }
    }
  }
}

uint64_t ETLMaverickNVWriteFactory(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a3)
  {
    int v31 = "Transport or srcBuffer cannot be NULL\n";
LABEL_15:
    _ETLDebugPrint((uint64_t)"ETLMaverickNVWriteFactory", (uint64_t)v31, a3, a4, a5, a6, a7, a8, v33);
    return 0;
  }
  if (a4 < 0x2000)
  {
    memset(v36, 0, sizeof(v36));
    uint64_t v37 = 0;
    memset(v34, 0, sizeof(v34));
    uint64_t v35 = 0;
    if (HDLCFrameCreateUplink())
    {
      uint64_t FreeSpace = HDLCFrameGetFreeSpace();
      if (FreeSpace < 4)
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
      }
      else
      {
        int v38 = 1965643;
        if (HDLCFrameInject())
        {
          if (HDLCFrameInjectUnsignedInt()
            && HDLCFrameInject()
            && ETLSendCommand(a1, (uint64_t)v36, a5)
            && ETLSubsysFindMatchingResponse((uint64_t)a1, (unsigned __int8 **)v34, a5))
          {
            uint64_t v30 = ETLMaverickParseNVWriteFactory((unsigned int *)v34, v23, v24, v25, v26, v27, v28, v29);
LABEL_21:
            HDLCFrameFree();
            HDLCFrameFree();
            return v30;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v17, v18, v19, v20, v21, v22, v33);
        }
      }
      uint64_t v30 = 0;
      goto LABEL_21;
    }
    int v31 = "Failed to create command frame\n";
    goto LABEL_15;
  }
  _ETLDebugPrint((uint64_t)"ETLMaverickNVWriteFactory", (uint64_t)"Buffer size (%u) should be less than %u\n", a3, a4, a5, a6, a7, a8, a4);
  return 0;
}

uint64_t ETLMaverickParseNVWriteFactory(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a1[2];
  uint64_t v9 = v8 - 4;
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
LABEL_12:
    _ETLDebugPrint((uint64_t)"ETLMaverickParseNVWriteFactory", (uint64_t)"Failed on parsing Factory Response Header.\n", v13, v14, v15, v16, v17, v18, v20);
    return 0;
  }
  unsigned int v10 = **(_DWORD **)a1;
  if (v10 != 75)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
    goto LABEL_12;
  }
  if (BYTE1(v10) != 254)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v10));
    goto LABEL_12;
  }
  uint64_t v11 = HIWORD(v10);
  if (v11 != 29)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v11);
    goto LABEL_12;
  }
  if (v9 <= 1)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseNVWriteFactory", (uint64_t)"Received response has only %u bytes, need %u\n", a3, a4, a5, a6, a7, a8, v9);
    return 0;
  }
  else if (*(unsigned __int16 *)(*(void *)a1 + 4) >= 2u)
  {
    _ETLDebugPrint((uint64_t)"ETLMaverickParseNVWriteFactory", (uint64_t)"Failed on writing NV via Factory command\n", a3, a4, a5, a6, a7, a8, v19);
    return 0;
  }
  else
  {
    return 1;
  }
}

double ETLPingParametersInit(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = xmmword_1E458FFB0;
  *(void *)(a1 + 32) = &__block_literal_global;
  *(void *)(a1 + 40) = &__block_literal_global_4;
  return result;
}

uint64_t _block_invoke()
{
  return 1;
}

uint64_t ETLPing(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 8))
  {
LABEL_5:
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v5 = *(const void **)(a2 + 16);
    if (v5 && (unsigned int v6 = *(_DWORD *)(a2 + 24)) != 0)
    {
      if (*(unsigned char *)(a2 + 28)) {
        size_t v7 = v6 + 4;
      }
      else {
        size_t v7 = v6;
      }
      unsigned int v8 = malloc(v7);
    }
    else
    {
      if (!*(unsigned char *)(a2 + 28))
      {
        if (*(_DWORD *)a2)
        {
          unsigned int v10 = (unsigned int *)(a2 + 4);
LABEL_24:
          uint64_t v11 = 0;
          while (1)
          {
            if (!ETLBBSendEcho(a1, (uint64_t)&v14))
            {
LABEL_29:
              unsigned int v8 = 0;
              uint64_t v12 = 0;
              goto LABEL_36;
            }
            if (ETLBBCheckEchoResponse((uint64_t)a1, (uint64_t)&v14, 1, *v10)) {
              break;
            }
            if ((*(unsigned int (**)(void, uint64_t))(*(void *)(a2 + 32) + 16))(*(void *)(a2 + 32), v11))
            {
              uint64_t v11 = (v11 + 1);
              if (v11 < *(_DWORD *)a2) {
                continue;
              }
            }
            goto LABEL_29;
          }
          unsigned int v8 = 0;
LABEL_34:
          (*(void (**)(void, uint64_t))(*(void *)(a2 + 40) + 16))(*(void *)(a2 + 40), v11);
          goto LABEL_35;
        }
        unsigned int v8 = 0;
        goto LABEL_35;
      }
      unsigned int v6 = *(_DWORD *)(a2 + 24);
      LODWORD(v7) = v6 + 4;
      uint64_t v9 = malloc(v6 + 4);
      unsigned int v8 = v9;
      if (!v6)
      {
        uint64_t v14 = v9;
        LODWORD(v15) = 4;
        if (*(_DWORD *)a2)
        {
LABEL_14:
          unsigned int v10 = (unsigned int *)(a2 + 4);
          if (v8)
          {
            uint64_t v11 = 0;
            do
            {
              _DWORD *v8 = v11;
              if (!ETLBBSendEcho(a1, (uint64_t)&v14)) {
                break;
              }
              if (ETLBBCheckEchoResponse((uint64_t)a1, (uint64_t)&v14, 1, *v10)) {
                goto LABEL_34;
              }
              if (!(*(unsigned int (**)(void, uint64_t))(*(void *)(a2 + 32) + 16))(*(void *)(a2 + 32), v11))break; {
              uint64_t v11 = (v11 + 1);
              }
            }
            while (v11 < *(_DWORD *)a2);
            uint64_t v12 = 0;
            goto LABEL_36;
          }
          goto LABEL_24;
        }
LABEL_35:
        uint64_t v12 = 1;
LABEL_36:
        free(v8);
        return v12;
      }
    }
    memcpy(v8 + 1, v5, v6);
    uint64_t v14 = v8;
    LODWORD(v15) = v7;
    if (*(_DWORD *)a2) {
      goto LABEL_14;
    }
    goto LABEL_35;
  }
  int v4 = 0;
  while (ETLBBPing(a1))
  {
    usleep(1000 * *(_DWORD *)(a2 + 12));
    if (++v4 >= *(_DWORD *)(a2 + 8)) {
      goto LABEL_5;
    }
  }
  return 0;
}

void *ETLTimestampGetTimeval(void *result, uint64_t a2)
{
  unsigned int v2 = (43685 * (unsigned __int16)*result) >> 16;
  unint64_t v3 = 5 * (*result >> 16)
     + ((unsigned __int16)(v2 + ((unsigned __int16)((*result - v2) & 0xFFFE) >> 1)) >> 13)
     + 2;
  *(void *)a2 = ((v3 * (unsigned __int128)0x10624DD2F1A9FCuLL) >> 64) + 315964800;
  *(_DWORD *)(a2 + 8) = 1000 * ((v3 >> 2) - 1000 * (((v3 >> 2) * (unsigned __int128)0x4189374BC6A7F0uLL) >> 64));
  return result;
}

uint64_t ETLTimestampFromTimeval(uint64_t result, void *a2)
{
  if (result)
  {
    if (a2) {
      *a2 = ((unsigned __int16)(-25600 * (*(_DWORD *)(result + 8) % 1250)) | (unint64_t)((800
    }
                                                                                               * *(void *)result
                                                                                               + *(_DWORD *)(result + 8)
                                                                                               / 1250) << 16))
          - 16565655306240000;
  }
  return result;
}

uint64_t ETLTimestampGetHoursMinutesSeconds(uint64_t result, int *a2, int *a3, _DWORD *a4)
{
  *a4 = result % 60;
  *a3 = (int)(result / 60) % 60;
  *a2 = (int)(result / 3600) % 24;
  return result;
}

uint64_t ETLTimestampsEqual(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2 = bswap64(*a1);
  unint64_t v3 = bswap64(*a2);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 > v3;
  int v6 = !v4;
  return (v5 - v6);
}

uint64_t eUICC::GetVinylType::Perform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  HIDWORD(v43) = -1431655766;
  int v44 = -1431655766;
  unsigned int v8 = *(void **)a1;
  if (!*(void *)a1)
  {
    LODWORD(v43) = 22;
    long long v40 = "transport";
LABEL_31:
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", a3, a4, a5, a6, a7, a8, (uint64_t)v40);
    goto LABEL_32;
  }
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_30;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
    goto LABEL_30;
  }
  LODWORD(__src[0]) = 8453451;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v17, v18, v19, v20, v21, v22, v42);
    goto LABEL_30;
  }
  if ((HDLCFrameInjectUnsignedChar() & 1) == 0)
  {
LABEL_30:
    LODWORD(v43) = 12;
    long long v40 = "success";
    goto LABEL_31;
  }
  uint64_t v23 = *(unsigned int *)(a1 + 12);
  v24.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  uint64_t v47 = 0;
  *(_OWORD *)int __src = 0u;
  long long v46 = 0u;
  HIDWORD(v43) = 0;
  LOWORD(v44) = 0;
  while (1)
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    uint64_t v25 = malloc(0x20uLL);
    if (!v25) {
      goto LABEL_34;
    }
    uint64_t v32 = v25;
    uint64_t v33 = HDLCFrameEncode();
    if (!v33) {
      goto LABEL_33;
    }
    uint64_t v34 = v33;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v32, v33);
    }
    if (!*v8)
    {
LABEL_33:
      free(v32);
LABEL_34:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v26, v27, v28, v29, v30, v31, (uint64_t)"success");
      int v39 = 5;
      goto LABEL_35;
    }
    int v35 = ((uint64_t (*)(void *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, void))*v8)(v8, v32, v34, &__ns, 1, v23, 0);
    int rep = __ns.__rep_;
    free(v32);
    if (v35) {
      BOOL v37 = rep == v34;
    }
    else {
      BOOL v37 = 0;
    }
    if (!v37) {
      goto LABEL_34;
    }
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)v8, (unsigned __int8 **)__src, (uint64_t)&_ETLResponseRingBuffer, &__ns, v23)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_34;
    }
    size_t v38 = LODWORD(__src[1]) >= 6 ? 6 : LODWORD(__src[1]);
    memcpy((char *)&v43 + 4, __src[0], v38);
    if (v44 != 2) {
      break;
    }
    if (std::chrono::steady_clock::now().__d_.__rep_ - v24.__d_.__rep_ > 1000000 * v23)
    {
      int v39 = 60;
      goto LABEL_35;
    }
  }
  int v39 = 0;
LABEL_35:
  HDLCFrameFree();
  LODWORD(v43) = v39;
LABEL_32:
  HDLCFrameFree();
  return v43;
}

uint64_t eUICC::GetData::Perform@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, uint64_t a8@<X8>)
{
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)(a8 + 4) = v9;
  unsigned int v10 = (_OWORD *)(a8 + 4);
  *(_OWORD *)(a8 + 244) = v9;
  *(_OWORD *)(a8 + 228) = v9;
  *(_OWORD *)(a8 + 212) = v9;
  *(_OWORD *)(a8 + 196) = v9;
  *(_OWORD *)(a8 + 180) = v9;
  *(_OWORD *)(a8 + 164) = v9;
  *(_OWORD *)(a8 + 148) = v9;
  *(_OWORD *)(a8 + 132) = v9;
  *(_OWORD *)(a8 + 116) = v9;
  *(_OWORD *)(a8 + 100) = v9;
  *(_OWORD *)(a8 + 84) = v9;
  *(_OWORD *)(a8 + 68) = v9;
  *(_OWORD *)(a8 + 52) = v9;
  *(_OWORD *)(a8 + 36) = v9;
  *(_OWORD *)(a8 + 20) = v9;
  *(_DWORD *)a8 = -1;
  uint64_t v11 = *(void **)a1;
  if (!*(void *)a1)
  {
    *(_DWORD *)a8 = 22;
    uint64_t v43 = "transport";
LABEL_31:
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", a2, a3, a4, a5, a6, a7, (uint64_t)v43);
    return HDLCFrameFree();
  }
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_30;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v14, v15, v16, v17, v18, v19, FreeSpace);
    goto LABEL_30;
  }
  LODWORD(__src[0]) = 5700939;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v20, v21, v22, v23, v24, v25, v45);
    goto LABEL_30;
  }
  if ((HDLCFrameInjectUnsignedChar() & 1) == 0)
  {
LABEL_30:
    *(_DWORD *)a8 = 12;
    uint64_t v43 = "success";
    goto LABEL_31;
  }
  uint64_t v26 = *(unsigned int *)(a1 + 12);
  v27.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  uint64_t v48 = 0;
  *(_OWORD *)int __src = 0u;
  long long v47 = 0u;
  *unsigned int v10 = 0u;
  v10[1] = 0u;
  v10[2] = 0u;
  void v10[3] = 0u;
  v10[4] = 0u;
  v10[5] = 0u;
  v10[6] = 0u;
  v10[7] = 0u;
  v10[8] = 0u;
  v10[9] = 0u;
  v10[10] = 0u;
  v10[11] = 0u;
  v10[12] = 0u;
  v10[13] = 0u;
  v10[14] = 0u;
  *(_OWORD *)((char *)v10 + 238) = 0u;
  while (1)
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    uint64_t v28 = malloc(0x20uLL);
    if (!v28) {
      goto LABEL_34;
    }
    int v35 = v28;
    uint64_t v36 = HDLCFrameEncode();
    if (!v36) {
      goto LABEL_33;
    }
    uint64_t v37 = v36;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v35, v36);
    }
    if (!*v11)
    {
LABEL_33:
      free(v35);
LABEL_34:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v29, v30, v31, v32, v33, v34, (uint64_t)"success");
      int v42 = 5;
      goto LABEL_35;
    }
    int v38 = ((uint64_t (*)(void *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, void))*v11)(v11, v35, v37, &__ns, 1, v26, 0);
    int rep = __ns.__rep_;
    free(v35);
    if (v38) {
      BOOL v40 = rep == v37;
    }
    else {
      BOOL v40 = 0;
    }
    if (!v40) {
      goto LABEL_34;
    }
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)v11, (unsigned __int8 **)__src, (uint64_t)&_ETLResponseRingBuffer, &__ns, v26)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_34;
    }
    size_t v41 = LODWORD(__src[1]) >= 0xFE ? 254 : LODWORD(__src[1]);
    memcpy(v10, __src[0], v41);
    if (*(unsigned char *)(a8 + 8) != 2) {
      break;
    }
    if (std::chrono::steady_clock::now().__d_.__rep_ - v27.__d_.__rep_ > 1000000 * v26)
    {
      int v42 = 60;
      goto LABEL_35;
    }
  }
  int v42 = 0;
LABEL_35:
  HDLCFrameFree();
  *(_DWORD *)a8 = v42;
  return HDLCFrameFree();
}

uint64_t eUICC::SwitchMode::Perform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v30[0] = 0xAAAAAAAAFFFFFFFFLL;
  v30[1] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v29 = 0;
  memset(v28, 0, sizeof(v28));
  uint64_t v27 = 0;
  memset(v26, 0, sizeof(v26));
  unsigned int v8 = *(void **)a1;
  if (!*(void *)a1)
  {
    LODWORD(v30[0]) = 22;
    uint64_t v23 = "transport";
LABEL_21:
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", a3, a4, a5, a6, a7, a8, (uint64_t)v23);
    goto LABEL_22;
  }
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_19;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v11, v12, v13, v14, v15, v16, FreeSpace);
LABEL_19:
    LODWORD(v30[0]) = 12;
LABEL_20:
    uint64_t v23 = "success";
    goto LABEL_21;
  }
  int v31 = 5766475;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v17, v18, v19, v20, v21, v22, v25);
    goto LABEL_19;
  }
  if (!HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || (HDLCFrameInjectUnsignedChar() & 1) == 0)
  {
    goto LABEL_19;
  }
  if (!ETLSendCommand((uint64_t (**)(void, void *, uint64_t, int *, uint64_t, uint64_t, void))v8, (uint64_t)v28, *(unsigned int *)(a1 + 12))|| (ETLSubsysFindMatchingResponse((uint64_t)v8, (unsigned __int8 **)v26, *(_DWORD *)(a1 + 12)) & 1) == 0)
  {
    LODWORD(v30[0]) = 5;
    goto LABEL_20;
  }
  if (DWORD2(v26[0]) != 8)
  {
    LODWORD(v30[0]) = 40;
    uint64_t v23 = "sizeof(result) == HDLCFrameGetPayloadLength( &rsp)";
    goto LABEL_21;
  }
  if (*(unsigned char *)(*(void *)&v26[0] + 4) != 1)
  {
    LODWORD(v30[0]) = -4;
    uint64_t v23 = "VinylError::kStatusSuccess == result.cmd_ack_status";
    goto LABEL_21;
  }
  HDLCFrameFree();
  if (!HDLCFrameCreateUplink()
    || !ETLMaverickAddBSPCommandHeader()
    || (HDLCFrameInjectUnsignedShort() & 1) == 0)
  {
    LODWORD(v30[0]) = 12;
    goto LABEL_20;
  }
  LODWORD(v30[0]) = eUICC::PollResult<eUICC::SwitchMode::Response::{unnamed type#1}>((uint64_t)v28, (uint64_t)v30 + 4, v8, *(unsigned int *)(a1 + 12));
LABEL_22:
  HDLCFrameFree();
  HDLCFrameFree();
  return v30[0];
}

uint64_t eUICC::PollResult<eUICC::SwitchMode::Response::{unnamed type#1}>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  v8.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  uint64_t v26 = 0;
  memset(v25, 0, sizeof(v25));
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 0;
  do
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    long long v9 = malloc((2 * *(_DWORD *)(a1 + 8) + 32));
    if (!v9) {
      goto LABEL_22;
    }
    uint64_t v16 = v9;
    uint64_t v17 = HDLCFrameEncode();
    if (!v17) {
      goto LABEL_21;
    }
    uint64_t v18 = v17;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
    }
    if (!*a3)
    {
LABEL_21:
      free(v16);
LABEL_22:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v10, v11, v12, v13, v14, v15, (uint64_t)"success");
      uint64_t v23 = 5;
      goto LABEL_23;
    }
    int v19 = ((uint64_t (*)(void *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, void))*a3)(a3, v16, v18, &__ns, 1, a4, 0);
    int rep = __ns.__rep_;
    free(v16);
    if (v19) {
      BOOL v21 = rep == v18;
    }
    else {
      BOOL v21 = 0;
    }
    if (!v21) {
      goto LABEL_22;
    }
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a3, (unsigned __int8 **)v25, (uint64_t)&_ETLResponseRingBuffer, &__ns, a4)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_22;
    }
    if (DWORD2(v25[0]) < 0xC)
    {
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v10, v11, v12, v13, v14, v15, DWORD2(v25[0]));
    }
    else
    {
      int v22 = *(_DWORD *)(*(void *)&v25[0] + 8);
      *(void *)a2 = **(void **)&v25[0];
      *(_DWORD *)(a2 + 8) = v22;
      if (v22 != 2)
      {
        uint64_t v23 = 0;
        goto LABEL_23;
      }
    }
  }
  while (std::chrono::steady_clock::now().__d_.__rep_ - v8.__d_.__rep_ <= 1000000 * a4);
  uint64_t v23 = 60;
LABEL_23:
  HDLCFrameFree();
  return v23;
}

uint64_t eUICC::InstallTicket::Perform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v80 = 0;
  long long v78 = 0u;
  long long v79 = 0u;
  uint64_t v77 = 0;
  memset(v76, 0, sizeof(v76));
  std::chrono::steady_clock::time_point v8 = *(void **)a1;
  unint64_t v9 = *(void *)(a1 + 24);
  if (v9 % 0x5DC) {
    unint64_t v10 = v9 / 0x5DC + 1;
  }
  else {
    unint64_t v10 = v9 / 0x5DC;
  }
  if (!v8)
  {
    uint64_t v14 = 2863311530;
    uint64_t v63 = "transport";
    goto LABEL_57;
  }
  if (!*(void *)(a1 + 16) || !v9 || !v10)
  {
    uint64_t v14 = 2863311530;
    uint64_t v63 = "request.data && request.data_len && segment_count";
LABEL_57:
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", a3, a4, a5, a6, a7, a8, (uint64_t)v63);
    uint64_t v62 = 22;
    goto LABEL_58;
  }
  uint64_t v12 = 0;
  int v13 = (unsigned __int16)v10;
  uint64_t v14 = 2863311530;
  while (2)
  {
    if (!HDLCFrameCreateUplink()) {
      goto LABEL_68;
    }
    uint64_t FreeSpace = HDLCFrameGetFreeSpace();
    if (FreeSpace < 4) {
      goto LABEL_71;
    }
    LODWORD(v81[0]) = 5897547;
    if ((HDLCFrameInject() & 1) == 0)
    {
LABEL_67:
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v28, v29, v30, v31, v32, v33, v71);
LABEL_68:
      _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v15, v16, v17, v18, v19, v20, (uint64_t)"success");
      uint64_t v62 = 12;
      break;
    }
    if (!HDLCFrameInjectUnsignedChar()
      || !HDLCFrameInjectUnsignedShort()
      || !HDLCFrameInjectUnsignedShort()
      || !HDLCFrameInjectUnsignedShort()
      || (HDLCFrameInject() & 1) == 0)
    {
      goto LABEL_68;
    }
    int v72 = v13;
    uint64_t v73 = v12;
    unint64_t v74 = v10;
    uint64_t v34 = *(unsigned int *)(a1 + 32);
    int v35 = malloc((2 * DWORD2(v78) + 32));
    if (!v35)
    {
LABEL_64:
      _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v36, v37, v38, v39, v40, v41, (uint64_t)"success");
      uint64_t v62 = 5;
      break;
    }
    int v42 = v35;
    uint64_t v43 = HDLCFrameEncode();
    if (!v43) {
      goto LABEL_63;
    }
    uint64_t v44 = v43;
    LODWORD(v81[0]) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v42, v43);
    }
    if (!*v8)
    {
LABEL_63:
      free(v42);
      goto LABEL_64;
    }
    int v45 = ((uint64_t (*)(void *, void *, uint64_t, _OWORD *, uint64_t, uint64_t, void))*v8)(v8, v42, v44, v81, 1, v34, 0);
    int v46 = v81[0];
    free(v42);
    if (!v45 || v46 != v44) {
      goto LABEL_64;
    }
    unsigned int v47 = *(_DWORD *)(a1 + 32);
    LOBYTE(v81[0]) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)v8, (unsigned __int8 **)v76, (uint64_t)&_ETLResponseRingBuffer, v81, v47)|| LOBYTE(v81[0]) != 75)
    {
      goto LABEL_64;
    }
    if (DWORD2(v76[0]) != 6)
    {
      _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v36, v37, v38, v39, v40, v41, (uint64_t)"sizeof( result) == HDLCFrameGetPayloadLength( &rsp)");
      uint64_t v62 = 40;
      break;
    }
    if (*(unsigned char *)(*(void *)&v76[0] + 4) != 1)
    {
      _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v36, v37, v38, v39, v40, v41, (uint64_t)"VinylError::kStatusSuccess == result.cmd_ack_status");
      uint64_t v62 = 4294967286;
      break;
    }
    HDLCFrameFree();
    if (!HDLCFrameCreateUplink()) {
      goto LABEL_68;
    }
    uint64_t FreeSpace = HDLCFrameGetFreeSpace();
    if (FreeSpace < 4)
    {
LABEL_71:
      _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v22, v23, v24, v25, v26, v27, FreeSpace);
      goto LABEL_68;
    }
    LODWORD(v81[0]) = 4980043;
    if ((HDLCFrameInject() & 1) == 0) {
      goto LABEL_67;
    }
    if ((HDLCFrameInjectUnsignedShort() & 1) == 0) {
      goto LABEL_68;
    }
    uint64_t v48 = *(unsigned int *)(a1 + 32);
    v75.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
    uint64_t v14 = 0;
    uint64_t v82 = 0;
    memset(v81, 0, sizeof(v81));
    while (1)
    {
      __ns.__rep_ = 100000000;
      std::this_thread::sleep_for (&__ns);
      uint64_t v49 = malloc((2 * DWORD2(v78) + 32));
      if (!v49) {
        goto LABEL_60;
      }
      unsigned int v56 = v49;
      uint64_t v57 = HDLCFrameEncode();
      if (!v57) {
        goto LABEL_59;
      }
      uint64_t v58 = v57;
      LODWORD(__ns.__rep_) = -1431655766;
      if ((_ETLDebugFlags & 2) != 0) {
        ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v56, v57);
      }
      if (!*v8)
      {
LABEL_59:
        free(v56);
LABEL_60:
        _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v50, v51, v52, v53, v54, v55, (uint64_t)"success");
        uint64_t v62 = 5;
LABEL_61:
        HDLCFrameFree();
        _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v65, v66, v67, v68, v69, v70, (uint64_t)"0 == response.error");
        goto LABEL_58;
      }
      int v59 = ((uint64_t (*)(void *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, void))*v8)(v8, v56, v58, &__ns, 1, v48, 0);
      int rep = __ns.__rep_;
      free(v56);
      if (v59) {
        BOOL v61 = rep == v58;
      }
      else {
        BOOL v61 = 0;
      }
      if (!v61) {
        goto LABEL_60;
      }
      LOBYTE(__ns.__rep_) = 75;
      if (!_ETLResponseRingBuffer) {
        TelephonyUtilRingBufferInitialize();
      }
      if (!ETLFindMatchingResponseUsingBuffer((uint64_t)v8, (unsigned __int8 **)v81, (uint64_t)&_ETLResponseRingBuffer, &__ns, v48)|| LOBYTE(__ns.__rep_) != 75)
      {
        goto LABEL_60;
      }
      if (DWORD2(v81[0]) >= 0xB) {
        break;
      }
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v50, v51, v52, v53, v54, v55, DWORD2(v81[0]));
LABEL_36:
      if (std::chrono::steady_clock::now().__d_.__rep_ - v75.__d_.__rep_ > 1000000 * v48)
      {
        uint64_t v62 = 60;
        goto LABEL_61;
      }
    }
    uint64_t v14 = **(_DWORD **)&v81[0];
    if (((*(unsigned int *)(*(void *)&v81[0] + 4) | ((unint64_t)(*(unsigned __int16 *)(*(void *)&v81[0]
                                                                                                 + 8) | (*(unsigned __int8 *)(*(void *)&v81[0] + 10) << 16)) << 32)) & 0xFF00000000) == 0x200000000)
      goto LABEL_36;
    HDLCFrameFree();
    uint64_t v62 = 0;
    unint64_t v10 = v74;
    uint64_t v12 = v73 + 1;
    int v13 = v72;
    if (v73 + 1 != v74) {
      continue;
    }
    break;
  }
LABEL_58:
  HDLCFrameFree();
  return v62 | (v14 << 32);
}

uint64_t eUICC::StreamAPDU::Perform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v35[0] = 0xAAAAAAAAFFFFFFFFLL;
  v35[1] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v34 = 0;
  memset(v33, 0, sizeof(v33));
  uint64_t v32 = 0;
  memset(v31, 0, sizeof(v31));
  int v8 = _ETLDebugFlags & 2;
  _ETLDebugFlags &= ~2u;
  unint64_t v9 = *(void **)a1;
  if (!*(void *)a1)
  {
    LODWORD(v35[0]) = 22;
    uint64_t v28 = "transport";
LABEL_34:
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", a3, a4, a5, a6, a7, a8, (uint64_t)v28);
    goto LABEL_35;
  }
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_32;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
LABEL_32:
    LODWORD(v35[0]) = 12;
LABEL_33:
    uint64_t v28 = "success";
    goto LABEL_34;
  }
  int v36 = 5832011;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v18, v19, v20, v21, v22, v23, v30);
    goto LABEL_32;
  }
  if (!HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedShort()
    || !HDLCFrameInjectUnsignedShort())
  {
    goto LABEL_32;
  }
  int v24 = HDLCFrameInjectUnsignedChar();
  if (v24 && *(unsigned char *)(a1 + 14))
  {
    uint64_t v25 = 0;
    unint64_t v26 = 1;
    while (*(void *)(a1 + 24) >= v26 - 1)
    {
      if (!HDLCFrameInjectUnsignedChar()
        || !HDLCFrameInject()
        || !HDLCFrameInjectUnsignedChar())
      {
        goto LABEL_32;
      }
      int v24 = HDLCFrameInject();
      v25 += 32;
      if (v24) {
        BOOL v27 = v26 >= *(unsigned __int8 *)(a1 + 14);
      }
      else {
        BOOL v27 = 1;
      }
      ++v26;
      if (v27) {
        goto LABEL_20;
      }
    }
    LODWORD(v35[0]) = 22;
    uint64_t v28 = "i <= request.apdu_payload.apdu_data_size";
    goto LABEL_34;
  }
LABEL_20:
  if ((v24 & 1) == 0) {
    goto LABEL_32;
  }
  if ((ETLSendCommand((uint64_t (**)(void, void *, uint64_t, int *, uint64_t, uint64_t, void))v9, (uint64_t)v33, *(unsigned int *)(a1 + 32)) & 1) == 0)
  {
    LODWORD(v35[0]) = 5;
    goto LABEL_33;
  }
  _ETLDebugFlags |= v8;
  if ((ETLSubsysFindMatchingResponse((uint64_t)v9, (unsigned __int8 **)v31, *(_DWORD *)(a1 + 32)) & 1) == 0)
  {
    LODWORD(v35[0]) = 5;
    goto LABEL_33;
  }
  if (DWORD2(v31[0]) != 6)
  {
    LODWORD(v35[0]) = 40;
    uint64_t v28 = "sizeof( result) == HDLCFrameGetPayloadLength( &rsp)";
    goto LABEL_34;
  }
  if (*(unsigned char *)(*(void *)&v31[0] + 4) != 1)
  {
    LODWORD(v35[0]) = -10;
    uint64_t v28 = "VinylError::kStatusSuccess == result.cmd_ack_status";
    goto LABEL_34;
  }
  HDLCFrameFree();
  if (!HDLCFrameCreateUplink()
    || !ETLMaverickAddBSPCommandHeader()
    || (HDLCFrameInjectUnsignedShort() & 1) == 0)
  {
    LODWORD(v35[0]) = 12;
    goto LABEL_33;
  }
  LODWORD(v35[0]) = eUICC::PollResult<eUICC::StreamAPDU::Response::{unnamed type#1}>((uint64_t)v33, (uint64_t)v35 + 4, v9, *(unsigned int *)(a1 + 32));
LABEL_35:
  _ETLDebugFlags |= v8;
  HDLCFrameFree();
  return v35[0];
}

uint64_t eUICC::PollResult<eUICC::StreamAPDU::Response::{unnamed type#1}>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  v8.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  uint64_t v26 = 0;
  memset(v25, 0, sizeof(v25));
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 7) = 0;
  do
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    unint64_t v9 = malloc((2 * *(_DWORD *)(a1 + 8) + 32));
    if (!v9) {
      goto LABEL_22;
    }
    uint64_t v16 = v9;
    uint64_t v17 = HDLCFrameEncode();
    if (!v17) {
      goto LABEL_21;
    }
    uint64_t v18 = v17;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
    }
    if (!*a3)
    {
LABEL_21:
      free(v16);
LABEL_22:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v10, v11, v12, v13, v14, v15, (uint64_t)"success");
      uint64_t v23 = 5;
      goto LABEL_23;
    }
    int v19 = ((uint64_t (*)(void *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, void))*a3)(a3, v16, v18, &__ns, 1, a4, 0);
    int rep = __ns.__rep_;
    free(v16);
    if (v19) {
      BOOL v21 = rep == v18;
    }
    else {
      BOOL v21 = 0;
    }
    if (!v21) {
      goto LABEL_22;
    }
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a3, (unsigned __int8 **)v25, (uint64_t)&_ETLResponseRingBuffer, &__ns, a4)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_22;
    }
    if (DWORD2(v25[0]) < 0xB)
    {
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v10, v11, v12, v13, v14, v15, DWORD2(v25[0]));
    }
    else
    {
      uint64_t v22 = **(void **)&v25[0];
      *(_DWORD *)(a2 + 7) = *(_DWORD *)(*(void *)&v25[0] + 7);
      *(void *)a2 = v22;
      if (*(unsigned char *)(a2 + 8) != 2)
      {
        uint64_t v23 = 0;
        goto LABEL_23;
      }
    }
  }
  while (std::chrono::steady_clock::now().__d_.__rep_ - v8.__d_.__rep_ <= 1000000 * a4);
  uint64_t v23 = 60;
LABEL_23:
  HDLCFrameFree();
  return v23;
}

uint64_t eUICC::InitPersoSession::Perform@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0xAAAAAAAAAAAAAAAALL;
  a2[1] = 0xAAAAAAAAAAAAAAAALL;
  BOOL v4 = operator new(0x90uLL);
  _OWORD *v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  v4[3] = 0u;
  v4[4] = 0u;
  v4[5] = 0u;
  v4[6] = 0u;
  v4[7] = 0u;
  v4[8] = 0u;
  *(_DWORD *)BOOL v4 = -1;
  *a2 = v4;
  BOOL v5 = operator new(0x20uLL);
  void *v5 = &unk_1F4023028;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a2[1] = v5;
  uint64_t v31 = 0;
  memset(v30, 0, sizeof(v30));
  uint64_t v12 = *(void **)a1;
  if (!*(void *)a1)
  {
    uint64_t v26 = "transport";
    int v27 = 22;
LABEL_15:
    *(_DWORD *)BOOL v4 = v27;
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v6, v7, v8, v9, v10, v11, (uint64_t)v26);
    return HDLCFrameFree();
  }
  if (!HDLCFrameCreateUplink())
  {
LABEL_14:
    uint64_t v26 = "success";
    int v27 = 12;
    goto LABEL_15;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v14, v15, v16, v17, v18, v19, FreeSpace);
    goto LABEL_14;
  }
  int v32 = 5963083;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v20, v21, v22, v23, v24, v25, v29);
    goto LABEL_14;
  }
  if (!HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedShort()
    || (HDLCFrameInject() & 1) == 0)
  {
    goto LABEL_14;
  }
  *(_DWORD *)BOOL v4 = eUICC::PollResult<eUICC::InitPersoSession::Response::contents>((uint64_t)v30, (_OWORD *)((char *)v4 + 4), v12, *(unsigned int *)(a1 + 28));
  return HDLCFrameFree();
}

void sub_1E4589104(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1E4589118(_Unwind_Exception *a1)
{
  std::shared_ptr<eUICC::InitPersoSession::Response>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t eUICC::PollResult<eUICC::InitPersoSession::Response::contents>(uint64_t a1, _OWORD *a2, void *a3, uint64_t a4)
{
  v8.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  uint64_t v27 = 0;
  *(_OWORD *)int __src = 0u;
  long long v26 = 0u;
  *a2 = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[5] = 0u;
  a2[6] = 0u;
  a2[7] = 0u;
  *(_OWORD *)((char *)a2 + 121) = 0u;
  do
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    uint64_t v9 = malloc((2 * *(_DWORD *)(a1 + 8) + 32));
    if (!v9) {
      goto LABEL_25;
    }
    uint64_t v16 = v9;
    uint64_t v17 = HDLCFrameEncode();
    if (!v17) {
      goto LABEL_24;
    }
    uint64_t v18 = v17;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
    }
    if (!*a3)
    {
LABEL_24:
      free(v16);
LABEL_25:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v10, v11, v12, v13, v14, v15, (uint64_t)"success");
      uint64_t v23 = 5;
      goto LABEL_26;
    }
    int v19 = ((uint64_t (*)(void *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, void))*a3)(a3, v16, v18, &__ns, 1, a4, 0);
    int rep = __ns.__rep_;
    free(v16);
    if (v19) {
      BOOL v21 = rep == v18;
    }
    else {
      BOOL v21 = 0;
    }
    if (!v21) {
      goto LABEL_25;
    }
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a3, (unsigned __int8 **)__src, (uint64_t)&_ETLResponseRingBuffer, &__ns, a4)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_25;
    }
    if (LODWORD(__src[1]) < 5)
    {
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v10, v11, v12, v13, v14, v15, LODWORD(__src[1]));
    }
    else
    {
      if (LODWORD(__src[1]) >= 0x89) {
        size_t v22 = 137;
      }
      else {
        size_t v22 = LODWORD(__src[1]);
      }
      memcpy(a2, __src[0], v22);
      if (*((unsigned char *)a2 + 4) != 2)
      {
        uint64_t v23 = 0;
        goto LABEL_26;
      }
    }
  }
  while (std::chrono::steady_clock::now().__d_.__rep_ - v8.__d_.__rep_ <= 1000000 * a4);
  uint64_t v23 = 60;
LABEL_26:
  HDLCFrameFree();
  return v23;
}

uint64_t std::shared_ptr<eUICC::InitPersoSession::Response>::~shared_ptr[abi:ne180100](uint64_t result)
{
  uint64_t v1 = result;
  unint64_t v2 = *(std::__shared_weak_count **)(result + 8);
  if (v2)
  {
    if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
      return v1;
    }
  }
  return result;
}

uint64_t eUICC::AuthPersoSession::Perform@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0xAAAAAAAAAAAAAAAALL;
  a2[1] = 0xAAAAAAAAAAAAAAAALL;
  BOOL v4 = operator new(0x210uLL);
  bzero(v4, 0x210uLL);
  *(_DWORD *)BOOL v4 = -1;
  *a2 = v4;
  BOOL v5 = operator new(0x20uLL);
  void *v5 = &unk_1F4023078;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a2[1] = v5;
  int v12 = _ETLDebugFlags & 2;
  _ETLDebugFlags &= ~2u;
  uint64_t v32 = 0;
  memset(v31, 0, sizeof(v31));
  uint64_t v13 = *(void **)a1;
  if (!*(void *)a1)
  {
    uint64_t v27 = "transport";
    int v28 = 22;
LABEL_15:
    *(_DWORD *)BOOL v4 = v28;
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v6, v7, v8, v9, v10, v11, (uint64_t)v27);
    goto LABEL_16;
  }
  if (!HDLCFrameCreateUplink())
  {
LABEL_14:
    uint64_t v27 = "success";
    int v28 = 12;
    goto LABEL_15;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v15, v16, v17, v18, v19, v20, FreeSpace);
    goto LABEL_14;
  }
  int v33 = 6028619;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v21, v22, v23, v24, v25, v26, v30);
    goto LABEL_14;
  }
  if (!HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedShort()
    || (HDLCFrameInject() & 1) == 0)
  {
    goto LABEL_14;
  }
  _ETLDebugFlags |= v12;
  *(_DWORD *)BOOL v4 = eUICC::PollResult<eUICC::AuthPersoSession::Response::contents>((uint64_t)v31, v4 + 4, v13, *(unsigned int *)(a1 + 2064));
LABEL_16:
  _ETLDebugFlags |= v12;
  return HDLCFrameFree();
}

void sub_1E458960C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1E4589620(_Unwind_Exception *a1)
{
  std::shared_ptr<eUICC::InitPersoSession::Response>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t eUICC::PollResult<eUICC::AuthPersoSession::Response::contents>(uint64_t a1, unsigned char *a2, void *a3, uint64_t a4)
{
  v8.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  uint64_t v27 = 0;
  *(_OWORD *)int __src = 0u;
  long long v26 = 0u;
  bzero(a2, 0x209uLL);
  do
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    uint64_t v9 = malloc((2 * *(_DWORD *)(a1 + 8) + 32));
    if (!v9) {
      goto LABEL_25;
    }
    uint64_t v16 = v9;
    uint64_t v17 = HDLCFrameEncode();
    if (!v17) {
      goto LABEL_24;
    }
    uint64_t v18 = v17;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
    }
    if (!*a3)
    {
LABEL_24:
      free(v16);
LABEL_25:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v10, v11, v12, v13, v14, v15, (uint64_t)"success");
      uint64_t v23 = 5;
      goto LABEL_26;
    }
    int v19 = ((uint64_t (*)(void *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, void))*a3)(a3, v16, v18, &__ns, 1, a4, 0);
    int rep = __ns.__rep_;
    free(v16);
    if (v19) {
      BOOL v21 = rep == v18;
    }
    else {
      BOOL v21 = 0;
    }
    if (!v21) {
      goto LABEL_25;
    }
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a3, (unsigned __int8 **)__src, (uint64_t)&_ETLResponseRingBuffer, &__ns, a4)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_25;
    }
    if (LODWORD(__src[1]) < 5)
    {
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v10, v11, v12, v13, v14, v15, LODWORD(__src[1]));
    }
    else
    {
      if (LODWORD(__src[1]) >= 0x209) {
        size_t v22 = 521;
      }
      else {
        size_t v22 = LODWORD(__src[1]);
      }
      memcpy(a2, __src[0], v22);
      if (a2[4] != 2)
      {
        uint64_t v23 = 0;
        goto LABEL_26;
      }
    }
  }
  while (std::chrono::steady_clock::now().__d_.__rep_ - v8.__d_.__rep_ <= 1000000 * a4);
  uint64_t v23 = 60;
LABEL_26:
  HDLCFrameFree();
  return v23;
}

uint64_t eUICC::FinalizePersoSession::Perform@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0xAAAAAAAAAAAAAAAALL;
  a2[1] = 0xAAAAAAAAAAAAAAAALL;
  BOOL v4 = operator new(0xCuLL);
  *(void *)BOOL v4 = 0;
  v4[2] = 0;
  _DWORD *v4 = -1;
  *a2 = v4;
  BOOL v5 = operator new(0x20uLL);
  void *v5 = &unk_1F40230C8;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a2[1] = v5;
  uint64_t v31 = 0;
  memset(v30, 0, sizeof(v30));
  uint64_t v12 = *(void **)a1;
  if (!*(void *)a1)
  {
    long long v26 = "transport";
    int v27 = 22;
LABEL_15:
    _DWORD *v4 = v27;
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v6, v7, v8, v9, v10, v11, (uint64_t)v26);
    return HDLCFrameFree();
  }
  if (!HDLCFrameCreateUplink())
  {
LABEL_14:
    long long v26 = "success";
    int v27 = 12;
    goto LABEL_15;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v14, v15, v16, v17, v18, v19, FreeSpace);
    goto LABEL_14;
  }
  int v32 = 6094155;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v20, v21, v22, v23, v24, v25, v29);
    goto LABEL_14;
  }
  if (!HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedShort()
    || (HDLCFrameInject() & 1) == 0)
  {
    goto LABEL_14;
  }
  _DWORD *v4 = eUICC::PollResult<eUICC::FinalizePersoSession::Response::contents>((uint64_t)v30, (unsigned char *)v4 + 4, v12, *(unsigned int *)(a1 + 272));
  return HDLCFrameFree();
}

void sub_1E4589A5C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1E4589A70(_Unwind_Exception *a1)
{
  std::shared_ptr<eUICC::InitPersoSession::Response>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t eUICC::PollResult<eUICC::FinalizePersoSession::Response::contents>(uint64_t a1, unsigned char *a2, void *a3, uint64_t a4)
{
  v8.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  uint64_t v27 = 0;
  *(_OWORD *)int __src = 0u;
  long long v26 = 0u;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 3) = 0;
  do
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    uint64_t v9 = malloc((2 * *(_DWORD *)(a1 + 8) + 32));
    if (!v9) {
      goto LABEL_25;
    }
    uint64_t v16 = v9;
    uint64_t v17 = HDLCFrameEncode();
    if (!v17) {
      goto LABEL_24;
    }
    uint64_t v18 = v17;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
    }
    if (!*a3)
    {
LABEL_24:
      free(v16);
LABEL_25:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v10, v11, v12, v13, v14, v15, (uint64_t)"success");
      uint64_t v23 = 5;
      goto LABEL_26;
    }
    int v19 = ((uint64_t (*)(void *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, void))*a3)(a3, v16, v18, &__ns, 1, a4, 0);
    int rep = __ns.__rep_;
    free(v16);
    if (v19) {
      BOOL v21 = rep == v18;
    }
    else {
      BOOL v21 = 0;
    }
    if (!v21) {
      goto LABEL_25;
    }
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a3, (unsigned __int8 **)__src, (uint64_t)&_ETLResponseRingBuffer, &__ns, a4)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_25;
    }
    if (LODWORD(__src[1]) < 5)
    {
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v10, v11, v12, v13, v14, v15, LODWORD(__src[1]));
    }
    else
    {
      if (LODWORD(__src[1]) >= 7) {
        size_t v22 = 7;
      }
      else {
        size_t v22 = LODWORD(__src[1]);
      }
      memcpy(a2, __src[0], v22);
      if (a2[4] != 2)
      {
        uint64_t v23 = 0;
        goto LABEL_26;
      }
    }
  }
  while (std::chrono::steady_clock::now().__d_.__rep_ - v8.__d_.__rep_ <= 1000000 * a4);
  uint64_t v23 = 60;
LABEL_26:
  HDLCFrameFree();
  return v23;
}

uint64_t eUICC::ValidatePerso::Perform@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0xAAAAAAAAAAAAAAAALL;
  a2[1] = 0xAAAAAAAAAAAAAAAALL;
  BOOL v4 = operator new(0x1780uLL);
  bzero(v4, 0x1780uLL);
  *(_DWORD *)BOOL v4 = -1;
  *a2 = v4;
  BOOL v5 = operator new(0x20uLL);
  void *v5 = &unk_1F4023118;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a2[1] = v5;
  int v12 = _ETLDebugFlags & 2;
  _ETLDebugFlags &= ~2u;
  uint64_t v32 = 0;
  memset(v31, 0, sizeof(v31));
  uint64_t v13 = *(void **)a1;
  if (!*(void *)a1)
  {
    uint64_t v27 = "transport";
    int v28 = 22;
LABEL_13:
    *(_DWORD *)BOOL v4 = v28;
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v6, v7, v8, v9, v10, v11, (uint64_t)v27);
    goto LABEL_14;
  }
  if (!HDLCFrameCreateUplink())
  {
LABEL_12:
    uint64_t v27 = "success";
    int v28 = 12;
    goto LABEL_13;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v15, v16, v17, v18, v19, v20, FreeSpace);
    goto LABEL_12;
  }
  int v33 = 6356299;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v21, v22, v23, v24, v25, v26, v30);
    goto LABEL_12;
  }
  if (!HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedShort()
    || (HDLCFrameInject() & 1) == 0)
  {
    goto LABEL_12;
  }
  _ETLDebugFlags |= v12;
  *(_DWORD *)BOOL v4 = eUICC::PollResult<eUICC::ValidatePerso::Response::contents>((uint64_t)v31, v4 + 4, v13, *(unsigned int *)(a1 + 80));
LABEL_14:
  _ETLDebugFlags |= v12;
  return HDLCFrameFree();
}

void sub_1E4589EBC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1E4589ED0(_Unwind_Exception *a1)
{
  std::shared_ptr<eUICC::InitPersoSession::Response>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t eUICC::PollResult<eUICC::ValidatePerso::Response::contents>(uint64_t a1, unsigned char *a2, void *a3, uint64_t a4)
{
  v8.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  uint64_t v27 = 0;
  *(_OWORD *)int __src = 0u;
  long long v26 = 0u;
  bzero(a2, 0x1779uLL);
  do
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    uint64_t v9 = malloc((2 * *(_DWORD *)(a1 + 8) + 32));
    if (!v9) {
      goto LABEL_25;
    }
    uint64_t v16 = v9;
    uint64_t v17 = HDLCFrameEncode();
    if (!v17) {
      goto LABEL_24;
    }
    uint64_t v18 = v17;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
    }
    if (!*a3)
    {
LABEL_24:
      free(v16);
LABEL_25:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v10, v11, v12, v13, v14, v15, (uint64_t)"success");
      uint64_t v23 = 5;
      goto LABEL_26;
    }
    int v19 = ((uint64_t (*)(void *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, void))*a3)(a3, v16, v18, &__ns, 1, a4, 0);
    int rep = __ns.__rep_;
    free(v16);
    if (v19) {
      BOOL v21 = rep == v18;
    }
    else {
      BOOL v21 = 0;
    }
    if (!v21) {
      goto LABEL_25;
    }
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a3, (unsigned __int8 **)__src, (uint64_t)&_ETLResponseRingBuffer, &__ns, a4)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_25;
    }
    if (LODWORD(__src[1]) < 5)
    {
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v10, v11, v12, v13, v14, v15, LODWORD(__src[1]));
    }
    else
    {
      if (LODWORD(__src[1]) >= 0x1779) {
        size_t v22 = 6009;
      }
      else {
        size_t v22 = LODWORD(__src[1]);
      }
      memcpy(a2, __src[0], v22);
      if (a2[4] != 2)
      {
        uint64_t v23 = 0;
        goto LABEL_26;
      }
    }
  }
  while (std::chrono::steady_clock::now().__d_.__rep_ - v8.__d_.__rep_ <= 1000000 * a4);
  uint64_t v23 = 60;
LABEL_26:
  HDLCFrameFree();
  return v23;
}

uint64_t eUICC::DeleteProfile::Perform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_DWORD *)&v44[4] = -1431655766;
  *(_DWORD *)&v44[8] = -1431655766;
  int v8 = _ETLDebugFlags & 2;
  _ETLDebugFlags &= ~2u;
  uint64_t v9 = *(void **)a1;
  if (!*(void *)a1)
  {
    *(_DWORD *)uint64_t v44 = 22;
    long long v26 = "transport";
LABEL_12:
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", a3, a4, a5, a6, a7, a8, (uint64_t)v26);
    goto LABEL_13;
  }
  if (!HDLCFrameCreateUplink())
  {
LABEL_11:
    *(_DWORD *)uint64_t v44 = 12;
    long long v26 = "success";
    goto LABEL_12;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v12, v13, v14, v15, v16, v17, FreeSpace);
    goto LABEL_11;
  }
  LODWORD(__src[0]) = 7011659;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v18, v19, v20, v21, v22, v23, v43);
    goto LABEL_11;
  }
  if (!HDLCFrameInjectUnsignedChar() || (HDLCFrameInjectUnsignedChar() & 1) == 0) {
    goto LABEL_11;
  }
  _ETLDebugFlags |= v8;
  uint64_t v24 = *(unsigned int *)(a1 + 12);
  v25.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  uint64_t v47 = 0;
  *(_OWORD *)int __src = 0u;
  long long v46 = 0u;
  *(_DWORD *)&v44[4] = 0;
  *(_DWORD *)&v44[7] = 0;
  do
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    int v28 = malloc(0x20uLL);
    if (!v28) {
      goto LABEL_37;
    }
    int v35 = v28;
    uint64_t v36 = HDLCFrameEncode();
    if (!v36) {
      goto LABEL_36;
    }
    uint64_t v37 = v36;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v35, v36);
    }
    if (!*v9)
    {
LABEL_36:
      free(v35);
LABEL_37:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v29, v30, v31, v32, v33, v34, (uint64_t)"success");
      int v42 = 5;
      goto LABEL_38;
    }
    int v38 = ((uint64_t (*)(void *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, void))*v9)(v9, v35, v37, &__ns, 1, v24, 0);
    int rep = __ns.__rep_;
    free(v35);
    if (v38) {
      BOOL v40 = rep == v37;
    }
    else {
      BOOL v40 = 0;
    }
    if (!v40) {
      goto LABEL_37;
    }
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)v9, (unsigned __int8 **)__src, (uint64_t)&_ETLResponseRingBuffer, &__ns, v24)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_37;
    }
    if (LODWORD(__src[1]) < 5)
    {
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v29, v30, v31, v32, v33, v34, LODWORD(__src[1]));
    }
    else
    {
      if (LODWORD(__src[1]) >= 7) {
        size_t v41 = 7;
      }
      else {
        size_t v41 = LODWORD(__src[1]);
      }
      memcpy(&v44[4], __src[0], v41);
      if (v44[8] != 2)
      {
        int v42 = 0;
        goto LABEL_38;
      }
    }
  }
  while (std::chrono::steady_clock::now().__d_.__rep_ - v25.__d_.__rep_ <= 1000000 * v24);
  int v42 = 60;
LABEL_38:
  HDLCFrameFree();
  *(_DWORD *)uint64_t v44 = v42;
LABEL_13:
  _ETLDebugFlags |= v8;
  HDLCFrameFree();
  return *(void *)v44;
}

uint64_t eUICC::GetCSN::Perform@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0xAAAAAAAAAAAAAAAALL;
  a2[1] = 0xAAAAAAAAAAAAAAAALL;
  BOOL v4 = operator new(0x1CuLL);
  v4[1] = 0;
  v4[2] = 0;
  void *v4 = 0;
  *((_DWORD *)v4 + 6) = 0;
  *(_DWORD *)BOOL v4 = -1;
  *a2 = v4;
  BOOL v5 = operator new(0x20uLL);
  void *v5 = &unk_1F4023168;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a2[1] = v5;
  uint64_t v12 = *(void **)a1;
  if (!*(void *)a1)
  {
    long long v26 = "transport";
    int v29 = 22;
LABEL_34:
    *(_DWORD *)BOOL v4 = v29;
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v6, v7, v8, v9, v10, v11, (uint64_t)v26);
    return HDLCFrameFree();
  }
  if (!HDLCFrameCreateUplink()) {
    goto LABEL_32;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v14, v15, v16, v17, v18, v19, FreeSpace);
LABEL_32:
    long long v26 = "success";
LABEL_33:
    int v29 = 12;
    goto LABEL_34;
  }
  LODWORD(__src[0]) = 5504331;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v20, v21, v22, v23, v24, v25, v46);
    goto LABEL_32;
  }
  long long v26 = "success";
  if ((HDLCFrameInjectUnsignedChar() & 1) == 0) {
    goto LABEL_33;
  }
  uint64_t v27 = *(unsigned int *)(a1 + 12);
  v28.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  *(void *)((char *)v4 + 4) = 0;
  uint64_t v50 = 0;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep = v28.__d_.__rep_;
  *(_OWORD *)int __src = 0u;
  long long v49 = 0u;
  *(void *)((char *)v4 + 12) = 0;
  *(void *)((char *)v4 + 18) = 0;
  do
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    uint64_t v30 = malloc(0x20uLL);
    if (!v30) {
      goto LABEL_38;
    }
    uint64_t v37 = v30;
    uint64_t v38 = HDLCFrameEncode();
    if (!v38) {
      goto LABEL_37;
    }
    uint64_t v39 = v38;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v37, v38);
    }
    if (!*v12)
    {
LABEL_37:
      free(v37);
LABEL_38:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v31, v32, v33, v34, v35, v36, (uint64_t)"success");
      int v44 = 5;
      goto LABEL_39;
    }
    int v40 = ((uint64_t (*)(void *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, void))*v12)(v12, v37, v39, &__ns, 1, v27, 0);
    int v41 = __ns.__rep_;
    free(v37);
    if (v40) {
      BOOL v42 = v41 == v39;
    }
    else {
      BOOL v42 = 0;
    }
    if (!v42) {
      goto LABEL_38;
    }
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)v12, (unsigned __int8 **)__src, (uint64_t)&_ETLResponseRingBuffer, &__ns, v27)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_38;
    }
    if (LODWORD(__src[1]) < 5)
    {
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v31, v32, v33, v34, v35, v36, LODWORD(__src[1]));
    }
    else
    {
      if (LODWORD(__src[1]) >= 0x16) {
        size_t v43 = 22;
      }
      else {
        size_t v43 = LODWORD(__src[1]);
      }
      memcpy((char *)v4 + 4, __src[0], v43);
      if (*((unsigned char *)v4 + 8) != 2)
      {
        int v44 = 0;
        goto LABEL_39;
      }
    }
  }
  while (std::chrono::steady_clock::now().__d_.__rep_ - rep <= 1000000 * v27);
  int v44 = 60;
LABEL_39:
  HDLCFrameFree();
  *(_DWORD *)BOOL v4 = v44;
  return HDLCFrameFree();
}

void sub_1E458A88C(_Unwind_Exception *a1)
{
  std::shared_ptr<eUICC::InitPersoSession::Response>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1E458A8A0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1E458A8B4(_Unwind_Exception *a1)
{
  std::shared_ptr<eUICC::InitPersoSession::Response>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t eUICC::StoreData::Perform@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  BOOL v4 = a2 + 1;
  memset(a2 + 1, 170, 0x1780uLL);
  *a2 = -1;
  uint64_t v31 = 0;
  memset(v30, 0, sizeof(v30));
  uint64_t v29 = 0;
  memset(v28, 0, sizeof(v28));
  uint64_t v11 = *(void **)a1;
  if (!*(void *)a1)
  {
    *a2 = 22;
    uint64_t v25 = "transport";
    goto LABEL_24;
  }
  if (!*(void *)(a1 + 16) || (unint64_t)(*(void *)(a1 + 24) - 1) >= 0x7FFF)
  {
    *a2 = 22;
    uint64_t v25 = "request.data && request.data_len && (request.data_len < kRequestMaxSize)";
LABEL_24:
    _ETLDebugPrint((uint64_t)"Perform", (uint64_t)"Condition %s failed %s/%d\n", v5, v6, v7, v8, v9, v10, (uint64_t)v25);
    return HDLCFrameFree();
  }
  if (!HDLCFrameCreateUplink())
  {
LABEL_22:
    *a2 = 12;
LABEL_23:
    uint64_t v25 = "success";
    goto LABEL_24;
  }
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v13, v14, v15, v16, v17, v18, FreeSpace);
    goto LABEL_22;
  }
  int v32 = 10943819;
  if ((HDLCFrameInject() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Failed to inject\n", v19, v20, v21, v22, v23, v24, v27);
    goto LABEL_22;
  }
  if (!HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInjectUnsignedShort()
    || (HDLCFrameInject() & 1) == 0)
  {
    goto LABEL_22;
  }
  if ((ETLSendCommand((uint64_t (**)(void, void *, uint64_t, int *, uint64_t, uint64_t, void))v11, (uint64_t)v30, *(unsigned int *)(a1 + 32)) & 1) == 0)
  {
    *a2 = 5;
    goto LABEL_23;
  }
  if ((ETLSubsysFindMatchingResponse((uint64_t)v11, (unsigned __int8 **)v28, *(_DWORD *)(a1 + 32)) & 1) == 0)
  {
    *a2 = 5;
    goto LABEL_23;
  }
  if (DWORD2(v28[0]) != 6)
  {
    *a2 = 40;
    uint64_t v25 = "sizeof( result) == HDLCFrameGetPayloadLength( &rsp)";
    goto LABEL_24;
  }
  if (*(unsigned char *)(*(void *)&v28[0] + 4) != 1)
  {
    *a2 = -10;
    uint64_t v25 = "VinylError::kStatusSuccess == result.cmd_ack_status";
    goto LABEL_24;
  }
  HDLCFrameFree();
  if (!HDLCFrameCreateUplink()
    || !ETLMaverickAddBSPCommandHeader()
    || (HDLCFrameInjectUnsignedShort() & 1) == 0)
  {
    *a2 = 12;
    goto LABEL_23;
  }
  *a2 = eUICC::PollResult<eUICC::StoreData::Response::{unnamed type#1}>((uint64_t)v30, v4, v11, *(unsigned int *)(a1 + 32));
  return HDLCFrameFree();
}

uint64_t eUICC::PollResult<eUICC::StoreData::Response::{unnamed type#1}>(uint64_t a1, unsigned char *a2, void *a3, uint64_t a4)
{
  v8.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  uint64_t v27 = 0;
  *(_OWORD *)int __src = 0u;
  long long v26 = 0u;
  bzero(a2, 0x177DuLL);
  do
  {
    __ns.__rep_ = 100000000;
    std::this_thread::sleep_for (&__ns);
    uint64_t v9 = malloc((2 * *(_DWORD *)(a1 + 8) + 32));
    if (!v9) {
      goto LABEL_25;
    }
    uint64_t v16 = v9;
    uint64_t v17 = HDLCFrameEncode();
    if (!v17) {
      goto LABEL_24;
    }
    uint64_t v18 = v17;
    LODWORD(__ns.__rep_) = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v16, v17);
    }
    if (!*a3)
    {
LABEL_24:
      free(v16);
LABEL_25:
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Condition %s failed %s/%d\n", v10, v11, v12, v13, v14, v15, (uint64_t)"success");
      uint64_t v23 = 5;
      goto LABEL_26;
    }
    int v19 = ((uint64_t (*)(void *, void *, uint64_t, std::chrono::nanoseconds *, uint64_t, uint64_t, void))*a3)(a3, v16, v18, &__ns, 1, a4, 0);
    int rep = __ns.__rep_;
    free(v16);
    if (v19) {
      BOOL v21 = rep == v18;
    }
    else {
      BOOL v21 = 0;
    }
    if (!v21) {
      goto LABEL_25;
    }
    LOBYTE(__ns.__rep_) = 75;
    if (!_ETLResponseRingBuffer) {
      TelephonyUtilRingBufferInitialize();
    }
    if (!ETLFindMatchingResponseUsingBuffer((uint64_t)a3, (unsigned __int8 **)__src, (uint64_t)&_ETLResponseRingBuffer, &__ns, a4)|| LOBYTE(__ns.__rep_) != 75)
    {
      goto LABEL_25;
    }
    if (LODWORD(__src[1]) < 9)
    {
      _ETLDebugPrint((uint64_t)"PollResult", (uint64_t)"Received payload length (%d) is smaller than required size (%d)\n", v10, v11, v12, v13, v14, v15, LODWORD(__src[1]));
    }
    else
    {
      if (LODWORD(__src[1]) >= 0x177D) {
        size_t v22 = 6013;
      }
      else {
        size_t v22 = LODWORD(__src[1]);
      }
      memcpy(a2, __src[0], v22);
      if (a2[8] != 2)
      {
        uint64_t v23 = 0;
        goto LABEL_26;
      }
    }
  }
  while (std::chrono::steady_clock::now().__d_.__rep_ - v8.__d_.__rep_ <= 1000000 * a4);
  uint64_t v23 = 60;
LABEL_26:
  HDLCFrameFree();
  return v23;
}

BOOL ETLeUICCGetCSN(uint64_t a1, _OWORD *a2, char a3, int a4)
{
  char v12 = 0;
  __int16 v11 = 0;
  char v10 = a3;
  int v13 = a4;
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v9 = a1;
  unint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
  eUICC::GetCSN::Perform((uint64_t)&v9, &v7);
  if (a2 && !*(_DWORD *)v7 && *(unsigned char *)(v7 + 8) == 1) {
    *a2 = *(_OWORD *)(v7 + 10);
  }
  uint64_t v5 = (std::__shared_weak_count *)v8;
  if (!v8 || atomic_fetch_add((atomic_ullong *volatile)(v8 + 8), 0xFFFFFFFFFFFFFFFFLL)) {
    return a2 != 0;
  }
  ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
  std::__shared_weak_count::__release_weak(v5);
  return a2 != 0;
}

uint64_t ETLeUICCGetSimType(uint64_t a1, int *a2, char a3, int a4)
{
  *a2 = 0;
  char v15 = 0;
  __int16 v14 = 0;
  char v13 = a3;
  int v16 = a4;
  unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v12 = a1;
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  eUICC::GetCSN::Perform((uint64_t)&v12, &v10);
  int v5 = *(unsigned __int8 *)(v10 + 8);
  if (v5 == 1)
  {
    int v7 = 2;
    goto LABEL_5;
  }
  uint64_t v6 = 0;
  if (v5 == 3)
  {
    int v7 = 1;
LABEL_5:
    *a2 = v7;
    uint64_t v6 = 1;
  }
  unint64_t v8 = (std::__shared_weak_count *)v11;
  if (!v11 || atomic_fetch_add((atomic_ullong *volatile)(v11 + 8), 0xFFFFFFFFFFFFFFFFLL)) {
    return v6;
  }
  ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
  std::__shared_weak_count::__release_weak(v8);
  return v6;
}

void std::__shared_ptr_pointer<eUICC::InitPersoSession::Response *,std::shared_ptr<eUICC::InitPersoSession::Response>::__shared_ptr_default_delete<eUICC::InitPersoSession::Response,eUICC::InitPersoSession::Response>,std::allocator<eUICC::InitPersoSession::Response>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<eUICC::InitPersoSession::Response *,std::shared_ptr<eUICC::InitPersoSession::Response>::__shared_ptr_default_delete<eUICC::InitPersoSession::Response,eUICC::InitPersoSession::Response>,std::allocator<eUICC::InitPersoSession::Response>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1) {
    operator delete(v1);
  }
}

uint64_t std::__shared_ptr_pointer<eUICC::InitPersoSession::Response *,std::shared_ptr<eUICC::InitPersoSession::Response>::__shared_ptr_default_delete<eUICC::InitPersoSession::Response,eUICC::InitPersoSession::Response>,std::allocator<eUICC::InitPersoSession::Response>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x80000001E4590052) {
    return a1 + 24;
  }
  if (((v3 & 0x80000001E4590052 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001E4590052)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001E4590052 & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

void std::__shared_ptr_pointer<eUICC::AuthPersoSession::Response *,std::shared_ptr<eUICC::AuthPersoSession::Response>::__shared_ptr_default_delete<eUICC::AuthPersoSession::Response,eUICC::AuthPersoSession::Response>,std::allocator<eUICC::AuthPersoSession::Response>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<eUICC::AuthPersoSession::Response *,std::shared_ptr<eUICC::AuthPersoSession::Response>::__shared_ptr_default_delete<eUICC::AuthPersoSession::Response,eUICC::AuthPersoSession::Response>,std::allocator<eUICC::AuthPersoSession::Response>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1) {
    operator delete(v1);
  }
}

uint64_t std::__shared_ptr_pointer<eUICC::AuthPersoSession::Response *,std::shared_ptr<eUICC::AuthPersoSession::Response>::__shared_ptr_default_delete<eUICC::AuthPersoSession::Response,eUICC::AuthPersoSession::Response>,std::allocator<eUICC::AuthPersoSession::Response>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x80000001E4590143) {
    return a1 + 24;
  }
  if (((v3 & 0x80000001E4590143 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001E4590143)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001E4590143 & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

void std::__shared_ptr_pointer<eUICC::FinalizePersoSession::Response *,std::shared_ptr<eUICC::FinalizePersoSession::Response>::__shared_ptr_default_delete<eUICC::FinalizePersoSession::Response,eUICC::FinalizePersoSession::Response>,std::allocator<eUICC::FinalizePersoSession::Response>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<eUICC::FinalizePersoSession::Response *,std::shared_ptr<eUICC::FinalizePersoSession::Response>::__shared_ptr_default_delete<eUICC::FinalizePersoSession::Response,eUICC::FinalizePersoSession::Response>,std::allocator<eUICC::FinalizePersoSession::Response>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1) {
    operator delete(v1);
  }
}

uint64_t std::__shared_ptr_pointer<eUICC::FinalizePersoSession::Response *,std::shared_ptr<eUICC::FinalizePersoSession::Response>::__shared_ptr_default_delete<eUICC::FinalizePersoSession::Response,eUICC::FinalizePersoSession::Response>,std::allocator<eUICC::FinalizePersoSession::Response>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x80000001E4590238) {
    return a1 + 24;
  }
  if (((v3 & 0x80000001E4590238 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001E4590238)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001E4590238 & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

void std::__shared_ptr_pointer<eUICC::ValidatePerso::Response *,std::shared_ptr<eUICC::ValidatePerso::Response>::__shared_ptr_default_delete<eUICC::ValidatePerso::Response,eUICC::ValidatePerso::Response>,std::allocator<eUICC::ValidatePerso::Response>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<eUICC::ValidatePerso::Response *,std::shared_ptr<eUICC::ValidatePerso::Response>::__shared_ptr_default_delete<eUICC::ValidatePerso::Response,eUICC::ValidatePerso::Response>,std::allocator<eUICC::ValidatePerso::Response>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1) {
    operator delete(v1);
  }
}

uint64_t std::__shared_ptr_pointer<eUICC::ValidatePerso::Response *,std::shared_ptr<eUICC::ValidatePerso::Response>::__shared_ptr_default_delete<eUICC::ValidatePerso::Response,eUICC::ValidatePerso::Response>,std::allocator<eUICC::ValidatePerso::Response>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x80000001E459032ALL) {
    return a1 + 24;
  }
  if (((v3 & 0x80000001E459032ALL & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001E459032ALL)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001E459032ALL & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

void std::__shared_ptr_pointer<eUICC::GetCSN::Response *,std::shared_ptr<eUICC::GetCSN::Response>::__shared_ptr_default_delete<eUICC::GetCSN::Response,eUICC::GetCSN::Response>,std::allocator<eUICC::GetCSN::Response>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<eUICC::GetCSN::Response *,std::shared_ptr<eUICC::GetCSN::Response>::__shared_ptr_default_delete<eUICC::GetCSN::Response,eUICC::GetCSN::Response>,std::allocator<eUICC::GetCSN::Response>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1) {
    operator delete(v1);
  }
}

uint64_t std::__shared_ptr_pointer<eUICC::GetCSN::Response *,std::shared_ptr<eUICC::GetCSN::Response>::__shared_ptr_default_delete<eUICC::GetCSN::Response,eUICC::GetCSN::Response>,std::allocator<eUICC::GetCSN::Response>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x80000001E459040DLL) {
    return a1 + 24;
  }
  if (((v3 & 0x80000001E459040DLL & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001E459040DLL)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001E459040DLL & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

uint64_t APPLIB_DIAG_Unlock(unsigned char *a1, int a2, unsigned __int8 *a3, int a4)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 13 && a4 == 6)
  {
    bzero(a1, a2);
    *a1 = 65;
    uint64_t v8 = *a3;
    a1[1] = v8;
    int v9 = a3[1];
    a1[2] = v9;
    int v10 = a3[2];
    a1[3] = v10;
    int v11 = a3[3];
    a1[4] = v11;
    int v12 = a3[4];
    a1[5] = v12;
    int v13 = a3[5];
    a1[6] = v13;
    unsigned __int16 v14 = crc_16_l_table[v8 ^ 0xA];
    unsigned __int16 v15 = crc_16_l_table[(v9 ^ v14) ^ 0x5C];
    unsigned __int16 v16 = crc_16_l_table[(v10 ^ v15 ^ HIBYTE(v14))];
    unsigned __int16 v17 = crc_16_l_table[(v11 ^ v16 ^ HIBYTE(v15))];
    unsigned int v18 = crc_16_l_table[(v12 ^ v17 ^ HIBYTE(v16))];
    int v19 = crc_16_l_table[(v13 ^ v18 ^ HIBYTE(v17))];
    int v20 = v19 ^ ~(v18 >> 8);
    a1[7] = v20;
    int v21 = BYTE1(v20);
    a1[8] = v21;
    if (a2 >= 0x12)
    {
      int v32 = v21;
      bzero(v34, 0x7FFuLL);
      char __src = 65;
      if ((v8 - 125) > 1)
      {
        unsigned int v22 = 1;
      }
      else
      {
        v34[0] = 125;
        LOBYTE(v8) = v8 ^ 0x20;
        unsigned int v22 = 2;
      }
      v34[v22 - 1] = v8;
      uint64_t v23 = v22 + 1;
      if ((v9 - 125) <= 1)
      {
        v34[v23 - 1] = 125;
        LODWORD(v23) = v22 + 2;
        LOBYTE(v9) = v9 ^ 0x20;
      }
      v34[v23 - 1] = v9;
      uint64_t v24 = v23 + 1;
      if ((v10 - 125) <= 1)
      {
        v34[v24 - 1] = 125;
        LOBYTE(v10) = v10 ^ 0x20;
        LODWORD(v24) = v23 + 2;
      }
      v34[v24 - 1] = v10;
      uint64_t v25 = v24 + 1;
      if ((v11 - 125) <= 1)
      {
        v34[v25 - 1] = 125;
        LODWORD(v25) = v24 + 2;
        LOBYTE(v11) = v11 ^ 0x20;
      }
      v34[v25 - 1] = v11;
      uint64_t v26 = v25 + 1;
      if ((v12 - 125) <= 1)
      {
        v34[v26 - 1] = 125;
        LOBYTE(v12) = v12 ^ 0x20;
        LODWORD(v26) = v25 + 2;
      }
      int v27 = ~(v19 ^ BYTE1(v18));
      v34[v26 - 1] = v12;
      uint64_t v28 = v26 + 1;
      if ((v13 - 125) <= 1)
      {
        v34[v28 - 1] = 125;
        LOBYTE(v13) = v13 ^ 0x20;
        LODWORD(v28) = v26 + 2;
      }
      v34[v28 - 1] = v13;
      uint64_t v29 = v28 + 1;
      if ((v27 - 125) <= 1)
      {
        v34[v29 - 1] = 125;
        LODWORD(v29) = v28 + 2;
        LOBYTE(v27) = v27 ^ 0x20;
      }
      char v30 = v32;
      v34[v29 - 1] = v27;
      uint64_t v31 = v29 + 1;
      if ((v32 - 125) <= 1)
      {
        v34[v31 - 1] = 125;
        char v30 = v32 ^ 0x20;
        LODWORD(v31) = v29 + 2;
      }
      v34[v31 - 1] = v30;
      memcpy(a1, &__src, v31 + 1);
      uint64_t result = (v31 + 2);
      a1[v31 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_Lock(_WORD *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 4)
  {
    bzero(a1, a2);
    *a1 = 11387;
    *((unsigned char *)a1 + 2) = 61;
    if (a2 >= 6)
    {
      *(_DWORD *)a1 = 2117938299;
      return 4;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_CreateICCID_EFS_File(char *a1, int a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (a2 < 64) {
    return 0xFFFFFFFFLL;
  }
  long long v4 = 0u;
  long long v5 = 0u;
  memset(v6, 0, sizeof(v6));
  __int16 v3 = 8523;
  BYTE2(v4) = 1;
  BYTE4(v5) = 1;
  BYTE8(v5) = 1;
  BYTE14(v5) = 10;
  qmemcpy(v6, "sim.txt", 7);
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 42);
}

uint64_t APPLIB_DIAG_GetICCID(char *a1, int a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (a2 < 64) {
    return 0xFFFFFFFFLL;
  }
  long long v5 = 0u;
  long long v6 = 0u;
  memset(v7, 0, sizeof(v7));
  __int16 v3 = 8576;
  char v4 = 72;
  BYTE1(v5) = 1;
  BYTE5(v5) = 119;
  *(_WORD *)((char *)&v5 + 9) = 4097;
  BYTE11(v6) = 107;
  HIBYTE(v6) = 107;
  v7[7] = 1;
  v7[15] = 10;
  return APPLIB_DIAG_SendRawRequest(a1, a2, &v3, 55);
}

uint64_t APPLIB_DIAG_Read_Meid(char *a1, int a2)
{
  return APPLIB_DIAG_NvItemRead(a1, a2, 1943);
}

uint64_t APPLIB_DIAG_Write_Meid(char *a1, int a2, void *__src, int a4)
{
  if (a4 > 8) {
    return 0xFFFFFFFFLL;
  }
  else {
    return APPLIB_DIAG_NvItemWrite(a1, a2, 1943, __src, a4);
  }
}

uint64_t APPLIB_DIAG_Read_Msl(char *a1, int a2)
{
  return APPLIB_DIAG_NvItemRead(a1, a2, 85);
}

uint64_t APPLIB_DIAG_Write_Msl(char *a1, int a2, void *__src, int a4)
{
  if (a4 > 6) {
    return 0xFFFFFFFFLL;
  }
  else {
    return APPLIB_DIAG_NvItemWrite(a1, a2, 85, __src, a4);
  }
}

uint64_t APPLIB_DIAG_Read_Otksl(char *a1, int a2)
{
  return APPLIB_DIAG_NvItemRead(a1, a2, 85);
}

uint64_t APPLIB_DIAG_Write_Otksl(char *a1, int a2, void *__src, int a4)
{
  if (a4 > 6) {
    return 0xFFFFFFFFLL;
  }
  else {
    return APPLIB_DIAG_NvItemWrite(a1, a2, 219, __src, a4);
  }
}

uint64_t APPLIB_DIAG_Write_AKey(char *a1, int a2, void *__src, int a4)
{
  if (a4 > 9) {
    return 0xFFFFFFFFLL;
  }
  else {
    return APPLIB_DIAG_NvItemWrite(a1, a2, 25, __src, a4);
  }
}

uint64_t APPLIB_DIAG_Write_AKeyCSum(char *a1, int a2, void *__src, int a4)
{
  if (a4 > 8) {
    return 0xFFFFFFFFLL;
  }
  else {
    return APPLIB_DIAG_NvItemWrite(a1, a2, 26, __src, a4);
  }
}

uint64_t APPLIB_DIAG_Write_BlueToothAddr(char *a1, int a2, void *__src, int a4)
{
  if (a4 > 6) {
    return 0xFFFFFFFFLL;
  }
  else {
    return APPLIB_DIAG_NvItemWrite(a1, a2, 50001, __src, a4);
  }
}

uint64_t APPLIB_DIAG_Read_BlueToothAddr(char *a1, int a2)
{
  return APPLIB_DIAG_NvItemRead(a1, a2, 50001);
}

uint64_t APPLIB_DIAG_Write_WiFi_MAC_Addr(char *a1, int a2, void *__src, int a4)
{
  if (a4 > 6) {
    return 0xFFFFFFFFLL;
  }
  else {
    return APPLIB_DIAG_NvItemWrite(a1, a2, 50002, __src, a4);
  }
}

uint64_t APPLIB_DIAG_Read_WiFi_MAC_Addr(char *a1, int a2)
{
  return APPLIB_DIAG_NvItemRead(a1, a2, 50002);
}

uint64_t APPLIB_DIAG_Write_WiFi_Cal_Data(char *a1, int a2, void *__src, int a4)
{
  if (a4 > 64) {
    return 0xFFFFFFFFLL;
  }
  else {
    return APPLIB_DIAG_NvItemWrite(a1, a2, 50003, __src, a4);
  }
}

uint64_t APPLIB_DIAG_Read_WiFi_Cal_Data(char *a1, int a2)
{
  return APPLIB_DIAG_NvItemRead(a1, a2, 50003);
}

uint64_t APPLIB_DIAG_Write_USB2ETHERNET_MAC_Addr(char *a1, int a2, void *__src, int a4)
{
  if (a4 > 6) {
    return 0xFFFFFFFFLL;
  }
  else {
    return APPLIB_DIAG_NvItemWrite(a1, a2, 50004, __src, a4);
  }
}

uint64_t APPLIB_DIAG_Read_USB2ETHERNET_MAC_Addr(char *a1, int a2)
{
  return APPLIB_DIAG_NvItemRead(a1, a2, 50004);
}

uint64_t APPLIB_DIAG_GetSerialNumAndChipID(void *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 8)
  {
    bzero(a1, a2);
    *a1 = 0x9B390003000CFE4BLL;
    if (a2 >= 16)
    {
      *a1 = 0x9B390003000CFE4BLL;
      *((unsigned char *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_GetNonce(void *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 8)
  {
    bzero(a1, a2);
    *a1 = 0x82E10002000CFE4BLL;
    if (a2 >= 16)
    {
      *a1 = 0x82E10002000CFE4BLL;
      *((unsigned char *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_SfpNvBackup(void *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 8)
  {
    bzero(a1, a2);
    *a1 = 0xFC590007000CFE4BLL;
    if (a2 >= 16)
    {
      *a1 = 0xFC590007000CFE4BLL;
      *((unsigned char *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_SfpNvRestore(void *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 8)
  {
    bzero(a1, a2);
    *a1 = 0x7F910008000CFE4BLL;
    if (a2 >= 16)
    {
      *a1 = 0x7F910008000CFE4BLL;
      *((unsigned char *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_ReadRootManifest(_DWORD *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x17)
  {
    bzero(a1, a2);
    *a1 = 851275;
    a1[1] = 10;
    *((_WORD *)a1 + 4) = 5546;
    if (a2 >= 20)
    {
      *(void *)a1 = 0xA000CFD4BLL;
      *((_WORD *)a1 + 4) = 5546;
      *((unsigned char *)a1 + 10) = 126;
      return 11;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_StartProvision(_WORD *a1, unsigned int a2, const void *a3, unsigned int a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!a1 || 2 * (unint64_t)a4 + 22 >= a2) {
    return 0xFFFFFFFFLL;
  }
  bzero(a1, a2);
  *(_DWORD *)a1 = 851531;
  a1[2] = 0;
  a1[3] = a4;
  memcpy(a1 + 4, a3, a4);
  int v8 = 8 * (a4 + 8);
  if (8 * ((_WORD)a4 + 8))
  {
    LOWORD(v9) = -1;
    int v10 = (char *)a1;
    do
    {
      char v11 = *v10++;
      int v9 = crc_16_l_table[(v11 ^ v9)] ^ ((unsigned __int16)(v9 & 0xFF00) >> 8);
      v8 -= 8;
    }
    while ((_WORD)v8);
    char v12 = ~(_BYTE)v9;
    char v13 = (unsigned __int16)~(_WORD)v9 >> 8;
  }
  else
  {
    char v12 = 0;
    char v13 = 0;
  }
  *((unsigned char *)a1 + a4 + 8) = v12;
  *((unsigned char *)a1 + a4 + 9) = v13;
  uint64_t v15 = a4 + 10;
  uint64_t result = 0xFFFFFFFFLL;
  if ((int)v15 <= 1024 && 2 * (int)v15 <= (int)a2)
  {
    bzero(__src, 0x800uLL);
    if ((int)v15 < 1)
    {
      int v16 = 0;
    }
    else
    {
      int v16 = 0;
      unsigned __int16 v17 = (unsigned __int8 *)a1;
      do
      {
        int v19 = *v17++;
        char v18 = v19;
        if ((v19 - 125) <= 1)
        {
          __src[v16] = 125;
          v18 ^= 0x20u;
          ++v16;
        }
        __src[v16++] = v18;
        --v15;
      }
      while (v15);
    }
    memcpy(a1, __src, v16);
    uint64_t result = (v16 + 1);
    *((unsigned char *)a1 + v16) = 126;
  }
  return result;
}

uint64_t APPLIB_DIAG_FinishProvision(_WORD *a1, unsigned int a2, const void *a3, unsigned int a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!a1 || 2 * (unint64_t)a4 + 22 >= a2) {
    return 0xFFFFFFFFLL;
  }
  bzero(a1, a2);
  *(_DWORD *)a1 = 851531;
  a1[2] = 1;
  a1[3] = a4;
  memcpy(a1 + 4, a3, a4);
  int v8 = 8 * (a4 + 8);
  if (8 * ((_WORD)a4 + 8))
  {
    LOWORD(v9) = -1;
    int v10 = (char *)a1;
    do
    {
      char v11 = *v10++;
      int v9 = crc_16_l_table[(v11 ^ v9)] ^ ((unsigned __int16)(v9 & 0xFF00) >> 8);
      v8 -= 8;
    }
    while ((_WORD)v8);
    char v12 = ~(_BYTE)v9;
    char v13 = (unsigned __int16)~(_WORD)v9 >> 8;
  }
  else
  {
    char v12 = 0;
    char v13 = 0;
  }
  *((unsigned char *)a1 + a4 + 8) = v12;
  *((unsigned char *)a1 + a4 + 9) = v13;
  uint64_t v15 = a4 + 10;
  uint64_t result = 0xFFFFFFFFLL;
  if ((int)v15 <= 1024 && 2 * (int)v15 <= (int)a2)
  {
    bzero(__src, 0x800uLL);
    if ((int)v15 < 1)
    {
      int v16 = 0;
    }
    else
    {
      int v16 = 0;
      unsigned __int16 v17 = (unsigned __int8 *)a1;
      do
      {
        int v19 = *v17++;
        char v18 = v19;
        if ((v19 - 125) <= 1)
        {
          __src[v16] = 125;
          v18 ^= 0x20u;
          ++v16;
        }
        __src[v16++] = v18;
        --v15;
      }
      while (v15);
    }
    memcpy(a1, __src, v16);
    uint64_t result = (v16 + 1);
    *((unsigned char *)a1 + v16) = 126;
  }
  return result;
}

uint64_t APPLIB_DIAG_WriteCalibrationManifest(_WORD *a1, unsigned int a2, const void *a3, unsigned int a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (!a1 || 2 * (unint64_t)a4 + 22 >= a2) {
    return 0xFFFFFFFFLL;
  }
  bzero(a1, a2);
  *(_DWORD *)a1 = 851531;
  a1[2] = 6;
  a1[3] = a4;
  memcpy(a1 + 4, a3, a4);
  uint64_t v8 = a4 + 8;
  int v9 = 8 * (a4 + 8);
  if (8 * ((_WORD)a4 + 8))
  {
    LOWORD(v10) = -1;
    char v11 = (char *)a1;
    do
    {
      char v12 = *v11++;
      int v10 = crc_16_l_table[(v12 ^ v10)] ^ ((unsigned __int16)(v10 & 0xFF00) >> 8);
      v9 -= 8;
    }
    while ((_WORD)v9);
    *((unsigned char *)a1 + v8) = ~(_BYTE)v10;
    *((unsigned char *)a1 + a4 + 9) = (unsigned __int16)~(_WORD)v10 >> 8;
    uint64_t result = 0xFFFFFFFFLL;
    if (a4 > 0x3F6) {
      return result;
    }
  }
  else
  {
    *((unsigned char *)a1 + v8) = 0;
    *((unsigned char *)a1 + a4 + 9) = 0;
    uint64_t result = 0xFFFFFFFFLL;
    if (a4 > 0x3F6) {
      return result;
    }
  }
  uint64_t v14 = a4 + 10;
  if (2 * (int)v14 <= (int)a2)
  {
    bzero(__src, 0x800uLL);
    uint64_t v15 = 0;
    LODWORD(v16) = 0;
    do
    {
      while (1)
      {
        int v18 = *((unsigned __int8 *)a1 + v15);
        if ((v18 - 125) > 1) {
          break;
        }
        int v17 = v16 + 1;
        __src[(int)v16] = 125;
        __src[(int)v16 + 1] = v18 ^ 0x20;
        size_t v16 = (int)v16 + 1 + 1;
        if (v14 == ++v15) {
          goto LABEL_16;
        }
      }
      int v17 = v16;
      __src[(int)v16] = v18;
      size_t v16 = (int)v16 + 1;
      ++v15;
    }
    while (v14 != v15);
LABEL_16:
    memcpy(a1, __src, v16);
    uint64_t result = (v17 + 2);
    *((unsigned char *)a1 + v16) = 126;
  }
  return result;
}

uint64_t APPLIB_DIAG_ReadCalibrationBackup(void *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x13)
  {
    bzero(a1, a2);
    *a1 = 0xCFE90005000CFE4BLL;
    if (a2 >= 16)
    {
      *a1 = 0xCFE90005000CFE4BLL;
      *((unsigned char *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_BackupCalibrationData(void *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x13)
  {
    bzero(a1, a2);
    *a1 = 0xD6310004000CFE4BLL;
    if (a2 >= 16)
    {
      *a1 = 0xD6310004000CFE4BLL;
      *((unsigned char *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_RestoreCalibrationData(void *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x13)
  {
    bzero(a1, a2);
    *a1 = 0x66490009000CFE4BLL;
    if (a2 >= 16)
    {
      *a1 = 0x66490009000CFE4BLL;
      *((unsigned char *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_ReadManifestStatus(void *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x13)
  {
    bzero(a1, a2);
    *a1 = 0x53D000C000CFD4BLL;
    if (a2 >= 16)
    {
      *a1 = 0x53D000C000CFD4BLL;
      *((unsigned char *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_CheckCalibrationData(void *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x13)
  {
    bzero(a1, a2);
    *a1 = 0x129000D000CFE4BLL;
    if (a2 >= 16)
    {
      *a1 = 0x129000D000CFE4BLL;
      *((unsigned char *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_ReadCalCounter(void *a1, int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x13)
  {
    bzero(a1, a2);
    *a1 = 0x2B41000E000CFE4BLL;
    if (a2 >= 16)
    {
      *a1 = 0x2B41000E000CFE4BLL;
      *((unsigned char *)a1 + 8) = 126;
      return 9;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t ETLSMSCreateAddress(uint64_t a1, char *__s)
{
  unsigned __int8 v4 = strlen(__s);
  if ((v4 & 0xF0) != 0) {
    unsigned __int8 v5 = 15;
  }
  else {
    unsigned __int8 v5 = v4;
  }
  *(unsigned char *)a1 = v5;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 1) = 0;
  memcpy((void *)(a1 + 1), __s, v5);
  return 1;
}

uint64_t ETLSMSCreateMessage(uint64_t a1, char *__s)
{
  unsigned __int8 v4 = strlen(__s);
  if ((v4 & 0xF8u) <= 0xC7uLL) {
    unsigned __int8 v5 = v4;
  }
  else {
    unsigned __int8 v5 = -57;
  }
  *(unsigned char *)a1 = v5;
  *(_OWORD *)(a1 + 17) = 0u;
  *(_OWORD *)(a1 + 33) = 0u;
  *(_OWORD *)(a1 + 49) = 0u;
  *(_OWORD *)(a1 + 65) = 0u;
  *(_OWORD *)(a1 + 81) = 0u;
  *(_OWORD *)(a1 + 97) = 0u;
  *(_OWORD *)(a1 + 113) = 0u;
  *(_OWORD *)(a1 + 129) = 0u;
  *(_OWORD *)(a1 + 145) = 0u;
  *(_OWORD *)(a1 + 161) = 0u;
  *(_OWORD *)(a1 + 177) = 0u;
  *(void *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 1) = 0u;
  memcpy((void *)(a1 + 1), __s, v5);
  return 1;
}

uint64_t ETLSMSCreateSendSMSCommand(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysAddHeaderInternal", (uint64_t)"Free space %u not enough for %zu\n", v6, v7, v8, v9, v10, v11, FreeSpace);
    return 0;
  }
  if ((HDLCFrameInject() & 1) == 0)
  {
    int v19 = "ETLSubsysAddHeaderInternal";
    uint64_t v20 = "Failed to inject\n";
LABEL_15:
    _ETLDebugPrint((uint64_t)v19, (uint64_t)v20, v12, v13, v14, v15, v16, v17, v21);
    return 0;
  }
  if (HDLCFrameGetFreeSpace() <= 0xD7)
  {
    uint64_t v21 = 216;
    int v19 = "ETLRequireFreeSpace";
    uint64_t v20 = "Need %u bytes free space, but only have %u\n";
    goto LABEL_15;
  }
  if (*a2 > 0xFu
    || *a3 > 0xC7u
    || !HDLCFrameInjectUnsignedChar()
    || !HDLCFrameInject()
    || !HDLCFrameInjectUnsignedChar())
  {
    return 0;
  }

  return HDLCFrameInject();
}

uint64_t ETLSMSParseSendSMSResponse(unsigned int *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a1[2];
  if (v8 < 4)
  {
    _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", a3, a4, a5, a6, a7, a8, a1[2]);
    return 0;
  }
  else
  {
    unsigned int v9 = **(_DWORD **)a1;
    if (v9 == 75)
    {
      if (BYTE1(v9) == 252)
      {
        uint64_t v10 = HIWORD(v9);
        if (v10 == 1)
        {
          if (v8 - 4 <= 1)
          {
            _ETLDebugPrint((uint64_t)"ETLSMSParseSendSMSResponse", (uint64_t)"response requires %u bytes, got %u\n", a3, a4, a5, a6, a7, a8, 2);
            return 0;
          }
          else
          {
            uint64_t v11 = *(unsigned __int16 *)(*(void *)a1 + 4);
            *a2 = v11;
            _ETLDebugPrint((uint64_t)"ETLSMSParseSendSMSResponse", (uint64_t)"Status was %u\n", a3, a4, a5, a6, a7, a8, v11);
            return 1;
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, v10);
          return 0;
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, BYTE1(v9));
        return 0;
      }
    }
    else
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", a3, a4, a5, a6, a7, a8, **(_DWORD **)a1);
      return 0;
    }
  }
}

uint64_t ETLSMSSendSMS(void *a1, unsigned __int8 *a2, unsigned __int8 *a3, _WORD *a4, uint64_t a5)
{
  memset(v38, 0, sizeof(v38));
  uint64_t v39 = 0;
  memset(v36, 0, sizeof(v36));
  uint64_t v37 = 0;
  if ((HDLCFrameCreateUplink() & 1) == 0)
  {
    _ETLDebugPrint((uint64_t)"ETLSMSSendSMS", (uint64_t)"Failed to create command frame\n", v10, v11, v12, v13, v14, v15, v35);
    goto LABEL_24;
  }
  if (!ETLSMSCreateSendSMSCommand((uint64_t)v38, a2, a3)) {
    goto LABEL_24;
  }
  uint64_t v16 = malloc((2 * DWORD2(v38[0]) + 32));
  if (!v16) {
    goto LABEL_24;
  }
  uint64_t v17 = v16;
  uint64_t v18 = HDLCFrameEncode();
  if (!v18) {
    goto LABEL_26;
  }
  uint64_t v19 = v18;
  int v40 = -1431655766;
  if ((_ETLDebugFlags & 2) != 0) {
    ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v17, v18);
  }
  if (!*a1)
  {
LABEL_26:
    free(v17);
    goto LABEL_24;
  }
  int v20 = ((uint64_t (*)(void *, void *, uint64_t, int *, uint64_t, uint64_t, void))*a1)(a1, v17, v19, &v40, 1, a5, 0);
  int v21 = v40;
  free(v17);
  if (v20) {
    BOOL v22 = v21 == v19;
  }
  else {
    BOOL v22 = 0;
  }
  if (!v22) {
    goto LABEL_24;
  }
  LOBYTE(v40) = 75;
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  int v23 = ETLFindMatchingResponseUsingBuffer((uint64_t)a1, (unsigned __int8 **)v36, (uint64_t)&_ETLResponseRingBuffer, &v40, a5);
  uint64_t v30 = 0;
  if (v23 && v40 == 75)
  {
    if (DWORD2(v36[0]) < 4)
    {
      _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Response length %u less than %zu\n", v24, v25, v26, v27, v28, v29, DWORD2(v36[0]));
    }
    else
    {
      unsigned int v31 = **(_DWORD **)&v36[0];
      if (**(_DWORD **)&v36[0] == 75)
      {
        if (BYTE1(v31) == 252)
        {
          uint64_t v32 = HIWORD(v31);
          if (v32 == 1)
          {
            if ((DWORD2(v36[0]) - 4) > 1)
            {
              uint64_t v33 = *(unsigned __int16 *)(*(void *)&v36[0] + 4);
              *a4 = v33;
              _ETLDebugPrint((uint64_t)"ETLSMSParseSendSMSResponse", (uint64_t)"Status was %u\n", v24, v25, v26, v27, v28, v29, v33);
              uint64_t v30 = 1;
              goto LABEL_25;
            }
            _ETLDebugPrint((uint64_t)"ETLSMSParseSendSMSResponse", (uint64_t)"response requires %u bytes, got %u\n", v24, v25, v26, v27, v28, v29, 2);
          }
          else
          {
            _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received command code 0x%x doesn't match expected 0x%x\n", v24, v25, v26, v27, v28, v29, v32);
          }
        }
        else
        {
          _ETLDebugPrint((uint64_t)"ETLMaverickParseSubsysResponseHeader", (uint64_t)"Received subsys 0x%x doesn't match expected 0x%x\n", v24, v25, v26, v27, v28, v29, BYTE1(v31));
        }
      }
      else
      {
        _ETLDebugPrint((uint64_t)"ETLSubsysParseHeaderInternal", (uint64_t)"Header command code 0x%x doesn't match expected 0x%x\n", v24, v25, v26, v27, v28, v29, **(_DWORD **)&v36[0]);
      }
    }
LABEL_24:
    uint64_t v30 = 0;
  }
LABEL_25:
  HDLCFrameFree();
  HDLCFrameFree();
  return v30;
}

uint64_t ETLFlushResponseBuffer()
{
  return 1;
}

uint64_t ETLFlushResponseFull(uint64_t a1)
{
  TelephonyUtilRingBufferReset();
  unint64_t v2 = *(uint64_t (**)(uint64_t))(a1 + 24);
  if (!v2) {
    return 0;
  }

  return v2(a1);
}

uint64_t ETLGetResponse(uint64_t a1, unsigned char **a2, unsigned char *a3)
{
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }
  uint64_t v6 = ETLFrameReadFromTransport(a1, (uint64_t)a2);
  if (v6)
  {
    uint64_t v7 = *((unsigned int *)a2 + 2);
    if ((_ETLDebugFlags & 2) != 0)
    {
      ((void (*)(const char *, uint64_t, void, uint64_t))*(&gDelegate + 1))("", 1, *a2, v7);
      LODWORD(v7) = *((_DWORD *)a2 + 2);
    }
    if (v7) {
      *a3 = **a2;
    }
  }
  return v6;
}

uint64_t ETLGetResponseUsingBuffer(uint64_t a1, unsigned char **a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v6 = ETLFrameReadFromTransport(a1, (uint64_t)a2);
  if (v6)
  {
    uint64_t v7 = *((unsigned int *)a2 + 2);
    if ((_ETLDebugFlags & 2) != 0)
    {
      ((void (*)(const char *, uint64_t, void, uint64_t))*(&gDelegate + 1))("", 1, *a2, v7);
      LODWORD(v7) = *((_DWORD *)a2 + 2);
    }
    if (v7) {
      *a4 = **a2;
    }
  }
  return v6;
}

uint64_t ETLFindMatchingResponse(uint64_t a1, unsigned __int8 **a2, unsigned char *a3, unsigned int a4)
{
  if (!_ETLResponseRingBuffer) {
    TelephonyUtilRingBufferInitialize();
  }

  return ETLFindMatchingResponseUsingBuffer(a1, a2, (uint64_t)&_ETLResponseRingBuffer, a3, a4);
}

uint64_t ETLFindMatchingResponseUsingBuffer(uint64_t a1, unsigned __int8 **a2, uint64_t a3, unsigned char *a4, unsigned int a5)
{
  uint64_t v9 = mach_absolute_time();
  if (a5 == -1)
  {
    if (ETLFrameReadFromTransport(a1, (uint64_t)a2))
    {
      do
      {
        uint64_t v17 = *((unsigned int *)a2 + 2);
        if ((_ETLDebugFlags & 2) != 0)
        {
          ((void (*)(const char *, uint64_t, void, uint64_t))*(&gDelegate + 1))("", 1, *a2, v17);
          uint64_t v17 = *((unsigned int *)a2 + 2);
        }
        if (v17)
        {
          uint64_t v18 = **a2;
          if (v18 == *a4) {
            return 1;
          }
        }
        else
        {
          uint64_t v18 = 0;
          if (!*a4) {
            return 1;
          }
        }
        if ((v18 - 19) <= 0x34 && ((1 << (v18 - 19)) & 0x10800000000027) != 0)
        {
LABEL_26:
          _ETLDebugPrint((uint64_t)"ETLFindMatchingResponseUsingBuffer", (uint64_t)"Received error code %u\n", v11, v17, v13, v14, v15, v16, v18);
          *a4 = v18;
          return 1;
        }
        HDLCFrameFree();
      }
      while ((ETLFrameReadFromTransport(a1, (uint64_t)a2) & 1) != 0);
    }
  }
  else
  {
    uint64_t v10 = v9;
    while (ETLFrameReadFromTransport(a1, (uint64_t)a2))
    {
      uint64_t v17 = *((unsigned int *)a2 + 2);
      if ((_ETLDebugFlags & 2) != 0)
      {
        ((void (*)(const char *, uint64_t, void, uint64_t))*(&gDelegate + 1))("", 1, *a2, v17);
        uint64_t v17 = *((unsigned int *)a2 + 2);
      }
      if (v17)
      {
        uint64_t v18 = **a2;
        int v19 = *a4;
        BOOL v20 = v18 == v19;
        if (v18 == v19) {
          return v20;
        }
      }
      else
      {
        uint64_t v18 = 0;
        BOOL v20 = *a4 == 0;
        if (!*a4) {
          return v20;
        }
      }
      if ((v18 - 19) <= 0x34 && ((1 << (v18 - 19)) & 0x10800000000027) != 0) {
        goto LABEL_26;
      }
      HDLCFrameFree();
      uint64_t v21 = mach_absolute_time();
      double v22 = *(double *)&ETLGetTimeDifferenceMilliseconds_conversion;
      if (*(double *)&ETLGetTimeDifferenceMilliseconds_conversion == 0.0)
      {
        mach_timebase_info info = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
        mach_timebase_info(&info);
        LODWORD(v24) = info.denom;
        LODWORD(v23) = info.numer;
        double v22 = (double)v23 * 0.000001 / (double)v24;
        ETLGetTimeDifferenceMilliseconds_conversion = *(void *)&v22;
      }
      if ((v22 * (double)(v21 - v10)) >= a5) {
        return v20;
      }
    }
  }
  _ETLDebugPrint((uint64_t)"ETLFindMatchingResponseUsingBuffer", (uint64_t)"Failed to receive response from Baseband\n", v11, v12, v13, v14, v15, v16, v26);
  return 0;
}

uint64_t ETLSendCommand(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, uint64_t a3)
{
  unsigned __int8 v5 = malloc((2 * *(_DWORD *)(a2 + 8) + 32));
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  uint64_t v7 = HDLCFrameEncode();
  if (v7)
  {
    uint64_t v8 = v7;
    int v9 = -1431655766;
    int v13 = -1431655766;
    if ((_ETLDebugFlags & 2) != 0) {
      ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v6, v7);
    }
    if (*a1)
    {
      unsigned int v10 = (*a1)(a1, v6, v8, &v13, 1, a3, 0);
      int v9 = v13;
    }
    else
    {
      unsigned int v10 = 0;
    }
    if (v9 == v8) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = 0;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  free(v6);
  return v11;
}

uint64_t ETLSendRaw(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  if (HDLCFrameCreateUplink())
  {
    int v8 = HDLCFrameInjectUnsignedChar();
    if (a4 && v8)
    {
      if ((HDLCFrameInject() & 1) == 0) {
        goto LABEL_14;
      }
    }
    else if (!v8)
    {
      goto LABEL_14;
    }
    unsigned int v10 = malloc(0x55555574uLL);
    if (v10)
    {
      uint64_t v11 = v10;
      uint64_t v12 = HDLCFrameEncode();
      if (v12)
      {
        uint64_t v13 = v12;
        int v14 = -1431655766;
        int v17 = -1431655766;
        if ((_ETLDebugFlags & 2) != 0) {
          ((void (*)(const char *, void, void *, uint64_t))*(&gDelegate + 1))("", 0, v11, v12);
        }
        if (*a1)
        {
          unsigned int v15 = (*a1)(a1, v11, v13, &v17, 1, a5, 0);
          int v14 = v17;
        }
        else
        {
          unsigned int v15 = 0;
        }
        if (v14 == v13) {
          uint64_t v9 = v15;
        }
        else {
          uint64_t v9 = 0;
        }
      }
      else
      {
        uint64_t v9 = 0;
      }
      free(v11);
      goto LABEL_21;
    }
LABEL_14:
    uint64_t v9 = 0;
LABEL_21:
    HDLCFrameFree();
    return v9;
  }
  return 0;
}

BOOL ETLRequireFreeSpace(uint64_t a1, uint64_t a2)
{
  unsigned int FreeSpace = HDLCFrameGetFreeSpace();
  if (FreeSpace < a2) {
    _ETLDebugPrint((uint64_t)"ETLRequireFreeSpace", (uint64_t)"Need %u bytes free space, but only have %u\n", v3, v4, v5, v6, v7, v8, a2);
  }
  return FreeSpace >= a2;
}

BOOL ETLCheckPayloadLength(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a3;
  unsigned int v9 = *(_DWORD *)(a1 + 8) - a2;
  if (v9 < a3) {
    _ETLDebugPrint((uint64_t)"ETLCheckPayloadLength", (uint64_t)"Need %u bytes, but only have %u\n", a3, a4, a5, a6, a7, a8, a3);
  }
  return v9 >= v8;
}

BOOL ETLExpectResponseCode(unsigned int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 != a2) {
    _ETLDebugPrint((uint64_t)"ETLExpectResponseCode", (uint64_t)"Received response code is %u, expected %u\n", a3, a4, a5, a6, a7, a8, a1);
  }
  return a1 == a2;
}

uint64_t ETLNVRAMExtTranslateID(int a1, const char **a2)
{
  uint64_t result = 0;
  if (a1 <= 67287)
  {
    switch(a1)
    {
      case 65633:
        uint64_t v4 = "/nv/item_files/modem/mmode/lte_bandpref";
        break;
      case 65728:
        uint64_t v4 = "/nv/item_files/modem/utils/a2/sps_dynamic_usb_endpoint";
        break;
      case 65768:
        uint64_t v4 = "/nv/item_files/hsusb/device_composition";
        break;
      default:
        return result;
    }
LABEL_15:
    *a2 = v4;
    a2[1] = (const char *)0xAAAAAAAA00000000;
    return 1;
  }
  else
  {
    switch(a1)
    {
      case 67288:
        uint64_t v4 = "/nv/item_files/modem/hdr/srch/hdr_acq_div_thresh0";
        goto LABEL_15;
      case 67289:
        uint64_t v4 = "/nv/item_files/modem/hdr/srch/hdr_acq_div_thresh1";
        goto LABEL_15;
      case 67290:
        uint64_t v4 = "/nv/item_files/modem/hdr/srch/hdr_acq_div_enable";
        goto LABEL_15;
      case 67297:
        uint64_t v4 = "/nv/item_files/gps/cgps/me/gnss_main_wwan_tx_antenna_im_jamming_power";
        goto LABEL_15;
      case 67298:
        uint64_t v4 = "/nv/item_files/gps/cgps/me/gnss_aux_wwan_tx_antenna_im_jamming_power";
        goto LABEL_15;
      case 67299:
        uint64_t v4 = "/nv/item_files/gps/cgps/me/gnss_wlan_bt_delta_tx_antenna_im_jamming_power";
        goto LABEL_15;
      default:
        return result;
    }
  }
}

uint64_t ETLNVRAMExtWrite(void *a1, int a2, uint64_t a3, unsigned int a4, _DWORD *a5, unsigned int a6)
{
  *a5 = 0xFFFF;
  if (a2 > 67287)
  {
    switch(a2)
    {
      case 67288:
        uint64_t v7 = "/nv/item_files/modem/hdr/srch/hdr_acq_div_thresh0";
        return ETLEFS2Put(a1, 0, 524352, 0, v7, a3, a4, a5, a6);
      case 67289:
        uint64_t v7 = "/nv/item_files/modem/hdr/srch/hdr_acq_div_thresh1";
        return ETLEFS2Put(a1, 0, 524352, 0, v7, a3, a4, a5, a6);
      case 67290:
        uint64_t v7 = "/nv/item_files/modem/hdr/srch/hdr_acq_div_enable";
        return ETLEFS2Put(a1, 0, 524352, 0, v7, a3, a4, a5, a6);
      case 67297:
        uint64_t v7 = "/nv/item_files/gps/cgps/me/gnss_main_wwan_tx_antenna_im_jamming_power";
        return ETLEFS2Put(a1, 0, 524352, 0, v7, a3, a4, a5, a6);
      case 67298:
        uint64_t v7 = "/nv/item_files/gps/cgps/me/gnss_aux_wwan_tx_antenna_im_jamming_power";
        return ETLEFS2Put(a1, 0, 524352, 0, v7, a3, a4, a5, a6);
      case 67299:
        uint64_t v7 = "/nv/item_files/gps/cgps/me/gnss_wlan_bt_delta_tx_antenna_im_jamming_power";
        return ETLEFS2Put(a1, 0, 524352, 0, v7, a3, a4, a5, a6);
      default:
        goto LABEL_16;
    }
  }
  switch(a2)
  {
    case 65633:
      uint64_t v7 = "/nv/item_files/modem/mmode/lte_bandpref";
      return ETLEFS2Put(a1, 0, 524352, 0, v7, a3, a4, a5, a6);
    case 65728:
      uint64_t v7 = "/nv/item_files/modem/utils/a2/sps_dynamic_usb_endpoint";
      return ETLEFS2Put(a1, 0, 524352, 0, v7, a3, a4, a5, a6);
    case 65768:
      uint64_t v7 = "/nv/item_files/hsusb/device_composition";
      return ETLEFS2Put(a1, 0, 524352, 0, v7, a3, a4, a5, a6);
  }
LABEL_16:
  *a5 = 0x10000;
  return 0;
}

uint64_t ETLNVRAMExtRead(uint64_t (**a1)(void, void *, uint64_t, int *, uint64_t, uint64_t, void), int a2, void *a3, unsigned int a4, unsigned int *a5, unsigned int *a6, unsigned int a7)
{
  *a5 = 0xFFFF;
  if (a2 > 67287)
  {
    switch(a2)
    {
      case 67288:
        unsigned int v9 = "/nv/item_files/modem/hdr/srch/hdr_acq_div_thresh0";
        return ETLEFS2Get(a1, 0, 0, v9, a3, a4, a5, a6, a7);
      case 67289:
        unsigned int v9 = "/nv/item_files/modem/hdr/srch/hdr_acq_div_thresh1";
        return ETLEFS2Get(a1, 0, 0, v9, a3, a4, a5, a6, a7);
      case 67290:
        unsigned int v9 = "/nv/item_files/modem/hdr/srch/hdr_acq_div_enable";
        return ETLEFS2Get(a1, 0, 0, v9, a3, a4, a5, a6, a7);
      case 67297:
        unsigned int v9 = "/nv/item_files/gps/cgps/me/gnss_main_wwan_tx_antenna_im_jamming_power";
        return ETLEFS2Get(a1, 0, 0, v9, a3, a4, a5, a6, a7);
      case 67298:
        unsigned int v9 = "/nv/item_files/gps/cgps/me/gnss_aux_wwan_tx_antenna_im_jamming_power";
        return ETLEFS2Get(a1, 0, 0, v9, a3, a4, a5, a6, a7);
      case 67299:
        unsigned int v9 = "/nv/item_files/gps/cgps/me/gnss_wlan_bt_delta_tx_antenna_im_jamming_power";
        return ETLEFS2Get(a1, 0, 0, v9, a3, a4, a5, a6, a7);
      default:
        goto LABEL_16;
    }
  }
  switch(a2)
  {
    case 65633:
      unsigned int v9 = "/nv/item_files/modem/mmode/lte_bandpref";
      return ETLEFS2Get(a1, 0, 0, v9, a3, a4, a5, a6, a7);
    case 65728:
      unsigned int v9 = "/nv/item_files/modem/utils/a2/sps_dynamic_usb_endpoint";
      return ETLEFS2Get(a1, 0, 0, v9, a3, a4, a5, a6, a7);
    case 65768:
      unsigned int v9 = "/nv/item_files/hsusb/device_composition";
      return ETLEFS2Get(a1, 0, 0, v9, a3, a4, a5, a6, a7);
  }
LABEL_16:
  *a5 = 0x10000;
  return 0;
}

uint64_t APPLIB_DIAG_GPS_SA_RF_VERIF_MODE_SWITCH(_DWORD *a1, int a2, int a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0x12) {
    return result;
  }
  bzero(a1, a2);
  *a1 = 6622539;
  *((_WORD *)a1 + 2) = 276;
  *((unsigned char *)a1 + 6) = a3;
  __int16 v7 = crc_16_l_table[a3 ^ 0x3B] ^ 0xFFB0;
  *((unsigned char *)a1 + 7) = crc_16_l_table[a3 ^ 0x3B] ^ 0xB0;
  int v8 = HIBYTE(v7);
  *((unsigned char *)a1 + 8) = HIBYTE(v7);
  if (a2 < 18) {
    return 0xFFFFFFFFLL;
  }
  int v9 = v7;
  bzero(v15, 0x7FAuLL);
  int __src = 6622539;
  __int16 v14 = 276;
  if ((a3 - 125) <= 1)
  {
    v15[0] = 125;
    int v10 = 7;
    v15[1] = a3 ^ 0x20;
    uint64_t v11 = 8;
    if ((v9 - 125) > 1) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v10 = 6;
  v15[0] = a3;
  uint64_t v11 = 7;
  if ((v9 - 125) <= 1)
  {
LABEL_9:
    *((unsigned char *)&__src + v11) = 125;
    LODWORD(v11) = v10 + 2;
    LOBYTE(v9) = v9 ^ 0x20;
  }
LABEL_10:
  *((unsigned char *)&__src + v11) = v9;
  uint64_t v12 = v11 + 1;
  if ((v8 - 125) <= 1)
  {
    *((unsigned char *)&__src + v12) = 125;
    LOBYTE(v8) = v8 ^ 0x20;
    LODWORD(v12) = v11 + 2;
  }
  *((unsigned char *)&__src + v12) = v8;
  memcpy(a1, &__src, v12 + 1);
  uint64_t result = (v12 + 2);
  *((unsigned char *)a1 + v12 + 1) = 126;
  return result;
}

uint64_t APPLIB_DIAG_GPS_GEN8_HW_CONFIG(char *a1, int a2, uint64_t a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x16)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 6622539;
    *((_WORD *)a1 + 2) = 12826;
    char v7 = *(unsigned char *)(a3 + 4);
    *(_DWORD *)(a1 + 6) = *(_DWORD *)a3;
    a1[10] = v7;
    *(_WORD *)(a1 + 11) = 0;
    a1[13] = 0;
    uint64_t v8 = a1[6];
    unsigned __int16 v9 = crc_16_l_table[v8 ^ 0x33];
    unsigned __int16 v10 = crc_16_l_table[a1[7] ^ 0xD6 ^ v9];
    unsigned __int16 v11 = crc_16_l_table[(a1[8] ^ v10 ^ HIBYTE(v9))];
    unsigned __int16 v12 = crc_16_l_table[(a1[9] ^ v11 ^ HIBYTE(v10))];
    unsigned __int16 v13 = crc_16_l_table[(a1[10] ^ v12 ^ HIBYTE(v11))];
    unsigned int v14 = crc_16_l_table[(v13 ^ HIBYTE(v12))];
    unsigned int v15 = crc_16_l_table[(v14 ^ HIBYTE(v13))];
    unsigned __int16 v16 = crc_16_l_table[crc_16_l_table[(v14 ^ HIBYTE(v13))] ^ (v14 >> 8)];
    *((_WORD *)a1 + 7) = v16 ^ ~HIBYTE(crc_16_l_table[(v14 ^ HIBYTE(v13))]);
    if (a2 >= 32)
    {
      bzero(__src, 0x800uLL);
      int v17 = *a1;
      if ((v17 - 125) > 1)
      {
        unsigned int v18 = 0;
      }
      else
      {
        __src[0] = 125;
        LOBYTE(v17) = v17 ^ 0x20;
        unsigned int v18 = 1;
      }
      __src[v18] = v17;
      uint64_t v19 = v18 + 1;
      int v20 = a1[1];
      if ((v20 - 125) <= 1)
      {
        __src[v19] = 125;
        LODWORD(v19) = v18 | 2;
        LOBYTE(v20) = v20 ^ 0x20;
      }
      uint64_t v21 = &__src[v19];
      unsigned char *v21 = v20;
      *(_DWORD *)(v21 + 1) = 840564837;
      uint64_t v22 = v19 + 5;
      if ((v8 - 125) <= 1)
      {
        __src[v22] = 125;
        LOBYTE(v8) = v8 ^ 0x20;
        LODWORD(v22) = v19 + 6;
      }
      __src[v22] = v8;
      uint64_t v23 = v22 + 1;
      int v24 = a1[7];
      if ((v24 - 125) <= 1)
      {
        __src[v23] = 125;
        LODWORD(v23) = v22 + 2;
        LOBYTE(v24) = v24 ^ 0x20;
      }
      __src[v23] = v24;
      uint64_t v25 = v23 + 1;
      int v26 = a1[8];
      if ((v26 - 125) <= 1)
      {
        __src[v25] = 125;
        LODWORD(v25) = v23 + 2;
        LOBYTE(v26) = v26 ^ 0x20;
      }
      __src[v25] = v26;
      uint64_t v27 = v25 + 1;
      int v28 = a1[9];
      if ((v28 - 125) <= 1)
      {
        __src[v27] = 125;
        LOBYTE(v28) = v28 ^ 0x20;
        LODWORD(v27) = v25 + 2;
      }
      int v29 = ~(v16 ^ BYTE1(v15));
      __src[v27] = v28;
      uint64_t v30 = v27 + 1;
      int v31 = a1[10];
      if ((v31 - 125) <= 1)
      {
        __src[v30] = 125;
        LOBYTE(v31) = v31 ^ 0x20;
        LODWORD(v30) = v27 + 2;
      }
      int v32 = ((unsigned __int16)(v16 ^ ~(unsigned __int16)(v15 >> 8)) >> 8);
      uint64_t v33 = &__src[v30];
      unsigned char *v33 = v31;
      *(_WORD *)(v33 + 1) = 0;
      void v33[3] = 0;
      uint64_t v34 = v30 + 4;
      if ((v29 - 125) <= 1)
      {
        __src[v34] = 125;
        LOBYTE(v29) = v29 ^ 0x20;
        LODWORD(v34) = v30 + 5;
      }
      __src[v34] = v29;
      uint64_t v35 = v34 + 1;
      if ((v32 - 125) <= 1)
      {
        __src[v35] = 125;
        LOBYTE(v32) = v32 ^ 0x20;
        LODWORD(v35) = v34 + 2;
      }
      __src[v35] = v32;
      memcpy(a1, __src, v35 + 1);
      uint64_t result = (v35 + 2);
      a1[v35 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_FTM_GNSS_EXTERNAL_LNA(unsigned __int8 *a1, int a2, int a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || a2 < 0x11) {
    return result;
  }
  bzero(a1, a2);
  *(_DWORD *)a1 = 2231115;
  a1[4] = -3;
  a1[6] = a3;
  uint64_t v7 = a1[5];
  unsigned __int16 v8 = crc_16_l_table[crc_16_l_table[v7 ^ 0xBA] ^ a3 ^ 0xEC];
  unsigned __int16 v9 = crc_16_l_table[(a1[7] ^ v8 ^ HIBYTE(crc_16_l_table[v7 ^ 0xBA]))];
  unsigned int v10 = crc_16_l_table[(a1[8] ^ v9 ^ HIBYTE(v8))];
  int v11 = crc_16_l_table[(a1[9] ^ v10 ^ HIBYTE(v9))];
  int v12 = v11 ^ ~(v10 >> 8);
  *((_WORD *)a1 + 5) = v11 ^ ~HIBYTE(crc_16_l_table[(a1[8] ^ v9 ^ HIBYTE(v8))]);
  if (a2 < 24) {
    return 0xFFFFFFFFLL;
  }
  bzero(v27, 0x7FBuLL);
  int __src = 2231115;
  char v26 = -3;
  if ((v7 - 125) <= 1)
  {
    v27[0] = 125;
    int v13 = 6;
    v27[1] = v7 ^ 0x20;
    uint64_t v14 = 7;
    if ((a3 - 125) > 1) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v13 = 5;
  v27[0] = v7;
  uint64_t v14 = 6;
  if ((a3 - 125) <= 1)
  {
LABEL_9:
    *((unsigned char *)&__src + v14) = 125;
    LOBYTE(a3) = a3 ^ 0x20;
    LODWORD(v14) = v13 + 2;
  }
LABEL_10:
  *((unsigned char *)&__src + v14) = a3;
  uint64_t v15 = v14 + 1;
  int v16 = a1[7];
  if ((v16 - 125) <= 1)
  {
    *((unsigned char *)&__src + v15) = 125;
    LODWORD(v15) = v14 + 2;
    LOBYTE(v16) = v16 ^ 0x20;
  }
  *((unsigned char *)&__src + v15) = v16;
  uint64_t v17 = v15 + 1;
  int v18 = a1[8];
  if ((v18 - 125) <= 1)
  {
    *((unsigned char *)&__src + v17) = 125;
    LOBYTE(v18) = v18 ^ 0x20;
    LODWORD(v17) = v15 + 2;
  }
  int v19 = ~(v11 ^ BYTE1(v10));
  *((unsigned char *)&__src + v17) = v18;
  uint64_t v20 = v17 + 1;
  int v21 = a1[9];
  if ((v21 - 125) <= 1)
  {
    *((unsigned char *)&__src + v20) = 125;
    LOBYTE(v21) = v21 ^ 0x20;
    LODWORD(v20) = v17 + 2;
  }
  char v22 = (unsigned __int16)(v11 ^ ~(unsigned __int16)(v10 >> 8)) >> 8;
  *((unsigned char *)&__src + v20) = v21;
  uint64_t v23 = v20 + 1;
  if ((v19 - 125) <= 1)
  {
    *((unsigned char *)&__src + v23) = 125;
    LOBYTE(v19) = v19 ^ 0x20;
    LODWORD(v23) = v20 + 2;
  }
  *((unsigned char *)&__src + v23) = v19;
  uint64_t v24 = v23 + 1;
  if (BYTE1(v12) - 125 <= 1)
  {
    *((unsigned char *)&__src + v24) = 125;
    char v22 = BYTE1(v12) ^ 0x20;
    LODWORD(v24) = v23 + 2;
  }
  *((unsigned char *)&__src + v24) = v22;
  memcpy(a1, &__src, v24 + 1);
  uint64_t result = (v24 + 2);
  a1[v24 + 1] = 126;
  return result;
}

uint64_t APPLIB_DIAG_GPS_GEN8_StartIQTest(unsigned __int8 *a1, int a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 16)
  {
    bzero(a1, a2);
    *(_OWORD *)a1 = xmmword_1E4590500;
    *((_WORD *)a1 + 8) = 2560;
    unsigned __int16 v5 = crc_16_l_table[a1[7] ^ 0x6DLL];
    unsigned __int16 v6 = crc_16_l_table[a1[8] ^ 0xA6 ^ v5];
    unsigned __int16 v7 = crc_16_l_table[(a1[9] ^ v6 ^ HIBYTE(v5))];
    unsigned __int16 v8 = crc_16_l_table[(a1[10] ^ v7 ^ HIBYTE(v6))];
    unsigned __int16 v9 = crc_16_l_table[(a1[11] ^ v8 ^ HIBYTE(v7))];
    unsigned __int16 v10 = crc_16_l_table[(a1[12] ^ v9 ^ HIBYTE(v8))];
    unsigned __int16 v11 = crc_16_l_table[(a1[13] ^ v10 ^ HIBYTE(v9))];
    unsigned __int16 v12 = crc_16_l_table[(a1[14] ^ v11 ^ HIBYTE(v10))];
    unsigned int v13 = crc_16_l_table[(a1[15] ^ v12 ^ HIBYTE(v11))];
    unsigned __int16 v14 = crc_16_l_table[(v13 ^ HIBYTE(v12))];
    LOWORD(v13) = crc_16_l_table[v14 ^ (v13 >> 8) ^ 0xA];
    unsigned __int16 v15 = crc_16_l_table[(a1[18] ^ v13 ^ HIBYTE(v14))];
    LOWORD(v13) = crc_16_l_table[(a1[19] ^ v15 ^ BYTE1(v13))];
    unsigned int v16 = crc_16_l_table[(a1[20] ^ v13 ^ HIBYTE(v15))];
    *((_WORD *)a1 + 11) = crc_16_l_table[(a1[21] ^ v16 ^ BYTE1(v13))] ^ ~(unsigned __int16)(v16 >> 8);
    if (a2 >= 0x30)
    {
      bzero(__src, 0x800uLL);
      uint64_t v17 = 0;
      LODWORD(v18) = 0;
      do
      {
        while (1)
        {
          int v20 = a1[v17];
          if ((v20 - 125) > 1) {
            break;
          }
          int v19 = v18 + 1;
          __src[(int)v18] = 125;
          __src[(int)v18 + 1] = v20 ^ 0x20;
          size_t v18 = (int)v18 + 1 + 1;
          if (++v17 == 24) {
            goto LABEL_9;
          }
        }
        int v19 = v18;
        __src[(int)v18] = v20;
        size_t v18 = (int)v18 + 1;
        ++v17;
      }
      while (v17 != 24);
LABEL_9:
      memcpy(a1, __src, v18);
      uint64_t result = (v19 + 2);
      a1[v18] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_GPS_GEN8_SV_TRACK(char *a1, int a2, _DWORD *a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 0x12)
  {
    bzero(a1, a2);
    *(_DWORD *)a1 = 6622539;
    *((_WORD *)a1 + 2) = 12827;
    int v7 = *(_DWORD *)((char *)a3 + 3);
    *(_DWORD *)(a1 + 6) = *a3;
    *(_DWORD *)(a1 + 9) = v7;
    uint64_t v8 = a1[6];
    LOWORD(v7) = crc_16_l_table[v8 ^ 0xEB];
    unsigned __int16 v9 = crc_16_l_table[(a1[7] ^ v7) ^ 0xCF];
    LOWORD(v7) = crc_16_l_table[(a1[8] ^ v9 ^ BYTE1(v7))];
    unsigned __int16 v10 = crc_16_l_table[(a1[9] ^ v7 ^ HIBYTE(v9))];
    LOWORD(v7) = crc_16_l_table[(a1[10] ^ v10 ^ BYTE1(v7))];
    unsigned int v11 = crc_16_l_table[(a1[11] ^ v7 ^ HIBYTE(v10))];
    unsigned __int16 v12 = crc_16_l_table[(a1[12] ^ v11 ^ BYTE1(v7))];
    *(_WORD *)(a1 + 13) = v12 ^ ~HIBYTE(crc_16_l_table[(a1[11] ^ v7 ^ HIBYTE(v10))]);
    if (a2 >= 30)
    {
      bzero(v32, 0x7FAuLL);
      int __src = 6622539;
      __int16 v31 = 12827;
      if ((v8 - 125) > 1)
      {
        unsigned int v13 = 6;
      }
      else
      {
        v32[0] = 125;
        LOBYTE(v8) = v8 ^ 0x20;
        unsigned int v13 = 7;
      }
      *((unsigned char *)&__src + v13) = v8;
      uint64_t v14 = v13 + 1;
      int v15 = a1[7];
      if ((v15 - 125) <= 1)
      {
        *((unsigned char *)&__src + v14) = 125;
        LODWORD(v14) = v13 + 2;
        LOBYTE(v15) = v15 ^ 0x20;
      }
      *((unsigned char *)&__src + v14) = v15;
      uint64_t v16 = v14 + 1;
      int v17 = a1[8];
      if ((v17 - 125) <= 1)
      {
        *((unsigned char *)&__src + v16) = 125;
        LOBYTE(v17) = v17 ^ 0x20;
        LODWORD(v16) = v14 + 2;
      }
      *((unsigned char *)&__src + v16) = v17;
      uint64_t v18 = v16 + 1;
      int v19 = a1[9];
      if ((v19 - 125) <= 1)
      {
        *((unsigned char *)&__src + v18) = 125;
        LODWORD(v18) = v16 + 2;
        LOBYTE(v19) = v19 ^ 0x20;
      }
      *((unsigned char *)&__src + v18) = v19;
      uint64_t v20 = v18 + 1;
      int v21 = a1[10];
      if ((v21 - 125) <= 1)
      {
        *((unsigned char *)&__src + v20) = 125;
        LODWORD(v20) = v18 + 2;
        LOBYTE(v21) = v21 ^ 0x20;
      }
      *((unsigned char *)&__src + v20) = v21;
      uint64_t v22 = v20 + 1;
      int v23 = a1[11];
      if ((v23 - 125) <= 1)
      {
        *((unsigned char *)&__src + v22) = 125;
        LOBYTE(v23) = v23 ^ 0x20;
        LODWORD(v22) = v20 + 2;
      }
      int v24 = ~(v12 ^ BYTE1(v11));
      *((unsigned char *)&__src + v22) = v23;
      uint64_t v25 = v22 + 1;
      int v26 = a1[12];
      if ((v26 - 125) <= 1)
      {
        *((unsigned char *)&__src + v25) = 125;
        LOBYTE(v26) = v26 ^ 0x20;
        LODWORD(v25) = v22 + 2;
      }
      int v27 = ((unsigned __int16)(v12 ^ ~(unsigned __int16)(v11 >> 8)) >> 8);
      *((unsigned char *)&__src + v25) = v26;
      uint64_t v28 = v25 + 1;
      if ((v24 - 125) <= 1)
      {
        *((unsigned char *)&__src + v28) = 125;
        LOBYTE(v24) = v24 ^ 0x20;
        LODWORD(v28) = v25 + 2;
      }
      *((unsigned char *)&__src + v28) = v24;
      uint64_t v29 = v28 + 1;
      if ((v27 - 125) <= 1)
      {
        *((unsigned char *)&__src + v29) = 125;
        LOBYTE(v27) = v27 ^ 0x20;
        LODWORD(v29) = v28 + 2;
      }
      *((unsigned char *)&__src + v29) = v27;
      memcpy(a1, &__src, v29 + 1);
      uint64_t result = (v29 + 2);
      a1[v29 + 1] = 126;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_MemoryPoke_Byte(char *a1, int a2, int a3, void *__src, int a5)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a5 && a3 && a1 && a2 >= 0xD && __src)
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 5) = 0;
    *a1 = 5;
    *(_DWORD *)(a1 + 1) = a3;
    a1[5] = a5;
    memcpy(a1 + 6, __src, a5);
    int v9 = 8 * (a5 + 6);
    if (8 * ((_WORD)a5 + 6))
    {
      LOWORD(v10) = -1;
      unsigned int v11 = a1;
      do
      {
        char v12 = *v11++;
        int v10 = crc_16_l_table[(v12 ^ v10)] ^ ((unsigned __int16)(v10 & 0xFF00) >> 8);
        v9 -= 8;
      }
      while ((_WORD)v9);
      char v13 = ~(_BYTE)v10;
      char v14 = (unsigned __int16)~(_WORD)v10 >> 8;
    }
    else
    {
      char v13 = 0;
      char v14 = 0;
    }
    a1[a5 + 6] = v13;
    a1[a5 + 7] = v14;
    uint64_t v15 = (a5 + 8);
    uint64_t result = 0xFFFFFFFFLL;
    if ((int)v15 <= 1024 && 2 * (int)v15 <= a2)
    {
      bzero(__srca, 0x800uLL);
      if ((int)v15 < 1)
      {
        int v16 = 0;
      }
      else
      {
        int v16 = 0;
        int v17 = (unsigned __int8 *)a1;
        do
        {
          int v19 = *v17++;
          char v18 = v19;
          if ((v19 - 125) <= 1)
          {
            __srca[v16] = 125;
            v18 ^= 0x20u;
            ++v16;
          }
          __srca[v16++] = v18;
          --v15;
        }
        while (v15);
      }
      memcpy(a1, __srca, v16);
      uint64_t result = (v16 + 1);
      a1[v16] = 126;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_MemoryPoke_Word(char *a1, int a2, int a3, void *__src, int a5)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a5 && a3 && a1 && a2 >= 0xD && __src)
  {
    *(void *)a1 = 0;
    *a1 = 6;
    *(_DWORD *)(a1 + 1) = a3;
    int v8 = 2 * a5;
    *(void *)(a1 + 5) = 0;
    a1[5] = a5;
    memcpy(a1 + 6, __src, 2 * a5);
    int v9 = 8 * (v8 + 6);
    if ((v9 & 0xFFF0) != 0)
    {
      LOWORD(v10) = -1;
      unsigned int v11 = a1;
      do
      {
        char v12 = *v11++;
        int v10 = crc_16_l_table[(v12 ^ v10)] ^ ((unsigned __int16)(v10 & 0xFF00) >> 8);
        v9 -= 8;
      }
      while ((_WORD)v9);
      char v13 = ~(_BYTE)v10;
      char v14 = (unsigned __int16)~(_WORD)v10 >> 8;
    }
    else
    {
      char v13 = 0;
      char v14 = 0;
    }
    a1[v8 + 6] = v13;
    a1[v8 + 7] = v14;
    uint64_t v15 = (v8 + 8);
    uint64_t result = 0xFFFFFFFFLL;
    if ((int)v15 <= 1024 && 2 * (int)v15 <= a2)
    {
      bzero(__srca, 0x800uLL);
      if ((int)v15 < 1)
      {
        int v16 = 0;
      }
      else
      {
        int v16 = 0;
        int v17 = (unsigned __int8 *)a1;
        do
        {
          int v19 = *v17++;
          char v18 = v19;
          if ((v19 - 125) <= 1)
          {
            __srca[v16] = 125;
            v18 ^= 0x20u;
            ++v16;
          }
          __srca[v16++] = v18;
          --v15;
        }
        while (v15);
      }
      memcpy(a1, __srca, v16);
      uint64_t result = (v16 + 1);
      a1[v16] = 126;
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_MemoryPoke_DWord(char *a1, int a2, int a3, void *__src, int a5)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a5)
  {
    if (a3)
    {
      if (a1)
      {
        if (a2 >= 0xD)
        {
          if (__src)
          {
            *(void *)a1 = 0;
            *a1 = 7;
            *(_DWORD *)(a1 + 1) = a3;
            int v8 = 4 * a5;
            *(void *)(a1 + 5) = 0;
            a1[5] = a5;
            memcpy(a1 + 6, __src, 4 * a5);
            int v9 = 8 * (v8 + 6);
            LOWORD(v10) = -1;
            unsigned int v11 = a1;
            do
            {
              char v12 = *v11++;
              int v10 = crc_16_l_table[(v12 ^ v10)] ^ ((unsigned __int16)(v10 & 0xFF00) >> 8);
              v9 -= 8;
            }
            while ((_WORD)v9);
            a1[v8 + 6] = ~(_BYTE)v10;
            a1[v8 + 7] = (unsigned __int16)~(_WORD)v10 >> 8;
            uint64_t v13 = (v8 + 8);
            uint64_t result = 0xFFFFFFFFLL;
            if ((int)v13 <= 1024 && 2 * (int)v13 <= a2)
            {
              bzero(__srca, 0x800uLL);
              if ((int)v13 < 1)
              {
                int v14 = 0;
              }
              else
              {
                int v14 = 0;
                uint64_t v15 = (unsigned __int8 *)a1;
                do
                {
                  int v17 = *v15++;
                  char v16 = v17;
                  if ((v17 - 125) <= 1)
                  {
                    __srca[v14] = 125;
                    v16 ^= 0x20u;
                    ++v14;
                  }
                  __srca[v14++] = v16;
                  --v13;
                }
                while (v13);
              }
              memcpy(a1, __srca, v14);
              uint64_t result = (v14 + 1);
              a1[v14] = 126;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t APPLIB_DIAG_GPS_SessionControl(char *a1, int a2, char a3, void *__src, int a5)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 39 && __src && a5)
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 5) = 0;
    *a1 = 108;
    a1[1] = a3;
    *((_WORD *)a1 + 1) = a5;
    memcpy(a1 + 4, __src, a5);
    uint64_t v9 = a5 + 4;
    int v10 = 8 * (a5 + 4);
    if (8 * ((_WORD)a5 + 4))
    {
      LOWORD(v11) = -1;
      char v12 = a1;
      do
      {
        char v13 = *v12++;
        int v11 = crc_16_l_table[(v13 ^ v11)] ^ ((unsigned __int16)(v11 & 0xFF00) >> 8);
        v10 -= 8;
      }
      while ((_WORD)v10);
      a1[v9] = ~(_BYTE)v11;
      a1[a5 + 5] = (unsigned __int16)~(_WORD)v11 >> 8;
      uint64_t result = 0xFFFFFFFFLL;
      if (a5 > 1018) {
        return result;
      }
    }
    else
    {
      a1[v9] = 0;
      a1[a5 + 5] = 0;
      uint64_t result = 0xFFFFFFFFLL;
      if (a5 > 1018) {
        return result;
      }
    }
    uint64_t v14 = (a5 + 6);
    if (2 * (int)v14 <= a2)
    {
      bzero(__srca, 0x800uLL);
      if (a5 < -5)
      {
        int v15 = 0;
      }
      else
      {
        int v15 = 0;
        char v16 = (unsigned __int8 *)a1;
        do
        {
          int v18 = *v16++;
          char v17 = v18;
          if ((v18 - 125) <= 1)
          {
            __srca[v15] = 125;
            v17 ^= 0x20u;
            ++v15;
          }
          __srca[v15++] = v17;
          --v14;
        }
        while (v14);
      }
      memcpy(a1, __srca, v15);
      uint64_t result = (v15 + 1);
      a1[v15] = 126;
    }
  }
  return result;
}

uint64_t HDLCFrameCreateDownlink()
{
  return MEMORY[0x1F417A5D8]();
}

uint64_t HDLCFrameCreateUplink()
{
  return MEMORY[0x1F417A5E0]();
}

uint64_t HDLCFrameEncode()
{
  return MEMORY[0x1F417A5E8]();
}

uint64_t HDLCFrameEncodeAndCache()
{
  return MEMORY[0x1F417A5F0]();
}

uint64_t HDLCFrameFree()
{
  return MEMORY[0x1F417A5F8]();
}

uint64_t HDLCFrameGetFreeSpace()
{
  return MEMORY[0x1F417A600]();
}

uint64_t HDLCFrameInject()
{
  return MEMORY[0x1F417A608]();
}

uint64_t HDLCFrameInjectUnsignedChar()
{
  return MEMORY[0x1F417A610]();
}

uint64_t HDLCFrameInjectUnsignedInt()
{
  return MEMORY[0x1F417A618]();
}

uint64_t HDLCFrameInjectUnsignedShort()
{
  return MEMORY[0x1F417A620]();
}

uint64_t TelephonyUtilBinToHex()
{
  return MEMORY[0x1F417D8B8]();
}

uint64_t TelephonyUtilDecodeHexWithDefault()
{
  return MEMORY[0x1F417D8D0]();
}

uint64_t TelephonyUtilEncodeHex()
{
  return MEMORY[0x1F417D8D8]();
}

uint64_t TelephonyUtilLogBinaryToBuffer()
{
  return MEMORY[0x1F417D900]();
}

uint64_t TelephonyUtilRingBufferGetSize()
{
  return MEMORY[0x1F417D908]();
}

uint64_t TelephonyUtilRingBufferInitialize()
{
  return MEMORY[0x1F417D910]();
}

uint64_t TelephonyUtilRingBufferInsertTransport()
{
  return MEMORY[0x1F417D918]();
}

uint64_t TelephonyUtilRingBufferLinearize()
{
  return MEMORY[0x1F417D920]();
}

uint64_t TelephonyUtilRingBufferReset()
{
  return MEMORY[0x1F417D928]();
}

uint64_t TelephonyUtilRingBufferSkip()
{
  return MEMORY[0x1F417D930]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

uint64_t capabilities::etl::supportsBBAppsCrash(capabilities::etl *this)
{
  return MEMORY[0x1F417D468](this);
}

uint64_t capabilities::etl::getMavSHAHashLenType(capabilities::etl *this)
{
  return MEMORY[0x1F417D470](this);
}

uint64_t capabilities::etl::maverickTxPowerUsesRFSubsys(capabilities::etl *this)
{
  return MEMORY[0x1F417D478](this);
}

uint64_t capabilities::etl::getMaverickIPALoopbackV2ParametersType(capabilities::etl *this)
{
  return MEMORY[0x1F417D480](this);
}

uint64_t capabilities::radio::mav20Plus(capabilities::radio *this)
{
  return MEMORY[0x1F417D5F8](this);
}

uint64_t capabilities::radio::mavLegacy(capabilities::radio *this)
{
  return MEMORY[0x1F417D600](this);
}

uint64_t ctu::tokenize()
{
  return MEMORY[0x1F417DBF8]();
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1F417E408](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1F417E418](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x1F417E448](this, a2);
}

void std::this_thread::sleep_for (const std::chrono::nanoseconds *__ns)
{
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E5C0](this, __s, __n);
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1F417E848]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1F417E850]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x1F417E860]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1F417E898]();
}

{
  return MEMORY[0x1F417E8A0]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1F417E978]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1F417E980]();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

std::chrono::steady_clock::time_point std::chrono::steady_clock::now(void)
{
  return (std::chrono::steady_clock::time_point)MEMORY[0x1F417EC90]();
}

void std::locale::~locale(std::locale *this)
{
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1F417EE40]();
}

void std::terminate(void)
{
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1F417EF30](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1F417EF48](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

int *__error(void)
{
  return (int *)MEMORY[0x1F40C9B88]();
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1F40C9C28]();
}

void bzero(void *a1, size_t a2)
{
}

void *__cdecl calloc(size_t __count, size_t __size)
{
  return (void *)MEMORY[0x1F40CA660](__count, __size);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CC1D8](a1, a2);
}

void free(void *a1)
{
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1F40CC910]();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1F40CCA60](info);
}

void *__cdecl malloc(size_t __size)
{
  return (void *)MEMORY[0x1F40CCB10](__size);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCD8](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1F40CCCE8](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD10](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD20](__b, *(void *)&__c, __len);
}

unsigned int sleep(unsigned int a1)
{
  return MEMORY[0x1F40CE078](*(void *)&a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1F40CE080](__str, __size, __format);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1F40CE158](__s1, __s2);
}

int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
{
  return MEMORY[0x1F40CE190](*(void *)&__errnum, __strerrbuf, __buflen);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1F40CE1F0](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x1F40CE1F8](__dst, __src, __n);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1F40CE2E0](__str, __endptr, *(void *)&__base);
}