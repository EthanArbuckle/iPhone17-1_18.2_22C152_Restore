objc_object *sub_180109C10(objc_object *a1, double a2)
{
  uint64_t v2;
  char v3;

  if ((v3 & 2) != 0 && (*(_DWORD *)((v2 & 0xFFFFFFFF8) + 0x28) & 2) != 0) {
    return (objc_object *)swiftRetain(a1, a2);
  }
  else {
    return [(objc_object *)a1 retain];
  }
}

id objc_alloc(id result)
{
  if (result)
  {
    if ((*(_WORD *)((*(void *)result & 0xFFFFFFFF8) + 0x1E) & 0x4000) != 0) {
      return _objc_rootAllocWithZone((uint64_t)result);
    }
    else {
      return [result alloc];
    }
  }
  return result;
}

BOOL object_isClass(id obj)
{
  if ((uint64_t)obj < 1) {
    LOBYTE(v1) = 0;
  }
  else {
    return (*(unsigned __int16 *)((*(void *)obj & 0xFFFFFFFF8) + 0x1E) >> 2) & 1;
  }
  return v1;
}

id objc_msgSend(id result, SEL a2, ...)
{
  if ((uint64_t)result > 0)
  {
    uint64_t v16 = *(void *)result & 0x7FFFFFFFFFFFF8;
    goto LABEL_3;
  }
  if (result)
  {
    if ((result & 7) == 7) {
      uint64_t v28 = (uint64_t)result >> 55;
    }
    else {
      uint64_t v28 = result & 7;
    }
    uint64_t v16 = objc_debug_taggedpointer_classes[v28];
LABEL_3:
    while (1)
    {
      unint64_t v17 = *(void *)(v16 + 16);
      if ((v17 & 1) == 0) {
        break;
      }
      unint64_t v27 = *(void *)((v17 & 0x7FFFFFFFFFFFFELL)
                      + 8 * (((a2 - (SEL)&unk_1F62995A8) >> (v17 >> 55)) & (0x7FFFuLL >> (v17 >> 60))));
      if (a2 - (SEL)&unk_1F62995A8 == v27 >> 38) {
        return (id)((uint64_t (*)(void))(v16 - ((uint64_t)(v27 << 26) >> 24)))();
      }
      v16 += *(void *)((v17 & 0x7FFFFFFFFFFFFELL) - 16);
    }
    unint64_t v18 = v17 & 0xFFFFFFFFFFFFLL;
    unint64_t v19 = ((unint64_t)a2 ^ ((unint64_t)a2 >> 7)) & HIWORD(v17);
    unint64_t v20 = (v17 & 0xFFFFFFFFFFFFLL) + 16 * v19;
    while (1)
    {
      v22 = *(uint64_t (**)(void))v20;
      v21 = *(const char **)(v20 + 8);
      v20 -= 16;
      if (v21 == a2) {
        return (id)v22();
      }
      if (!v21) {
        break;
      }
      if (v20 < v18)
      {
        unint64_t v23 = v18 + (v17 >> 44);
        unint64_t v24 = v18 + 16 * v19;
        while (1)
        {
          v22 = *(uint64_t (**)(void))v23;
          v25 = *(const char **)(v23 + 8);
          v23 -= 16;
          if (v25 == a2) {
            break;
          }
          if (v25) {
            BOOL v26 = v23 > v24;
          }
          else {
            BOOL v26 = 0;
          }
          if (!v26) {
            return (id)[result _objc_msgSend_uncached:a2 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15];
          }
        }
        return (id)v22();
      }
    }
    return (id)[result _objc_msgSend_uncached:a2 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15];
  }
  return result;
}

objc_object *objc_msgLookup(objc_object *a1, objc_selector *a2)
{
  if ((uint64_t)a1 > 0)
  {
    uint64_t v2 = (uint64_t)a1->isa & 0x7FFFFFFFFFFFF8;
    goto LABEL_3;
  }
  if (a1)
  {
    if ((a1 & 7) == 7) {
      uint64_t v13 = (uint64_t)a1 >> 55;
    }
    else {
      uint64_t v13 = a1 & 7;
    }
    uint64_t v2 = objc_debug_taggedpointer_classes[v13];
LABEL_3:
    while (1)
    {
      unint64_t v3 = *(void *)(v2 + 16);
      if ((v3 & 1) == 0) {
        break;
      }
      if (a2 - (objc_selector *)&unk_1F62995A8 == *(void *)((v3 & 0x7FFFFFFFFFFFFELL)
                                                             + 8
                                                             * (((a2 - (objc_selector *)&unk_1F62995A8) >> (v3 >> 55)) & (0x7FFFuLL >> (v3 >> 60)))) >> 38)
        return a1;
      v2 += *(void *)((v3 & 0x7FFFFFFFFFFFFELL) - 16);
    }
    unint64_t v4 = v3 & 0xFFFFFFFFFFFFLL;
    unint64_t v5 = ((unint64_t)a2 ^ ((unint64_t)a2 >> 7)) & HIWORD(v3);
    uint64_t v6 = (uint64_t *)((v3 & 0xFFFFFFFFFFFFLL) + 16 * v5);
    while (1)
    {
      uint64_t v8 = *v6;
      uint64_t v7 = (objc_selector *)v6[1];
      v6 -= 2;
      if (v7 == a2) {
        break;
      }
      if (!v7) {
        return _objc_msgLookup_uncached(a1, a2);
      }
      if ((unint64_t)v6 < v4)
      {
        __n128 v9 = (uint64_t *)(v4 + (v3 >> 44));
        unint64_t v10 = v4 + 16 * v5;
        while (1)
        {
          uint64_t v8 = *v9;
          __n128 v11 = (objc_selector *)v9[1];
          v9 -= 2;
          if (v11 == a2) {
            break;
          }
          if (v11) {
            BOOL v12 = (unint64_t)v9 > v10;
          }
          else {
            BOOL v12 = 0;
          }
          if (!v12) {
            return _objc_msgLookup_uncached(a1, a2);
          }
        }
        break;
      }
    }
  }
  return a1;
}

double _objc_msgNil()
{
  return 0.0;
}

double _objc_returnNil()
{
  return _objc_msgNil();
}

id objc_msgSendSuper(objc_super *a1, SEL a2, ...)
{
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  receiver = (objc_object *)a1->receiver;
  for (uint64_t i = *((void *)a1->super_class + 1); ; i += *(void *)((v19 & 0x7FFFFFFFFFFFFELL) - 16))
  {
    unint64_t v19 = *(void *)(i + 16);
    if ((v19 & 1) == 0) {
      break;
    }
    unint64_t v30 = *(void *)((v19 & 0x7FFFFFFFFFFFFELL)
                    + 8 * (((a2 - (SEL)&unk_1F62995A8) >> (v19 >> 55)) & (0x7FFFuLL >> (v19 >> 60))));
    if (a2 - (SEL)&unk_1F62995A8 == v30 >> 38) {
      return (id)((uint64_t (*)(objc_object *))(i - ((uint64_t)(v30 << 26) >> 24)))(receiver);
    }
  }
  unint64_t v20 = v19 & 0xFFFFFFFFFFFFLL;
  unint64_t v21 = ((unint64_t)a2 ^ ((unint64_t)a2 >> 7)) & HIWORD(v19);
  unint64_t v22 = (v19 & 0xFFFFFFFFFFFFLL) + 16 * v21;
  while (1)
  {
    unint64_t v24 = *(uint64_t (**)(objc_object *))v22;
    unint64_t v23 = *(const char **)(v22 + 8);
    v22 -= 16;
    if (v23 == a2) {
      return (id)v24(receiver);
    }
    if (!v23) {
      break;
    }
    if (v22 < v20)
    {
      unint64_t v26 = v20 + (v19 >> 44);
      unint64_t v27 = v20 + 16 * v21;
      while (1)
      {
        unint64_t v24 = *(uint64_t (**)(objc_object *))v26;
        uint64_t v28 = *(const char **)(v26 + 8);
        v26 -= 16;
        if (v28 == a2) {
          break;
        }
        if (v28) {
          BOOL v29 = v26 > v27;
        }
        else {
          BOOL v29 = 0;
        }
        if (!v29) {
          return (id)[receiver _objc_msgSend_uncached:(objc_selector *)a2, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15];
        }
      }
      return (id)v24(receiver);
    }
  }
  return (id)[receiver _objc_msgSend_uncached:(objc_selector *)a2 v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15];
}

objc_object *objc_msgLookupSuper2(uint64_t a1, objc_selector *a2)
{
  result = *(objc_object **)a1;
  for (uint64_t i = *(void *)(*(void *)(a1 + 8) + 8); ; i += *(void *)((v5 & 0x7FFFFFFFFFFFFELL) - 16))
  {
    unint64_t v5 = *(void *)(i + 16);
    if ((v5 & 1) == 0) {
      break;
    }
    if (a2 - (objc_selector *)&unk_1F62995A8 == *(void *)((v5 & 0x7FFFFFFFFFFFFELL)
                                                           + 8
                                                           * (((a2 - (objc_selector *)&unk_1F62995A8) >> (v5 >> 55)) & (0x7FFFuLL >> (v5 >> 60)))) >> 38)
      return result;
  }
  unint64_t v6 = v5 & 0xFFFFFFFFFFFFLL;
  unint64_t v7 = ((unint64_t)a2 ^ ((unint64_t)a2 >> 7)) & HIWORD(v5);
  __n128 v8 = (uint64_t *)((v5 & 0xFFFFFFFFFFFFLL) + 16 * v7);
  while (1)
  {
    uint64_t v10 = *v8;
    __n128 v9 = (objc_selector *)v8[1];
    v8 -= 2;
    if (v9 == a2) {
      break;
    }
    if (!v9) {
      return _objc_msgLookup_uncached(result, a2);
    }
    if ((unint64_t)v8 < v6)
    {
      __n128 v11 = (uint64_t *)(v6 + (v5 >> 44));
      unint64_t v12 = v6 + 16 * v7;
      while (1)
      {
        uint64_t v10 = *v11;
        __n128 v13 = (objc_selector *)v11[1];
        v11 -= 2;
        if (v13 == a2) {
          break;
        }
        if (v13) {
          BOOL v14 = (unint64_t)v11 > v12;
        }
        else {
          BOOL v14 = 0;
        }
        if (!v14) {
          return _objc_msgLookup_uncached(result, a2);
        }
      }
      break;
    }
  }
  return result;
}

uint64_t _objc_msgSend_uncached(objc_object *a1, objc_selector *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9, __n128 a10, __n128 a11, __n128 a12, __n128 a13, __n128 a14, __n128 a15, __n128 a16, ...)
{
  unint64_t v17 = lookUpImpOrForward(a1, a2, v16, 3u);
  if ((vars8 & 0x4000000000000000) != 0) {
    __break(0xC471u);
  }
  return ((uint64_t (*)(objc_object *, objc_selector *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128))v17)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
}

objc_object *_objc_msgLookup_uncached(objc_object *a1, objc_selector *a2)
{
  lookUpImpOrForward(a1, a2, v2, 3u);
  result = a1;
  if ((vars8 & 0x4000000000000000) != 0) {
    __break(0xC471u);
  }
  return result;
}

uint64_t cache_getImp(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a1 + 16);
  if (v3)
  {
    unint64_t v14 = *(void *)((v3 & 0x7FFFFFFFFFFFFELL)
                    + 8 * (((a2 - (void)&unk_1F62995A8) >> (v3 >> 55)) & (0x7FFFuLL >> (v3 >> 60))));
    if (a2 - (void)&unk_1F62995A8 == v14 >> 38) {
      return a1 - ((uint64_t)(v14 << 26) >> 24);
    }
    else {
      return a3;
    }
  }
  else
  {
    unint64_t v4 = v3 & 0xFFFFFFFFFFFFLL;
    unint64_t v5 = (a2 ^ (a2 >> 7)) & HIWORD(v3);
    unint64_t v6 = (uint64_t *)((v3 & 0xFFFFFFFFFFFFLL) + 16 * v5);
    while (1)
    {
      uint64_t v8 = *v6;
      uint64_t v7 = v6[1];
      v6 -= 2;
      if (v7 == a2) {
        break;
      }
      if (!v7) {
        return 0;
      }
      if ((unint64_t)v6 < v4)
      {
        uint64_t v10 = (uint64_t *)(v4 + (v3 >> 44));
        unint64_t v11 = v4 + 16 * v5;
        while (1)
        {
          uint64_t v8 = *v10;
          uint64_t v12 = v10[1];
          v10 -= 2;
          if (v12 == a2) {
            break;
          }
          if (v12) {
            BOOL v13 = (unint64_t)v10 > v11;
          }
          else {
            BOOL v13 = 0;
          }
          if (!v13) {
            return 0;
          }
        }
        break;
      }
    }
    uint64_t result = v8;
    if (v8)
    {
    }
  }
  return result;
}

void _objc_msgForward(void)
{
}

void method_invoke(void)
{
  if (v1)
  {
    __n128 v19 = v9;
    __n128 v20 = v10;
    __n128 v21 = v11;
    __n128 v22 = v12;
    __n128 v23 = v13;
    __n128 v24 = v14;
    __n128 v25 = v15;
    __n128 v26 = v16;
    uint64_t v27 = v0;
    uint64_t v28 = v2;
    uint64_t v29 = v3;
    uint64_t v30 = v4;
    uint64_t v31 = v5;
    uint64_t v32 = v6;
    uint64_t v33 = v7;
    ImplementationAndName = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128))_method_getImplementationAndName(v1);
    if ((v8 & 0x4000000000000000) != 0) {
      __break(0xC471u);
    }
    ImplementationAndName(v27, v17, v28, v29, v30, v31, v32, v33, v19, v20, v21, v22, v23, v24, v25, v26);
  }
  else
  {
    (*(void (**)(void))((v1 & 0xFFFFFFFFFFFFFFFCLL) + 16))();
  }
}

BOOL class_isMetaClass(Class cls)
{
  if (cls) {
    LODWORD(cls) = (*((unsigned __int16 *)cls + 15) >> 2) & 1;
  }
  return (char)cls;
}

const char *__cdecl sel_getName(const char *sel)
{
  if (!sel) {
    return "<null selector>";
  }
  return sel;
}

uint64_t load_images(uint64_t a1)
{
  if (PrintImages)
  {
    v56 = *(const char **)(a1 + 8);
    if (!v56) {
      v56 = "<null>";
    }
    _objc_inform("IMAGES: calling +load methods in %s\n", v56);
  }
  if (_dyld_lookup_section_info()) {
    BOOL v2 = v1 > 7;
  }
  else {
    BOOL v2 = 0;
  }
  if (v2 || ((result = _dyld_lookup_section_info()) != 0 ? (BOOL v5 = v4 >= 8) : (BOOL v5 = 0), v5))
  {
    os_unfair_recursive_lock_lock_with_options();
    int v6 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v6, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v6) {
      os_unfair_lock_lock_with_options();
    }
    loadAllCategoriesIfNeeded();
    uint64_t v8 = (unint64_t *)_dyld_lookup_section_info();
    if (v8 && v7 >= 8)
    {
      if (v7 >> 3 <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v7 >> 3;
      }
      do
      {
        unint64_t v10 = remapClass(*v8);
        schedule_class_load(v10);
        ++v8;
        --v9;
      }
      while (v9);
    }
    LoadMethod = (objc_class *)_dyld_lookup_section_info();
    __n128 v14 = (uint64_t *)LoadMethod;
    if (LoadMethod && v12 >= 8)
    {
      if (v12 >> 3 <= 1) {
        uint64_t v15 = 1;
      }
      else {
        uint64_t v15 = v12 >> 3;
      }
      do
      {
        uint64_t v16 = *v14;
        LoadMethod = (objc_class *)remapClass(*(void *)(*v14 + 8));
        if (LoadMethod)
        {
          if ((*((unsigned char *)LoadMethod + 32) & 2) != 0)
          {
            uint64_t v57 = *(void *)v16;
            v58 = objc_class::nameForLogging(LoadMethod);
            _objc_fatal("Category %s on Swift class %s has +load method. Swift class extensions and categories on Swift classes are not allowed to have +load methods.", v59, v60, v61, v57, v58);
          }
          realizeClassWithoutSwift(LoadMethod, 0);
          LoadMethod = (objc_class *)_category_getLoadMethod(v16, v17, v18, v19);
          __n128 v20 = LoadMethod;
          if (LoadMethod)
          {
            if (PrintLoading)
            {
              __n128 v21 = (objc_class *)remapClass(*(void *)(v16 + 8));
              __n128 v22 = objc_class::nameForLogging(v21);
              _objc_inform("LOAD: category '%s(%s)' scheduled for +load", v22, *(const char **)v16);
            }
            int v23 = loadable_categories_used;
            LoadMethod = (objc_class *)loadable_categories;
            if (loadable_categories_used == loadable_categories_allocated)
            {
              loadable_categories_allocated = 2 * loadable_categories_used + 16;
              LoadMethod = (objc_class *)malloc_type_realloc((void *)loadable_categories, 16 * loadable_categories_allocated, 0xA0040AFF93C70uLL);
              loadable_categories = (uint64_t)LoadMethod;
              int v23 = loadable_categories_used;
            }
            __n128 v24 = (uint64_t *)((char *)LoadMethod + 16 * v23);
            *__n128 v24 = v16;
            v24[1] = (uint64_t)v20;
            loadable_categories_used = v23 + 1;
          }
        }
        ++v14;
        --v15;
      }
      while (v15);
    }
    int v25 = *(_DWORD *)(StatusReg + 24);
    int v26 = v25;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v26, 0, memory_order_release, memory_order_relaxed);
    if (v26 != v25) {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
    if (call_load_methods::loading)
    {
LABEL_85:
      return os_unfair_recursive_lock_unlock();
    }
    call_load_methods::loading = 1;
    context = AutoreleasePoolPage::push((objc_object *)LoadMethod, v12, v13);
    uint64_t v27 = &objc_debug_taggedpointer_ext_classes[202];
    uint64_t v28 = &objc_debug_taggedpointer_ext_classes[202];
    uint64_t v29 = loadable_classes_used;
    while (1)
    {
      if ((int)v29 >= 1)
      {
        do
        {
          uint64_t v30 = 0;
          uint64_t v31 = (char *)v28[210];
          v28[210] = 0;
          loadable_classes_allocated = 0;
          *((_DWORD *)v27 + 450) = 0;
          uint64_t v32 = 16 * v29;
          do
          {
            uint64_t v33 = *(void *)&v31[v30];
            if (v33)
            {
              v34 = *(void (**)(uint64_t, char *))&v31[v30 + 8];
              if (PrintLoading)
              {
                v35 = objc_class::nameForLogging(*(objc_class **)&v31[v30]);
                _objc_inform("LOAD: +[%s load]\n", v35);
              }
              v34(v33, sel_load);
            }
            v30 += 16;
          }
          while (v32 != v30);
          free(v31);
          uint64_t v29 = *((unsigned int *)v27 + 450);
        }
        while ((int)v29 > 0);
      }
      v36 = (char *)loadable_categories;
      uint64_t v37 = loadable_categories_used;
      int v38 = loadable_categories_allocated;
      loadable_categories = 0;
      loadable_categories_allocated = 0;
      loadable_categories_used = 0;
      if ((int)v37 < 1)
      {
        BOOL v51 = 0;
        if (!v37) {
          goto LABEL_72;
        }
        goto LABEL_75;
      }
      uint64_t v39 = 0;
      int v63 = v37;
      uint64_t v40 = 16 * v37;
      do
      {
        uint64_t v41 = *(void *)&v36[v39];
        if (v41)
        {
          int v42 = 0;
          v43 = *(void (**)(objc_class *, char *))&v36[v39 + 8];
          atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v42, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
          if (v42) {
            os_unfair_lock_lock_with_options();
          }
          v44 = (objc_class *)remapClass(*(void *)(v41 + 8));
          int v45 = *(_DWORD *)(StatusReg + 24);
          int v46 = v45;
          atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v46, 0, memory_order_release, memory_order_relaxed);
          if (v46 != v45) {
            os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
          }
          if (v44)
          {
            if (PrintLoading)
            {
              v47 = objc_class::nameForLogging(v44);
              _objc_inform("LOAD: +[%s(%s) load]\n", v47, *(const char **)v41);
            }
            v43(v44, sel_load);
            *(void *)&v36[v39] = 0;
          }
        }
        v39 += 16;
      }
      while (v40 != v39);
      uint64_t v48 = 0;
      int v49 = 0;
      uint64_t v27 = &objc_debug_taggedpointer_ext_classes[202];
      uint64_t v28 = objc_debug_taggedpointer_ext_classes + 1616;
      do
      {
        if (*(void *)&v36[v48]) {
          *(_OWORD *)&v36[v48 + -16 * v49] = *(_OWORD *)&v36[v48];
        }
        else {
          ++v49;
        }
        v48 += 16;
      }
      while (v40 != v48);
      int v50 = loadable_categories_used;
      LODWORD(v37) = v63 - v49;
      BOOL v51 = loadable_categories_used > 0;
      if (loadable_categories_used >= 1) {
        break;
      }
      v54 = (void *)loadable_categories;
      if (loadable_categories) {
        goto LABEL_71;
      }
      BOOL v51 = 0;
      if (!v37)
      {
LABEL_72:
        if (v36)
        {
          free(v36);
          v36 = 0;
        }
        int v38 = 0;
      }
LABEL_75:
      loadable_categories = (uint64_t)v36;
      loadable_categories_used = v37;
      loadable_categories_allocated = v38;
      if (v37 && PrintLoading) {
        _objc_inform("LOAD: %d categories still waiting for +load\n", v37);
      }
      uint64_t v29 = *((unsigned int *)v27 + 450);
      char v55 = (int)v29 > 0 || v51;
      if ((v55 & 1) == 0)
      {
        call_load_methods::loading = 0;
        goto LABEL_85;
      }
    }
    uint64_t v52 = 0;
    uint64_t v53 = 0;
    do
    {
      if (v37 + v53 == v38)
      {
        int v38 = 2 * v38 + 16;
        v36 = (char *)malloc_type_realloc(v36, 16 * v38, 0xA0040AFF93C70uLL);
        int v50 = loadable_categories_used;
      }
      v54 = (void *)loadable_categories;
      *(_OWORD *)&v36[16 * (int)v37 + v52] = *(_OWORD *)(loadable_categories + v52);
      ++v53;
      v52 += 16;
    }
    while (v53 < v50);
    LODWORD(v37) = v37 + v53;
    uint64_t v27 = objc_debug_taggedpointer_ext_classes + 1616;
    uint64_t v28 = objc_debug_taggedpointer_ext_classes + 1616;
LABEL_71:
    free(v54);
    if (!v37) {
      goto LABEL_72;
    }
    goto LABEL_75;
  }
  return result;
}

void sub_18010CA20(_Unwind_Exception *a1)
{
}

{
  void *v1;
  AutoreleasePoolPage *v2;
  objc_object **v3;
  void *StatusReg;
  void *v6;
  void *v7;
  unint64_t v8;
  const void **v9;
  BOOL v10;
  AutoreleasePoolPage *v12;
  uint64_t vars8;

  unint64_t StatusReg = (void *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  int v6 = (void *)(StatusReg[44] & 0xFFFFFFFFFFFFFFFCLL);
  if (v6)
  {
    unint64_t v7 = StatusReg + 44;
    do
    {
      *unint64_t v7 = 0;
      StatusReg[45] = 0;

      int v6 = (void *)(*v7 & 0xFFFFFFFFFFFFFFFCLL);
    }
    while (v6);
  }
  if (context == (void *)1)
  {
    uint64_t v8 = StatusReg[43];
    if (v8 < 2)
    {
      StatusReg[43] = 0;
      return;
    }
    if (*(_DWORD *)v8 != -1583242847) {
LABEL_6:
    }
      AutoreleasePoolPage::busted_die((const void **)v8);
    while (1)
    {
      uint64_t v9 = *(const void ***)(v8 + 32);
      if (!v9) {
        break;
      }
      uint64_t v8 = *(void *)(v8 + 32);
      if (*(_DWORD *)v9 != -1583242847) {
        AutoreleasePoolPage::busted_die(v9);
      }
    }
    context = (void *)(v8 + 56);
  }
  else
  {
    uint64_t v8 = (unint64_t)context & 0xFFFFFFFFFFFFF000;
    if (*(_DWORD *)((unint64_t)context & 0xFFFFFFFFFFFFF000) != -1583242847) {
      goto LABEL_6;
    }
  }
  if (*(void *)context && (context != (void *)(v8 + 56) || *(void *)(v8 + 32)))
  {
    AutoreleasePoolPage::badPop((AutoreleasePoolPage *)context, v1);
  }
  else
  {
    if (PrintPoolHiwat) {
      unint64_t v10 = 0;
    }
    else {
      unint64_t v10 = DebugPoolAllocation == 0;
    }
    if (v10 && DebugMissingPools == 0)
    {
      AutoreleasePoolPage::releaseUntil((objc_object ***)v8, (objc_object **)context);
      unint64_t v12 = *(AutoreleasePoolPage **)(v8 + 40);
      if (v12)
      {
        if ((uint64_t)(*(void *)(v8 + 16) - v8 - 56) < 2016
          || (unint64_t v12 = (AutoreleasePoolPage *)*((void *)v12 + 5)) != 0)
        {
          AutoreleasePoolPage::kill(v12);
        }
      }
    }
    else
    {
      AutoreleasePoolPage::popPageDebug((const void ***)v8, (objc_object **)context, v2, v3);
    }
  }
}

uint64_t *AutoreleasePoolPage::push(objc_object *this, uint64_t a2, AutoreleasePoolPage *a3)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v4 = *(void *)(StatusReg + 352);
  BOOL v5 = (objc_object *)(v4 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v4 & 0xFFFFFFFFFFFFFFFCLL) != 0)
  {
    if ((v4 & 2) != 0)
    {
      unint64_t v6 = *(void *)(StatusReg + 344);
      if (v6 >= 2)
      {
        if (*(_DWORD *)v6 != -1583242847) {
          AutoreleasePoolPage::busted_die(*(const void ***)(StatusReg + 344));
        }
        if (*(void *)(v6 + 16) == v6 + 4096) {
          this = (objc_object *)AutoreleasePoolPage::autoreleaseFullPage(v5, *(objc_object **)(StatusReg + 344), a3);
        }
        else {
          this = (objc_object *)AutoreleasePoolPage::add(*(AutoreleasePoolPage **)(StatusReg + 344), (uint64_t)v5);
        }
      }
      else
      {
        this = (objc_object *)AutoreleasePoolPage::autoreleaseNoPage(v5, v5);
      }
    }
    else
    {
      *(void *)(StatusReg + 352) = -1;
      *(void *)(StatusReg + 360) = 0;
      this = v5;
    }
  }
  *(void *)(StatusReg + 352) = 0;
  *(void *)(StatusReg + 360) = 0;
  if (DebugPoolAllocation) {
    return AutoreleasePoolPage::autoreleaseNewPage((AutoreleasePoolPage *)this, v5, a3);
  }
  unint64_t v7 = *(objc_object **)(StatusReg + 344);
  if ((unint64_t)v7 < 2) {
    return (uint64_t *)AutoreleasePoolPage::autoreleaseNoPage(0, v7);
  }
  if (LODWORD(v7->isa) != -1583242847) {
    AutoreleasePoolPage::busted_die(*(const void ***)(StatusReg + 344));
  }
  isa = v7[2].isa;
  if (isa == (void *)&v7[512]) {
    return AutoreleasePoolPage::autoreleaseFullPage(0, v7, a3);
  }
  v7[2].isa = (Class)(isa + 1);
  void *isa = 0;
  return isa;
}

void *AutoreleasePoolPage::releaseUntil(objc_object ***this, objc_object **a2)
{
  unint64_t StatusReg = (void *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  while (1)
  {
    while (this[2] != a2)
    {
      uint64_t v5 = StatusReg[43];
      if (!v5) {
        goto LABEL_11;
      }
      if (v5 == 1)
      {
        uint64_t v5 = 0;
        goto LABEL_11;
      }
      if (*(_DWORD *)v5 != -1583242847) {
LABEL_20:
      }
        AutoreleasePoolPage::busted_die((const void **)v5);
LABEL_11:
      while (1)
      {
        uint64_t v6 = *(void *)(v5 + 16);
        if (v6 != v5 + 56) {
          break;
        }
        uint64_t v5 = *(void *)(v5 + 32);
        if (v5 && *(_DWORD *)v5 != -1583242847) {
          goto LABEL_20;
        }
        StatusReg[43] = v5;
      }
      *(void *)(v5 + 16) = v6 - 8;
      unint64_t v7 = *(void *)(v6 - 8);
      *(void *)(v6 - 8) = 0xA3A3A3A3A3A3A3A3;
      uint64_t v8 = (void *)(v7 & 0xF00FFFFFFFFFFFFLL);
      if ((v7 & 0xF00FFFFFFFFFFFFLL) != 0)
      {
        int v9 = ((v7 >> 60) | (v7 >> 44) & 0xFF0) + 1;
        do
        {

          --v9;
        }
        while (v9);
      }
    }
    uint64_t result = (void *)(StatusReg[44] & 0xFFFFFFFFFFFFFFFCLL);
    if (!result) {
      break;
    }
    StatusReg[44] = 0;
    StatusReg[45] = 0;
  }
  if (*(_DWORD *)this != -1583242847) {
    AutoreleasePoolPage::busted_die((const void **)this);
  }
  StatusReg[43] = this;
  return result;
}

void _objc_rootDealloc(unint64_t a1)
{
  if ((a1 & 0x8000000000000000) == 0)
  {
    uint64_t v2 = *(void *)a1;
    if ((*(void *)a1 & 7) != 1
      || (v2 & 0x80000000000000) != 0
      || (*(_WORD *)((v2 & 0xFFFFFFFF8) + 0x1E) & 1) != 0)
    {
      a1 = (unint64_t)objc_destructInstance((id)a1);
    }
    free((void *)a1);
  }
}

void *__cdecl objc_destructInstance(id obj)
{
  if (obj)
  {
    uint64_t v4 = (objc_class *)(*(void *)obj & 0xFFFFFFFF8);
    uint64_t v5 = (*(void *)obj >> 1) & 1;
    if ((*(void *)obj & 1) == 0) {
      LODWORD(v5) = 1;
    }
    if ((uint64_t)obj >= 0) {
      int v6 = v5;
    }
    else {
      int v6 = 1;
    }
    if ((*((_WORD *)v4 + 15) & 1) != 0 && (uint64_t)obj >= 1) {
      object_cxxDestructFromClass((void (*)(void))obj, v4);
    }
    if (v6) {
      _object_remove_associations((uint64_t)obj, 1);
    }
    if (*(void *)obj)
    {
      if ((*(void *)obj & 0x80000000000004) != 0) {
        objc_object::clearDeallocating_slow((objc_object *)obj, (uint64_t)v4, v1, v2);
      }
    }
    else
    {
      objc_object::sidetable_clearDeallocating((objc_object *)obj);
    }
  }
  return obj;
}

void _object_remove_associations(uint64_t a1, int a2)
{
  int v4 = 0;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  unsigned int v43 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(&AssociationsManagerLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v4) {
    os_unfair_lock_lock_with_options();
  }
  int v6 = (void *)objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::find(-a1);
  if ((void *)(objc::AssociationsManager::_mapStorage + 32 * dword_1EB1CAC58) == v6) {
    goto LABEL_37;
  }
  objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::swap((uint64_t *)&v41, v6 + 1);
  if (a2)
  {
LABEL_36:
    objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::erase(v6);
    goto LABEL_37;
  }
  if (v42)
  {
    if (v41) {
      uint64_t v7 = (uint64_t)v41;
    }
    else {
      uint64_t v7 = 0;
    }
    unsigned int v10 = v43;
    if (v43)
    {
      uint64_t v11 = v7 + 24 * v43;
      uint64_t v12 = 24 * v43;
      while (*(void *)v7 >= 0xFFFFFFFFFFFFFFFELL)
      {
        v7 += 24;
        v12 -= 24;
        if (!v12)
        {
          uint64_t v7 = v11;
          if (v41) {
            goto LABEL_19;
          }
          goto LABEL_22;
        }
      }
    }
    else
    {
      uint64_t v11 = v7;
    }
    if (v41) {
      goto LABEL_19;
    }
LABEL_22:
    uint64_t v13 = 0;
    goto LABEL_23;
  }
  if (v41)
  {
    uint64_t v8 = (uint64_t)v41;
    unsigned int v9 = v43;
    uint64_t v7 = (uint64_t)v41 + 24 * v43;
  }
  else
  {
    uint64_t v8 = 0;
    unsigned int v9 = v43;
    uint64_t v7 = 24 * v43;
  }
  unsigned int v10 = v9;
  uint64_t v11 = v8 + 24 * v9;
  if (!v41) {
    goto LABEL_22;
  }
LABEL_19:
  uint64_t v13 = (uint64_t)v41;
LABEL_23:
  uint64_t v14 = v13 + 24 * v10;
  if (v7 == v14) {
    goto LABEL_36;
  }
  char v15 = 0;
  do
  {
    if (*(unsigned char *)(v7 + 10))
    {
      uint64_t v39 = 0;
      if ((objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::LookupBucketFor<void const*>((uint64_t)(v6 + 1), *(void *)v7, &v39) & 1) == 0)
      {
        inserted = objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::InsertIntoBucketImpl<void const*>((int32x2_t *)v6 + 1, (unint64_t *)v7, v39);
        void *inserted = *(void *)v7;
        *(_OWORD *)(inserted + 1) = *(_OWORD *)(v7 + 8);
      }
      char v15 = 1;
    }
    uint64_t v17 = v7 + 24;
    uint64_t v7 = v11;
    if (v17 != v11)
    {
      uint64_t v7 = v17;
      while (*(void *)v7 >= 0xFFFFFFFFFFFFFFFELL)
      {
        v7 += 24;
        if (v7 == v11)
        {
          uint64_t v7 = v11;
          break;
        }
      }
    }
  }
  while (v7 != v14);
  if ((v15 & 1) == 0) {
    goto LABEL_36;
  }
LABEL_37:
  int v18 = *(_DWORD *)(StatusReg + 24);
  int v19 = v18;
  atomic_compare_exchange_strong_explicit(&AssociationsManagerLock, (unsigned int *)&v19, 0, memory_order_release, memory_order_relaxed);
  if (v19 != v18) {
    os_unfair_lock_unlock((os_unfair_lock_t)&AssociationsManagerLock);
  }
  LODWORD(v39) = 0;
  ptr[0] = 0;
  if (v42)
  {
    if (v41) {
      uint64_t v20 = (uint64_t)v41;
    }
    else {
      uint64_t v20 = 0;
    }
    unsigned int v23 = v43;
    if (v43)
    {
      uint64_t v24 = v20 + 24 * v43;
      uint64_t v25 = 24 * v43;
      while (*(void *)v20 >= 0xFFFFFFFFFFFFFFFELL)
      {
        v20 += 24;
        v25 -= 24;
        if (!v25)
        {
          uint64_t v20 = v24;
          if (v41) {
            goto LABEL_53;
          }
          goto LABEL_56;
        }
      }
    }
    else
    {
      uint64_t v24 = v20;
    }
    if (v41) {
      goto LABEL_53;
    }
  }
  else
  {
    if (v41)
    {
      uint64_t v21 = (uint64_t)v41;
      unsigned int v22 = v43;
      uint64_t v20 = (uint64_t)v41 + 24 * v43;
    }
    else
    {
      uint64_t v21 = 0;
      unsigned int v22 = v43;
      uint64_t v20 = 24 * v43;
    }
    unsigned int v23 = v22;
    uint64_t v24 = v21 + 24 * v22;
    if (v41)
    {
LABEL_53:
      uint64_t v26 = (uint64_t)v41;
      goto LABEL_57;
    }
  }
LABEL_56:
  uint64_t v26 = 0;
LABEL_57:
  uint64_t v27 = v26 + 24 * v23;
  if (v20 == v27) {
    goto LABEL_89;
  }
  unsigned int v28 = 0;
  uint64_t v29 = ptr;
  do
  {
    uint64_t v31 = (void *)(v20 + 8);
    uint64_t v30 = *(void *)(v20 + 8);
    if ((v30 & 0x10000) != 0)
    {
      if (a2)
      {
        if (v28 > 3)
        {
          if (v28 == 4)
          {
            uint64_t v33 = malloc_type_malloc(0x28uLL, 0x2004093837F09uLL);
            for (uint64_t i = 0; i != 4; ++i)
              v33[i] = ptr[i];
            v33[4] = v31;
            ptr[0] = v33;
          }
          else
          {
            ptr[0] = malloc_type_realloc(ptr[0], 8 * (v28 + 1), 0x2004093837F09uLL);
            *((void *)ptr[0] + v28) = v31;
          }
        }
        else
        {
          ptr[v28] = v31;
        }
        LODWORD(v39) = ++v28;
      }
    }
    else if (v30)
    {
      uint64_t v32 = *(void **)(v20 + 16);
      if (v32) {
    }
      }
    uint64_t v35 = v20 + 24;
    uint64_t v20 = v24;
    if (v35 != v24)
    {
      uint64_t v20 = v35;
      while (*(void *)v20 >= 0xFFFFFFFFFFFFFFFELL)
      {
        v20 += 24;
        if (v20 == v24)
        {
          uint64_t v20 = v24;
          break;
        }
      }
    }
  }
  while (v20 != v27);
  if (v28 >= 5)
  {
    uint64_t v29 = (void **)ptr[0];
  }
  else if (!v28)
  {
    goto LABEL_89;
  }
  v36 = &v29[v28];
  do
  {
    uint64_t v37 = (void *)*((void *)*v29 + 1);
    if (v37 && (*(unsigned char *)*v29 & 1) != 0) {

    }
    ++v29;
  }
  while (v29 != v36);
  if (v39 >= 5) {
    free(ptr[0]);
  }
LABEL_89:
  if (v41) {
    int v38 = v41;
  }
  else {
    int v38 = 0;
  }
  free(v38);
}

void sub_18010D520(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  int v17 = *(_DWORD *)(v15 + 24);
  int v18 = v17;
  atomic_compare_exchange_strong_explicit(v14, (unsigned int *)&v18, 0, memory_order_release, memory_order_relaxed);
  if (v18 != v17) {
    os_unfair_lock_unlock((os_unfair_lock_t)&AssociationsManagerLock);
  }
  if (a14) {
    int v19 = a14;
  }
  else {
    int v19 = 0;
  }
  free(v19);
  _Unwind_Resume(a1);
}

uint64_t objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::find(uint64_t a1)
{
  uint64_t v2 = 0;
  if (objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::LookupBucketFor<DisguisedPtr<objc_object>>(a1, &v2))return v2; {
  if (objc::AssociationsManager::_mapStorage)
  }
    return objc::AssociationsManager::_mapStorage + 32 * dword_1EB1CAC58;
  return 32 * dword_1EB1CAC58;
}

uint64_t objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::LookupBucketFor<DisguisedPtr<objc_object>>(uint64_t a1, void *a2)
{
  if (dword_1EB1CAC58)
  {
    uint64_t v2 = -a1;
    unint64_t v3 = 0x8A970BE7488FDA55 * (-a1 ^ ((unint64_t)-a1 >> 4));
    uint64_t v4 = (dword_1EB1CAC58 - 1) & (bswap64(v3) ^ v3);
    uint64_t v5 = (void *)(objc::AssociationsManager::_mapStorage + 32 * v4);
    if (a1 == *v5)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v7 = 0;
      uint64_t v8 = -*v5;
      unsigned int v9 = 1;
      uint64_t result = 1;
      while (v8 != -1)
      {
        if (v9 > dword_1EB1CAC58) {
          objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::FatalCorruptHashTables((void *)objc::AssociationsManager::_mapStorage, dword_1EB1CAC58);
        }
        if (v7) {
          BOOL v10 = 0;
        }
        else {
          BOOL v10 = v8 == -2;
        }
        if (v10) {
          uint64_t v7 = v5;
        }
        int v11 = v4 + v9++;
        uint64_t v4 = v11 & (dword_1EB1CAC58 - 1);
        uint64_t v5 = (void *)(objc::AssociationsManager::_mapStorage + 32 * v4);
        uint64_t v8 = -*v5;
        if (!(v2 + *v5)) {
          goto LABEL_5;
        }
      }
      uint64_t result = 0;
      if (v7) {
        uint64_t v5 = v7;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_5:
  *a2 = v5;
  return result;
}

uint64_t protocol_conformsToProtocol_nolock(protocol_t *a1, const char **a2)
{
  uint64_t result = 0;
  if (a1 && a2)
  {
    if (strcmp(*((const char **)a1 + 1), a2[1]))
    {
      uint64_t v5 = (unint64_t *)*((void *)a1 + 2);
      if (!v5 || !*v5) {
        return 0;
      }
      unint64_t v6 = 0;
      while (1)
      {
        uint64_t v7 = v5[v6 + 1];
        int v8 = canonical_protocol ? 0 : 0x20000000;
        if ((v8 & *(_DWORD *)(v7 + 68)) == 0)
        {
          uint64_t Protocol = getProtocol(*(const char **)(v7 + 8));
          if (Protocol) {
            uint64_t v7 = Protocol;
          }
        }
        if ((const char **)v7 == a2
          || !strcmp(a2[1], *(const char **)(v7 + 8))
          || protocol_conformsToProtocol_nolock((protocol_t *)v7, (protocol_t *)a2))
        {
          break;
        }
        ++v6;
        uint64_t v5 = (unint64_t *)*((void *)a1 + 2);
        if (v6 >= *v5) {
          return 0;
        }
      }
    }
    return 1;
  }
  return result;
}

void objc_object::sidetable_clearDeallocating(objc_object *this)
{
  int v2 = 0;
                                           * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(v3, (unsigned int *)&v2, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v2) {
    os_unfair_lock_lock_with_options();
  }
  int v8 = (void *)v5;
  if (*((void *)v3 + 1) + 16 * v3[6] != v5)
  {
    if (*(unsigned char *)(v5 + 8)) {
      weak_clear_no_lock((void *)v3 + 4, this, v6, v7);
    }
    *int v8 = 2;
    *((int32x2_t *)v3 + 2) = vadd_s32(*(int32x2_t *)(v3 + 4), (int32x2_t)0x1FFFFFFFFLL);
  }
  int v9 = *(_DWORD *)(StatusReg + 24);
  int v10 = v9;
  atomic_compare_exchange_strong_explicit(v3, (unsigned int *)&v10, 0, memory_order_release, memory_order_relaxed);
  if (v10 != v9)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)v3);
  }
}

uint64_t objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object const>,unsigned long,anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>,DisguisedPtr<objc_object const>,unsigned long,anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>::find(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0;
  else {
    return *(void *)a1 + 16 * *(unsigned int *)(a1 + 16);
  }
}

uint64_t objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object const>,unsigned long,anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>,DisguisedPtr<objc_object const>,unsigned long,anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>::LookupBucketFor<DisguisedPtr<objc_object const>>(uint64_t a1, uint64_t a2, void *a3)
{
  unint64_t v3 = *(void **)a1;
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    uint64_t v5 = -a2;
    unint64_t v6 = 0x8A970BE7488FDA55 * (-a2 ^ ((unint64_t)-a2 >> 4));
    unsigned int v7 = v4 - 1;
    unsigned int v8 = (v4 - 1) & (bswap64(v6) ^ v6);
    int v9 = &v3[2 * v8];
    if (a2 == *v9)
    {
      uint64_t v10 = 1;
    }
    else
    {
      unint64_t v12 = 0;
      uint64_t v13 = -*v9;
      unsigned int v14 = 1;
      while (v13 != -1)
      {
        if (v14 > v4) {
          objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::FatalCorruptHashTables(a1, v3, *(unsigned int *)(a1 + 16));
        }
        if (v12) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v13 == -2;
        }
        if (v15) {
          unint64_t v12 = (unint64_t)v9;
        }
        if (!(v9[1] | v12)) {
          unint64_t v12 = (unint64_t)v9;
        }
        unsigned int v16 = v8 + v14++;
        unsigned int v8 = v16 & v7;
        int v9 = &v3[2 * (v16 & v7)];
        uint64_t v13 = -*v9;
        uint64_t v10 = 1;
        if (!(v5 + *v9)) {
          goto LABEL_5;
        }
      }
      uint64_t v10 = 0;
      if (v12) {
        int v9 = (void *)v12;
      }
    }
  }
  else
  {
    int v9 = 0;
    uint64_t v10 = 0;
  }
LABEL_5:
  *a3 = v9;
  return v10;
}

void (*object_cxxDestructFromClass(void (*result)(void), objc_class *a2))(void)
{
  if (a2)
  {
    int v2 = a2;
    unint64_t v3 = result;
    while ((*((_WORD *)v2 + 15) & 1) != 0)
    {
      uint64_t result = lookupMethodInClassAndLoadCache((uint64_t)v2, (objc_selector *)SEL_cxx_destruct);
      if (result != _objc_msgForward_impcache)
      {
        unsigned int v4 = result;
        if (PrintCxxCtors)
        {
          uint64_t v5 = objc_class::nameForLogging(v2);
          _objc_inform("CXX: calling C++ destructors for class %s", v5);
        }
        uint64_t result = (void (*)(void))((uint64_t (*)(void (*)(void)))v4)(v3);
      }
      if (!*((void *)v2 + 1)) {
        break;
      }
      int v2 = (objc_class *)*((void *)v2 + 1);
    }
  }
  return result;
}

void (*lookupMethodInClassAndLoadCache(uint64_t a1, objc_selector *a2))(void)
{
  Imp = (void (*)(void))cache_getImp(a1, (unint64_t)a2, (uint64_t)_objc_msgForward_impcache);
  if (!Imp)
  {
    unsigned int v7 = (const char *)a1;
    int v8 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v8, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v8) {
      os_unfair_lock_lock_with_options();
    }
    unint64_t MethodNoSuper_nolock = getMethodNoSuper_nolock((objc_class *)a1, a2, v7, v4);
    if (MethodNoSuper_nolock) {
      Imp = (void (*)(void))method_t::imp(MethodNoSuper_nolock, 0);
    }
    else {
      Imp = _objc_msgForward_impcache;
    }
    if ((*(void *)(a1 + 16) & 1) == 0) {
      cache_t::insert((cache_t *)(a1 + 16), a2, Imp, 0);
    }
    int v11 = *(_DWORD *)(StatusReg + 24);
    int v12 = v11;
    atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v12, 0, memory_order_release, memory_order_relaxed);
    if (v12 != v11) {
      os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
    }
  }
  return Imp;
}

void sub_18010DD1C(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void (*lookUpImpOrForward(objc_object *a1, objc_selector *a2, void *a3, unsigned int a4))(void)
{
  unsigned int v7 = a3 + 4;
  int v8 = *(_DWORD *)(a3[4] & 0xF00007FFFFFFFF8);
  if ((v8 & 1) == 0) {
    int v8 = *(_DWORD *)(*(void *)((*a3 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  }
  int v9 = 0;
  if ((v8 & 0x20000000) != 0) {
    unsigned int v10 = a4;
  }
  else {
    unsigned int v10 = a4 | 8;
  }
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v9, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v9) {
    os_unfair_lock_lock_with_options();
  }
  if ((unint64_t)(*a3 - 1) < 0xF
    || (*(_DWORD *)(*v7 & 0xF00007FFFFFFFF8) & 0x80000000) == 0
    || (uint64_t v12 = *(unsigned __int16 *)((*v7 & 0xF00007FFFFFFFF8) + 4), dword_1EB1CB088 <= v12)
    || (*(void *)(qword_1EB1CB080 + 16 * v12) <= (unint64_t)a3
      ? (BOOL v13 = *(void *)(qword_1EB1CB080 + 16 * v12 + 8) > (unint64_t)a3)
      : (BOOL v13 = 0),
        !v13))
  {
    if (objc::allocatedClasses + 8 * qword_1EB1CAEA0 == objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::find((unint64_t)a3)
      && (dataSegmentsContain((objc_class *)a3, v34, v35) & 1) == 0)
    {
      _objc_fatal("Attempt to use unknown class %p.", v36, v37, v38, a3);
    }
  }
  Class v14 = realizeAndInitializeIfNeeded_locked(a1, (objc_class *)a3, v10 & 1);
  Class v17 = v14;
  int v18 = (void (*)(void))_objc_returnNil;
  if (!v14 || (int v18 = (void (*)(void))_objc_returnNil, (*(void *)v14 & 0xFFFFFFFF8) == 0))
  {
LABEL_33:
    uint64_t v30 = v18;
LABEL_34:
    if ((v10 & 8) == 0)
    {
LABEL_39:
      while ((*((void *)v17 + 2) & 1) != 0)
        Class v17 = (Class)((char *)v17 + *(void *)((*((void *)v17 + 2) & 0x7FFFFFFFFFFFFELL) - 16));
      if (msgSendCacheMissHook) {
        ((void (*)(Class, objc_object *, objc_selector *, void (*)(void)))atomic_load_explicit(&msgSendCacheMissHook, memory_order_acquire))(v17, a1, a2, v30);
      }
      cache_t::insert((Class)((char *)v17 + 16), a2, v30, a1);
    }
    goto LABEL_43;
  }
  int v19 = *(_DWORD *)(gdb_objc_realized_classes + 8);
  if (DisablePreopt) {
    int v20 = 0;
  }
  else {
    int v20 = _dyld_objc_class_count();
  }
  int v21 = 16 * ~(v20 + v19);
  unsigned int v22 = v17;
  while ((*((void *)v22 + 2) & 1) != 0)
  {
    uint64_t Imp = cache_getImp((uint64_t)v22, (unint64_t)a2, 0);
    if (Imp)
    {
      uint64_t v30 = (void (*)(void))Imp;
      goto LABEL_43;
    }
    unsigned int v22 = (objc_class *)((char *)v22 + *(void *)((*((void *)v22 + 2) & 0x7FFFFFFFFFFFFELL) - 16));
LABEL_28:
    if (__CFADD__(v21++, 1)) {
      _objc_fatal("Memory corruption in class list.", v24, v25, v26);
    }
    uint64_t v29 = (void (*)(void))cache_getImp((uint64_t)v22, (unint64_t)a2, 0);
    if (v29 == _objc_msgForward_impcache)
    {
LABEL_32:
      int v18 = _objc_msgForward_impcache;
      if ((v10 & 2) == 0) {
        goto LABEL_33;
      }
      return resolveMethod_locked(a1, a2, v17, v10 ^ 2);
    }
    uint64_t v30 = v29;
    if (v29) {
      goto LABEL_34;
    }
  }
  unint64_t MethodNoSuper_nolock = getMethodNoSuper_nolock(v22, a2, v15, v16);
  if (!MethodNoSuper_nolock)
  {
    if (!*((void *)v22 + 1)) {
      goto LABEL_32;
    }
    unsigned int v22 = (objc_class *)*((void *)v22 + 1);
    goto LABEL_28;
  }
  uint64_t v30 = (void (*)(void))method_t::imp(MethodNoSuper_nolock, 0);
  if ((v10 & 8) == 0) {
    goto LABEL_39;
  }
LABEL_43:
  int v31 = *(_DWORD *)(StatusReg + 24);
  int v32 = v31;
  atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v32, 0, memory_order_release, memory_order_relaxed);
  if (v32 != v31) {
    os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
  }
  if (((v30 == _objc_msgForward_impcache) & (v10 >> 2)) != 0) {
    return 0;
  }
  else {
    return v30;
  }
}

unint64_t getMethodNoSuper_nolock(objc_class *a1, objc_selector *a2, const char *a3, char *a4)
{
  uint64_t v4 = *(void *)((*((void *)a1 + 4) & 0xF00007FFFFFFFF8) + 8);
  if ((v4 & 1) == 0)
  {
    if (v4) {
      unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    }
    else {
      unint64_t v5 = 0;
    }
    uint64_t v12 = *(void *)(v5 + 32);
    if (v12) {
      BOOL v13 = (*(void *)(v5 + 32) & 1) == 0;
    }
    else {
      BOOL v13 = 0;
    }
    if (!v13)
    {
      if ((v12 & 1) == 0) {
        return 0;
      }
      unint64_t result = v12 & 0xFFFFFFFFFFFFFFFELL;
      if ((v12 & 0xFFFFFFFFFFFFFFFELL) == 0) {
        return result;
      }
LABEL_33:
      return getMethodFromRelativeList((unsigned int *)result, a2, a3, a4);
    }
    unint64_t result = v12 & 0xFFFFFFFFFFFFFFFELL;
    if ((v12 & 0xFFFFFFFFFFFFFFFELL) == 0) {
      return result;
    }
LABEL_29:
    return getMethodFromListArray<method_list_t **>(result, a2, a3, a4);
  }
  uint64_t v6 = *(void *)((v4 & 0xFFFFFFFFFFFFFFFELL) + 8);
  if (!v6) {
    return 0;
  }
  unsigned int v7 = (unsigned int *)(v6 & 0xFFFFFFFFFFFFFFFCLL);
  uint64_t v8 = v6 & 3;
  if ((v6 & 3) != 0) {
    unint64_t result = 0;
  }
  else {
    unint64_t result = v6 & 0xFFFFFFFFFFFFFFFCLL;
  }
  if (v8 == 2) {
    unint64_t v10 = v6 & 0xFFFFFFFFFFFFFFFCLL;
  }
  else {
    unint64_t v10 = 0;
  }
  if (v8 != 1 || v7 == 0)
  {
    if (result) {
      goto LABEL_29;
    }
    if (v10)
    {
      unint64_t result = v10;
      goto LABEL_33;
    }
    return 0;
  }
  if (result) {
    goto LABEL_29;
  }
  unsigned int v16 = *v7;
  BOOL v15 = v7 + 2;
  uint64_t v14 = v16;
  if (!v16) {
    return 0;
  }
  uint64_t v17 = 0;
  unint64_t v18 = a2 - (objc_selector *)&unk_1F62995A8;
  while (1)
  {
    unint64_t v19 = *(void *)&v15[2 * v17];
    unint64_t v20 = *(unsigned int *)v19;
    BOOL v21 = (int)v20 > -1 || (v19 & 0x8000000000000000) != 0;
    uint64_t v22 = v21 ? 24 : 12;
    uint64_t v23 = (unsigned __int16)v20 & 0xFFFC;
    if ((~v20 & 3) == 0 && v23 == v22) {
      break;
    }
    if ((v19 & 0x8000000000000000) != 0)
    {
      uint64_t v74 = *(unsigned int *)(v19 + 4);
      unint64_t v78 = v74 * (unint64_t)v23;
      if ((v78 & 0xFFFFFFFF00000000) == 0)
      {
        unint64_t v79 = v19 + 8;
        unint64_t result = v79 & 0xFFFFFFFFFFFFFFFCLL | 2;
        unint64_t v80 = (v79 + v78) & 0xFFFFFFFFFFFFFFFCLL | 2;
        if (result == v80) {
          goto LABEL_144;
        }
        while (*(objc_selector **)(result & 0xFFFFFFFFFFFFFFFCLL) != a2)
        {
          result += v23;
          if (result == v80) {
            goto LABEL_144;
          }
        }
        goto LABEL_143;
      }
      goto LABEL_174;
    }
    if ((v20 & 0x80000000) == 0)
    {
      uint64_t v74 = *(unsigned int *)(v19 + 4);
      unint64_t v75 = v74 * (unint64_t)v23;
      if ((v75 & 0xFFFFFFFF00000000) == 0)
      {
        unint64_t v76 = v19 + 8;
        unint64_t result = v76 & 0xFFFFFFFFFFFFFFFCLL;
        unint64_t v77 = (v76 + v75) & 0xFFFFFFFFFFFFFFFCLL;
        if (result == v77) {
          goto LABEL_144;
        }
        while (*(objc_selector **)(result & 0xFFFFFFFFFFFFFFFCLL) != a2)
        {
          result += v23;
          if (result == v77) {
            goto LABEL_144;
          }
        }
        goto LABEL_143;
      }
      goto LABEL_174;
    }
    if (dataSegmentsRanges > v19 || *(void *)algn_1EB1CB078 <= v19)
    {
      uint64_t v74 = *(unsigned int *)(v19 + 4);
      unint64_t v84 = v74 * (unint64_t)v23;
      if ((v84 & 0xFFFFFFFF00000000) == 0)
      {
        unint64_t v85 = v19 + 8;
        unint64_t result = v85 & 0xFFFFFFFFFFFFFFFCLL | 1;
        unint64_t v86 = (v85 + v84) & 0xFFFFFFFFFFFFFFFCLL | 1;
        if (result == v86) {
          goto LABEL_144;
        }
        while (*(objc_selector **)((result & 0xFFFFFFFFFFFFFFFCLL) + *(int *)(result & 0xFFFFFFFFFFFFFFFCLL)) != a2)
        {
          result += v23;
          if (result == v86) {
            goto LABEL_144;
          }
        }
        goto LABEL_143;
      }
LABEL_174:
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, (const char *)dataSegmentsRanges, *(char **)algn_1EB1CB078, v74, v19, v23);
    }
    if (dataSegmentsRanges <= (unint64_t)a2 && *(void *)algn_1EB1CB078 > (unint64_t)a2)
    {
      uint64_t v74 = *(unsigned int *)(v19 + 4);
      unint64_t v81 = v74 * (unint64_t)v23;
      if ((v81 & 0xFFFFFFFF00000000) != 0) {
        goto LABEL_174;
      }
      unint64_t v82 = v19 + 8;
      unint64_t result = v82 & 0xFFFFFFFFFFFFFFFCLL | 1;
      unint64_t v83 = (v82 + v81) & 0xFFFFFFFFFFFFFFFCLL | 1;
      while (result != v83)
      {
        if ((objc_selector *)((char *)&unk_1F62995A8 + *(int *)(result & 0xFFFFFFFFFFFFFFFCLL)) == a2) {
          goto LABEL_143;
        }
        result += v23;
      }
    }
LABEL_144:
    unint64_t result = 0;
    if (++v17 == v14) {
      return result;
    }
  }
  if ((v19 & 0x8000000000000000) != 0)
  {
    unint64_t v33 = (v19 + 8) & 0xFFFFFFFFFFFFFFFCLL | 2;
    unsigned int v34 = *(_DWORD *)(v19 + 4);
    if (v34 < 5)
    {
      unint64_t v35 = (v19 + 8) & 0xFFFFFFFFFFFFFFFCLL | 2;
      if (!v34) {
        goto LABEL_144;
      }
    }
    else
    {
      unint64_t v35 = (v19 + 8) & 0xFFFFFFFFFFFFFFFCLL | 2;
      do
      {
        unint64_t result = v35 + v22 * (unint64_t)(v34 >> 1);
        uint64_t v36 = *(objc_selector **)(result & 0xFFFFFFFFFFFFFFFCLL);
        BOOL v37 = v36 >= a2;
        if (v36 == a2)
        {
          if (result > v33)
          {
            uint64_t v56 = 0;
            while (*(objc_selector **)((v35 + (int)v22 * (uint64_t)(int)((v34 >> 1) - 1) + v56) & 0xFFFFFFFFFFFFFFFCLL) == a2)
            {
              v56 -= v22;
              if (result + v56 <= v33) {
                return v35 + (v34 >> 1) * (unint64_t)v22 + v56;
              }
            }
            result += v56;
          }
          goto LABEL_143;
        }
        BOOL v38 = v36 < a2;
        if (!v37) {
          unint64_t v35 = result + v22;
        }
        unsigned int v39 = v34 - v38;
        unsigned int v34 = v39 >> 1;
      }
      while (v39 > 9);
      if (!v34) {
        goto LABEL_144;
      }
    }
    uint64_t v40 = 0;
    unsigned int v41 = v34 - 1;
    while (1)
    {
      unsigned int v42 = v41;
      unsigned int v43 = *(objc_selector **)((v35 + v40) & 0xFFFFFFFFFFFFFFFCLL);
      if (v43 == a2) {
        break;
      }
      if (v43 <= a2)
      {
        unsigned int v41 = v42 - 1;
        v40 += v22;
        if (v42) {
          continue;
        }
      }
      goto LABEL_144;
    }
    unint64_t result = v35 + v40;
    goto LABEL_143;
  }
  if ((v20 & 0x80000000) == 0)
  {
    unint64_t v25 = (v19 + 8) & 0xFFFFFFFFFFFFFFFCLL;
    unsigned int v26 = *(_DWORD *)(v19 + 4);
    if (v26 < 5)
    {
      unint64_t v27 = (v19 + 8) & 0xFFFFFFFFFFFFFFFCLL;
      if (!v26) {
        goto LABEL_144;
      }
    }
    else
    {
      unint64_t v27 = (v19 + 8) & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        unint64_t result = v27 + 24 * (v26 >> 1);
        unsigned int v28 = *(objc_selector **)(result & 0xFFFFFFFFFFFFFFFCLL);
        BOOL v29 = v28 >= a2;
        if (v28 == a2)
        {
          if (result > v25)
          {
            for (uint64_t i = v27 + 24 * (v26 >> 1) - 24; *(objc_selector **)(i & 0xFFFFFFFFFFFFFFFCLL) == a2; i -= 24)
            {
              result -= 24;
              if (result <= v25) {
                return result;
              }
            }
          }
          goto LABEL_143;
        }
        BOOL v30 = v28 < a2;
        unint64_t v31 = result + 24;
        if (!v29) {
          unint64_t v27 = v31;
        }
        unsigned int v32 = v26 - v30;
        unsigned int v26 = (v26 - v30) >> 1;
      }
      while (v32 > 9);
      if (!v26) {
        goto LABEL_144;
      }
    }
    uint64_t v52 = 0;
    unsigned int v53 = v26 - 1;
    while (1)
    {
      unint64_t result = v27 + v52;
      v54 = *(objc_selector **)((v27 + v52) & 0xFFFFFFFFFFFFFFFCLL);
      if (v54 == a2) {
        goto LABEL_143;
      }
      BOOL v55 = v54 > a2 || v53-- == 0;
      v52 += v22;
      if (v55) {
        goto LABEL_144;
      }
    }
  }
  if (dataSegmentsRanges <= v19 && *(void *)algn_1EB1CB078 > v19)
  {
    if (dataSegmentsRanges <= (unint64_t)a2 && *(void *)algn_1EB1CB078 > (unint64_t)a2)
    {
      unint64_t v44 = (v19 + 8) & 0xFFFFFFFFFFFFFFFCLL | (v20 >> 31);
      LODWORD(v45) = *(_DWORD *)(v19 + 4);
      if (v45 < 5)
      {
        unint64_t v46 = (v19 + 8) & 0xFFFFFFFFFFFFFFFCLL | (v20 >> 31);
LABEL_128:
        if (!v45) {
          goto LABEL_144;
        }
        uint64_t v70 = 0;
        int v71 = v45 - 1;
        while (1)
        {
          unint64_t result = v46 + v70;
          unint64_t v72 = *(int *)((v46 + v70) & 0xFFFFFFFFFFFFFFFCLL);
          if (v18 == v72) {
            break;
          }
          BOOL v73 = v18 < v72 || v71-- == 0;
          v70 += v22;
          if (v73) {
            goto LABEL_144;
          }
        }
      }
      else
      {
        unint64_t v46 = (v19 + 8) & 0xFFFFFFFFFFFFFFFCLL | (v20 >> 31);
        while (1)
        {
          unint64_t result = v46 + v22 * (unint64_t)(v45 >> 1);
          unint64_t v47 = *(int *)(result & 0xFFFFFFFFFFFFFFFCLL);
          BOOL v48 = v18 > v47;
          if (v18 == v47) {
            break;
          }
          BOOL v49 = v18 > v47;
          unint64_t v50 = result + v22;
          if (v48) {
            unint64_t v46 = v50;
          }
          unsigned int v51 = v45 - v49;
          LODWORD(v45) = (v45 - v49) >> 1;
          if (v51 <= 9) {
            goto LABEL_128;
          }
        }
        if (result > v44)
        {
          uint64_t v68 = 0;
          unint64_t v45 = v45;
          while (v18 == *(_DWORD *)((v46 + (int)v22 * (uint64_t)(int)((v45 >> 1) - 1) + v68) & 0xFFFFFFFFFFFFFFFCLL))
          {
            v68 -= v22;
            if (result + v68 <= v44) {
              return v46 + (v45 >> 1) * (unint64_t)v22 + v68;
            }
          }
          goto LABEL_142;
        }
      }
      goto LABEL_143;
    }
    goto LABEL_144;
  }
  unint64_t v57 = (v19 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
  LODWORD(v45) = *(_DWORD *)(v19 + 4);
  if (v45 < 5)
  {
    unint64_t v46 = (v19 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
LABEL_112:
    if (!v45) {
      goto LABEL_144;
    }
    uint64_t v64 = 0;
    int v65 = v45 - 1;
    while (1)
    {
      unint64_t result = v46 + v64;
      v66 = *(objc_selector **)(((v46 + v64) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v46 + v64) & 0xFFFFFFFFFFFFFFFCLL));
      if (v66 == a2) {
        break;
      }
      BOOL v67 = v66 > a2 || v65-- == 0;
      v64 += v22;
      if (v67) {
        goto LABEL_144;
      }
    }
  }
  else
  {
    unint64_t v46 = (v19 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
    while (1)
    {
      unint64_t result = v46 + v22 * (unint64_t)(v45 >> 1);
      v58 = *(objc_selector **)((result & 0xFFFFFFFFFFFFFFFCLL) + *(int *)(result & 0xFFFFFFFFFFFFFFFCLL));
      BOOL v59 = v58 >= a2;
      if (v58 == a2) {
        break;
      }
      BOOL v60 = v58 < a2;
      unint64_t v61 = result + v22;
      if (!v59) {
        unint64_t v46 = v61;
      }
      unsigned int v62 = v45 - v60;
      LODWORD(v45) = (v45 - v60) >> 1;
      if (v62 <= 9) {
        goto LABEL_112;
      }
    }
    if (result > v57)
    {
      uint64_t v68 = 0;
      unint64_t v45 = v45;
      while (1)
      {
        unint64_t v69 = v46 + (int)v22 * (uint64_t)(int)((v45 >> 1) - 1);
        if (*(objc_selector **)(((v69 + v68) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v69 + v68) & 0xFFFFFFFFFFFFFFFCLL)) != a2) {
          break;
        }
        v68 -= v22;
        if (result + v68 <= v57) {
          return v46 + (v45 >> 1) * (unint64_t)v22 + v68;
        }
      }
LABEL_142:
      result += v68;
    }
  }
LABEL_143:
  if (!result) {
    goto LABEL_144;
  }
  return result;
}

BOOL class_respondsToSelector_inst(objc_object *a1, objc_selector *a2, void *a3)
{
  BOOL result = 0;
  if (a2 && a3)
  {
    int v7 = *(_DWORD *)(a3[4] & 0xF00007FFFFFFFF8);
    if ((v7 & 1) == 0) {
      int v7 = *(_DWORD *)(*(void *)((*a3 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    }
    if ((v7 & 0x20000000) != 0
      && ((uint64_t Imp = (void (*)(void))cache_getImp((uint64_t)a3, (unint64_t)a2, 0)) != 0
       || (a3[2] & 1) != 0
       && (uint64_t Imp = (void (*)(void))cache_getImp((uint64_t)a3 + *(void *)((a3[2] & 0x7FFFFFFFFFFFFELL) - 16), (unint64_t)a2, 0)) != 0))
    {
      if (Imp == _objc_msgForward_impcache) {
        uint64_t Imp = 0;
      }
    }
    else
    {
      uint64_t Imp = lookUpImpOrForward(a1, a2, a3, 6u);
    }
    return Imp != 0;
  }
  return result;
}

unint64_t object_getMethodImplementation(unint64_t result, objc_selector *a2)
{
  if (!result) {
    return result;
  }
  if ((result & 0x8000000000000000) == 0)
  {
    uint64_t v3 = *(void *)result & 0x7FFFFFFFFFFFF8;
    if (v3) {
      goto LABEL_4;
    }
    return 0;
  }
  uint64_t v6 = (__objc2_class *)objc_debug_taggedpointer_classes[result & 7];
  if (!v6) {
    return 0;
  }
  uint64_t v4 = objc_debug_taggedpointer_classes[result & 7];
  if (v6 != __NSUnrecognizedTaggedPointer) {
    goto LABEL_5;
  }
  uint64_t v3 = objc_debug_taggedpointer_ext_classes[(result >> 55)];
  if (!v3) {
    return 0;
  }
LABEL_4:
  uint64_t v4 = (void *)v3;
LABEL_5:
  BOOL result = 0;
  if (a2 && v4)
  {
    int v5 = *(_DWORD *)(v4[4] & 0xF00007FFFFFFFF8);
    if ((v5 & 1) == 0) {
      int v5 = *(_DWORD *)(*(void *)((*v4 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    }
    if ((v5 & 0x20000000) != 0
      && ((BOOL result = cache_getImp((uint64_t)v4, (unint64_t)a2, 0)) != 0
       || (v4[2] & 1) != 0
       && (BOOL result = cache_getImp((uint64_t)v4 + *(void *)((v4[2] & 0x7FFFFFFFFFFFFELL) - 16), (unint64_t)a2, 0)) != 0))
    {
      if ((void (*)(void))result == _objc_msgForward_impcache) {
        BOOL result = 0;
      }
    }
    else
    {
      BOOL result = (unint64_t)lookUpImpOrForward(0, a2, v4, 7u);
    }
    if (!result) {
      return (unint64_t)_objc_msgForward;
    }
  }
  return result;
}

Class realizeAndInitializeIfNeeded_locked(objc_object *a1, objc_class *a2, int a3)
{
  uint64_t v5 = *(void *)a2;
  if ((unint64_t)(*(void *)a2 - 1) < 0xF
    || (*(_DWORD *)(*((void *)a2 + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0)
  {
    int v11 = realizeClassMaybeSwiftMaybeRelock((uint64_t *)a2, 1);
    a2 = v11;
    if (!v11) {
      return a2;
    }
    uint64_t v5 = *(void *)v11;
  }
  uint64_t v6 = v5 & 0xFFFFFFFF8;
  if (v6) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if (v6) {
    BOOL v8 = a3 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8) {
    return v7;
  }
  int v9 = *(_DWORD *)(*((void *)a2 + 4) & 0xF00007FFFFFFFF8);
  if ((v9 & 1) == 0) {
    int v9 = *(_DWORD *)(*(void *)(v6 + 32) & 0xF00007FFFFFFFF8);
  }
  if ((v9 & 0x20000000) != 0) {
    return a2;
  }

  return initializeAndMaybeRelock(a2, a1, 1);
}

void cache_t::insert(cache_t *this, objc_selector *a2, void (*a3)(void), objc_object *a4)
{
  int v8 = *(_DWORD *)(*((void *)this + 2) & 0xF00007FFFFFFFF8);
  if ((v8 & 1) == 0) {
    int v8 = *(_DWORD *)(*(void *)((*((void *)this - 2) & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  }
  if ((v8 & 0x20000000) != 0)
  {
    if ((*(void *)this & 1) != 0
      || (*(objc_cache **)this != &_objc_empty_cache ? (BOOL v9 = HIWORD(*(void *)this) == 0) : (BOOL v9 = 0), v9))
    {
      BOOL v21 = objc_class::nameForLogging((cache_t *)((char *)this - 16));
      _objc_fatal("cache_t::insert() called with a preoptimized cache for %s", v22, v23, v24, v21);
    }
    unsigned int v10 = *((unsigned __int16 *)this + 6);
    if (HIWORD(*(void *)this)) {
      LODWORD(v11) = HIWORD(*(void *)this) + 1;
    }
    else {
      LODWORD(v11) = 0;
    }
    if (cache_t::isConstantEmptyCache(this))
    {
      if (v11) {
        uint64_t v11 = v11;
      }
      else {
        uint64_t v11 = 2;
      }
      atomic_store(cache_t::allocateBuckets((cache_t *)v11) | ((unint64_t)(v11 - 1) << 48), (unint64_t *)this);
      *((_WORD *)this + 6) = 0;
    }
    else if (v10 >= (7 * v11) >> 3 && (v11 > 8 || v11 <= v10))
    {
      unsigned int v18 = 2 * v11;
      if ((2 * v11) >= 0x10000) {
        unsigned int v18 = 0x10000;
      }
      if (v11) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = 2;
      }
      uint64_t v20 = *(void *)this & 0xFFFFFFFFFFFLL;
      atomic_store(cache_t::allocateBuckets((cache_t *)v19) | ((unint64_t)(v19 - 1) << 48), (unint64_t *)this);
      *((_WORD *)this + 6) = 0;
      cache_t::collect_free(v20, v11);
      LODWORD(v11) = v19;
    }
    uint64_t v12 = *(void *)this & 0xFFFFFFFFFFFLL;
    unsigned int v13 = (v11 - 1) & (((unint64_t)a2 >> 7) ^ a2);
    while (1)
    {
      uint64_t v14 = v13;
      uint64_t v15 = v12 + 16 * v13;
      if (!*(void *)(v15 + 8)) {
        break;
      }
      if (*(objc_selector **)(v15 + 8) == a2) {
        return;
      }
      unsigned int v13 = v14 - 1;
      if (!v14) {
        unsigned int v13 = v11 - 1;
      }
      if (v13 == ((v11 - 1) & (((unint64_t)a2 >> 7) ^ a2))) {
        cache_t::bad_cache(this, a4, a2);
      }
    }
    unsigned int v16 = (void (**)(void))(v12 + 16 * v14);
    ++*((_WORD *)this + 6);
    if (a3) {
      uint64_t v17 = a3;
    }
    else {
      uint64_t v17 = 0;
    }
    *unsigned int v16 = v17;
    v16[1] = (void (*)(void))a2;
  }
}

BOOL cache_t::isConstantEmptyCache(cache_t *this)
{
  if (*((_WORD *)this + 6)) {
    return 0;
  }
  unint64_t v2 = (unint64_t)&_objc_empty_cache & 0xFFFFFFFFFFFLL;
  if (HIWORD(*(void *)this))
  {
    uint64_t v3 = HIWORD(*(void *)this);
    if (v3 >= 0x401)
    {
      unsigned int v4 = 0;
      unsigned int v5 = v3 + 1;
      do
      {
        ++v4;
        BOOL v6 = v5 > 3;
        v5 >>= 1;
      }
      while (v6);
      if (v4 >= cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsListCount) {
        unint64_t v2 = 0;
      }
      else {
        unint64_t v2 = *(void *)(cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsList + 8 * v4);
      }
    }
  }
  return v2 == (*(void *)this & 0xFFFFFFFFFFFLL);
}

unint64_t getMethodFromListArray<method_list_t **>(unint64_t a1, unsigned char *a2, const char *a3, char *a4)
{
  unint64_t v5 = *(unsigned int *)a1;
  if ((int)v5 > -1 || (a1 & 0x8000000000000000) != 0) {
    uint64_t v7 = 24;
  }
  else {
    uint64_t v7 = 12;
  }
  uint64_t v8 = (unsigned __int16)v5 & 0xFFFC;
  if ((~v5 & 3) == 0 && v8 == v7)
  {
    if ((a1 & 0x8000000000000000) != 0)
    {
      unint64_t v18 = (a1 + 8) & 0xFFFFFFFFFFFFFFFCLL | 2;
      unsigned int v19 = *(_DWORD *)(a1 + 4);
      if (v19 < 5)
      {
        unint64_t v20 = (a1 + 8) & 0xFFFFFFFFFFFFFFFCLL | 2;
        if (!v19) {
          return 0;
        }
LABEL_31:
        uint64_t v23 = 0;
        unsigned int v24 = v19 - 1;
        while (1)
        {
          unsigned int v25 = v24;
          unsigned int v26 = *(unsigned char **)((v20 + v23) & 0xFFFFFFFFFFFFFFFCLL);
          if (v26 == a2) {
            break;
          }
          unint64_t result = 0;
          if (v26 <= a2)
          {
            --v24;
            v23 += v7;
            if (v25) {
              continue;
            }
          }
          return result;
        }
        return v20 + v23;
      }
      unint64_t v20 = (a1 + 8) & 0xFFFFFFFFFFFFFFFCLL | 2;
      while (1)
      {
        unint64_t result = v20 + v7 * (unint64_t)(v19 >> 1);
        BOOL v21 = *(unsigned char **)(result & 0xFFFFFFFFFFFFFFFCLL);
        if (v21 == a2) {
          break;
        }
        if (v21 < a2) {
          unint64_t v20 = result + v7;
        }
        unsigned int v22 = v19 - (v21 < a2);
        unsigned int v19 = v22 >> 1;
        if (v22 <= 9)
        {
          if (v19) {
            goto LABEL_31;
          }
          return 0;
        }
      }
      if (result <= v18) {
        return result;
      }
      uint64_t v39 = 0;
      unint64_t v40 = v20 + (int)v7 * (uint64_t)(int)((v19 >> 1) - 1);
      while (*(unsigned char **)((v40 + v39) & 0xFFFFFFFFFFFFFFFCLL) == a2)
      {
        v39 -= v7;
        uint64_t v41 = result + v39;
        if (result + v39 <= v18) {
          return v41;
        }
      }
    }
    else
    {
      if ((v5 & 0x80000000) == 0)
      {
        unint64_t v10 = (a1 + 8) & 0xFFFFFFFFFFFFFFFCLL;
        unsigned int v11 = *(_DWORD *)(a1 + 4);
        if (v11 >= 5)
        {
          unint64_t v12 = (a1 + 8) & 0xFFFFFFFFFFFFFFFCLL;
          do
          {
            unint64_t result = v12 + 24 * (v11 >> 1);
            uint64_t v14 = *(unsigned char **)(result & 0xFFFFFFFFFFFFFFFCLL);
            BOOL v15 = v14 >= a2;
            if (v14 == a2)
            {
              if (result > v10)
              {
                uint64_t v49 = v12 + 24 * (v11 >> 1) - 24;
                do
                {
                  if (*(unsigned char **)(v49 & 0xFFFFFFFFFFFFFFFCLL) != a2) {
                    break;
                  }
                  result -= 24;
                  v49 -= 24;
                }
                while (result > v10);
              }
              return result;
            }
            BOOL v16 = v14 < a2;
            if (!v15) {
              unint64_t v12 = result + 24;
            }
            unsigned int v17 = v11 - v16;
            unsigned int v11 = v17 >> 1;
          }
          while (v17 > 9);
          if (v11) {
            goto LABEL_48;
          }
          return 0;
        }
        unint64_t v12 = (a1 + 8) & 0xFFFFFFFFFFFFFFFCLL;
        if (!v11) {
          return 0;
        }
LABEL_48:
        uint64_t v35 = 0;
        unsigned int v36 = v11 - 1;
        while (1)
        {
          unint64_t result = v12 + v35;
          BOOL v37 = *(unsigned char **)((v12 + v35) & 0xFFFFFFFFFFFFFFFCLL);
          if (v37 == a2) {
            break;
          }
          BOOL v38 = v37 > a2 || v36-- == 0;
          v35 += v7;
          if (v38) {
            return 0;
          }
        }
        return result;
      }
      if (dataSegmentsRanges <= a1 && *(void *)algn_1EB1CB078 > a1)
      {
        unint64_t result = 0;
        if (dataSegmentsRanges > (unint64_t)a2 || *(void *)algn_1EB1CB078 <= (unint64_t)a2) {
          return result;
        }
        unint64_t v27 = a2 - (unsigned char *)&unk_1F62995A8;
        unint64_t v28 = (a1 + 8) & 0xFFFFFFFFFFFFFFFCLL | (v5 >> 31);
        unsigned int v29 = *(_DWORD *)(a1 + 4);
        if (v29 < 5)
        {
          unint64_t v30 = v28;
LABEL_91:
          if (!v29) {
            return 0;
          }
          uint64_t v55 = 0;
          unsigned int v56 = v29 - 1;
          do
          {
            unint64_t result = v30 + v55;
            unint64_t v57 = *(int *)((v30 + v55) & 0xFFFFFFFFFFFFFFFCLL);
            if (v27 == v57) {
              break;
            }
            unint64_t result = 0;
            BOOL v58 = v27 < v57 || v56-- == 0;
            v55 += v7;
          }
          while (!v58);
        }
        else
        {
          unint64_t v30 = v28;
          while (1)
          {
            unint64_t result = v30 + v7 * (unint64_t)(v29 >> 1);
            unint64_t v31 = *(int *)(result & 0xFFFFFFFFFFFFFFFCLL);
            BOOL v32 = v27 > v31;
            if (v27 == v31) {
              break;
            }
            BOOL v33 = v27 > v31;
            if (v32) {
              unint64_t v30 = result + v7;
            }
            unsigned int v34 = v29 - v33;
            unsigned int v29 = v34 >> 1;
            if (v34 <= 9) {
              goto LABEL_91;
            }
          }
          if (result > v28)
          {
            uint64_t v59 = 0;
            unint64_t v60 = v30 + (int)v7 * (uint64_t)(int)((v29 >> 1) - 1);
            while (v27 == *(_DWORD *)((v60 + v59) & 0xFFFFFFFFFFFFFFFCLL))
            {
              v59 -= v7;
              if (result + v59 <= v28)
              {
                result += v59;
                return result;
              }
            }
            result += v59;
          }
        }
        return result;
      }
      unint64_t v42 = (a1 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
      unsigned int v43 = *(_DWORD *)(a1 + 4);
      if (v43 < 5)
      {
        unint64_t v44 = (a1 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
LABEL_75:
        if (!v43) {
          return 0;
        }
        uint64_t v50 = 0;
        unsigned int v51 = v43 - 1;
        do
        {
          unint64_t result = v44 + v50;
          uint64_t v52 = *(unsigned char **)(((v44 + v50) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v44 + v50) & 0xFFFFFFFFFFFFFFFCLL));
          if (v52 == a2) {
            break;
          }
          unint64_t result = 0;
          BOOL v53 = v52 > a2 || v51-- == 0;
          v50 += v7;
        }
        while (!v53);
        return result;
      }
      unint64_t v44 = (a1 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
      while (1)
      {
        unint64_t result = v44 + v7 * (unint64_t)(v43 >> 1);
        unint64_t v45 = *(unsigned char **)((result & 0xFFFFFFFFFFFFFFFCLL) + *(int *)(result & 0xFFFFFFFFFFFFFFFCLL));
        BOOL v46 = v45 >= a2;
        if (v45 == a2) {
          break;
        }
        BOOL v47 = v45 < a2;
        if (!v46) {
          unint64_t v44 = result + v7;
        }
        unsigned int v48 = v43 - v47;
        unsigned int v43 = v48 >> 1;
        if (v48 <= 9) {
          goto LABEL_75;
        }
      }
      if (result <= v42) {
        return result;
      }
      uint64_t v39 = 0;
      unint64_t v54 = v44 + (int)v7 * (uint64_t)(int)((v43 >> 1) - 1);
      while (*(unsigned char **)(((v54 + v39) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v54 + v39) & 0xFFFFFFFFFFFFFFFCLL)) == a2)
      {
        v39 -= v7;
        uint64_t v41 = result + v39;
        if (result + v39 <= v42) {
          return v41;
        }
      }
    }
    result += v39;
    return result;
  }
  if ((a1 & 0x8000000000000000) != 0)
  {
    uint64_t v61 = *(unsigned int *)(a1 + 4);
    unint64_t v66 = v61 * (unint64_t)((unsigned __int16)v5 & 0xFFFC);
    if ((v66 & 0xFFFFFFFF00000000) != 0) {
      goto LABEL_139;
    }
    unint64_t v67 = (a1 + 8) & 0xFFFFFFFFFFFFFFFCLL | 2;
    unint64_t v68 = (a1 + 8 + v66) & 0xFFFFFFFFFFFFFFFCLL | 2;
    if (v67 == v68) {
      return 0;
    }
    uint64_t v69 = 0;
    while (*(unsigned char **)((v67 + v69) & 0xFFFFFFFFFFFFFFFCLL) != a2)
    {
      unint64_t result = 0;
      v69 += v8;
      if (v67 + v69 == v68) {
        return result;
      }
    }
    return v67 + v69;
  }
  else
  {
    if ((v5 & 0x80000000) == 0)
    {
      uint64_t v61 = *(unsigned int *)(a1 + 4);
      unint64_t v62 = v61 * (unint64_t)((unsigned __int16)v5 & 0xFFFC);
      if ((v62 & 0xFFFFFFFF00000000) == 0)
      {
        unint64_t v63 = (a1 + 8) & 0xFFFFFFFFFFFFFFFCLL;
        unint64_t v64 = (a1 + 8 + v62) & 0xFFFFFFFFFFFFFFFCLL;
        if (v63 != v64)
        {
          uint64_t v65 = 0;
          do
          {
            unint64_t result = v63 + v65;
            if (*(unsigned char **)((v63 + v65) & 0xFFFFFFFFFFFFFFFCLL) == a2) {
              break;
            }
            unint64_t result = 0;
            v65 += v8;
          }
          while (v63 + v65 != v64);
          return result;
        }
        return 0;
      }
LABEL_139:
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v61, a1, v8);
    }
    if (dataSegmentsRanges > a1 || *(void *)algn_1EB1CB078 <= a1)
    {
      uint64_t v61 = *(unsigned int *)(a1 + 4);
      unint64_t v75 = v61 * (unint64_t)((unsigned __int16)v5 & 0xFFFC);
      if ((v75 & 0xFFFFFFFF00000000) != 0) {
        goto LABEL_139;
      }
      unint64_t v76 = (a1 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
      unint64_t v77 = (a1 + 8 + v75) & 0xFFFFFFFFFFFFFFFCLL | 1;
      if (v76 == v77) {
        return 0;
      }
      uint64_t v78 = 0;
      do
      {
        unint64_t result = v76 + v78;
        if (*(unsigned char **)(((v76 + v78) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v76 + v78) & 0xFFFFFFFFFFFFFFFCLL)) == a2) {
          break;
        }
        unint64_t result = 0;
        v78 += v8;
      }
      while (v76 + v78 != v77);
    }
    else
    {
      unint64_t result = 0;
      if (dataSegmentsRanges > (unint64_t)a2 || *(void *)algn_1EB1CB078 <= (unint64_t)a2) {
        return result;
      }
      uint64_t v61 = *(unsigned int *)(a1 + 4);
      unint64_t v70 = v61 * (unint64_t)((unsigned __int16)v5 & 0xFFFC);
      if ((v70 & 0xFFFFFFFF00000000) != 0) {
        goto LABEL_139;
      }
      unint64_t v71 = a1 + 8;
      unint64_t v72 = (a1 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
      unint64_t v73 = (v71 + v70) & 0xFFFFFFFFFFFFFFFCLL | 1;
      if (v72 == v73) {
        return 0;
      }
      uint64_t v74 = 0;
      do
      {
        unint64_t result = v72 + v74;
        if ((char *)&unk_1F62995A8 + *(int *)((v72 + v74) & 0xFFFFFFFFFFFFFFFCLL) == a2) {
          break;
        }
        unint64_t result = 0;
        v74 += v8;
      }
      while (v72 + v74 != v73);
    }
  }
  return result;
}

unint64_t getMethodFromRelativeList(unsigned int *a1, unsigned char *a2, const char *a3, char *a4)
{
  if (dataSegmentsRanges > (unint64_t)a2 || *(void *)algn_1EB1CB078 <= (unint64_t)a2) {
    return 0;
  }
  if (DisablePreattachedCategories)
  {
    uint64_t v7 = *a1;
    uint64_t v86 = a1[1];
    unint64_t v87 = v86 * (unint64_t)v7;
    if ((v87 & 0xFFFFFFFF00000000) != 0) {
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v86, a1, v7);
    }
    uint64_t v88 = (uint64_t)a1 + v87 + 8;
    if (v86) {
      uint64_t v6 = v86;
    }
    else {
      uint64_t v6 = 0;
    }
    if (v86) {
      unint64_t v5 = (uint64_t *)(v88 - v7);
    }
    else {
      unint64_t v5 = (uint64_t *)v88;
    }
  }
  else
  {
    unint64_t v5 = (uint64_t *)(a1 + 2);
    uint64_t v7 = *a1;
    uint64_t v6 = a1[1];
  }
  unint64_t v8 = v6 * (unint64_t)v7;
  if ((v8 & 0xFFFFFFFF00000000) != 0) {
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v6, a1, v7);
  }
  unint64_t v9 = (unint64_t)a1 + v8 + 8;
  if ((unint64_t)v5 < v9)
  {
    while ((*(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v5 + 8) & 1) == 0)
    {
      unint64_t v5 = (uint64_t *)((char *)v5 + v7);
      unsigned int v10 = v7;
      if ((unint64_t)v5 >= v9) {
        goto LABEL_14;
      }
    }
  }
  unsigned int v10 = v7;
LABEL_14:
  if (v5 == (uint64_t *)v9) {
    return 0;
  }
  unint64_t v11 = a2 - (unsigned char *)&unk_1F62995A8;
  while (1)
  {
    unint64_t v12 = (unint64_t)v5 + (*v5 >> 16);
    unint64_t v13 = *(unsigned int *)v12;
    if ((v12 & 0x8000000000000000) == 0 && (int)v13 <= -1) {
      uint64_t v15 = 12;
    }
    else {
      uint64_t v15 = 24;
    }
    uint64_t v16 = (unsigned __int16)v13 & 0xFFFC;
    if ((~v13 & 3) != 0 || v16 != v15)
    {
      if ((v12 & 0x8000000000000000) != 0)
      {
        uint64_t v73 = *(unsigned int *)(v12 + 4);
        unint64_t v77 = v73 * (unint64_t)v16;
        if ((v77 & 0xFFFFFFFF00000000) != 0) {
          goto LABEL_164;
        }
        unint64_t v78 = v12 + 8;
        unint64_t result = v78 & 0xFFFFFFFFFFFFFFFCLL | 2;
        unint64_t v79 = (v78 + v77) & 0xFFFFFFFFFFFFFFFCLL | 2;
        if (result == v79) {
          goto LABEL_122;
        }
        while (*(unsigned char **)(result & 0xFFFFFFFFFFFFFFFCLL) != a2)
        {
          result += v16;
          if (result == v79) {
            goto LABEL_122;
          }
        }
        goto LABEL_121;
      }
      if ((v13 & 0x80000000) != 0)
      {
        uint64_t v73 = *(unsigned int *)(v12 + 4);
        unint64_t v80 = v73 * (unint64_t)v16;
        if (dataSegmentsRanges <= v12 && *(void *)algn_1EB1CB078 > v12)
        {
          if ((v80 & 0xFFFFFFFF00000000) != 0) {
LABEL_164:
          }
            _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, (const char *)3, (char *)0xFFFFFFFFLL, v73, (char *)v5 + (*v5 >> 16), v16);
          unint64_t v84 = v12 + 8;
          unint64_t result = v84 & 0xFFFFFFFFFFFFFFFCLL | 1;
          unint64_t v85 = (v84 + v80) & 0xFFFFFFFFFFFFFFFCLL | 1;
          while (result != v85)
          {
            if ((char *)&unk_1F62995A8 + *(int *)(result & 0xFFFFFFFFFFFFFFFCLL) == a2) {
              goto LABEL_121;
            }
            result += v16;
          }
        }
        else
        {
          if ((v80 & 0xFFFFFFFF00000000) != 0) {
            goto LABEL_164;
          }
          unint64_t v82 = v12 + 8;
          unint64_t result = v82 & 0xFFFFFFFFFFFFFFFCLL | 1;
          unint64_t v83 = (v82 + v80) & 0xFFFFFFFFFFFFFFFCLL | 1;
          while (result != v83)
          {
            if (*(unsigned char **)((result & 0xFFFFFFFFFFFFFFFCLL) + *(int *)(result & 0xFFFFFFFFFFFFFFFCLL)) == a2) {
              goto LABEL_121;
            }
            result += v16;
          }
        }
        goto LABEL_122;
      }
      uint64_t v73 = *(unsigned int *)(v12 + 4);
      unint64_t v74 = v73 * (unint64_t)v16;
      if ((v74 & 0xFFFFFFFF00000000) != 0) {
        goto LABEL_164;
      }
      unint64_t v75 = v12 + 8;
      unint64_t result = v75 & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v76 = (v75 + v74) & 0xFFFFFFFFFFFFFFFCLL;
      if (result != v76)
      {
        while (*(unsigned char **)(result & 0xFFFFFFFFFFFFFFFCLL) != a2)
        {
          result += v16;
          if (result == v76) {
            goto LABEL_122;
          }
        }
        goto LABEL_121;
      }
      goto LABEL_122;
    }
    unint64_t v18 = v12 + 8;
    if ((v12 & 0x8000000000000000) == 0) {
      break;
    }
    unint64_t v28 = v18 & 0xFFFFFFFFFFFFFFFCLL | 2;
    unsigned int v29 = *(_DWORD *)(v12 + 4);
    if (v29 >= 5)
    {
      unint64_t v30 = v18 & 0xFFFFFFFFFFFFFFFCLL | 2;
      while (1)
      {
        unint64_t result = v30 + v15 * (unint64_t)(v29 >> 1);
        unint64_t v31 = *(unsigned char **)(result & 0xFFFFFFFFFFFFFFFCLL);
        BOOL v32 = v31 >= a2;
        if (v31 == a2) {
          break;
        }
        BOOL v33 = v31 < a2;
        if (!v32) {
          unint64_t v30 = result + v15;
        }
        unsigned int v34 = v29 - v33;
        unsigned int v29 = v34 >> 1;
        if (v34 <= 9)
        {
          if (!v29) {
            goto LABEL_122;
          }
          goto LABEL_46;
        }
      }
      if (result > v28)
      {
        uint64_t v52 = 0;
        while (*(unsigned char **)((v30 + (int)v15 * (uint64_t)(int)((v29 >> 1) - 1) + v52) & 0xFFFFFFFFFFFFFFFCLL) == a2)
        {
          v52 -= v15;
          if (result + v52 <= v28) {
            return v30 + (v29 >> 1) * (unint64_t)v15 + v52;
          }
        }
        result += v52;
      }
      goto LABEL_121;
    }
    unint64_t v30 = v18 & 0xFFFFFFFFFFFFFFFCLL | 2;
    if (v29)
    {
LABEL_46:
      uint64_t v35 = 0;
      unsigned int v36 = v29 - 1;
      while (1)
      {
        unsigned int v37 = v36;
        BOOL v38 = *(unsigned char **)((v30 + v35) & 0xFFFFFFFFFFFFFFFCLL);
        if (v38 == a2) {
          break;
        }
        if (v38 <= a2)
        {
          unsigned int v36 = v37 - 1;
          v35 += v15;
          if (v37) {
            continue;
          }
        }
        goto LABEL_122;
      }
      unint64_t result = v30 + v35;
      goto LABEL_121;
    }
LABEL_122:
    uint64_t v70 = v10;
    unint64_t v71 = (uint64_t *)((char *)v5 + v10);
    do
    {
      unint64_t v5 = v71;
      if ((unint64_t)v71 >= v9) {
        break;
      }
      uint64_t v72 = *(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v71 + 8);
      unint64_t v71 = (uint64_t *)((char *)v71 + v70);
    }
    while ((v72 & 1) == 0);
    unsigned int v10 = v70;
    if (v5 == (uint64_t *)v9) {
      return 0;
    }
  }
  if ((v13 & 0x80000000) == 0)
  {
    unint64_t v19 = v18 & 0xFFFFFFFFFFFFFFFCLL;
    unsigned int v20 = *(_DWORD *)(v12 + 4);
    if (v20 < 5)
    {
      unint64_t v21 = v18 & 0xFFFFFFFFFFFFFFFCLL;
      if (v20) {
        goto LABEL_64;
      }
      goto LABEL_122;
    }
    unint64_t v21 = v18 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      unint64_t result = v21 + 24 * (v20 >> 1);
      uint64_t v23 = *(unsigned char **)(result & 0xFFFFFFFFFFFFFFFCLL);
      BOOL v24 = v23 >= a2;
      if (v23 == a2)
      {
        if (result > v19)
        {
          for (uint64_t i = v21 + 24 * (v20 >> 1) - 24; *(unsigned char **)(i & 0xFFFFFFFFFFFFFFFCLL) == a2; i -= 24)
          {
            result -= 24;
            if (result <= v19) {
              return result;
            }
          }
        }
        goto LABEL_121;
      }
      BOOL v25 = v23 < a2;
      unint64_t v26 = result + 24;
      if (!v24) {
        unint64_t v21 = v26;
      }
      unsigned int v27 = v20 - v25;
      unsigned int v20 = (v20 - v25) >> 1;
    }
    while (v27 > 9);
    if (!v20) {
      goto LABEL_122;
    }
LABEL_64:
    uint64_t v48 = 0;
    unsigned int v49 = v20 - 1;
    while (1)
    {
      unint64_t result = v21 + v48;
      uint64_t v50 = *(unsigned char **)((v21 + v48) & 0xFFFFFFFFFFFFFFFCLL);
      if (v50 == a2) {
        break;
      }
      BOOL v51 = v50 > a2 || v49-- == 0;
      v48 += v15;
      if (v51) {
        goto LABEL_122;
      }
    }
LABEL_121:
    if (result) {
      return result;
    }
    goto LABEL_122;
  }
  unint64_t v39 = v18 & 0xFFFFFFFFFFFFFFFCLL;
  if (dataSegmentsRanges > v12 || *(void *)algn_1EB1CB078 <= v12)
  {
    unint64_t v41 = v39 | 1;
    LODWORD(v12) = *(_DWORD *)(v12 + 4);
    if (v12 >= 5)
    {
      uint64_t v42 = v39 | 1;
      while (1)
      {
        unint64_t result = v42 + v15 * (unint64_t)(v12 >> 1);
        unsigned int v43 = *(unsigned char **)((result & 0xFFFFFFFFFFFFFFFCLL) + *(int *)(result & 0xFFFFFFFFFFFFFFFCLL));
        BOOL v44 = v43 >= a2;
        if (v43 == a2) {
          break;
        }
        BOOL v45 = v43 < a2;
        uint64_t v46 = result + v15;
        if (!v44) {
          uint64_t v42 = v46;
        }
        unsigned int v47 = v12 - v45;
        LODWORD(v12) = (v12 - v45) >> 1;
        if (v47 <= 9)
        {
          if (!v12) {
            goto LABEL_122;
          }
          goto LABEL_92;
        }
      }
      if (result <= v41) {
        goto LABEL_121;
      }
      uint64_t v68 = 0;
      unint64_t v12 = v12;
      while (1)
      {
        uint64_t v69 = v42 + (int)v15 * (uint64_t)(int)((v12 >> 1) - 1);
        if (*(unsigned char **)(((v69 + v68) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v69 + v68) & 0xFFFFFFFFFFFFFFFCLL)) != a2) {
          break;
        }
        v68 -= v15;
        if (result + v68 <= v41) {
          return v42 + (v12 >> 1) * (unint64_t)v15 + v68;
        }
      }
LABEL_120:
      result += v68;
      goto LABEL_121;
    }
    uint64_t v42 = v39 | 1;
    if (v12)
    {
LABEL_92:
      uint64_t v60 = 0;
      int v61 = v12 - 1;
      while (1)
      {
        unint64_t result = v42 + v60;
        unint64_t v62 = *(unsigned char **)(((v42 + v60) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v42 + v60) & 0xFFFFFFFFFFFFFFFCLL));
        if (v62 == a2) {
          goto LABEL_121;
        }
        BOOL v63 = v62 > a2 || v61-- == 0;
        v60 += v15;
        if (v63) {
          goto LABEL_122;
        }
      }
    }
    goto LABEL_122;
  }
  unint64_t v53 = v39 | (v13 >> 31);
  LODWORD(v12) = *(_DWORD *)(v12 + 4);
  if (v12 < 5)
  {
    uint64_t v42 = v39 | (v13 >> 31);
    if (v12)
    {
LABEL_101:
      uint64_t v64 = 0;
      int v65 = v12 - 1;
      while (1)
      {
        unint64_t result = v42 + v64;
        unint64_t v66 = *(int *)((v42 + v64) & 0xFFFFFFFFFFFFFFFCLL);
        if (v11 == v66) {
          goto LABEL_121;
        }
        BOOL v67 = v11 < v66 || v65-- == 0;
        v64 += v15;
        if (v67) {
          goto LABEL_122;
        }
      }
    }
    goto LABEL_122;
  }
  uint64_t v42 = v39 | (v13 >> 31);
  while (1)
  {
    unint64_t result = v42 + v15 * (unint64_t)(v12 >> 1);
    unint64_t v54 = *(int *)(result & 0xFFFFFFFFFFFFFFFCLL);
    BOOL v55 = v11 > v54;
    if (v11 == v54) {
      break;
    }
    BOOL v56 = v11 > v54;
    uint64_t v57 = result + v15;
    if (v55) {
      uint64_t v42 = v57;
    }
    unsigned int v58 = v12 - v56;
    LODWORD(v12) = (v12 - v56) >> 1;
    if (v58 <= 9)
    {
      if (!v12) {
        goto LABEL_122;
      }
      goto LABEL_101;
    }
  }
  if (result <= v53) {
    goto LABEL_121;
  }
  uint64_t v68 = 0;
  unint64_t v12 = v12;
  do
  {
    if (v11 != *(_DWORD *)((v42 + (int)v15 * (uint64_t)(int)((v12 >> 1) - 1) + v68) & 0xFFFFFFFFFFFFFFFCLL)) {
      goto LABEL_120;
    }
    v68 -= v15;
  }
  while (result + v68 > v53);
  return v42 + (v12 >> 1) * (unint64_t)v15 + v68;
}

unint64_t method_t::imp(unint64_t this, int a2)
{
  unint64_t v2 = (const method_t *)this;
  int v3 = this & 3;
  if ((this & 3) == 0 || v3 == 2)
  {
    if (*(void *)((this & 0xFFFFFFFFFFFFFFFCLL) + 16)) {
      return *(void *)((this & 0xFFFFFFFFFFFFFFFCLL) + 16);
    }
    else {
      return 0;
    }
  }
  else if (v3 == 1)
  {
    unint64_t v4 = *(int *)((this & 0xFFFFFFFFFFFFFFFCLL) + 8) + (this & 0xFFFFFFFFFFFFFFFCLL) + 8;
    if (a2)
    {
      int v5 = 0;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v5, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
      if (v5) {
        os_unfair_lock_lock_with_options();
      }
      uint64_t v7 = method_t_remappedImp_nolock(v2);
      int v8 = *(_DWORD *)(StatusReg + 24);
      int v9 = v8;
      atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v9, 0, memory_order_release, memory_order_relaxed);
      if (v9 != v8) {
        os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
      }
    }
    else
    {
      uint64_t v7 = method_t_remappedImp_nolock((const method_t *)this);
    }
    if (v7) {
      return v7;
    }
    else {
      return v4;
    }
  }
  return this;
}

void sub_18010FF3C(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

uint64_t method_t_remappedImp_nolock(const method_t *a1)
{
  if (!byte_1EB1CA748) {
    return 0;
  }
  uint64_t v5 = 0;
  if (objc::DenseMapBase<objc::DenseMap<method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>,method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>::LookupBucketFor<method_t const*>((unint64_t)a1, &v5))
  {
    uint64_t v1 = v5;
    if (objc::smallMethodIMPMap)
    {
LABEL_4:
      uint64_t v2 = objc::smallMethodIMPMap;
      goto LABEL_10;
    }
  }
  else
  {
    if (objc::smallMethodIMPMap) {
      uint64_t v3 = objc::smallMethodIMPMap;
    }
    else {
      uint64_t v3 = 0;
    }
    uint64_t v1 = v3 + 16 * dword_1EB1CA740;
    if (objc::smallMethodIMPMap) {
      goto LABEL_4;
    }
  }
  uint64_t v2 = 0;
LABEL_10:
  if (v2 + 16 * dword_1EB1CA740 != v1) {
    return *(void *)(v1 + 8);
  }
  return 0;
}

uint64_t objc_release_full(uint64_t result, double a2)
{
  if ((result & 0x8000000000000000) == 0)
  {
    unint64_t v2 = *(void *)result;
    uint64_t v3 = *(void *)((*(void *)result & 0xFFFFFFFF8) + 0x20);
    if ((v3 & 4) != 0)
    {
      if (v2)
      {
        while (v2 >> 55)
        {
          unint64_t v4 = v2 - 0x100000000000000;
          if (v2 < 0x100000000000000) {
            return objc_object::rootRelease_underflow((objc_object *)result, 1);
          }
          unint64_t v5 = v2;
          atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)result, &v5, v4, memory_order_release, memory_order_relaxed);
          if (v5 == v2)
          {
            if (!(v4 >> 55))
            {
              __dmb(9u);
              if ((*(_WORD *)((*(void *)result & 0xFFFFFFFF8) + 0x1E) & 0x1000) != 0) {
                uint64_t v6 = &selRef__objc_initiateDealloc;
              }
              else {
                uint64_t v6 = &selRef_dealloc;
              }
              return (uint64_t)[(id)result *v6];
            }
            return result;
          }
          unint64_t v2 = v5;
          if ((v5 & 1) == 0) {
            return objc_object::sidetable_release((objc_object *)result, 0, 1);
          }
        }
      }
      else if ((*(_WORD *)((*(void *)result & 0xFFFFFFFF8) + 0x1E) & 4) == 0)
      {
        return objc_object::sidetable_release((objc_object *)result, 0, 1);
      }
    }
    else if ((v3 & 2) != 0 {
           && *(__int16 *)((*(void *)result & 0xFFFFFFFF8) + 0x1E) < 0
    }
           && (*(unsigned char *)((*(void *)result & 0xFFFFFFFF8) + 0x28) & 2) != 0)
    {
      return swiftRelease((objc_object *)result, a2);
    }
    else
    {
      return (uint64_t)[(id)result sel_release];
    }
  }
  return result;
}

void objc_destroyWeak(id *location)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  while (1)
  {
    int v4 = 0;
    id v5 = *location;
                                             * (unint64_t)(((*location >> 4) ^ (*location >> 9)) & 7)];
    atomic_compare_exchange_strong_explicit(v6, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v4) {
      os_unfair_lock_lock_with_options();
    }
    if (*location == v5) {
      break;
    }
    int v7 = *(_DWORD *)(StatusReg + 24);
    int v8 = v7;
    atomic_compare_exchange_strong_explicit(v6, (unsigned int *)&v8, 0, memory_order_release, memory_order_relaxed);
    if (v8 != v7) {
      os_unfair_lock_unlock((os_unfair_lock_t)v6);
    }
  }
  weak_unregister_no_lock((void *)v6 + 4, (unint64_t)v5, (const char *)location, v1);
  int v9 = *(_DWORD *)(StatusReg + 24);
  int v10 = v9;
  atomic_compare_exchange_strong_explicit(v6, (unsigned int *)&v10, 0, memory_order_release, memory_order_relaxed);
  if (v10 != v9)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)v6);
  }
}

uint64_t cache_t::allocateBuckets(cache_t *this)
{
  if (PrintCaches)
  {
    if (this >= 2)
    {
      unsigned int v2 = -1;
      unsigned int v3 = this;
      do
      {
        unsigned int v4 = v2++;
        BOOL v5 = v3 > 3;
        v3 >>= 1;
      }
      while (v5);
      if (v2 > 0xE) {
        goto LABEL_9;
      }
      unsigned int v1 = v4 + 2;
    }
    else
    {
      unsigned int v1 = 0;
    }
    ++cache_counts[v1];
LABEL_9:
    ++cache_allocations;
  }
  return malloc_type_zone_malloc_with_options_internal();
}

uint64_t *AutoreleasePoolPage::autoreleaseNewPage(AutoreleasePoolPage *this, objc_object *a2, AutoreleasePoolPage *a3)
{
  unsigned int v3 = *(objc_object **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 344);
  if ((unint64_t)v3 >= 2)
  {
    if (LODWORD(v3->isa) != -1583242847) {
      AutoreleasePoolPage::busted_die((const void **)&v3->isa);
    }
    return AutoreleasePoolPage::autoreleaseFullPage(0, v3, a3);
  }
  else
  {
    return (uint64_t *)AutoreleasePoolPage::autoreleaseNoPage(0, v3);
  }
}

unint64_t _category_getLoadMethod(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  unint64_t v4 = *(void *)(a1 + 24);
  if (!v4) {
    return 0;
  }
  unint64_t v5 = *(unsigned int *)v4;
  if ((int)v5 > -1 || (v4 & 0x8000000000000000) != 0) {
    uint64_t v7 = 24;
  }
  else {
    uint64_t v7 = 12;
  }
  uint64_t v8 = (unsigned __int16)v5 & 0xFFFC;
  if ((~v5 & 3) == 0 && v8 == v7)
  {
    if ((v4 & 0x8000000000000000) != 0)
    {
      unint64_t v18 = (v4 + 8) & 0xFFFFFFFFFFFFFFFCLL | 2;
      unsigned int v19 = *(_DWORD *)(v4 + 4);
      if (v19 < 5)
      {
        unint64_t v20 = (v4 + 8) & 0xFFFFFFFFFFFFFFFCLL | 2;
        if (v19)
        {
LABEL_32:
          uint64_t v23 = 0;
          unsigned int v24 = v19 - 1;
          while (1)
          {
            unsigned int v25 = v24;
            unint64_t v26 = *(char **)((v20 + v23) & 0xFFFFFFFFFFFFFFFCLL);
            if (sel_load == v26) {
              break;
            }
            if (sel_load >= v26)
            {
              --v24;
              v23 += v7;
              if (v25) {
                continue;
              }
            }
            return 0;
          }
          unint64_t v13 = v20 + v23;
          goto LABEL_106;
        }
        return 0;
      }
      unint64_t v20 = (v4 + 8) & 0xFFFFFFFFFFFFFFFCLL | 2;
      while (1)
      {
        unint64_t v13 = v20 + v7 * (unint64_t)(v19 >> 1);
        unint64_t v21 = *(char **)(v13 & 0xFFFFFFFFFFFFFFFCLL);
        if (sel_load == v21) {
          break;
        }
        if (sel_load > v21) {
          unint64_t v20 = v13 + v7;
        }
        unsigned int v22 = v19 - (sel_load > v21);
        unsigned int v19 = v22 >> 1;
        if (v22 <= 9)
        {
          if (v19) {
            goto LABEL_32;
          }
          return 0;
        }
      }
      if (v13 <= v18) {
        goto LABEL_106;
      }
      uint64_t v39 = 0;
      unint64_t v40 = v20 + (int)v7 * (uint64_t)(int)((v19 >> 1) - 1);
      while (sel_load == *(char **)((v40 + v39) & 0xFFFFFFFFFFFFFFFCLL))
      {
        v39 -= v7;
        unint64_t v41 = v13 + v39;
        if (v13 + v39 <= v18)
        {
LABEL_61:
          unint64_t v13 = v41;
          goto LABEL_107;
        }
      }
    }
    else
    {
      if ((v5 & 0x80000000) == 0)
      {
        unint64_t v10 = (v4 + 8) & 0xFFFFFFFFFFFFFFFCLL;
        unsigned int v11 = *(_DWORD *)(v4 + 4);
        if (v11 >= 5)
        {
          unint64_t v12 = (v4 + 8) & 0xFFFFFFFFFFFFFFFCLL;
          do
          {
            unint64_t v13 = v12 + 24 * (v11 >> 1);
            uint64_t v14 = *(char **)(v13 & 0xFFFFFFFFFFFFFFFCLL);
            BOOL v15 = sel_load > v14;
            if (sel_load == v14)
            {
              if (v13 > v10)
              {
                uint64_t v49 = v12 + 24 * (v11 >> 1) - 24;
                while (sel_load == *(char **)(v49 & 0xFFFFFFFFFFFFFFFCLL))
                {
                  v13 -= 24;
                  v49 -= 24;
                  if (v13 <= v10) {
                    goto LABEL_107;
                  }
                }
              }
              goto LABEL_106;
            }
            BOOL v16 = sel_load > v14;
            if (v15) {
              unint64_t v12 = v13 + 24;
            }
            unsigned int v17 = v11 - v16;
            unsigned int v11 = v17 >> 1;
          }
          while (v17 > 9);
          if (v11) {
            goto LABEL_49;
          }
          return 0;
        }
        unint64_t v12 = (v4 + 8) & 0xFFFFFFFFFFFFFFFCLL;
        if (v11)
        {
LABEL_49:
          uint64_t v35 = 0;
          unsigned int v36 = v11 - 1;
          while (1)
          {
            unint64_t v13 = v12 + v35;
            unsigned int v37 = *(char **)((v12 + v35) & 0xFFFFFFFFFFFFFFFCLL);
            if (sel_load == v37) {
              break;
            }
            BOOL v38 = sel_load < v37 || v36-- == 0;
            v35 += v7;
            if (v38) {
              return 0;
            }
          }
          goto LABEL_106;
        }
        return 0;
      }
      if (dataSegmentsRanges > v4 || *(void *)algn_1EB1CB078 <= v4)
      {
        unint64_t v42 = (v4 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
        unsigned int v43 = *(_DWORD *)(v4 + 4);
        if (v43 < 5)
        {
          unint64_t v44 = (v4 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
LABEL_76:
          if (!v43) {
            return 0;
          }
          uint64_t v50 = 0;
          unsigned int v51 = v43 - 1;
          while (1)
          {
            unint64_t v13 = v44 + v50;
            uint64_t v52 = *(char **)(((v44 + v50) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v44 + v50) & 0xFFFFFFFFFFFFFFFCLL));
            if (sel_load == v52) {
              break;
            }
            BOOL v53 = sel_load < v52 || v51-- == 0;
            v50 += v7;
            if (v53) {
              return 0;
            }
          }
          goto LABEL_106;
        }
        unint64_t v44 = (v4 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
        while (1)
        {
          unint64_t v13 = v44 + v7 * (unint64_t)(v43 >> 1);
          BOOL v45 = *(char **)((v13 & 0xFFFFFFFFFFFFFFFCLL) + *(int *)(v13 & 0xFFFFFFFFFFFFFFFCLL));
          BOOL v46 = sel_load > v45;
          if (sel_load == v45) {
            break;
          }
          BOOL v47 = sel_load > v45;
          if (v46) {
            unint64_t v44 = v13 + v7;
          }
          unsigned int v48 = v43 - v47;
          unsigned int v43 = v48 >> 1;
          if (v48 <= 9) {
            goto LABEL_76;
          }
        }
        if (v13 <= v42) {
          goto LABEL_106;
        }
        uint64_t v39 = 0;
        unint64_t v54 = v44 + (int)v7 * (uint64_t)(int)((v43 >> 1) - 1);
        while (sel_load == *(char **)(((v54 + v39) & 0xFFFFFFFFFFFFFFFCLL)
                                     + *(int *)((v54 + v39) & 0xFFFFFFFFFFFFFFFCLL)))
        {
          v39 -= v7;
          unint64_t v41 = v13 + v39;
          if (v13 + v39 <= v42) {
            goto LABEL_61;
          }
        }
      }
      else
      {
        if (dataSegmentsRanges > (unint64_t)sel_load || *(void *)algn_1EB1CB078 <= (unint64_t)sel_load) {
          return 0;
        }
        unint64_t v27 = sel_load - (char *)&unk_1F62995A8;
        unint64_t v28 = (v4 + 8) & 0xFFFFFFFFFFFFFFFCLL | (v5 >> 31);
        unsigned int v29 = *(_DWORD *)(v4 + 4);
        if (v29 < 5)
        {
          unint64_t v30 = v28;
LABEL_91:
          if (!v29) {
            return 0;
          }
          uint64_t v55 = 0;
          unsigned int v56 = v29 - 1;
          while (1)
          {
            unint64_t v13 = v30 + v55;
            unint64_t v57 = *(int *)((v30 + v55) & 0xFFFFFFFFFFFFFFFCLL);
            if (v27 == v57) {
              break;
            }
            BOOL v58 = v27 < v57 || v56-- == 0;
            v55 += v7;
            if (v58) {
              return 0;
            }
          }
          goto LABEL_106;
        }
        unint64_t v30 = v28;
        while (1)
        {
          unint64_t v13 = v30 + v7 * (unint64_t)(v29 >> 1);
          unint64_t v31 = *(int *)(v13 & 0xFFFFFFFFFFFFFFFCLL);
          BOOL v32 = v27 > v31;
          if (v27 == v31) {
            break;
          }
          BOOL v33 = v27 > v31;
          if (v32) {
            unint64_t v30 = v13 + v7;
          }
          unsigned int v34 = v29 - v33;
          unsigned int v29 = v34 >> 1;
          if (v34 <= 9) {
            goto LABEL_91;
          }
        }
        if (v13 <= v28) {
          goto LABEL_106;
        }
        uint64_t v39 = 0;
        unint64_t v59 = v30 + (int)v7 * (uint64_t)(int)((v29 >> 1) - 1);
        while (v27 == *(_DWORD *)((v59 + v39) & 0xFFFFFFFFFFFFFFFCLL))
        {
          v39 -= v7;
          unint64_t v41 = v13 + v39;
          if (v13 + v39 <= v28) {
            goto LABEL_61;
          }
        }
      }
    }
    v13 += v39;
    goto LABEL_106;
  }
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v61 = *(unsigned int *)(v4 + 4);
    unint64_t v66 = v61 * (unint64_t)((unsigned __int16)v5 & 0xFFFC);
    if ((v66 & 0xFFFFFFFF00000000) == 0)
    {
      unint64_t v67 = (v4 + 8) & 0xFFFFFFFFFFFFFFFCLL | 2;
      unint64_t v68 = (v4 + 8 + v66) & 0xFFFFFFFFFFFFFFFCLL | 2;
      if (v67 == v68) {
        return 0;
      }
      uint64_t v69 = 0;
      while (*(char **)((v67 + v69) & 0xFFFFFFFFFFFFFFFCLL) != sel_load)
      {
        v69 += v8;
        if (v67 + v69 == v68) {
          return 0;
        }
      }
      unint64_t v13 = v67 + v69;
      goto LABEL_106;
    }
LABEL_141:
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v61, v4, v8);
  }
  if ((v5 & 0x80000000) != 0)
  {
    if (dataSegmentsRanges > v4 || *(void *)algn_1EB1CB078 <= v4)
    {
      uint64_t v61 = *(unsigned int *)(v4 + 4);
      unint64_t v74 = v61 * (unint64_t)((unsigned __int16)v5 & 0xFFFC);
      if ((v74 & 0xFFFFFFFF00000000) == 0)
      {
        unint64_t v75 = (v4 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
        unint64_t v76 = (v4 + 8 + v74) & 0xFFFFFFFFFFFFFFFCLL | 1;
        if (v75 == v76) {
          return 0;
        }
        uint64_t v77 = 0;
        while (1)
        {
          unint64_t v13 = v75 + v77;
          if (*(char **)(((v75 + v77) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v75 + v77) & 0xFFFFFFFFFFFFFFFCLL)) == sel_load) {
            break;
          }
          v77 += v8;
          if (v75 + v77 == v76) {
            return 0;
          }
        }
        goto LABEL_106;
      }
    }
    else
    {
      if (dataSegmentsRanges > (unint64_t)sel_load || *(void *)algn_1EB1CB078 <= (unint64_t)sel_load) {
        return 0;
      }
      uint64_t v61 = *(unsigned int *)(v4 + 4);
      unint64_t v70 = v61 * (unint64_t)((unsigned __int16)v5 & 0xFFFC);
      if ((v70 & 0xFFFFFFFF00000000) == 0)
      {
        unint64_t v71 = (v4 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
        unint64_t v72 = (v4 + 8 + v70) & 0xFFFFFFFFFFFFFFFCLL | 1;
        if (v71 == v72) {
          return 0;
        }
        uint64_t v73 = 0;
        while (1)
        {
          unint64_t v13 = v71 + v73;
          if (sel_load == (char *)&unk_1F62995A8 + *(int *)((v71 + v73) & 0xFFFFFFFFFFFFFFFCLL)) {
            break;
          }
          v73 += v8;
          if (v71 + v73 == v72) {
            return 0;
          }
        }
        goto LABEL_106;
      }
    }
    goto LABEL_141;
  }
  uint64_t v61 = *(unsigned int *)(v4 + 4);
  unint64_t v62 = v61 * (unint64_t)((unsigned __int16)v5 & 0xFFFC);
  if ((v62 & 0xFFFFFFFF00000000) != 0) {
    goto LABEL_141;
  }
  unint64_t v63 = (v4 + 8) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v64 = (v4 + 8 + v62) & 0xFFFFFFFFFFFFFFFCLL;
  if (v63 == v64) {
    return 0;
  }
  uint64_t v65 = 0;
  while (1)
  {
    unint64_t v13 = v63 + v65;
    if (*(char **)((v63 + v65) & 0xFFFFFFFFFFFFFFFCLL) == sel_load) {
      break;
    }
    v65 += v8;
    if (v63 + v65 == v64) {
      return 0;
    }
  }
LABEL_106:
  if (!v13) {
    return 0;
  }
LABEL_107:

  return method_t::imp(v13, 0);
}

void (*_objc_setBadAllocHandler(void (*result)(objc_class *)))(objc_class *)
{
  if (result) {
    unsigned int v1 = result;
  }
  else {
    unsigned int v1 = 0;
  }
  badAllocHandler = v1;
  return result;
}

const char *__cdecl class_getName(Class cls)
{
  if (cls) {
    return (const char *)objc_class::demangledName(cls, 1);
  }
  else {
    return "nil";
  }
}

uint64_t __getPreoptimizedClass_block_invoke(uint64_t result, uint64_t a2, int a3, unsigned char *a4)
{
  if (a3)
  {
    **(void **)(result + 32) = a2;
    *a4 = 1;
  }
  return result;
}

Class objc_lookUpClass(Class name)
{
  if (name) {
    return look_up_class((char *)name);
  }
  return name;
}

id class_createInstance(id cls, size_t extraBytes)
{
  if (!cls) {
    return cls;
  }
  unsigned int v3 = (objc_class **)cls;
  __int16 v4 = *((_WORD *)cls + 15);
  if ((v4 & 0xFF8) != 0)
  {
    size_t v5 = (extraBytes + (v4 & 0xFF8) + 7) & 0xFFFFFFFFFFFFFFF0;
  }
  else
  {
    unint64_t v11 = class_rw_t::ro((class_rw_t *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8));
    size_t v5 = ((*(_DWORD *)(v11 + 8) + 7) & 0xFFFFFFF8) + extraBytes <= 0x10
       ? 16
       : ((*(_DWORD *)(v11 + 8) + 7) & 0xFFFFFFF8) + extraBytes;
  }
  cls = malloc_type_calloc(1uLL, v5, 0x40000000000uLL);
  if (!cls) {
    return cls;
  }
  unint64_t v9 = (unint64_t)v3 & 0xFF80000000000007;
  if ((v4 & 0x2000) == 0)
  {
    if (!v9)
    {
      uint64_t v10 = (unint64_t)v3 & 0x7FFFFFFFFFFFF8 | 0x100000000000001;
      goto LABEL_10;
    }
LABEL_15:
    _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", v6, v7, v8, v3);
  }
  if (v9) {
    goto LABEL_15;
  }
  uint64_t v10 = (unint64_t)v3 & 0x7FFFFFFFFFFFF8;
LABEL_10:
  *(void *)cls = v10;
  if ((v4 & 2) != 0)
  {
    return object_cxxConstructFromClass((void (*)(void))cls, v3, 1);
  }
  return cls;
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  if (offset)
  {
    size_t v5 = (void **)((char *)self + offset);
    id v6 = [newValue copyWithZone:0];
    int v7 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(&PropertyLocks[16* (unint64_t)(((v5 >> 4) ^ (v5 >> 9)) & 7)], (unsigned int *)&v7, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v7) {
      os_unfair_lock_lock_with_options();
    }
    unint64_t v9 = *v5;
    *size_t v5 = v6;
    int v10 = *(_DWORD *)(StatusReg + 24);
    int v11 = v10;
    atomic_compare_exchange_strong_explicit(&PropertyLocks[16* (unint64_t)(((v5 >> 4) ^ (v5 >> 9)) & 7)], (unsigned int *)&v11, 0, memory_order_release, memory_order_relaxed);
    if (v11 != v10) {
      os_unfair_lock_unlock((os_unfair_lock_t)&PropertyLocks[16
    }
                                                           * (unint64_t)(((v5 >> 4) ^ (v5 >> 9)) & 7)]);
  }
  else
  {
    object_setClass(self, (Class)newValue);
  }
}

id objc_opt_new(void (*a1)(void))
{
  if (a1 && (int v1 = *(__int16 *)((*(void *)a1 & 0xFFFFFFFF8) + 0x1E), v1 < 0))
  {
    if ((v1 & 0x4000) != 0) {
      a1 = _objc_rootAllocWithZone((uint64_t)a1);
    }
    else {
      a1 = (void (*)(void))[a1 sel_alloc];
    }
    unsigned int v2 = sel_init;
  }
  else
  {
    unsigned int v2 = (const char *)&sel_new;
  }

  return [a1 v2];
}

id objc_alloc_init(void (*a1)(void))
{
  if (a1)
  {
    if ((*(_WORD *)((*(void *)a1 & 0xFFFFFFFF8) + 0x1E) & 0x4000) != 0) {
      a1 = _objc_rootAllocWithZone((uint64_t)a1);
    }
    else {
      a1 = (void (*)(void))[a1 sel_alloc];
    }
  }

  return [a1 init];
}

void (*_objc_rootAlloc(uint64_t a1))(void)
{
  if ((*(_WORD *)((*(void *)a1 & 0xFFFFFFFF8) + 0x1E) & 0x4000) != 0) {
    return _objc_rootAllocWithZone(a1);
  }
  else {
    return (void (*)(void))[a1 allocWithZone:0];
  }
}

void (*_objc_rootAllocWithZone(uint64_t a1))(void)
{
  __int16 v2 = *(_WORD *)(a1 + 30);
  size_t v3 = v2 & 0xFF0;
  if ((v2 & 0xFF0) == 0)
  {
    unsigned int v10 = (*(_DWORD *)(class_rw_t::ro((class_rw_t *)(*(void *)(a1 + 32) & 0xF00007FFFFFFFF8)) + 8) + 7) & 0xFFFFFFF8;
    if (v10 <= 0x10) {
      size_t v3 = 16;
    }
    else {
      size_t v3 = v10;
    }
  }
  unint64_t result = (void (*)(void))malloc_type_calloc(1uLL, v3, 0x40000000000uLL);
  if (!result)
  {
    _objc_callBadAllocHandler((objc_class *)a1);
  }
  unint64_t v8 = a1 & 0xFF80000000000007;
  if ((v2 & 0x2000) == 0)
  {
    if (!v8)
    {
      uint64_t v9 = a1 & 0x7FFFFFFFFFFFF8 | 0x100000000000001;
      goto LABEL_8;
    }
LABEL_16:
    _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", v5, v6, v7, a1);
  }
  if (v8) {
    goto LABEL_16;
  }
  uint64_t v9 = a1 & 0x7FFFFFFFFFFFF8;
LABEL_8:
  *(void *)unint64_t result = v9;
  if ((v2 & 2) != 0)
  {
    return object_cxxConstructFromClass(result, (objc_class **)a1, 3);
  }
  return result;
}

id objc_allocWithZone(id result)
{
  if (result)
  {
    if ((*(_WORD *)((*(void *)result & 0xFFFFFFFF8) + 0x1E) & 0x4000) != 0) {
      return _objc_rootAllocWithZone((uint64_t)result);
    }
    else {
      return [result allocWithZone:0];
    }
  }
  return result;
}

void (*object_cxxConstructFromClass(void (*a1)(void), objc_class **a2, uint64_t a3))(void)
{
  char v3 = a3;
  uint64_t v5 = a1;
  int v7 = a2 + 1;
  id v6 = a2[1];
  if (v6 && (*((_WORD *)v6 + 15) & 2) != 0 && !object_cxxConstructFromClass(a1, v6, a3)) {
    return 0;
  }
  Cache = lookupMethodInClassAndLoadCache((uint64_t)a2, (objc_selector *)SEL_cxx_construct);
  if (Cache != _objc_msgForward_impcache)
  {
    uint64_t v9 = Cache;
    if (PrintCxxCtors)
    {
      int v11 = objc_class::nameForLogging((objc_class *)a2);
      _objc_inform("CXX: calling C++ constructors for class %s", v11);
    }
    if (!((uint64_t (*)(void (*)(void)))v9)(v5))
    {
      if (*v7) {
        object_cxxDestructFromClass(v5, *v7);
      }
      if (v3) {
        free(v5);
      }
      if ((v3 & 2) != 0)
      {
        _objc_callBadAllocHandler((objc_class *)a2);
      }
      return 0;
    }
  }
  return v5;
}

unint64_t objc_opt_isKindOfClass(unint64_t result, uint64_t a2)
{
  if (!result) {
    return result;
  }
  if ((result & 0x8000000000000000) == 0)
  {
    uint64_t v2 = *(void *)result & 0x7FFFFFFFFFFFF8;
LABEL_4:
    uint64_t v3 = v2;
    goto LABEL_5;
  }
  uint64_t v3 = objc_debug_taggedpointer_classes[result & 7];
  if ((__objc2_class *)v3 == __NSUnrecognizedTaggedPointer)
  {
    uint64_t v2 = objc_debug_taggedpointer_ext_classes[(result >> 55)];
    goto LABEL_4;
  }
LABEL_5:
  if ((*(__int16 *)(v3 + 30) & 0x80000000) == 0) {
    return (unint64_t)[(id)result isKindOfClass:a2];
  }
  if (v3 == a2)
  {
    BOOL v5 = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v4 = *(void *)(v3 + 8);
      if (!v4) {
        break;
      }
      uint64_t v3 = *(void *)(v3 + 8);
      BOOL v5 = v4 == 0;
      if (v4 == a2) {
        return !v5;
      }
    }
    BOOL v5 = 1;
  }
  return !v5;
}

unint64_t objc_object::changeIsa(objc_object *this, unint64_t a2, const char *a3, char *a4)
{
  unint64_t v6 = 0;
  char v7 = 0;
  Class isa = this->isa;
  unint64_t v9 = a2 & 0xFF80000000000007;
  if (this->isa) {
    goto LABEL_2;
  }
  while (1)
  {
LABEL_3:
    if (((unint64_t)(*(void *)a2 - 1) < 0xF
       || (*(unsigned char *)((*(void *)(a2 + 32) & 0xF00007FFFFFFFF8) + 3) & 0x40) == 0)
      && (*(_WORD *)(a2 + 30) & 0x2000) == 0)
    {
      if (!v9)
      {
        unint64_t v10 = (unint64_t)isa & 0xFF80000000000007;
        if (!isa) {
          unint64_t v10 = 0x100000000000001;
        }
        unint64_t v6 = a2 & 0x7FFFFFFFFFFFF8 | v10;
        goto LABEL_13;
      }
LABEL_31:
      _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", a2, a3, a4, a2);
    }
    if (isa) {
      break;
    }
    while (1)
    {
      if (v9) {
        goto LABEL_31;
      }
      unint64_t v6 = v6 & 0xFF80000000000007 | (8 * ((a2 >> 3) & 0xFFFFFFFFFFFFFLL));
LABEL_13:
      int v11 = isa;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)this, (unint64_t *)&v11, v6, memory_order_relaxed, memory_order_relaxed);
      if (v11 == isa)
      {
        if ((v7 & 1) == 0) {
          return (unint64_t)isa & 0xFFFFFFFF8;
        }
        uint64_t v12 = ((this >> 4) ^ (this >> 9)) & 7;
        goto LABEL_28;
      }
LABEL_14:
      Class isa = v11;
      if (!v11) {
        break;
      }
LABEL_2:
      if (isa) {
        goto LABEL_3;
      }
    }
  }
  if ((v7 & 1) == 0) {
    objc_object::sidetable_lock(this);
  }
  if (v9) {
    goto LABEL_31;
  }
  unint64_t v6 = v6 & 0xFF80000000000007 | (8 * ((a2 >> 3) & 0xFFFFFFFFFFFFFLL));
  int v11 = isa;
  atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)this, (unint64_t *)&v11, v6, memory_order_relaxed, memory_order_relaxed);
  if (v11 != isa)
  {
    char v7 = 1;
    goto LABEL_14;
  }
  uint64_t v12 = ((this >> 4) ^ (this >> 9)) & 7;
  uint64_t v19 = -(uint64_t)this;
  uint64_t v14 = (((unint64_t)isa >> 54) & 0x3FC) - 4;
  unint64_t v15 = *v13 + v14;
  if (__CFADD__(*v13, v14)) {
    unint64_t v15 = 0x8000000000000000;
  }
  if (!((unint64_t)isa >> 55)) {
    v15 |= 2uLL;
  }
  *unint64_t v13 = v15 | ((unint64_t)isa >> 2) & 1;
LABEL_28:
  int v16 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  int v17 = v16;
  if (v17 != v16) {
  return (unint64_t)isa & 0xFFFFFFFF8;
  }
}

Class object_setClass(Class result, Class a2)
{
  if (result)
  {
    BOOL v5 = (objc_object *)result;
    int v6 = *(_DWORD *)(*((void *)a2 + 4) & 0xF00007FFFFFFFF8);
    if ((unint64_t)(*(void *)a2 - 1) < 0xF || (v6 & 0x40000000) == 0)
    {
      if ((v6 & 1) == 0) {
        int v6 = *(_DWORD *)(*(void *)((*(void *)a2 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
      }
      if ((v6 & 0x20000000) == 0) {
        lookUpImpOrNilTryCache(0, (unint64_t)sel_initialize, a2, 1);
      }
    }
    return (Class)objc_object::changeIsa(v5, (unint64_t)a2, v2, v3);
  }
  return result;
}

objc_object *objc_opt_respondsToSelector(objc_object *result, objc_selector *a2)
{
  if (result)
  {
    if (((unint64_t)result & 0x8000000000000000) != 0)
    {
      uint64_t v2 = objc_debug_taggedpointer_classes[result & 7];
      if ((__objc2_class *)v2 == __NSUnrecognizedTaggedPointer) {
        uint64_t v2 = objc_debug_taggedpointer_ext_classes[((unint64_t)result >> 55)];
      }
    }
    else
    {
      uint64_t v2 = (uint64_t)result->isa & 0x7FFFFFFFFFFFF8;
    }
    if (*(__int16 *)(v2 + 30) < 0) {
      return (objc_object *)class_respondsToSelector_inst(result, a2, (void *)v2);
    }
    else {
      return (objc_object *)[(objc_object *)result respondsToSelector:a2];
    }
  }
  return result;
}

SEL sel_registerName(const char *str)
{
  return (SEL)__sel_registerName((char *)str, 1, 1);
}

BOOL class_respondsToSelector(Class cls, SEL sel)
{
  return class_respondsToSelector_inst(0, (objc_selector *)sel, cls);
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  if (offset)
  {
    id v6 = [newValue copyWithZone:0];
    char v7 = *(void **)((char *)self + offset);
    *(void *)((char *)self + offset) = v6;
  }
  else
  {
    object_setClass(self, (Class)newValue);
  }
}

uint64_t list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<true>::iteratorImpl(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::ListIterator::ListIterator(a1, a2);
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::ListIterator::ListIterator(v6 + 32, (uint64_t)a3);
  uint64_t v9 = **(void **)a2;
  if (*(void *)a2 != *a3) {
    goto LABEL_2;
  }
  if (!v9) {
    goto LABEL_12;
  }
  if ((**(void **)a2 & 3) == 2)
  {
    uint64_t v23 = *(void *)(a2 + 24);
    uint64_t v24 = a3[3];
    goto LABEL_47;
  }
  if ((**(void **)a2 & 3) == 1)
  {
    uint64_t v23 = *(void *)(a2 + 8);
    uint64_t v24 = a3[1];
LABEL_47:
    if (v23 == v24) {
      goto LABEL_41;
    }
    goto LABEL_3;
  }
  if ((v9 & 3) != 0)
  {
LABEL_3:
    uint64_t v10 = **(void **)a2 & 3;
    if (v10 == 2)
    {
      uint64_t v13 = *(void *)(a2 + 24) + (**(uint64_t **)(a2 + 24) >> 16);
      if (!v13)
      {
        int v11 = 0;
        goto LABEL_21;
      }
      goto LABEL_18;
    }
    if (v10 == 1)
    {
      int v11 = **(unsigned int ***)(a2 + 8);
      if (!v11) {
        goto LABEL_21;
      }
      goto LABEL_17;
    }
    if (v10)
    {
      int v11 = 0;
      goto LABEL_21;
    }
LABEL_6:
    int v11 = *(unsigned int **)(a2 + 8);
    if (!v11) {
      goto LABEL_21;
    }
LABEL_17:
    uint64_t v13 = (uint64_t)v11;
LABEL_18:
    int v11 = (unsigned int *)v13;
LABEL_21:
    unint64_t v14 = *v11;
    uint64_t v25 = (unsigned __int16)v14 & 0xFFFC;
    uint64_t v15 = v14 >> 31;
    if ((uint64_t)v11 < 0) {
      uint64_t v15 = 2;
    }
    unint64_t v16 = v15 | (unint64_t)(v11 + 2) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v26 = v16;
    *(void *)(a1 + 64) = v25;
    if (v16) {
      unint64_t v16 = v15 | (unint64_t)(v11 + 2) & 0xFFFFFFFFFFFFFFFCLL;
    }
    *(void *)(a1 + 72) = v16;
    uint64_t v17 = **(void **)a2;
    if (v17)
    {
      if ((**(void **)a2 & 3) == 2)
      {
        uint64_t v19 = *(void *)(a2 + 24) + (**(uint64_t **)(a2 + 24) >> 16);
        if (!v19)
        {
          unint64_t v18 = 0;
LABEL_36:
          if (v18) {
            unint64_t v20 = v18;
          }
          else {
            unint64_t v20 = 0;
          }
          goto LABEL_40;
        }
LABEL_35:
        unint64_t v18 = (unsigned int *)v19;
        goto LABEL_36;
      }
      if ((**(void **)a2 & 3) == 1)
      {
        unint64_t v18 = **(unsigned int ***)(a2 + 8);
        if (!v18) {
          goto LABEL_36;
        }
        goto LABEL_34;
      }
      if ((v17 & 3) != 0)
      {
        unint64_t v20 = 0;
LABEL_40:
        entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::signedEnd((uint64_t)&v25, v20, v7, v8);
        unint64_t v21 = v26;
        *(void *)(a1 + 80) = v25;
        *(void *)(a1 + 88) = v21;
        goto LABEL_41;
      }
    }
    unint64_t v18 = *(unsigned int **)(a2 + 8);
    if (!v18) {
      goto LABEL_36;
    }
LABEL_34:
    uint64_t v19 = (uint64_t)v18;
    goto LABEL_35;
  }
LABEL_12:
  if (*(void *)(a2 + 8)) {
    uint64_t v12 = *(void *)(a2 + 8);
  }
  else {
    uint64_t v12 = 0;
  }
  if (v12 != a3[1])
  {
LABEL_2:
    if (!v9) {
      goto LABEL_6;
    }
    goto LABEL_3;
  }
LABEL_41:
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::skipEmptyLists((uint64_t **)a1);
  return a1;
}

void _finishInitializing(objc_class *a1, objc_class *a2)
{
  if (PrintInitializing)
  {
    BOOL v32 = *(const void **)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    BOOL v33 = objc_class::nameForLogging(a1);
    _objc_inform("INITIALIZE: thread %p: %s is fully +initialized", v32, v33);
  }
  int v3 = 0;
  uint64_t v4 = *(void *)a1;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v3, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v3) {
    os_unfair_lock_lock_with_options();
  }
  objc::Scanner::scanAddedClassImpl((__objc2_class *)a1, 0);
  uint64_t v6 = v4 & 0xFFFFFFFF8;
  objc::Scanner::scanAddedClassImpl((__objc2_class *)v6, (objc_class *)1);
  cache_t::maybeConvertToPreoptimized((objc_class *)((char *)a1 + 16));
  cache_t::maybeConvertToPreoptimized((cache_t *)(v6 + 16));
  if (PrintInitializing)
  {
    uint64_t v10 = objc_class::nameForLogging(a1);
    _objc_inform("INITIALIZE: thread %p: setInitialized(%s)", *(const void **)StatusReg, v10);
  }
  int v11 = (atomic_uint *)(*(void *)(v6 + 32) & 0xF00007FFFFFFFF8);
  do
  {
    atomic_uint v12 = *v11;
    atomic_uint v13 = *v11;
    atomic_compare_exchange_strong(v11, (unsigned int *)&v13, *v11 & 0xCFFFFFFF | 0x20000000);
  }
  while (v13 != v12);
  int v14 = *(_DWORD *)(StatusReg + 24);
  int v15 = v14;
  atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v15, 0, memory_order_release, memory_order_relaxed);
  if (v15 != v14) {
    os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
  }
  unlockClass(a1, v7, v8, v9);
  InitializingClassList = _fetchInitializingClassList(0);
  if (!InitializingClassList) {
    goto LABEL_19;
  }
  if ((unint64_t)(*(void *)a1 - 1) < 0xF
    || (unint64_t v20 = a1, (*(unsigned char *)(*((void *)a1 + 4) & 0xF00007FFFFFFFF8) & 1) == 0))
  {
    unint64_t v20 = (objc_class *)(*(void *)a1 & 0xFFFFFFFF8);
  }
  uint64_t v21 = *(unsigned int *)InitializingClassList;
  if ((int)v21 < 1) {
LABEL_19:
  }
    _objc_fatal("thread is not initializing this class!", (uint64_t)v17, v18, v19);
  uint64_t v22 = 0;
  uint64_t v23 = InitializingClassList[1];
  while (v20 != *(objc_class **)(v23 + 8 * v22))
  {
    if (v21 == ++v22) {
      goto LABEL_19;
    }
  }
  *(void *)(v23 + 8 * v22) = 0;
  uint64_t v24 = (int32x2_t *)pendingInitializeMap;
  if (pendingInitializeMap)
  {
    uint64_t v25 = *(void *)pendingInitializeMap;
    if (*(void *)pendingInitializeMap) {
      unint64_t v26 = *(void **)pendingInitializeMap;
    }
    else {
      unint64_t v26 = 0;
    }
    uint64_t v27 = *(unsigned int *)(pendingInitializeMap + 16);
    if (v27)
    {
      LODWORD(v28) = (v27 - 1) & (bswap64(0x8A970BE7488FDA55 * ((unint64_t)a1 ^ ((unint64_t)a1 >> 4))) ^ (1217387093 * (a1 ^ ((unint64_t)a1 >> 4))));
      uint64_t v29 = (uint64_t)&v26[2 * v28];
      unint64_t v30 = *(objc_class **)v29;
      if (*(objc_class **)v29 == a1)
      {
        if (!v25)
        {
LABEL_27:
          uint64_t v31 = 0;
          goto LABEL_37;
        }
        goto LABEL_36;
      }
      unsigned int v34 = 1;
      while (v30 != (objc_class *)-1)
      {
        if (v34 > v27) {
          objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::FatalCorruptHashTables(pendingInitializeMap, v26, v27);
        }
        int v35 = v28 + v34++;
        uint64_t v28 = v35 & (v27 - 1);
        unint64_t v30 = (objc_class *)v26[2 * v28];
        if (v30 == a1)
        {
          uint64_t v29 = (uint64_t)&v26[2 * v28];
          if (v25) {
            goto LABEL_36;
          }
          goto LABEL_27;
        }
      }
    }
    if (!v25)
    {
      uint64_t v31 = 0;
      uint64_t v29 = 16 * v27;
LABEL_37:
      if (v31 + 16 * v27 != v29)
      {
        uint64_t v36 = *(void *)(v29 + 8);
        *(void *)uint64_t v29 = -2;
        int32x2_t v37 = vadd_s32(v24[1], (int32x2_t)0x1FFFFFFFFLL);
        v24[1] = v37;
        unsigned int v38 = v24[2].u32[0];
        if (v37.i32[0])
        {
          if (v38 >= 0x401 && v38 >> 4 > v37.i32[0]) {
            objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::grow((uint64_t)v24, 2 * v37.i32[0]);
          }
        }
        else if (v38)
        {
          if (*v24) {
            uint64_t v39 = (void *)*v24;
          }
          else {
            uint64_t v39 = 0;
          }
          free(v39);
          objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::init(v24, 0);
        }
        else
        {
          v24[1] = 0;
        }
        unint64_t v40 = (void *)pendingInitializeMap;
        if (!*(_DWORD *)(pendingInitializeMap + 8))
        {
          if (*(void *)pendingInitializeMap) {
            unint64_t v41 = *(void **)pendingInitializeMap;
          }
          else {
            unint64_t v41 = 0;
          }
          free(v41);
          free(v40);
          pendingInitializeMap = 0;
        }
        if (v36)
        {
          do
          {
            uint64_t v42 = *(void *)(v36 + 8);
            if (*(void *)v36) {
              _finishInitializing(*(objc_class **)v36, v17);
            }
            free((void *)v36);
            uint64_t v36 = v42;
          }
          while (v42);
        }
      }
      return;
    }
    uint64_t v29 = v25 + 16 * v27;
LABEL_36:
    uint64_t v31 = *(void *)pendingInitializeMap;
    goto LABEL_37;
  }
}

void sub_180111EEC(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void objc::Scanner::scanAddedClassImpl(__objc2_class *this, objc_class *a2)
{
  unint64_t v3 = ((unint64_t)objc::NSObjectSwizzledMask >> (char)a2) & 0x15;
  int v4 = NSObject;
  if (a2) {
    int v4 = &OBJC_METACLASS___NSObject;
  }
  if (v4 != this)
  {
    superclass = this->superclass;
    if (!superclass)
    {
      BOOL v7 = 0;
      int v10 = 0;
      BOOL v9 = 0;
      LOBYTE(v3) = 21;
      goto LABEL_19;
    }
    unsigned int vtable_high = HIWORD(superclass->vtable);
    BOOL v7 = (vtable_high & 0x4000) == 0;
    int v8 = v3 | v7;
    BOOL v9 = ((uint64_t)superclass->info & 4) == 0;
    if (((uint64_t)superclass->info & 4) == 0) {
      int v8 = v3 | v7 | 4;
    }
    int v10 = (vtable_high >> 15) ^ 1;
    if ((vtable_high & 0x8000u) != 0) {
      LODWORD(v3) = v8;
    }
    else {
      LODWORD(v3) = v8 | 0x10;
    }
    if (v3 == 21) {
      goto LABEL_19;
    }
    class_rw_t::methods(&v94, (uint64_t)this->info & 0xF00007FFFFFFFF8);
    unint64_t v80 = (unint64_t **)&v94;
    if (v94)
    {
      unint64_t v14 = v94 & 3;
      if ((v94 & 3) != 0)
      {
        if (v94 > 3)
        {
          if (v14 != 2)
          {
            if (v14 == 1 && (v94 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
              unint64_t v81 = (v94 & 0xFFFFFFFFFFFFFFFCLL) + 8;
            }
            goto LABEL_54;
          }
          uint64_t v19 = (unint64_t *)(v94 & 0xFFFFFFFFFFFFFFFCLL);
          if ((v94 & 0xFFFFFFFFFFFFFFFCLL) != 0)
          {
            if (!DisablePreattachedCategories)
            {
              uint64_t v55 = (unsigned __int16 *)(v19 + 1);
              unint64_t v56 = *(unsigned int *)v19;
              uint64_t v20 = *((unsigned int *)v19 + 1);
              unint64_t v22 = v56;
              goto LABEL_125;
            }
            unint64_t v22 = *(unsigned int *)v19;
            uint64_t v60 = *((unsigned int *)v19 + 1);
            unint64_t v71 = v60 * (unint64_t)v22;
            if ((v71 & 0xFFFFFFFF00000000) == 0)
            {
              unint64_t v72 = v22 | (v60 << 32);
              uint64_t v73 = (uint64_t)v19 + v71 + 8;
              unint64_t v74 = v22 | ((unint64_t)(v60 - 1) << 32);
              BOOL v75 = v60 == 0;
              if (v60) {
                uint64_t v20 = v60;
              }
              else {
                uint64_t v20 = 0;
              }
              if (v60) {
                uint64_t v55 = (unsigned __int16 *)(v73 - v22);
              }
              else {
                uint64_t v55 = (unsigned __int16 *)v73;
              }
              if (v75) {
                unint64_t v56 = v72;
              }
              else {
                unint64_t v56 = v74;
              }
LABEL_125:
              unint64_t v57 = v20 * (unint64_t)v22;
              if ((v57 & 0xFFFFFFFF00000000) == 0)
              {
                unint64_t v58 = HIDWORD(v56);
                for (unint64_t i = (unint64_t)v19 + v57 + 8;
                      (unint64_t)v55 < i;
                      unint64_t v58 = (v58 + 1))
                {
                  if (*(void *)(objc_debug_headerInfoRWs + 8 * *v55 + 8)) {
                    break;
                  }
                  uint64_t v55 = (unsigned __int16 *)((char *)v55 + v56);
                }
                unint64_t v81 = v94 & 0xFFFFFFFFFFFFFFFCLL;
                unint64_t v82 = v56 | (v58 << 32);
                unint64_t v83 = v55;
LABEL_56:
                unint64_t v76 = (unint64_t **)&v94;
                if (!v94) {
                  goto LABEL_60;
                }
                goto LABEL_57;
              }
LABEL_166:
              _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v11, v12, v13, v20, v19, v22, v76);
            }
LABEL_168:
            _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v11, v12, v13, v60, v19, v22, v76);
          }
LABEL_54:
          unint64_t v76 = (unint64_t **)&v94;
LABEL_57:
          if ((v94 & 3) == 2)
          {
            unint64_t v30 = (unsigned int *)(v94 & 0xFFFFFFFFFFFFFFFCLL);
            if ((v94 & 0xFFFFFFFFFFFFFFFCLL) != 0)
            {
              uint64_t v32 = *v30;
              uint64_t v31 = v30[1];
              unint64_t v33 = v31 * (unint64_t)v32;
              if ((v33 & 0xFFFFFFFF00000000) != 0) {
                _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v11, v12, v13, v31, v30, *v30, v76);
              }
              unint64_t v77 = v94 & 0xFFFFFFFFFFFFFFFCLL;
              uint64_t v78 = v32 | (v31 << 32);
              uint64_t v79 = (uint64_t)v30 + v33 + 8;
            }
            goto LABEL_74;
          }
          if ((v94 & 3) == 1)
          {
            if ((v94 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
              unint64_t v77 = (v94 & 0xFFFFFFFFFFFFFFFCLL) + 8 * *(unsigned int *)(v94 & 0xFFFFFFFFFFFFFFFCLL) + 8;
            }
            goto LABEL_74;
          }
          if ((v94 & 3) != 0)
          {
LABEL_74:
            char v34 = objc::Scanner::scanMethodLists<list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::ListIterator>((uint64_t)&v80, (uint64_t)&v76);
            goto LABEL_105;
          }
LABEL_60:
          unint64_t v77 = 0;
          goto LABEL_74;
        }
      }
      else if ((v94 & 0xFFFFFFFFFFFFFFFCLL) != 0)
      {
        unint64_t v81 = v94 & 0xFFFFFFFFFFFFFFFCLL;
        goto LABEL_54;
      }
    }
    unint64_t v81 = 0;
    goto LABEL_56;
  }
  p_unint64_t info = &this->info;
  class_rw_t::methods(&v89, (uint64_t)this->info & 0xF00007FFFFFFFF8);
  unint64_t v85 = &v89;
  if (!v89) {
    goto LABEL_31;
  }
  unint64_t v18 = v89 & 3;
  if ((v89 & 3) == 0)
  {
    if ((v89 & 0xFFFFFFFFFFFFFFFCLL) != 0)
    {
      unint64_t v86 = v89 & 0xFFFFFFFFFFFFFFFCLL;
      goto LABEL_30;
    }
LABEL_31:
    unint64_t v86 = 0;
    goto LABEL_32;
  }
  if (v89 <= 3) {
    goto LABEL_31;
  }
  if (v18 != 2)
  {
    if (v18 == 1 && (v89 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
      unint64_t v86 = (v89 & 0xFFFFFFFFFFFFFFFCLL) + 8;
    }
    goto LABEL_30;
  }
  uint64_t v19 = (unint64_t *)(v89 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v89 & 0xFFFFFFFFFFFFFFFCLL) == 0)
  {
LABEL_30:
    uint64_t v19 = &v89;
    unint64_t v94 = (unint64_t)&v89;
    goto LABEL_33;
  }
  if (DisablePreattachedCategories)
  {
    unint64_t v22 = *(unsigned int *)v19;
    uint64_t v60 = *((unsigned int *)v19 + 1);
    unint64_t v66 = v60 * (unint64_t)v22;
    if ((v66 & 0xFFFFFFFF00000000) != 0) {
      goto LABEL_168;
    }
    unint64_t v67 = v22 | (v60 << 32);
    uint64_t v68 = (uint64_t)v19 + v66 + 8;
    unint64_t v69 = v22 | ((unint64_t)(v60 - 1) << 32);
    BOOL v70 = v60 == 0;
    if (v60) {
      uint64_t v20 = v60;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v60) {
      unint64_t v16 = (unint64_t *)(v68 - v22);
    }
    else {
      unint64_t v16 = (unint64_t *)v68;
    }
    if (v70) {
      unint64_t v26 = v67;
    }
    else {
      unint64_t v26 = v69;
    }
  }
  else
  {
    unint64_t v16 = v19 + 1;
    unint64_t v26 = *(unsigned int *)v19;
    uint64_t v20 = *((unsigned int *)v19 + 1);
    unint64_t v22 = v26;
  }
  unint64_t v27 = v20 * (unint64_t)v22;
  if ((v27 & 0xFFFFFFFF00000000) != 0) {
    goto LABEL_166;
  }
  unint64_t v28 = HIDWORD(v26);
  unint64_t v29 = (unint64_t)v19 + v27 + 8;
  for (j = v26; (unint64_t)v16 < v29; unint64_t v28 = (v28 + 1))
  {
    if (*(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v16 + 8)) {
      break;
    }
    unint64_t v16 = (unint64_t *)((char *)v16 + v26);
  }
  unint64_t v86 = v89 & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v87 = v26 | (v28 << 32);
  uint64_t v88 = v16;
LABEL_32:
  uint64_t v19 = &v89;
  unint64_t v94 = (unint64_t)&v89;
  if (!v89) {
    goto LABEL_41;
  }
LABEL_33:
  unint64_t v16 = (unint64_t *)(v89 & 3);
  if ((v89 & 3) == 0)
  {
    if ((v89 & 0xFFFFFFFFFFFFFFFCLL) != 0)
    {
      uint64_t v19 = (unint64_t *)(v89 & 0xFFFFFFFFFFFFFFFCLL);
      unint64_t v95 = v89 & 0xFFFFFFFFFFFFFFFCLL;
      goto LABEL_75;
    }
LABEL_41:
    uint64_t v19 = 0;
    unint64_t v95 = 0;
    goto LABEL_42;
  }
  if (v89 <= 3) {
    goto LABEL_41;
  }
  if (v16 != (unint64_t *)2)
  {
    if (v16 == (unint64_t *)1)
    {
      uint64_t v19 = (unint64_t *)(v89 & 0xFFFFFFFFFFFFFFFCLL);
      if ((v89 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
        unint64_t v95 = (unint64_t)++v19;
      }
    }
    goto LABEL_75;
  }
  uint64_t v19 = (unint64_t *)(v89 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v89 & 0xFFFFFFFFFFFFFFFCLL) == 0)
  {
LABEL_75:
    unint64_t v16 = &v89;
    v90 = &v89;
    goto LABEL_76;
  }
  if (DisablePreattachedCategories)
  {
    unint64_t v22 = *(unsigned int *)v19;
    uint64_t v60 = *((unsigned int *)v19 + 1);
    unint64_t v61 = v60 * (unint64_t)v22;
    if ((v61 & 0xFFFFFFFF00000000) != 0) {
      goto LABEL_168;
    }
    unint64_t v62 = v22 | (v60 << 32);
    uint64_t v63 = (uint64_t)v19 + v61 + 8;
    unint64_t v64 = v22 | ((unint64_t)(v60 - 1) << 32);
    BOOL v65 = v60 == 0;
    if (v60) {
      uint64_t v20 = v60;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v60) {
      unint64_t v16 = (unint64_t *)(v63 - v22);
    }
    else {
      unint64_t v16 = (unint64_t *)v63;
    }
    if (v65) {
      unint64_t v21 = v62;
    }
    else {
      unint64_t v21 = v64;
    }
  }
  else
  {
    unint64_t v16 = v19 + 1;
    unint64_t v21 = *(unsigned int *)v19;
    uint64_t v20 = *((unsigned int *)v19 + 1);
    unint64_t v22 = v21;
  }
  unint64_t v23 = v20 * (unint64_t)v22;
  if ((v23 & 0xFFFFFFFF00000000) != 0) {
    goto LABEL_166;
  }
  unint64_t v24 = HIDWORD(v21);
  unint64_t v25 = (unint64_t)v19 + v23 + 8;
  for (j = v21; (unint64_t)v16 < v25; unint64_t v24 = (v24 + 1))
  {
    if (*(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v16 + 8)) {
      break;
    }
    unint64_t v16 = (unint64_t *)((char *)v16 + v21);
  }
  unint64_t v95 = v89 & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v96 = v21 | (v24 << 32);
  v97 = v16;
LABEL_42:
  v90 = &v89;
  if (!v89) {
    goto LABEL_83;
  }
LABEL_76:
  unint64_t v35 = v89 & 3;
  if ((v89 & 3) == 0)
  {
LABEL_83:
    unint64_t v91 = 0;
    if (!v19) {
      goto LABEL_104;
    }
    goto LABEL_89;
  }
  if (v35 == 2)
  {
    int32x2_t v37 = (unsigned int *)(v89 & 0xFFFFFFFFFFFFFFFCLL);
    if ((v89 & 0xFFFFFFFFFFFFFFFCLL) != 0)
    {
      uint64_t v39 = *v37;
      uint64_t v38 = v37[1];
      unint64_t v40 = v38 * (unint64_t)v39;
      if ((v40 & 0xFFFFFFFF00000000) != 0) {
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v11, v12, v13, v38, v37, *v37, v76);
      }
      uint64_t j = (uint64_t)v37 + v40 + 8;
      unint64_t v91 = v89 & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v92 = v39 | (v38 << 32);
      v93 = (unsigned __int16 *)j;
    }
    if (v16 == (unint64_t *)j) {
      goto LABEL_104;
    }
  }
  else if (v35 == 1)
  {
    uint64_t v36 = (unint64_t *)(v89 & 0xFFFFFFFFFFFFFFFCLL);
    if ((v89 & 0xFFFFFFFFFFFFFFFCLL) != 0)
    {
      v36 += *(unsigned int *)v36 + 1;
      unint64_t v91 = (unint64_t)v36;
    }
    if (v19 == v36) {
      goto LABEL_104;
    }
  }
LABEL_89:
  unint64_t v41 = *(void *)(class_rw_t::ro((class_rw_t *)(*p_info & 0xF00007FFFFFFFF8)) + 32);
  if (v41) {
    BOOL v42 = (v41 & 1) == 0;
  }
  else {
    BOOL v42 = 0;
  }
  if (v42 || (v41) && v41 >= 2)
  {
    unint64_t v43 = *v90;
    if (*v90)
    {
      if ((*v90 & 3) != 1)
      {
        if ((v43 & 3) == 0 && (v43 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
          unint64_t v91 = v43 & 0xFFFFFFFFFFFFFFFCLL;
        }
        goto LABEL_101;
      }
      v91 -= 8;
      unint64_t v43 = *v90;
      if (*v90)
      {
LABEL_101:
        if ((v43 & 3) == 2)
        {
          int v44 = HIDWORD(v92) - 1;
          BOOL v45 = (unsigned __int16 *)((char *)v93 - v92);
          do
          {
            v93 = v45;
            HIDWORD(v92) = v44;
            uint64_t v46 = *(void *)(objc_debug_headerInfoRWs + 8 * *v45 + 8);
            --v44;
            BOOL v45 = (unsigned __int16 *)((char *)v45 - v92);
          }
          while ((v46 & 1) == 0);
        }
      }
    }
  }
LABEL_104:
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::ListIterator::ListIterator((uint64_t)v84, (uint64_t)&v90);
  char v34 = objc::Scanner::scanMethodLists<list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::ListIterator>((uint64_t)&v85, (uint64_t)v84);
  BOOL v9 = 0;
  int v10 = 0;
  BOOL v7 = 0;
LABEL_105:
  LOBYTE(v3) = v34 | v3;
  if ((v3 & 1) == 0)
  {
    atomic_fetch_or_explicit((atomic_ushort *volatile)&this->vtable + 3, 0x4000u, memory_order_relaxed);
    goto LABEL_107;
  }
LABEL_19:
  atomic_fetch_and_explicit((atomic_ushort *volatile)&this->vtable + 3, 0xBFFFu, memory_order_relaxed);
  if (PrintCustomAWZ) {
    objc::Scanner::printCustom("CUSTOM AWZ", (objc_class *)this, v7);
  }
LABEL_107:
  BOOL v47 = (atomic_ullong *)&this->info;
  unint64_t info = (unint64_t)this->info;
  if ((v3 & 4) != 0)
  {
    if (!info) {
      goto LABEL_110;
    }
LABEL_109:
    for (unint64_t k = info; ; unint64_t k = 0x8000000000000000)
    {
      unint64_t v50 = k & 0xFFFFFFFFFFFFFFFBLL;
      unint64_t v51 = info;
      atomic_compare_exchange_strong_explicit(v47, &v51, v50, memory_order_release, memory_order_relaxed);
      if (v51 == info) {
        break;
      }
      unint64_t info = v51;
      if (v51) {
        goto LABEL_109;
      }
LABEL_110:
      ;
    }
    if (PrintCustomRR) {
      objc::Scanner::printCustom("CUSTOM RR", (objc_class *)this, v9);
    }
  }
  else
  {
    while (1)
    {
      unint64_t v52 = info ? info : 0x8000000000000000;
      unint64_t v53 = v52 | 4;
      unint64_t v54 = info;
      atomic_compare_exchange_strong_explicit(v47, &v54, v53, memory_order_release, memory_order_relaxed);
      if (v54 == info) {
        break;
      }
      unint64_t info = v54;
    }
  }
  if ((v3 & 0x10) == 0 || objc::Scanner::isSwiftObject((objc::Scanner *)this, a2))
  {
    atomic_fetch_or_explicit((atomic_ushort *volatile)&this->vtable + 3, 0x8000u, memory_order_relaxed);
  }
  else
  {
    atomic_fetch_and_explicit((atomic_ushort *volatile)&this->vtable + 3, 0x7FFFu, memory_order_relaxed);
    if (PrintCustomCore) {
      objc::Scanner::printCustom("CUSTOM Core", (objc_class *)this, v10);
    }
  }
}

unint64_t *class_rw_t::methods(unint64_t *this, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if ((v2 & 1) == 0)
  {
    if (v2) {
      unint64_t v3 = v2 & 0xFFFFFFFFFFFFFFFELL;
    }
    else {
      unint64_t v3 = 0;
    }
    uint64_t v5 = *(void *)(v3 + 32);
    if (v5) {
      BOOL v6 = (*(void *)(v3 + 32) & 1) == 0;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6)
    {
      unint64_t v7 = v5 & 0xFFFFFFFFFFFFFFFELL;
      if ((v5 & 0xFFFFFFFFFFFFFFFELL) != 0) {
        goto LABEL_14;
      }
    }
    else if ((v5 & 1) != 0 && (v5 & 0xFFFFFFFFFFFFFFFELL) != 0)
    {
      unint64_t v7 = v5 & 0xFFFFFFFFFFFFFFFCLL | 2;
LABEL_14:
      unint64_t v4 = v7;
      goto LABEL_16;
    }
    unint64_t v4 = 0;
    goto LABEL_16;
  }
  *this = 0;
  unint64_t v4 = *(void *)((v2 & 0xFFFFFFFFFFFFFFFELL) + 8);
LABEL_16:
  *this = v4;
  return this;
}

void cache_t::maybeConvertToPreoptimized(cache_t *this)
{
  uint64_t v2 = *(void *)this & 0xFFFFFFFFFFFLL;
  uint64_t v3 = *(void *)(v2 + 8);
  if (v3 < 0)
  {
    if (*((_DWORD *)this + 2) != (HIDWORD(v1) ^ v1))
    {
      __break(1u);
      JUMPOUT(0x180112B9CLL);
    }
    uint64_t v5 = *((void *)this + 2);
    BOOL v6 = (cache_t *)((char *)this - 16);
    int v7 = *(_DWORD *)(v5 & 0xF00007FFFFFFFF8);
    if ((v7 & 2) != 0 || (v7 & 4) != 0 && (v3 & 0x40000000) != 0)
    {
      if (PrintCaches)
      {
        if ((*((_WORD *)this + 7) & 4) != 0) {
          BOOL v9 = "meta";
        }
        else {
          BOOL v9 = "";
        }
        int v10 = objc_class::nameForLogging(v6);
        _objc_inform("CACHES: %sclass %s: dropping cache (from %s)", v9, v10, "setInitialized");
      }
      __int16 v8 = 0;
      atomic_store((unint64_t)&_objc_empty_cache & 0xFFFFFFFFFFFLL, (unint64_t *)this);
    }
    else
    {
      *(void *)this = ((((*(void *)(v2 + 8) & 0x1FLL) << 55) | ((unint64_t)__clz((unsigned __int16)*(void *)(v2 + 8) >> 5) << 60))
                       - 0x1000000000000000) | (v2 + 16) | 1;
      __int16 v8 = *(_WORD *)(v2 + 10) & 0x3FFF;
    }
    *((_WORD *)this + 6) = v8;
  }
}

uint64_t objc::Scanner::scanMethodLists<list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::ListIterator>(uint64_t a1, uint64_t a2)
{
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::ListIterator::ListIterator((uint64_t)&v89, a1);
  uint64_t result = 0;
  unint64_t v4 = (void *)(a2 + 8);
  int v5 = v92;
  BOOL v6 = (char *)(2 * v91);
  int v7 = v93;
  uint64_t v8 = *v89;
  while (1)
  {
LABEL_2:
    if (v8)
    {
      if ((v8 & 3) == 2)
      {
        if ((unint64_t)v7 >= *(void *)(a2 + 24)) {
          return result;
        }
        goto LABEL_13;
      }
      if ((v8 & 3) == 1)
      {
        if ((unint64_t)v90 >= *v4) {
          return result;
        }
        goto LABEL_13;
      }
      if ((v8 & 3) != 0) {
        return result;
      }
    }
    if (!v90 || *v4) {
      return result;
    }
    if (!v8) {
      goto LABEL_16;
    }
LABEL_13:
    char v9 = v8;
    uint64_t v10 = v8 & 3;
    if ((v9 & 3) == 2)
    {
      uint64_t v11 = (unsigned int *)((char *)v7 + (*v7 >> 16));
      if (!v11) {
        goto LABEL_23;
      }
    }
    else
    {
      if (v10 != 1)
      {
        if (v10) {
          goto LABEL_23;
        }
LABEL_16:
        uint64_t v11 = v90;
        if (!v90) {
          goto LABEL_23;
        }
        goto LABEL_21;
      }
      uint64_t v11 = *(unsigned int **)v90;
      if (!*(void *)v90) {
        goto LABEL_23;
      }
    }
LABEL_21:
    if (v11)
    {
      unint64_t v12 = (unint64_t)v11;
      goto LABEL_24;
    }
LABEL_23:
    unint64_t v12 = 0;
LABEL_24:
    uint64_t v8 = *v89;
    if (*v89)
    {
      if ((v8 & 3) != 0)
      {
        if ((*v89 & 3) != 1) {
          goto LABEL_31;
        }
        atomic_uint v13 = v90 + 2;
      }
      else
      {
        atomic_uint v13 = 0;
      }
      v90 = v13;
      uint64_t v8 = *v89;
      if (*v89)
      {
LABEL_31:
        if ((v8 & 3) == 2)
        {
          unint64_t v14 = (unint64_t)v7 + v91;
          v93 = (uint64_t *)v14;
          uint64_t v16 = *v90;
          uint64_t v15 = v90[1];
          unint64_t v17 = v15 * (unint64_t)v16;
          int v92 = ++v5;
          if ((v17 & 0xFFFFFFFF00000000) != 0) {
            _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)sel_alloc, sel_retain, v6, sel_allocWithZone_, sel_release, sel_autorelease, sel__tryRetain, v15, v90, v16);
          }
          while (1)
          {
            if (v14 >= (unint64_t)v90 + v17 + 8)
            {
              int v7 = (uint64_t *)v14;
              goto LABEL_38;
            }
            if (*(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)((char *)v7 + v91) + 8)) {
              break;
            }
            v93 = (uint64_t *)&v6[(void)v7];
            int v92 = ++v5;
            int v7 = (uint64_t *)((char *)v7 + v91);
            unint64_t v14 = (unint64_t)v7 + v91;
          }
          int v7 = (uint64_t *)((char *)v7 + v91);
        }
      }
    }
    else
    {
      v90 = 0;
    }
LABEL_38:
    int v18 = *(_DWORD *)v12;
    if ((v12 & 0x8000000000000000) != 0)
    {
      uint64_t v40 = (unsigned __int16)v18 & 0xFFFC;
      uint64_t v41 = *(unsigned int *)(v12 + 4);
      unint64_t v42 = v41 * (unint64_t)v40;
      if ((v42 & 0xFFFFFFFF00000000) != 0) {
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)sel_alloc, sel_retain, v6, sel_allocWithZone_, sel_release, sel_autorelease, sel__tryRetain, v41, v12, v40);
      }
      unint64_t v43 = v12 + 8;
      unint64_t v44 = v43 & 0xFFFFFFFFFFFFFFFCLL | 2;
      unint64_t v45 = (v43 + v42) & 0xFFFFFFFFFFFFFFFCLL | 2;
      while (v44 != v45)
      {
        uint64_t v46 = 0;
        while (1)
        {
          BOOL v47 = *(char **)((v44 + v46) & 0xFFFFFFFFFFFFFFFCLL);
          if ((objc::InterestingSelectorZeroes & (unint64_t)v47) == 0
            && (objc::InterestingSelectorOnes & (unint64_t)v47) == objc::InterestingSelectorOnes)
          {
            break;
          }
          v46 += v40;
          if (v44 + v46 == v45) {
            goto LABEL_2;
          }
        }
        if (sel_alloc == v47 || sel_allocWithZone_ == v47)
        {
          uint64_t result = result | 1;
        }
        else if (sel_retain == v47 {
               || sel_release == v47
        }
               || sel_autorelease == v47
               || sel__tryRetain == v47
               || sel__isDeallocating == v47
               || sel_retainCount == v47
               || sel_allowsWeakReference == v47
               || sel_retainWeakReference == v47)
        {
          uint64_t result = result | 4;
        }
        else
        {
          BOOL v48 = sel_respondsToSelector_ == v47 || sel_isKindOfClass_ == v47;
          BOOL v49 = v48 || sel_class == v47;
          BOOL v50 = v49 || sel_self == v47;
          BOOL v51 = v50 || &sel_new == (_UNKNOWN *)v47;
          uint64_t result = v51 ? result | 0x10 : result;
        }
        if (result == 21) {
          break;
        }
        v44 += v46 + v40;
      }
    }
    else if (v18 < 0)
    {
      uint64_t v19 = (unsigned __int16)v18 & 0xFFFC;
      uint64_t v20 = *(unsigned int *)(v12 + 4);
      unint64_t v52 = v20 * (unint64_t)v19;
      if (dataSegmentsRanges > v12 || *(void *)algn_1EB1CB078 <= v12)
      {
        if ((v52 & 0xFFFFFFFF00000000) != 0) {
LABEL_253:
        }
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)sel_alloc, sel_retain, v6, sel_allocWithZone_, sel_release, sel_autorelease, sel__tryRetain, v20, v12, v19);
        unint64_t v71 = v12 + 8;
        unint64_t v72 = v71 & 0xFFFFFFFFFFFFFFFCLL | 1;
        for (unint64_t i = (v71 + v52) & 0xFFFFFFFFFFFFFFFCLL | 1; v72 != i; v72 += v74 + v19)
        {
          uint64_t v74 = 0;
          while (1)
          {
            BOOL v75 = *(char **)(((v72 + v74) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v72 + v74) & 0xFFFFFFFFFFFFFFFCLL));
            if ((objc::InterestingSelectorZeroes & (unint64_t)v75) == 0
              && (objc::InterestingSelectorOnes & (unint64_t)v75) == objc::InterestingSelectorOnes)
            {
              break;
            }
            v74 += v19;
            if (v72 + v74 == i) {
              goto LABEL_2;
            }
          }
          if (sel_alloc == v75 || sel_allocWithZone_ == v75)
          {
            uint64_t result = result | 1;
          }
          else if (sel_retain == v75 {
                 || sel_release == v75
          }
                 || sel_autorelease == v75
                 || sel__tryRetain == v75
                 || sel__isDeallocating == v75
                 || sel_retainCount == v75
                 || sel_allowsWeakReference == v75
                 || sel_retainWeakReference == v75)
          {
            uint64_t result = result | 4;
          }
          else if (sel_respondsToSelector_ == v75 {
                 || sel_isKindOfClass_ == v75
          }
                 || sel_class == v75
                 || sel_self == v75
                 || &sel_new == (_UNKNOWN *)v75)
          {
            uint64_t result = result | 0x10;
          }
          else
          {
            uint64_t result = result;
          }
          if (result == 21) {
            break;
          }
        }
      }
      else
      {
        if ((v52 & 0xFFFFFFFF00000000) != 0) {
          goto LABEL_253;
        }
        unint64_t v53 = v12 + 8;
        unint64_t v54 = v53 & 0xFFFFFFFFFFFFFFFCLL | 1;
        unint64_t v55 = (v53 + v52) & 0xFFFFFFFFFFFFFFFCLL | 1;
        while (v54 != v55)
        {
          uint64_t v56 = 0;
          while (1)
          {
            unint64_t v57 = (char *)&unk_1F62995A8 + *(int *)((v54 + v56) & 0xFFFFFFFFFFFFFFFCLL);
            if (((unint64_t)v57 & objc::InterestingSelectorZeroes) == 0
              && (objc::InterestingSelectorOnes & (unint64_t)v57) == objc::InterestingSelectorOnes)
            {
              break;
            }
            v56 += v19;
            if (v54 + v56 == v55) {
              goto LABEL_2;
            }
          }
          if (sel_alloc == v57 || sel_allocWithZone_ == v57)
          {
            uint64_t result = result | 1;
          }
          else
          {
            BOOL v60 = sel_retain == v57 || sel_release == v57;
            BOOL v61 = v60 || sel_autorelease == v57;
            BOOL v62 = v61 || sel__tryRetain == v57;
            BOOL v63 = v62 || sel__isDeallocating == v57;
            BOOL v64 = v63 || sel_retainCount == v57;
            BOOL v65 = v64 || sel_allowsWeakReference == v57;
            if (v65 || sel_retainWeakReference == v57)
            {
              uint64_t result = result | 4;
            }
            else
            {
              BOOL v67 = sel_respondsToSelector_ == v57 || sel_isKindOfClass_ == v57;
              BOOL v68 = v67 || sel_class == v57;
              BOOL v69 = v68 || sel_self == v57;
              BOOL v70 = v69 || &sel_new == (_UNKNOWN *)v57;
              uint64_t result = v70 ? result | 0x10 : result;
            }
          }
          if (result == 21) {
            break;
          }
          v54 += v56 + v19;
        }
      }
    }
    else
    {
      uint64_t v19 = (unsigned __int16)v18 & 0xFFFC;
      uint64_t v20 = *(unsigned int *)(v12 + 4);
      unint64_t v21 = v20 * (unint64_t)v19;
      if ((v21 & 0xFFFFFFFF00000000) != 0) {
        goto LABEL_253;
      }
      unint64_t v22 = v12 + 8;
      unint64_t v23 = v22 & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v24 = (v22 + v21) & 0xFFFFFFFFFFFFFFFCLL;
      while (v23 != v24)
      {
        uint64_t v25 = 0;
        while (1)
        {
          unint64_t v26 = *(char **)((v23 + v25) & 0xFFFFFFFFFFFFFFFCLL);
          if ((objc::InterestingSelectorZeroes & (unint64_t)v26) == 0
            && (objc::InterestingSelectorOnes & (unint64_t)v26) == objc::InterestingSelectorOnes)
          {
            break;
          }
          v25 += v19;
          if (v23 + v25 == v24) {
            goto LABEL_2;
          }
        }
        if (sel_alloc == v26 || sel_allocWithZone_ == v26)
        {
          uint64_t result = result | 1;
        }
        else
        {
          BOOL v29 = sel_retain == v26 || sel_release == v26;
          BOOL v30 = v29 || sel_autorelease == v26;
          BOOL v31 = v30 || sel__tryRetain == v26;
          BOOL v32 = v31 || sel__isDeallocating == v26;
          BOOL v33 = v32 || sel_retainCount == v26;
          BOOL v34 = v33 || sel_allowsWeakReference == v26;
          if (v34 || sel_retainWeakReference == v26)
          {
            uint64_t result = result | 4;
          }
          else
          {
            BOOL v36 = sel_respondsToSelector_ == v26 || sel_isKindOfClass_ == v26;
            BOOL v37 = v36 || sel_class == v26;
            BOOL v38 = v37 || sel_self == v26;
            BOOL v39 = v38 || &sel_new == (_UNKNOWN *)v26;
            uint64_t result = v39 ? result | 0x10 : result;
          }
        }
        if (result == 21) {
          break;
        }
        v23 += v25 + v19;
      }
    }
  }
}

uint64_t list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::ListIterator::ListIterator(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void **)a2;
  *(void *)uint64_t result = *(void *)a2;
  if (!*v2) {
    goto LABEL_14;
  }
  if ((*v2 & 3) == 2)
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(result + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(result + 8) = v4;
    return result;
  }
  if ((*v2 & 3) == 1)
  {
    *(void *)(result + 8) = *(void *)(a2 + 8);
    return result;
  }
  if ((*v2 & 3) == 0)
  {
LABEL_14:
    if (*(void *)(a2 + 8)) {
      uint64_t v3 = *(void *)(a2 + 8);
    }
    else {
      uint64_t v3 = 0;
    }
    *(void *)(result + 8) = v3;
  }
  return result;
}

id CALLING_SOME__initialize_METHOD(void *a1)
{
  return [a1 sel_initialize];
}

uint64_t objc_opt_self(uint64_t result)
{
  if (result >= 1 && (*(__int16 *)((*(void *)result & 0xFFFFFFFF8) + 0x1E) & 0x80000000) == 0) {
    return (uint64_t)[result sel_self];
  }
  return result;
}

int objc_sync_exit(id obj)
{
  int v4 = _objc_sync_exit_kind((uint64_t)obj, 1, v1, v2);
  if (v4 && DebugSyncErrors)
  {
    int v5 = _objc_inform;
    if (DebugSyncErrors == 2) {
      int v5 = (void (*)(const char *, ...))_objc_fatal;
    }
    v5("objc_sync_exit(%p) returned error %d", obj, -1);
  }
  return v4;
}

int objc_sync_enter(id obj)
{
  _objc_sync_enter_kind((uint64_t)obj, 1, v1, v2);
  return 0;
}

uint64_t _objc_sync_exit_kind(uint64_t result, uint64_t a2, uint64_t a3, char *a4)
{
  if (result)
  {
    if (id2data(result, a2, (const char *)1, a4)) {
      return os_unfair_recursive_lock_tryunlock4objc() - 1;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t _objc_sync_enter_kind(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if (a1)
  {
    id2data(a1, a2, 0, a4);
    return os_unfair_recursive_lock_lock_with_options();
  }
  else
  {
    if (DebugNilSync) {
      _objc_inform("NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug");
    }
    uint64_t result = gdb_objc_class_changed();
    if (DebugNilSync == 2) {
      _objc_fatal("@synchronized(nil) is fatal", v5, v6, v7);
    }
  }
  return result;
}

_DWORD *id2data(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  int v4 = (int)a3;
  atomic_uint v5 = a2;
  memptr = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v8 = *(void *)(StatusReg + 328);
  if (v8 && !(*(void *)(v8 + 8) + a1) && *(_DWORD *)(v8 + 16) == a2)
  {
    memptr = *(void **)(StatusReg + 328);
    if (*(int *)(v8 + 20) < 1 || (uint64_t v9 = *(void *)(StatusReg + 336)) == 0) {
      _objc_fatal("id2data fastcache is buggy", a2, a3, a4);
    }
    if (a3 != 1)
    {
      if (!a3) {
        *(void *)(StatusReg + 336) = v9 + 1;
      }
      return (_DWORD *)v8;
    }
    uint64_t result = (_DWORD *)v8;
    uint64_t v33 = v9 - 1;
    *(void *)(StatusReg + 336) = v33;
    if (v33) {
      return result;
    }
    *(void *)(StatusReg + 328) = 0;
    BOOL v34 = (atomic_uint *)(v8 + 20);
    goto LABEL_55;
  }
  cache = fetch_cache(0);
  uint64_t v15 = cache;
  if (!cache || (uint64_t v16 = cache[1], !v16))
  {
LABEL_16:
    int v19 = 0;
    uint64_t v20 = (os_unfair_lock_s *)((char *)&sDataLists
                             + 64
                             * (unint64_t)(((a1 >> 4) ^ (a1 >> 9)) & 7));
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)&v20[2], (unsigned int *)&v19, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v19) {
      os_unfair_lock_lock_with_options();
    }
    unint64_t v21 = *(atomic_uint **)&v20->_os_unfair_lock_opaque;
    if (*(void *)&v20->_os_unfair_lock_opaque)
    {
      unint64_t v22 = 0;
      do
      {
        if (!(*((void *)v21 + 1) + a1) && v21[4] == v5)
        {
          memptr = v21;
          atomic_fetch_add(v21 + 5, 1u);
          goto LABEL_33;
        }
        if (!v22)
        {
          if (v21[5]) {
            unint64_t v22 = 0;
          }
          else {
            unint64_t v22 = v21;
          }
        }
        unint64_t v21 = *(atomic_uint **)v21;
      }
      while (v21);
      if (v4 == 1) {
        goto LABEL_33;
      }
      if (v22)
      {
        memptr = v22;
        *((void *)v22 + 1) = -a1;
        v22[4] = v5;
        v22[5] = 1;
        goto LABEL_33;
      }
    }
    else if (v4 == 1)
    {
      goto LABEL_33;
    }
    malloc_type_posix_memalign(&memptr, 0x40uLL, 0x40uLL, 0x10A0040571A19FAuLL);
    unint64_t v23 = (char *)memptr;
    *((void *)memptr + 1) = -a1;
    *((_DWORD *)v23 + 4) = v5;
    *(void *)(v23 + 20) = 1;
    *((_DWORD *)v23 + 7) = 0;
    *(void *)unint64_t v23 = *(void *)&v20->_os_unfair_lock_opaque;
    *(void *)&v20->_os_unfair_lock_opaque = memptr;
LABEL_33:
    int v24 = *(_DWORD *)(StatusReg + 24);
    int v25 = v24;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)&v20[2], (unsigned int *)&v25, 0, memory_order_release, memory_order_relaxed);
    if (v25 != v24) {
      os_unfair_lock_unlock(v20 + 2);
    }
    uint64_t result = 0;
    unint64_t v26 = memptr;
    if (memptr && v4 != 1)
    {
      if (*((void *)memptr + 1) + a1 || *((_DWORD *)memptr + 4) != v5) {
        _objc_fatal("id2data is buggy", v12, v13, v14);
      }
      if (!v8)
      {
        *(void *)(StatusReg + 328) = memptr;
        *(void *)(StatusReg + 336) = 1;
        return v26;
      }
      if (!v15)
      {
        uint64_t v15 = fetch_cache(1);
        unint64_t v26 = memptr;
      }
      uint64_t v27 = v15[1];
      unint64_t v28 = &v15[4 * v27];
      *((void *)v28 + 1) = v26;
      v28[4] = 1;
      v15[1] = v27 + 1;
      return memptr;
    }
    return result;
  }
  uint64_t v17 = 0;
  int v18 = (void **)(cache + 2);
  while (1)
  {
    uint64_t result = *v18;
    if (!(*((void *)*v18 + 1) + a1) && result[4] == v5) {
      break;
    }
    ++v17;
    v18 += 2;
    if (v16 == v17) {
      goto LABEL_16;
    }
  }
  memptr = *v18;
  if ((int)result[5] < 1 || (BOOL v29 = &v15[4 * v17], v32 = v29[4], v30 = v29 + 4, (v31 = v32) == 0)) {
    _objc_fatal("id2data cache is buggy", v12, v13, v14);
  }
  if (v4 == 1)
  {
    int v35 = v31 - 1;
    *BOOL v30 = v35;
    if (v35) {
      return result;
    }
    int v36 = v16 - 1;
    v15[1] = v36;
    *(_OWORD *)int v18 = *(_OWORD *)&v15[4 * v36 + 2];
    BOOL v34 = result + 5;
LABEL_55:
    atomic_fetch_add(v34, 0xFFFFFFFF);
    return memptr;
  }
  if (!v4) {
    *BOOL v30 = v31 + 1;
  }
  return result;
}

int *fetch_cache(int a1)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v3 = *(_OWORD **)(StatusReg + 320);
  if (!a1 || v3)
  {
    if (!v3) {
      return 0;
    }
  }
  else
  {
    uint64_t v3 = malloc_type_malloc(0x48uLL, 0xB4ED9BFAuLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    v3[3] = 0u;
    *((void *)v3 + 8) = 0;
    *(void *)(StatusReg + 320) = v3;
  }
  uint64_t result = (int *)*((void *)v3 + 1);
  if (result)
  {
    int v5 = *result;
    goto LABEL_9;
  }
  if (!a1) {
    return 0;
  }
  uint64_t result = (int *)malloc_type_calloc(1uLL, 0x48uLL, 0x17782B40uLL);
  *((void *)v3 + 1) = result;
  int v5 = 4;
  int *result = 4;
LABEL_9:
  if (v5 == result[1])
  {
    unsigned int v6 = 2 * v5;
    int *result = v6;
    uint64_t result = (int *)malloc_type_realloc(result, (32 * (v6 >> 1)) | 8, 0x675CCBBCuLL);
    *((void *)v3 + 1) = result;
  }
  return result;
}

void objc_setAssociatedObject(id object, const void *key, id value, void *policy)
{
  unint64_t v43 = key;
  if (!((unint64_t)object | (unint64_t)value)) {
    return;
  }
  if (((unint64_t)object & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (__objc2_class *)objc_debug_taggedpointer_classes[object & 7];
    if (v9)
    {
      uint64_t v8 = objc_debug_taggedpointer_classes[object & 7];
      if (v9 != __NSUnrecognizedTaggedPointer) {
        goto LABEL_9;
      }
      uint64_t v7 = objc_debug_taggedpointer_ext_classes[((unint64_t)object >> 55)];
      if (v7) {
        goto LABEL_4;
      }
    }
  }
  else
  {
    uint64_t v7 = *(void *)object & 0x7FFFFFFFFFFFF8;
    if (v7)
    {
LABEL_4:
      uint64_t v8 = v7;
      goto LABEL_9;
    }
  }
  uint64_t v8 = 0;
LABEL_9:
  if ((*(unsigned char *)((*(void *)(v8 + 32) & 0xF00007FFFFFFFF8) + 2) & 0x10) != 0)
  {
    ClassName = object_getClassName(object);
    _objc_fatal("objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects", v38, v39, v40, object, ClassName);
  }
  if (value)
  {
    if (policy == 3)
    {
      id v11 = [value sel_copy];
    }
    else
    {
      id v10 = value;
      if (policy != 1) {
        goto LABEL_17;
      }
      id v11 = value;
    }
    id v10 = v11;
  }
  else
  {
    id v10 = 0;
  }
LABEL_17:
  int v12 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(&AssociationsManagerLock, (unsigned int *)&v12, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v12) {
    os_unfair_lock_lock_with_options();
  }
  if (!value)
  {
    uint64_t v16 = objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::find(-(uint64_t)object);
    uint64_t v17 = (int32x2_t *)v16;
    if (objc::AssociationsManager::_mapStorage + 32 * dword_1EB1CAC58 == v16
      || (int v18 = (void **)(v16 + 8),
          int v19 = (void *)objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::find(v16 + 8, (unint64_t)v43), (char *)*v18 + 24 * v17[3].u32[0] == (char *)v19))
    {
      LOBYTE(v15) = (_BYTE)policy;
      uint64_t v20 = v10;
      goto LABEL_66;
    }
    uint64_t v15 = v19[1];
    uint64_t v20 = (void *)v19[2];
    v19[1] = policy;
    v19[2] = v10;
    *int v19 = -2;
    int32x2_t v21 = vadd_s32(v17[2], (int32x2_t)0x1FFFFFFFFLL);
    v17[2] = v21;
    unsigned int v22 = v17[3].u32[0];
    if (v21.i32[0])
    {
      if (v22 < 0x401
        || v22 >> 4 <= v21.i32[0]
        || (objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::grow((uint64_t)&v17[1], 2 * v21.i32[0]), v17[2].i32[0]))
      {
LABEL_66:
        int v34 = *(_DWORD *)(StatusReg + 24);
        int v35 = v34;
        atomic_compare_exchange_strong_explicit(&AssociationsManagerLock, (unsigned int *)&v35, 0, memory_order_release, memory_order_relaxed);
        if (v35 != v34) {
          os_unfair_lock_unlock((os_unfair_lock_t)&AssociationsManagerLock);
        }
        goto LABEL_68;
      }
    }
    else if (v22)
    {
      if (*v18) {
        int v24 = *v18;
      }
      else {
        int v24 = 0;
      }
      free(v24);
      *int v18 = 0;
      v17[2] = 0;
      v17[3].i32[0] = 0;
    }
    else
    {
      v17[2] = 0;
    }
    objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::erase(v17);
    goto LABEL_66;
  }
  v41[0] = 0;
  v41[1] = 0;
  int v42 = 0;
  uint64_t v44 = 0;
  char v14 = objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::LookupBucketFor<DisguisedPtr<objc_object>>(-(uint64_t)object, &v44);
  uint64_t v15 = v44;
  if ((v14 & 1) == 0)
  {
    if (4 * (int)qword_1EB1CAC50 + 4 >= (3 * dword_1EB1CAC58))
    {
      objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::grow(2 * dword_1EB1CAC58);
      uint64_t v44 = 0;
      objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::LookupBucketFor<DisguisedPtr<objc_object>>(-(uint64_t)object, &v44);
    }
    else
    {
      if (dword_1EB1CAC58 + ~qword_1EB1CAC50 - HIDWORD(qword_1EB1CAC50) > dword_1EB1CAC58 >> 3)
      {
LABEL_23:
        if (*(void *)v15 == 2)
        {
          qword_1EB1CAC50 = (uint64_t)vadd_s32((int32x2_t)qword_1EB1CAC50, (int32x2_t)0xFFFFFFFF00000001);
        }
        else if (-*(void *)v15 == -1)
        {
          LODWORD(qword_1EB1CAC50) = qword_1EB1CAC50 + 1;
        }
        else
        {
          if (*(void *)(v15 + 8)) {
            unint64_t v23 = *(void **)(v15 + 8);
          }
          else {
            unint64_t v23 = 0;
          }
          free(v23);
        }
        *(void *)uint64_t v15 = -(uint64_t)object;
        *(void *)(v15 + 16) = 0;
        *(_DWORD *)(v15 + 24) = 0;
        *(void *)(v15 + 8) = 0;
        objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::swap((uint64_t *)(v15 + 8), (uint64_t *)v41);
        goto LABEL_43;
      }
      objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::grow(dword_1EB1CAC58);
      uint64_t v44 = 0;
      objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::LookupBucketFor<DisguisedPtr<objc_object>>(-(uint64_t)object, &v44);
    }
    uint64_t v15 = v44;
    goto LABEL_23;
  }
LABEL_43:
  if (v41[0]) {
    int v25 = v41[0];
  }
  else {
    int v25 = 0;
  }
  free(v25);
  v41[0] = 0;
  if (objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::LookupBucketFor<void const*>(v15 + 8, (unint64_t)v43, v41))
  {
    unint64_t v26 = v41[0] + 2;
    uint64_t v20 = (void *)v41[0][2];
    uint64_t v15 = v41[0][1];
    v41[0][1] = policy;
  }
  else
  {
    inserted = objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::InsertIntoBucketImpl<void const*>((int32x2_t *)(v15 + 8), (unint64_t *)&v43, v41[0]);
    LOBYTE(v15) = 0;
    uint64_t v20 = 0;
    void *inserted = v43;
    inserted[1] = policy;
    unint64_t v26 = inserted + 2;
  }
  *unint64_t v26 = v10;
  int v28 = *(_DWORD *)(StatusReg + 24);
  int v29 = v28;
  atomic_compare_exchange_strong_explicit(&AssociationsManagerLock, (unsigned int *)&v29, 0, memory_order_release, memory_order_relaxed);
  if (v29 != v28) {
    os_unfair_lock_unlock((os_unfair_lock_t)&AssociationsManagerLock);
  }
  if ((uint64_t)object < 0) {
    char v30 = 1;
  }
  else {
    char v30 = v14;
  }
  if ((v30 & 1) == 0)
  {
    if ((*(void *)object & 1) == 0)
    {
      uint64_t v31 = *(void *)((*(void *)object & 0xFFFFFFFF8) + 0x20);
      if ((v31 & 4) == 0
        && ((unint64_t)(*(void *)(*(void *)object & 0xFFFFFFFF8) - 1) < 0xF
         || (*(unsigned char *)((v31 & 0xF00007FFFFFFFF8) + 3) & 0x40) == 0)
        && (*(_WORD *)((*(void *)object & 0xFFFFFFFF8) + 0x1E) & 4) == 0)
      {
        MethodImplementation = (void (*)(void))object_getMethodImplementation((unint64_t)object, (objc_selector *)sel__noteAssociatedObjects);
        if (MethodImplementation != _objc_msgForward) {
          ((void (*)(id, char *))MethodImplementation)(object, sel__noteAssociatedObjects);
        }
      }
    }
    uint64_t v32 = *(void *)object;
    if ((*(void *)object & 3) == 1)
    {
      uint64_t v33 = *(void *)object;
      do
      {
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)object, (unint64_t *)&v33, v32 | 2, memory_order_relaxed, memory_order_relaxed);
        if (v33 == v32) {
          break;
        }
        uint64_t v32 = v33;
      }
      while ((v33 & 3) == 1);
    }
  }
LABEL_68:
  if (v20)
  {
    if (v15) {
  }
    }
}

void sub_1801140E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  int v15 = *(_DWORD *)(v13 + 24);
  int v16 = v15;
  atomic_compare_exchange_strong_explicit(v12, (unsigned int *)&v16, 0, memory_order_release, memory_order_relaxed);
  if (v16 != v15) {
    os_unfair_lock_unlock((os_unfair_lock_t)&AssociationsManagerLock);
  }
  _Unwind_Resume(exception_object);
}

const char *__cdecl object_getClassName(id a1)
{
  if (a1)
  {
    if (((unint64_t)a1 & 0x8000000000000000) != 0)
    {
      uint64_t v1 = (objc_class *)objc_debug_taggedpointer_classes[a1 & 7];
      if (v1)
      {
        if (v1 != (objc_class *)__NSUnrecognizedTaggedPointer) {
          return (const char *)objc_class::demangledName(v1, 1);
        }
        uint64_t v1 = (objc_class *)objc_debug_taggedpointer_ext_classes[((unint64_t)a1 >> 55)];
        if (v1) {
          return (const char *)objc_class::demangledName(v1, 1);
        }
      }
    }
    else
    {
      uint64_t v1 = (objc_class *)(*(void *)a1 & 0x7FFFFFFFFFFFF8);
      if (v1) {
        return (const char *)objc_class::demangledName(v1, 1);
      }
    }
  }
  return "nil";
}

void *objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::InsertIntoBucketImpl<void const*>(int32x2_t *a1, unint64_t *a2, void *a3)
{
  __int32 v5 = a1[1].i32[0];
  unsigned int v6 = a1[2].u32[0];
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1].i32[1] > v6 >> 3)
  {
    goto LABEL_3;
  }
  objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::grow((uint64_t)a1, v6);
  uint64_t v8 = 0;
  objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::LookupBucketFor<void const*>((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_3:
  if (*a3 == -2)
  {
    a1[1] = vadd_s32(a1[1], (int32x2_t)0xFFFFFFFF00000001);
  }
  else if (*a3 == -1)
  {
    ++a1[1].i32[0];
  }
  return a3;
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  if (offset)
  {
    int v4 = (void **)((char *)self + offset);
    if (*(id *)((char *)self + offset) != newValue)
    {
      id v5 = newValue;
      int v6 = 0;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      atomic_compare_exchange_strong_explicit(&PropertyLocks[16* (unint64_t)(((v4 >> 4) ^ (v4 >> 9)) & 7)], (unsigned int *)&v6, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
      if (v6) {
        os_unfair_lock_lock_with_options();
      }
      uint64_t v8 = *v4;
      *int v4 = v5;
      int v9 = *(_DWORD *)(StatusReg + 24);
      int v10 = v9;
      atomic_compare_exchange_strong_explicit(&PropertyLocks[16* (unint64_t)(((v4 >> 4) ^ (v4 >> 9)) & 7)], (unsigned int *)&v10, 0, memory_order_release, memory_order_relaxed);
      if (v10 != v9) {
        os_unfair_lock_unlock((os_unfair_lock_t)&PropertyLocks[16
      }
                                                             * (unint64_t)(((v4 >> 4) ^ (v4 >> 9)) & 7)]);
    }
  }
  else
  {
    object_setClass(self, (Class)newValue);
  }
}

objc_object *objc_object *a1
{
  objc_object *v1;
  uint64_t vars8;

  uint64_t v1 = a1;

  return v1;
}

id objc_retainAutorelease(id a1)
{
  id v1 = a1;

  return v1;
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  if (offset)
  {
    int v4 = (id *)((char *)self + offset);
    if (atomic)
    {
      int v5 = 0;
      int v6 = (os_unfair_lock_s *)&PropertyLocks[16
                                            * (unint64_t)(((v4 >> 4) ^ (v4 >> 9)) & 7)];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      atomic_compare_exchange_strong_explicit((atomic_uint *volatile)v6, (unsigned int *)&v5, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
      if (v5) {
        os_unfair_lock_lock_with_options();
      }
      id v8 = *v4;
      int v9 = *(_DWORD *)(StatusReg + 24);
      int v10 = v9;
      atomic_compare_exchange_strong_explicit((atomic_uint *volatile)v6, (unsigned int *)&v10, 0, memory_order_release, memory_order_relaxed);
      if (v10 != v9) {
        os_unfair_lock_unlock(v6);
      }
      return v8;
    }
    else
    {
      return *v4;
    }
  }
  else
  {
    return object_getClass(self);
  }
}

void objc_storeStrong(id *location, id obj)
{
  id v2 = *location;
  if (*location != obj)
  {
    id v5 = obj;
    *location = obj;
  }
}

objc_object *objc_retain_full(objc_object *result, double a2)
{
  if (((unint64_t)result & 0x8000000000000000) == 0)
  {
    unint64_t isa = (unint64_t)result->isa;
    uint64_t v3 = *(void *)(((uint64_t)result->isa & 0xFFFFFFFF8) + 0x20);
    if ((v3 & 4) != 0)
    {
      if (isa)
      {
        while (isa >> 55)
        {
          if (isa >= 0xFF00000000000000)
          {
            return objc_object::rootRetain_overflow(result, 0);
          }
          unint64_t v4 = isa;
          atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)result, &v4, isa + 0x100000000000000, memory_order_relaxed, memory_order_relaxed);
          if (v4 == isa) {
            return result;
          }
          unint64_t isa = v4;
          if ((v4 & 1) == 0) {
            return objc_object::sidetable_retain(result, 0);
          }
        }
      }
      else if ((*(_WORD *)(((uint64_t)result->isa & 0xFFFFFFFF8) + 0x1E) & 4) == 0)
      {
        return objc_object::sidetable_retain(result, 0);
      }
    }
    else if ((v3 & 2) != 0 {
           && *(__int16 *)(((uint64_t)result->isa & 0xFFFFFFFF8) + 0x1E) < 0
    }
           && (*(unsigned char *)(((uint64_t)result->isa & 0xFFFFFFFF8) + 0x28) & 2) != 0)
    {
      id v5 = swiftRetain;
      return (objc_object *)v5(result, a2);
    }
    else
    {
      return [(objc_object *)result retain];
    }
  }
  return result;
}

objc_object *_objc_rootRetain(objc_object *result)
{
  if (((unint64_t)result & 0x8000000000000000) == 0)
  {
    unint64_t isa = (unint64_t)result->isa;
    if ((uint64_t)result->isa)
    {
      while (isa >> 55)
      {
        if (isa >= 0xFF00000000000000)
        {
          return objc_object::rootRetain_overflow(result, 0);
        }
        unint64_t v2 = isa;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)result, &v2, isa + 0x100000000000000, memory_order_relaxed, memory_order_relaxed);
        if (v2 == isa) {
          return result;
        }
        unint64_t isa = v2;
        if ((v2 & 1) == 0) {
          return objc_object::sidetable_retain(result, 0);
        }
      }
    }
    else if ((*(_WORD *)((isa & 0xFFFFFFFF8) + 0x1E) & 4) == 0)
    {
      return objc_object::sidetable_retain(result, 0);
    }
  }
  return result;
}

void objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if (*(void *)a1) {
    unint64_t v4 = *(void **)a1;
  }
  else {
    unint64_t v4 = 0;
  }
  unsigned int v5 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
  unsigned int v6 = v5 | (v5 >> 4) | ((v5 | (v5 >> 4)) >> 8);
  int v7 = v6 | HIWORD(v6);
  if ((v7 + 1) > 4) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 4;
  }
  *(_DWORD *)(a1 + 16) = v8;
  int v9 = malloc_type_malloc(24 * v8, 0x64B88C75uLL);
  if (v9)
  {
    *(void *)a1 = v9;
    *(void *)(a1 + 8) = 0;
    if (v4)
    {
      int v10 = v9;
LABEL_13:
      uint64_t v12 = *(unsigned int *)(a1 + 16);
      if (v12)
      {
        uint64_t v13 = 24 * v12;
        do
        {
          *int v10 = -1;
          v10 += 3;
          v13 -= 24;
        }
        while (v13);
      }
      if (v3)
      {
        uint64_t v14 = 24 * v3;
        int v15 = v4 + 2;
        do
        {
          unint64_t v16 = *(v15 - 2);
          if (v16 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            unsigned int v22 = 0;
            objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::LookupBucketFor<void const*>(a1, v16, &v22);
            uint64_t v17 = v22;
            uint64_t v18 = *(v15 - 2);
            v22[1] = 0;
            v17[2] = 0;
            *uint64_t v17 = v18;
            v17[1] = *(v15 - 1);
            *(v15 - 1) = 0;
            uint64_t v19 = v17[2];
            v17[2] = *v15;
            *int v15 = v19;
            ++*(_DWORD *)(a1 + 8);
          }
          v15 += 3;
          v14 -= 24;
        }
        while (v14);
      }
      free(v4);
      return;
    }
    id v11 = v9;
  }
  else
  {
    id v11 = 0;
    int v10 = 0;
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    if (v4) {
      goto LABEL_13;
    }
  }
  uint64_t v20 = *(unsigned int *)(a1 + 16);
  if (v20)
  {
    uint64_t v21 = 24 * v20;
    do
    {
      *id v11 = -1;
      v11 += 3;
      v21 -= 24;
    }
    while (v21);
  }
}

objc_object *objc_object::sidetable_retain(objc_object *this, char a2)
{
                                           * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  if ((a2 & 1) == 0)
  {
    int v4 = 0;
    atomic_compare_exchange_strong_explicit(v3, (unsigned int *)&v4, *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24), memory_order_acquire, memory_order_acquire);
    if (v4) {
      os_unfair_lock_lock_with_options();
    }
  }
  uint64_t v9 = -(uint64_t)this;
  if ((*v5 & 0x8000000000000000) == 0) {
    *v5 += 4;
  }
  int v6 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  int v7 = v6;
  atomic_compare_exchange_strong_explicit(v3, (unsigned int *)&v7, 0, memory_order_release, memory_order_relaxed);
  if (v7 != v6) {
    os_unfair_lock_unlock((os_unfair_lock_t)v3);
  }
  return this;
}

void *objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object const>,unsigned long,anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>,DisguisedPtr<objc_object const>,unsigned long,anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>::operator[](int32x2_t *a1, uint64_t *a2)
{
  int v7 = 0;
  inserted = v7;
  if ((v4 & 1) == 0)
  {
    void *inserted = *a2;
    inserted[1] = 0;
  }
  return inserted + 1;
}

unint64_t objc_opt_class(unint64_t result)
{
  if (result)
  {
    if ((result & 0x8000000000000000) != 0)
    {
      uint64_t v1 = objc_debug_taggedpointer_classes[result & 7];
      if ((__objc2_class *)v1 == __NSUnrecognizedTaggedPointer) {
        uint64_t v1 = objc_debug_taggedpointer_ext_classes[(result >> 55)];
      }
    }
    else
    {
      uint64_t v1 = *(void *)result & 0x7FFFFFFFFFFFF8;
    }
    int v2 = *(__int16 *)(v1 + 30);
    if (v2 < 0)
    {
      if ((v2 & 4) == 0) {
        return v1;
      }
    }
    else
    {
      return (unint64_t)[(id)result sel_class];
    }
  }
  return result;
}

Class class_getSuperclass(Class cls)
{
  if (cls)
  {
    if (*((void *)cls + 1)) {
      return (Class)*((void *)cls + 1);
    }
    else {
      return 0;
    }
  }
  return cls;
}

void objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::erase(void *a1)
{
  if (a1[1]) {
    int v2 = (void *)a1[1];
  }
  else {
    int v2 = 0;
  }
  free(v2);
  *a1 = 2;
  qword_1EB1CAC50 = (uint64_t)vadd_s32((int32x2_t)qword_1EB1CAC50, (int32x2_t)0x1FFFFFFFFLL);
  if (qword_1EB1CAC50)
  {
    if (dword_1EB1CAC58 >= 0x401 && dword_1EB1CAC58 >> 4 > qword_1EB1CAC50)
    {
      int v4 = 2 * qword_1EB1CAC50;
      objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::grow(v4);
    }
  }
  else
  {
    if (!dword_1EB1CAC58) {
      goto LABEL_24;
    }
    uint64_t v5 = 32 * dword_1EB1CAC58;
    int v6 = (void **)(objc::AssociationsManager::_mapStorage + 8);
    uint64_t v7 = objc::AssociationsManager::_mapStorage + 8;
    do
    {
      if ((char *)*(v6 - 1) - 1 >= (char *)2)
      {
        if (*v6) {
          unsigned int v8 = *v6;
        }
        else {
          unsigned int v8 = 0;
        }
        free(v8);
      }
      v7 += 32;
      v6 += 4;
      v5 -= 32;
    }
    while (v5);
    if (dword_1EB1CAC58)
    {
      if (objc::AssociationsManager::_mapStorage) {
        uint64_t v9 = (void *)objc::AssociationsManager::_mapStorage;
      }
      else {
        uint64_t v9 = 0;
      }
      free(v9);
      objc::AssociationsManager::_mapStorage = 0;
      qword_1EB1CAC50 = 0;
      dword_1EB1CAC58 = 0;
    }
    else
    {
LABEL_24:
      qword_1EB1CAC50 = 0;
    }
  }
}

void *objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object const>,unsigned long,anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>,DisguisedPtr<objc_object const>,unsigned long,anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>::InsertIntoBucketImpl<DisguisedPtr<objc_object const>>(int32x2_t *a1, uint64_t *a2, void *a3)
{
  unsigned int v8 = a3;
  __int32 v5 = a1[1].i32[0];
  unsigned int v6 = a1[2].u32[0];
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1].i32[1] > v6 >> 3)
  {
    goto LABEL_3;
  }
  a3 = v8;
LABEL_3:
  if (*a3 == 2)
  {
    a1[1] = vadd_s32(a1[1], (int32x2_t)0xFFFFFFFF00000001);
  }
  else if (-*a3 == -1)
  {
    ++a1[1].i32[0];
  }
  return a3;
}

BOOL objc::Scanner::isSwiftObject(objc::Scanner *this, objc_class *a2)
{
  BOOL result = 0;
  if (!*((void *)this + 1) || (objc::Scanner *)(*(void *)this & 0xFFFFFFFF8) == this)
  {
    int v2 = (const char *)objc_class::mangledName(this);
    if (!strcmp(v2, "_TtCs12_SwiftObject")) {
      return 1;
    }
  }
  return result;
}

void *objc_class::mangledName(objc_class *this)
{
  BOOL result = (void *)atomic_load_explicit((atomic_ullong *volatile)(class_data_bits_t::safe_ro<(Authentication)0>((uint64_t *)this + 4) + 24), memory_order_acquire);
  if (!result)
  {
    return objc_class::installMangledNameForLazilyNamedClass(this, v3, v4, v5);
  }
  return result;
}

char *objc_class::nameForLogging(objc_class *this)
{
  if ((unint64_t)(*(void *)this - 1) < 0xF)
  {
    uint64_t v14 = 0;
    asprintf(&v14, "<stub class %p>");
LABEL_13:
    unsigned int v8 = v14;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    int v10 = *(_OWORD **)(StatusReg + 320);
    if (!v10)
    {
      int v10 = malloc_type_malloc(0x48uLL, 0xB4ED9BFAuLL);
      *int v10 = 0u;
      v10[1] = 0u;
      v10[2] = 0u;
      v10[3] = 0u;
      *((void *)v10 + 8) = 0;
      *(void *)(StatusReg + 320) = v10;
    }
    id v11 = (void *)*((void *)v10 + 3);
    if (v11) {
      free(v11);
    }
    long long v12 = v10[2];
    *((void *)v10 + 5) = *((void *)v10 + 6);
    *(_OWORD *)((char *)v10 + 24) = v12;
    *((void *)v10 + 6) = v8;
    return v14;
  }
  int v2 = (uint64_t *)((char *)this + 32);
  uint64_t v3 = *((void *)this + 4);
  if (!(*(_DWORD *)(v3 & 0xF00007FFFFFFFF8) >> 30)) {
    goto LABEL_8;
  }
  if ((v3 & 3) == 0) {
    return (char *)atomic_load_explicit((atomic_ullong *volatile)(class_rw_t::ro((class_rw_t *)(v3 & 0xF00007FFFFFFFF8)) + 24), memory_order_acquire);
  }
  uint64_t v4 = *(void *)((v3 & 0xF00007FFFFFFFF8) + 8);
  if ((v4 & 1) == 0 || (v4 & 0xFFFFFFFFFFFFFFFELL) == 0 || (uint64_t v5 = *(void *)((v4 & 0xFFFFFFFFFFFFFFFELL) + 32)) == 0)
  {
LABEL_8:
    uint64_t v14 = 0;
    explicit = (char *)atomic_load_explicit((atomic_ullong *volatile)(class_data_bits_t::safe_ro<(Authentication)0>(v2) + 24), memory_order_acquire);
    if (explicit)
    {
      uint64_t v7 = copySwiftV1DemangledName(explicit, 0);
      if (!v7) {
        uint64_t v7 = strdup(explicit);
      }
      uint64_t v14 = v7;
    }
    else
    {
      asprintf(&v14, "<lazily named class %p>");
    }
    goto LABEL_13;
  }
  return (char *)v5;
}

void objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object const>,unsigned long,anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>,DisguisedPtr<objc_object const>,unsigned long,anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if (*(void *)a1) {
    uint64_t v4 = *(uint64_t **)a1;
  }
  else {
    uint64_t v4 = 0;
  }
  unsigned int v5 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
  unsigned int v6 = v5 | (v5 >> 4) | ((v5 | (v5 >> 4)) >> 8);
  int v7 = v6 | HIWORD(v6);
  if ((v7 + 1) > 4) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 4;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t v9 = malloc_type_malloc(16 * v8, 0x64B88C75uLL);
  if (v9)
  {
    *(void *)a1 = v9;
    *(void *)(a1 + 8) = 0;
    if (v4)
    {
      int v10 = v9;
LABEL_13:
      uint64_t v12 = *(unsigned int *)(a1 + 16);
      if (v12)
      {
        uint64_t v13 = 16 * v12;
        do
        {
          *int v10 = 1;
          v10 += 2;
          v13 -= 16;
        }
        while (v13);
      }
      if (v3)
      {
        uint64_t v14 = 16 * v3;
        int v15 = v4 + 1;
        do
        {
          if (*v15)
          {
            uint64_t v16 = *(v15 - 1);
            if ((unint64_t)(v16 - 1) >= 2)
            {
              uint64_t v21 = 0;
              uint64_t v17 = v21;
              uint64_t v18 = *v15;
              void *v21 = *(v15 - 1);
              v17[1] = v18;
              ++*(_DWORD *)(a1 + 8);
            }
          }
          v15 += 2;
          v14 -= 16;
        }
        while (v14);
      }
      free(v4);
      return;
    }
    id v11 = v9;
  }
  else
  {
    id v11 = 0;
    int v10 = 0;
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    if (v4) {
      goto LABEL_13;
    }
  }
  uint64_t v19 = *(unsigned int *)(a1 + 16);
  if (v19)
  {
    uint64_t v20 = 16 * v19;
    do
    {
      *id v11 = 1;
      v11 += 2;
      v20 -= 16;
    }
    while (v20);
  }
}

_DWORD *objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::init(_DWORD *result, int a2)
{
  int v2 = result;
  if (a2)
  {
    unsigned int v3 = (4 * a2 / 3u + 1) | ((4 * a2 / 3u + 1) >> 1);
    unsigned int v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    unsigned int v5 = (v4 | (v4 >> 8) | ((v4 | (v4 >> 8)) >> 16)) + 1;
    result[4] = v5;
    BOOL result = malloc_type_malloc(16 * v5, 0x64B88C75uLL);
    if (result)
    {
      *(void *)int v2 = result;
      *((void *)v2 + 1) = 0;
      unsigned int v6 = result;
    }
    else
    {
      unsigned int v6 = 0;
      *(void *)int v2 = 0;
      *((void *)v2 + 1) = 0;
    }
    uint64_t v7 = v2[4];
    if (v7)
    {
      uint64_t v8 = 16 * v7;
      do
      {
        *unsigned int v6 = -1;
        v6 += 2;
        v8 -= 16;
      }
      while (v8);
    }
  }
  else
  {
    *(void *)BOOL result = 0;
    *((void *)result + 1) = 0;
    result[4] = 0;
  }
  return result;
}

void class_setVersion(Class cls, int version)
{
  if (cls)
  {
    unsigned int v3 = (void *)((char *)cls + 32);
    uint64_t v4 = *(void *)((*((void *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
    if ((v4 & 1) == 0 || (unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL, (v4 & 0xFFFFFFFFFFFFFFFELL) == 0))
    {
      int v6 = 0;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v6, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
      if (v6) {
        os_unfair_lock_lock_with_options();
      }
      unint64_t v5 = (unint64_t)class_rw_t::extAllocIfNeeded((class_rw_t *)(*v3 & 0xF00007FFFFFFFF8));
      int v8 = *(_DWORD *)(StatusReg + 24);
      int v9 = v8;
      atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v9, 0, memory_order_release, memory_order_relaxed);
      if (v9 != v8) {
        os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
      }
    }
    *(_DWORD *)(v5 + 40) = version;
  }
}

void sub_180115560(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void _class_setCustomDeallocInitiation(uint64_t a1)
{
  if ((*(_WORD *)(a1 + 30) & 0x1000) == 0)
  {
    int v2 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v2, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v2) {
      os_unfair_lock_lock_with_options();
    }
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3321888768;
    v6[2] = ___class_setCustomDeallocInitiation_block_invoke;
    v6[3] = &__block_descriptor_33_e8_32c46_ZTSKZ33_class_setCustomDeallocInitiationE3__0_e8_B16__0_8l;
    foreach_realized_class_and_subclass(a1, (uint64_t)v6);
    int v4 = *(_DWORD *)(StatusReg + 24);
    int v5 = v4;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
    if (v5 != v4) {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
  }
}

void sub_180115664(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void objc_exception_rethrow(void)
{
  if (PrintExceptions) {
    _objc_inform("EXCEPTIONS: rethrowing current exception");
  }
  __cxa_rethrow();
}

void objc_copyCppObjectAtomic(void *dest, const void *src, void (__cdecl *copyHelper)(void *, const void *))
{
  int v6 = (os_unfair_lock_s *)&CppObjectLocks[16
                                         * (unint64_t)(((src >> 4) ^ (src >> 9)) & 7)];
  uint64_t v7 = (os_unfair_lock_s *)&CppObjectLocks[16
                                         * (unint64_t)(((dest >> 4) ^ (dest >> 9)) & 7)];
  locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::lockWith((atomic_uint *)v6, (atomic_uint *)v7);
  ((void (*)(void *, const void *))copyHelper)(dest, src);

  locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::unlockWith(v6, v7);
}

BOOL objc_isUniquelyReferenced(objc_object *this)
{
  if ((uint64_t)this < 1) {
    return 0;
  }
  if ((*(unsigned char *)(((uint64_t)this->isa & 0xFFFFFFFF8) + 0x20) & 4) != 0)
  {
    objc_object::sidetable_lock(this);
    Class isa = this->isa;
    if ((uint64_t)this->isa)
    {
      int v6 = (char *)((unint64_t)isa >> 56);
      if (((unint64_t)isa & 0x80000000000000) != 0) {
        v6 += objc_object::sidetable_getExtraRC_nolock(this);
      }
      int v8 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
      int v9 = v8;
      if (v9 != v8) {
                                                                                    * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)]);
      }
      return v6 == (char *)1;
    }
    int v3 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
    int v4 = v3;
    if (v4 != v3) {
                                                                                  * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)]);
    }
    int v5 = (char *)objc_object::sidetable_retainCount(this);
  }
  else
  {
    int v5 = (char *)[(objc_object *)this retainCount];
  }
  int v6 = v5;
  return v6 == (char *)1;
}

objc_object *_objc_rootRetainCount(objc_object *this)
{
  if (((unint64_t)this & 0x8000000000000000) != 0) {
    return this;
  }
  objc_object::sidetable_lock(this);
  Class isa = this->isa;
  if ((uint64_t)this->isa)
  {
    unint64_t v2 = (unint64_t)isa >> 56;
    if (((unint64_t)isa & 0x80000000000000) != 0) {
      v2 += objc_object::sidetable_getExtraRC_nolock(this);
    }
    int v7 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
    int v8 = v7;
    if (v8 != v7) {
                                                                                  * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)]);
    }
    return (objc_object *)v2;
  }
  int v4 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  int v5 = v4;
  if (v5 != v4) {
                                                                                * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)]);
  }

  return (objc_object *)objc_object::sidetable_retainCount(this);
}

void objc_copyStruct(void *dest, const void *src, ptrdiff_t size, BOOL atomic, BOOL hasStrong)
{
  if (atomic)
  {
    int v8 = (os_unfair_lock_s *)&StructLocks[16
                                        * (unint64_t)(((dest >> 4) ^ (dest >> 9)) & 7)];
    locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::lockWith(&StructLocks[16* (unint64_t)(((src >> 4) ^ (src >> 9)) & 7)], (atomic_uint *)v8);
    memmove(dest, src, size);
    locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::unlockWith((os_unfair_lock_t)&StructLocks[16* (unint64_t)(((src >> 4) ^ (src >> 9)) & 7)], v8);
  }
  else
  {
    memmove(dest, src, size);
  }
}

Method class_getInstanceMethod(Class cls, SEL name)
{
  unint64_t v2 = 0;
  if (cls && name)
  {
    Class v4 = cls;
    lookUpImpOrForward(0, (objc_selector *)name, cls, 2u);
    int v7 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v7, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v7) {
      os_unfair_lock_lock_with_options();
    }
    while (1)
    {
      unint64_t MethodNoSuper_nolock = getMethodNoSuper_nolock(v4, (objc_selector *)name, v5, v6);
      if (MethodNoSuper_nolock) {
        break;
      }
      if (!*((void *)v4 + 1))
      {
        unint64_t v2 = 0;
        goto LABEL_10;
      }
      Class v4 = (Class)*((void *)v4 + 1);
    }
    unint64_t v2 = (objc_method *)MethodNoSuper_nolock;
LABEL_10:
    int v10 = *(_DWORD *)(StatusReg + 24);
    int v11 = v10;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v11, 0, memory_order_release, memory_order_relaxed);
    if (v11 != v10) {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
  }
  return v2;
}

void sub_180115B80(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void objc_copyWeak(id *to, id *from)
{
  id WeakRetained = objc_loadWeakRetained(from);
  objc_initWeak(to, WeakRetained);
}

id objc_loadWeak(id *location)
{
  if (!*location) {
    return 0;
  }
  id WeakRetained = objc_loadWeakRetained(location);

  return WeakRetained;
}

id objc_loadWeakRetained(id *location)
{
  uint64_t v1 = (objc_object *)*location;
  if ((uint64_t)*location < 1) {
    return v1;
  }
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  while (1)
  {
    int v4 = 0;
                                                                 * (unint64_t)(((v1 >> 4) ^ (v1 >> 9)) & 7)];
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)v5, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v4) {
      os_unfair_lock_lock_with_options();
    }
    if (*location != v1)
    {
      int v6 = *(_DWORD *)(StatusReg + 24);
      int v7 = v6;
      atomic_compare_exchange_strong_explicit((atomic_uint *volatile)v5, (unsigned int *)&v7, 0, memory_order_release, memory_order_relaxed);
      if (v7 != v6) {
                                                                                    * (unint64_t)(((v1 >> 4) ^ (v1 >> 9)) & 7)]);
      }
      goto LABEL_16;
    }
    int v8 = (objc_class *)((uint64_t)v1->isa & 0xFFFFFFFF8);
    uint64_t v9 = *((void *)v8 + 4);
    if ((v9 & 4) != 0) {
      break;
    }
    int v10 = *(_DWORD *)(v9 & 0xF00007FFFFFFFF8);
    if ((v10 & 1) == 0) {
      int v10 = *(_DWORD *)(*(void *)((*(void *)v8 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    }
    if ((v10 & 0x20000000) != 0
      || _thisThreadIsInitializingClass((void *)((uint64_t)v1->isa & 0xFFFFFFFF8)))
    {
      uint64_t v13 = lookUpImpOrForwardTryCache((uint64_t)v1, (unint64_t)sel_retainWeakReference, v8, 0);
      if (v13 == _objc_msgForward)
      {
        uint64_t v1 = 0;
      }
      else if (!((unsigned int (*)(objc_object *, char *))v13)(v1, sel_retainWeakReference))
      {
        uint64_t v1 = 0;
      }
      goto LABEL_35;
    }
    int v11 = *(_DWORD *)(StatusReg + 24);
    int v12 = v11;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)v5, (unsigned int *)&v12, 0, memory_order_release, memory_order_relaxed);
    if (v12 != v11) {
                                                                                  * (unint64_t)(((v1 >> 4) ^ (v1 >> 9)) & 7)]);
    }
    class_initialize(v8, v1);
LABEL_16:
    uint64_t v1 = (objc_object *)*location;
    if ((uint64_t)*location <= 0) {
      return v1;
    }
  }
  unint64_t isa = (unint64_t)v1->isa;
  if ((uint64_t)v1->isa)
  {
    while (1)
    {
      if (!(isa >> 55))
      {
        uint64_t v16 = 0;
        goto LABEL_31;
      }
      if (isa >= 0xFF00000000000000) {
        break;
      }
      unint64_t v15 = isa;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)v1, &v15, isa + 0x100000000000000, memory_order_relaxed, memory_order_relaxed);
      if (v15 == isa)
      {
        uint64_t v16 = v1;
        goto LABEL_31;
      }
      unint64_t isa = v15;
      if ((v15 & 1) == 0) {
        goto LABEL_27;
      }
    }
    uint64_t v16 = objc_object::rootRetain_overflow(v1, 1);
  }
  else
  {
    uint64_t v16 = v1;
    if ((*(_WORD *)((isa & 0xFFFFFFFF8) + 0x1E) & 4) == 0)
    {
LABEL_27:
      if (objc_object::sidetable_tryRetain(v1)) {
        uint64_t v16 = v1;
      }
      else {
        uint64_t v16 = 0;
      }
    }
  }
LABEL_31:
  if (!v16) {
    uint64_t v1 = 0;
  }
LABEL_35:
  int v17 = *(_DWORD *)(StatusReg + 24);
  int v18 = v17;
  atomic_compare_exchange_strong_explicit((atomic_uint *volatile)v5, (unsigned int *)&v18, 0, memory_order_release, memory_order_relaxed);
  if (v18 != v17) {
    os_unfair_lock_unlock(v5);
  }
  return v1;
}

void (*lookUpImpOrForwardTryCache(uint64_t a1, unint64_t a2, void *a3, uint64_t a4))(void)
{
  int v8 = *(_DWORD *)(a3[4] & 0xF00007FFFFFFFF8);
  if ((v8 & 1) == 0) {
    int v8 = *(_DWORD *)(*(void *)((*a3 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  }
  if ((v8 & 0x20000000) != 0
    && ((BOOL result = (void (*)(void))cache_getImp((uint64_t)a3, a2, 0)) != 0
     || (a3[2] & 1) != 0
     && (BOOL result = (void (*)(void))cache_getImp((uint64_t)a3 + *(void *)((a3[2] & 0x7FFFFFFFFFFFFELL) - 16), a2, 0)) != 0))
  {
    if (((result == _objc_msgForward_impcache) & (a4 >> 2)) != 0) {
      return 0;
    }
  }
  else
  {
    return (void (*)(void))lookUpImpOrForward(a1, a2, a3, a4);
  }
  return result;
}

void (*resolveMethod_locked(objc_object *a1, objc_selector *a2, objc_class *a3, uint64_t a4))(void)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  int v9 = *(_DWORD *)(StatusReg + 24);
  int v10 = v9;
  atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v10, 0, memory_order_release, memory_order_relaxed);
  if (v10 != v9) {
    os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
  }
  if ((*((_WORD *)a3 + 15) & 4) == 0) {
    goto LABEL_14;
  }
  if (lookUpImpOrNilTryCache((uint64_t)a1, (unint64_t)sel_resolveClassMethod_, a3, 0))
  {
    int v11 = 0;
    atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v11, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v11) {
      os_unfair_lock_lock_with_options();
    }
    MaybeUnrealizedNonMetaClass = getMaybeUnrealizedNonMetaClass(a3, a1);
    uint64_t v13 = MaybeUnrealizedNonMetaClass;
    if ((unint64_t)(*(void *)MaybeUnrealizedNonMetaClass - 1) < 0xF
      || (*(_DWORD *)(*((void *)MaybeUnrealizedNonMetaClass + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0)
    {
      unsigned int v22 = objc_class::nameForLogging(MaybeUnrealizedNonMetaClass);
      _objc_fatal("nonmeta class %s (%p) unexpectedly not realized", v23, v24, v25, v22, v13);
    }
    int v14 = *(_DWORD *)(StatusReg + 24);
    int v15 = v14;
    atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v15, 0, memory_order_release, memory_order_relaxed);
    if (v15 != v14) {
      os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
    }
    unsigned int v16 = [(objc_class *)v13 resolveClassMethod:a2];
    int v17 = lookUpImpOrNilTryCache((uint64_t)a1, (unint64_t)a2, a3, 0);
    if (v16 && PrintResolving)
    {
      if (v17)
      {
        objc_class::nameForLogging(a3);
        _objc_inform("RESOLVE: method %c[%s %s] dynamically resolved to %p");
      }
      else
      {
        objc_class::nameForLogging(a3);
        objc_class::nameForLogging(a3);
        _objc_inform("RESOLVE: +[%s resolveClassMethod:%s] returned YES, but no new implementation of %c[%s %s] was found");
      }
    }
  }
  if (!lookUpImpOrNilTryCache((uint64_t)a1, (unint64_t)a2, a3, 0))
  {
LABEL_14:
    if ((*(void *)a3 & 0x7FFFFFFFFFFFF8) != 0) {
      int v18 = (void *)(*(void *)a3 & 0x7FFFFFFFFFFFF8);
    }
    else {
      int v18 = 0;
    }
    if (lookUpImpOrNilTryCache((uint64_t)a3, (unint64_t)sel_resolveInstanceMethod_, v18, 0))
    {
      unsigned int v19 = [(objc_class *)a3 resolveInstanceMethod:a2];
      uint64_t v20 = lookUpImpOrNilTryCache((uint64_t)a1, (unint64_t)a2, a3, 0);
      if (v19)
      {
        if (PrintResolving)
        {
          if (v20)
          {
            objc_class::nameForLogging(a3);
            _objc_inform("RESOLVE: method %c[%s %s] dynamically resolved to %p");
          }
          else
          {
            objc_class::nameForLogging(a3);
            objc_class::nameForLogging(a3);
            _objc_inform("RESOLVE: +[%s resolveInstanceMethod:%s] returned YES, but no new implementation of %c[%s %s] was found");
          }
        }
      }
    }
  }
  return lookUpImpOrForwardTryCache((uint64_t)a1, (unint64_t)a2, a3, a4);
}

void sub_1801162F8(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void (*lookUpImpOrNilTryCache(uint64_t a1, unint64_t a2, void *a3, int a4))(void)
{
  uint64_t v7 = a4 | 4u;
  int v8 = *(_DWORD *)(a3[4] & 0xF00007FFFFFFFF8);
  if ((v8 & 1) == 0) {
    int v8 = *(_DWORD *)(*(void *)((*a3 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  }
  if ((v8 & 0x20000000) != 0
    && ((BOOL result = (void (*)(void))cache_getImp((uint64_t)a3, a2, 0)) != 0
     || (a3[2] & 1) != 0
     && (BOOL result = (void (*)(void))cache_getImp((uint64_t)a3 + *(void *)((a3[2] & 0x7FFFFFFFFFFFFELL) - 16), a2, 0)) != 0))
  {
    if (result == _objc_msgForward_impcache) {
      return 0;
    }
  }
  else
  {
    return (void (*)(void))lookUpImpOrForward(a1, a2, a3, v7);
  }
  return result;
}

BOOL _objc_rootTryRetain(objc_object *this)
{
  uint64_t v1 = this;
  if (((unint64_t)this & 0x8000000000000000) == 0)
  {
    Class isa = this->isa;
    if ((uint64_t)this->isa)
    {
      while (1)
      {
        if (!((unint64_t)isa >> 55))
        {
          uint64_t v1 = 0;
          return v1 != 0;
        }
        if ((unint64_t)isa >= 0xFF00000000000000) {
          break;
        }
        int v3 = isa;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)this, (unint64_t *)&v3, (unint64_t)isa + 0x100000000000000, memory_order_relaxed, memory_order_relaxed);
        if (v3 == isa) {
          return v1 != 0;
        }
        Class isa = v3;
        if ((v3 & 1) == 0) {
          goto LABEL_7;
        }
      }
      uint64_t v1 = objc_object::rootRetain_overflow(this, 1);
    }
    else if ((*(_WORD *)(((unint64_t)isa & 0xFFFFFFFF8) + 0x1E) & 4) == 0)
    {
LABEL_7:
      if (!objc_object::sidetable_tryRetain(this)) {
        uint64_t v1 = 0;
      }
    }
  }
  return v1 != 0;
}

objc_object *objc_object::rootRetain_overflow(objc_object *this, int a2)
{
  uint64_t v2 = this;
  if (((unint64_t)this & 0x8000000000000000) == 0)
  {
    Class isa = this->isa;
    if ((uint64_t)this->isa)
    {
      int v5 = 0;
      while ((unint64_t)isa >> 55)
      {
        unint64_t v6 = (unint64_t)isa + 0x100000000000000;
        if ((unint64_t)isa >= 0xFF00000000000000)
        {
          if (((a2 | v5) & 1) == 0) {
            objc_object::sidetable_lock(v2);
          }
          int v9 = isa;
          atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)v2, (unint64_t *)&v9, v6 & 0x7FFFFFFFFFFFFFLL | 0x8080000000000000, memory_order_relaxed, memory_order_relaxed);
          if (v9 == isa)
          {
            objc_object::sidetable_addExtraRC_nolock(v2, 128);
            LOBYTE(v5) = 1;
LABEL_26:
            if (!a2 && (v5 & 1) != 0) {
              objc_object::sidetable_unlock(v2);
            }
            return v2;
          }
          int v5 = 1;
          Class isa = v9;
        }
        else
        {
          uint64_t v7 = isa;
          atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)v2, (unint64_t *)&v7, v6, memory_order_relaxed, memory_order_relaxed);
          BOOL v8 = v7 == isa;
          Class isa = v7;
          if (v8) {
            goto LABEL_26;
          }
        }
        if ((isa & 1) == 0) {
          goto LABEL_20;
        }
      }
      if (v5) {
        objc_object::sidetable_unlock(v2);
      }
      if (a2) {
        return 0;
      }
    }
    else if ((*(_WORD *)(((unint64_t)isa & 0xFFFFFFFF8) + 0x1E) & 4) == 0)
    {
      LOBYTE(v5) = 0;
LABEL_20:
      if (a2)
      {
        if (!objc_object::sidetable_tryRetain(v2)) {
          return 0;
        }
      }
      else
      {
        objc_object::sidetable_retain(v2, v5 & 1);
      }
    }
  }
  return v2;
}

uint64_t *objc_object::sidetable_addExtraRC_nolock(objc_object *this, uint64_t a2)
{
  uint64_t v6 = -(uint64_t)this;
  uint64_t v4 = *result;
  if ((*result & 0x8000000000000000) == 0)
  {
    if (__CFADD__(v4, 4 * a2)) {
      unint64_t v5 = *result & 3 | 0x8000000000000000;
    }
    else {
      unint64_t v5 = v4 + 4 * a2;
    }
    uint64_t *result = v5;
  }
  return result;
}

BOOL objc_object::rootRelease_underflow(objc_object *this, int a2)
{
  if (((unint64_t)this & 0x8000000000000000) != 0) {
    return 0;
  }
  Class isa = this->isa;
  if (((uint64_t)this->isa & 1) == 0)
  {
    if ((*(_WORD *)(((unint64_t)isa & 0xFFFFFFFF8) + 0x1E) & 4) == 0)
    {
      char v5 = 0;
LABEL_39:
      return objc_object::sidetable_release(this, v5, a2);
    }
    return 0;
  }
  char v5 = 0;
  uint64_t v6 = ((this >> 4) ^ (this >> 9)) & 7;
  BOOL v8 = v7 + 2;
  int v9 = (unsigned int *)(v7 + 6);
  while (1)
  {
    while (1)
    {
      if (!((unint64_t)isa >> 55)) {
        goto LABEL_21;
      }
      unint64_t v10 = (unint64_t)isa - 0x100000000000000;
      if ((unint64_t)isa >= 0x100000000000000) {
        break;
      }
      if (v5)
      {
        if (*v8 + 16 * *v9 == v12) {
          goto LABEL_29;
        }
        uint64_t v13 = *(void *)(v12 + 8);
        if (!v13) {
          goto LABEL_29;
        }
        unint64_t v14 = v13 - 512;
        *(void *)(v12 + 8) = v14;
        unint64_t v15 = (unint64_t)isa;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)this, &v15, ((unint64_t)(v14 > 3) << 55) | (unint64_t)isa & 0x7FFFFFFFFFFFFFLL | 0x7F00000000000000, memory_order_release, memory_order_relaxed);
        if ((Class)v15 == isa)
        {
          if (v14 <= 3) {
            objc_object::sidetable_clearExtraRC_nolock(this);
          }
          goto LABEL_25;
        }
        if ((v15 & 1) != 0 && v15 < 0x8100000000000000)
        {
          unint64_t v16 = (v15 + 0x7F00000000000000) & 0xFF7FFFFFFFFFFFFFLL | ((unint64_t)(v14 > 3) << 55);
          unint64_t v17 = v15;
          atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)this, &v17, v16, memory_order_release, memory_order_relaxed);
          if (v17 == v15)
          {
            if (v14 < 4) {
              objc_object::sidetable_clearExtraRC_nolock(this);
            }
            if (v16 >> 55)
            {
LABEL_25:
              objc_object::sidetable_unlock(this);
              return 0;
            }
            goto LABEL_29;
          }
        }
        objc_object::sidetable_addExtraRC_nolock(this, 128);
      }
      else
      {
        objc_object::sidetable_lock(this);
      }
      Class isa = this->isa;
      char v5 = 1;
      if (((uint64_t)this->isa & 1) == 0) {
        goto LABEL_39;
      }
    }
    int v11 = isa;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)this, (unint64_t *)&v11, v10, memory_order_release, memory_order_relaxed);
    if (v11 == isa) {
      break;
    }
    Class isa = v11;
    if ((v11 & 1) == 0) {
      goto LABEL_39;
    }
  }
  if (v10 >> 55)
  {
LABEL_21:
    if ((v5 & 1) == 0) {
      return 0;
    }
    goto LABEL_25;
  }
  if (v5)
  {
LABEL_29:
    int v19 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
    int v20 = v19;
    if (v20 != v19) {
  }
    }
  __dmb(9u);
  if (a2)
  {
    if ((*(_WORD *)(((uint64_t)this->isa & 0xFFFFFFFF8) + 0x1E) & 0x1000) != 0) {
      uint64_t v21 = &selRef__objc_initiateDealloc;
    }
    else {
      uint64_t v21 = &selRef_dealloc;
    }
    [this *v21];
  }
  return 1;
}

atomic_uint *objc_object::sidetable_lock(objc_object *this)
{
  int v1 = 0;
                                               * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  atomic_compare_exchange_strong_explicit(result, (unsigned int *)&v1, *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24), memory_order_acquire, memory_order_acquire);
  if (v1) {
    return (atomic_uint *)os_unfair_lock_lock_with_options();
  }
  return result;
}

void objc_object::sidetable_unlock(objc_object *this)
{
                                                               * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  int v2 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  int v3 = v2;
  atomic_compare_exchange_strong_explicit((atomic_uint *volatile)v1, (unsigned int *)&v3, 0, memory_order_release, memory_order_relaxed);
  if (v3 != v2) {
    os_unfair_lock_unlock(v1);
  }
}

void objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object const>,unsigned long,anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>,DisguisedPtr<objc_object const>,unsigned long,anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>::compact(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  if (v2)
  {
    if (v3 >= 0x401 && v3 >> 4 > v2)
    {
    }
  }
  else if (v3)
  {
    if (*(void *)a1) {
      char v5 = *(void **)a1;
    }
    else {
      char v5 = 0;
    }
    free(v5);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = 0;
  }
  else
  {
    *(void *)(a1 + 8) = 0;
  }
}

void objc_object::sidetable_clearExtraRC_nolock(objc_object *this)
{
                                                        * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  v1[2] = vadd_s32(v1[2], (int32x2_t)0x1FFFFFFFFLL);
}

uint64_t objc_object::sidetable_tryRetain(objc_object *this)
{
  uint64_t v4 = -(uint64_t)this;
  uint64_t v3 = 4;
  if (!v6)
  {
    uint64_t v2 = *(void *)(v5 + 8);
    if ((v2 & 2) != 0) {
      return 0;
    }
    if ((v2 & 0x8000000000000000) == 0) {
      *(void *)(v5 + 8) = v2 + 4;
    }
  }
  return 1;
}

BOOL objc_object::sidetable_release(objc_object *this, char a2, int a3)
{
                                           * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  if ((a2 & 1) == 0)
  {
    int v6 = 0;
    atomic_compare_exchange_strong_explicit(v5, (unsigned int *)&v6, *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24), memory_order_acquire, memory_order_acquire);
    if (v6) {
      os_unfair_lock_lock_with_options();
    }
  }
  uint64_t v15 = -(uint64_t)this;
  uint64_t v14 = 2;
  if (v17)
  {
    BOOL v7 = 1;
    goto LABEL_12;
  }
  unint64_t v8 = *(void *)(v16 + 8);
  BOOL v7 = v8 < 2;
  if (v8 <= 1)
  {
    uint64_t v9 = v8 | 2;
LABEL_10:
    *(void *)(v16 + 8) = v9;
    goto LABEL_12;
  }
  if ((v8 & 0x8000000000000000) == 0)
  {
    uint64_t v9 = v8 - 4;
    goto LABEL_10;
  }
  BOOL v7 = 0;
LABEL_12:
  int v10 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  int v11 = v10;
  atomic_compare_exchange_strong_explicit(v5, (unsigned int *)&v11, 0, memory_order_release, memory_order_relaxed);
  if (v11 != v10) {
    os_unfair_lock_unlock((os_unfair_lock_t)v5);
  }
  if ((v7 & a3) == 1)
  {
    if ((*(_WORD *)(((uint64_t)this->isa & 0xFFFFFFFF8) + 0x1E) & 0x1000) != 0) {
      uint64_t v12 = &selRef__objc_initiateDealloc;
    }
    else {
      uint64_t v12 = &selRef_dealloc;
    }
    [this *v12];
  }
  return v7;
}

void *objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object const>,unsigned long,anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>,DisguisedPtr<objc_object const>,unsigned long,anonymous namespace'::RefcountMapValuePurgeable,objc::DenseMapInfo<DisguisedPtr<objc_object const>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object const>,unsigned long>>::try_emplace<unsigned long>(uint64_t a1, int32x2_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v14 = 0;
  uint64_t v9 = v14;
  if (result)
  {
    char v10 = 0;
    int32x2_t v11 = *a2;
  }
  else
  {
    uint64_t v9 = result;
    uint64_t v13 = *a4;
    void *result = *a3;
    result[1] = v13;
    int32x2_t v11 = *a2;
    char v10 = 1;
  }
  uint64_t v12 = *(void *)&v11 + 16 * a2[2].u32[0];
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v12;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

unint64_t _thisThreadIsInitializingClass(void *a1)
{
  unint64_t result = (unint64_t)_fetchInitializingClassList(0);
  if (result)
  {
    if ((unint64_t)(*a1 - 1) < 0xF || (*(unsigned char *)(a1[4] & 0xF00007FFFFFFFF8) & 1) == 0) {
      a1 = (void *)(*a1 & 0xFFFFFFFF8);
    }
    uint64_t v3 = *(unsigned int *)result;
    if ((int)v3 < 1)
    {
      return 0;
    }
    else
    {
      uint64_t v4 = *(void **)(result + 8);
      uint64_t v5 = v3 - 1;
      do
      {
        int v6 = (void *)*v4++;
        unint64_t result = a1 == v6;
      }
      while (a1 != v6 && v5-- != 0);
    }
  }
  return result;
}

void objc_moveWeak(id *to, id *from)
{
  unint64_t v4 = (unint64_t)*from;
  if (*from)
  {
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    while (1)
    {
      int v7 = 0;
                                               * (unint64_t)(((v4 >> 4) ^ (v4 >> 9)) & 7)];
      atomic_compare_exchange_strong_explicit(v8, (unsigned int *)&v7, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
      if (v7) {
        os_unfair_lock_lock_with_options();
      }
      if (*from == (id)v4) {
        break;
      }
      int v9 = *(_DWORD *)(StatusReg + 24);
      int v10 = v9;
      atomic_compare_exchange_strong_explicit(v8, (unsigned int *)&v10, 0, memory_order_release, memory_order_relaxed);
      if (v10 != v9) {
                                                                                    * (unint64_t)(((v4 >> 4) ^ (v4 >> 9)) & 7)]);
      }
      unint64_t v4 = (unint64_t)*from;
      if (!*from) {
        goto LABEL_9;
      }
    }
    weak_unregister_no_lock((void *)v8 + 4, v4, (const char *)from, v2);
    weak_register_no_lock((char **)v8 + 4, v4, (unint64_t)to, (char *)2);
    *to = (id)v4;
    *from = 0;
    int v11 = *(_DWORD *)(StatusReg + 24);
    int v12 = v11;
    atomic_compare_exchange_strong_explicit(v8, (unsigned int *)&v12, 0, memory_order_release, memory_order_relaxed);
    if (v12 != v11)
    {
                                                                                  * (unint64_t)(((v4 >> 4) ^ (v4 >> 9)) & 7)]);
    }
  }
  else
  {
LABEL_9:
    *to = 0;
  }
}

void grow_refs_and_insert(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[3];
  if (v4) {
    unint64_t v5 = v4 + 1;
  }
  else {
    unint64_t v5 = 0;
  }
  if (v5) {
    size_t v6 = 2 * v5;
  }
  else {
    size_t v6 = 8;
  }
  int v7 = (void *)a1[1];
  unint64_t v8 = a1[2];
  a1[3] = v6 - 1;
  int v9 = malloc_type_calloc(v6, 8uLL, 0x80040B8603338uLL);
  uint64_t v10 = a1[2] & 3;
  a1[1] = v9;
  a1[2] = v10;
  a1[4] = 0;
  if (v5) {
    BOOL v11 = v8 >= 4;
  }
  else {
    BOOL v11 = 0;
  }
  if (v11)
  {
    unint64_t v12 = 0;
    unint64_t v13 = v8 >> 2;
    do
    {
      uint64_t v14 = v7[v12];
      if (v14)
      {
        append_referrer(a1, -v14);
        --v13;
      }
      ++v12;
    }
    while (v12 < v5 && v13);
    append_referrer(a1, a2);
  }
  else
  {
    append_referrer(a1, a2);
    if (!v7) {
      return;
    }
  }

  free(v7);
}

id objc_initWeak(id *location, id val)
{
  unint64_t v2 = (unint64_t)val;
  if (!val)
  {
    *location = 0;
    return (id)v2;
  }
  uint64_t v4 = 0;
                                           * (unint64_t)(((val >> 4) ^ (val >> 9)) & 7)];
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  int v7 = (objc_class **)&objc_debug_taggedpointer_classes[val & 7];
  unint64_t v8 = &objc_debug_taggedpointer_ext_classes[((unint64_t)val >> 55)];
  while (1)
  {
    int v9 = 0;
    atomic_compare_exchange_strong_explicit(v5, (unsigned int *)&v9, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v9) {
      os_unfair_lock_lock_with_options();
    }
    if ((v2 & 0x8000000000000000) == 0)
    {
      uint64_t v10 = *(void *)v2 & 0x7FFFFFFFFFFFF8;
      if (!v10) {
        goto LABEL_11;
      }
LABEL_7:
      BOOL v11 = (objc_class *)v10;
      goto LABEL_12;
    }
    if (!*v7) {
      goto LABEL_11;
    }
    BOOL v11 = *v7;
    if (*v7 == (objc_class *)__NSUnrecognizedTaggedPointer)
    {
      uint64_t v10 = *v8;
      if (!*v8)
      {
LABEL_11:
        BOOL v11 = 0;
        goto LABEL_12;
      }
      goto LABEL_7;
    }
LABEL_12:
    if (v11 == v4) {
      break;
    }
    int v12 = *(_DWORD *)(*((void *)v11 + 4) & 0xF00007FFFFFFFF8);
    if ((v12 & 1) == 0) {
      int v12 = *(_DWORD *)(*(void *)((*(void *)v11 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    }
    if ((v12 & 0x20000000) != 0) {
      break;
    }
    int v13 = *(_DWORD *)(StatusReg + 24);
    int v14 = v13;
    atomic_compare_exchange_strong_explicit(v5, (unsigned int *)&v14, 0, memory_order_release, memory_order_relaxed);
    if (v14 != v13) {
                                                                                  * (unint64_t)(((v2 >> 4) ^ (v2 >> 9)) & 7)]);
    }
    class_initialize(v11, (objc_object *)v2);
    uint64_t v4 = v11;
  }
  int64_t v15 = weak_register_no_lock((char **)v5 + 4, v2, (unint64_t)location, (char *)1);
  unint64_t v2 = v15;
  if (v15 >= 1)
  {
    atomic_ullong v16 = *(void *)v15;
    if (*(void *)v15)
    {
      while ((v16 & 4) == 0)
      {
        atomic_ullong v17 = v16;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)v15, (unint64_t *)&v17, v16 | 4, memory_order_relaxed, memory_order_relaxed);
        if (v17 == v16) {
          break;
        }
        atomic_ullong v16 = v17;
        if ((v17 & 1) == 0) {
          goto LABEL_24;
        }
      }
    }
    else
    {
LABEL_24:
      uint64_t v22 = -v15;
      *v18 |= 1uLL;
    }
  }
  *location = (id)v2;
  int v19 = *(_DWORD *)(StatusReg + 24);
  int v20 = v19;
  atomic_compare_exchange_strong_explicit(v5, (unsigned int *)&v20, 0, memory_order_release, memory_order_relaxed);
  if (v20 != v19) {
    os_unfair_lock_unlock((os_unfair_lock_t)v5);
  }
  callSetWeaklyReferenced(v2);
  return (id)v2;
}

id objc_storeWeak(id *location, id obj)
{
  uint64_t v4 = 0;
                                           * (unint64_t)(((obj >> 4) ^ (obj >> 9)) & 7)];
  int v19 = (objc_class **)&objc_debug_taggedpointer_classes[obj & 7];
  size_t v6 = &objc_debug_taggedpointer_ext_classes[((unint64_t)obj >> 55)];
  while (1)
  {
    while (1)
    {
      id v7 = *location;
                                               * (unint64_t)(((*location >> 4) ^ (*location >> 9)) & 7)];
      locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::lockWith(v8, v5);
      if (*location == v7) {
        break;
      }
      locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::unlockWith((os_unfair_lock_t)v8, (os_unfair_lock_t)v5);
    }
    if (!obj) {
      break;
    }
    if (((unint64_t)obj & 0x8000000000000000) == 0)
    {
      uint64_t v10 = *(void *)obj & 0x7FFFFFFFFFFFF8;
      if (!v10) {
        goto LABEL_11;
      }
LABEL_7:
      BOOL v11 = (objc_class *)v10;
      goto LABEL_12;
    }
    if (!*v19) {
      goto LABEL_11;
    }
    BOOL v11 = *v19;
    if (*v19 == (objc_class *)__NSUnrecognizedTaggedPointer)
    {
      uint64_t v10 = *v6;
      if (!*v6)
      {
LABEL_11:
        BOOL v11 = 0;
        goto LABEL_12;
      }
      goto LABEL_7;
    }
LABEL_12:
    if (v11 == v4) {
      break;
    }
    int v12 = *(_DWORD *)(*((void *)v11 + 4) & 0xF00007FFFFFFFF8);
    if ((v12 & 1) == 0) {
      int v12 = *(_DWORD *)(*(void *)((*(void *)v11 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    }
    if ((v12 & 0x20000000) != 0) {
      break;
    }
    locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::unlockWith((os_unfair_lock_t)v8, (os_unfair_lock_t)v5);
    class_initialize(v11, (objc_object *)obj);
    uint64_t v4 = v11;
  }
  weak_unregister_no_lock((void *)v8 + 4, (unint64_t)v7, (const char *)location, v9);
  int64_t v13 = weak_register_no_lock((char **)v5 + 4, (int64_t)obj, (unint64_t)location, (char *)1);
  int v14 = (void *)v13;
  if (v13 >= 1)
  {
    atomic_ullong v15 = *(void *)v13;
    if (*(void *)v13)
    {
      while ((v15 & 4) == 0)
      {
        atomic_ullong v16 = v15;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)v13, (unint64_t *)&v16, v15 | 4, memory_order_relaxed, memory_order_relaxed);
        if (v16 == v15) {
          break;
        }
        atomic_ullong v15 = v16;
        if ((v16 & 1) == 0) {
          goto LABEL_22;
        }
      }
    }
    else
    {
LABEL_22:
      uint64_t v20 = -v13;
      *v17 |= 1uLL;
    }
  }
  *location = v14;
  locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::unlockWith((os_unfair_lock_t)v8, (os_unfair_lock_t)v5);
  callSetWeaklyReferenced((unint64_t)v14);
  return v14;
}

void weak_unregister_no_lock(void *a1, unint64_t a2, const char *a3, char *a4)
{
  if (a2)
  {
    size_t v6 = weak_entry_for_referent(a1, a2, a3, a4);
    if (v6)
    {
      uint64_t v10 = (uint64_t)v6;
      if ((v6[2] & 3) == 2)
      {
        uint64_t v11 = 0;
        uint64_t v12 = v6[3];
        uint64_t v13 = (bswap64(0x8A970BE7488FDA55 * ((unint64_t)a3 ^ ((unint64_t)a3 >> 4))) ^ (1217387093 * (a3 ^ ((unint64_t)a3 >> 4)))) & v12;
        uint64_t v14 = v6[1];
        uint64_t v15 = v13;
        while (&a3[*(void *)(v14 + 8 * v15)])
        {
          uint64_t v15 = (v15 + 1) & v12;
          if (v15 == v13) {
            _objc_fatal("bad weak table at %p. This may be a runtime bug or a memory error somewhere else.", v7, v8, v9, v6);
          }
          if ((unint64_t)++v11 > v6[4]) {
            goto LABEL_12;
          }
        }
        *(void *)(v14 + 8 * v15) = 0;
        unint64_t v20 = v6[2] - 4;
        v6[2] = v20;
      }
      else
      {
        uint64_t v16 = 0;
        atomic_ullong v17 = v6 + 1;
        do
        {
          if (!&a3[v17[v16]])
          {
            v17[v16] = 0;
            goto LABEL_20;
          }
          ++v16;
        }
        while (v16 != 4);
LABEL_12:
        if (DebugWeakErrors)
        {
          int v18 = " Break on objc_weak_error to debug.";
          if (DebugWeakErrors == 2) {
            int v18 = "";
          }
          int v19 = (uint64_t (*)(const char *, ...))_objc_inform;
          if (DebugWeakErrors == 2) {
            int v19 = (uint64_t (*)(const char *, ...))_objc_fatal;
          }
          size_t v6 = (void *)v19("Attempted to unregister unknown __weak variable at %p. This is probably incorrect use of objc_storeWeak() and objc_loadWeak().%s", a3, v18);
        }
        gdb_objc_class_changed(v6);
LABEL_20:
        unint64_t v20 = *(void *)(v10 + 16);
      }
      if (v20 < 4 || (v20 & 3) != 2)
      {
        uint64_t v22 = 8;
        while (!*(void *)(v10 + v22))
        {
          v22 += 8;
          if (v22 == 40)
          {
            weak_entry_remove((uint64_t)a1, v10);
            return;
          }
        }
      }
    }
  }
}

unint64_t weak_register_no_lock(char **a1, int64_t this, unint64_t a3, char *a4)
{
  unint64_t v4 = this;
  if (this >= 1)
  {
    int v5 = (int)a4;
    if (a4 <= 1)
    {
      unint64_t v8 = *(void *)this;
      if ((*(unsigned char *)((*(void *)this & 0xFFFFFFFF8) + 0x20) & 4) != 0)
      {
        if (v8)
        {
          if (!(v8 >> 55)) {
            goto LABEL_24;
          }
        }
        else if (objc_object::sidetable_isDeallocating((objc_object *)this))
        {
          goto LABEL_24;
        }
      }
      else
      {
        if ((v8 & 0x7FFFFFFFFFFFF8) != 0) {
          int v9 = (void *)(v8 & 0x7FFFFFFFFFFFF8);
        }
        else {
          int v9 = 0;
        }
        uint64_t v16 = lookUpImpOrForwardTryCache(this, (unint64_t)sel_allowsWeakReference, v9, 0);
        if (v16 == _objc_msgForward) {
          return 0;
        }
        if ((((uint64_t (*)(unint64_t, char *))v16)(v4, sel_allowsWeakReference) & 1) == 0)
        {
LABEL_24:
          if (v5 == 1)
          {
            ClassName = object_getClassName((id)v4);
            _objc_fatal("Cannot form weak reference to instance (%p) of class %s. It is possible that this object was over-released, or is in the process of deallocation.", v19, v20, v21, v4, ClassName);
          }
          return 0;
        }
      }
    }
    uint64_t v10 = weak_entry_for_referent(a1, v4, (const char *)a3, a4);
    if (v10)
    {
      append_referrer(v10, a3, v11, v12);
    }
    else
    {
      v22[0] = -(uint64_t)v4;
      v22[1] = -(uint64_t)a3;
      memset(&v22[2], 0, 24);
      uint64_t v13 = a1[2];
      if (v13) {
        uint64_t v14 = v13 + 1;
      }
      else {
        uint64_t v14 = 0;
      }
      if ((unint64_t)a1[1] >= (unint64_t)(3 * (void)v14) >> 2)
      {
        if (v14) {
          size_t v15 = 2 * (void)v14;
        }
        else {
          size_t v15 = 64;
        }
        weak_resize(a1, v15);
      }
      weak_entry_insert(a1, (uint64_t)v22, v11, v12);
    }
  }
  return v4;
}

void *weak_entry_for_referent(void *a1, unint64_t a2, const char *a3, char *a4)
{
  if (!*a1) {
    return 0;
  }
  uint64_t v4 = 0;
  uint64_t v5 = a1[2];
  uint64_t v6 = (bswap64(0x8A970BE7488FDA55 * (a2 ^ (a2 >> 4))) ^ (1217387093
                                                                        * (a2 ^ (a2 >> 4)))) & v5;
  uint64_t v7 = v6;
  while (1)
  {
    unint64_t v8 = (void *)(*a1 + 40 * v7);
    if (!(*v8 + a2)) {
      break;
    }
    uint64_t v7 = (v7 + 1) & v5;
    if (v7 == v6) {
      _objc_fatal("bad weak table at %p. This may be a runtime bug or a memory error somewhere else.", a2, a3, a4, *a1);
    }
    if ((unint64_t)++v4 > a1[3]) {
      return 0;
    }
  }
  return v8;
}

unint64_t callSetWeaklyReferenced(unint64_t result)
{
  if (result)
  {
    unint64_t v1 = result;
    if ((result & 0x8000000000000000) != 0)
    {
      uint64_t v2 = objc_debug_taggedpointer_classes[result & 7];
      if ((__objc2_class *)v2 == __NSUnrecognizedTaggedPointer) {
        uint64_t v2 = objc_debug_taggedpointer_ext_classes[(result >> 55)];
      }
    }
    else
    {
      uint64_t v2 = *(void *)result & 0x7FFFFFFFFFFFF8;
    }
    if ((*(unsigned char *)(v2 + 32) & 4) == 0
      && ((uint64_t)result < 1 || (*(_WORD *)((*(void *)result & 0xFFFFFFFF8) + 0x1E) & 4) == 0))
    {
      unint64_t result = (unint64_t)class_getMethodImplementation((Class)v2, sel__setWeaklyReferenced);
      if ((void (*)(void))result != _objc_msgForward)
      {
        return ((uint64_t (*)(unint64_t, char *))result)(v1, sel__setWeaklyReferenced);
      }
    }
  }
  return result;
}

IMP class_getMethodImplementation(Class cls, SEL name)
{
  IMP result = 0;
  if (cls && name)
  {
    int v5 = *(_DWORD *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8);
    if ((v5 & 1) == 0) {
      int v5 = *(_DWORD *)(*(void *)((*(void *)cls & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    }
    if ((v5 & 0x20000000) != 0
      && ((IMP result = (IMP)cache_getImp((uint64_t)cls, (unint64_t)name, 0)) != 0
       || (*((void *)cls + 2) & 1) != 0
       && (IMP result = (IMP)cache_getImp((uint64_t)cls + *(void *)((*((void *)cls + 2) & 0x7FFFFFFFFFFFFELL) - 16), (unint64_t)name, 0)) != 0))
    {
      if (result == _objc_msgForward_impcache) {
        IMP result = 0;
      }
    }
    else
    {
      IMP result = lookUpImpOrForward(0, (objc_selector *)name, cls, 7u);
    }
    if (!result) {
      return _objc_msgForward;
    }
  }
  return result;
}

void append_referrer(void *a1, unint64_t a2, const char *a3, char *a4)
{
  if ((a1[2] & 3) == 2)
  {
    uint64_t v6 = a1[3];
    unint64_t v7 = a1[2] >> 2;
  }
  else
  {
    uint64_t v8 = 0;
    int v9 = a1 + 1;
    do
    {
      if (!v9[v8])
      {
        v9[v8] = -(uint64_t)a2;
        return;
      }
      ++v8;
    }
    while (v8 != 4);
    uint64_t v10 = (char *)malloc_type_calloc(4uLL, 8uLL, 0x80040B8603338uLL);
    for (uint64_t i = 0; i != 4; ++i)
      *(void *)&v10[i * 8] = v9[i];
    a1[1] = v10;
    *((_OWORD *)a1 + 1) = xmmword_1801515E0;
    a1[4] = 0;
    unint64_t v7 = 4;
    uint64_t v6 = 3;
  }
  if (v7 >= (unint64_t)(3 * v6 + 3) >> 2)
  {
    grow_refs_and_insert(a1, a2);
  }
  else
  {
    unint64_t v12 = 0;
    uint64_t v13 = (bswap64(0x8A970BE7488FDA55 * (a2 ^ (a2 >> 4))) ^ (1217387093
                                                                           * (a2 ^ (a2 >> 4)))) & v6;
    uint64_t v14 = a1[1];
    uint64_t v15 = v13;
    while (*(void *)(v14 + 8 * v15))
    {
      ++v12;
      uint64_t v15 = (v15 + 1) & v6;
      if (v15 == v13) {
        _objc_fatal("bad weak table at %p. This may be a runtime bug or a memory error somewhere else.", a2, a3, a4, a1);
      }
    }
    if (v12 > a1[4]) {
      a1[4] = v12;
    }
    *(void *)(v14 + 8 * v15) = -(uint64_t)a2;
    a1[2] += 4;
  }
}

atomic_uint *locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::lockWith(atomic_uint *result, atomic_uint *a2)
{
  uint64_t v3 = result;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  unsigned int v5 = *(_DWORD *)(StatusReg + 24);
  if (result < a2)
  {
    int v6 = 0;
    atomic_compare_exchange_strong_explicit(result, (unsigned int *)&v6, v5, memory_order_acquire, memory_order_acquire);
    if (v6) {
      IMP result = (atomic_uint *)os_unfair_lock_lock_with_options();
    }
    int v7 = 0;
    atomic_compare_exchange_strong_explicit(a2, (unsigned int *)&v7, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    goto LABEL_9;
  }
  int v8 = 0;
  atomic_compare_exchange_strong_explicit(a2, (unsigned int *)&v8, v5, memory_order_acquire, memory_order_acquire);
  if (v8) {
    IMP result = (atomic_uint *)os_unfair_lock_lock_with_options();
  }
  if (v3 != a2)
  {
    int v7 = 0;
    atomic_compare_exchange_strong_explicit(v3, (unsigned int *)&v7, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
LABEL_9:
    if (v7)
    {
      return (atomic_uint *)os_unfair_lock_lock_with_options();
    }
  }
  return result;
}

void locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::unlockWith(os_unfair_lock_t lock, os_unfair_lock_t a2)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  int v5 = *(_DWORD *)(StatusReg + 24);
  int v6 = v5;
  atomic_compare_exchange_strong_explicit((atomic_uint *volatile)lock, (unsigned int *)&v6, 0, memory_order_release, memory_order_relaxed);
  if (v6 != v5) {
    os_unfair_lock_unlock(lock);
  }
  if (lock != a2)
  {
    int v7 = *(_DWORD *)(StatusReg + 24);
    int v8 = v7;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)a2, (unsigned int *)&v8, 0, memory_order_release, memory_order_relaxed);
    if (v8 != v7)
    {
      os_unfair_lock_unlock(a2);
    }
  }
}

void *weak_entry_insert(void *result, uint64_t a2, const char *a3, char *a4)
{
  unint64_t v4 = 0x8A970BE7488FDA55 * (-*(void *)a2 ^ (-*(void *)a2 >> 4));
  uint64_t v5 = result[2];
  uint64_t v6 = v5 & (bswap64(v4) ^ v4);
  uint64_t v7 = *result + 40 * v6;
  unint64_t v8 = *(void *)v7;
  if (*(void *)v7)
  {
    unint64_t v8 = 0;
    uint64_t v9 = v6;
    do
    {
      uint64_t v9 = (v9 + 1) & v5;
      if (v9 == v6) {
        _objc_fatal("bad weak table at %p. This may be a runtime bug or a memory error somewhere else.", a2, a3, a4, *result);
      }
      ++v8;
      uint64_t v7 = *result + 40 * v9;
    }
    while (*(void *)v7);
  }
  long long v10 = *(_OWORD *)a2;
  long long v11 = *(_OWORD *)(a2 + 16);
  *(void *)(v7 + 32) = *(void *)(a2 + 32);
  *(_OWORD *)uint64_t v7 = v10;
  *(_OWORD *)(v7 + 16) = v11;
  ++result[1];
  if (v8 > result[3]) {
    result[3] = v8;
  }
  return result;
}

void objc_object::clearDeallocating_slow(objc_object *this, uint64_t a2, const char *a3, char *a4)
{
  int v5 = 0;
                                           * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(v6, (unsigned int *)&v5, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v5) {
    os_unfair_lock_lock_with_options();
  }
  Class isa = this->isa;
  if (((uint64_t)this->isa & 4) != 0)
  {
    weak_clear_no_lock((void *)v6 + 4, this, a3, a4);
    Class isa = this->isa;
  }
  if (((unint64_t)isa & 0x80000000000000) != 0)
  {
    long long v11 = 0;
    {
      *long long v11 = 2;
      *((int32x2_t *)v6 + 2) = vadd_s32(*(int32x2_t *)(v6 + 4), (int32x2_t)0x1FFFFFFFFLL);
    }
  }
  int v9 = *(_DWORD *)(StatusReg + 24);
  int v10 = v9;
  atomic_compare_exchange_strong_explicit(v6, (unsigned int *)&v10, 0, memory_order_release, memory_order_relaxed);
  if (v10 != v9)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)v6);
  }
}

void weak_entry_remove(uint64_t a1, uint64_t a2)
{
  if ((*(void *)(a2 + 16) & 3) == 2) {
    free(*(void **)(a2 + 8));
  }
  *(void *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t v4 = *(void *)(a1 + 16);
  unint64_t v5 = *(void *)(a1 + 8) - 1;
  *(void *)(a1 + 8) = v5;
  if (v4) {
    unint64_t v6 = v4 + 1;
  }
  else {
    unint64_t v6 = 0;
  }
  if (v6 >= 0x400 && v6 >> 4 >= v5)
  {
    weak_resize((char **)a1, v6 >> 3);
  }
}

void weak_clear_no_lock(void *a1, const void *a2, const char *a3, char *a4)
{
  unint64_t v6 = weak_entry_for_referent(a1, (unint64_t)a2, a3, a4);
  if (!v6) {
    return;
  }
  uint64_t v7 = (uint64_t)v6;
  if ((v6[2] & 3) != 2)
  {
    int v9 = v6 + 1;
    unint64_t v8 = 4;
    do
    {
LABEL_7:
      uint64_t v10 = *v9;
      if (*v9)
      {
        uint64_t v11 = -v10;
        unint64_t v12 = *(const void **)-v10;
        if (v12 == a2)
        {
          *(void *)uint64_t v11 = 0;
        }
        else if (v12)
        {
          if (DebugWeakErrors)
          {
            if (DebugWeakErrors == 2) {
              uint64_t v13 = "";
            }
            else {
              uint64_t v13 = " Break on objc_weak_error to debug.";
            }
            uint64_t v14 = (uint64_t (*)(const char *, ...))_objc_inform;
            if (DebugWeakErrors == 2) {
              uint64_t v14 = (uint64_t (*)(const char *, ...))_objc_fatal;
            }
            unint64_t v6 = (void *)v14("__weak variable at %p holds %p instead of %p. This is probably incorrect use of objc_storeWeak() and objc_loadWeak().%s", (const void *)v11, v12, a2, v13);
          }
          unint64_t v6 = (void *)gdb_objc_class_changed(v6);
        }
      }
      ++v9;
      --v8;
    }
    while (v8);
    goto LABEL_20;
  }
  unint64_t v8 = v6[3] + 1;
  if (v8 >= 2)
  {
    int v9 = (uint64_t *)v6[1];
    goto LABEL_7;
  }
LABEL_20:

  weak_entry_remove((uint64_t)a1, v7);
}

uint64_t objc_object::sidetable_isDeallocating(objc_object *this)
{
                                           * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  if (*((void *)v1 + 1) + 16 * v1[6] == v2) {
    return 0;
  }
  else {
    return (*(unsigned __int8 *)(v2 + 8) >> 1) & 1;
  }
}

void weak_resize(char **a1, size_t count)
{
  uint64_t v4 = a1[2];
  unint64_t v5 = *a1;
  unint64_t v6 = (char *)malloc_type_calloc(count, 0x28uLL, 0x10A20404071C379uLL);
  a1[2] = (char *)(count - 1);
  a1[3] = 0;
  *a1 = v6;
  a1[1] = 0;
  if (v5)
  {
    if (v4) {
      uint64_t v9 = (uint64_t)(v4 + 1);
    }
    else {
      uint64_t v9 = 0;
    }
    if (v9 >= 1)
    {
      uint64_t v10 = &v5[40 * v9];
      uint64_t v11 = v5;
      do
      {
        if (*(void *)v11) {
          weak_entry_insert(a1, (uint64_t)v11, v7, v8);
        }
        v11 += 40;
      }
      while (v11 < v10);
    }
    free(v5);
  }
}

void _objc_fatal(char *a1, uint64_t a2, const char *a3, char *a4, ...)
{
  va_start(va, a4);
  _objc_fatalv(a1, va, a3, a4);
}

id objc_storeWeakOrNil(id *location, id obj)
{
  uint64_t v4 = 0;
                                           * (unint64_t)(((obj >> 4) ^ (obj >> 9)) & 7)];
  uint64_t v19 = (objc_class **)&objc_debug_taggedpointer_classes[obj & 7];
  unint64_t v6 = &objc_debug_taggedpointer_ext_classes[((unint64_t)obj >> 55)];
  while (1)
  {
    while (1)
    {
      id v7 = *location;
                                               * (unint64_t)(((*location >> 4) ^ (*location >> 9)) & 7)];
      locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::lockWith(v8, v5);
      if (*location == v7) {
        break;
      }
      locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::unlockWith((os_unfair_lock_t)v8, (os_unfair_lock_t)v5);
    }
    if (!obj) {
      break;
    }
    if (((unint64_t)obj & 0x8000000000000000) == 0)
    {
      uint64_t v10 = *(void *)obj & 0x7FFFFFFFFFFFF8;
      if (!v10) {
        goto LABEL_11;
      }
LABEL_7:
      uint64_t v11 = (objc_class *)v10;
      goto LABEL_12;
    }
    if (!*v19) {
      goto LABEL_11;
    }
    uint64_t v11 = *v19;
    if (*v19 == (objc_class *)__NSUnrecognizedTaggedPointer)
    {
      uint64_t v10 = *v6;
      if (!*v6)
      {
LABEL_11:
        uint64_t v11 = 0;
        goto LABEL_12;
      }
      goto LABEL_7;
    }
LABEL_12:
    if (v11 == v4) {
      break;
    }
    int v12 = *(_DWORD *)(*((void *)v11 + 4) & 0xF00007FFFFFFFF8);
    if ((v12 & 1) == 0) {
      int v12 = *(_DWORD *)(*(void *)((*(void *)v11 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    }
    if ((v12 & 0x20000000) != 0) {
      break;
    }
    locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::unlockWith((os_unfair_lock_t)v8, (os_unfair_lock_t)v5);
    class_initialize(v11, (objc_object *)obj);
    uint64_t v4 = v11;
  }
  weak_unregister_no_lock((void *)v8 + 4, (unint64_t)v7, (const char *)location, v9);
  int64_t v13 = weak_register_no_lock((char **)v5 + 4, (int64_t)obj, (unint64_t)location, 0);
  uint64_t v14 = (void *)v13;
  if (v13 >= 1)
  {
    atomic_ullong v15 = *(void *)v13;
    if (*(void *)v13)
    {
      while ((v15 & 4) == 0)
      {
        atomic_ullong v16 = v15;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)v13, (unint64_t *)&v16, v15 | 4, memory_order_relaxed, memory_order_relaxed);
        if (v16 == v15) {
          break;
        }
        atomic_ullong v15 = v16;
        if ((v16 & 1) == 0) {
          goto LABEL_22;
        }
      }
    }
    else
    {
LABEL_22:
      uint64_t v20 = -v13;
      *v17 |= 1uLL;
    }
  }
  *location = v14;
  locker_mixin<lockdebug::lock_mixin<objc_lock_base_t>>::unlockWith((os_unfair_lock_t)v8, (os_unfair_lock_t)v5);
  callSetWeaklyReferenced((unint64_t)v14);
  return v14;
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  unint64_t v5 = *(uint64_t **)(StatusReg + 352);
  if (v5 != (uint64_t *)-1)
  {
    unint64_t v6 = *(_DWORD **)(StatusReg + 360);
    if ((unint64_t)v5 > 3 || v6 != 0)
    {
      *(void *)(StatusReg + 352) = 0;
      *(void *)(StatusReg + 360) = 0;
      if (v2 - (void)v6 == 8 || *v6 == -1440939011)
      {
        if (v5) {
          objc_releaseAndReturn((objc_object *)a1);
        }
      }
      else if (v5)
      {
        moveTLSAutoreleaseToPool(v5, (uint64_t)v6, v1);
      }
    }
  }
  return a1;
}

objc_object *objc_releaseAndReturn(objc_object *a1)
{
  return a1;
}

uint64_t _objc_rootRelease(uint64_t result)
{
  if ((result & 0x8000000000000000) == 0)
  {
    unint64_t v1 = *(void *)result;
    if (*(void *)result)
    {
      while (v1 >> 55)
      {
        unint64_t v2 = v1 - 0x100000000000000;
        if (v1 < 0x100000000000000) {
          return objc_object::rootRelease_underflow((objc_object *)result, 1);
        }
        unint64_t v3 = v1;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)result, &v3, v2, memory_order_release, memory_order_relaxed);
        if (v3 == v1)
        {
          if (!(v2 >> 55))
          {
            __dmb(9u);
            if ((*(_WORD *)((*(void *)result & 0xFFFFFFFF8) + 0x1E) & 0x1000) != 0) {
              uint64_t v4 = &selRef__objc_initiateDealloc;
            }
            else {
              uint64_t v4 = &selRef_dealloc;
            }
            return (uint64_t)[(id)result *v4];
          }
          return result;
        }
        unint64_t v1 = v3;
        if ((v3 & 1) == 0) {
          return objc_object::sidetable_release((objc_object *)result, 0, 1);
        }
      }
    }
    else if ((*(_WORD *)((v1 & 0xFFFFFFFF8) + 0x1E) & 4) == 0)
    {
      return objc_object::sidetable_release((objc_object *)result, 0, 1);
    }
  }
  return result;
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  unint64_t v5 = *(uint64_t **)(StatusReg + 352);
  if (v5 != (uint64_t *)-1)
  {
    unint64_t v6 = *(_DWORD **)(StatusReg + 360);
    if ((unint64_t)v5 > 3 || v6 != 0)
    {
      *(void *)(StatusReg + 352) = 0;
      *(void *)(StatusReg + 360) = 0;
      if (v2 - (void)v6 == 8 || *v6 == -1440939011)
      {
        if (v5) {
          return a1;
        }
      }
      else if (v5)
      {
        moveTLSAutoreleaseToPool(v5, (uint64_t)v6, v1);
      }
    }
  }

  return a1;
}

id objc_claimAutoreleasedReturnValue(id a1, uint64_t a2, AutoreleasePoolPage *a3)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  unint64_t v6 = *(uint64_t **)(StatusReg + 352);
  if (v6 != (uint64_t *)-1)
  {
    uint64_t v7 = *(void *)(StatusReg + 360);
    if ((unint64_t)v6 > 3 || v7 != 0)
    {
      *(void *)(StatusReg + 352) = 0;
      *(void *)(StatusReg + 360) = 0;
      if (v3 - v7 == 4)
      {
        if (v6) {
          return a1;
        }
      }
      else if (v6)
      {
        moveTLSAutoreleaseToPool(v6, v7, a3);
      }
    }
  }

  return a1;
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  unint64_t v5 = *(uint64_t **)(StatusReg + 352);
  if (v5 == (uint64_t *)-1) {
    goto LABEL_15;
  }
  moveTLSAutoreleaseToPool(v5, *(void *)(StatusReg + 360), v1);
  if ((uint64_t)a1 < 1)
  {
    unint64_t v10 = 0;
    uint64_t v9 = 0;
    goto LABEL_10;
  }
  uint64_t v6 = *(void *)a1;
  uint64_t v7 = *(void *)((*(void *)a1 & 0xFFFFFFFF8) + 0x20);
  int v8 = *(_DWORD *)(v7 & 0xF00007FFFFFFFF8);
  if ((v8 & 1) == 0) {
    int v8 = *(_DWORD *)(*(void *)((*(void *)(*(void *)a1 & 0xFFFFFFFF8) & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  }
  if ((v8 & 0x20000000) == 0)
  {
    if ((unint64_t)(*(void *)(v6 & 0x7FFFFFFFFFFFF8) - 1) < 0xF
      || (*(_DWORD *)(*(void *)((v6 & 0x7FFFFFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8) & 0x80000000) == 0)
    {
      goto LABEL_15;
    }
    class_initialize((objc_class *)(v6 & 0x7FFFFFFFFFFFF8), (objc_object *)a1);
    uint64_t v7 = *(void *)((*(void *)a1 & 0xFFFFFFFF8) + 0x20);
  }
  uint64_t v9 = v2;
  if ((v7 & 4) != 0 || *v2 == -1440939011)
  {
    unint64_t v10 = (unint64_t)a1 & 0xFFFFFFFFFFFFFFFCLL | 1;
LABEL_10:
    *(void *)(StatusReg + 352) = v10;
    *(void *)(StatusReg + 360) = v9;
    return a1;
  }
LABEL_15:

  return (objc_object *)a1;
}

uint64_t _objc_rootAutorelease(uint64_t this, uint64_t a2, AutoreleasePoolPage *a3)
{
  if (this < 0) {
    return this;
  }
  v6.Class isa = *(Class *)this;
  if (*(void *)this)
  {
    if (!((unint64_t)v6.isa >> 55)) {
      return this;
    }
  }
  else if ((*(_WORD *)(((unint64_t)v6.isa & 0xFFFFFFFF8) + 0x1E) & 0x1000) != 0 {
         && (objc_object::sidetable_isDeallocating((objc_object *)this) & 1) != 0)
  }
  {
    return this;
  }
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  int v8 = *(uint64_t **)(StatusReg + 352);
  if (v8 == (uint64_t *)-1)
  {
    uint64_t v10 = *(void *)this & 0xFFFFFFFF8;
  }
  else
  {
    moveTLSAutoreleaseToPool(v8, *(void *)(StatusReg + 360), a3);
    if (this <= 0)
    {
      *(void *)(StatusReg + 352) = 0;
      *(void *)(StatusReg + 360) = 0;
      return this;
    }
    v9.Class isa = *(Class *)this;
    uint64_t v10 = *(void *)this & 0xFFFFFFFF8;
    int v11 = *(_DWORD *)(*(void *)(v10 + 0x20) & 0xF00007FFFFFFFF8);
    if ((v11 & 1) == 0) {
      int v11 = *(_DWORD *)(*(void *)((*(void *)v10 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    }
    if ((v11 & 0x20000000) != 0) {
      goto LABEL_13;
    }
    if ((unint64_t)(*(void *)((unint64_t)v9.isa & 0x7FFFFFFFFFFFF8) - 1) >= 0xF
      && (*(_DWORD *)(*(void *)(((unint64_t)v9.isa & 0x7FFFFFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8) & 0x80000000) != 0)
    {
      class_initialize((objc_class *)((unint64_t)v9.isa & 0x7FFFFFFFFFFFF8), (objc_object *)this);
LABEL_13:
      *(void *)(StatusReg + 352) = this | 3;
      *(void *)(StatusReg + 360) = v3;
      return this;
    }
  }
  if ((*(_WORD *)(v10 + 30) & 4) == 0) {
    objc_object::rootAutorelease2((objc_object *)this, a2, a3);
  }
  return this;
}

id objc_autoreleaseReturnValue(id a1)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  unint64_t v5 = *(uint64_t **)(StatusReg + 352);
  if (v5 != (uint64_t *)-1)
  {
    moveTLSAutoreleaseToPool(v5, *(void *)(StatusReg + 360), v1);
    if ((uint64_t)a1 <= 0)
    {
      *(void *)(StatusReg + 352) = 0;
      *(void *)(StatusReg + 360) = 0;
      return a1;
    }
    uint64_t v6 = *(void *)a1;
    uint64_t v7 = *(void *)((*(void *)a1 & 0xFFFFFFFF8) + 0x20);
    int v8 = *(_DWORD *)(v7 & 0xF00007FFFFFFFF8);
    if ((v8 & 1) == 0) {
      int v8 = *(_DWORD *)(*(void *)((*(void *)(*(void *)a1 & 0xFFFFFFFF8) & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    }
    if ((v8 & 0x20000000) == 0)
    {
      if ((unint64_t)(*(void *)(v6 & 0x7FFFFFFFFFFFF8) - 1) < 0xF
        || (*(_DWORD *)(*(void *)((v6 & 0x7FFFFFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8) & 0x80000000) == 0)
      {
        goto LABEL_13;
      }
      class_initialize((objc_class *)(v6 & 0x7FFFFFFFFFFFF8), (objc_object *)a1);
      uint64_t v7 = *(void *)((*(void *)a1 & 0xFFFFFFFF8) + 0x20);
    }
    if ((v7 & 4) != 0 || *v2 == -1440939011)
    {
      *(void *)(StatusReg + 352) = (unint64_t)a1 & 0xFFFFFFFFFFFFFFFCLL | 1;
      *(void *)(StatusReg + 360) = v2;
      return a1;
    }
  }
LABEL_13:

  return a1;
}

uint64_t *moveTLSAutoreleaseToPool(uint64_t *result, uint64_t a2, AutoreleasePoolPage *a3)
{
  uint64_t v3 = (objc_object *)((unint64_t)result & 0xFFFFFFFFFFFFFFFCLL);
  if (((unint64_t)result & 0xFFFFFFFFFFFFFFFCLL) != 0)
  {
    unint64_t StatusReg = (void *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    if ((result & 2) != 0)
    {
      unint64_t v5 = (objc_object *)StatusReg[43];
      if ((unint64_t)v5 >= 2)
      {
        if (LODWORD(v5->isa) != -1583242847) {
          AutoreleasePoolPage::busted_die((const void **)&v5->isa);
        }
        if ((objc_object *)v5[2].isa == &v5[512]) {
          IMP result = AutoreleasePoolPage::autoreleaseFullPage((objc_object *)((unint64_t)result & 0xFFFFFFFFFFFFFFFCLL), v5, a3);
        }
        else {
          IMP result = AutoreleasePoolPage::add((AutoreleasePoolPage *)v5, (uint64_t)v3);
        }
      }
      else
      {
        IMP result = (uint64_t *)AutoreleasePoolPage::autoreleaseNoPage((id)((unint64_t)result & 0xFFFFFFFFFFFFFFFCLL), v3);
      }
    }
    else
    {
      StatusReg[44] = -1;
      StatusReg[45] = 0;
      IMP result = v3;
    }
  }
  unint64_t v6 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  *(void *)(v6 + 352) = 0;
  *(void *)(v6 + 360) = 0;
  return result;
}

id objc_autorelease(id a1)
{
  if ((uint64_t)a1 < 1) {
    return a1;
  }
  unint64_t v5 = *(void *)a1;
  if ((*(unsigned char *)((*(void *)a1 & 0xFFFFFFFF8) + 0x20) & 4) != 0)
  {
    if (v5)
    {
      if (!(v5 >> 55)) {
        return a1;
      }
    }
    else if ((*(_WORD *)((*(void *)a1 & 0xFFFFFFFF8) + 0x1E) & 0x1000) != 0 {
           && (objc_object::sidetable_isDeallocating((objc_object *)a1) & 1) != 0)
    }
    {
      return a1;
    }
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    uint64_t v7 = *(void *)(StatusReg + 352);
    if (v7 == -1)
    {
      uint64_t v9 = *(void *)a1 & 0xFFFFFFFF8;
    }
    else
    {
      unint64_t v1 = (objc_object *)(v7 & 0xFFFFFFFFFFFFFFFCLL);
      if ((v7 & 0xFFFFFFFFFFFFFFFCLL) != 0)
      {
        if ((v7 & 2) != 0)
        {
          unint64_t v10 = *(void *)(StatusReg + 344);
          if (v10 >= 2)
          {
            if (*(_DWORD *)v10 != -1583242847) {
              AutoreleasePoolPage::busted_die(*(const void ***)(StatusReg + 344));
            }
            if (*(void *)(v10 + 16) == v10 + 4096) {
              AutoreleasePoolPage::autoreleaseFullPage(v1, *(objc_object **)(StatusReg + 344), v2);
            }
            else {
              AutoreleasePoolPage::add(*(AutoreleasePoolPage **)(StatusReg + 344), (uint64_t)v1);
            }
          }
          else
          {
            AutoreleasePoolPage::autoreleaseNoPage(v1, v1);
          }
        }
        else
        {
          *(void *)(StatusReg + 352) = -1;
          *(void *)(StatusReg + 360) = 0;
          int v8 = v1;
        }
      }
      *(void *)(StatusReg + 352) = 0;
      *(void *)(StatusReg + 360) = 0;
      unint64_t v11 = *(void *)a1;
      uint64_t v9 = *(void *)a1 & 0xFFFFFFFF8;
      int v12 = *(_DWORD *)(*(void *)(v9 + 0x20) & 0xF00007FFFFFFFF8);
      if ((v12 & 1) == 0) {
        int v12 = *(_DWORD *)(*(void *)((*(void *)v9 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
      }
      if ((v12 & 0x20000000) != 0) {
        goto LABEL_24;
      }
      if ((unint64_t)(*(void *)(v11 & 0x7FFFFFFFFFFFF8) - 1) >= 0xF
        && (*(_DWORD *)(*(void *)((v11 & 0x7FFFFFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8) & 0x80000000) != 0)
      {
        class_initialize((objc_class *)(v11 & 0x7FFFFFFFFFFFF8), (objc_object *)a1);
LABEL_24:
        *(void *)(StatusReg + 352) = (unint64_t)a1 | 3;
        *(void *)(StatusReg + 360) = v3;
        return a1;
      }
    }
    if ((*(_WORD *)(v9 + 30) & 4) == 0) {
      objc_object::rootAutorelease2((objc_object *)a1, (uint64_t)v1, v2);
    }
    return a1;
  }

  return [a1 autorelease];
}

uint64_t *AutoreleasePoolPage::add(AutoreleasePoolPage *this, uint64_t a2)
{
  uint64_t v2 = a2;
  IMP result = (uint64_t *)*((void *)this + 2);
  if (DisableAutoreleaseCoalescing) {
    BOOL v5 = DisableAutoreleaseCoalescingLRU == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    unint64_t v6 = (uint64_t *)((char *)this + 56);
    if (a2) {
      BOOL v7 = result == v6;
    }
    else {
      BOOL v7 = 1;
    }
    char v8 = v7;
    if (DisableAutoreleaseCoalescingLRU)
    {
      if ((v8 & 1) == 0)
      {
        unint64_t v9 = *(result - 1);
        if ((v9 & 0xF00FFFFFFFFFFFFLL) == a2)
        {
          uint64_t v10 = (v9 >> 44) & 0xFF0 | (v9 >> 60);
          if (v10 != 4095)
          {
            *--IMP result = ((v10 + 1) << 44) & 0xFF000000000000 | ((v10 + 1) << 60) | a2;
            return result;
          }
        }
      }
    }
    else if ((v8 & 1) == 0)
    {
      uint64_t v11 = 0;
      int v12 = result - 1;
      int64_t v13 = result - 1;
      do
      {
        if (v13 <= v6) {
          break;
        }
        unint64_t v14 = *v13;
        if (!*v13) {
          break;
        }
        if ((v14 & 0xF00FFFFFFFFFFFFLL) == a2)
        {
          uint64_t v15 = (v14 >> 44) & 0xFF0 | (v14 >> 60);
          if (v15 != 4095)
          {
            if (v11)
            {
              memmove(v13, v13 + 1, 8 * v11);
            }
            else
            {
              uint64_t v15 = ((unint64_t)*v12 >> 44) & 0xFF0 | ((unint64_t)*v12 >> 60);
              uint64_t v2 = *v12 & 0xF00FFFFFFFFFFFFLL;
            }
            *int v12 = v2 | ((v15 + 1) << 44) & 0xFF000000000000 | ((v15 + 1) << 60);
            return v12;
          }
        }
        ++v11;
        --v13;
      }
      while (v11 != 4);
    }
  }
  *((void *)this + 2) = result + 1;
  uint64_t *result = a2;
  return result;
}

objc_object *objc_object::rootAutorelease2(objc_object *this, uint64_t a2, AutoreleasePoolPage *a3)
{
  uint64_t v4 = *(objc_object **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 344);
  if ((unint64_t)v4 >= 2)
  {
    if (LODWORD(v4->isa) != -1583242847) {
      AutoreleasePoolPage::busted_die((const void **)&v4->isa);
    }
    if ((objc_object *)v4[2].isa == &v4[512]) {
      AutoreleasePoolPage::autoreleaseFullPage(this, v4, a3);
    }
    else {
      AutoreleasePoolPage::add((AutoreleasePoolPage *)v4, (uint64_t)this);
    }
  }
  else
  {
    AutoreleasePoolPage::autoreleaseNoPage(this, v4);
  }
  return this;
}

uint64_t AutoreleasePoolPage::autoreleaseNoPage(id this, objc_object *a2)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v4 = *(void *)(StatusReg + 344);
  if (v4 == 1)
  {
LABEL_7:
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x1000uLL, 0x1000uLL, 0x778FB154uLL);
    unint64_t v6 = (const void **)memptr;
    AutoreleasePoolPage::AutoreleasePoolPage((AutoreleasePoolPage *)memptr, 0);
    if (v6 && *(_DWORD *)v6 != -1583242847) {
      AutoreleasePoolPage::busted_die(v6);
    }
    *(void *)(StatusReg + 344) = v6;
    if (v4 == 1)
    {
      BOOL v7 = v6[2];
      v6[2] = v7 + 1;
      *BOOL v7 = 0;
    }
    return (uint64_t)AutoreleasePoolPage::add((AutoreleasePoolPage *)v6, (uint64_t)this);
  }
  if (!this || !DebugMissingPools)
  {
    if (!this && !DebugPoolAllocation)
    {
      uint64_t result = 1;
      *(void *)(StatusReg + 344) = 1;
      return result;
    }
    goto LABEL_7;
  }
  char v8 = *(const void **)StatusReg;
  ClassName = object_getClassName(this);
  _objc_inform("MISSING POOLS: (%p) Object %p of class %s autoreleased with no pool in place - just leaking - break on objc_autoreleaseNoPool() to debug", v8, this, ClassName);
  gdb_objc_class_changed(v10);
  if (DebugMissingPools == 2) {
    _objc_fatal("Missing pools are a fatal error", v11, v12, v13);
  }
  return 0;
}

void sub_18011927C(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void AutoreleasePoolPage::AutoreleasePoolPage(AutoreleasePoolPage *this, AutoreleasePoolPage *a2)
{
  uint64_t v2 = a2;
  unint64_t StatusReg = (uint64_t *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v5 = *StatusReg;
  if (a2)
  {
    int v6 = *((_DWORD *)a2 + 13);
    int v7 = *((_DWORD *)a2 + 12) + 1;
  }
  else
  {
    int v7 = 0;
    int v6 = 0;
  }
  *((_DWORD *)this + 3) = 558191425;
  *(_DWORD *)this = -1583242847;
  *(void *)((char *)this + 4) = *(void *)"AUTORELEASE!";
  *((void *)this + 2) = (char *)this + 56;
  *((void *)this + 3) = v5;
  *((void *)this + 4) = a2;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 12) = v7;
  *((_DWORD *)this + 13) = v6;
  if (objc::PageCountWarning != -1)
  {
    {
      if (DisableFaults
        || getpid() == 1
        || (is_root_ramdisk() & 1) != 0
        || !os_variant_has_internal_diagnostics())
      {
        _dyld_get_image_uuid();
        if (_dyld_get_shared_cache_uuid()) {
          _dyld_get_shared_cache_range();
        }
        _os_log_simple();
      }
      else
      {
        os_fault_with_payload();
      }
    }
    uint64_t v2 = (AutoreleasePoolPage *)*((void *)this + 4);
  }
  if (v2)
  {
    if (*(_DWORD *)v2 != -1583242847
      || strncmp((const char *)v2 + 4, "AUTORELEASE!", 0xCuLL)
      || *((void *)v2 + 3) != *StatusReg)
    {
      AutoreleasePoolPage::busted_die((const void **)v2);
    }
    *((void *)v2 + 5) = this;
  }
}

void sub_180119490(_Unwind_Exception *a1)
{
  *unint64_t v1 = 0;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

uint64_t *AutoreleasePoolPage::autoreleaseFullPage(objc_object *this, objc_object *a2, AutoreleasePoolPage *a3)
{
  do
  {
    Class isa = (objc_object *)a2[5].isa;
    if (!isa)
    {
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x1000uLL, 0x1000uLL, 0x778FB154uLL);
      Class isa = (objc_object *)memptr;
      AutoreleasePoolPage::AutoreleasePoolPage((AutoreleasePoolPage *)memptr, (AutoreleasePoolPage *)a2);
    }
    a2 = isa;
  }
  while ((objc_object *)isa[2].isa == &isa[512]);
  if (LODWORD(isa->isa) != -1583242847) {
    AutoreleasePoolPage::busted_die((const void **)&isa->isa);
  }
  *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 344) = isa;
  return AutoreleasePoolPage::add((AutoreleasePoolPage *)isa, (uint64_t)this);
}

void sub_18011955C(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

Class class_initialize(objc_class *a1, objc_object *a2)
{
  int v4 = 0;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24), memory_order_acquire, memory_order_acquire);
  if (v4) {
    os_unfair_lock_lock_with_options();
  }

  return initializeAndMaybeRelock(a1, a2, 0);
}

uint64_t is_root_ramdisk()
{
  if ((os_parse_boot_arg_string() & 1) != 0 || (uint64_t result = os_parse_boot_arg_string(), result))
  {
    uint64_t result = 0;
    if (v1 == 109 && v2 == 100) {
      return v3 == 0;
    }
  }
  return result;
}

SEL method_getName(SEL m)
{
  if (m)
  {
    int v1 = m & 3;
    if ((m & 3) != 0)
    {
      if (v1 == 2)
      {
        if (*(void *)((unint64_t)m & 0xFFFFFFFFFFFFFFFCLL)) {
          return *(SEL *)((unint64_t)m & 0xFFFFFFFFFFFFFFFCLL);
        }
        else {
          return 0;
        }
      }
      else if (v1 == 1)
      {
        char v2 = (int *)((unint64_t)m & 0xFFFFFFFFFFFFFFFCLL);
        if (dataSegmentsRanges > ((unint64_t)m & 0xFFFFFFFFFFFFFFFCLL)
          || *(void *)algn_1EB1CB078 <= (unint64_t)v2)
        {
          return *(SEL *)((char *)v2 + *v2);
        }
        else
        {
          return (char *)&unk_1F62995A8 + *v2;
        }
      }
    }
    else
    {
      return *(SEL *)((unint64_t)m & 0xFFFFFFFFFFFFFFFCLL);
    }
  }
  return m;
}

unint64_t sel_hash(unint64_t a1)
{
  return a1 ^ (a1 >> 7);
}

uint64_t __getPreoptimizedProtocol_block_invoke(uint64_t result, uint64_t a2, int a3, unsigned char *a4)
{
  if (a3)
  {
    **(void **)(result + 32) = a2;
    *a4 = 1;
  }
  return result;
}

SEL sel_getUid(const char *str)
{
  return (SEL)__sel_registerName((char *)str, 1, 1);
}

size_t class_getInstanceSize(size_t cls)
{
  if (cls) {
    return (*(_DWORD *)(class_rw_t::ro((class_rw_t *)(*(void *)(cls + 32) & 0xF00007FFFFFFFF8)) + 8) + 7) & 0xFFFFFFF8;
  }
  return cls;
}

objc_class *objc_readClassPair(uint64_t *a1)
{
  int v2 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v2, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v2) {
    os_unfair_lock_lock_with_options();
  }
  unsigned int v4 = *(_DWORD *)class_data_bits_t::safe_ro<(Authentication)0>(a1 + 4);
  if (a1[1]) {
    uint64_t v5 = (objc_class *)a1[1];
  }
  else {
    uint64_t v5 = 0;
  }
  if (verifySuperclass(v5, (v4 >> 1) & 1))
  {
    Class = (objc_class *)readClass((objc_class *)a1, 0, 0);
    if (Class != (objc_class *)a1)
    {
      uint64_t v15 = Class;
      uint64_t v11 = objc_class::nameForLogging(Class);
      _objc_fatal("objc_readClassPair for class %s changed %p to %p", v12, v13, v14, v11, a1, v15);
    }
    int v7 = realizeClassWithoutSwift((objc_class *)a1, 0);
  }
  else
  {
    int v7 = 0;
  }
  int v8 = *(_DWORD *)(StatusReg + 24);
  int v9 = v8;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v9, 0, memory_order_release, memory_order_relaxed);
  if (v9 != v8) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return v7;
}

void sub_180119A00(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

BOOL verifySuperclass(objc_class *a1, uint64_t a2)
{
  if (a1)
  {
    if ((unint64_t)(*(void *)a1 - 1) >= 0xF
      && (uint64_t v2 = *((void *)a1 + 4), (*(_DWORD *)(v2 & 0xF00007FFFFFFFF8) & 0x80000000) != 0))
    {
      return (*(unsigned char *)((v2 & 0xF00007FFFFFFFF8) + 3) & 4) == 0;
    }
    else
    {
      return 0;
    }
  }
  return a2;
}

uint64_t readClass(objc_class *a1, int a2, char a3)
{
  unint64_t v5 = (unint64_t)a1;
  int v6 = (uint64_t *)((char *)a1 + 32);
  explicit = (const char *)atomic_load_explicit((atomic_ullong *volatile)(class_data_bits_t::safe_ro<(Authentication)0>((uint64_t *)a1 + 4)+ 24), memory_order_acquire);
  int v9 = (uint64_t *)(v5 + 8);
  unint64_t v8 = *(void *)(v5 + 8);
  for (i = (void *)v5; v8; unint64_t v8 = i[1])
  {
    uint64_t i = (void *)remapClass(v8);
    if (!i) {
      goto LABEL_7;
    }
    if ((unint64_t)(*i - 1) >= 0xF && (*(_DWORD *)(i[4] & 0xF00007FFFFFFFF8) & 0x80000000) != 0) {
      goto LABEL_10;
    }
  }
  if ((*(unsigned char *)class_data_bits_t::safe_ro<(Authentication)0>(i + 4) & 2) == 0)
  {
LABEL_7:
    if (PrintConnecting)
    {
      int v28 = objc_class::nameForLogging((objc_class *)v5);
      _objc_inform("CLASS: IGNORING class '%s' with missing weak-linked superclass", v28);
    }
    addRemappedClass((objc_class *)v5, 0);
    uint64_t v11 = 0;
    *(void *)(v5 + 8) = 0;
    return v11;
  }
LABEL_10:
  if ((*v6 & 1) != 0 && (*(unsigned char *)(v5 + 40) & 1) == 0) {
    *int v6 = *v6 & 0xFFFFFFFFFFFFFFFCLL | 2;
  }
  if (!explicit)
  {
    if ((a3 & 1) == 0)
    {
      class_data_bits_t::safe_ro<(Authentication)0>((uint64_t *)((*(void *)v5 & 0xFFFFFFFF8) + 32));
      uint64_t v11 = v5;
      goto LABEL_30;
    }
    goto LABEL_28;
  }
  uint64_t v12 = (uint64_t *)future_named_class_map;
  if (future_named_class_map)
  {
    unsigned int v13 = (**(uint64_t (***)(uint64_t, const char *))future_named_class_map)(future_named_class_map, explicit);
    uint64_t v14 = _NXMapMemberWithHash(v12, (uint64_t)explicit, v13, &v48);
    if (v14 != -1)
    {
      uint64_t v15 = (char *)v14;
      uint64_t v11 = NXMapRemove((uint64_t)v12, v14);
      strlen(v15);
      if ((_dyld_is_memory_immutable() & 1) == 0) {
        free(v15);
      }
      if (v11)
      {
        if (!*(_DWORD *)(future_named_class_map + 8))
        {
          NXFreeMapTable((void *)future_named_class_map);
          future_named_class_map = 0;
        }
        atomic_ullong v17 = (atomic_ullong *)(v11 + 32);
        uint64_t v16 = *(void *)(v11 + 32);
        if ((v16 & 3) != 0)
        {
          uint64_t v44 = objc_class::nameForLogging((objc_class *)v5);
          _objc_fatal("Can't complete future class request for '%s' because the real class is too big.", v45, v46, v47, v44);
        }
        uint64_t v18 = v16 & 0xF00007FFFFFFFF8;
        uint64_t v22 = (atomic_ullong *)class_rw_t::ro((class_rw_t *)(v16 & 0xF00007FFFFFFFF8));
        if (*v9) {
          uint64_t v23 = *v9;
        }
        else {
          uint64_t v23 = 0;
        }
        *(void *)(v11 + 8) = v23;
        if ((v5 & 0x8000000000000000) != 0)
        {
          uint64_t v31 = (__objc2_class *)objc_debug_taggedpointer_classes[v5 & 7];
          if (v31)
          {
            uint64_t v30 = objc_debug_taggedpointer_classes[v5 & 7];
            if (v31 != __NSUnrecognizedTaggedPointer) {
              goto LABEL_42;
            }
            uint64_t v29 = objc_debug_taggedpointer_ext_classes[(v5 >> 55)];
            if (v29) {
              goto LABEL_37;
            }
          }
        }
        else
        {
          uint64_t v29 = *(void *)v5 & 0x7FFFFFFFFFFFF8;
          if (v29)
          {
LABEL_37:
            uint64_t v30 = v29;
            goto LABEL_42;
          }
        }
        uint64_t v30 = 0;
LABEL_42:
        if ((v30 & 0xFF80000000000007) != 0) {
          _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", v19, v20, v21, v30);
        }
        *(void *)uint64_t v11 = v30 & 0x7FFFFFFFFFFFF8;
        *(_OWORD *)(v11 + 16) = *(_OWORD *)(v5 + 16);
        unint64_t v32 = *(void *)(v11 + 32);
        if ((*(void *)(v5 + 32) & 4) != 0)
        {
          while (1)
          {
            unint64_t v36 = v32 ? v32 : 0x8000000000000000;
            unint64_t v37 = v36 | 4;
            unint64_t v38 = v32;
            atomic_compare_exchange_strong_explicit(v17, &v38, v37, memory_order_release, memory_order_relaxed);
            if (v38 == v32) {
              break;
            }
            unint64_t v32 = v38;
          }
        }
        else
        {
          if (!v32) {
            goto LABEL_46;
          }
LABEL_45:
          for (unint64_t j = v32; ; unint64_t j = 0x8000000000000000)
          {
            unint64_t v34 = j & 0xFFFFFFFFFFFFFFFBLL;
            unint64_t v35 = v32;
            atomic_compare_exchange_strong_explicit(v17, &v35, v34, memory_order_release, memory_order_relaxed);
            if (v35 == v32) {
              break;
            }
            unint64_t v32 = v35;
            if (v35) {
              goto LABEL_45;
            }
LABEL_46:
            ;
          }
        }
        unint64_t v39 = class_data_bits_t::safe_ro<(Authentication)0>(v6);
        uint64_t v40 = (void *)(v18 + 8);
        uint64_t v41 = *(void *)(v18 + 8);
        if (v41)
        {
          uint64_t v40 = (void *)(v41 & 0xFFFFFFFFFFFFFFFELL);
          if (v39)
          {
            unint64_t v42 = v39;
            goto LABEL_61;
          }
        }
        else if (v39)
        {
          unint64_t v42 = v39;
          goto LABEL_61;
        }
        unint64_t v42 = 0;
LABEL_61:
        *uint64_t v40 = v42;
        unint64_t v43 = (char *)atomic_load_explicit(v22 + 3, memory_order_acquire);
        strlen(v43);
        if ((_dyld_is_memory_immutable() & 1) == 0) {
          free(v43);
        }
        free(v22);
        addRemappedClass((objc_class *)v5, (objc_class *)v11);
        int v24 = (objc_class *)v5;
        if (!v5 && (a3 & 1) != 0) {
          goto LABEL_31;
        }
        goto LABEL_26;
      }
    }
  }
  if (a3)
  {
LABEL_28:
    uint64_t v11 = v5;
    goto LABEL_31;
  }
  int v24 = 0;
  uint64_t v11 = v5;
LABEL_26:
  addNamedClass((objc_class *)v11, explicit, v24);
  unint64_t v5 = v11;
LABEL_30:
  addClassTableEntry(v5, 1);
LABEL_31:
  if (a2)
  {
    int v25 = (_DWORD *)class_data_bits_t::safe_ro<(Authentication)0>((uint64_t *)(v11 + 32));
    *v25 |= 0x20000000u;
    unint64_t v26 = (_DWORD *)class_data_bits_t::safe_ro<(Authentication)0>((uint64_t *)((*(void *)v11 & 0xFFFFFFFF8) + 32));
    *v26 |= 0x20000000u;
  }
  return v11;
}

objc_class *realizeClassMaybeSwiftMaybeRelock(uint64_t *a1, int a2)
{
  int v4 = a1 + 4;
  if ((a1[4] & 3) != 0)
  {
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    int v6 = *(_DWORD *)(StatusReg + 24);
    int v7 = v6;
    atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v7, 0, memory_order_release, memory_order_relaxed);
    if (v7 != v6) {
      os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
    }
    unint64_t v8 = class_data_bits_t::safe_ro<(Authentication)0>(v4);
    if ((*(unsigned char *)v8 & 0x40) != 0 && (int v9 = *(uint64_t (**)(uint64_t *, void))(v8 + 72)) != 0)
    {
      if (PrintConnecting)
      {
        uint64_t v20 = objc_class::nameForLogging((objc_class *)a1);
        _objc_inform("CLASS: calling Swift metadata initializer for class '%s' (%p)", v20, a1);
      }
      uint64_t v10 = v9(a1, 0);
      if ((uint64_t *)v10 == a1)
      {
        uint64_t v11 = (objc_class *)a1;
        if (!a2) {
          return v11;
        }
        goto LABEL_18;
      }
      uint64_t v11 = (objc_class *)v10;
      int v12 = 0;
      atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v12, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
      if (v12) {
        os_unfair_lock_lock_with_options();
      }
      addRemappedClass((objc_class *)a1, v11);
    }
    else
    {
      int v13 = 0;
      atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v13, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
      if (v13) {
        os_unfair_lock_lock_with_options();
      }
      uint64_t v11 = realizeClassWithoutSwift((objc_class *)a1, 0);
    }
    int v14 = *(_DWORD *)(StatusReg + 24);
    int v15 = v14;
    atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v15, 0, memory_order_release, memory_order_relaxed);
    if (v15 != v14) {
      os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
    }
    if (a2)
    {
LABEL_18:
      int v16 = 0;
      atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v16, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
      if (v16) {
        os_unfair_lock_lock_with_options();
      }
    }
  }
  else
  {
    uint64_t v11 = realizeClassWithoutSwift((objc_class *)a1, 0);
    if ((a2 & 1) == 0)
    {
      int v17 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
      int v18 = v17;
      atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v18, 0, memory_order_release, memory_order_relaxed);
      if (v18 != v17) {
        os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
      }
    }
  }
  return v11;
}

void sub_18011A2F0(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

Class initializeAndMaybeRelock(objc_class *a1, objc_object *a2, int a3)
{
  Class Class = a1;
  int v5 = *(_DWORD *)(*((void *)a1 + 4) & 0xF00007FFFFFFFF8);
  if ((v5 & 1) == 0) {
    int v5 = *(_DWORD *)(*(void *)((*(void *)a1 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  }
  if ((v5 & 0x20000000) != 0)
  {
    if ((a3 & 1) == 0)
    {
      int v12 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
      int v13 = v12;
      atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v13, 0, memory_order_release, memory_order_relaxed);
      if (v13 != v12) {
        os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
      }
    }
  }
  else
  {
    MaybeUnrealizedNonMetaClass Class = (uint64_t *)getMaybeUnrealizedNonMetaClass(a1, a2);
    uint64_t v10 = (objc_class *)MaybeUnrealizedNonMetaClass;
    if ((unint64_t)(*MaybeUnrealizedNonMetaClass - 1) >= 0xF
      && (*(_DWORD *)(MaybeUnrealizedNonMetaClass[4] & 0xF00007FFFFFFFF8) & 0x80000000) != 0)
    {
      int v15 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
      int v16 = v15;
      atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v16, 0, memory_order_release, memory_order_relaxed);
      if (v16 != v15) {
        os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
      }
    }
    else
    {
      uint64_t v10 = realizeClassMaybeSwiftMaybeRelock(MaybeUnrealizedNonMetaClass, 0);
      Class Class = object_getClass(v10);
    }
    initializeNonMetaClass(v10, v7, v8, v9);
    if (a3)
    {
      int v11 = 0;
      atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v11, *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24), memory_order_acquire, memory_order_acquire);
      if (v11) {
        os_unfair_lock_lock_with_options();
      }
    }
  }
  return Class;
}

void initializeNonMetaClass(objc_class *a1, uint64_t a2, uint64_t a3, char *a4)
{
  int v5 = (void *)*((void *)a1 + 1);
  if (v5)
  {
    int v6 = (objc_class *)*((void *)a1 + 1);
    int v7 = *(_DWORD *)(v5[4] & 0xF00007FFFFFFFF8);
    if ((v7 & 1) == 0) {
      int v7 = *(_DWORD *)(*(void *)((*v5 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    }
    if ((v7 & 0x20000000) == 0) {
      initializeNonMetaClass(v5);
    }
  }
  else
  {
    int v6 = 0;
  }
  WAITING_FOR_A_CLASS__initialize_LOCK(a1, a2, a3, a4);
  int v11 = *(_DWORD *)(*((void *)a1 + 4) & 0xF00007FFFFFFFF8);
  if ((v11 & 1) == 0) {
    int v11 = *(_DWORD *)(*(void *)((*(void *)a1 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  }
  if ((v11 & 0x20000000) == 0)
  {
    if ((v11 & 0x10000000) == 0)
    {
LABEL_11:
      int v12 = 0;
      v24[0] = 0;
      unint64_t StatusReg = (const void **)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      atomic_compare_exchange_strong_explicit(&classInitLock, (unsigned int *)&v12, *((_DWORD *)StatusReg + 6), memory_order_acquire, memory_order_acquire);
      if (v12) {
        os_unfair_lock_lock_with_options();
      }
      int v14 = v24;
      atomic_fetch_or_explicit((atomic_uint *volatile)(*(void *)((*(void *)a1 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8), 0x10000000u, memory_order_relaxed);
      size_t v15 = 16 * willInitializeFuncs;
      unsigned int v23 = willInitializeFuncs;
      if (willInitializeFuncs < 2)
      {
        memcpy(v24, &xmmword_1E8EB82B0, 16 * willInitializeFuncs);
      }
      else
      {
        int v16 = (const void *)xmmword_1E8EB82B0;
        int v17 = malloc_type_malloc(16 * willInitializeFuncs, 0x3F84A03uLL);
        memcpy(v17, v16, v15);
        v24[0] = v17;
      }
      int v18 = *((_DWORD *)StatusReg + 6);
      int v19 = v18;
      atomic_compare_exchange_strong_explicit(&classInitLock, (unsigned int *)&v19, 0, memory_order_release, memory_order_relaxed);
      if (v19 != v18) {
        os_unfair_lock_unlock((os_unfair_lock_t)&classInitLock);
      }
      _setThisThreadIsInitializingClass(a1);
      if (MultithreadedForkChild == 1)
      {
        performForkChildInitialize(a1, v6);
      }
      else
      {
        if (v23 >= 2uLL) {
          int v14 = (void **)v24[0];
        }
        if (v23)
        {
          uint64_t v20 = &v14[2 * v23];
          do
          {
            ((void (*)(void *, objc_class *))*v14)(v14[1], a1);
            v14 += 2;
          }
          while (v14 != v20);
        }
        if (PrintInitializing)
        {
          uint64_t v21 = objc_class::nameForLogging(a1);
          _objc_inform("INITIALIZE: thread %p: calling +[%s initialize]", *StatusReg, v21);
        }
        CALLING_SOME__initialize_METHOD(a1);
        if (PrintInitializing)
        {
          uint64_t v22 = objc_class::nameForLogging(a1);
          _objc_inform("INITIALIZE: thread %p: finished +[%s initialize]", *StatusReg, v22);
        }
        lockAndFinishInitializing(a1, v6);
      }
      if (v23 >= 2) {
        free(v24[0]);
      }
      return;
    }
    if (MultithreadedForkChild == 1 && !_thisThreadIsInitializingClass(a1))
    {
      WAITING_FOR_A_CLASS__initialize_LOCK(a1, v8, v9, v10);
      _setThisThreadIsInitializingClass(a1);
      performForkChildInitialize(a1, v6);
      goto LABEL_11;
    }
  }

  unlockClass(a1, v8, v9, v10);
}

void sub_18011A7BC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, void *a13)
{
}

void sub_18011A834(void *a1)
{
}

void sub_18011A850()
{
}

uint64_t WAITING_FOR_A_CLASS__initialize_LOCK(objc_class *this, uint64_t a2, uint64_t a3, char *a4)
{
  int v4 = this;
  if (PrintInitializing)
  {
    int v6 = *(const void **)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    int v7 = objc_class::nameForLogging(this);
    _objc_inform("INITIALIZE: thread %p: acquiring lock for +[%s initialize]", v6, v7);
  }
  if ((unint64_t)(*(void *)v4 - 1) < 0xF || (*(unsigned char *)(*((void *)v4 + 4) & 0xF00007FFFFFFFF8) & 1) == 0) {
    int v4 = (objc_class *)(*(void *)v4 & 0xFFFFFFFF8);
  }

  return _objc_sync_enter_kind((uint64_t)v4, 2, a3, a4);
}

uint64_t unlockClass(objc_class *a1, uint64_t a2, uint64_t a3, char *a4)
{
  if ((unint64_t)(*(void *)a1 - 1) < 0xF || (*(unsigned char *)(*((void *)a1 + 4) & 0xF00007FFFFFFFF8) & 1) == 0) {
    a1 = (objc_class *)(*(void *)a1 & 0xFFFFFFFF8);
  }
  return _objc_sync_exit_kind((uint64_t)a1, 2, a3, a4);
}

objc_class *getMaybeUnrealizedNonMetaClass(objc_class *a1, objc_object *a2)
{
  ++getMaybeUnrealizedNonMetaClass(objc_class *,objc_object *)::total;
  if ((*((_WORD *)a1 + 15) & 4) == 0) {
    return a1;
  }
  if ((objc_class *)(*(void *)a1 & 0xFFFFFFFF8) != a1
    || (!*((void *)a1 + 1) ? (uint64_t i = 0) : (uint64_t i = (void *)*((void *)a1 + 1)), (objc_class *)(*i & 0xFFFFFFFF8) != a1))
  {
    if (a2 && (unint64_t v4 = remapClass((unint64_t)a2)) != 0)
    {
      for (uint64_t i = (void *)v4; (objc_class *)(*i & 0xFFFFFFFF8) != a1; uint64_t i = (void *)i[1])
      {
        if (!i[1]) {
          goto LABEL_14;
        }
      }
    }
    else
    {
LABEL_14:
      uint64_t i = *(void **)(class_data_bits_t::safe_ro<(Authentication)0>((uint64_t *)a1 + 4) + 16);
      if (!i)
      {
        explicit = (const char *)atomic_load_explicit((atomic_ullong *volatile)(class_data_bits_t::safe_ro<(Authentication)0>((uint64_t *)a1 + 4)+ 24), memory_order_acquire);
        if (!explicit) {
          explicit = (const char *)objc_class::installMangledNameForLazilyNamedClass(a1, v6, v7, v8);
        }
        ClassExceptSomeSwift = (void *)getClassExceptSomeSwift(explicit);
        if (ClassExceptSomeSwift
          && (uint64_t i = ClassExceptSomeSwift, (objc_class *)(*ClassExceptSomeSwift & 0xFFFFFFFF8) == a1))
        {
          ++getMaybeUnrealizedNonMetaClass(objc_class *,objc_object *)::named;
          if (PrintInitializing) {
            _objc_inform("INITIALIZE: %d/%d (%g%%) successful by-name metaclass lookups");
          }
        }
        else
        {
          uint64_t v10 = (uint64_t *)nonMetaClasses();
          uint64_t v11 = NXMapGet(v10, (uint64_t)a1);
          if (!v11)
          {
            if (!DisablePreopt && (preoptimized & 1) != 0)
            {
              objc_class::mangledName(a1);
              _dyld_for_each_objc_class();
            }
            _objc_fatal("no class for metaclass %p", v12, v13, v14, a1);
          }
          uint64_t i = (void *)v11;
          ++getMaybeUnrealizedNonMetaClass(objc_class *,objc_object *)::secondary;
          if (PrintInitializing) {
            _objc_inform("INITIALIZE: %d/%d (%g%%) successful secondary metaclass lookups");
          }
        }
      }
    }
  }
  return (objc_class *)i;
}

unint64_t objc_class::setInstanceSize(objc_class *this, unsigned int a2)
{
  unint64_t result = class_rw_t::ro((class_rw_t *)(*((void *)this + 4) & 0xF00007FFFFFFFF8));
  if (*(_DWORD *)(result + 8) != a2) {
    *(_DWORD *)(result + 8) = a2;
  }
  unsigned int v5 = ((_WORD)a2 + 15) & 0xFF8;
  if (v5 < a2) {
    LOWORD(v5) = 0;
  }
  *((_WORD *)this + 15) = *((_WORD *)this + 15) & 0xF007 | v5;
  return result;
}

objc_class *realizeClassWithoutSwift(objc_class *a1, objc_class *a2)
{
  uint64_t v2 = a1;
  if (!a1
    || (unint64_t)(*(void *)a1 - 1) >= 0xF
    && (*(_DWORD *)(*((void *)a1 + 4) & 0xF00007FFFFFFFF8) & 0x80000000) != 0)
  {
    return v2;
  }
  unint64_t v4 = (void *)((char *)a1 + 32);
  unsigned int v5 = (atomic_ullong *)class_data_bits_t::safe_ro<(Authentication)0>((uint64_t *)a1 + 4);
  int v6 = *(_DWORD *)v5 & 1;
  v169 = a2;
  if ((*(_DWORD *)v5 & 0x40000000) != 0)
  {
    v170 = (class_rw_t *)(*v4 & 0xF00007FFFFFFFF8);
    int v7 = (atomic_ullong *)class_rw_t::ro(v170);
    uint64_t v11 = (atomic_uint *)(*v4 & 0xF00007FFFFFFFF8);
    do
    {
      atomic_uint v12 = *v11;
      atomic_uint v13 = *v11;
      atomic_compare_exchange_strong(v11, (unsigned int *)&v13, *v11 & 0x3FF7FFFF | 0x80080000);
    }
    while (v13 != v12);
  }
  else
  {
    int v7 = v5;
    uint64_t v8 = malloc_type_calloc(0x20uLL, 1uLL, 0x1ECB51D3uLL);
    uint64_t v9 = v8 + 1;
    uint64_t v10 = v8[1];
    if (v10) {
      uint64_t v9 = (void *)(v10 & 0xFFFFFFFFFFFFFFFELL);
    }
    *uint64_t v9 = v7;
    *(_DWORD *)uint64_t v8 = v6 | 0x80080000;
    v170 = (class_rw_t *)v8;
    class_data_bits_t::setData((unint64_t *)v2 + 4, (unint64_t)v8);
  }
  if (DisablePreoptCaches
    || (int v14 = (objc_cache **)((char *)v2 + 16),
        unint64_t v15 = dataSegmentsRanges,
        unint64_t v16 = *(void *)algn_1EB1CB078,
        dataSegmentsRanges > (unint64_t)v2 + 16)
    || *(void *)algn_1EB1CB078 <= (unint64_t)v14
    || !*((void *)v2 + 3))
  {
    *((void *)v2 + 2) = &_objc_empty_cache;
    *((void *)v2 + 3) = 0;
    if (!v6) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }
  unint64_t v17 = *((void *)v2 + 3);
  if (!dyld_shared_cache_some_image_overridden() || !*(void *)v17)
  {
LABEL_31:
    *((void *)v2 + 3) = 0;
    atomic_store(v17, (unint64_t *)v2 + 2);
    *((_WORD *)v2 + 14) = 0;
    *((_DWORD *)v2 + 6) = (((unint64_t)v2 + 16) >> 32) ^ (v2 + 16);
    *((_WORD *)v2 + 14) = *(_WORD *)(v17 + 10) & 0x3FFF;
    if (!v6) {
      goto LABEL_35;
    }
LABEL_34:
    atomic_fetch_or_explicit((atomic_ushort *volatile)v2 + 15, 4u, memory_order_relaxed);
    goto LABEL_35;
  }
  int v18 = v2;
  v167 = (objc_class *)((char *)v2 + *(void *)v17);
  while (1)
  {
    unint64_t v19 = *((void *)v18 + 1);
    if (!v19) {
      break;
    }
    if (v15 > v19 || v16 <= v19) {
      break;
    }
    int v18 = (objc_class *)*((void *)v18 + 1);
    unint64_t v21 = class_data_bits_t::safe_ro<(Authentication)0>((uint64_t *)(v19 + 32));
    if (v15 > v21 || v16 <= v21) {
      break;
    }
    if (v18 == v167) {
      goto LABEL_31;
    }
  }
  *int v14 = &_objc_empty_cache;
  *((void *)v2 + 3) = 0;
  objc_class::setDisallowPreoptCachesRecursively((uint64_t)v2, "roots");
  if (v6) {
    goto LABEL_34;
  }
LABEL_35:
  if (PrintConnecting)
  {
    v105 = objc_class::nameForLogging(v2);
    v106 = "";
    v107 = " (meta)";
    if (!v6) {
      v107 = "";
    }
    uint64_t v108 = *((void *)v2 + 4);
    v109 = "(swift)";
    if ((v108 & 2) == 0) {
      v109 = "";
    }
    if (v108) {
      v106 = "(pre-stable swift)";
    }
    _objc_inform("CLASS: realizing class '%s'%s %p %p #%u %s%s", v105, v107, v2, v7, 0, v109, v106);
  }
  if (*((void *)v2 + 1)) {
    unint64_t v23 = *((void *)v2 + 1);
  }
  else {
    unint64_t v23 = 0;
  }
  int v24 = (objc_class *)remapClass(v23);
  uint64_t v25 = realizeClassWithoutSwift(v24, 0);
  unint64_t v26 = (objc_class *)remapClass(*(void *)v2 & 0xFFFFFFFF8);
  uint64_t v30 = realizeClassWithoutSwift(v26, 0);
  if (!v25 && (*(unsigned char *)class_data_bits_t::safe_ro<(Authentication)0>((uint64_t *)v2 + 4) & 2) == 0)
  {
    if (PrintConnecting)
    {
      v141 = objc_class::nameForLogging(v2);
      v142 = "";
      if (v6) {
        v142 = " (meta)";
      }
      _objc_inform("CLASS: '%s'%s %p has missing weak superclass, disabling.", v141, v142, v2);
    }
    addRemappedClass(v2, 0);
    *(void *)uint64_t v2 = 0;
    return 0;
  }
  if (!v6)
  {
    if (!DisableNonpointerIsa)
    {
      int v58 = *((unsigned __int16 *)v2 + 15);
      if ((realizeClassWithoutSwift(objc_class *,objc_class *)::hackedDispatch & 1) == 0)
      {
        explicit = (const char *)atomic_load_explicit(v7 + 3, memory_order_acquire);
        if (explicit)
        {
          if (!strcmp(explicit, "OS_object"))
          {
            LOBYTE(v31) = 0;
            realizeClassWithoutSwift(objc_class *,objc_class *)::hackedDispatch = 1;
            goto LABEL_47;
          }
        }
      }
      if (v25 && *(void *)(v25 + 8))
      {
        unsigned int v60 = *(unsigned __int16 *)(v25 + 30);
        if (((v60 | v58) & 0x2000) == 0) {
          goto LABEL_48;
        }
        int v31 = (v60 >> 13) & 1;
        goto LABEL_47;
      }
      if ((v58 & 0x2000) == 0) {
        goto LABEL_48;
      }
    }
    LOBYTE(v31) = 0;
LABEL_47:
    objc_class::setInstancesRequireRawIsaRecursively((uint64_t)v2, v31);
    goto LABEL_48;
  }
  atomic_fetch_or_explicit((atomic_ushort *volatile)v2 + 15, 0x2000u, memory_order_relaxed);
LABEL_48:
  *((void *)v2 + 1) = v25;
  if (DisableNonpointerIsa || (*(_WORD *)(v30 + 30) & 0x2000) != 0)
  {
    if ((v30 & 0xFF80000000000007) == 0)
    {
      uint64_t v32 = v30 & 0x7FFFFFFFFFFFF8;
      goto LABEL_54;
    }
LABEL_221:
    _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", v27, v28, v29, v30);
  }
  if ((v30 & 0xFF80000000000007) != 0) {
    goto LABEL_221;
  }
  uint64_t v32 = v30 & 0x7FFFFFFFFFFFF8 | 0x100000000000001;
LABEL_54:
  uint64_t v33 = &OBJC_IVAR___Object_isa;
  *(void *)uint64_t v2 = v32;
  if (v6 || !v25) {
    goto LABEL_105;
  }
  unint64_t v34 = (class_rw_t *)(*v4 & 0xF00007FFFFFFFF8);
  unint64_t v35 = class_rw_t::ro((class_rw_t *)(*(void *)(v25 + 32) & 0xF00007FFFFFFFF8));
  if (DebugNonFragileIvars)
  {
    unint64_t v36 = (char *)objc_class::mangledName(v2);
    if (!strstr(v36, "NSCF")
      && strncmp(v36, "__CF", 4uLL)
      && strcmp(v36, "NSConstantString")
      && strcmp(v36, "NSSimpleCString"))
    {
      uint64_t v61 = *((unsigned int *)v7 + 1);
      ro_writeable_nolocunint64_t k = make_ro_writeable_nolock(v34);
      unint64_t v63 = class_rw_t::ro(v34);
      int v7 = (atomic_ullong *)v63;
      BOOL v67 = *(unsigned int **)(v63 + 48);
      if (!v67) {
        goto LABEL_191;
      }
      uint64_t v68 = *v67;
      uint64_t v69 = v67[1];
      unint64_t v70 = v69 * (unint64_t)v68;
      if ((v70 & 0xFFFFFFFF00000000) != 0) {
        goto LABEL_248;
      }
      if (v70)
      {
        uint64_t v71 = (uint64_t)v67 + v70 + 8;
        unint64_t v72 = v67 + 2;
        unsigned int v73 = 8;
        do
        {
          unsigned int v74 = v72[6];
          if (v74 == -1) {
            unsigned int v75 = 8;
          }
          else {
            unsigned int v75 = 1 << v74;
          }
          if (v75 > v73) {
            unsigned int v73 = v75;
          }
          unint64_t v72 = (unsigned int *)((char *)v72 + v68);
        }
        while (v72 != (unsigned int *)v71);
      }
      else
      {
LABEL_191:
        unsigned int v73 = 8;
      }
      unsigned int v134 = *(_DWORD *)(v63 + 4);
      int v135 = v134 / v73 * v73;
      int v136 = *(_DWORD *)(ro_writeable_nolock + 8) - v135;
      *(_DWORD *)(ro_writeable_nolock + 4) = v134 - v135;
      *(_DWORD *)(ro_writeable_nolock + 8) = v136;
      if (PrintIvars)
      {
        v156 = objc_class::nameForLogging(v2);
        _objc_inform("IVARS: DEBUG: forcing ivars for class '%s' to slide (instanceStart %zu -> %zu)", v156, v61, *((unsigned int *)v7 + 1));
        BOOL v67 = (unsigned int *)v7[6];
        if (v67)
        {
LABEL_194:
          uint64_t v68 = *v67;
          uint64_t v69 = v67[1];
          unint64_t v137 = v69 * (unint64_t)v68;
          if ((v137 & 0xFFFFFFFF00000000) == 0)
          {
            if (v137)
            {
              uint64_t v138 = (uint64_t)v67 + v137 + 8;
              v139 = (_DWORD **)(v67 + 2);
              do
              {
                if (*v139) {
                  **v139 -= v135;
                }
                v139 = (_DWORD **)((char *)v139 + v68);
              }
              while (v139 != (_DWORD **)v138);
            }
            goto LABEL_200;
          }
LABEL_248:
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v64, v65, v66, v69, v67, v68);
        }
      }
      else if (v67)
      {
        goto LABEL_194;
      }
LABEL_200:
      uint64_t v33 = &OBJC_IVAR___Object_isa;
    }
  }
  if (*((_DWORD *)v7 + 1) < *(_DWORD *)(v35 + 8))
  {
    if (PrintIvars)
    {
      v140 = objc_class::nameForLogging(v2);
      _objc_inform("IVARS: sliding ivars for class %s (superclass was %u bytes, now %u)", v140, *((_DWORD *)v7 + 1), *(_DWORD *)(v35 + 8));
    }
    unint64_t v37 = make_ro_writeable_nolock(v34);
    int v7 = (atomic_ullong *)class_rw_t::ro(v34);
    int v41 = *(_DWORD *)(v37 + 4);
    int v42 = *(_DWORD *)(v35 + 8) - v41;
    unint64_t v43 = *(unsigned int **)(v37 + 48);
    if (v43)
    {
      uint64_t v45 = *v43;
      uint64_t v44 = v43[1];
      unint64_t v46 = v44 * (unint64_t)v45;
      if ((v46 & 0xFFFFFFFF00000000) != 0) {
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v38, v39, v40, v44, *(void *)(v37 + 48), *v43);
      }
      if (v46)
      {
        uint64_t v47 = 0;
        unsigned int v48 = 1;
        uint64_t v49 = v46;
        do
        {
          if (*(void *)((char *)v43 + v47 + 8))
          {
            int v50 = *(unsigned int *)((char *)v43 + v47 + 32);
            unsigned int v51 = v50 == -1 ? 8 : 1 << v50;
            if (v51 > v48) {
              unsigned int v48 = v51;
            }
          }
          v47 += v45;
        }
        while (v49 != v47);
        uint64_t v52 = 0;
        int v42 = (v42 + v48 - 1) & -v48;
        unint64_t v53 = &OBJC_IVAR___Object_isa;
        do
        {
          unint64_t v54 = *(int **)((char *)v43 + v52 + 8);
          if (v54)
          {
            int v55 = *v54;
            *v54 += v42;
            if (v53[238])
            {
              int v56 = *(unsigned int *)((char *)v43 + v52 + 32);
              if (v56 == -1) {
                int v57 = 8;
              }
              else {
                int v57 = 1 << v56;
              }
              _objc_inform("IVARS:    offset %u -> %u for %s (size %u, align %u)", v55, v55 + v42, *(const char **)((char *)v43 + v52 + 16), *(unsigned int *)((char *)v43 + v52 + 36), v57);
              unint64_t v53 = &OBJC_IVAR___Object_isa;
            }
          }
          v52 += v45;
        }
        while (v49 != v52);
        int v41 = *(_DWORD *)(v37 + 4);
        uint64_t v33 = &OBJC_IVAR___Object_isa;
      }
    }
    int v76 = *(_DWORD *)(v37 + 8) + v42;
    *(_DWORD *)(v37 + 4) = v42 + v41;
    *(_DWORD *)(v37 + 8) = v76;
    atomic_load_explicit(v7 + 3, memory_order_acquire);
    gdb_objc_class_changed();
  }
LABEL_105:
  objc_class::setInstanceSize(v2, *((_DWORD *)v7 + 2));
  int v77 = *(_DWORD *)v7;
  if ((*(_DWORD *)v7 & 4) != 0)
  {
    atomic_fetch_or_explicit((atomic_ushort *volatile)v2 + 15, 1u, memory_order_relaxed);
    int v77 = *(_DWORD *)v7;
    if ((*(_DWORD *)v7 & 0x100) == 0)
    {
      atomic_fetch_or_explicit((atomic_ushort *volatile)v2 + 15, 2u, memory_order_relaxed);
      int v77 = *(_DWORD *)v7;
    }
  }
  if ((v77 & 0x400) != 0)
  {
    *(_DWORD *)v170 |= 0x100000u;
    if (v25)
    {
LABEL_113:
      addSubclass(v25, v2);
      uint64_t v78 = *((void *)v2 + 4);
      goto LABEL_115;
    }
  }
  else if (v25)
  {
    if ((*(unsigned char *)((*(void *)(v25 + 32) & 0xF00007FFFFFFFF8) + 2) & 0x10) != 0) {
      *(_DWORD *)v170 |= 0x100000u;
    }
    goto LABEL_113;
  }
  ++objc_debug_realized_class_generation_count;
  uint64_t v78 = *((void *)v2 + 4);
  *(void *)((v78 & 0xF00007FFFFFFFF8) + 0x18) = _firstRealizedClass;
  _firstRealizedClass Class = (uint64_t)v2;
LABEL_115:
  __int16 v79 = *((_WORD *)v2 + 15);
  uint64_t v80 = v78 & 0xF00007FFFFFFFF8;
  unint64_t v84 = class_rw_t::ro((class_rw_t *)(v78 & 0xF00007FFFFFFFF8));
  if (v33[292])
  {
    v110 = objc_class::nameForLogging(v2);
    v111 = "(meta)";
    if ((v79 & 4) == 0) {
      v111 = "";
    }
    _objc_inform("CLASS: methodizing class '%s' %s", v110, v111);
  }
  char v168 = v79;
  uint64_t v85 = *(void *)(v84 + 32);
  if (v85) {
    BOOL v86 = (*(void *)(v84 + 32) & 1) == 0;
  }
  else {
    BOOL v86 = 0;
  }
  if (v86)
  {
    v173 = (method_list_t *)(v85 & 0xFFFFFFFFFFFFFFFELL);
    if ((v85 & 0xFFFFFFFFFFFFFFFELL) != 0)
    {
      unint64_t v94 = (_DWORD *)class_rw_t::ro((class_rw_t *)(*((void *)v2 + 4) & 0xF00007FFFFFFFF8));
      prepareMethodLists(v2, &v173, 1, (char *)1, (*v94 >> 29) & 1, 0);
    }
  }
  else
  {
    v173 = 0;
    if (v85)
    {
      unint64_t v87 = (unsigned int *)(v85 & 0xFFFFFFFFFFFFFFFELL);
      if ((v85 & 0xFFFFFFFFFFFFFFFELL) != 0)
      {
        v166 = (objc_class *)v80;
        if (DisablePreattachedCategories)
        {
          uint64_t v90 = *v87;
          uint64_t v89 = v87[1];
          unint64_t v157 = v89 * (unint64_t)v90;
          if ((v157 & 0xFFFFFFFF00000000) != 0) {
            goto LABEL_236;
          }
          uint64_t v158 = (uint64_t)v87 + v157 + 8;
          BOOL v159 = v89 == 0;
          uint64_t v89 = v89 ? v89 : 0;
          uint64_t v88 = (uint64_t *)(v159 ? v158 : v158 - v90);
        }
        else
        {
          uint64_t v88 = (uint64_t *)(v87 + 2);
          uint64_t v90 = *v87;
          uint64_t v89 = v87[1];
        }
        unint64_t v91 = v89 * (unint64_t)v90;
        if ((v91 & 0xFFFFFFFF00000000) != 0) {
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v81, v82, v83, v89, v87, v90);
        }
        v171 = v87 + 2;
        unint64_t v92 = (unint64_t)v87 + v91 + 8;
        if ((unint64_t)v88 < v92)
        {
          while ((*(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v88 + 8) & 1) == 0)
          {
            uint64_t v88 = (uint64_t *)((char *)v88 + v90);
            unsigned int v93 = v90;
            if ((unint64_t)v88 >= v92) {
              goto LABEL_144;
            }
          }
        }
        unsigned int v93 = v90;
LABEL_144:
        if (v88 == (uint64_t *)v92)
        {
          unsigned int v98 = 0;
        }
        else
        {
          unsigned int v98 = 0;
          do
          {
            v172 = 0;
            v172 = (method_list_t *)((char *)v88 + (*v88 >> 16));
            uint64_t v90 = *v87;
            uint64_t v89 = v87[1];
            unint64_t v99 = v89 * (unint64_t)v90;
            if ((v99 & 0xFFFFFFFF00000000) != 0) {
              goto LABEL_236;
            }
            uint64_t v100 = v93;
            unint64_t v101 = (unint64_t)v171 + v99;
            v102 = (uint64_t *)((char *)v88 + v93);
            do
            {
              uint64_t v88 = v102;
              if ((unint64_t)v102 >= v101) {
                break;
              }
              uint64_t v103 = *(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v102 + 8);
              v102 = (uint64_t *)((char *)v102 + v100);
            }
            while ((v103 & 1) == 0);
            v104 = (_DWORD *)class_rw_t::ro((class_rw_t *)(*((void *)v2 + 4) & 0xF00007FFFFFFFF8));
            prepareMethodLists(v2, &v172, 1, (char *)(v88 == (uint64_t *)v92), (*v104 >> 29) & 1, 0);
            unsigned int v93 = v100;
            ++v98;
          }
          while (v88 != (uint64_t *)v92);
          LODWORD(v89) = v87[1];
          uint64_t v33 = &OBJC_IVAR___Object_isa;
        }
        if (v89 >= 0x64 && v98 <= v89 >> 1)
        {
          if (v33[292])
          {
            v143 = objc_class::nameForLogging(v2);
            v144 = "(meta)";
            if ((v79 & 4) == 0) {
              v144 = "";
            }
            _objc_inform("CLASS: Copying preoptimized categories for sparsely loaded class '%s' %s - %u lists, %u loaded - loaded lists are:", v143, v144, v87[1], v98);
            if (DisablePreattachedCategories)
            {
              uint64_t v149 = *v87;
              uint64_t v148 = v87[1];
              unint64_t v163 = v148 * (unint64_t)v149;
              if ((v163 & 0xFFFFFFFF00000000) != 0) {
                _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v145, v146, v147, v148, v87, *v87);
              }
              v164 = (char *)v171 + v163;
              BOOL v165 = v148 == 0;
              uint64_t v148 = v148 ? v148 : 0;
              v150 = (uint64_t *)(v165 ? v164 : &v164[-v149]);
            }
            else
            {
              uint64_t v149 = *v87;
              uint64_t v148 = v87[1];
              v150 = (uint64_t *)(v87 + 2);
            }
            unint64_t v151 = v148 * (unint64_t)v149;
            if ((v151 & 0xFFFFFFFF00000000) != 0) {
              _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v145, v146, v147, v148, v87, v149);
            }
            for (uint64_t i = (uint64_t *)((char *)v171 + v151); v150 < i; v150 = (uint64_t *)((char *)v150 + v149))
            {
              if (*(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v150 + 8)) {
                break;
              }
            }
            if (v150 != i)
            {
              while (1)
              {
                _objc_inform("    %p", (char *)v150 + (*v150 >> 16));
                uint64_t v90 = *v87;
                uint64_t v89 = v87[1];
                unint64_t v153 = v89 * (unint64_t)v90;
                if ((v153 & 0xFFFFFFFF00000000) != 0) {
                  break;
                }
                v154 = (uint64_t *)((char *)v150 + v149);
                do
                {
                  v150 = v154;
                  if (v154 >= (uint64_t *)((char *)v171 + v153)) {
                    break;
                  }
                  uint64_t v155 = *(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v154 + 8);
                  v154 = (uint64_t *)((char *)v154 + v149);
                }
                while ((v155 & 1) == 0);
                if (v150 == i) {
                  goto LABEL_168;
                }
              }
LABEL_236:
              _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v81, v82, v83, v89, v87, v90);
            }
          }
LABEL_168:
          v117 = class_rw_t::extAllocIfNeeded(v166) + 1;
          if (*v117 && (*v117 & 3) == 2) {
            v118 = (unsigned int *)(*v117 & 0xFFFFFFFFFFFFFFFCLL);
          }
          else {
            v118 = 0;
          }
          if (DisablePreattachedCategories)
          {
            uint64_t v120 = *v118;
            uint64_t v121 = v118[1];
            unint64_t v160 = v121 * (unint64_t)v120;
            if ((v160 & 0xFFFFFFFF00000000) != 0) {
              _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v112, v113, v114, v121, v118, *v118);
            }
            uint64_t v161 = (uint64_t)v118 + v160 + 8;
            BOOL v162 = v121 == 0;
            if (v121) {
              uint64_t v121 = v121;
            }
            else {
              uint64_t v121 = 0;
            }
            if (v162) {
              v119 = (uint64_t *)v161;
            }
            else {
              v119 = (uint64_t *)(v161 - v120);
            }
          }
          else
          {
            v119 = (uint64_t *)(v118 + 2);
            uint64_t v120 = *v118;
            uint64_t v121 = v118[1];
          }
          unint64_t v122 = v121 * (unint64_t)v120;
          if ((v122 & 0xFFFFFFFF00000000) != 0) {
            _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v112, v113, v114, v121, v118, v120);
          }
          unint64_t v123 = (unint64_t)v118 + v122 + 8;
          if ((unint64_t)v119 < v123)
          {
            while ((*(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v119 + 8) & 1) == 0)
            {
              v119 = (uint64_t *)((char *)v119 + v120);
              unsigned int v124 = v120;
              if ((unint64_t)v119 >= v123) {
                goto LABEL_180;
              }
            }
          }
          unsigned int v124 = v120;
LABEL_180:
          if (v98 == 1)
          {
            unint64_t *v117 = (unint64_t)v119 + (*v119 >> 16);
          }
          else
          {
            unint64_t v125 = (unint64_t)malloc_type_malloc(8 * v98 + 8, 0x8BC14CD7uLL);
            unint64_t *v117 = v125 | 1;
            *(_DWORD *)unint64_t v125 = v98;
            if (v98)
            {
              uint64_t v126 = 0;
              uint64_t v128 = *v118;
              uint64_t v127 = v118[1];
              unint64_t v129 = v127 * (unint64_t)v128;
              BOOL v130 = (v129 & 0xFFFFFFFF00000000) != 0;
              unint64_t v131 = (unint64_t)v118 + v129 + 8;
              do
              {
                *(void *)(v125 + 8 * v126 + 8) = (char *)v119 + (*v119 >> 16);
                if (v130) {
                  _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v112, v113, v114, v127, v118, v128);
                }
                ++v126;
                v132 = (uint64_t *)((char *)v119 + v124);
                do
                {
                  v119 = v132;
                  if ((unint64_t)v132 >= v131) {
                    break;
                  }
                  uint64_t v133 = *(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v132 + 8);
                  v132 = (uint64_t *)((char *)v132 + v124);
                }
                while ((v133 & 1) == 0);
              }
              while (v126 != v98);
            }
          }
          list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::validate(v117, v112, v113, v114, v115, v116);
        }
      }
    }
  }
  if ((objc_class *)(*(void *)v2 & 0xFFFFFFFF8) == v2) {
    addMethod(v2, (objc_selector *)sel_initialize, (void (*)(void))objc_noop_imp, "", 0);
  }
  if (v169)
  {
    if ((v168 & 4) != 0) {
      uint64_t v95 = 2;
    }
    else {
      uint64_t v95 = 4;
    }
    objc::UnattachedCategories::attachToClass(v2, v169, (objc_class *)v95);
  }
  if ((v168 & 4) != 0) {
    uint64_t v96 = 2;
  }
  else {
    uint64_t v96 = 1;
  }
  objc::UnattachedCategories::attachToClass(v2, v2, (objc_class *)v96);
  return v2;
}

unint64_t objc_class::demangledName(objc_class *this, int a2)
{
  if ((unint64_t)(*(void *)this - 1) >= 0xF)
  {
    uint64_t v4 = *((void *)this + 4);
    int v5 = *(_DWORD *)(v4 & 0xF00007FFFFFFFF8);
    if (v5 < 0)
    {
      if ((v5 & 0x40000000) == 0 && ((*((_WORD *)this + 15) & 4) != 0 || (v4 & 3) != 0))
      {
        uint64_t v24 = *(void *)((v4 & 0xF00007FFFFFFFF8) + 8);
        if ((v24 & 1) != 0 && (v24 & 0xFFFFFFFFFFFFFFFELL) != 0)
        {
          int v6 = *(char **)((v24 & 0xFFFFFFFFFFFFFFFELL) + 32);
          if (v6) {
            return (unint64_t)v6;
          }
        }
        goto LABEL_4;
      }
    }
    else if ((v5 & 0x40000000) == 0)
    {
      goto LABEL_4;
    }
    return atomic_load_explicit((atomic_ullong *volatile)(class_rw_t::ro((class_rw_t *)(v4 & 0xF00007FFFFFFFF8)) + 24), memory_order_acquire);
  }
LABEL_4:
  int v6 = (char *)objc_class::mangledName(this);
  int v7 = copySwiftV1DemangledName(v6, 0);
  uint64_t v25 = v7;
  if ((unint64_t)(*(void *)this - 1) >= 0xF
    && (uint64_t v10 = *((void *)this + 4),
        uint64_t v9 = (void *)((char *)this + 32),
        uint64_t v8 = v10,
        *(_DWORD *)(v10 & 0xF00007FFFFFFFF8) >> 30))
  {
    if (a2)
    {
      int v16 = 0;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v16, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
      if (v16) {
        os_unfair_lock_lock_with_options();
      }
      int v18 = class_rw_t::extAllocIfNeeded((class_rw_t *)(*v9 & 0xF00007FFFFFFFF8));
      int v19 = *(_DWORD *)(StatusReg + 24);
      int v20 = v19;
      atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v20, 0, memory_order_release, memory_order_relaxed);
      if (v20 != v19) {
        os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
      }
    }
    else
    {
      int v18 = class_rw_t::extAllocIfNeeded((class_rw_t *)(v8 & 0xF00007FFFFFFFF8));
    }
    uint64_t v21 = 0;
    uint64_t v22 = v25;
    if (!v25) {
      uint64_t v22 = v6;
    }
    atomic_compare_exchange_strong((atomic_ullong *volatile)v18 + 4, (unint64_t *)&v21, (unint64_t)v22);
    if (v21 && v25) {
      free(v25);
    }
    return v18[4];
  }
  else if (v7)
  {
    int v11 = 0;
    unint64_t v12 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(&DemangleCacheLock, (unsigned int *)&v11, *(_DWORD *)(v12 + 24), memory_order_acquire, memory_order_acquire);
    if (v11) {
      os_unfair_lock_lock_with_options();
    }
    atomic_uint v13 = (int32x2_t *)DemangleCache;
    if (!DemangleCache)
    {
      atomic_uint v13 = (int32x2_t *)malloc_type_malloc(0x18uLL, 0xB4ED9BFAuLL);
      *atomic_uint v13 = 0;
      v13[1] = 0;
      v13[2] = 0;
      DemangleCache = (uint64_t)v13;
    }
    objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::try_emplace<objc::detail::DenseSetEmpty&>((uint64_t)&v26, v13, (char **)&v25);
    int v6 = *v26;
    int v14 = *(_DWORD *)(v12 + 24);
    int v15 = v14;
    atomic_compare_exchange_strong_explicit(&DemangleCacheLock, (unsigned int *)&v15, 0, memory_order_release, memory_order_relaxed);
    if (v15 != v14) {
      os_unfair_lock_unlock((os_unfair_lock_t)&DemangleCacheLock);
    }
    if (v6 != v25) {
      free(v25);
    }
  }
  return (unint64_t)v6;
}

void sub_18011C0DC(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit((atomic_uint *volatile)v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock(v1);
  }
  _Unwind_Resume(exception_object);
}

void *__cdecl object_getIndexedIvars(id a1)
{
  if ((uint64_t)a1 < 1) {
    return 0;
  }
  if ((*(_WORD *)((*(void *)a1 & 0xFFFFFFFF8) + 0x1E) & 4) == 0) {
    return (char *)a1
  }
         + ((*(_DWORD *)(class_rw_t::ro((class_rw_t *)(*(void *)((*(void *)a1 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8))
                       + 8)
           + 7) & 0xFFFFFFF8);
  if ((*((unsigned char *)a1 + 32) & 3) != 0) {
    return (char *)a1 + ((*((_DWORD *)a1 + 14) + 7) & 0xFFFFFFF8) - *((unsigned int *)a1 + 15);
  }
  return (char *)a1 + 40;
}

unint64_t class_rw_t::ro(class_rw_t *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1)
  {
    uint64_t v3 = *(void *)(v1 & 0xFFFFFFFFFFFFFFFELL);
    if (v3) {
      return v3;
    }
  }
  else if (v1)
  {
    return v1 & 0xFFFFFFFFFFFFFFFELL;
  }
  return 0;
}

unint64_t remapClass(unint64_t result)
{
  if (!result || !byte_1EB1CA648) {
    return result;
  }
  if (remappedClasses(BOOL)::remapped_class_map) {
    uint64_t v1 = (void *)remappedClasses(BOOL)::remapped_class_map;
  }
  else {
    uint64_t v1 = 0;
  }
  if (!dword_1EB1CA640) {
    goto LABEL_13;
  }
  LODWORD(v2) = (dword_1EB1CA640 - 1) & (bswap64(0x8A970BE7488FDA55 * (result ^ (result >> 4))) ^ (1217387093 * (result ^ (result >> 4))));
  uint64_t v3 = &v1[2 * v2];
  uint64_t v4 = *v3;
  if (*v3 != result)
  {
    unsigned int v5 = 1;
    while (v4 != -1)
    {
      if (v5 > dword_1EB1CA640) {
        objc::DenseMapBase<objc::DenseMap<objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>,objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>::FatalCorruptHashTables(v1, dword_1EB1CA640);
      }
      int v6 = v2 + v5++;
      uint64_t v2 = v6 & (dword_1EB1CA640 - 1);
      uint64_t v4 = v1[2 * v2];
      if (v4 == result)
      {
        uint64_t v3 = &v1[2 * v2];
        goto LABEL_17;
      }
    }
LABEL_13:
    if (remappedClasses(BOOL)::remapped_class_map) {
      uint64_t v7 = remappedClasses(BOOL)::remapped_class_map;
    }
    else {
      uint64_t v7 = 0;
    }
    uint64_t v3 = (uint64_t *)(v7 + 16 * dword_1EB1CA640);
  }
LABEL_17:
  if (remappedClasses(BOOL)::remapped_class_map) {
    uint64_t v8 = remappedClasses(BOOL)::remapped_class_map;
  }
  else {
    uint64_t v8 = 0;
  }
  if ((uint64_t *)(v8 + 16 * dword_1EB1CA640) != v3) {
    return v3[1];
  }
  return result;
}

unint64_t class_data_bits_t::safe_ro<(Authentication)0>(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 < 0) {
    return class_rw_t::ro((class_rw_t *)(v1 & 0xF00007FFFFFFFF8));
  }
  else {
    return v1 & 0xF00007FFFFFFFF8;
  }
}

uint64_t addSubclass(uint64_t result, objc_class *this)
{
  if (!result || !this) {
    return result;
  }
  uint64_t v3 = result;
  ++objc_debug_realized_class_generation_count;
  uint64_t v4 = (uint64_t *)(result + 32);
  uint64_t v5 = *(void *)(result + 32) & 0xF00007FFFFFFFF8;
  uint64_t v7 = (void *)((char *)this + 32);
  uint64_t v6 = *((void *)this + 4);
  *(void *)((v6 & 0xF00007FFFFFFFF8) + 0x18) = *(void *)(v5 + 0x10);
  *(void *)(v5 + 16) = this;
  __int16 v8 = *(_WORD *)(result + 30);
  if ((v8 & 2) == 0)
  {
    if ((v8 & 1) == 0) {
      goto LABEL_5;
    }
LABEL_25:
    atomic_fetch_or_explicit((atomic_ushort *volatile)this + 15, 1u, memory_order_relaxed);
    __int16 v8 = *(_WORD *)(result + 30);
    if ((v8 & 0x1000) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  atomic_fetch_or_explicit((atomic_ushort *volatile)this + 15, 2u, memory_order_relaxed);
  __int16 v8 = *(_WORD *)(result + 30);
  if (v8) {
    goto LABEL_25;
  }
LABEL_5:
  if ((v8 & 0x1000) != 0)
  {
LABEL_6:
    atomic_fetch_or_explicit((atomic_ushort *volatile)this + 15, 0x1000u, memory_order_relaxed);
    __int16 v8 = *(_WORD *)(result + 30);
  }
LABEL_7:
  uint64_t v9 = *v4;
  if (v8 >= 0) {
    unsigned int v10 = (*v4 & 4 | ((v8 & 0x4000) == 0)) ^ 4 | 0x10;
  }
  else {
    unsigned int v10 = (*v4 & 4 | ((v8 & 0x4000) == 0)) ^ 4;
  }
  if ((*((_WORD *)this + 15) & 0x4000) == 0) {
    v10 &= 0xFFFFFFFC;
  }
  if ((v6 & 4) != 0) {
    unsigned int v11 = v10;
  }
  else {
    unsigned int v11 = v10 & 0xFFFFFFF3;
  }
  if (*((__int16 *)this + 15) >= 0) {
    unsigned int v12 = v11 & 0xFFFFFFEF;
  }
  else {
    unsigned int v12 = v11;
  }
  if (v12)
  {
    unint64_t result = objc::Scanner::propagateCustomFlags((uint64_t)this, v12, 1);
    uint64_t v9 = *v4;
  }
  int v13 = *(_DWORD *)(v9 & 0xF00007FFFFFFFF8);
  if ((v13 & 2) != 0)
  {
    unint64_t result = objc_class::setDisallowPreoptCachesRecursively((uint64_t)this, "addSubclass");
  }
  else if ((v13 & 4) != 0 && (*(unsigned char *)(*v7 & 0xF00007FFFFFFFF8) & 4) == 0)
  {
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3321888768;
    v14[2] = ___ZN10objc_class39setDisallowPreoptInlinedSelsRecursivelyEPKc_block_invoke;
    v14[3] = &__block_descriptor_48_e8_32c69_ZTSKZN10objc_class39setDisallowPreoptInlinedSelsRecursivelyEPKcE3__0_e8_B16__0_8l;
    v14[4] = this;
    v14[5] = "addSubclass";
    unint64_t result = foreach_realized_class_and_subclass((uint64_t)this, (uint64_t)v14);
  }
  if ((*(_WORD *)(v3 + 30) & 0x2000) != 0 && *(void *)(v3 + 8))
  {
    return objc_class::setInstancesRequireRawIsaRecursively((uint64_t)this, 1);
  }
  return result;
}

unint64_t *class_data_bits_t::setData(unint64_t *this, unint64_t a2)
{
  unint64_t v2 = *this;
  __dmb(0xBu);
  *this = v2 & 7 | a2 | 0x8000000000000000;
  return this;
}

void objc::UnattachedCategories::attachToClass(objc::UnattachedCategories *this, objc_class *a2, objc_class *a3)
{
  int v3 = (int)a3;
  uint64_t v6 = objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::find((unint64_t)a2);
  uint64_t v7 = (void *)v6;
  if (objc::unattachedCategories + 24 * dword_1EB1CB0C8 != v6)
  {
    __int16 v8 = (void **)(v6 + 8);
    if ((v3 & 4) != 0)
    {
      unsigned int v15 = v3 & 0xFFFFFFFB;
      uint64_t v16 = *(void *)(v6 + 16);
      if (v16) {
        uint64_t v17 = *(void *)(v6 + 8);
      }
      else {
        uint64_t v17 = v6 + 8;
      }
      if (v16) {
        unint64_t v18 = v16 >> 1;
      }
      else {
        unint64_t v18 = *(void *)(v6 + 8) != 0;
      }
      attachCategories((uint64_t)this, v17, (const char *)v18, (char *)a2, v15 | 1);
      unsigned int v12 = (objc::UnattachedCategories *)(*(void *)this & 0xFFFFFFFF8);
      uint64_t v19 = v7[2];
      if (v19) {
        uint64_t v10 = v7[1];
      }
      else {
        uint64_t v10 = (uint64_t)(v7 + 1);
      }
      if (v19) {
        unint64_t v11 = v19 >> 1;
      }
      else {
        unint64_t v11 = v7[1] != 0;
      }
      int v14 = v15 | 2;
      int v13 = (char *)a2;
    }
    else
    {
      uint64_t v9 = *(void *)(v6 + 16);
      if (v9) {
        uint64_t v10 = *(void *)(v6 + 8);
      }
      else {
        uint64_t v10 = v6 + 8;
      }
      if (v9) {
        unint64_t v11 = v9 >> 1;
      }
      else {
        unint64_t v11 = *(void *)(v6 + 8) != 0;
      }
      unsigned int v12 = this;
      int v13 = (char *)a2;
      int v14 = v3;
    }
    attachCategories((uint64_t)v12, v10, (const char *)v11, v13, v14);
    if (v7[2]) {
      free(*v8);
    }
    *uint64_t v7 = -2;
    qword_1EB1CB0C0 = (uint64_t)vadd_s32((int32x2_t)qword_1EB1CB0C0, (int32x2_t)0x1FFFFFFFFLL);
    objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::compact();
  }
}

uint64_t objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::find(unint64_t a1)
{
  if (objc::unattachedCategories) {
    uint64_t v1 = (void *)objc::unattachedCategories;
  }
  else {
    uint64_t v1 = 0;
  }
  if (dword_1EB1CB0C8)
  {
    int v2 = dword_1EB1CB0C8 - 1;
    unsigned int v3 = (dword_1EB1CB0C8 - 1) & (bswap64(0x8A970BE7488FDA55 * (a1 ^ (a1 >> 4))) ^ (1217387093 * (a1 ^ (a1 >> 4))));
    uint64_t v4 = &v1[3 * v3];
    uint64_t v5 = *v4;
    if (*v4 == a1) {
      return (uint64_t)v4;
    }
    unsigned int v6 = 1;
    while (v5 != -1)
    {
      if (v6 > dword_1EB1CB0C8) {
        objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::FatalCorruptHashTables(v1, dword_1EB1CB0C8);
      }
      unsigned int v7 = v3 + v6++;
      unsigned int v3 = v7 & v2;
      uint64_t v4 = &v1[3 * (v7 & v2)];
      uint64_t v5 = *v4;
      if (*v4 == a1) {
        return (uint64_t)v4;
      }
    }
  }
  if (objc::unattachedCategories) {
    return objc::unattachedCategories + 24 * dword_1EB1CB0C8;
  }
  else {
    return 24 * dword_1EB1CB0C8;
  }
}

void prepareMethodLists(objc_class *this, method_list_t **a2, int a3, char *a4, uint64_t a5, const char *a6)
{
  if (!a3) {
    return;
  }
  if ((a4 & 1) == 0)
  {
    uint64_t v10 = (objc_cache *)*((void *)this + 2);
    if ((v10 & 1) != 0
      || (v10 != &_objc_empty_cache ? (BOOL v11 = HIWORD(*((void *)this + 2)) == 0) : (BOOL v11 = 0), v11))
    {
      objc_class::setDisallowPreoptCachesRecursively((uint64_t)this, a6);
    }
    else if ((*(unsigned char *)(*((void *)this + 4) & 0xF00007FFFFFFFF8) & 4) == 0)
    {
      if (a3 <= 0) {
        goto LABEL_17;
      }
      goto LABEL_13;
    }
  }
  if (a3 < 1) {
    goto LABEL_17;
  }
LABEL_13:
  uint64_t v12 = a3;
  int v13 = (uint64_t *)a2;
  do
  {
    if ((~*(_DWORD *)*v13 & 3) != 0) {
      fixupMethodList(*v13, a5, (const char *)1, a4);
    }
    ++v13;
    --v12;
  }
  while (v12);
LABEL_17:
  int v14 = *(_DWORD *)(*((void *)this + 4) & 0xF00007FFFFFFFF8);
  if ((v14 & 1) == 0) {
    int v14 = *(_DWORD *)(*(void *)((*(void *)this & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  }
  if ((v14 & 0x20000000) != 0 && a3 >= 1)
  {
    uint64_t v15 = 0;
    uint64_t v16 = &a2[a3];
    do
    {
      unint64_t v18 = (unint64_t)*a2++;
      unint64_t v17 = v18;
      int v19 = *(_DWORD *)v18;
      if ((v18 & 0x8000000000000000) != 0)
      {
        uint64_t v40 = (unsigned __int16)v19 & 0xFFFC;
        uint64_t v41 = *(unsigned int *)(v17 + 4);
        unint64_t v42 = v41 * (unint64_t)v40;
        if ((v42 & 0xFFFFFFFF00000000) != 0) {
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v15, sel__tryRetain, sel__isDeallocating, sel_retainCount, sel_allowsWeakReference, sel_retainWeakReference, v41, v17, v40);
        }
        unint64_t v43 = v17 + 8;
        unint64_t v44 = v43 & 0xFFFFFFFFFFFFFFFCLL | 2;
        unint64_t v45 = (v43 + v42) & 0xFFFFFFFFFFFFFFFCLL | 2;
        while (v44 != v45)
        {
          uint64_t v46 = 0;
          while (1)
          {
            uint64_t v47 = *(char **)((v44 + v46) & 0xFFFFFFFFFFFFFFFCLL);
            if ((objc::InterestingSelectorZeroes & (unint64_t)v47) == 0
              && (objc::InterestingSelectorOnes & (unint64_t)v47) == objc::InterestingSelectorOnes)
            {
              break;
            }
            v46 += v40;
            if (v44 + v46 == v45) {
              goto LABEL_178;
            }
          }
          if (sel_alloc == v47 || sel_allocWithZone_ == v47)
          {
            uint64_t v15 = v15 | 1;
          }
          else if (sel_retain == v47 {
                 || sel_release == v47
          }
                 || sel_autorelease == v47
                 || sel__tryRetain == v47
                 || sel__isDeallocating == v47
                 || sel_retainCount == v47
                 || sel_allowsWeakReference == v47
                 || sel_retainWeakReference == v47)
          {
            uint64_t v15 = v15 | 4;
          }
          else
          {
            BOOL v48 = sel_respondsToSelector_ == v47 || sel_isKindOfClass_ == v47;
            BOOL v49 = v48 || sel_class == v47;
            BOOL v50 = v49 || sel_self == v47;
            BOOL v51 = v50 || &sel_new == (_UNKNOWN *)v47;
            uint64_t v15 = v51 ? v15 | 0x10 : v15;
          }
          if (v15 == 21) {
            break;
          }
          v44 += v46 + v40;
        }
      }
      else if (v19 < 0)
      {
        uint64_t v20 = (unsigned __int16)v19 & 0xFFFC;
        uint64_t v21 = *(unsigned int *)(v17 + 4);
        unint64_t v52 = v21 * (unint64_t)v20;
        if (dataSegmentsRanges <= v17 && *(void *)algn_1EB1CB078 > v17)
        {
          if ((v52 & 0xFFFFFFFF00000000) != 0) {
LABEL_243:
          }
            _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v15, sel__tryRetain, sel__isDeallocating, sel_retainCount, sel_allowsWeakReference, sel_retainWeakReference, v21, v17, v20);
          unint64_t v71 = (v17 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
          unint64_t v72 = (v17 + 8 + v52) & 0xFFFFFFFFFFFFFFFCLL | 1;
          while (v71 != v72)
          {
            uint64_t v73 = 0;
            while (1)
            {
              unsigned int v74 = (char *)&unk_1F62995A8 + *(int *)((v71 + v73) & 0xFFFFFFFFFFFFFFFCLL);
              if (((unint64_t)v74 & objc::InterestingSelectorZeroes) == 0
                && (objc::InterestingSelectorOnes & (unint64_t)v74) == objc::InterestingSelectorOnes)
              {
                break;
              }
              v73 += v20;
              if (v71 + v73 == v72) {
                goto LABEL_178;
              }
            }
            if (sel_alloc == v74 || sel_allocWithZone_ == v74)
            {
              uint64_t v15 = v15 | 1;
            }
            else
            {
              BOOL v77 = sel_retain == v74 || sel_release == v74;
              BOOL v78 = v77 || sel_autorelease == v74;
              BOOL v79 = v78 || sel__tryRetain == v74;
              BOOL v80 = v79 || sel__isDeallocating == v74;
              BOOL v81 = v80 || sel_retainCount == v74;
              BOOL v82 = v81 || sel_allowsWeakReference == v74;
              if (v82 || sel_retainWeakReference == v74)
              {
                uint64_t v15 = v15 | 4;
              }
              else
              {
                BOOL v84 = sel_respondsToSelector_ == v74 || sel_isKindOfClass_ == v74;
                BOOL v85 = v84 || sel_class == v74;
                BOOL v86 = v85 || sel_self == v74;
                BOOL v87 = v86 || &sel_new == (_UNKNOWN *)v74;
                uint64_t v15 = v87 ? v15 | 0x10 : v15;
              }
            }
            if (v15 == 21) {
              break;
            }
            v71 += v73 + v20;
          }
        }
        else
        {
          if ((v52 & 0xFFFFFFFF00000000) != 0) {
            goto LABEL_243;
          }
          unint64_t v54 = (v17 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
          for (unint64_t i = (v17 + 8 + v52) & 0xFFFFFFFFFFFFFFFCLL | 1; v54 != i; v54 += v56 + v20)
          {
            uint64_t v56 = 0;
            while (1)
            {
              int v57 = *(char **)(((v54 + v56) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v54 + v56) & 0xFFFFFFFFFFFFFFFCLL));
              if ((objc::InterestingSelectorZeroes & (unint64_t)v57) == 0
                && (objc::InterestingSelectorOnes & (unint64_t)v57) == objc::InterestingSelectorOnes)
              {
                break;
              }
              v56 += v20;
              if (v54 + v56 == i) {
                goto LABEL_178;
              }
            }
            if (sel_alloc == v57 || sel_allocWithZone_ == v57)
            {
              uint64_t v15 = v15 | 1;
            }
            else if (sel_retain == v57 {
                   || sel_release == v57
            }
                   || sel_autorelease == v57
                   || sel__tryRetain == v57
                   || sel__isDeallocating == v57
                   || sel_retainCount == v57
                   || sel_allowsWeakReference == v57
                   || sel_retainWeakReference == v57)
            {
              uint64_t v15 = v15 | 4;
            }
            else if (sel_respondsToSelector_ == v57 {
                   || sel_isKindOfClass_ == v57
            }
                   || sel_class == v57
                   || sel_self == v57
                   || &sel_new == (_UNKNOWN *)v57)
            {
              uint64_t v15 = v15 | 0x10;
            }
            else
            {
              uint64_t v15 = v15;
            }
            if (v15 == 21) {
              break;
            }
          }
        }
      }
      else
      {
        uint64_t v20 = (unsigned __int16)v19 & 0xFFFC;
        uint64_t v21 = *(unsigned int *)(v17 + 4);
        unint64_t v22 = v21 * (unint64_t)v20;
        if ((v22 & 0xFFFFFFFF00000000) != 0) {
          goto LABEL_243;
        }
        unint64_t v23 = (v17 + 8) & 0xFFFFFFFFFFFFFFFCLL;
        unint64_t v24 = (v17 + 8 + v22) & 0xFFFFFFFFFFFFFFFCLL;
        while (v23 != v24)
        {
          uint64_t v25 = 0;
          while (1)
          {
            unint64_t v26 = *(char **)((v23 + v25) & 0xFFFFFFFFFFFFFFFCLL);
            if ((objc::InterestingSelectorZeroes & (unint64_t)v26) == 0
              && (objc::InterestingSelectorOnes & (unint64_t)v26) == objc::InterestingSelectorOnes)
            {
              break;
            }
            v25 += v20;
            if (v23 + v25 == v24) {
              goto LABEL_178;
            }
          }
          if (sel_alloc == v26 || sel_allocWithZone_ == v26)
          {
            uint64_t v15 = v15 | 1;
          }
          else
          {
            BOOL v29 = sel_retain == v26 || sel_release == v26;
            BOOL v30 = v29 || sel_autorelease == v26;
            BOOL v31 = v30 || sel__tryRetain == v26;
            BOOL v32 = v31 || sel__isDeallocating == v26;
            BOOL v33 = v32 || sel_retainCount == v26;
            BOOL v34 = v33 || sel_allowsWeakReference == v26;
            if (v34 || sel_retainWeakReference == v26)
            {
              uint64_t v15 = v15 | 4;
            }
            else
            {
              BOOL v36 = sel_respondsToSelector_ == v26 || sel_isKindOfClass_ == v26;
              BOOL v37 = v36 || sel_class == v26;
              BOOL v38 = v37 || sel_self == v26;
              BOOL v39 = v38 || &sel_new == (_UNKNOWN *)v26;
              uint64_t v15 = v39 ? v15 | 0x10 : v15;
            }
          }
          if (v15 == 21) {
            break;
          }
          v23 += v25 + v20;
        }
      }
LABEL_178:
      ;
    }
    while (a2 < v16);
    if (v15)
    {
      objc::Scanner::propagateCustomFlags((uint64_t)this, v15, 0);
    }
  }
}

uint64_t objc_class::setInstancesRequireRawIsaRecursively(uint64_t this, char a2)
{
  if ((*(_WORD *)(this + 30) & 0x2000) == 0)
  {
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 3321888768;
    v2[2] = ___ZN10objc_class36setInstancesRequireRawIsaRecursivelyEb_block_invoke;
    v2[3] = &__block_descriptor_48_e8_32c64_ZTSKZN10objc_class36setInstancesRequireRawIsaRecursivelyEbE3__0_e8_B16__0_8l;
    char v3 = a2;
    uint64_t v4 = this;
    return foreach_realized_class_and_subclass(this, (uint64_t)v2);
  }
  return this;
}

void *_setThisThreadIsInitializingClass(objc_class *a1)
{
  InitializingClassList = (unsigned int *)_fetchInitializingClassList(1);
  unsigned int v6 = InitializingClassList;
  if ((unint64_t)(*(void *)a1 - 1) < 0xF || (*(unsigned char *)(*((void *)a1 + 4) & 0xF00007FFFFFFFF8) & 1) == 0) {
    a1 = (objc_class *)(*(void *)a1 & 0xFFFFFFFF8);
  }
  uint64_t v7 = *InitializingClassList;
  unint64_t result = (void *)*((void *)InitializingClassList + 1);
  if ((int)v7 < 1)
  {
    unsigned int v11 = 0;
  }
  else
  {
    uint64_t v9 = *v6;
    uint64_t v10 = (objc_class **)*((void *)v6 + 1);
    do
    {
      if (a1 == *v10) {
        _objc_fatal("thread is already initializing this class!", v3, v4, v5);
      }
      ++v10;
      --v9;
    }
    while (v9);
    do
    {
      if (!result[v9])
      {
        result[v9] = a1;
        return result;
      }
      ++v9;
    }
    while (v7 != v9);
    unsigned int v11 = *v6;
  }
  signed int v12 = (2 * v7) | 1;
  *unsigned int v6 = v12;
  unint64_t result = malloc_type_realloc(result, 8 * v12, 0x80040B8603338uLL);
  *((void *)v6 + 1) = result;
  result[v11] = a1;
  if ((int)(v11 + 1) < (int)*v6)
  {
    uint64_t v13 = v11 + 1;
    do
      *(void *)(*((void *)v6 + 1) + 8 * v13++) = 0;
    while ((int)*v6 > (int)v13);
  }
  return result;
}

void *_fetchInitializingClassList(int a1)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v3 = *(_OWORD **)(StatusReg + 320);
  if (!a1 || v3)
  {
    if (!v3) {
      return 0;
    }
  }
  else
  {
    uint64_t v3 = malloc_type_malloc(0x48uLL, 0xB4ED9BFAuLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    v3[3] = 0u;
    *((void *)v3 + 8) = 0;
    *(void *)(StatusReg + 320) = v3;
  }
  uint64_t v4 = *(void **)v3;
  if (*(void *)v3) {
    goto LABEL_8;
  }
  if (!a1) {
    return 0;
  }
  uint64_t v4 = malloc_type_calloc(1uLL, 0x10uLL, 0x10800407411B482uLL);
  *(void *)uint64_t v3 = v4;
LABEL_8:
  if (!v4[1])
  {
    *(_DWORD *)uint64_t v4 = 4;
    v4[1] = malloc_type_calloc(4uLL, 8uLL, 0x80040B8603338uLL);
  }
  return v4;
}

void lockAndFinishInitializing(objc_class *a1, objc_class *a2)
{
  int v4 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(&pendingInitializeMapLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v4) {
    os_unfair_lock_lock_with_options();
  }
  if (!a2) {
    goto LABEL_13;
  }
  int v6 = *(_DWORD *)(*((void *)a2 + 4) & 0xF00007FFFFFFFF8);
  if ((v6 & 1) == 0) {
    int v6 = *(_DWORD *)(*(void *)((*(void *)a2 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  }
  if ((v6 & 0x20000000) != 0)
  {
LABEL_13:
    _finishInitializing(a1, a2);
    goto LABEL_22;
  }
  if (PrintInitializing)
  {
    uint64_t v7 = *(const void **)StatusReg;
    __int16 v8 = objc_class::nameForLogging(a1);
    uint64_t v9 = objc_class::nameForLogging(a2);
    _objc_inform("INITIALIZE: thread %p: class %s will be marked as fully +initialized after superclass +[%s initialize] completes", v7, v8, v9);
  }
  if (!pendingInitializeMap)
  {
    uint64_t v10 = malloc_type_malloc(0x18uLL, 0xB4ED9BFAuLL);
    objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::init(v10, 10);
    pendingInitializeMap = (uint64_t)v10;
  }
  unsigned int v11 = malloc_type_malloc(0x10uLL, 0xB4ED9BFAuLL);
  *unsigned int v11 = a1;
  v11[1] = 0;
  signed int v12 = (int32x2_t *)pendingInitializeMap;
  uint64_t v20 = 0;
  char v13 = objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::LookupBucketFor<objc_class *>(pendingInitializeMap, (unint64_t)a2, &v20);
  int v14 = v20;
  if ((v13 & 1) == 0)
  {
    __int32 v16 = v12[1].i32[0];
    unsigned int v17 = v12[2].u32[0];
    if (4 * v16 + 4 >= 3 * v17)
    {
      objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::grow((uint64_t)v12, 2 * v17);
      uint64_t v20 = 0;
      objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::LookupBucketFor<objc_class *>((uint64_t)v12, (unint64_t)a2, &v20);
    }
    else
    {
      if (v17 + ~v16 - v12[1].i32[1] > v17 >> 3)
      {
LABEL_16:
        if (*v14 == -2)
        {
          v12[1] = vadd_s32(v12[1], (int32x2_t)0xFFFFFFFF00000001);
        }
        else if (*v14 == -1)
        {
          ++v12[1].i32[0];
        }
        *int v14 = a2;
        uint64_t v15 = v14 + 1;
        goto LABEL_21;
      }
      objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::grow((uint64_t)v12, v17);
      uint64_t v20 = 0;
      objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::LookupBucketFor<objc_class *>((uint64_t)v12, (unint64_t)a2, &v20);
    }
    int v14 = v20;
    goto LABEL_16;
  }
  uint64_t v15 = v20 + 1;
  v11[1] = v20[1];
LABEL_21:
  *uint64_t v15 = v11;
LABEL_22:
  int v18 = *(_DWORD *)(StatusReg + 24);
  int v19 = v18;
  atomic_compare_exchange_strong_explicit(&pendingInitializeMapLock, (unsigned int *)&v19, 0, memory_order_release, memory_order_relaxed);
  if (v19 != v18)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&pendingInitializeMapLock);
  }
}

void sub_18011D600(_Unwind_Exception *a1)
{
  free(v1);
  int v5 = *(_DWORD *)(v3 + 24);
  int v6 = v5;
  atomic_compare_exchange_strong_explicit(v2, (unsigned int *)&v6, 0, memory_order_release, memory_order_relaxed);
  if (v6 != v5) {
    os_unfair_lock_unlock((os_unfair_lock_t)&pendingInitializeMapLock);
  }
  _Unwind_Resume(a1);
}

Class object_getClass(id a1)
{
  if (!a1) {
    return 0;
  }
  if (((unint64_t)a1 & 0x8000000000000000) == 0) {
    return (Class)(*(void *)a1 & 0x7FFFFFFFFFFFF8);
  }
  uint64_t v1 = (__objc2_class *)objc_debug_taggedpointer_classes[a1 & 7];
  if (v1 && v1 == __NSUnrecognizedTaggedPointer) {
    return (Class)objc_debug_taggedpointer_ext_classes[((unint64_t)a1 >> 55)];
  }
  return (Class)v1;
}

void objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::compact()
{
  if (qword_1EB1CB0C0)
  {
    if (dword_1EB1CB0C8 >= 0x401 && dword_1EB1CB0C8 >> 4 > qword_1EB1CB0C0)
    {
      int v1 = 2 * qword_1EB1CB0C0;
      objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::grow(v1);
    }
  }
  else
  {
    if (!dword_1EB1CB0C8) {
      goto LABEL_19;
    }
    uint64_t v2 = 24 * dword_1EB1CB0C8;
    uint64_t v3 = objc::unattachedCategories + 8;
    do
    {
      if (*(void *)(v3 - 8) <= 0xFFFFFFFFFFFFFFFDLL && (*(unsigned char *)(v3 + 8) & 1) != 0) {
        free(*(void **)v3);
      }
      v3 += 24;
      v2 -= 24;
    }
    while (v2);
    if (dword_1EB1CB0C8)
    {
      if (objc::unattachedCategories) {
        int v4 = (void *)objc::unattachedCategories;
      }
      else {
        int v4 = 0;
      }
      free(v4);
      objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::init(0);
    }
    else
    {
LABEL_19:
      qword_1EB1CB0C0 = 0;
    }
  }
}

uint64_t objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::LookupBucketFor<objc_class *>(uint64_t a1, unint64_t a2, void *a3)
{
  uint64_t v3 = *(void **)a1;
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    unsigned int v5 = v4 - 1;
    unsigned int v6 = (v4 - 1) & (bswap64(0x8A970BE7488FDA55 * (a2 ^ (a2 >> 4))) ^ (1217387093 * (a2 ^ (a2 >> 4))));
    uint64_t v7 = &v3[2 * v6];
    uint64_t v8 = *v7;
    if (*v7 == a2)
    {
      uint64_t v9 = 1;
    }
    else
    {
      unsigned int v11 = 0;
      unsigned int v12 = 1;
      while (v8 != -1)
      {
        if (v12 > v4) {
          objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::FatalCorruptHashTables(a1, v3, *(unsigned int *)(a1 + 16));
        }
        if (v11) {
          BOOL v13 = 0;
        }
        else {
          BOOL v13 = v8 == -2;
        }
        if (v13) {
          unsigned int v11 = v7;
        }
        unsigned int v14 = v6 + v12++;
        unsigned int v6 = v14 & v5;
        uint64_t v7 = &v3[2 * (v14 & v5)];
        uint64_t v8 = *v7;
        uint64_t v9 = 1;
        if (*v7 == a2) {
          goto LABEL_5;
        }
      }
      uint64_t v9 = 0;
      if (v11) {
        uint64_t v7 = v11;
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v9 = 0;
  }
LABEL_5:
  *a3 = v7;
  return v9;
}

uint64_t objc::Scanner::propagateCustomFlags(uint64_t a1, char a2, int a3)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3321888768;
  v4[2] = ___ZN4objc7Scanner20propagateCustomFlagsEP10objc_classjNS0_11inherited_tE_block_invoke;
  v4[3] = &__block_descriptor_48_e8_32c83_ZTSKZN4objc7Scanner20propagateCustomFlagsEP10objc_classjNS0_11inherited_tEEUlS2_E__e8_B16__0_8l;
  v4[4] = a1;
  int v5 = a3;
  char v6 = a2 & 1;
  BOOL v7 = (a2 & 4) != 0;
  BOOL v8 = (a2 & 0x10) != 0;
  return foreach_realized_class_and_subclass(a1, (uint64_t)v4);
}

BOOL sel_isEqual(SEL lhs, SEL rhs)
{
  return lhs == rhs;
}

id objc_getAssociatedObject(id object, const void *key)
{
  int v4 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(&AssociationsManagerLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v4) {
    os_unfair_lock_lock_with_options();
  }
  uint64_t v6 = objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::find(-(uint64_t)object);
  uint64_t v7 = v6;
  if (objc::AssociationsManager::_mapStorage + 32 * dword_1EB1CAC58 == v6
    || (BOOL v8 = (void *)(v6 + 8),
        uint64_t v9 = objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::find(v6 + 8, (unint64_t)key), *v8 + 24 * *(unsigned int *)(v7 + 24) == v9))
  {
    uint64_t v10 = 0;
    LOWORD(v11) = 0;
  }
  else
  {
    uint64_t v11 = *(void *)(v9 + 8);
    uint64_t v10 = *(void **)(v9 + 16);
    if (v10 && (v11 & 0x100) != 0) {
      id v12 = v10;
    }
  }
  int v13 = *(_DWORD *)(StatusReg + 24);
  int v14 = v13;
  atomic_compare_exchange_strong_explicit(&AssociationsManagerLock, (unsigned int *)&v14, 0, memory_order_release, memory_order_relaxed);
  if (v14 != v13) {
    os_unfair_lock_unlock((os_unfair_lock_t)&AssociationsManagerLock);
  }
  if (!v10 || (v11 & 0x200) == 0) {
    return v10;
  }

  return v10;
}

void sub_18011DC58(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)&AssociationsManagerLock);
  }
  _Unwind_Resume(exception_object);
}

uint64_t objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::find(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = 0;
  if (objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::LookupBucketFor<void const*>(a1, a2, &v4))return v4; {
  else
  }
    return *(void *)a1 + 24 * *(unsigned int *)(a1 + 16);
}

uint64_t objc::DenseMapBase<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::LookupBucketFor<void const*>(uint64_t a1, unint64_t a2, void *a3)
{
  uint64_t v3 = *(void **)a1;
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    unsigned int v5 = v4 - 1;
    unsigned int v6 = (v4 - 1) & (bswap64(0x8A970BE7488FDA55 * (a2 ^ (a2 >> 4))) ^ (1217387093 * (a2 ^ (a2 >> 4))));
    uint64_t v7 = &v3[3 * v6];
    uint64_t v8 = *v7;
    if (*v7 == a2)
    {
      uint64_t v9 = 1;
    }
    else
    {
      uint64_t v11 = 0;
      unsigned int v12 = 1;
      while (v8 != -1)
      {
        if (v12 > v4) {
          objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::FatalCorruptHashTables(a1, v3, *(unsigned int *)(a1 + 16));
        }
        if (v11) {
          BOOL v13 = 0;
        }
        else {
          BOOL v13 = v8 == -2;
        }
        if (v13) {
          uint64_t v11 = v7;
        }
        unsigned int v14 = v6 + v12++;
        unsigned int v6 = v14 & v5;
        uint64_t v7 = &v3[3 * (v14 & v5)];
        uint64_t v8 = *v7;
        uint64_t v9 = 1;
        if (*v7 == a2) {
          goto LABEL_5;
        }
      }
      uint64_t v9 = 0;
      if (v11) {
        uint64_t v7 = v11;
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v9 = 0;
  }
LABEL_5:
  *a3 = v7;
  return v9;
}

Class objc_getClass(Class name)
{
  if (name) {
    return look_up_class((char *)name);
  }
  return name;
}

void objc_removeAssociatedObjects(id object)
{
  if (object && (((unint64_t)object & 0x8000000000000000) != 0 || (*(void *)object & 3) != 1)) {
    _object_remove_associations((uint64_t)object, 0);
  }
}

const char *__cdecl property_getName(objc_property_t property)
{
  return *(const char **)property;
}

Ivar class_getInstanceVariable(Class cls, const char *name)
{
  if (cls && name) {
    return (Ivar)_class_getVariable(cls, (char *)name);
  }
  else {
    return 0;
  }
}

uint64_t empty_getClass(const char *a1, objc_class **a2)
{
  *a2 = 0;
  return 0;
}

IMP method_getImplementation(Method m)
{
  if (m) {
    return (IMP)method_t::imp((unint64_t)m, 1);
  }
  else {
    return 0;
  }
}

const char *__cdecl property_getAttributes(objc_property_t property)
{
  return (const char *)*((void *)property + 1);
}

objc_property_t *__cdecl protocol_copyPropertyList2(Protocol *proto, unsigned int *outCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
{
  if (proto && isRequiredProperty)
  {
    BOOL v5 = isInstanceProperty;
    int v7 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v7, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v7) {
      os_unfair_lock_lock_with_options();
    }
    if (v5)
    {
      uint64_t v9 = proto + 7;
    }
    else
    {
      uint64_t v9 = proto + 11;
      if ((Protocol *)((char *)proto + LODWORD(proto[8].super.isa)) <= &proto[11]) {
        goto LABEL_16;
      }
    }
    Class isa = (unsigned int *)v9->super.isa;
    if (v9->super.isa)
    {
      unsigned int v12 = isa[1];
      if (v12)
      {
        uint64_t v10 = (objc_property_t *)malloc_type_malloc(8 * (v12 + 1), 0x2004093837F09uLL);
        BOOL v13 = (objc_property *)(isa + 2);
        uint64_t v14 = *isa;
        entsize_list_tt<property_t,property_list_t,0u,PointerModifierNop>::end(isa, v15, v16, v17);
        if (isa + 2 == v18)
        {
          unsigned int v12 = 0;
        }
        else
        {
          int v19 = 0;
          do
          {
            unsigned int v12 = v19 + 1;
            v10[v19] = v13;
            BOOL v13 = (objc_property *)((char *)v13 + v14);
            ++v19;
          }
          while (v13 != (objc_property *)v18);
        }
        v10[v12] = 0;
        if (!outCount) {
          goto LABEL_19;
        }
LABEL_18:
        *outCount = v12;
LABEL_19:
        int v20 = *(_DWORD *)(StatusReg + 24);
        int v21 = v20;
        atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v21, 0, memory_order_release, memory_order_relaxed);
        if (v21 != v20) {
          os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
        }
        return v10;
      }
LABEL_17:
      uint64_t v10 = 0;
      if (!outCount) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }
LABEL_16:
    unsigned int v12 = 0;
    goto LABEL_17;
  }
  uint64_t v10 = 0;
  if (outCount) {
    *outCount = 0;
  }
  return v10;
}

void sub_18011E0D0(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

objc_property_t *__cdecl class_copyPropertyList(Class cls, unsigned int *outCount)
{
  if (cls)
  {
    int v4 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v4) {
      os_unfair_lock_lock_with_options();
    }
    if ((unint64_t)(*(void *)cls - 1) < 0xF
      || (*(_DWORD *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
      || (uint64_t v6 = *(unsigned __int16 *)((*((void *)cls + 4) & 0xF00007FFFFFFFF8) + 4),
          dword_1EB1CB088 <= v6)
      || (*(void *)(qword_1EB1CB080 + 16 * v6) <= (unint64_t)cls
        ? (BOOL v7 = *(void *)(qword_1EB1CB080 + 16 * v6 + 8) > (unint64_t)cls)
        : (BOOL v7 = 0),
          !v7))
    {
      if (objc::allocatedClasses + 8 * qword_1EB1CAEA0 == objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::find((unint64_t)cls)
        && (dataSegmentsContain(cls, v42, v43) & 1) == 0)
      {
        _objc_fatal("Attempt to use unknown class %p.", v44, v45, v46, cls);
      }
    }
    class_rw_t::properties(&v51, *((void *)cls + 4) & 0xF00007FFFFFFFF8);
    if (!v51)
    {
      unsigned int v12 = 0;
      uint64_t v15 = 0;
      goto LABEL_19;
    }
    uint64_t v15 = (unsigned int *)(v51 & 0xFFFFFFFFFFFFFFFCLL);
    unint64_t v13 = v51 & 3;
    if ((v51 & 3) == 0 && v15)
    {
      unsigned int v12 = (unsigned int *)(v51 & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v15 = 0;
      goto LABEL_19;
    }
    if (v51 >= 4)
    {
      if (v13 == 2)
      {
        if (!v15) {
          goto LABEL_19;
        }
        if (DisablePreattachedCategories)
        {
          uint64_t v38 = *v15;
          uint64_t v19 = v15[1];
          unint64_t v47 = v19 * (unint64_t)v38;
          if ((v47 & 0xFFFFFFFF00000000) != 0) {
            goto LABEL_86;
          }
          uint64_t v11 = (uint64_t *)((char *)v15 + v47 + 8);
          BOOL v48 = v19 == 0;
          if (v19) {
            uint64_t v19 = v19;
          }
          else {
            uint64_t v19 = 0;
          }
          if (!v48) {
            uint64_t v11 = (uint64_t *)((char *)v11 - v38);
          }
        }
        else
        {
          uint64_t v11 = (uint64_t *)(v15 + 2);
          uint64_t v38 = *v15;
          uint64_t v19 = v15[1];
        }
        unint64_t v39 = v19 * (unint64_t)v38;
        if ((v39 & 0xFFFFFFFF00000000) != 0)
        {
LABEL_86:
          unsigned int v12 = (unsigned int *)(v51 & 0xFFFFFFFFFFFFFFFCLL);
LABEL_85:
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v8, v9, v10, v19, v12, v38);
        }
        unint64_t v40 = (unint64_t)v15 + v39 + 8;
        if ((unint64_t)v11 < v40)
        {
          while ((*(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v11 + 8) & 1) == 0)
          {
            uint64_t v11 = (uint64_t *)((char *)v11 + v38);
            unsigned int v14 = v38;
            if ((unint64_t)v11 >= v40) {
              goto LABEL_73;
            }
          }
        }
        unsigned int v14 = v38;
LABEL_73:
        unsigned int v12 = (unsigned int *)(v51 & 0xFFFFFFFFFFFFFFFCLL);
      }
      else if (v13 == 1)
      {
        if (v15)
        {
          unsigned int v12 = v15 + 2;
LABEL_66:
          unint64_t v13 = *v15;
          v15 += 2 * v13 + 2;
        }
LABEL_19:
        int v17 = 0;
        if (!v51) {
          goto LABEL_34;
        }
        while (1)
        {
          unint64_t v18 = v51 & 3;
          if ((v51 & 3) == 0) {
            break;
          }
          if (v18 == 1)
          {
            if (v12 != v15)
            {
              unint64_t v24 = v12;
              unsigned int v12 = *(unsigned int **)v12;
LABEL_33:
              unsigned int v21 = v12[1];
              unsigned int v12 = &v24[2 * (v18 == 1)];
              goto LABEL_36;
            }
            goto LABEL_38;
          }
          if (v18 == 2 && v11 == (uint64_t *)v13) {
            goto LABEL_38;
          }
          uint64_t v19 = v12[1];
          unint64_t v20 = v19 * (unint64_t)*v12;
          if ((v20 & 0xFFFFFFFF00000000) != 0)
          {
            uint64_t v38 = *v12;
            goto LABEL_85;
          }
          unsigned int v21 = *(_DWORD *)((char *)v11 + (*v11 >> 16) + 4);
          unint64_t v22 = (unint64_t)v12 + v20 + 8;
          unint64_t v23 = (uint64_t *)((char *)v11 + v14);
          do
          {
            uint64_t v11 = v23;
            if ((unint64_t)v23 >= v22) {
              break;
            }
            uint64_t v8 = *(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v23 + 8);
            unint64_t v23 = (uint64_t *)((char *)v23 + v14);
          }
          while ((v8 & 1) == 0);
LABEL_36:
          while (1)
          {
            v17 += v21;
            if (v51) {
              break;
            }
LABEL_34:
            if (v12 == v15) {
              goto LABEL_38;
            }
            unsigned int v21 = v12[1];
            unsigned int v12 = 0;
          }
        }
        if (v12 != v15)
        {
          unint64_t v24 = 0;
          goto LABEL_33;
        }
LABEL_38:
        if (v17)
        {
          __int32 v16 = (objc_property_t *)malloc_type_malloc(8 * (v17 + 1), 0x2004093837F09uLL);
          list_array_tt<property_t,property_list_t,RawPtr>::begin(v50, &v51, v25, v26);
          list_array_tt<property_t,property_list_t,RawPtr>::end(v49, &v51, v27, v28);
          for (unsigned int i = 0; ; ++i)
          {
            int v30 = list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::operator==((uint64_t)v50, v49);
            uint64_t v34 = i;
            if (v30) {
              break;
            }
            v16[v34] = (objc_property_t)v50[9];
            list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::operator++(v50, v31, v32, v33);
          }
          v16[i] = 0;
          if (outCount) {
            goto LABEL_43;
          }
        }
        else
        {
          __int32 v16 = 0;
          unsigned int i = 0;
          if (outCount) {
LABEL_43:
          }
            *outCount = i;
        }
        int v35 = *(_DWORD *)(StatusReg + 24);
        int v36 = v35;
        atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v36, 0, memory_order_release, memory_order_relaxed);
        if (v36 != v35) {
          os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
        }
        return v16;
      }
    }
    else
    {
      unsigned int v12 = 0;
    }
    if (v13 != 2)
    {
      if (v13 == 1)
      {
        if (!v15) {
          goto LABEL_19;
        }
        goto LABEL_66;
      }
      uint64_t v15 = 0;
      goto LABEL_19;
    }
    if (!v15) {
      goto LABEL_19;
    }
    uint64_t v38 = *v15;
    uint64_t v19 = v15[1];
    unint64_t v41 = v19 * (unint64_t)v38;
    if ((v41 & 0xFFFFFFFF00000000) == 0)
    {
      unint64_t v13 = (unint64_t)v15 + v41 + 8;
      goto LABEL_19;
    }
    goto LABEL_86;
  }
  __int32 v16 = 0;
  if (outCount) {
    *outCount = 0;
  }
  return v16;
}

void sub_18011E5E0(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

objc_property_t class_getProperty(Class cls, const char *name)
{
  uint64_t v2 = 0;
  if (cls && name)
  {
    Class v4 = cls;
    int v5 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v5, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v5) {
      os_unfair_lock_lock_with_options();
    }
    if ((unint64_t)(*(void *)v4 - 1) < 0xF
      || (*(_DWORD *)(*((void *)v4 + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
      || (uint64_t v7 = *(unsigned __int16 *)((*((void *)v4 + 4) & 0xF00007FFFFFFFF8) + 4),
          qword_1EB1CB088 <= v7)
      || (*(void *)(qword_1EB1CB080 + 16 * v7) <= (unint64_t)v4
        ? (BOOL v8 = *(void *)(qword_1EB1CB080 + 16 * v7 + 8) > (unint64_t)v4)
        : (BOOL v8 = 0),
          !v8))
    {
      if (objc::allocatedClasses + 8 * qword_1EB1CAEA0 == objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::find((unint64_t)v4)
        && (dataSegmentsContain(v4, v19, v20) & 1) == 0)
      {
        _objc_fatal("Attempt to use unknown class %p.", v21, v22, v23, v4);
      }
    }
    while (1)
    {
      class_rw_t::properties(&v27, *((void *)v4 + 4) & 0xF00007FFFFFFFF8);
      list_array_tt<property_t,property_list_t,RawPtr>::begin(v25, &v27, v9, v10);
      list_array_tt<property_t,property_list_t,RawPtr>::end(v24, &v27, v11, v12);
      while ((list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::operator==((uint64_t)v25, v24) & 1) == 0)
      {
        uint64_t v2 = (objc_property *)v26;
        if (!strcmp(name, *v26)) {
          goto LABEL_20;
        }
        list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::operator++(v25, v13, v14, v15);
      }
      if (!*((void *)v4 + 1)) {
        break;
      }
      Class v4 = (Class)*((void *)v4 + 1);
    }
    uint64_t v2 = 0;
LABEL_20:
    int v16 = *(_DWORD *)(StatusReg + 24);
    int v17 = v16;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v17, 0, memory_order_release, memory_order_relaxed);
    if (v17 != v16) {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
  }
  return v2;
}

void sub_18011E868(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

uint64_t list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::operator==(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)a1;
  if (*(void *)a1 != *a2) {
    return 0;
  }
  if (!*v2)
  {
LABEL_5:
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v4 = a2[1];
    goto LABEL_6;
  }
  if ((*v2 & 3) != 2)
  {
    if ((*v2 & 3uLL) > 1) {
      return 0;
    }
    goto LABEL_5;
  }
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = a2[3];
LABEL_6:
  if (v3 != v4) {
    return 0;
  }
  if (v2 != *(void **)(a1 + 32)) {
    return *(void *)(a1 + 72) == a2[9];
  }
  if (!*v2)
  {
LABEL_12:
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v7 = *(void *)(a1 + 40);
    goto LABEL_13;
  }
  if ((*v2 & 3) != 2)
  {
    if ((*v2 & 3uLL) > 1) {
      return *(void *)(a1 + 72) == a2[9];
    }
    goto LABEL_12;
  }
  uint64_t v6 = *(void *)(a1 + 24);
  uint64_t v7 = *(void *)(a1 + 56);
LABEL_13:
  if (v6 != v7) {
    return *(void *)(a1 + 72) == a2[9];
  }
  return 1;
}

uint64_t **list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::operator++(uint64_t **a1, uint64_t a2, const char *a3, char *a4)
{
  int v5 = a1[8];
  uint64_t v6 = (uint64_t *)((char *)a1[9] + v5);
  a1[9] = v6;
  *((_DWORD *)a1 + 17) = HIDWORD(v5) + 1;
  if (v6 == a1[11])
  {
    uint64_t v7 = *a1;
    uint64_t v8 = **a1;
    if (!v8)
    {
      a1[1] = 0;
      goto LABEL_14;
    }
    if ((**a1 & 3) == 1)
    {
      ++a1[1];
      uint64_t v8 = *v7;
      if (!*v7) {
        goto LABEL_14;
      }
    }
    else if ((v8 & 3) == 0)
    {
      a1[1] = 0;
    }
    if ((v8 & 3) == 2)
    {
      uint64_t v9 = a1[3];
      uint64_t v10 = *((unsigned int *)a1 + 4);
      int v11 = *((_DWORD *)a1 + 5);
      a1[3] = (uint64_t *)((char *)v9 + v10);
      unsigned int v12 = (unsigned int *)a1[1];
      uint64_t v14 = *v12;
      uint64_t v13 = v12[1];
      unint64_t v15 = v13 * (unint64_t)v14;
      *((_DWORD *)a1 + 5) = v11 + 1;
      if ((v15 & 0xFFFFFFFF00000000) != 0) {
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v13, v12, v14);
      }
      unint64_t v16 = (unint64_t)v12 + v15 + 8;
      if ((unint64_t)v9 + v10 < v16)
      {
        uint64_t v17 = objc_debug_headerInfoRWs;
        int v18 = v11 + 2;
        do
        {
          if (*(void *)(v17 + 8 * *(unsigned __int16 *)((char *)v9 + v10) + 8)) {
            break;
          }
          a1[3] = (uint64_t *)((char *)v9 + 2 * v10);
          *((_DWORD *)a1 + 5) = v18++;
          uint64_t v9 = (uint64_t *)((char *)v9 + v10);
        }
        while ((unint64_t)v9 + v10 < v16);
      }
    }
LABEL_14:
    list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::skipEmptyLists(a1);
    unint64_t v22 = *a1;
    uint64_t v23 = **a1;
    if (*a1 != a1[4]) {
      goto LABEL_15;
    }
    if (v23)
    {
      if ((**a1 & 3) == 2)
      {
        uint64_t v31 = a1[3];
        BOOL v32 = a1[7];
      }
      else
      {
        if ((**a1 & 3) != 1)
        {
          if ((v23 & 3) != 0) {
            goto LABEL_16;
          }
          goto LABEL_24;
        }
        uint64_t v31 = a1[1];
        BOOL v32 = a1[5];
      }
      if (v31 == v32) {
        return a1;
      }
      goto LABEL_16;
    }
LABEL_24:
    if (a1[1] == a1[5]) {
      return a1;
    }
LABEL_15:
    if (!v23)
    {
LABEL_19:
      uint64_t v25 = (unsigned int *)a1[1];
      goto LABEL_29;
    }
LABEL_16:
    uint64_t v24 = **a1 & 3;
    switch(v24)
    {
      case 2:
        uint64_t v25 = (unsigned int *)((char *)a1[3] + (*a1[3] >> 16));
        break;
      case 1:
        uint64_t v25 = (unsigned int *)*a1[1];
        break;
      case 0:
        goto LABEL_19;
      default:
        uint64_t v25 = 0;
        break;
    }
LABEL_29:
    a1[8] = (uint64_t *)*v25;
    a1[9] = (uint64_t *)(v25 + 2);
    if (*v22)
    {
      switch(*v22 & 3)
      {
        case 2:
          unint64_t v26 = (unsigned int *)((char *)a1[3] + (*a1[3] >> 16));
          break;
        case 1:
          unint64_t v26 = (unsigned int *)*a1[1];
          break;
        case 0:
          goto LABEL_33;
        default:
          unint64_t v26 = 0;
          break;
      }
LABEL_37:
      a1[10] = (uint64_t *)entsize_list_tt<property_t,property_list_t,0u,PointerModifierNop>::end(v26, v19, v20, v21);
      a1[11] = (uint64_t *)v27;
      if (a1[9] != (uint64_t *)v27) {
        return a1;
      }
      uint64_t v33 = **a1;
      if (!v33) {
        goto LABEL_47;
      }
      if ((**a1 & 3) == 2)
      {
        uint64_t v34 = (uint64_t)a1[3] + (*a1[3] >> 16);
      }
      else if ((**a1 & 3) == 1)
      {
        uint64_t v34 = *a1[1];
      }
      else
      {
        if ((v33 & 3) == 0)
        {
LABEL_47:
          uint64_t v34 = (uint64_t)a1[1];
          goto LABEL_48;
        }
        uint64_t v34 = 0;
      }
LABEL_48:
      _objc_fatal("Assertion failed: (%s) - empty list %p encountered during iteration", v27, v28, v29, "m != mEnd", v34);
    }
LABEL_33:
    unint64_t v26 = (unsigned int *)a1[1];
    goto LABEL_37;
  }
  return a1;
}

uint64_t entsize_list_tt<property_t,property_list_t,0u,PointerModifierNop>::end(unsigned int *a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  if (((v4 * (unint64_t)v5) & 0xFFFFFFFF00000000) != 0) {
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v4, a1, v5);
  }
  return v5 | (v4 << 32);
}

uint64_t **list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(uint64_t **a1, uint64_t a2, void *a3)
{
  list_array_tt<property_t,property_list_t,RawPtr>::ListIterator::ListIterator(a1, a2);
  list_array_tt<property_t,property_list_t,RawPtr>::ListIterator::ListIterator((void *)(v6 + 32), (uint64_t)a3);
  uint64_t v10 = **(void **)a2;
  if (*(void *)a2 != *a3) {
    goto LABEL_2;
  }
  if (v10)
  {
    if ((**(void **)a2 & 3) == 2)
    {
      uint64_t v17 = *(void *)(a2 + 24);
      uint64_t v18 = a3[3];
    }
    else
    {
      if ((**(void **)a2 & 3) != 1)
      {
        if ((v10 & 3) != 0) {
          goto LABEL_3;
        }
        goto LABEL_11;
      }
      uint64_t v17 = *(void *)(a2 + 8);
      uint64_t v18 = a3[1];
    }
    if (v17 == v18) {
      goto LABEL_25;
    }
    goto LABEL_3;
  }
LABEL_11:
  if (*(void *)(a2 + 8) == a3[1]) {
    goto LABEL_25;
  }
LABEL_2:
  if (!v10)
  {
LABEL_6:
    unsigned int v12 = *(unsigned int **)(a2 + 8);
    goto LABEL_16;
  }
LABEL_3:
  uint64_t v11 = **(void **)a2 & 3;
  switch(v11)
  {
    case 2:
      unsigned int v12 = (unsigned int *)(*(void *)(a2 + 24) + (**(uint64_t **)(a2 + 24) >> 16));
      break;
    case 1:
      unsigned int v12 = **(unsigned int ***)(a2 + 8);
      break;
    case 0:
      goto LABEL_6;
    default:
      unsigned int v12 = 0;
      break;
  }
LABEL_16:
  a1[8] = (uint64_t *)*v12;
  a1[9] = (uint64_t *)(v12 + 2);
  uint64_t v13 = **(void **)a2;
  if (v13)
  {
    if ((**(void **)a2 & 3) == 2)
    {
      uint64_t v14 = (unsigned int *)(*(void *)(a2 + 24) + (**(uint64_t **)(a2 + 24) >> 16));
      goto LABEL_24;
    }
    if ((**(void **)a2 & 3) == 1)
    {
      uint64_t v14 = **(unsigned int ***)(a2 + 8);
      goto LABEL_24;
    }
    if ((v13 & 3) != 0)
    {
      uint64_t v14 = 0;
      goto LABEL_24;
    }
  }
  uint64_t v14 = *(unsigned int **)(a2 + 8);
LABEL_24:
  a1[10] = (uint64_t *)entsize_list_tt<property_t,property_list_t,0u,PointerModifierNop>::end(v14, v7, v8, v9);
  a1[11] = v15;
LABEL_25:
  list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::skipEmptyLists(a1);
  return a1;
}

uint64_t **list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::skipEmptyLists(uint64_t **result)
{
  int v1 = *result;
  uint64_t v2 = result[4];
  uint64_t v3 = objc_debug_headerInfoRWs;
  uint64_t v4 = **result;
  while (1)
  {
    if (v1 != v2) {
      goto LABEL_8;
    }
    if (v4) {
      break;
    }
LABEL_7:
    if (result[1] == result[5]) {
      return result;
    }
LABEL_8:
    if (!v4)
    {
      int v5 = 1;
LABEL_13:
      uint64_t v6 = (uint64_t)result[1];
      goto LABEL_15;
    }
LABEL_9:
    int v5 = v4 & 3;
    if ((v4 & 3) != 1)
    {
      if ((v4 & 3) != 0)
      {
        int v5 = 0;
        uint64_t v6 = (uint64_t)result[3] + (*result[3] >> 16);
        goto LABEL_15;
      }
      goto LABEL_13;
    }
    int v5 = 0;
    uint64_t v6 = *result[1];
LABEL_15:
    if (*(_DWORD *)(v6 + 4)) {
      return result;
    }
    if (v5)
    {
      uint64_t v4 = 0;
      result[1] = 0;
    }
    else
    {
      if ((v4 & 3) == 1)
      {
        ++result[1];
        uint64_t v7 = *v1;
      }
      else
      {
        if ((v4 & 3) == 0) {
          result[1] = 0;
        }
        uint64_t v7 = v4;
      }
      uint64_t v4 = 0;
      if (v7)
      {
        uint64_t v4 = v7;
        if ((v7 & 3) == 2)
        {
          uint64_t v8 = result[3];
          uint64_t v9 = *((unsigned int *)result + 4);
          int v10 = *((_DWORD *)result + 5);
          unint64_t v11 = (unint64_t)v8 + v9;
          result[3] = (uint64_t *)((char *)v8 + v9);
          unsigned int v12 = (unsigned int *)result[1];
          uint64_t v13 = (const char *)*v12;
          uint64_t v14 = v12[1];
          unint64_t v15 = v14 * (unint64_t)v13;
          *((_DWORD *)result + 5) = v10 + 1;
          if ((v15 & 0xFFFFFFFF00000000) != 0) {
            _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v11, v13, (char *)v15, v14, v12, v13);
          }
          unint64_t v16 = (unint64_t)v12 + v15 + 8;
          uint64_t v4 = v7;
          if (v11 < v16)
          {
            int v17 = v10 + 2;
            do
            {
              if (*(void *)(v3 + 8 * *(unsigned __int16 *)((char *)v8 + v9) + 8)) {
                break;
              }
              result[3] = (uint64_t *)((char *)v8 + 2 * v9);
              *((_DWORD *)result + 5) = v17++;
              uint64_t v8 = (uint64_t *)((char *)v8 + v9);
            }
            while ((unint64_t)v8 + v9 < v16);
            uint64_t v4 = v7;
          }
        }
      }
    }
  }
  if ((v4 & 3) == 2)
  {
    uint64_t v18 = result[3];
    uint64_t v19 = result[7];
    goto LABEL_33;
  }
  if ((v4 & 3) != 1)
  {
    if ((v4 & 3) != 0) {
      goto LABEL_9;
    }
    goto LABEL_7;
  }
  uint64_t v18 = result[1];
  uint64_t v19 = result[5];
LABEL_33:
  if (v18 != v19) {
    goto LABEL_9;
  }
  return result;
}

unint64_t *class_rw_t::properties(unint64_t *this, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2)
  {
    *this = 0;
    unint64_t v6 = *(void *)((v2 & 0xFFFFFFFFFFFFFFFELL) + 16);
    if (v6) {
      unint64_t v4 = v6;
    }
    else {
      unint64_t v4 = 0;
    }
    goto LABEL_13;
  }
  *this = 0;
  uint64_t v3 = *(void *)((v2 & 0xFFFFFFFFFFFFFFFELL) + 64);
  unint64_t v4 = v3 & 0xFFFFFFFFFFFFFFFELL;
  if ((v3 & 1) == 0 && v4)
  {
LABEL_13:
    *this = v4;
    return this;
  }
  if (v4) {
    BOOL v5 = (*(void *)((v2 & 0xFFFFFFFFFFFFFFFELL) + 64) & 1) == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    unint64_t v4 = v3 & 0xFFFFFFFFFFFFFFFCLL | 2;
    goto LABEL_13;
  }
  return this;
}

uint64_t **list_array_tt<property_t,property_list_t,RawPtr>::begin(uint64_t **a1, unint64_t *a2, const char *a3, char *a4)
{
  int v35 = a2;
  unint64_t v4 = *a2;
  if (!*a2) {
    goto LABEL_13;
  }
  unint64_t v5 = *a2;
  uint64_t v6 = *a2 & 3;
  if ((v4 & 3) == 0)
  {
    unint64_t v9 = v4 & 0xFFFFFFFFFFFFFFFCLL;
    if ((v4 & 0xFFFFFFFFFFFFFFFCLL) != 0)
    {
LABEL_11:
      unint64_t v36 = v9;
LABEL_12:
      uint64_t v31 = a2;
      goto LABEL_15;
    }
    goto LABEL_13;
  }
  if (v4 <= 3)
  {
LABEL_13:
    unint64_t v36 = 0;
    goto LABEL_14;
  }
  if (v6 != 2)
  {
    BOOL v8 = v6 == 1;
    unint64_t v7 = v4 & 0xFFFFFFFFFFFFFFFCLL;
    BOOL v8 = !v8 || v7 == 0;
    if (v8) {
      goto LABEL_12;
    }
    unint64_t v9 = v7 + 8;
    goto LABEL_11;
  }
  int v17 = (unsigned int *)(v4 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v4 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
    goto LABEL_12;
  }
  if (DisablePreattachedCategories)
  {
    unint64_t v21 = *v17;
    uint64_t v25 = v17[1];
    unint64_t v26 = v25 * (unint64_t)v21;
    if ((v26 & 0xFFFFFFFF00000000) != 0) {
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v25, v5 & 0xFFFFFFFFFFFFFFFCLL, v21);
    }
    unint64_t v27 = v21 | (v25 << 32);
    uint64_t v28 = (uint64_t)v17 + v26 + 8;
    unint64_t v29 = v21 | ((unint64_t)(v25 - 1) << 32);
    BOOL v30 = v25 == 0;
    if (v25) {
      uint64_t v19 = v25;
    }
    else {
      uint64_t v19 = 0;
    }
    if (v25) {
      uint64_t v18 = (unsigned __int16 *)(v28 - v21);
    }
    else {
      uint64_t v18 = (unsigned __int16 *)v28;
    }
    if (v30) {
      unint64_t v20 = v27;
    }
    else {
      unint64_t v20 = v29;
    }
  }
  else
  {
    uint64_t v18 = (unsigned __int16 *)(v17 + 2);
    unint64_t v20 = *v17;
    uint64_t v19 = v17[1];
    unint64_t v21 = v20;
  }
  unint64_t v22 = v19 * (unint64_t)v21;
  if ((v22 & 0xFFFFFFFF00000000) != 0) {
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v19, v5 & 0xFFFFFFFFFFFFFFFCLL, v21);
  }
  unint64_t v23 = HIDWORD(v20);
  for (i = (unint64_t)v17 + v22 + 8; (unint64_t)v18 < i; unint64_t v23 = (v23 + 1))
  {
    if (*(void *)(objc_debug_headerInfoRWs + 8 * *v18 + 8)) {
      break;
    }
    uint64_t v18 = (unsigned __int16 *)((char *)v18 + v20);
  }
  unint64_t v36 = v5 & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v37 = v20 | (v23 << 32);
  uint64_t v38 = v18;
LABEL_14:
  uint64_t v31 = a2;
  if (!v4)
  {
LABEL_18:
    unint64_t v32 = 0;
    return list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v35, &v31);
  }
LABEL_15:
  unint64_t v10 = v4;
  unint64_t v11 = v4 & 3;
  if ((v10 & 3) == 2)
  {
    unsigned int v12 = (unsigned int *)(v10 & 0xFFFFFFFFFFFFFFFCLL);
    if ((v10 & 0xFFFFFFFFFFFFFFFCLL) != 0)
    {
      uint64_t v14 = *v12;
      uint64_t v13 = v12[1];
      unint64_t v15 = v13 * (unint64_t)v14;
      if ((v15 & 0xFFFFFFFF00000000) != 0) {
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v13, v10 & 0xFFFFFFFFFFFFFFFCLL, v14);
      }
      unint64_t v32 = v10 & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v33 = v14 | (v13 << 32);
      uint64_t v34 = (uint64_t)v12 + v15 + 8;
    }
  }
  else if (v11 == 1)
  {
    if ((v10 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
      unint64_t v32 = (v10 & 0xFFFFFFFFFFFFFFFCLL) + 8 * *(unsigned int *)(v10 & 0xFFFFFFFFFFFFFFFCLL) + 8;
    }
  }
  else if (!v11)
  {
    goto LABEL_18;
  }
  return list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v35, &v31);
}

uint64_t **list_array_tt<property_t,property_list_t,RawPtr>::end(uint64_t **a1, void *a2, const char *a3, char *a4)
{
  uint64_t v6 = *a2;
  if (!*a2)
  {
    int v17 = a2;
    goto LABEL_8;
  }
  if ((*a2 & 3) != 2)
  {
    if ((*a2 & 3) == 1)
    {
      unint64_t v7 = (unsigned int *)(v6 & 0xFFFFFFFFFFFFFFFCLL);
      if ((v6 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
        v7 += 2 * *v7 + 2;
      }
      int v17 = a2;
      unint64_t v18 = (unint64_t)v7;
      uint64_t v13 = a2;
      unint64_t v14 = (unint64_t)v7;
      return list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v17, &v13);
    }
    int v17 = a2;
    if ((v6 & 3) != 0)
    {
      uint64_t v13 = a2;
      return list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v17, &v13);
    }
LABEL_8:
    unint64_t v18 = 0;
    uint64_t v13 = a2;
    unint64_t v14 = 0;
    return list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v17, &v13);
  }
  BOOL v8 = (unsigned int *)(v6 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v6 & 0xFFFFFFFFFFFFFFFCLL) != 0)
  {
    uint64_t v10 = *v8;
    uint64_t v9 = v8[1];
    unint64_t v11 = v9 * (unint64_t)v10;
    if ((v11 & 0xFFFFFFFF00000000) != 0) {
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v9, v6 & 0xFFFFFFFFFFFFFFFCLL, v10);
    }
    uint64_t v4 = (uint64_t)v8 + v11 + 8;
    uint64_t v5 = v10 | (v9 << 32);
  }
  int v17 = a2;
  unint64_t v18 = v6 & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v19 = v5;
  uint64_t v20 = v4;
  uint64_t v13 = a2;
  unint64_t v14 = v6 & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v15 = v5;
  uint64_t v16 = v4;
  return list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v17, &v13);
}

Protocol **__cdecl class_copyProtocolList(Class cls, unsigned int *outCount)
{
  if (cls)
  {
    int v4 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v4) {
      os_unfair_lock_lock_with_options();
    }
    uint64_t v6 = (void *)((char *)cls + 32);
    class_rw_t::protocols(&v48, *((void *)cls + 4) & 0xF00007FFFFFFFF8);
    if ((unint64_t)(*(void *)cls - 1) < 0xF
      || (*(_DWORD *)(*v6 & 0xF00007FFFFFFFF8) & 0x80000000) == 0
      || (uint64_t v14 = *(unsigned __int16 *)((*v6 & 0xF00007FFFFFFFF8) + 4), dword_1EB1CB088 <= v14)
      || (*(void *)(qword_1EB1CB080 + 16 * v14) <= (unint64_t)cls
        ? (BOOL v15 = *(void *)(qword_1EB1CB080 + 16 * v14 + 8) > (unint64_t)cls)
        : (BOOL v15 = 0),
          !v15))
    {
      if (objc::allocatedClasses + 8 * qword_1EB1CAEA0 == objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::find((unint64_t)cls)
        && (dataSegmentsContain(cls, v7, (unsigned int *)v8) & 1) == 0)
      {
        _objc_fatal("Attempt to use unknown class %p.", v7, v8, v9, cls);
      }
    }
    if (!v48)
    {
      unint64_t v11 = 0;
      uint64_t v16 = 0;
      goto LABEL_19;
    }
    uint64_t v16 = (unsigned int *)(v48 & 0xFFFFFFFFFFFFFFFCLL);
    unint64_t v12 = v48 & 3;
    if ((v48 & 3) == 0 && v16)
    {
      unint64_t v11 = (unsigned int *)(v48 & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v16 = 0;
      goto LABEL_19;
    }
    if (v48 >= 4)
    {
      if (v12 == 2)
      {
        if (!v16) {
          goto LABEL_19;
        }
        if (DisablePreattachedCategories)
        {
          uint64_t v39 = *v16;
          uint64_t v20 = v16[1];
          unint64_t v43 = v20 * (unint64_t)v39;
          if ((v43 & 0xFFFFFFFF00000000) != 0) {
            goto LABEL_92;
          }
          uint64_t v10 = (uint64_t *)((char *)v16 + v43 + 8);
          BOOL v44 = v20 == 0;
          if (v20) {
            uint64_t v20 = v20;
          }
          else {
            uint64_t v20 = 0;
          }
          if (!v44) {
            uint64_t v10 = (uint64_t *)((char *)v10 - v39);
          }
        }
        else
        {
          uint64_t v10 = (uint64_t *)(v16 + 2);
          uint64_t v39 = *v16;
          uint64_t v20 = v16[1];
        }
        unint64_t v40 = v20 * (unint64_t)v39;
        if ((v40 & 0xFFFFFFFF00000000) != 0)
        {
LABEL_92:
          unint64_t v11 = (unsigned int *)(v48 & 0xFFFFFFFFFFFFFFFCLL);
LABEL_91:
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v7, v8, v9, v20, v11, v39);
        }
        unint64_t v41 = (unint64_t)v16 + v40 + 8;
        if ((unint64_t)v10 < v41)
        {
          while ((*(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v10 + 8) & 1) == 0)
          {
            uint64_t v10 = (uint64_t *)((char *)v10 + v39);
            unsigned int v13 = v39;
            if ((unint64_t)v10 >= v41) {
              goto LABEL_79;
            }
          }
        }
        unsigned int v13 = v39;
LABEL_79:
        unint64_t v11 = (unsigned int *)(v48 & 0xFFFFFFFFFFFFFFFCLL);
      }
      else if (v12 == 1)
      {
        if (v16)
        {
          unint64_t v11 = v16 + 2;
LABEL_72:
          unint64_t v12 = *v16;
          v16 += 2 * v12 + 2;
        }
LABEL_19:
        int v18 = 0;
        if (!v48) {
          goto LABEL_34;
        }
        while (1)
        {
          unint64_t v19 = v48 & 3;
          if ((v48 & 3) == 0) {
            break;
          }
          if (v19 == 1)
          {
            if (v11 != v16)
            {
              uint64_t v24 = v11;
              unint64_t v11 = *(unsigned int **)v11;
LABEL_33:
              unint64_t v21 = *(unsigned int **)v11;
              unint64_t v11 = &v24[2 * (v19 == 1)];
              goto LABEL_36;
            }
            goto LABEL_38;
          }
          if (v19 == 2 && v10 == (uint64_t *)v12) {
            goto LABEL_38;
          }
          uint64_t v20 = v11[1];
          uint64_t v7 = v20 * (unint64_t)*v11;
          if ((v7 & 0xFFFFFFFF00000000) != 0)
          {
            uint64_t v39 = *v11;
            goto LABEL_91;
          }
          unint64_t v21 = *(unsigned int **)((char *)v10 + (*v10 >> 16));
          unint64_t v22 = (unint64_t)v11 + v7 + 8;
          unint64_t v23 = (uint64_t *)((char *)v10 + v13);
          do
          {
            uint64_t v10 = v23;
            if ((unint64_t)v23 >= v22) {
              break;
            }
            BOOL v8 = *(char **)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v23 + 8);
            unint64_t v23 = (uint64_t *)((char *)v23 + v13);
          }
          while ((v8 & 1) == 0);
LABEL_36:
          while (1)
          {
            v18 += (int)v21;
            if (v48) {
              break;
            }
LABEL_34:
            if (v11 == v16) {
              goto LABEL_38;
            }
            unint64_t v21 = *(unsigned int **)v11;
            unint64_t v11 = 0;
          }
        }
        if (v11 != v16)
        {
          uint64_t v24 = 0;
          goto LABEL_33;
        }
LABEL_38:
        if (v18)
        {
          int v17 = (Protocol **)malloc_type_malloc(8 * (v18 + 1), 0x80040B8603338uLL);
          list_array_tt<unsigned long,protocol_list_t,RawPtr>::begin(v46, &v48, v25, v26);
          list_array_tt<unsigned long,protocol_list_t,RawPtr>::end(v45, &v48, v27, v28);
          unsigned int v29 = 0;
          while (!list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::operator==((uint64_t)v46, v45))
          {
            uint64_t v33 = *v47;
            if (canonical_protocol) {
              int v34 = 0;
            }
            else {
              int v34 = 0x20000000;
            }
            if ((v34 & *(_DWORD *)(*v47 + 68)) == 0)
            {
              uint64_t Protocol = getProtocol(*(const char **)(v33 + 8));
              if (Protocol) {
                uint64_t v33 = Protocol;
              }
            }
            v17[v29] = (Protocol *)v33;
            list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::operator++(v46, v30, v31, v32);
            ++v29;
          }
          v17[v29] = 0;
          if (outCount) {
            goto LABEL_49;
          }
        }
        else
        {
          int v17 = 0;
          unsigned int v29 = 0;
          if (outCount) {
LABEL_49:
          }
            *outCount = v29;
        }
        int v36 = *(_DWORD *)(StatusReg + 24);
        int v37 = v36;
        atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v37, 0, memory_order_release, memory_order_relaxed);
        if (v37 != v36) {
          os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
        }
        return v17;
      }
    }
    else
    {
      unint64_t v11 = 0;
    }
    if (v12 != 2)
    {
      if (v12 == 1)
      {
        if (!v16) {
          goto LABEL_19;
        }
        goto LABEL_72;
      }
      uint64_t v16 = 0;
      goto LABEL_19;
    }
    if (!v16) {
      goto LABEL_19;
    }
    uint64_t v39 = *v16;
    uint64_t v20 = v16[1];
    unint64_t v42 = v20 * (unint64_t)v39;
    if ((v42 & 0xFFFFFFFF00000000) == 0)
    {
      unint64_t v12 = (unint64_t)v16 + v42 + 8;
      goto LABEL_19;
    }
    goto LABEL_92;
  }
  int v17 = 0;
  if (outCount) {
    *outCount = 0;
  }
  return v17;
}

void sub_18011FB08(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

BOOL class_conformsToProtocol(Class cls, Protocol *protocol)
{
  char v2 = 0;
  if (cls && protocol)
  {
    int v5 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v5, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v5) {
      os_unfair_lock_lock_with_options();
    }
    if ((unint64_t)(*(void *)cls - 1) < 0xF
      || (*(_DWORD *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
      || (uint64_t v7 = *(unsigned __int16 *)((*((void *)cls + 4) & 0xF00007FFFFFFFF8) + 4),
          dword_1EB1CB088 <= v7)
      || (*(void *)(qword_1EB1CB080 + 16 * v7) <= (unint64_t)cls
        ? (BOOL v8 = *(void *)(qword_1EB1CB080 + 16 * v7 + 8) > (unint64_t)cls)
        : (BOOL v8 = 0),
          !v8))
    {
      if (objc::allocatedClasses + 8 * qword_1EB1CAEA0 == objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::find((unint64_t)cls)
        && (dataSegmentsContain(cls, v23, v24) & 1) == 0)
      {
        _objc_fatal("Attempt to use unknown class %p.", v25, v26, v27, cls);
      }
    }
    class_rw_t::protocols(&v31, *((void *)cls + 4) & 0xF00007FFFFFFFF8);
    list_array_tt<unsigned long,protocol_list_t,RawPtr>::begin(v29, &v31, v9, v10);
    list_array_tt<unsigned long,protocol_list_t,RawPtr>::end(v28, &v31, v11, v12);
    while (1)
    {
      char v13 = list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::operator==((uint64_t)v29, v28);
      if (v13) {
        break;
      }
      uint64_t v14 = *v30;
      if (canonical_protocol) {
        int v15 = 0;
      }
      else {
        int v15 = 0x20000000;
      }
      if ((v15 & *(_DWORD *)(*v30 + 68)) == 0)
      {
        uint64_t v16 = getProtocol(*(const char **)(v14 + 8));
        if (v16) {
          uint64_t v14 = v16;
        }
      }
      if ((Protocol *)v14 == protocol
        || (protocol_conformsToProtocol_nolock((protocol_t *)v14, (const char **)protocol) & 1) != 0)
      {
        break;
      }
      list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::operator++(v29, v17, v18, v19);
    }
    char v2 = v13 ^ 1;
    int v20 = *(_DWORD *)(StatusReg + 24);
    int v21 = v20;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v21, 0, memory_order_release, memory_order_relaxed);
    if (v21 != v20) {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
  }
  return v2;
}

void sub_18011FDA4(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

uint64_t list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::operator==(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)a1;
  if (*(void *)a1 != *a2) {
    return 0;
  }
  if (!*v2)
  {
LABEL_5:
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v4 = a2[1];
    goto LABEL_6;
  }
  if ((*v2 & 3) != 2)
  {
    if ((*v2 & 3uLL) > 1) {
      return 0;
    }
    goto LABEL_5;
  }
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = a2[3];
LABEL_6:
  if (v3 != v4) {
    return 0;
  }
  if (v2 != *(void **)(a1 + 32)) {
    return *(void *)(a1 + 64) == a2[8];
  }
  if (!*v2)
  {
LABEL_12:
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v7 = *(void *)(a1 + 40);
    goto LABEL_13;
  }
  if ((*v2 & 3) != 2)
  {
    if ((*v2 & 3uLL) > 1) {
      return *(void *)(a1 + 64) == a2[8];
    }
    goto LABEL_12;
  }
  uint64_t v6 = *(void *)(a1 + 24);
  uint64_t v7 = *(void *)(a1 + 56);
LABEL_13:
  if (v6 != v7) {
    return *(void *)(a1 + 64) == a2[8];
  }
  return 1;
}

uint64_t **list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::operator++(uint64_t **a1, uint64_t a2, const char *a3, char *a4)
{
  int v5 = a1[9];
  uint64_t v6 = (uint64_t)(a1[8] + 1);
  a1[8] = (uint64_t *)v6;
  if ((uint64_t *)v6 != v5) {
    return a1;
  }
  uint64_t v7 = *a1;
  uint64_t v8 = **a1;
  if (!v8)
  {
    a1[1] = 0;
    goto LABEL_14;
  }
  if ((**a1 & 3) == 1)
  {
    ++a1[1];
    uint64_t v8 = *v7;
    if (!*v7) {
      goto LABEL_14;
    }
  }
  else if ((v8 & 3) == 0)
  {
    a1[1] = 0;
  }
  if ((v8 & 3) == 2)
  {
    uint64_t v9 = a1[3];
    uint64_t v10 = *((unsigned int *)a1 + 4);
    int v11 = *((_DWORD *)a1 + 5);
    a1[3] = (uint64_t *)((char *)v9 + v10);
    unint64_t v12 = (unsigned int *)a1[1];
    uint64_t v14 = *v12;
    uint64_t v13 = v12[1];
    unint64_t v15 = v13 * (unint64_t)v14;
    *((_DWORD *)a1 + 5) = v11 + 1;
    if ((v15 & 0xFFFFFFFF00000000) != 0) {
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v13, v12, v14);
    }
    unint64_t v16 = (unint64_t)v12 + v15 + 8;
    if ((unint64_t)v9 + v10 < v16)
    {
      uint64_t v17 = objc_debug_headerInfoRWs;
      int v18 = v11 + 2;
      do
      {
        if (*(void *)(v17 + 8 * *(unsigned __int16 *)((char *)v9 + v10) + 8)) {
          break;
        }
        a1[3] = (uint64_t *)((char *)v9 + 2 * v10);
        *((_DWORD *)a1 + 5) = v18++;
        uint64_t v9 = (uint64_t *)((char *)v9 + v10);
      }
      while ((unint64_t)v9 + v10 < v16);
    }
  }
LABEL_14:
  list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::skipEmptyLists(a1);
  uint64_t v22 = **a1;
  if (*a1 == a1[4])
  {
    if (!v22) {
      goto LABEL_24;
    }
    if ((**a1 & 3) == 2)
    {
      unint64_t v32 = a1[3];
      uint64_t v33 = a1[7];
    }
    else
    {
      if ((**a1 & 3) != 1)
      {
        if ((v22 & 3) == 0)
        {
LABEL_24:
          if (a1[1] == a1[5]) {
            return a1;
          }
          goto LABEL_15;
        }
LABEL_16:
        uint64_t v23 = **a1 & 3;
        if (v23)
        {
          if (v23 != 1)
          {
            if (v23 == 2)
            {
              uint64_t v24 = a1[3];
              uint64_t v25 = (char *)v24 + (*v24 >> 16);
            }
            else
            {
              uint64_t v25 = 0;
              uint64_t v24 = a1[3];
            }
            unsigned int v29 = (uint64_t *)(v25 + 8);
            a1[8] = v29;
            uint64_t v28 = (uint64_t *)((char *)v24 + (*v24 >> 16));
            goto LABEL_33;
          }
          uint64_t v28 = (uint64_t *)*a1[1];
        }
        else
        {
          uint64_t v28 = a1[1];
        }
        unsigned int v29 = v28 + 1;
        a1[8] = v28 + 1;
LABEL_33:
        uint64_t v30 = (uint64_t)&v28[*v28 + 1];
        a1[9] = (uint64_t *)v30;
        if (v29 != (uint64_t *)v30) {
          return a1;
        }
        if (v23 == 2)
        {
          unint64_t v26 = (uint64_t *)((char *)a1[3] + (*a1[3] >> 16));
        }
        else if (v23 == 1)
        {
          unint64_t v26 = (uint64_t *)*a1[1];
        }
        else if (v23)
        {
          unint64_t v26 = 0;
        }
        else
        {
          unint64_t v26 = a1[1];
        }
LABEL_46:
        _objc_fatal("Assertion failed: (%s) - empty list %p encountered during iteration", v19, v20, v21, "m != mEnd", v26);
      }
      unint64_t v32 = a1[1];
      uint64_t v33 = a1[5];
    }
    if (v32 == v33) {
      return a1;
    }
    goto LABEL_16;
  }
LABEL_15:
  if (v22) {
    goto LABEL_16;
  }
  unint64_t v26 = a1[1];
  uint64_t v27 = *v26;
  a1[8] = v26 + 1;
  a1[9] = &v26[v27 + 1];
  if (!v27) {
    goto LABEL_46;
  }
  return a1;
}

uint64_t **list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::skipEmptyLists(uint64_t **result)
{
  int v1 = *result;
  uint64_t v2 = result[4];
  uint64_t v3 = objc_debug_headerInfoRWs;
  uint64_t v4 = **result;
  while (1)
  {
    if (v1 != v2) {
      goto LABEL_8;
    }
    if (v4) {
      break;
    }
LABEL_7:
    if (result[1] == result[5]) {
      return result;
    }
LABEL_8:
    if (!v4)
    {
      int v5 = 1;
LABEL_13:
      uint64_t v6 = result[1];
      goto LABEL_15;
    }
LABEL_9:
    int v5 = v4 & 3;
    if ((v4 & 3) != 1)
    {
      if ((v4 & 3) != 0)
      {
        int v5 = 0;
        uint64_t v6 = (uint64_t *)((char *)result[3] + (*result[3] >> 16));
        goto LABEL_15;
      }
      goto LABEL_13;
    }
    int v5 = 0;
    uint64_t v6 = (uint64_t *)*result[1];
LABEL_15:
    if (*v6) {
      return result;
    }
    if (v5)
    {
      uint64_t v4 = 0;
      result[1] = 0;
    }
    else
    {
      if ((v4 & 3) == 1)
      {
        ++result[1];
        uint64_t v7 = *v1;
      }
      else
      {
        if ((v4 & 3) == 0) {
          result[1] = 0;
        }
        uint64_t v7 = v4;
      }
      uint64_t v4 = 0;
      if (v7)
      {
        uint64_t v4 = v7;
        if ((v7 & 3) == 2)
        {
          uint64_t v8 = result[3];
          uint64_t v9 = *((unsigned int *)result + 4);
          int v10 = *((_DWORD *)result + 5);
          unint64_t v11 = (unint64_t)v8 + v9;
          result[3] = (uint64_t *)((char *)v8 + v9);
          unint64_t v12 = (unsigned int *)result[1];
          uint64_t v13 = (const char *)*v12;
          uint64_t v14 = v12[1];
          unint64_t v15 = v14 * (unint64_t)v13;
          *((_DWORD *)result + 5) = v10 + 1;
          if ((v15 & 0xFFFFFFFF00000000) != 0) {
            _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v11, v13, (char *)v15, v14, v12, v13);
          }
          unint64_t v16 = (unint64_t)v12 + v15 + 8;
          uint64_t v4 = v7;
          if (v11 < v16)
          {
            int v17 = v10 + 2;
            do
            {
              if (*(void *)(v3 + 8 * *(unsigned __int16 *)((char *)v8 + v9) + 8)) {
                break;
              }
              result[3] = (uint64_t *)((char *)v8 + 2 * v9);
              *((_DWORD *)result + 5) = v17++;
              uint64_t v8 = (uint64_t *)((char *)v8 + v9);
            }
            while ((unint64_t)v8 + v9 < v16);
            uint64_t v4 = v7;
          }
        }
      }
    }
  }
  if ((v4 & 3) == 2)
  {
    int v18 = result[3];
    uint64_t v19 = result[7];
    goto LABEL_33;
  }
  if ((v4 & 3) != 1)
  {
    if ((v4 & 3) != 0) {
      goto LABEL_9;
    }
    goto LABEL_7;
  }
  int v18 = result[1];
  uint64_t v19 = result[5];
LABEL_33:
  if (v18 != v19) {
    goto LABEL_9;
  }
  return result;
}

unint64_t *class_rw_t::protocols(unint64_t *this, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2)
  {
    *this = 0;
    unint64_t v6 = *(void *)((v2 & 0xFFFFFFFFFFFFFFFELL) + 24);
    if (v6) {
      unint64_t v4 = v6;
    }
    else {
      unint64_t v4 = 0;
    }
    goto LABEL_13;
  }
  *this = 0;
  uint64_t v3 = *(void *)((v2 & 0xFFFFFFFFFFFFFFFELL) + 40);
  unint64_t v4 = v3 & 0xFFFFFFFFFFFFFFFELL;
  if ((v3 & 1) == 0 && v4)
  {
LABEL_13:
    *this = v4;
    return this;
  }
  if (v4) {
    BOOL v5 = (*(void *)((v2 & 0xFFFFFFFFFFFFFFFELL) + 40) & 1) == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    unint64_t v4 = v3 & 0xFFFFFFFFFFFFFFFCLL | 2;
    goto LABEL_13;
  }
  return this;
}

uint64_t **list_array_tt<unsigned long,protocol_list_t,RawPtr>::end(uint64_t **a1, void *a2, const char *a3, char *a4)
{
  uint64_t v6 = *a2;
  if (!*a2)
  {
    int v17 = a2;
    goto LABEL_8;
  }
  if ((*a2 & 3) != 2)
  {
    if ((*a2 & 3) == 1)
    {
      uint64_t v7 = (unsigned int *)(v6 & 0xFFFFFFFFFFFFFFFCLL);
      if ((v6 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
        v7 += 2 * *v7 + 2;
      }
      int v17 = a2;
      unint64_t v18 = (unint64_t)v7;
      uint64_t v13 = a2;
      unint64_t v14 = (unint64_t)v7;
      return list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v17, &v13);
    }
    int v17 = a2;
    if ((v6 & 3) != 0)
    {
      uint64_t v13 = a2;
      return list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v17, &v13);
    }
LABEL_8:
    unint64_t v18 = 0;
    uint64_t v13 = a2;
    unint64_t v14 = 0;
    return list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v17, &v13);
  }
  uint64_t v8 = (unsigned int *)(v6 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v6 & 0xFFFFFFFFFFFFFFFCLL) != 0)
  {
    uint64_t v10 = *v8;
    uint64_t v9 = v8[1];
    unint64_t v11 = v9 * (unint64_t)v10;
    if ((v11 & 0xFFFFFFFF00000000) != 0) {
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v9, v6 & 0xFFFFFFFFFFFFFFFCLL, v10);
    }
    uint64_t v4 = (uint64_t)v8 + v11 + 8;
    uint64_t v5 = v10 | (v9 << 32);
  }
  int v17 = a2;
  unint64_t v18 = v6 & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v19 = v5;
  uint64_t v20 = v4;
  uint64_t v13 = a2;
  unint64_t v14 = v6 & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v15 = v5;
  uint64_t v16 = v4;
  return list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v17, &v13);
}

uint64_t **list_array_tt<unsigned long,protocol_list_t,RawPtr>::begin(uint64_t **a1, unint64_t *a2, const char *a3, char *a4)
{
  int v35 = a2;
  unint64_t v4 = *a2;
  if (!*a2) {
    goto LABEL_13;
  }
  unint64_t v5 = *a2;
  uint64_t v6 = *a2 & 3;
  if ((v4 & 3) == 0)
  {
    unint64_t v9 = v4 & 0xFFFFFFFFFFFFFFFCLL;
    if ((v4 & 0xFFFFFFFFFFFFFFFCLL) != 0)
    {
LABEL_11:
      unint64_t v36 = v9;
LABEL_12:
      unint64_t v31 = a2;
      goto LABEL_15;
    }
    goto LABEL_13;
  }
  if (v4 <= 3)
  {
LABEL_13:
    unint64_t v36 = 0;
    goto LABEL_14;
  }
  if (v6 != 2)
  {
    BOOL v8 = v6 == 1;
    unint64_t v7 = v4 & 0xFFFFFFFFFFFFFFFCLL;
    BOOL v8 = !v8 || v7 == 0;
    if (v8) {
      goto LABEL_12;
    }
    unint64_t v9 = v7 + 8;
    goto LABEL_11;
  }
  int v17 = (unsigned int *)(v4 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v4 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
    goto LABEL_12;
  }
  if (DisablePreattachedCategories)
  {
    unint64_t v21 = *v17;
    uint64_t v25 = v17[1];
    unint64_t v26 = v25 * (unint64_t)v21;
    if ((v26 & 0xFFFFFFFF00000000) != 0) {
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v25, v5 & 0xFFFFFFFFFFFFFFFCLL, v21);
    }
    unint64_t v27 = v21 | (v25 << 32);
    uint64_t v28 = (uint64_t)v17 + v26 + 8;
    unint64_t v29 = v21 | ((unint64_t)(v25 - 1) << 32);
    BOOL v30 = v25 == 0;
    if (v25) {
      uint64_t v19 = v25;
    }
    else {
      uint64_t v19 = 0;
    }
    if (v25) {
      unint64_t v18 = (unsigned __int16 *)(v28 - v21);
    }
    else {
      unint64_t v18 = (unsigned __int16 *)v28;
    }
    if (v30) {
      unint64_t v20 = v27;
    }
    else {
      unint64_t v20 = v29;
    }
  }
  else
  {
    unint64_t v18 = (unsigned __int16 *)(v17 + 2);
    unint64_t v20 = *v17;
    uint64_t v19 = v17[1];
    unint64_t v21 = v20;
  }
  unint64_t v22 = v19 * (unint64_t)v21;
  if ((v22 & 0xFFFFFFFF00000000) != 0) {
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v19, v5 & 0xFFFFFFFFFFFFFFFCLL, v21);
  }
  unint64_t v23 = HIDWORD(v20);
  for (i = (unint64_t)v17 + v22 + 8; (unint64_t)v18 < i; unint64_t v23 = (v23 + 1))
  {
    if (*(void *)(objc_debug_headerInfoRWs + 8 * *v18 + 8)) {
      break;
    }
    unint64_t v18 = (unsigned __int16 *)((char *)v18 + v20);
  }
  unint64_t v36 = v5 & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v37 = v20 | (v23 << 32);
  uint64_t v38 = v18;
LABEL_14:
  unint64_t v31 = a2;
  if (!v4)
  {
LABEL_18:
    unint64_t v32 = 0;
    return list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v35, &v31);
  }
LABEL_15:
  unint64_t v10 = v4;
  unint64_t v11 = v4 & 3;
  if ((v10 & 3) == 2)
  {
    unint64_t v12 = (unsigned int *)(v10 & 0xFFFFFFFFFFFFFFFCLL);
    if ((v10 & 0xFFFFFFFFFFFFFFFCLL) != 0)
    {
      uint64_t v14 = *v12;
      uint64_t v13 = v12[1];
      unint64_t v15 = v13 * (unint64_t)v14;
      if ((v15 & 0xFFFFFFFF00000000) != 0) {
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v13, v10 & 0xFFFFFFFFFFFFFFFCLL, v14);
      }
      unint64_t v32 = v10 & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v33 = v14 | (v13 << 32);
      uint64_t v34 = (uint64_t)v12 + v15 + 8;
    }
  }
  else if (v11 == 1)
  {
    if ((v10 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
      unint64_t v32 = (v10 & 0xFFFFFFFFFFFFFFFCLL) + 8 * *(unsigned int *)(v10 & 0xFFFFFFFFFFFFFFFCLL) + 8;
    }
  }
  else if (!v11)
  {
    goto LABEL_18;
  }
  return list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v35, &v31);
}

uint64_t **list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::iteratorImpl(uint64_t **a1, uint64_t a2, void *a3)
{
  list_array_tt<property_t,property_list_t,RawPtr>::ListIterator::ListIterator(a1, a2);
  list_array_tt<property_t,property_list_t,RawPtr>::ListIterator::ListIterator((void *)(v6 + 32), (uint64_t)a3);
  uint64_t v7 = **(void **)a2;
  if (*(void *)a2 != *a3) {
    goto LABEL_2;
  }
  if (!v7)
  {
LABEL_12:
    if (*(void *)(a2 + 8) == a3[1]) {
      goto LABEL_18;
    }
LABEL_2:
    if (!v7) {
      goto LABEL_7;
    }
    goto LABEL_3;
  }
  if ((**(void **)a2 & 3) == 2)
  {
    uint64_t v13 = *(void *)(a2 + 24);
    uint64_t v14 = a3[3];
LABEL_21:
    if (v13 == v14) {
      goto LABEL_18;
    }
    goto LABEL_3;
  }
  if ((**(void **)a2 & 3) == 1)
  {
    uint64_t v13 = *(void *)(a2 + 8);
    uint64_t v14 = a3[1];
    goto LABEL_21;
  }
  if ((v7 & 3) == 0) {
    goto LABEL_12;
  }
LABEL_3:
  uint64_t v8 = **(void **)a2 & 3;
  if (v8)
  {
    if (v8 == 1)
    {
      a1[8] = (uint64_t *)(**(void **)(a2 + 8) + 8);
      unint64_t v11 = **(void ***)(a2 + 8);
    }
    else
    {
      if (v8 == 2)
      {
        unint64_t v9 = *(uint64_t **)(a2 + 24);
        unint64_t v10 = (char *)v9 + (*v9 >> 16);
      }
      else
      {
        unint64_t v10 = 0;
        unint64_t v9 = *(uint64_t **)(a2 + 24);
      }
      a1[8] = (uint64_t *)(v10 + 8);
      unint64_t v11 = (uint64_t *)((char *)v9 + (*v9 >> 16));
    }
    goto LABEL_17;
  }
LABEL_7:
  unint64_t v11 = *(void **)(a2 + 8);
  a1[8] = v11 + 1;
LABEL_17:
  a1[9] = &v11[*v11 + 1];
LABEL_18:
  list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::skipEmptyLists(a1);
  return a1;
}

__n128 list_array_tt<property_t,property_list_t,RawPtr>::ListIterator::ListIterator(void *a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a2;
  *a1 = *(void *)a2;
  if (!*v2)
  {
LABEL_4:
    a1[1] = *(void *)(a2 + 8);
    return result;
  }
  if ((*v2 & 3) != 2)
  {
    if ((*v2 & 3uLL) > 1) {
      return result;
    }
    goto LABEL_4;
  }
  __n128 result = *(__n128 *)(a2 + 8);
  a1[3] = *(void *)(a2 + 24);
  *(__n128 *)(a1 + 1) = result;
  return result;
}

uint64_t addClassTableEntry(uint64_t result, char a2)
{
  for (unint64_t i = (objc_class *)result; ; unint64_t i = (objc_class *)(*(void *)i & 0xFFFFFFFF8))
  {
    uint64_t v8 = i;
    if ((unint64_t)(*(void *)i - 1) < 0xF
      || (*(_DWORD *)(*((void *)i + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
      || (uint64_t v4 = *(unsigned __int16 *)((*((void *)i + 4) & 0xF00007FFFFFFFF8) + 4), dword_1EB1CB088 <= v4)
      || (*(void *)(qword_1EB1CB080 + 16 * v4) <= (unint64_t)i
        ? (BOOL v5 = *(void *)(qword_1EB1CB080 + 16 * v4 + 8) > (unint64_t)i)
        : (BOOL v5 = 0),
          !v5))
    {
      __n128 result = objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::find((unint64_t)i);
      if (objc::allocatedClasses + 8 * qword_1EB1CAEA0 == result)
      {
        __n128 result = dataSegmentsContain(i, v6, v7);
        if ((result & 1) == 0) {
          __n128 result = objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::try_emplace<objc::detail::DenseSetEmpty&>((uint64_t)v9, (int32x2_t *)&objc::allocatedClasses, (unint64_t *)&v8);
        }
      }
    }
    if ((a2 & 1) == 0) {
      break;
    }
    a2 = 0;
  }
  return result;
}

uint64_t objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::find(unint64_t a1)
{
  if (objc::allocatedClasses) {
    int v1 = (void *)objc::allocatedClasses;
  }
  else {
    int v1 = 0;
  }
  if (qword_1EB1CAEA0)
  {
    LODWORD(v2) = (qword_1EB1CAEA0 - 1) & (bswap64(0x8A970BE7488FDA55 * (a1 ^ (a1 >> 4))) ^ (1217387093
                                                                                             * (a1 ^ (a1 >> 4))));
    uint64_t v3 = &v1[v2];
    uint64_t v4 = *v3;
    if (*v3 == a1) {
      return (uint64_t)v3;
    }
    unsigned int v5 = 1;
    while (v4 != -1)
    {
      if (v5 > qword_1EB1CAEA0) {
        objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::FatalCorruptHashTables((uint64_t)&objc::allocatedClasses, v1, qword_1EB1CAEA0);
      }
      int v6 = v2 + v5++;
      uint64_t v2 = v6 & (qword_1EB1CAEA0 - 1);
      uint64_t v4 = v1[v2];
      if (v4 == a1) {
        return (uint64_t)&v1[v2];
      }
    }
  }
  if (objc::allocatedClasses) {
    return objc::allocatedClasses + 8 * qword_1EB1CAEA0;
  }
  else {
    return 8 * qword_1EB1CAEA0;
  }
}

uint64_t dataSegmentsContain(objc_class *a1, uint64_t a2, unsigned int *a3)
{
  int v6 = 0;
  uint64_t result = objc::SafeRanges::find(a1, &v6, a3);
  if (result && (unint64_t)(*(void *)a1 - 1) >= 0xF)
  {
    uint64_t v5 = *((void *)a1 + 4);
    if ((*(_DWORD *)(v5 & 0xF00007FFFFFFFF8) & 0x80000000) != 0) {
      *(_WORD *)((v5 & 0xF00007FFFFFFFF8) + 4) = v6;
    }
  }
  return result;
}

uint64_t objc::SafeRanges::find(objc::SafeRanges *this, _DWORD *a2, unsigned int *a3)
{
  if ((dword_1EB1CB08C & 0x80000000) == 0)
  {
    unint64_t v5 = 126 - 2 * __clz(dword_1EB1CB088);
    if (dword_1EB1CB088) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    std::__introsort<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *,false>(qword_1EB1CB080, (unint64_t *)(qword_1EB1CB080 + 16 * dword_1EB1CB088), v6, 1);
    dword_1EB1CB08C |= 0x80000000;
  }
  unsigned int v7 = dword_1EB1CB088;
  if (dword_1EB1CB088)
  {
    unsigned int v8 = 0;
    do
    {
      uint64_t v9 = (v7 + v8) >> 1;
      if (*(void *)(qword_1EB1CB080 + 16 * v9) <= (unint64_t)this)
      {
        if (*(void *)(qword_1EB1CB080 + 16 * v9 + 8) > (unint64_t)this)
        {
          uint64_t result = 1;
          goto LABEL_15;
        }
        unsigned int v8 = v9 + 1;
      }
      else
      {
        unsigned int v7 = (v7 + v8) >> 1;
      }
    }
    while (v8 < v7);
  }
  uint64_t result = 0;
  LODWORD(v9) = -1;
LABEL_15:
  *a2 = v9;
  return result;
}

uint64_t objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::try_emplace<objc::detail::DenseSetEmpty&>(uint64_t a1, int32x2_t *a2, unint64_t *a3)
{
  uint64_t v13 = 0;
  uint64_t result = objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::LookupBucketFor<objc_class *>((uint64_t)a2, *a3, &v13);
  unsigned int v7 = v13;
  if (result)
  {
    char v8 = 0;
    int32x2_t v9 = *a2;
    goto LABEL_3;
  }
  __int32 v11 = a2[1].i32[0];
  unsigned int v12 = a2[2].u32[0];
  if (4 * v11 + 4 >= 3 * v12)
  {
    v12 *= 2;
    goto LABEL_12;
  }
  if (v12 + ~v11 - a2[1].i32[1] <= v12 >> 3)
  {
LABEL_12:
    objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::grow((uint64_t)a2, v12);
    uint64_t v13 = 0;
    uint64_t result = objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::LookupBucketFor<objc_class *>((uint64_t)a2, *a3, &v13);
    unsigned int v7 = v13;
  }
  if (*v7 == -2)
  {
    a2[1] = vadd_s32(a2[1], (int32x2_t)0xFFFFFFFF00000001);
  }
  else if (*v7 == -1)
  {
    ++a2[1].i32[0];
  }
  *unsigned int v7 = *a3;
  int32x2_t v9 = *a2;
  char v8 = 1;
LABEL_3:
  uint64_t v10 = *(void *)&v9 + 8 * a2[2].u32[0];
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v10;
  *(unsigned char *)(a1 + 16) = v8;
  return result;
}

void objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if (*(void *)a1) {
    uint64_t v4 = *(unint64_t **)a1;
  }
  else {
    uint64_t v4 = 0;
  }
  unsigned int v5 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
  unsigned int v6 = v5 | (v5 >> 4) | ((v5 | (v5 >> 4)) >> 8);
  int v7 = v6 | HIWORD(v6);
  if ((v7 + 1) > 4) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 4;
  }
  *(_DWORD *)(a1 + 16) = v8;
  int32x2_t v9 = malloc_type_malloc(8 * v8, 0x64B88C75uLL);
  if (v9)
  {
    *(void *)a1 = v9;
    if (v4)
    {
      uint64_t v10 = &v4[v3];
      *(void *)(a1 + 8) = 0;
LABEL_13:
      uint64_t v11 = *(unsigned int *)(a1 + 16);
      if (v11) {
        memset(v9, 255, 8 * v11);
      }
      if (v3)
      {
        unsigned int v12 = v4;
        do
        {
          unint64_t v13 = *v12;
          if (*v12 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            unint64_t v15 = 0;
            objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::LookupBucketFor<objc_class *>(a1, v13, &v15);
            *unint64_t v15 = *v12;
            ++*(_DWORD *)(a1 + 8);
          }
          ++v12;
        }
        while (v12 != v10);
      }
      free(v4);
      return;
    }
    *(void *)(a1 + 8) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    int32x2_t v9 = 0;
    if (v4)
    {
      uint64_t v10 = &v4[v3];
      *(void *)(a1 + 8) = 0;
      goto LABEL_13;
    }
    *(void *)(a1 + 8) = 0;
  }
  uint64_t v14 = *(unsigned int *)(a1 + 16);
  if (v14)
  {
    memset(v9, 255, 8 * v14);
  }
}

uint64_t objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::LookupBucketFor<objc_class *>(uint64_t a1, unint64_t a2, void *a3)
{
  uint64_t v3 = *(void **)a1;
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    unsigned int v5 = v4 - 1;
    int v6 = (v4 - 1) & (bswap64(0x8A970BE7488FDA55 * (a2 ^ (a2 >> 4))) ^ (1217387093 * (a2 ^ (a2 >> 4))));
    int v7 = &v3[v6];
    uint64_t v8 = *v7;
    if (*v7 == a2)
    {
      uint64_t v9 = 1;
    }
    else
    {
      uint64_t v11 = 0;
      unsigned int v12 = 1;
      while (v8 != -1)
      {
        if (v12 > v4) {
          objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::FatalCorruptHashTables(a1, v3, *(unsigned int *)(a1 + 16));
        }
        if (v11) {
          BOOL v13 = 0;
        }
        else {
          BOOL v13 = v8 == -2;
        }
        if (v13) {
          uint64_t v11 = v7;
        }
        int v14 = v6 + v12++;
        int v6 = v14 & v5;
        int v7 = &v3[v14 & v5];
        uint64_t v8 = *v7;
        uint64_t v9 = 1;
        if (*v7 == a2) {
          goto LABEL_5;
        }
      }
      uint64_t v9 = 0;
      if (v11) {
        int v7 = v11;
      }
    }
  }
  else
  {
    int v7 = 0;
    uint64_t v9 = 0;
  }
LABEL_5:
  *a3 = v7;
  return v9;
}

void std::__introsort<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *,false>(unint64_t a1, unint64_t *a2, uint64_t a3, char a4)
{
  while (2)
  {
    uint64_t v10 = (long long *)(a2 - 2);
    unint64_t v11 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v11;
          uint64_t v12 = (uint64_t)a2 - v11;
          unint64_t v13 = (uint64_t)((uint64_t)a2 - v11) >> 4;
          if (v5 || !v4)
          {
            switch(v13)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (*(void *)v10 < *(void *)v11)
                {
                  long long v88 = *(_OWORD *)v11;
                  *(_OWORD *)unint64_t v11 = *v10;
                  *uint64_t v10 = v88;
                }
                break;
              case 3uLL:
                std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((long long *)v11, (unint64_t *)(v11 + 16), a2 - 2);
                break;
              case 4uLL:
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((long long *)v11, (unint64_t *)(v11 + 16), (unint64_t *)(v11 + 32), (_OWORD *)a2 - 1);
                break;
              case 5uLL:
                unint64_t v36 = (long long *)(v11 + 16);
                unint64_t v37 = (long long *)(v11 + 32);
                uint64_t v38 = (long long *)(v11 + 48);
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((long long *)v11, (unint64_t *)(v11 + 16), (unint64_t *)(v11 + 32), (_OWORD *)(v11 + 48));
                if (*(void *)v10 < *(void *)(v11 + 48))
                {
                  long long v39 = *v38;
                  *uint64_t v38 = *v10;
                  *uint64_t v10 = v39;
                  if (*(void *)v38 < *(void *)v37)
                  {
                    long long v40 = *v37;
                    *unint64_t v37 = *v38;
                    *uint64_t v38 = v40;
                    if (*(void *)v37 < *(void *)v36)
                    {
                      long long v41 = *v36;
                      long long *v36 = *v37;
                      *unint64_t v37 = v41;
                      if (*(void *)(v11 + 16) < *(void *)v11)
                      {
                        long long v89 = *(_OWORD *)v11;
                        *(_OWORD *)unint64_t v11 = *v36;
                        long long *v36 = v89;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v12 <= 383)
          {
            unint64_t v42 = (unint64_t *)(v11 + 16);
            BOOL v44 = (unint64_t *)v11 == a2 || v42 == a2;
            if (a4)
            {
              if (!v44)
              {
                uint64_t v45 = 0;
                uint64_t v46 = (unint64_t *)v11;
                do
                {
                  unint64_t v47 = v42;
                  unint64_t v48 = v46[2];
                  if (v48 < *v46)
                  {
                    unint64_t v49 = v46[3];
                    uint64_t v50 = v45;
                    while (1)
                    {
                      *(_OWORD *)(v11 + v50 + 16) = *(_OWORD *)(v11 + v50);
                      if (!v50) {
                        break;
                      }
                      unint64_t v51 = *(void *)(v11 + v50 - 16);
                      v50 -= 16;
                      if (v48 >= v51)
                      {
                        unint64_t v52 = (void *)(v11 + v50 + 16);
                        goto LABEL_81;
                      }
                    }
                    unint64_t v52 = (void *)v11;
LABEL_81:
                    *unint64_t v52 = v48;
                    v52[1] = v49;
                  }
                  unint64_t v42 = v47 + 2;
                  v45 += 16;
                  uint64_t v46 = v47;
                }
                while (v47 + 2 != a2);
              }
            }
            else if (!v44)
            {
              do
              {
                unint64_t v81 = (unint64_t)v42;
                unint64_t v82 = *(void *)(a1 + 16);
                if (v82 < *(void *)a1)
                {
                  uint64_t v83 = *(void *)(a1 + 24);
                  unint64_t v84 = v81;
                  do
                  {
                    *(_OWORD *)unint64_t v84 = *(_OWORD *)(v84 - 16);
                    unint64_t v85 = *(void *)(v84 - 32);
                    v84 -= 16;
                  }
                  while (v82 < v85);
                  *(void *)unint64_t v84 = v82;
                  *(void *)(v84 + 8) = v83;
                }
                unint64_t v42 = (unint64_t *)(v81 + 16);
                a1 = v81;
              }
              while ((unint64_t *)(v81 + 16) != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((unint64_t *)v11 != a2)
            {
              int64_t v53 = (v13 - 2) >> 1;
              int64_t v54 = v53;
              do
              {
                int64_t v55 = v54;
                if (v53 >= v54)
                {
                  uint64_t v56 = (2 * v54) | 1;
                  int v57 = (unint64_t *)(v11 + 16 * v56);
                  if (2 * v55 + 2 < (uint64_t)v13)
                  {
                    unint64_t v59 = v57[2];
                    BOOL v58 = *v57 >= v59;
                    if (*v57 > v59) {
                      unint64_t v59 = *v57;
                    }
                    if (!v58)
                    {
                      v57 += 2;
                      uint64_t v56 = 2 * v55 + 2;
                    }
                  }
                  else
                  {
                    unint64_t v59 = *v57;
                  }
                  unsigned int v60 = (unint64_t *)(v11 + 16 * v55);
                  unint64_t v61 = *v60;
                  if (v59 >= *v60)
                  {
                    unint64_t v62 = v60[1];
                    do
                    {
                      unint64_t v63 = v60;
                      unsigned int v60 = v57;
                      *(_OWORD *)unint64_t v63 = *(_OWORD *)v57;
                      if (v53 < v56) {
                        break;
                      }
                      uint64_t v64 = (2 * v56) | 1;
                      int v57 = (unint64_t *)(v11 + 16 * v64);
                      uint64_t v56 = 2 * v56 + 2;
                      if (v56 < (uint64_t)v13)
                      {
                        unint64_t v67 = *v57;
                        unint64_t v65 = v57[2];
                        BOOL v66 = *v57 >= v65;
                        if (*v57 <= v65) {
                          unint64_t v67 = v57[2];
                        }
                        if (*v57 < v65) {
                          v57 += 2;
                        }
                        if (v66) {
                          uint64_t v56 = v64;
                        }
                      }
                      else
                      {
                        unint64_t v67 = *v57;
                        uint64_t v56 = v64;
                      }
                    }
                    while (v67 >= v61);
                    unint64_t *v60 = v61;
                    v60[1] = v62;
                  }
                }
                int64_t v54 = v55 - 1;
              }
              while (v55);
              uint64_t v68 = (unint64_t)v12 >> 4;
              do
              {
                uint64_t v69 = 0;
                long long v90 = *(_OWORD *)v11;
                unint64_t v70 = (_OWORD *)v11;
                do
                {
                  unint64_t v71 = (unint64_t *)&v70[v69 + 1];
                  uint64_t v72 = (2 * v69) | 1;
                  uint64_t v73 = 2 * v69 + 2;
                  if (v73 < v68 && *v71 < v71[2])
                  {
                    v71 += 2;
                    uint64_t v72 = v73;
                  }
                  *unint64_t v70 = *(_OWORD *)v71;
                  unint64_t v70 = v71;
                  uint64_t v69 = v72;
                }
                while (v72 <= (uint64_t)((unint64_t)(v68 - 2) >> 1));
                a2 -= 2;
                if (v71 == a2)
                {
                  *(_OWORD *)unint64_t v71 = v90;
                }
                else
                {
                  *(_OWORD *)unint64_t v71 = *(_OWORD *)a2;
                  *(_OWORD *)a2 = v90;
                  uint64_t v74 = (uint64_t)v71 - v11 + 16;
                  if (v74 >= 17)
                  {
                    unint64_t v75 = (((unint64_t)v74 >> 4) - 2) >> 1;
                    int v76 = (unint64_t *)(v11 + 16 * v75);
                    unint64_t v77 = *v71;
                    if (*v76 < *v71)
                    {
                      unint64_t v78 = v71[1];
                      do
                      {
                        BOOL v79 = v71;
                        unint64_t v71 = v76;
                        *(_OWORD *)BOOL v79 = *(_OWORD *)v76;
                        if (!v75) {
                          break;
                        }
                        unint64_t v75 = (v75 - 1) >> 1;
                        int v76 = (unint64_t *)(v11 + 16 * v75);
                      }
                      while (*v76 < v77);
                      *unint64_t v71 = v77;
                      v71[1] = v78;
                    }
                  }
                }
              }
              while (v68-- > 2);
            }
            return;
          }
          unint64_t v14 = v13 >> 1;
          unint64_t v15 = (unint64_t *)(v11 + 16 * (v13 >> 1));
          if ((unint64_t)v12 >= 0x801)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((long long *)a1, (unint64_t *)(a1 + 16 * (v13 >> 1)), a2 - 2);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((long long *)(a1 + 16), v15 - 2, a2 - 4);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((long long *)(a1 + 32), (unint64_t *)(a1 + 16 + 16 * v14), a2 - 6);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((long long *)v15 - 1, v15, (unint64_t *)(a1 + 16 + 16 * v14));
            long long v86 = *(_OWORD *)a1;
            *(_OWORD *)a1 = *(_OWORD *)v15;
            *(_OWORD *)unint64_t v15 = v86;
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((long long *)(a1 + 16 * (v13 >> 1)), (unint64_t *)a1, a2 - 2);
          }
          --a3;
          unint64_t v16 = *(void *)a1;
          if ((a4 & 1) != 0 || *(void *)(a1 - 16) < v16) {
            break;
          }
          if (v16 >= *(void *)v10)
          {
            unint64_t v30 = a1 + 16;
            do
            {
              unint64_t v11 = v30;
              if (v30 >= (unint64_t)a2) {
                break;
              }
              v30 += 16;
            }
            while (v16 >= *(void *)v11);
          }
          else
          {
            unint64_t v11 = a1;
            do
            {
              unint64_t v29 = *(void *)(v11 + 16);
              v11 += 16;
            }
            while (v16 >= v29);
          }
          unint64_t v31 = a2;
          if (v11 < (unint64_t)a2)
          {
            unint64_t v31 = a2;
            do
              unint64_t v32 = *((void *)v31-- - 2);
            while (v16 < v32);
          }
          uint64_t v33 = *(void *)(a1 + 8);
          while (v11 < (unint64_t)v31)
          {
            long long v87 = *(_OWORD *)v11;
            *(_OWORD *)unint64_t v11 = *v31;
            *unint64_t v31 = v87;
            do
            {
              unint64_t v34 = *(void *)(v11 + 16);
              v11 += 16;
            }
            while (v16 >= v34);
            do
              unint64_t v35 = *((void *)v31-- - 2);
            while (v16 < v35);
          }
          BOOL v4 = v11 - 16 >= a1;
          BOOL v5 = v11 - 16 == a1;
          if (v11 - 16 != a1) {
            *(_OWORD *)a1 = *(_OWORD *)(v11 - 16);
          }
          a4 = 0;
          *(void *)(v11 - 16) = v16;
          *(void *)(v11 - 8) = v33;
        }
        uint64_t v17 = *(void *)(a1 + 8);
        unint64_t v18 = a1;
        do
        {
          unint64_t v19 = v18;
          unint64_t v20 = *(void *)(v18 + 16);
          v18 += 16;
        }
        while (v20 < v16);
        unint64_t v21 = a2;
        if (v19 == a1)
        {
          unint64_t v21 = a2;
          do
          {
            if (v18 >= (unint64_t)v21) {
              break;
            }
            unint64_t v23 = *(v21 - 2);
            v21 -= 2;
          }
          while (v23 >= v16);
        }
        else
        {
          do
          {
            unint64_t v22 = *(v21 - 2);
            v21 -= 2;
          }
          while (v22 >= v16);
        }
        unint64_t v11 = v18;
        if (v18 < (unint64_t)v21)
        {
          uint64_t v24 = (long long *)v21;
          do
          {
            long long v25 = *(_OWORD *)v11;
            *(_OWORD *)unint64_t v11 = *v24;
            *uint64_t v24 = v25;
            do
            {
              unint64_t v26 = *(void *)(v11 + 16);
              v11 += 16;
            }
            while (v26 < v16);
            do
              unint64_t v27 = *((void *)v24-- - 2);
            while (v27 >= v16);
          }
          while (v11 < (unint64_t)v24);
        }
        if (v11 - 16 != a1) {
          *(_OWORD *)a1 = *(_OWORD *)(v11 - 16);
        }
        *(void *)(v11 - 16) = v16;
        *(void *)(v11 - 8) = v17;
        if (v18 >= (unint64_t)v21) {
          break;
        }
LABEL_30:
        std::__introsort<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *,false>(a1, v11 - 16, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v28 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>(a1, (unint64_t *)(v11 - 16));
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>(v11, a2))
      {
        break;
      }
      if (!v28) {
        goto LABEL_30;
      }
    }
    a2 = (unint64_t *)(v11 - 16);
    if (!v28) {
      continue;
    }
    break;
  }
}

long long *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>(long long *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *a3;
  if (*a2 >= *(void *)result)
  {
    if (v4 < v3)
    {
      long long v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v6;
      if (*a2 < *(void *)result)
      {
        long long v7 = *result;
        void *result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      long long v8 = *result;
      void *result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (*a3 >= *a2) {
        return result;
      }
      long long v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    else
    {
      long long v5 = *result;
      void *result = *(_OWORD *)a3;
    }
    *(_OWORD *)a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>(uint64_t a1, unint64_t *a2)
{
  uint64_t v4 = ((uint64_t)a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      long long v6 = (long long *)(a2 - 2);
      if (*(a2 - 2) < *(void *)a1)
      {
        long long v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *long long v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((long long *)a1, (unint64_t *)(a1 + 16), a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((long long *)a1, (unint64_t *)(a1 + 16), (unint64_t *)(a1 + 32), (_OWORD *)a2 - 1);
      return 1;
    case 5:
      uint64_t v17 = (long long *)(a1 + 16);
      unint64_t v18 = (long long *)(a1 + 32);
      unint64_t v19 = (long long *)(a1 + 48);
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((long long *)a1, (unint64_t *)(a1 + 16), (unint64_t *)(a1 + 32), (_OWORD *)(a1 + 48));
      unint64_t v21 = *(a2 - 2);
      unint64_t v20 = (long long *)(a2 - 2);
      if (v21 < *(void *)(a1 + 48))
      {
        long long v22 = *v19;
        *unint64_t v19 = *v20;
        *unint64_t v20 = v22;
        if (*(void *)v19 < *(void *)v18)
        {
          long long v23 = *v18;
          *unint64_t v18 = *v19;
          *unint64_t v19 = v23;
          if (*(void *)v18 < *(void *)v17)
          {
            long long v24 = *v17;
            *uint64_t v17 = *v18;
            *unint64_t v18 = v24;
            if (*(void *)(a1 + 16) < *(void *)a1)
            {
              long long v25 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *v17;
              *uint64_t v17 = v25;
            }
          }
        }
      }
      return 1;
    default:
      long long v8 = (unint64_t *)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>((long long *)a1, (unint64_t *)(a1 + 16), (unint64_t *)(a1 + 32));
      uint64_t v9 = (unint64_t *)(a1 + 48);
      if ((unint64_t *)(a1 + 48) == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    unint64_t v12 = *v9;
    if (*v9 < *v8)
    {
      unint64_t v13 = v9[1];
      uint64_t v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32) {
          break;
        }
        unint64_t v15 = *(void *)(a1 + v14 + 16);
        v14 -= 16;
        if (v12 >= v15)
        {
          unint64_t v16 = (unint64_t *)(a1 + v14 + 48);
          goto LABEL_13;
        }
      }
      unint64_t v16 = (unint64_t *)a1;
LABEL_13:
      *unint64_t v16 = v12;
      v16[1] = v13;
      if (++v11 == 8) {
        return v9 + 2 == a2;
      }
    }
    long long v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>(long long *a1, unint64_t *a2, unint64_t *a3, _OWORD *a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,objc::SafeRanges::find(unsigned long,unsigned int &)::$_0 &,objc::SafeRanges::Range *>(a1, a2, a3);
  if (*(void *)a4 < *a3)
  {
    __n128 result = *(__n128 *)a3;
    *(_OWORD *)a3 = *a4;
    *a4 = result;
    if (*a3 < *a2)
    {
      __n128 result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      if (*a2 < *(void *)a1)
      {
        __n128 result = (__n128)*a1;
        *a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

ptrdiff_t ivar_getOffset(ptrdiff_t v)
{
  if (v) {
    return **(int **)v;
  }
  return v;
}

const char *__cdecl protocol_getName(Protocol *p)
{
  if (p) {
    return (const char *)protocol_t::demangledName((char **)p);
  }
  else {
    return "nil";
  }
}

Method class_getClassMethod(Class cls, SEL name)
{
  if (!cls || !name) {
    return 0;
  }
  if ((unint64_t)(*(void *)cls - 1) < 0xF
    || (*(unsigned char *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8) & 1) == 0)
  {
    cls = (Class)(*(void *)cls & 0xFFFFFFFF8);
  }
  return class_getInstanceMethod(cls, name);
}

void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  if (offset)
  {
    if (*(id *)((char *)self + offset) != newValue)
    {
      id v6 = newValue;
      long long v7 = *(void **)((char *)self + offset);
      *(void *)((char *)self + offset) = v6;
    }
  }
  else
  {
    object_setClass(self, (Class)newValue);
  }
}

void *class_addMethodsBulk(objc_class *a1, objc_selector **a2, void (**a3)(void), const char **a4, method_list_t *a5, unsigned int *a6)
{
  if (a1)
  {
    int v12 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v12, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v12) {
      os_unfair_lock_lock_with_options();
    }
    uint64_t v14 = addMethods(a1, a2, a3, a4, a5, 0, a6);
    int v15 = *(_DWORD *)(StatusReg + 24);
    int v16 = v15;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v16, 0, memory_order_release, memory_order_relaxed);
    if (v16 != v15) {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
  }
  else
  {
    if (a6) {
      *a6 = a5;
    }
    size_t v17 = 8 * a5;
    uint64_t v14 = malloc_type_malloc(v17, 0x3F84A03uLL);
    memcpy(v14, a2, v17);
  }
  return v14;
}

void sub_180121EFC(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

char *__cdecl method_copyReturnType(char *m)
{
  if (m)
  {
    m = (char *)method_t::types((uint64_t)m);
    if (m)
    {
      int v4 = m;
      size_t v5 = SkipFirstType(m, v1, v2, v3) - m;
      id v6 = (char *)malloc_type_malloc(v5 + 1, 0x8B5561D0uLL);
      m = strncpy(v6, v4, v5);
      m[v5] = 0;
    }
  }
  return m;
}

char *__cdecl method_copyArgumentType(char *m, unsigned int index)
{
  if (m)
  {
    uint64_t v2 = *(void *)&index;
    m = (char *)method_t::types((uint64_t)m);
    uint64_t v10 = m;
    if (m)
    {
      encoding_getArgumentInfo(m, v2, (char *)&v10, v9);
      id v6 = v10;
      if (v10)
      {
        size_t v7 = SkipFirstType(v10, v3, v4, v5) - v6;
        long long v8 = (char *)malloc_type_malloc(v7 + 1, 0x619B5C91uLL);
        m = strncpy(v8, v6, v7);
        m[v7] = 0;
      }
      else
      {
        return 0;
      }
    }
  }
  return m;
}

objc_method_description protocol_getMethodDescription(Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
{
  unint64_t Method = protocol_getMethod((protocol_t *)p, (objc_selector *)aSel, (const char *)isRequiredMethod, (char *)isInstanceMethod, v4);
  if (Method)
  {
    int v7 = Method & 3;
    if ((Method & 3) != 0)
    {
      if (v7 == 2)
      {
        if (*(void *)(Method & 0xFFFFFFFFFFFFFFFCLL)) {
          size_t v5 = *(const char **)(Method & 0xFFFFFFFFFFFFFFFCLL);
        }
        else {
          size_t v5 = 0;
        }
      }
      else if (v7 == 1)
      {
        long long v8 = (int *)(Method & 0xFFFFFFFFFFFFFFFCLL);
        if (dataSegmentsRanges > (Method & 0xFFFFFFFFFFFFFFFCLL) || *(void *)algn_1EB1CB078 <= (unint64_t)v8) {
          size_t v5 = *(const char **)((char *)v8 + *v8);
        }
        else {
          size_t v5 = (char *)&unk_1F62995A8 + *v8;
        }
      }
    }
    else
    {
      size_t v5 = *(const char **)(Method & 0xFFFFFFFFFFFFFFFCLL);
    }
    uint64_t v9 = (char *)method_t::types(Method);
  }
  else
  {
    size_t v5 = 0;
    uint64_t v9 = 0;
  }
  uint64_t v10 = v5;
  result.types = v9;
  result.name = v10;
  return result;
}

unint64_t protocol_getMethod(protocol_t *a1, objc_selector *a2, const char *a3, char *a4, BOOL a5)
{
  if (!a1) {
    return 0;
  }
  int v9 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v9, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v9) {
    os_unfair_lock_lock_with_options();
  }
  if (fixed_up_protocol) {
    int v11 = -1073741824;
  }
  else {
    int v11 = 0x40000000;
  }
  if ((*((_DWORD *)a1 + 17) & 0xC0000000) != v11) {
    fixupProtocol(a1);
  }
  Method_nolocunint64_t k = protocol_getMethod_nolock(a1, a2, a3, a4, a5);
  if (Method_nolock) {
    unint64_t v13 = Method_nolock;
  }
  else {
    unint64_t v13 = 0;
  }
  int v14 = *(_DWORD *)(StatusReg + 24);
  int v15 = v14;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v15, 0, memory_order_release, memory_order_relaxed);
  if (v15 != v14) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return v13;
}

void sub_180122264(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

unint64_t protocol_getMethod_nolock(protocol_t *a1, objc_selector *a2, const char *a3, char *a4, BOOL a5)
{
  unint64_t result = 0;
  if (a1 && a2)
  {
    BOOL v8 = (char)a4;
    BOOL v9 = (char)a3;
    uint64_t v10 = (unint64_t *)((char *)a1 + 48);
    if (a4) {
      uint64_t v10 = (unint64_t *)((char *)a1 + 40);
    }
    int v11 = (unint64_t *)((char *)a1 + 32);
    if (a4) {
      int v11 = (unint64_t *)((char *)a1 + 24);
    }
    if (a3) {
      uint64_t v10 = v11;
    }
    if (!*v10 || (unint64_t result = getMethodFromListArray<method_list_t **>(*v10, a2, a3, a4)) == 0)
    {
      int v12 = (void *)*((void *)a1 + 2);
      if (v12 && *v12)
      {
        uint64_t v13 = 0;
        unsigned int v14 = 1;
        while (1)
        {
          uint64_t v15 = v12[v13 + 1];
          int v16 = canonical_protocol ? 0 : 0x20000000;
          if ((v16 & *(_DWORD *)(v15 + 68)) == 0)
          {
            uint64_t Protocol = getProtocol(*(const char **)(v15 + 8));
            if (Protocol) {
              uint64_t v15 = Protocol;
            }
          }
          unint64_t result = protocol_getMethod_nolock((protocol_t *)v15, a2, v9, v8, a5);
          if (result) {
            break;
          }
          uint64_t v13 = v14;
          int v12 = (void *)*((void *)a1 + 2);
          if (*v12 <= (unint64_t)v14++) {
            return 0;
          }
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

objc_method_description *__cdecl protocol_copyMethodDescriptionList(Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount)
{
  if (p)
  {
    BOOL v5 = isInstanceMethod;
    BOOL v6 = isRequiredMethod;
    int v8 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v8, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v8) {
      os_unfair_lock_lock_with_options();
    }
    if (fixed_up_protocol) {
      int v10 = -1073741824;
    }
    else {
      int v10 = 0x40000000;
    }
    if ((HIDWORD(p[8].super.isa) & 0xC0000000) != v10) {
      fixupProtocol((protocol_t *)p);
    }
    int v11 = p + 6;
    if (v5) {
      int v11 = p + 5;
    }
    int v12 = p + 4;
    if (v5) {
      int v12 = p + 3;
    }
    if (v6) {
      int v11 = v12;
    }
    Class isa = (int *)v11->super.isa;
    if (v11->super.isa)
    {
      unsigned int v14 = (objc_method_description *)malloc_type_calloc((isa[1] + 1), 0x10uLL, 0x90040C859B4A5uLL);
      unint64_t v15 = *isa;
      entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::end(isa, v16, v17, v18);
      uint64_t v21 = v19;
      uint64_t v22 = v15 >> 31;
      if ((uint64_t)isa < 0) {
        uint64_t v22 = 2;
      }
      unint64_t v23 = v22 | (unint64_t)(isa + 2) & 0xFFFFFFFFFFFFFFFCLL;
      if (v23 == v19)
      {
        LODWORD(isa) = 0;
        if (!outCount)
        {
LABEL_36:
          int v33 = *(_DWORD *)(StatusReg + 24);
          int v34 = v33;
          atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v34, 0, memory_order_release, memory_order_relaxed);
          if (v34 != v33) {
            os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
          }
          return v14;
        }
      }
      else
      {
        unint64_t v36 = StatusReg;
        uint64_t v24 = 0;
        LODWORD(isa) = 0;
        uint64_t v25 = (unsigned __int16)v15 & 0xFFFC;
        unint64_t v26 = dataSegmentsRanges;
        unint64_t v27 = *(void *)algn_1EB1CB078;
        do
        {
          uint64_t v28 = v23 + v24;
          int v29 = (v23 + v24) & 3;
          if (v29)
          {
            if (v29 == 2)
            {
              unint64_t v20 = *(const char **)(v28 & 0xFFFFFFFFFFFFFFFCLL);
            }
            else if (v29 == 1)
            {
              unint64_t v30 = v28 & 0xFFFFFFFFFFFFFFFCLL;
              uint64_t v31 = *(int *)(v28 & 0xFFFFFFFFFFFFFFFCLL);
              if (v26 > (v28 & 0xFFFFFFFFFFFFFFFCLL) || v27 <= v30) {
                unint64_t v20 = *(const char **)(v30 + v31);
              }
              else {
                unint64_t v20 = (char *)&unk_1F62995A8 + v31;
              }
            }
          }
          else
          {
            unint64_t v20 = *(const char **)(v28 & 0xFFFFFFFFFFFFFFFCLL);
          }
          unint64_t v32 = &v14[isa];
          v32->name = v20;
          v32->types = (char *)method_t::types(v28);
          LODWORD(isa) = isa + 1;
          v24 += v25;
        }
        while (v23 + v24 != v21);
        unint64_t StatusReg = v36;
        if (!outCount) {
          goto LABEL_36;
        }
      }
    }
    else
    {
      unsigned int v14 = 0;
      if (!outCount) {
        goto LABEL_36;
      }
    }
    *outCount = isa;
    goto LABEL_36;
  }
  unsigned int v14 = 0;
  if (outCount) {
    *outCount = 0;
  }
  return v14;
}

void sub_180122608(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void method_getArgumentType(Method m, unsigned int index, char *dst, size_t dst_len)
{
  if (!m)
  {
    if (!dst) {
      return;
    }
    goto LABEL_11;
  }
  uint64_t v6 = *(void *)&index;
  int v7 = (char *)method_t::types((uint64_t)m);
  unint64_t v18 = v7;
  if (!dst) {
    return;
  }
  if (!v7 || (encoding_getArgumentInfo(v7, v6, (char *)&v18, v17), (int v11 = v18) == 0))
  {
LABEL_11:
    uint64_t v16 = dst;
    size_t v15 = dst_len;
    goto LABEL_12;
  }
  Type = SkipFirstType(v18, v8, v9, v10);
  unint64_t v13 = Type - v11;
  if (Type - v11 >= dst_len) {
    size_t v14 = dst_len;
  }
  else {
    size_t v14 = Type - v11;
  }
  strncpy(dst, v11, v14);
  size_t v15 = dst_len - v13;
  if (dst_len > v13)
  {
    uint64_t v16 = &dst[v13];
LABEL_12:
    bzero(v16, v15);
  }
}

char *encoding_getArgumentInfo(char *a1, uint64_t a2, char *a3, char *a4)
{
  int v6 = a2;
  unint64_t result = (char *)(SkipFirstType(a1, a2, a3, a4) - 1);
  do
  {
    int v12 = *++result;
    int v11 = v12;
  }
  while ((v12 - 48) < 0xA);
  BOOL v15 = v11 == 0;
  int v13 = v11 != 0;
  int v14 = 0;
  BOOL v15 = v15 || v6 == 0;
  if (!v15)
  {
    int v16 = 0;
    do
    {
      Type = SkipFirstType(result, v8, v9, v10);
      unint64_t v18 = Type;
      BOOL v19 = *(unsigned __int8 *)Type == 43;
      if (*Type == 43) {
        unint64_t v20 = (char *)(Type + 1);
      }
      else {
        unint64_t v20 = (char *)Type;
      }
      int v21 = *v20;
      if (v21 == 45) {
        unint64_t result = v20 + 1;
      }
      else {
        unint64_t result = v20;
      }
      if (v16)
      {
        unint64_t result = (char *)&v18[(v21 == 45) - 1 + v19];
        do
        {
          int v23 = *++result;
          int v22 = v23;
        }
        while ((v23 - 48) < 0xA);
      }
      else
      {
        int v24 = *result;
        if ((v24 - 48) > 9)
        {
          int v22 = *result;
        }
        else
        {
          do
          {
            int v25 = *++result;
            int v22 = v25;
            int v14 = v24 + 10 * v14 - 48;
            int v24 = v25;
          }
          while ((v25 - 48) < 0xA);
        }
        if (v21 == 45) {
          int v14 = -v14;
        }
      }
      ++v16;
      BOOL v15 = v22 == 0;
      int v13 = v22 != 0;
    }
    while (!v15 && v16 != v6);
  }
  if (v13)
  {
    *(void *)a3 = result;
    unint64_t result = (char *)SkipFirstType(result, v8, v9, v10);
    if (v6)
    {
      int v27 = *result;
      BOOL v28 = v27 == 43;
      if (v27 == 43) {
        int v29 = result + 1;
      }
      else {
        int v29 = result;
      }
      int v30 = *v29;
      if (v30 == 45) {
        ++v29;
      }
      int v31 = *v29;
      if ((v31 - 48) > 9)
      {
        int v32 = 0;
      }
      else
      {
        int v32 = 0;
        int v33 = &result[(v30 == 45) + 1 + v28];
        do
        {
          int v32 = v31 + 10 * v32 - 48;
          int v34 = *v33++;
          int v31 = v34;
        }
        while ((v34 - 48) < 0xA);
      }
      if (v30 == 45) {
        int v35 = -v32;
      }
      else {
        int v35 = v32;
      }
      int v13 = v35 - v14;
    }
    else
    {
      int v13 = 0;
    }
  }
  else
  {
    *(void *)a3 = 0;
  }
  *(_DWORD *)a4 = v13;
  return result;
}

unsigned int method_getNumberOfArguments(Method m)
{
  if (!m) {
    return 0;
  }
  uint64_t v1 = (char *)method_t::types((uint64_t)m);
  int v5 = (char *)(SkipFirstType(v1, v2, v3, v4) - 1);
  do
  {
    int v10 = *++v5;
    int v9 = v10;
  }
  while ((v10 - 48) < 0xA);
  if (!v9) {
    return 0;
  }
  unsigned int v11 = 0;
  do
  {
    Type = SkipFirstType(v5, v6, v7, v8);
    int v13 = Type + 1;
    int v14 = *(unsigned __int8 *)Type;
    if (v14 != 43) {
      int v13 = Type;
    }
    uint64_t v15 = *(unsigned __int8 *)v13 == 45;
    if (v14 == 43) {
      ++v15;
    }
    int v5 = (char *)&Type[v15 - 1];
    do
    {
      int v17 = *++v5;
      int v16 = v17;
    }
    while ((v17 - 48) < 0xA);
    ++v11;
  }
  while (v16);
  return v11;
}

const char *SkipFirstType(char *a1, uint64_t a2, const char *a3, char *a4)
{
  do
  {
    int v5 = a1;
    int v7 = *a1++;
    int v6 = v7;
    uint64_t v8 = (v7 - 78);
    if (v8 > 0x2D) {
      goto LABEL_8;
    }
  }
  while (((1 << v8) & 0x1300010103) != 0);
  if (v8 == 13)
  {
    do
      int v11 = *++v5;
    while ((v11 - 48) < 0xA);
    int v12 = &v5[(int)SubtypeUntil(v5, 93, a3, a4)];
    return v12 + 1;
  }
  if (v8 == 45)
  {
    int v9 = a1;
    uint64_t v10 = 125;
LABEL_14:
    int v12 = &a1[(int)SubtypeUntil(v9, v10, a3, a4)];
    return v12 + 1;
  }
LABEL_8:
  if (v6 == 40)
  {
    int v9 = a1;
    uint64_t v10 = 41;
    goto LABEL_14;
  }
  if (v6 != 64) {
    return v5 + 1;
  }
  if (v5[1] == 63) {
    return v5 + 2;
  }
  return a1;
}

void method_getReturnType(Method m, char *dst, size_t dst_len)
{
  if (!m)
  {
    if (!dst) {
      return;
    }
    goto LABEL_10;
  }
  int v5 = (char *)method_t::types((uint64_t)m);
  if (!dst) {
    return;
  }
  int v9 = v5;
  if (!v5)
  {
LABEL_10:
    int v14 = dst;
    size_t v13 = dst_len;
    goto LABEL_11;
  }
  Type = SkipFirstType(v5, v6, v7, v8);
  unint64_t v11 = Type - v9;
  if (Type - v9 >= dst_len) {
    size_t v12 = dst_len;
  }
  else {
    size_t v12 = Type - v9;
  }
  strncpy(dst, v9, v12);
  size_t v13 = dst_len - v11;
  if (dst_len > v11)
  {
    int v14 = &dst[v11];
LABEL_11:
    bzero(v14, v13);
  }
}

uint64_t method_t::types(uint64_t this)
{
  int v1 = this & 3;
  if ((this & 3) == 0) {
    return *(void *)((this & 0xFFFFFFFFFFFFFFFCLL) + 8);
  }
  if (v1 == 2)
  {
    if (*(void *)((this & 0xFFFFFFFFFFFFFFFCLL) + 8)) {
      return *(void *)((this & 0xFFFFFFFFFFFFFFFCLL) + 8);
    }
    else {
      return 0;
    }
  }
  else if (v1 == 1)
  {
    uint64_t v2 = *(int *)((this & 0xFFFFFFFFFFFFFFFCLL) + 4);
    if (v2) {
      return v2 + (this & 0xFFFFFFFFFFFFFFFCLL) + 4;
    }
    else {
      return 0;
    }
  }
  return this;
}

void *addMethods(objc_class *a1, objc_selector **a2, void (**a3)(void), const char **a4, method_list_t *this, char a6, unsigned int *a7)
{
  unsigned int v8 = this;
  int v9 = a4;
  uint64_t v10 = a3;
  MethodList = method_list_t::allocateMethodList(this, 3, (const char *)a3, (char *)a4);
  int v16 = MethodList;
  MethodList[1] = 0;
  if (v8)
  {
    unint64_t v36 = a7;
    uint64_t v17 = 0;
    unint64_t v18 = 0;
    uint64_t v19 = v8;
    unint64_t v37 = *(void *)algn_1EB1CB078;
    unint64_t v38 = dataSegmentsRanges;
    size_t size = v8 + 1;
    long long v41 = MethodList;
    unint64_t v42 = a1;
    do
    {
      unint64_t MethodNoSuper_nolock = getMethodNoSuper_nolock(a1, *a2, v14, v15);
      if (MethodNoSuper_nolock)
      {
        unint64_t v23 = MethodNoSuper_nolock;
        if (a6)
        {
          _method_setImplementation(a1, MethodNoSuper_nolock, *v10);
        }
        else
        {
          if (!v18) {
            unint64_t v18 = malloc_type_calloc(8uLL, size, 0x95961078uLL);
          }
          int v31 = v23 & 3;
          if ((v23 & 3) != 0)
          {
            if (v31 == 2)
            {
              int v22 = *(char **)(v23 & 0xFFFFFFFFFFFFFFFCLL);
            }
            else if (v31 == 1)
            {
              unint64_t v32 = v23 & 0xFFFFFFFFFFFFFFFCLL;
              uint64_t v33 = *(int *)(v23 & 0xFFFFFFFFFFFFFFFCLL);
              if (v38 > (v23 & 0xFFFFFFFFFFFFFFFCLL) || v37 <= v32) {
                int v22 = *(char **)(v32 + v33);
              }
              else {
                int v22 = (char *)&unk_1F62995A8 + v33;
              }
            }
          }
          else
          {
            int v22 = *(char **)(v23 & 0xFFFFFFFFFFFFFFFCLL);
          }
          v18[v17] = v22;
          uint64_t v17 = (v17 + 1);
        }
      }
      else
      {
        entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::end(v16, v21, v14, v15);
        unint64_t v25 = v24 & 0xFFFFFFFFFFFFFFFCLL;
        *(void *)(v24 & 0xFFFFFFFFFFFFFFFCLL) = *a2;
        unint64_t v26 = *v9;
        size_t v27 = strlen(*v9) + 1;
        if ((_dyld_is_memory_immutable() & 1) == 0)
        {
          long long v40 = v18;
          uint64_t v28 = v17;
          int v29 = malloc_type_malloc(v27, 0x3F84A03uLL);
          memcpy(v29, v26, v27);
          unint64_t v26 = (const char *)v29;
          uint64_t v17 = v28;
          unint64_t v18 = v40;
        }
        int v16 = v41;
        if (v26) {
          int v30 = v26;
        }
        else {
          int v30 = 0;
        }
        *(void *)(v25 + 8) = v30;
        int v34 = (void (**)(void))(v25 + 16);
        a1 = v42;
        *int v34 = *v10;
        ++v41[1];
      }
      ++v10;
      ++v9;
      ++a2;
      --v19;
    }
    while (v19);
    if (v16[1])
    {
      addMethods_finish(a1, (method_list_t *)v16);
      a7 = v36;
      if (!v36) {
        return v18;
      }
      goto LABEL_31;
    }
    a7 = v36;
  }
  else
  {
    LODWORD(v17) = 0;
    unint64_t v18 = 0;
  }
  free((void *)((unint64_t)v16 & 0xFFFFFFFFFFFFFFFLL));
  if (a7) {
LABEL_31:
  }
    *a7 = v17;
  return v18;
}

unint64_t entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::end(int *a1, uint64_t a2, const char *a3, char *a4)
{
  int v5 = *a1;
  uint64_t v4 = a1[1];
  if (((v4 * (unint64_t)(*a1 & 0xFFFC)) & 0xFFFFFFFF00000000) != 0) {
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v4, a1, v5 & 0xFFFC);
  }
  return (unsigned __int16)v5 & 0xFFFC | (unint64_t)(v4 << 32);
}

_DWORD *method_list_t::allocateMethodList(method_list_t *this, uint64_t a2, const char *a3, char *a4)
{
  int v4 = (int)this;
  uint64_t v5 = 24 * this;
  if ((v5 & 0xFFFFFFFF00000000) != 0) {
    _objc_fatal("entsize_list_tt overflow: count %u with entsize %u", a2, a3, a4, 24, this);
  }
  int v6 = a2;
  unint64_t result = (_DWORD *)((unint64_t)malloc_type_calloc(v5 + 8, 1uLL, 0xB48A38ECuLL) | 0x8000000000000000);
  _DWORD *result = v6 | 0x18;
  result[1] = v4;
  return result;
}

uint64_t SubtypeUntil(char *a1, uint64_t a2, const char *a3, char *a4)
{
  char v4 = *a1;
  if (!*a1) {
LABEL_16:
  }
    _objc_fatal("Object: SubtypeUntil: end of type encountered prematurely\n", a2, a3, a4);
  int v5 = 0;
  int v6 = a1;
  while (v5 || v4 != a2)
  {
    if (v4 <= 92)
    {
      if (v4 == 40) {
        goto LABEL_14;
      }
      if (v4 != 41)
      {
        if (v4 != 91) {
          goto LABEL_15;
        }
LABEL_14:
        ++v5;
        goto LABEL_15;
      }
LABEL_13:
      --v5;
      goto LABEL_15;
    }
    switch(v4)
    {
      case '}':
        goto LABEL_13;
      case '{':
        goto LABEL_14;
      case ']':
        goto LABEL_13;
    }
LABEL_15:
    int v7 = *(unsigned __int8 *)++v6;
    char v4 = v7;
    if (!v7) {
      goto LABEL_16;
    }
  }
  return (v6 - a1);
}

void fixupProtocol(protocol_t *a1)
{
  uint64_t v2 = (unint64_t *)*((void *)a1 + 2);
  if (v2 && *v2)
  {
    unint64_t v3 = 0;
    do
    {
      uint64_t v4 = v2[v3 + 1];
      int v5 = *(_DWORD *)(v4 + 68);
      if (canonical_protocol) {
        int v6 = 0;
      }
      else {
        int v6 = 0x20000000;
      }
      if ((v6 & v5) == 0)
      {
        uint64_t Protocol = getProtocol(*(const char **)(v4 + 8));
        if (Protocol) {
          uint64_t v4 = Protocol;
        }
        int v5 = *(_DWORD *)(v4 + 68);
      }
      unsigned int v8 = v5 & 0xC0000000;
      if (fixed_up_protocol) {
        int v9 = -1073741824;
      }
      else {
        int v9 = 0x40000000;
      }
      if (v8 != v9) {
        fixupProtocol((protocol_t *)v4);
      }
      ++v3;
      uint64_t v2 = (unint64_t *)*((void *)a1 + 2);
    }
    while (v3 < *v2);
  }
  fixupProtocolMethodList(a1, *((void *)a1 + 3), 1, (char *)1);
  fixupProtocolMethodList(a1, *((void *)a1 + 4), 1, 0);
  fixupProtocolMethodList(a1, *((void *)a1 + 5), 0, (char *)1);
  fixupProtocolMethodList(a1, *((void *)a1 + 6), 0, 0);
  if (fixed_up_protocol) {
    int v10 = -1073741824;
  }
  else {
    int v10 = 0x40000000;
  }
  *((_DWORD *)a1 + 17) = v10 | *((_DWORD *)a1 + 17) & 0x3FFFFFFF;
}

void fixupProtocolMethodList(protocol_t *a1, uint64_t a2, int a3, char *a4)
{
  if (a2 && (~*(_DWORD *)a2 & 3) != 0)
  {
    int v6 = (uint64_t *)((char *)a1 + 72);
    if ((char *)a1 + *((unsigned int *)a1 + 16) <= (char *)a1 + 72)
    {
      fixupMethodList(a2, 1, (const char *)1, a4);
    }
    else
    {
      int v7 = (int)a4;
      uint64_t v9 = *v6;
      fixupMethodList(a2, 1, (const char *)(*v6 == 0), a4);
      if (v9 && (a2 < 0 || (*(_DWORD *)a2 & 0x80000000) == 0))
      {
        unint64_t v12 = *(unsigned int *)(a2 + 4);
        int v30 = 0;
        unint64_t v13 = entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::get((unsigned int *)a2, 0, v10, v11);
        getExtendedTypesIndexesForMethod(a1, v13, a3, v7, &v30, &v29);
        if (v12)
        {
          uint64_t v16 = 0;
          uint64_t v17 = 1;
          int v18 = v30;
          do
          {
            uint64_t v28 = v16 + 1;
            if (v16 + 1 < v12)
            {
              uint64_t v19 = (v18 + v16);
              uint64_t v20 = v17;
              do
              {
                unint64_t v21 = entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::get((unsigned int *)a2, v16, v14, v15) & 0xFFFFFFFFFFFFFFFCLL;
                unint64_t v24 = entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::get((unsigned int *)a2, v20, v22, v23) & 0xFFFFFFFFFFFFFFFCLL;
                if (*(void *)v21 > *(void *)v24)
                {
                  long long v31 = *(_OWORD *)v21;
                  if (*(void *)(v21 + 16)) {
                    uint64_t v25 = *(void *)(v21 + 16);
                  }
                  else {
                    uint64_t v25 = 0;
                  }
                  *(_OWORD *)unint64_t v21 = *(_OWORD *)v24;
                  *(void *)(v21 + 16) = *(void *)(v24 + 16);
                  *(_OWORD *)unint64_t v24 = v31;
                  if (v25) {
                    uint64_t v26 = v25;
                  }
                  else {
                    uint64_t v26 = 0;
                  }
                  *(void *)(v24 + 16) = v26;
                  uint64_t v27 = *(void *)(v9 + 8 * v19);
                  *(void *)(v9 + 8 * v19) = *(void *)(v9 + 8 * (v18 + v20));
                  *(void *)(v9 + 8 * (v18 + v20)) = v27;
                }
                uint64_t v20 = (v20 + 1);
              }
              while (v12 != v20);
            }
            uint64_t v17 = (v17 + 1);
            ++v16;
          }
          while (v28 != v12);
        }
      }
    }
  }
}

uint64_t _protocol_getMethodTypeEncoding(protocol_t *a1, objc_selector *a2, const char *a3, char *a4)
{
  if (!a1) {
    return 0;
  }
  int v8 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v8, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v8) {
    os_unfair_lock_lock_with_options();
  }
  if (fixed_up_protocol) {
    int v10 = -1073741824;
  }
  else {
    int v10 = 0x40000000;
  }
  if ((*((_DWORD *)a1 + 17) & 0xC0000000) != v10) {
    fixupProtocol(a1);
  }
  MethodTypeEncoding_nolocunint64_t k = protocol_getMethodTypeEncoding_nolock((uint64_t)a1, a2, a3, a4);
  int v12 = *(_DWORD *)(StatusReg + 24);
  int v13 = v12;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v13, 0, memory_order_release, memory_order_relaxed);
  if (v13 != v12) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return MethodTypeEncoding_nolock;
}

void sub_180123480(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

uint64_t protocol_getMethodTypeEncoding_nolock(uint64_t result, objc_selector *a2, const char *a3, char *a4)
{
  if (result)
  {
    int v4 = (int)a4;
    int v5 = (int)a3;
    int v7 = (void *)result;
    if ((unint64_t)*(unsigned int *)(result + 64) + result <= result + 72 || !a2 || !*(void *)(result + 72)) {
      goto LABEL_14;
    }
    int v8 = (unint64_t *)(result + 48);
    if (a4) {
      int v8 = (unint64_t *)(result + 40);
    }
    uint64_t v9 = (unint64_t *)(result + 32);
    if (a4) {
      uint64_t v9 = (unint64_t *)(result + 24);
    }
    if (a3) {
      int v8 = v9;
    }
    if (*v8 && (unint64_t MethodFromList = getMethodFromListArray<method_list_t **>(*v8, a2, a3, a4)) != 0)
    {
      uint64_t v16 = 0;
      getExtendedTypesIndexesForMethod(v7, MethodFromList, v5, v4, (_DWORD *)&v16 + 1, &v16);
      return *(void *)(v7[9] + 8 * (v16 + HIDWORD(v16)));
    }
    else
    {
LABEL_14:
      unint64_t v11 = (unint64_t *)v7[2];
      if (v11 && *v11)
      {
        unint64_t v12 = 0;
        while (1)
        {
          uint64_t v13 = v11[v12 + 1];
          int v14 = canonical_protocol ? 0 : 0x20000000;
          if ((v14 & *(_DWORD *)(v13 + 68)) == 0)
          {
            uint64_t Protocol = getProtocol(*(const char **)(v13 + 8));
            if (Protocol) {
              uint64_t v13 = Protocol;
            }
          }
          unint64_t result = protocol_getMethodTypeEncoding_nolock((protocol_t *)v13, a2, v5, v4);
          if (result) {
            break;
          }
          ++v12;
          unint64_t v11 = (unint64_t *)v7[2];
          if (v12 >= *v11) {
            return 0;
          }
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

void *getExtendedTypesIndexesForMethod(void *result, uint64_t a2, int a3, int a4, _DWORD *a5, _DWORD *a6)
{
  *a5 = 0;
  int v6 = (_DWORD *)result[3];
  if (v6)
  {
    if (a3 && a4)
    {
      unint64_t v7 = (a2 - (uint64_t)v6) / (unint64_t)((unsigned __int16)*v6 & 0xFFFC);
LABEL_18:
      *a6 = v7;
      return result;
    }
    LODWORD(v6) = v6[1];
    *a5 = v6;
  }
  int v8 = (_DWORD *)result[4];
  if (v8)
  {
    if (a3 && (a4 & 1) == 0) {
      goto LABEL_17;
    }
    LODWORD(v6) = v6 + v8[1];
    *a5 = v6;
  }
  int v8 = (_DWORD *)result[5];
  if (!v8) {
    goto LABEL_14;
  }
  if (a4 && (a3 & 1) == 0)
  {
LABEL_17:
    unint64_t v7 = (a2 - (uint64_t)v8) / (unint64_t)((unsigned __int16)*v8 & 0xFFFC);
    goto LABEL_18;
  }
  LODWORD(v6) = v6 + v8[1];
  *a5 = v6;
LABEL_14:
  int v8 = (_DWORD *)result[6];
  if (!v8) {
    return result;
  }
  if ((a3 & 1) == 0 && (a4 & 1) == 0) {
    goto LABEL_17;
  }
  *a5 = v6 + v8[1];
  return result;
}

unint64_t entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::get(unsigned int *a1, uint64_t a2, const char *a3, char *a4)
{
  unint64_t v4 = *a1;
  unint64_t v5 = a2 * (unint64_t)((unsigned __int16)v4 & 0xFFFC);
  if ((v5 & 0xFFFFFFFF00000000) != 0) {
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, a2, a1, v4 & 0xFFFC);
  }
  uint64_t v6 = v4 >> 31;
  if ((uint64_t)a1 < 0) {
    uint64_t v6 = 2;
  }
  return ((unint64_t)a1 + v5 + 8) & 0xFFFFFFFFFFFFFFFCLL | v6;
}

void fixupMethodList(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  if (*(_DWORD *)(a1 + 4))
  {
    int v4 = (int)a3;
    if ((*(int *)a1 >= 0 || a1 <= -1) && (*(_DWORD *)a1 & 1) == 0)
    {
      int v8 = a2;
      int v29 = (int)a3;
      int v9 = 0;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      atomic_compare_exchange_strong_explicit(&selLock, (unsigned int *)&v9, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
      if (v9) {
        os_unfair_lock_lock_with_options();
      }
      unint64_t v10 = *(unsigned int *)a1;
      entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::end((int *)a1, a2, a3, a4);
      uint64_t v11 = a2;
      uint64_t v12 = v10 >> 31;
      if (a1 < 0) {
        uint64_t v12 = 2;
      }
      unint64_t v13 = v12 | (a1 + 8) & 0xFFFFFFFFFFFFFFFCLL;
      if (v13 != a2)
      {
        uint64_t v14 = 0;
        uint64_t v15 = (unsigned __int16)v10 & 0xFFFC;
        unint64_t v16 = dataSegmentsRanges;
        unint64_t v17 = *(void *)algn_1EB1CB078;
        do
        {
          uint64_t v18 = v13 + v14;
          int v19 = (v13 + v14) & 3;
          if (v19)
          {
            if (v19 == 2)
            {
              if (*(void *)(v18 & 0xFFFFFFFFFFFFFFFCLL)) {
                uint64_t v20 = *(char **)(v18 & 0xFFFFFFFFFFFFFFFCLL);
              }
              else {
                uint64_t v20 = 0;
              }
            }
            else
            {
              unint64_t v21 = v18 & 0xFFFFFFFFFFFFFFFCLL;
              uint64_t v22 = *(int *)(v18 & 0xFFFFFFFFFFFFFFFCLL);
              if (v16 <= (v18 & 0xFFFFFFFFFFFFFFFCLL) && v17 > v21) {
                uint64_t v20 = (char *)&unk_1F62995A8 + v22;
              }
              else {
                uint64_t v20 = *(char **)(v21 + v22);
              }
            }
          }
          else
          {
            uint64_t v20 = *(char **)(v18 & 0xFFFFFFFFFFFFFFFCLL);
          }
          unint64_t v24 = __sel_registerName(v20, 0, v8);
          if (v19)
          {
            if (v19 == 2)
            {
              if (v24) {
                uint64_t v25 = v24;
              }
              else {
                uint64_t v25 = 0;
              }
              *(void *)(v18 & 0xFFFFFFFFFFFFFFFCLL) = v25;
            }
            else if (v19 == 1)
            {
              *(void *)((v18 & 0xFFFFFFFFFFFFFFFCLL) + *(int *)(v18 & 0xFFFFFFFFFFFFFFFCLL)) = v24;
            }
          }
          else
          {
            *(void *)(v18 & 0xFFFFFFFFFFFFFFFCLL) = v24;
          }
          v14 += v15;
        }
        while (v13 + v14 != v11);
      }
      int v26 = *(_DWORD *)(StatusReg + 24);
      int v27 = v26;
      atomic_compare_exchange_strong_explicit(&selLock, (unsigned int *)&v27, 0, memory_order_release, memory_order_relaxed);
      int v4 = v29;
      if (v27 != v26) {
        os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
      }
    }
    int v28 = *(_DWORD *)a1;
    if (v4)
    {
      if ((a1 & 0x8000000000000000) == 0 && v28 < 0) {
        return;
      }
      if ((*(_DWORD *)a1 & 0xFFFC) == 0x18)
      {
        method_list_t::sortBySELAddress((method_list_t *)a1, a2, a3, a4);
        int v28 = *(_DWORD *)a1;
      }
    }
    if (a1 < 0 || (v28 & 0x80000000) == 0) {
      *(_DWORD *)a1 = v28 | 3;
    }
  }
}

void sub_180123984(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v12 = *(_DWORD *)(a11 + 24);
  int v13 = v12;
  atomic_compare_exchange_strong_explicit(&selLock, (unsigned int *)&v13, 0, memory_order_release, memory_order_relaxed);
  if (v13 != v12) {
    os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
  }
  _Unwind_Resume(exception_object);
}

void method_list_t::sortBySELAddress(method_list_t *this, uint64_t a2, const char *a3, char *a4)
{
  if (((unint64_t)this & 0x8000000000000000) != 0)
  {
    int v12 = (uint64_t *)(((unint64_t)this + 8) & 0xFFFFFFFFFFFFFFFCLL);
    entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::end((int *)this, a2, a3, a4);
    uint64_t v14 = (uint64_t *)(v13 & 0xFFFFFFFFFFFFFFFCLL);
    uint64_t v15 = (v13 & 0xFFFFFFFFFFFFFFFCLL) - (void)v12;
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * (v15 >> 3);
    if (v15 < 1)
    {
LABEL_12:
      std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::bigSigned *>(v12, v14, (uint64_t)&v21, v16, 0, 0);
      return;
    }
    unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * (v15 >> 3);
    while (1)
    {
      uint64_t v18 = (unint64_t *)malloc_type_malloc(24 * v17, 0xECB36C86uLL);
      if (v18) {
        break;
      }
      BOOL v11 = v17 > 1;
      v17 >>= 1;
      if (!v11) {
        goto LABEL_12;
      }
    }
    int v19 = v18;
    std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::bigSigned *>(v12, v14, (uint64_t)&v21, v16, v18, v17);
  }
  else
  {
    if ((*(_DWORD *)this & 0x80000000) != 0) {
      _objc_fatal("Cannot sort small method list %p", a2, a3, a4, this);
    }
    unint64_t v4 = ((unint64_t)this + 8) & 0xFFFFFFFFFFFFFFFCLL;
    entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::end((int *)this, a2, a3, a4);
    uint64_t v6 = (char *)(v5 & 0xFFFFFFFFFFFFFFFCLL);
    uint64_t v7 = (v5 & 0xFFFFFFFFFFFFFFFCLL) - v4;
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (v7 >> 3);
    if (v7 < 1)
    {
LABEL_7:
      std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(v4, v6, (uint64_t)&v20, v8, 0, 0);
      return;
    }
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (v7 >> 3);
    while (1)
    {
      unint64_t v10 = (unint64_t *)malloc_type_malloc(24 * v9, 0xECB36C86uLL);
      if (v10) {
        break;
      }
      BOOL v11 = v9 > 1;
      v9 >>= 1;
      if (!v11) {
        goto LABEL_7;
      }
    }
    int v19 = v10;
    std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(v4, v6, (uint64_t)&v20, v8, (uint64_t)v10, v9);
  }
  free(v19);
}

uint64_t *std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::bigSigned *>(uint64_t *result, uint64_t *a2, uint64_t a3, unint64_t a4, unint64_t *a5, uint64_t a6)
{
  if (a4 < 2) {
    return result;
  }
  uint64_t v7 = result;
  if (a4 == 2)
  {
    if (*(a2 - 3)) {
      unint64_t v8 = *(a2 - 3);
    }
    else {
      unint64_t v8 = 0;
    }
    if (v8 < *result)
    {
      return std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<method_t::bigSigned *&,method_t::bigSigned *&>(result, a2 - 3);
    }
    return result;
  }
  if ((uint64_t)a4 <= 0)
  {
    if (result == a2) {
      return result;
    }
    unint64_t v16 = result + 3;
    if (result + 3 == a2) {
      return result;
    }
    unint64_t v17 = 0;
    uint64_t v18 = result;
    while (1)
    {
      int v19 = v16;
      uint64_t v20 = v18[3];
      if (v20) {
        unint64_t v21 = v18[3];
      }
      else {
        unint64_t v21 = 0;
      }
      if (v21 < *v18)
      {
        if (v20) {
          uint64_t v22 = v18[3];
        }
        else {
          uint64_t v22 = 0;
        }
        uint64_t v49 = v22;
        uint64_t v50 = v18[4];
        uint64_t v51 = v18[5];
        uint64_t v23 = *v18;
        unint64_t v24 = v17;
        while (1)
        {
          unint64_t result = v24;
          uint64_t v25 = (uint64_t *)((char *)v24 + (void)v7);
          uint64_t v26 = v23 ? v23 : 0;
          v25[3] = v26;
          v25[4] = v25[1];
          *(uint64_t *)((char *)v24 + (void)v7 + 40) = *(uint64_t *)((char *)v24 + (void)v7 + 16);
          if (!v24) {
            break;
          }
          if (v49) {
            unint64_t v27 = v49;
          }
          else {
            unint64_t v27 = 0;
          }
          uint64_t v23 = *(uint64_t *)((char *)v24 + (void)v7 - 24);
          if (v23) {
            unint64_t v28 = *(uint64_t *)((char *)v24 + (void)v7 - 24);
          }
          else {
            unint64_t v28 = 0;
          }
          v24 -= 3;
          if (v27 >= v28)
          {
            int v29 = (uint64_t *)((char *)result + (void)v7);
            int v30 = (uint64_t *)((char *)result + (void)v7 + 16);
            long long v31 = (uint64_t *)((char *)result + (void)v7 + 8);
            if (v49) {
              goto LABEL_39;
            }
LABEL_41:
            uint64_t v32 = 0;
            goto LABEL_42;
          }
        }
        int v30 = v7 + 2;
        long long v31 = v7 + 1;
        int v29 = v7;
        if (!v49) {
          goto LABEL_41;
        }
LABEL_39:
        uint64_t v32 = v49;
LABEL_42:
        *int v29 = v32;
        *long long v31 = v50;
        *int v30 = v51;
      }
      unint64_t v16 = v19 + 3;
      v17 += 3;
      uint64_t v18 = v19;
      if (v19 + 3 == a2) {
        return result;
      }
    }
  }
  BOOL v11 = a5;
  unint64_t v13 = a4 >> 1;
  uint64_t v14 = (unint64_t *)&result[3 * (a4 >> 1)];
  unint64_t v15 = a4 >> 1;
  if ((uint64_t)a4 > a6)
  {
    std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::bigSigned *>(result, v14, a3, v15, a5, a6);
    std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::bigSigned *>(&v7[3 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), v11, a6);
    return std::__inplace_merge<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::bigSigned *>(v7, &v7[3 * (a4 >> 1)], a2, a3, a4 >> 1, a4 - (a4 >> 1), v11, a6);
  }
  std::__stable_sort_move<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::bigSigned *>((unint64_t *)result, v14, a3, v15, a5);
  uint64_t v33 = &v11[3 * v13];
  unint64_t result = (uint64_t *)std::__stable_sort_move<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::bigSigned *>((unint64_t *)&v7[3 * (a4 >> 1)], (unint64_t *)a2, a3, a4 - (a4 >> 1), v33);
  uint64_t v34 = 0;
  int v35 = &v11[3 * a4];
  unint64_t v36 = v33;
  while (v36 != v35)
  {
    if (*v36) {
      unint64_t v37 = *v36;
    }
    else {
      unint64_t v37 = 0;
    }
    if (*v11)
    {
      if (v37 < *v11)
      {
        if (*v36) {
          uint64_t v38 = *v36;
        }
        else {
          uint64_t v38 = 0;
        }
        long long v41 = &v7[v34];
        v7[v34] = v38;
        v41[1] = v36[1];
        v41[2] = v36[2];
        v36 += 3;
        goto LABEL_59;
      }
      unint64_t v39 = *v11;
    }
    else
    {
      unint64_t v39 = 0;
    }
    long long v40 = &v7[v34];
    v7[v34] = v39;
    v40[1] = v11[1];
    v40[2] = v11[2];
    v11 += 3;
LABEL_59:
    v34 += 3;
    if (v11 == v33)
    {
      if (v36 != v35)
      {
        uint64_t v42 = 0;
        unint64_t v43 = &v7[v34];
        do
        {
          BOOL v44 = &v36[v42];
          v43[v42] = v36[v42];
          v7[v42 + 1 + v34] = v36[v42 + 1];
          v43[v42 + 2] = v36[v42 + 2];
          v42 += 3;
        }
        while (v44 + 3 != v35);
      }
      return result;
    }
  }
  if (v11 != v33)
  {
    uint64_t v45 = 0;
    uint64_t v46 = &v7[v34];
    unint64_t v47 = &v7[v34];
    do
    {
      unint64_t v48 = &v11[v45];
      v46[v45] = v11[v45];
      v7[v45 + 1 + v34] = v11[v45 + 1];
      v46[v45 + 2] = v11[v45 + 2];
      v47 += 3;
      v45 += 3;
    }
    while (v48 + 3 != v33);
  }
  return result;
}

unint64_t *std::__stable_sort_move<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::bigSigned *>(unint64_t *result, unint64_t *a2, uint64_t a3, unint64_t a4, unint64_t *a5)
{
  if (!a4) {
    return result;
  }
  unint64_t v8 = result;
  if (a4 == 2)
  {
    uint64_t v10 = *(a2 - 3);
    if (v10) {
      unint64_t v11 = *(a2 - 3);
    }
    else {
      unint64_t v11 = 0;
    }
    if (*result)
    {
      if (v11 < *result)
      {
        if (v10) {
          unint64_t v40 = *(a2 - 3);
        }
        else {
          unint64_t v40 = 0;
        }
        *a5 = v40;
        a5[1] = *(a2 - 2);
        a5[2] = *(a2 - 1);
        a5[3] = *result;
        a5[4] = result[1];
        unint64_t v9 = a5 + 5;
        goto LABEL_69;
      }
      unint64_t v41 = *result;
    }
    else
    {
      unint64_t v41 = 0;
    }
    *a5 = v41;
    a5[1] = result[1];
    a5[2] = result[2];
    a5[3] = *(a2 - 3);
    a5[4] = *(a2 - 2);
    unint64_t v9 = a5 + 5;
    unint64_t v42 = *(a2 - 1);
LABEL_70:
    *unint64_t v9 = v42;
    return result;
  }
  if (a4 == 1)
  {
    *a5 = *result;
    a5[1] = result[1];
    unint64_t v9 = a5 + 2;
LABEL_69:
    unint64_t v42 = result[2];
    goto LABEL_70;
  }
  if ((uint64_t)a4 > 8)
  {
    int v29 = &result[3 * (a4 >> 1)];
    std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::bigSigned *>(result, v29, a3, a4 >> 1, a5, a4 >> 1);
    unint64_t result = (unint64_t *)std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::bigSigned *>(&v8[3 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), &a5[3 * (a4 >> 1)], a4 - (a4 >> 1));
    uint64_t v30 = 0;
    long long v31 = &v8[3 * (a4 >> 1)];
    while (1)
    {
      if (v31 == a2)
      {
        if (v8 != v29)
        {
          uint64_t v43 = 0;
          BOOL v44 = &a5[v30];
          uint64_t v45 = &a5[v30];
          do
          {
            uint64_t v46 = &v8[v43];
            v44[v43] = v8[v43];
            a5[v43 + 1 + v30] = v8[v43 + 1];
            v44[v43 + 2] = v8[v43 + 2];
            v45 += 3;
            v43 += 3;
          }
          while (v46 + 3 != v29);
        }
        return result;
      }
      if (*v31) {
        unint64_t v32 = *v31;
      }
      else {
        unint64_t v32 = 0;
      }
      if (*v8)
      {
        if (v32 < *v8)
        {
          if (*v31) {
            unint64_t v33 = *v31;
          }
          else {
            unint64_t v33 = 0;
          }
          unint64_t v36 = &a5[v30];
          a5[v30] = v33;
          v36[1] = v31[1];
          v36[2] = v31[2];
          v31 += 3;
          goto LABEL_50;
        }
        unint64_t v34 = *v8;
      }
      else
      {
        unint64_t v34 = 0;
      }
      int v35 = &a5[v30];
      a5[v30] = v34;
      v35[1] = v8[1];
      v35[2] = v8[2];
      v8 += 3;
LABEL_50:
      v30 += 3;
      if (v8 == v29)
      {
        if (v31 != a2)
        {
          uint64_t v37 = 0;
          uint64_t v38 = &a5[v30];
          do
          {
            unint64_t v39 = &v31[v37];
            v38[v37] = v31[v37];
            a5[v37 + 1 + v30] = v31[v37 + 1];
            v38[v37 + 2] = v31[v37 + 2];
            v37 += 3;
          }
          while (v39 + 3 != a2);
        }
        return result;
      }
    }
  }
  if (result != a2)
  {
    *a5 = *result;
    a5[1] = result[1];
    a5[2] = result[2];
    int v12 = result + 3;
    if (result + 3 != a2)
    {
      uint64_t v13 = 0;
      uint64_t v14 = a5;
      do
      {
        unint64_t v15 = v12;
        unint64_t v16 = v8[3];
        if (v16) {
          unint64_t v17 = v8[3];
        }
        else {
          unint64_t v17 = 0;
        }
        uint64_t v18 = v14 + 3;
        unint64_t v19 = *v14;
        if (*v14 && v17 < v19)
        {
          v14[3] = v19;
          unint64_t v20 = v14[2];
          v14[4] = v14[1];
          if (v20) {
            unint64_t v21 = v20;
          }
          else {
            unint64_t v21 = 0;
          }
          v14[5] = v21;
          unint64_t v24 = a5;
          if (v14 != a5)
          {
            uint64_t v25 = v13;
            while (1)
            {
              unint64_t v26 = *v15 ? *v15 : 0;
              unint64_t v27 = *(unint64_t *)((char *)a5 + v25 - 24);
              if (!v27) {
                break;
              }
              unint64_t v24 = (unint64_t *)((char *)a5 + v25);
              unint64_t result = (unint64_t *)((char *)a5 + v25 - 24);
              if (v26 >= v27) {
                goto LABEL_33;
              }
              *unint64_t v24 = v27;
              v24[1] = *(v24 - 2);
              v14 -= 3;
              *(unint64_t *)((char *)a5 + v25 + 16) = *(unint64_t *)((char *)a5 + v25 - 8);
              v25 -= 24;
              if (!v25)
              {
                unint64_t v24 = a5;
                goto LABEL_33;
              }
            }
            unint64_t v24 = v14;
          }
LABEL_33:
          *unint64_t v24 = *v15;
          v24[1] = v8[4];
          uint64_t v23 = v24 + 2;
        }
        else
        {
          if (v16) {
            unint64_t v22 = v8[3];
          }
          else {
            unint64_t v22 = 0;
          }
          v14[3] = v22;
          v14[4] = v8[4];
          uint64_t v23 = v14 + 5;
        }
        *uint64_t v23 = v8[5];
        int v12 = v15 + 3;
        v13 += 24;
        uint64_t v14 = v18;
        unint64_t v8 = v15;
      }
      while (v15 + 3 != a2);
    }
  }
  return result;
}

uint64_t *std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<method_t::bigSigned *&,method_t::bigSigned *&>(uint64_t *result, uint64_t *a2)
{
  if (*result) {
    uint64_t v2 = *result;
  }
  else {
    uint64_t v2 = 0;
  }
  if (result[1]) {
    uint64_t v3 = result[1];
  }
  else {
    uint64_t v3 = 0;
  }
  if (result[2]) {
    uint64_t v4 = result[2];
  }
  else {
    uint64_t v4 = 0;
  }
  _DWORD *result = *a2;
  result[1] = a2[1];
  result[2] = a2[2];
  if (v2) {
    uint64_t v5 = v2;
  }
  else {
    uint64_t v5 = 0;
  }
  *a2 = v5;
  if (v3) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = 0;
  }
  a2[1] = v6;
  if (v4) {
    uint64_t v7 = v4;
  }
  else {
    uint64_t v7 = 0;
  }
  a2[2] = v7;
  return result;
}

uint64_t std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(uint64_t result, char *a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a4 >= 2)
  {
    uint64_t v7 = result;
    if (a4 == 2)
    {
      unint64_t v8 = a2 - 24;
      if (*((void *)a2 - 3) < *(void *)result)
      {
        long long v38 = *(_OWORD *)result;
        if (*(void *)(result + 16)) {
          uint64_t v9 = *(void *)(result + 16);
        }
        else {
          uint64_t v9 = 0;
        }
        *(_OWORD *)unint64_t result = *(_OWORD *)v8;
        *(void *)(result + 16) = *((void *)a2 - 1);
        *(_OWORD *)unint64_t v8 = v38;
        if (v9) {
          uint64_t v35 = v9;
        }
        else {
          uint64_t v35 = 0;
        }
        *((void *)a2 - 1) = v35;
      }
    }
    else if ((uint64_t)a4 <= 0)
    {
      if ((char *)result != a2)
      {
        unint64_t v17 = (_OWORD *)(result + 24);
        if ((char *)(result + 24) != a2)
        {
          uint64_t v18 = 0;
          unint64_t v19 = (void *)result;
          do
          {
            unint64_t v20 = v17;
            if (v19[3] < *v19)
            {
              long long v39 = *v17;
              uint64_t v40 = v19[5];
              uint64_t v21 = v18;
              while (1)
              {
                *(_OWORD *)(result + v21 + 24) = *(_OWORD *)(result + v21);
                *(void *)(result + v21 + 40) = *(void *)(result + v21 + 16);
                if (!v21) {
                  break;
                }
                uint64_t v22 = result + v21;
                unint64_t v23 = *(void *)(result + v21 - 24);
                v21 -= 24;
                if ((unint64_t)v39 >= v23)
                {
                  unint64_t v24 = (_OWORD *)(result + v21 + 24);
                  uint64_t v25 = (void *)(v22 + 16);
                  goto LABEL_21;
                }
              }
              uint64_t v25 = (void *)(result + 16);
              unint64_t v24 = (_OWORD *)result;
LABEL_21:
              *unint64_t v24 = v39;
              void *v25 = v40;
            }
            unint64_t v17 = (_OWORD *)((char *)v20 + 24);
            v18 += 24;
            unint64_t v19 = v20;
          }
          while ((char *)v20 + 24 != a2);
        }
      }
    }
    else
    {
      uint64_t v12 = a5;
      unint64_t v14 = a4 >> 1;
      unint64_t v15 = (char *)(result + 24 * (a4 >> 1));
      unint64_t v16 = a4 >> 1;
      if ((uint64_t)a4 <= a6)
      {
        std::__stable_sort_move<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(result, v15, a3, v16, a5);
        uint64_t v26 = v12 + 24 * v14;
        unint64_t result = std::__stable_sort_move<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(v7 + 24 * (a4 >> 1), a2, a3, a4 - (a4 >> 1), v26);
        unint64_t v27 = v12 + 24 * a4;
        unint64_t v28 = (void *)(v7 + 16);
        uint64_t v29 = v7 + 16;
        uint64_t v30 = v26;
        while (v30 != v27)
        {
          long long v31 = v28 - 2;
          if (*(void *)v30 >= *(void *)v12)
          {
            *long long v31 = *(_OWORD *)v12;
            *unint64_t v28 = *(void *)(v12 + 16);
            v12 += 24;
          }
          else
          {
            *long long v31 = *(_OWORD *)v30;
            *unint64_t v28 = *(void *)(v30 + 16);
            v30 += 24;
          }
          v29 += 24;
          v28 += 3;
          if (v12 == v26)
          {
            if (v30 != v27)
            {
              unint64_t v32 = 0;
              do
              {
                unint64_t v33 = v30 + v32;
                *(_OWORD *)&v28[v32 / 8 - 2] = *(_OWORD *)(v30 + v32);
                uint64_t v34 = *(void *)(v30 + v32 + 16);
                if (v34) {
                  unint64_t result = v30 + 16 + v32;
                }
                v28[v32 / 8] = v34;
                v32 += 24;
              }
              while (v33 + 24 != v27);
            }
            return result;
          }
        }
        if (v12 != v26)
        {
          uint64_t v36 = 0;
          do
          {
            uint64_t v37 = v12 + v36 * 8;
            *(_OWORD *)&v28[v36 - 2] = *(_OWORD *)(v12 + v36 * 8);
            v28[v36] = *(void *)(v12 + v36 * 8 + 16);
            v29 += 24;
            v36 += 3;
          }
          while (v37 + 24 != v26);
        }
      }
      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(result, v15, a3, v16, a5, a6);
        std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(v7 + 24 * (a4 >> 1), a2, a3, a4 - (a4 >> 1), v12, a6);
        return std::__inplace_merge<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(v7, (unint64_t *)(v7 + 24 * (a4 >> 1)), (unint64_t *)a2, a3, a4 >> 1, a4 - (a4 >> 1), v12, a6);
      }
    }
  }
  return result;
}

uint64_t std::__stable_sort_move<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(uint64_t result, char *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  if (a4)
  {
    unint64_t v8 = (_OWORD *)result;
    if (a4 == 2)
    {
      uint64_t v10 = a2 - 24;
      if (*((void *)a2 - 3) >= *(void *)result)
      {
        *(_OWORD *)a5 = *(_OWORD *)result;
        *(void *)(a5 + 16) = *(void *)(result + 16);
        *(_OWORD *)(a5 + 24) = *(_OWORD *)v10;
        uint64_t v9 = (void *)(a5 + 40);
        uint64_t v11 = *((void *)a2 - 1);
        goto LABEL_23;
      }
      *(_OWORD *)a5 = *(_OWORD *)v10;
      *(void *)(a5 + 16) = *((void *)a2 - 1);
      *(_OWORD *)(a5 + 24) = *(_OWORD *)result;
      uint64_t v9 = (void *)(a5 + 40);
LABEL_7:
      uint64_t v11 = *(void *)(result + 16);
LABEL_23:
      *uint64_t v9 = v11;
      return result;
    }
    if (a4 == 1)
    {
      *(_OWORD *)a5 = *(_OWORD *)result;
      uint64_t v9 = (void *)(a5 + 16);
      goto LABEL_7;
    }
    if ((uint64_t)a4 > 8)
    {
      unint64_t v21 = result + 24 * (a4 >> 1);
      std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(result, v21, a3, a4 >> 1, a5, a4 >> 1);
      unint64_t result = std::__stable_sort<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>((char *)v8 + 24 * (a4 >> 1), a2, a3, a4 - (a4 >> 1), a5 + 24 * (a4 >> 1), a4 - (a4 >> 1));
      uint64_t v22 = (void *)(a5 + 16);
      uint64_t v23 = a5 + 16;
      unint64_t v24 = (char *)v8 + 24 * (a4 >> 1);
      while (v24 != a2)
      {
        uint64_t v25 = v22 - 2;
        if (*(void *)v24 >= *(void *)v8)
        {
          _OWORD *v25 = *v8;
          *uint64_t v22 = *((void *)v8 + 2);
          unint64_t v8 = (_OWORD *)((char *)v8 + 24);
        }
        else
        {
          _OWORD *v25 = *(_OWORD *)v24;
          *uint64_t v22 = *((void *)v24 + 2);
          v24 += 24;
        }
        v23 += 24;
        v22 += 3;
        if (v8 == (_OWORD *)v21)
        {
          if (v24 != a2)
          {
            uint64_t v26 = 0;
            do
            {
              unint64_t v27 = &v24[v26 * 8];
              *(_OWORD *)&v22[v26 - 2] = *(_OWORD *)&v24[v26 * 8];
              v22[v26] = *(void *)&v24[v26 * 8 + 16];
              v26 += 3;
            }
            while (v27 + 24 != a2);
          }
          return result;
        }
      }
      if (v8 != (_OWORD *)v21)
      {
        uint64_t v28 = 0;
        do
        {
          uint64_t v29 = (char *)v8 + v28 * 8;
          *(_OWORD *)&v22[v28 - 2] = *(_OWORD *)((char *)v8 + v28 * 8);
          v22[v28] = *(void *)((char *)v8 + v28 * 8 + 16);
          v23 += 24;
          v28 += 3;
        }
        while (v29 + 24 != (char *)v21);
      }
    }
    else if ((char *)result != a2)
    {
      *(_OWORD *)a5 = *(_OWORD *)result;
      *(void *)(a5 + 16) = *(void *)(result + 16);
      uint64_t v12 = (_OWORD *)(result + 24);
      if ((char *)(result + 24) != a2)
      {
        uint64_t v13 = 0;
        unint64_t v14 = (_OWORD *)a5;
        do
        {
          unint64_t v15 = v12;
          unint64_t v16 = (_OWORD *)((char *)v14 + 24);
          unint64_t v17 = (void *)v14 + 5;
          if (*((void *)v8 + 3) >= *(void *)v14)
          {
            *unint64_t v16 = *v15;
          }
          else
          {
            *unint64_t v16 = *v14;
            *((void *)v14 + 5) = *((void *)v14 + 2);
            uint64_t v18 = a5;
            if (v14 != (_OWORD *)a5)
            {
              uint64_t v19 = v13;
              while (1)
              {
                uint64_t v18 = a5 + v19;
                if (*(void *)v15 >= *(void *)(a5 + v19 - 24)) {
                  break;
                }
                *(_OWORD *)uint64_t v18 = *(_OWORD *)(a5 + v19 - 24);
                *(void *)(v18 + 16) = *(void *)(v18 - 8);
                v19 -= 24;
                if (!v19)
                {
                  uint64_t v18 = a5;
                  break;
                }
              }
            }
            *(_OWORD *)uint64_t v18 = *v15;
            unint64_t v17 = (void *)(v18 + 16);
          }
          *unint64_t v17 = *((void *)v8 + 5);
          uint64_t v12 = (_OWORD *)((char *)v15 + 24);
          v13 += 24;
          unint64_t v14 = v16;
          unint64_t v8 = v15;
        }
        while ((char *)v15 + 24 != a2);
      }
    }
  }
  return result;
}

uint64_t sel_lookUpByName(char *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t objc_selector = _dyld_get_objc_selector();
  if (!objc_selector)
  {
    int v3 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(&selLock, (unsigned int *)&v3, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v3) {
      os_unfair_lock_lock_with_options();
    }
    uint64_t v5 = objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::find(a1);
    if ((char **)(*(void *)namedSelectors + 8 * dword_1EB1CAE58) == v5) {
      uint64_t objc_selector = 0;
    }
    else {
      uint64_t objc_selector = (uint64_t)*v5;
    }
    int v6 = *(_DWORD *)(StatusReg + 24);
    int v7 = v6;
    atomic_compare_exchange_strong_explicit(&selLock, (unsigned int *)&v7, 0, memory_order_release, memory_order_relaxed);
    if (v7 != v6) {
      os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
    }
  }
  return objc_selector;
}

void sub_180125D48(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
  }
  _Unwind_Resume(exception_object);
}

char **objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::find(char *__s1)
{
  uint64_t v2 = 0;
  if (objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::LookupBucketFor<char const*>((uint64_t)namedSelectors, __s1, &v2))
  {
    return v2;
  }
  if (namedSelectors[0]) {
    return (char **)(*(void *)namedSelectors + 8 * dword_1EB1CAE58);
  }
  return (char **)(8 * dword_1EB1CAE58);
}

BOOL objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::LookupBucketFor<char const*>(uint64_t a1, char *__s1, char ***a3)
{
  if (*(void *)a1) {
    int v6 = *(void **)a1;
  }
  else {
    int v6 = 0;
  }
  uint64_t v7 = *(unsigned int *)(a1 + 16);
  if (v7)
  {
    unsigned int v8 = 0;
    uint64_t v9 = __s1;
    do
    {
      unsigned int v10 = v8;
      int v11 = *v9++;
      unsigned int v8 = 257 * v8 + v11;
    }
    while (v11);
    uint64_t v22 = 0;
    int v12 = v7 - 1;
    for (int i = 1; ; int i = v21 + 1)
    {
      unsigned int v21 = i;
      unsigned int v14 = v10 & v12;
      unint64_t v15 = (char **)&v6[v10 & v12];
      unint64_t v16 = *v15;
      BOOL isEqual = objc::DenseMapInfo<char const*>::isEqual(__s1, *v15);
      if (isEqual) {
        break;
      }
      if (objc::DenseMapInfo<char const*>::isEqual(v16, (char *)0xFFFFFFFFFFFFFFFFLL))
      {
        if (v22) {
          unint64_t v15 = v22;
        }
        break;
      }
      if (v21 > v7) {
        objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::FatalCorruptHashTables(a1, v6, v7);
      }
      BOOL v18 = objc::DenseMapInfo<char const*>::isEqual(v16, (char *)0xFFFFFFFFFFFFFFFELL);
      uint64_t v19 = v22;
      if (v18 && v22 == 0) {
        uint64_t v19 = (char **)&v6[v14];
      }
      uint64_t v22 = v19;
      unsigned int v10 = v14 + v21;
    }
  }
  else
  {
    unint64_t v15 = 0;
    BOOL isEqual = 0;
  }
  *a3 = v15;
  return isEqual;
}

BOOL objc::DenseMapInfo<char const*>::isEqual(char *__s1, char *a2)
{
  if (__s1 == a2) {
    return 1;
  }
  BOOL result = 0;
  if (a2 != (char *)-2 && __s1 != (char *)-2 && __s1 != (char *)-1 && a2 != (char *)-1) {
    return strcmp(__s1, a2) == 0;
  }
  return result;
}

void *_headerForClass(unint64_t a1)
{
  int v1 = (void *)FirstHeader;
  if (FirstHeader)
  {
LABEL_2:
    uint64_t v3 = 0;
    while (1)
    {
      unint64_t size = 0;
      int v4 = getsegmentdata((const mach_header_64 *)((char *)v1 + *v1), off_1E4FBDCD0[v3], &size);
      if (v4)
      {
        if ((unint64_t)v4 <= a1 && (unint64_t)&v4[size] > a1) {
          break;
        }
      }
      if (++v3 == 4)
      {
        uint64_t PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v1);
        uint64_t v7 = v1 + 3;
        if (PreoptimizedHeaderRW) {
          uint64_t v7 = (void *)PreoptimizedHeaderRW;
        }
        int v1 = (void *)(*v7 & 0xFFFFFFFFFFFFFFFCLL);
        if (v1) {
          goto LABEL_2;
        }
        return v1;
      }
    }
  }
  return v1;
}

void _NXMapRehash(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  int v4 = *(_DWORD *)(a1 + 8);
  int v3 = *(_DWORD *)(a1 + 12);
  int v5 = v3 + 1;
  BOOL v6 = v3 == -1;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 2 * (v3 + 1) - 1;
  *(void *)(a1 + 16) = allocBuckets(2 * (v3 + 1));
  if (!v6)
  {
    uint64_t v7 = (uint64_t *)(v2 + 8);
    do
    {
      uint64_t v8 = *(v7 - 1);
      if (v8 != -1)
      {
        uint64_t v9 = *v7;
        uint64_t v10 = (**(uint64_t (***)(uint64_t, void))a1)(a1, *(v7 - 1));
        NXMapInsertWithHash(a1, v8, v10, v9);
      }
      v7 += 2;
      --v5;
    }
    while (v5);
  }
  if (v4 != *(_DWORD *)(a1 + 8)) {
    _objc_inform("*** maptable: count differs after rehashing; probably indicates a broken invariant: there are x and y such as isEq"
  }
      "ual(x, y) is TRUE but hash(x) != hash (y)\n");

  free((void *)(v2 - 16));
}

void objc_registerClassPair(Class cls)
{
  int v2 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v2, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v2) {
    os_unfair_lock_lock_with_options();
  }
  if ((unint64_t)(*(void *)cls - 1) < 0xF
    || (*(_DWORD *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
    || (uint64_t v4 = *(unsigned __int16 *)((*((void *)cls + 4) & 0xF00007FFFFFFFF8) + 4), dword_1EB1CB088 <= v4)
    || (*(void *)(qword_1EB1CB080 + 16 * v4) <= (unint64_t)cls
      ? (BOOL v5 = *(void *)(qword_1EB1CB080 + 16 * v4 + 8) > (unint64_t)cls)
      : (BOOL v5 = 0),
        !v5))
  {
    if (objc::allocatedClasses + 8 * qword_1EB1CAEA0 == objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::find((unint64_t)cls)
      && (dataSegmentsContain(cls, v18, v19) & 1) == 0)
    {
      _objc_fatal("Attempt to use unknown class %p.", v20, v21, v22, cls);
    }
  }
  BOOL v6 = (class_rw_t *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8);
  if ((*(_DWORD *)v6 & 0x2000000) != 0
    || (uint64_t v7 = (atomic_uint *)(*(void *)((*(void *)cls & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8),
        (*v7 & 0x2000000) != 0))
  {
    unsigned int v14 = "objc_registerClassPair: class '%s' was already registered!";
LABEL_19:
    unint64_t v15 = class_rw_t::ro(v6);
    _objc_inform(v14, atomic_load_explicit((atomic_ullong *volatile)(v15 + 24), memory_order_acquire));
    goto LABEL_20;
  }
  if ((*(_DWORD *)v6 & *v7 & 0x4000000) == 0)
  {
    unsigned int v14 = "objc_registerClassPair: class '%s' was not allocated with objc_allocateClassPair!";
    goto LABEL_19;
  }
  do
  {
    atomic_uint v8 = *v7;
    atomic_uint v9 = *v7;
    atomic_compare_exchange_strong(v7, (unsigned int *)&v9, *v7 & 0xF9F7FFFF | 0x2000000);
  }
  while (v9 != v8);
  uint64_t v10 = (atomic_uint *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8);
  do
  {
    atomic_uint v11 = *v10;
    atomic_uint v12 = *v10;
    atomic_compare_exchange_strong(v10, (unsigned int *)&v12, *v10 & 0xF9F7FFFF | 0x2000000);
  }
  while (v12 != v11);
  unint64_t v13 = class_rw_t::ro((class_rw_t *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8));
  addNamedClass(cls, (const char *)atomic_load_explicit((atomic_ullong *volatile)(v13 + 24), memory_order_acquire), 0);
LABEL_20:
  int v16 = *(_DWORD *)(StatusReg + 24);
  int v17 = v16;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v17, 0, memory_order_release, memory_order_relaxed);
  if (v17 != v16)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
}

void sub_18012645C(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NXMapInsertWithHash(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  if (a2 == -1)
  {
    _objc_inform("*** NXMapInsert: invalid key: -1\n");
  }
  else
  {
    uint64_t v8 = *(void *)(a1 + 16);
    int v9 = *(_DWORD *)(a1 + 12);
    uint64_t v10 = v9 & a3;
    atomic_uint v11 = (uint64_t *)(v8 + 16 * v10);
    int v12 = v9 + 1;
    uint64_t v13 = *v11;
    if (*v11 == -1)
    {
LABEL_11:
      *atomic_uint v11 = a2;
      int v16 = (void *)(v8 + 16 * v10);
LABEL_12:
      v16[1] = a4;
      int v17 = *(_DWORD *)(a1 + 8) + 1;
      *(_DWORD *)(a1 + 8) = v17;
      if (3 * v12 < (4 * v17)) {
        _NXMapRehash(a1);
      }
    }
    else
    {
      while (1)
      {
        if (v13 == a2
          || (!*(void *)a1 ? (uint64_t v14 = 0) : (uint64_t v14 = *(void *)a1),
              (*(unsigned int (**)(uint64_t))(v14 + 8))(a1)))
        {
          uint64_t v18 = v8 + 16 * v10;
LABEL_25:
          uint64_t v24 = *(void *)(v18 + 8);
          uint64_t v22 = (void *)(v18 + 8);
          uint64_t v23 = v24;
          if (v24 != a4)
          {
            *uint64_t v22 = a4;
            return v23;
          }
          return a4;
        }
        if (*(_DWORD *)(a1 + 8) != v12) {
          break;
        }
        _NXMapRehash(a1);
        uint64_t v8 = *(void *)(a1 + 16);
        int v15 = *(_DWORD *)(a1 + 12);
        uint64_t v10 = v15 & a3;
        int v12 = v15 + 1;
        uint64_t v13 = *(void *)(v8 + 16 * v10);
        if (v13 == -1)
        {
          atomic_uint v11 = (uint64_t *)(v8 + 16 * v10);
          goto LABEL_11;
        }
      }
      LODWORD(v19) = v10;
      while (1)
      {
        uint64_t v19 = *(_DWORD *)(a1 + 12) & (v19 + 1);
        if (v19 == v10) {
          break;
        }
        uint64_t v20 = *(void *)(v8 + 16 * v19);
        if (v20 == -1)
        {
          int v16 = (void *)(v8 + 16 * v19);
          *int v16 = a2;
          goto LABEL_12;
        }
        if (v20 != a2)
        {
          uint64_t v21 = *(void *)a1 ? *(void *)a1 : 0;
          if (!(*(unsigned int (**)(uint64_t))(v21 + 8))(a1)) {
            continue;
          }
        }
        uint64_t v18 = v8 + 16 * v19;
        goto LABEL_25;
      }
      _objc_inform("**** NXMapInsert: bug\n");
    }
  }
  return 0;
}

uint64_t addNamedClass(objc_class *a1, const char *a2, objc_class *a3)
{
  ClassExceptSomeSwift = (objc_class *)getClassExceptSomeSwift(a2);
  if (!ClassExceptSomeSwift || (uint64_t v7 = ClassExceptSomeSwift, ClassExceptSomeSwift == a3))
  {
    unsigned int v13 = namedClassTableHash(a2);
    uint64_t v14 = a1;
    uint64_t v15 = gdb_objc_realized_classes;
    int v16 = a2;
    goto LABEL_18;
  }
  uint64_t v8 = _headerForClass((unint64_t)ClassExceptSomeSwift);
  int v9 = _headerForClass((unint64_t)a1);
  uint64_t v10 = v9;
  if (v8)
  {
    atomic_uint v11 = (const char *)dyld_image_path_containing_address();
    if (v10)
    {
LABEL_5:
      int v12 = (const char *)dyld_image_path_containing_address();
      goto LABEL_9;
    }
  }
  else
  {
    atomic_uint v11 = "??";
    if (v9) {
      goto LABEL_5;
    }
  }
  int v12 = "??";
LABEL_9:
  int v17 = _NSGetMachExecuteHeader();
  uint64_t size = 0;
  uint64_t v18 = getsectdatafromheader_64(v17, "__DATA_CONST", "__objc_dupclass", &size);
  uint64_t v19 = &v18[_dyld_get_image_slide()];
  while (1)
  {
    uint64_t v20 = _NSGetMachExecuteHeader();
    uint64_t size = 0;
    uint64_t v21 = getsectdatafromheader_64(v20, "__DATA_CONST", "__objc_dupclass", &size);
    if (v19 >= &v21[_dyld_get_image_slide() + size]) {
      break;
    }
    uint64_t v22 = *(void *)v19;
    v19 += 8;
    if (!strcmp((const char *)(v22 + 8), a2)) {
      goto LABEL_17;
    }
  }
  if (DebugDuplicateClasses)
  {
    uint64_t v23 = _objc_inform;
    if (DebugDuplicateClasses == 2) {
      uint64_t v23 = (void (*)(const char *, ...))_objc_fatal;
    }
    v23("Class %s is implemented in both %s (%p) and %s (%p). One of the two will be used. Which one is undefined.", a2, v11, v7, v12, a1);
  }
LABEL_17:
  uint64_t v24 = (uint64_t (***)(void, uint64_t))nonMetaClasses();
  uint64_t v25 = *(void *)a1 & 0xFFFFFFFF8;
  unsigned int v13 = (**v24)(v24, v25);
  uint64_t v15 = (uint64_t)v24;
  int v16 = (const char *)v25;
  uint64_t v14 = a1;
LABEL_18:

  return NXMapInsertWithHash(v15, (uint64_t)v16, v13, (uint64_t)v14);
}

const char *namedClassTableHashCallback(int a1, char *a2)
{
  return namedClassTableHash(a2);
}

void map_images_nolock(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v224 = a4;
  v216 = a2;
  uint64_t v233 = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790]();
  v215 = (char *)&v209 - v5;
  v210 = v6;
  *(unsigned char *)BOOL v6 = 0;
  if (map_images_nolock::firstTime)
  {
    loadAllCategoriesIfNeeded();
  }
  else
  {
    size[0] = 0;
    shared_cache_range = (objc::SafeRanges *)_dyld_get_shared_cache_range();
    if (shared_cache_range)
    {
      dataSegmentsRanges = (uint64_t)shared_cache_range;
      *(void *)algn_1EB1CB078 = (char *)shared_cache_range + size[0];
      objc::SafeRanges::add(shared_cache_range, (uint64_t)shared_cache_range + size[0]);
    }
    headerInfoROs = _dyld_for_objc_header_opt_ro();
    objc_debug_headerInfoRWs = _dyld_for_objc_header_opt_rw();
    opt = &_objc_opt_data;
    if (DisablePreopt)
    {
      uint64_t v8 = "(by OBJC_DISABLE_PREOPTIMIZATION)";
    }
    else if (headerInfoROs)
    {
      uint64_t v8 = "libobjc is not in the shared cache";
      if (dataSegmentsRanges <= (unint64_t)&_objc_empty_cache
        && *(void *)algn_1EB1CB078 > (unint64_t)&_objc_empty_cache)
      {
        preoptimized = 1;
        if (PrintPreopt) {
          _objc_inform("PREOPTIMIZATION: is ENABLED (version %d)", 16);
        }
        goto LABEL_9;
      }
    }
    else
    {
      uint64_t v8 = "(dyld shared cache is absent or out of date)";
    }
    preoptimized = 0;
    opt = 0;
    fixed_up_protocol = 1;
    canonical_protocol = 1;
    if (PrintPreopt) {
      _objc_inform("PREOPTIMIZATION: is DISABLED %s", v8);
    }
  }
LABEL_9:
  uint64_t v212 = a1;
  if (PrintImages) {
    _objc_inform("IMAGES: processing %u newly-mapped images...\n", a1);
  }
  uint64_t prog_image_header = _dyld_get_prog_image_header();
  uint64_t v211 = a1;
  if (a1)
  {
    int v12 = (const mach_header_64 *)prog_image_header;
    unsigned int v219 = 0;
    uint64_t v209 = 0;
    LODWORD(v221) = 0;
    v222 = 0;
    unsigned int v13 = &objc_debug_taggedpointer_ext_classes[202];
    unint64_t v214 = *(void *)algn_1EB1CB078;
    unint64_t v217 = dataSegmentsRanges;
    uint64_t v14 = v212;
    uint64_t v213 = prog_image_header;
    while (1)
    {
      uint64_t v15 = --v14;
      int v16 = (const mach_header_64 **)&v216[4 * v14];
      int v17 = *v16;
      uint64_t v18 = v16[2];
      if (headerInfoROs)
      {
        int v19 = *(_DWORD *)headerInfoROs;
        if ((*(_DWORD *)headerInfoROs & 0x80000000) == 0) {
          break;
        }
      }
LABEL_23:
      uint32_t magic = v17->magic;
      if (v17->magic + 17958194 >= 2 && magic != -805638658 && magic != -822415874) {
        goto LABEL_106;
      }
      uint64_t v223 = v14;
      size[0] = 0;
      uint64_t v30 = _dyld_lookup_section_info();
      if (getsegmentdata(v17, "__OBJC", size)) {
        BOOL v31 = 0;
      }
      else {
        BOOL v31 = v30 == 0;
      }
      if (!v31)
      {
        unint64_t v32 = (char *)malloc_type_calloc(0x20uLL, 1uLL, 0x28110169uLL);
        uint64_t v25 = (uint64_t)v32;
        unint64_t v33 = &addHeader(mach_header_64 const*,char const*,_dyld_section_location_info_s *,int &,int &)::emptyInfo;
        if (v30) {
          unint64_t v33 = (unsigned char *)v30;
        }
        *(void *)unint64_t v32 = (char *)v17 - v32;
        *((void *)v32 + 1) = v33 - (v32 + 8);
        *((void *)v32 + 2) = (char *)v18 - (v32 + 16);
        uint64_t PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v32);
        uint64_t v35 = (void *)(v25 + 24);
        if (PreoptimizedHeaderRW) {
          uint64_t v35 = (void *)PreoptimizedHeaderRW;
        }
        *v35 |= 1uLL;
        int v36 = 1;
        goto LABEL_46;
      }
LABEL_105:
      uint64_t v14 = v223;
LABEL_106:
      if (!v15) {
        goto LABEL_109;
      }
    }
    int v20 = 0;
    uint64_t v21 = headerInfoROs + 8;
    int v22 = *(_DWORD *)(headerInfoROs + 4);
    while (1)
    {
      int v23 = v19 + v20;
      if (v19 + v20 < 0 != __OFADD__(v19, v20)) {
        ++v23;
      }
      int v24 = v23 >> 1;
      uint64_t v25 = v21 + (v22 * v24);
      uint64_t v26 = (const mach_header_64 *)(*(void *)v25 + v25);
      if (v17 == v26) {
        break;
      }
      if (v17 < v26) {
        int v19 = v24 - 1;
      }
      else {
        int v20 = v24 + 1;
      }
      if (v20 > v19) {
        goto LABEL_23;
      }
    }
    uint64_t v37 = getPreoptimizedHeaderRW(v21 + (v22 * v24));
    long long v38 = (uint64_t *)(v25 + 24);
    if (v37) {
      long long v38 = (uint64_t *)v37;
    }
    uint64_t v39 = *v38;
    if (*v38) {
      goto LABEL_106;
    }
    uint64_t v223 = v14;
    *long long v38 = v39 | 1;
    if (PrintPreopt)
    {
      uint64_t v40 = (const char *)dyld_image_path_containing_address();
      _objc_inform("PREOPTIMIZATION: honoring preoptimized header info at %p for %s", (const void *)v25, v40);
    }
    int v36 = 0;
LABEL_46:
    size[0] = 0;
    uint64_t v41 = header_info::classlist((header_info *)v25, size);
    unsigned int v42 = size[0];
    if (v36) {
      int v43 = size[0];
    }
    else {
      int v43 = 0;
    }
    if (!v41) {
      unsigned int v42 = 0;
    }
    unsigned int v218 = v42;
    if (v41) {
      int v44 = v43;
    }
    else {
      int v44 = 0;
    }
    uint64_t v45 = getPreoptimizedHeaderRW(v25);
    uint64_t v46 = (void *)(v25 + 24);
    if (v45) {
      uint64_t v46 = (void *)v45;
    }
    *v46 &= 3uLL;
    if (v13[501])
    {
      unint64_t i = LastHeader;
      if (!LastHeader)
      {
        for (unint64_t i = v13[501]; ; unint64_t i = v58 & 0xFFFFFFFFFFFFFFFCLL)
        {
          LastHeader = i;
          uint64_t v56 = getPreoptimizedHeaderRW(i);
          int v57 = (unint64_t *)(i + 24);
          if (v56) {
            int v57 = (unint64_t *)v56;
          }
          unint64_t v58 = *v57;
          if (v58 < 4) {
            break;
          }
        }
      }
      uint64_t v48 = getPreoptimizedHeaderRW(i);
      uint64_t v49 = (void *)(i + 24);
      if (v48) {
        uint64_t v49 = (void *)v48;
      }
      *uint64_t v49 = v25 & 0xFFFFFFFFFFFFFFFCLL | *v49 & 3;
      LastHeader = v25;
    }
    else
    {
      LastHeader = v25;
      v13[501] = v25;
    }
    unint64_t v50 = *(void *)v25 + v25;
    if (v217 > v50 || v214 <= v50)
    {
      LODWORD(v220) = v44;
      size[0] = (unint64_t)&unk_1EC9784E0;
      v231 = size;
      unint64_t v52 = *(unsigned int *)(v50 + 16);
      if (v52)
      {
        unint64_t v53 = v50 + 32;
        unint64_t v54 = *(unsigned int *)(v50 + 16);
        unint64_t v55 = v50 + 32;
        while (*(_DWORD *)v55 != 25 || strncmp((const char *)(v55 + 8), "__TEXT", 0x10uLL))
        {
          v55 += *(unsigned int *)(v55 + 4);
          if (!--v54) {
            goto LABEL_78;
          }
        }
        unint64_t v54 = v50 - *(void *)(v55 + 24);
LABEL_78:
        for (unint64_t j = 0; j < v52; ++j)
        {
          if (*(_DWORD *)v53 == 25
            && (!strncmp((const char *)(v53 + 8), "__DATA", 6uLL) || !strncmp((const char *)(v53 + 8), "__AUTH", 6uLL)))
          {
            ((void (*)(unint64_t *, unint64_t, unint64_t))std::function<void ()(segment_command_64 const*,long)>::operator())(v231, v53, v54);
            unint64_t v52 = *(unsigned int *)(v50 + 16);
          }
          v53 += *(unsigned int *)(v53 + 4);
        }
      }
      std::__function::__value_func<void ()(segment_command_64 const*,long)>::~__value_func[abi:nn180100](size);
      int v12 = (const mach_header_64 *)v213;
      int v44 = v220;
    }
    *(_OWORD *)uint64_t size = *(_OWORD *)v16;
    *((void *)&v60 + 1) = size[1];
    v230 = (uint64_t (*)())v16[2];
    *(void *)&long long v60 = v16[3];
    long long v220 = v60;
    if (v17 != v12)
    {
      unsigned int v13 = objc_debug_taggedpointer_ext_classes + 1616;
LABEL_96:
      BOOL v66 = &v215[40 * v219];
      *(void *)BOOL v66 = v25;
      *(_OWORD *)(v66 + 8) = *(_OWORD *)size;
      *((void *)v66 + 3) = v230;
      *((void *)v66 + 4) = v220;
      if (PrintImages)
      {
        unint64_t v67 = (const char *)dyld_image_path_containing_address();
        uint64_t v68 = " (bundle)";
        if (v17->filetype != 8) {
          uint64_t v68 = "";
        }
        uint64_t v69 = " (has class properties)";
        if ((*(_DWORD *)(*(void *)(v25 + 8) + v25 + 8 + 4) & 0x40) == 0) {
          uint64_t v69 = "";
        }
        unint64_t v70 = " (preoptimized)";
        if ((*(_DWORD *)(*(void *)(v25 + 8) + v25 + 8 + 4) & 8) == 0) {
          unint64_t v70 = "";
        }
        _objc_inform("IMAGES: loading image for %s%s%s%s\n", v67, v68, v69, v70);
      }
      v222 = (header_info **)(v218 + v222);
      LODWORD(v221) = v44 + v221;
      ++v219;
      goto LABEL_105;
    }
    unsigned int v13 = objc_debug_taggedpointer_ext_classes + 1616;
    if (v60)
    {
      if ((preoptimized & 1) == 0)
      {
        unint64_t v65 = *(void *)v25 + v25;
LABEL_94:
        if (hasSignedClassROPointers(v65)) {
          map_images_nolock::executableHasClassROSigning = 1;
        }
        goto LABEL_96;
      }
      v225[0] = 0;
      header_info::selrefs((header_info *)v25, v225);
      unint64_t v61 = v225[0];
      uint64_t v62 = _dyld_lookup_section_info();
      unint64_t v64 = v63 >> 4;
      if (!v62) {
        unint64_t v64 = 0;
      }
      v209 += v61 + v64;
    }
    unint64_t v65 = *(void *)v25 + v25;
    goto LABEL_94;
  }
  v222 = 0;
  LODWORD(v221) = 0;
  uint64_t v209 = 0;
  unsigned int v219 = 0;
LABEL_109:
  if ((map_images_nolock::firstTime & 1) == 0)
  {
    if (PrintPreopt) {
      _objc_inform("PREOPTIMIZATION: using dyld selector opt");
    }
    if (v209)
    {
      unsigned int v71 = (4 * (int)v209 / 3u + 1) | ((4 * (int)v209 / 3u + 1) >> 1);
      unsigned int v72 = v71 | (v71 >> 2) | ((v71 | (v71 >> 2)) >> 4);
      dword_1EB1CAE58 = (v72 | (v72 >> 8) | ((v72 | (v72 >> 8)) >> 16)) + 1;
      uint64_t v73 = malloc_type_malloc(8 * dword_1EB1CAE58, 0x64B88C75uLL);
      if (v73) {
        namedSelectors[0] = (int32x2_t)v73;
      }
      else {
        namedSelectors[0] = 0;
      }
      unk_1EB1CAE50 = 0;
      if (dword_1EB1CAE58) {
        memset(v73, 255, 8 * dword_1EB1CAE58);
      }
    }
    else
    {
      namedSelectors[0] = 0;
      unk_1EB1CAE50 = 0;
      dword_1EB1CAE58 = 0;
    }
    int v74 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(&selLock, (unsigned int *)&v74, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v74) {
      os_unfair_lock_lock_with_options();
    }
    SEL_cxx_construct = (uint64_t)__sel_registerName(".cxx_construct", 0, 0);
    SEL_cxx_destruct = (uint64_t)__sel_registerName(".cxx_destruct", 0, 0);
    int v76 = *(_DWORD *)(StatusReg + 24);
    int v77 = v76;
    atomic_compare_exchange_strong_explicit(&selLock, (unsigned int *)&v77, 0, memory_order_release, memory_order_relaxed);
    if (v77 != v76) {
      os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
    }
    objc::AssociationsManager::_mapStorage = 0;
    qword_1EB1CAC50 = 0;
    dword_1EB1CAC58 = 0;
    pthread_key_init_np();
    pthread_key_init_np();
    if (DebugScanWeakTables)
    {
      _objc_inform("Starting background scan of weak references.");
      size[0] = 0;
      uint64_t v78 = pthread_create((pthread_t *)size, 0, (void *(__cdecl *)(void *))weakTableScan, 0);
      uint64_t v79 = v78;
      if (v78)
      {
        v205 = strerror(v78);
        _objc_fatal("pthread_create failed with error %d (%s)", v206, v207, v208, v79, v205);
      }
      pthread_detach((pthread_t)size[0]);
    }
    uint64_t v80 = _dyld_get_prog_image_header();
    if (v80)
    {
      if (*(_DWORD *)(v80 + 4) == 16777228 && (*(_DWORD *)(v80 + 8) & 0xFFFFFF) == 2)
      {
        map_images_nolock::executableIsARM64e = 1;
LABEL_136:
        if (DebugClassRXSigning) {
          int v81 = map_images_nolock::executableHasClassROSigning;
        }
        else {
          int v81 = 0;
        }
        if (!v219) {
          goto LABEL_349;
        }
        uint64_t v82 = v219;
        uint64_t v83 = (void **)v215;
        while (1)
        {
          if ((hasSignedClassROPointers((unint64_t)*v83 + **v83) & 1) == 0)
          {
            if (objc::disableEnforceClassRXPtrAuth)
            {
              if (!v81) {
                goto LABEL_147;
              }
LABEL_146:
              unint64_t v84 = (const char *)dyld_image_path_containing_address();
              _objc_inform("%s has un-signed class_ro_t pointers, but the main executable was compiled with class_ro_t pointer signing enabled", v84);
              goto LABEL_147;
            }
            *(unsigned char *)v210 = 1;
            objc::disableEnforceClassRXPtrAuth = 1;
            if (v81) {
              goto LABEL_146;
            }
          }
LABEL_147:
          v83 += 5;
          if (!--v82) {
            goto LABEL_148;
          }
        }
      }
    }
  }
  if (map_images_nolock::executableIsARM64e == 1) {
    goto LABEL_136;
  }
LABEL_148:
  if (!v219) {
    goto LABEL_349;
  }
  unint64_t v227 = 0;
  LODWORD(v213) = _read_images::doneOnce;
  if ((_read_images::doneOnce & 1) == 0)
  {
    _read_images::doneOnce = 1;
    if (DisableTaggedPointers)
    {
      objc_debug_taggedpointer_masuint64_t k = 0;
      objc_debug_taggedpointer_slot_shift = 0;
      objc_debug_taggedpointer_slot_masuint64_t k = 0;
      objc_debug_taggedpointer_payload_lshift = 0;
      objc_debug_taggedpointer_payload_rshift = 0;
      objc_debug_taggedpointer_ext_masuint64_t k = 0;
      objc_debug_taggedpointer_ext_slot_shift = 0;
      objc_debug_taggedpointer_ext_slot_masuint64_t k = 0;
      objc_debug_taggedpointer_ext_payload_lshift = 0;
      objc_debug_taggedpointer_ext_payload_rshift = 0;
    }
    if (DisableTaggedPointerObfuscation || !dyld_program_sdk_at_least())
    {
      objc_debug_taggedpointer_obfuscator = 0;
    }
    else
    {
      arc4random_buf(&objc_debug_taggedpointer_obfuscator, 8uLL);
      objc_debug_taggedpointer_obfuscator &= 0x3FFFFFFFFFFFFFF8uLL;
      for (uint64_t k = 6u; k != -1; --k)
      {
        uint32_t v86 = arc4random_uniform(k + 1);
        unsigned __int8 v87 = objc_debug_tag60_permutations[k];
        objc_debug_tag60_permutations[k] = objc_debug_tag60_permutations[v86];
        objc_debug_tag60_permutations[v86] = v87;
      }
    }
    if (PrintConnecting) {
      _objc_inform("CLASS: found %d classes during launch", v222);
    }
    if (preoptimized) {
      int v88 = (int)v221;
    }
    else {
      int v88 = (int)v222;
    }
    size[1] = (unint64_t)_mapStrIsEqual;
    v230 = _mapNoFree;
    LODWORD(v231) = 0;
    size[0] = (unint64_t)namedClassTableHashCallback;
    v225[0] = (unint64_t)namedClassTableHashCallback;
    if (_mapStrIsEqual) {
      long long v89 = _mapStrIsEqual;
    }
    else {
      long long v89 = 0;
    }
    v225[1] = (unint64_t)v89;
    if (_mapNoFree) {
      long long v90 = _mapNoFree;
    }
    else {
      long long v90 = 0;
    }
    v225[2] = (unint64_t)v90;
    int v226 = 0;
    gdb_objc_realized_classes = (uint64_t)NXCreateMapTable(v225, 4 * v88 / 3);
  }
  int v91 = 0;
  uint64_t v92 = v219;
  unint64_t v93 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(&selLock, (unsigned int *)&v91, *(_DWORD *)(v93 + 24), memory_order_acquire, memory_order_acquire);
  if (v91) {
    os_unfair_lock_lock_with_options();
  }
  unint64_t v94 = (header_info **)v215;
  uint64_t v209 = v92;
  v222 = (header_info **)&v215[40 * v92];
  do
  {
    uint64_t v95 = *v94;
    if (((_BYTE)v94[4] & 1) == 0 || (preoptimized & 1) == 0)
    {
      int v96 = *(_DWORD *)((char *)v95 + *(void *)v95 + 12);
      uint64_t v97 = header_info::selrefs(v95, &v227);
      unint64_t v98 = v227;
      _read_images::UnfixedSelectors += v227;
      if (v227)
      {
        unint64_t v99 = (char **)v97;
        do
        {
          uint64_t v100 = (char *)__sel_registerName(*v99, 0, v96 == 8);
          if (*v99 != v100) {
            *unint64_t v99 = v100;
          }
          ++v99;
          --v98;
        }
        while (v98);
      }
    }
    v94 += 5;
  }
  while (v94 != v222);
  int v101 = *(_DWORD *)(v93 + 24);
  int v102 = v101;
  atomic_compare_exchange_strong_explicit(&selLock, (unsigned int *)&v102, 0, memory_order_release, memory_order_relaxed);
  if (v102 != v101) {
    os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
  }
  LODWORD(v223) = dyld_shared_cache_some_image_overridden();
  uint64_t v103 = 0;
  uint64_t v104 = 0;
  v105 = (header_info **)v215;
  do
  {
    v106 = *v105;
    int v107 = *((_DWORD *)v105 + 8);
    if ((v107 & 1) == 0 || preoptimized != 1) {
      goto LABEL_193;
    }
    char v108 = v223;
    if ((*((unsigned char *)opt + 4) & 2) == 0) {
      char v108 = 1;
    }
    v109 = "the image may contain classes with missing weak superclasses";
    if ((v108 & 1) != 0
      || future_named_class_map
      && (v109 = "there are unresolved future classes pending", *(_DWORD *)(future_named_class_map + 8)))
    {
      if (PrintPreopt)
      {
        v110 = (const char *)dyld_image_path_containing_address();
        _objc_inform("PREOPTIMIZATION: reading classes manually from %s because %s", v110, v109);
      }
LABEL_193:
      uint64_t v111 = header_info::classlist(v106, &v227);
      unint64_t v112 = v227;
      if (v227)
      {
        uint64_t v113 = v111;
        unint64_t v114 = 0;
        int v115 = *(_DWORD *)((char *)v106 + *(void *)v106 + 12);
        char v116 = v107 & 1 & preoptimized;
        do
        {
          v117 = *(objc_class **)(v113 + 8 * v114);
          uint64_t Class = readClass(v117, v115 == 8, v116);
          uint64_t v119 = Class;
          if ((objc_class *)Class != v117 && Class != 0)
          {
            uint64_t v103 = malloc_type_realloc(v103, 8 * (v104 + 1), 0x80040B8603338uLL);
            *((void *)v103 + v104) = v119;
            unint64_t v112 = v227;
            ++v104;
          }
          ++v114;
        }
        while (v114 < v112);
      }
    }
    v105 += 5;
  }
  while (v105 != v222);
  if (byte_1EB1CA648)
  {
    uint64_t v121 = (header_info **)v215;
    do
    {
      unint64_t v123 = (unint64_t *)_dyld_lookup_section_info();
      uint64_t v124 = v219 + ~(-858993459 * ((unint64_t)((char *)v121 - v215) >> 3));
      if (v123) {
        BOOL v125 = v122 >= 8;
      }
      else {
        BOOL v125 = 0;
      }
      if (v125)
      {
        unint64_t v126 = v122 >> 3;
        do
        {
          unint64_t v127 = remapClass(*v123);
          if (*v123 != v127)
          {
            (*(void (**)(uint64_t, uint64_t))(v224 + 16))(v224, v124);
            *unint64_t v123 = v127;
          }
          ++v123;
          --v126;
        }
        while (v126);
      }
      unint64_t v129 = (unint64_t *)_dyld_lookup_section_info();
      if (v129) {
        unint64_t v130 = v128 >> 3;
      }
      else {
        unint64_t v130 = 0;
      }
      if (v130)
      {
        unint64_t v131 = v130;
        do
        {
          unint64_t v132 = remapClass(*v129);
          if (*v129 != v132)
          {
            (*(void (**)(uint64_t, uint64_t))(v224 + 16))(v224, v124);
            *unint64_t v129 = v132;
          }
          ++v129;
          --v131;
        }
        while (v131);
      }
      v121 += 5;
    }
    while (v121 != v222);
    unint64_t v227 = v130;
  }
  uint64_t v223 = v224 + 16;
  v210 = &v230;
  unint64_t v214 = *(void *)algn_1EB1CB078;
  unint64_t v217 = dataSegmentsRanges;
  *(void *)&long long v220 = v215;
  while (2)
  {
    atomic_ullong v133 = protocols();
    if (*(unsigned char *)(v220 + 32))
    {
      int v134 = preoptimized;
      if ((v213 | preoptimized ^ 1)) {
        goto LABEL_227;
      }
      if (PrintProtocols)
      {
        unint64_t v160 = (const char *)dyld_image_path_containing_address();
        _objc_inform("PROTOCOLS: Skipping reading protocols in image: %s", v160);
      }
    }
    else
    {
      int v134 = 0;
LABEL_227:
      int v135 = *(_DWORD *)(**(void **)v220 + *(void *)v220 + 12);
      uint64_t v136 = header_info::protocollist(*(header_info **)v220, &v227);
      unint64_t v137 = v227;
      if (v227)
      {
        uint64_t v138 = v136;
        unsigned int v218 = v219 + ~(-858993459 * (((void)v220 - (void)v215) >> 3));
        v139 = (void (*)(atomic_ullong, unint64_t, unint64_t *))NXMapInsert;
        if (v135 == 8) {
          v139 = (void (*)(atomic_ullong, unint64_t, unint64_t *))NXMapKeyCopyingInsert;
        }
        v221 = v139;
        do
        {
          v140 = *(unint64_t **)v138;
          uint64_t Protocol = (char **)getProtocol(*(const char **)(*(void *)v138 + 8));
          v142 = Protocol;
          if (Protocol)
          {
            if (Protocol != (char **)v140)
            {
              if (PrintProtocols)
              {
                v143 = (const char *)protocol_t::demangledName(Protocol);
                _objc_inform("PROTOCOLS: protocol at %p is %s  (duplicate of %p)", v140, v143, v142);
              }
              if (v134)
              {
                int v144 = canonical_protocol ? 0 : 0x20000000;
                if (v144 & *((_DWORD *)v142 + 17)) == 0 && !DisablePreopt && (preoptimized)
                {
                  uint64_t v228 = 0;
                  size[0] = MEMORY[0x1E4F143A8];
                  size[1] = 3321888768;
                  v230 = (uint64_t (*)())__getSharedCachePreoptimizedProtocol_block_invoke;
                  v231 = (unint64_t *)&__block_descriptor_40_e8_32c47_ZTSKZ34getSharedCachePreoptimizedProtocolE3__0_e16_v28__0_v8B16_B20l;
                  v232 = &v228;
                  _dyld_for_each_objc_protocol();
                  if (v228)
                  {
                    int v145 = *(_DWORD *)(v228 + 68);
                    int v146 = canonical_protocol ? 0 : 0x20000000;
                    if ((v146 & v145) != 0)
                    {
                      if (canonical_protocol) {
                        int v147 = -1;
                      }
                      else {
                        int v147 = -536870913;
                      }
                      *(_DWORD *)(v228 + 68) = v147 & v145;
                    }
                  }
                }
              }
            }
          }
          else if (v134)
          {
            Preoptimizeduint64_t Protocol = getPreoptimizedProtocol();
            uint64_t v149 = (char **)PreoptimizedProtocol;
            if (PreoptimizedProtocol) {
              BOOL v150 = PreoptimizedProtocol == (void)v140;
            }
            else {
              BOOL v150 = 1;
            }
            char v151 = v150;
            if (v150) {
              v152 = v140;
            }
            else {
              v152 = (unint64_t *)PreoptimizedProtocol;
            }
            v221(v133, v152[1], v152);
            if (PrintProtocols)
            {
              unint64_t v153 = (const char *)protocol_t::demangledName((char **)v152);
              _objc_inform("PROTOCOLS: protocol at %p is %s", v152, v153);
              if ((v151 & 1) == 0)
              {
                v154 = (const char *)protocol_t::demangledName(v149);
                _objc_inform("PROTOCOLS: protocol at %p is %s  (duplicate of %p)", v140, v154, v149);
              }
            }
          }
          else
          {
            (*(void (**)(uint64_t, void))(v224 + 16))(v224, v218);
            if (((unint64_t)Protocol & 0xFF80000000000007) != 0) {
              _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", v155, v156, v157, Protocol);
            }
            unint64_t *v140 = (unint64_t)Protocol & 0x7FFFFFFFFFFFF8;
            if (v217 <= (unint64_t)v140 && v214 > (unint64_t)v140 && (preoptimized & 1) == 0)
            {
              if (fixed_up_protocol) {
                int v158 = -1073741824;
              }
              else {
                int v158 = 0x40000000;
              }
              if ((*((_DWORD *)v140 + 17) & 0xC0000000) != v158) {
                fixupProtocol((protocol_t *)v140);
              }
              protocol_t::demangledName((char **)v140);
            }
            v221(v133, v140[1], v140);
            if (PrintProtocols)
            {
              BOOL v159 = (const char *)protocol_t::demangledName((char **)v140);
              _objc_inform("PROTOCOLS: protocol at %p is %s", v140, v159);
            }
          }
          v138 += 8;
          --v137;
        }
        while (v137);
      }
    }
    *(void *)&long long v220 = v220 + 40;
    if ((header_info **)v220 != v222) {
      continue;
    }
    break;
  }
  unint64_t v161 = v227;
  BOOL v162 = (header_info **)v215;
  do
  {
    if ((v213 & 1) != 0 || !preoptimized || (*((unsigned char *)*v162 + *((void *)*v162 + 1) + 12) & 8) == 0)
    {
      uint64_t v164 = _dyld_lookup_section_info();
      unint64_t v161 = v164 ? v163 >> 3 : 0;
      if (v161)
      {
        uint64_t v165 = 0;
        uint64_t v166 = v219 + ~(-858993459 * ((unint64_t)((char *)v162 - v215) >> 3));
        do
        {
          uint64_t v167 = *(void *)(v164 + 8 * v165);
          if (canonical_protocol) {
            int v168 = 0;
          }
          else {
            int v168 = 0x20000000;
          }
          if ((v168 & *(_DWORD *)(v167 + 68)) == 0)
          {
            uint64_t v169 = getProtocol(*(const char **)(v167 + 8));
            if (v169) {
              uint64_t v167 = v169;
            }
            if (*(void *)(v164 + 8 * v165) != v167)
            {
              (*(void (**)(uint64_t, uint64_t))(v224 + 16))(v224, v166);
              *(void *)(v164 + 8 * v165) = v167;
              ++UnfixedProtocolReferences;
            }
          }
          ++v165;
        }
        while (v161 != v165);
      }
    }
    v162 += 5;
  }
  while (v162 != v222);
  unint64_t v227 = v161;
  if (didInitialAttachCategories == 1)
  {
    uint64_t v170 = 40 * v209;
    v171 = (header_info **)v215;
    do
    {
      if (*((unsigned char *)*v171 + *((void *)*v171 + 1) + 12)) {
        load_categories_nolock(*v171);
      }
      v171 += 5;
      v170 -= 40;
    }
    while (v170);
    uint64_t v172 = 40 * v209;
    v173 = (header_info **)v215;
    do
    {
      if ((*((unsigned char *)*v173 + *((void *)*v173 + 1) + 12) & 1) == 0) {
        load_categories_nolock(*v173);
      }
      v173 += 5;
      v172 -= 40;
    }
    while (v172);
  }
  v174 = (header_info **)v215;
  do
  {
    uint64_t v175 = header_info::nlclslist(*v174, &v227);
    unint64_t v177 = v227;
    if (v227)
    {
      v178 = (unint64_t *)v175;
      do
      {
        unint64_t v179 = remapClass(*v178);
        v180 = (uint64_t *)v179;
        if (v179)
        {
          addClassTableEntry(v179, 1);
          if ((v180[4] & 2) != 0)
          {
            unint64_t v181 = class_data_bits_t::safe_ro<(Authentication)0>(v180 + 4);
            if ((*(unsigned char *)v181 & 0x40) != 0)
            {
              if (*(void *)(v181 + 72))
              {
                v201 = objc_class::nameForLogging((objc_class *)v180);
                _objc_fatal("Swift class %s with a metadata initializer is not allowed to be non-lazy", v202, v203, v204, v201);
              }
            }
          }
          realizeClassWithoutSwift((objc_class *)v180, 0);
        }
        ++v178;
        --v177;
      }
      while (v177);
    }
    v174 += 5;
  }
  while (v174 != v222);
  if (v103)
  {
    if (v104)
    {
      v182 = (objc_class **)v103;
      do
      {
        uint64_t v183 = (uint64_t)*v182;
        if ((*((unsigned char *)*v182 + 32) & 2) != 0) {
          _objc_fatal("Swift class is not allowed to be future", v176, v10, v11);
        }
        realizeClassWithoutSwift(*v182, 0);
        objc_class::setInstancesRequireRawIsaRecursively(v183, 0);
        ++v182;
        --v104;
      }
      while (v104);
    }
    free(v103);
  }
  if (DebugNonFragileIvars) {
    realizeAllClasses();
  }
  if (PrintPreopt)
  {
    v184 = v215;
    do
    {
      v185 = *(void **)v184;
      v186 = v184;
      int v187 = *((_DWORD *)v184 + 8);
      if (v187 & 1) != 0 && (v188 = "PREOPTIMIZATION: honoring preoptimized selectors in %s", (preoptimized) {
        || (v188 = "PREOPTIMIZATION: IGNORING preoptimized selectors in %s", (*((unsigned char *)v185 + v185[1] + 12) & 8) != 0))
      }
      {
        uint64_t v189 = dyld_image_path_containing_address();
        _objc_inform(v188, v189);
      }
      uint64_t v190 = header_info::classlist((header_info *)v185, &v227);
      unint64_t v191 = v227;
      if (v227)
      {
        v192 = (unint64_t *)v190;
        do
        {
          unint64_t v193 = remapClass(*v192);
          v194 = (void *)v193;
          if (v193)
          {
            ++_read_images::PreoptTotalClasses;
            if ((v187 & 1) != 0 && preoptimized == 1) {
              ++_read_images::PreoptOptimizedClasses;
            }
            _read_images::$_1::operator()(v193);
            _read_images::$_1::operator()(*v194 & 0xFFFFFFFF8);
          }
          ++v192;
          --v191;
        }
        while (v191);
      }
      v184 = v186 + 40;
    }
    while (v186 + 40 != (char *)v222);
    _objc_inform("PREOPTIMIZATION: %zu selector references not pre-optimized", _read_images::UnfixedSelectors);
    if (_read_images::PreoptTotalMethodLists) {
      _objc_inform("PREOPTIMIZATION: %u/%u (%.3g%%) method lists pre-sorted", _read_images::PreoptOptimizedMethodLists, _read_images::PreoptTotalMethodLists, (double)_read_images::PreoptOptimizedMethodLists* 100.0/ (double)_read_images::PreoptTotalMethodLists);
    }
    else {
      _objc_inform("PREOPTIMIZATION: %u/%u (%.3g%%) method lists pre-sorted", _read_images::PreoptOptimizedMethodLists, 0, 0.0);
    }
    if (_read_images::PreoptTotalClasses) {
      _objc_inform("PREOPTIMIZATION: %u/%u (%.3g%%) classes pre-registered", _read_images::PreoptOptimizedClasses, _read_images::PreoptTotalClasses, (double)_read_images::PreoptOptimizedClasses* 100.0/ (double)_read_images::PreoptTotalClasses);
    }
    else {
      _objc_inform("PREOPTIMIZATION: %u/%u (%.3g%%) classes pre-registered", _read_images::PreoptOptimizedClasses, 0, 0.0);
    }
    _objc_inform("PREOPTIMIZATION: %zu protocol references not pre-optimized", UnfixedProtocolReferences);
  }
LABEL_349:
  map_images_nolock::firstTime = 1;
  if (loadImageCallbacks[0] >= 5uLL) {
    v195 = (uint64_t *)qword_1EB1CADE8;
  }
  else {
    v195 = &qword_1EB1CADE8;
  }
  if (loadImageCallbacks[0])
  {
    v196 = &v195[2 * loadImageCallbacks[0]];
    do
    {
      BOOL v197 = v211 == 0;
      loadImageCallback::operator=((uint64_t)size, (uint64_t)v195, v10, v11);
      v199 = v216;
      uint64_t v200 = v212;
      if (!v197)
      {
        do
        {
          if (LOBYTE(size[1]) == 2)
          {
            ((void (*)(void, void))size[0])(*v199, v199[2]);
          }
          else
          {
            if (LOBYTE(size[1]) != 1) {
              _objc_fatal("Corrupt load image callback, unknown kind %u, func %p", v198, v10, v11, LOBYTE(size[1]), size[0]);
            }
            ((void (*)(void))size[0])(*v199);
          }
          v199 += 4;
          --v200;
        }
        while (v200);
      }
      v195 += 2;
    }
    while (v195 != v196);
  }
}

void sub_180128608(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
  }
  _Unwind_Resume(exception_object);
}

const void *__sel_registerName(char *a1, int a2, int a3)
{
  __s = a1;
  if (!a1) {
    return 0;
  }
  uint64_t objc_selector = (const void *)_dyld_get_objc_selector();
  if (!objc_selector)
  {
    if (a2)
    {
      int v6 = 0;
      atomic_compare_exchange_strong_explicit(&selLock, (unsigned int *)&v6, *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24), memory_order_acquire, memory_order_acquire);
      if (v6) {
        os_unfair_lock_lock_with_options();
      }
    }
    objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::try_emplace<objc::detail::DenseSetEmpty&>((uint64_t)&v14, namedSelectors, &__s);
    uint64_t v7 = v14;
    if (!v15)
    {
      uint64_t objc_selector = *v14;
      if (!a2) {
        return objc_selector;
      }
      goto LABEL_15;
    }
    uint64_t objc_selector = __s;
    if (a3)
    {
      size_t v8 = strlen(__s) + 1;
      if ((_dyld_is_memory_immutable() & 1) == 0)
      {
        int v9 = malloc_type_malloc(v8, 0x3F84A03uLL);
        memcpy(v9, objc_selector, v8);
        uint64_t objc_selector = v9;
      }
    }
    *uint64_t v7 = objc_selector;
    if (a2)
    {
LABEL_15:
      int v11 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
      int v12 = v11;
      atomic_compare_exchange_strong_explicit(&selLock, (unsigned int *)&v12, 0, memory_order_release, memory_order_relaxed);
      if (v12 != v11) {
        os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
      }
    }
  }
  return objc_selector;
}

void sub_1801287A4(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    int v3 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
    int v4 = v3;
    atomic_compare_exchange_strong_explicit(&selLock, (unsigned int *)&v4, 0, memory_order_release, memory_order_relaxed);
    if (v4 != v3) {
      os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t getProtocol(const char *a1)
{
  uint64_t v2 = (uint64_t *)protocols();
  Preoptimizeduint64_t Protocol = NXMapGet(v2, (uint64_t)a1);
  if (!PreoptimizedProtocol)
  {
    Preoptimizeduint64_t Protocol = getPreoptimizedProtocol();
    if (!PreoptimizedProtocol)
    {
      int v4 = copySwiftV1MangledName(a1, 1);
      if (v4)
      {
        int v5 = v4;
        int v6 = (uint64_t *)protocols();
        Preoptimizeduint64_t Protocol = NXMapGet(v6, (uint64_t)v5);
        if (!PreoptimizedProtocol) {
          Preoptimizeduint64_t Protocol = getPreoptimizedProtocol();
        }
        free(v5);
      }
      else
      {
        return 0;
      }
    }
  }
  return PreoptimizedProtocol;
}

atomic_ullong protocols(void)
{
  if (!protocols(void)::protocol_map[0])
  {
    v3[0] = _mapStrHash;
    v3[1] = _mapStrIsEqual;
    v3[2] = _mapNoFree;
    int v4 = 0;
    uint64_t v0 = NXCreateMapTable(v3, 0x10u);
    while (1)
    {
      uint64_t v1 = protocols(void)::protocol_map[0];
      if (protocols(void)::protocol_map[0]) {
        break;
      }
      atomic_compare_exchange_strong(protocols(void)::protocol_map, (unint64_t *)&v1, (unint64_t)v0);
      if (!v1) {
        return protocols(void)::protocol_map[0];
      }
    }
    NXFreeMapTable(v0);
  }
  return protocols(void)::protocol_map[0];
}

uint64_t NXMapGet(uint64_t *a1, uint64_t a2)
{
  unsigned int v4 = (*(uint64_t (**)(uint64_t *))*a1)(a1);
  uint64_t v6 = 0;
  if (_NXMapMemberWithHash(a1, a2, v4, &v6) == -1) {
    return 0;
  }
  else {
    return v6;
  }
}

objc_class *look_up_class(char *a1)
{
  if (!a1) {
    return 0;
  }
  int v2 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v2, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v2) {
    os_unfair_lock_lock_with_options();
  }
  ClassExceptSomeSwift = (uint64_t *)getClassExceptSomeSwift(a1);
  int v5 = (objc_class *)ClassExceptSomeSwift;
  if (!ClassExceptSomeSwift
    || (unint64_t)(*ClassExceptSomeSwift - 1) >= 0xF
    && (*(_DWORD *)(ClassExceptSomeSwift[4] & 0xF00007FFFFFFFF8) & 0x80000000) != 0)
  {
    int v6 = *(_DWORD *)(StatusReg + 24);
    int v7 = v6;
    atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v7, 0, memory_order_release, memory_order_relaxed);
    if (v7 != v6) {
      os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
    }
  }
  else
  {
    int v5 = realizeClassMaybeSwiftMaybeRelock(ClassExceptSomeSwift, 0);
  }
  if (!v5)
  {
    size_t v8 = *(unsigned int **)(StatusReg + 320);
    if (!v8)
    {
      size_t v8 = (unsigned int *)malloc_type_malloc(0x48uLL, 0xB4ED9BFAuLL);
      *(_OWORD *)size_t v8 = 0u;
      *((_OWORD *)v8 + 1) = 0u;
      *((_OWORD *)v8 + 2) = 0u;
      *((_OWORD *)v8 + 3) = 0u;
      *((void *)v8 + 8) = 0;
      *(void *)(StatusReg + 320) = v8;
    }
    unsigned int v9 = v8[17];
    if (v9)
    {
      uint64_t v10 = (const char **)*((void *)v8 + 7);
      uint64_t v11 = v8[17];
      while (strcmp(a1, *v10))
      {
        ++v10;
        if (!--v11) {
          goto LABEL_17;
        }
      }
      return 0;
    }
LABEL_17:
    if (v9 == v8[16])
    {
      unsigned int v12 = 2 * v9;
      if (2 * v9 <= 1) {
        unsigned int v12 = 1;
      }
      v8[16] = v12;
      unsigned int v13 = malloc_type_realloc(*((void **)v8 + 7), 8 * v12, 0x992452D7uLL);
      *((void *)v8 + 7) = v13;
      unsigned int v9 = v8[17];
    }
    else
    {
      unsigned int v13 = (void *)*((void *)v8 + 7);
    }
    v8[17] = v9 + 1;
    v13[v9] = a1;
    int v16 = 0;
    if (((unsigned int (*)(char *, objc_class **))atomic_load_explicit(&GetClassHook, memory_order_acquire))(a1, &v16))
    {
      int v5 = v16;
    }
    else
    {
      int v5 = 0;
    }
    unsigned int v14 = v8[17] - 1;
    v8[17] = v14;
    *(void *)(*((void *)v8 + 7) + 8 * v14) = 0;
  }
  return v5;
}

uint64_t getClassExceptSomeSwift(const char *a1)
{
  uint64_t ClassFromNamedClassTable = getClassFromNamedClassTable(a1);
  if (!ClassFromNamedClassTable)
  {
    uint64_t ClassFromNamedClassTable = getPreoptimizedClass();
    if (!ClassFromNamedClassTable)
    {
      int v3 = copySwiftV1MangledName(a1, 0);
      if (v3)
      {
        unsigned int v4 = v3;
        uint64_t ClassFromNamedClassTable = getClassFromNamedClassTable(v3);
        if (!ClassFromNamedClassTable) {
          uint64_t ClassFromNamedClassTable = getPreoptimizedClass();
        }
        free(v4);
      }
      else
      {
        return 0;
      }
    }
  }
  return ClassFromNamedClassTable;
}

uint64_t getClassFromNamedClassTable(const char *a1)
{
  unsigned int v2 = namedClassTableHash(a1);
  uint64_t v6 = 0;
  uint64_t v3 = _NXMapMemberWithHash((uint64_t *)gdb_objc_realized_classes, (uint64_t)a1, v2, &v6);
  uint64_t result = 0;
  if (v3 != -1 && v6 != 0) {
    return v6;
  }
  return result;
}

uint64_t _NXMapMemberWithHash(uint64_t *a1, uint64_t a2, unsigned int a3, void *a4)
{
  uint64_t v5 = a1[2];
  uint64_t v6 = *((_DWORD *)a1 + 3) & a3;
  uint64_t v7 = v5 + 16 * v6;
  if (*(void *)v7 != -1)
  {
    if (*(void *)v7 == a2
      || (!*a1 ? (uint64_t v10 = 0) : (uint64_t v10 = *a1), (*(unsigned int (**)(uint64_t *))(v10 + 8))(a1)))
    {
LABEL_16:
      *a4 = *(void *)(v5 + 16 * v6 + 8);
      return *(void *)v7;
    }
    LODWORD(v11) = v6;
    while (1)
    {
      uint64_t v11 = *((_DWORD *)a1 + 3) & (v11 + 1);
      if (v11 == v6) {
        break;
      }
      uint64_t v12 = *(void *)(v5 + 16 * v11);
      if (v12 == -1) {
        break;
      }
      if (v12 != a2)
      {
        uint64_t v13 = *a1 ? *a1 : 0;
        if (!(*(unsigned int (**)(uint64_t *))(v13 + 8))(a1)) {
          continue;
        }
      }
      uint64_t v7 = v5 + 16 * v11;
      uint64_t v6 = v11;
      goto LABEL_16;
    }
  }
  return -1;
}

BOOL _mapStrIsEqual(int a1, char *__s1, char *__s2)
{
  if (__s1 == __s2) {
    return 1;
  }
  if (!__s1)
  {
    int v3 = *__s2;
    return v3 == 0;
  }
  int v3 = *__s1;
  if (!__s2) {
    return v3 == 0;
  }
  if (v3 != *__s2) {
    return 0;
  }
  return strcmp(__s1, __s2) == 0;
}

const char *namedClassTableHash(const char *result)
{
  if (result)
  {
    uint64_t v1 = result;
    size_t v2 = strlen(result) + 1;
    if (v2 >= 9)
    {
      do
      {
        v1 += 8;
        v2 -= 8;
      }
      while (v2 > 8);
    }
    return 0;
  }
  return result;
}

uint64_t getPreoptimizedClass()
{
  if (DisablePreopt || preoptimized != 1) {
    return 0;
  }
  _dyld_for_each_objc_class();
  return 0;
}

uint64_t _mapStrHash(uint64_t a1, unsigned char *a2)
{
  if (a2 && (int v2 = *a2, *a2))
  {
    unsigned int v3 = 0;
    unsigned int v4 = a2 + 4;
    do
    {
      v3 ^= v2;
      if (!*(v4 - 3)) {
        break;
      }
      v3 ^= *(v4 - 3) << 8;
      if (!*(v4 - 2)) {
        break;
      }
      v3 ^= *(v4 - 2) << 16;
      if (!*(v4 - 1)) {
        break;
      }
      v3 ^= *(v4 - 1) << 24;
      int v5 = *v4;
      v4 += 4;
      int v2 = v5;
    }
    while (v5);
  }
  else
  {
    unsigned int v3 = 0;
  }
  return v3 + 65521 * ((unsigned __int16)v3 ^ HIWORD(v3));
}

uint64_t getPreoptimizedProtocol()
{
  if (DisablePreopt || preoptimized != 1) {
    return 0;
  }
  _dyld_for_each_objc_protocol();
  return 0;
}

uint64_t header_info::classlist(header_info *this, unint64_t *a2)
{
  uint64_t result = _dyld_lookup_section_info();
  unint64_t v5 = v4 >> 3;
  if (!result) {
    unint64_t v5 = 0;
  }
  *a2 = v5;
  return result;
}

uint64_t hasSignedClassROPointers(unint64_t a1)
{
  if (dataSegmentsRanges <= a1 && *(void *)algn_1EB1CB078 > a1) {
    return 1;
  }
  uint64_t v2 = _dyld_lookup_section_info();
  if (v2) {
    return (*(unsigned __int8 *)(v2 + 4) >> 4) & 1;
  }
  else {
    return 1;
  }
}

uint64_t header_info::nlclslist(header_info *this, unint64_t *a2)
{
  uint64_t result = _dyld_lookup_section_info();
  unint64_t v5 = v4 >> 3;
  if (!result) {
    unint64_t v5 = 0;
  }
  *a2 = v5;
  return result;
}

char *copySwiftV1MangledName(const char *a1, int a2)
{
  if (!a1) {
    return 0;
  }
  unint64_t v2 = 0;
  uint64_t v3 = 0;
  unint64_t v4 = 0;
  while (1)
  {
    unint64_t v5 = &a1[v2];
    if (a1[v2] != 46) {
      break;
    }
    ++v3;
    unint64_t v4 = v2;
LABEL_7:
    ++v2;
  }
  if (a1[v2]) {
    goto LABEL_7;
  }
  uint64_t v6 = 0;
  if (v3 == 1 && v4 && v4 < v5 - a1 - 1)
  {
    uint64_t v10 = 0;
    if (v4 == 5 && (*(_DWORD *)a1 == 1718187859 ? (BOOL v7 = a1[4] == 116) : (BOOL v7 = 0), v7))
    {
      asprintf(&v10, "_Tt%cs%zu%.*s%s");
    }
    else
    {
      uint64_t v8 = 67;
      if (a2) {
        uint64_t v8 = 80;
      }
      asprintf(&v10, "_Tt%c%zu%.*s%zu%.*s%s", v8, v4);
    }
    return v10;
  }
  return (char *)v6;
}

BOOL objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::try_emplace<objc::detail::DenseSetEmpty&>(uint64_t a1, int32x2_t *a2, char **a3)
{
  unsigned int v14 = 0;
  BOOL result = objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::LookupBucketFor<char const*>((uint64_t)a2, *a3, &v14);
  BOOL v7 = v14;
  if (result)
  {
    char v8 = 0;
    int32x2_t v9 = *a2;
    goto LABEL_3;
  }
  __int32 v11 = a2[1].i32[0];
  unsigned int v12 = a2[2].u32[0];
  if (4 * v11 + 4 >= 3 * v12)
  {
    v12 *= 2;
    goto LABEL_12;
  }
  if (v12 + ~v11 - a2[1].i32[1] <= v12 >> 3)
  {
LABEL_12:
    objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::grow((uint64_t)a2, v12);
    unsigned int v14 = 0;
    objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::LookupBucketFor<char const*>((uint64_t)a2, *a3, &v14);
    BOOL v7 = v14;
  }
  uint64_t v13 = *v7;
  BOOL result = objc::DenseMapInfo<char const*>::isEqual(*v7, (char *)0xFFFFFFFFFFFFFFFFLL);
  if (result)
  {
    ++a2[1].i32[0];
  }
  else
  {
    BOOL result = objc::DenseMapInfo<char const*>::isEqual(v13, (char *)0xFFFFFFFFFFFFFFFELL);
    if (result) {
      a2[1] = vadd_s32(a2[1], (int32x2_t)0xFFFFFFFF00000001);
    }
  }
  *BOOL v7 = *a3;
  int32x2_t v9 = *a2;
  char v8 = 1;
LABEL_3:
  uint64_t v10 = *(void *)&v9 + 8 * a2[2].u32[0];
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v10;
  *(unsigned char *)(a1 + 16) = v8;
  return result;
}

uint64_t header_info::protocollist(header_info *this, unint64_t *a2)
{
  uint64_t result = _dyld_lookup_section_info();
  unint64_t v5 = v4 >> 3;
  if (!result) {
    unint64_t v5 = 0;
  }
  *a2 = v5;
  return result;
}

uint64_t loadImageCallback::operator=(uint64_t result, uint64_t a2, const char *a3, char *a4)
{
  int v4 = *(unsigned __int8 *)(a2 + 8);
  if (v4 == 2)
  {
    uint64_t v5 = *(void *)a2;
  }
  else
  {
    if (v4 != 1) {
      _objc_fatal("Corrupt load image callback, unknown kind %u, func %p", a2, a3, a4, *(unsigned __int8 *)(a2 + 8), *(void *)a2);
    }
    uint64_t v5 = *(void *)a2;
  }
  *(void *)uint64_t result = v5;
  *(unsigned char *)(result + 8) = v4;
  return result;
}

char *objc::SafeRanges::add(objc::SafeRanges *this, uint64_t a2)
{
  int v4 = qword_1EB1CB088;
  if (qword_1EB1CB088 == (HIDWORD(qword_1EB1CB088) & 0x7FFFFFFF))
  {
    int v5 = 1 << (29 - __clz(qword_1EB1CB088));
    if (qword_1EB1CB088 >= 0x10) {
      int v6 = v5;
    }
    else {
      int v6 = 4;
    }
    int v7 = v6 + HIDWORD(qword_1EB1CB088);
    HIDWORD(qword_1EB1CB088) = HIDWORD(qword_1EB1CB088) & 0x80000000 | v7 & 0x7FFFFFFF;
    uint64_t result = (char *)malloc_type_realloc((void *)qword_1EB1CB080, 16 * (v7 & 0x7FFFFFFF), 0x1000040451B5BE8uLL);
    qword_1EB1CB080 = (uint64_t)result;
    int v4 = qword_1EB1CB088;
  }
  else
  {
    uint64_t result = (char *)qword_1EB1CB080;
  }
  unsigned int v9 = v4 + 1;
  uint64_t v10 = &result[16 * v4];
  *(void *)uint64_t v10 = this;
  *((void *)v10 + 1) = a2;
  qword_1EB1CB088 = __PAIR64__(HIDWORD(qword_1EB1CB088), v9) & 0x7FFFFFFFFFFFFFFFLL;
  return result;
}

char *std::__function::__func<appendHeader::$_0,std::allocator<appendHeader::$_0>,void ()(segment_command_64 const*,long)>::operator()(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = (objc::SafeRanges *)(*(void *)(*(void *)a2 + 24) + *a3);
  return objc::SafeRanges::add(v3, (uint64_t)v3 + *(void *)(*(void *)a2 + 32));
}

void *objc_copyClassNamesForImageHeader(header_info *a1, unsigned int *a2)
{
  if (a1)
  {
    int v4 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v4) {
      os_unfair_lock_lock_with_options();
    }
    int v6 = (header_info *)FirstHeader;
    if (FirstHeader)
    {
      while ((header_info *)((char *)v6 + *(void *)v6) != a1)
      {
        uint64_t PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v6);
        char v8 = (void *)((char *)v6 + 24);
        if (PreoptimizedHeaderRW) {
          char v8 = (void *)PreoptimizedHeaderRW;
        }
        int v6 = (header_info *)(*v8 & 0xFFFFFFFFFFFFFFFCLL);
        if (!v6) {
          goto LABEL_9;
        }
      }
      unsigned int v9 = copyClassNamesForImage_nolock(v6, a2);
    }
    else
    {
LABEL_9:
      unsigned int v9 = 0;
      if (a2) {
        *a2 = 0;
      }
    }
    int v10 = *(_DWORD *)(StatusReg + 24);
    int v11 = v10;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v11, 0, memory_order_release, memory_order_relaxed);
    if (v11 != v10) {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
  }
  else
  {
    unsigned int v9 = 0;
    if (a2) {
      *a2 = 0;
    }
  }
  return v9;
}

void sub_180129838(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void objc_addLoadImageFunc2(void (*a1)(char *, uint64_t), uint64_t a2, const char *a3, char *a4)
{
  int v5 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v5, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v5) {
    os_unfair_lock_lock_with_options();
  }
  int v7 = (void *)FirstHeader;
  if (FirstHeader)
  {
    do
    {
      if (preoptimized == 1 && (*((unsigned char *)v7 + v7[1] + 12) & 8) != 0 && *(_DWORD *)(headerInfoROs + 4) < 0x18u) {
        uint64_t v8 = 0;
      }
      else {
        uint64_t v8 = (uint64_t)v7 + v7[2] + 16;
      }
      a1((char *)v7 + *v7, v8);
      uint64_t PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v7);
      int v10 = v7 + 3;
      if (PreoptimizedHeaderRW) {
        int v10 = (void *)PreoptimizedHeaderRW;
      }
      int v7 = (void *)(*v10 & 0xFFFFFFFFFFFFFFFCLL);
    }
    while (v7);
  }
  if (a1) {
    int v11 = a1;
  }
  else {
    int v11 = 0;
  }
  unsigned int v14 = v11;
  char v15 = 2;
  GlobalSmallVector<loadImageCallback,4u>::append((uint64_t)&v14, a2, a3, a4);
  int v12 = *(_DWORD *)(StatusReg + 24);
  int v13 = v12;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v13, 0, memory_order_release, memory_order_relaxed);
  if (v13 != v12) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
}

void sub_1801299CC(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

uint64_t getPreoptimizedHeaderRW(uint64_t a1)
{
  if ((*(unsigned char *)(*(void *)(a1 + 8) + a1 + 8 + 4) & 8) == 0) {
    return 0;
  }
  if (!headerInfoROs || objc_debug_headerInfoRWs == 0) {
    return 0;
  }
  else {
    return objc_debug_headerInfoRWs
  }
         + ((uint64_t)(((a1 - headerInfoROs - 8) / (unint64_t)*(unsigned int *)(headerInfoROs + 4)) << 32) >> 29)
         + 8;
}

uint64_t GlobalSmallVector<loadImageCallback,4u>::append(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  if (loadImageCallbacks[0] <= 3u)
  {
    int v5 = &loadImageCallbacks[4 * loadImageCallbacks[0] + 2];
LABEL_12:
    uint64_t result = loadImageCallback::operator=((uint64_t)v5, a1, a3, a4);
    goto LABEL_15;
  }
  if (loadImageCallbacks[0] != 4)
  {
    int v16 = (char *)malloc_type_malloc(16 * (loadImageCallbacks[0] + 1), 0x10C0040E6EFC850uLL);
    if (loadImageCallbacks[0])
    {
      uint64_t v17 = 0;
      unint64_t v18 = 0;
      do
      {
        loadImageCallback::operator=((uint64_t)&v16[v17], qword_1EB1CADE8 + v17, v14, v15);
        ++v18;
        v17 += 16;
      }
      while (v18 < loadImageCallbacks[0]);
    }
    free((void *)qword_1EB1CADE8);
    qword_1EB1CADE8 = (uint64_t)v16;
    int v5 = (int *)&v16[16 * loadImageCallbacks[0]];
    goto LABEL_12;
  }
  int v6 = malloc_type_malloc(0x50uLL, 0x10C0040E6EFC850uLL);
  uint64_t v9 = (uint64_t)v6;
  if (loadImageCallbacks[0])
  {
    unint64_t v10 = 0;
    int v11 = &qword_1EB1CADE8;
    do
    {
      uint64_t v12 = loadImageCallback::operator=((uint64_t)v6, (uint64_t)v11, v7, v8);
      ++v10;
      uint64_t v13 = loadImageCallbacks[0];
      int v6 = (void *)(v12 + 16);
      v11 += 2;
    }
    while (v10 < loadImageCallbacks[0]);
  }
  else
  {
    uint64_t v13 = 0;
  }
  uint64_t result = loadImageCallback::operator=(v9 + 16 * v13, a1, v7, v8);
  qword_1EB1CADE8 = v9;
LABEL_15:
  ++loadImageCallbacks[0];
  return result;
}

void *copyClassNamesForImage_nolock(header_info *a1, unsigned int *a2)
{
  unint64_t v13 = 0;
  uint64_t v3 = (unint64_t *)header_info::classlist(a1, &v13);
  unint64_t v4 = v13;
  int v5 = malloc_type_malloc(8 * v13 + 8, 0x50040EE9192B6uLL);
  int v6 = v5;
  if (v4)
  {
    uint64_t v7 = 0;
    uint64_t v8 = v5;
    unint64_t v9 = v4;
    do
    {
      unint64_t v10 = (objc_class *)remapClass(*v3);
      if (v10) {
        v8[-v7] = objc_class::demangledName(v10, 0);
      }
      else {
        ++v7;
      }
      ++v8;
      ++v3;
      --v9;
    }
    while (v9);
    uint64_t v11 = v4 - v7;
  }
  else
  {
    uint64_t v11 = 0;
  }
  v6[v11] = 0;
  if (a2) {
    *a2 = v11;
  }
  return v6;
}

void *std::__function::__value_func<void ()(segment_command_64 const*,long)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if (*(void *)a1) {
    unint64_t v4 = *(char ***)a1;
  }
  else {
    unint64_t v4 = 0;
  }
  unsigned int v5 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
  unsigned int v6 = v5 | (v5 >> 4) | ((v5 | (v5 >> 4)) >> 8);
  int v7 = v6 | HIWORD(v6);
  if ((v7 + 1) > 4) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 4;
  }
  *(_DWORD *)(a1 + 16) = v8;
  unint64_t v9 = malloc_type_malloc(8 * v8, 0x64B88C75uLL);
  if (v9)
  {
    *(void *)a1 = v9;
    if (v4)
    {
      unint64_t v10 = &v4[v3];
      *(void *)(a1 + 8) = 0;
LABEL_13:
      uint64_t v11 = *(unsigned int *)(a1 + 16);
      if (v11) {
        memset(v9, 255, 8 * v11);
      }
      if (v3)
      {
        uint64_t v12 = v4;
        do
        {
          unint64_t v13 = *v12;
          if (!objc::DenseMapInfo<char const*>::isEqual(*v12, (char *)0xFFFFFFFFFFFFFFFFLL)
            && !objc::DenseMapInfo<char const*>::isEqual(v13, (char *)0xFFFFFFFFFFFFFFFELL))
          {
            char v15 = 0;
            objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::LookupBucketFor<char const*>(a1, v13, &v15);
            *char v15 = *v12;
            ++*(_DWORD *)(a1 + 8);
          }
          ++v12;
        }
        while (v12 != v10);
      }
      free(v4);
      return;
    }
    *(void *)(a1 + 8) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    unint64_t v9 = 0;
    if (v4)
    {
      unint64_t v10 = &v4[v3];
      *(void *)(a1 + 8) = 0;
      goto LABEL_13;
    }
    *(void *)(a1 + 8) = 0;
  }
  uint64_t v14 = *(unsigned int *)(a1 + 16);
  if (v14)
  {
    memset(v9, 255, 8 * v14);
  }
}

uint64_t header_info::selrefs(header_info *this, unint64_t *a2)
{
  uint64_t result = _dyld_lookup_section_info();
  unint64_t v5 = v4 >> 3;
  if (!result) {
    unint64_t v5 = 0;
  }
  *a2 = v5;
  return result;
}

uint64_t NXMapInsert(uint64_t (***a1)(void), uint64_t a2, uint64_t a3)
{
  unsigned int v6 = (**a1)(a1);

  return NXMapInsertWithHash((uint64_t)a1, a2, v6, a3);
}

uint64_t NXMapKeyCopyingInsert(uint64_t *a1, const char *a2, uint64_t a3)
{
  unsigned int v6 = (*(uint64_t (**)(uint64_t *))*a1)(a1);
  int v7 = (void *)_NXMapMemberWithHash(a1, (uint64_t)a2, v6, &v11);
  if (v7 == (void *)-1)
  {
    size_t v8 = strlen(a2) + 1;
    if (_dyld_is_memory_immutable())
    {
      int v7 = (void *)a2;
    }
    else
    {
      int v7 = malloc_type_malloc(v8, 0x3F84A03uLL);
      memcpy(v7, a2, v8);
    }
  }
  unsigned int v9 = (*(uint64_t (**)(uint64_t *, void *))*a1)(a1, v7);

  return NXMapInsertWithHash((uint64_t)a1, (uint64_t)v7, v9, a3);
}

unint64_t _mapPtrHash(uint64_t a1, unint64_t a2)
{
  return a2 >> 3;
}

id objc_constructInstance(Class cls, void *bytes)
{
  id result = 0;
  if (!cls || !bytes) {
    return result;
  }
  __int16 v6 = *((_WORD *)cls + 15);
  unint64_t v7 = (unint64_t)cls & 0xFF80000000000007;
  if ((v6 & 0x2000) == 0)
  {
    if (!v7)
    {
      unint64_t v8 = (unint64_t)cls & 0x7FFFFFFFFFFFF8 | 0x100000000000001;
      goto LABEL_8;
    }
LABEL_13:
    _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", (uint64_t)bytes, v2, v3, cls);
  }
  if (v7) {
    goto LABEL_13;
  }
  unint64_t v8 = (unint64_t)cls & 0x7FFFFFFFFFFFF8;
LABEL_8:
  *(void *)bytes = v8;
  id result = bytes;
  if ((v6 & 2) != 0)
  {
    return object_cxxConstructFromClass((void (*)(void))bytes, (objc_class **)cls, 0);
  }
  return result;
}

uint64_t _class_isSwift(uint64_t result)
{
  if (result) {
    return (*(unsigned __int8 *)(result + 32) >> 1) & 1;
  }
  return result;
}

void objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::grow(int a1)
{
  uint64_t v1 = dword_1EB1CAC58;
  if (objc::AssociationsManager::_mapStorage) {
    uint64_t v2 = (uint64_t *)objc::AssociationsManager::_mapStorage;
  }
  else {
    uint64_t v2 = 0;
  }
  unsigned int v3 = (a1 - 1) | ((a1 - 1) >> 1) | (((a1 - 1) | ((a1 - 1) >> 1)) >> 2);
  unsigned int v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
  int v5 = v4 | HIWORD(v4);
  if ((v5 + 1) > 4) {
    unsigned int v6 = v5 + 1;
  }
  else {
    unsigned int v6 = 4;
  }
  dword_1EB1CAC58 = v6;
  unint64_t v7 = malloc_type_malloc(32 * v6, 0x64B88C75uLL);
  if (v7)
  {
    objc::AssociationsManager::_mapStorage = (uint64_t)v7;
    qword_1EB1CAC50 = 0;
    if (v2)
    {
      unint64_t v8 = v7;
LABEL_13:
      if (dword_1EB1CAC58)
      {
        uint64_t v10 = 32 * dword_1EB1CAC58;
        do
        {
          *unint64_t v8 = 1;
          v8 += 4;
          v10 -= 32;
        }
        while (v10);
      }
      if (v1)
      {
        uint64_t v11 = 32 * v1;
        uint64_t v12 = v2 + 1;
        unint64_t v13 = (char *)(v2 + 1);
        do
        {
          uint64_t v14 = *(v12 - 1);
          if ((unint64_t)(v14 - 1) >= 2)
          {
            unint64_t v18 = 0;
            objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::LookupBucketFor<DisguisedPtr<objc_object>>(v14, &v18);
            char v15 = v18;
            *unint64_t v18 = *(v12 - 1);
            v15[2] = 0;
            *((_DWORD *)v15 + 6) = 0;
            v15[1] = 0;
            objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::swap(v15 + 1, v12);
            LODWORD(qword_1EB1CAC50) = qword_1EB1CAC50 + 1;
            if (*v12) {
              int v16 = (void *)*v12;
            }
            else {
              int v16 = 0;
            }
            free(v16);
          }
          v13 += 32;
          v12 += 4;
          v11 -= 32;
        }
        while (v11);
      }
      free(v2);
      return;
    }
    unsigned int v9 = v7;
  }
  else
  {
    unsigned int v9 = 0;
    unint64_t v8 = 0;
    objc::AssociationsManager::_mapStorage = 0;
    qword_1EB1CAC50 = 0;
    if (v2) {
      goto LABEL_13;
    }
  }
  if (dword_1EB1CAC58)
  {
    uint64_t v17 = 32 * dword_1EB1CAC58;
    do
    {
      *unsigned int v9 = 1;
      v9 += 4;
      v17 -= 32;
    }
    while (v17);
  }
}

uint64_t *objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>::swap(uint64_t *result, uint64_t *a2)
{
  if (*result) {
    uint64_t v2 = *result;
  }
  else {
    uint64_t v2 = 0;
  }
  char *result = *a2;
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  *a2 = v3;
  int v4 = *((_DWORD *)result + 2);
  *((_DWORD *)result + 2) = *((_DWORD *)a2 + 2);
  *((_DWORD *)a2 + 2) = v4;
  int v5 = *((_DWORD *)result + 3);
  *((_DWORD *)result + 3) = *((_DWORD *)a2 + 3);
  *((_DWORD *)a2 + 3) = v5;
  int v6 = *((_DWORD *)result + 4);
  *((_DWORD *)result + 4) = *((_DWORD *)a2 + 4);
  *((_DWORD *)a2 + 4) = v6;
  return result;
}

Class class_setSuperclass(Class cls, Class newSuper)
{
  int v4 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v4) {
    os_unfair_lock_lock_with_options();
  }
  if (*((void *)cls + 1)) {
    int v6 = (objc_class *)*((void *)cls + 1);
  }
  else {
    int v6 = 0;
  }
  removeSubclass(v6, cls);
  removeSubclass((objc_class *)(*(void *)v6 & 0xFFFFFFFF8), (objc_class *)(*(void *)cls & 0xFFFFFFFF8));
  *((void *)cls + 1) = newSuper;
  if ((*(void *)newSuper & 0x7FFFFFFFFFFFF8) != 0) {
    uint64_t v7 = *(void *)newSuper & 0x7FFFFFFFFFFFF8;
  }
  else {
    uint64_t v7 = 0;
  }
  *(void *)((*(void *)cls & 0xFFFFFFFF8) + 8) = v7;
  addSubclass((uint64_t)newSuper, cls);
  addSubclass(*(void *)newSuper & 0xFFFFFFFF8, (objc_class *)(*(void *)cls & 0xFFFFFFFF8));
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 3321888768;
  v15[2] = ___ZL13setSuperclassP10objc_classS0__block_invoke;
  v15[3] = &__block_descriptor_33_e8_32c43_ZTSKZL13setSuperclassP10objc_classS0_E3__0_e8_B16__0_8l;
  flushCaches((uint64_t)cls, (uint64_t)"setSuperclass", (const char *)v15, v8);
  uint64_t v9 = *(void *)cls & 0xFFFFFFFF8;
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 3321888768;
  v14[2] = ___ZL13setSuperclassP10objc_classS0__block_invoke_195;
  v14[3] = &__block_descriptor_33_e8_32c43_ZTSKZL13setSuperclassP10objc_classS0_E3__1_e8_B16__0_8l;
  flushCaches(v9, (uint64_t)"setSuperclass", (const char *)v14, v10);
  int v11 = *(_DWORD *)(StatusReg + 24);
  int v12 = v11;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v12, 0, memory_order_release, memory_order_relaxed);
  if (v12 != v11) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return v6;
}

void sub_18012A86C(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

uint64_t removeSubclass(objc_class *a1, objc_class *a2)
{
  ++objc_debug_realized_class_generation_count;
  uint64_t v3 = *((void *)a1 + 4);
  uint64_t result = (uint64_t)a1 + 32;
  int v4 = (void *)((v3 & 0xF00007FFFFFFFF8) + 16);
  int v5 = *(objc_class **)((v3 & 0xF00007FFFFFFFF8) + 0x10);
  if (v5) {
    BOOL v6 = v5 == a2;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    do
    {
      uint64_t v7 = *((void *)v5 + 4);
      int v5 = *(objc_class **)((v7 & 0xF00007FFFFFFFF8) + 0x18);
      if (v5) {
        BOOL v8 = v5 == a2;
      }
      else {
        BOOL v8 = 1;
      }
    }
    while (!v8);
    int v4 = (void *)((v7 & 0xF00007FFFFFFFF8) + 24);
  }
  *int v4 = *(void *)((*((void *)a2 + 4) & 0xF00007FFFFFFFF8) + 0x18);
  return result;
}

BOOL class_addProtocol(Class cls, Protocol *protocol)
{
  if (cls)
  {
    Class v3 = cls;
    if (class_conformsToProtocol(cls, protocol))
    {
      LOBYTE(cls) = 0;
    }
    else
    {
      int v4 = 0;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
      if (v4) {
        os_unfair_lock_lock_with_options();
      }
      BOOL v6 = class_rw_t::extAllocIfNeeded((class_rw_t *)(*((void *)v3 + 4) & 0xF00007FFFFFFFF8));
      uint64_t v7 = malloc_type_malloc(0x10uLL, 0xE73314F2uLL);
      int v12 = v7;
      *uint64_t v7 = 1;
      v7[1] = protocol;
      if (PrintPreopt) {
        BOOL v8 = "protocols";
      }
      else {
        BOOL v8 = 0;
      }
      list_array_tt<property_t,property_list_t,RawPtr>::attachLists(v6 + 3, (uint64_t)&v12, (const char *)1, 0, v8);
      int v9 = *(_DWORD *)(StatusReg + 24);
      int v10 = v9;
      atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v10, 0, memory_order_release, memory_order_relaxed);
      if (v10 != v9) {
        os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
      }
      LOBYTE(cls) = 1;
    }
  }
  return (char)cls;
}

void sub_18012AA7C(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::grow(int a1)
{
  uint64_t v1 = dword_1EB1CB0C8;
  if (objc::unattachedCategories) {
    uint64_t v2 = (char *)objc::unattachedCategories;
  }
  else {
    uint64_t v2 = 0;
  }
  unsigned int v3 = (a1 - 1) | ((a1 - 1) >> 1) | (((a1 - 1) | ((a1 - 1) >> 1)) >> 2);
  unsigned int v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
  int v5 = v4 | HIWORD(v4);
  if ((v5 + 1) > 4) {
    unsigned int v6 = v5 + 1;
  }
  else {
    unsigned int v6 = 4;
  }
  dword_1EB1CB0C8 = v6;
  uint64_t v7 = malloc_type_malloc(24 * v6, 0x64B88C75uLL);
  if (v7)
  {
    objc::unattachedCategories = (uint64_t)v7;
    qword_1EB1CB0C0 = 0;
    if (v2)
    {
      BOOL v8 = v7;
LABEL_13:
      if (dword_1EB1CB0C8)
      {
        uint64_t v10 = 24 * dword_1EB1CB0C8;
        do
        {
          *BOOL v8 = -1;
          v8 += 3;
          v10 -= 24;
        }
        while (v10);
      }
      if (v1)
      {
        uint64_t v11 = 24 * v1;
        int v12 = v2 + 8;
        do
        {
          unint64_t v13 = *((void *)v12 - 1);
          if (v13 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            uint64_t v17 = 0;
            objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::LookupBucketFor<objc_class *>(v13, &v17);
            uint64_t v14 = v17;
            uint64_t v15 = *((void *)v12 - 1);
            *(void *)(v17 + 8) = 0;
            *(void *)(v14 + 16) = 0;
            *(void *)uint64_t v14 = v15;
            *(_OWORD *)(v14 + 8) = *(_OWORD *)v12;
            *(void *)int v12 = 0;
            *((void *)v12 + 1) = 0;
            LODWORD(qword_1EB1CB0C0) = qword_1EB1CB0C0 + 1;
          }
          v12 += 24;
          v11 -= 24;
        }
        while (v11);
      }
      free(v2);
      return;
    }
    int v9 = v7;
  }
  else
  {
    int v9 = 0;
    BOOL v8 = 0;
    objc::unattachedCategories = 0;
    qword_1EB1CB0C0 = 0;
    if (v2) {
      goto LABEL_13;
    }
  }
  if (dword_1EB1CB0C8)
  {
    uint64_t v16 = 24 * dword_1EB1CB0C8;
    do
    {
      *int v9 = -1;
      v9 += 3;
      v16 -= 24;
    }
    while (v16);
  }
}

void loadAllCategoriesIfNeeded()
{
  if ((didInitialAttachCategories & 1) == 0 && didCallDyldNotifyRegister)
  {
    if (PrintImages) {
      _objc_inform("IMAGES: performing initial category attach\n");
    }
    uint64_t v0 = (header_info *)FirstHeader;
    if (FirstHeader)
    {
      do
      {
        load_categories_nolock(v0);
        uint64_t PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v0);
        uint64_t v2 = (void *)((char *)v0 + 24);
        if (PreoptimizedHeaderRW) {
          uint64_t v2 = (void *)PreoptimizedHeaderRW;
        }
        uint64_t v0 = (header_info *)(*v2 & 0xFFFFFFFFFFFFFFFCLL);
      }
      while (v0);
    }
    didInitialAttachCategories = 1;
  }
}

void load_categories_nolock(header_info *a1)
{
  uint64_t v1 = a1;
  uint64_t v21 = a1;
  uint64_t v2 = (void *)((char *)a1 + 8);
  int v3 = *(_DWORD *)((char *)a1 + *((void *)a1 + 1) + 12);
  BOOL v4 = DisablePreattachedCategories == 0;
  int v5 = v3 & v4;
  char v20 = v3 & v4;
  int v6 = dyld_shared_cache_some_image_overridden();
  int v7 = v6;
  BOOL v19 = (*((unsigned char *)v2 + *v2 + 4) & 0x40) != 0;
  unint64_t v18 = 0;
  v17[0] = &v18;
  v17[1] = &v21;
  v17[2] = &v19;
  v17[3] = &v20;
  if ((didInitialAttachCategories & 1) == 0 && (v5 ? (BOOL v8 = v6 == 0) : (BOOL v8 = 0), v8))
  {
    if (PrintPreopt)
    {
      int v9 = (char *)v1 + *(void *)v1;
      uint64_t v10 = (const char *)dyld_image_path_containing_address();
      _objc_inform("PREOPTIMIZATION: IGNORING preoptimized categories in image %p %s", v9, v10);
    }
  }
  else
  {
    if (PrintPreopt)
    {
      uint64_t v15 = (char *)v1 + *(void *)v1;
      uint64_t v16 = (const char *)dyld_image_path_containing_address();
      _objc_inform("PREOPTIMIZATION: SCANNING categories in image %p %s - didInitialAttachCategories=%d hi->info()->dyldCategoriesOptimized()=%d hasRoot=%d", v15, v16, didInitialAttachCategories, *(_DWORD *)((unsigned char *)v21 + *((void *)v21 + 1) + 12) & 1, v7);
      uint64_t v1 = v21;
    }
    uint64_t v11 = header_info::catlist(v1, &v18);
    load_categories_nolock(header_info *)::$_0::operator()((uint64_t)v17, v11);
  }
  uint64_t v12 = _dyld_lookup_section_info();
  unint64_t v14 = v13 >> 3;
  if (!v12) {
    unint64_t v14 = 0;
  }
  unint64_t v18 = v14;
  load_categories_nolock(header_info *)::$_0::operator()((uint64_t)v17, v12);
}

void load_categories_nolock(header_info *)::$_0::operator()(uint64_t a1, uint64_t a2)
{
  if (**(void **)a1)
  {
    uint64_t v4 = 0;
    unsigned int v5 = 1;
    unint64_t v7 = dataSegmentsRanges;
    unint64_t v6 = *(void *)algn_1EB1CB078;
    do
    {
      BOOL v8 = *(const char ***)(a2 + 8 * v4);
      int v9 = (uint64_t *)remapClass((unint64_t)v8[1]);
      uint64_t v10 = **(const char ****)(a1 + 8);
      v27[0] = v8;
      v27[1] = v10;
      if (!v9)
      {
        if (PrintConnecting) {
          _objc_inform("CLASS: IGNORING category ???(%s) %p with missing weak-linked target class", *v8, v8);
        }
        goto LABEL_35;
      }
      uint64_t v11 = (objc_class *)v9;
      if ((unint64_t)(*v9 - 1) > 0xE)
      {
        if ((didInitialAttachCategories & 1) == 0)
        {
          BOOL v15 = !**(unsigned char **)(a1 + 24) || v7 > (unint64_t)v9;
          if (!v15 && v6 > (unint64_t)v9)
          {
            unint64_t v17 = class_data_bits_t::safe_ro<(Authentication)0>(v9 + 4);
            if (v7 <= v17 && v6 > v17) {
              goto LABEL_35;
            }
          }
        }
        if (v8[2] || v8[4] || v8[5])
        {
          if ((unint64_t)(*(void *)v11 - 1) >= 0xF
            && (*(_DWORD *)(*((void *)v11 + 4) & 0xF00007FFFFFFFF8) & 0x80000000) != 0)
          {
            if (PrintConnecting)
            {
              uint64_t v26 = *v8;
              uint64_t v21 = objc_class::nameForLogging(v11);
              _objc_inform("CLASS: Attaching category (%s) %p to class %s", v26, v8, v21);
            }
            attachCategories((uint64_t)v11, (uint64_t)v27, (const char *)1, (char *)v11, 8);
          }
          else
          {
            if (PrintConnecting)
            {
              int v24 = *v8;
              BOOL v19 = objc_class::nameForLogging(v11);
              _objc_inform("CLASS: Adding unattached category (%s) %p for class %s", v24, v8, v19);
            }
            objc::UnattachedCategories::addForClass(v8, v10, v11);
          }
        }
        if (!v8[3] && !v8[4] && (!**(unsigned char **)(a1 + 16) || !v8[6])) {
          goto LABEL_35;
        }
        unint64_t v14 = (objc_class *)(*(void *)v11 & 0xFFFFFFFF8);
        if ((unint64_t)(*(void *)v14 - 1) >= 0xF
          && (*(_DWORD *)(*(void *)((*(void *)v11 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8) & 0x80000000) != 0)
        {
          if (PrintConnecting)
          {
            int v22 = *v8;
            int v23 = objc_class::nameForLogging(v11);
            _objc_inform("CLASS: Attaching category (%s) %p to metaclass %s", v22, v8, v23);
            unint64_t v14 = (objc_class *)(*(void *)v11 & 0xFFFFFFFF8);
          }
          attachCategories((uint64_t)v14, (uint64_t)v27, (const char *)1, (char *)v11, 10);
          goto LABEL_35;
        }
        if (PrintConnecting)
        {
          uint64_t v25 = *v8;
          char v20 = objc_class::nameForLogging(v11);
          _objc_inform("CLASS: Adding unattached category (%s) %p for metaclass %s", v25, v8, v20);
          unint64_t v14 = (objc_class *)(*(void *)v11 & 0xFFFFFFFF8);
        }
        uint64_t v12 = v8;
        unint64_t v13 = v10;
      }
      else
      {
        if (!v8[2] && !v8[4] && !v8[5] && !v8[3] && (!**(unsigned char **)(a1 + 16) || !v8[6])) {
          goto LABEL_35;
        }
        uint64_t v12 = v8;
        unint64_t v13 = v10;
        unint64_t v14 = v11;
      }
      objc::UnattachedCategories::addForClass(v12, v13, v14);
LABEL_35:
      uint64_t v4 = v5;
      BOOL v15 = **(void **)a1 > (unint64_t)v5++;
    }
    while (v15);
  }
}

void objc::UnattachedCategories::addForClass(const char **a1, const char **a2, objc_class *this)
{
  if (PrintConnecting)
  {
    uint64_t v18 = 45;
    if ((unint64_t)(*(void *)this - 1) >= 0xF)
    {
      if (*(_DWORD *)(*((void *)this + 4) & 0xF00007FFFFFFFF8)) {
        uint64_t v18 = 43;
      }
      else {
        uint64_t v18 = 45;
      }
    }
    BOOL v19 = objc_class::nameForLogging(this);
    _objc_inform("CLASS: found category %c%s(%s)", v18, v19, *a1);
  }
  uint64_t v21 = 0;
  char v6 = objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::LookupBucketFor<objc_class *>((unint64_t)this, &v21);
  uint64_t v7 = v21;
  if (v6)
  {
    BOOL v8 = (void **)(v21 + 8);
    uint64_t v9 = *(void *)(v21 + 16);
    if (v9)
    {
      unsigned int v13 = v9 >> 1;
      unint64_t v14 = (char *)*v8;
      if (v9 >> 1 == HIDWORD(v9))
      {
        int v15 = 1 << (30 - __clz(v13));
        if (v9 < 0x10) {
          int v15 = 2;
        }
        unsigned int v16 = v15 + v13;
        *(void *)(v21 + 16) = *(void *)(v21 + 16) | ((unint64_t)v16 << 32);
        unint64_t v14 = (char *)reallocf(v14, 16 * v16);
        *(void *)(v7 + 8) = v14;
        uint64_t v9 = *(void *)(v7 + 16);
      }
      *(void *)(v7 + 16) = v9 & 0xFFFFFFFF00000001 | (2
                                                        * (((unint64_t)(v9 + 2) >> 1) & 0x7FFFFFFF));
      unint64_t v17 = (const char ***)&v14[16 * (v9 >> 1)];
      *unint64_t v17 = a1;
      v17[1] = a2;
    }
    else if (*v8)
    {
      uint64_t v10 = malloc_type_malloc(0x20uLL, 0x907FE284uLL);
      *(_OWORD *)uint64_t v10 = *(_OWORD *)v8;
      v10[2] = a1;
      v10[3] = a2;
      *(void *)(v7 + 8) = v10;
      *(void *)(v7 + 16) = 0x200000005;
    }
    else
    {
      *(void *)(v21 + 8) = a1;
      *(void *)(v7 + 16) = a2;
    }
    return;
  }
  *(void *)&long long v11 = a1;
  int v12 = dword_1EB1CB0C8;
  if (4 * (int)qword_1EB1CB0C0 + 4 >= (3 * dword_1EB1CB0C8))
  {
    int v12 = 2 * dword_1EB1CB0C8;
    goto LABEL_28;
  }
  if (dword_1EB1CB0C8 + ~qword_1EB1CB0C0 - HIDWORD(qword_1EB1CB0C0) <= dword_1EB1CB0C8 >> 3)
  {
LABEL_28:
    objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::grow(v12);
    uint64_t v21 = 0;
    objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::LookupBucketFor<objc_class *>((unint64_t)this, &v21);
    *(void *)&long long v11 = a1;
    uint64_t v7 = v21;
  }
  *((void *)&v11 + 1) = a2;
  if (*(void *)v7 == -2)
  {
    qword_1EB1CB0C0 = (uint64_t)vadd_s32((int32x2_t)qword_1EB1CB0C0, (int32x2_t)0xFFFFFFFF00000001);
  }
  else if (*(void *)v7 == -1)
  {
    LODWORD(qword_1EB1CB0C0) = qword_1EB1CB0C0 + 1;
  }
  else if (*(unsigned char *)(v7 + 16))
  {
    long long v20 = v11;
    free(*(void **)(v7 + 8));
    long long v11 = v20;
  }
  *(void *)uint64_t v7 = this;
  *(_OWORD *)(v7 + 8) = v11;
}

uint64_t objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::LookupBucketFor<objc_class *>(unint64_t a1, void *a2)
{
  if (dword_1EB1CB0C8)
  {
    int v2 = dword_1EB1CB0C8 - 1;
    unsigned int v3 = (dword_1EB1CB0C8 - 1) & (bswap64(0x8A970BE7488FDA55 * (a1 ^ (a1 >> 4))) ^ (1217387093 * (a1 ^ (a1 >> 4))));
    uint64_t v4 = (void *)(objc::unattachedCategories + 24 * v3);
    uint64_t v5 = *v4;
    if (*v4 == a1)
    {
      uint64_t v6 = 1;
    }
    else
    {
      BOOL v8 = 0;
      unsigned int v9 = 1;
      while (v5 != -1)
      {
        if (v9 > dword_1EB1CB0C8) {
          objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::FatalCorruptHashTables((void *)objc::unattachedCategories, dword_1EB1CB0C8);
        }
        if (v8) {
          BOOL v10 = 0;
        }
        else {
          BOOL v10 = v5 == -2;
        }
        if (v10) {
          BOOL v8 = v4;
        }
        unsigned int v11 = v3 + v9++;
        unsigned int v3 = v11 & v2;
        uint64_t v4 = (void *)(objc::unattachedCategories + 24 * (v11 & v2));
        uint64_t v5 = *v4;
        uint64_t v6 = 1;
        if (*v4 == a1) {
          goto LABEL_5;
        }
      }
      uint64_t v6 = 0;
      if (v8) {
        uint64_t v4 = v8;
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v6 = 0;
  }
LABEL_5:
  *a2 = v4;
  return v6;
}

BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)
{
  if (!cls) {
    return 0;
  }
  int v8 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v8, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v8) {
    os_unfair_lock_lock_with_options();
  }
  if (types) {
    BOOL v10 = (char *)types;
  }
  else {
    BOOL v10 = "";
  }
  BOOL v11 = addMethod(cls, (objc_selector *)name, imp, v10, 0) == 0;
  int v12 = *(_DWORD *)(StatusReg + 24);
  int v13 = v12;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v13, 0, memory_order_release, memory_order_relaxed);
  if (v13 != v12) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return v11;
}

void sub_18012B768(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

unint64_t addMethod(objc_class *a1, objc_selector *a2, void (*a3)(void), char *a4, char a5)
{
  uint64_t v6 = a4;
  if ((unint64_t)(*(void *)a1 - 1) < 0xF
    || (*(_DWORD *)(*((void *)a1 + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
    || (uint64_t v10 = *(unsigned __int16 *)((*((void *)a1 + 4) & 0xF00007FFFFFFFF8) + 4),
        dword_1EB1CB088 <= v10)
    || (*(void *)(qword_1EB1CB080 + 16 * v10) <= (unint64_t)a1
      ? (BOOL v11 = *(void *)(qword_1EB1CB080 + 16 * v10 + 8) > (unint64_t)a1)
      : (BOOL v11 = 0),
        !v11))
  {
    if (objc::allocatedClasses + 8 * qword_1EB1CAEA0 == objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::find((unint64_t)a1)
      && (dataSegmentsContain(a1, v21, (unsigned int *)a3) & 1) == 0)
    {
      _objc_fatal("Attempt to use unknown class %p.", v22, (const char *)a3, a4, a1);
    }
  }
  unint64_t MethodNoSuper_nolock = getMethodNoSuper_nolock(a1, a2, (const char *)a3, a4);
  if (MethodNoSuper_nolock)
  {
    if (a5)
    {
      return _method_setImplementation(a1, MethodNoSuper_nolock, a3);
    }
    else
    {
      return method_t::imp(MethodNoSuper_nolock, 0);
    }
  }
  else
  {
    unint64_t v14 = (method_list_t *)((unint64_t)malloc_type_calloc(0x20uLL, 1uLL, 0xB48A38ECuLL) | 0x8000000000000000);
    *(void *)unint64_t v14 = 0x10000001BLL;
    int v15 = (void *)(((unint64_t)v14 + 8) & 0xFFFFFFFFFFFFFFFCLL);
    if (a2) {
      unsigned int v16 = a2;
    }
    else {
      unsigned int v16 = 0;
    }
    *int v15 = v16;
    size_t v17 = strlen(v6) + 1;
    if ((_dyld_is_memory_immutable() & 1) == 0)
    {
      uint64_t v18 = malloc_type_malloc(v17, 0x3F84A03uLL);
      memcpy(v18, v6, v17);
      uint64_t v6 = (const char *)v18;
    }
    if (v6) {
      BOOL v19 = v6;
    }
    else {
      BOOL v19 = 0;
    }
    v15[1] = v19;
    if (a3) {
      long long v20 = a3;
    }
    else {
      long long v20 = 0;
    }
    v15[2] = v20;
    addMethods_finish(a1, v14);
    return 0;
  }
}

void attachCategories(uint64_t a1, uint64_t a2, const char *a3, char *a4, int a5)
{
  char v5 = a5;
  unsigned int v6 = a3;
  uint64_t v7 = (const char ***)a2;
  uint64_t v59 = a1;
  int v58 = a5;
  if (PrintReplacedMethods) {
    printReplacements((_WORD *)a1, a2, a3, a4);
  }
  if (PrintConnecting)
  {
    if ((v5 & 8) != 0) {
      uint64_t v39 = " existing";
    }
    else {
      uint64_t v39 = "";
    }
    uint64_t v40 = objc_class::nameForLogging((objc_class *)a1);
    int v8 = v5 & 2;
    uint64_t v41 = " (meta)";
    if ((v5 & 2) == 0) {
      uint64_t v41 = "";
    }
    _objc_inform("CLASS: attaching %d categories to%s class '%s'%s", v6, v39, v40, v41);
    if (v6)
    {
      uint64_t v42 = v6;
      int v43 = v7;
      do
      {
        int v44 = *v43;
        v43 += 2;
        _objc_inform("    category: (%s) %p", *v44, v44);
        --v42;
      }
      while (v42);
    }
  }
  else
  {
    int v8 = v5 & 2;
  }
  v55[128] = 0;
  v56[128] = 0;
  v57[128] = 0;
  v52[128] = 0;
  v53[128] = 0;
  v54[128] = 0;
  uint64_t v9 = *(void *)(a1 + 32);
  char v51 = 0;
  uint64_t v10 = class_rw_t::extAllocIfNeeded((class_rw_t *)(v9 & 0xF00007FFFFFFFF8));
  unint64_t v50 = v10;
  if (v6)
  {
    char v11 = 0;
    uint64_t v12 = v6;
    uint64_t v46 = v10 + 2;
    unint64_t v47 = v10 + 1;
    uint64_t v45 = v10 + 3;
    do
    {
      int v13 = *v7;
      unint64_t v14 = *v7;
      if (v8)
      {
        int v15 = v14[3];
        if (v15) {
          goto LABEL_9;
        }
      }
      else
      {
        int v15 = v14[2];
        if (v15)
        {
LABEL_9:
          unsigned int v16 = v15;
          goto LABEL_12;
        }
      }
      unsigned int v16 = 0;
LABEL_12:
      size_t v17 = v7[1];
      int v18 = *((unsigned __int8 *)v17 + (void)v17[1] + 12);
      BOOL v19 = DisablePreattachedCategories == 0;
      char v20 = v18 & v19;
      if ((v18 & v19) != 0) {
        uint64_t v21 = v55;
      }
      else {
        uint64_t v21 = v52;
      }
      if (v16)
      {
        if ((v18 & (DisablePreattachedCategories == 0)) != 0) {
          uint64_t v22 = v55;
        }
        else {
          uint64_t v22 = v52;
        }
        unsigned int v23 = v22[128];
        if (v23 >= 0x40)
        {
          prepareMethodLists((objc_class *)a1, (method_list_t **)v21, v23, 0, v11 != 0, "attachCategories");
          if (PrintPreopt) {
            uint64_t v25 = "methods";
          }
          else {
            uint64_t v25 = 0;
          }
          list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists(v47, (uint64_t)v21, (const char *)v22[128], (char *)(v20 & 1), v25, v24);
          unsigned int v23 = 0;
          int v13 = *v7;
          size_t v17 = v7[1];
        }
        v22[128] = v23 + 1;
        *(void *)&v21[2 * (v23 ^ 0x3F)] = v16;
        v11 |= *(_DWORD *)((char *)v17 + (void)*v17 + 12) == 8;
        char v51 = v11;
      }
      if (!v8)
      {
        uint64_t v26 = (uint64_t *)(v13 + 5);
        goto LABEL_29;
      }
      if ((*((unsigned char *)v17 + (void)v17[1] + 12) & 0x40) != 0)
      {
        uint64_t v26 = (uint64_t *)(v13 + 6);
LABEL_29:
        uint64_t v27 = *v26;
        if (*v26)
        {
          if (v20) {
            uint64_t v28 = v56;
          }
          else {
            uint64_t v28 = v53;
          }
          if (v20) {
            uint64_t v29 = v55;
          }
          else {
            uint64_t v29 = v52;
          }
          unsigned int v30 = v29[258];
          if (v30 >= 0x40)
          {
            if (v20) {
              BOOL v31 = v55;
            }
            else {
              BOOL v31 = v52;
            }
            if (PrintPreopt) {
              unint64_t v32 = "properties";
            }
            else {
              unint64_t v32 = 0;
            }
            list_array_tt<property_t,property_list_t,RawPtr>::attachLists(v46, (uint64_t)v28, (const char *)v31[258], (char *)(v20 & 1), v32);
            unsigned int v30 = 0;
            int v13 = *v7;
          }
          v29[258] = v30 + 1;
          *(void *)&v28[2 * (v30 ^ 0x3F)] = v27;
        }
        if (!v8)
        {
          unint64_t v33 = v13[4];
          if (v33)
          {
            if (v20) {
              uint64_t v34 = v57;
            }
            else {
              uint64_t v34 = v54;
            }
            if (v20) {
              uint64_t v35 = v55;
            }
            else {
              uint64_t v35 = v52;
            }
            unsigned int v36 = v35[388];
            if (v36 >= 0x40)
            {
              if (v20) {
                uint64_t v37 = v55;
              }
              else {
                uint64_t v37 = v52;
              }
              if (PrintPreopt) {
                long long v38 = "protocols";
              }
              else {
                long long v38 = 0;
              }
              list_array_tt<property_t,property_list_t,RawPtr>::attachLists(v45, (uint64_t)v34, (const char *)v37[388], (char *)(v20 & 1), v38);
              unsigned int v36 = 0;
            }
            v35[388] = v36 + 1;
            *(void *)&v34[2 * (v36 ^ 0x3F)] = v33;
          }
        }
      }
      v7 += 2;
      --v12;
    }
    while (v12);
  }
  v49[0] = &v59;
  v49[1] = (uint64_t *)&v51;
  v49[2] = (uint64_t *)&v50;
  v49[3] = (uint64_t *)&v58;
  attachCategories(objc_class *,locstamped_category_t const*,unsigned int,objc_class *,int)::$_0::operator()(v49, v55, (char *)1);
  attachCategories(objc_class *,locstamped_category_t const*,unsigned int,objc_class *,int)::$_0::operator()(v49, v52, 0);
}

void attachCategories(objc_class *,locstamped_category_t const*,unsigned int,objc_class *,int)::$_0::operator()(uint64_t **a1, unsigned int *a2, char *a3)
{
  uint64_t v6 = a2[128];
  if (v6)
  {
    uint64_t v7 = a2 + 128;
    prepareMethodLists((objc_class *)**a1, (method_list_t **)&a2[-2 * v6 + 128], v6, 0, *(unsigned __int8 *)a1[1], "operator()");
    uint64_t v9 = PrintPreopt ? "methods" : 0;
    list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists((unint64_t *)(*a1[2] + 8), (uint64_t)&v7[-2 * *v7], (const char *)*v7, a3, v9, v8);
    if ((*(unsigned char *)a1[3] & 8) != 0)
    {
      uint64_t v11 = **a1;
      v14[0] = MEMORY[0x1E4F143A8];
      v14[1] = 3321888768;
      v14[2] = ___ZZL16attachCategoriesP10objc_classPK21locstamped_category_tjS0_iENK3__0clEPZL16attachCategoriesS0_S3_jS0_iE5Listsb_block_invoke;
      v14[3] = &__block_descriptor_33_e8_32c127_ZTSKZZL16attachCategoriesP10objc_classPK21locstamped_category_tjS0_iENK3__0clEPZL16attachCategoriesS0_S3_jS0_iE5ListsbEUlS0_E__e8_B16__0_8l;
      flushCaches(v11, (uint64_t)"operator()", (const char *)v14, v10);
    }
  }
  if (PrintPreopt) {
    uint64_t v12 = "properties";
  }
  else {
    uint64_t v12 = 0;
  }
  list_array_tt<property_t,property_list_t,RawPtr>::attachLists((unint64_t *)(*a1[2] + 16), (uint64_t)&a2[-2 * a2[258] + 258], (const char *)a2[258], a3, v12);
  if (PrintPreopt) {
    int v13 = "protocols";
  }
  else {
    int v13 = 0;
  }
  list_array_tt<property_t,property_list_t,RawPtr>::attachLists((unint64_t *)(*a1[2] + 24), (uint64_t)&a2[-2 * a2[388] + 388], (const char *)a2[388], a3, v13);
}

void list_array_tt<property_t,property_list_t,RawPtr>::attachLists(unint64_t *a1, uint64_t a2, const char *a3, char *a4, const char *a5)
{
  if (!a3) {
    return;
  }
  LODWORD(v6) = a3;
  uint64_t v7 = (uint64_t *)a2;
  unint64_t v9 = *a1;
  if (a4)
  {
    if (v9)
    {
      if ((*a1 & 3) == 2 && (v9 & 0xFFFFFFFFFFFFFFFCLL) != 0)
      {
        if (a5) {
          _objc_inform("PREOPTIMIZATION: not attaching preoptimized category, class's %s list %p is still original.", a5, (const void *)(v9 & 0xFFFFFFFFFFFFFFFCLL));
        }
        return;
      }
    }
    if (a5)
    {
      _objc_inform("PREOPTIMIZATION: copying preoptimized category, class's %s list has already been copied.", a5);
      unint64_t v9 = *a1;
      if (*a1) {
        goto LABEL_11;
      }
LABEL_56:
      if (v6 != 1) {
        goto LABEL_59;
      }
      goto LABEL_57;
    }
  }
  if (!v9) {
    goto LABEL_56;
  }
LABEL_11:
  unint64_t v11 = v9;
  if (v6 == 1 && v9 <= 3)
  {
LABEL_57:
    uint64_t v30 = *v7;
    goto LABEL_58;
  }
  if (v9 < 4)
  {
    if (!v9) {
      goto LABEL_30;
    }
LABEL_59:
    unint64_t v20 = 0;
    goto LABEL_60;
  }
  unint64_t v12 = v9 & 3;
  if ((v11 & 3) == 0)
  {
LABEL_30:
    unint64_t v20 = v11 & 0xFFFFFFFFFFFFFFFCLL;
LABEL_60:
    if (v20) {
      unsigned int v42 = v6 + 1;
    }
    else {
      unsigned int v42 = v6;
    }
    unint64_t v43 = (unint64_t)malloc_type_malloc(8 * v42 + 8, 0x7ABC97A5uLL);
    *a1 = v43 | 1;
    *(_DWORD *)unint64_t v43 = v42;
    uint64_t v44 = v6;
    if (v20) {
      *(void *)(v43 + 8 * v6 + 8) = v20;
    }
    uint64_t v45 = (void *)(v43 + 8);
    do
    {
      uint64_t v46 = *v7++;
      *v45++ = v46;
      --v44;
    }
    while (v44);
    goto LABEL_67;
  }
  if (v12 == 1)
  {
    uint64_t v21 = (int *)(v11 & 0xFFFFFFFFFFFFFFFCLL);
    if ((v11 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
      return;
    }
    int v22 = *v21;
    unsigned int v23 = *v21 + v6;
    unint64_t v24 = malloc_type_malloc(8 * v23 + 8, 0xB6D94A04uLL);
    unint64_t v25 = (unint64_t)v24;
    *unint64_t v24 = v23;
    uint64_t v26 = (v22 - 1);
    if (v22 - 1 >= 0)
    {
      do
      {
        *(void *)&v24[2 * (v6 + v26) + 2] = *(void *)&v21[2 * v26 + 2];
        --v26;
      }
      while (v26 != -1);
    }
    if (v6 <= 1) {
      uint64_t v27 = 1;
    }
    else {
      uint64_t v27 = v6;
    }
    uint64_t v28 = v24 + 2;
    do
    {
      uint64_t v29 = *v7++;
      *v28++ = v29;
      --v27;
    }
    while (v27);
    free(v21);
    uint64_t v30 = v25 | 1;
  }
  else
  {
    if (v12 != 2) {
      return;
    }
    int v13 = (unsigned int *)(v11 & 0xFFFFFFFFFFFFFFFCLL);
    if ((v11 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
      return;
    }
    if (DisablePreattachedCategories)
    {
      uint64_t v15 = *v13;
      uint64_t v16 = v13[1];
      unint64_t v47 = v16 * (unint64_t)v15;
      if ((v47 & 0xFFFFFFFF00000000) != 0) {
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v16, v11 & 0xFFFFFFFFFFFFFFFCLL, *v13);
      }
      uint64_t v48 = (uint64_t)v13 + v47 + 8;
      BOOL v49 = v16 == 0;
      if (v16) {
        uint64_t v16 = v16;
      }
      else {
        uint64_t v16 = 0;
      }
      if (v49) {
        unint64_t v14 = (unsigned __int16 *)v48;
      }
      else {
        unint64_t v14 = (unsigned __int16 *)(v48 - v15);
      }
    }
    else
    {
      unint64_t v14 = (unsigned __int16 *)(v13 + 2);
      uint64_t v15 = *v13;
      uint64_t v16 = v13[1];
    }
    unint64_t v17 = v16 * (unint64_t)v15;
    if ((v17 & 0xFFFFFFFF00000000) != 0) {
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v16, v11 & 0xFFFFFFFFFFFFFFFCLL, v15);
    }
    unint64_t v18 = (unint64_t)v13 + v17 + 8;
    if ((unint64_t)v14 < v18)
    {
      while ((*(void *)(objc_debug_headerInfoRWs + 8 * *v14 + 8) & 1) == 0)
      {
        unint64_t v14 = (unsigned __int16 *)((char *)v14 + v15);
        unsigned int v19 = v15;
        if ((unint64_t)v14 >= v18) {
          goto LABEL_41;
        }
      }
    }
    unsigned int v19 = v15;
LABEL_41:
    uint64_t v31 = relative_list_list_t<protocol_list_t>::countLists((unsigned int *)(v11 & 0xFFFFFFFFFFFFFFFCLL), a2, a3, a4)+ v6;
    unint64_t v32 = (unint64_t)malloc_type_malloc(8 * v31 + 8, 0xA45900CBuLL);
    *(_DWORD *)unint64_t v32 = v31;
    unint64_t v33 = (void *)(v32 + 8);
    if (v6 <= 1) {
      uint64_t v6 = 1;
    }
    else {
      uint64_t v6 = v6;
    }
    uint64_t v34 = v6;
    do
    {
      uint64_t v35 = *v7++;
      *v33++ = v35;
      --v34;
    }
    while (v34);
    if (v6 < v31)
    {
      do
      {
        uint64_t v36 = *(void *)v14;
        if (a5)
        {
          unint64_t v50 = (_DWORD *)v32;
          _objc_inform("PREOPTIMIZATION: copying preoptimized %s list %p", a5, (char *)v14 + (v36 >> 16));
          unint64_t v32 = (unint64_t)v50;
          uint64_t v36 = *(void *)v14;
        }
        *(void *)(v32 + 8 * v6 + 8) = (char *)v14 + (v36 >> 16);
        uint64_t v38 = *v13;
        uint64_t v37 = v13[1];
        unint64_t v39 = v37 * (unint64_t)v38;
        if ((v39 & 0xFFFFFFFF00000000) != 0) {
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v37, v13, v38);
        }
        uint64_t v40 = (unsigned __int16 *)((char *)v14 + v19);
        do
        {
          unint64_t v14 = v40;
          if (v40 >= (unsigned __int16 *)((char *)v13 + v39 + 8)) {
            break;
          }
          uint64_t v41 = *(void *)(objc_debug_headerInfoRWs + 8 * *v40 + 8);
          uint64_t v40 = (unsigned __int16 *)((char *)v40 + v19);
        }
        while ((v41 & 1) == 0);
        ++v6;
      }
      while (v6 != v31);
    }
    uint64_t v30 = v32 | 1;
  }
LABEL_58:
  *a1 = v30;
LABEL_67:

  list_array_tt<unsigned long,protocol_list_t,RawPtr>::validate(a1, a2, a3, a4);
}

uint64_t addMethods_finish(objc_class *a1, method_list_t *a2)
{
  uint64_t v4 = *((void *)a1 + 4);
  unint64_t v14 = a2;
  unint64_t v8 = class_rw_t::extAllocIfNeeded((class_rw_t *)(v4 & 0xF00007FFFFFFFF8));
  if (*((_DWORD *)a2 + 1) >= 2u) {
    method_list_t::sortBySELAddress(a2, v5, v6, v7);
  }
  prepareMethodLists(a1, &v14, 1, 0, 0, "addMethods_finish");
  if (PrintPreopt) {
    uint64_t v10 = "methods";
  }
  else {
    uint64_t v10 = 0;
  }
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists(v8 + 1, (uint64_t)&v14, (const char *)1, 0, v10, v9);
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3321888768;
  v13[2] = ___ZL17addMethods_finishP10objc_classP13method_list_t_block_invoke;
  v13[3] = &__block_descriptor_33_e8_32c60_ZTSKZL17addMethods_finishP10objc_classP13method_list_tE3__0_e8_B16__0_8l;
  return flushCaches((uint64_t)a1, (uint64_t)"addMethods_finish", (const char *)v13, v11);
}

unint64_t *class_rw_t::extAllocIfNeeded(class_rw_t *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    return (unint64_t *)(v1 & 0xFFFFFFFFFFFFFFFELL);
  }
  if (v1) {
    unsigned int v3 = (const class_ro_t *)(v1 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    unsigned int v3 = 0;
  }
  return class_rw_t::extAlloc(this, v3, 0);
}

void list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists(unint64_t *a1, uint64_t a2, const char *a3, char *a4, const char *a5, unint64_t a6)
{
  if (!a3) {
    return;
  }
  LODWORD(v7) = a3;
  unint64_t v8 = (uint64_t *)a2;
  unint64_t v10 = *a1;
  if (a4)
  {
    if (v10)
    {
      if ((*a1 & 3) == 2 && (v10 & 0xFFFFFFFFFFFFFFFCLL) != 0)
      {
        if (a5) {
          _objc_inform("PREOPTIMIZATION: not attaching preoptimized category, class's %s list %p is still original.", a5, (const void *)(v10 & 0xFFFFFFFFFFFFFFFCLL));
        }
        return;
      }
    }
    if (a5)
    {
      _objc_inform("PREOPTIMIZATION: copying preoptimized category, class's %s list has already been copied.", a5);
      unint64_t v10 = *a1;
      if (*a1) {
        goto LABEL_11;
      }
LABEL_61:
      if (v7 != 1) {
        goto LABEL_64;
      }
      goto LABEL_62;
    }
  }
  if (!v10) {
    goto LABEL_61;
  }
LABEL_11:
  unint64_t v12 = v10;
  if (v7 == 1 && v10 <= 3)
  {
LABEL_62:
    uint64_t v35 = *v8;
    goto LABEL_63;
  }
  if (v10 < 4)
  {
    if (!v10) {
      goto LABEL_30;
    }
LABEL_64:
    unint64_t v21 = 0;
    goto LABEL_65;
  }
  unint64_t v13 = v10 & 3;
  if ((v12 & 3) == 0)
  {
LABEL_30:
    unint64_t v21 = v12 & 0xFFFFFFFFFFFFFFFCLL;
LABEL_65:
    if (v21) {
      unsigned int v47 = v7 + 1;
    }
    else {
      unsigned int v47 = v7;
    }
    unint64_t v48 = (unint64_t)malloc_type_malloc(8 * v47 + 8, 0x7ABC97A5uLL);
    *a1 = v48 | 1;
    *(_DWORD *)unint64_t v48 = v47;
    uint64_t v49 = v7;
    if (v21) {
      *(void *)(v48 + 8 * v7 + 8) = v21;
    }
    unint64_t v50 = (_DWORD *)(v48 + 8);
    char v51 = (uint64_t *)(v48 + 8);
    do
    {
      *v51++ = *v8;
      v50 += 2;
      ++v8;
      --v49;
    }
    while (v49);
    goto LABEL_72;
  }
  if (v13 == 1)
  {
    int v22 = (int *)(v12 & 0xFFFFFFFFFFFFFFFCLL);
    if ((v12 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
      return;
    }
    int v23 = *v22;
    unsigned int v24 = *v22 + v7;
    unint64_t v25 = malloc_type_malloc(8 * v24 + 8, 0xB6D94A04uLL);
    unint64_t v26 = (unint64_t)v25;
    _DWORD *v25 = v24;
    uint64_t v27 = (v23 - 1);
    if (v23 - 1 >= 0)
    {
      uint64_t v28 = v27 + 1;
      uint64_t v29 = (uint64_t)&v22[2 * v27 + 2];
      do
      {
        if (*(void *)&v22[2 * v28]) {
          uint64_t v30 = *(void *)&v22[2 * v28];
        }
        else {
          uint64_t v30 = 0;
        }
        *(void *)&v25[2 * (v7 + v28 - 1) + 2] = v30;
        v29 -= 8;
      }
      while (v28-- > 1);
    }
    if (v7 <= 1) {
      uint64_t v32 = 1;
    }
    else {
      uint64_t v32 = v7;
    }
    unint64_t v33 = v25 + 2;
    uint64_t v34 = (uint64_t *)(v25 + 2);
    do
    {
      *v34++ = *v8;
      v33 += 2;
      ++v8;
      --v32;
    }
    while (v32);
    free(v22);
    uint64_t v35 = v26 | 1;
  }
  else
  {
    if (v13 != 2) {
      return;
    }
    unint64_t v14 = (unsigned int *)(v12 & 0xFFFFFFFFFFFFFFFCLL);
    if ((v12 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
      return;
    }
    if (DisablePreattachedCategories)
    {
      uint64_t v16 = *v14;
      uint64_t v17 = v14[1];
      unint64_t v52 = v17 * (unint64_t)v16;
      if ((v52 & 0xFFFFFFFF00000000) != 0) {
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v17, v12 & 0xFFFFFFFFFFFFFFFCLL, *v14);
      }
      uint64_t v53 = (uint64_t)v14 + v52 + 8;
      BOOL v54 = v17 == 0;
      if (v17) {
        uint64_t v17 = v17;
      }
      else {
        uint64_t v17 = 0;
      }
      if (v54) {
        uint64_t v15 = (unsigned __int16 *)v53;
      }
      else {
        uint64_t v15 = (unsigned __int16 *)(v53 - v16);
      }
    }
    else
    {
      uint64_t v15 = (unsigned __int16 *)(v14 + 2);
      uint64_t v16 = *v14;
      uint64_t v17 = v14[1];
    }
    unint64_t v18 = v17 * (unint64_t)v16;
    if ((v18 & 0xFFFFFFFF00000000) != 0) {
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v17, v12 & 0xFFFFFFFFFFFFFFFCLL, v16);
    }
    unint64_t v19 = (unint64_t)v14 + v18 + 8;
    if ((unint64_t)v15 < v19)
    {
      while ((*(void *)(objc_debug_headerInfoRWs + 8 * *v15 + 8) & 1) == 0)
      {
        uint64_t v15 = (unsigned __int16 *)((char *)v15 + v16);
        unsigned int v20 = v16;
        if ((unint64_t)v15 >= v19) {
          goto LABEL_46;
        }
      }
    }
    unsigned int v20 = v16;
LABEL_46:
    uint64_t v36 = relative_list_list_t<protocol_list_t>::countLists((unsigned int *)(v12 & 0xFFFFFFFFFFFFFFFCLL), a2, a3, a4)+ v7;
    unint64_t v37 = (unint64_t)malloc_type_malloc(8 * v36 + 8, 0xA45900CBuLL);
    *(_DWORD *)unint64_t v37 = v36;
    uint64_t v38 = (_DWORD *)(v37 + 8);
    if (v7 <= 1) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = v7;
    }
    unint64_t v39 = (uint64_t *)(v37 + 8);
    uint64_t v40 = v7;
    do
    {
      *v39++ = *v8;
      v38 += 2;
      ++v8;
      --v40;
    }
    while (v40);
    if (v7 < v36)
    {
      do
      {
        uint64_t v41 = *(void *)v15;
        if (a5)
        {
          unint64_t v55 = (_DWORD *)v37;
          _objc_inform("PREOPTIMIZATION: copying preoptimized %s list %p", a5, (char *)v15 + (v41 >> 16));
          unint64_t v37 = (unint64_t)v55;
          uint64_t v41 = *(void *)v15;
        }
        *(void *)(v37 + 8 * v7 + 8) = (char *)v15 + (v41 >> 16);
        uint64_t v43 = *v14;
        uint64_t v42 = v14[1];
        unint64_t v44 = v42 * (unint64_t)v43;
        if ((v44 & 0xFFFFFFFF00000000) != 0) {
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v42, v14, v43);
        }
        uint64_t v45 = (unsigned __int16 *)((char *)v15 + v20);
        do
        {
          uint64_t v15 = v45;
          if (v45 >= (unsigned __int16 *)((char *)v14 + v44 + 8)) {
            break;
          }
          uint64_t v46 = *(void *)(objc_debug_headerInfoRWs + 8 * *v45 + 8);
          uint64_t v45 = (unsigned __int16 *)((char *)v45 + v20);
        }
        while ((v46 & 1) == 0);
        ++v7;
      }
      while (v7 != v36);
    }
    uint64_t v35 = v37 | 1;
  }
LABEL_63:
  *a1 = v35;
LABEL_72:

  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::validate(a1, a2, a3, a4, (uint64_t)a5, a6);
}

unint64_t *list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::validate(unint64_t *result, uint64_t a2, const char *a3, char *a4, uint64_t a5, unint64_t a6)
{
  v33[3] = result;
  unint64_t v10 = *result;
  if (!*result) {
    goto LABEL_10;
  }
  unint64_t v11 = *result;
  uint64_t v12 = *result & 3;
  if ((v10 & 3) == 0)
  {
    if ((v10 & 0xFFFFFFFFFFFFFFFCLL) != 0)
    {
      uint64_t v6 = (unsigned int *)(v10 & 0xFFFFFFFFFFFFFFFCLL);
      unint64_t v34 = v10 & 0xFFFFFFFFFFFFFFFCLL;
      goto LABEL_21;
    }
    goto LABEL_10;
  }
  if (v10 <= 3)
  {
LABEL_10:
    uint64_t v6 = 0;
    unint64_t v34 = 0;
    goto LABEL_11;
  }
  if (v12 != 2)
  {
    if (v12 == 1)
    {
      uint64_t v6 = (unsigned int *)(v10 & 0xFFFFFFFFFFFFFFFCLL);
      if ((v10 & 0xFFFFFFFFFFFFFFFCLL) != 0)
      {
        v6 += 2;
        unint64_t v34 = (unint64_t)v6;
      }
    }
    goto LABEL_21;
  }
  uint64_t v6 = (unsigned int *)(v10 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v10 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
    goto LABEL_21;
  }
  if (DisablePreattachedCategories)
  {
    unint64_t v15 = *v6;
    uint64_t v14 = v6[1];
    unint64_t v29 = v14 * (unint64_t)v15;
    if ((v29 & 0xFFFFFFFF00000000) != 0) {
LABEL_69:
    }
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, a5, a6, v14, v11 & 0xFFFFFFFFFFFFFFFCLL, v15);
    unint64_t v30 = v15 | (v14 << 32);
    unint64_t v8 = (char *)v6 + v29 + 8;
    unint64_t v31 = v15 | ((unint64_t)(v14 - 1) << 32);
    BOOL v32 = v14 == 0;
    if (v14) {
      uint64_t v14 = v14;
    }
    else {
      uint64_t v14 = 0;
    }
    if (v32)
    {
      a6 = v30;
    }
    else
    {
      v8 -= v15;
      a6 = v31;
    }
  }
  else
  {
    unint64_t v8 = (char *)(v6 + 2);
    a6 = *v6;
    uint64_t v14 = v6[1];
    unint64_t v15 = a6;
  }
  unint64_t v16 = v14 * (unint64_t)v15;
  if ((v16 & 0xFFFFFFFF00000000) != 0) {
    goto LABEL_69;
  }
  unint64_t v7 = HIDWORD(a6);
  for (i = (unint64_t)v6 + v16 + 8; (unint64_t)v8 < i; unint64_t v7 = (v7 + 1))
  {
    if (*(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v8 + 8)) {
      break;
    }
    v8 += a6;
  }
  unint64_t v34 = v11 & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v35 = a6 | (v7 << 32);
  uint64_t v36 = v8;
LABEL_11:
  if (!v10)
  {
    unint64_t v13 = 0;
LABEL_24:
    v33[0] = 0;
    goto LABEL_31;
  }
LABEL_21:
  unint64_t v13 = (unsigned int *)(v10 & 3);
  if (v13 == (unsigned int *)2)
  {
    unint64_t v13 = (unsigned int *)(v10 & 0xFFFFFFFFFFFFFFFCLL);
    if ((v10 & 0xFFFFFFFFFFFFFFFCLL) != 0)
    {
      uint64_t v18 = *v13;
      uint64_t v17 = v13[1];
      unint64_t v19 = v17 * (unint64_t)v18;
      if ((v19 & 0xFFFFFFFF00000000) != 0) {
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, a5, a6, v17, v10 & 0xFFFFFFFFFFFFFFFCLL, v18);
      }
      unint64_t i = (unint64_t)v13 + v19 + 8;
      v33[0] = v10 & 0xFFFFFFFFFFFFFFFCLL;
      v33[1] = v18 | (v17 << 32);
      v33[2] = i;
    }
  }
  else if (v13 == (unsigned int *)1)
  {
    unint64_t v13 = (unsigned int *)(v10 & 0xFFFFFFFFFFFFFFFCLL);
    if ((v10 & 0xFFFFFFFFFFFFFFFCLL) != 0)
    {
      unint64_t i = *v13;
      v13 += 2 * i + 2;
      v33[0] = v13;
    }
  }
  else
  {
    if ((v10 & 3) == 0) {
      goto LABEL_24;
    }
    unint64_t v13 = 0;
  }
LABEL_31:
  unsigned int v20 = (char *)a6;
  uint64_t v21 = 2 * a6;
LABEL_32:
  int v22 = v8;
  while (1)
  {
    if (!v10)
    {
LABEL_37:
      if (v6)
      {
        int v23 = v6;
        if (v13)
        {
LABEL_39:
          unsigned int v24 = v13;
          goto LABEL_42;
        }
      }
      else
      {
        int v23 = 0;
        if (v13) {
          goto LABEL_39;
        }
      }
      unsigned int v24 = 0;
LABEL_42:
      if (v23 == v24) {
        return result;
      }
      if (!v10) {
        goto LABEL_52;
      }
      goto LABEL_48;
    }
    if ((v10 & 3) == 2)
    {
      if (v8 == (char *)i) {
        return result;
      }
      goto LABEL_48;
    }
    if ((v10 & 3) == 1) {
      break;
    }
    if ((v10 & 3) == 0) {
      goto LABEL_37;
    }
LABEL_48:
    unint64_t v25 = v10 & 3;
    if ((v10 & 3) != 0)
    {
      if (v25 == 2)
      {
        unint64_t v8 = &v20[(void)v8];
        uint64_t v36 = &v20[(void)v22];
        uint64_t v27 = *v6;
        uint64_t v26 = v6[1];
        unint64_t v28 = v26 * (unint64_t)v27;
        LODWORD(v7) = v7 + 1;
        HIDWORD(v35) = v7;
        if ((v28 & 0xFFFFFFFF00000000) != 0) {
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)&v34, (const char *)v33, v20, objc_debug_headerInfoRWs, v21, v26, v6, v27);
        }
        while (v8 < (char *)v6 + v28 + 8)
        {
          if (*(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)&v20[(void)v22] + 8))
          {
            unint64_t v8 = &v20[(void)v22];
            goto LABEL_32;
          }
          uint64_t v36 = &v22[v21];
          LODWORD(v7) = v7 + 1;
          HIDWORD(v35) = v7;
          int v22 = &v20[(void)v22];
          unint64_t v8 = &v20[(void)v22];
        }
        goto LABEL_32;
      }
      if (v25 == 1)
      {
        v6 += 2;
        goto LABEL_53;
      }
    }
    else
    {
LABEL_52:
      uint64_t v6 = 0;
LABEL_53:
      unint64_t v34 = (unint64_t)v6;
    }
  }
  if (v6 != v13) {
    goto LABEL_48;
  }
  return result;
}

uint64_t objc_class::setDisallowPreoptCachesRecursively(uint64_t this, const char *a2)
{
  if ((*(unsigned char *)(*(void *)(this + 32) & 0xF00007FFFFFFFF8) & 2) == 0)
  {
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 3321888768;
    v2[2] = ___ZN10objc_class34setDisallowPreoptCachesRecursivelyEPKc_block_invoke;
    v2[3] = &__block_descriptor_48_e8_32c64_ZTSKZN10objc_class34setDisallowPreoptCachesRecursivelyEPKcE3__0_e8_B16__0_8l;
    void v2[4] = a2;
    v2[5] = this;
    return foreach_realized_class_and_subclass(this, (uint64_t)v2);
  }
  return this;
}

uint64_t flushCaches(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v10 = MEMORY[0x1E4F143A8];
  uint64_t v11 = 3221225472;
  uint64_t v12 = ___ZL11flushCachesP10objc_classPKcU13block_pointerFbS0_E_block_invoke;
  unint64_t v13 = &unk_1E4FBD440;
  uint64_t v14 = a3;
  uint64_t v15 = a2;
  if (a1) {
    return foreach_realized_class_and_subclass(a1, (uint64_t)&v10);
  }
  int v5 = *(_DWORD *)(gdb_objc_realized_classes + 8);
  if (DisablePreopt) {
    uint64_t result = 0;
  }
  else {
    uint64_t result = _dyld_objc_class_count();
  }
  uint64_t v6 = _firstRealizedClass;
  if (_firstRealizedClass)
  {
    int v7 = 16 * (result + v5) + 16;
    do
    {
      if (!--v7) {
LABEL_24:
      }
        _objc_fatal("Memory corruption in class list.", a2, a3, a4, v10, v11);
      uint64_t v8 = v6;
      while (1)
      {
        uint64_t result = v12((uint64_t)&v10, v8);
        if (!result || (uint64_t v9 = *(void *)((*(void *)(v8 + 32) & 0xF00007FFFFFFFF8) + 0x10)) == 0)
        {
          while (1)
          {
            uint64_t v9 = *(void *)((*(void *)(v8 + 32) & 0xF00007FFFFFFFF8) + 0x18);
            if (v8 == v6 || v9) {
              break;
            }
            if (*(void *)(v8 + 8)) {
              uint64_t v8 = *(void *)(v8 + 8);
            }
            else {
              uint64_t v8 = 0;
            }
            if (!--v7) {
              goto LABEL_24;
            }
          }
          if (v8 == v6) {
            break;
          }
        }
        uint64_t v8 = v9;
        if (!--v7) {
          goto LABEL_24;
        }
      }
      uint64_t v6 = *(void *)((*(void *)(v6 + 32) & 0xF00007FFFFFFFF8) + 0x18);
    }
    while (v6);
  }
  return result;
}

uint64_t foreach_realized_class_and_subclass(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(gdb_objc_realized_classes + 8);
  if (DisablePreopt) {
    int v5 = 0;
  }
  else {
    int v5 = _dyld_objc_class_count();
  }
  int v6 = (16 * (v5 + v4)) | 0xF;
  uint64_t v7 = a1;
  while (1)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v7);
    if (!result || (uint64_t v12 = *(void *)((*(void *)(v7 + 32) & 0xF00007FFFFFFFF8) + 0x10)) == 0)
    {
      while (1)
      {
        uint64_t v12 = *(void *)((*(void *)(v7 + 32) & 0xF00007FFFFFFFF8) + 0x18);
        if (v7 == a1 || v12) {
          break;
        }
        if (*(void *)(v7 + 8)) {
          uint64_t v7 = *(void *)(v7 + 8);
        }
        else {
          uint64_t v7 = 0;
        }
        if (!--v6) {
          goto LABEL_16;
        }
      }
      if (v7 == a1) {
        return result;
      }
    }
    uint64_t v7 = v12;
    if (!--v6) {
LABEL_16:
    }
      _objc_fatal("Memory corruption in class list.", v9, v10, v11);
  }
}

uint64_t ___ZL11flushCachesP10objc_classPKcU13block_pointerFbS0_E_block_invoke(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned int (**)(void))(*(void *)(a1 + 32) + 16))()) {
    cache_t::eraseNolock((cache_t *)(a2 + 16), *(const char **)(a1 + 40));
  }
  return 1;
}

BOOL cache_t::shouldFlush(cache_t *this, objc_selector *a2, void (*a3)(void))
{
  if ((*(void *)this & 1) == 0 && (uint64_t v4 = *(void *)((*(void *)this & 0xFFFFFFFFFFFLL) + 8), v4 < 0))
  {
    if (*((_DWORD *)this + 2) != (HIDWORD(v3) ^ v3))
    {
      __break(1u);
      JUMPOUT(0x18012D3F0);
    }
    unint64_t v7 = *(void *)((*(void *)this & 0xFFFFFFFFFFFLL)
                   + 8
                   * ((unsigned __int16)((unint64_t)(a2 - (objc_selector *)&unk_1F62995A8) >> (v4 & 0x1F)) & (unsigned __int16)(v4 >> 5) & 0x7FF)
                   + 0x10);
    if (a2 - (objc_selector *)&unk_1F62995A8 != v7 >> 38) {
      return 0;
    }
    return (char *)((char *)this - ((uint64_t)(v7 << 26) >> 24) - 16) == (char *)a3;
  }
  else
  {
    return cache_getImp((uint64_t)this - 16, (unint64_t)a2, 0) == (void)a3;
  }
}

BOOL ___ZZL16attachCategoriesP10objc_classPK21locstamped_category_tjS0_iENK3__0clEPZL16attachCategoriesS0_S3_jS0_iE5Listsb_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(objc_cache **)(a2 + 16);
  if (v2) {
    return 0;
  }
  return v2 == &_objc_empty_cache || HIWORD(*(void *)(a2 + 16)) != 0;
}

BOOL __method_exchangeImplementations_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (cache_t *)(a2 + 16);
  if (cache_t::shouldFlush((cache_t *)(a2 + 16), *(objc_selector **)(a1 + 32), *(void (**)(void))(a1 + 48))) {
    return 1;
  }
  int v5 = *(objc_selector **)(a1 + 40);
  int v6 = *(void (**)(void))(a1 + 56);

  return cache_t::shouldFlush(v3, v5, v6);
}

void cache_t::eraseNolock(cache_t *this, const char *a2)
{
  if ((*(void *)this & 1) != 0
    || (*(objc_cache **)this != &_objc_empty_cache ? (BOOL v4 = HIWORD(*(void *)this) == 0) : (BOOL v4 = 0), v4))
  {
    if (PrintCaches)
    {
      if ((*((_WORD *)this + 7) & 4) != 0) {
        uint64_t v17 = "meta";
      }
      else {
        uint64_t v17 = "";
      }
      uint64_t v18 = objc_class::nameForLogging((cache_t *)((char *)this - 16));
      _objc_inform("CACHES: %sclass %s: dropping and disallowing preopt cache (from %s)", v17, v18, a2);
    }
    atomic_store((unint64_t)&_objc_empty_cache & 0xFFFFFFFFFFFLL, (unint64_t *)this);
    *((_WORD *)this + 6) = 0;
    atomic_fetch_or_explicit((atomic_uint *volatile)(*((void *)this + 2) & 0xF00007FFFFFFFF8), 6u, memory_order_relaxed);
  }
  else if (*((_WORD *)this + 6))
  {
    unint64_t v5 = (unint64_t)&_objc_empty_cache & 0xFFFFFFFFFFFLL;
    unint64_t v6 = *(void *)this;
    if (HIWORD(*(void *)this))
    {
      unint64_t v8 = HIWORD(v6);
      uint64_t v7 = HIWORD(v6) + 1;
      unint64_t v6 = *(void *)this;
      if (v8 >= 0x401)
      {
        uint64_t v9 = 0;
        unsigned int v10 = v7;
        do
        {
          ++v9;
          BOOL v11 = v10 > 3;
          v10 >>= 1;
        }
        while (v11);
        if (v9 >= cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsListCount)
        {
          uint64_t v12 = (const void *)malloc_type_zone_malloc_with_options_internal();
          unint64_t v13 = (char *)malloc_type_realloc((void *)cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsList, 8 * (v9 + 1), 0x2004093837F09uLL);
          cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsList = (uint64_t)v13;
          if (cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsListCount < (v9 + 1))
          {
            uint64_t v14 = ~v9 + cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsListCount;
            uint64_t v15 = &v13[8 * cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsListCount];
            do
            {
              *(void *)uint64_t v15 = v12;
              v15 += 8;
            }
            while (!__CFADD__(v14++, 1));
          }
          cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsListCount = v9 + 1;
          if (PrintCaches) {
            _objc_inform("CACHES: new empty buckets at %p (capacity %zu)", v12, v7);
          }
        }
        unint64_t v5 = *(void *)(cache_t::emptyBucketsForCapacity(unsigned int,BOOL)::emptyBucketsList + 8 * v9);
      }
    }
    else
    {
      LODWORD(v7) = 0;
    }
    atomic_store(v5 | ((unint64_t)(v7 - 1) << 48), (unint64_t *)this);
    *((_WORD *)this + 6) = 0;
    cache_t::collect_free(v6 & 0xFFFFFFFFFFFLL, v7);
  }
}

void cache_t::collectNolock(cache_t *this)
{
  if ((unint64_t)garbage_byte_size >> 15) {
    BOOL v1 = 0;
  }
  else {
    BOOL v1 = this == 0;
  }
  if (v1) {
    return;
  }
  if (this)
  {
    while (_collecting_in_critical())
      ;
LABEL_13:
    if (PrintCaches) {
      _objc_inform("CACHES: COLLECTING %zu bytes (%zu allocations, %zu collections)", garbage_byte_size, cache_allocations, ++cache_collections);
    }
    uint64_t v2 = garbage_count;
    if (DebugScribbleCaches)
    {
      if (!garbage_count)
      {
LABEL_25:
        garbage_count = 0;
        garbage_byte_uint64_t size = 0;
        if (PrintCaches)
        {
          uint64_t v9 = 0;
          uint64_t v10 = 0;
          for (uint64_t i = 0; i != 16; ++i)
          {
            uint64_t v12 = cache_counts[i];
            if (v12)
            {
              _objc_inform("CACHES: %4d slots: %4d caches, %6zu bytes", 1 << i, v12, 16 * (int)(v12 << i));
              v10 += v12;
              v9 += 16 * (int)(v12 << i);
            }
          }
          _objc_inform("CACHES:      total: %4zu caches, %6zu bytes", v10, v9);
        }
        return;
      }
      do
      {
        --v2;
        uint64_t v3 = *(const void **)(garbage_refs + 8 * v2);
        size_t v4 = malloc_size(v3);
        if (v4 >= 0x10)
        {
          size_t v5 = v4 >> 4;
          unint64_t v6 = v3;
          do
          {
            *unint64_t v6 = v3;
            v6 += 2;
            --v5;
          }
          while (v5);
        }
      }
      while (v2);
      uint64_t v2 = garbage_count;
    }
    if (v2)
    {
      uint64_t v7 = garbage_refs - 8;
      do
      {
        unint64_t v8 = *(void **)(v7 + 8 * v2);
        *(void *)(v7 + 8 * v2) = 0;
        free(v8);
        --v2;
      }
      while (v2);
    }
    goto LABEL_25;
  }
  if (!_collecting_in_critical()) {
    goto LABEL_13;
  }
  if (PrintCaches)
  {
    _objc_inform("CACHES: not collecting; objc_msgSend in progress");
  }
}

void cache_t::collect_free(uint64_t a1, unsigned int a2)
{
  if (PrintCaches)
  {
    if (a2 < 2)
    {
      unsigned int v4 = 0;
LABEL_8:
      --cache_counts[v4];
      goto LABEL_9;
    }
    unsigned int v5 = -1;
    unsigned int v6 = a2;
    do
    {
      unsigned int v7 = v5++;
      BOOL v8 = v6 > 3;
      v6 >>= 1;
    }
    while (v8);
    if (v5 <= 0xE)
    {
      unsigned int v4 = v7 + 2;
      goto LABEL_8;
    }
  }
LABEL_9:
  if (_garbage_make_room(void)::first)
  {
    uint64_t v9 = garbage_count;
    uint64_t v10 = (void *)garbage_refs;
    if (garbage_count != garbage_max) {
      goto LABEL_14;
    }
    uint64_t v10 = malloc_type_realloc((void *)garbage_refs, 16 * garbage_count, 0x80040B8603338uLL);
    garbage_refs = (uint64_t)v10;
    uint64_t v11 = 2 * garbage_max;
  }
  else
  {
    _garbage_make_room(void)::first = 1;
    uint64_t v10 = malloc_type_malloc(0x400uLL, 0x80040B8603338uLL);
    garbage_refs = (uint64_t)v10;
    uint64_t v11 = 128;
  }
  garbage_max = v11;
  uint64_t v9 = garbage_count;
LABEL_14:
  garbage_byte_size += 16 * a2;
  garbage_count = v9 + 1;
  v10[v9] = a1;

  cache_t::collectNolock(0);
}

BOOL ___ZL25_method_setImplementationP10objc_classP8method_tPFvvE_block_invoke(uint64_t a1, uint64_t a2)
{
  return cache_t::shouldFlush((cache_t *)(a2 + 16), *(objc_selector **)(a1 + 32), *(void (**)(void))(a1 + 40));
}

BOOL ___ZN10objc_class34setDisallowPreoptCachesRecursivelyEPKc_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)(a2 + 32);
  uint64_t v2 = *(void *)(a2 + 32);
  int v4 = *(_DWORD *)(v2 & 0xF00007FFFFFFFF8);
  if ((v4 & 2) == 0)
  {
    unsigned int v6 = *(objc_class **)(a1 + 40);
    if (*(void *)(a2 + 16))
    {
      cache_t::eraseNolock((cache_t *)(a2 + 16), *(const char **)(a1 + 32));
    }
    else
    {
      if (PrintCaches)
      {
        if ((*((_WORD *)v6 + 15) & 4) != 0) {
          BOOL v8 = "meta";
        }
        else {
          BOOL v8 = "";
        }
        uint64_t v9 = objc_class::nameForLogging(v6);
        _objc_inform("CACHES: %sclass %s: disallow preopt cache (from %s)", v8, v9, *(const char **)(a1 + 32));
        uint64_t v2 = *v3;
      }
      atomic_fetch_or_explicit((atomic_uint *volatile)(v2 & 0xF00007FFFFFFFF8), 6u, memory_order_relaxed);
    }
  }
  return (v4 & 2) == 0;
}

BOOL ___ZL17addMethods_finishP10objc_classP13method_list_t_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(objc_cache **)(a2 + 16);
  if (v2) {
    return 0;
  }
  return v2 == &_objc_empty_cache || HIWORD(*(void *)(a2 + 16)) != 0;
}

unint64_t *class_rw_t::extAlloc(class_rw_t *this, const class_ro_t *a2, int a3)
{
  unsigned int v5 = (unint64_t *)malloc_type_calloc(0x30uLL, 1uLL, 0x1ECB51D3uLL);
  uint64_t v10 = v5;
  *((_DWORD *)v5 + 10) = ((int)(*(_DWORD *)a2 << 31) >> 31) & 7;
  uint64_t v11 = *((void *)a2 + 4);
  if (v11) {
    BOOL v12 = (*((void *)a2 + 4) & 1) == 0;
  }
  else {
    BOOL v12 = 0;
  }
  if (v12)
  {
    unint64_t v41 = v11 & 0xFFFFFFFFFFFFFFFELL;
    if ((v11 & 0xFFFFFFFFFFFFFFFELL) != 0)
    {
      if (a3) {
        unint64_t v41 = (unint64_t)method_list_t::duplicate((method_list_t *)(v11 & 0xFFFFFFFFFFFFFFFELL), v6, v7, v8);
      }
      if (PrintPreopt) {
        unsigned int v20 = "methods";
      }
      else {
        unsigned int v20 = 0;
      }
      list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists(v10 + 1, (uint64_t)&v41, (const char *)1, 0, v20, v9);
    }
    goto LABEL_22;
  }
  unint64_t v41 = 0;
  if ((v11 & 1) == 0) {
    goto LABEL_22;
  }
  unint64_t v13 = (unsigned int *)(v11 & 0xFFFFFFFFFFFFFFFELL);
  if ((v11 & 0xFFFFFFFFFFFFFFFELL) == 0) {
    goto LABEL_22;
  }
  if (!a3)
  {
    v5[1] = v11 & 0xFFFFFFFFFFFFFFFCLL | 2;
    goto LABEL_22;
  }
  if (DisablePreattachedCategories)
  {
    uint64_t v15 = *v13;
    uint64_t v16 = v13[1];
    unint64_t v35 = v16 * (unint64_t)v15;
    if ((v35 & 0xFFFFFFFF00000000) != 0)
    {
      uint64_t v38 = *v13;
LABEL_66:
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v6, v7, v8, v16, v11 & 0xFFFFFFFFFFFFFFFELL, v38, this, v40, v41);
    }
    uint64_t v36 = (uint64_t)v13 + v35 + 8;
    BOOL v37 = v16 == 0;
    if (v16) {
      uint64_t v16 = v16;
    }
    else {
      uint64_t v16 = 0;
    }
    if (v37) {
      uint64_t v14 = (uint64_t *)v36;
    }
    else {
      uint64_t v14 = (uint64_t *)(v36 - v15);
    }
  }
  else
  {
    uint64_t v14 = (uint64_t *)(v13 + 2);
    uint64_t v15 = *v13;
    uint64_t v16 = v13[1];
  }
  unint64_t v17 = v16 * (unint64_t)v15;
  if ((v17 & 0xFFFFFFFF00000000) != 0)
  {
    uint64_t v38 = v15;
    goto LABEL_66;
  }
  unint64_t v18 = (unint64_t)v13 + v17 + 8;
  if ((unint64_t)v14 < v18)
  {
    while ((*(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v14 + 8) & 1) == 0)
    {
      uint64_t v14 = (uint64_t *)((char *)v14 + v15);
      unsigned int v19 = v15;
      if ((unint64_t)v14 >= v18) {
        goto LABEL_47;
      }
    }
  }
  unsigned int v19 = v15;
LABEL_47:
  while (v14 != (uint64_t *)v18)
  {
    uint64_t v40 = 0;
    uint64_t v40 = method_list_t::duplicate((method_list_t *)((char *)v14 + (*v14 >> 16)), v6, v7, v8);
    if (PrintPreopt) {
      unint64_t v29 = "methods";
    }
    else {
      unint64_t v29 = 0;
    }
    list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::attachLists(v10 + 1, (uint64_t)&v40, (const char *)1, 0, v29, v28);
    uint64_t v31 = *v13;
    uint64_t v30 = v13[1];
    unint64_t v32 = v30 * (unint64_t)v31;
    if ((v32 & 0xFFFFFFFF00000000) != 0) {
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v6, v7, v8, v30, v13, v31, this, v40, v41);
    }
    unint64_t v33 = (uint64_t *)((char *)v14 + v19);
    do
    {
      uint64_t v14 = v33;
      if (v33 >= (uint64_t *)((char *)v13 + v32 + 8)) {
        break;
      }
      uint64_t v34 = *(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v33 + 8);
      unint64_t v33 = (uint64_t *)((char *)v33 + v19);
    }
    while ((v34 & 1) == 0);
  }
LABEL_22:
  uint64_t v21 = *((void *)a2 + 8);
  if (v21) {
    unint64_t v22 = 0;
  }
  else {
    unint64_t v22 = v21 & 0xFFFFFFFFFFFFFFFELL;
  }
  unint64_t v41 = v22;
  if (v22)
  {
    if (PrintPreopt) {
      int v23 = "properties";
    }
    else {
      int v23 = 0;
    }
    list_array_tt<property_t,property_list_t,RawPtr>::attachLists(v10 + 2, (uint64_t)&v41, (const char *)1, 0, v23);
  }
  else if ((v21 & 1) != 0 && (v21 & 0xFFFFFFFFFFFFFFFELL) != 0)
  {
    v10[2] = v21 & 0xFFFFFFFFFFFFFFFCLL | 2;
  }
  uint64_t v24 = *((void *)a2 + 5);
  if (v24) {
    unint64_t v25 = 0;
  }
  else {
    unint64_t v25 = v24 & 0xFFFFFFFFFFFFFFFELL;
  }
  unint64_t v41 = v25;
  if (v25)
  {
    if (PrintPreopt) {
      uint64_t v26 = "protocols";
    }
    else {
      uint64_t v26 = 0;
    }
    list_array_tt<property_t,property_list_t,RawPtr>::attachLists(v10 + 3, (uint64_t)&v41, (const char *)1, 0, v26);
  }
  else if ((v24 & 1) != 0 && (v24 & 0xFFFFFFFFFFFFFFFELL) != 0)
  {
    v10[3] = v24 & 0xFFFFFFFFFFFFFFFCLL | 2;
  }
  *uint64_t v10 = (unint64_t)a2;
  atomic_store((unint64_t)v10 | 1, (unint64_t *)this + 1);
  return v10;
}

BOOL ___ZN10objc_class36setInstancesRequireRawIsaRecursivelyEb_block_invoke(uint64_t a1, objc_class *this)
{
  __int16 v2 = *((_WORD *)this + 15);
  if ((v2 & 0x2000) == 0)
  {
    atomic_fetch_or_explicit((atomic_ushort *volatile)this + 15, 0x2000u, memory_order_relaxed);
    if (PrintRawIsa)
    {
      unsigned int v5 = " (inherited)";
      if (!*(unsigned char *)(a1 + 32) && *(objc_class **)(a1 + 40) == this) {
        unsigned int v5 = "";
      }
      uint64_t v6 = objc_class::nameForLogging(this);
      if ((*((_WORD *)this + 15) & 4) != 0) {
        unsigned int v7 = " (meta)";
      }
      else {
        unsigned int v7 = "";
      }
      _objc_inform("RAW ISA:  %s%s%s", v6, v7, v5);
    }
  }
  return (v2 & 0x2000) == 0;
}

unint64_t *list_array_tt<unsigned long,protocol_list_t,RawPtr>::validate(unint64_t *result, uint64_t a2, const char *a3, char *a4)
{
  unint64_t v8 = *result;
  if (!*result)
  {
    unsigned int v5 = 0;
    unint64_t v9 = 0;
    goto LABEL_10;
  }
  uint64_t v7 = *result & 3;
  unint64_t v9 = (unsigned int *)(v8 & 0xFFFFFFFFFFFFFFFCLL);
  BOOL v10 = (v8 & 3) != 0 || v9 == 0;
  if (!v10)
  {
    unsigned int v5 = (unsigned int *)(v8 & 0xFFFFFFFFFFFFFFFCLL);
    unint64_t v9 = 0;
    goto LABEL_10;
  }
  if (v8 >= 4)
  {
    if (v7 == 2)
    {
      if (!v9) {
        goto LABEL_10;
      }
      if (DisablePreattachedCategories)
      {
        uint64_t v18 = *v9;
        uint64_t v25 = v9[1];
        unint64_t v26 = v25 * (unint64_t)v18;
        if ((v26 & 0xFFFFFFFF00000000) != 0) {
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v25, *result & 0xFFFFFFFFFFFFFFFCLL, v18);
        }
        uint64_t v27 = (uint64_t)v9 + v26 + 8;
        if (v25) {
          uint64_t v19 = v25;
        }
        else {
          uint64_t v19 = 0;
        }
        if (v25) {
          int v4 = (unsigned __int16 *)(v27 - v18);
        }
        else {
          int v4 = (unsigned __int16 *)v27;
        }
      }
      else
      {
        int v4 = (unsigned __int16 *)(v9 + 2);
        uint64_t v18 = *v9;
        uint64_t v19 = v9[1];
      }
      unint64_t v20 = v19 * (unint64_t)v18;
      if ((v20 & 0xFFFFFFFF00000000) != 0) {
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v19, v9, v18);
      }
      unint64_t v21 = (unint64_t)v9 + v20 + 8;
      if ((unint64_t)v4 < v21)
      {
        while ((*(void *)(objc_debug_headerInfoRWs + 8 * *v4 + 8) & 1) == 0)
        {
          int v4 = (unsigned __int16 *)((char *)v4 + v18);
          unsigned int v6 = v18;
          if ((unint64_t)v4 >= v21) {
            goto LABEL_50;
          }
        }
      }
      unsigned int v6 = v18;
LABEL_50:
      unsigned int v5 = (unsigned int *)(v8 & 0xFFFFFFFFFFFFFFFCLL);
    }
    else if (v7 == 1)
    {
      if (!v9) {
        goto LABEL_10;
      }
      unsigned int v5 = v9 + 2;
LABEL_43:
      uint64_t v7 = *v9;
      v9 += 2 * v7 + 2;
      goto LABEL_10;
    }
  }
  else
  {
    unsigned int v5 = 0;
  }
  if (v7 != 2)
  {
    if (v7 != 1)
    {
      unint64_t v9 = 0;
      goto LABEL_10;
    }
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_43;
  }
  if (v9)
  {
    uint64_t v23 = *v9;
    uint64_t v22 = v9[1];
    unint64_t v24 = v22 * (unint64_t)v23;
    if ((v24 & 0xFFFFFFFF00000000) != 0) {
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v22, v9, v23);
    }
    uint64_t v7 = (uint64_t)v9 + v24 + 8;
  }
  while (1)
  {
    while (1)
    {
LABEL_10:
      while (!v8)
      {
        BOOL v10 = v5 == v9;
        unsigned int v5 = 0;
        if (v10) {
          return result;
        }
      }
      uint64_t v11 = *result & 3;
      if ((v8 & 3) == 0 || v11 == 1) {
        break;
      }
      if (v11 != 2) {
        goto LABEL_24;
      }
      if (v4 == (unsigned __int16 *)v7) {
        return result;
      }
      v5 += 2 * (v11 == 1);
      uint64_t v13 = *v5;
      uint64_t v12 = v5[1];
      unint64_t v14 = v12 * (unint64_t)v13;
      if ((v14 & 0xFFFFFFFF00000000) != 0) {
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v12, v5, v13);
      }
      unint64_t v15 = (unint64_t)v5 + v14 + 8;
      uint64_t v16 = (unsigned __int16 *)((char *)v4 + v6);
      do
      {
        int v4 = v16;
        if ((unint64_t)v16 >= v15) {
          break;
        }
        uint64_t v17 = *(void *)(objc_debug_headerInfoRWs + 8 * *v16 + 8);
        uint64_t v16 = (unsigned __int16 *)((char *)v16 + v6);
      }
      while ((v17 & 1) == 0);
    }
    if (v5 == v9) {
      return result;
    }
LABEL_24:
    if ((v8 & 3) == 0) {
      unsigned int v5 = 0;
    }
    v5 += 2 * (v11 == 1);
  }
}

uint64_t ___ZL13setSuperclassP10objc_classS0__block_invoke_195()
{
  return 1;
}

uint64_t ___ZL13setSuperclassP10objc_classS0__block_invoke()
{
  return 1;
}

uint64_t header_info::catlist(header_info *this, unint64_t *a2)
{
  uint64_t result = _dyld_lookup_section_info();
  unint64_t v5 = v4 >> 3;
  if (!result) {
    unint64_t v5 = 0;
  }
  *a2 = v5;
  return result;
}

uint64_t relative_list_list_t<protocol_list_t>::countLists(unsigned int *a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  unint64_t v6 = v5 * (unint64_t)v4;
  if ((v6 & 0xFFFFFFFF00000000) != 0) {
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v5, a1, v4);
  }
  uint64_t v7 = (unsigned __int16 *)(a1 + 2);
  unint64_t v8 = (unint64_t)a1 + v6 + 8;
  if (DisablePreattachedCategories)
  {
    if (!v5) {
      return 0;
    }
    uint64_t v7 = (unsigned __int16 *)(v8 - v4);
  }
  for (; (unint64_t)v7 < v8; uint64_t v7 = (unsigned __int16 *)((char *)v7 + v4))
  {
    if (*(void *)(objc_debug_headerInfoRWs + 8 * *v7 + 8)) {
      break;
    }
  }
  if ((unint64_t)v7 >= v8) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    do
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v4);
    while ((unint64_t)v7 < v8 && (*(void *)(objc_debug_headerInfoRWs + 8 * *v7 + 8) & 1) == 0);
    ++result;
  }
  while ((unint64_t)v7 < v8);
  return result;
}

uint64_t _collecting_in_critical(void)
{
  if (shouldUseRestartableRanges)
  {
    thread_act_array_t act_list = 0;
    mach_msg_type_number_t act_listCnt = 0;
    mach_port_t v0 = pthread_mach_thread_np(*(pthread_t *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)));
    BOOL v1 = (ipc_space_t *)MEMORY[0x1E4F14960];
    uint64_t v2 = task_threads(*MEMORY[0x1E4F14960], &act_list, &act_listCnt);
    if (v2) {
      _objc_fatal("task_threads failed (result 0x%x)\n", v3, v4, v5, v2);
    }
    if (act_listCnt)
    {
      uint64_t v6 = 0;
      while (1)
      {
        thread_read_t v7 = act_list[v6];
        if (v7 != v0)
        {
          mach_msg_type_number_t old_stateCnt = 68;
          if (thread_get_state(v7, 6, old_state, &old_stateCnt) || v26 == 1) {
            goto LABEL_19;
          }
          unint64_t v8 = objc_restartableRanges;
          if (objc_restartableRanges) {
            break;
          }
        }
LABEL_14:
        if (++v6 >= (unint64_t)act_listCnt)
        {
          uint64_t v13 = 0;
          if (!act_listCnt) {
            goto LABEL_24;
          }
          goto LABEL_20;
        }
      }
      unint64_t v9 = &qword_1EB1C9960;
      while (1)
      {
        BOOL v10 = v26 >= v8;
        unint64_t v11 = v26 - v8;
        if (v11 != 0 && v10 && v11 < *((unsigned __int16 *)v9 - 4)) {
          break;
        }
        unint64_t v12 = *v9;
        v9 += 2;
        unint64_t v8 = v12;
        if (!v12) {
          goto LABEL_14;
        }
      }
LABEL_19:
      uint64_t v13 = 1;
      if (!act_listCnt) {
        goto LABEL_24;
      }
LABEL_20:
      for (unint64_t i = 0; i < act_listCnt; mach_port_deallocate(*v1, act_list[i++]))
        ;
      uint64_t v20 = 4 * act_listCnt;
    }
    else
    {
      uint64_t v13 = 0;
LABEL_24:
      uint64_t v20 = 0;
    }
    MEMORY[0x1852FC730](*v1, act_list, v20);
  }
  else
  {
    uint64_t v14 = task_restartable_ranges_synchronize();
    uint64_t v13 = v14;
    if (v14)
    {
      unint64_t v15 = mach_error_string(v14);
      _objc_fatal("task_restartable_ranges_synchronize failed (result 0x%x: %s)", v16, v17, v18, v13, v15);
    }
  }
  return v13;
}

uint64_t ___class_setCustomDeallocInitiation_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t ___ZN4objc7Scanner20propagateCustomFlagsEP10objc_classjNS0_11inherited_tE_block_invoke(uint64_t a1, objc_class *this)
{
  if (*(objc_class **)(a1 + 32) == this)
  {
    int v6 = *(_DWORD *)(a1 + 40);
  }
  else
  {
    int v4 = *(_DWORD *)(*((void *)this + 4) & 0xF00007FFFFFFFF8);
    if ((v4 & 1) == 0) {
      int v4 = *(_DWORD *)(*(void *)((*(void *)this & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    }
    if ((v4 & 0x20000000) == 0) {
      return 0;
    }
    int v6 = 1;
  }
  if (*(unsigned char *)(a1 + 44) && (*((_WORD *)this + 15) & 0x4000) != 0)
  {
    atomic_fetch_and_explicit((atomic_ushort *volatile)this + 15, 0xBFFFu, memory_order_relaxed);
    if (PrintCustomAWZ) {
      objc::Scanner::printCustom("CUSTOM AWZ", this, v6);
    }
    uint64_t result = 1;
  }
  else
  {
    uint64_t result = 0;
  }
  if (*(unsigned char *)(a1 + 45))
  {
    thread_read_t v7 = (atomic_ullong *)((char *)this + 32);
    if ((*((unsigned char *)this + 32) & 4) != 0)
    {
      atomic_ullong v8 = *v7;
      if (!*v7) {
        goto LABEL_18;
      }
LABEL_17:
      for (unint64_t i = v8; ; unint64_t i = 0x8000000000000000)
      {
        unint64_t v10 = i & 0xFFFFFFFFFFFFFFFBLL;
        atomic_ullong v11 = v8;
        atomic_compare_exchange_strong_explicit(v7, (unint64_t *)&v11, v10, memory_order_release, memory_order_relaxed);
        if (v11 == v8) {
          break;
        }
        atomic_ullong v8 = v11;
        if (v11) {
          goto LABEL_17;
        }
LABEL_18:
        ;
      }
      if (PrintCustomRR) {
        objc::Scanner::printCustom("CUSTOM RR", this, v6);
      }
      uint64_t result = 1;
    }
  }
  if (*(unsigned char *)(a1 + 46) && *((__int16 *)this + 15) < 0)
  {
    atomic_fetch_and_explicit((atomic_ushort *volatile)this + 15, 0x7FFFu, memory_order_relaxed);
    if (PrintCustomCore) {
      objc::Scanner::printCustom("CUSTOM Core", this, v6);
    }
    return 1;
  }
  return result;
}

Protocol **__cdecl protocol_copyProtocolList(Protocol *proto, unsigned int *outCount)
{
  if (proto)
  {
    int v4 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v4) {
      os_unfair_lock_lock_with_options();
    }
    Class isa = proto[2].super.isa;
    if (isa)
    {
      uint64_t v7 = *(void *)isa;
      if (*(void *)isa)
      {
        atomic_ullong v8 = (Protocol **)malloc_type_malloc((8 * v7 + 8) & 0x7FFFFFFF8, 0x80040B8603338uLL);
        uint64_t v9 = 0;
        do
        {
          uint64_t v10 = *(void *)((char *)proto[2].super.isa + v9 * 8 + 8);
          if (canonical_protocol) {
            int v11 = 0;
          }
          else {
            int v11 = 0x20000000;
          }
          if ((v11 & *(_DWORD *)(v10 + 68)) == 0)
          {
            uint64_t Protocol = getProtocol(*(const char **)(v10 + 8));
            if (Protocol) {
              uint64_t v10 = Protocol;
            }
          }
          v8[v9++] = (Protocol *)v10;
        }
        while (v7 != v9);
        v8[v7] = 0;
        if (!outCount) {
          goto LABEL_21;
        }
LABEL_20:
        *outCount = v7;
LABEL_21:
        int v13 = *(_DWORD *)(StatusReg + 24);
        int v14 = v13;
        atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v14, 0, memory_order_release, memory_order_relaxed);
        if (v14 != v13) {
          os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
        }
        return v8;
      }
    }
    else
    {
      LODWORD(v7) = 0;
    }
    atomic_ullong v8 = 0;
    if (!outCount) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  atomic_ullong v8 = 0;
  if (outCount) {
    *outCount = 0;
  }
  return v8;
}

void sub_18012E914(_Unwind_Exception *exception_object)
{
  int v3 = *(_DWORD *)(v1 + 24);
  int v4 = v3;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, 0, memory_order_release, memory_order_relaxed);
  if (v4 != v3) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

IMP method_setImplementation(Method m, IMP imp)
{
  if (m) {
    Method v3 = m;
  }
  else {
    Method v3 = 0;
  }
  int v4 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v4) {
    os_unfair_lock_lock_with_options();
  }
  int v6 = (void (*)(void))_method_setImplementation(0, (uint64_t)v3, imp);
  int v7 = *(_DWORD *)(StatusReg + 24);
  int v8 = v7;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v8, 0, memory_order_release, memory_order_relaxed);
  if (v8 != v7) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return v6;
}

void sub_18012EA18(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void method_exchangeImplementations(Method m1, Method m2)
{
  if (m1 && m2)
  {
    int v4 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v4) {
      os_unfair_lock_lock_with_options();
    }
    int v8 = (void (*)(void))method_t::imp((unint64_t)m1, 0);
    uint64_t v9 = (void (*)(void))method_t::imp((unint64_t)m2, 0);
    int v10 = m1 & 3;
    if ((m1 & 3) != 0)
    {
      if (v10 == 2)
      {
        if (*(void *)((unint64_t)m1 & 0xFFFFFFFFFFFFFFFCLL)) {
          uint64_t v2 = *(char **)((unint64_t)m1 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else {
          uint64_t v2 = 0;
        }
      }
      else if (v10 == 1)
      {
        int v11 = (int *)((unint64_t)m1 & 0xFFFFFFFFFFFFFFFCLL);
        if (dataSegmentsRanges > ((unint64_t)m1 & 0xFFFFFFFFFFFFFFFCLL)
          || *(void *)algn_1EB1CB078 <= (unint64_t)v11)
        {
          uint64_t v2 = *(char **)((char *)v11 + *v11);
        }
        else
        {
          uint64_t v2 = (char *)&unk_1F62995A8 + *v11;
        }
      }
    }
    else
    {
      uint64_t v2 = *(char **)((unint64_t)m1 & 0xFFFFFFFFFFFFFFFCLL);
    }
    int v12 = m2 & 3;
    if ((m2 & 3) != 0)
    {
      if (v12 == 2)
      {
        if (*(void *)((unint64_t)m2 & 0xFFFFFFFFFFFFFFFCLL)) {
          Method v3 = *(char **)((unint64_t)m2 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else {
          Method v3 = 0;
        }
      }
      else if (v12 == 1)
      {
        int v13 = (int *)((unint64_t)m2 & 0xFFFFFFFFFFFFFFFCLL);
        if (dataSegmentsRanges > ((unint64_t)m2 & 0xFFFFFFFFFFFFFFFCLL)
          || *(void *)algn_1EB1CB078 <= (unint64_t)v13)
        {
          Method v3 = *(char **)((char *)v13 + *v13);
        }
        else
        {
          Method v3 = (char *)&unk_1F62995A8 + *v13;
        }
      }
    }
    else
    {
      Method v3 = *(char **)((unint64_t)m2 & 0xFFFFFFFFFFFFFFFCLL);
    }
    method_t::setImp((uint64_t)m1, v9);
    method_t::setImp((uint64_t)m2, v8);
    v19[0] = MEMORY[0x1E4F143A8];
    v19[1] = 3321888768;
    v19[2] = __method_exchangeImplementations_block_invoke;
    v19[3] = &__block_descriptor_64_e8_32c43_ZTSKZ30method_exchangeImplementationsE3__0_e8_B16__0_8l;
    v19[4] = v2;
    v19[5] = v3;
    v19[6] = v8;
    v19[7] = v9;
    flushCaches(0, (uint64_t)"method_exchangeImplementations", (const char *)v19, v14);
    objc::Scanner::scanChangedMethod(0, (unint64_t)m1, v15);
    objc::Scanner::scanChangedMethod(0, (unint64_t)m2, v16);
    int v17 = *(_DWORD *)(StatusReg + 24);
    int v18 = v17;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v18, 0, memory_order_release, memory_order_relaxed);
    if (v18 != v17) {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
  }
}

void sub_18012ED14(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)
{
  if (!cls) {
    return 0;
  }
  int v8 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v8, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v8) {
    os_unfair_lock_lock_with_options();
  }
  if (types) {
    int v10 = (char *)types;
  }
  else {
    int v10 = "";
  }
  int v11 = (void (*)(void))addMethod(cls, (objc_selector *)name, imp, v10, 1);
  int v12 = *(_DWORD *)(StatusReg + 24);
  int v13 = v12;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v13, 0, memory_order_release, memory_order_relaxed);
  if (v13 != v12) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return v11;
}

void sub_18012EE18(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

unint64_t _method_setImplementation(objc_class *a1, uint64_t this, void (*a3)(void))
{
  unint64_t v4 = 0;
  if (this && a3)
  {
    unint64_t v4 = method_t::imp(this, 0);
    int v8 = this & 3;
    if ((this & 3) != 0)
    {
      if (v8 == 2)
      {
        if (*(void *)(this & 0xFFFFFFFFFFFFFFFCLL)) {
          Method v3 = *(char **)(this & 0xFFFFFFFFFFFFFFFCLL);
        }
        else {
          Method v3 = 0;
        }
      }
      else if (v8 == 1)
      {
        uint64_t v9 = (int *)(this & 0xFFFFFFFFFFFFFFFCLL);
        if (dataSegmentsRanges > (this & 0xFFFFFFFFFFFFFFFCLL) || *(void *)algn_1EB1CB078 <= (unint64_t)v9) {
          Method v3 = *(char **)((char *)v9 + *v9);
        }
        else {
          Method v3 = (char *)&unk_1F62995A8 + *v9;
        }
      }
    }
    else
    {
      Method v3 = *(char **)(this & 0xFFFFFFFFFFFFFFFCLL);
    }
    method_t::setImp(this, a3);
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3321888768;
    v13[2] = ___ZL25_method_setImplementationP10objc_classP8method_tPFvvE_block_invoke;
    v13[3] = &__block_descriptor_48_e8_32c67_ZTSKZL25_method_setImplementationP10objc_classP8method_tPFvvEE3__0_e8_B16__0_8l;
    v13[4] = v3;
    void v13[5] = v4;
    flushCaches((uint64_t)a1, (uint64_t)"_method_setImplementation", (const char *)v13, v10);
    objc::Scanner::scanChangedMethod((uint64_t)a1, this, v11);
  }
  return v4;
}

uint64_t objc::Scanner::scanChangedMethod(uint64_t this, unint64_t a2, const method_t *a3)
{
  int v4 = a2 & 3;
  if ((a2 & 3) != 0)
  {
    if (v4 == 2)
    {
      int v6 = *(char **)(a2 & 0xFFFFFFFFFFFFFFFCLL);
    }
    else
    {
      if (v4 != 1) {
        goto LABEL_41;
      }
      int v5 = (int *)(a2 & 0xFFFFFFFFFFFFFFFCLL);
      if (dataSegmentsRanges > (a2 & 0xFFFFFFFFFFFFFFFCLL) || *(void *)algn_1EB1CB078 <= (unint64_t)v5) {
        int v6 = *(char **)((char *)v5 + *v5);
      }
      else {
        int v6 = (char *)&unk_1F62995A8 + *v5;
      }
    }
  }
  else
  {
    int v6 = *(char **)(a2 & 0xFFFFFFFFFFFFFFFCLL);
  }
  if (sel_alloc != v6 && sel_allocWithZone_ != v6)
  {
    int v8 = 4;
    int v9 = 1;
    if (sel_retain != v6
      && sel_release != v6
      && sel_autorelease != v6
      && sel__tryRetain != v6
      && sel__isDeallocating != v6
      && sel_retainCount != v6
      && sel_allowsWeakReference != v6
      && sel_retainWeakReference != v6)
    {
      int v8 = 16;
      int v9 = 1;
      if (&sel_new != (_UNKNOWN *)v6 && sel_self != v6 && sel_class != v6 && sel_isKindOfClass_ != v6)
      {
        if (sel_respondsToSelector_ != v6) {
          return this;
        }
        int v9 = 1;
      }
    }
    if (this) {
      goto LABEL_29;
    }
LABEL_42:
    int v14 = objc::NSObjectSwizzledMask;
    if ((objc::NSObjectSwizzledMask & v8) != 0) {
      int v9 = 0;
    }
    if (v9 == 1)
    {
      class_rw_t::methods(&v32, (uint64_t)OBJC_CLASS___NSObject.info & 0xF00007FFFFFFFF8);
      list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::begin((uint64_t)v30, &v32, v15, v16);
      list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::end((uint64_t)v29, &v32, v17, v18);
      while (1)
      {
        this = list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator==((uint64_t)v30, v29);
        if (this) {
          break;
        }
        if (v31 == (objc_class *)a2)
        {
          this = (uint64_t)objc::Scanner::setNSObjectSwizzled(NSObject, v8, 0);
          break;
        }
        list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator++(v30, v19, v20, v21);
      }
      int v14 = objc::NSObjectSwizzledMask;
    }
    if ((v14 & (2 * v8)) == 0)
    {
      class_rw_t::methods(&v32, (uint64_t)OBJC_METACLASS___NSObject.info & 0xF00007FFFFFFFF8);
      list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::begin((uint64_t)v30, &v32, v22, v23);
      list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::end((uint64_t)v29, &v32, v24, v25);
      while (1)
      {
        this = list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator==((uint64_t)v30, v29);
        if (this) {
          break;
        }
        if (v31 == (objc_class *)a2) {
          return (uint64_t)objc::Scanner::setNSObjectSwizzled(&OBJC_METACLASS___NSObject, v8, 1);
        }
        list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator++(v30, v26, v27, v28);
      }
    }
    return this;
  }
LABEL_41:
  int v9 = 0;
  int v8 = 1;
  if (!this) {
    goto LABEL_42;
  }
LABEL_29:
  if ((*(_WORD *)(this + 30) & 4) != 0)
  {
    if ((__objc2_class *)this != &OBJC_METACLASS___NSObject
      || (objc::NSObjectSwizzledMask & (2 * v8)) != 0)
    {
      return this;
    }
    int v11 = &OBJC_METACLASS___NSObject;
    int v12 = v8;
    char v13 = 1;
    goto LABEL_38;
  }
  char v10 = v9 ^ 1;
  if ((__objc2_class *)this != NSObject) {
    char v10 = 1;
  }
  if ((v10 & 1) == 0 && (objc::NSObjectSwizzledMask & v8) == 0)
  {
    int v11 = NSObject;
    int v12 = v8;
    char v13 = 0;
LABEL_38:
    return (uint64_t)objc::Scanner::setNSObjectSwizzled(v11, v12, v13);
  }
  return this;
}

void objc::DenseMap<method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>::grow(int a1)
{
  uint64_t v1 = dword_1EB1CA740;
  if (objc::smallMethodIMPMap) {
    uint64_t v2 = (unint64_t *)objc::smallMethodIMPMap;
  }
  else {
    uint64_t v2 = 0;
  }
  unsigned int v3 = (a1 - 1) | ((a1 - 1) >> 1) | (((a1 - 1) | ((a1 - 1) >> 1)) >> 2);
  unsigned int v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
  int v5 = v4 | HIWORD(v4);
  if ((v5 + 1) > 4) {
    unsigned int v6 = v5 + 1;
  }
  else {
    unsigned int v6 = 4;
  }
  dword_1EB1CA740 = v6;
  int v7 = malloc_type_malloc(16 * v6, 0x64B88C75uLL);
  if (v7)
  {
    objc::smallMethodIMPMap = (uint64_t)v7;
    qword_1EB1CA738 = 0;
    if (v2)
    {
      int v8 = v7;
LABEL_13:
      if (dword_1EB1CA740)
      {
        uint64_t v10 = 16 * dword_1EB1CA740;
        do
        {
          *int v8 = -1;
          v8 += 2;
          v10 -= 16;
        }
        while (v10);
      }
      if (v1)
      {
        uint64_t v11 = 16 * v1;
        int v12 = v2;
        do
        {
          unint64_t v13 = *v12;
          if (*v12 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            uint64_t v16 = 0;
            objc::DenseMapBase<objc::DenseMap<method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>,method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>::LookupBucketFor<method_t const*>(v13, &v16);
            int v14 = v16;
            *uint64_t v16 = *v12;
            v14[1] = v12[1];
            LODWORD(qword_1EB1CA738) = qword_1EB1CA738 + 1;
          }
          v12 += 2;
          v11 -= 16;
        }
        while (v11);
      }
      free(v2);
      return;
    }
    int v9 = v7;
  }
  else
  {
    int v9 = 0;
    int v8 = 0;
    objc::smallMethodIMPMap = 0;
    qword_1EB1CA738 = 0;
    if (v2) {
      goto LABEL_13;
    }
  }
  if (dword_1EB1CA740)
  {
    uint64_t v15 = 16 * dword_1EB1CA740;
    do
    {
      *int v9 = -1;
      v9 += 2;
      v15 -= 16;
    }
    while (v15);
  }
}

uint64_t method_t::setImp(uint64_t this, void (*a2)(void))
{
  unint64_t v2 = this;
  int v3 = this & 3;
  if ((this & 3) != 0 && v3 != 2)
  {
    if (v3 != 1) {
      return this;
    }
    if (!byte_1EB1CA748)
    {
      objc::smallMethodIMPMap = 0;
      qword_1EB1CA738 = 0;
      dword_1EB1CA740 = 0;
      byte_1EB1CA748 = 1;
    }
    int v7 = 0;
    this = objc::DenseMapBase<objc::DenseMap<method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>,method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>::LookupBucketFor<method_t const*>(this, &v7);
    int v5 = v7;
    if (this) {
      goto LABEL_18;
    }
    this = dword_1EB1CA740;
    if (4 * (int)qword_1EB1CA738 + 4 >= (3 * dword_1EB1CA740))
    {
      LODWORD(this) = 2 * dword_1EB1CA740;
    }
    else if (dword_1EB1CA740 + ~qword_1EB1CA738 - HIDWORD(qword_1EB1CA738) > dword_1EB1CA740 >> 3)
    {
LABEL_9:
      if (*v5 == -2)
      {
        qword_1EB1CA738 = (uint64_t)vadd_s32((int32x2_t)qword_1EB1CA738, (int32x2_t)0xFFFFFFFF00000001);
      }
      else if (*v5 == -1)
      {
        LODWORD(qword_1EB1CA738) = qword_1EB1CA738 + 1;
      }
      *int v5 = v2;
      v5[1] = 0;
LABEL_18:
      v5[1] = (unint64_t)a2;
      return this;
    }
    objc::DenseMap<method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>::grow(this);
    int v7 = 0;
    this = objc::DenseMapBase<objc::DenseMap<method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>,method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>::LookupBucketFor<method_t const*>(v2, &v7);
    int v5 = v7;
    goto LABEL_9;
  }
  if (a2) {
    unsigned int v6 = a2;
  }
  else {
    unsigned int v6 = 0;
  }
  *(void *)((this & 0xFFFFFFFFFFFFFFFCLL) + 16) = v6;
  return this;
}

uint64_t objc::DenseMapBase<objc::DenseMap<method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>,method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>::LookupBucketFor<method_t const*>(unint64_t a1, void *a2)
{
  if (dword_1EB1CA740)
  {
    int v2 = dword_1EB1CA740 - 1;
    unsigned int v3 = (dword_1EB1CA740 - 1) & (bswap64(0x8A970BE7488FDA55 * (a1 ^ (a1 >> 4))) ^ (1217387093 * (a1 ^ (a1 >> 4))));
    unsigned int v4 = (void *)(objc::smallMethodIMPMap + 16 * v3);
    uint64_t v5 = *v4;
    if (*v4 == a1)
    {
      uint64_t v6 = 1;
    }
    else
    {
      int v8 = 0;
      unsigned int v9 = 1;
      while (v5 != -1)
      {
        if (v9 > dword_1EB1CA740) {
          objc::DenseMapBase<objc::DenseMap<method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>,method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>::FatalCorruptHashTables((void *)objc::smallMethodIMPMap, dword_1EB1CA740);
        }
        if (v8) {
          BOOL v10 = 0;
        }
        else {
          BOOL v10 = v5 == -2;
        }
        if (v10) {
          int v8 = v4;
        }
        unsigned int v11 = v3 + v9++;
        unsigned int v3 = v11 & v2;
        unsigned int v4 = (void *)(objc::smallMethodIMPMap + 16 * (v11 & v2));
        uint64_t v5 = *v4;
        uint64_t v6 = 1;
        if (*v4 == a1) {
          goto LABEL_5;
        }
      }
      uint64_t v6 = 0;
      if (v8) {
        unsigned int v4 = v8;
      }
    }
  }
  else
  {
    unsigned int v4 = 0;
    uint64_t v6 = 0;
  }
LABEL_5:
  *a2 = v4;
  return v6;
}

BOOL protocol_isEqual(Protocol *proto, Protocol *other)
{
  if (proto == other)
  {
    LOBYTE(proto) = 1;
  }
  else
  {
    int v2 = proto;
    LOBYTE(proto) = 0;
    if (v2)
    {
      if (other)
      {
        LODWORD(proto) = protocol_conformsToProtocol(v2, other);
        if (proto)
        {
          LOBYTE(proto) = protocol_conformsToProtocol(other, v2);
        }
      }
    }
  }
  return (char)proto;
}

BOOL protocol_conformsToProtocol(Protocol *proto, Protocol *other)
{
  int v4 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v4) {
    os_unfair_lock_lock_with_options();
  }
  char v6 = protocol_conformsToProtocol_nolock((protocol_t *)proto, (const char **)other);
  int v7 = *(_DWORD *)(StatusReg + 24);
  int v8 = v7;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v8, 0, memory_order_release, memory_order_relaxed);
  if (v8 != v7) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return v6;
}

void sub_18012F940(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

const char *__cdecl method_getTypeEncoding(const char *m)
{
  if (m) {
    return (const char *)method_t::types((uint64_t)m);
  }
  return m;
}

atomic_ullong protocol_t::demangledName(char **this)
{
  uint64_t v2 = (atomic_ullong *)(this + 10);
  if ((char **)((char *)this + *((unsigned int *)this + 16)) <= this + 10)
  {
    uint64_t v2 = (atomic_ullong *)(this + 1);
  }
  else if (!*v2)
  {
    unsigned int v3 = copySwiftV1DemangledName(this[1], 1);
    uint64_t v4 = 0;
    if (v3)
    {
      atomic_compare_exchange_strong(v2, (unint64_t *)&v4, (unint64_t)v3);
      if (v4) {
        free(v3);
      }
    }
    else
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)this + 10, (unint64_t *)&v4, (unint64_t)this[1]);
    }
  }
  return *v2;
}

char *copySwiftV1DemangledName(char *result, int a2)
{
  if (result)
  {
    unsigned int v3 = result;
    if (a2) {
      uint64_t v4 = "_TtP";
    }
    else {
      uint64_t v4 = "_TtC";
    }
    if (strncmp(result, v4, 4uLL)) {
      return 0;
    }
    int v12 = v3 + 4;
    int v5 = &v3[strlen(v3 + 4) + 4];
    unsigned int v11 = 0;
    int v10 = 0;
    if (v3[4] == 115)
    {
      int v10 = 5;
      unsigned int v11 = "Swift";
      int v12 = v3 + 5;
    }
    else if (!scanMangledField((const char **)&v12, v5, (const char **)&v11, &v10))
    {
      return 0;
    }
    unsigned int v9 = 0;
    int v8 = 0;
    BOOL v6 = scanMangledField((const char **)&v12, v5, (const char **)&v9, &v8);
    uint64_t result = 0;
    if (v6)
    {
      if (a2)
      {
        if (!strcmp(v12, "_")) {
          goto LABEL_16;
        }
      }
      else if (v12 == v5)
      {
LABEL_16:
        int v7 = 0;
        asprintf(&v7, "%.*s.%.*s", v10, v11, v8, v9);
        return v7;
      }
      return 0;
    }
  }
  return result;
}

BOOL scanMangledField(const char **a1, const char *a2, const char **a3, int *a4)
{
  uint64_t v4 = *a1;
  if (**a1 == 48) {
    return 0;
  }
  int v6 = 0;
  *a4 = 0;
  *a3 = v4;
  uint64_t v7 = MEMORY[0x1E4F14390];
  while (1)
  {
    int v8 = (char *)*a3;
    if (*a3 >= a2) {
      break;
    }
    unsigned int v9 = *v8;
    if ((v9 & 0x80000000) != 0 || (*(_DWORD *)(v7 + 4 * v9 + 60) & 0x400) == 0) {
      break;
    }
    *a3 = v8 + 1;
    uint64_t v10 = 10 * v6;
    *a4 = v10;
    if (v10 == (int)v10)
    {
      unsigned int v11 = v9 - 48;
      BOOL v12 = __OFADD__(v10, v11);
      int v6 = v10 + v11;
      *a4 = v6;
      if (!v12) {
        continue;
      }
    }
    return 0;
  }
  unint64_t v13 = &v8[v6];
  *a1 = v13;
  return v6 > 0 && v13 <= a2;
}

objc_property_attribute_t *__cdecl property_copyAttributeList(objc_property_t property, unsigned int *outCount)
{
  if (property)
  {
    int v4 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v4) {
      os_unfair_lock_lock_with_options();
    }
    int v6 = (const char *)*((void *)property + 1);
    if (v6)
    {
      unsigned int v7 = 1;
      for (unint64_t i = (unsigned char *)*((void *)property + 1); ; ++i)
      {
        if (*i == 44)
        {
          ++v7;
        }
        else if (!*i)
        {
          size_t v9 = strlen(v6);
          uint64_t v10 = (objc_property_attribute_t *)malloc_type_calloc(2 * v7 + 16 * v7 + v9 + 16, 1uLL, 0xEC10EE0uLL);
          uint64_t v16 = (uint64_t)&v10[v7 + 1];
          int v17 = v10;
          unsigned int v11 = iteratePropertyAttributes(v6, (uint64_t (*)(uint64_t, void *, void *, const char *, int64_t, uint64_t, const char *))copyOneAttribute, &v17, &v16);
          unsigned int v12 = v11;
          if (!v11)
          {
            free(v10);
            uint64_t v10 = 0;
          }
          if (outCount) {
            *outCount = v12;
          }
          goto LABEL_19;
        }
      }
    }
    uint64_t v10 = 0;
    if (outCount) {
      *outCount = 0;
    }
LABEL_19:
    int v13 = *(_DWORD *)(StatusReg + 24);
    int v14 = v13;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v14, 0, memory_order_release, memory_order_relaxed);
    if (v14 != v13) {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
  }
  else
  {
    uint64_t v10 = 0;
    if (outCount) {
      *outCount = 0;
    }
  }
  return v10;
}

void sub_18012FE30(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

char *__cdecl property_copyAttributeValue(objc_property_t property, const char *attributeName)
{
  uint64_t v2 = 0;
  if (property && attributeName)
  {
    if (*attributeName)
    {
      int v5 = 0;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v5, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
      if (v5) {
        os_unfair_lock_lock_with_options();
      }
      unsigned int v7 = (const char *)*((void *)property + 1);
      unsigned int v11 = 0;
      iteratePropertyAttributes(v7, (uint64_t (*)(uint64_t, void *, void *, const char *, int64_t, uint64_t, const char *))findOneAttribute, (void *)attributeName, &v11);
      uint64_t v2 = v11;
      int v8 = *(_DWORD *)(StatusReg + 24);
      int v9 = v8;
      atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v9, 0, memory_order_release, memory_order_relaxed);
      if (v9 != v8) {
        os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

void sub_18012FF30(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

uint64_t iteratePropertyAttributes(const char *__s, uint64_t (*a2)(uint64_t, void *, void *, const char *, int64_t, uint64_t, const char *), void *a3, void *a4)
{
  if (!__s) {
    return 0;
  }
  int v4 = __s;
  int v5 = *(unsigned __int8 *)__s;
  if (!*__s) {
    return 0;
  }
  uint64_t v9 = 0;
  do
  {
    size_t v10 = strcspn(v4, ",");
    unsigned int v11 = &v4[v10];
    if (v4[v10]) {
      unsigned int v12 = &v4[v10 + 1];
    }
    else {
      unsigned int v12 = &v4[v10];
    }
    if (v10)
    {
      int v13 = v4 + 1;
      if (v5 == 34)
      {
        size_t v14 = strcspn(++v4, "\",");
        v13 += v14;
        uint64_t v15 = (uint64_t)(*v13 == 34 ? v13 + 1 : v13);
      }
      else
      {
        uint64_t v15 = (uint64_t)(v4 + 1);
      }
      int v16 = a2(v9, a3, a4, v4, v13 - v4, v15, &v11[-v15]);
      uint64_t v9 = (v9 + 1);
      if (!v16) {
        break;
      }
    }
    int v5 = *(unsigned __int8 *)v12;
    int v4 = v12;
  }
  while (*v12);
  return v9;
}

uint64_t findOneAttribute(unsigned int a1, char *__s, void *a3, const char *a4, size_t a5, const char *a6, size_t a7)
{
  if (strlen(__s) != a5 || strncmp(a4, __s, a5)) {
    return 1;
  }
  size_t v14 = malloc_type_calloc(a7 + 1, 1uLL, 0xCAE7772DuLL);
  memcpy(v14, a6, a7);
  uint64_t result = 0;
  *((unsigned char *)v14 + a7) = 0;
  *a3 = v14;
  return result;
}

uint64_t copyOneAttribute(unsigned int a1, void *a2, void **a3, const char *__src, size_t __n, const char *a6, size_t a7)
{
  unsigned int v12 = (void *)*a2;
  int v13 = (char *)*a3;
  *(void *)*a2 = *a3;
  memcpy(v13, __src, __n);
  size_t v14 = &v13[__n];
  *v14++ = 0;
  v12[1] = v14;
  memcpy(v14, a6, a7);
  v14[a7] = 0;
  *a2 = v12 + 2;
  *a3 = &v14[a7 + 1];
  return 1;
}

id object_getIvar(id a1, Ivar a2)
{
  id result = 0;
  if ((uint64_t)a1 >= 1 && a2)
  {
    uint64_t v6 = 0;
    int v5 = 0;
    _class_lookUpIvar(*(void *)a1 & 0xFFFFFFFF8, (char *)a2, &v6, &v5);
    int v4 = (id *)((char *)a1 + v6);
    if (v5 == 2) {
      return objc_loadWeak(v4);
    }
    else {
      return *v4;
    }
  }
  return result;
}

uint64_t _class_getIvarMemoryManagement(unint64_t a1, char *a2)
{
  uint64_t v4 = 0;
  unsigned int v3 = 0;
  _class_lookUpIvar(a1, a2, &v4, (int *)&v3);
  return v3;
}

Ivar object_setInstanceVariableWithStrongDefault(id obj, const char *name, void *value)
{
  Variable = 0;
  if ((uint64_t)obj >= 1)
  {
    if (name)
    {
      Variable = (char *)_class_getVariable((objc_class *)(*(void *)obj & 0xFFFFFFFF8), (char *)name);
      if (Variable)
      {
        uint64_t v9 = 0;
        unsigned int v8 = 0;
        _class_lookUpIvar(*(void *)obj & 0xFFFFFFFF8, Variable, &v9, (int *)&v8);
        uint64_t v6 = (id *)((char *)obj + v9);
        if (v8 < 2)
        {
          objc_storeStrong(v6, value);
        }
        else if (v8 == 3)
        {
          *uint64_t v6 = value;
        }
        else if (v8 == 2)
        {
          objc_storeWeak(v6, value);
        }
      }
    }
  }
  return (Ivar)Variable;
}

unint64_t _class_lookUpIvar(unint64_t result, char *a2, uint64_t *a3, int *a4)
{
  unint64_t v7 = result;
  if (a2) {
    uint64_t v8 = **(int **)a2;
  }
  else {
    uint64_t v8 = 0;
  }
  *a3 = v8;
  if (!result) {
    goto LABEL_44;
  }
  for (unint64_t i = result; ; unint64_t i = *(void *)(i + 8))
  {
    id result = class_rw_t::ro((class_rw_t *)(*(void *)(i + 32) & 0xF00007FFFFFFFF8));
    if ((*(_WORD *)result & 0x280) != 0) {
      break;
    }
    if (!*(void *)(i + 8)) {
      goto LABEL_44;
    }
  }
  int v10 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v10, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v10) {
    os_unfair_lock_lock_with_options();
  }
  while (1)
  {
    unint64_t v12 = class_rw_t::ro((class_rw_t *)(*(void *)(v7 + 32) & 0xF00007FFFFFFFF8));
    int v16 = *(unsigned int **)(v12 + 48);
    int v17 = v16 + 2;
    if (v16 && v17 <= (unsigned int *)a2)
    {
      uint64_t v20 = *v16;
      uint64_t v19 = v16[1];
      unint64_t v21 = v19 * (unint64_t)v20;
      if ((v21 & 0xFFFFFFFF00000000) != 0) {
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v13, v14, v15, v19, *(void *)(v12 + 48), v20);
      }
      if ((char *)v17 + v21 > a2) {
        break;
      }
    }
    if (!*(void *)(v7 + 8))
    {
      unint64_t v7 = 0;
      break;
    }
    unint64_t v7 = *(void *)(v7 + 8);
  }
  int v22 = *(_DWORD *)(StatusReg + 24);
  int v23 = v22;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v23, 0, memory_order_release, memory_order_relaxed);
  if (v23 != v22) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  unint64_t v24 = (void *)(v7 + 32);
  id result = class_rw_t::ro((class_rw_t *)(*(void *)(v7 + 32) & 0xF00007FFFFFFFF8));
  if ((*(_WORD *)result & 0x280) == 0) {
    goto LABEL_44;
  }
  uint64_t v25 = *a3;
  unint64_t v26 = v25 - ((*(_DWORD *)(class_rw_t::ro((class_rw_t *)(*v24 & 0xF00007FFFFFFFF8)) + 4) + 7) & 0xFFFFFFF8);
  id result = class_rw_t::ro((class_rw_t *)(*v24 & 0xF00007FFFFFFFF8));
  if (*(unsigned char *)result) {
    goto LABEL_34;
  }
  uint64_t v27 = *(unsigned __int8 **)(result + 16);
  if (!v27) {
    goto LABEL_34;
  }
  uint64_t v28 = 0;
  int64_t v29 = v26 >> 3;
  while (1)
  {
    unsigned int v31 = *v27++;
    char v30 = v31;
    uint64_t v32 = v28 + ((unint64_t)v31 >> 4);
    if (!v31 || v32 > v29) {
      break;
    }
    uint64_t v28 = v32 + (v30 & 0xF);
    int v34 = 1;
    if (v28 > v29) {
      goto LABEL_45;
    }
  }
  if (v7)
  {
LABEL_34:
    id result = class_rw_t::ro((class_rw_t *)(*v24 & 0xF00007FFFFFFFF8));
    unint64_t v35 = *(unsigned __int8 **)(result + 56);
    if (v35)
    {
      uint64_t v36 = 0;
      int64_t v37 = v26 >> 3;
      do
      {
        unsigned int v39 = *v35++;
        char v38 = v39;
        uint64_t v40 = v36 + ((unint64_t)v39 >> 4);
        if (!v39 || v40 > v37) {
          break;
        }
        uint64_t v36 = v40 + (v38 & 0xF);
        int v34 = 2;
      }
      while (v36 <= v37);
    }
  }
  id result = class_rw_t::ro((class_rw_t *)(*v24 & 0xF00007FFFFFFFF8));
  if ((*(unsigned char *)result & 0x80) != 0) {
    int v34 = 3;
  }
  else {
LABEL_44:
  }
    int v34 = 0;
LABEL_45:
  *a4 = v34;
  return result;
}

void sub_1801306A0(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void *objc_class::installMangledNameForLazilyNamedClass(objc_class *this, uint64_t a2, const char *a3, char *a4)
{
  while (1)
  {
    explicit = (uint64_t (*)(objc_class *))atomic_load_explicit(&LazyClassNamerHook, memory_order_acquire);
    if (!explicit) {
      _objc_fatal("Lazily named class %p with no lazy name handler registered", a2, a3, a4, this);
    }
    if ((*((_WORD *)this + 15) & 4) == 0) {
      break;
    }
    this = *(objc_class **)(class_data_bits_t::safe_ro<(Authentication)0>((uint64_t *)this + 4) + 16);
  }
  uint64_t v6 = *(void *)this;
  uint64_t v7 = explicit(this);
  if (!v7) {
    _objc_fatal("Lazily named class %p wasn't named by lazy name handler", v8, v9, v10, this);
  }
  unsigned int v11 = (void *)v7;
  int v12 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v12, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v12) {
    os_unfair_lock_lock_with_options();
  }
  size_t v14 = (atomic_ullong *)(make_ro_writeable_nolock(this) + 24);
  unint64_t v15 = atomic_load_explicit(v14, memory_order_acquire);
  if (v15)
  {
    free(v11);
    unsigned int v11 = (void *)v15;
  }
  else
  {
    atomic_store((unint64_t)v11, (unint64_t *)v14);
    atomic_store((unint64_t)v11, (unint64_t *)(make_ro_writeable_nolock((objc_class *)(v6 & 0xFFFFFFFF8)) + 24));
    addNamedClass(this, (const char *)v11, 0);
  }
  int v16 = *(_DWORD *)(StatusReg + 24);
  int v17 = v16;
  atomic_compare_exchange_strong_explicit(&runtimeLock, (unsigned int *)&v17, 0, memory_order_release, memory_order_relaxed);
  if (v17 != v16) {
    os_unfair_lock_unlock((os_unfair_lock_t)&runtimeLock);
  }
  return v11;
}

void sub_180130838(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)
{
  if (!cls) {
    return 0;
  }
  int v5 = alignment;
  if (types) {
    uint64_t v8 = types;
  }
  else {
    uint64_t v8 = "";
  }
  if (name)
  {
    if (*name) {
      uint64_t v9 = name;
    }
    else {
      uint64_t v9 = 0;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  __s = (char *)v8;
  int v11 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v11, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v11) {
    os_unfair_lock_lock_with_options();
  }
  if ((unint64_t)(*(void *)cls - 1) < 0xF
    || (*(_DWORD *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
    || (uint64_t v13 = *(unsigned __int16 *)((*((void *)cls + 4) & 0xF00007FFFFFFFF8) + 4),
        qword_1EB1CB088 <= v13)
    || (*(void *)(qword_1EB1CB080 + 16 * v13) <= (unint64_t)cls
      ? (BOOL v14 = *(void *)(qword_1EB1CB080 + 16 * v13 + 8) > (unint64_t)cls)
      : (BOOL v14 = 0),
        !v14))
  {
    if (objc::allocatedClasses + 8 * qword_1EB1CAEA0 == objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::find((unint64_t)cls)
      && (dataSegmentsContain(cls, v43, v44) & 1) == 0)
    {
      _objc_fatal("Attempt to use unknown class %p.", v45, v46, v47, cls);
    }
  }
  if ((*((_WORD *)cls + 15) & 4) != 0) {
    goto LABEL_23;
  }
  int v16 = (uint64_t *)((char *)cls + 32);
  uint64_t v15 = *((void *)cls + 4);
  if ((*(unsigned char *)((v15 & 0xF00007FFFFFFFF8) + 3) & 4) == 0) {
    goto LABEL_23;
  }
  if (!v9)
  {
    if (HIDWORD(size))
    {
LABEL_23:
      BOOL v10 = 0;
      goto LABEL_24;
    }
LABEL_32:
    ro_writeable_nolocuint64_t k = make_ro_writeable_nolock((class_rw_t *)(v15 & 0xF00007FFFFFFFF8));
    unint64_t v24 = *(unsigned int **)(class_rw_t::ro((class_rw_t *)(*v16 & 0xF00007FFFFFFFF8)) + 48);
    if (v24)
    {
      uint64_t v25 = *v24;
      unint64_t v26 = v24[1] * (unint64_t)v25;
      if ((v26 & 0xFFFFFFFF00000000) != 0) {
        _objc_fatal("entsize_list_tt overflow: count %u with entsize %u", v21, v22, v23, v24[1], v25);
      }
      size_t v27 = v26 + 8;
      uint64_t v28 = (unsigned int *)malloc_type_calloc(v27 + v25, 1uLL, 0x6A23870CuLL);
      memcpy(v28, v24, v27);
      free(v24);
    }
    else
    {
      uint64_t v28 = (unsigned int *)malloc_type_calloc(0x28uLL, 1uLL, 0x2B3CB0EDuLL);
      *uint64_t v28 = 32;
    }
    int v32 = *(_DWORD *)(class_rw_t::ro((class_rw_t *)(*v16 & 0xF00007FFFFFFFF8)) + 8);
    uint64_t v34 = *v28;
    uint64_t v33 = v28[1];
    v28[1] = v33 + 1;
    unint64_t v35 = v33 * (unint64_t)v34;
    if ((v35 & 0xFFFFFFFF00000000) != 0) {
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v29, v30, v31, v33, v28, v34);
    }
    uint64_t v36 = malloc_type_malloc(4uLL, 0x100004052888210uLL);
    int v37 = (v32 + ~(-1 << v5)) & (-1 << v5);
    uint64_t v38 = (uint64_t)v28 + v35 + 8;
    *(void *)uint64_t v38 = v36;
    _DWORD *v36 = v37;
    if (v9)
    {
      size_t v39 = strlen(v9) + 1;
      if ((_dyld_is_memory_immutable() & 1) == 0)
      {
        uint64_t v40 = malloc_type_malloc(v39, 0x3F84A03uLL);
        memcpy(v40, v9, v39);
        uint64_t v9 = (const char *)v40;
      }
    }
    *(void *)(v38 + 8) = v9;
    size_t v41 = strlen(__s) + 1;
    if (_dyld_is_memory_immutable())
    {
      uint64_t v42 = __s;
    }
    else
    {
      uint64_t v42 = malloc_type_malloc(v41, 0x3F84A03uLL);
      memcpy(v42, __s, v41);
    }
    *(void *)(v38 + 16) = v42;
    *(_DWORD *)(v38 + 24) = v5;
    *(_DWORD *)(v38 + 28) = size;
    *(void *)(ro_writeable_nolock + 48) = v28;
    objc_class::setInstanceSize(cls, v37 + size);
    BOOL v10 = 1;
    goto LABEL_24;
  }
  uint64_t Ivar = getIvar(cls, v9);
  BOOL v10 = 0;
  if (!HIDWORD(size) && !Ivar)
  {
    uint64_t v15 = *v16;
    goto LABEL_32;
  }
LABEL_24:
  int v17 = *(_DWORD *)(StatusReg + 24);
  int v18 = v17;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v18, 0, memory_order_release, memory_order_relaxed);
  if (v18 != v17) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return v10;
}

void sub_180130CF0(_Unwind_Exception *exception_object)
{
  int v3 = *(_DWORD *)(v1 + 24);
  int v4 = v3;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, 0, memory_order_release, memory_order_relaxed);
  if (v4 != v3) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _class_getVariable(objc_class *a1, char *a2)
{
  int v4 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v4) {
    os_unfair_lock_lock_with_options();
  }
  if (a1)
  {
    while (1)
    {
      uint64_t Ivar = getIvar(a1, a2);
      if (Ivar) {
        break;
      }
      if (!*((void *)a1 + 1)) {
        goto LABEL_7;
      }
      a1 = (objc_class *)*((void *)a1 + 1);
    }
  }
  else
  {
LABEL_7:
    uint64_t Ivar = 0;
  }
  int v7 = *(_DWORD *)(StatusReg + 24);
  int v8 = v7;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v8, 0, memory_order_release, memory_order_relaxed);
  if (v8 != v7) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return Ivar;
}

void sub_180130E14(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

uint64_t getIvar(objc_class *a1, const char *a2)
{
  unint64_t v3 = class_rw_t::ro((class_rw_t *)(*((void *)a1 + 4) & 0xF00007FFFFFFFF8));
  int v7 = *(unsigned int **)(v3 + 48);
  if (!v7) {
    return 0;
  }
  uint64_t v9 = *v7;
  uint64_t v8 = v7[1];
  unint64_t v10 = v8 * (unint64_t)v9;
  if ((v10 & 0xFFFFFFFF00000000) != 0) {
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v4, v5, v6, v8, *(void *)(v3 + 48), v9);
  }
  if (!v10) {
    return 0;
  }
  uint64_t v11 = 0;
  uint64_t v12 = v10;
  while (1)
  {
    if (*(void *)((char *)v7 + v11 + 8))
    {
      uint64_t v13 = *(const char **)((char *)v7 + v11 + 16);
      if (v13)
      {
        if (!strcmp(a2, v13)) {
          break;
        }
      }
    }
    v11 += v9;
    if (v12 == v11) {
      return 0;
    }
  }
  return (uint64_t)v7 + v11 + 8;
}

unint64_t make_ro_writeable_nolock(class_rw_t *this)
{
  if ((*((unsigned char *)this + 3) & 8) == 0)
  {
    uint64_t v2 = (class_ro_t *)class_rw_t::ro(this);
    unint64_t v3 = class_ro_t::duplicate(v2);
    uint64_t v4 = (void *)((char *)this + 8);
    uint64_t v5 = *((void *)this + 1);
    if (v5)
    {
      uint64_t v4 = (void *)(v5 & 0xFFFFFFFFFFFFFFFELL);
      if (v3)
      {
        uint64_t v6 = v3;
        goto LABEL_8;
      }
    }
    else if (v3)
    {
      uint64_t v6 = v3;
LABEL_8:
      *uint64_t v4 = v6;
      *(_DWORD *)this |= 0x8000000u;
      goto LABEL_9;
    }
    uint64_t v6 = 0;
    goto LABEL_8;
  }
LABEL_9:

  return class_rw_t::ro(this);
}

void *class_ro_t::duplicate(class_ro_t *this)
{
  int v2 = *(_DWORD *)this;
  if ((*(_DWORD *)this & 0x40) != 0) {
    size_t v3 = 80;
  }
  else {
    size_t v3 = 72;
  }
  uint64_t v4 = malloc_type_malloc(v3, 0x3F84A03uLL);
  memcpy(v4, this, v3);
  if ((v2 & 0x40) != 0) {
    v4[9] = *((void *)this + 9);
  }
  unint64_t v5 = *((void *)this + 4);
  if (v5) {
    BOOL v6 = (*((void *)this + 4) & 1) == 0;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6)
  {
    unint64_t v7 = v5 & 0xFFFFFFFFFFFFFFFELL;
    if ((v5 & 0xFFFFFFFFFFFFFFFELL) != 0) {
      goto LABEL_14;
    }
  }
  else if ((v5 & 1) != 0 && v5 >= 2)
  {
    unint64_t v7 = v5 | 1;
LABEL_14:
    v4[4] = v7;
  }
  return v4;
}

unint64_t make_ro_writeable_nolock(objc_class *a1)
{
  if ((unint64_t)(*(void *)a1 - 1) < 0xF
    || (uint64_t v2 = *((void *)a1 + 4), (*(_DWORD *)(v2 & 0xF00007FFFFFFFF8) & 0x80000000) == 0))
  {
    realizeAndInitializeIfNeeded_locked(0, a1, 0);
    uint64_t v2 = *((void *)a1 + 4);
  }

  return make_ro_writeable_nolock((class_rw_t *)(v2 & 0xF00007FFFFFFFF8));
}

Method *__cdecl class_copyMethodList(Class cls, unsigned int *outCount)
{
  if (!cls)
  {
    int v18 = 0;
    if (outCount) {
      *outCount = 0;
    }
    return v18;
  }
  int v4 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v4) {
    os_unfair_lock_lock_with_options();
  }
  class_rw_t::methods(&v119, *((void *)cls + 4) & 0xF00007FFFFFFFF8);
  v109 = (uint64_t *)&v119;
  if (!v119) {
    goto LABEL_15;
  }
  unint64_t v16 = v119 & 3;
  if ((v119 & 3) == 0)
  {
    if ((v119 & 0xFFFFFFFFFFFFFFFCLL) != 0)
    {
      uint64_t v13 = (unsigned int *)(v119 & 0xFFFFFFFFFFFFFFFCLL);
      v110 = (unsigned int *)(v119 & 0xFFFFFFFFFFFFFFFCLL);
      goto LABEL_26;
    }
LABEL_15:
    uint64_t v13 = 0;
    v110 = 0;
    goto LABEL_16;
  }
  if (v119 <= 3) {
    goto LABEL_15;
  }
  if (v16 != 2)
  {
    if (v16 == 1)
    {
      unint64_t v17 = v119 & 0xFFFFFFFFFFFFFFFCLL;
      if ((v119 & 0xFFFFFFFFFFFFFFFCLL) != 0)
      {
        uint64_t v13 = (unsigned int *)(v17 + 8);
        v110 = (unsigned int *)(v17 + 8);
      }
    }
    goto LABEL_26;
  }
  uint64_t v13 = (unsigned int *)(v119 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v119 & 0xFFFFFFFFFFFFFFFCLL) == 0)
  {
LABEL_26:
    uint64_t v104 = (uint64_t *)&v119;
    goto LABEL_27;
  }
  if (DisablePreattachedCategories)
  {
    unint64_t v21 = *v13;
    uint64_t v20 = v13[1];
    unint64_t v97 = v20 * (unint64_t)v21;
    if ((v97 & 0xFFFFFFFF00000000) != 0) {
      goto LABEL_259;
    }
    unint64_t v98 = v21 | (v20 << 32);
    uint64_t v12 = (uint64_t *)((char *)v13 + v97 + 8);
    unint64_t v99 = v21 | ((unint64_t)(v20 - 1) << 32);
    BOOL v100 = v20 == 0;
    if (v20) {
      uint64_t v20 = v20;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v100)
    {
      unint64_t v11 = v98;
    }
    else
    {
      uint64_t v12 = (uint64_t *)((char *)v12 - v21);
      unint64_t v11 = v99;
    }
  }
  else
  {
    uint64_t v12 = (uint64_t *)(v13 + 2);
    unint64_t v11 = *v13;
    uint64_t v20 = v13[1];
    unint64_t v21 = v11;
  }
  unint64_t v22 = v20 * (unint64_t)v21;
  if ((v22 & 0xFFFFFFFF00000000) != 0) {
    goto LABEL_259;
  }
  unint64_t v14 = HIDWORD(v11);
  for (i = (unint64_t)v13 + v22 + 8; (unint64_t)v12 < i; unint64_t v14 = (v14 + 1))
  {
    uint64_t v15 = *(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v12 + 8);
    if (v15) {
      break;
    }
    uint64_t v12 = (uint64_t *)((char *)v12 + v11);
  }
  v110 = (unsigned int *)(v119 & 0xFFFFFFFFFFFFFFFCLL);
  unint64_t v111 = v11 | (v14 << 32);
  unint64_t v112 = v12;
LABEL_16:
  uint64_t v104 = (uint64_t *)&v119;
  if (v119)
  {
LABEL_27:
    uint64_t v19 = (unsigned int *)(v119 & 3);
    if (v19 != (unsigned int *)2)
    {
      if (v19 == (unsigned int *)1)
      {
        uint64_t v19 = (unsigned int *)(v119 & 0xFFFFFFFFFFFFFFFCLL);
        if ((v119 & 0xFFFFFFFFFFFFFFFCLL) != 0)
        {
          v19 += 2 * *v19 + 2;
          unint64_t v105 = (unint64_t)v19;
        }
        goto LABEL_37;
      }
      if ((v119 & 3) != 0)
      {
        uint64_t v19 = 0;
        goto LABEL_37;
      }
      goto LABEL_30;
    }
    uint64_t v19 = (unsigned int *)(v119 & 0xFFFFFFFFFFFFFFFCLL);
    if ((v119 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
      goto LABEL_37;
    }
    uint64_t v24 = *v19;
    uint64_t v20 = v19[1];
    unint64_t v25 = v20 * (unint64_t)v24;
    if ((v25 & 0xFFFFFFFF00000000) == 0)
    {
      uint64_t v15 = (uint64_t)v19 + v25 + 8;
      unint64_t v105 = v119 & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v106 = v24 | (v20 << 32);
      int v107 = (unsigned __int16 *)v15;
      goto LABEL_37;
    }
    uint64_t v13 = (unsigned int *)(v119 & 0xFFFFFFFFFFFFFFFCLL);
    unint64_t v21 = *v19;
LABEL_259:
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)v6, v7, v8, v9, v10, v20, v13, v21);
  }
  uint64_t v19 = 0;
LABEL_30:
  unint64_t v105 = 0;
LABEL_37:
  int v26 = 0;
  BOOL v6 = &v105;
  unint64_t v7 = (const char *)(2 * v11);
  uint64_t v8 = (char *)((unint64_t)&v119 | 0x23CD000000000000);
  uint64_t v9 = &v122;
  uint64_t v10 = 4;
LABEL_38:
  size_t v27 = v12;
  while (1)
  {
    if (!v119) {
      goto LABEL_43;
    }
    if ((v119 & 3) == 2) {
      break;
    }
    if ((v119 & 3) == 1)
    {
      if (v13 == v19) {
        goto LABEL_75;
      }
      goto LABEL_54;
    }
    if ((v119 & 3) != 0) {
      goto LABEL_54;
    }
LABEL_43:
    if (v13)
    {
      uint64_t v28 = v13;
      if (v19) {
        goto LABEL_45;
      }
    }
    else
    {
      uint64_t v28 = 0;
      if (v19)
      {
LABEL_45:
        uint64_t v29 = v19;
        goto LABEL_48;
      }
    }
    uint64_t v29 = 0;
LABEL_48:
    if (v28 == v29) {
      goto LABEL_75;
    }
    if (!v119) {
      goto LABEL_57;
    }
LABEL_54:
    switch(v119 & 3)
    {
      case 2uLL:
        char v30 = (unsigned int *)((char *)v27 + (*v27 >> 16));
        break;
      case 1uLL:
        char v30 = *(unsigned int **)v13;
        break;
      case 0uLL:
LABEL_57:
        if (v13) {
          char v30 = v13;
        }
        else {
          char v30 = 0;
        }
        break;
      default:
        v26 += MEMORY[4];
        goto LABEL_64;
    }
    v26 += v30[1];
    if (v119)
    {
LABEL_64:
      unint64_t v31 = v119 & 3;
      if ((v119 & 3) == 0) {
        goto LABEL_68;
      }
      if (v31 == 2)
      {
        uint64_t v12 = (uint64_t *)((char *)v27 + v11);
        unint64_t v112 = v12;
        unint64_t v32 = *v13;
        uint64_t v20 = v13[1];
        unint64_t v33 = v20 * (unint64_t)v32;
        LODWORD(v14) = v14 + 1;
        HIDWORD(v111) = v14;
        if ((v33 & 0xFFFFFFFF00000000) != 0)
        {
          unint64_t v21 = v32;
          goto LABEL_259;
        }
        while (v12 < (uint64_t *)((char *)v13 + v33 + 8))
        {
          if (*(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)((char *)v27 + v11) + 8))
          {
            uint64_t v12 = (uint64_t *)((char *)v27 + v11);
            goto LABEL_38;
          }
          unint64_t v112 = (uint64_t *)&v7[(void)v27];
          LODWORD(v14) = v14 + 1;
          HIDWORD(v111) = v14;
          size_t v27 = (uint64_t *)((char *)v27 + v11);
          uint64_t v12 = (uint64_t *)((char *)v27 + v11);
        }
        goto LABEL_38;
      }
      if (v31 == 1)
      {
        v13 += 2;
        goto LABEL_69;
      }
    }
    else
    {
LABEL_68:
      uint64_t v13 = 0;
LABEL_69:
      v110 = v13;
    }
  }
  if (v27 != (uint64_t *)v15) {
    goto LABEL_54;
  }
LABEL_75:
  if (!v26)
  {
    unsigned int v35 = 0;
    int v18 = 0;
    if (outCount) {
      goto LABEL_213;
    }
    goto LABEL_214;
  }
  uint64_t v104 = (uint64_t *)&v119;
  if (!v119) {
    goto LABEL_88;
  }
  unint64_t v34 = v119 & 3;
  if ((v119 & 3) == 0)
  {
    if ((v119 & 0xFFFFFFFFFFFFFFFCLL) != 0)
    {
      unint64_t v105 = v119 & 0xFFFFFFFFFFFFFFFCLL;
      goto LABEL_87;
    }
    goto LABEL_88;
  }
  if (v119 <= 3)
  {
LABEL_88:
    unint64_t v105 = 0;
    goto LABEL_89;
  }
  if (v34 != 2)
  {
    if (v34 == 1 && (v119 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
      unint64_t v105 = (v119 & 0xFFFFFFFFFFFFFFFCLL) + 8;
    }
LABEL_87:
    unint64_t v122 = &v119;
LABEL_90:
    if ((v119 & 3) != 2)
    {
      if ((v119 & 3) == 1)
      {
        if ((v119 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
          unint64_t v123 = (v119 & 0xFFFFFFFFFFFFFFFCLL) + 8 * *(unsigned int *)(v119 & 0xFFFFFFFFFFFFFFFCLL) + 8;
        }
      }
      else if ((v119 & 3) == 0)
      {
        goto LABEL_93;
      }
      goto LABEL_99;
    }
    uint64_t v36 = (unsigned int *)(v119 & 0xFFFFFFFFFFFFFFFCLL);
    if ((v119 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
      goto LABEL_99;
    }
    unint64_t v37 = *v36;
    uint64_t v38 = v36[1];
    unint64_t v39 = v38 * (unint64_t)v37;
    if ((v39 & 0xFFFFFFFF00000000) == 0)
    {
      unint64_t v123 = v119 & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v124 = v37 | (v38 << 32);
      uint64_t v125 = (uint64_t)v36 + v39 + 8;
      goto LABEL_99;
    }
LABEL_261:
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)&v105, v7, v8, v38, v36, v37);
  }
  uint64_t v36 = (unsigned int *)(v119 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v119 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
    goto LABEL_87;
  }
  if (DisablePreattachedCategories)
  {
    unint64_t v37 = *v36;
    uint64_t v38 = v36[1];
    unint64_t v101 = v38 * (unint64_t)v37;
    if ((v101 & 0xFFFFFFFF00000000) != 0) {
      goto LABEL_261;
    }
    unint64_t v91 = v37 | (v38 << 32);
    long long v90 = (unsigned __int16 *)((char *)v36 + v101 + 8);
    unint64_t v102 = v37 | ((unint64_t)(v38 - 1) << 32);
    BOOL v103 = v38 == 0;
    if (v38) {
      uint64_t v38 = v38;
    }
    else {
      uint64_t v38 = 0;
    }
    if (!v103)
    {
      long long v90 = (unsigned __int16 *)((char *)v90 - v37);
      unint64_t v91 = v102;
    }
  }
  else
  {
    long long v90 = (unsigned __int16 *)(v36 + 2);
    unint64_t v91 = *v36;
    uint64_t v38 = v36[1];
    unint64_t v37 = v91;
  }
  unint64_t v92 = v38 * (unint64_t)v37;
  if ((v92 & 0xFFFFFFFF00000000) != 0) {
    goto LABEL_261;
  }
  unint64_t v93 = HIDWORD(v91);
  unint64_t v94 = (unint64_t)v36 + v92 + 8;
  while ((unint64_t)v90 < v94 && (*(void *)(objc_debug_headerInfoRWs + 8 * *v90 + 8) & 1) == 0)
  {
    long long v90 = (unsigned __int16 *)((char *)v90 + v91);
    unint64_t v93 = (v93 + 1);
  }
  unint64_t v105 = v119 & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v106 = v91 | (v93 << 32);
  int v107 = v90;
LABEL_89:
  unint64_t v122 = &v119;
  if (v119) {
    goto LABEL_90;
  }
LABEL_93:
  unint64_t v123 = 0;
LABEL_99:
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<true>::iteratorImpl((uint64_t)&v109, (uint64_t)&v104, &v122);
  unint64_t v122 = &v119;
  if (v119)
  {
    switch(v119 & 3)
    {
      case 2uLL:
        uint32_t v86 = (unsigned int *)(v119 & 0xFFFFFFFFFFFFFFFCLL);
        if ((v119 & 0xFFFFFFFFFFFFFFFCLL) != 0)
        {
          uint64_t v88 = *v86;
          uint64_t v87 = v86[1];
          unint64_t v89 = v87 * (unint64_t)v88;
          if ((v89 & 0xFFFFFFFF00000000) != 0) {
            _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v40, v41, v42, v87, v119 & 0xFFFFFFFFFFFFFFFCLL, v88);
          }
          unint64_t v123 = v119 & 0xFFFFFFFFFFFFFFFCLL;
          unint64_t v124 = v88 | (v87 << 32);
          uint64_t v125 = (uint64_t)v86 + v89 + 8;
        }
        break;
      case 1uLL:
        if ((v119 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
          unint64_t v123 = (v119 & 0xFFFFFFFFFFFFFFFCLL) + 8 * *(unsigned int *)(v119 & 0xFFFFFFFFFFFFFFFCLL) + 8;
        }
        break;
      case 0uLL:
        goto LABEL_103;
    }
  }
  else
  {
LABEL_103:
    unint64_t v123 = 0;
  }
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::ListIterator::ListIterator((uint64_t)v121, (uint64_t)&v122);
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::ListIterator::ListIterator((uint64_t)v120, (uint64_t)&v122);
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<true>::iteratorImpl((uint64_t)&v104, (uint64_t)v121, v120);
  int v18 = (Method *)malloc_type_malloc(8 * (v26 + 1), 0x2004093837F09uLL);
  unsigned int v35 = 0;
  while (2)
  {
    if (v109 != v104)
    {
LABEL_106:
      if (*((void *)&v116 + 1)) {
        uint64_t v46 = (objc_method *)*((void *)&v116 + 1);
      }
      else {
        uint64_t v46 = 0;
      }
      v18[v35] = v46;
      if (*((void *)&v116 + 1))
      {
        uint64_t v47 = *((void *)&v116 + 1) + v116;
        *((void *)&v116 + 1) = v47;
        ++DWORD1(v116);
        if (v47) {
          uint64_t v48 = v47;
        }
        else {
          uint64_t v48 = 0;
        }
      }
      else
      {
        uint64_t v48 = 0;
        HIDWORD(v116) = 0;
        *(void *)((char *)&v116 + 4) = (DWORD1(v116) + 1);
      }
      if (v48 != v118) {
        goto LABEL_192;
      }
      uint64_t v49 = *v109;
      if (*v109)
      {
        if ((*v109 & 3) == 1)
        {
          v110 += 2;
          uint64_t v49 = *v109;
          if (*v109) {
            goto LABEL_127;
          }
        }
        else
        {
          if ((v49 & 3) == 0) {
            v110 = 0;
          }
LABEL_127:
          if ((v49 & 3) == 2)
          {
            unint64_t v52 = v112;
            int v53 = HIDWORD(v111);
            BOOL v54 = (uint64_t *)((char *)v112 + v111);
            unint64_t v112 = v54;
            uint64_t v56 = *v110;
            uint64_t v55 = v110[1];
            unint64_t v57 = v55 * (unint64_t)v56;
            ++HIDWORD(v111);
            if ((v57 & 0xFFFFFFFF00000000) != 0) {
              _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v43, v44, v45, v55, v110, v56);
            }
            unint64_t v58 = (unint64_t)v110 + v57 + 8;
            if ((unint64_t)v54 < v58)
            {
              int v59 = v53 + 2;
              do
              {
                if ((*(void *)(objc_debug_headerInfoRWs
                                + 8 * *(unsigned __int16 *)((char *)v52 + v111)
                                + 8) & 1) != 0)
                  break;
                unint64_t v112 = (uint64_t *)((char *)v52 + 2 * v111);
                HIDWORD(v111) = v59++;
                unint64_t v52 = (uint64_t *)((char *)v52 + v111);
              }
              while ((unint64_t)v52 + v111 < v58);
            }
          }
        }
      }
      else
      {
        v110 = 0;
      }
      list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::skipEmptyLists(&v109);
      uint64_t v60 = *v109;
      if (v109 != v113)
      {
LABEL_134:
        if (v60) {
          goto LABEL_135;
        }
LABEL_138:
        uint64_t v62 = v110;
        if (v110)
        {
LABEL_160:
          uint64_t v68 = v62;
          goto LABEL_162;
        }
        goto LABEL_163;
      }
      if (!v60)
      {
LABEL_144:
        if (v110) {
          unint64_t v63 = v110;
        }
        else {
          unint64_t v63 = 0;
        }
        if (v63 != v114) {
          goto LABEL_134;
        }
        goto LABEL_192;
      }
      if ((*v109 & 3) == 2)
      {
        uint64_t v78 = v112;
        uint64_t v79 = v115;
      }
      else
      {
        if ((*v109 & 3) != 1)
        {
          if ((v60 & 3) == 0) {
            goto LABEL_144;
          }
LABEL_135:
          uint64_t v61 = *v109 & 3;
          switch(v61)
          {
            case 2:
              uint64_t v68 = (unsigned int *)((char *)v112 + (*v112 >> 16));
              if (v68) {
LABEL_162:
              }
                uint64_t v62 = v68;
              else {
                uint64_t v62 = 0;
              }
LABEL_163:
              v121[0] = v62;
              break;
            case 1:
              uint64_t v62 = *(unsigned int **)v110;
              if (*(void *)v110) {
                goto LABEL_160;
              }
              goto LABEL_163;
            case 0:
              goto LABEL_138;
            default:
              uint64_t v62 = 0;
              v121[0] = 0;
              break;
          }
          unint64_t v69 = *v62;
          unint64_t v122 = (unint64_t *)((unsigned __int16)v69 & 0xFFFC);
          uint64_t v70 = v69 >> 31;
          if ((uint64_t)v62 < 0) {
            uint64_t v70 = 2;
          }
          unint64_t v71 = v70 | (unint64_t)(v62 + 2) & 0xFFFFFFFFFFFFFFFCLL;
          *(void *)&long long v116 = v122;
          if (v71) {
            unint64_t v71 = v70 | (unint64_t)(v62 + 2) & 0xFFFFFFFFFFFFFFFCLL;
          }
          *((void *)&v116 + 1) = v71;
          if (*v109)
          {
            switch(*v109 & 3)
            {
              case 2:
                uint64_t v73 = (unsigned int *)((char *)v112 + (*v112 >> 16));
                if (v73) {
LABEL_178:
                }
                  unsigned int v72 = v73;
                else {
                  unsigned int v72 = 0;
                }
                break;
              case 1:
                unsigned int v72 = *(unsigned int **)v110;
                if (*(void *)v110)
                {
LABEL_176:
                  uint64_t v73 = v72;
                  goto LABEL_178;
                }
                break;
              case 0:
                goto LABEL_173;
              default:
                int v74 = 0;
                v120[0] = 0;
LABEL_183:
                entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::signedEnd((uint64_t)&v122, v74, v44, v45);
                v117 = v122;
                if (v123) {
                  unint64_t v75 = v123;
                }
                else {
                  unint64_t v75 = 0;
                }
                unint64_t v118 = v75;
                if (*((void *)&v116 + 1))
                {
                  uint64_t v76 = *((void *)&v116 + 1);
                  if (v75) {
                    goto LABEL_188;
                  }
LABEL_190:
                  unint64_t v77 = 0;
                }
                else
                {
                  uint64_t v76 = 0;
                  if (!v75) {
                    goto LABEL_190;
                  }
LABEL_188:
                  unint64_t v77 = v75;
                }
                if (v76 != v77)
                {
LABEL_192:
                  ++v35;
                  continue;
                }
                if (!*v109)
                {
LABEL_232:
                  uint64_t v95 = (unint64_t *)v110;
                  if (v110)
                  {
                    int v96 = (unint64_t *)v110;
                    goto LABEL_241;
                  }
                  goto LABEL_242;
                }
                switch(*v109 & 3)
                {
                  case 2:
                    int v96 = (unint64_t *)((char *)v112 + (*v112 >> 16));
                    if (v96) {
LABEL_241:
                    }
                      uint64_t v95 = v96;
                    else {
                      uint64_t v95 = 0;
                    }
LABEL_242:
                    unint64_t v122 = v95;
                    break;
                  case 1:
                    uint64_t v95 = *(unint64_t **)v110;
                    goto LABEL_242;
                  case 0:
                    goto LABEL_232;
                  default:
                    uint64_t v95 = 0;
                    unint64_t v122 = 0;
                    break;
                }
                _objc_fatal("Assertion failed: (%s) - empty list %p encountered during iteration", v43, v44, v45, "m != mEnd", v95);
            }
          }
          else
          {
LABEL_173:
            unsigned int v72 = v110;
            if (v110) {
              goto LABEL_176;
            }
          }
          v120[0] = v72;
          if (v72) {
            int v74 = v72;
          }
          else {
            int v74 = 0;
          }
          goto LABEL_183;
        }
        uint64_t v78 = (uint64_t *)v110;
        uint64_t v79 = (uint64_t *)v114;
      }
      if (v78 != v79) {
        goto LABEL_135;
      }
      goto LABEL_192;
    }
    break;
  }
  uint64_t v50 = *v109;
  if (*v109)
  {
    if ((*v109 & 3) == 2)
    {
      unint64_t v64 = v112;
      unint64_t v65 = (unint64_t)v107;
    }
    else
    {
      if ((*v109 & 3) != 1)
      {
        if ((v50 & 3) != 0) {
          goto LABEL_106;
        }
        goto LABEL_122;
      }
      unint64_t v64 = (uint64_t *)v110;
      unint64_t v65 = v105;
    }
    if (v64 != (uint64_t *)v65) {
      goto LABEL_106;
    }
  }
  else
  {
LABEL_122:
    if (v110) {
      char v51 = v110;
    }
    else {
      char v51 = 0;
    }
    if (v51 != (unsigned int *)v105) {
      goto LABEL_106;
    }
  }
  if (v109 != v113) {
    goto LABEL_208;
  }
  if (!v50) {
    goto LABEL_157;
  }
  uint64_t v66 = *v109 & 3;
  if (v66 == 2)
  {
    uint64_t v80 = v112;
    int v81 = v115;
LABEL_207:
    if (v80 == v81) {
      goto LABEL_212;
    }
    goto LABEL_208;
  }
  if (v66 == 1)
  {
    uint64_t v80 = (uint64_t *)v110;
    int v81 = (uint64_t *)v114;
    goto LABEL_207;
  }
  if (v66) {
    goto LABEL_208;
  }
LABEL_157:
  if (v110) {
    unint64_t v67 = v110;
  }
  else {
    unint64_t v67 = 0;
  }
  if (v67 != v114)
  {
LABEL_208:
    if (*((void *)&v116 + 1)) {
      uint64_t v82 = *((void *)&v116 + 1);
    }
    else {
      uint64_t v82 = 0;
    }
    if (v82 == v108) {
      goto LABEL_212;
    }
    goto LABEL_106;
  }
LABEL_212:
  v18[v35] = 0;
  if (outCount) {
LABEL_213:
  }
    *outCount = v35;
LABEL_214:
  int v83 = *(_DWORD *)(StatusReg + 24);
  int v84 = v83;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v84, 0, memory_order_release, memory_order_relaxed);
  if (v84 != v83) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return v18;
}

void sub_1801324C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  int v16 = *(_DWORD *)(v14 + 24);
  int v17 = v16;
  atomic_compare_exchange_strong_explicit(v13, (unsigned int *)&v17, 0, memory_order_release, memory_order_relaxed);
  if (v17 != v16) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

uint64_t **list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::skipEmptyLists(uint64_t **result)
{
  uint64_t v1 = *result;
  uint64_t v2 = result[4];
  size_t v3 = result + 1;
  int v4 = result + 5;
  uint64_t v5 = objc_debug_headerInfoRWs;
  uint64_t v6 = **result;
  while (1)
  {
    if (v1 != v2) {
      goto LABEL_11;
    }
    if (!v6) {
      goto LABEL_7;
    }
    if ((v6 & 3) == 2)
    {
      uint64_t v20 = result[3];
      unint64_t v21 = result[7];
      goto LABEL_36;
    }
    if ((v6 & 3) == 1)
    {
      uint64_t v20 = *v3;
      unint64_t v21 = *v4;
LABEL_36:
      if (v20 == v21) {
        return result;
      }
      goto LABEL_12;
    }
    if ((v6 & 3) != 0) {
      goto LABEL_11;
    }
LABEL_7:
    unint64_t v7 = *v3 ? *v3 : 0;
    if (v7 == *v4) {
      return result;
    }
LABEL_11:
    if (!v6)
    {
      int v8 = 1;
LABEL_16:
      uint64_t v9 = (uint64_t)*v3;
      goto LABEL_18;
    }
LABEL_12:
    int v8 = v6 & 3;
    if ((v6 & 3) != 1)
    {
      if ((v6 & 3) != 0)
      {
        int v8 = 0;
        uint64_t v9 = (uint64_t)result[3] + (*result[3] >> 16);
        goto LABEL_18;
      }
      goto LABEL_16;
    }
    uint64_t v9 = **v3;
    int v8 = 0;
LABEL_18:
    if (*(_DWORD *)(v9 + 4)) {
      return result;
    }
    if (v8)
    {
      uint64_t v6 = 0;
      *size_t v3 = 0;
    }
    else
    {
      if ((v6 & 3) == 1)
      {
        ++*v3;
        uint64_t v10 = *v1;
      }
      else
      {
        if ((v6 & 3) == 0) {
          *size_t v3 = 0;
        }
        uint64_t v10 = v6;
      }
      uint64_t v6 = 0;
      if (v10)
      {
        uint64_t v6 = v10;
        if ((v10 & 3) == 2)
        {
          unint64_t v11 = result[3];
          uint64_t v13 = *((unsigned int *)result + 4);
          uint64_t v12 = (char *)*((unsigned int *)result + 5);
          result[3] = (uint64_t *)((char *)v11 + v13);
          uint64_t v14 = (unsigned int *)result[1];
          uint64_t v16 = *v14;
          uint64_t v15 = (const char *)v14[1];
          unint64_t v17 = v15 * (unint64_t)v16;
          *((_DWORD *)result + 5) = v12 + 1;
          if ((v17 & 0xFFFFFFFF00000000) != 0) {
            _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)v22, v15, v12, v15, v14, v16);
          }
          unint64_t v18 = (unint64_t)v14 + v17 + 8;
          uint64_t v6 = v10;
          if ((unint64_t)v11 + v13 < v18)
          {
            int v19 = v12 + 2;
            do
            {
              if (*(void *)(v5 + 8 * *(unsigned __int16 *)((char *)v11 + v13) + 8)) {
                break;
              }
              result[3] = (uint64_t *)((char *)v11 + 2 * v13);
              *((_DWORD *)result + 5) = v19++;
              unint64_t v11 = (uint64_t *)((char *)v11 + v13);
            }
            while ((unint64_t)v11 + v13 < v18);
            uint64_t v6 = v10;
          }
        }
      }
    }
  }
}

uint64_t entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::signedEnd(uint64_t result, unsigned int *a2, const char *a3, char *a4)
{
  unint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  *(_DWORD *)id result = *a2 & 0xFFFC;
  *(_DWORD *)(result + 4) = v4;
  unint64_t v6 = v4 * (unint64_t)((unsigned __int16)v5 & 0xFFFC);
  if ((v6 & 0xFFFFFFFF00000000) != 0) {
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v4, a2, v5 & 0xFFFC);
  }
  uint64_t v7 = v5 >> 31;
  if ((uint64_t)a2 < 0) {
    uint64_t v7 = 2;
  }
  *(void *)(result + 8) = ((unint64_t)a2 + v6 + 8) & 0xFFFFFFFFFFFFFFFCLL | v7;
  return result;
}

objc_property_t *__cdecl protocol_copyPropertyList(Protocol *proto, unsigned int *outCount)
{
  return protocol_copyPropertyList2(proto, outCount, 1, 1);
}

uint64_t _objc_rootIsDeallocating(objc_object *a1)
{
  if (((unint64_t)a1 & 0x8000000000000000) != 0) {
    return 0;
  }
  if ((uint64_t)a1->isa) {
    return (unint64_t)a1->isa >> 55 == 0;
  }
  return objc_object::sidetable_isDeallocating(a1);
}

unint64_t _method_getImplementationAndName(unint64_t a1)
{
  if (a1) {
    unint64_t v1 = a1;
  }
  else {
    unint64_t v1 = 0;
  }
  return method_t::imp(v1, 1);
}

const char *__cdecl ivar_getTypeEncoding(const char *v)
{
  if (v) {
    return (const char *)*((void *)v + 2);
  }
  return v;
}

const char *__cdecl class_getImageName(const char *cls)
{
  if (cls)
  {
    unint64_t v1 = 0;
    if (((unsigned int (*)(const char *, const char **))atomic_load_explicit(&GetImageNameHook, memory_order_acquire))(cls, &v1))
    {
      return v1;
    }
    else
    {
      return 0;
    }
  }
  return cls;
}

BOOL internal_class_getImageName(objc_class *a1, const char **a2)
{
  size_t v3 = (const char *)dyld_image_path_containing_address();
  *a2 = v3;
  return v3 != 0;
}

objc_method_description *__cdecl method_getDescription(objc_method_description *m)
{
  if (m)
  {
    int v1 = m & 3;
    if ((m & 3) != 0)
    {
      if (v1 == 2 || v1 == 1) {
        return (objc_method_description *)method_t::getCachedDescription((uint64_t)m);
      }
    }
    else
    {
      return (objc_method_description *)((unint64_t)m & 0xFFFFFFFFFFFFFFFCLL);
    }
  }
  return m;
}

Protocol *__cdecl objc_getProtocol(const char *name)
{
  int v2 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v2, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v2) {
    os_unfair_lock_lock_with_options();
  }
  uint64_t Protocol = (Protocol *)getProtocol(name);
  int v5 = *(_DWORD *)(StatusReg + 24);
  int v6 = v5;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v6, 0, memory_order_release, memory_order_relaxed);
  if (v6 != v5) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return Protocol;
}

void sub_180132C04(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

id objc_initWeakOrNil(id *location, id val)
{
  unint64_t v2 = (unint64_t)val;
  if (!val)
  {
    *location = 0;
    return (id)v2;
  }
  int v4 = 0;
                                           * (unint64_t)(((val >> 4) ^ (val >> 9)) & 7)];
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v7 = (objc_class **)&objc_debug_taggedpointer_classes[val & 7];
  int v8 = &objc_debug_taggedpointer_ext_classes[((unint64_t)val >> 55)];
  while (1)
  {
    int v9 = 0;
    atomic_compare_exchange_strong_explicit(v5, (unsigned int *)&v9, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v9) {
      os_unfair_lock_lock_with_options();
    }
    if ((v2 & 0x8000000000000000) == 0)
    {
      uint64_t v10 = *(void *)v2 & 0x7FFFFFFFFFFFF8;
      if (!v10) {
        goto LABEL_11;
      }
LABEL_7:
      unint64_t v11 = (objc_class *)v10;
      goto LABEL_12;
    }
    if (!*v7) {
      goto LABEL_11;
    }
    unint64_t v11 = *v7;
    if (*v7 == (objc_class *)__NSUnrecognizedTaggedPointer)
    {
      uint64_t v10 = *v8;
      if (!*v8)
      {
LABEL_11:
        unint64_t v11 = 0;
        goto LABEL_12;
      }
      goto LABEL_7;
    }
LABEL_12:
    if (v11 == v4) {
      break;
    }
    int v12 = *(_DWORD *)(*((void *)v11 + 4) & 0xF00007FFFFFFFF8);
    if ((v12 & 1) == 0) {
      int v12 = *(_DWORD *)(*(void *)((*(void *)v11 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
    }
    if ((v12 & 0x20000000) != 0) {
      break;
    }
    int v13 = *(_DWORD *)(StatusReg + 24);
    int v14 = v13;
    atomic_compare_exchange_strong_explicit(v5, (unsigned int *)&v14, 0, memory_order_release, memory_order_relaxed);
    if (v14 != v13) {
                                                                                  * (unint64_t)(((v2 >> 4) ^ (v2 >> 9)) & 7)]);
    }
    class_initialize(v11, (objc_object *)v2);
    int v4 = v11;
  }
  int64_t v15 = weak_register_no_lock((char **)v5 + 4, v2, (unint64_t)location, 0);
  unint64_t v2 = v15;
  if (v15 >= 1)
  {
    atomic_ullong v16 = *(void *)v15;
    if (*(void *)v15)
    {
      while ((v16 & 4) == 0)
      {
        atomic_ullong v17 = v16;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)v15, (unint64_t *)&v17, v16 | 4, memory_order_relaxed, memory_order_relaxed);
        if (v17 == v16) {
          break;
        }
        atomic_ullong v16 = v17;
        if ((v17 & 1) == 0) {
          goto LABEL_24;
        }
      }
    }
    else
    {
LABEL_24:
      uint64_t v22 = -v15;
      *v18 |= 1uLL;
    }
  }
  *location = (id)v2;
  int v19 = *(_DWORD *)(StatusReg + 24);
  int v20 = v19;
  atomic_compare_exchange_strong_explicit(v5, (unsigned int *)&v20, 0, memory_order_release, memory_order_relaxed);
  if (v20 != v19) {
    os_unfair_lock_unlock((os_unfair_lock_t)v5);
  }
  callSetWeaklyReferenced(v2);
  return (id)v2;
}

void AutoreleasePoolPage::popPageDebug(const void ***this, objc_object **a2, AutoreleasePoolPage *a3, objc_object **a4)
{
  if (PrintPoolHiwat) {
    AutoreleasePoolPage::printHiwat((AutoreleasePoolPage *)this);
  }
  AutoreleasePoolPage::releaseUntil((objc_object ***)this, a2);
  if (DebugPoolAllocation && this[2] == (const void **)(this + 7))
  {
    uint64_t v7 = this[4];
    AutoreleasePoolPage::kill((AutoreleasePoolPage *)this);
    if (v7 && *(_DWORD *)v7 != -1583242847) {
      AutoreleasePoolPage::busted_die(v7);
    }
    *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 344) = v7;
  }
  else if (DebugMissingPools && this[2] == (const void **)(this + 7) && !this[4])
  {
    AutoreleasePoolPage::kill((AutoreleasePoolPage *)this);
    *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 344) = 0;
  }
  else
  {
    int v6 = (AutoreleasePoolPage *)this[5];
    if (v6)
    {
      if ((char *)this[2] - (char *)this - 56 <= 2015 || (int v6 = (AutoreleasePoolPage *)*((void *)v6 + 5)) != 0)
      {
        AutoreleasePoolPage::kill(v6);
      }
    }
  }
}

void objc_tls_direct_base<AutoreleasePoolPage *,(tls_key)3,AutoreleasePoolPage::HotPageDealloc>::dtor_(const void **this)
{
  unint64_t StatusReg = (void *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  size_t v3 = (void *)(StatusReg[44] & 0xFFFFFFFFFFFFFFFCLL);
  if (v3)
  {
    int v4 = StatusReg + 44;
    do
    {
      *int v4 = 0;
      StatusReg[45] = 0;

      size_t v3 = (void *)(*v4 & 0xFFFFFFFFFFFFFFFCLL);
    }
    while (v3);
  }
  if (this != (const void **)1)
  {
    if (this)
    {
      if (*(_DWORD *)this != -1583242847) {
        AutoreleasePoolPage::busted_die(this);
      }
      int v5 = StatusReg + 43;
      StatusReg[43] = this;
      while (1)
      {
        int v6 = (const void **)this[4];
        if (!v6) {
          break;
        }
        this = (const void **)this[4];
        if (*(_DWORD *)v6 != -1583242847) {
          AutoreleasePoolPage::busted_die(v6);
        }
      }
      if (this[2] != this + 7) {
      if (!(DebugMissingPools | DebugPoolAllocation))
      }
        AutoreleasePoolPage::kill((AutoreleasePoolPage *)this);
    }
    else
    {
      int v5 = StatusReg + 43;
    }
    *int v5 = 0;
  }
}

void AutoreleasePoolPage::kill(AutoreleasePoolPage *this)
{
  unint64_t v2 = this;
  do
  {
    size_t v3 = v2;
    unint64_t v2 = (AutoreleasePoolPage *)*((void *)v2 + 5);
  }
  while (v2);
  unint64_t StatusReg = (void *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  do
  {
    int v5 = (AutoreleasePoolPage *)*((void *)v3 + 4);
    if (v5) {
      *((void *)v5 + 5) = 0;
    }
    if (*(_DWORD *)v3 != -1583242847
      || strncmp((const char *)v3 + 4, "AUTORELEASE!", 0xCuLL)
      || *((void *)v3 + 3) != *StatusReg)
    {
      AutoreleasePoolPage::busted_die((const void **)v3);
    }
    *(void *)size_t v3 = 0;
    *((void *)v3 + 1) = 0;
    free(v3);
    BOOL v6 = v3 == this;
    size_t v3 = v5;
  }
  while (!v6);
}

void sub_1801331BC(_Unwind_Exception *a1)
{
  *int v1 = 0;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

uint64_t schedule_class_load(uint64_t result)
{
  if (result)
  {
    int v1 = (unint64_t *)result;
    unint64_t v2 = (void *)(result + 32);
    if ((*(unsigned char *)((*(void *)(result + 32) & 0xF00007FFFFFFFF8) + 2) & 0x80) == 0)
    {
      if (*(void *)(result + 8)) {
        size_t v3 = *(objc_class **)(result + 8);
      }
      else {
        size_t v3 = 0;
      }
      schedule_class_load(v3);
      id result = objc_class::getLoadMethod(*v1);
      if (result)
      {
        uint64_t v4 = result;
        if (PrintLoading)
        {
          uint64_t v7 = objc_class::nameForLogging((objc_class *)v1);
          _objc_inform("LOAD: class '%s' scheduled for +load", v7);
        }
        int v5 = loadable_classes_used;
        id result = loadable_classes;
        if (loadable_classes_used == loadable_classes_allocated)
        {
          loadable_classes_allocated = 2 * loadable_classes_used + 16;
          id result = (uint64_t)malloc_type_realloc((void *)loadable_classes, 16 * loadable_classes_allocated, 0x80040803F642BuLL);
          loadable_classes = result;
          int v5 = loadable_classes_used;
        }
        BOOL v6 = (unint64_t **)(result + 16 * v5);
        *BOOL v6 = v1;
        v6[1] = (unint64_t *)v4;
        loadable_classes_used = v5 + 1;
      }
      atomic_fetch_or_explicit((atomic_uint *volatile)(*v2 & 0xF00007FFFFFFFF8), 0x800000u, memory_order_relaxed);
    }
  }
  return result;
}

unint64_t objc_class::getLoadMethod(unint64_t this)
{
  uint64_t v4 = *(void *)(class_rw_t::ro((class_rw_t *)(*(void *)((this & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8)) + 32);
  if (v4) {
    BOOL v5 = (v4 & 1) == 0;
  }
  else {
    BOOL v5 = 0;
  }
  if (!v5)
  {
    if ((v4 & 1) == 0) {
      return 0;
    }
    BOOL v6 = (unsigned int *)(v4 & 0xFFFFFFFFFFFFFFFELL);
    if ((v4 & 0xFFFFFFFFFFFFFFFELL) == 0) {
      return 0;
    }
    uint64_t v7 = *v6;
    uint64_t v8 = v6[1];
    unint64_t v9 = v8 * (unint64_t)v7;
    if ((v9 & 0xFFFFFFFF00000000) != 0) {
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v1, v2, v3, v8, v4 & 0xFFFFFFFFFFFFFFFELL, v7);
    }
    uint64_t v10 = (unsigned __int16 *)(v6 + 2);
    unint64_t v11 = (unsigned __int16 *)((char *)v6 + v9 + 8);
    if (DisablePreattachedCategories)
    {
      if (!v8) {
        return 0;
      }
      uint64_t v10 = (unsigned __int16 *)((char *)v11 - v7);
    }
    for (; v10 < v11; uint64_t v10 = (unsigned __int16 *)((char *)v10 + v7))
    {
      if (*(void *)(objc_debug_headerInfoRWs + 8 * *v10 + 8)) {
        break;
      }
    }
    if (v11 == v10) {
      return 0;
    }
    uint64_t v12 = -v7;
    do
      unint64_t v11 = (unsigned __int16 *)((char *)v11 + v12);
    while ((*(void *)(objc_debug_headerInfoRWs + 8 * (unsigned __int16)*(void *)v11 + 8) & 1) == 0);
    unint64_t v13 = (unint64_t)v11 + (*(uint64_t *)v11 >> 16);
    if (!v13) {
      return 0;
    }
    unint64_t v14 = *(unsigned int *)v13;
    if ((int)v14 > -1 || (v13 & 0x8000000000000000) != 0) {
      uint64_t v16 = 24;
    }
    else {
      uint64_t v16 = 12;
    }
    uint64_t v17 = (unsigned __int16)v14 & 0xFFFC;
    if ((~v14 & 3) != 0 || v17 != v16)
    {
      if ((v13 & 0x8000000000000000) == 0)
      {
        if ((v14 & 0x80000000) != 0)
        {
          if (dataSegmentsRanges > v13 || *(void *)algn_1EB1CB078 <= v13)
          {
            uint64_t v120 = *(unsigned int *)(v13 + 4);
            unint64_t v155 = v120 * (unint64_t)((unsigned __int16)v14 & 0xFFFC);
            if ((v155 & 0xFFFFFFFF00000000) == 0)
            {
              unint64_t v156 = v13 + 8;
              unint64_t v157 = v156 & 0xFFFFFFFFFFFFFFFCLL | 1;
              unint64_t v158 = (v156 + v155) & 0xFFFFFFFFFFFFFFFCLL | 1;
              if (v157 == v158) {
                return 0;
              }
              uint64_t v159 = 0;
              while (1)
              {
                unint64_t v22 = v157 + v159;
                if (*(char **)(((v157 + v159) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v157 + v159) & 0xFFFFFFFFFFFFFFFCLL)) == sel_load) {
                  break;
                }
                v159 += v17;
                if (v157 + v159 == v158) {
                  return 0;
                }
              }
              goto LABEL_225;
            }
          }
          else
          {
            if (dataSegmentsRanges > (unint64_t)sel_load
              || *(void *)algn_1EB1CB078 <= (unint64_t)sel_load)
            {
              return 0;
            }
            uint64_t v120 = *(unsigned int *)(v13 + 4);
            unint64_t v150 = v120 * (unint64_t)((unsigned __int16)v14 & 0xFFFC);
            if ((v150 & 0xFFFFFFFF00000000) == 0)
            {
              unint64_t v151 = v13 + 8;
              unint64_t v152 = v151 & 0xFFFFFFFFFFFFFFFCLL | 1;
              unint64_t v153 = (v151 + v150) & 0xFFFFFFFFFFFFFFFCLL | 1;
              if (v152 == v153) {
                return 0;
              }
              uint64_t v154 = 0;
              while (1)
              {
                unint64_t v22 = v152 + v154;
                if (sel_load == (char *)&unk_1F62995A8 + *(int *)((v152 + v154) & 0xFFFFFFFFFFFFFFFCLL)) {
                  break;
                }
                v154 += v17;
                if (v152 + v154 == v153) {
                  return 0;
                }
              }
              goto LABEL_225;
            }
          }
        }
        else
        {
          uint64_t v120 = *(unsigned int *)(v13 + 4);
          unint64_t v131 = v120 * (unint64_t)((unsigned __int16)v14 & 0xFFFC);
          if ((v131 & 0xFFFFFFFF00000000) == 0)
          {
            unint64_t v132 = v13 + 8;
            unint64_t v133 = v132 & 0xFFFFFFFFFFFFFFFCLL;
            unint64_t v134 = (v132 + v131) & 0xFFFFFFFFFFFFFFFCLL;
            if (v133 == v134) {
              return 0;
            }
            uint64_t v135 = 0;
            while (1)
            {
              unint64_t v22 = v133 + v135;
              if (*(char **)((v133 + v135) & 0xFFFFFFFFFFFFFFFCLL) == sel_load) {
                break;
              }
              v135 += v17;
              if (v133 + v135 == v134) {
                return 0;
              }
            }
            goto LABEL_225;
          }
        }
LABEL_295:
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v1, v2, v3, v120, v13, v17);
      }
      uint64_t v120 = *(unsigned int *)(v13 + 4);
      unint64_t v142 = v120 * (unint64_t)((unsigned __int16)v14 & 0xFFFC);
      if ((v142 & 0xFFFFFFFF00000000) != 0) {
        goto LABEL_295;
      }
      unint64_t v143 = v13 + 8;
      unint64_t v128 = v143 & 0xFFFFFFFFFFFFFFFCLL | 2;
      unint64_t v144 = (v143 + v142) & 0xFFFFFFFFFFFFFFFCLL | 2;
      if (v128 == v144) {
        return 0;
      }
      uint64_t v130 = 0;
      while (*(char **)((v128 + v130) & 0xFFFFFFFFFFFFFFFCLL) != sel_load)
      {
        v130 += v17;
        if (v128 + v130 == v144) {
          return 0;
        }
      }
LABEL_269:
      unint64_t v22 = v128 + v130;
      goto LABEL_225;
    }
    if ((v13 & 0x8000000000000000) == 0)
    {
      if ((v14 & 0x80000000) == 0)
      {
        unint64_t v19 = (v13 + 8) & 0xFFFFFFFFFFFFFFFCLL;
        unsigned int v20 = *(_DWORD *)(v13 + 4);
        if (v20 < 5)
        {
          unint64_t v21 = (v13 + 8) & 0xFFFFFFFFFFFFFFFCLL;
LABEL_148:
          if (!v20) {
            return 0;
          }
          uint64_t v90 = 0;
          unsigned int v91 = v20 - 1;
          while (1)
          {
            unint64_t v22 = v21 + v90;
            unint64_t v92 = *(char **)((v21 + v90) & 0xFFFFFFFFFFFFFFFCLL);
            if (sel_load == v92) {
              break;
            }
            BOOL v93 = sel_load < v92 || v91-- == 0;
            v90 += v16;
            if (v93) {
              return 0;
            }
          }
        }
        else
        {
          unint64_t v21 = (v13 + 8) & 0xFFFFFFFFFFFFFFFCLL;
          while (1)
          {
            unint64_t v22 = v21 + 24 * (v20 >> 1);
            int v23 = *(char **)(v22 & 0xFFFFFFFFFFFFFFFCLL);
            BOOL v24 = sel_load > v23;
            if (sel_load == v23) {
              break;
            }
            BOOL v25 = sel_load > v23;
            if (v24) {
              unint64_t v21 = v22 + 24;
            }
            unsigned int v26 = v20 - v25;
            unsigned int v20 = v26 >> 1;
            if (v26 <= 9) {
              goto LABEL_148;
            }
          }
          if (v22 > v19)
          {
            uint64_t v107 = v21 + 24 * (v20 >> 1) - 24;
            while (sel_load == *(char **)(v107 & 0xFFFFFFFFFFFFFFFCLL))
            {
              v22 -= 24;
              v107 -= 24;
              if (v22 <= v19) {
                goto LABEL_226;
              }
            }
          }
        }
        goto LABEL_225;
      }
      if (dataSegmentsRanges > v13 || *(void *)algn_1EB1CB078 <= v13)
      {
        unint64_t v100 = (v13 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
        unsigned int v101 = *(_DWORD *)(v13 + 4);
        if (v101 < 5)
        {
          unint64_t v102 = (v13 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
LABEL_195:
          if (!v101) {
            return 0;
          }
          uint64_t v109 = 0;
          unsigned int v110 = v101 - 1;
          while (1)
          {
            unint64_t v22 = v102 + v109;
            unint64_t v111 = *(char **)(((v102 + v109) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v102 + v109) & 0xFFFFFFFFFFFFFFFCLL));
            if (sel_load == v111) {
              break;
            }
            BOOL v112 = sel_load < v111 || v110-- == 0;
            v109 += v16;
            if (v112) {
              return 0;
            }
          }
          goto LABEL_225;
        }
        unint64_t v102 = (v13 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
        while (1)
        {
          unint64_t v22 = v102 + v16 * (unint64_t)(v101 >> 1);
          BOOL v103 = *(char **)((v22 & 0xFFFFFFFFFFFFFFFCLL) + *(int *)(v22 & 0xFFFFFFFFFFFFFFFCLL));
          BOOL v104 = sel_load > v103;
          if (sel_load == v103) {
            break;
          }
          BOOL v105 = sel_load > v103;
          if (v104) {
            unint64_t v102 = v22 + v16;
          }
          unsigned int v106 = v101 - v105;
          unsigned int v101 = v106 >> 1;
          if (v106 <= 9) {
            goto LABEL_195;
          }
        }
        if (v22 <= v100) {
          goto LABEL_225;
        }
        uint64_t v59 = 0;
        unint64_t v113 = v102 + (int)v16 * (uint64_t)(int)((v101 >> 1) - 1);
        while (sel_load == *(char **)(((v113 + v59) & 0xFFFFFFFFFFFFFFFCLL)
                                     + *(int *)((v113 + v59) & 0xFFFFFFFFFFFFFFFCLL)))
        {
          v59 -= v16;
          unint64_t v61 = v22 + v59;
          if (v22 + v59 <= v100) {
            goto LABEL_96;
          }
        }
      }
      else
      {
        if (dataSegmentsRanges > (unint64_t)sel_load || *(void *)algn_1EB1CB078 <= (unint64_t)sel_load) {
          return 0;
        }
        unint64_t v82 = sel_load - (char *)&unk_1F62995A8;
        unint64_t v83 = (v13 + 8) & 0xFFFFFFFFFFFFFFFCLL | (v14 >> 31);
        unsigned int v84 = *(_DWORD *)(v13 + 4);
        if (v84 < 5)
        {
          unint64_t v85 = v83;
LABEL_210:
          if (!v84) {
            return 0;
          }
          uint64_t v114 = 0;
          unsigned int v115 = v84 - 1;
          while (1)
          {
            unint64_t v22 = v85 + v114;
            unint64_t v116 = *(int *)((v85 + v114) & 0xFFFFFFFFFFFFFFFCLL);
            if (v82 == v116) {
              break;
            }
            BOOL v117 = v82 < v116 || v115-- == 0;
            v114 += v16;
            if (v117) {
              return 0;
            }
          }
          goto LABEL_225;
        }
        unint64_t v85 = v83;
        while (1)
        {
          unint64_t v22 = v85 + v16 * (unint64_t)(v84 >> 1);
          unint64_t v86 = *(int *)(v22 & 0xFFFFFFFFFFFFFFFCLL);
          BOOL v87 = v82 > v86;
          if (v82 == v86) {
            break;
          }
          BOOL v88 = v82 > v86;
          if (v87) {
            unint64_t v85 = v22 + v16;
          }
          unsigned int v89 = v84 - v88;
          unsigned int v84 = v89 >> 1;
          if (v89 <= 9) {
            goto LABEL_210;
          }
        }
        if (v22 <= v83) {
          goto LABEL_225;
        }
        uint64_t v59 = 0;
        unint64_t v118 = v85 + (int)v16 * (uint64_t)(int)((v84 >> 1) - 1);
        while (v82 == *(_DWORD *)((v118 + v59) & 0xFFFFFFFFFFFFFFFCLL))
        {
          v59 -= v16;
          unint64_t v61 = v22 + v59;
          if (v22 + v59 <= v83) {
            goto LABEL_96;
          }
        }
      }
LABEL_224:
      v22 += v59;
      goto LABEL_225;
    }
    unint64_t v62 = (v13 + 8) & 0xFFFFFFFFFFFFFFFCLL | 2;
    unsigned int v63 = *(_DWORD *)(v13 + 4);
    if (v63 >= 5)
    {
      unint64_t v40 = (v13 + 8) & 0xFFFFFFFFFFFFFFFCLL | 2;
      while (1)
      {
        unint64_t v22 = v40 + v16 * (unint64_t)(v63 >> 1);
        unint64_t v64 = *(char **)(v22 & 0xFFFFFFFFFFFFFFFCLL);
        if (sel_load == v64) {
          break;
        }
        if (sel_load > v64) {
          unint64_t v40 = v22 + v16;
        }
        unsigned int v65 = v63 - (sel_load > v64);
        unsigned int v63 = v65 >> 1;
        if (v65 <= 9) {
          goto LABEL_119;
        }
      }
      if (v22 <= v62) {
        goto LABEL_225;
      }
      uint64_t v59 = 0;
      unint64_t v94 = v40 + (int)v16 * (uint64_t)(int)((v63 >> 1) - 1);
      while (sel_load == *(char **)((v94 + v59) & 0xFFFFFFFFFFFFFFFCLL))
      {
        v59 -= v16;
        unint64_t v61 = v22 + v59;
        if (v22 + v59 <= v62) {
          goto LABEL_96;
        }
      }
      goto LABEL_224;
    }
    unint64_t v40 = (v13 + 8) & 0xFFFFFFFFFFFFFFFCLL | 2;
LABEL_119:
    if (!v63) {
      return 0;
    }
    uint64_t v43 = 0;
    unsigned int v75 = v63 - 1;
    while (1)
    {
      unsigned int v76 = v75;
      unint64_t v77 = *(char **)((v40 + v43) & 0xFFFFFFFFFFFFFFFCLL);
      if (sel_load == v77) {
        break;
      }
      if (sel_load >= v77)
      {
        --v75;
        v43 += v16;
        if (v76) {
          continue;
        }
      }
      return 0;
    }
LABEL_125:
    unint64_t v22 = v40 + v43;
    goto LABEL_225;
  }
  unint64_t v13 = v4 & 0xFFFFFFFFFFFFFFFELL;
  if ((v4 & 0xFFFFFFFFFFFFFFFELL) == 0) {
    return 0;
  }
  unint64_t v27 = *(unsigned int *)v13;
  if ((int)v27 > -1 || v4 < 0) {
    uint64_t v29 = 24;
  }
  else {
    uint64_t v29 = 12;
  }
  uint64_t v17 = (unsigned __int16)v27 & 0xFFFC;
  if ((~v27 & 3) == 0 && v17 == v29)
  {
    if ((v4 & 0x8000000000000000) == 0)
    {
      if ((v27 & 0x80000000) == 0)
      {
        unint64_t v31 = (v13 + 8) & 0xFFFFFFFFFFFFFFFCLL;
        unsigned int v32 = *(_DWORD *)(v13 + 4);
        if (v32 < 5)
        {
          unint64_t v33 = (v13 + 8) & 0xFFFFFFFFFFFFFFFCLL;
LABEL_83:
          if (!v32) {
            return 0;
          }
          uint64_t v55 = 0;
          unsigned int v56 = v32 - 1;
          while (1)
          {
            unint64_t v22 = v33 + v55;
            unint64_t v57 = *(char **)((v33 + v55) & 0xFFFFFFFFFFFFFFFCLL);
            if (sel_load == v57) {
              break;
            }
            BOOL v58 = sel_load < v57 || v56-- == 0;
            v55 += v29;
            if (v58) {
              return 0;
            }
          }
        }
        else
        {
          unint64_t v33 = (v13 + 8) & 0xFFFFFFFFFFFFFFFCLL;
          while (1)
          {
            unint64_t v22 = v33 + 24 * (v32 >> 1);
            unint64_t v34 = *(char **)(v22 & 0xFFFFFFFFFFFFFFFCLL);
            BOOL v35 = sel_load > v34;
            if (sel_load == v34) {
              break;
            }
            BOOL v36 = sel_load > v34;
            if (v35) {
              unint64_t v33 = v22 + 24;
            }
            unsigned int v37 = v32 - v36;
            unsigned int v32 = v37 >> 1;
            if (v37 <= 9) {
              goto LABEL_83;
            }
          }
          if (v22 > v31)
          {
            uint64_t v74 = v33 + 24 * (v32 >> 1) - 24;
            while (sel_load == *(char **)(v74 & 0xFFFFFFFFFFFFFFFCLL))
            {
              v22 -= 24;
              v74 -= 24;
              if (v22 <= v31) {
                goto LABEL_226;
              }
            }
          }
        }
        goto LABEL_225;
      }
      if (dataSegmentsRanges <= v13 && *(void *)algn_1EB1CB078 > v13)
      {
        if (dataSegmentsRanges > (unint64_t)sel_load || *(void *)algn_1EB1CB078 <= (unint64_t)sel_load) {
          return 0;
        }
        unint64_t v66 = sel_load - (char *)&unk_1F62995A8;
        unint64_t v67 = (v13 + 8) & 0xFFFFFFFFFFFFFFFCLL | (v27 >> 31);
        unsigned int v68 = *(_DWORD *)(v13 + 4);
        if (v68 < 5)
        {
          unint64_t v69 = v67;
LABEL_168:
          if (!v68) {
            return 0;
          }
          uint64_t v96 = 0;
          unsigned int v97 = v68 - 1;
          while (1)
          {
            unint64_t v22 = v69 + v96;
            unint64_t v98 = *(int *)((v69 + v96) & 0xFFFFFFFFFFFFFFFCLL);
            if (v66 == v98) {
              break;
            }
            BOOL v99 = v66 < v98 || v97-- == 0;
            v96 += v29;
            if (v99) {
              return 0;
            }
          }
          goto LABEL_225;
        }
        unint64_t v69 = v67;
        while (1)
        {
          unint64_t v22 = v69 + v29 * (unint64_t)(v68 >> 1);
          unint64_t v70 = *(int *)(v22 & 0xFFFFFFFFFFFFFFFCLL);
          BOOL v71 = v66 > v70;
          if (v66 == v70) {
            break;
          }
          BOOL v72 = v66 > v70;
          if (v71) {
            unint64_t v69 = v22 + v29;
          }
          unsigned int v73 = v68 - v72;
          unsigned int v68 = v73 >> 1;
          if (v73 <= 9) {
            goto LABEL_168;
          }
        }
        if (v22 <= v67) {
          goto LABEL_225;
        }
        uint64_t v59 = 0;
        unint64_t v108 = v69 + (int)v29 * (uint64_t)(int)((v68 >> 1) - 1);
        while (v66 == *(_DWORD *)((v108 + v59) & 0xFFFFFFFFFFFFFFFCLL))
        {
          v59 -= v29;
          unint64_t v61 = v22 + v59;
          if (v22 + v59 <= v67) {
            goto LABEL_96;
          }
        }
      }
      else
      {
        unint64_t v48 = (v13 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
        unsigned int v49 = *(_DWORD *)(v13 + 4);
        if (v49 < 5)
        {
          unint64_t v50 = (v13 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
LABEL_127:
          if (!v49) {
            return 0;
          }
          uint64_t v78 = 0;
          unsigned int v79 = v49 - 1;
          while (1)
          {
            unint64_t v22 = v50 + v78;
            uint64_t v80 = *(char **)(((v50 + v78) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v50 + v78) & 0xFFFFFFFFFFFFFFFCLL));
            if (sel_load == v80) {
              break;
            }
            BOOL v81 = sel_load < v80 || v79-- == 0;
            v78 += v29;
            if (v81) {
              return 0;
            }
          }
          goto LABEL_225;
        }
        unint64_t v50 = (v13 + 8) & 0xFFFFFFFFFFFFFFFCLL | 1;
        while (1)
        {
          unint64_t v22 = v50 + v29 * (unint64_t)(v49 >> 1);
          char v51 = *(char **)((v22 & 0xFFFFFFFFFFFFFFFCLL) + *(int *)(v22 & 0xFFFFFFFFFFFFFFFCLL));
          BOOL v52 = sel_load > v51;
          if (sel_load == v51) {
            break;
          }
          BOOL v53 = sel_load > v51;
          if (v52) {
            unint64_t v50 = v22 + v29;
          }
          unsigned int v54 = v49 - v53;
          unsigned int v49 = v54 >> 1;
          if (v54 <= 9) {
            goto LABEL_127;
          }
        }
        if (v22 <= v48) {
          goto LABEL_225;
        }
        uint64_t v59 = 0;
        unint64_t v95 = v50 + (int)v29 * (uint64_t)(int)((v49 >> 1) - 1);
        while (sel_load == *(char **)(((v95 + v59) & 0xFFFFFFFFFFFFFFFCLL)
                                     + *(int *)((v95 + v59) & 0xFFFFFFFFFFFFFFFCLL)))
        {
          v59 -= v29;
          unint64_t v61 = v22 + v59;
          if (v22 + v59 <= v48) {
            goto LABEL_96;
          }
        }
      }
      goto LABEL_224;
    }
    unint64_t v38 = (v13 + 8) | 2;
    unsigned int v39 = *(_DWORD *)(v13 + 4);
    if (v39 >= 5)
    {
      unint64_t v40 = (v13 + 8) | 2;
      while (1)
      {
        unint64_t v22 = v40 + v29 * (unint64_t)(v39 >> 1);
        size_t v41 = *(char **)(v22 & 0xFFFFFFFFFFFFFFFCLL);
        if (sel_load == v41) {
          break;
        }
        if (sel_load > v41) {
          unint64_t v40 = v22 + v29;
        }
        unsigned int v42 = v39 - (sel_load > v41);
        unsigned int v39 = v42 >> 1;
        if (v42 <= 9)
        {
          if (v39) {
            goto LABEL_66;
          }
          return 0;
        }
      }
      if (v22 <= v38) {
        goto LABEL_225;
      }
      uint64_t v59 = 0;
      unint64_t v60 = v40 + (int)v29 * (uint64_t)(int)((v39 >> 1) - 1);
      while (sel_load == *(char **)((v60 + v59) & 0xFFFFFFFFFFFFFFFCLL))
      {
        v59 -= v29;
        unint64_t v61 = v22 + v59;
        if (v22 + v59 <= v38)
        {
LABEL_96:
          unint64_t v22 = v61;
          goto LABEL_226;
        }
      }
      goto LABEL_224;
    }
    unint64_t v40 = (v13 + 8) | 2;
    if (v39)
    {
LABEL_66:
      uint64_t v43 = 0;
      unsigned int v44 = v39 - 1;
      while (1)
      {
        unsigned int v45 = v44;
        uint64_t v46 = *(char **)((v40 + v43) & 0xFFFFFFFFFFFFFFFCLL);
        if (sel_load == v46) {
          break;
        }
        if (sel_load >= v46)
        {
          --v44;
          v43 += v29;
          if (v45) {
            continue;
          }
        }
        return 0;
      }
      goto LABEL_125;
    }
    return 0;
  }
  if (v4 < 0)
  {
    uint64_t v120 = *(unsigned int *)(v13 + 4);
    unint64_t v126 = v120 * (unint64_t)((unsigned __int16)v27 & 0xFFFC);
    if ((v126 & 0xFFFFFFFF00000000) != 0) {
      goto LABEL_295;
    }
    unint64_t v127 = v13 + 8;
    unint64_t v128 = v127 | 2;
    unint64_t v129 = (v127 + v126) & 0xFFFFFFFFFFFFFFFCLL | 2;
    if (v128 == v129) {
      return 0;
    }
    uint64_t v130 = 0;
    while (*(char **)((v128 + v130) & 0xFFFFFFFFFFFFFFFCLL) != sel_load)
    {
      v130 += v17;
      if (v128 + v130 == v129) {
        return 0;
      }
    }
    goto LABEL_269;
  }
  if ((v27 & 0x80000000) != 0)
  {
    if (dataSegmentsRanges <= v13 && *(void *)algn_1EB1CB078 > v13)
    {
      if (dataSegmentsRanges > (unint64_t)sel_load || *(void *)algn_1EB1CB078 <= (unint64_t)sel_load) {
        return 0;
      }
      uint64_t v120 = *(unsigned int *)(v13 + 4);
      unint64_t v145 = v120 * (unint64_t)((unsigned __int16)v27 & 0xFFFC);
      if ((v145 & 0xFFFFFFFF00000000) == 0)
      {
        unint64_t v146 = v13 + 8;
        unint64_t v147 = v146 & 0xFFFFFFFFFFFFFFFCLL | 1;
        unint64_t v148 = (v146 + v145) & 0xFFFFFFFFFFFFFFFCLL | 1;
        if (v147 == v148) {
          return 0;
        }
        uint64_t v149 = 0;
        while (1)
        {
          unint64_t v22 = v147 + v149;
          if (sel_load == (char *)&unk_1F62995A8 + *(int *)((v147 + v149) & 0xFFFFFFFFFFFFFFFCLL)) {
            break;
          }
          v149 += v17;
          if (v147 + v149 == v148) {
            return 0;
          }
        }
        goto LABEL_225;
      }
    }
    else
    {
      uint64_t v120 = *(unsigned int *)(v13 + 4);
      unint64_t v137 = v120 * (unint64_t)((unsigned __int16)v27 & 0xFFFC);
      if ((v137 & 0xFFFFFFFF00000000) == 0)
      {
        unint64_t v138 = v13 + 8;
        unint64_t v139 = v138 & 0xFFFFFFFFFFFFFFFCLL | 1;
        unint64_t v140 = (v138 + v137) & 0xFFFFFFFFFFFFFFFCLL | 1;
        if (v139 == v140) {
          return 0;
        }
        uint64_t v141 = 0;
        while (1)
        {
          unint64_t v22 = v139 + v141;
          if (*(char **)(((v139 + v141) & 0xFFFFFFFFFFFFFFFCLL) + *(int *)((v139 + v141) & 0xFFFFFFFFFFFFFFFCLL)) == sel_load) {
            break;
          }
          v141 += v17;
          if (v139 + v141 == v140) {
            return 0;
          }
        }
        goto LABEL_225;
      }
    }
    goto LABEL_295;
  }
  uint64_t v120 = *(unsigned int *)(v13 + 4);
  unint64_t v121 = v120 * (unint64_t)((unsigned __int16)v27 & 0xFFFC);
  if ((v121 & 0xFFFFFFFF00000000) != 0) {
    goto LABEL_295;
  }
  unint64_t v122 = v13 + 8;
  unint64_t v123 = v122 & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v124 = (v122 + v121) & 0xFFFFFFFFFFFFFFFCLL;
  if (v123 == v124) {
    return 0;
  }
  uint64_t v125 = 0;
  while (1)
  {
    unint64_t v22 = v123 + v125;
    if (*(char **)((v123 + v125) & 0xFFFFFFFFFFFFFFFCLL) == sel_load) {
      break;
    }
    v125 += v17;
    if (v123 + v125 == v124) {
      return 0;
    }
  }
LABEL_225:
  if (!v22) {
    return 0;
  }
LABEL_226:

  return method_t::imp(v22, 0);
}

Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)
{
  if (look_up_class((char *)name)) {
    return 0;
  }
  int v6 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v6, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v6) {
    os_unfair_lock_lock_with_options();
  }
  if (getClassExceptSomeSwift(name) || !verifySuperclass(superclass, 1))
  {
    BOOL v5 = 0;
  }
  else
  {
    BOOL v5 = alloc_class_for_subclass(superclass);
    uint64_t v8 = alloc_class_for_subclass(superclass);
    objc_initializeClassPair_internal(superclass, name, (objc_class *)v5, (unint64_t)v8);
  }
  int v9 = *(_DWORD *)(StatusReg + 24);
  int v10 = v9;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v10, 0, memory_order_release, memory_order_relaxed);
  if (v10 != v9) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return (Class)v5;
}

void sub_18013420C(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

char *alloc_class_for_subclass(objc_class *a1)
{
  if (a1 && (*((unsigned char *)a1 + 32) & 3) != 0)
  {
    size_t v2 = *((unsigned int *)a1 + 14);
    size_t v3 = (char *)a1 - *((unsigned int *)a1 + 15);
    int v4 = (char *)malloc_type_zone_malloc_with_options_internal();
    memcpy(v4, v3, v2);
    int v5 = &v4[*((unsigned int *)a1 + 15)];
    *((void *)v5 + 4) = 0;
    *(_OWORD *)int v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    *((void *)v5 + 8) = 0;
    if (classCopyFixupHandlers >= 2uLL) {
      int v6 = (uint64_t *)qword_1EB1CADC0;
    }
    else {
      int v6 = &qword_1EB1CADC0;
    }
    if (classCopyFixupHandlers)
    {
      uint64_t v7 = 8 * classCopyFixupHandlers;
      do
      {
        uint64_t v8 = (void (*)(objc_class *, char *))*v6++;
        v8(a1, v5);
        v7 -= 8;
      }
      while (v7);
    }
    return v5;
  }
  else
  {
    return (char *)malloc_type_zone_malloc_with_options_internal();
  }
}

uint64_t objc_initializeClassPair_internal(objc_class *a1, const char *a2, objc_class *a3, unint64_t a4)
{
  uint64_t v7 = malloc_type_calloc(0x20uLL, 1uLL, 0x1ECB51D3uLL);
  uint64_t v8 = malloc_type_calloc(0x20uLL, 1uLL, 0x1ECB51D3uLL);
  int v9 = malloc_type_calloc(0x48uLL, 1uLL, 0xD8E12CD6uLL);
  int v10 = malloc_type_calloc(0x48uLL, 1uLL, 0xF9518B77uLL);
  *(_DWORD *)uint64_t v7 = -1945632768;
  *(_DWORD *)uint64_t v8 = -1945632767;
  *(_DWORD *)int v9 = 0;
  *(_DWORD *)int v10 = 1;
  unint64_t v11 = (atomic_ullong *)((char *)a3 + 32);
  class_data_bits_t::setData((unint64_t *)a3 + 4, (unint64_t)v7);
  if (v7[1]) {
    *(void *)(v7[1] & 0xFFFFFFFFFFFFFFFELL) = v9;
  }
  else {
    v7[1] = v9;
  }
  uint64_t v12 = (atomic_ullong *)(a4 + 32);
  class_data_bits_t::setData((unint64_t *)(a4 + 32), (unint64_t)v8);
  unint64_t v13 = v8 + 1;
  uint64_t v14 = v8[1];
  if (v14) {
    unint64_t v13 = (void *)(v14 & 0xFFFFFFFFFFFFFFFELL);
  }
  *unint64_t v13 = v10;
  if (a1)
  {
    uint64_t v15 = *((void *)a1 + 4);
    *(_DWORD *)v7 |= *(_DWORD *)(v15 & 0xF00007FFFFFFFF8) & 0x100000;
    *((_DWORD *)v9 + 1) = *(_DWORD *)(class_rw_t::ro((class_rw_t *)(v15 & 0xF00007FFFFFFFF8)) + 8);
    *((_DWORD *)v10 + 1) = *(_DWORD *)(class_rw_t::ro((class_rw_t *)(*(void *)((*(void *)a1 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8))
                                     + 8);
    objc_class::setInstanceSize(a3, *((_DWORD *)v9 + 1));
    objc_class::setInstanceSize((objc_class *)a4, *((_DWORD *)v10 + 1));
    uint64_t v16 = *((void *)a1 + 4);
    if ((v16 & 2) != 0)
    {
      atomic_ullong v17 = *v11;
      if (!*v11) {
        goto LABEL_10;
      }
LABEL_9:
      for (unint64_t i = v17; ; unint64_t i = 0x8000000000000000)
      {
        unint64_t v19 = i & 0xFFFFFFFFFFFFFFFCLL | 2;
        atomic_ullong v20 = v17;
        atomic_compare_exchange_strong_explicit(v11, (unint64_t *)&v20, v19, memory_order_release, memory_order_relaxed);
        if (v20 == v17) {
          break;
        }
        atomic_ullong v17 = v20;
        if (v20) {
          goto LABEL_9;
        }
LABEL_10:
        ;
      }
      atomic_ullong v23 = *v12;
      if (!*v12) {
        goto LABEL_17;
      }
LABEL_16:
      for (unint64_t j = v23; ; unint64_t j = 0x8000000000000000)
      {
        unint64_t v25 = j & 0xFFFFFFFFFFFFFFFCLL | 2;
        atomic_ullong v26 = v23;
        atomic_compare_exchange_strong_explicit(v12, (unint64_t *)&v26, v25, memory_order_release, memory_order_relaxed);
        if (v26 == v23) {
          break;
        }
        atomic_ullong v23 = v26;
        if (v26) {
          goto LABEL_16;
        }
LABEL_17:
        ;
      }
      uint64_t v16 = *((void *)a1 + 4);
    }
    unint64_t v22 = a2;
    if (v16)
    {
      atomic_ullong v36 = *v11;
      if (!*v11) {
        goto LABEL_39;
      }
LABEL_38:
      for (unint64_t k = v36; ; unint64_t k = 0x8000000000000000)
      {
        unint64_t v38 = k & 0xFFFFFFFFFFFFFFFCLL | 1;
        atomic_ullong v39 = v36;
        atomic_compare_exchange_strong_explicit(v11, (unint64_t *)&v39, v38, memory_order_release, memory_order_relaxed);
        if (v39 == v36) {
          break;
        }
        atomic_ullong v36 = v39;
        if (v39) {
          goto LABEL_38;
        }
LABEL_39:
        ;
      }
      atomic_ullong v40 = *v12;
      if (!*v12) {
        goto LABEL_45;
      }
LABEL_44:
      for (unint64_t m = v40; ; unint64_t m = 0x8000000000000000)
      {
        unint64_t v42 = m & 0xFFFFFFFFFFFFFFFCLL | 1;
        atomic_ullong v43 = v40;
        atomic_compare_exchange_strong_explicit(v12, (unint64_t *)&v43, v42, memory_order_release, memory_order_relaxed);
        if (v43 == v40) {
          break;
        }
        atomic_ullong v40 = v43;
        if (v43) {
          goto LABEL_44;
        }
LABEL_45:
        ;
      }
    }
  }
  else
  {
    *(_DWORD *)v9 |= 2u;
    int v21 = *(_DWORD *)v10 | 2;
    *((_DWORD *)v9 + 1) = 0;
    *(_DWORD *)int v10 = v21;
    *((_DWORD *)v10 + 1) = 40;
    objc_class::setInstanceSize(a3, 8u);
    objc_class::setInstanceSize((objc_class *)a4, *((_DWORD *)v10 + 1));
    unint64_t v22 = a2;
  }
  size_t v27 = strlen(v22) + 1;
  if ((_dyld_is_memory_immutable() & 1) == 0)
  {
    unint64_t v31 = malloc_type_malloc(v27, 0x3F84A03uLL);
    memcpy(v31, v22, v27);
    unint64_t v22 = (const char *)v31;
  }
  atomic_store((unint64_t)v22, (unint64_t *)v9 + 3);
  atomic_store((unint64_t)v22, (unint64_t *)v10 + 3);
  *((void *)v9 + 2) = &UnsetLayout;
  *((void *)v9 + 7) = &UnsetLayout;
  *((void *)a3 + 2) = &_objc_empty_cache;
  *((void *)a3 + 3) = 0;
  *(void *)(a4 + 16) = &_objc_empty_cache;
  *(void *)(a4 + 24) = 0;
  atomic_fetch_or_explicit((atomic_ushort *volatile)(a4 + 30), 4u, memory_order_relaxed);
  atomic_fetch_or_explicit((atomic_ushort *volatile)(a4 + 30), 0x2000u, memory_order_relaxed);
  int v32 = DisableNonpointerIsa;
  if (DisableNonpointerIsa || (*(_WORD *)(a4 + 30) & 0x2000) != 0)
  {
    if ((a4 & 0xFF80000000000007) != 0) {
      goto LABEL_59;
    }
    *(void *)a3 = a4 & 0x7FFFFFFFFFFFF8;
    if (a1)
    {
      uint64_t v33 = *(void *)(*(void *)a1 & 0xFFFFFFFF8) & 0xFFFFFFFF8;
      if (v32) {
        goto LABEL_35;
      }
      goto LABEL_33;
    }
    if (v32) {
      goto LABEL_53;
    }
  }
  else
  {
    if ((a4 & 0xFF80000000000007) != 0) {
      goto LABEL_59;
    }
    *(void *)a3 = a4 & 0x7FFFFFFFFFFFF8 | 0x100000000000001;
    if (a1)
    {
      uint64_t v33 = *(void *)(*(void *)a1 & 0xFFFFFFFF8) & 0xFFFFFFFF8;
LABEL_33:
      if ((*(_WORD *)(v33 + 30) & 0x2000) == 0)
      {
        uint64_t v34 = v33 & 0x7FFFFFFFFFFFF8 | 0x100000000000001;
LABEL_36:
        *(void *)a4 = v34;
        *((void *)a3 + 1) = a1;
        *(void *)(a4 + 8) = *(void *)a1 & 0xFFFFFFFF8;
        addSubclass((uint64_t)a1, a3);
        BOOL v35 = (objc_class *)(*(void *)a1 & 0xFFFFFFFF8);
        goto LABEL_56;
      }
LABEL_35:
      uint64_t v34 = v33 & 0xFFFFFFFF8;
      goto LABEL_36;
    }
  }
  if ((*(_WORD *)(a4 + 30) & 0x2000) != 0)
  {
LABEL_53:
    if ((a4 & 0xFF80000000000007) == 0)
    {
      unint64_t v44 = a4 & 0x7FFFFFFFFFFFF8;
      goto LABEL_55;
    }
LABEL_59:
    _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", v28, v29, v30, a4);
  }
  if ((a4 & 0xFF80000000000007) != 0) {
    goto LABEL_59;
  }
  unint64_t v44 = a4 & 0x7FFFFFFFFFFFF8 | 0x100000000000001;
LABEL_55:
  *(void *)a4 = v44;
  *((void *)a3 + 1) = 0;
  *(void *)(a4 + 8) = a3;
  ++objc_debug_realized_class_generation_count;
  *(void *)((*((void *)a3 + 4) & 0xF00007FFFFFFFF8) + 0x18) = _firstRealizedClass;
  _firstRealizeduint64_t Class = (uint64_t)a3;
  BOOL v35 = a3;
LABEL_56:
  addSubclass((uint64_t)v35, (objc_class *)a4);

  return addClassTableEntry((uint64_t)a3, 1);
}

const char *__cdecl ivar_getName(const char *v)
{
  if (v) {
    return (const char *)*((void *)v + 1);
  }
  return v;
}

void objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::grow(int a1)
{
  uint64_t v1 = dword_1EB1CA560;
  if (objc::methodDescriptionMap) {
    size_t v2 = (unint64_t *)objc::methodDescriptionMap;
  }
  else {
    size_t v2 = 0;
  }
  unsigned int v3 = (a1 - 1) | ((a1 - 1) >> 1) | (((a1 - 1) | ((a1 - 1) >> 1)) >> 2);
  unsigned int v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
  int v5 = v4 | HIWORD(v4);
  if ((v5 + 1) > 4) {
    unsigned int v6 = v5 + 1;
  }
  else {
    unsigned int v6 = 4;
  }
  dword_1EB1CA560 = v6;
  uint64_t v7 = malloc_type_malloc(16 * v6, 0x64B88C75uLL);
  if (v7)
  {
    objc::methodDescriptionMap = (uint64_t)v7;
    qword_1EB1CA558 = 0;
    if (v2)
    {
      uint64_t v8 = v7;
LABEL_13:
      if (dword_1EB1CA560)
      {
        uint64_t v10 = 16 * dword_1EB1CA560;
        do
        {
          *uint64_t v8 = -1;
          v8 += 2;
          v10 -= 16;
        }
        while (v10);
      }
      if (v1)
      {
        uint64_t v11 = 16 * v1;
        uint64_t v12 = v2;
        do
        {
          unint64_t v13 = *v12;
          if (*v12 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            uint64_t v16 = 0;
            objc::DenseMapBase<objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>,method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::LookupBucketFor<method_t const*>(v13, &v16);
            uint64_t v14 = v16;
            *uint64_t v16 = *v12;
            v14[1] = v12[1];
            LODWORD(qword_1EB1CA558) = qword_1EB1CA558 + 1;
          }
          v12 += 2;
          v11 -= 16;
        }
        while (v11);
      }
      free(v2);
      return;
    }
    int v9 = v7;
  }
  else
  {
    int v9 = 0;
    uint64_t v8 = 0;
    objc::methodDescriptionMap = 0;
    qword_1EB1CA558 = 0;
    if (v2) {
      goto LABEL_13;
    }
  }
  if (dword_1EB1CA560)
  {
    uint64_t v15 = 16 * dword_1EB1CA560;
    do
    {
      *int v9 = -1;
      v9 += 2;
      v15 -= 16;
    }
    while (v15);
  }
}

uint64_t method_t::getCachedDescription(uint64_t this)
{
  int v2 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v2, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v2) {
    os_unfair_lock_lock_with_options();
  }
  if (!byte_1EB1CA568)
  {
    objc::methodDescriptionMap = 0;
    qword_1EB1CA558 = 0;
    dword_1EB1CA560 = 0;
    byte_1EB1CA568 = 1;
  }
  uint64_t v15 = 0;
  char v4 = objc::DenseMapBase<objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>,method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::LookupBucketFor<method_t const*>(this, &v15);
  int v5 = v15;
  if (v4)
  {
    uint64_t v7 = v15 + 1;
    uint64_t v6 = v15[1];
    if (v6) {
      goto LABEL_25;
    }
    goto LABEL_15;
  }
  if (4 * (int)qword_1EB1CA558 + 4 >= (3 * dword_1EB1CA560))
  {
    objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::grow(2 * dword_1EB1CA560);
    uint64_t v15 = 0;
    objc::DenseMapBase<objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>,method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::LookupBucketFor<method_t const*>(this, &v15);
LABEL_30:
    int v5 = v15;
    goto LABEL_10;
  }
  if (dword_1EB1CA560 + ~qword_1EB1CA558 - HIDWORD(qword_1EB1CA558) <= dword_1EB1CA560 >> 3)
  {
    objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::grow(dword_1EB1CA560);
    uint64_t v15 = 0;
    objc::DenseMapBase<objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>,method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::LookupBucketFor<method_t const*>(this, &v15);
    goto LABEL_30;
  }
LABEL_10:
  if (*v5 == -2)
  {
    qword_1EB1CA558 = (uint64_t)vadd_s32((int32x2_t)qword_1EB1CA558, (int32x2_t)0xFFFFFFFF00000001);
  }
  else if (*v5 == -1)
  {
    LODWORD(qword_1EB1CA558) = qword_1EB1CA558 + 1;
  }
  *int v5 = this;
  v5[1] = 0;
  uint64_t v7 = v5 + 1;
LABEL_15:
  uint64_t v8 = malloc_type_malloc(0x10uLL, 0x90040C859B4A5uLL);
  *uint64_t v7 = (uint64_t)v8;
  int v10 = this & 3;
  if ((this & 3) != 0)
  {
    if (v10 == 2)
    {
      int v9 = *(char **)(this & 0xFFFFFFFFFFFFFFFCLL);
    }
    else if (v10 == 1)
    {
      uint64_t v11 = (int *)(this & 0xFFFFFFFFFFFFFFFCLL);
      if (dataSegmentsRanges > (this & 0xFFFFFFFFFFFFFFFCLL) || *(void *)algn_1EB1CB078 <= (unint64_t)v11) {
        int v9 = *(char **)((char *)v11 + *v11);
      }
      else {
        int v9 = (char *)&unk_1F62995A8 + *v11;
      }
    }
  }
  else
  {
    int v9 = *(char **)(this & 0xFFFFFFFFFFFFFFFCLL);
  }
  *uint64_t v8 = v9;
  *(void *)(*v7 + 8) = method_t::types(this);
  uint64_t v6 = *v7;
LABEL_25:
  int v12 = *(_DWORD *)(StatusReg + 24);
  int v13 = v12;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v13, 0, memory_order_release, memory_order_relaxed);
  if (v13 != v12) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return v6;
}

void sub_180134F68(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

uint64_t objc::DenseMapBase<objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>,method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::LookupBucketFor<method_t const*>(unint64_t a1, void *a2)
{
  if (dword_1EB1CA560)
  {
    int v2 = dword_1EB1CA560 - 1;
    unsigned int v3 = (dword_1EB1CA560 - 1) & (bswap64(0x8A970BE7488FDA55 * (a1 ^ (a1 >> 4))) ^ (1217387093 * (a1 ^ (a1 >> 4))));
    int v4 = (void *)(objc::methodDescriptionMap + 16 * v3);
    uint64_t v5 = *v4;
    if (*v4 == a1)
    {
      uint64_t v6 = 1;
    }
    else
    {
      uint64_t v8 = 0;
      unsigned int v9 = 1;
      while (v5 != -1)
      {
        if (v9 > dword_1EB1CA560) {
          objc::DenseMapBase<objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>,method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::FatalCorruptHashTables((void *)objc::methodDescriptionMap, dword_1EB1CA560);
        }
        if (v8) {
          BOOL v10 = 0;
        }
        else {
          BOOL v10 = v5 == -2;
        }
        if (v10) {
          uint64_t v8 = v4;
        }
        unsigned int v11 = v3 + v9++;
        unsigned int v3 = v11 & v2;
        int v4 = (void *)(objc::methodDescriptionMap + 16 * (v11 & v2));
        uint64_t v5 = *v4;
        uint64_t v6 = 1;
        if (*v4 == a1) {
          goto LABEL_5;
        }
      }
      uint64_t v6 = 0;
      if (v8) {
        int v4 = v8;
      }
    }
  }
  else
  {
    int v4 = 0;
    uint64_t v6 = 0;
  }
LABEL_5:
  *a2 = v4;
  return v6;
}

Class _objc_realizeClassFromSwift(Class cls, void *previously)
{
  if (!cls) {
    _objc_fatal("Swift requested that class %p be ignored, but libobjc does not support that.", (uint64_t)previously, v2, v3, previously);
  }
  uint64_t Class = cls;
  int v6 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v6, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  BOOL v8 = v6 == 0;
  if (!previously || previously == cls)
  {
    if (!v8) {
      os_unfair_lock_lock_with_options();
    }
    if (!previously) {
      uint64_t Class = (objc_class *)readClass(Class, 0, 0);
    }
    BOOL v10 = realizeClassWithoutSwift(Class, 0);
  }
  else
  {
    if (!v8) {
      os_unfair_lock_lock_with_options();
    }
    addRemappedClass((objc_class *)previously, Class);
    addClassTableEntry((uint64_t)Class, 1);
    unsigned int v9 = (const char *)objc_class::mangledName(Class);
    addNamedClass(Class, v9, 0);
    BOOL v10 = realizeClassWithoutSwift(Class, (objc_class *)previously);
  }
  unsigned int v11 = v10;
  int v12 = *(_DWORD *)(StatusReg + 24);
  int v13 = v12;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v13, 0, memory_order_release, memory_order_relaxed);
  if (v13 != v12) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return v11;
}

void sub_1801351D8(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

uint64_t addRemappedClass(objc_class *this, objc_class *a2)
{
  if (PrintFuture)
  {
    unsigned int v9 = objc_class::nameForLogging(this);
    _objc_inform("FUTURE: using %p instead of %p for %s", a2, this, v9);
  }
  if (!byte_1EB1CA648)
  {
    dword_1EB1CA640 = 64;
    int v4 = malloc_type_malloc(0x400uLL, 0x64B88C75uLL);
    if (v4)
    {
      remappedClasses(BOOL)::remapped_class_map = (uint64_t)v4;
      qword_1EB1CA638 = 0;
      int v5 = v4;
    }
    else
    {
      int v5 = 0;
      remappedClasses(BOOL)::remapped_class_map = 0;
      qword_1EB1CA638 = 0;
    }
    if (dword_1EB1CA640)
    {
      uint64_t v6 = 16 * dword_1EB1CA640;
      do
      {
        *int v5 = -1;
        v5 += 2;
        v6 -= 16;
      }
      while (v6);
    }
    byte_1EB1CA648 = 1;
  }
  BOOL v10 = 0;
  uint64_t result = objc::DenseMapBase<objc::DenseMap<objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>,objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>::LookupBucketFor<objc_class *>((unint64_t)this, &v10);
  if ((result & 1) == 0)
  {
    uint64_t result = dword_1EB1CA640;
    if (4 * (int)qword_1EB1CA638 + 4 >= (3 * dword_1EB1CA640))
    {
      LODWORD(result) = 2 * dword_1EB1CA640;
    }
    else if (dword_1EB1CA640 + ~qword_1EB1CA638 - HIDWORD(qword_1EB1CA638) > dword_1EB1CA640 >> 3)
    {
LABEL_14:
      BOOL v8 = v10;
      if (*v10 == -2)
      {
        qword_1EB1CA638 = (uint64_t)vadd_s32((int32x2_t)qword_1EB1CA638, (int32x2_t)0xFFFFFFFF00000001);
      }
      else if (*v10 == -1)
      {
        LODWORD(qword_1EB1CA638) = qword_1EB1CA638 + 1;
      }
      *BOOL v10 = this;
      v8[1] = a2;
      return result;
    }
    objc::DenseMap<objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>::grow(result);
    BOOL v10 = 0;
    uint64_t result = objc::DenseMapBase<objc::DenseMap<objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>,objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>::LookupBucketFor<objc_class *>((unint64_t)this, &v10);
    goto LABEL_14;
  }
  return result;
}

uint64_t objc::DenseMapBase<objc::DenseMap<objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>,objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>::LookupBucketFor<objc_class *>(unint64_t a1, void *a2)
{
  if (dword_1EB1CA640)
  {
    int v2 = dword_1EB1CA640 - 1;
    unsigned int v3 = (dword_1EB1CA640 - 1) & (bswap64(0x8A970BE7488FDA55 * (a1 ^ (a1 >> 4))) ^ (1217387093 * (a1 ^ (a1 >> 4))));
    int v4 = (void *)(remappedClasses(BOOL)::remapped_class_map + 16 * v3);
    uint64_t v5 = *v4;
    if (*v4 == a1)
    {
      uint64_t v6 = 1;
    }
    else
    {
      BOOL v8 = 0;
      unsigned int v9 = 1;
      while (v5 != -1)
      {
        if (v9 > dword_1EB1CA640) {
          objc::DenseMapBase<objc::DenseMap<objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>,objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>::FatalCorruptHashTables((void *)remappedClasses(BOOL)::remapped_class_map, dword_1EB1CA640);
        }
        if (v8) {
          BOOL v10 = 0;
        }
        else {
          BOOL v10 = v5 == -2;
        }
        if (v10) {
          BOOL v8 = v4;
        }
        unsigned int v11 = v3 + v9++;
        unsigned int v3 = v11 & v2;
        int v4 = (void *)(remappedClasses(BOOL)::remapped_class_map + 16 * (v11 & v2));
        uint64_t v5 = *v4;
        uint64_t v6 = 1;
        if (*v4 == a1) {
          goto LABEL_5;
        }
      }
      uint64_t v6 = 0;
      if (v8) {
        int v4 = v8;
      }
    }
  }
  else
  {
    int v4 = 0;
    uint64_t v6 = 0;
  }
LABEL_5:
  *a2 = v4;
  return v6;
}

Class objc_getFutureClass(const char *name)
{
  int v2 = look_up_class((char *)name);
  if (v2)
  {
    unsigned int v3 = (unint64_t *)v2;
    if (PrintFuture) {
      _objc_inform("FUTURE: found %p already in use for %s", v2, name);
    }
  }
  else
  {
    int v4 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v4) {
      os_unfair_lock_lock_with_options();
    }
    uint64_t v6 = (uint64_t *)futureNamedClasses();
    unsigned int v3 = (unint64_t *)NXMapGet(v6, (uint64_t)name);
    if (!v3)
    {
      uint64_t v7 = (unint64_t *)malloc_type_zone_malloc_with_options_internal();
      unsigned int v3 = v7;
      if (PrintFuture) {
        _objc_inform("FUTURE: reserving %p for %s", v7, name);
      }
      BOOL v8 = malloc_type_calloc(0x20uLL, 1uLL, 0x1ECB51D3uLL);
      unsigned int v9 = malloc_type_calloc(0x48uLL, 1uLL, 0xF421F30EuLL);
      size_t v10 = strlen(name) + 1;
      unsigned int v11 = (void *)name;
      if ((_dyld_is_memory_immutable() & 1) == 0)
      {
        unsigned int v11 = malloc_type_malloc(v10, 0x3F84A03uLL);
        memcpy(v11, name, v10);
      }
      v9[3] = v11;
      int v12 = v8 + 1;
      uint64_t v13 = v8[1];
      if (v13) {
        int v12 = (void *)(v13 & 0xFFFFFFFFFFFFFFFELL);
      }
      *int v12 = v9;
      class_data_bits_t::setData(v3 + 4, (unint64_t)v8);
      *(_DWORD *)(v3[4] & 0xF00007FFFFFFFF8) = 0x40000000;
      uint64_t v14 = (uint64_t *)futureNamedClasses();
      NXMapKeyCopyingInsert(v14, name, (uint64_t)v3);
    }
    int v15 = *(_DWORD *)(StatusReg + 24);
    int v16 = v15;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v16, 0, memory_order_release, memory_order_relaxed);
    if (v16 != v15) {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
  }
  return (Class)v3;
}

void sub_180135710(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void *_objc_getClassForTag(unsigned int a1)
{
  uint64_t result = classSlotForTagIndex(a1);
  if (result)
  {
    if (*result) {
      return (void *)*result;
    }
    else {
      return 0;
    }
  }
  return result;
}

objc_class **_objc_registerTaggedPointerClass(unsigned int a1, objc_class *a2, const char *a3, char *a4)
{
  if (!objc_debug_taggedpointer_mask) {
    _objc_fatal("tagged pointers are disabled", (uint64_t)a2, a3, a4);
  }
  uint64_t result = (objc_class **)classSlotForTagIndex(a1);
  if (!result) {
    _objc_fatal("tag index %u is invalid", v7, v8, v9, a1);
  }
  size_t v10 = *result;
  if (*result && a2 && v10 && v10 != a2)
  {
    uint64_t v13 = *result;
    uint64_t v14 = objc_class::nameForLogging(v10);
    int v15 = objc_class::nameForLogging(a2);
    _objc_fatal("tag index %u used for two different classes (was %p %s, now %p %s)", v16, v17, v18, a1, v13, v14, a2, v15);
  }
  if (a2) {
    unsigned int v11 = a2;
  }
  else {
    unsigned int v11 = 0;
  }
  void *result = v11;
  if (a1 >= 7)
  {
    int v12 = &objc_debug_taggedpointer_classes[byte_1EB1CA237];
    if (!*v12) {
      *int v12 = __NSUnrecognizedTaggedPointer;
    }
  }
  return result;
}

void *classSlotForTagIndex(unsigned int a1)
{
  if (a1 <= 6)
  {
    uint64_t v1 = objc_debug_tag60_permutations[a1];
    uint64_t v2 = objc_debug_taggedpointer_classes;
    return &v2[v1];
  }
  uint64_t v3 = 0;
  if (a1 != 7 && a1 <= 0x107)
  {
    uint64_t v4 = ((unint64_t)objc_debug_taggedpointer_obfuscator >> 55);
    if (a1 > 0x87) {
      uint64_t v4 = 0;
    }
    uint64_t v1 = v4 ^ (a1 - 8);
    uint64_t v2 = objc_debug_taggedpointer_ext_classes;
    return &v2[v1];
  }
  return (void *)v3;
}

IMP imp_implementationWithBlock(id block)
{
  uint64_t v4 = _Block_copy(block);
  if (!Trampolines[0])
  {
    int v5 = dlopen("/usr/lib/libobjc-trampolines.dylib", 262);
    if (!v5)
    {
      atomic_ullong v26 = dlerror();
      _objc_fatal("couldn't dlopen libobjc-trampolines.dylib: %s", v27, v28, v29, v26);
    }
    uint64_t v6 = v5;
    uint64_t v7 = malloc_type_malloc(0x20uLL, 0xB4ED9BFAuLL);
    TrampolinePointerWrapper::TrampolinePointers::TrampolineAddress::TrampolineAddress((TrampolinePointerWrapper::TrampolinePointers::TrampolineAddress *)v7, v6, "Impl");
    TrampolinePointerWrapper::TrampolinePointers::TrampolineAddress::TrampolineAddress((TrampolinePointerWrapper::TrampolinePointers::TrampolineAddress *)(v7 + 1), v6, "Start");
    BOOL v8 = (const mach_header_64 *)dyld_image_header_containing_address();
    unint64_t size = 0;
    unsigned int v9 = getsegmentdata(v8, "__TEXT", &size);
    if (v9) {
      size_t v10 = v9;
    }
    else {
      size_t v10 = 0;
    }
    v7[2] = v10;
    uint64_t v11 = 0;
    v7[3] = size;
    atomic_compare_exchange_strong_explicit(Trampolines, (unint64_t *)&v11, (unint64_t)v7, memory_order_release, memory_order_relaxed);
    if (v11) {
      free(v7);
    }
  }
  int v12 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v12, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v12) {
    os_unfair_lock_lock_with_options();
  }
  if (!HeadPageGroup) {
    goto LABEL_14;
  }
  TrampolinesAndData = (void *)HeadPageGroup;
  if (*(void *)(HeadPageGroup + 16) != 2048) {
    goto LABEL_15;
  }
  if (*(void *)(HeadPageGroup + 8)) {
    TrampolinesAndData = *(void **)(HeadPageGroup + 8);
  }
  else {
LABEL_14:
  }
    TrampolinesAndData = _allocateTrampolinesAndData();
LABEL_15:
  unint64_t v15 = TrampolinesAndData[2];
  uint64_t v16 = v15;
  unint64_t v17 = TrampolinesAndData[v15];
  if (!v17) {
    unint64_t v17 = v15 + 1;
  }
  TrampolinesAndData[2] = v17;
  if (v17 == 2048 && HeadPageGroup)
  {
    uint64_t v18 = HeadPageGroup;
    do
    {
      int v21 = *(void **)(v18 + 8);
      unint64_t v19 = (void *)(v18 + 8);
      atomic_ullong v20 = v21;
      if (!v21) {
        break;
      }
      if (TrampolinesAndData == v20)
      {
        *unint64_t v19 = TrampolinesAndData[1];
        TrampolinesAndData[1] = 0;
        break;
      }
      uint64_t v18 = (uint64_t)v20;
    }
    while (v20);
  }
  TrampolinesAndData[v15] = v4;
  if (*(void *)(Trampolines[0] + 8)) {
    uint64_t v22 = *(void *)(Trampolines[0] + 8);
  }
  else {
    uint64_t v22 = 0;
  }
  if (v15 > 0x7FF || (unint64_t)(v22 - *(void *)Trampolines[0]) >> 3 > v15) {
    _objc_fatal("Trampoline block %p, requested invalid index %lu", v1, v2, v3, TrampolinesAndData, v15);
  }
  int v23 = *(_DWORD *)(StatusReg + 24);
  int v24 = v23;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v24, 0, memory_order_release, memory_order_relaxed);
  if (v24 != v23) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return (IMP)&TrampolinesAndData[v16 + 4096];
}

void sub_180135CF4(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

TrampolinePointerWrapper::TrampolinePointers::TrampolineAddress *TrampolinePointerWrapper::TrampolinePointers::TrampolineAddress::TrampolineAddress(TrampolinePointerWrapper::TrampolinePointers::TrampolineAddress *this, void *a2, const char *__s)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  strlen(__s);
  uint64_t v6 = (char *)v12 - ((MEMORY[0x1F4188790]() + 37) & 0xFFFFFFFFFFFFFFF0);
  strcpy(v6, "_objc_blockTrampoline");
  strcat(v6, __s);
  uint64_t v7 = dlsym(a2, v6);
  if (!v7)
  {
    *(void *)this = 0;
    _objc_fatal("couldn't dlsym %s", v8, v9, v10, v6);
  }
  *(void *)this = v7;
  return this;
}

void *_allocateTrampolinesAndData(void)
{
  vm_address_t address = 0;
  if (*(void *)(Trampolines + 16)) {
    vm_address_t v0 = *(void *)(Trampolines + 16);
  }
  else {
    vm_address_t v0 = 0;
  }
  if (*(void *)(Trampolines + 24)) {
    vm_size_t v1 = *(void *)(Trampolines + 24);
  }
  else {
    vm_size_t v1 = 0;
  }
  uint64_t v2 = (vm_map_t *)MEMORY[0x1E4F14960];
  uint64_t v3 = vm_allocate(*MEMORY[0x1E4F14960], &address, v1 + 0x4000, 687865857);
  if (v3) {
    _objc_fatal("vm_allocate trampolines failed (%d)", v4, v5, v6, v3);
  }
  *(void *)cur_protection = 0;
  vm_address_t target_address = address + 0x4000;
  uint64_t v7 = vm_remap(*v2, &target_address, v1, 0, 0x4000, *v2, v0, 1, &cur_protection[1], cur_protection, 0);
  if (v7) {
    _objc_fatal("vm_remap trampolines failed (%d)", v8, v9, v10, v7);
  }
  uint64_t result = (void *)address;
  *(void *)vm_address_t address = 0;
  result[1] = 0;
  if (*(void *)(Trampolines + 8)) {
    uint64_t v12 = *(void *)(Trampolines + 8);
  }
  else {
    uint64_t v12 = 0;
  }
  result[2] = (unint64_t)(v12 - *(void *)Trampolines) >> 3;
  result[3] = result + 2048;
  if (HeadPageGroup)
  {
    uint64_t v13 = (void *)HeadPageGroup;
    if (*(void *)HeadPageGroup)
    {
      for (unint64_t i = *(void **)HeadPageGroup; ; unint64_t i = (void *)*i)
      {
        uint64_t v13 = i;
        if (!*i) {
          break;
        }
      }
    }
    if (result) {
      unint64_t v15 = result;
    }
    else {
      unint64_t v15 = 0;
    }
    *uint64_t v13 = v15;
    if (result) {
      unint64_t v17 = result;
    }
    else {
      unint64_t v17 = 0;
    }
    *(void *)(HeadPageGroup + 8) = v17;
  }
  else
  {
    if (result) {
      uint64_t v16 = result;
    }
    else {
      uint64_t v16 = 0;
    }
    HeadPageGroup = (uint64_t)v16;
  }
  return result;
}

void objc_setEnumerationMutationHandler(void (__cdecl *handler)(id))
{
  enumerationMutationHandler = handler;
}

id object_dispose(id a1)
{
  if (a1)
  {
    vm_size_t v1 = objc_destructInstance(a1);
    free(v1);
  }
  return 0;
}

Ivar *__cdecl class_copyIvarList(Class cls, unsigned int *outCount)
{
  if (cls)
  {
    int v4 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v4) {
      os_unfair_lock_lock_with_options();
    }
    uint64_t v6 = *(unsigned int **)(class_rw_t::ro((class_rw_t *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8)) + 48);
    if (v6 && (unsigned int v7 = v6[1]) != 0)
    {
      uint64_t v8 = (Ivar *)malloc_type_malloc(8 * (v7 + 1), 0x2004093837F09uLL);
      uint64_t v12 = *v6;
      uint64_t v13 = v6[1];
      unint64_t v14 = v13 * (unint64_t)v12;
      if ((v14 & 0xFFFFFFFF00000000) != 0) {
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v9, v10, v11, v13, v6, v12);
      }
      unint64_t v15 = v8;
      if (v14)
      {
        uint64_t v16 = 0;
        unsigned int v17 = 0;
        uint64_t v18 = v6 + 2;
        do
        {
          if (*(void *)((char *)v18 + v16)) {
            v8[v17++] = (Ivar)((char *)v18 + v16);
          }
          v16 += v12;
        }
        while (v14 != v16);
      }
      else
      {
        unsigned int v17 = 0;
      }
      v8[v17] = 0;
      if (!outCount) {
        goto LABEL_15;
      }
    }
    else
    {
      unint64_t v15 = 0;
      unsigned int v17 = 0;
      if (!outCount) {
        goto LABEL_15;
      }
    }
    *outCount = v17;
LABEL_15:
    int v19 = *(_DWORD *)(StatusReg + 24);
    int v20 = v19;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v20, 0, memory_order_release, memory_order_relaxed);
    if (v20 != v19) {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
    return v15;
  }
  unint64_t v15 = 0;
  if (outCount) {
    *outCount = 0;
  }
  return v15;
}

void sub_180136348(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void map_images(uint64_t a1, void *a2, uint64_t a3)
{
  int v6 = 0;
  char v13 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v6, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v6) {
    os_unfair_lock_lock_with_options();
  }
  map_images_nolock(a1, a2, (uint64_t)&v13, a3);
  int v11 = *(_DWORD *)(StatusReg + 24);
  int v12 = v11;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v12, 0, memory_order_release, memory_order_relaxed);
  if (v12 != v11) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  if (v13)
  {
    if (DebugClassRXSigning == 2) {
      _objc_fatal("class_rx signing mismatch", v8, v9, v10);
    }
    if (!(DisableFaults | DisableClassROFaults)
      && getpid() != 1
      && (is_root_ramdisk() & 1) == 0
      && os_variant_has_internal_diagnostics())
    {
      os_fault_with_payload();
    }
  }
}

void sub_1801364CC(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _initializeSwiftRefcountingThenCallRelease(objc_object *a1, double a2)
{
  double Helper_x16__swift_retain = gotLoadHelper_x16__swift_retain(a2);
  *int v4 = *(void *)(v3 + 2272);
  double Helper_x16__swift_release = gotLoadHelper_x16__swift_release(Helper_x16__swift_retain);
  *unsigned int v7 = *(uint64_t (**)(double))(v6 + 2256);
  return (*v7)(Helper_x16__swift_release);
}

uint64_t _initializeSwiftRefcountingThenCallRetain(objc_object *a1, double a2)
{
  double Helper_x16__swift_retain = gotLoadHelper_x16__swift_retain(a2);
  *int v4 = *(void *)(v3 + 2272);
  double Helper_x16__swift_release = gotLoadHelper_x16__swift_release(Helper_x16__swift_retain);
  *unsigned int v7 = *(void *)(v6 + 2256);
  return (*v8)(Helper_x16__swift_release);
}

uint64_t nonMetaClasses(void)
{
  uint64_t result = nonmeta_class_map[0];
  if (!nonmeta_class_map[0])
  {
    v3[0] = _mapPtrHash;
    v3[1] = _mapPtrIsEqual;
    v3[2] = _mapNoFree;
    int v4 = 0;
    vm_size_t v1 = NXCreateMapTable(v3, 0x20u);
    while (1)
    {
      uint64_t v2 = nonmeta_class_map[0];
      if (nonmeta_class_map[0]) {
        break;
      }
      atomic_compare_exchange_strong(nonmeta_class_map, (unint64_t *)&v2, (unint64_t)v1);
      if (!v2) {
        return nonmeta_class_map[0];
      }
    }
    NXFreeMapTable(v1);
    return nonmeta_class_map[0];
  }
  return result;
}

_DWORD *NXCreateMapTable(void *a1, unsigned int a2)
{
  int v4 = malloc_type_malloc(0x18uLL, 0x10E0040A403B16CuLL);
  int v5 = (NXHashTable *)prototypes;
  if (!prototypes)
  {
    NXHashTablePrototype v11 = *(NXHashTablePrototype *)protoPrototype;
    int v5 = NXCreateHashTable(&v11, 0, 0);
    prototypes = (uint64_t)v5;
  }
  if (*a1 && a1[1] && a1[2] && !*((_DWORD *)a1 + 6))
  {
    uint64_t v6 = NXHashGet(v5, a1);
    if (!v6)
    {
      uint64_t v6 = malloc_type_malloc(0x20uLL, 0x1080040AA79BA9DuLL);
      *uint64_t v6 = *a1;
      v6[1] = a1[1];
      v6[2] = a1[2];
      *((_DWORD *)v6 + 6) = *((_DWORD *)a1 + 6);
      NXHashInsert((NXHashTable *)prototypes, v6);
    }
    *(void *)int v4 = v6;
    v4[2] = 0;
    char v7 = 1;
    if (a2 >= 2)
    {
      char v8 = -1;
      do
      {
        ++v8;
        BOOL v9 = a2 > 3;
        a2 >>= 1;
      }
      while (v9);
      char v7 = v8 + 2;
    }
    v4[3] = (1 << v7) - 1;
    *((void *)v4 + 2) = allocBuckets(1 << v7);
  }
  else
  {
    _objc_inform("*** NXCreateMapTable: invalid creation parameters\n", v11.hash, v11.isEqual);
    return 0;
  }
  return v4;
}

void *allocBuckets(int a1)
{
  int v1 = a1;
  uint64_t result = (char *)malloc_type_malloc(16 * (a1 + 1), 0xC0040D1025EB5uLL) + 16;
  if (v1)
  {
    uint64_t v3 = result;
    do
    {
      *uint64_t v3 = -1;
      v3[1] = 0;
      v3 += 2;
      --v1;
    }
    while (v1);
  }
  return result;
}

NXHashTable *__cdecl NXCreateHashTable(NXHashTablePrototype *prototype, unsigned int capacity, const void *info)
{
  uint64_t v6 = (NXHashTable *)malloc_type_malloc(0x20uLL, 0x10E00402E54A04BuLL);
  char v7 = (NXHashTable *)prototypes;
  if (!prototypes)
  {
    char v8 = malloc_type_malloc(8uLL, 0x587677AEuLL);
    free(v8);
    BOOL v9 = malloc_type_malloc(0x20uLL, 0x10E00402E54A04BuLL);
    prototypes = (uint64_t)v9;
    *BOOL v9 = &protoPrototype;
    v9[1] = 0x100000001;
    size_t v10 = malloc_type_calloc(1uLL, 0x10uLL, 0x10C20406D26F19BuLL);
    char v7 = (NXHashTable *)prototypes;
    *(void *)(prototypes + 16) = v10;
    v7->unint64_t info = 0;
    *(_DWORD *)size_t v10 = 1;
    v10[1] = &protoPrototype;
  }
  if (!prototype->hash) {
    prototype->hash = NXPtrHash;
  }
  p_BOOL isEqual = &prototype->isEqual;
  if (!prototype->isEqual) {
    *p_BOOL isEqual = NXPtrIsEqual;
  }
  p_free = &prototype->free;
  if (!prototype->free) {
    *p_free = NXNoEffectFree;
  }
  if (prototype->style)
  {
    _objc_inform("*** NXCreateHashTable: invalid style\n");
    return 0;
  }
  char v13 = (const NXHashTablePrototype *)NXHashGet(v7, prototype);
  if (!v13)
  {
    unint64_t v14 = malloc_type_malloc(0x20uLL, 0x1080040AA79BA9DuLL);
    *unint64_t v14 = prototype->hash;
    v14[1] = *p_isEqual;
    v14[2] = *p_free;
    *((_DWORD *)v14 + 6) = prototype->style;
    NXHashInsert((NXHashTable *)prototypes, v14);
    char v13 = (const NXHashTablePrototype *)NXHashGet((NXHashTable *)prototypes, prototype);
    if (!v13)
    {
      _objc_inform("*** NXCreateHashTable: bug\n");
      return 0;
    }
  }
  v6->prototype = v13;
  v6->count = 0;
  v6->unint64_t info = info;
  if (capacity >= 2)
  {
    char v16 = -1;
    do
    {
      ++v16;
      BOOL v17 = capacity > 3;
      capacity >>= 1;
    }
    while (v17);
    char v15 = v16 + 2;
  }
  else
  {
    char v15 = 1;
  }
  size_t v18 = ~(-1 << v15);
  v6->nbBuckets = v18;
  v6->buckets = malloc_type_calloc(v18, 0x10uLL, 0x10C20406D26F19BuLL);
  return v6;
}

void *__cdecl NXHashGet(NXHashTable *table, const void *data)
{
  buckets = table->buckets;
  unint64_t v5 = ((uint64_t (*)(const void *))table->prototype->hash)(table->info) % (unint64_t)table->nbBuckets;
  int v6 = buckets[4 * v5];
  if (!v6) {
    return 0;
  }
  if (v6 == 1)
  {
    char v7 = (char *)&buckets[4 * v5];
    BOOL v9 = (const void *)*((void *)v7 + 1);
    unint64_t i = (void **)(v7 + 8);
    if (v9 != data)
    {
      if (((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data)) {
        return *i;
      }
      return 0;
    }
  }
  else
  {
    for (unint64_t i = *(void ***)&buckets[4 * v5 + 2]; *i != data; ++i)
    {
      if (((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data)) {
        return *i;
      }
      if (!--v6) {
        return 0;
      }
    }
  }
  return (void *)data;
}

BOOL isEqualPrototype(const void *a1, _DWORD *a2, _DWORD *a3)
{
  if (*(void *)a2) {
    uint64_t v3 = *(void *)a2;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3 == *(void *)a3
    && (!*((void *)a2 + 1) ? (uint64_t v4 = 0) : (uint64_t v4 = *((void *)a2 + 1)),
        v4 == *((void *)a3 + 1)
     && (!*((void *)a2 + 2) ? (uint64_t v5 = 0) : (uint64_t v5 = *((void *)a2 + 2)), v5 == *((void *)a3 + 2))))
  {
    return a2[6] == a3[6];
  }
  else
  {
    return 0;
  }
}

void _NXHashRehashToCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = (NXHashTable *)malloc_type_malloc(0x20uLL, 0x10E00402E54A04BuLL);
  v4->prototype = *(const NXHashTablePrototype **)a1;
  *(void *)&v4->count = *(void *)(a1 + 8);
  v4->buckets = *(void **)(a1 + 16);
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = a2;
  uint64_t v5 = malloc_type_calloc(a2, 0x10uLL, 0x10C20406D26F19BuLL);
  int v6 = 0;
  *(void *)(a1 + 16) = v5;
  signed int nbBuckets = v4->nbBuckets;
  while (1)
  {
    buckets = (char *)v4->buckets;
    if (!v6) {
      break;
    }
LABEL_7:
    --v6;
    int v12 = &buckets[16 * nbBuckets];
    int v14 = *(_DWORD *)v12;
    char v13 = (const void **)(v12 + 8);
    if (v14 != 1) {
      char v13 = (const void **)((char *)*v13 + 8 * v6);
    }
    NXHashInsert((NXHashTable *)a1, *v13);
  }
  uint64_t v9 = nbBuckets;
  size_t v10 = (int *)&buckets[16 * nbBuckets - 16];
  while (v9)
  {
    --v9;
    int v11 = *v10;
    v10 -= 4;
    int v6 = v11;
    if (v11)
    {
      signed int nbBuckets = v9;
      goto LABEL_7;
    }
  }
  freeBuckets(v4, 0);
  if (v4->count != *(_DWORD *)(a1 + 8)) {
    _objc_inform("*** hashtable: count differs after rehashing; probably indicates a broken invariant: there are x and y such as isE"
  }
      "qual(x, y) is TRUE but hash(x) != hash (y)\n");
  free(v4->buckets);

  free(v4);
}

void *__cdecl NXHashInsert(NXHashTable *table, const void *data)
{
  buckets = table->buckets;
  unint64_t v5 = ((uint64_t (*)(const void *))table->prototype->hash)(table->info) % (unint64_t)table->nbBuckets;
  int v6 = (char *)&buckets[2 * v5];
  char v7 = v6;
  int v8 = *(_DWORD *)v6;
  if (*(_DWORD *)v6 != 1)
  {
    if (!v8)
    {
      uint64_t result = 0;
      *(_DWORD *)int v6 = 1;
      buckets[2 * v5 + 1] = data;
      ++table->count;
      return result;
    }
    int v12 = (char *)&buckets[2 * v5];
    char v15 = (void **)*((void *)v12 + 1);
    char v13 = (const void **)(v12 + 8);
    int v14 = v15;
    while (*v14 != data)
    {
      if (((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data))
      {
        uint64_t result = *v14;
        goto LABEL_17;
      }
      ++v14;
      if (!--v8)
      {
        char v16 = (char *)malloc_type_calloc((*v7 + 2), 8uLL, 0x80040B8603338uLL);
        BOOL v17 = (const void **)(v16 + 8);
        uint64_t v18 = *v7;
        if (v18) {
          memmove(v16 + 16, *v13, 8 * v18);
        }
        *BOOL v17 = data;
        free((char *)*v13 - 8);
        ++*v7;
        *char v13 = v17;
LABEL_19:
        unsigned int nbBuckets = table->nbBuckets;
        unsigned int v22 = table->count + 1;
        table->count = v22;
        if (v22 > nbBuckets) {
          _NXHashRehashToCapacity((uint64_t)table, (2 * nbBuckets) | 1);
        }
        return 0;
      }
    }
    uint64_t result = (void *)data;
LABEL_17:
    *int v14 = (void *)data;
    return result;
  }
  int v11 = (const void *)*((void *)v6 + 1);
  size_t v10 = (void **)(v6 + 8);
  uint64_t result = (void *)data;
  if (v11 != data)
  {
    if (!((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data))
    {
      int v19 = malloc_type_calloc(3uLL, 8uLL, 0x80040B8603338uLL);
      int v20 = *v10;
      v19[1] = data;
      v19[2] = v20;
      ++*v7;
      *size_t v10 = v19 + 1;
      goto LABEL_19;
    }
    uint64_t result = *v10;
  }
  *size_t v10 = (void *)data;
  return result;
}

unint64_t hashPrototype(uint64_t a1, uint64_t *a2)
{
  if (*a2) {
    uint64_t v2 = *a2;
  }
  else {
    uint64_t v2 = 0;
  }
  if (a2[1]) {
    unint64_t v3 = a2[1];
  }
  else {
    unint64_t v3 = 0;
  }
  return a2[2] ^ v2 ^ v3 ^ *((int *)a2 + 6) ^ ((a2[2] ^ v2 ^ v3) >> 16);
}

unint64_t hashPrototype(const void *a1, unint64_t *a2)
{
  if (*a2) {
    unint64_t v2 = *a2;
  }
  else {
    unint64_t v2 = 0;
  }
  if (a2[1]) {
    unint64_t v3 = a2[1];
  }
  else {
    unint64_t v3 = 0;
  }
  return *((int *)a2 + 6) ^ ((v3 ^ v2 ^ a2[2]) >> 16) ^ v2 ^ v3 ^ a2[2];
}

void freeBuckets(NXHashTable *a1, int a2)
{
  unsigned int nbBuckets = a1->nbBuckets;
  if (nbBuckets)
  {
    for (unint64_t i = a1->buckets; !*(_DWORD *)i; i += 2)
    {
LABEL_18:
      if (!--nbBuckets) {
        return;
      }
    }
    free = NXNoEffectFree;
    if (a2 && (!a1->prototype ? (prototype = 0) : (prototype = a1->prototype), (free = prototype->free) == 0)) {
      int v8 = 0;
    }
    else {
      int v8 = free;
    }
    int v9 = *(_DWORD *)i;
    uint64_t v10 = i[1];
    if (*(_DWORD *)i)
    {
      unint64_t info = a1->info;
      if (v9 == 1)
      {
        ((void (*)(const void *, void))v8)(a1->info, i[1]);
LABEL_17:
        *(_DWORD *)unint64_t i = 0;
        i[1] = 0;
        goto LABEL_18;
      }
      int v12 = (uint64_t *)i[1];
      do
      {
        --v9;
        uint64_t v13 = *v12++;
        ((void (*)(const void *, uint64_t))v8)(info, v13);
      }
      while (v9);
    }
    ::free((void *)(v10 - 8));
    goto LABEL_17;
  }
}

BOOL isEqualPrototype(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    uint64_t v3 = *a2;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3 == *(void *)a3
    && (!a2[1] ? (uint64_t v4 = 0) : (uint64_t v4 = a2[1]),
        v4 == *(void *)(a3 + 8) && (!a2[2] ? (uint64_t v5 = 0) : (uint64_t v5 = a2[2]), v5 == *(void *)(a3 + 16))))
  {
    return *((_DWORD *)a2 + 6) == *(_DWORD *)(a3 + 24);
  }
  else
  {
    return 0;
  }
}

void _objc_inform(const char *a1, ...)
{
  va_start(va, a1);
  v3[0] = 0;
  unint64_t v2 = 0;
  va_copy((va_list)&v3[1], va);
  vasprintf(v3, a1, va);
  pid_t v1 = getpid();
  asprintf(&v2, "objc[%d]: %s\n", v1, v3[0]);
  _objc_syslog(v2);
  free(v2);
  free(v3[0]);
}

ssize_t _objc_syslog(const char *a1)
{
  getpid();
  if (!sandbox_check()
    || (_simple_asl_log(), ssize_t result = fstat(2, &v5), (result & 0x80000000) == 0)
    && ((v5.st_mode & 0xB000) == 0x8000 || (int v3 = v5.st_mode & 0xF000, v3 == 0x2000) || v3 == 4096))
  {
    size_t v4 = strlen(a1);
    return write(2, a1, v4);
  }
  return result;
}

void objc_setForwardHandler(void *fwd, void *fwd_stret)
{
  if (fwd) {
    unint64_t v2 = (void (*)(objc_object *, objc_selector *))fwd;
  }
  else {
    unint64_t v2 = 0;
  }
  _objc_forward_handler = v2;
}

objc_uncaught_exception_handler objc_setUncaughtExceptionHandler(objc_uncaught_exception_handler fn)
{
  if (!uncaught_handler)
  {
    objc_uncaught_exception_handler result = 0;
    if (fn) {
      goto LABEL_3;
    }
LABEL_5:
    int v3 = 0;
    goto LABEL_6;
  }
  objc_uncaught_exception_handler result = (objc_uncaught_exception_handler)uncaught_handler;
  if (!fn) {
    goto LABEL_5;
  }
LABEL_3:
  int v3 = (uint64_t (*)(objc_object *))fn;
LABEL_6:
  uncaught_handler = v3;
  return result;
}

objc_exception_matcher objc_setExceptionMatcher(objc_exception_matcher fn)
{
  if (!exception_matcher)
  {
    objc_exception_matcher result = 0;
    if (fn) {
      goto LABEL_3;
    }
LABEL_5:
    int v3 = 0;
    goto LABEL_6;
  }
  objc_exception_matcher result = (objc_exception_matcher)exception_matcher;
  if (!fn) {
    goto LABEL_5;
  }
LABEL_3:
  int v3 = (uint64_t (*)(objc_class *, objc_object *))fn;
LABEL_6:
  exception_matcher = v3;
  return result;
}

objc_exception_preprocessor objc_setExceptionPreprocessor(objc_exception_preprocessor fn)
{
  if (!exception_preprocessor[0])
  {
    objc_exception_preprocessor result = 0;
    if (fn) {
      goto LABEL_3;
    }
LABEL_5:
    int v3 = 0;
    goto LABEL_6;
  }
  objc_exception_preprocessor result = (objc_exception_preprocessor)exception_preprocessor[0];
  if (!fn) {
    goto LABEL_5;
  }
LABEL_3:
  int v3 = (uint64_t (*)(objc_object *))fn;
LABEL_6:
  exception_preprocessor[0] = v3;
  return result;
}

uint64_t __getSharedCachePreoptimizedProtocol_block_invoke(uint64_t result, unint64_t a2, int a3, unsigned char *a4)
{
  if (a3)
  {
    if (dataSegmentsRanges <= a2 && *(void *)algn_1EB1CB078 > a2)
    {
      **(void **)(result + 32) = a2;
      *a4 = 1;
    }
  }
  return result;
}

void tls_autoptr_direct_impl<_objc_pthread_data,(tls_key)0>::dtor_(char *a1)
{
  if (a1)
  {
    unint64_t v2 = *(void **)a1;
    if (*(void *)a1)
    {
      int v3 = (void *)v2[1];
      if (v3) {
        free(v3);
      }
      free(v2);
    }
    size_t v4 = (void *)*((void *)a1 + 1);
    if (v4) {
      free(v4);
    }
    for (uint64_t i = 24; i != 56; i += 8)
    {
      int v6 = *(void **)&a1[i];
      if (v6) {
        free(v6);
      }
    }
    free(*((void **)a1 + 7));
    free(a1);
  }
}

void objc_setHook_getClass(objc_hook_getClass newValue, objc_hook_getClass *outOldValue)
{
  unint64_t v2 = (BOOL (__cdecl *)(const char *, Class *))GetClassHook;
  while (1)
  {
    *outOldValue = v2;
    if (v2)
    {
      int v3 = v2;
      if (newValue) {
        goto LABEL_4;
      }
    }
    else
    {
      int v3 = 0;
      if (newValue)
      {
LABEL_4:
        objc_hook_getClass v4 = newValue;
        goto LABEL_7;
      }
    }
    objc_hook_getClass v4 = 0;
LABEL_7:
    stat v5 = v3;
    atomic_compare_exchange_strong_explicit(&GetClassHook, (unint64_t *)&v5, (unint64_t)v4, memory_order_release, memory_order_relaxed);
    if (v5 == v3) {
      break;
    }
    unint64_t v2 = 0;
    if (v5) {
      unint64_t v2 = v5;
    }
  }
}

void objc_setHook_lazyClassNamer(objc_hook_lazyClassNamer newValue, objc_hook_lazyClassNamer *oldOutValue)
{
  unint64_t v2 = (const char *(__cdecl *)(Class))LazyClassNamerHook;
  while (1)
  {
    *oldOutValue = v2;
    if (v2)
    {
      int v3 = v2;
      if (newValue) {
        goto LABEL_4;
      }
    }
    else
    {
      int v3 = 0;
      if (newValue)
      {
LABEL_4:
        objc_hook_lazyClassNamer v4 = newValue;
        goto LABEL_7;
      }
    }
    objc_hook_lazyClassNamer v4 = 0;
LABEL_7:
    stat v5 = v3;
    atomic_compare_exchange_strong_explicit(&LazyClassNamerHook, (unint64_t *)&v5, (unint64_t)v4, memory_order_release, memory_order_relaxed);
    if (v5 == v3) {
      break;
    }
    unint64_t v2 = 0;
    if (v5) {
      unint64_t v2 = v5;
    }
  }
}

void objc_setHook_getImageName(objc_hook_getImageName newValue, objc_hook_getImageName *outOldValue)
{
  unint64_t v2 = (BOOL (__cdecl *)(Class, const char **))GetImageNameHook;
  while (1)
  {
    *outOldValue = v2;
    if (v2)
    {
      int v3 = v2;
      if (newValue) {
        goto LABEL_4;
      }
    }
    else
    {
      int v3 = 0;
      if (newValue)
      {
LABEL_4:
        objc_hook_getImageName v4 = newValue;
        goto LABEL_7;
      }
    }
    objc_hook_getImageName v4 = 0;
LABEL_7:
    stat v5 = v3;
    atomic_compare_exchange_strong_explicit(&GetImageNameHook, (unint64_t *)&v5, (unint64_t)v4, memory_order_release, memory_order_relaxed);
    if (v5 == v3) {
      break;
    }
    unint64_t v2 = 0;
    if (v5) {
      unint64_t v2 = v5;
    }
  }
}

Class objc_getMetaClass(Class name)
{
  if (name)
  {
    pid_t v1 = (const char *)name;
    unint64_t v2 = look_up_class((char *)name);
    if (v2)
    {
      return (Class)(*(void *)v2 & 0xFFFFFFFF8);
    }
    else
    {
      return 0;
    }
  }
  return name;
}

void _objc_setClassCopyFixupHandler(uint64_t a1)
{
  int v2 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v2, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v2) {
    os_unfair_lock_lock_with_options();
  }
  LODWORD(v4) = classCopyFixupHandlers;
  if (classCopyFixupHandlers == 1)
  {
    stat v5 = malloc_type_malloc(0x10uLL, 0x80040B8603338uLL);
    uint64_t v4 = classCopyFixupHandlers;
    if (classCopyFixupHandlers)
    {
      int v6 = &qword_1EB1CADC0;
      char v7 = v5;
      uint64_t v8 = classCopyFixupHandlers;
      do
      {
        uint64_t v9 = *v6++;
        *v7++ = v9;
        --v8;
      }
      while (v8);
      uint64_t v10 = v4;
    }
    else
    {
      uint64_t v10 = 0;
    }
    v5[v10] = a1;
    qword_1EB1CADC0 = (uint64_t)v5;
  }
  else if (classCopyFixupHandlers)
  {
    qword_1EB1CADC0 = (uint64_t)malloc_type_realloc((void *)qword_1EB1CADC0, 8 * (classCopyFixupHandlers + 1), 0x80040B8603338uLL);
    LODWORD(v4) = classCopyFixupHandlers;
    *(void *)(qword_1EB1CADC0 + 8 * classCopyFixupHandlers) = a1;
  }
  else
  {
    qword_1EB1CADC0 = a1;
  }
  classCopyFixupHandlers = v4 + 1;
  int v11 = *(_DWORD *)(StatusReg + 24);
  int v12 = v11;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v12, 0, memory_order_release, memory_order_relaxed);
  if (v12 != v11)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
}

void sub_1801380D4(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

int __objc_personality_v0(int version, int actions, uint64_t exceptionClass, _Unwind_Exception *exceptionObject, _Unwind_Context *context)
{
  uint64_t v8 = *(void *)&actions;
  uint64_t v9 = *(void *)&version;
  if (PrintExceptions)
  {
    if ((actions & 0xA) != 0) {
      uint64_t v10 = "unwinding";
    }
    else {
      uint64_t v10 = "searching";
    }
    int v11 = (const void *)(_Unwind_GetIP(context) - 1);
    CFA = (const void *)_Unwind_GetCFA(context);
    _objc_inform("EXCEPTIONS: %s through frame [ip=%p sp=%p] for exception %p", v10, v11, CFA, exceptionObject);
  }

  return MEMORY[0x1F417F090](v9, v8, exceptionClass, exceptionObject, context);
}

void _objc_init()
{
  if (_objc_init::initialized) {
    return;
  }
  _objc_init::initialized = 1;
  if (MEMORY[0x1E4F149E0] && getpid() == 1) {
    objc_bp_assist_cfg_np();
  }
  classInitLocuint64_t k = 0;
  pendingInitializeMapLocuint64_t k = 0;
  selLocuint64_t k = 0;
  loadMethodLocuint64_t k = 0;
  crashlog_locuint64_t k = 0;
  objcMsgLogLocuint64_t k = 0;
  AltHandlerDebugLocuint64_t k = 0;
  AssociationsManagerLocuint64_t k = 0;
  runtimeLock[0] = 0;
  DemangleCacheLocuint64_t k = 0;
  vm_address_t v0 = &OBJC_IVAR___Object_isa;
  if (!issetugid())
  {
    if ((dyld_program_sdk_at_least() & 1) == 0) {
      DisableAutoreleaseCoalescingLRU = 1;
    }
    if ((_os_feature_enabled_simple_impl() & 1) == 0) {
      DisableClassRXSigningEnforcement = 1;
    }
    if ((_os_feature_enabled_simple_impl() & 1) == 0) {
      DisableClassROFaults = 1;
    }
    int v12 = *_NSGetEnviron();
    if (v12)
    {
      uint64_t v13 = *v12;
      if (*v12)
      {
        char v14 = 0;
        int v15 = 0;
        int v16 = 0;
        do
        {
          if (!strncmp(v13, "Malloc", 6uLL)
            || !strncmp(v13, "DYLD", 4uLL)
            || !strncmp(v13, "NSZombiesEnabled", 0x10uLL))
          {
            char v14 = 1;
          }
          if (!strncmp(v13, "OBJC_", 5uLL))
          {
            if (!strncmp(v13, "OBJC_HELP=", 0xAuLL))
            {
              int v16 = 1;
            }
            else if (!strncmp(v13, "OBJC_PRINT_OPTIONS=", 0x13uLL))
            {
              int v15 = 1;
            }
            else if (!strncmp(v13, "OBJC_DEBUG_POOL_DEPTH=", 0x16uLL))
            {
              uint64_t v22 = strtol(v13 + 22, 0, 10);
              if ((unint64_t)(v22 + 1) <= 0x80000000 && v22) {
                objc::PageCountWarning = v22;
              }
            }
            else
            {
              uint64_t v18 = strchr(v13, 61);
              if (*v18)
              {
                unint64_t v19 = 0;
                int v20 = v18 + 1;
                int v21 = (size_t *)&qword_1E4FBD4F0;
                while (v19 >= 0x30 && !os_variant_allows_internal_security_policies()
                     || v20 - *v12 != *v21 + 1
                     || strncmp(*v12, (const char *)*(v21 - 2), *v21))
                {
                  ++v19;
                  v21 += 5;
                  if (v19 == 51) {
                    goto LABEL_37;
                  }
                }
                int v23 = (_DWORD **)((char *)&Settings + 40 * v19);
                if (!strcasecmp(v20, "fatal") || !strcasecmp(v20, "halt")) {
                  **int v23 = 2;
                }
                else {
                  **int v23 = !strcasecmp(v20, "yes")
                }
                       || !strcasecmp(v20, "warn")
                       || !strcasecmp(v20, "true")
                       || !strcasecmp(v20, "on")
                       || !strcasecmp(v20, "y")
                       || !strcmp(v20, "1");
              }
            }
          }
LABEL_37:
          BOOL v17 = v12[1];
          ++v12;
          uint64_t v13 = v17;
        }
        while (v17);
        if (v14)
        {
          uint64_t v27 = getenv("DYLD_INSERT_LIBRARIES");
          uint64_t v28 = getenv("NSZombiesEnabled");
          uint64_t v29 = getenv("OBJC_DEBUG_POOL_ALLOCATION");
          if (getenv("MallocStackLogging")
            || getenv("MallocStackLoggingNoCompact")
            || v28 && (*v28 | 0x20) == 0x79)
          {
            vm_address_t v0 = &OBJC_IVAR___Object_isa;
            if (v29) {
              goto LABEL_83;
            }
            goto LABEL_80;
          }
          vm_address_t v0 = &OBJC_IVAR___Object_isa;
          if (v27)
          {
            uint64_t v33 = strstr(v27, "libgmalloc");
            if (!v29)
            {
              if (v33) {
LABEL_80:
              }
                DebugPoolAllocation = 1;
            }
          }
        }
        else
        {
          vm_address_t v0 = &OBJC_IVAR___Object_isa;
        }
      }
      else
      {
        int v15 = 0;
        int v16 = 0;
      }
LABEL_83:
      if ((_os_feature_enabled_simple_impl() & 1) == 0) {
        DisablePreoptCaches = 1;
      }
      if ((v16 | v15))
      {
        if (v16)
        {
          _objc_inform("Objective-C runtime debugging. Set variable=YES to enable.");
          _objc_inform("OBJC_HELP: describe available environment variables");
          if (v15) {
            _objc_inform("OBJC_HELP is set");
          }
          _objc_inform("OBJC_PRINT_OPTIONS: list which options are set");
          if ((v15 & 1) == 0) {
            goto LABEL_88;
          }
        }
        else if ((v15 & 1) == 0)
        {
LABEL_88:
          unint64_t v30 = 0;
          unint64_t v31 = (const char **)off_1E4FBD4E0;
          while (1)
          {
            if (v30 < 0x30 || os_variant_allows_internal_security_policies())
            {
              if (v16)
              {
                _objc_inform("%s: %s", *v31, v31[1]);
                if (v15)
                {
LABEL_93:
                  int v32 = *(_DWORD *)*(v31 - 1);
                  if (v32 == 1)
                  {
                    _objc_inform("%s is set");
                  }
                  else if (v32 == 2)
                  {
                    _objc_inform("%s is fatal");
                  }
                }
              }
              else if (v15)
              {
                goto LABEL_93;
              }
            }
            ++v30;
            v31 += 5;
            if (v30 == 51) {
              goto LABEL_6;
            }
          }
        }
        _objc_inform("OBJC_PRINT_OPTIONS is set");
        goto LABEL_88;
      }
    }
  }
LABEL_6:
  pthread_key_init_np();
  for (uint64_t i = 0; i != 512; i += 64)
  {
    uint64_t v2 = (char *)&sDataLists + i;
    *(void *)uint64_t v2 = 0;
    *((_DWORD *)v2 + 2) = 0;
  }
  for (uint64_t j = 0; j != 128; j += 16)
    PropertyLocks[j] = 0;
  for (uint64_t k = 0; k != 128; k += 16)
    StructLocks[k] = 0;
  for (uint64_t m = 0; m != 128; m += 16)
    CppObjectLocks[m] = 0;
  do
  {
    *int v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = 0;
    v6[6] = 0;
    *((_OWORD *)v6 + 2) = 0uLL;
    *((_OWORD *)v6 + 3) = 0uLL;
    v6 += 16;
  }
  while (v6 != (int *)&objc_debug_headerInfoRWs);
  static_init();
  uint64_t v7 = 0;
  uint64_t v8 = -1;
  uint64_t v9 = -1;
  while (1)
  {
    uint64_t objc_selector = _dyld_get_objc_selector();
    if (!objc_selector) {
      break;
    }
    v8 &= ~objc_selector;
    v9 &= objc_selector;
    v7 += 8;
    if (v7 == 120) {
      goto LABEL_21;
    }
  }
  uint64_t v9 = 0;
  uint64_t v8 = 0;
LABEL_21:
  objc::InterestingSelectorOnes = v9;
  objc::InterestingSelectorZeroes = v8;
  uint64_t v11 = v0[74];
  if (!v11) {
    uint64_t v11 = 0;
  }
  objc::disableEnforceClassRXPtrAuth = v11;
  objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::init((void *)0x20);
  objc::allocatedClasses = 0;
  qword_1EB1CAE98 = 0;
  qword_1EB1CAEA0 = 0;
  old_terminate = std::set_terminate((std::terminate_handler)_objc_terminate);
  unsigned int v24 = -1;
  do
    ++v24;
  while (objc_restartableRanges[2 * v24]);
  uint64_t v25 = task_restartable_ranges_register();
  if (v25)
  {
    uint64_t v26 = v25;
    if (v25 != 6)
    {
      uint64_t v34 = mach_error_string(v25);
      _objc_fatal("task_restartable_ranges_register failed (result 0x%x: %s)", v35, v36, v37, v26, v34);
    }
    shouldUseRestartableRanges = 1;
  }
  _dyld_objc_register_callbacks();
  didCallDyldNotifyRegister = 1;
}

void *objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::init(void *result)
{
  if (result)
  {
    unsigned int v1 = (4 * (int)result / 3u + 1) | ((4 * (int)result / 3u + 1) >> 1);
    unsigned int v2 = v1 | (v1 >> 2) | ((v1 | (v1 >> 2)) >> 4);
    dword_1EB1CB0C8 = (v2 | (v2 >> 8) | ((v2 | (v2 >> 8)) >> 16)) + 1;
    objc_exception_preprocessor result = malloc_type_malloc(24 * dword_1EB1CB0C8, 0x64B88C75uLL);
    if (result)
    {
      objc::unattachedCategories = (uint64_t)result;
      qword_1EB1CB0C0 = 0;
      int v3 = result;
    }
    else
    {
      int v3 = 0;
      objc::unattachedCategories = 0;
      qword_1EB1CB0C0 = 0;
    }
    if (dword_1EB1CB0C8)
    {
      uint64_t v4 = 24 * dword_1EB1CB0C8;
      do
      {
        *int v3 = -1;
        v3 += 3;
        v4 -= 24;
      }
      while (v4);
    }
  }
  else
  {
    objc::unattachedCategories = 0;
    qword_1EB1CB0C0 = 0;
    dword_1EB1CB0C8 = 0;
  }
  return result;
}

BOOL imp_removeBlock(IMP anImp)
{
  if (anImp)
  {
    unsigned int v1 = anImp;
    int v2 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v2, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v2) {
      os_unfair_lock_lock_with_options();
    }
    unint64_t v14 = 0;
    uint64_t v4 = pageAndIndexContainingIMP(v1, &v14);
    int v5 = v4;
    if (v4)
    {
      int v6 = (const void *)v4[v14];
      v4[v14] = v4[2];
      v4[2] = v14;
      if (HeadPageGroup) {
        uint64_t v7 = HeadPageGroup;
      }
      else {
        uint64_t v7 = 0;
      }
      uint64_t v10 = *(uint64_t **)(v7 + 8);
      uint64_t v8 = (uint64_t **)(v7 + 8);
      uint64_t v9 = v10;
      if (v10)
      {
        while (v9)
        {
          if (v4 == v9) {
            goto LABEL_15;
          }
          uint64_t v8 = (uint64_t **)(v9 + 1);
          if (!v9[1]) {
            break;
          }
          uint64_t v9 = (uint64_t *)v9[1];
        }
      }
      *uint64_t v8 = v4;
      v4[1] = 0;
    }
    else
    {
      int v6 = 0;
    }
LABEL_15:
    int v11 = *(_DWORD *)(StatusReg + 24);
    int v12 = v11;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v12, 0, memory_order_release, memory_order_relaxed);
    if (v12 != v11) {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
    if (v5)
    {
      _Block_release(v6);
      LOBYTE(anImp) = 1;
    }
    else
    {
      LOBYTE(anImp) = 0;
    }
  }
  return (char)anImp;
}

uint64_t *pageAndIndexContainingIMP(void (*a1)(void), unint64_t *a2)
{
  if (!HeadPageGroup) {
    return 0;
  }
  for (objc_exception_preprocessor result = (uint64_t *)HeadPageGroup; ; objc_exception_preprocessor result = (uint64_t *)*result)
  {
    uint64_t v4 = *(void *)(Trampolines + 8) ? *(void *)(Trampolines + 8) : 0;
    if (result + 6144 > (uint64_t *)a1)
    {
      int v5 = result + 4096;
      if ((char *)result + ((v4 - *(void *)Trampolines) & 0xFFFFFFFFFFFFFFF8) + 0x8000 <= (char *)a1
        && (unint64_t)((char *)a1 - (char *)v5) >= 8)
      {
        break;
      }
    }
    if (!*result) {
      return 0;
    }
  }
  if (a2) {
    *a2 = (unint64_t)((char *)a1 - (char *)v5) >> 3;
  }
  return result;
}

void objc_end_catch(void)
{
  if (PrintExceptions) {
    _objc_inform("EXCEPTIONS: finishing handler");
  }

  __cxa_end_catch();
}

id _objc_deallocOnMainThreadHelper(void *a1)
{
  return [a1 dealloc];
}

id objc_begin_catch(void *exc_buf)
{
  if (PrintExceptions) {
    _objc_inform("EXCEPTIONS: handling exception %p at %p", exc_buf, v1);
  }

  return __cxa_begin_catch(exc_buf);
}

id _objc_exception_destructor(id *a1)
{
  id v1 = *a1;
  if (PrintExceptions)
  {
    ClassName = object_getClassName(*a1);
    _objc_inform("EXCEPTIONS: releasing completed exception %p (object %p, a %s)", a1, v1, ClassName);
  }

  return [v1 release];
}

uint64_t _objc_exception_do_catch(uint64_t a1, uint64_t (***a2)(), objc_object ***a3)
{
  if (!*a2 || *a2 != off_1EC978658)
  {
    if (PrintExceptions) {
      _objc_inform("EXCEPTIONS: skipping catch(?)");
    }
    return 0;
  }
  uint64_t v4 = **a3;
  *a3 = (objc_object **)v4;
  if ((uint64_t (**)())a1 == &OBJC_EHTYPE_id)
  {
    if (PrintExceptions) {
      _objc_inform("EXCEPTIONS: catch(id)");
    }
  }
  else
  {
    int v5 = 0;
    unint64_t v6 = *(void *)(a1 + 16);
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v5, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v5) {
      os_unfair_lock_lock_with_options();
    }
    uint64_t v8 = (objc_class *)remapClass(v6);
    int v9 = *(_DWORD *)(StatusReg + 24);
    int v10 = v9;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v10, 0, memory_order_release, memory_order_relaxed);
    if (v10 != v9) {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
    if (!v8 || !exception_matcher(v8, v4))
    {
      if (PrintExceptions)
      {
        objc_class::nameForLogging(v8);
        _objc_inform("EXCEPTIONS: skipping catch(%s)");
      }
      return 0;
    }
    if (PrintExceptions)
    {
      objc_class::nameForLogging(v8);
      _objc_inform("EXCEPTIONS: catch(%s)");
    }
  }
  return 1;
}

void sub_1801391C0(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void objc_exception_throw(id exception)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = __cxa_allocate_exception(0x20uLL);
  unint64_t v3 = exception_preprocessor[0]((objc_object *)exception);
  [v3 retain];
  *uint64_t v2 = v3;
  v2[1] = off_1EC978658;
  v2[2] = object_getClassName((id)v3);
  if (v3)
  {
    if ((v3 & 0x8000000000000000) != 0)
    {
      int v4 = (__objc2_class *)objc_debug_taggedpointer_classes[v3 & 7];
      if (v4 && v4 == __NSUnrecognizedTaggedPointer) {
        int v4 = (__objc2_class *)objc_debug_taggedpointer_ext_classes[(v3 >> 55)];
      }
    }
    else
    {
      int v4 = (__objc2_class *)(*(void *)v3 & 0x7FFFFFFFFFFFF8);
    }
  }
  else
  {
    int v4 = 0;
  }
  v2[3] = v4;
  if (PrintExceptions)
  {
    ClassName = object_getClassName((id)v3);
    _objc_inform("EXCEPTIONS: throwing %p (object %p, a %s)", v2, (const void *)v3, ClassName);
  }
  if (PrintExceptionThrow)
  {
    if (!PrintExceptions)
    {
      unint64_t v6 = object_getClassName((id)v3);
      _objc_inform("EXCEPTIONS: throwing %p (object %p, a %s)", v2, (const void *)v3, v6);
    }
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    *(_OWORD *)int v9 = 0u;
    long long v10 = 0u;
    int v7 = backtrace(v9, 500);
    int v8 = fileno((FILE *)*MEMORY[0x1E4F143C8]);
    backtrace_symbols_fd(v9, v7, v8);
  }
  __cxa_throw(v2, (struct type_info *)(v2 + 1), (void (*)(void *))_objc_exception_destructor);
}

void objc_addLoadImageFunc(objc_func_loadImage func)
{
  int v5 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v5, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v5) {
    os_unfair_lock_lock_with_options();
  }
  int v7 = (void *)FirstHeader;
  if (FirstHeader)
  {
    do
    {
      ((void (*)(char *))func)((char *)v7 + *v7);
      uint64_t PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v7);
      int v9 = v7 + 3;
      if (PreoptimizedHeaderRW) {
        int v9 = (void *)PreoptimizedHeaderRW;
      }
      int v7 = (void *)(*v9 & 0xFFFFFFFFFFFFFFFCLL);
    }
    while (v7);
  }
  if (func) {
    objc_func_loadImage v10 = func;
  }
  else {
    objc_func_loadImage v10 = 0;
  }
  objc_func_loadImage v13 = v10;
  char v14 = 1;
  GlobalSmallVector<loadImageCallback,4u>::append((uint64_t)&v13, v1, v2, v3);
  int v11 = *(_DWORD *)(StatusReg + 24);
  int v12 = v11;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v12, 0, memory_order_release, memory_order_relaxed);
  if (v12 != v11) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
}

void sub_180139534(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void objc::DenseMapBase<objc::DenseMap<objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>,objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>::FatalCorruptHashTables(void *a1, uint64_t a2)
{
  size_t v4 = malloc_size(a1);
  _objc_fatal("Hash table corrupted. This is probably a memory error somewhere. (table at %p, buckets at %p (%zu bytes), %u buckets, %u entries, %u tombstones, data %p %p %p %p)", v5, v6, v7, &remappedClasses(BOOL)::remapped_class_map, a1, v4, a2, qword_1EB1CA638, HIDWORD(qword_1EB1CA638), *a1, a1[1], a1[2], a1[3]);
}

int NXPtrIsEqual(const void *info, const void *data1, const void *data2)
{
  return data1 == data2;
}

uintptr_t NXPtrHash(const void *info, const void *data)
{
  return (unint64_t)data ^ ((unint64_t)data >> 16);
}

int NXStrIsEqual(const void *info, const void *data1, const void *data2)
{
  if (data1 == data2) {
    return 1;
  }
  if (!data1)
  {
    int v3 = *(unsigned __int8 *)data2;
    return v3 == 0;
  }
  int v3 = *(unsigned __int8 *)data1;
  if (!data2) {
    return v3 == 0;
  }
  if (v3 != *(unsigned __int8 *)data2) {
    return 0;
  }
  return strcmp((const char *)data1, (const char *)data2) == 0;
}

uintptr_t NXStrHash(const void *info, const void *data)
{
  if (!data) {
    return 0;
  }
  unsigned int v2 = *(unsigned __int8 *)data;
  if (!*(unsigned char *)data) {
    return 0;
  }
  uintptr_t result = 0;
  size_t v4 = (unsigned __int8 *)data + 4;
  do
  {
    result ^= v2;
    if (!*(v4 - 3)) {
      break;
    }
    result ^= (unint64_t)*(v4 - 3) << 8;
    if (!*(v4 - 2)) {
      break;
    }
    result ^= (unint64_t)*(v4 - 2) << 16;
    if (!*(v4 - 1)) {
      break;
    }
    result ^= (unint64_t)*(v4 - 1) << 24;
    unsigned int v5 = *v4;
    v4 += 4;
    unsigned int v2 = v5;
  }
  while (v5);
  return result;
}

void NXReallyFree(const void *info, void *data)
{
}

BOOL isEqualPtrStructKey(const void *a1, void *a2, void *a3)
{
  return *a2 == *a3;
}

uint64_t hashPtrStructKey(const void *a1, void *a2)
{
  return *a2 ^ (*a2 >> 16);
}

uint64_t isEqualStrStructKey(const void *a1, const void **a2, const void **a3)
{
  return NXStrIsEqual(a1, *a2, *a3);
}

uintptr_t hashStrStructKey(const void *a1, const void **a2)
{
  return NXStrHash(a1, *a2);
}

NXHashTable *__cdecl NXCreateHashTableFromZone(NXHashTablePrototype *prototype, unsigned int capacity, const void *info, void *zone)
{
  NXHashTablePrototype v5 = *prototype;
  return NXCreateHashTable(&v5, capacity, info);
}

void NXFreeHashTable(NXHashTable *table)
{
  freeBuckets(table, 1);
  free(table->buckets);

  free(table);
}

void NXEmptyHashTable(NXHashTable *table)
{
  table->count = 0;
}

void NXResetHashTable(NXHashTable *table)
{
  table->count = 0;
}

BOOL NXCompareHashTables(NXHashTable *table1, NXHashTable *table2)
{
  if (table1 == table2)
  {
    LOBYTE(v13) = 1;
  }
  else if (table1->count == table2->count)
  {
    int v4 = 0;
    signed int nbBuckets = table1->nbBuckets;
    while (1)
    {
      buckets = (char *)table1->buckets;
      if (!v4) {
        break;
      }
LABEL_9:
      --v4;
      objc_func_loadImage v10 = &buckets[16 * nbBuckets];
      int v12 = *(_DWORD *)v10;
      int v11 = (const void **)(v10 + 8);
      if (v12 != 1) {
        int v11 = (const void **)((char *)*v11 + 8 * v4);
      }
      int v13 = NXHashMember(table2, *v11);
      if (!v13) {
        return v13;
      }
    }
    uint64_t v7 = nbBuckets;
    int v8 = &buckets[16 * nbBuckets - 16];
    while (v7)
    {
      --v7;
      int v9 = *(_DWORD *)v8;
      v8 -= 16;
      int v4 = v9;
      if (v9)
      {
        signed int nbBuckets = v7;
        goto LABEL_9;
      }
    }
    LOBYTE(v13) = 1;
  }
  else
  {
    LOBYTE(v13) = 0;
  }
  return v13;
}

int NXHashMember(NXHashTable *table, const void *data)
{
  buckets = table->buckets;
  unint64_t v5 = ((uint64_t (*)(const void *))table->prototype->hash)(table->info) % (unint64_t)table->nbBuckets;
  int v6 = buckets[4 * v5];
  if (v6)
  {
    uint64_t v7 = (char *)&buckets[4 * v5];
    if (v6 == 1)
    {
      if (*((const void **)v7 + 1) != data) {
        return ((uint64_t (*)(const void *, const void *))table->prototype->isEqual)(table->info, data) != 0;
      }
    }
    else
    {
      for (uint64_t i = (const void **)*((void *)v7 + 1);
            *i != data
         && !((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data);
            ++i)
      {
        if (!--v6) {
          return v6;
        }
      }
    }
    return 1;
  }
  return v6;
}

unsigned int NXCountHashTable(NXHashTable *table)
{
  return table->count;
}

NXHashState NXInitHashState(NXHashTable *table)
{
  return (NXHashState)table->nbBuckets;
}

int NXNextHashState(NXHashTable *table, NXHashState *state, void **data)
{
  buckets = (char *)table->buckets;
  int i = state->i;
  int j = state->j;
  if (j)
  {
LABEL_6:
    int v10 = j - 1;
    state->int j = v10;
    int v11 = &buckets[16 * i];
    int v13 = *(_DWORD *)v11;
    int v12 = (void **)(v11 + 8);
    if (v13 != 1) {
      int v12 = (void **)((char *)*v12 + 8 * v10);
    }
    *data = *v12;
    return 1;
  }
  else
  {
    uint64_t v6 = i;
    uint64_t v7 = (int *)&buckets[16 * i - 16];
    while (v6)
    {
      int v8 = v6 - 1;
      int v9 = *v7;
      v7 -= 4;
      int j = v9;
      state->int i = v6 - 1;
      state->int j = v9;
      --v6;
      if (v9)
      {
        int i = v8;
        goto LABEL_6;
      }
    }
    return 0;
  }
}

NXHashTable *__cdecl NXCopyHashTable(NXHashTable *table)
{
  signed int nbBuckets = table->nbBuckets;
  int v3 = (NXHashTable *)malloc_type_malloc(0x20uLL, 0x10E00402E54A04BuLL);
  v3->prototype = table->prototype;
  v3->unint64_t info = table->info;
  size_t v4 = table->nbBuckets;
  v3->count = 0;
  v3->signed int nbBuckets = v4;
  int v5 = 0;
  v3->buckets = malloc_type_calloc(v4, 0x10uLL, 0x10C20406D26F19BuLL);
  while (1)
  {
    buckets = (char *)table->buckets;
    if (!v5) {
      break;
    }
LABEL_7:
    --v5;
    int v10 = &buckets[16 * nbBuckets];
    int v12 = *(_DWORD *)v10;
    int v11 = (const void **)(v10 + 8);
    if (v12 != 1) {
      int v11 = (const void **)((char *)*v11 + 8 * v5);
    }
    NXHashInsert(v3, *v11);
  }
  uint64_t v7 = nbBuckets;
  int v8 = &buckets[16 * nbBuckets - 16];
  while (v7)
  {
    --v7;
    int v9 = *(_DWORD *)v8;
    v8 -= 16;
    int v5 = v9;
    if (v9)
    {
      signed int nbBuckets = v7;
      goto LABEL_7;
    }
  }
  return v3;
}

void *__cdecl NXHashInsertIfAbsent(NXHashTable *table, const void *data)
{
  buckets = table->buckets;
  unint64_t v5 = ((uint64_t (*)(const void *))table->prototype->hash)(table->info) % (unint64_t)table->nbBuckets;
  uint64_t v6 = (char *)&buckets[2 * v5];
  uint64_t v7 = v6;
  int v8 = *(_DWORD *)v6;
  if (*(_DWORD *)v6 == 1)
  {
    int v10 = (const void *)*((void *)v6 + 1);
    int v9 = (void **)(v6 + 8);
    if (v10 != data)
    {
      if (((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data))
      {
        return *v9;
      }
      else
      {
        long long v18 = malloc_type_calloc(3uLL, 8uLL, 0x80040B8603338uLL);
        long long v19 = *v9;
        v18[1] = data;
        v18[2] = v19;
        ++*v7;
        *int v9 = v18 + 1;
LABEL_16:
        unsigned int nbBuckets = table->nbBuckets;
        unsigned int v21 = table->count + 1;
        table->count = v21;
        if (v21 > nbBuckets) {
          _NXHashRehashToCapacity((uint64_t)table, (2 * nbBuckets) | 1);
        }
      }
    }
  }
  else if (v8)
  {
    int v11 = (char *)&buckets[2 * v5];
    char v14 = (void **)*((void *)v11 + 1);
    int v12 = (const void **)(v11 + 8);
    int v13 = v14;
    while (*v13 != data)
    {
      if (((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data)) {
        return *v13;
      }
      ++v13;
      if (!--v8)
      {
        long long v15 = (char *)malloc_type_calloc((*v7 + 2), 8uLL, 0x80040B8603338uLL);
        long long v16 = (const void **)(v15 + 8);
        uint64_t v17 = *v7;
        if (v17) {
          memmove(v15 + 16, *v12, 8 * v17);
        }
        *long long v16 = data;
        free((char *)*v12 - 8);
        ++*v7;
        *int v12 = v16;
        goto LABEL_16;
      }
    }
  }
  else
  {
    *(_DWORD *)uint64_t v6 = 1;
    buckets[2 * v5 + 1] = data;
    ++table->count;
  }
  return (void *)data;
}

void *__cdecl NXHashRemove(NXHashTable *table, const void *data)
{
  buckets = (char *)table->buckets;
  unint64_t v5 = ((uint64_t (*)(const void *))table->prototype->hash)(table->info) % (unint64_t)table->nbBuckets;
  uint64_t v6 = (int *)&buckets[16 * v5];
  int v7 = *v6;
  if (!*v6) {
    return 0;
  }
  if (v7 == 1)
  {
    int v8 = &buckets[16 * v5];
    int v10 = (const void *)*((void *)v8 + 1);
    int v9 = (const void **)(v8 + 8);
    if (v10 == data)
    {
      int v11 = 0;
      goto LABEL_16;
    }
    if (((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data))
    {
      data = *v9;
      int v11 = *v6 - 1;
LABEL_16:
      --table->count;
      *uint64_t v6 = v11;
      *int v9 = 0;
      return (void *)data;
    }
    return 0;
  }
  int v12 = &buckets[16 * v5];
  long long v15 = (const void **)*((void *)v12 + 1);
  char v14 = (const void **)(v12 + 8);
  int v13 = v15;
  if (v7 == 2)
  {
    if (*v13 == data
      || ((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data))
    {
      long long v16 = v13 + 1;
      uint64_t v17 = v13;
      goto LABEL_10;
    }
    uint64_t v17 = v13 + 1;
    if (v13[1] == data)
    {
      long long v16 = v13;
      goto LABEL_10;
    }
    int v25 = ((uint64_t (*)(const void *, const void *))table->prototype->isEqual)(table->info, data);
    long long v16 = v13;
    if (v25)
    {
LABEL_10:
      *char v14 = *v16;
      data = *v17;
      free(v13 - 1);
      --table->count;
      --*v6;
      return (void *)data;
    }
    return 0;
  }
  while (1)
  {
    int v18 = v7 - 1;
    if (*v13 == data) {
      break;
    }
    if (((unsigned int (*)(const void *, const void *))table->prototype->isEqual)(table->info, data))
    {
      data = *v13;
      break;
    }
    ++v13;
    --v7;
    if (!v18) {
      return 0;
    }
  }
  size_t v19 = *v6;
  if (v19 == 1)
  {
    long long v20 = 0;
    int v21 = 1;
  }
  else
  {
    long long v20 = (char *)malloc_type_calloc(v19, 8uLL, 0x80040B8603338uLL) + 8;
    int v21 = *v6;
  }
  long long v22 = (char *)*v14;
  unsigned int v23 = v21 - v7;
  if (v23)
  {
    memmove(v20, v22, 8 * v23);
    long long v22 = (char *)*v14;
  }
  if (v7 != 1)
  {
    memmove(&v20[8 * *v6 - 8 + -8 * (v7 - 1)], &v22[8 * *v6 + -8 * (v7 - 1)], 8 * (v7 - 1));
    long long v22 = (char *)*v14;
  }
  free(v22 - 8);
  --table->count;
  --*v6;
  *char v14 = v20;
  return (void *)data;
}

BOOL _mapPtrIsEqual(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a2 == a3;
}

_DWORD *NXCreateMapTableFromZone(uint64_t a1, unsigned int a2)
{
  v3[0] = *(void *)a1;
  v3[1] = *(void *)(a1 + 8);
  v3[2] = *(void *)(a1 + 16);
  int v4 = *(_DWORD *)(a1 + 24);
  return NXCreateMapTable(v3, a2);
}

void NXFreeMapTable(void *a1)
{
  NXResetMapTable((uint64_t)a1);
  free((void *)(a1[2] - 16));

  free(a1);
}

uint64_t NXResetMapTable(uint64_t result)
{
  uint64_t v1 = result;
  if (*(void *)result) {
    uint64_t v2 = *(void *)result;
  }
  else {
    uint64_t v2 = 0;
  }
  if (*(void *)(v2 + 16)) {
    int v3 = *(uint64_t (**)(uint64_t, uint64_t, void))(v2 + 16);
  }
  else {
    int v3 = 0;
  }
  int v4 = *(_DWORD *)(result + 12);
  if (v4 != -1)
  {
    int v5 = v4 + 1;
    uint64_t v6 = (void *)(*(void *)(result + 16) + 8);
    do
    {
      uint64_t v7 = *(v6 - 1);
      if (v7 != -1)
      {
        uintptr_t result = v3(v1, v7, *v6);
        *(v6 - freeBuckets(table, 1) = -1;
        *uint64_t v6 = 0;
      }
      v6 += 2;
      --v5;
    }
    while (v5);
  }
  *(_DWORD *)(v1 + 8) = 0;
  return result;
}

uint64_t NXCompareMapTables(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  int v4 = *(_DWORD *)(a1 + 12) + 1;
LABEL_4:
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t *)(*(void *)(a1 + 16) + 16 * v4 - 16);
  while (1)
  {
    BOOL v7 = v5 == 0;
    if (!v5) {
      return v7;
    }
    --v5;
    uint64_t v9 = *v6;
    v6 -= 2;
    uint64_t v8 = v9;
    if (v9 != -1)
    {
      unsigned int v10 = (**(uint64_t (***)(uint64_t, uint64_t))a2)(a2, v8);
      uint64_t v11 = _NXMapMemberWithHash((uint64_t *)a2, v8, v10, &v13);
      int v4 = v5;
      if (v11 != -1) {
        goto LABEL_4;
      }
      return v7;
    }
  }
}

uint64_t NXInitMapState(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 12) + 1);
}

uint64_t NXNextMapState(uint64_t a1, int *a2, void *a3, void *a4)
{
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *a2;
  uint64_t v6 = (uint64_t *)(v4 + 16 * v5 - 16);
  while (v5)
  {
    --v5;
    uint64_t v8 = *v6;
    v6 -= 2;
    uint64_t v7 = v8;
    if (v8 != -1)
    {
      *a2 = v5;
      *a3 = v7;
      *a4 = *(void *)(v4 + 16 * v5 + 8);
      return 1;
    }
  }
  uint64_t result = 0;
  *a2 = -1;
  return result;
}

uint64_t NXMapMember(uint64_t *a1, uint64_t a2, void *a3)
{
  unsigned int v6 = (*(uint64_t (**)(uint64_t *))*a1)(a1);

  return _NXMapMemberWithHash(a1, a2, v6, a3);
}

uint64_t NXCountMapTable(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t NXMapGetWithHash(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4 = 0;
  if (_NXMapMemberWithHash(a1, a2, a3, &v4) == -1) {
    return 0;
  }
  else {
    return v4;
  }
}

uint64_t NXMapRemove(uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(_DWORD *)(a1 + 12) & (**(unsigned int (***)(uint64_t))a1)(a1);
  uint64_t v6 = *(void *)(v4 + 16 * v5);
  if (v6 == -1) {
    return 0;
  }
  if (v6 == a2 || (!*(void *)a1 ? (uint64_t v7 = 0) : (uint64_t v7 = *(unsigned int (***)(void))a1), v7[1](a1)))
  {
    uint64_t v8 = *(void *)(v4 + 16 * v5 + 8);
    int v9 = 1;
  }
  else
  {
    int v9 = 0;
    uint64_t v8 = 0;
  }
  unsigned int v10 = *(_DWORD *)(a1 + 12) & (v5 + 1);
  unsigned int v11 = 1;
  while (v10 != v5)
  {
    uint64_t v12 = *(void *)(v4 + 16 * v10);
    if (v12 == -1) {
      break;
    }
    uint64_t v13 = v10;
    if (v12 == a2 || (!*(void *)a1 ? (char v14 = 0) : (char v14 = *(unsigned int (***)(void))a1), v14[1](a1)))
    {
      ++v9;
      uint64_t v8 = *(void *)(v4 + 16 * v13 + 8);
    }
    ++v11;
    unsigned int v10 = *(_DWORD *)(a1 + 12) & (v13 + 1);
  }
  if (!v9) {
    return 0;
  }
  if (v9 != 1) {
    _objc_inform("**** NXMapRemove: incorrect table\n");
  }
  if (v11 < 0x11)
  {
    long long v15 = &v27;
    if (!v11)
    {
      int v17 = 0;
      goto LABEL_35;
    }
  }
  else
  {
    long long v15 = (char *)malloc_type_malloc(16 * (v11 - 1), 0xC0040D1025EB5uLL);
  }
  int v17 = 0;
  unsigned int v18 = v11;
  do
  {
    size_t v19 = (_OWORD *)(v4 + 16 * v5);
    if (*(void *)v19 != a2)
    {
      uint64_t v20 = *(void *)a1 ? *(void *)a1 : 0;
      if (!(*(unsigned int (**)(uint64_t))(v20 + 8))(a1)) {
        *(_OWORD *)&v15[16 * v17++] = *v19;
      }
    }
    *(void *)size_t v19 = -1;
    *(void *)(v4 + 16 * v5 + 8) = 0;
    LODWORD(v5) = *(_DWORD *)(a1 + 12) & (v5 + 1);
    --v18;
  }
  while (v18);
LABEL_35:
  *(_DWORD *)(a1 + 8) -= v11;
  if (v17 == v11 - 1)
  {
    if (!v17) {
      goto LABEL_39;
    }
  }
  else
  {
    _objc_inform("**** NXMapRemove: bug\n");
    if (!v17) {
      goto LABEL_39;
    }
  }
  unsigned int v21 = v17 - 1;
  do
  {
    uint64_t v22 = v21;
    unsigned int v23 = (uint64_t *)&v15[16 * v21];
    uint64_t v24 = *v23;
    uint64_t v25 = v23[1];
    unsigned int v26 = (**(uint64_t (***)(uint64_t, uint64_t))a1)(a1, *v23);
    NXMapInsertWithHash(a1, v24, v26, v25);
    --v21;
  }
  while (v22);
LABEL_39:
  if (v11 >= 0x11) {
    free(v15);
  }
  return v8;
}

uint64_t objc_cache_buckets(void *a1)
{
  return *a1 & 0xFFFFFFFFFFFLL;
}

uint64_t objc_cache_preoptCache(void *a1)
{
  return (*a1 & 0x7FFFFFFFFFFFFELL) - 16;
}

BOOL objc_cache_isConstantOptimizedCache(uint64_t *a1, char a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  BOOL result = *a1 & 1;
  if ((v4 & 1) == 0 && (a2 & 1) == 0)
  {
    unint64_t v6 = HIWORD(*a1);
    return v4 != a3 && v6 == 0;
  }
  return result;
}

uint64_t objc_cache_preoptCapacity(void *a1)
{
  return (*(unsigned __int16 *)((*a1 & 0x7FFFFFFFFFFFFELL) - 8) >> 5) + 1;
}

uint64_t objc_cache_preoptFallbackClass(void *a1)
{
  return (uint64_t)a1 + *(void *)((*a1 & 0x7FFFFFFFFFFFFELL) - 16) - 16;
}

uint64_t objc_cache_bytesForCapacity(unsigned int a1)
{
  return 16 * a1;
}

uint64_t objc_cache_occupied(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 12);
}

uint64_t objc_cache_capacity(void *a1)
{
  if (HIWORD(*a1)) {
    return HIWORD(*a1) + 1;
  }
  else {
    return 0;
  }
}

void object_setIvar(id obj, Ivar ivar, id value)
{
  if ((uint64_t)obj >= 1 && ivar)
  {
    v9[3] = v3;
    char v9[4] = v4;
    v9[0] = 0;
    int v8 = 0;
    _class_lookUpIvar(*(void *)obj & 0xFFFFFFFF8, (char *)ivar, v9, &v8);
    uint64_t v7 = (id *)((char *)obj + v9[0]);
    switch(v8)
    {
      case 0:
      case 3:
        *uint64_t v7 = value;
        break;
      case 1:
        objc_storeStrong(v7, value);
        break;
      case 2:
        objc_storeWeak(v7, value);
        break;
      default:
        return;
    }
  }
}

void object_setIvarWithStrongDefault(id obj, Ivar ivar, id value)
{
  if ((uint64_t)obj >= 1 && ivar)
  {
    v9[3] = v3;
    char v9[4] = v4;
    v9[0] = 0;
    unsigned int v8 = 0;
    _class_lookUpIvar(*(void *)obj & 0xFFFFFFFF8, (char *)ivar, v9, (int *)&v8);
    uint64_t v7 = (id *)((char *)obj + v9[0]);
    if (v8 < 2)
    {
      objc_storeStrong(v7, value);
    }
    else if (v8 == 3)
    {
      *uint64_t v7 = value;
    }
    else if (v8 == 2)
    {
      objc_storeWeak(v7, value);
    }
  }
}

Ivar object_setInstanceVariable(id obj, const char *name, void *value)
{
  Variable = 0;
  if ((uint64_t)obj >= 1)
  {
    if (name)
    {
      Variable = (char *)_class_getVariable((objc_class *)(*(void *)obj & 0xFFFFFFFF8), (char *)name);
      if (Variable)
      {
        uint64_t v9 = 0;
        int v8 = 0;
        _class_lookUpIvar(*(void *)obj & 0xFFFFFFFF8, Variable, &v9, &v8);
        unint64_t v6 = (id *)((char *)obj + v9);
        switch(v8)
        {
          case 0:
          case 3:
            *unint64_t v6 = value;
            break;
          case 1:
            objc_storeStrong(v6, value);
            break;
          case 2:
            objc_storeWeak(v6, value);
            break;
          default:
            return (Ivar)Variable;
        }
      }
    }
  }
  return (Ivar)Variable;
}

Ivar object_getInstanceVariable(id obj, const char *name, void **outValue)
{
  if ((uint64_t)obj < 1) {
    goto LABEL_8;
  }
  if (!name) {
    goto LABEL_8;
  }
  uint64_t v5 = (objc_class *)(*(void *)obj & 0xFFFFFFFF8);
  if (!v5) {
    goto LABEL_8;
  }
  Variable = (objc_ivar *)_class_getVariable(v5, (char *)name);
  uint64_t v7 = Variable;
  if (outValue && Variable)
  {
    id Ivar = object_getIvar(obj, Variable);
LABEL_9:
    *outValue = Ivar;
    return v7;
  }
  if (!Variable)
  {
LABEL_8:
    id Ivar = 0;
    uint64_t v7 = 0;
    if (outValue) {
      goto LABEL_9;
    }
  }
  return v7;
}

Ivar class_getClassVariable(Class cls, const char *name)
{
  if (cls && name && (uint64_t v2 = (objc_class *)(*(void *)cls & 0xFFFFFFFF8)) != 0) {
    return (Ivar)_class_getVariable(v2, (char *)name);
  }
  else {
    return 0;
  }
}

BOOL class_respondsToMethod(Class cls, SEL sel)
{
  if ((class_respondsToMethod::warned & 1) == 0)
  {
    class_respondsToMethod::warned = 1;
    _objc_inform_deprecated("class_respondsToMethod", sel);
  }

  return class_respondsToSelector_inst(0, (objc_selector *)sel, cls);
}

IMP class_lookupMethod(Class cls, SEL sel)
{
  if (class_lookupMethod::warned)
  {
    if (sel) {
      goto LABEL_3;
    }
LABEL_17:
    __objc_error((objc_object *)cls, sel, v2);
  }
  class_lookupMethod::warned = 1;
  _objc_inform_deprecated("class_lookupMethod", sel);
  if (!sel) {
    goto LABEL_17;
  }
LABEL_3:
  if (!cls) {
    return 0;
  }
  int v5 = *(_DWORD *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8);
  if ((v5 & 1) == 0) {
    int v5 = *(_DWORD *)(*(void *)((*(void *)cls & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  }
  if ((v5 & 0x20000000) != 0
    && ((IMP result = (IMP)cache_getImp((uint64_t)cls, (unint64_t)sel, 0)) != 0
     || (*((void *)cls + 2) & 1) != 0
     && (IMP result = (IMP)cache_getImp((uint64_t)cls + *(void *)((*((void *)cls + 2) & 0x7FFFFFFFFFFFFELL) - 16), (unint64_t)sel, 0)) != 0))
  {
    if (result == _objc_msgForward_impcache) {
      IMP result = 0;
    }
  }
  else
  {
    IMP result = lookUpImpOrForward(0, (objc_selector *)sel, cls, 7u);
  }
  if (!result) {
    return _objc_msgForward;
  }
  return result;
}

char *copyPropertyAttributeString(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = a2;
    int v5 = (const char **)(a1 + 8);
    uint64_t v6 = a2;
    do
    {
      if (*v5)
      {
        size_t v7 = strlen(*(v5 - 1));
        if (v7 <= 1) {
          size_t v8 = v7;
        }
        else {
          size_t v8 = v7 + 2;
        }
        v3 += strlen(*v5) + v8 + 1;
      }
      v5 += 2;
      --v6;
    }
    while (v6);
    uint64_t v9 = (char *)malloc_type_malloc(v3 + 1, 0x7CD87uLL);
    unsigned int v10 = &v9[v3 + 1];
    unsigned int v11 = (void *)(a1 + 8);
    unsigned int v18 = v9;
    uint64_t v12 = v9;
    do
    {
      if (*v11)
      {
        if (strlen((const char *)*(v11 - 1)) <= 1) {
          int v13 = snprintf(v12, v10 - v12, "%s%s,");
        }
        else {
          int v13 = snprintf(v12, v10 - v12, "\"%s\"%s,");
        }
        if (v10 - v12 < (unint64_t)v13) {
          _objc_fatal("Incorrect buffer calculation for property string. Partial string is %s, calculated length is %zu.", v14, v15, v16, v18, v3);
        }
        v12 += v13;
      }
      v11 += 2;
      --v4;
    }
    while (v4);
    IMP result = v18;
    if (v12 > v18) {
      *(v12 - freeBuckets(table, 1) = 0;
    }
  }
  else
  {
    return strdup("");
  }
  return result;
}

void _objc_crashlog(const char *__s1)
{
  int v2 = 0;
  uint64_t v12 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(&crashlog_lock, (unsigned int *)&v2, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v2) {
    os_unfair_lock_lock_with_options();
  }
  uint64_t v4 = (void *)__crashreporter_info__;
  if (__crashreporter_info__)
  {
    size_t v5 = strlen((const char *)__crashreporter_info__);
    if (v5 < 0x1F41)
    {
      asprintf(&v12, "%s\n%s", (const char *)__crashreporter_info__, __s1);
    }
    else
    {
      uint64_t v6 = (const char *)(v5 + __crashreporter_info__ - 8001);
      do
        char v7 = *++v6;
      while ((v7 & 0xC0) == 0x80);
      asprintf(&v12, "... %s\n%s", v6, __s1);
    }
    size_t v8 = v12;
    if (!v12) {
      goto LABEL_17;
    }
  }
  else
  {
    size_t v8 = strdup(__s1);
    uint64_t v12 = v8;
    if (!v8) {
      goto LABEL_17;
    }
  }
  size_t v9 = strlen(v8) - 1;
  if (v8[v9] == 10) {
    v8[v9] = 0;
  }
  if (v4) {
    free(v4);
  }
  __crashreporter_info__ = (uint64_t)v12;
LABEL_17:
  int v10 = *(_DWORD *)(StatusReg + 24);
  int v11 = v10;
  atomic_compare_exchange_strong_explicit(&crashlog_lock, (unsigned int *)&v11, 0, memory_order_release, memory_order_relaxed);
  if (v11 != v10) {
    os_unfair_lock_unlock((os_unfair_lock_t)&crashlog_lock);
  }
}

void sub_18013B02C(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)&crashlog_lock);
  }
  _Unwind_Resume(exception_object);
}

void _objc_exception_abort1(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
}

void _objc_exception_abort2(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
}

void _objc_exception_abort3(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
}

void _objc_exception_abort4(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
}

uint64_t _objc_exception_false()
{
  return 0;
}

uint64_t _objc_default_exception_matcher(objc_class *a1, unint64_t a2)
{
  if ((a2 & 0x8000000000000000) == 0)
  {
    uint64_t v2 = *(void *)a2 & 0x7FFFFFFFFFFFF8;
    if (!v2) {
      return 0;
    }
    goto LABEL_3;
  }
  int v5 = (__objc2_class *)objc_debug_taggedpointer_classes[a2 & 7];
  if (!v5) {
    return 0;
  }
  uint64_t v3 = (objc_class *)objc_debug_taggedpointer_classes[a2 & 7];
  if (v5 == __NSUnrecognizedTaggedPointer)
  {
    uint64_t v2 = objc_debug_taggedpointer_ext_classes[(a2 >> 55)];
    if (!v2) {
      return 0;
    }
LABEL_3:
    uint64_t v3 = (objc_class *)v2;
  }
  if (!v3) {
    return 0;
  }
  while (v3 != a1)
  {
    if (!*((void *)v3 + 1)) {
      return 0;
    }
    uint64_t v3 = (objc_class *)*((void *)v3 + 1);
  }
  return 1;
}

uint64_t _objc_terminate(void)
{
  if (PrintExceptions) {
    _objc_inform("EXCEPTIONS: terminating");
  }
  if (__cxa_current_exception_type()) {
    __cxa_rethrow();
  }
  vm_address_t v0 = (uint64_t (*)(void))old_terminate;

  return v0();
}

void sub_18013B290(void *a1, int a2)
{
  uint64_t v3 = (objc_object *)objc_begin_catch(a1);
  if (a2 == 2) {
    uint64_t v3 = (objc_object *)uncaught_handler(v3);
  }
  ((void (*)(objc_object *))old_terminate)(v3);
  objc_end_catch();
}

void sub_18013B2F0(_Unwind_Exception *a1)
{
}

void __clang_call_terminate(void *a1)
{
}

void performForkChildInitialize(objc_class *a1, objc_class *a2)
{
  if (*((void *)a1 + 1))
  {
    uint64_t v4 = (objc_class *)(*(void *)a1 & 0xFFFFFFFF8);
    if (v4 != a1)
    {
      int v5 = lookUpImpOrNilTryCache(*(void *)((*(void *)v4 & 0xFFFFFFFF8) + 8), (unint64_t)sel_initialize, (void *)(**(void **)((*(void *)v4 & 0xFFFFFFFF8) + 8) & 0xFFFFFFFF8), 0);
      uint64_t v6 = lookUpImpOrNilTryCache((uint64_t)a1, (unint64_t)sel_initialize, (void *)(*(void *)a1 & 0xFFFFFFFF8), 0);
      if (v6)
      {
        if ((char *)v6 != (char *)objc_noop_imp && v6 != v5)
        {
          if (PrintInitializing)
          {
            size_t v9 = *(const void **)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
            int v10 = objc_class::nameForLogging(a1);
            _objc_inform("INITIALIZE: thread %p: refusing to call +[%s initialize] in fork() child process because it may have been in progress when fork() was called", v9, v10);
          }
          int v11 = objc_class::nameForLogging(a1);
          _objc_inform_now_and_on_crash("+[%s initialize] may have been in progress in another thread when fork() was called.", v11);
          gdb_objc_class_changed();
          uint64_t v12 = objc_class::nameForLogging(a1);
          _objc_fatal("+[%s initialize] may have been in progress in another thread when fork() was called. We cannot safely call it or ignore it in the fork() child process. Crashing instead. Set a breakpoint on objc_initializeAfterForkError to debug.", v13, v14, v15, v12);
        }
      }
    }
  }
  if (PrintInitializing)
  {
    char v7 = *(const void **)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    size_t v8 = objc_class::nameForLogging(a1);
    _objc_inform("INITIALIZE: thread %p: skipping trivial +[%s initialize] in fork() child process", v7, v8);
  }

  lockAndFinishInitializing(a1, a2);
}

void objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if (*(void *)a1) {
    uint64_t v4 = *(unint64_t **)a1;
  }
  else {
    uint64_t v4 = 0;
  }
  unsigned int v5 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
  unsigned int v6 = v5 | (v5 >> 4) | ((v5 | (v5 >> 4)) >> 8);
  int v7 = v6 | HIWORD(v6);
  if ((v7 + 1) > 4) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 4;
  }
  *(_DWORD *)(a1 + 16) = v8;
  size_t v9 = malloc_type_malloc(16 * v8, 0x64B88C75uLL);
  if (v9)
  {
    *(void *)a1 = v9;
    *(void *)(a1 + 8) = 0;
    if (v4)
    {
      int v10 = v9;
LABEL_13:
      uint64_t v12 = *(unsigned int *)(a1 + 16);
      if (v12)
      {
        uint64_t v13 = 16 * v12;
        do
        {
          *int v10 = -1;
          v10 += 2;
          v13 -= 16;
        }
        while (v13);
      }
      if (v3)
      {
        uint64_t v14 = 16 * v3;
        long long v15 = v4;
        do
        {
          unint64_t v16 = *v15;
          if (*v15 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            uint64_t v20 = 0;
            objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::LookupBucketFor<objc_class *>(a1, v16, &v20);
            int v17 = v20;
            *uint64_t v20 = *v15;
            v17[1] = v15[1];
            ++*(_DWORD *)(a1 + 8);
          }
          v15 += 2;
          v14 -= 16;
        }
        while (v14);
      }
      free(v4);
      return;
    }
    int v11 = v9;
  }
  else
  {
    int v11 = 0;
    int v10 = 0;
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    if (v4) {
      goto LABEL_13;
    }
  }
  uint64_t v18 = *(unsigned int *)(a1 + 16);
  if (v18)
  {
    uint64_t v19 = 16 * v18;
    do
    {
      *int v11 = -1;
      v11 += 2;
      v19 -= 16;
    }
    while (v19);
  }
}

void _objc_addWillInitializeClassFunc(void (*a1)(uint64_t), uint64_t a2, const char *a3, char *a4)
{
  int v6 = 0;
  unsigned int v26 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(&classInitLock, (unsigned int *)&v6, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v6) {
    os_unfair_lock_lock_with_options();
  }
  unsigned int v8 = objc_copyRealizedClassList(&v26, a2, a3, a4);
  size_t v9 = v8;
  uint64_t v10 = v26;
  if (v26)
  {
    int v11 = v8;
    do
    {
      int v12 = *(_DWORD *)(*(void *)(*v11 + 32) & 0xF00007FFFFFFFF8);
      if ((v12 & 1) == 0) {
        int v12 = *(_DWORD *)(*(void *)((*(void *)*v11 & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
      }
      if ((v12 & 0x10000000) == 0 && (v12 & 0x20000000) == 0) {
        *int v11 = 0;
      }
      ++v11;
      --v10;
    }
    while (v10);
  }
  LODWORD(v13) = willInitializeFuncs;
  if (willInitializeFuncs == 1)
  {
    uint64_t v14 = malloc_type_malloc(0x20uLL, 0x80040803F642BuLL);
    uint64_t v13 = willInitializeFuncs;
    if (willInitializeFuncs)
    {
      long long v15 = &xmmword_1E8EB82B0;
      unint64_t v16 = v14;
      uint64_t v17 = willInitializeFuncs;
      do
      {
        long long v18 = *v15++;
        *v16++ = v18;
        --v17;
      }
      while (v17);
      uint64_t v19 = v13;
    }
    else
    {
      uint64_t v19 = 0;
    }
    unsigned int v21 = (void (**)(uint64_t))&v14[v19];
    size_t *v21 = a1;
    v21[1] = (void (*)(uint64_t))a2;
    *(void *)&xmmword_1E8EB82B0 = v14;
  }
  else if (willInitializeFuncs)
  {
    *(void *)&xmmword_1E8EB82B0 = malloc_type_realloc((void *)xmmword_1E8EB82B0, 16 * (willInitializeFuncs + 1), 0x80040803F642BuLL);
    LODWORD(v13) = willInitializeFuncs;
    uint64_t v20 = (void (**)(uint64_t))(xmmword_1E8EB82B0 + 16 * willInitializeFuncs);
    *uint64_t v20 = a1;
    v20[1] = (void (*)(uint64_t))a2;
  }
  else
  {
    *(void *)&xmmword_1E8EB82B0 = a1;
    *((void *)&xmmword_1E8EB82B0 + freeBuckets(table, 1) = a2;
  }
  willInitializeFuncs = v13 + 1;
  int v22 = *(_DWORD *)(StatusReg + 24);
  int v23 = v22;
  atomic_compare_exchange_strong_explicit(&classInitLock, (unsigned int *)&v23, 0, memory_order_release, memory_order_relaxed);
  if (v23 != v22) {
    os_unfair_lock_unlock((os_unfair_lock_t)&classInitLock);
  }
  unint64_t v24 = v26;
  if (v26)
  {
    unint64_t v25 = 0;
    do
    {
      if (v9[v25])
      {
        a1(a2);
        unint64_t v24 = v26;
      }
      ++v25;
    }
    while (v25 < v24);
  }
  free(v9);
}

void sub_18013B8AC(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)&classInitLock);
  }
  _Unwind_Resume(exception_object);
}

void *objc_copyRealizedClassList_nolock(unsigned int *a1, uint64_t a2, const char *a3, char *a4)
{
  unsigned int v13 = 0;
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 3321888768;
  void v12[2] = ___ZL33objc_copyRealizedClassList_nolockPj_block_invoke;
  v12[3] = &__block_descriptor_40_e8_32c49_ZTSKZL33objc_copyRealizedClassList_nolockPjE3__0_e8_B16__0_8l;
  v12[4] = &v13;
  foreach_realized_class((uint64_t)v12, a2, a3, a4);
  if (!v13)
  {
    int v5 = 0;
    if (!a1) {
      return v5;
    }
    goto LABEL_3;
  }
  int v11 = 0;
  int v5 = malloc_type_malloc(8 * (v13 + 1), 0x80040B8603338uLL);
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3321888768;
  v10[2] = ___ZL33objc_copyRealizedClassList_nolockPj_block_invoke_38;
  v10[3] = &__block_descriptor_48_e8_32c49_ZTSKZL33objc_copyRealizedClassList_nolockPjE3__1_e8_B16__0_8l;
  v10[4] = &v11;
  v10[5] = v5;
  foreach_realized_class((uint64_t)v10, v6, v7, v8);
  v5[v11] = 0;
  if (a1) {
LABEL_3:
  }
    *a1 = v13;
  return v5;
}

uint64_t ___ZL33objc_copyRealizedClassList_nolockPj_block_invoke(uint64_t a1)
{
  return 1;
}

uint64_t foreach_realized_class(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  int v5 = *(_DWORD *)(gdb_objc_realized_classes + 8);
  if (DisablePreopt) {
    uint64_t result = 0;
  }
  else {
    uint64_t result = _dyld_objc_class_count();
  }
  uint64_t v7 = _firstRealizedClass;
  if (_firstRealizedClass)
  {
    int v8 = 16 * (result + v5) + 16;
    do
    {
      if (!--v8) {
LABEL_23:
      }
        _objc_fatal("Memory corruption in class list.", a2, a3, a4);
      uint64_t v9 = v7;
      while (1)
      {
        if ((*(_WORD *)(v9 + 30) & 4) != 0
          || (uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 16))(a1, v9), !result)
          || (uint64_t v10 = *(void *)((*(void *)(v9 + 32) & 0xF00007FFFFFFFF8) + 0x10)) == 0)
        {
          while (1)
          {
            uint64_t v10 = *(void *)((*(void *)(v9 + 32) & 0xF00007FFFFFFFF8) + 0x18);
            if (v9 == v7 || v10) {
              break;
            }
            if (*(void *)(v9 + 8)) {
              uint64_t v9 = *(void *)(v9 + 8);
            }
            else {
              uint64_t v9 = 0;
            }
            if (!--v8) {
              goto LABEL_23;
            }
          }
          if (v9 == v7) {
            break;
          }
        }
        uint64_t v9 = v10;
        if (!--v8) {
          goto LABEL_23;
        }
      }
      uint64_t v7 = *(void *)((*(void *)(v7 + 32) & 0xF00007FFFFFFFF8) + 0x18);
    }
    while (v7);
  }
  return result;
}

uint64_t ___ZL33objc_copyRealizedClassList_nolockPj_block_invoke_38(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(_DWORD **)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v4 = *v3;
  *uint64_t v3 = v4 + 1;
  *(void *)(v2 + 8 * v4) = a2;
  return 1;
}

__n128 __copy_helper_block_e8_32c49_ZTSKZL33objc_copyRealizedClassList_nolockPjE3__1(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[2];
  a1[2] = result;
  return result;
}

uint64_t __copy_helper_block_e8_32c49_ZTSKZL33objc_copyRealizedClassList_nolockPjE3__0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = *(void *)(a2 + 32);
  return result;
}

_DWORD *method_list_t::duplicate(method_list_t *this, uint64_t a2, const char *a3, char *a4)
{
  unint64_t v5 = *(unsigned int *)this;
  uint64_t v57 = (unsigned __int16)v5 & 0xFFFC;
  uint64_t v6 = v5 >> 31;
  if ((uint64_t)this < 0) {
    uint64_t v6 = 2;
  }
  unint64_t v58 = v6 | ((unint64_t)this + 8) & 0xFFFFFFFFFFFFFFFCLL;
  entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::signedEnd((uint64_t)&v55, (unsigned int *)this, a3, a4);
  if (*(int *)this > -1 || (uint64_t)this < 0) {
    uint64_t v10 = *(_DWORD *)this & 0xFFFF0003;
  }
  else {
    uint64_t v10 = 0;
  }
  MethodList = method_list_t::allocateMethodList((method_list_t *)*((unsigned int *)this + 1), v10, v7, v8);
  if (v58) {
    unint64_t v13 = v58;
  }
  else {
    unint64_t v13 = 0;
  }
  if (v56) {
    uint64_t v14 = v56;
  }
  else {
    uint64_t v14 = 0;
  }
  unint64_t v15 = *MethodList;
  uint64_t v61 = v57;
  unint64_t v62 = v13;
  uint64_t v59 = v55;
  uint64_t v60 = v14;
  uint64_t v65 = v57;
  unint64_t v66 = v13;
  uint64_t v63 = v55;
  uint64_t v16 = v15 >> 31;
  if ((uint64_t)MethodList < 0) {
    uint64_t v16 = 2;
  }
  uint64_t v64 = v14;
  uint64_t v69 = v57;
  unint64_t v70 = v13;
  uint64_t v67 = v55;
  uint64_t v68 = v14;
  uint64_t v74 = v57;
  unint64_t v75 = v13;
  uint64_t v72 = v55;
  if (v14) {
    uint64_t v17 = v14;
  }
  else {
    uint64_t v17 = 0;
  }
  uint64_t v73 = v17;
  uint64_t v82 = v57;
  if (v13) {
    unint64_t v18 = v13;
  }
  else {
    unint64_t v18 = 0;
  }
  unint64_t v83 = v18;
  uint64_t v80 = v55;
  if (v17) {
    uint64_t v19 = v17;
  }
  else {
    uint64_t v19 = 0;
  }
  uint64_t v81 = v19;
  if (!v18) {
    unint64_t v18 = 0;
  }
  unint64_t v71 = v18;
  if (!v19) {
    uint64_t v19 = 0;
  }
  uint64_t v84 = v19;
  uint64_t v76 = v57;
  unint64_t v77 = v18;
  uint64_t v78 = v55;
  uint64_t v20 = (const char *)&v79;
  if (v19) {
    uint64_t v21 = v19;
  }
  else {
    uint64_t v21 = 0;
  }
  uint64_t v22 = (uint64_t)(MethodList + 2);
  uint64_t v79 = v21;
  uint64_t v82 = v57;
  unsigned int v54 = MethodList;
  if (v18) {
    unint64_t v23 = v18;
  }
  else {
    unint64_t v23 = 0;
  }
  unint64_t v83 = v23;
  uint64_t v80 = v55;
  if (v21) {
    uint64_t v24 = v21;
  }
  else {
    uint64_t v24 = 0;
  }
  uint64_t v25 = 0;
  unint64_t v26 = v16 | v22 & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v81 = v24;
  uint64_t v27 = (unsigned __int16)v15 & 0xFFFC;
  unint64_t v28 = dataSegmentsRanges;
  unint64_t v29 = *(void *)algn_1EB1CB078;
  if (!v23) {
    goto LABEL_41;
  }
LABEL_40:
  for (unint64_t i = v23; i != v81; unint64_t i = 0)
  {
    unint64_t v31 = v23;
    uint64_t v32 = v23;
    uint64_t v33 = v26 + v25;
    int v34 = (v26 + v25) & 3;
    if (v34)
    {
      if (v34 == 2)
      {
        long long v39 = (void *)(v33 & 0xFFFFFFFFFFFFFFFCLL);
        long long v40 = (unint64_t *)((v33 & 0xFFFFFFFFFFFFFFFCLL) + 16);
        unint64_t v41 = method_t::imp(v31, 0);
        if (v41)
        {
          unint64_t v43 = v41;
          unint64_t v42 = (char *)v41;
        }
        else
        {
          unint64_t v43 = 0;
        }
        *long long v40 = v43;
        int v47 = v32 & 3;
        if ((v32 & 3) != 0)
        {
          if (v47 == 2)
          {
            if (*(void *)(v32 & 0xFFFFFFFFFFFFFFFCLL)) {
              unint64_t v42 = *(char **)(v32 & 0xFFFFFFFFFFFFFFFCLL);
            }
            else {
              unint64_t v42 = 0;
            }
          }
          else if (v47 == 1)
          {
            unint64_t v48 = v32 & 0xFFFFFFFFFFFFFFFCLL;
            uint64_t v49 = *(int *)(v32 & 0xFFFFFFFFFFFFFFFCLL);
            if (v28 > (v32 & 0xFFFFFFFFFFFFFFFCLL) || v29 <= v48) {
              unint64_t v42 = *(char **)(v48 + v49);
            }
            else {
              unint64_t v42 = (char *)&unk_1F62995A8 + v49;
            }
          }
        }
        else
        {
          unint64_t v42 = *(char **)(v32 & 0xFFFFFFFFFFFFFFFCLL);
        }
        *long long v39 = v42;
        unint64_t v50 = v39 + 1;
        uint64_t v51 = method_t::types(v32);
        if (v51) {
          uint64_t v52 = v51;
        }
        else {
          uint64_t v52 = 0;
        }
        *unint64_t v50 = v52;
      }
      else if (v34 == 1)
      {
        _objc_fatal("Cannot assign to small method %p from method %p", v22, v20, v12, v26 + v25, v31);
      }
    }
    else
    {
      long long v35 = (void *)(v33 & 0xFFFFFFFFFFFFFFFCLL);
      long long v36 = (void *)((v33 & 0xFFFFFFFFFFFFFFFCLL) + 16);
      unint64_t v37 = method_t::imp(v31, 0);
      if (v37) {
        long long v38 = (char *)v37;
      }
      else {
        long long v38 = 0;
      }
      void *v36 = v38;
      int v44 = v32 & 3;
      if ((v32 & 3) != 0)
      {
        if (v44 == 2)
        {
          long long v38 = *(char **)(v32 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else if (v44 == 1)
        {
          unint64_t v45 = v32 & 0xFFFFFFFFFFFFFFFCLL;
          uint64_t v46 = *(int *)(v32 & 0xFFFFFFFFFFFFFFFCLL);
          if (v28 > (v32 & 0xFFFFFFFFFFFFFFFCLL) || v29 <= v45) {
            long long v38 = *(char **)(v45 + v46);
          }
          else {
            long long v38 = (char *)&unk_1F62995A8 + v46;
          }
        }
      }
      else
      {
        long long v38 = *(char **)(v32 & 0xFFFFFFFFFFFFFFFCLL);
      }
      void *v35 = v38;
      v35[1] = method_t::types(v32);
    }
    if (v83) {
      unint64_t v23 = v83 + v82;
    }
    else {
      unint64_t v23 = 0;
    }
    unint64_t v83 = v23;
    ++HIDWORD(v82);
    v25 += v27;
    if (v23) {
      goto LABEL_40;
    }
LABEL_41:
    ;
  }
  return v54;
}

uint64_t objc_loadClassref(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(unint64_t, void))((result & 0xFFFFFFFFFFFFFFFELL) + 8))(result & 0xFFFFFFFFFFFFFFFELL, 0);
    *a1 = result;
  }
  return result;
}

void objc::DenseMap<objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>::grow(int a1)
{
  uint64_t v1 = dword_1EB1CA640;
  if (remappedClasses(BOOL)::remapped_class_map) {
    uint64_t v2 = (unint64_t *)remappedClasses(BOOL)::remapped_class_map;
  }
  else {
    uint64_t v2 = 0;
  }
  unsigned int v3 = (a1 - 1) | ((a1 - 1) >> 1) | (((a1 - 1) | ((a1 - 1) >> 1)) >> 2);
  unsigned int v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
  int v5 = v4 | HIWORD(v4);
  if ((v5 + 1) > 4) {
    unsigned int v6 = v5 + 1;
  }
  else {
    unsigned int v6 = 4;
  }
  dword_1EB1CA640 = v6;
  uint64_t v7 = malloc_type_malloc(16 * v6, 0x64B88C75uLL);
  if (v7)
  {
    remappedClasses(BOOL)::remapped_class_map = (uint64_t)v7;
    qword_1EB1CA638 = 0;
    if (v2)
    {
      int v8 = v7;
LABEL_13:
      if (dword_1EB1CA640)
      {
        uint64_t v10 = 16 * dword_1EB1CA640;
        do
        {
          *int v8 = -1;
          v8 += 2;
          v10 -= 16;
        }
        while (v10);
      }
      if (v1)
      {
        uint64_t v11 = 16 * v1;
        int v12 = v2;
        do
        {
          unint64_t v13 = *v12;
          if (*v12 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            uint64_t v16 = 0;
            objc::DenseMapBase<objc::DenseMap<objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>,objc_class *,objc_class *,objc::DenseMapValueInfo<objc_class *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc_class *>>::LookupBucketFor<objc_class *>(v13, &v16);
            uint64_t v14 = v16;
            *uint64_t v16 = *v12;
            v14[1] = v12[1];
            LODWORD(qword_1EB1CA638) = qword_1EB1CA638 + 1;
          }
          v12 += 2;
          v11 -= 16;
        }
        while (v11);
      }
      free(v2);
      return;
    }
    uint64_t v9 = v7;
  }
  else
  {
    uint64_t v9 = 0;
    int v8 = 0;
    remappedClasses(BOOL)::remapped_class_map = 0;
    qword_1EB1CA638 = 0;
    if (v2) {
      goto LABEL_13;
    }
  }
  if (dword_1EB1CA640)
  {
    uint64_t v15 = 16 * dword_1EB1CA640;
    do
    {
      *uint64_t v9 = -1;
      v9 += 2;
      v15 -= 16;
    }
    while (v15);
  }
}

unint64_t method_t::impRaw(unint64_t this)
{
  unint64_t v1 = this;
  int v2 = this & 3;
  if ((this & 3) == 0 || v2 == 2)
  {
    if (*(void *)((this & 0xFFFFFFFFFFFFFFFCLL) + 16)) {
      return *(void *)((this & 0xFFFFFFFFFFFFFFFCLL) + 16);
    }
    else {
      return 0;
    }
  }
  else if (v2 == 1)
  {
    this = method_t_remappedImp_nolock((const method_t *)this);
    if (!this) {
      return *(int *)((v1 & 0xFFFFFFFFFFFFFFFCLL) + 8) + (v1 & 0xFFFFFFFFFFFFFFFCLL) + 8;
    }
  }
  return this;
}

uint64_t list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::begin(uint64_t a1, unint64_t *a2, const char *a3, char *a4)
{
  int v34 = a2;
  unint64_t v4 = *a2;
  if (!*a2) {
    goto LABEL_13;
  }
  unint64_t v5 = *a2;
  uint64_t v6 = *a2 & 3;
  if ((v4 & 3) == 0)
  {
    if ((v4 & 0xFFFFFFFFFFFFFFFCLL) != 0)
    {
      unint64_t v35 = v4 & 0xFFFFFFFFFFFFFFFCLL;
      goto LABEL_12;
    }
LABEL_13:
    unint64_t v35 = 0;
    goto LABEL_14;
  }
  if (v4 <= 3) {
    goto LABEL_13;
  }
  if (v6 != 2)
  {
    BOOL v8 = v6 == 1;
    unint64_t v7 = v4 & 0xFFFFFFFFFFFFFFFCLL;
    BOOL v8 = !v8 || v7 == 0;
    if (!v8) {
      unint64_t v35 = v7 + 8;
    }
    goto LABEL_12;
  }
  uint64_t v16 = (unsigned int *)(v4 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v4 & 0xFFFFFFFFFFFFFFFCLL) == 0)
  {
LABEL_12:
    long long v30 = a2;
    goto LABEL_15;
  }
  if (DisablePreattachedCategories)
  {
    unint64_t v20 = *v16;
    uint64_t v24 = v16[1];
    unint64_t v25 = v24 * (unint64_t)v20;
    if ((v25 & 0xFFFFFFFF00000000) != 0) {
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v24, v5 & 0xFFFFFFFFFFFFFFFCLL, v20);
    }
    unint64_t v26 = v20 | (v24 << 32);
    uint64_t v27 = (uint64_t)v16 + v25 + 8;
    unint64_t v28 = v20 | ((unint64_t)(v24 - 1) << 32);
    BOOL v29 = v24 == 0;
    if (v24) {
      uint64_t v18 = v24;
    }
    else {
      uint64_t v18 = 0;
    }
    if (v24) {
      uint64_t v17 = (unsigned __int16 *)(v27 - v20);
    }
    else {
      uint64_t v17 = (unsigned __int16 *)v27;
    }
    if (v29) {
      unint64_t v19 = v26;
    }
    else {
      unint64_t v19 = v28;
    }
  }
  else
  {
    uint64_t v17 = (unsigned __int16 *)(v16 + 2);
    unint64_t v19 = *v16;
    uint64_t v18 = v16[1];
    unint64_t v20 = v19;
  }
  unint64_t v21 = v18 * (unint64_t)v20;
  if ((v21 & 0xFFFFFFFF00000000) != 0) {
    _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v18, v5 & 0xFFFFFFFFFFFFFFFCLL, v20);
  }
  unint64_t v22 = HIDWORD(v19);
  for (unint64_t i = (unint64_t)v16 + v21 + 8; (unint64_t)v17 < i; v22 = (v22 + 1))
  {
    if (*(void *)(objc_debug_headerInfoRWs + 8 * *v17 + 8)) {
      break;
    }
    uint64_t v17 = (unsigned __int16 *)((char *)v17 + v19);
  }
  unint64_t v35 = v5 & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v36 = v19 | (v22 << 32);
  unint64_t v37 = v17;
LABEL_14:
  long long v30 = a2;
  if (!v4)
  {
LABEL_18:
    unint64_t v31 = 0;
    return list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v34, &v30);
  }
LABEL_15:
  unint64_t v9 = v4;
  unint64_t v10 = v4 & 3;
  if ((v9 & 3) == 2)
  {
    uint64_t v11 = (unsigned int *)(v9 & 0xFFFFFFFFFFFFFFFCLL);
    if ((v9 & 0xFFFFFFFFFFFFFFFCLL) != 0)
    {
      uint64_t v13 = *v11;
      uint64_t v12 = v11[1];
      unint64_t v14 = v12 * (unint64_t)v13;
      if ((v14 & 0xFFFFFFFF00000000) != 0) {
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v12, v9 & 0xFFFFFFFFFFFFFFFCLL, v13);
      }
      unint64_t v31 = v9 & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v32 = v13 | (v12 << 32);
      uint64_t v33 = (uint64_t)v11 + v14 + 8;
    }
  }
  else if (v10 == 1)
  {
    if ((v9 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
      unint64_t v31 = (v9 & 0xFFFFFFFFFFFFFFFCLL) + 8 * *(unsigned int *)(v9 & 0xFFFFFFFFFFFFFFFCLL) + 8;
    }
  }
  else if (!v10)
  {
    goto LABEL_18;
  }
  return list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)&v34, &v30);
}

uint64_t list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::end(uint64_t a1, void *a2, const char *a3, char *a4)
{
  uint64_t v13 = a2;
  uint64_t v5 = *a2;
  if (!*a2) {
    goto LABEL_5;
  }
  if ((*a2 & 3) == 2)
  {
    unint64_t v7 = (unsigned int *)(v5 & 0xFFFFFFFFFFFFFFFCLL);
    if ((v5 & 0xFFFFFFFFFFFFFFFCLL) != 0)
    {
      uint64_t v9 = *v7;
      uint64_t v8 = v7[1];
      unint64_t v10 = v8 * (unint64_t)v9;
      if ((v10 & 0xFFFFFFFF00000000) != 0) {
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", (uint64_t)a2, a3, a4, v8, v5 & 0xFFFFFFFFFFFFFFFCLL, v9);
      }
      unint64_t v14 = v5 & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v15 = v9 | (v8 << 32);
      uint64_t v16 = (uint64_t)v7 + v10 + 8;
    }
  }
  else if ((*a2 & 3) == 1)
  {
    if ((v5 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
      unint64_t v14 = (v5 & 0xFFFFFFFFFFFFFFFCLL) + 8 * *(unsigned int *)(v5 & 0xFFFFFFFFFFFFFFFCLL) + 8;
    }
  }
  else if ((v5 & 3) == 0)
  {
LABEL_5:
    unint64_t v14 = 0;
  }
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::ListIterator::ListIterator((uint64_t)v12, (uint64_t)&v13);
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::ListIterator::ListIterator((uint64_t)v11, (uint64_t)&v13);
  return list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::iteratorImpl(a1, (uint64_t)v12, v11);
}

uint64_t list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator==(uint64_t a1, void *a2)
{
  int v2 = *(uint64_t **)a1;
  if (*(void *)a1 != *a2) {
    return 0;
  }
  uint64_t v4 = *v2;
  if (!*v2) {
    goto LABEL_7;
  }
  if ((*v2 & 3) == 2)
  {
    uint64_t v6 = *(void *)(a1 + 24);
    uint64_t v7 = a2[3];
    goto LABEL_14;
  }
  if ((*v2 & 3) == 1)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v7 = a2[1];
LABEL_14:
    if (v6 == v7) {
      goto LABEL_15;
    }
    return 0;
  }
  if ((v4 & 3) != 0) {
    return 0;
  }
LABEL_7:
  if (*(void *)(a1 + 8)) {
    uint64_t v5 = *(void *)(a1 + 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (v5 != a2[1]) {
    return 0;
  }
LABEL_15:
  if (v2 != *(uint64_t **)(a1 + 32)) {
    return *(void *)(a1 + 72) == a2[9];
  }
  if (!v4) {
    goto LABEL_21;
  }
  uint64_t v8 = *v2 & 3;
  if (v8 == 2)
  {
    uint64_t v10 = *(void *)(a1 + 24);
    uint64_t v11 = *(void *)(a1 + 56);
  }
  else
  {
    if (v8 != 1)
    {
      if (v8) {
        return *(void *)(a1 + 72) == a2[9];
      }
LABEL_21:
      if (*(void *)(a1 + 8)) {
        uint64_t v9 = *(void *)(a1 + 8);
      }
      else {
        uint64_t v9 = 0;
      }
      if (v9 != *(void *)(a1 + 40)) {
        return *(void *)(a1 + 72) == a2[9];
      }
      return 1;
    }
    uint64_t v10 = *(void *)(a1 + 8);
    uint64_t v11 = *(void *)(a1 + 40);
  }
  if (v10 != v11) {
    return *(void *)(a1 + 72) == a2[9];
  }
  return 1;
}

uint64_t **list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator++(uint64_t **a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v5 = a1[8];
  uint64_t v6 = (uint64_t *)((char *)a1[9] + v5);
  a1[9] = v6;
  *((_DWORD *)a1 + 17) = HIDWORD(v5) + 1;
  if (v6 != a1[11]) {
    return a1;
  }
  uint64_t v7 = *a1;
  uint64_t v8 = **a1;
  if (!v8)
  {
    a1[1] = 0;
    goto LABEL_14;
  }
  if ((**a1 & 3) == 1)
  {
    ++a1[1];
    uint64_t v8 = *v7;
    if (!*v7) {
      goto LABEL_14;
    }
  }
  else if ((v8 & 3) == 0)
  {
    a1[1] = 0;
  }
  if ((v8 & 3) == 2)
  {
    uint64_t v9 = a1[3];
    uint64_t v10 = *((unsigned int *)a1 + 4);
    int v11 = *((_DWORD *)a1 + 5);
    a1[3] = (uint64_t *)((char *)v9 + v10);
    uint64_t v12 = (unsigned int *)a1[1];
    uint64_t v14 = *v12;
    uint64_t v13 = v12[1];
    unint64_t v15 = v13 * (unint64_t)v14;
    *((_DWORD *)a1 + 5) = v11 + 1;
    if ((v15 & 0xFFFFFFFF00000000) != 0) {
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", a2, a3, a4, v13, v12, v14);
    }
    unint64_t v16 = (unint64_t)v12 + v15 + 8;
    if ((unint64_t)v9 + v10 < v16)
    {
      uint64_t v17 = objc_debug_headerInfoRWs;
      int v18 = v11 + 2;
      do
      {
        if (*(void *)(v17 + 8 * *(unsigned __int16 *)((char *)v9 + v10) + 8)) {
          break;
        }
        a1[3] = (uint64_t *)((char *)v9 + 2 * v10);
        *((_DWORD *)a1 + 5) = v18++;
        uint64_t v9 = (uint64_t *)((char *)v9 + v10);
      }
      while ((unint64_t)v9 + v10 < v16);
    }
  }
LABEL_14:
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::skipEmptyLists(a1);
  unint64_t v22 = *a1;
  uint64_t v23 = **a1;
  if (*a1 != a1[4]) {
    goto LABEL_15;
  }
  if (!v23) {
    goto LABEL_25;
  }
  if ((**a1 & 3) == 2)
  {
    long long v40 = a1[3];
    unint64_t v41 = a1[7];
    goto LABEL_59;
  }
  if ((**a1 & 3) == 1)
  {
    long long v40 = a1[1];
    unint64_t v41 = a1[5];
LABEL_59:
    if (v40 == v41) {
      return a1;
    }
    goto LABEL_16;
  }
  if ((v23 & 3) != 0)
  {
LABEL_16:
    uint64_t v24 = **a1 & 3;
    if (v24 == 2)
    {
      uint64_t v27 = (uint64_t)a1[3] + (*a1[3] >> 16);
      if (!v27)
      {
        unint64_t v25 = 0;
        goto LABEL_34;
      }
      goto LABEL_31;
    }
    if (v24 == 1)
    {
      unint64_t v25 = (unsigned int *)*a1[1];
      if (!v25) {
        goto LABEL_34;
      }
      goto LABEL_30;
    }
    if (v24)
    {
      unint64_t v25 = 0;
      goto LABEL_34;
    }
LABEL_19:
    unint64_t v25 = (unsigned int *)a1[1];
    if (!v25) {
      goto LABEL_34;
    }
LABEL_30:
    uint64_t v27 = (uint64_t)v25;
LABEL_31:
    unint64_t v25 = (unsigned int *)v27;
LABEL_34:
    BOOL v28 = (uint64_t)v25 < 0;
    unsigned int v30 = *v25;
    unint64_t v29 = (unint64_t)(v25 + 2);
    unint64_t v31 = (uint64_t *)((unsigned __int16)v30 & 0xFFFC);
    unint64_t v32 = (unint64_t)v30 >> 31;
    if (v28) {
      unint64_t v32 = 2;
    }
    a1[8] = v31;
    a1[9] = (uint64_t *)(v32 | v29 & 0xFFFFFFFFFFFFFFFCLL);
    if (*v22)
    {
      if ((*v22 & 3) == 2)
      {
        uint64_t v34 = (uint64_t)a1[3] + (*a1[3] >> 16);
        if (!v34)
        {
          uint64_t v33 = 0;
          goto LABEL_48;
        }
LABEL_47:
        uint64_t v33 = (int *)v34;
        goto LABEL_48;
      }
      if ((*v22 & 3) == 1)
      {
        uint64_t v33 = (int *)*a1[1];
        if (!v33) {
          goto LABEL_48;
        }
LABEL_46:
        uint64_t v34 = (uint64_t)v33;
        goto LABEL_47;
      }
      if ((*v22 & 3) != 0)
      {
        unint64_t v35 = 0;
        goto LABEL_52;
      }
    }
    uint64_t v33 = (int *)a1[1];
    if (!v33)
    {
LABEL_48:
      if (v33) {
        unint64_t v35 = v33;
      }
      else {
        unint64_t v35 = 0;
      }
LABEL_52:
      a1[10] = (uint64_t *)entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::end(v35, v19, v20, v21);
      a1[11] = (uint64_t *)v36;
      if (a1[9] != (uint64_t *)v36) {
        return a1;
      }
      uint64_t v42 = **a1;
      if (v42)
      {
        if ((**a1 & 3) == 2)
        {
          uint64_t v44 = (uint64_t)a1[3] + (*a1[3] >> 16);
          if (!v44)
          {
            unint64_t v43 = 0;
            goto LABEL_75;
          }
          goto LABEL_74;
        }
        if ((**a1 & 3) == 1)
        {
          unint64_t v43 = (uint64_t *)*a1[1];
          if (!v43) {
            goto LABEL_75;
          }
          goto LABEL_68;
        }
        if ((v42 & 3) != 0)
        {
          unint64_t v43 = 0;
          goto LABEL_75;
        }
      }
      unint64_t v43 = a1[1];
      if (!v43) {
        goto LABEL_75;
      }
LABEL_68:
      uint64_t v44 = (uint64_t)v43;
LABEL_74:
      unint64_t v43 = (uint64_t *)v44;
LABEL_75:
      _objc_fatal("Assertion failed: (%s) - empty list %p encountered during iteration", v36, v37, v38, "m != mEnd", v43);
    }
    goto LABEL_46;
  }
LABEL_25:
  if (a1[1]) {
    unint64_t v26 = a1[1];
  }
  else {
    unint64_t v26 = 0;
  }
  if (v26 != a1[5])
  {
LABEL_15:
    if (!v23) {
      goto LABEL_19;
    }
    goto LABEL_16;
  }
  return a1;
}

uint64_t list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::iteratorImpl(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::ListIterator::ListIterator(a1, a2);
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::ListIterator::ListIterator(v6 + 32, (uint64_t)a3);
  uint64_t v10 = **(void **)a2;
  if (*(void *)a2 != *a3) {
    goto LABEL_2;
  }
  if (!v10) {
    goto LABEL_12;
  }
  if ((**(void **)a2 & 3) == 2)
  {
    uint64_t v26 = *(void *)(a2 + 24);
    uint64_t v27 = a3[3];
    goto LABEL_46;
  }
  if ((**(void **)a2 & 3) == 1)
  {
    uint64_t v26 = *(void *)(a2 + 8);
    uint64_t v27 = a3[1];
LABEL_46:
    if (v26 == v27) {
      goto LABEL_40;
    }
    goto LABEL_3;
  }
  if ((v10 & 3) != 0)
  {
LABEL_3:
    uint64_t v11 = **(void **)a2 & 3;
    if (v11 == 2)
    {
      uint64_t v14 = *(void *)(a2 + 24) + (**(uint64_t **)(a2 + 24) >> 16);
      if (!v14)
      {
        uint64_t v12 = 0;
        goto LABEL_21;
      }
      goto LABEL_18;
    }
    if (v11 == 1)
    {
      uint64_t v12 = **(unsigned int ***)(a2 + 8);
      if (!v12) {
        goto LABEL_21;
      }
      goto LABEL_17;
    }
    if (v11)
    {
      uint64_t v12 = 0;
      goto LABEL_21;
    }
LABEL_6:
    uint64_t v12 = *(unsigned int **)(a2 + 8);
    if (!v12) {
      goto LABEL_21;
    }
LABEL_17:
    uint64_t v14 = (uint64_t)v12;
LABEL_18:
    uint64_t v12 = (unsigned int *)v14;
LABEL_21:
    BOOL v15 = (uint64_t)v12 < 0;
    unsigned int v17 = *v12;
    unint64_t v16 = (unint64_t)(v12 + 2);
    uint64_t v18 = (unsigned __int16)v17 & 0xFFFC;
    unint64_t v19 = (unint64_t)v17 >> 31;
    if (v15) {
      unint64_t v19 = 2;
    }
    *(void *)(a1 + 64) = v18;
    *(void *)(a1 + 72) = v19 | v16 & 0xFFFFFFFFFFFFFFFCLL;
    uint64_t v20 = **(void **)a2;
    if (v20)
    {
      if ((**(void **)a2 & 3) == 2)
      {
        uint64_t v22 = *(void *)(a2 + 24) + (**(uint64_t **)(a2 + 24) >> 16);
        if (!v22)
        {
          unint64_t v21 = 0;
LABEL_35:
          if (v21) {
            uint64_t v23 = v21;
          }
          else {
            uint64_t v23 = 0;
          }
          goto LABEL_39;
        }
LABEL_34:
        unint64_t v21 = (int *)v22;
        goto LABEL_35;
      }
      if ((**(void **)a2 & 3) == 1)
      {
        unint64_t v21 = **(int ***)(a2 + 8);
        if (!v21) {
          goto LABEL_35;
        }
        goto LABEL_33;
      }
      if ((v20 & 3) != 0)
      {
        uint64_t v23 = 0;
LABEL_39:
        *(void *)(a1 + 8freeBuckets(table, 0) = entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::end(v23, v7, v8, v9);
        *(void *)(a1 + 88) = v24;
        goto LABEL_40;
      }
    }
    unint64_t v21 = *(int **)(a2 + 8);
    if (!v21) {
      goto LABEL_35;
    }
LABEL_33:
    uint64_t v22 = (uint64_t)v21;
    goto LABEL_34;
  }
LABEL_12:
  if (*(void *)(a2 + 8)) {
    uint64_t v13 = *(void *)(a2 + 8);
  }
  else {
    uint64_t v13 = 0;
  }
  if (v13 != a3[1])
  {
LABEL_2:
    if (!v10) {
      goto LABEL_6;
    }
    goto LABEL_3;
  }
LABEL_40:
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::skipEmptyLists((uint64_t **)a1);
  return a1;
}

uint64_t *std::__inplace_merge<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::bigSigned *>(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  if (!a6) {
    return result;
  }
  uint64_t v10 = a6;
  uint64_t v14 = result;
  while (v10 > a8 && a5 > a8)
  {
    if (!a5) {
      return result;
    }
    for (unint64_t i = v14; ; i += 3)
    {
      unint64_t v16 = *a2 ? *a2 : 0;
      if (v16 < *v14) {
        break;
      }
      v14 += 3;
      if (!--a5) {
        return result;
      }
    }
    uint64_t v67 = a8;
    if (a5 >= v10)
    {
      if (a5 == 1)
      {
        return std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<method_t::bigSigned *&,method_t::bigSigned *&>(v14, a2);
      }
      if (a5 >= 0) {
        uint64_t v27 = a5;
      }
      else {
        uint64_t v27 = a5 + 1;
      }
      uint64_t v66 = v27 >> 1;
      unint64_t v21 = &v14[3 * (v27 >> 1)];
      if (a3 == a2)
      {
        unint64_t v19 = a2;
LABEL_46:
        uint64_t v18 = 0xAAAAAAAAAAAAAAABLL * (v19 - a2);
        goto LABEL_47;
      }
      unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * (a3 - a2);
      uint64_t v29 = *v21;
      unint64_t v19 = a2;
      while (2)
      {
        unint64_t v30 = v28 >> 1;
        unint64_t v31 = &v19[3 * (v28 >> 1)];
        if (*v31)
        {
          unint64_t v32 = *v31;
          if (v29) {
            goto LABEL_35;
          }
LABEL_37:
          unint64_t v33 = 0;
        }
        else
        {
          unint64_t v32 = 0;
          if (!v29) {
            goto LABEL_37;
          }
LABEL_35:
          unint64_t v33 = *v21;
        }
        uint64_t v34 = v31 + 3;
        v28 += ~v30;
        if (v32 < v33) {
          unint64_t v19 = v34;
        }
        else {
          unint64_t v28 = v30;
        }
        if (!v28) {
          goto LABEL_46;
        }
        continue;
      }
    }
    if (v10 >= 0) {
      uint64_t v17 = v10;
    }
    else {
      uint64_t v17 = v10 + 1;
    }
    uint64_t v18 = v17 >> 1;
    unint64_t v19 = &a2[3 * (v17 >> 1)];
    if (a2 == v14)
    {
      unint64_t v21 = a2;
    }
    else
    {
      unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * (a2 - v14);
      unint64_t v21 = v14;
      do
      {
        if (*v19) {
          unint64_t v22 = *v19;
        }
        else {
          unint64_t v22 = 0;
        }
        unint64_t v23 = v20 >> 1;
        uint64_t v24 = (unint64_t *)&v21[3 * (v20 >> 1)];
        unint64_t v25 = *v24;
        uint64_t v26 = (uint64_t *)(v24 + 3);
        v20 += ~(v20 >> 1);
        if (v22 < v25) {
          unint64_t v20 = v23;
        }
        else {
          unint64_t v21 = v26;
        }
      }
      while (v20);
    }
    uint64_t v66 = 0xAAAAAAAAAAAAAAABLL * (v21 - v14);
LABEL_47:
    unint64_t v35 = v19;
    if (v21 != a2)
    {
      unint64_t v35 = v21;
      if (a2 != v19)
      {
        uint64_t v64 = a3;
        uint64_t v65 = v18;
        unint64_t v35 = v21;
        uint64_t v36 = a2;
        while (1)
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<method_t::bigSigned *&,method_t::bigSigned *&>(v35, a2);
          v35 += 3;
          a2 += 3;
          if (a2 == v19) {
            break;
          }
          if (v35 == v36) {
            uint64_t v36 = a2;
          }
        }
        uint64_t v18 = v65;
        if (v35 == v36)
        {
          a3 = v64;
        }
        else
        {
          uint64_t v63 = a7;
          unint64_t v37 = v35;
          long long v38 = v36;
          do
          {
            while (1)
            {
              std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<method_t::bigSigned *&,method_t::bigSigned *&>(v37, v36);
              v37 += 3;
              v36 += 3;
              if (v36 == v19) {
                break;
              }
              if (v37 == v38) {
                long long v38 = v36;
              }
            }
            uint64_t v36 = v38;
          }
          while (v37 != v38);
          a7 = v63;
          a3 = v64;
          uint64_t v18 = v65;
        }
      }
    }
    a5 -= v66;
    v10 -= v18;
    if (v66 + v18 >= a5 + v10)
    {
      uint64_t v40 = a5;
      uint64_t v41 = v18;
      uint64_t result = (uint64_t *)std::__inplace_merge<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::bigSigned *>(v35, v19, a3, a4, v40, v10, a7, v67);
      unint64_t v19 = v21;
      a8 = v67;
      uint64_t v10 = v41;
      a5 = v66;
      a3 = v35;
    }
    else
    {
      long long v39 = v21;
      a8 = v67;
      uint64_t result = (uint64_t *)std::__inplace_merge<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::bigSigned *>(v14, v39, v35, a4, v66, v18, a7, v67);
      uint64_t v14 = v35;
    }
    a2 = v19;
    if (!v10) {
      return result;
    }
  }
  if (a5 <= v10)
  {
    if (v14 == a2) {
      return result;
    }
    uint64_t v52 = 0;
    do
    {
      BOOL v53 = &v14[v52];
      unsigned int v54 = &a7[v52];
      a7[v52] = v14[v52];
      v54[1] = v14[v52 + 1];
      v54[2] = v14[v52 + 2];
      v52 += 3;
    }
    while (v53 + 3 != a2);
    uint64_t v55 = &a7[v52];
    if (&a7[v52] == a7) {
      return result;
    }
    for (int j = v14; ; j += 3)
    {
      if (a2 == a3)
      {
        if (a7 != v55)
        {
          uint64_t v61 = 0;
          do
          {
            unint64_t v62 = &a7[v61];
            v14[v61] = a7[v61];
            v14[v61 + 1] = a7[v61 + 1];
            v14[v61 + 2] = a7[v61 + 2];
            j += 3;
            v61 += 3;
          }
          while (v62 != v55 - 3);
        }
        return result;
      }
      if (*a2) {
        unint64_t v57 = *a2;
      }
      else {
        unint64_t v57 = 0;
      }
      if (*a7)
      {
        if (v57 < *a7)
        {
          if (*a2) {
            uint64_t v58 = *a2;
          }
          else {
            uint64_t v58 = 0;
          }
          *uint64_t v14 = v58;
          v14[1] = a2[1];
          v14[2] = a2[2];
          a2 += 3;
          goto LABEL_105;
        }
        uint64_t v59 = *a7;
      }
      else
      {
        uint64_t v59 = 0;
      }
      *uint64_t v14 = v59;
      v14[1] = a7[1];
      v14[2] = a7[2];
      a7 += 3;
LABEL_105:
      v14 += 3;
      if (a7 == v55) {
        return result;
      }
    }
  }
  if (a2 != a3)
  {
    uint64_t v42 = 0;
    do
    {
      unint64_t v43 = &a7[v42];
      uint64_t v44 = &a2[v42];
      a7[v42] = a2[v42];
      v43[1] = a2[v42 + 1];
      v43[2] = a2[v42 + 2];
      v42 += 3;
    }
    while (v44 + 3 != a3);
    unint64_t v45 = &a7[v42];
    if (&a7[v42] != a7)
    {
      uint64_t v46 = a3 - 1;
      int v47 = a3 - 1;
      while (a2 != v14)
      {
        uint64_t v48 = *(v45 - 3);
        if (v48) {
          unint64_t v49 = *(v45 - 3);
        }
        else {
          unint64_t v49 = 0;
        }
        unint64_t v50 = *(a2 - 3);
        if (v50 && v49 < v50)
        {
          *(v46 - 2) = v50;
          *(v46 - freeBuckets(table, 1) = *(a2 - 2);
          *uint64_t v46 = *(a2 - 1);
          a2 -= 3;
        }
        else
        {
          if (v48) {
            uint64_t v51 = *(v45 - 3);
          }
          else {
            uint64_t v51 = 0;
          }
          *(v46 - 2) = v51;
          *(v46 - freeBuckets(table, 1) = *(v45 - 2);
          *uint64_t v46 = *(v45 - 1);
          v45 -= 3;
        }
        v47 -= 3;
        v46 -= 3;
        if (v45 == a7) {
          return result;
        }
      }
      if (v45 != a7)
      {
        uint64_t v60 = 0;
        do
        {
          v46[v60 - 2] = v45[v60 - 3];
          v46[v60 - 1] = v45[v60 - 2];
          v46[v60] = v45[v60 - 1];
          v60 -= 3;
          v47 -= 3;
        }
        while (&v45[v60] != a7);
      }
    }
  }
  return result;
}

uint64_t std::__inplace_merge<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(uint64_t result, unint64_t *a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a6)
  {
    uint64_t v8 = a6;
    uint64_t v11 = (unint64_t *)result;
    while (v8 > a8 && a5 > a8)
    {
      if (!a5) {
        return result;
      }
      while (*a2 >= *v11)
      {
        v11 += 3;
        if (!--a5) {
          return result;
        }
      }
      if (a5 >= v8)
      {
        if (a5 == 1)
        {
          long long v71 = *(_OWORD *)v11;
          if (v11[2]) {
            unint64_t v64 = v11[2];
          }
          else {
            unint64_t v64 = 0;
          }
          *(_OWORD *)uint64_t v11 = *(_OWORD *)a2;
          v11[2] = a2[2];
          *(_OWORD *)a2 = v71;
          if (v64) {
            unint64_t v68 = v64;
          }
          else {
            unint64_t v68 = 0;
          }
          a2[2] = v68;
          return result;
        }
        if (a5 >= 0) {
          uint64_t v22 = a5;
        }
        else {
          uint64_t v22 = a5 + 1;
        }
        uint64_t v23 = v22 >> 1;
        unint64_t v16 = &v11[3 * (v22 >> 1)];
        if (a3 == a2)
        {
          uint64_t v14 = a3;
          uint64_t v29 = a3;
        }
        else
        {
          unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * (a3 - a2);
          uint64_t v14 = a2;
          do
          {
            unint64_t v25 = v24 >> 1;
            uint64_t v26 = &v14[3 * (v24 >> 1)];
            unint64_t v28 = *v26;
            uint64_t v27 = v26 + 3;
            v24 += ~(v24 >> 1);
            if (v28 < *v16) {
              uint64_t v14 = v27;
            }
            else {
              unint64_t v24 = v25;
            }
          }
          while (v24);
          uint64_t v29 = a2;
        }
        uint64_t v13 = 0xAAAAAAAAAAAAAAABLL * (v14 - v29);
      }
      else
      {
        if (v8 >= 0) {
          uint64_t v12 = v8;
        }
        else {
          uint64_t v12 = v8 + 1;
        }
        uint64_t v13 = v12 >> 1;
        uint64_t v14 = &a2[3 * (v12 >> 1)];
        if (a2 == v11)
        {
          unint64_t v16 = a2;
          unint64_t v21 = a2;
        }
        else
        {
          unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * (a2 - v11);
          unint64_t v16 = v11;
          do
          {
            unint64_t v17 = v15 >> 1;
            uint64_t v18 = &v16[3 * (v15 >> 1)];
            unint64_t v20 = *v18;
            unint64_t v19 = v18 + 3;
            v15 += ~(v15 >> 1);
            if (*v14 < v20) {
              unint64_t v15 = v17;
            }
            else {
              unint64_t v16 = v19;
            }
          }
          while (v15);
          unint64_t v21 = v11;
        }
        uint64_t v23 = 0xAAAAAAAAAAAAAAABLL * (v16 - v21);
      }
      unint64_t v30 = v14;
      if (v16 != a2)
      {
        unint64_t v30 = v16;
        if (a2 != v14)
        {
          unint64_t v31 = v16 + 3;
          unint64_t v32 = v16 + 2;
          unint64_t v33 = a2 + 2;
          unint64_t v30 = a2;
          while (1)
          {
            long long v69 = *(_OWORD *)(v31 - 3);
            unint64_t v34 = *(v31 - 1) ? *(v31 - 1) : 0;
            *(_OWORD *)(v31 - 3) = *(_OWORD *)a2;
            *(v31 - freeBuckets(table, 1) = a2[2];
            *(_OWORD *)a2 = v69;
            uint64_t v35 = v34 ? v34 : 0;
            a2[2] = v35;
            a2 += 3;
            if (a2 == v14) {
              break;
            }
            if (v31 == v30) {
              unint64_t v30 = a2;
            }
            v31 += 3;
            v32 += 3;
            v33 += 3;
          }
          if (v31 != v30)
          {
            uint64_t v36 = v31;
            unint64_t v37 = v30;
LABEL_50:
            long long v38 = v36 + 2;
            do
            {
              long long v70 = *(_OWORD *)v36;
              if (v36[2]) {
                unint64_t v39 = v36[2];
              }
              else {
                unint64_t v39 = 0;
              }
              *(_OWORD *)uint64_t v36 = *(_OWORD *)v30;
              v36[2] = v30[2];
              *(_OWORD *)unint64_t v30 = v70;
              if (v39) {
                unint64_t v40 = v39;
              }
              else {
                unint64_t v40 = 0;
              }
              v30[2] = v40;
              v36 += 3;
              v30 += 3;
              if (v30 != v14)
              {
                if (v36 == v37) {
                  unint64_t v37 = v30;
                }
                goto LABEL_50;
              }
              v38 += 3;
              unint64_t v30 = v37;
            }
            while (v36 != v37);
            unint64_t v30 = v31;
          }
        }
      }
      a5 -= v23;
      v8 -= v13;
      if (v23 + v13 >= a5 + v8)
      {
        uint64_t v47 = a5;
        uint64_t v48 = v13;
        uint64_t v49 = v8;
        uint64_t v50 = a7;
        uint64_t v51 = a8;
        uint64_t result = std::__inplace_merge<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(v30, v14, a3, a4, v47, v49);
        a8 = v51;
        a7 = v50;
        uint64_t v14 = v16;
        uint64_t v8 = v48;
        a5 = v23;
        a3 = v30;
      }
      else
      {
        uint64_t v41 = v11;
        uint64_t v42 = v16;
        unint64_t v43 = a3;
        uint64_t v44 = v23;
        uint64_t v45 = a7;
        uint64_t v46 = a8;
        uint64_t result = std::__inplace_merge<std::_ClassicAlgPolicy,method_t::SortBySELAddress &,method_t::big *>(v41, v42, v30, a4, v44, v13);
        a8 = v46;
        a3 = v43;
        a7 = v45;
        uint64_t v11 = v30;
      }
      a2 = v14;
      if (!v8) {
        return result;
      }
    }
    if (a5 <= v8)
    {
      if (v11 != a2)
      {
        uint64_t v59 = 0;
        do
        {
          uint64_t v60 = &v11[v59];
          *(_OWORD *)(a7 + v59 * 8) = *(_OWORD *)&v11[v59];
          *(void *)(a7 + v59 * 8 + 16) = v11[v59 + 2];
          v59 += 3;
        }
        while (v60 + 3 != a2);
        uint64_t v61 = a7 + v59 * 8;
        if (a7 + v59 * 8 != a7)
        {
          uint64_t v62 = v61 - 24;
          uint64_t v63 = v11 + 2;
          while (a2 != a3)
          {
            if (*a2 >= *(void *)a7)
            {
              *(_OWORD *)uint64_t v11 = *(_OWORD *)a7;
              v11[2] = *(void *)(a7 + 16);
              a7 += 24;
            }
            else
            {
              *(_OWORD *)uint64_t v11 = *(_OWORD *)a2;
              v11[2] = a2[2];
              a2 += 3;
            }
            v11 += 3;
            v63 += 3;
            if (a7 == v61) {
              return result;
            }
          }
          uint64_t v66 = 0;
          do
          {
            uint64_t v67 = a7 + v66 * 8;
            *(_OWORD *)&v11[v66] = *(_OWORD *)(a7 + v66 * 8);
            v11[v66 + 2] = *(void *)(a7 + v66 * 8 + 16);
            v63 += 3;
            v66 += 3;
          }
          while (v67 != v62);
        }
      }
    }
    else if (a2 != a3)
    {
      uint64_t v52 = 0;
      do
      {
        BOOL v53 = &a2[v52];
        *(_OWORD *)(a7 + v52 * 8) = *(_OWORD *)&a2[v52];
        *(void *)(a7 + v52 * 8 + 16) = a2[v52 + 2];
        v52 += 3;
      }
      while (v53 + 3 != a3);
      uint64_t v54 = a7 + v52 * 8;
      if (a7 + v52 * 8 != a7)
      {
        uint64_t v55 = a3 - 1;
        uint64_t v56 = a3 - 3;
        while (a2 != v11)
        {
          unint64_t v57 = a2 - 3;
          if (*(void *)(v54 - 24) >= *(a2 - 3))
          {
            *(_OWORD *)uint64_t v56 = *(_OWORD *)(v54 - 24);
            unint64_t v58 = *(void *)(v54 - 8);
            unint64_t v57 = a2;
            v54 -= 24;
          }
          else
          {
            *(_OWORD *)uint64_t v56 = *(_OWORD *)v57;
            unint64_t v58 = *(a2 - 1);
          }
          v56[2] = v58;
          v55 -= 3;
          v56 -= 3;
          a2 = v57;
          if (v54 == a7) {
            return result;
          }
        }
        uint64_t v65 = 0;
        do
        {
          *(_OWORD *)&v56[v65] = *(_OWORD *)(v54 + v65 * 8 - 24);
          v56[v65 + 2] = *(void *)(v54 + v65 * 8 - 8);
          v65 -= 3;
          v55 -= 3;
        }
        while (v54 + v65 * 8 != a7);
      }
    }
  }
  return result;
}

void *objc::Scanner::setNSObjectSwizzled(void *result, int a2, char a3)
{
  objc::NSObjectSwizzledMask |= (a2 << a3);
  int v3 = *(_DWORD *)(result[4] & 0xF00007FFFFFFFF8);
  if ((v3 & 1) == 0) {
    int v3 = *(_DWORD *)(*(void *)((*result & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8);
  }
  if ((v3 & 0x20000000) != 0) {
    return (void *)objc::Scanner::propagateCustomFlags((uint64_t)result, a2, 0);
  }
  return result;
}

uint64_t __copy_helper_block_e8_32c83_ZTSKZN4objc7Scanner20propagateCustomFlagsEP10objc_classjNS0_11inherited_tEEUlS2_E_(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  *(void *)(result + 39) = *(void *)(a2 + 39);
  *(void *)(result + 32) = v2;
  return result;
}

void objc::Scanner::printCustom(const char *a1, objc_class *this, int a3)
{
  uint64_t v6 = objc_class::nameForLogging(this);
  if ((*((_WORD *)this + 15) & 4) != 0) {
    uint64_t v7 = " (meta)";
  }
  else {
    uint64_t v7 = "";
  }
  uint64_t v8 = " (inherited)";
  if (a3 != 1) {
    uint64_t v8 = "";
  }
  _objc_inform("%s: %s%s%s", a1, v6, v7, v8);
}

__n128 __copy_helper_block_e8_32c67_ZTSKZL25_method_setImplementationP10objc_classP8method_tPFvvEE3__0(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[2];
  a1[2] = result;
  return result;
}

BOOL ___ZN10objc_class39setDisallowPreoptInlinedSelsRecursivelyEPKc_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = (uint64_t *)(a2 + 32);
  uint64_t v2 = *(void *)(a2 + 32);
  int v4 = *(_DWORD *)(v2 & 0xF00007FFFFFFFF8);
  if ((v4 & 4) == 0)
  {
    if (PrintCaches)
    {
      uint64_t v8 = *(objc_class **)(a1 + 32);
      if ((*((_WORD *)v8 + 15) & 4) != 0) {
        uint64_t v9 = "meta";
      }
      else {
        uint64_t v9 = "";
      }
      uint64_t v10 = objc_class::nameForLogging(v8);
      _objc_inform("CACHES: %sclass %s: disallow sel-inlined preopt cache (from %s)", v9, v10, *(const char **)(a1 + 40));
      uint64_t v2 = *v3;
    }
    atomic_fetch_or_explicit((atomic_uint *volatile)(v2 & 0xF00007FFFFFFFF8), 4u, memory_order_relaxed);
    if ((*(void *)(a2 + 16) & 1) != 0 && (*(_DWORD *)((*(void *)(a2 + 16) & 0x7FFFFFFFFFFFFELL) - 6) & 0x4000) != 0) {
      cache_t::eraseNolock((cache_t *)(a2 + 16), *(const char **)(a1 + 40));
    }
  }
  return (v4 & 4) == 0;
}

__n128 __copy_helper_block_e8_32c69_ZTSKZN10objc_class39setDisallowPreoptInlinedSelsRecursivelyEPKcE3__0(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[2];
  a1[2] = result;
  return result;
}

__n128 __copy_helper_block_e8_32c64_ZTSKZN10objc_class34setDisallowPreoptCachesRecursivelyEPKcE3__0(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[2];
  a1[2] = result;
  return result;
}

uint64_t empty_lazyClassNamer(objc_class *a1)
{
  return 0;
}

__n128 __copy_helper_block_e8_32c64_ZTSKZN10objc_class36setInstancesRequireRawIsaRecursivelyEbE3__0(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[2];
  a1[2] = result;
  return result;
}

_DWORD *futureNamedClasses(void)
{
  __n128 result = (_DWORD *)future_named_class_map;
  if (!future_named_class_map)
  {
    v1[0] = _mapStrHash;
    v1[1] = _mapStrIsEqual;
    v1[2] = _mapNoFree;
    int v2 = 0;
    __n128 result = NXCreateMapTable(v1, 0x20u);
    future_named_class_map = (uint64_t)result;
  }
  return result;
}

void *_class_isFutureClass(void *result)
{
  if (result)
  {
    if ((unint64_t)(*result - 1) >= 0xF) {
      return (void *)((*(unsigned __int8 *)((result[4] & 0xF00007FFFFFFFF8) + 3) >> 6) & 1);
    }
    else {
      return 0;
    }
  }
  return result;
}

void _objc_flush_caches(Class cls)
{
  int v3 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v3, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v3) {
    os_unfair_lock_lock_with_options();
  }
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3321888768;
  v13[2] = ___objc_flush_caches_block_invoke;
  v13[3] = &__block_descriptor_33_e8_32c31_ZTSKZ18_objc_flush_cachesE3__0_e8_B16__0_8l;
  flushCaches((uint64_t)cls, (uint64_t)"_objc_flush_caches", (const char *)v13, v1);
  if (cls)
  {
    if ((*((_WORD *)cls + 15) & 4) == 0 && *((void *)cls + 1))
    {
      uint64_t v6 = *(void *)cls & 0xFFFFFFFF8;
      v12[0] = MEMORY[0x1E4F143A8];
      v12[1] = 3321888768;
      void v12[2] = ___objc_flush_caches_block_invoke_6;
      v12[3] = &__block_descriptor_33_e8_32c31_ZTSKZ18_objc_flush_cachesE3__1_e8_B16__0_8l;
      flushCaches(v6, (uint64_t)"_objc_flush_caches", (const char *)v12, v5);
    }
  }
  else
  {
    int v7 = *(_DWORD *)(StatusReg + 24);
    int v8 = v7;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v8, 0, memory_order_release, memory_order_relaxed);
    if (v8 != v7) {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
    int v9 = 0;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v9, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v9) {
      os_unfair_lock_lock_with_options();
    }
    cache_t::collectNolock((cache_t *)1);
  }
  int v10 = *(_DWORD *)(StatusReg + 24);
  int v11 = v10;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v11, 0, memory_order_release, memory_order_relaxed);
  if (v11 != v10) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
}

void sub_18013F184(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

BOOL ___objc_flush_caches_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(objc_cache **)(a2 + 16);
  if (v2) {
    return 0;
  }
  return v2 == &_objc_empty_cache || HIWORD(*(void *)(a2 + 16)) != 0;
}

BOOL ___objc_flush_caches_block_invoke_6(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(objc_cache **)(a2 + 16);
  if (v2) {
    return 0;
  }
  return v2 == &_objc_empty_cache || HIWORD(*(void *)(a2 + 16)) != 0;
}

void _objc_map_images(unsigned int a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    int v5 = 0;
    uint64_t v6 = 0;
    int v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = a1;
    do
    {
      uint64_t v10 = *(void *)(a3 + 8 * v8);
      uint64_t v11 = *(void *)(a2 + 8 * v8);
      if (v6 >= v7)
      {
        uint64_t v12 = (v6 - v5) >> 5;
        unint64_t v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 59) {
          abort();
        }
        if ((v7 - v5) >> 4 > v13) {
          unint64_t v13 = (v7 - v5) >> 4;
        }
        if ((unint64_t)(v7 - v5) >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v14 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v13;
        }
        if (v14)
        {
          if (v14 >> 59) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unint64_t v15 = (char *)malloc_type_malloc(32 * v14, 0xB4ED9BFAuLL);
        }
        else
        {
          unint64_t v15 = 0;
        }
        unint64_t v16 = &v15[32 * v12];
        *(void *)unint64_t v16 = v10;
        *((void *)v16 + freeBuckets(table, 1) = v11;
        *((void *)v16 + 2) = 0;
        *((void *)v16 + 3) = 0;
        if (v6 == v5)
        {
          unint64_t v19 = &v15[32 * v12];
        }
        else
        {
          unint64_t v17 = &v15[32 * v12];
          do
          {
            long long v18 = *((_OWORD *)v6 - 1);
            unint64_t v19 = v17 - 32;
            *((_OWORD *)v17 - 2) = *((_OWORD *)v6 - 2);
            *((_OWORD *)v17 - freeBuckets(table, 1) = v18;
            v6 -= 32;
            v17 -= 32;
          }
          while (v6 != v5);
        }
        int v7 = &v15[32 * v14];
        uint64_t v6 = v16 + 32;
        if (v5) {
          free(v5);
        }
        int v5 = v19;
      }
      else
      {
        *(void *)uint64_t v6 = v10;
        *((void *)v6 + freeBuckets(table, 1) = v11;
        *((void *)v6 + 2) = 0;
        *((void *)v6 + 3) = 0;
        v6 += 32;
      }
      ++v8;
    }
    while (v8 != v9);
  }
  else
  {
    int v5 = 0;
  }
  map_images(a1, v5, (uint64_t)&__block_literal_global);
  if (v5)
  {
    free(v5);
  }
}

void sub_18013F3D0(_Unwind_Exception *exception_object)
{
  if (v1) {
    free(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
}

uint64_t _objc_load_image(uint64_t a1, uint64_t a2)
{
  v3[0] = a2;
  v3[1] = a1;
  v3[2] = 0;
  void v3[3] = 0;
  return load_images((uint64_t)v3);
}

uint64_t unmap_image(uint64_t a1, header_info *a2)
{
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  os_unfair_recursive_lock_lock_with_options();
  int v3 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v3, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v3) {
    os_unfair_lock_lock_with_options();
  }
  if (PrintImages) {
    _objc_inform("IMAGES: processing 1 newly-unmapped image...\n");
  }
  int v5 = (header_info *)FirstHeader;
  if (!FirstHeader) {
    goto LABEL_130;
  }
  while ((header_info *)((char *)v5 + *(void *)v5) != a2)
  {
    uint64_t PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v5);
    int v7 = (void *)((char *)v5 + 24);
    if (PreoptimizedHeaderRW) {
      int v7 = (void *)PreoptimizedHeaderRW;
    }
    int v5 = (header_info *)(*v7 & 0xFFFFFFFFFFFFFFFCLL);
    if (!v5) {
      goto LABEL_130;
    }
  }
  if (PrintImages)
  {
    uint64_t v8 = (const char *)dyld_image_path_containing_address();
    if (*(_DWORD *)((char *)v5 + *(void *)v5 + 12) == 8) {
      uint64_t v9 = " (bundle)";
    }
    else {
      uint64_t v9 = "";
    }
    _objc_inform("IMAGES: unloading image for %s%s\n", v8, v9);
  }
  unint64_t v79 = 0;
  uint64_t v10 = header_info::catlist(v5, &v79);
  unint64_t v75 = StatusReg;
  unint64_t v11 = v79;
  if (v79)
  {
    uint64_t v12 = v10;
    uint64_t v13 = 0;
    while (1)
    {
      unint64_t v14 = *(const char ***)(v12 + 8 * v13);
      unint64_t v15 = remapClass((unint64_t)v14[1]);
      if (v15) {
        break;
      }
LABEL_47:
      if (++v13 == v11) {
        goto LABEL_48;
      }
    }
    uint64_t v16 = objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::find(v15);
    unint64_t v17 = (void *)v16;
    if (objc::unattachedCategories + 24 * dword_1EB1CB0C8 == v16)
    {
LABEL_39:
      if (loadable_categories && loadable_categories_used >= 1)
      {
        uint64_t v25 = 0;
        uint64_t v26 = (void **)loadable_categories;
        while (*v26 != v14)
        {
          ++v25;
          v26 += 2;
          if (loadable_categories_used == v25) {
            goto LABEL_47;
          }
        }
        *(void *)(loadable_categories + 16 * v25) = 0;
        if (PrintLoading)
        {
          uint64_t v27 = (objc_class *)remapClass((unint64_t)v14[1]);
          unint64_t v28 = objc_class::nameForLogging(v27);
          _objc_inform("LOAD: category '%s(%s)' unscheduled for +load", v28, *v14);
        }
      }
      goto LABEL_47;
    }
    long long v18 = (void **)(v16 + 8);
    unint64_t v19 = *(void *)(v16 + 16);
    if (v19)
    {
      if (v19 >= 2)
      {
        uint64_t v21 = 0;
        unsigned int v22 = v19 >> 1;
        if (v19 >> 1 <= 1) {
          uint64_t v23 = 1;
        }
        else {
          uint64_t v23 = v22;
        }
        unint64_t v24 = (void **)*v18;
        while (v14 != *v24)
        {
          ++v21;
          v24 += 2;
          if (v23 == v21) {
            goto LABEL_32;
          }
        }
        memmove((char *)*v18 + 16 * v21, (char *)*v18 + 16 * (v21 + 1), 16 * (v22 + ~v21));
        unint64_t v19 = v17[2] & 0xFFFFFFFF00000001 | (2 * (((unint64_t)(v17[2] - 2) >> 1) & 0x7FFFFFFF));
        v17[2] = v19;
      }
    }
    else if (v14 == *v18)
    {
      *long long v18 = 0;
      *(void *)(v16 + 16) = 0;
      BOOL v20 = 1;
      goto LABEL_33;
    }
LABEL_32:
    BOOL v20 = (v19 & 1) == 0;
    if (v19)
    {
      if (v19 >> 1) {
        goto LABEL_39;
      }
LABEL_36:
      if (!v20) {
        free(*v18);
      }
      *unint64_t v17 = -2;
      qword_1EB1CB0C0 = (uint64_t)vadd_s32((int32x2_t)qword_1EB1CB0C0, (int32x2_t)0x1FFFFFFFFLL);
      objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::compact();
      goto LABEL_39;
    }
LABEL_33:
    if (*v18) {
      goto LABEL_39;
    }
    goto LABEL_36;
  }
LABEL_48:
  v77[0] = 0;
  v77[1] = 0;
  uint64_t v78 = 0;
  uint64_t v29 = header_info::classlist(v5, &v79);
  unint64_t v30 = v79;
  if (v79)
  {
    unint64_t v31 = (unint64_t *)v29;
    do
    {
      unint64_t v76 = remapClass(*v31);
      if (v76) {
        objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::try_emplace<objc::detail::DenseSetEmpty&>((uint64_t)v80, v77, &v76);
      }
      ++v31;
      --v30;
    }
    while (v30);
  }
  uint64_t v32 = header_info::nlclslist(v5, &v79);
  unint64_t v33 = v79;
  if (v79)
  {
    unint64_t v34 = (unint64_t *)v32;
    do
    {
      unint64_t v76 = remapClass(*v34);
      if (v76) {
        objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::try_emplace<objc::detail::DenseSetEmpty&>((uint64_t)v80, v77, &v76);
      }
      ++v34;
      --v33;
    }
    while (v33);
  }
  uint64_t v35 = (objc_class **)objc::detail::DenseSetImpl<objc_class *,objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc::DenseMapInfo<objc_class *>>::begin((uint64_t)v77);
  uint64_t v36 = v35;
  long long v38 = v37;
  int32x2_t v39 = v77[0];
  if (v77[0]) {
    int32x2_t v40 = v77[0];
  }
  else {
    int32x2_t v40 = 0;
  }
  uint64_t v41 = (objc_class **)(*(void *)&v40 + 8 * v78);
  if (v41 != v35)
  {
    do
    {
      uint64_t v42 = *v36;
      if (loadable_classes && loadable_classes_used >= 1)
      {
        uint64_t v43 = 0;
        uint64_t v44 = (objc_class **)loadable_classes;
        while (*v44 != v42)
        {
          ++v43;
          v44 += 2;
          if (loadable_classes_used == v43) {
            goto LABEL_70;
          }
        }
        *(void *)(loadable_classes + 16 * v43) = 0;
        if (PrintLoading)
        {
          uint64_t v45 = objc_class::nameForLogging(v42);
          _objc_inform("LOAD: class '%s' unscheduled for +load", v45);
        }
      }
LABEL_70:
      detach_class((objc_class *)(*(void *)v42 & 0xFFFFFFFF8), 1);
      detach_class(v42, 0);
      while (++v36 != v38)
      {
        if ((unint64_t)*v36 < 0xFFFFFFFFFFFFFFFELL) {
          goto LABEL_75;
        }
      }
      uint64_t v36 = v38;
LABEL_75:
      ;
    }
    while (v36 != v41);
    int32x2_t v39 = v77[0];
  }
  uint64_t v46 = (objc_class **)objc::detail::DenseSetImpl<objc_class *,objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc::DenseMapInfo<objc_class *>>::begin((uint64_t)v77);
  uint64_t v47 = v46;
  uint64_t v49 = v48;
  if (v39) {
    int32x2_t v50 = v39;
  }
  else {
    int32x2_t v50 = 0;
  }
  uint64_t v51 = (objc_class **)(*(void *)&v50 + 8 * v78);
  if (v51 != v46)
  {
    do
    {
      uint64_t v52 = *v47;
      free_class((objc_class *)(*(void *)*v47 & 0xFFFFFFFF8));
      free_class(v52);
      while (++v47 != v49)
      {
        if ((unint64_t)*v47 < 0xFFFFFFFFFFFFFFFELL) {
          goto LABEL_86;
        }
      }
      uint64_t v47 = v49;
LABEL_86:
      ;
    }
    while (v47 != v51);
    int32x2_t v39 = v77[0];
  }
  if (v39) {
    BOOL v53 = (void *)v39;
  }
  else {
    BOOL v53 = 0;
  }
  free(v53);
  uint64_t v54 = FirstHeader;
  if (FirstHeader)
  {
    if ((header_info *)FirstHeader != v5)
    {
      while (1)
      {
        uint64_t v55 = getPreoptimizedHeaderRW(v54);
        uint64_t v56 = (void *)(v54 + 24);
        if (v55) {
          uint64_t v56 = (void *)v55;
        }
        unint64_t v57 = *v56 & 0xFFFFFFFFFFFFFFFCLL;
        if (!v57) {
          goto LABEL_111;
        }
        uint64_t v58 = v54;
        uint64_t v54 = v57;
        if (v5 == (header_info *)v57) {
          goto LABEL_99;
        }
      }
    }
    uint64_t v58 = 0;
LABEL_99:
    uint64_t v59 = getPreoptimizedHeaderRW((uint64_t)v5);
    uint64_t v60 = (void *)((char *)v5 + 24);
    if (v59) {
      uint64_t v60 = (void *)v59;
    }
    unint64_t v61 = *v60 & 0xFFFFFFFFFFFFFFFCLL;
    if (v58)
    {
      uint64_t v62 = getPreoptimizedHeaderRW(v58);
      uint64_t v63 = (void *)(v58 + 24);
      if (v62) {
        uint64_t v63 = (void *)v62;
      }
      *uint64_t v63 = *v63 & 3 | v61;
      if ((header_info *)LastHeaderRealizedAllClasses != v5) {
        goto LABEL_109;
      }
    }
    else
    {
      FirstHeader = *v60 & 0xFFFFFFFFFFFFFFFCLL;
      if ((header_info *)LastHeaderRealizedAllClasses != v5) {
        goto LABEL_109;
      }
      uint64_t v58 = 0;
    }
    LastHeaderRealizedAllClasses = v58;
LABEL_109:
    if ((header_info *)LastHeader == v5) {
      LastHeader = 0;
    }
  }
LABEL_111:
  unint64_t v64 = (unint64_t)v5 + *(void *)v5;
  if (dataSegmentsRanges > v64 || *(void *)algn_1EB1CB078 <= v64)
  {
    v80[0] = &unk_1EC978528;
    uint64_t v81 = v80;
    unint64_t v66 = *(unsigned int *)(v64 + 16);
    if (v66)
    {
      unint64_t v67 = v64 + 32;
      uint64_t v68 = *(unsigned int *)(v64 + 16);
      unint64_t v69 = v64 + 32;
      while (*(_DWORD *)v69 != 25 || strncmp((const char *)(v69 + 8), "__TEXT", 0x10uLL))
      {
        v69 += *(unsigned int *)(v69 + 4);
        if (!--v68)
        {
          unint64_t v70 = 0;
          goto LABEL_122;
        }
      }
      unint64_t v70 = v64 - *(void *)(v69 + 24);
LABEL_122:
      for (unint64_t i = 0; i < v66; ++i)
      {
        if (*(_DWORD *)v67 == 25
          && (!strncmp((const char *)(v67 + 8), "__DATA", 6uLL) || !strncmp((const char *)(v67 + 8), "__AUTH", 6uLL)))
        {
          ((void (*)(void *, unint64_t, unint64_t))std::function<void ()(segment_command_64 const*,long)>::operator())(v81, v67, v70);
          unint64_t v66 = *(unsigned int *)(v64 + 16);
        }
        v67 += *(unsigned int *)(v67 + 4);
      }
    }
    std::__function::__value_func<void ()(segment_command_64 const*,long)>::~__value_func[abi:nn180100](v80);
  }
  free(v5);
  unint64_t StatusReg = v75;
LABEL_130:
  int v72 = *(_DWORD *)(StatusReg + 24);
  int v73 = v72;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v73, 0, memory_order_release, memory_order_relaxed);
  if (v73 != v72) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }

  return os_unfair_recursive_lock_unlock();
}

void sub_18013FC54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  if (a14) {
    unint64_t v15 = a14;
  }
  else {
    unint64_t v15 = 0;
  }
  free(v15);
  int v16 = *(_DWORD *)(a12 + 24);
  int v17 = v16;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v17, 0, memory_order_release, memory_order_relaxed);
  if (v17 != v16) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  os_unfair_recursive_lock_unlock();
  _Unwind_Resume(a1);
}

void realizeAllClasses(void)
{
  vm_address_t v0 = (header_info *)FirstHeader;
  uint64_t v1 = LastHeaderRealizedAllClasses;
  if (LastHeaderRealizedAllClasses) {
    BOOL v2 = FirstHeader == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2 && FirstHeader != LastHeaderRealizedAllClasses)
  {
    do
    {
      uint64_t PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v0);
      int v5 = (void *)((char *)v0 + 24);
      if (PreoptimizedHeaderRW) {
        int v5 = (void *)PreoptimizedHeaderRW;
      }
      vm_address_t v0 = (header_info *)(*v5 & 0xFFFFFFFFFFFFFFFCLL);
      if (v0) {
        BOOL v6 = v1 == (void)v0;
      }
      else {
        BOOL v6 = 1;
      }
    }
    while (!v6);
  }
  if (v0)
  {
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    do
    {
      unint64_t v22 = 0;
      uint64_t v8 = header_info::classlist(v0, &v22);
      unint64_t v9 = v22;
      if (v22)
      {
        uint64_t v10 = (unint64_t *)v8;
        do
        {
          unint64_t v11 = (uint64_t *)remapClass(*v10);
          if (v11) {
            realizeClassMaybeSwiftMaybeRelock(v11, 1);
          }
          ++v10;
          --v9;
        }
        while (v9);
      }
      uint64_t v12 = _dyld_lookup_section_info();
      unint64_t v14 = v13 >> 3;
      if (!v12) {
        unint64_t v14 = 0;
      }
      unint64_t v22 = v14;
      if (v14)
      {
        uint64_t v15 = v12;
        unint64_t v16 = 0;
        do
        {
          if (remapClass(*(void *)(v15 + 8 * v16)) == *(void *)(v15 + 8 * v16))
          {
            int v17 = *(_DWORD *)(StatusReg + 24);
            int v18 = v17;
            atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v18, 0, memory_order_release, memory_order_relaxed);
            if (v18 != v17) {
              os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
            }
            (*(void (**)(void))(*(void *)(v15 + 8 * v16) + 8))();
            int v19 = 0;
            atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v19, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
            if (v19) {
              os_unfair_lock_lock_with_options();
            }
          }
          ++v16;
        }
        while (v16 < v22);
      }
      LastHeaderRealizedAllClasses = (uint64_t)v0;
      uint64_t v20 = getPreoptimizedHeaderRW((uint64_t)v0);
      uint64_t v21 = (void *)((char *)v0 + 24);
      if (v20) {
        uint64_t v21 = (void *)v20;
      }
      vm_address_t v0 = (header_info *)(*v21 & 0xFFFFFFFFFFFFFFFCLL);
    }
    while (v0);
  }
}

int *_read_images::$_1::operator()(uint64_t a1)
{
  unint64_t v1 = class_data_bits_t::safe_ro<(Authentication)0>((uint64_t *)(a1 + 32));
  uint64_t v7 = *(void *)(v1 + 32);
  __n128 result = (int *)(v1 + 32);
  uint64_t v6 = v7;
  uint64_t v8 = v7 & 1;
  if (v7) {
    BOOL v9 = v8 == 0;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9)
  {
    if ((v6 & 0xFFFFFFFFFFFFFFFELL) != 0)
    {
      ++_read_images::PreoptTotalMethodLists;
      if ((~*(_DWORD *)(v6 & 0xFFFFFFFFFFFFFFFELL) & 3) == 0) {
        ++_read_images::PreoptOptimizedMethodLists;
      }
    }
  }
  else if (v6)
  {
    uint64_t v10 = (unsigned int *)(v6 & 0xFFFFFFFFFFFFFFFELL);
    if ((v6 & 0xFFFFFFFFFFFFFFFELL) != 0)
    {
      if (DisablePreattachedCategories)
      {
        uint64_t v13 = *v10;
        uint64_t v12 = v10[1];
        unint64_t v24 = v12 * (unint64_t)v13;
        if ((v24 & 0xFFFFFFFF00000000) != 0) {
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v2, v3, v4, v12, v10, *v10);
        }
        unint64_t v11 = (uint64_t *)((char *)v10 + v24 + 8);
        BOOL v25 = v12 == 0;
        if (v12) {
          uint64_t v12 = v12;
        }
        else {
          uint64_t v12 = 0;
        }
        if (!v25) {
          unint64_t v11 = (uint64_t *)((char *)v11 - v13);
        }
      }
      else
      {
        unint64_t v11 = (uint64_t *)(v10 + 2);
        uint64_t v13 = *v10;
        uint64_t v12 = v10[1];
      }
      unint64_t v14 = v12 * (unint64_t)v13;
      if ((v14 & 0xFFFFFFFF00000000) != 0) {
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v2, v3, v4, v12, v10, v13);
      }
      unint64_t v15 = (unint64_t)v10 + v14 + 8;
      if ((unint64_t)v11 < v15)
      {
        while ((*(void *)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v11 + 8) & 1) == 0)
        {
          unint64_t v11 = (uint64_t *)((char *)v11 + v13);
          unsigned int v16 = v13;
          if ((unint64_t)v11 >= v15) {
            goto LABEL_18;
          }
        }
      }
      unsigned int v16 = v13;
LABEL_18:
      if (v11 != (uint64_t *)v15)
      {
        int v17 = _read_images::PreoptTotalMethodLists;
        __n128 result = &OBJC_IVAR___Object_isa;
        do
        {
          uint64_t v18 = *v11 >> 16;
          _read_images::PreoptTotalMethodLists = ++v17;
          if ((~*(_DWORD *)((char *)v11 + v18) & 3) == 0) {
            ++_read_images::PreoptOptimizedMethodLists;
          }
          uint64_t v19 = *v10;
          unint64_t v20 = v19 * (unint64_t)v12;
          if ((v20 & 0xFFFFFFFF00000000) != 0) {
            _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v19, (const char *)v20, v4, v12, v10, *v10);
          }
          uint64_t v21 = v16;
          unint64_t v22 = (unint64_t)v10 + v20 + 8;
          uint64_t v23 = (uint64_t *)((char *)v11 + v16);
          do
          {
            unint64_t v11 = v23;
            if ((unint64_t)v23 >= v22) {
              break;
            }
            int v4 = *(char **)(objc_debug_headerInfoRWs + 8 * *(unsigned __int16 *)v23 + 8);
            uint64_t v23 = (uint64_t *)((char *)v23 + v21);
          }
          while ((v4 & 1) == 0);
          unsigned int v16 = v21;
        }
        while (v11 != (uint64_t *)v15);
      }
    }
  }
  return result;
}

void *objc::detail::DenseSetImpl<objc_class *,objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc::DenseMapInfo<objc_class *>>::begin(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (*(_DWORD *)(a1 + 8))
  {
    if (v2) {
      __n128 result = *(void **)a1;
    }
    else {
      __n128 result = 0;
    }
    uint64_t v4 = *(unsigned int *)(a1 + 16);
    if (v4)
    {
      uint64_t v5 = 8 * v4;
      uint64_t v6 = &result[v4];
      while (*result >= 0xFFFFFFFFFFFFFFFELL)
      {
        ++result;
        v5 -= 8;
        if (!v5) {
          return v6;
        }
      }
    }
  }
  else if (v2)
  {
    return &v2[*(unsigned int *)(a1 + 16)];
  }
  else
  {
    return (void *)(8 * *(unsigned int *)(a1 + 16));
  }
  return result;
}

void detach_class(objc_class *a1, char a2)
{
  uint64_t v15 = 0;
  if (objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::LookupBucketFor<objc_class *>((unint64_t)a1, &v15))
  {
    uint64_t v4 = (void *)v15;
    if (*(unsigned char *)(v15 + 16)) {
      free(*(void **)(v15 + 8));
    }
    *uint64_t v4 = -2;
    qword_1EB1CB0C0 = (uint64_t)vadd_s32((int32x2_t)qword_1EB1CB0C0, (int32x2_t)0x1FFFFFFFFLL);
    objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::compact();
  }
  if ((unint64_t)(*(void *)a1 - 1) >= 0xF)
  {
    uint64_t v5 = *((void *)a1 + 4);
    if ((*(_DWORD *)(v5 & 0xF00007FFFFFFFF8) & 0x80000000) != 0)
    {
      uint64_t v6 = (objc_class *)*((void *)a1 + 1);
      if (v6)
      {
        removeSubclass(v6, a1);
      }
      else
      {
        ++objc_debug_realized_class_generation_count;
        uint64_t v7 = &_firstRealizedClass;
        uint64_t v8 = (objc_class *)_firstRealizedClass;
        if ((objc_class *)_firstRealizedClass != a1)
        {
          do
          {
            uint64_t v9 = *((void *)v8 + 4);
            uint64_t v8 = *(objc_class **)((v9 & 0xF00007FFFFFFFF8) + 0x18);
          }
          while (v8 != a1);
          uint64_t v7 = (uint64_t *)((v9 & 0xF00007FFFFFFFF8) + 24);
        }
        *uint64_t v7 = *(void *)((v5 & 0xF00007FFFFFFFF8) + 0x18);
      }
    }
  }
  if ((a2 & 1) == 0)
  {
    uint64_t v10 = (const char *)objc_class::mangledName(a1);
    if ((objc_class *)getClassFromNamedClassTable(v10) == a1)
    {
      uint64_t v11 = gdb_objc_realized_classes;
      uint64_t v12 = (uint64_t)v10;
    }
    else
    {
      uint64_t v11 = nonMetaClasses();
      uint64_t v12 = *(void *)a1 & 0xFFFFFFFF8;
    }
    NXMapRemove(v11, v12);
  }
  uint64_t v15 = 0;
  if (objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::LookupBucketFor<objc_class *>((uint64_t)&objc::allocatedClasses, (unint64_t)a1, &v15))
  {
    *(void *)uint64_t v15 = -2;
    qword_1EB1CAE98 = (uint64_t)vadd_s32((int32x2_t)qword_1EB1CAE98, (int32x2_t)0x1FFFFFFFFLL);
    if (qword_1EB1CAE98)
    {
      if (qword_1EB1CAEA0 >= 0x401 && qword_1EB1CAEA0 >> 4 > qword_1EB1CAE98)
      {
        int v13 = 2 * qword_1EB1CAE98;
        objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::grow((uint64_t)&objc::allocatedClasses, v13);
      }
    }
    else if (qword_1EB1CAEA0)
    {
      if (objc::allocatedClasses) {
        unint64_t v14 = (void *)objc::allocatedClasses;
      }
      else {
        unint64_t v14 = 0;
      }
      free(v14);
      objc::allocatedClasses = 0;
      qword_1EB1CAE98 = 0;
      LODWORD(qword_1EB1CAEAfreeBuckets(table, 0) = 0;
    }
    else
    {
      qword_1EB1CAE98 = 0;
    }
  }
}

void free_class(objc_class *a1)
{
  if ((unint64_t)(*(void *)a1 - 1) < 0xF) {
    return;
  }
  unint64_t v1 = a1;
  int v3 = (char *)a1 + 32;
  uint64_t v2 = *((void *)a1 + 4);
  if ((*(_DWORD *)(v2 & 0xF00007FFFFFFFF8) & 0x80000000) == 0) {
    return;
  }
  uint64_t v4 = (class_rw_t *)(v2 & 0xF00007FFFFFFFF8);
  uint64_t v5 = *(void *)((v2 & 0xF00007FFFFFFFF8) + 8);
  if (v5) {
    uint64_t v6 = (unint64_t *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v6 = 0;
  }
  unint64_t v7 = class_rw_t::ro(v4);
  uint64_t v8 = (void *)((char *)v1 + 16);
  if (!cache_t::isConstantEmptyCache((objc_class *)((char *)v1 + 16))
    && (*v8 & 1) == 0
    && ((objc_cache *)*v8 == &_objc_empty_cache || HIWORD(*v8)))
  {
    if (PrintCaches)
    {
      uint64_t v12 = HIWORD(*v8);
      if (v12)
      {
        uint64_t v12 = HIWORD(*v8);
        if (v12)
        {
          unsigned int v13 = v12 + 1;
          unsigned int v14 = -1;
          do
          {
            unsigned int v15 = v14++;
            BOOL v16 = v13 > 3;
            v13 >>= 1;
          }
          while (v16);
          if (v14 > 0xE) {
            goto LABEL_18;
          }
          LODWORD(v12) = v15 + 2;
        }
      }
      --cache_counts[v12];
    }
LABEL_18:
    free((void *)(*v8 & 0xFFFFFFFFFFFLL));
  }
  int v72 = v4;
  if (!v6) {
    goto LABEL_59;
  }
  long long v71 = v6;
  int v17 = v6 + 1;
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::begin((uint64_t)v74, v6 + 1, v10, v11);
  list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::end((uint64_t)v73, v6 + 1, v18, v19);
  while (!list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator==((uint64_t)v74, v73))
  {
    unint64_t v20 = v75;
    uint64_t v21 = (void *)method_t::types((uint64_t)v75);
    if (v21)
    {
      BOOL v25 = v21;
      if (malloc_size(v21)) {
        free(v25);
      }
    }
    if (byte_1EB1CA568)
    {
      unint64_t v76 = 0;
      if (objc::DenseMapBase<objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>,method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::LookupBucketFor<method_t const*>((unint64_t)v20, &v76))
      {
        *unint64_t v76 = -2;
        int32x2_t v26 = vadd_s32((int32x2_t)qword_1EB1CA558, (int32x2_t)0x1FFFFFFFFLL);
        qword_1EB1CA558 = (uint64_t)v26;
        if (v26.i32[0])
        {
          if (dword_1EB1CA560 >= 0x401 && dword_1EB1CA560 >> 4 > v26.i32[0]) {
            objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::grow(2 * v26.i32[0]);
          }
        }
        else if (dword_1EB1CA560)
        {
          if (objc::methodDescriptionMap) {
            uint64_t v27 = (void *)objc::methodDescriptionMap;
          }
          else {
            uint64_t v27 = 0;
          }
          free(v27);
          objc::methodDescriptionMap = 0;
          qword_1EB1CA558 = 0;
          dword_1EB1CA560 = 0;
        }
        else
        {
          qword_1EB1CA558 = 0;
        }
      }
    }
    list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator++(v74, v22, v23, v24);
  }
  unint64_t v28 = *v17;
  uint64_t v4 = v72;
  if (!*v17) {
    goto LABEL_59;
  }
  if ((*v17 & 3) != 1)
  {
    BOOL v34 = v28 >= 4 && (*v17 & 3) == 0;
    uint64_t v29 = (_DWORD *)(v28 & 0xFFFFFFFFFFFFFFCLL);
    BOOL v35 = !v34 || v29 == 0;
    if (v35 || !malloc_size((const void *)(v28 & 0xFFFFFFFFFFFFFFCLL))) {
      goto LABEL_59;
    }
LABEL_58:
    free(v29);
    goto LABEL_59;
  }
  uint64_t v29 = (_DWORD *)(v28 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v28 & 0xFFFFFFFFFFFFFFFCLL) != 0)
  {
    if (*v29)
    {
      unint64_t v30 = 0;
      unint64_t v31 = v29 + 2;
      do
      {
        uint64_t v32 = *(void *)&v29[2 * v30 + 2];
        if (v32)
        {
          unint64_t v33 = (void *)(v32 & 0xFFFFFFFFFFFFFFFLL);
          if ((v32 & 0xFFFFFFFFFFFFFFFLL) != 0)
          {
            if (malloc_size((const void *)(v32 & 0xFFFFFFFFFFFFFFFLL))) {
              free(v33);
            }
          }
        }
        ++v30;
        v31 += 2;
      }
      while (v30 < *v29);
    }
    uint64_t v6 = v71;
    if (malloc_size(v29)) {
      goto LABEL_58;
    }
  }
LABEL_59:
  uint64_t v36 = *(unsigned int **)(v7 + 48);
  if (v36)
  {
    uint64_t v38 = *v36;
    uint64_t v37 = v36[1];
    unint64_t v39 = v37 * (unint64_t)v38;
    if ((v39 & 0xFFFFFFFF00000000) != 0) {
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v9, v10, v11, v37, *(void *)(v7 + 48), v38);
    }
    unint64_t v40 = v7;
    uint64_t v41 = v6;
    if (v39)
    {
      uint64_t v42 = 0;
      uint64_t v43 = v39;
      do
      {
        uint64_t v44 = *(void **)((char *)v36 + v42 + 8);
        if (v44 && malloc_size(*(const void **)((char *)v36 + v42 + 8))) {
          free(v44);
        }
        uint64_t v45 = *(void **)((char *)v36 + v42 + 16);
        if (v45 && malloc_size(*(const void **)((char *)v36 + v42 + 16))) {
          free(v45);
        }
        uint64_t v46 = *(void **)((char *)v36 + v42 + 24);
        if (v46 && malloc_size(*(const void **)((char *)v36 + v42 + 24))) {
          free(v46);
        }
        v42 += v38;
      }
      while (v43 != v42);
    }
    uint64_t v6 = v41;
    unint64_t v7 = v40;
    uint64_t v4 = v72;
    if (malloc_size(v36)) {
      free(v36);
    }
  }
  if (!v6) {
    goto LABEL_119;
  }
  uint64_t v47 = v6 + 2;
  list_array_tt<property_t,property_list_t,RawPtr>::begin(v74, v6 + 2, v10, v11);
  list_array_tt<property_t,property_list_t,RawPtr>::end(v73, v6 + 2, v48, v49);
  while (!list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::operator==((uint64_t)v74, v73))
  {
    BOOL v53 = v75;
    uint64_t v54 = *(void **)v75;
    if (*(void *)v75 && malloc_size(*(const void **)v75)) {
      free(v54);
    }
    uint64_t v55 = (void *)*((void *)v53 + 1);
    if (v55 && malloc_size(*((const void **)v53 + 1))) {
      free(v55);
    }
    list_array_tt<property_t,property_list_t,RawPtr>::iteratorImpl<false>::operator++(v74, v50, v51, v52);
  }
  unint64_t v56 = *v47;
  if (*v47)
  {
    if ((*v47 & 3) == 1)
    {
      unint64_t v57 = (_DWORD *)(v56 & 0xFFFFFFFFFFFFFFFCLL);
      if ((v56 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
        goto LABEL_104;
      }
      if (*v57)
      {
        unint64_t v58 = 0;
        do
        {
          uint64_t v59 = *(void *)&v57[2 * v58 + 2];
          uint64_t v60 = (void *)(v59 & 0xFFFFFFFFFFFFFFFLL);
          if ((v59 & 0xFFFFFFFFFFFFFFFLL) != 0 && malloc_size((const void *)(v59 & 0xFFFFFFFFFFFFFFFLL))) {
            free(v60);
          }
          ++v58;
        }
        while (v58 < *v57);
      }
    }
    else
    {
      BOOL v61 = v56 >= 4 && (*v47 & 3) == 0;
      unint64_t v57 = (_DWORD *)(v56 & 0xFFFFFFFFFFFFFFCLL);
      if (!v61 || v57 == 0) {
        goto LABEL_104;
      }
    }
    if (malloc_size(v57)) {
      free(v57);
    }
  }
LABEL_104:
  unint64_t v63 = v6[3];
  if (v63)
  {
    if ((v6[3] & 3) == 1)
    {
      unint64_t v64 = (_DWORD *)(v63 & 0xFFFFFFFFFFFFFFFCLL);
      if ((v63 & 0xFFFFFFFFFFFFFFFCLL) != 0)
      {
        if (*v64)
        {
          unint64_t v65 = 0;
          do
          {
            uint64_t v66 = *(void *)&v64[2 * v65 + 2];
            unint64_t v67 = (void *)(v66 & 0xFFFFFFFFFFFFFFFLL);
            if ((v66 & 0xFFFFFFFFFFFFFFFLL) != 0 && malloc_size((const void *)(v66 & 0xFFFFFFFFFFFFFFFLL))) {
              free(v67);
            }
            ++v65;
          }
          while (v65 < *v64);
        }
        goto LABEL_117;
      }
    }
    else if (v63 >= 4 && (v63 & 3) == 0)
    {
      unint64_t v64 = (_DWORD *)(v63 & 0xFFFFFFFFFFFFFFCLL);
      if ((v63 & 0xFFFFFFFFFFFFFFCLL) != 0)
      {
LABEL_117:
        if (malloc_size(v64)) {
          free(v64);
        }
      }
    }
  }
LABEL_119:
  if ((*(unsigned char *)v7 & 1) == 0)
  {
    uint64_t v68 = *(void **)(v7 + 16);
    if (v68)
    {
      if (malloc_size(*(const void **)(v7 + 16))) {
        free(v68);
      }
    }
  }
  unint64_t v69 = *(void **)(v7 + 56);
  if (v69 && malloc_size(*(const void **)(v7 + 56))) {
    free(v69);
  }
  if ((*((_WORD *)v1 + 15) & 4) == 0)
  {
    explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)(v7 + 24), memory_order_acquire);
    if (explicit)
    {
      if (malloc_size(explicit)) {
        free(explicit);
      }
    }
  }
  if (malloc_size((const void *)v7)) {
    free((void *)v7);
  }
  free(v6);
  free(v4);
  if ((*v3 & 2) != 0) {
    unint64_t v1 = (objc_class *)((char *)v1 - *((unsigned int *)v1 + 15));
  }
  if (malloc_size(v1)) {
    free(v1);
  }
}

void _method_setImplementationRawUnsafe(uint64_t a1, void (*a2)(void))
{
  if (a1) {
    uint64_t v3 = a1;
  }
  else {
    uint64_t v3 = 0;
  }
  int v4 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v4) {
    os_unfair_lock_lock_with_options();
  }
  method_t::setImp(v3, a2);
  int v6 = *(_DWORD *)(StatusReg + 24);
  int v7 = v6;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v7, 0, memory_order_release, memory_order_relaxed);
  if (v7 != v6)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
}

void sub_180140C14(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

__n128 __copy_helper_block_e8_32c43_ZTSKZ30method_exchangeImplementationsE3__0(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 32);
  long long v3 = *(_OWORD *)(a2 + 48);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v3;
  return result;
}

objc_property_t protocol_getProperty(Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty)
{
  Property_nolocuint64_t k = 0;
  if (proto && name)
  {
    BOOL v6 = isInstanceProperty;
    BOOL v7 = isRequiredProperty;
    int v9 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v9, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v9) {
      os_unfair_lock_lock_with_options();
    }
    Property_nolocuint64_t k = protocol_getProperty_nolock((protocol_t *)proto, name, (const char *)v7, (char *)v6);
    int v11 = *(_DWORD *)(StatusReg + 24);
    int v12 = v11;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v12, 0, memory_order_release, memory_order_relaxed);
    if (v12 != v11) {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
  }
  return (objc_property_t)Property_nolock;
}

void sub_180140D08(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

const char **protocol_getProperty_nolock(protocol_t *a1, const char *a2, const char *a3, char *a4)
{
  if (!a3) {
    return 0;
  }
  BOOL v4 = (char)a4;
  if (a4)
  {
    BOOL v7 = (unsigned int **)((char *)a1 + 56);
  }
  else
  {
    BOOL v7 = (unsigned int **)((char *)a1 + 88);
    if ((char *)a1 + *((unsigned int *)a1 + 16) <= (char *)a1 + 88) {
      goto LABEL_10;
    }
  }
  uint64_t v8 = *v7;
  if (!*v7
    || (int v9 = (const char **)(v8 + 2),
        uint64_t v10 = *v8,
        entsize_list_tt<property_t,property_list_t,0u,PointerModifierNop>::end(v8, (uint64_t)a2, a3, a4),
        v9 == v11))
  {
LABEL_10:
    unsigned int v13 = (unint64_t *)*((void *)a1 + 2);
    if (v13 && *v13)
    {
      unint64_t v14 = 0;
      while (1)
      {
        uint64_t v15 = v13[v14 + 1];
        int v16 = canonical_protocol ? 0 : 0x20000000;
        if ((v16 & *(_DWORD *)(v15 + 68)) == 0)
        {
          uint64_t Protocol = getProtocol(*(const char **)(v15 + 8));
          if (Protocol) {
            uint64_t v15 = Protocol;
          }
        }
        Property_nolocuint64_t k = protocol_getProperty_nolock((protocol_t *)v15, a2, 1, v4);
        if (Property_nolock) {
          break;
        }
        ++v14;
        unsigned int v13 = (unint64_t *)*((void *)a1 + 2);
        if (v14 >= *v13) {
          return 0;
        }
      }
      return (const char **)Property_nolock;
    }
    return 0;
  }
  int v12 = v11;
  while (strcmp(a2, *v9))
  {
    int v9 = (const char **)((char *)v9 + v10);
    if (v9 == v12) {
      goto LABEL_10;
    }
  }
  return v9;
}

Protocol *__cdecl objc_allocateProtocol(const char *name)
{
  int v2 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v2, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v2) {
    os_unfair_lock_lock_with_options();
  }
  if (getProtocol(name))
  {
    BOOL v4 = 0;
    goto LABEL_14;
  }
  int v5 = (Protocol *)malloc_type_calloc(0x60uLL, 1uLL, 0x59DDB3E2uLL);
  BOOL v4 = v5;
  if (DisableNonpointerIsa || (HIWORD(OBJC_CLASS_____IncompleteProtocol.vtable) & 0x2000) != 0)
  {
    if (((unint64_t)__IncompleteProtocol & 0xFF80000000000007) == 0)
    {
      unint64_t v9 = (unint64_t)__IncompleteProtocol & 0x7FFFFFFFFFFFF8;
      goto LABEL_11;
    }
LABEL_17:
    _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", v6, v7, v8, __IncompleteProtocol);
  }
  if (((unint64_t)__IncompleteProtocol & 0xFF80000000000007) != 0) {
    goto LABEL_17;
  }
  unint64_t v9 = (unint64_t)__IncompleteProtocol & 0x7FFFFFFFFFFFF8 | 0x100000000000001;
LABEL_11:
  v5->super.Class isa = (Class)v9;
  LODWORD(v5[8].super.isa) = 96;
  size_t v10 = strlen(name) + 1;
  if ((_dyld_is_memory_immutable() & 1) == 0)
  {
    int v11 = malloc_type_malloc(v10, 0x3F84A03uLL);
    memcpy(v11, name, v10);
    name = (const char *)v11;
  }
  v4[1].super.Class isa = (Class)name;
LABEL_14:
  int v12 = *(_DWORD *)(StatusReg + 24);
  int v13 = v12;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v13, 0, memory_order_release, memory_order_relaxed);
  if (v13 != v12) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return v4;
}

void sub_180140FF0(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void objc_registerProtocol(Protocol *proto)
{
  int v4 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v4) {
    os_unfair_lock_lock_with_options();
  }
  uint64_t v6 = (__objc2_class *)((uint64_t)proto->super.isa & 0xFFFFFFFF8);
  if (v6 == Protocol)
  {
    protocol_t::demangledName((char **)proto);
    _objc_inform("objc_registerProtocol: protocol '%s' was already registered!");
  }
  else if (v6 == __IncompleteProtocol)
  {
    objc_object::changeIsa((objc_object *)proto, (unint64_t)Protocol, v1, v2);
    if (!getProtocol((const char *)proto[1].super.isa))
    {
      unint64_t v9 = (uint64_t *)protocols();
      NXMapKeyCopyingInsert(v9, (const char *)proto[1].super.isa, (uint64_t)proto);
    }
  }
  else
  {
    protocol_t::demangledName((char **)proto);
    _objc_inform("objc_registerProtocol: protocol '%s' was not allocated with objc_allocateProtocol!");
  }
  int v7 = *(_DWORD *)(StatusReg + 24);
  int v8 = v7;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v8, 0, memory_order_release, memory_order_relaxed);
  if (v8 != v7)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
}

void sub_18014114C(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void protocol_addProtocol(Protocol *proto, Protocol *addition)
{
  if (proto && addition)
  {
    int v4 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v4) {
      os_unfair_lock_lock_with_options();
    }
    if ((__objc2_class *)((uint64_t)proto->super.isa & 0xFFFFFFFF8) == __IncompleteProtocol)
    {
      if ((__objc2_class *)((uint64_t)addition->super.isa & 0xFFFFFFFF8) == __IncompleteProtocol)
      {
        protocol_t::demangledName((char **)addition);
        _objc_inform("protocol_addProtocol: added protocol '%s' is still under construction!");
      }
      else
      {
        Class isa = proto[2].super.isa;
        if (isa) {
          int v7 = (objc_class *)malloc_type_realloc(isa, 8 * *(void *)isa + 16, 0x89BCB4C0uLL);
        }
        else {
          int v7 = (objc_class *)malloc_type_calloc(1uLL, 0x10uLL, 0xD9C3E683uLL);
        }
        uint64_t v8 = (*(void *)v7)++;
        *((void *)v7 + v8 + freeBuckets(table, 1) = addition;
        proto[2].super.Class isa = v7;
      }
    }
    else
    {
      protocol_t::demangledName((char **)proto);
      _objc_inform("protocol_addProtocol: modified protocol '%s' is not under construction!");
    }
    int v9 = *(_DWORD *)(StatusReg + 24);
    int v10 = v9;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v10, 0, memory_order_release, memory_order_relaxed);
    if (v10 != v9)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
  }
}

void sub_1801412D0(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void protocol_addMethodDescription(Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod)
{
  if (proto)
  {
    BOOL v6 = isRequiredMethod;
    int v7 = types;
    int v10 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v10, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v10) {
      os_unfair_lock_lock_with_options();
    }
    if ((__objc2_class *)((uint64_t)proto->super.isa & 0xFFFFFFFF8) == __IncompleteProtocol)
    {
      if (!v6 || !isInstanceMethod)
      {
        if (!isInstanceMethod || v6) {
          unint64_t v14 = proto + 6;
        }
        else {
          unint64_t v14 = proto + 5;
        }
        if (!v6 || isInstanceMethod) {
          int v13 = v14;
        }
        else {
          int v13 = proto + 4;
        }
      }
      else
      {
        int v13 = proto + 3;
      }
      Class isa = v13->super.isa;
      if (v13->super.isa)
      {
        uint64_t v16 = *isa & 0xFFFCLL;
        unint64_t v17 = isa[1] * (unint64_t)v16;
        if ((v17 & 0xFFFFFFFF00000000) != 0) {
          _objc_fatal("entsize_list_tt overflow: count %u with entsize %u", (uint64_t)name, types, (char *)isRequiredMethod, isa[1], v16);
        }
        uint64_t v18 = (unsigned int *)malloc_type_realloc(isa, v16 + v17 + 8, 0x4755E9A6uLL);
        v13->super.Class isa = (Class)v18;
      }
      else
      {
        uint64_t v18 = (unsigned int *)malloc_type_calloc(0x20uLL, 1uLL, 0x8B7F0322uLL);
        v13->super.Class isa = (Class)v18;
        *uint64_t v18 = 24;
      }
      uint64_t v21 = v18[1];
      v18[1] = v21 + 1;
      uint64_t v22 = (void *)(entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::get(v18, v21, v19, v20) & 0xFFFFFFFFFFFFFFFCLL);
      *uint64_t v22 = name;
      if (v7)
      {
        size_t v23 = strlen(v7) + 1;
        if ((_dyld_is_memory_immutable() & 1) == 0)
        {
          unint64_t v24 = malloc_type_malloc(v23, 0x3F84A03uLL);
          memcpy(v24, v7, v23);
          int v7 = (const char *)v24;
        }
      }
      else
      {
        int v7 = "";
      }
      v22[1] = v7;
      v22[2] = 0;
    }
    else
    {
      int v12 = (const char *)protocol_t::demangledName((char **)proto);
      _objc_inform("protocol_addMethodDescription: protocol '%s' is not under construction!", v12);
    }
    int v25 = *(_DWORD *)(StatusReg + 24);
    int v26 = v25;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v26, 0, memory_order_release, memory_order_relaxed);
    if (v26 != v25)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
  }
}

void sub_180141514(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void protocol_addProperty(Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
{
  if (!proto) {
    return;
  }
  BOOL v6 = name;
  if (!name) {
    return;
  }
  BOOL v7 = isInstanceProperty;
  BOOL v8 = isRequiredProperty;
  int v12 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v12, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v12) {
    os_unfair_lock_lock_with_options();
  }
  if ((__objc2_class *)((uint64_t)proto->super.isa & 0xFFFFFFFF8) != __IncompleteProtocol)
  {
    unint64_t v14 = (const char *)protocol_t::demangledName((char **)proto);
    _objc_inform("protocol_addProperty: protocol '%s' is not under construction!", v14);
    goto LABEL_21;
  }
  if (v8 && v7)
  {
    uint64_t v15 = proto + 7;
LABEL_13:
    Class isa = (unsigned int *)v15->super.isa;
    if (v15->super.isa)
    {
      uint64_t v17 = *isa;
      uint64_t v18 = isa[1] + 1;
      isa[1] = v18;
      unint64_t v19 = v17 * (unint64_t)v18;
      if ((v19 & 0xFFFFFFFF00000000) != 0) {
        _objc_fatal("entsize_list_tt overflow: count %u with entsize %u", (uint64_t)name, (const char *)attributes, *(char **)&attributeCount, v18, v17);
      }
      size_t v23 = (objc_class *)malloc_type_realloc(isa, v19 + 8, 0x216364AEuLL);
      v15->super.Class isa = v23;
      uint64_t v24 = *(unsigned int *)v23;
      uint64_t v25 = (*((_DWORD *)v23 + 1) - 1);
    }
    else
    {
      size_t v23 = (objc_class *)malloc_type_calloc(0x18uLL, 1uLL, 0xEE94C62CuLL);
      uint64_t v25 = 0;
      v15->super.Class isa = v23;
      *(void *)size_t v23 = 0x100000010;
      uint64_t v24 = 16;
    }
    unint64_t v26 = v25 * (unint64_t)v24;
    if ((v26 & 0xFFFFFFFF00000000) != 0) {
      _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v20, v21, v22, v25, v23, v24);
    }
    size_t v27 = strlen(v6) + 1;
    if ((_dyld_is_memory_immutable() & 1) == 0)
    {
      unint64_t v28 = malloc_type_malloc(v27, 0x3F84A03uLL);
      memcpy(v28, v6, v27);
      BOOL v6 = (const char *)v28;
    }
    uint64_t v29 = (char *)v23 + v26;
    *((void *)v29 + freeBuckets(table, 1) = v6;
    *((void *)v29 + 2) = copyPropertyAttributeString((uint64_t)attributes, attributeCount);
    goto LABEL_21;
  }
  if (v8 && !v7)
  {
    uint64_t v15 = proto + 11;
    goto LABEL_13;
  }
LABEL_21:
  int v30 = *(_DWORD *)(StatusReg + 24);
  int v31 = v30;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v31, 0, memory_order_release, memory_order_relaxed);
  if (v31 != v30)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
}

void sub_180141778(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _objc_getRealizedClassList_trylock(objc_class **a1, uint64_t a2)
{
  if (!os_unfair_lock_trylock((os_unfair_lock_t)runtimeLock)) {
    return -1;
  }
  RealizedClassList_nolocuint64_t k = objc_getRealizedClassList_nolock(a1, a2, v4, v5);
  int v7 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  int v8 = v7;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v8, 0, memory_order_release, memory_order_relaxed);
  if (v8 != v7) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return RealizedClassList_nolock;
}

uint64_t objc_getRealizedClassList_nolock(objc_class **a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v9 = 0;
  if (a1)
  {
    uint64_t v8 = 0;
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 3321888768;
    v7[2] = ___ZL32objc_getRealizedClassList_nolockPP10objc_classm_block_invoke;
    v7[3] = &__block_descriptor_64_e8_32c61_ZTSKZL32objc_getRealizedClassList_nolockPP10objc_classmE3__0_e8_B16__0_8l;
    v7[4] = &v9;
    v7[5] = &v8;
    v7[6] = a2;
    v7[7] = a1;
    int v4 = v7;
  }
  else
  {
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3321888768;
    v6[2] = ___ZL32objc_getRealizedClassList_nolockPP10objc_classm_block_invoke_171;
    v6[3] = &__block_descriptor_40_e8_32c61_ZTSKZL32objc_getRealizedClassList_nolockPP10objc_classmE3__1_e8_B16__0_8l;
    v6[4] = &v9;
    int v4 = v6;
  }
  foreach_realized_class((uint64_t)v4, a2, a3, a4);
  return v9;
}

uint64_t ___ZL32objc_getRealizedClassList_nolockPP10objc_classm_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 40);
  ++**(void **)(a1 + 32);
  uint64_t v3 = *v2;
  if ((unint64_t)*v2 < *(void *)(a1 + 48))
  {
    uint64_t v4 = *(void *)(a1 + 56);
    *uint64_t v2 = v3 + 1;
    *(void *)(v4 + 8 * v3) = a2;
  }
  return 1;
}

uint64_t ___ZL32objc_getRealizedClassList_nolockPP10objc_classm_block_invoke_171(uint64_t a1)
{
  return 1;
}

uint64_t __copy_helper_block_e8_32c61_ZTSKZL32objc_getRealizedClassList_nolockPP10objc_classmE3__1(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = *(void *)(a2 + 32);
  return result;
}

__n128 __copy_helper_block_e8_32c61_ZTSKZL32objc_getRealizedClassList_nolockPP10objc_classmE3__0(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 32);
  long long v3 = *(_OWORD *)(a2 + 48);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v3;
  return result;
}

int objc_getClassList(Class *buffer, int bufferCount)
{
  int v4 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v4) {
    os_unfair_lock_lock_with_options();
  }
  realizeAllClasses();
  RealizedClassList_nolocuint64_t k = objc_getRealizedClassList_nolock(buffer, bufferCount, v6, v7);
  int v9 = *(_DWORD *)(StatusReg + 24);
  int v10 = v9;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v10, 0, memory_order_release, memory_order_relaxed);
  if (v10 != v9) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return RealizedClassList_nolock;
}

void sub_1801419FC(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void *objc_copyRealizedClassList(unsigned int *a1, uint64_t a2, const char *a3, char *a4)
{
  int v5 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v5, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v5) {
    os_unfair_lock_lock_with_options();
  }
  int v7 = objc_copyRealizedClassList_nolock(a1, a2, a3, a4);
  int v8 = *(_DWORD *)(StatusReg + 24);
  int v9 = v8;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v9, 0, memory_order_release, memory_order_relaxed);
  if (v9 != v8) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return v7;
}

void sub_180141AB0(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

Class *__cdecl objc_copyClassList(unsigned int *outCount)
{
  int v2 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v2, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v2) {
    os_unfair_lock_lock_with_options();
  }
  realizeAllClasses();
  int v7 = (Class *)objc_copyRealizedClassList_nolock(outCount, v4, v5, v6);
  int v8 = *(_DWORD *)(StatusReg + 24);
  int v9 = v8;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v9, 0, memory_order_release, memory_order_relaxed);
  if (v9 != v8) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return v7;
}

void sub_180141B68(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void _objc_beginClassEnumeration(uint64_t a1, char *__s, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(void *)a5 = a1;
  *(void *)(a5 + 8) = __s;
  *(void *)(a5 + 16) = a3;
  *(void *)(a5 + 24) = a4;
  if (__s) {
    *(void *)(a5 + 32) = strlen(__s);
  }
  if (a1 == -1)
  {
    int v7 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v7, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v7) {
      os_unfair_lock_lock_with_options();
    }
    uint64_t v22 = 0;
    size_t size = 0;
    unsigned int v24 = qword_1EB1CAEA0;
    if (qword_1EB1CAEA0)
    {
      int v9 = (char *)malloc_type_malloc(8 * qword_1EB1CAEA0, 0x64B88C75uLL);
      if (v9) {
        uint64_t v22 = v9;
      }
      else {
        uint64_t v22 = 0;
      }
      size_t size = qword_1EB1CAE98;
      if (objc::allocatedClasses) {
        int v11 = (const void *)objc::allocatedClasses;
      }
      else {
        int v11 = 0;
      }
      memcpy(v9, v11, 8 * v24);
      size_t v10 = size;
    }
    else
    {
      size_t v10 = 0;
      uint64_t v22 = 0;
      size_t size = 0;
    }
    int v12 = malloc_type_calloc(8uLL, v10, 0x9CB45D16uLL);
    int v13 = (char *)objc::detail::DenseSetImpl<objc_class *,objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc::DenseMapInfo<objc_class *>>::begin((uint64_t)&v22);
    uint64_t v15 = &v22[8 * v24];
    if (v15 == v13)
    {
      uint64_t v16 = 0;
    }
    else
    {
      uint64_t v16 = 0;
      do
      {
        if ((*(_DWORD *)(*(void *)(*(void *)v13 + 32) & 0xF00007FFFFFFFF8) & 0x2000001) == 0x2000000) {
          v12[v16++] = *(void *)v13;
        }
        while (1)
        {
          v13 += 8;
          if (v13 == v14) {
            break;
          }
          if (*(void *)v13 < 0xFFFFFFFFFFFFFFFELL) {
            goto LABEL_23;
          }
        }
        int v13 = v14;
LABEL_23:
        ;
      }
      while (v13 != v15);
    }
    uint64_t v17 = malloc_type_realloc(v12, 8 * v16, 0x80040B8603338uLL);
    if (v17) {
      uint64_t v18 = v17;
    }
    else {
      uint64_t v18 = v12;
    }
    *(void *)(a5 + 4freeBuckets(table, 0) = v18;
    *(void *)(a5 + 48) = 0;
    *(void *)(a5 + 56) = v16;
    if (v22) {
      unint64_t v19 = v22;
    }
    else {
      unint64_t v19 = 0;
    }
    free(v19);
    int v20 = *(_DWORD *)(StatusReg + 24);
    int v21 = v20;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v21, 0, memory_order_release, memory_order_relaxed);
    if (v21 != v20) {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
  }
}

void sub_180141E94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  int v13 = *(_DWORD *)(v11 + 24);
  int v14 = v13;
  atomic_compare_exchange_strong_explicit(v10, (unsigned int *)&v14, 0, memory_order_release, memory_order_relaxed);
  if (v14 != v13) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void *_objc_enumerateNextClass(uint64_t a1)
{
  int v2 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v2, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v2) {
    os_unfair_lock_lock_with_options();
  }
  if (*(void *)(a1 + 40))
  {
    unint64_t v4 = *(void *)(a1 + 48);
  }
  else
  {
    BOOL v6 = (void *)FirstHeader;
    if (!FirstHeader) {
      goto LABEL_90;
    }
    uint64_t v46 = *(void **)a1;
    while (v46 != (void *)((char *)v6 + *v6))
    {
      uint64_t PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v6);
      uint64_t v48 = v6 + 3;
      if (PreoptimizedHeaderRW) {
        uint64_t v48 = (void *)PreoptimizedHeaderRW;
      }
      BOOL v6 = (void *)(*v48 & 0xFFFFFFFFFFFFFFFCLL);
      if (!v6) {
        goto LABEL_90;
      }
    }
    uint64_t v49 = header_info::classlist((header_info *)v6, (unint64_t *)(a1 + 56));
    *(void *)(a1 + 4freeBuckets(table, 0) = v49;
    if (!v49)
    {
LABEL_89:
      BOOL v6 = 0;
      goto LABEL_90;
    }
    unint64_t v4 = 0;
    *(void *)(a1 + 48) = 0;
  }
  if (v4 >= *(void *)(a1 + 56)) {
    goto LABEL_89;
  }
  unint64_t v56 = StatusReg;
  while (2)
  {
    *(void *)(a1 + 48) = v4 + 1;
    int v5 = (objc_class *)remapClass(*(void *)(*(void *)(a1 + 40) + 8 * v4));
    BOOL v6 = v5;
    if (!v5) {
      goto LABEL_10;
    }
    if (*(void *)(a1 + 8))
    {
      int v7 = (const void *)objc_class::demangledName(v5, 0);
      if (memcmp(v7, *(const void **)(a1 + 8), *(void *)(a1 + 32))) {
        goto LABEL_10;
      }
    }
    int v8 = *(const char ***)(a1 + 16);
    if (!v8) {
      goto LABEL_70;
    }
    int v9 = v6;
    while (1)
    {
      v60[0] = 0;
      if ((unint64_t)(*v9 - 1) >= 0xF && (*(_DWORD *)(v9[4] & 0xF00007FFFFFFFF8) & 0x80000000) != 0)
      {
        class_rw_t::protocols((unint64_t *)v58, v9[4] & 0xF00007FFFFFFFF8);
        v60[0] = (unint64_t)v58[0];
        goto LABEL_26;
      }
      uint64_t v12 = *(void *)(class_data_bits_t::safe_ro<(Authentication)0>(v9 + 4) + 40);
      unint64_t v13 = v12 & 0xFFFFFFFFFFFFFFFELL;
      if ((v12 & 1) == 0 && v13) {
        goto LABEL_24;
      }
      uint64_t v14 = v12 & 1;
      if (v13) {
        BOOL v15 = v14 == 0;
      }
      else {
        BOOL v15 = 1;
      }
      if (!v15)
      {
        v13 |= 2uLL;
LABEL_24:
        unint64_t v16 = v13;
        goto LABEL_25;
      }
      unint64_t v16 = 0;
LABEL_25:
      v60[0] = v16;
LABEL_26:
      list_array_tt<unsigned long,protocol_list_t,RawPtr>::begin(v58, v60, v10, v11);
      list_array_tt<unsigned long,protocol_list_t,RawPtr>::end(v57, v60, v17, v18);
      while ((list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::operator==((uint64_t)v58, v57) & 1) == 0)
      {
        unint64_t v19 = *v59;
        if (canonical_protocol) {
          int v20 = 0;
        }
        else {
          int v20 = 0x20000000;
        }
        if ((v20 & *((_DWORD *)*v59 + 17)) == 0)
        {
          uint64_t Protocol = getProtocol(v19[1]);
          if (Protocol) {
            unint64_t v19 = (const char **)Protocol;
          }
        }
        if (v19 == v8 || (protocol_conformsToProtocol_nolock((protocol_t *)v19, v8) & 1) != 0) {
          goto LABEL_70;
        }
        list_array_tt<unsigned long,protocol_list_t,RawPtr>::iteratorImpl<false>::operator++(v58, v22, v23, v24);
      }
      if ((unint64_t)(*v9 - 1) < 0xF)
      {
        char v55 = 0;
        goto LABEL_42;
      }
      int v25 = *(_DWORD *)(v9[4] & 0xF00007FFFFFFFF8);
      if ((v25 & 0x80000000) == 0) {
        break;
      }
LABEL_65:
      if (v9[1]) {
        unint64_t v43 = v9[1];
      }
      else {
        unint64_t v43 = 0;
      }
      int v9 = (void *)remapClass(v43);
      if (!v9) {
        goto LABEL_10;
      }
    }
    char v55 = v25 & 1;
LABEL_42:
    uint64_t v26 = objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::find((unint64_t)v9);
    if (objc::unattachedCategories + 24 * dword_1EB1CB0C8 == v26) {
      goto LABEL_65;
    }
    uint64_t v28 = *(void *)(v26 + 8);
    uint64_t v29 = *(void *)(v26 + 16);
    uint64_t v27 = v26 + 8;
    unsigned int v30 = v29 >> 1;
    BOOL v31 = (v29 & 1) == 0;
    uint64_t v32 = (v29 & 1) != 0 ? v28 : v27;
    uint64_t v33 = v31 ? v28 != 0 : v30;
    uint64_t v53 = v33;
    uint64_t v54 = v32;
    if (!v33) {
      goto LABEL_65;
    }
    uint64_t v34 = 0;
    while (1)
    {
      if ((v55 & 1) == 0)
      {
        BOOL v35 = *(void **)(*(void *)(v54 + 16 * v34) + 32);
        if (v35)
        {
          uint64_t v38 = *v35;
          uint64_t v37 = (const char ***)(v35 + 1);
          uint64_t v36 = v38;
          if (v38) {
            break;
          }
        }
      }
LABEL_64:
      if (++v34 == v53) {
        goto LABEL_65;
      }
    }
    uint64_t v39 = 8 * v36;
    while (1)
    {
      unint64_t v40 = *v37;
      if (canonical_protocol) {
        int v41 = 0;
      }
      else {
        int v41 = 0x20000000;
      }
      if ((v41 & *((_DWORD *)*v37 + 17)) == 0)
      {
        uint64_t v42 = getProtocol(v40[1]);
        if (v42) {
          unint64_t v40 = (const char **)v42;
        }
      }
      if (v40 == v8 || (protocol_conformsToProtocol_nolock((protocol_t *)v40, v8) & 1) != 0) {
        break;
      }
      ++v37;
      v39 -= 8;
      if (!v39) {
        goto LABEL_64;
      }
    }
LABEL_70:
    if (*(void *)(a1 + 24))
    {
      if (v6[1]) {
        unint64_t v44 = v6[1];
      }
      else {
        unint64_t v44 = 0;
      }
      while (1)
      {
        unint64_t v45 = remapClass(v44);
        if (!v45) {
          break;
        }
        if (v45 == *(void *)(a1 + 24)) {
          goto LABEL_86;
        }
        if (*(void *)(v45 + 8)) {
          unint64_t v44 = *(void *)(v45 + 8);
        }
        else {
          unint64_t v44 = 0;
        }
      }
LABEL_10:
      unint64_t v4 = *(void *)(a1 + 48);
      if (v4 >= *(void *)(a1 + 56))
      {
        BOOL v6 = 0;
        unint64_t StatusReg = v56;
        goto LABEL_90;
      }
      continue;
    }
    break;
  }
LABEL_86:
  unint64_t StatusReg = v56;
  realizeClassMaybeSwiftMaybeRelock(v6, 1);
LABEL_90:
  int v50 = *(_DWORD *)(StatusReg + 24);
  int v51 = v50;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v51, 0, memory_order_release, memory_order_relaxed);
  if (v51 != v50) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return v6;
}

void sub_180142484(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  int v16 = *(_DWORD *)(v14 + 24);
  int v17 = v16;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v17, 0, memory_order_release, memory_order_relaxed);
  if (v17 != v16) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void _objc_endClassEnumeration(uint64_t a1)
{
  if (*(void *)a1 == -1) {
    free(*(void **)(a1 + 40));
  }
}

void objc_enumerateClasses(const void *image, const char *namePrefix, Protocol *conformingTo, Class subclassing, void *block)
{
  if (image != (const void *)-1)
  {
    int v9 = image;
    if (image)
    {
      image = (const void *)_dyld_get_dlopen_image_header();
      if (!image)
      {
        uint64_t v11 = dyld_image_header_containing_address();
        if (!v9 || (uint64_t v12 = (const void *)v11, image = v9, v12 != v9))
        {
          size_t v10 = "unable to find mach header for image";
          goto LABEL_15;
        }
      }
    }
    else
    {
      image = (const void *)dyld_image_header_containing_address();
      if (!image)
      {
        size_t v10 = "unable to find caller's image";
LABEL_15:
        _objc_inform(v10);
        return;
      }
    }
  }
  _objc_beginClassEnumeration((uint64_t)image, (char *)namePrefix, (uint64_t)conformingTo, (uint64_t)subclassing, (uint64_t)v15);
  char v14 = 0;
  do
  {
    uint64_t Class = _objc_enumerateNextClass((uint64_t)v15);
    if (!Class) {
      break;
    }
    (*((void (**)(void *, void *, char *))block + 2))(block, Class, &v14);
  }
  while (!v14);
  if (v15[0] == -1) {
    free((void *)v15[5]);
  }
}

unint64_t _objc_setHook_msgSendCacheMiss(unint64_t result, uint64_t *a2)
{
  uint64_t v2 = msgSendCacheMissHook;
  if (msgSendCacheMissHook) {
    goto LABEL_3;
  }
  uint64_t v3 = 0;
  while (1)
  {
    if (v3)
    {
      *a2 = v3;
      if (result) {
        goto LABEL_6;
      }
    }
    else
    {
      *a2 = 0;
      if (result)
      {
LABEL_6:
        unint64_t v4 = result;
        goto LABEL_9;
      }
    }
    unint64_t v4 = 0;
LABEL_9:
    uint64_t v2 = v3;
    atomic_compare_exchange_strong_explicit(&msgSendCacheMissHook, (unint64_t *)&v2, v4, memory_order_release, memory_order_relaxed);
    if (v2 == v3) {
      return result;
    }
    uint64_t v3 = 0;
    if (v2) {
LABEL_3:
    }
      uint64_t v3 = v2;
  }
}

char *class_copyImpCache(uint64_t a1, _DWORD *a2)
{
  int v4 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v4) {
    os_unfair_lock_lock_with_options();
  }
  uint64_t v6 = *(unsigned __int16 *)(a1 + 28);
  if (*(_WORD *)(a1 + 28))
  {
    int v7 = (char *)malloc_type_calloc(v6 + 1, 0x10uLL, 0x80040803F642BuLL);
    int v8 = v7;
    int v9 = (void *)(a1 + 16);
    size_t v10 = *(objc_cache **)(a1 + 16);
    if ((v10 & 1) == 0 && (v10 == &_objc_empty_cache || HIWORD(*v9)))
    {
      if (HIWORD(*v9))
      {
        unint64_t v21 = 0;
        int v22 = 0;
        unint64_t v23 = HIWORD(*v9);
        unsigned int v24 = (void *)((*v9 & 0xFFFFFFFFFFFLL) + 8);
        do
        {
          if (*v24)
          {
            int v25 = &v7[16 * v22];
            *((void *)v25 + freeBuckets(table, 1) = *(v24 - 1);
            *(void *)int v25 = *v24;
            ++v22;
          }
          if (v21 >= v23) {
            break;
          }
          ++v21;
          v24 += 2;
        }
        while (v22 < (int)v6);
      }
    }
    else
    {
      uint64_t v11 = 0;
      uint64_t v12 = *v9 & 0x7FFFFFFFFFFFFELL;
      unint64_t v13 = (unint64_t)*(unsigned __int16 *)(v12 - 8) >> 5;
      if (v13 >= (v6 - 1)) {
        unint64_t v13 = (v6 - 1);
      }
      uint64_t v14 = 16 * v13 + 16;
      BOOL v15 = (uint64_t *)(*v9 & 0x7FFFFFFFFFFFFELL);
      do
      {
        int v16 = &v7[v11];
        *(void *)int v16 = (unint64_t)*v15 >> 38;
        uint64_t v17 = *v15++;
        *((void *)v16 + freeBuckets(table, 1) = v12 - (v17 << 26 >> 24);
        v11 += 16;
      }
      while (v14 != v11);
    }
  }
  else
  {
    int v8 = 0;
  }
  if (a2) {
    *a2 = v6;
  }
  int v18 = *(_DWORD *)(StatusReg + 24);
  int v19 = v18;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v19, 0, memory_order_release, memory_order_relaxed);
  if (v19 != v18) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return v8;
}

void sub_180142914(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

Protocol **__cdecl objc_copyProtocolList(unsigned int *outCount)
{
  int v2 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v2, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v2) {
    os_unfair_lock_lock_with_options();
  }
  atomic_ullong v4 = protocols();
  unint64_t v40 = 0;
  int32x2_t v41 = 0;
  unsigned int v42 = 0;
  int v5 = (header_info *)FirstHeader;
  if (FirstHeader)
  {
    do
    {
      unint64_t v39 = 0;
      uint64_t v6 = header_info::protocollist(v5, &v39);
      unint64_t v7 = v39;
      if (v39)
      {
        uint64_t v8 = v6;
        do
        {
          uint64_t v9 = *(void *)v8;
          if (!NXMapGet((uint64_t *)v4, *(void *)(*(void *)v8 + 8)))
          {
            Preoptimizeduint64_t Protocol = getPreoptimizedProtocol();
            uint64_t v11 = *(char **)(v9 + 8);
            unint64_t v43 = 0;
            if (!objc::DenseMapBase<objc::DenseMap<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>,char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>::LookupBucketFor<char const*>((uint64_t)&v40, v11, &v43))
            {
              if (4 * v41.i32[0] + 4 >= 3 * v42)
              {
                objc::DenseMap<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>::grow((uint64_t)&v40, 2 * v42);
                unint64_t v43 = 0;
                objc::DenseMapBase<objc::DenseMap<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>,char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>::LookupBucketFor<char const*>((uint64_t)&v40, v11, &v43);
              }
              else if (v42 + ~v41.i32[0] - v41.i32[1] <= v42 >> 3)
              {
                objc::DenseMap<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>::grow((uint64_t)&v40, v42);
                unint64_t v43 = 0;
                objc::DenseMapBase<objc::DenseMap<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>,char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>::LookupBucketFor<char const*>((uint64_t)&v40, v11, &v43);
              }
              uint64_t v12 = v43;
              unint64_t v13 = *v43;
              if (objc::DenseMapInfo<char const*>::isEqual(*v43, (char *)0xFFFFFFFFFFFFFFFFLL))
              {
                ++v41.i32[0];
              }
              else if (objc::DenseMapInfo<char const*>::isEqual(v13, (char *)0xFFFFFFFFFFFFFFFELL))
              {
                int32x2_t v41 = vadd_s32(v41, (int32x2_t)0xFFFFFFFF00000001);
              }
              *uint64_t v12 = v11;
              v12[1] = (char *)PreoptimizedProtocol;
            }
          }
          v8 += 8;
          --v7;
        }
        while (v7);
      }
      uint64_t PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v5);
      BOOL v15 = (void *)((char *)v5 + 24);
      if (PreoptimizedHeaderRW) {
        BOOL v15 = (void *)PreoptimizedHeaderRW;
      }
      int v5 = (header_info *)(*v15 & 0xFFFFFFFFFFFFFFFCLL);
    }
    while (v5);
    __int32 v16 = v41.i32[0];
  }
  else
  {
    __int32 v16 = 0;
  }
  unsigned int v17 = v16 + *(_DWORD *)(v4 + 8);
  if (!v17)
  {
    int v19 = 0;
    if (!outCount) {
      goto LABEL_49;
    }
    unsigned int v17 = 0;
    goto LABEL_48;
  }
  int v18 = (Protocol **)malloc_type_malloc(8 * (v17 + 1), 0x80040B8603338uLL);
  int v19 = v18;
  int v20 = 0;
  int v21 = *(_DWORD *)(v4 + 12) + 1;
LABEL_26:
  uint64_t v22 = *(void *)(v4 + 16);
  uint64_t v23 = v21;
  unsigned int v24 = (uint64_t *)(v22 + 16 * v21 - 16);
  while (v23)
  {
    --v23;
    uint64_t v25 = *v24;
    v24 -= 2;
    if (v25 != -1)
    {
      v18[v20++] = *(Protocol **)(v22 + 16 * v23 + 8);
      int v21 = v23;
      goto LABEL_26;
    }
  }
  uint64_t v26 = v40;
  if (v41.i32[0])
  {
    if (v40) {
      uint64_t v27 = v40;
    }
    else {
      uint64_t v27 = 0;
    }
    unsigned int v31 = v42;
    unint64_t v43 = v27;
    unint64_t v44 = &v27[2 * v42];
    objc::DenseMapIterator<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>,false>::AdvancePastEmptyBuckets(&v43);
    unsigned int v30 = v43;
    uint64_t v32 = v44;
  }
  else
  {
    if (v40)
    {
      uint64_t v28 = v40;
      uint64_t v29 = v42;
      unsigned int v30 = &v40[2 * v42];
    }
    else
    {
      uint64_t v28 = 0;
      uint64_t v29 = v42;
      unsigned int v30 = (char **)(16 * v42);
    }
    unsigned int v31 = v29;
    uint64_t v32 = &v28[2 * v29];
  }
  unint64_t v44 = v32;
  if (v26) {
    uint64_t v33 = v26;
  }
  else {
    uint64_t v33 = 0;
  }
  uint64_t v34 = &v33[2 * v31];
  while (v30 != v34)
  {
    v19[v20] = (Protocol *)v30[1];
    unint64_t v43 = v30 + 2;
    objc::DenseMapIterator<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>,false>::AdvancePastEmptyBuckets(&v43);
    unsigned int v30 = v43;
    ++v20;
  }
  v19[v20] = 0;
  if (outCount) {
LABEL_48:
  }
    *outCount = v17;
LABEL_49:
  if (v40) {
    BOOL v35 = v40;
  }
  else {
    BOOL v35 = 0;
  }
  free(v35);
  int v36 = *(_DWORD *)(StatusReg + 24);
  int v37 = v36;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v37, 0, memory_order_release, memory_order_relaxed);
  if (v37 != v36) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return v19;
}

void sub_180142D44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  if (a10) {
    uint64_t v12 = a10;
  }
  else {
    uint64_t v12 = 0;
  }
  free(v12);
  int v13 = *(_DWORD *)(v10 + 24);
  int v14 = v13;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v14, 0, memory_order_release, memory_order_relaxed);
  if (v14 != v13) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(a1);
}

char ***objc::DenseMapIterator<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>,false>::AdvancePastEmptyBuckets(char ***result)
{
  unint64_t v1 = *result;
  int v2 = result[1];
  if (*result != v2)
  {
    uint64_t v3 = result;
    do
    {
      atomic_ullong v4 = *v1;
      __n128 result = (char ***)objc::DenseMapInfo<char const*>::isEqual(*v1, (char *)0xFFFFFFFFFFFFFFFFLL);
      if ((result & 1) == 0)
      {
        __n128 result = (char ***)objc::DenseMapInfo<char const*>::isEqual(v4, (char *)0xFFFFFFFFFFFFFFFELL);
        if (!result) {
          break;
        }
      }
      v1 += 2;
      *uint64_t v3 = v1;
    }
    while (v1 != v2);
  }
  return result;
}

BOOL objc::DenseMapBase<objc::DenseMap<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>,char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>::LookupBucketFor<char const*>(uint64_t a1, char *__s1, char ***a3)
{
  if (*(void *)a1) {
    uint64_t v6 = *(void **)a1;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(unsigned int *)(a1 + 16);
  if (v7)
  {
    unsigned int v8 = 0;
    uint64_t v9 = __s1;
    do
    {
      unsigned int v10 = v8;
      int v11 = *v9++;
      unsigned int v8 = 257 * v8 + v11;
    }
    while (v11);
    uint64_t v22 = 0;
    int v12 = v7 - 1;
    for (int i = 1; ; int i = v21 + 1)
    {
      unsigned int v21 = i;
      unsigned int v14 = v10 & v12;
      BOOL v15 = (char **)&v6[2 * (v10 & v12)];
      __int32 v16 = *v15;
      BOOL isEqual = objc::DenseMapInfo<char const*>::isEqual(__s1, *v15);
      if (isEqual) {
        break;
      }
      if (objc::DenseMapInfo<char const*>::isEqual(v16, (char *)0xFFFFFFFFFFFFFFFFLL))
      {
        if (v22) {
          BOOL v15 = v22;
        }
        break;
      }
      if (v21 > v7) {
        objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::FatalCorruptHashTables(a1, v6, v7);
      }
      BOOL v18 = objc::DenseMapInfo<char const*>::isEqual(v16, (char *)0xFFFFFFFFFFFFFFFELL);
      int v19 = v22;
      if (v18 && v22 == 0) {
        int v19 = (char **)&v6[2 * v14];
      }
      uint64_t v22 = v19;
      unsigned int v10 = v14 + v21;
    }
  }
  else
  {
    BOOL v15 = 0;
    BOOL isEqual = 0;
  }
  *a3 = v15;
  return isEqual;
}

void objc::DenseMap<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if (*(void *)a1) {
    atomic_ullong v4 = *(char ***)a1;
  }
  else {
    atomic_ullong v4 = 0;
  }
  unsigned int v5 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
  unsigned int v6 = v5 | (v5 >> 4) | ((v5 | (v5 >> 4)) >> 8);
  int v7 = v6 | HIWORD(v6);
  if ((v7 + 1) > 4) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 4;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t v9 = malloc_type_malloc(16 * v8, 0x64B88C75uLL);
  if (v9)
  {
    *(void *)a1 = v9;
    *(void *)(a1 + 8) = 0;
    if (v4)
    {
      unsigned int v10 = v9;
LABEL_13:
      uint64_t v12 = *(unsigned int *)(a1 + 16);
      if (v12)
      {
        uint64_t v13 = 16 * v12;
        do
        {
          *unsigned int v10 = -1;
          v10 += 2;
          v13 -= 16;
        }
        while (v13);
      }
      if (v3)
      {
        uint64_t v14 = 16 * v3;
        BOOL v15 = v4;
        do
        {
          __int32 v16 = *v15;
          if (!objc::DenseMapInfo<char const*>::isEqual(*v15, (char *)0xFFFFFFFFFFFFFFFFLL)
            && !objc::DenseMapInfo<char const*>::isEqual(v16, (char *)0xFFFFFFFFFFFFFFFELL))
          {
            int v20 = 0;
            objc::DenseMapBase<objc::DenseMap<char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>,char const*,Protocol *,objc::DenseMapValueInfo<Protocol *>,objc::DenseMapInfo<char const*>,objc::detail::DenseMapPair<char const*,Protocol *>>::LookupBucketFor<char const*>(a1, v16, &v20);
            unsigned int v17 = v20;
            *int v20 = *v15;
            v17[1] = v15[1];
            ++*(_DWORD *)(a1 + 8);
          }
          v15 += 2;
          v14 -= 16;
        }
        while (v14);
      }
      free(v4);
      return;
    }
    int v11 = v9;
  }
  else
  {
    int v11 = 0;
    unsigned int v10 = 0;
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    if (v4) {
      goto LABEL_13;
    }
  }
  uint64_t v18 = *(unsigned int *)(a1 + 16);
  if (v18)
  {
    uint64_t v19 = 16 * v18;
    do
    {
      *int v11 = -1;
      v11 += 2;
      v19 -= 16;
    }
    while (v19);
  }
}

const char **__cdecl objc_copyImageNames(unsigned int *outCount)
{
  int v1 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v1, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v1) {
    os_unfair_lock_lock_with_options();
  }
  uint64_t v3 = (void *)FirstHeader;
  if (FirstHeader)
  {
    atomic_ullong v4 = 0;
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    do
    {
      int v7 = (char *)v3 + *v3;
      if (v5 >= v6)
      {
        uint64_t v9 = (v5 - v4) >> 3;
        unint64_t v10 = v9 + 1;
        if ((unint64_t)(v9 + 1) >> 61) {
          abort();
        }
        if ((v6 - v4) >> 2 > v10) {
          unint64_t v10 = (v6 - v4) >> 2;
        }
        if ((unint64_t)(v6 - v4) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v11 = v10;
        }
        if (v11)
        {
          if (v11 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v12 = (char *)malloc_type_malloc(8 * v11, 0xB4ED9BFAuLL);
        }
        else
        {
          uint64_t v12 = 0;
        }
        uint64_t v13 = &v12[8 * v9];
        *(void *)uint64_t v13 = v7;
        unsigned int v8 = v13 + 8;
        while (v5 != v4)
        {
          uint64_t v14 = *((void *)v5 - 1);
          v5 -= 8;
          *((void *)v13 - freeBuckets(table, 1) = v14;
          v13 -= 8;
        }
        unsigned int v6 = &v12[8 * v11];
        if (v4) {
          free(v4);
        }
        atomic_ullong v4 = v13;
      }
      else
      {
        *(void *)unsigned int v5 = v7;
        unsigned int v8 = v5 + 8;
      }
      uint64_t PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v3);
      __int32 v16 = v3 + 3;
      if (PreoptimizedHeaderRW) {
        __int32 v16 = (void *)PreoptimizedHeaderRW;
      }
      unsigned int v5 = v8;
      uint64_t v3 = (void *)(*v16 & 0xFFFFFFFFFFFFFFFCLL);
    }
    while (v3);
  }
  else
  {
    atomic_ullong v4 = 0;
    unsigned int v8 = 0;
  }
  int v17 = *(_DWORD *)(StatusReg + 24);
  int v18 = v17;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v18, 0, memory_order_release, memory_order_relaxed);
  if (v18 != v17) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  uint64_t v19 = malloc_type_malloc(v8 - v4 + 8, 0x10040436913F5uLL);
  int v20 = v19;
  if (v4 == v8)
  {
    *uint64_t v19 = 0;
LABEL_38:
    free(v20);
    unsigned int v21 = 0;
    int v20 = 0;
    goto LABEL_39;
  }
  unsigned int v21 = 0;
  uint64_t v22 = v4;
  do
  {
    uint64_t v23 = dyld_image_path_containing_address();
    if (v23) {
      *((void *)v20 + v21++) = v23;
    }
    v22 += 8;
  }
  while (v22 != v8);
  *((void *)v20 + v2freeBuckets(table, 1) = 0;
  if (!v21) {
    goto LABEL_38;
  }
LABEL_39:
  if (outCount) {
    *outCount = v21;
  }
  if (v4) {
    free(v4);
  }
  return (const char **)v20;
}

void sub_1801433D0(_Unwind_Exception *exception_object)
{
  if (v1) {
    free(v1);
  }
  _Unwind_Resume(exception_object);
}

const char **__cdecl objc_copyClassNamesForImage(const char *image, unsigned int *outCount)
{
  if (!image)
  {
    if (!outCount) {
      return 0;
    }
LABEL_66:
    __n128 result = 0;
    *outCount = 0;
    return result;
  }
  uint64_t v32 = outCount;
  uint64_t v33 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  do
  {
    int v3 = 0;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v3, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v3) {
      os_unfair_lock_lock_with_options();
    }
    atomic_ullong v4 = (void *)FirstHeader;
    if (FirstHeader)
    {
      unsigned int v5 = 0;
      unsigned int v6 = 0;
      int v7 = 0;
      do
      {
        if (_dyld_get_image_uuid())
        {
          unsigned int v8 = (header_info *)((char *)v4 + *v4);
          if (v6 >= (header_info **)v7)
          {
            unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (v6 - v5) + 1;
            if (v9 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            if (0x5555555555555556 * ((v7 - (char *)v5) >> 3) > v9) {
              unint64_t v9 = 0x5555555555555556 * ((v7 - (char *)v5) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((v7 - (char *)v5) >> 3) >= 0x555555555555555) {
              unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v10 = v9;
            }
            if (v10)
            {
              if (v10 > 0xAAAAAAAAAAAAAAALL) {
                std::__throw_bad_array_new_length[abi:nn180100]();
              }
              unint64_t v11 = (char *)malloc_type_malloc(24 * v10, 0xB4ED9BFAuLL);
            }
            else
            {
              unint64_t v11 = 0;
            }
            uint64_t v12 = &v11[8 * (v6 - v5)];
            *(void *)uint64_t v12 = v8;
            *(_OWORD *)(v12 + 8) = v35;
            if (v6 == v5)
            {
              uint64_t v14 = &v11[8 * (v6 - v5)];
            }
            else
            {
              uint64_t v13 = &v11[8 * (v6 - v5)];
              do
              {
                uint64_t v14 = v13 - 24;
                long long v15 = *(_OWORD *)(v6 - 3);
                *((void *)v13 - freeBuckets(table, 1) = *(v6 - 1);
                *(_OWORD *)(v13 - 24) = v15;
                v6 -= 3;
                v13 -= 24;
              }
              while (v6 != v5);
            }
            int v7 = &v11[24 * v10];
            unsigned int v6 = (header_info **)(v12 + 24);
            if (v5) {
              free(v5);
            }
            unsigned int v5 = (header_info **)v14;
          }
          else
          {
            *unsigned int v6 = v8;
            *(_OWORD *)(v6 + freeBuckets(table, 1) = v35;
            v6 += 3;
          }
        }
        uint64_t PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v4);
        int v17 = v4 + 3;
        if (PreoptimizedHeaderRW) {
          int v17 = (void *)PreoptimizedHeaderRW;
        }
        atomic_ullong v4 = (void *)(*v17 & 0xFFFFFFFFFFFFFFFCLL);
      }
      while (v4);
    }
    else
    {
      unsigned int v6 = 0;
      unsigned int v5 = 0;
    }
    int v18 = *(_DWORD *)(StatusReg + 24);
    int v19 = v18;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v19, 0, memory_order_release, memory_order_relaxed);
    if (v19 != v18) {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
    int v20 = v5;
    if (v5 == v6) {
      goto LABEL_39;
    }
    while (1)
    {
      unsigned int v21 = (const char *)dyld_image_path_containing_address();
      if (v21)
      {
        if (!strcmp(v21, image)) {
          break;
        }
      }
      v20 += 3;
      if (v20 == v6) {
        goto LABEL_39;
      }
    }
    if (v20 == v6)
    {
LABEL_39:
      int v22 = 1;
    }
    else
    {
      int v23 = 0;
      unsigned int v24 = *v20;
      atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v23, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
      if (v23) {
        os_unfair_lock_lock_with_options();
      }
      uint64_t v25 = (header_info *)FirstHeader;
      if (!FirstHeader) {
        goto LABEL_58;
      }
      while (v24 != (header_info *)((char *)v25 + *(void *)v25))
      {
        uint64_t v26 = getPreoptimizedHeaderRW((uint64_t)v25);
        uint64_t v27 = (void *)((char *)v25 + 24);
        if (v26) {
          uint64_t v27 = (void *)v26;
        }
        uint64_t v25 = (header_info *)(*v27 & 0xFFFFFFFFFFFFFFFCLL);
        if (!v25) {
          goto LABEL_58;
        }
      }
      long long v35 = 0uLL;
      if (_dyld_get_image_uuid() && (!v20[1] ? (BOOL v28 = v20[2] == 0) : (BOOL v28 = 0), v28))
      {
        uint64_t v33 = (const char **)copyClassNamesForImage_nolock(v25, v32);
        int v22 = 1;
      }
      else
      {
LABEL_58:
        int v22 = 0;
      }
      int v29 = *(_DWORD *)(StatusReg + 24);
      int v30 = v29;
      atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v30, 0, memory_order_release, memory_order_relaxed);
      if (v30 != v29) {
        os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
      }
    }
    if (v5) {
      free(v5);
    }
  }
  while (!v22);
  outCount = v32;
  if (!v32) {
    return v33;
  }
  __n128 result = v33;
  if (!v33) {
    goto LABEL_66;
  }
  return result;
}

void sub_1801437DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  int v14 = *(_DWORD *)(a12 + 24);
  int v15 = v14;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v15, 0, memory_order_release, memory_order_relaxed);
  if (v15 != v14) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  if (v12) {
    free(v12);
  }
  _Unwind_Resume(exception_object);
}

void *objc_copyClassesForImage(const char *a1, _DWORD *a2)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if (!a2) {
      return 0;
    }
LABEL_76:
    __n128 result = 0;
    *a2 = 0;
    return result;
  }
  unint64_t v40 = a2;
  int32x2_t v41 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  unint64_t v42 = StatusReg;
  do
  {
    int v4 = 0;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v4) {
      os_unfair_lock_lock_with_options();
    }
    unsigned int v5 = (void *)FirstHeader;
    if (FirstHeader)
    {
      unsigned int v6 = 0;
      int v7 = 0;
      unsigned int v8 = 0;
      do
      {
        if (_dyld_get_image_uuid())
        {
          unint64_t v9 = (header_info *)((char *)v5 + *v5);
          *(_OWORD *)unint64_t v43 = v44;
          if (v7 >= (header_info **)v8)
          {
            unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v7 - v6) + 1;
            if (v10 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            if (0x5555555555555556 * ((v8 - (char *)v6) >> 3) > v10) {
              unint64_t v10 = 0x5555555555555556 * ((v8 - (char *)v6) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((v8 - (char *)v6) >> 3) >= 0x555555555555555) {
              unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v11 = v10;
            }
            if (v11)
            {
              if (v11 > 0xAAAAAAAAAAAAAAALL) {
                std::__throw_bad_array_new_length[abi:nn180100]();
              }
              uint64_t v12 = (char *)malloc_type_malloc(24 * v11, 0xB4ED9BFAuLL);
            }
            else
            {
              uint64_t v12 = 0;
            }
            uint64_t v13 = &v12[8 * (v7 - v6)];
            *(void *)uint64_t v13 = v9;
            *(_OWORD *)(v13 + 8) = *(_OWORD *)v43;
            if (v7 == v6)
            {
              int v15 = &v12[8 * (v7 - v6)];
            }
            else
            {
              int v14 = &v12[8 * (v7 - v6)];
              do
              {
                int v15 = v14 - 24;
                long long v16 = *(_OWORD *)(v7 - 3);
                *((void *)v14 - freeBuckets(table, 1) = *(v7 - 1);
                *(_OWORD *)(v14 - 24) = v16;
                v7 -= 3;
                v14 -= 24;
              }
              while (v7 != v6);
            }
            unsigned int v8 = &v12[24 * v11];
            int v7 = (header_info **)(v13 + 24);
            if (v6) {
              free(v6);
            }
            unsigned int v6 = (header_info **)v15;
          }
          else
          {
            *int v7 = v9;
            *(_OWORD *)(v7 + freeBuckets(table, 1) = *(_OWORD *)v43;
            v7 += 3;
          }
        }
        uint64_t PreoptimizedHeaderRW = getPreoptimizedHeaderRW((uint64_t)v5);
        int v18 = v5 + 3;
        if (PreoptimizedHeaderRW) {
          int v18 = (void *)PreoptimizedHeaderRW;
        }
        unsigned int v5 = (void *)(*v18 & 0xFFFFFFFFFFFFFFFCLL);
      }
      while (v5);
    }
    else
    {
      int v7 = 0;
      unsigned int v6 = 0;
    }
    unint64_t StatusReg = v42;
    int v19 = *(_DWORD *)(v42 + 24);
    int v20 = v19;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v20, 0, memory_order_release, memory_order_relaxed);
    if (v20 != v19) {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
    unsigned int v21 = v6;
    if (v6 == v7) {
      goto LABEL_39;
    }
    while (1)
    {
      int v22 = (const char *)dyld_image_path_containing_address();
      if (v22)
      {
        if (!strcmp(v22, a1)) {
          break;
        }
      }
      v21 += 3;
      if (v21 == v7) {
        goto LABEL_39;
      }
    }
    if (v21 == v7)
    {
LABEL_39:
      int v23 = 1;
    }
    else
    {
      int v24 = 0;
      uint64_t v25 = *v21;
      atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v24, *(_DWORD *)(v42 + 24), memory_order_acquire, memory_order_acquire);
      if (v24) {
        os_unfair_lock_lock_with_options();
      }
      uint64_t v26 = (header_info *)FirstHeader;
      if (!FirstHeader) {
        goto LABEL_58;
      }
      while (v25 != (header_info *)((char *)v26 + *(void *)v26))
      {
        uint64_t v27 = getPreoptimizedHeaderRW((uint64_t)v26);
        BOOL v28 = (void *)((char *)v26 + 24);
        if (v27) {
          BOOL v28 = (void *)v27;
        }
        uint64_t v26 = (header_info *)(*v28 & 0xFFFFFFFFFFFFFFFCLL);
        if (!v26) {
          goto LABEL_58;
        }
      }
      long long v44 = 0uLL;
      if (_dyld_get_image_uuid()
        && ((header_info *)v44 == v21[1] ? (BOOL v29 = *((void *)&v44 + 1) == (void)v21[2]) : (BOOL v29 = 0), v29))
      {
        v43[0] = 0;
        uint64_t v32 = (unint64_t *)header_info::classlist(v26, v43);
        unint64_t v33 = v43[0];
        int32x2_t v41 = malloc_type_malloc(8 * v43[0] + 8, 0x80040B8603338uLL);
        if (v33)
        {
          uint64_t v34 = 0;
          long long v35 = v41;
          unint64_t v36 = v33;
          do
          {
            unint64_t v37 = remapClass(*v32);
            if (v37) {
              v35[-v34] = v37;
            }
            else {
              ++v34;
            }
            ++v35;
            ++v32;
            --v36;
          }
          while (v36);
          uint64_t v38 = v33 - v34;
        }
        else
        {
          uint64_t v38 = 0;
        }
        unint64_t StatusReg = v42;
        v41[v38] = 0;
        if (v40) {
          *unint64_t v40 = v38;
        }
        int v23 = 1;
      }
      else
      {
LABEL_58:
        int v23 = 0;
        unint64_t StatusReg = v42;
      }
      int v30 = *(_DWORD *)(StatusReg + 24);
      int v31 = v30;
      atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v31, 0, memory_order_release, memory_order_relaxed);
      if (v31 != v30) {
        os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
      }
    }
    if (v6) {
      free(v6);
    }
  }
  while (!v23);
  a2 = v40;
  if (!v40) {
    return v41;
  }
  __n128 result = v41;
  if (!v41) {
    goto LABEL_76;
  }
  return result;
}

void sub_180143C94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  int v14 = *(_DWORD *)(a12 + 24);
  int v15 = v14;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v15, 0, memory_order_release, memory_order_relaxed);
  if (v15 != v14) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  if (v12) {
    free(v12);
  }
  _Unwind_Resume(exception_object);
}

const char *objc_debug_class_getNameRaw(objc_class *this, uint64_t a2, const char *a3, char *a4)
{
  if (!this) {
    return "nil";
  }
  uint64_t v5 = *((void *)this + 4);
  if (v5 < 0) {
    unint64_t v6 = class_rw_t::ro((class_rw_t *)(v5 & 0xF00007FFFFFFFF8));
  }
  else {
    unint64_t v6 = v5 & 0xF00007FFFFFFFF8;
  }
  __n128 result = (const char *)atomic_load_explicit((atomic_ullong *volatile)(v6 + 24), memory_order_acquire);
  if (!result)
  {
    return (const char *)objc_class::installMangledNameForLazilyNamedClass(this, a2, a3, a4);
  }
  return result;
}

int class_getVersion(Class cls)
{
  if (cls)
  {
    uint64_t v1 = *(void *)((*((void *)cls + 4) & 0xF00007FFFFFFFF8) + 8);
    if ((v1 & 1) != 0 && (v1 & 0xFFFFFFFFFFFFFFFELL) != 0) {
      LODWORD(cls) = *(_DWORD *)((v1 & 0xFFFFFFFFFFFFFFFELL) + 40);
    }
    else {
      LODWORD(cls) = (*((unsigned __int16 *)cls + 15) << 29 >> 31) & 7;
    }
  }
  return (int)cls;
}

objc_class *gdb_class_getClass(objc_class *a1)
{
  uint64_t v1 = (char *)objc_class::mangledName(a1);
  if (!v1 || !*v1) {
    return 0;
  }

  return look_up_class(v1);
}

objc_class *gdb_object_getClass(objc_class *result)
{
  if (result)
  {
    if (((unint64_t)result & 0x8000000000000000) != 0)
    {
      uint64_t v1 = (__objc2_class *)objc_debug_taggedpointer_classes[result & 7];
      if (v1)
      {
        if (v1 == __NSUnrecognizedTaggedPointer) {
          uint64_t v1 = (__objc2_class *)objc_debug_taggedpointer_ext_classes[((unint64_t)result >> 55)];
        }
      }
    }
    else
    {
      uint64_t v1 = (__objc2_class *)(*(void *)result & 0x7FFFFFFFFFFFF8);
    }
    return gdb_class_getClass((objc_class *)v1);
  }
  return result;
}

const uint8_t *__cdecl class_getIvarLayout(const uint8_t *cls)
{
  if (cls)
  {
    unint64_t v1 = class_rw_t::ro((class_rw_t *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8));
    if (*(unsigned char *)v1) {
      return 0;
    }
    else {
      return *(const uint8_t **)(v1 + 16);
    }
  }
  return cls;
}

const uint8_t *__cdecl class_getWeakIvarLayout(const uint8_t *cls)
{
  if (cls) {
    return *(const uint8_t **)(class_rw_t::ro((class_rw_t *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8)) + 56);
  }
  return cls;
}

void class_setIvarLayout(Class cls, const uint8_t *layout)
{
  if (cls)
  {
    int v4 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v4) {
      os_unfair_lock_lock_with_options();
    }
    if ((unint64_t)(*(void *)cls - 1) < 0xF
      || (*(_DWORD *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
      || (uint64_t v6 = *(unsigned __int16 *)((*((void *)cls + 4) & 0xF00007FFFFFFFF8) + 4),
          qword_1EB1CB088 <= v6)
      || (*(void *)(qword_1EB1CB080 + 16 * v6) <= (unint64_t)cls
        ? (BOOL v7 = *(void *)(qword_1EB1CB080 + 16 * v6 + 8) > (unint64_t)cls)
        : (BOOL v7 = 0),
          !v7))
    {
      if (objc::allocatedClasses + 8 * qword_1EB1CAEA0 == objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::find((unint64_t)cls)
        && (dataSegmentsContain(cls, v17, v18) & 1) == 0)
      {
        _objc_fatal("Attempt to use unknown class %p.", v19, v20, v21, cls);
      }
    }
    unsigned int v8 = (class_rw_t *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8);
    if ((*((unsigned char *)v8 + 3) & 4) != 0)
    {
      ro_writeable_nolocuint64_t k = make_ro_writeable_nolock(v8);
      unint64_t v11 = ro_writeable_nolock;
      if ((*(unsigned char *)ro_writeable_nolock & 1) == 0)
      {
        uint64_t v12 = *(void **)(ro_writeable_nolock + 16);
        if (v12)
        {
          if (malloc_size(*(const void **)(ro_writeable_nolock + 16))) {
            free(v12);
          }
        }
      }
      if (layout)
      {
        size_t v13 = strlen((const char *)layout) + 1;
        if ((_dyld_is_memory_immutable() & 1) == 0)
        {
          int v14 = malloc_type_malloc(v13, 0x3F84A03uLL);
          memcpy(v14, layout, v13);
          layout = (const uint8_t *)v14;
        }
      }
      *(void *)(v11 + 16) = layout;
    }
    else
    {
      unint64_t v9 = objc_class::nameForLogging(cls);
      _objc_inform("*** Can't set ivar layout for already-registered class '%s'", v9);
    }
    int v15 = *(_DWORD *)(StatusReg + 24);
    int v16 = v15;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v16, 0, memory_order_release, memory_order_relaxed);
    if (v16 != v15)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
  }
}

void sub_180144268(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void class_setWeakIvarLayout(Class cls, const uint8_t *layout)
{
  if (cls)
  {
    int v4 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v4) {
      os_unfair_lock_lock_with_options();
    }
    if ((unint64_t)(*(void *)cls - 1) < 0xF
      || (*(_DWORD *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
      || (uint64_t v6 = *(unsigned __int16 *)((*((void *)cls + 4) & 0xF00007FFFFFFFF8) + 4),
          qword_1EB1CB088 <= v6)
      || (*(void *)(qword_1EB1CB080 + 16 * v6) <= (unint64_t)cls
        ? (BOOL v7 = *(void *)(qword_1EB1CB080 + 16 * v6 + 8) > (unint64_t)cls)
        : (BOOL v7 = 0),
          !v7))
    {
      if (objc::allocatedClasses + 8 * qword_1EB1CAEA0 == objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::find((unint64_t)cls)
        && (dataSegmentsContain(cls, v17, v18) & 1) == 0)
      {
        _objc_fatal("Attempt to use unknown class %p.", v19, v20, v21, cls);
      }
    }
    unsigned int v8 = (class_rw_t *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8);
    if ((*((unsigned char *)v8 + 3) & 4) != 0)
    {
      ro_writeable_nolocuint64_t k = make_ro_writeable_nolock(v8);
      unint64_t v11 = ro_writeable_nolock;
      uint64_t v12 = *(void **)(ro_writeable_nolock + 56);
      if (v12 && malloc_size(*(const void **)(ro_writeable_nolock + 56))) {
        free(v12);
      }
      if (layout)
      {
        size_t v13 = strlen((const char *)layout) + 1;
        if ((_dyld_is_memory_immutable() & 1) == 0)
        {
          int v14 = malloc_type_malloc(v13, 0x3F84A03uLL);
          memcpy(v14, layout, v13);
          layout = (const uint8_t *)v14;
        }
      }
      *(void *)(v11 + 56) = layout;
    }
    else
    {
      unint64_t v9 = objc_class::nameForLogging(cls);
      _objc_inform("*** Can't set weak ivar layout for already-registered class '%s'", v9);
    }
    int v15 = *(_DWORD *)(StatusReg + 24);
    int v16 = v15;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v16, 0, memory_order_release, memory_order_relaxed);
    if (v16 != v15)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
  }
}

void sub_180144500(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void class_replaceMethodsBulk(objc_class *a1, objc_selector **a2, void (**a3)(void), const char **a4, method_list_t *this)
{
  if (a1)
  {
    int v10 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v10, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v10) {
      os_unfair_lock_lock_with_options();
    }
    addMethods(a1, a2, a3, a4, this, 1, 0);
    int v12 = *(_DWORD *)(StatusReg + 24);
    int v13 = v12;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v13, 0, memory_order_release, memory_order_relaxed);
    if (v13 != v12)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
  }
}

void sub_180144614(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)
{
  return _class_addProperty(cls, name, attributes, attributeCount, 0);
}

uint64_t _class_addProperty(Class cls, const char *name, const objc_property_attribute_t *a3, unsigned int a4, int a5)
{
  uint64_t result = 0;
  if (cls)
  {
    BOOL v7 = name;
    if (name)
    {
      objc_property_t Property = class_getProperty(cls, name);
      objc_property_t v12 = Property;
      if (!Property || a5)
      {
        int v13 = 0;
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v13, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
        BOOL v15 = v13 == 0;
        if (Property)
        {
          if (!v15) {
            os_unfair_lock_lock_with_options();
          }
          int v16 = (void *)*((void *)v12 + 1);
          if (v16 && malloc_size(*((const void **)v12 + 1))) {
            free(v16);
          }
          *((void *)v12 + freeBuckets(table, 1) = copyPropertyAttributeString((uint64_t)a3, a4);
        }
        else
        {
          if (!v15) {
            os_unfair_lock_lock_with_options();
          }
          uint64_t v17 = class_rw_t::extAllocIfNeeded((class_rw_t *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8));
          int v18 = malloc_type_malloc(0x18uLL, 0x899C19F0uLL);
          int v24 = v18;
          *int v18 = 0x100000010;
          size_t v19 = strlen(v7) + 1;
          if ((_dyld_is_memory_immutable() & 1) == 0)
          {
            int v20 = malloc_type_malloc(v19, 0x3F84A03uLL);
            memcpy(v20, v7, v19);
            BOOL v7 = (const char *)v20;
          }
          v18[1] = v7;
          v18[2] = copyPropertyAttributeString((uint64_t)a3, a4);
          if (PrintPreopt) {
            unsigned int v21 = "properties";
          }
          else {
            unsigned int v21 = 0;
          }
          list_array_tt<property_t,property_list_t,RawPtr>::attachLists(v17 + 2, (uint64_t)&v24, (const char *)1, 0, v21);
        }
        int v22 = *(_DWORD *)(StatusReg + 24);
        int v23 = v22;
        atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v23, 0, memory_order_release, memory_order_relaxed);
        if (v23 != v22) {
          os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
        }
        return 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

void sub_180144850(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)
{
}

Class objc_duplicateClass(Class original, const char *name, size_t extraBytes)
{
  int v5 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v5, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v5) {
    os_unfair_lock_lock_with_options();
  }
  if ((unint64_t)(*(void *)original - 1) < 0xF
    || (*(_DWORD *)(*((void *)original + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
    || (uint64_t v7 = *(unsigned __int16 *)((*((void *)original + 4) & 0xF00007FFFFFFFF8) + 4),
        qword_1EB1CB088 <= v7)
    || (*(void *)(qword_1EB1CB080 + 16 * v7) <= (unint64_t)original
      ? (BOOL v8 = *(void *)(qword_1EB1CB080 + 16 * v7 + 8) > (unint64_t)original)
      : (BOOL v8 = 0),
        !v8))
  {
    if (objc::allocatedClasses + 8 * qword_1EB1CAEA0 == objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::find((unint64_t)original)
      && (dataSegmentsContain(original, v45, v46) & 1) == 0)
    {
      _objc_fatal("Attempt to use unknown class %p.", v47, v48, v49, original);
    }
  }
  unint64_t v9 = (class_rw_t *)(*((void *)original + 4) & 0xF00007FFFFFFFF8);
  uint64_t v10 = *((void *)v9 + 1);
  if (v10) {
    unint64_t v11 = v10 & 0xFFFFFFFFFFFFFFFELL;
  }
  else {
    unint64_t v11 = 0;
  }
  objc_property_t v12 = (class_ro_t *)class_rw_t::ro(v9);
  int v13 = alloc_class_for_subclass(original);
  int v14 = (unint64_t *)v13;
  if (DisableNonpointerIsa || (*(_WORD *)((*(void *)original & 0xFFFFFFFF8) + 0x1E) & 0x2000) != 0) {
    uint64_t v15 = *(void *)original & 0xFFFFFFFF8;
  }
  else {
    uint64_t v15 = *(void *)original & 0xFFFFFFFF8 | 0x100000000000001;
  }
  *(void *)int v13 = v15;
  unint64_t v54 = v11;
  if (*((void *)original + 1)) {
    uint64_t v16 = *((void *)original + 1);
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v53 = (uint64_t *)(v13 + 8);
  *((void *)v13 + _class_addProperty(cls, name, attributes, attributeCount, 1) = v16;
  *((void *)v13 + 2) = &_objc_empty_cache;
  *((void *)v13 + 3) = 0;
  uint64_t v17 = malloc_type_calloc(0x20uLL, 1uLL, 0x1ECB51D3uLL);
  *(_DWORD *)uint64_t v17 = *(_DWORD *)v9 | 0x8080000;
  v17[2] = 0;
  v17[3] = 0;
  v14[4] = *((void *)original + 4);
  class_data_bits_t::setData(v14 + 4, (unint64_t)v17);
  int v18 = class_ro_t::duplicate(v12);
  size_t v19 = strlen(name) + 1;
  int v20 = (void *)name;
  if ((_dyld_is_memory_immutable() & 1) == 0)
  {
    int v20 = malloc_type_malloc(v19, 0x3F84A03uLL);
    memcpy(v20, name, v19);
  }
  v18[3] = (atomic_ullong)v20;
  unsigned int v21 = v17 + 1;
  uint64_t v22 = v17[1];
  if (v22) {
    unsigned int v21 = (void *)(v22 & 0xFFFFFFFFFFFFFFFELL);
  }
  void *v21 = v18;
  if (v54)
  {
    unint64_t v52 = StatusReg;
    uint64_t v26 = class_rw_t::extAllocIfNeeded((class_rw_t *)v17);
    uint64_t v27 = *(void *)(v54 + 8);
    *((_DWORD *)v26 + 1freeBuckets(table, 0) = *(_DWORD *)(v54 + 40);
    BOOL v28 = v26 + 1;
    int v51 = name;
    if (v27)
    {
      if ((v27 & 3) != 0)
      {
        if ((v27 & 3) == 1)
        {
          BOOL v29 = (_DWORD *)(v27 & 0xFFFFFFFFFFFFFFFCLL);
          if ((v27 & 0xFFFFFFFFFFFFFFFCLL) != 0)
          {
            uint64_t __n = 8 * *v29 + 8;
            unint64_t v30 = (unint64_t)malloc_type_malloc(__n, 0x3F84A03uLL);
            memcpy((void *)v30, v29, __n);
            *BOOL v28 = v30 | 1;
            if (*v29)
            {
              uint64_t v34 = (char *)(v30 + 8);
              long long v35 = v29 + 2;
              unint64_t v36 = 1;
              do
              {
                if (*(void *)&v29[2 * v36]) {
                  unint64_t v37 = *(method_list_t **)&v29[2 * v36];
                }
                else {
                  unint64_t v37 = 0;
                }
                *(void *)(v30 + 8 * v36) = method_list_t::duplicate(v37, v31, v32, v33);
                v34 += 8;
                v35 += 2;
              }
              while (v36++ < *v29);
            }
            goto LABEL_47;
          }
        }
      }
      else if ((v27 & 0xFFFFFFFFFFFFFFFCLL) != 0)
      {
        unint64_t v40 = method_list_t::duplicate((method_list_t *)(v27 & 0xFFFFFFFFFFFFFFFCLL), v23, v24, v25);
LABEL_46:
        *BOOL v28 = (unint64_t)v40;
LABEL_47:
        name = v51;
        unint64_t StatusReg = v52;
        v26[2] = *(void *)(v54 + 16);
        v26[3] = *(void *)(v54 + 24);
        goto LABEL_48;
      }
    }
    unint64_t v40 = 0;
    goto LABEL_46;
  }
  unint64_t v39 = v18[4];
  if (v39 && (v39 & 1) == 0 || (v39) && v39 >= 2) {
    class_rw_t::extAlloc((class_rw_t *)v17, (const class_ro_t *)v18, 1);
  }
LABEL_48:
  if (*v53)
  {
    addSubclass(*v53, (objc_class *)v14);
  }
  else
  {
    ++objc_debug_realized_class_generation_count;
    *(void *)((v14[4] & 0xF00007FFFFFFFF8) + 0x18) = _firstRealizedClass;
    _firstRealizeduint64_t Class = (uint64_t)v14;
  }
  addNamedClass((objc_class *)v14, (const char *)atomic_load_explicit(v18 + 3, memory_order_acquire), 0);
  addClassTableEntry((uint64_t)v14, 0);
  if (PrintConnecting)
  {
    int32x2_t v41 = objc_class::nameForLogging(original);
    _objc_inform("CLASS: realizing class '%s' (duplicate of %s) %p %p", name, v41, v14, v18);
  }
  atomic_fetch_and_explicit((atomic_uint *volatile)(v14[4] & 0xF00007FFFFFFFF8), 0xFFF7FFFF, memory_order_relaxed);
  int v42 = *(_DWORD *)(StatusReg + 24);
  int v43 = v42;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v43, 0, memory_order_release, memory_order_relaxed);
  if (v43 != v42) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return (Class)v14;
}

void sub_180144FB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  int v18 = *(_DWORD *)(v16 + 24);
  int v19 = v18;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v19, 0, memory_order_release, memory_order_relaxed);
  if (v19 != v18) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

objc_class *objc_initializeClassPair(objc_class *a1, char *a2, objc_class *a3, unint64_t a4)
{
  if (look_up_class(a2)) {
    return 0;
  }
  int v8 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v8, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v8) {
    os_unfair_lock_lock_with_options();
  }
  if (getClassExceptSomeSwift(a2) || !verifySuperclass(a1, 1)) {
    a3 = 0;
  }
  else {
    objc_initializeClassPair_internal(a1, a2, a3, a4);
  }
  int v10 = *(_DWORD *)(StatusReg + 24);
  int v11 = v10;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v11, 0, memory_order_release, memory_order_relaxed);
  if (v11 != v10) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  return a3;
}

void sub_1801450EC(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

void objc_disposeClassPair(Class cls)
{
  int v2 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v2, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v2) {
    os_unfair_lock_lock_with_options();
  }
  if ((unint64_t)(*(void *)cls - 1) < 0xF
    || (*(_DWORD *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8) & 0x80000000) == 0
    || (uint64_t v4 = *(unsigned __int16 *)((*((void *)cls + 4) & 0xF00007FFFFFFFF8) + 4),
        qword_1EB1CB088 <= v4)
    || (*(void *)(qword_1EB1CB080 + 16 * v4) <= (unint64_t)cls
      ? (BOOL v5 = *(void *)(qword_1EB1CB080 + 16 * v4 + 8) > (unint64_t)cls)
      : (BOOL v5 = 0),
        !v5))
  {
    if (objc::allocatedClasses + 8 * qword_1EB1CAEA0 == objc::DenseMapBase<objc::DenseMap<objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>,objc_class *,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseSetPair<objc_class *>>::find((unint64_t)cls)
      && (dataSegmentsContain(cls, v17, v18) & 1) == 0)
    {
      _objc_fatal("Attempt to use unknown class %p.", v19, v20, v21, cls);
    }
  }
  uint64_t v6 = (class_rw_t *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8);
  if ((*((unsigned char *)v6 + 3) & 6) == 0
    || (uint64_t v7 = (objc_class *)(*(void *)cls & 0xFFFFFFFF8),
        uint64_t v8 = *((void *)v7 + 4),
        (*(unsigned char *)((v8 & 0xF00007FFFFFFFF8) + 3) & 6) == 0))
  {
    int v13 = "objc_disposeClassPair: class '%s' was not allocated with objc_allocateClassPair!";
LABEL_21:
    unint64_t v14 = class_rw_t::ro(v6);
    _objc_inform(v13, atomic_load_explicit((atomic_ullong *volatile)(v14 + 24), memory_order_acquire));
    goto LABEL_22;
  }
  if ((*((_WORD *)cls + 15) & 4) != 0)
  {
    int v13 = "objc_disposeClassPair: class '%s' is a metaclass, not a class!";
    goto LABEL_21;
  }
  if (*(void *)((*((void *)cls + 4) & 0xF00007FFFFFFFF8) + 0x10))
  {
    explicit = (const char *)atomic_load_explicit((atomic_ullong *volatile)(class_rw_t::ro(v6) + 24), memory_order_acquire);
    int v10 = objc_class::nameForLogging(*(objc_class **)((*((void *)cls + 4) & 0xF00007FFFFFFFF8) + 0x10));
    _objc_inform("objc_disposeClassPair: class '%s' still has subclasses, including '%s'!", explicit, v10);
    uint64_t v7 = (objc_class *)(*(void *)cls & 0xFFFFFFFF8);
    uint64_t v8 = *((void *)v7 + 4);
  }
  if (*(void *)((v8 & 0xF00007FFFFFFFF8) + 0x10))
  {
    int v11 = (const char *)atomic_load_explicit((atomic_ullong *volatile)(class_rw_t::ro((class_rw_t *)(*((void *)cls + 4) & 0xF00007FFFFFFFF8))+ 24), memory_order_acquire);
    objc_property_t v12 = objc_class::nameForLogging(*(objc_class **)((*(void *)((*(void *)cls & 0xFFFFFFFF8) + 0x20) & 0xF00007FFFFFFFF8)
                                                    + 0x10));
    _objc_inform("objc_disposeClassPair: class '%s' still has subclasses, including '%s'!", v11, v12);
    uint64_t v7 = (objc_class *)(*(void *)cls & 0xFFFFFFFF8);
  }
  detach_class(v7, 1);
  detach_class(cls, 0);
  free_class((objc_class *)(*(void *)cls & 0xFFFFFFFF8));
  free_class(cls);
LABEL_22:
  int v15 = *(_DWORD *)(StatusReg + 24);
  int v16 = v15;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v16, 0, memory_order_release, memory_order_relaxed);
  if (v16 != v15)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
}

void sub_1801454B8(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

uint64_t class_createInstances(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  if (result)
  {
    int v4 = a4;
    uint64_t v7 = result;
    if ((*(_WORD *)(result + 30) & 0xFF8) != 0)
    {
      size_t v8 = (a2 + (*(_WORD *)(result + 30) & 0xFF8) + 7) & 0xFFFFFFFFFFFFFFF0;
      if (a4) {
        goto LABEL_4;
      }
    }
    else
    {
      unint64_t v18 = class_rw_t::ro((class_rw_t *)(*(void *)(result + 32) & 0xF00007FFFFFFFF8));
      if ((unint64_t)((*(_DWORD *)(v18 + 8) + 7) & 0xFFFFFFF8) + a2 <= 0x10) {
        size_t v8 = 16;
      }
      else {
        size_t v8 = ((*(_DWORD *)(v18 + 8) + 7) & 0xFFFFFFF8) + a2;
      }
      if (v4)
      {
LABEL_4:
        uint64_t v9 = 0;
        while (1)
        {
          int v10 = malloc_type_calloc(1uLL, v8, 0x40000000000uLL);
          *(void *)(a3 + 8 * v9) = v10;
          if (!v10) {
            break;
          }
          if (v4 == ++v9)
          {
            if (!v4) {
              goto LABEL_22;
            }
            goto LABEL_10;
          }
        }
        int v4 = v9;
        if (!v9) {
          goto LABEL_22;
        }
LABEL_10:
        if ((v7 & 0xFF80000000000007) != 0) {
          _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", v11, v12, v13, v7);
        }
        uint64_t v14 = 0;
        int v15 = 0;
        __int16 v16 = *(_WORD *)(v7 + 30);
        do
        {
          uint64_t v17 = *(void (**)(void))(a3 + 8 * v14);
          *(void *)uint64_t v17 = v7 & 0x7FFFFFFFFFFFF8;
          if ((v16 & 2) != 0 && (uint64_t v17 = object_cxxConstructFromClass(v17, (objc_class **)v7, 1)) == 0) {
            ++v15;
          }
          else {
            *(void *)(a3 + 8 * (v14 - v15)) = v17;
          }
          ++v14;
        }
        while (v4 != v14);
        return (v4 - v15);
      }
    }
LABEL_22:
    int v15 = 0;
    return (v4 - v15);
  }
  return result;
}

id object_copy(id a1, size_t a2)
{
  uint64_t v2 = a1;
  if ((uint64_t)a1 < 1) {
    return v2;
  }
  if ((*(void *)a1 & 0x7FFFFFFFFFFFF8) != 0) {
    uint64_t v4 = *(void *)a1 & 0x7FFFFFFFFFFFF8;
  }
  else {
    uint64_t v4 = 0;
  }
  __int16 v5 = *(_WORD *)(v4 + 30);
  if ((v5 & 0xFF8) != 0)
  {
    size_t v6 = (a2 + (v5 & 0xFF8) + 7) & 0xFFFFFFFFFFFFFFF0;
  }
  else
  {
    unint64_t v45 = class_rw_t::ro((class_rw_t *)(*(void *)(v4 + 32) & 0xF00007FFFFFFFF8));
    if (((*(_DWORD *)(v45 + 8) + 7) & 0xFFFFFFF8) + a2 <= 0x10) {
      size_t v6 = 16;
    }
    else {
      size_t v6 = ((*(_DWORD *)(v45 + 8) + 7) & 0xFFFFFFF8) + a2;
    }
  }
  uint64_t v7 = (char *)malloc_type_calloc(1uLL, v6, 0x40000000000uLL);
  if (!v7) {
    return 0;
  }
  uint64_t v11 = v7;
  unint64_t v12 = v4 & 0xFF80000000000007;
  if ((v5 & 0x2000) != 0)
  {
    if (!v12)
    {
      uint64_t v13 = v4 & 0x7FFFFFFFFFFFF8;
      goto LABEL_13;
    }
LABEL_47:
    _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", v8, v9, v10, v4);
  }
  if (v12) {
    goto LABEL_47;
  }
  uint64_t v13 = v4 & 0x7FFFFFFFFFFFF8 | 0x100000000000001;
LABEL_13:
  *(void *)uint64_t v7 = v13;
  memmove(v7 + 8, v2 + 1, v6 - 8);
  uint64_t v14 = *v2 & 0xFFFFFFFF8;
  if (v14)
  {
    while (1)
    {
      int v15 = (void *)(v14 + 32);
      if ((*(_WORD *)class_rw_t::ro((class_rw_t *)(*(void *)(v14 + 32) & 0xF00007FFFFFFFF8)) & 0x280) != 0)
      {
        uint64_t v16 = (*(_DWORD *)(class_rw_t::ro((class_rw_t *)(*v15 & 0xF00007FFFFFFFF8)) + 4) + 7) & 0xFFFFFFF8;
        unint64_t v17 = class_rw_t::ro((class_rw_t *)(*v15 & 0xF00007FFFFFFFF8));
        if (*(unsigned char *)v17) {
          goto LABEL_25;
        }
        unint64_t v18 = *(unsigned char **)(v17 + 16);
        if (!v18) {
          goto LABEL_25;
        }
        unsigned int v19 = *v18;
        if (!*v18) {
          goto LABEL_25;
        }
        int v20 = (void **)&v11[v16];
        do
        {
          v20 += v19 >> 4;
          int v21 = v19 & 0xF;
          if ((v19 & 0xF) != 0)
          {
            do
            {
              uint64_t v23 = *v20++;
              uint64_t v22 = v23;
              if (v23) {
                id v24 = v22;
              }
              --v21;
            }
            while (v21);
          }
          unsigned int v25 = *++v18;
          unsigned int v19 = v25;
        }
        while (v25);
        if (v14)
        {
LABEL_25:
          uint64_t v26 = *(unsigned char **)(class_rw_t::ro((class_rw_t *)(*v15 & 0xF00007FFFFFFFF8)) + 56);
          if (v26)
          {
            unsigned int v27 = *v26;
            if (*v26)
            {
              BOOL v28 = (id *)((char *)v2 + v16);
              BOOL v29 = (id *)&v11[v16];
              do
              {
                v29 += v27 >> 4;
                v28 += v27 >> 4;
                int v30 = v27 & 0xF;
                if ((v27 & 0xF) != 0)
                {
                  do
                  {
                    --v30;
                    id WeakRetained = objc_loadWeakRetained(v28);
                    objc_initWeak(v29, WeakRetained);

                    ++v29;
                    ++v28;
                  }
                  while (v30);
                }
                unsigned int v32 = *++v26;
                unsigned int v27 = v32;
              }
              while (v32);
            }
          }
        }
      }
      unint64_t v33 = class_rw_t::ro((class_rw_t *)(*v15 & 0xF00007FFFFFFFF8));
      unint64_t v37 = *(unsigned int **)(v33 + 48);
      if (v37)
      {
        uint64_t v38 = *v37;
        uint64_t v39 = v37[1];
        unint64_t v40 = v39 * (unint64_t)v38;
        if ((v40 & 0xFFFFFFFF00000000) != 0) {
          _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v34, v35, v36, v39, *(void *)(v33 + 48), v38);
        }
        if (v40)
        {
          uint64_t v41 = (uint64_t)v37 + v40 + 8;
          int v42 = (int **)(v37 + 2);
          do
          {
            int v43 = v42[2];
            if (v43 && *(unsigned char *)v43 == 58) {
              *(void *)&v11[**v42] = *(void *)((char *)v2 + **v42);
            }
            int v42 = (int **)((char *)v42 + v38);
          }
          while (v42 != (int **)v41);
        }
      }
      if (!*(void *)(v14 + 8)) {
        break;
      }
      uint64_t v14 = *(void *)(v14 + 8);
    }
  }
  return v11;
}

uint64_t _objc_getFreedObjectClass()
{
  return 0;
}

Class objc_getRequiredClass(const char *name)
{
  if (!name) {
    _objc_fatal("link error: class '%s' not found.", v1, v2, v3, 0);
  }
  Class result = look_up_class((char *)name);
  if (!result) {
    _objc_fatal("link error: class '%s' not found.", v6, v7, v8, name);
  }
  return result;
}

void std::__function::__func<appendHeader::$_0,std::allocator<appendHeader::$_0>,void ()(segment_command_64 const*,long)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EC9784E0;
}

void *std::__function::__func<appendHeader::$_0,std::allocator<appendHeader::$_0>,void ()(segment_command_64 const*,long)>::__clone()
{
  Class result = malloc_type_malloc(0x10uLL, 0xB4ED9BFAuLL);
  void *result = &unk_1EC9784E0;
  return result;
}

__n128 std::__function::__func<removeHeader::$_0,std::allocator<removeHeader::$_0>,void ()(segment_command_64 const*,long)>::operator()(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  int v3 = (objc::SafeRanges *)(*(void *)(*(void *)a2 + 24) + *(void *)a3);
  uint64_t v4 = (char *)v3 + *(void *)(*(void *)a2 + 32);
  unsigned int v10 = 0;
  if (!objc::SafeRanges::find(v3, &v10, a3) || *(char **)(qword_1EB1CB080 + 16 * v10 + 8) != v4) {
    _objc_fatal("Cannot find range %#lx..%#lx", v5, v6, v7, v3, v4);
  }
  unsigned int v9 = qword_1EB1CB088 - 1;
  LODWORD(qword_1EB1CB088) = v9;
  if (v10 < v9)
  {
    __n128 result = *(__n128 *)(qword_1EB1CB080 + 16 * v9);
    *(__n128 *)(qword_1EB1CB080 + 16 * v1freeBuckets(table, 0) = result;
    HIDWORD(qword_1EB1CB088) &= ~0x80000000;
  }
  return result;
}

void std::__function::__func<removeHeader::$_0,std::allocator<removeHeader::$_0>,void ()(segment_command_64 const*,long)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EC978528;
}

void *std::__function::__func<removeHeader::$_0,std::allocator<removeHeader::$_0>,void ()(segment_command_64 const*,long)>::__clone()
{
  __n128 result = malloc_type_malloc(0x10uLL, 0xB4ED9BFAuLL);
  void *result = &unk_1EC978528;
  return result;
}

void logReplacedMethod(const char *a1, char *a2, int a3, const char *a4, void *a5, const void *a6)
{
  if (sel_load != a2)
  {
    int v12 = dladdr(a5, &v23);
    if (v23.dli_fname) {
      BOOL v13 = v12 == 0;
    }
    else {
      BOOL v13 = 1;
    }
    if (v13) {
      dli_fname = "??";
    }
    else {
      dli_fname = v23.dli_fname;
    }
    int v15 = dladdr(a6, &v23);
    uint64_t v16 = v23.dli_fname;
    if (v23.dli_fname) {
      BOOL v17 = v15 == 0;
    }
    else {
      BOOL v17 = 1;
    }
    if (v17) {
      uint64_t v16 = "??";
    }
    unint64_t v18 = "<null selector>";
    unsigned int v19 = "by category ";
    if (a2) {
      unint64_t v18 = a2;
    }
    int v20 = "";
    if (a4) {
      int v20 = a4;
    }
    else {
      unsigned int v19 = "";
    }
    uint64_t v22 = v18;
    uint64_t v21 = 45;
    if (a3) {
      uint64_t v21 = 43;
    }
    _objc_inform("REPLACED: %c[%s %s]  %s%s  (IMP was %p (%s), now %p (%s))", v21, a1, v22, v19, v20, a5, dli_fname, a6, v16);
  }
}

void objc_enumerationMutation(id obj)
{
  int v3 = (void (*)(id))enumerationMutationHandler;
  if (!enumerationMutationHandler) {
    _objc_fatal("mutation detected during 'for (... in ...)'  enumeration of object %p.", 0, v1, v2, obj);
  }

  v3(obj);
}

BOOL sel_isMapped(SEL sel)
{
  uint64_t v1 = (char *)sel;
  if (sel)
  {
    if ((SEL)_dyld_get_objc_selector() == sel)
    {
      LOBYTE(v_class_addProperty(cls, name, attributes, attributeCount, 1) = 1;
    }
    else
    {
      int v2 = 0;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      atomic_compare_exchange_strong_explicit(&selLock, (unsigned int *)&v2, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
      if (v2) {
        os_unfair_lock_lock_with_options();
      }
      uint64_t v4 = objc::DenseMapBase<objc::DenseMap<char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>,char const*,objc::detail::DenseSetEmpty,objc::DenseMapValueInfo<objc::detail::DenseSetEmpty>,objc::DenseMapInfo<char const*>,objc::detail::DenseSetPair<char const*>>::find(v1);
      LOBYTE(v_class_addProperty(cls, name, attributes, attributeCount, 1) = (char **)(*(void *)namedSelectors + 8 * dword_1EB1CAE58) != v4 && *v4 == v1;
      int v5 = *(_DWORD *)(StatusReg + 24);
      int v6 = v5;
      atomic_compare_exchange_strong_explicit(&selLock, (unsigned int *)&v6, 0, memory_order_release, memory_order_relaxed);
      if (v6 != v5) {
        os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
      }
    }
  }
  return (char)v1;
}

void sub_180145F58(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)&selLock);
  }
  _Unwind_Resume(exception_object);
}

uint64_t objc_sync_try_enter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if (a1)
  {
    int v4 = id2data(a1, 1, 0, a4) + 6;
    return MEMORY[0x1F40CD618](v4);
  }
  else
  {
    if (DebugNilSync) {
      _objc_inform("NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug");
    }
    gdb_objc_class_changed(a1);
    if (DebugNilSync == 2) {
      _objc_fatal("@synchronized(nil) is fatal", v5, v6, v7);
    }
    return 1;
  }
}

void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, char shouldCopy)
{
  if (offset)
  {
    uint64_t v7 = (id *)((char *)self + offset);
    if ((shouldCopy & 0xFD) != 0)
    {
      id v8 = [newValue copyWithZone:0];
    }
    else if (shouldCopy == 2)
    {
      id v8 = [newValue mutableCopyWithZone:0];
    }
    else
    {
      if (*v7 == newValue) {
        return;
      }
      id v8 = newValue;
    }
    id v9 = v8;
    if (atomic)
    {
      int v10 = 0;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      atomic_compare_exchange_strong_explicit(&PropertyLocks[16* (unint64_t)(((v7 >> 4) ^ (v7 >> 9)) & 7)], (unsigned int *)&v10, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
      if (v10) {
        os_unfair_lock_lock_with_options();
      }
      id v12 = *v7;
      *uint64_t v7 = v9;
      int v13 = *(_DWORD *)(StatusReg + 24);
      int v14 = v13;
      atomic_compare_exchange_strong_explicit(&PropertyLocks[16* (unint64_t)(((v7 >> 4) ^ (v7 >> 9)) & 7)], (unsigned int *)&v14, 0, memory_order_release, memory_order_relaxed);
      if (v14 != v13) {
        os_unfair_lock_unlock((os_unfair_lock_t)&PropertyLocks[16
      }
                                                             * (unint64_t)(((v7 >> 4) ^ (v7 >> 9)) & 7)]);
    }
    else
    {
      id v12 = *v7;
      *uint64_t v7 = v8;
    }
  }
  else
  {
    object_setClass(self, (Class)newValue);
  }
}

void _objc_patch_root_of_class(int a1, objc_class *this, const char *a3, char *a4)
{
  int v7 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v7, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v7) {
    os_unfair_lock_lock_with_options();
  }
  if (PrintConnecting)
  {
    id v9 = objc_class::nameForLogging(this);
    _objc_inform("CLASS: patching class '%s' (%p) to point to body of %p", v9, this, a4);
  }
  if (((unint64_t)a4 & 0x8000000000000000) != 0)
  {
    id v12 = (__objc2_class *)objc_debug_taggedpointer_classes[a4 & 7];
    if (v12)
    {
      uint64_t v11 = objc_debug_taggedpointer_classes[a4 & 7];
      if (v12 != __NSUnrecognizedTaggedPointer) {
        goto LABEL_12;
      }
      uint64_t v10 = objc_debug_taggedpointer_ext_classes[((unint64_t)a4 >> 55)];
      if (v10) {
        goto LABEL_7;
      }
    }
  }
  else
  {
    uint64_t v10 = *(void *)a4 & 0x7FFFFFFFFFFFF8;
    if (v10)
    {
LABEL_7:
      uint64_t v11 = v10;
      goto LABEL_12;
    }
  }
  uint64_t v11 = 0;
LABEL_12:
  if ((v11 & 0xFF80000000000007) != 0) {
    _objc_fatal("Invalid class pointer %p has bits set outside of ISA_MASK", (uint64_t)this, a3, a4, v11);
  }
  *(void *)this = v11 & 0x7FFFFFFFFFFFF8;
  if (*((void *)a4 + 1)) {
    uint64_t v13 = *((void *)a4 + 1);
  }
  else {
    uint64_t v13 = 0;
  }
  *((void *)this + _class_addProperty(cls, name, attributes, attributeCount, 1) = v13;
  *((void *)this + 2) = &_objc_empty_cache;
  *((void *)this + 3) = 0;
  hasSignedClassROPointers((unint64_t)a3);
  *((void *)this + 4) = *((void *)a4 + 4);
  int v14 = *(_DWORD *)(StatusReg + 24);
  int v15 = v14;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v15, 0, memory_order_release, memory_order_relaxed);
  if (v15 != v14)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
}

void sub_180146488(_Unwind_Exception *exception_object)
{
  int v4 = *(_DWORD *)(v2 + 24);
  int v5 = v4;
  atomic_compare_exchange_strong_explicit(v1, (unsigned int *)&v5, 0, memory_order_release, memory_order_relaxed);
  if (v5 != v4) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  _Unwind_Resume(exception_object);
}

atomic_uint *_objc_atfork_prepare()
{
  ForkIsMultithreaded = pthread_is_threaded_np() != 0;
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v0 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  do
  {
    int v2 = 0;
    atomic_compare_exchange_strong_explicit(&PropertyLocks[v0], (unsigned int *)&v2, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v2) {
      os_unfair_lock_lock_with_options();
    }
    v0 += 16;
  }
  while (v0 != 128);
  for (uint64_t i = 0; i != 128; i += 16)
  {
    int v4 = 0;
    atomic_compare_exchange_strong_explicit(&StructLocks[i], (unsigned int *)&v4, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v4) {
      os_unfair_lock_lock_with_options();
    }
  }
  for (uint64_t j = 0; j != 128; j += 16)
  {
    int v6 = 0;
    atomic_compare_exchange_strong_explicit(&CppObjectLocks[j], (unsigned int *)&v6, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v6) {
      os_unfair_lock_lock_with_options();
    }
  }
  unint64_t v7 = 0;
  id v8 = &dword_1EB1CB288;
  id v9 = (char *)&unk_1EB1CB2C0;
  do
  {
    int v10 = 0;
    atomic_compare_exchange_strong_explicit(v8, (unsigned int *)&v10, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v10) {
      os_unfair_lock_lock_with_options();
    }
    unint64_t v11 = v7 + 1;
    if (v7 <= 6) {
      id v12 = v9;
    }
    else {
      id v12 = 0;
    }
    uint64_t v13 = (atomic_uint *)(v12 + 8);
    if (v7 <= 6) {
      id v8 = v13;
    }
    else {
      id v8 = 0;
    }
    v9 += 64;
    ++v7;
  }
  while (v11 != 8);
  int v14 = 0;
  atomic_compare_exchange_strong_explicit(&AssociationsManagerLock, (unsigned int *)&v14, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v14) {
    os_unfair_lock_lock_with_options();
  }
  unint64_t v15 = 0;
  BOOL v17 = (atomic_uint *)&unk_1EB1CB4C0;
  do
  {
    int v18 = 0;
    atomic_compare_exchange_strong_explicit(result, (unsigned int *)&v18, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v18) {
      os_unfair_lock_lock_with_options();
    }
    unint64_t v19 = v15 + 1;
    if (v15 <= 6) {
      __n128 result = v17;
    }
    else {
      __n128 result = 0;
    }
    v17 += 16;
    ++v15;
  }
  while (v19 != 8);
  int v20 = 0;
  atomic_compare_exchange_strong_explicit(classInitLock, (unsigned int *)&v20, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v20) {
    __n128 result = (atomic_uint *)os_unfair_lock_lock_with_options();
  }
  int v21 = 0;
  atomic_compare_exchange_strong_explicit(pendingInitializeMapLock, (unsigned int *)&v21, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v21) {
    __n128 result = (atomic_uint *)os_unfair_lock_lock_with_options();
  }
  int v22 = 0;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v22, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v22) {
    __n128 result = (atomic_uint *)os_unfair_lock_lock_with_options();
  }
  int v23 = 0;
  atomic_compare_exchange_strong_explicit(&DemangleCacheLock, (unsigned int *)&v23, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v23) {
    __n128 result = (atomic_uint *)os_unfair_lock_lock_with_options();
  }
  int v24 = 0;
  atomic_compare_exchange_strong_explicit(selLock, (unsigned int *)&v24, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v24) {
    __n128 result = (atomic_uint *)os_unfair_lock_lock_with_options();
  }
  int v25 = 0;
  atomic_compare_exchange_strong_explicit(objcMsgLogLock, (unsigned int *)&v25, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v25) {
    __n128 result = (atomic_uint *)os_unfair_lock_lock_with_options();
  }
  int v26 = 0;
  atomic_compare_exchange_strong_explicit(AltHandlerDebugLock, (unsigned int *)&v26, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v26) {
    __n128 result = (atomic_uint *)os_unfair_lock_lock_with_options();
  }
  int v27 = 0;
  atomic_compare_exchange_strong_explicit(&crashlog_lock, (unsigned int *)&v27, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v27)
  {
    return (atomic_uint *)os_unfair_lock_lock_with_options();
  }
  return result;
}

void _objc_atfork_parent()
{
  os_unfair_recursive_lock_unlock();
  uint64_t v0 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  do
  {
    int v2 = *(_DWORD *)(StatusReg + 24);
    int v3 = v2;
    atomic_compare_exchange_strong_explicit(&PropertyLocks[v0], (unsigned int *)&v3, 0, memory_order_release, memory_order_relaxed);
    if (v3 != v2) {
      os_unfair_lock_unlock((os_unfair_lock_t)&PropertyLocks[v0]);
    }
    v0 += 16;
  }
  while (v0 != 128);
  for (uint64_t i = 0; i != 128; i += 16)
  {
    int v5 = *(_DWORD *)(StatusReg + 24);
    int v6 = v5;
    atomic_compare_exchange_strong_explicit(&StructLocks[i], (unsigned int *)&v6, 0, memory_order_release, memory_order_relaxed);
    if (v6 != v5) {
      os_unfair_lock_unlock((os_unfair_lock_t)&StructLocks[i]);
    }
  }
  for (uint64_t j = 0; j != 128; j += 16)
  {
    int v8 = *(_DWORD *)(StatusReg + 24);
    int v9 = v8;
    atomic_compare_exchange_strong_explicit(&CppObjectLocks[j], (unsigned int *)&v9, 0, memory_order_release, memory_order_relaxed);
    if (v9 != v8) {
      os_unfair_lock_unlock((os_unfair_lock_t)&CppObjectLocks[j]);
    }
  }
  unint64_t v10 = 0;
  unint64_t v11 = (os_unfair_lock_s *)&dword_1EB1CB288;
  id v12 = (os_unfair_lock_s *)&unk_1EB1CB2C0;
  do
  {
    int v13 = *(_DWORD *)(StatusReg + 24);
    int v14 = v13;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)v11, (unsigned int *)&v14, 0, memory_order_release, memory_order_relaxed);
    if (v14 != v13) {
      os_unfair_lock_unlock(v11);
    }
    unint64_t v15 = v10 + 1;
    if (v10 <= 6) {
      uint64_t v16 = v12;
    }
    else {
      uint64_t v16 = 0;
    }
    BOOL v17 = v16 + 2;
    if (v10 <= 6) {
      unint64_t v11 = v17;
    }
    else {
      unint64_t v11 = 0;
    }
    v12 += 16;
    ++v10;
  }
  while (v15 != 8);
  int v18 = *(_DWORD *)(StatusReg + 24);
  int v19 = v18;
  atomic_compare_exchange_strong_explicit(&AssociationsManagerLock, (unsigned int *)&v19, 0, memory_order_release, memory_order_relaxed);
  if (v19 != v18) {
    os_unfair_lock_unlock((os_unfair_lock_t)&AssociationsManagerLock);
  }
  unint64_t v20 = 0;
  int v22 = (os_unfair_lock_s *)&unk_1EB1CB4C0;
  do
  {
    int v23 = *(_DWORD *)(StatusReg + 24);
    int v24 = v23;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)v21, (unsigned int *)&v24, 0, memory_order_release, memory_order_relaxed);
    if (v24 != v23) {
      os_unfair_lock_unlock(v21);
    }
    unint64_t v25 = v20 + 1;
    if (v20 <= 6) {
      int v21 = v22;
    }
    else {
      int v21 = 0;
    }
    v22 += 16;
    ++v20;
  }
  while (v25 != 8);
  int v26 = *(_DWORD *)(StatusReg + 24);
  int v27 = v26;
  atomic_compare_exchange_strong_explicit(classInitLock, (unsigned int *)&v27, 0, memory_order_release, memory_order_relaxed);
  if (v27 != v26) {
    os_unfair_lock_unlock((os_unfair_lock_t)classInitLock);
  }
  int v28 = *(_DWORD *)(StatusReg + 24);
  int v29 = v28;
  atomic_compare_exchange_strong_explicit(pendingInitializeMapLock, (unsigned int *)&v29, 0, memory_order_release, memory_order_relaxed);
  if (v29 != v28) {
    os_unfair_lock_unlock((os_unfair_lock_t)pendingInitializeMapLock);
  }
  int v30 = *(_DWORD *)(StatusReg + 24);
  int v31 = v30;
  atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v31, 0, memory_order_release, memory_order_relaxed);
  if (v31 != v30) {
    os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
  }
  int v32 = *(_DWORD *)(StatusReg + 24);
  int v33 = v32;
  atomic_compare_exchange_strong_explicit(&DemangleCacheLock, (unsigned int *)&v33, 0, memory_order_release, memory_order_relaxed);
  if (v33 != v32) {
    os_unfair_lock_unlock((os_unfair_lock_t)&DemangleCacheLock);
  }
  int v34 = *(_DWORD *)(StatusReg + 24);
  int v35 = v34;
  atomic_compare_exchange_strong_explicit(selLock, (unsigned int *)&v35, 0, memory_order_release, memory_order_relaxed);
  if (v35 != v34) {
    os_unfair_lock_unlock((os_unfair_lock_t)selLock);
  }
  int v36 = *(_DWORD *)(StatusReg + 24);
  int v37 = v36;
  atomic_compare_exchange_strong_explicit(objcMsgLogLock, (unsigned int *)&v37, 0, memory_order_release, memory_order_relaxed);
  if (v37 != v36) {
    os_unfair_lock_unlock((os_unfair_lock_t)objcMsgLogLock);
  }
  int v38 = *(_DWORD *)(StatusReg + 24);
  int v39 = v38;
  atomic_compare_exchange_strong_explicit(AltHandlerDebugLock, (unsigned int *)&v39, 0, memory_order_release, memory_order_relaxed);
  if (v39 != v38) {
    os_unfair_lock_unlock((os_unfair_lock_t)AltHandlerDebugLock);
  }
  int v40 = *(_DWORD *)(StatusReg + 24);
  int v41 = v40;
  atomic_compare_exchange_strong_explicit(&crashlog_lock, (unsigned int *)&v41, 0, memory_order_release, memory_order_relaxed);
  if (v41 != v40)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&crashlog_lock);
  }
}

objc_class *_objc_atfork_child()
{
  if (ForkIsMultithreaded) {
    BOOL v0 = DisableInitializeForkSafety == 0;
  }
  else {
    BOOL v0 = 0;
  }
  if (v0) {
    MultithreadedForkChild = 1;
  }
  uint64_t v1 = 0;
  loadMethodLocuint64_t k = 0;
  do
  {
    PropertyLocks[v1] = 0;
    v1 += 16;
  }
  while (v1 != 128);
  for (uint64_t i = 0; i != 128; i += 16)
    StructLocks[i] = 0;
  for (uint64_t j = 0; j != 128; j += 16)
    CppObjectLocks[j] = 0;
  unint64_t v4 = 0;
  int v5 = &dword_1EB1CB288;
  int v6 = (char *)&unk_1EB1CB2C0;
  do
  {
    *int v5 = 0;
    unint64_t v7 = v4 + 1;
    if (v4 <= 6) {
      int v8 = v6;
    }
    else {
      int v8 = 0;
    }
    int v5 = (int *)(v8 + 8);
    if (v4 > 6) {
      int v5 = 0;
    }
    v6 += 64;
    ++v4;
  }
  while (v7 != 8);
  unint64_t v9 = 0;
  AssociationsManagerLocuint64_t k = 0;
  unint64_t v11 = (int *)&unk_1EB1CB4C0;
  do
  {
    unint64_t v12 = v9 + 1;
    *unint64_t v10 = 0;
    if (v9 <= 6) {
      unint64_t v10 = v11;
    }
    else {
      unint64_t v10 = 0;
    }
    v11 += 16;
    ++v9;
  }
  while (v12 != 8);
  classInitLock[0] = 0;
  pendingInitializeMapLock[0] = 0;
  runtimeLock[0] = 0;
  DemangleCacheLocuint64_t k = 0;
  selLock[0] = 0;
  objcMsgLogLock[0] = 0;
  AltHandlerDebugLock[0] = 0;
  crashlog_locuint64_t k = 0;
  unint64_t StatusReg = (void *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v14 = StatusReg[40];
  if (v14)
  {
    unint64_t v15 = *(void **)(v14 + 8);
    if (v15) {
      free(v15);
    }
    *(void *)(v14 + 8) = 0;
  }
  uint64_t v16 = 0;
  StatusReg[41] = 0;
  StatusReg[42] = 0;
  do
  {
    BOOL v17 = (void **)((char *)&sDataLists + 64 * v16);
    int v18 = *v17;
    if (*v17)
    {
      do
      {
        int v19 = (void *)*v18;
        free(v18);
        int v18 = v19;
      }
      while (v19);
    }
    *BOOL v17 = 0;
    ++v16;
  }
  while (v16 != 8);
  __n128 result = (objc_class *)_fetchInitializingClassList(0);
  if (result)
  {
    int v24 = result;
    int v25 = *(_DWORD *)result;
    if (*(int *)result >= 1)
    {
      uint64_t v26 = 0;
      do
      {
        __n128 result = *(objc_class **)(*((void *)v24 + 1) + 8 * v26);
        if (result)
        {
          __n128 result = (objc_class *)WAITING_FOR_A_CLASS__initialize_LOCK(result, v21, v22, v23);
          int v25 = *(_DWORD *)v24;
        }
        ++v26;
      }
      while (v26 < v25);
    }
  }
  return result;
}

id imp_getBlock(IMP anImp)
{
  uint64_t v1 = anImp;
  if (anImp)
  {
    int v2 = 0;
    unint64_t v8 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v2, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v2) {
      os_unfair_lock_lock_with_options();
    }
    unint64_t v4 = pageAndIndexContainingIMP(v1, &v8);
    if (v4)
    {
      if ((unint64_t)v4[v8] <= 0x800) {
        uint64_t v1 = 0;
      }
      else {
        uint64_t v1 = (void (*)(void))v4[v8];
      }
    }
    else
    {
      uint64_t v1 = 0;
    }
    int v5 = *(_DWORD *)(StatusReg + 24);
    int v6 = v5;
    atomic_compare_exchange_strong_explicit(runtimeLock, (unsigned int *)&v6, 0, memory_order_release, memory_order_relaxed);
    if (v6 != v5) {
      os_unfair_lock_unlock((os_unfair_lock_t)runtimeLock);
    }
  }
  return v1;
}

void defaultBadAllocHandler(objc_class *a1)
{
  uint64_t v1 = objc_class::nameForLogging(a1);
  _objc_fatal("attempt to allocate object of class '%s' failed", v2, v3, v4, v1);
}

uint64_t objc_object::sidetable_getExtraRC_nolock(objc_object *this)
{
                                           * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  if (*((void *)v1 + 1) + 16 * v1[6] == v2) {
    return 0;
  }
  else {
    return *(void *)(v2 + 8) >> 2;
  }
}

uint64_t objc_object::sidetable_retainCount(objc_object *this)
{
  int v2 = 0;
                                           * (unint64_t)(((this >> 4) ^ (this >> 9)) & 7)];
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  atomic_compare_exchange_strong_explicit(v3, (unsigned int *)&v2, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
  if (v2) {
    os_unfair_lock_lock_with_options();
  }
  if (*((void *)v3 + 1) + 16 * v3[6] == v5) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = (*(void *)(v5 + 8) >> 2) + 1;
  }
  int v7 = *(_DWORD *)(StatusReg + 24);
  int v8 = v7;
  atomic_compare_exchange_strong_explicit(v3, (unsigned int *)&v8, 0, memory_order_release, memory_order_relaxed);
  if (v8 != v7) {
    os_unfair_lock_unlock((os_unfair_lock_t)v3);
  }
  return v6;
}

uint64_t AutoreleasePoolPage::busted<void (*)(char const*,...)>(const void **a1, uint64_t (*a2)(const char *, ...))
{
  return a2("autorelease pool page %p corrupted\n  magic     0x%08x 0x%08x 0x%08x 0x%08x\n  should be 0x%08x 0x%08x 0x%08x 0x%08x\n  pthread   %p\n  should be %p\n", a1, *(_DWORD *)a1, *((_DWORD *)a1 + 1), *((_DWORD *)a1 + 2), *((_DWORD *)a1 + 3), -1583242847, 1330926913, 1162626386, 558191425, a1[3], *(const void **)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)));
}

void sub_180147224(_Unwind_Exception *a1)
{
  *(void *)(v1 - 8) = 0;
  *(void *)(v1 - 16) = 0;
  _Unwind_Resume(a1);
}

uint64_t objc_should_deallocate()
{
  return 1;
}

id objc_retain_autorelease(id a1)
{
  id v1 = a1;

  return v1;
}

void objc_clear_deallocating(objc_object *this, uint64_t a2, const char *a3, char *a4)
{
  if (((unint64_t)this & 0x8000000000000000) == 0)
  {
    if ((uint64_t)this->isa)
    {
      if (((uint64_t)this->isa & 0x80000000000004) != 0) {
        objc_object::clearDeallocating_slow(this, a2, a3, a4);
      }
    }
    else
    {
      objc_object::sidetable_clearDeallocating(this);
    }
  }
}

uint64_t _objc_rootReleaseWasZero(objc_object *a1)
{
  if (((unint64_t)a1 & 0x8000000000000000) != 0) {
    return 0;
  }
  unint64_t isa = (unint64_t)a1->isa;
  if ((uint64_t)a1->isa)
  {
    while (isa >> 55)
    {
      unint64_t v2 = isa - 0x100000000000000;
      if (isa < 0x100000000000000) {
        return objc_object::rootRelease_underflow(a1, 0);
      }
      unint64_t v3 = isa;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)a1, &v3, v2, memory_order_release, memory_order_relaxed);
      if (v3 == isa)
      {
        if (v2 >> 55) {
          return 0;
        }
        __dmb(9u);
        return 1;
      }
      unint64_t isa = v3;
      if ((v3 & 1) == 0) {
        return objc_object::sidetable_release(a1, 0, 0);
      }
    }
    return 0;
  }
  if ((*(_WORD *)((isa & 0xFFFFFFFF8) + 0x1E) & 4) != 0) {
    return 0;
  }
  return objc_object::sidetable_release(a1, 0, 0);
}

void _objc_rootFinalize(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
}

uint64_t _objc_rootZone()
{
  return 0;
}

void weakTableScan(void *a1)
{
  pthread_setname_np("ObjC weak reference scanner");
  timespec __rqtp = (timespec)xmmword_1801515F0;
  id v1 = getenv("OBJC_DEBUG_SCAN_WEAK_TABLES_INTERVAL_NANOSECONDS");
  if (v1)
  {
    unint64_t v2 = strtoull(v1, 0, 10);
    __rqtp.tv_sec = v2 / 0x3B9ACA00;
    __rqtp.tv_nsec = v2 % 0x3B9ACA00;
  }
  uint64_t v3 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  while (1)
  {
    nanosleep(&__rqtp, 0);
    int v9 = 0;
    atomic_compare_exchange_strong_explicit(v5, (unsigned int *)&v9, *(_DWORD *)(StatusReg + 24), memory_order_acquire, memory_order_acquire);
    if (v9) {
      os_unfair_lock_lock_with_options();
    }
    unint64_t v10 = *((void *)v5 + 6);
    if (v10)
    {
      unint64_t v11 = 0;
      uint64_t v12 = *((void *)v5 + 4);
      do
      {
        int v13 = (uint64_t *)(v12 + 40 * v11);
        uint64_t v14 = v13 + 1;
        if ((v13[2] & 3) == 2)
        {
          uint64_t v14 = (void *)*v14;
          uint64_t v15 = *(void *)(v12 + 40 * v11 + 24) + 1;
        }
        else
        {
          uint64_t v15 = 4;
        }
        uint64_t v16 = *v13;
        if (v16) {
          BOOL v17 = v15 == 0;
        }
        else {
          BOOL v17 = 1;
        }
        if (!v17)
        {
          uint64_t v18 = -v16;
          do
          {
            if (*v14)
            {
              int v19 = (void *)-*v14;
              if (*v19 != v18) {
                _objc_fatal("Weak reference at %p contains %p, should contain %p", v6, v7, v8, v19, *v19, v18);
              }
            }
            ++v14;
            --v15;
          }
          while (v15);
        }
        ++v11;
      }
      while (v11 <= v10);
    }
    int v20 = *(_DWORD *)(StatusReg + 24);
    int v21 = v20;
    atomic_compare_exchange_strong_explicit(v5, (unsigned int *)&v21, 0, memory_order_release, memory_order_relaxed);
    if (v21 != v20) {
    if (v3 == 7)
    }
      uint64_t v3 = 0;
    else {
      ++v3;
    }
  }
}

void *objc_tls_direct_base<unsigned long,(tls_key)4,ReturnAutoreleaseInfo::TlsDealloc>::dtor_(uint64_t a1)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  __n128 result = (void *)(*(void *)(StatusReg + 352) & 0xFFFFFFFFFFFFFFFCLL);
  if (result)
  {
    uint64_t v3 = (void *)(StatusReg + 352);
    do
    {
      *uint64_t v3 = 0;
      v3[1] = 0;

      __n128 result = (void *)(*v3 & 0xFFFFFFFFFFFFFFFCLL);
    }
    while (result);
  }
  return result;
}

uint64_t __copy_helper_block_e8_32c47_ZTSKZ34getSharedCachePreoptimizedProtocolE3__0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = *(void *)(a2 + 32);
  return result;
}

uint64_t __copy_helper_block_e8_32c36_ZTSKZ23getPreoptimizedProtocolE3__0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = *(void *)(a2 + 32);
  return result;
}

uint64_t __copy_helper_block_e8_32c33_ZTSKZ20getPreoptimizedClassE3__0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = *(void *)(a2 + 32);
  return result;
}

uint64_t __getPreoptimizedClassesWithMetaClass_block_invoke(uint64_t result, void *a2, int a3, unsigned char *a4)
{
  if (a3)
  {
    if (*(void *)(result + 40) == (*a2 & 0xFFFFFFFF8))
    {
      **(void **)(result + 32) = a2;
      *a4 = 1;
    }
  }
  return result;
}

__n128 __copy_helper_block_e8_32c48_ZTSKZ35getPreoptimizedClassesWithMetaClassE3__0(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[2];
  a1[2] = result;
  return result;
}

void cache_t::bad_cache(cache_t *this, objc_object *a2, objc_selector *a3)
{
  _objc_inform_now_and_on_crash("Method cache corrupted. This may be a message to an invalid object, or a memory error somewhere else.");
  if (a2) {
    uint64_t v6 = "receiver";
  }
  else {
    uint64_t v6 = "unused";
  }
  _objc_inform_now_and_on_crash("%s %p, SEL %p, isa %p, cache %p, buckets and mask 0x%lx, occupied 0x%x", v6, a2, a3, (char *)this - 16, this, *(void *)this, *((unsigned __int16 *)this + 6));
  size_t v7 = malloc_size(a2);
  size_t v8 = malloc_size((const void *)(*(void *)this & 0xFFFFFFFFFFFLL));
  _objc_inform_now_and_on_crash("%s %zu bytes, buckets %zu bytes", v6, v7, v8);
  int v9 = "<null selector>";
  if (a3) {
    int v9 = (const char *)a3;
  }
  _objc_inform_now_and_on_crash("selector '%s'", v9);
  unint64_t v10 = objc_class::nameForLogging((cache_t *)((char *)this - 16));
  _objc_inform_now_and_on_crash("isa '%s'", v10);
  _objc_fatal("Method cache corrupted. This may be a message to an invalid object, or a memory error somewhere else.", v11, v12, v13);
}

void _objc_error(objc_object *a1, va_list a2, char *a3)
{
  size_t v8 = 0;
  vasprintf(&v8, "invalid selector (null)", a2);
  ClassName = object_getClassName(a1);
  _objc_fatal("%s: %s", v5, v6, v7, ClassName, v8);
}

void _objc_fatalv(char *a1, va_list a2, const char *a3, char *a4)
{
  size_t v8 = 0;
  vasprintf(&v8, a1, a2);
  size_t v7 = 0;
  pid_t v4 = getpid();
  asprintf(&v7, "objc[%d]: %s\n", v4, v8);
  _objc_syslog(v7);
  if (!DebugDontCrash)
  {
    _objc_crashlog(v8);
    abort_with_reason();
  }
  uint64_t v6 = 0;
  pid_t v5 = getpid();
  asprintf(&v6, "objc[%d]: HALTED\n", v5);
  _objc_syslog(v6);
  _Exit(1);
}

void __objc_error(objc_object *a1, const char *a2, char *a3, ...)
{
  va_start(va, a3);
  _objc_error(a1, va, a3);
}

void _objc_inform_now_and_on_crash(const char *a1, ...)
{
  va_start(va, a1);
  v3[0] = 0;
  __s1 = 0;
  va_copy((va_list)&v3[1], va);
  vasprintf(v3, a1, va);
  pid_t v1 = getpid();
  asprintf(&__s1, "objc[%d]: %s\n", v1, v3[0]);
  _objc_crashlog(__s1);
  _objc_syslog(__s1);
  free(__s1);
  free(v3[0]);
}

uint64_t _objc_inform_deprecated(const char *a1, const char *a2)
{
  if (PrintDeprecation) {
    _objc_inform("The function %s is obsolete. Do not use it. Set a breakpoint on _objc_warn_deprecated to find the culprit.", a1);
  }

  return gdb_objc_class_changed(a1);
}

void objc_terminate(void)
{
}

void objc::DenseMapBase<objc::DenseMap<objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>,objc_class *,PendingInitialize *,objc::DenseMapValueInfo<PendingInitialize *>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,PendingInitialize *>>::FatalCorruptHashTables(uint64_t a1, void *ptr, uint64_t a3)
{
  size_t v6 = malloc_size(ptr);
  _objc_fatal("Hash table corrupted. This is probably a memory error somewhere. (table at %p, buckets at %p (%zu bytes), %u buckets, %u entries, %u tombstones, data %p %p %p %p)", v7, v8, v9, a1, ptr, v6, a3, *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), *ptr, ptr[1], ptr[2], ptr[3]);
}

void objc::DenseMapBase<objc::DenseMap<method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>,method_t const*,void *,objc::DenseMapValueInfo<void *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,void *>>::FatalCorruptHashTables(void *a1, uint64_t a2)
{
  size_t v4 = malloc_size(a1);
  _objc_fatal("Hash table corrupted. This is probably a memory error somewhere. (table at %p, buckets at %p (%zu bytes), %u buckets, %u entries, %u tombstones, data %p %p %p %p)", v5, v6, v7, &objc::smallMethodIMPMap, a1, v4, a2, qword_1EB1CA738, HIDWORD(qword_1EB1CA738), *a1, a1[1], a1[2], a1[3]);
}

void objc::DenseMapBase<objc::DenseMap<method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>,method_t const*,objc_method_description *,objc::DenseMapValueInfo<objc_method_description *>,objc::DenseMapInfo<method_t const*>,objc::detail::DenseMapPair<method_t const*,objc_method_description *>>::FatalCorruptHashTables(void *a1, uint64_t a2)
{
  size_t v4 = malloc_size(a1);
  _objc_fatal("Hash table corrupted. This is probably a memory error somewhere. (table at %p, buckets at %p (%zu bytes), %u buckets, %u entries, %u tombstones, data %p %p %p %p)", v5, v6, v7, &objc::methodDescriptionMap, a1, v4, a2, qword_1EB1CA558, HIDWORD(qword_1EB1CA558), *a1, a1[1], a1[2], a1[3]);
}

void objc::DenseMapBase<objc::DenseMap<objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>,objc_class *,objc::category_list,objc::DenseMapValueInfo<objc::category_list>,objc::DenseMapInfo<objc_class *>,objc::detail::DenseMapPair<objc_class *,objc::category_list>>::FatalCorruptHashTables(void *a1, uint64_t a2)
{
  size_t v4 = malloc_size(a1);
  _objc_fatal("Hash table corrupted. This is probably a memory error somewhere. (table at %p, buckets at %p (%zu bytes), %u buckets, %u entries, %u tombstones, data %p %p %p %p)", v5, v6, v7, &objc::unattachedCategories, a1, v4, a2, qword_1EB1CB0C0, HIDWORD(qword_1EB1CB0C0), *a1, a1[1], a1[2], a1[3]);
}

void printReplacements(_WORD *a1, uint64_t a2, const char *a3, char *a4)
{
  if (a3)
  {
    uint64_t v4 = 0;
    __int16 v63 = a1[15];
    uint64_t v60 = a1 + 16;
    uint64_t v59 = a3;
    unint64_t v6 = dataSegmentsRanges;
    unint64_t v5 = *(void *)algn_1EB1CB078;
    while (1)
    {
      uint64_t v7 = *(void *)(a2 + 16 * v4);
      BOOL v61 = (const char **)v7;
      if ((v63 & 4) != 0)
      {
        size_t v8 = *(int **)(v7 + 24);
        if (!v8) {
          goto LABEL_67;
        }
      }
      else
      {
        size_t v8 = *(int **)(v7 + 16);
        if (!v8) {
          goto LABEL_67;
        }
      }
      unint64_t v9 = *v8;
      uint64_t v10 = v9 >> 31;
      if ((uint64_t)v8 < 0) {
        uint64_t v10 = 2;
      }
      unint64_t v11 = v10 | (unint64_t)(v8 + 2) & 0xFFFFFFFFFFFFFFFCLL;
      entsize_list_tt<method_t,method_list_t,4294901763u,method_t::pointer_modifier>::end(v8, a2, a3, a4);
      uint64_t v62 = a2;
      if (v11 != a2) {
        break;
      }
LABEL_67:
      if (++v4 == v59) {
        return;
      }
    }
    uint64_t v65 = v4;
LABEL_11:
    if ((v11 & 3) != 0)
    {
      if ((v11 & 3) == 2)
      {
        if (*(void *)(v11 & 0xFFFFFFFFFFFFFFFCLL)) {
          uint64_t v12 = *(char **)(v11 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else {
          uint64_t v12 = 0;
        }
      }
      else
      {
        unint64_t v13 = v11 & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v14 = *(int *)(v11 & 0xFFFFFFFFFFFFFFFCLL);
        if (v6 <= (v11 & 0xFFFFFFFFFFFFFFFCLL) && v5 > v13) {
          uint64_t v12 = (char *)&unk_1F62995A8 + v14;
        }
        else {
          uint64_t v12 = *(char **)(v13 + v14);
        }
      }
    }
    else
    {
      uint64_t v12 = *(char **)(v11 & 0xFFFFFFFFFFFFFFFCLL);
    }
    int v19 = (char *)__sel_registerName(v12, 1, 1);
    if (!v4)
    {
LABEL_48:
      class_rw_t::methods(v70, *v60 & 0xF00007FFFFFFFF8);
      list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::begin((uint64_t)v68, v70, v36, v37);
      list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::end((uint64_t)v67, v70, v38, v39);
      while ((list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator==((uint64_t)v68, v67) & 1) == 0)
      {
        unint64_t v40 = v69;
        if ((v69 & 3) != 0)
        {
          if ((v69 & 3) == 2)
          {
            if (*(void *)(v69 & 0xFFFFFFFFFFFFFFFCLL)) {
              int v41 = *(char **)(v69 & 0xFFFFFFFFFFFFFFFCLL);
            }
            else {
              int v41 = 0;
            }
          }
          else
          {
            unint64_t v42 = v69 & 0xFFFFFFFFFFFFFFFCLL;
            uint64_t v43 = *(int *)(v69 & 0xFFFFFFFFFFFFFFFCLL);
            if (v6 <= (v69 & 0xFFFFFFFFFFFFFFFCLL) && v5 > v42) {
              int v41 = (char *)&unk_1F62995A8 + v43;
            }
            else {
              int v41 = *(char **)(v42 + v43);
            }
          }
        }
        else
        {
          int v41 = *(char **)(v69 & 0xFFFFFFFFFFFFFFFCLL);
        }
        if (v19 == __sel_registerName(v41, 1, 1))
        {
          uint64_t v53 = objc_class::nameForLogging((objc_class *)a1);
          int v54 = ((unsigned __int16)a1[15] >> 2) & 1;
          char v55 = *v61;
          unint64_t v56 = (void *)method_t::impRaw(v40);
          unint64_t v57 = (const void *)method_t::impRaw(v11);
          int v58 = v54;
          uint64_t v4 = v65;
          logReplacedMethod(v53, v19, v58, v55, v56, v57);
          goto LABEL_66;
        }
        list_array_tt<method_t,method_list_t,method_list_t_authed_ptr>::iteratorImpl<false>::operator++(v68, v45, v46, v47);
      }
      goto LABEL_66;
    }
    uint64_t v20 = 0;
    while (1)
    {
      uint64_t v21 = *(void *)(a2 + 16 * v20);
      if ((v63 & 4) != 0)
      {
        uint64_t v22 = *(unsigned int **)(v21 + 24);
        if (!v22) {
          goto LABEL_47;
        }
      }
      else
      {
        uint64_t v22 = *(unsigned int **)(v21 + 16);
        if (!v22) {
          goto LABEL_47;
        }
      }
      unint64_t v23 = *v22;
      uint64_t v24 = v22[1];
      unsigned int v25 = *v22 & 0xFFFC;
      unint64_t v26 = v24 * (unint64_t)((unsigned __int16)v23 & 0xFFFC);
      if ((v26 & 0xFFFFFFFF00000000) != 0) {
        _objc_fatal("entsize_list_tt overflow: index %u in list %p with entsize %u", v16, v17, v18, v24, v22, v23 & 0xFFFC);
      }
      uint64_t v27 = v23 >> 31;
      if ((uint64_t)v22 < 0) {
        uint64_t v27 = 2;
      }
      unint64_t v28 = (unint64_t)(v22 + 2) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v29 = v27 | v28;
      unint64_t v30 = ((unint64_t)v22 + v26 + 8) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v31 = v30 | v27;
      if ((v27 | v28) != (v30 | v27))
      {
        while (1)
        {
          if ((v29 & 3) != 0)
          {
            if ((v29 & 3) == 2)
            {
              int v32 = *(void *)(v29 & 0xFFFFFFFFFFFFFFFCLL) ? *(char **)(v29 & 0xFFFFFFFFFFFFFFFCLL) : 0;
            }
            else
            {
              unint64_t v33 = v29 & 0xFFFFFFFFFFFFFFFCLL;
              uint64_t v34 = *(int *)(v29 & 0xFFFFFFFFFFFFFFFCLL);
              BOOL v35 = v6 <= (v29 & 0xFFFFFFFFFFFFFFFCLL) && v5 > v33;
              int v32 = v35 ? (char *)&unk_1F62995A8 + v34 : *(char **)(v33 + v34);
            }
          }
          else
          {
            int v32 = *(char **)(v29 & 0xFFFFFFFFFFFFFFFCLL);
          }
          if (v19 == __sel_registerName(v32, 1, 1)) {
            break;
          }
          v29 += v25;
          if (v29 == v31) {
            goto LABEL_47;
          }
        }
        uint64_t v48 = objc_class::nameForLogging((objc_class *)a1);
        int v49 = ((unsigned __int16)a1[15] >> 2) & 1;
        int v50 = *v61;
        int v51 = (void *)method_t::impRaw(v29);
        unint64_t v52 = (const void *)method_t::impRaw(v11);
        logReplacedMethod(v48, v19, v49, v50, v51, v52);
        uint64_t v4 = v65;
LABEL_66:
        v11 += (unsigned __int16)v9 & 0xFFFC;
        if (v11 == v62) {
          goto LABEL_67;
        }
        goto LABEL_11;
      }
LABEL_47:
      ++v20;
      uint64_t v4 = v65;
      if (v20 == v65) {
        goto LABEL_48;
      }
    }
  }
}

void objc_defaultForwardHandler(objc_object *a1, objc_selector *a2)
{
  Class Class = object_getClass(a1);
  uint64_t v5 = 45;
  if (Class)
  {
    if ((*((_WORD *)Class + 15) & 4) != 0) {
      uint64_t v5 = 43;
    }
    else {
      uint64_t v5 = 45;
    }
  }
  ClassName = object_getClassName(a1);
  uint64_t v10 = "<null selector>";
  if (a2) {
    uint64_t v10 = (const char *)a2;
  }
  _objc_fatal("%c[%s %s]: unrecognized selector sent to instance %p (no message forward handler is installed)", v7, v8, v9, v5, ClassName, v10, a1);
}

void objc::DenseMapBase<objc::DenseMap<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>,DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>,objc::DenseMapValueInfo<objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>,objc::DenseMapInfo<DisguisedPtr<objc_object>>,objc::detail::DenseMapPair<DisguisedPtr<objc_object>,objc::DenseMap<void const*,objc::ObjcAssociation,objc::DenseMapValueInfo<objc::ObjcAssociation>,objc::DenseMapInfo<void const*>,objc::detail::DenseMapPair<void const*,objc::ObjcAssociation>>>>::FatalCorruptHashTables(void *a1, uint64_t a2)
{
  size_t v4 = malloc_size(a1);
  _objc_fatal("Hash table corrupted. This is probably a memory error somewhere. (table at %p, buckets at %p (%zu bytes), %u buckets, %u entries, %u tombstones, data %p %p %p %p)", v5, v6, v7, &objc::AssociationsManager::_mapStorage, a1, v4, a2, qword_1EB1CAC50, HIDWORD(qword_1EB1CAC50), *a1, a1[1], a1[2], a1[3]);
}

void AutoreleasePoolPage::busted_die(const void **this)
{
}

void _objc_callBadAllocHandler(objc_class *a1)
{
}

uint64_t AutoreleasePoolPage::badPop(AutoreleasePoolPage *this, void *a2)
{
  unint64_t v2 = this;
  if (DebugPoolAllocation == 2
    || (this = (AutoreleasePoolPage *)dyld_program_sdk_at_least(), (this & 1) != 0)
    || (this = (AutoreleasePoolPage *)dyld_program_sdk_at_least(), (this & 1) != 0)
    || (this = (AutoreleasePoolPage *)dyld_program_sdk_at_least(), (this & 1) != 0)
    || (this = (AutoreleasePoolPage *)dyld_program_sdk_at_least(), (this & 1) != 0))
  {
    char v3 = 1;
  }
  else
  {
    this = (AutoreleasePoolPage *)dyld_program_sdk_at_least();
    char v3 = (char)this;
  }
  if (AutoreleasePoolPage::badPop(void *)::complained)
  {
    uint64_t result = gdb_objc_class_changed(this);
    if ((v3 & 1) == 0) {
      return result;
    }
LABEL_16:
    _objc_fatal("Invalid autorelease pools are a fatal error", v5, v6, v7);
  }
  AutoreleasePoolPage::badPop(void *)::complained = 1;
  _objc_inform_now_and_on_crash("Invalid or prematurely-freed autorelease pool %p. Set a breakpoint on objc_autoreleasePoolInvalid to debug. ", v2);
  if (v3)
  {
    gdb_objc_class_changed(v8);
    goto LABEL_16;
  }
  _objc_inform("Proceeding anyway.  Memory errors are likely.");

  return gdb_objc_class_changed(v9);
}

void AutoreleasePoolPage::printHiwat(AutoreleasePoolPage *this)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v2 = *(void *)(StatusReg + 344);
  if (v2)
  {
    if (v2 == 1)
    {
      uint64_t v2 = 0;
    }
    else if (*(_DWORD *)v2 != -1583242847)
    {
      AutoreleasePoolPage::busted_die(*(const void ***)(StatusReg + 344));
    }
  }
  unsigned int v3 = ((unint64_t)(*(void *)(v2 + 16) - v2 - 56) >> 3) + (*(_DWORD *)(v2 + 48) << 9);
  if (*(_DWORD *)(v2 + 52) + 256 < v3)
  {
    int v4 = 0;
    do
    {
      *(_DWORD *)(v2 + 52) = v3;
      v4 += AutoreleasePoolPage::sumOfExtraReleases((AutoreleasePoolPage *)v2);
      uint64_t v2 = *(void *)(v2 + 32);
    }
    while (v2);
    _objc_inform("POOL HIGHWATER: new high water mark of %u pending releases for thread %p:", v3, *(const void **)StatusReg);
    if (v4) {
      _objc_inform("POOL HIGHWATER: extra sequential autoreleases of objects: %u", v4);
    }
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    *(_OWORD *)unint64_t v11 = 0u;
    long long v12 = 0u;
    int v5 = backtrace(v11, 128);
    unint64_t v6 = backtrace_symbols(v11, v5);
    uint64_t v7 = v6;
    if (v5 >= 1)
    {
      uint64_t v8 = v5;
      uint64_t v9 = (const char **)v6;
      do
      {
        uint64_t v10 = *v9++;
        _objc_inform("POOL HIGHWATER:     %s", v10);
        --v8;
      }
      while (v8);
    }
    free(v7);
  }
}

uint64_t AutoreleasePoolPage::sumOfExtraReleases(AutoreleasePoolPage *this)
{
  pid_t v1 = (unint64_t *)((char *)this + 56);
  unint64_t v2 = *((void *)this + 2);
  if ((unint64_t)this + 56 >= v2) {
    return 0;
  }
  LODWORD(result) = 0;
  do
  {
    unint64_t v4 = *v1++;
    unsigned int v5 = result + ((v4 >> 44) & 0xFF0 | (v4 >> 60));
    if (v4) {
      uint64_t result = v5;
    }
    else {
      uint64_t result = result;
    }
  }
  while ((unint64_t)v1 < v2);
  return result;
}

void AutoreleasePoolPage::printAll(AutoreleasePoolPage *this)
{
  _objc_inform("##############");
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  _objc_inform("AUTORELEASE POOLS for thread %p", *(const void **)StatusReg);
  unint64_t v2 = *(void *)(StatusReg + 344);
  if (v2 >= 2)
  {
    if (*(_DWORD *)v2 != -1583242847) {
LABEL_14:
    }
      AutoreleasePoolPage::busted_die((const void **)v2);
    while (1)
    {
      unsigned int v3 = *(const void ***)(v2 + 32);
      if (!v3) {
        break;
      }
      unint64_t v2 = *(void *)(v2 + 32);
      if (*(_DWORD *)v3 != -1583242847) {
        AutoreleasePoolPage::busted_die(v3);
      }
    }
    do
    {
      unsigned int v3 = (const void **)((char *)v3 + ((uint64_t)(*(void *)(v2 + 16) - v2 - 56) >> 3));
      unint64_t v2 = *(void *)(v2 + 40);
    }
    while (v2);
  }
  else
  {
    unsigned int v3 = 0;
  }
  _objc_inform("%llu releases pending.", v3);
  unint64_t v4 = *(void *)(StatusReg + 344);
  if (v4 == 1)
  {
    _objc_inform("[%p]  ................  PAGE (placeholder)", (const void *)1);
    _objc_inform("[%p]  ################  POOL (placeholder)", (const void *)1);
  }
  else if (v4 >= 2)
  {
    if (*(_DWORD *)v4 != -1583242847) {
      AutoreleasePoolPage::busted_die((const void **)v4);
    }
    while (1)
    {
      unint64_t v2 = *(void *)(v4 + 32);
      if (!v2) {
        break;
      }
      unint64_t v4 = *(void *)(v4 + 32);
      if (*(_DWORD *)v2 != -1583242847) {
        goto LABEL_14;
      }
    }
    do
    {
      AutoreleasePoolPage::print((AutoreleasePoolPage *)v4);
      unint64_t v4 = *(void *)(v4 + 40);
    }
    while (v4);
  }

  _objc_inform("##############");
}

void AutoreleasePoolPage::print(AutoreleasePoolPage *this)
{
  unint64_t v2 = "";
  if (*((AutoreleasePoolPage **)this + 2) == (AutoreleasePoolPage *)((char *)this + 4096)) {
    unsigned int v3 = "(full)";
  }
  else {
    unsigned int v3 = "";
  }
  unint64_t StatusReg = (void *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  unint64_t v5 = StatusReg[43];
  if (v5)
  {
    if (v5 == 1)
    {
      unint64_t v6 = 0;
      goto LABEL_9;
    }
    if (*(_DWORD *)v5 != -1583242847) {
      goto LABEL_30;
    }
  }
  unint64_t v6 = (AutoreleasePoolPage *)StatusReg[43];
LABEL_9:
  if (v6 == this) {
    uint64_t v7 = "(hot)";
  }
  else {
    uint64_t v7 = "";
  }
  if (v5 >= 2)
  {
    while (*(_DWORD *)v5 == -1583242847)
    {
      uint64_t v8 = (AutoreleasePoolPage *)v5;
      unint64_t v5 = *(void *)(v5 + 32);
      if (!v5) {
        goto LABEL_16;
      }
    }
LABEL_30:
    AutoreleasePoolPage::busted_die((const void **)v5);
  }
  uint64_t v8 = 0;
LABEL_16:
  if (v8 == this) {
    unint64_t v2 = "(cold)";
  }
  _objc_inform("[%p]  ................  PAGE %s %s %s", this, v3, v7, v2);
  if (*(_DWORD *)this != -1583242847
    || strncmp((const char *)this + 4, "AUTORELEASE!", 0xCuLL)
    || *((void *)this + 3) != *StatusReg)
  {
    AutoreleasePoolPage::busted<void (*)(char const*,...)>((const void **)this, (uint64_t (*)(const char *, ...))_objc_inform);
  }
  uint64_t v9 = (id *)((char *)this + 56);
  if ((unint64_t)this + 56 < *((void *)this + 2))
  {
    do
    {
      unint64_t v10 = (unint64_t)*v9;
      if (*v9)
      {
        if ((v10 >> 44) & 0xFF0 | (v10 >> 60))
        {
          object_getClassName((id)(v10 & 0xF00FFFFFFFFFFFFLL));
          _objc_inform("[%p]  %#16lx  %s  autorelease count %lu");
        }
        else
        {
          object_getClassName(*v9);
          _objc_inform("[%p]  %#16lx  %s");
        }
      }
      else
      {
        _objc_inform("[%p]  ################  POOL %p");
      }
      ++v9;
    }
    while ((unint64_t)v9 < *((void *)this + 2));
  }
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1F40C9A70](aBlock);
}

void _Block_release(const void *aBlock)
{
}

void _Exit(int a1)
{
}

char ***_NSGetEnviron(void)
{
  return (char ***)MEMORY[0x1F40C9AE0]();
}

mach_header_64 *_NSGetMachExecuteHeader(void)
{
  return (mach_header_64 *)MEMORY[0x1F40C9AF0]();
}

uintptr_t _Unwind_GetCFA(_Unwind_Context *a1)
{
  return MEMORY[0x1F40C9B00](a1);
}

uintptr_t _Unwind_GetIP(_Unwind_Context *context)
{
  return MEMORY[0x1F40C9B08](context);
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

void std::__libcpp_verbose_abort(const char *__format, ...)
{
}

std::terminate_handler std::set_terminate(std::terminate_handler a1)
{
  return (std::terminate_handler)MEMORY[0x1F417EFF8](a1);
}

void std::terminate(void)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1F417F008](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1F417F010](a1);
}

struct type_info *__cxa_current_exception_type(void)
{
  return (struct type_info *)MEMORY[0x1F417F018]();
}

void __cxa_end_catch(void)
{
}

void __cxa_rethrow(void)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

uint64_t _dyld_for_each_objc_class()
{
  return MEMORY[0x1F40C9DE0]();
}

uint64_t _dyld_for_each_objc_protocol()
{
  return MEMORY[0x1F40C9DE8]();
}

uint64_t _dyld_for_objc_header_opt_ro()
{
  return MEMORY[0x1F40C9DF0]();
}

uint64_t _dyld_for_objc_header_opt_rw()
{
  return MEMORY[0x1F40C9DF8]();
}

uint64_t _dyld_get_dlopen_image_header()
{
  return MEMORY[0x1F40C9E00]();
}

uint64_t _dyld_get_image_slide()
{
  return MEMORY[0x1F40C9E18]();
}

uint64_t _dyld_get_image_uuid()
{
  return MEMORY[0x1F40C9E20]();
}

uint64_t _dyld_get_objc_selector()
{
  return MEMORY[0x1F40C9E30]();
}

uint64_t _dyld_get_prog_image_header()
{
  return MEMORY[0x1F40C9E38]();
}

uint64_t _dyld_get_shared_cache_range()
{
  return MEMORY[0x1F40C9E40]();
}

uint64_t _dyld_get_shared_cache_uuid()
{
  return MEMORY[0x1F40C9E48]();
}

uint64_t _dyld_is_memory_immutable()
{
  return MEMORY[0x1F40C9E70]();
}

uint64_t _dyld_lookup_section_info()
{
  return MEMORY[0x1F40C9E90]();
}

uint64_t _dyld_objc_class_count()
{
  return MEMORY[0x1F40C9E98]();
}

uint64_t _dyld_objc_register_callbacks()
{
  return MEMORY[0x1F40C9EA0]();
}

uint64_t _os_feature_enabled_simple_impl()
{
  return MEMORY[0x1F40C9FB8]();
}

uint64_t _os_log_simple()
{
  return MEMORY[0x1F40CA008]();
}

uint64_t _simple_asl_log()
{
  return MEMORY[0x1F40CA1A0]();
}

void abort(void)
{
}

uint64_t abort_with_reason()
{
  return MEMORY[0x1F40CA1F8]();
}

void arc4random_buf(void *__buf, size_t __nbytes)
{
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return MEMORY[0x1F40CA3C0](*(void *)&__upper_bound);
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x1F40CA440](a1, a2);
}

int backtrace(void **a1, int a2)
{
  return MEMORY[0x1F40CA4F8](a1, *(void *)&a2);
}

char **__cdecl backtrace_symbols(void *const *a1, int a2)
{
  return (char **)MEMORY[0x1F40CA508](a1, *(void *)&a2);
}

void backtrace_symbols_fd(void *const *a1, int a2, int a3)
{
}

void bzero(void *a1, size_t a2)
{
}

int dladdr(const void *a1, Dl_info *a2)
{
  return MEMORY[0x1F40CBDA0](a1, a2);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1F40CBDB0]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1F40CBDB8](__path, *(void *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1F40CBDC8](__handle, __symbol);
}

uint64_t dyld_image_header_containing_address()
{
  return MEMORY[0x1F40CBE68]();
}

uint64_t dyld_image_path_containing_address()
{
  return MEMORY[0x1F40CBE70]();
}

uint64_t dyld_program_sdk_at_least()
{
  return MEMORY[0x1F40CBEC8]();
}

uint64_t dyld_shared_cache_some_image_overridden()
{
  return MEMORY[0x1F40CBF10]();
}

int fileno(FILE *a1)
{
  return MEMORY[0x1F40CC110](a1);
}

void free(void *a1)
{
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1F40CC2B8](*(void *)&a1, a2);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1F40CC3B0](a1);
}

pid_t getpid(void)
{
  return MEMORY[0x1F40CC4A0]();
}

char *__cdecl getsectdatafromheader_64(const mach_header_64 *mhp, const char *segname, const char *sectname, uint64_t *size)
{
  return (char *)MEMORY[0x1F40CC520](mhp, segname, sectname, size);
}

uint8_t *__cdecl getsegmentdata(const mach_header_64 *mhp, const char *segname, unint64_t *size)
{
  return (uint8_t *)MEMORY[0x1F40CC538](mhp, segname, size);
}

int issetugid(void)
{
  return MEMORY[0x1F40CC6C0]();
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return (char *)MEMORY[0x1F40CC940](*(void *)&error_value);
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return MEMORY[0x1F40CC9B8](*(void *)&task, *(void *)&name);
}

size_t malloc_size(const void *ptr)
{
  return MEMORY[0x1F40CCB80](ptr);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB90](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB98](size, type_id);
}

int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return MEMORY[0x1F40CCBA0](memptr, alignment, size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBA8](ptr, size, type_id);
}

uint64_t malloc_type_zone_malloc_with_options_internal()
{
  return MEMORY[0x1F40CCBC8]();
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1F40CCCE8](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD10](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD20](__b, *(void *)&__c, __len);
}

int nanosleep(const timespec *__rqtp, timespec *__rmtp)
{
  return MEMORY[0x1F40CCEA0](__rqtp, __rmtp);
}

uint64_t objc_bp_assist_cfg_np()
{
  return MEMORY[0x1F40CD0D8]();
}

uint64_t os_fault_with_payload()
{
  return MEMORY[0x1F40CD328]();
}

uint64_t os_parse_boot_arg_string()
{
  return MEMORY[0x1F40CD530]();
}

uint64_t os_unfair_lock_lock_with_options()
{
  return MEMORY[0x1F40CD5E8]();
}

BOOL os_unfair_lock_trylock(os_unfair_lock_t lock)
{
  return MEMORY[0x1F40CD5F0](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_unfair_recursive_lock_lock_with_options()
{
  return MEMORY[0x1F40CD610]();
}

uint64_t os_unfair_recursive_lock_tryunlock4objc()
{
  return MEMORY[0x1F40CD620]();
}

uint64_t os_unfair_recursive_lock_unlock()
{
  return MEMORY[0x1F40CD628]();
}

uint64_t os_variant_allows_internal_security_policies()
{
  return MEMORY[0x1F40CD630]();
}

uint64_t os_variant_has_internal_diagnostics()
{
  return MEMORY[0x1F40CD650]();
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x1F40CD9B8](a1, a2, a3, a4);
}

int pthread_detach(pthread_t a1)
{
  return MEMORY[0x1F40CD9D8](a1);
}

int pthread_is_threaded_np(void)
{
  return MEMORY[0x1F40CDA30]();
}

uint64_t pthread_key_init_np()
{
  return MEMORY[0x1F40CDA50]();
}

mach_port_t pthread_mach_thread_np(pthread_t a1)
{
  return MEMORY[0x1F40CDA60](a1);
}

int pthread_setname_np(const char *a1)
{
  return MEMORY[0x1F40CDB60](a1);
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x1F40CDC88](__ptr, __size);
}

uint64_t sandbox_check()
{
  return MEMORY[0x1F40CDDD0]();
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1F40CE080](__str, __size, __format);
}

int strcasecmp(const char *a1, const char *a2)
{
  return MEMORY[0x1F40CE138](a1, a2);
}

char *__cdecl strcat(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1F40CE148](__s1, __s2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1F40CE150](__s, *(void *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1F40CE158](__s1, __s2);
}

size_t strcspn(const char *__s, const char *__charset)
{
  return MEMORY[0x1F40CE170](__s, __charset);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1F40CE178](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1F40CE188](*(void *)&__errnum);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1F40CE1F0](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x1F40CE1F8](__dst, __src, __n);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1F40CE258](__s1, __s2);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1F40CE2A0](__str, __endptr, *(void *)&__base);
}

unint64_t strtoull(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1F40CE2F0](__str, __endptr, *(void *)&__base);
}

uint64_t task_restartable_ranges_register()
{
  return MEMORY[0x1F40CE4A0]();
}

uint64_t task_restartable_ranges_synchronize()
{
  return MEMORY[0x1F40CE4A8]();
}

kern_return_t task_threads(task_inspect_t target_task, thread_act_array_t *act_list, mach_msg_type_number_t *act_listCnt)
{
  return MEMORY[0x1F40CE4D8](*(void *)&target_task, act_list, act_listCnt);
}

kern_return_t thread_get_state(thread_read_t target_act, thread_state_flavor_t flavor, thread_state_t old_state, mach_msg_type_number_t *old_stateCnt)
{
  return MEMORY[0x1F40CE528](*(void *)&target_act, *(void *)&flavor, old_state, old_stateCnt);
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return MEMORY[0x1F40CE680](a1, a2, a3);
}

kern_return_t vm_allocate(vm_map_t target_task, vm_address_t *address, vm_size_t size, int flags)
{
  return MEMORY[0x1F40CE6A8](*(void *)&target_task, address, size, *(void *)&flags);
}

kern_return_t vm_deallocate(vm_map_t target_task, vm_address_t address, vm_size_t size)
{
  return MEMORY[0x1F40CE6C0](*(void *)&target_task, address, size);
}

kern_return_t vm_remap(vm_map_t target_task, vm_address_t *target_address, vm_size_t size, vm_address_t mask, int flags, vm_map_t src_task, vm_address_t src_address, BOOLean_t copy, vm_prot_t *cur_protection, vm_prot_t *max_protection, vm_inherit_t inheritance)
{
  return MEMORY[0x1F40CE700](*(void *)&target_task, target_address, size, mask, *(void *)&flags, *(void *)&src_task, src_address, *(void *)&copy);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x1F40CE928](*(void *)&__fd, __buf, __nbyte);
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_libswiftCore_dylib(double a1)
{
  return a1;
}

double gotLoadHelper_x16__swift_retain(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_libswiftCore_dylib)) {
    return dlopenHelper_libswiftCore_dylib(result);
  }
  return result;
}

double gotLoadHelper_x16__swift_release(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_libswiftCore_dylib)) {
    return dlopenHelper_libswiftCore_dylib(result);
  }
  return result;
}