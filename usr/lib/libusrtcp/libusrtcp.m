uint64_t tcp_log_packet(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  int v4;

  result = *(void *)(*(void *)(a1 + 80) + 224);
  if (result && (*(unsigned char *)(result + 828) & 6) == 0)
  {
    v3 = nw_tcp_access_globals(result);
    if (*(_DWORD *)(a1 + 1776)) {
      nw_log_ms_to_delta();
    }
    v4 = *(_DWORD *)(v3 + 316);
    if (!v4) {
      v4 = -1;
    }
    *(_DWORD *)(a1 + 1776) = v4;
    return nw_log_ring_append();
  }
  return result;
}

uint64_t tcp_cc_delay_ack(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(sysctls + 36);
  if ((v3 - 1) >= 2)
  {
    if (v3 == 3)
    {
      if (*(_DWORD *)(sysctls + 288))
      {
        unsigned int v5 = tcp_sbspace(a1);
        unsigned int v6 = 0xFFFF << *(unsigned char *)(a1 + 261);
        if (v5 < v6) {
          unsigned int v6 = v5;
        }
        if ((*(unsigned char *)(a1 + 90) & 4) != 0
          || *(_WORD *)(a1 + 308)
          || *(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 224) + 488) <= *(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 224)
                                                                                         + 496)
          || v6 > *(_DWORD *)(a1 + 132))
        {
          return 0;
        }
        unsigned int v7 = *(_DWORD *)(a1 + 120) - *(_DWORD *)(a1 + 284);
        unsigned int v8 = *(_DWORD *)(a1 + 196);
        if (v7 <= v8)
        {
          if (v7 >= v6 >> 2) {
            return 0;
          }
        }
        else if (v7 >= v6 >> 2 || v6 <= *(_DWORD *)(sysctls + 236) + (*(int *)(sysctls + 236) >> 1))
        {
          return 0;
        }
        if (v7 < v8 << 8)
        {
          ++*(_DWORD *)(a1 + 728);
          return 1;
        }
      }
      else
      {
        int v9 = *(_DWORD *)(a1 + 88);
        if ((v9 & 0x40000) == 0 && (*(unsigned char *)(a2 + 13) & 8) == 0)
        {
          int v10 = *(unsigned __int16 *)(a1 + 304);
          if (v10 == 1 || v9 < 0 && *(_DWORD *)(sysctls + 52) > v10) {
            return 1;
          }
        }
      }
    }
  }
  else if ((*(unsigned char *)(a1 + 90) & 4) == 0 && (*(unsigned char *)(a2 + 13) & 8) == 0 && *(_WORD *)(a1 + 304) == 1)
  {
    return 1;
  }
  return 0;
}

uint64_t tcp_sbspace(uint64_t a1)
{
  v2 = *(_DWORD **)(*(void *)(a1 + 80) + 224);
  int v3 = v2 + 122;
  int v4 = *(_DWORD *)(a1 + 196);
  unsigned int v5 = v2[123];
  if (*(_DWORD *)(sysctls + 40) != 1
    && (v2[92] & 0x4000) == 0
    && *(_DWORD *)(sysctls + 68) == 1
    && !(*(_DWORD *)(a1 + 88) & 0x80000 | v2[92] & 0x40))
  {
    int v6 = 16 * v4;
    if (v5 - *v3 < 16 * v4)
    {
      unsigned int v7 = *(_DWORD *)(sysctls + 72);
      if (v5 < v7)
      {
        int v8 = v2[135];
        if (v8 && v5 <= v8 + v6)
        {
          if (v5 + v6 >= v7) {
            unsigned int v10 = *(_DWORD *)(sysctls + 72);
          }
          else {
            unsigned int v10 = v5 + v6;
          }
          sbreserve((uint64_t)(v2 + 122), v10);
          unsigned int v5 = v2[123];
          int v4 = *(_DWORD *)(a1 + 196);
        }
      }
    }
  }
  uint64_t result = (v5 - *v3) & ~((int)(v5 - *v3) >> 31);
  if ((int)result >= v4 && (*(unsigned char *)(a1 + 90) & 8) != 0)
  {
    int v12 = *(_DWORD *)(sysctls + 48);
    if ((int)result >= v12) {
      unsigned int v13 = *(_DWORD *)(sysctls + 48);
    }
    else {
      unsigned int v13 = (v5 - *v3) & ~((int)(v5 - *v3) >> 31);
    }
    if (v12 <= 0) {
      return result;
    }
    else {
      return v13;
    }
  }
  return result;
}

uint64_t tcp_usr_rcvd(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (!*a1 || *(_DWORD *)(v1 + 232) == 3) {
    return 22;
  }
  int v4 = *(int **)(v1 + 240);
  uint64_t v5 = nw_tcp_access_globals(*(void *)(v1 + 224));
  calculate_tcp_clock(v5);
  if (v4)
  {
    if (*(_DWORD *)(sysctls + 68) == 1)
    {
      unsigned int v6 = *((_DWORD *)a1 + 135);
      if (v6)
      {
        unsigned int v7 = *((_DWORD *)a1 + 123);
        int v8 = v7 - v6;
        if (v7 > v6)
        {
          unsigned int v9 = v6 >> 4;
          if (v4[31] - v4[30] > v9) {
            unsigned int v9 = v4[31] - v4[30];
          }
          if (!v9) {
            unsigned int v9 = 8 * v4[49];
          }
          int v10 = v7 - v9 - *((_DWORD *)a1 + 122);
          if (v10 < v8) {
            int v8 = v10;
          }
          if (v8 >= 1)
          {
            unsigned int v11 = v7 - v8;
            if (v11 <= 0x71C71C)
            {
              *((_DWORD *)a1 + 123) = v11;
              uint64_t v12 = *(void *)(a1[70] + 24);
              if ((a1[67] & 4) != 0)
              {
                if (v12)
                {
                  uint64_t all_stats = nw_protocol_tcp_get_all_stats();
                  if (all_stats) {
                    *(_DWORD *)(all_stats + 88) = *((_DWORD *)a1 + 123);
                  }
                }
              }
              else if (v12)
              {
                uint64_t v13 = nw_protocol_tcp_get_all_stats();
                if (v13) {
                  *(_DWORD *)(v13 + 100) = *((_DWORD *)a1 + 123);
                }
              }
              unsigned int v15 = *((_DWORD *)a1 + 123);
              if (*((_DWORD *)a1 + 124) > v15) {
                *((_DWORD *)a1 + 124) = v15;
              }
            }
          }
        }
      }
    }
    if (v4[3] >= 4) {
      tcp_output((uint64_t)v4);
    }
  }
  return 0;
}

double calculate_tcp_clock(uint64_t a1)
{
  v2 = (_OWORD *)(a1 + 240);
  uint64_t v3 = *(void *)(a1 + 240);
  int v4 = *(_DWORD *)(a1 + 248);
  long long v19 = 0uLL;
  microuptime((uint64_t)&v19);
  unsigned int v6 = v4 + 1000;
  if (v4 >= -1000)
  {
    if (v6 <= 0xF423F) {
      goto LABEL_6;
    }
    int v7 = -1000000;
    uint64_t v8 = 1;
  }
  else
  {
    int v7 = 1000000;
    uint64_t v8 = -1;
  }
  v3 += v8;
  v6 += v7;
LABEL_6:
  uint64_t v9 = v19;
  BOOL v10 = (uint64_t)v19 <= v3;
  if ((void)v19 == v3) {
    BOOL v10 = SDWORD2(v19) <= (int)v6;
  }
  if (!v10)
  {
    *(void *)a1 = v19;
    uint64_t v11 = *(void *)(a1 + 240);
    BOOL v12 = v11 < v9;
    if (v11 == v9) {
      BOOL v12 = *(_DWORD *)(a1 + 248) < SDWORD2(v19);
    }
    if (v12)
    {
      microuptime((uint64_t)&v19);
      uint64_t v13 = v19 - *(void *)(a1 + 240);
      int v14 = DWORD2(v19) - *(_DWORD *)(a1 + 248);
      if (v14 < 0)
      {
        int v15 = 1000000;
        int v16 = -1;
      }
      else
      {
        if (v14 <= 0xF423F)
        {
LABEL_18:
          int v17 = v14 / 1000 + 1000 * v13;
          unsigned int v18 = v14 % 1000 + *(_DWORD *)(a1 + 320);
          if (v18 >= 0x3E8) {
            v17 += v18 / 0x3E8;
          }
          if (v17)
          {
            double result = *(double *)&v19;
            _OWORD *v2 = v19;
            *(_DWORD *)(a1 + 320) = v18 % 0x3E8;
            *(_DWORD *)(a1 + 316) += v17;
          }
          return result;
        }
        int v15 = -1000000;
        int v16 = 1;
      }
      LODWORD(v13) = v16 + v13;
      v14 += v15;
      goto LABEL_18;
    }
  }
  return result;
}

void microuptime(uint64_t a1)
{
  kern_return_t v2;
  kern_return_t v3;
  NSObject *v4;
  uint64_t v5;
  mach_timebase_info info;
  uint8_t buf[4];
  const char *v8;
  __int16 v9;
  kern_return_t v10;
  uint64_t v11;

  uint64_t v11 = *MEMORY[0x263EF8340];
  info = 0;
  v2 = mach_timebase_info(&info);
  if (v2)
  {
    uint64_t v3 = v2;
    int v4 = __nwlog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v8 = "microuptime";
      uint64_t v9 = 1024;
      BOOL v10 = v3;
      _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_ERROR, "%{public}s mach_timebase_info returned %u", buf, 0x12u);
    }
  }
  else
  {
    uint64_t v5 = mach_absolute_time() * info.numer / info.denom;
    *(void *)a1 = v5 / 0x3B9ACA00;
    *(_DWORD *)(a1 + 8) = v5 % 0x3B9ACA00 / 0x3E8;
  }
}

BOOL tcp_stretch_ack_enable(uint64_t a1, int a2)
{
  uint64_t v4 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
  uint64_t v5 = sysctls;
  if (*(_DWORD *)(a1 + 328) >= (*(_DWORD *)(a1 + 196) * *(_DWORD *)(sysctls + 52)))
  {
    int v7 = *(_DWORD *)(a1 + 324);
    int v6 = *(_DWORD *)(v4 + 316);
    if (v7 - v6 >= 0)
    {
      unsigned int v8 = *(_DWORD *)(a1 + 88) | 0x2000000;
      goto LABEL_6;
    }
  }
  else
  {
    int v6 = *(_DWORD *)(v4 + 316);
    int v7 = *(_DWORD *)(a1 + 324);
  }
  unsigned int v8 = *(_DWORD *)(a1 + 88) & 0xFDFFFFFF;
LABEL_6:
  *(_DWORD *)(a1 + 88) = v8;
  if (v6 - v7 - 200 >= 1)
  {
    v8 &= ~0x2000000u;
    *(_DWORD *)(a1 + 88) = v8;
  }
  if ((a2 & 0xFFFFFFEF) != 0)
  {
    v8 &= ~0x2000000u;
    *(_DWORD *)(a1 + 88) = v8;
  }
  int v9 = *(_DWORD *)(a1 + 740);
  if ((v9 & 0x10000) != 0)
  {
    unsigned int v10 = *(_DWORD *)(a1 + 340);
    if (v10 < 0x7D0)
    {
      *(_DWORD *)(a1 + 340) = v10 + 1;
    }
    else
    {
      v9 &= ~0x10000u;
      *(_DWORD *)(a1 + 740) = v9;
      *(void *)(a1 + 336) = 0;
    }
  }
  return (v9 & 0x10200) == 0
      && (v8 & 0x2000000) != 0
      && ((v9 & 2) == 0 || *(_DWORD *)(v5 + 76) <= (int)*(unsigned __int16 *)(a1 + 344));
}

uint64_t tcp_compute_rcv_rtt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2 || !a3)
  {
    int v16 = __nwlog_obj();
    os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    int v17 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if (result)
    {
      __break(1u);
      return result;
    }
    free(v17);
  }
  uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
  if (*(unsigned char *)a2)
  {
    int v11 = *(_DWORD *)(a2 + 8);
    if (v11 && (int v12 = *(_DWORD *)(result + 316), v12 - v11 >= 0))
    {
      if (v12 == v11) {
        unsigned int v10 = 1;
      }
      else {
        unsigned int v10 = v12 - v11;
      }
    }
    else
    {
      unsigned int v10 = 0;
    }
  }
  else
  {
    int v6 = *(_DWORD *)(a1 + 1972);
    if (v6)
    {
      int v7 = *(_DWORD *)(a1 + 120);
      if (v7 - *(_DWORD *)(a1 + 1976) < 0) {
        return result;
      }
      int v8 = *(_DWORD *)(result + 316);
      unsigned int v9 = v8 - v6;
      if (v9) {
        unsigned int v10 = v9;
      }
      else {
        unsigned int v10 = 1;
      }
    }
    else
    {
      int v8 = *(_DWORD *)(result + 316);
      int v7 = *(_DWORD *)(a1 + 120);
      unsigned int v10 = 100;
    }
    *(_DWORD *)(a1 + 1972) = v8;
    *(_DWORD *)(a1 + 1976) = *(_DWORD *)(a1 + 128) + v7;
  }
  unsigned int v13 = *(_DWORD *)(a1 + 1968);
  unsigned int v14 = v13 + 4 * v10 - (v13 >> 3);
  if (v14 <= 1) {
    unsigned int v14 = 1;
  }
  if (v13) {
    int v15 = v14;
  }
  else {
    int v15 = 32 * v10;
  }
  *(_DWORD *)(a1 + 1968) = v15;
  *(_DWORD *)(a1 + 236) = v10;
  return update_base_rtt(a1, v10);
}

uint64_t update_base_rtt(uint64_t a1, unsigned int a2)
{
  uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
  uint64_t v5 = *(void *)(*(void *)(a1 + 80) + 496);
  if (v5)
  {
    int v6 = *(unsigned int **)(v5 + 1488);
    if (v6)
    {
      if (v6[11])
      {
        int v7 = *(_DWORD *)(a1 + 740);
        if ((v7 & 0x100) != 0
          && *(_DWORD *)(result + 316) - *(_DWORD *)(a1 + 1040) >= 5000
          && *(_DWORD *)(a1 + 236) <= *(_DWORD *)(sysctls + 4) + v6[10])
        {
          *(_DWORD *)(a1 + 740) = v7 & 0xFFFFFEFF;
          *(_DWORD *)(a1 + 1040) = 0;
        }
        unsigned int v8 = (*(_DWORD *)(a1 + 1912) + 1) & 3;
        *(_DWORD *)(a1 + 1912) = v8;
        *(_DWORD *)(a1 + 1892 + 4 * v8) = a2;
        int v9 = *(_DWORD *)(a1 + 1892);
        if (*(_DWORD *)(a1 + 1896) - 1 < (v9 - 1)) {
          int v9 = *(_DWORD *)(a1 + 1896);
        }
        if (*(_DWORD *)(a1 + 1900) - 1 < (v9 - 1)) {
          int v9 = *(_DWORD *)(a1 + 1900);
        }
        if (*(_DWORD *)(a1 + 1904) - 1 < (v9 - 1)) {
          int v9 = *(_DWORD *)(a1 + 1904);
        }
        *(_DWORD *)(a1 + 1908) = v9;
        int v10 = *(_DWORD *)(result + 316) - v6[11];
        if (v10 < 60000)
        {
          unsigned int v24 = v6[*((unsigned __int8 *)v6 + 72)];
          if (v24 >= a2) {
            unsigned int v24 = a2;
          }
          v6[*((unsigned __int8 *)v6 + 72)] = v24;
          unsigned int v25 = v6[10];
          if (v25)
          {
            if (v25 >= a2) {
              unsigned int v25 = a2;
            }
            v6[10] = v25;
          }
          else
          {
            v6[10] = a2;
          }
        }
        else
        {
          unsigned int v11 = v10 / 0xEA60u;
          if (v10 >= 0xA1220) {
            unsigned int v11 = 11;
          }
          int v12 = *((unsigned __int8 *)v6 + 72);
          LODWORD(v13) = v12 + 1;
          if (v11 >= 2)
          {
            if (v11 == 2) {
              goto LABEL_22;
            }
            unsigned int v14 = (v11 - 1) & 0xFFFFFFFE;
            unsigned int v15 = v12 + 2;
            unsigned int v16 = v12 + 1;
            unsigned int v17 = v14;
            do
            {
              v6[v16 % 0xA] = 0;
              v6[v15 % 0xA] = 0;
              v16 += 2;
              v15 += 2;
              v17 -= 2;
            }
            while (v17);
            LODWORD(v13) = v13 + v14;
            if (v11 - 1 != v14)
            {
LABEL_22:
              unsigned int v18 = v11 + v12;
              long long v19 = (int *)&v6[v13];
              unint64_t v13 = v13;
              do
              {
                v19[-10 * (v13 / 0xA)] = 0;
                ++v13;
                ++v19;
              }
              while (v13 < v18);
            }
          }
          unsigned int v20 = v13 % 0xA;
          *((unsigned char *)v6 + 72) = v20;
          v6[v20] = a2;
          unsigned int v21 = *(_DWORD *)(result + 316);
          unsigned int v22 = *v6;
          uint64_t result = v6[8];
          if (v6[1] - 1 < *v6 - 1) {
            unsigned int v22 = v6[1];
          }
          if (v6[2] - 1 < v22 - 1) {
            unsigned int v22 = v6[2];
          }
          if (v6[3] - 1 < v22 - 1) {
            unsigned int v22 = v6[3];
          }
          if (v6[4] - 1 < v22 - 1) {
            unsigned int v22 = v6[4];
          }
          if (v6[5] - 1 < v22 - 1) {
            unsigned int v22 = v6[5];
          }
          if (v6[6] - 1 < v22 - 1) {
            unsigned int v22 = v6[6];
          }
          if (v6[7] - 1 < v22 - 1) {
            unsigned int v22 = v6[7];
          }
          if ((int)result - 1 < v22 - 1) {
            unsigned int v22 = v6[8];
          }
          if (v6[9] - 1 < v22 - 1) {
            unsigned int v22 = v6[9];
          }
          v6[10] = v22;
          v6[11] = v21;
        }
      }
      else
      {
        unsigned int v23 = *(_DWORD *)(result + 316);
        *((unsigned char *)v6 + 72) = 0;
        *int v6 = a2;
        v6[10] = a2;
        v6[11] = v23;
        *(_DWORD *)(a1 + 1912) = 0;
        *(_DWORD *)(a1 + 1892) = a2;
        *(_DWORD *)(a1 + 1908) = a2;
      }
    }
  }
  return result;
}

void set_frame_service_class(uint64_t a1, uint64_t a2, int a3, char a4, int *a5)
{
  uint64_t v9 = *(void *)a2;
  if ((a3 + 1) >= 2)
  {
    int v11 = 524432;
    if (a3 <= 499)
    {
      if (a3 > 299)
      {
        if (a3 == 300)
        {
          int v10 = 1572880;
          goto LABEL_3;
        }
        if (a3 == 400)
        {
          int v10 = 2097184;
          goto LABEL_3;
        }
      }
      else
      {
        if (a3 == 100) {
          goto LABEL_11;
        }
        if (a3 == 200)
        {
LABEL_9:
          int v11 = 1048704;
          goto LABEL_11;
        }
      }
    }
    else if (a3 <= 699)
    {
      if (a3 == 500)
      {
        int v10 = 2621728;
        goto LABEL_3;
      }
      if (a3 == 600)
      {
        int v10 = 3146000;
        goto LABEL_3;
      }
    }
    else
    {
      switch(a3)
      {
        case 700:
          int v10 = 3670272;
          goto LABEL_3;
        case 800:
          int v10 = 4194688;
          goto LABEL_3;
        case 900:
          int v10 = 4718992;
          goto LABEL_3;
      }
    }
    uint64_t v24 = *(void *)a2;
    unsigned int v22 = __nwlog_obj();
    os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
    unsigned int v23 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort()) {
      goto LABEL_55;
    }
    free(v23);
    int v10 = 0;
    uint64_t v9 = v24;
    goto LABEL_3;
  }
  int v10 = 0;
LABEL_3:
  if ((*(unsigned char *)(a2 + 369) & 0x20) != 0) {
    goto LABEL_9;
  }
  if (v10 && v10 != 2097184 && v10 != 1572880 || !*(void *)(v9 + 448))
  {
    int v11 = v10;
    goto LABEL_11;
  }
  int v11 = v10;
  if (so_throttle_best_effort(a2)) {
    goto LABEL_9;
  }
LABEL_11:
  if ((*(unsigned char *)(a2 + 369) & 0x20) != 0 || (int v12 = *(_DWORD *)(a2 + 600), v12 == 200) || v12 == 100)
  {
    *(unsigned char *)(a1 + 186) |= 0x10u;
    int v12 = *(_DWORD *)(a2 + 600);
  }
  if ((v12 - 801) >= 0xFFFFFED3) {
    *(unsigned char *)(a1 + 186) |= 0x20u;
  }
  if ((a4 & 6) != 0) {
    int v13 = 4718992;
  }
  else {
    int v13 = v11;
  }
  if (v11 == 1048704) {
    int v14 = 1048704;
  }
  else {
    int v14 = v13;
  }
  if (v11 == 524432) {
    int v15 = 524432;
  }
  else {
    int v15 = v14;
  }
  set_tcp_stream_priority(a2);
  uint64_t v16 = (unsigned __int16)v15 >> 7;
  if (v16 < 4) {
    goto LABEL_27;
  }
  unsigned int v20 = __nwlog_obj();
  os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
  unsigned int v21 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort())
  {
LABEL_55:
    __break(1u);
    return;
  }
  free(v21);
LABEL_27:
  uint64_t v17 = a2 + 32 * v16;
  ++*(void *)(v17 + 712);
  int v18 = *(_DWORD *)(a1 + 52);
  if (v18) {
    uint64_t v19 = (v18 - (*(_DWORD *)(a1 + 56) + *(_DWORD *)(a1 + 60)));
  }
  else {
    uint64_t v19 = 0;
  }
  *(void *)(v17 + 720) += v19;
  *a5 = v15;
}

void set_tcp_stream_priority(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(*(void *)a1 + 232) != 3)
  {
    uint64_t v2 = *(void *)(*(void *)a1 + 240);
    int v3 = *(unsigned __int8 *)(v2 + 264);
    int v4 = *(_DWORD *)(a1 + 368);
    uint64_t v5 = (unint64_t *)nw_tcp_access_globals(a1);
    unint64_t v6 = *v5;
    if (so_throttle_best_effort(a1)
      || ((int v10 = *(_DWORD *)(a1 + 368), (v10 & 0x2000) != 0) || (v11 = *(_DWORD *)(a1 + 600), v11 == 200) || v11 == 100)
      && ((uint64_t v12 = *(void *)(v2 + 1064)) != 0 ? (v13 = v6 >= 3) : (v13 = 0), v13 && *(void *)(v12 + 8) > *v5 - 2)
      || *(_DWORD *)(a1 + 600) == 100)
    {
      if (v3 != 2) {
        tcp_set_new_cc(a1, 2);
      }
      int v7 = *(_DWORD *)(a1 + 368);
      if ((v7 & 0x4000) == 0)
      {
        *(_DWORD *)(a1 + 368) = v7 | 0x4000;
        if (*(_DWORD *)(sysctls + 308) == 1)
        {
          uint64_t v8 = *(void *)(*(void *)a1 + 240);
          if ((~*(_DWORD *)(v8 + 88) & 0x180) == 0 && off_26AA46378 != 0) {
            off_26AA46378(v8);
          }
        }
      }
    }
    else
    {
      if ((v10 & 0x4000) != 0) {
        *(_DWORD *)(a1 + 368) = v10 & 0xFFFFBFFF;
      }
      if (v3 == 2) {
        tcp_set_foreground_cc(a1);
      }
    }
    int v14 = v4 & 0x4000;
    if ((v3 != *(unsigned __int8 *)(v2 + 264) || v14 != (*(_DWORD *)(a1 + 368) & 0x4000))
      && (*(unsigned char *)(a1 + 828) & 2) == 0
      && __nwlog_is_datapath_logging_enabled())
    {
      int v15 = __nwlog_tcp_log();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v16 = tcp_cc_algo_list[*(unsigned __int8 *)(v2 + 264)];
        int v17 = 136446978;
        int v18 = "set_tcp_stream_priority";
        __int16 v19 = 2082;
        uint64_t v20 = a1 + 604;
        __int16 v21 = 2082;
        uint64_t v22 = v16;
        __int16 v23 = 1024;
        int v24 = v14;
        _os_log_impl(&dword_214653000, v15, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s cc_algo %{public}s recvbg %d", (uint8_t *)&v17, 0x26u);
      }
    }
  }
}

void tcp_set_lotimer_index(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 16);
  int v3 = *(_DWORD *)(a1 + 20);
  int v4 = *(_DWORD *)(a1 + 24);
  unsigned int v5 = *(_DWORD *)(a1 + 28);
  BOOL v6 = (v4 | v2) != 0;
  if (v3) {
    BOOL v6 = 1;
  }
  if (v3 - 1 >= (v2 - 1))
  {
    int v7 = 8 * (v2 == 0);
  }
  else
  {
    int v2 = *(_DWORD *)(a1 + 20);
    int v7 = 1;
  }
  if (v4 - 1 < (v2 - 1))
  {
    int v2 = *(_DWORD *)(a1 + 24);
    int v7 = 2;
  }
  int v8 = v6 | 2;
  if (v2 - 1 >= v5) {
    int v9 = *(_DWORD *)(a1 + 28);
  }
  else {
    int v9 = v2;
  }
  if (v2 - 1 >= v5) {
    int v10 = 3;
  }
  else {
    int v10 = v7;
  }
  if (v5) {
    int v2 = v9;
  }
  else {
    int v8 = v6;
  }
  if (v5) {
    int v7 = v10;
  }
  unsigned int v11 = *(_DWORD *)(a1 + 32);
  unsigned int v12 = *(_DWORD *)(a1 + 36);
  if (v2 - 1 >= v11) {
    int v13 = *(_DWORD *)(a1 + 32);
  }
  else {
    int v13 = v2;
  }
  if (v2 - 1 >= v11) {
    int v14 = 4;
  }
  else {
    int v14 = v7;
  }
  if (v11)
  {
    int v2 = v13;
    v8 |= 2u;
    int v7 = v14;
  }
  if (v2 - 1 >= v12) {
    int v15 = *(_DWORD *)(a1 + 36);
  }
  else {
    int v15 = v2;
  }
  if (v2 - 1 >= v12) {
    int v16 = 5;
  }
  else {
    int v16 = v7;
  }
  if (v12)
  {
    int v2 = v15;
    v8 |= 4u;
    int v17 = v16;
  }
  else
  {
    int v17 = v7;
  }
  unsigned int v19 = *(_DWORD *)(a1 + 40);
  unsigned int v18 = *(_DWORD *)(a1 + 44);
  if (v2 - 1 >= v19) {
    int v20 = *(_DWORD *)(a1 + 40);
  }
  else {
    int v20 = v2;
  }
  if (v2 - 1 >= v19) {
    int v21 = 6;
  }
  else {
    int v21 = v17;
  }
  if (v19) {
    v8 |= 4u;
  }
  else {
    int v20 = v2;
  }
  if (v19) {
    unsigned int v22 = v21;
  }
  else {
    unsigned int v22 = v17;
  }
  if (v18)
  {
    __int16 v23 = v8 | 4;
    if (v20 - 1 >= v18) {
      unsigned int v22 = 7;
    }
    *(_WORD *)(a1 + 72) = v22;
    *(_WORD *)(a1 + 74) = v23;
    if (v22 == 8) {
      return;
    }
    goto LABEL_58;
  }
  *(_WORD *)(a1 + 72) = v22;
  *(_WORD *)(a1 + 74) = v8;
  if (v22 == 8 || v8 != 0)
  {
    if (v22 == 8) {
      return;
    }
    goto LABEL_58;
  }
  v27 = __nwlog_obj();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  v28 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort())
  {
    __break(1u);
    return;
  }
  free(v28);
  unsigned int v22 = *(unsigned __int16 *)(a1 + 72);
  if (v22 != 8)
  {
LABEL_58:
    unsigned int v25 = *(_DWORD *)(a1 + 4 * v22 + 16) + *(_DWORD *)(a1 + 64);
    if (v25 != *(_DWORD *)(a1 + 68))
    {
      if (v25 <= 1) {
        unsigned int v25 = 1;
      }
      *(_DWORD *)(a1 + 68) = v25;
      uint64_t v26 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
      if (*(_DWORD *)(v26 + 288)) {
        *(unsigned char *)(v26 + 310) |= 4u;
      }
    }
  }
}

void tcp_check_timer_state(uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  (*(void (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 80) + 224) + 8) + 32))();
  if (*(unsigned char *)(*(void *)(a1 + 80) + 2232)) {
    return;
  }
  tcp_set_lotimer_index(a1);
  uint64_t v2 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
  uint64_t v3 = a1 + 48;
  uint64_t v4 = *(void *)(a1 + 80);
  if (*(_DWORD *)(v4 + 232) == 3)
  {
    if ((*(unsigned char *)(a1 + 91) & 0x40) == 0) {
      return;
    }
    goto LABEL_6;
  }
  if (*(_WORD *)(a1 + 72) == 8)
  {
LABEL_6:
    uint64_t v5 = nw_tcp_access_globals(*(void *)(v4 + 224));
    (*(void (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 80) + 224) + 8) + 32))();
    int v6 = *(_DWORD *)(a1 + 88);
    if ((v6 & 0x40000000) != 0)
    {
      uint64_t v7 = *(void *)(v5 + 264);
      uint64_t v8 = *(void *)v3;
      if (v7) {
        BOOL v9 = v7 == v3;
      }
      else {
        BOOL v9 = 0;
      }
      if (v9) {
        *(void *)(v5 + 264) = v8;
      }
      if (v8) {
        *(void *)(v8 + 8) = *(void *)(a1 + 56);
      }
      **(void **)(a1 + 56) = v8;
      *(_DWORD *)(a1 + 88) = v6 & 0xBFFFFFFF;
      --*(_DWORD *)(v5 + 280);
      *(void *)uint64_t v3 = 0;
      *(void *)(a1 + 56) = 0;
    }
    return;
  }
  uint64_t v10 = v2;
  int v11 = *(unsigned __int16 *)(a1 + 74);
  int v12 = *(_DWORD *)(a1 + 68);
  if (v12 - *(_DWORD *)(v2 + 316) <= 1) {
    unsigned int v13 = 1;
  }
  else {
    unsigned int v13 = v12 - *(_DWORD *)(v2 + 316);
  }
  int v14 = *(_DWORD *)(a1 + 88);
  if ((v14 & 0x40000000) != 0)
  {
    char v17 = *(unsigned char *)(v2 + 310);
  }
  else
  {
    uint64_t v15 = *(void *)(v2 + 256);
    *(void *)uint64_t v3 = v15;
    if (v15) {
      *(void *)(v15 + 8) = v3;
    }
    *(void *)(v2 + 256) = v3;
    *(void *)(a1 + 56) = v2 + 256;
    *(_DWORD *)(a1 + 88) = v14 | 0x40000000;
    unsigned int v16 = *(_DWORD *)(v2 + 280) + 1;
    *(_DWORD *)(v2 + 280) = v16;
    if (v16 > *(_DWORD *)(v2 + 284)) {
      *(_DWORD *)(v2 + 284) = v16;
    }
    char v17 = *(unsigned char *)(v2 + 310);
    if ((v17 & 2) == 0) {
      goto LABEL_52;
    }
  }
  if ((v17 & 3) == 2)
  {
    unsigned int v18 = *(_DWORD *)(v2 + 272) - v12;
    if ((int)v18 < 1) {
      return;
    }
    if (v11)
    {
      if (v18 < 0xB) {
        return;
      }
    }
    else if ((v11 & 2) != 0)
    {
      if (v18 < 0x65) {
        return;
      }
    }
    else if (v18 < 0x1F5)
    {
      return;
    }
  }
  if (*(void *)v3 && *(void *)(*(void *)v3 + 8) != v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v28 = "tcp_sched_timers";
    __int16 v29 = 2048;
    uint64_t v30 = a1 + 48;
    unsigned int v19 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v20 = __nwlog_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v28 = "tcp_sched_timers";
        __int16 v29 = 2048;
        uint64_t v30 = a1 + 48;
        _os_log_impl(&dword_214653000, v20, OS_LOG_TYPE_ERROR, "%{public}s Bad link elm %p next->prev != elm, backtrace limit exceeded", buf, 0x16u);
      }
    }
    if (v19) {
      free(v19);
    }
  }
  if (**(void **)(a1 + 56) != v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v28 = "tcp_sched_timers";
    __int16 v29 = 2048;
    uint64_t v30 = a1 + 48;
    int v21 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      unsigned int v22 = __nwlog_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v28 = "tcp_sched_timers";
        __int16 v29 = 2048;
        uint64_t v30 = v3;
        _os_log_impl(&dword_214653000, v22, OS_LOG_TYPE_ERROR, "%{public}s Bad link elm %p prev->next != elm, backtrace limit exceeded", buf, 0x16u);
      }
    }
    if (v21) {
      free(v21);
    }
  }
  if ((*(unsigned char *)(v10 + 310) & 1) == 0)
  {
    if ((*(unsigned char *)(v10 + 310) & 2) != 0 && (int)(*(_DWORD *)(v10 + 272) - *(_DWORD *)(v10 + 316) - v13) < 1) {
      return;
    }
LABEL_52:
    if (v11)
    {
      *(_DWORD *)(v10 + 292) = 1;
      *(_DWORD *)(v10 + 304) = 0;
      BOOL v23 = v13 >= 0xA;
      int v24 = 10;
    }
    else
    {
      if ((v11 & 2) == 0)
      {
LABEL_67:
        tcp_sched_timerlist(v10, v13);
        return;
      }
      if (*(_DWORD *)(v10 + 292) >= 3u) {
        *(_DWORD *)(v10 + 292) = 2;
      }
      *(_DWORD *)(v10 + 304) = 0;
      BOOL v23 = v13 >= 0x64;
      int v24 = 100;
    }
    if (v23) {
      unsigned int v13 = v24;
    }
    goto LABEL_67;
  }
  *(_DWORD *)(v10 + 296) |= v11;
  int v25 = *(_DWORD *)(v10 + 300);
  if (v25) {
    BOOL v26 = (int)v13 < v25;
  }
  else {
    BOOL v26 = 1;
  }
  if (v26) {
    *(_DWORD *)(v10 + 300) = v13;
  }
}

uint64_t nw_tcp_access_globals(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 40);
    if (v1) {
      return *(void *)(v1 + 5240);
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v7 = "nw_tcp_access_globals";
    uint64_t v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v7 = "nw_tcp_access_globals";
        uint64_t v5 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_12;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v7 = "nw_tcp_access_globals";
    uint64_t v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v7 = "nw_tcp_access_globals";
        uint64_t v5 = "%{public}s called with null so, backtrace limit exceeded";
LABEL_12:
        _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_ERROR, v5, buf, 0xCu);
      }
    }
  }
  if (v3) {
    free(v3);
  }
  return 0;
}

uint64_t tcp_getlock(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  if (*(void *)a1)
  {
    if ((*(_DWORD *)(a1 + 360) & 0x80000000) == 0) {
      return *(void *)a1 + 24;
    }
    if ((*(unsigned char *)(a1 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      int v4 = *(_DWORD *)(a1 + 360);
      *(_DWORD *)buf = 136447234;
      int v12 = "tcp_getlock";
      __int16 v13 = 2082;
      uint64_t v14 = a1 + 604;
      __int16 v15 = 2048;
      uint64_t v16 = a1;
      __int16 v17 = 1024;
      *(_DWORD *)unsigned int v18 = v4;
      *(_WORD *)&v18[4] = 2082;
      *(void *)&v18[6] = "";
      uint64_t v3 = (void *)_os_log_send_and_compose_impl();
      if (!__nwlog_fault()) {
        goto LABEL_15;
      }
      BOOL v9 = __nwlog_tcp_log();
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        goto LABEL_15;
      }
      int v10 = *(_DWORD *)(a1 + 360);
      *(_DWORD *)buf = 136447234;
      int v12 = "tcp_getlock";
      __int16 v13 = 2082;
      uint64_t v14 = a1 + 604;
      __int16 v15 = 2048;
      uint64_t v16 = a1;
      __int16 v17 = 1024;
      *(_DWORD *)unsigned int v18 = v10;
      *(_WORD *)&v18[4] = 2082;
      *(void *)&v18[6] = "";
      int v6 = "%{public}s %{public}s tcp_getlock: so=%p usecount=%x lrh= %{public}s, backtrace limit exceeded";
      uint64_t v7 = v9;
      uint32_t v8 = 48;
LABEL_14:
      _os_log_impl(&dword_214653000, v7, OS_LOG_TYPE_ERROR, v6, buf, v8);
LABEL_15:
      if (v3) {
        free(v3);
      }
    }
  }
  else if ((*(unsigned char *)(a1 + 828) & 2) == 0)
  {
    __nwlog_tcp_log();
    *(_DWORD *)buf = 136446978;
    int v12 = "tcp_getlock";
    __int16 v13 = 2082;
    uint64_t v14 = a1 + 604;
    __int16 v15 = 2048;
    uint64_t v16 = a1;
    __int16 v17 = 2082;
    *(void *)unsigned int v18 = "";
    uint64_t v3 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_15;
    }
    uint64_t v5 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    *(_DWORD *)buf = 136446978;
    int v12 = "tcp_getlock";
    __int16 v13 = 2082;
    uint64_t v14 = a1 + 604;
    __int16 v15 = 2048;
    uint64_t v16 = a1;
    __int16 v17 = 2082;
    *(void *)unsigned int v18 = "";
    int v6 = "%{public}s %{public}s tcp_getlock: so=%p NULL so_pcb %{public}s, backtrace limit exceeded";
    uint64_t v7 = v5;
    uint32_t v8 = 42;
    goto LABEL_14;
  }
  return 0;
}

BOOL so_throttle_best_effort(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a1 + 600);
  if (v2 && v2 != 400 && v2 != 300) {
    return 0;
  }
  uint64_t v3 = *(void *)(*(void *)a1 + 240);
  int v4 = (unint64_t *)nw_tcp_access_globals(a1);
  BOOL v8 = *(_DWORD *)(sysctls + 340) == 1
    && ((unint64_t v5 = *v4, (v6 = *(void *)(v3 + 1064)) != 0) ? (v7 = v5 >= 3) : (v7 = 0), v7)
    && *(void *)(v6 + 16) > v5 - 2;
  if (so_throttle_best_effort_old_result != v8 && (*(unsigned char *)(a1 + 828) & 2) == 0)
  {
    BOOL v9 = __nwlog_tcp_log();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      int v10 = "off";
      __int16 v13 = "so_throttle_best_effort";
      int v12 = 136446722;
      if (v8) {
        int v10 = "on";
      }
      __int16 v14 = 2082;
      uint64_t v15 = a1 + 604;
      __int16 v16 = 2080;
      __int16 v17 = v10;
      _os_log_impl(&dword_214653000, v9, OS_LOG_TYPE_INFO, "%{public}s %{public}s throttling is now %s", (uint8_t *)&v12, 0x20u);
    }
  }
  so_throttle_best_effort_old_uint64_t result = v8;
  return v8;
}

void tcp_process_timerlist(uint64_t a1)
{
  uint64_t v98 = *MEMORY[0x263EF8340];
  if ((*(unsigned char *)(a1 + 310) & 1) == 0)
  {
    *(unsigned char *)(a1 + 310) = *(unsigned char *)(a1 + 310) & 0xFA | 1;
    int v2 = *(void **)(a1 + 256);
    if (!v2) {
      goto LABEL_168;
    }
    unsigned int v3 = 0;
    int v4 = 0;
    do
    {
      uint64_t v6 = v2;
      int v2 = (void *)*v2;
      if (*((unsigned __int16 *)v6 + 12) > 7u || (int v5 = *((_DWORD *)v6 + 5) - *(_DWORD *)(a1 + 316), v5 < 1))
      {
        uint64_t v7 = (uint64_t)(v6 - 6);
        uint64_t v8 = v6[4];
        while (1)
        {
          int v9 = *(_DWORD *)(v8 + 456);
          if ((_WORD)v9 == 0xFFFF) {
            break;
          }
          int v10 = *(_DWORD *)(v8 + 456);
          atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(v8 + 456), (unsigned int *)&v10, v9 + 1, memory_order_relaxed, memory_order_relaxed);
          if (v10 == v9)
          {
            int v92 = v4;
            unsigned int v93 = v3;
            int v12 = (uint64_t *)(v7 + 48);
            uint64_t v11 = *(void *)(v7 + 48);
            if (v11 && *(uint64_t **)(v11 + 8) != v12)
            {
              __nwlog_obj();
              *(_DWORD *)buf = 136446466;
              v95 = "tcp_process_timerlist";
              __int16 v96 = 2048;
              uint64_t v97 = v7 + 48;
              __int16 v13 = (void *)_os_log_send_and_compose_impl();
              if (__nwlog_fault())
              {
                __int16 v16 = __nwlog_obj();
                if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446466;
                  v95 = "tcp_process_timerlist";
                  __int16 v96 = 2048;
                  uint64_t v97 = v7 + 48;
                  _os_log_impl(&dword_214653000, v16, OS_LOG_TYPE_ERROR, "%{public}s Bad link elm %p next->prev != elm, backtrace limit exceeded", buf, 0x16u);
                }
              }
              if (v13) {
                free(v13);
              }
            }
            if (**(uint64_t ***)(v7 + 56) != v12)
            {
              __nwlog_obj();
              *(_DWORD *)buf = 136446466;
              v95 = "tcp_process_timerlist";
              __int16 v96 = 2048;
              uint64_t v97 = v7 + 48;
              __int16 v17 = (void *)_os_log_send_and_compose_impl();
              if (__nwlog_fault())
              {
                uint64_t v18 = __nwlog_obj();
                if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446466;
                  v95 = "tcp_process_timerlist";
                  __int16 v96 = 2048;
                  uint64_t v97 = v7 + 48;
                  _os_log_impl(&dword_214653000, v18, OS_LOG_TYPE_ERROR, "%{public}s Bad link elm %p prev->next != elm, backtrace limit exceeded", buf, 0x16u);
                }
              }
              if (v17) {
                free(v17);
              }
            }
            int v19 = *(unsigned __int16 *)(a1 + 308);
            (*(void (**)(void, uint64_t))(*(void *)(*(void *)(*(void *)(v7 + 80) + 224) + 8) + 16))(*(void *)(*(void *)(v7 + 80) + 224), 1);
            uint64_t v20 = *(void *)(*(void *)(v7 + 80) + 224);
            uint64_t v21 = nw_tcp_access_globals(v20);
            if (in_pcb_checkstate(*(void *)(v7 + 80), 2, 1) == 0xFFFF)
            {
              if ((*(unsigned char *)(v7 + 91) & 0x40) != 0)
              {
                uint64_t v22 = nw_tcp_access_globals(*(void *)(*(void *)(v7 + 80) + 224));
                (*(void (**)(void, void))(*(void *)(*(void *)(*(void *)(v7 + 80) + 224) + 8)
                                                       + 32))(*(void *)(*(void *)(v7 + 80) + 224), 0);
                int v23 = *(_DWORD *)(v7 + 88);
                if ((v23 & 0x40000000) != 0)
                {
                  int v24 = *(uint64_t **)(v22 + 264);
                  uint64_t v25 = *v12;
                  if (v24) {
                    BOOL v26 = v24 == v12;
                  }
                  else {
                    BOOL v26 = 0;
                  }
                  if (v26) {
                    *(void *)(v22 + 264) = v25;
                  }
                  if (v25) {
                    *(void *)(v25 + 8) = *(void *)(v7 + 56);
                  }
                  int v27 = 0;
                  int v28 = 0;
                  **(void **)(v7 + 56) = v25;
                  *(_DWORD *)(v7 + 88) = v23 & 0xBFFFFFFF;
                  --*(_DWORD *)(v22 + 280);
                  *int v12 = 0;
                  *(void *)(v7 + 56) = 0;
LABEL_51:
                  if (*(_WORD *)(v7 + 72) == 8)
                  {
                    uint64_t v31 = nw_tcp_access_globals(*(void *)(*(void *)(v7 + 80) + 224));
                    (*(void (**)(void, void))(*(void *)(*(void *)(*(void *)(v7 + 80) + 224) + 8)
                                                           + 32))(*(void *)(*(void *)(v7 + 80) + 224), 0);
                    int v32 = *(_DWORD *)(v7 + 88);
                    if ((v32 & 0x40000000) != 0)
                    {
                      v33 = *(uint64_t **)(v31 + 264);
                      v34 = (uint64_t *)(v7 + 48);
                      if (v33) {
                        BOOL v35 = v33 == v34;
                      }
                      else {
                        BOOL v35 = 0;
                      }
                      if (v35) {
                        *(void *)(v31 + 264) = *v33;
                      }
                      uint64_t v36 = *v34;
                      if (*v34) {
                        *(void *)(v36 + 8) = *(void *)(v7 + 56);
                      }
                      int v28 = 0;
                      **(void **)(v7 + 56) = v36;
                      *(_DWORD *)(v7 + 88) = v32 & 0xBFFFFFFF;
                      --*(_DWORD *)(v31 + 280);
                      uint64_t *v34 = 0;
                      *(void *)(v7 + 56) = 0;
                    }
                    else
                    {
                      int v28 = 0;
                    }
                  }
LABEL_63:
                  (*(void (**)(uint64_t, uint64_t))(*(void *)(v20 + 8) + 24))(v20, 1);
                  if (v28 && v27)
                  {
                    unsigned int v3 = v93;
                    int v4 = v27 | v92;
                    if (v93 - 1 >= v28) {
                      unsigned int v3 = v28;
                    }
                  }
                  else
                  {
                    int v4 = v92;
                    unsigned int v3 = v93;
                  }
                  goto LABEL_8;
                }
              }
LABEL_48:
              int v27 = 0;
              int v28 = 0;
              goto LABEL_51;
            }
            if (v19)
            {
              uint64_t v29 = *(void *)(*(void *)(v7 + 80) + 448);
              if (v29)
              {
                if (*(unsigned __int16 *)(v29 + 1072) == v19)
                {
                  *(_DWORD *)(v7 + 740) |= 0x200000u;
                  tcp_timers(v7, 0);
                  *(_DWORD *)(v7 + 16) = 0;
                  *(_DWORD *)(v7 + 740) &= 0x200000u;
                }
              }
            }
            int v30 = *(unsigned __int16 *)(v7 + 72);
            if (v30 == 8) {
              goto LABEL_48;
            }
            int v28 = *(_DWORD *)(v7 + 68) - *(_DWORD *)(v21 + 316);
            if (v28 >= 1)
            {
LABEL_50:
              int v27 = *(unsigned __int16 *)(v7 + 74);
              goto LABEL_51;
            }
            uint64_t v37 = v7 + 4 * *(unsigned __int16 *)(v7 + 72);
            int v38 = *(_DWORD *)(v37 + 16);
            *(_DWORD *)(v37 + 16) = 0;
            if (v38)
            {
              uint64_t v7 = tcp_timers(v7, v30);
              if (!v7) {
                goto LABEL_155;
              }
            }
            *(_WORD *)(v7 + 74) = 0;
            int v39 = *(_DWORD *)(v7 + 16);
            int v40 = *(_DWORD *)(v21 + 316);
            if (v39)
            {
              int v41 = *(_DWORD *)(v7 + 64) + v39 - v40;
              int v42 = 1;
              if (v41 < 1)
              {
                int v44 = 0;
                char v45 = 0;
                int v41 = 0;
                unsigned int v43 = 8;
                int v46 = *(_DWORD *)(v7 + 20);
                if (!v46) {
                  goto LABEL_81;
                }
              }
              else
              {
                unsigned int v43 = 0;
                *(_DWORD *)(v7 + 16) = v41;
                *(_WORD *)(v7 + 74) = 1;
                int v40 = *(_DWORD *)(v21 + 316);
                int v44 = 1;
                char v45 = 1;
                int v42 = 0;
                int v46 = *(_DWORD *)(v7 + 20);
                if (!v46) {
                  goto LABEL_81;
                }
              }
LABEL_77:
              int v47 = *(_DWORD *)(v7 + 64) + v46 - v40;
              if (v47 >= 1)
              {
                *(_DWORD *)(v7 + 20) = v47;
                if (v41 - 1 >= v47)
                {
                  unsigned int v43 = 1;
                  int v41 = v47;
                }
                int v44 = 1;
                *(_WORD *)(v7 + 74) = 1;
                int v40 = *(_DWORD *)(v21 + 316);
                goto LABEL_81;
              }
              char v48 = 0;
              ++v42;
              int v49 = *(_DWORD *)(v7 + 24);
              if (v49)
              {
LABEL_84:
                int v50 = *(_DWORD *)(v7 + 64) + v49 - v40;
                if (v50 >= 1)
                {
                  *(_DWORD *)(v7 + 24) = v50;
                  if (v41 - 1 >= v50)
                  {
                    unsigned int v43 = 2;
                    int v41 = v50;
                  }
                  int v44 = 1;
                  *(_WORD *)(v7 + 74) = 1;
                  int v40 = *(_DWORD *)(v21 + 316);
                  goto LABEL_88;
                }
                char v51 = 0;
                ++v42;
                int v52 = *(_DWORD *)(v7 + 28);
                if (v52)
                {
LABEL_91:
                  int v53 = *(_DWORD *)(v7 + 64) + v52 - v40;
                  if (v53 >= 1)
                  {
                    *(_DWORD *)(v7 + 28) = v53;
                    if (v41 - 1 >= v53)
                    {
                      int v41 = v53;
                      unsigned int v43 = 3;
                    }
                    v44 |= 2u;
                    *(_WORD *)(v7 + 74) = v44;
                    int v40 = *(_DWORD *)(v21 + 316);
                    goto LABEL_95;
                  }
                  char v91 = 0;
                  ++v42;
                  int v54 = *(_DWORD *)(v7 + 32);
                  if (v54)
                  {
LABEL_98:
                    int v55 = *(_DWORD *)(v7 + 64) + v54 - v40;
                    if (v55 >= 1)
                    {
                      *(_DWORD *)(v7 + 32) = v55;
                      if (v41 - 1 >= v55)
                      {
                        int v41 = v55;
                        unsigned int v43 = 4;
                      }
                      v44 |= 2u;
                      *(_WORD *)(v7 + 74) = v44;
                      int v40 = *(_DWORD *)(v21 + 316);
                      goto LABEL_102;
                    }
                    char v56 = 0;
                    ++v42;
                    int v57 = *(_DWORD *)(v7 + 36);
                    if (v57)
                    {
LABEL_105:
                      int v58 = *(_DWORD *)(v7 + 64) + v57 - v40;
                      if (v58 >= 1)
                      {
                        *(_DWORD *)(v7 + 36) = v58;
                        if (v41 - 1 >= v58)
                        {
                          int v41 = v58;
                          unsigned int v43 = 5;
                        }
                        v44 |= 4u;
                        *(_WORD *)(v7 + 74) = v44;
                        int v40 = *(_DWORD *)(v21 + 316);
                        goto LABEL_109;
                      }
                      char v59 = 0;
                      ++v42;
                      int v60 = *(_DWORD *)(v7 + 40);
                      if (!v60)
                      {
LABEL_115:
                        char v62 = 1;
                        goto LABEL_117;
                      }
LABEL_110:
                      int v61 = *(_DWORD *)(v7 + 64) + v60 - v40;
                      if (v61 < 1)
                      {
                        char v62 = 0;
                        ++v42;
                      }
                      else
                      {
                        *(_DWORD *)(v7 + 40) = v61;
                        if (v41 - 1 >= v61)
                        {
                          int v41 = v61;
                          unsigned int v43 = 6;
                        }
                        v44 |= 4u;
                        *(_WORD *)(v7 + 74) = v44;
                        int v40 = *(_DWORD *)(v21 + 316);
                        char v62 = 1;
                      }
LABEL_117:
                      int v63 = *(_DWORD *)(v7 + 44);
                      BOOL v64 = v63 == 0;
                      if (v63)
                      {
                        int v65 = *(_DWORD *)(v7 + 64) + v63 - v40;
                        if (v65 >= 1)
                        {
                          *(_DWORD *)(v7 + 44) = v65;
                          *(_WORD *)(v7 + 74) = v44 | 4;
                          int v40 = *(_DWORD *)(v21 + 316);
                          *(_DWORD *)(v7 + 64) = v40;
                          if (v41 - 1 >= v65)
                          {
                            unsigned int v43 = 7;
                            *(_WORD *)(v7 + 72) = 7;
                            BOOL v64 = 1;
                          }
                          else
                          {
                            *(_WORD *)(v7 + 72) = v43;
                            BOOL v64 = 1;
                            if (v43 == 8) {
                              goto LABEL_132;
                            }
                          }
LABEL_129:
                          unsigned int v68 = *(_DWORD *)(v7 + 4 * v43 + 16) + v40;
                          if (v68 <= 1) {
                            unsigned int v68 = 1;
                          }
                          *(_DWORD *)(v7 + 68) = v68;
LABEL_132:
                          if (!v42)
                          {
LABEL_153:
                            if (v43 > 7) {
                              goto LABEL_48;
                            }
                            int v28 = *(_DWORD *)(v7 + 4 * v43 + 16);
                            goto LABEL_50;
                          }
                          char v88 = v62;
                          BOOL v90 = v64;
                          char v69 = v59;
                          if (v45)
                          {
                            char v70 = v56;
                            char v71 = v51;
                            goto LABEL_136;
                          }
                          char v70 = v56;
                          char v71 = v51;
                          *(_DWORD *)(v7 + 16) = 0;
                          char v72 = v48;
                          uint64_t v73 = tcp_timers(v7, 0);
                          char v48 = v72;
                          uint64_t v7 = v73;
                          if (v73)
                          {
LABEL_136:
                            if ((v48 & 1) != 0 || (*(_DWORD *)(v7 + 20) = 0, (uint64_t v7 = tcp_timers(v7, 1)) != 0))
                            {
                              if ((v71 & 1) == 0)
                              {
                                *(_DWORD *)(v7 + 24) = 0;
                                nw_tcp_access_globals(*(void *)(*(void *)(v7 + 80) + 224));
                                if ((*(_DWORD *)(v7 + 740) & 0x20400020) == 0x20000020) {
                                  tcp_rack_reordering_timeout(v7);
                                }
                              }
                              if ((v91 & 1) != 0 || (*(_DWORD *)(v7 + 28) = 0, (uint64_t v7 = tcp_timers(v7, 3)) != 0))
                              {
                                if ((v70 & 1) != 0 || (*(_DWORD *)(v7 + 32) = 0, (uint64_t v7 = tcp_timers(v7, 4)) != 0))
                                {
                                  if ((v69 & 1) != 0 || (*(_DWORD *)(v7 + 36) = 0, (uint64_t v7 = tcp_timers(v7, 5)) != 0))
                                  {
                                    if (v88)
                                    {
                                      BOOL v74 = v90;
LABEL_150:
                                      if (v74 || (*(_DWORD *)(v7 + 44) = 0, (uint64_t v7 = tcp_timers(v7, 7)) != 0))
                                      {
                                        tcp_set_lotimer_index(v7);
                                        unsigned int v43 = *(unsigned __int16 *)(v7 + 72);
                                        goto LABEL_153;
                                      }
                                    }
                                    else
                                    {
                                      *(_DWORD *)(v7 + 40) = 0;
                                      uint64_t v7 = tcp_timers(v7, 6);
                                      BOOL v74 = v90;
                                      if (v7) {
                                        goto LABEL_150;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
LABEL_155:
                          int v27 = 0;
                          int v28 = 0;
                          goto LABEL_63;
                        }
                        ++v42;
                      }
                      *(_DWORD *)(v7 + 64) = v40;
                      *(_WORD *)(v7 + 72) = v43;
                      if (v43 == 8) {
                        goto LABEL_132;
                      }
                      if (!v44)
                      {
                        char v87 = v48;
                        BOOL v89 = v64;
                        char v84 = v59;
                        char v85 = v56;
                        char v86 = v51;
                        v66 = __nwlog_obj();
                        os_log_type_enabled(v66, OS_LOG_TYPE_ERROR);
                        *(_DWORD *)buf = 136446210;
                        v95 = "tcp_run_conn_timer";
                        v67 = (void *)_os_log_send_and_compose_impl();
                        if (__nwlog_abort())
                        {
                          __break(1u);
                          return;
                        }
                        free(v67);
                        unsigned int v43 = *(unsigned __int16 *)(v7 + 72);
                        if (v43 == 8)
                        {
                          char v51 = v86;
                          char v48 = v87;
                          char v59 = v84;
                          char v56 = v85;
                          BOOL v64 = v89;
                          goto LABEL_132;
                        }
                        int v40 = *(_DWORD *)(v7 + 64);
                        char v51 = v86;
                        char v48 = v87;
                        char v59 = v84;
                        char v56 = v85;
                        BOOL v64 = v89;
                      }
                      goto LABEL_129;
                    }
LABEL_109:
                    char v59 = 1;
                    int v60 = *(_DWORD *)(v7 + 40);
                    if (!v60) {
                      goto LABEL_115;
                    }
                    goto LABEL_110;
                  }
LABEL_102:
                  char v56 = 1;
                  int v57 = *(_DWORD *)(v7 + 36);
                  if (v57) {
                    goto LABEL_105;
                  }
                  goto LABEL_109;
                }
LABEL_95:
                char v91 = 1;
                int v54 = *(_DWORD *)(v7 + 32);
                if (v54) {
                  goto LABEL_98;
                }
                goto LABEL_102;
              }
            }
            else
            {
              int v44 = 0;
              int v42 = 0;
              int v41 = 0;
              unsigned int v43 = 8;
              char v45 = 1;
              int v46 = *(_DWORD *)(v7 + 20);
              if (v46) {
                goto LABEL_77;
              }
LABEL_81:
              char v48 = 1;
              int v49 = *(_DWORD *)(v7 + 24);
              if (v49) {
                goto LABEL_84;
              }
            }
LABEL_88:
            char v51 = 1;
            int v52 = *(_DWORD *)(v7 + 28);
            if (v52) {
              goto LABEL_91;
            }
            goto LABEL_95;
          }
        }
        int v14 = *(_DWORD *)(v7 + 88);
        if ((v14 & 0x40000000) != 0)
        {
          uint64_t v15 = *(void *)(v7 + 48);
          *(_DWORD *)(v7 + 88) = v14 & 0xBFFFFFFF;
          if (v15) {
            *(void *)(v15 + 8) = *(void *)(v7 + 56);
          }
          **(void **)(v7 + 56) = v15;
          --*(_DWORD *)(a1 + 280);
          *(void *)(v7 + 48) = 0;
          *(void *)(v7 + 56) = 0;
        }
      }
      else
      {
        if (v3 - 1 >= v5) {
          unsigned int v3 = *((_DWORD *)v6 + 5) - *(_DWORD *)(a1 + 316);
        }
        v4 |= *((unsigned __int16 *)v6 + 13);
      }
LABEL_8:
      ;
    }
    while (v2);
    if (*(void *)(a1 + 256))
    {
      if (v4)
      {
        BOOL v77 = 0;
        int v78 = 1;
      }
      else
      {
        int v75 = *(_DWORD *)(a1 + 296);
        if (((v75 | v4) & 2) != 0) {
          int v76 = 2;
        }
        else {
          int v76 = 4;
        }
        BOOL v77 = (v75 & 1) == 0 && ((v75 | v4) & 2) == 0;
        if (*(_DWORD *)(a1 + 296)) {
          int v78 = 1;
        }
        else {
          int v78 = v76;
        }
      }
      *(_DWORD *)(a1 + 304) = 0;
      *(_DWORD *)(a1 + 292) = v78;
      unsigned int v80 = *(_DWORD *)(a1 + 300);
      if (v80 >= v3) {
        unsigned int v81 = v3;
      }
      else {
        unsigned int v81 = *(_DWORD *)(a1 + 300);
      }
      if (v80) {
        unsigned int v82 = v81;
      }
      else {
        unsigned int v82 = v3;
      }
      if (v82 <= 0x1F4) {
        int v83 = 500;
      }
      else {
        int v83 = v82;
      }
      if (v77) {
        unsigned int v79 = v83;
      }
      else {
        unsigned int v79 = v82;
      }
    }
    else
    {
LABEL_168:
      unsigned int v79 = tcp_timerlist_max_offset;
    }
    tcp_sched_timerlist(a1, v79);
    *(unsigned char *)(a1 + 310) &= ~1u;
    *(void *)(a1 + 296) = 0;
    *(_WORD *)(a1 + 308) = 0;
  }
}

uint64_t in_pcb_checkstate(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  if (a2 == 0xFFFF)
  {
    if (!a3) {
      (*(void (**)(void))(*(void *)(*(void *)(a1 + 224) + 8) + 16))();
    }
    *(_DWORD *)(a1 + 232) = 3;
LABEL_11:
    uint64_t v9 = *(void *)(a1 + 224);
    if ((*(_DWORD *)(v9 + 360) & 0x80000000) != 0)
    {
      if ((*(unsigned char *)(v9 + 828) & 2) != 0) {
        return 0xFFFFLL;
      }
      __nwlog_tcp_log();
      uint64_t v20 = v9 + 604;
      uint64_t v21 = *(void *)(a1 + 224);
      *(_DWORD *)buf = 136446978;
      int v39 = "in_pcb_checkstate";
      __int16 v40 = 2082;
      int v41 = (const char *)(v9 + 604);
      __int16 v42 = 2048;
      uint64_t v43 = a1;
      __int16 v44 = 2048;
      uint64_t v45 = v21;
      uint64_t v22 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        int v28 = __nwlog_tcp_log();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          uint64_t v29 = *(void *)(a1 + 224);
          *(_DWORD *)buf = 136446978;
          int v39 = "in_pcb_checkstate";
          __int16 v40 = 2082;
          int v41 = (const char *)v20;
          __int16 v42 = 2048;
          uint64_t v43 = a1;
          __int16 v44 = 2048;
          uint64_t v45 = v29;
          int v30 = "%{public}s %{public}s pcb=%p so=%p usecount is negative, backtrace limit exceeded";
LABEL_62:
          v34 = v28;
          uint32_t v35 = 42;
LABEL_63:
          _os_log_impl(&dword_214653000, v34, OS_LOG_TYPE_ERROR, v30, buf, v35);
        }
      }
LABEL_64:
      if (v22) {
        free(v22);
      }
      return 0xFFFFLL;
    }
    if (!a3)
    {
      (*(void (**)(void, uint64_t, uint64_t))(*(void *)(v9 + 8) + 24))(*(void *)(a1 + 224), 1, v3);
      uint64_t v9 = *(void *)(a1 + 224);
    }
    uint64_t v10 = nw_tcp_access_globals(v9);
    uint64_t v11 = *(void *)(a1 + 16);
    *(unsigned char *)(v10 + 328) |= 2u;
    atomic_fetch_add((atomic_uint *volatile)(v11 + 44), 1u);
    if (*(unsigned char *)(v10 + 328))
    {
      if ((*(unsigned char *)(v10 + 328) & 8) != 0) {
        goto LABEL_40;
      }
      char v12 = 8;
    }
    else
    {
      if ((*(unsigned char *)(v10 + 328) & 6) == 0) {
        goto LABEL_40;
      }
      char v12 = 9;
    }
    *(unsigned char *)(v10 + 328) |= v12;
    nw_protocol_timer_run_inner(v10, 1000000000, 0);
LABEL_40:
    uint64_t v6 = 0xFFFFLL;
    if (!(unsigned __int16)*(_DWORD *)(a1 + 456))
    {
      int v23 = *(_DWORD *)(a1 + 456);
      atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(a1 + 456), (unsigned int *)&v23, 0xFFFFu, memory_order_relaxed, memory_order_relaxed);
    }
    return v6;
  }
  uint64_t v6 = a2;
  if (a2 == 2)
  {
    if (!a3) {
      (*(void (**)(void))(*(void *)(*(void *)(a1 + 224) + 8) + 16))();
    }
    do
    {
      int v13 = *(_DWORD *)(a1 + 456);
      if ((unsigned __int16)v13 == 0xFFFF)
      {
        if (!a3) {
          (*(void (**)(void))(*(void *)(*(void *)(a1 + 224) + 8) + 24))();
        }
        return 0xFFFFLL;
      }
      if (!(unsigned __int16)*(_DWORD *)(a1 + 456))
      {
        uint64_t v24 = *(void *)(a1 + 224);
        if (v24 && (*(unsigned char *)(v24 + 828) & 2) != 0) {
          return 0xFFFFLL;
        }
        __nwlog_tcp_log();
        *(_DWORD *)buf = 136446722;
        int v39 = "in_pcb_checkstate";
        if (v24) {
          uint64_t v25 = (const char *)(v24 + 604);
        }
        else {
          uint64_t v25 = "";
        }
        __int16 v40 = 2082;
        int v41 = v25;
        __int16 v42 = 2048;
        uint64_t v43 = a1;
        uint64_t v22 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          uint64_t v31 = __nwlog_tcp_log();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            int v39 = "in_pcb_checkstate";
            __int16 v40 = 2082;
            int v41 = v25;
            __int16 v42 = 2048;
            uint64_t v43 = a1;
            int v30 = "%{public}s %{public}s pcb=%p release with zero count, backtrace limit exceeded";
            v34 = v31;
            uint32_t v35 = 32;
            goto LABEL_63;
          }
        }
        goto LABEL_64;
      }
      int v14 = *(_DWORD *)(a1 + 456);
      atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(a1 + 456), (unsigned int *)&v14, v13 - 1, memory_order_relaxed, memory_order_relaxed);
    }
    while (v14 != v13);
    if (*(_DWORD *)(a1 + 232) == 3) {
      goto LABEL_11;
    }
    uint64_t v15 = *(void *)(a1 + 224);
    if ((*(_DWORD *)(v15 + 360) & 0x80000000) == 0)
    {
      if (!a3) {
        (*(void (**)(void, uint64_t, uint64_t))(*(void *)(v15 + 8) + 24))(*(void *)(a1 + 224), 1, v3);
      }
      return 2;
    }
    if ((*(unsigned char *)(v15 + 828) & 2) != 0) {
      return 0xFFFFLL;
    }
    __nwlog_tcp_log();
    int v32 = (const char *)(v15 + 604);
    uint64_t v33 = *(void *)(a1 + 224);
    *(_DWORD *)buf = 136446978;
    int v39 = "in_pcb_checkstate";
    __int16 v40 = 2082;
    int v41 = (const char *)(v15 + 604);
    __int16 v42 = 2048;
    uint64_t v43 = a1;
    __int16 v44 = 2048;
    uint64_t v45 = v33;
    uint64_t v22 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v28 = __nwlog_tcp_log();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        uint64_t v37 = *(void *)(a1 + 224);
        *(_DWORD *)buf = 136446978;
        int v39 = "in_pcb_checkstate";
        __int16 v40 = 2082;
        int v41 = v32;
        __int16 v42 = 2048;
        uint64_t v43 = a1;
        __int16 v44 = 2048;
        uint64_t v45 = v37;
        int v30 = "%{public}s %{public}s RELEASE pcb=%p so=%p usecount is negative, backtrace limit exceeded";
        goto LABEL_62;
      }
    }
    goto LABEL_64;
  }
  if (a2 == 1)
  {
    uint64_t v6 = 0xFFFFLL;
    while (1)
    {
      int v7 = *(_DWORD *)(a1 + 456);
      if ((_WORD)v7 == 0xFFFF) {
        break;
      }
      int v8 = *(_DWORD *)(a1 + 456);
      atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(a1 + 456), (unsigned int *)&v8, v7 + 1, memory_order_relaxed, memory_order_relaxed);
      if (v8 == v7) {
        return 1;
      }
    }
  }
  else
  {
    uint64_t v16 = *(void *)(a1 + 224);
    if (!v16 || (*(unsigned char *)(v16 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      uint64_t v17 = *(void *)(a1 + 224);
      *(_DWORD *)buf = 136446978;
      __int16 v40 = 2082;
      int v39 = "in_pcb_checkstate";
      if (v16) {
        uint64_t v18 = (const char *)(v16 + 604);
      }
      else {
        uint64_t v18 = "";
      }
      int v41 = v18;
      __int16 v42 = 2048;
      uint64_t v43 = v17;
      __int16 v44 = 1024;
      LODWORD(v45) = v6;
      int v19 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        BOOL v26 = __nwlog_tcp_log();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          uint64_t v27 = *(void *)(a1 + 224);
          *(_DWORD *)buf = 136446978;
          int v39 = "in_pcb_checkstate";
          __int16 v40 = 2082;
          int v41 = v18;
          __int16 v42 = 2048;
          uint64_t v43 = v27;
          __int16 v44 = 1024;
          LODWORD(v45) = v6;
          _os_log_impl(&dword_214653000, v26, OS_LOG_TYPE_ERROR, "%{public}s %{public}s so=%p not a valid state =%x, backtrace limit exceeded", buf, 0x26u);
        }
      }
      if (v19) {
        free(v19);
      }
    }
  }
  return v6;
}

void tcp_sched_timerlist(uint64_t a1, unsigned int a2)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 288)) {
    return;
  }
  int v3 = tcp_timerlist_max_offset;
  if (tcp_timerlist_max_offset >= a2) {
    unsigned int v4 = a2;
  }
  else {
    unsigned int v4 = tcp_timerlist_max_offset;
  }
  unsigned int v5 = *(_DWORD *)(a1 + 316);
  unsigned int v6 = v5 + v4;
  if ((*(unsigned char *)(a1 + 310) & 2) == 0 || (unsigned int v7 = *(_DWORD *)(a1 + 272), v6 < v7))
  {
    *(_DWORD *)(a1 + 272) = v6;
    if (!v6)
    {
      *(_DWORD *)(a1 + 272) = 1;
      ++v4;
    }
    goto LABEL_17;
  }
  if (v7 <= v5 && v6 > v5)
  {
    *(_DWORD *)(a1 + 272) = v6;
LABEL_17:
    *(_DWORD *)(a1 + 276) = v5;
    if (v4 == v3)
    {
      if (__nwlog_is_datapath_logging_enabled()
        && (int v15 = v3, v16 = __nwlog_obj(), os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)))
      {
        int v17 = *(_DWORD *)(a1 + 292);
        int v18 = *(_DWORD *)(a1 + 276);
        int v19 = *(_DWORD *)(a1 + 272);
        int v26 = 136447234;
        uint64_t v27 = "tcp_sched_timerlist";
        __int16 v28 = 1024;
        int v29 = v17;
        __int16 v30 = 1024;
        int v31 = v18;
        __int16 v32 = 1024;
        int v33 = v19;
        __int16 v34 = 1024;
        unsigned int v35 = v15;
        _os_log_impl(&dword_214653000, v16, OS_LOG_TYPE_DEBUG, "%{public}s mode %d schedtime %u runtime %u offset %u, deadline set to forever", (uint8_t *)&v26, 0x24u);
        int64_t v14 = -1;
      }
      else
      {
        int64_t v14 = -1;
      }
    }
    else
    {
      int64_t v14 = 1000000 * v4;
      if (__nwlog_is_datapath_logging_enabled())
      {
        unsigned int v20 = v4;
        uint64_t v21 = __nwlog_obj();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        {
          int v22 = *(_DWORD *)(a1 + 292);
          int v23 = *(_DWORD *)(a1 + 276);
          int v24 = *(_DWORD *)(a1 + 272);
          int v26 = 136447234;
          uint64_t v27 = "tcp_sched_timerlist";
          __int16 v28 = 1024;
          int v29 = v22;
          __int16 v30 = 1024;
          int v31 = v23;
          __int16 v32 = 1024;
          int v33 = v24;
          __int16 v34 = 1024;
          unsigned int v35 = v20;
          uint64_t v25 = v21;
          unsigned int v4 = v20;
          _os_log_impl(&dword_214653000, v25, OS_LOG_TYPE_DEBUG, "%{public}s mode %d schedtime %u runtime %u offset %u", (uint8_t *)&v26, 0x24u);
        }
        else
        {
          unsigned int v4 = v20;
        }
      }
    }
    nw_protocol_timer_run_inner(a1, v14, 1);
    if (v4 != tcp_timerlist_max_offset) {
      *(unsigned char *)(a1 + 310) |= 2u;
    }
    return;
  }
  if (__nwlog_is_datapath_logging_enabled())
  {
    uint64_t v9 = __nwlog_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      int v10 = *(_DWORD *)(a1 + 292);
      int v11 = *(_DWORD *)(a1 + 276);
      int v12 = *(_DWORD *)(a1 + 272);
      int v13 = *(_DWORD *)(a1 + 316);
      int v26 = 136447746;
      uint64_t v27 = "tcp_sched_timerlist";
      __int16 v28 = 1024;
      int v29 = v10;
      __int16 v30 = 1024;
      int v31 = v11;
      __int16 v32 = 1024;
      int v33 = v12;
      __int16 v34 = 1024;
      unsigned int v35 = v6;
      __int16 v36 = 1024;
      int v37 = v13;
      __int16 v38 = 1024;
      unsigned int v39 = v4;
      _os_log_impl(&dword_214653000, v9, OS_LOG_TYPE_DEBUG, "%{public}s mode %d schedtime %u runtime %u new_runtime %u tcp_now %u offset %u, not pushing timer out", (uint8_t *)&v26, 0x30u);
    }
  }
}

void nw_protocol_timer_run_inner(uint64_t a1, int64_t a2, int a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v3 = 96;
  if (a3) {
    uint64_t v3 = 88;
  }
  uint64_t v4 = *(void *)(a1 + v3);
  if (a2 == -1)
  {
    uint64_t v7 = *(void *)(a1 + v3);
    uint64_t v6 = -1;
    goto LABEL_7;
  }
  dispatch_time_t v5 = dispatch_time(0x8000000000000000, a2);
  if (v5 != -1)
  {
    uint64_t v6 = v5;
    uint64_t v7 = v4;
LABEL_7:
    MEMORY[0x270EF90B8](v7, v6, -1, 0);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v11 = "nw_protocol_timer_run_inner";
  int v8 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    uint64_t v9 = __nwlog_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      int v11 = "nw_protocol_timer_run_inner";
      _os_log_impl(&dword_214653000, v9, OS_LOG_TYPE_ERROR, "%{public}s dispatch_time: Integer overflow failed, backtrace limit exceeded", buf, 0xCu);
    }
  }
  if (v8) {
    free(v8);
  }
}

uint64_t tcp_timers(uint64_t a1, int a2)
{
  uint64_t v3 = a1;
  uint64_t v163 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a1 + 80);
  uint64_t v5 = *(void *)(v4 + 448);
  uint64_t v6 = *(void *)(v4 + 224);
  uint64_t v7 = nw_tcp_access_globals(v6);
  uint64_t v8 = v7;
  int v9 = *(_DWORD *)(v7 + 316);
  int v10 = v9 - *(_DWORD *)(v3 + 160);
  switch(a2)
  {
    case 0:
      int v11 = *(_DWORD *)(v3 + 740);
      unsigned int v12 = v11 & 0xFFFFEFFF;
      *(_DWORD *)(v3 + 740) = v11 & 0xFFFFEFFF;
      if (*(_DWORD *)(v3 + 12) == 4 && (!*(_WORD *)(v3 + 226) || (v11 & 0x200000) != 0))
      {
        int v13 = *(_DWORD *)(v3 + 96);
        unsigned int v14 = v13 - *(_DWORD *)(v3 + 92);
        if (v14)
        {
          if ((v11 & 0x20) != 0 && (*(unsigned char *)(v3 + 90) & 0x20) == 0)
          {
            unsigned int v15 = *(_DWORD *)(v6 + 384);
            if (v15 >= *(_DWORD *)(v3 + 140)) {
              unsigned int v15 = *(_DWORD *)(v3 + 140);
            }
            if ((int)(v15 - v14) < 1)
            {
              unsigned int v104 = *(_DWORD *)(v3 + 196);
              if (v14 < v104) {
                unsigned int v104 = v13 - *(_DWORD *)(v3 + 92);
              }
              v13 -= v104;
              unsigned int v16 = v12 | 0x40000000;
            }
            else
            {
              unsigned int v16 = v11 & 0xBFFFEFFF;
            }
            *(_DWORD *)(v3 + 100) = v13;
            uint64_t v105 = *(void *)(v3 + 1056);
            if (v105)
            {
              ++*(void *)(v105 + 712);
              if ((v16 & 0x200000) != 0) {
                ++*(void *)(v105 + 728);
              }
            }
            *(_DWORD *)(v3 + 172) = 0;
            *(_DWORD *)(v3 + 740) = v16 | 0x1000;
            *(_DWORD *)(v3 + 936) = v9;
            *(_DWORD *)(v3 + 144) += *(_DWORD *)(v3 + 196);
            *(_DWORD *)(v3 + 28) = 0;
            tcp_output(v3);
            *(_DWORD *)(v3 + 144) -= *(_DWORD *)(v3 + 196);
            int v106 = *(_DWORD *)(v3 + 100);
            *(_DWORD *)(v3 + 928) = v106;
            *(_DWORD *)(v3 + 932) = v106;
          }
        }
      }
      return v3;
    case 1:
      int v34 = *(_DWORD *)(v3 + 740);
      *(_DWORD *)(v3 + 740) = v34 & 0xFFFFBFFF;
      if ((*(unsigned char *)(v3 + 90) & 0x20) != 0
        || *(_DWORD *)(v3 + 92) - *(_DWORD *)(v3 + 152) >= 0
        || *(_WORD *)(v3 + 226))
      {
        return v3;
      }
      if ((v34 & 0x20) != 0) {
        goto LABEL_62;
      }
      v155 = __nwlog_obj();
      os_log_type_enabled(v155, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "tcp_timers";
      v156 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = __nwlog_abort();
      if (result)
      {
        __break(1u);
        return result;
      }
      free(v156);
LABEL_62:
      tcp_rexmt_save_state(v3);
      unsigned int v35 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(v3 + 264)] + 64);
      if (v35)
      {
        if ((v35(v3), int v36 = *(_DWORD *)(v3 + 740), (v36 & 0x10000000) != 0)
          || (v36 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1
          || (~*(_DWORD *)(v3 + 348) & 0x300000) != 0)
        {
          int v37 = *(_DWORD *)(v3 + 348);
          if ((~v37 & 3) == 0) {
            *(_DWORD *)(v3 + 348) = v37 | 8;
          }
        }
      }
      *(_DWORD *)(v3 + 88) |= 0x200000u;
      uint64_t v38 = *(void *)(v3 + 80);
      if ((*(unsigned char *)(v38 + 2231) & 0x40) != 0) {
        inp_reset_fc_state(v38);
      }
      if (*(void *)(v3 + 952)) {
        tcp_rxtseg_clean(v3);
      }
      *(_DWORD *)(v3 + 28) = 0;
      uint64_t v39 = *(void *)(v3 + 1056);
      if (v39) {
        ++*(void *)(v39 + 568);
      }
      ++*(_DWORD *)(v3 + 1004);
      *(_DWORD *)(v3 + 144) = *(_DWORD *)(v3 + 196);
      goto LABEL_364;
    case 2:
      if ((*(_DWORD *)(v3 + 740) & 0x20400020) == 0x20000020) {
        tcp_rack_reordering_timeout(v3);
      }
      return v3;
    case 3:
      unsigned __int16 v22 = *(_WORD *)(v3 + 226) + 1;
      *(_WORD *)(v3 + 226) = v22;
      if (v22 > 0xCu) {
        goto LABEL_162;
      }
      unsigned int v23 = *(_DWORD *)(v3 + 244);
      if (v23)
      {
        int v24 = *(_DWORD *)(v3 + 248);
        if (v24)
        {
          if (v9 - v24 >= v23) {
            goto LABEL_162;
          }
        }
      }
      if ((*(unsigned char *)(v3 + 740) & 1) == 0 || (*(unsigned char *)(v3 + 88) & 0x10) == 0)
      {
        if (v22 < 5u) {
          goto LABEL_190;
        }
        int v25 = *(_DWORD *)(v3 + 12);
        if (v25 >= 4 && v5)
        {
          if ((*(unsigned char *)(v5 + 1052) & 8) != 0)
          {
            if (*(void *)(*(void *)(*(void *)(v3 + 80) + 224) + 24))
            {
              uint64_t all_stats = nw_protocol_tcp_get_all_stats();
              if (all_stats)
              {
                char v27 = 2;
LABEL_189:
                *(unsigned char *)(all_stats + 96) |= v27;
              }
            }
          }
        }
        else if (v25 <= 3)
        {
          if (*(void *)(*(void *)(*(void *)(v3 + 80) + 224) + 24))
          {
            uint64_t all_stats = nw_protocol_tcp_get_all_stats();
            if (all_stats)
            {
              char v27 = 8;
              goto LABEL_189;
            }
          }
        }
LABEL_190:
        uint64_t v81 = *(void *)(v3 + 1056);
        if (v81) {
          ++*(void *)(v81 + 480);
        }
        *(void *)(v3 + 216) = 0;
        if (*(_WORD *)(v3 + 226) == 1 && *(_DWORD *)(v3 + 12) == 4)
        {
          *(_DWORD *)(v3 + 248) = *(_DWORD *)(v8 + 316);
          tcp_rexmt_save_state(v3);
        }
        if (*(unsigned char *)(v3 + 266))
        {
          if (*(unsigned __int16 *)(v3 + 226) > *(unsigned __int8 *)(v3 + 266) && *(int *)(v3 + 12) >= 4)
          {
            if (v6)
            {
              uint64_t v82 = *(void *)(v6 + 32);
              if (v82)
              {
                int v83 = *(void (**)(uint64_t))(v82 + 80);
                if (v83) {
                  v83(v6);
                }
              }
            }
          }
        }
        int v84 = *(_DWORD *)(v3 + 740);
        if ((v84 & 0x1000) != 0)
        {
          v84 &= ~0x1000u;
          *(_DWORD *)(v3 + 740) = v84;
          uint64_t v85 = *(void *)(v3 + 1056);
          if (v85) {
            ++*(void *)(v85 + 720);
          }
        }
        if ((v84 & 0x4000) != 0)
        {
          *(_WORD *)(v3 + 536) = 0;
          *(_DWORD *)(v3 + 20) = 0;
          v84 &= ~0x4000u;
          *(_DWORD *)(v3 + 740) = v84;
        }
        if ((v84 & 0x1000000) == 0 && *(_DWORD *)(v3 + 12) == 3)
        {
          v84 &= ~0x400000u;
          *(_DWORD *)(v3 + 740) = v84;
        }
        if ((v84 & 0x1000000) == 0
          && (*(unsigned char *)(v3 + 988) & 0x40) == 0
          && (*(unsigned char *)(v3 + 988) & 0x20) == 0
          && (*(_WORD *)(v3 + 990) & 0x40) != 0)
        {
          unsigned int v86 = *(unsigned __int16 *)(v3 + 226);
          if (*(_DWORD *)(v3 + 12) == 2)
          {
            if (v86 < 5) {
              goto LABEL_270;
            }
          }
          else if (v86 <= 1)
          {
            goto LABEL_270;
          }
          tcp_heuristic_tfo_middlebox(v3);
          *(_WORD *)(v6 + 378) = 96;
          user_north_signal_error(v6);
          v107 = *(void (***)(uint64_t))(v6 + 32);
          if (v107)
          {
            v108 = v107[3];
            if (!v108 || (v108(v6), (v107 = *(void (***)(uint64_t))(v6 + 32)) != 0))
            {
              v109 = *v107;
              if (v109) {
                v109(v6);
              }
            }
          }
          *(_WORD *)(v3 + 990) |= 0x1000u;
          uint64_t v110 = *(void *)(v3 + 1056);
          if (v110) {
            ++*(void *)(v110 + 1176);
          }
        }
LABEL_270:
        if ((*(unsigned char *)(v3 + 743) & 1) == 0
          && (*(unsigned char *)(v3 + 988) & 0x40) == 0
          && (*(_WORD *)(v3 + 990) & 0x80) != 0
          && *(unsigned __int16 *)(v3 + 226) >= 4u
          && *(_DWORD *)(v3 + 164) - *(_DWORD *)(v3 + 160) - 10000 >= 1)
        {
          tcp_heuristic_tfo_middlebox(v3);
          *(_WORD *)(v6 + 378) = 96;
          user_north_signal_error(v6);
          v111 = *(void (***)(uint64_t))(v6 + 32);
          if (v111)
          {
            v112 = v111[3];
            if (!v112 || (v112(v6), (v111 = *(void (***)(uint64_t))(v6 + 32)) != 0))
            {
              v113 = *v111;
              if (v113) {
                v113(v6);
              }
            }
          }
        }
        int v114 = *(_DWORD *)(v3 + 12);
        uint64_t v115 = *(unsigned int *)(v3 + 228);
        int v116 = (*(_DWORD *)(v3 + 208) + (*(int *)(v3 + 200) >> 3)) >> 2;
        if (v115 > v116) {
          int v116 = *(_DWORD *)(v3 + 228);
        }
        uint64_t v117 = *(unsigned __int16 *)(v3 + 226);
        if (v114 == 2)
        {
          int v118 = v116 * tcp_syn_backoff[v117];
          *(unsigned char *)(v3 + 716) = v117;
          int v119 = *(_DWORD *)(v3 + 740);
          if ((v119 & 0x1400000) == 0x400000)
          {
            int v120 = 0;
            *(_DWORD *)(v3 + 740) = v119 & 0xFFBFFFFF;
            *(unsigned char *)(v3 + 988) |= 0x10u;
            goto LABEL_288;
          }
        }
        else
        {
          int v118 = v116 * tcp_backoff[v117];
          if (v114 >= 4)
          {
            int v120 = *(_DWORD *)(sysctls + 176);
            goto LABEL_288;
          }
        }
        int v120 = 0;
LABEL_288:
        unsigned int v121 = v120 + v118;
        *(_DWORD *)(v3 + 192) = v121;
        if (v121 >= v115)
        {
          if (v121 < 0xFA01) {
            goto LABEL_292;
          }
          LODWORD(v115) = 64000;
        }
        *(_DWORD *)(v3 + 192) = v115;
LABEL_292:
        *(_DWORD *)(v3 + 28) = *(_DWORD *)(v3 + 192)
                             + *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v3 + 80) + 224)) + 316)
                             - *(_DWORD *)(v3 + 64);
        if ((*(unsigned char *)(*(void *)(v3 + 80) + 2231) & 0x50) != 0)
        {
LABEL_364:
          tcp_output(v3);
          return v3;
        }
        tcp_free_sackholes(v3);
        int v122 = *(_DWORD *)(v3 + 740);
        if ((v122 & 0x20400020) == 0x20000020)
        {
          tcp_segs_clear_sacked(v3);
          tcp_rack_loss_on_rto(v3);
          int v122 = *(_DWORD *)(v3 + 740);
        }
        if ((v122 & 0x20000) == 0)
        {
          int v123 = *(_DWORD *)(v3 + 12);
          if (v123 != 4) {
            goto LABEL_322;
          }
          int v124 = *(_DWORD *)(v3 + 88);
          if ((v124 & 0x4000000) == 0) {
            goto LABEL_319;
          }
          unsigned int v125 = *(_DWORD *)(v3 + 156);
          uint64_t v126 = sysctls;
          unsigned int v127 = *(_DWORD *)(sysctls + 228);
          unsigned int v128 = v127;
          if (v125 <= v127)
          {
            uint64_t v129 = 148;
            if ((*(unsigned char *)(*(void *)(v3 + 80) + 2236) & 1) == 0) {
              uint64_t v129 = 152;
            }
            unsigned int v128 = *(_DWORD *)(sysctls + v129);
          }
          if (v128 < *(unsigned __int16 *)(v3 + 696) && *(_WORD *)(v3 + 226) == 2)
          {
            *(_DWORD *)(v3 + 88) = v124 & 0xDBFFFFFF | 0x20000000;
            unsigned int v130 = *(_DWORD *)(v3 + 196) - v125;
            *(_WORD *)(v3 + 698) = v125;
            unsigned int v131 = *(_DWORD *)(v8 + 316);
            if (v131 <= 1) {
              unsigned int v131 = 1;
            }
            *(_DWORD *)(v3 + 700) = v131;
            if (v125 <= v127)
            {
              uint64_t v132 = 148;
              if ((*(unsigned char *)(*(void *)(v3 + 80) + 2236) & 1) == 0) {
                uint64_t v132 = 152;
              }
              unsigned int v127 = *(_DWORD *)(v126 + v132);
            }
            *(_DWORD *)(v3 + 156) = v127;
            unsigned int v133 = v130 + v127;
            *(_DWORD *)(v3 + 196) = v133;
            v134 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(v3 + 264)] + 40);
            if (v134)
            {
              v134(v3);
              unsigned int v133 = *(_DWORD *)(v3 + 196);
              uint64_t v126 = sysctls;
            }
            *(_DWORD *)(v3 + 144) = v133;
            if (*(_DWORD *)(v126 + 308) == 1
              && (~*(_DWORD *)(v3 + 88) & 0x180) == 0
              && (*(_DWORD *)(v126 + 40) == 1 || (*(unsigned char *)(v6 + 369) & 0x40) != 0)
              && off_26AA46358)
            {
              off_26AA46358((_DWORD *)v3);
            }
          }
          else
          {
LABEL_319:
            if ((v124 & 0x20000000) != 0 && *(unsigned __int16 *)(v3 + 226) >= 5u)
            {
              tcp_pmtud_revert_segment_size(v3);
              *(_DWORD *)(v3 + 144) = *(_DWORD *)(v3 + 196);
            }
          }
        }
        int v123 = *(_DWORD *)(v3 + 12);
LABEL_322:
        unsigned int v135 = *(unsigned __int16 *)(v3 + 226);
        if (v123 == 2)
        {
          if (*(_DWORD *)(sysctls + 220) == v135) {
            *(_DWORD *)(v3 + 88) &= 0xFFFFFF5F;
          }
          if (v135 <= 2)
          {
            if (!v6 || (*(unsigned char *)(v6 + 828) & 2) == 0)
            {
              v136 = __nwlog_tcp_log();
              if (os_log_type_enabled(v136, OS_LOG_TYPE_INFO))
              {
                v137 = (const char *)(v6 + 604);
                int v138 = *(unsigned __int16 *)(v3 + 226);
                *(void *)&uint8_t buf[4] = "tcp_timers";
                *(_DWORD *)buf = 136446722;
                if (!v6) {
                  v137 = "";
                }
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v137;
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = v138;
                v139 = "%{public}s %{public}s retransmit SYN %u";
                v140 = v136;
                os_log_type_t v141 = OS_LOG_TYPE_INFO;
                uint32_t v142 = 28;
LABEL_341:
                _os_log_impl(&dword_214653000, v140, v141, v139, buf, v142);
                goto LABEL_342;
              }
            }
            goto LABEL_342;
          }
        }
        else if (v135 < 3)
        {
          goto LABEL_345;
        }
        if (!v6 || (*(unsigned char *)(v6 + 828) & 2) == 0)
        {
          v143 = __nwlog_tcp_log();
          if (os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT))
          {
            v144 = (const char *)(v6 + 604);
            v145 = "";
            int v146 = *(_DWORD *)(v3 + 92);
            if (!v6) {
              v144 = "";
            }
            BOOL v57 = *(_DWORD *)(v3 + 12) == 2;
            int v147 = *(unsigned __int16 *)(v3 + 226);
            *(void *)&uint8_t buf[4] = "tcp_timers";
            *(_DWORD *)buf = 136447234;
            if (v57) {
              v145 = " SYN";
            }
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v144;
            *(_WORD *)&buf[22] = 2082;
            *(void *)&buf[24] = v145;
            LOWORD(v159) = 1024;
            *(_DWORD *)((char *)&v159 + 2) = v146;
            HIWORD(v159) = 1024;
            LODWORD(v160) = v147;
            v139 = "%{public}s %{public}s retransmit%{public}s seq=%u %u";
            v140 = v143;
            os_log_type_t v141 = OS_LOG_TYPE_DEFAULT;
            uint32_t v142 = 44;
            goto LABEL_341;
          }
        }
LABEL_342:
        unsigned int v135 = *(unsigned __int16 *)(v3 + 226);
        if (v135 >= 4)
        {
          *(_DWORD *)(v3 + 208) += *(int *)(v3 + 200) >> 5;
          *(_DWORD *)(v3 + 200) = 0;
          if ((*(_DWORD *)(v3 + 1872) & 0xFFFFFFFE) == 2)
          {
            *(_DWORD *)(v3 + 212) += *(int *)(v3 + 204) >> 5;
            *(_DWORD *)(v3 + 204) = 0;
          }
        }
LABEL_345:
        int v148 = *(_DWORD *)(v3 + 88);
        *(_DWORD *)(v3 + 100) = *(_DWORD *)(v3 + 92);
        *(_DWORD *)(v3 + 152) = *(_DWORD *)(v3 + 96);
        *(_DWORD *)(v3 + 88) = v148 | 1;
        if (*(int *)(v3 + 12) > 3 || v5 && *(unsigned __int8 *)(v5 + 1076) != 255 && *(_DWORD *)(v5 + 1024) != 255) {
          *(_DWORD *)(v3 + 172) = 0;
        }
        if ((v148 & 0x200000) != 0)
        {
          if (v135 == 1)
          {
LABEL_355:
            v150 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(v3 + 264)] + 88);
            if (v150)
            {
              if ((v150(v3), int v151 = *(_DWORD *)(v3 + 740), (v151 & 0x10000000) != 0)
                || (v151 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1
                || (~*(_DWORD *)(v3 + 348) & 0x300000) != 0)
              {
                int v152 = *(_DWORD *)(v3 + 348);
                if ((~v152 & 3) == 0) {
                  *(_DWORD *)(v3 + 348) = v152 | 8;
                }
              }
            }
          }
        }
        else if (v135 == 1)
        {
          uint64_t v149 = *(void *)(v3 + 1056);
          if (v149) {
            ++*(void *)(v149 + 1608);
          }
          goto LABEL_355;
        }
        *(_DWORD *)(v3 + 88) &= ~0x200000u;
        *(_DWORD *)(v3 + 8) = 0;
        *(unsigned char *)(v3 + 310) = 3;
        *(_DWORD *)(v3 + 288) = 0;
        *(_DWORD *)(v3 + 348) &= ~0x20u;
        *(_DWORD *)(v3 + 16) = 0;
        int v153 = *(_DWORD *)(v3 + 740);
        *(_DWORD *)(v3 + 984) = 0;
        *(_DWORD *)(v3 + 628) = 0;
        *(_DWORD *)(v3 + 740) = v153 & 0xFFE7FFFF;
        goto LABEL_364;
      }
      if (v22 < 4u) {
        goto LABEL_190;
      }
LABEL_162:
      uint64_t v72 = *(void *)(v3 + 1056);
      if (*(unsigned char *)(v3 + 740))
      {
        if (v72) {
          ++*(void *)(v72 + 496);
        }
      }
      else if (v72)
      {
        ++*(void *)(v72 + 488);
      }
      int v73 = *(_DWORD *)(v3 + 348) & 3;
      if (v22 < 0xCu) {
        goto LABEL_176;
      }
      uint64_t v74 = *(void *)(v3 + 80);
      int v75 = *(void **)(v74 + 448);
      if (v73 == 3)
      {
        if (!v75)
        {
          *(_WORD *)(v3 + 226) = 12;
LABEL_177:
          if (*(_DWORD *)(v3 + 12) == 4) {
            tcp_heuristic_ecn_droprxmt(v3);
          }
          goto LABEL_181;
        }
        char v76 = *(unsigned char *)(v74 + 2236);
        BOOL v77 = v75 + 45;
        int v78 = v75 + 93;
      }
      else
      {
        if (!v75)
        {
          *(_WORD *)(v3 + 226) = 12;
          goto LABEL_181;
        }
        char v76 = *(unsigned char *)(v74 + 2236);
        BOOL v77 = v75 + 58;
        int v78 = v75 + 106;
      }
      if ((v76 & 2) == 0) {
        int v78 = v77;
      }
      ++*v78;
LABEL_176:
      *(_WORD *)(v3 + 226) = 12;
      if (v73 == 3) {
        goto LABEL_177;
      }
LABEL_181:
      if (*(_DWORD *)(v3 + 256)) {
        int v79 = *(_DWORD *)(v3 + 256);
      }
      else {
        int v79 = 60;
      }
      uint64_t v80 = v3;
      goto LABEL_254;
    case 4:
      uint64_t v17 = sysctls;
      if (!*(_DWORD *)(sysctls + 36)) {
        return v3;
      }
      int v18 = *(_DWORD *)(v3 + 88);
      if ((v18 & 2) == 0) {
        return v3;
      }
      *(_DWORD *)(v3 + 32) = 0;
      *(_DWORD *)(v3 + 88) = v18 & 0xFFFFFFFC | 1;
      if (v18 < 0)
      {
        unsigned int v19 = *(unsigned __int16 *)(v3 + 304);
        if (v19 >= 2 && *(_DWORD *)(v17 + 52) > (signed int)v19) {
          ++*(unsigned char *)(v3 + 267);
        }
        if (*(unsigned __int8 *)(v3 + 267) >= 6u)
        {
          *(_DWORD *)(v3 + 740) |= 0x10000u;
          *(_DWORD *)(v3 + 336) = *(_DWORD *)(v7 + 316);
          uint64_t v20 = *(void *)(v3 + 1056);
          if (v20) {
            ++*(void *)(v20 + 1624);
          }
          *(unsigned char *)(v3 + 267) = 0;
          *(_DWORD *)(v3 + 340) = 0;
        }
        tcp_reset_stretch_ack(v3);
      }
      *(_WORD *)(v3 + 308) = 16;
      *(_DWORD *)(v3 + 744) = 0;
      uint64_t v21 = *(void *)(v3 + 1056);
      if (v21) {
        ++*(void *)(v21 + 56);
      }
      ++*(_DWORD *)(v3 + 724);
      goto LABEL_364;
    case 5:
      uint64_t v40 = *(void *)(v3 + 1056);
      if (v40) {
        ++*(void *)(v40 + 504);
      }
      if (*(_WORD *)(v3 + 226) != 12) {
        goto LABEL_85;
      }
      if (v10 <= 7199999)
      {
        uint64_t v41 = *(unsigned int *)(v3 + 228);
        if (v41 <= (*(_DWORD *)(v3 + 208) + (*(int *)(v3 + 200) >> 3)) >> 2) {
          LODWORD(v41) = (*(_DWORD *)(v3 + 208) + (*(int *)(v3 + 200) >> 3)) >> 2;
        }
        if (v10 < 511 * (int)v41)
        {
LABEL_85:
          int v42 = *(_DWORD *)(v3 + 316);
          if (!v42 || v42 - v9 > 0)
          {
            tcp_setpersist(v3);
            *(_DWORD *)(v3 + 740) |= 0x8000u;
            tcp_output(v3);
            *(_DWORD *)(v3 + 740) &= ~0x8000u;
            return v3;
          }
        }
      }
      if (v40) {
        ++*(void *)(v40 + 512);
      }
      goto LABEL_253;
    case 6:
      uint64_t v43 = *(void *)(v3 + 1056);
      if (v43) {
        ++*(void *)(v43 + 520);
      }
      int v44 = *(_DWORD *)(v3 + 12);
      if (v44 <= 3)
      {
        if (v44 != 1 || v6 && (*(unsigned char *)(v6 + 828) & 2) != 0) {
          goto LABEL_251;
        }
        __nwlog_tcp_log();
        if (v6) {
          uint64_t v45 = (const char *)(v6 + 604);
        }
        else {
          uint64_t v45 = "";
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "tcp_timers";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v45;
        uint64_t v46 = (void *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        if (!__nwlog_fault()) {
          goto LABEL_249;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          int v47 = __nwlog_tcp_log();
          os_log_type_t v48 = type[0];
          if (!os_log_type_enabled(v47, type[0])) {
            goto LABEL_249;
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "tcp_timers";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v45;
          int v49 = "%{public}s %{public}s TCP listener failed to receive inbound connection within timeout, dropping connection";
        }
        else
        {
          int v47 = __nwlog_tcp_log();
          os_log_type_t v48 = type[0];
          if (!os_log_type_enabled(v47, type[0])) {
            goto LABEL_249;
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "tcp_timers";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v45;
          int v49 = "%{public}s %{public}s TCP listener failed to receive inbound connection within timeout, dropping connect"
                "ion, backtrace limit exceeded";
        }
        _os_log_impl(&dword_214653000, v47, v48, v49, buf, 0x16u);
LABEL_249:
        if (v46) {
          free(v46);
        }
        goto LABEL_251;
      }
      uint64_t v54 = *(void *)(v3 + 80);
      uint64_t v55 = *(void *)(v54 + 224);
      int v56 = *(_DWORD *)(v55 + 372);
      if ((v56 & 8) == 0 && (*(unsigned char *)(v3 + 740) & 0x80) == 0 && *(unsigned char *)(v3 + 993) != 1
        || ((v44 - 4) >= 4 ? (BOOL v57 = v44 == 9) : (BOOL v57 = 1), !v57))
      {
        int v64 = *(_DWORD *)(nw_tcp_access_globals(v55) + 316);
        int v65 = *(_DWORD *)(v3 + 676);
        if (!v65 || (*(unsigned char *)(*(void *)(*(void *)(v3 + 80) + 224) + 372) & 8) == 0) {
          int v65 = *(_DWORD *)(sysctls + 192);
        }
        goto LABEL_147;
      }
      if ((v56 & 8) != 0 && (int v58 = *(_DWORD *)(v3 + 676)) != 0)
      {
        int v59 = *(_DWORD *)(v3 + 688);
        if (v59) {
          goto LABEL_122;
        }
      }
      else
      {
        int v58 = *(_DWORD *)(sysctls + 192);
        int v59 = *(_DWORD *)(v3 + 688);
        if (v59)
        {
LABEL_122:
          int v60 = *(_DWORD *)(v3 + 684);
          if (v60) {
            goto LABEL_123;
          }
          goto LABEL_131;
        }
      }
      int v59 = *(_DWORD *)(sysctls + 200);
      int v60 = *(_DWORD *)(v3 + 684);
      if (v60) {
        goto LABEL_123;
      }
LABEL_131:
      int v60 = *(_DWORD *)(sysctls + 196);
LABEL_123:
      if (v10 < v58 + v60 * v59)
      {
        uint64_t v159 = 0;
        memset(buf, 0, sizeof(buf));
        *(void *)type = 0x1000000000;
        if (v43) {
          ++*(void *)(v43 + 528);
        }
        if ((*(unsigned char *)(v54 + 2236) & 2) != 0) {
          __int16 v61 = in6_pseudo();
        }
        else {
          __int16 v61 = in_pseudo();
        }
        __int16 v161 = v61;
        HIDWORD(v66) = *(_DWORD *)(v54 + 2224);
        LODWORD(v66) = HIDWORD(v66);
        *(void *)&long long v160 = (v66 >> 16);
        *((void *)&v160 + 1) = 0x5000000000;
        __int16 v162 = 0;
        tcp_respond(v3, &v160, 0, *(_DWORD *)(v3 + 120), *(_DWORD *)(v3 + 92) - 1, 0, (uint64_t)type);
        if ((*(unsigned char *)(v3 + 740) & 0x80) != 0) {
          ++*(unsigned char *)(v3 + 311);
        }
        int v64 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v3 + 80) + 224)) + 316);
        int v65 = *(_DWORD *)(v3 + 684);
        if (!v65) {
          int v65 = *(_DWORD *)(sysctls + 196);
        }
LABEL_147:
        *(_DWORD *)(v3 + 40) = v65 + v64 - *(_DWORD *)(v3 + 64);
        if (v5)
        {
          if ((*(unsigned char *)(v5 + 1052) & 8) != 0 && *(unsigned __int8 *)(v3 + 311) >= 5u)
          {
            if (*(void *)(*(void *)(*(void *)(v3 + 80) + 224) + 24))
            {
              uint64_t v67 = nw_protocol_tcp_get_all_stats();
              if (v67) {
                *(unsigned char *)(v67 + 96) |= 4u;
              }
            }
          }
        }
        int v68 = *(_DWORD *)(v3 + 740);
        if ((v68 & 0x80) == 0) {
          goto LABEL_227;
        }
        if (*(unsigned char *)(v3 + 265))
        {
          unsigned int v69 = *(unsigned __int8 *)(v3 + 311);
          if (v69 > *(unsigned __int8 *)(v3 + 265))
          {
            if (v6)
            {
              uint64_t v70 = *(void *)(v6 + 32);
              if (v70)
              {
                char v71 = *(void (**)(uint64_t))(v70 + 72);
                if (v71) {
                  v71(v6);
                }
              }
            }
            tcp_keepalive_reset(v3);
            goto LABEL_227;
          }
        }
        else if (!v5 || (*(unsigned char *)(v5 + 1052) & 8) == 0 || (unsigned int v69 = *(unsigned __int8 *)(v3 + 311), v69 >= 6))
        {
          *(_DWORD *)(v3 + 740) = v68 & 0xFFFFFF7F;
LABEL_227:
          int v90 = *(unsigned __int8 *)(v3 + 993);
          if (v90 == 1)
          {
            unsigned int v91 = ++*(unsigned char *)(v3 + 992);
            if (v91 >= 0xC) {
              int v92 = 12;
            }
            else {
              int v92 = v91;
            }
            int v93 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v3 + 80) + 224)) + 316);
            int v94 = tcp_backoff[v92];
            uint64_t v95 = *(unsigned int *)(v3 + 228);
            if (v95 <= (*(_DWORD *)(v3 + 208) + (*(int *)(v3 + 200) >> 3)) >> 2) {
              LODWORD(v95) = (*(_DWORD *)(v3 + 208) + (*(int *)(v3 + 200) >> 3)) >> 2;
            }
            unsigned int v96 = v93 - *(_DWORD *)(v3 + 64) + v95 * v94;
            unsigned int v97 = *(_DWORD *)(v3 + 40);
            if (v96 < v97)
            {
              int v98 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v3 + 80) + 224)) + 316);
              uint64_t v99 = *(unsigned int *)(v3 + 228);
              if (v99 <= (*(_DWORD *)(v3 + 208) + (*(int *)(v3 + 200) >> 3)) >> 2) {
                LODWORD(v99) = (*(_DWORD *)(v3 + 208) + (*(int *)(v3 + 200) >> 3)) >> 2;
              }
              unsigned int v97 = v98 - *(_DWORD *)(v3 + 64) + v99 * v94;
            }
            *(_DWORD *)(v3 + 40) = v97;
          }
          else if ((*(unsigned char *)(v3 + 743) & 1) == 0 && v90 == 2 && (*(unsigned char *)(v3 + 988) & 0x40) == 0)
          {
            tcp_heuristic_tfo_middlebox(v3);
            *(_WORD *)(v6 + 378) = 96;
            user_north_signal_error(v6);
            uint64_t v100 = *(void *)(v6 + 32);
            if (v100)
            {
              v101 = *(void (**)(uint64_t))(v100 + 24);
              if (v101) {
                v101(v6);
              }
            }
            *(_WORD *)(v3 + 990) |= 0x2000u;
            uint64_t v102 = *(void *)(v3 + 1056);
            if (v102) {
              ++*(void *)(v102 + 1144);
            }
          }
          return v3;
        }
        if (v69 >= 0xC) {
          int v87 = 12;
        }
        else {
          int v87 = v69;
        }
        uint64_t v88 = nw_tcp_access_globals(*(void *)(*(void *)(v3 + 80) + 224));
        uint64_t v89 = *(unsigned int *)(v3 + 228);
        if (v89 <= (*(_DWORD *)(v3 + 208) + (*(int *)(v3 + 200) >> 3)) >> 2) {
          LODWORD(v89) = (*(_DWORD *)(v3 + 208) + (*(int *)(v3 + 200) >> 3)) >> 2;
        }
        *(_DWORD *)(v3 + 40) = *(_DWORD *)(v88 + 316) - *(_DWORD *)(v3 + 64) + v89 * tcp_backoff[v87];
        goto LABEL_227;
      }
      if (!v6 || (*(unsigned char *)(v6 + 828) & 2) == 0)
      {
        char v62 = __nwlog_tcp_log();
        if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
        {
          int v63 = "";
          if (v6) {
            int v63 = (const char *)(v6 + 604);
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "tcp_timers";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v63;
          _os_log_impl(&dword_214653000, v62, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s dropping connection on keepalive timeout", buf, 0x16u);
        }
      }
LABEL_251:
      uint64_t v103 = *(void *)(v3 + 1056);
      if (v103) {
        ++*(void *)(v103 + 536);
      }
LABEL_253:
      uint64_t v80 = v3;
      int v79 = 60;
LABEL_254:
      tcp_drop(v80, v79);
      return 0;
    case 7:
      __int16 v28 = *(void **)(v3 + 544);
      if (!v28) {
        goto LABEL_50;
      }
      break;
    default:
      return v3;
  }
  while (1)
  {
    uint64_t v29 = v28[2];
    if (*(void **)(v3 + 616) == v28)
    {
      *(void *)(v3 + 616) = v29;
      __int16 v30 = (void *)v28[3];
      if (v29)
      {
LABEL_49:
        *(void *)(v29 + 24) = v30;
        __int16 v30 = (void *)v28[3];
        goto LABEL_44;
      }
    }
    else
    {
      __int16 v30 = (void *)v28[3];
      if (v29) {
        goto LABEL_49;
      }
    }
    *(void *)(v3 + 552) = v30;
LABEL_44:
    *__int16 v30 = v29;
    nw_tcp_access_globals(*(void *)(*(void *)(v3 + 80) + 224));
    free(v28);
    --*(_WORD *)(v3 + 538);
    atomic_fetch_add_explicit(tcp_sack_globalholes, 0xFFFFFFFF, memory_order_relaxed);
    __int16 v28 = *(void **)(v3 + 544);
    if (!v28)
    {
LABEL_50:
      *(_OWORD *)(v3 + 616) = 0u;
      int v31 = *(_DWORD *)(v3 + 12);
      if (v31 == 10 || v31 == 9 || v10 < 1) {
        goto LABEL_371;
      }
      int v50 = *(_DWORD *)(v3 + 688);
      if (!v50) {
        int v50 = *(_DWORD *)(sysctls + 200);
      }
      int v51 = *(_DWORD *)(v3 + 684);
      if (!v51) {
        int v51 = *(_DWORD *)(sysctls + 196);
      }
      if (v10 >= v51 * v50)
      {
LABEL_371:
        if (!v6 || (*(unsigned char *)(v6 + 828) & 2) == 0)
        {
          __int16 v32 = __nwlog_tcp_log();
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
          {
            int v33 = "";
            if (v6) {
              int v33 = (const char *)(v6 + 604);
            }
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "tcp_timers";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v33;
            _os_log_impl(&dword_214653000, v32, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s dropping connection on 2 MSL timeout", buf, 0x16u);
          }
        }
        tcp_close(v3);
        return 0;
      }
      else
      {
        int v52 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v3 + 80) + 224)) + 316);
        int v53 = *(_DWORD *)(v3 + 684);
        if (!v53) {
          int v53 = *(_DWORD *)(sysctls + 196);
        }
        *(_DWORD *)(v3 + 44) = v53 + v52 - *(_DWORD *)(v3 + 64);
      }
      return v3;
    }
  }
}

void tcp_set_new_cc(uint64_t a1, int a2)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(*(void *)a1 + 240);
  uint64_t v3 = *(unsigned __int8 *)(v2 + 264);
  if (v3 != a2)
  {
    uint64_t v6 = *(void (**)(void))(tcp_cc_algo_list[v3] + 32);
    if (v6) {
      v6(*(void *)(*(void *)a1 + 240));
    }
    *(unsigned char *)(v2 + 264) = a2;
    if (*(void *)(a1 + 24))
    {
      uint64_t all_stats = nw_protocol_tcp_get_all_stats();
      if (all_stats) {
        *(_DWORD *)(all_stats + 132) = a2;
      }
    }
    uint64_t v8 = *(unsigned __int8 *)(v2 + 264);
    if ((v8 - 2) <= 2 && !*(void *)(v2 + 840))
    {
      *(void *)(v2 + 840) = v2 + 848;
      *(_OWORD *)(v2 + 848) = 0u;
      *(_OWORD *)(v2 + 864) = 0u;
      *(_OWORD *)(v2 + 880) = 0u;
      *(_OWORD *)(v2 + 896) = 0u;
      *(_OWORD *)(v2 + 912) = 0u;
    }
    int v9 = *(void (**)(uint64_t))(tcp_cc_algo_list[v8] + 120);
    if (v9) {
      v9(v2);
    }
    if ((*(unsigned char *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
    {
      int v10 = __nwlog_tcp_log();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v11 = tcp_cc_algo_list[*(unsigned __int8 *)(v2 + 264)];
        int v12 = 136446722;
        int v13 = "tcp_set_new_cc";
        __int16 v14 = 2082;
        uint64_t v15 = a1 + 604;
        __int16 v16 = 2082;
        uint64_t v17 = v11;
        _os_log_impl(&dword_214653000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s cc_algo %{public}s", (uint8_t *)&v12, 0x20u);
      }
    }
  }
}

void tcp_segs_clear_sacked(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  for (uint64_t i = *(void *)(a1 + 1984); i; uint64_t i = *(void *)(i + 16))
  {
    unsigned int v4 = tcp_seg_len((int *)i);
    if (*(unsigned char *)(i + 12))
    {
      unsigned int v5 = v4;
      *(unsigned char *)(i + 12) &= ~1u;
      unsigned int v3 = *(_DWORD *)(a1 + 2080);
      if (v3 < v4)
      {
        __nwlog_obj();
        int v6 = *(_DWORD *)(a1 + 2080);
        *(_DWORD *)buf = 136446722;
        uint64_t v11 = "tcp_segs_clear_sacked";
        __int16 v12 = 1024;
        int v13 = v6;
        __int16 v14 = 1024;
        unsigned int v15 = v5;
        uint64_t v7 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          uint64_t v8 = __nwlog_obj();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          {
            int v9 = *(_DWORD *)(a1 + 2080);
            *(_DWORD *)buf = 136446722;
            uint64_t v11 = "tcp_segs_clear_sacked";
            __int16 v12 = 1024;
            int v13 = v9;
            __int16 v14 = 1024;
            unsigned int v15 = v5;
            _os_log_impl(&dword_214653000, v8, OS_LOG_TYPE_ERROR, "%{public}s bytes_sacked (%u) can't be smaller than already SACKed segment length (%u), backtrace limit exceeded", buf, 0x18u);
          }
        }
        if (v7) {
          free(v7);
        }
        unsigned int v3 = *(_DWORD *)(a1 + 2080);
      }
      *(_DWORD *)(a1 + 2080) = v3 - v5;
    }
  }
}

void tcp_rack_loss_on_rto(uint64_t a1)
{
  uint64_t v2 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
  if (*(_DWORD *)(a1 + 1016))
  {
    int v3 = *(unsigned __int8 *)(a1 + 2068);
    uint64_t v4 = *(void *)(*(void *)(a1 + 80) + 496);
    if (v4)
    {
      uint64_t v5 = *(void *)(v4 + 1488);
      if (v5) {
        LODWORD(v5) = *(_DWORD *)(v5 + 40) >> 2;
      }
      unsigned int v6 = v5 * v3;
      unsigned int v7 = *(int *)(a1 + 200) >> 5;
      if (v6 >= v7)
      {
LABEL_13:
        if (v7 <= 2) {
          int v9 = 2;
        }
        else {
          int v9 = v7;
        }
        uint64_t v10 = *(void *)(a1 + 1984);
        if (!v10) {
          return;
        }
        goto LABEL_17;
      }
      uint64_t v8 = *(void *)(v4 + 1488);
      if (v8) {
        LODWORD(v8) = *(_DWORD *)(v8 + 40) >> 2;
      }
    }
    else
    {
      unsigned int v7 = *(int *)(a1 + 200) >> 5;
      if (!v7) {
        goto LABEL_13;
      }
      LODWORD(v8) = 0;
    }
    unsigned int v7 = v8 * v3;
    goto LABEL_13;
  }
  int v9 = 0;
  uint64_t v10 = *(void *)(a1 + 1984);
  if (!v10) {
    return;
  }
LABEL_17:
  int v11 = *(_DWORD *)(v2 + 316);
  do
  {
    if (*(_DWORD *)v10 == *(_DWORD *)(a1 + 92)) {
      tcp_mark_seg_lost(a1, v10);
    }
    if ((*(unsigned char *)(v10 + 12) & 6) != 2
      && (*(unsigned char *)(v10 + 12) & 1) == 0
      && v11 - *(_DWORD *)(a1 + 2056) - (v9 + *(_DWORD *)(v10 + 8)) >= 0)
    {
      tcp_mark_seg_lost(a1, v10);
    }
    uint64_t v10 = *(void *)(v10 + 16);
  }
  while (v10);
}

double tcp_free_sackholes(uint64_t a1)
{
  for (uint64_t i = *(void **)(a1 + 544); i; uint64_t i = *(void **)(a1 + 544))
  {
    uint64_t v3 = i[2];
    if (*(void **)(a1 + 616) == i)
    {
      *(void *)(a1 + 616) = v3;
      uint64_t v4 = (void *)i[3];
      if (v3)
      {
LABEL_9:
        *(void *)(v3 + 24) = v4;
        uint64_t v4 = (void *)i[3];
        goto LABEL_4;
      }
    }
    else
    {
      uint64_t v4 = (void *)i[3];
      if (v3) {
        goto LABEL_9;
      }
    }
    *(void *)(a1 + 552) = v4;
LABEL_4:
    *uint64_t v4 = v3;
    nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
    free(i);
    --*(_WORD *)(a1 + 538);
    atomic_fetch_add_explicit(tcp_sack_globalholes, 0xFFFFFFFF, memory_order_relaxed);
  }
  double result = 0.0;
  *(_OWORD *)(a1 + 616) = 0u;
  return result;
}

int *nw_protocol_tcp_identifier()
{
  if (nw_protocol_tcp_identifier_onceToken != -1) {
    dispatch_once(&nw_protocol_tcp_identifier_onceToken, &__block_literal_global);
  }
  return &nw_protocol_tcp_identifier_identifier;
}

void nw_protocol_tcp_get_message_properties(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (nw_protocol_downcast())
    {
      if (a3)
      {
        unsigned int v4 = a3[1] & 0xFFFFFFF8 | 4;
        *a3 = -1;
        a3[1] = v4;
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v9 = "nw_protocol_tcp_get_message_properties";
    uint64_t v5 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      unsigned int v6 = __nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        int v9 = "nw_protocol_tcp_get_message_properties";
        unsigned int v7 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_14;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v9 = "nw_protocol_tcp_get_message_properties";
    uint64_t v5 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      unsigned int v6 = __nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        int v9 = "nw_protocol_tcp_get_message_properties";
        unsigned int v7 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_14:
        _os_log_impl(&dword_214653000, v6, OS_LOG_TYPE_ERROR, v7, buf, 0xCu);
      }
    }
  }
  if (v5) {
    free(v5);
  }
}

uint64_t tcp_connect(uint64_t a1, uint64_t a2)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a1 + 80);
  uint64_t v5 = *(void *)(v4 + 224);
  int v6 = *(unsigned __int16 *)(v4 + 2226);
  if (!*(_WORD *)(v4 + 2226))
  {
    if (*(_DWORD *)(v4 + 492))
    {
LABEL_39:
      uint64_t v24 = 22;
LABEL_58:
      tcp_drop(a1, v24);
      return v24;
    }
    *(void *)uint64_t v29 = 0;
    *(void *)&v29[8] = 0;
    uint64_t v24 = (*(uint64_t (**)(uint64_t, void, uint64_t, unsigned char *, uint64_t))(*(void *)(v4 + 2136) + 8))(v5, 0, 16, v29, 16);
    if (v24) {
      goto LABEL_58;
    }
    if (*(_DWORD *)&v29[4]) {
      *(_DWORD *)(v4 + 492) = *(_DWORD *)&v29[4];
    }
    int v6 = *(unsigned __int16 *)&v29[2];
    *(_WORD *)(v4 + 2226) = *(_WORD *)&v29[2];
  }
  if (*(unsigned char *)a2 != 16)
  {
    uint64_t v24 = 22;
    if (!v5) {
      goto LABEL_54;
    }
    goto LABEL_53;
  }
  if (*(unsigned char *)(a2 + 1) != 2)
  {
    uint64_t v24 = 47;
    if (!v5) {
      goto LABEL_54;
    }
    goto LABEL_53;
  }
  int v7 = *(unsigned __int16 *)(a2 + 2);
  if (!*(_WORD *)(a2 + 2))
  {
    uint64_t v24 = 49;
    if (!v5) {
      goto LABEL_54;
    }
    goto LABEL_53;
  }
  int v8 = *(_DWORD *)(a2 + 4);
  if (v8 == -1)
  {
    int v25 = __nwlog_obj();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v29 = 136446210;
      *(void *)&v29[4] = "in_pcbladdr";
      _os_log_impl(&dword_214653000, v25, OS_LOG_TYPE_ERROR, "%{public}s INADDR_BROADCAST destination not supported", v29, 0xCu);
    }
    uint64_t v24 = 61;
    if (!v5) {
      goto LABEL_54;
    }
LABEL_53:
    if ((*(unsigned char *)(v5 + 828) & 2) != 0) {
      goto LABEL_58;
    }
LABEL_54:
    int v26 = __nwlog_tcp_log();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      char v27 = "";
      if (v5) {
        char v27 = (const char *)(v5 + 604);
      }
      *(_DWORD *)uint64_t v29 = 136446466;
      *(void *)&v29[4] = "tcp_connect";
      *(_WORD *)&v29[12] = 2082;
      *(void *)&v29[14] = v27;
      _os_log_impl(&dword_214653000, v26, OS_LOG_TYPE_ERROR, "%{public}s %{public}s ipv4 pcb local address lookup failed", v29, 0x16u);
    }
    goto LABEL_58;
  }
  if (*(_DWORD *)(v4 + 492) == v8 && v6 == v7) {
    goto LABEL_39;
  }
  *(_DWORD *)(v4 + 476) = v8;
  *(_WORD *)(v4 + 2224) = v7;
  if (!*(_DWORD *)(v4 + 460))
  {
    int v10 = inp_calc_flowhash_flow_hash++;
    *(_DWORD *)(v4 + 460) = v10;
  }
  uint64_t v11 = *(int *)(sysctls + 184);
  if (v11 <= *(unsigned __int8 *)(a1 + 262)) {
    LOBYTE(v11) = *(unsigned char *)(a1 + 262);
  }
  __int16 v12 = (int *)(sysctls + 72);
  if ((*(unsigned char *)(v5 + 537) & 2) != 0) {
    __int16 v12 = (int *)(v5 + 492);
  }
  int v13 = *v12;
  unsigned int v14 = v11;
  if (v11 <= 0xDu && 0x10000 << v11 < v13)
  {
    do
    {
      LOBYTE(v11) = v14 + 1;
      if (v14 > 0xC) {
        break;
      }
      int v16 = 0x20000 << v14++;
    }
    while (v16 < v13);
  }
  if (v11 >= 0xEu) {
    LOBYTE(v11) = 14;
  }
  *(unsigned char *)(a1 + 262) = v11;
  *(_WORD *)(v5 + 376) = *(_WORD *)(v5 + 376) & 0xFFF1 | 4;
  uint64_t v17 = *(void *)(a1 + 1056);
  if (v17) {
    ++*(void *)(v17 + 376);
  }
  *(_DWORD *)(a1 + 12) = 2;
  if (*(void *)(v5 + 24))
  {
    uint64_t all_stats = nw_protocol_tcp_get_all_stats();
    if (all_stats) {
      *(_DWORD *)(all_stats + 136) = 2;
    }
  }
  int v19 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 316);
  int v20 = *(_DWORD *)(a1 + 680);
  if (!v20) {
    int v20 = *(_DWORD *)(sysctls + 188);
  }
  *(_DWORD *)(a1 + 40) = v20 + v19 - *(_DWORD *)(a1 + 64);
  int v21 = tcp_new_isn(a1);
  *(_DWORD *)(a1 + 112) = v21;
  *(_DWORD *)(a1 + 152) = v21;
  *(_DWORD *)(a1 + 96) = v21;
  *(_DWORD *)(a1 + 100) = v21;
  *(_DWORD *)(a1 + 92) = v21;
  if (!*(void *)(v5 + 24)) {
    return 0;
  }
  uint64_t v22 = nw_protocol_tcp_get_all_stats();
  if (v22) {
    *(_DWORD *)(v22 + 108) = *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92);
  }
  if (!*(void *)(v5 + 24)) {
    return 0;
  }
  uint64_t v23 = nw_protocol_tcp_get_all_stats();
  uint64_t v24 = 0;
  if (v23) {
    ++*(_DWORD *)(v23 + 60);
  }
  return v24;
}

uint64_t tcp_usr_attach(uint64_t a1)
{
  uint64_t v60 = *MEMORY[0x263EF8340];
  int v2 = **(_DWORD **)(*(void *)(a1 + 8) + 8);
  uint64_t v3 = nw_tcp_access_globals(a1);
  uint64_t v4 = v3;
  if (v3)
  {
    uint64_t v5 = *(void *)(v3 + 72);
    if (v5) {
      goto LABEL_3;
    }
  }
  else
  {
    uint64_t v54 = __nwlog_obj();
    os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
    unsigned int __buf = 136446210;
    int v59 = "tcp_attach";
    uint64_t v55 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if (result)
    {
LABEL_105:
      __break(1u);
      return result;
    }
    free(v55);
    uint64_t v5 = MEMORY[0x48];
    if (MEMORY[0x48]) {
      goto LABEL_3;
    }
  }
  int v56 = __nwlog_obj();
  os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
  unsigned int __buf = 136446210;
  int v59 = "tcp_attach";
  BOOL v57 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (result) {
    goto LABEL_105;
  }
  free(v57);
  uint64_t v5 = *(void *)(v4 + 72);
LABEL_3:
  uint64_t v6 = *(void *)a1;
  *(void *)(v6 + 16) = v5;
  *(void *)(v6 + 224) = a1;
  v7.i64[0] = v6 + 280;
  v7.i64[1] = v6 + 320;
  *(int64x2_t *)(v6 + 248) = vnegq_s64((int64x2_t)vandq_s8((int8x16_t)vnegq_s64(v7), (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFFF8)));
  *(void *)(v6 + 264) = -(uint64_t)((-360 - v6) & 0xFFFFFFFFFFFFFFF8);
  *(void *)(v6 + 272) = -(uint64_t)((-400 - v6) & 0xFFFFFFFFFFFFFFF8);
  int v8 = *(uint64_t **)(v5 + 32);
  uint64_t v9 = *v8;
  *(void *)uint64_t v6 = *v8;
  if (v9) {
    *(void *)(v9 + 8) = v6;
  }
  *int v8 = v6;
  *(void *)(v6 + 8) = v8;
  uint64_t v10 = *(void *)a1;
  if (!*(_DWORD *)(a1 + 388) || !*(_DWORD *)(a1 + 492))
  {
    unsigned int v13 = *(_DWORD *)(sysctls + 232);
    if (v13 > 0x71C71C) {
      return 55;
    }
    unsigned int v15 = *(_DWORD *)(sysctls + 236);
    *(_DWORD *)(a1 + 388) = v13;
    uint64_t v16 = *(void *)(*(void *)(a1 + 456) + 24);
    if ((*(unsigned char *)(a1 + 432) & 4) != 0)
    {
      if (v16)
      {
        uint64_t all_stats = nw_protocol_tcp_get_all_stats();
        if (all_stats) {
          *(_DWORD *)(all_stats + 88) = *(_DWORD *)(a1 + 388);
        }
      }
    }
    else if (v16)
    {
      uint64_t v17 = nw_protocol_tcp_get_all_stats();
      if (v17) {
        *(_DWORD *)(v17 + 100) = *(_DWORD *)(a1 + 388);
      }
    }
    unsigned int v29 = *(_DWORD *)(a1 + 388);
    if (*(_DWORD *)(a1 + 392) > v29) {
      *(_DWORD *)(a1 + 392) = v29;
    }
    *(_DWORD *)(a1 + 436) = v13;
    if (v15 > 0x71C71C)
    {
      sbflush(a1 + 384);
      *(_DWORD *)(a1 + 388) = 0;
      uint64_t v30 = *(void *)(*(void *)(a1 + 456) + 24);
      if ((*(unsigned char *)(a1 + 432) & 4) != 0)
      {
        if (v30)
        {
          uint64_t v48 = nw_protocol_tcp_get_all_stats();
          if (v48) {
            *(_DWORD *)(v48 + 88) = *(_DWORD *)(a1 + 388);
          }
        }
      }
      else if (v30)
      {
        uint64_t v31 = nw_protocol_tcp_get_all_stats();
        if (v31) {
          *(_DWORD *)(v31 + 100) = *(_DWORD *)(a1 + 388);
        }
      }
      return 55;
    }
    *(_DWORD *)(a1 + 492) = v15;
    uint64_t v32 = *(void *)(*(void *)(a1 + 560) + 24);
    if ((*(unsigned char *)(a1 + 536) & 4) != 0)
    {
      if (v32)
      {
        uint64_t v49 = nw_protocol_tcp_get_all_stats();
        if (v49) {
          *(_DWORD *)(v49 + 88) = *(_DWORD *)(a1 + 492);
        }
      }
    }
    else if (v32)
    {
      uint64_t v33 = nw_protocol_tcp_get_all_stats();
      if (v33) {
        *(_DWORD *)(v33 + 100) = *(_DWORD *)(a1 + 492);
      }
    }
    unsigned int v50 = *(_DWORD *)(a1 + 496);
    unsigned int v51 = *(_DWORD *)(a1 + 492);
    if (v50 <= v51)
    {
      *(_DWORD *)(a1 + 540) = v15;
      if (!v50)
      {
LABEL_95:
        *(_DWORD *)(a1 + 496) = 1;
        unsigned int v52 = *(_DWORD *)(a1 + 392);
        if (v52) {
          goto LABEL_99;
        }
        goto LABEL_96;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 496) = v51;
      *(_DWORD *)(a1 + 540) = v15;
      if (!v51) {
        goto LABEL_95;
      }
    }
    unsigned int v52 = *(_DWORD *)(a1 + 392);
    if (v52)
    {
LABEL_99:
      unsigned int v53 = *(_DWORD *)(a1 + 388);
      if (v52 > v53) {
        *(_DWORD *)(a1 + 392) = v53;
      }
      goto LABEL_7;
    }
LABEL_96:
    unsigned int v52 = 2048;
    *(_DWORD *)(a1 + 392) = 2048;
    goto LABEL_99;
  }
LABEL_7:
  if (*(_DWORD *)(a1 + 484))
  {
    int v11 = *(_DWORD *)(a1 + 536);
    if ((v11 & 0x200) == 0) {
      goto LABEL_9;
    }
LABEL_18:
    int v12 = *(_DWORD *)(a1 + 432);
    if ((v12 & 0x200) != 0) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  *(_DWORD *)(a1 + 484) = 2048;
  *(_DWORD *)(a1 + 588) = 2048;
  int v11 = *(_DWORD *)(a1 + 536);
  if ((v11 & 0x200) != 0) {
    goto LABEL_18;
  }
LABEL_9:
  *(_DWORD *)(a1 + 536) = v11 | 0x400;
  int v12 = *(_DWORD *)(a1 + 432);
  if ((v12 & 0x200) == 0) {
LABEL_19:
  }
    *(_DWORD *)(a1 + 432) = v12 | 0x400;
LABEL_20:
  char v18 = *(unsigned char *)(v10 + 2236);
  if (v2 == 30) {
    char v19 = 2;
  }
  else {
    char v19 = 1;
  }
  char v20 = v18 | v19;
  *(unsigned char *)(v10 + 2236) = v18 | v19;
  uint64_t v21 = nw_tcp_access_globals(*(void *)(v10 + 224));
  calculate_tcp_clock(v21);
  *(_DWORD *)(v10 + 4104) = 0;
  *(void *)(v10 + 2240) = 0;
  uint64_t v22 = (_DWORD *)sysctls;
  uint64_t v23 = 152;
  if ((v20 & 2) == 0) {
    uint64_t v23 = 148;
  }
  int v24 = *(_DWORD *)(sysctls + v23);
  *(_DWORD *)(v10 + 2396) = v24;
  *(_DWORD *)(v10 + 2436) = v24;
  *(_DWORD *)(v10 + 2328) = 160;
  int v25 = *(_DWORD *)(v10 + 2980);
  int v26 = v25 | 0x20;
  *(_DWORD *)(v10 + 2980) = v25 | 0x20;
  if (v22[83])
  {
    int v26 = v25 | 0x20000020;
    *(_DWORD *)(v10 + 2980) = v25 | 0x20000020;
  }
  *(void *)(v10 + 2784) = 0;
  *(void *)(v10 + 2792) = v10 + 2784;
  *(void *)(v10 + 3192) = 0;
  *(void *)(v10 + 4224) = 0;
  *(void *)(v10 + 4232) = v10 + 4224;
  *(_OWORD *)(v10 + 4240) = 0u;
  *(void *)(v10 + 4256) = v10 + 4248;
  *(void *)(v10 + 4264) = 0;
  *(void *)(v10 + 4272) = v10 + 4264;
  *(void *)(v10 + 3272) = 0;
  *(void *)(v10 + 2320) = v10;
  *(_OWORD *)(v10 + 2440) = xmmword_2146B2940;
  *(_DWORD *)(v10 + 2468) = v22[43];
  *(_DWORD *)(v10 + 2432) = 1000;
  if (v22[5])
  {
    int v27 = 1;
    *(unsigned char *)(v10 + 2504) = 1;
  }
  else
  {
    if (v22[76])
    {
      int v27 = 2;
    }
    else if ((v26 & 0x10000000) != 0 || (int v27 = 4, (v26 & 0x8000000) == 0) && v22[84] != 1 && tcp_do_l4s != 1)
    {
      int v27 = 3;
    }
    *(unsigned char *)(v10 + 2504) = v27;
    if (!*(void *)(v10 + 3080))
    {
      *(void *)(v10 + 3080) = v10 + 3088;
      *(_OWORD *)(v10 + 3088) = 0u;
      *(_OWORD *)(v10 + 3104) = 0u;
      *(_OWORD *)(v10 + 3120) = 0u;
      *(_OWORD *)(v10 + 3136) = 0u;
      *(_OWORD *)(v10 + 3152) = 0u;
    }
  }
  int v34 = *(void (**)(uint64_t))(tcp_cc_algo_list[v27] + 24);
  if (v34)
  {
    v34(v10 + 2240);
    uint64_t v22 = (_DWORD *)sysctls;
  }
  if (v22[77] == 1 && (v22[10] == 1 || (*(unsigned char *)(*(void *)(v10 + 224) + 369) & 0x40) != 0) && off_26AA46348)
  {
    off_26AA46348(v10 + 2240);
    uint64_t v22 = (_DWORD *)sysctls;
  }
  int v35 = v22[76];
  if (v35)
  {
    int v36 = v22[4];
LABEL_63:
    int v37 = *(_DWORD *)(v10 + 2436) * v36;
    goto LABEL_64;
  }
  if (v22[69])
  {
    int v36 = 10;
    goto LABEL_63;
  }
  int v37 = 4380;
LABEL_64:
  *(_DWORD *)(v10 + 2384) = v37;
  *(_DWORD *)(v10 + 2388) = 1073725440;
  *(_DWORD *)(v10 + 2748) = 1073725440;
  int v38 = *(_DWORD *)(v21 + 316);
  *(_DWORD *)(v10 + 2400) = v38;
  *(_DWORD *)(v10 + 2304) = v38;
  *(_DWORD *)(v10 + 2564) = v38;
  *(_DWORD *)(v10 + 2552) = v22[52];
  *(_DWORD *)(v10 + 2556) = 0;
  int v39 = *(_DWORD *)(v10 + 2980);
  *(unsigned char *)(v10 + 2550) = 3;
  *(unsigned char *)(v10 + 4308) = 1;
  *(_DWORD *)(v10 + 2420) = v38;
  if (v35)
  {
    int v40 = v22[4];
    int v41 = *(_DWORD *)(v10 + 2436);
  }
  else
  {
    int v42 = v22[69];
    int v41 = *(_DWORD *)(v10 + 2436);
    if (!v42)
    {
      int v43 = 4380;
      goto LABEL_69;
    }
    int v40 = 10;
  }
  int v43 = v41 * v40;
LABEL_69:
  unsigned int __buf = 0;
  *(_DWORD *)(v10 + 2428) = v43;
  *(_WORD *)(v10 + 2548) = 16;
  *(_DWORD *)(v10 + 4320) = 0;
  *(void *)(v10 + 4312) = 0;
  *(_OWORD *)(v10 + 3016) = 0u;
  *(_OWORD *)(v10 + 3032) = 0u;
  *(void *)(v10 + 3048) = 0;
  *(void *)(v10 + 3008) = v10 + 3016;
  *(_DWORD *)(v10 + 3028) = 6;
  *(_DWORD *)(v10 + 3036) = 6 * v41;
  *(_DWORD *)(v10 + 2980) = v39 | 0xA;
  *(_OWORD *)(v10 + 3064) = 0u;
  arc4random_buf(&__buf, 4uLL);
  unsigned int v44 = __buf;
  if (__buf <= 1) {
    int v45 = 1;
  }
  else {
    int v45 = __buf;
  }
  *(_DWORD *)(v10 + 4116) = v45;
  *(_DWORD *)(v10 + 4120) = *(_DWORD *)(v21 + 316);
  if (*(_DWORD *)(sysctls + 296)) {
    *(_DWORD *)(v10 + 4128) = v44;
  }
  *(void *)(v10 + 2600) = 0x100000001;
  *(void *)(v10 + 2872) = 0;
  *(void *)(v10 + 2880) = v10 + 2872;
  *(_DWORD *)(v10 + 2888) = 0;
  *(_DWORD *)(v10 + 2540) = 0;
  *(unsigned char *)(v10 + 2237) = 64;
  *(void *)(v10 + 240) = v10 + 2240;
  *(void *)(v10 + 3312) = 680;
  *(void *)(v10 + 3328) = 0;
  *(void *)(v10 + 3320) = 0;
  *(_DWORD *)(v10 + 2252) = 0;
  if (*(void *)(a1 + 24))
  {
    uint64_t v46 = nw_protocol_tcp_get_all_stats();
    if (v46) {
      *(_DWORD *)(v46 + 132) = *(unsigned __int8 *)(v10 + 2504);
    }
    if (*(void *)(a1 + 24))
    {
      uint64_t v47 = nw_protocol_tcp_get_all_stats();
      if (v47) {
        *(_DWORD *)(v47 + 136) = 0;
      }
    }
  }
  if ((*(unsigned char *)(a1 + 372) & 0x80) == 0 || *(_DWORD *)(a1 + 16)) {
    return 0;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 16) = 120000;
  return result;
}

void sbdrop(int *a1, int a2)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  if (*((void *)a1 + 4))
  {
    uint64_t v4 = *((void *)a1 + 9);
    if (tcp_perf_measurement)
    {
      if (!v4 || (*(unsigned char *)(v4 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          uint64_t v5 = __nwlog_tcp_log();
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v6 = "";
            if (v4) {
              uint64_t v6 = (const char *)(v4 + 604);
            }
            *(_DWORD *)buf = 136446466;
            int v36 = "sbdrop";
            __int16 v37 = 2082;
            *(void *)int v38 = v6;
            int64x2_t v7 = v5;
            os_log_type_t v8 = OS_LOG_TYPE_DEBUG;
LABEL_16:
            _os_log_impl(&dword_214653000, v7, v8, "%{public}s %{public}s sb_mb_aggregate not empty", buf, 0x16u);
          }
        }
      }
    }
    else if (!v4 || (*(unsigned char *)(v4 + 828) & 2) == 0)
    {
      uint64_t v9 = __nwlog_tcp_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        uint64_t v10 = "";
        if (v4) {
          uint64_t v10 = (const char *)(v4 + 604);
        }
        *(_DWORD *)buf = 136446466;
        int v36 = "sbdrop";
        __int16 v37 = 2082;
        *(void *)int v38 = v10;
        int64x2_t v7 = v9;
        os_log_type_t v8 = OS_LOG_TYPE_INFO;
        goto LABEL_16;
      }
    }
  }
  if ((a2 & 0x80000000) == 0)
  {
    while (1)
    {
      uint64_t v11 = *((void *)a1 + 2);
      if (!v11) {
        break;
      }
      int v12 = *(_DWORD *)(v11 + 52);
      if (v12)
      {
        int v13 = *(_DWORD *)(v11 + 56);
        int v14 = *(_DWORD *)(v11 + 60);
        if (v12 - (v13 + v14) > a2)
        {
          if ((*(_WORD *)(v11 + 204) & 0x80) != 0) {
            *(_WORD *)(v11 + 196) -= a2;
          }
          int v28 = v13 + a2;
          if (v13 + a2 <= (v12 - v14))
          {
            *(_DWORD *)(v11 + 56) = v28;
          }
          else
          {
            unsigned int v29 = __nwlog_obj();
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            {
              int v30 = *(_DWORD *)(v11 + 52);
              *(_DWORD *)buf = 136446978;
              int v36 = "__nw_frame_claim_internal";
              __int16 v37 = 1024;
              *(_DWORD *)int v38 = v28;
              *(_WORD *)&v38[4] = 1024;
              *(_DWORD *)&v38[6] = v30;
              *(_WORD *)int v39 = 1024;
              *(_DWORD *)&v39[2] = v14;
              _os_log_impl(&dword_214653000, v29, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
            }
          }
          *a1 -= a2;
          goto LABEL_58;
        }
        int v15 = v13 - v12 + v14;
      }
      else
      {
        int v15 = 0;
      }
      *a1 += v15;
      uint64_t v16 = *(void *)(*((void *)a1 + 9) + 24);
      if ((a1[12] & 4) != 0)
      {
        if (v16)
        {
          uint64_t all_stats = nw_protocol_tcp_get_all_stats();
          if (all_stats) {
            *(_DWORD *)(all_stats + 92) = *a1;
          }
        }
      }
      else if (v16)
      {
        uint64_t v17 = nw_protocol_tcp_get_all_stats();
        if (v17) {
          *(_DWORD *)(v17 + 104) = *a1;
        }
      }
      uint64_t v19 = *(void *)(v11 + 32);
      char v20 = *(void **)(v11 + 40);
      if (v19)
      {
        *(void *)(v19 + 40) = v20;
        char v20 = *(void **)(v11 + 40);
      }
      else
      {
        *((void *)a1 + 3) = v20;
      }
      a2 += v15;
      *char v20 = v19;
      uint64_t v21 = *(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 80);
      *(void *)(v11 + 32) = 0;
      *(void *)(v11 + 40) = 0;
      if (v21)
      {
        uint64_t v22 = *(void *)(v11 + 88);
        *(void *)(v11 + 80) = 0;
        *(void *)(v11 + 88) = 0;
        v21(v11, 1, v22);
        if (a2 < 0) {
          goto LABEL_58;
        }
      }
      else
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        int v36 = "__nw_frame_finalize";
        uint64_t v23 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          log = __nwlog_obj();
          if (os_log_type_enabled(log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            int v36 = "__nw_frame_finalize";
            _os_log_impl(&dword_214653000, log, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
          }
        }
        if (v23) {
          free(v23);
        }
        if (a2 < 0) {
          goto LABEL_58;
        }
      }
    }
    if (*a1)
    {
      uint64_t v24 = *((void *)a1 + 9);
      if (!v24 || (*(unsigned char *)(v24 + 828) & 2) == 0)
      {
        int v25 = __nwlog_tcp_log();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          int v26 = (const char *)(v24 + 604);
          int v27 = *a1;
          int v36 = "sbdrop";
          *(_DWORD *)buf = 136446978;
          if (!v24) {
            int v26 = "";
          }
          __int16 v37 = 2082;
          *(void *)int v38 = v26;
          *(_WORD *)&v38[8] = 1024;
          *(_DWORD *)int v39 = a2;
          *(_WORD *)&v39[4] = 1024;
          int v40 = v27;
          _os_log_impl(&dword_214653000, v25, OS_LOG_TYPE_ERROR, "%{public}s %{public}s sbdrop - count not zero: len %d sb_cc %u", buf, 0x22u);
        }
      }
      *a1 = 0;
    }
  }
LABEL_58:
  uint64_t v31 = *(void *)(*((void *)a1 + 9) + 24);
  if ((a1[12] & 4) != 0)
  {
    if (v31)
    {
      uint64_t v33 = nw_protocol_tcp_get_all_stats();
      if (v33) {
        *(_DWORD *)(v33 + 92) = *a1;
      }
    }
  }
  else
  {
    if (v31)
    {
      uint64_t v32 = nw_protocol_tcp_get_all_stats();
      if (v32) {
        *(_DWORD *)(v32 + 104) = *a1;
      }
    }
    nw_protocol_tcp_update_metadata(*(void *)(*((void *)a1 + 9) + 24));
  }
}

void nw_frame_tcp_finalize(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v74 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if ((*(_WORD *)(a1 + 204) & 4) == 0)
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446466;
      unsigned int v69 = "nw_frame_tcp_finalize";
      __int16 v70 = 2048;
      *(void *)char v71 = 0;
      uint64_t v6 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort()) {
        goto LABEL_86;
      }
      free(v6);
    }
    if (!a3)
    {
      int64x2_t v7 = __nwlog_obj();
      os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446466;
      unsigned int v69 = "nw_frame_tcp_finalize";
      __int16 v70 = 2048;
      *(void *)char v71 = 0;
      os_log_type_t v8 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort()) {
        goto LABEL_86;
      }
      free(v8);
    }
    unsigned int v9 = *(unsigned __int8 *)(a1 + 208);
    int v10 = v9 & 1;
    if ((~v9 & 6) == 0 || (v9 & 5) == 5 || (v9 & 3) == 3)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446978;
      unsigned int v69 = "nw_frame_tcp_finalize";
      __int16 v70 = 1024;
      *(_DWORD *)char v71 = v9 & 1;
      *(_WORD *)&v71[4] = 1024;
      *(_DWORD *)&v71[6] = (v9 >> 1) & 1;
      __int16 v72 = 1024;
      int v73 = (v9 >> 2) & 1;
      int v12 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort()) {
        goto LABEL_86;
      }
      free(v12);
    }
    unsigned int v13 = v9 & 4;
    unsigned int v14 = v9 & 2;
    if (v14)
    {
      if ((*(_WORD *)(a1 + 204) & 2) != 0)
      {
        uint64_t v33 = *(void **)(a1 + 96);
        if (v33)
        {
          nw_release(v33);
          *(void *)(a1 + 96) = 0;
        }
        *(_DWORD *)(a1 + 52) = 0;
        *(_DWORD *)(a1 + 56) = 0;
        *(_WORD *)(a1 + 196) = 0;
      }
      else
      {
        uint64_t v23 = __nwlog_obj();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          unsigned int v69 = "__nw_frame_set_external_data";
          _os_log_impl(&dword_214653000, v23, OS_LOG_TYPE_ERROR, "%{public}s Frame does not use external data", buf, 0xCu);
        }
      }
      int v34 = a3 + 22;
      int v35 = a3 + 24;
      int v36 = a3 + 2;
      goto LABEL_61;
    }
    if (!v10)
    {
      if (!v13)
      {
LABEL_56:
        int v34 = a3 + 18;
        int v35 = a3 + 20;
        int v36 = a3 + 1;
LABEL_61:
        uint64_t v40 = *(void *)(a1 + 16);
        uint64_t v41 = *(void **)(a1 + 24);
        int v39 = (void *)(a1 + 16);
        if (v40)
        {
          *(void *)(v40 + 24) = v41;
          uint64_t v41 = *(void **)(a1 + 24);
        }
        else
        {
          v35[1] = v41;
        }
        *uint64_t v41 = v40;
        *int v39 = 0;
        *(void *)(a1 + 24) = 0;
        int v42 = (void *)v34[1];
        *(void *)(a1 + 24) = v42;
        *int v42 = a1;
        v34[1] = v39;
        uint64_t v43 = *v36;
        if ((*v36 & 0x8000000000000000) == 0)
        {
LABEL_65:
          *int v36 = v43 + 1;
          if (v43 >= 100)
          {
            v58[0] = MEMORY[0x263EF8330];
            v58[1] = 0x40000000;
            int v59 = __nw_frame_tcp_finalize_block_invoke;
            uint64_t v60 = &__block_descriptor_tmp_2;
            __int16 v61 = v36;
            char v62 = v34;
            char v63 = v14 >> 1;
            char v64 = v13 >> 2;
            char v65 = v10;
            uint64_t v44 = *v34;
            do
            {
              if (!v44) {
                break;
              }
              uint64_t v45 = *(void *)(v44 + 16);
              char v46 = ((uint64_t (*)(void *))v59)(v58);
              uint64_t v44 = v45;
            }
            while ((v46 & 1) != 0);
          }
          return;
        }
        unsigned int v51 = __nwlog_obj();
        os_log_type_enabled(v51, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        unsigned int v69 = "nw_frame_tcp_finalize";
        unsigned int v52 = (void *)_os_log_send_and_compose_impl();
        if (!__nwlog_abort())
        {
          free(v52);
          uint64_t v43 = *v36;
          goto LABEL_65;
        }
LABEL_86:
        __break(1u);
      }
      if ((*(_WORD *)(a1 + 204) & 0x100) == 0
        || !*MEMORY[0x263F144B8]
        || ((unsigned int (*)(uint64_t, void))*MEMORY[0x263F144B8])(a1, *(void *)(a1 + 88)))
      {
        int v15 = *(void **)(a1 + 112);
        if (v15) {
          free(v15);
        }
      }
      int v16 = *(unsigned __int16 *)(a1 + 204);
      *(_WORD *)(a1 + 196) = 0;
      *(_DWORD *)(a1 + 192) = 0;
      *(unsigned char *)(a1 + 200) = 0;
      *(void *)(a1 + 56) = 0;
      *(void *)(a1 + 48) = 0;
      *(void *)(a1 + 88) = 0;
      *(void *)(a1 + 80) = 0;
      *(void *)(a1 + 112) = 0;
      *(void *)(a1 + 104) = 0;
      unsigned int v17 = v16 & 0xFFFFFFC7 | (*(unsigned __int8 *)(a1 + 206) << 16);
      *(_WORD *)(a1 + 204) = v17;
      *(unsigned char *)(a1 + 206) = BYTE2(v17);
      char v18 = *(void **)(a1 + 64);
      if (v18)
      {
        do
        {
          uint64_t v19 = (void *)*v18;
          char v20 = (void *)v18[6];
          uint64_t v21 = (void *)*v18;
          if (v20)
          {
            nw_release(v20);
            v18[6] = 0;
            uint64_t v21 = (void *)*v18;
          }
          uint64_t v22 = (void *)v18[1];
          if (v21)
          {
            v21[1] = v22;
            uint64_t v22 = (void *)v18[1];
          }
          else
          {
            *(void *)(a1 + 72) = v22;
          }
          *uint64_t v22 = v21;
          if (v18 != (void *)(a1 + 120)) {
            free(v18);
          }
          char v18 = v19;
        }
        while (v19);
      }
      *(void *)(a1 + 64) = 0;
      *(void *)(a1 + 72) = a1 + 64;
      __int16 v37 = *(void **)(a1 + 168);
      if (!v37) {
        goto LABEL_55;
      }
      goto LABEL_54;
    }
    uint64_t v24 = *(void *)(a1 + 104);
    if ((*(_WORD *)(a1 + 204) & 0x100) != 0
      && *MEMORY[0x263F144B8]
      && !((unsigned int (*)(uint64_t, void))*MEMORY[0x263F144B8])(a1, *(void *)(a1 + 88)))
    {
      if (!v24) {
        goto LABEL_60;
      }
    }
    else
    {
      uint64_t v25 = *(void *)(a1 + 112);
      if (!v24)
      {
        if (v25)
        {
          int v56 = __nwlog_obj();
          os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446210;
          unsigned int v69 = "nw_frame_tcp_finalize";
          BOOL v57 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_abort()) {
            goto LABEL_86;
          }
          free(v57);
        }
        goto LABEL_60;
      }
      if (v25)
      {
LABEL_39:
        nw_mem_buffer_free();
        int v26 = *(unsigned __int16 *)(a1 + 204);
        *(_WORD *)(a1 + 196) = 0;
        *(_DWORD *)(a1 + 192) = 0;
        *(unsigned char *)(a1 + 200) = 0;
        *(void *)(a1 + 56) = 0;
        *(void *)(a1 + 48) = 0;
        *(void *)(a1 + 88) = 0;
        *(void *)(a1 + 80) = 0;
        *(void *)(a1 + 104) = 0;
        *(void *)(a1 + 112) = 0;
        unsigned int v27 = v26 & 0xFFFFFFC7 | (*(unsigned __int8 *)(a1 + 206) << 16);
        *(_WORD *)(a1 + 204) = v27;
        *(unsigned char *)(a1 + 206) = BYTE2(v27);
        int v28 = *(void **)(a1 + 64);
        if (v28)
        {
          do
          {
            unsigned int v29 = (void *)*v28;
            int v30 = (void *)v28[6];
            uint64_t v31 = (void *)*v28;
            if (v30)
            {
              nw_release(v30);
              v28[6] = 0;
              uint64_t v31 = (void *)*v28;
            }
            uint64_t v32 = (void *)v28[1];
            if (v31)
            {
              v31[1] = v32;
              uint64_t v32 = (void *)v28[1];
            }
            else
            {
              *(void *)(a1 + 72) = v32;
            }
            *uint64_t v32 = v31;
            if (v28 != (void *)(a1 + 120)) {
              free(v28);
            }
            int v28 = v29;
          }
          while (v29);
        }
        *(void *)(a1 + 64) = 0;
        *(void *)(a1 + 72) = a1 + 64;
        __int16 v37 = *(void **)(a1 + 168);
        if (!v37)
        {
LABEL_55:
          __int16 v38 = *(_WORD *)(a1 + 204);
          *(void *)(a1 + 184) = 0;
          *(_OWORD *)(a1 + 168) = 0u;
          *(_OWORD *)(a1 + 152) = 0u;
          *(_OWORD *)(a1 + 136) = 0u;
          *(_OWORD *)(a1 + 120) = 0u;
          *(_WORD *)(a1 + 204) = v38 & 0x213F;
          *(unsigned char *)(a1 + 203) = 0;
          *(_WORD *)(a1 + 198) = 0;
          if (!v10) {
            goto LABEL_56;
          }
LABEL_60:
          int v34 = a3 + 26;
          int v35 = a3 + 28;
          int v36 = a3 + 3;
          goto LABEL_61;
        }
LABEL_54:
        nw_release(v37);
        goto LABEL_55;
      }
    }
    int v53 = v10;
    uint64_t v54 = __nwlog_obj();
    os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    unsigned int v69 = "nw_frame_tcp_finalize";
    uint64_t v55 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort()) {
      goto LABEL_86;
    }
    free(v55);
    int v10 = v53;
    goto LABEL_39;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unsigned int v69 = "nw_frame_tcp_finalize";
  uint64_t v47 = (void *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v66 = 0;
  if (__nwlog_fault())
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v48 = __nwlog_obj();
      os_log_type_t v49 = type;
      if (!os_log_type_enabled(v48, type)) {
        goto LABEL_82;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v69 = "nw_frame_tcp_finalize";
      unsigned int v50 = "%{public}s called with null frame";
    }
    else
    {
      uint64_t v48 = __nwlog_obj();
      os_log_type_t v49 = type;
      if (!os_log_type_enabled(v48, type)) {
        goto LABEL_82;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v69 = "nw_frame_tcp_finalize";
      unsigned int v50 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_214653000, v48, v49, v50, buf, 0xCu);
  }
LABEL_82:
  if (v47) {
    free(v47);
  }
}

void tcp_xmit_timer(uint64_t a1, unsigned int a2, int a3, int a4)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  if (a2 <= 1) {
    unsigned int v7 = 1;
  }
  else {
    unsigned int v7 = a2;
  }
  if ((int)v7 >= 60001)
  {
    uint64_t v8 = *(void *)(*(void *)(a1 + 80) + 224);
    if (!v8 || (*(unsigned char *)(v8 + 828) & 2) == 0)
    {
      unsigned int v9 = __nwlog_tcp_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        int v10 = (const char *)(v8 + 604);
        int v42 = "tcp_xmit_timer";
        int v41 = 136446722;
        if (!v8) {
          int v10 = "";
        }
        __int16 v43 = 2082;
        uint64_t v44 = v10;
        __int16 v45 = 1024;
        unsigned int v46 = v7;
        _os_log_impl(&dword_214653000, v9, OS_LOG_TYPE_INFO, "%{public}s %{public}s rtt is %d - maxing it at 4 x MSL\n", (uint8_t *)&v41, 0x1Cu);
      }
    }
    unsigned int v7 = 60000;
  }
  uint64_t v11 = *(void *)(*(void *)(a1 + 80) + 448);
  if (!v11 || (*(unsigned char *)(v11 + 1054) & 0x10) == 0 || *(_DWORD *)(a1 + 112) + 1 != a4)
  {
    int v12 = *(_DWORD *)(a1 + 740);
    if ((v12 & 0x40) == 0)
    {
      uint64_t v13 = *(void *)(a1 + 1056);
      if (v13) {
        ++*(void *)(v13 + 464);
      }
      int v14 = *(_DWORD *)(a1 + 240) + 1;
      *(_DWORD *)(a1 + 236) = v7;
      *(_DWORD *)(a1 + 240) = v14;
      update_base_rtt(a1, v7);
      int v15 = *(_DWORD *)(a1 + 200);
      if (v15)
      {
        int v16 = 4 * v7 - (v15 >> 3);
        int v17 = v16 + v15;
        if (v17 <= 1) {
          int v17 = 1;
        }
        *(_DWORD *)(a1 + 200) = v17;
        if (v16 < 0) {
          int v16 = -v16;
        }
        int v18 = *(_DWORD *)(a1 + 208) + v16 - (*(int *)(a1 + 208) >> 2);
        if (v18 <= 1) {
          int v19 = 1;
        }
        else {
          int v19 = v18;
        }
        *(_DWORD *)(a1 + 208) = v19;
        int v20 = *(_DWORD *)(a1 + 232);
        int v21 = v19 + v17;
        if (!v20 || v20 > v21) {
          *(_DWORD *)(a1 + 232) = v21;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 200) = 32 * v7;
        *(_DWORD *)(a1 + 208) = 8 * v7;
        *(_DWORD *)(a1 + 232) = 40 * v7;
        if (!*(_DWORD *)(a1 + 1968)) {
          *(_DWORD *)(a1 + 1968) = 32 * v7;
        }
      }
      if ((*(_DWORD *)(a1 + 1872) & 0xFFFFFFFE) == 2)
      {
        int v29 = *(_DWORD *)(a1 + 204);
        if (v29)
        {
          int v30 = 4 * v7 - (v29 >> 3);
          int v31 = v30 + v29;
          if (v31 <= 1) {
            int v31 = 1;
          }
          *(_DWORD *)(a1 + 204) = v31;
          if (v30 >= 0) {
            int v32 = v30;
          }
          else {
            int v32 = -v30;
          }
          int v33 = *(_DWORD *)(a1 + 212) + v32 - (*(int *)(a1 + 212) >> 2);
          if (v33 <= 1) {
            int v33 = 1;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 204) = 32 * v7;
          int v33 = 8 * v7;
        }
        *(_DWORD *)(a1 + 212) = v33;
      }
      goto LABEL_59;
    }
    if (a4 - *(_DWORD *)(a1 + 92) >= 1 && a4 - *(_DWORD *)(a1 + 96) <= 0 && (!a3 || a3 - *(_DWORD *)(a1 + 532) >= 0))
    {
      *(_DWORD *)(a1 + 740) = v12 & 0xFFFFFFBF;
      *(_DWORD *)(a1 + 532) = 0;
      uint64_t v22 = *(int *)(a1 + 516);
      if (v22 <= v7) {
        LODWORD(v22) = v7;
      }
      int v23 = 32 * v22;
      *(_DWORD *)(a1 + 200) = v23;
      signed int v24 = *(_DWORD *)(a1 + 524);
      if (v24 <= (int)(v7 >> 1)) {
        signed int v24 = v7 >> 1;
      }
      int v25 = 16 * v24;
      *(_DWORD *)(a1 + 208) = v25;
      if ((*(_DWORD *)(a1 + 1872) & 0xFFFFFFFE) == 2)
      {
        if (*(int *)(a1 + 520) <= (uint64_t)v7) {
          unsigned int v26 = v7;
        }
        else {
          unsigned int v26 = *(_DWORD *)(a1 + 520);
        }
        *(_DWORD *)(a1 + 204) = 32 * v26;
        signed int v27 = *(_DWORD *)(a1 + 528);
        if (v27 <= (int)(v7 >> 1)) {
          signed int v27 = v7 >> 1;
        }
        *(_DWORD *)(a1 + 212) = 16 * v27;
      }
      int v28 = v23 + v25;
      if (*(_DWORD *)(a1 + 232) > v28) {
        *(_DWORD *)(a1 + 232) = v28;
      }
LABEL_59:
      if (*(void *)(*(void *)(*(void *)(a1 + 80) + 224) + 24))
      {
        uint64_t all_stats = nw_protocol_tcp_get_all_stats();
        if (all_stats) {
          *(_DWORD *)(all_stats + 68) = *(_DWORD *)(a1 + 232);
        }
      }
      if (*(void *)(*(void *)(*(void *)(a1 + 80) + 224) + 24))
      {
        uint64_t v35 = nw_protocol_tcp_get_all_stats();
        if (v35) {
          *(_DWORD *)(v35 + 72) = *(_DWORD *)(a1 + 200);
        }
      }
      if (*(void *)(*(void *)(*(void *)(a1 + 80) + 224) + 24))
      {
        uint64_t v36 = nw_protocol_tcp_get_all_stats();
        if (v36) {
          *(_DWORD *)(v36 + 76) = *(_DWORD *)(a1 + 208);
        }
      }
      if (*(int *)(a1 + 12) < 4) {
        int v37 = 0;
      }
      else {
        int v37 = *(_DWORD *)(sysctls + 176);
      }
      unint64_t v38 = *(unsigned int *)(a1 + 228);
      int v39 = (*(_DWORD *)(a1 + 208) + (*(int *)(a1 + 200) >> 3)) >> 2;
      if ((uint64_t)v38 > v39) {
        int v39 = *(_DWORD *)(a1 + 228);
      }
      unsigned int v40 = v39 + v37;
      *(_DWORD *)(a1 + 192) = v40;
      if ((unint64_t)v7 + 2 >= v38) {
        LODWORD(v38) = v7 + 2;
      }
      if (v40 >= v38)
      {
        if (v40 < 0xFA01)
        {
LABEL_79:
          *(_DWORD *)(a1 + 256) = 0;
          return;
        }
        LODWORD(v38) = 64000;
      }
      *(_DWORD *)(a1 + 192) = v38;
      goto LABEL_79;
    }
  }
}

void *tcp_input_sbappendstream(uint64_t a1, uint64_t *a2, signed int a3, char a4)
{
  uint64_t v67 = *MEMORY[0x263EF8340];
  uint64_t v8 = *a2;
  if (*a2)
  {
    int v9 = 0;
    uint64_t v10 = *a2;
    do
    {
      int v11 = *(_DWORD *)(v10 + 52);
      if (v11) {
        v11 -= *(_DWORD *)(v10 + 56) + *(_DWORD *)(v10 + 60);
      }
      v9 += v11;
      uint64_t v10 = *(void *)(v10 + 32);
    }
    while (v10);
  }
  else
  {
    int v9 = 0;
  }
  if (v9 != a3 && (!a1 || (*(unsigned char *)(a1 + 828) & 2) == 0))
  {
    __nwlog_tcp_log();
    if (a1) {
      int v12 = (const char *)(a1 + 604);
    }
    else {
      int v12 = "";
    }
    uint64_t v13 = *a2;
    if (*a2)
    {
      int v14 = 0;
      do
      {
        int v15 = *(_DWORD *)(v13 + 52);
        if (v15) {
          v15 -= *(_DWORD *)(v13 + 56) + *(_DWORD *)(v13 + 60);
        }
        v14 += v15;
        uint64_t v13 = *(void *)(v13 + 32);
      }
      while (v13);
    }
    else
    {
      int v14 = 0;
    }
    *(_DWORD *)buf = 136446978;
    uint64_t v60 = "tcp_input_sbappendstream";
    __int16 v61 = 2082;
    char v62 = v12;
    __int16 v63 = 1024;
    signed int v64 = a3;
    __int16 v65 = 1024;
    int v66 = v14;
    int v16 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v58 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault()) {
      goto LABEL_38;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v17 = __nwlog_tcp_log();
      os_log_type_t v18 = type[0];
      if (os_log_type_enabled(v17, type[0]))
      {
        uint64_t v19 = *a2;
        if (*a2)
        {
          int v20 = 0;
          do
          {
            int v21 = *(_DWORD *)(v19 + 52);
            if (v21) {
              v21 -= *(_DWORD *)(v19 + 56) + *(_DWORD *)(v19 + 60);
            }
            v20 += v21;
            uint64_t v19 = *(void *)(v19 + 32);
          }
          while (v19);
        }
        else
        {
          int v20 = 0;
        }
        *(_DWORD *)buf = 136446978;
        uint64_t v60 = "tcp_input_sbappendstream";
        __int16 v61 = 2082;
        char v62 = v12;
        __int16 v63 = 1024;
        signed int v64 = a3;
        __int16 v65 = 1024;
        int v66 = v20;
        int v25 = "%{public}s %{public}s tlen %d != __nw_frame_array_unclaimed_length() %u";
LABEL_37:
        _os_log_impl(&dword_214653000, v17, v18, v25, buf, 0x22u);
      }
    }
    else
    {
      int v17 = __nwlog_tcp_log();
      os_log_type_t v18 = type[0];
      if (os_log_type_enabled(v17, type[0]))
      {
        uint64_t v22 = *a2;
        if (*a2)
        {
          int v23 = 0;
          do
          {
            int v24 = *(_DWORD *)(v22 + 52);
            if (v24) {
              v24 -= *(_DWORD *)(v22 + 56) + *(_DWORD *)(v22 + 60);
            }
            v23 += v24;
            uint64_t v22 = *(void *)(v22 + 32);
          }
          while (v22);
        }
        else
        {
          int v23 = 0;
        }
        *(_DWORD *)buf = 136446978;
        uint64_t v60 = "tcp_input_sbappendstream";
        __int16 v61 = 2082;
        char v62 = v12;
        __int16 v63 = 1024;
        signed int v64 = a3;
        __int16 v65 = 1024;
        int v66 = v23;
        int v25 = "%{public}s %{public}s tlen %d != __nw_frame_array_unclaimed_length() %u, backtrace limit exceeded";
        goto LABEL_37;
      }
    }
LABEL_38:
    if (v16) {
      free(v16);
    }
    uint64_t v8 = *a2;
  }
  *(void *)os_log_type_t type = 0;
  int v56 = type;
  if ((a4 & 2) != 0 && !*(_DWORD *)(a1 + 824))
  {
    uint64_t v26 = nw_protocol_tcp_copy_frame(a1, v8, a3);
    if (v26)
    {
      a4 &= ~2u;
      *(void *)(v26 + 32) = 0;
      signed int v27 = v56;
      *(void *)(v26 + 40) = v56;
      void *v27 = v26;
      int v56 = (os_log_type_t *)(v26 + 32);
      goto LABEL_47;
    }
    uint64_t v39 = *(void *)(*(void *)a1 + 240);
    if ((*(unsigned char *)(a1 + 828) & 2) == 0)
    {
      unsigned int v40 = __nwlog_tcp_log();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v60 = "tcp_input_sbappendstream";
        __int16 v61 = 2082;
        char v62 = (const char *)(a1 + 604);
        _os_log_impl(&dword_214653000, v40, OS_LOG_TYPE_ERROR, "%{public}s %{public}s nw_protocol_tcp_copy_frame failed", buf, 0x16u);
      }
    }
    if (v8)
    {
      if ((*(_WORD *)(v8 + 204) & 0x100) == 0
        || !*MEMORY[0x263F144B8]
        || (((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(v8, *(void *)(v8 + 88)) & 1) != 0)
      {
        goto LABEL_79;
      }
      goto LABEL_78;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v60 = "__nw_frame_check_validity";
    int v41 = (void *)_os_log_send_and_compose_impl();
    os_log_type_t v58 = OS_LOG_TYPE_ERROR;
    char v57 = 0;
    if (__nwlog_fault())
    {
      if (v58 == OS_LOG_TYPE_FAULT)
      {
        int v42 = __nwlog_obj();
        os_log_type_t v43 = v58;
        if (!os_log_type_enabled(v42, v58)) {
          goto LABEL_94;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v60 = "__nw_frame_check_validity";
        uint64_t v44 = "%{public}s called with null frame";
        goto LABEL_93;
      }
      if (!v57)
      {
        int v42 = __nwlog_obj();
        os_log_type_t v43 = v58;
        if (!os_log_type_enabled(v42, v58)) {
          goto LABEL_94;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v60 = "__nw_frame_check_validity";
        uint64_t v44 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_93;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v42 = __nwlog_obj();
      os_log_type_t v43 = v58;
      BOOL v46 = os_log_type_enabled(v42, v58);
      if (backtrace_string)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v60 = "__nw_frame_check_validity";
          __int16 v61 = 2082;
          char v62 = backtrace_string;
          _os_log_impl(&dword_214653000, v42, v43, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_94;
      }
      if (v46)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v60 = "__nw_frame_check_validity";
        uint64_t v44 = "%{public}s called with null frame, no backtrace";
LABEL_93:
        _os_log_impl(&dword_214653000, v42, v43, v44, buf, 0xCu);
      }
    }
LABEL_94:
    if (v41) {
      free(v41);
    }
LABEL_78:
    *(void *)(v39 + 1056) = 0;
LABEL_79:
    tcp_drop(v39, 53);
    return 0;
  }
  if (v8)
  {
    *(void *)(v8 + 40) = type;
    int v28 = (os_log_type_t *)a2[1];
    *(void *)os_log_type_t type = v8;
    int v56 = v28;
    *a2 = 0;
    a2[1] = (uint64_t)a2;
  }
LABEL_47:
  if (a3 > 0) {
    return (void *)sbappendstream((int *)(a1 + 488), (uint64_t *)type, a3, a4);
  }
  uint64_t result = *(void **)type;
  if (*(void *)type)
  {
    while (1)
    {
      int v30 = (void (*)(void *, uint64_t, uint64_t))result[10];
      int v31 = (void *)result[4];
      if (!v30) {
        break;
      }
      uint64_t v32 = result[11];
      result[10] = 0;
      result[11] = 0;
      v30(result, 1, v32);
LABEL_53:
      uint64_t result = v31;
      if (!v31) {
        return result;
      }
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v60 = "__nw_frame_finalize";
    uint64_t v33 = _os_log_send_and_compose_impl();
    os_log_type_t v58 = OS_LOG_TYPE_ERROR;
    char v57 = 0;
    uint64_t v54 = (void *)v33;
    if (__nwlog_fault())
    {
      if (v58 == OS_LOG_TYPE_FAULT)
      {
        unsigned int v51 = __nwlog_obj();
        os_log_type_t log = v58;
        if (!os_log_type_enabled(v51, v58)) {
          goto LABEL_69;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v60 = "__nw_frame_finalize";
        int v34 = v51;
        os_log_type_t v35 = log;
        uint64_t v36 = "%{public}s called with null frame->finalizer";
        goto LABEL_68;
      }
      if (!v57)
      {
        int v53 = __nwlog_obj();
        os_log_type_t logb = v58;
        if (!os_log_type_enabled(v53, v58)) {
          goto LABEL_69;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v60 = "__nw_frame_finalize";
        int v34 = v53;
        os_log_type_t v35 = logb;
        uint64_t v36 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
        goto LABEL_68;
      }
      unsigned int v52 = (void *)__nw_create_backtrace_string();
      loga = __nwlog_obj();
      os_log_type_t v47 = v58;
      BOOL v37 = os_log_type_enabled(loga, v58);
      unint64_t v38 = v52;
      if (v52)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v60 = "__nw_frame_finalize";
          __int16 v61 = 2082;
          char v62 = (const char *)v52;
          _os_log_impl(&dword_214653000, loga, v47, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
          unint64_t v38 = v52;
        }
        free(v38);
        goto LABEL_69;
      }
      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v60 = "__nw_frame_finalize";
        int v34 = loga;
        os_log_type_t v35 = v47;
        uint64_t v36 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_68:
        _os_log_impl(&dword_214653000, v34, v35, v36, buf, 0xCu);
      }
    }
LABEL_69:
    if (v54) {
      free(v54);
    }
    goto LABEL_53;
  }
  return result;
}

uint64_t sbappendstream(int *a1, uint64_t *a2, int a3, char a4)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  if (!a2) {
    return 0;
  }
  int v6 = a1[12];
  if ((v6 & 0x80) != 0)
  {
    uint64_t result = *a2;
    if (*a2)
    {
      do
      {
        int v12 = *(void (**)(uint64_t, uint64_t, uint64_t))(result + 80);
        uint64_t v13 = *(void *)(result + 32);
        if (v12)
        {
          uint64_t v14 = *(void *)(result + 88);
          *(void *)(result + 80) = 0;
          *(void *)(result + 88) = 0;
          v12(result, 1, v14);
        }
        else
        {
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          unint64_t v38 = "__nw_frame_finalize";
          uint64_t v36 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            os_log_type_t v35 = __nwlog_obj();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              unint64_t v38 = "__nw_frame_finalize";
              _os_log_impl(&dword_214653000, v35, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
            }
          }
          if (v36) {
            free(v36);
          }
        }
        uint64_t result = v13;
      }
      while (v13);
    }
    return result;
  }
  *a1 += a3;
  uint64_t v9 = *(void *)(*((void *)a1 + 9) + 24);
  if ((v6 & 4) != 0)
  {
    if (v9)
    {
      uint64_t all_stats = nw_protocol_tcp_get_all_stats();
      if (all_stats) {
        *(_DWORD *)(all_stats + 92) = *a1;
      }
    }
  }
  else if (v9)
  {
    uint64_t v10 = nw_protocol_tcp_get_all_stats();
    if (v10) {
      *(_DWORD *)(v10 + 104) = *a1;
    }
  }
  if ((a4 & 2) != 0)
  {
    if (*a2)
    {
      int v16 = 0;
      int v17 = 0;
      uint64_t v18 = *a2;
      do
      {
        int v19 = *(_DWORD *)(v18 + 52);
        if (v19) {
          v19 -= *(_DWORD *)(v18 + 56) + *(_DWORD *)(v18 + 60);
        }
        v16 += v19;
        ++v17;
        uint64_t v18 = *(void *)(v18 + 32);
      }
      while (v18);
      **((void **)a1 + 5) = *a2;
      *(void *)(*a2 + 40) = *((void *)a1 + 5);
      *((void *)a1 + 5) = a2[1];
      *a2 = 0;
      a2[1] = (uint64_t)a2;
      if (v16 == a3) {
        goto LABEL_30;
      }
    }
    else
    {
      int v16 = 0;
      int v17 = 0;
      if (!a3)
      {
LABEL_30:
        int v20 = a1[16] + a3;
        a1[15] += v17;
        a1[16] = v20;
        uint64_t v21 = *((void *)a1 + 9);
        if (v21 && (*(unsigned char *)(v21 + 828) & 2) != 0) {
          return 1;
        }
        if (!__nwlog_is_datapath_logging_enabled()) {
          return 1;
        }
        uint64_t v22 = __nwlog_tcp_log();
        if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
          return 1;
        }
        int v23 = (const char *)(v21 + 604);
        int v24 = a1[16];
        int v25 = *a1;
        if (!v21) {
          int v23 = "";
        }
        *(_DWORD *)buf = 136447490;
        unint64_t v38 = "sbcompress";
        __int16 v39 = 2082;
        *(void *)unsigned int v40 = v23;
        *(_WORD *)&v40[8] = 1024;
        int v41 = v17;
        __int16 v42 = 1024;
        int v43 = a3;
        __int16 v44 = 1024;
        int v45 = v24;
        __int16 v46 = 1024;
        int v47 = v25;
        uint64_t v26 = "%{public}s %{public}s append to aggregate frame count %u length %u sb_agg_bytes %u sb_cc %u";
        goto LABEL_58;
      }
    }
    int v31 = __nwlog_obj();
    uint64_t result = os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
    if (result) {
      goto LABEL_53;
    }
    return result;
  }
  if (*((void *)a1 + 4)
    && tcp_input_aggregate_end(*(void *)(**((void **)a1 + 9) + 224), *(void *)(**((void **)a1 + 9) + 240)))
  {
    return 0;
  }
  if (*a2)
  {
    int v16 = 0;
    int v27 = 0;
    uint64_t v28 = *a2;
    do
    {
      int v29 = *(_DWORD *)(v28 + 52);
      if (v29) {
        v29 -= *(_DWORD *)(v28 + 56) + *(_DWORD *)(v28 + 60);
      }
      v16 += v29;
      ++v27;
      uint64_t v28 = *(void *)(v28 + 32);
    }
    while (v28);
    **((void **)a1 + 3) = *a2;
    *(void *)(*a2 + 40) = *((void *)a1 + 3);
    *((void *)a1 + 3) = a2[1];
    *a2 = 0;
    a2[1] = (uint64_t)a2;
    if (v16 == a3) {
      goto LABEL_43;
    }
  }
  else
  {
    int v16 = 0;
    int v27 = 0;
    if (!a3)
    {
LABEL_43:
      uint64_t v30 = *((void *)a1 + 9);
      if (v30 && (*(unsigned char *)(v30 + 828) & 2) != 0) {
        return 1;
      }
      if (!__nwlog_is_datapath_logging_enabled()) {
        return 1;
      }
      uint64_t v22 = __nwlog_tcp_log();
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
        return 1;
      }
      uint64_t v32 = (const char *)(v30 + 604);
      int v33 = a1[16];
      int v34 = *a1;
      if (!v30) {
        uint64_t v32 = "";
      }
      *(_DWORD *)buf = 136447490;
      unint64_t v38 = "sbcompress";
      __int16 v39 = 2082;
      *(void *)unsigned int v40 = v32;
      *(_WORD *)&v40[8] = 1024;
      int v41 = v27;
      __int16 v42 = 1024;
      int v43 = a3;
      __int16 v44 = 1024;
      int v45 = v33;
      __int16 v46 = 1024;
      int v47 = v34;
      uint64_t v26 = "%{public}s %{public}s append frame count %u length %u sb_agg_bytes %u sb_cc %u";
LABEL_58:
      _os_log_impl(&dword_214653000, v22, OS_LOG_TYPE_DEBUG, v26, buf, 0x2Eu);
      return 1;
    }
  }
  int v31 = __nwlog_obj();
  uint64_t result = os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
  if (result)
  {
LABEL_53:
    *(_DWORD *)buf = 136446722;
    unint64_t v38 = "sbcompress";
    __int16 v39 = 1024;
    *(_DWORD *)unsigned int v40 = a3;
    *(_WORD *)&v40[4] = 1024;
    *(_DWORD *)&v40[6] = v16;
    _os_log_impl(&dword_214653000, v31, OS_LOG_TYPE_ERROR, "%{public}s len_added %u != len_to_add %u", buf, 0x18u);
    return 0;
  }
  return result;
}

uint64_t nw_protocol_tcp_get_all_stats()
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  uint64_t v0 = nw_protocol_downcast();
  if (!v0)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v5 = "nw_protocol_tcp_get_all_stats";
    uint64_t v1 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v2 = __nwlog_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v5 = "nw_protocol_tcp_get_all_stats";
        _os_log_impl(&dword_214653000, v2, OS_LOG_TYPE_ERROR, "%{public}s called with null tcp, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v1) {
      free(v1);
    }
    return 0;
  }
  if (!*(void *)(v0 + 5216)) {
    return 0;
  }

  return MEMORY[0x270EF8890]();
}

uint64_t __tcp_input_get_aggregate_frames_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v63 = *MEMORY[0x263EF8340];
  if (!a2)
  {
    uint64_t v9 = __nwlog_obj();
    os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    os_log_type_t v58 = "tcp_input_get_aggregate_frames_block_invoke";
    uint64_t v10 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if (result) {
      goto LABEL_95;
    }
    free(v10);
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v58 = "__nw_frame_unclaimed_bytes";
    int v12 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v13 = __nwlog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v58 = "__nw_frame_unclaimed_bytes";
        _os_log_impl(&dword_214653000, v13, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v12) {
      free(v12);
    }
    goto LABEL_17;
  }
  if (!*(void *)(a2 + 112)
    || (*(_WORD *)(a2 + 204) & 0x100) != 0
    && *MEMORY[0x263F144B8]
    && !((unsigned int (*)(uint64_t, void))*MEMORY[0x263F144B8])(a2, *(void *)(a2 + 88)))
  {
LABEL_17:
    unsigned int v6 = 0;
    goto LABEL_18;
  }
  int v5 = *(_DWORD *)(a2 + 52);
  uint64_t v4 = *(unsigned int *)(a2 + 56);
  if (v5)
  {
    unsigned int v6 = v5 - (v4 + *(_DWORD *)(a2 + 60));
    uint64_t v7 = *(void *)(a2 + 112);
    if (!v7)
    {
LABEL_18:
      uint64_t v14 = __nwlog_obj();
      os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      os_log_type_t v58 = "tcp_input_get_aggregate_frames_block_invoke";
      int v15 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = __nwlog_abort();
      if (!result)
      {
        free(v15);
        uint64_t v8 = 0;
        goto LABEL_20;
      }
LABEL_95:
      __break(1u);
      return result;
    }
  }
  else
  {
    unsigned int v6 = 0;
    uint64_t v7 = *(void *)(a2 + 112);
    if (!v7) {
      goto LABEL_18;
    }
  }
  uint64_t v8 = v7 + v4;
LABEL_20:
  *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = 0;
  int v16 = (void *)a1[7];
  uint64_t v17 = v16[65];
  if (!v17) {
    goto LABEL_77;
  }
  int v18 = 0;
  while (1)
  {
    if (*(_DWORD *)(*(void *)(a1[4] + 8) + 24) >= v6)
    {
LABEL_74:
      if ((v18 & 1) == 0) {
        goto LABEL_77;
      }
      goto LABEL_75;
    }
    int v19 = *(_DWORD *)(v17 + 52);
    unsigned int v20 = v19 ? v19 - (*(_DWORD *)(v17 + 56) + *(_DWORD *)(v17 + 60)) : 0;
    if (*(void *)(*v16 + 240))
    {
      uint64_t v21 = *(void *)(v17 + 112);
      if (v21
        && ((*(_WORD *)(v17 + 204) & 0x100) == 0
         || !*MEMORY[0x263F144B8]
         || ((unsigned int (*)(uint64_t, void))*MEMORY[0x263F144B8])(v17, *(void *)(v17 + 88))
         && (uint64_t v21 = *(void *)(v17 + 112)) != 0))
      {
        uint64_t v22 = (const void *)(v21 + *(unsigned int *)(v17 + 56));
      }
      else
      {
        uint64_t v22 = 0;
        if ((*(_WORD *)(v17 + 204) & 0x100) != 0)
        {
          if (*MEMORY[0x263F144B8])
          {
            uint64_t v22 = 0;
            if ((((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(v17, *(void *)(v17 + 88)) & 1) == 0) {
              *(void *)(*(void *)(*(void *)a1[7] + 240) + 1056) = 0;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v22 = 0;
    }
    v18 |= (unsigned __int16)(*(_WORD *)(v17 + 204) & 0x4000) >> 14;
    if (v20)
    {
      if (v22) {
        break;
      }
    }
    uint64_t v29 = a1[7];
    if (!v29 || (*(unsigned char *)(v29 + 828) & 2) == 0)
    {
      uint64_t v30 = __nwlog_tcp_log();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
      {
        int v31 = (const char *)(v29 + 604);
        *(_DWORD *)buf = 136446978;
        if (!v29) {
          int v31 = "";
        }
        os_log_type_t v58 = "tcp_input_get_aggregate_frames_block_invoke";
        __int16 v59 = 2082;
        *(void *)uint64_t v60 = v31;
        *(_WORD *)&v60[8] = 1024;
        *(_DWORD *)__int16 v61 = v20;
        *(_WORD *)&v61[4] = 2048;
        char v62 = v22;
        _os_log_impl(&dword_214653000, v30, OS_LOG_TYPE_INFO, "%{public}s %{public}s skipping empty input frame (length %u bytes %p)", buf, 0x26u);
      }
    }
    uint64_t v26 = a1[7];
    if (*(_DWORD *)(v26 + 552) < v20)
    {
      unsigned int v40 = __nwlog_obj();
      os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      os_log_type_t v58 = "tcp_input_get_aggregate_frames_block_invoke";
      int v41 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = __nwlog_abort();
      if (result) {
        goto LABEL_95;
      }
      free(v41);
      uint64_t v26 = a1[7];
    }
    unsigned int v27 = *(_DWORD *)(v26 + 488);
    if (v27 < v20)
    {
      __int16 v42 = __nwlog_obj();
      os_log_type_enabled(v42, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      os_log_type_t v58 = "tcp_input_get_aggregate_frames_block_invoke";
      int v43 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = __nwlog_abort();
      if (result) {
        goto LABEL_95;
      }
      free(v43);
      uint64_t v26 = a1[7];
      unsigned int v27 = *(_DWORD *)(v26 + 488);
    }
    uint64_t v28 = (_DWORD *)(v26 + 488);
    *(_DWORD *)(v26 + 552) -= v20;
LABEL_48:
    _DWORD *v28 = v27 - v20;
    int v32 = *(_DWORD *)(v26 + 548);
    if (!v32)
    {
      BOOL v37 = __nwlog_obj();
      os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      os_log_type_t v58 = "tcp_input_get_aggregate_frames_block_invoke";
      unint64_t v38 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = __nwlog_abort();
      if (result) {
        goto LABEL_95;
      }
      free(v38);
      uint64_t v26 = a1[7];
      int v32 = *(_DWORD *)(v26 + 548);
    }
    *(_DWORD *)(v26 + 548) = v32 - 1;
    uint64_t v33 = *(void *)(v17 + 32);
    int v34 = *(void **)(v17 + 40);
    if (v33)
    {
      *(void *)(v33 + 40) = v34;
      int v34 = *(void **)(v17 + 40);
    }
    else
    {
      *(void *)(v26 + 528) = v34;
    }
    void *v34 = v33;
    os_log_type_t v35 = *(void (**)(uint64_t, uint64_t, uint64_t))(v17 + 80);
    *(void *)(v17 + 32) = 0;
    *(void *)(v17 + 40) = 0;
    if (v35)
    {
      uint64_t v36 = *(void *)(v17 + 88);
      *(void *)(v17 + 80) = 0;
      *(void *)(v17 + 88) = 0;
      v35(v17, 1, v36);
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      os_log_type_t v58 = "__nw_frame_finalize";
      __int16 v39 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        __int16 v46 = __nwlog_obj();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v58 = "__nw_frame_finalize";
          _os_log_impl(&dword_214653000, v46, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
        }
      }
      if (v39) {
        free(v39);
      }
    }
    int v16 = (void *)a1[7];
    uint64_t v17 = v16[65];
    if (!v17) {
      goto LABEL_74;
    }
  }
  uint64_t v23 = *(unsigned int *)(*(void *)(a1[4] + 8) + 24);
  unsigned int v24 = v6 - v23;
  int v25 = (void *)(v8 + v23);
  if (v6 - v23 >= v20)
  {
    memcpy(v25, v22, v20);
    *(_DWORD *)(*(void *)(a1[4] + 8) + 24) += v20;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 24) += v20;
    uint64_t v26 = a1[7];
    unsigned int v27 = *(_DWORD *)(v26 + 552);
    if (v27 < v20)
    {
      __int16 v44 = __nwlog_obj();
      os_log_type_enabled(v44, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      os_log_type_t v58 = "tcp_input_get_aggregate_frames_block_invoke";
      int v45 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = __nwlog_abort();
      if (result) {
        goto LABEL_95;
      }
      free(v45);
      uint64_t v26 = a1[7];
      unsigned int v27 = *(_DWORD *)(v26 + 552);
    }
    uint64_t v28 = (_DWORD *)(v26 + 552);
    goto LABEL_48;
  }
  memcpy(v25, v22, v6 - v23);
  if ((*(_WORD *)(v17 + 204) & 0x80) != 0) {
    *(_WORD *)(v17 + 196) -= v24;
  }
  unsigned int v47 = *(_DWORD *)(v17 + 56) + v24;
  int v48 = *(_DWORD *)(v17 + 60);
  if (v47 <= *(_DWORD *)(v17 + 52) - v48)
  {
    *(_DWORD *)(v17 + 56) = v47;
  }
  else
  {
    os_log_type_t v49 = __nwlog_obj();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
    {
      int v50 = *(_DWORD *)(v17 + 52);
      *(_DWORD *)buf = 136446978;
      os_log_type_t v58 = "__nw_frame_claim_internal";
      __int16 v59 = 1024;
      *(_DWORD *)uint64_t v60 = v47;
      *(_WORD *)&v60[4] = 1024;
      *(_DWORD *)&v60[6] = v50;
      *(_WORD *)__int16 v61 = 1024;
      *(_DWORD *)&v61[2] = v48;
      _os_log_impl(&dword_214653000, v49, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
    }
  }
  *(_DWORD *)(*(void *)(a1[4] + 8) + 24) += v24;
  *(_DWORD *)(*(void *)(a1[5] + 8) + 24) += v24;
  uint64_t v51 = a1[7];
  unsigned int v52 = *(_DWORD *)(v51 + 552);
  if (v52 < v24)
  {
    uint64_t v54 = __nwlog_obj();
    os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    os_log_type_t v58 = "tcp_input_get_aggregate_frames_block_invoke";
    uint64_t v55 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if (result) {
      goto LABEL_95;
    }
    free(v55);
    uint64_t v51 = a1[7];
    unsigned int v52 = *(_DWORD *)(v51 + 552);
  }
  *(_DWORD *)(v51 + 552) = v52 - v24;
  if ((v18 & 1) == 0) {
    goto LABEL_77;
  }
LABEL_75:
  if (a2)
  {
    *(_WORD *)(a2 + 204) |= 0x4000u;
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v58 = "__nw_frame_set_is_wake_packet";
    int v53 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v56 = __nwlog_obj();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v58 = "__nw_frame_set_is_wake_packet";
        _os_log_impl(&dword_214653000, v56, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v53) {
      free(v53);
    }
  }
LABEL_77:
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
  return 1;
}

uint64_t tcp_new_isn(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  v9[0] = 0;
  v9[1] = 0;
  int v1 = *(_DWORD *)(a1 + 12);
  if (v1 == 10 || v1 == 1)
  {
    return arc4random();
  }
  else
  {
    memset(&v8, 0, sizeof(v8));
    microuptime((uint64_t)v9);
    arc4random_buf(__buf, 0x40uLL);
    CC_SHA256_Init(&v8);
    CC_SHA256_Update(&v8, __buf, 0x40u);
    CC_SHA256_Update(&v8, (const void *)(*(void *)(a1 + 80) + 2224), 2u);
    CC_SHA256_Update(&v8, (const void *)(*(void *)(a1 + 80) + 2226), 2u);
    int v5 = *(unsigned char **)(a1 + 80);
    if ((v5[2236] & 2) != 0)
    {
      CC_SHA256_Update(&v8, v5 + 464, 0x10u);
      unsigned int v6 = (const void *)(*(void *)(a1 + 80) + 480);
      CC_LONG v7 = 16;
    }
    else
    {
      CC_SHA256_Update(&v8, v5 + 476, 4u);
      unsigned int v6 = (const void *)(*(void *)(a1 + 80) + 492);
      CC_LONG v7 = 4;
    }
    CC_SHA256_Update(&v8, v6, v7);
    CC_SHA256_Final(md, &v8);
    return (*(_DWORD *)md + 1048 * LODWORD(v9[0]));
  }
}

uint64_t tcp_cubic_init(uint64_t a1)
{
  atomic_fetch_add(dword_26AA46420, 1u);
  float v2 = 0.3;
  if (!*(_DWORD *)(sysctls + 280)) {
    float v2 = 0.2;
  }
  float v3 = 0.85;
  if (!*(_DWORD *)(sysctls + 280)) {
    float v3 = 0.875;
  }
  float v4 = 0.7;
  if (!*(_DWORD *)(sysctls + 280)) {
    float v4 = 0.8;
  }
  tcp_cubic_backoff = LODWORD(v2);
  tcp_cubic_fast_convergence_factor = LODWORD(v3);
  tcp_cubic_beta = LODWORD(v4);
  int v5 = *(_DWORD **)(a1 + 840);
  if (v5) {
    goto LABEL_8;
  }
  CC_LONG v7 = __nwlog_obj();
  os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
  CC_SHA256_CTX v8 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!result)
  {
    free(v8);
    int v5 = *(_DWORD **)(a1 + 840);
LABEL_8:
    *int v5 = 0;
    *(_DWORD *)(*(void *)(a1 + 840) + 4) = 0;
    *(_DWORD *)(*(void *)(a1 + 840) + 8) = 0;
    *(_DWORD *)(*(void *)(a1 + 840) + 12) = 0;
    *(_DWORD *)(*(void *)(a1 + 840) + 16) = 0;
    *(_DWORD *)(*(void *)(a1 + 840) + 28) = 0;
    return 0;
  }
  __break(1u);
  return result;
}

uint64_t tcp_set_traffic_class(uint64_t a1, int a2)
{
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
  if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) == 0 && (*(unsigned char *)(a1 + 365) & 0x20) == 0)
  {
    uint64_t v5 = 22;
    goto LABEL_23;
  }
  if (a2 > 9999)
  {
LABEL_22:
    uint64_t v5 = 0;
    goto LABEL_23;
  }
  uint64_t v5 = 22;
  if (a2 > 499)
  {
    if (a2 <= 699)
    {
      if (a2 != 500 && a2 != 600) {
        goto LABEL_23;
      }
    }
    else if (a2 != 700 && a2 != 900 && a2 != 800)
    {
      goto LABEL_23;
    }
LABEL_21:
    *(_DWORD *)(a1 + 600) = a2;
    set_tcp_stream_priority(a1);
    goto LABEL_22;
  }
  if (a2 > 199)
  {
    if (a2 != 200 && a2 != 300 && a2 != 400) {
      goto LABEL_23;
    }
    goto LABEL_21;
  }
  if (!a2 || a2 == 100) {
    goto LABEL_21;
  }
LABEL_23:
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v2);
  return v5;
}

void tcp_output_batch_acks_end(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 240);
  uint64_t v3 = *(void *)(a1 + 224);
  if (!v3 || (*(unsigned char *)(v3 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      float v4 = __nwlog_tcp_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v5 = (const char *)(v3 + 604);
        int v6 = *(_DWORD *)(v2 + 740);
        int v7 = *(_DWORD *)(v2 + 648);
        if (!v3) {
          uint64_t v5 = "";
        }
        int v8 = *(_DWORD *)(v2 + 300);
        uint64_t v13 = "tcp_output_batch_acks_end";
        BOOL v9 = (v6 & 0x2000000) == 0;
        uint64_t v10 = "off";
        int v12 = 136447234;
        if (!v9) {
          uint64_t v10 = "on";
        }
        __int16 v14 = 2082;
        int v15 = v5;
        __int16 v16 = 2082;
        uint64_t v17 = v10;
        __int16 v18 = 1024;
        int v19 = v7;
        __int16 v20 = 1024;
        int v21 = v8;
        _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s %{public}s t_pktlist_sentlen %d t_lastchain %d", (uint8_t *)&v12, 0x2Cu);
      }
    }
  }
  *(_DWORD *)(v2 + 740) &= ~0x2000000u;
  if (*(unsigned char *)(a1 + 2238)) {
    goto LABEL_17;
  }
  if (*(void *)(v2 + 632)) {
    goto LABEL_14;
  }
  while (*(void *)(v2 + 656))
  {
LABEL_14:
    tcp_ip_output_send(v3, v2, (void *)(v2 + 632), *(_DWORD *)(v2 + 300), 0);
    *(void *)(v2 + 632) = 0;
    *(void *)(v2 + 640) = v2 + 632;
    *(_DWORD *)(v2 + 648) = 0;
    *(_DWORD *)(v2 + 300) = 0;
    if (*(unsigned char *)(a1 + 2238)) {
      goto LABEL_17;
    }
  }
  int v11 = *(_DWORD *)(v2 + 88);
  if ((v11 & 0x8000000) != 0)
  {
    *(_DWORD *)(v2 + 88) = v11 & 0xF7FFFFFF;
    tcp_close(v2);
  }
  else
  {
LABEL_17:
    tcp_check_timer_state(v2);
  }
}

uint64_t tcp_ip_output_send(uint64_t a1, uint64_t a2, void *a3, int a4, int a5)
{
  uint64_t v82 = *MEMORY[0x263EF8340];
  uint64_t v10 = *(void *)(a2 + 80);
  uint64_t v11 = *(void *)(v10 + 496);
  int v72 = *(_DWORD *)(v10 + 2228);
  if ((*(unsigned char *)(a2 + 743) & 2) == 0
    || a4 != 1
    || *(_DWORD *)(a2 + 648)
    || *(_DWORD *)(a2 + 672) + 1 >= tcp_batch_ack_max)
  {
    goto LABEL_2;
  }
  __int16 v14 = (void *)*a3;
  if (!*a3) {
    goto LABEL_89;
  }
  uint64_t v15 = v14[14];
  __int16 v16 = (void *)MEMORY[0x263F144B8];
  if (!v15
    || (*((_WORD *)v14 + 102) & 0x100) != 0
    && *MEMORY[0x263F144B8]
    && (!((unsigned int (*)(void, void))*MEMORY[0x263F144B8])(*a3, v14[11]) || (uint64_t v15 = v14[14]) == 0))
  {
    if ((*((_WORD *)v14 + 102) & 0x100) != 0
      && *v16
      && (((uint64_t (*)(void *, void))*v16)(v14, v14[11]) & 1) == 0)
    {
      *(void *)(a2 + 1056) = 0;
    }
LABEL_89:
    if (!a1 || (*(unsigned char *)(a1 + 828) & 2) == 0)
    {
      int v43 = __nwlog_tcp_log();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
      {
        __int16 v44 = (const char *)(a1 + 604);
        if (!a1) {
          __int16 v44 = "";
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "tcp_ip_output_send";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v44;
        _os_log_impl(&dword_214653000, v43, OS_LOG_TYPE_INFO, "%{public}s %{public}s failed to get tcp buffer in tcp-ip output", buf, 0x16u);
      }
    }
    int v45 = (void *)*a3;
    if (!*a3) {
      return 6;
    }
    while (1)
    {
      uint64_t v46 = v45[4];
      unsigned int v47 = (void *)v45[5];
      if (v46)
      {
        *(void *)(v46 + 40) = v47;
        unsigned int v47 = (void *)v45[5];
      }
      else
      {
        a3[1] = v47;
      }
      *unsigned int v47 = v46;
      int v48 = (void (*)(void *, void, uint64_t))v45[10];
      v45[4] = 0;
      v45[5] = 0;
      if (!v48) {
        break;
      }
      uint64_t v49 = v45[11];
      v45[10] = 0;
      v45[11] = 0;
      v48(v45, 0, v49);
LABEL_101:
      int v45 = (void *)*a3;
      if (!*a3) {
        return 6;
      }
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
    os_log_type_t v79 = OS_LOG_TYPE_ERROR;
    char v78 = 0;
    char v71 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      if (v79 == OS_LOG_TYPE_FAULT)
      {
        unsigned int v69 = __nwlog_obj();
        if (!os_log_type_enabled(v69, v79)) {
          goto LABEL_110;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        int v50 = v69;
        os_log_type_t v51 = v79;
        unsigned int v52 = "%{public}s called with null frame->finalizer";
      }
      else
      {
        __int16 v70 = __nwlog_obj();
        if (!os_log_type_enabled(v70, v79)) {
          goto LABEL_110;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        int v50 = v70;
        os_log_type_t v51 = v79;
        unsigned int v52 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
      }
      _os_log_impl(&dword_214653000, v50, v51, v52, buf, 0xCu);
    }
LABEL_110:
    if (v71) {
      free(v71);
    }
    goto LABEL_101;
  }
  if ((*(unsigned char *)(v15 + *((unsigned int *)v14 + 14) + 13) & 7) == 0)
  {
    if (*a3)
    {
      **(void **)(a2 + 664) = *a3;
      *(void *)(*a3 + 40) = *(void *)(a2 + 664);
      *(void *)(a2 + 664) = a3[1];
      *a3 = 0;
      a3[1] = a3;
    }
    uint64_t v17 = 0;
    ++*(_DWORD *)(a2 + 672);
    return v17;
  }
LABEL_2:
  uint64_t v12 = *(void *)(a2 + 656);
  if (v12)
  {
    if (*a3)
    {
      **(void **)(a2 + 664) = *a3;
      *(void *)(*a3 + 40) = *(void *)(a2 + 664);
      *(void *)(a2 + 664) = a3[1];
      *a3 = 0;
      a3[1] = a3;
      uint64_t v12 = *(void *)(a2 + 656);
      uint64_t v13 = a3;
      if (!v12) {
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = (void *)a3[1];
    }
    *uint64_t v13 = v12;
    *(void *)(*(void *)(a2 + 656) + 40) = a3[1];
    a3[1] = *(void *)(a2 + 664);
    *(void *)(a2 + 656) = 0;
    *(void *)(a2 + 664) = a2 + 656;
LABEL_21:
    *(_DWORD *)(a2 + 672) = 0;
  }
  ++*(unsigned char *)(v10 + 2238);
  if (*(_DWORD *)(sysctls + 104) && !*(_DWORD *)(a1 + 592))
  {
    char v18 = 1;
    if (!a5 && *(_DWORD *)(a2 + 12) == 4 && (*(unsigned char *)(a2 + 90) & 0x20) == 0 && (*(unsigned char *)(a1 + 367) & 1) == 0)
    {
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 0, v5);
      char v18 = 0;
    }
  }
  else
  {
    char v18 = 1;
  }
  uint64_t v19 = *(void *)(*(void *)(a1 + 24) + 32);
  if (__nwlog_is_datapath_logging_enabled())
  {
    v73[0] = MEMORY[0x263EF8330];
    v73[1] = 0x40000000;
    uint64_t v74 = __tcp_ip_output_send_block_invoke;
    int v75 = &__block_descriptor_tmp_488;
    uint64_t v76 = a2;
    uint64_t v77 = a1;
    uint64_t v56 = *a3;
    do
    {
      if (!v56) {
        break;
      }
      uint64_t v57 = *(void *)(v56 + 32);
      char v58 = ((uint64_t (*)(void *))v74)(v73);
      uint64_t v56 = v57;
    }
    while ((v58 & 1) != 0);
  }
  __int16 v20 = (void *)MEMORY[0x263F144B0];
  if (*MEMORY[0x263F144B0] != -1) {
    dispatch_once(MEMORY[0x263F144B0], &__block_literal_global_489);
  }
  int v21 = (unsigned char *)MEMORY[0x263F144A8];
  if (*MEMORY[0x263F144A8] && kdebug_is_enabled())
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2000000000;
    uint64_t v81 = 0;
    nw_frame_array_foreach();
    if (*v20 == -1)
    {
      if (*v21) {
        goto LABEL_131;
      }
    }
    else
    {
      dispatch_once(MEMORY[0x263F144B0], &__block_literal_global_489);
      if (*v21)
      {
LABEL_131:
        if (kdebug_is_enabled())
        {
          nw_frame_array_unclaimed_length();
          kdebug_trace();
        }
      }
    }
    _Block_object_dispose(buf, 8);
  }
  if (((*(uint64_t (**)(uint64_t, void *))(*(void *)(v19 + 24) + 96))(v19, a3) & 1) == 0)
  {
    uint64_t v22 = (void *)*a3;
    if (!*a3) {
      goto LABEL_57;
    }
    while (1)
    {
      uint64_t v23 = v22[4];
      unsigned int v24 = (void *)v22[5];
      if (v23)
      {
        *(void *)(v23 + 40) = v24;
        unsigned int v24 = (void *)v22[5];
      }
      else
      {
        a3[1] = v24;
      }
      *unsigned int v24 = v23;
      int v25 = (void (*)(void *, void, uint64_t))v22[10];
      v22[4] = 0;
      v22[5] = 0;
      if (!v25) {
        break;
      }
      uint64_t v26 = v22[11];
      v22[10] = 0;
      v22[11] = 0;
      v25(v22, 0, v26);
LABEL_39:
      uint64_t v22 = (void *)*a3;
      if (!*a3) {
        goto LABEL_57;
      }
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
    uint64_t v27 = _os_log_send_and_compose_impl();
    os_log_type_t v79 = OS_LOG_TYPE_ERROR;
    char v78 = 0;
    int v68 = (void *)v27;
    if (__nwlog_fault())
    {
      if (v79 == OS_LOG_TYPE_FAULT)
      {
        __int16 v65 = __nwlog_obj();
        os_log_type_t log = v79;
        if (!os_log_type_enabled(v65, v79)) {
          goto LABEL_55;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        uint64_t v28 = v65;
        os_log_type_t v29 = log;
        uint64_t v30 = "%{public}s called with null frame->finalizer";
        goto LABEL_54;
      }
      if (!v78)
      {
        uint64_t v67 = __nwlog_obj();
        os_log_type_t logb = v79;
        if (!os_log_type_enabled(v67, v79)) {
          goto LABEL_55;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        uint64_t v28 = v67;
        os_log_type_t v29 = logb;
        uint64_t v30 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
        goto LABEL_54;
      }
      os_log_t backtrace_string = (os_log_t)__nw_create_backtrace_string();
      loga = __nwlog_obj();
      os_log_type_t type = v79;
      BOOL v31 = os_log_type_enabled(loga, v79);
      os_log_t v32 = backtrace_string;
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_214653000, loga, type, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
          os_log_t v32 = backtrace_string;
        }
        free(v32);
        goto LABEL_55;
      }
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        uint64_t v28 = loga;
        os_log_type_t v29 = type;
        uint64_t v30 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_54:
        _os_log_impl(&dword_214653000, v28, v29, v30, buf, 0xCu);
      }
    }
LABEL_55:
    if (v68) {
      free(v68);
    }
    goto LABEL_39;
  }
  if (*(_DWORD *)(a2 + 12) == 2) {
    ++*(unsigned char *)(a2 + 1868);
  }
LABEL_57:
  if ((v18 & 1) == 0) {
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)(a1 + 8) + 16))(a1, 0, v5);
  }
  if ((*(unsigned char *)(v10 + 2231) & 0x10) != 0)
  {
    if ((v72 & 0x10000000) != 0)
    {
      uint64_t v17 = 0;
      goto LABEL_66;
    }
LABEL_64:
    uint64_t v17 = 55;
    goto LABEL_66;
  }
  uint64_t v17 = 0;
  if ((*(unsigned char *)(*(void *)(v10 + 224) + 366) & 2) != 0 && (v72 & 0x10000000) == 0) {
    goto LABEL_64;
  }
LABEL_66:
  int v33 = *(unsigned __int8 *)(v10 + 2238);
  *(unsigned char *)(v10 + 2238) = v33 - 1;
  if (v33)
  {
    if (!v11) {
      goto LABEL_71;
    }
    goto LABEL_68;
  }
  __int16 v59 = __nwlog_obj();
  os_log_type_enabled(v59, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "tcp_ip_output_send";
  uint64_t v60 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!result)
  {
    free(v60);
    if (!v11) {
      goto LABEL_71;
    }
LABEL_68:
    uint64_t v34 = *(void *)(v11 + 216);
    if (v34 != *(void *)(v10 + 448) && *(_DWORD *)(a1 + 384))
    {
      os_unfair_lock_lock((os_unfair_lock_t)(a2 + 1864));
      *(void *)(v10 + 448) = v34;
      os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 1864));
    }
LABEL_71:
    if (*(int *)(a2 + 12) > 3) {
      return v17;
    }
    if (*(_WORD *)(a2 + 226)) {
      return v17;
    }
    uint64_t v35 = *(void *)(a2 + 80);
    uint64_t v36 = *(void *)(v35 + 496);
    if (!v36) {
      return v17;
    }
    uint64_t v37 = *(void *)(v36 + 1488);
    if (!v37) {
      goto LABEL_120;
    }
    unsigned int v38 = *(_DWORD *)(v37 + 64);
    if (!v38 || *(_DWORD *)(a2 + 1872) == 1) {
      goto LABEL_120;
    }
    *(_DWORD *)(a2 + 228) = 30;
    unsigned int v39 = v38 / 0x1F;
    *(_DWORD *)(a2 + 200) = v38 / 0x1F;
    uint64_t v40 = *(void *)(a2 + 1056);
    if (v40)
    {
      ++*(void *)(v40 + 1280);
      unsigned int v41 = *(_DWORD *)(v37 + 68);
      if (v41)
      {
        unsigned int v42 = v41 / 0x3E;
        *(_DWORD *)(a2 + 208) = v41 / 0x3E;
        ++*(void *)(v40 + 1288);
LABEL_116:
        signed int v54 = (v42 + (v39 >> 3)) >> 2;
        if (v54 <= 30) {
          signed int v54 = 30;
        }
        *(_DWORD *)(a2 + 192) = v54;
        if (v54 >= 0xFA01) {
          *(_DWORD *)(a2 + 192) = 64000;
        }
LABEL_120:
        *(_DWORD *)(a2 + 28) = *(_DWORD *)(a2 + 192)
                             + *(_DWORD *)(nw_tcp_access_globals(*(void *)(v35 + 224)) + 316)
                             - *(_DWORD *)(a2 + 64);
        return v17;
      }
    }
    else
    {
      unsigned int v53 = *(_DWORD *)(v37 + 68);
      if (v53)
      {
        unsigned int v42 = v53 / 0x3E;
        *(_DWORD *)(a2 + 208) = v53 / 0x3E;
        goto LABEL_116;
      }
    }
    unsigned int v42 = v38 / 0x3E;
    *(_DWORD *)(a2 + 208) = v42;
    goto LABEL_116;
  }
  __break(1u);
  return result;
}

uint64_t nw_protocol_tcp_get_input_frames(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5, void **a6)
{
  uint64_t v155 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
    int v68 = (void *)_os_log_send_and_compose_impl();
    BYTE4(v144[0]) = 16;
    LOBYTE(v144[0]) = 0;
    if (!__nwlog_fault()) {
      goto LABEL_143;
    }
    if (BYTE4(v144[0]) == 17)
    {
      uint64_t v95 = __nwlog_obj();
      os_log_type_t v96 = BYTE4(v144[0]);
      if (!os_log_type_enabled(v95, BYTE4(v144[0]))) {
        goto LABEL_143;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
      char v71 = "%{public}s called with null protocol";
    }
    else
    {
      uint64_t v95 = __nwlog_obj();
      os_log_type_t v96 = BYTE4(v144[0]);
      if (!os_log_type_enabled(v95, BYTE4(v144[0]))) {
        goto LABEL_143;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
      char v71 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_234;
  }
  uint64_t v12 = nw_protocol_downcast();
  if (!v12)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
    int v68 = (void *)_os_log_send_and_compose_impl();
    BYTE4(v144[0]) = 16;
    LOBYTE(v144[0]) = 0;
    if (!__nwlog_fault()) {
      goto LABEL_143;
    }
    if (BYTE4(v144[0]) == 17)
    {
      uint64_t v95 = __nwlog_obj();
      os_log_type_t v96 = BYTE4(v144[0]);
      if (!os_log_type_enabled(v95, BYTE4(v144[0]))) {
        goto LABEL_143;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
      char v71 = "%{public}s called with null tcp";
    }
    else
    {
      uint64_t v95 = __nwlog_obj();
      os_log_type_t v96 = BYTE4(v144[0]);
      if (!os_log_type_enabled(v95, BYTE4(v144[0]))) {
        goto LABEL_143;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
      char v71 = "%{public}s called with null tcp, backtrace limit exceeded";
    }
LABEL_234:
    uint64_t v74 = v95;
    os_log_type_t v75 = v96;
    uint32_t v76 = 12;
    goto LABEL_142;
  }
  uint64_t v13 = v12;
  unsigned int v14 = *(_DWORD *)(v12 + 5224);
  if (v14 <= 1)
  {
    if ((*(unsigned char *)(v12 + 828) & 2) != 0) {
      return 0;
    }
    if (!__nwlog_is_datapath_logging_enabled()) {
      return 0;
    }
    uint64_t v15 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
      return 0;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v13 + 604;
    __int16 v16 = "%{public}s %{public}s skipping";
    goto LABEL_8;
  }
  if (v14 != 2)
  {
    if (!*(_DWORD *)(v12 + 488))
    {
      if ((*(unsigned char *)(v12 + 828) & 2) != 0) {
        return 0;
      }
      if (!__nwlog_is_datapath_logging_enabled()) {
        return 0;
      }
      uint64_t v15 = __nwlog_tcp_log();
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
        return 0;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v13 + 604;
      __int16 v16 = "%{public}s %{public}s past connected state, skipping";
LABEL_8:
      _os_log_impl(&dword_214653000, v15, OS_LOG_TYPE_DEBUG, v16, buf, 0x16u);
      return 0;
    }
    if ((*(unsigned char *)(v12 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v103 = __nwlog_tcp_log();
        if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v13 + 604;
          _os_log_impl(&dword_214653000, v103, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s allowing read past connected state", buf, 0x16u);
        }
      }
    }
  }
  if (*(_DWORD *)(v13 + 492) < a3)
  {
    if ((*(unsigned char *)(v13 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v101 = __nwlog_tcp_log();
        if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
        {
          int v102 = *(_DWORD *)(v13 + 492);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v13 + 604;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)int v147 = a3;
          *(_WORD *)&v147[4] = 1024;
          *(_DWORD *)int v148 = v102;
          _os_log_impl(&dword_214653000, v101, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s capping minimum_bytes %u to sb_hiwat %u", buf, 0x22u);
        }
      }
    }
    a3 = *(_DWORD *)(v13 + 492);
  }
  uint64_t v17 = *(void *)(v13 + 8);
  char v18 = *(NSObject **)(*(void *)v13 + 240);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v17 + 16))(v13, 1, v6);
  if (*(_DWORD *)(v13 + 360) == 1)
  {
    if ((*(unsigned char *)(v13 + 828) & 2) != 0) {
      goto LABEL_126;
    }
    __nwlog_tcp_log();
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "tcp_get_northbound_frames";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v13 + 604;
    uint64_t v19 = (void *)_os_log_send_and_compose_impl();
    BYTE4(v144[0]) = 16;
    LOBYTE(v144[0]) = 0;
    if (!__nwlog_fault()) {
      goto LABEL_54;
    }
    if (BYTE4(v144[0]) == 17)
    {
      __int16 v20 = __nwlog_tcp_log();
      os_log_type_t v21 = BYTE4(v144[0]);
      if (!os_log_type_enabled(v20, BYTE4(v144[0]))) {
        goto LABEL_54;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "tcp_get_northbound_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v13 + 604;
      uint64_t v22 = "%{public}s %{public}s no other reference on socket";
    }
    else
    {
      __int16 v20 = __nwlog_tcp_log();
      os_log_type_t v21 = BYTE4(v144[0]);
      if (!os_log_type_enabled(v20, BYTE4(v144[0]))) {
        goto LABEL_54;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "tcp_get_northbound_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v13 + 604;
      uint64_t v22 = "%{public}s %{public}s no other reference on socket, backtrace limit exceeded";
    }
    _os_log_impl(&dword_214653000, v20, v21, v22, buf, 0x16u);
LABEL_54:
    if (v19) {
      free(v19);
    }
    goto LABEL_126;
  }
  uint64_t v23 = (unsigned int *)(v13 + 488);
  if ((*(unsigned char *)(v13 + 364) & 8) != 0)
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 57;
    if ((*(unsigned char *)(v13 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        unsigned int v104 = __nwlog_tcp_log();
        if (os_log_type_enabled(v104, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "tcp_get_northbound_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v13 + 604;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)int v147 = 57;
          _os_log_impl(&dword_214653000, v104, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s defunct socket error (%d)", buf, 0x1Cu);
        }
      }
    }
    if (*(__int16 *)(v13 + 376) < 0) {
      sb_empty_assert((int *)(v13 + 488), (uint64_t)"tcp_get_northbound_frames");
    }
    goto LABEL_125;
  }
  if ((*(unsigned char *)(v13 + 368) & 0x20) != 0)
  {
    unsigned int v24 = *(uint64_t (**)(uint64_t))(*(void *)(v17 + 40) + 88);
    if (v24)
    {
      int v25 = v24(v13);
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = v25;
      if (v25)
      {
LABEL_125:
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v13 + 8) + 24))(v13, 1, v6);
        goto LABEL_126;
      }
    }
  }
  if ((~*(unsigned __int16 *)(v13 + 376) & 0x21) == 0 && (*(unsigned char *)(v13 + 367) & 1) == 0)
  {
    uint64_t v26 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    int v27 = 45;
LABEL_124:
    *uint64_t v26 = v27;
    goto LABEL_125;
  }
  unsigned int v28 = *v23;
  if (*v23 < a3 && v28 < *(_DWORD *)(v13 + 496)) {
    goto LABEL_123;
  }
  unsigned int v29 = v28 >= a4 ? a4 : *v23;
  if (!v29) {
    goto LABEL_123;
  }
  os_log_t v130 = v18;
  uint64_t isa = *(void *)(v13 + 504);
  unsigned int v138 = v29;
  if (!isa)
  {
    int v129 = a5;
    goto LABEL_58;
  }
  BOOL v31 = (uint64_t *)(v13 + 504);
  if (*(_DWORD *)(v13 + 824) != -1)
  {
    int v129 = a5;
    unsigned int v32 = *(_DWORD *)(v13 + 552);
    unsigned int v33 = v28 - v32;
    if (v28 > v32 && v33 <= v29)
    {
      *a6[1] = isa;
      *(void *)(*(void *)(v13 + 504) + 40) = a6[1];
      a6[1] = *(void **)(v13 + 512);
      *(void *)(v13 + 504) = 0;
      *(void *)(v13 + 512) = v31;
      goto LABEL_50;
    }
    int v124 = (unsigned int *)(v13 + 488);
    unsigned int v33 = 0;
    uint64_t v34 = 0;
    unsigned int v78 = v29;
    while (1)
    {
      unsigned int v79 = *(_DWORD *)(isa + 52);
      if (v79) {
        v79 -= *(_DWORD *)(isa + 56) + *(_DWORD *)(isa + 60);
      }
      signed int v80 = v78 - v79;
      if (v78 < v79) {
        break;
      }
      uint64_t v82 = *(void *)(isa + 32);
      int v83 = *(void **)(isa + 40);
      uint64_t v81 = (void *)(isa + 32);
      if (v82)
      {
        *(void *)(v82 + 40) = v83;
        int v83 = *(void **)(isa + 40);
      }
      else
      {
        *(void *)(v13 + 512) = v83;
      }
      v33 += v79;
      *int v83 = v82;
      *uint64_t v81 = 0;
      *(void *)(isa + 40) = 0;
      int v84 = a6[1];
      *(void *)(isa + 40) = v84;
      *int v84 = isa;
      a6[1] = v81;
      uint64_t v34 = (v34 + 1);
      uint64_t isa = *v31;
      if (*v31)
      {
        unsigned int v78 = v80;
        if (v80) {
          continue;
        }
      }
      goto LABEL_167;
    }
    signed int v80 = v78;
LABEL_167:
    if (!isa || !v80)
    {
      uint64_t v23 = (unsigned int *)(v13 + 488);
      goto LABEL_59;
    }
    os_log_t v126 = (os_log_t)(v13 + 504);
    unsigned int v136 = v33;
    uint64_t v89 = nw_protocol_tcp_copy_frame(v13, isa, v80);
    if (v89)
    {
      uint64_t v90 = v89;
      if ((*(_WORD *)(isa + 204) & 0x80) != 0) {
        *(_WORD *)(isa + 196) -= v80;
      }
      unsigned int v91 = *(_DWORD *)(isa + 56) + v80;
      if (v91 <= *(_DWORD *)(isa + 52) - *(_DWORD *)(isa + 60))
      {
        *(_DWORD *)(isa + 56) = v91;
      }
      else
      {
        int v120 = *(_DWORD *)(isa + 56) + v80;
        int v123 = *(_DWORD *)(isa + 60);
        os_log_t v131 = (os_log_t)v89;
        unsigned int v127 = __nwlog_obj();
        BOOL v92 = os_log_type_enabled(v127, OS_LOG_TYPE_ERROR);
        uint64_t v90 = (uint64_t)v131;
        if (v92)
        {
          int v93 = *(_DWORD *)(isa + 52);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v120;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v93;
          *(_WORD *)int v147 = 1024;
          *(_DWORD *)&v147[2] = v123;
          _os_log_impl(&dword_214653000, v127, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
          uint64_t v90 = (uint64_t)v131;
        }
      }
      *(void *)(v90 + 32) = 0;
      unsigned int v33 = v136 + v80;
      int v94 = a6[1];
      *(void *)(v90 + 40) = v94;
      *int v94 = v90;
      a6[1] = (void *)(v90 + 32);
      uint64_t v34 = (v34 + 1);
LABEL_187:
      uint64_t v23 = v124;
      unsigned int v29 = v138;
      goto LABEL_59;
    }
    if (v126->isa)
    {
      *a6[1] = v126->isa;
      *(void *)(*(void *)(v13 + 504) + 40) = a6[1];
      a6[1] = *(void **)(v13 + 512);
      *(void *)(v13 + 504) = 0;
      *(void *)(v13 + 512) = v126;
    }
    if (*a6)
    {
      **(void **)(v13 + 512) = *a6;
      (*a6)[5] = *(void *)(v13 + 512);
      *(void *)(v13 + 512) = a6[1];
      *a6 = 0;
      a6[1] = a6;
    }
    if ((*(_WORD *)(isa + 204) & 0x100) != 0
      && *MEMORY[0x263F144B8]
      && (((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(isa, *(void *)(isa + 88)) & 1) == 0)
    {
      v130[132].uint64_t isa = 0;
    }
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 55;
LABEL_126:
    int v66 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v66 == 35)
    {
      nw_protocol_tcp_set_receive_low_water_mark(a1, a3);
      return 0;
    }
    __nwlog_obj();
    uint64_t v67 = v13 + 604;
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v13 + 604;
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)int v147 = v66;
    int v68 = (void *)_os_log_send_and_compose_impl();
    BYTE4(v144[0]) = 16;
    LOBYTE(v144[0]) = 0;
    if (__nwlog_fault())
    {
      if (BYTE4(v144[0]) == 17)
      {
        unsigned int v69 = __nwlog_obj();
        os_log_type_t v70 = BYTE4(v144[0]);
        if (!os_log_type_enabled(v69, BYTE4(v144[0]))) {
          goto LABEL_143;
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v67;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)int v147 = v66;
        char v71 = "%{public}s %{public}s tcp_get_northbound_frame, returned NULL %{darwin.errno}d";
        goto LABEL_141;
      }
      if (!LOBYTE(v144[0]))
      {
        unsigned int v69 = __nwlog_obj();
        os_log_type_t v70 = BYTE4(v144[0]);
        if (!os_log_type_enabled(v69, BYTE4(v144[0]))) {
          goto LABEL_143;
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v67;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)int v147 = v66;
        char v71 = "%{public}s %{public}s tcp_get_northbound_frame, returned NULL %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_141;
      }
      os_log_t backtrace_string = (void *)__nw_create_backtrace_string();
      unsigned int v69 = __nwlog_obj();
      os_log_type_t v70 = BYTE4(v144[0]);
      BOOL v73 = os_log_type_enabled(v69, BYTE4(v144[0]));
      if (backtrace_string)
      {
        if (v73)
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v67;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)int v147 = v66;
          *(_WORD *)&v147[4] = 2082;
          *(void *)int v148 = backtrace_string;
          _os_log_impl(&dword_214653000, v69, v70, "%{public}s %{public}s tcp_get_northbound_frame, returned NULL %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x26u);
        }
        free(backtrace_string);
        goto LABEL_143;
      }
      if (v73)
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v67;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)int v147 = v66;
        char v71 = "%{public}s %{public}s tcp_get_northbound_frame, returned NULL %{darwin.errno}d, no backtrace";
LABEL_141:
        uint64_t v74 = v69;
        os_log_type_t v75 = v70;
        uint32_t v76 = 28;
LABEL_142:
        _os_log_impl(&dword_214653000, v74, v75, v71, buf, v76);
      }
    }
LABEL_143:
    if (v68) {
      free(v68);
    }
    return 0;
  }
  os_log_t v125 = (os_log_t)(v13 + 504);
  *(void *)((char *)v144 + 4) = 0;
  *(void *)((char *)&v144[1] + 4) = (char *)v144 + 4;
  if (!nw_protocol_tcp_get_frames(v13, v29, (uint64_t)v144 + 4, 1, 0, 0))
  {
    uint64_t v26 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    int v27 = 12;
    goto LABEL_124;
  }
  uint64_t v39 = *(void *)((char *)v144 + 4);
  int v129 = a5;
  if (!*(void *)((char *)v144 + 4))
  {
    int v124 = (unsigned int *)(v13 + 488);
    int v106 = __nwlog_obj();
    os_log_type_enabled(v106, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "tcp_get_northbound_frames";
    v107 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if (result)
    {
      __break(1u);
      return result;
    }
    free(v107);
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_frame_unclaimed_bytes";
    v108 = (void *)_os_log_send_and_compose_impl();
    LOBYTE(v144[0]) = 16;
    char v145 = 0;
    if (!__nwlog_fault()) {
      goto LABEL_255;
    }
    if (LOBYTE(v144[0]) == 17)
    {
      v109 = __nwlog_obj();
      os_log_type_t v110 = v144[0];
      if (os_log_type_enabled(v109, v144[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_unclaimed_bytes";
        v111 = "%{public}s called with null frame";
LABEL_253:
        int v114 = v109;
LABEL_254:
        _os_log_impl(&dword_214653000, v114, v110, v111, buf, 0xCu);
      }
    }
    else if (v145)
    {
      v112 = (void *)__nw_create_backtrace_string();
      os_log_type_t v110 = v144[0];
      unsigned int v133 = __nwlog_obj();
      BOOL v113 = os_log_type_enabled(v133, v144[0]);
      if (v112)
      {
        if (v113)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "__nw_frame_unclaimed_bytes";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v112;
          _os_log_impl(&dword_214653000, v133, v144[0], "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v112);
        goto LABEL_255;
      }
      if (v113)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_unclaimed_bytes";
        v111 = "%{public}s called with null frame, no backtrace";
        int v114 = v133;
        goto LABEL_254;
      }
    }
    else
    {
      v109 = __nwlog_obj();
      os_log_type_t v110 = v144[0];
      if (os_log_type_enabled(v109, v144[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_unclaimed_bytes";
        v111 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_253;
      }
    }
LABEL_255:
    if (v108) {
      free(v108);
    }
    uint64_t v34 = 0;
    unsigned int v33 = 0;
    goto LABEL_187;
  }
  unsigned int v29 = v138;
  if (!*(void *)(*(void *)((char *)v144 + 4) + 112)) {
    goto LABEL_58;
  }
  if ((*(_WORD *)(*(void *)((char *)v144 + 4) + 204) & 0x100) != 0)
  {
    if (*MEMORY[0x263F144B8])
    {
      uint64_t v121 = *(void *)((char *)v144 + 4);
      int v40 = ((uint64_t (*)(void, void))*MEMORY[0x263F144B8])(*(void *)((char *)v144 + 4), *(void *)(*(void *)((char *)v144 + 4) + 88));
      uint64_t v39 = v121;
      unsigned int v29 = v138;
      if (!v40) {
        goto LABEL_58;
      }
    }
  }
  int v41 = *(_DWORD *)(v39 + 52);
  if (!v41)
  {
    unsigned int v33 = 0;
    uint64_t v34 = 0;
    if (*(void *)(v39 + 112)) {
      goto LABEL_240;
    }
    goto LABEL_59;
  }
  uint64_t v42 = *(void *)(v39 + 112);
  if (!v42)
  {
LABEL_58:
    uint64_t v34 = 0;
    unsigned int v33 = 0;
    goto LABEL_59;
  }
  uint64_t v122 = v39;
  uint64_t v43 = *(unsigned int *)(v39 + 56);
  unsigned int v44 = v41 - (v43 + *(_DWORD *)(v39 + 60));
  if (!v44 || !v130)
  {
    unsigned int v33 = 0;
    uint64_t v23 = (unsigned int *)(v13 + 488);
    goto LABEL_239;
  }
  unsigned int v33 = 0;
  uint64_t v119 = v42 + v43;
  while (1)
  {
    unsigned int v134 = v33;
    if (!*(void *)(isa + 112)) {
      break;
    }
    if ((*(_WORD *)(isa + 204) & 0x100) != 0)
    {
      if (*MEMORY[0x263F144B8])
      {
        int v45 = ((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(isa, *(void *)(isa + 88));
        unsigned int v29 = v138;
        if (!v45) {
          break;
        }
      }
    }
    int v47 = *(_DWORD *)(isa + 52);
    uint64_t v46 = *(unsigned int *)(isa + 56);
    unsigned int v48 = v47 ? v47 - (v46 + *(_DWORD *)(isa + 60)) : 0;
    uint64_t v49 = *(void *)(isa + 112);
    if (!v49) {
      break;
    }
    unsigned int v50 = v44 - v48;
    if (v44 < v48) {
      goto LABEL_206;
    }
    unsigned int v51 = v48;
    memcpy((void *)(v119 + v134), (const void *)(v49 + v46), v48);
    uint64_t v52 = *(void *)(isa + 32);
    unsigned int v53 = *(void **)(isa + 40);
    if (v52)
    {
      *(void *)(v52 + 40) = v53;
      unsigned int v53 = *(void **)(isa + 40);
    }
    else
    {
      *(void *)(v13 + 512) = v53;
    }
    *unsigned int v53 = v52;
    signed int v54 = *(void (**)(uint64_t, uint64_t, uint64_t))(isa + 80);
    *(void *)(isa + 32) = 0;
    *(void *)(isa + 40) = 0;
    if (!v54)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
      uint64_t v56 = _os_log_send_and_compose_impl();
      LOBYTE(v144[0]) = 16;
      char v145 = 0;
      int v118 = (void *)v56;
      if (!__nwlog_fault()) {
        goto LABEL_107;
      }
      if (LOBYTE(v144[0]) == 17)
      {
        os_log_type_t log = __nwlog_obj();
        if (os_log_type_enabled(log, v144[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          uint64_t v57 = log;
          os_log_type_t v58 = v144[0];
          __int16 v59 = "%{public}s called with null frame->finalizer";
          goto LABEL_106;
        }
        goto LABEL_107;
      }
      if (v145)
      {
        uint64_t v60 = (void *)__nw_create_backtrace_string();
        loga = __nwlog_obj();
        BOOL v61 = os_log_type_enabled(loga, v144[0]);
        if (v60)
        {
          if (v61)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v60;
            _os_log_impl(&dword_214653000, loga, v144[0], "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v60);
          goto LABEL_107;
        }
        if (!v61)
        {
LABEL_107:
          if (v118) {
            free(v118);
          }
          goto LABEL_90;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        uint64_t v57 = loga;
        os_log_type_t v58 = v144[0];
        __int16 v59 = "%{public}s called with null frame->finalizer, no backtrace";
      }
      else
      {
        os_log_type_t logb = __nwlog_obj();
        if (!os_log_type_enabled(logb, v144[0])) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        uint64_t v57 = logb;
        os_log_type_t v58 = v144[0];
        __int16 v59 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
      }
LABEL_106:
      _os_log_impl(&dword_214653000, v57, v58, v59, buf, 0xCu);
      goto LABEL_107;
    }
    uint64_t v55 = *(void *)(isa + 88);
    *(void *)(isa + 80) = 0;
    *(void *)(isa + 88) = 0;
    v54(isa, 1, v55);
LABEL_90:
    unsigned int v33 = v51 + v134;
    uint64_t isa = (uint64_t)v125->isa;
    unsigned int v29 = v138;
    if (v125->isa)
    {
      unsigned int v44 = v50;
      if (v50) {
        continue;
      }
    }
    goto LABEL_208;
  }
  if ((*(_WORD *)(isa + 204) & 0x100) == 0)
  {
LABEL_206:
    unsigned int v50 = v44;
    goto LABEL_207;
  }
  if (*MEMORY[0x263F144B8]
    && (((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(isa, *(void *)(isa + 88)) & 1) == 0)
  {
    v130[132].uint64_t isa = 0;
  }
  unsigned int v50 = v44;
  unsigned int v29 = v138;
LABEL_207:
  unsigned int v33 = v134;
LABEL_208:
  if (isa && v50)
  {
    unsigned int v137 = v33;
    uint64_t v97 = *(void *)(isa + 112);
    if (v97
      && ((*(_WORD *)(isa + 204) & 0x100) == 0
       || !*MEMORY[0x263F144B8]
       || ((unsigned int (*)(uint64_t, void))*MEMORY[0x263F144B8])(isa, *(void *)(isa + 88))
       && (uint64_t v97 = *(void *)(isa + 112)) != 0))
    {
      memcpy((void *)(v119 + v137), (const void *)(v97 + *(unsigned int *)(isa + 56)), v50);
      if ((*(_WORD *)(isa + 204) & 0x80) != 0) {
        *(_WORD *)(isa + 196) -= v50;
      }
      unsigned int v132 = v50;
      unsigned int v98 = *(_DWORD *)(isa + 56) + v50;
      int v99 = *(_DWORD *)(isa + 60);
      if (v98 <= *(_DWORD *)(isa + 52) - v99)
      {
        *(_DWORD *)(isa + 56) = v98;
      }
      else
      {
        unsigned int v128 = __nwlog_obj();
        if (os_log_type_enabled(v128, OS_LOG_TYPE_ERROR))
        {
          int v100 = *(_DWORD *)(isa + 52);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v98;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v100;
          *(_WORD *)int v147 = 1024;
          *(_DWORD *)&v147[2] = v99;
          _os_log_impl(&dword_214653000, v128, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
        }
      }
      unsigned int v33 = v137 + v132;
      uint64_t v23 = (unsigned int *)(v13 + 488);
      unsigned int v29 = v138;
    }
    else
    {
      if ((*(_WORD *)(isa + 204) & 0x100) != 0
        && *MEMORY[0x263F144B8]
        && (((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(isa, *(void *)(isa + 88)) & 1) == 0)
      {
        v130[132].uint64_t isa = 0;
      }
      uint64_t v23 = (unsigned int *)(v13 + 488);
      unsigned int v29 = v138;
      unsigned int v33 = v137;
    }
  }
  else
  {
    uint64_t v23 = (unsigned int *)(v13 + 488);
  }
LABEL_239:
  uint64_t v39 = v122;
LABEL_240:
  *(void *)(v39 + 32) = 0;
  uint64_t v105 = a6[1];
  *(void *)(v39 + 40) = v105;
  *uint64_t v105 = v39;
  a6[1] = (void *)(v39 + 32);
LABEL_50:
  uint64_t v34 = 1;
LABEL_59:
  BOOL v35 = v29 >= v33;
  unsigned int v36 = v29 - v33;
  if (v36 != 0 && v35)
  {
    unsigned int v37 = v33;
    v144[0] = 0;
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    if (tcp_input_get_aggregate_frames(v13, v36, (_DWORD *)v144 + 1, v144, (uint64_t)buf))
    {
      if (*(void *)buf)
      {
        *a6[1] = *(void *)buf;
        unsigned int v38 = *(void **)&buf[8];
        *(void *)(*(void *)buf + 40) = a6[1];
        a6[1] = v38;
      }
      unsigned int v33 = HIDWORD(v144[0]) + v37;
      uint64_t v34 = (LODWORD(v144[0]) + v34);
    }
    else
    {
      unsigned int v33 = v37;
    }
  }
  if (!v33)
  {
LABEL_123:
    uint64_t v26 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    int v27 = 35;
    goto LABEL_124;
  }
  unsigned int v135 = v33;
  *(_DWORD *)(v13 + 488) -= v33;
  if (*(void *)(v13 + 24))
  {
    uint64_t all_stats = nw_protocol_tcp_get_all_stats();
    if (all_stats) {
      *(_DWORD *)(all_stats + 92) = *v23;
    }
  }
  uint64_t v63 = v23;
  if (*(void *)v13) {
    (*(void (**)(uint64_t, void))(*(void *)(v17 + 40) + 56))(v13, 0);
  }
  if (v138 != v135)
  {
    signed int v64 = __nwlog_obj();
    if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "tcp_get_northbound_frames";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v138;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v135;
      _os_log_impl(&dword_214653000, v64, OS_LOG_TYPE_ERROR, "%{public}s Failed to copy expected bytes, total_space %u != adj_space %u", buf, 0x18u);
    }
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v13 + 8) + 24))(v13, 1, v6);
  if ((v138 & 0x80000000) != 0) {
    goto LABEL_126;
  }
  if (*(void *)(v13 + 5232))
  {
    nw_protocol_tcp_update_metadata(a1);
    BOOL v65 = (*(_WORD *)(v13 + 376) & 0x20) != 0 && *v63 == 0;
    v139[0] = MEMORY[0x263EF8330];
    v139[1] = 0x40000000;
    v140 = __nw_protocol_tcp_get_input_frames_block_invoke;
    os_log_type_t v141 = &__block_descriptor_tmp_27;
    uint64_t v142 = v13;
    BOOL v143 = v65;
    uint64_t v85 = (uint64_t)*a6;
    do
    {
      if (!v85) {
        break;
      }
      uint64_t v86 = *(void *)(v85 + 32);
      char v87 = ((uint64_t (*)(void *))v140)(v139);
      uint64_t v85 = v86;
    }
    while ((v87 & 1) != 0);
  }
  nw_protocol_tcp_set_receive_low_water_mark(a1, 1);
  if ((*(unsigned char *)(v13 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      uint64_t v88 = __nwlog_tcp_log();
      if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136448002;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v13 + 604;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)int v147 = a3;
        *(_WORD *)&v147[4] = 1024;
        *(_DWORD *)int v148 = a4;
        *(_WORD *)&v148[4] = 1024;
        *(_DWORD *)&v148[6] = v129;
        __int16 v149 = 1024;
        int v150 = v34;
        __int16 v151 = 1024;
        unsigned int v152 = v135;
        __int16 v153 = 1024;
        unsigned int v154 = v138;
        _os_log_impl(&dword_214653000, v88, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Asked for min %u max %u bytes, max %u frames and got %d frames %u bytes, ret %u", buf, 0x3Au);
      }
    }
  }
  return v34;
}

uint64_t tcp_unlock(uint64_t a1, int a2)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  int v3 = *(_DWORD *)(a1 + 360);
  if (a2) {
    *(_DWORD *)(a1 + 360) = --v3;
  }
  if (v3 < 0)
  {
    if ((*(unsigned char *)(a1 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      int v5 = *(_DWORD *)(a1 + 360);
      *(_DWORD *)buf = 136447234;
      uint64_t v13 = "tcp_unlock";
      __int16 v14 = 2082;
      uint64_t v15 = a1 + 604;
      __int16 v16 = 2048;
      uint64_t v17 = a1;
      __int16 v18 = 1024;
      int v19 = v5;
      __int16 v20 = 2080;
      os_log_type_t v21 = "";
      uint64_t v6 = (void *)_os_log_send_and_compose_impl();
      if (!__nwlog_fault()) {
        goto LABEL_17;
      }
      int v8 = __nwlog_tcp_log();
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        goto LABEL_17;
      }
      int v9 = *(_DWORD *)(a1 + 360);
      *(_DWORD *)buf = 136447234;
      uint64_t v13 = "tcp_unlock";
      __int16 v14 = 2082;
      uint64_t v15 = a1 + 604;
      __int16 v16 = 2048;
      uint64_t v17 = a1;
      __int16 v18 = 1024;
      int v19 = v9;
      __int16 v20 = 2080;
      os_log_type_t v21 = "";
      uint64_t v10 = "%{public}s %{public}s tcp_unlock: so=%p usecount=%x lrh= %s, backtrace limit exceeded";
      goto LABEL_16;
    }
  }
  else
  {
    if (*(void *)a1) {
      return 0;
    }
    if ((*(unsigned char *)(a1 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      int v7 = *(_DWORD *)(a1 + 360);
      *(_DWORD *)buf = 136447234;
      uint64_t v13 = "tcp_unlock";
      __int16 v14 = 2082;
      uint64_t v15 = a1 + 604;
      __int16 v16 = 2048;
      uint64_t v17 = a1;
      __int16 v18 = 1024;
      int v19 = v7;
      __int16 v20 = 2080;
      os_log_type_t v21 = "";
      uint64_t v6 = (void *)_os_log_send_and_compose_impl();
      if (!__nwlog_fault()) {
        goto LABEL_17;
      }
      int v8 = __nwlog_tcp_log();
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        goto LABEL_17;
      }
      int v11 = *(_DWORD *)(a1 + 360);
      *(_DWORD *)buf = 136447234;
      uint64_t v13 = "tcp_unlock";
      __int16 v14 = 2082;
      uint64_t v15 = a1 + 604;
      __int16 v16 = 2048;
      uint64_t v17 = a1;
      __int16 v18 = 1024;
      int v19 = v11;
      __int16 v20 = 2080;
      os_log_type_t v21 = "";
      uint64_t v10 = "%{public}s %{public}s tcp_unlock: so=%p NO PCB usecount=%x lrh= %s, backtrace limit exceeded";
LABEL_16:
      _os_log_impl(&dword_214653000, v8, OS_LOG_TYPE_ERROR, v10, buf, 0x30u);
LABEL_17:
      if (v6) {
        free(v6);
      }
    }
  }
  return 22;
}

uint64_t tcp_lock(uint64_t *a1, int a2)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  int v3 = *((_DWORD *)a1 + 90);
  if (v3 < 0)
  {
    if ((*((unsigned char *)a1 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      uint64_t v5 = *a1;
      int v6 = *((_DWORD *)a1 + 90);
      *(_DWORD *)buf = 136447490;
      uint64_t v12 = "tcp_lock";
      __int16 v13 = 2082;
      uint64_t v14 = (uint64_t)a1 + 604;
      __int16 v15 = 2048;
      __int16 v16 = a1;
      __int16 v17 = 2048;
      uint64_t v18 = v5;
      __int16 v19 = 1024;
      int v20 = v6;
      __int16 v21 = 2080;
      uint64_t v22 = "";
      int v7 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        int v8 = __nwlog_tcp_log();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          uint64_t v9 = *a1;
          int v10 = *((_DWORD *)a1 + 90);
          *(_DWORD *)buf = 136447490;
          uint64_t v12 = "tcp_lock";
          __int16 v13 = 2082;
          uint64_t v14 = (uint64_t)a1 + 604;
          __int16 v15 = 2048;
          __int16 v16 = a1;
          __int16 v17 = 2048;
          uint64_t v18 = v9;
          __int16 v19 = 1024;
          int v20 = v10;
          __int16 v21 = 2080;
          uint64_t v22 = "";
          _os_log_impl(&dword_214653000, v8, OS_LOG_TYPE_ERROR, "%{public}s %{public}s tcp_lock: so=%p so_pcb=%p ref=%x lrh= %s, backtrace limit exceeded", buf, 0x3Au);
        }
      }
      if (v7) {
        free(v7);
      }
    }
    return 22;
  }
  else
  {
    uint64_t result = 0;
    if (a2) {
      *((_DWORD *)a1 + 90) = v3 + 1;
    }
  }
  return result;
}

void nw_protocol_tcp_set_receive_low_water_mark(uint64_t a1, int a2)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v4 = nw_protocol_downcast();
  if (!v4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v18 = "nw_protocol_tcp_set_receive_low_water_mark";
    __int16 v15 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      __int16 v16 = __nwlog_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_protocol_tcp_set_receive_low_water_mark";
        _os_log_impl(&dword_214653000, v16, OS_LOG_TYPE_ERROR, "%{public}s called with null tcp, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v15) {
      free(v15);
    }
    return;
  }
  uint64_t v5 = v4;
  if (a2 <= 1) {
    a2 = 1;
  }
  if (*(_DWORD *)(v4 + 496) == a2) {
    return;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 8) + 16))(v4, 1, v2);
  if ((~*(unsigned __int16 *)(v5 + 376) & 0x30) != 0)
  {
    if (a2 > 0) {
      goto LABEL_8;
    }
LABEL_19:
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 + 8) + 24))(v5, 1, v2);
    uint64_t v14 = __nwlog_obj();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136446722;
    uint64_t v18 = "nw_protocol_tcp_set_receive_low_water_mark";
    __int16 v19 = 1024;
    *(_DWORD *)int v20 = a2;
    *(_WORD *)&v20[4] = 1024;
    *(_DWORD *)&v20[6] = 22;
    int v10 = "%{public}s setsockopt SO_RCVLOWAT %u failed %{darwin.errno}d";
    int v11 = v14;
    os_log_type_t v12 = OS_LOG_TYPE_ERROR;
    uint32_t v13 = 24;
    goto LABEL_21;
  }
  if ((*(unsigned char *)(v5 + 365) & 0x20) == 0 || a2 < 1) {
    goto LABEL_19;
  }
LABEL_8:
  signed int v6 = *(_DWORD *)(v5 + 492) / 3u;
  if (a2 <= *(_DWORD *)(v5 + 492) / 3) {
    signed int v6 = a2;
  }
  if (v6 >= 0x4000) {
    signed int v6 = 0x4000;
  }
  if (v6 <= 1) {
    signed int v6 = 1;
  }
  *(_DWORD *)(v5 + 496) = v6;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 + 8) + 24))(v5, 1, v2);
  if ((*(unsigned char *)(v5 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      int v7 = __nwlog_tcp_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        int v8 = *(_DWORD *)(v5 + 496);
        int v9 = *(_DWORD *)(v5 + 488);
        *(_DWORD *)buf = 136446978;
        uint64_t v18 = "nw_protocol_tcp_set_receive_low_water_mark";
        __int16 v19 = 2082;
        *(void *)int v20 = v5 + 604;
        *(_WORD *)&v20[8] = 1024;
        int v21 = v8;
        __int16 v22 = 1024;
        int v23 = v9;
        int v10 = "%{public}s %{public}s so_rcv.sb_lowat %u sb_cc %u";
        int v11 = v7;
        os_log_type_t v12 = OS_LOG_TYPE_DEBUG;
        uint32_t v13 = 34;
LABEL_21:
        _os_log_impl(&dword_214653000, v11, v12, v10, buf, v13);
      }
    }
  }
}

uint64_t __nw_protocol_tcp_get_input_frames_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v49 = *MEMORY[0x263EF8340];
  int v3 = *(NSObject **)(*(void *)(a1 + 32) + 5232);
  if (*(unsigned char *)(a1 + 40))
  {
    BOOL v4 = *(void *)(a2 + 32) == 0;
    if (v3) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v8 = a2 + 204;
    if ((*(_WORD *)(a2 + 204) & 8) != 0) {
      return 1;
    }
    goto LABEL_15;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unsigned int v44 = "__nw_frame_set_metadata";
    __int16 v15 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v34 = __nwlog_obj();
        os_log_type_t v35 = type[0];
        if (os_log_type_enabled(v34, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          unsigned int v44 = "__nw_frame_set_metadata";
          uint64_t v18 = "%{public}s called with null frame";
LABEL_77:
          uint64_t v30 = v34;
          os_log_type_t v31 = v35;
          uint32_t v32 = 12;
LABEL_59:
          _os_log_impl(&dword_214653000, v30, v31, v18, buf, v32);
        }
      }
      else
      {
        uint64_t v34 = __nwlog_obj();
        os_log_type_t v35 = type[0];
        if (os_log_type_enabled(v34, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          unsigned int v44 = "__nw_frame_set_metadata";
          uint64_t v18 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_77;
        }
      }
    }
LABEL_60:
    if (v15) {
      free(v15);
    }
    return 1;
  }
  BOOL v4 = 0;
  if (!v3) {
    goto LABEL_10;
  }
LABEL_3:
  if (nw_protocol_metadata_is_ip(*(nw_protocol_metadata_t *)(*(void *)(a1 + 32) + 5232)))
  {
    *(unsigned char *)(a2 + 186) = *(unsigned char *)(a2 + 186) & 0xFC | nw_ip_metadata_get_ecn_flag(v3) & 3;
    unsigned int dscp_value = nw_ip_metadata_get_dscp_value();
    if (dscp_value < 0x40)
    {
      *(unsigned char *)(a2 + 184) = dscp_value;
LABEL_6:
      nw_service_class_t service_class = nw_ip_metadata_get_service_class(v3);
      if (service_class > nw_service_class_signaling) {
        int v7 = 0;
      }
      else {
        int v7 = dword_2146B29A0[service_class];
      }
      *(_DWORD *)(a2 + 176) = v7;
      *(_DWORD *)(a2 + 180) = nw_ip_metadata_get_fragmentation_value();
      goto LABEL_14;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unsigned int v44 = "__nw_frame_set_dscp_value";
    unsigned int v36 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        unsigned int v37 = __nwlog_obj();
        os_log_type_t v38 = type[0];
        if (!os_log_type_enabled(v37, type[0])) {
          goto LABEL_81;
        }
        *(_DWORD *)buf = 136446210;
        unsigned int v44 = "__nw_frame_set_dscp_value";
        uint64_t v39 = "%{public}s called with null (dscp_value <= _MAX_DSCP)";
      }
      else
      {
        unsigned int v37 = __nwlog_obj();
        os_log_type_t v38 = type[0];
        if (!os_log_type_enabled(v37, type[0])) {
          goto LABEL_81;
        }
        *(_DWORD *)buf = 136446210;
        unsigned int v44 = "__nw_frame_set_dscp_value";
        uint64_t v39 = "%{public}s called with null (dscp_value <= _MAX_DSCP), backtrace limit exceeded";
      }
      _os_log_impl(&dword_214653000, v37, v38, v39, buf, 0xCu);
    }
LABEL_81:
    if (v36) {
      free(v36);
    }
    goto LABEL_6;
  }
LABEL_14:
  uint64_t v8 = a2 + 204;
  if ((*(_WORD *)(a2 + 204) & 8) == 0)
  {
LABEL_15:
    int v9 = *(void **)(a2 + 168);
    if (v9)
    {
      nw_release(v9);
      *(void *)(a2 + 168) = 0;
    }
    uint64_t v10 = a2 + 120;
    if (v3)
    {
      *(void *)(a2 + 168) = nw_retain(v3);
      int v11 = *(unsigned __int16 *)(a2 + 204);
      int v12 = v11 | (*(unsigned __int8 *)(a2 + 206) << 16);
      if ((v11 & 0x20) == 0)
      {
        nw_protocol_metadata_copy_identifier();
        int v12 = *(unsigned __int16 *)(a2 + 204) | (*(unsigned __int8 *)(a2 + 206) << 16);
      }
      *(unsigned char *)(v8 + 2) = BYTE2(v12);
      *(_WORD *)uint64_t v8 = v12 | 8;
    }
    uint64_t v13 = *(void *)(a2 + 64);
    if (v4) {
      char v14 = 64;
    }
    else {
      char v14 = 0;
    }
    *(unsigned char *)(a2 + 186) = *(unsigned char *)(a2 + 186) & 0xBF | v14;
    if (!v13)
    {
      *(void *)(a2 + 64) = v10;
      *(void *)(a2 + 72) = v10;
      *(void *)(a2 + 120) = 0;
      *(void *)(a2 + 128) = a2 + 64;
      return 1;
    }
    if (v13 == v10) {
      return 1;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446722;
    unsigned int v44 = "__nw_frame_set_metadata";
    __int16 v45 = 2048;
    uint64_t v46 = v13;
    __int16 v47 = 2048;
    uint64_t v48 = a2 + 120;
    __int16 v15 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault()) {
      goto LABEL_60;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v16 = __nwlog_obj();
      os_log_type_t v17 = type[0];
      if (!os_log_type_enabled(v16, type[0])) {
        goto LABEL_60;
      }
      *(_DWORD *)buf = 136446722;
      unsigned int v44 = "__nw_frame_set_metadata";
      __int16 v45 = 2048;
      uint64_t v46 = v13;
      __int16 v47 = 2048;
      uint64_t v48 = v10;
      uint64_t v18 = "%{public}s Existing metadata %p doesn't match expected %p";
    }
    else
    {
      __int16 v16 = __nwlog_obj();
      os_log_type_t v17 = type[0];
      if (!os_log_type_enabled(v16, type[0])) {
        goto LABEL_60;
      }
      *(_DWORD *)buf = 136446722;
      unsigned int v44 = "__nw_frame_set_metadata";
      __int16 v45 = 2048;
      uint64_t v46 = v13;
      __int16 v47 = 2048;
      uint64_t v48 = v10;
      uint64_t v18 = "%{public}s Existing metadata %p doesn't match expected %p, backtrace limit exceeded";
    }
    uint64_t v30 = v16;
    os_log_type_t v31 = v17;
    uint32_t v32 = 32;
    goto LABEL_59;
  }
  memset(type, 0, sizeof(type));
  nw_protocol_metadata_copy_identifier();
  __int16 v19 = *(const unsigned __int8 **)(a2 + 64);
  if (!v19) {
    goto LABEL_47;
  }
  char v20 = 0;
  if (v4) {
    char v21 = 64;
  }
  else {
    char v21 = 0;
  }
  do
  {
    nw_protocol_definition_t v22 = nw_protocol_metadata_copy_definition(v3);
    int v23 = *((void *)v19 + 6);
    if (!v23) {
      goto LABEL_40;
    }
    nw_protocol_definition_t v24 = nw_protocol_metadata_copy_definition(v23);
    if (!MEMORY[0x2166A5D00](v22, v24) || uuid_compare((const unsigned __int8 *)type, v19 + 16))
    {
      if (!v24) {
        goto LABEL_40;
      }
LABEL_39:
      nw_release(v24);
      goto LABEL_40;
    }
    nw_retain(v3);
    int v25 = (void *)*((void *)v19 + 6);
    if (v25) {
      nw_release(v25);
    }
    *((void *)v19 + 6) = v3;
    *((unsigned char *)v19 + 66) = v19[66] & 0xBF | v21;
    char v20 = 1;
    if (v24) {
      goto LABEL_39;
    }
LABEL_40:
    if (v22) {
      nw_release(v22);
    }
    __int16 v19 = *(const unsigned __int8 **)v19;
  }
  while (v19);
  if (v20) {
    return 1;
  }
LABEL_47:
  uint64_t v26 = malloc_type_calloc(1uLL, 0x48uLL, 0xEAFB8F1AuLL);
  if (v26) {
    goto LABEL_48;
  }
  int v40 = __nwlog_obj();
  os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  unsigned int v44 = "strict_calloc";
  __int16 v45 = 2048;
  uint64_t v46 = 1;
  __int16 v47 = 2048;
  uint64_t v48 = 72;
  int v41 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (result)
  {
    __break(1u);
  }
  else
  {
    free(v41);
LABEL_48:
    v26[6] = nw_retain(v3);
    *((_OWORD *)v26 + 1) = *(_OWORD *)type;
    if (v4) {
      char v27 = 64;
    }
    else {
      char v27 = 0;
    }
    *((unsigned char *)v26 + 66) = *((unsigned char *)v26 + 66) & 0xBF | v27;
    uint64_t v28 = *(void *)(a2 + 64);
    *uint64_t v26 = v28;
    if (v28) {
      unsigned int v29 = (void *)(v28 + 8);
    }
    else {
      unsigned int v29 = (void *)(a2 + 72);
    }
    *unsigned int v29 = v26;
    *(void *)(a2 + 64) = v26;
    v26[1] = a2 + 64;
    return 1;
  }
  return result;
}

uint64_t tcp_seg_collect_acked(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v4 = a2;
    uint64_t v5 = result;
    while (1)
    {
      signed int v6 = *(void **)(v4 + 32);
      if ((int)a3 - *(_DWORD *)(v4 + 4) >= 0) {
        break;
      }
      uint64_t v4 = *(void *)(v4 + 32);
      if (!v6) {
        return result;
      }
    }
    tcp_seg_collect_acked_subtree(result, v6);
    uint64_t result = tcp_seg_collect_acked(v5, *(void *)(v4 + 40), a3);
    *(void *)(v4 + 56) = 0;
    int v7 = *(void **)(v5 + 2016);
    *(void *)(v4 + 64) = v7;
    *int v7 = v4;
    *(void *)(v5 + 2016) = v4 + 56;
  }
  return result;
}

uint64_t tcp_seg_collect_acked_subtree(uint64_t result, void *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    tcp_seg_collect_acked_subtree(result, a2[4]);
    uint64_t result = tcp_seg_collect_acked_subtree(v3, a2[5]);
    a2[7] = 0;
    uint64_t v4 = *(void **)(v3 + 2016);
    a2[8] = v4;
    *uint64_t v4 = a2;
    *(void *)(v3 + 2016) = a2 + 7;
  }
  return result;
}

uint64_t __nw_protocol_tcp_wake_send_block_invoke(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_DWORD *)(*(void *)(a1 + 32) + 5224) == 2)
  {
    int v3 = *(_DWORD *)(v2 + 384);
    int v4 = *(_DWORD *)(v2 + 388) - v3;
    int v5 = *(_DWORD *)(v2 + 484);
    int v6 = v5 - v3;
    if (v6 >= v4) {
      int v6 = v4;
    }
    if (v5) {
      int v4 = v6;
    }
    if ((v4 & ~(v4 >> 31)) >= *(_DWORD *)(v2 + 392))
    {
      nw_protocol_get_input_handler();
      nw_protocol_output_available_quiet();
    }
    else if ((*(unsigned char *)(v2 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        int v7 = __nwlog_tcp_log();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v8 = *(_DWORD **)(a1 + 40);
          int v9 = v8[98];
          int v10 = v8[96];
          int v11 = v8[97] - v10;
          int v12 = v8[121];
          int v13 = v12 - v10;
          if (v13 >= v11) {
            int v13 = v11;
          }
          if (v12) {
            int v14 = v13;
          }
          else {
            int v14 = v11;
          }
          int v18 = 136446978;
          __int16 v19 = "nw_protocol_tcp_wake_send_block_invoke";
          __int16 v20 = 2082;
          char v21 = (const char *)(v2 + 604);
          __int16 v22 = 1024;
          int v23 = v9;
          __int16 v24 = 1024;
          int v25 = v14 & ~(v14 >> 31);
          _os_log_impl(&dword_214653000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Ignoring wake low_water %u sbpace %u", (uint8_t *)&v18, 0x22u);
        }
      }
    }
  }
  else if (!v2 || (*(unsigned char *)(v2 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      __int16 v15 = __nwlog_tcp_log();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        __int16 v16 = "";
        if (v2) {
          __int16 v16 = (const char *)(v2 + 604);
        }
        int v18 = 136446466;
        __int16 v19 = "nw_protocol_tcp_wake_send_block_invoke";
        __int16 v20 = 2082;
        char v21 = v16;
        _os_log_impl(&dword_214653000, v15, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v18, 0x16u);
      }
    }
  }
  return nw_protocol_release();
}

void tcp_disconnect(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(*(void *)(a1 + 80) + 224);
  if (!v2 || (*(unsigned char *)(v2 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      int v7 = __nwlog_tcp_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v8 = (const char *)(v2 + 604);
        int v9 = *(_DWORD *)(v2 + 360);
        int v10 = *(_DWORD *)(a1 + 12);
        if (!v2) {
          uint64_t v8 = "";
        }
        int v11 = 136446978;
        int v12 = "tcp_disconnect";
        __int16 v13 = 2082;
        int v14 = v8;
        __int16 v15 = 1024;
        int v16 = v9;
        __int16 v17 = 1024;
        int v18 = v10;
        _os_log_impl(&dword_214653000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s so_usecount %u t_state %u", (uint8_t *)&v11, 0x22u);
      }
    }
  }
  if (*(_DWORD *)(v2 + 488) || *(_WORD *)(a1 + 224) || (*(unsigned char *)(v2 + 368) & 8) != 0) {
    goto LABEL_18;
  }
  if (*(int *)(a1 + 12) <= 3)
  {
    tcp_close(a1);
    return;
  }
  if ((*(unsigned char *)(v2 + 372) & 0x80) != 0 && !*(_DWORD *)(v2 + 16))
  {
LABEL_18:
    tcp_drop(a1, 0);
  }
  else
  {
    *(_WORD *)(v2 + 376) = *(_WORD *)(v2 + 376) & 0xFFC3 | 0x38;
    int v3 = *(void (***)(uint64_t))(v2 + 32);
    if (v3)
    {
      if (!*v3 || ((*v3)(v2), (int v3 = *(void (***)(uint64_t))(v2 + 32)) != 0))
      {
        int v4 = v3[3];
        if (v4) {
          v4(v2);
        }
      }
    }
    tcp_input_aggregate_end(*(void *)(*(void *)(a1 + 80) + 224), *(void *)(*(void *)(a1 + 80) + 240));
    sbflush(v2 + 488);
    uint64_t v6 = tcp_usrclosed(a1, v5);
    if (v6) {
      tcp_output(v6);
    }
  }
}

uint64_t nw_protocol_tcp_wake_send()
{
  return nw_queue_context_async();
}

void nw_protocol_tcp_connected(uint64_t a1)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v35 = "nw_protocol_tcp_connected";
    uint64_t v28 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      os_log_type_t v31 = __nwlog_obj();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v35 = "nw_protocol_tcp_connected";
        uint32_t v32 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_97:
        _os_log_impl(&dword_214653000, v31, OS_LOG_TYPE_ERROR, v32, buf, 0xCu);
      }
    }
LABEL_98:
    if (v28) {
      free(v28);
    }
    return;
  }
  uint64_t v2 = nw_protocol_downcast();
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v35 = "nw_protocol_tcp_connected";
    uint64_t v28 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      os_log_type_t v31 = __nwlog_obj();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v35 = "nw_protocol_tcp_connected";
        uint32_t v32 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_97;
      }
    }
    goto LABEL_98;
  }
  uint64_t v3 = v2;
  if ((*(unsigned char *)(v2 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      unsigned int v29 = __nwlog_tcp_log();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v35 = "nw_protocol_tcp_connected";
        __int16 v36 = 2082;
        uint64_t v37 = v3 + 604;
        _os_log_impl(&dword_214653000, v29, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s got a connected event from the lower layer", buf, 0x16u);
      }
    }
  }
  if ((*(_DWORD *)(v3 + 5224) - 1) >= 2)
  {
    if ((*(unsigned char *)(v3 + 828) & 2) != 0) {
      return;
    }
    if (!__nwlog_is_datapath_logging_enabled()) {
      return;
    }
    int v12 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
      return;
    }
    *(_DWORD *)buf = 136446466;
    os_log_type_t v35 = "nw_protocol_tcp_connected";
    __int16 v36 = 2082;
    uint64_t v37 = v3 + 604;
    int v11 = "%{public}s %{public}s skipping";
    goto LABEL_28;
  }
  if (*(void *)(v3 + 5216))
  {
    nw_protocol_get_identifier();
    uint64_t stats_region = nw_path_flow_registration_get_stats_region();
    *(void *)(v3 + 4128) = stats_region;
    if (stats_region) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  if (!*(void *)(v3 + 4128)) {
LABEL_8:
  }
    *(void *)(v3 + 4128) = &tcpstat;
LABEL_9:
  *(void *)(v3 + 4136) = nw_path_flow_registration_get_advisory_region();
  remote_endpoint = nw_protocol_get_remote_endpoint();
  if (!remote_endpoint)
  {
    if ((*(unsigned char *)(v3 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      uint64_t v15 = v3 + 604;
      *(_DWORD *)buf = 136446466;
      os_log_type_t v35 = "nw_protocol_tcp_connected";
      __int16 v36 = 2082;
      uint64_t v37 = v3 + 604;
      int v16 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        int v18 = __nwlog_tcp_log();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v35 = "nw_protocol_tcp_connected";
          __int16 v36 = 2082;
          uint64_t v37 = v15;
          uint64_t v19 = "%{public}s %{public}s get_remote_endpoint failed, backtrace limit exceeded";
LABEL_52:
          _os_log_impl(&dword_214653000, v18, OS_LOG_TYPE_ERROR, v19, buf, 0x16u);
        }
      }
LABEL_53:
      if (v16) {
        free(v16);
      }
    }
LABEL_55:
    nw_protocol_get_input_handler();
    nw_protocol_error();
    return;
  }
  address = nw_endpoint_get_address(remote_endpoint);
  if (!address)
  {
    if ((*(unsigned char *)(v3 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      uint64_t v17 = v3 + 604;
      *(_DWORD *)buf = 136446466;
      os_log_type_t v35 = "nw_protocol_tcp_connected";
      __int16 v36 = 2082;
      uint64_t v37 = v3 + 604;
      int v16 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        int v18 = __nwlog_tcp_log();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v35 = "nw_protocol_tcp_connected";
          __int16 v36 = 2082;
          uint64_t v37 = v17;
          uint64_t v19 = "%{public}s %{public}s nw_endpoint_get_address failed, backtrace limit exceeded";
          goto LABEL_52;
        }
      }
      goto LABEL_53;
    }
    goto LABEL_55;
  }
  if ((*(unsigned char *)(v3 + 5310) & 0x20) == 0)
  {
    int v7 = address;
    microuptime(v3 + 5248);
    __int16 v8 = *(_WORD *)(v3 + 376);
    if ((v8 & 4) == 0)
    {
      int v9 = *(_DWORD *)(v3 + 364);
      if ((*(unsigned char *)(v3 + 372) & 2) != 0)
      {
        if ((v9 & 8) == 0) {
          goto LABEL_47;
        }
      }
      else if ((v9 & 8) == 0)
      {
        if ((v8 & 6) != 0)
        {
LABEL_16:
          *(_DWORD *)(v3 + 5224) = 2;
          nw_protocol_tcp_input_available(a1);
          if (*MEMORY[0x263F144B0] != -1) {
            dispatch_once(MEMORY[0x263F144B0], &__block_literal_global_18);
          }
          if (*MEMORY[0x263F144A8] && kdebug_is_enabled()) {
            kdebug_trace();
          }
          nw_protocol_get_input_handler();
          nw_protocol_connected();
          if ((*(unsigned char *)(v3 + 828) & 2) == 0)
          {
            int v10 = __nwlog_tcp_log();
            if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 136446466;
              os_log_type_t v35 = "nw_protocol_tcp_connected";
              __int16 v36 = 2082;
              uint64_t v37 = v3 + 604;
              int v11 = "%{public}s %{public}s is already connected";
LABEL_40:
              __int16 v13 = v10;
              os_log_type_t v14 = OS_LOG_TYPE_INFO;
              goto LABEL_41;
            }
          }
          return;
        }
        int v23 = (*(uint64_t (**)(uint64_t, const sockaddr *))(*(void *)(*(void *)(v3 + 8) + 40) + 24))(v3, v7);
        if (v23)
        {
          int v20 = v23;
          *(_WORD *)(v3 + 376) &= ~4u;
          switch(v23)
          {
            case 1:
            case 6:
            case 13:
            case 49:
            case 50:
            case 51:
            case 60:
            case 61:
            case 64:
            case 65:
              __int16 v24 = __nwlog_obj();
              if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446466;
                os_log_type_t v35 = "nw_protocol_tcp_connected";
                __int16 v36 = 1024;
                LODWORD(v37) = v20;
                _os_log_impl(&dword_214653000, v24, OS_LOG_TYPE_ERROR, "%{public}s tcp_trigger_connect failed %{darwin.errno}d", buf, 0x12u);
              }
              goto LABEL_55;
            case 37:
              goto LABEL_63;
            case 56:
              goto LABEL_16;
            default:
              goto LABEL_48;
          }
        }
        if ((*(unsigned char *)(v3 + 5308) & 0x20) == 0)
        {
          nw_protocol_tcp_input_available(a1);
          return;
        }
        if (tcp_perf_measurement)
        {
          if ((*(unsigned char *)(v3 + 828) & 2) != 0) {
            goto LABEL_87;
          }
          if (!__nwlog_is_datapath_logging_enabled()) {
            goto LABEL_87;
          }
          int v25 = __nwlog_tcp_log();
          if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_87;
          }
          *(_DWORD *)buf = 136446466;
          os_log_type_t v35 = "nw_protocol_tcp_connected";
          __int16 v36 = 2082;
          uint64_t v37 = v3 + 604;
          uint64_t v26 = v25;
          os_log_type_t v27 = OS_LOG_TYPE_DEBUG;
        }
        else
        {
          if ((*(unsigned char *)(v3 + 828) & 2) != 0) {
            goto LABEL_87;
          }
          uint64_t v30 = __nwlog_tcp_log();
          if (!os_log_type_enabled(v30, OS_LOG_TYPE_INFO)) {
            goto LABEL_87;
          }
          *(_DWORD *)buf = 136446466;
          os_log_type_t v35 = "nw_protocol_tcp_connected";
          __int16 v36 = 2082;
          uint64_t v37 = v3 + 604;
          uint64_t v26 = v30;
          os_log_type_t v27 = OS_LOG_TYPE_INFO;
        }
        _os_log_impl(&dword_214653000, v26, v27, "%{public}s %{public}s tfo preconnect", buf, 0x16u);
LABEL_87:
        if (*MEMORY[0x263F144B0] != -1) {
          dispatch_once(MEMORY[0x263F144B0], &__block_literal_global_18);
        }
        if (*MEMORY[0x263F144A8] && kdebug_is_enabled()) {
          kdebug_trace();
        }
        nw_protocol_get_input_handler();
        nw_protocol_connected();
        return;
      }
      if ((*(unsigned char *)(v3 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
      {
        unsigned int v33 = __nwlog_tcp_log();
        int v20 = 102;
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          os_log_type_t v35 = "tcp_trigger_connect";
          __int16 v36 = 2082;
          uint64_t v37 = v3 + 604;
          __int16 v38 = 1024;
          LODWORD(v39) = 102;
          _os_log_impl(&dword_214653000, v33, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s defunct flow error (%d)", buf, 0x1Cu);
        }
        goto LABEL_48;
      }
LABEL_47:
      int v20 = 102;
LABEL_48:
      __nwlog_obj();
      *(_DWORD *)buf = 136446466;
      os_log_type_t v35 = "nw_protocol_tcp_connected";
      __int16 v36 = 1024;
      LODWORD(v37) = v20;
      char v21 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        __int16 v22 = __nwlog_obj();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v35 = "nw_protocol_tcp_connected";
          __int16 v36 = 1024;
          LODWORD(v37) = v20;
          _os_log_impl(&dword_214653000, v22, OS_LOG_TYPE_ERROR, "%{public}s tcp_trigger_connect failed %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
        }
      }
      if (v21) {
        free(v21);
      }
      goto LABEL_55;
    }
LABEL_63:
    if ((*(unsigned char *)(v3 + 828) & 2) != 0) {
      return;
    }
    if (!__nwlog_is_datapath_logging_enabled()) {
      return;
    }
    int v12 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
      return;
    }
    *(_DWORD *)buf = 136446466;
    os_log_type_t v35 = "nw_protocol_tcp_connected";
    __int16 v36 = 2082;
    uint64_t v37 = v3 + 604;
    int v11 = "%{public}s %{public}s is already connecting";
LABEL_28:
    __int16 v13 = v12;
    os_log_type_t v14 = OS_LOG_TYPE_DEBUG;
LABEL_41:
    _os_log_impl(&dword_214653000, v13, v14, v11, buf, 0x16u);
    return;
  }
  if ((*(unsigned char *)(v3 + 828) & 2) == 0)
  {
    int v10 = __nwlog_tcp_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v35 = "nw_protocol_tcp_connected";
      __int16 v36 = 2082;
      uint64_t v37 = v3 + 604;
      int v11 = "%{public}s %{public}s is accepting an inbound connection";
      goto LABEL_40;
    }
  }
}

void nw_protocol_tcp_input_available(uint64_t a1)
{
  uint64_t v75 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_input_available";
    os_log_type_t v58 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    HIBYTE(v68) = 0;
    if (!__nwlog_fault()) {
      goto LABEL_128;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v59 = __nwlog_obj();
      os_log_type_t v60 = type[0];
      if (!os_log_type_enabled(v59, type[0])) {
        goto LABEL_128;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_input_available";
      BOOL v61 = "%{public}s called with null protocol";
    }
    else
    {
      __int16 v59 = __nwlog_obj();
      os_log_type_t v60 = type[0];
      if (!os_log_type_enabled(v59, type[0])) {
        goto LABEL_128;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_input_available";
      BOOL v61 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_127;
  }
  uint64_t v1 = nw_protocol_downcast();
  if (!v1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_input_available";
    os_log_type_t v58 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    HIBYTE(v68) = 0;
    if (!__nwlog_fault()) {
      goto LABEL_128;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v59 = __nwlog_obj();
      os_log_type_t v60 = type[0];
      if (!os_log_type_enabled(v59, type[0])) {
        goto LABEL_128;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_input_available";
      BOOL v61 = "%{public}s called with null tcp";
    }
    else
    {
      __int16 v59 = __nwlog_obj();
      os_log_type_t v60 = type[0];
      if (!os_log_type_enabled(v59, type[0])) {
        goto LABEL_128;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_input_available";
      BOOL v61 = "%{public}s called with null tcp, backtrace limit exceeded";
    }
LABEL_127:
    _os_log_impl(&dword_214653000, v59, v60, v61, buf, 0xCu);
LABEL_128:
    if (v58) {
      free(v58);
    }
    return;
  }
  uint64_t v2 = v1;
  if (*(_DWORD *)(v1 + 5224))
  {
    uint64_t v3 = (dispatch_once_t *)MEMORY[0x263F144B0];
    if (*MEMORY[0x263F144B0] != -1) {
      dispatch_once(MEMORY[0x263F144B0], &__block_literal_global_18);
    }
    if (*MEMORY[0x263F144A8] && kdebug_is_enabled()) {
      kdebug_trace();
    }
    signed int v64 = (int *)(v2 + 488);
    uint64_t v63 = v2 + 604;
    *(void *)os_log_type_t type = 0;
    int v66 = type;
    while (1)
    {
LABEL_11:
      nw_protocol_get_output_handler();
      unsigned int input_frames = nw_protocol_get_input_frames();
      if (!input_frames) {
        return;
      }
      unsigned int v5 = input_frames;
      if (*v3 != -1) {
        dispatch_once(v3, &__block_literal_global_18);
      }
      if (*MEMORY[0x263F144A8] && kdebug_is_enabled())
      {
        nw_frame_array_unclaimed_length();
        kdebug_trace();
      }
      if (v5 > tcp_input_batch_size)
      {
        if ((*(unsigned char *)(v2 + 828) & 2) == 0)
        {
          uint64_t v57 = __nwlog_tcp_log();
          if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_input_available";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v63;
            __int16 v70 = 1024;
            *(_DWORD *)char v71 = tcp_input_batch_size;
            *(_WORD *)&v71[4] = 1024;
            *(_DWORD *)&v71[6] = v5;
            unsigned int v53 = "%{public}s %{public}s we asked for maximum %u frames, but got %u";
            signed int v54 = v57;
            os_log_type_t v55 = OS_LOG_TYPE_ERROR;
            uint32_t v56 = 34;
LABEL_111:
            _os_log_impl(&dword_214653000, v54, v55, v53, buf, v56);
          }
        }
        return;
      }
      if ((*(unsigned char *)(v2 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          __int16 v45 = __nwlog_tcp_log();
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_input_available";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v2 + 604;
            __int16 v70 = 1024;
            *(_DWORD *)char v71 = v5;
            _os_log_impl(&dword_214653000, v45, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s input available and we got %d frames", buf, 0x1Cu);
          }
        }
      }
      uint64_t v6 = *(uint64_t **)v2;
      if (!*(void *)v2)
      {
        if ((*(unsigned char *)(v2 + 828) & 2) == 0)
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            char v21 = __nwlog_tcp_log();
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "tcp_input_available";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v2 + 604;
              _os_log_impl(&dword_214653000, v21, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s inp == NULL || so->so_pcb == NULL", buf, 0x16u);
            }
          }
        }
LABEL_51:
        for (uint64_t i = *(void **)type; ; uint64_t i = v24)
        {
LABEL_52:
          if (!i) {
            goto LABEL_11;
          }
          int v23 = (void (*)(void *, void, uint64_t))i[10];
          __int16 v24 = (void *)i[4];
          if (!v23) {
            break;
          }
          uint64_t v25 = i[11];
          i[10] = 0;
          i[11] = 0;
          v23(i, 0, v25);
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        uint64_t v26 = (void *)_os_log_send_and_compose_impl();
        __int16 v68 = 4096;
        if (!__nwlog_fault()) {
          goto LABEL_69;
        }
        if (HIBYTE(v68) == 17)
        {
          os_log_type_t v27 = __nwlog_obj();
          os_log_type_t v28 = HIBYTE(v68);
          if (os_log_type_enabled(v27, HIBYTE(v68)))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            unsigned int v29 = v27;
            os_log_type_t v30 = v28;
            os_log_type_t v31 = "%{public}s called with null frame->finalizer";
            goto LABEL_68;
          }
          goto LABEL_69;
        }
        if ((_BYTE)v68)
        {
          os_log_t backtrace_string = (void *)__nw_create_backtrace_string();
          unsigned int v33 = __nwlog_obj();
          os_log_type_t v34 = HIBYTE(v68);
          os_log_type_t log = v33;
          BOOL v35 = os_log_type_enabled(v33, HIBYTE(v68));
          if (backtrace_string)
          {
            if (v35)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl(&dword_214653000, log, v34, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(backtrace_string);
            goto LABEL_69;
          }
          if (!v35)
          {
LABEL_69:
            if (v26) {
              free(v26);
            }
            uint64_t i = v24;
            goto LABEL_52;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          unsigned int v29 = log;
          os_log_type_t v30 = v34;
          os_log_type_t v31 = "%{public}s called with null frame->finalizer, no backtrace";
        }
        else
        {
          __int16 v36 = __nwlog_obj();
          os_log_type_t v37 = HIBYTE(v68);
          if (!os_log_type_enabled(v36, HIBYTE(v68))) {
            goto LABEL_69;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          unsigned int v29 = v36;
          os_log_type_t v30 = v37;
          os_log_type_t v31 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
        }
LABEL_68:
        _os_log_impl(&dword_214653000, v29, v30, v31, buf, 0xCu);
        goto LABEL_69;
      }
      char v7 = *(unsigned char *)(v2 + 828);
      if ((*(unsigned char *)(v2 + 364) & 8) != 0)
      {
        if ((*(unsigned char *)(v2 + 828) & 2) == 0)
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            unsigned int v51 = __nwlog_tcp_log();
            if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "tcp_input_available";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v2 + 604;
              __int16 v70 = 1024;
              *(_DWORD *)char v71 = 57;
              _os_log_impl(&dword_214653000, v51, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s defunct socket error (%d)", buf, 0x1Cu);
            }
          }
        }
        if (*(__int16 *)(v2 + 376) < 0) {
          sb_empty_assert(v64, (uint64_t)"tcp_input_available");
        }
        goto LABEL_51;
      }
      __int16 v8 = v3;
      if ((*(unsigned char *)(v2 + 828) & 1) == 0)
      {
        uint64_t v9 = nw_tcp_access_globals(v2);
        ++*(_DWORD *)(v9 + 288);
        uint64_t v10 = v6[28];
        if (*(void *)(v10 + 520))
        {
          if ((*(unsigned char *)(v10 + 828) & 2) == 0)
          {
            int v11 = __nwlog_tcp_log();
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "tcp_input_aggregate_begin";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v10 + 604;
              _os_log_impl(&dword_214653000, v11, OS_LOG_TYPE_ERROR, "%{public}s %{public}s tcp_input_aggregate_begin sb_mb_aggregate not empty", buf, 0x16u);
            }
          }
        }
      }
      uint64_t v12 = v6[30];
      if (*(_DWORD *)(v12 + 12) == 4 && *(int *)(sysctls + 100) >= 1) {
        *(_DWORD *)(v12 + 740) |= 0x2000000u;
      }
      *(void *)(v12 + 656) = 0;
      *(void *)(v12 + 664) = v12 + 656;
      *(_DWORD *)(v12 + 672) = 0;
      uint64_t v13 = v6[28];
      if (!v13 || (*(unsigned char *)(v13 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          uint64_t v46 = __nwlog_tcp_log();
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
          {
            __int16 v47 = (const char *)(v13 + 604);
            if (!v13) {
              __int16 v47 = "";
            }
            uint64_t v48 = "on";
            if ((*(_DWORD *)(v12 + 740) & 0x2000000) == 0) {
              uint64_t v48 = "off";
            }
            uint64_t v49 = tcpstates[*(int *)(v12 + 12)];
            int v50 = *(_DWORD *)(sysctls + 100);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "tcp_output_batch_acks_begin";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v47;
            __int16 v70 = 2082;
            *(void *)char v71 = v48;
            *(_WORD *)&v71[8] = 2082;
            int v72 = v49;
            __int16 v73 = 1024;
            int v74 = v50;
            _os_log_impl(&dword_214653000, v46, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s %{public}s t_state %{public}s tcp_packet_chaining %d", buf, 0x30u);
          }
        }
      }
      os_log_type_t v14 = *(void **)type;
      if (!*(void *)type)
      {
        tcp_output_batch_acks_end((uint64_t)v6);
        goto LABEL_92;
      }
      char v15 = 0;
      char v16 = 0;
      char v17 = 0;
      do
      {
        *(void *)buf = 0;
        *(void *)&buf[8] = buf;
        do
        {
          uint64_t v18 = v14[4];
          uint64_t v19 = (void *)v14[5];
          if (v18)
          {
            *(void *)(v18 + 40) = v19;
            uint64_t v19 = (void *)v14[5];
          }
          else
          {
            int v66 = (os_log_type_t *)v14[5];
          }
          *uint64_t v19 = v18;
          int v20 = *(void **)&buf[8];
          v14[4] = 0;
          v14[5] = v20;
          *int v20 = v14;
          *(void *)&buf[8] = v14 + 4;
          os_log_type_t v14 = *(void **)type;
        }
        while (*(void *)type && (*(_WORD *)(*(void *)type + 204) & 0x40) != 0);
        __int16 v68 = 0;
        BOOL v67 = 0;
        tcp_input((uint64_t *)buf, v6[56], (uint64_t)v6, (unsigned char *)&v68 + 1, &v68, &v67);
        v16 |= (_BYTE)v68 != 0;
        v17 |= HIBYTE(v68) != 0;
        v15 |= v67;
        os_log_type_t v14 = *(void **)type;
      }
      while (*(void *)type);
      tcp_output_batch_acks_end((uint64_t)v6);
      if (v16)
      {
        uint64_t v38 = *(void *)(v2 + 32);
        if (v38)
        {
          uint64_t v39 = *(void (**)(uint64_t))(v38 + 48);
          if (v39) {
            v39(v2);
          }
        }
      }
      if ((v15 & 1) == 0) {
        goto LABEL_91;
      }
      if ((*(_DWORD *)(v2 + 552) && (uint64_t v40 = v2 + 528, *(void *)(v2 + 520))
         || *v64 && (uint64_t v40 = v2 + 512, *(void *)(v2 + 504)))
        && (uint64_t v41 = **(void **)(*(void *)v40 + 8)) != 0)
      {
        if ((*(unsigned char *)(v2 + 828) & 2) == 0)
        {
          uint64_t v42 = __nwlog_tcp_log();
          if (os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "tcp_input_carry_wake_packet";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v2 + 604;
            _os_log_impl(&dword_214653000, v42, OS_LOG_TYPE_INFO, "%{public}s %{public}s found data to carry wake packet", buf, 0x16u);
          }
        }
        *(_WORD *)(v41 + 204) |= 0x4000u;
        if (v17) {
          goto LABEL_10;
        }
LABEL_92:
        uint64_t v3 = v8;
        if ((v7 & 1) == 0)
        {
          uint64_t v44 = nw_tcp_access_globals(v2);
          tcp_coalesce_timer_updates_end(v44);
          tcp_input_aggregate_end(v6[28], v6[30]);
        }
      }
      else
      {
        if ((*(unsigned char *)(v2 + 828) & 2) == 0)
        {
          uint64_t v43 = __nwlog_tcp_log();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "tcp_input_carry_wake_packet";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v2 + 604;
            _os_log_impl(&dword_214653000, v43, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s no data to carry wake packet", buf, 0x16u);
          }
        }
LABEL_91:
        if ((v17 & 1) == 0) {
          goto LABEL_92;
        }
LABEL_10:
        *(unsigned char *)(v2 + 828) |= 1u;
        uint64_t v3 = v8;
      }
    }
  }
  if ((*(unsigned char *)(v1 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      uint64_t v52 = __nwlog_tcp_log();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_input_available";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v2 + 604;
        unsigned int v53 = "%{public}s %{public}s skipping";
        signed int v54 = v52;
        os_log_type_t v55 = OS_LOG_TYPE_DEBUG;
        uint32_t v56 = 22;
        goto LABEL_111;
      }
    }
  }
}

void nw_protocol_tcp_input_flush(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v1 = nw_protocol_downcast();
    if (v1)
    {
      uint64_t v2 = v1;
      if (*(unsigned char *)(v1 + 828))
      {
        uint64_t v3 = *(void *)v1;
        uint64_t v4 = nw_tcp_access_globals(v1);
        tcp_coalesce_timer_updates_end(v4);
        uint64_t v5 = *(void *)(v2 + 32);
        if (v5)
        {
          uint64_t v6 = *(void (**)(uint64_t))(v5 + 24);
          if (v6) {
            v6(v2);
          }
        }
        if (v3) {
          tcp_input_aggregate_end(*(void *)(v3 + 224), *(void *)(v3 + 240));
        }
        *(unsigned char *)(v2 + 828) &= ~1u;
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v11 = "nw_protocol_tcp_input_flush";
    char v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      __int16 v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        int v11 = "nw_protocol_tcp_input_flush";
        uint64_t v9 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_19;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v11 = "nw_protocol_tcp_input_flush";
    char v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      __int16 v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        int v11 = "nw_protocol_tcp_input_flush";
        uint64_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_19:
        _os_log_impl(&dword_214653000, v8, OS_LOG_TYPE_ERROR, v9, buf, 0xCu);
      }
    }
  }
  if (v7) {
    free(v7);
  }
}

uint64_t tcp_input_aggregate_end(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  uint64_t v15 = 0;
  char v16 = 0;
  if (__nwlog_is_datapath_logging_enabled())
  {
    uint64_t v12 = __nwlog_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      int v13 = *(_DWORD *)(a1 + 552);
      int v14 = *(_DWORD *)(a1 + 488);
      *(_DWORD *)buf = 136446722;
      uint64_t v18 = "tcp_input_aggregate_end";
      __int16 v19 = 1024;
      int v20 = v13;
      __int16 v21 = 1024;
      int v22 = v14;
      _os_log_impl(&dword_214653000, v12, OS_LOG_TYPE_DEBUG, "%{public}s start sb_agg_bytes %u sb_cc %u", buf, 0x18u);
    }
  }
  if (*(_DWORD *)(a1 + 552))
  {
    while (*(void *)(a1 + 520))
    {
      uint64_t v15 = 0;
      char v16 = &v15;
      if (!tcp_input_get_aggregate_frames(a1, *(_DWORD *)(a1 + 824), 0, 0, (uint64_t)&v15))
      {
        uint64_t v9 = __nwlog_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          int v10 = *(_DWORD *)(a1 + 548);
          int v11 = *(_DWORD *)(a1 + 552);
          *(_DWORD *)buf = 136446722;
          uint64_t v18 = "tcp_input_aggregate_end";
          __int16 v19 = 1024;
          int v20 = v10;
          __int16 v21 = 1024;
          int v22 = v11;
          _os_log_impl(&dword_214653000, v9, OS_LOG_TYPE_ERROR, "%{public}s tcp_input_get_aggregate_frame failed, drop %u segments of length %u", buf, 0x18u);
        }
        tcp_drop(a2, 53);
        return 0xFFFFFFFFLL;
      }
      if (v15)
      {
        **(void **)(a1 + 512) = v15;
        uint64_t v4 = v16;
        *(void *)(v15 + 40) = *(void *)(a1 + 512);
        *(void *)(a1 + 512) = v4;
        uint64_t v15 = 0;
        char v16 = &v15;
      }
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v5 = __nwlog_obj();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          int v6 = *(_DWORD *)(a1 + 552);
          int v7 = *(_DWORD *)(a1 + 488);
          *(_DWORD *)buf = 136446722;
          uint64_t v18 = "tcp_input_aggregate_end";
          __int16 v19 = 1024;
          int v20 = v6;
          __int16 v21 = 1024;
          int v22 = v7;
          _os_log_impl(&dword_214653000, v5, OS_LOG_TYPE_DEBUG, "%{public}s added agg frame to sb_mb sb_agg_bytes %u sb_cc %u", buf, 0x18u);
        }
      }
      if (!*(_DWORD *)(a1 + 552)) {
        break;
      }
    }
  }
  sb_agg_empty_verify((int *)(a1 + 488), (uint64_t)"tcp_input_aggregate_end");
  return 0;
}

void sb_agg_empty_verify(int *a1, uint64_t a2)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  if (a1[15])
  {
    if (!a1[16])
    {
      for (uint64_t i = *((void *)a1 + 4); i; uint64_t i = *((void *)a1 + 4))
      {
        int v19 = a1[15];
        if (!v19)
        {
          uint64_t v20 = *((void *)a1 + 9);
          if (v20 && (*(unsigned char *)(v20 + 828) & 2) != 0)
          {
            int v19 = 0;
          }
          else
          {
            __int16 v21 = __nwlog_tcp_log();
            os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
            int v22 = a1[12];
            int v23 = *a1;
            __int16 v24 = (const char *)(v20 + 604);
            if (!v20) {
              __int16 v24 = "";
            }
            int v25 = a1[15];
            int v26 = a1[16];
            *(_DWORD *)buf = 136447746;
            signed int v54 = "sb_agg_empty_verify";
            __int16 v55 = 2082;
            uint32_t v56 = v24;
            __int16 v57 = 2082;
            uint64_t v58 = a2;
            __int16 v59 = 1024;
            int v60 = v22;
            __int16 v61 = 1024;
            int v62 = v23;
            __int16 v63 = 1024;
            int v64 = v25;
            __int16 v65 = 1024;
            int v66 = v26;
            os_log_type_t v27 = (void *)_os_log_send_and_compose_impl();
            if (__nwlog_abort()) {
              goto LABEL_54;
            }
            free(v27);
            int v19 = a1[15];
          }
        }
        a1[15] = v19 - 1;
        int v28 = *(_DWORD *)(i + 52);
        if (v28)
        {
          int v29 = *(_DWORD *)(i + 60) + *(_DWORD *)(i + 56);
          int v30 = v28 - v29;
          if (v28 != v29)
          {
            uint64_t v31 = *((void *)a1 + 9);
            if (!v31 || (*(unsigned char *)(v31 + 828) & 2) == 0)
            {
              uint32_t v32 = __nwlog_tcp_log();
              os_log_type_enabled(v32, OS_LOG_TYPE_ERROR);
              int v33 = a1[12];
              int v34 = *a1;
              BOOL v35 = (const char *)(v31 + 604);
              if (!v31) {
                BOOL v35 = "";
              }
              int v36 = a1[15];
              int v37 = a1[16];
              *(_DWORD *)buf = 136448002;
              signed int v54 = "sb_agg_empty_verify";
              __int16 v55 = 2082;
              uint32_t v56 = v35;
              __int16 v57 = 2082;
              uint64_t v58 = a2;
              __int16 v59 = 1024;
              int v60 = v30;
              __int16 v61 = 1024;
              int v62 = v33;
              __int16 v63 = 1024;
              int v64 = v34;
              __int16 v65 = 1024;
              int v66 = v36;
              __int16 v67 = 1024;
              LODWORD(v68) = v37;
              uint64_t v38 = (void *)_os_log_send_and_compose_impl();
              if (__nwlog_abort()) {
                goto LABEL_54;
              }
              free(v38);
            }
          }
        }
        if (nw_frame_is_wake_packet())
        {
          uint64_t v39 = *((void *)a1 + 9);
          if (!v39 || (*(unsigned char *)(v39 + 828) & 2) == 0)
          {
            uint64_t v40 = __nwlog_tcp_log();
            if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
            {
              uint64_t v41 = (const char *)(v39 + 604);
              *(_DWORD *)buf = 136446466;
              if (!v39) {
                uint64_t v41 = "";
              }
              signed int v54 = "sb_agg_empty_verify";
              __int16 v55 = 2082;
              uint32_t v56 = v41;
              _os_log_impl(&dword_214653000, v40, OS_LOG_TYPE_INFO, "%{public}s %{public}s removing empty wake packet", buf, 0x16u);
            }
          }
        }
        uint64_t v42 = *(void *)(i + 32);
        uint64_t v43 = *(void **)(i + 40);
        if (v42)
        {
          *(void *)(v42 + 40) = v43;
          uint64_t v43 = *(void **)(i + 40);
        }
        else
        {
          *((void *)a1 + 5) = v43;
        }
        *uint64_t v43 = v42;
        uint64_t v44 = *(void (**)(uint64_t, uint64_t, uint64_t))(i + 80);
        *(void *)(i + 32) = 0;
        *(void *)(i + 40) = 0;
        if (v44)
        {
          uint64_t v45 = *(void *)(i + 88);
          *(void *)(i + 80) = 0;
          *(void *)(i + 88) = 0;
          v44(i, 1, v45);
        }
        else
        {
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          signed int v54 = "__nw_frame_finalize";
          uint64_t v46 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            __int16 v47 = __nwlog_obj();
            if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              signed int v54 = "__nw_frame_finalize";
              _os_log_impl(&dword_214653000, v47, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
            }
          }
          if (v46) {
            free(v46);
          }
        }
      }
    }
  }
  if (a1[16])
  {
    uint64_t v4 = *((void *)a1 + 9);
    if ((~*(unsigned __int16 *)(v4 + 376) & 0x30) != 0)
    {
      if ((*(unsigned char *)(v4 + 828) & 2) != 0) {
        return;
      }
      int v11 = __nwlog_tcp_log();
      os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
      int v12 = a1[12];
      int v13 = *a1;
      int v14 = a1[15];
      int v15 = a1[16];
      *(_DWORD *)buf = 136447746;
      signed int v54 = "sb_agg_empty_verify";
      __int16 v55 = 2082;
      uint32_t v56 = (const char *)(v4 + 604);
      __int16 v57 = 2082;
      uint64_t v58 = a2;
      __int16 v59 = 1024;
      int v60 = v12;
      __int16 v61 = 1024;
      int v62 = v13;
      __int16 v63 = 1024;
      int v64 = v14;
      __int16 v65 = 1024;
      int v66 = v15;
      uint64_t v16 = _os_log_send_and_compose_impl();
      if (__nwlog_abort()) {
LABEL_54:
      }
        __break(1u);
      char v17 = (void *)v16;
      goto LABEL_52;
    }
    if ((*(unsigned char *)(v4 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      int v5 = a1[12];
      int v6 = (const char *)(v4 + 604);
      int v7 = *a1;
      int v8 = a1[15];
      int v9 = a1[16];
      *(_DWORD *)buf = 136447746;
      signed int v54 = "sb_agg_empty_verify";
      __int16 v55 = 2082;
      uint32_t v56 = (const char *)(v4 + 604);
      __int16 v57 = 2082;
      uint64_t v58 = a2;
      __int16 v59 = 1024;
      int v60 = v5;
      __int16 v61 = 1024;
      int v62 = v7;
      __int16 v63 = 1024;
      int v64 = v8;
      __int16 v65 = 1024;
      int v66 = v9;
      uint64_t v10 = _os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        uint64_t v48 = __nwlog_tcp_log();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
        {
          int v49 = a1[12];
          int v50 = *a1;
          int v51 = a1[15];
          int v52 = a1[16];
          *(_DWORD *)buf = 136447746;
          signed int v54 = "sb_agg_empty_verify";
          __int16 v55 = 2082;
          uint32_t v56 = v6;
          __int16 v57 = 2082;
          uint64_t v58 = a2;
          __int16 v59 = 1024;
          int v60 = v49;
          __int16 v61 = 1024;
          int v62 = v50;
          __int16 v63 = 1024;
          int v64 = v51;
          __int16 v65 = 1024;
          int v66 = v52;
          _os_log_impl(&dword_214653000, v48, OS_LOG_TYPE_ERROR, "%{public}s %{public}s %{public}s: sb flags 0x%x cc %d agg_cnt %u agg_bytes %u, backtrace limit exceeded", buf, 0x38u);
        }
      }
      if (v10)
      {
        char v17 = (void *)v10;
LABEL_52:
        free(v17);
      }
    }
  }
}

void tcp_coalesce_timer_updates_end(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 288);
  if (!v2)
  {
    uint64_t v3 = __nwlog_obj();
    os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
    uint64_t v4 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }
    free(v4);
    int v2 = *(_DWORD *)(a1 + 288);
  }
  int v5 = v2 - 1;
  *(_DWORD *)(a1 + 288) = v5;
  if (!v5 && (*(unsigned char *)(a1 + 310) & 4) != 0) {
    tcp_process_timerlist(a1);
  }
}

void nw_protocol_tcp_wake_read(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD **)(a1 + 40);
  if (v2[1306] == 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 488);
    if (v3 >= v2[124] || v3 >= *(_DWORD *)(a1 + 496))
    {
      nw_protocol_upcast();
      nw_protocol_get_input_handler();
      if (nw_protocol_input_available_is_valid())
      {
        if ((*(unsigned char *)(a1 + 828) & 2) == 0)
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            int v8 = __nwlog_tcp_log();
            if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
            {
              int v9 = *(_DWORD *)(a1 + 488);
              int v10 = 136446722;
              int v11 = "nw_protocol_tcp_wake_read";
              __int16 v12 = 2082;
              uint64_t v13 = a1 + 604;
              __int16 v14 = 1024;
              int v15 = v9;
              _os_log_impl(&dword_214653000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s waking the input_handler with %d bytes in our queue", (uint8_t *)&v10, 0x1Cu);
            }
          }
        }
        nw_protocol_get_input_handler();
        nw_protocol_input_available();
      }
    }
    else if ((*(unsigned char *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
    {
      uint64_t v4 = __nwlog_tcp_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        int v5 = v2[124];
        int v6 = v2[122];
        int v10 = 136446978;
        int v11 = "nw_protocol_tcp_wake_read";
        __int16 v12 = 2082;
        uint64_t v13 = a1 + 604;
        __int16 v14 = 1024;
        int v15 = v5;
        __int16 v16 = 1024;
        int v17 = v6;
        _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s ignoring wake low_water %u sb_cc %u", (uint8_t *)&v10, 0x22u);
      }
    }
  }
  else if ((*(unsigned char *)(a1 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      int v7 = __nwlog_tcp_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        int v10 = 136446466;
        int v11 = "nw_protocol_tcp_wake_read";
        __int16 v12 = 2082;
        uint64_t v13 = a1 + 604;
        _os_log_impl(&dword_214653000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v10, 0x16u);
      }
    }
  }
}

uint64_t tcp_usr_connect(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)a1;
  if (!*(void *)a1) {
    return 22;
  }
  if (*(_DWORD *)(v2 + 232) == 3)
  {
    uint64_t v4 = *(unsigned __int16 *)(a1 + 378);
    if (*(_WORD *)(a1 + 378))
    {
      *(_WORD *)(a1 + 378) = 0;
      __nwlog_obj();
      uint64_t v5 = a1 + 604;
      *(_DWORD *)buf = 136446722;
      int v15 = "tcp_usr_connect";
      __int16 v16 = 2082;
      uint64_t v17 = a1 + 604;
      __int16 v18 = 1024;
      int v19 = v4;
      int v6 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        __int16 v12 = __nwlog_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446722;
          int v15 = "tcp_usr_connect";
          __int16 v16 = 2082;
          uint64_t v17 = v5;
          __int16 v18 = 1024;
          int v19 = v4;
          _os_log_impl(&dword_214653000, v12, OS_LOG_TYPE_ERROR, "%{public}s %{public}s this should be handled by user_north_signal_error %{darwin.errno}d, backtrace limit exceeded", buf, 0x1Cu);
        }
      }
      if (v6) {
        free(v6);
      }
      return v4;
    }
    return 22;
  }
  uint64_t v8 = *(void *)(v2 + 240);
  if ((*(unsigned char *)(a1 + 368) & 0x10) != 0 && (*(unsigned char *)(sysctls + 160) & 2) != 0) {
    *(_DWORD *)(v8 + 740) |= 0x400000u;
  }
  uint64_t v9 = nw_tcp_access_globals(a1);
  calculate_tcp_clock(v9);
  if (*(unsigned char *)(a2 + 1) && (*(unsigned char *)(a2 + 1) != 2 || (*(_DWORD *)(a2 + 4) & 0xF0) == 0xE0)) {
    return 47;
  }
  uint64_t v4 = tcp_connect(v8, a2);
  if (v4) {
    return v4;
  }
  uint64_t v10 = *(void *)(*(void *)a1 + 240);
  (*(void (**)(void))(*(void *)(*(void *)(v10 + 80) + 2136) + 64))(*(void *)(a1 + 24));
  if ((*(unsigned char *)(a1 + 368) & 0x20) != 0)
  {
    tcp_mss(v10, -1, 0);
    uint64_t v4 = 0;
    int v13 = *(_DWORD *)(v10 + 196);
    *(_DWORD *)(v10 + 140) = v13;
    *(_DWORD *)(v10 + 252) = v13;
    return v4;
  }

  return tcp_output(v10);
}

void nw_proto_tcp_notify_segmentation_offload(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v1 = (unsigned char *)nw_protocol_downcast();
    if (v1)
    {
      uint64_t v2 = v1;
      if ((v1[5310] & 0x40) != 0)
      {
        if (*(void *)v1)
        {
          if ((*(unsigned char *)(*(void *)v1 + 2236) & 2) != 0) {
            tso_max_segment_size_int v6 = nw_path_get_tso_max_segment_size_v6();
          }
          else {
            tso_max_segment_size_int v6 = nw_path_get_tso_max_segment_size_v4();
          }
          BOOL v5 = tso_max_segment_size_v6 != 0;
        }
        else
        {
          BOOL v5 = 0;
        }
        if ((v2[828] & 2) == 0)
        {
          int v6 = __nwlog_tcp_log();
          if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446722;
            int v11 = "nw_proto_tcp_notify_segmentation_offload";
            __int16 v12 = 2082;
            int v13 = v2 + 604;
            __int16 v14 = 1024;
            BOOL v15 = v5;
            _os_log_impl(&dword_214653000, v6, OS_LOG_TYPE_INFO, "%{public}s %{public}s notifying segmentation offload value %d", buf, 0x1Cu);
          }
        }
        nw_protocol_get_output_handler();
        nw_protocol_notify_quiet();
      }
      else if ((v1[828] & 2) == 0)
      {
        unsigned int v3 = __nwlog_tcp_log();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446466;
          int v11 = "nw_proto_tcp_notify_segmentation_offload";
          __int16 v12 = 2082;
          int v13 = v2 + 604;
          _os_log_impl(&dword_214653000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s segmentation offload notification not enabled", buf, 0x16u);
        }
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v11 = "nw_proto_tcp_notify_segmentation_offload";
    int v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        int v11 = "nw_proto_tcp_notify_segmentation_offload";
        uint64_t v9 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_26;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v11 = "nw_proto_tcp_notify_segmentation_offload";
    int v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        int v11 = "nw_proto_tcp_notify_segmentation_offload";
        uint64_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_26:
        _os_log_impl(&dword_214653000, v8, OS_LOG_TYPE_ERROR, v9, buf, 0xCu);
      }
    }
  }
  if (v7) {
    free(v7);
  }
}

void nw_protocol_tcp_wake_connected(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 40);
  if (*(_DWORD *)(v3 + 5224) >= 2u)
  {
    if ((*(unsigned char *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
    {
      uint64_t v4 = __nwlog_tcp_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_wake_connected";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 604;
        _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
      }
    }
    return;
  }
  *(_DWORD *)(v3 + 5224) = 2;
  if (*MEMORY[0x263F144B0] != -1) {
    dispatch_once(MEMORY[0x263F144B0], &__block_literal_global_18);
  }
  if (*MEMORY[0x263F144A8] && kdebug_is_enabled()) {
    kdebug_trace();
  }
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  microuptime((uint64_t)&v19);
  uint64_t v5 = v19 - *(void *)(v3 + 5248);
  int v6 = v20 - *(_DWORD *)(v3 + 5256);
  LODWORD(v20) = v6;
  if (v6 < 0)
  {
    uint64_t v8 = -1;
    int v7 = 1000000;
  }
  else
  {
    if (v6 <= 0xF423F) {
      goto LABEL_16;
    }
    int v7 = -1000000;
    uint64_t v8 = 1;
  }
  v5 += v8;
  uint64_t v19 = v5;
  v6 += v7;
LABEL_16:
  *(_DWORD *)(v3 + 5296) = v6 + 1000000 * v5;
  nw_protocol_upcast();
  nw_protocol_get_input_handler();
  if (nw_protocol_get_parameters())
  {
    uint64_t v9 = nw_parameters_copy_protocol_options_legacy();
    if (v9)
    {
      uint64_t v10 = (void *)v9;
      if (nw_protocol_options_is_tcp())
      {
        int maximum_segment_size = nw_tcp_options_get_maximum_segment_size();
        int v18 = maximum_segment_size;
        if (maximum_segment_size)
        {
          if ((*(unsigned char *)(a1 + 828) & 2) == 0)
          {
            int v12 = maximum_segment_size;
            int v13 = __nwlog_tcp_log();
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_wake_connected";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = a1 + 604;
              *(_WORD *)&unsigned char buf[22] = 1024;
              LODWORD(v22) = v12;
              _os_log_impl(&dword_214653000, v13, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s setting MSS to %d", buf, 0x1Cu);
            }
          }
          *(void *)buf = 0x600000001;
          *(void *)&buf[8] = 2;
          *(void *)&buf[16] = &v18;
          uint64_t v22 = 4;
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v3 + 8) + 16))(v3, 1, v1);
          if ((~*(unsigned __int16 *)(v3 + 376) & 0x30) != 0 || (*(unsigned char *)(v3 + 365) & 0x20) != 0) {
            int v14 = tcp_ctloutput(v3, (uint64_t)buf);
          }
          else {
            int v14 = 22;
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v3 + 8) + 24))(v3, 1, v1);
          if (v14)
          {
            __nwlog_obj();
            uint64_t v15 = a1 + 604;
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_wake_connected";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = a1 + 604;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v22) = v14;
            uint64_t v16 = (void *)_os_log_send_and_compose_impl();
            if (__nwlog_fault())
            {
              uint64_t v17 = __nwlog_obj();
              if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_protocol_tcp_wake_connected";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v15;
                *(_WORD *)&unsigned char buf[22] = 1024;
                LODWORD(v22) = v14;
                _os_log_impl(&dword_214653000, v17, OS_LOG_TYPE_ERROR, "%{public}s %{public}s tcp_setsockopt TCP_MAXSEG failed %{darwin.errno}d, backtrace limit exceeded", buf, 0x1Cu);
              }
            }
            if (v16) {
              free(v16);
            }
          }
        }
      }
      nw_release(v10);
    }
  }
  nw_protocol_get_input_handler();
  nw_protocol_connected_quiet();
}

uint64_t tcp_usrclosed(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v24 = *MEMORY[0x263EF8340];
  int v3 = *(_DWORD *)(a1 + 12);
  switch(v3)
  {
    case 0:
    case 1:
    case 2:
      tcp_close(a1);
      return 0;
    case 3:
      *(_DWORD *)(a1 + 88) |= 0x800u;
      goto LABEL_17;
    case 4:
      *(_DWORD *)(a1 + 12) = 6;
      uint64_t v4 = *(void *)(*(void *)(a1 + 80) + 224);
      if (!v4 || (*(unsigned char *)(v4 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          int v12 = __nwlog_tcp_log();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            int v13 = (const char *)(v4 + 604);
            int v14 = tcpstates[*(int *)(v2 + 12)];
            int v18 = 136446722;
            uint64_t v19 = "tcp_usrclosed";
            if (!v4) {
              int v13 = "";
            }
            __int16 v20 = 2082;
            __int16 v21 = v13;
            __int16 v22 = 2082;
            uint64_t v23 = v14;
            _os_log_impl(&dword_214653000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", (uint8_t *)&v18, 0x20u);
          }
        }
      }
      if (!*(void *)(*(void *)(*(void *)(v2 + 80) + 224) + 24)) {
        goto LABEL_17;
      }
      uint64_t all_stats = nw_protocol_tcp_get_all_stats();
      if (!all_stats) {
        goto LABEL_17;
      }
      int v6 = 6;
      break;
    case 5:
      *(_DWORD *)(a1 + 12) = 8;
      uint64_t v7 = *(void *)(*(void *)(a1 + 80) + 224);
      if (!v7 || (*(unsigned char *)(v7 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          uint64_t v15 = __nwlog_tcp_log();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v16 = (const char *)(v7 + 604);
            uint64_t v17 = tcpstates[*(int *)(v2 + 12)];
            int v18 = 136446722;
            uint64_t v19 = "tcp_usrclosed";
            if (!v7) {
              uint64_t v16 = "";
            }
            __int16 v20 = 2082;
            __int16 v21 = v16;
            __int16 v22 = 2082;
            uint64_t v23 = v17;
            _os_log_impl(&dword_214653000, v15, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", (uint8_t *)&v18, 0x20u);
          }
        }
      }
      if (!*(void *)(*(void *)(*(void *)(v2 + 80) + 224) + 24)) {
        goto LABEL_17;
      }
      uint64_t all_stats = nw_protocol_tcp_get_all_stats();
      if (!all_stats) {
        goto LABEL_17;
      }
      int v6 = 8;
      break;
    default:
      goto LABEL_18;
  }
  *(_DWORD *)(all_stats + 136) = v6;
LABEL_17:
  int v3 = *(_DWORD *)(v2 + 12);
LABEL_18:
  if (v3 >= 9)
  {
    uint64_t v8 = *(void *)(*(void *)(v2 + 80) + 224);
    *(_WORD *)(v8 + 376) = *(_WORD *)(v8 + 376) & 0xDFC1 | 0x2030;
    uint64_t v9 = *(void *)(v8 + 32);
    if (v9)
    {
      uint64_t v10 = *(void (**)(uint64_t, uint64_t))(v9 + 56);
      if (v10)
      {
        v10(v8, a2);
        int v3 = *(_DWORD *)(v2 + 12);
      }
    }
    if (v3 == 9) {
      tcp_set_finwait_timeout(v2);
    }
  }
  return v2;
}

BOOL nw_protocol_tcp_finalize_output_frames(uint64_t a1, uint64_t *a2)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v4 = nw_protocol_downcast();
    if (v4)
    {
      uint64_t v5 = v4;
      *(void *)&long long buf = 0;
      *((void *)&buf + 1) = &buf;
      uint64_t v27 = 0x2000000000;
      uint64_t v28 = v4;
      *(void *)os_log_type_t type = 0;
      __int16 v22 = type;
      uint64_t v23 = 0x2000000000;
      char v24 = 1;
      v15[0] = MEMORY[0x263EF8330];
      v15[1] = 0x40000000;
      uint64_t v16 = (uint64_t (*)(void *))__nw_protocol_tcp_finalize_output_frames_block_invoke;
      uint64_t v17 = &unk_264217658;
      int v18 = type;
      p_long long buf = &buf;
      uint64_t v20 = a1;
      uint64_t v6 = *a2;
      do
      {
        if (!v6) {
          break;
        }
        uint64_t v7 = *(void *)(v6 + 32);
        char v8 = v16(v15);
        uint64_t v6 = v7;
      }
      while ((v8 & 1) != 0);
      nw_protocol_tcp_update_metadata(a1);
      *(_DWORD *)(v5 + 5308) &= ~0x20u;
      BOOL v9 = *((unsigned char *)v22 + 24) != 0;
      _Block_object_dispose(type, 8);
      _Block_object_dispose(&buf, 8);
      return v9;
    }
    __nwlog_obj();
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = "nw_protocol_tcp_finalize_output_frames";
    int v11 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        int v12 = __nwlog_obj();
        os_log_type_t v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          LODWORD(buf) = 136446210;
          *(void *)((char *)&buf + 4) = "nw_protocol_tcp_finalize_output_frames";
          int v14 = "%{public}s called with null tcp";
          goto LABEL_22;
        }
      }
      else
      {
        int v12 = __nwlog_obj();
        os_log_type_t v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          LODWORD(buf) = 136446210;
          *(void *)((char *)&buf + 4) = "nw_protocol_tcp_finalize_output_frames";
          int v14 = "%{public}s called with null tcp, backtrace limit exceeded";
          goto LABEL_22;
        }
      }
    }
  }
  else
  {
    __nwlog_obj();
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = "nw_protocol_tcp_finalize_output_frames";
    int v11 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        int v12 = __nwlog_obj();
        os_log_type_t v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          LODWORD(buf) = 136446210;
          *(void *)((char *)&buf + 4) = "nw_protocol_tcp_finalize_output_frames";
          int v14 = "%{public}s called with null protocol";
LABEL_22:
          _os_log_impl(&dword_214653000, v12, v13, v14, (uint8_t *)&buf, 0xCu);
        }
      }
      else
      {
        int v12 = __nwlog_obj();
        os_log_type_t v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          LODWORD(buf) = 136446210;
          *(void *)((char *)&buf + 4) = "nw_protocol_tcp_finalize_output_frames";
          int v14 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_22;
        }
      }
    }
  }
  if (v11) {
    free(v11);
  }
  return 0;
}

void nw_protocol_tcp_update_metadata(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v6 = "nw_protocol_tcp_update_metadata";
    uint64_t v2 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_14;
    }
    int v3 = __nwlog_obj();
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v6 = "nw_protocol_tcp_update_metadata";
    uint64_t v4 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_13;
  }
  uint64_t v1 = (_DWORD *)nw_protocol_downcast();
  if (v1)
  {
    v1[1322] = v1[96];
    v1[1323] = v1[122];
    return;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v6 = "nw_protocol_tcp_update_metadata";
  uint64_t v2 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    int v3 = __nwlog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v6 = "nw_protocol_tcp_update_metadata";
      uint64_t v4 = "%{public}s called with null tcp, backtrace limit exceeded";
LABEL_13:
      _os_log_impl(&dword_214653000, v3, OS_LOG_TYPE_ERROR, v4, buf, 0xCu);
    }
  }
LABEL_14:
  if (v2) {
    free(v2);
  }
}

uint64_t __nw_protocol_tcp_finalize_output_frames_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v30 = "__nw_frame_unclaimed_length";
    uint64_t v16 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v17 = __nwlog_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        int v30 = "__nw_frame_unclaimed_length";
        _os_log_impl(&dword_214653000, v17, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v16) {
      free(v16);
    }
    goto LABEL_36;
  }
  int v4 = *(_DWORD *)(a2 + 52);
  if (!v4)
  {
LABEL_36:
    unsigned int v5 = 0;
    goto LABEL_37;
  }
  unsigned int v5 = v4 - (*(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60));
  if (*(unsigned char *)(*(void *)(a1[4] + 8) + 24)) {
    BOOL v6 = v4 == *(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60);
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    int v7 = *(char *)(a2 + 186);
    uint64_t v8 = *(void *)(*(void *)(a1[5] + 8) + 24);
    unsigned int v9 = (*(uint64_t (**)(uint64_t, void, uint64_t, void, void))(*(void *)(*(void *)(v8 + 8) + 40)
                                                                             + 72))(v8, 0, a2, 0, 0);
    unsigned int v10 = v9;
    if ((*(_DWORD *)(v8 + 368) & 0x30) != 0) {
      *(_DWORD *)(v8 + 368) &= *(_DWORD *)(v8 + 368) & 0x10 ^ 0xFFFFFFDF;
    }
    if (v9 > 0x23 || ((1 << v9) & 0x800000011) == 0)
    {
      uint64_t v12 = *(void *)(*(void *)(a1[5] + 8) + 24);
      if (!v12 || (*(unsigned char *)(v12 + 828) & 2) == 0)
      {
        os_log_type_t v13 = __nwlog_tcp_log();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          int v14 = (const char *)(v12 + 604);
          int v30 = "nw_protocol_tcp_finalize_output_frames_block_invoke";
          __int16 v31 = 2082;
          *(_DWORD *)long long buf = 136446978;
          if (!v12) {
            int v14 = "";
          }
          uint32_t v32 = v14;
          __int16 v33 = 1024;
          unsigned int v34 = v10;
          __int16 v35 = 1024;
          unsigned int v36 = v5;
          _os_log_impl(&dword_214653000, v13, OS_LOG_TYPE_ERROR, "%{public}s %{public}s tcp_finalize_send error %d for frame of length %u", buf, 0x22u);
        }
      }
      *(_WORD *)(*(void *)(*(void *)(a1[5] + 8) + 24) + 378) = v10;
      user_north_signal_error(*(void *)(*(void *)(a1[5] + 8) + 24));
      *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 0;
    }
    if (*(unsigned char *)(*(void *)(a1[4] + 8) + 24) && v7 < 0)
    {
      uint64_t v15 = *(void *)(*(void *)(a1[5] + 8) + 24);
      if (!v15 || (*(unsigned char *)(v15 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          int v18 = __nwlog_tcp_log();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v19 = "";
            if (v15) {
              uint64_t v19 = (const char *)(v15 + 604);
            }
            *(_DWORD *)long long buf = 136446466;
            int v30 = "nw_protocol_tcp_finalize_output_frames_block_invoke";
            __int16 v31 = 2082;
            uint32_t v32 = v19;
            _os_log_impl(&dword_214653000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s frame marks connection complete, marking output finished", buf, 0x16u);
          }
        }
      }
      nw_protocol_tcp_output_finished(a1[6]);
    }
    return 1;
  }
LABEL_37:
  uint64_t v20 = *(void *)(*(void *)(a1[5] + 8) + 24);
  if (!v20 || (*(unsigned char *)(v20 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      char v25 = __nwlog_tcp_log();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        int v26 = (const char *)(v20 + 604);
        int v30 = "nw_protocol_tcp_finalize_output_frames_block_invoke";
        *(_DWORD *)long long buf = 136446722;
        if (!v20) {
          int v26 = "";
        }
        __int16 v31 = 2082;
        uint32_t v32 = v26;
        __int16 v33 = 1024;
        unsigned int v34 = v5;
        _os_log_impl(&dword_214653000, v25, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s dropping frame of length %u", buf, 0x1Cu);
      }
    }
  }
  if (a2)
  {
    __int16 v21 = *(void (**)(uint64_t, uint64_t, uint64_t))(a2 + 80);
    if (v21)
    {
      uint64_t v22 = *(void *)(a2 + 88);
      *(void *)(a2 + 80) = 0;
      *(void *)(a2 + 88) = 0;
      v21(a2, 1, v22);
      return 1;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v30 = "__nw_frame_finalize";
    char v24 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_57;
    }
    uint64_t v27 = __nwlog_obj();
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_57;
    }
    *(_DWORD *)long long buf = 136446210;
    int v30 = "__nw_frame_finalize";
    uint64_t v28 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
    goto LABEL_56;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  int v30 = "__nw_frame_finalize";
  char v24 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    uint64_t v27 = __nwlog_obj();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446210;
      int v30 = "__nw_frame_finalize";
      uint64_t v28 = "%{public}s called with null frame, backtrace limit exceeded";
LABEL_56:
      _os_log_impl(&dword_214653000, v27, OS_LOG_TYPE_ERROR, v28, buf, 0xCu);
    }
  }
LABEL_57:
  if (v24) {
    free(v24);
  }
  return 1;
}

uint64_t tcp_usr_send(uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(void *)a1;
  if (!*(void *)a1 || *(_DWORD *)(v5 + 232) == 3)
  {
    if (a3)
    {
      int v7 = (void *)(a3 + 80);
      BOOL v6 = *(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 80);
      if (v6)
      {
        uint64_t v8 = *(void *)(a3 + 88);
        *int v7 = 0;
        *(void *)(a3 + 88) = 0;
        v6(a3, 1, v8);
      }
      else
      {
        __nwlog_obj();
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        int v26 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          uint64_t v29 = __nwlog_obj();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            _os_log_impl(&dword_214653000, v29, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
          }
        }
        if (v26) {
          free(v26);
        }
      }
    }
    if (v5) {
      return 41;
    }
    else {
      return 54;
    }
  }
  if (a4) {
    BOOL v14 = *(unsigned __int8 *)(a4 + 1) == 30;
  }
  else {
    BOOL v14 = 0;
  }
  uint64_t v15 = *(int **)(v5 + 240);
  uint64_t v16 = nw_tcp_access_globals(a1);
  calculate_tcp_clock(v16);
  if ((*(unsigned char *)(a1 + 367) & 1) == 0 || (*(unsigned char *)(a1 + 433) & 0x10) != 0)
  {
    if (a2) {
      goto LABEL_16;
    }
    goto LABEL_17;
  }
  uint64_t v27 = __nwlog_obj();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "tcp_usr_send";
  uint64_t v28 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!result)
  {
    free(v28);
    if (a2)
    {
LABEL_16:
      if ((*(unsigned char *)(a1 + 368) & 0x20) == 0) {
        goto LABEL_36;
      }
    }
LABEL_17:
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 40) = buf;
    *(void *)long long buf = a3;
    *(void *)&buf[8] = a3 + 32;
    int v17 = *(_DWORD *)(a3 + 52);
    if (v17) {
      int v18 = v17 - (*(_DWORD *)(a3 + 56) + *(_DWORD *)(a3 + 60));
    }
    else {
      int v18 = 0;
    }
    sbappendstream((int *)(a1 + 384), (uint64_t *)buf, v18, 0);
    if (a4 && v15[3] <= 1)
    {
      if (v14)
      {
        uint64_t v9 = tcp6_connect((uint64_t)v15, a4);
        if (v9) {
          return v9;
        }
      }
      else
      {
        uint64_t v9 = tcp_connect((uint64_t)v15, a4);
        if (v9) {
          return v9;
        }
      }
      v15[35] = 4096;
      v15[63] = 4096;
      tcp_mss((uint64_t)v15, -1, 0);
    }
    if ((a2 & 2) != 0)
    {
      *(_WORD *)(a1 + 376) |= 0x10u;
      uint64_t v20 = *(void *)(a1 + 32);
      if (v20)
      {
        __int16 v21 = *(void (**)(uint64_t))(v20 + 16);
        if (v21) {
          v21(a1);
        }
      }
      uint64_t v15 = (int *)tcp_usrclosed((uint64_t)v15, v19);
    }
    if (v15)
    {
      if ((a2 & 4) != 0)
      {
        v15[22] |= 0x10000u;
        uint64_t v9 = tcp_output((uint64_t)v15);
        v15[22] &= ~0x10000u;
        __int16 v22 = *(_WORD *)(a1 + 376);
        if ((v22 & 4) != 0) {
          goto LABEL_39;
        }
      }
      else
      {
        uint64_t v9 = tcp_output((uint64_t)v15);
        __int16 v22 = *(_WORD *)(a1 + 376);
        if ((v22 & 4) != 0) {
          goto LABEL_39;
        }
      }
      return v9;
    }
LABEL_36:
    uint64_t v9 = 0;
    __int16 v22 = *(_WORD *)(a1 + 376);
    if ((v22 & 4) != 0)
    {
LABEL_39:
      if ((v22 & 0x100) != 0)
      {
        return 35;
      }
      else if ((*(unsigned char *)(a1 + 828) & 2) == 0)
      {
        __nwlog_tcp_log();
        uint64_t v23 = a1 + 604;
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "tcp_usr_send";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 604;
        char v24 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          char v25 = __nwlog_tcp_log();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "tcp_usr_send";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v23;
            _os_log_impl(&dword_214653000, v25, OS_LOG_TYPE_ERROR, "%{public}s %{public}s NBIO not set, backtrace limit exceeded", buf, 0x16u);
          }
        }
        if (v24) {
          free(v24);
        }
      }
    }
    return v9;
  }
  __break(1u);
  return result;
}

uint64_t nw_protocol_tcp_get_output_frames(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5, uint64_t a6)
{
  uint64_t v102 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
    uint64_t v37 = (void *)_os_log_send_and_compose_impl();
    v92[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault()) {
      goto LABEL_100;
    }
    if (v92[0] == OS_LOG_TYPE_FAULT)
    {
      signed int v80 = __nwlog_obj();
      os_log_type_t v81 = v92[0];
      if (!os_log_type_enabled(v80, v92[0])) {
        goto LABEL_100;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
      uint64_t v40 = "%{public}s called with null protocol";
    }
    else
    {
      signed int v80 = __nwlog_obj();
      os_log_type_t v81 = v92[0];
      if (!os_log_type_enabled(v80, v92[0])) {
        goto LABEL_100;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
      uint64_t v40 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_178;
  }
  uint64_t v11 = nw_protocol_downcast();
  if (!v11)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
    uint64_t v37 = (void *)_os_log_send_and_compose_impl();
    v92[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault()) {
      goto LABEL_100;
    }
    if (v92[0] == OS_LOG_TYPE_FAULT)
    {
      signed int v80 = __nwlog_obj();
      os_log_type_t v81 = v92[0];
      if (!os_log_type_enabled(v80, v92[0])) {
        goto LABEL_100;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
      uint64_t v40 = "%{public}s called with null tcp";
    }
    else
    {
      signed int v80 = __nwlog_obj();
      os_log_type_t v81 = v92[0];
      if (!os_log_type_enabled(v80, v92[0])) {
        goto LABEL_100;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
      uint64_t v40 = "%{public}s called with null tcp, backtrace limit exceeded";
    }
LABEL_178:
    __int16 v59 = v80;
    os_log_type_t v60 = v81;
    uint32_t v61 = 12;
    goto LABEL_99;
  }
  uint64_t v12 = v11;
  if (*(_DWORD *)(v11 + 5224) == 2)
  {
    if (a5)
    {
      int v13 = *(_DWORD *)(v11 + 5308);
      if ((v13 & 0xC00) == 0x400)
      {
        uint64_t all_stats = nw_protocol_tcp_get_all_stats();
        if (all_stats) {
          *(_DWORD *)(all_stats + 124) |= 0x400u;
        }
        int v13 = *(_DWORD *)(v12 + 5308) | 0x800;
        *(_DWORD *)(v12 + 5308) = v13;
      }
LABEL_15:
      *(_DWORD *)BOOL v92 = 0;
      if ((*(unsigned char *)(v12 + 364) & 8) != 0)
      {
        if ((*(unsigned char *)(v12 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
        {
          uint64_t v85 = __nwlog_tcp_log();
          int v22 = 32;
          if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "sosendcheck";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v12 + 604;
            *(_WORD *)&unsigned char buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = 32;
            _os_log_impl(&dword_214653000, v85, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s defunct flow error (%d)", buf, 0x1Cu);
          }
          goto LABEL_28;
        }
      }
      else
      {
        __int16 v21 = *(_WORD *)(v12 + 376);
        if ((v21 & 0x10) == 0)
        {
          int v22 = *(unsigned __int16 *)(v12 + 378);
          if (*(_WORD *)(v12 + 378))
          {
            *(_WORD *)(v12 + 378) = 0;
            __nwlog_obj();
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "sosendcheck";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v12 + 604;
            *(_WORD *)&unsigned char buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = v22;
            uint64_t v23 = (void *)_os_log_send_and_compose_impl();
            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v93 = 0;
            if (!__nwlog_fault()) {
              goto LABEL_115;
            }
            if (type == OS_LOG_TYPE_FAULT)
            {
              char v24 = __nwlog_obj();
              os_log_type_t v25 = type;
              if (!os_log_type_enabled(v24, type)) {
                goto LABEL_115;
              }
              *(_DWORD *)long long buf = 136446722;
              *(void *)&uint8_t buf[4] = "sosendcheck";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v12 + 604;
              *(_WORD *)&unsigned char buf[22] = 1024;
              *(_DWORD *)&unsigned char buf[24] = v22;
              int v26 = "%{public}s %{public}s this should be handled by user_north_signal_error %{darwin.errno}d";
            }
            else
            {
              char v24 = __nwlog_obj();
              os_log_type_t v25 = type;
              if (!os_log_type_enabled(v24, type)) {
                goto LABEL_115;
              }
              *(_DWORD *)long long buf = 136446722;
              *(void *)&uint8_t buf[4] = "sosendcheck";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v12 + 604;
              *(_WORD *)&unsigned char buf[22] = 1024;
              *(_DWORD *)&unsigned char buf[24] = v22;
              int v26 = "%{public}s %{public}s this should be handled by user_north_signal_error %{darwin.errno}d, backtrace limit exceeded";
            }
            _os_log_impl(&dword_214653000, v24, v25, v26, buf, 0x1Cu);
LABEL_115:
            if (v23) {
              free(v23);
            }
            goto LABEL_28;
          }
          if ((v21 & 2) == 0 && a4 && (*(_WORD *)(v12 + 376) & 0x400) == 0 && (*(unsigned char *)(v12 + 368) & 0x20) == 0)
          {
            int v22 = 57;
            goto LABEL_28;
          }
          int v43 = *(_DWORD *)(v12 + 384);
          int v44 = *(_DWORD *)(v12 + 388) - v43;
          int v45 = *(_DWORD *)(v12 + 484);
          int v46 = v45 - v43;
          if (v46 >= v44) {
            int v46 = v44;
          }
          if (!v45) {
            int v46 = v44;
          }
          unsigned int v47 = v46 & ~(v46 >> 31);
          if (v47 >= a4 || v47 >= *(_DWORD *)(v12 + 392))
          {
            int v48 = **(_DWORD **)(*(void *)(v12 + 8) + 8);
            BOOL v49 = v48 == 30 || v48 == 2;
            if (!v49 || (v21 & 2) == 0 || (*(unsigned char *)(*(void *)v12 + 2231) & 0x50) == 0)
            {
LABEL_72:
              if (v47 >= a4) {
                unsigned int v50 = a4;
              }
              else {
                unsigned int v50 = v46 & ~(v46 >> 31);
              }
              if (a3 > v50 && v50 < *(_DWORD *)(v12 + 392))
              {
                unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
                int v51 = *(int **)(StatusReg + 8);
                int v52 = 35;
LABEL_113:
                *int v51 = v52;
LABEL_29:
                int v29 = **(_DWORD **)(StatusReg + 8);
                if (v29 != 35)
                {
                  if (v29 == 32)
                  {
                    int v30 = __nwlog_obj();
                    uint64_t result = os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
                    if (!result) {
                      return result;
                    }
                    *(_DWORD *)long long buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = 32;
                    int v17 = "%{public}s tcp_get_southbound_frame failed %{darwin.errno}d";
                    int v18 = v30;
                    os_log_type_t v19 = OS_LOG_TYPE_ERROR;
                    uint32_t v20 = 18;
                    goto LABEL_33;
                  }
                  __nwlog_obj();
                  *(_DWORD *)long long buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v29;
                  uint64_t v37 = (void *)_os_log_send_and_compose_impl();
                  os_log_type_t type = OS_LOG_TYPE_ERROR;
                  char v93 = 0;
                  if (__nwlog_fault())
                  {
                    if (type == OS_LOG_TYPE_FAULT)
                    {
                      uint64_t v38 = __nwlog_obj();
                      os_log_type_t v39 = type;
                      if (!os_log_type_enabled(v38, type)) {
                        goto LABEL_100;
                      }
                      *(_DWORD *)long long buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v29;
                      uint64_t v40 = "%{public}s tcp_get_southbound_frame failed %{darwin.errno}d";
                      goto LABEL_98;
                    }
                    if (!v93)
                    {
                      uint64_t v38 = __nwlog_obj();
                      os_log_type_t v39 = type;
                      if (!os_log_type_enabled(v38, type)) {
                        goto LABEL_100;
                      }
                      *(_DWORD *)long long buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v29;
                      uint64_t v40 = "%{public}s tcp_get_southbound_frame failed %{darwin.errno}d, backtrace limit exceeded";
                      goto LABEL_98;
                    }
                    os_log_t backtrace_string = (void *)__nw_create_backtrace_string();
                    uint64_t v38 = __nwlog_obj();
                    os_log_type_t v39 = type;
                    BOOL v42 = os_log_type_enabled(v38, type);
                    if (backtrace_string)
                    {
                      if (v42)
                      {
                        *(_DWORD *)long long buf = 136446722;
                        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
                        *(_WORD *)&buf[12] = 1024;
                        *(_DWORD *)&buf[14] = v29;
                        *(_WORD *)&buf[18] = 2082;
                        *(void *)&buf[20] = backtrace_string;
                        _os_log_impl(&dword_214653000, v38, v39, "%{public}s tcp_get_southbound_frame failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                      }
                      free(backtrace_string);
                      goto LABEL_100;
                    }
                    if (v42)
                    {
                      *(_DWORD *)long long buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v29;
                      uint64_t v40 = "%{public}s tcp_get_southbound_frame failed %{darwin.errno}d, no backtrace";
LABEL_98:
                      __int16 v59 = v38;
                      os_log_type_t v60 = v39;
                      uint32_t v61 = 18;
LABEL_99:
                      _os_log_impl(&dword_214653000, v59, v60, v40, buf, v61);
                    }
                  }
LABEL_100:
                  if (v37) {
                    free(v37);
                  }
                  return 0;
                }
                if ((*(unsigned char *)(v12 + 828) & 2) != 0) {
                  return 0;
                }
                uint64_t result = __nwlog_is_datapath_logging_enabled();
                if (result)
                {
                  uint64_t v31 = __nwlog_tcp_log();
                  uint64_t result = os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG);
                  if (result)
                  {
                    int v32 = *(_DWORD *)(v12 + 392);
                    int v33 = *(_DWORD *)(v12 + 384);
                    int v34 = *(_DWORD *)(v12 + 388) - v33;
                    int v35 = *(_DWORD *)(v12 + 484);
                    int v36 = v35 - v33;
                    if (v36 >= v34) {
                      int v36 = v34;
                    }
                    if (v35) {
                      int v34 = v36;
                    }
                    *(_DWORD *)long long buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v12 + 604;
                    *(_WORD *)&unsigned char buf[22] = 1024;
                    *(_DWORD *)&unsigned char buf[24] = v32;
                    *(_WORD *)&buf[28] = 1024;
                    *(_DWORD *)&buf[30] = v34 & ~(v34 >> 31);
                    int v17 = "%{public}s %{public}s tcp_get_southbound_frame failed, socket is full minimum %u sbspace %u";
                    int v18 = v31;
                    os_log_type_t v19 = OS_LOG_TYPE_DEBUG;
                    uint32_t v20 = 34;
                    goto LABEL_33;
                  }
                }
                return result;
              }
              *(void *)long long buf = 0;
              *(void *)&buf[8] = buf;
              if (!nw_protocol_tcp_get_frames(v12, v50, (uint64_t)buf, a5, (int *)v92, (v13 & 0x1000) != 0))
              {
                unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
                int v51 = *(int **)(StatusReg + 8);
                int v52 = 55;
                goto LABEL_113;
              }
              if (*(void *)buf)
              {
                **(void **)(a6 + 8) = *(void *)buf;
                uint64_t v53 = *(void *)&buf[8];
                *(void *)(*(void *)buf + 40) = *(void *)(a6 + 8);
                *(void *)(a6 + 8) = v53;
              }
              uint64_t v54 = nw_protocol_downcast();
              if (!v54)
              {
                __nwlog_obj();
                *(_DWORD *)long long buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                __int16 v67 = (void *)_os_log_send_and_compose_impl();
                os_log_type_t type = OS_LOG_TYPE_ERROR;
                char v93 = 0;
                if (!__nwlog_fault()) {
                  goto LABEL_163;
                }
                if (type == OS_LOG_TYPE_FAULT)
                {
                  uint64_t v86 = __nwlog_obj();
                  os_log_type_t v87 = type;
                  if (!os_log_type_enabled(v86, type)) {
                    goto LABEL_163;
                  }
                  *(_DWORD *)long long buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                  __int16 v70 = "%{public}s called with null tcp";
                }
                else if (v93)
                {
                  uint64_t v89 = (void *)__nw_create_backtrace_string();
                  uint64_t v86 = __nwlog_obj();
                  os_log_type_t v87 = type;
                  BOOL v90 = os_log_type_enabled(v86, type);
                  if (v89)
                  {
                    if (v90)
                    {
                      *(_DWORD *)long long buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v89;
                      _os_log_impl(&dword_214653000, v86, v87, "%{public}s called with null tcp, dumping backtrace:%{public}s", buf, 0x16u);
                    }
                    free(v89);
                    goto LABEL_163;
                  }
                  if (!v90) {
                    goto LABEL_163;
                  }
                  *(_DWORD *)long long buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                  __int16 v70 = "%{public}s called with null tcp, no backtrace";
                }
                else
                {
                  uint64_t v86 = __nwlog_obj();
                  os_log_type_t v87 = type;
                  if (!os_log_type_enabled(v86, type)) {
                    goto LABEL_163;
                  }
                  *(_DWORD *)long long buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                  __int16 v70 = "%{public}s called with null tcp, backtrace limit exceeded";
                }
                uint64_t v82 = v86;
                os_log_type_t v83 = v87;
                uint32_t v84 = 12;
                goto LABEL_162;
              }
              uint64_t v55 = v54;
              if (a3 - v50 <= 1) {
                int v56 = 1;
              }
              else {
                int v56 = a3 - v50;
              }
              if (a3 <= v50) {
                int v57 = 2048;
              }
              else {
                int v57 = v56;
              }
              if (*(_DWORD *)(v54 + 392) == v57) {
                goto LABEL_165;
              }
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v54 + 8) + 16))(v54, 1, v6);
              if ((~*(unsigned __int16 *)(v55 + 376) & 0x30) != 0)
              {
                if (v57 < 1)
                {
                  int v58 = 1;
                  goto LABEL_127;
                }
              }
              else
              {
                int v58 = 1;
                if ((*(unsigned char *)(v55 + 365) & 0x20) == 0 || v57 < 1) {
                  goto LABEL_127;
                }
              }
              int v58 = 0;
              unsigned int v66 = *(_DWORD *)(v55 + 388) / 3u;
              if (v57 <= *(_DWORD *)(v55 + 388) / 3) {
                unsigned int v66 = v57;
              }
              if (v66 <= 1) {
                unsigned int v66 = 1;
              }
              *(_DWORD *)(v55 + 392) = v66;
LABEL_127:
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v55 + 8) + 24))(v55, 1, v6);
              if (!v58)
              {
                if ((*(unsigned char *)(v55 + 828) & 2) == 0)
                {
                  if (__nwlog_is_datapath_logging_enabled())
                  {
                    char v71 = __nwlog_tcp_log();
                    if (os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG))
                    {
                      int v72 = *(_DWORD *)(v55 + 392);
                      int v73 = *(_DWORD *)(v55 + 384);
                      int v74 = *(_DWORD *)(v55 + 388) - v73;
                      int v75 = *(_DWORD *)(v55 + 484);
                      int v76 = v75 - v73;
                      if (v76 >= v74) {
                        int v76 = v74;
                      }
                      if (v75) {
                        int v74 = v76;
                      }
                      *(_DWORD *)long long buf = 136446978;
                      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v55 + 604;
                      *(_WORD *)&unsigned char buf[22] = 1024;
                      *(_DWORD *)&unsigned char buf[24] = v72;
                      *(_WORD *)&buf[28] = 1024;
                      *(_DWORD *)&buf[30] = v74 & ~(v74 >> 31);
                      _os_log_impl(&dword_214653000, v71, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s so_snd.sb_lowat %u sbspace %u", buf, 0x22u);
                    }
                  }
                }
                goto LABEL_165;
              }
              __nwlog_obj();
              *(_DWORD *)long long buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v57;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v58;
              __int16 v67 = (void *)_os_log_send_and_compose_impl();
              os_log_type_t type = OS_LOG_TYPE_ERROR;
              char v93 = 0;
              if (__nwlog_fault())
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  uint64_t v68 = __nwlog_obj();
                  os_log_type_t v69 = type;
                  if (!os_log_type_enabled(v68, type)) {
                    goto LABEL_163;
                  }
                  *(_DWORD *)long long buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v57;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v58;
                  __int16 v70 = "%{public}s setsockopt SO_SNDLOWAT %u failed %{darwin.errno}d";
LABEL_160:
                  uint64_t v82 = v68;
LABEL_161:
                  os_log_type_t v83 = v69;
                  uint32_t v84 = 24;
LABEL_162:
                  _os_log_impl(&dword_214653000, v82, v83, v70, buf, v84);
                  goto LABEL_163;
                }
                if (!v93)
                {
                  uint64_t v68 = __nwlog_obj();
                  os_log_type_t v69 = type;
                  if (!os_log_type_enabled(v68, type)) {
                    goto LABEL_163;
                  }
                  *(_DWORD *)long long buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v57;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v58;
                  __int16 v70 = "%{public}s setsockopt SO_SNDLOWAT %u failed %{darwin.errno}d, backtrace limit exceeded";
                  goto LABEL_160;
                }
                uint64_t v77 = (void *)__nw_create_backtrace_string();
                unsigned int v78 = __nwlog_obj();
                os_log_type_t v69 = type;
                os_log_type_t log = v78;
                BOOL v79 = os_log_type_enabled(v78, type);
                if (v77)
                {
                  if (v79)
                  {
                    *(_DWORD *)long long buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v57;
                    *(_WORD *)&buf[18] = 1024;
                    *(_DWORD *)&buf[20] = v58;
                    *(_WORD *)&unsigned char buf[24] = 2082;
                    *(void *)&buf[26] = v77;
                    _os_log_impl(&dword_214653000, log, v69, "%{public}s setsockopt SO_SNDLOWAT %u failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
                  }
                  free(v77);
                  if (!v67) {
                    goto LABEL_165;
                  }
LABEL_164:
                  free(v67);
LABEL_165:
                  if ((*(unsigned char *)(v12 + 828) & 2) == 0)
                  {
                    if (__nwlog_is_datapath_logging_enabled())
                    {
                      uint64_t v88 = __nwlog_tcp_log();
                      if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)long long buf = 136447746;
                        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v12 + 604;
                        *(_WORD *)&unsigned char buf[22] = 1024;
                        *(_DWORD *)&unsigned char buf[24] = a3;
                        *(_WORD *)&buf[28] = 1024;
                        *(_DWORD *)&buf[30] = a4;
                        __int16 v96 = 1024;
                        int v97 = a5;
                        __int16 v98 = 1024;
                        unsigned int v99 = v50;
                        __int16 v100 = 2048;
                        uint64_t v101 = v12;
                        _os_log_impl(&dword_214653000, v88, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s asked for min %u max %u bytes, max %u frames and got 1 frame of %u bytes on %p", buf, 0x38u);
                      }
                    }
                  }
                  return *(unsigned int *)v92;
                }
                if (v79)
                {
                  *(_DWORD *)long long buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v57;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v58;
                  __int16 v70 = "%{public}s setsockopt SO_SNDLOWAT %u failed %{darwin.errno}d, no backtrace";
                  uint64_t v82 = log;
                  goto LABEL_161;
                }
              }
LABEL_163:
              if (!v67) {
                goto LABEL_165;
              }
              goto LABEL_164;
            }
          }
          if ((*(unsigned char *)(v12 + 368) & 0x20) != 0)
          {
            if (v46 < 1) {
              goto LABEL_149;
            }
            if (v47 < *(_DWORD *)(v12 + 392)) {
              goto LABEL_72;
            }
          }
          if ((*(_WORD *)(v12 + 376) & 0x100) == 0 && (*(unsigned char *)(v12 + 828) & 2) == 0)
          {
            __nwlog_tcp_log();
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "sosendcheck";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v12 + 604;
            int v62 = (void *)_os_log_send_and_compose_impl();
            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v93 = 0;
            if (!__nwlog_fault()) {
              goto LABEL_147;
            }
            if (type == OS_LOG_TYPE_FAULT)
            {
              __int16 v63 = __nwlog_tcp_log();
              os_log_type_t v64 = type;
              if (!os_log_type_enabled(v63, type)) {
                goto LABEL_147;
              }
              *(_DWORD *)long long buf = 136446466;
              *(void *)&uint8_t buf[4] = "sosendcheck";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v12 + 604;
              __int16 v65 = "%{public}s %{public}s NBIO not set";
            }
            else
            {
              __int16 v63 = __nwlog_tcp_log();
              os_log_type_t v64 = type;
              if (!os_log_type_enabled(v63, type)) {
                goto LABEL_147;
              }
              *(_DWORD *)long long buf = 136446466;
              *(void *)&uint8_t buf[4] = "sosendcheck";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v12 + 604;
              __int16 v65 = "%{public}s %{public}s NBIO not set, backtrace limit exceeded";
            }
            _os_log_impl(&dword_214653000, v63, v64, v65, buf, 0x16u);
LABEL_147:
            if (v62) {
              free(v62);
            }
          }
LABEL_149:
          int v22 = 35;
          goto LABEL_28;
        }
      }
      int v22 = 32;
LABEL_28:
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(StatusReg + 8) = v22;
      goto LABEL_29;
    }
    goto LABEL_22;
  }
  int v13 = *(_DWORD *)(v11 + 5308);
  if ((v13 & 0x20) != 0)
  {
    if (a5) {
      goto LABEL_15;
    }
LABEL_22:
    if ((*(unsigned char *)(v11 + 828) & 2) == 0)
    {
      uint64_t v27 = __nwlog_tcp_log();
      uint64_t result = os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v12 + 604;
      int v17 = "%{public}s %{public}s cannot specify 0 as maximum_frame_count on a streaming socket";
      int v18 = v27;
      os_log_type_t v19 = OS_LOG_TYPE_ERROR;
      uint32_t v20 = 22;
      goto LABEL_33;
    }
    return 0;
  }
  if ((*(unsigned char *)(v11 + 828) & 2) != 0) {
    return 0;
  }
  uint64_t result = __nwlog_is_datapath_logging_enabled();
  if (result)
  {
    uint64_t v16 = __nwlog_tcp_log();
    uint64_t result = os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG);
    if (result)
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v12 + 604;
      int v17 = "%{public}s %{public}s skipping";
      int v18 = v16;
      os_log_type_t v19 = OS_LOG_TYPE_DEBUG;
      uint32_t v20 = 22;
LABEL_33:
      _os_log_impl(&dword_214653000, v18, v19, v17, buf, v20);
      return 0;
    }
  }
  return result;
}

BOOL tcp_input_get_aggregate_frames(uint64_t a1, unsigned int a2, _DWORD *a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v16 = 0;
  int v17 = &v16;
  int v19 = 0;
  uint64_t v18 = 0x2000000000;
  v14[0] = 0;
  v14[1] = v14;
  int v15 = 0;
  v14[2] = 0x2000000000;
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  int v13 = 0;
  uint64_t v12 = 0x2000000000;
  unsigned int v7 = *(_DWORD *)(a1 + 552);
  if (v7 && *(void *)(a1 + 520))
  {
    if (v7 < a2) {
      a2 = *(_DWORD *)(a1 + 552);
    }
    if (nw_protocol_tcp_get_frames(a1, a2, a5, -1, 0, 0)) {
      nw_frame_array_foreach();
    }
  }
  if (a3) {
    *a3 = *((_DWORD *)v17 + 6);
  }
  if (a4) {
    *a4 = *((_DWORD *)v11 + 6);
  }
  BOOL v8 = *((_DWORD *)v17 + 6) != 0;
  _Block_object_dispose(&v10, 8);
  _Block_object_dispose(v14, 8);
  _Block_object_dispose(&v16, 8);
  return v8;
}

uint64_t nw_protocol_tcp_get_frames(uint64_t a1, signed int a2, uint64_t a3, int a4, int *a5, char a6)
{
  uint64_t v6 = a5;
  unsigned int v7 = a4;
  uint64_t v10 = a1;
  uint64_t v199 = *MEMORY[0x263EF8340];
  if ((a6 & 1) == 0)
  {
    if (!g_use_slab_allocator)
    {
      return nw_protocol_tcp_get_malloc_frame(a1, a2, a3, a4, a5);
    }
    uint64_t v178 = 0;
    v179 = &v178;
    uint64_t v180 = 0x2800000000;
    uint64_t v181 = 0;
    uint64_t v182 = 0;
    unsigned int v177 = 0;
    if (a3)
    {
      if (a4)
      {
        if (a2 < 1) {
          goto LABEL_250;
        }
        if (a5) {
          *a5 = 0;
        }
        if (a1)
        {
          unsigned int v17 = a2;
          if (*(void *)(a1 + 40))
          {
LABEL_17:
            uint64_t v18 = (void *)nw_tcp_access_globals(v10);
            int v19 = v179;
            v179[3] = 0;
            v19[4] = (uint64_t)(v19 + 3);
            unsigned int v20 = nw_context_2k_buffer_length();
            unsigned int frame_count = nw_protocol_tcp_get_frame_count(v17, v20, (int *)&v177);
            if (frame_count > v7 || (unsigned int v22 = frame_count, frame_count - 3 < 0xFFFFFFFE))
            {
              unsigned int v40 = nw_context_8k_buffer_length();
              if (nw_protocol_tcp_get_frame_count(v17, v40, (int *)&v177) == 1)
              {
                uint64_t v23 = nw_context_8k_buffer_manager();
                unsigned int v22 = 1;
                int v24 = nw_context_8k_buffer_length();
              }
              else
              {
                unsigned int v45 = nw_context_16k_buffer_length();
                unsigned int v46 = nw_protocol_tcp_get_frame_count(v17, v45, (int *)&v177);
                if (v46 > v7 || (unsigned int v22 = v46, v46 - 3 < 0xFFFFFFFE))
                {
                  unsigned int v47 = nw_context_64k_buffer_length();
                  if (nw_protocol_tcp_get_frame_count(v17, v47, (int *)&v177) == 1)
                  {
                    uint64_t v23 = nw_context_64k_buffer_manager();
                    unsigned int v22 = 1;
                    int v24 = nw_context_64k_buffer_length();
                  }
                  else
                  {
                    unsigned int v48 = nw_context_128k_buffer_length();
                    unsigned int v22 = nw_protocol_tcp_get_frame_count(v17, v48, (int *)&v177);
                    uint64_t v23 = nw_context_128k_buffer_manager();
                    int v24 = nw_context_128k_buffer_length();
                  }
                }
                else
                {
                  uint64_t v23 = nw_context_16k_buffer_manager();
                  int v24 = nw_context_16k_buffer_length();
                }
              }
            }
            else
            {
              uint64_t v23 = nw_context_2k_buffer_manager();
              int v24 = nw_context_2k_buffer_length();
            }
            int v49 = v24;
            if (v23)
            {
              if (v22 > v7)
              {
                *(_DWORD *)os_log_type_t type = 0;
                unsigned int v50 = a2;
                if (nw_protocol_tcp_get_malloc_frame(v10, a2, (uint64_t)(v179 + 3), 1, type))
                {
                  int v51 = v179;
                  int v52 = v179 + 3;
                  uint64_t v53 = v179[3];
                  if (v53)
                  {
                    **(void **)(a3 + 8) = v53;
                    *(void *)(v51[3] + 40) = *(void *)(a3 + 8);
                    *(void *)(a3 + 8) = v51[4];
                    v51[3] = 0;
                    v51[4] = (uint64_t)v52;
                  }
                  if (v6) {
                    *uint64_t v6 = *(_DWORD *)type;
                  }
                  goto LABEL_173;
                }
                v109 = __nwlog_obj();
                if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)v190 = 136446722;
                  v191 = "nw_protocol_tcp_get_slab_frame";
                  __int16 v192 = 1024;
                  *(_DWORD *)v193 = v22;
                  *(_WORD *)&v193[4] = 1024;
                  *(_DWORD *)&v193[6] = v7;
                  _os_log_impl(&dword_214653000, v109, OS_LOG_TYPE_ERROR, "%{public}s requested frame count %u larger than max frame count %u", v190, 0x18u);
                }
                _Block_object_dispose(&v178, 8);
                uint64_t v110 = a3;
                return nw_protocol_tcp_get_malloc_frame(v10, v50, v110, v7, v6);
              }
              uint64_t v171 = v10;
              unsigned int v170 = v7;
              int v54 = 0;
              while (1)
              {
                uint64_t v57 = nw_mem_buffer_allocate();
                if (!v57)
                {
                  uint64_t v10 = v171;
                  if (__nwlog_is_datapath_logging_enabled())
                  {
                    v111 = __nwlog_obj();
                    if (os_log_type_enabled(v111, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)v190 = 136446466;
                      v191 = "nw_protocol_tcp_get_slab_frame";
                      __int16 v192 = 1024;
                      *(_DWORD *)v193 = v49;
                      _os_log_impl(&dword_214653000, v111, OS_LOG_TYPE_DEBUG, "%{public}s failed to allocate slab buffer of size %u", v190, 0x12u);
                    }
                  }
LABEL_167:
                  unsigned int v50 = a2;
                  unsigned int v124 = a2 - v54;
                  if (a2 == v54)
                  {
                    __int16 v161 = __nwlog_obj();
                    os_log_type_enabled(v161, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)v190 = 136446210;
                    v191 = "nw_protocol_tcp_get_slab_frame";
                    __int16 v162 = (void *)_os_log_send_and_compose_impl();
                    uint64_t result = __nwlog_abort();
                    if (result) {
                      goto LABEL_277;
                    }
                    free(v162);
                    uint64_t v6 = a5;
                    unsigned int v50 = a2;
                    uint64_t v10 = v171;
                  }
                  *(_DWORD *)os_log_type_t type = 0;
                  int malloc_frame = nw_protocol_tcp_get_malloc_frame(v10, v124, (uint64_t)(v179 + 3), 1, type);
                  char v126 = malloc_frame;
                  unsigned int v7 = v170;
                  if (malloc_frame)
                  {
                    unsigned int v127 = v179;
                    unsigned int v128 = v179 + 3;
                    uint64_t v129 = v179[3];
                    uint64_t v110 = a3;
                    if (v129)
                    {
                      **(void **)(a3 + 8) = v129;
                      *(void *)(v127[3] + 40) = *(void *)(a3 + 8);
                      *(void *)(a3 + 8) = v127[4];
                      v127[3] = 0;
                      v127[4] = (uint64_t)v128;
                    }
                    if (v6)
                    {
                      int v130 = *v6 + *(_DWORD *)type;
                      goto LABEL_182;
                    }
LABEL_173:
                    _Block_object_dispose(&v178, 8);
                    return 1;
                  }
                  os_log_t v131 = __nwlog_obj();
                  if (os_log_type_enabled(v131, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)v190 = 136446466;
                    v191 = "nw_protocol_tcp_get_slab_frame";
                    __int16 v192 = 1024;
                    *(_DWORD *)v193 = v124;
                    _os_log_impl(&dword_214653000, v131, OS_LOG_TYPE_ERROR, "%{public}s tcp get malloc failed for %u bytes", v190, 0x12u);
                  }
                  *(void *)&long long buf = MEMORY[0x263EF8330];
                  *((void *)&buf + 1) = 0x40000000;
                  v185 = __nw_protocol_tcp_get_slab_frame_block_invoke;
                  v186 = &unk_264217450;
                  v187 = &v178;
                  uint64_t v188 = v23;
                  v189 = v18;
                  uint64_t v132 = v179[3];
                  do
                  {
                    if (!v132) {
                      break;
                    }
                    uint64_t v133 = *(void *)(v132 + 32);
                    char v134 = ((uint64_t (*)(long long *))v185)(&buf);
                    uint64_t v132 = v133;
                  }
                  while ((v134 & 1) != 0);
                  uint64_t v110 = a3;
                  unsigned int v50 = a2;
                  if (v179[3])
                  {
                    v165 = __nwlog_obj();
                    os_log_type_enabled(v165, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)v190 = 136446210;
                    v191 = "nw_protocol_tcp_get_slab_frame";
                    v166 = (void *)_os_log_send_and_compose_impl();
                    uint64_t result = __nwlog_abort();
                    if (result) {
                      goto LABEL_277;
                    }
                    free(v166);
                    uint64_t v110 = a3;
                    unsigned int v50 = a2;
                    unsigned int v7 = v170;
                    uint64_t v10 = v171;
                    uint64_t v6 = a5;
                    if (a5) {
                      goto LABEL_181;
                    }
                  }
                  else
                  {
                    uint64_t v6 = a5;
                    if (a5)
                    {
LABEL_181:
                      int v130 = 0;
LABEL_182:
                      *uint64_t v6 = v130;
                    }
                  }
                  _Block_object_dispose(&v178, 8);
                  if ((v126 & 1) == 0) {
                    return nw_protocol_tcp_get_malloc_frame(v10, v50, v110, v7, v6);
                  }
                  return 1;
                }
                uint64_t v58 = v57;
                uint64_t v59 = v18[26];
                if (v59)
                {
                  uint64_t v61 = *(void *)(v59 + 16);
                  int v62 = *(void **)(v59 + 24);
                  os_log_type_t v60 = (void *)(v59 + 16);
                  if (v61)
                  {
                    *(void *)(v61 + 24) = v62;
                    int v62 = *(void **)(v59 + 24);
                  }
                  else
                  {
                    v18[27] = v62;
                  }
                  *int v62 = v61;
                  *os_log_type_t v60 = 0;
                  *(void *)(v59 + 24) = 0;
                  unsigned int v66 = (uint64_t *)v18[29];
                  *(void *)(v59 + 24) = v66;
                  uint64_t *v66 = v59;
                  v18[29] = v60;
                  uint64_t v67 = v18[3];
                  if (v67 <= 0)
                  {
                    v107 = __nwlog_obj();
                    os_log_type_enabled(v107, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)v190 = 136446210;
                    v191 = "nw_protocol_tcp_get_slab_frame";
                    v108 = (void *)_os_log_send_and_compose_impl();
                    uint64_t result = __nwlog_abort();
                    if (result) {
                      goto LABEL_277;
                    }
                    free(v108);
                    uint64_t v67 = v18[3];
                  }
                  v18[3] = v67 - 1;
                  int v68 = *(unsigned __int16 *)(v59 + 204);
                  *(void *)(v59 + 80) = nw_frame_tcp_finalize;
                  *(void *)(v59 + 88) = v18;
                  *(void *)(v59 + 112) = v58;
                  *(void *)(v59 + 104) = 0;
                  *(_WORD *)(v59 + 196) = 0;
                  *(_DWORD *)(v59 + 48) = v49;
                  *(_DWORD *)(v59 + 52) = v49;
                  *(void *)(v59 + 56) = 0;
                  *(_DWORD *)(v59 + 192) = 0;
                  *(unsigned char *)(v59 + 200) = 0;
                  unsigned int v69 = v68 & 0xFFFFFFC7 | (*(unsigned __int8 *)(v59 + 206) << 16);
                  *(_WORD *)(v59 + 204) = v69;
                  *(unsigned char *)(v59 + 206) = BYTE2(v69);
                  __int16 v70 = *(void **)(v59 + 64);
                  if (v70)
                  {
                    do
                    {
                      char v71 = (void *)*v70;
                      int v72 = (void *)v70[6];
                      int v73 = (void *)*v70;
                      if (v72)
                      {
                        nw_release(v72);
                        v70[6] = 0;
                        int v73 = (void *)*v70;
                      }
                      int v74 = (void *)v70[1];
                      if (v73)
                      {
                        v73[1] = v74;
                        int v74 = (void *)v70[1];
                      }
                      else
                      {
                        *(void *)(v59 + 72) = v74;
                      }
                      *int v74 = v73;
                      if (v70 != (void *)(v59 + 120)) {
                        free(v70);
                      }
                      __int16 v70 = v71;
                    }
                    while (v71);
                  }
                  *(void *)(v59 + 64) = 0;
                  *(void *)(v59 + 72) = v59 + 64;
                  int v75 = *(void **)(v59 + 168);
                  if (v75) {
                    nw_release(v75);
                  }
                  __int16 v76 = *(_WORD *)(v59 + 204);
                  *(void *)(v59 + 184) = 0;
                  *(_OWORD *)(v59 + 168) = 0u;
                  *(_OWORD *)(v59 + 152) = 0u;
                  *(_OWORD *)(v59 + 136) = 0u;
                  *(_OWORD *)(v59 + 120) = 0u;
                  *(_WORD *)(v59 + 204) = v76 & 0x213F;
                  *(unsigned char *)(v59 + 203) = 0;
                  *(_WORD *)(v59 + 198) = 0;
                  *(void *)(v59 + 104) = v23;
                  uint64_t v6 = a5;
                }
                else
                {
                  uint64_t v63 = nw_frame_create();
                  if (!v63)
                  {
                    __nwlog_obj();
                    *(_DWORD *)v190 = 136446210;
                    v191 = "nw_protocol_tcp_get_slab_frame";
                    uint64_t v115 = (void *)_os_log_send_and_compose_impl();
                    type[0] = OS_LOG_TYPE_ERROR;
                    char v183 = 0;
                    if (!__nwlog_fault()) {
                      goto LABEL_164;
                    }
                    if (type[0] == OS_LOG_TYPE_FAULT)
                    {
                      int v116 = __nwlog_obj();
                      os_log_type_t v117 = type[0];
                      if (os_log_type_enabled(v116, type[0]))
                      {
                        *(_DWORD *)v190 = 136446210;
                        v191 = "nw_protocol_tcp_get_slab_frame";
                        int v118 = "%{public}s nw_frame_create failed";
                        goto LABEL_162;
                      }
                      goto LABEL_164;
                    }
                    if (v183)
                    {
                      os_log_t backtrace_string = (void *)__nw_create_backtrace_string();
                      int v120 = __nwlog_obj();
                      BOOL v121 = os_log_type_enabled(v120, type[0]);
                      if (backtrace_string)
                      {
                        if (v121)
                        {
                          *(_DWORD *)v190 = 136446466;
                          v191 = "nw_protocol_tcp_get_slab_frame";
                          __int16 v192 = 2082;
                          *(void *)v193 = backtrace_string;
                          _os_log_impl(&dword_214653000, v120, type[0], "%{public}s nw_frame_create failed, dumping backtrace:%{public}s", v190, 0x16u);
                        }
                        free(backtrace_string);
                        goto LABEL_164;
                      }
                      if (!v121)
                      {
LABEL_164:
                        if (v115) {
                          free(v115);
                        }
                        nw_mem_buffer_free();
                        uint64_t v10 = v171;
                        goto LABEL_167;
                      }
                      *(_DWORD *)v190 = 136446210;
                      v191 = "nw_protocol_tcp_get_slab_frame";
                      int v118 = "%{public}s nw_frame_create failed, no backtrace";
                      uint64_t v122 = v120;
                      os_log_type_t v123 = type[0];
                    }
                    else
                    {
                      int v116 = __nwlog_obj();
                      os_log_type_t v117 = type[0];
                      if (!os_log_type_enabled(v116, type[0])) {
                        goto LABEL_164;
                      }
                      *(_DWORD *)v190 = 136446210;
                      v191 = "nw_protocol_tcp_get_slab_frame";
                      int v118 = "%{public}s nw_frame_create failed, backtrace limit exceeded";
LABEL_162:
                      uint64_t v122 = v116;
                      os_log_type_t v123 = v117;
                    }
                    _os_log_impl(&dword_214653000, v122, v123, v118, v190, 0xCu);
                    goto LABEL_164;
                  }
                  uint64_t v59 = v63;
                  os_log_type_t v64 = (*(_WORD *)(v63 + 204) & 4) != 0 ? (unsigned char *)(v63 + 208) : 0;
                  *v64 |= 1u;
                  *(void *)(v63 + 104) = v23;
                  *(void *)(v63 + 16) = 0;
                  __int16 v65 = (uint64_t *)v18[29];
                  *(void *)(v63 + 24) = v65;
                  *__int16 v65 = v63;
                  v18[29] = v63 + 16;
                }
                int v77 = v49;
                if (v22 == 1)
                {
                  int v78 = v177;
                  int v77 = v49;
                  if (v177) {
                    break;
                  }
                }
LABEL_135:
                if (v6) {
                  ++*v6;
                }
                v54 += v77;
                *(void *)(v59 + 32) = 0;
                uint64_t v55 = v179;
                int v56 = (uint64_t *)v179[4];
                *(void *)(v59 + 40) = v56;
                *int v56 = v59;
                v55[4] = v59 + 32;
                if (!--v22)
                {
                  v112 = v179;
                  BOOL v113 = v179 + 3;
                  uint64_t v114 = v179[3];
                  if (v114)
                  {
                    **(void **)(a3 + 8) = v114;
                    *(void *)(v112[3] + 40) = *(void *)(a3 + 8);
                    *(void *)(a3 + 8) = v112[4];
                    v112[3] = 0;
                    v112[4] = (uint64_t)v113;
                  }
                  goto LABEL_173;
                }
              }
              if ((*(_WORD *)(v59 + 204) & 0x80) != 0) {
                *(_WORD *)(v59 + 196) -= v177;
              }
              int v79 = *(_DWORD *)(v59 + 52);
              unsigned int v80 = *(_DWORD *)(v59 + 56) + v78;
              int v81 = *(_DWORD *)(v59 + 60);
              if (v80 <= v79 - v81)
              {
                *(_DWORD *)(v59 + 56) = v80;
                uint64_t v6 = a5;
                if (!v79)
                {
LABEL_128:
                  unsigned int v102 = v177;
                  if ((*(_WORD *)(v59 + 204) & 0x80) != 0) {
                    *(_WORD *)(v59 + 196) += v177;
                  }
                  unsigned int v103 = *(_DWORD *)(v59 + 56);
                  BOOL v89 = v103 >= v102;
                  unsigned int v104 = v103 - v102;
                  if (v89)
                  {
                    *(_DWORD *)(v59 + 56) = v104;
                  }
                  else
                  {
                    uint64_t v105 = __nwlog_obj();
                    if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
                    {
                      int v106 = *(_DWORD *)(v59 + 56);
                      *(_DWORD *)v190 = 136446722;
                      v191 = "__nw_frame_unclaim_internal";
                      __int16 v192 = 1024;
                      *(_DWORD *)v193 = v102;
                      *(_WORD *)&v193[4] = 1024;
                      *(_DWORD *)&v193[6] = v106;
                      _os_log_impl(&dword_214653000, v105, OS_LOG_TYPE_ERROR, "%{public}s Frame cannot unclaim %u start bytes (has %u left)", v190, 0x18u);
                    }
                  }
                  int v77 = v177;
                  goto LABEL_135;
                }
              }
              else
              {
                uint64_t v82 = __nwlog_obj();
                if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
                {
                  int v83 = *(_DWORD *)(v59 + 52);
                  *(_DWORD *)v190 = 136446978;
                  v191 = "__nw_frame_claim_internal";
                  __int16 v192 = 1024;
                  *(_DWORD *)v193 = v80;
                  *(_WORD *)&v193[4] = 1024;
                  *(_DWORD *)&v193[6] = v83;
                  LOWORD(v194) = 1024;
                  *(_DWORD *)((char *)&v194 + 2) = v81;
                  _os_log_impl(&dword_214653000, v82, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", v190, 0x1Eu);
                }
                int v79 = *(_DWORD *)(v59 + 52);
                uint64_t v6 = a5;
                if (!v79) {
                  goto LABEL_128;
                }
              }
              uint64_t v85 = *(unsigned int *)(v59 + 56);
              size_t v84 = *(unsigned int *)(v59 + 60);
              uint64_t v86 = (v79 - (v84 + v85));
              if (v79 == v84 + v85) {
                goto LABEL_128;
              }
              if (v84)
              {
                uint64_t v87 = *(void *)(v59 + 112);
                if (v87)
                {
                  memmove((void *)(v87 + v85), (const void *)(v87 + v85 + v86), v84);
                  int v79 = *(_DWORD *)(v59 + 52);
                }
              }
              *(_DWORD *)(v59 + 52) = v79 - v86;
              if ((*(_WORD *)(v59 + 204) & 0x80) == 0) {
                goto LABEL_128;
              }
              unsigned int v88 = *(unsigned __int16 *)(v59 + 196);
              BOOL v89 = v88 >= v86;
              unsigned int v90 = v88 - v86;
              *(_WORD *)(v59 + 196) = v90;
              if (v89 && v90 < 0x10000) {
                goto LABEL_128;
              }
              __nwlog_obj();
              uint64_t v91 = *(unsigned __int16 *)(v59 + 196);
              *(_DWORD *)v190 = 136446978;
              v191 = "__nw_frame_collapse";
              __int16 v192 = 2082;
              *(void *)v193 = "frame->aggregate_buffer_length";
              *(_WORD *)&v193[8] = 2048;
              uint64_t v194 = v86;
              __int16 v195 = 2048;
              uint64_t v196 = v91;
              BOOL v92 = (void *)_os_log_send_and_compose_impl();
              type[0] = OS_LOG_TYPE_ERROR;
              char v183 = 0;
              if (__nwlog_fault())
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  v168 = __nwlog_obj();
                  if (os_log_type_enabled(v168, type[0]))
                  {
                    uint64_t v93 = *(unsigned __int16 *)(v59 + 196);
                    *(_DWORD *)v190 = 136446978;
                    v191 = "__nw_frame_collapse";
                    __int16 v192 = 2082;
                    *(void *)v193 = "frame->aggregate_buffer_length";
                    *(_WORD *)&v193[8] = 2048;
                    uint64_t v194 = v86;
                    __int16 v195 = 2048;
                    uint64_t v196 = v93;
                    int v94 = v168;
                    os_log_type_t v95 = type[0];
                    __int16 v96 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_124:
                    _os_log_impl(&dword_214653000, v94, v95, v96, v190, 0x2Au);
                  }
                }
                else if (v183)
                {
                  int v97 = (void *)__nw_create_backtrace_string();
                  os_log_type_t log = __nwlog_obj();
                  BOOL v98 = os_log_type_enabled(log, type[0]);
                  if (v97)
                  {
                    if (v98)
                    {
                      uint64_t v99 = *(unsigned __int16 *)(v59 + 196);
                      *(_DWORD *)v190 = 136447234;
                      v191 = "__nw_frame_collapse";
                      __int16 v192 = 2082;
                      *(void *)v193 = "frame->aggregate_buffer_length";
                      *(_WORD *)&v193[8] = 2048;
                      uint64_t v194 = v86;
                      __int16 v195 = 2048;
                      uint64_t v196 = v99;
                      __int16 v197 = 2082;
                      v198 = v97;
                      _os_log_impl(&dword_214653000, log, type[0], "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", v190, 0x34u);
                    }
                    free(v97);
                    goto LABEL_125;
                  }
                  if (v98)
                  {
                    uint64_t v101 = *(unsigned __int16 *)(v59 + 196);
                    *(_DWORD *)v190 = 136446978;
                    v191 = "__nw_frame_collapse";
                    __int16 v192 = 2082;
                    *(void *)v193 = "frame->aggregate_buffer_length";
                    *(_WORD *)&v193[8] = 2048;
                    uint64_t v194 = v86;
                    __int16 v195 = 2048;
                    uint64_t v196 = v101;
                    int v94 = log;
                    os_log_type_t v95 = type[0];
                    __int16 v96 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
                    goto LABEL_124;
                  }
                }
                else
                {
                  v169 = __nwlog_obj();
                  if (os_log_type_enabled(v169, type[0]))
                  {
                    uint64_t v100 = *(unsigned __int16 *)(v59 + 196);
                    *(_DWORD *)v190 = 136446978;
                    v191 = "__nw_frame_collapse";
                    __int16 v192 = 2082;
                    *(void *)v193 = "frame->aggregate_buffer_length";
                    *(_WORD *)&v193[8] = 2048;
                    uint64_t v194 = v86;
                    __int16 v195 = 2048;
                    uint64_t v196 = v100;
                    int v94 = v169;
                    os_log_type_t v95 = type[0];
                    __int16 v96 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
                    goto LABEL_124;
                  }
                }
              }
LABEL_125:
              if (v92) {
                free(v92);
              }
              *(_WORD *)(v59 + 196) = 0;
              goto LABEL_128;
            }
LABEL_250:
            _Block_object_dispose(&v178, 8);
            uint64_t v110 = a3;
            unsigned int v50 = a2;
            return nw_protocol_tcp_get_malloc_frame(v10, v50, v110, v7, v6);
          }
          unsigned int v142 = a4;
          __nwlog_obj();
          *(_DWORD *)v190 = 136446210;
          v191 = "nw_tcp_access_context";
          BOOL v143 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          char v183 = 0;
          if (__nwlog_fault())
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              v144 = __nwlog_obj();
              os_log_type_t v145 = type[0];
              if (!os_log_type_enabled(v144, type[0])) {
                goto LABEL_266;
              }
              *(_DWORD *)v190 = 136446210;
              v191 = "nw_tcp_access_context";
              int v146 = "%{public}s called with null tcp";
              goto LABEL_264;
            }
            if (!v183)
            {
              v144 = __nwlog_obj();
              os_log_type_t v145 = type[0];
              if (!os_log_type_enabled(v144, type[0])) {
                goto LABEL_266;
              }
              *(_DWORD *)v190 = 136446210;
              v191 = "nw_tcp_access_context";
              int v146 = "%{public}s called with null tcp, backtrace limit exceeded";
              goto LABEL_264;
            }
            v157 = (void *)__nw_create_backtrace_string();
            unsigned int v154 = __nwlog_obj();
            os_log_type_t v155 = type[0];
            BOOL v158 = os_log_type_enabled(v154, type[0]);
            if (v157)
            {
              if (v158)
              {
                *(_DWORD *)v190 = 136446466;
                v191 = "nw_tcp_access_context";
                __int16 v192 = 2082;
                *(void *)v193 = v157;
                _os_log_impl(&dword_214653000, v154, type[0], "%{public}s called with null tcp, dumping backtrace:%{public}s", v190, 0x16u);
              }
              free(v157);
              if (!v143) {
                goto LABEL_268;
              }
              goto LABEL_267;
            }
            if (v158)
            {
              *(_DWORD *)v190 = 136446210;
              v191 = "nw_tcp_access_context";
              int v146 = "%{public}s called with null tcp, no backtrace";
              goto LABEL_276;
            }
          }
        }
        else
        {
          unsigned int v142 = a4;
          __nwlog_obj();
          *(_DWORD *)v190 = 136446210;
          v191 = "nw_tcp_access_context";
          BOOL v143 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          char v183 = 0;
          if (!__nwlog_fault()) {
            goto LABEL_266;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v144 = __nwlog_obj();
            os_log_type_t v145 = type[0];
            if (!os_log_type_enabled(v144, type[0])) {
              goto LABEL_266;
            }
            *(_DWORD *)v190 = 136446210;
            v191 = "nw_tcp_access_context";
            int v146 = "%{public}s called with null so";
LABEL_264:
            uint64_t v163 = v144;
            os_log_type_t v164 = v145;
LABEL_265:
            _os_log_impl(&dword_214653000, v163, v164, v146, v190, 0xCu);
            goto LABEL_266;
          }
          if (!v183)
          {
            v144 = __nwlog_obj();
            os_log_type_t v145 = type[0];
            if (!os_log_type_enabled(v144, type[0])) {
              goto LABEL_266;
            }
            *(_DWORD *)v190 = 136446210;
            v191 = "nw_tcp_access_context";
            int v146 = "%{public}s called with null so, backtrace limit exceeded";
            goto LABEL_264;
          }
          __int16 v153 = (void *)__nw_create_backtrace_string();
          unsigned int v154 = __nwlog_obj();
          os_log_type_t v155 = type[0];
          BOOL v156 = os_log_type_enabled(v154, type[0]);
          if (v153)
          {
            if (v156)
            {
              *(_DWORD *)v190 = 136446466;
              v191 = "nw_tcp_access_context";
              __int16 v192 = 2082;
              *(void *)v193 = v153;
              _os_log_impl(&dword_214653000, v154, type[0], "%{public}s called with null so, dumping backtrace:%{public}s", v190, 0x16u);
            }
            free(v153);
          }
          else if (v156)
          {
            *(_DWORD *)v190 = 136446210;
            v191 = "nw_tcp_access_context";
            int v146 = "%{public}s called with null so, no backtrace";
LABEL_276:
            uint64_t v163 = v154;
            os_log_type_t v164 = v155;
            goto LABEL_265;
          }
        }
LABEL_266:
        if (!v143)
        {
LABEL_268:
          uint64_t v6 = a5;
          unsigned int v17 = a2;
          unsigned int v7 = v142;
          goto LABEL_17;
        }
LABEL_267:
        free(v143);
        goto LABEL_268;
      }
      uint64_t v172 = a1;
      unsigned int v135 = 0;
      __nwlog_obj();
      *(_DWORD *)v190 = 136446210;
      v191 = "nw_protocol_tcp_get_slab_frame";
      unsigned int v136 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      char v183 = 0;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          unsigned int v137 = __nwlog_obj();
          os_log_type_t v138 = type[0];
          if (!os_log_type_enabled(v137, type[0])) {
            goto LABEL_247;
          }
          *(_DWORD *)v190 = 136446210;
          v191 = "nw_protocol_tcp_get_slab_frame";
          v139 = "%{public}s called with null (max_frame_count > 0)";
          goto LABEL_245;
        }
        if (!v183)
        {
          unsigned int v137 = __nwlog_obj();
          os_log_type_t v138 = type[0];
          uint64_t v6 = a5;
          if (!os_log_type_enabled(v137, type[0])) {
            goto LABEL_247;
          }
          *(_DWORD *)v190 = 136446210;
          v191 = "nw_protocol_tcp_get_slab_frame";
          v139 = "%{public}s called with null (max_frame_count > 0), backtrace limit exceeded";
          goto LABEL_245;
        }
        __int16 v151 = (void *)__nw_create_backtrace_string();
        int v148 = __nwlog_obj();
        os_log_type_t v149 = type[0];
        BOOL v152 = os_log_type_enabled(v148, type[0]);
        if (v151)
        {
          if (v152)
          {
            *(_DWORD *)v190 = 136446466;
            v191 = "nw_protocol_tcp_get_slab_frame";
            __int16 v192 = 2082;
            *(void *)v193 = v151;
            _os_log_impl(&dword_214653000, v148, type[0], "%{public}s called with null (max_frame_count > 0), dumping backtrace:%{public}s", v190, 0x16u);
          }
          free(v151);
          uint64_t v6 = a5;
          if (!v136) {
            goto LABEL_249;
          }
          goto LABEL_248;
        }
        uint64_t v6 = a5;
        if (v152)
        {
          *(_DWORD *)v190 = 136446210;
          v191 = "nw_protocol_tcp_get_slab_frame";
          v139 = "%{public}s called with null (max_frame_count > 0), no backtrace";
          goto LABEL_259;
        }
      }
    }
    else
    {
      uint64_t v172 = a1;
      unsigned int v135 = a4;
      __nwlog_obj();
      *(_DWORD *)v190 = 136446210;
      v191 = "nw_protocol_tcp_get_slab_frame";
      unsigned int v136 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      char v183 = 0;
      if (!__nwlog_fault()) {
        goto LABEL_247;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        unsigned int v137 = __nwlog_obj();
        os_log_type_t v138 = type[0];
        if (!os_log_type_enabled(v137, type[0])) {
          goto LABEL_247;
        }
        *(_DWORD *)v190 = 136446210;
        v191 = "nw_protocol_tcp_get_slab_frame";
        v139 = "%{public}s called with null ret_frame_array";
LABEL_245:
        uint64_t v159 = v137;
        os_log_type_t v160 = v138;
LABEL_246:
        _os_log_impl(&dword_214653000, v159, v160, v139, v190, 0xCu);
        goto LABEL_247;
      }
      if (!v183)
      {
        unsigned int v137 = __nwlog_obj();
        os_log_type_t v138 = type[0];
        uint64_t v6 = a5;
        if (!os_log_type_enabled(v137, type[0])) {
          goto LABEL_247;
        }
        *(_DWORD *)v190 = 136446210;
        v191 = "nw_protocol_tcp_get_slab_frame";
        v139 = "%{public}s called with null ret_frame_array, backtrace limit exceeded";
        goto LABEL_245;
      }
      int v147 = (void *)__nw_create_backtrace_string();
      int v148 = __nwlog_obj();
      os_log_type_t v149 = type[0];
      BOOL v150 = os_log_type_enabled(v148, type[0]);
      if (v147)
      {
        if (v150)
        {
          *(_DWORD *)v190 = 136446466;
          v191 = "nw_protocol_tcp_get_slab_frame";
          __int16 v192 = 2082;
          *(void *)v193 = v147;
          _os_log_impl(&dword_214653000, v148, type[0], "%{public}s called with null ret_frame_array, dumping backtrace:%{public}s", v190, 0x16u);
        }
        free(v147);
        uint64_t v6 = a5;
      }
      else
      {
        uint64_t v6 = a5;
        if (v150)
        {
          *(_DWORD *)v190 = 136446210;
          v191 = "nw_protocol_tcp_get_slab_frame";
          v139 = "%{public}s called with null ret_frame_array, no backtrace";
LABEL_259:
          uint64_t v159 = v148;
          os_log_type_t v160 = v149;
          goto LABEL_246;
        }
      }
    }
LABEL_247:
    if (!v136)
    {
LABEL_249:
      unsigned int v7 = v135;
      uint64_t v10 = v172;
      goto LABEL_250;
    }
LABEL_248:
    free(v136);
    goto LABEL_249;
  }
  if (!a3)
  {
    __nwlog_obj();
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
    uint64_t v41 = (void *)_os_log_send_and_compose_impl();
    v190[0] = 16;
    LOBYTE(v178) = 0;
    if (!__nwlog_fault()) {
      goto LABEL_152;
    }
    if (v190[0] == 17)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = v190[0];
      if (!os_log_type_enabled(v42, (os_log_type_t)v190[0])) {
        goto LABEL_152;
      }
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
      int v44 = "%{public}s called with null ret_frame_array";
    }
    else
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = v190[0];
      if (!os_log_type_enabled(v42, (os_log_type_t)v190[0])) {
        goto LABEL_152;
      }
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
      int v44 = "%{public}s called with null ret_frame_array, backtrace limit exceeded";
    }
    goto LABEL_151;
  }
  if (!a4)
  {
    __nwlog_obj();
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
    uint64_t v41 = (void *)_os_log_send_and_compose_impl();
    v190[0] = 16;
    LOBYTE(v178) = 0;
    if (!__nwlog_fault()) {
      goto LABEL_152;
    }
    if (v190[0] == 17)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = v190[0];
      if (!os_log_type_enabled(v42, (os_log_type_t)v190[0])) {
        goto LABEL_152;
      }
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
      int v44 = "%{public}s called with null (max_frame_count > 0)";
    }
    else
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = v190[0];
      if (!os_log_type_enabled(v42, (os_log_type_t)v190[0])) {
        goto LABEL_152;
      }
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
      int v44 = "%{public}s called with null (max_frame_count > 0), backtrace limit exceeded";
    }
    goto LABEL_151;
  }
  uint64_t v11 = (void *)nw_tcp_access_globals(a1);
  uint64_t v12 = v11;
  if (v6) {
    *uint64_t v6 = 0;
  }
  uint64_t v13 = v11[22];
  if (!v13)
  {
    uint64_t external = nw_frame_create_external();
    if (external)
    {
      if ((*(_WORD *)(external + 204) & 4) != 0) {
        uint64_t v27 = (unsigned char *)(external + 208);
      }
      else {
        uint64_t v27 = 0;
      }
      *v27 |= 2u;
      *(void *)(external + 16) = 0;
      uint64_t v28 = (uint64_t *)v12[25];
      *(void *)(external + 24) = v28;
      uint64_t *v28 = external;
      v12[25] = external + 16;
      *(void *)(external + 32) = 0;
      int v29 = *(uint64_t **)(a3 + 8);
      *(void *)(external + 40) = v29;
      *int v29 = external;
      *(void *)(a3 + 8) = external + 32;
      uint64_t result = 1;
      if (v6) {
        *uint64_t v6 = 1;
      }
      return result;
    }
    __nwlog_obj();
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
    uint64_t v41 = (void *)_os_log_send_and_compose_impl();
    v190[0] = 16;
    LOBYTE(v178) = 0;
    if (!__nwlog_fault()) {
      goto LABEL_152;
    }
    if (v190[0] == 17)
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = v190[0];
      if (os_log_type_enabled(v42, (os_log_type_t)v190[0]))
      {
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
        int v44 = "%{public}s nw_frame_create_external failed";
LABEL_151:
        _os_log_impl(&dword_214653000, v42, v43, v44, (uint8_t *)&buf, 0xCu);
      }
    }
    else
    {
      BOOL v42 = __nwlog_obj();
      os_log_type_t v43 = v190[0];
      if (os_log_type_enabled(v42, (os_log_type_t)v190[0]))
      {
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
        int v44 = "%{public}s nw_frame_create_external failed, backtrace limit exceeded";
        goto LABEL_151;
      }
    }
LABEL_152:
    if (v41) {
      free(v41);
    }
    return 0;
  }
  uint64_t v15 = *(void *)(v13 + 16);
  uint64_t v16 = *(void **)(v13 + 24);
  BOOL v14 = (void *)(v13 + 16);
  if (v15)
  {
    *(void *)(v15 + 24) = v16;
    uint64_t v16 = *(void **)(v13 + 24);
  }
  else
  {
    v11[23] = v16;
  }
  *uint64_t v16 = v15;
  *BOOL v14 = 0;
  *(void *)(v13 + 24) = 0;
  int v30 = (void *)v11[25];
  *(void *)(v13 + 24) = v30;
  *int v30 = v13;
  v11[25] = v14;
  --v11[2];
  LODWORD(v30) = *(unsigned __int16 *)(v13 + 204);
  int v31 = v30 | (*(unsigned __int8 *)(v13 + 206) << 16);
  if ((v30 & 2) == 0)
  {
    v140 = __nwlog_obj();
    os_log_type_enabled(v140, OS_LOG_TYPE_ERROR);
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
    os_log_type_t v141 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if (result)
    {
LABEL_277:
      __break(1u);
      return result;
    }
    free(v141);
    int v31 = *(unsigned __int16 *)(v13 + 204) | (*(unsigned __int8 *)(v13 + 206) << 16);
  }
  int v32 = *(void **)(v13 + 64);
  *(void *)(v13 + 80) = nw_frame_tcp_finalize;
  *(void *)(v13 + 88) = v12;
  *(void *)(v13 + 104) = 0;
  *(void *)(v13 + 112) = 0;
  *(_WORD *)(v13 + 196) = 0;
  *(_DWORD *)(v13 + 48) = a2;
  *(_DWORD *)(v13 + 52) = a2;
  *(void *)(v13 + 56) = 0;
  *(_DWORD *)(v13 + 192) = 0;
  *(unsigned char *)(v13 + 200) = 0;
  unsigned int v33 = v31 & 0xFFFFFFC7;
  *(_WORD *)(v13 + 204) = v33;
  *(unsigned char *)(v13 + 206) = BYTE2(v33);
  if (v32)
  {
    do
    {
      int v34 = (void *)*v32;
      int v35 = (void *)v32[6];
      int v36 = (void *)*v32;
      if (v35)
      {
        nw_release(v35);
        v32[6] = 0;
        int v36 = (void *)*v32;
      }
      uint64_t v37 = (void *)v32[1];
      if (v36)
      {
        v36[1] = v37;
        uint64_t v37 = (void *)v32[1];
      }
      else
      {
        *(void *)(v13 + 72) = v37;
      }
      *uint64_t v37 = v36;
      if (v32 != (void *)(v13 + 120)) {
        free(v32);
      }
      int v32 = v34;
    }
    while (v34);
  }
  *(void *)(v13 + 64) = 0;
  *(void *)(v13 + 72) = v13 + 64;
  uint64_t v38 = *(void **)(v13 + 168);
  if (v38) {
    nw_release(v38);
  }
  *(void *)(v13 + 184) = 0;
  *(_OWORD *)(v13 + 168) = 0u;
  *(_OWORD *)(v13 + 152) = 0u;
  *(_OWORD *)(v13 + 136) = 0u;
  *(_OWORD *)(v13 + 120) = 0u;
  *(_WORD *)(v13 + 204) &= 0x213Fu;
  *(unsigned char *)(v13 + 203) = 0;
  *(void *)(v13 + 32) = 0;
  *(_WORD *)(v13 + 198) = 0;
  os_log_type_t v39 = *(void **)(a3 + 8);
  *(void *)(v13 + 40) = v39;
  *os_log_type_t v39 = v13;
  *(void *)(a3 + 8) = v13 + 32;
  uint64_t result = 1;
  if (a5) {
    *a5 = 1;
  }
  return result;
}

uint64_t nw_protocol_tcp_get_frame_count(unsigned int a1, unsigned int a2, int *a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a2)
  {
    uint64_t result = (a1 + a2 - 1) / a2;
    if (a3) {
      *a3 = a1 % a2;
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v8 = "nw_protocol_tcp_get_frame_count";
    uint64_t v5 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v6 = __nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v8 = "nw_protocol_tcp_get_frame_count";
        _os_log_impl(&dword_214653000, v6, OS_LOG_TYPE_ERROR, "%{public}s called with null (buffer_size > 0), backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v5) {
      free(v5);
    }
    return 0;
  }
  return result;
}

void *tcp_input(uint64_t *a1, uint64_t a2, uint64_t a3, unsigned char *a4, unsigned char *a5, BOOL *a6)
{
  uint64_t v919 = *MEMORY[0x263EF8340];
  uint64_t v11 = nw_frame_array_first();
  uint64_t v12 = v11;
  int v891 = 0;
  uint64_t v13 = *(void *)(a3 + 240);
  uint64_t v14 = *(void *)(a3 + 224);
  uint64_t v890 = 0;
  uint64_t v889 = 0;
  memset(v888, 0, sizeof(v888));
  if (!v11)
  {
    uint64_t v18 = a5;
    uint64_t v829 = v13;
    *(void *)v840 = v14;
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    v894 = "__nw_frame_get_ecn_flag";
    int v19 = (void *)_os_log_send_and_compose_impl();
    LOBYTE(v914) = 16;
    LOBYTE(v887) = 0;
    if (!__nwlog_fault()) {
      goto LABEL_20;
    }
    if (v914 == 17)
    {
      unsigned int v20 = __nwlog_obj();
      os_log_type_t v21 = v914;
      if (!os_log_type_enabled(v20, (os_log_type_t)v914)) {
        goto LABEL_20;
      }
      *(_DWORD *)long long buf = 136446210;
      v894 = "__nw_frame_get_ecn_flag";
      unsigned int v22 = "%{public}s called with null frame";
    }
    else
    {
      unsigned int v20 = __nwlog_obj();
      os_log_type_t v21 = v914;
      if (!os_log_type_enabled(v20, (os_log_type_t)v914)) {
        goto LABEL_20;
      }
      *(_DWORD *)long long buf = 136446210;
      v894 = "__nw_frame_get_ecn_flag";
      unsigned int v22 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_214653000, v20, v21, v22, buf, 0xCu);
LABEL_20:
    if (v19) {
      free(v19);
    }
    unsigned int v855 = 0;
    uint64_t v14 = *(void *)v840;
    uint64_t v13 = v829;
    a5 = v18;
    v885 = a1;
    if (a2) {
      goto LABEL_3;
    }
LABEL_23:
    uint64_t v16 = 0;
    int v15 = 0;
    uint64_t v17 = 0;
    goto LABEL_24;
  }
  unsigned int v855 = *(unsigned char *)(v11 + 186) & 3;
  v885 = a1;
  if (!a2) {
    goto LABEL_23;
  }
LABEL_3:
  if (*(unsigned __int8 *)(a2 + 1076) == 255 || *(_DWORD *)(a2 + 1024) == 255)
  {
    int v15 = 1;
  }
  else
  {
    if (*(_DWORD *)(a2 + 1068) == 3)
    {
      int v15 = 0;
      uint64_t v17 = 0;
      uint64_t v16 = 1;
      goto LABEL_24;
    }
    int v15 = 0;
    if (*(_DWORD *)(a2 + 1032) == 3)
    {
      uint64_t v16 = 1;
      uint64_t v17 = 0;
      goto LABEL_24;
    }
  }
  uint64_t v16 = 0;
  uint64_t v17 = *(_DWORD *)(a2 + 1064) == 2 || *(_DWORD *)(a2 + 1028) == 2;
LABEL_24:
  int v887 = 0;
  if (a5) {
    *a5 = 0;
  }
  uint64_t v23 = nw_tcp_access_globals(*(void *)(*(void *)(v13 + 80) + 224));
  uint64_t v24 = v23;
  do
  {
    int v25 = *(_DWORD *)(a3 + 456);
    if ((_WORD)v25 == 0xFFFF) {
      break;
    }
    int v26 = *(_DWORD *)(a3 + 456);
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(a3 + 456), (unsigned int *)&v26, v25 + 1, memory_order_relaxed, memory_order_relaxed);
  }
  while (v26 != v25);
  if (!v12 || !v13) {
    goto LABEL_42;
  }
  HIDWORD(v839) = HIDWORD(v6);
  uint64_t v27 = *(void *)(v12 + 112);
  uint64_t v28 = (void *)MEMORY[0x263F144B8];
  if (!v27)
  {
LABEL_38:
    if ((*(_WORD *)(v12 + 204) & 0x100) != 0
      && *v28
      && (((uint64_t (*)(uint64_t, void))*v28)(v12, *(void *)(v12 + 88)) & 1) == 0)
    {
      *(void *)(v13 + 1056) = 0;
    }
LABEL_42:
    uint64_t v38 = *(void *)(v13 + 1056);
    if (v38)
    {
      ++*(void *)(v38 + 152);
      ++*(void *)(v38 + 232);
    }
    in_pcb_checkstate(a3, 2, 1);
    os_log_type_t v39 = a6;
    unsigned int v40 = v885;
    if (v14 && (*(unsigned char *)(v14 + 828) & 2) != 0) {
      goto LABEL_62;
    }
    uint64_t v41 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_INFO)) {
      goto LABEL_62;
    }
    BOOL v42 = "";
    if (v14) {
      BOOL v42 = (const char *)(v14 + 604);
    }
    *(_DWORD *)long long buf = 136446466;
    v894 = "tcp_input";
    __int16 v895 = 2082;
    *(void *)v896 = v42;
    os_log_type_t v43 = "%{public}s %{public}s failed to get tcp header";
    int v44 = v41;
    os_log_type_t v45 = OS_LOG_TYPE_INFO;
LABEL_60:
    uint32_t v50 = 22;
LABEL_61:
    _os_log_impl(&dword_214653000, v44, v45, v43, buf, v50);
LABEL_62:
    int v51 = 0;
    goto LABEL_63;
  }
  if ((*(_WORD *)(v12 + 204) & 0x100) != 0 && *MEMORY[0x263F144B8])
  {
    uint64_t v29 = v16;
    int v30 = v15;
    uint64_t v31 = v17;
    uint64_t v32 = v23;
    int v33 = ((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(v12, *(void *)(v12 + 88));
    uint64_t v24 = v32;
    uint64_t v17 = v31;
    int v15 = v30;
    uint64_t v16 = v29;
    uint64_t v28 = (void *)MEMORY[0x263F144B8];
    if (v33)
    {
      uint64_t v34 = *(void *)(v12 + 112);
      if (v34)
      {
        uint64_t v35 = *(unsigned int *)(v12 + 56);
        uint64_t v36 = v34 + v35;
        int v37 = *(_DWORD *)(v12 + 52);
        if (!v37) {
          goto LABEL_52;
        }
        goto LABEL_51;
      }
    }
    goto LABEL_38;
  }
  uint64_t v35 = *(unsigned int *)(v12 + 56);
  uint64_t v36 = v27 + v35;
  int v37 = *(_DWORD *)(v12 + 52);
  if (!v37)
  {
LABEL_52:
    uint64_t v47 = *(void *)(v13 + 1056);
    if (v47)
    {
      ++*(void *)(v47 + 152);
      ++*(void *)(v47 + 368);
    }
    in_pcb_checkstate(a3, 2, 1);
    os_log_type_t v39 = a6;
    unsigned int v40 = v885;
    if (v14 && (*(unsigned char *)(v14 + 828) & 2) != 0) {
      goto LABEL_62;
    }
    unsigned int v48 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
      goto LABEL_62;
    }
    int v49 = "";
    if (v14) {
      int v49 = (const char *)(v14 + 604);
    }
    *(_DWORD *)long long buf = 136446466;
    v894 = "tcp_input";
    __int16 v895 = 2082;
    *(void *)v896 = v49;
    os_log_type_t v43 = "%{public}s %{public}s buffer smaller than tcp header";
    int v44 = v48;
    os_log_type_t v45 = OS_LOG_TYPE_ERROR;
    goto LABEL_60;
  }
LABEL_51:
  int v46 = v37 - (v35 + *(_DWORD *)(v12 + 60));
  if (v46 <= 19) {
    goto LABEL_52;
  }
  unint64_t v62 = ((unint64_t)*(unsigned __int8 *)(v36 + 12) >> 2) & 0x3C;
  BOOL v63 = v62 >= 0x14 && v46 >= v62;
  unint64_t v837 = ((unint64_t)*(unsigned __int8 *)(v36 + 12) >> 2) & 0x3C;
  if (!v63)
  {
    uint64_t v64 = *(void *)(v13 + 1056);
    if (v64)
    {
      ++*(void *)(v64 + 152);
      ++*(void *)(v64 + 360);
    }
    in_pcb_checkstate(a3, 2, 1);
    os_log_type_t v39 = a6;
    unsigned int v40 = v885;
    if (v14 && (*(unsigned char *)(v14 + 828) & 2) != 0) {
      goto LABEL_62;
    }
    __int16 v65 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
      goto LABEL_62;
    }
    unsigned int v66 = (const char *)(v14 + 604);
    v894 = "tcp_input";
    *(_DWORD *)long long buf = 136446722;
    if (!v14) {
      unsigned int v66 = "";
    }
    __int16 v895 = 2082;
    *(void *)v896 = v66;
    *(_WORD *)&v896[8] = 1024;
    *(_DWORD *)v897 = v837;
    os_log_type_t v43 = "%{public}s %{public}s offset does not make any sense: %u";
    int v44 = v65;
    os_log_type_t v45 = OS_LOG_TYPE_ERROR;
    uint32_t v50 = 28;
    goto LABEL_61;
  }
  int v824 = v62 - 20;
  uint64_t v828 = v24;
  uint64_t v842 = v14;
  uint64_t v823 = v36;
  __memcpy_chk();
  if ((*(_WORD *)(v12 + 204) & 0x100) != 0
    && *v28
    && (((uint64_t (*)(uint64_t, void))*v28)(v12, *(void *)(v12 + 88)) & 1) == 0)
  {
    os_log_type_t v39 = a6;
    unsigned int v40 = v885;
    uint64_t v108 = v13;
    uint64_t v109 = *(void *)(v13 + 1056);
    if (v109) {
      ++*(void *)(v109 + 152);
    }
    in_pcb_checkstate(a3, 2, 1);
    if (!v842 || (*(unsigned char *)(v842 + 828) & 2) == 0)
    {
      uint64_t v110 = __nwlog_tcp_log();
      if (os_log_type_enabled(v110, OS_LOG_TYPE_INFO))
      {
        v111 = "";
        if (v842) {
          v111 = (const char *)(v842 + 604);
        }
        *(_DWORD *)long long buf = 136446466;
        v894 = "tcp_input";
        __int16 v895 = 2082;
        *(void *)v896 = v111;
        _os_log_impl(&dword_214653000, v110, OS_LOG_TYPE_INFO, "%{public}s %{public}s buffer no longer valid", buf, 0x16u);
      }
    }
    int v51 = 0;
    *(void *)(v108 + 1056) = 0;
    goto LABEL_63;
  }
  uint64_t v67 = *v885;
  uint64_t v830 = v13;
  v821 = a5;
  uint64_t v822 = a2;
  if (!*v885)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    v894 = "__nw_frame_is_single_ip_aggregate";
    v112 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v892 = 0;
    if (!__nwlog_fault()) {
      goto LABEL_221;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v113 = __nwlog_obj();
      os_log_type_t v114 = type[0];
      if (!os_log_type_enabled(v113, type[0])) {
        goto LABEL_221;
      }
      *(_DWORD *)long long buf = 136446210;
      v894 = "__nw_frame_is_single_ip_aggregate";
      uint64_t v115 = "%{public}s called with null frame";
    }
    else
    {
      BOOL v113 = __nwlog_obj();
      os_log_type_t v114 = type[0];
      if (!os_log_type_enabled(v113, type[0])) {
        goto LABEL_221;
      }
      *(_DWORD *)long long buf = 136446210;
      v894 = "__nw_frame_is_single_ip_aggregate";
      uint64_t v115 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_214653000, v113, v114, v115, buf, 0xCu);
LABEL_221:
    if (v112) {
      free(v112);
    }
    int v838 = 0;
    int v70 = 0;
    uint64_t v69 = 0;
LABEL_224:
    uint64_t v99 = v842;
    if (!v842 || (*(unsigned char *)(v842 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v206 = __nwlog_tcp_log();
        if (os_log_type_enabled(v206, OS_LOG_TYPE_DEBUG))
        {
          v894 = "tcp_compute_segment_length";
          __int16 v895 = 2082;
          v207 = "";
          *(_DWORD *)long long buf = 136447234;
          if (v842) {
            v207 = (const char *)(v842 + 604);
          }
          *(void *)v896 = v207;
          *(_WORD *)&v896[8] = 1024;
          *(_DWORD *)v897 = v837;
          *(_WORD *)&v897[4] = 1024;
          *(_DWORD *)&v897[6] = v69;
          __int16 v898 = 1024;
          *(_DWORD *)v899 = v70;
          _os_log_impl(&dword_214653000, v206, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s TCP hlen %d segment length %d on %d buffers", buf, 0x28u);
        }
      }
    }
    int v891 = v69;
    goto LABEL_228;
  }
  char v68 = *(_WORD *)(v67 + 204);
  if ((*(_WORD *)(v67 + 204) & 0x80) != 0)
  {
    uint64_t v69 = *(unsigned __int16 *)(v67 + 196);
    int v891 = *(unsigned __int16 *)(v67 + 196);
    if ((v68 & 0x40) == 0)
    {
      int v70 = *(unsigned __int8 *)(v67 + 200);
      if (*(unsigned char *)(v67 + 200))
      {
LABEL_180:
        uint64_t v99 = v842;
        if (v842 && (*(unsigned char *)(v842 + 828) & 2) != 0 || !__nwlog_is_datapath_logging_enabled())
        {
LABEL_183:
          int v838 = 0;
          goto LABEL_228;
        }
        int v116 = __nwlog_tcp_log();
        if (os_log_type_enabled(v116, OS_LOG_TYPE_DEBUG))
        {
          v894 = "tcp_compute_segment_length";
          __int16 v895 = 2082;
          os_log_type_t v117 = "";
          uint64_t v99 = v842;
          *(_DWORD *)long long buf = 136447234;
          if (v842) {
            os_log_type_t v117 = (const char *)(v842 + 604);
          }
          *(void *)v896 = v117;
          *(_WORD *)&v896[8] = 1024;
          *(_DWORD *)v897 = v837;
          *(_WORD *)&v897[4] = 1024;
          *(_DWORD *)&v897[6] = v69;
          __int16 v898 = 1024;
          *(_DWORD *)v899 = v70;
          _os_log_impl(&dword_214653000, v116, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s TCP hlen %d segment length %d on %d buffers", buf, 0x28u);
          goto LABEL_183;
        }
        int v838 = 0;
        uint64_t v99 = v842;
LABEL_228:
        if (*(_DWORD *)(sysctls + 288)) {
          unsigned int v118 = v70;
        }
        else {
          unsigned int v118 = 1;
        }
        uint64_t v119 = v830;
        uint64_t v120 = *(void *)(v830 + 1056);
        if (v120) {
          *(void *)(v120 + 152) += v118;
        }
        if (v99 && (*(unsigned char *)(v99 + 828) & 2) != 0)
        {
          if (tcp_validate_cksum(v12, v69, v830)) {
            goto LABEL_237;
          }
        }
        else
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            uint64_t v172 = __nwlog_tcp_log();
            if (os_log_type_enabled(v172, OS_LOG_TYPE_DEBUG))
            {
              v173 = (const char *)(v842 + 604);
              if (!v842) {
                v173 = "";
              }
              int v174 = *(_DWORD *)(v830 + 12);
              int v175 = *(_DWORD *)(v830 + 120);
              int v176 = *(_DWORD *)(v830 + 92);
              *(_DWORD *)long long buf = 136449026;
              v894 = "tcp_input";
              __int16 v895 = 2082;
              *(void *)v896 = v173;
              *(_WORD *)&v896[8] = 1024;
              *(_DWORD *)v897 = bswap32((unsigned __int16)v914) >> 16;
              *(_WORD *)&v897[4] = 1024;
              *(_DWORD *)&v897[6] = bswap32(WORD1(v914)) >> 16;
              __int16 v898 = 1024;
              *(_DWORD *)v899 = v69;
              *(_WORD *)&v899[4] = 1024;
              *(_DWORD *)&v899[6] = BYTE13(v914);
              __int16 v900 = 1024;
              unsigned int v901 = bswap32(DWORD1(v914));
              __int16 v902 = 1024;
              unsigned int v903 = bswap32(DWORD2(v914));
              __int16 v904 = 1024;
              unsigned int v905 = bswap32(HIWORD(v914)) >> 16;
              __int16 v906 = 1024;
              int v907 = v174;
              __int16 v908 = 1024;
              int v909 = v175;
              __int16 v910 = 1024;
              int v911 = v176;
              unsigned int v177 = v172;
              uint64_t v99 = v842;
              _os_log_impl(&dword_214653000, v177, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s processing an input-frame, %u:%u tlen %u, flags=%{network:tcp_flags}x seq=%u, ack=%u, win=%u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u", buf, 0x52u);
              LODWORD(v69) = v891;
            }
            else
            {
              uint64_t v99 = v842;
            }
          }
          if (validate_tcp_cksum())
          {
LABEL_237:
            int v875 = v69 - v837;
            int v891 = v69 - v837;
            if (v837 < 0x15)
            {
              int v122 = 0;
              BOOL v121 = 0;
              uint64_t v123 = v828;
            }
            else
            {
              BOOL v121 = (unsigned __int8 *)&v916;
              int v122 = v824;
              uint64_t v123 = v828;
              if ((v824 == 12 || v837 >= 0x21 && !v918) && v916 == 168296705 && (BYTE13(v914) & 2) == 0)
              {
                int v122 = 0;
                BOOL v121 = 0;
                LODWORD(v888[0]) |= 1u;
                *(int8x8_t *)((char *)v888 + 4) = vrev32_s8(v917);
              }
            }
            unsigned int v127 = BYTE13(v914);
            if ((~BYTE13(v914) & 3) == 0) {
              goto LABEL_257;
            }
            int v825 = v122;
            calculate_tcp_clock(v123);
            if (v822) {
              unsigned int v831 = *(unsigned __int16 *)(v822 + 1072);
            }
            else {
              unsigned int v831 = 0;
            }
            v819 = v121;
            unsigned int v834 = v127;
            if ((BYTE13(v914) & 0x24) != 0)
            {
              if (!v842 || (*(unsigned char *)(v842 + 828) & 2) == 0)
              {
                v208 = __nwlog_tcp_log();
                if (os_log_type_enabled(v208, OS_LOG_TYPE_ERROR))
                {
                  v209 = (const char *)(v842 + 604);
                  if (!v842) {
                    v209 = "";
                  }
                  unsigned int v210 = *(_DWORD *)(v830 + 12);
                  unsigned int v211 = *(_DWORD *)(v830 + 120);
                  unsigned int v212 = *(_DWORD *)(v830 + 92);
                  *(_DWORD *)long long buf = 136448258;
                  v894 = "tcp_input";
                  __int16 v895 = 2082;
                  *(void *)v896 = v209;
                  *(_WORD *)&v896[8] = 1024;
                  *(_DWORD *)v897 = BYTE13(v914);
                  *(_WORD *)&v897[4] = 1024;
                  *(_DWORD *)&v897[6] = bswap32(DWORD1(v914));
                  __int16 v898 = 1024;
                  *(_DWORD *)v899 = bswap32(DWORD2(v914));
                  *(_WORD *)&v899[4] = 1024;
                  *(_DWORD *)&v899[6] = bswap32(HIWORD(v914)) >> 16;
                  __int16 v900 = 1024;
                  unsigned int v901 = v210;
                  __int16 v902 = 1024;
                  unsigned int v903 = v211;
                  __int16 v904 = 1024;
                  unsigned int v905 = v212;
                  v213 = v208;
                  os_log_type_t v214 = OS_LOG_TYPE_ERROR;
                  goto LABEL_547;
                }
              }
            }
            else if ((BYTE13(v914) & 3) != 0 && (!v842 || (*(unsigned char *)(v842 + 828) & 2) == 0))
            {
              v215 = __nwlog_tcp_log();
              if (os_log_type_enabled(v215, OS_LOG_TYPE_DEFAULT))
              {
                v216 = (const char *)(v842 + 604);
                if (!v842) {
                  v216 = "";
                }
                unsigned int v217 = *(_DWORD *)(v830 + 12);
                unsigned int v218 = *(_DWORD *)(v830 + 120);
                unsigned int v219 = *(_DWORD *)(v830 + 92);
                *(_DWORD *)long long buf = 136448258;
                v894 = "tcp_input";
                __int16 v895 = 2082;
                *(void *)v896 = v216;
                *(_WORD *)&v896[8] = 1024;
                *(_DWORD *)v897 = BYTE13(v914);
                *(_WORD *)&v897[4] = 1024;
                *(_DWORD *)&v897[6] = bswap32(DWORD1(v914));
                __int16 v898 = 1024;
                *(_DWORD *)v899 = bswap32(DWORD2(v914));
                *(_WORD *)&v899[4] = 1024;
                *(_DWORD *)&v899[6] = bswap32(HIWORD(v914)) >> 16;
                __int16 v900 = 1024;
                unsigned int v901 = v217;
                __int16 v902 = 1024;
                unsigned int v903 = v218;
                __int16 v904 = 1024;
                unsigned int v905 = v219;
                v213 = v215;
                os_log_type_t v214 = OS_LOG_TYPE_DEFAULT;
LABEL_547:
                _os_log_impl(&dword_214653000, v213, v214, "%{public}s %{public}s flags=%{network:tcp_flags}x seq=%u, ack=%u, win=%u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u", buf, 0x40u);
              }
            }
            tcp_log_packet(v830);
            if ((*(_WORD *)(v12 + 204) & 0x100) != 0
              && *MEMORY[0x263F144B8]
              && (((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(v12, *(void *)(v12 + 88)) & 1) == 0)
            {
              os_log_type_t v39 = a6;
              if (!v842 || (*(unsigned char *)(v842 + 828) & 2) == 0)
              {
                v798 = __nwlog_tcp_log();
                if (os_log_type_enabled(v798, OS_LOG_TYPE_INFO))
                {
                  v799 = "";
                  if (v842) {
                    v799 = (const char *)(v842 + 604);
                  }
                  *(_DWORD *)long long buf = 136446466;
                  v894 = "tcp_input";
                  __int16 v895 = 2082;
                  *(void *)v896 = v799;
                  _os_log_impl(&dword_214653000, v798, OS_LOG_TYPE_INFO, "%{public}s %{public}s dropping tcp input frame since frame is no longer valid", buf, 0x16u);
                }
              }
              *(void *)(v830 + 1056) = 0;
              in_pcb_checkstate(a3, 2, 1);
              unsigned int v40 = v885;
              int v51 = v838;
              goto LABEL_63;
            }
            *(int8x8_t *)((char *)&v914 + 4) = vrev32_s8(*(int8x8_t *)((char *)&v914 + 4));
            HIWORD(v914) = bswap32(HIWORD(v914)) >> 16;
            unsigned __int16 v915 = bswap32(v915) >> 16;
            uint64_t v128 = v842;
            if (&v914 != (long long *)v823)
            {
              *(int8x8_t *)(v823 + 4) = vrev32_s8(*(int8x8_t *)(v823 + 4));
              *(_WORD *)(v823 + 14) = bswap32(*(unsigned __int16 *)(v823 + 14)) >> 16;
              *(_WORD *)(v823 + 18) = bswap32(*(unsigned __int16 *)(v823 + 18)) >> 16;
            }
            unsigned int v818 = v118;
            if ((*(unsigned char *)(a3 + 2229) & 0x40) != 0) {
              unsigned int v831 = *(unsigned __int16 *)(*(void *)(a3 + 440) + 1072);
            }
            uint64_t v129 = v6;
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v842 + 8) + 16))(v842, 1, v6);
            if (in_pcb_checkstate(a3, 2, 1) == 0xFFFF)
            {
              int v130 = 0;
              unsigned int v40 = v885;
              os_log_type_t v39 = a6;
              goto LABEL_272;
            }
            if (v888[0]) {
              DWORD2(v888[0]) -= *(_DWORD *)(v830 + 1888);
            }
            if ((v127 & 0x17) == 0 || !*(_DWORD *)(v830 + 12))
            {
              unsigned int v40 = v885;
              int v51 = v838;
              os_log_type_t v39 = a6;
LABEL_1313:
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v128 + 8) + 24))(v128, 1, v129);
              goto LABEL_63;
            }
            if (*(void *)(v842 + 24))
            {
              uint64_t all_stats = nw_protocol_tcp_get_all_stats();
              if (all_stats) {
                ++*(void *)(all_stats + 16);
              }
              if (*(void *)(v842 + 24))
              {
                uint64_t v137 = nw_protocol_tcp_get_all_stats();
                if (v137) {
                  *(void *)(v137 + 24) += v875;
                }
              }
            }
            LODWORD(v890) = DWORD2(v914);
            int v138 = HIWORD(v914);
            if ((v127 & 2) == 0) {
              int v138 = HIWORD(v914) << *(unsigned char *)(v830 + 260);
            }
            unsigned int v816 = v138;
            int v139 = *(_DWORD *)(v842 + 372);
            if ((v139 & 2) != 0)
            {
              *(_DWORD *)(v842 + 372) = v139 & 0xFFFFFFFD;
              if ((*(unsigned char *)(v842 + 828) & 2) == 0)
              {
                if (__nwlog_is_datapath_logging_enabled())
                {
                  v582 = __nwlog_tcp_log();
                  if (os_log_type_enabled(v582, OS_LOG_TYPE_DEBUG))
                  {
                    v583 = "";
                    v894 = "tcp_input";
                    int v584 = *(_DWORD *)(v830 + 12);
                    *(_DWORD *)long long buf = 136446722;
                    if (v842) {
                      v583 = (const char *)(v842 + 604);
                    }
                    __int16 v895 = 2082;
                    *(void *)v896 = v583;
                    *(_WORD *)&v896[8] = 1024;
                    *(_DWORD *)v897 = v584;
                    _os_log_impl(&dword_214653000, v582, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{network:tcp_state}d", buf, 0x1Cu);
                  }
                }
              }
              if (*(void *)(v842 + 24))
              {
                uint64_t v148 = nw_protocol_tcp_get_all_stats();
                if (v148) {
                  *(_DWORD *)(v148 + 136) = 1;
                }
              }
              tcp_set_max_rwinscale(v830, v842);
              LODWORD(v839) = 1;
              unsigned int v127 = v834;
            }
            else
            {
              LODWORD(v839) = 0;
            }
            (*(void (**)(uint64_t, void))(*(void *)(v842 + 8) + 32))(v842, 0);
            int v149 = v837;
            if (*(_DWORD *)(v830 + 12) == 4 && v875 >= 1)
            {
              if ((*(unsigned char *)(v830 + 740) & 2) != 0) {
                *(_WORD *)(v830 + 344) += v818;
              }
              BOOL v150 = tcp_stretch_ack_enable(v830, v127);
              int v151 = *(_DWORD *)(v830 + 88);
              if (v150)
              {
                unsigned int v152 = v151 | 0x80000000;
                *(_DWORD *)(v830 + 740) &= ~2u;
                *(_WORD *)(v830 + 344) = 0;
              }
              else
              {
                unsigned int v152 = v151 & 0x7FFFFFFF;
              }
              *(_DWORD *)(v830 + 88) = v152;
              int v153 = *(_DWORD *)(v828 + 316);
              int v149 = v837;
              if (*(_DWORD *)(v830 + 324) - v153 - 50 < 1)
              {
                *(_DWORD *)(v830 + 324) = v153 + 100;
                *(_DWORD *)(v830 + 328) = v69 + *(_DWORD *)(v830 + 332);
                *(_DWORD *)(v830 + 332) = v69;
              }
              else
              {
                *(int32x2_t *)(v830 + 328) = vadd_s32(*(int32x2_t *)(v830 + 328), vdup_n_s32(v69));
              }
            }
            int v154 = *(_DWORD *)(v830 + 740);
            if ((v154 & 0x10000000) == 0
              && ((v154 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 336) == 1 || tcp_do_l4s == 1)
              && ((v154 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1)
              && (~*(_DWORD *)(v830 + 348) & 0x300000) == 0)
            {
              *(unsigned char *)(v830 + 428) &= ~1u;
            }
            if (*(_DWORD *)(v830 + 12) == 4)
            {
              int v155 = *(_DWORD *)(v830 + 92);
              if (DWORD2(v914) != v155)
              {
                BOOL v156 = *(void (**)(uint64_t, void))(tcp_cc_algo_list[*(unsigned __int8 *)(v830 + 264)] + 112);
                if (v156)
                {
                  v156(v830, (DWORD2(v914) - v155));
                  int v149 = v837;
                }
                if ((*(unsigned char *)(v830 + 348) & 4) != 0)
                {
                  unsigned int v157 = *(_DWORD *)(v830 + 196);
                  unsigned int v158 = (DWORD2(v914) - *(_DWORD *)(v830 + 92) + (v157 >> 1)) / v157;
                  if (v157 > v158 * v157) {
                    uint64_t v159 = 1;
                  }
                  else {
                    uint64_t v159 = v158;
                  }
                  *(void *)(v830 + 376) += v159;
                }
              }
            }
            int v160 = *(_DWORD *)(v830 + 740);
            if ((v160 & 0x10000000) == 0
              && ((v160 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1))
            {
              if ((v127 & 0x80) == 0) {
                goto LABEL_357;
              }
              int v161 = *(_DWORD *)(v830 + 348);
              if ((v161 & 0x300000) == 0x300000) {
                goto LABEL_357;
              }
            }
            else
            {
              if ((v127 & 0x80) == 0) {
                goto LABEL_357;
              }
              int v161 = *(_DWORD *)(v830 + 348);
            }
            *(_DWORD *)(v830 + 348) = v161 & 0xFFFFFFEF;
            ++*(_DWORD *)(v830 + 356);
LABEL_357:
            if ((SBYTE13(v914) & 0x80u) == 0) {
              int v162 = (BYTE13(v914) & 0x40) != 0;
            }
            else {
              int v162 = (BYTE13(v914) >> 6) | 2;
            }
            unsigned int v814 = v162 & 0xFFFFFFFB | (4 * (BYTE12(v914) & 1));
            uint64_t v163 = v828;
            if ((v160 & 0x10000000) != 0
              || (v160 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1
              || (~*(_DWORD *)(v830 + 348) & 0x300000) != 0
              || *(_DWORD *)(v830 + 12) != 4)
            {
              if (v855 == 3)
              {
                int v165 = *(_DWORD *)(v830 + 12);
                if (v165 != 4) {
                  goto LABEL_411;
                }
                int v166 = *(_DWORD *)(v830 + 348);
                if ((~v166 & 3) == 0 && v875 >= 1)
                {
                  int v167 = *(_DWORD *)(v830 + 284);
                  if (DWORD1(v914) - v167 >= 0 && DWORD1(v914) - (v167 + *(_DWORD *)(v830 + 128)) < 0)
                  {
                    ++*(_DWORD *)(v830 + 352);
                    uint64_t v168 = *(void *)(v830 + 1056);
                    if (v168) {
                      ++*(void *)(v168 + 856);
                    }
                    uint64_t v169 = *(void *)(a3 + 448);
                    if (v169)
                    {
                      uint64_t v170 = 568;
                      if ((*(unsigned char *)(a3 + 2236) & 2) == 0) {
                        uint64_t v170 = 184;
                      }
                      ++*(void *)(v169 + v170);
                    }
                    *(_DWORD *)(v830 + 348) = v166 | 0x50;
                    uint64_t v128 = v842;
                    uint64_t v163 = v828;
                    LOBYTE(v127) = v834;
                  }
                }
              }
LABEL_395:
              int v165 = *(_DWORD *)(v830 + 12);
              if (v165 == 4)
              {
                int v178 = *(_DWORD *)(v830 + 348);
                if ((v178 & 1) == 0)
                {
                  if (v855 == 3)
                  {
LABEL_406:
                    int v817 = 1;
                    if ((~v178 & 3) == 0 || (v178 & 0x2000) != 0) {
                      goto LABEL_415;
                    }
                    uint64_t v179 = *(void *)(v830 + 1056);
                    if (v179) {
                      ++*(void *)(v179 + 944);
                    }
                    tcp_heuristic_ecn_aggressive(v830);
                    *(_DWORD *)(v830 + 348) |= 0x2000u;
                    int v165 = *(_DWORD *)(v830 + 12);
                    int v817 = 1;
                    uint64_t v163 = v828;
LABEL_413:
                    if (v165 != 4) {
                      goto LABEL_428;
                    }
                    int v178 = *(_DWORD *)(v830 + 348);
LABEL_415:
                    if (v817 && (v178 & 0x2003) == 3)
                    {
                      unsigned int v180 = *(unsigned __int8 *)(v830 + 733);
                      if (**(void **)(a3 + 248) > 9uLL)
                      {
                        if (v180 >= 8)
                        {
                          uint64_t v181 = *(void *)(v830 + 1056);
                          if (v181) {
                            ++*(void *)(v181 + 944);
                          }
                          tcp_heuristic_ecn_aggressive(v830);
                          *(_DWORD *)(v830 + 348) |= 0x2000u;
                          uint64_t v182 = *(void *)(a3 + 448);
                          if (v182)
                          {
                            if ((*(unsigned char *)(a3 + 2236) & 2) != 0) {
                              ++*(void *)(v182 + 640);
                            }
                            else {
                              ++*(void *)(v182 + 256);
                            }
                            int v817 = 1;
                            uint64_t v128 = v842;
                            uint64_t v163 = v828;
                            LOBYTE(v127) = v834;
                          }
                          else
                          {
                            int v817 = 1;
                            uint64_t v128 = v842;
                            uint64_t v163 = v828;
                            LOBYTE(v127) = v834;
                          }
                          goto LABEL_427;
                        }
                        *(_DWORD *)(v830 + 348) = v178 | 0x2000;
                      }
                      else
                      {
                        *(unsigned char *)(v830 + 733) = v180 + 1;
                      }
                      int v817 = 1;
                    }
LABEL_427:
                    int v165 = *(_DWORD *)(v830 + 12);
LABEL_428:
                    *(_DWORD *)(v830 + 160) = *(_DWORD *)(v163 + 316);
                    if (v165 >= 4)
                    {
                      tcp_keepalive_reset(v830);
                      int v165 = *(_DWORD *)(v830 + 12);
                    }
                    if (v165 != 1 && v819)
                    {
                      tcp_dooptions(v830, v819, v825, (uint64_t)&v914, (uint64_t)v888);
                      int v165 = *(_DWORD *)(v830 + 12);
                    }
                    int v815 = v15;
                    if ((v127 & 2) != 0 && v165 == 2)
                    {
                      if ((v127 & 0x10) != 0
                        && (DWORD2(v914) - *(_DWORD *)(v830 + 112) < 1 || DWORD2(v914) - *(_DWORD *)(v830 + 96) > 0))
                      {
LABEL_456:
                        *(_DWORD *)(v830 + 744) = 0;
                        goto LABEL_457;
                      }
                      tcp_finalize_options(v830, (int *)v888, v831);
                      int v165 = *(_DWORD *)(v830 + 12);
                    }
                    if ((v127 & 0x7F) != 0x10
                      || v165 != 4
                      || (*(unsigned char *)(v830 + 89) & 8) != 0
                      || (v888[0] & 1) != 0 && DWORD1(v888[0]) - *(_DWORD *)(v830 + 276) < 0
                      || DWORD1(v914) != *(_DWORD *)(v830 + 120)
                      || *(void *)v830)
                    {
                      goto LABEL_456;
                    }
                    unsigned int v183 = *(unsigned __int16 *)(v830 + 752);
                    if (v183 <= 0x28) {
                      *(_WORD *)(v830 + 752) = v183 + v818;
                    }
                    int v184 = *(unsigned __int16 *)(v830 + 748);
                    if (*(_WORD *)(v830 + 748) && v875 <= v184)
                    {
                      if (v875 != v184)
                      {
LABEL_451:
                        if (v875 < v184)
                        {
                          unsigned int v186 = (*(unsigned char *)(v830 + 750) + v818);
                          *(unsigned char *)(v830 + 750) += v818;
                          if (v186 < 0x15)
                          {
                            *(_DWORD *)(v830 + 744) = 0;
                          }
                          else
                          {
                            *(_WORD *)(v830 + 748) = v875;
                            *(_DWORD *)(v830 + 744) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v830 + 80)
                                                                                                  + 224))
                                                                + 316);
                            *(unsigned char *)(v830 + 750) = 0;
                          }
                          goto LABEL_526;
                        }
                        uint64_t v192 = v830;
LABEL_525:
                        update_iaj_state(v192, v875);
LABEL_526:
                        uint64_t v128 = v842;
                        uint64_t v16 = v16;
LABEL_457:
                        if (*(_DWORD *)(v830 + 12) != 4) {
                          goto LABEL_550;
                        }
                        if ((v834 & 0xFFFFFFF7) != 0x10) {
                          goto LABEL_550;
                        }
                        if ((*(_WORD *)(v128 + 376) & 0x20) != 0) {
                          goto LABEL_550;
                        }
                        int v187 = *(_DWORD *)(v830 + 88);
                        if ((v187 & 0x800) != 0 || (v888[0] & 1) != 0 && DWORD1(v888[0]) - *(_DWORD *)(v830 + 276) < 0) {
                          goto LABEL_550;
                        }
                        if (DWORD1(v914) != *(_DWORD *)(v830 + 120)) {
                          goto LABEL_550;
                        }
                        if (!v816) {
                          goto LABEL_550;
                        }
                        if (v816 != *(_DWORD *)(v830 + 140)) {
                          goto LABEL_550;
                        }
                        int v188 = *(_DWORD *)(v830 + 100);
                        if (v188 != *(_DWORD *)(v830 + 96)) {
                          goto LABEL_550;
                        }
                        uint64_t v813 = v839;
                        if ((v888[0] & 1) != 0 && DWORD1(v914) - *(_DWORD *)(v830 + 284) <= 0)
                        {
                          *(_DWORD *)(v830 + 280) = *(_DWORD *)(v828 + 316);
                          *(_DWORD *)(v830 + 276) = DWORD1(v888[0]);
                        }
                        int v189 = *(_DWORD *)(v830 + 740);
                        if ((v189 & 0x10000000) == 0
                          && ((v189 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1))
                        {
                          char v190 = v817 ^ 1;
                          if ((~*(_DWORD *)(v830 + 348) & 0x300000) != 0) {
                            char v190 = 1;
                          }
                          if ((v190 & 1) == 0) {
                            *(_WORD *)(v830 + 306) += v818;
                          }
                        }
                        int v191 = *(_DWORD *)(v830 + 92);
                        if (v69 == v837)
                        {
                          uint64_t v128 = v842;
                          uint64_t v119 = v830;
                          uint64_t v129 = v839;
                          uint64_t v17 = v17;
                          if (DWORD2(v914) - v188 <= 0
                            && DWORD2(v914) - v191 >= 1
                            && (v187 & 0x200000) == 0
                            && *(_DWORD *)(v830 + 144) >= *(_DWORD *)(v830 + 148))
                          {
                            if ((v189 & 0x20) != 0)
                            {
                              uint64_t v128 = v842;
                              uint64_t v119 = v830;
                              uint64_t v129 = v839;
                              uint64_t v17 = v17;
                              if (!HIBYTE(v888[0]) && !*(void *)(v830 + 544)) {
                                goto LABEL_1447;
                              }
                            }
                            else
                            {
                              uint64_t v119 = v830;
                              uint64_t v128 = v842;
                              uint64_t v129 = v839;
                              uint64_t v17 = v17;
                              if (*(_DWORD *)(v830 + 8) < (int)*(unsigned __int8 *)(v830 + 310))
                              {
LABEL_1447:
                                uint64_t v559 = *(void *)(v119 + 1056);
                                if (v559) {
                                  ++*(void *)(v559 + 544);
                                }
                                tcp_bad_rexmt_check(v830, (uint64_t)&v914, (uint64_t)v888);
                                tcp_compute_rtt(v830, (uint64_t)v888, (uint64_t)&v914);
                                int v560 = DWORD2(v914);
                                uint64_t v17 = *(unsigned int *)(v830 + 92);
                                int v561 = DWORD2(v914) - v17;
                                if (DWORD2(v914) - (int)v17 >= 0)
                                {
LABEL_1450:
                                  uint64_t v562 = *(void *)(v830 + 1056);
                                  if (v562)
                                  {
                                    uint64_t v563 = *(void *)(v562 + 168) + v561;
                                    ++*(void *)(v562 + 160);
                                    *(void *)(v562 + 168) = v563;
                                  }
                                  int v564 = *(_DWORD *)(v830 + 740);
                                  if ((v564 & 0x10000000) != 0
                                    || (v564 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1
                                    || (~*(_DWORD *)(v830 + 348) & 0x300004) != 0)
                                  {
                                    goto LABEL_1941;
                                  }
                                  if ((v564 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 336) == 1 || tcp_do_l4s == 1)
                                  {
LABEL_1930:
                                    unsigned int v724 = *(_DWORD *)(v830 + 196);
                                    if (v561 / v724 * v724 == v561) {
                                      unsigned int v725 = v561 / v724;
                                    }
                                    else {
                                      unsigned int v725 = v561 / v724 + 1;
                                    }
                                    *(_DWORD *)(v830 + 296) += v725;
                                    if (v560 == v17)
                                    {
                                      BOOL v726 = 0;
                                      if ((v888[0] & 1) != 0 && DWORD2(v888[0])) {
                                        BOOL v726 = DWORD2(v888[0]) - *(_DWORD *)(v830 + 400) > 0;
                                      }
                                    }
                                    else
                                    {
                                      BOOL v726 = 0;
                                    }
                                    if (v561 > 0 || v726) {
                                      tcp_process_accecn(v830, (uint64_t)v888, (uint64_t)&v914, v725, v814);
                                    }
LABEL_1941:
                                    if ((*(_DWORD *)(v830 + 740) & 0x20400020) == 0x20000020)
                                    {
                                      tcp_segs_doack(v830, DWORD2(v914), v888[0], SDWORD2(v888[0]));
                                      if (*(_DWORD *)(v830 + 560) - DWORD2(v914) < 0) {
                                        *(_DWORD *)(v830 + 560) = DWORD2(v914);
                                      }
                                    }
                                    v727 = *(void (**)(uint64_t, long long *))(tcp_cc_algo_list[*(unsigned __int8 *)(v830 + 264)]
                                                                                      + 48);
                                    if (v727) {
                                      v727(v830, &v914);
                                    }
                                    sbdrop((int *)(v842 + 384), v561);
                                    tcp_sbsnd_trim(v842 + 384);
                                    int v728 = *(_DWORD *)(v830 + 152);
                                    int v729 = DWORD2(v914);
                                    if (*(_DWORD *)(v830 + 92) - v728 >= 1 && DWORD2(v914) - v728 <= 0) {
                                      *(_DWORD *)(v830 + 152) = DWORD2(v914) - 1;
                                    }
                                    tcp_update_snd_una(v830, v729);
                                    *(_WORD *)(v830 + 226) = 0;
                                    *(_DWORD *)(v830 + 248) = 0;
                                    *(_DWORD *)(v830 + 108) = DWORD2(v914);
                                    if (*(int *)(v830 + 8) >= 1)
                                    {
                                      *(_DWORD *)(v830 + 8) = 0;
                                      *(unsigned char *)(v830 + 310) = 3;
                                    }
                                    *(_DWORD *)(v830 + 628) = 0;
                                    if (*(_DWORD *)(v830 + 92) == *(_DWORD *)(v830 + 96))
                                    {
                                      *(_DWORD *)(v830 + 16) = 0;
                                      *(void *)(v830 + 24) = 0;
                                      *(unsigned char *)(v830 + 2069) &= ~0x80u;
                                    }
                                    else if (!*(_DWORD *)(v830 + 36))
                                    {
                                      *(_DWORD *)(v830 + 28) = *(_DWORD *)(v830 + 192)
                                                             + *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v830 + 80) + 224))
                                                                         + 316)
                                                             - *(_DWORD *)(v830 + 64);
                                    }
                                    if (*(void *)(v830 + 952))
                                    {
                                      int v730 = *(_DWORD *)(v830 + 960);
                                      if (v730 - *(_DWORD *)(v830 + 96) > 0) {
                                        goto LABEL_1957;
                                      }
                                      unsigned int v731 = *(_DWORD *)(v830 + 140);
                                      if (v731 >= *(_DWORD *)(sysctls + 120)) {
                                        unsigned int v731 = *(_DWORD *)(sysctls + 120);
                                      }
                                      if ((int)(v730 - *(_DWORD *)(v830 + 92) + v731) < 0) {
LABEL_1957:
                                      }
                                        tcp_rxtseg_clean(v830);
                                    }
                                    if ((*(unsigned char *)(v830 + 740) & 8) != 0 && *(void *)(v830 + 768)) {
                                      tcp_bwmeas_check(v830);
                                    }
                                    v732 = *(void (***)(uint64_t))(v842 + 32);
                                    if (v732)
                                    {
                                      v733 = *v732;
                                      if (v733) {
                                        v733(v842);
                                      }
                                    }
                                    if (!*(_DWORD *)(v842 + 384) && (*(unsigned char *)(v830 + 88) & 1) == 0
                                      || !tcp_output(v830)
                                      || (*(_WORD *)(v12 + 204) & 0x100) == 0
                                      || !*MEMORY[0x263F144B8]
                                      || (((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(v12, *(void *)(v12 + 88)) & 1) != 0)
                                    {
                                      tcp_tfo_rcv_ack(v830, (uint64_t)&v914);
                                      tcp_check_timer_state(v830);
                                      (*(void (**)(uint64_t, uint64_t))(*(void *)(v842 + 8) + 24))(v842, 1);
                                      uint64_t result = (void *)*v885;
                                      if (!*v885) {
                                        return result;
                                      }
                                      while (1)
                                      {
                                        v734 = (void (*)(void *, uint64_t, uint64_t))result[10];
                                        v735 = (void *)result[4];
                                        if (!v734) {
                                          break;
                                        }
                                        uint64_t v736 = result[11];
                                        result[10] = 0;
                                        result[11] = 0;
                                        v734(result, 1, v736);
LABEL_1976:
                                        uint64_t result = v735;
                                        if (!v735) {
                                          return result;
                                        }
                                      }
                                      __nwlog_obj();
                                      *(_DWORD *)long long buf = 136446210;
                                      v894 = "__nw_frame_finalize";
                                      uint64_t v737 = _os_log_send_and_compose_impl();
                                      type[0] = OS_LOG_TYPE_ERROR;
                                      char v892 = 0;
                                      v883 = (void *)v737;
                                      if (__nwlog_fault())
                                      {
                                        if (type[0] == OS_LOG_TYPE_FAULT)
                                        {
                                          v871 = __nwlog_obj();
                                          if (!os_log_type_enabled(v871, type[0])) {
                                            goto LABEL_1992;
                                          }
                                          *(_DWORD *)long long buf = 136446210;
                                          v894 = "__nw_frame_finalize";
                                          v738 = v871;
                                          os_log_type_t v739 = type[0];
                                          v740 = "%{public}s called with null frame->finalizer";
                                          goto LABEL_1991;
                                        }
                                        if (!v892)
                                        {
                                          v873 = __nwlog_obj();
                                          if (!os_log_type_enabled(v873, type[0])) {
                                            goto LABEL_1992;
                                          }
                                          *(_DWORD *)long long buf = 136446210;
                                          v894 = "__nw_frame_finalize";
                                          v738 = v873;
                                          os_log_type_t v739 = type[0];
                                          v740 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
                                          goto LABEL_1991;
                                        }
                                        os_log_t backtrace_string = (void *)__nw_create_backtrace_string();
                                        logj = __nwlog_obj();
                                        BOOL v741 = os_log_type_enabled(logj, type[0]);
                                        if (backtrace_string)
                                        {
                                          if (v741)
                                          {
                                            *(_DWORD *)long long buf = 136446466;
                                            v894 = "__nw_frame_finalize";
                                            __int16 v895 = 2082;
                                            *(void *)v896 = backtrace_string;
                                            _os_log_impl(&dword_214653000, logj, type[0], "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
                                          }
                                          free(backtrace_string);
                                          goto LABEL_1992;
                                        }
                                        if (v741)
                                        {
                                          *(_DWORD *)long long buf = 136446210;
                                          v894 = "__nw_frame_finalize";
                                          v738 = logj;
                                          os_log_type_t v739 = type[0];
                                          v740 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_1991:
                                          _os_log_impl(&dword_214653000, v738, v739, v740, buf, 0xCu);
                                        }
                                      }
LABEL_1992:
                                      if (v883) {
                                        free(v883);
                                      }
                                      goto LABEL_1976;
                                    }
                                    if ((*(unsigned char *)(v842 + 828) & 2) == 0)
                                    {
                                      v794 = __nwlog_tcp_log();
                                      if (os_log_type_enabled(v794, OS_LOG_TYPE_INFO))
                                      {
                                        v795 = "";
                                        if (v842) {
                                          v795 = (const char *)(v842 + 604);
                                        }
                                        *(_DWORD *)long long buf = 136446466;
                                        v894 = "tcp_input";
                                        __int16 v895 = 2082;
                                        *(void *)v896 = v795;
                                        _os_log_impl(&dword_214653000, v794, OS_LOG_TYPE_INFO, "%{public}s %{public}s dropping input packet since frame is no longer valid", buf, 0x16u);
                                      }
                                    }
                                    *(void *)(v830 + 1056) = 0;
                                    goto LABEL_1270;
                                  }
                                  __nwlog_obj();
                                  *(_DWORD *)long long buf = 136446210;
                                  v894 = "tcp_input";
                                  v565 = (void *)_os_log_send_and_compose_impl();
                                  type[0] = OS_LOG_TYPE_ERROR;
                                  char v892 = 0;
                                  if (__nwlog_fault())
                                  {
                                    if (type[0] == OS_LOG_TYPE_FAULT)
                                    {
                                      v566 = __nwlog_obj();
                                      os_log_type_t v567 = type[0];
                                      if (!os_log_type_enabled(v566, type[0])) {
                                        goto LABEL_1928;
                                      }
                                      *(_DWORD *)long long buf = 136446210;
                                      v894 = "tcp_input";
                                      v568 = "%{public}s TE_SENDIPECT flag is set but TCP_L4S_ENABLED is not";
LABEL_1926:
                                      v722 = v566;
                                      os_log_type_t v723 = v567;
LABEL_1927:
                                      _os_log_impl(&dword_214653000, v722, v723, v568, buf, 0xCu);
                                      goto LABEL_1928;
                                    }
                                    if (!v892)
                                    {
                                      v566 = __nwlog_obj();
                                      os_log_type_t v567 = type[0];
                                      if (!os_log_type_enabled(v566, type[0])) {
                                        goto LABEL_1928;
                                      }
                                      *(_DWORD *)long long buf = 136446210;
                                      v894 = "tcp_input";
                                      v568 = "%{public}s TE_SENDIPECT flag is set but TCP_L4S_ENABLED is not, backtrace limit exceeded";
                                      goto LABEL_1926;
                                    }
                                    v700 = (void *)__nw_create_backtrace_string();
                                    v701 = __nwlog_obj();
                                    BOOL v702 = os_log_type_enabled(v701, type[0]);
                                    if (v700)
                                    {
                                      if (v702)
                                      {
                                        *(_DWORD *)long long buf = 136446466;
                                        v894 = "tcp_input";
                                        __int16 v895 = 2082;
                                        *(void *)v896 = v700;
                                        _os_log_impl(&dword_214653000, v701, type[0], "%{public}s TE_SENDIPECT flag is set but TCP_L4S_ENABLED is not, dumping backtrace:%{public}s", buf, 0x16u);
                                      }
                                      free(v700);
                                      goto LABEL_1928;
                                    }
                                    if (v702)
                                    {
                                      *(_DWORD *)long long buf = 136446210;
                                      v894 = "tcp_input";
                                      v568 = "%{public}s TE_SENDIPECT flag is set but TCP_L4S_ENABLED is not, no backtrace";
                                      v722 = v701;
                                      os_log_type_t v723 = type[0];
                                      goto LABEL_1927;
                                    }
                                  }
LABEL_1928:
                                  if (v565) {
                                    free(v565);
                                  }
                                  goto LABEL_1930;
                                }
                                v789 = __nwlog_obj();
                                os_log_type_enabled(v789, OS_LOG_TYPE_ERROR);
                                *(_DWORD *)long long buf = 136446210;
                                v894 = "tcp_input";
                                v790 = (void *)_os_log_send_and_compose_impl();
                                if (!__nwlog_abort())
                                {
                                  free(v790);
                                  int v560 = DWORD2(v914);
                                  LODWORD(v17) = *(_DWORD *)(v830 + 92);
                                  int v561 = DWORD2(v914) - v17;
                                  goto LABEL_1450;
                                }
                                goto LABEL_2107;
                              }
                            }
                          }
LABEL_550:
                          (*(void (**)(uint64_t, void))(*(void *)(v128 + 8) + 32))(v128, 0);
                          unsigned int v220 = tcp_sbspace(v119);
                          if ((v220 & 0x80000000) == 0)
                          {
                            v222 = v885;
                            os_log_type_t v39 = a6;
                            if ((*(unsigned char *)(v119 + 90) & 8) != 0)
                            {
                              int v223 = *(_DWORD *)(sysctls + 48);
                              unsigned int v224 = v220 >= v223 ? *(_DWORD *)(sysctls + 48) : v220;
                              if (v223 > 0) {
                                unsigned int v220 = v224;
                              }
                            }
LABEL_564:
                            int v227 = *(_DWORD *)(v119 + 120);
                            if ((int)v220 <= *(_DWORD *)(v119 + 124) - v227) {
                              unsigned int v228 = *(_DWORD *)(v119 + 124) - v227;
                            }
                            else {
                              unsigned int v228 = v220;
                            }
                            *(_DWORD *)(v119 + 128) = v228;
                            int v229 = *(_DWORD *)(v119 + 12);
                            unsigned int v127 = v834;
                            switch(v229)
                            {
                              case 1:
                                tcp_dooptions(v119, v819, v825, (uint64_t)&v914, (uint64_t)v888);
                                tcp_finalize_options(v119, (int *)v888, v831);
                                if ((*(unsigned char *)(v119 + 742) & 0x40) != 0) {
                                  int v832 = tcp_tfo_syn(v119, (uint64_t)v888);
                                }
                                else {
                                  int v832 = 0;
                                }
                                int v243 = tcp_new_isn(v119);
                                int v244 = DWORD1(v914);
                                *(_DWORD *)(v119 + 112) = v243;
                                *(_DWORD *)(v119 + 116) = v244;
                                *(_DWORD *)(v119 + 152) = v243;
                                *(_DWORD *)(v119 + 96) = v243;
                                *(_DWORD *)(v119 + 100) = v243;
                                *(_DWORD *)(v119 + 92) = v243;
                                if (*(void *)(v128 + 24))
                                {
                                  uint64_t v245 = nw_protocol_tcp_get_all_stats();
                                  int v243 = *(_DWORD *)(v119 + 92);
                                  if (v245)
                                  {
                                    *(_DWORD *)(v245 + 108) = *(_DWORD *)(v119 + 96) - v243;
                                    int v243 = *(_DWORD *)(v119 + 92);
                                  }
                                }
                                int v246 = *(_DWORD *)(v119 + 116) + 1;
                                *(_DWORD *)(v119 + 1916) = v246;
                                *(_DWORD *)(v119 + 120) = v246;
                                *(_DWORD *)(v119 + 124) = v246;
                                *(_DWORD *)(v119 + 152) = v243;
                                *(_DWORD *)(v119 + 140) = v816;
                                *(_DWORD *)(v119 + 252) = v816;
                                if (*(void *)(v128 + 24))
                                {
                                  uint64_t v247 = nw_protocol_tcp_get_all_stats();
                                  if (v247) {
                                    *(_DWORD *)(v247 + 112) = *(_DWORD *)(v119 + 140);
                                  }
                                }
                                *(_DWORD *)(v119 + 88) |= 1u;
                                *(_DWORD *)(v119 + 304) = 0;
                                *(_DWORD *)(v119 + 12) = 3;
                                if ((*(unsigned char *)(v128 + 828) & 2) == 0)
                                {
                                  if (__nwlog_is_datapath_logging_enabled())
                                  {
                                    v633 = __nwlog_tcp_log();
                                    if (os_log_type_enabled(v633, OS_LOG_TYPE_DEBUG))
                                    {
                                      v634 = tcpstates[*(int *)(v119 + 12)];
                                      v894 = "tcp_input";
                                      v635 = "";
                                      *(_DWORD *)long long buf = 136446722;
                                      if (v128) {
                                        v635 = (const char *)(v128 + 604);
                                      }
                                      __int16 v895 = 2082;
                                      *(void *)v896 = v635;
                                      *(_WORD *)&v896[8] = 2082;
                                      *(void *)v897 = v634;
                                      _os_log_impl(&dword_214653000, v633, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                    }
                                  }
                                }
                                if (*(void *)(v128 + 24))
                                {
                                  uint64_t v248 = nw_protocol_tcp_get_all_stats();
                                  if (v248) {
                                    *(_DWORD *)(v248 + 136) = 3;
                                  }
                                }
                                int v249 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v119 + 80) + 224))
                                                 + 316);
                                int v250 = *(_DWORD *)(v119 + 680);
                                unsigned int v251 = v834;
                                if (!v250) {
                                  int v250 = *(_DWORD *)(sysctls + 188);
                                }
                                *(_DWORD *)(v119 + 40) = v250 + v249 - *(_DWORD *)(v119 + 64);
                                if (!*(_DWORD *)(a3 + 460))
                                {
                                  int v252 = inp_calc_flowhash_flow_hash++;
                                  *(_DWORD *)(a3 + 460) = v252;
                                }
                                *(_DWORD *)(v128 + 364) &= ~0x40000u;
                                uint64_t v253 = *(void *)(v119 + 1056);
                                if (v253) {
                                  ++*(void *)(v253 + 384);
                                }
                                int64x2_t v221 = tcp_input_process_accecn_syn((int64x2_t *)v119, ((unsigned __int16)v834 | (unsigned __int16)(BYTE12(v914) << 8)) & 0x1C0, v855);
                                LODWORD(v839) = 0;
                                uint64_t v254 = v823;
                                goto LABEL_933;
                              case 2:
                                if ((v834 & 0x10) == 0)
                                {
                                  if ((v834 & 6) == 2) {
                                    goto LABEL_607;
                                  }
                                  goto LABEL_643;
                                }
                                if (DWORD2(v914) - *(_DWORD *)(v119 + 112) >= 1
                                  && DWORD2(v914) - *(_DWORD *)(v119 + 96) <= 0)
                                {
                                  if ((v834 & 4) != 0)
                                  {
                                    if ((*(_DWORD *)(v119 + 740) & 0x1400000) == 0x400000) {
                                      tcp_heuristic_tfo_rst(v119);
                                    }
                                    int v316 = *(_DWORD *)(v119 + 348);
                                    if ((v316 & 0x8001) == 1 || (v316 & 0x108000) == 0x100000) {
                                      tcp_heuristic_ecn_synrst(v119);
                                    }
                                    tcp_drop(v119, 61);
                                    unsigned int v40 = v222;
                                    goto LABEL_787;
                                  }
                                  uint64_t v128 = v842;
                                  LOBYTE(v127) = v834;
                                  if ((v834 & 2) != 0)
                                  {
LABEL_607:
                                    int v238 = HIWORD(v914);
                                    *(_DWORD *)(v119 + 140) = HIWORD(v914);
                                    *(_DWORD *)(v119 + 252) = v238;
                                    if (*(void *)(v128 + 24))
                                    {
                                      uint64_t v239 = nw_protocol_tcp_get_all_stats();
                                      if (v239) {
                                        *(_DWORD *)(v239 + 112) = *(_DWORD *)(v119 + 140);
                                      }
                                    }
                                    int v240 = DWORD1(v914);
                                    int v241 = DWORD1(v914) + 1;
                                    *(_DWORD *)(v119 + 1916) = DWORD1(v914) + 1;
                                    *(_DWORD *)(v119 + 116) = v240;
                                    *(_DWORD *)(v119 + 120) = v241;
                                    *(_DWORD *)(v119 + 124) = v241;
                                    if ((v127 & 0x10) == 0)
                                    {
                                      *(_DWORD *)(v119 + 88) |= 1u;
                                      *(_DWORD *)(v119 + 28) = 0;
                                      *(_DWORD *)(v119 + 12) = 3;
                                      if ((*(unsigned char *)(v128 + 828) & 2) == 0)
                                      {
                                        if (__nwlog_is_datapath_logging_enabled())
                                        {
                                          v703 = __nwlog_tcp_log();
                                          if (os_log_type_enabled(v703, OS_LOG_TYPE_DEBUG))
                                          {
                                            v704 = tcpstates[*(int *)(v119 + 12)];
                                            v894 = "tcp_input";
                                            v705 = "";
                                            *(_DWORD *)long long buf = 136446722;
                                            if (v128) {
                                              v705 = (const char *)(v128 + 604);
                                            }
                                            __int16 v895 = 2082;
                                            *(void *)v896 = v705;
                                            *(_WORD *)&v896[8] = 2082;
                                            *(void *)v897 = v704;
                                            _os_log_impl(&dword_214653000, v703, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                          }
                                        }
                                      }
                                      if (*(void *)(v128 + 24))
                                      {
                                        uint64_t v242 = nw_protocol_tcp_get_all_stats();
                                        if (v242) {
                                          *(_DWORD *)(v242 + 136) = 3;
                                        }
                                      }
                                      int v832 = 0;
                                      *(_DWORD *)(v119 + 740) &= ~0x400000u;
                                      uint64_t v16 = v16;
LABEL_932:
                                      uint64_t v254 = v823;
                                      unsigned int v251 = v834;
LABEL_933:
                                      if ((*(_WORD *)(v12 + 204) & 0x100) == 0
                                        || !*MEMORY[0x263F144B8]
                                        || (v366 = ((uint64_t (*)(uint64_t, void, __n128))*MEMORY[0x263F144B8])(v12, *(void *)(v12 + 88), (__n128)v221), uint64_t v254 = v823, (v366 & 1) != 0))
                                      {
                                        uint64_t v813 = v129;
                                        ++DWORD1(v914);
                                        if (&v914 != (long long *)v254) {
                                          ++*(_DWORD *)(v254 + 4);
                                        }
                                        int v367 = v891;
                                        int v368 = *(_DWORD *)(v119 + 128);
                                        unsigned int v369 = v891 - v368;
                                        unsigned int v835 = v251;
                                        if (v891 <= v368)
                                        {
LABEL_986:
                                          BOOL v403 = 0;
                                          int v404 = 0;
                                          int v878 = 0;
                                          int v405 = DWORD1(v914);
                                          uint64_t v119 = v830;
                                          *(_DWORD *)(v830 + 104) = DWORD1(v914) - 1;
                                          *(_DWORD *)(v830 + 136) = v405;
                                          os_log_type_t v39 = a6;
                                          unsigned int v406 = v835;
                                          if ((v835 & 0x10) == 0) {
                                            goto LABEL_1166;
                                          }
LABEL_987:
                                          unsigned int v834 = v406;
                                          int v407 = DWORD2(v914) - *(_DWORD *)(v119 + 92);
                                          if (v407 >= 0)
                                          {
                                            uint64_t v408 = *(void *)(v119 + 1056);
                                            if (v408)
                                            {
                                              uint64_t v409 = *(void *)(v408 + 168) + v407;
                                              ++*(void *)(v408 + 160);
                                              *(void *)(v408 + 168) = v409;
                                            }
                                            tcp_bad_rexmt_check(v119, (uint64_t)&v914, (uint64_t)v888);
                                            tcp_compute_rtt(v119, (uint64_t)v888, (uint64_t)&v914);
                                            int v410 = 0;
                                            *(_WORD *)(v119 + 226) = 0;
                                            *(_DWORD *)(v119 + 248) = 0;
                                            if (*(int *)(v119 + 12) >= 4) {
                                              int v410 = *(_DWORD *)(sysctls + 176);
                                            }
                                            uint64_t v411 = *(unsigned int *)(v119 + 228);
                                            int v412 = (*(_DWORD *)(v119 + 208) + (*(int *)(v119 + 200) >> 3)) >> 2;
                                            if (v411 > v412) {
                                              int v412 = *(_DWORD *)(v119 + 228);
                                            }
                                            unsigned int v413 = v412 + v410;
                                            *(_DWORD *)(v119 + 192) = v413;
                                            if (v413 >= v411)
                                            {
                                              if (v413 < 0xFA01)
                                              {
LABEL_998:
                                                int v807 = v17;
                                                int v811 = v16;
                                                unsigned int v40 = v222;
                                                if (DWORD2(v914) == *(_DWORD *)(v119 + 96))
                                                {
                                                  *(_DWORD *)(v119 + 16) = 0;
                                                  *(void *)(v119 + 24) = 0;
                                                  *(unsigned char *)(v119 + 2069) &= ~0x80u;
                                                  int v414 = 1;
                                                }
                                                else
                                                {
                                                  int v414 = 0;
                                                  if (!*(_DWORD *)(v119 + 36)) {
                                                    *(_DWORD *)(v119 + 28) = *(_DWORD *)(v119 + 192)
                                                  }
                                                                           + *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v119 + 80) + 224))
                                                                                       + 316)
                                                                           - *(_DWORD *)(v119 + 64);
                                                }
                                                int v878 = v414;
                                                if (v407)
                                                {
                                                  if ((*(_DWORD *)(v119 + 740) & 0x20400020) == 0x20000020)
                                                  {
                                                    tcp_segs_doack(v119, DWORD2(v914), v888[0], SDWORD2(v888[0]));
                                                    int v432 = *(_DWORD *)(v119 + 560);
                                                    int v433 = v890;
                                                    if (v432 - (int)v890 < 0)
                                                    {
                                                      *(_DWORD *)(v119 + 560) = v890;
                                                      int v432 = v433;
                                                    }
                                                    if (v432 - DWORD2(v914) < 0) {
                                                      *(_DWORD *)(v119 + 560) = DWORD2(v914);
                                                    }
                                                  }
                                                  int v434 = v407;
                                                  if ((*(_WORD *)(v119 + 990) & 0x40) != 0
                                                    && (*(unsigned char *)(v119 + 988) & 0x20) == 0
                                                    && (BYTE13(v914) & 2) == 0)
                                                  {
                                                    *(unsigned char *)(v119 + 988) |= 0x20u;
                                                  }
                                                  int v435 = *(_DWORD *)(v119 + 348);
                                                  if ((v435 & 4) != 0)
                                                  {
                                                    int v440 = *(_DWORD *)(v119 + 740);
                                                    if ((v440 & 0x10000000) == 0
                                                      && ((v440 & 0x8000000) != 0
                                                       || *(_DWORD *)(sysctls + 320) == 1
                                                       || tcp_do_acc_ecn == 1)
                                                      && (v834 & 2) == 0
                                                      && (v435 & 0x300000) == 0x300000)
                                                    {
                                                      int v462 = 0;
                                                      int v463 = DWORD2(v914);
                                                      int v464 = *(_DWORD *)(v119 + 112) + 1;
                                                      if (DWORD2(v914) == v464) {
                                                        unsigned int v465 = 0;
                                                      }
                                                      else {
                                                        unsigned int v465 = v407;
                                                      }
                                                      unsigned int v466 = *(_DWORD *)(v119 + 196);
                                                      int v434 = v465;
                                                      if (v465 / v466 * v466 == v465) {
                                                        unsigned int v467 = v465 / v466;
                                                      }
                                                      else {
                                                        unsigned int v467 = v465 / v466 + 1;
                                                      }
                                                      *(_DWORD *)(v119 + 296) += v467;
                                                      if (v463 == v464 && !HIDWORD(v890))
                                                      {
                                                        int v462 = 0;
                                                        if (v888[0])
                                                        {
                                                          if (DWORD2(v888[0]))
                                                          {
                                                            int v468 = *(_DWORD *)(v119 + 400);
                                                            if (v468) {
                                                              BOOL v469 = DWORD2(v888[0]) - v468 <= 0;
                                                            }
                                                            else {
                                                              BOOL v469 = 0;
                                                            }
                                                            int v462 = !v469;
                                                          }
                                                        }
                                                      }
                                                      if (v465 || HIDWORD(v890) || v462) {
                                                        tcp_process_accecn(v119, (uint64_t)v888, (uint64_t)&v914, v467, v814);
                                                      }
                                                      else {
                                                        int v434 = 0;
                                                      }
                                                    }
                                                    else if ((v834 & 0x40) != 0 {
                                                           && (*(_DWORD *)(v119 + 348) & 3) == 3
                                                    }
                                                           && (*(unsigned char *)(v119 + 90) & 0x20) == 0)
                                                    {
                                                      tcp_enter_fast_recovery(v119);
                                                      *(_DWORD *)(v119 + 348) |= 0xA8u;
                                                      uint64_t v441 = *(void *)(a3 + 448);
                                                      if (v441)
                                                      {
                                                        uint64_t v442 = 576;
                                                        if ((*(unsigned char *)(a3 + 2236) & 2) == 0) {
                                                          uint64_t v442 = 192;
                                                        }
                                                        ++*(void *)(v441 + v442);
                                                      }
                                                      uint64_t v443 = *(void *)(v119 + 1056);
                                                      if (v443) {
                                                        ++*(void *)(v443 + 864);
                                                      }
                                                      ++*(void *)(v119 + 384);
                                                    }
                                                  }
                                                  if (!(*(_DWORD *)(v119 + 88) & 0x200000 | v403))
                                                  {
                                                    v436 = *(void (**)(uint64_t, long long *))(tcp_cc_algo_list[*(unsigned __int8 *)(v119 + 264)] + 56);
                                                    if (v436) {
                                                      v436(v119, &v914);
                                                    }
                                                  }
                                                  v437 = (int *)(v842 + 384);
                                                  int v438 = *(_DWORD *)(v842 + 384);
                                                  if (v434 <= v438)
                                                  {
                                                    sbdrop((int *)(v842 + 384), v434);
                                                    tcp_sbsnd_trim((uint64_t)v437);
                                                    *(_DWORD *)(v119 + 140) -= v434;
                                                    if (*(void *)(v842 + 24))
                                                    {
                                                      uint64_t v444 = nw_protocol_tcp_get_all_stats();
                                                      if (v444) {
                                                        *(_DWORD *)(v444 + 112) = *(_DWORD *)(v119 + 140);
                                                      }
                                                    }
                                                  }
                                                  else
                                                  {
                                                    *(_DWORD *)(v119 + 140) -= v438;
                                                    if (*(void *)(v842 + 24))
                                                    {
                                                      uint64_t v439 = nw_protocol_tcp_get_all_stats();
                                                      if (v439) {
                                                        *(_DWORD *)(v439 + 112) = *(_DWORD *)(v119 + 140);
                                                      }
                                                    }
                                                    sbdrop(v437, *v437);
                                                  }
                                                  int v445 = *(_DWORD *)(v119 + 88);
                                                  int v446 = *(_DWORD *)(v119 + 152);
                                                  if ((v445 & 0x200000) != 0)
                                                  {
                                                    int v447 = DWORD2(v914);
                                                    if (DWORD2(v914) - v446 >= 0)
                                                    {
                                                      *(_DWORD *)(v119 + 88) = v445 & 0xFFDFFFFF;
                                                      *(_DWORD *)(v119 + 8) = 0;
                                                      *(unsigned char *)(v119 + 310) = 3;
                                                      *(_DWORD *)(v119 + 288) = 0;
                                                      *(_DWORD *)(v119 + 348) &= ~0x20u;
                                                      *(_DWORD *)(v119 + 16) = 0;
                                                      int v448 = *(_DWORD *)(v119 + 740);
                                                      *(_DWORD *)(v119 + 740) = v448 & 0xFFF7FFFF;
                                                      *(_DWORD *)(v119 + 984) = 0;
                                                      *(_DWORD *)(v119 + 628) = 0;
                                                      if ((v448 & 0x20400020) == 0x20000020
                                                        && (*(unsigned char *)(v119 + 2069) & 0x1F) != 0)
                                                      {
                                                        *(unsigned char *)(v119 + 2069) = *(unsigned char *)(v119 + 2069) & 0xE0 | (*(unsigned char *)(v119 + 2069) - 1) & 0x1F;
                                                      }
                                                    }
                                                  }
                                                  else
                                                  {
                                                    int v447 = DWORD2(v914);
                                                    if (*(_DWORD *)(v119 + 92) - v446 >= 1 && DWORD2(v914) - v446 <= 0) {
                                                      *(_DWORD *)(v119 + 152) = DWORD2(v914) - 1;
                                                    }
                                                  }
                                                  tcp_update_snd_una(v119, v447);
                                                  int v449 = *(_DWORD *)(v119 + 740);
                                                  int v450 = *(_DWORD *)(v119 + 92);
                                                  if ((v449 & 0x20) != 0 && v450 - *(_DWORD *)(v119 + 152) >= 1) {
                                                    *(_DWORD *)(v119 + 152) = v450;
                                                  }
                                                  if (*(_DWORD *)(v119 + 100) - v450 < 0) {
                                                    *(_DWORD *)(v119 + 100) = v450;
                                                  }
                                                  if ((v449 & 0x20400020) == 0x20000020
                                                    && tcp_rack_detect_loss_and_arm_timer(v119, 0))
                                                  {
                                                    if ((*(unsigned char *)(v119 + 90) & 0x20) == 0)
                                                    {
                                                      tcp_enter_fast_recovery(v119);
                                                      uint64_t v451 = *(void *)(v119 + 1056);
                                                      if (v451) {
                                                        ++*(void *)(v451 + 624);
                                                      }
                                                      ++*(_DWORD *)(v119 + 1008);
                                                    }
                                                    tcp_output(v119);
                                                  }
                                                  if (*(void *)(v119 + 952))
                                                  {
                                                    int v452 = *(_DWORD *)(v119 + 960);
                                                    if (v452 - *(_DWORD *)(v119 + 96) > 0) {
                                                      goto LABEL_1076;
                                                    }
                                                    unsigned int v453 = *(_DWORD *)(v119 + 140);
                                                    if (v453 >= *(_DWORD *)(sysctls + 120)) {
                                                      unsigned int v453 = *(_DWORD *)(sysctls + 120);
                                                    }
                                                    if ((int)(v452 - *(_DWORD *)(v119 + 92) + v453) < 0) {
LABEL_1076:
                                                    }
                                                      tcp_rxtseg_clean(v119);
                                                  }
                                                  if ((*(unsigned char *)(v119 + 740) & 8) != 0 && *(void *)(v119 + 768)) {
                                                    tcp_bwmeas_check(v119);
                                                  }
                                                  v454 = *(void (***)(uint64_t))(v842 + 32);
                                                  if (v454)
                                                  {
                                                    v455 = *v454;
                                                    if (v455) {
                                                      v455(v842);
                                                    }
                                                  }
                                                  int v404 = 0;
                                                  int v456 = *(_DWORD *)(v119 + 12);
                                                  switch(v456)
                                                  {
                                                    case 6:
                                                      if (v434 <= v438) {
                                                        goto LABEL_1107;
                                                      }
                                                      *(_DWORD *)(v119 + 12) = 9;
                                                      if ((*(unsigned char *)(v842 + 828) & 2) == 0)
                                                      {
                                                        if (__nwlog_is_datapath_logging_enabled())
                                                        {
                                                          v756 = __nwlog_tcp_log();
                                                          if (os_log_type_enabled(v756, OS_LOG_TYPE_DEBUG))
                                                          {
                                                            v757 = tcpstates[*(int *)(v119 + 12)];
                                                            v894 = "tcp_input";
                                                            v758 = "";
                                                            *(_DWORD *)long long buf = 136446722;
                                                            if (v842) {
                                                              v758 = (const char *)(v842 + 604);
                                                            }
                                                            __int16 v895 = 2082;
                                                            *(void *)v896 = v758;
                                                            *(_WORD *)&v896[8] = 2082;
                                                            *(void *)v897 = v757;
                                                            _os_log_impl(&dword_214653000, v756, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                                          }
                                                        }
                                                      }
                                                      if (*(void *)(v842 + 24))
                                                      {
                                                        uint64_t v457 = nw_protocol_tcp_get_all_stats();
                                                        if (v457) {
                                                          *(_DWORD *)(v457 + 136) = 9;
                                                        }
                                                      }
                                                      if ((*(_WORD *)(v842 + 376) & 0x20) != 0)
                                                      {
                                                        tcp_set_finwait_timeout(v119);
                                                        int v832 = 0;
LABEL_1156:
                                                        int v404 = 1;
                                                      }
                                                      else
                                                      {
                                                        int v404 = 0;
                                                      }
                                                      int v456 = *(_DWORD *)(v119 + 12);
LABEL_1158:
                                                      if (v456 != 4) {
                                                        goto LABEL_1163;
                                                      }
                                                      if ((*(_DWORD *)(v119 + 740) & 0x20) == 0) {
                                                        goto LABEL_1163;
                                                      }
                                                      if (!HIDWORD(v890)) {
                                                        goto LABEL_1163;
                                                      }
                                                      if (!HIBYTE(v888[0])) {
                                                        goto LABEL_1163;
                                                      }
                                                      if (*(_DWORD *)(v119 + 8)) {
                                                        goto LABEL_1163;
                                                      }
                                                      if (DWORD2(v914) - *(_DWORD *)(v119 + 92) > 0) {
                                                        goto LABEL_1163;
                                                      }
                                                      int v827 = v891;
                                                      if (v891 | *(_DWORD *)(v119 + 740) & 0x2000) {
                                                        goto LABEL_1163;
                                                      }
                                                      uint64_t v538 = *(void *)(v119 + 1056);
                                                      if (v538) {
                                                        ++*(void *)(v538 + 704);
                                                      }
                                                      LODWORD(v17) = v807;
                                                      LODWORD(v16) = v811;
                                                      goto LABEL_1358;
                                                    case 7:
                                                      if (v434 <= v438) {
                                                        goto LABEL_1107;
                                                      }
                                                      *(_DWORD *)(v119 + 12) = 10;
                                                      if ((*(unsigned char *)(v842 + 828) & 2) == 0)
                                                      {
                                                        if (__nwlog_is_datapath_logging_enabled())
                                                        {
                                                          v759 = __nwlog_tcp_log();
                                                          if (os_log_type_enabled(v759, OS_LOG_TYPE_DEBUG))
                                                          {
                                                            v760 = tcpstates[*(int *)(v119 + 12)];
                                                            v894 = "tcp_input";
                                                            v761 = "";
                                                            *(_DWORD *)long long buf = 136446722;
                                                            if (v842) {
                                                              v761 = (const char *)(v842 + 604);
                                                            }
                                                            __int16 v895 = 2082;
                                                            *(void *)v896 = v761;
                                                            *(_WORD *)&v896[8] = 2082;
                                                            *(void *)v897 = v760;
                                                            _os_log_impl(&dword_214653000, v759, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                                          }
                                                        }
                                                      }
                                                      if (*(void *)(v842 + 24))
                                                      {
                                                        uint64_t v458 = nw_protocol_tcp_get_all_stats();
                                                        if (v458) {
                                                          *(_DWORD *)(v458 + 136) = 10;
                                                        }
                                                      }
                                                      tcp_canceltimers(v119);
                                                      if ((*(unsigned char *)(v119 + 741) & 8) != 0)
                                                      {
                                                        int v832 = 0;
                                                        *(_DWORD *)(v119 + 88) |= 0x8000000u;
                                                      }
                                                      else
                                                      {
                                                        add_to_time_wait(v119, 2 * *(_DWORD *)(sysctls + 204));
                                                        int v832 = 0;
                                                      }
                                                      goto LABEL_1156;
                                                    case 8:
                                                      if (v434 > v438)
                                                      {
                                                        if ((*(unsigned char *)(v842 + 828) & 2) == 0)
                                                        {
                                                          if (__nwlog_is_datapath_logging_enabled())
                                                          {
                                                            v753 = __nwlog_tcp_log();
                                                            if (os_log_type_enabled(v753, OS_LOG_TYPE_DEBUG))
                                                            {
                                                              v754 = tcpstates[*(int *)(v119 + 12)];
                                                              v894 = "tcp_input";
                                                              v755 = "";
                                                              *(_DWORD *)long long buf = 136446722;
                                                              if (v842) {
                                                                v755 = (const char *)(v842 + 604);
                                                              }
                                                              __int16 v895 = 2082;
                                                              *(void *)v896 = v755;
                                                              *(_WORD *)&v896[8] = 2082;
                                                              *(void *)v897 = v754;
                                                              _os_log_impl(&dword_214653000, v753, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s ourfinisacked t_state %{public}s", buf, 0x20u);
                                                            }
                                                          }
                                                        }
                                                        tcp_close(v119);
                                                        goto LABEL_1271;
                                                      }
LABEL_1107:
                                                      int v404 = 0;
LABEL_1163:
                                                      os_log_type_t v39 = a6;
                                                      break;
                                                    case 10:
                                                      add_to_time_wait(v119, 2 * *(_DWORD *)(sysctls + 204));
                                                      os_log_type_t v39 = a6;
                                                      uint64_t v128 = v842;
                                                      goto LABEL_1109;
                                                    default:
                                                      goto LABEL_1158;
                                                  }
                                                }
                                                else
                                                {
                                                  int v404 = 0;
                                                  os_log_type_t v39 = a6;
                                                }
                                                LODWORD(v17) = v807;
                                                LODWORD(v16) = v811;
                                                goto LABEL_1165;
                                              }
                                              LODWORD(v411) = 64000;
                                            }
                                            *(_DWORD *)(v119 + 192) = v411;
                                            goto LABEL_998;
                                          }
                                          int v415 = v367;
                                          uint64_t v128 = v842;
                                          if (v842 && (*(unsigned char *)(v842 + 828) & 2) != 0)
                                          {
LABEL_1141:
                                            int v51 = v838;
                                            uint64_t v129 = v813;
LABEL_1142:
                                            int v130 = v839;
                                            unsigned int v40 = v222;
                                            goto LABEL_1311;
                                          }
                                          __nwlog_tcp_log();
                                          if (v842) {
                                            v416 = (const char *)(v842 + 604);
                                          }
                                          else {
                                            v416 = "";
                                          }
                                          int v417 = *(_DWORD *)(v119 + 12);
                                          int v418 = *(_DWORD *)(v119 + 120);
                                          int v419 = *(_DWORD *)(v119 + 92);
                                          *(_DWORD *)long long buf = 136449026;
                                          v894 = "tcp_input";
                                          __int16 v895 = 2082;
                                          *(void *)v896 = v416;
                                          *(_WORD *)&v896[8] = 1024;
                                          *(_DWORD *)v897 = bswap32((unsigned __int16)v914) >> 16;
                                          *(_WORD *)&v897[4] = 1024;
                                          *(_DWORD *)&v897[6] = bswap32(WORD1(v914)) >> 16;
                                          __int16 v898 = 1024;
                                          *(_DWORD *)v899 = v415;
                                          *(_WORD *)&v899[4] = 1024;
                                          *(_DWORD *)&v899[6] = BYTE13(v914);
                                          __int16 v900 = 1024;
                                          unsigned int v901 = bswap32(DWORD1(v914));
                                          __int16 v902 = 1024;
                                          unsigned int v903 = bswap32(DWORD2(v914));
                                          __int16 v904 = 1024;
                                          unsigned int v905 = bswap32(HIWORD(v914)) >> 16;
                                          __int16 v906 = 1024;
                                          int v907 = v417;
                                          __int16 v908 = 1024;
                                          int v909 = v418;
                                          __int16 v910 = 1024;
                                          int v911 = v419;
                                          v420 = (void *)_os_log_send_and_compose_impl();
                                          type[0] = OS_LOG_TYPE_ERROR;
                                          char v892 = 0;
                                          if (__nwlog_fault())
                                          {
                                            if (type[0] == OS_LOG_TYPE_FAULT)
                                            {
                                              v421 = __nwlog_tcp_log();
                                              os_log_type_t v422 = type[0];
                                              if (os_log_type_enabled(v421, type[0]))
                                              {
                                                int v423 = *(_DWORD *)(v119 + 12);
                                                int v424 = *(_DWORD *)(v119 + 120);
                                                int v425 = *(_DWORD *)(v119 + 92);
                                                *(_DWORD *)long long buf = 136449026;
                                                v894 = "tcp_input";
                                                __int16 v895 = 2082;
                                                *(void *)v896 = v416;
                                                *(_WORD *)&v896[8] = 1024;
                                                *(_DWORD *)v897 = bswap32((unsigned __int16)v914) >> 16;
                                                *(_WORD *)&v897[4] = 1024;
                                                *(_DWORD *)&v897[6] = bswap32(WORD1(v914)) >> 16;
                                                __int16 v898 = 1024;
                                                *(_DWORD *)v899 = v891;
                                                *(_WORD *)&v899[4] = 1024;
                                                *(_DWORD *)&v899[6] = BYTE13(v914);
                                                __int16 v900 = 1024;
                                                unsigned int v901 = bswap32(DWORD1(v914));
                                                __int16 v902 = 1024;
                                                unsigned int v903 = bswap32(DWORD2(v914));
                                                __int16 v904 = 1024;
                                                unsigned int v905 = bswap32(HIWORD(v914)) >> 16;
                                                __int16 v906 = 1024;
                                                int v907 = v423;
                                                __int16 v908 = 1024;
                                                int v909 = v424;
                                                __int16 v910 = 1024;
                                                int v911 = v425;
                                                v426 = "%{public}s %{public}s assertion failure SEQ_GEQ(tcp_hdr->th_ack, "
                                                       "tp->snd_una) %u:%u tlen %u, flags=%{network:tcp_flags}x seq=%u, a"
                                                       "ck=%u, win=%u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u";
LABEL_1137:
                                                _os_log_impl(&dword_214653000, v421, v422, v426, buf, 0x52u);
                                              }
                                            }
                                            else if (v892)
                                            {
                                              v427 = (void *)__nw_create_backtrace_string();
                                              v421 = __nwlog_tcp_log();
                                              os_log_type_t v422 = type[0];
                                              BOOL v428 = os_log_type_enabled(v421, type[0]);
                                              if (v427)
                                              {
                                                if (v428)
                                                {
                                                  int v429 = *(_DWORD *)(v119 + 12);
                                                  int v430 = *(_DWORD *)(v119 + 120);
                                                  int v431 = *(_DWORD *)(v119 + 92);
                                                  *(_DWORD *)long long buf = 136449282;
                                                  v894 = "tcp_input";
                                                  __int16 v895 = 2082;
                                                  *(void *)v896 = v416;
                                                  *(_WORD *)&v896[8] = 1024;
                                                  *(_DWORD *)v897 = bswap32((unsigned __int16)v914) >> 16;
                                                  *(_WORD *)&v897[4] = 1024;
                                                  *(_DWORD *)&v897[6] = bswap32(WORD1(v914)) >> 16;
                                                  __int16 v898 = 1024;
                                                  *(_DWORD *)v899 = v891;
                                                  *(_WORD *)&v899[4] = 1024;
                                                  *(_DWORD *)&v899[6] = BYTE13(v914);
                                                  __int16 v900 = 1024;
                                                  unsigned int v901 = bswap32(DWORD1(v914));
                                                  __int16 v902 = 1024;
                                                  unsigned int v903 = bswap32(DWORD2(v914));
                                                  __int16 v904 = 1024;
                                                  unsigned int v905 = bswap32(HIWORD(v914)) >> 16;
                                                  __int16 v906 = 1024;
                                                  int v907 = v429;
                                                  __int16 v908 = 1024;
                                                  int v909 = v430;
                                                  __int16 v910 = 1024;
                                                  int v911 = v431;
                                                  __int16 v912 = 2082;
                                                  v913 = v427;
                                                  _os_log_impl(&dword_214653000, v421, type[0], "%{public}s %{public}s assertion failure SEQ_GEQ(tcp_hdr->th_ack, tp->snd_una) %u:%u tlen %u, flags=%{network:tcp_flags}x seq=%u, ack=%u, win=%u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u, dumping backtrace:%{public}s", buf, 0x5Cu);
                                                }
                                                free(v427);
                                                goto LABEL_1138;
                                              }
                                              if (v428)
                                              {
                                                int v470 = *(_DWORD *)(v119 + 12);
                                                int v471 = *(_DWORD *)(v119 + 120);
                                                int v472 = *(_DWORD *)(v119 + 92);
                                                *(_DWORD *)long long buf = 136449026;
                                                v894 = "tcp_input";
                                                __int16 v895 = 2082;
                                                *(void *)v896 = v416;
                                                *(_WORD *)&v896[8] = 1024;
                                                *(_DWORD *)v897 = bswap32((unsigned __int16)v914) >> 16;
                                                *(_WORD *)&v897[4] = 1024;
                                                *(_DWORD *)&v897[6] = bswap32(WORD1(v914)) >> 16;
                                                __int16 v898 = 1024;
                                                *(_DWORD *)v899 = v891;
                                                *(_WORD *)&v899[4] = 1024;
                                                *(_DWORD *)&v899[6] = BYTE13(v914);
                                                __int16 v900 = 1024;
                                                unsigned int v901 = bswap32(DWORD1(v914));
                                                __int16 v902 = 1024;
                                                unsigned int v903 = bswap32(DWORD2(v914));
                                                __int16 v904 = 1024;
                                                unsigned int v905 = bswap32(HIWORD(v914)) >> 16;
                                                __int16 v906 = 1024;
                                                int v907 = v470;
                                                __int16 v908 = 1024;
                                                int v909 = v471;
                                                __int16 v910 = 1024;
                                                int v911 = v472;
                                                v426 = "%{public}s %{public}s assertion failure SEQ_GEQ(tcp_hdr->th_ack, "
                                                       "tp->snd_una) %u:%u tlen %u, flags=%{network:tcp_flags}x seq=%u, a"
                                                       "ck=%u, win=%u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u, no backtrace";
                                                goto LABEL_1137;
                                              }
                                            }
                                            else
                                            {
                                              v421 = __nwlog_tcp_log();
                                              os_log_type_t v422 = type[0];
                                              if (os_log_type_enabled(v421, type[0]))
                                              {
                                                int v459 = *(_DWORD *)(v119 + 12);
                                                int v460 = *(_DWORD *)(v119 + 120);
                                                int v461 = *(_DWORD *)(v119 + 92);
                                                *(_DWORD *)long long buf = 136449026;
                                                v894 = "tcp_input";
                                                __int16 v895 = 2082;
                                                *(void *)v896 = v416;
                                                *(_WORD *)&v896[8] = 1024;
                                                *(_DWORD *)v897 = bswap32((unsigned __int16)v914) >> 16;
                                                *(_WORD *)&v897[4] = 1024;
                                                *(_DWORD *)&v897[6] = bswap32(WORD1(v914)) >> 16;
                                                __int16 v898 = 1024;
                                                *(_DWORD *)v899 = v891;
                                                *(_WORD *)&v899[4] = 1024;
                                                *(_DWORD *)&v899[6] = BYTE13(v914);
                                                __int16 v900 = 1024;
                                                unsigned int v901 = bswap32(DWORD1(v914));
                                                __int16 v902 = 1024;
                                                unsigned int v903 = bswap32(DWORD2(v914));
                                                __int16 v904 = 1024;
                                                unsigned int v905 = bswap32(HIWORD(v914)) >> 16;
                                                __int16 v906 = 1024;
                                                int v907 = v459;
                                                __int16 v908 = 1024;
                                                int v909 = v460;
                                                __int16 v910 = 1024;
                                                int v911 = v461;
                                                v426 = "%{public}s %{public}s assertion failure SEQ_GEQ(tcp_hdr->th_ack, "
                                                       "tp->snd_una) %u:%u tlen %u, flags=%{network:tcp_flags}x seq=%u, a"
                                                       "ck=%u, win=%u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u,"
                                                       " backtrace limit exceeded";
                                                goto LABEL_1137;
                                              }
                                            }
                                          }
LABEL_1138:
                                          if (v420) {
                                            free(v420);
                                          }
                                          uint64_t v128 = v842;
                                          goto LABEL_1141;
                                        }
                                        uint64_t v370 = *v222;
                                        unsigned int v877 = v891 - v368;
                                        if (*v222)
                                        {
                                          if ((*(_WORD *)(v370 + 204) & 0x80) != 0)
                                          {
                                            unsigned int v371 = *(unsigned __int16 *)(v370 + 196);
                                            if (v369 > v371)
                                            {
                                              int v372 = v891;
                                              int v373 = v891 - v368;
                                              __nwlog_obj();
                                              int v374 = *(unsigned __int16 *)(v370 + 196);
                                              *(_DWORD *)long long buf = 136446722;
                                              v894 = "__nw_frame_array_claim";
                                              __int16 v895 = 1024;
                                              *(_DWORD *)v896 = v374;
                                              *(_WORD *)&v896[4] = 1024;
                                              *(_DWORD *)&v896[6] = v373;
                                              v375 = (void *)_os_log_send_and_compose_impl();
                                              type[0] = OS_LOG_TYPE_ERROR;
                                              char v892 = 0;
                                              if (__nwlog_fault())
                                              {
                                                if (type[0] == OS_LOG_TYPE_FAULT)
                                                {
                                                  v376 = __nwlog_obj();
                                                  os_log_type_t v377 = type[0];
                                                  if (os_log_type_enabled(v376, type[0]))
                                                  {
                                                    int v378 = *(unsigned __int16 *)(v370 + 196);
                                                    *(_DWORD *)long long buf = 136446722;
                                                    v894 = "__nw_frame_array_claim";
                                                    __int16 v895 = 1024;
                                                    *(_DWORD *)v896 = v378;
                                                    *(_WORD *)&v896[4] = 1024;
                                                    *(_DWORD *)&v896[6] = v877;
                                                    v379 = "%{public}s Aggregate buffer length: %u sum: %u";
LABEL_956:
                                                    v384 = v376;
                                                    os_log_type_t v385 = v377;
LABEL_957:
                                                    _os_log_impl(&dword_214653000, v384, v385, v379, buf, 0x18u);
                                                  }
                                                }
                                                else if (v892)
                                                {
                                                  v380 = (void *)__nw_create_backtrace_string();
                                                  v820 = __nwlog_obj();
                                                  BOOL v381 = os_log_type_enabled(v820, type[0]);
                                                  if (v380)
                                                  {
                                                    if (v381)
                                                    {
                                                      int v382 = *(unsigned __int16 *)(v370 + 196);
                                                      *(_DWORD *)long long buf = 136446978;
                                                      v894 = "__nw_frame_array_claim";
                                                      __int16 v895 = 1024;
                                                      *(_DWORD *)v896 = v382;
                                                      *(_WORD *)&v896[4] = 1024;
                                                      *(_DWORD *)&v896[6] = v877;
                                                      *(_WORD *)v897 = 2082;
                                                      *(void *)&v897[2] = v380;
                                                      _os_log_impl(&dword_214653000, v820, type[0], "%{public}s Aggregate buffer length: %u sum: %u, dumping backtrace:%{public}s", buf, 0x22u);
                                                    }
                                                    free(v380);
                                                    goto LABEL_958;
                                                  }
                                                  if (v381)
                                                  {
                                                    int v473 = *(unsigned __int16 *)(v370 + 196);
                                                    *(_DWORD *)long long buf = 136446722;
                                                    v894 = "__nw_frame_array_claim";
                                                    __int16 v895 = 1024;
                                                    *(_DWORD *)v896 = v473;
                                                    *(_WORD *)&v896[4] = 1024;
                                                    *(_DWORD *)&v896[6] = v877;
                                                    v379 = "%{public}s Aggregate buffer length: %u sum: %u, no backtrace";
                                                    v384 = v820;
                                                    os_log_type_t v385 = type[0];
                                                    goto LABEL_957;
                                                  }
                                                }
                                                else
                                                {
                                                  v376 = __nwlog_obj();
                                                  os_log_type_t v377 = type[0];
                                                  if (os_log_type_enabled(v376, type[0]))
                                                  {
                                                    int v383 = *(unsigned __int16 *)(v370 + 196);
                                                    *(_DWORD *)long long buf = 136446722;
                                                    v894 = "__nw_frame_array_claim";
                                                    __int16 v895 = 1024;
                                                    *(_DWORD *)v896 = v383;
                                                    *(_WORD *)&v896[4] = 1024;
                                                    *(_DWORD *)&v896[6] = v877;
                                                    v379 = "%{public}s Aggregate buffer length: %u sum: %u, backtrace limit exceeded";
                                                    goto LABEL_956;
                                                  }
                                                }
                                              }
LABEL_958:
                                              if (v375) {
                                                free(v375);
                                              }
                                              *(_WORD *)(v370 + 196) = 0;
                                              int v367 = v372;
                                              unsigned int v369 = v877;
                                              goto LABEL_961;
                                            }
                                            *(_WORD *)(v370 + 196) = v371 - v369;
                                          }
LABEL_947:
                                          if (v367 == v368)
                                          {
LABEL_983:
                                            int v367 = *(_DWORD *)(v830 + 128);
                                            int v891 = v367;
                                            v835 &= ~1u;
                                            uint64_t v401 = *(void *)(v830 + 1056);
                                            if (v401)
                                            {
                                              uint64_t v402 = *(void *)(v401 + 280) + (int)v369;
                                              ++*(void *)(v401 + 272);
                                              *(void *)(v401 + 280) = v402;
                                            }
                                            v222 = v885;
                                            goto LABEL_986;
                                          }
LABEL_961:
                                          unsigned int v386 = 0;
                                          uint64_t v387 = **(void **)(v885[1] + 8);
                                          if (!v387 || v367 == v368)
                                          {
LABEL_980:
                                            if (v386 != v369)
                                            {
                                              v399 = __nwlog_obj();
                                              BOOL v400 = os_log_type_enabled(v399, OS_LOG_TYPE_ERROR);
                                              unsigned int v369 = v877;
                                              if (v400)
                                              {
                                                *(_DWORD *)long long buf = 136446722;
                                                v894 = "__nw_frame_array_claim";
                                                __int16 v895 = 1024;
                                                *(_DWORD *)v896 = v386;
                                                *(_WORD *)&v896[4] = 1024;
                                                *(_DWORD *)&v896[6] = v877;
                                                _os_log_impl(&dword_214653000, v399, OS_LOG_TYPE_ERROR, "%{public}s end_offset %u != end_bytes %u", buf, 0x18u);
                                                unsigned int v369 = v877;
                                              }
                                            }
                                          }
                                          else
                                          {
                                            unsigned int v386 = 0;
                                            while (1)
                                            {
                                              uint64_t v388 = v16;
                                              int v389 = *(_DWORD *)(v387 + 52);
                                              unsigned int v390 = *(_DWORD *)(v387 + 56);
                                              int v391 = *(_DWORD *)(v387 + 60);
                                              unsigned int v392 = v389 - (v390 + v391);
                                              if (v392 >= v369 - v386) {
                                                unsigned int v392 = v369 - v386;
                                              }
                                              unsigned int v393 = v389 ? v392 : 0;
                                              int v394 = v391 + v393;
                                              if (v390 <= v389 - (v391 + v393))
                                              {
                                                *(_DWORD *)(v387 + 60) = v394;
                                              }
                                              else
                                              {
                                                v395 = __nwlog_obj();
                                                BOOL v396 = os_log_type_enabled(v395, OS_LOG_TYPE_ERROR);
                                                unsigned int v369 = v877;
                                                if (v396)
                                                {
                                                  int v397 = *(_DWORD *)(v387 + 52);
                                                  *(_DWORD *)long long buf = 136446978;
                                                  v894 = "__nw_frame_claim_internal";
                                                  __int16 v895 = 1024;
                                                  *(_DWORD *)v896 = v390;
                                                  *(_WORD *)&v896[4] = 1024;
                                                  *(_DWORD *)&v896[6] = v397;
                                                  *(_WORD *)v897 = 1024;
                                                  *(_DWORD *)&v897[2] = v394;
                                                  _os_log_impl(&dword_214653000, v395, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
                                                  unsigned int v369 = v877;
                                                }
                                              }
                                              v386 += v393;
                                              uint64_t v16 = v388;
                                              if (v386 == v369) {
                                                break;
                                              }
                                              if (*(_OWORD *)(v387 + 32) != 0)
                                              {
                                                uint64_t v387 = **(void **)(*(void *)(v387 + 40) + 8);
                                                if (v387 && v386 < v369) {
                                                  continue;
                                                }
                                              }
                                              goto LABEL_980;
                                            }
                                          }
                                          goto LABEL_983;
                                        }
                                        int v646 = v891;
                                        __nwlog_obj();
                                        *(_DWORD *)long long buf = 136446210;
                                        v894 = "__nw_frame_is_single_ip_aggregate";
                                        v647 = (void *)_os_log_send_and_compose_impl();
                                        type[0] = OS_LOG_TYPE_ERROR;
                                        char v892 = 0;
                                        if (__nwlog_fault())
                                        {
                                          if (type[0] == OS_LOG_TYPE_FAULT)
                                          {
                                            v648 = __nwlog_obj();
                                            os_log_type_t v649 = type[0];
                                            if (os_log_type_enabled(v648, type[0]))
                                            {
                                              *(_DWORD *)long long buf = 136446210;
                                              v894 = "__nw_frame_is_single_ip_aggregate";
                                              v650 = "%{public}s called with null frame";
LABEL_1887:
                                              v709 = v648;
                                              os_log_type_t v710 = v649;
LABEL_1888:
                                              _os_log_impl(&dword_214653000, v709, v710, v650, buf, 0xCu);
                                            }
                                          }
                                          else if (v892)
                                          {
                                            v660 = (void *)__nw_create_backtrace_string();
                                            v661 = __nwlog_obj();
                                            BOOL v662 = os_log_type_enabled(v661, type[0]);
                                            if (v660)
                                            {
                                              if (v662)
                                              {
                                                *(_DWORD *)long long buf = 136446466;
                                                v894 = "__nw_frame_is_single_ip_aggregate";
                                                __int16 v895 = 2082;
                                                *(void *)v896 = v660;
                                                _os_log_impl(&dword_214653000, v661, type[0], "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                                              }
                                              free(v660);
                                              goto LABEL_1889;
                                            }
                                            if (v662)
                                            {
                                              *(_DWORD *)long long buf = 136446210;
                                              v894 = "__nw_frame_is_single_ip_aggregate";
                                              v650 = "%{public}s called with null frame, no backtrace";
                                              v709 = v661;
                                              os_log_type_t v710 = type[0];
                                              goto LABEL_1888;
                                            }
                                          }
                                          else
                                          {
                                            v648 = __nwlog_obj();
                                            os_log_type_t v649 = type[0];
                                            if (os_log_type_enabled(v648, type[0]))
                                            {
                                              *(_DWORD *)long long buf = 136446210;
                                              v894 = "__nw_frame_is_single_ip_aggregate";
                                              v650 = "%{public}s called with null frame, backtrace limit exceeded";
                                              goto LABEL_1887;
                                            }
                                          }
                                        }
LABEL_1889:
                                        if (v647) {
                                          free(v647);
                                        }
                                        int v367 = v646;
                                        unsigned int v369 = v877;
                                        goto LABEL_947;
                                      }
                                      if ((*(unsigned char *)(v128 + 828) & 2) != 0
                                        || (v630 = __nwlog_tcp_log(),
                                            !os_log_type_enabled(v630, OS_LOG_TYPE_INFO)))
                                      {
LABEL_1691:
                                        *(void *)(v119 + 1056) = 0;
                                        unsigned int v40 = v222;
                                        goto LABEL_787;
                                      }
                                      v631 = "";
                                      if (v842) {
                                        v631 = (const char *)(v842 + 604);
                                      }
LABEL_1690:
                                      *(_DWORD *)long long buf = 136446466;
                                      v894 = "tcp_input";
                                      __int16 v895 = 2082;
                                      *(void *)v896 = v631;
                                      _os_log_impl(&dword_214653000, v630, OS_LOG_TYPE_INFO, "%{public}s %{public}s dropping tcp input frame since frame is no longer valid", buf, 0x16u);
                                      goto LABEL_1691;
                                    }
                                    v265 = *(void **)(v119 + 1056);
                                    if (v265) {
                                      ++v265[51];
                                    }
                                    if ((v127 & 0xC0) == 0x40)
                                    {
                                      int v266 = *(_DWORD *)(v119 + 348);
                                      *(_DWORD *)(v119 + 348) = v266 | 2;
                                      if (v266)
                                      {
                                        uint64_t v267 = *(void *)(v119 + 80);
                                        buf[0] = 1;
                                        (*(void (**)(void, uint8_t *))(*(void *)(v267 + 2136) + 24))(*(void *)(v267 + 224), buf);
                                        uint64_t v268 = *(void *)(v119 + 1056);
                                        if (v268) {
                                          ++*(void *)(v268 + 776);
                                        }
                                      }
                                      uint64_t v269 = v119;
                                      int v270 = *(_DWORD *)(v119 + 348);
                                      if ((v270 & 0x100000) != 0)
                                      {
                                        *(_DWORD *)(v119 + 348) = v270 & 0xFFEFFFFA | 5;
                                        if (*(_DWORD *)(v119 + 360) == 2)
                                        {
                                          int v271 = 3;
LABEL_801:
                                          *(_DWORD *)(v269 + 360) = v271;
                                        }
                                      }
                                    }
                                    else
                                    {
                                      int v304 = *(_DWORD *)(v119 + 740);
                                      if ((v304 & 0x10000000) == 0
                                        && ((int v305 = ((unsigned __int16)v834 | (unsigned __int16)(BYTE12(v914) << 8)) & 0x1C0,
                                             uint64_t v306 = sysctls,
                                             *(_DWORD *)(sysctls + 320) == 1)
                                         || tcp_do_acc_ecn == 1
                                         || (v304 & 0x8000000) != 0)
                                        && (((unsigned __int16)v834 | (unsigned __int16)(BYTE12(v914) << 8)) & 0x1C0) != 0
                                        && v305 != 448)
                                      {
                                        *(_DWORD *)(v119 + 420) = 5;
                                        *(void *)(v119 + 456) = 1;
                                        *(_OWORD *)(v119 + 464) = xmmword_2146B2930;
                                        int v307 = *(_DWORD *)(v119 + 348);
                                        unsigned int v308 = v307 | 0x400000;
                                        *(_DWORD *)(v119 + 348) = v307 | 0x400000;
                                        switch((v305 - 128) >> 6)
                                        {
                                          case 0u:
                                            int v309 = v304 & 0x8000000;
                                            int v310 = *(_DWORD *)(v306 + 336);
                                            if (tcp_do_l4s != 1 && v310 != 1 && v309 == 0) {
                                              int v313 = 0x200000;
                                            }
                                            else {
                                              int v313 = 2097156;
                                            }
                                            v308 |= v313;
                                            *(_DWORD *)(v119 + 348) = v308;
                                            *(_DWORD *)(v119 + 360) = 7;
                                            if (v265) {
                                              ++v265[102];
                                            }
                                            break;
                                          case 1u:
                                            unsigned int v308 = v307 & 0xFF9FFFFB | 0x600000;
                                            *(_DWORD *)(v119 + 348) = v308;
                                            *(_DWORD *)(v119 + 360) = 8;
                                            if (v265) {
                                              ++v265[103];
                                            }
                                            break;
                                          case 2u:
                                            unsigned int v308 = v307 & 0xFF9FFFFB | 0x600000;
                                            *(_DWORD *)(v119 + 348) = v308;
                                            *(_DWORD *)(v119 + 360) = 8;
                                            if (v265) {
                                              ++v265[104];
                                            }
                                            break;
                                          case 4u:
                                            *(_DWORD *)(v119 + 360) = 8;
                                            unsigned int v308 = v307 & 0xFF9FFFFB | 0x600000;
                                            *(_DWORD *)(v119 + 348) = v308;
                                            *(_DWORD *)(v119 + 144) = 2 * *(_DWORD *)(v119 + 196);
                                            if (v265) {
                                              ++v265[105];
                                            }
                                            break;
                                          default:
                                            break;
                                        }
                                        if ((~v308 & 3) == 0)
                                        {
                                          uint64_t v555 = *(void *)(v119 + 80);
                                          buf[0] = 1;
                                          (*(void (**)(void, uint8_t *))(*(void *)(v555 + 2136) + 24))(*(void *)(v555 + 224), buf);
                                          uint64_t v556 = *(void *)(v119 + 1056);
                                          if (v556) {
                                            ++*(void *)(v556 + 776);
                                          }
                                        }
                                        uint64_t v269 = v119;
                                        *(_DWORD *)(v119 + 416) = 5;
                                        *(int64x2_t *)(v119 + 432) = vdupq_n_s64(1uLL);
                                        *(void *)(v119 + 448) = 0;
                                        tcp_input_ip_ecn(v119, a3, v891, v818, v855);
                                        *(_DWORD *)(v119 + 348) |= dword_2146B2950[v855];
                                        if (v888[0])
                                        {
                                          if (DWORD2(v888[0]))
                                          {
                                            int v557 = *(_DWORD *)(v119 + 400);
                                            if (!v557 || ((DWORD2(v888[0]) - v557) & 0x80000000) == 0) {
                                              *(_DWORD *)(v119 + 400) = DWORD2(v888[0]);
                                            }
                                          }
                                        }
                                      }
                                      else
                                      {
                                        if ((*(_DWORD *)(v119 + 348) & 0x100001) != 0 && !*(_WORD *)(v119 + 226))
                                        {
                                          uint64_t v317 = *(void *)(v119 + 80);
                                          buf[0] = 1;
                                          (*(void (**)(void, uint8_t *))(*(void *)(v317 + 2136) + 24))(*(void *)(v317 + 224), buf);
                                          uint64_t v318 = *(void *)(v119 + 1056);
                                          if (v318) {
                                            ++*(void *)(v318 + 784);
                                          }
                                        }
                                        int v319 = *(_DWORD *)(v119 + 348);
                                        if ((v319 & 0x100001) != 0 && *(_WORD *)(v119 + 226))
                                        {
                                          tcp_heuristic_ecn_loss(v119);
                                          int v319 = *(_DWORD *)(v119 + 348);
                                        }
                                        *(_DWORD *)(v119 + 348) = v319 & 0xFFFFFFFB;
                                        if ((v319 & 0x100) != 0
                                          && *(unsigned __int16 *)(v119 + 226) <= 2u
                                          && *(_DWORD *)(v119 + 360) == 2)
                                        {
                                          *(_DWORD *)(v119 + 360) = 5;
                                        }
                                        uint64_t v269 = v119;
                                        if (*(_DWORD *)(v119 + 360) == 2)
                                        {
                                          int v271 = 4;
                                          goto LABEL_801;
                                        }
                                      }
                                    }
                                    int v320 = *(_DWORD *)(v269 + 88);
                                    if ((~v320 & 0x60) != 0)
                                    {
                                      char v321 = *(unsigned char *)(v269 + 261);
                                    }
                                    else
                                    {
                                      *(unsigned char *)(v269 + 260) = *(unsigned char *)(v269 + 263);
                                      char v321 = *(unsigned char *)(v269 + 262);
                                      *(unsigned char *)(v269 + 261) = v321;
                                    }
                                    uint64_t v322 = 0xFFFFLL << v321;
                                    int v323 = 0xFFFF << v321;
                                    if (v322 <= *(unsigned int *)(v269 + 128)) {
                                      unsigned int v324 = v323;
                                    }
                                    else {
                                      unsigned int v324 = *(_DWORD *)(v269 + 128);
                                    }
                                    if (*(_DWORD *)(sysctls + 308) == 1
                                      && (v320 & 0x180) == 0x180
                                      && (*(_DWORD *)(sysctls + 40) == 1 || (*(unsigned char *)(v842 + 369) & 0x40) != 0))
                                    {
                                      if (off_26AA46368)
                                      {
                                        unsigned int v325 = off_26AA46368(v119);
                                        unsigned int v326 = v324 >= v325 ? v325 : v324;
                                        if (v325) {
                                          unsigned int v324 = v326;
                                        }
                                      }
                                    }
                                    *(_DWORD *)(v119 + 124) += v324;
                                    int v327 = *(_DWORD *)(v119 + 92) + 1;
                                    *(_DWORD *)(v119 + 92) = v327;
                                    if (*(void *)(v842 + 24))
                                    {
                                      uint64_t v328 = nw_protocol_tcp_get_all_stats();
                                      int v327 = *(_DWORD *)(v119 + 92);
                                      if (v328)
                                      {
                                        *(_DWORD *)(v328 + 108) = *(_DWORD *)(v119 + 96) - v327;
                                        int v327 = *(_DWORD *)(v119 + 92);
                                      }
                                    }
                                    uint64_t v329 = v119;
                                    int v330 = *(_DWORD *)(v119 + 100);
                                    if (v330 - v327 < 0)
                                    {
                                      *(_DWORD *)(v119 + 100) = v327;
                                      int v330 = v327;
                                    }
                                    int v331 = DWORD2(v914);
                                    if (v330 - DWORD2(v914) >= 1)
                                    {
                                      if ((*(unsigned char *)(v119 + 743) & 1) == 0 && (*(_WORD *)(v119 + 990) & 0x40) != 0)
                                      {
                                        unsigned int v332 = *(_DWORD *)(v119 + 96);
                                        if (v332 == DWORD2(v914) + 1 && v332 > v327 + 1)
                                        {
                                          tcp_heuristic_tfo_middlebox(v119);
                                          *(_WORD *)(v842 + 378) = 96;
                                          user_north_signal_error(v842);
                                          *(_WORD *)(v119 + 990) |= 0x4000u;
                                          int v331 = DWORD2(v914);
                                        }
                                      }
                                      uint64_t v329 = v119;
                                      *(_DWORD *)(v119 + 96) = v331;
                                      *(_DWORD *)(v119 + 100) = v331;
                                    }
                                    if (*(void *)(v842 + 24))
                                    {
                                      uint64_t v333 = nw_protocol_tcp_get_all_stats();
                                      if (v333) {
                                        *(_DWORD *)(v333 + 108) = *(_DWORD *)(v329 + 96) - *(_DWORD *)(v329 + 92);
                                      }
                                    }
                                    *(_WORD *)(v329 + 304) += v818;
                                    int v334 = *(_DWORD *)(v329 + 740);
                                    if ((v334 & 0x10000000) == 0
                                      && ((v334 & 0x8000000) != 0
                                       || *(_DWORD *)(sysctls + 320) == 1
                                       || tcp_do_acc_ecn == 1))
                                    {
                                      char v335 = v817 ^ 1;
                                      if ((~*(_DWORD *)(v329 + 348) & 0x300000) != 0) {
                                        char v335 = 1;
                                      }
                                      if ((v335 & 1) == 0) {
                                        *(_WORD *)(v329 + 306) += v818;
                                      }
                                    }
                                    v336 = *(uint64_t (**)(uint64_t, long long *))(tcp_cc_algo_list[*(unsigned __int8 *)(v329 + 264)]
                                                                                         + 96);
                                    if (v336)
                                    {
                                      int v337 = v336(v329, &v914);
                                      int v338 = *(_DWORD *)(v329 + 88);
                                      if (v337 && v891)
                                      {
                                        uint64_t v339 = v119;
                                        if ((v338 & 2) == 0)
                                        {
                                          *(_DWORD *)(v119 + 88) = v338 | 2;
                                          *(_DWORD *)(v119 + 32) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v119 + 80) + 224))
                                                                             + 316)
                                                                 - *(_DWORD *)(v119 + 64)
                                                                 + 100;
                                        }
LABEL_857:
                                        *(_DWORD *)(v339 + 168) = *(_DWORD *)(v828 + 316);
                                        tcp_sbrcv_tstmp_check(v339);
                                        if ((*(unsigned char *)(v339 + 89) & 8) != 0)
                                        {
                                          *(_DWORD *)(v339 + 12) = 6;
                                          if ((*(unsigned char *)(v842 + 828) & 2) == 0)
                                          {
                                            if (__nwlog_is_datapath_logging_enabled())
                                            {
                                              v719 = __nwlog_tcp_log();
                                              if (os_log_type_enabled(v719, OS_LOG_TYPE_DEBUG))
                                              {
                                                v720 = tcpstates[*(int *)(v119 + 12)];
                                                v894 = "tcp_input";
                                                v721 = "";
                                                *(_DWORD *)long long buf = 136446722;
                                                if (v842) {
                                                  v721 = (const char *)(v842 + 604);
                                                }
                                                __int16 v895 = 2082;
                                                *(void *)v896 = v721;
                                                *(_WORD *)&v896[8] = 2082;
                                                *(void *)v897 = v720;
                                                _os_log_impl(&dword_214653000, v719, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                              }
                                            }
                                          }
                                          if (*(void *)(v842 + 24))
                                          {
                                            uint64_t v348 = nw_protocol_tcp_get_all_stats();
                                            if (v348) {
                                              *(_DWORD *)(v348 + 136) = 6;
                                            }
                                          }
                                          *(_DWORD *)(v119 + 88) &= ~0x800u;
                                          v834 &= ~2u;
                                        }
                                        else
                                        {
                                          *(_DWORD *)(v339 + 12) = 4;
                                          if ((*(unsigned char *)(v842 + 828) & 2) == 0)
                                          {
                                            if (__nwlog_is_datapath_logging_enabled())
                                            {
                                              v716 = __nwlog_tcp_log();
                                              if (os_log_type_enabled(v716, OS_LOG_TYPE_DEBUG))
                                              {
                                                v717 = tcpstates[*(int *)(v119 + 12)];
                                                v894 = "tcp_input";
                                                v718 = "";
                                                *(_DWORD *)long long buf = 136446722;
                                                if (v842) {
                                                  v718 = (const char *)(v842 + 604);
                                                }
                                                __int16 v895 = 2082;
                                                *(void *)v896 = v718;
                                                *(_WORD *)&v896[8] = 2082;
                                                *(void *)v897 = v717;
                                                _os_log_impl(&dword_214653000, v716, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                              }
                                            }
                                          }
                                          if (*(void *)(v842 + 24))
                                          {
                                            uint64_t v344 = nw_protocol_tcp_get_all_stats();
                                            if (v344) {
                                              *(_DWORD *)(v344 + 136) = 4;
                                            }
                                          }
                                          int v345 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v119 + 80)
                                                                                             + 224))
                                                           + 316);
                                          int v346 = *(_DWORD *)(v119 + 676);
                                          if (!v346
                                            || (*(unsigned char *)(*(void *)(*(void *)(v119 + 80) + 224) + 372) & 8) == 0)
                                          {
                                            int v346 = *(_DWORD *)(sysctls + 192);
                                          }
                                          *(_DWORD *)(v119 + 40) = v346 + v345 - *(_DWORD *)(v119 + 64);
                                          if (*(void *)(v842 + 24))
                                          {
                                            uint64_t v347 = nw_protocol_tcp_get_all_stats();
                                            if (v347) {
                                              ++*(_DWORD *)(v347 + 64);
                                            }
                                          }
                                        }
                                        *(_WORD *)(v119 + 308) = 16;
                                        if ((*(unsigned char *)(v119 + 988) & 0xC) != 0 || (*(_WORD *)(v119 + 990) & 0x40) != 0)
                                        {
                                          tcp_tfo_synack(v119, (uint64_t)v888);
                                          __int16 v349 = *(_WORD *)(v119 + 990);
                                          if ((v349 & 0x40) == 0 || *(_DWORD *)(v119 + 92) - DWORD2(v914) >= 0)
                                          {
                                            int v832 = 1;
                                            uint64_t v128 = v842;
LABEL_931:
                                            uint64_t v16 = v16;
                                            goto LABEL_932;
                                          }
                                          *(_WORD *)(v119 + 990) = v349 | 0x80;
                                          uint64_t v365 = *(void *)(v119 + 1056);
                                          if (v365) {
                                            ++*(void *)(v365 + 1128);
                                          }
                                          tcp_tfo_rcv_probe(v119, v891);
                                        }
                                        int v832 = 1;
                                        uint64_t v128 = v842;
                                        goto LABEL_931;
                                      }
                                    }
                                    else
                                    {
                                      int v338 = *(_DWORD *)(v329 + 88);
                                    }
                                    uint64_t v339 = v119;
                                    *(_DWORD *)(v119 + 88) = v338 | 1;
                                    goto LABEL_857;
                                  }
LABEL_643:
                                  int v51 = v838;
                                  goto LABEL_1142;
                                }
                                goto LABEL_739;
                              case 3:
                                if ((v834 & 0x10) != 0
                                  && (DWORD2(v914) - *(_DWORD *)(v119 + 92) < 1
                                   || DWORD2(v914) - *(_DWORD *)(v119 + 96) > 0))
                                {
                                  goto LABEL_739;
                                }
                                if ((v834 & 2) != 0 && *(_DWORD *)(v119 + 116) == DWORD1(v914) && (v888[0] & 0x20) == 0) {
                                  *(_DWORD *)(v119 + 88) &= ~0x40u;
                                }
LABEL_581:
                                if ((v834 & 4) == 0)
                                {
                                  if ((v888[0] & 1) == 0
                                    || (int v231 = *(_DWORD *)(v119 + 276)) == 0
                                    || DWORD1(v888[0]) - v231 >= 0)
                                  {
LABEL_587:
                                    if (v229 == 3 && DWORD1(v914) - *(_DWORD *)(v119 + 116) < 0) {
                                      goto LABEL_739;
                                    }
                                    if ((*(_WORD *)(v12 + 204) & 0x100) != 0 && *MEMORY[0x263F144B8])
                                    {
                                      if (!((unsigned int (*)(uint64_t, void))*MEMORY[0x263F144B8])(v12, *(void *)(v12 + 88)))
                                      {
                                        if ((*(unsigned char *)(v128 + 828) & 2) != 0) {
                                          goto LABEL_1691;
                                        }
                                        v630 = __nwlog_tcp_log();
                                        if (!os_log_type_enabled(v630, OS_LOG_TYPE_INFO)) {
                                          goto LABEL_1691;
                                        }
                                        v631 = "";
                                        if (v842) {
                                          v631 = (const char *)(v842 + 604);
                                        }
                                        goto LABEL_1690;
                                      }
                                      int v227 = *(_DWORD *)(v119 + 120);
                                    }
                                    int v232 = v227 - DWORD1(v914);
                                    int v233 = v837;
                                    uint64_t v813 = v129;
                                    if (v227 - DWORD1(v914) <= 0)
                                    {
                                      int v255 = v891;
                                      unsigned int v127 = v834;
LABEL_723:
                                      if (!v255) {
                                        goto LABEL_732;
                                      }
                                      int v283 = *(_DWORD *)(v128 + 364);
                                      BOOL v284 = (v283 & 0x1000000) == 0
                                          && (*(_WORD *)(v128 + 376) & 1) != 0
                                          && *(_DWORD *)(v119 + 12) > 5;
                                      if ((v283 & 8) != 0 && *(int *)(v119 + 12) > 6) {
                                        BOOL v284 = 1;
                                      }
                                      if (!(*(_WORD *)(v128 + 376) & 0x20 | v284))
                                      {
LABEL_732:
                                        int v285 = DWORD1(v914);
                                        int v286 = *(_DWORD *)(v119 + 120);
                                        int v287 = *(_DWORD *)(v119 + 128);
                                        uint64_t v288 = v119;
                                        int v289 = DWORD1(v914) + v255 - (v286 + v287);
                                        LODWORD(v837) = v233;
                                        int v810 = v16;
                                        uint64_t v806 = a3;
                                        if (v289 < 1) {
                                          goto LABEL_1252;
                                        }
                                        v290 = *(void **)(v288 + 1056);
                                        unsigned int v834 = v127;
                                        if (v290)
                                        {
                                          uint64_t v291 = v290[35];
                                          ++v290[34];
                                          if (v255 > v289)
                                          {
                                            int v292 = v255;
                                            v290[35] = v291 + v289;
                                            goto LABEL_747;
                                          }
                                          v290[35] = v291 + v255;
                                          if (v285 == v286 && !v287)
                                          {
                                            int v292 = v255;
                                            *(_DWORD *)(v830 + 88) |= 1u;
                                            ++v290[36];
LABEL_747:
                                            uint64_t v294 = *v222;
                                            if (*v222)
                                            {
                                              if ((*(_WORD *)(v294 + 204) & 0x80) == 0)
                                              {
LABEL_1228:
                                                uint64_t v501 = **(void **)(v222[1] + 8);
                                                if (v501)
                                                {
                                                  unsigned int v502 = 0;
                                                  while (1)
                                                  {
                                                    int v503 = *(_DWORD *)(v501 + 52);
                                                    unsigned int v504 = *(_DWORD *)(v501 + 56);
                                                    int v505 = *(_DWORD *)(v501 + 60);
                                                    unsigned int v506 = v503 - (v504 + v505);
                                                    if (v506 >= v289 - v502) {
                                                      unsigned int v506 = v289 - v502;
                                                    }
                                                    unsigned int v507 = v503 ? v506 : 0;
                                                    int v508 = v505 + v507;
                                                    if (v504 <= v503 - (v505 + v507))
                                                    {
                                                      *(_DWORD *)(v501 + 60) = v508;
                                                    }
                                                    else
                                                    {
                                                      v509 = __nwlog_obj();
                                                      if (os_log_type_enabled(v509, OS_LOG_TYPE_ERROR))
                                                      {
                                                        int v510 = *(_DWORD *)(v501 + 52);
                                                        *(_DWORD *)long long buf = 136446978;
                                                        v894 = "__nw_frame_claim_internal";
                                                        __int16 v895 = 1024;
                                                        *(_DWORD *)v896 = v504;
                                                        *(_WORD *)&v896[4] = 1024;
                                                        *(_DWORD *)&v896[6] = v510;
                                                        *(_WORD *)v897 = 1024;
                                                        *(_DWORD *)&v897[2] = v508;
                                                        _os_log_impl(&dword_214653000, v509, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
                                                      }
                                                    }
                                                    v502 += v507;
                                                    if (v502 == v289) {
                                                      break;
                                                    }
                                                    if (*(_OWORD *)(v501 + 32) != 0)
                                                    {
                                                      uint64_t v501 = **(void **)(*(void *)(v501 + 40) + 8);
                                                      if (v501 && v502 < v289) {
                                                        continue;
                                                      }
                                                    }
                                                    goto LABEL_1248;
                                                  }
                                                }
                                                else
                                                {
                                                  unsigned int v502 = 0;
LABEL_1248:
                                                  if (v502 != v289)
                                                  {
                                                    v512 = __nwlog_obj();
                                                    if (os_log_type_enabled(v512, OS_LOG_TYPE_ERROR))
                                                    {
                                                      *(_DWORD *)long long buf = 136446722;
                                                      v894 = "__nw_frame_array_claim";
                                                      __int16 v895 = 1024;
                                                      *(_DWORD *)v896 = v502;
                                                      *(_WORD *)&v896[4] = 1024;
                                                      *(_DWORD *)&v896[6] = v289;
                                                      _os_log_impl(&dword_214653000, v512, OS_LOG_TYPE_ERROR, "%{public}s end_offset %u != end_bytes %u", buf, 0x18u);
                                                    }
                                                  }
                                                }
                                                int v255 = v292 - v289;
                                                int v891 = v292 - v289;
                                                unsigned int v127 = v834 & 0xFFFFFFF6;
LABEL_1252:
                                                uint64_t v119 = v830;
                                                if (v888[0])
                                                {
                                                  int v513 = *(_DWORD *)(v830 + 284);
                                                  if (DWORD1(v914) - v513 <= 0
                                                    && v513 - ((v127 & 3) != 0) - (DWORD1(v914) + v255) <= 0)
                                                  {
                                                    *(_DWORD *)(v830 + 280) = *(_DWORD *)(v828 + 316);
                                                    *(_DWORD *)(v830 + 276) = DWORD1(v888[0]);
                                                  }
                                                }
                                                unsigned int v879 = v255;
                                                if ((v127 & 2) != 0)
                                                {
                                                  if (v255 < 1
                                                    || DWORD1(v914) != *(_DWORD *)(v830 + 116)
                                                    || *(void *)(*(void *)(*(void *)(v830 + 80) + 248) + 8) >> 31)
                                                  {
                                                    if (!tcp_is_ack_ratelimited(v830))
                                                    {
                                                      uint64_t v516 = *(void *)(v830 + 1056);
                                                      if (v516) {
                                                        ++*(void *)(v516 + 104);
                                                      }
                                                      unsigned int v40 = v885;
                                                      os_log_type_t v39 = a6;
                                                      uint64_t v128 = v842;
                                                      uint64_t v129 = v813;
                                                      int v130 = v839;
                                                      goto LABEL_1277;
                                                    }
LABEL_1270:
                                                    unsigned int v40 = v885;
LABEL_1271:
                                                    os_log_type_t v39 = a6;
                                                    uint64_t v128 = v842;
                                                    int v51 = v838;
LABEL_1272:
                                                    uint64_t v129 = v813;
                                                    int v130 = v839;
                                                    goto LABEL_1311;
                                                  }
                                                  ++DWORD1(v914);
                                                  v127 &= ~2u;
                                                  int v514 = *(_DWORD *)(v830 + 12);
                                                  if ((v127 & 0x10) == 0)
                                                  {
LABEL_1258:
                                                    if (v514 == 3)
                                                    {
                                                      if ((*(unsigned char *)(v830 + 742) & 0x40) != 0)
                                                      {
                                                        *(_DWORD *)(v830 + 100) = *(_DWORD *)(v830 + 92);
                                                        int v878 = (BYTE13(v914) >> 1) & 1;
                                                      }
                                                      else
                                                      {
                                                        int v878 = 0;
                                                      }
                                                      LOBYTE(v406) = v127;
                                                      tcp_input_process_accecn_syn((int64x2_t *)v830, ((unsigned __int16)v127 | (unsigned __int16)(BYTE12(v914) << 8)) & 0x1C0, v855);
                                                      int v404 = 0;
                                                      int v832 = 0;
                                                      os_log_type_t v39 = a6;
                                                      LODWORD(v16) = v810;
                                                      a3 = v806;
                                                      goto LABEL_1166;
                                                    }
                                                    unsigned int v40 = v885;
                                                    os_log_type_t v39 = a6;
                                                    uint64_t v128 = v842;
                                                    uint64_t v129 = v813;
                                                    int v130 = v839;
                                                    if (*(unsigned char *)(v830 + 88))
                                                    {
LABEL_1277:
                                                      if (*(_DWORD *)(v119 + 12) != 3
                                                        || (v127 & 0x10) == 0
                                                        || *(_DWORD *)(v119 + 92) - DWORD2(v914) <= 0
                                                        && DWORD2(v914) - *(_DWORD *)(v119 + 96) <= 0)
                                                      {
                                                        *(_DWORD *)(v119 + 88) |= 1u;
                                                        tcp_output(v119);
                                                        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v128 + 8) + 24))(v128, 1, v129);
                                                        *os_log_type_t v39 = v838 != 0;
                                                        uint64_t result = (void *)*v40;
                                                        if (!*v40) {
                                                          return result;
                                                        }
                                                        while (1)
                                                        {
                                                          v517 = (void (*)(void *, uint64_t, uint64_t))result[10];
                                                          v518 = (void *)result[4];
                                                          if (!v517) {
                                                            break;
                                                          }
                                                          uint64_t v519 = result[11];
                                                          result[10] = 0;
                                                          result[11] = 0;
                                                          v517(result, 1, v519);
LABEL_1284:
                                                          uint64_t result = v518;
                                                          if (!v518) {
                                                            return result;
                                                          }
                                                        }
                                                        __nwlog_obj();
                                                        *(_DWORD *)long long buf = 136446210;
                                                        v894 = "__nw_frame_finalize";
                                                        uint64_t v520 = _os_log_send_and_compose_impl();
                                                        type[0] = OS_LOG_TYPE_ERROR;
                                                        char v892 = 0;
                                                        v880 = (void *)v520;
                                                        if (__nwlog_fault())
                                                        {
                                                          if (type[0] == OS_LOG_TYPE_FAULT)
                                                          {
                                                            v862 = __nwlog_obj();
                                                            if (!os_log_type_enabled(v862, type[0])) {
                                                              goto LABEL_1300;
                                                            }
                                                            *(_DWORD *)long long buf = 136446210;
                                                            v894 = "__nw_frame_finalize";
                                                            v521 = v862;
                                                            os_log_type_t v522 = type[0];
                                                            v523 = "%{public}s called with null frame->finalizer";
                                                            goto LABEL_1299;
                                                          }
                                                          if (!v892)
                                                          {
                                                            v864 = __nwlog_obj();
                                                            if (!os_log_type_enabled(v864, type[0])) {
                                                              goto LABEL_1300;
                                                            }
                                                            *(_DWORD *)long long buf = 136446210;
                                                            v894 = "__nw_frame_finalize";
                                                            v521 = v864;
                                                            os_log_type_t v522 = type[0];
                                                            v523 = "%{public}s called with null frame->finalizer, backtra"
                                                                   "ce limit exceeded";
                                                            goto LABEL_1299;
                                                          }
                                                          v863 = (void *)__nw_create_backtrace_string();
                                                          loge = __nwlog_obj();
                                                          BOOL v524 = os_log_type_enabled(loge, type[0]);
                                                          if (v863)
                                                          {
                                                            if (v524)
                                                            {
                                                              *(_DWORD *)long long buf = 136446466;
                                                              v894 = "__nw_frame_finalize";
                                                              __int16 v895 = 2082;
                                                              *(void *)v896 = v863;
                                                              _os_log_impl(&dword_214653000, loge, type[0], "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
                                                            }
                                                            free(v863);
                                                            goto LABEL_1300;
                                                          }
                                                          if (v524)
                                                          {
                                                            *(_DWORD *)long long buf = 136446210;
                                                            v894 = "__nw_frame_finalize";
                                                            v521 = loge;
                                                            os_log_type_t v522 = type[0];
                                                            v523 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_1299:
                                                            _os_log_impl(&dword_214653000, v521, v522, v523, buf, 0xCu);
                                                          }
                                                        }
LABEL_1300:
                                                        if (v880) {
                                                          free(v880);
                                                        }
                                                        goto LABEL_1284;
                                                      }
LABEL_272:
                                                      if ((v127 & 4) == 0)
                                                      {
                                                        if ((v127 & 0x10) != 0)
                                                        {
                                                          unsigned int v134 = DWORD2(v914);
                                                          uint64_t v132 = v119;
                                                          uint64_t v133 = v12;
                                                          unsigned int v131 = 0;
                                                          char v135 = 4;
                                                        }
                                                        else
                                                        {
                                                          unsigned int v131 = v891 + ((v127 >> 1) & 1) + DWORD1(v914);
                                                          uint64_t v132 = v119;
                                                          uint64_t v133 = v12;
                                                          unsigned int v134 = 0;
                                                          char v135 = 20;
                                                        }
                                                        tcp_respond(v132, &v914, v133, v131, v134, v135, 0);
                                                        if (v130) {
                                                          soabort(v128);
                                                        }
                                                        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v128 + 8) + 24))(v128, 1, v129);
                                                        *os_log_type_t v39 = v838 != 0;
                                                        uint64_t result = (void *)*v40;
                                                        if (!*v40) {
                                                          return result;
                                                        }
                                                        while (1)
                                                        {
                                                          v140 = (void (*)(void *, uint64_t, uint64_t))result[10];
                                                          os_log_type_t v141 = (void *)result[4];
                                                          if (!v140) {
                                                            break;
                                                          }
                                                          uint64_t v142 = result[11];
                                                          result[10] = 0;
                                                          result[11] = 0;
                                                          v140(result, 1, v142);
LABEL_296:
                                                          uint64_t result = v141;
                                                          if (!v141) {
                                                            return result;
                                                          }
                                                        }
                                                        __nwlog_obj();
                                                        *(_DWORD *)long long buf = 136446210;
                                                        v894 = "__nw_frame_finalize";
                                                        uint64_t v143 = _os_log_send_and_compose_impl();
                                                        type[0] = OS_LOG_TYPE_ERROR;
                                                        char v892 = 0;
                                                        v876 = (void *)v143;
                                                        if (__nwlog_fault())
                                                        {
                                                          if (type[0] == OS_LOG_TYPE_FAULT)
                                                          {
                                                            v859 = __nwlog_obj();
                                                            if (!os_log_type_enabled(v859, type[0])) {
                                                              goto LABEL_312;
                                                            }
                                                            *(_DWORD *)long long buf = 136446210;
                                                            v894 = "__nw_frame_finalize";
                                                            v144 = v859;
                                                            os_log_type_t v145 = type[0];
                                                            int v146 = "%{public}s called with null frame->finalizer";
                                                            goto LABEL_311;
                                                          }
                                                          if (!v892)
                                                          {
                                                            v861 = __nwlog_obj();
                                                            if (!os_log_type_enabled(v861, type[0])) {
                                                              goto LABEL_312;
                                                            }
                                                            *(_DWORD *)long long buf = 136446210;
                                                            v894 = "__nw_frame_finalize";
                                                            v144 = v861;
                                                            os_log_type_t v145 = type[0];
                                                            int v146 = "%{public}s called with null frame->finalizer, backtra"
                                                                   "ce limit exceeded";
                                                            goto LABEL_311;
                                                          }
                                                          v860 = (void *)__nw_create_backtrace_string();
                                                          logd = __nwlog_obj();
                                                          BOOL v147 = os_log_type_enabled(logd, type[0]);
                                                          if (v860)
                                                          {
                                                            if (v147)
                                                            {
                                                              *(_DWORD *)long long buf = 136446466;
                                                              v894 = "__nw_frame_finalize";
                                                              __int16 v895 = 2082;
                                                              *(void *)v896 = v860;
                                                              _os_log_impl(&dword_214653000, logd, type[0], "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
                                                            }
                                                            free(v860);
                                                            goto LABEL_312;
                                                          }
                                                          if (v147)
                                                          {
                                                            *(_DWORD *)long long buf = 136446210;
                                                            v894 = "__nw_frame_finalize";
                                                            v144 = logd;
                                                            os_log_type_t v145 = type[0];
                                                            int v146 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_311:
                                                            _os_log_impl(&dword_214653000, v144, v145, v146, buf, 0xCu);
                                                          }
                                                        }
LABEL_312:
                                                        if (v876) {
                                                          free(v876);
                                                        }
                                                        goto LABEL_296;
                                                      }
                                                    }
LABEL_1310:
                                                    int v51 = v838;
LABEL_1311:
                                                    if (v130) {
                                                      soabort(v128);
                                                    }
                                                    goto LABEL_1313;
                                                  }
                                                }
                                                else
                                                {
                                                  int v514 = *(_DWORD *)(v830 + 12);
                                                  if ((v127 & 0x10) == 0) {
                                                    goto LABEL_1258;
                                                  }
                                                }
                                                unsigned int v834 = v127;
                                                int v832 = 0;
                                                if ((v514 - 4) < 7) {
                                                  goto LABEL_1266;
                                                }
                                                if (v514 != 3)
                                                {
                                                  int v404 = 0;
                                                  int v878 = 0;
LABEL_1383:
                                                  os_log_type_t v39 = a6;
                                                  LODWORD(v16) = v810;
                                                  a3 = v806;
LABEL_1165:
                                                  LOBYTE(v406) = v834;
                                                  goto LABEL_1166;
                                                }
                                                uint64_t v526 = *(void *)(v830 + 1056);
                                                if (v526) {
                                                  ++*(void *)(v526 + 408);
                                                }
                                                if ((~*(_DWORD *)(v830 + 88) & 0x60) == 0)
                                                {
                                                  char v527 = *(unsigned char *)(v830 + 263);
                                                  *(unsigned char *)(v830 + 260) = v527;
                                                  *(unsigned char *)(v830 + 261) = *(unsigned char *)(v830 + 262);
                                                  int v528 = HIWORD(v914) << v527;
                                                  *(_DWORD *)(v830 + 140) = v528;
                                                  unsigned int v816 = v528;
                                                  *(_DWORD *)(v830 + 252) = v528;
                                                  if (*(void *)(v842 + 24))
                                                  {
                                                    uint64_t v529 = nw_protocol_tcp_get_all_stats();
                                                    unsigned int v816 = *(_DWORD *)(v830 + 140);
                                                    if (v529)
                                                    {
                                                      *(_DWORD *)(v529 + 112) = v816;
                                                      unsigned int v816 = *(_DWORD *)(v830 + 140);
                                                    }
                                                  }
                                                }
                                                *(_DWORD *)(v830 + 168) = *(_DWORD *)(v828 + 316);
                                                tcp_sbrcv_tstmp_check(v830);
                                                if ((*(unsigned char *)(v830 + 89) & 8) != 0)
                                                {
                                                  *(_DWORD *)(v830 + 12) = 6;
                                                  if (!v842 || (*(unsigned char *)(v842 + 828) & 2) == 0)
                                                  {
                                                    if (__nwlog_is_datapath_logging_enabled())
                                                    {
                                                      v778 = __nwlog_tcp_log();
                                                      if (os_log_type_enabled(v778, OS_LOG_TYPE_DEBUG))
                                                      {
                                                        v779 = tcpstates[*(int *)(v830 + 12)];
                                                        v894 = "tcp_input";
                                                        v780 = "";
                                                        *(_DWORD *)long long buf = 136446722;
                                                        if (v842) {
                                                          v780 = (const char *)(v842 + 604);
                                                        }
                                                        __int16 v895 = 2082;
                                                        *(void *)v896 = v780;
                                                        *(_WORD *)&v896[8] = 2082;
                                                        *(void *)v897 = v779;
                                                        _os_log_impl(&dword_214653000, v778, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                                      }
                                                    }
                                                  }
                                                  if (*(void *)(v842 + 24))
                                                  {
                                                    uint64_t v548 = nw_protocol_tcp_get_all_stats();
                                                    if (v548) {
                                                      *(_DWORD *)(v548 + 136) = 6;
                                                    }
                                                  }
                                                  *(_DWORD *)(v830 + 88) &= ~0x800u;
                                                }
                                                else
                                                {
                                                  *(_DWORD *)(v830 + 12) = 4;
                                                  if (!v842 || (*(unsigned char *)(v842 + 828) & 2) == 0)
                                                  {
                                                    if (__nwlog_is_datapath_logging_enabled())
                                                    {
                                                      v775 = __nwlog_tcp_log();
                                                      if (os_log_type_enabled(v775, OS_LOG_TYPE_DEBUG))
                                                      {
                                                        v776 = tcpstates[*(int *)(v830 + 12)];
                                                        v894 = "tcp_input";
                                                        v777 = "";
                                                        *(_DWORD *)long long buf = 136446722;
                                                        if (v842) {
                                                          v777 = (const char *)(v842 + 604);
                                                        }
                                                        __int16 v895 = 2082;
                                                        *(void *)v896 = v777;
                                                        *(_WORD *)&v896[8] = 2082;
                                                        *(void *)v897 = v776;
                                                        _os_log_impl(&dword_214653000, v775, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                                      }
                                                    }
                                                  }
                                                  if (*(void *)(v842 + 24))
                                                  {
                                                    uint64_t v530 = nw_protocol_tcp_get_all_stats();
                                                    if (v530) {
                                                      *(_DWORD *)(v530 + 136) = 4;
                                                    }
                                                  }
                                                  int v531 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v830 + 80) + 224))
                                                                   + 316);
                                                  int v532 = *(_DWORD *)(v830 + 676);
                                                  if (!v532
                                                    || (*(unsigned char *)(*(void *)(*(void *)(v830 + 80) + 224) + 372) & 8) == 0)
                                                  {
                                                    int v532 = *(_DWORD *)(sysctls + 192);
                                                  }
                                                  *(_DWORD *)(v830 + 40) = v532 + v531 - *(_DWORD *)(v830 + 64);
                                                  if (*(void *)(v842 + 24))
                                                  {
                                                    uint64_t v533 = nw_protocol_tcp_get_all_stats();
                                                    if (v533) {
                                                      ++*(_DWORD *)(v533 + 64);
                                                    }
                                                  }
                                                }
                                                *(_WORD *)(v830 + 308) = 16;
                                                if (*(void *)v830)
                                                {
                                                  v768 = __nwlog_obj();
                                                  os_log_type_enabled(v768, OS_LOG_TYPE_ERROR);
                                                  *(_DWORD *)long long buf = 136446210;
                                                  v894 = "tcp_input";
                                                  v769 = (void *)_os_log_send_and_compose_impl();
                                                  if (__nwlog_abort()) {
                                                    goto LABEL_2107;
                                                  }
                                                  free(v769);
                                                }
                                                *(_DWORD *)(v830 + 104) = DWORD1(v914) - 1;
                                                int v549 = *(_DWORD *)(v830 + 740);
                                                if ((v549 & 0x10000000) == 0
                                                  && ((v549 & 0x8000000) != 0
                                                   || *(_DWORD *)(sysctls + 320) == 1
                                                   || tcp_do_acc_ecn == 1)
                                                  && (v834 & 0x12) == 0x10)
                                                {
                                                  int v550 = *(_DWORD *)(v830 + 348);
                                                  if ((v550 & 0x300000) == 0x300000)
                                                  {
                                                    if (v879 || HIBYTE(v888[0]))
                                                    {
                                                      if (!HIBYTE(v888[0]))
                                                      {
                                                        *(_DWORD *)(v830 + 420) = 5;
                                                        if (*(_DWORD *)(v830 + 364) == 5) {
                                                          *(_DWORD *)(v830 + 364) = 8;
                                                        }
                                                      }
                                                    }
                                                    else
                                                    {
                                                      switch(((v834 | (BYTE12(v914) << 8)) >> 6) & 7)
                                                      {
                                                        case 0u:
                                                          *(_DWORD *)(v830 + 348) = v550 & 0xFFDFFFF1;
                                                          if ((v550 & 0x200) != 0
                                                            && *(unsigned __int16 *)(v830 + 226) <= 2u
                                                            && (*(_DWORD *)(v830 + 364) & 0xFFFFFFFE) == 4)
                                                          {
                                                            *(_DWORD *)(v830 + 364) = 6;
                                                          }
                                                          if (*(_DWORD *)(v830 + 364) == 5)
                                                          {
                                                            int v663 = 7;
                                                            goto LABEL_1768;
                                                          }
                                                          break;
                                                        case 2u:
                                                          *(_DWORD *)(v830 + 420) = 5;
                                                          if (*(_DWORD *)(v830 + 364) == 5)
                                                          {
                                                            int v663 = 8;
                                                            goto LABEL_1768;
                                                          }
                                                          break;
                                                        case 3u:
                                                        case 4u:
                                                          *(_DWORD *)(v830 + 420) = 5;
                                                          goto LABEL_1764;
                                                        case 6u:
                                                          *(_DWORD *)(v830 + 420) = 6;
                                                          *(_DWORD *)(v830 + 144) = 2 * *(_DWORD *)(v830 + 196);
LABEL_1764:
                                                          if (*(_DWORD *)(v830 + 364) == 5)
                                                          {
                                                            int v663 = 9;
LABEL_1768:
                                                            *(_DWORD *)(v830 + 364) = v663;
                                                          }
                                                          break;
                                                        default:
                                                          *(_DWORD *)(v830 + 420) = 5;
                                                          break;
                                                      }
                                                      if (v888[0])
                                                      {
                                                        if (DWORD2(v888[0]))
                                                        {
                                                          int v664 = *(_DWORD *)(v830 + 400);
                                                          if (!v664 || ((DWORD2(v888[0]) - v664) & 0x80000000) == 0) {
                                                            *(_DWORD *)(v830 + 400) = DWORD2(v888[0]);
                                                          }
                                                        }
                                                      }
                                                    }
                                                    tcp_input_ip_ecn(v830, v806, v879, v818, v855);
                                                  }
                                                }
                                                char v665 = *(unsigned char *)(v830 + 988);
                                                if ((v665 & 2) == 0)
                                                {
                                                  int v832 = 1;
                                                  goto LABEL_1779;
                                                }
                                                atomic_fetch_add_explicit(&tcp_tfo_halfcnt, 0xFFFFFFFF, memory_order_relaxed);
                                                if ((tcp_tfo_halfcnt & 0x80000000) == 0)
                                                {
LABEL_1778:
                                                  int v832 = 0;
                                                  *(unsigned char *)(v830 + 988) = v665 & 0xFD;
LABEL_1779:
                                                  if (*(_DWORD *)(v842 + 384))
                                                  {
                                                    int v666 = *(_DWORD *)(v830 + 92) + 1;
                                                    *(_DWORD *)(v830 + 92) = v666;
                                                    if (*(void *)(v842 + 24))
                                                    {
                                                      uint64_t v667 = nw_protocol_tcp_get_all_stats();
                                                      int v666 = *(_DWORD *)(v830 + 92);
                                                      if (v667)
                                                      {
                                                        *(_DWORD *)(v667 + 108) = *(_DWORD *)(v830 + 96) - v666;
                                                        int v666 = *(_DWORD *)(v830 + 92);
                                                      }
                                                    }
                                                    if (*(_DWORD *)(v830 + 100) - v666 < 0) {
                                                      *(_DWORD *)(v830 + 100) = v666;
                                                    }
                                                    if ((*(unsigned char *)(v830 + 740) & 0x20) != 0
                                                      && (HIBYTE(v888[0]) || *(void *)(v830 + 544)))
                                                    {
                                                      tcp_sack_doack(v830, (uint64_t)v888, SDWORD2(v914), (_DWORD *)&v890 + 1, &v890);
                                                    }
                                                    goto LABEL_1789;
                                                  }
LABEL_1266:
                                                  if (DWORD2(v914) - *(_DWORD *)(v830 + 96) >= 1)
                                                  {
                                                    uint64_t v515 = *(void *)(v830 + 1056);
                                                    if (v515) {
                                                      ++*(void *)(v515 + 184);
                                                    }
LABEL_1309:
                                                    unsigned int v40 = v885;
                                                    os_log_type_t v39 = a6;
                                                    uint64_t v128 = v842;
                                                    uint64_t v129 = v813;
                                                    int v130 = v839;
                                                    unsigned int v127 = v834;
                                                    if (!tcp_is_ack_ratelimited(v830)) {
                                                      goto LABEL_1277;
                                                    }
                                                    goto LABEL_1310;
                                                  }
                                                  if (DWORD2(v914) - *(_DWORD *)(v830 + 92) + *(_DWORD *)(v830 + 252) < 0) {
                                                    goto LABEL_1309;
                                                  }
                                                  char v525 = 1;
                                                  if ((*(unsigned char *)(v830 + 740) & 0x20) != 0)
                                                  {
                                                    if (HIBYTE(v888[0]))
                                                    {
                                                      if (tcp_sack_process_dsack(v830, (uint64_t)v888, (uint64_t)&v914, &v887))
                                                      {
                                                        char v525 = 0;
                                                        if (DWORD2(v914) - *(_DWORD *)(v830 + 92) <= 0
                                                          && !HIBYTE(v888[0]))
                                                        {
                                                          tcp_bad_rexmt_check(v830, (uint64_t)&v914, (uint64_t)v888);
                                                          goto LABEL_1270;
                                                        }
                                                      }
                                                    }
                                                  }
                                                  int v534 = *(_DWORD *)(v830 + 740);
                                                  if ((v534 & 0x20) != 0
                                                    && (HIBYTE(v888[0]) || *(void *)(v830 + 544)))
                                                  {
                                                    tcp_sack_doack(v830, (uint64_t)v888, SDWORD2(v914), (_DWORD *)&v890 + 1, &v890);
                                                    int v534 = *(_DWORD *)(v830 + 740);
                                                  }
                                                  if ((v534 & 0x20400020) == 0x20000020)
                                                  {
                                                    if (v887) {
                                                      char v535 = 1;
                                                    }
                                                    else {
                                                      char v535 = v525;
                                                    }
                                                    if ((v535 & 1) == 0) {
                                                      *(unsigned char *)(v830 + 2069) |= 0x40u;
                                                    }
                                                    tcp_rack_update_reordering_window(v830, SDWORD2(v914));
                                                  }
                                                  tcp_tfo_rcv_ack(v830, (uint64_t)&v914);
                                                  if (DWORD2(v914) - *(_DWORD *)(v830 + 92) > 0)
                                                  {
                                                    int v536 = *(_DWORD *)(v830 + 88);
                                                    if ((v536 & 0x200000) != 0)
                                                    {
                                                      if (DWORD2(v914) - *(_DWORD *)(v830 + 152) >= 0)
                                                      {
                                                        BOOL v403 = *(_DWORD *)(sysctls + 276) != 0;
                                                        *(_DWORD *)(v830 + 88) = v536 & 0xFFDFFFFF;
                                                        *(_DWORD *)(v830 + 8) = 0;
                                                        *(unsigned char *)(v830 + 310) = 3;
                                                        *(_DWORD *)(v830 + 288) = 0;
                                                        *(_DWORD *)(v830 + 348) &= ~0x20u;
                                                        *(_DWORD *)(v830 + 16) = 0;
                                                        unsigned int v551 = *(_DWORD *)(v830 + 740) & 0xFFF7FFFF;
                                                        *(_DWORD *)(v830 + 740) = v551;
                                                        *(_DWORD *)(v830 + 984) = 0;
                                                        *(_DWORD *)(v830 + 628) = 0;
                                                        v552 = *(void (**)(uint64_t, long long *))(tcp_cc_algo_list[*(unsigned __int8 *)(v830 + 264)] + 72);
                                                        if (v552)
                                                        {
                                                          v552(v830, &v914);
                                                          unsigned int v551 = *(_DWORD *)(v830 + 740);
                                                        }
                                                        if ((v551 & 0x20400020) == 0x20000020
                                                          && (*(unsigned char *)(v830 + 2069) & 0x1F) != 0)
                                                        {
                                                          *(unsigned char *)(v830 + 2069) = *(unsigned char *)(v830 + 2069) & 0xE0 | (*(unsigned char *)(v830 + 2069) - 1) & 0x1F;
                                                        }
                                                        *(_DWORD *)(v830 + 972) = 0;
                                                        *(void *)(v830 + 964) = 0;
                                                        *(unsigned char *)(v830 + 751) = 0;
                                                        *(void *)(v830 + 980) = 0;
                                                        goto LABEL_1790;
                                                      }
                                                      if ((*(unsigned char *)(v830 + 348) & 0x20) == 0)
                                                      {
                                                        int v558 = *(_DWORD *)(v830 + 740);
                                                        if ((v558 & 0x20400020) != 0x20000020)
                                                        {
                                                          if ((v558 & 0x20) != 0) {
                                                            tcp_sack_partialack(v830, (uint64_t)&v914);
                                                          }
                                                          else {
                                                            tcp_newreno_partial_ack((_DWORD *)v830, (uint64_t)&v914);
                                                          }
                                                        }
                                                      }
                                                    }
                                                    else
                                                    {
                                                      int v537 = *(_DWORD *)(v830 + 740);
                                                      if ((~v537 & 0x6000) != 0)
                                                      {
                                                        BOOL v403 = 0;
                                                        *(_DWORD *)(v830 + 8) = 0;
                                                        *(unsigned char *)(v830 + 310) = 3;
                                                        goto LABEL_1790;
                                                      }
                                                      if (DWORD2(v914) - *(_DWORD *)(v830 + 152) >= 0
                                                        || !*(void *)(v830 + 544))
                                                      {
                                                        BOOL v403 = 0;
                                                        *(_DWORD *)(v830 + 88) = v536 & 0xFFDFFFFF;
                                                        *(unsigned char *)(v830 + 310) = 3;
                                                        *(_DWORD *)(v830 + 348) &= ~0x20u;
                                                        *(_DWORD *)(v830 + 8) = 0;
                                                        *(_DWORD *)(v830 + 288) = 0;
                                                        *(void *)(v830 + 16) = 0;
                                                        *(_DWORD *)(v830 + 740) = v537 & 0xFFF7BFFF;
                                                        *(_DWORD *)(v830 + 984) = 0;
                                                        *(_DWORD *)(v830 + 628) = 0;
LABEL_1790:
                                                        v222 = v885;
                                                        os_log_type_t v39 = a6;
                                                        LODWORD(v16) = v810;
                                                        a3 = v806;
                                                        unsigned int v406 = v834;
                                                        int v367 = v879;
                                                        goto LABEL_987;
                                                      }
                                                    }
LABEL_1789:
                                                    BOOL v403 = 0;
                                                    goto LABEL_1790;
                                                  }
                                                  int v545 = *(_DWORD *)(v830 + 740);
                                                  if ((~v545 & 0x20000020) == 0
                                                    && (v545 & 0x400000) == 0
                                                    && HIDWORD(v890)
                                                    && *(_DWORD *)(v830 + 560) - (int)v890 < 0)
                                                  {
                                                    *(_DWORD *)(v830 + 560) = v890;
                                                  }
                                                  if ((v545 & 0x10000000) == 0
                                                    && ((v545 & 0x8000000) != 0
                                                     || *(_DWORD *)(sysctls + 320) == 1
                                                     || tcp_do_acc_ecn == 1))
                                                  {
                                                    int v546 = *(_DWORD *)(v830 + 348);
                                                    if ((~v546 & 0x300000) == 0 && (v546 & 4) != 0 && !HIDWORD(v890))
                                                    {
                                                      ++*(_DWORD *)(v830 + 296);
                                                      if ((v888[0] & 1) != 0
                                                        && DWORD2(v888[0])
                                                        && DWORD2(v888[0]) - *(_DWORD *)(v830 + 400) >= 1)
                                                      {
                                                        tcp_process_accecn(v830, (uint64_t)v888, (uint64_t)&v914, 1u, v814);
                                                      }
                                                    }
                                                  }
                                                  if (v879)
                                                  {
                                                    int v404 = 0;
                                                    int v878 = 0;
                                                    goto LABEL_1383;
                                                  }
                                                  if (v816 != *(_DWORD *)(v830 + 140))
                                                  {
                                                    int v404 = 0;
                                                    if (!HIBYTE(v888[0]) || !HIDWORD(v890))
                                                    {
                                                      int v878 = 0;
                                                      goto LABEL_1383;
                                                    }
                                                  }
                                                  if (v834)
                                                  {
                                                    int v827 = 0;
                                                    int v404 = 0;
                                                    int v878 = 0;
                                                    os_log_type_t v39 = a6;
                                                    LODWORD(v16) = v810;
                                                    a3 = v806;
                                                    LOBYTE(v406) = v834;
                                                    if (*(int *)(v830 + 12) < 10)
                                                    {
LABEL_1166:
                                                      int v836 = v891;
                                                      char updated = tcp_update_window(v119, v406, (uint64_t)&v914, v816, v891);
                                                      char v478 = v406;
                                                      if ((v406 & 0x20) == 0 || !v915 || *(int *)(v119 + 12) > 9)
                                                      {
                                                        int v479 = *(_DWORD *)(v119 + 120);
                                                        uint64_t v128 = v842;
                                                        uint64_t v129 = v813;
                                                        if (v479 - *(_DWORD *)(v119 + 136) >= 1) {
                                                          *(_DWORD *)(v119 + 136) = v479;
                                                        }
LABEL_1177:
                                                        if (v832)
                                                        {
                                                          soisconnected(v128);
                                                          if (v821) {
                                                            unsigned char *v821 = 1;
                                                          }
                                                        }
                                                        else if (v404)
                                                        {
                                                          *(_WORD *)(v128 + 376) = *(_WORD *)(v128 + 376) & 0xDFC1 | 0x2030;
                                                          uint64_t v480 = *(void *)(v128 + 32);
                                                          if (v480)
                                                          {
                                                            v481 = *(void (**)(uint64_t))(v480 + 56);
                                                            if (v481) {
                                                              v481(v128);
                                                            }
                                                          }
                                                        }
                                                        if (*(_DWORD *)(a3 + 232) == 3)
                                                        {
                                                          unsigned int v40 = v885;
                                                          goto LABEL_1186;
                                                        }
                                                        if (!(v836 | v478 & 1)
                                                          || (int v482 = *(_DWORD *)(v119 + 12), v482 > 9))
                                                        {
                                                          char v487 = 0;
                                                          v488 = v885;
                                                          goto LABEL_1588;
                                                        }
                                                        int v808 = v17;
                                                        int v812 = v16;
                                                        uint64_t v813 = v129;
                                                        if (v482 <= 3
                                                          && (v482 != 3 || (*(unsigned char *)(v119 + 988) & 2) == 0))
                                                        {
                                                          char v487 = 0;
LABEL_1587:
                                                          v488 = v885;
                                                          os_log_type_t v39 = a6;
LABEL_1588:
                                                          int v609 = *(_DWORD *)(v119 + 740);
                                                          if ((v609 & 0x10000000) == 0
                                                            && ((v609 & 0x8000000) != 0
                                                             || *(_DWORD *)(sysctls + 320) == 1
                                                             || tcp_do_acc_ecn == 1)
                                                            && (~*(_DWORD *)(v119 + 348) & 0x300000) == 0
                                                            && (*(_DWORD *)(v119 + 12) - 4) <= 5)
                                                          {
                                                            unsigned __int16 v610 = *(_WORD *)(v119 + 306);
                                                            if (v817
                                                              && (v610 += v818,
                                                                  *(_WORD *)(v119 + 306) = v610,
                                                                  *(_DWORD *)(v119 + 408) != 3)
                                                              || v610 >= 2u
                                                              && (v610 != 2
                                                               || *(_DWORD *)(v119 + 284) != *(_DWORD *)(v119 + 120)))
                                                            {
                                                              *(_DWORD *)(v119 + 88) |= 1u;
                                                            }
                                                            *(_DWORD *)(v119 + 408) = v855;
                                                            v488 = v885;
                                                          }
                                                          if (v487)
                                                          {
                                                            int v620 = *(_DWORD *)(v119 + 12);
                                                            if (v620 <= 9)
                                                            {
                                                              *(_WORD *)(v842 + 376) |= 0x20u;
                                                              uint64_t v621 = *(void *)(v842 + 32);
                                                              if (v621)
                                                              {
                                                                v622 = *(void (**)(uint64_t, uint64_t))(v621 + 40);
                                                                if (v622)
                                                                {
                                                                  v622(v842, v477);
                                                                  int v620 = *(_DWORD *)(v119 + 12);
                                                                }
                                                              }
                                                              *(_WORD *)(v119 + 304) += v818;
                                                              *(_DWORD *)(v119 + 88) |= 1u;
                                                              ++*(_DWORD *)(v119 + 120);
                                                              v488 = v885;
                                                            }
                                                            switch(v620)
                                                            {
                                                              case 3:
                                                                *(_DWORD *)(v119 + 168) = *(_DWORD *)(v828 + 316);
                                                                goto LABEL_1635;
                                                              case 4:
LABEL_1635:
                                                                *(_DWORD *)(v119 + 12) = 5;
                                                                if (!v842 || (*(unsigned char *)(v842 + 828) & 2) == 0)
                                                                {
                                                                  if (__nwlog_is_datapath_logging_enabled())
                                                                  {
                                                                    v711 = __nwlog_tcp_log();
                                                                    if (os_log_type_enabled(v711, OS_LOG_TYPE_DEBUG))
                                                                    {
                                                                      v712 = tcpstates[*(int *)(v119 + 12)];
                                                                      v894 = "tcp_input";
                                                                      v713 = "";
                                                                      *(_DWORD *)long long buf = 136446722;
                                                                      if (v842) {
                                                                        v713 = (const char *)(v842 + 604);
                                                                      }
                                                                      __int16 v895 = 2082;
                                                                      *(void *)v896 = v713;
                                                                      *(_WORD *)&v896[8] = 2082;
                                                                      *(void *)v897 = v712;
                                                                      _os_log_impl(&dword_214653000, v711, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                                                    }
                                                                  }
                                                                }
                                                                v488 = v885;
                                                                if (*(void *)(v842 + 24))
                                                                {
                                                                  uint64_t v623 = nw_protocol_tcp_get_all_stats();
                                                                  if (v623) {
                                                                    *(_DWORD *)(v623 + 136) = 5;
                                                                  }
                                                                }
                                                                break;
                                                              case 6:
                                                                *(_DWORD *)(v119 + 12) = 7;
                                                                if (!v842 || (*(unsigned char *)(v842 + 828) & 2) == 0)
                                                                {
                                                                  if (__nwlog_is_datapath_logging_enabled())
                                                                  {
                                                                    v747 = __nwlog_tcp_log();
                                                                    if (os_log_type_enabled(v747, OS_LOG_TYPE_DEBUG))
                                                                    {
                                                                      v748 = tcpstates[*(int *)(v119 + 12)];
                                                                      v894 = "tcp_input";
                                                                      v749 = "";
                                                                      *(_DWORD *)long long buf = 136446722;
                                                                      if (v842) {
                                                                        v749 = (const char *)(v842 + 604);
                                                                      }
                                                                      __int16 v895 = 2082;
                                                                      *(void *)v896 = v749;
                                                                      *(_WORD *)&v896[8] = 2082;
                                                                      *(void *)v897 = v748;
                                                                      _os_log_impl(&dword_214653000, v747, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                                                    }
                                                                  }
                                                                }
                                                                v488 = v885;
                                                                if (*(void *)(v842 + 24))
                                                                {
                                                                  uint64_t v624 = nw_protocol_tcp_get_all_stats();
                                                                  if (v624) {
                                                                    *(_DWORD *)(v624 + 136) = 7;
                                                                  }
                                                                }
                                                                break;
                                                              case 9:
                                                                *(_DWORD *)(v119 + 12) = 10;
                                                                if (!v842 || (*(unsigned char *)(v842 + 828) & 2) == 0)
                                                                {
                                                                  if (__nwlog_is_datapath_logging_enabled())
                                                                  {
                                                                    v750 = __nwlog_tcp_log();
                                                                    if (os_log_type_enabled(v750, OS_LOG_TYPE_DEBUG))
                                                                    {
                                                                      v751 = tcpstates[*(int *)(v119 + 12)];
                                                                      v894 = "tcp_input";
                                                                      v752 = "";
                                                                      *(_DWORD *)long long buf = 136446722;
                                                                      if (v842) {
                                                                        v752 = (const char *)(v842 + 604);
                                                                      }
                                                                      __int16 v895 = 2082;
                                                                      *(void *)v896 = v752;
                                                                      *(_WORD *)&v896[8] = 2082;
                                                                      *(void *)v897 = v751;
                                                                      _os_log_impl(&dword_214653000, v750, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
                                                                    }
                                                                  }
                                                                }
                                                                if (*(void *)(v842 + 24))
                                                                {
                                                                  uint64_t v625 = nw_protocol_tcp_get_all_stats();
                                                                  if (v625) {
                                                                    *(_DWORD *)(v625 + 136) = 10;
                                                                  }
                                                                }
                                                                tcp_canceltimers(v119);
                                                                int v626 = *(_DWORD *)(v119 + 88);
                                                                *(_DWORD *)(v119 + 88) = v626 | 1;
                                                                if ((*(unsigned char *)(v119 + 741) & 8) != 0) {
                                                                  *(_DWORD *)(v119 + 88) = v626 | 0x8000001;
                                                                }
                                                                else {
                                                                  add_to_time_wait(v119, 2 * *(_DWORD *)(sysctls + 204));
                                                                }
                                                                *(_WORD *)(v842 + 376) = *(_WORD *)(v842 + 376) & 0xDFC1 | 0x2030;
                                                                uint64_t v627 = *(void *)(v842 + 32);
                                                                v488 = v885;
                                                                if (v627)
                                                                {
                                                                  v628 = *(void (**)(uint64_t))(v627 + 56);
                                                                  if (v628) {
                                                                    v628(v842);
                                                                  }
                                                                }
                                                                break;
                                                              case 10:
                                                                add_to_time_wait(v119, 2 * *(_DWORD *)(sysctls + 204));
                                                                break;
                                                              default:
                                                                break;
                                                            }
                                                          }
                                                          char v611 = updated;
                                                          if (v878) {
                                                            char v611 = 1;
                                                          }
                                                          if (v611 & 1) != 0 || (*(unsigned char *)(v119 + 88)) {
                                                            tcp_output(v119);
                                                          }
                                                          tcp_check_timer_state(v119);
                                                          (*(void (**)(uint64_t, uint64_t))(*(void *)(v842 + 8) + 24))(v842, 1);
                                                          *os_log_type_t v39 = v838 != 0;
                                                          uint64_t result = (void *)*v488;
                                                          if (!*v488) {
                                                            return result;
                                                          }
                                                          while (1)
                                                          {
                                                            v612 = (void (*)(void *, uint64_t, uint64_t))result[10];
                                                            v613 = (void *)result[4];
                                                            if (!v612) {
                                                              break;
                                                            }
                                                            uint64_t v614 = result[11];
                                                            result[10] = 0;
                                                            result[11] = 0;
                                                            v612(result, 1, v614);
LABEL_1610:
                                                            uint64_t result = v613;
                                                            if (!v613) {
                                                              return result;
                                                            }
                                                          }
                                                          __nwlog_obj();
                                                          *(_DWORD *)long long buf = 136446210;
                                                          v894 = "__nw_frame_finalize";
                                                          uint64_t v615 = _os_log_send_and_compose_impl();
                                                          type[0] = OS_LOG_TYPE_ERROR;
                                                          char v892 = 0;
                                                          v881 = (void *)v615;
                                                          if (__nwlog_fault())
                                                          {
                                                            if (type[0] == OS_LOG_TYPE_FAULT)
                                                            {
                                                              v865 = __nwlog_obj();
                                                              os_log_type_t logf = type[0];
                                                              if (!os_log_type_enabled(v865, type[0])) {
                                                                goto LABEL_1626;
                                                              }
                                                              *(_DWORD *)long long buf = 136446210;
                                                              v894 = "__nw_frame_finalize";
                                                              v616 = v865;
                                                              os_log_type_t v617 = logf;
                                                              v618 = "%{public}s called with null frame->finalizer";
                                                              goto LABEL_1625;
                                                            }
                                                            if (!v892)
                                                            {
                                                              v867 = __nwlog_obj();
                                                              os_log_type_t logh = type[0];
                                                              if (!os_log_type_enabled(v867, type[0])) {
                                                                goto LABEL_1626;
                                                              }
                                                              *(_DWORD *)long long buf = 136446210;
                                                              v894 = "__nw_frame_finalize";
                                                              v616 = v867;
                                                              os_log_type_t v617 = logh;
                                                              v618 = "%{public}s called with null frame->finalizer, backt"
                                                                     "race limit exceeded";
                                                              goto LABEL_1625;
                                                            }
                                                            v866 = (void *)__nw_create_backtrace_string();
                                                            logg = __nwlog_obj();
                                                            os_log_type_t v843 = type[0];
                                                            BOOL v619 = os_log_type_enabled(logg, type[0]);
                                                            if (v866)
                                                            {
                                                              if (v619)
                                                              {
                                                                *(_DWORD *)long long buf = 136446466;
                                                                v894 = "__nw_frame_finalize";
                                                                __int16 v895 = 2082;
                                                                *(void *)v896 = v866;
                                                                _os_log_impl(&dword_214653000, logg, v843, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
                                                              }
                                                              free(v866);
                                                              goto LABEL_1626;
                                                            }
                                                            if (v619)
                                                            {
                                                              *(_DWORD *)long long buf = 136446210;
                                                              v894 = "__nw_frame_finalize";
                                                              v616 = logg;
                                                              os_log_type_t v617 = v843;
                                                              v618 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_1625:
                                                              _os_log_impl(&dword_214653000, v616, v617, v618, buf, 0xCu);
                                                            }
                                                          }
LABEL_1626:
                                                          if (v881) {
                                                            free(v881);
                                                          }
                                                          goto LABEL_1610;
                                                        }
                                                        int v483 = DWORD1(v914);
                                                        int v484 = DWORD1(v914) + v836;
                                                        if (DWORD1(v914) != *(_DWORD *)(v119 + 120) || *(void *)v119)
                                                        {
                                                          *(_DWORD *)os_log_type_t type = 0;
                                                          if (*(_DWORD *)(v119 + 1916) - v484 < 0)
                                                          {
                                                            *(_DWORD *)(v119 + 1916) = v484;
                                                            if (v888[0]) {
                                                              *(_DWORD *)(v119 + 1920) = DWORD1(v888[0]);
                                                            }
                                                          }
                                                          tcp_compute_rcv_rtt(v119, (uint64_t)v888, (uint64_t)&v914);
                                                          uint64_t v485 = sysctls;
                                                          if (*(_DWORD *)(sysctls + 260))
                                                          {
                                                            tcp_sbrcv_grow(v830, v842 + 488, (uint64_t)v888, v836);
                                                            uint64_t v485 = sysctls;
                                                          }
                                                          if (*(_DWORD *)(v485 + 308) == 1
                                                            && (~*(_DWORD *)(v830 + 88) & 0x180) == 0
                                                            && (*(_DWORD *)(v485 + 40) == 1
                                                             || (*(unsigned char *)(v842 + 369) & 0x40) != 0)
                                                            && off_26AA46360)
                                                          {
                                                            off_26AA46360(v830, (uint64_t)&v914, (uint64_t)v888, v836);
                                                          }
                                                          char v486 = tcp_reass(v830, &v891, v885, v822, v837, a4, type);
                                                          if (*(_DWORD *)type)
                                                          {
                                                            if ((*(_WORD *)(v12 + 204) & 0x100) != 0
                                                              && *MEMORY[0x263F144B8]
                                                              && (((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(v12, *(void *)(v12 + 88)) & 1) == 0)
                                                            {
                                                              if (!v842 || (*(unsigned char *)(v842 + 828) & 2) == 0)
                                                              {
                                                                v714 = __nwlog_tcp_log();
                                                                if (os_log_type_enabled(v714, OS_LOG_TYPE_INFO))
                                                                {
                                                                  v715 = "";
                                                                  if (v842) {
                                                                    v715 = (const char *)(v842 + 604);
                                                                  }
                                                                  *(_DWORD *)long long buf = 136446466;
                                                                  v894 = "tcp_input";
                                                                  __int16 v895 = 2082;
                                                                  *(void *)v896 = v715;
                                                                  _os_log_impl(&dword_214653000, v714, OS_LOG_TYPE_INFO, "%{public}s %{public}s frame no longer valid", buf, 0x16u);
                                                                }
                                                              }
                                                              *(void *)(v830 + 1056) = 0;
                                                            }
                                                            int v51 = 0;
                                                            unsigned int v40 = v885;
                                                            os_log_type_t v39 = a6;
                                                            uint64_t v128 = v842;
                                                            goto LABEL_1272;
                                                          }
                                                          char v487 = v486;
                                                          *(_DWORD *)(v830 + 88) |= 1u;
                                                          int v836 = v891;
                                                          if (v891 > 0)
                                                          {
                                                            int v838 = 0;
                                                            goto LABEL_1582;
                                                          }
                                                          int v838 = 0;
                                                          char v489 = BYTE13(v914);
LABEL_1211:
                                                          if ((v489 & 1) == 0)
                                                          {
                                                            uint64_t v119 = v830;
                                                            tcp_adaptive_rwtimo_check(v830, v836);
                                                            goto LABEL_1587;
                                                          }
LABEL_1582:
                                                          if ((*(unsigned char *)(v830 + 740) & 0x20) != 0) {
                                                            tcp_update_sack_list((_DWORD *)v830, v483, v484 + (BYTE13(v914) & 1));
                                                          }
                                                          uint64_t v119 = v830;
                                                          tcp_adaptive_rwtimo_check(v830, v836);
                                                          if (v836 >= 1 && *(unsigned char *)(v830 + 993)) {
                                                            *(unsigned char *)(v830 + 993) = 0;
                                                          }
                                                          goto LABEL_1587;
                                                        }
                                                        uint64_t v490 = *v885;
                                                        if (*v885)
                                                        {
                                                          if ((*(_WORD *)(v490 + 204) & 0x80) != 0)
                                                          {
                                                            unsigned int v491 = *(unsigned __int16 *)(v490 + 196);
                                                            if (v837 > v491)
                                                            {
                                                              __nwlog_obj();
                                                              int v492 = *(unsigned __int16 *)(v490 + 196);
                                                              *(_DWORD *)long long buf = 136446722;
                                                              v894 = "__nw_frame_array_claim";
                                                              __int16 v895 = 1024;
                                                              *(_DWORD *)v896 = v492;
                                                              *(_WORD *)&v896[4] = 1024;
                                                              *(_DWORD *)&v896[6] = v837;
                                                              v493 = (void *)_os_log_send_and_compose_impl();
                                                              type[0] = OS_LOG_TYPE_ERROR;
                                                              char v892 = 0;
                                                              if (__nwlog_fault())
                                                              {
                                                                if (type[0] == OS_LOG_TYPE_FAULT)
                                                                {
                                                                  v494 = __nwlog_obj();
                                                                  os_log_type_t v495 = type[0];
                                                                  if (os_log_type_enabled(v494, type[0]))
                                                                  {
                                                                    int v496 = *(unsigned __int16 *)(v490 + 196);
                                                                    *(_DWORD *)long long buf = 136446722;
                                                                    v894 = "__nw_frame_array_claim";
                                                                    __int16 v895 = 1024;
                                                                    *(_DWORD *)v896 = v496;
                                                                    *(_WORD *)&v896[4] = 1024;
                                                                    *(_DWORD *)&v896[6] = v837;
                                                                    v497 = "%{public}s Aggregate buffer length: %u sum: %u";
LABEL_1526:
                                                                    v588 = v494;
                                                                    os_log_type_t v589 = v495;
LABEL_1527:
                                                                    _os_log_impl(&dword_214653000, v588, v589, v497, buf, 0x18u);
                                                                  }
                                                                }
                                                                else if (v892)
                                                                {
                                                                  v569 = (void *)__nw_create_backtrace_string();
                                                                  v570 = __nwlog_obj();
                                                                  BOOL v571 = os_log_type_enabled(v570, type[0]);
                                                                  if (v569)
                                                                  {
                                                                    if (v571)
                                                                    {
                                                                      int v572 = *(unsigned __int16 *)(v490 + 196);
                                                                      *(_DWORD *)long long buf = 136446978;
                                                                      v894 = "__nw_frame_array_claim";
                                                                      __int16 v895 = 1024;
                                                                      *(_DWORD *)v896 = v572;
                                                                      *(_WORD *)&v896[4] = 1024;
                                                                      *(_DWORD *)&v896[6] = v837;
                                                                      *(_WORD *)v897 = 2082;
                                                                      *(void *)&v897[2] = v569;
                                                                      _os_log_impl(&dword_214653000, v570, type[0], "%{public}s Aggregate buffer length: %u sum: %u, dumping backtrace:%{public}s", buf, 0x22u);
                                                                    }
                                                                    free(v569);
                                                                    goto LABEL_1528;
                                                                  }
                                                                  if (v571)
                                                                  {
                                                                    int v632 = *(unsigned __int16 *)(v490 + 196);
                                                                    *(_DWORD *)long long buf = 136446722;
                                                                    v894 = "__nw_frame_array_claim";
                                                                    __int16 v895 = 1024;
                                                                    *(_DWORD *)v896 = v632;
                                                                    *(_WORD *)&v896[4] = 1024;
                                                                    *(_DWORD *)&v896[6] = v837;
                                                                    v497 = "%{public}s Aggregate buffer length: %u sum: %u, no backtrace";
                                                                    v588 = v570;
                                                                    os_log_type_t v589 = type[0];
                                                                    goto LABEL_1527;
                                                                  }
                                                                }
                                                                else
                                                                {
                                                                  v494 = __nwlog_obj();
                                                                  os_log_type_t v495 = type[0];
                                                                  if (os_log_type_enabled(v494, type[0]))
                                                                  {
                                                                    int v587 = *(unsigned __int16 *)(v490 + 196);
                                                                    *(_DWORD *)long long buf = 136446722;
                                                                    v894 = "__nw_frame_array_claim";
                                                                    __int16 v895 = 1024;
                                                                    *(_DWORD *)v896 = v587;
                                                                    *(_WORD *)&v896[4] = 1024;
                                                                    *(_DWORD *)&v896[6] = v837;
                                                                    v497 = "%{public}s Aggregate buffer length: %u sum: %"
                                                                           "u, backtrace limit exceeded";
                                                                    goto LABEL_1526;
                                                                  }
                                                                }
                                                              }
LABEL_1528:
                                                              if (v493) {
                                                                free(v493);
                                                              }
                                                              *(_WORD *)(v490 + 196) = 0;
LABEL_1531:
                                                              uint64_t v590 = *v885;
                                                              if (*v885)
                                                              {
                                                                unsigned int v591 = 0;
                                                                while (1)
                                                                {
                                                                  int v592 = *(_DWORD *)(v590 + 52);
                                                                  int v593 = *(_DWORD *)(v590 + 56);
                                                                  int v594 = *(_DWORD *)(v590 + 60);
                                                                  unsigned int v595 = v592 - (v593 + v594);
                                                                  if (v595 >= v837 - v591) {
                                                                    unsigned int v595 = v837 - v591;
                                                                  }
                                                                  unsigned int v596 = v592 ? v595 : 0;
                                                                  int v597 = v593 + v596;
                                                                  if (v593 + v596 <= v592 - v594)
                                                                  {
                                                                    *(_DWORD *)(v590 + 56) = v597;
                                                                    *(_DWORD *)(v590 + 60) = v594;
                                                                  }
                                                                  else
                                                                  {
                                                                    v598 = __nwlog_obj();
                                                                    if (os_log_type_enabled(v598, OS_LOG_TYPE_ERROR))
                                                                    {
                                                                      int v599 = *(_DWORD *)(v590 + 52);
                                                                      *(_DWORD *)long long buf = 136446978;
                                                                      v894 = "__nw_frame_claim_internal";
                                                                      __int16 v895 = 1024;
                                                                      *(_DWORD *)v896 = v597;
                                                                      *(_WORD *)&v896[4] = 1024;
                                                                      *(_DWORD *)&v896[6] = v599;
                                                                      *(_WORD *)v897 = 1024;
                                                                      *(_DWORD *)&v897[2] = v594;
                                                                      _os_log_impl(&dword_214653000, v598, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
                                                                    }
                                                                  }
                                                                  v591 += v596;
                                                                  if (v591 == v837) {
                                                                    break;
                                                                  }
                                                                  if (v591 < v837)
                                                                  {
                                                                    uint64_t v590 = *(void *)(v590 + 32);
                                                                    if (v590) {
                                                                      continue;
                                                                    }
                                                                  }
                                                                  goto LABEL_1547;
                                                                }
                                                              }
                                                              else
                                                              {
                                                                unsigned int v591 = 0;
LABEL_1547:
                                                                if (v591 != v837)
                                                                {
                                                                  v600 = __nwlog_obj();
                                                                  if (os_log_type_enabled(v600, OS_LOG_TYPE_ERROR))
                                                                  {
                                                                    *(_DWORD *)long long buf = 136446722;
                                                                    v894 = "__nw_frame_array_claim";
                                                                    __int16 v895 = 1024;
                                                                    *(_DWORD *)v896 = v591;
                                                                    *(_WORD *)&v896[4] = 1024;
                                                                    *(_DWORD *)&v896[6] = v837;
                                                                    _os_log_impl(&dword_214653000, v600, OS_LOG_TYPE_ERROR, "%{public}s start_offset %u != start_bytes %u", buf, 0x18u);
                                                                  }
                                                                }
                                                              }
LABEL_1550:
                                                              if (!v842 || (*(unsigned char *)(v842 + 828) & 2) == 0)
                                                              {
                                                                if (__nwlog_is_datapath_logging_enabled())
                                                                {
                                                                  v766 = __nwlog_tcp_log();
                                                                  if (os_log_type_enabled(v766, OS_LOG_TYPE_DEBUG))
                                                                  {
                                                                    v767 = (const char *)(v842 + 604);
                                                                    v894 = "tcp_input";
                                                                    *(_DWORD *)long long buf = 136446722;
                                                                    if (!v842) {
                                                                      v767 = "";
                                                                    }
                                                                    __int16 v895 = 2082;
                                                                    *(void *)v896 = v767;
                                                                    *(_WORD *)&v896[8] = 1024;
                                                                    *(_DWORD *)v897 = v836;
                                                                    _os_log_impl(&dword_214653000, v766, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s queueing frame of length %u - slowpath", buf, 0x1Cu);
                                                                  }
                                                                }
                                                              }
                                                              *(_WORD *)(v830 + 304) += v818;
                                                              tcp_compute_rcv_rtt(v830, (uint64_t)v888, (uint64_t)&v914);
                                                              v601 = *(unsigned int (**)(uint64_t, long long *))(tcp_cc_algo_list[*(unsigned __int8 *)(v830 + 264)] + 96);
                                                              if (v601
                                                                && v601(v830, &v914)
                                                                && (int v602 = *(_DWORD *)(v830 + 88), (v602 & 1) == 0))
                                                              {
                                                                if ((v602 & 2) == 0)
                                                                {
                                                                  *(_DWORD *)(v830 + 88) = v602 | 2;
                                                                  *(_DWORD *)(v830 + 32) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v830 + 80) + 224)) + 316)
                                                                                         - *(_DWORD *)(v830 + 64)
                                                                                         + 100;
                                                                }
                                                              }
                                                              else
                                                              {
                                                                *(_DWORD *)(v830 + 88) |= 1u;
                                                              }
                                                              int v603 = *(_DWORD *)(v830 + 120) + v836;
                                                              *(_DWORD *)(v830 + 120) = v603;
                                                              if (*(_DWORD *)(v830 + 1916) - v603 < 0)
                                                              {
                                                                *(_DWORD *)(v830 + 1916) = v603;
                                                                if (v888[0]) {
                                                                  *(_DWORD *)(v830 + 1920) = DWORD1(v888[0]);
                                                                }
                                                              }
                                                              uint64_t v604 = *(void *)(v830 + 1056);
                                                              if (v604)
                                                              {
                                                                uint64_t v605 = *(void *)(v604 + 200) + v836;
                                                                ++*(void *)(v604 + 192);
                                                                *(void *)(v604 + 200) = v605;
                                                              }
                                                              char v606 = BYTE13(v914);
                                                              v607 = *(void **)(a3 + 248);
                                                              ++*v607;
                                                              if (v815)
                                                              {
                                                                ++**(void **)(a3 + 256);
                                                                if (!v812) {
                                                                  goto LABEL_1566;
                                                                }
                                                              }
                                                              else if (!v812)
                                                              {
LABEL_1566:
                                                                if (!v808) {
                                                                  goto LABEL_1568;
                                                                }
                                                                goto LABEL_1567;
                                                              }
                                                              ++**(void **)(a3 + 264);
                                                              if (!v808)
                                                              {
LABEL_1568:
                                                                v607[1] += v836;
                                                                if (v815)
                                                                {
                                                                  *(void *)(*(void *)(a3 + 256) + 8) += v836;
                                                                  if (!v812) {
                                                                    goto LABEL_1570;
                                                                  }
                                                                }
                                                                else if (!v812)
                                                                {
LABEL_1570:
                                                                  if (!v808) {
                                                                    goto LABEL_1572;
                                                                  }
                                                                  goto LABEL_1571;
                                                                }
                                                                *(void *)(*(void *)(a3 + 264) + 8) += v836;
                                                                if (!v808)
                                                                {
LABEL_1572:
                                                                  char v487 = v606 & 1;
                                                                  tcp_sbrcv_grow(v830, v842 + 488, (uint64_t)v888, v836);
                                                                  if (*(_DWORD *)(sysctls + 308) == 1
                                                                    && (~*(_DWORD *)(v830 + 88) & 0x180) == 0
                                                                    && (*(_DWORD *)(sysctls + 40) == 1
                                                                     || (*(unsigned char *)(v842 + 369) & 0x40) != 0)
                                                                    && off_26AA46360)
                                                                  {
                                                                    off_26AA46360(v830, (uint64_t)&v914, (uint64_t)v888, v836);
                                                                  }
                                                                  char v489 = BYTE13(v914);
                                                                  *(_DWORD *)(v830 + 740) = *(_DWORD *)(v830 + 740) & 0xFFFFFFEF | (16 * ((BYTE13(v914) >> 3) & 1));
                                                                  if (v836 >= 1)
                                                                  {
                                                                    unsigned int v608 = tcp_input_sbappendstream(v842, v885, v836, 2);
                                                                    int v838 = 0;
                                                                    if (a4 && v608)
                                                                    {
                                                                      int v838 = 0;
                                                                      *a4 = 1;
                                                                    }
                                                                    goto LABEL_1582;
                                                                  }
                                                                  goto LABEL_1211;
                                                                }
LABEL_1571:
                                                                *(void *)(*(void *)(a3 + 272) + 8) += v836;
                                                                goto LABEL_1572;
                                                              }
LABEL_1567:
                                                              ++**(void **)(a3 + 272);
                                                              goto LABEL_1568;
                                                            }
                                                            *(_WORD *)(v490 + 196) = v491 - v837;
                                                          }
LABEL_1413:
                                                          if (!v837) {
                                                            goto LABEL_1550;
                                                          }
                                                          goto LABEL_1531;
                                                        }
                                                        __nwlog_obj();
                                                        *(_DWORD *)long long buf = 136446210;
                                                        v894 = "__nw_frame_is_single_ip_aggregate";
                                                        v762 = (void *)_os_log_send_and_compose_impl();
                                                        type[0] = OS_LOG_TYPE_ERROR;
                                                        char v892 = 0;
                                                        if (__nwlog_fault())
                                                        {
                                                          if (type[0] == OS_LOG_TYPE_FAULT)
                                                          {
                                                            v763 = __nwlog_obj();
                                                            os_log_type_t v764 = type[0];
                                                            if (!os_log_type_enabled(v763, type[0])) {
                                                              goto LABEL_2058;
                                                            }
                                                            *(_DWORD *)long long buf = 136446210;
                                                            v894 = "__nw_frame_is_single_ip_aggregate";
                                                            v765 = "%{public}s called with null frame";
LABEL_2056:
                                                            v781 = v763;
                                                            os_log_type_t v782 = v764;
LABEL_2057:
                                                            _os_log_impl(&dword_214653000, v781, v782, v765, buf, 0xCu);
                                                            goto LABEL_2058;
                                                          }
                                                          if (!v892)
                                                          {
                                                            v763 = __nwlog_obj();
                                                            os_log_type_t v764 = type[0];
                                                            if (!os_log_type_enabled(v763, type[0])) {
                                                              goto LABEL_2058;
                                                            }
                                                            *(_DWORD *)long long buf = 136446210;
                                                            v894 = "__nw_frame_is_single_ip_aggregate";
                                                            v765 = "%{public}s called with null frame, backtrace limit exceeded";
                                                            goto LABEL_2056;
                                                          }
                                                          v770 = (void *)__nw_create_backtrace_string();
                                                          v771 = __nwlog_obj();
                                                          BOOL v772 = os_log_type_enabled(v771, type[0]);
                                                          if (v770)
                                                          {
                                                            if (v772)
                                                            {
                                                              *(_DWORD *)long long buf = 136446466;
                                                              v894 = "__nw_frame_is_single_ip_aggregate";
                                                              __int16 v895 = 2082;
                                                              *(void *)v896 = v770;
                                                              _os_log_impl(&dword_214653000, v771, type[0], "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                                                            }
                                                            free(v770);
                                                            goto LABEL_2058;
                                                          }
                                                          if (v772)
                                                          {
                                                            *(_DWORD *)long long buf = 136446210;
                                                            v894 = "__nw_frame_is_single_ip_aggregate";
                                                            v765 = "%{public}s called with null frame, no backtrace";
                                                            v781 = v771;
                                                            os_log_type_t v782 = type[0];
                                                            goto LABEL_2057;
                                                          }
                                                        }
LABEL_2058:
                                                        if (v762) {
                                                          free(v762);
                                                        }
                                                        goto LABEL_1413;
                                                      }
                                                      uint64_t v128 = v842;
                                                      uint64_t v129 = v813;
                                                      if ((*(_WORD *)(v12 + 204) & 0x100) == 0
                                                        || !*MEMORY[0x263F144B8]
                                                        || (((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(v12, *(void *)(v12 + 88)) & 1) != 0)
                                                      {
                                                        unsigned __int16 v915 = 0;
                                                        if (&v914 != (long long *)v823) {
                                                          *(_WORD *)(v823 + 18) = 0;
                                                        }
                                                        v478 &= ~0x20u;
                                                        goto LABEL_1177;
                                                      }
                                                      if (!v842 || (*(unsigned char *)(v842 + 828) & 2) == 0)
                                                      {
                                                        v800 = __nwlog_tcp_log();
                                                        if (os_log_type_enabled(v800, OS_LOG_TYPE_INFO))
                                                        {
                                                          v801 = "";
                                                          if (v842) {
                                                            v801 = (const char *)(v842 + 604);
                                                          }
                                                          *(_DWORD *)long long buf = 136446466;
                                                          v894 = "tcp_input";
                                                          __int16 v895 = 2082;
                                                          *(void *)v896 = v801;
                                                          _os_log_impl(&dword_214653000, v800, OS_LOG_TYPE_INFO, "%{public}s %{public}s dropping tcp input frame since frame is no longer valid", buf, 0x16u);
                                                        }
                                                      }
                                                      *(void *)(v119 + 1056) = 0;
                                                      unsigned int v40 = v885;
LABEL_787:
                                                      uint64_t v128 = v842;
LABEL_1186:
                                                      int v51 = v838;
                                                      int v130 = v839;
                                                      goto LABEL_1311;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    int v827 = 0;
                                                    int v404 = 0;
                                                    int v878 = 0;
                                                    LODWORD(v16) = v810;
                                                    a3 = v806;
LABEL_1358:
                                                    LOBYTE(v406) = v834;
                                                  }
                                                  int v809 = v17;
                                                  LOBYTE(v834) = v406;
                                                  uint64_t v17 = v119;
                                                  int v539 = *(_DWORD *)(v119 + 348);
                                                  if ((v539 & 0x20) != 0)
                                                  {
                                                    v539 &= ~0x20u;
                                                    *(_DWORD *)(v119 + 348) = v539;
                                                  }
                                                  unsigned int v540 = *(_DWORD *)(v119 + 8);
                                                  uint64_t v541 = *(void *)(v17 + 1056);
                                                  if (v541) {
                                                    ++*(void *)(v541 + 176);
                                                  }
                                                  int v542 = *(_DWORD *)(v17 + 740);
                                                  if ((v542 & 0x20) != 0)
                                                  {
                                                    unsigned int v544 = HIDWORD(v890);
                                                    unsigned int v553 = *(_DWORD *)(v17 + 196);
                                                    if (v553 <= HIDWORD(v890)) {
                                                      int v554 = HIDWORD(v890) / v553;
                                                    }
                                                    else {
                                                      int v554 = 1;
                                                    }
                                                    unsigned int v543 = v540 + v554;
                                                  }
                                                  else
                                                  {
                                                    unsigned int v543 = v540 + 1;
                                                    unsigned int v544 = HIDWORD(v890);
                                                  }
                                                  *(_DWORD *)(v17 + 8) = v543;
                                                  *(_DWORD *)(v17 + 628) += v544;
                                                  if (v544 && (v542 & 0x10000000) == 0)
                                                  {
                                                    BOOL v573 = (v542 & 0x8000000) == 0;
                                                    if (*(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1) {
                                                      BOOL v573 = 0;
                                                    }
                                                    if ((~v539 & 0x300004) == 0 && !v573 && *(_DWORD *)(v17 + 12) == 4)
                                                    {
                                                      unsigned int v575 = *(_DWORD *)(v17 + 196);
                                                      if (v544 / v575 * v575 == v544) {
                                                        unsigned int v576 = v544 / v575;
                                                      }
                                                      else {
                                                        unsigned int v576 = v544 / v575 + 1;
                                                      }
                                                      *(_DWORD *)(v17 + 296) += v576;
                                                      tcp_process_accecn(v17, (uint64_t)v888, (uint64_t)&v914, v576, v814);
                                                    }
                                                  }
                                                  if (*(_WORD *)(v17 + 268)
                                                    && *(_DWORD *)(v828 + 316) - *(_DWORD *)(v17 + 272) - 60000 >= 0)
                                                  {
                                                    *(_WORD *)(v17 + 268) = 0;
                                                  }
                                                  if ((*(unsigned char *)(v17 + 90) & 0x20) == 0) {
                                                    tcp_early_rexmt_check(v17);
                                                  }
                                                  BOOL v577 = (*(_DWORD *)(v17 + 740) & 0x20400020) == 0x20000020
                                                      && tcp_rack_detect_loss_and_arm_timer(v17, *(_DWORD *)(v17 + 8));
                                                  if (!*(_DWORD *)(v17 + 28)
                                                    || (int v578 = *(_DWORD *)(v17 + 92), DWORD2(v914) != v578) && !v544)
                                                  {
                                                    uint64_t v119 = v17;
                                                    *(_DWORD *)(v17 + 8) = 0;
                                                    *(unsigned char *)(v17 + 310) = 3;
LABEL_1497:
                                                    os_log_type_t v39 = a6;
LABEL_1498:
                                                    LODWORD(v17) = v809;
                                                    goto LABEL_1165;
                                                  }
                                                  int v579 = *(_DWORD *)(v17 + 740);
                                                  if ((v579 & 0x20400020) != 0x20000020
                                                    && (unsigned int v585 = *(unsigned __int8 *)(v17 + 310),
                                                        *(_DWORD *)(v17 + 8) > (signed int)v585)
                                                    && v540 >= v585
                                                    || (int v580 = *(_DWORD *)(v17 + 88), (v580 & 0x200000) != 0))
                                                  {
                                                    if ((v579 & 0x20) == 0) {
                                                      goto LABEL_1516;
                                                    }
                                                    int v629 = *(_DWORD *)(v17 + 88);
                                                    if ((~v579 & 0x6000) == 0 && (v629 & 0x200000) == 0) {
                                                      goto LABEL_1734;
                                                    }
                                                    if ((v629 & 0x200000) != 0)
                                                    {
                                                      int v586 = *(_DWORD *)(v17 + 148);
                                                      if (*(_DWORD *)(v17 + 100)
                                                         - *(_DWORD *)(v17 + 560)
                                                         + *(_DWORD *)(v17 + 624) >= v586)
                                                        goto LABEL_1518;
                                                      if (*(_DWORD *)(v17 + 144) + *(_DWORD *)(v17 + 196) < v586) {
                                                        int v586 = *(_DWORD *)(v17 + 144) + *(_DWORD *)(v17 + 196);
                                                      }
                                                    }
                                                    else
                                                    {
LABEL_1516:
                                                      int v586 = *(_DWORD *)(v17 + 144) + *(_DWORD *)(v17 + 196);
                                                    }
                                                    *(_DWORD *)(v17 + 144) = v586;
LABEL_1518:
                                                    if (v816 > *(_DWORD *)(v17 + 140)) {
                                                      tcp_update_window(v17, v834, (uint64_t)&v914, v816, v827);
                                                    }
                                                    tcp_output(v17);
                                                    goto LABEL_1270;
                                                  }
                                                  if (!v577)
                                                  {
                                                    int v636 = *(_DWORD *)(v17 + 8);
                                                    if ((v579 & 0x20400020) == 0x20000020
                                                      || v636 < *(unsigned __int8 *)(v17 + 310))
                                                    {
                                                      if (v636 >= 1)
                                                      {
                                                        int v637 = ~v579 & 0x6000;
                                                        BOOL v638 = (v579 & 0x20) != 0 && v544 == 0;
                                                        BOOL v639 = !v638;
                                                        if (v637
                                                          && v636 < *(unsigned __int8 *)(v17 + 310)
                                                          && v639
                                                          && v578 - *(_DWORD *)(v17 + 96) + *(_DWORD *)(v842 + 384))
                                                        {
                                                          int v640 = *(_DWORD *)(v17 + 196) * v636;
                                                          *(_DWORD *)(v17 + 144) += v640;
                                                          uint64_t v641 = *(void *)(v17 + 1056);
                                                          if (v641) {
                                                            ++*(void *)(v641 + 688);
                                                          }
                                                          if (tcp_output(v17)
                                                            && (*(_WORD *)(v12 + 204) & 0x100) != 0
                                                            && *MEMORY[0x263F144B8]
                                                            && (((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(v12, *(void *)(v12 + 88)) & 1) == 0)
                                                          {
                                                            goto LABEL_2108;
                                                          }
                                                          uint64_t v119 = v17;
                                                          *(_DWORD *)(v17 + 144) -= v640;
                                                          goto LABEL_1497;
                                                        }
                                                      }
LABEL_1734:
                                                      os_log_type_t v39 = a6;
                                                      uint64_t v119 = v17;
                                                      goto LABEL_1498;
                                                    }
                                                  }
                                                  int v581 = *(_DWORD *)(v17 + 100);
                                                  if ((v579 & 0x20) != 0)
                                                  {
                                                    if ((v579 & 0x4000) != 0) {
                                                      goto LABEL_1734;
                                                    }
                                                  }
                                                  else if (DWORD2(v914) - *(_DWORD *)(v17 + 152) <= 0)
                                                  {
                                                    uint64_t v119 = v17;
                                                    *(_DWORD *)(v17 + 8) = 0;
                                                    goto LABEL_1497;
                                                  }
                                                  *(_DWORD *)(v17 + 152) = *(_DWORD *)(v17 + 96) + (v580 << 27 >> 31);
                                                  *(_DWORD *)(v17 + 16) = 0;
                                                  *(_DWORD *)(v17 + 172) = 0;
                                                  if ((v579 & 0x6020) == 0x2020
                                                    && *(_WORD *)(v17 + 536)
                                                    && (*(_DWORD *)(v17 + 12) | 2) == 6)
                                                  {
                                                    *(_DWORD *)(v17 + 20) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v17 + 80) + 224))
                                                                                      + 316)
                                                                          + *(unsigned __int16 *)(v17 + 536)
                                                                          - *(_DWORD *)(v17 + 64);
                                                    *(_DWORD *)(v17 + 740) |= 0x4000u;
                                                    uint64_t v653 = *(void *)(v17 + 1056);
                                                    if (v653) {
                                                      ++*(void *)(v653 + 984);
                                                    }
                                                    goto LABEL_1734;
                                                  }
                                                  tcp_rexmt_save_state(v17);
                                                  v654 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(v17 + 264)]
                                                                                        + 64);
                                                  if (v654) {
                                                    v654(v17);
                                                  }
                                                  *(_DWORD *)(v17 + 88) |= 0x200000u;
                                                  uint64_t v655 = *(void *)(v17 + 80);
                                                  if ((*(unsigned char *)(v655 + 2231) & 0x40) != 0) {
                                                    inp_reset_fc_state(v655);
                                                  }
                                                  if (*(void *)(v17 + 952)) {
                                                    tcp_rxtseg_clean(v17);
                                                  }
                                                  *(_DWORD *)(v17 + 28) = 0;
                                                  int v656 = *(_DWORD *)(v17 + 740);
                                                  if ((v656 & 0x10000000) != 0)
                                                  {
                                                    int v659 = *(_DWORD *)(v17 + 348);
                                                  }
                                                  else
                                                  {
                                                    BOOL v658 = tcp_do_acc_ecn != 1
                                                        && *(_DWORD *)(sysctls + 320) != 1
                                                        && (v656 & 0x8000000) == 0;
                                                    int v659 = *(_DWORD *)(v17 + 348);
                                                    if (!v658 && (v659 & 0x300000) == 0x300000)
                                                    {
LABEL_1859:
                                                      if ((v656 & 0x20) == 0)
                                                      {
                                                        *(_DWORD *)(v17 + 100) = DWORD2(v914);
                                                        *(_DWORD *)(v17 + 144) = *(_DWORD *)(v17 + 196);
                                                        *(_DWORD *)(v17 + 740) = v656 & 0xFFEFFFFF;
                                                        if (v816 > *(_DWORD *)(v17 + 140)) {
                                                          tcp_update_window(v17, v834, (uint64_t)&v914, v816, v827);
                                                        }
                                                        tcp_output(v17);
                                                        if ((*(unsigned char *)(v17 + 742) & 0x10) != 0) {
                                                          tcp_cc_adjust_nonvalidated_cwnd(v17);
                                                        }
                                                        else {
                                                          *(_DWORD *)(v17 + 144) = *(_DWORD *)(v17 + 148)
                                                        }
                                                                                 + *(_DWORD *)(v17 + 8)
                                                                                 * *(_DWORD *)(v17 + 196);
                                                        if (v581 - *(_DWORD *)(v17 + 100) >= 1) {
                                                          *(_DWORD *)(v17 + 100) = v581;
                                                        }
                                                        goto LABEL_1270;
                                                      }
                                                      uint64_t v698 = *(void *)(v17 + 1056);
                                                      if ((v656 & 0x20400000) == 0x20000000)
                                                      {
                                                        if (v698) {
                                                          ++*(void *)(v698 + 624);
                                                        }
                                                        ++*(_DWORD *)(v17 + 1008);
                                                      }
                                                      else
                                                      {
                                                        if (v698) {
                                                          ++*(void *)(v698 + 568);
                                                        }
                                                        ++*(_DWORD *)(v17 + 1004);
                                                      }
                                                      *(_DWORD *)(v17 + 144) = *(_DWORD *)(v17 + 148);
                                                      *(_DWORD *)(v17 + 740) = v656 & 0xFFEFFFFF;
                                                      goto LABEL_1518;
                                                    }
                                                  }
                                                  if ((~v659 & 3) == 0) {
                                                    *(_DWORD *)(v17 + 348) = v659 | 8;
                                                  }
                                                  goto LABEL_1859;
                                                }
                                                v773 = __nwlog_obj();
                                                os_log_type_enabled(v773, OS_LOG_TYPE_ERROR);
                                                *(_DWORD *)long long buf = 136446210;
                                                v894 = "tcp_input";
                                                v774 = (void *)_os_log_send_and_compose_impl();
                                                if (!__nwlog_abort())
                                                {
                                                  free(v774);
                                                  char v665 = *(unsigned char *)(v830 + 988);
                                                  goto LABEL_1778;
                                                }
LABEL_2107:
                                                __break(1u);
LABEL_2108:
                                                if ((*(unsigned char *)(v842 + 828) & 2) == 0)
                                                {
                                                  v802 = __nwlog_tcp_log();
                                                  if (os_log_type_enabled(v802, OS_LOG_TYPE_INFO))
                                                  {
                                                    v803 = "";
                                                    if (v842) {
                                                      v803 = (const char *)(v842 + 604);
                                                    }
                                                    *(_DWORD *)long long buf = 136446466;
                                                    v894 = "tcp_input";
                                                    __int16 v895 = 2082;
                                                    *(void *)v896 = v803;
                                                    _os_log_impl(&dword_214653000, v802, OS_LOG_TYPE_INFO, "%{public}s %{public}s dropping input packet since frame is no longer valid", buf, 0x16u);
                                                  }
                                                }
                                                *(void *)(v17 + 1056) = 0;
                                                goto LABEL_1270;
                                              }
                                              v295 = v222;
                                              unsigned int v296 = *(unsigned __int16 *)(v294 + 196);
                                              if (v289 <= v296)
                                              {
                                                *(_WORD *)(v294 + 196) = v296 - v289;
LABEL_1227:
                                                v222 = v295;
                                                goto LABEL_1228;
                                              }
                                              __nwlog_obj();
                                              int v297 = *(unsigned __int16 *)(v294 + 196);
                                              *(_DWORD *)long long buf = 136446722;
                                              v894 = "__nw_frame_array_claim";
                                              __int16 v895 = 1024;
                                              *(_DWORD *)v896 = v297;
                                              *(_WORD *)&v896[4] = 1024;
                                              *(_DWORD *)&v896[6] = v289;
                                              v298 = (void *)_os_log_send_and_compose_impl();
                                              type[0] = OS_LOG_TYPE_ERROR;
                                              char v892 = 0;
                                              if (__nwlog_fault())
                                              {
                                                if (type[0] == OS_LOG_TYPE_FAULT)
                                                {
                                                  v299 = __nwlog_obj();
                                                  os_log_type_t v300 = type[0];
                                                  if (os_log_type_enabled(v299, type[0]))
                                                  {
                                                    int v301 = *(unsigned __int16 *)(v294 + 196);
                                                    *(_DWORD *)long long buf = 136446722;
                                                    v894 = "__nw_frame_array_claim";
                                                    __int16 v895 = 1024;
                                                    *(_DWORD *)v896 = v301;
                                                    *(_WORD *)&v896[4] = 1024;
                                                    *(_DWORD *)&v896[6] = v289;
                                                    v302 = "%{public}s Aggregate buffer length: %u sum: %u";
LABEL_1222:
                                                    v499 = v299;
                                                    os_log_type_t v500 = v300;
LABEL_1223:
                                                    _os_log_impl(&dword_214653000, v499, v500, v302, buf, 0x18u);
                                                  }
                                                }
                                                else if (v892)
                                                {
                                                  v350 = (void *)__nw_create_backtrace_string();
                                                  v351 = __nwlog_obj();
                                                  BOOL v352 = os_log_type_enabled(v351, type[0]);
                                                  if (v350)
                                                  {
                                                    if (v352)
                                                    {
                                                      int v353 = *(unsigned __int16 *)(v294 + 196);
                                                      *(_DWORD *)long long buf = 136446978;
                                                      v894 = "__nw_frame_array_claim";
                                                      __int16 v895 = 1024;
                                                      *(_DWORD *)v896 = v353;
                                                      *(_WORD *)&v896[4] = 1024;
                                                      *(_DWORD *)&v896[6] = v289;
                                                      *(_WORD *)v897 = 2082;
                                                      *(void *)&v897[2] = v350;
                                                      _os_log_impl(&dword_214653000, v351, type[0], "%{public}s Aggregate buffer length: %u sum: %u, dumping backtrace:%{public}s", buf, 0x22u);
                                                    }
                                                    free(v350);
                                                    goto LABEL_1224;
                                                  }
                                                  if (v352)
                                                  {
                                                    int v547 = *(unsigned __int16 *)(v294 + 196);
                                                    *(_DWORD *)long long buf = 136446722;
                                                    v894 = "__nw_frame_array_claim";
                                                    __int16 v895 = 1024;
                                                    *(_DWORD *)v896 = v547;
                                                    *(_WORD *)&v896[4] = 1024;
                                                    *(_DWORD *)&v896[6] = v289;
                                                    v302 = "%{public}s Aggregate buffer length: %u sum: %u, no backtrace";
                                                    v499 = v351;
                                                    os_log_type_t v500 = type[0];
                                                    goto LABEL_1223;
                                                  }
                                                }
                                                else
                                                {
                                                  v299 = __nwlog_obj();
                                                  os_log_type_t v300 = type[0];
                                                  if (os_log_type_enabled(v299, type[0]))
                                                  {
                                                    int v498 = *(unsigned __int16 *)(v294 + 196);
                                                    *(_DWORD *)long long buf = 136446722;
                                                    v894 = "__nw_frame_array_claim";
                                                    __int16 v895 = 1024;
                                                    *(_DWORD *)v896 = v498;
                                                    *(_WORD *)&v896[4] = 1024;
                                                    *(_DWORD *)&v896[6] = v289;
                                                    v302 = "%{public}s Aggregate buffer length: %u sum: %u, backtrace limit exceeded";
                                                    goto LABEL_1222;
                                                  }
                                                }
                                              }
LABEL_1224:
                                              if (v298) {
                                                free(v298);
                                              }
                                              *(_WORD *)(v294 + 196) = 0;
                                              goto LABEL_1227;
                                            }
                                            v295 = v222;
                                            __nwlog_obj();
                                            *(_DWORD *)long long buf = 136446210;
                                            v894 = "__nw_frame_is_single_ip_aggregate";
                                            v694 = (void *)_os_log_send_and_compose_impl();
                                            type[0] = OS_LOG_TYPE_ERROR;
                                            char v892 = 0;
                                            if (__nwlog_fault())
                                            {
                                              if (type[0] == OS_LOG_TYPE_FAULT)
                                              {
                                                v695 = __nwlog_obj();
                                                os_log_type_t v696 = type[0];
                                                if (!os_log_type_enabled(v695, type[0])) {
                                                  goto LABEL_2003;
                                                }
                                                *(_DWORD *)long long buf = 136446210;
                                                v894 = "__nw_frame_is_single_ip_aggregate";
                                                v697 = "%{public}s called with null frame";
LABEL_2001:
                                                v745 = v695;
                                                os_log_type_t v746 = v696;
LABEL_2002:
                                                _os_log_impl(&dword_214653000, v745, v746, v697, buf, 0xCu);
                                                goto LABEL_2003;
                                              }
                                              if (!v892)
                                              {
                                                v695 = __nwlog_obj();
                                                os_log_type_t v696 = type[0];
                                                if (!os_log_type_enabled(v695, type[0])) {
                                                  goto LABEL_2003;
                                                }
                                                *(_DWORD *)long long buf = 136446210;
                                                v894 = "__nw_frame_is_single_ip_aggregate";
                                                v697 = "%{public}s called with null frame, backtrace limit exceeded";
                                                goto LABEL_2001;
                                              }
                                              v706 = (void *)__nw_create_backtrace_string();
                                              v707 = __nwlog_obj();
                                              BOOL v708 = os_log_type_enabled(v707, type[0]);
                                              if (v706)
                                              {
                                                if (v708)
                                                {
                                                  *(_DWORD *)long long buf = 136446466;
                                                  v894 = "__nw_frame_is_single_ip_aggregate";
                                                  __int16 v895 = 2082;
                                                  *(void *)v896 = v706;
                                                  _os_log_impl(&dword_214653000, v707, type[0], "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                                                }
                                                free(v706);
                                                goto LABEL_2003;
                                              }
                                              if (v708)
                                              {
                                                *(_DWORD *)long long buf = 136446210;
                                                v894 = "__nw_frame_is_single_ip_aggregate";
                                                v697 = "%{public}s called with null frame, no backtrace";
                                                v745 = v707;
                                                os_log_type_t v746 = type[0];
                                                goto LABEL_2002;
                                              }
                                            }
LABEL_2003:
                                            if (v694) {
                                              free(v694);
                                            }
                                            goto LABEL_1227;
                                          }
                                        }
                                        else
                                        {
                                          int v292 = v255;
                                          if (v255 > v289) {
                                            goto LABEL_747;
                                          }
                                          if (DWORD1(v914) == v286 && !v287)
                                          {
                                            *(_DWORD *)(v830 + 88) |= 1u;
                                            goto LABEL_747;
                                          }
                                        }
                                        unsigned int v40 = v222;
                                        os_log_type_t v39 = a6;
                                        uint64_t v128 = v842;
                                        uint64_t v119 = v830;
LABEL_1109:
                                        uint64_t v129 = v813;
LABEL_1110:
                                        int v130 = v839;
                                        unsigned int v127 = v834;
                                        goto LABEL_1277;
                                      }
                                      uint64_t v293 = *(void *)(v119 + 1056);
                                      if (v293) {
                                        ++*(void *)(v293 + 304);
                                      }
                                      tcp_close(v119);
LABEL_739:
                                      int v130 = v839;
                                      unsigned int v40 = v222;
                                      goto LABEL_272;
                                    }
                                    uint64_t v234 = v119;
                                    unsigned int v235 = v834;
                                    if ((v834 & 2) == 0)
                                    {
LABEL_676:
                                      int v272 = v891;
                                      if (v232 <= v891 && ((v235 & 1) != 0 || v232 != v891))
                                      {
                                        uint64_t v279 = *(void *)(v234 + 1056);
                                        if (!v279)
                                        {
LABEL_692:
                                          unsigned int v278 = v235;
LABEL_693:
                                          uint64_t v119 = v234;
                                          if (v232 >= 2)
                                          {
                                            int v280 = DWORD1(v914);
                                            *(_DWORD *)(v234 + 940) = DWORD1(v914);
                                            *(_DWORD *)(v234 + 944) = v280 + v232;
                                            *(_DWORD *)(v234 + 88) |= 1u;
                                          }
                                          v281 = *(void **)(a3 + 248);
                                          ++*v281;
                                          if (v815)
                                          {
                                            ++**(void **)(a3 + 256);
                                            if (!v16) {
                                              goto LABEL_697;
                                            }
                                          }
                                          else if (!v16)
                                          {
LABEL_697:
                                            if (!v17) {
                                              goto LABEL_699;
                                            }
                                            goto LABEL_698;
                                          }
                                          ++**(void **)(a3 + 264);
                                          if (!v17)
                                          {
LABEL_699:
                                            v281[1] += v232;
                                            if (v815)
                                            {
                                              *(void *)(*(void *)(a3 + 256) + 8) += v232;
                                              if (!v16) {
                                                goto LABEL_701;
                                              }
                                            }
                                            else if (!v16)
                                            {
LABEL_701:
                                              if (!v17) {
                                                goto LABEL_703;
                                              }
                                              goto LABEL_702;
                                            }
                                            *(void *)(*(void *)(a3 + 264) + 8) += v232;
                                            if (!v17)
                                            {
LABEL_703:
                                              *(_DWORD *)(v234 + 704) += v232;
                                              if (*(void *)(v842 + 24))
                                              {
                                                uint64_t v282 = nw_protocol_tcp_get_all_stats();
                                                if (v282) {
                                                  *(_DWORD *)(v282 + 48) += v232;
                                                }
                                              }
                                              if ((*(_WORD *)(v12 + 204) & 0x100) != 0
                                                && *MEMORY[0x263F144B8]
                                                && (((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(v12, *(void *)(v12 + 88)) & 1) == 0)
                                              {
                                                if ((*(unsigned char *)(v842 + 828) & 2) == 0)
                                                {
                                                  v651 = __nwlog_tcp_log();
                                                  if (os_log_type_enabled(v651, OS_LOG_TYPE_INFO))
                                                  {
                                                    v652 = "";
                                                    if (v842) {
                                                      v652 = (const char *)(v842 + 604);
                                                    }
                                                    *(_DWORD *)long long buf = 136446466;
                                                    v894 = "tcp_input";
                                                    __int16 v895 = 2082;
                                                    *(void *)v896 = v652;
                                                    _os_log_impl(&dword_214653000, v651, OS_LOG_TYPE_INFO, "%{public}s %{public}s dropping tcp input frame since frame is no longer valid", buf, 0x16u);
                                                  }
                                                }
                                                *(void *)(v234 + 1056) = 0;
                                                unsigned int v40 = v222;
                                                goto LABEL_1271;
                                              }
                                              int v233 = v232 + v837;
                                              DWORD1(v914) += v232;
                                              if (&v914 == (long long *)v823)
                                              {
                                                int v255 = v272 - v232;
                                                int v891 = v272 - v232;
                                                if (v232 >= v915)
                                                {
                                                  unsigned int v127 = v278 & 0xFFFFFFDF;
                                                  unsigned __int16 v915 = 0;
                                                  uint64_t v128 = v842;
                                                  uint64_t v129 = v813;
                                                }
                                                else
                                                {
                                                  v915 -= v232;
                                                  uint64_t v128 = v842;
                                                  uint64_t v129 = v813;
                                                  unsigned int v127 = v278;
                                                }
                                              }
                                              else
                                              {
                                                *(_DWORD *)(v823 + 4) += v232;
                                                int v255 = v272 - v232;
                                                int v891 = v272 - v232;
                                                uint64_t v129 = v813;
                                                if (v232 >= v915)
                                                {
                                                  unsigned int v127 = v278 & 0xFFFFFFDF;
                                                  unsigned __int16 v915 = 0;
                                                  *(_WORD *)(v823 + 18) = 0;
                                                  uint64_t v128 = v842;
                                                }
                                                else
                                                {
                                                  v915 -= v232;
                                                  *(_WORD *)(v823 + 18) -= v232;
                                                  uint64_t v128 = v842;
                                                  unsigned int v127 = v278;
                                                }
                                              }
                                              os_log_type_t v39 = a6;
                                              goto LABEL_723;
                                            }
LABEL_702:
                                            *(void *)(*(void *)(a3 + 272) + 8) += v232;
                                            goto LABEL_703;
                                          }
LABEL_698:
                                          ++**(void **)(a3 + 272);
                                          goto LABEL_699;
                                        }
                                        ++*(void *)(v279 + 240);
                                        uint64_t v276 = v232;
                                        v277 = (void *)(v279 + 248);
LABEL_691:
                                        *v277 += v276;
                                        goto LABEL_692;
                                      }
                                      if ((v834 & 2) != 0)
                                      {
                                        if (tcp_is_ack_ratelimited(v234))
                                        {
LABEL_682:
                                          v235 &= ~1u;
                                          if (v232 == 1)
                                          {
                                            uint64_t v273 = *(void *)(v842 + 32);
                                            if (v273)
                                            {
                                              v274 = *(void (**)(uint64_t))(v273 + 88);
                                              if (v274) {
                                                v274(v842);
                                              }
                                            }
                                          }
                                          uint64_t v275 = *(void *)(v234 + 1056);
                                          if (!v275)
                                          {
                                            unsigned int v278 = v235;
                                            int v232 = v272;
                                            goto LABEL_693;
                                          }
                                          uint64_t v276 = v272;
                                          ++*(void *)(v275 + 208);
                                          v277 = (void *)(v275 + 216);
                                          int v232 = v272;
                                          goto LABEL_691;
                                        }
                                        uint64_t v303 = *(void *)(v234 + 1056);
                                        if (v303) {
                                          ++*(void *)(v303 + 104);
                                        }
                                      }
                                      *(_DWORD *)(v234 + 88) |= 1u;
                                      goto LABEL_682;
                                    }
                                    unsigned int v235 = v834 & 0xFFFFFFFD;
                                    ++DWORD1(v914);
                                    if (&v914 == (long long *)v823)
                                    {
                                      if (v915 > 1u)
                                      {
                                        --v915;
                                        goto LABEL_675;
                                      }
                                    }
                                    else
                                    {
                                      ++*(_DWORD *)(v823 + 4);
                                      if (v915 > 1u)
                                      {
                                        --v915;
                                        --*(_WORD *)(v823 + 18);
LABEL_675:
                                        --v232;
                                        goto LABEL_676;
                                      }
                                    }
                                    unsigned int v235 = v834 & 0xDDDDDDDD;
                                    goto LABEL_675;
                                  }
                                  if (*(_DWORD *)(v828 + 316) - *(_DWORD *)(v119 + 280) >= 2073600001)
                                  {
                                    *(_DWORD *)(v119 + 276) = 0;
                                    uint64_t v128 = v842;
                                    unsigned int v127 = v834;
                                    goto LABEL_587;
                                  }
                                  uint64_t v314 = *(void *)(v119 + 1056);
                                  if (v314)
                                  {
                                    ++*(void *)(v314 + 208);
                                    ++*(_DWORD *)(v119 + 1000);
                                    int64x2_t v315 = vdupq_n_s64(1uLL);
                                    v315.i64[0] = v875;
                                    *(int64x2_t *)(v314 + 216) = vaddq_s64(*(int64x2_t *)(v314 + 216), v315);
                                  }
                                  else
                                  {
                                    ++*(_DWORD *)(v119 + 1000);
                                  }
                                  int v356 = *(_DWORD *)(v119 + 348);
                                  if ((~v356 & 3) == 0) {
                                    goto LABEL_2116;
                                  }
                                  int v359 = *(_DWORD *)(v119 + 740);
                                  if ((v359 & 0x10000000) == 0)
                                  {
                                    BOOL v360 = (v359 & 0x8000000) == 0;
                                    if (*(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1) {
                                      BOOL v360 = 0;
                                    }
                                    if ((~v356 & 0x300000) == 0 && !v360)
                                    {
LABEL_2116:
                                      if (!(*(void *)(*(void *)(a3 + 248) + 8) >> 31))
                                      {
                                        uint64_t v357 = *(void *)(a3 + 448);
                                        if (v357)
                                        {
                                          uint64_t v358 = 632;
                                          if ((*(unsigned char *)(a3 + 2236) & 2) == 0) {
                                            uint64_t v358 = 248;
                                          }
                                          ++*(void *)(v357 + v358);
                                        }
                                        if (v314) {
                                          ++*(void *)(v314 + 936);
                                        }
                                        tcp_heuristic_ecn_aggressive(v119);
                                      }
                                    }
                                  }
                                  v362 = *(void **)(a3 + 248);
                                  ++*v362;
                                  if (v815)
                                  {
                                    ++**(void **)(a3 + 256);
                                    if (!v16) {
                                      goto LABEL_909;
                                    }
                                  }
                                  else if (!v16)
                                  {
LABEL_909:
                                    if (!v17) {
                                      goto LABEL_911;
                                    }
                                    goto LABEL_910;
                                  }
                                  ++**(void **)(a3 + 264);
                                  if (!v17)
                                  {
LABEL_911:
                                    uint64_t v363 = v891;
                                    v362[1] += v891;
                                    if (v815)
                                    {
                                      *(void *)(*(void *)(a3 + 256) + 8) += v363;
                                      if (!v16) {
                                        goto LABEL_913;
                                      }
                                    }
                                    else if (!v16)
                                    {
LABEL_913:
                                      if (!v17)
                                      {
LABEL_915:
                                        *(_DWORD *)(v119 + 704) += v363;
                                        if (*(void *)(v842 + 24))
                                        {
                                          uint64_t v364 = nw_protocol_tcp_get_all_stats();
                                          if (v364) {
                                            *(_DWORD *)(v364 + 48) += v363;
                                          }
                                        }
                                        BOOL v469 = (int)v363 <= 0;
                                        unsigned int v40 = v222;
                                        uint64_t v128 = v842;
                                        int v130 = v839;
                                        unsigned int v127 = v834;
                                        if (!v469) {
                                          goto LABEL_1277;
                                        }
                                        goto LABEL_1310;
                                      }
LABEL_914:
                                      *(void *)(*(void *)(a3 + 272) + 8) += v363;
                                      goto LABEL_915;
                                    }
                                    *(void *)(*(void *)(a3 + 264) + 8) += v363;
                                    if (!v17) {
                                      goto LABEL_915;
                                    }
                                    goto LABEL_914;
                                  }
LABEL_910:
                                  ++**(void **)(a3 + 272);
                                  goto LABEL_911;
                                }
                                int v236 = *(_DWORD *)(v119 + 284);
                                int v130 = v839;
                                unsigned int v40 = v222;
                                if (DWORD1(v914) - v236 >= 0 && (int)(DWORD1(v914) - v236 - v228) < 0)
                                {
                                  int v237 = v236 - 1;
                                }
                                else
                                {
                                  if (v228 && v229 < 5) {
                                    goto LABEL_1310;
                                  }
                                  int v237 = v236 - 1;
                                  if (DWORD1(v914) != v236 && v237 != DWORD1(v914)) {
                                    goto LABEL_1310;
                                  }
                                }
                                if (DWORD1(v914) != v236 && v237 != DWORD1(v914))
                                {
                                  uint64_t v256 = *(void *)(v119 + 1056);
                                  if (v256) {
                                    ++*(void *)(v256 + 312);
                                  }
                                  if (tcp_is_ack_ratelimited(v119)) {
                                    goto LABEL_787;
                                  }
                                  uint64_t v257 = *(void *)(v119 + 1056);
                                  if (v257) {
                                    ++*(void *)(v257 + 112);
                                  }
                                  uint64_t v128 = v842;
                                  goto LABEL_1110;
                                }
                                break;
                              case 4:
                                if ((v834 & 2) == 0 || v875 > 0) {
                                  goto LABEL_581;
                                }
                                if (tcp_is_ack_ratelimited(v119)) {
                                  goto LABEL_643;
                                }
                                uint64_t v230 = *(void *)(v119 + 1056);
                                if (v230) {
                                  ++*(void *)(v230 + 104);
                                }
                                int v130 = v839;
                                unsigned int v40 = v222;
                                goto LABEL_1277;
                              default:
                                goto LABEL_581;
                            }
                            int v258 = v229 - 3;
                            __int16 v259 = 61;
                            switch(v258)
                            {
                              case 0:
                                goto LABEL_656;
                              case 1:
                                int v354 = *(_DWORD *)(v119 + 348);
                                if ((~v354 & 3) == 0) {
                                  goto LABEL_886;
                                }
                                int v474 = *(_DWORD *)(v119 + 740);
                                if ((v474 & 0x10000000) == 0)
                                {
                                  BOOL v475 = (v474 & 0x8000000) == 0;
                                  if (*(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1) {
                                    BOOL v475 = 0;
                                  }
                                  if ((~v354 & 0x300000) == 0 && !v475)
                                  {
LABEL_886:
                                    int v355 = *(_DWORD *)(v119 + 92);
                                    if (v355 == *(_DWORD *)(v119 + 112) + 1 && *(_DWORD *)(v119 + 96) - v355 >= 1) {
                                      tcp_heuristic_ecn_droprst(v119);
                                    }
                                  }
                                }
                                goto LABEL_655;
                              case 2:
                              case 3:
                              case 6:
LABEL_655:
                                __int16 v259 = 54;
LABEL_656:
                                *(_WORD *)(v128 + 378) = v259;
                                if (tcp_perf_measurement)
                                {
                                  if ((*(unsigned char *)(v128 + 828) & 2) == 0)
                                  {
                                    if (__nwlog_is_datapath_logging_enabled())
                                    {
                                      v260 = __nwlog_tcp_log();
                                      if (os_log_type_enabled(v260, OS_LOG_TYPE_DEBUG))
                                      {
                                        v261 = tcpstates[*(int *)(v119 + 12)];
                                        v894 = "tcp_input";
                                        v262 = "";
                                        *(_DWORD *)long long buf = 136446722;
                                        if (v842) {
                                          v262 = (const char *)(v842 + 604);
                                        }
                                        __int16 v895 = 2082;
                                        *(void *)v896 = v262;
                                        *(_WORD *)&v896[8] = 2082;
                                        *(void *)v897 = v261;
                                        v263 = v260;
                                        os_log_type_t v264 = OS_LOG_TYPE_DEBUG;
LABEL_851:
                                        _os_log_impl(&dword_214653000, v263, v264, "%{public}s %{public}s ECONNRESET t_state %{public}s", buf, 0x20u);
                                      }
                                    }
                                  }
                                }
                                else if ((*(unsigned char *)(v128 + 828) & 2) == 0)
                                {
                                  v340 = __nwlog_tcp_log();
                                  if (os_log_type_enabled(v340, OS_LOG_TYPE_INFO))
                                  {
                                    v341 = tcpstates[*(int *)(v119 + 12)];
                                    v894 = "tcp_input";
                                    v342 = "";
                                    *(_DWORD *)long long buf = 136446722;
                                    if (v842) {
                                      v342 = (const char *)(v842 + 604);
                                    }
                                    __int16 v895 = 2082;
                                    *(void *)v896 = v342;
                                    *(_WORD *)&v896[8] = 2082;
                                    *(void *)v897 = v341;
                                    v263 = v340;
                                    os_log_type_t v264 = OS_LOG_TYPE_INFO;
                                    goto LABEL_851;
                                  }
                                }
                                uint64_t v128 = v842;
                                user_north_signal_error(v842);
                                uint64_t v343 = *(void *)(v119 + 1056);
                                if (v343) {
                                  ++*(void *)(v343 + 424);
                                }
                                tcp_close(v119);
                                goto LABEL_1186;
                              case 4:
                              case 5:
                                if ((*(unsigned char *)(v128 + 828) & 2) == 0)
                                {
                                  if (__nwlog_is_datapath_logging_enabled())
                                  {
                                    v742 = __nwlog_tcp_log();
                                    if (os_log_type_enabled(v742, OS_LOG_TYPE_DEBUG))
                                    {
                                      v743 = tcpstates[*(int *)(v119 + 12)];
                                      v894 = "tcp_input";
                                      v744 = "";
                                      *(_DWORD *)long long buf = 136446722;
                                      if (v842) {
                                        v744 = (const char *)(v842 + 604);
                                      }
                                      __int16 v895 = 2082;
                                      *(void *)v896 = v744;
                                      *(_WORD *)&v896[8] = 2082;
                                      *(void *)v897 = v743;
                                      _os_log_impl(&dword_214653000, v742, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s t_state %{public}s", buf, 0x20u);
                                    }
                                  }
                                }
                                tcp_close(v119);
                                goto LABEL_787;
                              default:
                                goto LABEL_1310;
                            }
                          }
                          v222 = v885;
                          os_log_type_t v39 = a6;
                          if ((*(unsigned char *)(v128 + 828) & 2) == 0)
                          {
                            v225 = __nwlog_tcp_log();
                            unsigned int v220 = os_log_type_enabled(v225, OS_LOG_TYPE_ERROR);
                            if (!v220) {
                              goto LABEL_564;
                            }
                            v226 = (const char *)(v128 + 604);
                            v894 = "tcp_input";
                            *(_DWORD *)long long buf = 136446722;
                            if (!v128) {
                              v226 = "";
                            }
                            __int16 v895 = 2082;
                            *(void *)v896 = v226;
                            *(_WORD *)&v896[8] = 1024;
                            *(_DWORD *)v897 = 0;
                            _os_log_impl(&dword_214653000, v225, OS_LOG_TYPE_ERROR, "%{public}s %{public}s win is smaller than 0: %d", buf, 0x1Cu);
                          }
                          unsigned int v220 = 0;
                          goto LABEL_564;
                        }
                        uint64_t v128 = v842;
                        uint64_t v119 = v830;
                        uint64_t v129 = v839;
                        uint64_t v17 = v17;
                        if (DWORD2(v914) != v191 || *(void *)v830 || v875 > (int)tcp_sbspace(v830)) {
                          goto LABEL_550;
                        }
                        if ((*(unsigned char *)(v830 + 740) & 0x20) != 0 && *(_DWORD *)(v830 + 564))
                        {
                          *(_DWORD *)(v830 + 612) = 0;
                          *(_OWORD *)(v830 + 580) = 0u;
                          *(_OWORD *)(v830 + 596) = 0u;
                          *(_OWORD *)(v830 + 564) = 0u;
                        }
                        v193 = *(void **)(v830 + 1056);
                        if (v193) {
                          ++v193[69];
                        }
                        int v194 = *(_DWORD *)(v830 + 120) + v875;
                        *(_DWORD *)(v830 + 120) = v194;
                        if (*(_DWORD *)(v830 + 1916) - v194 < 0)
                        {
                          *(_DWORD *)(v830 + 1916) = v194;
                          if (v888[0]) {
                            *(_DWORD *)(v830 + 1920) = DWORD1(v888[0]);
                          }
                        }
                        *(_DWORD *)(v830 + 104) = DWORD1(v914);
                        *(_DWORD *)(v830 + 136) = v194;
                        if (v193)
                        {
                          uint64_t v195 = v193[25] + v875;
                          v193[24] += v818;
                          v193[25] = v195;
                        }
                        uint64_t v196 = *(void **)(a3 + 248);
                        ++*v196;
                        if (v15)
                        {
                          ++**(void **)(a3 + 256);
                          if (!v16) {
                            goto LABEL_505;
                          }
                        }
                        else if (!v16)
                        {
LABEL_505:
                          if (!v17) {
                            goto LABEL_507;
                          }
                          goto LABEL_506;
                        }
                        ++**(void **)(a3 + 264);
                        if (!v17)
                        {
LABEL_507:
                          v196[1] += v875;
                          if (v15)
                          {
                            *(void *)(*(void *)(a3 + 256) + 8) += v875;
                            if (!v16) {
                              goto LABEL_509;
                            }
                          }
                          else if (!v16)
                          {
LABEL_509:
                            if (!v17) {
                              goto LABEL_511;
                            }
                            goto LABEL_510;
                          }
                          *(void *)(*(void *)(a3 + 264) + 8) += v875;
                          if (!v17)
                          {
LABEL_511:
                            tcp_compute_rcv_rtt(v830, (uint64_t)v888, (uint64_t)&v914);
                            tcp_sbrcv_grow(v830, v842 + 488, (uint64_t)v888, v875);
                            if (*(_DWORD *)(sysctls + 308) == 1
                              && (~*(_DWORD *)(v830 + 88) & 0x180) == 0
                              && (*(_DWORD *)(sysctls + 40) == 1 || (*(unsigned char *)(v842 + 369) & 0x40) != 0)
                              && off_26AA46360)
                            {
                              off_26AA46360(v830, (uint64_t)&v914, (uint64_t)v888, v875);
                            }
                            uint64_t v197 = *v885;
                            if (*v885)
                            {
                              if ((*(_WORD *)(v197 + 204) & 0x80) == 0) {
                                goto LABEL_1798;
                              }
                              unsigned int v198 = *(unsigned __int16 *)(v197 + 196);
                              BOOL v63 = v198 >= v837;
                              __int16 v199 = v198 - v837;
                              if (v63)
                              {
                                *(_WORD *)(v197 + 196) = v199;
                                goto LABEL_1798;
                              }
                              __nwlog_obj();
                              int v200 = *(unsigned __int16 *)(v197 + 196);
                              *(_DWORD *)long long buf = 136446722;
                              v894 = "__nw_frame_array_claim";
                              __int16 v895 = 1024;
                              *(_DWORD *)v896 = v200;
                              *(_WORD *)&v896[4] = 1024;
                              *(_DWORD *)&v896[6] = v837;
                              v201 = (void *)_os_log_send_and_compose_impl();
                              type[0] = OS_LOG_TYPE_ERROR;
                              char v892 = 0;
                              if (!__nwlog_fault()) {
                                goto LABEL_1795;
                              }
                              if (type[0] == OS_LOG_TYPE_FAULT)
                              {
                                v202 = __nwlog_obj();
                                os_log_type_t v203 = type[0];
                                if (os_log_type_enabled(v202, type[0]))
                                {
                                  int v204 = *(unsigned __int16 *)(v197 + 196);
                                  *(_DWORD *)long long buf = 136446722;
                                  v894 = "__nw_frame_array_claim";
                                  __int16 v895 = 1024;
                                  *(_DWORD *)v896 = v204;
                                  *(_WORD *)&v896[4] = 1024;
                                  *(_DWORD *)&v896[6] = v837;
                                  v205 = "%{public}s Aggregate buffer length: %u sum: %u";
LABEL_1793:
                                  v669 = v202;
                                  os_log_type_t v670 = v203;
LABEL_1794:
                                  _os_log_impl(&dword_214653000, v669, v670, v205, buf, 0x18u);
                                }
                              }
                              else if (v892)
                              {
                                v642 = (void *)__nw_create_backtrace_string();
                                v643 = __nwlog_obj();
                                BOOL v644 = os_log_type_enabled(v643, type[0]);
                                if (v642)
                                {
                                  if (v644)
                                  {
                                    int v645 = *(unsigned __int16 *)(v197 + 196);
                                    *(_DWORD *)long long buf = 136446978;
                                    v894 = "__nw_frame_array_claim";
                                    __int16 v895 = 1024;
                                    *(_DWORD *)v896 = v645;
                                    *(_WORD *)&v896[4] = 1024;
                                    *(_DWORD *)&v896[6] = v837;
                                    *(_WORD *)v897 = 2082;
                                    *(void *)&v897[2] = v642;
                                    _os_log_impl(&dword_214653000, v643, type[0], "%{public}s Aggregate buffer length: %u sum: %u, dumping backtrace:%{public}s", buf, 0x22u);
                                  }
                                  free(v642);
                                  goto LABEL_1795;
                                }
                                if (v644)
                                {
                                  int v699 = *(unsigned __int16 *)(v197 + 196);
                                  *(_DWORD *)long long buf = 136446722;
                                  v894 = "__nw_frame_array_claim";
                                  __int16 v895 = 1024;
                                  *(_DWORD *)v896 = v699;
                                  *(_WORD *)&v896[4] = 1024;
                                  *(_DWORD *)&v896[6] = v837;
                                  v205 = "%{public}s Aggregate buffer length: %u sum: %u, no backtrace";
                                  v669 = v643;
                                  os_log_type_t v670 = type[0];
                                  goto LABEL_1794;
                                }
                              }
                              else
                              {
                                v202 = __nwlog_obj();
                                os_log_type_t v203 = type[0];
                                if (os_log_type_enabled(v202, type[0]))
                                {
                                  int v668 = *(unsigned __int16 *)(v197 + 196);
                                  *(_DWORD *)long long buf = 136446722;
                                  v894 = "__nw_frame_array_claim";
                                  __int16 v895 = 1024;
                                  *(_DWORD *)v896 = v668;
                                  *(_WORD *)&v896[4] = 1024;
                                  *(_DWORD *)&v896[6] = v837;
                                  v205 = "%{public}s Aggregate buffer length: %u sum: %u, backtrace limit exceeded";
                                  goto LABEL_1793;
                                }
                              }
LABEL_1795:
                              if (v201) {
                                free(v201);
                              }
                              *(_WORD *)(v197 + 196) = 0;
                              goto LABEL_1798;
                            }
                            __nwlog_obj();
                            *(_DWORD *)long long buf = 136446210;
                            v894 = "__nw_frame_is_single_ip_aggregate";
                            v783 = (void *)_os_log_send_and_compose_impl();
                            type[0] = OS_LOG_TYPE_ERROR;
                            char v892 = 0;
                            if (__nwlog_fault())
                            {
                              if (type[0] == OS_LOG_TYPE_FAULT)
                              {
                                v784 = __nwlog_obj();
                                os_log_type_t v785 = type[0];
                                if (!os_log_type_enabled(v784, type[0])) {
                                  goto LABEL_2087;
                                }
                                *(_DWORD *)long long buf = 136446210;
                                v894 = "__nw_frame_is_single_ip_aggregate";
                                v786 = "%{public}s called with null frame";
LABEL_2085:
                                v796 = v784;
                                os_log_type_t v797 = v785;
LABEL_2086:
                                _os_log_impl(&dword_214653000, v796, v797, v786, buf, 0xCu);
                                goto LABEL_2087;
                              }
                              if (!v892)
                              {
                                v784 = __nwlog_obj();
                                os_log_type_t v785 = type[0];
                                if (!os_log_type_enabled(v784, type[0])) {
                                  goto LABEL_2087;
                                }
                                *(_DWORD *)long long buf = 136446210;
                                v894 = "__nw_frame_is_single_ip_aggregate";
                                v786 = "%{public}s called with null frame, backtrace limit exceeded";
                                goto LABEL_2085;
                              }
                              v791 = (void *)__nw_create_backtrace_string();
                              v792 = __nwlog_obj();
                              BOOL v793 = os_log_type_enabled(v792, type[0]);
                              if (v791)
                              {
                                if (v793)
                                {
                                  *(_DWORD *)long long buf = 136446466;
                                  v894 = "__nw_frame_is_single_ip_aggregate";
                                  __int16 v895 = 2082;
                                  *(void *)v896 = v791;
                                  _os_log_impl(&dword_214653000, v792, type[0], "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                                }
                                free(v791);
                                goto LABEL_2087;
                              }
                              if (v793)
                              {
                                *(_DWORD *)long long buf = 136446210;
                                v894 = "__nw_frame_is_single_ip_aggregate";
                                v786 = "%{public}s called with null frame, no backtrace";
                                v796 = v792;
                                os_log_type_t v797 = type[0];
                                goto LABEL_2086;
                              }
                            }
LABEL_2087:
                            if (v783) {
                              free(v783);
                            }
LABEL_1798:
                            uint64_t v671 = *v885;
                            if (*v885)
                            {
                              unsigned int v672 = 0;
                              while (1)
                              {
                                int v673 = *(_DWORD *)(v671 + 52);
                                int v674 = *(_DWORD *)(v671 + 56);
                                int v675 = *(_DWORD *)(v671 + 60);
                                unsigned int v676 = v673 - (v674 + v675);
                                if (v676 >= v837 - v672) {
                                  unsigned int v676 = v837 - v672;
                                }
                                unsigned int v677 = v673 ? v676 : 0;
                                int v678 = v674 + v677;
                                if (v674 + v677 <= v673 - v675)
                                {
                                  *(_DWORD *)(v671 + 56) = v678;
                                }
                                else
                                {
                                  v679 = __nwlog_obj();
                                  if (os_log_type_enabled(v679, OS_LOG_TYPE_ERROR))
                                  {
                                    int v680 = *(_DWORD *)(v671 + 52);
                                    *(_DWORD *)long long buf = 136446978;
                                    v894 = "__nw_frame_claim_internal";
                                    __int16 v895 = 1024;
                                    *(_DWORD *)v896 = v678;
                                    *(_WORD *)&v896[4] = 1024;
                                    *(_DWORD *)&v896[6] = v680;
                                    *(_WORD *)v897 = 1024;
                                    *(_DWORD *)&v897[2] = v675;
                                    _os_log_impl(&dword_214653000, v679, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
                                  }
                                }
                                v672 += v677;
                                if (v672 == v837) {
                                  break;
                                }
                                if (v672 < v837)
                                {
                                  uint64_t v671 = *(void *)(v671 + 32);
                                  if (v671) {
                                    continue;
                                  }
                                }
                                goto LABEL_1814;
                              }
                            }
                            else
                            {
                              unsigned int v672 = 0;
LABEL_1814:
                              if (v672 != v837)
                              {
                                v681 = __nwlog_obj();
                                if (os_log_type_enabled(v681, OS_LOG_TYPE_ERROR))
                                {
                                  *(_DWORD *)long long buf = 136446722;
                                  v894 = "__nw_frame_array_claim";
                                  __int16 v895 = 1024;
                                  *(_DWORD *)v896 = v672;
                                  *(_WORD *)&v896[4] = 1024;
                                  *(_DWORD *)&v896[6] = v837;
                                  _os_log_impl(&dword_214653000, v681, OS_LOG_TYPE_ERROR, "%{public}s start_offset %u != start_bytes %u", buf, 0x18u);
                                }
                              }
                            }
                            if (!v842 || (*(unsigned char *)(v842 + 828) & 2) == 0)
                            {
                              if (__nwlog_is_datapath_logging_enabled())
                              {
                                v787 = __nwlog_tcp_log();
                                if (os_log_type_enabled(v787, OS_LOG_TYPE_DEBUG))
                                {
                                  v788 = "";
                                  v894 = "tcp_input";
                                  *(_DWORD *)long long buf = 136446722;
                                  if (v842) {
                                    v788 = (const char *)(v842 + 604);
                                  }
                                  __int16 v895 = 2082;
                                  *(void *)v896 = v788;
                                  *(_WORD *)&v896[8] = 1024;
                                  *(_DWORD *)v897 = v891;
                                  _os_log_impl(&dword_214653000, v787, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s queueing frame of length %u - fastpath", buf, 0x1Cu);
                                }
                              }
                            }
                            *(_DWORD *)(v830 + 740) = *(_DWORD *)(v830 + 740) & 0xFFFFFFEF | (16
                                                                                            * ((BYTE13(v914) >> 3) & 1));
                            int v682 = v891;
                            unsigned int v683 = tcp_input_sbappendstream(v842, v885, v891, 2);
                            if (a4 && v683) {
                              *a4 = 1;
                            }
                            *(_WORD *)(v830 + 304) += v818;
                            v684 = *(unsigned int (**)(uint64_t, long long *))(tcp_cc_algo_list[*(unsigned __int8 *)(v830 + 264)]
                                                                                      + 96);
                            if (v684 && v684(v830, &v914))
                            {
                              int v685 = *(_DWORD *)(v830 + 88);
                              if ((v685 & 2) == 0)
                              {
                                *(_DWORD *)(v830 + 88) = v685 | 2;
                                *(_DWORD *)(v830 + 32) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v830 + 80) + 224))
                                                                   + 316)
                                                       - *(_DWORD *)(v830 + 64)
                                                       + 100;
                              }
                            }
                            else
                            {
                              *(_DWORD *)(v830 + 88) |= 1u;
                              tcp_output(v830);
                            }
                            tcp_adaptive_rwtimo_check(v830, v682);
                            if (v682 >= 1 && *(unsigned char *)(v830 + 993)) {
                              *(unsigned char *)(v830 + 993) = 0;
                            }
                            tcp_check_timer_state(v830);
                            (*(void (**)(uint64_t, uint64_t))(*(void *)(v842 + 8) + 24))(v842, 1);
                            *a6 = 0;
                            uint64_t result = (void *)*v885;
                            if (!*v885) {
                              return result;
                            }
                            while (1)
                            {
                              v686 = (void (*)(void *, uint64_t, uint64_t))result[10];
                              v687 = (void *)result[4];
                              if (!v686) {
                                break;
                              }
                              uint64_t v688 = result[11];
                              result[10] = 0;
                              result[11] = 0;
                              v686(result, 1, v688);
LABEL_1834:
                              uint64_t result = v687;
                              if (!v687) {
                                return result;
                              }
                            }
                            __nwlog_obj();
                            *(_DWORD *)long long buf = 136446210;
                            v894 = "__nw_frame_finalize";
                            uint64_t v689 = _os_log_send_and_compose_impl();
                            type[0] = OS_LOG_TYPE_ERROR;
                            char v892 = 0;
                            v882 = (void *)v689;
                            if (__nwlog_fault())
                            {
                              if (type[0] == OS_LOG_TYPE_FAULT)
                              {
                                v868 = __nwlog_obj();
                                if (!os_log_type_enabled(v868, type[0])) {
                                  goto LABEL_1850;
                                }
                                *(_DWORD *)long long buf = 136446210;
                                v894 = "__nw_frame_finalize";
                                v690 = v868;
                                os_log_type_t v691 = type[0];
                                v692 = "%{public}s called with null frame->finalizer";
                                goto LABEL_1849;
                              }
                              if (!v892)
                              {
                                v870 = __nwlog_obj();
                                if (!os_log_type_enabled(v870, type[0])) {
                                  goto LABEL_1850;
                                }
                                *(_DWORD *)long long buf = 136446210;
                                v894 = "__nw_frame_finalize";
                                v690 = v870;
                                os_log_type_t v691 = type[0];
                                v692 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
                                goto LABEL_1849;
                              }
                              v869 = (void *)__nw_create_backtrace_string();
                              loguint64_t i = __nwlog_obj();
                              BOOL v693 = os_log_type_enabled(logi, type[0]);
                              if (v869)
                              {
                                if (v693)
                                {
                                  *(_DWORD *)long long buf = 136446466;
                                  v894 = "__nw_frame_finalize";
                                  __int16 v895 = 2082;
                                  *(void *)v896 = v869;
                                  _os_log_impl(&dword_214653000, logi, type[0], "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
                                }
                                free(v869);
                                goto LABEL_1850;
                              }
                              if (v693)
                              {
                                *(_DWORD *)long long buf = 136446210;
                                v894 = "__nw_frame_finalize";
                                v690 = logi;
                                os_log_type_t v691 = type[0];
                                v692 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_1849:
                                _os_log_impl(&dword_214653000, v690, v691, v692, buf, 0xCu);
                              }
                            }
LABEL_1850:
                            if (v882) {
                              free(v882);
                            }
                            goto LABEL_1834;
                          }
LABEL_510:
                          *(void *)(*(void *)(a3 + 272) + 8) += v875;
                          goto LABEL_511;
                        }
LABEL_506:
                        ++**(void **)(a3 + 272);
                        goto LABEL_507;
                      }
                      int v185 = *(_DWORD *)(v830 + 744);
                      if (v185)
                      {
                        compute_iaj_meat(v830, *(_DWORD *)(v828 + 316) - v185);
                        int v184 = *(unsigned __int16 *)(v830 + 748);
                        goto LABEL_451;
                      }
                    }
                    uint64_t v192 = v830;
                    goto LABEL_525;
                  }
LABEL_401:
                  int v817 = 0;
                  goto LABEL_427;
                }
                if (v855 != 3 && ((char)v127 & 0x80000000) == 0) {
                  goto LABEL_401;
                }
                tcp_reset_stretch_ack(v830);
                uint64_t v163 = v828;
                *(_WORD *)(v830 + 308) = 16;
                *(_DWORD *)(v830 + 744) = 0;
                int v165 = *(_DWORD *)(v830 + 12);
              }
              if (v855 != 3)
              {
                int v817 = 0;
                goto LABEL_413;
              }
              if (v165 == 4)
              {
                int v178 = *(_DWORD *)(v830 + 348);
                goto LABEL_406;
              }
LABEL_411:
              int v817 = 1;
              goto LABEL_428;
            }
            if (v69 == v149)
            {
LABEL_367:
              tcp_input_ip_ecn(v830, a3, v875, v818, v855);
              uint64_t v163 = v828;
              int v164 = DWORD1(v914);
LABEL_392:
              if (v164 == *(_DWORD *)(v830 + 112) + 1 && !v814) {
                *(_DWORD *)(v830 + 360) = 6;
              }
              goto LABEL_395;
            }
            int v164 = DWORD1(v914);
            if (v875 < 1)
            {
              uint64_t v128 = v842;
            }
            else
            {
              int v171 = *(_DWORD *)(v830 + 284);
              if (DWORD1(v914) - v171 >= 0)
              {
                uint64_t v128 = v842;
                uint64_t v163 = v828;
                LOBYTE(v127) = v834;
                if (DWORD1(v914) - (v171 + *(_DWORD *)(v830 + 128)) >= 0) {
                  goto LABEL_392;
                }
                goto LABEL_367;
              }
              uint64_t v128 = v842;
            }
            uint64_t v163 = v828;
            LOBYTE(v127) = v834;
            goto LABEL_392;
          }
          if ((*(_WORD *)(v12 + 204) & 0x100) != 0
            && *MEMORY[0x263F144B8]
            && (((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(v12, *(void *)(v12 + 88)) & 1) == 0)
          {
            *(void *)(v830 + 1056) = 0;
            if (!v99) {
              goto LABEL_251;
            }
          }
          else
          {
            uint64_t v124 = *(void *)(v830 + 1056);
            if (v124) {
              ++*(void *)(v124 + 320);
            }
            if (!v99) {
              goto LABEL_251;
            }
          }
        }
        if ((*(unsigned char *)(v99 + 828) & 2) != 0)
        {
LABEL_257:
          in_pcb_checkstate(a3, 2, 1);
          unsigned int v40 = v885;
          int v51 = v838;
          os_log_type_t v39 = a6;
          goto LABEL_63;
        }
LABEL_251:
        os_log_t v125 = __nwlog_tcp_log();
        if (os_log_type_enabled(v125, OS_LOG_TYPE_INFO))
        {
          char v126 = "";
          if (v99) {
            char v126 = (const char *)(v99 + 604);
          }
          *(_DWORD *)long long buf = 136446466;
          v894 = "tcp_input";
          __int16 v895 = 2082;
          *(void *)v896 = v126;
          _os_log_impl(&dword_214653000, v125, OS_LOG_TYPE_INFO, "%{public}s %{public}s invalid checksum", buf, 0x16u);
        }
        goto LABEL_257;
      }
LABEL_165:
      uint64_t v99 = v842;
      if (v842 && (*(unsigned char *)(v842 + 828) & 2) != 0)
      {
        int v838 = 0;
        int v70 = 1;
        goto LABEL_228;
      }
      __nwlog_tcp_log();
      if (v842) {
        uint64_t v100 = (const char *)(v842 + 604);
      }
      else {
        uint64_t v100 = "";
      }
      *(_DWORD *)long long buf = 136446466;
      v894 = "tcp_compute_segment_length";
      __int16 v895 = 2082;
      *(void *)v896 = v100;
      uint64_t v101 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      char v892 = 0;
      if (!__nwlog_fault()) {
        goto LABEL_177;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        unsigned int v102 = __nwlog_tcp_log();
        os_log_type_t v103 = type[0];
        if (os_log_type_enabled(v102, type[0]))
        {
          *(_DWORD *)long long buf = 136446466;
          v894 = "tcp_compute_segment_length";
          __int16 v895 = 2082;
          *(void *)v896 = v100;
          unsigned int v104 = "%{public}s %{public}s Segment count is 0 for single-IP frame";
LABEL_176:
          _os_log_impl(&dword_214653000, v102, v103, v104, buf, 0x16u);
        }
      }
      else
      {
        unsigned int v102 = __nwlog_tcp_log();
        os_log_type_t v103 = type[0];
        if (os_log_type_enabled(v102, type[0]))
        {
          *(_DWORD *)long long buf = 136446466;
          v894 = "tcp_compute_segment_length";
          __int16 v895 = 2082;
          *(void *)v896 = v100;
          unsigned int v104 = "%{public}s %{public}s Segment count is 0 for single-IP frame, backtrace limit exceeded";
          goto LABEL_176;
        }
      }
LABEL_177:
      if (v101) {
        free(v101);
      }
      int v70 = 1;
      goto LABEL_180;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    v894 = "__nw_frame_get_segment_count";
    uint64_t v87 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v892 = 0;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        unsigned int v88 = __nwlog_obj();
        os_log_type_t v89 = type[0];
        if (!os_log_type_enabled(v88, type[0])) {
          goto LABEL_163;
        }
        *(_DWORD *)long long buf = 136446210;
        v894 = "__nw_frame_get_segment_count";
        unsigned int v90 = "%{public}s Attempt to get segment-count on a chain-member";
      }
      else
      {
        unsigned int v88 = __nwlog_obj();
        os_log_type_t v89 = type[0];
        if (!os_log_type_enabled(v88, type[0])) {
          goto LABEL_163;
        }
        *(_DWORD *)long long buf = 136446210;
        v894 = "__nw_frame_get_segment_count";
        unsigned int v90 = "%{public}s Attempt to get segment-count on a chain-member, backtrace limit exceeded";
      }
      _os_log_impl(&dword_214653000, v88, v89, v90, buf, 0xCu);
    }
LABEL_163:
    if (v87) {
      free(v87);
    }
    goto LABEL_165;
  }
  int v838 = 0;
  LODWORD(v69) = 0;
  int v70 = 0;
  char v71 = (const char *)(v842 + 604);
  if (!v842) {
    char v71 = "";
  }
  *(void *)v833 = v71;
  char v72 = 1;
  while (1)
  {
    if ((*(_WORD *)(v67 + 204) & 0x4000) == 0)
    {
      if ((v72 & 1) == 0) {
        goto LABEL_121;
      }
LABEL_125:
      int v73 = *(_DWORD *)(v67 + 52);
      if (!v73) {
        goto LABEL_126;
      }
      goto LABEL_105;
    }
    if ((v72 & 1) == 0) {
      break;
    }
    if (!v842 || (*(unsigned char *)(v842 + 828) & 2) == 0)
    {
      int v75 = __nwlog_tcp_log();
      int v838 = 1;
      if (os_log_type_enabled(v75, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 136446466;
        v894 = "tcp_compute_segment_length";
        __int16 v895 = 2082;
        *(void *)v896 = *(void *)v833;
        int v838 = 1;
        _os_log_impl(&dword_214653000, v75, OS_LOG_TYPE_INFO, "%{public}s %{public}s first frame is wake packet", buf, 0x16u);
        int v73 = *(_DWORD *)(v67 + 52);
        if (!v73) {
          goto LABEL_126;
        }
        goto LABEL_105;
      }
      goto LABEL_125;
    }
    int v838 = 1;
    int v73 = *(_DWORD *)(v67 + 52);
    if (!v73)
    {
LABEL_126:
      int v74 = 0;
      goto LABEL_106;
    }
LABEL_105:
    int v74 = v73 - (*(_DWORD *)(v67 + 56) + *(_DWORD *)(v67 + 60));
LABEL_106:
    char v72 = 0;
    uint64_t v69 = (v74 + v69);
    uint64_t v67 = *(void *)(v67 + 32);
    ++v70;
    if (!v67) {
      goto LABEL_224;
    }
  }
  if (!v842 || (*(unsigned char *)(v842 + 828) & 2) == 0)
  {
    __int16 v76 = __nwlog_tcp_log();
    if (os_log_type_enabled(v76, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 136446466;
      v894 = "tcp_compute_segment_length";
      __int16 v895 = 2082;
      *(void *)v896 = *(void *)v833;
      _os_log_impl(&dword_214653000, v76, OS_LOG_TYPE_INFO, "%{public}s %{public}s frame is wake packet", buf, 0x16u);
    }
  }
  int v77 = *(_WORD *)(v67 + 204) & 0xBFFF | (*(unsigned __int8 *)(v67 + 206) << 16);
  *(_WORD *)(v67 + 204) &= ~0x4000u;
  *(unsigned char *)(v67 + 206) = BYTE2(v77);
  if (*v885)
  {
    *(_WORD *)(*v885 + 204) |= 0x4000u;
    int v838 = 1;
    goto LABEL_121;
  }
  uint64_t v804 = v12;
  uint64_t v805 = a3;
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  v894 = "__nw_frame_set_is_wake_packet";
  type[0] = OS_LOG_TYPE_ERROR;
  char v892 = 0;
  int v81 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v82 = __nwlog_obj();
      if (os_log_type_enabled(v82, type[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        v894 = "__nw_frame_set_is_wake_packet";
        int v83 = v82;
        os_log_type_t v84 = type[0];
        uint64_t v85 = "%{public}s called with null frame";
        goto LABEL_135;
      }
    }
    else
    {
      uint64_t v86 = __nwlog_obj();
      if (os_log_type_enabled(v86, type[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        v894 = "__nw_frame_set_is_wake_packet";
        int v83 = v86;
        os_log_type_t v84 = type[0];
        uint64_t v85 = "%{public}s called with null frame, backtrace limit exceeded";
LABEL_135:
        _os_log_impl(&dword_214653000, v83, v84, v85, buf, 0xCu);
      }
    }
  }
  if (v81) {
    free(v81);
  }
  int v838 = 1;
  uint64_t v12 = v804;
  a3 = v805;
LABEL_121:
  uint64_t v78 = v16;
  if ((*(_WORD *)(v67 + 204) & 0x80) != 0) {
    *(_WORD *)(v67 + 196) -= v837;
  }
  unsigned int v79 = *(_DWORD *)(v67 + 56) + v837;
  int v80 = *(_DWORD *)(v67 + 60);
  if (v79 <= *(_DWORD *)(v67 + 52) - v80)
  {
    *(_DWORD *)(v67 + 56) = v79;
    uint64_t v16 = v78;
    goto LABEL_125;
  }
  uint64_t v91 = __nwlog_obj();
  if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
  {
    int v92 = *(_DWORD *)(v67 + 52);
    *(_DWORD *)long long buf = 136446978;
    v894 = "__nw_frame_claim_internal";
    __int16 v895 = 1024;
    *(_DWORD *)v896 = v79;
    *(_WORD *)&v896[4] = 1024;
    *(_DWORD *)&v896[6] = v92;
    *(_WORD *)v897 = 1024;
    *(_DWORD *)&v897[2] = v80;
    _os_log_impl(&dword_214653000, v91, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
  }
  unsigned int v40 = v885;
  if (!v842 || (*(unsigned char *)(v842 + 828) & 2) == 0)
  {
    __nwlog_tcp_log();
    int v93 = *(_DWORD *)(v67 + 52);
    if (v93) {
      v93 -= *(_DWORD *)(v67 + 56) + *(_DWORD *)(v67 + 60);
    }
    *(_DWORD *)long long buf = 136446978;
    v894 = "tcp_compute_segment_length";
    __int16 v895 = 2082;
    *(void *)v896 = *(void *)v833;
    *(_WORD *)&v896[8] = 1024;
    *(_DWORD *)v897 = v93;
    *(_WORD *)&v897[4] = 1024;
    *(_DWORD *)&v897[6] = v837;
    int v94 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v892 = 0;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v95 = __nwlog_tcp_log();
        os_log_type_t v96 = type[0];
        if (os_log_type_enabled(v95, type[0]))
        {
          int v97 = *(_DWORD *)(v67 + 52);
          if (v97) {
            v97 -= *(_DWORD *)(v67 + 56) + *(_DWORD *)(v67 + 60);
          }
          *(_DWORD *)long long buf = 136446978;
          v894 = "tcp_compute_segment_length";
          __int16 v895 = 2082;
          *(void *)v896 = *(void *)v833;
          *(_WORD *)&v896[8] = 1024;
          *(_DWORD *)v897 = v97;
          *(_WORD *)&v897[4] = 1024;
          *(_DWORD *)&v897[6] = v837;
          BOOL v98 = "%{public}s %{public}s chained frame len %u is smaller than TCP header size %u";
          goto LABEL_188;
        }
      }
      else
      {
        os_log_type_t v95 = __nwlog_tcp_log();
        os_log_type_t v96 = type[0];
        if (os_log_type_enabled(v95, type[0]))
        {
          int v105 = *(_DWORD *)(v67 + 52);
          if (v105) {
            v105 -= *(_DWORD *)(v67 + 56) + *(_DWORD *)(v67 + 60);
          }
          *(_DWORD *)long long buf = 136446978;
          v894 = "tcp_compute_segment_length";
          __int16 v895 = 2082;
          *(void *)v896 = *(void *)v833;
          *(_WORD *)&v896[8] = 1024;
          *(_DWORD *)v897 = v105;
          *(_WORD *)&v897[4] = 1024;
          *(_DWORD *)&v897[6] = v837;
          BOOL v98 = "%{public}s %{public}s chained frame len %u is smaller than TCP header size %u, backtrace limit exceeded";
LABEL_188:
          _os_log_impl(&dword_214653000, v95, v96, v98, buf, 0x22u);
        }
      }
    }
    if (v94) {
      free(v94);
    }
  }
  uint64_t v106 = *(void *)(v830 + 1056);
  if (v106) {
    ++*(void *)(v106 + 152);
  }
  os_log_type_t v39 = a6;
  int v51 = v838;
  if (!v842 || (*(unsigned char *)(v842 + 828) & 2) == 0)
  {
    v107 = __nwlog_tcp_log();
    if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446466;
      v894 = "tcp_input";
      __int16 v895 = 2082;
      *(void *)v896 = *(void *)v833;
      _os_log_impl(&dword_214653000, v107, OS_LOG_TYPE_ERROR, "%{public}s %{public}s invalid frame list", buf, 0x16u);
    }
  }
  in_pcb_checkstate(a3, 2, 1);
LABEL_63:
  *os_log_type_t v39 = v51 != 0;
  uint64_t result = (void *)*v40;
  if (*v40)
  {
    while (2)
    {
      uint64_t v53 = (void (*)(void *, uint64_t, uint64_t))result[10];
      int v54 = (void *)result[4];
      if (v53)
      {
        uint64_t v55 = result[11];
        result[10] = 0;
        result[11] = 0;
        v53(result, 1, v55);
        goto LABEL_66;
      }
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      v894 = "__nw_frame_finalize";
      uint64_t v56 = _os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      char v892 = 0;
      v874 = (void *)v56;
      if (!__nwlog_fault()) {
        goto LABEL_82;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v856 = __nwlog_obj();
        os_log_type_t loga = type[0];
        if (os_log_type_enabled(v856, type[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          v894 = "__nw_frame_finalize";
          uint64_t v57 = v856;
          os_log_type_t v58 = loga;
          uint64_t v59 = "%{public}s called with null frame->finalizer";
          break;
        }
        goto LABEL_82;
      }
      if (v892)
      {
        v857 = (void *)__nw_create_backtrace_string();
        os_log_type_t logb = __nwlog_obj();
        os_log_type_t v841 = type[0];
        BOOL v60 = os_log_type_enabled(logb, type[0]);
        uint64_t v61 = v857;
        if (v857)
        {
          if (v60)
          {
            *(_DWORD *)long long buf = 136446466;
            v894 = "__nw_frame_finalize";
            __int16 v895 = 2082;
            *(void *)v896 = v857;
            _os_log_impl(&dword_214653000, logb, v841, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
            uint64_t v61 = v857;
          }
          free(v61);
          goto LABEL_82;
        }
        if (!v60)
        {
LABEL_82:
          if (v874) {
            free(v874);
          }
LABEL_66:
          uint64_t result = v54;
          if (!v54) {
            return result;
          }
          continue;
        }
        *(_DWORD *)long long buf = 136446210;
        v894 = "__nw_frame_finalize";
        uint64_t v57 = logb;
        os_log_type_t v58 = v841;
        uint64_t v59 = "%{public}s called with null frame->finalizer, no backtrace";
      }
      else
      {
        v858 = __nwlog_obj();
        os_log_type_t logc = type[0];
        if (!os_log_type_enabled(v858, type[0])) {
          goto LABEL_82;
        }
        *(_DWORD *)long long buf = 136446210;
        v894 = "__nw_frame_finalize";
        uint64_t v57 = v858;
        os_log_type_t v58 = logc;
        uint64_t v59 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
      }
      break;
    }
    _os_log_impl(&dword_214653000, v57, v58, v59, buf, 0xCu);
    goto LABEL_82;
  }
  return result;
}

uint64_t tcp_keepalive_reset(uint64_t a1)
{
  uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
  int v3 = *(_DWORD *)(a1 + 676);
  if (!v3 || (*(unsigned char *)(*(void *)(*(void *)(a1 + 80) + 224) + 372) & 8) == 0) {
    int v3 = *(_DWORD *)(sysctls + 192);
  }
  *(_DWORD *)(a1 + 40) = v3 + *(_DWORD *)(result + 316) - *(_DWORD *)(a1 + 64);
  *(_DWORD *)(a1 + 740) &= ~0x80u;
  *(unsigned char *)(a1 + 311) = 0;
  return result;
}

uint64_t tcp_sbrcv_grow(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = *(void *)(a2 + 72);
  uint64_t result = nw_tcp_access_globals(v8);
  uint64_t v10 = result;
  if (*(_DWORD *)(sysctls + 68))
  {
    if ((*(unsigned char *)(a2 + 49) & 4) != 0)
    {
      unsigned int v11 = *(_DWORD *)(a2 + 4);
      unsigned int v12 = *(_DWORD *)(sysctls + 72);
      if (v11 < v12
        && (*(unsigned char *)(a1 + 741) & 1) == 0
        && (*(unsigned char *)(v8 + 368) & 0x40) == 0
        && (*(_DWORD *)(sysctls + 260) || !*(void *)a1))
      {
        if ((~*(_DWORD *)(a1 + 88) & 0x180) != 0)
        {
          int v25 = *(_DWORD *)(result + 316);
          int v26 = *(_DWORD *)(a1 + 180) + (*(_DWORD *)(a1 + 1968) >> 5);
          unsigned int v27 = *(_DWORD *)(a1 + 184) + a4;
          *(_DWORD *)(a1 + 184) = v27;
          if (v25 - v26 < 0) {
            return result;
          }
          unsigned int v28 = *(_DWORD *)(a1 + 188);
          if (v27 > v28)
          {
            char v29 = v27 <= v28 + (v28 >> 1) ? 1 : 2;
            unsigned int v30 = v27 << v29;
            int v31 = (v27 << v29) - v11;
            if (v31 >= 1)
            {
              uint64_t result = tcp_sbrcv_reserve(a1, a2, v11 + v31 / *(_DWORD *)(a1 + 196) * *(_DWORD *)(a1 + 196), v30, v12);
              *(_DWORD *)(a1 + 188) = *(_DWORD *)(a1 + 184);
            }
          }
        }
        else
        {
          int v13 = *(_DWORD *)(a3 + 8);
          if (v13)
          {
            int v14 = *(_DWORD *)(a1 + 180);
            unsigned int v15 = *(_DWORD *)(a1 + 184) + a4;
            *(_DWORD *)(a1 + 184) = v15;
            if (v13 - v14 < 0) {
              return result;
            }
            unsigned int v16 = *(_DWORD *)(a1 + 188);
            if (v15 > v16)
            {
              char v17 = v15 <= v16 + (v16 >> 1) ? 1 : 2;
              unsigned int v18 = v15 << v17;
              int v19 = (v15 << v17) - v11;
              *(_DWORD *)(a1 + 188) = v15;
              if (v19 >= 1) {
                uint64_t result = tcp_sbrcv_reserve(a1, a2, v11 + v19 / *(_DWORD *)(a1 + 196) * *(_DWORD *)(a1 + 196), v18, v12);
              }
            }
            uint64_t v20 = *(void *)(a1 + 768);
            if (v20)
            {
              unsigned int v21 = *(_DWORD *)(a1 + 184);
              if (v21)
              {
                int v22 = *(_DWORD *)(v10 + 316) - *(_DWORD *)(a1 + 180);
                if (v22 >= 1)
                {
                  unsigned int v23 = *(_DWORD *)(v20 + 36);
                  unsigned int v24 = v21 / v22;
                  if (v23)
                  {
                    if (v23 > v24) {
                      unsigned int v24 = *(_DWORD *)(v20 + 36);
                    }
                  }
                  *(_DWORD *)(v20 + 36) = v24;
                }
              }
            }
          }
        }
      }
    }
  }
  *(void *)(a1 + 180) = *(unsigned int *)(v10 + 316);
  return result;
}

uint64_t tcp_adaptive_rwtimo_check(uint64_t result, int a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(void *)(result + 80);
  if (*(unsigned char *)(result + 265))
  {
    if (a2 < 1) {
      return result;
    }
  }
  else
  {
    uint64_t v4 = *(void *)(v3 + 448);
    if (!v4 || a2 < 1 || (*(_DWORD *)(v4 + 1052) & 8) == 0) {
      return result;
    }
  }
  if (*(_DWORD *)(result + 12) == 4)
  {
    uint64_t result = nw_tcp_access_globals(*(void *)(v3 + 224));
    uint64_t v5 = *(unsigned int *)(v2 + 228);
    if (v5 <= (*(_DWORD *)(v2 + 208) + (*(int *)(v2 + 200) >> 3)) >> 2) {
      LODWORD(v5) = (*(_DWORD *)(v2 + 208) + (*(int *)(v2 + 200) >> 3)) >> 2;
    }
    *(_DWORD *)(v2 + 40) = *(_DWORD *)(result + 316) - *(_DWORD *)(v2 + 64) + 2 * v5;
    *(_DWORD *)(v2 + 740) |= 0x80u;
    *(unsigned char *)(v2 + 311) = 0;
  }
  return result;
}

uint64_t update_iaj_state(uint64_t result, unsigned int a2)
{
  if (*(_WORD *)(result + 748)) {
    BOOL v2 = *(unsigned __int16 *)(result + 748) > a2;
  }
  else {
    BOOL v2 = 0;
  }
  if (!v2)
  {
    uint64_t v3 = result;
    *(_WORD *)(result + 748) = a2;
    uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(result + 80) + 224));
    *(_DWORD *)(v3 + 744) = *(_DWORD *)(result + 316);
    *(unsigned char *)(v3 + 750) = 0;
  }
  return result;
}

uint64_t tcp_update_window(uint64_t a1, char a2, uint64_t a3, unsigned int a4, int a5)
{
  if ((a2 & 0x10) == 0) {
    return 0;
  }
  int v8 = *(_DWORD *)(a1 + 104);
  int v9 = *(_DWORD *)(a3 + 4);
  if (v8 - v9 >= 0)
  {
    if (v8 != v9) {
      return 0;
    }
    int v10 = *(_DWORD *)(a1 + 108);
    int v11 = *(_DWORD *)(a3 + 8);
    if (v10 - v11 >= 0 && (v10 != v11 || *(_DWORD *)(a1 + 140) >= a4)) {
      return 0;
    }
  }
  if (!a5 && *(_DWORD *)(a1 + 108) == *(_DWORD *)(a3 + 8) && *(_DWORD *)(a1 + 140) < a4)
  {
    uint64_t v12 = *(void *)(a1 + 1056);
    if (v12) {
      ++*(void *)(v12 + 296);
    }
  }
  *(_DWORD *)(a1 + 140) = a4;
  if (*(void *)(*(void *)(*(void *)(a1 + 80) + 224) + 24))
  {
    uint64_t all_stats = nw_protocol_tcp_get_all_stats();
    a4 = *(_DWORD *)(a1 + 140);
    if (all_stats)
    {
      *(_DWORD *)(all_stats + 112) = a4;
      a4 = *(_DWORD *)(a1 + 140);
    }
  }
  *(void *)(a1 + 104) = *(void *)(a3 + 4);
  if (a4 > *(_DWORD *)(a1 + 252)) {
    *(_DWORD *)(a1 + 252) = a4;
  }
  return 1;
}

void tcp_bad_rexmt_check(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_WORD *)(a1 + 226) && tcp_detect_bad_rexmt(a1, a2, a3, *(_DWORD *)(a1 + 248)))
  {
    uint64_t v6 = *(void *)(a1 + 1056);
    if (v6) {
      ++*(void *)(v6 + 1312);
    }
    tcp_bad_rexmt_restore_state(a1, a2);
  }
  else if ((~*(_DWORD *)(a1 + 740) & 0x40001000) != 0 {
         || (int v7 = *(_DWORD *)(a1 + 928)) == 0
  }
         || *(_DWORD *)(a2 + 8) - v7 < 0
         || tcp_detect_bad_rexmt(a1, a2, a3, *(_DWORD *)(a1 + 936)))
  {
    uint64_t v8 = *(void *)(a1 + 952);
    if (v8 && *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 152) >= 0)
    {
      int v9 = (void *)(a1 + 952);
      while ((*(_WORD *)(v8 + 10) & 1) != 0)
      {
        uint64_t v8 = *(void *)(v8 + 16);
        if (!v8)
        {
          uint64_t v10 = *(void *)(a1 + 1056);
          if (v10) {
            ++*(void *)(v10 + 1032);
          }
          tcp_bad_rexmt_restore_state(a1, a2);
          int v11 = *(void **)(a1 + 952);
          if (v11)
          {
            do
            {
              char v17 = (void *)*v9;
              unsigned int v18 = (void *)(a1 + 952);
              if ((void *)*v9 != v11)
              {
                do
                {
                  int v19 = v17;
                  char v17 = (void *)v17[2];
                }
                while (v17 != v11);
                unsigned int v18 = v19 + 2;
              }
              unsigned int v16 = (void *)v11[2];
              *unsigned int v18 = v16;
              nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
              free(v11);
              int v11 = v16;
            }
            while (v16);
          }
          *(_DWORD *)(a1 + 960) = *(_DWORD *)(a1 + 96);
          break;
        }
      }
    }
  }
  else
  {
    uint64_t v20 = *(void *)(a1 + 1056);
    if (v20) {
      ++*(void *)(v20 + 752);
    }
    int v21 = *(_DWORD *)(a1 + 88);
    if ((v21 & 0x200000) == 0)
    {
      int v22 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 64);
      if (v22)
      {
        v22(a1);
        int v21 = *(_DWORD *)(a1 + 88);
      }
      *(_DWORD *)(a1 + 88) = v21 | 0x200000;
      uint64_t v23 = *(void *)(a1 + 80);
      if ((*(unsigned char *)(v23 + 2231) & 0x40) != 0) {
        inp_reset_fc_state(v23);
      }
      if (*(void *)(a1 + 952)) {
        tcp_rxtseg_clean(a1);
      }
      int v24 = *(_DWORD *)(a1 + 88);
      *(_DWORD *)(a1 + 152) = *(_DWORD *)(a1 + 96) + (v24 << 27 >> 31);
      int v25 = *(_DWORD *)(a1 + 740);
      *(_DWORD *)(a1 + 28) = 0;
      *(_DWORD *)(a1 + 172) = 0;
      *(_DWORD *)(a1 + 144) = *(_DWORD *)(a1 + 148);
      *(_DWORD *)(a1 + 88) = v24 & 0xFFDFFFFF;
      *(_DWORD *)(a1 + 8) = 0;
      *(unsigned char *)(a1 + 310) = 3;
      *(_DWORD *)(a1 + 288) = 0;
      *(_DWORD *)(a1 + 348) &= ~0x20u;
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 740) = v25 & 0xFFE7FFFF;
      *(_DWORD *)(a1 + 984) = 0;
      *(_DWORD *)(a1 + 628) = 0;
    }
  }
  *(_DWORD *)(a1 + 740) &= ~0x1000u;
  *(_DWORD *)(a1 + 928) = 0;
  *(_DWORD *)(a1 + 936) = 0;
  if (*(_WORD *)(a1 + 226))
  {
    int v12 = *(_DWORD *)(a1 + 88);
    if ((v12 & 0x20000000) != 0)
    {
      int v13 = *(_DWORD *)(a1 + 700);
      if (~v12 & 0x180) == 0 && v13 != 0 && (*(unsigned char *)a3)
      {
        int v15 = *(_DWORD *)(a3 + 8);
        if (v15)
        {
          if (v15 - v13 < 0) {
            tcp_pmtud_revert_segment_size(a1);
          }
        }
      }
    }
  }
  if (*(_DWORD *)(a1 + 700)) {
    *(_DWORD *)(a1 + 700) = 0;
  }
  *(_WORD *)(a1 + 696) = 0;
}

void tcp_compute_rtt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2 || !a3)
  {
    uint64_t v20 = __nwlog_obj();
    os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
    int v21 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }
    free(v21);
  }
  uint64_t v6 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
  int v7 = *(_DWORD *)(a1 + 172);
  if (v7)
  {
    int v8 = *(_DWORD *)(a3 + 8);
    if (v8 - *(_DWORD *)(a1 + 176) >= 1)
    {
      signed int v9 = *(_DWORD *)(v6 + 316) - v7;
      if (v9) {
        signed int v10 = v9;
      }
      else {
        signed int v10 = 1;
      }
      int v11 = v8 - *(_DWORD *)(a1 + 976);
      if (v11 < 1) {
        goto LABEL_23;
      }
      uint64_t v12 = *(unsigned __int8 *)(a1 + 751);
      *(_DWORD *)(a1 + 964 + 4 * v12) = v11;
      *(unsigned char *)(a1 + 751) = (v12 + 1) % 3u;
      unsigned int v13 = *(_DWORD *)(a1 + 964);
      if (v13 <= *(_DWORD *)(a1 + 968)) {
        unsigned int v13 = *(_DWORD *)(a1 + 968);
      }
      if (*(_DWORD *)(a1 + 972) > v13) {
        unsigned int v13 = *(_DWORD *)(a1 + 972);
      }
      if (*(_DWORD *)(sysctls + 304))
      {
        int v14 = *(_DWORD *)(sysctls + 16);
      }
      else
      {
        if (!*(_DWORD *)(sysctls + 276))
        {
          unsigned int v15 = 4380;
          goto LABEL_20;
        }
        int v14 = 10;
      }
      unsigned int v15 = *(_DWORD *)(a1 + 196) * v14;
LABEL_20:
      if (v13 <= v15) {
        unsigned int v13 = 0;
      }
      *(_DWORD *)(a1 + 980) = v13;
LABEL_23:
      *(_DWORD *)(a1 + 172) = 0;
      if ((*(unsigned char *)a2 & 1) == 0) {
        goto LABEL_27;
      }
      goto LABEL_24;
    }
  }
  signed int v10 = 0;
  if ((*(unsigned char *)a2 & 1) == 0) {
    goto LABEL_27;
  }
LABEL_24:
  int v16 = *(_DWORD *)(a2 + 8);
  if (v16)
  {
    int v17 = *(_DWORD *)(v6 + 316) - v16;
    if (v17 >= 0)
    {
      int v18 = *(_DWORD *)(a3 + 8);
      uint64_t v19 = a1;
      signed int v10 = v17;
      goto LABEL_29;
    }
  }
LABEL_27:
  if (v10 < 1) {
    return;
  }
  int v18 = *(_DWORD *)(a3 + 8);
  uint64_t v19 = a1;
  int v16 = 0;
LABEL_29:
  tcp_xmit_timer(v19, v10, v16, v18);
}

uint64_t tcp_tfo_rcv_ack(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)(result + 993) == 1)
  {
    BOOL v2 = (_DWORD *)result;
    if (*(unsigned char *)(result + 992))
    {
      int v3 = *(_DWORD *)(a2 + 4) - *(_DWORD *)(result + 120);
      if (v3)
      {
        if (v3 >= 1)
        {
          *(unsigned char *)(result + 993) = 2;
          uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(result + 80) + 224));
          uint64_t v4 = v2[57];
          if (v4 <= (v2[52] + ((int)v2[50] >> 3)) >> 2) {
            LODWORD(v4) = (v2[52] + ((int)v2[50] >> 3)) >> 2;
          }
          v2[10] = *(_DWORD *)(result + 316) - v2[16] + v4;
        }
      }
      else
      {
        *(unsigned char *)(result + 993) = 0;
      }
    }
  }
  return result;
}

uint64_t tcp_rack_update_reordering_window(uint64_t result, int a2)
{
  char v2 = *(unsigned char *)(result + 2069);
  if (a2 - *(_DWORD *)(result + 2060) < 0)
  {
    v2 &= ~0x40u;
    *(unsigned char *)(result + 2069) = v2;
    if ((v2 & 0x40) == 0)
    {
LABEL_3:
      if ((v2 & 0x1F) == 0) {
        *(unsigned char *)(result + 2068) = 1;
      }
      return result;
    }
  }
  else if ((*(unsigned char *)(result + 2069) & 0x40) == 0)
  {
    goto LABEL_3;
  }
  *(_DWORD *)(result + 2060) = *(_DWORD *)(result + 100);
  __int16 v3 = *(unsigned __int8 *)(result + 2068);
  if (((v3 + 1) & 0x100) != 0) {
    char v4 = -1;
  }
  else {
    char v4 = v3 + 1;
  }
  *(unsigned char *)(result + 2068) = v4;
  *(unsigned char *)(result + 2069) = v2 & 0xA0 | 0x10;
  return result;
}

uint64_t tcp_update_snd_una(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 92) = a2;
  uint64_t result = *(void *)(*(void *)(*(void *)(a1 + 80) + 224) + 24);
  if (result)
  {
    uint64_t result = nw_protocol_tcp_get_all_stats();
    if (result) {
      *(_DWORD *)(result + 108) = *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92);
    }
  }
  return result;
}

void tcp_segs_doack(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (*(void *)(a1 + 1984))
  {
    int v6 = (a3 << 31 >> 31) & a4;
    if (*(char *)(a1 + 2069) < 0
      || (uint64_t v7 = **(void **)(*(void *)(a1 + 1992) + 8), v8 = *(_DWORD *)(v7 + 4), (int)a2 - v8 < 0))
    {
      uint64_t v15 = *(void *)(a1 + 2000);
      if (!v15) {
        return;
      }
      uint64_t v16 = *(void *)(a1 + 2000);
      do
      {
        while (1)
        {
          int v17 = *(_DWORD *)(v16 + 4);
          if ((int)a2 - v17 >= 0) {
            break;
          }
          uint64_t v16 = *(void *)(v16 + 32);
          if (!v16) {
            goto LABEL_11;
          }
        }
        if (a2 == v17)
        {
          unsigned int v24 = *(_DWORD *)(v16 + 8);
          int v10 = (*(unsigned __int8 *)(v16 + 12) >> 3) & 1;
          tcp_seg_collect_acked(a1, v15, a2);
          tcp_seg_delete_acked(a1, v24, v6);
          goto LABEL_28;
        }
        uint64_t v16 = *(void *)(v16 + 40);
      }
      while (v16);
LABEL_11:
      unint64_t v18 = *(void *)(a1 + 2000);
      do
      {
        unint64_t v19 = v18;
        unint64_t v18 = *(void *)(v18 + 32);
      }
      while (v18);
      while (1)
      {
        unint64_t v20 = *(void *)(v19 + 40);
        if (v20)
        {
          do
          {
            unint64_t v21 = v20;
            unint64_t v20 = *(void *)(v20 + 32);
          }
          while (v20);
        }
        else
        {
          unint64_t v21 = *(void *)(v19 + 48) & 0xFFFFFFFFFFFFFFFELL;
          if (!v21 || *(void *)(v21 + 32) != v19)
          {
            unint64_t v22 = v19;
            do
            {
              unint64_t v21 = *(void *)(v22 + 48) & 0xFFFFFFFFFFFFFFFELL;
              if (!v21) {
                break;
              }
              BOOL v23 = v22 == *(void *)(v21 + 40);
              unint64_t v22 = *(void *)(v22 + 48) & 0xFFFFFFFFFFFFFFFELL;
            }
            while (v23);
          }
        }
        if ((int)a2 - *(_DWORD *)(v19 + 4) < 0 && (int)a2 - *(_DWORD *)v19 >= 1) {
          break;
        }
        unint64_t v19 = v21;
        if (!v21) {
          return;
        }
      }
      unsigned int v24 = *(_DWORD *)(v19 + 8);
      int v10 = (*(unsigned __int8 *)(v19 + 12) >> 3) & 1;
      tcp_seg_collect_acked(a1, v15, a2);
      tcp_seg_delete_acked(a1, v24, v6);
      *(_DWORD *)unint64_t v19 = a2;
LABEL_28:
      uint64_t v11 = a1;
      int v12 = v6;
      unsigned int v13 = v24;
      int v14 = a2;
    }
    else
    {
      unsigned int v9 = *(_DWORD *)(v7 + 8);
      int v10 = (*(unsigned __int8 *)(v7 + 12) >> 3) & 1;
      tcp_segs_sent_clean(a1, 0);
      uint64_t v11 = a1;
      int v12 = v6;
      unsigned int v13 = v9;
      int v14 = v8;
    }
    tcp_rack_update_segment_acked(v11, v12, v13, v14, v10);
  }
}

uint64_t tcp_bwmeas_check(uint64_t result)
{
  uint64_t v1 = *(_DWORD **)(result + 768);
  int v2 = *(_DWORD *)(result + 92) - *v1;
  if (v2 >= 1)
  {
    uint64_t v3 = result;
    if ((*(unsigned char *)(result + 740) & 4) != 0 && v2 >= v1[2])
    {
      uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(result + 80) + 224));
      char v4 = *(_DWORD **)(v3 + 768);
      unsigned int v5 = *(_DWORD *)(result + 316) - v4[1];
      if (v5 && v5 <= v2)
      {
        unsigned int v6 = v2 / v5;
        int v7 = v4[7];
        unsigned int v8 = v4[8];
        if (v7) {
          unsigned int v6 = (v6 - v7 + 8 * v7) >> 3;
        }
        if (v6 <= v8) {
          unsigned int v9 = v4[8];
        }
        else {
          unsigned int v9 = v6;
        }
        if (!v8) {
          unsigned int v9 = v6;
        }
        v4[7] = v6;
        v4[8] = v9;
      }
      *(_DWORD *)(v3 + 740) &= ~4u;
    }
  }
  return result;
}

BOOL tcp_rack_detect_loss_and_arm_timer(uint64_t a1, unsigned int a2)
{
  BOOL result = 0;
  char v6 = 0;
  if ((*(unsigned char *)(a1 + 2069) & 0x20) != 0)
  {
    *(_DWORD *)(a1 + 24) = 0;
    int v4 = tcp_rack_detect_loss(a1, a2, &v6);
    if (v4)
    {
      int v5 = v4
         + *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 316)
         - *(_DWORD *)(a1 + 64)
         + 2;
      *(_DWORD *)(a1 + 16) = 0;
    }
    else
    {
      int v5 = 0;
    }
    *(_DWORD *)(a1 + 24) = v5;
    return v6 != 0;
  }
  return result;
}

uint64_t tcp_rack_detect_loss(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  uint64_t v6 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
  if (*(_DWORD *)(a1 + 1016) || (*(unsigned char *)(a1 + 90) & 0x20) == 0 && *(unsigned __int8 *)(a1 + 310) > a2)
  {
    int v7 = *(unsigned __int8 *)(a1 + 2068);
    uint64_t v8 = *(void *)(*(void *)(a1 + 80) + 496);
    if (v8)
    {
      uint64_t v9 = *(void *)(v8 + 1488);
      if (v9) {
        LODWORD(v9) = *(_DWORD *)(v9 + 40) >> 2;
      }
      unsigned int v10 = v9 * v7;
      unsigned int v11 = *(int *)(a1 + 200) >> 5;
      if (v10 >= v11)
      {
LABEL_16:
        if (v11 <= 2) {
          int v13 = 2;
        }
        else {
          int v13 = v11;
        }
        uint64_t v14 = *(void *)(a1 + 1984);
        if (!v14) {
          return 0;
        }
        goto LABEL_20;
      }
      uint64_t v12 = *(void *)(v8 + 1488);
      if (v12) {
        LODWORD(v12) = *(_DWORD *)(v12 + 40) >> 2;
      }
    }
    else
    {
      unsigned int v11 = *(int *)(a1 + 200) >> 5;
      if (!v11) {
        goto LABEL_16;
      }
      LODWORD(v12) = 0;
    }
    unsigned int v11 = v12 * v7;
    goto LABEL_16;
  }
  int v13 = 0;
  uint64_t v14 = *(void *)(a1 + 1984);
  if (!v14) {
    return 0;
  }
LABEL_20:
  int v17 = *(_DWORD *)(v6 + 316);
  uint64_t v15 = 0;
  if (a3)
  {
    do
    {
      unsigned int v18 = *(_DWORD *)(a1 + 2048);
      unsigned int v19 = *(_DWORD *)(v14 + 8);
      if (v18 <= v19 && (v18 != v19 || *(_DWORD *)(a1 + 2052) - *(_DWORD *)(v14 + 4) < 1)) {
        break;
      }
      if ((*(unsigned char *)(v14 + 12) & 6) != 2 && (*(unsigned char *)(v14 + 12) & 1) == 0)
      {
        int v22 = v19 + v13 + *(_DWORD *)(a1 + 2056);
        if (v17 - v22 >= 0)
        {
          tcp_mark_seg_lost(a1, v14);
          *a3 = 1;
        }
        else
        {
          LODWORD(v23) = v22 - v17;
          if (v22 - v17 <= v15) {
            uint64_t v23 = v15;
          }
          else {
            uint64_t v23 = v23;
          }
          if (v22 != v17) {
            uint64_t v15 = v23;
          }
        }
      }
      uint64_t v14 = *(void *)(v14 + 16);
    }
    while (v14);
  }
  else
  {
    do
    {
      unsigned int v24 = *(_DWORD *)(a1 + 2048);
      unsigned int v25 = *(_DWORD *)(v14 + 8);
      if (v24 <= v25 && (v24 != v25 || *(_DWORD *)(a1 + 2052) - *(_DWORD *)(v14 + 4) < 1)) {
        break;
      }
      if ((*(unsigned char *)(v14 + 12) & 6) != 2 && (*(unsigned char *)(v14 + 12) & 1) == 0)
      {
        int v28 = v25 + v13 + *(_DWORD *)(a1 + 2056);
        if (v17 - v28 >= 0)
        {
          tcp_mark_seg_lost(a1, v14);
        }
        else
        {
          LODWORD(v29) = v28 - v17;
          if (v28 - v17 <= v15) {
            uint64_t v29 = v15;
          }
          else {
            uint64_t v29 = v29;
          }
          if (v28 != v17) {
            uint64_t v15 = v29;
          }
        }
      }
      uint64_t v14 = *(void *)(v14 + 16);
    }
    while (v14);
  }
  return v15;
}

void tcp_cubic_ack_rcvd(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 980);
  if (v2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 144);
    if (v2 < v3 >> 1)
    {
      uint64_t v4 = *(void *)(*(void *)(a1 + 80) + 224);
      if (!v4 || *(_DWORD *)(v4 + 384) <= v3)
      {
        *(_DWORD *)(a1 + 740) |= 0x100000u;
        return;
      }
    }
    *(_DWORD *)(a1 + 740) &= ~0x100000u;
  }
  else
  {
    *(_DWORD *)(a1 + 740) &= ~0x100000u;
    unsigned int v3 = *(_DWORD *)(a1 + 144);
  }
  if (v3 >= *(_DWORD *)(a1 + 148))
  {
    tcp_cubic_congestion_avd(a1, a2);
  }
  else
  {
    unsigned int v5 = *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 92);
    if (*(_DWORD *)(sysctls + 276))
    {
      if (*(_DWORD *)(sysctls + 304)) {
        int v6 = *(_DWORD *)(sysctls + 16);
      }
      else {
        int v6 = 10;
      }
      unsigned int v7 = *(_DWORD *)(a1 + 196) * v6;
    }
    else
    {
      unsigned int v7 = *(_DWORD *)(a1 + 196) << (*(_DWORD *)(a1 + 100) == *(_DWORD *)(a1 + 96));
    }
    if (v5 >= v7) {
      unsigned int v5 = v7;
    }
    uint64_t v8 = v5 + v3;
    char v9 = *(unsigned char *)(a1 + 260);
    uint64_t v10 = 0xFFFFLL << v9;
    int v11 = 0xFFFF << v9;
    if (v10 <= v8) {
      LODWORD(v8) = v11;
    }
    *(_DWORD *)(a1 + 144) = v8;
  }
}

void tcp_rack_update_segment_acked(uint64_t a1, int a2, unsigned int a3, int a4, int a5)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  int v10 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 316);
  unsigned int v11 = v10 - a3;
  if (v10 == a3) {
    unsigned int v11 = 1;
  }
  if (!a5) {
    goto LABEL_10;
  }
  if (a2 && (((a2 - a3) & 0x80000000) != 0 || a2 - v10 >= 1))
  {
    uint64_t v12 = *(void *)(a1 + 80);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 80);
    uint64_t v13 = *(void *)(v12 + 496);
    if (!v13 || (uint64_t v14 = *(void *)(v13 + 1488)) == 0 || v11 >= *(_DWORD *)(v14 + 40))
    {
LABEL_10:
      unsigned int v15 = *(_DWORD *)(a1 + 2048);
      if (v15 < a3 || (v15 == a3 ? (BOOL v16 = a4 - *(_DWORD *)(a1 + 2052) < 1) : (BOOL v16 = 1), !v16))
      {
        *(unsigned char *)(a1 + 2069) |= 0x20u;
        *(_DWORD *)(a1 + 2048) = a3;
        *(_DWORD *)(a1 + 2052) = a4;
        *(_DWORD *)(a1 + 2056) = v11;
        *(_DWORD *)(a1 + 24) = 0;
      }
      return;
    }
  }
  uint64_t v17 = *(void *)(v12 + 224);
  if (!v17 || (*(unsigned char *)(v17 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      unsigned int v18 = __nwlog_tcp_log();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        unsigned int v19 = (const char *)(v17 + 604);
        if (!v17) {
          unsigned int v19 = "";
        }
        uint64_t v20 = *(void *)(*(void *)(a1 + 80) + 496);
        if (v20)
        {
          uint64_t v20 = *(void *)(v20 + 1488);
          if (v20) {
            LODWORD(v20) = *(_DWORD *)(v20 + 40);
          }
        }
        int v21 = 136447490;
        int v22 = "tcp_rack_update_segment_acked";
        __int16 v23 = 2082;
        unsigned int v24 = v19;
        __int16 v25 = 1024;
        int v26 = a2;
        __int16 v27 = 1024;
        unsigned int v28 = a3;
        __int16 v29 = 1024;
        int v30 = v10;
        __int16 v31 = 1024;
        int v32 = v20;
        _os_log_impl(&dword_214653000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Spurious inference as eithertsecr (%u) doesn't lie between xmit_ts(%u) and now (%u) ORthe segment was transmitted less than base rtt (%u) ago", (uint8_t *)&v21, 0x2Eu);
      }
    }
  }
}

uint64_t tcp_sbsnd_trim(uint64_t result)
{
  uint64_t v1 = (_DWORD *)result;
  int v2 = *(_DWORD *)(result + 48);
  if ((~v2 & 0xC00) == 0)
  {
    unsigned int v3 = *(_DWORD *)(result + 52);
    if (v3)
    {
      if (*(_DWORD *)(result + 4) > v3)
      {
        if (*(_DWORD *)result > v3) {
          unsigned int v3 = *(_DWORD *)result;
        }
        if (v3 <= 0x71C71C)
        {
          *(_DWORD *)(result + 4) = v3;
          BOOL result = *(void *)(*(void *)(result + 72) + 24);
          if ((v2 & 4) != 0)
          {
            if (result)
            {
              BOOL result = nw_protocol_tcp_get_all_stats();
              if (result) {
                *(_DWORD *)(result + 88) = v1[1];
              }
            }
          }
          else if (result)
          {
            BOOL result = nw_protocol_tcp_get_all_stats();
            if (result) {
              *(_DWORD *)(result + 100) = v1[1];
            }
          }
          unsigned int v4 = v1[1];
          if (v1[2] > v4) {
            v1[2] = v4;
          }
        }
      }
    }
  }
  if (v1[1] <= v1[13]) {
    v1[12] &= ~0x800u;
  }
  return result;
}

_DWORD *tcp_update_sack_list(_DWORD *result, int a2, int a3)
{
  unsigned int v3 = result;
  __src[6] = *MEMORY[0x263EF8340];
  uint64_t v4 = result[141];
  if ((int)v4 < 1)
  {
    int v5 = 0;
  }
  else
  {
    int v5 = 0;
    int v6 = result + 142;
    do
    {
      int v7 = *v6;
      int v8 = HIDWORD(*v6);
      if (v7 - v8 < 0 && v7 - result[30] >= 1)
      {
        if (a2 - v8 > 0 || a3 - v7 < 0)
        {
          __src[v5++] = *v6;
        }
        else
        {
          if (a2 - v7 > 0) {
            a2 = *v6;
          }
          if (a3 - v8 < 0) {
            a3 = HIDWORD(*v6);
          }
        }
      }
      ++v6;
      --v4;
    }
    while (v4);
  }
  if (a2 - result[30] < 1)
  {
    unsigned int v9 = 0;
    if (v5 < 1) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  result[142] = a2;
  result[143] = a3;
  v5 -= v5 > 5;
  unsigned int v9 = 1;
  if (v5 >= 1) {
LABEL_17:
  }
    BOOL result = memcpy(&result[2 * v9 + 142], __src, 8 * v5);
LABEL_18:
  int v10 = v5 + v9;
  v3[141] = v5 + v9;
  int v11 = v3[22];
  if (v11 < 0 && v10 >= 1)
  {
    v3[22] = v11 & 0x7DFFFFFF;
    *((void *)v3 + 41) = 0;
    BOOL result = (_DWORD *)nw_tcp_access_globals(*(void *)(*((void *)v3 + 10) + 224));
    v3[81] = result[79] + 100;
    v3[185] |= 2u;
    *((_WORD *)v3 + 172) = 0;
    int v10 = v3[141];
  }
  if (v10 >= 1)
  {
    *((_WORD *)v3 + 154) = 16;
    if (*((_WORD *)v3 + 377))
    {
      *((_WORD *)v3 + 377) = 0;
      v3[186] = 0;
    }
  }
  return result;
}

uint64_t tcp_dooptions(uint64_t result, unsigned __int8 *a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a3 >= 1)
  {
    do
    {
      int v7 = *a2;
      if (v7 == 1)
      {
        unsigned int v5 = 1;
      }
      else
      {
        if (*a2) {
          BOOL v8 = a3 >= 2;
        }
        else {
          BOOL v8 = 0;
        }
        if (!v8) {
          return result;
        }
        unsigned int v5 = a2[1];
        unsigned int v9 = v5 - 2;
        if (v5 < 2 || a3 < v5) {
          return result;
        }
        switch(*a2)
        {
          case 2u:
            if (v5 == 4)
            {
              if ((*(unsigned char *)(a4 + 13) & 2) != 0)
              {
                *(_WORD *)(a5 + 12) = bswap32(*((unsigned __int16 *)a2 + 1)) >> 16;
                *(_DWORD *)a5 |= 0x10u;
              }
              unsigned int v5 = 4;
            }
            break;
          case 3u:
            if (v5 == 3)
            {
              if ((*(unsigned char *)(a4 + 13) & 2) != 0)
              {
                *(_DWORD *)a5 |= 0x20u;
                unsigned int v16 = a2[2];
                if (v16 >= 0xE) {
                  LOBYTE(v16) = 14;
                }
                *(unsigned char *)(a5 + 14) = v16;
                unsigned int v5 = 3;
              }
              else
              {
                unsigned int v5 = 3;
              }
            }
            break;
          case 4u:
            if (v5 == 2)
            {
              if ((*(unsigned char *)(a4 + 13) & 2) == 0) {
                goto LABEL_48;
              }
              int v12 = *(_DWORD *)a5 | 0x100;
              goto LABEL_44;
            }
            break;
          case 5u:
            if (v5 >= 3 && (v9 & 7) == 0)
            {
              *(unsigned char *)(a5 + 15) = v9 >> 3;
              *(void *)(a5 + 16) = a2 + 2;
              uint64_t v13 = *(void *)(result + 1056);
              if (v13) {
                ++*(void *)(v13 + 592);
              }
            }
            break;
          case 6u:
          case 7u:
          case 9u:
          case 0xAu:
          case 0xBu:
          case 0xCu:
          case 0xDu:
          case 0xEu:
          case 0xFu:
          case 0x10u:
          case 0x11u:
          case 0x12u:
          case 0x13u:
          case 0x14u:
          case 0x15u:
          case 0x16u:
          case 0x17u:
          case 0x18u:
          case 0x19u:
          case 0x1Au:
          case 0x1Bu:
          case 0x1Cu:
          case 0x1Du:
          case 0x1Eu:
          case 0x1Fu:
          case 0x20u:
          case 0x21u:
            break;
          case 8u:
            if (v5 == 10)
            {
              *(_DWORD *)a5 |= 1u;
              *(_DWORD *)(a5 + 4) = bswap32(*(_DWORD *)(a2 + 2));
              unsigned int v14 = *(_DWORD *)(a2 + 6);
              *(_DWORD *)(a5 + 8) = v14;
              *(_DWORD *)(a5 + 8) = bswap32(v14) - *(_DWORD *)(result + 1888);
              int v15 = *(_DWORD *)(result + 88);
              if ((v15 & 0x80) == 0) {
                *(_DWORD *)(result + 88) = v15 | 0x80;
              }
              unsigned int v5 = 10;
            }
            break;
          case 0x22u:
            if (v5 == 2)
            {
              if (*(_DWORD *)(result + 12) == 1)
              {
                int v12 = *(_DWORD *)a5 | 0x800;
LABEL_44:
                *(_DWORD *)a5 = v12;
                unsigned int v5 = 2;
              }
              else
              {
LABEL_48:
                unsigned int v5 = 2;
              }
            }
            else if ((v5 - 19) >= 0xF3u && (*(_DWORD *)(result + 12) - 1) <= 1)
            {
              *(_DWORD *)a5 |= 0x400u;
              *(void *)(a5 + 24) = a2 + 1;
            }
            break;
          default:
            if ((v7 == 172 || v7 == 174) && v5 >= 5)
            {
              char v11 = (v5 - 2) / 3u;
              if ((-3 * v11) == (2 - v5))
              {
                *(unsigned char *)(a5 + 32) = v11;
                *(void *)(a5 + 40) = a2 + 2;
                *(unsigned char *)(a5 + 48) = v7 == 174;
              }
            }
            break;
        }
      }
      a2 += v5;
      BOOL v6 = __OFSUB__(a3, v5);
      a3 -= v5;
    }
    while (!((a3 < 0) ^ v6 | (a3 == 0)));
  }
  return result;
}

uint64_t tcp_sbrcv_tstmp_check(uint64_t result)
{
  if ((~*(_DWORD *)(result + 88) & 0x180) != 0)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)(*(void *)(result + 80) + 224);
    int v3 = *(_DWORD *)(v2 + 536);
    if ((v3 & 0x400) != 0)
    {
      unsigned int v4 = 2 * *(_DWORD *)(sysctls + 236);
      char v5 = *(unsigned char *)(result + 261);
      uint64_t v6 = 0xFFFFLL << v5;
      int v7 = 0xFFFF << v5;
      unsigned int v8 = v6 <= v4 ? v7 : 2 * *(_DWORD *)(sysctls + 236);
      if (v8 > *(_DWORD *)(v2 + 492) && v8 <= 0x71C71C)
      {
        *(_DWORD *)(v2 + 492) = v8;
        BOOL result = *(void *)(*(void *)(v2 + 560) + 24);
        if ((v3 & 4) != 0)
        {
          if (result)
          {
            BOOL result = nw_protocol_tcp_get_all_stats();
            if (result) {
              *(_DWORD *)(result + 88) = *(_DWORD *)(v2 + 492);
            }
          }
        }
        else if (result)
        {
          BOOL result = nw_protocol_tcp_get_all_stats();
          if (result) {
            *(_DWORD *)(result + 100) = *(_DWORD *)(v2 + 492);
          }
        }
        unsigned int v10 = *(_DWORD *)(v2 + 492);
        if (*(_DWORD *)(v2 + 496) > v10) {
          *(_DWORD *)(v2 + 496) = v10;
        }
        LODWORD(v11) = *(_DWORD *)(v2 + 540);
        if (v11 <= v8) {
          LODWORD(v11) = v8;
        }
        if (v11 >= v4) {
          uint64_t v11 = v4;
        }
        else {
          uint64_t v11 = v11;
        }
        char v12 = *(unsigned char *)(v1 + 261);
        uint64_t v13 = 0xFFFFLL << v12;
        int v14 = 0xFFFF << v12;
        if (v13 <= v11) {
          LODWORD(v11) = v14;
        }
        *(_DWORD *)(v2 + 540) = v11;
      }
    }
  }
  return result;
}

uint64_t soisconnected(uint64_t result)
{
  uint64_t v2 = (void *)result;
  uint64_t v3 = *(void *)(result + 296);
  __int16 v4 = *(_WORD *)(result + 376);
  __int16 v5 = v4 & 0xFBF1 | 2;
  *(_WORD *)(result + 376) = v5;
  *(_DWORD *)(result + 484) = 0;
  *(_DWORD *)(result + 588) = 0;
  int v6 = v4 & 0x800;
  if (v3) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    uint64_t v8 = *(void *)(result + 32);
    if (v8)
    {
      unsigned int v9 = *(uint64_t (**)(uint64_t))(v8 + 24);
      if (!v9 || (result = v9(result), (uint64_t v8 = v2[4]) != 0))
      {
        unsigned int v10 = *(uint64_t (**)(void *))v8;
        if (*(void *)v8)
        {
          return v10(v2);
        }
      }
    }
  }
  else
  {
    *(_WORD *)(result + 376) = v5 & 0xE3F3 | 0x1000;
    if (*(void *)(*(void *)(v3 + 8) + 32))
    {
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)(result + 8) + 24))(result, 0, v1);
      BOOL result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v3 + 8) + 16))(v3, 1, v1);
    }
    uint64_t v11 = v2[42];
    char v12 = (void *)v2[43];
    if (v11)
    {
      *(void *)(v11 + 344) = v12;
      char v12 = (void *)v2[43];
    }
    else
    {
      *(void *)(v3 + 312) = v12;
    }
    *char v12 = v11;
    --*(_WORD *)(v3 + 356);
    uint64_t v13 = *(void **)(v3 + 328);
    v2[42] = 0;
    v2[43] = v13;
    *uint64_t v13 = v2;
    *(void *)(v3 + 328) = v2 + 42;
    uint64_t v14 = *(void *)(v3 + 32);
    if (v14)
    {
      int v15 = *(uint64_t (**)(uint64_t))(v14 + 24);
      if (!v15 || (BOOL result = v15(v3), (v14 = *(void *)(v3 + 32)) != 0))
      {
        unsigned int v16 = *(uint64_t (**)(uint64_t))(v14 + 48);
        if (v16) {
          BOOL result = v16(v3);
        }
      }
    }
    uint64_t v17 = *(void *)(v3 + 8);
    if (*(void *)(v17 + 32))
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(v17 + 24))(v3, 1, v1);
      unsigned int v18 = *(uint64_t (**)(void *, void, uint64_t))(v2[1] + 16);
      return v18(v2, 0, v1);
    }
  }
  return result;
}

uint64_t compute_iaj_meat(uint64_t result, unsigned int a2)
{
  int v2 = *(_DWORD *)(result + 756);
  int v3 = *(_DWORD *)(result + 760);
  unsigned int v4 = v3 + v2;
  if ((v3 + v2) <= *(_DWORD *)(sysctls + 64)) {
    unsigned int v4 = *(_DWORD *)(sysctls + 64);
  }
  if (*(unsigned __int16 *)(result + 752) >= 0x29u)
  {
    unsigned int v5 = *(unsigned __int16 *)(result + 754);
    unsigned int v6 = a2 - v4 + v5;
    BOOL v7 = v5 >= 2;
    unsigned int v8 = v5 - 2;
    if (!v7) {
      unsigned int v8 = 0;
    }
    if (a2 <= v4) {
      unsigned int v9 = v8;
    }
    else {
      unsigned int v9 = v6;
    }
    unsigned int v10 = *(_DWORD *)(sysctls + 112) + 100;
    if (v9 < v10) {
      LOWORD(v10) = v9;
    }
    *(_WORD *)(result + 754) = v10;
  }
  *(_DWORD *)(result + 756) = (a2 - v2 + 16 * v2 + 8) >> 4;
  unsigned int v11 = (a2 - v2) * (a2 - v2) - v3 * v3 + 16 * v3 * v3 + 8;
  unsigned int v12 = v11 >> 4;
  if (v11 >= 0x650)
  {
    int v13 = 0;
    char v14 = 15;
    unsigned int v15 = 0x8000;
    do
    {
      unsigned int v16 = (v15 + 2 * v13) << v14;
      if (v12 >= v16)
      {
        unsigned int v17 = v15;
      }
      else
      {
        unsigned int v16 = 0;
        unsigned int v17 = 0;
      }
      v13 += v17;
      if (v15 < 2) {
        break;
      }
      --v14;
      v15 >>= 1;
      v12 -= v16;
    }
    while (v12);
    *(_DWORD *)(result + 760) = v13;
  }
  else if (v12 > 1)
  {
    if (v11 >= 0x40)
    {
      if (v12 == 4)
      {
        *(_DWORD *)(result + 760) = 2;
      }
      else if (v11 >= 0x90)
      {
        if (v12 == 9 || v11 < 0x100)
        {
          *(_DWORD *)(result + 760) = 3;
        }
        else if (v12 == 16 || v11 < 0x190)
        {
          *(_DWORD *)(result + 760) = 4;
        }
        else if (v12 == 25 || v11 < 0x240)
        {
          *(_DWORD *)(result + 760) = 5;
        }
        else if (v12 == 36 || v11 < 0x310)
        {
          *(_DWORD *)(result + 760) = 6;
        }
        else if (v12 == 49 || v11 < 0x400)
        {
          *(_DWORD *)(result + 760) = 7;
        }
        else if (v12 == 64 || v11 < 0x510)
        {
          *(_DWORD *)(result + 760) = 8;
        }
        else if (v12 == 81 || v11 < 0x640)
        {
          *(_DWORD *)(result + 760) = 9;
        }
        else
        {
          *(_DWORD *)(result + 760) = 10;
        }
      }
      else
      {
        *(_DWORD *)(result + 760) = 2;
      }
    }
    else
    {
      *(_DWORD *)(result + 760) = 1;
    }
  }
  else
  {
    *(_DWORD *)(result + 760) = v12;
  }
  return result;
}

void nw_proto_tcp_ecn_update_cache(uint64_t a1, unsigned char *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      uint64_t v2 = *(void *)(a1 + 40);
      if (v2)
      {
        *(_DWORD *)(v2 + 5308) = *(_DWORD *)(v2 + 5308) & 0xFFFDFFFF | ((*a2 & 1) << 17);
        if (*(void *)(v2 + 5208))
        {
          if (*(void *)(v2 + 5216))
          {
            MEMORY[0x270EF88B0]();
          }
        }
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v7 = "nw_proto_tcp_ecn_update_cache";
    int v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      unsigned int v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v7 = "nw_proto_tcp_ecn_update_cache";
        unsigned int v5 = "%{public}s called with null ecn_cache_buffer, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v7 = "nw_proto_tcp_ecn_update_cache";
    int v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      unsigned int v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v7 = "nw_proto_tcp_ecn_update_cache";
        unsigned int v5 = "%{public}s called with null so, backtrace limit exceeded";
LABEL_17:
        _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_ERROR, v5, buf, 0xCu);
      }
    }
  }
  if (v3) {
    free(v3);
  }
}

void tcp_respond(uint64_t a1, long long *a2, uint64_t a3, unsigned int a4, unsigned int a5, char a6, uint64_t a7)
{
  char v8 = a6;
  uint64_t v118 = *MEMORY[0x263EF8340];
  uint64_t v13 = *(void *)(a1 + 80);
  uint64_t v14 = *(void *)(v13 + 224);
  uint64_t v15 = *(void *)(v14 + 24);
  uint64_t v16 = *(void *)(v15 + 32);
  char v93 = *(unsigned char *)(v13 + 2236);
  if ((a6 & 4) != 0)
  {
    int v18 = 0;
  }
  else
  {
    int v17 = tcp_sbspace(a1);
    if (v17 >= 0xFFFF << *(unsigned char *)(a1 + 261)) {
      int v18 = 0xFFFF << *(unsigned char *)(a1 + 261);
    }
    else {
      int v18 = v17;
    }
    uint64_t v15 = *(void *)(v14 + 24);
  }
  v98[0] = 0;
  v98[1] = v98;
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)(v16 + 24)
                                                                                             + 88))(v16, v15, 20, 20, 1, v98))
  {
    int v91 = v18;
    uint64_t v19 = v98[0];
    if (v98[0])
    {
      uint64_t v89 = a7;
      uint64_t v20 = *(void *)(v98[0] + 112);
      int v21 = (void *)MEMORY[0x263F144B8];
      if (v20)
      {
        unsigned int v86 = a5;
        unsigned int v87 = a4;
        if ((*(_WORD *)(v98[0] + 204) & 0x100) == 0 || !*MEMORY[0x263F144B8])
        {
          unsigned int v88 = (unsigned int *)(v98[0] + 56);
          uint64_t v23 = v20 + *(unsigned int *)(v98[0] + 56);
LABEL_24:
          long long v26 = *a2;
          *(_DWORD *)(v23 + 16) = *((_DWORD *)a2 + 4);
          *(_OWORD *)uint64_t v23 = v26;
          if ((*(_WORD *)(v19 + 204) & 0x80) != 0) {
            *(_WORD *)(v19 + 196) -= 20;
          }
          int v27 = *(_DWORD *)(v19 + 52);
          unsigned int v28 = *(_DWORD *)(v19 + 56) + 20;
          int v29 = *(_DWORD *)(v19 + 60);
          if (v28 <= v27 - v29)
          {
            *unsigned int v88 = v28;
            uint64_t v33 = v88;
            int v32 = (void *)MEMORY[0x263F144B8];
            if (!v27) {
              goto LABEL_56;
            }
          }
          else
          {
            int v30 = __nwlog_obj();
            BOOL v31 = os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
            int v27 = *(_DWORD *)(v19 + 52);
            if (v31)
            {
              *(_DWORD *)long long buf = 136446978;
              unsigned int v102 = "__nw_frame_claim_internal";
              __int16 v103 = 1024;
              *(_DWORD *)unsigned int v104 = v28;
              *(_WORD *)&v104[4] = 1024;
              *(_DWORD *)&v104[6] = v27;
              *(_WORD *)int v105 = 1024;
              *(_DWORD *)&v105[2] = v29;
              _os_log_impl(&dword_214653000, v30, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
              int v27 = *(_DWORD *)(v19 + 52);
            }
            int v32 = (void *)MEMORY[0x263F144B8];
            uint64_t v33 = v88;
            if (!v27)
            {
LABEL_56:
              if ((*(_WORD *)(v19 + 204) & 0x80) != 0) {
                *(_WORD *)(v19 + 196) += 20;
              }
              if (*v33 > 0x13)
              {
                *v33 -= 20;
              }
              else
              {
                int v52 = __nwlog_obj();
                if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
                {
                  unsigned int v53 = *v33;
                  *(_DWORD *)long long buf = 136446722;
                  unsigned int v102 = "__nw_frame_unclaim_internal";
                  __int16 v103 = 1024;
                  *(_DWORD *)unsigned int v104 = 20;
                  *(_WORD *)&v104[4] = 1024;
                  *(_DWORD *)&v104[6] = v53;
                  _os_log_impl(&dword_214653000, v52, OS_LOG_TYPE_ERROR, "%{public}s Frame cannot unclaim %u start bytes (has %u left)", buf, 0x18u);
                }
              }
              if (a3)
              {
                HIDWORD(v54) = *(_DWORD *)v23;
                LODWORD(v54) = *(_DWORD *)v23;
                *(_DWORD *)uint64_t v23 = v54 >> 16;
                uint64_t v55 = v89;
                if (!v89) {
                  goto LABEL_68;
                }
              }
              else
              {
                char v8 = 16;
                uint64_t v55 = v89;
                if (!v89) {
                  goto LABEL_68;
                }
              }
              if ((*(unsigned char *)(v55 + 4) & 0x10) != 0) {
                *(_WORD *)(v19 + 204) |= 0x8000u;
              }
LABEL_68:
              *(_DWORD *)(v23 + 4) = bswap32(v86);
              *(_DWORD *)(v23 + 8) = bswap32(v87);
              *(unsigned char *)(v23 + 12) = 80;
              *(unsigned char *)(v23 + 13) = v8;
              *(_WORD *)(v23 + 14) = bswap32(v91 >> *(unsigned char *)(a1 + 261)) >> 16;
              *(_WORD *)(v23 + 18) = 0;
              if ((v93 & 2) != 0) {
                __int16 v56 = in6_pseudo();
              }
              else {
                __int16 v56 = in_pseudo();
              }
              *(_WORD *)(v23 + 16) = v56;
              int v57 = in_finalize_cksum();
              if (v57
                && (*(_WORD *)(v19 + 204) & 0x100) != 0
                && *v32
                && (((uint64_t (*)(uint64_t, void))*v32)(v19, *(void *)(v19 + 88)) & 1) == 0)
              {
                *(void *)(a1 + 1056) = 0;
                int v57 = 6;
                if ((*(unsigned char *)(v14 + 828) & 2) == 0)
                {
LABEL_84:
                  BOOL v63 = __nwlog_tcp_log();
                  if (os_log_type_enabled(v63, OS_LOG_TYPE_INFO))
                  {
                    uint64_t v64 = strerror(v57);
                    *(_DWORD *)long long buf = 136446722;
                    unsigned int v102 = "tcp_respond";
                    __int16 v103 = 2082;
                    *(void *)unsigned int v104 = v14 + 604;
                    *(_WORD *)&v104[8] = 2080;
                    *(void *)int v105 = v64;
                    _os_log_impl(&dword_214653000, v63, OS_LOG_TYPE_INFO, "%{public}s %{public}s failed to finalize checksum, %s", buf, 0x20u);
                  }
                }
LABEL_94:
                (*(void (**)(uint64_t, void *))(*(void *)(v16 + 24) + 96))(v16, v98);
                return;
              }
              int v58 = *(_DWORD *)(v19 + 52);
              if (v58)
              {
                uint64_t v59 = (v58 - (*(_DWORD *)(v19 + 56) + *(_DWORD *)(v19 + 60)));
                uint64_t v60 = *(void *)(a1 + 1056);
                if (!v60) {
                  goto LABEL_82;
                }
              }
              else
              {
                uint64_t v59 = 0;
                uint64_t v60 = *(void *)(a1 + 1056);
                if (!v60) {
                  goto LABEL_82;
                }
              }
              uint64_t v61 = 144;
              uint64_t v62 = 136;
              if ((v93 & 2) == 0) {
                uint64_t v62 = 120;
              }
              ++*(void *)(v60 + v62);
              if ((v93 & 2) == 0) {
                uint64_t v61 = 128;
              }
              *(void *)(v60 + v61) += v59;
LABEL_82:
              if (v57)
              {
                if ((*(unsigned char *)(v14 + 828) & 2) == 0) {
                  goto LABEL_84;
                }
                goto LABEL_94;
              }
              uint64_t v65 = *(void *)(*(void *)(a1 + 80) + 224);
              int v66 = *(_DWORD *)(v65 + 600);
              int v97 = 0;
              set_frame_service_class(v19, v65, v66, (v93 & 2) >> 1, &v97);
              int v67 = v97;
              *(_DWORD *)(v19 + 176) = v97;
              if (!__nwlog_is_datapath_logging_enabled())
              {
LABEL_89:
                if (*MEMORY[0x263F144B0] != -1) {
                  dispatch_once(MEMORY[0x263F144B0], &__block_literal_global_82);
                }
                if (*MEMORY[0x263F144A8] && kdebug_is_enabled())
                {
                  nw_frame_array_unclaimed_length();
                  kdebug_trace();
                }
                goto LABEL_94;
              }
              int v69 = *(_DWORD *)(v19 + 52);
              if (v69) {
                int v70 = v69 - (*(_DWORD *)(v19 + 56) + *(_DWORD *)(v19 + 60));
              }
              else {
                int v70 = 0;
              }
              uint64_t v71 = *(void *)(v19 + 112);
              if (v71)
              {
                if ((*(_WORD *)(v19 + 204) & 0x100) == 0 || !*MEMORY[0x263F144B8])
                {
                  uint64_t v72 = *v88;
                  goto LABEL_115;
                }
                if (((unsigned int (*)(uint64_t, void))*MEMORY[0x263F144B8])(v19, *(void *)(v19 + 88)))
                {
                  uint64_t v71 = *(void *)(v19 + 112);
                  if (v71)
                  {
                    uint64_t v72 = *(unsigned int *)(v19 + 56);
LABEL_115:
                    int v73 = (unsigned __int16 *)(v71 + v72);
                    if ((*(unsigned char *)(v14 + 828) & 2) == 0)
                    {
                      if (__nwlog_is_datapath_logging_enabled())
                      {
                        int v74 = __nwlog_tcp_log();
                        if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
                        {
                          unsigned int v75 = bswap32(*v73) >> 16;
                          unsigned int v76 = bswap32(v73[1]) >> 16;
                          int v77 = *((unsigned __int8 *)v73 + 13);
                          unsigned int v78 = *((_DWORD *)v73 + 2);
                          unsigned int v79 = bswap32(*((_DWORD *)v73 + 1));
                          unsigned int v90 = bswap32(v78);
                          int v92 = v77;
                          int v94 = *(_DWORD *)(a1 + 120);
                          int v96 = *(_DWORD *)(a1 + 92);
                          int v80 = *(_DWORD *)(a1 + 12);
                          int v81 = packet_service_class_to_str(v67);
                          *(_DWORD *)long long buf = 136449026;
                          unsigned int v102 = "tcp_respond";
                          __int16 v103 = 2082;
                          *(void *)unsigned int v104 = v14 + 604;
                          *(_WORD *)&v104[8] = 1024;
                          *(_DWORD *)int v105 = v75;
                          *(_WORD *)&v105[4] = 1024;
                          *(_DWORD *)&v105[6] = v76;
                          LOWORD(v106) = 1024;
                          *(_DWORD *)((char *)&v106 + 2) = v70;
                          HIWORD(v106) = 1024;
                          *(_DWORD *)v107 = v92;
                          *(_WORD *)&v107[4] = 1024;
                          *(_DWORD *)&v107[6] = v79;
                          __int16 v108 = 1024;
                          unsigned int v109 = v90;
                          __int16 v110 = 1024;
                          int v111 = v94;
                          __int16 v112 = 1024;
                          int v113 = v96;
                          __int16 v114 = 1024;
                          int v115 = v80;
                          __int16 v116 = 2082;
                          os_log_type_t v117 = v81;
                          _os_log_impl(&dword_214653000, v74, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s sending frame, %u:%u tlen %u, flags %#x, seq %u, ack %u, rcv_nxt %u snd_una %u state %u svc %{public}s", buf, 0x56u);
                        }
                      }
                    }
                    goto LABEL_89;
                  }
                }
              }
              if ((*(_WORD *)(v19 + 204) & 0x100) != 0
                && *MEMORY[0x263F144B8]
                && (((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(v19, *(void *)(v19 + 88)) & 1) == 0)
              {
                *(void *)(a1 + 1056) = 0;
              }
              goto LABEL_89;
            }
          }
          uint64_t v35 = *(unsigned int *)(v19 + 56);
          size_t v34 = *(unsigned int *)(v19 + 60);
          uint64_t v36 = (v27 - (v34 + v35));
          if (v27 == v34 + v35) {
            goto LABEL_56;
          }
          if (v34)
          {
            uint64_t v37 = *(void *)(v19 + 112);
            if (v37)
            {
              memmove((void *)(v37 + v35), (const void *)(v37 + v35 + v36), v34);
              int v27 = *(_DWORD *)(v19 + 52);
            }
          }
          *(_DWORD *)(v19 + 52) = v27 - v36;
          if ((*(_WORD *)(v19 + 204) & 0x80) == 0) {
            goto LABEL_56;
          }
          unsigned int v38 = *(unsigned __int16 *)(v19 + 196);
          BOOL v39 = v38 >= v36;
          unsigned int v40 = v38 - v36;
          *(_WORD *)(v19 + 196) = v40;
          if (v39 && v40 < 0x10000) {
            goto LABEL_56;
          }
          __nwlog_obj();
          uint64_t v41 = *(unsigned __int16 *)(v19 + 196);
          *(_DWORD *)long long buf = 136446978;
          unsigned int v102 = "__nw_frame_collapse";
          __int16 v103 = 2082;
          *(void *)unsigned int v104 = "frame->aggregate_buffer_length";
          *(_WORD *)&v104[8] = 2048;
          *(void *)int v105 = v36;
          *(_WORD *)&v105[8] = 2048;
          uint64_t v106 = v41;
          uint64_t v42 = _os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v99 = 0;
          uint64_t v85 = (void *)v42;
          if (__nwlog_fault())
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              os_log_type_t v43 = __nwlog_obj();
              os_log_type_t log = type;
              if (os_log_type_enabled(v43, type))
              {
                uint64_t v44 = *(unsigned __int16 *)(v19 + 196);
                *(_DWORD *)long long buf = 136446978;
                unsigned int v102 = "__nw_frame_collapse";
                __int16 v103 = 2082;
                *(void *)unsigned int v104 = "frame->aggregate_buffer_length";
                *(_WORD *)&v104[8] = 2048;
                *(void *)int v105 = v36;
                *(_WORD *)&v105[8] = 2048;
                uint64_t v106 = v44;
                os_log_type_t v45 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_51:
                uint32_t v50 = v43;
                os_log_type_t v51 = log;
LABEL_52:
                _os_log_impl(&dword_214653000, v50, v51, v45, buf, 0x2Au);
              }
            }
            else if (v99)
            {
              os_log_t backtrace_string = (void *)__nw_create_backtrace_string();
              os_log_type_t loga = __nwlog_obj();
              os_log_type_t v82 = type;
              BOOL v47 = os_log_type_enabled(loga, type);
              if (backtrace_string)
              {
                if (v47)
                {
                  uint64_t v48 = *(unsigned __int16 *)(v19 + 196);
                  *(_DWORD *)long long buf = 136447234;
                  unsigned int v102 = "__nw_frame_collapse";
                  __int16 v103 = 2082;
                  *(void *)unsigned int v104 = "frame->aggregate_buffer_length";
                  *(_WORD *)&v104[8] = 2048;
                  *(void *)int v105 = v36;
                  *(_WORD *)&v105[8] = 2048;
                  uint64_t v106 = v48;
                  *(_WORD *)v107 = 2082;
                  *(void *)&v107[2] = backtrace_string;
                  _os_log_impl(&dword_214653000, loga, v82, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                }
                free(backtrace_string);
                goto LABEL_53;
              }
              if (v47)
              {
                uint64_t v68 = *(unsigned __int16 *)(v19 + 196);
                *(_DWORD *)long long buf = 136446978;
                unsigned int v102 = "__nw_frame_collapse";
                __int16 v103 = 2082;
                *(void *)unsigned int v104 = "frame->aggregate_buffer_length";
                *(_WORD *)&v104[8] = 2048;
                *(void *)int v105 = v36;
                *(_WORD *)&v105[8] = 2048;
                uint64_t v106 = v68;
                os_log_type_t v45 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
                uint32_t v50 = loga;
                os_log_type_t v51 = v82;
                goto LABEL_52;
              }
            }
            else
            {
              os_log_type_t v43 = __nwlog_obj();
              os_log_type_t log = type;
              if (os_log_type_enabled(v43, type))
              {
                uint64_t v49 = *(unsigned __int16 *)(v19 + 196);
                *(_DWORD *)long long buf = 136446978;
                unsigned int v102 = "__nw_frame_collapse";
                __int16 v103 = 2082;
                *(void *)unsigned int v104 = "frame->aggregate_buffer_length";
                *(_WORD *)&v104[8] = 2048;
                *(void *)int v105 = v36;
                *(_WORD *)&v105[8] = 2048;
                uint64_t v106 = v49;
                os_log_type_t v45 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
                goto LABEL_51;
              }
            }
          }
LABEL_53:
          if (v85) {
            free(v85);
          }
          *(_WORD *)(v19 + 196) = 0;
          uint64_t v33 = v88;
          goto LABEL_56;
        }
        if (((unsigned int (*)(void, void))*MEMORY[0x263F144B8])(v98[0], *(void *)(v98[0] + 88)))
        {
          unsigned int v88 = (unsigned int *)(v19 + 56);
          uint64_t v22 = *(void *)(v19 + 112);
          if (v22)
          {
            uint64_t v23 = v22 + *(unsigned int *)(v19 + 56);
            goto LABEL_24;
          }
        }
      }
      if ((*(_WORD *)(v19 + 204) & 0x100) != 0
        && *v21
        && (((uint64_t (*)(uint64_t, void))*v21)(v19, *(void *)(v19 + 88)) & 1) == 0)
      {
        *(void *)(a1 + 1056) = 0;
      }
    }
    if ((*(unsigned char *)(v14 + 828) & 2) == 0)
    {
      unsigned int v24 = __nwlog_tcp_log();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 136446466;
        unsigned int v102 = "tcp_respond";
        __int16 v103 = 2082;
        *(void *)unsigned int v104 = v14 + 604;
        __int16 v25 = "%{public}s %{public}s output frame is no longer valid";
LABEL_22:
        _os_log_impl(&dword_214653000, v24, OS_LOG_TYPE_INFO, v25, buf, 0x16u);
      }
    }
  }
  else if ((*(unsigned char *)(v14 + 828) & 2) == 0)
  {
    unsigned int v24 = __nwlog_tcp_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 136446466;
      unsigned int v102 = "tcp_respond";
      __int16 v103 = 2082;
      *(void *)unsigned int v104 = v14 + 604;
      __int16 v25 = "%{public}s %{public}s failed to get output frames";
      goto LABEL_22;
    }
  }
}

uint64_t tcp_sbrcv_reserve(uint64_t result, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  if (a3 >= a5) {
    uint64_t v5 = a5;
  }
  else {
    uint64_t v5 = a3;
  }
  char v6 = *(unsigned char *)(result + 261);
  uint64_t v7 = 0xFFFFLL << v6;
  int v8 = 0xFFFF << v6;
  if (v7 <= v5) {
    unsigned int v9 = v8;
  }
  else {
    unsigned int v9 = v5;
  }
  if (v9 > *(_DWORD *)(a2 + 4) && v9 <= 0x71C71C)
  {
    uint64_t v14 = result;
    *(_DWORD *)(a2 + 4) = v9;
    BOOL result = *(void *)(*(void *)(a2 + 72) + 24);
    if ((*(unsigned char *)(a2 + 48) & 4) != 0)
    {
      if (result)
      {
        BOOL result = nw_protocol_tcp_get_all_stats();
        if (result) {
          *(_DWORD *)(result + 88) = *(_DWORD *)(a2 + 4);
        }
      }
    }
    else if (result)
    {
      BOOL result = nw_protocol_tcp_get_all_stats();
      if (result) {
        *(_DWORD *)(result + 100) = *(_DWORD *)(a2 + 4);
      }
    }
    unsigned int v15 = *(_DWORD *)(a2 + 4);
    if (*(_DWORD *)(a2 + 8) > v15) {
      *(_DWORD *)(a2 + 8) = v15;
    }
    LODWORD(v16) = *(_DWORD *)(a2 + 52);
    if (a4) {
      unsigned int v17 = a4;
    }
    else {
      unsigned int v17 = v9;
    }
    if (v16 <= v17) {
      LODWORD(v16) = v17;
    }
    if (v16 >= a5) {
      uint64_t v16 = a5;
    }
    else {
      uint64_t v16 = v16;
    }
    char v18 = *(unsigned char *)(v14 + 261);
    uint64_t v19 = 0xFFFFLL << v18;
    int v20 = 0xFFFF << v18;
    if (v19 <= v16) {
      LODWORD(v16) = v20;
    }
    *(_DWORD *)(a2 + 52) = v16;
  }
  return result;
}

void tcp_cubic_congestion_avd(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 80);
  uint64_t v5 = *(void *)(v4 + 224);
  unsigned int v6 = *(_DWORD *)(a1 + 980);
  if (v6)
  {
    unsigned int v7 = *(_DWORD *)(a1 + 144);
    if (v6 < v7 >> 1 && (!v5 || *(_DWORD *)(v5 + 384) <= v7))
    {
      *(_DWORD *)(a1 + 740) |= 0x100000u;
      return;
    }
  }
  *(_DWORD *)(a1 + 740) &= ~0x100000u;
  *(_DWORD *)(a1 + 288) += *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 92);
  uint64_t v8 = *(void *)(v4 + 496);
  if (v8 && (uint64_t v9 = *(void *)(v8 + 1488)) != 0) {
    unsigned int v10 = *(_DWORD *)(v9 + 40);
  }
  else {
    unsigned int v10 = 0;
  }
  uint64_t v11 = nw_tcp_access_globals(v5);
  uint64_t v12 = v11;
  unsigned int v13 = *(_DWORD *)(a1 + 144);
  if (v13 >= *(_DWORD *)(a1 + 140)) {
    unsigned int v13 = *(_DWORD *)(a1 + 140);
  }
  uint64_t v14 = *(void *)(a1 + 840);
  if (!*(_DWORD *)v14)
  {
    *(_DWORD *)uint64_t v14 = *(_DWORD *)(a1 + 148);
    uint64_t v14 = *(void *)(a1 + 840);
  }
  if (!*(_DWORD *)(v14 + 4))
  {
    *(_DWORD *)(v14 + 4) = *(_DWORD *)(v11 + 316);
    unsigned int v15 = *(unsigned int **)(a1 + 840);
    if (!v15[1])
    {
      v15[1] = 1;
      unsigned int v15 = *(unsigned int **)(a1 + 840);
    }
    if (*v15 <= v13)
    {
      v15[7] = 0;
      unsigned int v17 = *(unsigned int **)(a1 + 840);
    }
    else
    {
      if (*(_DWORD *)(sysctls + 276)) {
        float v16 = (float)((float)((float)*v15 - (float)v13) * 2.5) / (float)*(unsigned int *)(a1 + 196);
      }
      else {
        float v16 = (float)((*v15 - v13) / *(_DWORD *)(a1 + 196)) * 2.5;
      }
      *((float *)v15 + 7) = cbrtf(v16) * 1000.0;
      unsigned int v17 = *(unsigned int **)(a1 + 840);
      unsigned int v13 = *v17;
    }
    v17[2] = v13;
    uint64_t v14 = *(void *)(a1 + 840);
  }
  unsigned int v18 = *(_DWORD *)(v14 + 8);
  if (!v18)
  {
    int v66 = __nwlog_obj();
    os_log_type_enabled(v66, OS_LOG_TYPE_ERROR);
    int v67 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }
    free(v67);
    uint64_t v14 = *(void *)(a1 + 840);
    unsigned int v18 = *(_DWORD *)(v14 + 8);
  }
  int v19 = *(_DWORD *)(v12 + 316);
  int v20 = *(_DWORD *)(v14 + 4);
  uint64_t v21 = sysctls;
  uint64_t v22 = *(int *)(sysctls + 32);
  if (v22 <= v10) {
    unsigned int v23 = v10;
  }
  else {
    unsigned int v23 = *(_DWORD *)(sysctls + 32);
  }
  if (v22) {
    unsigned int v24 = v23;
  }
  else {
    unsigned int v24 = v10;
  }
  float v25 = *(float *)(v14 + 28);
  unsigned int v26 = *(_DWORD *)(a1 + 196);
  if (*(_DWORD *)(v14 + 12))
  {
    *(_DWORD *)(v14 + 16) += *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 92);
    uint64_t v27 = *(void *)(a1 + 840);
    unsigned int v30 = *(_DWORD *)(v27 + 16);
    unsigned int v28 = (unsigned int *)(v27 + 16);
    unsigned int v29 = v30;
    if (*(_DWORD *)(v21 + 276))
    {
      unsigned int v31 = *(_DWORD *)(a1 + 144);
      if (v29 >= v31)
      {
        float v32 = 3.0 - (float)(*(float *)&tcp_cubic_beta * 3.0);
        float v33 = 1.0 / (float)(*(float *)&tcp_cubic_beta + 1.0);
        do
        {
          unsigned int *v28 = v29 - v31;
          uint64_t v37 = *(_DWORD **)(a1 + 840);
          if (*(_DWORD *)(a1 + 144) < *v37 && *(_DWORD *)(v21 + 280)) {
            unsigned int v34 = (float)((float)(v32 * (float)*(unsigned int *)(a1 + 196)) * v33);
          }
          else {
            unsigned int v34 = *(_DWORD *)(a1 + 196);
          }
          v37[3] += v34;
          uint64_t v35 = *(void *)(a1 + 840);
          unsigned int v36 = *(_DWORD *)(v35 + 16);
          unsigned int v28 = (unsigned int *)(v35 + 16);
          unsigned int v29 = v36;
          unsigned int v31 = *(_DWORD *)(a1 + 144);
        }
        while (v36 >= v31);
      }
    }
    else
    {
      unsigned int v39 = *(_DWORD *)(*(void *)(a1 + 840) + 12);
      BOOL v40 = v29 >= v39;
      unsigned int v41 = v29 - v39;
      if (v40)
      {
        unsigned int *v28 = v41;
        *(_DWORD *)(*(void *)(a1 + 840) + 12) += *(_DWORD *)(a1 + 196);
      }
    }
  }
  else
  {
    unsigned int v38 = *(_DWORD *)(a1 + 144);
    if (v38 >= *(_DWORD *)(a1 + 140)) {
      unsigned int v38 = *(_DWORD *)(a1 + 140);
    }
    *(_DWORD *)(v14 + 12) = v38;
    if (*(_DWORD *)(v21 + 276)) {
      *(_DWORD *)(*(void *)(a1 + 840) + 16) = *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 92);
    }
    else {
      *(_DWORD *)(*(void *)(a1 + 840) + 16) = 0;
    }
  }
  uint64_t v42 = *(void *)(a1 + 840);
  unsigned int v43 = *(_DWORD *)(v42 + 12);
  uint64_t v44 = *(unsigned int *)(a1 + 144);
  if (v44 < v43
    && !*(_DWORD *)(v21 + 276)
    && (*(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 224) + 600) - 801) <= 0xFFFFFED2
    && *(_DWORD *)(v42 + 24) > (2 * *(_DWORD *)(a1 + 196)))
  {
    unsigned int v45 = *(_DWORD *)(a1 + 288);
    if (v45 < v44) {
      return;
    }
    *(_DWORD *)(a1 + 288) = v45 - v44;
LABEL_59:
    char v54 = *(unsigned char *)(a1 + 260);
    uint64_t v55 = 0xFFFFLL << v54;
    int v56 = 0xFFFF << v54;
    if (v55 > v43) {
      int v56 = v43;
    }
LABEL_72:
    *(_DWORD *)(a1 + 144) = v56;
    return;
  }
  float v46 = (float)((float)(v24 + v19 - v20) - v25) * 0.001;
  unsigned int v47 = (float)((float)v18 + (float)((float)((float)(v46 * v46) * (float)((float)v26 * 0.4)) * v46));
  if (v47 <= v44)
  {
    int v51 = *(_DWORD *)(v21 + 276);
    unint64_t v52 = 0xFFFFFFFFLL;
  }
  else
  {
    unsigned int v48 = *(_DWORD *)(a1 + 196);
    unint64_t v49 = v48 * (unint64_t)v44;
    unint64_t v50 = v47 - v44;
    int v51 = *(_DWORD *)(v21 + 276);
    unint64_t v52 = v49 / v50;
    if (!v51 && v49 >= v50)
    {
      unint64_t v53 = *(unsigned int *)(a1 + 288);
      if (v52 > v53) {
        return;
      }
      *(_DWORD *)(a1 + 288) = v53 - v52;
      unsigned int v43 = v48 + v44;
      goto LABEL_59;
    }
  }
  if (v51)
  {
    uint64_t v57 = *(unsigned int *)(a1 + 196);
    unsigned int v58 = (v43 + (v57 >> 1)) / v57 * v57;
    if (v58 > v44)
    {
      unint64_t v59 = v57 * (unint64_t)v44 / (v58 - v44);
      if (v59 < v52) {
        unint64_t v52 = v59;
      }
    }
    if (v52)
    {
      unint64_t v60 = *(unsigned int *)(a1 + 288);
      if (v52 <= v60)
      {
        *(_DWORD *)(a1 + 288) = v60 - v52;
        uint64_t v61 = v57 + v44;
        char v62 = *(unsigned char *)(a1 + 260);
        uint64_t v63 = 0xFFFFLL << v62;
        int v64 = v57 + v44;
        int v65 = 0xFFFF << v62;
        if (v61 >= v63) {
          int v56 = v65;
        }
        else {
          int v56 = v64;
        }
        goto LABEL_72;
      }
    }
  }
}

uint64_t tcp_sack_process_dsack(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v4 = *(unsigned int **)(a2 + 16);
  unsigned int v5 = bswap32(*v4);
  unsigned int v6 = *(unsigned __int8 *)(a2 + 15);
  if (v6 < 2)
  {
    unsigned int v7 = 0;
    unsigned int v8 = 0;
  }
  else
  {
    unsigned int v7 = bswap32(v4[2]);
    unsigned int v8 = bswap32(v4[3]);
  }
  unsigned int v9 = bswap32(v4[1]);
  int v10 = *(_DWORD *)(a3 + 8);
  if (((v5 - v10) & 0x80000000) != 0 && (int)(v9 - v10) <= 0)
  {
    int v11 = *(_DWORD *)(a1 + 96);
    if ((int)(v5 - v11) > 0) {
      goto LABEL_46;
    }
    unsigned int v12 = *(_DWORD *)(a1 + 140);
    if (v12 >= *(_DWORD *)(sysctls + 120)) {
      unsigned int v12 = *(_DWORD *)(sysctls + 120);
    }
    int v13 = v12 - v10;
    if (((v13 + v5) & 0x80000000) != 0 || (int)(v9 - v11) > 0 || ((v13 + v9) & 0x80000000) != 0) {
      goto LABEL_46;
    }
    goto LABEL_25;
  }
  uint64_t v14 = 0;
  BOOL v15 = v6 >= 2 && (int)(v7 - v5) <= 0;
  if (v15 && ((v8 - v9) & 0x80000000) == 0)
  {
    if ((int)(v8 - v7) < 1
      || (int)(v7 - v10) < 1
      || (int v16 = *(_DWORD *)(a1 + 92), (int)(v7 - v16) < 1)
      || (int v17 = *(_DWORD *)(a1 + 96), ((v7 - v17) & 0x80000000) == 0)
      || (int)(v8 - v16) < 1
      || (int)(v8 - v17) >= 1)
    {
LABEL_46:
      *(unsigned char *)(a2 + 15) = v6 - 1;
      *(void *)(a2 + 16) = v4 + 2;
      uint64_t v24 = *(void *)(a1 + 1056);
      if (v24) {
        ++*(void *)(v24 + 1048);
      }
      return 1;
    }
LABEL_25:
    *(unsigned char *)(a2 + 15) = v6 - 1;
    *(void *)(a2 + 16) = v4 + 2;
    uint64_t v18 = *(void *)(a1 + 1056);
    if (v18) {
      ++*(void *)(v18 + 1016);
    }
    ++*(_DWORD *)(a1 + 1024);
    int v19 = *(_DWORD *)(a1 + 932);
    if (v19 && v19 == v9)
    {
      *a4 = 1;
      *(_DWORD *)(a1 + 932) = 0;
    }
    int v20 = *(_DWORD *)(a1 + 740);
    if ((v20 & 0x20400020) == 0x20000020 && !*a4)
    {
      for (uint64_t i = *(void *)(a1 + 1984); i; uint64_t i = *(void *)(i + 16))
      {
        if ((*(unsigned char *)(i + 12) & 8) != 0 && (int)(v5 - *(_DWORD *)i) <= 0 && (int)(v9 - *(_DWORD *)(i + 4)) >= 0) {
          ++*(_DWORD *)(a1 + 1016);
        }
      }
    }
    if ((*(_WORD *)(a1 + 226) == 1 && v5 == *(_DWORD *)(a1 + 92)
       || (~v20 & 0x40001000) == 0 && v9 == *(_DWORD *)(a1 + 928))
      && !*(void *)(a1 + 544)
      && *(_DWORD *)(a3 + 8) - *(_DWORD *)(a1 + 92) >= 1)
    {
      if (v18) {
        ++*(void *)(v18 + 1040);
      }
    }
    else
    {
      uint64_t v21 = *(int **)(a1 + 952);
      if (v21)
      {
        unsigned int v22 = v9 - 1;
        do
        {
          int v23 = *v21;
          if ((int)(*v21 - v5) >= 0 && (int)(v21[1] - v22) <= 0 && *((_WORD *)v21 + 4) == 1) {
            *((_WORD *)v21 + 5) |= 1u;
          }
          if ((int)(v23 - v22) >= 0) {
            break;
          }
          uint64_t v21 = (int *)*((void *)v21 + 2);
        }
        while (v21);
      }
    }
    return 1;
  }
  return v14;
}

BOOL tcp_detect_bad_rexmt(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v5 = *(_DWORD *)(a1 + 740);
  if ((v5 & 0x10000000) == 0)
  {
    if ((v5 & 0x8000000) != 0 || (*(_DWORD *)(sysctls + 320) != 1 ? (BOOL v6 = tcp_do_acc_ecn == 1) : (BOOL v6 = 1), v6))
    {
      if ((~*(_DWORD *)(a1 + 348) & 0x300000) == 0 && *(_DWORD *)(a1 + 424)) {
        return 0;
      }
    }
  }
  if ((~*(_DWORD *)(a1 + 348) & 3) == 0 && (*(unsigned char *)(a2 + 13) & 0x40) != 0) {
    return 0;
  }
  if ((~*(_DWORD *)(a1 + 88) & 0x180) == 0)
  {
    if (!a4) {
      return 0;
    }
    if ((*(unsigned char *)a3 & 1) == 0) {
      return 0;
    }
    int v7 = *(_DWORD *)(a3 + 8);
    return v7 && v7 - a4 < 0;
  }
  if (*(_WORD *)(a1 + 226) == 1)
  {
    if (!a4) {
      return 0;
    }
  }
  else if (!a4 || (v5 & 0x40001000) != 0x40001000)
  {
    return 0;
  }
  int v4 = *(_DWORD *)(a1 + 200);
  return *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 316) - a4 < v4 >> 6;
}

uint64_t tcp_cubic_pre_fr(uint64_t result)
{
  *(_DWORD *)(*(void *)(result + 840) + 4) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 12) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 16) = 0;
  if ((*(unsigned char *)(result + 742) & 0x10) != 0)
  {
    unsigned int v1 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
    unsigned int v3 = *(_DWORD *)(result + 980);
    if (v3 <= v1) {
      unsigned int v3 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
    }
    unsigned int v2 = v3 >> (*(_DWORD *)(sysctls + 292) == 0);
  }
  else
  {
    unsigned int v1 = 0;
    unsigned int v2 = *(_DWORD *)(result + 144);
    if (v2 >= *(_DWORD *)(result + 140)) {
      unsigned int v2 = *(_DWORD *)(result + 140);
    }
  }
  *(_DWORD *)(result + 984) = v1;
  int v4 = *(unsigned int **)(result + 840);
  unsigned int v5 = v2;
  if (v2 < *v4)
  {
    unsigned int v5 = v2;
    if (*(_DWORD *)(sysctls + 276)) {
      unsigned int v5 = (float)(*(float *)&tcp_cubic_fast_convergence_factor * (float)v2);
    }
  }
  *int v4 = v5;
  BOOL v6 = *(unsigned int **)(result + 840);
  if (*v6)
  {
    unsigned int v7 = v6[5];
    if (v7)
    {
LABEL_12:
      unsigned int v8 = (*v6 - v7 + (v7 << 6)) >> 6;
      goto LABEL_15;
    }
  }
  else
  {
    *BOOL v6 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
    BOOL v6 = *(unsigned int **)(result + 840);
    unsigned int v7 = v6[5];
    if (v7) {
      goto LABEL_12;
    }
  }
  unsigned int v8 = *v6;
LABEL_15:
  v6[5] = v8;
  unsigned int v9 = *(_DWORD **)(result + 840);
  int v10 = v9[6];
  int v11 = v9[5] - *v9;
  if (v11 < 0) {
    int v11 = *v9 - v9[5];
  }
  if (v10) {
    int v11 = (v11 - v10 + 16 * v10) >> 4;
  }
  v9[6] = v11;
  unsigned int v12 = *(_DWORD *)(result + 196);
  unsigned int v13 = ((float)((float)v2 - (float)(*(float *)&tcp_cubic_backoff * (float)v2)) + (v12 >> 1)) / v12 * v12;
  unsigned int v14 = 2 * v12;
  if (v13 > v14) {
    unsigned int v14 = v13;
  }
  *(_DWORD *)(result + 148) = v14;
  BOOL v15 = *(_DWORD **)(*(void *)(result + 80) + 224);
  if (v15[97] > v14)
  {
    int v16 = v15[108];
    if ((v16 & 0x400) != 0)
    {
      if (v15[109] > v14)
      {
        if (*(int *)(sysctls + 232) > (uint64_t)v14) {
          unsigned int v14 = *(_DWORD *)(sysctls + 232);
        }
        unsigned int v17 = *(_DWORD *)(sysctls + 120);
        if (v14 < v17) {
          unsigned int v17 = v14;
        }
        v15[109] = v17;
      }
      v15[108] = v16 | 0x800;
    }
  }
  return result;
}

uint64_t tcp_set_finwait_timeout(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(sysctls + 316);
  if (!v2) {
    goto LABEL_6;
  }
  int v3 = *(_DWORD *)(a1 + 688);
  if (v3)
  {
    int v4 = *(_DWORD *)(a1 + 684);
    if (v4) {
      goto LABEL_4;
    }
  }
  else
  {
    int v3 = *(_DWORD *)(sysctls + 200);
    int v4 = *(_DWORD *)(a1 + 684);
    if (v4) {
      goto LABEL_4;
    }
  }
  int v4 = *(_DWORD *)(sysctls + 196);
LABEL_4:
  if (v2 < v4 * v3)
  {
    uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
    int v6 = *(_DWORD *)(sysctls + 316) + *(_DWORD *)(result + 316);
    goto LABEL_11;
  }
LABEL_6:
  uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
  int v7 = *(_DWORD *)(a1 + 688);
  if (!v7) {
    int v7 = *(_DWORD *)(sysctls + 200);
  }
  int v8 = *(_DWORD *)(a1 + 684);
  if (!v8) {
    int v8 = *(_DWORD *)(sysctls + 196);
  }
  int v6 = *(_DWORD *)(result + 316) + v8 * v7;
LABEL_11:
  *(_DWORD *)(a1 + 44) = v6 - *(_DWORD *)(a1 + 64);
  return result;
}

uint64_t tcp_early_rexmt_check(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(*(void *)(result + 80) + 224);
  int v3 = *(_DWORD *)(result + 740);
  if ((v3 & 0x20) == 0 && *(unsigned __int16 *)(result + 268) > 9u) {
    goto LABEL_33;
  }
  int v5 = *(_DWORD *)(result + 92);
  int v4 = *(_DWORD *)(result + 96);
  uint64_t result = (v4 - v5);
  if ((int)result < 1) {
    goto LABEL_33;
  }
  if (*(_DWORD *)(v1 + 8) == 1)
  {
    if ((v3 & 0x20400020) != 0x20000020 && ((v3 & 0x20) == 0 || !*(void *)(v1 + 544))) {
      goto LABEL_12;
    }
  }
  else if ((v3 & 0x20) == 0 || !*(void *)(v1 + 544))
  {
    goto LABEL_33;
  }
  uint64_t result = tcp_flight_size((_DWORD *)v1);
  int v5 = *(_DWORD *)(v1 + 92);
  int v4 = *(_DWORD *)(v1 + 96);
LABEL_12:
  unsigned int v6 = *(_DWORD *)(v1 + 140);
  if (*(_DWORD *)(v2 + 384) < v6) {
    unsigned int v6 = *(_DWORD *)(v2 + 384);
  }
  unsigned int v7 = *(_DWORD *)(v1 + 196);
  if (result < 4 * v7 && (int)(v5 - v4 + v6) <= 0)
  {
    unsigned int v8 = result / v7;
    if (result / v7 * v7 < result) {
      ++v8;
    }
    if (v8 <= 3)
    {
      unsigned int v9 = v8 - 1;
      if (v9 <= 1) {
        LOBYTE(v9) = 1;
      }
      if (v9 >= 3u) {
        LOBYTE(v9) = 3;
      }
      if (*(int *)(v1 + 8) >= (uint64_t)v9) {
        LOBYTE(v9) = *(_DWORD *)(v1 + 8);
      }
      *(unsigned char *)(v1 + 310) = v9;
      if (!*(_WORD *)(v1 + 268))
      {
        uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(v1 + 80) + 224));
        *(_DWORD *)(v1 + 272) = *(_DWORD *)(result + 316);
      }
      uint64_t v10 = *(void *)(v1 + 1056);
      if ((*(unsigned char *)(v1 + 741) & 0x10) != 0)
      {
        if (v10) {
          ++*(void *)(v10 + 744);
        }
      }
      else
      {
        if (v10) {
          ++*(void *)(v10 + 696);
        }
        ++*(_WORD *)(v1 + 268);
      }
    }
  }
LABEL_33:
  *(_DWORD *)(v1 + 740) &= ~0x1000u;
  *(_DWORD *)(v1 + 928) = 0;
  *(_DWORD *)(v1 + 936) = 0;
  return result;
}

uint64_t nw_protocol_tcp_set_no_wake_from_sleep(os_unfair_lock_s *a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v1 = a1 + 1316;
    os_unfair_lock_lock(a1 + 1316);
    *(_OWORD *)long long buf = 0uLL;
    uint64_t v2 = 0;
    if (nw_path_flow_registration_get_nexus_instance())
    {
      nw_protocol_upcast();
      nw_protocol_get_flow_id();
      uint64_t v2 = os_nexus_flow_set_wake_from_sleep();
    }
    os_unfair_lock_unlock(v1);
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_wake_from_sleep";
    int v4 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v5 = __nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_wake_from_sleep";
        _os_log_impl(&dword_214653000, v5, OS_LOG_TYPE_ERROR, "%{public}s called with null handle, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v4) {
      free(v4);
    }
    return 22;
  }
  return v2;
}

uint64_t __nw_protocol_tcp_identifier_block_invoke()
{
  unk_26AA4657C = 0;
  unk_26AA46574 = 0;
  dword_26AA4658C = 0;
  unk_26AA46584 = 0;
  nw_protocol_tcp_identifier_identifier = 7365492;
  qword_26AA46590 = 0x100000003;
  return MEMORY[0x270EF8FC0]();
}

uint64_t nw_protocol_tcp_waiting_for_output(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v1 = nw_protocol_downcast();
    if (v1) {
      return (*(unsigned __int8 *)(v1 + 5308) >> 5) & 1;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v7 = "nw_protocol_tcp_waiting_for_output";
    int v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v7 = "nw_protocol_tcp_waiting_for_output";
        int v5 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_12;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v7 = "nw_protocol_tcp_waiting_for_output";
    int v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v7 = "nw_protocol_tcp_waiting_for_output";
        int v5 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_12:
        _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_ERROR, v5, buf, 0xCu);
      }
    }
  }
  if (v3) {
    free(v3);
  }
  return 0;
}

uint64_t nw_protocol_tcp_copy_info(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_info";
    int v20 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v21 = __nwlog_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_info";
        unsigned int v22 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_48:
        _os_log_impl(&dword_214653000, v21, OS_LOG_TYPE_ERROR, v22, buf, 0xCu);
      }
    }
LABEL_49:
    if (v20) {
      free(v20);
    }
    return 0;
  }
  uint64_t v5 = nw_protocol_downcast();
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_info";
    int v20 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v21 = __nwlog_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_info";
        unsigned int v22 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_48;
      }
    }
    goto LABEL_49;
  }
  uint64_t v6 = v5;
  uint64_t v7 = v5 + 832;
  uint64_t v8 = (int32x2_t *)(v5 + 3072);
  if (a2 > 253)
  {
    if (a2 == 254)
    {
      nw_protocol_get_output_handler();
      uint64_t v9 = nw_protocol_copy_info_quiet();
      if (!v9) {
        uint64_t v9 = nw_array_create();
      }
      nw_protocol_definition_t v16 = nw_protocol_copy_tcp_definition();
      unsigned int v17 = (void *)nw_protocol_establishment_report_create();
      if (v16) {
        nw_release(v16);
      }
      uint64_t v50 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      memset(v33, 0, sizeof(v33));
      memset(v32, 0, sizeof(v32));
      long long v30 = 0u;
      long long v31 = 0u;
      memset(buf, 0, sizeof(buf));
      tcp_fill_info((uint64_t)v8, v7, v6, (uint64_t)buf);
      nw_protocol_establishment_report_set_client_accurate_ecn_state();
      nw_protocol_establishment_report_set_server_accurate_ecn_state();
      nw_array_append();
      if (v17) {
        nw_release(v17);
      }
      return v9;
    }
    if (a2 == 255)
    {
      nw_protocol_get_output_handler();
      uint64_t v9 = nw_protocol_copy_info_quiet();
      if (!v9) {
        uint64_t v9 = nw_array_create();
      }
      nw_array_append();
      return v9;
    }
    goto LABEL_15;
  }
  if (a2 == 1)
  {
    if ((*(unsigned char *)(v5 + 5310) & 4) != 0)
    {
      uint64_t v9 = (uint64_t)malloc_type_malloc(0x198uLL, 0xF2B69DE5uLL);
      if (v9)
      {
        tcp_fill_info((uint64_t)v8, v7, v6, v9);
        if (!a3) {
          return v9;
        }
      }
      else
      {
        float v25 = __nwlog_obj();
        os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "strict_malloc";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = 408;
        unsigned int v26 = (void *)_os_log_send_and_compose_impl();
        uint64_t result = __nwlog_abort();
        if (result) {
          goto LABEL_59;
        }
        free(v26);
        tcp_fill_info((uint64_t)v8, v7, v6, 0);
        if (!a3) {
          return v9;
        }
      }
      uint64_t v10 = 408;
      goto LABEL_38;
    }
    return 0;
  }
  if (a2 != 2)
  {
LABEL_15:
    nw_protocol_get_output_handler();
    uint64_t v11 = nw_protocol_copy_info_quiet();
    uint64_t v9 = v11;
    if (a2 != 5)
    {
      if ((*(unsigned char *)(v6 + 828) & 2) == 0)
      {
        uint64_t v18 = __nwlog_tcp_log();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_info";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v6 + 604;
          *(_WORD *)&unsigned char buf[22] = 1024;
          *(_DWORD *)&uint8_t buf[24] = a2;
          _os_log_impl(&dword_214653000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s unknown protocol info type %d", buf, 0x1Cu);
        }
      }
      return v9;
    }
    if (!v11)
    {
      uint64_t v9 = (uint64_t)malloc_type_calloc(1uLL, 0xB8uLL, 0xEAFB8F1AuLL);
      if (!v9)
      {
        uint64_t v27 = __nwlog_obj();
        os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "strict_calloc";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = 1;
        *(_WORD *)&unsigned char buf[22] = 2048;
        *(void *)&uint8_t buf[24] = 184;
        unsigned int v28 = (void *)_os_log_send_and_compose_impl();
        uint64_t result = __nwlog_abort();
        if (result) {
          goto LABEL_59;
        }
        free(v28);
        uint64_t v9 = 0;
      }
    }
    uint64_t v50 = 0;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    memset(v33, 0, sizeof(v33));
    memset(v32, 0, sizeof(v32));
    long long v30 = 0u;
    long long v31 = 0u;
    memset(buf, 0, sizeof(buf));
    tcp_fill_info((uint64_t)v8, v7, v6, (uint64_t)buf);
    *(void *)(v9 + 72) = *(void *)((char *)v32 + 12);
    *(_OWORD *)(v9 + 48) = *(_OWORD *)((char *)v33 + 12);
    *(void *)(v9 + 64) = *(void *)((char *)&v33[1] + 12);
    *(void *)(v9 + 80) = *(void *)((char *)&v32[1] + 4);
    uint64_t v12 = *(unsigned int *)&buf[20];
    uint64_t v14 = *(unsigned int *)&buf[28];
    uint64_t v13 = v30;
    *(void *)(v9 + 120) = *(unsigned int *)&buf[24];
    *(void *)(v9 + 128) = v13;
    *(void *)(v9 + 136) = v12;
    *(void *)(v9 + 144) = v14;
    v15.i64[0] = DWORD1(v30);
    v15.i64[1] = DWORD2(v30);
    *(int8x16_t *)(v9 + 152) = vextq_s8(v15, v15, 8uLL);
    if (!*(void *)(v9 + 8)) {
      *(void *)(v9 + 8) = *(void *)((char *)v33 + 4);
    }
    if (!*(void *)(v9 + 40)) {
      *(void *)(v9 + 40) = *(void *)((char *)v32 + 4);
    }
    *(_OWORD *)(v9 + 88) = v44;
    *(_OWORD *)(v9 + 104) = v45;
    if (!a3) {
      return v9;
    }
    uint64_t v10 = 184;
    goto LABEL_38;
  }
  if ((*(unsigned char *)(v5 + 5310) & 4) == 0) {
    return 0;
  }
  uint64_t v9 = (uint64_t)malloc_type_malloc(0x70uLL, 0xF2B69DE5uLL);
  if (v9)
  {
    tcp_connection_fill_info(v8, v7, v6, v9);
    if (a3)
    {
LABEL_9:
      uint64_t v10 = 112;
LABEL_38:
      *a3 = v10;
    }
    return v9;
  }
  int v23 = __nwlog_obj();
  os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
  *(_DWORD *)long long buf = 136446466;
  *(void *)&uint8_t buf[4] = "strict_malloc";
  *(_WORD *)&buf[12] = 2048;
  *(void *)&buf[14] = 112;
  uint64_t v24 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!result)
  {
    free(v24);
    tcp_connection_fill_info(v8, v7, v6, 0);
    if (!a3) {
      return v9;
    }
    goto LABEL_9;
  }
LABEL_59:
  __break(1u);
  return result;
}

void tcp_fill_info(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v63 = *MEMORY[0x263EF8340];
  *(void *)(a4 + 400) = 0;
  *(_OWORD *)(a4 + 368) = 0u;
  *(_OWORD *)(a4 + 384) = 0u;
  *(_OWORD *)(a4 + 336) = 0u;
  *(_OWORD *)(a4 + 352) = 0u;
  *(_OWORD *)(a4 + 304) = 0u;
  *(_OWORD *)(a4 + 320) = 0u;
  *(_OWORD *)(a4 + 272) = 0u;
  *(_OWORD *)(a4 + 288) = 0u;
  *(_OWORD *)(a4 + 240) = 0u;
  *(_OWORD *)(a4 + 256) = 0u;
  *(_OWORD *)(a4 + 208) = 0u;
  *(_OWORD *)(a4 + 224) = 0u;
  *(_OWORD *)(a4 + 176) = 0u;
  *(_OWORD *)(a4 + 192) = 0u;
  *(_OWORD *)(a4 + 144) = 0u;
  *(_OWORD *)(a4 + 160) = 0u;
  *(_OWORD *)(a4 + 112) = 0u;
  *(_OWORD *)(a4 + 128) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  if (a1 && a2 && a3)
  {
    uint64_t v8 = (os_unfair_lock_s *)(a1 + 1864);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 1864));
    int v9 = *(_DWORD *)(a1 + 12);
    *(unsigned char *)a4 = v9;
    *(_DWORD *)(a4 + 280) = *(_DWORD *)(a2 + 460);
    int v10 = *(_DWORD *)(a1 + 88);
    if ((~v10 & 0x180) == 0) {
      *(unsigned char *)(a4 + 1) |= 1u;
    }
    int v11 = *(_DWORD *)(a1 + 740);
    if ((v11 & 0x20) != 0) {
      *(unsigned char *)(a4 + 1) |= 2u;
    }
    if ((~v10 & 0x60) == 0)
    {
      *(unsigned char *)(a4 + 1) |= 4u;
      *(_WORD *)(a4 + 2) = *(_WORD *)(a1 + 260);
    }
    if ((~*(_DWORD *)(a1 + 348) & 3) == 0) {
      *(unsigned char *)(a4 + 1) |= 8u;
    }
    if ((v10 & 0x200000) != 0 || *(_WORD *)(a1 + 226)) {
      *(_DWORD *)(a4 + 4) |= 1u;
    }
    if ((v10 & 0x2000000) != 0) {
      *(_DWORD *)(a4 + 4) |= 2u;
    }
    int v12 = *(_DWORD *)(a1 + 28);
    if (v12) {
      int v12 = *(_DWORD *)(a1 + 192);
    }
    *(_DWORD *)(a4 + 8) = v12;
    int v13 = *(_DWORD *)(a1 + 196);
    *(_DWORD *)(a4 + 12) = v13;
    *(_DWORD *)(a4 + 16) = v13;
    *(_DWORD *)(a4 + 20) = *(_DWORD *)(a1 + 236);
    *(_DWORD *)(a4 + 24) = *(int *)(a1 + 200) >> 5;
    *(_DWORD *)(a4 + 292) = *(_DWORD *)(a1 + 1968) >> 5;
    *(_DWORD *)(a4 + 28) = *(int *)(a1 + 208) >> 4;
    *(_DWORD *)(a4 + 32) = *(_DWORD *)(a1 + 232) >> 5;
    *(int32x2_t *)(a4 + 36) = vrev64_s32(*(int32x2_t *)(a1 + 144));
    *(_DWORD *)(a4 + 64) = *(_DWORD *)(a3 + 384);
    unsigned int v15 = *(_DWORD *)(a1 + 120);
    unsigned int v14 = *(_DWORD *)(a1 + 124);
    BOOL v16 = v14 >= v15;
    unsigned int v17 = v14 - v15;
    if (!v16) {
      unsigned int v17 = 0;
    }
    *(_DWORD *)(a4 + 44) = v17;
    *(_DWORD *)(a4 + 48) = *(_DWORD *)(a1 + 140);
    *(_DWORD *)(a4 + 52) = *(_DWORD *)(a1 + 100);
    *(_DWORD *)(a4 + 56) = v15;
    if ((v11 & 8) != 0)
    {
      uint64_t v18 = *(void *)(a1 + 768);
      if (v18) {
        *(void *)(a4 + 132) = (8000 * *(_DWORD *)(v18 + 28));
      }
    }
    uint64_t v19 = *(void *)(a2 + 448);
    if (v19) {
      LODWORD(v19) = *(unsigned __int16 *)(v19 + 1072);
    }
    *(_DWORD *)(a4 + 60) = v19;
    int v20 = *(_OWORD **)(a2 + 248);
    *(_OWORD *)(a4 + 68) = v20[1];
    *(void *)(a4 + 84) = *(unsigned int *)(a1 + 712);
    *(void *)(a4 + 284) = *(unsigned int *)(a1 + 720);
    *(void *)(a4 + 92) = (*(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92));
    *(_OWORD *)(a4 + 100) = *v20;
    uint64_t v21 = *(void *)(a1 + 704);
    *(void *)&long long v22 = v21;
    *((void *)&v22 + 1) = HIDWORD(v21);
    *(_OWORD *)(a4 + 116) = v22;
    if (v9 >= 2) {
      *(unsigned char *)(a4 + 140) = *(unsigned char *)(a1 + 716);
    }
    char v23 = 0;
    uint64_t v24 = *(_OWORD **)(a2 + 256);
    *(_OWORD *)(a4 + 144) = *v24;
    *(_OWORD *)(a4 + 160) = v24[1];
    float v25 = *(_OWORD **)(a2 + 264);
    *(_OWORD *)(a4 + 176) = *v25;
    *(_OWORD *)(a4 + 192) = v25[1];
    unsigned int v26 = *(_OWORD **)(a2 + 272);
    *(_OWORD *)(a4 + 208) = *v26;
    *(_OWORD *)(a4 + 224) = v26[1];
    *(_DWORD *)(a4 + 240) = 0;
    if (*(unsigned __int16 *)(a1 + 226) >= 5u)
    {
      if (*(int *)(a1 + 12) <= 3) {
        char v23 = 8;
      }
      else {
        char v23 = 2;
      }
      *(unsigned char *)(a4 + 240) = v23;
    }
    if (*(unsigned __int8 *)(a1 + 311) >= 5u)
    {
      v23 |= 4u;
      *(unsigned char *)(a4 + 240) = v23;
    }
    uint64_t v27 = *(void *)(a1 + 80);
    if (v27)
    {
      uint64_t v28 = *(void *)(v27 + 448);
      if (v28)
      {
        if ((*(unsigned char *)(v28 + 1052) & 8) != 0) {
          *(unsigned char *)(a4 + 240) = v23 | 1;
        }
      }
    }
    unsigned int v29 = *(_DWORD *)(a4 + 244) & 0xFFFFFFDF | (32 * (*(_WORD *)(a1 + 990) & 1));
    *(_DWORD *)(a4 + 244) = v29;
    unsigned int v30 = v29 & 0xFFFFFFBF | (((*(unsigned __int16 *)(a1 + 990) >> 1) & 1) << 6);
    *(_DWORD *)(a4 + 244) = v30;
    unsigned int v31 = v30 & 0xFFFFFF7F | (((*(unsigned __int16 *)(a1 + 990) >> 2) & 1) << 7);
    *(_DWORD *)(a4 + 244) = v31;
    unsigned int v32 = v31 & 0xFFFFFEFF | (((*(unsigned __int16 *)(a1 + 990) >> 3) & 1) << 8);
    *(_DWORD *)(a4 + 244) = v32;
    unsigned int v33 = v32 & 0xFFFFFFFE | (*(unsigned __int16 *)(a1 + 990) >> 4) & 1;
    *(_DWORD *)(a4 + 244) = v33;
    unsigned int v34 = v33 & 0xFFFFFFFD | (2 * ((*(unsigned __int16 *)(a1 + 990) >> 5) & 1));
    *(_DWORD *)(a4 + 244) = v34;
    unsigned int v35 = v34 & 0xFFFFFFF7 | (8 * ((*(unsigned __int16 *)(a1 + 990) >> 6) & 1));
    *(_DWORD *)(a4 + 244) = v35;
    unsigned int v36 = v35 & 0xFFFFFFEF | (16 * ((*(unsigned __int16 *)(a1 + 990) >> 7) & 1));
    *(_DWORD *)(a4 + 244) = v36;
    unsigned int v37 = v36 & 0xFFFFFFFB | (4 * (HIBYTE(*(unsigned __int16 *)(a1 + 990)) & 1));
    *(_DWORD *)(a4 + 244) = v37;
    unsigned int v38 = v37 & 0xFFFFFDFF | (((*(unsigned __int16 *)(a1 + 990) >> 9) & 1) << 9);
    *(_DWORD *)(a4 + 244) = v38;
    unsigned int v39 = v38 & 0xFFFFFBFF | (((*(unsigned __int16 *)(a1 + 990) >> 10) & 1) << 10);
    *(_DWORD *)(a4 + 244) = v39;
    unsigned int v40 = v39 & 0xFFFFF7FF | (((*(unsigned __int16 *)(a1 + 990) >> 11) & 1) << 11);
    *(_DWORD *)(a4 + 244) = v40;
    unsigned int v41 = v40 & 0xFFFFEFFF | (((*(unsigned __int16 *)(a1 + 990) >> 12) & 1) << 12);
    *(_DWORD *)(a4 + 244) = v41;
    unsigned int v42 = v41 & 0xFFFFDFFF | (((*(unsigned __int16 *)(a1 + 990) >> 13) & 1) << 13);
    *(_DWORD *)(a4 + 244) = v42;
    unsigned int v43 = v42 & 0xFFFFBFFF | (((*(unsigned __int16 *)(a1 + 990) >> 14) & 1) << 14);
    *(_DWORD *)(a4 + 244) = v43;
    unsigned int v44 = v43 & 0xFFFF7FFF | (((*(_DWORD *)(a1 + 348) & 0x100001) != 0) << 15);
    *(_DWORD *)(a4 + 244) = v44;
    unsigned int v45 = v44 & 0xFFFEFFFF | (((*(_DWORD *)(a1 + 348) & 0x200002) != 0) << 16);
    *(_DWORD *)(a4 + 244) = v45;
    int v46 = *(_DWORD *)(a1 + 348);
    if ((~v46 & 3) != 0)
    {
      int v50 = *(_DWORD *)(a1 + 740);
      if ((v50 & 0x10000000) == 0 && ((v50 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1)) {
        int v47 = ((~v46 & 0x300000) == 0) << 17;
      }
      else {
        int v47 = 0;
      }
    }
    else
    {
      int v47 = 0x20000;
    }
    unsigned int v51 = v47 | v45 & 0xFFFDFFFF;
    *(_DWORD *)(a4 + 244) = v51;
    unsigned int v52 = v51 & 0xFFFBFFFF | (((*(_DWORD *)(a1 + 348) >> 8) & 1) << 18);
    *(_DWORD *)(a4 + 244) = v52;
    unsigned int v53 = v52 & 0xFFF7FFFF | (((*(_DWORD *)(a1 + 348) >> 9) & 1) << 19);
    *(_DWORD *)(a4 + 244) = v53;
    unsigned int v54 = v53 & 0xFFEFFFFF | (((*(_DWORD *)(a1 + 88) >> 17) & 1) << 20);
    *(_DWORD *)(a4 + 244) = v54;
    uint64_t v55 = *(void *)(a2 + 448);
    if (v55)
    {
      if (*(unsigned __int8 *)(v55 + 1076) == 255 || *(_DWORD *)(v55 + 1024) == 255)
      {
        v54 |= 0x200000u;
        *(_DWORD *)(a4 + 244) = v54;
        uint64_t v55 = *(void *)(a2 + 448);
      }
      if (*(_DWORD *)(v55 + 1068) == 3 || *(_DWORD *)(v55 + 1032) == 3)
      {
        v54 |= 0x400000u;
        *(_DWORD *)(a4 + 244) = v54;
        uint64_t v55 = *(void *)(a2 + 448);
      }
      if (*(_DWORD *)(v55 + 1064) == 2 || *(_DWORD *)(v55 + 1028) == 2)
      {
        v54 |= 0x800000u;
        *(_DWORD *)(a4 + 244) = v54;
        uint64_t v55 = *(void *)(a2 + 448);
        if (*(_DWORD *)(v55 + 1064) == 2 && *(_DWORD *)(v55 + 1068) == 3 && (*(unsigned char *)(v55 + 1054) & 0x10) == 0)
        {
          v54 |= 0x1000000u;
          *(_DWORD *)(a4 + 244) = v54;
          uint64_t v55 = *(void *)(a2 + 448);
        }
      }
      if ((*(unsigned char *)(v55 + 1054) & 0x10) != 0)
      {
        v54 |= 0x2000000u;
        *(_DWORD *)(a4 + 244) = v54;
      }
    }
    if (*(unsigned char *)(a1 + 264) == 2)
    {
      v54 |= 0x4000000u;
      *(_DWORD *)(a4 + 244) = v54;
    }
    if (*(_DWORD *)(sysctls + 40) == 1 || (*(unsigned char *)(a3 + 369) & 0x40) != 0) {
      *(_DWORD *)(a4 + 244) = v54 | 0x8000000;
    }
    *(void *)&long long v56 = *(void *)(a1 + 352);
    *((void *)&v56 + 1) = *(void *)(a1 + 996);
    *(_OWORD *)(a4 + 248) = v56;
    *(_DWORD *)(a4 + 264) = *(_DWORD *)(a1 + 1004);
    *(void *)(a4 + 268) = *(void *)(a1 + 1016);
    *(_DWORD *)(a4 + 276) = *(_DWORD *)(a1 + 1024);
    *(void *)(a4 + 296) = *(void *)(a1 + 360);
    *(_OWORD *)(a4 + 304) = *(_OWORD *)(a1 + 368);
    *(_OWORD *)(a4 + 320) = *(_OWORD *)(a1 + 384);
    *(void *)(a4 + 336) = (*(_DWORD *)(a1 + 416) - 5);
    v57.i64[0] = -1;
    v57.i64[1] = -1;
    int8x16_t v58 = (int8x16_t)vaddq_s64(*(int64x2_t *)(a1 + 432), v57);
    *(int8x16_t *)(a4 + 344) = vextq_s8(v58, v58, 8uLL);
    *(void *)(a4 + 360) = *(void *)(a1 + 448);
    *(void *)(a4 + 368) = *(void *)(a1 + 464) - 1;
    *(void *)(a4 + 376) = *(void *)(a1 + 456) - 1;
    *(void *)(a4 + 384) = *(void *)(a1 + 472);
    os_unfair_lock_unlock(v8);
  }
  else
  {
    long long v48 = __nwlog_obj();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_INFO))
    {
      long long v49 = "tp";
      if (!a2) {
        long long v49 = "inp";
      }
      if (!a3) {
        long long v49 = "so";
      }
      int v59 = 136446466;
      unint64_t v60 = "tcp_fill_info";
      __int16 v61 = 2082;
      char v62 = v49;
      _os_log_impl(&dword_214653000, v48, OS_LOG_TYPE_INFO, "%{public}s %{public}s is NULL", (uint8_t *)&v59, 0x16u);
    }
  }
}

__n128 tcp_connection_fill_info(int32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  if (a1 && a2 && a3)
  {
    *(unsigned char *)a4 = a1[1].i32[1];
    __int32 v6 = a1[11].i32[0];
    if ((~v6 & 0x180) != 0)
    {
      int v7 = 0;
      __int32 v8 = a1[92].i32[1];
      if ((v8 & 0x20) == 0) {
        goto LABEL_15;
      }
    }
    else
    {
      int v7 = 1;
      *(_DWORD *)(a4 + 4) = 1;
      __int32 v8 = a1[92].i32[1];
      if ((v8 & 0x20) == 0)
      {
LABEL_15:
        if ((~v6 & 0x60) == 0)
        {
          v7 |= 4u;
          *(_DWORD *)(a4 + 4) = v7;
          *(_WORD *)(a4 + 1) = a1[32].i16[2];
        }
        if ((~a1[43].i32[1] & 3) == 0) {
          *(_DWORD *)(a4 + 4) = v7 | 8;
        }
        if ((v6 & 0x200000) != 0 || a1[28].i16[1])
        {
          *(_DWORD *)(a4 + 8) = 1;
          int v12 = 3;
          if ((v8 & 0x2000) == 0)
          {
LABEL_23:
            __int32 v13 = a1[3].i32[1];
            if (v13) {
              __int32 v13 = a1[24].i32[0];
            }
            *(_DWORD *)(a4 + 12) = v13;
            *(_DWORD *)(a4 + 16) = a1[24].i32[1];
            *(int32x2_t *)(a4 + 20) = vrev64_s32(a1[18]);
            *(_DWORD *)(a4 + 28) = a1[17].i32[1];
            *(_DWORD *)(a4 + 32) = *(_DWORD *)(a3 + 384);
            unsigned __int32 v15 = a1[15].u32[0];
            unsigned __int32 v14 = a1[15].u32[1];
            BOOL v16 = v14 >= v15;
            unsigned __int32 v17 = v14 - v15;
            if (!v16) {
              unsigned __int32 v17 = 0;
            }
            *(_DWORD *)(a4 + 36) = v17;
            *(_DWORD *)(a4 + 40) = a1[29].i32[1];
            *(_DWORD *)(a4 + 44) = a1[25].i32[0] >> 5;
            *(_DWORD *)(a4 + 48) = a1[26].i32[0] >> 4;
            uint64_t v18 = *(void *)(a2 + 248);
            *(_OWORD *)(a4 + 56) = *(_OWORD *)(v18 + 16);
            *(void *)(a4 + 72) = a1[89].u32[0];
            *(void *)(a4 + 104) = a1[90].u32[0];
            __n128 result = *(__n128 *)v18;
            *(_OWORD *)(a4 + 80) = *(_OWORD *)v18;
            *(void *)(a4 + 96) = a1[88].u32[1];
            LOBYTE(v18) = a1[123].i16[3];
            *(_DWORD *)(a4 + 52) = 32 * (v18 & 1);
            int v19 = (32 * a1[123].u16[3]) & 0x40 | (32 * (v18 & 1));
            *(_DWORD *)(a4 + 52) = v19;
            unsigned int v20 = v19 & 0xFFFFFF7F | (((a1[123].u16[3] >> 2) & 1) << 7);
            *(_DWORD *)(a4 + 52) = v20;
            unsigned int v21 = v20 & 0xFFFFFEFF | (((a1[123].u16[3] >> 3) & 1) << 8);
            *(_DWORD *)(a4 + 52) = v21;
            unsigned int v22 = v21 & 0xFFFFFFFE | (a1[123].u16[3] >> 4) & 1;
            *(_DWORD *)(a4 + 52) = v22;
            LODWORD(v18) = v22 | (a1[123].u16[3] >> 4) & 2;
            *(_DWORD *)(a4 + 52) = v18;
            LODWORD(v18) = v18 & 0xFFFFFFF7 | (a1[123].u16[3] >> 3) & 8;
            *(_DWORD *)(a4 + 52) = v18;
            LODWORD(v18) = v18 & 0xFFFFFFEF | (a1[123].u16[3] >> 3) & 0x10;
            *(_DWORD *)(a4 + 52) = v18;
            LODWORD(v18) = v18 & 0xFFFFFFFB | (a1[123].u16[3] >> 6) & 4;
            *(_DWORD *)(a4 + 52) = v18;
            LODWORD(v18) = v18 & 0xFFFFFDFF | a1[123].i16[3] & 0x200;
            *(_DWORD *)(a4 + 52) = v18;
            LODWORD(v18) = v18 & 0xFFFFFBFF | a1[123].i16[3] & 0x400;
            *(_DWORD *)(a4 + 52) = v18;
            LODWORD(v18) = v18 & 0xFFFFF7FF | a1[123].i16[3] & 0x800;
            *(_DWORD *)(a4 + 52) = v18;
            LODWORD(v18) = v18 & 0xFFFFEFFF | a1[123].i16[3] & 0x1000;
            *(_DWORD *)(a4 + 52) = v18;
            LODWORD(v18) = v18 & 0xFFFFDFFF | a1[123].i16[3] & 0x2000;
            *(_DWORD *)(a4 + 52) = v18;
            *(_DWORD *)(a4 + 52) = v18 & 0xFFFFBFFF | a1[123].i16[3] & 0x4000;
            return result;
          }
        }
        else
        {
          int v12 = 2;
          if ((v8 & 0x2000) == 0) {
            goto LABEL_23;
          }
        }
        *(_DWORD *)(a4 + 8) = v12;
        goto LABEL_23;
      }
    }
    v7 |= 2u;
    *(_DWORD *)(a4 + 4) = v7;
    goto LABEL_15;
  }
  int v9 = __nwlog_obj();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    int v11 = "tp";
    if (!a2) {
      int v11 = "inp";
    }
    if (!a3) {
      int v11 = "so";
    }
    int v23 = 136446466;
    uint64_t v24 = "tcp_connection_fill_info";
    __int16 v25 = 2082;
    unsigned int v26 = v11;
    _os_log_impl(&dword_214653000, v9, OS_LOG_TYPE_INFO, "%{public}s %{public}s is NULL", (uint8_t *)&v23, 0x16u);
  }
  return result;
}

uint64_t tcp_output(uint64_t a1)
{
  kern_return_t v461;
  kern_return_t v462;
  NSObject *v463;
  int v464;
  char v465;
  char v466;
  int v467;
  unsigned int v468;
  int v469;
  int v470;
  int v471;
  int v472;
  unsigned int v473;
  char v474;
  unsigned int v475;
  int v476;
  int v477;
  uint64_t v478;
  uint64_t v479;
  int v480;
  char v481;
  uint64_t (*v482)(uint64_t, uint64_t, void, void);
  char v483;
  int v484;
  int v485;
  NSObject *v486;
  int v487;
  int v488;
  unsigned int v489;
  int v490;
  int v491;
  int v492;
  uint64_t v493;
  unsigned int v494;
  unsigned int v495;
  int v496;
  unsigned int v497;
  uint64_t v498;
  uint64_t v499;
  uint64_t v500;
  int v501;
  int v502;
  int v503;
  uint64_t v504;
  int v505;
  uint64_t v506;
  int v507;
  int v508;
  int v509;
  int v510;
  uint64_t v511;
  int v512;
  int v513;
  int v514;
  uint64_t v515;
  int v516;
  uint64_t v517;
  uint64_t v518;
  uint64_t *v519;
  int v520;
  int v521;
  int v522;
  unsigned int v523;
  unsigned int v524;
  unsigned int v525;
  int v526;
  char v527;
  int v528;
  void *v529;
  NSObject *v530;
  os_log_type_t v531;
  int v532;
  NSObject *v533;
  os_log_type_t v534;
  const char *v535;
  unint64_t v536;
  uint64_t v537;
  void *v538;
  unint64_t v539;
  uint64_t v540;
  void *v541;
  unint64_t v542;
  unint64_t v543;
  int v544;
  unint64_t v545;
  unint64_t v546;
  unint64_t v547;
  int v548;
  unint64_t v549;
  uint64_t v550;
  void *v551;
  void *v552;
  NSObject *v553;
  os_log_type_t v554;
  BOOL v555;
  int v556;
  int v557;
  unint64_t v558;
  unint64_t v559;
  int v560;
  unint64_t *v561;
  uint64_t v562;
  void *v563;
  NSObject *v564;
  int v565;
  int v566;
  unint64_t v567;
  unint64_t *v568;
  uint64_t v569;
  unint64_t v570;
  uint64_t v571;
  unsigned int v572;
  unint64_t v573;
  unint64_t v574;
  int v575;
  unint64_t v576;
  unint64_t v577;
  int v578;
  unint64_t *v579;
  NSObject *v580;
  int v581;
  int v582;
  NSObject *v583;
  os_log_type_t v584;
  int v585;
  unint64_t *v586;
  int v587;
  int v588;
  char v589;
  int v590;
  int v591;
  uint64_t v592;
  void *v593;
  void *v594;
  void *v595;
  int v596;
  uint64_t v597;
  NSObject *v598;
  os_log_type_t v599;
  unint64_t v600;
  uint64_t v601;
  void *v602;
  uint64_t v603;
  uint64_t v604;
  uint64_t v605;
  uint64_t v606;
  uint64_t v607;
  int v608;
  int v609;
  void *v610;
  NSObject *v611;
  os_log_type_t v612;
  uint64_t v613;
  int v614;
  int v615;
  NSObject *v616;
  os_log_type_t v617;
  const char *v618;
  NSObject *v619;
  void *v620;
  NSObject *v621;
  int v622;
  unsigned int v623;
  unsigned int v624;
  unsigned int v625;
  int v626;
  int v627;
  int v628;
  NSObject *v629;
  os_log_type_t v630;
  NSObject *v631;
  int v632;
  unsigned int v633;
  unsigned int v634;
  unsigned int v635;
  int v636;
  int v637;
  int v638;
  void *v639;
  NSObject *v640;
  os_log_type_t v641;
  BOOL v642;
  uint64_t v643;
  int v644;
  int v645;
  int v646;
  void *v647;
  NSObject *v648;
  os_log_type_t v649;
  int v650;
  NSObject *v651;
  os_log_type_t v652;
  const char *v653;
  void *v654;
  NSObject *v655;
  os_log_type_t v656;
  NSObject *v657;
  os_log_type_t v658;
  const char *v659;
  int v660;
  int v661;
  int v662;
  uint64_t v663;
  int v664;
  void *v665;
  void *v666;
  NSObject *v667;
  os_log_type_t v668;
  BOOL v669;
  int v670;
  NSObject *v671;
  os_log_type_t v672;
  uint64_t v673;
  int v674;
  int v675;
  void *v676;
  NSObject *v677;
  os_log_type_t v678;
  BOOL v679;
  uint64_t v680;
  int v681;
  int v682;
  NSObject *v683;
  os_log_type_t v684;
  int v685;
  void *v686;
  NSObject *v687;
  os_log_type_t v688;
  NSObject *v689;
  os_log_type_t v690;
  const char *v691;
  int v692;
  int64x2_t *v693;
  NSObject *v694;
  os_log_type_t v695;
  NSObject *v696;
  const char *v697;
  void *v698;
  NSObject *v699;
  os_log_type_t v700;
  NSObject *v701;
  os_log_type_t v702;
  const char *v703;
  void *v704;
  NSObject *v705;
  os_log_type_t v706;
  BOOL v707;
  void *v708;
  NSObject *v709;
  os_log_type_t v710;
  NSObject *v711;
  os_log_type_t v712;
  const char *v713;
  void *v714;
  NSObject *v715;
  os_log_type_t v716;
  BOOL v717;
  NSObject *v718;
  os_log_type_t v719;
  void *v720;
  NSObject *v721;
  os_log_type_t v722;
  NSObject *v723;
  os_log_type_t v724;
  const char *v725;
  void *v726;
  NSObject *v727;
  os_log_type_t v728;
  BOOL v729;
  NSObject *v730;
  os_log_type_t v731;
  int v732;
  int v733;
  void *v734;
  void *v735;
  NSObject *v736;
  os_log_type_t v737;
  BOOL v738;
  NSObject *v739;
  os_log_type_t v740;
  NSObject *v741;
  os_log_type_t v742;
  char v743;
  int v744;
  char v745;
  int v746;
  int v747;
  int v748;
  void *v749;
  int v750;
  char *v751;
  const char *v752;
  void *v753;
  NSObject *v754;
  os_log_type_t v755;
  const char *v756;
  int v757;
  char *v758;
  const char *v759;
  uint64_t v760;
  void *v761;
  NSObject *v762;
  void (*v763)(uint64_t, void, uint64_t);
  uint64_t v764;
  NSObject *v765;
  void (*v766)(uint64_t, void, uint64_t);
  uint64_t v767;
  uint64_t v768;
  void *v769;
  void (*v770)(void *, void, uint64_t);
  uint64_t v771;
  uint64_t v772;
  NSObject *v773;
  os_log_type_t v774;
  const char *v775;
  BOOL v776;
  os_log_t v777;
  void *v778;
  BOOL v779;
  const char *v780;
  int v781;
  char *v782;
  int v783;
  int v784;
  const char *v785;
  int v786;
  char *v787;
  unsigned char *v788;
  const char *v789;
  int v790;
  char *v791;
  char v792;
  void *v793;
  NSObject *v794;
  os_log_type_t numer;
  const char *v796;
  NSObject *v797;
  void *v798;
  NSObject *v799;
  os_log_type_t v800;
  const char *v801;
  NSObject *v802;
  void (*v803)(uint64_t, void, uint64_t);
  uint64_t v804;
  void *backtrace_string;
  NSObject *v806;
  os_log_type_t v807;
  BOOL v808;
  const char *v809;
  BOOL v810;
  void *v811;
  NSObject *v812;
  os_log_type_t v813;
  BOOL v814;
  NSObject *v815;
  os_log_type_t v816;
  NSObject *v817;
  void *v818;
  uint64_t v819;
  void *v820;
  void (*v821)(void *, void, uint64_t);
  uint64_t v822;
  uint64_t v823;
  NSObject *v824;
  os_log_type_t v825;
  const char *v826;
  BOOL v827;
  NSObject *v828;
  os_log_type_t v829;
  int v830;
  void *v832;
  NSObject *v833;
  os_log_type_t v834;
  const char *v835;
  void *v836;
  NSObject *v837;
  os_log_type_t v838;
  BOOL v839;
  void *v840;
  BOOL v841;
  void *v842;
  NSObject *v843;
  os_log_type_t v844;
  const char *v845;
  void *v846;
  NSObject *v847;
  os_log_type_t v848;
  BOOL v849;
  void *v850;
  BOOL v851;
  NSObject *v852;
  os_log_type_t v853;
  NSObject *v854;
  os_log_type_t v855;
  void *v856;
  NSObject *v857;
  os_log_type_t v858;
  const char *v859;
  void *v860;
  NSObject *v861;
  os_log_type_t v862;
  BOOL v863;
  NSObject *v864;
  os_log_type_t v865;
  NSObject *v866;
  char *v867;
  void (*v868)(uint64_t, void, uint64_t);
  uint64_t v869;
  void *v870;
  NSObject *v871;
  os_log_type_t v872;
  const char *v873;
  void *v874;
  NSObject *v875;
  os_log_type_t v876;
  BOOL v877;
  NSObject *v878;
  os_log_type_t v879;
  NSObject *log;
  os_log_t v881;
  NSObject *v882;
  NSObject *v883;
  int v884;
  char v885;
  unint64_t v886;
  uint64_t v887;
  unsigned int v888;
  unsigned int v889;
  int v890;
  unsigned int v891;
  uint64_t v892;
  uint64_t v893;
  unint64_t *v894;
  int v895;
  int v896;
  int v897;
  unsigned int *v898;
  int v899;
  int v900;
  unsigned int *v901;
  BOOL v902;
  char v903;
  BOOL v904;
  uint64_t v905;
  int v906;
  int v907;
  unsigned int v908;
  int v909;
  int *v910;
  int v911;
  int v912;
  int v913;
  int v914;
  unsigned int *type;
  os_log_type_t typea;
  signed int v917;
  os_log_t v918;
  NSObject *v919;
  os_log_type_t v920;
  NSObject *v921;
  os_log_type_t v922;
  uint64_t v923;
  int v924;
  os_log_t v925;
  int v926;
  int v927;
  NSObject *v928;
  NSObject *v929;
  NSObject *v930;
  NSObject *v931;
  os_log_t v932;
  NSObject *v933;
  os_log_type_t v934;
  int v935;
  void *v936;
  os_log_type_t v937;
  NSObject *v938;
  os_log_type_t v939;
  unsigned char *v940;
  NSObject *v941;
  void *v942;
  NSObject *v943;
  int v944;
  unsigned int v945;
  unsigned int v946;
  unsigned int v947;
  void *v948;
  void *v949;
  mach_timebase_info info;
  mach_timebase_info *p_info;
  char v952;
  os_log_type_t v953;
  unsigned char buf[24];
  unsigned char v955[28];
  char *v956;
  _DWORD v957[3];
  _WORD __src[2];
  unsigned int v959;
  uint64_t v960;
  float32x4x2_t v961;
  float32x4x2_t v962;
  float32x4x2_t v963;

  v960 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void **)(a1 + 80);
  uint64_t v3 = v2[28];
  v899 = *(_DWORD *)(v3 + 600);
  uint64_t v4 = nw_tcp_access_globals(v3);
  int v907 = *((unsigned char *)v2 + 2236) & 2;
  int v5 = *(_DWORD *)(a1 + 88);
  if ((v5 & 0x100000) != 0)
  {
    __int16 v910 = (int *)(v4 + 316);
    goto LABEL_5;
  }
  __int16 v910 = (int *)(v4 + 316);
  if (*(_DWORD *)(a1 + 96) == *(_DWORD *)(a1 + 92))
  {
LABEL_5:
    int v7 = *(_DWORD *)(v4 + 316) - *(_DWORD *)(a1 + 160);
    if (*(int *)(a1 + 12) <= 3) {
      int v8 = *(_DWORD *)(sysctls + 176);
    }
    else {
      int v8 = 0;
    }
    if (v7 >= *(_DWORD *)(a1 + 192) + v8)
    {
      int v9 = *(unsigned __int8 *)(a1 + 264);
      int v10 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 80);
      if (v10 && (v9 != 3 && v9 != 4 || v7 > 179999)) {
        v10(a1);
      }
      int v11 = *(void **)(a1 + 952);
      if (v11)
      {
        int v12 = (void *)(a1 + 952);
        do
        {
          unsigned __int32 v14 = (void *)*v12;
          unsigned __int32 v15 = (void *)(a1 + 952);
          if ((void *)*v12 != v11)
          {
            do
            {
              BOOL v16 = v14;
              unsigned __int32 v14 = (void *)v14[2];
            }
            while (v14 != v11);
            unsigned __int32 v15 = v16 + 2;
          }
          __int32 v13 = (void *)v11[2];
          *unsigned __int32 v15 = v13;
          nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
          free(v11);
          int v11 = v13;
        }
        while (v13);
        *(_DWORD *)(a1 + 960) = *(_DWORD *)(a1 + 96);
      }
      if (*(unsigned char *)(a1 + 742))
      {
        int v17 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 316)
            - *(_DWORD *)(a1 + 336);
        if (v17 < 0) {
          int v17 = -v17;
        }
        if (v17 >= 0xDBBA1)
        {
          *(_DWORD *)(a1 + 740) &= ~0x10000u;
          *(unsigned char *)(a1 + 267) = 0;
          *(_DWORD *)(a1 + 88) &= 0x7DFFFFFFu;
          *(void *)(a1 + 328) = 0;
          *(_DWORD *)(a1 + 324) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 316)
                                + 100;
          *(_DWORD *)(a1 + 740) |= 2u;
          *(_WORD *)(a1 + 344) = 0;
        }
      }
      *(_WORD *)(a1 + 308) = 16;
      int v5 = *(_DWORD *)(a1 + 88);
    }
    char v6 = 1;
    goto LABEL_28;
  }
  char v6 = 0;
LABEL_28:
  __int16 v900 = 0;
  v897 = 0;
  unsigned int v905 = 0;
  __int16 v906 = 0;
  __int16 v895 = 0;
  int v891 = 0;
  uint64_t v18 = 0;
  __int16 v908 = 0;
  unsigned int v19 = v5 & 0xFFEFFFFF;
  unsigned int v20 = *(_DWORD *)&v6 & ((v5 & 0x10000u) >> 16);
  if (v20) {
    int v21 = 0x100000;
  }
  else {
    int v21 = 0;
  }
  v885 = v20 ^ v6;
  *(_DWORD *)(a1 + 88) = v19 | v21;
  os_log_type_t type = (unsigned int *)(a1 + 100);
  unsigned int v901 = (unsigned int *)(a1 + 940);
  int v887 = v3 + 604;
  if (v907) {
    int v22 = -40;
  }
  else {
    int v22 = -20;
  }
  uint64_t v890 = v22;
  if (v907) {
    int v23 = 40;
  }
  else {
    int v23 = 20;
  }
  if (v907) {
    int v24 = 56;
  }
  else {
    int v24 = 36;
  }
  v888 = v24;
  uint64_t v889 = v23;
  __int16 v25 = (void *)(a1 + 632);
  v886 = a1 + 568;
  uint64_t v26 = 17;
  if (v907)
  {
    uint64_t v27 = 18;
  }
  else
  {
    uint64_t v26 = 15;
    uint64_t v27 = 16;
  }
  char v892 = 8 * v27;
  v893 = 8 * v26;
  v894 = (unint64_t *)(a1 + 2000);
  v949 = (void *)(a1 + 632);
  v923 = v3;
  v940 = v2;
  while (1)
  {
    *(_DWORD *)(a1 + 88) &= ~0x10000000u;
    if (!*(void *)(v3 + 24))
    {
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
      BOOL v793 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v953 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault()) {
        goto LABEL_1753;
      }
      if (LOBYTE(info.numer) == 17)
      {
        v794 = __nwlog_obj();
        numer = info.numer;
        if (!os_log_type_enabled(v794, info.numer)) {
          goto LABEL_1753;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
        v796 = "%{public}s called with null protocol";
LABEL_1751:
        int v815 = v794;
        unsigned int v816 = numer;
LABEL_1752:
        _os_log_impl(&dword_214653000, v815, v816, v796, buf, 0xCu);
        goto LABEL_1753;
      }
      if (v953 == OS_LOG_TYPE_DEFAULT)
      {
        v794 = __nwlog_obj();
        numer = info.numer;
        if (!os_log_type_enabled(v794, info.numer)) {
          goto LABEL_1753;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
        v796 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_1751;
      }
      os_log_t backtrace_string = (void *)__nw_create_backtrace_string();
      uint64_t v806 = __nwlog_obj();
      int v807 = info.numer;
      int v808 = os_log_type_enabled(v806, info.numer);
      if (backtrace_string)
      {
        if (v808)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          int v809 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_1739:
          _os_log_impl(&dword_214653000, v806, v807, v809, buf, 0x16u);
        }
LABEL_1740:
        free(backtrace_string);
        goto LABEL_1753;
      }
      if (v808)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
        v796 = "%{public}s called with null protocol, no backtrace";
LABEL_1793:
        int v815 = v806;
        unsigned int v816 = v807;
        goto LABEL_1752;
      }
LABEL_1753:
      if (v793) {
        free(v793);
      }
      __int16 v25 = (void *)(a1 + 632);
LABEL_1756:
      if (*(int *)(a1 + 12) >= 5)
      {
        uint64_t v515 = 49;
        tcp_drop(a1, 49);
        return v515;
      }
      if ((*(unsigned char *)(v3 + 828) & 2) == 0)
      {
        int v817 = __nwlog_tcp_log();
        if (os_log_type_enabled(v817, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "tcp_output";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v887;
          _os_log_impl(&dword_214653000, v817, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s path is non-viable, dropping output", buf, 0x16u);
        }
      }
      if (!*(_DWORD *)(a1 + 28))
      {
        *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 192)
                             + *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 316)
                             - *(_DWORD *)(a1 + 64);
        if (*(_DWORD *)(a1 + 36))
        {
          *(_DWORD *)(a1 + 36) = 0;
          *(_DWORD *)(a1 + 316) = 0;
          *(_WORD *)(a1 + 226) = 0;
          *(_DWORD *)(a1 + 248) = 0;
        }
      }
      unsigned int v818 = (void *)*v25;
      if (!*v25)
      {
LABEL_1788:
        *(void *)(a1 + 632) = 0;
        *(void *)(a1 + 640) = v949;
        *(_DWORD *)(a1 + 648) = 0;
        *(_DWORD *)(a1 + 300) = 0;
        goto LABEL_1709;
      }
      while (1)
      {
        v819 = v818[4];
        v820 = (void *)v818[5];
        if (v819)
        {
          *(void *)(v819 + 40) = v820;
          v820 = (void *)v818[5];
        }
        else
        {
          *(void *)(a1 + 640) = v820;
        }
        NSObject *v820 = v819;
        v821 = (void (*)(void *, void, uint64_t))v818[10];
        v818[4] = 0;
        v818[5] = 0;
        if (!v821) {
          break;
        }
        uint64_t v822 = v818[11];
        v818[10] = 0;
        v818[11] = 0;
        v821(v818, 0, v822);
LABEL_1770:
        unsigned int v818 = (void *)*v949;
        if (!*v949) {
          goto LABEL_1788;
        }
      }
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
      uint64_t v823 = _os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v953 = OS_LOG_TYPE_DEFAULT;
      v948 = (void *)v823;
      if (__nwlog_fault())
      {
        if (LOBYTE(info.numer) == 17)
        {
          v941 = __nwlog_obj();
          v937 = info.numer;
          if (!os_log_type_enabled(v941, info.numer)) {
            goto LABEL_1786;
          }
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          int v824 = v941;
          int v825 = v937;
          v826 = "%{public}s called with null frame->finalizer";
          goto LABEL_1785;
        }
        if (v953 == OS_LOG_TYPE_DEFAULT)
        {
          v943 = __nwlog_obj();
          v939 = info.numer;
          if (!os_log_type_enabled(v943, info.numer)) {
            goto LABEL_1786;
          }
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          int v824 = v943;
          int v825 = v939;
          v826 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
          goto LABEL_1785;
        }
        v942 = (void *)__nw_create_backtrace_string();
        v938 = __nwlog_obj();
        v934 = info.numer;
        int v827 = os_log_type_enabled(v938, info.numer);
        if (v942)
        {
          if (v827)
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v942;
            _os_log_impl(&dword_214653000, v938, v934, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v942);
          goto LABEL_1786;
        }
        if (v827)
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          int v824 = v938;
          int v825 = v934;
          v826 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_1785:
          _os_log_impl(&dword_214653000, v824, v825, v826, buf, 0xCu);
        }
      }
LABEL_1786:
      if (v948) {
        free(v948);
      }
      goto LABEL_1770;
    }
    uint64_t v28 = nw_protocol_downcast();
    if (!v28)
    {
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
      BOOL v793 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v953 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault()) {
        goto LABEL_1753;
      }
      if (LOBYTE(info.numer) == 17)
      {
        v794 = __nwlog_obj();
        numer = info.numer;
        if (!os_log_type_enabled(v794, info.numer)) {
          goto LABEL_1753;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
        v796 = "%{public}s called with null tcp";
        goto LABEL_1751;
      }
      if (v953 == OS_LOG_TYPE_DEFAULT)
      {
        v794 = __nwlog_obj();
        numer = info.numer;
        if (!os_log_type_enabled(v794, info.numer)) {
          goto LABEL_1753;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
        v796 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_1751;
      }
      os_log_t backtrace_string = (void *)__nw_create_backtrace_string();
      uint64_t v806 = __nwlog_obj();
      int v807 = info.numer;
      int v810 = os_log_type_enabled(v806, info.numer);
      if (backtrace_string)
      {
        if (v810)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          int v809 = "%{public}s called with null tcp, dumping backtrace:%{public}s";
          goto LABEL_1739;
        }
        goto LABEL_1740;
      }
      if (v810)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
        v796 = "%{public}s called with null tcp, no backtrace";
        goto LABEL_1793;
      }
      goto LABEL_1753;
    }
    if (*(void *)(v28 + 5208) && (*(unsigned char *)(v28 + 5309) & 0x20) == 0) {
      goto LABEL_1756;
    }
    uint64_t v29 = v2[62];
    if (v29)
    {
      uint64_t v30 = *(void *)(v29 + 216);
      int v31 = *(_DWORD *)(a1 + 88);
      *(_DWORD *)(a1 + 88) = v31 & 0xEFFFFFFF;
      if ((*(unsigned char *)(*(void *)(a1 + 80) + 2236) & 2) != 0)
      {
        if (!v30)
        {
LABEL_68:
          unsigned int v905 = 0;
          __int16 v906 = 0;
          int v37 = *(_DWORD *)(a1 + 740);
          if ((v37 & 0x20) == 0) {
            goto LABEL_99;
          }
          goto LABEL_73;
        }
        if ((*(unsigned char *)(v30 + 1050) & 0x40) == 0) {
          goto LABEL_63;
        }
        *(_DWORD *)(a1 + 88) = v31 | 0x10000000;
        unsigned int v32 = (unsigned int *)(v30 + 1060);
      }
      else
      {
        if (!v30) {
          goto LABEL_68;
        }
        if ((*(unsigned char *)(v30 + 1050) & 0x20) == 0) {
          goto LABEL_63;
        }
        *(_DWORD *)(a1 + 88) = v31 | 0x10000000;
        unsigned int v32 = (unsigned int *)(v30 + 1056);
      }
      unsigned int v33 = *v32;
      if (v33 >= 0xFFFF) {
        int v34 = 0xFFFF;
      }
      else {
        int v34 = v33;
      }
      if (v33) {
        int v35 = v34;
      }
      else {
        int v35 = 0xFFFF;
      }
      *(_DWORD *)(a1 + 692) = v35;
LABEL_63:
      if (*(unsigned __int8 *)(v30 + 1076) == 255 || *(_DWORD *)(v30 + 1024) == 255)
      {
        __int16 v906 = 1;
      }
      else
      {
        if (*(_DWORD *)(v30 + 1068) == 3 || *(_DWORD *)(v30 + 1032) == 3)
        {
          __int16 v906 = 0;
          unsigned int v905 = 0x100000000;
          int v37 = *(_DWORD *)(a1 + 740);
          if ((v37 & 0x20) == 0) {
            goto LABEL_99;
          }
          goto LABEL_73;
        }
        __int16 v906 = 0;
      }
      HIDWORD(v905) = 0;
      BOOL v36 = *(_DWORD *)(v30 + 1064) == 2 || *(_DWORD *)(v30 + 1028) == 2;
      LODWORD(v905) = v36;
    }
    int v37 = *(_DWORD *)(a1 + 740);
    if ((v37 & 0x20) == 0) {
      goto LABEL_99;
    }
LABEL_73:
    int v38 = *(_DWORD *)(a1 + 100);
    if (v38 - *(_DWORD *)(a1 + 96) >= 0) {
      goto LABEL_99;
    }
    if ((v37 & 0x20400000) != 0x20000000)
    {
      uint64_t v47 = *(void *)(a1 + 544);
      if (v47)
      {
        unsigned int v48 = *(_DWORD *)(a1 + 560);
        if ((int)(v38 - v48) < 0)
        {
          while (1)
          {
            int v65 = *(_DWORD *)(v47 + 4);
            uint64_t v47 = *(void *)(v47 + 16);
            int v66 = v38 - v65;
            if (!v47) {
              break;
            }
            if (v66 < 0) {
              goto LABEL_317;
            }
            unsigned int v67 = *(_DWORD *)v47;
            if (v38 - *(_DWORD *)v47 < 0)
            {
              *os_log_type_t type = v67;
              __int16 v908 = *(_DWORD *)(v47 + 4) - v67;
              goto LABEL_99;
            }
          }
          if ((v66 & 0x80000000) == 0)
          {
            __int16 v908 = 0;
            *os_log_type_t type = v48;
            goto LABEL_99;
          }
LABEL_317:
          __int16 v908 = v65 - v38;
          goto LABEL_99;
        }
      }
LABEL_98:
      __int16 v908 = 0;
      goto LABEL_99;
    }
    int v39 = *(_DWORD *)(a1 + 144);
    int v40 = v39 - tcp_flight_size((_DWORD *)a1);
    if (v40 < 1) {
      goto LABEL_99;
    }
    unint64_t v41 = *v894;
    if (!*v894) {
      goto LABEL_98;
    }
    do
    {
      unint64_t v42 = v41;
      unint64_t v41 = *(void *)(v41 + 32);
    }
    while (v41);
    __int16 v908 = 0;
    while (1)
    {
      int v43 = *(_DWORD *)(v42 + 4);
      int v44 = *type - v43;
      if (*(unsigned char *)(v42 + 12))
      {
        if (v44 < 0 && (int)(*type - *(_DWORD *)v42) >= 0) {
          *os_log_type_t type = v43;
        }
        goto LABEL_99;
      }
      if (v44 < 0)
      {
        v908 += tcp_seg_len((int *)v42);
        unint64_t v45 = *(void *)(v42 + 40);
        if (v45)
        {
          do
          {
LABEL_84:
            unint64_t v46 = v45;
            unint64_t v45 = *(void *)(v45 + 32);
          }
          while (v45);
          goto LABEL_85;
        }
      }
      else
      {
        unint64_t v45 = *(void *)(v42 + 40);
        if (v45) {
          goto LABEL_84;
        }
      }
      unint64_t v46 = *(void *)(v42 + 48) & 0xFFFFFFFFFFFFFFFELL;
      if (!v46 || *(void *)(v46 + 32) != v42) {
        break;
      }
LABEL_85:
      unint64_t v42 = v46;
      if (v908 >= v40) {
        goto LABEL_99;
      }
    }
    while (1)
    {
      unint64_t v46 = *(void *)(v42 + 48) & 0xFFFFFFFFFFFFFFFELL;
      if (!v46) {
        break;
      }
      BOOL v59 = v42 == *(void *)(v46 + 40);
      unint64_t v42 = *(void *)(v42 + 48) & 0xFFFFFFFFFFFFFFFELL;
      if (!v59) {
        goto LABEL_85;
      }
    }
LABEL_99:
    if (*(_DWORD *)(a1 + 140) >= *(_DWORD *)(a1 + 144)) {
      int v49 = *(_DWORD *)(a1 + 144);
    }
    else {
      int v49 = *(_DWORD *)(a1 + 140);
    }
    int v50 = *(_DWORD *)(a1 + 88);
    int v51 = v49;
    if ((v50 & 0x80000) != 0)
    {
      uint64_t v52 = *(unsigned int *)(sysctls + 48);
      if (v49 >= v52) {
        int v53 = *(_DWORD *)(sysctls + 48);
      }
      else {
        int v53 = v49;
      }
      if ((int)v52 >= 1) {
        int v51 = v53;
      }
      else {
        int v51 = v49;
      }
    }
    int v54 = 0;
    uint64_t v55 = 0;
    v924 = *(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 92);
    int v56 = tcp_outflags[*(int *)(a1 + 12)];
    int v57 = 1;
    if ((*(unsigned char *)(a1 + 740) & 0x20) == 0 || (v50 & 0x200000) == 0)
    {
      __int16 v61 = 0;
      v935 = 0;
      BOOL v62 = 0;
      int v63 = 0;
      goto LABEL_199;
    }
    int v58 = v49 - tcp_flight_size((_DWORD *)a1);
    BOOL v59 = v58 <= 0 && v900 == 0;
    if (v59) {
      int v58 = *(_DWORD *)(a1 + 196);
    }
    unsigned int v60 = v58 & ~(v58 >> 31);
    if ((*(_DWORD *)(a1 + 740) & 0x20400020) == 0x20000020)
    {
      uint64_t v55 = *(void *)(a1 + 1984);
      if (!v55)
      {
LABEL_121:
        int v54 = 0;
        goto LABEL_158;
      }
      while ((*(unsigned char *)(v55 + 12) & 7) != 2)
      {
        uint64_t v55 = *(void *)(v55 + 16);
        if (!v55) {
          goto LABEL_121;
        }
      }
      if (*(_DWORD *)(a1 + 196) >= v60) {
        unsigned __int16 v82 = v58 & ~(unsigned __int16)(v58 >> 31);
      }
      else {
        unsigned __int16 v82 = *(_DWORD *)(a1 + 196);
      }
      unsigned int v83 = tcp_seg_len((int *)v55);
      unsigned __int16 v84 = v82;
      if (v83 <= v82) {
        unsigned __int16 v84 = tcp_seg_len((int *)v55);
      }
      int v63 = v84;
      if (v60 < v84) {
        int v63 = v60;
      }
      if (!v63)
      {
        int v54 = 0;
        uint64_t v55 = 0;
        __int16 v61 = 0;
        v935 = 0;
        BOOL v62 = 0;
        goto LABEL_160;
      }
      v924 = *(_DWORD *)v55 - *(_DWORD *)(a1 + 92);
      uint64_t v85 = *(void *)(a1 + 1056);
      if (!v85)
      {
        int v54 = 0;
        __int16 v61 = 0;
        int v57 = 0;
        __int16 v900 = 1;
        v935 = 1;
        BOOL v62 = 1;
        goto LABEL_199;
      }
      int v54 = 0;
      __int16 v61 = 0;
      unsigned int v86 = (void *)(v85 + 616);
      uint64_t v87 = 1;
      BOOL v62 = 1;
LABEL_190:
      int v57 = 0;
      *v86 += v87;
      goto LABEL_198;
    }
    __int16 v61 = *(int **)(a1 + 544);
    if (!v61)
    {
      int v54 = 0;
      goto LABEL_135;
    }
    int v54 = 0;
    while (2)
    {
      int v64 = v61[2];
      if (v64 - v61[1] >= 0)
      {
        v54 += v64 - *v61;
LABEL_126:
        __int16 v61 = (int *)*((void *)v61 + 2);
        if (!v61) {
          goto LABEL_135;
        }
        continue;
      }
      break;
    }
    if (v64 - *(_DWORD *)(a1 + 92) < 0) {
      goto LABEL_126;
    }
    int v54 = v64 + v54 - *v61;
LABEL_135:
    uint64_t v68 = *(void *)(a1 + 616);
    v944 = v51;
    if (v68 && *(_DWORD *)(v68 + 8) - *(_DWORD *)(v68 + 4) >= 0)
    {
      while (1)
      {
        uint64_t v68 = *(void *)(v68 + 16);
        if (!v68) {
          break;
        }
        if (*(_DWORD *)(v68 + 8) - *(_DWORD *)(v68 + 4) < 0)
        {
          *(void *)(a1 + 616) = v68;
          break;
        }
      }
    }
    int v69 = *(_DWORD *)(a1 + 624);
    int v70 = v54;
    if (v61 != (int *)v68)
    {
      uint64_t v71 = *(void *)(*(void *)(a1 + 80) + 224);
      if (!v71 || (*(unsigned char *)(v71 + 828) & 2) == 0)
      {
        uint64_t v72 = __nwlog_tcp_log();
        BOOL v73 = os_log_type_enabled(v72, OS_LOG_TYPE_ERROR);
        int v54 = v70;
        if (v73)
        {
          int v74 = (const char *)(v71 + 604);
          *(_DWORD *)long long buf = 136446466;
          if (!v71) {
            int v74 = "";
          }
          *(void *)&uint8_t buf[4] = "tcp_sack_output";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v74;
          _os_log_impl(&dword_214653000, v72, OS_LOG_TYPE_ERROR, "%{public}s %{public}s computed sack hole not the same as cached value", buf, 0x16u);
          int v54 = v70;
        }
      }
    }
    if (v69 != v54)
    {
      uint64_t v75 = *(void *)(*(void *)(a1 + 80) + 224);
      if (!v75 || (*(unsigned char *)(v75 + 828) & 2) == 0)
      {
        unsigned int v76 = __nwlog_tcp_log();
        BOOL v77 = os_log_type_enabled(v76, OS_LOG_TYPE_ERROR);
        int v54 = v70;
        if (v77)
        {
          unsigned int v78 = (const char *)(v75 + 604);
          *(_DWORD *)long long buf = 136446978;
          if (!v75) {
            unsigned int v78 = "";
          }
          *(void *)&uint8_t buf[4] = "tcp_sack_output";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v78;
          *(_WORD *)&unsigned char buf[22] = 1024;
          *(_DWORD *)v955 = v70;
          *(_WORD *)&v955[4] = 1024;
          *(_DWORD *)&v955[6] = v69;
          _os_log_impl(&dword_214653000, v76, OS_LOG_TYPE_ERROR, "%{public}s %{public}s computed sack_bytes_retransmitted (%d) not the same as cached value (%d)", buf, 0x22u);
          int v54 = v70;
        }
      }
    }
    if (!v61)
    {
      uint64_t v55 = 0;
      v935 = 0;
      BOOL v62 = 0;
      int v63 = 0;
      __int16 v900 = 1;
      int v57 = 1;
      uint64_t v2 = v940;
      int v51 = v944;
      goto LABEL_199;
    }
    uint64_t v79 = v61[1];
    uint64_t v80 = *(unsigned int *)(a1 + 152);
    uint64_t v2 = v940;
    int v51 = v944;
    if ((int)v79 - (int)v80 < 1)
    {
      uint64_t v88 = v61[2];
      uint64_t v89 = v79 - v88;
      int v90 = v79 - v88;
      if (v89 <= v60) {
        int v63 = v90;
      }
      else {
        int v63 = v60;
      }
      LODWORD(v81) = v61[2];
      if (v63 < 1)
      {
LABEL_194:
        uint64_t v55 = 0;
        goto LABEL_159;
      }
LABEL_176:
      v924 = v81 - *(_DWORD *)(a1 + 92);
      int v91 = *(_DWORD *)(a1 + 100);
      int v92 = v91 - v81;
      BOOL v62 = v91 - *(_DWORD *)(a1 + 96) >= 0 || v92 > 0 || v63 > v908;
      uint64_t v95 = *(void *)(a1 + 1056);
      if (v95)
      {
        uint64_t v55 = 0;
        ++*(void *)(v95 + 576);
        LODWORD(v87) = *(_DWORD *)(a1 + 196);
        if (v63 >= v87) {
          uint64_t v87 = v87;
        }
        else {
          uint64_t v87 = v63;
        }
        unsigned int v86 = (void *)(v95 + 584);
        goto LABEL_190;
      }
      uint64_t v55 = 0;
      int v57 = 0;
LABEL_198:
      __int16 v900 = 1;
      v935 = 1;
      goto LABEL_199;
    }
    uint64_t v81 = v61[2];
    if ((int)v81 - (int)v80 < 0)
    {
      uint64_t v96 = v80 - v81;
      int v63 = v80 - v81;
      if (v96 > v60) {
        int v63 = v60;
      }
      if (v63 < 1) {
        goto LABEL_194;
      }
      goto LABEL_176;
    }
    uint64_t v55 = 0;
LABEL_158:
    __int16 v61 = 0;
LABEL_159:
    v935 = 0;
    BOOL v62 = 0;
    int v63 = 0;
LABEL_160:
    __int16 v900 = 1;
    int v57 = 1;
LABEL_199:
    unsigned int v97 = *(_DWORD *)(a1 + 88);
    int v98 = (v97 >> 11) & 1 | v56;
    int v99 = *(_DWORD *)(a1 + 740);
    int v911 = v57;
    if ((v99 & 0x8000) == 0)
    {
LABEL_202:
      __int16 v912 = v54;
      if (!v57) {
        goto LABEL_239;
      }
LABEL_203:
      int v100 = (v97 >> 21) & 1;
      if ((v99 & 0x20400020) != 0x20000020) {
        LOBYTE(v100) = 0;
      }
      if (v54 || (v100 & 1) != 0)
      {
        int v102 = *(_DWORD *)(a1 + 144);
        int v103 = v102 - tcp_flight_size((_DWORD *)a1);
        int v104 = v103 & ~(v103 >> 31);
        unsigned int v105 = *(_DWORD *)(v3 + 384);
        if (v105 >= *(_DWORD *)(a1 + 140)) {
          unsigned int v105 = *(_DWORD *)(a1 + 140);
        }
        int v106 = v105 - v924;
        if (v106 >= v104) {
          int v107 = v103 & ~(v103 >> 31);
        }
        else {
          int v107 = v106;
        }
        if (v106 <= 0) {
          int v63 = 0;
        }
        else {
          int v63 = v107;
        }
        if (v63) {
          BOOL v108 = 1;
        }
        else {
          BOOL v108 = v103 < 1;
        }
        if (v108)
        {
          int v54 = v912;
        }
        else
        {
          int v109 = *(_DWORD *)(a1 + 560);
          int v110 = *(_DWORD *)(a1 + 152);
          int v54 = v912;
          int v63 = 0;
          if (v109 - v110 < 0)
          {
            int v111 = *(_DWORD *)(a1 + 740);
            if ((v111 & 0x80000) == 0 && (v111 & 0x20400020) != 0x20000020)
            {
              int v63 = v110 - v109;
              if ((v110 - v109) >= *(_DWORD *)(a1 + 196)) {
                int v63 = *(_DWORD *)(a1 + 196);
              }
              if (v63 >= v104) {
                int v63 = v104;
              }
              int v891 = *(_DWORD *)(a1 + 100);
              int v112 = v110 - v63;
              *(_DWORD *)(a1 + 100) = v110 - v63;
              if ((*(unsigned char *)(a1 + 88) & 0x10) != 0 && *(_DWORD *)(a1 + 96) == v110) {
                *os_log_type_t type = --v112;
              }
              BOOL v62 = 0;
              v924 = v112 - *(_DWORD *)(a1 + 92);
              *(_DWORD *)(a1 + 740) = v111 | 0x80000;
              v897 = 1;
            }
          }
        }
      }
      else
      {
        uint64_t v101 = *(unsigned int *)(v3 + 384);
        if (v101 >= v51) {
          LODWORD(v101) = v51;
        }
        int v63 = v101 - v924;
      }
      goto LABEL_239;
    }
    if (v51)
    {
      *(_DWORD *)(a1 + 36) = 0;
      *(_DWORD *)(a1 + 316) = 0;
      *(_WORD *)(a1 + 226) = 0;
      *(_DWORD *)(a1 + 248) = 0;
      goto LABEL_202;
    }
    if (v924 < *(_DWORD *)(v3 + 384)) {
      int v98 = v56 & 0xFE;
    }
    int v51 = 1;
    __int16 v912 = v54;
    if (v57) {
      goto LABEL_203;
    }
LABEL_239:
    if (v63 >= v908) {
      int v113 = v908;
    }
    else {
      int v113 = v63;
    }
    if (v63 > 0 && v908 != 0) {
      int v63 = v113;
    }
    if (*(unsigned char *)(a1 + 264) == 4)
    {
      unsigned int v115 = *(_DWORD *)(a1 + 488);
      BOOL v116 = !v115 || v63 <= 0;
      BOOL v117 = !v116;
      if (v117 && v63 > v115)
      {
        BOOL v62 = 1;
        int v63 = *(_DWORD *)(a1 + 488);
      }
    }
    if ((v98 & 2) == 0 || (int v118 = *(_DWORD *)(a1 + 100), v119 = *(_DWORD *)(a1 + 92), v118 - v119 < 1))
    {
      int v122 = v63;
      goto LABEL_265;
    }
    int v120 = *(_DWORD *)(a1 + 12);
    if (v120 != 3)
    {
      v98 &= ~2u;
      --v924;
      int v122 = v63 + 1;
      if (v63 < 0 || v120 != 2) {
        goto LABEL_265;
      }
      if (*((unsigned char *)v2 + 2238)) {
        goto LABEL_1709;
      }
      int v664 = *(_DWORD *)(a1 + 88);
      if (*(void *)(a1 + 632))
      {
        v783 = *(_DWORD *)(a1 + 300);
        if (v54) {
          v784 = 1;
        }
        else {
          v784 = v935;
        }
        *(_DWORD *)(a1 + 284) = *(_DWORD *)(a1 + 120);
        *(_DWORD *)(a1 + 88) = v664 & 0xFFFFFFFC;
        *(_DWORD *)(a1 + 32) = 0;
        *(_DWORD *)(a1 + 304) = 0;
        tcp_ip_output_send(v3, a1, v949, v783, v784);
        *(void *)(a1 + 632) = 0;
        *(void *)(a1 + 640) = v949;
        *(_DWORD *)(a1 + 648) = 0;
        *(_DWORD *)(a1 + 300) = 0;
        if (*((unsigned char *)v2 + 2238)) {
          goto LABEL_1709;
        }
        int v664 = *(_DWORD *)(a1 + 88);
      }
      if ((v664 & 0x8000000) == 0) {
        goto LABEL_1709;
      }
      goto LABEL_1809;
    }
    int v121 = *(_DWORD *)(a1 + 740);
    if ((v118 != v119 + 1 || (v121 & 0x400000) == 0) && (v121 & 0x400000) != 0) {
      v98 &= ~2u;
    }
    --v924;
    int v122 = v63 + 1;
LABEL_265:
    if ((v98 & 2) != 0)
    {
      int v123 = *(_DWORD *)(a1 + 740);
      if ((v123 & 0x400000) == 0) {
        v98 &= ~1u;
      }
      v122 &= v123 << 9 >> 31;
    }
    if ((v98 & 4) != 0) {
      LODWORD(v124) = 0;
    }
    else {
      LODWORD(v124) = v122;
    }
    if ((v98 & 2) != 0)
    {
      if (*(int *)(a1 + 12) > 2) {
        goto LABEL_301;
      }
      int v125 = *(_DWORD *)(a1 + 740);
      if ((v125 & 0x400000) == 0) {
        goto LABEL_301;
      }
      if ((*(unsigned char *)(a1 + 88) & 8) == 0)
      {
        uint64_t v126 = *(void *)(a1 + 80);
        uint64_t v127 = *(void *)(v126 + 224);
        if ((v125 & 0x1000000) != 0
          || (char v128 = (*(uint64_t (**)(void))(*(void *)(v126 + 2136) + 32))(*(void *)(v126 + 224)),
              int v54 = v912,
              (v128 & 1) != 0))
        {
          if (*(unsigned char *)(v127 + 370)) {
            goto LABEL_301;
          }
          int v129 = *(_DWORD *)(a1 + 88);
          v945 = *(_DWORD *)(a1 + 740);
          unsigned int v130 = (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 80) + 2136) + 48))(*(void *)(*(void *)(a1 + 80) + 224));
          if (!v130)
          {
            LODWORD(v124) = 0;
            uint64_t v3 = v923;
            int v54 = v912;
            goto LABEL_301;
          }
          if ((v129 & 0x20) != 0) {
            int v131 = -8;
          }
          else {
            int v131 = -4;
          }
          if ((v129 & 0x80) != 0) {
            v131 -= 12;
          }
          uint64_t v3 = v923;
          int v54 = v912;
          if (v131 - ((v945 >> 4) & 2) + 40 >= v130
            && *(_DWORD *)(v127 + 384) <= (*(_DWORD *)(a1 + 156) - 40))
          {
            goto LABEL_301;
          }
        }
        else
        {
          *(_WORD *)(a1 + 990) |= 0x800u;
          uint64_t v132 = *(void *)(a1 + 1056);
          if (v132) {
            ++*(void *)(v132 + 1168);
          }
        }
      }
      LODWORD(v124) = 0;
      *(_DWORD *)(a1 + 740) &= ~0x400000u;
      goto LABEL_301;
    }
    if ((int)v124 <= 0)
    {
      if (!v51)
      {
        v924 = 0;
        LODWORD(v124) = 0;
        *(_DWORD *)(a1 + 28) = 0;
        *(_DWORD *)(a1 + 16) = 0;
        *(_WORD *)(a1 + 226) = 0;
        *(_DWORD *)(a1 + 248) = 0;
        *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 92);
        if (*(_DWORD *)(a1 + 36)) {
          goto LABEL_301;
        }
        tcp_setpersist(a1);
        int v54 = v912;
        v924 = 0;
      }
      LODWORD(v124) = 0;
    }
    else
    {
      LODWORD(v124) = v122;
    }
LABEL_301:
    if ((v940[2231] & 0x50) == 0 && (*(unsigned char *)(a1 + 90) & 0x20) == 0)
    {
      int v133 = *(_DWORD *)(v3 + 432);
      if ((v133 & 0xC00) == 0x400)
      {
        uint64_t v134 = *(unsigned int *)(v3 + 388);
        if (5 * (*(_DWORD *)(a1 + 140) >> 2) >= v134)
        {
          unsigned int v135 = *(_DWORD *)(v3 + 384);
          if (v135 >= 7 * (v134 >> 3)
            && v51 >= (int)(v135 - *(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 92)))
          {
            uint64_t v136 = *(unsigned int *)(sysctls + 116);
            unint64_t v137 = v136 + v134;
            unsigned int v138 = v136 + v134;
            if (v137 >= *(unsigned int *)(sysctls + 120)) {
              unsigned int v138 = *(_DWORD *)(sysctls + 120);
            }
            if (v138 <= 0x71C71C)
            {
              *(_DWORD *)(v3 + 388) = v138;
              uint64_t v139 = *(void *)(*(void *)(v3 + 456) + 24);
              if ((v133 & 4) != 0)
              {
                if (v139)
                {
                  uint64_t all_stats = nw_protocol_tcp_get_all_stats();
                  int v54 = v912;
                  if (all_stats) {
                    *(_DWORD *)(all_stats + 88) = *(_DWORD *)(v3 + 388);
                  }
                }
              }
              else if (v139)
              {
                uint64_t v140 = nw_protocol_tcp_get_all_stats();
                int v54 = v912;
                if (v140) {
                  *(_DWORD *)(v140 + 100) = *(_DWORD *)(v3 + 388);
                }
              }
              unsigned int v142 = *(_DWORD *)(v3 + 388);
              if (*(_DWORD *)(v3 + 392) > v142) {
                *(_DWORD *)(v3 + 392) = v142;
              }
              *(_DWORD *)(v3 + 436) = v142;
            }
          }
        }
      }
    }
    uint64_t v143 = *(unsigned int *)(a1 + 196);
    if ((int)v124 <= (int)v143)
    {
      int v144 = 0;
    }
    else if ((*(unsigned char *)(a1 + 91) & 0x10) != 0 {
           && *(_DWORD *)(sysctls + 324)
    }
           && !(*(_DWORD *)(a1 + 564) | v935 | v54)
           && !*((void *)v940 + 273))
    {
      BOOL v62 = 0;
      int v144 = 1;
    }
    else
    {
      int v144 = 0;
      BOOL v62 = 1;
      LODWORD(v124) = *(_DWORD *)(a1 + 196);
    }
    int v145 = *(_DWORD *)(a1 + 740);
    if ((v145 & 0x1000) != 0) {
      int v144 = 0;
    }
    long long v914 = v144;
    BOOL v146 = (v145 & 0x1000) == 0 && v62;
    v913 = v146;
    if ((int)v124 < v143 || (*(_DWORD *)(a1 + 740) & 0x1000) == 0) {
      unint64_t v124 = v124;
    }
    else {
      unint64_t v124 = v143;
    }
    __int16 v898 = (unsigned int *)(v61 + 2);
    if ((v145 & 0x20400020) == 0x20000020) {
      uint64_t v148 = (_DWORD *)v55;
    }
    else {
      uint64_t v148 = v61 + 2;
    }
    if (!v935) {
      uint64_t v148 = (_DWORD *)(a1 + 100);
    }
    if (*v148 + (int)v124 - (*(_DWORD *)(a1 + 92) + *(_DWORD *)(v3 + 384)) >= 0) {
      unsigned int v149 = v98;
    }
    else {
      unsigned int v149 = v98 & 0xFFFFFFFE;
    }
    int v150 = tcp_sbspace(a1);
    int v151 = v150;
    if (v150 < *(_DWORD *)(v3 + 492) >> 2)
    {
      if (v150 >= *(_DWORD *)(a1 + 196)) {
        int v151 = v150;
      }
      else {
        int v151 = 0;
      }
    }
    uint64_t v152 = sysctls;
    if (*(_DWORD *)(sysctls + 40) == 1 || (*(unsigned char *)(v3 + 369) & 0x40) != 0)
    {
      int v153 = *(_DWORD *)(sysctls + 308);
      if (v153 && (v153 == 1 && (~*(_DWORD *)(a1 + 88) & 0x180) == 0 || *(int *)(a1 + 12) <= 3))
      {
        if (v151 >= 1)
        {
          if (off_26AA46368)
          {
            int v154 = off_26AA46368(a1);
            if (v151 >= v154) {
              int v151 = v154;
            }
          }
        }
        goto LABEL_389;
      }
      if (v151 < 1) {
        goto LABEL_389;
      }
      if (*(_DWORD *)(sysctls + 124) != 1 || (~*(_DWORD *)(a1 + 88) & 0x180) != 0) {
        goto LABEL_383;
      }
      int v155 = *(_DWORD *)(a1 + 740);
      if ((v155 & 0x100) != 0) {
        goto LABEL_384;
      }
      uint64_t v156 = *(void *)(a1 + 80);
      uint64_t v157 = *(void *)(v156 + 496);
      if (v157
        && (uint64_t v158 = *(void *)(v157 + 1488)) != 0
        && (int v159 = *(_DWORD *)(v158 + 40)) != 0
        && (unsigned int v160 = *(_DWORD *)(a1 + 236)) != 0)
      {
        if (v160 <= *(_DWORD *)(sysctls + 4) + v159) {
          goto LABEL_389;
        }
        unsigned int v161 = v149;
        uint64_t v162 = *(void *)(v156 + 224);
        *(_DWORD *)(a1 + 740) = v155 | 0x100;
        if (!*(_DWORD *)(a1 + 1040))
        {
          *(_DWORD *)(a1 + 1040) = *(_DWORD *)(nw_tcp_access_globals(v162) + 316);
          uint64_t v152 = sysctls;
        }
        unsigned int v163 = *(_DWORD *)(v162 + 540);
        unsigned int v164 = *(_DWORD *)(v152 + 128);
        if (v163 > v164)
        {
          unsigned int v165 = v163 >> 1;
          if (v165 > v164) {
            unsigned int v164 = v165;
          }
          *(_DWORD *)(v162 + 540) = v164;
        }
        unsigned int v149 = v161;
      }
      else
      {
LABEL_383:
        if (*(_DWORD *)(sysctls + 112) >= (int)*(unsigned __int16 *)(a1 + 754)) {
          goto LABEL_389;
        }
      }
LABEL_384:
      int v166 = *(_DWORD *)(a1 + 120);
      int v167 = v166 + *(_DWORD *)(a1 + 196) * *(_DWORD *)(v152 + 108);
      if (*(_DWORD *)(a1 + 124) - v167 >= 0) {
        int v167 = *(_DWORD *)(a1 + 124);
      }
      int v168 = v167 - v166;
      if (v168 >= v151) {
        int v168 = v151;
      }
      int v151 = v168 & ~(v168 >> 31);
    }
LABEL_389:
    char v169 = *(unsigned char *)(a1 + 261);
    int v170 = 0xFFFF << v169;
    if (v151 >= 0xFFFF << v169) {
      int v171 = 0xFFFF << v169;
    }
    else {
      int v171 = v151;
    }
    if ((*(unsigned char *)(v3 + 367) & 2) == 0 && v171 <= *(_DWORD *)(a1 + 124) - *(_DWORD *)(a1 + 120)) {
      int v171 = *(_DWORD *)(a1 + 124) - *(_DWORD *)(a1 + 120);
    }
    int v909 = v171;
    if (!v124) {
      goto LABEL_429;
    }
    int v172 = *(_DWORD *)(a1 + 740);
    if ((v172 & 0x8000) != 0) {
      goto LABEL_457;
    }
    uint64_t v174 = *(unsigned int *)(a1 + 96);
    uint64_t v173 = *(unsigned int *)(a1 + 100);
    if ((int)v173 - (int)v174 < 0)
    {
      if ((~v172 & 0x20000020) == 0 && !(v172 & 0x400000 | v935))
      {
        if (v174 - v173 <= (int)v124) {
          unint64_t v124 = (v174 - v173);
        }
        else {
          unint64_t v124 = v124;
        }
      }
      goto LABEL_457;
    }
    if (v935) {
      goto LABEL_457;
    }
    int v175 = *(_DWORD *)(a1 + 12);
    if ((v172 & 0x400000) == 0 || v175 != 3)
    {
      if (v175 == 4 && (*((_DWORD *)v940 + 557) & 0x50000000) != 0)
      {
        uint64_t v176 = *(void *)(a1 + 1056);
        int v171 = v909;
        if (v176) {
          ++*(void *)(v176 + 96);
        }
        goto LABEL_429;
      }
LABEL_413:
      if ((int)v124 >= *(_DWORD *)(a1 + 196)) {
        goto LABEL_457;
      }
      int v177 = *(_DWORD *)(a1 + 88);
      if ((v177 & 0x10000) == 0)
      {
        if (v885 & 1 | ((v177 & 0x1000004) != 0))
        {
          if ((v177 & 0x1000) != 0) {
            goto LABEL_424;
          }
        }
        else
        {
          int v178 = *(_DWORD *)(a1 + 8);
          if (v178 < 1
            || (v177 & 0x1000) != 0
            || (*(_DWORD *)(a1 + 740) & 0x6000) == 0x6000
            || v178 >= *(unsigned __int8 *)(a1 + 310))
          {
            goto LABEL_424;
          }
        }
        if ((int)v124 + v924 >= *(_DWORD *)(v3 + 384)) {
          goto LABEL_457;
        }
      }
LABEL_424:
      int v179 = *(_DWORD *)(a1 + 252);
      if (v179 >= 0) {
        int v180 = *(_DWORD *)(a1 + 252);
      }
      else {
        int v180 = v179 + 1;
      }
      int v171 = v909;
      if (v179 && (int)v124 >= v180 >> 1) {
        goto LABEL_457;
      }
LABEL_429:
      if (v171 >= 1)
      {
        if (v171 < v170) {
          int v170 = v171;
        }
        int v181 = *(_DWORD *)(a1 + 120);
        int v182 = *(_DWORD *)(a1 + 124) - v181;
        int v183 = v170 - v182;
        unsigned int v184 = v182 & ~(v182 >> 31);
        int v185 = *(_DWORD *)(sysctls + 288);
        int v186 = 2 * *(_DWORD *)(a1 + 196);
        if (v185)
        {
          if (v183 < v186)
          {
            if ((*(unsigned char *)(a1 + 88) & 2) != 0
              && !*(_DWORD *)(v3 + 488)
              && *(_DWORD *)(a1 + 284) != v181
              && (*(unsigned char *)(a1 + 740) & 0x10) != 0)
            {
              goto LABEL_457;
            }
            goto LABEL_445;
          }
          if (*(_DWORD *)(v3 + 488) >= *(_DWORD *)(v3 + 496)) {
            goto LABEL_445;
          }
        }
        else if (v183 < v186 || (*(_DWORD *)(a1 + 88) & 0x80000000) != 0)
        {
          goto LABEL_445;
        }
        if (*(_DWORD *)(a1 + 284) != v181 || (int)(v184 + v183) >> v169 > (int)(v184 >> v169)) {
          goto LABEL_457;
        }
LABEL_445:
        if (*(_DWORD *)(v3 + 492) <= 4 * v183) {
          goto LABEL_457;
        }
        if (!v185)
        {
          int v187 = *(_DWORD *)(a1 + 88);
          if ((v187 & 0x80000002) == 0x80000000)
          {
            *(_DWORD *)(a1 + 88) = v187 | 2;
            *(_DWORD *)(a1 + 32) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 316)
                                 - *(_DWORD *)(a1 + 64)
                                 + 100;
          }
        }
      }
      int v188 = *(_DWORD *)(a1 + 88);
      if (v188)
      {
        if (*(_WORD *)(a1 + 308)) {
          --*(_WORD *)(a1 + 308);
        }
        goto LABEL_457;
      }
      if ((v149 & 6) != 0 || (v149 & 1) != 0 && ((v188 & 0x10) == 0 || *(_DWORD *)(a1 + 100) == *(_DWORD *)(a1 + 92))) {
        goto LABEL_457;
      }
      if ((*(unsigned char *)(a1 + 740) & 0x20) == 0
        || *(int *)(a1 + 12) < 4
        || *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92) < 1
        || *(_DWORD *)(a1 + 28)
        || *(_DWORD *)(a1 + 36))
      {
        v788 = v940;
        if (*(_DWORD *)(v3 + 384) && !*(_DWORD *)(a1 + 28) && !*(_DWORD *)(a1 + 36))
        {
          *(_WORD *)(a1 + 226) = 0;
          *(_DWORD *)(a1 + 248) = 0;
          tcp_setpersist(a1);
        }
      }
      else
      {
        *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 192)
                             + *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 316)
                             - *(_DWORD *)(a1 + 64);
        v788 = v940;
      }
      if (v788[2238]) {
        goto LABEL_1709;
      }
      uint64_t v830 = v912 ? 1 : v935;
      tcp_ip_output(v3, a1, v949, *(_DWORD *)(a1 + 300), v830);
      *(void *)(a1 + 632) = 0;
      *(void *)(a1 + 640) = v949;
      *(_DWORD *)(a1 + 648) = 0;
      *(_DWORD *)(a1 + 300) = 0;
      if (v788[2238]) {
        goto LABEL_1709;
      }
      int v664 = *(_DWORD *)(a1 + 88);
      if ((v664 & 0x8000000) == 0) {
        goto LABEL_1709;
      }
LABEL_1809:
      *(_DWORD *)(a1 + 88) = v664 & 0xF7FFFFFF;
      tcp_close(a1);
      return 0;
    }
    if ((*(unsigned char *)(a1 + 988) & 2) == 0 || v173 != *(_DWORD *)(a1 + 112) + 1) {
      goto LABEL_413;
    }
LABEL_457:
    if ((int)v124 >= 1) {
      *(_DWORD *)(a1 + 88) = *(_DWORD *)(a1 + 88) & 0xFEFFFFFF | (((int)v124 >= *(_DWORD *)(a1 + 196)) << 24);
    }
    int v189 = *(_DWORD *)(a1 + 740);
    if ((v189 & 0x10000000) == 0 && ((v189 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1))
    {
      int v190 = *(_DWORD *)(a1 + 348);
      if ((~v190 & 0x300000) == 0 && *(_DWORD *)(a1 + 12) == 4)
      {
        int v191 = *(_DWORD *)(a1 + 112);
        if (*(_DWORD *)(a1 + 92) == v191 + 1
          && *(_DWORD *)(a1 + 560) == v191
          && (v190 & 0x2000000) == 0
          && *(_WORD *)(a1 + 226))
        {
          *(_DWORD *)(a1 + 348) = v190 | 0x2000000;
        }
      }
    }
    int v192 = *(_DWORD *)(a1 + 88);
    if ((v149 & 2) == 0
      || (int v193 = *(_DWORD *)(a1 + 112), *(_DWORD *)(a1 + 100) = v193, *(_DWORD *)(a1 + 560) = v193, (v192 & 8) != 0))
    {
      unsigned int v203 = 0;
      if ((v149 & 4) == 0) {
        goto LABEL_487;
      }
    }
    else
    {
      unsigned int v194 = v149;
      __src[0] = 1026;
      uint64_t v195 = *(void *)(a1 + 80);
      char v196 = *(unsigned char *)(v195 + 2236);
      if ((v196 & 2) != 0) {
        int v197 = -60;
      }
      else {
        int v197 = -40;
      }
      if ((*(unsigned char *)(v195 + 2236) & 2) != 0)
      {
        uint64_t v198 = tcp_rtlookup6(v195, 0);
        if (v198) {
          goto LABEL_477;
        }
      }
      else
      {
        uint64_t v198 = tcp_rtlookup(v195, 0);
        if (v198)
        {
LABEL_477:
          uint64_t v199 = *(void *)(v198 + 216);
          if (*(unsigned char *)(v199 + 1076) == 23
            && *(int *)(sysctls + 48) >= 1
            && (*(_DWORD *)(v199 + 1040) - 9601) >> 7 <= 0x39C)
          {
            *(_DWORD *)(a1 + 88) |= 0x80000u;
          }
          uint64_t v200 = *(void *)(v198 + 1488);
          if (v200 && (unsigned int v201 = *(_DWORD *)(v200 + 48)) != 0)
          {
            unsigned int v202 = *(_DWORD *)(v199 + 1044);
            if (v201 < v202) {
              unsigned int v202 = v201;
            }
          }
          else
          {
            unsigned int v202 = *(_DWORD *)(v199 + 1044);
          }
          unsigned int v220 = v202 + v197;
          goto LABEL_521;
        }
      }
      uint64_t v219 = 152;
      if ((v196 & 2) == 0) {
        uint64_t v219 = 148;
      }
      unsigned int v220 = *(_DWORD *)(sysctls + v219);
LABEL_521:
      __src[1] = bswap32(v220) >> 16;
      int v192 = *(_DWORD *)(a1 + 88);
      unsigned int v149 = v194;
      if ((v192 & 0x20) != 0 && ((v194 & 0x10) == 0 || (v192 & 0x40) != 0))
      {
        v959 = bswap32(*(unsigned __int8 *)(a1 + 262) | 0x1030300);
        unsigned int v203 = 8;
        if ((v194 & 4) != 0) {
          goto LABEL_491;
        }
      }
      else
      {
        unsigned int v203 = 4;
        if ((v194 & 4) != 0) {
          goto LABEL_491;
        }
      }
LABEL_487:
      if ((v192 & 0x88) == 0x80 && ((v149 & 0x10) == 0 || (v192 & 0x100) != 0))
      {
        int v204 = (_DWORD *)((char *)__src + v203);
        *int v204 = 168296705;
        unsigned int v205 = bswap32(*(_DWORD *)(a1 + 276));
        v204[1] = bswap32(*(_DWORD *)(a1 + 1888) + *v910);
        v204[2] = v205;
        v203 += 12;
      }
    }
LABEL_491:
    int v206 = v149 & 2;
    int v207 = *(_DWORD *)(a1 + 740);
    if ((v207 & 0x20) != 0 && (v149 & 2) != 0 && (v192 & 8) == 0 && ((v149 & 0x10) == 0 || (v192 & 0x200) != 0))
    {
      *(_WORD *)((char *)__src + v203) = 516;
      v203 += 2;
    }
    if ((v207 & 0x400000) == 0)
    {
      unsigned int v208 = 0;
      int v209 = v149 & 0x12;
      goto LABEL_539;
    }
    if ((v149 & 0x12) != 2 || (v192 & 8) != 0)
    {
      if ((v149 & 0x12) == 0x12)
      {
        if (*(unsigned char *)(a1 + 988))
        {
          unsigned int v222 = v203;
          tcp_tfo_gen_cookie(*(void *)(a1 + 80), buf);
          int v223 = (char *)__src + v222;
          *(_WORD *)int v223 = 2594;
          *(void *)(v223 + 2) = *(void *)buf;
          *(_WORD *)(a1 + 990) |= 4u;
          uint64_t v224 = *(void *)(a1 + 1056);
          if (v224) {
            ++*(void *)(v224 + 1072);
          }
          unsigned int v208 = 0;
          LOBYTE(v203) = v222 + 10;
          int v207 = *(_DWORD *)(a1 + 740);
        }
        else
        {
          unsigned int v208 = 0;
        }
        BOOL v218 = 1;
        if ((v207 & 0x20) != 0) {
          goto LABEL_540;
        }
      }
      else
      {
        BOOL v218 = 0;
        unsigned int v208 = 0;
        if ((v207 & 0x20) != 0) {
          goto LABEL_540;
        }
      }
LABEL_566:
      if ((v207 & 0x10000000) != 0) {
        goto LABEL_657;
      }
LABEL_567:
      if ((v207 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1) {
        goto LABEL_657;
      }
      int v239 = *(_DWORD *)(a1 + 348);
      if ((~v239 & 0x300000) != 0)
      {
        if ((v239 & 0x2200000) != 0x200000 || !v218) {
          goto LABEL_657;
        }
      }
      else if ((v239 & 0x2000000) != 0)
      {
        goto LABEL_657;
      }
      uint64_t v241 = *(void *)(*(void *)(a1 + 80) + 224);
      if ((40 - v203) <= 1u)
      {
        unsigned __int8 v242 = v203;
        if (v241 && (*(unsigned char *)(v241 + 828) & 2) != 0 || !__nwlog_is_datapath_logging_enabled())
        {
LABEL_584:
          uint64_t v3 = v923;
LABEL_585:
          LOBYTE(v203) = v242;
          goto LABEL_657;
        }
        unsigned int v245 = v149;
        os_log_type_t v696 = __nwlog_tcp_log();
        if (os_log_type_enabled(v696, OS_LOG_TYPE_DEBUG))
        {
          v697 = (const char *)(v241 + 604);
          *(_DWORD *)long long buf = 136446466;
          if (!v241) {
            v697 = "";
          }
          *(void *)&uint8_t buf[4] = "tcp_add_accecn_option";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v697;
          _os_log_impl(&dword_214653000, v696, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s not enough space to add any AccECN option", buf, 0x16u);
        }
LABEL_1495:
        uint64_t v3 = v923;
        unsigned int v149 = v245;
        goto LABEL_585;
      }
      int v243 = *(_DWORD *)(a1 + 432);
      if ((v239 & 0x400000 | v206 || (v239 & 0x1800000) != 0 || *(_DWORD *)(a1 + 92) == *(_DWORD *)(a1 + 112) + 1)
        && (!v218 || !*(_WORD *)(a1 + 226)))
      {
        int v244 = (_DWORD *)((char *)__src + (v203 | ((unint64_t)v208 << 8)));
        if ((40 - v203) > 4u)
        {
          if ((40 - v203) > 7u)
          {
            int v264 = *(_DWORD *)(a1 + 448) & 0xFFFFFF;
            if ((40 - v203) > 0xAu)
            {
              BOOL v423 = (v239 & 0x800000) == 0;
              if ((v239 & 0x800000) != 0) {
                unsigned int v424 = *(_DWORD *)(a1 + 432);
              }
              else {
                unsigned int v424 = *(_DWORD *)(a1 + 440);
              }
              if (v423) {
                int v425 = -1408565248;
              }
              else {
                int v425 = -1375010816;
              }
              if (!v423) {
                int v243 = *(_DWORD *)(a1 + 440);
              }
              *int v244 = bswap32(v425 & 0xFFFF0000 | (unsigned __int16)(v424 >> 8));
              v244[1] = bswap32(v264 | (v424 << 24));
              v244[2] = bswap32((v243 << 8) | 1);
              unsigned __int8 v242 = v203 + 12;
              if (v241 && (*(unsigned char *)(v241 + 828) & 2) != 0 || !__nwlog_is_datapath_logging_enabled()) {
                goto LABEL_584;
              }
              unsigned int v245 = v149;
              v426 = __nwlog_tcp_log();
              if (!os_log_type_enabled(v426, OS_LOG_TYPE_DEBUG)) {
                goto LABEL_1495;
              }
              v427 = (const char *)(v241 + 604);
              *(_DWORD *)long long buf = 136446722;
              if (!v241) {
                v427 = "";
              }
              *(void *)&uint8_t buf[4] = "tcp_add_accecn_option";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v427;
              *(_WORD *)&unsigned char buf[22] = 1024;
              *(_DWORD *)v955 = v242;
              uint64_t v248 = v426;
              int v249 = "%{public}s %{public}s add all 3 counters for AccECN option, optlen=%u";
            }
            else
            {
              BOOL v265 = (v239 & 0x800000) == 0;
              if ((v239 & 0x800000) != 0) {
                unsigned int v266 = *(_DWORD *)(a1 + 432);
              }
              else {
                unsigned int v266 = *(_DWORD *)(a1 + 440);
              }
              if (v265) {
                int v267 = -1408761856;
              }
              else {
                int v267 = -1375207424;
              }
              *int v244 = bswap32(v267 & 0xFFFF0000 | (unsigned __int16)(v266 >> 8));
              v244[1] = bswap32(v264 | (v266 << 24));
              unsigned __int8 v242 = v203 + 8;
              if (v241 && (*(unsigned char *)(v241 + 828) & 2) != 0 || !__nwlog_is_datapath_logging_enabled()) {
                goto LABEL_584;
              }
              unsigned int v245 = v149;
              uint64_t v268 = __nwlog_tcp_log();
              if (!os_log_type_enabled(v268, OS_LOG_TYPE_DEBUG)) {
                goto LABEL_1495;
              }
              uint64_t v269 = (const char *)(v241 + 604);
              *(_DWORD *)long long buf = 136446722;
              if (!v241) {
                uint64_t v269 = "";
              }
              *(void *)&uint8_t buf[4] = "tcp_add_accecn_option";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v269;
              *(_WORD *)&unsigned char buf[22] = 1024;
              *(_DWORD *)v955 = v242;
              uint64_t v248 = v268;
              int v249 = "%{public}s %{public}s add 2 counters for AccECN option, optlen=%u";
            }
          }
          else
          {
            BOOL v259 = (v239 & 0x800000) == 0;
            if ((v239 & 0x800000) != 0) {
              unsigned int v260 = *(_DWORD *)(a1 + 432);
            }
            else {
              unsigned int v260 = *(_DWORD *)(a1 + 440);
            }
            if (v259) {
              int v261 = -1408958464;
            }
            else {
              int v261 = -1375404032;
            }
            *int v244 = bswap32(v261 & 0xFFFF0000 | (unsigned __int16)(v260 >> 8));
            v244[1] = bswap32((v260 << 24) | 0x10101);
            unsigned __int8 v242 = v203 + 8;
            if (v241 && (*(unsigned char *)(v241 + 828) & 2) != 0 || !__nwlog_is_datapath_logging_enabled()) {
              goto LABEL_584;
            }
            unsigned int v245 = v149;
            v262 = __nwlog_tcp_log();
            if (!os_log_type_enabled(v262, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_1495;
            }
            v263 = (const char *)(v241 + 604);
            *(_DWORD *)long long buf = 136446722;
            if (!v241) {
              v263 = "";
            }
            *(void *)&uint8_t buf[4] = "tcp_add_accecn_option";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v263;
            *(_WORD *)&unsigned char buf[22] = 1024;
            *(_DWORD *)v955 = v242;
            uint64_t v248 = v262;
            int v249 = "%{public}s %{public}s add single counter for AccECN option, optlen=%u";
          }
          goto LABEL_992;
        }
        if (v206)
        {
          *int v244 = 16843438;
          unsigned __int8 v242 = v203 + 4;
          if (v241 && (*(unsigned char *)(v241 + 828) & 2) != 0 || !__nwlog_is_datapath_logging_enabled()) {
            goto LABEL_584;
          }
          unsigned int v245 = v149;
          int v246 = __nwlog_tcp_log();
          if (!os_log_type_enabled(v246, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_1495;
          }
          uint64_t v247 = (const char *)(v241 + 604);
          *(_DWORD *)long long buf = 136446722;
          if (!v241) {
            uint64_t v247 = "";
          }
          *(void *)&uint8_t buf[4] = "tcp_add_accecn_option";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v247;
          *(_WORD *)&unsigned char buf[22] = 1024;
          *(_DWORD *)v955 = v242;
          uint64_t v248 = v246;
          int v249 = "%{public}s %{public}s add empty AccECN option, optlen=%u";
LABEL_992:
          _os_log_impl(&dword_214653000, v248, OS_LOG_TYPE_DEBUG, v249, buf, 0x1Cu);
          LOBYTE(v203) = v242;
          uint64_t v3 = v923;
          unsigned int v149 = v245;
          goto LABEL_657;
        }
      }
      uint64_t v3 = v923;
      goto LABEL_657;
    }
    uint64_t v210 = *(void *)(a1 + 80);
    uint64_t v211 = *(void *)(v210 + 224);
    buf[0] = 38 - v203;
    if (*(unsigned char *)(v211 + 370))
    {
      if ((int)v124 >= 1)
      {
        *(_WORD *)(a1 + 990) |= 0x40u;
        uint64_t v217 = *(void *)(a1 + 1056);
        if (v217)
        {
          int v216 = 0;
          goto LABEL_518;
        }
      }
      int v216 = 0;
      goto LABEL_538;
    }
    unsigned int v212 = v149;
    unsigned int v213 = v203;
    os_log_type_t v214 = (char *)__src + v203;
    char v215 = (*(uint64_t (**)(uint64_t, char *))(*(void *)(v210 + 2136) + 40))(v211, v214 + 2);
    *os_log_type_t v214 = 34;
    if ((v215 & 1) == 0)
    {
      int v216 = 2;
      v214[1] = 2;
      *(unsigned char *)(a1 + 988) |= 4u;
      *(_WORD *)(a1 + 990) |= 0x10u;
      uint64_t v225 = *(void *)(a1 + 1056);
      if (v225)
      {
        int64x2_t v221 = (void *)(v225 + 1104);
        unsigned int v149 = v212;
        unsigned int v203 = v213;
        goto LABEL_536;
      }
LABEL_537:
      unsigned int v149 = v212;
      unsigned int v203 = v213;
      goto LABEL_538;
    }
    int v216 = buf[0] + 2;
    v214[1] = buf[0] + 2;
    *(unsigned char *)(a1 + 988) |= 8u;
    if ((int)v124 < 1) {
      goto LABEL_537;
    }
    *(_WORD *)(a1 + 990) |= 0x40u;
    uint64_t v217 = *(void *)(a1 + 1056);
    unsigned int v149 = v212;
    unsigned int v203 = v213;
    if (!v217) {
      goto LABEL_538;
    }
LABEL_518:
    int64x2_t v221 = (void *)(v217 + 1120);
LABEL_536:
    ++*v221;
LABEL_538:
    v203 += v216;
    unsigned int v208 = v203 >> 8;
    int v207 = *(_DWORD *)(a1 + 740);
    int v209 = 2;
LABEL_539:
    BOOL v218 = v209 == 18;
    if ((v207 & 0x20) == 0) {
      goto LABEL_566;
    }
LABEL_540:
    int v226 = *(_DWORD *)(a1 + 88);
    if ((v226 & 8) != 0 || (v226 & 0x200) == 0 || *(int *)(a1 + 12) < 4) {
      goto LABEL_566;
    }
    uint64_t v227 = *(int *)(a1 + 564);
    if ((int)v227 <= 0 && (!*v901 || !*(_DWORD *)(a1 + 944))
      || (uint64_t v228 = v203 | (v208 << 8), v229 = 38 - v228, (38 - v228) < 8))
    {
      uint64_t v3 = v923;
      goto LABEL_566;
    }
    v946 = v149;
    unsigned int v230 = v229 >> 3;
    if ((v207 & 0x10000000) == 0
      && v229 >= 0x18
      && ((v207 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1))
    {
      int v231 = *(_DWORD *)(a1 + 348);
      int v233 = (v231 & 0x1800000) != 0 && (v231 & 0x2300000) == 3145728;
      v230 -= v233;
    }
    unsigned int v234 = *v901;
    if (!*v901)
    {
      if (v230 < v227) {
        goto LABEL_604;
      }
      BOOL v236 = 0;
LABEL_603:
      unsigned int v230 = v227 + v236;
      goto LABEL_604;
    }
    int v235 = *(_DWORD *)(a1 + 944);
    BOOL v59 = v235 == 0;
    BOOL v236 = v235 != 0;
    if (v59) {
      int v237 = *(_DWORD *)(a1 + 564);
    }
    else {
      int v237 = v227 + 1;
    }
    if (v230 >= (uint64_t)v237) {
      goto LABEL_603;
    }
LABEL_604:
    int8x8_t v917 = *(_DWORD *)(a1 + 564);
    int v250 = (char *)__src + v228;
    int v251 = (2 - (_BYTE)v203) & 3;
    if (((2 - (_BYTE)v203) & 3) != 0)
    {
      __int16 v902 = v218;
      uint64_t v252 = v203 | (v208 << 8);
      int v253 = v206;
      unsigned int v254 = v230;
      memset(v250, 1, (2 - (_BYTE)v203) & 3);
      BOOL v218 = v902;
      unsigned int v230 = v254;
      int v206 = v253;
      LODWORD(v228) = v252;
      int v250 = (char *)__src + v252 + (v251 - 1) + 1;
    }
    uint64_t v255 = *(void *)(a1 + 1056);
    if (v255) {
      ++*(void *)(v255 + 600);
    }
    int v256 = (8 * v230) | 2;
    *int v250 = 5;
    uint64_t v257 = (int8x8_t *)(v250 + 2);
    v250[1] = (8 * v230) | 2;
    if (v234)
    {
      unsigned int v258 = *(_DWORD *)(a1 + 944);
      if (v258)
      {
        if ((int)v230 >= 1)
        {
          if (v917 && v230 < 2)
          {
            unsigned int v230 = 1;
            goto LABEL_646;
          }
          *(_DWORD *)(v250 + 2) = bswap32(v234);
          *(_DWORD *)(v250 + 6) = bswap32(v258);
          if (v255) {
            ++*(void *)(v255 + 1008);
          }
          uint64_t v257 = (int8x8_t *)(v250 + 10);
          ++*(_DWORD *)(a1 + 1020);
          --v230;
        }
      }
    }
    if (!v230) {
      goto LABEL_656;
    }
LABEL_646:
    if (v917 < (int)v230)
    {
      __int16 v904 = v218;
      v732 = v230;
      v884 = v256;
      v896 = v251;
      v733 = v228;
      uint64_t v919 = __nwlog_obj();
      os_log_type_enabled(v919, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "tcp_output";
      v734 = (void *)_os_log_send_and_compose_impl();
      if (!__nwlog_abort())
      {
        free(v734);
        LODWORD(v228) = v733;
        int v251 = v896;
        int v256 = v884;
        unsigned int v230 = v732;
        BOOL v218 = v904;
        if (v732 < 1) {
          goto LABEL_656;
        }
LABEL_648:
        uint64_t v270 = v230;
        if (v230 < 8)
        {
          uint64_t v271 = 0;
          goto LABEL_650;
        }
        int v272 = (const float *)(a1 + 568);
        if ((unint64_t)v257 >= v886 + 8 * v230 || v886 >= (unint64_t)&v257[v230])
        {
          uint64_t v271 = v230 & 0xFFFFFFF8;
          int v419 = (float *)&v257[4];
          uint64_t v420 = v271;
          do
          {
            v421 = v272;
            v961 = vld2q_f32(v421);
            v421 += 8;
            os_log_type_t v422 = v419 - 8;
            v962 = vld2q_f32(v421);
            v963.val[0] = (float32x4_t)vrev32q_s8((int8x16_t)v961.val[0]);
            v963.val[1] = (float32x4_t)vrev32q_s8((int8x16_t)v961.val[1]);
            vst2q_f32(v422, v963);
            v961.val[0] = (float32x4_t)vrev32q_s8((int8x16_t)v962.val[0]);
            v961.val[1] = (float32x4_t)vrev32q_s8((int8x16_t)v962.val[1]);
            vst2q_f32(v419, v961);
            v272 += 16;
            v419 += 16;
            v420 -= 8;
          }
          while (v420);
          if (v271 == v270) {
            goto LABEL_656;
          }
          v257 += v270 & 0xFFFFFFF8;
LABEL_650:
          int v272 = (const float *)(a1 + 568);
        }
        else
        {
          uint64_t v271 = 0;
        }
        uint64_t v273 = v270 - v271;
        v274 = (int8x8_t *)&v272[2 * v271];
        do
        {
          int8x8_t v275 = *v274++;
          *v257++ = vrev32_s8(v275);
          --v273;
        }
        while (v273);
        goto LABEL_656;
      }
LABEL_1898:
      __break(1u);
LABEL_1899:
      *(void *)(a1 + 1056) = 0;
      uint64_t v515 = 6;
LABEL_1900:
      if ((*(unsigned char *)(v923 + 828) & 2) == 0)
      {
        v866 = __nwlog_tcp_log();
        if (os_log_type_enabled(v866, OS_LOG_TYPE_INFO))
        {
          v867 = strerror(v515);
          *(_DWORD *)long long buf = 136446722;
          *(void *)&uint8_t buf[4] = "tcp_output";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v887;
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)v955 = v867;
          _os_log_impl(&dword_214653000, v866, OS_LOG_TYPE_INFO, "%{public}s %{public}s failed to finalize tcp checksum, %s", buf, 0x20u);
        }
      }
      v868 = *(void (**)(uint64_t, void, uint64_t))(v18 + 80);
      __int16 v25 = (void *)(a1 + 632);
      if (v868)
      {
        v869 = *(void *)(v18 + 88);
        *(void *)(v18 + 80) = 0;
        *(void *)(v18 + 88) = 0;
        v868(v18, 0, v869);
        v743 = v946;
        if (v515 == 6)
        {
LABEL_1905:
          BOOL v662 = 0;
          goto LABEL_1571;
        }
LABEL_1922:
        BOOL v662 = *(_DWORD *)(a1 + 648);
        uint64_t v515 = 55;
        goto LABEL_1571;
      }
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
      v870 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v953 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (LOBYTE(info.numer) == 17)
        {
          v871 = __nwlog_obj();
          v872 = info.numer;
          if (!os_log_type_enabled(v871, info.numer)) {
            goto LABEL_1919;
          }
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          v873 = "%{public}s called with null frame->finalizer";
LABEL_1917:
          int v878 = v871;
          unsigned int v879 = v872;
LABEL_1918:
          _os_log_impl(&dword_214653000, v878, v879, v873, buf, 0xCu);
          goto LABEL_1919;
        }
        if (v953 == OS_LOG_TYPE_DEFAULT)
        {
          v871 = __nwlog_obj();
          v872 = info.numer;
          if (!os_log_type_enabled(v871, info.numer)) {
            goto LABEL_1919;
          }
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          v873 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
          goto LABEL_1917;
        }
        v874 = (void *)__nw_create_backtrace_string();
        int v875 = __nwlog_obj();
        v876 = info.numer;
        unsigned int v877 = os_log_type_enabled(v875, info.numer);
        if (v874)
        {
          if (v877)
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v874;
            _os_log_impl(&dword_214653000, v875, v876, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v874);
        }
        else if (v877)
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          v873 = "%{public}s called with null frame->finalizer, no backtrace";
          int v878 = v875;
          unsigned int v879 = v876;
          goto LABEL_1918;
        }
      }
LABEL_1919:
      if (v870) {
        free(v870);
      }
      __int16 v25 = (void *)(a1 + 632);
      v743 = v946;
      unint64_t v124 = a1 + 100;
      if (v515 == 6) {
        goto LABEL_1905;
      }
      goto LABEL_1922;
    }
    if ((int)v230 >= 1) {
      goto LABEL_648;
    }
LABEL_656:
    unsigned int v203 = v251 + v228 + v256;
    unsigned int v208 = v203 >> 8;
    int v207 = *(_DWORD *)(a1 + 740);
    uint64_t v3 = v923;
    unsigned int v149 = v946;
    if ((v207 & 0x10000000) == 0) {
      goto LABEL_567;
    }
LABEL_657:
    uint64_t v276 = v203 | (v208 << 8);
    if (v276 <= 0x27)
    {
      int v277 = v203 & 3;
      if ((v203 & 3) != 0)
      {
        unsigned int v278 = v149;
        char v279 = 4 - v277;
        char v280 = v203;
        bzero((char *)__src + v276, (4 - v277));
        unsigned int v208 = 0;
        LOBYTE(v203) = v280 + v279;
        unsigned int v149 = v278;
      }
    }
    int v281 = *(_DWORD *)(a1 + 740);
    if ((v281 & 0x10000000) == 0)
    {
      if ((v281 & 0x8000000) != 0
        || (*(_DWORD *)(sysctls + 320) != 1 ? (BOOL v282 = tcp_do_acc_ecn == 1) : (BOOL v282 = 1), v282))
      {
        int v283 = *(_DWORD *)(a1 + 348);
        if ((~v283 & 0x300000) == 0 && (v283 & 0x400000) == 0 && *(int *)(a1 + 12) >= 4) {
          unsigned int v149 = v149 & 0xFFFFFE3F | ((*(_DWORD *)(a1 + 416) & 7) << 6);
        }
      }
    }
    unsigned int v903 = v203;
    if ((v149 & 0x12) == 2)
    {
      int v286 = *(_DWORD *)(a1 + 348);
      if ((v286 & 0x1000) == 0) {
        goto LABEL_678;
      }
      BOOL v290 = (v286 & 0x100000) != 0 && *(unsigned __int16 *)(a1 + 226) < 2u;
      if ((v286 & 0x100001) == 0 || v290)
      {
        if ((v281 & 0x10000000) != 0
          || (int v292 = 0x100000, v293 = 448, (v281 & 0x8000000) == 0)
          && *(_DWORD *)(sysctls + 320) != 1
          && tcp_do_acc_ecn != 1)
        {
          int v292 = 5;
          int v293 = 192;
        }
        uint64_t v294 = *(void *)(a1 + 1056);
        if (v294) {
          ++*(void *)(v294 + 768);
        }
        v149 |= v293;
        unsigned int v289 = v286 | v292 | 0x4000;
      }
      else
      {
        uint64_t v291 = *(void *)(a1 + 1056);
        if (v291) {
          ++*(void *)(v291 + 792);
        }
        unsigned int v289 = v286 & 0xFFFFFEFB | 0x100;
      }
LABEL_723:
      *(_DWORD *)(a1 + 348) = v289;
    }
    else
    {
      if ((v149 & 0x12) == 0x12)
      {
        int v284 = *(_DWORD *)(a1 + 348);
        if ((v284 & 0x1000) != 0)
        {
          if ((v284 & 0x200002) == 0)
          {
            unsigned int v289 = *(_DWORD *)(a1 + 348);
            goto LABEL_724;
          }
          BOOL v285 = (v284 & 0x100000) != 0 && *(unsigned __int16 *)(a1 + 226) < 2u;
          if ((v284 & 0x100001) != 0 && !v285)
          {
            uint64_t v295 = *(void *)(a1 + 1056);
            if (v295)
            {
              ++*(void *)(v295 + 848);
              --*(void *)(v295 + 808);
            }
            unsigned int v289 = v284 | 0x200;
            *(_DWORD *)(a1 + 348) = v284 | 0x200;
            if ((v281 & 0x10000000) != 0
              || (v281 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1)
            {
              unsigned int v289 = v284 & 0xFFFFFDF1 | 0x200;
              goto LABEL_723;
            }
            goto LABEL_724;
          }
          if ((v281 & 0x10000000) != 0
            || (*(_DWORD *)(sysctls + 320) != 1 ? (BOOL v297 = tcp_do_acc_ecn == 1) : (BOOL v297 = 1),
                !v297 ? (BOOL v298 = (v281 & 0x8000000) == 0) : (BOOL v298 = 0),
                (v284 & 0x200000) == 0 || v298))
          {
            if ((v284 & 2) == 0)
            {
              unsigned int v289 = *(_DWORD *)(a1 + 348);
              goto LABEL_1486;
            }
            v149 |= 0x40u;
            int v299 = 5;
          }
          else
          {
            *(void *)(a1 + 416) = 0x500000005;
            *(void *)(a1 + 472) = 0;
            *(void *)(a1 + 448) = 0;
            if ((v284 & 0x10000) != 0)
            {
              *(_WORD *)(a1 + 404) = 128;
              v149 |= 0x80u;
              v284 &= ~0x10000u;
              *(_DWORD *)(a1 + 348) = v284;
              uint64_t v406 = *(void *)(a1 + 1056);
              if (v406) {
                ++*(void *)(v406 + 816);
              }
            }
            else if ((v284 & 0x20000) != 0)
            {
              *(_WORD *)(a1 + 404) = 192;
              v149 |= 0xC0u;
              v284 &= ~0x20000u;
              int v597 = *(void *)(a1 + 1056);
              if (v597) {
                ++*(void *)(v597 + 824);
              }
            }
            else if ((v284 & 0x40000) != 0)
            {
              *(_WORD *)(a1 + 404) = 256;
              v149 |= 0x100u;
              v284 &= ~0x40000u;
              uint64_t v605 = *(void *)(a1 + 1056);
              if (v605) {
                ++*(void *)(v605 + 832);
              }
            }
            else
            {
              if ((v284 & 0x80000) == 0)
              {
                if (*(_WORD *)(a1 + 404))
                {
                  v149 |= *(unsigned __int16 *)(a1 + 404);
                  goto LABEL_1482;
                }
                v947 = v149;
                if ((*(unsigned char *)(v3 + 828) & 2) == 0)
                {
                  __nwlog_tcp_log();
                  int v646 = *(_DWORD *)(a1 + 348);
                  *(_DWORD *)long long buf = 136446722;
                  *(void *)&uint8_t buf[4] = "tcp_output";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v887;
                  *(_WORD *)&unsigned char buf[22] = 1024;
                  *(_DWORD *)v955 = v646;
                  v647 = (void *)_os_log_send_and_compose_impl();
                  LOBYTE(info.numer) = 16;
                  v953 = OS_LOG_TYPE_DEFAULT;
                  if (!__nwlog_fault()) {
                    goto LABEL_1478;
                  }
                  if (LOBYTE(info.numer) != 17)
                  {
                    if (v953)
                    {
                      int v666 = (void *)__nw_create_backtrace_string();
                      uint64_t v667 = __nwlog_tcp_log();
                      int v668 = info.numer;
                      v669 = os_log_type_enabled(v667, info.numer);
                      if (v666)
                      {
                        if (v669)
                        {
                          os_log_type_t v670 = *(_DWORD *)(a1 + 348);
                          *(_DWORD *)long long buf = 136446978;
                          *(void *)&uint8_t buf[4] = "tcp_output";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v887;
                          *(_WORD *)&unsigned char buf[22] = 1024;
                          *(_DWORD *)v955 = v670;
                          *(_WORD *)&v955[4] = 2082;
                          *(void *)&v955[6] = v666;
                          _os_log_impl(&dword_214653000, v667, v668, "%{public}s %{public}s ECN flags (0x%x) not set correctly, dumping backtrace:%{public}s", buf, 0x26u);
                        }
                        free(v666);
                        uint64_t v3 = v923;
                        goto LABEL_1478;
                      }
                      uint64_t v3 = v923;
                      if (!v669) {
                        goto LABEL_1478;
                      }
                      v692 = *(_DWORD *)(a1 + 348);
                      *(_DWORD *)long long buf = 136446722;
                      *(void *)&uint8_t buf[4] = "tcp_output";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v887;
                      *(_WORD *)&unsigned char buf[22] = 1024;
                      *(_DWORD *)v955 = v692;
                      v651 = v667;
                      v652 = v668;
                      uint64_t v653 = "%{public}s %{public}s ECN flags (0x%x) not set correctly, no backtrace";
                    }
                    else
                    {
                      unsigned int v683 = __nwlog_tcp_log();
                      v684 = info.numer;
                      if (!os_log_type_enabled(v683, info.numer)) {
                        goto LABEL_1478;
                      }
                      int v685 = *(_DWORD *)(a1 + 348);
                      *(_DWORD *)long long buf = 136446722;
                      *(void *)&uint8_t buf[4] = "tcp_output";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v887;
                      *(_WORD *)&unsigned char buf[22] = 1024;
                      *(_DWORD *)v955 = v685;
                      v651 = v683;
                      v652 = v684;
                      uint64_t v653 = "%{public}s %{public}s ECN flags (0x%x) not set correctly, backtrace limit exceeded";
                    }
LABEL_1477:
                    _os_log_impl(&dword_214653000, v651, v652, v653, buf, 0x1Cu);
                    goto LABEL_1478;
                  }
                  v648 = __nwlog_tcp_log();
                  os_log_type_t v649 = info.numer;
                  if (os_log_type_enabled(v648, info.numer))
                  {
                    v650 = *(_DWORD *)(a1 + 348);
                    *(_DWORD *)long long buf = 136446722;
                    *(void *)&uint8_t buf[4] = "tcp_output";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v887;
                    *(_WORD *)&unsigned char buf[22] = 1024;
                    *(_DWORD *)v955 = v650;
                    v651 = v648;
                    v652 = v649;
                    uint64_t v653 = "%{public}s %{public}s ECN flags (0x%x) not set correctly";
                    goto LABEL_1477;
                  }
LABEL_1478:
                  if (v647) {
                    free(v647);
                  }
                  int v284 = *(_DWORD *)(a1 + 348);
                  int v281 = *(_DWORD *)(a1 + 740);
                }
                unsigned int v149 = v947;
                LOBYTE(v203) = v903;
                goto LABEL_1482;
              }
              *(_WORD *)(a1 + 404) = 384;
              v149 |= 0x180u;
              v284 &= ~0x80000u;
              char v606 = *(void *)(a1 + 1056);
              if (v606) {
                ++*(void *)(v606 + 840);
              }
            }
LABEL_1482:
            unsigned int v289 = v284 | 0x100000;
            *(_DWORD *)(a1 + 348) = v284 | 0x100000;
            if ((v281 & 0x10000000) != 0
              || (v281 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 336) != 1 && tcp_do_l4s != 1)
            {
LABEL_1486:
              BOOL v693 = *(int64x2_t **)(a1 + 1056);
              if (v693) {
                v693[50] = vaddq_s64(v693[50], vdupq_n_s64(1uLL));
              }
              goto LABEL_724;
            }
            int v299 = 1048580;
          }
          unsigned int v289 = v284 | v299;
          *(_DWORD *)(a1 + 348) = v289;
          goto LABEL_1486;
        }
      }
LABEL_678:
      if ((v281 & 0x10000000) != 0)
      {
        unsigned int v289 = *(_DWORD *)(a1 + 348);
        goto LABEL_724;
      }
      BOOL v288 = tcp_do_acc_ecn != 1 && *(_DWORD *)(sysctls + 320) != 1 && (v281 & 0x8000000) == 0;
      unsigned int v289 = *(_DWORD *)(a1 + 348);
      if (!v288
        && (v289 & 0x300000) == 0x300000
        && v149 == 16
        && !v124
        && (v289 & 0x400000) != 0)
      {
        v149 &= 0xFFFFFE3F;
        if ((v289 & 0x10000) != 0)
        {
          v149 |= 0x80u;
          v289 &= ~0x10000u;
        }
        else if ((v289 & 0x20000) != 0)
        {
          v149 |= 0xC0u;
          v289 &= ~0x20000u;
        }
        else if ((v289 & 0x40000) != 0)
        {
          v149 |= 0x100u;
          v289 &= ~0x40000u;
        }
        else if ((v289 & 0x80000) != 0)
        {
          v149 |= 0x180u;
          v289 &= ~0x80000u;
        }
        v289 &= ~0x400000u;
        *(_DWORD *)(a1 + 348) = v289;
LABEL_753:
        if (!v124 && (v289 & 0x10) != 0)
        {
          v149 |= 0x40u;
          uint64_t v300 = *(void *)(a1 + 1056);
          if (v300) {
            ++*(void *)(v300 + 872);
          }
        }
        goto LABEL_757;
      }
    }
LABEL_724:
    if (!v124 || (v289 & 8) == 0) {
      goto LABEL_753;
    }
    char v296 = v935;
    if (*(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 96) < 0) {
      char v296 = 1;
    }
    if ((v296 & 1) == 0)
    {
      v149 |= 0x80u;
      *(_DWORD *)(a1 + 348) = v289 & 0xFFFFFFF7;
    }
LABEL_757:
    int v301 = (v203 | (v208 << 8));
    *(void *)unsigned int v901 = 0;
    unsigned int v302 = *(_DWORD *)(a1 + 156);
    if ((int)v301 + (int)v124 <= v302)
    {
      int v306 = v124;
      if ((v281 & 8) != 0) {
        goto LABEL_774;
      }
    }
    else
    {
      v149 &= ~1u;
      if (v914)
      {
        int v303 = *(_DWORD *)(a1 + 692);
        if (!v303) {
          int v303 = 0xFFFF;
        }
        int v304 = v890 - v301 + v303 - 20;
        if ((int)v124 <= v304)
        {
          int v305 = v913;
          if ((*(unsigned char *)(a1 + 89) & 8) != 0) {
            int v305 = 1;
          }
          int v304 = v124;
        }
        else
        {
          int v305 = 1;
        }
        int v306 = v304 / (v302 - v301) * (v302 - v301);
        if (v304 == v306) {
          int v307 = v305;
        }
        else {
          int v307 = 1;
        }
        v913 = v307;
        if ((v281 & 8) != 0)
        {
LABEL_774:
          if ((v281 & 4) == 0)
          {
            uint64_t v308 = *(void *)(a1 + 768);
            if (v308)
            {
              unsigned int v309 = *(_DWORD *)(v3 + 384) - *(_DWORD *)(a1 + 96) + *(_DWORD *)(a1 + 92);
              if (v309 >= *(_DWORD *)(a1 + 144)) {
                unsigned int v309 = *(_DWORD *)(a1 + 144);
              }
              if (v309 >= *(_DWORD *)(a1 + 140)) {
                unsigned int v309 = *(_DWORD *)(a1 + 140);
              }
              unsigned int v310 = *(_DWORD *)(v308 + 20);
              if (v309 < v310 && v310 != 0) {
                unsigned int v309 = 0;
              }
              *(_DWORD *)(v308 + 8) = v309;
              v312 = *(_DWORD **)(a1 + 768);
              unsigned int v313 = v312[6];
              unsigned int v314 = v312[2];
              if (v313)
              {
                if (v314 >= v313) {
                  unsigned int v314 = v312[6];
                }
                v312[2] = v314;
              }
              if (v314)
              {
                *(_DWORD *)(a1 + 740) |= 4u;
                _DWORD *v312 = *(_DWORD *)(a1 + 96);
                v312[1] = *v910;
              }
            }
          }
        }
      }
      else
      {
        int v306 = v302 - v301;
        v913 = 1;
        if ((v281 & 8) != 0) {
          goto LABEL_774;
        }
      }
    }
    v946 = v149;
    if (!*((_DWORD *)v940 + 115))
    {
      BOOL v619 = __nwlog_obj();
      os_log_type_enabled(v619, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "tcp_output";
      int v620 = (void *)_os_log_send_and_compose_impl();
      if (!__nwlog_abort())
      {
        free(v620);
        unsigned int v149 = v946;
        goto LABEL_792;
      }
      goto LABEL_1898;
    }
LABEL_792:
    BOOL v316 = (v149 & 0xFFFFFFEF) != 0 || (int)v124 >= 1 || *(unsigned char *)(a1 + 261) == 0;
    int v317 = !v316;
    if (!v316)
    {
      int v318 = *v910;
      if (*(_DWORD *)(sysctls + 268) + *(_DWORD *)(a1 + 1880) - *v910 < 0)
      {
        int v319 = *(_DWORD *)(a1 + 1876);
        if ((v319 + 1) > 1) {
          int v320 = v319 + 1;
        }
        else {
          int v320 = 1;
        }
        *(_DWORD *)(a1 + 1876) = v320;
        *(_DWORD *)(a1 + 1880) = v318;
      }
    }
    unsigned int v321 = v301 + 20;
    LOBYTE(v896) = v306 != 0;
    char v918 = v301;
    if (!v306)
    {
      if (*(unsigned char *)(a1 + 88))
      {
        uint64_t v329 = *(void *)(a1 + 1056);
        if (v329) {
          ++*(void *)(v329 + 48);
        }
      }
      else
      {
        uint64_t v324 = *(void *)(a1 + 1056);
        if ((v149 & 7) != 0)
        {
          if (v324) {
            ++*(void *)(v324 + 88);
          }
        }
        else if (v324)
        {
          ++*(void *)(v324 + 80);
        }
      }
      if (!v317 || (*(unsigned char *)(a1 + 743) & 2) == 0 || !*(_DWORD *)(a1 + 672)) {
        goto LABEL_900;
      }
      uint64_t v18 = **(void **)(*(void *)(a1 + 664) + 8);
      if (v18)
      {
        unsigned int v361 = *(_DWORD *)(v18 + 52);
        goto LABEL_899;
      }
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
      uint64_t v698 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v953 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault()) {
        goto LABEL_1565;
      }
      if (LOBYTE(info.numer) == 17)
      {
        int v699 = __nwlog_obj();
        v700 = info.numer;
        if (os_log_type_enabled(v699, info.numer))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
          v701 = v699;
          BOOL v702 = v700;
          v703 = "%{public}s called with null frame";
          goto LABEL_1564;
        }
        goto LABEL_1565;
      }
      if (v953 == OS_LOG_TYPE_DEFAULT)
      {
        BOOL v741 = __nwlog_obj();
        v742 = info.numer;
        if (!os_log_type_enabled(v741, info.numer)) {
          goto LABEL_1565;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
        v701 = v741;
        BOOL v702 = v742;
        v703 = "%{public}s called with null frame, backtrace limit exceeded";
LABEL_1564:
        _os_log_impl(&dword_214653000, v701, v702, v703, buf, 0xCu);
        goto LABEL_1565;
      }
      v735 = (void *)__nw_create_backtrace_string();
      uint64_t v736 = __nwlog_obj();
      uint64_t v737 = info.numer;
      v930 = v736;
      v738 = os_log_type_enabled(v736, info.numer);
      if (v735)
      {
        if (v738)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v735;
          _os_log_impl(&dword_214653000, v930, v737, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v735);
        goto LABEL_1565;
      }
      if (v738)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
        v701 = v930;
        BOOL v702 = v737;
        v703 = "%{public}s called with null frame, no backtrace";
        goto LABEL_1564;
      }
LABEL_1565:
      if (v698) {
        free(v698);
      }
      unsigned int v361 = 0;
      uint64_t v3 = v923;
LABEL_899:
      if (v361 < *(_DWORD *)(v18 + 56) + v321)
      {
LABEL_900:
        uint64_t v362 = *(void *)(v3 + 24);
        uint64_t v363 = *(void *)(v362 + 32);
        *(void *)long long buf = 0;
        *(void *)&buf[8] = buf;
        if (!(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)(v363 + 24) + 88))(v363, v362))
        {
          LOBYTE(v896) = 0;
          uint64_t v515 = 55;
          goto LABEL_1691;
        }
        uint64_t v18 = *(void *)buf;
        if (*(void *)buf) {
          goto LABEL_902;
        }
        __nwlog_obj();
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
        v654 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(info.numer) = 16;
        v953 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault())
        {
          if (LOBYTE(info.numer) != 17)
          {
            if (v953)
            {
              unsigned int v676 = (void *)__nw_create_backtrace_string();
              unsigned int v677 = __nwlog_obj();
              int v678 = info.numer;
              v679 = os_log_type_enabled(v677, info.numer);
              if (v676)
              {
                if (v679)
                {
                  *(_DWORD *)long long buf = 136446466;
                  *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v676;
                  _os_log_impl(&dword_214653000, v677, v678, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                }
                free(v676);
                goto LABEL_1508;
              }
              if (!v679) {
                goto LABEL_1508;
              }
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
              v657 = v677;
              BOOL v658 = v678;
              int v659 = "%{public}s called with null frame, no backtrace";
            }
            else
            {
              v694 = __nwlog_obj();
              v695 = info.numer;
              if (!os_log_type_enabled(v694, info.numer)) {
                goto LABEL_1508;
              }
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
              v657 = v694;
              BOOL v658 = v695;
              int v659 = "%{public}s called with null frame, backtrace limit exceeded";
            }
LABEL_1507:
            _os_log_impl(&dword_214653000, v657, v658, v659, buf, 0xCu);
            goto LABEL_1508;
          }
          uint64_t v655 = __nwlog_obj();
          int v656 = info.numer;
          if (os_log_type_enabled(v655, info.numer))
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
            v657 = v655;
            BOOL v658 = v656;
            int v659 = "%{public}s called with null frame";
            goto LABEL_1507;
          }
        }
LABEL_1508:
        if (v654) {
          free(v654);
        }
        __nwlog_obj();
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
        BOOL v708 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(info.numer) = 16;
        v953 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault())
        {
          if (LOBYTE(info.numer) != 17)
          {
            if (v953)
            {
              v714 = (void *)__nw_create_backtrace_string();
              v715 = __nwlog_obj();
              v716 = info.numer;
              v717 = os_log_type_enabled(v715, info.numer);
              if (v714)
              {
                if (v717)
                {
                  *(_DWORD *)long long buf = 136446466;
                  *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v714;
                  _os_log_impl(&dword_214653000, v715, v716, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                }
                free(v714);
                goto LABEL_1524;
              }
              if (!v717) {
                goto LABEL_1524;
              }
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
              v711 = v715;
              v712 = v716;
              v713 = "%{public}s called with null frame, no backtrace";
            }
            else
            {
              v718 = __nwlog_obj();
              v719 = info.numer;
              if (!os_log_type_enabled(v718, info.numer)) {
                goto LABEL_1524;
              }
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
              v711 = v718;
              v712 = v719;
              v713 = "%{public}s called with null frame, backtrace limit exceeded";
            }
LABEL_1523:
            _os_log_impl(&dword_214653000, v711, v712, v713, buf, 0xCu);
            goto LABEL_1524;
          }
          v709 = __nwlog_obj();
          os_log_type_t v710 = info.numer;
          if (os_log_type_enabled(v709, info.numer))
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
            v711 = v709;
            v712 = v710;
            v713 = "%{public}s called with null frame";
            goto LABEL_1523;
          }
        }
LABEL_1524:
        if (v708) {
          free(v708);
        }
        __nwlog_obj();
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_unclaim_internal";
        v720 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(info.numer) = 16;
        v953 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault())
        {
          if (LOBYTE(info.numer) != 17)
          {
            if (v953)
            {
              BOOL v726 = (void *)__nw_create_backtrace_string();
              v727 = __nwlog_obj();
              int v728 = info.numer;
              int v729 = os_log_type_enabled(v727, info.numer);
              if (v726)
              {
                if (v729)
                {
                  *(_DWORD *)long long buf = 136446466;
                  *(void *)&uint8_t buf[4] = "__nw_frame_unclaim_internal";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v726;
                  _os_log_impl(&dword_214653000, v727, v728, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                }
                free(v726);
                goto LABEL_1540;
              }
              if (!v729) {
                goto LABEL_1540;
              }
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_unclaim_internal";
              os_log_type_t v723 = v727;
              unsigned int v724 = v728;
              unsigned int v725 = "%{public}s called with null frame, no backtrace";
            }
            else
            {
              int v730 = __nwlog_obj();
              unsigned int v731 = info.numer;
              if (!os_log_type_enabled(v730, info.numer)) {
                goto LABEL_1540;
              }
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_unclaim_internal";
              os_log_type_t v723 = v730;
              unsigned int v724 = v731;
              unsigned int v725 = "%{public}s called with null frame, backtrace limit exceeded";
            }
LABEL_1539:
            _os_log_impl(&dword_214653000, v723, v724, v725, buf, 0xCu);
            goto LABEL_1540;
          }
          v721 = __nwlog_obj();
          v722 = info.numer;
          if (os_log_type_enabled(v721, info.numer))
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_unclaim_internal";
            os_log_type_t v723 = v721;
            unsigned int v724 = v722;
            unsigned int v725 = "%{public}s called with null frame";
            goto LABEL_1539;
          }
        }
LABEL_1540:
        if (v720) {
          free(v720);
        }
        uint64_t v18 = 0;
        int v433 = 1;
        size_t v345 = (size_t)v918;
        if (!*(void *)(v3 + 24))
        {
LABEL_1014:
          if (v18)
          {
            int v415 = v946;
            goto LABEL_1016;
          }
          LOBYTE(v896) = 0;
LABEL_1620:
          __int16 v25 = (void *)(a1 + 632);
LABEL_1621:
          if ((*(unsigned char *)(v3 + 828) & 2) == 0)
          {
            v765 = __nwlog_tcp_log();
            if (os_log_type_enabled(v765, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)long long buf = 136446466;
              *(void *)&uint8_t buf[4] = "tcp_output";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v887;
              _os_log_impl(&dword_214653000, v765, OS_LOG_TYPE_INFO, "%{public}s %{public}s output buffer is no longer valid", buf, 0x16u);
            }
          }
          if (v18)
          {
            v766 = *(void (**)(uint64_t, void, uint64_t))(v18 + 80);
            if (v766)
            {
              v767 = *(void *)(v18 + 88);
              *(void *)(v18 + 80) = 0;
              *(void *)(v18 + 88) = 0;
              v766(v18, 0, v767);
              uint64_t v515 = 6;
LABEL_1627:
              v749 = (void *)*v25;
              if (*v25) {
                goto LABEL_1628;
              }
              goto LABEL_1692;
            }
            __nwlog_obj();
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            int v832 = (void *)_os_log_send_and_compose_impl();
            LOBYTE(info.numer) = 16;
            v953 = OS_LOG_TYPE_DEFAULT;
            if (__nwlog_fault())
            {
              if (LOBYTE(info.numer) == 17)
              {
                v833 = __nwlog_obj();
                unsigned int v834 = info.numer;
                if (!os_log_type_enabled(v833, info.numer)) {
                  goto LABEL_1858;
                }
                *(_DWORD *)long long buf = 136446210;
                *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
                unsigned int v835 = "%{public}s called with null frame->finalizer";
                goto LABEL_1856;
              }
              if (v953 == OS_LOG_TYPE_DEFAULT)
              {
                v833 = __nwlog_obj();
                unsigned int v834 = info.numer;
                if (!os_log_type_enabled(v833, info.numer)) {
                  goto LABEL_1858;
                }
                *(_DWORD *)long long buf = 136446210;
                *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
                unsigned int v835 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
                goto LABEL_1856;
              }
              v840 = (void *)__nw_create_backtrace_string();
              unint64_t v837 = __nwlog_obj();
              int v838 = info.numer;
              os_log_type_t v841 = os_log_type_enabled(v837, info.numer);
              if (v840)
              {
                if (v841)
                {
                  *(_DWORD *)long long buf = 136446466;
                  *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v840;
                  _os_log_impl(&dword_214653000, v837, v838, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
                }
                free(v840);
                if (!v832) {
                  goto LABEL_1860;
                }
                goto LABEL_1859;
              }
              if (v841)
              {
                *(_DWORD *)long long buf = 136446210;
                *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
                unsigned int v835 = "%{public}s called with null frame->finalizer, no backtrace";
                goto LABEL_1865;
              }
            }
          }
          else
          {
            __nwlog_obj();
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            int v832 = (void *)_os_log_send_and_compose_impl();
            LOBYTE(info.numer) = 16;
            v953 = OS_LOG_TYPE_DEFAULT;
            if (!__nwlog_fault()) {
              goto LABEL_1858;
            }
            if (LOBYTE(info.numer) == 17)
            {
              v833 = __nwlog_obj();
              unsigned int v834 = info.numer;
              if (!os_log_type_enabled(v833, info.numer)) {
                goto LABEL_1858;
              }
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
              unsigned int v835 = "%{public}s called with null frame";
LABEL_1856:
              v852 = v833;
              v853 = v834;
LABEL_1857:
              _os_log_impl(&dword_214653000, v852, v853, v835, buf, 0xCu);
              goto LABEL_1858;
            }
            if (v953 == OS_LOG_TYPE_DEFAULT)
            {
              v833 = __nwlog_obj();
              unsigned int v834 = info.numer;
              if (!os_log_type_enabled(v833, info.numer)) {
                goto LABEL_1858;
              }
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
              unsigned int v835 = "%{public}s called with null frame, backtrace limit exceeded";
              goto LABEL_1856;
            }
            int v836 = (void *)__nw_create_backtrace_string();
            unint64_t v837 = __nwlog_obj();
            int v838 = info.numer;
            uint64_t v839 = os_log_type_enabled(v837, info.numer);
            if (v836)
            {
              if (v839)
              {
                *(_DWORD *)long long buf = 136446466;
                *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v836;
                _os_log_impl(&dword_214653000, v837, v838, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v836);
            }
            else if (v839)
            {
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
              unsigned int v835 = "%{public}s called with null frame, no backtrace";
LABEL_1865:
              v852 = v837;
              v853 = v838;
              goto LABEL_1857;
            }
          }
LABEL_1858:
          if (!v832)
          {
LABEL_1860:
            uint64_t v515 = 6;
LABEL_1691:
            v749 = (void *)*v949;
            if (*v949) {
              goto LABEL_1628;
            }
            goto LABEL_1692;
          }
LABEL_1859:
          free(v832);
          goto LABEL_1860;
        }
LABEL_1007:
        uint64_t v434 = nw_protocol_tcp_get_all_stats();
        if (v434) {
          ++*(void *)(v434 + 32);
        }
        if (!*(void *)(v3 + 24)) {
          goto LABEL_1014;
        }
        uint64_t v435 = nw_protocol_tcp_get_all_stats();
        if (!v435) {
          goto LABEL_1014;
        }
        uint64_t v436 = v435;
        if (!v433)
        {
          uint64_t v437 = *(unsigned int *)(v18 + 52);
LABEL_1013:
          *(void *)(v436 + 40) += v437;
          goto LABEL_1014;
        }
        __nwlog_obj();
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
        v686 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(info.numer) = 16;
        v953 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault())
        {
          if (LOBYTE(info.numer) == 17)
          {
            v687 = __nwlog_obj();
            uint64_t v688 = info.numer;
            if (os_log_type_enabled(v687, info.numer))
            {
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
              uint64_t v689 = v687;
              v690 = v688;
              os_log_type_t v691 = "%{public}s called with null frame";
LABEL_1558:
              _os_log_impl(&dword_214653000, v689, v690, v691, buf, 0xCu);
            }
          }
          else if (v953)
          {
            v704 = (void *)__nw_create_backtrace_string();
            v705 = __nwlog_obj();
            v706 = info.numer;
            v929 = v705;
            v707 = os_log_type_enabled(v705, info.numer);
            if (v704)
            {
              if (v707)
              {
                *(_DWORD *)long long buf = 136446466;
                *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v704;
                _os_log_impl(&dword_214653000, v929, v706, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v704);
              goto LABEL_1559;
            }
            if (v707)
            {
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
              uint64_t v689 = v929;
              v690 = v706;
              os_log_type_t v691 = "%{public}s called with null frame, no backtrace";
              goto LABEL_1558;
            }
          }
          else
          {
            os_log_type_t v739 = __nwlog_obj();
            v740 = info.numer;
            if (os_log_type_enabled(v739, info.numer))
            {
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
              uint64_t v689 = v739;
              v690 = v740;
              os_log_type_t v691 = "%{public}s called with null frame, backtrace limit exceeded";
              goto LABEL_1558;
            }
          }
        }
LABEL_1559:
        if (v686) {
          free(v686);
        }
        uint64_t v437 = 0;
        size_t v345 = (size_t)v918;
        uint64_t v3 = v923;
        goto LABEL_1013;
      }
      if ((*(_WORD *)(v18 + 204) & 0x40) == 0)
      {
        if (*(_DWORD *)(a1 + 1876) != *(_DWORD *)(v18 + 192)) {
          goto LABEL_900;
        }
LABEL_1390:
        v601 = *(void *)(v18 + 32);
        int v602 = *(void **)(v18 + 40);
        if (v601)
        {
          *(void *)(v601 + 40) = v602;
          int v602 = *(void **)(v18 + 40);
        }
        else
        {
          *(void *)(a1 + 664) = v602;
        }
        *int v602 = v601;
        *(void *)(v18 + 32) = 0;
        *(void *)(v18 + 40) = 0;
        --*(_DWORD *)(a1 + 672);
        if (*(void *)(v3 + 24))
        {
          int v603 = nw_protocol_tcp_get_all_stats();
          if (v603) {
            --*(void *)(v603 + 32);
          }
          if (*(void *)(v3 + 24))
          {
            uint64_t v604 = nw_protocol_tcp_get_all_stats();
            if (v604) {
              *(void *)(v604 + 40) -= *(unsigned int *)(v18 + 52);
            }
          }
        }
        ++*(_DWORD *)(a1 + 1884);
LABEL_902:
        if ((*(_WORD *)(v18 + 204) & 0x80) != 0) {
          *(_WORD *)(v18 + 196) -= v321;
        }
        int v364 = *(_DWORD *)(v18 + 52);
        unsigned int v365 = *(_DWORD *)(v18 + 56) + v321;
        int v366 = *(_DWORD *)(v18 + 60);
        if (v365 <= v364 - v366)
        {
          *(_DWORD *)(v18 + 56) = v365;
          *(_DWORD *)(v18 + 60) = v366;
        }
        else
        {
          int v367 = __nwlog_obj();
          BOOL v368 = os_log_type_enabled(v367, OS_LOG_TYPE_ERROR);
          int v364 = *(_DWORD *)(v18 + 52);
          if (v368)
          {
            *(_DWORD *)long long buf = 136446978;
            *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v365;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v364;
            *(_WORD *)v955 = 1024;
            *(_DWORD *)&v955[2] = v366;
            _os_log_impl(&dword_214653000, v367, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
            int v364 = *(_DWORD *)(v18 + 52);
          }
        }
        size_t v345 = (size_t)v918;
        if (!v364) {
          goto LABEL_999;
        }
        uint64_t v370 = *(unsigned int *)(v18 + 56);
        size_t v369 = *(unsigned int *)(v18 + 60);
        uint64_t v371 = (v364 - (v369 + v370));
        if (v364 == v369 + v370) {
          goto LABEL_999;
        }
        if (v369)
        {
          uint64_t v372 = *(void *)(v18 + 112);
          if (v372)
          {
            memmove((void *)(v372 + v370), (const void *)(v372 + v370 + v371), v369);
            int v364 = *(_DWORD *)(v18 + 52);
          }
        }
        *(_DWORD *)(v18 + 52) = v364 - v371;
        if ((*(_WORD *)(v18 + 204) & 0x80) == 0
          || (unsigned int v373 = *(unsigned __int16 *)(v18 + 196),
              BOOL v351 = v373 >= v371,
              unsigned int v374 = v373 - v371,
              *(_WORD *)(v18 + 196) = v374,
              v351)
          && v374 < 0x10000)
        {
LABEL_999:
          if ((*(_WORD *)(v18 + 204) & 0x80) != 0) {
            *(_WORD *)(v18 + 196) += v321;
          }
          unsigned int v429 = *(_DWORD *)(v18 + 56);
          BOOL v351 = v429 >= v321;
          unsigned int v430 = v429 - v321;
          uint64_t v3 = v923;
          if (v351)
          {
            int v433 = 0;
            *(_DWORD *)(v18 + 56) = v430;
            if (!*(void *)(v923 + 24)) {
              goto LABEL_1014;
            }
          }
          else
          {
            int v431 = __nwlog_obj();
            if (os_log_type_enabled(v431, OS_LOG_TYPE_ERROR))
            {
              int v432 = *(_DWORD *)(v18 + 56);
              *(_DWORD *)long long buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_frame_unclaim_internal";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v321;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v432;
              _os_log_impl(&dword_214653000, v431, OS_LOG_TYPE_ERROR, "%{public}s Frame cannot unclaim %u start bytes (has %u left)", buf, 0x18u);
            }
            int v433 = 0;
            if (!*(void *)(v923 + 24)) {
              goto LABEL_1014;
            }
          }
          goto LABEL_1007;
        }
        __nwlog_obj();
        uint64_t v375 = *(unsigned __int16 *)(v18 + 196);
        *(_DWORD *)long long buf = 136446978;
        *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = "frame->aggregate_buffer_length";
        *(_WORD *)&unsigned char buf[22] = 2048;
        *(void *)v955 = v371;
        *(_WORD *)&v955[8] = 2048;
        *(void *)&v955[10] = v375;
        uint64_t v376 = _os_log_send_and_compose_impl();
        LOBYTE(info.numer) = 16;
        v953 = OS_LOG_TYPE_DEFAULT;
        v925 = (os_log_t)v376;
        if (__nwlog_fault())
        {
          if (LOBYTE(info.numer) == 17)
          {
            os_log_type_t v377 = __nwlog_obj();
            os_log_type_t v378 = info.numer;
            if (os_log_type_enabled(v377, info.numer))
            {
              uint64_t v379 = *(unsigned __int16 *)(v18 + 196);
              *(_DWORD *)long long buf = 136446978;
              *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "frame->aggregate_buffer_length";
              *(_WORD *)&unsigned char buf[22] = 2048;
              *(void *)v955 = v371;
              *(_WORD *)&v955[8] = 2048;
              *(void *)&v955[10] = v379;
              v380 = v377;
              os_log_type_t v381 = v378;
              int v382 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_995:
              _os_log_impl(&dword_214653000, v380, v381, v382, buf, 0x2Au);
            }
          }
          else if (v953)
          {
            int v394 = (void *)__nw_create_backtrace_string();
            v395 = __nwlog_obj();
            os_log_type_t v396 = info.numer;
            v882 = v395;
            BOOL v397 = os_log_type_enabled(v395, info.numer);
            if (v394)
            {
              if (v397)
              {
                uint64_t v398 = *(unsigned __int16 *)(v18 + 196);
                *(_DWORD *)long long buf = 136447234;
                *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = "frame->aggregate_buffer_length";
                *(_WORD *)&unsigned char buf[22] = 2048;
                *(void *)v955 = v371;
                *(_WORD *)&v955[8] = 2048;
                *(void *)&v955[10] = v398;
                *(_WORD *)&v955[18] = 2082;
                *(void *)&v955[20] = v394;
                _os_log_impl(&dword_214653000, v882, v396, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
              }
              free(v394);
              goto LABEL_996;
            }
            if (v397)
            {
              uint64_t v428 = *(unsigned __int16 *)(v18 + 196);
              *(_DWORD *)long long buf = 136446978;
              *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "frame->aggregate_buffer_length";
              *(_WORD *)&unsigned char buf[22] = 2048;
              *(void *)v955 = v371;
              *(_WORD *)&v955[8] = 2048;
              *(void *)&v955[10] = v428;
              v380 = v882;
              os_log_type_t v381 = v396;
              int v382 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              goto LABEL_995;
            }
          }
          else
          {
            int v407 = __nwlog_obj();
            os_log_type_t v408 = info.numer;
            if (os_log_type_enabled(v407, info.numer))
            {
              uint64_t v409 = *(unsigned __int16 *)(v18 + 196);
              *(_DWORD *)long long buf = 136446978;
              *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "frame->aggregate_buffer_length";
              *(_WORD *)&unsigned char buf[22] = 2048;
              *(void *)v955 = v371;
              *(_WORD *)&v955[8] = 2048;
              *(void *)&v955[10] = v409;
              v380 = v407;
              os_log_type_t v381 = v408;
              int v382 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              goto LABEL_995;
            }
          }
        }
LABEL_996:
        if (v925) {
          free(v925);
        }
        *(_WORD *)(v18 + 196) = 0;
        size_t v345 = (size_t)v918;
        goto LABEL_999;
      }
      v926 = *(_DWORD *)(a1 + 1876);
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
      uint64_t v388 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v953 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (LOBYTE(info.numer) == 17)
        {
          int v389 = __nwlog_obj();
          os_log_type_t v390 = info.numer;
          if (!os_log_type_enabled(v389, info.numer)) {
            goto LABEL_1387;
          }
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
          int v391 = v389;
          os_log_type_t v392 = v390;
          unsigned int v393 = "%{public}s Attempt to get generation-count on a chain-member";
LABEL_1386:
          _os_log_impl(&dword_214653000, v391, v392, v393, buf, 0xCu);
          goto LABEL_1387;
        }
        if (v953 == OS_LOG_TYPE_DEFAULT)
        {
          v598 = __nwlog_obj();
          int v599 = info.numer;
          if (!os_log_type_enabled(v598, info.numer)) {
            goto LABEL_1387;
          }
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
          int v391 = v598;
          os_log_type_t v392 = v599;
          unsigned int v393 = "%{public}s Attempt to get generation-count on a chain-member, backtrace limit exceeded";
          goto LABEL_1386;
        }
        uint64_t v402 = (void *)__nw_create_backtrace_string();
        BOOL v403 = __nwlog_obj();
        os_log_type_t v404 = info.numer;
        v883 = v403;
        BOOL v405 = os_log_type_enabled(v403, info.numer);
        if (!v402)
        {
          if (!v405) {
            goto LABEL_1387;
          }
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
          int v391 = v883;
          os_log_type_t v392 = v404;
          unsigned int v393 = "%{public}s Attempt to get generation-count on a chain-member, no backtrace";
          goto LABEL_1386;
        }
        if (v405)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v402;
          _os_log_impl(&dword_214653000, v883, v404, "%{public}s Attempt to get generation-count on a chain-member, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v402);
      }
LABEL_1387:
      if (v388) {
        free(v388);
      }
      uint64_t v3 = v923;
      if (v926) {
        goto LABEL_900;
      }
      goto LABEL_1390;
    }
    if (!*(_WORD *)(a1 + 696) && *(_DWORD *)(a1 + 100) == *(_DWORD *)(a1 + 92)) {
      *(_WORD *)(a1 + 696) = v306 + (_WORD)v301;
    }
    if (v306 != 1 || (*(_DWORD *)(a1 + 740) & 0x8000) == 0)
    {
      unsigned int v325 = *(void **)(a1 + 1056);
      if (((*(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 96) >= 0) & ~v935) != 0)
      {
        if (v325)
        {
          uint64_t v330 = v325[2] + v306;
          ++v325[1];
          v325[2] = v330;
        }
        uint64_t v331 = *((void *)v940 + 31);
        ++*(void *)(v331 + 16);
        if (v906) {
          ++*(void *)(*((void *)v940 + 32) + 16);
        }
        if (HIDWORD(v905)) {
          ++*(void *)(*((void *)v940 + 33) + 16);
        }
        if (v905) {
          ++*(void *)(*((void *)v940 + 34) + 16);
        }
        *(void *)(v331 + 24) += v306;
        if (v906) {
          *(void *)(*((void *)v940 + 32) + 24) += v306;
        }
        if (HIDWORD(v905)) {
          *(void *)(*((void *)v940 + 33) + 24) += v306;
        }
        if (v905) {
          *(void *)(*((void *)v940 + 34) + 24) += v306;
        }
        int v323 = (void *)(a1 + 368);
        if ((*(unsigned char *)(a1 + 348) & 4) == 0) {
          goto LABEL_857;
        }
      }
      else
      {
        if (v325)
        {
          uint64_t v326 = v325[4] + v306;
          ++v325[3];
          v325[4] = v326;
        }
        uint64_t v327 = *((void *)v940 + 31);
        ++*(void *)(v327 + 16);
        if (v906) {
          ++*(void *)(*((void *)v940 + 32) + 16);
        }
        if (HIDWORD(v905)) {
          ++*(void *)(*((void *)v940 + 33) + 16);
        }
        if (v905) {
          ++*(void *)(*((void *)v940 + 34) + 16);
        }
        *(void *)(v327 + 24) += v306;
        if (v906) {
          *(void *)(*((void *)v940 + 32) + 24) += v306;
        }
        if (HIDWORD(v905)) {
          *(void *)(*((void *)v940 + 33) + 24) += v306;
        }
        if (v905) {
          *(void *)(*((void *)v940 + 34) + 24) += v306;
        }
        *(_DWORD *)(a1 + 712) += v306;
        ++*(_DWORD *)(a1 + 720);
        if (*(void *)(v3 + 24))
        {
          uint64_t v328 = nw_protocol_tcp_get_all_stats();
          if (v328) {
            *(_DWORD *)(v328 + 56) += v306;
          }
        }
        int v323 = (void *)(a1 + 392);
        if ((*(unsigned char *)(a1 + 348) & 4) == 0) {
          goto LABEL_857;
        }
      }
LABEL_856:
      ++*v323;
      goto LABEL_857;
    }
    uint64_t v322 = *(void *)(a1 + 1056);
    if (v322)
    {
      int v323 = (void *)(v322 + 72);
      goto LABEL_856;
    }
LABEL_857:
    if (!*(void *)(v3 + 400) || v924 < 0)
    {
      if (!v18 || (*(unsigned char *)(v3 + 828) & 2) != 0)
      {
LABEL_1690:
        uint64_t v515 = 0;
        LOBYTE(v896) = 1;
        goto LABEL_1691;
      }
      __nwlog_tcp_log();
      v750 = *(_DWORD *)(v3 + 384);
      v751 = tcpstates[*(int *)(a1 + 12)];
      if (*(void *)(v3 + 400)) {
        v752 = "not";
      }
      else {
        v752 = "is";
      }
      *(_DWORD *)long long buf = 136447746;
      *(void *)&uint8_t buf[4] = "tcp_output";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v887;
      *(_WORD *)&unsigned char buf[22] = 2082;
      *(void *)v955 = v752;
      *(_WORD *)&v955[8] = 1024;
      *(_DWORD *)&v955[10] = v750;
      *(_WORD *)&v955[14] = 1024;
      *(_DWORD *)&v955[16] = v924;
      *(_WORD *)&v955[20] = 1024;
      *(_DWORD *)&v955[22] = v306;
      *(_WORD *)&v955[26] = 2082;
      v956 = v751;
      v753 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v953 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (LOBYTE(info.numer) == 17)
        {
          v754 = __nwlog_tcp_log();
          v755 = info.numer;
          if (!os_log_type_enabled(v754, info.numer)) {
            goto LABEL_1688;
          }
          if (*(void *)(v3 + 400)) {
            v756 = "not";
          }
          else {
            v756 = "is";
          }
          v757 = *(_DWORD *)(v3 + 384);
          v758 = tcpstates[*(int *)(a1 + 12)];
          *(_DWORD *)long long buf = 136447746;
          *(void *)&uint8_t buf[4] = "tcp_output";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v887;
          *(_WORD *)&unsigned char buf[22] = 2082;
          *(void *)v955 = v756;
          *(_WORD *)&v955[8] = 1024;
          *(_DWORD *)&v955[10] = v757;
          *(_WORD *)&v955[14] = 1024;
          *(_DWORD *)&v955[16] = v924;
          *(_WORD *)&v955[20] = 1024;
          *(_DWORD *)&v955[22] = v306;
          *(_WORD *)&v955[26] = 2082;
          v956 = v758;
          v759 = "%{public}s %{public}s m is non-NULL but there is nothing to send so_snd.sb_mb %{public}s empty so_snd.s"
                 "b_cc %u off %d len %d t_state[%{public}s]";
          goto LABEL_1687;
        }
        if (v953 == OS_LOG_TYPE_DEFAULT)
        {
          v754 = __nwlog_tcp_log();
          v755 = info.numer;
          if (!os_log_type_enabled(v754, info.numer)) {
            goto LABEL_1688;
          }
          if (*(void *)(v3 + 400)) {
            os_log_type_t v785 = "not";
          }
          else {
            os_log_type_t v785 = "is";
          }
          v786 = *(_DWORD *)(v3 + 384);
          v787 = tcpstates[*(int *)(a1 + 12)];
          *(_DWORD *)long long buf = 136447746;
          *(void *)&uint8_t buf[4] = "tcp_output";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v887;
          *(_WORD *)&unsigned char buf[22] = 2082;
          *(void *)v955 = v785;
          *(_WORD *)&v955[8] = 1024;
          *(_DWORD *)&v955[10] = v786;
          *(_WORD *)&v955[14] = 1024;
          *(_DWORD *)&v955[16] = v924;
          *(_WORD *)&v955[20] = 1024;
          *(_DWORD *)&v955[22] = v306;
          *(_WORD *)&v955[26] = 2082;
          v956 = v787;
          v759 = "%{public}s %{public}s m is non-NULL but there is nothing to send so_snd.sb_mb %{public}s empty so_snd.s"
                 "b_cc %u off %d len %d t_state[%{public}s], backtrace limit exceeded";
          goto LABEL_1687;
        }
        v778 = (void *)__nw_create_backtrace_string();
        v754 = __nwlog_tcp_log();
        v755 = info.numer;
        v779 = os_log_type_enabled(v754, info.numer);
        if (v778)
        {
          if (v779)
          {
            if (*(void *)(v3 + 400)) {
              v780 = "not";
            }
            else {
              v780 = "is";
            }
            v781 = *(_DWORD *)(v3 + 384);
            os_log_type_t v782 = tcpstates[*(int *)(a1 + 12)];
            *(_DWORD *)long long buf = 136448002;
            *(void *)&uint8_t buf[4] = "tcp_output";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v887;
            *(_WORD *)&unsigned char buf[22] = 2082;
            *(void *)v955 = v780;
            *(_WORD *)&v955[8] = 1024;
            *(_DWORD *)&v955[10] = v781;
            *(_WORD *)&v955[14] = 1024;
            *(_DWORD *)&v955[16] = v924;
            *(_WORD *)&v955[20] = 1024;
            *(_DWORD *)&v955[22] = v306;
            *(_WORD *)&v955[26] = 2082;
            v956 = v782;
            LOWORD(v957[0]) = 2082;
            *(void *)((char *)v957 + 2) = v778;
            _os_log_impl(&dword_214653000, v754, v755, "%{public}s %{public}s m is non-NULL but there is nothing to send so_snd.sb_mb %{public}s empty so_snd.sb_cc %u off %d len %d t_state[%{public}s], dumping backtrace:%{public}s", buf, 0x46u);
          }
          free(v778);
          goto LABEL_1688;
        }
        if (v779)
        {
          if (*(void *)(v3 + 400)) {
            v789 = "not";
          }
          else {
            v789 = "is";
          }
          v790 = *(_DWORD *)(v3 + 384);
          v791 = tcpstates[*(int *)(a1 + 12)];
          *(_DWORD *)long long buf = 136447746;
          *(void *)&uint8_t buf[4] = "tcp_output";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v887;
          *(_WORD *)&unsigned char buf[22] = 2082;
          *(void *)v955 = v789;
          *(_WORD *)&v955[8] = 1024;
          *(_DWORD *)&v955[10] = v790;
          *(_WORD *)&v955[14] = 1024;
          *(_DWORD *)&v955[16] = v924;
          *(_WORD *)&v955[20] = 1024;
          *(_DWORD *)&v955[22] = v306;
          *(_WORD *)&v955[26] = 2082;
          v956 = v791;
          v759 = "%{public}s %{public}s m is non-NULL but there is nothing to send so_snd.sb_mb %{public}s empty so_snd.s"
                 "b_cc %u off %d len %d t_state[%{public}s], no backtrace";
LABEL_1687:
          _os_log_impl(&dword_214653000, v754, v755, v759, buf, 0x3Cu);
        }
      }
LABEL_1688:
      if (v753) {
        free(v753);
      }
      goto LABEL_1690;
    }
    uint64_t v332 = *(void *)(v3 + 24);
    uint64_t v333 = *(void *)(v332 + 32);
    info = 0;
    p_info = &info;
    unsigned int v334 = v306 + v321;
    if (!(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)(v333 + 24) + 88))(v333, v332))
    {
      if ((*(unsigned char *)(v923 + 828) & 2) == 0)
      {
        os_log_type_t v797 = __nwlog_tcp_log();
        v761 = (void *)(a1 + 632);
        if (os_log_type_enabled(v797, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 136446978;
          *(void *)&uint8_t buf[4] = "tcp_output";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v887;
          *(_WORD *)&unsigned char buf[22] = 1024;
          *(_DWORD *)v955 = v306 + v321;
          *(_WORD *)&v955[4] = 1024;
          *(_DWORD *)&v955[6] = v914;
          _os_log_impl(&dword_214653000, v797, OS_LOG_TYPE_INFO, "%{public}s %{public}s no output frames len %d, TSO %d", buf, 0x22u);
        }
        uint64_t v515 = 55;
LABEL_1617:
        LOBYTE(v896) = 1;
        v749 = (void *)*v761;
        if (*v761) {
          goto LABEL_1628;
        }
        goto LABEL_1692;
      }
LABEL_1895:
      uint64_t v515 = 55;
      v761 = (void *)(a1 + 632);
      goto LABEL_1617;
    }
    uint64_t v18 = (uint64_t)info;
    if (!*(void *)&info)
    {
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
      v798 = (void *)_os_log_send_and_compose_impl();
      v953 = OS_LOG_TYPE_ERROR;
      v952 = 0;
      if (!__nwlog_fault()) {
        goto LABEL_1798;
      }
      if (v953 != OS_LOG_TYPE_FAULT)
      {
        if (v952)
        {
          int v811 = (void *)__nw_create_backtrace_string();
          int v812 = __nwlog_obj();
          uint64_t v813 = v953;
          unsigned int v814 = os_log_type_enabled(v812, v953);
          if (v811)
          {
            if (v814)
            {
              *(_DWORD *)long long buf = 136446466;
              *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v811;
              _os_log_impl(&dword_214653000, v812, v813, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v811);
            goto LABEL_1798;
          }
          if (!v814) {
            goto LABEL_1798;
          }
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
          v801 = "%{public}s called with null frame, no backtrace";
          uint64_t v828 = v812;
          uint64_t v829 = v813;
        }
        else
        {
          v799 = __nwlog_obj();
          v800 = v953;
          if (!os_log_type_enabled(v799, v953)) {
            goto LABEL_1798;
          }
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
          v801 = "%{public}s called with null frame, backtrace limit exceeded";
LABEL_1796:
          uint64_t v828 = v799;
          uint64_t v829 = v800;
        }
        _os_log_impl(&dword_214653000, v828, v829, v801, buf, 0xCu);
        goto LABEL_1798;
      }
      v799 = __nwlog_obj();
      v800 = v953;
      if (os_log_type_enabled(v799, v953))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
        v801 = "%{public}s called with null frame";
        goto LABEL_1796;
      }
LABEL_1798:
      if (v798) {
        free(v798);
      }
      v760 = 0;
      v761 = (void *)(a1 + 632);
      if ((*(unsigned char *)(v923 + 828) & 2) != 0)
      {
LABEL_1614:
        if (v18)
        {
          v763 = *(void (**)(uint64_t, void, uint64_t))(v760 + 80);
          if (v763)
          {
            os_log_type_t v764 = *(void *)(v760 + 88);
            *(void *)(v760 + 80) = 0;
            *(void *)(v760 + 88) = 0;
            v763(v760, 0, v764);
            uint64_t v515 = 6;
            goto LABEL_1617;
          }
          __nwlog_obj();
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          uint64_t v842 = (void *)_os_log_send_and_compose_impl();
          v953 = OS_LOG_TYPE_ERROR;
          v952 = 0;
          if (!__nwlog_fault()) {
            goto LABEL_1872;
          }
          if (v953 == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v843 = __nwlog_obj();
            v844 = v953;
            if (os_log_type_enabled(v843, v953))
            {
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
              v845 = "%{public}s called with null frame->finalizer";
              goto LABEL_1870;
            }
LABEL_1872:
            if (v842) {
LABEL_1873:
            }
              free(v842);
LABEL_1874:
            uint64_t v515 = 6;
            v761 = (void *)(a1 + 632);
            goto LABEL_1617;
          }
          if (v952)
          {
            v850 = (void *)__nw_create_backtrace_string();
            v847 = __nwlog_obj();
            v848 = v953;
            v851 = os_log_type_enabled(v847, v953);
            if (v850)
            {
              if (v851)
              {
                *(_DWORD *)long long buf = 136446466;
                *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v850;
                _os_log_impl(&dword_214653000, v847, v848, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v850);
              if (v842) {
                goto LABEL_1873;
              }
              goto LABEL_1874;
            }
            if (!v851) {
              goto LABEL_1872;
            }
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            v845 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_1879:
            v854 = v847;
            unsigned int v855 = v848;
LABEL_1871:
            _os_log_impl(&dword_214653000, v854, v855, v845, buf, 0xCu);
            goto LABEL_1872;
          }
          os_log_type_t v843 = __nwlog_obj();
          v844 = v953;
          if (!os_log_type_enabled(v843, v953)) {
            goto LABEL_1872;
          }
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          v845 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
        }
        else
        {
          __nwlog_obj();
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          uint64_t v842 = (void *)_os_log_send_and_compose_impl();
          v953 = OS_LOG_TYPE_ERROR;
          v952 = 0;
          if (!__nwlog_fault()) {
            goto LABEL_1872;
          }
          if (v953 == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v843 = __nwlog_obj();
            v844 = v953;
            if (os_log_type_enabled(v843, v953))
            {
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
              v845 = "%{public}s called with null frame";
              goto LABEL_1870;
            }
            goto LABEL_1872;
          }
          if (v952)
          {
            v846 = (void *)__nw_create_backtrace_string();
            v847 = __nwlog_obj();
            v848 = v953;
            v849 = os_log_type_enabled(v847, v953);
            if (v846)
            {
              if (v849)
              {
                *(_DWORD *)long long buf = 136446466;
                *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v846;
                _os_log_impl(&dword_214653000, v847, v848, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v846);
              goto LABEL_1872;
            }
            if (!v849) {
              goto LABEL_1872;
            }
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            v845 = "%{public}s called with null frame, no backtrace";
            goto LABEL_1879;
          }
          os_log_type_t v843 = __nwlog_obj();
          v844 = v953;
          if (!os_log_type_enabled(v843, v953)) {
            goto LABEL_1872;
          }
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          v845 = "%{public}s called with null frame, backtrace limit exceeded";
        }
LABEL_1870:
        v854 = v843;
        unsigned int v855 = v844;
        goto LABEL_1871;
      }
LABEL_1612:
      v762 = __nwlog_tcp_log();
      if (os_log_type_enabled(v762, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "tcp_output";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v887;
        _os_log_impl(&dword_214653000, v762, OS_LOG_TYPE_INFO, "%{public}s %{public}s output buffer is no longer valid", buf, 0x16u);
      }
      goto LABEL_1614;
    }
    if ((*(_WORD *)(*(void *)&info + 204) & 0x80) != 0) {
      *(_WORD *)(*(void *)&info + 196) -= v321;
    }
    unsigned int v335 = *(_DWORD *)(v18 + 56) + v321;
    int v336 = *(_DWORD *)(v18 + 60);
    if (v335 <= *(_DWORD *)(v18 + 52) - v336)
    {
      *(_DWORD *)(v18 + 56) = v335;
    }
    else
    {
      int v337 = __nwlog_obj();
      if (os_log_type_enabled(v337, OS_LOG_TYPE_ERROR))
      {
        int v338 = *(_DWORD *)(v18 + 52);
        *(_DWORD *)long long buf = 136446978;
        *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v335;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v338;
        *(_WORD *)v955 = 1024;
        *(_DWORD *)&v955[2] = v336;
        _os_log_impl(&dword_214653000, v337, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
      }
    }
    uint64_t v339 = *(void *)(v18 + 112);
    if (!v339
      || (*(_WORD *)(v18 + 204) & 0x100) != 0
      && *MEMORY[0x263F144B8]
      && (!((unsigned int (*)(uint64_t, void))*MEMORY[0x263F144B8])(v18, *(void *)(v18 + 88))
       || (uint64_t v339 = *(void *)(v18 + 112)) == 0))
    {
      v760 = v18;
      v761 = (void *)(a1 + 632);
      if ((*(_WORD *)(v18 + 204) & 0x100) != 0)
      {
        v760 = v18;
        if (*MEMORY[0x263F144B8])
        {
          v760 = v18;
          if ((((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(v18, *(void *)(v18 + 88)) & 1) == 0)
          {
            *(void *)(a1 + 1056) = 0;
            v760 = v18;
          }
        }
      }
      if ((*(unsigned char *)(v923 + 828) & 2) != 0) {
        goto LABEL_1614;
      }
      goto LABEL_1612;
    }
    if (!nw_protocol_tcp_copy_frame_to_buffer(*(void *)(v923 + 400), v924, v306, (char *)(v339 + *(unsigned int *)(v18 + 56))))
    {
      if ((*(unsigned char *)(v923 + 828) & 2) == 0)
      {
        v802 = __nwlog_tcp_log();
        if (os_log_type_enabled(v802, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "tcp_output";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v887;
          _os_log_impl(&dword_214653000, v802, OS_LOG_TYPE_INFO, "%{public}s %{public}s copy from snd buffer to channel buffer failed", buf, 0x16u);
        }
      }
      v803 = *(void (**)(uint64_t, void, uint64_t))(v18 + 80);
      v761 = (void *)(a1 + 632);
      if (v803)
      {
        uint64_t v804 = *(void *)(v18 + 88);
        *(void *)(v18 + 80) = 0;
        *(void *)(v18 + 88) = 0;
        v803(v18, 0, v804);
        uint64_t v515 = 55;
        goto LABEL_1617;
      }
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
      v856 = (void *)_os_log_send_and_compose_impl();
      v953 = OS_LOG_TYPE_ERROR;
      v952 = 0;
      if (!__nwlog_fault()) {
        goto LABEL_1893;
      }
      if (v953 == OS_LOG_TYPE_FAULT)
      {
        v857 = __nwlog_obj();
        v858 = v953;
        if (os_log_type_enabled(v857, v953))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          v859 = "%{public}s called with null frame->finalizer";
          goto LABEL_1891;
        }
        goto LABEL_1893;
      }
      if (v952)
      {
        v860 = (void *)__nw_create_backtrace_string();
        v861 = __nwlog_obj();
        v862 = v953;
        v863 = os_log_type_enabled(v861, v953);
        if (v860)
        {
          if (v863)
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v860;
            _os_log_impl(&dword_214653000, v861, v862, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v860);
          goto LABEL_1893;
        }
        if (!v863)
        {
LABEL_1893:
          if (v856) {
            free(v856);
          }
          goto LABEL_1895;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        v859 = "%{public}s called with null frame->finalizer, no backtrace";
        v864 = v861;
        v865 = v862;
      }
      else
      {
        v857 = __nwlog_obj();
        v858 = v953;
        if (!os_log_type_enabled(v857, v953)) {
          goto LABEL_1893;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        v859 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
LABEL_1891:
        v864 = v857;
        v865 = v858;
      }
      _os_log_impl(&dword_214653000, v864, v865, v859, buf, 0xCu);
      goto LABEL_1893;
    }
    if ((*(_WORD *)(v18 + 204) & 0x80) != 0) {
      *(_WORD *)(v18 + 196) -= v306;
    }
    int v340 = *(_DWORD *)(v18 + 52);
    unsigned int v341 = *(_DWORD *)(v18 + 56) + v306;
    int v342 = *(_DWORD *)(v18 + 60);
    if (v341 <= v340 - v342)
    {
      *(_DWORD *)(v18 + 56) = v341;
    }
    else
    {
      uint64_t v343 = __nwlog_obj();
      BOOL v344 = os_log_type_enabled(v343, OS_LOG_TYPE_ERROR);
      int v340 = *(_DWORD *)(v18 + 52);
      if (v344)
      {
        *(_DWORD *)long long buf = 136446978;
        *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v341;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v340;
        *(_WORD *)v955 = 1024;
        *(_DWORD *)&v955[2] = v342;
        _os_log_impl(&dword_214653000, v343, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
        int v340 = *(_DWORD *)(v18 + 52);
      }
    }
    size_t v345 = (size_t)v918;
    if (v340)
    {
      uint64_t v347 = *(unsigned int *)(v18 + 56);
      size_t v346 = *(unsigned int *)(v18 + 60);
      uint64_t v348 = (v340 - (v346 + v347));
      if (v340 != v346 + v347)
      {
        if (v346)
        {
          uint64_t v349 = *(void *)(v18 + 112);
          if (v349)
          {
            memmove((void *)(v349 + v347), (const void *)(v349 + v347 + v348), v346);
            int v340 = *(_DWORD *)(v18 + 52);
          }
        }
        *(_DWORD *)(v18 + 52) = v340 - v348;
        if ((*(_WORD *)(v18 + 204) & 0x80) != 0)
        {
          unsigned int v350 = *(unsigned __int16 *)(v18 + 196);
          BOOL v351 = v350 >= v348;
          unsigned int v352 = v350 - v348;
          *(_WORD *)(v18 + 196) = v352;
          if (!v351 || v352 >= 0x10000)
          {
            __nwlog_obj();
            uint64_t v353 = *(unsigned __int16 *)(v18 + 196);
            *(_DWORD *)long long buf = 136446978;
            *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "frame->aggregate_buffer_length";
            *(_WORD *)&unsigned char buf[22] = 2048;
            *(void *)v955 = v348;
            *(_WORD *)&v955[8] = 2048;
            *(void *)&v955[10] = v353;
            uint64_t v354 = _os_log_send_and_compose_impl();
            v953 = OS_LOG_TYPE_ERROR;
            v952 = 0;
            v881 = (os_log_t)v354;
            if (!__nwlog_fault()) {
              goto LABEL_952;
            }
            if (v953 != OS_LOG_TYPE_FAULT)
            {
              if (v952)
              {
                int v383 = (void *)__nw_create_backtrace_string();
                v384 = __nwlog_obj();
                os_log_type_t v385 = v953;
                os_log_type_t log = v384;
                BOOL v386 = os_log_type_enabled(v384, v953);
                if (v383)
                {
                  if (v386)
                  {
                    uint64_t v387 = *(unsigned __int16 *)(v18 + 196);
                    *(_DWORD *)long long buf = 136447234;
                    *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = "frame->aggregate_buffer_length";
                    *(_WORD *)&unsigned char buf[22] = 2048;
                    *(void *)v955 = v348;
                    *(_WORD *)&v955[8] = 2048;
                    *(void *)&v955[10] = v387;
                    *(_WORD *)&v955[18] = 2082;
                    *(void *)&v955[20] = v383;
                    _os_log_impl(&dword_214653000, log, v385, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                  }
                  free(v383);
                  goto LABEL_952;
                }
                if (!v386) {
                  goto LABEL_952;
                }
                uint64_t v410 = *(unsigned __int16 *)(v18 + 196);
                *(_DWORD *)long long buf = 136446978;
                *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = "frame->aggregate_buffer_length";
                *(_WORD *)&unsigned char buf[22] = 2048;
                *(void *)v955 = v348;
                *(_WORD *)&v955[8] = 2048;
                *(void *)&v955[10] = v410;
                uint64_t v358 = log;
                os_log_type_t v359 = v385;
                BOOL v360 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              }
              else
              {
                v399 = __nwlog_obj();
                os_log_type_t v400 = v953;
                if (!os_log_type_enabled(v399, v953)) {
                  goto LABEL_952;
                }
                uint64_t v401 = *(unsigned __int16 *)(v18 + 196);
                *(_DWORD *)long long buf = 136446978;
                *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = "frame->aggregate_buffer_length";
                *(_WORD *)&unsigned char buf[22] = 2048;
                *(void *)v955 = v348;
                *(_WORD *)&v955[8] = 2048;
                *(void *)&v955[10] = v401;
                uint64_t v358 = v399;
                os_log_type_t v359 = v400;
                BOOL v360 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              }
LABEL_951:
              _os_log_impl(&dword_214653000, v358, v359, v360, buf, 0x2Au);
              goto LABEL_952;
            }
            int v355 = __nwlog_obj();
            os_log_type_t v356 = v953;
            if (os_log_type_enabled(v355, v953))
            {
              uint64_t v357 = *(unsigned __int16 *)(v18 + 196);
              *(_DWORD *)long long buf = 136446978;
              *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "frame->aggregate_buffer_length";
              *(_WORD *)&unsigned char buf[22] = 2048;
              *(void *)v955 = v348;
              *(_WORD *)&v955[8] = 2048;
              *(void *)&v955[10] = v357;
              uint64_t v358 = v355;
              os_log_type_t v359 = v356;
              BOOL v360 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
              goto LABEL_951;
            }
LABEL_952:
            if (v881) {
              free(v881);
            }
            *(_WORD *)(v18 + 196) = 0;
            size_t v345 = (size_t)v918;
          }
        }
      }
    }
    if ((*(_WORD *)(v18 + 204) & 0x80) != 0) {
      *(_WORD *)(v18 + 196) += v334;
    }
    unsigned int v411 = *(_DWORD *)(v18 + 56);
    BOOL v351 = v411 >= v334;
    unsigned int v412 = v411 - v334;
    if (v351)
    {
      *(_DWORD *)(v18 + 56) = v412;
    }
    else
    {
      unsigned int v413 = __nwlog_obj();
      if (os_log_type_enabled(v413, OS_LOG_TYPE_ERROR))
      {
        int v414 = *(_DWORD *)(v18 + 56);
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_frame_unclaim_internal";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v334;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v414;
        _os_log_impl(&dword_214653000, v413, OS_LOG_TYPE_ERROR, "%{public}s Frame cannot unclaim %u start bytes (has %u left)", buf, 0x18u);
      }
    }
    uint64_t v3 = v923;
    int v415 = v946;
    if (*(void *)(v923 + 24))
    {
      uint64_t v416 = nw_protocol_tcp_get_all_stats();
      if (v416) {
        ++*(void *)(v416 + 32);
      }
      if (*(void *)(v923 + 24))
      {
        uint64_t v417 = nw_protocol_tcp_get_all_stats();
        if (v417) {
          *(void *)(v417 + 40) += *(unsigned int *)(v18 + 52);
        }
      }
    }
    if ((v946 & 2) == 0 && v306 + v924 == *(_DWORD *)(v923 + 384)) {
      int v415 = v946 | 8;
    }
LABEL_1016:
    v946 = v415;
    uint64_t v438 = *(void *)(v18 + 112);
    if (!v438) {
      goto LABEL_1585;
    }
    LOBYTE(v439) = *(_WORD *)(v18 + 204);
    if ((*(_WORD *)(v18 + 204) & 0x100) == 0 || !*MEMORY[0x263F144B8])
    {
      uint64_t v441 = v438 + *(unsigned int *)(v18 + 56);
      if (v317) {
        goto LABEL_1025;
      }
LABEL_1022:
      if ((v439 & 0x40) == 0)
      {
        *(_DWORD *)(v18 + 192) = 0;
        goto LABEL_1044;
      }
      goto LABEL_1027;
    }
    if (!((unsigned int (*)(uint64_t, void))*MEMORY[0x263F144B8])(v18, *(void *)(v18 + 88))
      || (uint64_t v440 = *(void *)(v18 + 112)) == 0)
    {
LABEL_1585:
      if ((*(_WORD *)(v18 + 204) & 0x100) == 0) {
        goto LABEL_1620;
      }
      __int16 v25 = (void *)(a1 + 632);
      if (*MEMORY[0x263F144B8]
        && (((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(v18, *(void *)(v18 + 88)) & 1) == 0)
      {
        *(void *)(a1 + 1056) = 0;
      }
      goto LABEL_1621;
    }
    uint64_t v441 = v440 + *(unsigned int *)(v18 + 56);
    __int16 v439 = *(_WORD *)(v18 + 204);
    if (!v317) {
      goto LABEL_1022;
    }
LABEL_1025:
    if ((v439 & 0x40) == 0)
    {
      *(_DWORD *)(v18 + 192) = *(_DWORD *)(a1 + 1876);
      goto LABEL_1044;
    }
LABEL_1027:
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_frame_set_compression_generation_count";
    uint64_t v442 = (void *)_os_log_send_and_compose_impl();
    LOBYTE(info.numer) = 16;
    v953 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault()) {
      goto LABEL_1041;
    }
    if (LOBYTE(info.numer) == 17)
    {
      uint64_t v443 = __nwlog_obj();
      os_log_type_t v444 = info.numer;
      if (os_log_type_enabled(v443, info.numer))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_set_compression_generation_count";
        int v445 = v443;
        os_log_type_t v446 = v444;
        int v447 = "%{public}s Attempt to set generation-count on a chain-member";
        goto LABEL_1040;
      }
      goto LABEL_1041;
    }
    if (v953 == OS_LOG_TYPE_DEFAULT)
    {
      int v452 = __nwlog_obj();
      os_log_type_t v453 = info.numer;
      if (!os_log_type_enabled(v452, info.numer)) {
        goto LABEL_1041;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_set_compression_generation_count";
      int v445 = v452;
      os_log_type_t v446 = v453;
      int v447 = "%{public}s Attempt to set generation-count on a chain-member, backtrace limit exceeded";
LABEL_1040:
      _os_log_impl(&dword_214653000, v445, v446, v447, buf, 0xCu);
      goto LABEL_1041;
    }
    int v448 = (void *)__nw_create_backtrace_string();
    int v449 = __nwlog_obj();
    os_log_type_t v450 = info.numer;
    BOOL v451 = os_log_type_enabled(v449, info.numer);
    if (v448)
    {
      if (v451)
      {
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "__nw_frame_set_compression_generation_count";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v448;
        _os_log_impl(&dword_214653000, v449, v450, "%{public}s Attempt to set generation-count on a chain-member, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v448);
      goto LABEL_1041;
    }
    if (v451)
    {
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_set_compression_generation_count";
      int v445 = v449;
      os_log_type_t v446 = v450;
      int v447 = "%{public}s Attempt to set generation-count on a chain-member, no backtrace";
      goto LABEL_1040;
    }
LABEL_1041:
    if (v442) {
      free(v442);
    }
    size_t v345 = (size_t)v918;
LABEL_1044:
    uint64_t v454 = *(void *)(a1 + 80);
    if ((*(unsigned char *)(v454 + 2236) & 2) != 0) {
      __int16 v455 = in6_pseudo();
    }
    else {
      __int16 v455 = in_pseudo();
    }
    *(_WORD *)(v441 + 16) = v455;
    HIDWORD(v456) = *(_DWORD *)(v454 + 2224);
    LODWORD(v456) = HIDWORD(v456);
    *(_DWORD *)(v441 + 4) = 0;
    *(_DWORD *)(v441 + 8) = 0;
    *(_DWORD *)uint64_t v441 = v456 >> 16;
    *(unsigned char *)(v441 + 12) = 80;
    *(unsigned char *)(v441 + 13) = 0;
    *(_WORD *)(v441 + 14) = 0;
    *(_WORD *)(v441 + 18) = 0;
    int v457 = *(_DWORD *)(a1 + 740);
    int v458 = v911;
    if ((v457 & 0x10000000) == 0
      && ((v457 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 336) == 1 || tcp_do_l4s == 1)
      && ((v457 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1))
    {
      int v459 = *(_DWORD *)(a1 + 348);
      if ((~v459 & 0x300000) == 0)
      {
        __int16 v460 = v946;
        if ((v459 & 4) == 0 || (v946 & 2) != 0) {
          goto LABEL_1075;
        }
        *(unsigned char *)(v18 + 186) = *(unsigned char *)(v18 + 186) & 0xFC | 1;
        info = 0;
        int v461 = mach_timebase_info(&info);
        if (v461)
        {
          int v462 = v461;
          int v463 = __nwlog_obj();
          if (os_log_type_enabled(v463, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "microuptime_ns";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v462;
            _os_log_impl(&dword_214653000, v463, OS_LOG_TYPE_ERROR, "%{public}s mach_timebase_info returned %u", buf, 0x12u);
          }
          __int16 v460 = v946;
          int v458 = v911;
          size_t v345 = (size_t)v918;
          goto LABEL_1075;
        }
        v569 = mach_absolute_time() * info.numer;
        v570 = v569 / info.denom;
        if ((_WORD)v306)
        {
          __int16 v460 = v946;
          int v458 = v911;
          if (v569 < info.denom)
          {
            v600 = v569 / info.denom;
          }
          else
          {
            BOOL v571 = *(void *)(a1 + 496);
            if (!v571)
            {
              *(void *)(a1 + 496) = v570;
              *(_DWORD *)(a1 + 492) = (unsigned __int16)v306;
              *(void *)(v18 + 160) = v570;
              goto LABEL_1075;
            }
            int v572 = *(_DWORD *)(a1 + 492) + (unsigned __int16)v306;
            *(_DWORD *)(a1 + 492) = v572;
            if (v572 <= *(_DWORD *)(a1 + 488))
            {
              *(void *)(v18 + 160) = v571;
              goto LABEL_1075;
            }
            BOOL v573 = *(void *)(a1 + 480);
            if (v573)
            {
              v574 = 1000000000 * (unint64_t)v572 / v573;
              if (v574 >= 0x989680) {
                v574 = 10000000;
              }
              goto LABEL_1465;
            }
            __nwlog_obj();
            v607 = tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)];
            unsigned int v608 = *(_DWORD *)(a1 + 144);
            int v609 = *(int *)(a1 + 200) >> 5;
            *(_DWORD *)long long buf = 136446978;
            *(void *)&uint8_t buf[4] = "tcp_pacer_get_packet_interval";
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = v607;
            *(_WORD *)&unsigned char buf[22] = 1024;
            *(_DWORD *)v955 = v608;
            *(_WORD *)&v955[4] = 1024;
            *(_DWORD *)&v955[6] = v609;
            unsigned __int16 v610 = (void *)_os_log_send_and_compose_impl();
            LOBYTE(info.numer) = 16;
            v953 = OS_LOG_TYPE_DEFAULT;
            if (!__nwlog_fault()) {
              goto LABEL_1462;
            }
            if (LOBYTE(info.numer) == 17)
            {
              char v611 = __nwlog_obj();
              v612 = info.numer;
              if (os_log_type_enabled(v611, info.numer))
              {
                v613 = tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)];
                uint64_t v614 = *(_DWORD *)(a1 + 144);
                uint64_t v615 = *(int *)(a1 + 200) >> 5;
                *(_DWORD *)long long buf = 136446978;
                *(void *)&uint8_t buf[4] = "tcp_pacer_get_packet_interval";
                *(_WORD *)&buf[12] = 2080;
                *(void *)&buf[14] = v613;
                *(_WORD *)&unsigned char buf[22] = 1024;
                *(_DWORD *)v955 = v614;
                *(_WORD *)&v955[4] = 1024;
                *(_DWORD *)&v955[6] = v615;
                v616 = v611;
                os_log_type_t v617 = v612;
                v618 = "%{public}s pacer rate shouldn't be 0, CCA is %s (cwnd=%u, smoothed rtt=%u ms)";
                goto LABEL_1461;
              }
              goto LABEL_1462;
            }
            if (v953 == OS_LOG_TYPE_DEFAULT)
            {
              uint64_t v671 = __nwlog_obj();
              unsigned int v672 = info.numer;
              if (!os_log_type_enabled(v671, info.numer)) {
                goto LABEL_1462;
              }
              int v673 = tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)];
              int v674 = *(_DWORD *)(a1 + 144);
              int v675 = *(int *)(a1 + 200) >> 5;
              *(_DWORD *)long long buf = 136446978;
              *(void *)&uint8_t buf[4] = "tcp_pacer_get_packet_interval";
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = v673;
              *(_WORD *)&unsigned char buf[22] = 1024;
              *(_DWORD *)v955 = v674;
              *(_WORD *)&v955[4] = 1024;
              *(_DWORD *)&v955[6] = v675;
              v616 = v671;
              os_log_type_t v617 = v672;
              v618 = "%{public}s pacer rate shouldn't be 0, CCA is %s (cwnd=%u, smoothed rtt=%u ms), backtrace limit exceeded";
LABEL_1461:
              _os_log_impl(&dword_214653000, v616, v617, v618, buf, 0x22u);
              goto LABEL_1462;
            }
            BOOL v639 = (void *)__nw_create_backtrace_string();
            int v640 = __nwlog_obj();
            uint64_t v641 = info.numer;
            v928 = v640;
            v642 = os_log_type_enabled(v640, info.numer);
            if (v639)
            {
              if (v642)
              {
                v643 = tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)];
                BOOL v644 = *(_DWORD *)(a1 + 144);
                int v645 = *(int *)(a1 + 200) >> 5;
                *(_DWORD *)long long buf = 136447234;
                *(void *)&uint8_t buf[4] = "tcp_pacer_get_packet_interval";
                *(_WORD *)&buf[12] = 2080;
                *(void *)&buf[14] = v643;
                *(_WORD *)&unsigned char buf[22] = 1024;
                *(_DWORD *)v955 = v644;
                *(_WORD *)&v955[4] = 1024;
                *(_DWORD *)&v955[6] = v645;
                *(_WORD *)&v955[10] = 2082;
                *(void *)&v955[12] = v639;
                _os_log_impl(&dword_214653000, v928, v641, "%{public}s pacer rate shouldn't be 0, CCA is %s (cwnd=%u, smoothed rtt=%u ms), dumping backtrace:%{public}s", buf, 0x2Cu);
              }
              free(v639);
              goto LABEL_1462;
            }
            if (v642)
            {
              int v680 = tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)];
              v681 = *(_DWORD *)(a1 + 144);
              int v682 = *(int *)(a1 + 200) >> 5;
              *(_DWORD *)long long buf = 136446978;
              *(void *)&uint8_t buf[4] = "tcp_pacer_get_packet_interval";
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = v680;
              *(_WORD *)&unsigned char buf[22] = 1024;
              *(_DWORD *)v955 = v681;
              *(_WORD *)&v955[4] = 1024;
              *(_DWORD *)&v955[6] = v682;
              v616 = v928;
              os_log_type_t v617 = v641;
              v618 = "%{public}s pacer rate shouldn't be 0, CCA is %s (cwnd=%u, smoothed rtt=%u ms), no backtrace";
              goto LABEL_1461;
            }
LABEL_1462:
            if (v610) {
              free(v610);
            }
            BOOL v571 = *(void *)(a1 + 496);
            v574 = 10000000;
            __int16 v460 = v946;
            int v458 = v911;
            size_t v345 = (size_t)v918;
LABEL_1465:
            v600 = v571 + v574;
            *(void *)(a1 + 496) = v600;
            *(_DWORD *)(a1 + 492) = 0;
            if (v570 > v600)
            {
              *(void *)(a1 + 496) = v570;
              goto LABEL_1468;
            }
          }
        }
        else
        {
          v600 = v569 / info.denom;
          __int16 v460 = v946;
          int v458 = v911;
        }
        v570 = v600;
        if (!v600) {
          goto LABEL_1075;
        }
LABEL_1468:
        *(void *)(v18 + 160) = v570;
        goto LABEL_1075;
      }
    }
    int v464 = (*(unsigned __int8 *)(a1 + 348) >> 2) & 1;
    if (!v306) {
      int v464 = 0;
    }
    __int16 v460 = v946;
    if (!v907)
    {
      if (!v464) {
        goto LABEL_1075;
      }
      unsigned int v465 = v935;
      if (*(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 96) < 0) {
        unsigned int v465 = 1;
      }
      if ((v465 & 1) != 0 || (v946 & 2) != 0) {
        goto LABEL_1075;
      }
LABEL_1074:
      *(unsigned char *)(v18 + 186) = *(unsigned char *)(v18 + 186) & 0xFC | 2;
      goto LABEL_1075;
    }
    if (v464)
    {
      unsigned int v466 = v935;
      if (*(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 96) < 0) {
        unsigned int v466 = 1;
      }
      if ((v466 & 1) == 0) {
        goto LABEL_1074;
      }
    }
LABEL_1075:
    unint64_t v124 = a1 + 100;
    if ((v460 & 1) != 0 && (*(unsigned char *)(a1 + 88) & 0x10) != 0)
    {
      unsigned int v467 = *(_DWORD *)(a1 + 100);
      if (v467 == *(_DWORD *)(a1 + 96)) {
        *os_log_type_t type = v467 - 1;
      }
    }
    if (!v458)
    {
      BOOL v469 = v306 - 1;
      if ((*(_DWORD *)(a1 + 740) & 0x20400020) == 0x20000020)
      {
        int v470 = *(_DWORD *)v55;
        *(_DWORD *)(v441 + 4) = bswap32(*(_DWORD *)v55);
        tcp_rxtseg_insert((void *)a1, v470, v469 + v470);
      }
      else
      {
        int v472 = *v898;
        *(_DWORD *)(v441 + 4) = bswap32(*v898);
        tcp_rxtseg_insert((void *)a1, v472, v469 + v472);
        *v898 += v306;
        size_t v345 = (size_t)v918;
        *(_DWORD *)(a1 + 624) += v306;
      }
      goto LABEL_1090;
    }
    if (v306 | v460 & 3)
    {
      int v468 = *(_DWORD *)(a1 + 96);
      goto LABEL_1085;
    }
    int v468 = *(_DWORD *)(a1 + 96);
    if (*(_DWORD *)(a1 + 36))
    {
LABEL_1085:
      int v471 = *type;
      *(_DWORD *)(v441 + 4) = bswap32(*type);
      if ((int)(v471 - v468) < 0)
      {
        if (v306 > 1 && (*(_DWORD *)(a1 + 740) & 0x1020) == 0x20)
        {
          tcp_rxtseg_insert((void *)a1, v471, v306 + v471 - 1);
          goto LABEL_1091;
        }
LABEL_1090:
        if (v306 >= 1) {
LABEL_1091:
        }
          *(unsigned char *)(v18 + 186) |= 4u;
      }
    }
    else
    {
      *(_DWORD *)(v441 + 4) = bswap32(v468);
    }
    int v473 = *(_DWORD *)(a1 + 120);
    *(_DWORD *)(v441 + 8) = bswap32(v473);
    *(_DWORD *)(a1 + 284) = v473;
    if (v345)
    {
      memmove((void *)(v441 + 20), __src, v345);
      int v474 = ((4 * v903) & 0xF0) + 80;
    }
    else
    {
      int v474 = *(unsigned char *)(v441 + 12);
    }
    *(unsigned char *)(v441 + 13) = v460;
    *(unsigned char *)(v441 + 12) = v474 & 0xF0 | HIBYTE(v460) & 1;
    BOOL v475 = v909 >> *(unsigned char *)(a1 + 261);
    *(_WORD *)(v441 + 14) = bswap32(v475) >> 16;
    *(_DWORD *)(a1 + 132) = v909;
    if (v909 >= 1)
    {
      v476 = *(_DWORD *)(a1 + 120) + v909;
      if (*(_DWORD *)(a1 + 124) - v476 < 0) {
        *(_DWORD *)(a1 + 124) = v476;
      }
    }
    *(_DWORD *)(a1 + 88) = *(_DWORD *)(a1 + 88) & 0xFFFBFFFF | (((unsigned __int16)v475 == 0) << 18);
    uint64_t v477 = *(_DWORD *)(a1 + 12);
    if ((v477 - 7) < 2 || v477 != 4 && (v477 == 10 || (v460 & 4) != 0)) {
      *(unsigned char *)(v18 + 186) |= 8u;
    }
    char v478 = *((void *)v940 + 62);
    if (v306 + v345) {
      *(_WORD *)(v441 + 16) = in_addword();
    }
    if (!v478) {
      goto LABEL_1275;
    }
    int v479 = *(void *)(v478 + 216);
    if (!v479) {
      goto LABEL_1275;
    }
    uint64_t v480 = *(_DWORD *)(v479 + 1048);
    if ((v480 & 0x1000) != 0)
    {
      if ((*(_WORD *)(v18 + 204) & 0x100) == 0) {
        goto LABEL_1121;
      }
      int v482 = (uint64_t (*)(uint64_t, uint64_t, void, void))*MEMORY[0x263F144C0];
      if (!*MEMORY[0x263F144C0]) {
        goto LABEL_1121;
      }
      *(unsigned char *)(v18 + 203) |= 1u;
      int v483 = 1;
      int v484 = v482(v18, 1, v889, v888);
      if (v484)
      {
        uint64_t v485 = v484;
        if (v484 != 45 && (*(unsigned char *)(v923 + 828) & 2) == 0)
        {
          char v486 = __nwlog_tcp_log();
          if (os_log_type_enabled(v486, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "tcp_output";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v887;
            *(_WORD *)&unsigned char buf[22] = 1024;
            *(_DWORD *)v955 = v485;
            _os_log_impl(&dword_214653000, v486, OS_LOG_TYPE_ERROR, "%{public}s %{public}s set internet checksum offload failed (err %d)", buf, 0x1Cu);
          }
        }
        goto LABEL_1121;
      }
LABEL_1122:
      LOWORD(v487) = v914;
      if (!v914) {
        goto LABEL_1124;
      }
LABEL_1123:
      char v487 = *(_DWORD *)(a1 + 156) - v918;
      goto LABEL_1124;
    }
    if (!v907)
    {
      if ((((v480 & 2) == 0) & ~v914) == 0 && (*(_WORD *)(v18 + 204) & 0x100) != 0)
      {
        v481 = *(unsigned char *)(v18 + 203) | 8;
        goto LABEL_1274;
      }
LABEL_1121:
      int v483 = 0;
      goto LABEL_1122;
    }
    if ((((v480 & 0x20) == 0) & ~v914) != 0 || (*(_WORD *)(v18 + 204) & 0x100) == 0) {
      goto LABEL_1121;
    }
    v481 = *(unsigned char *)(v18 + 203) | 0x20;
LABEL_1274:
    *(unsigned char *)(v18 + 203) = v481;
LABEL_1275:
    int v483 = 1;
    LOWORD(v487) = v914;
    if (v914) {
      goto LABEL_1123;
    }
LABEL_1124:
    v488 = *(unsigned __int16 *)(v18 + 204);
    *(_WORD *)(v18 + 198) = v487;
    char v489 = (v488 | (*(unsigned __int8 *)(v18 + 206) << 16)) & 0xFFFDFFFF | (v907 << 16);
    *(_WORD *)(v18 + 204) = v488;
    *(unsigned char *)(v18 + 206) = BYTE2(v489);
    if ((*(unsigned char *)(a1 + 741) & 0x80) != 0 && *(_DWORD *)(a1 + 36))
    {
      uint64_t v490 = ((v946 >> 1) & 1) + v306;
      if (v946)
      {
        unsigned int v491 = *(_DWORD *)(a1 + 88);
        if ((v491 & 0x10) == 0)
        {
          ++v490;
          *(_DWORD *)(a1 + 88) = v491 | 0x10;
        }
      }
      int v492 = *(_DWORD *)(a1 + 100);
      if (v492 + v490 - *(_DWORD *)(a1 + 96) >= 1)
      {
        *(_DWORD *)(a1 + 96) = v492 + v306;
        *(_DWORD *)(a1 + 164) = *v910;
        if (*(void *)(v923 + 24))
        {
          v493 = nw_protocol_tcp_get_all_stats();
          if (v493) {
            *(_DWORD *)(v493 + 108) = *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92);
          }
        }
      }
      goto LABEL_1184;
    }
    v494 = *type;
    os_log_type_t v495 = *type;
    if ((v946 & 3) != 0)
    {
      os_log_type_t v495 = *type;
      if ((v946 & 2) != 0)
      {
        os_log_type_t v495 = v494 + 1;
        *os_log_type_t type = v494 + 1;
      }
      if (v946)
      {
        int v496 = *(_DWORD *)(a1 + 88);
        if ((v496 & 0x10) == 0)
        {
          *(_DWORD *)(a1 + 100) = ++v495;
          *(_DWORD *)(a1 + 88) = v496 | 0x10;
        }
      }
    }
    if ((v935 & 1) == 0)
    {
      if (v897 == 1)
      {
        v497 = v891;
        *(_DWORD *)(a1 + 100) = v891;
        int v498 = *(void *)(a1 + 1056);
        if (v498)
        {
          ++*(void *)(v498 + 760);
          v497 = v891;
        }
      }
      else
      {
        v497 = v495 + v306;
        *os_log_type_t type = v497;
      }
      if ((int)(v497 - *(_DWORD *)(a1 + 96)) < 1) {
        goto LABEL_1927;
      }
      *(_DWORD *)(a1 + 96) = v497;
      *(_DWORD *)(a1 + 164) = *v910;
      if (*(void *)(v923 + 24))
      {
        v499 = nw_protocol_tcp_get_all_stats();
        if (v499) {
          *(_DWORD *)(v499 + 108) = *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92);
        }
      }
      if (*(_DWORD *)(a1 + 172))
      {
LABEL_1927:
        if (*(_DWORD *)(a1 + 28))
        {
LABEL_1154:
          v897 = 0;
          goto LABEL_1164;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 172) = *v910;
        *(_DWORD *)(a1 + 176) = v494;
        os_log_type_t v500 = *(void *)(a1 + 1056);
        if (v500) {
          ++*(void *)(v500 + 472);
        }
        *(_DWORD *)(a1 + 976) = *(_DWORD *)(a1 + 92);
        if (*(_DWORD *)(a1 + 28)) {
          goto LABEL_1154;
        }
      }
      v897 = 0;
      os_log_type_t v495 = *type;
      if (v946) {
        goto LABEL_1161;
      }
      goto LABEL_1160;
    }
    if (!*(_DWORD *)(a1 + 28))
    {
      if (v495 != *(_DWORD *)(a1 + 96) || (v946 & 1) != 0)
      {
LABEL_1161:
        if (*(_DWORD *)(a1 + 36))
        {
          *(_DWORD *)(a1 + 36) = 0;
          *(_DWORD *)(a1 + 316) = 0;
          *(_WORD *)(a1 + 226) = 0;
          *(_DWORD *)(a1 + 248) = 0;
        }
        *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 192)
                             + *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 316)
                             - *(_DWORD *)(a1 + 64);
        goto LABEL_1164;
      }
LABEL_1160:
      if (v495 != *(_DWORD *)(a1 + 92)) {
        goto LABEL_1161;
      }
    }
LABEL_1164:
    if (v306)
    {
      if (*(_DWORD *)(sysctls + 132))
      {
        if (*(_DWORD *)(a1 + 12) == 4)
        {
          uint64_t v501 = *(_DWORD *)(a1 + 740);
          if ((v501 & 0x20) != 0 && (*(unsigned char *)(a1 + 90) & 0x20) == 0)
          {
            unsigned int v502 = *(_DWORD *)(a1 + 100);
            if (v502 == *(_DWORD *)(a1 + 96))
            {
              int v503 = v502 - *(_DWORD *)(a1 + 92);
              if (v503 >= 1 && (v501 & 0x3000) == 0 && !*(_WORD *)(a1 + 226))
              {
                unsigned int v504 = *(void *)(a1 + 80);
                int v505 = *(_DWORD *)(a1 + 200);
                if (v505 > 0x1F
                  || (unsigned int v506 = *(void *)(v504 + 448)) != 0
                  && *(unsigned __int8 *)(v506 + 1076) != 255
                  && *(_DWORD *)(v506 + 1024) != 255)
                {
                  unsigned int v507 = v505 >> 5;
                  if (v503 <= *(_DWORD *)(a1 + 196)) {
                    int v508 = 100;
                  }
                  else {
                    int v508 = 2;
                  }
                  v509 = v508 + 2 * v507;
                  if (*(_DWORD *)(a1 + 192) >= v509) {
                    int v510 = v509;
                  }
                  else {
                    int v510 = *(_DWORD *)(a1 + 192);
                  }
                  *(_DWORD *)(a1 + 16) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(v504 + 224)) + 316)
                                       + v510
                                       - *(_DWORD *)(a1 + 64);
                }
              }
            }
          }
        }
      }
    }
LABEL_1184:
    v511 = *((void *)v940 + 56);
    if (!v511 || (*(_WORD *)(v511 + 1074) & 8) != 0)
    {
      int v514 = v899;
      if (v899 > 499)
      {
        if (v899 <= 699)
        {
          if (v899 == 500)
          {
            int v514 = 2621728;
            goto LABEL_1195;
          }
          if (v899 == 600)
          {
            int v514 = 3146000;
            goto LABEL_1195;
          }
        }
        else
        {
          switch(v899)
          {
            case 700:
              int v514 = 3670272;
              goto LABEL_1195;
            case 800:
              int v514 = 4194688;
              goto LABEL_1195;
            case 900:
              int v514 = 4718992;
              goto LABEL_1195;
          }
        }
      }
      else if (v899 <= 199)
      {
        if (!v899) {
          goto LABEL_1195;
        }
        if (v899 == 100)
        {
          int v514 = 524432;
          goto LABEL_1195;
        }
      }
      else
      {
        switch(v899)
        {
          case 200:
            int v514 = 1048704;
            goto LABEL_1195;
          case 300:
            int v514 = 1572880;
            goto LABEL_1195;
          case 400:
            int v514 = 2097184;
            goto LABEL_1195;
        }
      }
      int v514 = 0;
    }
    else
    {
      if (!v306 && (*(_DWORD *)(v511 + 1052) & 0x200080) == 0x80)
      {
        v512 = *(unsigned __int8 *)(v441 + 13);
        if (v512 == 16 && *(_DWORD *)(a1 + 92) == *(_DWORD *)(a1 + 96))
        {
          int v513 = v895;
          if (!*(_DWORD *)(a1 + 28)) {
            int v513 = v895 | 2;
          }
          __int16 v895 = v513;
        }
        v895 |= (2 * v512) & 4;
      }
      *(_DWORD *)long long buf = 0;
      set_frame_service_class(v18, v923, v899, v895, (int *)buf);
      int v514 = *(_DWORD *)buf;
    }
LABEL_1195:
    *(_DWORD *)(v18 + 176) = v514;
    *(_DWORD *)(a1 + 648) += v306;
    ++*(_DWORD *)(a1 + 300);
    if (v483) {
      goto LABEL_1204;
    }
    uint64_t v515 = in_finalize_cksum();
    if (v515
      && (*(_WORD *)(v18 + 204) & 0x100) != 0
      && *MEMORY[0x263F144B8]
      && (((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(v18, *(void *)(v18 + 88)) & 1) == 0)
    {
      goto LABEL_1899;
    }
    uint64_t v516 = *(_DWORD *)(v18 + 52);
    if (v516)
    {
      v517 = (v516 - (*(_DWORD *)(v18 + 56) + *(_DWORD *)(v18 + 60)));
      v518 = *(void *)(a1 + 1056);
      if (v518) {
        goto LABEL_1202;
      }
    }
    else
    {
      v517 = 0;
      v518 = *(void *)(a1 + 1056);
      if (v518)
      {
LABEL_1202:
        ++*(void *)(v518 + v893);
        *(void *)(v518 + v892) += v517;
      }
    }
    if (v515) {
      goto LABEL_1900;
    }
LABEL_1204:
    if ((*(unsigned char *)(v441 + 13) & 0x24) != 0)
    {
      if ((*(unsigned char *)(v923 + 828) & 2) == 0)
      {
        uint64_t v621 = __nwlog_tcp_log();
        if (os_log_type_enabled(v621, OS_LOG_TYPE_ERROR))
        {
          v622 = *(unsigned __int8 *)(v441 + 13);
          uint64_t v623 = bswap32(*(_DWORD *)(v441 + 4));
          uint64_t v624 = bswap32(*(_DWORD *)(v441 + 8));
          uint64_t v625 = bswap32(*(unsigned __int16 *)(v441 + 14));
          int v626 = *(_DWORD *)(a1 + 12);
          uint64_t v627 = *(_DWORD *)(a1 + 120);
          v628 = *(_DWORD *)(a1 + 92);
          *(_DWORD *)long long buf = 136448258;
          *(void *)&uint8_t buf[4] = "tcp_output";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v887;
          *(_WORD *)&unsigned char buf[22] = 1024;
          *(_DWORD *)v955 = v622;
          *(_WORD *)&v955[4] = 1024;
          *(_DWORD *)&v955[6] = v623;
          *(_WORD *)&v955[10] = 1024;
          *(_DWORD *)&v955[12] = v624;
          *(_WORD *)&v955[16] = 1024;
          *(_DWORD *)&v955[18] = HIWORD(v625);
          *(_WORD *)&v955[22] = 1024;
          *(_DWORD *)&v955[24] = v626;
          LOWORD(v956) = 1024;
          *(_DWORD *)((char *)&v956 + 2) = v627;
          HIWORD(v956) = 1024;
          v957[0] = v628;
          int v629 = v621;
          v630 = OS_LOG_TYPE_ERROR;
          goto LABEL_1417;
        }
      }
    }
    else if ((*(unsigned char *)(v441 + 13) & 3) != 0 && (*(unsigned char *)(v923 + 828) & 2) == 0)
    {
      v631 = __nwlog_tcp_log();
      if (os_log_type_enabled(v631, OS_LOG_TYPE_DEFAULT))
      {
        int v632 = *(unsigned __int8 *)(v441 + 13);
        v633 = bswap32(*(_DWORD *)(v441 + 4));
        v634 = bswap32(*(_DWORD *)(v441 + 8));
        v635 = bswap32(*(unsigned __int16 *)(v441 + 14));
        int v636 = *(_DWORD *)(a1 + 12);
        int v637 = *(_DWORD *)(a1 + 120);
        BOOL v638 = *(_DWORD *)(a1 + 92);
        *(_DWORD *)long long buf = 136448258;
        *(void *)&uint8_t buf[4] = "tcp_output";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v887;
        *(_WORD *)&unsigned char buf[22] = 1024;
        *(_DWORD *)v955 = v632;
        *(_WORD *)&v955[4] = 1024;
        *(_DWORD *)&v955[6] = v633;
        *(_WORD *)&v955[10] = 1024;
        *(_DWORD *)&v955[12] = v634;
        *(_WORD *)&v955[16] = 1024;
        *(_DWORD *)&v955[18] = HIWORD(v635);
        *(_WORD *)&v955[22] = 1024;
        *(_DWORD *)&v955[24] = v636;
        LOWORD(v956) = 1024;
        *(_DWORD *)((char *)&v956 + 2) = v637;
        HIWORD(v956) = 1024;
        v957[0] = v638;
        int v629 = v631;
        v630 = OS_LOG_TYPE_DEFAULT;
LABEL_1417:
        _os_log_impl(&dword_214653000, v629, v630, "%{public}s %{public}s flags=%{network:tcp_flags}x seq=%u, ack=%u, win=%u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u", buf, 0x40u);
      }
    }
    tcp_log_packet(a1);
    *(void *)(v18 + 32) = 0;
    uint64_t v519 = *(uint64_t **)(a1 + 640);
    *(void *)(v18 + 40) = v519;
    *uint64_t v519 = v18;
    *(void *)(a1 + 640) = v18 + 32;
    uint64_t v520 = *(_DWORD *)(a1 + 740);
    v521 = v912;
    if ((~v520 & 0x20000020) != 0 || !v306 || (v520 & 0x400000) != 0) {
      goto LABEL_1364;
    }
    os_log_type_t v522 = *(unsigned __int8 *)(v18 + 186);
    if ((v520 & 0x1000) != 0) {
      v523 = (2 * v522) & 8;
    }
    else {
      v523 = (v522 << 29 >> 31) & 0xC;
    }
    BOOL v524 = bswap32(*(_DWORD *)(v441 + 4));
    char v525 = v524 + v306;
    uint64_t v526 = *v910;
    if (!v55)
    {
      if (v523 > 7)
      {
        int v542 = *v894;
        if (!*v894) {
          goto LABEL_1364;
        }
        unsigned int v543 = *v894;
        do
        {
          while (1)
          {
            unsigned int v544 = *(_DWORD *)(v543 + 4);
            if ((int)(v525 - v544) >= 0) {
              break;
            }
            unsigned int v543 = *(void *)(v543 + 32);
            if (!v543) {
              goto LABEL_1257;
            }
          }
          if (v525 == v544)
          {
            tcp_process_rxmt_segs_after_rto(a1, (int *)v543, v524, *v910, v523);
            goto LABEL_1346;
          }
          unsigned int v543 = *(void *)(v543 + 40);
        }
        while (v543);
        do
        {
LABEL_1257:
          int v545 = v542;
          int v542 = *(void *)(v542 + 32);
        }
        while (v542);
        do
        {
          while (1)
          {
LABEL_1266:
            int v547 = v545;
            if ((int)(v525 - *(_DWORD *)(v545 + 4)) < 0 && (int)(v525 - *(_DWORD *)v545) >= 1)
            {
              tcp_seg_rto_insert_end(a1, *(_DWORD *)v545, v524 + v306, *v910, *(unsigned char *)(v545 + 12) | v523);
              v521 = v912;
              uint64_t v548 = *(_DWORD *)v547;
              if ((int)(*(_DWORD *)v547 - v524) >= 1)
              {
                int v549 = *v894;
                if (*v894)
                {
                  while (1)
                  {
                    while (1)
                    {
                      unsigned int v596 = *(_DWORD *)(v549 + 4);
                      if (v548 - v596 >= 0) {
                        break;
                      }
                      int v549 = *(void *)(v549 + 32);
                      if (!v549) {
                        goto LABEL_1433;
                      }
                    }
                    if (v548 == v596) {
                      break;
                    }
                    int v549 = *(void *)(v549 + 40);
                    if (!v549) {
                      goto LABEL_1433;
                    }
                  }
                  tcp_process_rxmt_segs_after_rto(a1, (int *)v549, v524, v526, v523);
                  v521 = v912;
                }
              }
LABEL_1433:
              *(_DWORD *)int v547 = v525;
              int v587 = v913;
              if (v913) {
                goto LABEL_1365;
              }
              goto LABEL_1434;
            }
            int v546 = *(void *)(v545 + 40);
            if (!v546) {
              break;
            }
            do
            {
              int v545 = v546;
              int v546 = *(void *)(v546 + 32);
            }
            while (v546);
          }
          int v545 = *(void *)(v545 + 48) & 0xFFFFFFFFFFFFFFFELL;
        }
        while (v545 && *(void *)(v545 + 32) == v547);
        while (1)
        {
          int v545 = *(void *)(v547 + 48) & 0xFFFFFFFFFFFFFFFELL;
          if (!v545) {
            break;
          }
          BOOL v59 = v547 == *(void *)(v545 + 40);
          int v547 = *(void *)(v547 + 48) & 0xFFFFFFFFFFFFFFFELL;
          if (!v59) {
            goto LABEL_1266;
          }
        }
LABEL_1364:
        int v587 = v913;
        if (v913)
        {
LABEL_1365:
          if (*(_DWORD *)(a1 + 12) == 4
            && *(_DWORD *)(a1 + 144) > *(_DWORD *)(a1 + 140) >> 3
            && (*(unsigned char *)(a1 + 88) & 1) == 0
            && (*(unsigned char *)(a1 + 741) & 0x80) == 0
            && *(_DWORD *)(a1 + 300) < *(_DWORD *)(sysctls + 100))
          {
            unsigned int v595 = *(void **)(a1 + 1056);
            __int16 v25 = (void *)(a1 + 632);
            uint64_t v3 = v923;
            uint64_t v2 = v940;
            if (v595) {
              ++*v595;
            }
            continue;
          }
        }
        goto LABEL_1434;
      }
      int v536 = *(void *)(a1 + 2024);
      if (v536)
      {
        int v537 = *(void *)(v536 + 72);
        uint64_t v538 = *(void **)(v536 + 80);
        if (v537)
        {
          *(void *)(v537 + 80) = v538;
          uint64_t v538 = *(void **)(v536 + 80);
        }
        else
        {
          *(void *)(a1 + 2032) = v538;
        }
        *uint64_t v538 = v537;
        --*(_DWORD *)(a1 + 2040);
      }
      else
      {
        uint64_t v562 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
        uint64_t v563 = malloc_type_malloc(**(void **)(v562 + 64), 0xB9BAFBABuLL);
        v521 = v912;
        int v536 = (unint64_t)v563;
        if (!v563) {
          goto LABEL_1364;
        }
      }
      *(_OWORD *)(v536 + 72) = 0u;
      *(_OWORD *)(v536 + 60) = 0u;
      *(_OWORD *)(v536 + 44) = 0u;
      *(_OWORD *)(v536 + 28) = 0u;
      *(_OWORD *)(v536 + 12) = 0u;
      *(_DWORD *)int v536 = v524;
      *(_DWORD *)(v536 + 4) = v525;
      *(_DWORD *)(v536 + 8) = v526;
      if ((int)(v524 - *(_DWORD *)(a1 + 2060)) < 0)
      {
        *(_DWORD *)(a1 + 2060) = v524;
        *(unsigned char *)(v536 + 12) = v523;
        if ((v523 & 4) != 0) {
          goto LABEL_1332;
        }
LABEL_1322:
        unsigned int v575 = *(char *)(a1 + 2069);
        if (v575 < 0)
        {
LABEL_1324:
          unsigned int v576 = *v894;
          if (*v894)
          {
            while (1)
            {
              while (1)
              {
                BOOL v577 = v576;
                int v578 = *(_DWORD *)(v536 + 4) - *(_DWORD *)(v576 + 4);
                if (v578 >= 0) {
                  break;
                }
                unsigned int v576 = *(void *)(v576 + 32);
                if (!v576) {
                  goto LABEL_1335;
                }
              }
              if (!v578) {
                break;
              }
              unsigned int v576 = *(void *)(v576 + 40);
              if (!v576) {
                goto LABEL_1335;
              }
            }
            int v580 = __nwlog_obj();
            if (os_log_type_enabled(v580, OS_LOG_TYPE_ERROR))
            {
              int v581 = *(_DWORD *)v577;
              v582 = *(_DWORD *)(v577 + 4);
              *(_DWORD *)long long buf = 136446978;
              *(void *)&uint8_t buf[4] = "tcp_seg_sent_insert";
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = v577;
              *(_WORD *)&unsigned char buf[22] = 1024;
              *(_DWORD *)v955 = v581;
              *(_WORD *)&v955[4] = 1024;
              *(_DWORD *)&v955[6] = v582;
              _os_log_impl(&dword_214653000, v580, OS_LOG_TYPE_ERROR, "%{public}s segment %p[%u %u) was not inserted in the RB tree", buf, 0x22u);
            }
          }
          else
          {
            BOOL v577 = 0;
            int v578 = 0;
LABEL_1335:
            *(void *)(v536 + 32) = 0;
            *(void *)(v536 + 40) = 0;
            *(void *)(v536 + 48) = v577 | 1;
            int v579 = (unint64_t *)(a1 + 2000);
            if (v577)
            {
              if (v578 < 0) {
                int v579 = (unint64_t *)(v577 + 32);
              }
              else {
                int v579 = (unint64_t *)(v577 + 40);
              }
            }
            *int v579 = v536;
            tcp_seg_sent_tree_head_RB_INSERT_COLOR((uint64_t)v894, v536);
          }
          *(void *)(v536 + 16) = 0;
          os_log_type_t v567 = v536 + 16;
          int v586 = *(unint64_t **)(a1 + 1992);
          *(void *)(v536 + 24) = v586;
          *int v586 = v536;
          goto LABEL_1345;
        }
      }
      else
      {
        *(unsigned char *)(v536 + 12) = v523;
        if ((v523 & 4) == 0) {
          goto LABEL_1322;
        }
LABEL_1332:
        *(_DWORD *)(a1 + 2076) += tcp_seg_len((int *)v536);
        unsigned int v575 = *(char *)(a1 + 2069);
        if (v575 < 0) {
          goto LABEL_1324;
        }
      }
      *(unsigned char *)(a1 + 2069) = v575 | (32 * v523);
      goto LABEL_1324;
    }
    char v527 = *(unsigned char *)(v55 + 12) | v523;
    if (*(_DWORD *)(v55 + 4) == v525)
    {
      if (*(_DWORD *)v55 != v524)
      {
        v927 = *v910;
        __nwlog_obj();
        int v528 = *(_DWORD *)v55;
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "tcp_seg_sent_insert";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v528;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v524;
        uint64_t v529 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(info.numer) = 16;
        v953 = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault()) {
          goto LABEL_1351;
        }
        if (LOBYTE(info.numer) != 17)
        {
          if (v953)
          {
            v552 = (void *)__nw_create_backtrace_string();
            unsigned int v553 = __nwlog_obj();
            int v554 = info.numer;
            uint64_t v555 = os_log_type_enabled(v553, info.numer);
            if (v552)
            {
              if (v555)
              {
                uint64_t v556 = *(_DWORD *)v55;
                *(_DWORD *)long long buf = 136446978;
                *(void *)&uint8_t buf[4] = "tcp_seg_sent_insert";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v556;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v524;
                *(_WORD *)v955 = 2082;
                *(void *)&v955[2] = v552;
                _os_log_impl(&dword_214653000, v553, v554, "%{public}s Segment start (%u) is not same as retransmitted start sequence number (%u), dumping backtrace:%{public}s", buf, 0x22u);
              }
              free(v552);
              goto LABEL_1351;
            }
            if (!v555) {
              goto LABEL_1351;
            }
            v588 = *(_DWORD *)v55;
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "tcp_seg_sent_insert";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v588;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v524;
            uint64_t v533 = v553;
            int v534 = v554;
            char v535 = "%{public}s Segment start (%u) is not same as retransmitted start sequence number (%u), no backtrace";
          }
          else
          {
            v583 = __nwlog_obj();
            int v584 = info.numer;
            if (!os_log_type_enabled(v583, info.numer)) {
              goto LABEL_1351;
            }
            unsigned int v585 = *(_DWORD *)v55;
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "tcp_seg_sent_insert";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v585;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v524;
            uint64_t v533 = v583;
            int v534 = v584;
            char v535 = "%{public}s Segment start (%u) is not same as retransmitted start sequence number (%u), backtrace limit exceeded";
          }
LABEL_1350:
          _os_log_impl(&dword_214653000, v533, v534, v535, buf, 0x18u);
          goto LABEL_1351;
        }
        uint64_t v530 = __nwlog_obj();
        int v531 = info.numer;
        if (os_log_type_enabled(v530, info.numer))
        {
          int v532 = *(_DWORD *)v55;
          *(_DWORD *)long long buf = 136446722;
          *(void *)&uint8_t buf[4] = "tcp_seg_sent_insert";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v532;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v524;
          uint64_t v533 = v530;
          int v534 = v531;
          char v535 = "%{public}s Segment start (%u) is not same as retransmitted start sequence number (%u)";
          goto LABEL_1350;
        }
LABEL_1351:
        if (v529) {
          free(v529);
        }
        BOOL v524 = *(_DWORD *)v55;
        char v525 = *(_DWORD *)(v55 + 4);
        v521 = v912;
        uint64_t v526 = v927;
      }
      *(_DWORD *)uint64_t v55 = v524;
      *(_DWORD *)(v55 + 4) = v525;
      *(_DWORD *)(v55 + 8) = v526;
      if ((int)(v524 - *(_DWORD *)(a1 + 2060)) < 0) {
        *(_DWORD *)(a1 + 2060) = v524;
      }
      os_log_type_t v589 = *(unsigned char *)(v55 + 12) | v527;
      *(unsigned char *)(v55 + 12) = v589;
      if ((v589 & 4) != 0)
      {
        uint64_t v590 = tcp_seg_len((int *)v55);
        v521 = v912;
        *(_DWORD *)(a1 + 2076) += v590;
      }
      unsigned int v591 = *(char *)(a1 + 2069);
      if ((v591 & 0x80000000) == 0) {
        *(unsigned char *)(a1 + 2069) = v591 | (32 * v527) & 0x80;
      }
      int v592 = *(void *)(v55 + 16);
      int v593 = *(void **)(v55 + 24);
      if (v592)
      {
        *(void *)(v592 + 24) = v593;
        int v593 = *(void **)(v55 + 24);
      }
      else
      {
        *(void *)(a1 + 1992) = v593;
      }
      *int v593 = v592;
      *(void *)(v55 + 16) = 0;
      int v594 = *(void **)(a1 + 1992);
      *(void *)(v55 + 24) = v594;
      *int v594 = v55;
      *(void *)(a1 + 1992) = v55 + 16;
      goto LABEL_1364;
    }
    int v539 = *(void *)(a1 + 2024);
    if (v539)
    {
      unsigned int v540 = *(void *)(v539 + 72);
      uint64_t v541 = *(void **)(v539 + 80);
      if (v540)
      {
        *(void *)(v540 + 80) = v541;
        uint64_t v541 = *(void **)(v539 + 80);
      }
      else
      {
        *(void *)(a1 + 2032) = v541;
      }
      *uint64_t v541 = v540;
      --*(_DWORD *)(a1 + 2040);
    }
    else
    {
      int v550 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
      unsigned int v551 = malloc_type_malloc(**(void **)(v550 + 64), 0xB9BAFBABuLL);
      v521 = v912;
      int v539 = (unint64_t)v551;
      if (!v551) {
        goto LABEL_1364;
      }
    }
    *(void *)(v539 + 80) = 0;
    *(_OWORD *)(v539 + 48) = 0u;
    *(_OWORD *)(v539 + 64) = 0u;
    *(_OWORD *)(v539 + 16) = 0u;
    *(_OWORD *)(v539 + 32) = 0u;
    *(_OWORD *)int v539 = 0u;
    *(_DWORD *)v55 += v306;
    *(_DWORD *)int v539 = v524;
    *(_DWORD *)(v539 + 4) = v525;
    *(_DWORD *)(v539 + 8) = v526;
    if ((int)(v524 - *(_DWORD *)(a1 + 2060)) >= 0)
    {
      *(unsigned char *)(v539 + 12) = v527;
      if ((v527 & 4) == 0) {
        goto LABEL_1286;
      }
LABEL_1296:
      *(_DWORD *)(a1 + 2076) += tcp_seg_len((int *)v539);
      int v557 = *(char *)(a1 + 2069);
      if (v557 < 0) {
        goto LABEL_1288;
      }
LABEL_1287:
      *(unsigned char *)(a1 + 2069) = v557 | (32 * v527) & 0x80;
      goto LABEL_1288;
    }
    *(_DWORD *)(a1 + 2060) = v524;
    *(unsigned char *)(v539 + 12) = v527;
    if ((v527 & 4) != 0) {
      goto LABEL_1296;
    }
LABEL_1286:
    int v557 = *(char *)(a1 + 2069);
    if ((v557 & 0x80000000) == 0) {
      goto LABEL_1287;
    }
LABEL_1288:
    int v558 = *v894;
    if (*v894)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v559 = v558;
          int v560 = *(_DWORD *)(v539 + 4) - *(_DWORD *)(v558 + 4);
          if (v560 >= 0) {
            break;
          }
          int v558 = *(void *)(v558 + 32);
          if (!v558) {
            goto LABEL_1299;
          }
        }
        if (!v560) {
          break;
        }
        int v558 = *(void *)(v558 + 40);
        if (!v558) {
          goto LABEL_1299;
        }
      }
      int v564 = __nwlog_obj();
      if (os_log_type_enabled(v564, OS_LOG_TYPE_ERROR))
      {
        v565 = *(_DWORD *)v559;
        v566 = *(_DWORD *)(v559 + 4);
        *(_DWORD *)long long buf = 136446978;
        *(void *)&uint8_t buf[4] = "tcp_seg_sent_insert";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v559;
        *(_WORD *)&unsigned char buf[22] = 1024;
        *(_DWORD *)v955 = v565;
        *(_WORD *)&v955[4] = 1024;
        *(_DWORD *)&v955[6] = v566;
        _os_log_impl(&dword_214653000, v564, OS_LOG_TYPE_ERROR, "%{public}s segment %p[%u %u) was not inserted in the RB tree", buf, 0x22u);
      }
    }
    else
    {
      uint64_t v559 = 0;
      int v560 = 0;
LABEL_1299:
      *(void *)(v539 + 32) = 0;
      *(void *)(v539 + 40) = 0;
      *(void *)(v539 + 48) = v559 | 1;
      int v561 = (unint64_t *)(a1 + 2000);
      if (v559)
      {
        if (v560 < 0) {
          int v561 = (unint64_t *)(v559 + 32);
        }
        else {
          int v561 = (unint64_t *)(v559 + 40);
        }
      }
      *int v561 = v539;
      tcp_seg_sent_tree_head_RB_INSERT_COLOR((uint64_t)v894, v539);
    }
    *(void *)(v539 + 16) = 0;
    os_log_type_t v567 = v539 + 16;
    v568 = *(unint64_t **)(a1 + 1992);
    *(void *)(v539 + 24) = v568;
    const char *v568 = v539;
LABEL_1345:
    *(void *)(a1 + 1992) = v567;
LABEL_1346:
    v521 = v912;
    int v587 = v913;
    if (v913) {
      goto LABEL_1365;
    }
LABEL_1434:
    v660 = v521 ? 1 : v935;
    __int16 v25 = (void *)(a1 + 632);
    uint64_t v3 = v923;
    uint64_t v2 = v940;
LABEL_1438:
    if (v940[2238]) {
      goto LABEL_1443;
    }
    if (*v949) {
      break;
    }
    int v664 = *(_DWORD *)(a1 + 88);
    if ((v664 & 0x8000000) != 0) {
      goto LABEL_1809;
    }
LABEL_1443:
    char v665 = *(void **)(a1 + 1056);
    if (v665) {
      ++*v665;
    }
    if (!v587) {
      goto LABEL_1709;
    }
  }
  v661 = *(_DWORD *)(a1 + 300);
  BOOL v662 = *(_DWORD *)(a1 + 648);
  *(_DWORD *)(a1 + 284) = *(_DWORD *)(a1 + 120);
  *(_DWORD *)(a1 + 88) &= 0xFFFFFFFC;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 304) = 0;
  int v663 = tcp_ip_output_send(v923, a1, v949, v661, v660);
  *(void *)(a1 + 632) = 0;
  *(void *)(a1 + 640) = v949;
  *(_DWORD *)(a1 + 648) = 0;
  *(_DWORD *)(a1 + 300) = 0;
  if (!v663) {
    goto LABEL_1438;
  }
  uint64_t v515 = v663;
  if (v940[2238])
  {
    v743 = v946;
    unint64_t v124 = a1 + 100;
    goto LABEL_1571;
  }
  int v664 = *(_DWORD *)(a1 + 88);
  v743 = v946;
  unint64_t v124 = a1 + 100;
  if ((v664 & 0x8000000) != 0) {
    goto LABEL_1809;
  }
LABEL_1571:
  v744 = *(_DWORD *)(a1 + 740);
  if ((v744 & 0x8000) != 0)
  {
    if (!(*(_DWORD *)(a1 + 36) | v743 & 2)) {
      goto LABEL_1575;
    }
    goto LABEL_1627;
  }
  if ((v743 & 2) != 0) {
    goto LABEL_1627;
  }
LABEL_1575:
  BOOL v59 = (v744 & 0x20400020) == 536870944;
  v745 = v935 ^ 1;
  os_log_type_t v746 = *(_DWORD *)(a1 + 92);
  if (v59) {
    v745 = 1;
  }
  if ((v745 & 1) == 0)
  {
    v747 = *v898 - v662;
    if (v747 - v746 < 1)
    {
      BOOL v662 = *v898 - v746;
      if (v746 - *v61 < 0) {
        os_log_type_t v746 = *v61;
      }
    }
    else
    {
      os_log_type_t v746 = *v61;
      if (v747 - *v61 >= 0) {
        os_log_type_t v746 = *v898 - v662;
      }
    }
    *__int16 v898 = v746;
    *(_DWORD *)(a1 + 624) = (*(_DWORD *)(a1 + 624) - v662) & ~((*(_DWORD *)(a1 + 624) - v662) >> 31);
    v749 = (void *)*v25;
    if (!*v25) {
      goto LABEL_1692;
    }
LABEL_1628:
    while (2)
    {
      v768 = v749[4];
      v769 = (void *)v749[5];
      if (v768)
      {
        *(void *)(v768 + 40) = v769;
        v769 = (void *)v749[5];
      }
      else
      {
        *(void *)(a1 + 640) = v769;
      }
      void *v769 = v768;
      v770 = (void (*)(void *, void, uint64_t))v749[10];
      v749[4] = 0;
      v749[5] = 0;
      if (v770)
      {
        v771 = v749[11];
        v749[10] = 0;
        v749[11] = 0;
        v770(v749, 0, v771);
        goto LABEL_1633;
      }
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
      BOOL v772 = _os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v953 = OS_LOG_TYPE_DEFAULT;
      v936 = (void *)v772;
      if (!__nwlog_fault()) {
        goto LABEL_1649;
      }
      if (LOBYTE(info.numer) == 17)
      {
        v931 = __nwlog_obj();
        v920 = info.numer;
        if (os_log_type_enabled(v931, info.numer))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          v773 = v931;
          v774 = v920;
          v775 = "%{public}s called with null frame->finalizer";
          break;
        }
        goto LABEL_1649;
      }
      if (v953)
      {
        v932 = (os_log_t)__nw_create_backtrace_string();
        v921 = __nwlog_obj();
        typea = info.numer;
        v776 = os_log_type_enabled(v921, info.numer);
        v777 = v932;
        if (v932)
        {
          if (v776)
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v932;
            _os_log_impl(&dword_214653000, v921, typea, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
            v777 = v932;
          }
          free(v777);
          goto LABEL_1649;
        }
        if (!v776)
        {
LABEL_1649:
          if (v936) {
            free(v936);
          }
LABEL_1633:
          v749 = (void *)*v949;
          if (!*v949) {
            goto LABEL_1692;
          }
          continue;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        v773 = v921;
        v774 = typea;
        v775 = "%{public}s called with null frame->finalizer, no backtrace";
      }
      else
      {
        v933 = __nwlog_obj();
        v922 = info.numer;
        if (!os_log_type_enabled(v933, info.numer)) {
          goto LABEL_1649;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        v773 = v933;
        v774 = v922;
        v775 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
      }
      break;
    }
    _os_log_impl(&dword_214653000, v773, v774, v775, buf, 0xCu);
    goto LABEL_1649;
  }
  v748 = *(_DWORD *)v124 - v662;
  if (v748 - v746 < 1)
  {
    *(_DWORD *)unint64_t v124 = v746;
    v749 = (void *)*v25;
    if (*v25) {
      goto LABEL_1628;
    }
  }
  else
  {
    *(_DWORD *)unint64_t v124 = v748;
    v749 = (void *)*v25;
    if (*v25) {
      goto LABEL_1628;
    }
  }
LABEL_1692:
  *(void *)(a1 + 632) = 0;
  *(void *)(a1 + 640) = v949;
  *(_DWORD *)(a1 + 648) = 0;
  *(_DWORD *)(a1 + 300) = 0;
  switch(v515)
  {
    case '(':
      if (v914) {
        *(_DWORD *)(a1 + 88) &= ~0x10000000u;
      }
      tcp_mtudisc(v940);
LABEL_1709:
      tcp_check_timer_state(a1);
      return 0;
    case '2':
      if (*(int *)(a1 + 12) >= 3)
      {
        *(_DWORD *)(a1 + 256) = 50;
        uint64_t v515 = 0;
      }
      break;
    case '7':
      if (!*(_DWORD *)(a1 + 28) && !*(_DWORD *)(a1 + 36))
      {
        v792 = v896;
        if ((v946 & 3) != 0) {
          v792 = 1;
        }
        if ((v792 & 1) != 0 || *(_DWORD *)(v923 + 384)) {
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 192)
        }
                               + *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 316)
                               - *(_DWORD *)(a1 + 64);
      }
      *(_DWORD *)(a1 + 144) = *(_DWORD *)(a1 + 196);
      *(_DWORD *)(a1 + 288) = 0;
      goto LABEL_1709;
  }
  tcp_check_timer_state(a1);
  return v515;
}

uint64_t tcp_ip_output(uint64_t a1, uint64_t a2, void *a3, int a4, int a5)
{
  if (*a3 || *(void *)(a2 + 656))
  {
    *(_DWORD *)(a2 + 284) = *(_DWORD *)(a2 + 120);
    *(_DWORD *)(a2 + 88) &= 0xFFFFFFFC;
    *(_DWORD *)(a2 + 32) = 0;
    *(_DWORD *)(a2 + 304) = 0;
    return tcp_ip_output_send(a1, a2, a3, a4, a5);
  }
  return a1;
}

BOOL nw_protocol_tcp_copy_frame_to_buffer(uint64_t a1, int a2, int a3, char *__dst)
{
  int v5 = a3;
  uint64_t v6 = a1;
  for (i = *MEMORY[0x263EF8340]; a2 >= 1 && v6; uint64_t v6 = *(void *)(v6 + 32))
  {
    int v7 = *(_DWORD *)(v6 + 52);
    if (v7)
    {
      int v8 = *(_DWORD *)(v6 + 56);
      int v9 = *(_DWORD *)(v6 + 60);
      int v10 = v7 - (v8 + v9);
      if (a2 < v10) {
        goto LABEL_13;
      }
      int v11 = v8 - v7 + v9;
    }
    else
    {
      int v11 = 0;
    }
    a2 += v11;
  }
  if ((a2 & 0x80000000) == 0)
  {
    if (!v6)
    {
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      int v37 = "__nw_frame_unclaimed_length";
      int v34 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        int v35 = __nwlog_obj();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136446210;
          int v37 = "__nw_frame_unclaimed_length";
          _os_log_impl(&dword_214653000, v35, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
        }
      }
      if (v34) {
        free(v34);
      }
      goto LABEL_14;
    }
    int v10 = *(_DWORD *)(v6 + 52);
    if (v10) {
      v10 -= *(_DWORD *)(v6 + 56) + *(_DWORD *)(v6 + 60);
    }
LABEL_13:
    if (v10 < a2)
    {
LABEL_14:
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
      int v12 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        uint64_t v26 = __nwlog_obj();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136446210;
          int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
          uint64_t v27 = "%{public}s invalid source frame, backtrace limit exceeded";
LABEL_63:
          _os_log_impl(&dword_214653000, v26, OS_LOG_TYPE_ERROR, v27, buf, 0xCu);
          goto LABEL_64;
        }
      }
      goto LABEL_64;
    }
    if (a3 < 1) {
      return v5 == 0;
    }
    uint64_t v13 = a2;
    if ((uint64_t)(v10 - (unint64_t)a2) >= a3) {
      size_t v14 = a3;
    }
    else {
      size_t v14 = (v10 - a2);
    }
    if (!v14)
    {
LABEL_54:
      int v24 = __nwlog_obj();
      BOOL result = os_log_type_enabled(v24, OS_LOG_TYPE_INFO);
      if (!result) {
        return result;
      }
      *(_DWORD *)long long buf = 136446210;
      int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
      goto LABEL_62;
    }
    if ((*(_WORD *)(v6 + 204) & 2) == 0)
    {
      uint64_t v15 = *(void *)(v6 + 112);
      if (!v15
        || (*(_WORD *)(v6 + 204) & 0x100) != 0
        && *MEMORY[0x263F144B8]
        && (!((unsigned int (*)(uint64_t, void))*MEMORY[0x263F144B8])(v6, *(void *)(v6 + 88))
         || (uint64_t v15 = *(void *)(v6 + 112)) == 0))
      {
LABEL_60:
        int v24 = __nwlog_obj();
        BOOL result = os_log_type_enabled(v24, OS_LOG_TYPE_INFO);
        if (!result) {
          return result;
        }
        *(_DWORD *)long long buf = 136446210;
        int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
LABEL_62:
        _os_log_impl(&dword_214653000, v24, OS_LOG_TYPE_INFO, "%{public}s source buffer is no longer valid", buf, 0xCu);
        return 0;
      }
      memcpy(__dst, (const void *)(v15 + v13 + *(unsigned int *)(v6 + 56)), v14);
LABEL_32:
      v5 -= v14;
      uint64_t v17 = *(void *)(v6 + 32);
      if (v17)
      {
        unsigned int v18 = *(_DWORD *)(v17 + 52);
        if (v18) {
          v18 -= *(_DWORD *)(v17 + 56) + *(_DWORD *)(v17 + 60);
        }
        if (v5 >= 1)
        {
          unsigned int v19 = &__dst[v14];
          unsigned int v20 = (unsigned int (**)(uint64_t, void))MEMORY[0x263F144B8];
          while (1)
          {
            size_t v21 = v18 >= v5 ? v5 : v18;
            if (!v21) {
              goto LABEL_54;
            }
            if ((*(_WORD *)(v17 + 204) & 2) != 0)
            {
              if (!*(void *)(v17 + 96)) {
                goto LABEL_67;
              }
              uint64_t v23 = nw_dispatch_data_copyout_from_offset();
              if (v23 != v21)
              {
                uint64_t v29 = v23;
                LODWORD(v14) = v21;
                goto LABEL_70;
              }
            }
            else
            {
              uint64_t v22 = *(void *)(v17 + 112);
              if (!v22) {
                goto LABEL_60;
              }
              if ((*(_WORD *)(v17 + 204) & 0x100) != 0)
              {
                if (*v20)
                {
                  if (!(*v20)(v17, *(void *)(v17 + 88))) {
                    goto LABEL_60;
                  }
                  uint64_t v22 = *(void *)(v17 + 112);
                  if (!v22) {
                    goto LABEL_60;
                  }
                }
              }
              memcpy(v19, (const void *)(v22 + *(unsigned int *)(v17 + 56)), v21);
            }
            v5 -= v21;
            uint64_t v17 = *(void *)(v17 + 32);
            if (v17)
            {
              unsigned int v18 = *(_DWORD *)(v17 + 52);
              if (v18) {
                v18 -= *(_DWORD *)(v17 + 56) + *(_DWORD *)(v17 + 60);
              }
              v19 += v21;
              if (v5 > 0) {
                continue;
              }
            }
            return v5 == 0;
          }
        }
      }
      return v5 == 0;
    }
    if (*(void *)(v6 + 96))
    {
      uint64_t v16 = nw_dispatch_data_copyout_from_offset();
      if (v16 == v14) {
        goto LABEL_32;
      }
      uint64_t v29 = v16;
LABEL_70:
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446722;
      int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
      __int16 v38 = 2048;
      uint64_t v39 = v29;
      __int16 v40 = 1024;
      int v41 = v14;
      uint64_t v30 = _os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        unsigned int v32 = __nwlog_obj();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136446722;
          int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
          __int16 v38 = 2048;
          uint64_t v39 = v29;
          __int16 v40 = 1024;
          int v41 = v14;
          _os_log_impl(&dword_214653000, v32, OS_LOG_TYPE_ERROR, "%{public}s Copied %zu out of expected %u bytes, backtrace limit exceeded", buf, 0x1Cu);
        }
      }
      if (!v30) {
        return v5 == 0;
      }
      unsigned int v33 = (void *)v30;
    }
    else
    {
LABEL_67:
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
      uint64_t v28 = _os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        int v31 = __nwlog_obj();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136446210;
          int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
          _os_log_impl(&dword_214653000, v31, OS_LOG_TYPE_ERROR, "%{public}s Failed to extract data from frame, backtrace limit exceeded", buf, 0xCu);
        }
      }
      if (!v28) {
        return v5 == 0;
      }
      unsigned int v33 = (void *)v28;
    }
    free(v33);
    return v5 == 0;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
  int v12 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    uint64_t v26 = __nwlog_obj();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446210;
      int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
      uint64_t v27 = "%{public}s source_offset < 0, backtrace limit exceeded";
      goto LABEL_63;
    }
  }
LABEL_64:
  if (v12) {
    free(v12);
  }
  return 0;
}

uint64_t tcp_seg_sent_tree_head_RB_INSERT_COLOR(uint64_t result, unint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  while (1)
  {
    uint64_t v4 = (void *)(v2 & 0xFFFFFFFFFFFFFFFELL);
    if ((v2 & 0xFFFFFFFFFFFFFFFELL) == 0) {
      break;
    }
    uint64_t v5 = v4[6];
    if ((v5 & 1) == 0) {
      break;
    }
    uint64_t v6 = (void *)(v5 & 0xFFFFFFFFFFFFFFFELL);
    int v7 = *(void **)((v5 & 0xFFFFFFFFFFFFFFFELL) + 32);
    if (v7 == v4)
    {
      int v7 = (void *)v6[5];
      if (v7)
      {
        uint64_t v8 = v7[6];
        if (v8)
        {
LABEL_2:
          v7[6] = v8 & 0xFFFFFFFFFFFFFFFELL;
          v4[6] &= ~1uLL;
          v6[6] |= 1uLL;
          unint64_t v3 = v5 & 0xFFFFFFFFFFFFFFFELL;
          goto LABEL_3;
        }
      }
      int v10 = (void *)v4[5];
      if (v10 == (void *)a2)
      {
        uint64_t v16 = *(void *)(a2 + 32);
        v4[5] = v16;
        if (v16)
        {
          uint64_t v17 = v2 | 1;
          if ((*(void *)(v16 + 48) & 1) == 0) {
            uint64_t v17 = (uint64_t)v4;
          }
          *(void *)(v16 + 48) = v17;
          uint64_t v18 = v4[6];
          uint64_t v2 = *(void *)(a2 + 48);
        }
        else
        {
          uint64_t v18 = v5;
        }
        *(void *)(a2 + 48) = v18 & 0xFFFFFFFFFFFFFFFELL | v2 & 1;
        if ((v18 & 0xFFFFFFFFFFFFFFFELL) != 0)
        {
          uint64_t v29 = v4[6];
          unint64_t v30 = v29 & 0xFFFFFFFFFFFFFFFELL;
          if (*(void **)((v29 & 0xFFFFFFFFFFFFFFFELL) + 32) == v4) {
            *(void *)(v30 + 32) = a2;
          }
          else {
            *(void *)(v30 + 40) = a2;
          }
        }
        else
        {
          *(void *)BOOL result = a2;
          uint64_t v29 = v4[6];
        }
        *(void *)(a2 + 32) = v4;
        if (v29) {
          uint64_t v31 = a2 | 1;
        }
        else {
          uint64_t v31 = a2;
        }
        v4[6] = v31;
        unint64_t v12 = v6[4];
        int v10 = *(void **)(v12 + 40);
        unint64_t v11 = *(void *)(a2 + 48) & 0xFFFFFFFFFFFFFFFELL;
        unint64_t v3 = (unint64_t)v4;
      }
      else
      {
        unint64_t v11 = v5 & 0xFFFFFFFFFFFFFFFELL;
        unint64_t v12 = v2 & 0xFFFFFFFFFFFFFFFELL;
        unint64_t v3 = a2;
        a2 = (unint64_t)v4;
      }
      *(void *)(a2 + 48) = v11;
      uint64_t v32 = v6[6] | 1;
      v6[6] = v32;
      v6[4] = v10;
      if (v10)
      {
        uint64_t v33 = v5 | 1;
        if ((v10[6] & 1) == 0) {
          uint64_t v33 = (uint64_t)v6;
        }
        v10[6] = v33;
        uint64_t v32 = v6[6];
      }
      *(void *)(v12 + 48) = v32 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v12 + 48) & 1;
      if ((v32 & 0xFFFFFFFFFFFFFFFELL) != 0)
      {
        uint64_t v34 = v6[6];
        unint64_t v35 = v34 & 0xFFFFFFFFFFFFFFFELL;
        if (*(void **)((v34 & 0xFFFFFFFFFFFFFFFELL) + 32) == v6) {
          *(void *)(v35 + 32) = v12;
        }
        else {
          *(void *)(v35 + 40) = v12;
        }
      }
      else
      {
        *(void *)BOOL result = v12;
        uint64_t v34 = v6[6];
      }
      *(void *)(v12 + 40) = v6;
      if (v34) {
        uint64_t v36 = v12 | 1;
      }
      else {
        uint64_t v36 = v12;
      }
      v6[6] = v36;
    }
    else
    {
      if (v7)
      {
        uint64_t v8 = v7[6];
        if (v8) {
          goto LABEL_2;
        }
      }
      if (v4[4] == a2)
      {
        uint64_t v13 = *(void *)(a2 + 40);
        v4[4] = v13;
        if (v13)
        {
          uint64_t v14 = v2 | 1;
          if ((*(void *)(v13 + 48) & 1) == 0) {
            uint64_t v14 = (uint64_t)v4;
          }
          *(void *)(v13 + 48) = v14;
          uint64_t v15 = v4[6];
          uint64_t v2 = *(void *)(a2 + 48);
        }
        else
        {
          uint64_t v15 = v5;
        }
        *(void *)(a2 + 48) = v15 & 0xFFFFFFFFFFFFFFFELL | v2 & 1;
        if ((v15 & 0xFFFFFFFFFFFFFFFELL) != 0)
        {
          uint64_t v19 = v4[6];
          unint64_t v20 = v19 & 0xFFFFFFFFFFFFFFFELL;
          if (*(void **)((v19 & 0xFFFFFFFFFFFFFFFELL) + 32) == v4) {
            *(void *)(v20 + 32) = a2;
          }
          else {
            *(void *)(v20 + 40) = a2;
          }
        }
        else
        {
          *(void *)BOOL result = a2;
          uint64_t v19 = v4[6];
        }
        *(void *)(a2 + 40) = v4;
        if (v19) {
          uint64_t v21 = a2 | 1;
        }
        else {
          uint64_t v21 = a2;
        }
        v4[6] = v21;
        unint64_t v9 = *(void *)(a2 + 48) & 0xFFFFFFFFFFFFFFFELL;
        unint64_t v3 = (unint64_t)v4;
      }
      else
      {
        unint64_t v9 = v5 & 0xFFFFFFFFFFFFFFFELL;
        unint64_t v3 = a2;
        a2 = (unint64_t)v4;
      }
      *(void *)(a2 + 48) = v9;
      uint64_t v22 = v6[5];
      uint64_t v23 = v6[6] | 1;
      uint64_t v24 = *(void *)(v22 + 32);
      v6[5] = v24;
      v6[6] = v23;
      if (v24)
      {
        uint64_t v25 = v5 | 1;
        if ((*(void *)(v24 + 48) & 1) == 0) {
          uint64_t v25 = (uint64_t)v6;
        }
        *(void *)(v24 + 48) = v25;
        uint64_t v23 = v6[6];
      }
      *(void *)(v22 + 48) = v23 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v22 + 48) & 1;
      if ((v23 & 0xFFFFFFFFFFFFFFFELL) != 0)
      {
        uint64_t v26 = v6[6];
        unint64_t v27 = v26 & 0xFFFFFFFFFFFFFFFELL;
        if (*(void **)((v26 & 0xFFFFFFFFFFFFFFFELL) + 32) == v6) {
          *(void *)(v27 + 32) = v22;
        }
        else {
          *(void *)(v27 + 40) = v22;
        }
      }
      else
      {
        *(void *)BOOL result = v22;
        uint64_t v26 = v6[6];
      }
      *(void *)(v22 + 32) = v6;
      if (v26) {
        uint64_t v28 = v22 | 1;
      }
      else {
        uint64_t v28 = v22;
      }
      v6[6] = v28;
    }
LABEL_3:
    uint64_t v2 = *(void *)(v3 + 48);
    a2 = v3;
  }
  *(void *)(*(void *)result + 48) &= ~1uLL;
  return result;
}

uint64_t tcp_flight_size(_DWORD *a1)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  if ((a1[157] & 0x80000000) != 0)
  {
    uint64_t v22 = __nwlog_obj();
    os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long buf = 136446210;
    unint64_t v27 = "tcp_flight_size";
    uint64_t v23 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if (result) {
      goto LABEL_20;
    }
    free(v23);
    if ((a1[156] & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_18:
    uint64_t v24 = __nwlog_obj();
    os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long buf = 136446210;
    unint64_t v27 = "tcp_flight_size";
    uint64_t v25 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if (!result)
    {
      free(v25);
      goto LABEL_3;
    }
LABEL_20:
    __break(1u);
    return result;
  }
  if ((a1[156] & 0x80000000) != 0) {
    goto LABEL_18;
  }
LABEL_3:
  int v2 = a1[25];
  int v3 = a1[23];
  if ((a1[185] & 0x20400020) != 0x20000020) {
    return (v2 - (v3 + a1[157])) & ~((v2 - (v3 + a1[157])) >> 31);
  }
  if (a1[24] - v2 > 0) {
    int v2 = a1[24];
  }
  int v4 = a1[519];
  int v5 = v2 - (a1[520] + v3 + a1[518]);
  uint64_t v6 = (v5 + v4);
  if (v5 + v4 < 0)
  {
    __nwlog_obj();
    int v8 = a1[24];
    int v7 = a1[25];
    int v9 = a1[23];
    int v10 = a1[520];
    int v11 = a1[518];
    int v12 = a1[519];
    *(_DWORD *)long long buf = 136448002;
    unint64_t v27 = "tcp_flight_size";
    __int16 v28 = 1024;
    int v29 = v6;
    __int16 v30 = 1024;
    int v31 = v7;
    __int16 v32 = 1024;
    int v33 = v8;
    __int16 v34 = 1024;
    int v35 = v9;
    __int16 v36 = 1024;
    int v37 = v10;
    __int16 v38 = 1024;
    int v39 = v11;
    __int16 v40 = 1024;
    int v41 = v12;
    uint64_t v13 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v14 = __nwlog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        int v16 = a1[24];
        int v15 = a1[25];
        int v17 = a1[23];
        int v18 = a1[520];
        int v19 = a1[518];
        int v20 = a1[519];
        *(_DWORD *)long long buf = 136448002;
        unint64_t v27 = "tcp_flight_size";
        __int16 v28 = 1024;
        int v29 = v6;
        __int16 v30 = 1024;
        int v31 = v15;
        __int16 v32 = 1024;
        int v33 = v16;
        __int16 v34 = 1024;
        int v35 = v17;
        __int16 v36 = 1024;
        int v37 = v18;
        __int16 v38 = 1024;
        int v39 = v19;
        __int16 v40 = 1024;
        int v41 = v20;
        _os_log_impl(&dword_214653000, v14, OS_LOG_TYPE_ERROR, "%{public}s flight_size (%d) can't be negative (snd_nxt:%u snd_max:%u, snd_una:%u, sacked:%u lost:%u retransmitted:%u), backtrace limit exceeded", buf, 0x36u);
      }
    }
    if (v13) {
      free(v13);
    }
    return 0;
  }
  return v6;
}

uint64_t tcp_process_rxmt_segs_after_rto(uint64_t result, int *a2, int a3, int a4, char a5)
{
  int v7 = a2;
  uint64_t v8 = result;
  int v9 = *a2;
  if (*a2 - a3 <= 0)
  {
    int v12 = a2[1];
LABEL_24:
    *int v7 = v9;
    v7[1] = v12;
    v7[2] = a4;
    if (v9 - *(_DWORD *)(v8 + 2060) < 0) {
      *(_DWORD *)(v8 + 2060) = v9;
    }
    char v19 = *((unsigned char *)v7 + 12) | a5;
    *((unsigned char *)v7 + 12) = v19;
    if ((v19 & 4) != 0)
    {
      uint64_t result = tcp_seg_len(v7);
      *(_DWORD *)(v8 + 2076) += result;
    }
    int v20 = *(char *)(v8 + 2069);
    if ((v20 & 0x80000000) == 0) {
      *(unsigned char *)(v8 + 2069) = v20 | (32 * a5) & 0x80;
    }
    if (*(int **)(v8 + 1984) == v7)
    {
      uint64_t v21 = *((void *)v7 + 2);
      uint64_t v22 = (void *)*((void *)v7 + 3);
      if (v21)
      {
        *(void *)(v21 + 24) = v22;
        uint64_t v22 = (void *)*((void *)v7 + 3);
      }
      else
      {
        *(void *)(v8 + 1992) = v22;
      }
      *uint64_t v22 = v21;
      uint64_t v23 = *(int ***)(v8 + 1992);
      *((void *)v7 + 2) = 0;
      *((void *)v7 + 3) = v23;
      *uint64_t v23 = v7;
      *(void *)(v8 + 1992) = v7 + 4;
    }
  }
  else
  {
    char v11 = (32 * a5) & 0x80;
    int v12 = a2[1];
    while (1)
    {
      *int v7 = v9;
      v7[1] = v12;
      v7[2] = a4;
      if (v9 - *(_DWORD *)(v8 + 2060) < 0) {
        *(_DWORD *)(v8 + 2060) = v9;
      }
      char v13 = *((unsigned char *)v7 + 12) | a5;
      *((unsigned char *)v7 + 12) = v13;
      if ((v13 & 4) != 0)
      {
        uint64_t result = tcp_seg_len(v7);
        *(_DWORD *)(v8 + 2076) += result;
      }
      int v14 = *(char *)(v8 + 2069);
      if ((v14 & 0x80000000) == 0) {
        *(unsigned char *)(v8 + 2069) = v14 | v11;
      }
      if (*(int **)(v8 + 1984) == v7)
      {
        uint64_t v15 = *((void *)v7 + 2);
        int v16 = (void *)*((void *)v7 + 3);
        if (v15)
        {
          *(void *)(v15 + 24) = v16;
          int v16 = (void *)*((void *)v7 + 3);
        }
        else
        {
          *(void *)(v8 + 1992) = v16;
        }
        *int v16 = v15;
        int v17 = *(int ***)(v8 + 1992);
        *((void *)v7 + 2) = 0;
        *((void *)v7 + 3) = v17;
        *int v17 = v7;
        *(void *)(v8 + 1992) = v7 + 4;
      }
      if (!*(void *)(v8 + 2000)) {
        break;
      }
      int v12 = *v7;
      int v7 = *(int **)(v8 + 2000);
      while (1)
      {
        while (1)
        {
          int v18 = v7[1];
          if (v12 - v18 >= 0) {
            break;
          }
          int v7 = (int *)*((void *)v7 + 4);
          if (!v7) {
            return result;
          }
        }
        if (v12 == v18) {
          break;
        }
        int v7 = (int *)*((void *)v7 + 5);
        if (!v7) {
          return result;
        }
      }
      int v9 = *v7;
      if (*v7 - a3 <= 0) {
        goto LABEL_24;
      }
    }
  }
  return result;
}

void *tcp_mtudisc(void *result)
{
  uint64_t v1 = result[28];
  if (*(__int16 *)(v1 + 376) < 0) {
    return result;
  }
  uint64_t v2 = result[30];
  if (!v2 || !*(_DWORD *)(v2 + 12)) {
    return result;
  }
  char v3 = *(unsigned char *)(*(void *)(v2 + 80) + 2236);
  if ((v3 & 2) != 0) {
    int v4 = -60;
  }
  else {
    int v4 = -40;
  }
  if ((*(unsigned char *)(*(void *)(v2 + 80) + 2236) & 2) != 0)
  {
    uint64_t result = (void *)tcp_rtlookup6((uint64_t)result, 0);
    if (!result) {
      goto LABEL_38;
    }
  }
  else
  {
    uint64_t result = (void *)tcp_rtlookup((uint64_t)result, 0);
    if (!result) {
      goto LABEL_38;
    }
  }
  uint64_t v5 = result[186];
  if (!v5 || (unsigned int v6 = *(_DWORD *)(v5 + 48)) == 0)
  {
LABEL_38:
    uint64_t v13 = 152;
    if ((v3 & 2) == 0) {
      uint64_t v13 = 148;
    }
    int v14 = *(_DWORD *)(sysctls + v13);
    *(_DWORD *)(v2 + 196) = v14;
    *(_DWORD *)(v2 + 156) = v14;
    return result;
  }
  int v7 = *(_DWORD *)(v5 + 52);
  if (v6 >= *(_DWORD *)(result[27] + 1044)) {
    unsigned int v6 = *(_DWORD *)(result[27] + 1044);
  }
  int v8 = v6 + v4;
  if (v8 >= v7) {
    int v9 = v7;
  }
  else {
    int v9 = v8;
  }
  if (v7) {
    int v10 = v9;
  }
  else {
    int v10 = v8;
  }
  if (*(_DWORD *)(v2 + 156) > v10)
  {
    *(_DWORD *)(v2 + 156) = v10;
    if ((*(_DWORD *)(v2 + 88) & 0x188) == 0x180) {
      v10 -= 12;
    }
    if (*(_DWORD *)(v1 + 388) < v10) {
      int v10 = *(_DWORD *)(v1 + 388);
    }
    *(_DWORD *)(v2 + 196) = v10;
    if (!v10)
    {
      uint64_t v17 = v1;
      uint64_t v15 = __nwlog_obj();
      os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
      int v16 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = (void *)__nwlog_abort();
      if (result)
      {
        __break(1u);
        return result;
      }
      free(v16);
      uint64_t v1 = v17;
    }
    char v11 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(v2 + 264)] + 40);
    if (v11) {
      v11(v2);
    }
    if (*(_DWORD *)(sysctls + 308) == 1
      && (~*(_DWORD *)(v2 + 88) & 0x180) == 0
      && (*(_DWORD *)(sysctls + 40) == 1 || (*(unsigned char *)(v1 + 369) & 0x40) != 0)
      && off_26AA46358)
    {
      off_26AA46358((_DWORD *)v2);
    }
    uint64_t v12 = *(void *)(v2 + 1056);
    if (v12) {
      ++*(void *)(v12 + 40);
    }
    *(_DWORD *)(v2 + 172) = 0;
    *(_DWORD *)(v2 + 100) = *(_DWORD *)(v2 + 92);
    return (void *)tcp_output(v2);
  }
  return result;
}

void tcp_release_route_heuristics(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t heuristics = tcp_get_heuristics(*(void *)(a1 + 80), 0);
  if (heuristics)
  {
    uint64_t v3 = heuristics;
    int v4 = *(_DWORD *)(heuristics + 148);
    *(_DWORD *)(heuristics + 148) = v4 - 1;
    if (v4 > 0) {
      return;
    }
    uint64_t v5 = *((void *)v1[10].isa + 28);
    if (v5)
    {
      if ((*(unsigned char *)(v5 + 828) & 2) != 0) {
        return;
      }
    }
    uint64_t v1 = __nwlog_tcp_log();
    os_log_type_enabled(v1, OS_LOG_TYPE_ERROR);
    unsigned int v6 = (const char *)(v5 + 604);
    uint64_t v13 = "tcp_release_route_heuristics";
    int v7 = *(_DWORD *)(v3 + 148);
    *(_DWORD *)long long buf = 136446722;
    if (!v5) {
      unsigned int v6 = "";
    }
    __int16 v14 = 2082;
    uint64_t v15 = (void *)v6;
    __int16 v16 = 1024;
    LODWORD(v17) = v7;
    int v8 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort()) {
      goto LABEL_18;
    }
    __break(1u);
  }
  uint64_t v9 = *((void *)v1[10].isa + 28);
  if (!v9 || (*(unsigned char *)(v9 + 828) & 2) == 0)
  {
    __nwlog_tcp_log();
    int v10 = v9 ? (char *)(v9 + 604) : "";
    *(_DWORD *)long long buf = 136446466;
    uint64_t v13 = "tcp_release_route_heuristics";
    __int16 v14 = 2082;
    uint64_t v15 = v10;
    int v8 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      char v11 = __nwlog_tcp_log();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446466;
        uint64_t v13 = "tcp_release_route_heuristics";
        __int16 v14 = 2082;
        uint64_t v15 = v10;
        _os_log_impl(&dword_214653000, v11, OS_LOG_TYPE_ERROR, "%{public}s %{public}s tcp get heuristics failed, backtrace limit exceeded", buf, 0x16u);
      }
    }
    if (v8) {
LABEL_18:
    }
      free(v8);
  }
}

void tcp_finalize_options(uint64_t a1, int *a2, uint64_t a3)
{
  int v6 = *a2;
  if (*a2)
  {
    *(_DWORD *)(a1 + 88) |= 0x100u;
    *(_DWORD *)(a1 + 276) = a2[1];
    *(_DWORD *)(a1 + 280) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 316);
    int v6 = *a2;
    if ((*a2 & 0x10) == 0)
    {
LABEL_3:
      int v7 = *(_DWORD *)(a1 + 740);
      if ((v7 & 0x20) == 0) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else if ((v6 & 0x10) == 0)
  {
    goto LABEL_3;
  }
  tcp_mss(a1, *((unsigned __int16 *)a2 + 6), a3);
  int v6 = *a2;
  int v7 = *(_DWORD *)(a1 + 740);
  if ((v7 & 0x20) == 0)
  {
LABEL_4:
    if ((v6 & 0x20) == 0) {
      return;
    }
    goto LABEL_12;
  }
LABEL_8:
  if ((v6 & 0x100) != 0)
  {
    *(_DWORD *)(a1 + 88) |= 0x200u;
    if ((v6 & 0x20) == 0) {
      return;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 740) = v7 & 0xFFFFFFDF;
    if ((v6 & 0x20) == 0) {
      return;
    }
  }
LABEL_12:
  int v8 = *(_DWORD *)(a1 + 88);
  *(_DWORD *)(a1 + 88) = v8 | 0x40;
  *(unsigned char *)(a1 + 263) = *((unsigned char *)a2 + 14);
  if (*(unsigned char *)(a1 + 262)) {
    *(_DWORD *)(a1 + 88) = v8 | 0x60;
  }
}

void tcp_mss(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 80);
  if (*(__int16 *)(*(void *)(v3 + 224) + 376) < 0 || !*(_DWORD *)(a1 + 12)) {
    return;
  }
  char v6 = *(unsigned char *)(v3 + 2236);
  if ((v6 & 2) != 0) {
    int v7 = -60;
  }
  else {
    int v7 = -40;
  }
  uint64_t v8 = *(void *)(a1 + 80);
  if ((*(unsigned char *)(v3 + 2236) & 2) != 0)
  {
    uint64_t v9 = tcp_rtlookup6(v8, a3);
    if (v9) {
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t v9 = tcp_rtlookup(v8, a3);
    if (v9)
    {
LABEL_8:
      uint64_t v10 = *(void *)(v9 + 216);
      if (*(unsigned char *)(v10 + 1076) == 23
        && *(int *)(sysctls + 48) >= 1
        && (*(_DWORD *)(v10 + 1040) - 9601) >> 7 <= 0x39C)
      {
        *(_DWORD *)(a1 + 88) |= 0x80000u;
      }
      uint64_t v11 = *(void *)(v3 + 224);
      int v12 = a2;
      if (a2 == -1)
      {
        uint64_t v16 = *(void *)(v9 + 1488);
        if (v16)
        {
          int v12 = *(_DWORD *)(v16 + 52);
          uint64_t v13 = (int *)sysctls;
          if (!v12)
          {
LABEL_21:
            uint64_t v17 = 38;
            if ((v6 & 2) == 0) {
              uint64_t v17 = 37;
            }
            int v12 = v13[v17];
            goto LABEL_29;
          }
        }
        else
        {
          uint64_t v13 = (int *)sysctls;
          int v12 = -1;
        }
      }
      else
      {
        uint64_t v13 = (int *)sysctls;
        if (!a2) {
          goto LABEL_21;
        }
      }
      if (v12 <= v13[41]) {
        int v12 = v13[41];
      }
      if (v12 <= 64) {
        int v12 = 64;
      }
LABEL_29:
      uint64_t v18 = *(_DWORD **)(v9 + 1488);
      BOOL v19 = v18 == 0;
      if (!v18)
      {
        *(_DWORD *)(a1 + 228) = 30;
        unsigned int v21 = *(_DWORD *)(v10 + 1044);
        goto LABEL_38;
      }
      v18[13] = v12;
      if (*(_DWORD *)(a1 + 200) || (unsigned int v35 = v18[16]) == 0)
      {
        *(_DWORD *)(a1 + 228) = 30;
        goto LABEL_32;
      }
      if (*(_DWORD *)(a1 + 1872) == 1) {
        goto LABEL_32;
      }
      *(_DWORD *)(a1 + 228) = 30;
      unsigned int v36 = v35 / 0x1F;
      *(_DWORD *)(a1 + 200) = v35 / 0x1F;
      uint64_t v37 = *(void *)(a1 + 1056);
      if (v37)
      {
        ++*(void *)(v37 + 1280);
        unsigned int v38 = v18[17];
        if (v38)
        {
          unsigned int v39 = v38 / 0x3E;
          *(_DWORD *)(a1 + 208) = v38 / 0x3E;
          ++*(void *)(v37 + 1288);
LABEL_91:
          if (*(int *)(a1 + 12) < 4) {
            int v48 = 0;
          }
          else {
            int v48 = v13[44];
          }
          signed int v49 = (v39 + (v36 >> 3)) >> 2;
          int v50 = 30;
          if (v49 <= 30) {
            signed int v49 = 30;
          }
          unsigned int v51 = v49 + v48;
          *(_DWORD *)(a1 + 192) = v51;
          if (v51 >= 0x1E)
          {
            if (v51 < 0xFA01) {
              goto LABEL_32;
            }
            int v50 = 64000;
          }
          *(_DWORD *)(a1 + 192) = v50;
LABEL_32:
          unsigned int v20 = v18[12];
          unsigned int v21 = *(_DWORD *)(v10 + 1044);
          if (v20)
          {
            BOOL v19 = 0;
            if (v20 >= v21) {
              int v22 = *(_DWORD *)(v10 + 1044);
            }
            else {
              int v22 = v18[12];
            }
            LODWORD(v23) = v22 + v7;
            goto LABEL_43;
          }
LABEL_38:
          uint64_t v24 = v21 + v7;
          if ((v6 & 2) != 0) {
            uint64_t v23 = v13[38];
          }
          else {
            uint64_t v23 = v13[37];
          }
          if (v24 < v23) {
            LODWORD(v23) = v24;
          }
LABEL_43:
          if (v23 < (uint64_t)v12) {
            int v12 = v23;
          }
          *(_DWORD *)(a1 + 156) = v12;
          if ((*(_DWORD *)(a1 + 88) & 0x100) != 0 || a2 == -1) {
            unsigned int v26 = v12 - 12;
          }
          else {
            unsigned int v26 = v12;
          }
          if ((*(_DWORD *)(a1 + 88) & 0x88) == 0x80) {
            unint64_t v27 = v26;
          }
          else {
            unint64_t v27 = v12;
          }
          *(_DWORD *)(a1 + 196) = v27;
          __int16 v28 = v18 + 14;
          int v29 = (_DWORD *)(v11 + 388);
          if (v19) {
            __int16 v28 = (unsigned int *)(v11 + 388);
          }
          unsigned int v30 = *v28;
          if (v30 <= *(_DWORD *)(v11 + 388)) {
            unsigned int v31 = *(_DWORD *)(v11 + 388);
          }
          else {
            unsigned int v31 = v30;
          }
          unsigned int v32 = v31;
          if (v31 >= v27)
          {
            unsigned int v32 = (v27 + v31 - 1) / v27 * v27;
            if (v32 <= 0x71C71C)
            {
              *(_DWORD *)(v11 + 388) = v32;
              uint64_t v33 = *(void *)(*(void *)(v11 + 456) + 24);
              if ((*(unsigned char *)(v11 + 432) & 4) != 0)
              {
                if (v33)
                {
                  uint64_t all_stats = nw_protocol_tcp_get_all_stats();
                  if (all_stats) {
                    *(_DWORD *)(all_stats + 88) = *v29;
                  }
                }
              }
              else if (v33)
              {
                uint64_t v34 = nw_protocol_tcp_get_all_stats();
                if (v34) {
                  *(_DWORD *)(v34 + 100) = *v29;
                }
              }
              unsigned int v41 = *(_DWORD *)(v11 + 388);
              if (*(_DWORD *)(v11 + 392) > v41) {
                *(_DWORD *)(v11 + 392) = v41;
              }
            }
            unsigned int v31 = v27;
          }
          *(_DWORD *)(a1 + 196) = v31;
          if (!v31)
          {
            BOOL v62 = __nwlog_obj();
            os_log_type_enabled(v62, OS_LOG_TYPE_ERROR);
            int v63 = (void *)_os_log_send_and_compose_impl();
            if (__nwlog_abort())
            {
              __break(1u);
              return;
            }
            free(v63);
          }
          uint64_t v42 = *(void *)(*(void *)v11 + 240);
          if (*(unsigned __int8 *)(v10 + 1076) != 255 && *(_DWORD *)(v10 + 1024) != 255
            || *(int *)(v42 + 12) > 5
            || (*(unsigned char *)(v42 + 91) & 0x20) != 0
            || (*(unsigned char *)(v10 + 9) & 0x80) == 0)
          {
            goto LABEL_108;
          }
          unsigned int v43 = *(_DWORD *)(v42 + 156);
          unsigned int v44 = *(_DWORD *)(v42 + 196) - v43;
          int v45 = *(unsigned __int16 *)(v10 + 72);
          if (v45 == 1200)
          {
            if (v43 <= 0x4B0) {
              goto LABEL_106;
            }
            unsigned int v46 = 1200;
          }
          else
          {
            if (v45 != 512)
            {
              if (*(_WORD *)(v10 + 72)
                || (unsigned int v46 = *(unsigned __int16 *)(v42 + 734), !*(_WORD *)(v42 + 734))
                || v43 >= v46)
              {
LABEL_106:
                *(_DWORD *)(v42 + 196) = v44 + v43;
                if (v43 == *(unsigned __int16 *)(v42 + 734)) {
                  *(_WORD *)(v42 + 734) = 0;
                }
LABEL_108:
                unsigned int v52 = *(_DWORD *)(v11 + 492);
                if (v32 > v52) {
                  unsigned int v52 = v32;
                }
                if (v52 > v31)
                {
                  unsigned int v53 = (v31 + (unint64_t)v52 - 1) / v31 * v31;
                  if (v53 <= 0x71C71C)
                  {
                    *(_DWORD *)(v11 + 492) = v53;
                    uint64_t v54 = *(void *)(*(void *)(v11 + 560) + 24);
                    if ((*(unsigned char *)(v11 + 536) & 4) != 0)
                    {
                      if (v54)
                      {
                        uint64_t v56 = nw_protocol_tcp_get_all_stats();
                        if (v56) {
                          *(_DWORD *)(v56 + 88) = *(_DWORD *)(v11 + 492);
                        }
                      }
                    }
                    else if (v54)
                    {
                      uint64_t v55 = nw_protocol_tcp_get_all_stats();
                      if (v55) {
                        *(_DWORD *)(v55 + 100) = *(_DWORD *)(v11 + 492);
                      }
                    }
                    unsigned int v57 = *(_DWORD *)(v11 + 492);
                    if (*(_DWORD *)(v11 + 496) > v57) {
                      *(_DWORD *)(v11 + 496) = v57;
                    }
                  }
                }
                set_tcp_stream_priority(v11);
                uint64_t v58 = *(void *)(v9 + 1488);
                if (v58 && (unint64_t v59 = *(unsigned int *)(v58 + 60), v59))
                {
                  if (v59 < 2 * (unint64_t)v31) {
                    LODWORD(v59) = 2 * v31;
                  }
                  *(_DWORD *)(a1 + 148) = v59;
                  uint64_t v60 = *(void *)(a1 + 1056);
                  if (v60) {
                    ++*(void *)(v60 + 1296);
                  }
                }
                else
                {
                  *(_DWORD *)(a1 + 148) = 1073725440;
                }
                __int16 v61 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 40);
                if (v61) {
                  v61(a1);
                }
                if (*(_DWORD *)(sysctls + 308) == 1
                  && (~*(_DWORD *)(a1 + 88) & 0x180) == 0
                  && (*(_DWORD *)(sysctls + 40) == 1 || (*(unsigned char *)(v11 + 369) & 0x40) != 0))
                {
                  if (off_26AA46358) {
                    off_26AA46358((_DWORD *)a1);
                  }
                }
                return;
              }
LABEL_105:
              *(_DWORD *)(v42 + 156) = v46;
              unsigned int v43 = v46;
              goto LABEL_106;
            }
            if (v43 < 0x201) {
              goto LABEL_106;
            }
            unsigned int v46 = 512;
          }
          *(_WORD *)(v42 + 734) = v43;
          goto LABEL_105;
        }
      }
      else
      {
        unsigned int v47 = v18[17];
        if (v47)
        {
          unsigned int v39 = v47 / 0x3E;
          *(_DWORD *)(a1 + 208) = v47 / 0x3E;
          goto LABEL_91;
        }
      }
      unsigned int v39 = v35 / 0x3E;
      *(_DWORD *)(a1 + 208) = v39;
      goto LABEL_91;
    }
  }
  uint64_t v14 = 152;
  if ((v6 & 2) == 0) {
    uint64_t v14 = 148;
  }
  int v15 = *(_DWORD *)(sysctls + v14);
  *(_DWORD *)(a1 + 196) = v15;
  *(_DWORD *)(a1 + 156) = v15;
}

uint64_t tcp_rtlookup(uint64_t a1, uint64_t a2)
{
  int v4 = (uint64_t *)(a1 + 496);
  uint64_t v5 = *(void *)(a1 + 496);
  if (v5)
  {
    if ((*(_DWORD *)(v5 + 1480) & 0x2000001) == 1)
    {
LABEL_11:
      uint64_t v7 = *(void *)(a1 + 240);
      if (*(_DWORD *)(sysctls + 80)
        && ((uint64_t v8 = *(void *)(v5 + 1488)) == 0 || (*(unsigned char *)(v5 + 1480) & 1) != 0 && !*(unsigned char *)(v8 + 73)))
      {
        unsigned int v9 = *(_DWORD *)(v7 + 88) | 0x4000000;
      }
      else
      {
        unsigned int v9 = *(_DWORD *)(v7 + 88) & 0xFBFFFFFF;
      }
      *(_DWORD *)(v7 + 88) = v9;
      uint64_t v13 = *(_DWORD **)(v5 + 216);
      if (!v13)
      {
LABEL_36:
        if (*(unsigned char *)(v5 + 1484)) {
          *(_DWORD *)(v7 + 88) |= 0x20000u;
        }
        return v5;
      }
      *(_DWORD *)(v7 + 88) = v9 & 0xEFFFFFFF;
      int v14 = v13[262];
      if ((*(unsigned char *)(*(void *)(v7 + 80) + 2236) & 2) != 0)
      {
        if ((v14 & 0x400000) != 0)
        {
          *(_DWORD *)(v7 + 88) = v9 | 0x10000000;
          int v15 = v13 + 265;
          goto LABEL_26;
        }
      }
      else if ((v14 & 0x200000) != 0)
      {
        *(_DWORD *)(v7 + 88) = v9 | 0x10000000;
        int v15 = v13 + 264;
LABEL_26:
        unsigned int v16 = *v15;
        if (v16 >= 0xFFFF) {
          int v17 = 0xFFFF;
        }
        else {
          int v17 = v16;
        }
        if (v16) {
          int v18 = v17;
        }
        else {
          int v18 = 0xFFFF;
        }
        *(_DWORD *)(v7 + 692) = v18;
      }
      tcp_set_ecn(v7);
      os_unfair_lock_lock((os_unfair_lock_t)(v7 + 1864));
      if (!*(void *)(a1 + 448)) {
        *(void *)(a1 + 448) = *(void *)(v5 + 216);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 1864));
      goto LABEL_36;
    }
    if (*(unsigned char *)(v5 + 1496))
    {
      char v6 = *(void **)(v5 + 1488);
      if (v6)
      {
        free(v6);
        uint64_t v5 = *v4;
        *(void *)(*v4 + 1488) = 0;
      }
      *(unsigned char *)(v5 + 1496) = 0;
    }
  }
  *(_WORD *)(a1 + 2008) = 528;
  *(_DWORD *)(a1 + 2012) = *(_DWORD *)(a1 + 476);
  if ((*(unsigned char *)(a1 + 2229) & 0x40) != 0) {
    a2 = *(unsigned __int16 *)(*(void *)(a1 + 440) + 1072);
  }
  bzero((void *)(a1 + 504), 0x5E0uLL);
  *(_OWORD *)(a1 + 704) = *(_OWORD *)(a1 + 2008);
  *(void *)(a1 + 720) = a1 + 728;
  *(_OWORD *)(a1 + 1768) = 0u;
  *(_DWORD *)(a1 + 1784) = 0;
  *(_WORD *)(a1 + 1800) = 1;
  *(unsigned char *)(a1 + 1804) = 6;
  *(void *)(a1 + 1960) = a1 + 1968;
  *(unsigned char *)(a1 + 1969) = 2;
  *(_DWORD *)(a1 + 1984) = 1;
  *(void *)(a1 + 496) = a1 + 504;
  if (((**(uint64_t (***)(uint64_t *, uint64_t, uint64_t))(a1 + 2136))(v4, a1 + 504, a2) & 0x80000000) != 0)
  {
    *int v4 = 0;
  }
  else
  {
    uint64_t v5 = *v4;
    if (*v4) {
      goto LABEL_11;
    }
  }
  uint64_t v10 = *(void *)(a1 + 240);
  int v11 = *(_DWORD *)(v10 + 88);
  uint64_t v5 = 0;
  if (*(_DWORD *)(sysctls + 80)) {
    unsigned int v12 = v11 | 0x4000000;
  }
  else {
    unsigned int v12 = v11 & 0xFBFFFFFF;
  }
  *(_DWORD *)(v10 + 88) = v12;
  return v5;
}

uint64_t tcp_set_ecn(uint64_t a1)
{
  tcp_do_acc_ecn = network_config_get_tcp_accurate_ecn_enabled();
  tcp_do_l4s = network_config_get_tcp_l4s_enabled();
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 80) + 2136) + 16))(*(void *)(*(void *)(a1 + 80) + 224));
  int v3 = *(_DWORD *)(a1 + 740);
  if ((result & 1) == 0)
  {
    if ((v3 & 0x10000000) != 0
      || (v3 & 0x8000000) == 0 && (*(_DWORD *)(sysctls + 320) != 1 ? (BOOL v5 = tcp_do_acc_ecn == 1) : (BOOL v5 = 1), !v5))
    {
      unsigned int v4 = *(_DWORD *)(a1 + 348) & 0xFFFFEFFF;
      *(_DWORD *)(a1 + 348) = v4;
      goto LABEL_22;
    }
    unsigned int v4 = *(_DWORD *)(a1 + 348) | 0x1000;
    *(_DWORD *)(a1 + 348) = v4;
    if ((v3 & 0x8000000) != 0) {
      goto LABEL_18;
    }
LABEL_13:
    if (*(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1) {
      goto LABEL_22;
    }
    goto LABEL_18;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 348) | 0x1000;
  *(_DWORD *)(a1 + 348) = v4;
  if ((v3 & 0x10000000) != 0) {
    goto LABEL_22;
  }
  if ((v3 & 0x8000000) == 0) {
    goto LABEL_13;
  }
LABEL_18:
  if (*(_DWORD *)(a1 + 360) == 1) {
    *(_DWORD *)(a1 + 360) = 2;
  }
  if (*(_DWORD *)(a1 + 364) == 1) {
    *(_DWORD *)(a1 + 364) = 2;
  }
LABEL_22:
  if ((v4 & 0x1C00) == 0x1000 && *(_DWORD *)(a1 + 112) % 0x64u >= *(_DWORD *)(sysctls + 88))
  {
    if ((v3 & 0x10000000) != 0
      || (v3 & 0x8000000) == 0 && (*(_DWORD *)(sysctls + 320) != 1 ? (BOOL v7 = tcp_do_acc_ecn == 1) : (BOOL v7 = 1), !v7))
    {
      *(_DWORD *)(a1 + 348) = v4 & 0xFFFFEFFF;
    }
  }
  return result;
}

uint64_t nw_proto_tcp_ecn_enabled(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 40);
    if (v1 && *(void *)(v1 + 5208) && *(void *)(v1 + 5216))
    {
      return MEMORY[0x270EF8860]();
    }
    else
    {
      return 1;
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    char v6 = "nw_proto_tcp_ecn_enabled";
    uint64_t v2 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v3 = __nwlog_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        char v6 = "nw_proto_tcp_ecn_enabled";
        _os_log_impl(&dword_214653000, v3, OS_LOG_TYPE_ERROR, "%{public}s called with null so, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v2) {
      free(v2);
    }
    return 0;
  }
}

uint64_t nw_proto_tcp_route_init(uint64_t a1, uint64_t a2)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 1648);
  int v3 = *(unsigned char **)(a1 + 1656);
  uint64_t v4 = *(void *)v3;
  uint64_t v5 = *(void *)(*(void *)v3 + 240);
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)&__n[1] = 136446210;
    *(void *)&__n[5] = "nw_proto_tcp_route_init";
    unsigned int v52 = (void *)_os_log_send_and_compose_impl();
    __src[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault()) {
      goto LABEL_113;
    }
    if (__src[0] == OS_LOG_TYPE_FAULT)
    {
      unsigned int v53 = __nwlog_obj();
      os_log_type_t v54 = __src[0];
      if (!os_log_type_enabled(v53, __src[0])) {
        goto LABEL_113;
      }
      *(_DWORD *)&__n[1] = 136446210;
      *(void *)&__n[5] = "nw_proto_tcp_route_init";
      uint64_t v55 = "%{public}s called with null rt";
    }
    else
    {
      unsigned int v53 = __nwlog_obj();
      os_log_type_t v54 = __src[0];
      if (!os_log_type_enabled(v53, __src[0])) {
        goto LABEL_113;
      }
      *(_DWORD *)&__n[1] = 136446210;
      *(void *)&__n[5] = "nw_proto_tcp_route_init";
      uint64_t v55 = "%{public}s called with null rt, backtrace limit exceeded";
    }
    goto LABEL_112;
  }
  if (!*(void *)(a2 + 216))
  {
    __nwlog_obj();
    *(_DWORD *)&__n[1] = 136446210;
    *(void *)&__n[5] = "nw_proto_tcp_route_init";
    unsigned int v52 = (void *)_os_log_send_and_compose_impl();
    __src[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault()) {
      goto LABEL_113;
    }
    if (__src[0] == OS_LOG_TYPE_FAULT)
    {
      unsigned int v53 = __nwlog_obj();
      os_log_type_t v54 = __src[0];
      if (!os_log_type_enabled(v53, __src[0])) {
        goto LABEL_113;
      }
      *(_DWORD *)&__n[1] = 136446210;
      *(void *)&__n[5] = "nw_proto_tcp_route_init";
      uint64_t v55 = "%{public}s called with null rt->rt_ifp";
    }
    else
    {
      unsigned int v53 = __nwlog_obj();
      os_log_type_t v54 = __src[0];
      if (!os_log_type_enabled(v53, __src[0])) {
        goto LABEL_113;
      }
      *(_DWORD *)&__n[1] = 136446210;
      *(void *)&__n[5] = "nw_proto_tcp_route_init";
      uint64_t v55 = "%{public}s called with null rt->rt_ifp, backtrace limit exceeded";
    }
LABEL_112:
    _os_log_impl(&dword_214653000, v53, v54, v55, &__n[1], 0xCu);
LABEL_113:
    if (v52) {
      free(v52);
    }
    return 0xFFFFFFFFLL;
  }
  int v7 = *(_DWORD *)(v4 + 492);
  nw_protocol_upcast();
  if (!nw_protocol_get_input_handler())
  {
    if ((v3[828] & 2) != 0) {
      return 0xFFFFFFFFLL;
    }
    int v14 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)&__n[1] = 136446466;
    *(void *)&__n[5] = "nw_proto_tcp_route_init";
    __int16 v64 = 2082;
    uint64_t v65 = (uint64_t)(v3 + 604);
    int v15 = "%{public}s %{public}s no input handler";
    goto LABEL_22;
  }
  if (!*(void *)(v2 + 5208))
  {
    if ((v3[828] & 2) != 0) {
      return 0xFFFFFFFFLL;
    }
    int v14 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)&__n[1] = 136446466;
    *(void *)&__n[5] = "nw_proto_tcp_route_init";
    __int16 v64 = 2082;
    uint64_t v65 = (uint64_t)(v3 + 604);
    int v15 = "%{public}s %{public}s no path from input_handler received";
LABEL_22:
    _os_log_impl(&dword_214653000, v14, OS_LOG_TYPE_ERROR, v15, &__n[1], 0x16u);
    return 0xFFFFFFFFLL;
  }
  int mtu = nw_path_get_mtu();
  if (!mtu)
  {
    if ((v3[828] & 2) == 0)
    {
      int v14 = __nwlog_tcp_log();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)&__n[1] = 136446466;
        *(void *)&__n[5] = "nw_proto_tcp_route_init";
        __int16 v64 = 2082;
        uint64_t v65 = (uint64_t)(v3 + 604);
        int v15 = "%{public}s %{public}s no mtu received";
        goto LABEL_22;
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v9 = mtu;
  *(_DWORD *)(*(void *)(a2 + 216) + 1044) = mtu;
  tso_max_segment_size_uint64_t v4 = nw_path_get_tso_max_segment_size_v4();
  uint64_t v11 = *(void *)(a2 + 216);
  *(_DWORD *)(v11 + 1056) = tso_max_segment_size_v4;
  if (tso_max_segment_size_v4) {
    *(_DWORD *)(v11 + 1048) |= 0x200000u;
  }
  tso_max_segment_size_char v6 = nw_path_get_tso_max_segment_size_v6();
  uint64_t v13 = *(void *)(a2 + 216);
  *(_DWORD *)(v13 + 1060) = tso_max_segment_size_v6;
  if (tso_max_segment_size_v6) {
    *(_DWORD *)(v13 + 1048) |= 0x400000u;
  }
  *(_DWORD *)(*(void *)(a2 + 216) + 1048) |= nw_path_get_csum_flags();
  if ((*(unsigned char *)(v4 + 2236) & 2) != 0)
  {
    if (!nw_path_get_ipv6_network_signature()) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  if (nw_path_get_ipv4_network_signature())
  {
LABEL_24:
    memcpy((void *)(*(void *)(a2 + 216) + 1078), __src, 0x14uLL);
    *(unsigned char *)(*(void *)(a2 + 216) + 1077) = 20;
  }
LABEL_25:
  int interface_index = nw_path_get_interface_index();
  *(_WORD *)(*(void *)(a2 + 216) + 1072) = interface_index;
  uint64_t v17 = *(void *)(v4 + 240);
  uint64_t heuristics = tcp_get_heuristics(*(void *)(v17 + 80), 1);
  if (!heuristics)
  {
    int v62 = v9;
    uint64_t v28 = *(void *)(*(void *)(v17 + 80) + 224);
    if (!v28 || (*(unsigned char *)(v28 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v58 = __nwlog_tcp_log();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
        {
          unint64_t v59 = "";
          if (v28) {
            unint64_t v59 = (const char *)(v28 + 604);
          }
          *(_DWORD *)&__n[1] = 136446466;
          *(void *)&__n[5] = "tcp_get_route_heuristics";
          __int16 v64 = 2082;
          uint64_t v65 = (uint64_t)v59;
          _os_log_impl(&dword_214653000, v58, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s tcp get heuristics failed", &__n[1], 0x16u);
        }
      }
    }
    *(void *)(a2 + 1488) = 0;
    unsigned int v26 = malloc_type_calloc(1uLL, 0x4CuLL, 0xEAFB8F1AuLL);
    if (!v26)
    {
      uint64_t v56 = __nwlog_obj();
      os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
      *(_DWORD *)&__n[1] = 136446722;
      *(void *)&__n[5] = "strict_calloc";
      __int16 v64 = 2048;
      uint64_t v65 = 1;
      __int16 v66 = 2048;
      *(void *)unsigned int v67 = 76;
      unsigned int v57 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = __nwlog_abort();
      if (result) {
        goto LABEL_123;
      }
      free(v57);
      unsigned int v26 = 0;
    }
    unint64_t v27 = (void *)(a2 + 1488);
    *(void *)(a2 + 1488) = v26;
    *(unsigned char *)(a2 + 1496) = 1;
    int v9 = v62;
    goto LABEL_39;
  }
  uint64_t v19 = heuristics;
  int v20 = *(_DWORD *)(heuristics + 148);
  *(_DWORD *)(heuristics + 148) = v20 + 1;
  if ((v20 & 0x80000000) == 0) {
    goto LABEL_33;
  }
  uint64_t v21 = *(void *)(*(void *)(v17 + 80) + 224);
  if (v21)
  {
    if ((*(unsigned char *)(v21 + 828) & 2) != 0) {
      goto LABEL_33;
    }
  }
  int v61 = v9;
  int v22 = __nwlog_tcp_log();
  os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
  uint64_t v23 = (const char *)(v21 + 604);
  int v24 = *(_DWORD *)(v19 + 148);
  *(_DWORD *)&__n[1] = 136446722;
  *(void *)&__n[5] = "tcp_get_route_heuristics";
  if (!v21) {
    uint64_t v23 = "";
  }
  __int16 v64 = 2082;
  uint64_t v65 = (uint64_t)v23;
  __int16 v66 = 1024;
  *(_DWORD *)unsigned int v67 = v24;
  uint64_t v25 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (result)
  {
LABEL_123:
    __break(1u);
    return result;
  }
  free(v25);
  int v9 = v61;
LABEL_33:
  unsigned int v26 = (_DWORD *)(v19 + 68);
  unint64_t v27 = (void *)(a2 + 1488);
  *(void *)(a2 + 1488) = v26;
LABEL_39:
  *(_DWORD *)(v5 + 1872) = 1;
  if (*(_DWORD *)(sysctls + 256))
  {
    if (v26[16])
    {
      *(_DWORD *)(v5 + 1872) = 2;
    }
    else
    {
      *(_DWORD *)&__n[1] = 0;
      nw_path_get_rtt_values();
      unsigned int v26 = (_DWORD *)*v27;
    }
  }
  if (!v26[12]) {
    v26[12] = v9;
  }
  *(_DWORD *)(a2 + 1328) = 528;
  *(_DWORD *)(a2 + 1332) = v7;
  *(void *)(a2 + 1336) = 0;
  uint64_t v29 = *(void *)(a2 + 216);
  int v30 = *(_DWORD *)(v29 + 1048);
  if (((v30 & 0x400020) == 0 && (*(unsigned char *)(v4 + 2236) & 2) != 0
     || (v30 & 0x200002) == 0 && (*(unsigned char *)(v4 + 2236) & 1) != 0)
    && (int partial_checksum_offload = nw_path_flow_registration_get_partial_checksum_offload(),
        uint64_t v29 = *(void *)(a2 + 216),
        int v30 = *(_DWORD *)(v29 + 1048),
        partial_checksum_offload))
  {
    unsigned int v32 = v30 | 0x1000;
  }
  else
  {
    unsigned int v32 = v30 & 0xFFFFEFFF;
  }
  *(_DWORD *)(v29 + 1048) = v32;
  if ((nw_path_is_local() & 1) != 0 || nw_path_is_direct()) {
    *(unsigned char *)(a2 + 1484) = 1;
  }
  uint64_t v33 = nw_path_copy_direct_interface();
  if (v33)
  {
    uint64_t v34 = v33;
    switch(nw_interface_get_type(v33))
    {
      case nw_interface_type_other:
        *(unsigned char *)(*(void *)(a2 + 216) + 1076) = 1;
        break;
      case nw_interface_type_wifi:
        uint64_t v35 = *(void *)(a2 + 216);
        *(unsigned char *)(v35 + 1076) = 6;
        *(void *)(v35 + 1064) = 0x300000002;
        break;
      case nw_interface_type_cellular:
        uint64_t v36 = *(void *)(a2 + 216);
        *(unsigned char *)(v36 + 1076) = -1;
        int v37 = 15;
        goto LABEL_63;
      case nw_interface_type_wired:
        uint64_t v36 = *(void *)(a2 + 216);
        char v38 = 6;
        goto LABEL_62;
      case nw_interface_type_loopback:
        uint64_t v36 = *(void *)(a2 + 216);
        char v38 = 24;
LABEL_62:
        *(unsigned char *)(v36 + 1076) = v38;
        int v37 = 2;
LABEL_63:
        *(_DWORD *)(v36 + 1064) = v37;
        break;
      default:
        break;
    }
    if (nw_interface_get_subtype() == 1002) {
      *(_DWORD *)(*(void *)(a2 + 216) + 1052) |= 0x100000u;
    }
    if (nw_interface_supports_tx_start()) {
      *(_DWORD *)(*(void *)(a2 + 216) + 1052) |= 0x80u;
    }
    if ((nw_interface_supports_ack_priority() & 1) == 0) {
      *(_DWORD *)(*(void *)(a2 + 216) + 1052) |= 0x200000u;
    }
    if (nw_interface_supports_carrier_aggregation()) {
      *(_DWORD *)(*(void *)(a2 + 216) + 1052) |= 0x8000000u;
    }
    nw_release(v34);
  }
  unsigned int v39 = nw_path_copy_delegate_interface();
  if (v39)
  {
    __int16 v40 = v39;
    switch(nw_interface_get_type(v39))
    {
      case nw_interface_type_other:
        *(_DWORD *)(*(void *)(a2 + 216) + 1024) = 1;
        break;
      case nw_interface_type_wifi:
        uint64_t v41 = *(void *)(a2 + 216);
        *(_DWORD *)(v41 + 1032) = 3;
        *(void *)(v41 + 1024) = 0x200000006;
        break;
      case nw_interface_type_cellular:
        uint64_t v42 = *(void *)(a2 + 216);
        uint64_t v43 = 0xF000000FFLL;
        goto LABEL_80;
      case nw_interface_type_wired:
        uint64_t v42 = *(void *)(a2 + 216);
        uint64_t v43 = 0x200000006;
        goto LABEL_80;
      case nw_interface_type_loopback:
        uint64_t v42 = *(void *)(a2 + 216);
        uint64_t v43 = 0x200000018;
LABEL_80:
        *(void *)(v42 + 1024) = v43;
        break;
      default:
        break;
    }
    nw_release(v40);
  }
  uint64_t v44 = *(void *)(a2 + 216);
  if (v44 && (*(unsigned __int8 *)(v44 + 1076) == 255 || *(_DWORD *)(v44 + 1024) == 255))
  {
    __int16 recommended_mss = nw_path_get_recommended_mss();
    uint64_t v46 = *(void *)(a2 + 216);
    *(_DWORD *)(v46 + 8) |= 0x8000u;
    *(_WORD *)(v46 + 72) = recommended_mss;
  }
  if (nw_path_should_probe_connectivity())
  {
    if ((v3[828] & 2) == 0)
    {
      unsigned int v47 = __nwlog_tcp_log();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)&__n[1] = 136446466;
        *(void *)&__n[5] = "nw_proto_tcp_route_init";
        __int16 v64 = 2082;
        uint64_t v65 = (uint64_t)(v3 + 604);
        _os_log_impl(&dword_214653000, v47, OS_LOG_TYPE_INFO, "%{public}s %{public}s probe connectivity enabled", &__n[1], 0x16u);
      }
    }
    *(_DWORD *)(v2 + 5308) |= 0x10u;
    *(_DWORD *)(*(void *)(a2 + 216) + 1052) |= 8u;
    if (*(void *)(*(void *)(v4 + 224) + 24))
    {
      uint64_t all_stats = nw_protocol_tcp_get_all_stats();
      if (all_stats) {
        *(unsigned char *)(all_stats + 96) |= 1u;
      }
    }
  }
  if ((v3[828] & 2) != 0) {
    return 0;
  }
  uint64_t result = __nwlog_is_datapath_logging_enabled();
  if (result)
  {
    signed int v49 = __nwlog_tcp_log();
    uint64_t result = os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG);
    if (result)
    {
      int v50 = *(_DWORD *)(*(void *)(a2 + 1488) + 48);
      int v51 = *(_DWORD *)(*(void *)(a2 + 216) + 1048);
      *(_DWORD *)&__n[1] = 136447234;
      *(void *)&__n[5] = "nw_proto_tcp_route_init";
      __int16 v64 = 2082;
      uint64_t v65 = (uint64_t)(v3 + 604);
      __int16 v66 = 1024;
      *(_DWORD *)unsigned int v67 = v50;
      *(_WORD *)&v67[4] = 1024;
      *(_DWORD *)&v67[6] = interface_index;
      __int16 v68 = 1024;
      int v69 = v51;
      _os_log_impl(&dword_214653000, v49, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s got mtu %d, ifindex %d, offloads %#x", &__n[1], 0x28u);
      return 0;
    }
  }
  return result;
}

uint64_t tcp_get_heuristics(uint64_t a1, int a2)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  uint64_t result = nw_tcp_access_globals(*(void *)(a1 + 224));
  if (!result) {
    return result;
  }
  uint64_t v5 = result;
  if (!*(void *)(result + 32)) {
    return 0;
  }
  memset(v26, 0, 60);
  uint64_t v6 = *(void *)(*(void *)(a1 + 496) + 216);
  DWORD1(v26[3]) = *(unsigned __int16 *)(v6 + 1072);
  if ((*(unsigned char *)(a1 + 2236) & 2) != 0)
  {
    BYTE8(v26[3]) = 30;
    if (*(unsigned __int8 *)(v6 + 1077) - 1 <= 0x12) {
      __memcpy_chk();
    }
    long long v8 = *(_OWORD *)(a1 + 464);
    *(_OWORD *)((char *)&v26[1] + 4) = *(_OWORD *)(a1 + 480);
    *(_OWORD *)((char *)&v26[2] + 4) = v8;
  }
  else
  {
    BYTE8(v26[3]) = 2;
    if (*(unsigned __int8 *)(v6 + 1077) - 1 <= 0x12) {
      __memcpy_chk();
    }
    int v7 = *(_DWORD *)(a1 + 476);
    DWORD1(v26[1]) = *(_DWORD *)(a1 + 492);
    DWORD1(v26[2]) = v7;
  }
  uint64_t v9 = ((unsigned int (*)(_OWORD *, uint64_t, void))*MEMORY[0x263F144D8])(v26, 60, *(unsigned int *)(v5 + 312))% 0x64;
  uint64_t v10 = *(void *)(v5 + 32);
  uint64_t result = *(void *)(v10 + 8 * v9);
  if (!result)
  {
    if (a2)
    {
LABEL_49:
      unsigned int v12 = malloc_type_calloc(1uLL, 0x98uLL, 0xEAFB8F1AuLL);
      if (!v12)
      {
        int v24 = __nwlog_obj();
        os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
        int v27 = 136446722;
        uint64_t v28 = "strict_calloc";
        __int16 v29 = 2048;
        uint64_t v30 = 1;
        __int16 v31 = 2048;
        uint64_t v32 = 152;
        uint64_t v25 = (void *)_os_log_send_and_compose_impl();
        uint64_t result = __nwlog_abort();
        if (result)
        {
          __break(1u);
          return result;
        }
        free(v25);
        unsigned int v12 = 0;
      }
      *(void *)unsigned int v12 = *(void *)(v10 + 8 * v9);
      *(void *)(v10 + 8 * v9) = v12;
      goto LABEL_51;
    }
    return 0;
  }
  unsigned int v11 = 0;
  unsigned int v12 = 0;
  unsigned int v13 = -1;
  do
  {
    if (*(void *)(result + 8) == *(void *)&v26[0]
      && *(void *)(result + 16) == *((void *)&v26[0] + 1)
      && *(void *)(result + 24) == *(void *)&v26[1]
      && *(void *)(result + 32) == *((void *)&v26[1] + 1)
      && *(void *)(result + 40) == *(void *)&v26[2]
      && *(void *)(result + 48) == *((void *)&v26[2] + 1)
      && *(void *)(result + 56) == *(void *)&v26[3]
      && *(_DWORD *)(result + 64) == (unint64_t)DWORD2(v26[3]))
    {
      if (!*(_DWORD *)(result + 148) && (*(_DWORD *)(v5 + 316) - *(_DWORD *)(result + 144)) >= 0xE10)
      {
        *(_OWORD *)(result + 128) = 0u;
        *(_OWORD *)(result + 116) = 0u;
        *(_OWORD *)(result + 100) = 0u;
        *(_OWORD *)(result + 84) = 0u;
        *(_OWORD *)(result + 68) = 0u;
      }
      goto LABEL_52;
    }
    if (!*(_DWORD *)(result + 148) && *(_DWORD *)(v5 + 316) - *(_DWORD *)(result + 144) > v11)
    {
      unsigned int v12 = (_OWORD *)result;
      unsigned int v11 = *(_DWORD *)(v5 + 316) - *(_DWORD *)(result + 144);
    }
    uint64_t result = *(void *)result;
    ++v13;
  }
  while (result);
  if (!a2) {
    return 0;
  }
  if (v13 < 9) {
    goto LABEL_49;
  }
  if (!v12) {
    return 0;
  }
  v12[8] = 0u;
  *(_OWORD *)((char *)v12 + 116) = 0u;
  *(_OWORD *)((char *)v12 + 100) = 0u;
  *(_OWORD *)((char *)v12 + 84) = 0u;
  *(_OWORD *)((char *)v12 + 68) = 0u;
LABEL_51:
  long long v21 = v26[0];
  long long v22 = v26[1];
  long long v23 = v26[2];
  *(_OWORD *)((char *)v12 + 52) = *(_OWORD *)((char *)&v26[2] + 12);
  *(_OWORD *)((char *)v12 + 40) = v23;
  *(_OWORD *)((char *)v12 + 24) = v22;
  *(_OWORD *)((char *)v12 + 8) = v21;
  uint64_t result = (uint64_t)v12;
LABEL_52:
  *(_DWORD *)(result + 144) = *(_DWORD *)(v5 + 316);
  return result;
}

void tcp_cubic_cwnd_init_or_reset(uint64_t a1)
{
  uint64_t v2 = *(_DWORD **)(a1 + 840);
  if (!v2)
  {
    uint64_t v10 = __nwlog_obj();
    os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    unsigned int v11 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }
    free(v11);
    uint64_t v2 = *(_DWORD **)(a1 + 840);
  }
  _DWORD *v2 = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 4) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 8) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 12) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 16) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 28) = 0;
  int v3 = (_DWORD *)sysctls;
  if (*(_DWORD *)(sysctls + 276))
  {
    if (*(_DWORD *)(sysctls + 304)) {
      int v4 = *(_DWORD *)(sysctls + 16);
    }
    else {
      int v4 = 10;
    }
    LODWORD(v5) = *(_DWORD *)(a1 + 196);
    LODWORD(v6) = v5 * v4;
  }
  else
  {
    uint64_t v5 = *(unsigned int *)(a1 + 196);
    LODWORD(v6) = 2 * v5;
    if (v5 <= 0x88E) {
      unint64_t v6 = 4380;
    }
    else {
      unint64_t v6 = v6;
    }
    if (v6 > 4 * v5) {
      LODWORD(v6) = 4 * v5;
    }
  }
  *(_DWORD *)(a1 + 144) = v6;
  *(void *)(a1 + 980) = 0;
  *(_DWORD *)(a1 + 972) = 0;
  *(void *)(a1 + 964) = 0;
  *(unsigned char *)(a1 + 751) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  if (v3[76])
  {
    int v7 = v3[4];
  }
  else
  {
    if (!v3[69])
    {
      unint64_t v8 = 4380;
      goto LABEL_18;
    }
    int v7 = 10;
  }
  unint64_t v8 = (v5 * v7);
LABEL_18:
  unsigned int v9 = *(_DWORD *)(a1 + 148);
  if (*(void *)(*(void *)(*(void *)(a1 + 80) + 248) + 24) <= v8 && v9 <= 0x3FFFBFFF)
  {
    unsigned int v9 = 1073725440;
    *(_DWORD *)(a1 + 148) = 1073725440;
  }
  **(_DWORD **)(a1 + 840) = v9;
}

uint64_t nw_protocol_tcp_create()
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (nw_protocol_tcp_identifier_onceToken != -1) {
    dispatch_once(&nw_protocol_tcp_identifier_onceToken, &__block_literal_global);
  }
  if (nw_protocol_tcp_callbacks_onceToken != -1) {
    dispatch_once(&nw_protocol_tcp_callbacks_onceToken, &__block_literal_global_10);
  }
  uint64_t v0 = nw_protocol_new();
  if (v0)
  {
    uint64_t v1 = v0;
    if (nw_protocol_tcp_initialize_globals_onceToken != -1) {
      dispatch_once(&nw_protocol_tcp_initialize_globals_onceToken, &__block_literal_global_35);
    }
    *(_DWORD *)(v1 + 5264) = 0;
    MEMORY[0x2166A6260](v1 + 5184);
    *(void *)(v1 + 5232) = nw_tcp_create_metadata();
    *(void *)&long long buf = nw_protocol_tcp_get_receive_buffer_size;
    *((void *)&buf + 1) = nw_protocol_tcp_get_send_buffer_size;
    unint64_t v6 = nw_protocol_tcp_reset_keepalives;
    int v7 = nw_protocol_tcp_set_no_delay;
    unint64_t v8 = nw_protocol_tcp_set_no_push;
    unsigned int v9 = nw_protocol_tcp_set_no_wake_from_sleep;
    nw_tcp_set_callbacks();
    return nw_protocol_upcast();
  }
  else
  {
    __nwlog_obj();
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = "__nw_protocol_tcp_create";
    int v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = "__nw_protocol_tcp_create";
        _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_ERROR, "%{public}s nw_protocol_tcp_obj_alloc failed, backtrace limit exceeded", (uint8_t *)&buf, 0xCu);
      }
    }
    if (v3) {
      free(v3);
    }
    return 0;
  }
}

uint64_t nw_protocol_tcp_wake_read_closed(uint64_t a1)
{
  return nw_queue_context_async();
}

void tcp_close(uint64_t a1)
{
  uint64_t v107 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)(a1 + 80);
  if (!*(void *)(v1 + 240)) {
    return;
  }
  uint64_t v3 = *(void *)(v1 + 224);
  char v4 = *(unsigned char *)(v1 + 2236);
  tcp_canceltimers(a1);
  int v5 = *(_DWORD *)(a1 + 88);
  if ((v5 & 0x8000000) != 0 || *(unsigned char *)(v1 + 2238))
  {
    *(_DWORD *)(a1 + 88) = v5 | 0x8000000;
    return;
  }
  if (!v3 || (*(unsigned char *)(v3 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      unsigned __int16 v84 = __nwlog_tcp_log();
      if (os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v85 = tcpstates[*(int *)(a1 + 12)];
        *(void *)&uint8_t buf[4] = "tcp_close";
        unsigned int v86 = "";
        *(_DWORD *)long long buf = 136446722;
        if (v3) {
          unsigned int v86 = (const char *)(v3 + 604);
        }
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v86;
        *(_WORD *)&unsigned char buf[22] = 2082;
        int v103 = v85;
        _os_log_impl(&dword_214653000, v84, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state is %{public}s", buf, 0x20u);
      }
    }
  }
  uint64_t v6 = *(void *)(v1 + 496);
  if (!v6)
  {
    if ((v4 & 2) != 0) {
      goto LABEL_62;
    }
    goto LABEL_15;
  }
  if ((v4 & 2) != 0)
  {
    if (!*(_DWORD *)(v6 + 208) && !*(_DWORD *)(v6 + 212) && !*(_DWORD *)(v6 + 216) && !*(_DWORD *)(v6 + 220)) {
      goto LABEL_62;
    }
LABEL_25:
    unint64_t v8 = *(_DWORD **)(v6 + 1488);
    if (!v8) {
      goto LABEL_62;
    }
    if (*(unsigned char *)(v6 + 1496))
    {
      free(v8);
      *(void *)(v6 + 1488) = 0;
      *(unsigned char *)(v6 + 1496) = 0;
      goto LABEL_62;
    }
    int v9 = *(_DWORD *)(a1 + 200);
    int v10 = 31 * v9;
    int v11 = v8[16];
    if (v9) {
      BOOL v12 = v11 == 0;
    }
    else {
      BOOL v12 = 1;
    }
    unsigned int v13 = (v11 + v10) >> 1;
    if (v12) {
      unsigned int v13 = v10;
    }
    v8[16] = v13;
    int v14 = *(void **)(a1 + 1056);
    if (v14) {
      ++v14[54];
    }
    int v15 = *(_DWORD *)(a1 + 208);
    int v16 = 62 * v15;
    int v17 = v8[17];
    if (v15) {
      BOOL v18 = v17 == 0;
    }
    else {
      BOOL v18 = 1;
    }
    unsigned int v19 = (v17 + v16) >> 1;
    if (v18) {
      unsigned int v19 = v16;
    }
    v8[17] = v19;
    if (v14) {
      ++v14[55];
    }
    unsigned int v20 = *(_DWORD *)(a1 + 148);
    unsigned int v21 = v8[14];
    if (!v21) {
      unsigned int v21 = *(_DWORD *)(v3 + 388);
    }
    unsigned int v22 = v21 >> 1;
    if (v20)
    {
      int v23 = v8[15];
      if (v23 || v20 < v22) {
        goto LABEL_52;
      }
    }
    else if (v22)
    {
      int v23 = v8[15];
LABEL_52:
      unsigned int v24 = *(_DWORD *)(a1 + 196);
      unsigned int v25 = (v20 + (v24 >> 1)) / v24;
      if (v25 <= 2) {
        unsigned int v25 = 2;
      }
      if ((v4 & 2) != 0) {
        int v26 = 60;
      }
      else {
        int v26 = 40;
      }
      unsigned int v27 = v25 * (v24 + v26);
      if (v23) {
        unsigned int v27 = (v27 + v23) >> 1;
      }
      v8[15] = v27;
      if (v14) {
        ++v14[56];
      }
    }
    *(_DWORD *)(a1 + 1964) = v8[10];
    tcp_release_route_heuristics(a1);
    *(void *)(v6 + 1488) = 0;
    goto LABEL_62;
  }
  if ((*(_DWORD *)(v6 + 1480) & 0x2000001) == 1 && *(_DWORD *)(v6 + 204)) {
    goto LABEL_25;
  }
LABEL_15:
  *(_DWORD *)(a1 + 12) = 0;
  if (!v3 || (*(unsigned char *)(v3 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      uint64_t v89 = __nwlog_tcp_log();
      if (os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG))
      {
        int v90 = tcpstates[*(int *)(a1 + 12)];
        *(void *)&uint8_t buf[4] = "tcp_close";
        int v91 = "";
        *(_DWORD *)long long buf = 136446722;
        if (v3) {
          int v91 = (const char *)(v3 + 604);
        }
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v91;
        *(_WORD *)&unsigned char buf[22] = 2082;
        int v103 = v90;
        _os_log_impl(&dword_214653000, v89, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", buf, 0x20u);
      }
    }
  }
  if (*(void *)(v3 + 24))
  {
    uint64_t all_stats = nw_protocol_tcp_get_all_stats();
    if (all_stats) {
      *(_DWORD *)(all_stats + 136) = 0;
    }
  }
LABEL_62:
  if (*(unsigned char *)(v1 + 2000) && (!v3 || (*(unsigned char *)(v3 + 828) & 2) == 0))
  {
    uint64_t v28 = __nwlog_tcp_log();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      __int16 v29 = "";
      if (v3) {
        __int16 v29 = (const char *)(v3 + 604);
      }
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "tcp_close";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v29;
      _os_log_impl(&dword_214653000, v28, OS_LOG_TYPE_ERROR, "%{public}s %{public}s rt_heur rt_heur_alloc unexpectly set", buf, 0x16u);
    }
  }
  uint64_t v30 = *(uint64_t **)a1;
  if (*(void *)a1)
  {
    while (1)
    {
      uint64_t v31 = *v30;
      if (*v30) {
        *(void *)(v31 + 8) = v30[1];
      }
      *(void *)v30[1] = v31;
      uint64_t v32 = (void *)v30[4];
      if (v32) {
        break;
      }
LABEL_71:
      nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
      free(v30);
      uint64_t v30 = *(uint64_t **)a1;
      if (!*(void *)a1) {
        goto LABEL_89;
      }
    }
    while (1)
    {
      while (1)
      {
        uint64_t v33 = (void (*)(void *, uint64_t, uint64_t))v32[10];
        uint64_t v34 = (void *)v32[4];
        if (!v33) {
          break;
        }
        uint64_t v35 = v32[11];
        v32[10] = 0;
        v32[11] = 0;
        v33(v32, 1, v35);
        uint64_t v32 = v34;
        if (!v34) {
          goto LABEL_71;
        }
      }
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
      uint64_t v36 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      if (!__nwlog_fault()) {
        goto LABEL_85;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        int v37 = __nwlog_obj();
        if (os_log_type_enabled(v37, type[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          char v38 = v37;
          os_log_type_t v39 = type[0];
          __int16 v40 = "%{public}s called with null frame->finalizer";
LABEL_84:
          _os_log_impl(&dword_214653000, v38, v39, v40, buf, 0xCu);
        }
      }
      else
      {
        uint64_t v41 = __nwlog_obj();
        if (os_log_type_enabled(v41, type[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          char v38 = v41;
          os_log_type_t v39 = type[0];
          __int16 v40 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
          goto LABEL_84;
        }
      }
LABEL_85:
      if (v36) {
        free(v36);
      }
      uint64_t v32 = v34;
      if (!v34) {
        goto LABEL_71;
      }
    }
  }
LABEL_89:
  *(_WORD *)(a1 + 224) = 0;
  uint64_t v42 = *(void *)(a1 + 80);
  uint64_t v43 = *(void *)(v42 + 224);
  if (!*(void *)(v43 + 24))
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_flow_registration";
    uint64_t v80 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault()) {
      goto LABEL_194;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v81 = __nwlog_obj();
      os_log_type_t v82 = type[0];
      if (!os_log_type_enabled(v81, type[0])) {
        goto LABEL_194;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_flow_registration";
      unsigned int v83 = "%{public}s called with null protocol";
    }
    else
    {
      uint64_t v81 = __nwlog_obj();
      os_log_type_t v82 = type[0];
      if (!os_log_type_enabled(v81, type[0])) {
        goto LABEL_194;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_flow_registration";
      unsigned int v83 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_193:
    _os_log_impl(&dword_214653000, v81, v82, v83, buf, 0xCu);
    goto LABEL_194;
  }
  uint64_t v44 = nw_protocol_downcast();
  if (v44)
  {
    int v45 = nw_retain(*(void **)(v44 + 5216));
    if (v45)
    {
      uint64_t v46 = v45;
      *(void *)long long buf = MEMORY[0x263EF8330];
      *(void *)&buf[8] = 0x40000000;
      *(void *)&buf[16] = __tcp_publish_necp_if_stats_block_invoke;
      int v103 = (char *)&__block_descriptor_tmp_15_104;
      uint64_t v104 = v42;
      uint64_t v105 = a1;
      uint64_t v106 = v43;
      nw_path_flow_registration_access_interface_stats();
      nw_release(v46);
    }
    goto LABEL_93;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_flow_registration";
  uint64_t v80 = (void *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  if (__nwlog_fault())
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v81 = __nwlog_obj();
      os_log_type_t v82 = type[0];
      if (!os_log_type_enabled(v81, type[0])) {
        goto LABEL_194;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_flow_registration";
      unsigned int v83 = "%{public}s called with null tcp";
    }
    else
    {
      uint64_t v81 = __nwlog_obj();
      os_log_type_t v82 = type[0];
      if (!os_log_type_enabled(v81, type[0])) {
        goto LABEL_194;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_flow_registration";
      unsigned int v83 = "%{public}s called with null tcp, backtrace limit exceeded";
    }
    goto LABEL_193;
  }
LABEL_194:
  if (v80) {
    free(v80);
  }
LABEL_93:
  for (uint64_t i = *(void **)(a1 + 544); i; uint64_t i = *(void **)(a1 + 544))
  {
    uint64_t v49 = i[2];
    if (*(void **)(a1 + 616) == i)
    {
      *(void *)(a1 + 616) = v49;
      int v48 = (void *)i[3];
      if (!v49) {
        goto LABEL_100;
      }
    }
    else
    {
      int v48 = (void *)i[3];
      if (!v49)
      {
LABEL_100:
        *(void *)(a1 + 552) = v48;
        goto LABEL_97;
      }
    }
    *(void *)(v49 + 24) = v48;
    int v48 = (void *)i[3];
LABEL_97:
    *int v48 = v49;
    nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
    free(i);
    --*(_WORD *)(a1 + 538);
    atomic_fetch_add_explicit(tcp_sack_globalholes, 0xFFFFFFFF, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 616) = 0u;
  int v50 = *(void **)(a1 + 1032);
  if (v50)
  {
    int v51 = (void *)(a1 + 1032);
    do
    {
      unsigned int v53 = (void *)*v51;
      os_log_type_t v54 = (void *)(a1 + 1032);
      if ((void *)*v51 != v50)
      {
        do
        {
          uint64_t v55 = v53;
          unsigned int v53 = (void *)v53[1];
        }
        while (v53 != v50);
        os_log_type_t v54 = v55 + 1;
      }
      unsigned int v52 = (void *)v50[1];
      *os_log_type_t v54 = v52;
      free(v50);
      int v50 = v52;
    }
    while (v52);
    *(void *)(a1 + 1032) = 0;
    *(unsigned char *)(a1 + 732) = 0;
  }
  if (*(void *)(a1 + 768)) {
    *(_DWORD *)(a1 + 740) &= 0xFFFFFFF3;
  }
  uint64_t v56 = *(void **)(a1 + 952);
  if (v56)
  {
    unsigned int v57 = (void *)(a1 + 952);
    do
    {
      unint64_t v59 = (void *)*v57;
      uint64_t v60 = (void *)(a1 + 952);
      if ((void *)*v57 != v56)
      {
        do
        {
          int v61 = v59;
          unint64_t v59 = (void *)v59[2];
        }
        while (v59 != v56);
        uint64_t v60 = v61 + 2;
      }
      uint64_t v58 = (void *)v56[2];
      *uint64_t v60 = v58;
      nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
      free(v56);
      uint64_t v56 = v58;
    }
    while (v58);
  }
  *(_DWORD *)(a1 + 960) = *(_DWORD *)(a1 + 96);
  tcp_segs_sent_clean(a1, 1);
  if (!*(void *)(a1 + 632) || v3 && (*(unsigned char *)(v3 + 828) & 2) != 0) {
    goto LABEL_131;
  }
  __nwlog_tcp_log();
  if (v3) {
    int v62 = (const char *)(v3 + 604);
  }
  else {
    int v62 = "";
  }
  *(_DWORD *)long long buf = 136446466;
  *(void *)&uint8_t buf[4] = "tcp_close";
  *(_WORD *)&buf[12] = 2082;
  *(void *)&buf[14] = v62;
  int v63 = (void *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  if (__nwlog_fault())
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v64 = __nwlog_tcp_log();
      os_log_type_t v65 = type[0];
      if (!os_log_type_enabled(v64, type[0])) {
        goto LABEL_129;
      }
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "tcp_close";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v62;
      __int16 v66 = "%{public}s %{public}s t_pktlist is not empty in tcp_close";
    }
    else
    {
      __int16 v64 = __nwlog_tcp_log();
      os_log_type_t v65 = type[0];
      if (!os_log_type_enabled(v64, type[0])) {
        goto LABEL_129;
      }
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "tcp_close";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v62;
      __int16 v66 = "%{public}s %{public}s t_pktlist is not empty in tcp_close, backtrace limit exceeded";
    }
    _os_log_impl(&dword_214653000, v64, v65, v66, buf, 0x16u);
  }
LABEL_129:
  if (v63) {
    free(v63);
  }
LABEL_131:
  *(_DWORD *)(a1 + 12) = 0;
  if (*(void *)(v3 + 24))
  {
    uint64_t v67 = nw_protocol_tcp_get_all_stats();
    if (v67) {
      *(_DWORD *)(v67 + 136) = 0;
    }
  }
  *(_WORD *)(v3 + 376) = *(_WORD *)(v3 + 376) & 0xDFC1 | 0x2030;
  __int16 v68 = *(void (***)(uint64_t))(v3 + 32);
  if (v68)
  {
    if (!*v68 || ((*v68)(v3), (__int16 v68 = *(void (***)(uint64_t))(v3 + 32)) != 0))
    {
      int v69 = v68[3];
      if (v69) {
        v69(v3);
      }
    }
  }
  if ((*(unsigned char *)(v3 + 374) & 1) != 0 && *(_DWORD *)(v1 + 232) != 3 && (*(unsigned char *)(v1 + 2232) & 1) == 0) {
    socket_post_kev_msg_closed();
  }
  int v70 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 32);
  if (v70) {
    v70(a1);
  }
  if (*(void *)(a1 + 840)) {
    *(void *)(a1 + 840) = 0;
  }
  *(unsigned char *)(a1 + 264) = 0;
  if (*(void *)(v3 + 24))
  {
    uint64_t v71 = nw_protocol_tcp_get_all_stats();
    if (v71) {
      *(_DWORD *)(v71 + 132) = *(unsigned __int8 *)(a1 + 264);
    }
  }
  if (*(_DWORD *)(sysctls + 308) == 1
    && (~*(_DWORD *)(a1 + 88) & 0x180) == 0
    && (*(_DWORD *)(sysctls + 40) == 1 || (*(unsigned char *)(v3 + 369) & 0x40) != 0)
    && off_26AA46350)
  {
    off_26AA46350();
  }
  char v72 = *(unsigned char *)(a1 + 988);
  if ((v72 & 2) != 0)
  {
    atomic_fetch_add_explicit(&tcp_tfo_halfcnt, 0xFFFFFFFF, memory_order_relaxed);
    if (tcp_tfo_halfcnt < 0)
    {
      uint64_t v87 = __nwlog_obj();
      os_log_type_enabled(v87, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "tcp_close";
      uint64_t v88 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort())
      {
        __break(1u);
        return;
      }
      free(v88);
      char v72 = *(unsigned char *)(a1 + 988);
    }
    *(unsigned char *)(a1 + 988) = v72 & 0xFD;
  }
  if ((*(unsigned char *)(v3 + 828) & 6) == 0)
  {
    buf[0] = 1;
    uint64_t v73 = nw_log_ring_copyout();
    int v74 = v73 + 1;
    if ((unint64_t)(v73 + 1) >= 3 && (*(unsigned char *)(v3 + 828) & 2) == 0)
    {
      uint64_t v75 = __nwlog_tcp_log();
      if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
      {
        int v76 = *(_DWORD *)(nw_tcp_access_globals(v3) + 316) - *(_DWORD *)(a1 + 1776);
        *(_DWORD *)os_log_type_t type = 136447235;
        char v93 = "tcp_close";
        __int16 v94 = 2082;
        uint64_t v95 = v3 + 604;
        __int16 v96 = 1040;
        int v97 = v74;
        __int16 v98 = 2097;
        int v99 = buf;
        __int16 v100 = 1024;
        int v101 = v76;
        _os_log_impl(&dword_214653000, v75, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s TCP Packets:\n%{private,network:tcp_packets}.*P\n\tLast packet %ums ago.", (uint8_t *)type, 0x2Cu);
      }
    }
  }
  in_pcbdetach(v1);
  *(_WORD *)(v3 + 376) = *(_WORD *)(v3 + 376) & 0xDFC1 | 0x2030;
  uint64_t v77 = *(void *)(v3 + 32);
  if (v77)
  {
    unsigned int v78 = *(void (**)(uint64_t))(v77 + 56);
    if (v78) {
      v78(v3);
    }
  }
  uint64_t v79 = *(void *)(a1 + 1056);
  if (v79) {
    ++*(void *)(v79 + 416);
  }
}

void tcp_seg_delete_acked(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 2008);
  if (v3)
  {
    uint64_t v32 = (unint64_t *)(a1 + 2000);
    while (1)
    {
      uint64_t v7 = *(void *)(v3 + 56);
      unsigned int v8 = *(_DWORD *)(v3 + 8);
      if (v8 > a2) {
        tcp_rack_update_segment_acked(a1, a3, v8, *(_DWORD *)(v3 + 4), (*(unsigned __int8 *)(v3 + 12) >> 3) & 1);
      }
      if (*(_DWORD *)(v3 + 4) - *(_DWORD *)(a1 + 560) < 0 && (*(unsigned char *)(v3 + 12) & 9) == 0) {
        ++*(_DWORD *)(a1 + 1016);
      }
      unsigned int v9 = tcp_seg_len((int *)v3);
      unsigned int v10 = v9;
      char v11 = *(unsigned char *)(v3 + 12);
      if ((v11 & 2) != 0)
      {
        unsigned int v14 = *(_DWORD *)(a1 + 2072);
        if (v14 < v9)
        {
          __nwlog_obj();
          int v15 = *(_DWORD *)(a1 + 2072);
          *(_DWORD *)long long buf = 136446722;
          uint64_t v34 = "tcp_seg_delete_acked";
          __int16 v35 = 1024;
          int v36 = v15;
          __int16 v37 = 1024;
          unsigned int v38 = v10;
          int v16 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            int v17 = __nwlog_obj();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            {
              int v18 = *(_DWORD *)(a1 + 2072);
              *(_DWORD *)long long buf = 136446722;
              uint64_t v34 = "tcp_seg_delete_acked";
              __int16 v35 = 1024;
              int v36 = v18;
              __int16 v37 = 1024;
              unsigned int v38 = v10;
              _os_log_impl(&dword_214653000, v17, OS_LOG_TYPE_ERROR, "%{public}s bytes_lost (%u) can't be smaller than already lost segment length (%u), backtrace limit exceeded", buf, 0x18u);
            }
          }
          if (v16) {
            free(v16);
          }
          unsigned int v14 = *(_DWORD *)(a1 + 2072);
          char v11 = *(unsigned char *)(v3 + 12);
        }
        *(_DWORD *)(a1 + 2072) = v14 - v10;
        if ((v11 & 4) == 0)
        {
LABEL_11:
          if ((v11 & 1) == 0) {
            goto LABEL_12;
          }
          goto LABEL_30;
        }
      }
      else if ((*(unsigned char *)(v3 + 12) & 4) == 0)
      {
        goto LABEL_11;
      }
      unsigned int v19 = *(_DWORD *)(a1 + 2076);
      if (v19 < v10)
      {
        __nwlog_obj();
        int v20 = *(_DWORD *)(a1 + 2076);
        *(_DWORD *)long long buf = 136446722;
        uint64_t v34 = "tcp_seg_delete_acked";
        __int16 v35 = 1024;
        int v36 = v20;
        __int16 v37 = 1024;
        unsigned int v38 = v10;
        unsigned int v21 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          unsigned int v22 = __nwlog_obj();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            int v23 = *(_DWORD *)(a1 + 2076);
            *(_DWORD *)long long buf = 136446722;
            uint64_t v34 = "tcp_seg_delete_acked";
            __int16 v35 = 1024;
            int v36 = v23;
            __int16 v37 = 1024;
            unsigned int v38 = v10;
            _os_log_impl(&dword_214653000, v22, OS_LOG_TYPE_ERROR, "%{public}s bytes_retransmitted (%u) can't be smaller than already retransmited segment length (%u), backtrace limit exceeded", buf, 0x18u);
          }
        }
        if (v21) {
          free(v21);
        }
        unsigned int v19 = *(_DWORD *)(a1 + 2076);
        char v11 = *(unsigned char *)(v3 + 12);
      }
      *(_DWORD *)(a1 + 2076) = v19 - v10;
      if ((v11 & 1) == 0)
      {
LABEL_12:
        uint64_t v12 = *(void *)(v3 + 56);
        unsigned int v13 = *(void **)(v3 + 64);
        if (!v12) {
          goto LABEL_38;
        }
        goto LABEL_13;
      }
LABEL_30:
      unsigned int v24 = *(_DWORD *)(a1 + 2080);
      if (v24 < v10)
      {
        __nwlog_obj();
        int v25 = *(_DWORD *)(a1 + 2080);
        *(_DWORD *)long long buf = 136446722;
        uint64_t v34 = "tcp_seg_delete_acked";
        __int16 v35 = 1024;
        int v36 = v25;
        __int16 v37 = 1024;
        unsigned int v38 = v10;
        int v26 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          unsigned int v27 = __nwlog_obj();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            int v28 = *(_DWORD *)(a1 + 2080);
            *(_DWORD *)long long buf = 136446722;
            uint64_t v34 = "tcp_seg_delete_acked";
            __int16 v35 = 1024;
            int v36 = v28;
            __int16 v37 = 1024;
            unsigned int v38 = v10;
            _os_log_impl(&dword_214653000, v27, OS_LOG_TYPE_ERROR, "%{public}s bytes_sacked (%u) can't be smaller than already SACKed segment length (%u), backtrace limit exceeded", buf, 0x18u);
          }
        }
        if (v26) {
          free(v26);
        }
        unsigned int v24 = *(_DWORD *)(a1 + 2080);
      }
      *(_DWORD *)(a1 + 2080) = v24 - v10;
      uint64_t v12 = *(void *)(v3 + 56);
      unsigned int v13 = *(void **)(v3 + 64);
      if (!v12)
      {
LABEL_38:
        *(void *)(a1 + 2016) = v13;
        goto LABEL_39;
      }
LABEL_13:
      *(void *)(v12 + 64) = v13;
      unsigned int v13 = *(void **)(v3 + 64);
LABEL_39:
      *unsigned int v13 = v12;
      uint64_t v29 = *(void *)(v3 + 16);
      uint64_t v30 = *(void **)(v3 + 24);
      if (v29)
      {
        *(void *)(v29 + 24) = v30;
        uint64_t v30 = *(void **)(v3 + 24);
      }
      else
      {
        *(void *)(a1 + 1992) = v30;
      }
      *uint64_t v30 = v29;
      tcp_seg_sent_tree_head_RB_REMOVE(v32, (void *)v3);
      if (*(_DWORD *)(a1 + 2040) < 0x40u)
      {
        *(void *)(v3 + 80) = 0;
        *(_OWORD *)(v3 + 48) = 0u;
        *(_OWORD *)(v3 + 64) = 0u;
        *(_OWORD *)(v3 + 16) = 0u;
        *(_OWORD *)(v3 + 32) = 0u;
        *(_OWORD *)uint64_t v3 = 0u;
        uint64_t v6 = *(void **)(a1 + 2032);
        *(void *)(v3 + 80) = v6;
        *uint64_t v6 = v3;
        *(void *)(a1 + 2032) = v3 + 72;
        ++*(_DWORD *)(a1 + 2040);
        uint64_t v3 = v7;
        if (!v7) {
          return;
        }
      }
      else
      {
        nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
        free((void *)v3);
        uint64_t v3 = v7;
        if (!v7) {
          return;
        }
      }
    }
  }
}

void tcp_segs_sent_clean(uint64_t a1, int a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a1 + 1984);
  if (v4)
  {
    while (1)
    {
      uint64_t v6 = *(void *)(v4 + 16);
      if (*(_DWORD *)(v4 + 4) - *(_DWORD *)(a1 + 560) >= 0 || (*(unsigned char *)(v4 + 12) & 9) != 0)
      {
        uint64_t v7 = *(void **)(v4 + 24);
        if (!v6) {
          goto LABEL_9;
        }
      }
      else
      {
        ++*(_DWORD *)(a1 + 1016);
        uint64_t v7 = *(void **)(v4 + 24);
        if (!v6)
        {
LABEL_9:
          *(void *)(a1 + 1992) = v7;
          goto LABEL_10;
        }
      }
      *(void *)(v6 + 24) = v7;
      uint64_t v7 = *(void **)(v4 + 24);
LABEL_10:
      *uint64_t v7 = v6;
      tcp_seg_sent_tree_head_RB_REMOVE((unint64_t *)(a1 + 2000), (void *)v4);
      if (*(_DWORD *)(a1 + 2040) < 0x40u)
      {
        *(void *)(v4 + 80) = 0;
        *(_OWORD *)(v4 + 48) = 0u;
        *(_OWORD *)(v4 + 64) = 0u;
        *(_OWORD *)(v4 + 16) = 0u;
        *(_OWORD *)(v4 + 32) = 0u;
        *(_OWORD *)uint64_t v4 = 0u;
        int v5 = *(void **)(a1 + 2032);
        *(void *)(v4 + 80) = v5;
        *int v5 = v4;
        *(void *)(a1 + 2032) = v4 + 72;
        ++*(_DWORD *)(a1 + 2040);
        uint64_t v4 = v6;
        if (!v6) {
          break;
        }
      }
      else
      {
        nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
        free((void *)v4);
        uint64_t v4 = v6;
        if (!v6) {
          break;
        }
      }
    }
  }
  if (*(void *)(a1 + 2000))
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v16 = "tcp_segs_sent_clean";
    char v11 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      unsigned int v13 = __nwlog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        int v16 = "tcp_segs_sent_clean";
        _os_log_impl(&dword_214653000, v13, OS_LOG_TYPE_ERROR, "%{public}s RB tree still contains segments while time ordered list is already empty, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v11) {
      free(v11);
    }
  }
  if (*(void *)(a1 + 2008))
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v16 = "tcp_segs_sent_clean";
    uint64_t v12 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      unsigned int v14 = __nwlog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        int v16 = "tcp_segs_sent_clean";
        _os_log_impl(&dword_214653000, v14, OS_LOG_TYPE_ERROR, "%{public}s Segment ACKed list shouldn't contain any segments as they are removed immediately after being ACKed, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v12) {
      free(v12);
    }
  }
  *(unsigned char *)(a1 + 2069) &= ~0x80u;
  *(_DWORD *)(a1 + 2080) = 0;
  *(void *)(a1 + 2072) = 0;
  if (a2)
  {
    unsigned int v8 = *(void **)(a1 + 2024);
    if (v8)
    {
      do
      {
        unsigned int v10 = (void *)v8[9];
        unsigned int v9 = (void *)v8[10];
        if (v10)
        {
          v10[10] = v9;
          unsigned int v9 = (void *)v8[10];
        }
        else
        {
          *(void *)(a1 + 2032) = v9;
        }
        *unsigned int v9 = v10;
        nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
        free(v8);
        unsigned int v8 = v10;
      }
      while (v10);
    }
    *(_DWORD *)(a1 + 2040) = 0;
  }
}

void *tcp_seg_sent_tree_head_RB_REMOVE(unint64_t *a1, void *a2)
{
  unint64_t v2 = a2[5];
  if (!a2[4])
  {
    unint64_t v5 = a2[6] & 0xFFFFFFFFFFFFFFFELL;
    uint64_t v17 = a2[6] & 1;
    if (!v2)
    {
      if (!v5)
      {
LABEL_37:
        int v18 = a1;
        goto LABEL_38;
      }
LABEL_29:
      int v18 = (unint64_t *)(v5 + 32);
      if (*(void **)(v5 + 32) != a2) {
        int v18 = (unint64_t *)(v5 + 40);
      }
LABEL_38:
      *int v18 = v2;
      if (!v17) {
        goto LABEL_41;
      }
      return a2;
    }
LABEL_33:
    if (*(void *)(v2 + 48)) {
      uint64_t v19 = v5 | 1;
    }
    else {
      uint64_t v19 = v5;
    }
    *(void *)(v2 + 48) = v19;
    if (!v5) {
      goto LABEL_37;
    }
    goto LABEL_29;
  }
  if (!v2)
  {
    unint64_t v5 = a2[6] & 0xFFFFFFFFFFFFFFFELL;
    uint64_t v17 = a2[6] & 1;
    unint64_t v2 = a2[4];
    goto LABEL_33;
  }
  do
  {
    unint64_t v3 = v2;
    unint64_t v2 = *(void *)(v2 + 32);
  }
  while (v2);
  unint64_t v2 = *(void *)(v3 + 40);
  uint64_t v4 = *(void *)(v3 + 48);
  unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
  if (v2)
  {
    if (*(void *)(v2 + 48)) {
      unint64_t v6 = v4 | 1;
    }
    else {
      unint64_t v6 = v4 & 0xFFFFFFFFFFFFFFFELL;
    }
    *(void *)(v2 + 48) = v6;
  }
  uint64_t v7 = a1;
  if (v5)
  {
    uint64_t v7 = (unint64_t *)(v5 + 32);
    if (*(void *)(v5 + 32) != v3) {
      uint64_t v7 = (unint64_t *)(v5 + 40);
    }
  }
  int v8 = v4 & 1;
  *uint64_t v7 = v2;
  if ((void *)(*(void *)(v3 + 48) & 0xFFFFFFFFFFFFFFFELL) == a2) {
    unint64_t v5 = v3;
  }
  uint64_t v9 = a2[6];
  *(_OWORD *)(v3 + 32) = *((_OWORD *)a2 + 2);
  *(void *)(v3 + 48) = v9;
  unsigned int v10 = a1;
  unint64_t v11 = a2[6] & 0xFFFFFFFFFFFFFFFELL;
  if (v11)
  {
    unsigned int v13 = *(void **)(v11 + 32);
    uint64_t v12 = (unint64_t *)(v11 + 32);
    if (v13 == a2) {
      unsigned int v10 = v12;
    }
    else {
      unsigned int v10 = v12 + 1;
    }
  }
  *unsigned int v10 = v3;
  uint64_t v15 = a2[4];
  uint64_t v14 = a2[5];
  if (*(void *)(v15 + 48)) {
    uint64_t v16 = v3 | 1;
  }
  else {
    uint64_t v16 = v3;
  }
  *(void *)(v15 + 48) = v16;
  if (v14)
  {
    if (*(void *)(v14 + 48)) {
      v3 |= 1uLL;
    }
    *(void *)(v14 + 48) = v3;
  }
  if (v8) {
    return a2;
  }
LABEL_41:
  while (1)
  {
    int v20 = (void *)v2;
    unint64_t v2 = v5;
    if (v20)
    {
      uint64_t v21 = v20[6];
      if (v21) {
        break;
      }
    }
    unint64_t v22 = *a1;
    if (v20 == (void *)*a1) {
      goto LABEL_127;
    }
    unint64_t v23 = *(void *)(v2 + 32);
    if ((void *)v23 == v20)
    {
      unint64_t v23 = *(void *)(v2 + 40);
      uint64_t v30 = *(void *)(v23 + 48);
      if (v30)
      {
        *(void *)(v23 + 48) = v30 & 0xFFFFFFFFFFFFFFFELL;
        uint64_t v31 = *(void *)(v2 + 48) | 1;
        uint64_t v32 = *(void **)(v23 + 32);
        *(void *)(v2 + 40) = v32;
        *(void *)(v2 + 48) = v31;
        if (v32)
        {
          if (v32[6]) {
            uint64_t v33 = v2 | 1;
          }
          else {
            uint64_t v33 = v2;
          }
          v32[6] = v33;
          uint64_t v31 = *(void *)(v2 + 48);
        }
        *(void *)(v23 + 48) = v31 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v23 + 48) & 1;
        if ((v31 & 0xFFFFFFFFFFFFFFFELL) != 0)
        {
          uint64_t v34 = *(void *)(v2 + 48);
          unint64_t v35 = v34 & 0xFFFFFFFFFFFFFFFELL;
          if (v2 == *(void *)((v34 & 0xFFFFFFFFFFFFFFFELL) + 32))
          {
            *(void *)(v35 + 32) = v23;
          }
          else
          {
            *(void *)(v35 + 40) = v23;
            uint64_t v32 = *(void **)(v2 + 40);
          }
        }
        else
        {
          *a1 = v23;
          uint64_t v34 = *(void *)(v2 + 48);
          unint64_t v22 = v23;
        }
        *(void *)(v23 + 32) = v2;
        if (v34) {
          v23 |= 1uLL;
        }
        *(void *)(v2 + 48) = v23;
        unint64_t v23 = (unint64_t)v32;
      }
      unint64_t v40 = *(void *)(v23 + 32);
      if (v40)
      {
        uint64_t v41 = *(void *)(v40 + 48);
        if (v41)
        {
          uint64_t v42 = *(void *)(v23 + 40);
          if (!v42 || (*(unsigned char *)(v42 + 48) & 1) == 0)
          {
            *(void *)(v40 + 48) = v41 & 0xFFFFFFFFFFFFFFFELL;
            uint64_t v48 = *(void *)(v23 + 48) | 1;
            *(void *)(v23 + 48) = v48;
            uint64_t v49 = *(void *)(v40 + 40);
            *(void *)(v23 + 32) = v49;
            if (v49)
            {
              if (*(void *)(v49 + 48)) {
                uint64_t v50 = v23 | 1;
              }
              else {
                uint64_t v50 = v23;
              }
              *(void *)(v49 + 48) = v50;
              uint64_t v48 = *(void *)(v23 + 48);
            }
            *(void *)(v40 + 48) = v48 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v40 + 48) & 1;
            if ((v48 & 0xFFFFFFFFFFFFFFFELL) != 0)
            {
              uint64_t v51 = *(void *)(v23 + 48);
              unint64_t v52 = v51 & 0xFFFFFFFFFFFFFFFELL;
              if (v23 == *(void *)((v51 & 0xFFFFFFFFFFFFFFFELL) + 32)) {
                *(void *)(v52 + 32) = v40;
              }
              else {
                *(void *)(v52 + 40) = v40;
              }
            }
            else
            {
              *a1 = v40;
              uint64_t v51 = *(void *)(v23 + 48);
              unint64_t v22 = v40;
            }
            *(void *)(v40 + 40) = v23;
            if (v51) {
              v40 |= 1uLL;
            }
            *(void *)(v23 + 48) = v40;
            unint64_t v23 = *(void *)(v2 + 40);
            uint64_t v42 = *(void *)(v23 + 40);
          }
LABEL_136:
          *(void *)(v23 + 48) = *(void *)(v23 + 48) & 0xFFFFFFFFFFFFFFFELL | *(void *)(v2 + 48) & 1;
          *(void *)(v2 + 48) &= ~1uLL;
          if (v42) {
            *(void *)(v42 + 48) &= ~1uLL;
          }
          unsigned int v53 = (unint64_t *)(v23 + 32);
          uint64_t v54 = *(void *)(v23 + 32);
          *(void *)(v2 + 40) = v54;
          if (v54) {
            goto LABEL_115;
          }
          goto LABEL_119;
        }
      }
      uint64_t v42 = *(void *)(v23 + 40);
      if (v42 && (*(unsigned char *)(v42 + 48) & 1) != 0) {
        goto LABEL_136;
      }
    }
    else
    {
      uint64_t v24 = *(void *)(v23 + 48);
      if (v24)
      {
        *(void *)(v23 + 48) = v24 & 0xFFFFFFFFFFFFFFFELL;
        uint64_t v25 = *(void *)(v2 + 48) | 1;
        *(void *)(v2 + 48) = v25;
        int v26 = *(void **)(v23 + 40);
        *(void *)(v2 + 32) = v26;
        if (v26)
        {
          if (v26[6]) {
            uint64_t v27 = v2 | 1;
          }
          else {
            uint64_t v27 = v2;
          }
          v26[6] = v27;
          uint64_t v25 = *(void *)(v2 + 48);
        }
        *(void *)(v23 + 48) = v25 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v23 + 48) & 1;
        if ((v25 & 0xFFFFFFFFFFFFFFFELL) != 0)
        {
          uint64_t v28 = *(void *)(v2 + 48);
          unint64_t v29 = v28 & 0xFFFFFFFFFFFFFFFELL;
          if (v2 == *(void *)((v28 & 0xFFFFFFFFFFFFFFFELL) + 32))
          {
            *(void *)(v29 + 32) = v23;
            int v26 = *(void **)(v2 + 32);
          }
          else
          {
            *(void *)(v29 + 40) = v23;
          }
        }
        else
        {
          *a1 = v23;
          uint64_t v28 = *(void *)(v2 + 48);
          unint64_t v22 = v23;
        }
        *(void *)(v23 + 40) = v2;
        if (v28) {
          v23 |= 1uLL;
        }
        *(void *)(v2 + 48) = v23;
        unint64_t v23 = (unint64_t)v26;
      }
      uint64_t v36 = *(void *)(v23 + 32);
      if (v36)
      {
        uint64_t v37 = *(void *)(v36 + 48);
        if (v37) {
          goto LABEL_85;
        }
      }
      unint64_t v38 = *(void *)(v23 + 40);
      if (v38)
      {
        uint64_t v39 = *(void *)(v38 + 48);
        if (v39)
        {
          if (!v36) {
            goto LABEL_88;
          }
          uint64_t v37 = *(void *)(v36 + 48);
LABEL_85:
          if ((v37 & 1) == 0)
          {
            unint64_t v38 = *(void *)(v23 + 40);
            if (v38)
            {
              uint64_t v39 = *(void *)(v38 + 48);
LABEL_88:
              *(void *)(v38 + 48) = v39 & 0xFFFFFFFFFFFFFFFELL;
            }
            uint64_t v43 = *(void *)(v23 + 48) | 1;
            uint64_t v44 = *(void *)(v38 + 32);
            *(void *)(v23 + 40) = v44;
            *(void *)(v23 + 48) = v43;
            if (v44)
            {
              if (*(void *)(v44 + 48)) {
                uint64_t v45 = v23 | 1;
              }
              else {
                uint64_t v45 = v23;
              }
              *(void *)(v44 + 48) = v45;
              uint64_t v43 = *(void *)(v23 + 48);
            }
            *(void *)(v38 + 48) = v43 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v38 + 48) & 1;
            if ((v43 & 0xFFFFFFFFFFFFFFFELL) != 0)
            {
              uint64_t v46 = *(void *)(v23 + 48);
              unint64_t v47 = v46 & 0xFFFFFFFFFFFFFFFELL;
              if (v23 == *(void *)((v46 & 0xFFFFFFFFFFFFFFFELL) + 32)) {
                *(void *)(v47 + 32) = v38;
              }
              else {
                *(void *)(v47 + 40) = v38;
              }
            }
            else
            {
              *a1 = v38;
              uint64_t v46 = *(void *)(v23 + 48);
              unint64_t v22 = v38;
            }
            *(void *)(v38 + 32) = v23;
            if (v46) {
              v38 |= 1uLL;
            }
            *(void *)(v23 + 48) = v38;
            unint64_t v23 = *(void *)(v2 + 32);
            uint64_t v36 = *(void *)(v23 + 32);
          }
          *(void *)(v23 + 48) = *(void *)(v23 + 48) & 0xFFFFFFFFFFFFFFFELL | *(void *)(v2 + 48) & 1;
          *(void *)(v2 + 48) &= ~1uLL;
          if (v36) {
            *(void *)(v36 + 48) &= ~1uLL;
          }
          unsigned int v53 = (unint64_t *)(v23 + 40);
          uint64_t v54 = *(void *)(v23 + 40);
          *(void *)(v2 + 32) = v54;
          if (v54)
          {
LABEL_115:
            if (*(void *)(v54 + 48)) {
              uint64_t v55 = v2 | 1;
            }
            else {
              uint64_t v55 = v2;
            }
            *(void *)(v54 + 48) = v55;
          }
LABEL_119:
          uint64_t v56 = *(void *)(v2 + 48);
          *(void *)(v23 + 48) = v56 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v23 + 48) & 1;
          if ((v56 & 0xFFFFFFFFFFFFFFFELL) != 0)
          {
            uint64_t v57 = *(void *)(v2 + 48);
            unint64_t v58 = v57 & 0xFFFFFFFFFFFFFFFELL;
            if (v2 == *(void *)((v57 & 0xFFFFFFFFFFFFFFFELL) + 32)) {
              *(void *)(v58 + 32) = v23;
            }
            else {
              *(void *)(v58 + 40) = v23;
            }
          }
          else
          {
            *a1 = v23;
            uint64_t v57 = *(void *)(v2 + 48);
            unint64_t v22 = v23;
          }
          *unsigned int v53 = v2;
          if (v57) {
            v23 |= 1uLL;
          }
          *(void *)(v2 + 48) = v23;
          int v20 = (void *)v22;
LABEL_127:
          if (!v20) {
            return a2;
          }
          uint64_t v21 = v20[6];
          break;
        }
      }
    }
    *(void *)(v23 + 48) |= 1uLL;
    unint64_t v5 = *(void *)(v2 + 48) & 0xFFFFFFFFFFFFFFFELL;
  }
  v20[6] = v21 & 0xFFFFFFFFFFFFFFFELL;
  return a2;
}

uint64_t tcp_seg_len(int *a1)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  int v3 = *a1;
  int v2 = a1[1];
  uint64_t result = (v2 - *a1);
  if (v2 - v3 < 0)
  {
    __nwlog_obj();
    int v6 = *a1;
    int v5 = a1[1];
    *(_DWORD *)long long buf = 136446722;
    uint64_t v12 = "tcp_seg_len";
    __int16 v13 = 1024;
    int v14 = v5;
    __int16 v15 = 1024;
    int v16 = v6;
    uint64_t v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        int v10 = *a1;
        int v9 = a1[1];
        *(_DWORD *)long long buf = 136446722;
        uint64_t v12 = "tcp_seg_len";
        __int16 v13 = 1024;
        int v14 = v9;
        __int16 v15 = 1024;
        int v16 = v10;
        _os_log_impl(&dword_214653000, v8, OS_LOG_TYPE_ERROR, "%{public}s segment end(%u) can't be smaller than segment start(%u), backtrace limit exceeded", buf, 0x18u);
      }
    }
    if (v7) {
      free(v7);
    }
    return (a1[1] - *a1);
  }
  return result;
}

void nw_protocol_tcp_disconnect(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v1 = nw_protocol_downcast();
    if (v1)
    {
      uint64_t v2 = v1;
      int v3 = (void *)MEMORY[0x263F144B0];
      if (*MEMORY[0x263F144B0] != -1) {
        dispatch_once(MEMORY[0x263F144B0], &__block_literal_global_18);
      }
      uint64_t v4 = (unsigned char *)MEMORY[0x263F144A8];
      if (*MEMORY[0x263F144A8] && kdebug_is_enabled())
      {
        kdebug_trace();
        if ((*(unsigned char *)(v2 + 828) & 2) != 0) {
          goto LABEL_10;
        }
      }
      else if ((*(unsigned char *)(v2 + 828) & 2) != 0)
      {
        goto LABEL_10;
      }
      int v5 = __nwlog_tcp_log();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 136446466;
        unint64_t v11 = "nw_protocol_tcp_disconnect";
        __int16 v12 = 2082;
        uint64_t v13 = v2 + 604;
        _os_log_impl(&dword_214653000, v5, OS_LOG_TYPE_INFO, "%{public}s %{public}s input protocol initiated disconnect", buf, 0x16u);
      }
LABEL_10:
      __nw_protocol_tcp_disconnect(v2);
      if ((*(unsigned char *)(v2 + 5308) & 2) != 0) {
        return;
      }
      if ((*(unsigned char *)(v2 + 828) & 2) == 0)
      {
        int v6 = __nwlog_tcp_log();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 136446466;
          unint64_t v11 = "nw_protocol_tcp_disconnect";
          __int16 v12 = 2082;
          uint64_t v13 = v2 + 604;
          _os_log_impl(&dword_214653000, v6, OS_LOG_TYPE_INFO, "%{public}s %{public}s send disconnect to input protocol", buf, 0x16u);
        }
      }
      nw_protocol_get_input_handler();
      if (!nw_protocol_disconnected_is_valid()) {
        goto LABEL_20;
      }
      if (*v3 == -1)
      {
        if (*v4) {
          goto LABEL_17;
        }
      }
      else
      {
        dispatch_once(MEMORY[0x263F144B0], &__block_literal_global_18);
        if (*v4)
        {
LABEL_17:
          if (kdebug_is_enabled()) {
            kdebug_trace();
          }
        }
      }
      nw_protocol_get_input_handler();
      nw_protocol_disconnected();
LABEL_20:
      *(_DWORD *)(v2 + 5308) |= 2u;
      return;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    unint64_t v11 = "nw_protocol_tcp_disconnect";
    uint64_t v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        unint64_t v11 = "nw_protocol_tcp_disconnect";
        int v9 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_34;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    unint64_t v11 = "nw_protocol_tcp_disconnect";
    uint64_t v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        unint64_t v11 = "nw_protocol_tcp_disconnect";
        int v9 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_34:
        _os_log_impl(&dword_214653000, v8, OS_LOG_TYPE_ERROR, v9, buf, 0xCu);
      }
    }
  }
  if (v7) {
    free(v7);
  }
}

void __nw_protocol_tcp_disconnect(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 5224) < 3u)
  {
    if ((*(unsigned char *)(a1 + 828) & 2) == 0)
    {
      int v3 = __nwlog_tcp_log();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 136446466;
        int v5 = "__nw_protocol_tcp_disconnect";
        __int16 v6 = 2082;
        uint64_t v7 = a1 + 604;
        _os_log_impl(&dword_214653000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s disconnect tcp", buf, 0x16u);
      }
    }
    *(_DWORD *)(a1 + 5224) = 3;
    nw_protocol_tcp_log_summary(a1);
    nw_protocol_upcast();
    nw_protocol_retain();
    nw_queue_context_async();
  }
  else if ((*(unsigned char *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
  {
    uint64_t v2 = __nwlog_tcp_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 136446466;
      int v5 = "__nw_protocol_tcp_disconnect";
      __int16 v6 = 2082;
      uint64_t v7 = a1 + 604;
      _os_log_impl(&dword_214653000, v2, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
    }
  }
}

void nw_protocol_tcp_log_summary(uint64_t a1)
{
  v155[2] = *MEMORY[0x263EF8340];
  if (*(void *)a1)
  {
    uint64_t v2 = *(void *)(*(void *)a1 + 240);
    if (v2)
    {
      uint64_t v3 = *(void *)(a1 + 40);
      if ((*(unsigned char *)(v3 + 5309) & 0x40) != 0) {
        return;
      }
      if ((*(_DWORD *)(v2 + 1872) & 0xFFFFFFFE) != 2)
      {
        *(_DWORD *)(v2 + 204) = *(_DWORD *)(v2 + 200);
        *(_DWORD *)(v2 + 212) = *(_DWORD *)(v2 + 208);
      }
      uint64_t v4 = *(void *)(*(void *)(v2 + 80) + 496);
      if (!v4 || (uint64_t v5 = *(void *)(v4 + 1488)) == 0 || (v6 = *(_DWORD *)(v5 + 40)) == 0) {
        int v6 = *(_DWORD *)(v2 + 1964);
      }
      v155[0] = 0;
      v155[1] = 0;
      nw_protocol_upcast();
      nw_protocol_get_flow_id();
      if ((*(unsigned char *)(a1 + 828) & 4) != 0)
      {
        if ((*(unsigned char *)(a1 + 828) & 2) != 0) {
          goto LABEL_30;
        }
        uint64_t v7 = __nwlog_tcp_log();
        if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_30;
        }
        uint64_t v74 = a1 + 604;
        unsigned int v11 = *(_DWORD *)(v3 + 5308);
        unsigned int v12 = *(_DWORD *)(v3 + 5296);
        unsigned int v13 = v12 / 0x3E8;
        BOOL v72 = ((v11 >> 15) & 1) != 0 && (*(_WORD *)(v2 + 990) & 0x800) == 0;
        uint64_t v60 = *(void *)(v3 + 5272);
        int v56 = *(unsigned __int16 *)(v3 + 5300);
        uint64_t v64 = *(void *)(v3 + 5280);
        int v70 = *(unsigned __int16 *)(v3 + 5302);
        unsigned int v66 = v12 % 0x3E8;
        int v68 = (v11 >> 18) & 1;
        int v62 = *(unsigned __int8 *)(v2 + 1868);
        int v58 = *(unsigned __int8 *)(v2 + 266);
        int v52 = *(unsigned __int8 *)(v2 + 265);
        int v54 = (v11 >> 19) & 1;
        int v50 = (v11 >> 20) & 1;
        int v46 = HIWORD(v11) & 1;
        int v48 = (v11 >> 15) & 1;
        int v23 = *(_DWORD *)(v3 + 5304);
        int v44 = (*(_DWORD *)(v2 + 348) >> 12) & 1;
        int v24 = (v11 >> 17) & 1;
        uint64_t v25 = nw_connection_client_accurate_ecn_state_to_string();
        uint64_t v26 = nw_connection_server_accurate_ecn_state_to_string();
        unsigned int v27 = *(_DWORD *)(v2 + 88);
        BOOL v28 = (~v27 & 0x180) == 0;
        int v29 = (v27 >> 28) & 1;
        unsigned int v30 = *(_DWORD *)(v2 + 1872) - 1;
        if (v30 > 2) {
          uint64_t v31 = "invalid";
        }
        else {
          uint64_t v31 = off_264217698[v30];
        }
        int v37 = *(_DWORD *)(v2 + 200);
        int v38 = *(_DWORD *)(v2 + 204);
        int v39 = *(_DWORD *)(v2 + 208);
        int v40 = *(_DWORD *)(v2 + 212);
        int v114 = v23;
        int v118 = v24;
        uint64_t v120 = v25;
        uint64_t v122 = v26;
        int v126 = v29;
        char v128 = v31;
        int v130 = *(_DWORD *)(v2 + 240);
        int v134 = ((1000 * v37) >> 5) % 1000;
        int v138 = ((1000 * v39) >> 4) % 1000;
        int v142 = ((1000 * v38) >> 5) % 1000;
        int v146 = ((1000 * v40) >> 4) % 1000;
        int v150 = *(_DWORD *)(v2 + 1884);
        int v154 = *(_DWORD *)(v2 + 724);
        int v76 = "nw_protocol_tcp_log_summary";
        uint64_t v78 = v74;
        __int16 v79 = 1042;
        int v80 = 16;
        __int16 v81 = 2098;
        os_log_type_t v82 = v155;
        uint64_t v84 = v60;
        int v86 = v56;
        __int16 v83 = 2085;
        __int16 v87 = 2085;
        uint64_t v88 = v64;
        __int16 v85 = 1026;
        __int16 v89 = 1026;
        int v90 = v70;
        int v92 = v68;
        unsigned int v94 = v13;
        unsigned int v96 = v66;
        int v98 = v62;
        int v100 = v58;
        int v102 = v54;
        int v104 = v52;
        int v106 = v50;
        int v108 = v48;
        BOOL v110 = v72;
        int v112 = v46;
        int v116 = v44;
        __int16 v119 = 2080;
        __int16 v121 = 2080;
        BOOL v124 = v28;
        __int16 v77 = 2082;
        __int16 v127 = 2082;
        int v132 = v37 >> 5;
        int v136 = v39 >> 4;
        int v140 = v38 >> 5;
        int v144 = v40 >> 4;
        int v148 = v6;
        int v152 = *(_DWORD *)(v2 + 728);
        __int16 v91 = 1024;
        __int16 v93 = 1024;
        __int16 v95 = 1024;
        __int16 v97 = 1024;
        __int16 v99 = 1024;
        __int16 v101 = 1024;
        __int16 v103 = 1024;
        __int16 v105 = 1024;
        __int16 v107 = 1024;
        __int16 v109 = 1024;
        __int16 v111 = 1024;
        __int16 v113 = 1024;
        __int16 v115 = 1024;
        __int16 v117 = 1024;
        __int16 v123 = 1024;
        __int16 v125 = 1024;
        __int16 v129 = 1024;
        __int16 v131 = 1024;
        __int16 v133 = 1024;
        __int16 v135 = 1024;
        __int16 v137 = 1024;
        __int16 v139 = 1024;
        __int16 v141 = 1024;
        __int16 v143 = 1024;
        __int16 v145 = 1024;
        __int16 v147 = 1024;
        __int16 v149 = 1024;
        __int16 v151 = 1024;
        __int16 v153 = 1024;
        *(_DWORD *)long long buf = 136456195;
        uint64_t v36 = "%{public}s %{public}s \n"
              "\t[%{public,uuid_t}.16P %{sensitive}s:%{public}d<->%{sensitive}s:%{public}d]\n"
              "\tInit: %d, Conn_Time: %u.%03ums, SYNs: %u, WR_T: %d/%d, RD_T: %d/%d, TFO: %d/%d/%d, ECN: %d/%d/%d, Accura"
              "te ECN (client/server): %s/%s, TS: %d, TSO: %d\n"
              "\trtt_cache: %{public}s, rtt_upd: %d, rtt: %u.%03ums, rtt_var: %u.%03ums rtt_nc: %u.%03ums, rtt_var_nc: %u"
              ".%03ums base rtt: %ums\n"
              "\tACKs-compressed: %u, ACKs delayed: %u delayed ACKs sent: %u";
      }
      else
      {
        if ((*(unsigned char *)(a1 + 828) & 2) != 0) {
          goto LABEL_30;
        }
        uint64_t v7 = __nwlog_tcp_log();
        if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_30;
        }
        uint64_t v71 = a1 + 604;
        unsigned int v8 = *(_DWORD *)(v3 + 5308);
        unsigned int v9 = *(_DWORD *)(v3 + 5296);
        unsigned int v10 = v9 / 0x3E8;
        BOOL v73 = ((v8 >> 15) & 1) != 0 && (*(_WORD *)(v2 + 990) & 0x800) == 0;
        uint64_t v47 = *(void *)(v3 + 5272);
        int v45 = *(unsigned __int16 *)(v3 + 5300);
        uint64_t v43 = *(void *)(v3 + 5280);
        int v53 = *(unsigned __int16 *)(v3 + 5302);
        unsigned int v67 = v9 % 0x3E8;
        int v65 = *(unsigned __int8 *)(v2 + 1868);
        int v61 = (v8 >> 19) & 1;
        int v63 = *(unsigned __int8 *)(v2 + 266);
        int v57 = (v8 >> 20) & 1;
        int v59 = *(unsigned __int8 *)(v2 + 265);
        int v55 = (v8 >> 15) & 1;
        int v69 = HIWORD(v8) & 1;
        int v14 = *(_DWORD *)(v3 + 5304);
        int v49 = (*(_DWORD *)(v2 + 348) >> 12) & 1;
        int v51 = (v8 >> 18) & 1;
        int v15 = (v8 >> 17) & 1;
        uint64_t v16 = nw_connection_client_accurate_ecn_state_to_string();
        uint64_t v17 = nw_connection_server_accurate_ecn_state_to_string();
        unsigned int v18 = *(_DWORD *)(v2 + 88);
        BOOL v19 = (~v18 & 0x180) == 0;
        int v20 = (v18 >> 28) & 1;
        unsigned int v21 = *(_DWORD *)(v2 + 1872) - 1;
        if (v21 > 2) {
          unint64_t v22 = "invalid";
        }
        else {
          unint64_t v22 = off_264217698[v21];
        }
        int v32 = *(_DWORD *)(v2 + 200);
        int v33 = *(_DWORD *)(v2 + 204);
        int v34 = *(_DWORD *)(v2 + 208);
        int v35 = *(_DWORD *)(v2 + 212);
        int v114 = v14;
        int v118 = v15;
        uint64_t v120 = v16;
        uint64_t v122 = v17;
        int v126 = v20;
        char v128 = v22;
        int v130 = *(_DWORD *)(v2 + 240);
        int v134 = ((1000 * v32) >> 5) % 1000;
        int v138 = ((1000 * v34) >> 4) % 1000;
        int v142 = ((1000 * v33) >> 5) % 1000;
        int v146 = ((1000 * v35) >> 4) % 1000;
        int v150 = *(_DWORD *)(v2 + 1884);
        int v154 = *(_DWORD *)(v2 + 724);
        int v76 = "nw_protocol_tcp_log_summary";
        uint64_t v78 = v71;
        __int16 v79 = 1042;
        int v80 = 16;
        __int16 v81 = 2098;
        os_log_type_t v82 = v155;
        uint64_t v84 = v47;
        int v86 = v45;
        uint64_t v88 = v43;
        __int16 v85 = 1026;
        __int16 v89 = 1026;
        int v90 = v53;
        int v92 = v51;
        unsigned int v94 = v10;
        unsigned int v96 = v67;
        int v98 = v65;
        int v100 = v63;
        int v102 = v61;
        int v104 = v59;
        int v106 = v57;
        int v108 = v55;
        BOOL v110 = v73;
        int v112 = v69;
        int v116 = v49;
        __int16 v119 = 2080;
        __int16 v121 = 2080;
        BOOL v124 = v19;
        __int16 v77 = 2082;
        __int16 v83 = 2082;
        __int16 v87 = 2082;
        __int16 v127 = 2082;
        int v132 = v32 >> 5;
        int v136 = v34 >> 4;
        int v140 = v33 >> 5;
        int v144 = v35 >> 4;
        int v148 = v6;
        int v152 = *(_DWORD *)(v2 + 728);
        __int16 v91 = 1024;
        __int16 v93 = 1024;
        __int16 v95 = 1024;
        __int16 v97 = 1024;
        __int16 v99 = 1024;
        __int16 v101 = 1024;
        __int16 v103 = 1024;
        __int16 v105 = 1024;
        __int16 v107 = 1024;
        __int16 v109 = 1024;
        __int16 v111 = 1024;
        __int16 v113 = 1024;
        __int16 v115 = 1024;
        __int16 v117 = 1024;
        __int16 v123 = 1024;
        __int16 v125 = 1024;
        __int16 v129 = 1024;
        __int16 v131 = 1024;
        __int16 v133 = 1024;
        __int16 v135 = 1024;
        __int16 v137 = 1024;
        __int16 v139 = 1024;
        __int16 v141 = 1024;
        __int16 v143 = 1024;
        __int16 v145 = 1024;
        __int16 v147 = 1024;
        __int16 v149 = 1024;
        __int16 v151 = 1024;
        __int16 v153 = 1024;
        *(_DWORD *)long long buf = 136456194;
        uint64_t v36 = "%{public}s %{public}s \n"
              "\t[%{public,uuid_t}.16P %{public}s:%{public}d<->%{public}s:%{public}d]\n"
              "\tInit: %d, Conn_Time: %u.%03ums, SYNs: %u, WR_T: %d/%d, RD_T: %d/%d, TFO: %d/%d/%d, ECN: %d/%d/%d, Accura"
              "te ECN (client/server): %s/%s, TS: %d, TSO: %d\n"
              "\trtt_cache: %{public}s, rtt_upd: %d, rtt: %u.%03ums, rtt_var: %u.%03ums rtt_nc: %u.%03ums, rtt_var_nc: %u"
              ".%03ums base rtt: %ums\n"
              "\tACKs-compressed: %u, ACKs delayed: %u delayed ACKs sent: %u";
      }
      _os_log_impl(&dword_214653000, v7, OS_LOG_TYPE_DEFAULT, v36, buf, 0x112u);
LABEL_30:
      *(_DWORD *)(v3 + 5308) |= 0x4000u;
      return;
    }
    if ((*(unsigned char *)(a1 + 828) & 2) == 0)
    {
      uint64_t v41 = __nwlog_tcp_log();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 136446466;
        int v76 = "nw_protocol_tcp_log_summary";
        __int16 v77 = 2082;
        uint64_t v78 = a1 + 604;
        uint64_t v42 = "%{public}s %{public}s tcp pcb is NULL";
        goto LABEL_38;
      }
    }
  }
  else if ((*(unsigned char *)(a1 + 828) & 2) == 0)
  {
    uint64_t v41 = __nwlog_tcp_log();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 136446466;
      int v76 = "nw_protocol_tcp_log_summary";
      __int16 v77 = 2082;
      uint64_t v78 = a1 + 604;
      uint64_t v42 = "%{public}s %{public}s socket inpcb is NULL";
LABEL_38:
      _os_log_impl(&dword_214653000, v41, OS_LOG_TYPE_INFO, v42, buf, 0x16u);
    }
  }
}

void nw_protocol_tcp_wake_disconnect(uint64_t a1)
{
}

uint64_t tcp_cubic_cleanup()
{
  return 0;
}

uint64_t tcp_canceltimers(uint64_t a1)
{
  uint64_t v2 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
  (*(void (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 80) + 224) + 8) + 32))();
  int v3 = *(_DWORD *)(a1 + 88);
  if ((v3 & 0x40000000) != 0)
  {
    uint64_t v4 = *(uint64_t **)(v2 + 264);
    uint64_t v5 = (uint64_t *)(a1 + 48);
    if (v4) {
      BOOL v6 = v4 == v5;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6) {
      *(void *)(v2 + 264) = *v4;
    }
    uint64_t v7 = *v5;
    if (*v5) {
      *(void *)(v7 + 8) = *(void *)(a1 + 56);
    }
    **(void **)(a1 + 56) = v7;
    *(_DWORD *)(a1 + 88) = v3 & 0xBFFFFFFF;
    --*(_DWORD *)(v2 + 280);
    *uint64_t v5 = 0;
    *(void *)(a1 + 56) = 0;
  }
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(result + 316);
  *(_WORD *)(a1 + 72) = 8;
  return result;
}

void in_pcbdetach(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 224);
  if (in_pcb_checkstate(a1, 0xFFFFLL, 1) == 0xFFFF)
  {
    if ((*(unsigned char *)(v2 + 364) & 4) != 0) {
      return;
    }
    uint64_t v3 = *(void *)(a1 + 496);
    if (v3)
    {
      if (*(unsigned char *)(v3 + 1496))
      {
        uint64_t v4 = *(void **)(v3 + 1488);
        if (v4)
        {
          free(v4);
          uint64_t v3 = *(void *)(a1 + 496);
          *(void *)(v3 + 1488) = 0;
        }
        *(unsigned char *)(v3 + 1496) = 0;
      }
      *(void *)(a1 + 496) = 0;
    }
    sofreelastref(v2);
    *(_DWORD *)(a1 + 232) = 3;
    *(_DWORD *)(v2 + 364) |= 4u;
    uint64_t v5 = nw_tcp_access_globals(v2);
    uint64_t v6 = *(void *)(a1 + 16);
    *(unsigned char *)(v5 + 328) |= 2u;
    atomic_fetch_add((atomic_uint *volatile)(v6 + 44), 1u);
    char v7 = *(unsigned char *)(v5 + 328);
    if (v7)
    {
      if ((*(unsigned char *)(v5 + 328) & 8) != 0) {
        return;
      }
      char v8 = v7 | 8;
    }
    else
    {
      if ((*(unsigned char *)(v5 + 328) & 6) == 0) {
        return;
      }
      char v8 = v7 | 9;
    }
    *(unsigned char *)(v5 + 328) = v8;
    nw_protocol_timer_run_inner(v5, 1000000000, 0);
  }
  else if (!v2 || (*(unsigned char *)(v2 + 828) & 2) == 0)
  {
    __nwlog_tcp_log();
    int v9 = **(__int16 **)(v2 + 8);
    if (v2) {
      unsigned int v10 = (const char *)(v2 + 604);
    }
    else {
      unsigned int v10 = "";
    }
    *(_DWORD *)long long buf = 136446978;
    int v15 = "in_pcbdetach";
    __int16 v16 = 2082;
    uint64_t v17 = v10;
    __int16 v18 = 2048;
    uint64_t v19 = v2;
    __int16 v20 = 1024;
    int v21 = v9;
    unsigned int v11 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      unsigned int v12 = __nwlog_tcp_log();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        int v13 = **(__int16 **)(v2 + 8);
        *(_DWORD *)long long buf = 136446978;
        int v15 = "in_pcbdetach";
        __int16 v16 = 2082;
        uint64_t v17 = v10;
        __int16 v18 = 2048;
        uint64_t v19 = v2;
        __int16 v20 = 1024;
        int v21 = v13;
        _os_log_impl(&dword_214653000, v12, OS_LOG_TYPE_ERROR, "%{public}s %{public}s so=%p proto=%d couldn't set to STOPUSING, backtrace limit exceeded", buf, 0x26u);
      }
    }
    if (v11) {
      free(v11);
    }
  }
}

BOOL nw_protocol_tcp_add_input_handler(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    unsigned int v10 = "nw_protocol_tcp_add_input_handler";
    uint64_t v6 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      char v7 = __nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        unsigned int v10 = "nw_protocol_tcp_add_input_handler";
        char v8 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_21:
        _os_log_impl(&dword_214653000, v7, OS_LOG_TYPE_ERROR, v8, buf, 0xCu);
      }
    }
LABEL_22:
    if (v6) {
      free(v6);
    }
    return 0;
  }
  uint64_t v2 = nw_protocol_downcast();
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    unsigned int v10 = "nw_protocol_tcp_add_input_handler";
    uint64_t v6 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      char v7 = __nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        unsigned int v10 = "nw_protocol_tcp_add_input_handler";
        char v8 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
    goto LABEL_22;
  }
  uint64_t v3 = v2;
  if (*(_DWORD *)(v2 + 5224)) {
    return 0;
  }
  nw_protocol_set_input_handler();
  nw_protocol_set_flow_id_from_protocol();
  if (!nw_protocol_get_output_handler()) {
    nw_protocol_set_output_handler();
  }
  if (nw_protocol_supports_external_data()) {
    int v5 = 4096;
  }
  else {
    int v5 = 0;
  }
  *(_DWORD *)(v3 + 5308) = *(_DWORD *)(v3 + 5308) & 0xFFFFEFFF | v5;

  return nw_protocol_tcp_initialize(a1);
}

uint64_t nw_protocol_tcp_connect(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v9 = "nw_protocol_tcp_connect";
    uint64_t v4 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_24;
    }
    uint64_t v6 = __nwlog_obj();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    *(_DWORD *)long long buf = 136446210;
    int v9 = "nw_protocol_tcp_connect";
    char v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_23;
  }
  uint64_t v1 = nw_protocol_downcast();
  if (v1)
  {
    uint64_t v2 = v1;
    if ((*(unsigned char *)(v1 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        int v5 = __nwlog_tcp_log();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 136446466;
          int v9 = "nw_protocol_tcp_connect";
          __int16 v10 = 2082;
          uint64_t v11 = v2 + 604;
          _os_log_impl(&dword_214653000, v5, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s got connect event", buf, 0x16u);
        }
      }
    }
    if (*MEMORY[0x263F144B0] != -1) {
      dispatch_once(MEMORY[0x263F144B0], &__block_literal_global_18);
    }
    if (*MEMORY[0x263F144A8] && kdebug_is_enabled()) {
      kdebug_trace();
    }
    if (*(_DWORD *)(v2 + 5224) == 2)
    {
      nw_protocol_get_input_handler();
      nw_protocol_connected_quiet();
      return 1;
    }
    else
    {
      nw_protocol_get_output_handler();
      return nw_protocol_connect_quiet();
    }
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  int v9 = "nw_protocol_tcp_connect";
  uint64_t v4 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    uint64_t v6 = __nwlog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446210;
      int v9 = "nw_protocol_tcp_connect";
      char v7 = "%{public}s called with null tcp, backtrace limit exceeded";
LABEL_23:
      _os_log_impl(&dword_214653000, v6, OS_LOG_TYPE_ERROR, v7, buf, 0xCu);
    }
  }
LABEL_24:
  if (v4) {
    free(v4);
  }
  return 0;
}

uint64_t __nw_protocol_tcp_initialize_globals_block_invoke()
{
  tcp_input_batch_size = networkd_settings_get_int64_with_default();
  tcp_batch_ack_max = networkd_settings_get_int64_with_default();
  tcp_perf_measurement = networkd_settings_get_BOOL();
  g_use_slab_allocator = networkd_settings_get_int64_with_default() == 0;
  uint64_t result = networkd_settings_get_int64_with_default();
  tcp_timerlist_max_offset = result;
  return result;
}

BOOL nw_protocol_tcp_initialize(uint64_t a1)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  uint64_t v2 = nw_protocol_downcast();
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v43 = "nw_protocol_tcp_initialize";
    uint64_t v13 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_66;
    }
    unsigned int v30 = __nwlog_obj();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      goto LABEL_66;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v43 = "nw_protocol_tcp_initialize";
    uint64_t v31 = "%{public}s called with null tcp, backtrace limit exceeded";
LABEL_65:
    _os_log_impl(&dword_214653000, v30, OS_LOG_TYPE_ERROR, v31, buf, 0xCu);
    goto LABEL_66;
  }
  uint64_t v3 = v2;
  _os_feature_enabled_impl();
  nw_protocol_get_input_handler();
  local_endpoint = nw_protocol_get_local_endpoint();
  if (!local_endpoint)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v43 = "nw_protocol_tcp_initialize";
    uint64_t v13 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_66;
    }
    unsigned int v30 = __nwlog_obj();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      goto LABEL_66;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v43 = "nw_protocol_tcp_initialize";
    uint64_t v31 = "%{public}s get_local_endpoint failed, backtrace limit exceeded";
    goto LABEL_65;
  }
  int v5 = local_endpoint;
  *(void *)(v3 + 5272) = nw_endpoint_copy_address_string(local_endpoint);
  *(_WORD *)(v3 + 5300) = nw_endpoint_get_port(v5);
  remote_endpoint = nw_protocol_get_remote_endpoint();
  if (!remote_endpoint)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v43 = "nw_protocol_tcp_initialize";
    uint64_t v13 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_66;
    }
    unsigned int v30 = __nwlog_obj();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      goto LABEL_66;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v43 = "nw_protocol_tcp_initialize";
    uint64_t v31 = "%{public}s get_remote_endpoint failed, backtrace limit exceeded";
    goto LABEL_65;
  }
  char v7 = remote_endpoint;
  *(void *)(v3 + 5280) = nw_endpoint_copy_address_string(remote_endpoint);
  *(_WORD *)(v3 + 5302) = nw_endpoint_get_port(v7);
  address = nw_endpoint_get_address(v5);
  if (!address)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v43 = "nw_protocol_tcp_initialize";
    uint64_t v13 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_66;
    }
    unsigned int v30 = __nwlog_obj();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      goto LABEL_66;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v43 = "nw_protocol_tcp_initialize";
    uint64_t v31 = "%{public}s nw_endpoint_get_address failed, backtrace limit exceeded";
    goto LABEL_65;
  }
  int v9 = address;
  __int16 v10 = *(void **)(v3 + 5208);
  if (v10)
  {
    nw_release(v10);
    *(void *)(v3 + 5208) = 0;
  }
  path = (void *)nw_protocol_get_path();
  *(void *)(v3 + 5208) = path;
  if (path)
  {
    nw_retain(path);
    if (nw_path_is_viable()) {
      int v12 = 0x2000;
    }
    else {
      int v12 = 0;
    }
    *(_DWORD *)(v3 + 5308) = *(_DWORD *)(v3 + 5308) & 0xFFFFDFFF | v12;
  }
  else
  {
    int v14 = __nwlog_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v43 = "nw_protocol_tcp_initialize";
      _os_log_impl(&dword_214653000, v14, OS_LOG_TYPE_ERROR, "%{public}s Unable to get path from input protocol, will not be able to get stats", buf, 0xCu);
    }
  }
  nw_protocol_get_input_handler();
  if (!nw_protocol_get_parameters())
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v43 = "nw_protocol_tcp_initialize";
    uint64_t v13 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_66;
    }
    unsigned int v30 = __nwlog_obj();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      goto LABEL_66;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v43 = "nw_protocol_tcp_initialize";
    uint64_t v31 = "%{public}s called with null parameters, backtrace limit exceeded";
    goto LABEL_65;
  }
  int v15 = (void *)nw_parameters_copy_protocol_options_legacy();
  uint64_t v16 = v3 + 604;
  if (!nw_protocol_options_get_log_id_str() || !nw_protocol_options_get_log_id_str())
  {
    snprintf((char *)(v3 + 604), 0x54uLL, "tcp[%llu]", ++tcp_flow_gencnt);
    snprintf((char *)(v3 + 4852), 0x54uLL, "tcp[%llu]", tcp_flow_gencnt);
  }
  *(_WORD *)(v3 + 688) = nw_protocol_options_get_log_id_num();
  if (v15) {
    nw_release(v15);
  }
  if (nw_parameters_get_logging_disabled()) {
    char v17 = 2;
  }
  else {
    char v17 = 0;
  }
  *(unsigned char *)(v3 + 828) = *(unsigned char *)(v3 + 828) & 0xFD | v17;
  if (nw_parameters_get_sensitive_redacted()) {
    char v18 = 4;
  }
  else {
    char v18 = 0;
  }
  *(unsigned char *)(v3 + 828) = *(unsigned char *)(v3 + 828) & 0xFB | v18;
  uint64_t v19 = nw_parameters_copy_context();
  if (!v19)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v43 = "nw_protocol_tcp_initialize";
    uint64_t v13 = _os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      unsigned int v30 = __nwlog_obj();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v43 = "nw_protocol_tcp_initialize";
        uint64_t v31 = "%{public}s called with null context, backtrace limit exceeded";
        goto LABEL_65;
      }
    }
LABEL_66:
    if (v13)
    {
      int v37 = (void *)v13;
LABEL_79:
      free(v37);
    }
    return 0;
  }
  uint64_t v20 = v19;
  *(void *)(v3 + 5216) = nw_path_copy_flow_registration();
  *(void *)(v3 + 5200) = v20;
  nw_protocol_definition_t v21 = nw_protocol_copy_tcp_definition();
  *(void *)(v3 + 5240) = nw_context_get_globals_for_protocol();
  if (nw_context_get_logging_disabled()) {
    char v22 = 0x80;
  }
  else {
    char v22 = 0;
  }
  *(unsigned char *)(*(void *)(v3 + 5240) + 328) = v22 & 0x80 | *(unsigned char *)(*(void *)(v3 + 5240) + 328) & 0x7F;
  if (v21) {
    nw_release(v21);
  }
  *(void *)(v3 + 24) = a1;
  *(void *)(v3 + 40) = v3;
  int sa_family = v9->sa_family;
  if (sa_family == 2)
  {
    int v24 = &inetsw;
  }
  else
  {
    if (sa_family != 30)
    {
      int v26 = 22;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
LABEL_45:
      **(_DWORD **)(StatusReg + 8) = v26;
      int v28 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446722;
      uint64_t v43 = "nw_protocol_tcp_initialize";
      __int16 v44 = 2082;
      uint64_t v45 = v3 + 604;
      __int16 v46 = 1024;
      LODWORD(v47) = v28;
      uint64_t v29 = _os_log_send_and_compose_impl();
      if (!__nwlog_fault()
        || (int v33 = __nwlog_obj(), !os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)))
      {
LABEL_77:
        if (v29)
        {
          int v37 = (void *)v29;
          goto LABEL_79;
        }
        return 0;
      }
      *(_DWORD *)long long buf = 136446722;
      uint64_t v43 = "nw_protocol_tcp_initialize";
      __int16 v44 = 2082;
      uint64_t v45 = v16;
      __int16 v46 = 1024;
      LODWORD(v47) = v28;
      int v34 = "%{public}s %{public}s setup state failed %{darwin.errno}d, backtrace limit exceeded";
      int v35 = v33;
      uint32_t v36 = 28;
LABEL_76:
      _os_log_impl(&dword_214653000, v35, OS_LOG_TYPE_ERROR, v34, buf, v36);
      goto LABEL_77;
    }
    int v24 = &inet6sw;
  }
  *(void *)(v3 + 304) = 0;
  *(void *)(v3 + 312) = v3 + 304;
  *(void *)(v3 + 320) = 0;
  *(void *)(v3 + 328) = v3 + 320;
  *(void *)(v3 + 400) = 0;
  *(void *)(v3 + 408) = v3 + 400;
  *(void *)(v3 + 504) = 0;
  *(void *)(v3 + 512) = v3 + 504;
  *(void *)(v3 + 416) = 0;
  *(void *)(v3 + 424) = v3 + 416;
  *(void *)(v3 + 444) = 0;
  *(void *)(v3 + 520) = 0;
  *(void *)(v3 + 528) = v3 + 520;
  *(void *)(v3 + 548) = 0;
  *(_DWORD *)(v3 + 360) = 1;
  *(_DWORD *)(v3 + 536) |= 0x1004u;
  *(_DWORD *)(v3 + 432) |= 0x1000u;
  *(_WORD *)(v3 + 376) |= 0x100u;
  *(void *)(v3 + 456) = v3;
  *(void *)(v3 + 560) = v3;
  *(void *)uint64_t v3 = v3 + 832;
  *(void *)(v3 + 8) = v24;
  int v25 = (*(uint64_t (**)(uint64_t))(v24[5] + 8))(v3);
  if (v25)
  {
    int v26 = v25;
    *(_WORD *)(v3 + 376) |= 1u;
    --*(_DWORD *)(v3 + 360);
    sofreelastref(v3);
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    goto LABEL_45;
  }
  *(void *)(v3 + 32) = &nw_proto_north;
  int v32 = *(void **)v3;
  v32[267] = &nw_proto_south;
  v32[268] = v3;
  v32[269] = v3;
  *(_DWORD *)(v3 + 824) = networkd_settings_get_int64_with_default();
  if ((*(unsigned char *)(v3 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      int v40 = __nwlog_tcp_log();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
      {
        int v41 = *(_DWORD *)(v3 + 824);
        *(_DWORD *)long long buf = 136446722;
        uint64_t v43 = "nw_protocol_tcp_initialize";
        __int16 v44 = 2082;
        uint64_t v45 = v3 + 604;
        __int16 v46 = 1024;
        LODWORD(v47) = v41;
        _os_log_impl(&dword_214653000, v40, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s tcp_input_max_aggregate %u", buf, 0x1Cu);
      }
    }
  }
  if ((nw_protocol_tcp_apply_parameters(v3) & 1) == 0)
  {
    if ((*(unsigned char *)(v3 + 828) & 2) != 0) {
      return 0;
    }
    __nwlog_tcp_log();
    *(_DWORD *)long long buf = 136446466;
    uint64_t v43 = "nw_protocol_tcp_initialize";
    __int16 v44 = 2082;
    uint64_t v45 = v3 + 604;
    uint64_t v29 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_77;
    }
    int v39 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      goto LABEL_77;
    }
    *(_DWORD *)long long buf = 136446466;
    uint64_t v43 = "nw_protocol_tcp_initialize";
    __int16 v44 = 2082;
    uint64_t v45 = v16;
    int v34 = "%{public}s %{public}s apply socket parameters failed, backtrace limit exceeded";
    goto LABEL_75;
  }
  if ((*(unsigned int (**)(uint64_t, const sockaddr *))(*(void *)(*(void *)(v3 + 8) + 40) + 16))(v3, v9))
  {
    if ((*(unsigned char *)(v3 + 828) & 2) != 0) {
      return 0;
    }
    __nwlog_tcp_log();
    *(_DWORD *)long long buf = 136446466;
    uint64_t v43 = "nw_protocol_tcp_initialize";
    __int16 v44 = 2082;
    uint64_t v45 = v3 + 604;
    uint64_t v29 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_77;
    }
    int v39 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      goto LABEL_77;
    }
    *(_DWORD *)long long buf = 136446466;
    uint64_t v43 = "nw_protocol_tcp_initialize";
    __int16 v44 = 2082;
    uint64_t v45 = v16;
    int v34 = "%{public}s %{public}s tcp_bind failed, backtrace limit exceeded";
LABEL_75:
    int v35 = v39;
    uint32_t v36 = 22;
    goto LABEL_76;
  }
  if ((*(unsigned char *)(v3 + 372) & 2) == 0 || (BOOL result = nw_protocol_tcp_initialize_inbound(v3, v7)))
  {
    BOOL result = 1;
    *(_DWORD *)(v3 + 5224) = 1;
    *(_DWORD *)(v3 + 5308) |= 0x40000u;
  }
  return result;
}

uint64_t tcp_usr_bind(uint64_t *a1, uint64_t a2)
{
  v7[2] = *MEMORY[0x263EF8340];
  uint64_t v2 = *a1;
  if (!*a1 || *(_DWORD *)(v2 + 232) == 3) {
    return 22;
  }
  uint64_t v4 = nw_tcp_access_globals(*(void *)(v2 + 224));
  v5.n128_f64[0] = calculate_tcp_clock(v4);
  if (*(unsigned char *)(a2 + 1) && (*(unsigned char *)(a2 + 1) != 2 || (*(_DWORD *)(a2 + 4) & 0xF0) == 0xE0)) {
    return 47;
  }
  if (*(_WORD *)(v2 + 2226)) {
    return 22;
  }
  if (*(_DWORD *)(v2 + 492)) {
    return 22;
  }
  v7[0] = 0;
  v7[1] = 0;
  if (*(unsigned char *)a2 != 16) {
    return 22;
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, void *, uint64_t, __n128))(*(void *)(v2 + 2136) + 8))(*(void *)(v2 + 224), a2, 16, v7, 16, v5);
  if (!result)
  {
    if (HIDWORD(v7[0])) {
      *(_DWORD *)(v2 + 492) = HIDWORD(v7[0]);
    }
    uint64_t result = 0;
    *(_WORD *)(v2 + 2226) = WORD1(v7[0]);
  }
  return result;
}

uint64_t nw_proto_tcp_bind(uint64_t a1, const void *a2, int a3, void *__dst, size_t __n)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (!a2)
  {
    if (a1 && (*(unsigned char *)(a1 + 828) & 2) != 0) {
      return 0xFFFFFFFFLL;
    }
    __nwlog_tcp_log();
    if (a1) {
      char v7 = (const char *)(a1 + 604);
    }
    else {
      char v7 = "";
    }
    *(_DWORD *)long long buf = 136446466;
    uint64_t v13 = "nw_proto_tcp_bind";
    __int16 v14 = 2082;
    int v15 = v7;
    char v8 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_23;
    }
    __int16 v10 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    *(_DWORD *)long long buf = 136446466;
    uint64_t v13 = "nw_proto_tcp_bind";
    __int16 v14 = 2082;
    int v15 = v7;
    uint64_t v11 = "%{public}s %{public}s nam is NULL, backtrace limit exceeded";
    goto LABEL_22;
  }
  if (__dst)
  {
    memcpy(__dst, a2, __n);
    return 0;
  }
  if (!a1 || (*(unsigned char *)(a1 + 828) & 2) == 0)
  {
    __nwlog_tcp_log();
    if (a1) {
      int v9 = (const char *)(a1 + 604);
    }
    else {
      int v9 = "";
    }
    *(_DWORD *)long long buf = 136446466;
    uint64_t v13 = "nw_proto_tcp_bind";
    __int16 v14 = 2082;
    int v15 = v9;
    char v8 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_23;
    }
    __int16 v10 = __nwlog_tcp_log();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    *(_DWORD *)long long buf = 136446466;
    uint64_t v13 = "nw_proto_tcp_bind";
    __int16 v14 = 2082;
    int v15 = v9;
    uint64_t v11 = "%{public}s %{public}s outaddr is NULL, backtrace limit exceeded";
LABEL_22:
    _os_log_impl(&dword_214653000, v10, OS_LOG_TYPE_ERROR, v11, buf, 0x16u);
LABEL_23:
    if (v8) {
      free(v8);
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t ____nw_protocol_tcp_disconnect_block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if ((*(unsigned char *)(*(void *)(a1 + 32) + 5308) & 2) == 0)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (!v2 || (*(unsigned char *)(v2 + 828) & 2) == 0)
    {
      uint64_t v3 = __nwlog_tcp_log();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        uint64_t v4 = "";
        if (v2) {
          uint64_t v4 = (const char *)(v2 + 604);
        }
        int v6 = 136446466;
        char v7 = "__nw_protocol_tcp_disconnect_block_invoke";
        __int16 v8 = 2082;
        int v9 = v4;
        _os_log_impl(&dword_214653000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s send disconnect to input protocol", (uint8_t *)&v6, 0x16u);
      }
    }
    nw_protocol_get_input_handler();
    if (nw_protocol_disconnected_is_valid())
    {
      if (*MEMORY[0x263F144B0] != -1) {
        dispatch_once(MEMORY[0x263F144B0], &__block_literal_global_18);
      }
      if (*MEMORY[0x263F144A8] && kdebug_is_enabled()) {
        kdebug_trace();
      }
      nw_protocol_get_input_handler();
      nw_protocol_disconnected();
    }
    *(_DWORD *)(*(void *)(a1 + 32) + 5308) |= 2u;
  }
  tcp_close_locked(*(void *)(a1 + 40));
  return nw_protocol_release();
}

void tcp_close_locked(uint64_t a1)
{
  kern_return_t v51;
  uint64_t v52;
  unint64_t v53;
  int64_t v54;
  void *v55;
  NSObject *v56;
  int v57;
  int v58;
  os_log_type_t type[8];
  unsigned char buf[22];
  __int16 v61;
  unsigned char v62[10];
  uint64_t v63;

  int v63 = *MEMORY[0x263EF8340];
  if (!*(_DWORD *)(a1 + 360))
  {
    if ((*(unsigned char *)(a1 + 828) & 2) != 0) {
      return;
    }
    __nwlog_tcp_log();
    *(_DWORD *)long long buf = 136446722;
    *(void *)&uint8_t buf[4] = "tcp_close_locked";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = a1 + 604;
    int v61 = 2048;
    *(void *)int v62 = a1;
    uint64_t v7 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault()) {
      goto LABEL_122;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v8 = __nwlog_tcp_log();
      os_log_type_t v9 = type[0];
      if (!os_log_type_enabled(v8, type[0])) {
        goto LABEL_122;
      }
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "tcp_close_locked";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      int v61 = 2048;
      *(void *)int v62 = a1;
      uint64_t v10 = "%{public}s %{public}s soclose: so=%p refcount=0";
    }
    else
    {
      __int16 v8 = __nwlog_tcp_log();
      os_log_type_t v9 = type[0];
      if (!os_log_type_enabled(v8, type[0])) {
        goto LABEL_122;
      }
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "tcp_close_locked";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      int v61 = 2048;
      *(void *)int v62 = a1;
      uint64_t v10 = "%{public}s %{public}s soclose: so=%p refcount=0, backtrace limit exceeded";
    }
LABEL_121:
    _os_log_impl(&dword_214653000, v8, v9, v10, buf, 0x20u);
    goto LABEL_122;
  }
  if (*(_DWORD *)(a1 + 592))
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "soclose_wait_locked";
    uint64_t v3 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault()) {
      goto LABEL_19;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type[0];
      if (!os_log_type_enabled(v4, type[0])) {
        goto LABEL_19;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "soclose_wait_locked";
      int v6 = "%{public}s currently not supported";
    }
    else
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type[0];
      if (!os_log_type_enabled(v4, type[0])) {
        goto LABEL_19;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "soclose_wait_locked";
      int v6 = "%{public}s currently not supported, backtrace limit exceeded";
    }
    _os_log_impl(&dword_214653000, v4, v5, v6, buf, 0xCu);
LABEL_19:
    if (v3) {
      free(v3);
    }
  }
  *(_DWORD *)(a1 + 368) &= ~0x40u;
  int v11 = *(_DWORD *)(a1 + 372);
  if ((v11 & 2) != 0)
  {
    *(_DWORD *)(a1 + 372) = v11 & 0xFFFFFFFD;
    uint64_t v12 = *(void *)(a1 + 304);
    if (v12)
    {
      int v13 = 0;
      do
      {
        uint64_t v14 = v12;
        uint64_t v12 = *(void *)(v12 + 336);
        if ((*(unsigned char *)(v14 + 365) & 2) == 0)
        {
          uint64_t v15 = *(void *)(a1 + 8);
          uint64_t v16 = v12;
          if (*(void *)(v15 + 32))
          {
            (*(void (**)(uint64_t, void, uint64_t))(v15 + 24))(a1, 0, v1);
            int v13 = 1;
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v14 + 8) + 16))(v14, 1, v1);
            (*(void (**)(uint64_t, void, uint64_t))(*(void *)(a1 + 8) + 16))(a1, 0, v1);
            uint64_t v16 = *(void *)(v14 + 336);
          }
          char v17 = *(uint64_t **)(v14 + 344);
          if (v16)
          {
            *(void *)(v16 + 344) = v17;
            char v17 = *(uint64_t **)(v14 + 344);
          }
          else
          {
            *(void *)(a1 + 312) = v17;
          }
          *char v17 = v16;
          --*(_WORD *)(a1 + 356);
          if ((*(_WORD *)(v14 + 376) & 0x800) != 0)
          {
            *(_WORD *)(v14 + 376) &= ~0x800u;
            *(void *)(v14 + 296) = 0;
            int v18 = *(_DWORD *)(v14 + 364);
            if ((v18 & 0x100) == 0)
            {
              *(_DWORD *)(v14 + 364) = v18 | 0x100;
              if ((**(unsigned int (***)(uint64_t))(*(void *)(v14 + 8) + 40))(v14))
              {
                uint64_t v19 = *(void *)(v14 + 8);
                if (v19)
                {
                  uint64_t v20 = *(void (**)(uint64_t, void))(v19 + 32);
                  if (v20) {
                    v20(v14, 0);
                  }
                }
                sofreelastref(v14);
              }
            }
          }
          if (v13)
          {
            int v13 = 1;
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v14 + 8) + 24))(v14, 1, v1);
          }
        }
      }
      while (v12);
    }
    while (1)
    {
      uint64_t v27 = *(void *)(a1 + 320);
      if (!v27) {
        break;
      }
      uint64_t v21 = *(void *)(v27 + 336);
      char v22 = *(void **)(v27 + 344);
      if (v21)
      {
        *(void *)(v21 + 344) = v22;
        char v22 = *(void **)(v27 + 344);
      }
      else
      {
        *(void *)(a1 + 328) = v22;
      }
      *char v22 = v21;
      --*(_WORD *)(a1 + 352);
      uint64_t v23 = *(void *)(a1 + 8);
      if (*(void *)(v23 + 32))
      {
        (*(void (**)(uint64_t, void, uint64_t))(v23 + 24))(a1, 0, v1);
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v27 + 8) + 16))(v27, 1, v1);
      }
      if ((*(_WORD *)(v27 + 376) & 0x1000) != 0)
      {
        *(_WORD *)(v27 + 376) &= ~0x1000u;
        *(void *)(v27 + 296) = 0;
        int v24 = *(_DWORD *)(v27 + 364);
        if ((v24 & 0x100) == 0)
        {
          *(_DWORD *)(v27 + 364) = v24 | 0x100;
          if ((**(unsigned int (***)(uint64_t))(*(void *)(v27 + 8) + 40))(v27))
          {
            uint64_t v25 = *(void *)(v27 + 8);
            if (v25)
            {
              int v26 = *(void (**)(uint64_t, void))(v25 + 32);
              if (v26) {
                v26(v27, 0);
              }
            }
            sofreelastref(v27);
          }
        }
      }
      if (*(void *)(*(void *)(a1 + 8) + 32))
      {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v27 + 8) + 24))(v27, 1, v1);
        (*(void (**)(uint64_t, void, uint64_t))(*(void *)(a1 + 8) + 16))(a1, 0, v1);
      }
    }
  }
  if (!*(void *)a1)
  {
    int v33 = *(_DWORD *)(a1 + 364) | 4;
    *(_DWORD *)(a1 + 364) = v33;
LABEL_76:
    *(_WORD *)(a1 + 376) |= 1u;
    if ((v33 & 0x1000000) == 0) {
      goto LABEL_91;
    }
    goto LABEL_90;
  }
  if ((*(unsigned char *)(a1 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      int v56 = __nwlog_tcp_log();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
      {
        int v57 = *(_DWORD *)(a1 + 360);
        int v58 = *(__int16 *)(a1 + 376);
        *(_DWORD *)long long buf = 136446978;
        *(void *)&uint8_t buf[4] = "tcp_close_locked";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 604;
        int v61 = 1024;
        *(_DWORD *)int v62 = v57;
        *(_WORD *)&v62[4] = 1024;
        *(_DWORD *)&v62[6] = v58;
        _os_log_impl(&dword_214653000, v56, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s so_usecount %u so_state 0x%x", buf, 0x22u);
      }
    }
  }
  __int16 v28 = *(_WORD *)(a1 + 376);
  if ((v28 & 2) != 0
    && ((v28 & 8) != 0 || !(*(unsigned int (**)(uint64_t))(*(void *)(*(void *)(a1 + 8) + 40) + 40))(a1))
    && (*(unsigned char *)(a1 + 372) & 0x80) != 0
    && (~*(unsigned __int16 *)(a1 + 376) & 0x108) != 0)
  {
    uint64_t v37 = *(void *)(a1 + 8);
    if (v37 && (int v38 = *(uint64_t (**)(uint64_t, void))(v37 + 32)) != 0) {
      uint64_t v39 = v38(a1, 0);
    }
    else {
      uint64_t v39 = 0;
    }
    while ((*(_WORD *)(a1 + 376) & 2) != 0)
    {
      uint64_t v46 = *(void *)(a1 + 32);
      if (v46)
      {
        uint64_t v47 = *(unsigned int (**)(uint64_t, uint64_t, unsigned char *))(v46 + 112);
        if (v47)
        {
          int v48 = *(_DWORD *)(a1 + 16);
          int v49 = v48 / 100;
          int v50 = v48 % 100;
          *(void *)long long buf = 0;
          *(void *)&buf[8] = 0;
          if ((v48 + 99) > 0xC6 || (uint64_t v45 = 0, v50))
          {
            *(void *)os_log_type_t type = 0;
            int v51 = mach_timebase_info((mach_timebase_info_t)type);
            uint64_t v45 = 0;
            if (!v51)
            {
              int v52 = mach_absolute_time() * *(unsigned int *)type / *(unsigned int *)&type[4];
              int v53 = v52 / 0x3B9ACA00;
              int v54 = 10000000 * v50 + v52 % 0x3B9ACA00;
              *(void *)&buf[8] = v54;
              if (v54 > 999999999)
              {
                *(void *)&buf[8] = v54 - 1000000000;
                ++v53;
              }
              *(void *)long long buf = v53 + v49;
              uint64_t v45 = buf;
            }
          }
          if (v47(a1, v39, v45)) {
            break;
          }
        }
      }
    }
  }
  int v29 = *(_DWORD *)(a1 + 360);
  if (!v29)
  {
    if ((*(unsigned char *)(a1 + 828) & 2) != 0) {
      return;
    }
    __nwlog_tcp_log();
    *(_DWORD *)long long buf = 136446722;
    *(void *)&uint8_t buf[4] = "tcp_close_locked";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = a1 + 604;
    int v61 = 2048;
    *(void *)int v62 = a1;
    uint64_t v7 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault()) {
      goto LABEL_122;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v8 = __nwlog_tcp_log();
      os_log_type_t v9 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
LABEL_82:
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "tcp_close_locked";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 604;
        int v61 = 2048;
        *(void *)int v62 = a1;
        uint64_t v10 = "%{public}s %{public}s soclose: usecount is zero so=%p";
        goto LABEL_121;
      }
LABEL_122:
      if (!v7) {
        return;
      }
      int v55 = (void *)v7;
      goto LABEL_124;
    }
    __int16 v8 = __nwlog_tcp_log();
    os_log_type_t v9 = type[0];
    if (!os_log_type_enabled(v8, type[0])) {
      goto LABEL_122;
    }
LABEL_100:
    *(_DWORD *)long long buf = 136446722;
    *(void *)&uint8_t buf[4] = "tcp_close_locked";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = a1 + 604;
    int v61 = 2048;
    *(void *)int v62 = a1;
    uint64_t v10 = "%{public}s %{public}s soclose: usecount is zero so=%p, backtrace limit exceeded";
    goto LABEL_121;
  }
  if (*(void *)a1)
  {
    if ((*(unsigned char *)(a1 + 364) & 4) == 0)
    {
      uint64_t v30 = *(void *)(a1 + 8);
      if (v30)
      {
        uint64_t v31 = *(void *)(v30 + 40);
        if (v31)
        {
          int v32 = *(void (**)(uint64_t))(v31 + 32);
          if (v32)
          {
            v32(a1);
            int v29 = *(_DWORD *)(a1 + 360);
          }
        }
      }
    }
  }
  if (v29 <= 0)
  {
    if ((*(unsigned char *)(a1 + 828) & 2) != 0) {
      return;
    }
    __nwlog_tcp_log();
    *(_DWORD *)long long buf = 136446722;
    *(void *)&uint8_t buf[4] = "tcp_close_locked";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = a1 + 604;
    int v61 = 2048;
    *(void *)int v62 = a1;
    uint64_t v7 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault()) {
      goto LABEL_122;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v8 = __nwlog_tcp_log();
      os_log_type_t v9 = type[0];
      if (os_log_type_enabled(v8, type[0])) {
        goto LABEL_82;
      }
      goto LABEL_122;
    }
    __int16 v8 = __nwlog_tcp_log();
    os_log_type_t v9 = type[0];
    if (!os_log_type_enabled(v8, type[0])) {
      goto LABEL_122;
    }
    goto LABEL_100;
  }
  int v33 = *(_DWORD *)(a1 + 364);
  if (!*(void *)a1) {
    goto LABEL_76;
  }
  __int16 v34 = *(_WORD *)(a1 + 376);
  if ((v33 & 0x1000000) != 0)
  {
    *(_WORD *)(a1 + 376) = v34 | 1;
LABEL_90:
    *(_DWORD *)(a1 + 364) = v33 & 0xFEFFFFFF;
    goto LABEL_91;
  }
  if (v34)
  {
    if ((*(unsigned char *)(a1 + 828) & 2) != 0) {
      return;
    }
    __nwlog_tcp_log();
    uint64_t v40 = a1 + 604;
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = "tcp_close_locked";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = a1 + 604;
    uint64_t v41 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault()) {
      goto LABEL_129;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v42 = __nwlog_tcp_log();
      os_log_type_t v43 = type[0];
      if (os_log_type_enabled(v42, type[0]))
      {
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "tcp_close_locked";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v40;
        __int16 v44 = "%{public}s %{public}s soclose: NOFDREF";
LABEL_128:
        _os_log_impl(&dword_214653000, v42, v43, v44, buf, 0x16u);
      }
    }
    else
    {
      uint64_t v42 = __nwlog_tcp_log();
      os_log_type_t v43 = type[0];
      if (os_log_type_enabled(v42, type[0]))
      {
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "tcp_close_locked";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v40;
        __int16 v44 = "%{public}s %{public}s soclose: NOFDREF, backtrace limit exceeded";
        goto LABEL_128;
      }
    }
LABEL_129:
    if (!v41) {
      return;
    }
    int v55 = (void *)v41;
LABEL_124:
    free(v55);
    return;
  }
  *(_WORD *)(a1 + 376) = v34 | 1;
LABEL_91:
  --*(_DWORD *)(a1 + 360);
  uint64_t v35 = *(void *)(a1 + 8);
  if (v35)
  {
    uint32_t v36 = *(void (**)(uint64_t, void))(v35 + 32);
    if (v36) {
      v36(a1, 0);
    }
  }
  sofreelastref(a1);
}

uint64_t tcp_usr_detach(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (!*a1 || *(_DWORD *)(v1 + 232) == 3) {
    return 22;
  }
  (*(void (**)(void))(a1[1] + 32))();
  uint64_t v4 = *(void *)(v1 + 240);
  if (v4)
  {
    uint64_t v5 = nw_tcp_access_globals((uint64_t)a1);
    calculate_tcp_clock(v5);
    tcp_disconnect(v4);
  }
  return 0;
}

uint64_t tcp_usr_disconnect(uint64_t *a1)
{
  uint64_t v1 = *a1;
  (*(void (**)(void))(a1[1] + 32))();
  if (!v1 || *(_DWORD *)(v1 + 232) == 3) {
    return 22;
  }
  uint64_t v3 = *(void *)(v1 + 240);
  uint64_t v4 = nw_tcp_access_globals(*(void *)(v1 + 224));
  calculate_tcp_clock(v4);
  if (v3) {
    tcp_disconnect(v3);
  }
  return 0;
}

uint64_t sorflush(uint64_t a1)
{
  uint64_t v2 = a1 + 488;
  *(_WORD *)(a1 + 376) |= 0x20u;
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    uint64_t v4 = *(void (**)(uint64_t))(v3 + 40);
    if (v4) {
      v4(a1);
    }
  }
  sblock(v2);
  *(_DWORD *)(a1 + 536) |= 0x80u;
  sbunlock(v2);
  sbflush(v2);
  *(_DWORD *)(a1 + 492) = 0;
  uint64_t result = *(void *)(*(void *)(a1 + 560) + 24);
  if ((*(unsigned char *)(a1 + 536) & 4) != 0)
  {
    if (result)
    {
      uint64_t result = nw_protocol_tcp_get_all_stats();
      if (result) {
        *(_DWORD *)(result + 88) = *(_DWORD *)(a1 + 492);
      }
    }
  }
  else if (result)
  {
    uint64_t result = nw_protocol_tcp_get_all_stats();
    if (result) {
      *(_DWORD *)(result + 100) = *(_DWORD *)(a1 + 492);
    }
  }
  return result;
}

uint64_t sofreelastref(uint64_t result)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  if ((*(unsigned char *)(result + 364) & 4) == 0) {
    return result;
  }
  uint64_t v2 = result;
  if ((*(_WORD *)(result + 376) & 1) == 0) {
    return result;
  }
  uint64_t v3 = *(void *)(result + 296);
  if (!v3) {
    goto LABEL_22;
  }
  (*(void (**)(void, uint64_t, uint64_t))(*(void *)(v3 + 8) + 16))(*(void *)(result + 296), 1, v1);
  __int16 v4 = *(_WORD *)(v2 + 376);
  if ((v4 & 0x800) != 0)
  {
    uint64_t v6 = *(void *)(v2 + 336);
    uint64_t v7 = *(void **)(v2 + 344);
    if (v6)
    {
      *(void *)(v6 + 344) = v7;
      uint64_t v7 = *(void **)(v2 + 344);
    }
    else
    {
      *(void *)(v3 + 312) = v7;
    }
    *uint64_t v7 = v6;
    --*(_WORD *)(v3 + 356);
LABEL_21:
    --*(_WORD *)(v3 + 352);
    *(_WORD *)(v2 + 376) = v4 & 0xF7FF;
    *(void *)(v2 + 296) = 0;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v3 + 8) + 24))(v3, 1, v1);
LABEL_22:
    sblock(v2 + 384);
    *(_DWORD *)(v2 + 432) |= 0x80u;
    sbunlock(v2 + 384);
    sbflush(v2 + 384);
    *(_DWORD *)(v2 + 388) = 0;
    uint64_t v10 = *(void *)(*(void *)(v2 + 456) + 24);
    if ((*(unsigned char *)(v2 + 432) & 4) != 0)
    {
      if (v10)
      {
        uint64_t all_stats = nw_protocol_tcp_get_all_stats();
        if (all_stats) {
          *(_DWORD *)(all_stats + 88) = *(_DWORD *)(v2 + 388);
        }
      }
    }
    else if (v10)
    {
      uint64_t v11 = nw_protocol_tcp_get_all_stats();
      if (v11) {
        *(_DWORD *)(v11 + 100) = *(_DWORD *)(v2 + 388);
      }
    }
    return sorflush(v2);
  }
  if ((*(_WORD *)(v2 + 376) & 0x1000) == 0)
  {
    if ((*(unsigned char *)(v2 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      *(_DWORD *)long long buf = 136446466;
      uint64_t v14 = "sofreelastref";
      __int16 v15 = 2082;
      uint64_t v16 = v2 + 604;
      uint64_t v5 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        os_log_type_t v9 = __nwlog_tcp_log();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v14 = "sofreelastref";
          __int16 v15 = 2082;
          uint64_t v16 = v2 + 604;
          _os_log_impl(&dword_214653000, v9, OS_LOG_TYPE_ERROR, "%{public}s %{public}s sofree: not queued, backtrace limit exceeded", buf, 0x16u);
        }
      }
      if (v5) {
        free(v5);
      }
      __int16 v4 = *(_WORD *)(v2 + 376);
    }
    goto LABEL_21;
  }
  __int16 v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v3 + 8) + 24);

  return v8(v3, 1, v1);
}

void sbflush(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 72);
  sblock(a1);
  if (*(void *)(a1 + 32))
  {
    if (!v2 || (*(unsigned char *)(v2 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v16 = __nwlog_tcp_log();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v17 = "";
          if (v2) {
            uint64_t v17 = (const char *)(v2 + 604);
          }
          *(_DWORD *)long long buf = 136446466;
          char v22 = "sbflush";
          __int16 v23 = 2082;
          int v24 = v17;
          _os_log_impl(&dword_214653000, v16, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s sb_mb_aggregate not empty", buf, 0x16u);
        }
      }
    }
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4)
    {
      *(void *)&long long v3 = 136446210;
      do
      {
        uint64_t v7 = *(void *)(v4 + 32);
        __int16 v8 = *(void **)(v4 + 40);
        os_log_type_t v9 = (void *)(v4 + 32);
        if (v7)
        {
          *(void *)(v7 + 40) = v8;
          __int16 v8 = *(void **)(v4 + 40);
        }
        else
        {
          *(void *)(a1 + 40) = v8;
        }
        *__int16 v8 = v7;
        *os_log_type_t v9 = 0;
        *(void *)(v4 + 40) = 0;
        int v10 = *(_DWORD *)(a1 + 60);
        if (!v10)
        {
          long long v20 = v3;
          uint64_t v14 = __nwlog_obj();
          os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long buf = v20;
          char v22 = "sbflush";
          __int16 v15 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_abort())
          {
LABEL_27:
            __break(1u);
            return;
          }
          free(v15);
          int v10 = *(_DWORD *)(a1 + 60);
          long long v3 = v20;
        }
        *(_DWORD *)(a1 + 60) = v10 - 1;
        int v11 = *(_DWORD *)(v4 + 52);
        unsigned int v12 = *(_DWORD *)(a1 + 64);
        if (v11)
        {
          unsigned int v5 = v11 - (*(_DWORD *)(v4 + 56) + *(_DWORD *)(v4 + 60));
          if (v12 < v5)
          {
            long long v19 = v3;
            int v13 = __nwlog_obj();
            os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
            *(_DWORD *)long long buf = v19;
            char v22 = "sbflush";
            int v18 = (void *)_os_log_send_and_compose_impl();
            if (__nwlog_abort()) {
              goto LABEL_27;
            }
            free(v18);
            unsigned int v12 = *(_DWORD *)(a1 + 64);
            long long v3 = v19;
          }
        }
        else
        {
          unsigned int v5 = 0;
        }
        *(_DWORD *)(a1 + 64) = v12 - v5;
        *(void *)(v4 + 32) = 0;
        uint64_t v6 = *(void **)(a1 + 24);
        *(void *)(v4 + 40) = v6;
        *uint64_t v6 = v4;
        *(void *)(a1 + 24) = v9;
        uint64_t v4 = *(void *)(a1 + 32);
      }
      while (v4);
    }
    sb_agg_empty_verify((int *)a1, (uint64_t)"sbflush");
  }
  if (nw_frame_array_first()) {
    sbdrop((int *)a1, *(_DWORD *)a1);
  }
  sb_empty_assert((int *)a1, (uint64_t)"sbflush");
  sbunlock(a1);
}

void sbunlock(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 72);
  if ((*(_DWORD *)(v2 + 360) & 0x80000000) != 0)
  {
    if ((*(unsigned char *)(v2 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      int v6 = *(_DWORD *)(a1 + 48);
      int v7 = *(_DWORD *)(v2 + 360);
      *(_DWORD *)long long buf = 136447490;
      __int16 v15 = "sbunlock";
      __int16 v16 = 2082;
      uint64_t v17 = v2 + 604;
      __int16 v18 = 2048;
      uint64_t v19 = a1;
      __int16 v20 = 1024;
      int v21 = v6;
      __int16 v22 = 2048;
      uint64_t v23 = v2;
      __int16 v24 = 1024;
      int v25 = v7;
      __int16 v8 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        os_log_type_t v9 = __nwlog_tcp_log();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          int v10 = *(_DWORD *)(a1 + 48);
          int v11 = *(_DWORD *)(v2 + 360);
          *(_DWORD *)long long buf = 136447490;
          __int16 v15 = "sbunlock";
          __int16 v16 = 2082;
          uint64_t v17 = v2 + 604;
          __int16 v18 = 2048;
          uint64_t v19 = a1;
          __int16 v20 = 1024;
          int v21 = v10;
          __int16 v22 = 2048;
          uint64_t v23 = v2;
          __int16 v24 = 1024;
          int v25 = v11;
          _os_log_impl(&dword_214653000, v9, OS_LOG_TYPE_ERROR, "%{public}s %{public}s sb=%p sb_flags=0x%x sb_so=%p usecount=%d, backtrace limit exceeded", buf, 0x36u);
        }
      }
      if (v8) {
        free(v8);
      }
    }
  }
  else
  {
    int v3 = *(_DWORD *)(a1 + 48);
    if ((v3 & 1) == 0 && (*(__int16 *)(v2 + 376) & 0x80000000) == 0 && (*(unsigned char *)(v2 + 368) & 8) == 0)
    {
      unsigned int v12 = __nwlog_obj();
      os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long buf = 136446210;
      __int16 v15 = "sbunlock";
      int v13 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort())
      {
        __break(1u);
        return;
      }
      free(v13);
      int v3 = *(_DWORD *)(a1 + 48);
    }
    *(_DWORD *)(a1 + 48) = v3 & 0xFFFFFFFE;
    if (*(_DWORD *)(a1 + 56))
    {
      uint64_t v4 = *(void *)(v2 + 32);
      if ((v3 & 4) == 0)
      {
        if (!v4) {
          return;
        }
        unsigned int v5 = *(void (**)(uint64_t))(v4 + 8);
        if (!v5) {
          return;
        }
LABEL_15:
        v5(v2);
        return;
      }
      if (v4)
      {
        unsigned int v5 = *(void (**)(uint64_t))(v4 + 32);
        if (v5) {
          goto LABEL_15;
        }
      }
    }
  }
}

void sblock(uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 72);
  if ((*(_DWORD *)(v2 + 360) & 0x80000000) == 0)
  {
    int v3 = *(_DWORD *)(a1 + 48);
    if ((v3 & 1) == 0)
    {
LABEL_18:
      *(_DWORD *)(a1 + 48) = v3 | 1;
      return;
    }
    while (1)
    {
      uint64_t v4 = (*(uint64_t (**)(uint64_t, void))(*(void *)(v2 + 8) + 32))(v2, 0);
      int v5 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)(a1 + 56) = v5 + 1;
      if (v5 == -1)
      {
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
        *(_DWORD *)long long buf = 136446210;
        __int16 v20 = "sblock";
        __int16 v18 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_abort()) {
          goto LABEL_26;
        }
        free(v18);
      }
      uint64_t v6 = *(void *)(v2 + 32);
      if ((*(unsigned char *)(a1 + 48) & 4) != 0)
      {
        if (v6)
        {
          int v7 = *(void (**)(uint64_t, uint64_t, void))(v6 + 104);
          if (v7) {
LABEL_10:
          }
            v7(v2, v4, 0);
        }
      }
      else if (v6)
      {
        int v7 = *(void (**)(uint64_t, uint64_t, void))(v6 + 96);
        if (v7) {
          goto LABEL_10;
        }
      }
      int v8 = *(_DWORD *)(a1 + 56);
      if (!v8)
      {
        int v10 = __nwlog_obj();
        os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
        *(_DWORD *)long long buf = 136446210;
        __int16 v20 = "sblock";
        int v11 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_abort())
        {
LABEL_26:
          __break(1u);
          return;
        }
        free(v11);
        int v8 = *(_DWORD *)(a1 + 56);
      }
      *(_DWORD *)(a1 + 56) = v8 - 1;
      int v3 = *(_DWORD *)(a1 + 48);
      if ((v3 & 1) == 0) {
        goto LABEL_18;
      }
    }
  }
  if ((*(unsigned char *)(v2 + 828) & 2) == 0)
  {
    __nwlog_tcp_log();
    int v12 = *(_DWORD *)(a1 + 48);
    int v13 = *(_DWORD *)(v2 + 360);
    *(_DWORD *)long long buf = 136447490;
    __int16 v20 = "sblock";
    __int16 v21 = 2082;
    uint64_t v22 = v2 + 604;
    __int16 v23 = 2048;
    uint64_t v24 = a1;
    __int16 v25 = 1024;
    int v26 = v12;
    __int16 v27 = 2048;
    uint64_t v28 = v2;
    __int16 v29 = 1024;
    int v30 = v13;
    uint64_t v14 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      __int16 v15 = __nwlog_tcp_log();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        int v16 = *(_DWORD *)(a1 + 48);
        int v17 = *(_DWORD *)(v2 + 360);
        *(_DWORD *)long long buf = 136447490;
        __int16 v20 = "sblock";
        __int16 v21 = 2082;
        uint64_t v22 = v2 + 604;
        __int16 v23 = 2048;
        uint64_t v24 = a1;
        __int16 v25 = 1024;
        int v26 = v16;
        __int16 v27 = 2048;
        uint64_t v28 = v2;
        __int16 v29 = 1024;
        int v30 = v17;
        _os_log_impl(&dword_214653000, v15, OS_LOG_TYPE_ERROR, "%{public}s %{public}s sb=%p sb_flags=0x%x sb_so=%p usecount=%d, backtrace limit exceeded", buf, 0x36u);
      }
    }
    if (v14) {
      free(v14);
    }
  }
}

void sb_empty_assert(int *a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  if (*a1 || !nw_frame_array_is_empty() || *((void *)a1 + 4))
  {
    uint64_t v4 = *((void *)a1 + 9);
    if (!v4 || (*(unsigned char *)(v4 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      uint64_t v5 = *((void *)a1 + 9);
      int v6 = *a1;
      *(_DWORD *)long long buf = 136447746;
      if (v4) {
        int v7 = (const char *)(v4 + 604);
      }
      else {
        int v7 = "";
      }
      int v13 = "sb_empty_assert";
      __int16 v14 = 2082;
      __int16 v15 = v7;
      __int16 v16 = 2082;
      uint64_t v17 = a2;
      __int16 v18 = 2048;
      uint64_t v19 = a1;
      __int16 v20 = 2048;
      uint64_t v21 = v5;
      __int16 v22 = 1024;
      int v23 = v6;
      __int16 v24 = 2048;
      __int16 v25 = a1 + 4;
      int v8 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        os_log_type_t v9 = __nwlog_tcp_log();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          uint64_t v10 = *((void *)a1 + 9);
          int v11 = *a1;
          *(_DWORD *)long long buf = 136447746;
          int v13 = "sb_empty_assert";
          __int16 v14 = 2082;
          __int16 v15 = v7;
          __int16 v16 = 2082;
          uint64_t v17 = a2;
          __int16 v18 = 2048;
          uint64_t v19 = a1;
          __int16 v20 = 2048;
          uint64_t v21 = v10;
          __int16 v22 = 1024;
          int v23 = v11;
          __int16 v24 = 2048;
          __int16 v25 = a1 + 4;
          _os_log_impl(&dword_214653000, v9, OS_LOG_TYPE_ERROR, "%{public}s %{public}s %{public}s: sb %p so %p cc %d mb %p, backtrace limit exceeded", buf, 0x44u);
        }
      }
      if (v8) {
        free(v8);
      }
    }
  }
}

void __nw_protocol_tcp_timer_init_block_invoke(uint64_t a1)
{
  uint64_t v56 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(a1 + 40))
  {
    calculate_tcp_clock(*(void *)(a1 + 32));
    *(unsigned char *)(v1 + 310) &= ~2u;
    int v2 = *(_DWORD *)(v1 + 272);
    unsigned int v3 = *(_DWORD *)(v1 + 316) - v2;
    if (*(void *)(v1 + 256))
    {
      int v4 = v2 - *(_DWORD *)(v1 + 276);
      if ((int)v3 < 11)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          int v33 = __nwlog_obj();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
          {
            int v34 = *(_DWORD *)(v1 + 292);
            int v35 = *(_DWORD *)(v1 + 276);
            int v36 = *(_DWORD *)(v1 + 272);
            int v37 = *(_DWORD *)(v1 + 316);
            *(_DWORD *)long long buf = 136447746;
            os_log_type_t v43 = "tcp_run_timerlist";
            __int16 v44 = 1024;
            int v45 = v34;
            __int16 v46 = 1024;
            int v47 = v35;
            __int16 v48 = 1024;
            int v49 = v36;
            __int16 v50 = 1024;
            int v51 = v37;
            __int16 v52 = 1024;
            unsigned int v53 = v3;
            __int16 v54 = 1024;
            int v55 = v4;
            uint64_t v10 = v33;
            os_log_type_t v11 = OS_LOG_TYPE_DEBUG;
            goto LABEL_7;
          }
        }
      }
      else if ((*(char *)(v1 + 328) & 0x80000000) == 0)
      {
        uint64_t v5 = __nwlog_obj();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
        {
          int v6 = *(_DWORD *)(v1 + 292);
          int v7 = *(_DWORD *)(v1 + 276);
          int v8 = *(_DWORD *)(v1 + 272);
          int v9 = *(_DWORD *)(v1 + 316);
          *(_DWORD *)long long buf = 136447746;
          os_log_type_t v43 = "tcp_run_timerlist";
          __int16 v44 = 1024;
          int v45 = v6;
          __int16 v46 = 1024;
          int v47 = v7;
          __int16 v48 = 1024;
          int v49 = v8;
          __int16 v50 = 1024;
          int v51 = v9;
          __int16 v52 = 1024;
          unsigned int v53 = v3;
          __int16 v54 = 1024;
          int v55 = v4;
          uint64_t v10 = v5;
          os_log_type_t v11 = OS_LOG_TYPE_INFO;
LABEL_7:
          _os_log_impl(&dword_214653000, v10, v11, "%{public}s mode %d schedtime %u runtime %u tcp_now %u drift %d / offset %d", buf, 0x30u);
        }
      }
    }
    tcp_process_timerlist(v1);
    uint64_t v22 = *(void *)(v1 + 256);
    if (v22)
    {
      int v23 = *(void **)(v22 + 1008);
      if (v23)
      {
        if ((int)v3 > 1)
        {
          if (v3 > 0xA)
          {
            if (v3 > 0x14)
            {
              if (v3 > 0x32)
              {
                if (v3 > 0x64)
                {
                  if (v3 > 0xC8)
                  {
                    if (v3 > 0x1F4)
                    {
                      if (v3 > 0x3E8) {
                        ++v23[159];
                      }
                      else {
                        ++v23[158];
                      }
                    }
                    else
                    {
                      ++v23[157];
                    }
                  }
                  else
                  {
                    ++v23[156];
                  }
                }
                else
                {
                  ++v23[155];
                }
              }
              else
              {
                ++v23[154];
              }
            }
            else
            {
              ++v23[153];
            }
          }
          else
          {
            ++v23[152];
          }
        }
        else
        {
          ++v23[151];
        }
      }
    }
    return;
  }
  char v12 = *(unsigned char *)(v1 + 328);
  *(unsigned char *)(v1 + 328) = v12 & 0xF9;
  if ((v12 & 6) == 0) {
    goto LABEL_21;
  }
  int v13 = *(uint64_t **)(v1 + 112);
  if (!v13) {
    goto LABEL_21;
  }
  if ((v12 & 2) == 0)
  {
    if ((v12 & 4) != 0)
    {
      int v15 = 0;
      long long v16 = 0uLL;
      do
      {
        if (*((_DWORD *)v13 + 10) || *((_DWORD *)v13 + 11) || *((_DWORD *)v13 + 12))
        {
          *((_DWORD *)v13 + 12) = 0;
          v13[5] = 0;
        }
        if (*((_DWORD *)v13 + 13) || *((_DWORD *)v13 + 14) || *((_DWORD *)v13 + 15))
        {
          *((_DWORD *)v13 + 15) = 0;
          *(uint64_t *)((char *)v13 + 52) = 0;
          __int16 v27 = (void (*)(uint64_t, uint64_t *))v13[3];
          if (v27)
          {
            long long v40 = v16;
            v27(v1, v13);
            *((void *)&v28 + 1) = *((void *)&v40 + 1);
            *(int32x2_t *)&long long v28 = vadd_s32(*(int32x2_t *)((char *)v13 + 52), *(int32x2_t *)&v40);
            long long v16 = v28;
            v15 += *((_DWORD *)v13 + 15);
          }
        }
        int v13 = (uint64_t *)*v13;
      }
      while (v13);
      int v14 = 0;
      goto LABEL_22;
    }
    do
    {
      if (*((_DWORD *)v13 + 10) || *((_DWORD *)v13 + 11) || *((_DWORD *)v13 + 12))
      {
        *((_DWORD *)v13 + 12) = 0;
        v13[5] = 0;
      }
      if (*((_DWORD *)v13 + 13) || *((_DWORD *)v13 + 14) || *((_DWORD *)v13 + 15))
      {
        *((_DWORD *)v13 + 15) = 0;
        *(uint64_t *)((char *)v13 + 52) = 0;
      }
      int v13 = (uint64_t *)*v13;
    }
    while (v13);
LABEL_21:
    int v14 = 0;
    int v15 = 0;
    *(void *)&long long v16 = 0;
LABEL_22:
    *(void *)&long long v38 = 0;
    goto LABEL_23;
  }
  if ((v12 & 4) != 0)
  {
    int v15 = 0;
    int v14 = 0;
    long long v16 = 0uLL;
    long long v38 = 0u;
    do
    {
      long long v41 = v16;
      if (*((_DWORD *)v13 + 10) || *((_DWORD *)v13 + 11) || *((_DWORD *)v13 + 12))
      {
        *((_DWORD *)v13 + 12) = 0;
        v13[5] = 0;
        __int16 v29 = (void (*)(uint64_t, uint64_t *))v13[2];
        if (v29)
        {
          v29(v1, v13);
          *((void *)&v30 + 1) = *((void *)&v38 + 1);
          *(int32x2_t *)&long long v30 = vadd_s32((int32x2_t)v13[5], *(int32x2_t *)&v38);
          long long v38 = v30;
          long long v16 = v41;
          v14 += *((_DWORD *)v13 + 12);
        }
      }
      if (*((_DWORD *)v13 + 13) || *((_DWORD *)v13 + 14) || *((_DWORD *)v13 + 15))
      {
        *((_DWORD *)v13 + 15) = 0;
        *(uint64_t *)((char *)v13 + 52) = 0;
        uint64_t v31 = (void (*)(uint64_t, uint64_t *))v13[3];
        if (v31)
        {
          v31(v1, v13);
          *((void *)&v32 + 1) = *((void *)&v41 + 1);
          *(int32x2_t *)&long long v32 = vadd_s32(*(int32x2_t *)((char *)v13 + 52), *(int32x2_t *)&v41);
          long long v16 = v32;
          v15 += *((_DWORD *)v13 + 15);
        }
      }
      int v13 = (uint64_t *)*v13;
    }
    while (v13);
  }
  else
  {
    int v14 = 0;
    long long v16 = 0uLL;
    do
    {
      if (*((_DWORD *)v13 + 10) || *((_DWORD *)v13 + 11) || *((_DWORD *)v13 + 12))
      {
        *((_DWORD *)v13 + 12) = 0;
        v13[5] = 0;
        __int16 v25 = (void (*)(uint64_t, uint64_t *))v13[2];
        if (v25)
        {
          long long v39 = v16;
          v25(v1, v13);
          *((void *)&v26 + 1) = *((void *)&v39 + 1);
          *(int32x2_t *)&long long v26 = vadd_s32((int32x2_t)v13[5], *(int32x2_t *)&v39);
          long long v16 = v26;
          v14 += *((_DWORD *)v13 + 12);
        }
      }
      if (*((_DWORD *)v13 + 13) || *((_DWORD *)v13 + 14) || *((_DWORD *)v13 + 15))
      {
        *((_DWORD *)v13 + 15) = 0;
        *(uint64_t *)((char *)v13 + 52) = 0;
      }
      int v13 = (uint64_t *)*v13;
    }
    while (v13);
    *(void *)&long long v38 = v16;
    int v15 = 0;
    *(void *)&long long v16 = 0;
  }
LABEL_23:
  char v17 = *(unsigned char *)(v1 + 328);
  if ((void)v38) {
    char v18 = 2;
  }
  else {
    char v18 = 2 * (v14 != 0);
  }
  char v19 = v17 & 0xFD | v18;
  if ((*(unsigned char *)(v1 + 328) & 2) == 0) {
    char v17 = v19;
  }
  if ((void)v16) {
    char v20 = 4;
  }
  else {
    char v20 = 4 * (v15 != 0);
  }
  char v21 = v17 & 0xFB | v20;
  if ((v17 & 4) == 0) {
    char v17 = v21;
  }
  *(unsigned char *)(v1 + 328) = v17 & 0xFE;
  if (v14 | v15)
  {
    if ((v17 & 6) == 0) {
      return;
    }
  }
  else
  {
    if (vadd_s32(*(int32x2_t *)&v16, *(int32x2_t *)&v38).u32[1] <= 5)
    {
      if ((v17 & 6) == 0) {
        return;
      }
      char v24 = v17 & 0xF6 | 1;
      goto LABEL_48;
    }
    if ((v17 & 6) == 0) {
      return;
    }
  }
  char v24 = v17 | 9;
LABEL_48:
  *(unsigned char *)(v1 + 328) = v24;

  nw_protocol_timer_run_inner(v1, 1000000000, 0);
}

void tcp_gc(uint64_t a1, uint64_t a2)
{
  calculate_tcp_clock(a1);
  *(unsigned char *)(a1 + 328) |= 0x20u;
  int v4 = *(void **)(a1 + 104);
  while (v4)
  {
    uint64_t v5 = (uint64_t)v4;
    int v4 = (void *)*v4;
    if (tcp_garbage_collect(v5, 0)) {
      atomic_fetch_add((atomic_uint *volatile)(a2 + 44), 1u);
    }
  }
  uint64_t v6 = *(void *)(a1 + 128);
  while (v6)
  {
    uint64_t v7 = v6;
    uint64_t v6 = *(void *)(v6 + 824);
    if (!*(_DWORD *)(v7 + 12) || *(_DWORD *)(a1 + 316) - *(_DWORD *)(v7 + 44) >= 0)
    {
      if (tcp_garbage_collect(*(void *)(v7 + 80), 1)) {
        atomic_fetch_add((atomic_uint *volatile)(a2 + 40), 1u);
      }
    }
  }
  atomic_fetch_add((atomic_uint *volatile)(a2 + 40), *(_DWORD *)(a2 + 64));
}

uint64_t tcp_garbage_collect(uint64_t a1, int a2)
{
  uint64_t v83 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a1 + 224);
  uint64_t v5 = *(void *)(a1 + 240);
  uint64_t v6 = nw_tcp_access_globals(v4);
  int v7 = *(_DWORD *)(v4 + 360);
  if (v7 >= 2) {
    return *(_DWORD *)(a1 + 456) == 0xFFFF;
  }
  if (!a2)
  {
    if (v7 != 1) {
      goto LABEL_15;
    }
    if (!v5) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  if (*(_DWORD *)(v6 + 316) - *(_DWORD *)(v5 + 44) >= 0 && *(_DWORD *)(v5 + 12))
  {
    tcp_close(v5);
    int v7 = *(_DWORD *)(v4 + 360);
  }
  if (v7 == 1)
  {
    if ((*(unsigned char *)(v4 + 365) & 2) != 0)
    {
LABEL_9:
      if (*(_DWORD *)(a1 + 232) == 3)
      {
        int v9 = 1;
      }
      else
      {
        in_pcbdetach(a1);
        int v9 = *(_DWORD *)(v4 + 360);
        if (v9 <= 0 && (*(unsigned char *)(v4 + 828) & 2) == 0)
        {
          __nwlog_tcp_log();
          *(_DWORD *)long long buf = 136446466;
          int v68 = "tcp_garbage_collect";
          __int16 v69 = 2082;
          uint64_t v70 = v4 + 604;
          char v20 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            unsigned int v53 = __nwlog_tcp_log();
            if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 136446466;
              int v68 = "tcp_garbage_collect";
              __int16 v69 = 2082;
              uint64_t v70 = v4 + 604;
              _os_log_impl(&dword_214653000, v53, OS_LOG_TYPE_ERROR, "%{public}s %{public}s so->so_usecount <= 0, backtrace limit exceeded", buf, 0x16u);
            }
          }
          if (v20) {
            free(v20);
          }
          int v9 = *(_DWORD *)(v4 + 360);
        }
      }
      *(_DWORD *)(v4 + 360) = v9 - 1;
      return *(_DWORD *)(a1 + 456) == 0xFFFF;
    }
LABEL_13:
    if (!*(_DWORD *)(v5 + 12) && *(void *)(v4 + 296) && (~*(unsigned __int16 *)(v4 + 376) & 0x830) == 0) {
      goto LABEL_9;
    }
LABEL_14:
    int v7 = 1;
  }
LABEL_15:
  if (*(_DWORD *)(a1 + 456) != 0xFFFF) {
    return 0;
  }
  if (v7) {
    return 1;
  }
  if ((*(unsigned char *)(v4 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      uint64_t v64 = __nwlog_tcp_log();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 136446722;
        int v68 = "tcp_garbage_collect";
        __int16 v69 = 2082;
        uint64_t v70 = v4 + 604;
        __int16 v71 = 1024;
        LODWORD(v72) = 0;
        _os_log_impl(&dword_214653000, v64, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{network:tcp_state}d", buf, 0x1Cu);
      }
    }
  }
  if ((*(unsigned char *)(v5 + 91) & 0x40) != 0)
  {
    uint64_t v10 = nw_tcp_access_globals(*(void *)(*(void *)(v5 + 80) + 224));
    (*(void (**)(void))(*(void *)(*(void *)(*(void *)(v5 + 80) + 224) + 8) + 32))();
    int v11 = *(_DWORD *)(v5 + 88);
    if ((v11 & 0x40000000) != 0)
    {
      char v12 = *(uint64_t **)(v10 + 264);
      int v13 = (uint64_t *)(v5 + 48);
      if (v12) {
        BOOL v14 = v12 == v13;
      }
      else {
        BOOL v14 = 0;
      }
      if (v14) {
        *(void *)(v10 + 264) = *v12;
      }
      uint64_t v15 = *v13;
      if (*v13) {
        *(void *)(v15 + 8) = *(void *)(v5 + 56);
      }
      **(void **)(v5 + 56) = v15;
      *(_DWORD *)(v5 + 88) = v11 & 0xBFFFFFFF;
      --*(_DWORD *)(v10 + 280);
      *int v13 = 0;
      *(void *)(v5 + 56) = 0;
    }
  }
  if (*(_DWORD *)(a1 + 232) != 3) {
    in_pcbdetach(a1);
  }
  uint64_t v16 = *(void *)(a1 + 224);
  if (v16)
  {
    if (*(_DWORD *)(v16 + 360))
    {
      if ((*(unsigned char *)(v16 + 828) & 2) != 0) {
        return 0;
      }
      __nwlog_tcp_log();
      int v17 = **(_DWORD **)(*(void *)(v16 + 8) + 8);
      int v18 = *(_DWORD *)(v16 + 360);
      *(_DWORD *)long long buf = 136447234;
      int v68 = "in_pcbdispose";
      __int16 v69 = 2082;
      uint64_t v70 = v16 + 604;
      __int16 v71 = 2048;
      uint64_t v72 = v16;
      __int16 v73 = 1024;
      *(_DWORD *)uint64_t v74 = v17;
      *(_WORD *)&v74[4] = 1024;
      *(_DWORD *)&v74[6] = v18;
      uint64_t v19 = _os_log_send_and_compose_impl();
      if (!__nwlog_fault()) {
        goto LABEL_109;
      }
      int v34 = __nwlog_tcp_log();
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        goto LABEL_109;
      }
      int v35 = **(_DWORD **)(*(void *)(v16 + 8) + 8);
      int v36 = *(_DWORD *)(v16 + 360);
      *(_DWORD *)long long buf = 136447234;
      int v68 = "in_pcbdispose";
      __int16 v69 = 2082;
      uint64_t v70 = v16 + 604;
      __int16 v71 = 2048;
      uint64_t v72 = v16;
      __int16 v73 = 1024;
      *(_DWORD *)uint64_t v74 = v35;
      *(_WORD *)&v74[4] = 1024;
      *(_DWORD *)&v74[6] = v36;
      int v37 = "%{public}s %{public}s so %p [%d] usecount %d, backtrace limit exceeded";
      int v51 = v34;
      uint32_t v52 = 44;
      goto LABEL_108;
    }
    if (*(_DWORD *)(a1 + 456) != 0xFFFF)
    {
      if ((*(unsigned char *)(v16 + 828) & 2) != 0) {
        return 0;
      }
      __nwlog_tcp_log();
      int v28 = *(_DWORD *)(a1 + 456);
      int v29 = **(_DWORD **)(*(void *)(v16 + 8) + 8);
      int v30 = *(_DWORD *)(v16 + 360);
      int v31 = *(__int16 *)(v16 + 376);
      int v32 = *(_DWORD *)(v16 + 364);
      *(_DWORD *)long long buf = 136448258;
      int v68 = "in_pcbdispose";
      __int16 v69 = 2082;
      uint64_t v70 = v16 + 604;
      __int16 v71 = 2048;
      uint64_t v72 = a1;
      __int16 v73 = 1024;
      *(_DWORD *)uint64_t v74 = v28;
      *(_WORD *)&v74[4] = 2048;
      *(void *)&v74[6] = v16;
      __int16 v75 = 1024;
      int v76 = v29;
      __int16 v77 = 1024;
      int v78 = v30;
      __int16 v79 = 1024;
      int v80 = v31;
      __int16 v81 = 1024;
      int v82 = v32;
      uint64_t v33 = _os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        int v58 = __nwlog_tcp_log();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
        {
          int v59 = *(_DWORD *)(a1 + 456);
          int v60 = **(_DWORD **)(*(void *)(v16 + 8) + 8);
          int v61 = *(_DWORD *)(v16 + 360);
          int v62 = *(__int16 *)(v16 + 376);
          int v63 = *(_DWORD *)(v16 + 364);
          *(_DWORD *)long long buf = 136448258;
          int v68 = "in_pcbdispose";
          __int16 v69 = 2082;
          uint64_t v70 = v16 + 604;
          __int16 v71 = 2048;
          uint64_t v72 = a1;
          __int16 v73 = 1024;
          *(_DWORD *)uint64_t v74 = v59;
          *(_WORD *)&v74[4] = 2048;
          *(void *)&v74[6] = v16;
          __int16 v75 = 1024;
          int v76 = v60;
          __int16 v77 = 1024;
          int v78 = v61;
          __int16 v79 = 1024;
          int v80 = v62;
          __int16 v81 = 1024;
          int v82 = v63;
          _os_log_impl(&dword_214653000, v58, OS_LOG_TYPE_ERROR, "%{public}s %{public}s inp %p invalid wantcnt %d, so %p [%d] usecount %d retaincnt state 0x%x flags 0x%x, backtrace limit exceeded", buf, 0x48u);
        }
      }
      if (!v33) {
        return 0;
      }
      int v57 = (void *)v33;
      goto LABEL_111;
    }
  }
  else if (*(_DWORD *)(a1 + 456) != 0xFFFF)
  {
    __nwlog_obj();
    int v21 = *(_DWORD *)(a1 + 456);
    *(_DWORD *)long long buf = 136446722;
    int v68 = "in_pcbdispose";
    __int16 v69 = 2048;
    uint64_t v70 = a1;
    __int16 v71 = 1024;
    LODWORD(v72) = v21;
    uint64_t v22 = _os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      __int16 v54 = __nwlog_obj();
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
      {
        int v55 = *(_DWORD *)(a1 + 456);
        *(_DWORD *)long long buf = 136446722;
        int v68 = "in_pcbdispose";
        __int16 v69 = 2048;
        uint64_t v70 = a1;
        __int16 v71 = 1024;
        LODWORD(v72) = v55;
        _os_log_impl(&dword_214653000, v54, OS_LOG_TYPE_ERROR, "%{public}s inp %p invalid wantcnt %d no socket, backtrace limit exceeded", buf, 0x1Cu);
      }
    }
    if (!v22) {
      return 0;
    }
    int v57 = (void *)v22;
    goto LABEL_111;
  }
  int v23 = *(_DWORD *)(a1 + 2232);
  if ((v23 & 1) == 0)
  {
    uint64_t v24 = *(void *)a1;
    if (*(void *)a1) {
      *(void *)(v24 + 8) = *(void *)(a1 + 8);
    }
    **(void **)(a1 + 8) = v24;
    goto LABEL_64;
  }
  uint64_t v25 = *(void *)(a1 + 240);
  uint64_t v26 = *(void *)(v25 + 824);
  uint64_t v27 = *(void *)(v25 + 832);
  if (v26)
  {
    *(void *)(v26 + 832) = v27;
  }
  else
  {
    *(void *)(nw_tcp_access_globals(*(void *)(a1 + 224)) + 136) = v27;
    uint64_t v26 = *(void *)(v25 + 824);
    int v23 = *(_DWORD *)(a1 + 2232);
  }
  **(void **)(v25 + 832) = v26;
  *(_DWORD *)(a1 + 2232) = v23 & 0xFFFFFFFE;
  uint64_t v38 = *(void *)(a1 + 16);
  int v39 = *(_DWORD *)(v38 + 64);
  if (v39)
  {
LABEL_62:
    *(_DWORD *)(v38 + 64) = v39 - 1;
    uint64_t v40 = *(void *)(*(void *)(a1 + 240) + 1056);
    if (v40) {
      --*(void *)(v40 + 1696);
    }
LABEL_64:
    if (!v16) {
      return 0;
    }
    sofreelastref(v16);
    if (*(_DWORD *)(v16 + 488) || *(_DWORD *)(v16 + 384))
    {
      sbflush(v16 + 488);
      *(_DWORD *)(v16 + 492) = 0;
      uint64_t v41 = *(void *)(*(void *)(v16 + 560) + 24);
      if ((*(unsigned char *)(v16 + 536) & 4) != 0)
      {
        if (v41)
        {
          uint64_t all_stats = nw_protocol_tcp_get_all_stats();
          if (all_stats) {
            *(_DWORD *)(all_stats + 88) = *(_DWORD *)(v16 + 492);
          }
        }
      }
      else if (v41)
      {
        uint64_t v42 = nw_protocol_tcp_get_all_stats();
        if (v42) {
          *(_DWORD *)(v42 + 100) = *(_DWORD *)(v16 + 492);
        }
      }
      sbflush(v16 + 384);
      *(_DWORD *)(v16 + 388) = 0;
      uint64_t v44 = *(void *)(*(void *)(v16 + 456) + 24);
      if ((*(unsigned char *)(v16 + 432) & 4) != 0)
      {
        if (v44)
        {
          uint64_t v46 = nw_protocol_tcp_get_all_stats();
          if (v46) {
            *(_DWORD *)(v46 + 88) = *(_DWORD *)(v16 + 388);
          }
        }
      }
      else if (v44)
      {
        uint64_t v45 = nw_protocol_tcp_get_all_stats();
        if (v45) {
          *(_DWORD *)(v45 + 100) = *(_DWORD *)(v16 + 388);
        }
      }
    }
    if (!*(void *)(v16 + 296))
    {
      *(_DWORD *)(v16 + 364) |= 4u;
      *(void *)uint64_t v16 = 0;
      *(void *)(a1 + 224) = 0;
      uint64_t v47 = *(void *)(a1 + 496);
      if (v47)
      {
        if (*(unsigned char *)(v47 + 1496))
        {
          __int16 v48 = *(void **)(v47 + 1488);
          if (v48)
          {
            free(v48);
            uint64_t v47 = *(void *)(a1 + 496);
            *(void *)(v47 + 1488) = 0;
          }
          *(unsigned char *)(v47 + 1496) = 0;
        }
        *(void *)(a1 + 496) = 0;
      }
      uint64_t v49 = *(void *)(v16 + 32);
      if (v49)
      {
        __int16 v50 = *(void (**)(uint64_t))(v49 + 64);
        if (v50) {
          v50(v16);
        }
      }
      return 0;
    }
    if ((*(unsigned char *)(v16 + 828) & 2) != 0) {
      return 0;
    }
    __nwlog_tcp_log();
    *(_DWORD *)long long buf = 136446722;
    int v68 = "in_pcbdispose";
    __int16 v69 = 2082;
    uint64_t v70 = v16 + 604;
    __int16 v71 = 2048;
    uint64_t v72 = v16;
    uint64_t v19 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault()
      || (uint64_t v56 = __nwlog_tcp_log(), !os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)))
    {
LABEL_109:
      if (v19)
      {
        int v57 = (void *)v19;
LABEL_111:
        free(v57);
      }
      return 0;
    }
    *(_DWORD *)long long buf = 136446722;
    int v68 = "in_pcbdispose";
    __int16 v69 = 2082;
    uint64_t v70 = v16 + 604;
    __int16 v71 = 2048;
    uint64_t v72 = v16;
    int v37 = "%{public}s %{public}s so=%p head still exist, backtrace limit exceeded";
    int v51 = v56;
    uint32_t v52 = 32;
LABEL_108:
    _os_log_impl(&dword_214653000, v51, OS_LOG_TYPE_ERROR, v37, buf, v52);
    goto LABEL_109;
  }
  int v65 = __nwlog_obj();
  os_log_type_enabled(v65, OS_LOG_TYPE_ERROR);
  *(_DWORD *)long long buf = 136446210;
  int v68 = "in_pcbremlists";
  unsigned int v66 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!result)
  {
    free(v66);
    uint64_t v38 = *(void *)(a1 + 16);
    int v39 = *(_DWORD *)(v38 + 64);
    goto LABEL_62;
  }
  __break(1u);
  return result;
}

void nw_protocol_tcp_wake_disconnected(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_DWORD *)(v2 + 5224) == 4)
  {
    if ((*(unsigned char *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
    {
      unsigned int v3 = __nwlog_tcp_log();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 136446466;
        uint64_t v6 = "nw_protocol_tcp_wake_disconnected";
        __int16 v7 = 2082;
        uint64_t v8 = a1 + 604;
        _os_log_impl(&dword_214653000, v3, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
      }
    }
  }
  else
  {
    *(_DWORD *)(v2 + 5224) = 4;
    if ((*(unsigned char *)(a1 + 828) & 2) == 0)
    {
      uint64_t v4 = __nwlog_tcp_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 136446466;
        uint64_t v6 = "nw_protocol_tcp_wake_disconnected";
        __int16 v7 = 2082;
        uint64_t v8 = a1 + 604;
        _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_INFO, "%{public}s %{public}s tcp disconnected", buf, 0x16u);
      }
    }
    if (*MEMORY[0x263F144B0] != -1) {
      dispatch_once(MEMORY[0x263F144B0], &__block_literal_global_18);
    }
    if (*MEMORY[0x263F144A8] && kdebug_is_enabled()) {
      kdebug_trace();
    }
    nw_protocol_upcast();
    nw_protocol_retain();
    nw_queue_context_async();
  }
}

void *__tcp_publish_necp_if_stats_block_invoke(void *result, uint64_t a2)
{
  *(void *)(a2 + 96) = 0;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  __int16 v2 = (*(unsigned char *)(result[4] + 2236) & 2) == 0;
  *(_WORD *)(a2 + 96) = v2;
  __int16 v3 = *(_WORD *)(result[5] + 90) & 2 | v2;
  *(_WORD *)(a2 + 96) = v3;
  __int16 v4 = v3 | (4 * (*(_WORD *)(result[6] + 378) == 54));
  *(_WORD *)(a2 + 96) = v4;
  __int16 v5 = v4 | (8 * (*(_WORD *)(result[6] + 378) == 60));
  *(_WORD *)(a2 + 96) = v5;
  uint64_t v6 = result[5];
  *(_DWORD *)(a2 + 92) = *(_DWORD *)(v6 + 348);
  int v7 = *(_DWORD *)(v6 + 708);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(v6 + 712);
  *(_DWORD *)(a2 + 28) = v7;
  int v8 = *(_DWORD *)(v6 + 996);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(v6 + 720);
  *(_DWORD *)(a2 + 36) = v8;
  *(void *)&long long v9 = *(void *)(v6 + 1000);
  *((void *)&v9 + 1) = *(void *)(v6 + 1016);
  *(_OWORD *)(a2 + 40) = v9;
  int v10 = *(_DWORD *)(v6 + 200);
  *(_DWORD *)(a2 + 56) = *(_DWORD *)(v6 + 1024);
  *(_DWORD *)(a2 + 60) = v10;
  int v11 = *(_DWORD *)(v6 + 208);
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(v6 + 240);
  *(_DWORD *)(a2 + 68) = v11;
  uint64_t v12 = *(void *)(*(void *)(v6 + 80) + 496);
  if (v12)
  {
    uint64_t v12 = *(void *)(v12 + 1488);
    if (v12) {
      LODWORD(v12) = *(_DWORD *)(v12 + 40);
    }
  }
  *(_DWORD *)(a2 + 72) = v12;
  uint64_t v13 = *(void *)(v6 + 768);
  if (v13)
  {
    *(_DWORD *)(a2 + 76) = *(_DWORD *)(v13 + 32);
    int v14 = *(_DWORD *)(v13 + 36);
    if (v14) {
      goto LABEL_9;
    }
  }
  else
  {
    *(_DWORD *)(a2 + 76) = 0;
  }
  int v14 = 0;
LABEL_9:
  *(_DWORD *)(a2 + 80) = v14;
  uint64_t v15 = result[4];
  uint64_t v16 = *(void **)(v15 + 248);
  uint64_t v17 = v16[2];
  *(void *)a2 = *(void *)(result[6] + 744);
  *(void *)(a2 + 8) = v17;
  *(void *)(a2 + 16) = *v16;
  uint64_t v18 = *(void *)(v15 + 448);
  if (v18)
  {
    uint64_t v19 = (void *)(v18 + 504);
    char v20 = (void *)(v18 + 120);
    if ((*(unsigned char *)(v15 + 2236) & 2) != 0) {
      int v21 = v19;
    }
    else {
      int v21 = v20;
    }
    uint64_t v22 = v21[8];
    *(_DWORD *)(a2 + 84) = v21[9];
    *(_DWORD *)(a2 + 88) = v22;
    __int16 v23 = v5 | ((v21[17] != 0) << 8);
    *(_WORD *)(a2 + 96) = v23;
    *(_WORD *)(a2 + 96) = v23 | ((v21[16] != 0) << 9);
  }
  return result;
}

void nw_tcp_init_globals(uint64_t a1, uint64_t a2)
{
  __int16 v4 = malloc_type_calloc(1uLL, 0x48uLL, 0xEAFB8F1AuLL);
  if (!v4)
  {
    int v7 = __nwlog_obj();
    os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
    int v8 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort()) {
      goto LABEL_8;
    }
    free(v8);
  }
  *(void *)(a1 + 72) = v4;
  sysctls = nw_path_get_sysctls_region();
  tcp_init(a1);
  xmmword_26AA46530 = 0u;
  unk_26AA46540 = 0u;
  xmmword_26AA46510 = 0u;
  unk_26AA46520 = 0u;
  xmmword_26AA464F0 = 0u;
  unk_26AA46500 = 0u;
  tcp_cc_algo_none = 0u;
  unk_26AA464E0 = 0u;
  tcp_cc_algo_list[0] = (uint64_t)&tcp_cc_algo_none;
  *(void *)algn_26AA465B8 = tcp_cc_newreno;
  qword_26AA465C0 = (uint64_t)tcp_cc_ledbat;
  unk_26AA465C8 = tcp_cc_cubic;
  qword_26AA465D0 = (uint64_t)tcp_cc_prague;
  __int16 v5 = malloc_type_calloc(0x64uLL, 8uLL, 0xEAFB8F1AuLL);
  if (v5)
  {
LABEL_3:
    *(void *)(a1 + 32) = v5;
    *(_DWORD *)(a1 + 312) = arc4random();
    nw_protocol_tcp_timer_init(a1, a2, 1);
    nw_protocol_tcp_timer_init(a1, a2, 0);
    *(void *)(a1 + 144) = 0;
    uint64_t v6 = (void *)(a1 + 144);
    v6[1] = v6;
    v6[2] = 0;
    v6[3] = v6 + 2;
    v6[4] = 0;
    v6[5] = v6 + 4;
    v6[6] = 0;
    v6[7] = v6 + 6;
    v6[8] = 0;
    v6[9] = v6 + 8;
    v6[10] = 0;
    v6[11] = v6 + 10;
    return;
  }
  long long v9 = __nwlog_obj();
  os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
  int v10 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort())
  {
    free(v10);
    goto LABEL_3;
  }
LABEL_8:
  __break(1u);
}

void nw_protocol_tcp_timer_init(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (a3) {
    uint64_t v4 = 88;
  }
  else {
    uint64_t v4 = 96;
  }
  uint64_t source = nw_queue_context_create_source();
  *(void *)(a1 + v4) = source;
  if (source)
  {
    if ((networkd_settings_get_BOOL() & 1) == 0) {
      nw_queue_source_set_qos_class_fallback();
    }
    nw_queue_activate_source();
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    long long v9 = "nw_protocol_tcp_timer_init";
    uint64_t v6 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v7 = __nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        long long v9 = "nw_protocol_tcp_timer_init";
        _os_log_impl(&dword_214653000, v7, OS_LOG_TYPE_ERROR, "%{public}s nw_queue_context_create_source failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v6) {
      free(v6);
    }
  }
}

void tcp_init(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  if ((*(unsigned char *)(a1 + 328) & 0x40) != 0) {
    return;
  }
  *(unsigned char *)(a1 + 328) |= 0x40u;
  uint64_t v2 = sysctls;
  unsigned int v3 = *(_DWORD *)(sysctls + 240);
  *(void *)(a1 + 240) = v3 / 0xF4240uLL;
  *(_DWORD *)(a1 + 248) = v3 % 0xF4240;
  *(_DWORD *)(a1 + 316) = *(_DWORD *)(v2 + 244);
  arc4random_buf(&__buf, 0x10uLL);
  if (CCCryptorCreate(0, 0, 2u, &__buf, 0x10uLL, 0, (CCCryptorRef *)(a1 + 80)))
  {
    uint64_t v4 = __nwlog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446210;
      int v21 = "aes_encrypt_key128";
      _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_ERROR, "%{public}s CCCryptorCreate", buf, 0xCu);
    }
  }
  __int16 v5 = *(void **)(a1 + 72);
  v5[2] = tcp_gc;
  v5[3] = tcp_itimer;
  v5[4] = a1 + 104;
  *(void *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 324) = 128;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 120) = a1 + 112;
  uint64_t v6 = (void *)(a1 + 112);
  do
  {
    uint64_t v6 = (void *)*v6;
    if (!v6)
    {
      *__int16 v5 = 0;
      v5[1] = a1 + 112;
      *(void *)(a1 + 112) = v5;
      *(void *)(a1 + 120) = v5;
      goto LABEL_18;
    }
  }
  while (v6 != v5);
  __nwlog_obj();
  int __buf = 136446466;
  __int16 v23 = "in_pcbinfo_attach";
  __int16 v24 = 2048;
  uint64_t v25 = v5;
  int v7 = (void *)_os_log_send_and_compose_impl();
  buf[0] = 16;
  if (__nwlog_fault())
  {
    if (buf[0] == 17)
    {
      int v8 = __nwlog_obj();
      os_log_type_t v9 = buf[0];
      if (!os_log_type_enabled(v8, (os_log_type_t)buf[0])) {
        goto LABEL_16;
      }
      int __buf = 136446466;
      __int16 v23 = "in_pcbinfo_attach";
      __int16 v24 = 2048;
      uint64_t v25 = v5;
      uint64_t v10 = "%{public}s ipi %p already in the list";
    }
    else
    {
      int v8 = __nwlog_obj();
      os_log_type_t v9 = buf[0];
      if (!os_log_type_enabled(v8, (os_log_type_t)buf[0])) {
        goto LABEL_16;
      }
      int __buf = 136446466;
      __int16 v23 = "in_pcbinfo_attach";
      __int16 v24 = 2048;
      uint64_t v25 = v5;
      uint64_t v10 = "%{public}s ipi %p already in the list, backtrace limit exceeded";
    }
    _os_log_impl(&dword_214653000, v8, v9, v10, (uint8_t *)&__buf, 0x16u);
  }
LABEL_16:
  if (v7) {
    free(v7);
  }
LABEL_18:
  int v11 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
  if (v11) {
    *int v11 = 32;
  }
  *(void *)(a1 + 40) = v11;
  uint64_t v12 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
  if (v12)
  {
    *uint64_t v12 = 48;
    *(void *)(a1 + 48) = v12;
    uint64_t v13 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
    if (v13) {
      *uint64_t v13 = 24;
    }
    *(void *)(a1 + 56) = v13;
    int v14 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
    if (v14) {
      *int v14 = 88;
    }
    *(void *)(a1 + 128) = 0;
    uint64_t v15 = a1 + 128;
    *(void *)(v15 - 64) = v14;
    *(void *)(v15 + 8) = v15;
    *(_OWORD *)(v15 + 128) = 0u;
    *(_OWORD *)(v15 + 144) = 0u;
    *(_OWORD *)(v15 + 160) = 0u;
    *(void *)(v15 + 176) = 0;
    return;
  }
  *(void *)(a1 + 48) = 0;
  __nwlog_obj();
  int __buf = 136446210;
  __int16 v23 = "tcp_init";
  uint64_t v16 = (void *)_os_log_send_and_compose_impl();
  buf[0] = 16;
  if (__nwlog_fault())
  {
    if (buf[0] == 17)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = buf[0];
      if (!os_log_type_enabled(v17, (os_log_type_t)buf[0])) {
        goto LABEL_33;
      }
      int __buf = 136446210;
      __int16 v23 = "tcp_init";
      uint64_t v19 = "%{public}s failed allocating tcp_reass_zone";
    }
    else
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = buf[0];
      if (!os_log_type_enabled(v17, (os_log_type_t)buf[0])) {
        goto LABEL_33;
      }
      int __buf = 136446210;
      __int16 v23 = "tcp_init";
      uint64_t v19 = "%{public}s failed allocating tcp_reass_zone, backtrace limit exceeded";
    }
    _os_log_impl(&dword_214653000, v17, v18, v19, (uint8_t *)&__buf, 0xCu);
  }
LABEL_33:
  if (v16) {
    free(v16);
  }
}

uint64_t nw_protocol_tcp_register_notification(uint64_t a1, uint64_t a2, int a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v9 = nw_protocol_downcast();
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = 1;
      switch(a3)
      {
        case 0:
          __nwlog_obj();
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = nw_protocol_notification_type_to_string();
          uint64_t v12 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          if (!__nwlog_fault()) {
            goto LABEL_63;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            uint64_t v13 = __nwlog_obj();
            os_log_type_t v14 = type[0];
            if (!os_log_type_enabled(v13, type[0])) {
              goto LABEL_63;
            }
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = nw_protocol_notification_type_to_string();
            uint64_t v15 = "%{public}s invalid registration notification: %{public}s";
          }
          else
          {
            uint64_t v13 = __nwlog_obj();
            os_log_type_t v14 = type[0];
            if (!os_log_type_enabled(v13, type[0])) {
              goto LABEL_63;
            }
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = nw_protocol_notification_type_to_string();
            uint64_t v15 = "%{public}s invalid registration notification: %{public}s, backtrace limit exceeded";
          }
          goto LABEL_61;
        case 1:
          if (!a4)
          {
            __nwlog_obj();
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
            uint64_t v12 = (void *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            if (!__nwlog_fault()) {
              goto LABEL_63;
            }
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              int v28 = __nwlog_obj();
              os_log_type_t v29 = type[0];
              if (!os_log_type_enabled(v28, type[0])) {
                goto LABEL_63;
              }
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              uint64_t v15 = "%{public}s called with null val";
            }
            else
            {
              int v28 = __nwlog_obj();
              os_log_type_t v29 = type[0];
              if (!os_log_type_enabled(v28, type[0])) {
                goto LABEL_63;
              }
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              uint64_t v15 = "%{public}s called with null val, backtrace limit exceeded";
            }
            goto LABEL_95;
          }
          if (a5)
          {
            *(_DWORD *)os_log_type_t type = *a4;
            *(void *)long long buf = 0x600000001;
            *(void *)&buf[8] = 517;
            *(void *)&buf[16] = type;
            uint64_t v32 = 4;
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 + 8) + 16))(v9, 1, v5);
            if ((~*(unsigned __int16 *)(v10 + 376) & 0x30) != 0 || (*(unsigned char *)(v10 + 365) & 0x20) != 0) {
              int v16 = tcp_ctloutput(v10, (uint64_t)buf);
            }
            else {
              int v16 = 22;
            }
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v10 + 8) + 24))(v10, 1, v5);
            if (!v16)
            {
              int v23 = *(_DWORD *)(v10 + 5308) | 0x40;
              goto LABEL_45;
            }
            __nwlog_obj();
            uint64_t v19 = v10 + 604;
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v10 + 604;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v32) = v16;
            uint64_t v12 = (void *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            if (!__nwlog_fault()) {
              goto LABEL_63;
            }
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              char v20 = __nwlog_obj();
              os_log_type_t v21 = type[0];
              if (!os_log_type_enabled(v20, type[0])) {
                goto LABEL_63;
              }
              *(_DWORD *)long long buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v19;
              *(_WORD *)&unsigned char buf[22] = 1024;
              LODWORD(v32) = v16;
              uint64_t v15 = "%{public}s %{public}s tcp_set_read_timeout failed %{darwin.errno}d";
            }
            else
            {
              char v20 = __nwlog_obj();
              os_log_type_t v21 = type[0];
              if (!os_log_type_enabled(v20, type[0])) {
                goto LABEL_63;
              }
              *(_DWORD *)long long buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v19;
              *(_WORD *)&unsigned char buf[22] = 1024;
              LODWORD(v32) = v16;
              uint64_t v15 = "%{public}s %{public}s tcp_set_read_timeout failed %{darwin.errno}d, backtrace limit exceeded";
            }
            goto LABEL_60;
          }
          __nwlog_obj();
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = nw_protocol_notification_type_to_string();
          uint64_t v12 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          if (!__nwlog_fault()) {
            goto LABEL_63;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            uint64_t v13 = __nwlog_obj();
            os_log_type_t v14 = type[0];
            if (!os_log_type_enabled(v13, type[0])) {
              goto LABEL_63;
            }
            goto LABEL_38;
          }
          uint64_t v13 = __nwlog_obj();
          os_log_type_t v14 = type[0];
          if (!os_log_type_enabled(v13, type[0])) {
            goto LABEL_63;
          }
          goto LABEL_57;
        case 2:
          if (!a4)
          {
            __nwlog_obj();
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
            uint64_t v12 = (void *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            if (!__nwlog_fault()) {
              goto LABEL_63;
            }
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              int v28 = __nwlog_obj();
              os_log_type_t v29 = type[0];
              if (!os_log_type_enabled(v28, type[0])) {
                goto LABEL_63;
              }
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              uint64_t v15 = "%{public}s called with null val";
            }
            else
            {
              int v28 = __nwlog_obj();
              os_log_type_t v29 = type[0];
              if (!os_log_type_enabled(v28, type[0])) {
                goto LABEL_63;
              }
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              uint64_t v15 = "%{public}s called with null val, backtrace limit exceeded";
            }
            goto LABEL_95;
          }
          if (a5)
          {
            *(_DWORD *)os_log_type_t type = *a4;
            *(void *)long long buf = 0x600000001;
            *(void *)&buf[8] = 519;
            *(void *)&buf[16] = type;
            uint64_t v32 = 4;
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 + 8) + 16))(v9, 1, v5);
            if ((~*(unsigned __int16 *)(v10 + 376) & 0x30) != 0 || (*(unsigned char *)(v10 + 365) & 0x20) != 0) {
              int v17 = tcp_ctloutput(v10, (uint64_t)buf);
            }
            else {
              int v17 = 22;
            }
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v10 + 8) + 24))(v10, 1, v5);
            if (!v17)
            {
              int v23 = *(_DWORD *)(v10 + 5308) | 0x80;
LABEL_45:
              *(_DWORD *)(v10 + 5308) = v23;
              return 1;
            }
            __nwlog_obj();
            uint64_t v22 = v10 + 604;
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v10 + 604;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v32) = v17;
            uint64_t v12 = (void *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            if (!__nwlog_fault()) {
              goto LABEL_63;
            }
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              char v20 = __nwlog_obj();
              os_log_type_t v21 = type[0];
              if (!os_log_type_enabled(v20, type[0])) {
                goto LABEL_63;
              }
              *(_DWORD *)long long buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v22;
              *(_WORD *)&unsigned char buf[22] = 1024;
              LODWORD(v32) = v17;
              uint64_t v15 = "%{public}s %{public}s tcp_set_write_timeout failed %{darwin.errno}d";
            }
            else
            {
              char v20 = __nwlog_obj();
              os_log_type_t v21 = type[0];
              if (!os_log_type_enabled(v20, type[0])) {
                goto LABEL_63;
              }
              *(_DWORD *)long long buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v22;
              *(_WORD *)&unsigned char buf[22] = 1024;
              LODWORD(v32) = v17;
              uint64_t v15 = "%{public}s %{public}s tcp_set_write_timeout failed %{darwin.errno}d, backtrace limit exceeded";
            }
LABEL_60:
            __int16 v24 = v20;
            os_log_type_t v25 = v21;
            uint32_t v26 = 28;
          }
          else
          {
            __nwlog_obj();
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = nw_protocol_notification_type_to_string();
            uint64_t v12 = (void *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            if (!__nwlog_fault()) {
              goto LABEL_63;
            }
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              uint64_t v13 = __nwlog_obj();
              os_log_type_t v14 = type[0];
              if (!os_log_type_enabled(v13, type[0])) {
                goto LABEL_63;
              }
LABEL_38:
              *(_DWORD *)long long buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = nw_protocol_notification_type_to_string();
              uint64_t v15 = "%{public}s register notification for %{public}s called with zero length";
            }
            else
            {
              uint64_t v13 = __nwlog_obj();
              os_log_type_t v14 = type[0];
              if (!os_log_type_enabled(v13, type[0])) {
                goto LABEL_63;
              }
LABEL_57:
              *(_DWORD *)long long buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = nw_protocol_notification_type_to_string();
              uint64_t v15 = "%{public}s register notification for %{public}s called with zero length, backtrace limit exceeded";
            }
LABEL_61:
            __int16 v24 = v13;
            os_log_type_t v25 = v14;
            uint32_t v26 = 22;
          }
          break;
        case 3:
          *(_DWORD *)(v9 + 5308) |= 0x100u;
          return v11;
        case 4:
        case 5:
          return v11;
        case 14:
          *(_DWORD *)(v9 + 5308) |= 0x400000u;
          if ((*(unsigned char *)(v9 + 828) & 2) == 0)
          {
            os_log_type_t v18 = __nwlog_tcp_log();
            if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)long long buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v10 + 604;
              _os_log_impl(&dword_214653000, v18, OS_LOG_TYPE_INFO, "%{public}s %{public}s segmentation_offload_notification enabled", buf, 0x16u);
            }
          }
          return v11;
        default:
          return 0;
      }
      goto LABEL_62;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
    uint64_t v12 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault()) {
      goto LABEL_63;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v28 = __nwlog_obj();
      os_log_type_t v29 = type[0];
      if (!os_log_type_enabled(v28, type[0])) {
        goto LABEL_63;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
      uint64_t v15 = "%{public}s called with null tcp";
    }
    else
    {
      int v28 = __nwlog_obj();
      os_log_type_t v29 = type[0];
      if (!os_log_type_enabled(v28, type[0])) {
        goto LABEL_63;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
      uint64_t v15 = "%{public}s called with null tcp, backtrace limit exceeded";
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
    uint64_t v12 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault()) {
      goto LABEL_63;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v28 = __nwlog_obj();
      os_log_type_t v29 = type[0];
      if (!os_log_type_enabled(v28, type[0])) {
        goto LABEL_63;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
      uint64_t v15 = "%{public}s called with null protocol";
    }
    else
    {
      int v28 = __nwlog_obj();
      os_log_type_t v29 = type[0];
      if (!os_log_type_enabled(v28, type[0])) {
        goto LABEL_63;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
      uint64_t v15 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
  }
LABEL_95:
  __int16 v24 = v28;
  os_log_type_t v25 = v29;
  uint32_t v26 = 12;
LABEL_62:
  _os_log_impl(&dword_214653000, v24, v25, v15, buf, v26);
LABEL_63:
  if (v12) {
    free(v12);
  }
  return 0;
}

uint64_t __nw_protocol_tcp_callbacks_block_invoke()
{
  nw_protocol_tcp_callbacks_callbacks = nw_protocol_one_to_one_callbacks_new();
  nw_protocol_callbacks_set_add_input_handler();
  nw_protocol_callbacks_set_replace_input_handler();
  nw_protocol_callbacks_set_remove_input_handler();
  nw_protocol_callbacks_set_input_available();
  nw_protocol_callbacks_set_input_flush();
  nw_protocol_callbacks_set_output_available();
  nw_protocol_callbacks_set_get_input_frames();
  nw_protocol_callbacks_set_get_output_frames();
  nw_protocol_callbacks_set_finalize_output_frames();
  nw_protocol_callbacks_set_link_state();
  nw_protocol_callbacks_set_disconnect();
  nw_protocol_callbacks_set_connect();
  nw_protocol_callbacks_set_connected();
  nw_protocol_callbacks_set_reset();
  nw_protocol_callbacks_set_disconnected();
  nw_protocol_callbacks_set_waiting_for_output();
  nw_protocol_callbacks_set_output_finished();
  nw_protocol_callbacks_set_updated_path();
  nw_protocol_callbacks_set_copy_info();
  nw_protocol_callbacks_set_register_notification();
  nw_protocol_callbacks_set_unregister_notification();
  nw_protocol_callbacks_set_get_message_properties();
  uint64_t v0 = nw_protocol_tcp_callbacks_callbacks;

  return MEMORY[0x270EF8A90](v0, nw_protocol_tcp_error);
}

uint64_t nw_protocol_tcp_apply_parameters(uint64_t a1)
{
  uint64_t v118 = *MEMORY[0x263EF8340];
  nw_protocol_upcast();
  nw_protocol_get_input_handler();
  uint64_t parameters = nw_protocol_get_parameters();
  if (!parameters)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
    int v58 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v114[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault()) {
      goto LABEL_282;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v59 = __nwlog_obj();
      os_log_type_t v60 = type[0];
      if (!os_log_type_enabled(v59, type[0])) {
        goto LABEL_282;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      int v61 = "%{public}s called with null parameters";
    }
    else
    {
      int v59 = __nwlog_obj();
      os_log_type_t v60 = type[0];
      if (!os_log_type_enabled(v59, type[0])) {
        goto LABEL_282;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      int v61 = "%{public}s called with null parameters, backtrace limit exceeded";
    }
    goto LABEL_281;
  }
  if (!*(void *)(a1 + 5208))
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
    int v58 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v114[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault()) {
      goto LABEL_282;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v59 = __nwlog_obj();
      os_log_type_t v60 = type[0];
      if (!os_log_type_enabled(v59, type[0])) {
        goto LABEL_282;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      int v61 = "%{public}s called with null path";
    }
    else
    {
      int v59 = __nwlog_obj();
      os_log_type_t v60 = type[0];
      if (!os_log_type_enabled(v59, type[0])) {
        goto LABEL_282;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      int v61 = "%{public}s called with null path, backtrace limit exceeded";
    }
LABEL_281:
    _os_log_impl(&dword_214653000, v59, v60, v61, buf, 0xCu);
LABEL_282:
    if (v58) {
      free(v58);
    }
    return 0;
  }
  uint64_t v4 = parameters;
  uint64_t v5 = (void *)nw_parameters_copy_protocol_options_legacy();
  if (nw_parameters_get_discretionary()) {
    *(_DWORD *)(a1 + 5308) |= 0x200u;
  }
  if (nw_tcp_options_get_no_delay())
  {
    *(_DWORD *)os_log_type_t type = 1;
    *(void *)long long buf = 0x600000001;
    *(void *)&buf[8] = 1;
    *(void *)&buf[16] = type;
    uint64_t v117 = 4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16))(a1, 1, v1);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(unsigned char *)(a1 + 365) & 0x20) != 0) {
      int v6 = tcp_ctloutput(a1, (uint64_t)buf);
    }
    else {
      int v6 = 22;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v1);
    if (v6)
    {
      __nwlog_obj();
      uint64_t v7 = a1 + 604;
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v6;
      int v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v9 = __nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v7;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v117) = v6;
            uint64_t v11 = "%{public}s %{public}s tcp_set_no_delay failed %{darwin.errno}d";
LABEL_130:
            os_log_type_t v43 = v9;
            os_log_type_t v44 = v10;
LABEL_131:
            _os_log_impl(&dword_214653000, v43, v44, v11, buf, 0x1Cu);
            goto LABEL_132;
          }
        }
        else
        {
          uint64_t v9 = __nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v7;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v117) = v6;
            uint64_t v11 = "%{public}s %{public}s tcp_set_no_delay failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_130;
          }
        }
      }
      goto LABEL_132;
    }
  }
  if (nw_tcp_options_get_no_push())
  {
    *(_DWORD *)os_log_type_t type = 1;
    *(void *)long long buf = 0x600000001;
    *(void *)&buf[8] = 4;
    *(void *)&buf[16] = type;
    uint64_t v117 = 4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16))(a1, 1, v1);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(unsigned char *)(a1 + 365) & 0x20) != 0) {
      int v12 = tcp_ctloutput(a1, (uint64_t)buf);
    }
    else {
      int v12 = 22;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v1);
    if (v12)
    {
      __nwlog_obj();
      uint64_t v13 = a1 + 604;
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v12;
      int v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v9 = __nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v13;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v117) = v12;
            uint64_t v11 = "%{public}s %{public}s tcp_set_no_push failed %{darwin.errno}d";
            goto LABEL_130;
          }
        }
        else
        {
          uint64_t v9 = __nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v13;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v117) = v12;
            uint64_t v11 = "%{public}s %{public}s tcp_set_no_push failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_130;
          }
        }
      }
LABEL_132:
      if (v8) {
        free(v8);
      }
      if (v5) {
        nw_release(v5);
      }
      return 0;
    }
  }
  if (nw_tcp_options_get_reduce_buffering())
  {
    *(_DWORD *)os_log_type_t type = 0x4000;
    *(void *)long long buf = 0x600000001;
    *(void *)&buf[8] = 513;
    *(void *)&buf[16] = type;
    uint64_t v117 = 4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16))(a1, 1, v1);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(unsigned char *)(a1 + 365) & 0x20) != 0) {
      int v14 = tcp_ctloutput(a1, (uint64_t)buf);
    }
    else {
      int v14 = 22;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v1);
    if (v14)
    {
      __nwlog_obj();
      uint64_t v15 = a1 + 604;
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v14;
      int v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v9 = __nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v15;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v117) = v14;
            uint64_t v11 = "%{public}s %{public}s tcp_set_notsent_lowat failed %{darwin.errno}d";
            goto LABEL_130;
          }
        }
        else
        {
          uint64_t v9 = __nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v15;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v117) = v14;
            uint64_t v11 = "%{public}s %{public}s tcp_set_notsent_lowat failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_130;
          }
        }
      }
      goto LABEL_132;
    }
  }
  if (nw_tcp_options_get_disable_blackhole_detection())
  {
    *(_DWORD *)os_log_type_t type = 1;
    *(void *)long long buf = 0x600000001;
    *(void *)&buf[8] = 521;
    *(void *)&buf[16] = type;
    uint64_t v117 = 4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16))(a1, 1, v1);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(unsigned char *)(a1 + 365) & 0x20) != 0) {
      int v16 = tcp_ctloutput(a1, (uint64_t)buf);
    }
    else {
      int v16 = 22;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v1);
    if (v16)
    {
      __nwlog_obj();
      uint64_t v17 = a1 + 604;
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v16;
      int v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v9 = __nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v17;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v117) = v16;
            uint64_t v11 = "%{public}s %{public}s tcp_disable_blackhole_detection(so) %{darwin.errno}d";
            goto LABEL_130;
          }
        }
        else
        {
          uint64_t v9 = __nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v17;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v117) = v16;
            uint64_t v11 = "%{public}s %{public}s tcp_disable_blackhole_detection(so) %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_130;
          }
        }
      }
      goto LABEL_132;
    }
  }
  int ecn_mode = nw_parameters_get_ecn_mode();
  if (!ecn_mode) {
    goto LABEL_77;
  }
  if (ecn_mode == 1) {
    int v19 = 1;
  }
  else {
    int v19 = 2;
  }
  *(_DWORD *)(a1 + 5304) = v19;
  *(_DWORD *)os_log_type_t type = v19;
  *(void *)long long buf = 0x600000001;
  *(void *)&buf[8] = 528;
  *(void *)&buf[16] = type;
  uint64_t v117 = 4;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16))(a1, 1, v1);
  if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) == 0 && (*(unsigned char *)(a1 + 365) & 0x20) == 0)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v1);
    goto LABEL_56;
  }
  int v20 = tcp_ctloutput(a1, (uint64_t)buf);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v1);
  if (v20)
  {
    if (v20 == 22)
    {
LABEL_56:
      os_log_type_t v21 = __nwlog_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 22;
        _os_log_impl(&dword_214653000, v21, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_ECN_MODE failed %{darwin.errno}d", buf, 0x12u);
      }
      goto LABEL_77;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v20;
    uint64_t v22 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v114[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        int v23 = __nwlog_obj();
        os_log_type_t v24 = type[0];
        if (!os_log_type_enabled(v23, type[0])) {
          goto LABEL_75;
        }
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v20;
        os_log_type_t v25 = "%{public}s setsockopt TCP_ECN_MODE failed %{darwin.errno}d";
      }
      else
      {
        int v23 = __nwlog_obj();
        os_log_type_t v24 = type[0];
        if (!os_log_type_enabled(v23, type[0])) {
          goto LABEL_75;
        }
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v20;
        os_log_type_t v25 = "%{public}s setsockopt TCP_ECN_MODE failed %{darwin.errno}d, backtrace limit exceeded";
      }
      _os_log_impl(&dword_214653000, v23, v24, v25, buf, 0x12u);
    }
LABEL_75:
    if (v22) {
      free(v22);
    }
  }
LABEL_77:
  int enable_l4s = nw_tcp_options_get_enable_l4s();
  if (enable_l4s != 2)
  {
    *(_DWORD *)os_log_type_t type = enable_l4s == 1;
    *(void *)long long buf = 0x600000001;
    *(void *)&buf[8] = 539;
    *(void *)&buf[16] = type;
    uint64_t v117 = 4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16))(a1, 1, v1);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(unsigned char *)(a1 + 365) & 0x20) != 0) {
      int v27 = tcp_ctloutput(a1, (uint64_t)buf);
    }
    else {
      int v27 = 22;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v1);
    if (v27)
    {
      __nwlog_obj();
      uint64_t v28 = a1 + 604;
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v27;
      int v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v9 = __nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v28;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v117) = v27;
            uint64_t v11 = "%{public}s %{public}s tcp_set_enable_l4s failed %{darwin.errno}d";
            goto LABEL_130;
          }
        }
        else
        {
          uint64_t v9 = __nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v28;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v117) = v27;
            uint64_t v11 = "%{public}s %{public}s tcp_set_enable_l4s failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_130;
          }
        }
      }
      goto LABEL_132;
    }
  }
  if (nw_parameters_get_fast_open_enabled(v4)
    || nw_tcp_options_get_enable_fast_open()
    && (nw_protocol_upcast(), nw_protocol_get_input_handler(), (nw_protocol_input_handler_is_connection_flow() & 1) == 0))
  {
    *(_DWORD *)(a1 + 368) |= 0x30u;
    if (nw_tcp_options_get_no_fast_open_cookie()) {
      *(_DWORD *)(a1 + 368) |= 0x10000u;
    }
    *(_DWORD *)(a1 + 5308) |= 0x8020u;
  }
  if (nw_tcp_options_get_fast_open_force_enable())
  {
    *(_DWORD *)os_log_type_t type = 1;
    *(void *)long long buf = 0x600000001;
    *(void *)&buf[8] = 536;
    *(void *)&buf[16] = type;
    uint64_t v117 = 4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16))(a1, 1, v1);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(unsigned char *)(a1 + 365) & 0x20) != 0) {
      int v29 = tcp_ctloutput(a1, (uint64_t)buf);
    }
    else {
      int v29 = 22;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v1);
    if (v29)
    {
      __nwlog_obj();
      uint64_t v30 = a1 + 604;
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v29;
      int v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v9 = __nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v30;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v117) = v29;
            uint64_t v11 = "%{public}s %{public}s tcp_set_fast_open_force_enable failed %{darwin.errno}d";
            goto LABEL_130;
          }
        }
        else
        {
          uint64_t v9 = __nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v30;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v117) = v29;
            uint64_t v11 = "%{public}s %{public}s tcp_set_fast_open_force_enable failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_130;
          }
        }
      }
      goto LABEL_132;
    }
  }
  int effective_traffic_class = nw_path_get_effective_traffic_class();
  int v32 = tcp_set_traffic_class(a1, effective_traffic_class);
  if (v32)
  {
    int v33 = v32;
    __nwlog_obj();
    uint64_t v34 = a1 + 604;
    *(_DWORD *)long long buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = a1 + 604;
    *(_WORD *)&unsigned char buf[22] = 1024;
    LODWORD(v117) = v33;
    int v8 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v114[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault()) {
      goto LABEL_132;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v35 = __nwlog_obj();
      os_log_type_t v36 = type[0];
      if (!os_log_type_enabled(v35, type[0])) {
        goto LABEL_132;
      }
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v34;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v33;
      uint64_t v11 = "%{public}s %{public}s tcp_set_traffic_class failed %{darwin.errno}d";
    }
    else
    {
      int v35 = __nwlog_obj();
      os_log_type_t v36 = type[0];
      if (!os_log_type_enabled(v35, type[0])) {
        goto LABEL_132;
      }
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v34;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v33;
      uint64_t v11 = "%{public}s %{public}s tcp_set_traffic_class failed %{darwin.errno}d, backtrace limit exceeded";
    }
LABEL_178:
    os_log_type_t v43 = v35;
    os_log_type_t v44 = v36;
    goto LABEL_131;
  }
  if (nw_tcp_options_get_enable_background_traffic_management())
  {
    int v37 = tcp_set_background_management(a1);
    if (v37)
    {
      int v38 = v37;
      __nwlog_obj();
      uint64_t v39 = a1 + 604;
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v38;
      int v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault()) {
        goto LABEL_132;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        int v35 = __nwlog_obj();
        os_log_type_t v36 = type[0];
        if (!os_log_type_enabled(v35, type[0])) {
          goto LABEL_132;
        }
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v39;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v117) = v38;
        uint64_t v11 = "%{public}s %{public}s tcp_set_background_management failed %{darwin.errno}d";
      }
      else
      {
        int v35 = __nwlog_obj();
        os_log_type_t v36 = type[0];
        if (!os_log_type_enabled(v35, type[0])) {
          goto LABEL_132;
        }
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v39;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v117) = v38;
        uint64_t v11 = "%{public}s %{public}s tcp_set_background_management failed %{darwin.errno}d, backtrace limit exceeded";
      }
      goto LABEL_178;
    }
  }
  if (nw_tcp_options_get_enable_keepalive())
  {
    int v40 = tcp_set_keepalive(a1, 1);
    if (v40)
    {
      int v41 = v40;
      __nwlog_obj();
      uint64_t v42 = a1 + 604;
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v41;
      int v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault()) {
        goto LABEL_132;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        int v35 = __nwlog_obj();
        os_log_type_t v36 = type[0];
        if (!os_log_type_enabled(v35, type[0])) {
          goto LABEL_132;
        }
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v42;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v117) = v41;
        uint64_t v11 = "%{public}s %{public}s tcp_set_keepalive failed %{darwin.errno}d";
      }
      else
      {
        int v35 = __nwlog_obj();
        os_log_type_t v36 = type[0];
        if (!os_log_type_enabled(v35, type[0])) {
          goto LABEL_132;
        }
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v42;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v117) = v41;
        uint64_t v11 = "%{public}s %{public}s tcp_set_keepalive failed %{darwin.errno}d, backtrace limit exceeded";
      }
      goto LABEL_178;
    }
    int keepalive_idle_time = nw_tcp_options_get_keepalive_idle_time();
    if (keepalive_idle_time)
    {
      int v47 = tcp_set_keepalive_idle_time(a1, keepalive_idle_time);
      if (v47)
      {
        int v48 = v47;
        __nwlog_obj();
        uint64_t v49 = a1 + 604;
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 604;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v117) = v48;
        int v8 = (void *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v114[0] = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault()) {
          goto LABEL_132;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          int v35 = __nwlog_obj();
          os_log_type_t v36 = type[0];
          if (!os_log_type_enabled(v35, type[0])) {
            goto LABEL_132;
          }
          goto LABEL_142;
        }
        int v35 = __nwlog_obj();
        os_log_type_t v36 = type[0];
        if (!os_log_type_enabled(v35, type[0])) {
          goto LABEL_132;
        }
        goto LABEL_171;
      }
    }
    int keepalive_interval = nw_tcp_options_get_keepalive_interval();
    if (keepalive_interval)
    {
      int v51 = tcp_set_keepalive_interval(a1, keepalive_interval);
      if (v51)
      {
        int v48 = v51;
        __nwlog_obj();
        uint64_t v49 = a1 + 604;
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 604;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v117) = v48;
        int v8 = (void *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v114[0] = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault()) {
          goto LABEL_132;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          int v35 = __nwlog_obj();
          os_log_type_t v36 = type[0];
          if (!os_log_type_enabled(v35, type[0])) {
            goto LABEL_132;
          }
LABEL_142:
          *(_DWORD *)long long buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v49;
          *(_WORD *)&unsigned char buf[22] = 1024;
          LODWORD(v117) = v48;
          uint64_t v11 = "%{public}s %{public}s tcp_set_keepalive_idle_time failed %{darwin.errno}d";
          goto LABEL_178;
        }
        int v35 = __nwlog_obj();
        os_log_type_t v36 = type[0];
        if (!os_log_type_enabled(v35, type[0])) {
          goto LABEL_132;
        }
LABEL_171:
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v49;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v117) = v48;
        uint64_t v11 = "%{public}s %{public}s tcp_set_keepalive_idle_time failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_178;
      }
    }
    *(_DWORD *)os_log_type_t type = 0;
    *(_DWORD *)os_log_type_t type = nw_tcp_options_get_keepalive_count();
    int v52 = tcp_setsockopt(a1, 6, 258, (int *)type);
    if (v52)
    {
      int v53 = v52;
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v53;
      __int16 v54 = (void *)_os_log_send_and_compose_impl();
      v114[0] = OS_LOG_TYPE_ERROR;
      v113[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault()) {
        goto LABEL_180;
      }
      if (v114[0] == OS_LOG_TYPE_FAULT)
      {
        int v55 = __nwlog_obj();
        os_log_type_t v56 = v114[0];
        if (!os_log_type_enabled(v55, v114[0])) {
          goto LABEL_180;
        }
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 604;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v117) = v53;
        int v57 = "%{public}s %{public}s tcp_setsockopt TCP_KEEPCNT failed %{darwin.errno}d";
      }
      else
      {
        int v55 = __nwlog_obj();
        os_log_type_t v56 = v114[0];
        if (!os_log_type_enabled(v55, v114[0])) {
          goto LABEL_180;
        }
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 604;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v117) = v53;
        int v57 = "%{public}s %{public}s tcp_setsockopt TCP_KEEPCNT failed %{darwin.errno}d, backtrace limit exceeded";
      }
      _os_log_impl(&dword_214653000, v55, v56, v57, buf, 0x1Cu);
LABEL_180:
      if (v54) {
        free(v54);
      }
    }
  }
  *(_DWORD *)os_log_type_t type = 1;
  if (!nw_tcp_options_get_disable_ack_stretching()) {
    goto LABEL_193;
  }
  int v62 = tcp_setsockopt(a1, 6, 259, (int *)type);
  if (!v62) {
    goto LABEL_193;
  }
  int v63 = v62;
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
  *(_WORD *)&buf[12] = 2082;
  *(void *)&buf[14] = a1 + 604;
  *(_WORD *)&unsigned char buf[22] = 1024;
  LODWORD(v117) = v63;
  uint64_t v64 = (void *)_os_log_send_and_compose_impl();
  v114[0] = OS_LOG_TYPE_ERROR;
  v113[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v114[0] == OS_LOG_TYPE_FAULT)
    {
      int v65 = __nwlog_obj();
      os_log_type_t v66 = v114[0];
      if (!os_log_type_enabled(v65, v114[0])) {
        goto LABEL_191;
      }
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v63;
      unsigned int v67 = "%{public}s %{public}s tcp_setsockopt TCP_SENDMOREACKS failed %{darwin.errno}d";
    }
    else
    {
      int v65 = __nwlog_obj();
      os_log_type_t v66 = v114[0];
      if (!os_log_type_enabled(v65, v114[0])) {
        goto LABEL_191;
      }
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v63;
      unsigned int v67 = "%{public}s %{public}s tcp_setsockopt TCP_SENDMOREACKS failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_214653000, v65, v66, v67, buf, 0x1Cu);
  }
LABEL_191:
  if (v64) {
    free(v64);
  }
LABEL_193:
  if (!nw_tcp_options_get_no_options()) {
    goto LABEL_204;
  }
  int v68 = tcp_setsockopt(a1, 6, 8, (int *)type);
  if (!v68) {
    goto LABEL_204;
  }
  int v69 = v68;
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
  *(_WORD *)&buf[12] = 2082;
  *(void *)&buf[14] = a1 + 604;
  *(_WORD *)&unsigned char buf[22] = 1024;
  LODWORD(v117) = v69;
  uint64_t v70 = (void *)_os_log_send_and_compose_impl();
  v114[0] = OS_LOG_TYPE_ERROR;
  v113[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v114[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v71 = __nwlog_obj();
      os_log_type_t v72 = v114[0];
      if (!os_log_type_enabled(v71, v114[0])) {
        goto LABEL_202;
      }
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v69;
      __int16 v73 = "%{public}s %{public}s tcp_setsockopt TCP_NOOPT failed %{darwin.errno}d";
    }
    else
    {
      __int16 v71 = __nwlog_obj();
      os_log_type_t v72 = v114[0];
      if (!os_log_type_enabled(v71, v114[0])) {
        goto LABEL_202;
      }
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v69;
      __int16 v73 = "%{public}s %{public}s tcp_setsockopt TCP_NOOPT failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_214653000, v71, v72, v73, buf, 0x1Cu);
  }
LABEL_202:
  if (v70) {
    free(v70);
  }
LABEL_204:
  if (!nw_tcp_options_get_no_timewait()) {
    goto LABEL_215;
  }
  int v74 = tcp_setsockopt(a1, 6, 520, (int *)type);
  if (!v74) {
    goto LABEL_215;
  }
  int v75 = v74;
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
  *(_WORD *)&buf[12] = 2082;
  *(void *)&buf[14] = a1 + 604;
  *(_WORD *)&unsigned char buf[22] = 1024;
  LODWORD(v117) = v75;
  int v76 = (void *)_os_log_send_and_compose_impl();
  v114[0] = OS_LOG_TYPE_ERROR;
  v113[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v114[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v77 = __nwlog_obj();
      os_log_type_t v78 = v114[0];
      if (!os_log_type_enabled(v77, v114[0])) {
        goto LABEL_213;
      }
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v75;
      __int16 v79 = "%{public}s %{public}s tcp_setsockopt TCP_NOTIMEWAIT failed %{darwin.errno}d";
    }
    else
    {
      __int16 v77 = __nwlog_obj();
      os_log_type_t v78 = v114[0];
      if (!os_log_type_enabled(v77, v114[0])) {
        goto LABEL_213;
      }
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v75;
      __int16 v79 = "%{public}s %{public}s tcp_setsockopt TCP_NOTIMEWAIT failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_214653000, v77, v78, v79, buf, 0x1Cu);
  }
LABEL_213:
  if (v76) {
    free(v76);
  }
LABEL_215:
  *(_DWORD *)int v114 = nw_tcp_options_get_maximum_segment_size();
  if (!*(_DWORD *)v114) {
    goto LABEL_226;
  }
  int v80 = tcp_setsockopt(a1, 6, 2, (int *)v114);
  if (!v80) {
    goto LABEL_226;
  }
  int v81 = v80;
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
  *(_WORD *)&buf[12] = 2082;
  *(void *)&buf[14] = a1 + 604;
  *(_WORD *)&unsigned char buf[22] = 1024;
  LODWORD(v117) = v81;
  int v82 = (void *)_os_log_send_and_compose_impl();
  v113[0] = OS_LOG_TYPE_ERROR;
  v112[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v113[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v83 = __nwlog_obj();
      os_log_type_t v84 = v113[0];
      if (!os_log_type_enabled(v83, v113[0])) {
        goto LABEL_224;
      }
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v81;
      __int16 v85 = "%{public}s %{public}s tcp_setsockopt TCP_MAXSEG failed %{darwin.errno}d";
    }
    else
    {
      uint64_t v83 = __nwlog_obj();
      os_log_type_t v84 = v113[0];
      if (!os_log_type_enabled(v83, v113[0])) {
        goto LABEL_224;
      }
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v81;
      __int16 v85 = "%{public}s %{public}s tcp_setsockopt TCP_MAXSEG failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_214653000, v83, v84, v85, buf, 0x1Cu);
  }
LABEL_224:
  if (v82) {
    free(v82);
  }
LABEL_226:
  *(_DWORD *)__int16 v113 = nw_tcp_options_get_retransmit_connection_drop_time();
  if (!*(_DWORD *)v113) {
    goto LABEL_237;
  }
  int v86 = tcp_setsockopt(a1, 6, 128, (int *)v113);
  if (!v86) {
    goto LABEL_237;
  }
  int v87 = v86;
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
  *(_WORD *)&buf[12] = 2082;
  *(void *)&buf[14] = a1 + 604;
  *(_WORD *)&unsigned char buf[22] = 1024;
  LODWORD(v117) = v87;
  uint64_t v88 = (void *)_os_log_send_and_compose_impl();
  v112[0] = OS_LOG_TYPE_ERROR;
  v110[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v112[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v89 = __nwlog_obj();
      os_log_type_t v90 = v112[0];
      if (!os_log_type_enabled(v89, v112[0])) {
        goto LABEL_235;
      }
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v87;
      __int16 v91 = "%{public}s %{public}s tcp_setsockopt TCP_RXT_CONNDROPTIME failed %{darwin.errno}d";
    }
    else
    {
      __int16 v89 = __nwlog_obj();
      os_log_type_t v90 = v112[0];
      if (!os_log_type_enabled(v89, v112[0])) {
        goto LABEL_235;
      }
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v87;
      __int16 v91 = "%{public}s %{public}s tcp_setsockopt TCP_RXT_CONNDROPTIME failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_214653000, v89, v90, v91, buf, 0x1Cu);
  }
LABEL_235:
  if (v88) {
    free(v88);
  }
LABEL_237:
  if (!nw_tcp_options_get_retransmit_fin_drop()) {
    goto LABEL_248;
  }
  int v92 = tcp_setsockopt(a1, 6, 256, (int *)type);
  if (!v92) {
    goto LABEL_248;
  }
  int v93 = v92;
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
  *(_WORD *)&buf[12] = 2082;
  *(void *)&buf[14] = a1 + 604;
  *(_WORD *)&unsigned char buf[22] = 1024;
  LODWORD(v117) = v93;
  unsigned int v94 = (void *)_os_log_send_and_compose_impl();
  v112[0] = OS_LOG_TYPE_ERROR;
  v110[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v112[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v95 = __nwlog_obj();
      os_log_type_t v96 = v112[0];
      if (!os_log_type_enabled(v95, v112[0])) {
        goto LABEL_246;
      }
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v93;
      __int16 v97 = "%{public}s %{public}s tcp_setsockopt TCP_RXT_FINDROP failed %{darwin.errno}d";
    }
    else
    {
      __int16 v95 = __nwlog_obj();
      os_log_type_t v96 = v112[0];
      if (!os_log_type_enabled(v95, v112[0])) {
        goto LABEL_246;
      }
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v93;
      __int16 v97 = "%{public}s %{public}s tcp_setsockopt TCP_RXT_FINDROP failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_214653000, v95, v96, v97, buf, 0x1Cu);
  }
LABEL_246:
  if (v94) {
    free(v94);
  }
LABEL_248:
  *(_DWORD *)int v112 = nw_tcp_options_get_connection_timeout();
  if (!*(_DWORD *)v112) {
    goto LABEL_259;
  }
  int v98 = tcp_setsockopt(a1, 6, 32, (int *)v112);
  if (!v98) {
    goto LABEL_259;
  }
  int v99 = v98;
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
  *(_WORD *)&buf[12] = 2082;
  *(void *)&buf[14] = a1 + 604;
  *(_WORD *)&unsigned char buf[22] = 1024;
  LODWORD(v117) = v99;
  int v100 = (void *)_os_log_send_and_compose_impl();
  v110[0] = OS_LOG_TYPE_ERROR;
  os_log_type_t v111 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v110[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v101 = __nwlog_obj();
      os_log_type_t v102 = v110[0];
      if (!os_log_type_enabled(v101, v110[0])) {
        goto LABEL_257;
      }
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v99;
      __int16 v103 = "%{public}s %{public}s tcp_setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d";
    }
    else
    {
      __int16 v101 = __nwlog_obj();
      os_log_type_t v102 = v110[0];
      if (!os_log_type_enabled(v101, v110[0])) {
        goto LABEL_257;
      }
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v99;
      __int16 v103 = "%{public}s %{public}s tcp_setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_214653000, v101, v102, v103, buf, 0x1Cu);
  }
LABEL_257:
  if (v100) {
    free(v100);
  }
LABEL_259:
  *(_DWORD *)BOOL v110 = nw_tcp_options_get_persist_timeout();
  if (*(_DWORD *)v110)
  {
    int v104 = tcp_setsockopt(a1, 6, 64, (int *)v110);
    if (v104)
    {
      int v105 = v104;
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v117) = v105;
      int v106 = (void *)_os_log_send_and_compose_impl();
      os_log_type_t v111 = OS_LOG_TYPE_ERROR;
      if (!__nwlog_fault()) {
        goto LABEL_268;
      }
      if (v111 == OS_LOG_TYPE_FAULT)
      {
        __int16 v107 = __nwlog_obj();
        os_log_type_t v108 = v111;
        if (!os_log_type_enabled(v107, v111)) {
          goto LABEL_268;
        }
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 604;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v117) = v105;
        __int16 v109 = "%{public}s %{public}s tcp_setsockopt PERSIST_TIMEOUT failed %{darwin.errno}d";
      }
      else
      {
        __int16 v107 = __nwlog_obj();
        os_log_type_t v108 = v111;
        if (!os_log_type_enabled(v107, v111)) {
          goto LABEL_268;
        }
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 604;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v117) = v105;
        __int16 v109 = "%{public}s %{public}s tcp_setsockopt PERSIST_TIMEOUT failed %{darwin.errno}d, backtrace limit exceeded";
      }
      _os_log_impl(&dword_214653000, v107, v108, v109, buf, 0x1Cu);
LABEL_268:
      if (v106) {
        free(v106);
      }
    }
  }
  if (nw_parameters_is_fallback()) {
    *(_DWORD *)(a1 + 5308) |= 0x400u;
  }
  if (nw_parameters_get_server_mode())
  {
    *(_DWORD *)(a1 + 5308) |= 0x200000u;
    *(_DWORD *)(a1 + 372) |= 2u;
  }
  if (v5) {
    nw_release(v5);
  }
  return 1;
}

uint64_t tcp_ctloutput(uint64_t a1, uint64_t a2)
{
  uint64_t v111 = *MEMORY[0x263EF8340];
  int __src = 0;
  uint64_t v2 = *(void *)a1;
  if (!*(void *)a1) {
    return 54;
  }
  int v5 = *(_DWORD *)(a2 + 4);
  if (v5 != 6)
  {
    if (v5 != 0xFFFF || ((int v6 = *(_DWORD *)(a2 + 8), v6 != 4355) ? (v7 = v6 == 4357) : (v7 = 1), !v7))
    {
      int v14 = **(_DWORD **)(*(void *)(a1 + 8) + 8);
      __nwlog_obj();
      if (v14 == 30)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "ip6_ctloutput";
        uint64_t v15 = (void *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v85 = 0;
        if (!__nwlog_fault()) {
          goto LABEL_55;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          int v16 = __nwlog_obj();
          os_log_type_t v17 = type;
          if (!os_log_type_enabled(v16, type)) {
            goto LABEL_55;
          }
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "ip6_ctloutput";
          os_log_type_t v18 = "%{public}s currently unsupported";
        }
        else
        {
          int v16 = __nwlog_obj();
          os_log_type_t v17 = type;
          if (!os_log_type_enabled(v16, type)) {
            goto LABEL_55;
          }
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "ip6_ctloutput";
          os_log_type_t v18 = "%{public}s currently unsupported, backtrace limit exceeded";
        }
      }
      else
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "ip_ctloutput";
        uint64_t v15 = (void *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v85 = 0;
        if (!__nwlog_fault()) {
          goto LABEL_55;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          int v16 = __nwlog_obj();
          os_log_type_t v17 = type;
          if (!os_log_type_enabled(v16, type)) {
            goto LABEL_55;
          }
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "ip_ctloutput";
          os_log_type_t v18 = "%{public}s currently unsupported";
        }
        else
        {
          int v16 = __nwlog_obj();
          os_log_type_t v17 = type;
          if (!os_log_type_enabled(v16, type)) {
            goto LABEL_55;
          }
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "ip_ctloutput";
          os_log_type_t v18 = "%{public}s currently unsupported, backtrace limit exceeded";
        }
      }
      _os_log_impl(&dword_214653000, v16, v17, v18, buf, 0xCu);
LABEL_55:
      if (v15) {
        free(v15);
      }
      return 0;
    }
  }
  uint64_t v8 = *(void *)(v2 + 240);
  if (!v8) {
    return 54;
  }
  uint64_t v9 = nw_tcp_access_globals(a1);
  calculate_tcp_clock(v9);
  if (!*(_DWORD *)a2)
  {
    int v19 = *(_DWORD *)(a2 + 8);
    uint64_t result = 42;
    if (v19 > 511)
    {
      switch(v19)
      {
        case 512:
          uint64_t v110 = 0;
          long long v108 = 0u;
          long long v109 = 0u;
          long long v106 = 0u;
          long long v107 = 0u;
          long long v104 = 0u;
          long long v105 = 0u;
          long long v102 = 0u;
          long long v103 = 0u;
          long long v100 = 0u;
          long long v101 = 0u;
          long long v98 = 0u;
          long long v99 = 0u;
          long long v96 = 0u;
          long long v97 = 0u;
          long long v94 = 0u;
          long long v95 = 0u;
          long long v93 = 0u;
          long long v91 = 0u;
          long long v92 = 0u;
          long long v89 = 0u;
          long long v90 = 0u;
          long long v88 = 0u;
          memset(buf, 0, sizeof(buf));
          tcp_fill_info(v8, *(void *)a1, a1, (uint64_t)buf);
          int v23 = *(void **)(a2 + 16);
          uint64_t v24 = *(void *)(a2 + 24);
          BOOL v25 = v24 < 408;
          uint64_t v26 = 408;
          goto LABEL_184;
        case 513:
          if ((*(unsigned char *)(a1 + 366) & 8) == 0) {
            goto LABEL_177;
          }
          int v20 = *(_DWORD *)(v8 + 320);
          goto LABEL_218;
        case 514:
          int v20 = *(_DWORD *)(v8 + 740) & 8;
          goto LABEL_218;
        case 515:
          if ((*(unsigned char *)(v8 + 740) & 8) == 0) {
            return 22;
          }
          uint64_t v63 = *(void *)(v8 + 768);
          if (!v63) {
            return 22;
          }
          *(void *)long long buf = *(void *)(v63 + 12);
          int v23 = *(void **)(a2 + 16);
          uint64_t v24 = *(void *)(a2 + 24);
          BOOL v25 = v24 < 8;
          uint64_t v26 = 8;
LABEL_184:
          if (v25) {
            size_t v75 = v24;
          }
          else {
            size_t v75 = v26;
          }
          *(void *)(a2 + 24) = v75;
          p_src = buf;
          goto LABEL_223;
        case 516:
        case 518:
        case 522:
        case 523:
        case 524:
        case 525:
        case 526:
        case 527:
        case 531:
        case 532:
        case 533:
        case 534:
        case 535:
        case 537:
        case 538:
          return result;
        case 517:
          int v20 = *(unsigned __int8 *)(v8 + 265);
          goto LABEL_218;
        case 519:
          int v20 = *(unsigned __int8 *)(v8 + 266);
          goto LABEL_218;
        case 520:
          int v20 = (*(_DWORD *)(v8 + 740) >> 11) & 1;
          goto LABEL_218;
        case 521:
          if ((*(unsigned char *)(v8 + 742) & 2) != 0) {
            goto LABEL_178;
          }
          goto LABEL_177;
        case 528:
          int v64 = *(_DWORD *)(v8 + 348);
          if ((v64 & 0x400) != 0)
          {
LABEL_178:
            int v20 = 1;
            goto LABEL_218;
          }
          if ((v64 & 0x800) != 0)
          {
            int v20 = 2;
            goto LABEL_218;
          }
LABEL_177:
          int __src = 0;
          break;
        case 529:
          int v20 = (*(_DWORD *)(v2 + 2232) >> 6) & 1;
          goto LABEL_218;
        case 530:
          if (*(void *)(a2 + 24) != 48) {
            return 22;
          }
          memset(buf, 0, sizeof(buf));
          tcp_get_notify_ack_count(v8, (int *)buf);
          if (*(_DWORD *)&buf[4])
          {
            tcp_get_notify_ack_ids(v8, (uint64_t)buf);
            uint64_t v65 = *(void *)(a2 + 24);
          }
          else
          {
            uint64_t v65 = 48;
          }
          if (v65 >= 48) {
            size_t v75 = 48;
          }
          else {
            size_t v75 = v65;
          }
          *(void *)(a2 + 24) = v75;
          int v23 = *(void **)(a2 + 16);
          p_src = buf;
          goto LABEL_223;
        case 536:
          int v20 = HIBYTE(*(_DWORD *)(v8 + 740)) & 1;
          goto LABEL_218;
        case 539:
          int v20 = (*(_DWORD *)(v8 + 740) >> 27) & 1;
          goto LABEL_218;
        default:
          if (v19 != 4357) {
            return result;
          }
          int v20 = (*(_DWORD *)(a1 + 368) >> 13) & 1;
          goto LABEL_218;
      }
    }
    else if (v19 <= 0x1FF)
    {
      switch(v19)
      {
        case 1:
          int v20 = *(_DWORD *)(v8 + 88) & 4;
          goto LABEL_218;
        case 2:
          int v20 = *(_DWORD *)(v8 + 196);
          goto LABEL_218;
        case 3:
        case 5:
        case 6:
        case 7:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
          return result;
        case 4:
          int v20 = *(_DWORD *)(v8 + 88) & 0x1000;
          goto LABEL_218;
        case 8:
          int v20 = *(_DWORD *)(v8 + 88) & 8;
          goto LABEL_218;
        case 16:
          unsigned int v59 = *(_DWORD *)(v8 + 676);
          if (!v59)
          {
            int v60 = *(_DWORD *)(sysctls + 192);
LABEL_198:
            int v20 = v60 / 1000;
            goto LABEL_218;
          }
LABEL_172:
          unint64_t v62 = 274877907 * v59;
LABEL_173:
          int __src = v62 >> 38;
          break;
        case 32:
          unsigned int v61 = *(_DWORD *)(v8 + 680);
          goto LABEL_130;
        case 64:
          unsigned int v61 = *(_DWORD *)(v8 + 312);
LABEL_130:
          unint64_t v62 = 274877907 * v61;
          goto LABEL_173;
        default:
LABEL_250:
          JUMPOUT(0);
      }
    }
    else
    {
      switch(v19)
      {
        case 256:
          int v20 = *(_DWORD *)(v8 + 740) & 1;
          break;
        case 257:
          unsigned int v59 = *(_DWORD *)(v8 + 684);
          if (v59) {
            goto LABEL_172;
          }
          int v60 = *(_DWORD *)(sysctls + 196);
          goto LABEL_198;
        case 258:
          int v20 = *(_DWORD *)(v8 + 688);
          if (!v20) {
            int v20 = *(_DWORD *)(sysctls + 200);
          }
          break;
        case 259:
          if ((*(unsigned char *)(v8 + 741) & 2) == 0) {
            goto LABEL_177;
          }
          goto LABEL_178;
        case 260:
          int v20 = (*(_DWORD *)(v8 + 348) >> 10) & 1;
          break;
        case 261:
          if (*(_DWORD *)(v8 + 12) != 1 || (*(unsigned char *)(sysctls + 160) & 1) == 0) {
            return 45;
          }
          int v20 = (*(_DWORD *)(v8 + 740) >> 22) & 1;
          break;
        case 262:
          long long v90 = 0u;
          long long v91 = 0u;
          long long v88 = 0u;
          long long v89 = 0u;
          memset(buf, 0, sizeof(buf));
          tcp_connection_fill_info((int32x2_t *)v8, *(void *)a1, a1, (uint64_t)buf);
          int v23 = *(void **)(a2 + 16);
          uint64_t v24 = *(void *)(a2 + 24);
          BOOL v25 = v24 < 112;
          uint64_t v26 = 112;
          goto LABEL_184;
        default:
          return result;
      }
LABEL_218:
      int __src = v20;
    }
    int v23 = *(void **)(a2 + 16);
    if (*(uint64_t *)(a2 + 24) >= 4) {
      size_t v75 = 4;
    }
    else {
      size_t v75 = *(void *)(a2 + 24);
    }
    *(void *)(a2 + 24) = v75;
    p_src = (uint8_t *)&__src;
LABEL_223:
    memcpy(v23, p_src, v75);
    return 0;
  }
  if (*(_DWORD *)a2 != 1) {
    return 0;
  }
  int v10 = *(_DWORD *)(a2 + 8);
  uint64_t result = 42;
  if (v10 > 512)
  {
    switch(v10)
    {
      case 513:
        int v21 = **(_DWORD **)(a2 + 16);
        if (v21 < 0) {
          return 22;
        }
        int v22 = *(_DWORD *)(a1 + 364);
        uint64_t result = 0;
        if (v21)
        {
          *(_DWORD *)(a1 + 364) = v22 | 0x80000;
          *(_DWORD *)(v8 + 320) = v21;
        }
        else
        {
          *(_DWORD *)(a1 + 364) = v22 & 0xFFF7FFFF;
          *(_DWORD *)(v8 + 320) = 0;
        }
        return result;
      case 514:
        uint64_t result = 0;
        if (**(_DWORD **)(a2 + 16))
        {
          *(_OWORD *)(v8 + 776) = 0u;
          *(_OWORD *)(v8 + 792) = 0u;
          *(void *)(v8 + 768) = v8 + 776;
          *(_DWORD *)(v8 + 788) = 6;
          *(_DWORD *)(v8 + 796) = 6 * *(_DWORD *)(v8 + 196);
          *(_DWORD *)(v8 + 740) |= 8u;
          *(void *)(v8 + 808) = 0;
        }
        else
        {
          *(_DWORD *)(v8 + 740) &= 0xFFFFFFF3;
        }
        return result;
      case 515:
        if ((*(unsigned char *)(v8 + 740) & 8) == 0) {
          return 22;
        }
        int v41 = *(_DWORD **)(v8 + 768);
        if (!v41) {
          return 22;
        }
        uint64_t v42 = *(unsigned int **)(a2 + 16);
        unsigned int v44 = *v42;
        unsigned int v43 = v42[1];
        if (v44)
        {
          if (v43) {
            goto LABEL_91;
          }
        }
        else
        {
          unsigned int v44 = v41[3];
          if (v43)
          {
LABEL_91:
            if (v44 > v43) {
              return 22;
            }
            goto LABEL_238;
          }
        }
        unsigned int v43 = v41[4];
        if (v44 > v43) {
          return 22;
        }
LABEL_238:
        uint64_t result = 0;
        v41[3] = v44;
        v41[4] = v43;
        int v80 = *(_DWORD *)(v8 + 196);
        v41[5] = v80 * v44;
        v41[6] = v80 * v43;
        return result;
      case 516:
      case 518:
      case 522:
      case 523:
      case 524:
      case 525:
      case 526:
      case 527:
      case 531:
      case 532:
      case 533:
      case 534:
      case 535:
      case 537:
      case 538:
        return result;
      case 517:
        unsigned int v45 = **(_DWORD **)(a2 + 16);
        if (v45 > 0xA) {
          return 22;
        }
        if (v45)
        {
          uint64_t result = 0;
          *(unsigned char *)(v8 + 265) = v45;
          return result;
        }
        *(unsigned char *)(v8 + 265) = 0;
        tcp_keepalive_reset(v8);
        return 0;
      case 519:
        unsigned int v46 = **(_DWORD **)(a2 + 16);
        if (v46 > 0xA) {
          return 22;
        }
        uint64_t result = 0;
        *(unsigned char *)(v8 + 266) = v46;
        return result;
      case 520:
LABEL_63:
        int v30 = (v10 == 520) << 11;
        uint64_t result = 0;
        if (**(_DWORD **)(a2 + 16)) {
          int v31 = *(_DWORD *)(v8 + 740) | v30;
        }
        else {
          int v31 = *(_DWORD *)(v8 + 740) & ~v30;
        }
        *(_DWORD *)(v8 + 740) = v31;
        return result;
      case 521:
        unsigned int v47 = **(_DWORD **)(a2 + 16);
        if (v47 > 1) {
          return 22;
        }
        int v48 = *(_DWORD *)(v8 + 740);
        if (!v47)
        {
          uint64_t result = 0;
          *(_DWORD *)(v8 + 740) = v48 & 0xFFFDFFFF;
          return result;
        }
        *(_DWORD *)(v8 + 740) = v48 | 0x20000;
        if ((*(unsigned char *)(v8 + 91) & 0x20) != 0 && *(_WORD *)(v8 + 698)) {
          tcp_pmtud_revert_segment_size(v8);
        }
        return 0;
      case 528:
        int v49 = **(_DWORD **)(a2 + 16);
        if (v49 == 2)
        {
          uint64_t result = 0;
          unsigned int v71 = *(_DWORD *)(v8 + 348) & 0xFFFFF3FF;
LABEL_211:
          *(_DWORD *)(v8 + 348) = v71 | 0x800;
        }
        else if (v49 == 1)
        {
          uint64_t result = 0;
          unsigned int v71 = *(_DWORD *)(v8 + 348) & 0xFFFFF3FF;
LABEL_213:
          *(_DWORD *)(v8 + 348) = v71 | 0x400;
        }
        else
        {
          if (v49) {
            return 22;
          }
          uint64_t result = 0;
          *(_DWORD *)(v8 + 348) &= 0xFFFFF3FF;
        }
        return result;
      case 529:
        int v50 = **(_DWORD **)(a2 + 16);
        if (v50 < 0) {
          return 22;
        }
        int v51 = *(_DWORD *)(v2 + 2232);
        uint64_t result = 0;
        if (v50) {
          unsigned int v52 = v51 | 0x40;
        }
        else {
          unsigned int v52 = v51 & 0xFFFFFFBF;
        }
        *(_DWORD *)(v2 + 2232) = v52;
        return result;
      case 530:
        int v53 = **(_DWORD **)(a2 + 16);
        if (v53 < 1) {
          return 22;
        }
        if (*(unsigned __int8 *)(v8 + 732) > 9u) {
          return 59;
        }
        int v78 = *(_DWORD *)(a1 + 384);
        if (!v78) {
          return 55;
        }
        uint64_t v79 = *(void *)(v8 + 1032);
        if (!v79)
        {
LABEL_209:
          tcp_add_notify_ack_marker(v8, v53);
          return 0;
        }
        while (*(_DWORD *)(v79 + 4) != v53 && *(_DWORD *)v79 != *(_DWORD *)(v8 + 92) + v78)
        {
          uint64_t v79 = *(void *)(v79 + 8);
          if (!v79) {
            goto LABEL_209;
          }
        }
        return 22;
      case 536:
        unsigned int v54 = **(_DWORD **)(a2 + 16);
        if (v54 > 1 || *(_DWORD *)(v8 + 12)) {
          return 22;
        }
        int v55 = *(_DWORD *)(v8 + 740);
        uint64_t result = 0;
        if (v54) {
          unsigned int v56 = v55 | 0x1000000;
        }
        else {
          unsigned int v56 = v55 & 0xFEFFFFFF;
        }
        *(_DWORD *)(v8 + 740) = v56;
        return result;
      case 539:
        unsigned int v57 = **(_DWORD **)(a2 + 16);
        if (v57 > 1) {
          return 22;
        }
        if (v57 == 1) {
          int v58 = 0x8000000;
        }
        else {
          int v58 = 0x10000000;
        }
        *(_DWORD *)(v8 + 740) = *(_DWORD *)(v8 + 740) & 0xE7FFFFFF | v58;
        tcp_set_foreground_cc(a1);
        return 0;
      default:
        if (v10 == 4355)
        {
          inp_flush();
          return 0;
        }
        if (v10 != 4357) {
          return result;
        }
        int v27 = *(_DWORD *)(a1 + 368);
        if (**(_DWORD **)(a2 + 16))
        {
          *(_DWORD *)(a1 + 368) = v27 | 0x2000;
          if (*(void *)(a1 + 24))
          {
            uint64_t all_stats = nw_protocol_tcp_get_all_stats();
            if (all_stats)
            {
              unsigned int v29 = *(_DWORD *)(all_stats + 128) | 1;
LABEL_202:
              *(_DWORD *)(all_stats + 128) = v29;
            }
          }
        }
        else
        {
          *(_DWORD *)(a1 + 368) = v27 & 0xFFFFDFFF;
          if (*(void *)(a1 + 24))
          {
            uint64_t all_stats = nw_protocol_tcp_get_all_stats();
            if (all_stats)
            {
              unsigned int v29 = *(_DWORD *)(all_stats + 128) & 0xFFFFFFFE;
              goto LABEL_202;
            }
          }
        }
        set_tcp_stream_priority(a1);
        break;
    }
    return 0;
  }
  if (v10 > 0x200)
  {
    switch(v10)
    {
      case 256:
        goto LABEL_63;
      case 257:
        unsigned int v12 = **(_DWORD **)(a2 + 16);
        if (v12 > 0x418937) {
          return 22;
        }
        *(_DWORD *)(v8 + 684) = 1000 * v12;
        if (*(_DWORD *)(v8 + 12) != 9) {
          return 0;
        }
        int v13 = *(_DWORD *)(v8 + 688);
        if (v13)
        {
          if (v12) {
            goto LABEL_19;
          }
        }
        else
        {
          int v13 = *(_DWORD *)(sysctls + 200);
          if (v12)
          {
LABEL_19:
            if (!(1000 * v12 * v13)) {
              return 0;
            }
            goto LABEL_242;
          }
        }
        if (!(*(_DWORD *)(sysctls + 196) * v13)) {
          return 0;
        }
LABEL_242:
        uint64_t v81 = nw_tcp_access_globals(*(void *)(*(void *)(v8 + 80) + 224));
        int v82 = *(_DWORD *)(v8 + 688);
        if (!v82) {
          int v82 = *(_DWORD *)(sysctls + 200);
        }
        int v83 = *(_DWORD *)(v8 + 684);
        if (!v83) {
          int v83 = *(_DWORD *)(sysctls + 196);
        }
        *(_DWORD *)(v8 + 44) = *(_DWORD *)(v81 + 316) + v83 * v82 - *(_DWORD *)(v8 + 64);
LABEL_247:
        tcp_check_timer_state(v8);
        return 0;
      case 258:
        int v66 = **(_DWORD **)(a2 + 16);
        if (v66 < 0) {
          return 22;
        }
        *(_DWORD *)(v8 + 688) = v66;
        if (*(_DWORD *)(v8 + 12) != 9) {
          return 0;
        }
        if (!v66) {
          int v66 = *(_DWORD *)(sysctls + 200);
        }
        int v67 = *(_DWORD *)(v8 + 684);
        if (!v67) {
          int v67 = *(_DWORD *)(sysctls + 196);
        }
        if (!(v67 * v66)) {
          return 0;
        }
        goto LABEL_242;
      case 259:
        unsigned int v68 = **(_DWORD **)(a2 + 16);
        if (v68 > 1) {
          return 22;
        }
        int v69 = *(_DWORD *)(v8 + 740);
        uint64_t result = 0;
        if (v68) {
          unsigned int v70 = v69 | 0x200;
        }
        else {
          unsigned int v70 = v69 & 0xFFFFFDFF;
        }
        *(_DWORD *)(v8 + 740) = v70;
        return result;
      case 260:
        unsigned int v71 = *(_DWORD *)(v8 + 348) & 0xFFFFF3FF;
        uint64_t result = 0;
        if (!**(_DWORD **)(a2 + 16)) {
          goto LABEL_211;
        }
        goto LABEL_213;
      case 261:
        if ((*(unsigned char *)(sysctls + 160) & 1) == 0) {
          return 45;
        }
        unsigned int v72 = **(_DWORD **)(a2 + 16);
        if (v72 > 1 || *(_DWORD *)(v8 + 12) != 1) {
          return 22;
        }
        int v73 = *(_DWORD *)(v8 + 740);
        uint64_t result = 0;
        if (v72) {
          unsigned int v74 = v73 | 0x400000;
        }
        else {
          unsigned int v74 = v73 & 0xFFBFFFFF;
        }
        *(_DWORD *)(v8 + 740) = v74;
        return result;
      default:
        return result;
    }
  }
  switch(v10)
  {
    case 1:
    case 4:
    case 8:
      if (v10 == 1)
      {
        int v10 = 4;
      }
      else if (v10 == 4)
      {
        int v10 = 4096;
      }
      else if (v10 != 8)
      {
        int v10 = 0;
      }
      uint64_t result = 0;
      if (**(_DWORD **)(a2 + 16)) {
        int v77 = *(_DWORD *)(v8 + 88) | v10;
      }
      else {
        int v77 = *(_DWORD *)(v8 + 88) & ~v10;
      }
      *(_DWORD *)(v8 + 88) = v77;
      return result;
    case 2:
      int v32 = **(_DWORD **)(a2 + 16);
      if (v32 >= 1 && v32 <= *(_DWORD *)(v8 + 196) && v32 + 40 >= *(_DWORD *)(sysctls + 164))
      {
        uint64_t result = 0;
        *(_DWORD *)(v8 + 196) = v32;
        return result;
      }
      if ((*(unsigned char *)(a1 + 828) & 2) == 0)
      {
        int v33 = __nwlog_tcp_log();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          int v34 = *(_DWORD *)(v8 + 196);
          int v35 = *(_DWORD *)(sysctls + 164);
          *(_DWORD *)long long buf = 136447234;
          *(void *)&uint8_t buf[4] = "tcp_ctloutput";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = a1 + 604;
          *(_WORD *)&unsigned char buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = v32;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v34;
          *(_WORD *)&unsigned char buf[34] = 1024;
          *(_DWORD *)&buf[36] = v35;
          _os_log_impl(&dword_214653000, v33, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s EINVAL: optval %d t_maxseg %u tcp_minmss %d", buf, 0x28u);
          return 22;
        }
      }
      break;
    case 3:
    case 5:
    case 6:
    case 7:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
      return result;
    case 16:
      unsigned int v36 = **(_DWORD **)(a2 + 16);
      if (v36 > 0x418937) {
        return 22;
      }
      *(_DWORD *)(v8 + 676) = 1000 * v36;
      int v37 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v8 + 80) + 224)) + 316);
      int v38 = *(_DWORD *)(v8 + 676);
      if (!v38 || (*(unsigned char *)(*(void *)(*(void *)(v8 + 80) + 224) + 372) & 8) == 0) {
        int v38 = *(_DWORD *)(sysctls + 192);
      }
      goto LABEL_82;
    case 32:
      unsigned int v39 = **(_DWORD **)(a2 + 16);
      if (v39 > 0x418937) {
        return 22;
      }
      *(_DWORD *)(v8 + 680) = 1000 * v39;
      if ((*(_DWORD *)(v8 + 12) - 1) > 2) {
        return 0;
      }
      int v37 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v8 + 80) + 224)) + 316);
      int v38 = *(_DWORD *)(v8 + 680);
      if (!v38) {
        int v38 = *(_DWORD *)(sysctls + 188);
      }
LABEL_82:
      *(_DWORD *)(v8 + 40) = v38 + v37 - *(_DWORD *)(v8 + 64);
      goto LABEL_247;
    case 64:
      int v40 = **(_DWORD **)(a2 + 16);
      if (v40 < 0) {
        return 22;
      }
      uint64_t result = 0;
      *(_DWORD *)(v8 + 312) = 1000 * v40;
      return result;
    default:
      goto LABEL_250;
  }
  return 22;
}

uint64_t __nw_protocol_tcp_wake_read_closed_block_invoke(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)(a1 + 40);
  if (*(_DWORD *)(*(void *)(a1 + 32) + 5224) < 3u)
  {
    if (!v1 || (*(unsigned char *)(v1 + 828) & 2) == 0)
    {
      uint64_t v4 = __nwlog_tcp_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        int v5 = "";
        if (v1) {
          int v5 = (const char *)(v1 + 604);
        }
        int v7 = 136446466;
        uint64_t v8 = "nw_protocol_tcp_wake_read_closed_block_invoke";
        __int16 v9 = 2082;
        int v10 = v5;
        _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_INFO, "%{public}s %{public}s read closed", (uint8_t *)&v7, 0x16u);
      }
    }
    nw_protocol_get_input_handler();
    nw_protocol_input_finished_quiet();
  }
  else if (!v1 || (*(unsigned char *)(v1 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      uint64_t v2 = __nwlog_tcp_log();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
      {
        unsigned int v3 = "";
        if (v1) {
          unsigned int v3 = (const char *)(v1 + 604);
        }
        int v7 = 136446466;
        uint64_t v8 = "nw_protocol_tcp_wake_read_closed_block_invoke";
        __int16 v9 = 2082;
        int v10 = v3;
        _os_log_impl(&dword_214653000, v2, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v7, 0x16u);
      }
    }
  }
  return nw_protocol_release();
}

uint64_t __nw_protocol_tcp_wake_disconnected_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(v2 + 5308);
  if ((v3 & 4) == 0)
  {
    nw_protocol_get_output_handler();
    nw_protocol_disconnect_quiet();
    uint64_t v2 = *(void *)(a1 + 32);
    int v3 = *(_DWORD *)(v2 + 5308);
  }
  if (v3) {
    nw_protocol_tcp_release(v2);
  }

  return nw_protocol_release();
}

void nw_protocol_tcp_release(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    *(_DWORD *)(a1 + 5308) &= ~1u;
    nw_protocol_upcast();
    nw_protocol_get_output_handler();
    if (nw_protocol_remove_input_handler_is_valid())
    {
      nw_protocol_get_output_handler();
      nw_protocol_remove_input_handler();
    }
    else if ((*(unsigned char *)(a1 + 828) & 2) == 0)
    {
      uint64_t v2 = __nwlog_tcp_log();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446466;
        int v6 = "nw_protocol_tcp_release";
        __int16 v7 = 2082;
        uint64_t v8 = a1 + 604;
        _os_log_impl(&dword_214653000, v2, OS_LOG_TYPE_ERROR, "%{public}s %{public}s remove_input_handler is not valid", buf, 0x16u);
      }
    }
    nw_protocol_destroy();
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v6 = "nw_protocol_tcp_release";
    int v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        int v6 = "nw_protocol_tcp_release";
        _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_ERROR, "%{public}s called with null tcp, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v3) {
      free(v3);
    }
  }
}

void __nw_protocol_tcp_release_block_invoke(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v13 = "nw_protocol_tcp_dispose";
    uint64_t v9 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_23;
    }
    int v10 = __nwlog_obj();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    *(_DWORD *)long long buf = 136446210;
    int v13 = "nw_protocol_tcp_dispose";
    uint64_t v11 = "%{public}s called with null object, backtrace limit exceeded";
    goto LABEL_22;
  }
  if ((*(unsigned char *)(v1 + 828) & 2) == 0)
  {
    uint64_t v2 = __nwlog_tcp_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 136446466;
      int v13 = "nw_protocol_tcp_dispose";
      __int16 v14 = 2082;
      uint64_t v15 = v1 + 604;
      _os_log_impl(&dword_214653000, v2, OS_LOG_TYPE_INFO, "%{public}s %{public}s tcp dispose", buf, 0x16u);
    }
  }
  int v3 = *(void **)(v1 + 5208);
  if (v3)
  {
    nw_release(v3);
    *(void *)(v1 + 5208) = 0;
  }
  if (*(void *)(v1 + 5232))
  {
    nw_tcp_set_callbacks();
    uint64_t v4 = *(void **)(v1 + 5232);
    if (v4)
    {
      nw_release(v4);
      *(void *)(v1 + 5232) = 0;
    }
  }
  int v5 = *(void **)(v1 + 5216);
  if (v5)
  {
    nw_release(v5);
    *(void *)(v1 + 5216) = 0;
  }
  int v6 = *(void **)(v1 + 5200);
  if (v6)
  {
    nw_release(v6);
    *(void *)(v1 + 5200) = 0;
  }
  __int16 v7 = *(void **)(v1 + 5272);
  if (v7)
  {
    free(v7);
    *(void *)(v1 + 5272) = 0;
  }
  uint64_t v8 = *(void **)(v1 + 5280);
  if (v8)
  {
    free(v8);
    *(void *)(v1 + 5280) = 0;
  }
  bzero((void *)v1, 0x1440uLL);
  if (*(unsigned char *)(v1 + 5308))
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v13 = "nw_protocol_tcp_dispose";
    uint64_t v9 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_23;
    }
    int v10 = __nwlog_obj();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    *(_DWORD *)long long buf = 136446210;
    int v13 = "nw_protocol_tcp_dispose";
    uint64_t v11 = "%{public}s tcp->release_is_delayed set during dispose, backtrace limit exceeded";
LABEL_22:
    _os_log_impl(&dword_214653000, v10, OS_LOG_TYPE_ERROR, v11, buf, 0xCu);
LABEL_23:
    if (v9) {
      free(v9);
    }
  }
}

uint64_t nw_protocol_tcp_remove_input_handler(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v22 = "nw_protocol_tcp_remove_input_handler";
    uint64_t v16 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      os_log_type_t v18 = __nwlog_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        int v22 = "nw_protocol_tcp_remove_input_handler";
        int v19 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_41:
        _os_log_impl(&dword_214653000, v18, OS_LOG_TYPE_ERROR, v19, buf, 0xCu);
      }
    }
LABEL_42:
    if (v16) {
      free(v16);
    }
    return 0;
  }
  uint64_t v7 = nw_protocol_downcast();
  if (!v7)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v22 = "nw_protocol_tcp_remove_input_handler";
    uint64_t v16 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      os_log_type_t v18 = __nwlog_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        int v22 = "nw_protocol_tcp_remove_input_handler";
        int v19 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_41;
      }
    }
    goto LABEL_42;
  }
  uint64_t v8 = v7;
  if ((*(unsigned char *)(v7 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      os_log_type_t v17 = __nwlog_tcp_log();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 136446466;
        int v22 = "nw_protocol_tcp_remove_input_handler";
        __int16 v23 = 2082;
        uint64_t v24 = v8 + 604;
        _os_log_impl(&dword_214653000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s protocol upper layer initiated remove_input_handler", buf, 0x16u);
      }
    }
  }
  if (nw_protocol_get_output_handler() == a1) {
    nw_protocol_set_output_handler();
  }
  if (nw_protocol_get_input_handler() != a2)
  {
    if ((*(unsigned char *)(v8 + 828) & 2) == 0)
    {
      uint64_t v9 = __nwlog_tcp_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446466;
        int v22 = "nw_protocol_tcp_remove_input_handler";
        __int16 v23 = 2082;
        uint64_t v24 = v8 + 604;
        _os_log_impl(&dword_214653000, v9, OS_LOG_TYPE_ERROR, "%{public}s %{public}s default_input_handler is different from the input_protocol", buf, 0x16u);
        return 0;
      }
    }
    return 0;
  }
  nw_protocol_set_input_handler();
  if (!a3) {
    return 1;
  }
  int v11 = *(_DWORD *)(v8 + 5308);
  if (v11)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v22 = "nw_protocol_tcp_remove_input_handler";
    unsigned int v12 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v13 = __nwlog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        int v22 = "nw_protocol_tcp_remove_input_handler";
        _os_log_impl(&dword_214653000, v13, OS_LOG_TYPE_ERROR, "%{public}s tcp->release_is_delayed already set, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v12) {
      free(v12);
    }
    int v11 = *(_DWORD *)(v8 + 5308);
  }
  *(_DWORD *)(v8 + 5308) = v11 | 1;
  int v14 = *(_DWORD *)(v8 + 5224);
  if ((v14 - 1) >= 2)
  {
    if (!v14 || v14 == 4) {
      nw_protocol_tcp_release(v8);
    }
    return 1;
  }
  *(_DWORD *)(v8 + 5308) = v11 | 3;
  *(_DWORD *)(v8 + 5224) = 3;
  if ((*(unsigned char *)(v8 + 828) & 2) == 0)
  {
    uint64_t v15 = __nwlog_tcp_log();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 136446466;
      int v22 = "nw_protocol_tcp_remove_input_handler";
      __int16 v23 = 2082;
      uint64_t v24 = v8 + 604;
      _os_log_impl(&dword_214653000, v15, OS_LOG_TYPE_INFO, "%{public}s %{public}s force closing tcp", buf, 0x16u);
    }
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v8 + 8) + 16))(v8, 1, v3);
  if ((~*(unsigned __int16 *)(v8 + 376) & 0x30) != 0 || (*(unsigned char *)(v8 + 365) & 0x20) != 0)
  {
    *(_DWORD *)(v8 + 16) = 0;
    *(_DWORD *)(v8 + 372) |= 0x80u;
  }
  uint64_t v10 = 1;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v8 + 8) + 24))(v8, 1, v3);
  tcp_close_locked(v8);
  return v10;
}

void nw_protocol_tcp_disconnected(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v1 = nw_protocol_downcast();
    if (v1)
    {
      uint64_t v2 = v1;
      if ((*(unsigned char *)(v1 + 828) & 2) == 0)
      {
        uint64_t v3 = __nwlog_tcp_log();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v10 = "nw_protocol_tcp_disconnected";
          __int16 v11 = 2082;
          uint64_t v12 = v2 + 604;
          _os_log_impl(&dword_214653000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s output protocol is disconnected", buf, 0x16u);
        }
      }
      int v4 = *(_DWORD *)(v2 + 5308);
      if ((v4 & 4) != 0)
      {
        if ((*(unsigned char *)(v2 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
        {
          int v6 = __nwlog_tcp_log();
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 136446466;
            uint64_t v10 = "nw_protocol_tcp_disconnected";
            __int16 v11 = 2082;
            uint64_t v12 = v2 + 604;
            _os_log_impl(&dword_214653000, v6, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
          }
        }
      }
      else
      {
        *(_DWORD *)(v2 + 5308) = v4 | 4;
        *(_OWORD *)(v2 + 4128) = 0u;
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v10 = "nw_protocol_tcp_disconnected";
    int v5 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v7 = __nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v10 = "nw_protocol_tcp_disconnected";
        uint64_t v8 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v10 = "nw_protocol_tcp_disconnected";
    int v5 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v7 = __nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v10 = "nw_protocol_tcp_disconnected";
        uint64_t v8 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_21:
        _os_log_impl(&dword_214653000, v7, OS_LOG_TYPE_ERROR, v8, buf, 0xCu);
      }
    }
  }
  if (v5) {
    free(v5);
  }
}

uint64_t nw_protocol_tcp_unregister_notification(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v5 = nw_protocol_downcast();
    if (v5)
    {
      uint64_t v6 = v5;
      if (*(_DWORD *)(v5 + 5224) > 2u) {
        return 1;
      }
      uint64_t v7 = 1;
      switch(a3)
      {
        case 0:
          __nwlog_obj();
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = nw_protocol_notification_type_to_string();
          uint64_t v8 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          if (!__nwlog_fault()) {
            goto LABEL_49;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            uint64_t v9 = __nwlog_obj();
            os_log_type_t v10 = type[0];
            if (!os_log_type_enabled(v9, type[0])) {
              goto LABEL_49;
            }
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = nw_protocol_notification_type_to_string();
            __int16 v11 = "%{public}s invalid registration notification: %{public}s";
          }
          else
          {
            uint64_t v9 = __nwlog_obj();
            os_log_type_t v10 = type[0];
            if (!os_log_type_enabled(v9, type[0])) {
              goto LABEL_49;
            }
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = nw_protocol_notification_type_to_string();
            __int16 v11 = "%{public}s invalid registration notification: %{public}s, backtrace limit exceeded";
          }
          int v20 = v9;
          os_log_type_t v21 = v10;
          uint32_t v22 = 22;
          goto LABEL_48;
        case 1:
          if ((~*(unsigned __int16 *)(v5 + 376) & 0x30) == 0) {
            goto LABEL_29;
          }
          *(_DWORD *)os_log_type_t type = 0;
          *(void *)long long buf = 0x600000001;
          *(void *)&buf[8] = 517;
          *(void *)&buf[16] = type;
          uint64_t v28 = 4;
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 + 8) + 16))(v5, 1, v3);
          if ((~*(unsigned __int16 *)(v6 + 376) & 0x30) != 0 || (*(unsigned char *)(v6 + 365) & 0x20) != 0) {
            int v12 = tcp_ctloutput(v6, (uint64_t)buf);
          }
          else {
            int v12 = 22;
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 + 8) + 24))(v6, 1, v3);
          if (!v12)
          {
LABEL_29:
            unsigned int v18 = *(_DWORD *)(v6 + 5308) & 0xFFFFFFBF;
            goto LABEL_37;
          }
          __nwlog_obj();
          uint64_t v15 = v6 + 604;
          *(_DWORD *)long long buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v6 + 604;
          *(_WORD *)&unsigned char buf[22] = 1024;
          LODWORD(v28) = v12;
          uint64_t v8 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          if (!__nwlog_fault()) {
            goto LABEL_49;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            uint64_t v16 = __nwlog_obj();
            os_log_type_t v17 = type[0];
            if (!os_log_type_enabled(v16, type[0])) {
              goto LABEL_49;
            }
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v15;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v28) = v12;
            __int16 v11 = "%{public}s %{public}s tcp_set_read_timeout failed %{darwin.errno}d";
          }
          else
          {
            uint64_t v16 = __nwlog_obj();
            os_log_type_t v17 = type[0];
            if (!os_log_type_enabled(v16, type[0])) {
              goto LABEL_49;
            }
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v15;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v28) = v12;
            __int16 v11 = "%{public}s %{public}s tcp_set_read_timeout failed %{darwin.errno}d, backtrace limit exceeded";
          }
          goto LABEL_47;
        case 2:
          if ((~*(unsigned __int16 *)(v5 + 376) & 0x30) == 0) {
            goto LABEL_36;
          }
          *(_DWORD *)os_log_type_t type = 0;
          *(void *)long long buf = 0x600000001;
          *(void *)&buf[8] = 519;
          *(void *)&buf[16] = type;
          uint64_t v28 = 4;
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 + 8) + 16))(v5, 1, v3);
          if ((~*(unsigned __int16 *)(v6 + 376) & 0x30) != 0 || (*(unsigned char *)(v6 + 365) & 0x20) != 0) {
            int v13 = tcp_ctloutput(v6, (uint64_t)buf);
          }
          else {
            int v13 = 22;
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 + 8) + 24))(v6, 1, v3);
          if (!v13)
          {
LABEL_36:
            unsigned int v18 = *(_DWORD *)(v6 + 5308) & 0xFFFFFF7F;
LABEL_37:
            *(_DWORD *)(v6 + 5308) = v18;
            return 1;
          }
          __nwlog_obj();
          uint64_t v19 = v6 + 604;
          *(_DWORD *)long long buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v6 + 604;
          *(_WORD *)&unsigned char buf[22] = 1024;
          LODWORD(v28) = v13;
          uint64_t v8 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          if (!__nwlog_fault()) {
            goto LABEL_49;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            uint64_t v16 = __nwlog_obj();
            os_log_type_t v17 = type[0];
            if (!os_log_type_enabled(v16, type[0])) {
              goto LABEL_49;
            }
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v19;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v28) = v13;
            __int16 v11 = "%{public}s %{public}s tcp_set_write_timeout failed %{darwin.errno}d";
          }
          else
          {
            uint64_t v16 = __nwlog_obj();
            os_log_type_t v17 = type[0];
            if (!os_log_type_enabled(v16, type[0])) {
              goto LABEL_49;
            }
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v19;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v28) = v13;
            __int16 v11 = "%{public}s %{public}s tcp_set_write_timeout failed %{darwin.errno}d, backtrace limit exceeded";
          }
LABEL_47:
          int v20 = v16;
          os_log_type_t v21 = v17;
          uint32_t v22 = 28;
          break;
        case 3:
          *(_DWORD *)(v5 + 5308) &= ~0x100u;
          return v7;
        case 4:
        case 5:
          return v7;
        case 14:
          *(_DWORD *)(v5 + 5308) &= ~0x400000u;
          if ((*(unsigned char *)(v5 + 828) & 2) == 0)
          {
            int v14 = __nwlog_tcp_log();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)long long buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v6 + 604;
              _os_log_impl(&dword_214653000, v14, OS_LOG_TYPE_INFO, "%{public}s %{public}s segmentation_offload_notification disabled", buf, 0x16u);
            }
          }
          return v7;
        default:
          return 0;
      }
      goto LABEL_48;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
    uint64_t v8 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault()) {
      goto LABEL_49;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v24 = __nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_49;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
      __int16 v11 = "%{public}s called with null tcp";
    }
    else
    {
      uint64_t v24 = __nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_49;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
      __int16 v11 = "%{public}s called with null tcp, backtrace limit exceeded";
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
    uint64_t v8 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (!__nwlog_fault()) {
      goto LABEL_49;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v24 = __nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_49;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
      __int16 v11 = "%{public}s called with null protocol";
    }
    else
    {
      uint64_t v24 = __nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_49;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
      __int16 v11 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
  }
  int v20 = v24;
  os_log_type_t v21 = v25;
  uint32_t v22 = 12;
LABEL_48:
  _os_log_impl(&dword_214653000, v20, v21, v11, buf, v22);
LABEL_49:
  if (v8) {
    free(v8);
  }
  return 0;
}

uint64_t nw_protocol_tcp_updated_path(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v166 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    __int16 v149 = "nw_protocol_tcp_updated_path";
    int v134 = (void *)_os_log_send_and_compose_impl();
    v165[0] = 16;
    v164[0] = 0;
    if (!__nwlog_fault()) {
      goto LABEL_335;
    }
    if (v165[0] != 17)
    {
      __int16 v135 = __nwlog_obj();
      os_log_type_t v136 = v165[0];
      if (os_log_type_enabled(v135, (os_log_type_t)v165[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v149 = "nw_protocol_tcp_updated_path";
        __int16 v137 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_334;
      }
      goto LABEL_335;
    }
    __int16 v135 = __nwlog_obj();
    os_log_type_t v136 = v165[0];
    if (!os_log_type_enabled(v135, (os_log_type_t)v165[0])) {
      goto LABEL_335;
    }
    *(_DWORD *)long long buf = 136446210;
    __int16 v149 = "nw_protocol_tcp_updated_path";
    __int16 v137 = "%{public}s called with null protocol";
LABEL_334:
    _os_log_impl(&dword_214653000, v135, v136, v137, buf, 0xCu);
    goto LABEL_335;
  }
  uint64_t v4 = v3;
  uint64_t v7 = nw_protocol_downcast();
  if (!v7)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    __int16 v149 = "nw_protocol_tcp_updated_path";
    int v134 = (void *)_os_log_send_and_compose_impl();
    v165[0] = 16;
    v164[0] = 0;
    if (!__nwlog_fault()) {
      goto LABEL_335;
    }
    if (v165[0] != 17)
    {
      __int16 v135 = __nwlog_obj();
      os_log_type_t v136 = v165[0];
      if (os_log_type_enabled(v135, (os_log_type_t)v165[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v149 = "nw_protocol_tcp_updated_path";
        __int16 v137 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_334;
      }
      goto LABEL_335;
    }
    __int16 v135 = __nwlog_obj();
    os_log_type_t v136 = v165[0];
    if (!os_log_type_enabled(v135, (os_log_type_t)v165[0])) {
      goto LABEL_335;
    }
    *(_DWORD *)long long buf = 136446210;
    __int16 v149 = "nw_protocol_tcp_updated_path";
    __int16 v137 = "%{public}s called with null tcp";
    goto LABEL_334;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    __int16 v149 = "nw_protocol_tcp_updated_path";
    int v134 = (void *)_os_log_send_and_compose_impl();
    v165[0] = 16;
    v164[0] = 0;
    if (!__nwlog_fault()) {
      goto LABEL_335;
    }
    if (v165[0] != 17)
    {
      __int16 v135 = __nwlog_obj();
      os_log_type_t v136 = v165[0];
      if (os_log_type_enabled(v135, (os_log_type_t)v165[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v149 = "nw_protocol_tcp_updated_path";
        __int16 v137 = "%{public}s called with null path, backtrace limit exceeded";
        goto LABEL_334;
      }
      goto LABEL_335;
    }
    __int16 v135 = __nwlog_obj();
    os_log_type_t v136 = v165[0];
    if (!os_log_type_enabled(v135, (os_log_type_t)v165[0])) {
      goto LABEL_335;
    }
    *(_DWORD *)long long buf = 136446210;
    __int16 v149 = "nw_protocol_tcp_updated_path";
    __int16 v137 = "%{public}s called with null path";
    goto LABEL_334;
  }
  uint64_t v8 = (void **)v7;
  uint64_t v9 = *(void *)(v7 + 1280);
  if ((*(unsigned char *)(v7 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      int v138 = __nwlog_tcp_log();
      if (os_log_type_enabled(v138, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 136446466;
        __int16 v149 = "nw_protocol_tcp_updated_path";
        __int16 v150 = 2082;
        *(void *)__int16 v151 = (char *)v8 + 604;
        _os_log_impl(&dword_214653000, v138, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s ", buf, 0x16u);
      }
    }
  }
  if (v8[651] != a3)
  {
    os_log_type_t v10 = nw_retain(a3);
    __int16 v11 = v8[651];
    if (v11) {
      nw_release(v11);
    }
    v8[651] = v10;
    if (nw_path_is_viable()) {
      int v12 = 0x2000;
    }
    else {
      int v12 = 0;
    }
    *((_DWORD *)v8 + 1327) = *((_DWORD *)v8 + 1327) & 0xFFFFDFFF | v12;
  }
  nw_proto_tcp_notify_segmentation_offload(a1);
  uint64_t v13 = (uint64_t)*v8;
  if (*v8)
  {
    uint64_t v14 = *(void *)(v13 + 496);
    if (v14 && *(unsigned char *)(v14 + 1496))
    {
      uint64_t v15 = *(void **)(v14 + 1488);
      if (v15)
      {
        free(v15);
        uint64_t v13 = (uint64_t)*v8;
        *(void *)((*v8)[62] + 1488) = 0;
        uint64_t v14 = *(void *)(v13 + 496);
      }
      *(unsigned char *)(v14 + 1496) = 0;
    }
    *(void *)(v13 + 496) = 0;
    tcp_mtudisc(*v8);
  }
  uint64_t v16 = v8[652];
  nw_protocol_get_input_handler();
  if (nw_protocol_get_parameters())
  {
    os_log_type_t v17 = (void *)nw_parameters_copy_context();
    v8[652] = (void *)nw_path_copy_flow_registration();
    if (v17) {
      nw_release(v17);
    }
    if (v16) {
      nw_release(v16);
    }
    int v18 = *((_DWORD *)v8 + 1306);
    if ((v18 - 1) > 1)
    {
LABEL_79:
      if ((v18 | 4) == 4) {
        goto LABEL_280;
      }
      unsigned int v47 = v8[652];
      if (v8[651])
      {
        if (!v47) {
          goto LABEL_159;
        }
        *(_DWORD *)unsigned int v165 = 0;
        *(_DWORD *)unsigned int v164 = 0;
        if (nw_path_flow_registration_get_ctl_command())
        {
          if ((*((unsigned char *)v8 + 828) & 2) == 0)
          {
            if (__nwlog_is_datapath_logging_enabled())
            {
              __int16 v145 = __nwlog_tcp_log();
              if (os_log_type_enabled(v145, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)long long buf = 136446978;
                __int16 v149 = "nw_protocol_tcp_updated_path";
                __int16 v150 = 2082;
                *(void *)__int16 v151 = (char *)v8 + 604;
                *(_WORD *)&v151[8] = 1024;
                *(_DWORD *)int v152 = *(_DWORD *)v165;
                *(_WORD *)&v152[4] = 1024;
                *(_DWORD *)&v152[6] = *(_DWORD *)v164;
                _os_log_impl(&dword_214653000, v145, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Protocol event %d=%d", buf, 0x22u);
              }
            }
          }
          uint64_t v48 = *(unsigned int *)v165;
          unint64_t v49 = *(unsigned int *)v164;
          while (1)
          {
            int v50 = *((_DWORD *)v8 + 322);
            if ((_WORD)v50 == 0xFFFF) {
              break;
            }
            int v51 = *((_DWORD *)v8 + 322);
            atomic_compare_exchange_strong_explicit((atomic_uint *volatile)v8 + 322, (unsigned int *)&v51, v50 + 1, memory_order_relaxed, memory_order_relaxed);
            if (v51 == v50)
            {
              uint64_t v52 = v8[132][1];
              int v53 = **(_DWORD **)(v52 + 8);
              if (v53 == 30)
              {
                if (v8[162] == (void *)*MEMORY[0x263EF88F0] && v8[163] == *(void **)(MEMORY[0x263EF88F0] + 8))
                {
                  unsigned int v54 = __nwlog_obj();
                  if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)long long buf = 136446210;
                    __int16 v149 = "tcp_ctlinput";
                    int v55 = "%{public}s Protocol event reported for socket with faddr IN6ADDR_ANY";
LABEL_138:
                    _os_log_impl(&dword_214653000, v54, OS_LOG_TYPE_ERROR, v55, buf, 0xCu);
                  }
LABEL_155:
                  in_pcb_checkstate((uint64_t)(v8 + 104), 2, 0);
                  goto LABEL_156;
                }
              }
              else
              {
                if (v53 != 2)
                {
                  unsigned int v70 = __nwlog_obj();
                  if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
                  {
                    int v71 = **(_DWORD **)(v8[132][1] + 8);
                    *(_DWORD *)long long buf = 136446466;
                    __int16 v149 = "tcp_ctlinput";
                    __int16 v150 = 1024;
                    *(_DWORD *)__int16 v151 = v71;
                    _os_log_impl(&dword_214653000, v70, OS_LOG_TYPE_ERROR, "%{public}s Protocol event reported for unknown address family %d", buf, 0x12u);
                  }
                  goto LABEL_155;
                }
                if (!*((_DWORD *)v8 + 327))
                {
                  unsigned int v54 = __nwlog_obj();
                  if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)long long buf = 136446210;
                    __int16 v149 = "tcp_ctlinput";
                    int v55 = "%{public}s Protocol event reported for socket with faddr INADDR_ANY";
                    goto LABEL_138;
                  }
                  goto LABEL_155;
                }
              }
              if (v48 > 0x15) {
                goto LABEL_155;
              }
              unsigned int v68 = (void (*)(uint64_t, int))tcp_mtudisc;
              if (v48 == 5)
              {
LABEL_133:
                int v69 = v68;
              }
              else if (!*(_DWORD *)(sysctls + 168) || (int v69 = tcp_drop_syn_sent, ((1 << v48) & 0x240C00) == 0))
              {
                if (v48 == 4) {
                  goto LABEL_155;
                }
                unsigned int v68 = tcp_notify;
                if ((0xFC01FuLL >> v48)) {
                  goto LABEL_155;
                }
                goto LABEL_133;
              }
              __int16 v147 = v69;
              (*(void (**)(void))(v52 + 16))();
              unsigned int v72 = v8[134];
              if ((int)v72[23] > 0 || -v72[24] >= 1)
              {
                if (__nwlog_is_datapath_logging_enabled())
                {
                  int v73 = __nwlog_obj();
                  if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
                  {
                    int v74 = v72[23];
                    int v75 = v72[24];
                    *(_DWORD *)long long buf = 136446978;
                    __int16 v149 = "tcp_ctlinput";
                    __int16 v150 = 1024;
                    *(_DWORD *)__int16 v151 = 0;
                    *(_WORD *)&v151[4] = 1024;
                    *(_DWORD *)&v151[6] = v74;
                    *(_WORD *)int v152 = 1024;
                    *(_DWORD *)&v152[2] = v75;
                    _os_log_impl(&dword_214653000, v73, OS_LOG_TYPE_DEBUG, "%{public}s ICMP response for ineligible TCP seq num (%d, una %d max %d)", buf, 0x1Eu);
                  }
                }
                goto LABEL_154;
              }
              if (v48 != 5 || (tcp_handle_msgsize((uint64_t)v8[166], v49), (*((unsigned char *)v8 + 3068) & 2) == 0))
              {
                int v76 = (char *)&tcpctlerrmap + v48;
                goto LABEL_153;
              }
              if ((unint64_t)v72[49] + 60 > v49)
              {
                int v76 = "(@A3A==(A";
LABEL_153:
                v147((uint64_t)(v8 + 104), *(unsigned __int8 *)v76);
              }
LABEL_154:
              (*(void (**)(void))(v8[132][1] + 24))();
              goto LABEL_155;
            }
          }
          if (__nwlog_is_datapath_logging_enabled())
          {
            unsigned int v56 = __nwlog_obj();
            if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 136446210;
              __int16 v149 = "tcp_ctlinput";
              _os_log_impl(&dword_214653000, v56, OS_LOG_TYPE_DEBUG, "%{public}s PCB marked as WNT_STOPUSING, exiting early", buf, 0xCu);
            }
          }
        }
LABEL_156:
        unsigned int v47 = v8[652];
      }
      if (v47 && !nw_path_is_defunct()) {
        goto LABEL_280;
      }
LABEL_159:
      if (tcp_perf_measurement)
      {
        if ((*((unsigned char *)v8 + 828) & 2) == 0)
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            int v77 = __nwlog_tcp_log();
            if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
            {
              int v78 = "defunct";
              uint64_t v79 = v8[652];
              __int16 v149 = "nw_protocol_tcp_updated_path";
              *(_DWORD *)long long buf = 136446722;
              __int16 v150 = 2082;
              if (!v79) {
                int v78 = "unregistered";
              }
              *(void *)__int16 v151 = (char *)v8 + 604;
              *(_WORD *)&v151[8] = 2082;
              *(void *)int v152 = v78;
              int v80 = v77;
              os_log_type_t v81 = OS_LOG_TYPE_DEBUG;
LABEL_171:
              _os_log_impl(&dword_214653000, v80, v81, "%{public}s %{public}s flow is %{public}s", buf, 0x20u);
            }
          }
        }
      }
      else if ((*((unsigned char *)v8 + 828) & 2) == 0)
      {
        int v82 = __nwlog_tcp_log();
        if (os_log_type_enabled(v82, OS_LOG_TYPE_INFO))
        {
          int v83 = "defunct";
          os_log_type_t v84 = v8[652];
          __int16 v149 = "nw_protocol_tcp_updated_path";
          *(_DWORD *)long long buf = 136446722;
          __int16 v150 = 2082;
          if (!v84) {
            int v83 = "unregistered";
          }
          *(void *)__int16 v151 = (char *)v8 + 604;
          *(_WORD *)&v151[8] = 2082;
          *(void *)int v152 = v83;
          int v80 = v82;
          os_log_type_t v81 = OS_LOG_TYPE_INFO;
          goto LABEL_171;
        }
      }
      ((void (*)(void **, uint64_t, uint64_t))v8[1][2])(v8, 1, v3);
      char v85 = v8 + 61;
      int v86 = v8 + 48;
      int v87 = *((_DWORD *)v8 + 91);
      if ((v87 & 8) == 0)
      {
        if ((v87 & 0x8000) != 0)
        {
          if ((*((unsigned char *)v8 + 828) & 2) == 0)
          {
            if (__nwlog_is_datapath_logging_enabled())
            {
              long long v94 = __nwlog_tcp_log();
              if (os_log_type_enabled(v94, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)long long buf = 136446978;
                __int16 v149 = "sosetdefunct";
                __int16 v150 = 2082;
                *(void *)__int16 v151 = (char *)v8 + 604;
                *(_WORD *)&v151[8] = 2082;
                *(void *)int v152 = "process_suspended";
                *(_WORD *)&v152[8] = 1024;
                LODWORD(v153) = 102;
                _os_log_impl(&dword_214653000, v94, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s level %{public}s flow is not eligible for defunct (%d)", buf, 0x26u);
              }
            }
          }
          goto LABEL_279;
        }
        *((_DWORD *)v8 + 91) = v87 | 8;
        *((_DWORD *)v8 + 108) |= 0x80u;
        *((_DWORD *)v8 + 134) |= 0x80u;
        if (*((_DWORD *)v8 + 122))
        {
          sbflush((uint64_t)(v8 + 61));
          *((_DWORD *)v8 + 123) = 0;
          uint64_t v88 = v8[70][3];
          if (((_BYTE)v8[67] & 4) != 0)
          {
            if (v88)
            {
              uint64_t all_stats = nw_protocol_tcp_get_all_stats();
              if (all_stats) {
                *(_DWORD *)(all_stats + 88) = *((_DWORD *)v8 + 123);
              }
            }
          }
          else if (v88)
          {
            uint64_t v89 = nw_protocol_tcp_get_all_stats();
            if (v89) {
              *(_DWORD *)(v89 + 100) = *((_DWORD *)v8 + 123);
            }
          }
        }
        if (*v86)
        {
          sbflush((uint64_t)(v8 + 48));
          *((_DWORD *)v8 + 97) = 0;
          uint64_t v99 = v8[57][3];
          if (((_BYTE)v8[54] & 4) != 0)
          {
            if (v99)
            {
              uint64_t v101 = nw_protocol_tcp_get_all_stats();
              if (v101) {
                *(_DWORD *)(v101 + 88) = *((_DWORD *)v8 + 97);
              }
            }
          }
          else if (v99)
          {
            uint64_t v100 = nw_protocol_tcp_get_all_stats();
            if (v100) {
              *(_DWORD *)(v100 + 100) = *((_DWORD *)v8 + 97);
            }
          }
        }
LABEL_212:
        if ((*((unsigned char *)v8 + 828) & 2) == 0)
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            __int16 v143 = __nwlog_tcp_log();
            if (os_log_type_enabled(v143, OS_LOG_TYPE_DEBUG))
            {
              int v144 = "is already";
              *(_DWORD *)long long buf = 136446978;
              __int16 v149 = "sosetdefunct";
              if ((v87 & 8) == 0) {
                int v144 = "marked as";
              }
              __int16 v150 = 2082;
              *(void *)__int16 v151 = (char *)v8 + 604;
              *(_WORD *)&v151[8] = 2082;
              *(void *)int v152 = "process_suspended";
              *(_WORD *)&v152[8] = 2082;
              __int16 v153 = v144;
              _os_log_impl(&dword_214653000, v143, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s level %{public}s flow %{public}s defunct", buf, 0x2Au);
            }
          }
        }
        if ((*((unsigned char *)v8 + 364) & 8) == 0)
        {
          if ((*((unsigned char *)v8 + 828) & 2) == 0)
          {
            __nwlog_tcp_log();
            *(_DWORD *)long long buf = 136446466;
            __int16 v149 = "sodefunct";
            __int16 v150 = 2082;
            *(void *)__int16 v151 = (char *)v8 + 604;
            long long v103 = (void *)_os_log_send_and_compose_impl();
            v165[0] = 16;
            v164[0] = 0;
            if (!__nwlog_fault()) {
              goto LABEL_277;
            }
            if (v165[0] == 17)
            {
              long long v104 = __nwlog_tcp_log();
              os_log_type_t v105 = v165[0];
              if (!os_log_type_enabled(v104, (os_log_type_t)v165[0])) {
                goto LABEL_277;
              }
              *(_DWORD *)long long buf = 136446466;
              __int16 v149 = "sodefunct";
              __int16 v150 = 2082;
              *(void *)__int16 v151 = (char *)v8 + 604;
              long long v106 = "%{public}s %{public}s improperly called sodefunct";
            }
            else if (v164[0])
            {
              os_log_t backtrace_string = (void *)__nw_create_backtrace_string();
              long long v104 = __nwlog_tcp_log();
              os_log_type_t v105 = v165[0];
              BOOL v121 = os_log_type_enabled(v104, (os_log_type_t)v165[0]);
              if (backtrace_string)
              {
                if (v121)
                {
                  *(_DWORD *)long long buf = 136446722;
                  __int16 v149 = "sodefunct";
                  __int16 v150 = 2082;
                  *(void *)__int16 v151 = (char *)v8 + 604;
                  *(_WORD *)&v151[8] = 2082;
                  *(void *)int v152 = backtrace_string;
                  _os_log_impl(&dword_214653000, v104, v105, "%{public}s %{public}s improperly called sodefunct, dumping backtrace:%{public}s", buf, 0x20u);
                }
                free(backtrace_string);
                goto LABEL_277;
              }
              if (!v121)
              {
LABEL_277:
                if (v103) {
                  free(v103);
                }
                goto LABEL_279;
              }
              *(_DWORD *)long long buf = 136446466;
              __int16 v149 = "sodefunct";
              __int16 v150 = 2082;
              *(void *)__int16 v151 = (char *)v8 + 604;
              long long v106 = "%{public}s %{public}s improperly called sodefunct, no backtrace";
            }
            else
            {
              long long v104 = __nwlog_tcp_log();
              os_log_type_t v105 = v165[0];
              if (!os_log_type_enabled(v104, (os_log_type_t)v165[0])) {
                goto LABEL_277;
              }
              *(_DWORD *)long long buf = 136446466;
              __int16 v149 = "sodefunct";
              __int16 v150 = 2082;
              *(void *)__int16 v151 = (char *)v8 + 604;
              long long v106 = "%{public}s %{public}s improperly called sodefunct, backtrace limit exceeded";
            }
            _os_log_impl(&dword_214653000, v104, v105, v106, buf, 0x16u);
            goto LABEL_277;
          }
LABEL_279:
          ((void (*)(void **, uint64_t, uint64_t))v8[1][3])(v8, 1, v4);
LABEL_280:
          nw_protocol_get_output_handler();
          if (!nw_protocol_updated_path_is_valid()) {
            return 1;
          }
          nw_protocol_get_output_handler();
          return nw_protocol_updated_path();
        }
        if ((__int16)v8[47] < 0) {
          goto LABEL_279;
        }
        uint64_t v107 = (uint64_t)*v8;
        if ((*((unsigned char *)v8 + 828) & 2) == 0)
        {
          long long v108 = __nwlog_tcp_log();
          if (os_log_type_enabled(v108, OS_LOG_TYPE_INFO))
          {
            int v109 = *(_DWORD *)v8[1][1];
            if (v109 == 2) {
              uint64_t v110 = (const void *)(v107 + 492);
            }
            else {
              uint64_t v110 = (const void *)(v107 + 480);
            }
            uint64_t v111 = inet_ntop(v109, v110, v165, 0x40u);
            unsigned int v112 = bswap32(*(unsigned __int16 *)(v107 + 2226)) >> 16;
            int v113 = *(_DWORD *)v8[1][1];
            if (v113 == 2) {
              int v114 = (const void *)(v107 + 476);
            }
            else {
              int v114 = (const void *)(v107 + 464);
            }
            __int16 v115 = inet_ntop(v113, v114, v164, 0x40u);
            unsigned int v116 = bswap32(*(unsigned __int16 *)(v107 + 2224)) >> 16;
            int v117 = *((_DWORD *)v8 + 134);
            int v118 = *((_DWORD *)v8 + 108);
            *(_DWORD *)long long buf = 136448259;
            __int16 v149 = "sodefunct";
            __int16 v150 = 2082;
            *(void *)__int16 v151 = (char *)v8 + 604;
            int v86 = v8 + 48;
            uint64_t v4 = v3;
            *(_WORD *)&v151[8] = 2082;
            *(void *)int v152 = "process_suspended";
            *(_WORD *)&v152[8] = 2081;
            __int16 v153 = v111;
            __int16 v154 = 1024;
            unsigned int v155 = v112;
            __int16 v156 = 2081;
            uint64_t v157 = v115;
            __int16 v158 = 1024;
            unsigned int v159 = v116;
            __int16 v160 = 1024;
            int v161 = v117;
            __int16 v162 = 1024;
            int v163 = v118;
            _os_log_impl(&dword_214653000, v108, OS_LOG_TYPE_INFO, "%{public}s %{public}s level %{public}s flow [TCP %{private}s:%d -> %{private}s:%d] is now defunct [rcv_fl 0x%x, snd_fl 0x%x]", buf, 0x4Cu);
          }
        }
        *((_DWORD *)v8 + 92) |= 8u;
        if ((_BYTE)v8[67])
        {
          sbunlock((uint64_t)v85);
          if (((_BYTE)v8[54] & 1) == 0)
          {
LABEL_232:
            __int16 v119 = *((_WORD *)v8 + 188);
            if ((v119 & 0x20) == 0) {
              goto LABEL_233;
            }
            goto LABEL_242;
          }
        }
        else if (((_BYTE)v8[54] & 1) == 0)
        {
          goto LABEL_232;
        }
        sbunlock((uint64_t)v86);
        __int16 v119 = *((_WORD *)v8 + 188);
        if ((v119 & 0x20) == 0)
        {
LABEL_233:
          sorflush((uint64_t)v8);
          __int16 v119 = *((_WORD *)v8 + 188);
          if ((v119 & 0x10) == 0)
          {
LABEL_243:
            *((_WORD *)v8 + 188) = v119 | 0x10;
            uint64_t v122 = v8[4];
            if (v122)
            {
              __int16 v123 = (void (*)(void **))v122[2];
              if (v123) {
                v123(v8);
              }
            }
            uint64_t v124 = *(void *)(v107 + 240);
            *((_WORD *)v8 + 189) = 53;
            user_north_signal_error((uint64_t)v8);
            tcp_close(v124);
            __int16 v119 = *((_WORD *)v8 + 188);
          }
LABEL_247:
          if ((v119 & 0xA) == 2) {
            (*(void (**)(void **))(v8[1][5] + 40))(v8);
          }
          if ((*((unsigned char *)v8 + 365) & 0x20) == 0)
          {
            *((_WORD *)v8 + 188) = (_WORD)v8[47] & 0xDFC1 | 0x2030;
            __int16 v125 = v8[4];
            if (v125)
            {
              int v126 = (void (*)(void **))v125[7];
              if (v126) {
                v126(v8);
              }
            }
          }
          if (!*((_WORD *)v8 + 189)) {
            *((_WORD *)v8 + 189) = 9;
          }
          if (*v85)
          {
            sbflush((uint64_t)v85);
            *((_DWORD *)v8 + 123) = 0;
            uint64_t v127 = v8[70][3];
            if (((_BYTE)v8[67] & 4) != 0)
            {
              if (v127)
              {
                uint64_t v129 = nw_protocol_tcp_get_all_stats();
                if (v129) {
                  *(_DWORD *)(v129 + 88) = *((_DWORD *)v8 + 123);
                }
              }
            }
            else if (v127)
            {
              uint64_t v128 = nw_protocol_tcp_get_all_stats();
              if (v128) {
                *(_DWORD *)(v128 + 100) = *((_DWORD *)v8 + 123);
              }
            }
          }
          if (*v86)
          {
            sbflush((uint64_t)v86);
            *((_DWORD *)v8 + 97) = 0;
            uint64_t v130 = v8[57][3];
            if (((_BYTE)v8[54] & 4) != 0)
            {
              if (v130)
              {
                uint64_t v132 = nw_protocol_tcp_get_all_stats();
                if (v132) {
                  *(_DWORD *)(v132 + 88) = *((_DWORD *)v8 + 97);
                }
              }
            }
            else if (v130)
            {
              uint64_t v131 = nw_protocol_tcp_get_all_stats();
              if (v131) {
                *(_DWORD *)(v131 + 100) = *((_DWORD *)v8 + 97);
              }
            }
          }
          *((_WORD *)v8 + 188) |= 0x8000u;
          goto LABEL_279;
        }
LABEL_242:
        if ((v119 & 0x10) == 0) {
          goto LABEL_243;
        }
        goto LABEL_247;
      }
      if ((v8[54] & v8[67] & 0x80) != 0 || (*((unsigned char *)v8 + 828) & 2) != 0) {
        goto LABEL_212;
      }
      __nwlog_tcp_log();
      *(_DWORD *)long long buf = 136446466;
      __int16 v149 = "sosetdefunct";
      __int16 v150 = 2082;
      *(void *)__int16 v151 = (char *)v8 + 604;
      long long v90 = (void *)_os_log_send_and_compose_impl();
      v165[0] = 16;
      v164[0] = 0;
      if (__nwlog_fault())
      {
        if (v165[0] == 17)
        {
          long long v91 = __nwlog_tcp_log();
          os_log_type_t v92 = v165[0];
          if (os_log_type_enabled(v91, (os_log_type_t)v165[0]))
          {
            *(_DWORD *)long long buf = 136446466;
            __int16 v149 = "sosetdefunct";
            __int16 v150 = 2082;
            *(void *)__int16 v151 = (char *)v8 + 604;
            long long v93 = "%{public}s %{public}s SB_DROP not set";
LABEL_207:
            long long v102 = v91;
LABEL_208:
            _os_log_impl(&dword_214653000, v102, v92, v93, buf, 0x16u);
          }
        }
        else if (v164[0])
        {
          long long v95 = (void *)__nw_create_backtrace_string();
          long long v96 = __nwlog_tcp_log();
          os_log_type_t v92 = v165[0];
          os_log_type_t log = v96;
          BOOL v97 = os_log_type_enabled(v96, (os_log_type_t)v165[0]);
          if (v95)
          {
            if (v97)
            {
              *(_DWORD *)long long buf = 136446722;
              __int16 v149 = "sosetdefunct";
              __int16 v150 = 2082;
              *(void *)__int16 v151 = (char *)v8 + 604;
              *(_WORD *)&v151[8] = 2082;
              *(void *)int v152 = v95;
              _os_log_impl(&dword_214653000, log, v92, "%{public}s %{public}s SB_DROP not set, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(v95);
            goto LABEL_209;
          }
          if (v97)
          {
            *(_DWORD *)long long buf = 136446466;
            __int16 v149 = "sosetdefunct";
            __int16 v150 = 2082;
            *(void *)__int16 v151 = (char *)v8 + 604;
            long long v93 = "%{public}s %{public}s SB_DROP not set, no backtrace";
            long long v102 = log;
            goto LABEL_208;
          }
        }
        else
        {
          long long v91 = __nwlog_tcp_log();
          os_log_type_t v92 = v165[0];
          if (os_log_type_enabled(v91, (os_log_type_t)v165[0]))
          {
            *(_DWORD *)long long buf = 136446466;
            __int16 v149 = "sosetdefunct";
            __int16 v150 = 2082;
            *(void *)__int16 v151 = (char *)v8 + 604;
            long long v93 = "%{public}s %{public}s SB_DROP not set, backtrace limit exceeded";
            goto LABEL_207;
          }
        }
      }
LABEL_209:
      if (v90) {
        free(v90);
      }
      char v85 = v8 + 61;
      goto LABEL_212;
    }
    int is_traffic_mgmt_background = nw_path_is_traffic_mgmt_background();
    if ((is_traffic_mgmt_background ^ ((*((unsigned char *)v8 + 5308) & 8) == 0)))
    {
LABEL_46:
      int effective_traffic_class = nw_path_get_effective_traffic_class();
      tcp_set_traffic_class((uint64_t)v8, effective_traffic_class);
      int should_probe_connectivity = nw_path_should_probe_connectivity();
      if ((should_probe_connectivity ^ ((*((unsigned char *)v8 + 5308) & 0x10) == 0)))
      {
        if (!v9)
        {
LABEL_78:
          int v18 = *((_DWORD *)v8 + 1306);
          goto LABEL_79;
        }
LABEL_75:
        if (*(unsigned __int8 *)(v9 + 1076) == 255 || *(_DWORD *)(v9 + 1024) == 255)
        {
          __int16 recommended_mss = nw_path_get_recommended_mss();
          *(_DWORD *)(v9 + 8) |= 0x8000u;
          *(_WORD *)(v9 + 72) = recommended_mss;
        }
        goto LABEL_78;
      }
      int v33 = should_probe_connectivity;
      if (tcp_perf_measurement)
      {
        if ((*((unsigned char *)v8 + 828) & 2) != 0) {
          goto LABEL_62;
        }
        if (!__nwlog_is_datapath_logging_enabled()) {
          goto LABEL_62;
        }
        int v34 = __nwlog_tcp_log();
        if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_62;
        }
        int v35 = "disabled";
        __int16 v149 = "nw_protocol_tcp_updated_path";
        *(_DWORD *)long long buf = 136446722;
        *(void *)__int16 v151 = (char *)v8 + 604;
        __int16 v150 = 2082;
        if (v33) {
          int v35 = "enabled";
        }
        *(_WORD *)&v151[8] = 2082;
        *(void *)int v152 = v35;
        unsigned int v36 = v34;
        os_log_type_t v37 = OS_LOG_TYPE_DEBUG;
      }
      else
      {
        if ((*((unsigned char *)v8 + 828) & 2) != 0) {
          goto LABEL_62;
        }
        int v38 = __nwlog_tcp_log();
        if (!os_log_type_enabled(v38, OS_LOG_TYPE_INFO)) {
          goto LABEL_62;
        }
        unsigned int v39 = "disabled";
        __int16 v149 = "nw_protocol_tcp_updated_path";
        *(_DWORD *)long long buf = 136446722;
        *(void *)__int16 v151 = (char *)v8 + 604;
        __int16 v150 = 2082;
        if (v33) {
          unsigned int v39 = "enabled";
        }
        *(_WORD *)&v151[8] = 2082;
        *(void *)int v152 = v39;
        unsigned int v36 = v38;
        os_log_type_t v37 = OS_LOG_TYPE_INFO;
      }
      _os_log_impl(&dword_214653000, v36, v37, "%{public}s %{public}s probe connectivity %{public}s", buf, 0x20u);
LABEL_62:
      if (v33) {
        int v40 = 16;
      }
      else {
        int v40 = 0;
      }
      *((_DWORD *)v8 + 1327) = *((_DWORD *)v8 + 1327) & 0xFFFFFFEF | v40;
      if (!v9) {
        goto LABEL_78;
      }
      if (v33) {
        int v41 = 8;
      }
      else {
        int v41 = 0;
      }
      *(_DWORD *)(v9 + 1052) = *(_DWORD *)(v9 + 1052) & 0xFFFFFFF7 | v41;
      uint64_t v42 = nw_tcp_access_globals((uint64_t)v8[132]);
      v43.n128_f64[0] = calculate_tcp_clock(v42);
      do
      {
        int v44 = *((_DWORD *)v8 + 322);
        if ((_WORD)v44 == 0xFFFF) {
          goto LABEL_75;
        }
        int v45 = *((_DWORD *)v8 + 322);
        atomic_compare_exchange_strong_explicit((atomic_uint *volatile)v8 + 322, (unsigned int *)&v45, v44 + 1, memory_order_relaxed, memory_order_relaxed);
      }
      while (v45 != v44);
      (*(void (**)(__n128))(v8[132][1] + 16))(v43);
      if (!v8[134] || in_pcb_checkstate((uint64_t)(v8 + 104), 2, 1) == 0xFFFF)
      {
LABEL_74:
        (*(void (**)(void))(v8[132][1] + 24))();
        goto LABEL_75;
      }
      unsigned int v57 = v8[134];
      if (!v33)
      {
        if (!*((unsigned char *)v57 + 265) && ((*((unsigned char *)v57 + 740) & 0x80) != 0 || *((unsigned char *)v57 + 311))) {
          tcp_keepalive_reset((uint64_t)v8[134]);
        }
        if (v8[132][3])
        {
          uint64_t v63 = nw_protocol_tcp_get_all_stats();
          if (v63) {
            *(unsigned char *)(v63 + 96) &= ~1u;
          }
        }
        if (v8[132][3])
        {
          uint64_t v64 = nw_protocol_tcp_get_all_stats();
          if (v64) {
            *(unsigned char *)(v64 + 96) &= ~2u;
          }
        }
        if (v8[132][3])
        {
          uint64_t v65 = nw_protocol_tcp_get_all_stats();
          if (v65) {
            *(unsigned char *)(v65 + 96) &= ~4u;
          }
        }
        if (v8[132][3])
        {
          uint64_t v66 = nw_protocol_tcp_get_all_stats();
          if (v66) {
            *(unsigned char *)(v66 + 96) &= ~8u;
          }
        }
        goto LABEL_74;
      }
      uint64_t v58 = nw_tcp_access_globals(*(void *)(v57[10] + 224));
      if (*((_DWORD *)v57 + 3) != 4
        || *((_DWORD *)v57 + 24) != *((_DWORD *)v57 + 23)
        || (uint64_t v59 = v57[10], *(void *)(v59 + 448) != v9)
        || (int v60 = *((_DWORD *)v57 + 185), (v60 & 0x80) != 0)
        || *((unsigned char *)v57 + 311))
      {
        char v61 = 0;
        goto LABEL_103;
      }
      uint64_t v141 = v58;
      *((_DWORD *)v57 + 185) = v60 | 0x80;
      *((unsigned char *)v57 + 311) = 0;
      *((_DWORD *)v57 + 10) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(v59 + 224)) + 316)
                            - *((_DWORD *)v57 + 16)
                            + 10;
      if (*((_WORD *)v57 + 36) == 8)
      {
        *((_WORD *)v57 + 36) = 6;
        unsigned int v142 = *(_DWORD *)(v141 + 316) + 10;
      }
      else
      {
        unsigned int v142 = *(_DWORD *)(v141 + 316) + 10;
        if ((int)(*((_DWORD *)v57 + 17) - v142) < 1)
        {
LABEL_319:
          char v61 = 1;
LABEL_103:
          if (v8[132][3])
          {
            uint64_t v62 = nw_protocol_tcp_get_all_stats();
            if (v62) {
              *(unsigned char *)(v62 + 96) |= 1u;
            }
          }
          (*(void (**)(void))(v8[132][1] + 24))();
          if (v61)
          {
            if (*(unsigned char *)(v42 + 310))
            {
              *(_DWORD *)(v42 + 296) |= 1u;
            }
            else if ((*(unsigned char *)(v42 + 310) & 2) == 0 || *(_DWORD *)(v42 + 272) - *(_DWORD *)(v42 + 316) - 10 >= 1)
            {
              *(_DWORD *)(v42 + 292) = 1;
              *(_DWORD *)(v42 + 304) = 0;
              tcp_sched_timerlist(v42, 0xAu);
            }
          }
          goto LABEL_75;
        }
        *((_WORD *)v57 + 36) = 6;
        if (v142 <= 1) {
          unsigned int v142 = 1;
        }
      }
      *((_DWORD *)v57 + 17) = v142;
      goto LABEL_319;
    }
    int v20 = is_traffic_mgmt_background;
    if (tcp_perf_measurement)
    {
      if ((*((unsigned char *)v8 + 828) & 2) != 0) {
        goto LABEL_36;
      }
      if (!__nwlog_is_datapath_logging_enabled()) {
        goto LABEL_36;
      }
      os_log_type_t v21 = __nwlog_tcp_log();
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_36;
      }
      int v22 = (*((_DWORD *)v8 + 1327) >> 3) & 1;
      *(_DWORD *)long long buf = 136446978;
      __int16 v149 = "nw_protocol_tcp_updated_path";
      __int16 v150 = 2082;
      *(void *)__int16 v151 = (char *)v8 + 604;
      *(_WORD *)&v151[8] = 1024;
      *(_DWORD *)int v152 = v22;
      *(_WORD *)&v152[4] = 1024;
      *(_DWORD *)&v152[6] = v20;
      __int16 v23 = v21;
      os_log_type_t v24 = OS_LOG_TYPE_DEBUG;
    }
    else
    {
      if ((*((unsigned char *)v8 + 828) & 2) != 0) {
        goto LABEL_36;
      }
      os_log_type_t v25 = __nwlog_tcp_log();
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_INFO)) {
        goto LABEL_36;
      }
      int v26 = (*((_DWORD *)v8 + 1327) >> 3) & 1;
      *(_DWORD *)long long buf = 136446978;
      __int16 v149 = "nw_protocol_tcp_updated_path";
      __int16 v150 = 2082;
      *(void *)__int16 v151 = (char *)v8 + 604;
      *(_WORD *)&v151[8] = 1024;
      *(_DWORD *)int v152 = v26;
      *(_WORD *)&v152[4] = 1024;
      *(_DWORD *)&v152[6] = v20;
      __int16 v23 = v25;
      os_log_type_t v24 = OS_LOG_TYPE_INFO;
    }
    _os_log_impl(&dword_214653000, v23, v24, "%{public}s %{public}s traffic_mgmt_background current %d new %d", buf, 0x22u);
LABEL_36:
    if (v20) {
      int v27 = 8;
    }
    else {
      int v27 = 0;
    }
    *((_DWORD *)v8 + 1327) = *((_DWORD *)v8 + 1327) & 0xFFFFFFF7 | v27;
    int v28 = *((_DWORD *)v8 + 92);
    if (v20)
    {
      *((_DWORD *)v8 + 92) = v28 | 0x2000;
      uint64_t v29 = nw_protocol_tcp_get_all_stats();
      if (v29)
      {
        unsigned int v30 = *(_DWORD *)(v29 + 128) | 1;
LABEL_44:
        *(_DWORD *)(v29 + 128) = v30;
      }
    }
    else
    {
      *((_DWORD *)v8 + 92) = v28 & 0xFFFFDFFF;
      uint64_t v29 = nw_protocol_tcp_get_all_stats();
      if (v29)
      {
        unsigned int v30 = *(_DWORD *)(v29 + 128) & 0xFFFFFFFE;
        goto LABEL_44;
      }
    }
    set_tcp_stream_priority((uint64_t)v8);
    goto LABEL_46;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  __int16 v149 = "nw_protocol_tcp_updated_path";
  int v134 = (void *)_os_log_send_and_compose_impl();
  v165[0] = 16;
  v164[0] = 0;
  if (__nwlog_fault())
  {
    if (v165[0] == 17)
    {
      __int16 v135 = __nwlog_obj();
      os_log_type_t v136 = v165[0];
      if (os_log_type_enabled(v135, (os_log_type_t)v165[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v149 = "nw_protocol_tcp_updated_path";
        __int16 v137 = "%{public}s called with null parameters";
        goto LABEL_334;
      }
    }
    else if (v164[0])
    {
      __int16 v139 = (void *)__nw_create_backtrace_string();
      __int16 v135 = __nwlog_obj();
      os_log_type_t v136 = v165[0];
      BOOL v140 = os_log_type_enabled(v135, (os_log_type_t)v165[0]);
      if (v139)
      {
        if (v140)
        {
          *(_DWORD *)long long buf = 136446466;
          __int16 v149 = "nw_protocol_tcp_updated_path";
          __int16 v150 = 2082;
          *(void *)__int16 v151 = v139;
          _os_log_impl(&dword_214653000, v135, v136, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v139);
        goto LABEL_335;
      }
      if (v140)
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v149 = "nw_protocol_tcp_updated_path";
        __int16 v137 = "%{public}s called with null parameters, no backtrace";
        goto LABEL_334;
      }
    }
    else
    {
      __int16 v135 = __nwlog_obj();
      os_log_type_t v136 = v165[0];
      if (os_log_type_enabled(v135, (os_log_type_t)v165[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v149 = "nw_protocol_tcp_updated_path";
        __int16 v137 = "%{public}s called with null parameters, backtrace limit exceeded";
        goto LABEL_334;
      }
    }
  }
LABEL_335:
  if (v134) {
    free(v134);
  }
  return 0;
}

uint64_t tcp_is_ack_ratelimited(uint64_t a1)
{
  int v2 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 316);
  int v3 = *(_DWORD *)(a1 + 1044);
  if (!v3 || v2 - v3 >= 1000)
  {
    *(_DWORD *)(a1 + 1044) = v2;
    int v5 = 1;
    goto LABEL_6;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 1048);
  if (v4 < *(_DWORD *)(sysctls + 248))
  {
    int v5 = v4 + 1;
LABEL_6:
    uint64_t result = 0;
    *(_DWORD *)(a1 + 1048) = v5;
    return result;
  }
  return 1;
}

void tcp_cubic_after_timeout(uint64_t a1)
{
  if (!*(void *)(a1 + 840))
  {
    int v2 = __nwlog_obj();
    os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
    int v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }
    free(v3);
  }
  if (*(int *)(a1 + 12) > 3 || *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92) >= 2)
  {
    if ((*(unsigned char *)(a1 + 90) & 0x20) == 0)
    {
      **(_DWORD **)(a1 + 840) = 0;
      *(_DWORD *)(*(void *)(a1 + 840) + 4) = 0;
      *(_DWORD *)(*(void *)(a1 + 840) + 8) = 0;
      *(_DWORD *)(*(void *)(a1 + 840) + 12) = 0;
      *(_DWORD *)(*(void *)(a1 + 840) + 16) = 0;
      *(_DWORD *)(*(void *)(a1 + 840) + 28) = 0;
      tcp_cubic_pre_fr(a1);
    }
    *(_DWORD *)(a1 + 144) = *(_DWORD *)(a1 + 196);
  }
}

void add_to_time_wait(uint64_t a1, int a2)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 72);
  int v5 = *(uint64_t **)(a1 + 80);
  uint64_t v6 = v5[28];
  if (*(unsigned char *)(v6 + 374))
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v29 = "socket_post_kev_msg_closed";
    uint64_t v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v29 = "socket_post_kev_msg_closed";
        _os_log_impl(&dword_214653000, v8, OS_LOG_TYPE_ERROR, "%{public}s currently not supported, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v7) {
      free(v7);
    }
    int v5 = *(uint64_t **)(a1 + 80);
    uint64_t v6 = v5[28];
  }
  uint64_t v9 = nw_tcp_access_globals(v6);
  uint64_t v10 = v9;
  int v11 = *((_DWORD *)v5 + 558);
  if (v11)
  {
    uint64_t v13 = *(void *)(a1 + 824);
    uint64_t v14 = *(void **)(a1 + 832);
    if (v13)
    {
      *(void *)(v13 + 832) = v14;
      uint64_t v14 = *(void **)(a1 + 832);
    }
    else
    {
      *(void *)(v9 + 136) = v14;
    }
  }
  else
  {
    ++*(_DWORD *)(*(void *)(v9 + 72) + 64);
    uint64_t v12 = *(void *)(a1 + 1056);
    if (v12) {
      ++*(void *)(v12 + 1696);
    }
    *((_DWORD *)v5 + 558) = v11 | 1;
    uint64_t v13 = *v5;
    if (*v5) {
      *(void *)(v13 + 8) = v5[1];
    }
    uint64_t v14 = (void *)v5[1];
  }
  *uint64_t v14 = v13;
  int v15 = *(_DWORD *)(v9 + 316) + a2;
  if ((*(unsigned char *)(a1 + 91) & 0x40) != 0)
  {
    uint64_t v16 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
    (*(void (**)(void, void))(*(void *)(*(void *)(*(void *)(a1 + 80) + 224) + 8) + 32))(*(void *)(*(void *)(a1 + 80) + 224), 0);
    int v17 = *(_DWORD *)(a1 + 88);
    if ((v17 & 0x40000000) != 0)
    {
      int v18 = *(uint64_t **)(v16 + 264);
      uint64_t v19 = (uint64_t *)(a1 + 48);
      if (v18) {
        BOOL v20 = v18 == v19;
      }
      else {
        BOOL v20 = 0;
      }
      if (v20) {
        *(void *)(v16 + 264) = *v18;
      }
      uint64_t v21 = *v19;
      if (*v19) {
        *(void *)(v21 + 8) = *(void *)(a1 + 56);
      }
      **(void **)(a1 + 56) = v21;
      *(_DWORD *)(a1 + 88) = v17 & 0xBFFFFFFF;
      --*(_DWORD *)(v16 + 280);
      *uint64_t v19 = 0;
      *(void *)(a1 + 56) = 0;
    }
  }
  *(_DWORD *)(a1 + 44) = v15;
  uint64_t v22 = v5[28];
  if (!v22 || (*(unsigned char *)(v22 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      os_log_type_t v25 = __nwlog_tcp_log();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        int v26 = (const char *)(v22 + 604);
        int v27 = *(_DWORD *)(v5[28] + 360);
        if (!v22) {
          int v26 = "";
        }
        *(_DWORD *)long long buf = 136446978;
        uint64_t v29 = "add_to_time_wait_locked";
        __int16 v30 = 2082;
        int v31 = v26;
        __int16 v32 = 1024;
        int v33 = v27;
        __int16 v34 = 1024;
        int v35 = a2;
        _os_log_impl(&dword_214653000, v25, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s so_usecount %u added to TIME_WAIT delay %u", buf, 0x22u);
      }
    }
  }
  *(void *)(a1 + 824) = 0;
  __int16 v23 = *(void **)(v10 + 136);
  *(void *)(a1 + 832) = v23;
  *__int16 v23 = a1;
  *(void *)(v10 + 136) = a1 + 824;
  uint64_t v24 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
  *(unsigned char *)(v24 + 328) |= 2u;
  atomic_fetch_add((atomic_uint *volatile)(v4 + 40), 1u);
  if ((*(unsigned char *)(v24 + 328) & 1) == 0 && (*(unsigned char *)(v24 + 328) & 6) != 0)
  {
    *(unsigned char *)(v24 + 328) = *(unsigned char *)(v24 + 328) & 0xF6 | 1;
    nw_protocol_timer_run_inner(v24, 1000000000, 0);
  }
}

uint64_t tcp_ledbat_switch_cc(uint64_t result)
{
  **(_DWORD **)(result + 840) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 4) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 8) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 12) = 0;
  unsigned int v1 = *(_DWORD *)(result + 736);
  unsigned int v2 = *(_DWORD *)(result + 148);
  if (v1 - 1 >= v2)
  {
    *(_DWORD *)(result + 736) = v2;
    unsigned int v1 = v2;
  }
  unsigned int v3 = *(_DWORD *)(result + 140);
  unsigned int v4 = *(_DWORD *)(result + 144);
  if (v3 >= v4) {
    unsigned int v3 = *(_DWORD *)(result + 144);
  }
  if (v4 <= v1) {
    v3 >>= 1;
  }
  unsigned int v5 = *(_DWORD *)(result + 196);
  unsigned int v6 = v3 / v5;
  if (v6 <= *(_DWORD *)(sysctls + 16)) {
    unsigned int v6 = *(_DWORD *)(sysctls + 16);
  }
  *(_DWORD *)(result + 144) = v6 * v5;
  *(_DWORD *)(result + 288) = 0;
  atomic_fetch_add(dword_26AA46390, 1u);
  return result;
}

uint64_t tcp_ledbat_delay_ack(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(sysctls + 288) == 1) {
    return tcp_cc_delay_ack(a1, a2);
  }
  return (*(unsigned char *)(a1 + 90) & 4) == 0 && (*(unsigned char *)(a2 + 13) & 8) == 0 && *(_WORD *)(a1 + 304) == 1;
}

uint64_t tcp_ledbat_after_timeout(uint64_t result)
{
  if (*(int *)(result + 12) >= 4)
  {
    **(_DWORD **)(result + 840) = 0;
    *(_DWORD *)(*(void *)(result + 840) + 4) = 0;
    *(_DWORD *)(*(void *)(result + 840) + 8) = 0;
    *(_DWORD *)(*(void *)(result + 840) + 12) = 0;
    if ((*(unsigned char *)(result + 742) & 0x10) != 0)
    {
      unsigned int v1 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
      unsigned int v2 = *(_DWORD *)(result + 980);
      if (v2 <= v1) {
        unsigned int v2 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
      }
    }
    else
    {
      unsigned int v1 = 0;
      unsigned int v2 = *(_DWORD *)(result + 140);
      if (v2 >= *(_DWORD *)(result + 144)) {
        unsigned int v2 = *(_DWORD *)(result + 144);
      }
    }
    *(_DWORD *)(result + 984) = v1;
    unsigned int v3 = *(_DWORD *)(result + 196);
    unsigned int v4 = ((v3 >> 1) + (v2 >> 1)) / v3 * v3;
    if (v4 <= 2 * v3) {
      unsigned int v4 = 2 * v3;
    }
    *(_DWORD *)(result + 148) = v4;
    if (*(_DWORD *)(result + 736) > v4) {
      *(_DWORD *)(result + 736) = v4;
    }
    unsigned int v5 = *(_DWORD **)(*(void *)(result + 80) + 224);
    if (v5[97] > v4)
    {
      int v6 = v5[108];
      if ((v6 & 0x400) != 0)
      {
        if (v5[109] > v4)
        {
          if (*(int *)(sysctls + 232) > (uint64_t)v4) {
            unsigned int v4 = *(_DWORD *)(sysctls + 232);
          }
          if (v4 >= *(_DWORD *)(sysctls + 120)) {
            unsigned int v4 = *(_DWORD *)(sysctls + 120);
          }
          v5[109] = v4;
        }
        v5[108] = v6 | 0x800;
      }
    }
    *(_DWORD *)(result + 144) = v3;
  }
  return result;
}

uint64_t tcp_ledbat_after_idle(uint64_t result)
{
  **(_DWORD **)(result + 840) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 4) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 8) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 12) = 0;
  *(_DWORD *)(result + 144) = *(_DWORD *)(sysctls + 16) * *(_DWORD *)(result + 196);
  *(_DWORD *)(result + 288) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 12) = 0;
  return result;
}

uint64_t tcp_ledbat_post_fr(uint64_t result, uint64_t a2)
{
  unsigned int v2 = (_DWORD *)(result + 92);
  if (a2) {
    unsigned int v2 = (_DWORD *)(a2 + 8);
  }
  int v3 = *(_DWORD *)(result + 96) - *v2;
  int v4 = *(_DWORD *)(result + 148);
  if (v3 < v4)
  {
    uint64_t v5 = *(unsigned int *)(result + 196);
    if (v3 <= v5) {
      int v3 = *(_DWORD *)(result + 196);
    }
    int v4 = v3 + v5;
  }
  *(_DWORD *)(result + 144) = v4;
  *(_DWORD *)(result + 288) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 12) = 0;
  return result;
}

uint64_t tcp_ledbat_pre_fr(uint64_t result)
{
  if ((*(unsigned char *)(result + 742) & 0x10) != 0)
  {
    unsigned int v1 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
    unsigned int v2 = *(_DWORD *)(result + 980);
    if (v2 <= v1) {
      unsigned int v2 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
    }
  }
  else
  {
    unsigned int v1 = 0;
    unsigned int v2 = *(_DWORD *)(result + 140);
    if (v2 >= *(_DWORD *)(result + 144)) {
      unsigned int v2 = *(_DWORD *)(result + 144);
    }
  }
  *(_DWORD *)(result + 984) = v1;
  unsigned int v3 = *(_DWORD *)(result + 196);
  unsigned int v4 = ((v3 >> 1) + (v2 >> 1)) / v3 * v3;
  unsigned int v5 = 2 * v3;
  if (v4 > v5) {
    unsigned int v5 = v4;
  }
  *(_DWORD *)(result + 148) = v5;
  if (*(_DWORD *)(result + 736) > v5) {
    *(_DWORD *)(result + 736) = v5;
  }
  int v6 = *(_DWORD **)(*(void *)(result + 80) + 224);
  if (v6[97] > v5)
  {
    int v7 = v6[108];
    if ((v7 & 0x400) != 0)
    {
      if (v6[109] > v5)
      {
        if (*(int *)(sysctls + 232) > (uint64_t)v5) {
          unsigned int v5 = *(_DWORD *)(sysctls + 232);
        }
        if (v5 >= *(_DWORD *)(sysctls + 120)) {
          unsigned int v5 = *(_DWORD *)(sysctls + 120);
        }
        v6[109] = v5;
      }
      v6[108] = v7 | 0x800;
    }
  }
  return result;
}

_DWORD *tcp_ledbat_ack_rcvd(_DWORD *result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 8) - result[23];
  if (*(_DWORD *)(sysctls + 300)) {
    return (_DWORD *)ledbat_pp_ack_rcvd((uint64_t)result, v2);
  }
  unsigned int v3 = result[36];
  unsigned int v4 = result[49];
  unsigned int v5 = result[72] + v2;
  result[72] = v5;
  if (v3 >= result[184])
  {
    if (v5 >= v3) {
      unsigned int v2 = v4;
    }
    else {
      unsigned int v2 = 0;
    }
    BOOL v7 = v5 >= v3;
    unsigned int v8 = v5 - v3;
    if (!v7) {
      goto LABEL_14;
    }
  }
  else
  {
    unsigned int v6 = v4 << (result[25] == result[24]);
    if (v2 >= v6) {
      unsigned int v2 = v6;
    }
    BOOL v7 = v5 >= v3;
    unsigned int v8 = v5 - v3;
    if (!v7) {
      goto LABEL_14;
    }
  }
  result[72] = v8;
LABEL_14:
  if (v2) {
    return (_DWORD *)update_cwnd((uint64_t)result, v2, 1);
  }
  return result;
}

uint64_t ledbat_pp_ack_rcvd(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)(a1 + 80);
  uint64_t v5 = *(void *)(v4 + 496);
  if (v5 && (uint64_t v6 = *(void *)(v5 + 1488)) != 0) {
    unsigned int v7 = *(_DWORD *)(v6 + 40);
  }
  else {
    unsigned int v7 = 0;
  }
  uint64_t v8 = 1908;
  if (!*(_DWORD *)(sysctls + 312)) {
    uint64_t v8 = 236;
  }
  unsigned int v9 = *(_DWORD *)(a1 + v8);
  int v10 = 3 * *(_DWORD *)(sysctls + 4);
  if (v10 >= 0) {
    int v11 = 3 * *(_DWORD *)(sysctls + 4);
  }
  else {
    int v11 = v10 + 3;
  }
  uint64_t result = nw_tcp_access_globals(*(void *)(v4 + 224));
  uint64_t v13 = *(_DWORD **)(a1 + 840);
  unsigned int v14 = v13[1];
  if (!v14) {
    goto LABEL_20;
  }
  unsigned int v15 = *(_DWORD *)(result + 316);
  if (v15 < v14)
  {
    unsigned int v14 = 1;
    goto LABEL_20;
  }
  if (!v13[2])
  {
    v13[2] = v15;
    ++**(_DWORD **)(a1 + 840);
    unsigned int v15 = *(_DWORD *)(result + 316);
    uint64_t v13 = *(_DWORD **)(a1 + 840);
    unsigned int v14 = v13[1];
  }
  if (v15 >= v14 + 2 * (*(int *)(a1 + 200) >> 5))
  {
LABEL_20:
    if (v9) {
      BOOL v18 = v7 == 0;
    }
    else {
      BOOL v18 = 1;
    }
    if (v18)
    {
      if (10 * *(_DWORD *)(a1 + 196) >= a2) {
        int v19 = a2;
      }
      else {
        int v19 = 10 * *(_DWORD *)(a1 + 196);
      }
LABEL_28:
      return update_cwnd(a1, v19, 1);
    }
    unsigned int v20 = *(_DWORD *)(a1 + 144);
    unsigned int v21 = *(_DWORD *)(a1 + 736);
    if (v20 < v21)
    {
      int v22 = v11 >> 2;
      if (*v13)
      {
        int v23 = *(_DWORD *)(sysctls + 4);
        unsigned int v24 = v22 + v7;
        BOOL v25 = v9 > v23 + v7 && v9 > v24;
        if (!v25) {
          goto LABEL_58;
        }
      }
      else if (v9 <= v22 + v7)
      {
        int v23 = *(_DWORD *)(sysctls + 4);
LABEL_58:
        unsigned int v39 = *(_DWORD *)(a1 + 288) + a2;
        *(_DWORD *)(a1 + 288) = v39;
        double v40 = (double)(2 * v23) / (double)v7;
        double v41 = trunc(v40);
        BOOL v25 = v40 <= v41;
        double v42 = 0.0;
        if (!v25) {
          double v42 = 1.0;
        }
        unsigned int v43 = (v42 + v41);
        if (v43 >= 0x10) {
          unsigned int v43 = 16;
        }
        int v44 = *(_DWORD *)(a1 + 196);
        if (v39 >= v44 * v43)
        {
          if (v39 / v43 >= 10 * v44) {
            int v45 = 10 * v44;
          }
          else {
            int v45 = v39 / v43;
          }
          *(_DWORD *)(a1 + 288) = 0;
          uint64_t result = update_cwnd(a1, v45, 1);
          uint64_t v13 = *(_DWORD **)(a1 + 840);
        }
        if (v13[1]) {
          v13[1] = 0;
        }
        return result;
      }
    }
    int v26 = *(_DWORD *)(result + 316);
    if (v14)
    {
LABEL_47:
      uint64_t v28 = sysctls;
      if (*(_DWORD *)(sysctls + 4) + v7 < v9)
      {
        *(_DWORD *)(*(void *)(a1 + 840) + 12) += a2;
        uint64_t v29 = *(void *)(a1 + 840);
        unsigned int v30 = *(_DWORD *)(v29 + 12);
        unsigned int v31 = *(_DWORD *)(a1 + 144);
        BOOL v32 = v30 >= v31;
        unsigned int v33 = v30 - v31;
        if (v32)
        {
          unsigned int v34 = v9 - v7;
          if (v9 < v7) {
            unsigned int v34 = 0;
          }
          int v35 = (fmin((double)v34 / (double)*(int *)(v28 + 4) + -1.0, 0.5) * (double)v31);
          *(_DWORD *)(v29 + 12) = v33;
          uint64_t result = update_cwnd(a1, v35, 0);
          uint64_t v36 = *(void *)(a1 + 840);
          if (*(_DWORD *)(v36 + 4)) {
            *(_DWORD *)(v36 + 4) = v26 + 30000;
          }
        }
        return result;
      }
      unsigned int v37 = *(_DWORD *)(a1 + 288) + a2;
      *(_DWORD *)(a1 + 288) = v37;
      BOOL v32 = v37 >= v20;
      unsigned int v38 = v37 - v20;
      if (!v32) {
        return result;
      }
      int v19 = *(_DWORD *)(a1 + 196);
      *(_DWORD *)(a1 + 288) = v38;
      goto LABEL_28;
    }
    if (*v13)
    {
      int v27 = (v26 - v13[2]) << (v20 < v21);
      v13[1] = 9 * v27 + v26;
      if (v27) {
        goto LABEL_45;
      }
    }
    else
    {
      v13[1] = v26;
    }
    *(_DWORD *)(*(void *)(a1 + 840) + 4) += 2 * (*(int *)(a1 + 200) >> 5);
LABEL_45:
    *(_DWORD *)(*(void *)(a1 + 840) + 8) = 0;
    unsigned int v20 = *(_DWORD *)(a1 + 144);
    if (*(_DWORD *)(a1 + 736) > v20) {
      *(_DWORD *)(a1 + 736) = v20;
    }
    goto LABEL_47;
  }
  unsigned int v16 = *(_DWORD *)(a1 + 144);
  unsigned int v17 = *(_DWORD *)(a1 + 196) * *(_DWORD *)(sysctls + 16);
  if (v16 > v17)
  {
    if (*(_DWORD *)(a1 + 736) < v16) {
      *(_DWORD *)(a1 + 736) = v16;
    }
    *(_DWORD *)(a1 + 144) = v17;
    *(_DWORD *)(a1 + 288) = 0;
  }
  return result;
}

uint64_t update_cwnd(uint64_t result, int a2, int a3)
{
  uint64_t v3 = *(void *)(*(void *)(result + 80) + 496);
  if (v3 && (uint64_t v4 = *(void *)(v3 + 1488)) != 0) {
    int v5 = *(_DWORD *)(v4 + 40);
  }
  else {
    int v5 = 0;
  }
  uint64_t v6 = (_DWORD *)sysctls;
  uint64_t v7 = 1908;
  if (!*(_DWORD *)(sysctls + 312)) {
    uint64_t v7 = 236;
  }
  if (v5 && (unsigned int v8 = *(_DWORD *)(result + v7)) != 0)
  {
    if (v8 <= *(_DWORD *)(sysctls + 4) + v5)
    {
      unsigned int v11 = *(_DWORD *)(result + 144);
      if (*(_DWORD *)(result + 736) < v11) {
        *(_DWORD *)(result + 736) = v11;
      }
      unsigned int v10 = (v11 + a2 + (*(_DWORD *)(result + 196) >> 1)) / *(_DWORD *)(result + 196) * *(_DWORD *)(result + 196);
    }
    else
    {
      if (*(_DWORD *)(sysctls + 300))
      {
        if (a3)
        {
          int v19 = a2;
          uint64_t v18 = result;
          unsigned int v16 = __nwlog_obj();
          os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
          unsigned int v17 = (void *)_os_log_send_and_compose_impl();
          uint64_t result = __nwlog_abort();
          if (result)
          {
            __break(1u);
            return result;
          }
          free(v17);
          uint64_t v6 = (_DWORD *)sysctls;
          uint64_t result = v18;
          a2 = v19;
        }
        unsigned int v9 = *(_DWORD *)(result + 144) - a2;
      }
      else
      {
        unsigned int v9 = *(_DWORD *)(result + 144) - (*(_DWORD *)(result + 144) >> 3);
      }
      unsigned int v12 = *(_DWORD *)(result + 196);
      if (v9 <= v12 * v6[4]) {
        unsigned int v9 = v12 * v6[4];
      }
      unsigned int v10 = (v9 + (v12 >> 1)) / v12 * v12;
      if (*(_DWORD *)(result + 736) > v10) {
        *(_DWORD *)(result + 736) = v10;
      }
    }
  }
  else
  {
    unsigned int v10 = *(_DWORD *)(result + 144) + a2;
  }
  if (v6[75])
  {
    char v13 = *(unsigned char *)(result + 260);
    uint64_t v14 = 0xFFFFLL << v13;
    unsigned int v15 = 0xFFFF << v13;
    if (v14 > v10) {
      unsigned int v15 = v10;
    }
  }
  else
  {
    unsigned int v15 = ((*(_DWORD *)(result + 96) - *(_DWORD *)(result + 92)) << v6[3]) + *(_DWORD *)(result + 196) * v6[2];
    if (v10 < v15) {
      unsigned int v15 = v10;
    }
  }
  *(_DWORD *)(result + 144) = v15;
  return result;
}

_DWORD *tcp_ledbat_congestion_avd(_DWORD *result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 8) - result[23];
  if (*(_DWORD *)(sysctls + 300)) {
    return (_DWORD *)ledbat_pp_ack_rcvd((uint64_t)result, v2);
  }
  unsigned int v3 = result[72] + v2;
  result[72] = v3;
  unsigned int v4 = result[36];
  BOOL v5 = v3 >= v4;
  unsigned int v6 = v3 - v4;
  if (v6 != 0 && v5)
  {
    result[72] = v6;
    int v7 = result[49];
    if (v4 < result[35] && v7 != 0) {
      return (_DWORD *)update_cwnd((uint64_t)result, v7, 1);
    }
  }
  return result;
}

_DWORD *tcp_ledbat_cwnd_init(_DWORD *result)
{
  result[36] = *(_DWORD *)(sysctls + 16) * result[49];
  result[184] = result[37];
  return result;
}

uint64_t tcp_ledbat_cleanup()
{
  return 0;
}

uint64_t tcp_ledbat_init(uint64_t a1)
{
  **(_DWORD **)(a1 + 840) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 4) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 8) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 12) = 0;
  return 0;
}

uint64_t in_pcbbind(uint64_t a1, unsigned char *a2)
{
  if (*(_WORD *)(a1 + 2226) || *(_DWORD *)(a1 + 492) || a2 && *a2 != 16) {
    return 22;
  }
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 2136) + 8))(*(void *)(a1 + 224));
  if (!result)
  {
    uint64_t result = 0;
    *(_WORD *)(a1 + 2226) = 0;
  }
  return result;
}

uint64_t inp_reset_fc_state(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 224);
  int v3 = *(_DWORD *)(a1 + 2228);
  if ((v3 & 0x10000000) != 0)
  {
    *(_DWORD *)(a1 + 2228) = v3 & 0xAFFFFFFF;
    *(_DWORD *)(result + 364) &= ~0x20000u;
    if ((v3 & 0x50000000) == 0) {
      return result;
    }
    goto LABEL_7;
  }
  int v4 = *(_DWORD *)(result + 364);
  *(_DWORD *)(a1 + 2228) = v3 & 0xAFFFFFFF;
  if ((v4 & 0x20000) != 0) {
    *(_DWORD *)(result + 364) = v4 & 0xFFFDFFFF;
  }
  if ((v3 & 0x50000000) != 0)
  {
LABEL_7:
    BOOL v5 = *(uint64_t (***)(void))(result + 32);
    if (v5)
    {
      if (*v5) {
        return (*v5)();
      }
    }
  }
  return result;
}

uint64_t nw_protocol_tcp_get_malloc_frame(uint64_t a1, unsigned int a2, uint64_t a3, int a4, _DWORD *a5)
{
  uint64_t v82 = *MEMORY[0x263EF8340];
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v76 = "nw_protocol_tcp_get_malloc_frame";
    uint64_t v60 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_103;
    }
    int v73 = __nwlog_obj();
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
      goto LABEL_103;
    }
    *(_DWORD *)long long buf = 136446210;
    int v76 = "nw_protocol_tcp_get_malloc_frame";
    int v74 = "%{public}s called with null ret_frame_array, backtrace limit exceeded";
    goto LABEL_102;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v76 = "nw_protocol_tcp_get_malloc_frame";
    uint64_t v60 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_103;
    }
    int v73 = __nwlog_obj();
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
      goto LABEL_103;
    }
    *(_DWORD *)long long buf = 136446210;
    int v76 = "nw_protocol_tcp_get_malloc_frame";
    int v74 = "%{public}s called with null (max_frame_count > 0), backtrace limit exceeded";
LABEL_102:
    _os_log_impl(&dword_214653000, v73, OS_LOG_TYPE_ERROR, v74, buf, 0xCu);
LABEL_103:
    if (!v60) {
      return 0;
    }
    unsigned int v72 = (void *)v60;
    goto LABEL_96;
  }
  unsigned int v8 = (void *)nw_tcp_access_globals(a1);
  unsigned int v9 = v8;
  if (a5) {
    *a5 = 0;
  }
  uint64_t v10 = v8[18];
  if (!v10) {
    goto LABEL_16;
  }
  uint64_t v12 = *(void *)(v10 + 16);
  char v13 = *(void **)(v10 + 24);
  unsigned int v11 = (void *)(v10 + 16);
  if (v12)
  {
    *(void *)(v12 + 24) = v13;
    char v13 = *(void **)(v10 + 24);
  }
  else
  {
    v8[19] = v13;
  }
  *char v13 = v12;
  *unsigned int v11 = 0;
  *(void *)(v10 + 24) = 0;
  uint64_t v14 = (uint64_t *)v8[21];
  *(void *)(v10 + 24) = v14;
  *uint64_t v14 = v10;
  v8[21] = v11;
  uint64_t v15 = v8[1];
  if (v15 <= 0)
  {
    char v61 = __nwlog_obj();
    os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long buf = 136446210;
    int v76 = "nw_protocol_tcp_get_malloc_frame";
    uint64_t v62 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if (result) {
      goto LABEL_105;
    }
    free(v62);
    uint64_t v15 = v9[1];
  }
  if ((v9[1] = v15 - 1, (*(_WORD *)(v10 + 204) & 0x100) != 0)
    && *MEMORY[0x263F144B8]
    && !((unsigned int (*)(uint64_t, void))*MEMORY[0x263F144B8])(v10, *(void *)(v10 + 88))
    || (unsigned int v16 = *(void **)(v10 + 112)) == 0)
  {
LABEL_16:
    if ((int)a2 < 1) {
      goto LABEL_80;
    }
    uint64_t v18 = malloc_type_malloc(a2, 0xF2B69DE5uLL);
    if (v18)
    {
      if (v10)
      {
LABEL_19:
        int v19 = *(unsigned __int16 *)(v10 + 204);
        *(void *)(v10 + 80) = nw_frame_tcp_finalize;
        *(void *)(v10 + 88) = v9;
        *(void *)(v10 + 112) = v18;
        *(void *)(v10 + 104) = 0;
        *(_WORD *)(v10 + 196) = 0;
        *(_DWORD *)(v10 + 48) = a2;
        *(_DWORD *)(v10 + 52) = a2;
        *(void *)(v10 + 56) = 0;
        *(_DWORD *)(v10 + 192) = 0;
        *(unsigned char *)(v10 + 200) = 0;
        unsigned int v20 = v19 & 0xFFFFFFC7 | (*(unsigned __int8 *)(v10 + 206) << 16);
        *(_WORD *)(v10 + 204) = v20;
        *(unsigned char *)(v10 + 206) = BYTE2(v20);
        unsigned int v21 = *(void **)(v10 + 64);
        if (v21)
        {
          do
          {
            int v22 = (void *)*v21;
            int v23 = (void *)v21[6];
            unsigned int v24 = (void *)*v21;
            if (v23)
            {
              nw_release(v23);
              v21[6] = 0;
              unsigned int v24 = (void *)*v21;
            }
            BOOL v25 = (void *)v21[1];
            if (v24)
            {
              v24[1] = v25;
              BOOL v25 = (void *)v21[1];
            }
            else
            {
              *(void *)(v10 + 72) = v25;
            }
            *BOOL v25 = v24;
            if (v21 != (void *)(v10 + 120)) {
              free(v21);
            }
            unsigned int v21 = v22;
          }
          while (v22);
        }
        *(void *)(v10 + 64) = 0;
        *(void *)(v10 + 72) = v10 + 64;
        int v26 = *(void **)(v10 + 168);
        if (v26) {
          nw_release(v26);
        }
        __int16 v27 = *(_WORD *)(v10 + 204);
        *(void *)(v10 + 184) = 0;
        *(_OWORD *)(v10 + 168) = 0u;
        *(_OWORD *)(v10 + 152) = 0u;
        *(_OWORD *)(v10 + 136) = 0u;
        *(_OWORD *)(v10 + 120) = 0u;
        *(unsigned char *)(v10 + 203) = 0;
        *(_WORD *)(v10 + 198) = 0;
        *(_WORD *)(v10 + 204) = v27 & 0x213E | 1;
LABEL_86:
        *(void *)(v10 + 32) = 0;
        int v69 = *(uint64_t **)(a3 + 8);
        *(void *)(v10 + 40) = v69;
        *int v69 = v10;
        *(void *)(a3 + 8) = v10 + 32;
        uint64_t result = 1;
        if (!a5) {
          return result;
        }
        goto LABEL_87;
      }
      goto LABEL_81;
    }
    uint64_t v63 = __nwlog_obj();
    os_log_type_enabled(v63, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long buf = 136446466;
    int v76 = "strict_malloc";
    __int16 v77 = 2048;
    *(void *)int v78 = a2;
    uint64_t v64 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if (!result)
    {
      free(v64);
LABEL_80:
      uint64_t v18 = 0;
      if (v10) {
        goto LABEL_19;
      }
LABEL_81:
      uint64_t v65 = nw_frame_create();
      if (v65)
      {
        uint64_t v10 = v65;
        __int16 v66 = *(_WORD *)(v65 + 204);
        if ((v66 & 4) != 0) {
          int v67 = (unsigned char *)(v65 + 208);
        }
        else {
          int v67 = 0;
        }
        *v67 |= 4u;
        *(_WORD *)(v65 + 204) = v66 | 1;
        *(void *)(v65 + 16) = 0;
        unsigned int v68 = (uint64_t *)v9[21];
        *(void *)(v65 + 24) = v68;
        *unsigned int v68 = v65;
        v9[21] = v65 + 16;
        goto LABEL_86;
      }
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      int v76 = "nw_protocol_tcp_get_malloc_frame";
      unsigned int v70 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        int v71 = __nwlog_obj();
        if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136446210;
          int v76 = "nw_protocol_tcp_get_malloc_frame";
          _os_log_impl(&dword_214653000, v71, OS_LOG_TYPE_ERROR, "%{public}s nw_frame_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
      if (v70) {
        free(v70);
      }
      if (!v18) {
        return 0;
      }
      unsigned int v72 = v18;
LABEL_96:
      free(v72);
      return 0;
    }
LABEL_105:
    __break(1u);
    return result;
  }
  unsigned int v17 = *(_DWORD *)(v10 + 48);
  if (v17 < a2)
  {
    free(v16);
    goto LABEL_16;
  }
  int v28 = *(unsigned __int16 *)(v10 + 204);
  *(void *)(v10 + 80) = nw_frame_tcp_finalize;
  *(void *)(v10 + 88) = v9;
  *(void *)(v10 + 112) = v16;
  *(void *)(v10 + 104) = 0;
  *(_WORD *)(v10 + 196) = 0;
  *(_DWORD *)(v10 + 48) = v17;
  *(_DWORD *)(v10 + 52) = v17;
  *(void *)(v10 + 56) = 0;
  *(_DWORD *)(v10 + 192) = 0;
  *(unsigned char *)(v10 + 200) = 0;
  unsigned int v29 = v28 & 0xFFFFFFC7 | (*(unsigned __int8 *)(v10 + 206) << 16);
  *(_WORD *)(v10 + 204) = v28 & 0xFFC7;
  *(unsigned char *)(v10 + 206) = BYTE2(v29);
  unsigned int v30 = *(void **)(v10 + 64);
  if (v30)
  {
    do
    {
      unsigned int v31 = (void *)*v30;
      BOOL v32 = (void *)v30[6];
      unsigned int v33 = (void *)*v30;
      if (v32)
      {
        nw_release(v32);
        v30[6] = 0;
        unsigned int v33 = (void *)*v30;
      }
      unsigned int v34 = (void *)v30[1];
      if (v33)
      {
        v33[1] = v34;
        unsigned int v34 = (void *)v30[1];
      }
      else
      {
        *(void *)(v10 + 72) = v34;
      }
      void *v34 = v33;
      if (v30 != (void *)(v10 + 120)) {
        free(v30);
      }
      unsigned int v30 = v31;
    }
    while (v31);
  }
  *(void *)(v10 + 64) = 0;
  *(void *)(v10 + 72) = v10 + 64;
  int v35 = *(void **)(v10 + 168);
  if (v35) {
    nw_release(v35);
  }
  __int16 v36 = *(_WORD *)(v10 + 204);
  *(void *)(v10 + 184) = 0;
  *(_OWORD *)(v10 + 168) = 0u;
  *(_OWORD *)(v10 + 152) = 0u;
  *(_OWORD *)(v10 + 136) = 0u;
  *(_OWORD *)(v10 + 120) = 0u;
  *(_WORD *)(v10 + 204) = v36 & 0x213F;
  *(unsigned char *)(v10 + 203) = 0;
  *(_WORD *)(v10 + 198) = 0;
  int v37 = *(_DWORD *)(v10 + 52);
  unsigned int v38 = *(_DWORD *)(v10 + 56) + a2;
  int v39 = *(_DWORD *)(v10 + 60);
  if (v38 <= v37 - v39)
  {
    *(_DWORD *)(v10 + 56) = v38;
    if (!v37) {
      goto LABEL_64;
    }
    goto LABEL_50;
  }
  double v40 = __nwlog_obj();
  if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
  {
    int v41 = *(_DWORD *)(v10 + 52);
    *(_DWORD *)long long buf = 136446978;
    int v76 = "__nw_frame_claim_internal";
    __int16 v77 = 1024;
    *(_DWORD *)int v78 = v38;
    *(_WORD *)&v78[4] = 1024;
    *(_DWORD *)&v78[6] = v41;
    LOWORD(v79) = 1024;
    *(_DWORD *)((char *)&v79 + 2) = v39;
    _os_log_impl(&dword_214653000, v40, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
  }
  int v37 = *(_DWORD *)(v10 + 52);
  if (v37)
  {
LABEL_50:
    uint64_t v43 = *(unsigned int *)(v10 + 56);
    size_t v42 = *(unsigned int *)(v10 + 60);
    uint64_t v44 = (v37 - (v42 + v43));
    if (v37 != v42 + v43)
    {
      if (v42)
      {
        uint64_t v45 = *(void *)(v10 + 112);
        if (v45)
        {
          memmove((void *)(v45 + v43), (const void *)(v45 + v43 + v44), v42);
          int v37 = *(_DWORD *)(v10 + 52);
        }
      }
      *(_DWORD *)(v10 + 52) = v37 - v44;
      if ((*(_WORD *)(v10 + 204) & 0x80) != 0)
      {
        unsigned int v46 = *(unsigned __int16 *)(v10 + 196);
        BOOL v47 = v46 >= v44;
        unsigned int v48 = v46 - v44;
        *(_WORD *)(v10 + 196) = v48;
        if (!v47 || v48 >= 0x10000)
        {
          __nwlog_obj();
          uint64_t v49 = *(unsigned __int16 *)(v10 + 196);
          *(_DWORD *)long long buf = 136446978;
          int v76 = "__nw_frame_collapse";
          __int16 v77 = 2082;
          *(void *)int v78 = "frame->aggregate_buffer_length";
          *(_WORD *)&v78[8] = 2048;
          uint64_t v79 = v44;
          __int16 v80 = 2048;
          uint64_t v81 = v49;
          int v50 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            int v51 = __nwlog_obj();
            if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
            {
              uint64_t v52 = *(unsigned __int16 *)(v10 + 196);
              *(_DWORD *)long long buf = 136446978;
              int v76 = "__nw_frame_collapse";
              __int16 v77 = 2082;
              *(void *)int v78 = "frame->aggregate_buffer_length";
              *(_WORD *)&v78[8] = 2048;
              uint64_t v79 = v44;
              __int16 v80 = 2048;
              uint64_t v81 = v52;
              _os_log_impl(&dword_214653000, v51, OS_LOG_TYPE_ERROR, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded", buf, 0x2Au);
            }
          }
          if (v50) {
            free(v50);
          }
          *(_WORD *)(v10 + 196) = 0;
        }
      }
    }
  }
LABEL_64:
  if ((*(_WORD *)(v10 + 204) & 0x80) != 0) {
    *(_WORD *)(v10 + 196) += a2;
  }
  unsigned int v53 = *(_DWORD *)(v10 + 56);
  BOOL v47 = v53 >= a2;
  unsigned int v54 = v53 - a2;
  if (v47)
  {
    *(_DWORD *)(v10 + 56) = v54;
  }
  else
  {
    int v55 = __nwlog_obj();
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      int v56 = *(_DWORD *)(v10 + 56);
      *(_DWORD *)long long buf = 136446722;
      int v76 = "__nw_frame_unclaim_internal";
      __int16 v77 = 1024;
      *(_DWORD *)int v78 = a2;
      *(_WORD *)&v78[4] = 1024;
      *(_DWORD *)&v78[6] = v56;
      _os_log_impl(&dword_214653000, v55, OS_LOG_TYPE_ERROR, "%{public}s Frame cannot unclaim %u start bytes (has %u left)", buf, 0x18u);
    }
  }
  __int16 v57 = *(_WORD *)(v10 + 204) | 1;
  *(void *)(v10 + 32) = 0;
  *(_WORD *)(v10 + 204) = v57;
  uint64_t v58 = *(uint64_t **)(a3 + 8);
  *(void *)(v10 + 40) = v58;
  *uint64_t v58 = v10;
  *(void *)(a3 + 8) = v10 + 32;
  uint64_t result = 1;
  if (a5) {
LABEL_87:
  }
    *a5 = 1;
  return result;
}

uint64_t __nw_protocol_tcp_get_slab_frame_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4)
  {
    *(void *)(v4 + 40) = *(void *)(a2 + 40);
    BOOL v5 = *(void **)(a2 + 40);
  }
  else
  {
    BOOL v5 = *(void **)(a2 + 40);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 32) = v5;
  }
  *BOOL v5 = v4;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  if (((*(_WORD *)(a2 + 204) & 0x100) == 0
     || !*MEMORY[0x263F144B8]
     || ((unsigned int (*)(uint64_t, void))*MEMORY[0x263F144B8])(a2, *(void *)(a2 + 88)))
    && *(void *)(a2 + 112))
  {
    nw_mem_buffer_free();
  }
  unsigned int v6 = (void *)(a2 + 16);
  uint64_t v7 = *(void *)(a2 + 16);
  if (v7)
  {
    *(void *)(v7 + 24) = *(void *)(a2 + 24);
    unsigned int v8 = *(void **)(a2 + 24);
  }
  else
  {
    unsigned int v8 = *(void **)(a2 + 24);
    *(void *)(*(void *)(a1 + 48) + 232) = v8;
  }
  *unsigned int v8 = v7;
  *unsigned int v6 = 0;
  *(void *)(a2 + 24) = 0;
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v10 = *(void **)(v9 + 216);
  *(void *)(a2 + 24) = v10;
  *uint64_t v10 = a2;
  *(void *)(v9 + 216) = v6;
  uint64_t v11 = *(void *)(a1 + 48);
  uint64_t v12 = *(void *)(v11 + 24);
  if ((v12 & 0x8000000000000000) == 0) {
    goto LABEL_13;
  }
  uint64_t v14 = __nwlog_obj();
  os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  uint64_t v15 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!result)
  {
    free(v15);
    uint64_t v11 = *(void *)(a1 + 48);
    uint64_t v12 = *(void *)(v11 + 24);
LABEL_13:
    *(void *)(v11 + 24) = v12 + 1;
    return 1;
  }
  __break(1u);
  return result;
}

uint64_t __nw_frame_tcp_finalize_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  uint64_t v2 = **(void **)(a1 + 32);
  if (v2 < 21) {
    return v2 > 20;
  }
  uint64_t v4 = *(void *)(a2 + 16);
  if (v4)
  {
    *(void *)(v4 + 24) = *(void *)(a2 + 24);
    BOOL v5 = *(void **)(a2 + 24);
  }
  else
  {
    BOOL v5 = *(void **)(a2 + 24);
    *(void *)(*(void *)(a1 + 40) + 8) = v5;
  }
  *BOOL v5 = v4;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  --**(void **)(a1 + 32);
  if (*(unsigned char *)(a1 + 48))
  {
    if ((*(_WORD *)(a2 + 204) & 2) != 0)
    {
      unsigned int v8 = *(void **)(a2 + 96);
      if (v8)
      {
        nw_release(v8);
        *(void *)(a2 + 96) = 0;
      }
    }
    else
    {
      unsigned int v6 = __nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        int v22 = "__nw_frame_set_external_data";
        _os_log_impl(&dword_214653000, v6, OS_LOG_TYPE_ERROR, "%{public}s Frame does not use external data", buf, 0xCu);
      }
    }
    goto LABEL_22;
  }
  if (*(unsigned char *)(a1 + 49))
  {
    if ((*(_WORD *)(a2 + 204) & 0x100) != 0
      && *MEMORY[0x263F144B8]
      && !((unsigned int (*)(uint64_t, void))*MEMORY[0x263F144B8])(a2, *(void *)(a2 + 88)))
    {
      goto LABEL_22;
    }
    uint64_t v7 = *(void **)(a2 + 112);
    if (!v7) {
      goto LABEL_22;
    }
    goto LABEL_14;
  }
  if (!*(unsigned char *)(a1 + 50)
    || (*(_WORD *)(a2 + 204) & 0x100) != 0
    && *MEMORY[0x263F144B8]
    && !((unsigned int (*)(uint64_t, void))*MEMORY[0x263F144B8])(a2, *(void *)(a2 + 88))
    || !*(void *)(a2 + 112))
  {
    goto LABEL_22;
  }
  int v19 = __nwlog_obj();
  os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
  *(_DWORD *)long long buf = 136446210;
  int v22 = "nw_frame_tcp_finalize_block_invoke";
  uint64_t v20 = _os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!result)
  {
    uint64_t v7 = (void *)v20;
LABEL_14:
    free(v7);
LABEL_22:
    int v9 = *(unsigned __int16 *)(a2 + 204);
    *(_WORD *)(a2 + 196) = 0;
    *(_DWORD *)(a2 + 192) = 0;
    *(unsigned char *)(a2 + 200) = 0;
    *(void *)(a2 + 56) = 0;
    *(void *)(a2 + 48) = 0;
    *(void *)(a2 + 88) = 0;
    *(void *)(a2 + 80) = 0;
    *(void *)(a2 + 112) = 0;
    *(void *)(a2 + 104) = 0;
    unsigned int v10 = v9 & 0xFFFFFFC7 | (*(unsigned __int8 *)(a2 + 206) << 16);
    *(_WORD *)(a2 + 204) = v10;
    *(unsigned char *)(a2 + 206) = BYTE2(v10);
    uint64_t v11 = *(void **)(a2 + 64);
    if (v11)
    {
      do
      {
        uint64_t v12 = (void *)*v11;
        char v13 = (void *)v11[6];
        uint64_t v14 = (void *)*v11;
        if (v13)
        {
          nw_release(v13);
          v11[6] = 0;
          uint64_t v14 = (void *)*v11;
        }
        uint64_t v15 = (void *)v11[1];
        if (v14)
        {
          v14[1] = v15;
          uint64_t v15 = (void *)v11[1];
        }
        else
        {
          *(void *)(a2 + 72) = v15;
        }
        *uint64_t v15 = v14;
        if (v11 != (void *)(a2 + 120)) {
          free(v11);
        }
        uint64_t v11 = v12;
      }
      while (v12);
    }
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = a2 + 64;
    unsigned int v16 = *(void **)(a2 + 168);
    if (v16) {
      nw_release(v16);
    }
    *(void *)(a2 + 184) = 0;
    *(_OWORD *)(a2 + 168) = 0u;
    *(_OWORD *)(a2 + 152) = 0u;
    *(_OWORD *)(a2 + 136) = 0u;
    __int16 v17 = *(_WORD *)(a2 + 204);
    *(_OWORD *)(a2 + 120) = 0u;
    *(_WORD *)(a2 + 204) = v17 & 0x213F;
    *(unsigned char *)(a2 + 203) = 0;
    *(_WORD *)(a2 + 198) = 0;
    nw_release((void *)a2);
    return v2 > 20;
  }
  __break(1u);
  return result;
}

BOOL nw_protocol_tcp_copy_frame_to_frame(uint64_t a1, int a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  unsigned int v8 = "__nw_frame_unclaimed_bytes";
  uint64_t v4 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    BOOL v5 = __nwlog_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446210;
      unsigned int v8 = "__nw_frame_unclaimed_bytes";
      _os_log_impl(&dword_214653000, v5, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
    }
  }
  if (v4) {
    free(v4);
  }
  return nw_protocol_tcp_copy_frame_to_buffer(a1, 0, a2, 0);
}

uint64_t nw_protocol_tcp_copy_frame(uint64_t a1, uint64_t a2, signed int a3)
{
  *(void *)&v46[13] = *MEMORY[0x263EF8340];
  v40[0] = 0;
  v40[1] = v40;
  if (a3 <= 0)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446466;
    uint64_t v44 = "nw_protocol_tcp_copy_frame";
    __int16 v45 = 1024;
    *(_DWORD *)unsigned int v46 = a3;
    uint64_t v9 = (void *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (!__nwlog_fault()) {
      goto LABEL_37;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)long long buf = 136446466;
      uint64_t v44 = "nw_protocol_tcp_copy_frame";
      __int16 v45 = 1024;
      *(_DWORD *)unsigned int v46 = a3;
      uint64_t v12 = "%{public}s called with null invalid len %d";
    }
    else if (v41)
    {
      os_log_t backtrace_string = (void *)__nw_create_backtrace_string();
      unsigned int v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v15 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)long long buf = 136446722;
          uint64_t v44 = "nw_protocol_tcp_copy_frame";
          __int16 v45 = 1024;
          *(_DWORD *)unsigned int v46 = a3;
          v46[2] = 2082;
          *(void *)&v46[3] = backtrace_string;
          _os_log_impl(&dword_214653000, v10, v11, "%{public}s called with null invalid len %d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_37;
      }
      if (!v15) {
        goto LABEL_37;
      }
      *(_DWORD *)long long buf = 136446466;
      uint64_t v44 = "nw_protocol_tcp_copy_frame";
      __int16 v45 = 1024;
      *(_DWORD *)unsigned int v46 = a3;
      uint64_t v12 = "%{public}s called with null invalid len %d, no backtrace";
    }
    else
    {
      unsigned int v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)long long buf = 136446466;
      uint64_t v44 = "nw_protocol_tcp_copy_frame";
      __int16 v45 = 1024;
      *(_DWORD *)unsigned int v46 = a3;
      uint64_t v12 = "%{public}s called with null invalid len %d, backtrace limit exceeded";
    }
    int v19 = v10;
    os_log_type_t v20 = v11;
    uint32_t v21 = 18;
LABEL_36:
    _os_log_impl(&dword_214653000, v19, v20, v12, buf, v21);
    goto LABEL_37;
  }
  if ((nw_protocol_tcp_get_frames(a1, a3, (uint64_t)v40, 1, 0, 0) & 1) == 0)
  {
    char v13 = __nwlog_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v44 = "nw_protocol_tcp_copy_frame";
      _os_log_impl(&dword_214653000, v13, OS_LOG_TYPE_ERROR, "%{public}s failed to get tcp frame array", buf, 0xCu);
    }
    return 0;
  }
  uint64_t v5 = v40[0];
  unsigned int v6 = (void *)MEMORY[0x263F144B8];
  if (v40[0])
  {
    uint64_t v7 = *(void *)(v40[0] + 112);
    if (v7)
    {
      if ((*(_WORD *)(v40[0] + 204) & 0x100) == 0 || !*MEMORY[0x263F144B8]) {
        goto LABEL_9;
      }
      if (((unsigned int (*)(void, void))*MEMORY[0x263F144B8])(v40[0], *(void *)(v40[0] + 88)))
      {
        uint64_t v7 = *(void *)(v5 + 112);
LABEL_9:
        unsigned int v8 = (char *)(v7 + *(unsigned int *)(v5 + 56));
        goto LABEL_22;
      }
    }
    unsigned int v8 = 0;
LABEL_22:
    if (!nw_protocol_tcp_copy_frame_to_buffer(a2, 0, a3, v8)) {
      goto LABEL_67;
    }
    goto LABEL_23;
  }
  int v22 = __nwlog_obj();
  os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
  *(_DWORD *)long long buf = 136446210;
  uint64_t v44 = "nw_protocol_tcp_copy_frame";
  uint64_t v23 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!result)
  {
    free(v23);
    if (!nw_protocol_tcp_copy_frame_to_frame(a2, a3)) {
      goto LABEL_71;
    }
LABEL_23:
    if (a2)
    {
      int v16 = *(unsigned __int16 *)(a2 + 204);
      int v17 = v16 | (*(unsigned __int8 *)(a2 + 206) << 16);
      if ((v16 & 0x100) == 0 || !*v6)
      {
LABEL_28:
        if ((v17 & 0x4000) == 0) {
          return v5;
        }
        unsigned int v18 = v17 & 0xFFFFBFFF;
        *(_WORD *)(a2 + 204) = v18;
        *(unsigned char *)(a2 + 206) = BYTE2(v18);
        if (v5)
        {
          *(_WORD *)(v5 + 204) |= 0x4000u;
          return v5;
        }
        __nwlog_obj();
        *(_DWORD *)long long buf = 136446210;
        uint64_t v44 = "__nw_frame_set_is_wake_packet";
        uint64_t v9 = (void *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v41 = 0;
        if (!__nwlog_fault()) {
          goto LABEL_37;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          unsigned int v31 = __nwlog_obj();
          os_log_type_t v32 = type;
          if (os_log_type_enabled(v31, type))
          {
            *(_DWORD *)long long buf = 136446210;
            uint64_t v44 = "__nw_frame_set_is_wake_packet";
            uint64_t v12 = "%{public}s called with null frame";
LABEL_101:
            int v19 = v31;
            os_log_type_t v20 = v32;
            uint32_t v21 = 12;
            goto LABEL_36;
          }
          goto LABEL_37;
        }
        if (!v41)
        {
          unsigned int v31 = __nwlog_obj();
          os_log_type_t v32 = type;
          if (os_log_type_enabled(v31, type))
          {
            *(_DWORD *)long long buf = 136446210;
            uint64_t v44 = "__nw_frame_set_is_wake_packet";
            uint64_t v12 = "%{public}s called with null frame, backtrace limit exceeded";
            goto LABEL_101;
          }
          goto LABEL_37;
        }
        unsigned int v33 = (void *)__nw_create_backtrace_string();
        unsigned int v31 = __nwlog_obj();
        os_log_type_t v32 = type;
        BOOL v34 = os_log_type_enabled(v31, type);
        if (!v33)
        {
          if (v34)
          {
            *(_DWORD *)long long buf = 136446210;
            uint64_t v44 = "__nw_frame_set_is_wake_packet";
            uint64_t v12 = "%{public}s called with null frame, no backtrace";
            goto LABEL_101;
          }
          goto LABEL_37;
        }
        if (v34)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v44 = "__nw_frame_set_is_wake_packet";
          __int16 v45 = 2082;
          *(void *)unsigned int v46 = v33;
          int v35 = "%{public}s called with null frame, dumping backtrace:%{public}s";
LABEL_87:
          _os_log_impl(&dword_214653000, v31, v32, v35, buf, 0x16u);
          goto LABEL_88;
        }
        goto LABEL_88;
      }
      if (((unsigned int (*)(uint64_t, void))*v6)(a2, *(void *)(a2 + 88)))
      {
        int v17 = *(unsigned __int16 *)(a2 + 204) | (*(unsigned __int8 *)(a2 + 206) << 16);
        goto LABEL_28;
      }
LABEL_66:
      if (v5)
      {
LABEL_67:
        __int16 v36 = *(void (**)(uint64_t, void, uint64_t))(v5 + 80);
        if (v36)
        {
          uint64_t v37 = *(void *)(v5 + 88);
          *(void *)(v5 + 80) = 0;
          *(void *)(v5 + 88) = 0;
          v36(v5, 0, v37);
          return 0;
        }
        __nwlog_obj();
        *(_DWORD *)long long buf = 136446210;
        uint64_t v44 = "__nw_frame_finalize";
        uint64_t v9 = (void *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v41 = 0;
        if (!__nwlog_fault()) {
          goto LABEL_37;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          unsigned int v31 = __nwlog_obj();
          os_log_type_t v32 = type;
          if (os_log_type_enabled(v31, type))
          {
            *(_DWORD *)long long buf = 136446210;
            uint64_t v44 = "__nw_frame_finalize";
            uint64_t v12 = "%{public}s called with null frame->finalizer";
            goto LABEL_101;
          }
          goto LABEL_37;
        }
        if (!v41)
        {
          unsigned int v31 = __nwlog_obj();
          os_log_type_t v32 = type;
          if (os_log_type_enabled(v31, type))
          {
            *(_DWORD *)long long buf = 136446210;
            uint64_t v44 = "__nw_frame_finalize";
            uint64_t v12 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
            goto LABEL_101;
          }
          goto LABEL_37;
        }
        unsigned int v33 = (void *)__nw_create_backtrace_string();
        unsigned int v31 = __nwlog_obj();
        os_log_type_t v32 = type;
        BOOL v39 = os_log_type_enabled(v31, type);
        if (!v33)
        {
          if (v39)
          {
            *(_DWORD *)long long buf = 136446210;
            uint64_t v44 = "__nw_frame_finalize";
            uint64_t v12 = "%{public}s called with null frame->finalizer, no backtrace";
            goto LABEL_101;
          }
          goto LABEL_37;
        }
        if (v39)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v44 = "__nw_frame_finalize";
          __int16 v45 = 2082;
          *(void *)unsigned int v46 = v33;
          int v35 = "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s";
          goto LABEL_87;
        }
        goto LABEL_88;
      }
LABEL_71:
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      uint64_t v44 = "__nw_frame_finalize";
      uint64_t v9 = (void *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v41 = 0;
      if (!__nwlog_fault()) {
        goto LABEL_37;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        unsigned int v31 = __nwlog_obj();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v44 = "__nw_frame_finalize";
          uint64_t v12 = "%{public}s called with null frame";
          goto LABEL_101;
        }
LABEL_37:
        if (v9) {
          free(v9);
        }
        return 0;
      }
      if (!v41)
      {
        unsigned int v31 = __nwlog_obj();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v44 = "__nw_frame_finalize";
          uint64_t v12 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_101;
        }
        goto LABEL_37;
      }
      unsigned int v33 = (void *)__nw_create_backtrace_string();
      unsigned int v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      BOOL v38 = os_log_type_enabled(v31, type);
      if (!v33)
      {
        if (v38)
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v44 = "__nw_frame_finalize";
          uint64_t v12 = "%{public}s called with null frame, no backtrace";
          goto LABEL_101;
        }
        goto LABEL_37;
      }
      if (v38)
      {
        *(_DWORD *)long long buf = 136446466;
        uint64_t v44 = "__nw_frame_finalize";
        __int16 v45 = 2082;
        *(void *)unsigned int v46 = v33;
        int v35 = "%{public}s called with null frame, dumping backtrace:%{public}s";
        goto LABEL_87;
      }
LABEL_88:
      free(v33);
      goto LABEL_37;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v44 = "__nw_frame_check_validity";
    BOOL v25 = (void *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (__nwlog_fault())
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v26 = __nwlog_obj();
        os_log_type_t v27 = type;
        if (!os_log_type_enabled(v26, type)) {
          goto LABEL_64;
        }
        *(_DWORD *)long long buf = 136446210;
        uint64_t v44 = "__nw_frame_check_validity";
        int v28 = "%{public}s called with null frame";
        goto LABEL_63;
      }
      if (!v41)
      {
        int v26 = __nwlog_obj();
        os_log_type_t v27 = type;
        if (!os_log_type_enabled(v26, type)) {
          goto LABEL_64;
        }
        *(_DWORD *)long long buf = 136446210;
        uint64_t v44 = "__nw_frame_check_validity";
        int v28 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_63;
      }
      unsigned int v29 = (void *)__nw_create_backtrace_string();
      int v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      BOOL v30 = os_log_type_enabled(v26, type);
      if (v29)
      {
        if (v30)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v44 = "__nw_frame_check_validity";
          __int16 v45 = 2082;
          *(void *)unsigned int v46 = v29;
          _os_log_impl(&dword_214653000, v26, v27, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v29);
        goto LABEL_64;
      }
      if (v30)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v44 = "__nw_frame_check_validity";
        int v28 = "%{public}s called with null frame, no backtrace";
LABEL_63:
        _os_log_impl(&dword_214653000, v26, v27, v28, buf, 0xCu);
      }
    }
LABEL_64:
    if (v25) {
      free(v25);
    }
    goto LABEL_66;
  }
  __break(1u);
  return result;
}

_DWORD *tcp_newreno_switch_cc(_DWORD *result)
{
  unsigned int v1 = result[36];
  if (result[35] >= v1) {
    unsigned int v2 = result[36];
  }
  else {
    unsigned int v2 = result[35];
  }
  if (v1 < result[37]) {
    v2 >>= 1;
  }
  unsigned int v3 = result[49];
  unsigned int v4 = v2 / v3;
  if (*(_DWORD *)(sysctls + 304))
  {
    unint64_t v5 = v3 * *(_DWORD *)(sysctls + 16);
    if (v3 * (unint64_t)v4 < v5) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  if (*(_DWORD *)(sysctls + 276))
  {
    unint64_t v5 = 10 * v3;
    if (v3 * (unint64_t)v4 < v5) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  if ((v3 * (unint64_t)v4) >> 2 >= 0x447)
  {
LABEL_14:
    LODWORD(v5) = v3 * v4;
    goto LABEL_15;
  }
  LODWORD(v5) = 4380;
LABEL_15:
  result[36] = v5;
  result[72] = 0;
  atomic_fetch_add(dword_26B4A9228, 1u);
  return result;
}

uint64_t tcp_newreno_after_timeout(uint64_t result)
{
  if (*(int *)(result + 12) >= 4)
  {
    unsigned int v1 = *(_DWORD *)(result + 140);
    if (v1 >= *(_DWORD *)(result + 144)) {
      unsigned int v1 = *(_DWORD *)(result + 144);
    }
    unsigned int v2 = *(_DWORD *)(result + 196);
    unsigned int v3 = (v1 >> 1) / v2;
    if (v3 <= 2) {
      unsigned int v3 = 2;
    }
    unsigned int v4 = v3 * v2;
    *(_DWORD *)(result + 144) = v2;
    *(_DWORD *)(result + 148) = v3 * v2;
    unint64_t v5 = *(_DWORD **)(*(void *)(result + 80) + 224);
    if (v5[97] > v4)
    {
      int v6 = v5[108];
      if ((v6 & 0x400) != 0)
      {
        if (v5[109] > v4)
        {
          if (*(int *)(sysctls + 232) > (uint64_t)v4) {
            unsigned int v4 = *(_DWORD *)(sysctls + 232);
          }
          if (v4 >= *(_DWORD *)(sysctls + 120)) {
            unsigned int v4 = *(_DWORD *)(sysctls + 120);
          }
          v5[109] = v4;
        }
        v5[108] = v6 | 0x800;
      }
    }
  }
  return result;
}

_DWORD *tcp_newreno_post_fr(_DWORD *result, uint64_t a2)
{
  unsigned int v2 = result + 23;
  if (a2) {
    unsigned int v2 = (_DWORD *)(a2 + 8);
  }
  int v3 = result[24] - *v2;
  int v4 = result[37];
  if (v3 < v4)
  {
    uint64_t v5 = result[49];
    if (v3 <= v5) {
      int v3 = result[49];
    }
    int v4 = v3 + v5;
  }
  result[36] = v4;
  result[72] = 0;
  return result;
}

uint64_t tcp_newreno_pre_fr(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 140);
  if (v1 >= *(_DWORD *)(result + 144)) {
    unsigned int v1 = *(_DWORD *)(result + 144);
  }
  unsigned int v2 = *(_DWORD *)(result + 196);
  unsigned int v3 = (v1 >> 1) / v2;
  if (v3 <= 2) {
    unsigned int v3 = 2;
  }
  unsigned int v4 = v3 * v2;
  *(_DWORD *)(result + 148) = v4;
  uint64_t v5 = *(_DWORD **)(*(void *)(result + 80) + 224);
  if (v5[97] > v4)
  {
    int v6 = v5[108];
    if ((v6 & 0x400) != 0)
    {
      if (v5[109] > v4)
      {
        if (*(int *)(sysctls + 232) > (uint64_t)v4) {
          unsigned int v4 = *(_DWORD *)(sysctls + 232);
        }
        if (v4 >= *(_DWORD *)(sysctls + 120)) {
          unsigned int v4 = *(_DWORD *)(sysctls + 120);
        }
        v5[109] = v4;
      }
      v5[108] = v6 | 0x800;
    }
  }
  return result;
}

uint64_t tcp_newreno_ack_rcvd(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 196);
  unsigned int v3 = *(_DWORD *)(a2 + 8) - *(_DWORD *)(result + 92);
  uint64_t v4 = *(unsigned int *)(result + 144);
  if (v4 >= *(_DWORD *)(result + 148))
  {
    unsigned int v5 = *(_DWORD *)(result + 288) + v3;
    *(_DWORD *)(result + 288) = v5;
    if (v5 >= v4) {
      *(_DWORD *)(result + 288) = v5 - v4;
    }
    else {
      unsigned int v2 = 0;
    }
  }
  else
  {
    v2 <<= *(_DWORD *)(result + 100) == *(_DWORD *)(result + 96);
    if (v3 < v2) {
      unsigned int v2 = *(_DWORD *)(a2 + 8) - *(_DWORD *)(result + 92);
    }
  }
  uint64_t v6 = v4 + v2;
  char v7 = *(unsigned char *)(result + 260);
  int v8 = v2 + v4;
  if (v6 >= 0xFFFFLL << v7) {
    int v8 = 0xFFFF << v7;
  }
  *(_DWORD *)(result + 144) = v8;
  return result;
}

_DWORD *tcp_newreno_congestion_avd(_DWORD *result, uint64_t a2)
{
  unsigned int v2 = result[36];
  if (v2 < result[35])
  {
    unsigned int v3 = result[72] + *(_DWORD *)(a2 + 8) - result[23];
    result[72] = v3;
    BOOL v4 = v3 >= v2;
    unsigned int v5 = v3 - v2;
    if (v5 != 0 && v4)
    {
      result[72] = v5;
      result[36] = result[49] + v2;
    }
  }
  return result;
}

uint64_t tcp_newreno_cwnd_init_or_reset(uint64_t result)
{
  if (*(_DWORD *)(sysctls + 276))
  {
    if (*(_DWORD *)(sysctls + 304)) {
      int v1 = *(_DWORD *)(sysctls + 16);
    }
    else {
      int v1 = 10;
    }
    *(_DWORD *)(result + 144) = *(_DWORD *)(result + 196) * v1;
  }
  else
  {
    uint64_t v2 = *(unsigned int *)(result + 196);
    LODWORD(v3) = 2 * v2;
    if (v2 <= 0x88E) {
      unint64_t v3 = 4380;
    }
    else {
      unint64_t v3 = v3;
    }
    if (v3 <= 4 * v2) {
      int v4 = v3;
    }
    else {
      int v4 = 4 * v2;
    }
    *(_DWORD *)(result + 144) = v4;
  }
  return result;
}

uint64_t tcp_newreno_cleanup()
{
  return 0;
}

uint64_t tcp_newreno_init()
{
  return 0;
}

uint64_t tcp_rledbat_switch_to(uint64_t result)
{
  int v1 = (_DWORD *)result;
  *(_DWORD *)(result + 1932) = 0;
  *(void *)(result + 1924) = 0;
  *(void *)(result + 1940) = 0;
  *(_DWORD *)(result + 1956) = 0;
  unsigned int v2 = *(_DWORD *)(result + 1948);
  if (v2)
  {
    if (v2 >> 17) {
      int v3 = v2 >> 1;
    }
    else {
      int v3 = 0xFFFF;
    }
  }
  else
  {
    uint64_t result = tcp_sbspace(result);
    int v4 = v1[31] - v1[30];
    if ((int)result > v4) {
      int v4 = result;
    }
    int v3 = (v4 & ~(v4 >> 31)) >> 1;
  }
  unsigned int v5 = v1[49];
  unsigned int v6 = (v3 + (v5 >> 1)) / v5 * v5;
  unsigned int v7 = v5 * *(_DWORD *)(sysctls + 16);
  if (v6 <= v7) {
    unsigned int v6 = v7;
  }
  v1[487] = v6;
  unsigned int v8 = v1[488];
  if (v8 >= 0x3FFFC000) {
    int v9 = 1073725440;
  }
  else {
    int v9 = v1[488];
  }
  if (v8) {
    int v10 = v9;
  }
  else {
    int v10 = 1073725440;
  }
  v1[488] = v10;
  return result;
}

uint64_t tcp_rledbat_after_idle(uint64_t result)
{
  *(_DWORD *)(result + 1932) = 0;
  *(void *)(result + 1924) = 0;
  *(void *)(result + 1940) = 0;
  *(_DWORD *)(result + 1956) = 0;
  *(_DWORD *)(result + 1948) = *(_DWORD *)(sysctls + 16) * *(_DWORD *)(result + 196);
  return result;
}

uint64_t tcp_rledbat_get_rlwin(uint64_t a1)
{
  LODWORD(v1) = *(_DWORD *)(a1 + 1948);
  unsigned int v2 = *(_DWORD *)(a1 + 1960);
  unsigned int v3 = v2 - v1;
  if (v2 >= v1)
  {
    int v4 = v2 <= v1 ? 0 : *(_DWORD *)(a1 + 1956);
    int v5 = v2 - v4;
    if (v3 >= *(_DWORD *)(a1 + 1956)) {
      LODWORD(v1) = v5;
    }
  }
  *(_DWORD *)(a1 + 1956) = 0;
  char v6 = *(unsigned char *)(a1 + 261);
  unsigned int v7 = ((1 << v6) + v1) & -(1 << v6);
  if ((v1 & ((1 << v6) - 1)) == 0) {
    unsigned int v7 = v1;
  }
  if (*(unsigned char *)(a1 + 261)) {
    uint64_t v1 = v7;
  }
  else {
    uint64_t v1 = v1;
  }
  *(_DWORD *)(a1 + 1960) = v1;
  return v1;
}

uint64_t tcp_rledbat_data_rcvd(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v8 = *(void *)(a1 + 80);
  uint64_t v9 = *(void *)(v8 + 496);
  if (v9 && (uint64_t v10 = *(void *)(v9 + 1488)) != 0) {
    unsigned int v11 = *(_DWORD *)(v10 + 40);
  }
  else {
    unsigned int v11 = 0;
  }
  uint64_t v12 = 1908;
  if (!*(_DWORD *)(sysctls + 312)) {
    uint64_t v12 = 236;
  }
  unsigned int v13 = *(_DWORD *)(a1 + v12);
  int v14 = *(_DWORD *)(a1 + 1968) >> 5;
  int v15 = 3 * *(_DWORD *)(sysctls + 4);
  if (v15 >= 0) {
    int v16 = 3 * *(_DWORD *)(sysctls + 4);
  }
  else {
    int v16 = v15 + 3;
  }
  *(_DWORD *)(a1 + 1956) += a4;
  uint64_t result = nw_tcp_access_globals(*(void *)(v8 + 224));
  unsigned int v18 = *(_DWORD *)(a1 + 1928);
  if (v18)
  {
    unsigned int v19 = *(_DWORD *)(result + 316);
    if (v19 >= v18)
    {
      if (!*(_DWORD *)(a1 + 1932))
      {
        *(_DWORD *)(a1 + 1932) = v19;
        ++*(_DWORD *)(a1 + 1924);
      }
      if (v19 < v18 + 2 * v14)
      {
        unsigned int v20 = *(_DWORD *)(a1 + 1948);
        unsigned int v21 = *(_DWORD *)(a1 + 196) * *(_DWORD *)(sysctls + 16);
        if (v20 > v21)
        {
          if (*(_DWORD *)(a1 + 1952) < v20) {
            *(_DWORD *)(a1 + 1952) = v20;
          }
          *(_DWORD *)(a1 + 1948) = v21;
          *(_DWORD *)(a1 + 1940) = 0;
        }
        return result;
      }
    }
  }
  if ((int)(*(_DWORD *)(a2 + 4) + a4 - *(_DWORD *)(a1 + 1916)) < 0 && *(_DWORD *)(a3 + 4) - *(_DWORD *)(a1 + 1920) >= 0)
  {
    unsigned int v35 = *(_DWORD *)(result + 316);
    if (v35 >= *(_DWORD *)(a1 + 1936))
    {
      unsigned int v36 = *(_DWORD *)(a1 + 196);
      unsigned int v37 = ((v36 >> 1) + (*(_DWORD *)(a1 + 1948) >> 1)) / v36 * v36;
      unsigned int v38 = 2 * v36;
      if (v37 <= v38) {
        unsigned int v37 = v38;
      }
      *(_DWORD *)(a1 + 1952) = v37;
      *(_DWORD *)(a1 + 1948) = v37;
      *(void *)(a1 + 1940) = 0;
      *(_DWORD *)(a1 + 1936) = v35 + 2 * v14;
      if (v18)
      {
        unsigned int v39 = v35 + 60000;
LABEL_66:
        *(_DWORD *)(a1 + 1928) = v39;
        return result;
      }
    }
    return result;
  }
  if (v13) {
    BOOL v22 = v11 == 0;
  }
  else {
    BOOL v22 = 1;
  }
  if (v22)
  {
    unsigned int v23 = 10 * *(_DWORD *)(a1 + 196);
    if (v23 >= a4) {
      unsigned int v23 = a4;
    }
    uint64_t v24 = v23 + *(_DWORD *)(a1 + 1948);
LABEL_28:
    char v25 = *(unsigned char *)(a1 + 261);
    uint64_t v26 = 0xFFFFLL << v25;
    int v27 = 0xFFFF << v25;
    if (v26 <= v24) {
      LODWORD(v24) = v27;
    }
    *(_DWORD *)(a1 + 1948) = v24;
    return result;
  }
  unsigned int v28 = *(_DWORD *)(a1 + 1948);
  unsigned int v29 = *(_DWORD *)(a1 + 1952);
  if (v28 < v29)
  {
    int v30 = v16 >> 2;
    if (*(_DWORD *)(a1 + 1924))
    {
      int v31 = *(_DWORD *)(sysctls + 4);
      int v32 = 2 * v31;
      unsigned int v33 = v30 + v11;
      if (v13 <= 2 * v31 + v11 || v13 <= v33) {
        goto LABEL_72;
      }
    }
    else if (v13 <= v30 + v11)
    {
      int v31 = *(_DWORD *)(sysctls + 4);
      int v32 = 2 * v31;
LABEL_72:
      unsigned int v56 = *(_DWORD *)(a1 + 1940) + a4;
      *(_DWORD *)(a1 + 1940) = v56;
      double v57 = (double)v32 / (double)v11;
      double v58 = trunc(v57);
      if (v57 <= v58) {
        double v59 = 0.0;
      }
      else {
        double v59 = 1.0;
      }
      if ((v59 + v58) <= 0x10)
      {
        double v61 = (double)(2 * v31) / (double)v11;
        double v62 = trunc(v61);
        if (v61 <= v62) {
          double v63 = 0.0;
        }
        else {
          double v63 = 1.0;
        }
        unsigned int v60 = (v63 + v62);
      }
      else
      {
        unsigned int v60 = 16;
      }
      unsigned int v64 = *(_DWORD *)(a1 + 196);
      if (v56 >= v64 * v60)
      {
        unsigned int v65 = v56 / v60;
        if (v65 >= 10 * v64) {
          unsigned int v65 = 10 * v64;
        }
        *(_DWORD *)(a1 + 1940) = 0;
        uint64_t v66 = (v28 + v65 + (v64 >> 1)) / v64 * v64;
        char v67 = *(unsigned char *)(a1 + 261);
        uint64_t v68 = 0xFFFFLL << v67;
        int v69 = 0xFFFF << v67;
        if (v68 <= v66) {
          LODWORD(v66) = v69;
        }
        *(_DWORD *)(a1 + 1948) = v66;
      }
      if (v18) {
        *(_DWORD *)(a1 + 1928) = 0;
      }
      return result;
    }
  }
  unsigned int v40 = *(_DWORD *)(result + 316);
  if (!v18)
  {
    int v41 = v28 >= v29 ? 60000 : 120000;
    int v42 = *(_DWORD *)(a1 + 1924) ? v41 : 60000;
    unsigned int v18 = v42 + v40;
    *(void *)(a1 + 1928) = v18;
    if (v28 < v29)
    {
      *(_DWORD *)(a1 + 1952) = v28;
      unsigned int v29 = v28;
    }
  }
  uint64_t v43 = sysctls;
  int v44 = *(_DWORD *)(sysctls + 4);
  if (v44 + v11 >= v13)
  {
    unsigned int v53 = *(_DWORD *)(a1 + 1940) + a4;
    *(_DWORD *)(a1 + 1940) = v53;
    unsigned int v54 = v53 - v28;
    if (v53 < v28) {
      return result;
    }
    unsigned int v55 = *(_DWORD *)(a1 + 196);
    *(_DWORD *)(a1 + 1940) = v54;
    if (v29 < v28) {
      *(_DWORD *)(a1 + 1952) = v28;
    }
    uint64_t v24 = (v55 + v28 + (v55 >> 1)) / v55 * v55;
    goto LABEL_28;
  }
  if (*(_DWORD *)(a1 + 1936) <= v40)
  {
    unsigned int v45 = *(_DWORD *)(a1 + 1944) + a4;
    *(_DWORD *)(a1 + 1944) = v45;
    BOOL v46 = v45 >= v28;
    unsigned int v47 = v45 - v28;
    if (v46)
    {
      unsigned int v48 = v13 - v11;
      if (v13 < v11) {
        unsigned int v48 = 0;
      }
      *(_DWORD *)(a1 + 1944) = v47;
      unsigned int v49 = v28 - (fmin((double)v48 / (double)v44 + -1.0, 0.5) * (double)v28);
      unsigned int v50 = *(_DWORD *)(a1 + 196);
      unsigned int v51 = v50 * *(_DWORD *)(v43 + 16);
      if (v49 <= v51) {
        unsigned int v49 = v51;
      }
      unsigned int v52 = (v49 + (v50 >> 1)) / v50 * v50;
      *(_DWORD *)(a1 + 1948) = v52;
      if (v29 > v52) {
        *(_DWORD *)(a1 + 1952) = v52;
      }
      if (v18)
      {
        unsigned int v39 = v40 + 60000;
        goto LABEL_66;
      }
    }
  }
  return result;
}

_DWORD *tcp_rledbat_rwnd_init(_DWORD *result)
{
  result[487] = *(_DWORD *)(sysctls + 16) * result[49];
  if (!result[488]) {
    result[488] = 1073725440;
  }
  return result;
}

void tcp_rledbat_cleanup()
{
}

double tcp_rledbat_init(uint64_t a1)
{
  atomic_fetch_add(dword_26AA46340, 1u);
  *(_DWORD *)(a1 + 1932) = 0;
  *(void *)(a1 + 1924) = 0;
  *(void *)(a1 + 1940) = 0;
  *(_DWORD *)(a1 + 1948) = *(_DWORD *)(sysctls + 16) * *(_DWORD *)(a1 + 196);
  *(void *)&double result = 1073725440;
  *(void *)(a1 + 1952) = 1073725440;
  return result;
}

void user_north_signal_error(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 32);
    if (v2)
    {
      if (*(_WORD *)(a1 + 376))
      {
        if ((*(unsigned char *)(a1 + 828) & 2) == 0)
        {
          int v4 = __nwlog_tcp_log();
          if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
          {
            int v5 = 136446722;
            char v6 = "user_north_signal_error";
            __int16 v7 = 2082;
            uint64_t v8 = a1 + 604;
            __int16 v9 = 2048;
            uint64_t v10 = a1;
            _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping so %p SS_NOFDREF", (uint8_t *)&v5, 0x20u);
          }
        }
      }
      else
      {
        unsigned int v3 = *(void (**)(uint64_t, void))(v2 + 120);
        if (v3) {
          v3(a1, *(unsigned __int16 *)(a1 + 378));
        }
      }
      *(_WORD *)(a1 + 378) = 0;
    }
  }
}

uint64_t nw_tcp_destroy_globals(void *a1)
{
  uint64_t v2 = (void **)a1[4];
  unsigned int v3 = *v2;
  if (!*v2) {
    goto LABEL_8;
  }
  do
  {
    int v5 = *v2;
    for (i = v2; v5 != v3; int v5 = (void *)*v5)
      uint64_t i = v5;
    int v4 = (void *)*v3;
    *uint64_t i = *v3;
    free(v3);
    unsigned int v3 = v4;
  }
  while (v4);
  uint64_t v2 = (void **)a1[4];
  if (v2)
  {
LABEL_8:
    free(v2);
    a1[4] = 0;
  }
  if (a1[11])
  {
    nw_queue_cancel_source();
    a1[11] = 0;
  }
  if (a1[12])
  {
    nw_queue_cancel_source();
    a1[12] = 0;
  }
  __int16 v7 = (void *)a1[9];
  if (v7)
  {
    free(v7);
    a1[9] = 0;
  }
  nw_tcp_release_frame_array();
  nw_tcp_release_frame_array();
  nw_tcp_release_frame_array();
  nw_tcp_release_frame_array();
  nw_tcp_release_frame_array();
  uint64_t result = nw_tcp_release_frame_array();
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  return result;
}

uint64_t nw_tcp_release_frame_array()
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v0 = (void *)MEMORY[0x263F144B8];
  while (1)
  {
    uint64_t result = nw_frame_array_is_empty();
    if (result) {
      return result;
    }
    uint64_t v2 = nw_frame_array_first();
    nw_frame_array_remove();
    if (v2)
    {
      unsigned int v3 = (void *)(v2 + 104);
      __int16 v4 = *(_WORD *)(v2 + 204);
      if ((v4 & 2) != 0)
      {
        unsigned int v13 = *(void **)(v2 + 96);
        if (v13)
        {
          nw_release(v13);
          *(void *)(v2 + 96) = 0;
        }
        *(_DWORD *)(v2 + 52) = 0;
        *(_DWORD *)(v2 + 56) = 0;
        *(_WORD *)(v2 + 196) = 0;
      }
      else
      {
        if (*(void *)(v2 + 104))
        {
          if (((*(_WORD *)(v2 + 204) & 0x100) == 0
             || !*v0
             || ((unsigned int (*)(uint64_t, void))*v0)(v2, *(void *)(v2 + 88)))
            && *(void *)(v2 + 112))
          {
            nw_mem_buffer_free();
          }
          int v5 = *(unsigned __int16 *)(v2 + 204);
          *(_WORD *)(v2 + 196) = 0;
          *(_DWORD *)(v2 + 192) = 0;
          *(unsigned char *)(v2 + 200) = 0;
          *(void *)(v2 + 56) = 0;
          *(void *)(v2 + 48) = 0;
          *(void *)(v2 + 88) = 0;
          *(void *)(v2 + 80) = 0;
          *unsigned int v3 = 0;
          *(void *)(v2 + 112) = 0;
          unsigned int v6 = v5 & 0xFFFFFFC7 | (*(unsigned __int8 *)(v2 + 206) << 16);
          *(_WORD *)(v2 + 204) = v6;
          *(unsigned char *)(v2 + 206) = BYTE2(v6);
          uint64_t v8 = v2 + 64;
          __int16 v7 = *(void **)(v2 + 64);
          if (v7)
          {
            do
            {
              __int16 v9 = (void *)*v7;
              uint64_t v10 = (void *)v7[6];
              uint64_t v11 = (void *)*v7;
              if (v10)
              {
                nw_release(v10);
                v7[6] = 0;
                uint64_t v11 = (void *)*v7;
              }
              uint64_t v12 = (void *)v7[1];
              if (v11)
              {
                v11[1] = v12;
                uint64_t v12 = (void *)v7[1];
              }
              else
              {
                *(void *)(v2 + 72) = v12;
              }
              *uint64_t v12 = v11;
              if (v7 != (void *)(v2 + 120)) {
                free(v7);
              }
              __int16 v7 = v9;
            }
            while (v9);
          }
        }
        else
        {
          if ((v4 & 1) == 0) {
            goto LABEL_3;
          }
          if ((*(_WORD *)(v2 + 204) & 0x100) == 0
            || !*v0
            || ((unsigned int (*)(uint64_t, void))*v0)(v2, *(void *)(v2 + 88)))
          {
            int v14 = *(void **)(v2 + 112);
            if (v14) {
              free(v14);
            }
          }
          int v15 = *(unsigned __int16 *)(v2 + 204);
          *(_WORD *)(v2 + 196) = 0;
          *(_DWORD *)(v2 + 192) = 0;
          *(unsigned char *)(v2 + 200) = 0;
          *(void *)(v2 + 56) = 0;
          *(void *)(v2 + 48) = 0;
          *(void *)(v2 + 88) = 0;
          *(void *)(v2 + 80) = 0;
          *unsigned int v3 = 0;
          *(void *)(v2 + 112) = 0;
          unsigned int v16 = v15 & 0xFFFFFFC7 | (*(unsigned __int8 *)(v2 + 206) << 16);
          *(_WORD *)(v2 + 204) = v16;
          *(unsigned char *)(v2 + 206) = BYTE2(v16);
          uint64_t v8 = v2 + 64;
          int v17 = *(void **)(v2 + 64);
          if (v17)
          {
            do
            {
              unsigned int v18 = (void *)*v17;
              unsigned int v19 = (void *)v17[6];
              unsigned int v20 = (void *)*v17;
              if (v19)
              {
                nw_release(v19);
                v17[6] = 0;
                unsigned int v20 = (void *)*v17;
              }
              unsigned int v21 = (void *)v17[1];
              if (v20)
              {
                v20[1] = v21;
                unsigned int v21 = (void *)v17[1];
              }
              else
              {
                *(void *)(v2 + 72) = v21;
              }
              *unsigned int v21 = v20;
              if (v17 != (void *)(v2 + 120)) {
                free(v17);
              }
              int v17 = v18;
            }
            while (v18);
          }
        }
        *(void *)(v2 + 64) = 0;
        *(void *)(v2 + 72) = v8;
        BOOL v22 = *(void **)(v2 + 168);
        if (v22) {
          nw_release(v22);
        }
        __int16 v23 = *(_WORD *)(v2 + 204);
        *(void *)(v2 + 184) = 0;
        *(_OWORD *)(v2 + 168) = 0u;
        *(_OWORD *)(v2 + 152) = 0u;
        *(_OWORD *)(v2 + 136) = 0u;
        *(_OWORD *)(v2 + 120) = 0u;
        *(_WORD *)(v2 + 204) = v23 & 0x213F;
        *(unsigned char *)(v2 + 203) = 0;
        *(_WORD *)(v2 + 198) = 0;
      }
LABEL_3:
      nw_release((void *)v2);
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      int v31 = "__nw_frame_buffer_get_manager";
      uint64_t v24 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        char v25 = __nwlog_obj();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136446210;
          int v31 = "__nw_frame_buffer_get_manager";
          _os_log_impl(&dword_214653000, v25, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
        }
      }
      if (v24) {
        free(v24);
      }
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      int v31 = "__nw_frame_uses_external_data";
      uint64_t v26 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        int v27 = __nwlog_obj();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136446210;
          int v31 = "__nw_frame_uses_external_data";
          _os_log_impl(&dword_214653000, v27, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
        }
      }
      if (v26) {
        free(v26);
      }
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      int v31 = "__nw_frame_buffer_used_malloc";
      unsigned int v28 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        unsigned int v29 = __nwlog_obj();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136446210;
          int v31 = "__nw_frame_buffer_used_malloc";
          _os_log_impl(&dword_214653000, v29, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
        }
      }
      if (v28) {
        free(v28);
      }
    }
  }
}

uint64_t nw_protocol_tcp_set_no_push(uint64_t a1, int a2)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (a1)
  {
    int v5 = (os_unfair_lock_s *)(a1 + 5264);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 5264));
    *(_DWORD *)os_log_type_t type = a2;
    *(void *)long long buf = 0x600000001;
    *(void *)&buf[8] = 4;
    *(void *)&buf[16] = type;
    uint64_t v19 = 4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16))(a1, 1, v2);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(unsigned char *)(a1 + 365) & 0x20) != 0) {
      uint64_t v6 = tcp_ctloutput(a1, (uint64_t)buf);
    }
    else {
      uint64_t v6 = 22;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v2);
    if (!v6) {
      goto LABEL_16;
    }
    __nwlog_obj();
    uint64_t v7 = a1 + 604;
    *(_DWORD *)long long buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_push";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = a1 + 604;
    *(_WORD *)&unsigned char buf[22] = 1024;
    LODWORD(v19) = v6;
    uint64_t v8 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __int16 v9 = __nwlog_obj();
        os_log_type_t v10 = type[0];
        if (!os_log_type_enabled(v9, type[0])) {
          goto LABEL_14;
        }
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_push";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v7;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v19) = v6;
        uint64_t v11 = "%{public}s %{public}s tcp_set_no_push failed %{darwin.errno}d";
      }
      else
      {
        __int16 v9 = __nwlog_obj();
        os_log_type_t v10 = type[0];
        if (!os_log_type_enabled(v9, type[0])) {
          goto LABEL_14;
        }
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_push";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v7;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v19) = v6;
        uint64_t v11 = "%{public}s %{public}s tcp_set_no_push failed %{darwin.errno}d, backtrace limit exceeded";
      }
      _os_log_impl(&dword_214653000, v9, v10, v11, buf, 0x1Cu);
    }
LABEL_14:
    if (v8) {
      free(v8);
    }
LABEL_16:
    os_unfair_lock_unlock(v5);
    return v6;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_push";
  unsigned int v13 = (void *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  if (__nwlog_fault())
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v14 = __nwlog_obj();
      os_log_type_t v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_push";
        unsigned int v16 = "%{public}s called with null handle";
LABEL_24:
        _os_log_impl(&dword_214653000, v14, v15, v16, buf, 0xCu);
      }
    }
    else
    {
      int v14 = __nwlog_obj();
      os_log_type_t v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_push";
        unsigned int v16 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_24;
      }
    }
  }
  if (v13) {
    free(v13);
  }
  return 22;
}

uint64_t nw_protocol_tcp_set_no_delay(uint64_t a1, int a2)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (a1)
  {
    int v5 = (os_unfair_lock_s *)(a1 + 5264);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 5264));
    *(_DWORD *)os_log_type_t type = a2;
    *(void *)long long buf = 0x600000001;
    *(void *)&buf[8] = 1;
    *(void *)&buf[16] = type;
    uint64_t v19 = 4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16))(a1, 1, v2);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(unsigned char *)(a1 + 365) & 0x20) != 0) {
      uint64_t v6 = tcp_ctloutput(a1, (uint64_t)buf);
    }
    else {
      uint64_t v6 = 22;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v2);
    if (!v6) {
      goto LABEL_16;
    }
    __nwlog_obj();
    uint64_t v7 = a1 + 604;
    *(_DWORD *)long long buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_delay";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = a1 + 604;
    *(_WORD *)&unsigned char buf[22] = 1024;
    LODWORD(v19) = v6;
    uint64_t v8 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __int16 v9 = __nwlog_obj();
        os_log_type_t v10 = type[0];
        if (!os_log_type_enabled(v9, type[0])) {
          goto LABEL_14;
        }
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_delay";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v7;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v19) = v6;
        uint64_t v11 = "%{public}s %{public}s tcp_set_no_delay failed %{darwin.errno}d";
      }
      else
      {
        __int16 v9 = __nwlog_obj();
        os_log_type_t v10 = type[0];
        if (!os_log_type_enabled(v9, type[0])) {
          goto LABEL_14;
        }
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_delay";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v7;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v19) = v6;
        uint64_t v11 = "%{public}s %{public}s tcp_set_no_delay failed %{darwin.errno}d, backtrace limit exceeded";
      }
      _os_log_impl(&dword_214653000, v9, v10, v11, buf, 0x1Cu);
    }
LABEL_14:
    if (v8) {
      free(v8);
    }
LABEL_16:
    os_unfair_lock_unlock(v5);
    return v6;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_delay";
  unsigned int v13 = (void *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  if (__nwlog_fault())
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v14 = __nwlog_obj();
      os_log_type_t v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_delay";
        unsigned int v16 = "%{public}s called with null handle";
LABEL_24:
        _os_log_impl(&dword_214653000, v14, v15, v16, buf, 0xCu);
      }
    }
    else
    {
      int v14 = __nwlog_obj();
      os_log_type_t v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_delay";
        unsigned int v16 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_24;
      }
    }
  }
  if (v13) {
    free(v13);
  }
  return 22;
}

uint64_t nw_protocol_tcp_reset_keepalives(uint64_t a1, int a2, int a3, int a4, int a5)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v11 = (os_unfair_lock_s *)(a1 + 5264);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 5264));
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16))(a1, 1, v5);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) == 0 && (*(unsigned char *)(a1 + 365) & 0x20) == 0)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v5);
      __nwlog_obj();
      uint64_t v12 = a1 + 604;
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v33) = 22;
      unsigned int v13 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          int v14 = __nwlog_obj();
          os_log_type_t v15 = type[0];
          if (os_log_type_enabled(v14, type[0]))
          {
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v12;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v33) = 22;
            unsigned int v16 = "%{public}s %{public}s tcp_set_keepalive failed %{darwin.errno}d";
LABEL_45:
            _os_log_impl(&dword_214653000, v14, v15, v16, buf, 0x1Cu);
          }
        }
        else
        {
          int v14 = __nwlog_obj();
          os_log_type_t v15 = type[0];
          if (os_log_type_enabled(v14, type[0]))
          {
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v12;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v33) = 22;
            unsigned int v16 = "%{public}s %{public}s tcp_set_keepalive failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_45;
          }
        }
      }
      if (v13) {
        free(v13);
      }
      uint64_t v18 = 22;
LABEL_54:
      os_unfair_lock_unlock(v11);
      return v18;
    }
    if (a2) {
      int v17 = 8;
    }
    else {
      int v17 = 0;
    }
    *(_DWORD *)(a1 + 372) = *(_DWORD *)(a1 + 372) & 0xFFFFFFF7 | v17;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v5);
    *(_DWORD *)os_log_type_t type = a4;
    *(void *)long long buf = 0x600000001;
    *(void *)&buf[8] = 16;
    *(void *)&buf[16] = type;
    uint64_t v33 = 4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16))(a1, 1, v5);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(unsigned char *)(a1 + 365) & 0x20) != 0) {
      uint64_t v18 = tcp_ctloutput(a1, (uint64_t)buf);
    }
    else {
      uint64_t v18 = 22;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v5);
    if (v18)
    {
      __nwlog_obj();
      uint64_t v19 = a1 + 604;
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v33) = v18;
      uint64_t v20 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      if (!__nwlog_fault()) {
        goto LABEL_52;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        unsigned int v21 = __nwlog_obj();
        os_log_type_t v22 = type[0];
        if (!os_log_type_enabled(v21, type[0])) {
          goto LABEL_52;
        }
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v19;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v33) = v18;
        __int16 v23 = "%{public}s %{public}s tcp_set_keepalive_idle_time failed %{darwin.errno}d";
      }
      else
      {
        unsigned int v21 = __nwlog_obj();
        os_log_type_t v22 = type[0];
        if (!os_log_type_enabled(v21, type[0])) {
          goto LABEL_52;
        }
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v19;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v33) = v18;
        __int16 v23 = "%{public}s %{public}s tcp_set_keepalive_idle_time failed %{darwin.errno}d, backtrace limit exceeded";
      }
    }
    else
    {
      *(_DWORD *)os_log_type_t type = a5;
      *(void *)long long buf = 0x600000001;
      *(void *)&buf[8] = 257;
      *(void *)&buf[16] = type;
      uint64_t v33 = 4;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16))(a1, 1, v5);
      if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(unsigned char *)(a1 + 365) & 0x20) != 0) {
        uint64_t v18 = tcp_ctloutput(a1, (uint64_t)buf);
      }
      else {
        uint64_t v18 = 22;
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v5);
      if (v18)
      {
        __nwlog_obj();
        uint64_t v24 = a1 + 604;
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 604;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v33) = v18;
        uint64_t v20 = (void *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        if (!__nwlog_fault()) {
          goto LABEL_52;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          unsigned int v21 = __nwlog_obj();
          os_log_type_t v22 = type[0];
          if (!os_log_type_enabled(v21, type[0])) {
            goto LABEL_52;
          }
          *(_DWORD *)long long buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v24;
          *(_WORD *)&unsigned char buf[22] = 1024;
          LODWORD(v33) = v18;
          __int16 v23 = "%{public}s %{public}s tcp_set_keepalive_interval failed %{darwin.errno}d";
        }
        else
        {
          unsigned int v21 = __nwlog_obj();
          os_log_type_t v22 = type[0];
          if (!os_log_type_enabled(v21, type[0])) {
            goto LABEL_52;
          }
          *(_DWORD *)long long buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v24;
          *(_WORD *)&unsigned char buf[22] = 1024;
          LODWORD(v33) = v18;
          __int16 v23 = "%{public}s %{public}s tcp_set_keepalive_interval failed %{darwin.errno}d, backtrace limit exceeded";
        }
      }
      else
      {
        *(_DWORD *)os_log_type_t type = a3;
        *(void *)long long buf = 0x600000001;
        *(void *)&buf[8] = 258;
        *(void *)&buf[16] = type;
        uint64_t v33 = 4;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16))(a1, 1, v5);
        if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(unsigned char *)(a1 + 365) & 0x20) != 0) {
          uint64_t v18 = tcp_ctloutput(a1, (uint64_t)buf);
        }
        else {
          uint64_t v18 = 22;
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v5);
        if (!v18) {
          goto LABEL_54;
        }
        __nwlog_obj();
        uint64_t v25 = a1 + 604;
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 604;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v33) = v18;
        uint64_t v20 = (void *)_os_log_send_and_compose_impl();
        if (!__nwlog_fault()
          || (unsigned int v21 = __nwlog_obj(), v22 = OS_LOG_TYPE_ERROR, !os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)))
        {
LABEL_52:
          if (v20) {
            free(v20);
          }
          goto LABEL_54;
        }
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v25;
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v33) = v18;
        __int16 v23 = "%{public}s %{public}s tcp_setsockopt TCP_KEEPCNT failed %{darwin.errno}d, backtrace limit exceeded";
      }
    }
    _os_log_impl(&dword_214653000, v21, v22, v23, buf, 0x1Cu);
    goto LABEL_52;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
  int v27 = (void *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  if (__nwlog_fault())
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      unsigned int v28 = __nwlog_obj();
      os_log_type_t v29 = type[0];
      if (os_log_type_enabled(v28, type[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
        int v30 = "%{public}s called with null handle";
LABEL_62:
        _os_log_impl(&dword_214653000, v28, v29, v30, buf, 0xCu);
      }
    }
    else
    {
      unsigned int v28 = __nwlog_obj();
      os_log_type_t v29 = type[0];
      if (os_log_type_enabled(v28, type[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
        int v30 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_62;
      }
    }
  }
  if (v27) {
    free(v27);
  }
  return 22;
}

uint64_t nw_protocol_tcp_get_send_buffer_size(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(unsigned int *)(a1 + 5288);
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v5 = "nw_protocol_tcp_get_send_buffer_size";
  uint64_t v2 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    unsigned int v3 = __nwlog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v5 = "nw_protocol_tcp_get_send_buffer_size";
      _os_log_impl(&dword_214653000, v3, OS_LOG_TYPE_ERROR, "%{public}s called with null handle, backtrace limit exceeded", buf, 0xCu);
    }
  }
  if (v2) {
    free(v2);
  }
  return 0;
}

uint64_t nw_protocol_tcp_get_receive_buffer_size(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(unsigned int *)(a1 + 5292);
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v5 = "nw_protocol_tcp_get_receive_buffer_size";
  uint64_t v2 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    unsigned int v3 = __nwlog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v5 = "nw_protocol_tcp_get_receive_buffer_size";
      _os_log_impl(&dword_214653000, v3, OS_LOG_TYPE_ERROR, "%{public}s called with null handle, backtrace limit exceeded", buf, 0xCu);
    }
  }
  if (v2) {
    free(v2);
  }
  return 0;
}

void nw_protocol_tcp_error(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v4 = nw_protocol_downcast();
    if (v4)
    {
      uint64_t v5 = v4;
      if ((*(unsigned char *)(v4 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
      {
        uint64_t v7 = __nwlog_tcp_log();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 136446722;
          uint64_t v11 = "nw_protocol_tcp_error";
          __int16 v12 = 2082;
          uint64_t v13 = v5 + 604;
          __int16 v14 = 1024;
          int v15 = a3;
          _os_log_impl(&dword_214653000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called with error: %d", buf, 0x1Cu);
        }
      }
      nw_protocol_get_input_handler();
      nw_protocol_error_quiet();
      return;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v11 = "nw_protocol_tcp_error";
    uint64_t v6 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v11 = "nw_protocol_tcp_error";
        __int16 v9 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v11 = "nw_protocol_tcp_error";
    uint64_t v6 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v11 = "nw_protocol_tcp_error";
        __int16 v9 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_17:
        _os_log_impl(&dword_214653000, v8, OS_LOG_TYPE_ERROR, v9, buf, 0xCu);
      }
    }
  }
  if (v6) {
    free(v6);
  }
}

void nw_protocol_tcp_output_finished(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v1 = nw_protocol_downcast();
    if (v1)
    {
      uint64_t v2 = v1;
      if (*(_DWORD *)(v1 + 5224) == 2)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          uint64_t v4 = __nwlog_obj();
          if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 136446210;
            __int16 v9 = "nw_protocol_tcp_output_finished";
            _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_DEBUG, "%{public}s ", buf, 0xCu);
          }
        }
        (*(void (**)(uint64_t))(*(void *)(*(void *)(v2 + 8) + 40) + 80))(v2);
      }
      else if ((*(unsigned char *)(v1 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          uint64_t v5 = __nwlog_tcp_log();
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 136446466;
            __int16 v9 = "nw_protocol_tcp_output_finished";
            __int16 v10 = 2082;
            uint64_t v11 = v2 + 604;
            _os_log_impl(&dword_214653000, v5, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
          }
        }
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    __int16 v9 = "nw_protocol_tcp_output_finished";
    unsigned int v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v6 = __nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v9 = "nw_protocol_tcp_output_finished";
        uint64_t v7 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    __int16 v9 = "nw_protocol_tcp_output_finished";
    unsigned int v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v6 = __nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v9 = "nw_protocol_tcp_output_finished";
        uint64_t v7 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_21:
        _os_log_impl(&dword_214653000, v6, OS_LOG_TYPE_ERROR, v7, buf, 0xCu);
      }
    }
  }
  if (v3) {
    free(v3);
  }
}

uint64_t nw_protocol_tcp_reset(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v11 = "nw_protocol_tcp_reset";
    uint64_t v7 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_21;
    }
    uint64_t v8 = __nwlog_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v11 = "nw_protocol_tcp_reset";
    __int16 v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_20;
  }
  uint64_t v3 = nw_protocol_downcast();
  if (v3)
  {
    uint64_t v4 = v3;
    if ((*(_DWORD *)(v3 + 5224) - 1) <= 1)
    {
      *(_DWORD *)(v3 + 5308) |= 2u;
      *(_DWORD *)(v3 + 5224) = 3;
      if ((*(unsigned char *)(v3 + 828) & 2) == 0)
      {
        uint64_t v5 = __nwlog_tcp_log();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v11 = "nw_protocol_tcp_reset";
          __int16 v12 = 2082;
          uint64_t v13 = v4 + 604;
          _os_log_impl(&dword_214653000, v5, OS_LOG_TYPE_INFO, "%{public}s %{public}s force closing tcp", buf, 0x16u);
        }
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 8) + 16))(v4, 1, v1);
      if ((~*(unsigned __int16 *)(v4 + 376) & 0x30) != 0 || (*(unsigned char *)(v4 + 365) & 0x20) != 0)
      {
        *(_DWORD *)(v4 + 16) = 0;
        *(_DWORD *)(v4 + 372) |= 0x80u;
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 8) + 24))(v4, 1, v1);
      tcp_close_locked(v4);
    }
    *(_DWORD *)(v4 + 5308) &= 0xFFFFFFDD;
    *(_DWORD *)(v4 + 5224) = 0;
    bzero((void *)v4, 0x1440uLL);
    nw_protocol_tcp_initialize(a1);
    return 1;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v11 = "nw_protocol_tcp_reset";
  uint64_t v7 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    uint64_t v8 = __nwlog_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v11 = "nw_protocol_tcp_reset";
      __int16 v9 = "%{public}s called with null tcp, backtrace limit exceeded";
LABEL_20:
      _os_log_impl(&dword_214653000, v8, OS_LOG_TYPE_ERROR, v9, buf, 0xCu);
    }
  }
LABEL_21:
  if (v7) {
    free(v7);
  }
  return 0;
}

BOOL nw_protocol_tcp_initialize_inbound(uint64_t a1, nw_endpoint_t endpoint)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v4 = a1 + 832;
  address = nw_endpoint_get_address(endpoint);
  int sa_family = address->sa_family;
  if (sa_family == 2)
  {
    *(_DWORD *)(a1 + 1308) = *(_DWORD *)&address->sa_data[2];
    *(_WORD *)(a1 + 3056) = *(_WORD *)address->sa_data;
    *(_DWORD *)(a1 + 3084) = 1;
    uint64_t v7 = tcp_rtlookup(v4, 0);
    if (v7) {
      goto LABEL_4;
    }
    goto LABEL_10;
  }
  if (sa_family != 30)
  {
    __int16 v10 = __nwlog_obj();
    BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_initialize_inbound";
    __int16 v12 = "%{public}s Invalid address family";
    goto LABEL_14;
  }
  *(sockaddr *)(a1 + 1296) = *(sockaddr *)&address->sa_data[6];
  *(_WORD *)(a1 + 3056) = *(_WORD *)address->sa_data;
  *(_DWORD *)(a1 + 3084) = 1;
  uint64_t v7 = tcp_rtlookup6(v4, 0);
  if (!v7)
  {
LABEL_10:
    __int16 v10 = __nwlog_obj();
    BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_initialize_inbound";
    __int16 v12 = "%{public}s tcp_rtlookup[6] failed";
LABEL_14:
    _os_log_impl(&dword_214653000, v10, OS_LOG_TYPE_ERROR, v12, buf, 0xCu);
    return 0;
  }
LABEL_4:
  *(void *)(a1 + 1280) = *(void *)(v7 + 216);
  *(_DWORD *)(v7 + 1480) |= 0x2000000u;
  nw_protocol_upcast();
  nw_protocol_get_input_handler();
  if (nw_protocol_get_parameters())
  {
    uint64_t v8 = (void *)nw_parameters_copy_protocol_options_legacy();
    int connection_timeout = nw_tcp_options_get_connection_timeout();
    if (connection_timeout)
    {
      *(void *)long long buf = 0x600000001;
      *(void *)&buf[8] = 32;
      *(void *)&buf[16] = &connection_timeout;
      uint64_t v17 = 4;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16))(a1, 1, v2);
      if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(unsigned char *)(a1 + 365) & 0x20) != 0) {
        int v9 = tcp_ctloutput(a1, (uint64_t)buf);
      }
      else {
        int v9 = 22;
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v2);
      if (v9)
      {
        __nwlog_obj();
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_initialize_inbound";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v9;
        uint64_t v13 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          uint64_t v14 = __nwlog_obj();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_initialize_inbound";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v9;
            _os_log_impl(&dword_214653000, v14, OS_LOG_TYPE_ERROR, "%{public}s tcp_setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
          }
        }
        if (v13) {
          free(v13);
        }
      }
    }
    if (v8) {
      nw_release(v8);
    }
  }
  return 1;
}

void nw_proto_tcp_tfo_update_cache(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      uint64_t v2 = *(void *)(a1 + 40);
      if (v2)
      {
        if ((*(unsigned char *)(a2 + 17) & 9) != 0 || !*(unsigned char *)(a2 + 16)) {
          unsigned int v3 = *(_DWORD *)(v2 + 5308) | 0x10000;
        }
        else {
          unsigned int v3 = *(_DWORD *)(v2 + 5308) & 0xFFFEFFFF;
        }
        *(_DWORD *)(v2 + 5308) = v3;
        if (*(void *)(v2 + 5208) && *(void *)(v2 + 5216))
        {
          MEMORY[0x270EF88B8]();
        }
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v8 = "nw_proto_tcp_tfo_update_cache";
    uint64_t v4 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v5 = __nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v8 = "nw_proto_tcp_tfo_update_cache";
        uint64_t v6 = "%{public}s called with null tfo_cache_buffer, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v8 = "nw_proto_tcp_tfo_update_cache";
    uint64_t v4 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v5 = __nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v8 = "nw_proto_tcp_tfo_update_cache";
        uint64_t v6 = "%{public}s called with null so, backtrace limit exceeded";
LABEL_21:
        _os_log_impl(&dword_214653000, v5, OS_LOG_TYPE_ERROR, v6, buf, 0xCu);
      }
    }
  }
  if (v4) {
    free(v4);
  }
}

uint64_t nw_proto_tcp_tfo_cookie_len(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v6 = "nw_proto_tcp_tfo_cookie_len";
    uint64_t v2 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      unsigned int v3 = __nwlog_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v6 = "nw_proto_tcp_tfo_cookie_len";
        _os_log_impl(&dword_214653000, v3, OS_LOG_TYPE_ERROR, "%{public}s called with null so, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v2) {
      free(v2);
    }
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 40);
  if (!v1 || !*(void *)(v1 + 5208) || !*(void *)(v1 + 5216)) {
    return 0;
  }

  return MEMORY[0x270EF88A8]();
}

uint64_t nw_proto_tcp_tfo_get_cookie(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v9 = "nw_proto_tcp_tfo_get_cookie";
    uint64_t v4 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_23;
    }
    uint64_t v5 = __nwlog_obj();
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v9 = "nw_proto_tcp_tfo_get_cookie";
    uint64_t v6 = "%{public}s called with null so, backtrace limit exceeded";
LABEL_22:
    _os_log_impl(&dword_214653000, v5, OS_LOG_TYPE_ERROR, v6, buf, 0xCu);
    goto LABEL_23;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v9 = "nw_proto_tcp_tfo_get_cookie";
    uint64_t v4 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_23;
    }
    uint64_t v5 = __nwlog_obj();
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v9 = "nw_proto_tcp_tfo_get_cookie";
    uint64_t v6 = "%{public}s called with null cookie, backtrace limit exceeded";
    goto LABEL_22;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v9 = "nw_proto_tcp_tfo_get_cookie";
    uint64_t v4 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v5 = __nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v9 = "nw_proto_tcp_tfo_get_cookie";
        uint64_t v6 = "%{public}s called with null len, backtrace limit exceeded";
        goto LABEL_22;
      }
    }
LABEL_23:
    if (v4) {
      free(v4);
    }
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 40);
  if (!v3 || !*(void *)(v3 + 5208) || !*(void *)(v3 + 5216)) {
    return 0;
  }

  return MEMORY[0x270EF88A0]();
}

uint64_t nw_proto_tcp_tfo_enabled(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 40);
    if (v1 && *(void *)(v1 + 5208) && *(void *)(v1 + 5216)) {
      return nw_path_flow_registration_fast_open_blocked() ^ 1;
    }
    else {
      return 1;
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v6 = "nw_proto_tcp_tfo_enabled";
    uint64_t v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v6 = "nw_proto_tcp_tfo_enabled";
        _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_ERROR, "%{public}s called with null so, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v3) {
      free(v3);
    }
    return 0;
  }
}

uint64_t nw_protocol_tcp_signal_error(uint64_t a1, int a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if ((*(unsigned char *)(a1 + 828) & 2) == 0)
  {
    uint64_t v4 = __nwlog_tcp_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 136446722;
      uint64_t v7 = "nw_protocol_tcp_signal_error";
      __int16 v8 = 2082;
      uint64_t v9 = a1 + 604;
      __int16 v10 = 1024;
      int v11 = a2;
      _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_INFO, "%{public}s %{public}s tcp signal error: %d", buf, 0x1Cu);
    }
  }
  nw_protocol_upcast();
  nw_protocol_retain();
  return nw_queue_context_async();
}

uint64_t __nw_protocol_tcp_signal_error_block_invoke(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if ((*(unsigned char *)(*(void *)(a1 + 32) + 5308) & 2) != 0)
  {
    uint64_t v1 = *(void *)(a1 + 40);
    if (!v1 || (*(unsigned char *)(v1 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v3 = __nwlog_tcp_log();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v4 = "";
          if (v1) {
            uint64_t v4 = (const char *)(v1 + 604);
          }
          int v5 = 136446466;
          uint64_t v6 = "nw_protocol_tcp_signal_error_block_invoke";
          __int16 v7 = 2082;
          __int16 v8 = v4;
          _os_log_impl(&dword_214653000, v3, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v5, 0x16u);
        }
      }
    }
  }
  else
  {
    nw_protocol_get_input_handler();
    nw_protocol_error_quiet();
  }
  return nw_protocol_release();
}

void nw_protocol_tcp_wake_keepalive(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_DWORD *)(v2 + 5224) <= 2u && (*(unsigned char *)(v2 + 5309) & 1) != 0)
  {
    nw_protocol_upcast();
    nw_protocol_retain();
    nw_queue_context_async();
  }
  else if ((*(unsigned char *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
  {
    uint64_t v3 = __nwlog_tcp_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 136446466;
      int v5 = "nw_protocol_tcp_wake_keepalive";
      __int16 v6 = 2082;
      uint64_t v7 = a1 + 604;
      _os_log_impl(&dword_214653000, v3, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
    }
  }
}

uint64_t __nw_protocol_tcp_wake_keepalive_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2 || (*(unsigned char *)(v2 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      uint64_t v7 = __nwlog_tcp_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v8 = "";
        if (v2) {
          uint64_t v8 = (const char *)(v2 + 604);
        }
        int v9 = 136446466;
        __int16 v10 = "nw_protocol_tcp_wake_keepalive_block_invoke";
        __int16 v11 = 2082;
        uint64_t v12 = v8;
        _os_log_impl(&dword_214653000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s keepalive", (uint8_t *)&v9, 0x16u);
      }
    }
  }
  if (*(_DWORD *)(*(void *)(a1 + 40) + 5224) < 3u)
  {
    nw_protocol_get_input_handler();
    nw_protocol_notify_quiet();
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (!v3 || (*(unsigned char *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v4 = __nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          int v5 = "";
          if (v3) {
            int v5 = (const char *)(v3 + 604);
          }
          int v9 = 136446466;
          __int16 v10 = "nw_protocol_tcp_wake_keepalive_block_invoke";
          __int16 v11 = 2082;
          uint64_t v12 = v5;
          _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v9, 0x16u);
        }
      }
    }
  }
  return nw_protocol_release();
}

void nw_protocol_tcp_wake_write_timeout(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_DWORD *)(v2 + 5224) <= 2u && (int v3 = *(_DWORD *)(v2 + 5308), (v3 & 0x80) != 0))
  {
    *(_DWORD *)(v2 + 5308) = v3 | 0x80000;
    nw_protocol_upcast();
    nw_protocol_retain();
    nw_queue_context_async();
  }
  else if ((*(unsigned char *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
  {
    uint64_t v4 = __nwlog_tcp_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 136446466;
      __int16 v6 = "nw_protocol_tcp_wake_write_timeout";
      __int16 v7 = 2082;
      uint64_t v8 = a1 + 604;
      _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
    }
  }
}

uint64_t __nw_protocol_tcp_wake_write_timeout_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2 || (*(unsigned char *)(v2 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      __int16 v7 = __nwlog_tcp_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v8 = "";
        if (v2) {
          uint64_t v8 = (const char *)(v2 + 604);
        }
        int v9 = 136446466;
        __int16 v10 = "nw_protocol_tcp_wake_write_timeout_block_invoke";
        __int16 v11 = 2082;
        uint64_t v12 = v8;
        _os_log_impl(&dword_214653000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s write timeout", (uint8_t *)&v9, 0x16u);
      }
    }
  }
  if (*(_DWORD *)(*(void *)(a1 + 40) + 5224) < 3u)
  {
    nw_protocol_get_input_handler();
    nw_protocol_notify_quiet();
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (!v3 || (*(unsigned char *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v4 = __nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          int v5 = "";
          if (v3) {
            int v5 = (const char *)(v3 + 604);
          }
          int v9 = 136446466;
          __int16 v10 = "nw_protocol_tcp_wake_write_timeout_block_invoke";
          __int16 v11 = 2082;
          uint64_t v12 = v5;
          _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v9, 0x16u);
        }
      }
    }
  }
  return nw_protocol_release();
}

void nw_protocol_tcp_wake_read_timeout(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_DWORD *)(v2 + 5224) <= 2u && (int v3 = *(_DWORD *)(v2 + 5308), (v3 & 0x40) != 0))
  {
    *(_DWORD *)(v2 + 5308) = v3 | 0x100000;
    nw_protocol_upcast();
    nw_protocol_retain();
    nw_queue_context_async();
  }
  else if ((*(unsigned char *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
  {
    uint64_t v4 = __nwlog_tcp_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 136446466;
      __int16 v6 = "nw_protocol_tcp_wake_read_timeout";
      __int16 v7 = 2082;
      uint64_t v8 = a1 + 604;
      _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
    }
  }
}

uint64_t __nw_protocol_tcp_wake_read_timeout_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2 || (*(unsigned char *)(v2 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      __int16 v7 = __nwlog_tcp_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v8 = "";
        if (v2) {
          uint64_t v8 = (const char *)(v2 + 604);
        }
        int v9 = 136446466;
        __int16 v10 = "nw_protocol_tcp_wake_read_timeout_block_invoke";
        __int16 v11 = 2082;
        uint64_t v12 = v8;
        _os_log_impl(&dword_214653000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s read timeout", (uint8_t *)&v9, 0x16u);
      }
    }
  }
  if (*(_DWORD *)(*(void *)(a1 + 40) + 5224) < 3u)
  {
    nw_protocol_get_input_handler();
    nw_protocol_notify_quiet();
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (!v3 || (*(unsigned char *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v4 = __nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          int v5 = "";
          if (v3) {
            int v5 = (const char *)(v3 + 604);
          }
          int v9 = 136446466;
          __int16 v10 = "nw_protocol_tcp_wake_read_timeout_block_invoke";
          __int16 v11 = 2082;
          uint64_t v12 = v5;
          _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v9, 0x16u);
        }
      }
    }
  }
  return nw_protocol_release();
}

uint64_t ____nw_signpost_is_enabled_block_invoke()
{
  uint64_t result = networkd_settings_get_BOOL();
  *MEMORY[0x263F144A8] = result;
  return result;
}

void nw_protocol_tcp_link_state(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v46 = "nw_protocol_tcp_link_state";
    uint64_t v18 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_57;
    }
    __int16 v23 = __nwlog_obj();
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_57;
    }
    *(_DWORD *)long long buf = 136446210;
    BOOL v46 = "nw_protocol_tcp_link_state";
    uint64_t v24 = "%{public}s called with null link_info, backtrace limit exceeded";
LABEL_56:
    _os_log_impl(&dword_214653000, v23, OS_LOG_TYPE_ERROR, v24, buf, 0xCu);
    goto LABEL_57;
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v46 = "nw_protocol_tcp_link_state";
    uint64_t v18 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_57;
    }
    __int16 v23 = __nwlog_obj();
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_57;
    }
    *(_DWORD *)long long buf = 136446210;
    BOOL v46 = "nw_protocol_tcp_link_state";
    uint64_t v24 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_56;
  }
  uint64_t v4 = nw_protocol_downcast();
  if (!v4)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v46 = "nw_protocol_tcp_link_state";
    uint64_t v18 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      __int16 v23 = __nwlog_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v46 = "nw_protocol_tcp_link_state";
        uint64_t v24 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_56;
      }
    }
LABEL_57:
    if (v18) {
      free(v18);
    }
    return;
  }
  uint64_t v5 = v4;
  if (*(_DWORD *)(v4 + 5224) == 2)
  {
    uint64_t v6 = *(void *)v4;
    int flow_control_status = nw_link_get_flow_control_status();
    if (flow_control_status == 1)
    {
      uint64_t v13 = *(void *)(*(void *)v5 + 240);
      uint64_t v14 = *(void *)(v13 + 80);
      while (1)
      {
        int v15 = *(_DWORD *)(v14 + 456);
        if ((_WORD)v15 == 0xFFFF) {
          break;
        }
        int v16 = *(_DWORD *)(v14 + 456);
        atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(v14 + 456), (unsigned int *)&v16, v15 + 1, memory_order_relaxed, memory_order_relaxed);
        if (v16 == v15)
        {
          if ((*(_WORD *)(v13 + 90) & 0x820) == 0
            && *(_DWORD *)(v13 + 12) == 4
            && *(_DWORD *)(v13 + 96) - *(_DWORD *)(v13 + 92) >= 1)
          {
            int v17 = *(_DWORD *)(v14 + 2228);
            *(_DWORD *)(v14 + 2228) = v17 & 0xAFFFFFFF | 0x40000000;
            if ((v17 & 0x50000000) == 0)
            {
              if (*(_DWORD *)(sysctls + 292))
              {
                int v41 = *(void (**)(void))(tcp_cc_algo_list[*(unsigned __int8 *)(*(void *)(v14 + 240) + 264)] + 64);
                if (v41) {
                  v41();
                }
              }
            }
          }
          in_pcb_checkstate(v14, 2, 0);
          return;
        }
      }
    }
    else if (!flow_control_status)
    {
      uint64_t v8 = *(void *)(v6 + 224);
      do
      {
        int v9 = *(_DWORD *)(v6 + 456);
        if ((_WORD)v9 == 0xFFFF)
        {
          __nwlog_obj();
          *(_DWORD *)long long buf = 136446210;
          BOOL v46 = "inp_fc_feedback";
          uint64_t v18 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            __int16 v23 = __nwlog_obj();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 136446210;
              BOOL v46 = "inp_fc_feedback";
              uint64_t v24 = "%{public}s failed to acquire inpcb reference, backtrace limit exceeded";
              goto LABEL_56;
            }
          }
          goto LABEL_57;
        }
        int v10 = *(_DWORD *)(v6 + 456);
        atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(v6 + 456), (unsigned int *)&v10, v9 + 1, memory_order_relaxed, memory_order_relaxed);
      }
      while (v10 != v9);
      if (v8)
      {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v8 + 8) + 16))(v8, 1, v3);
        goto LABEL_12;
      }
      uint64_t v43 = __nwlog_obj();
      os_log_type_enabled(v43, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long buf = 136446210;
      BOOL v46 = "inp_fc_feedback";
      int v44 = (void *)_os_log_send_and_compose_impl();
      if (!__nwlog_abort())
      {
        free(v44);
        (*(void (**)(void, uint64_t, uint64_t))(MEMORY[8] + 16))(0, 1, v3);
LABEL_12:
        if (in_pcb_checkstate(v6, 2, 1) == 0xFFFF)
        {
          __nwlog_obj();
          *(_DWORD *)long long buf = 136446210;
          BOOL v46 = "inp_fc_feedback";
          uint64_t v12 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            unsigned int v40 = __nwlog_obj();
            if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 136446210;
              BOOL v46 = "inp_fc_feedback";
              _os_log_impl(&dword_214653000, v40, OS_LOG_TYPE_ERROR, "%{public}s failed to release inpcb reference, backtrace limit exceeded", buf, 0xCu);
            }
          }
          if (v12) {
            free(v12);
          }
          goto LABEL_77;
        }
        int v19 = *(_DWORD *)(v6 + 2228);
        if ((v19 & 0x50000000) == 0)
        {
LABEL_77:
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v8 + 8) + 24))(v8, 1, v3);
          return;
        }
        uint64_t v20 = *(void *)(v6 + 224);
        if ((v19 & 0x10000000) != 0)
        {
          *(_DWORD *)(v6 + 2228) = v19 & 0xAFFFFFFF;
          os_log_type_t v22 = (unsigned int *)(v20 + 364);
          int v21 = *(_DWORD *)(v20 + 364);
LABEL_37:
          *os_log_type_t v22 = v21 & 0xFFFDFFFF;
        }
        else
        {
          int v21 = *(_DWORD *)(v20 + 364);
          *(_DWORD *)(v6 + 2228) = v19 & 0xAFFFFFFF;
          if ((v21 & 0x20000) != 0)
          {
            os_log_type_t v22 = (unsigned int *)(v20 + 364);
            goto LABEL_37;
          }
        }
        uint64_t v25 = *(void (***)(uint64_t, uint64_t))(v20 + 32);
        if (v25)
        {
          uint64_t v26 = *v25;
          if (v26) {
            v26(v20, v11);
          }
        }
        uint64_t v27 = *(void *)(v6 + 240);
        uint64_t v28 = *(void *)(v6 + 448);
        uint64_t v29 = tcp_cc_algo_list[*(unsigned __int8 *)(v27 + 264)];
        if (*(_DWORD *)(sysctls + 292))
        {
          int v30 = *(void (**)(void, void))(v29 + 72);
          if (v30) {
            v30(*(void *)(v6 + 240), 0);
          }
          *(_DWORD *)(v27 + 288) = 0;
          if (*(_WORD *)(v27 + 226)
            && v28
            && (*(unsigned __int8 *)(v28 + 1076) == 255 || *(_DWORD *)(v28 + 1024) == 255))
          {
            uint64_t v31 = *(void *)(v6 + 224);
            if (!v31 || (*(unsigned char *)(v31 + 828) & 2) == 0)
            {
              uint64_t v32 = __nwlog_tcp_log();
              if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
              {
                uint64_t v33 = (const char *)(v31 + 604);
                int v34 = *(unsigned __int16 *)(v27 + 226);
                BOOL v46 = "inp_fc_unthrottle_tcp";
                *(_DWORD *)long long buf = 136446722;
                if (!v31) {
                  uint64_t v33 = "";
                }
                __int16 v47 = 2082;
                unsigned int v48 = v33;
                __int16 v49 = 1024;
                int v50 = v34;
                _os_log_impl(&dword_214653000, v32, OS_LOG_TYPE_INFO, "%{public}s %{public}s inp_fc_unthrottle_tcp keep rxmit state t_rxtshift %d", buf, 0x1Cu);
              }
            }
          }
          else
          {
            *(_WORD *)(v27 + 226) = 0;
            *(_DWORD *)(v27 + 248) = 0;
          }
          *(_DWORD *)(v27 + 740) &= ~0x100000u;
        }
        else
        {
          unsigned int v35 = *(void (**)(void))(v29 + 64);
          if (v35) {
            v35(*(void *)(v6 + 240));
          }
          *(_DWORD *)(v27 + 144) = *(_DWORD *)(v27 + 148);
          *(_DWORD *)(v27 + 740) &= ~0x100000u;
          *(_DWORD *)(v27 + 288) = 0;
          if (*(_WORD *)(v27 + 226)
            && v28
            && (*(unsigned __int8 *)(v28 + 1076) == 255 || *(_DWORD *)(v28 + 1024) == 255))
          {
            uint64_t v36 = *(void *)(v6 + 224);
            if (!v36 || (*(unsigned char *)(v36 + 828) & 2) == 0)
            {
              unsigned int v37 = __nwlog_tcp_log();
              if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
              {
                unsigned int v38 = (const char *)(v36 + 604);
                int v39 = *(unsigned __int16 *)(v27 + 226);
                BOOL v46 = "inp_fc_unthrottle_tcp";
                *(_DWORD *)long long buf = 136446722;
                if (!v36) {
                  unsigned int v38 = "";
                }
                __int16 v47 = 2082;
                unsigned int v48 = v38;
                __int16 v49 = 1024;
                int v50 = v39;
                _os_log_impl(&dword_214653000, v37, OS_LOG_TYPE_INFO, "%{public}s %{public}s inp_fc_unthrottle_tcp keep rxmit state t_rxtshift %d", buf, 0x1Cu);
              }
            }
          }
          else
          {
            *(_WORD *)(v27 + 226) = 0;
            *(_DWORD *)(v27 + 248) = 0;
          }
        }
        tcp_output(v27);
        goto LABEL_77;
      }
      __break(1u);
    }
  }
  else if ((*(unsigned char *)(v4 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      int v42 = __nwlog_tcp_log();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 136446466;
        BOOL v46 = "nw_protocol_tcp_link_state";
        __int16 v47 = 2082;
        unsigned int v48 = (const char *)(v5 + 604);
        _os_log_impl(&dword_214653000, v42, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
      }
    }
  }
}

void nw_protocol_tcp_output_available(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v1 = nw_protocol_downcast();
    if (v1)
    {
      uint64_t v2 = v1;
      if ((*(_DWORD *)(v1 + 5224) | 4) == 4 || (*(unsigned char *)(v1 + 5308) & 0x20) != 0)
      {
        if ((*(unsigned char *)(v1 + 828) & 2) == 0)
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            uint64_t v4 = __nwlog_tcp_log();
            if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 136446466;
              int v9 = "nw_protocol_tcp_output_available";
              __int16 v10 = 2082;
              uint64_t v11 = v2 + 604;
              _os_log_impl(&dword_214653000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
            }
          }
        }
      }
      else if (*(_DWORD *)(*(void *)v1 + 460))
      {
        if ((*(unsigned char *)(v1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
        {
          __int16 v7 = __nwlog_tcp_log();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 136446466;
            int v9 = "nw_protocol_tcp_output_available";
            __int16 v10 = 2082;
            uint64_t v11 = v2 + 604;
            _os_log_impl(&dword_214653000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s restarting TCP output on output available", buf, 0x16u);
          }
        }
        tcp_output(*(void *)(*(void *)v2 + 240));
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v9 = "nw_protocol_tcp_output_available";
    uint64_t v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v5 = __nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        int v9 = "nw_protocol_tcp_output_available";
        uint64_t v6 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_22;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v9 = "nw_protocol_tcp_output_available";
    uint64_t v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v5 = __nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        int v9 = "nw_protocol_tcp_output_available";
        uint64_t v6 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_22:
        _os_log_impl(&dword_214653000, v5, OS_LOG_TYPE_ERROR, v6, buf, 0xCu);
      }
    }
  }
  if (v3) {
    free(v3);
  }
}

uint64_t nw_protocol_tcp_replace_input_handler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v16 = "nw_protocol_tcp_replace_input_handler";
    uint64_t v12 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_38;
    }
    uint64_t v13 = __nwlog_obj();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_38;
    }
    *(_DWORD *)long long buf = 136446210;
    int v16 = "nw_protocol_tcp_replace_input_handler";
    uint64_t v14 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_37;
  }
  uint64_t v5 = nw_protocol_downcast();
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v16 = "nw_protocol_tcp_replace_input_handler";
    uint64_t v12 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_38;
    }
    uint64_t v13 = __nwlog_obj();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_38;
    }
    *(_DWORD *)long long buf = 136446210;
    int v16 = "nw_protocol_tcp_replace_input_handler";
    uint64_t v14 = "%{public}s called with null tcp, backtrace limit exceeded";
    goto LABEL_37;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v16 = "nw_protocol_tcp_replace_input_handler";
    uint64_t v12 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_38;
    }
    uint64_t v13 = __nwlog_obj();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_38;
    }
    *(_DWORD *)long long buf = 136446210;
    int v16 = "nw_protocol_tcp_replace_input_handler";
    uint64_t v14 = "%{public}s called with null old_input_handler, backtrace limit exceeded";
    goto LABEL_37;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v16 = "nw_protocol_tcp_replace_input_handler";
    uint64_t v12 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault()) {
      goto LABEL_38;
    }
    uint64_t v13 = __nwlog_obj();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_38;
    }
    *(_DWORD *)long long buf = 136446210;
    int v16 = "nw_protocol_tcp_replace_input_handler";
    uint64_t v14 = "%{public}s called with null new_input_handler, backtrace limit exceeded";
LABEL_37:
    _os_log_impl(&dword_214653000, v13, OS_LOG_TYPE_ERROR, v14, buf, 0xCu);
LABEL_38:
    if (!v12) {
      return 0;
    }
    uint64_t v11 = (void *)v12;
LABEL_19:
    free(v11);
    return 0;
  }
  uint64_t v6 = v5;
  if (nw_protocol_get_input_handler() != a2)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446722;
    int v16 = "nw_protocol_tcp_replace_input_handler";
    __int16 v17 = 2048;
    uint64_t input_handler = nw_protocol_get_input_handler();
    __int16 v19 = 2048;
    uint64_t v20 = a2;
    uint64_t v7 = _os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      __int16 v10 = __nwlog_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446722;
        int v16 = "nw_protocol_tcp_replace_input_handler";
        __int16 v17 = 2048;
        uint64_t input_handler = nw_protocol_get_input_handler();
        __int16 v19 = 2048;
        uint64_t v20 = a2;
        _os_log_impl(&dword_214653000, v10, OS_LOG_TYPE_ERROR, "%{public}s Old input handler does not match (%p != %p), backtrace limit exceeded", buf, 0x20u);
      }
    }
    if (!v7) {
      return 0;
    }
    uint64_t v11 = (void *)v7;
    goto LABEL_19;
  }
  nw_protocol_set_input_handler();
  if (!nw_protocol_get_output_handler()) {
    nw_protocol_set_output_handler();
  }
  if (nw_protocol_supports_external_data_is_valid() && nw_protocol_supports_external_data()) {
    unsigned int v8 = *(_DWORD *)(v6 + 5308) | 0x1000;
  }
  else {
    unsigned int v8 = *(_DWORD *)(v6 + 5308) & 0xFFFFEFFF;
  }
  *(_DWORD *)(v6 + 5308) = v8;
  return 1;
}

void tcp_tfo_gen_cookie(uint64_t a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  char v3 = *(unsigned char *)(a1 + 2236);
  *(void *)((char *)&dataIn + 4) = 0;
  HIDWORD(dataIn) = 0;
  *a2 = 0;
  a2[1] = 0;
  if ((v3 & 2) != 0) {
    long long dataIn = *(_OWORD *)(a1 + 464);
  }
  else {
    LODWORD(dataIn) = *(_DWORD *)(a1 + 476);
  }
  uint64_t v4 = nw_tcp_access_globals(*(void *)(a1 + 224));
  size_t dataOutMoved = 0;
  if (CCCryptorUpdate(*(CCCryptorRef *)(v4 + 80), &dataIn, 0x10uLL, a2, 0x10uLL, &dataOutMoved))
  {
    uint64_t v5 = __nwlog_obj();
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v13 = "aes_encrypt_cbc";
    uint64_t v6 = "%{public}s CCCryptorUpdate";
    uint64_t v7 = v5;
    uint32_t v8 = 12;
    goto LABEL_10;
  }
  if (dataOutMoved != 16)
  {
    int v9 = __nwlog_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446466;
      uint64_t v13 = "aes_encrypt_cbc";
      __int16 v14 = 2048;
      size_t v15 = dataOutMoved;
      uint64_t v6 = "%{public}s out_moved is %lu";
      uint64_t v7 = v9;
      uint32_t v8 = 22;
LABEL_10:
      _os_log_impl(&dword_214653000, v7, OS_LOG_TYPE_ERROR, v6, buf, v8);
    }
  }
}

uint64_t ____nw_signpost_is_enabled_block_invoke_87()
{
  uint64_t result = networkd_settings_get_BOOL();
  *MEMORY[0x263F144A8] = result;
  return result;
}

void tcp_drop(uint64_t a1, int a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(*(void *)(a1 + 80) + 224);
  if (*(int *)(a1 + 12) < 3)
  {
    uint64_t v8 = *(void *)(a1 + 1056);
    if (!v8) {
      goto LABEL_13;
    }
    uint64_t v7 = (void *)(v8 + 456);
    goto LABEL_12;
  }
  *(_DWORD *)(a1 + 12) = 0;
  if (!v4 || (*(unsigned char *)(v4 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      __int16 v10 = __nwlog_tcp_log();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v11 = tcpstates[*(int *)(a1 + 12)];
        __int16 v14 = "tcp_drop";
        uint64_t v12 = "";
        int v13 = 136446722;
        if (v4) {
          uint64_t v12 = (const char *)(v4 + 604);
        }
        __int16 v15 = 2082;
        uint64_t v16 = v12;
        __int16 v17 = 2082;
        uint64_t v18 = v11;
        _os_log_impl(&dword_214653000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state change to %{public}s", (uint8_t *)&v13, 0x20u);
      }
    }
  }
  if (*(void *)(v4 + 24))
  {
    uint64_t all_stats = nw_protocol_tcp_get_all_stats();
    if (all_stats) {
      *(_DWORD *)(all_stats + 136) = 0;
    }
  }
  tcp_output(a1);
  uint64_t v6 = *(void *)(a1 + 1056);
  if (v6)
  {
    uint64_t v7 = (void *)(v6 + 424);
LABEL_12:
    ++*v7;
  }
LABEL_13:
  if (a2 == 60)
  {
    int v9 = *(_DWORD *)(a1 + 256);
    if (!v9) {
      LOWORD(v9) = 60;
    }
    *(_WORD *)(v4 + 378) = v9;
    goto LABEL_18;
  }
  *(_WORD *)(v4 + 378) = a2;
  if (a2) {
LABEL_18:
  }
    user_north_signal_error(v4);
  tcp_close(a1);
}

void socket_post_kev_msg_closed()
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v3 = "socket_post_kev_msg_closed";
  uint64_t v0 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    uint64_t v1 = __nwlog_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446210;
      char v3 = "socket_post_kev_msg_closed";
      _os_log_impl(&dword_214653000, v1, OS_LOG_TYPE_ERROR, "%{public}s currently not supported, backtrace limit exceeded", buf, 0xCu);
    }
  }
  if (v0) {
    free(v0);
  }
}

void tcp_rxtseg_clean(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 952);
  if (v2)
  {
    char v3 = (void *)(a1 + 952);
    do
    {
      uint64_t v5 = (void *)*v3;
      uint64_t v6 = (void *)(a1 + 952);
      if ((void *)*v3 != v2)
      {
        do
        {
          uint64_t v7 = v5;
          uint64_t v5 = (void *)v5[2];
        }
        while (v5 != v2);
        uint64_t v6 = v7 + 2;
      }
      uint64_t v4 = (void *)v2[2];
      *uint64_t v6 = v4;
      nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
      free(v2);
      uint64_t v2 = v4;
    }
    while (v4);
  }
  *(_DWORD *)(a1 + 960) = *(_DWORD *)(a1 + 96);
}

uint64_t tcp_next_mtu(int a1, int a2)
{
  if (a1 > 65534)
  {
    if ((a2 & 0x80000000) == 0)
    {
      uint64_t v2 = 0;
      goto LABEL_28;
    }
    return 0;
  }
  if (a1 > 31999)
  {
    BOOL v3 = 0;
    uint64_t v2 = 1;
  }
  else if (a1 > 17913)
  {
    BOOL v3 = 0;
    uint64_t v2 = 2;
  }
  else if (a1 > 8165)
  {
    BOOL v3 = 0;
    uint64_t v2 = 3;
  }
  else if (a1 > 4351)
  {
    BOOL v3 = 0;
    uint64_t v2 = 4;
  }
  else if (a1 > 2001)
  {
    BOOL v3 = 0;
    uint64_t v2 = 5;
  }
  else if (a1 > 1491)
  {
    BOOL v3 = 0;
    uint64_t v2 = 6;
  }
  else if (a1 > 1005)
  {
    BOOL v3 = 0;
    uint64_t v2 = 7;
  }
  else if (a1 > 507)
  {
    BOOL v3 = 0;
    uint64_t v2 = 8;
  }
  else if (a1 > 295)
  {
    BOOL v3 = 0;
    uint64_t v2 = 9;
  }
  else
  {
    BOOL v3 = a1 < 68;
    uint64_t v2 = 10;
    if (a1 < 68) {
      uint64_t v2 = 11;
    }
  }
  if (a2 < 0)
  {
    uint64_t v5 = v2 - 1;
    return tcp_next_mtu_mtutab[v5];
  }
  if (v3) {
    return 0;
  }
LABEL_28:
  if ((int)tcp_next_mtu_mtutab[v2] < a1) {
    return tcp_next_mtu_mtutab[v2];
  }
  uint64_t v5 = v2 + 1;
  return tcp_next_mtu_mtutab[v5];
}

void tcp_handle_msgsize(uint64_t a1, unsigned int a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  if (a1 && (*(_DWORD *)(a1 + 1480) & 0x2000001) == 1)
  {
    uint64_t v2 = *(void *)(a1 + 1488);
    if (!v2 || *(unsigned char *)(v2 + 73)) {
      return;
    }
    unsigned int v3 = a2;
    if (a2) {
      goto LABEL_37;
    }
    int v4 = *(_DWORD *)(v2 + 48);
    if (v4 <= 65534)
    {
      if (v4 > 31999)
      {
        uint64_t v5 = 1;
      }
      else if (v4 > 17913)
      {
        uint64_t v5 = 2;
      }
      else if (v4 > 8165)
      {
        uint64_t v5 = 3;
      }
      else if (v4 > 4351)
      {
        uint64_t v5 = 4;
      }
      else if (v4 > 2001)
      {
        uint64_t v5 = 5;
      }
      else if (v4 > 1491)
      {
        uint64_t v5 = 6;
      }
      else if (v4 > 1005)
      {
        uint64_t v5 = 7;
      }
      else if (v4 > 507)
      {
        uint64_t v5 = 8;
      }
      else if (v4 > 295)
      {
        uint64_t v5 = 9;
      }
      else
      {
        if (v4 < 68)
        {
          unsigned int v3 = 0;
LABEL_37:
          uint64_t v8 = *(int *)(sysctls + 164);
          unint64_t v9 = v8 + 40;
          BOOL v10 = (int)v8 < 256;
          unint64_t v11 = 296;
          if (!v10) {
            unint64_t v11 = v9;
          }
          if (v11 <= v3)
          {
            if (*(_DWORD *)(v2 + 48) > v3)
            {
              *(_DWORD *)(v2 + 48) = v3;
              if (__nwlog_is_datapath_logging_enabled())
              {
                uint64_t v12 = __nwlog_obj();
                if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)long long buf = 136446466;
                  __int16 v14 = "tcp_handle_msgsize";
                  __int16 v15 = 1024;
                  LODWORD(v16) = v3;
                  _os_log_impl(&dword_214653000, v12, OS_LOG_TYPE_DEBUG, "%{public}s MTU reduced to %d\n", buf, 0x12u);
                }
              }
            }
          }
          else
          {
            *(unsigned char *)(v2 + 73) = 1;
          }
          return;
        }
        uint64_t v5 = 10;
      }
    }
    else
    {
      uint64_t v5 = 0;
    }
    unsigned int v3 = tcp_next_mtu_mtutab[v5];
    if ((int)v3 >= v4) {
      unsigned int v3 = tcp_next_mtu_mtutab[v5 + 1];
    }
    goto LABEL_37;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  __int16 v14 = "tcp_handle_msgsize";
  uint64_t v6 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    uint64_t v7 = __nwlog_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446210;
      __int16 v14 = "tcp_handle_msgsize";
      _os_log_impl(&dword_214653000, v7, OS_LOG_TYPE_ERROR, "%{public}s TCP route unusable, backtrace limit exceeded", buf, 0xCu);
    }
  }
  if (v6) {
    free(v6);
  }
}

void tcp_drop_syn_sent(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 240);
  if (v2)
  {
    if (*(_DWORD *)(v2 + 12) == 2) {
      tcp_drop(v2, a2);
    }
  }
}

uint64_t tcp_rtlookup6(uint64_t a1, uint64_t a2)
{
  int v4 = (uint64_t *)(a1 + 496);
  uint64_t v5 = *(void *)(a1 + 496);
  if (v5)
  {
    if ((*(_DWORD *)(v5 + 1480) & 0x2000001) == 1)
    {
LABEL_11:
      uint64_t v7 = *(void *)(a1 + 240);
      if (*(_DWORD *)(sysctls + 80)
        && ((uint64_t v8 = *(void *)(v5 + 1488)) == 0 || (*(unsigned char *)(v5 + 1480) & 1) != 0 && !*(unsigned char *)(v8 + 73)))
      {
        unsigned int v9 = *(_DWORD *)(v7 + 88) | 0x4000000;
      }
      else
      {
        unsigned int v9 = *(_DWORD *)(v7 + 88) & 0xFBFFFFFF;
      }
      *(_DWORD *)(v7 + 88) = v9;
      int v13 = *(_DWORD **)(v5 + 216);
      if (!v13)
      {
LABEL_36:
        if (*(unsigned char *)(v5 + 1484)) {
          *(_DWORD *)(v7 + 88) |= 0x20000u;
        }
        return v5;
      }
      *(_DWORD *)(v7 + 88) = v9 & 0xEFFFFFFF;
      int v14 = v13[262];
      if ((*(unsigned char *)(*(void *)(v7 + 80) + 2236) & 2) != 0)
      {
        if ((v14 & 0x400000) != 0)
        {
          *(_DWORD *)(v7 + 88) = v9 | 0x10000000;
          __int16 v15 = v13 + 265;
          goto LABEL_26;
        }
      }
      else if ((v14 & 0x200000) != 0)
      {
        *(_DWORD *)(v7 + 88) = v9 | 0x10000000;
        __int16 v15 = v13 + 264;
LABEL_26:
        unsigned int v16 = *v15;
        if (v16 >= 0xFFFF) {
          int v17 = 0xFFFF;
        }
        else {
          int v17 = v16;
        }
        if (v16) {
          int v18 = v17;
        }
        else {
          int v18 = 0xFFFF;
        }
        *(_DWORD *)(v7 + 692) = v18;
      }
      tcp_set_ecn(v7);
      os_unfair_lock_lock((os_unfair_lock_t)(v7 + 1864));
      if (!*(void *)(a1 + 448)) {
        *(void *)(a1 + 448) = *(void *)(v5 + 216);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 1864));
      goto LABEL_36;
    }
    if (*(unsigned char *)(v5 + 1496))
    {
      uint64_t v6 = *(void **)(v5 + 1488);
      if (v6)
      {
        free(v6);
        uint64_t v5 = *v4;
        *(void *)(*v4 + 1488) = 0;
      }
      *(unsigned char *)(v5 + 1496) = 0;
    }
  }
  *(_WORD *)(a1 + 2008) = 7708;
  *(_OWORD *)(a1 + 2016) = *(_OWORD *)(a1 + 464);
  if ((*(unsigned char *)(a1 + 2229) & 0x40) != 0) {
    a2 = *(unsigned __int16 *)(*(void *)(a1 + 440) + 1072);
  }
  bzero((void *)(a1 + 504), 0x5E0uLL);
  *(_OWORD *)(a1 + 704) = *(_OWORD *)(a1 + 2008);
  *(void *)(a1 + 720) = a1 + 728;
  *(_OWORD *)(a1 + 1768) = 0u;
  *(_DWORD *)(a1 + 1784) = 0;
  *(_WORD *)(a1 + 1800) = 1;
  *(unsigned char *)(a1 + 1804) = 6;
  *(void *)(a1 + 1960) = a1 + 1968;
  *(unsigned char *)(a1 + 1969) = 2;
  *(_DWORD *)(a1 + 1984) = 1;
  *(void *)(a1 + 496) = a1 + 504;
  if (((**(uint64_t (***)(uint64_t *, uint64_t, uint64_t))(a1 + 2136))(v4, a1 + 504, a2) & 0x80000000) != 0)
  {
    *int v4 = 0;
  }
  else
  {
    uint64_t v5 = *v4;
    if (*v4) {
      goto LABEL_11;
    }
  }
  uint64_t v10 = *(void *)(a1 + 240);
  int v11 = *(_DWORD *)(v10 + 88);
  uint64_t v5 = 0;
  if (*(_DWORD *)(sysctls + 80)) {
    unsigned int v12 = v11 | 0x4000000;
  }
  else {
    unsigned int v12 = v11 & 0xFBFFFFFF;
  }
  *(_DWORD *)(v10 + 88) = v12;
  return v5;
}

void tcp_notify(uint64_t a1, int a2)
{
  if (a1 && *(_DWORD *)(a1 + 232) != 3)
  {
    uint64_t v4 = *(void *)(a1 + 240);
    if (!v4)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
      uint64_t v7 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort())
      {
        __break(1u);
        return;
      }
      free(v7);
    }
    int v5 = *(_DWORD *)(v4 + 12);
    if (v5 == 4)
    {
      if ((a2 - 51) <= 0xE && ((1 << (a2 - 51)) & 0x6001) != 0)
      {
        if (*(void *)(a1 + 496)) {
          *(void *)(a1 + 496) = 0;
        }
        return;
      }
    }
    else if (v5 <= 3 && *(unsigned __int16 *)(v4 + 226) >= 4u && *(_DWORD *)(v4 + 256))
    {
      tcp_drop(v4, a2);
      return;
    }
    *(_DWORD *)(v4 + 256) = a2;
  }
}

uint64_t tcp_set_max_rwinscale(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(int *)(sysctls + 184);
  if (v2 <= *(unsigned __int8 *)(result + 262)) {
    LOBYTE(v2) = *(unsigned char *)(result + 262);
  }
  unsigned int v3 = (int *)(sysctls + 72);
  if ((*(unsigned char *)(a2 + 537) & 2) != 0) {
    unsigned int v3 = (int *)(a2 + 492);
  }
  int v4 = *v3;
  unsigned int v5 = v2;
  if (v2 <= 0xDu && 0x10000 << v2 < v4)
  {
    do
    {
      LOBYTE(v2) = v5 + 1;
      if (v5 > 0xC) {
        break;
      }
      int v7 = 0x20000 << v5++;
    }
    while (v7 < v4);
  }
  if (v2 >= 0xEu) {
    LOBYTE(v2) = 14;
  }
  *(unsigned char *)(result + 262) = v2;
  return result;
}

void *tcp_rxtseg_insert(void *result, int a2, int a3)
{
  int v3 = a3;
  int v4 = a2;
  unsigned int v5 = result;
  uint64_t v6 = (void *)result[119];
  if (v6)
  {
    BOOL v7 = *(_DWORD *)v6 - a2 > 0;
    if (*(_DWORD *)v6 - a2 > 0)
    {
      __int16 v8 = 0;
      unsigned int v9 = 0;
      goto LABEL_4;
    }
    do
    {
      unsigned int v9 = v6;
      uint64_t v6 = (void *)v6[2];
      if (!v6)
      {
        uint64_t result = 0;
        goto LABEL_17;
      }
    }
    while (*(_DWORD *)v6 - a2 <= 0);
    uint64_t result = v6;
LABEL_17:
    int v11 = *((_DWORD *)v9 + 1);
    if (*(_DWORD *)v9 - a2 <= 0 && ((v11 - a3) & 0x80000000) == 0)
    {
      ++*((_WORD *)v9 + 4);
      return result;
    }
    if (v11 - a2 < 1)
    {
      if (v6)
      {
LABEL_33:
        __int16 v8 = 0;
        goto LABEL_34;
      }
      goto LABEL_31;
    }
    if (*(_DWORD *)v9 == a2 && a3 - v11 >= 1)
    {
      int v4 = v11 + 1;
      ++*((_WORD *)v9 + 4);
      if (v6) {
        goto LABEL_33;
      }
LABEL_31:
      BOOL v7 = 0;
      __int16 v8 = 0;
      goto LABEL_11;
    }
    *((_DWORD *)v9 + 1) = a2 - 1;
    __int16 v8 = *((_WORD *)v9 + 4);
    if (v6)
    {
LABEL_34:
      uint64_t v6 = result;
LABEL_4:
      if (*(_DWORD *)v6 - a3 < 0)
      {
        if (*((_DWORD *)v6 + 1) - a3 <= 0)
        {
          int v3 = *(_DWORD *)v6 - 1;
          ++*((_WORD *)v6 + 4);
        }
        else
        {
          *(_DWORD *)uint64_t v6 = a3 + 1;
          __int16 v8 = *((_WORD *)v6 + 4);
        }
      }
      goto LABEL_11;
    }
    BOOL v7 = 0;
  }
  else
  {
    unsigned int v9 = 0;
    __int16 v8 = 0;
    *((_DWORD *)result + 240) = *((_DWORD *)result + 23);
    BOOL v7 = 1;
  }
LABEL_11:
  if (v4 - v3 < 0)
  {
    uint64_t v10 = nw_tcp_access_globals(*(void *)(v5[10] + 224));
    uint64_t result = malloc_type_malloc(**(void **)(v10 + 56), 0xB9BAFBABuLL);
    if (result)
    {
      result[2] = 0;
      *(void *)((char *)result + 10) = 0;
      *(_DWORD *)uint64_t result = v4;
      *((_DWORD *)result + 1) = v3;
      *((_WORD *)result + 4) = v8 + 1;
      if (v7)
      {
        result[2] = v5[119];
        v5[119] = result;
      }
      else
      {
        result[2] = v9[2];
        void v9[2] = result;
      }
    }
  }
  return result;
}

void tcp_seg_rto_insert_end(uint64_t a1, int a2, int a3, int a4, char a5)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v10 = *(void **)(a1 + 2024);
  if (v10)
  {
    uint64_t v11 = v10[9];
    unsigned int v12 = (void *)v10[10];
    if (v11)
    {
      *(void *)(v11 + 80) = v12;
      unsigned int v12 = (void *)v10[10];
    }
    else
    {
      *(void *)(a1 + 2032) = v12;
    }
    *unsigned int v12 = v11;
    --*(_DWORD *)(a1 + 2040);
    goto LABEL_8;
  }
  uint64_t v13 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
  uint64_t v10 = malloc_type_malloc(**(void **)(v13 + 64), 0xB9BAFBABuLL);
  if (v10)
  {
LABEL_8:
    v10[10] = 0;
    *((_OWORD *)v10 + 3) = 0u;
    *((_OWORD *)v10 + 4) = 0u;
    *((_OWORD *)v10 + 1) = 0u;
    *((_OWORD *)v10 + 2) = 0u;
    *(_OWORD *)uint64_t v10 = 0u;
  }
  *(_DWORD *)uint64_t v10 = a2;
  *((_DWORD *)v10 + 1) = a3;
  *((_DWORD *)v10 + 2) = a4;
  if (a2 - *(_DWORD *)(a1 + 2060) < 0) {
    *(_DWORD *)(a1 + 2060) = a2;
  }
  char v14 = *((unsigned char *)v10 + 12) | a5;
  *((unsigned char *)v10 + 12) = v14;
  if ((v14 & 4) != 0) {
    *(_DWORD *)(a1 + 2076) += tcp_seg_len((int *)v10);
  }
  int v15 = *(char *)(a1 + 2069);
  if ((v15 & 0x80000000) == 0) {
    *(unsigned char *)(a1 + 2069) = v15 | (32 * a5) & 0x80;
  }
  unint64_t v16 = *(void *)(a1 + 2000);
  if (v16)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v17 = v16;
        int v18 = *((_DWORD *)v10 + 1) - *(_DWORD *)(v16 + 4);
        if (v18 >= 0) {
          break;
        }
        unint64_t v16 = *(void *)(v16 + 32);
        if (!v16) {
          goto LABEL_23;
        }
      }
      if (!v18) {
        break;
      }
      unint64_t v16 = *(void *)(v16 + 40);
      if (!v16) {
        goto LABEL_23;
      }
    }
    uint64_t v21 = __nwlog_obj();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      int v22 = *(_DWORD *)v17;
      int v23 = *(_DWORD *)(v17 + 4);
      int v24 = 136446978;
      uint64_t v25 = "tcp_seg_rto_insert_end";
      __int16 v26 = 2048;
      unint64_t v27 = v17;
      __int16 v28 = 1024;
      int v29 = v22;
      __int16 v30 = 1024;
      int v31 = v23;
      _os_log_impl(&dword_214653000, v21, OS_LOG_TYPE_ERROR, "%{public}s segment %p[%u %u) was not inserted in the RB tree", (uint8_t *)&v24, 0x22u);
    }
  }
  else
  {
    unint64_t v17 = 0;
    int v18 = 0;
LABEL_23:
    v10[4] = 0;
    v10[5] = 0;
    v10[6] = v17 | 1;
    if (v18 < 0) {
      uint64_t v19 = (void *)(v17 + 32);
    }
    else {
      uint64_t v19 = (void *)(v17 + 40);
    }
    if (!v17) {
      uint64_t v19 = (void *)(a1 + 2000);
    }
    *uint64_t v19 = v10;
    tcp_seg_sent_tree_head_RB_INSERT_COLOR(a1 + 2000, (unint64_t)v10);
  }
  v10[2] = 0;
  uint64_t v20 = *(void **)(a1 + 1992);
  v10[3] = v20;
  *uint64_t v20 = v10;
  *(void *)(a1 + 1992) = v10 + 2;
}

void tcp_segs_dosack_matched(uint64_t a1, int *a2, int a3, int a4, _DWORD *a5)
{
  uint64_t v8 = (uint64_t)a2;
  int v10 = *a2;
  if (*a2 == a3)
  {
LABEL_13:
    unsigned int v14 = *(unsigned __int8 *)(v8 + 12);
    if (!tcp_seg_mark_sacked((_DWORD *)a1, v8, a5)) {
      return;
    }
    goto LABEL_14;
  }
  while (1)
  {
    unsigned int v11 = *(unsigned __int8 *)(v8 + 12);
    if (a3 - v10 >= 1) {
      break;
    }
    if (tcp_seg_mark_sacked((_DWORD *)a1, v8, a5)) {
      tcp_rack_update_segment_acked(a1, a4, *(_DWORD *)(v8 + 8), *(_DWORD *)(v8 + 4), (v11 >> 3) & 1);
    }
    if (!*(void *)(a1 + 2000)) {
      return;
    }
    int v12 = *(_DWORD *)v8;
    uint64_t v8 = *(void *)(a1 + 2000);
    while (1)
    {
      while (1)
      {
        int v13 = *(_DWORD *)(v8 + 4);
        if (v12 - v13 >= 0) {
          break;
        }
        uint64_t v8 = *(void *)(v8 + 32);
        if (!v8) {
          return;
        }
      }
      if (v12 == v13) {
        break;
      }
      uint64_t v8 = *(void *)(v8 + 40);
      if (!v8) {
        return;
      }
    }
    int v10 = *(_DWORD *)v8;
    if (*(_DWORD *)v8 == a3) {
      goto LABEL_13;
    }
  }
  if ((v11 & 1) == 0)
  {
    tcp_seg_sent_insert_before(a1, v8, v10, a3, *(_DWORD *)(v8 + 8), *(unsigned char *)(v8 + 12));
    *(_DWORD *)uint64_t v8 = a3;
    unsigned int v14 = *(unsigned __int8 *)(v8 + 12);
    if (tcp_seg_mark_sacked((_DWORD *)a1, v8, a5))
    {
LABEL_14:
      int v16 = *(_DWORD *)(v8 + 4);
      unsigned int v15 = *(_DWORD *)(v8 + 8);
      tcp_rack_update_segment_acked(a1, a4, v15, v16, (v14 >> 3) & 1);
    }
  }
}

void *tcp_seg_sent_insert_before(uint64_t a1, uint64_t a2, int a3, int a4, int a5, char a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  int v12 = *(void **)(a1 + 2024);
  if (v12)
  {
    uint64_t v13 = v12[9];
    unsigned int v14 = (void *)v12[10];
    if (v13)
    {
      *(void *)(v13 + 80) = v14;
      unsigned int v14 = (void *)v12[10];
    }
    else
    {
      *(void *)(a1 + 2032) = v14;
    }
    *unsigned int v14 = v13;
    --*(_DWORD *)(a1 + 2040);
    goto LABEL_8;
  }
  uint64_t v15 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
  int v12 = malloc_type_malloc(**(void **)(v15 + 64), 0xB9BAFBABuLL);
  if (v12)
  {
LABEL_8:
    v12[10] = 0;
    *((_OWORD *)v12 + 3) = 0u;
    *((_OWORD *)v12 + 4) = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    *((_OWORD *)v12 + 2) = 0u;
    *(_OWORD *)int v12 = 0u;
  }
  *(_DWORD *)int v12 = a3;
  *((_DWORD *)v12 + 1) = a4;
  *((_DWORD *)v12 + 2) = a5;
  if (a3 - *(_DWORD *)(a1 + 2060) < 0) {
    *(_DWORD *)(a1 + 2060) = a3;
  }
  char v16 = *((unsigned char *)v12 + 12) | a6;
  *((unsigned char *)v12 + 12) = v16;
  if ((v16 & 4) != 0) {
    *(_DWORD *)(a1 + 2076) += tcp_seg_len((int *)v12);
  }
  int v17 = *(char *)(a1 + 2069);
  if ((v17 & 0x80000000) == 0) {
    *(unsigned char *)(a1 + 2069) = v17 | (32 * a6) & 0x80;
  }
  unint64_t v18 = *(void *)(a1 + 2000);
  if (v18)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v19 = v18;
        int v20 = *((_DWORD *)v12 + 1) - *(_DWORD *)(v18 + 4);
        if (v20 >= 0) {
          break;
        }
        unint64_t v18 = *(void *)(v18 + 32);
        if (!v18) {
          goto LABEL_23;
        }
      }
      if (!v20) {
        break;
      }
      unint64_t v18 = *(void *)(v18 + 40);
      if (!v18) {
        goto LABEL_23;
      }
    }
    int v23 = __nwlog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      int v24 = *(_DWORD *)v19;
      int v25 = *(_DWORD *)(v19 + 4);
      int v26 = 136446978;
      unint64_t v27 = "tcp_seg_sent_insert_before";
      __int16 v28 = 2048;
      unint64_t v29 = v19;
      __int16 v30 = 1024;
      int v31 = v24;
      __int16 v32 = 1024;
      int v33 = v25;
      _os_log_impl(&dword_214653000, v23, OS_LOG_TYPE_ERROR, "%{public}s segment %p[%u %u) was not inserted in the RB tree", (uint8_t *)&v26, 0x22u);
    }
  }
  else
  {
    unint64_t v19 = 0;
    int v20 = 0;
LABEL_23:
    v12[4] = 0;
    v12[5] = 0;
    v12[6] = v19 | 1;
    if (v20 < 0) {
      uint64_t v21 = (void *)(v19 + 32);
    }
    else {
      uint64_t v21 = (void *)(v19 + 40);
    }
    if (!v19) {
      uint64_t v21 = (void *)(a1 + 2000);
    }
    *uint64_t v21 = v12;
    tcp_seg_sent_tree_head_RB_INSERT_COLOR(a1 + 2000, (unint64_t)v12);
  }
  v12[3] = *(void *)(a2 + 24);
  v12[2] = a2;
  **(void **)(a2 + 24) = v12;
  *(void *)(a2 + 24) = v12 + 2;
  return v12;
}

BOOL tcp_seg_mark_sacked(_DWORD *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  char v3 = *(unsigned char *)(a2 + 12);
  if ((v3 & 1) == 0)
  {
    unsigned int v7 = tcp_seg_len((int *)a2);
    unsigned int v8 = v7;
    char v9 = *(unsigned char *)(a2 + 12);
    if (*(_DWORD *)(a2 + 4) - a1[140] < 0 && (*(unsigned char *)(a2 + 12) & 9) == 0) {
      ++a1[254];
    }
    if ((v9 & 4) != 0)
    {
      if ((v9 & 2) != 0)
      {
        *(unsigned char *)(a2 + 12) = v9 & 0xF9;
        unsigned int v13 = a1[518];
        if (v13 < v7 || (unsigned int v14 = a1[519], v14 < v7))
        {
          __nwlog_obj();
          int v15 = a1[518];
          unsigned int v16 = a1[519];
          *(_DWORD *)long long buf = 136446978;
          int v25 = "tcp_seg_mark_sacked";
          __int16 v26 = 1024;
          int v27 = v15;
          __int16 v28 = 1024;
          unsigned int v29 = v16;
          __int16 v30 = 1024;
          LODWORD(v31) = v8;
          int v17 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            unint64_t v18 = __nwlog_obj();
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              int v19 = a1[518];
              unsigned int v20 = a1[519];
              *(_DWORD *)long long buf = 136446978;
              int v25 = "tcp_seg_mark_sacked";
              __int16 v26 = 1024;
              int v27 = v19;
              __int16 v28 = 1024;
              unsigned int v29 = v20;
              __int16 v30 = 1024;
              LODWORD(v31) = v8;
              _os_log_impl(&dword_214653000, v18, OS_LOG_TYPE_ERROR, "%{public}s bytes_lost (%u) and/or bytes_retransmitted (%u) can't be smaller than already lost/retransmitted segment length (%u), backtrace limit exceeded", buf, 0x1Eu);
            }
          }
          if (v17) {
            free(v17);
          }
          unsigned int v13 = a1[518];
          unsigned int v14 = a1[519];
        }
        a1[518] = v13 - v8;
        a1[519] = v14 - v8;
      }
    }
    else if ((v9 & 2) != 0)
    {
      *(unsigned char *)(a2 + 12) = v9 & 0xFD;
      unsigned int v10 = a1[518];
      if (v10 < v7)
      {
        __nwlog_obj();
        int v11 = a1[518];
        *(_DWORD *)long long buf = 136446722;
        int v25 = "tcp_seg_mark_sacked";
        __int16 v26 = 1024;
        int v27 = v11;
        __int16 v28 = 1024;
        unsigned int v29 = v8;
        int v12 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          uint64_t v21 = __nwlog_obj();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            int v22 = a1[518];
            *(_DWORD *)long long buf = 136446722;
            int v25 = "tcp_seg_mark_sacked";
            __int16 v26 = 1024;
            int v27 = v22;
            __int16 v28 = 1024;
            unsigned int v29 = v8;
            _os_log_impl(&dword_214653000, v21, OS_LOG_TYPE_ERROR, "%{public}s bytes_lost (%u) can't be smaller than already lost segment length (%u), backtrace limit exceeded", buf, 0x18u);
          }
        }
        if (v12) {
          free(v12);
        }
        unsigned int v10 = a1[518];
      }
      a1[518] = v10 - v8;
    }
    *a3 += v8;
    *(unsigned char *)(a2 + 12) |= 1u;
    a1[520] += v8;
  }
  return (v3 & 1) == 0;
}

void tcp_mark_seg_lost(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  unsigned int v4 = tcp_seg_len((int *)a2);
  unsigned int v5 = v4;
  char v6 = *(unsigned char *)(a2 + 12);
  if ((v6 & 2) != 0)
  {
    if ((*(unsigned char *)(a2 + 12) & 4) != 0)
    {
      *(unsigned char *)(a2 + 12) = v6 & 0xFB;
      unsigned int v7 = *(_DWORD *)(a1 + 2076);
      BOOL v8 = v7 >= v4;
      unsigned int v9 = v7 - v4;
      if (v8)
      {
        *(_DWORD *)(a1 + 2076) = v9;
      }
      else
      {
        __nwlog_obj();
        int v10 = *(_DWORD *)(a1 + 2076);
        *(_DWORD *)long long buf = 136446722;
        int v15 = "tcp_mark_seg_lost";
        __int16 v16 = 1024;
        int v17 = v10;
        __int16 v18 = 1024;
        unsigned int v19 = v5;
        int v11 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          int v12 = __nwlog_obj();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            int v13 = *(_DWORD *)(a1 + 2076);
            *(_DWORD *)long long buf = 136446722;
            int v15 = "tcp_mark_seg_lost";
            __int16 v16 = 1024;
            int v17 = v13;
            __int16 v18 = 1024;
            unsigned int v19 = v5;
            _os_log_impl(&dword_214653000, v12, OS_LOG_TYPE_ERROR, "%{public}s bytes_retransmitted (%u) can't be smaller than retransmited segment length (%u), backtrace limit exceeded", buf, 0x18u);
          }
        }
        if (v11) {
          free(v11);
        }
      }
    }
  }
  else
  {
    *(unsigned char *)(a2 + 12) = v6 | 2;
    *(_DWORD *)(a1 + 2072) += v4;
  }
}

void tcp_add_notify_ack_marker(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 80) + 224);
  unsigned int v5 = malloc_type_malloc(0x10uLL, 0xF2B69DE5uLL);
  if (!v5)
  {
    unsigned int v14 = __nwlog_obj();
    os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    int v15 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
LABEL_13:
      __break(1u);
      return;
    }
    free(v15);
  }
  v5[1] = a2;
  int v6 = *(_DWORD *)(v4 + 384) + *(_DWORD *)(a1 + 92);
  *unsigned int v5 = v6;
  unsigned int v7 = (uint64_t *)(a1 + 1032);
  BOOL v8 = *(_DWORD **)(a1 + 1032);
  if (v8)
  {
    do
    {
      int v10 = *v8;
      unsigned int v9 = (uint64_t *)(v8 + 2);
      if (v6 - v10 > 0)
      {
        unsigned int v7 = v9;
        goto LABEL_9;
      }
      BOOL v8 = (_DWORD *)*v9;
    }
    while (v8);
    int v11 = __nwlog_obj();
    os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    int v12 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort()) {
      goto LABEL_13;
    }
    free(v12);
LABEL_9:
    uint64_t v13 = *v7;
  }
  else
  {
    uint64_t v13 = 0;
  }
  *((void *)v5 + 1) = v13;
  *unsigned int v7 = (uint64_t)v5;
  ++*(unsigned char *)(a1 + 732);
}

uint64_t tcp_get_notify_ack_count(uint64_t result, int *a2)
{
  uint64_t v2 = *(void *)(result + 1032);
  if (v2)
  {
    LOBYTE(v3) = 0;
    do
    {
      if (*(_DWORD *)(result + 92) - *(_DWORD *)v2 < 0) {
        break;
      }
      LOBYTE(v3) = v3 + 1;
      uint64_t v2 = *(void *)(v2 + 8);
    }
    while (v2);
  }
  else
  {
    LOBYTE(v3) = 0;
  }
  int v3 = v3;
  int v4 = *(unsigned __int8 *)(result + 732) - v3;
  if (v3 >= 0xAu) {
    int v3 = 10;
  }
  *a2 = v4;
  a2[1] = v3;
  return result;
}

void *tcp_get_notify_ack_ids(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void **)(a1 + 1032);
  if (result)
  {
    unint64_t v5 = 0;
    int v6 = (void *)(a1 + 1032);
    do
    {
      if (v5 >= *(unsigned int *)(a2 + 4) || *(_DWORD *)(a1 + 92) - *(_DWORD *)result < 0) {
        break;
      }
      unsigned int v7 = (void *)result[1];
      *(_DWORD *)(a2 + 4 * v5 + 8) = *((_DWORD *)result + 1);
      BOOL v8 = (void *)*v6;
      unsigned int v9 = (void *)(a1 + 1032);
      if ((void *)*v6 != result)
      {
        do
        {
          int v10 = v8;
          BOOL v8 = (void *)v8[1];
        }
        while (v8 != result);
        unsigned int v9 = v10 + 1;
      }
      ++v5;
      *unsigned int v9 = v7;
      free(result);
      --*(unsigned char *)(a1 + 732);
      uint64_t result = v7;
    }
    while (v7);
  }
  return result;
}

uint64_t tcp_validate_cksum(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = validate_tcp_cksum();
  if ((v5 & 1) == 0)
  {
    if ((*(_WORD *)(a1 + 204) & 0x100) != 0
      && *MEMORY[0x263F144B8]
      && (((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(a1, *(void *)(a1 + 88)) & 1) == 0)
    {
      *(void *)(a3 + 1056) = 0;
    }
    else
    {
      uint64_t v6 = *(void *)(a3 + 1056);
      if (v6) {
        ++*(void *)(v6 + 320);
      }
    }
  }
  return v5;
}

void tcp_prague_switch_cc(uint64_t a1)
{
}

void tcp_prague_cwnd_init_or_reset(uint64_t a1)
{
  uint64_t v2 = *(_WORD **)(a1 + 840);
  if (!v2)
  {
    int v11 = __nwlog_obj();
    os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    int v12 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }
    free(v12);
    uint64_t v2 = *(_WORD **)(a1 + 840);
  }
  *(_DWORD *)(a1 + 504) = 0;
  _WORD *v2 = 0;
  *(_WORD *)(*(void *)(a1 + 840) + 2) = 0;
  *(void *)(*(void *)(a1 + 840) + 40) = 0x100000;
  *(_DWORD *)(*(void *)(a1 + 840) + 76) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 52) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 56) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 48) = 0;
  int v3 = (_DWORD *)sysctls;
  if (*(_DWORD *)(sysctls + 276))
  {
    if (*(_DWORD *)(sysctls + 304)) {
      int v4 = *(_DWORD *)(sysctls + 16);
    }
    else {
      int v4 = 10;
    }
    LODWORD(v5) = *(_DWORD *)(a1 + 196);
    LODWORD(v6) = v5 * v4;
  }
  else
  {
    uint64_t v5 = *(unsigned int *)(a1 + 196);
    LODWORD(v6) = 2 * v5;
    if (v5 <= 0x88E) {
      unint64_t v6 = 4380;
    }
    else {
      unint64_t v6 = v6;
    }
    if (v6 > 4 * v5) {
      LODWORD(v6) = 4 * v5;
    }
  }
  *(_DWORD *)(a1 + 144) = v6;
  *(void *)(a1 + 980) = 0;
  *(_DWORD *)(a1 + 972) = 0;
  *(void *)(a1 + 964) = 0;
  *(unsigned char *)(a1 + 751) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  if (v3[76])
  {
    int v7 = v3[4];
  }
  else
  {
    if (!v3[69])
    {
      unint64_t v8 = 4380;
      goto LABEL_18;
    }
    int v7 = 10;
  }
  unint64_t v8 = (v5 * v7);
LABEL_18:
  unsigned int v9 = *(_DWORD *)(a1 + 148);
  if (*(void *)(*(void *)(*(void *)(a1 + 80) + 248) + 24) <= v8 && v9 <= 0x3FFFBFFF)
  {
    unsigned int v9 = 1073725440;
    *(_DWORD *)(a1 + 148) = 1073725440;
  }
  *(_DWORD *)(*(void *)(a1 + 840) + 48) = v9;
  int v10 = *(_DWORD *)(a1 + 196);
  *(void *)(a1 + 480) = 10 * *(unsigned int *)(a1 + 144);
  *(_DWORD *)(a1 + 488) = v10;
}

uint64_t tcp_prague_set_bytes_acked(uint64_t result, int a2)
{
  *(_DWORD *)(*(void *)(result + 840) + 16) = a2;
  return result;
}

void tcp_prague_process_ecn(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  uint64_t v10 = *(void *)(a1 + 840);
  unsigned int v11 = *(_DWORD *)(v10 + 12);
  if (v11 <= a4 && *(_DWORD *)(v10 + 4) <= a5)
  {
    if (v11 >= a4) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  __nwlog_obj();
  uint64_t v12 = *(void *)(a1 + 840);
  int v13 = *(_DWORD *)(v12 + 12);
  LODWORD(v12) = *(_DWORD *)(v12 + 4);
  *(_DWORD *)long long buf = 136447234;
  __int16 v49 = "tcp_prague_process_ecn";
  __int16 v50 = 1024;
  unsigned int v51 = a4;
  __int16 v52 = 1024;
  int v53 = v13;
  __int16 v54 = 1024;
  unsigned int v55 = a5;
  __int16 v56 = 1024;
  int v57 = v12;
  unsigned int v14 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    int v41 = __nwlog_obj();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      uint64_t v42 = *(void *)(a1 + 840);
      int v43 = *(_DWORD *)(v42 + 12);
      LODWORD(v42) = *(_DWORD *)(v42 + 4);
      *(_DWORD *)long long buf = 136447234;
      __int16 v49 = "tcp_prague_process_ecn";
      __int16 v50 = 1024;
      unsigned int v51 = a4;
      __int16 v52 = 1024;
      int v53 = v43;
      __int16 v54 = 1024;
      unsigned int v55 = a5;
      __int16 v56 = 1024;
      int v57 = v42;
      _os_log_impl(&dword_214653000, v41, OS_LOG_TYPE_ERROR, "%{public}s new CE count (%u) can't be less than current CE count (%u)OR newly ACKed (%u) can't be less that current ACKed (%u), backtrace limit exceeded", buf, 0x24u);
    }
  }
  if (v14) {
    free(v14);
  }
  uint64_t v10 = *(void *)(a1 + 840);
  if (*(_DWORD *)(v10 + 12) < a4)
  {
LABEL_6:
    *(unsigned char *)(v10 + 28) |= 1u;
    uint64_t v10 = *(void *)(a1 + 840);
  }
LABEL_7:
  unsigned int v15 = *(_DWORD *)(v10 + 4);
  BOOL v16 = a5 >= v15;
  unsigned int v17 = a5 - v15;
  if (v17 != 0 && v16)
  {
    int v18 = *(_DWORD *)(v10 + 20);
    if (v18) {
      BOOL v19 = *(_DWORD *)(a2 + 8) - v18 <= 0;
    }
    else {
      BOOL v19 = 0;
    }
    if (v19)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        BOOL v46 = __nwlog_obj();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 136446210;
          __int16 v49 = "prague_update_alpha";
          _os_log_impl(&dword_214653000, v46, OS_LOG_TYPE_DEBUG, "%{public}s one RTT hasn't elapsed, not updating alpha", buf, 0xCu);
        }
      }
    }
    else if (*(unsigned char *)(v10 + 28))
    {
      unsigned int v20 = *(_DWORD *)(v10 + 8);
      BOOL v16 = a4 >= v20;
      unsigned int v21 = a4 - v20;
      BOOL v19 = v21 != 0 && v16;
      unsigned int v22 = v21 << 20;
      if (!v19) {
        unsigned int v22 = 0;
      }
      unint64_t v23 = *(void *)(v10 + 32) - (*(void *)(v10 + 32) >> 4) + v22 / v17;
      if (v23 >= 0x1000000) {
        unint64_t v23 = 0x1000000;
      }
      *(void *)(v10 + 32) = v23;
      *(_DWORD *)(*(void *)(a1 + 840) + 20) = *(_DWORD *)(a1 + 100);
      *(_DWORD *)(*(void *)(a1 + 840) + 8) = a4;
      *(_DWORD *)(*(void *)(a1 + 840) + 4) = a5;
    }
  }
  if (*(_DWORD *)(*(void *)(a1 + 840) + 12) != a4)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      int v44 = __nwlog_obj();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
      {
        unsigned int v45 = a4 - *(_DWORD *)(*(void *)(a1 + 840) + 12);
        *(_DWORD *)long long buf = 136446466;
        __int16 v49 = "tcp_prague_process_ecn";
        __int16 v50 = 1024;
        unsigned int v51 = v45;
        _os_log_impl(&dword_214653000, v44, OS_LOG_TYPE_DEBUG, "%{public}s %u packets were newly CE marked", buf, 0x12u);
      }
    }
    uint64_t v24 = *(void *)(a1 + 840);
    unsigned int v25 = *(_DWORD *)(v24 + 16);
    BOOL v16 = v25 >= a3;
    unsigned int v26 = v25 - a3;
    if (!v16) {
      unsigned int v26 = 0;
    }
    *(_DWORD *)(v24 + 16) = v26;
    *(_DWORD *)(*(void *)(a1 + 840) + 12) = a4;
    unsigned int v27 = *(_DWORD *)(a1 + 200);
    BOOL v19 = v27 > 0x33F;
    unint64_t v28 = ((((v27 >> 5) * (v27 >> 5)) << 20) | 0x138) / 0x271uLL;
    if (v19) {
      unint64_t v28 = 0x100000;
    }
    *(void *)(*(void *)(a1 + 840) + 40) = v28;
    uint64_t v29 = *(void *)(a1 + 840);
    int v30 = *(_DWORD *)(v29 + 24);
    if (v30 && *(_DWORD *)(a2 + 8) - v30 <= 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v31 = __nwlog_obj();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 136446210;
          __int16 v49 = "tcp_prague_process_ecn";
          _os_log_impl(&dword_214653000, v31, OS_LOG_TYPE_DEBUG, "%{public}s one RTT hasn't elapsed, not doing CWR", buf, 0xCu);
        }
      }
    }
    else
    {
      if ((*(unsigned char *)(v29 + 28) & 2) != 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          __int16 v47 = __nwlog_obj();
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 136446210;
            __int16 v49 = "prague_cwr";
            _os_log_impl(&dword_214653000, v47, OS_LOG_TYPE_DEBUG, "%{public}s currently in loss recovery, no need to do CWR", buf, 0xCu);
          }
        }
      }
      else
      {
        ++*(_WORD *)(v29 + 2);
        uint64_t v32 = *(void *)(a1 + 840);
        unsigned int v33 = *(_DWORD *)(a1 + 144)
            - (((*(void *)(v32 + 32) >> 4) * (unint64_t)*(unsigned int *)(a1 + 144)) >> 21);
        *(_DWORD *)(a1 + 144) = v33;
        unsigned int v34 = *(_DWORD *)(a1 + 196);
        if (!*(_DWORD *)(v32 + 16))
        {
          unsigned int v33 = (v33 + (v34 >> 1)) / v34 * v34;
          *(_DWORD *)(a1 + 144) = v33;
        }
        unsigned int v35 = 2 * v34;
        if (v33 < v35)
        {
          *(_DWORD *)(a1 + 144) = v35;
          unsigned int v33 = v35;
        }
        *(_DWORD *)(a1 + 148) = v33;
        *(unsigned char *)(v32 + 28) |= 4u;
        unint64_t v37 = *(unsigned int *)(a1 + 196);
        int v36 = *(_DWORD *)(a1 + 200);
        if (v36 >= 0x20) {
          unint64_t v38 = (v36 >> 5);
        }
        else {
          unint64_t v38 = 100;
        }
        unint64_t v39 = 1000
            * ((unint64_t)*(unsigned int *)(a1 + 144) << (*(_DWORD *)(a1 + 144) < *(_DWORD *)(a1 + 148)))
            / v38;
        *(void *)(a1 + 480) = v39;
        if (v39 >> 12 >= v37) {
          int v40 = v39 >> 12;
        }
        else {
          int v40 = v37;
        }
        *(_DWORD *)(a1 + 488) = v40;
      }
      *(_DWORD *)(*(void *)(a1 + 840) + 24) = *(_DWORD *)(a1 + 100);
    }
  }
}

void tcp_prague_after_timeout(uint64_t a1)
{
  if (!*(void *)(a1 + 840))
  {
    uint64_t v2 = __nwlog_obj();
    os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
    int v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }
    free(v3);
  }
  if (*(int *)(a1 + 12) > 3 || *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92) >= 2)
  {
    if ((*(unsigned char *)(a1 + 90) & 0x20) == 0)
    {
      *(_DWORD *)(a1 + 504) = 0;
      **(_WORD **)(a1 + 840) = 0;
      *(_WORD *)(*(void *)(a1 + 840) + 2) = 0;
      *(void *)(*(void *)(a1 + 840) + 40) = 0x100000;
      *(_DWORD *)(*(void *)(a1 + 840) + 76) = 0;
      *(_DWORD *)(*(void *)(a1 + 840) + 52) = 0;
      *(_DWORD *)(*(void *)(a1 + 840) + 56) = 0;
      *(_DWORD *)(*(void *)(a1 + 840) + 48) = 0;
      tcp_prague_pre_fr(a1);
    }
    *(_DWORD *)(a1 + 144) = *(_DWORD *)(a1 + 196);
  }
}

uint64_t tcp_prague_pre_fr(uint64_t a1)
{
  *(_DWORD *)(*(void *)(a1 + 840) + 52) = 0;
  if ((*(unsigned char *)(a1 + 742) & 0x10) != 0)
  {
    uint64_t result = tcp_flight_size((_DWORD *)a1);
    unsigned int v3 = *(_DWORD *)(a1 + 980);
    if (v3 <= result) {
      unsigned int v3 = result;
    }
  }
  else
  {
    uint64_t result = 0;
    unsigned int v3 = *(_DWORD *)(a1 + 144);
  }
  *(_DWORD *)(a1 + 984) = result;
  uint64_t v4 = *(void *)(a1 + 840);
  float v5 = (float)v3;
  if (v3 < *(_DWORD *)(v4 + 48)) {
    unsigned int v3 = (float)((float)v3 * 0.85);
  }
  *(_DWORD *)(v4 + 48) = v3;
  unsigned int v6 = *(_DWORD *)(a1 + 196);
  unsigned int v7 = ((float)(v5 * 0.7) + (v6 >> 1)) / v6 * v6;
  unsigned int v8 = 2 * v6;
  if (v7 > v8) {
    unsigned int v8 = v7;
  }
  *(_DWORD *)(a1 + 148) = v8;
  unsigned int v9 = *(_DWORD **)(*(void *)(a1 + 80) + 224);
  if (v9[97] > v8)
  {
    int v10 = v9[108];
    if ((v10 & 0x400) != 0)
    {
      if (v9[109] > v8)
      {
        if (*(int *)(sysctls + 232) > (uint64_t)v8) {
          unsigned int v8 = *(_DWORD *)(sysctls + 232);
        }
        if (v8 >= *(_DWORD *)(sysctls + 120)) {
          unsigned int v8 = *(_DWORD *)(sysctls + 120);
        }
        v9[109] = v8;
      }
      v9[108] = v10 | 0x800;
    }
  }
  ++**(_WORD **)(a1 + 840);
  *(unsigned char *)(*(void *)(a1 + 840) + 28) |= 2u;
  *(unsigned char *)(*(void *)(a1 + 840) + 28) &= ~4u;
  return result;
}

uint64_t tcp_prague_post_fr(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 148);
  *(_DWORD *)(result + 144) = v1;
  unint64_t v3 = *(unsigned int *)(result + 196);
  int v2 = *(_DWORD *)(result + 200);
  if (v2 >= 0x20) {
    unint64_t v4 = (v2 >> 5);
  }
  else {
    unint64_t v4 = 100;
  }
  unint64_t v5 = 1000 * (unint64_t)v1 / v4;
  *(void *)(result + 480) = v5;
  if (v5 >> 12 >= v3) {
    int v6 = v5 >> 12;
  }
  else {
    int v6 = v3;
  }
  *(_DWORD *)(result + 488) = v6;
  *(_DWORD *)(*(void *)(result + 840) + 60) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 64) = 0;
  *(unsigned char *)(*(void *)(result + 840) + 28) &= ~2u;
  return result;
}

void tcp_prague_ack_rcvd(uint64_t a1, uint64_t a2)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(*(void *)(a1 + 80) + 224);
  unsigned int v5 = *(_DWORD *)(a1 + 980);
  if (v5)
  {
    unsigned int v6 = *(_DWORD *)(a1 + 144);
    if (v5 < v6 >> 1 && (!v4 || *(_DWORD *)(v4 + 384) <= v6))
    {
      *(_DWORD *)(a1 + 740) |= 0x100000u;
      return;
    }
  }
  unsigned int v7 = *(_DWORD *)(a1 + 740) & 0xFFEFFFFF;
  *(_DWORD *)(a1 + 740) = v7;
  uint64_t v8 = *(void *)(a1 + 840);
  unsigned int v9 = *(_DWORD *)(v8 + 16);
  if (v9)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 144);
    if (v10 >= *(_DWORD *)(a1 + 148))
    {
      if ((*(unsigned char *)(v8 + 28) & 4) == 0)
      {
        if (v5 && v5 < v10 >> 1 && (!v4 || *(_DWORD *)(v4 + 384) <= v10))
        {
          *(_DWORD *)(a1 + 740) = v7 | 0x100000;
        }
        else
        {
          *(_DWORD *)(a1 + 740) = v7;
          *(_DWORD *)(a1 + 288) += v9;
          int v12 = *(_DWORD *)(a1 + 200);
          uint64_t v13 = nw_tcp_access_globals(v4);
          uint64_t v14 = v13;
          uint64_t v10 = *(void *)(a1 + 840);
          if (!*(_DWORD *)(v10 + 52))
          {
            *(_DWORD *)(v10 + 52) = *(_DWORD *)(v13 + 316);
            uint64_t v15 = *(void *)(a1 + 840);
            if (!*(_DWORD *)(v15 + 52))
            {
              *(_DWORD *)(v15 + 52) = 1;
              uint64_t v15 = *(void *)(a1 + 840);
            }
            unsigned int v16 = *(_DWORD *)(a1 + 144);
            unsigned int v17 = *(_DWORD *)(v15 + 48);
            BOOL v18 = v17 >= v16;
            unsigned int v19 = v17 - v16;
            if (v19 != 0 && v18)
            {
              *(float *)(v15 + 76) = cbrtf((float)((float)v19 * 2.5) / (float)*(unsigned int *)(a1 + 196)) * 1000.0;
              uint64_t v29 = *(void *)(a1 + 840);
              int v28 = *(_DWORD *)(v29 + 48);
            }
            else
            {
              *(_DWORD *)(v15 + 76) = 0;
              int v28 = *(_DWORD *)(a1 + 144);
              *(_DWORD *)(*(void *)(a1 + 840) + 48) = v28;
              uint64_t v29 = *(void *)(a1 + 840);
            }
            *(_DWORD *)(v29 + 56) = v28;
            uint64_t v10 = *(void *)(a1 + 840);
          }
          int v30 = v12 >> 5;
          unsigned int v31 = *(_DWORD *)(v10 + 56);
          if (!v31)
          {
            __nwlog_obj();
            *(_DWORD *)long long buf = 136446210;
            int v53 = "cubic_target";
            uint64_t v32 = (void *)_os_log_send_and_compose_impl();
            if (__nwlog_fault())
            {
              unsigned int v33 = __nwlog_obj();
              if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 136446210;
                int v53 = "cubic_target";
                _os_log_impl(&dword_214653000, v33, OS_LOG_TYPE_ERROR, "%{public}s Prague CC: Cubic origin point should be greater than 0, backtrace limit exceeded", buf, 0xCu);
              }
            }
            if (v32) {
              free(v32);
            }
            uint64_t v10 = *(void *)(a1 + 840);
            unsigned int v31 = *(_DWORD *)(v10 + 56);
          }
          float v34 = (float)(*(_DWORD *)(v14 + 316) - *(_DWORD *)(v10 + 52) + v30) - *(float *)(v10 + 76);
          float v35 = (float)v31
              + (float)((float)((float)((float)(v34 * 0.001) * (float)(v34 * 0.001)) * (float)(v34 * 0.0004))
                      * (float)*(unsigned int *)(a1 + 196));
          unsigned int v36 = (int)v35 & ~((int)v35 >> 31);
          unsigned int v37 = *(_DWORD *)(a1 + 144);
          unsigned int v38 = v37;
          if (v36 >= v37)
          {
            unsigned int v38 = ((double)v37 * 1.5);
            if (v36 < v38) {
              unsigned int v38 = (int)v35 & ~((int)v35 >> 31);
            }
          }
          if (!*(_DWORD *)(v10 + 60))
          {
            *(_DWORD *)(v10 + 60) = v37;
            *(_DWORD *)(*(void *)(a1 + 840) + 64) = *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 92);
            uint64_t v10 = *(void *)(a1 + 840);
          }
          *(_DWORD *)(v10 + 64) += *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 92);
          uint64_t v39 = *(void *)(a1 + 840);
          int v40 = (_DWORD *)(v39 + 64);
          unsigned int v41 = *(_DWORD *)(v39 + 64);
          for (LODWORD(v10) = *(_DWORD *)(a1 + 144); v41 >= v10; LODWORD(v10) = *(_DWORD *)(a1 + 144))
          {
            *int v40 = v41 - v10;
            uint64_t v10 = *(void *)(a1 + 840);
            unsigned int v42 = *(_DWORD *)(v10 + 60);
            float v43 = 0.52941;
            if (v42 >= *(_DWORD *)(v10 + 48)) {
              float v43 = 1.0;
            }
            *(_DWORD *)(v10 + 60) = v42 + (float)(v43 * (float)*(unsigned int *)(a1 + 196));
            uint64_t v39 = *(void *)(a1 + 840);
            int v40 = (_DWORD *)(v39 + 64);
            unsigned int v41 = *(_DWORD *)(v39 + 64);
          }
          uint64_t v44 = *(unsigned int *)(a1 + 196);
          unsigned int v45 = (*(_DWORD *)(v39 + 60) + (v44 >> 1)) / v44 * v44;
          BOOL v18 = v38 >= v10;
          unint64_t v46 = v38 - v10;
          if (v46 != 0 && v18) {
            unint64_t v47 = v44 * (unint64_t)v10 / v46;
          }
          else {
            unint64_t v47 = 0;
          }
          unint64_t v48 = v44 * (unint64_t)v10 / (v45 - v10);
          if (v48 >= v47) {
            unint64_t v48 = v47;
          }
          if (v45 > v10) {
            unint64_t v47 = v48;
          }
          if (v47)
          {
            unint64_t v49 = *(unsigned int *)(a1 + 288);
            if (v47 <= v49)
            {
              *(_DWORD *)(a1 + 288) = v49 - v47;
              uint64_t v50 = v44 + v10;
              char v51 = *(unsigned char *)(a1 + 260);
              LODWORD(v10) = v44 + v10;
              if (v50 >= 0xFFFFLL << v51) {
                LODWORD(v10) = 0xFFFF << v51;
              }
            }
          }
        }
        goto LABEL_29;
      }
      unint64_t v20 = *(_DWORD *)(a1 + 288) + v9;
      *(_DWORD *)(a1 + 288) = v20;
      unint64_t v21 = (unint64_t)(v10 << 20) / *(void *)(v8 + 40);
      if (v21 > v20)
      {
LABEL_29:
        unint64_t v23 = *(unsigned int *)(a1 + 196);
        int v24 = *(_DWORD *)(a1 + 200);
        LODWORD(v10) = (v10 + (v23 >> 1)) / v23 * v23;
        if (v10 <= 2 * (int)v23) {
          uint64_t v10 = (2 * v23);
        }
        else {
          uint64_t v10 = v10;
        }
        *(_DWORD *)(a1 + 144) = v10;
        if (v24 >= 0x20) {
          unint64_t v25 = (v24 >> 5);
        }
        else {
          unint64_t v25 = 100;
        }
        unint64_t v26 = 1000 * (v10 << (v10 < *(_DWORD *)(a1 + 148))) / v25;
        *(void *)(a1 + 480) = v26;
        if (v26 >> 12 >= v23) {
          int v27 = v26 >> 12;
        }
        else {
          int v27 = v23;
        }
        *(_DWORD *)(a1 + 488) = v27;
        return;
      }
      *(_DWORD *)(a1 + 288) = v20 - v21;
      unsigned int v9 = *(_DWORD *)(a1 + 196);
LABEL_28:
      LODWORD(v10) = v9 + v10;
      goto LABEL_29;
    }
    if (*(_DWORD *)(sysctls + 304))
    {
      int v11 = *(_DWORD *)(sysctls + 16);
    }
    else
    {
      if (!*(_DWORD *)(sysctls + 276))
      {
        unsigned int v22 = 4380;
LABEL_26:
        if (v9 >= v22) {
          unsigned int v9 = v22;
        }
        goto LABEL_28;
      }
      int v11 = 10;
    }
    unsigned int v22 = *(_DWORD *)(a1 + 196) * v11;
    goto LABEL_26;
  }
}

uint64_t tcp_prague_cleanup()
{
  return 0;
}

uint64_t tcp_prague_init(uint64_t a1)
{
  atomic_fetch_add(dword_26B4A90E8, 1u);
  uint64_t v2 = *(void *)(a1 + 840);
  if (v2) {
    goto LABEL_2;
  }
  uint64_t v4 = __nwlog_obj();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  unsigned int v5 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!result)
  {
    free(v5);
    uint64_t v2 = *(void *)(a1 + 840);
LABEL_2:
    *(void *)(v2 + 32) = 0x1000000;
    *(_DWORD *)(a1 + 504) = 0;
    **(_WORD **)(a1 + 840) = 0;
    *(_WORD *)(*(void *)(a1 + 840) + 2) = 0;
    *(void *)(*(void *)(a1 + 840) + 40) = 0x100000;
    *(_DWORD *)(*(void *)(a1 + 840) + 76) = 0;
    *(_DWORD *)(*(void *)(a1 + 840) + 52) = 0;
    *(_DWORD *)(*(void *)(a1 + 840) + 56) = 0;
    *(_DWORD *)(*(void *)(a1 + 840) + 48) = 0;
    return 0;
  }
  __break(1u);
  return result;
}

void tcp_enter_fast_recovery(uint64_t a1)
{
  uint64_t v2 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 64);
  if (v2) {
    v2(a1);
  }
  *(_DWORD *)(a1 + 88) |= 0x200000u;
  uint64_t v3 = *(void *)(a1 + 80);
  int v4 = *(_DWORD *)(v3 + 2228);
  if ((v4 & 0x40000000) != 0)
  {
    uint64_t v5 = *(void *)(v3 + 224);
    if ((v4 & 0x10000000) != 0)
    {
      *(_DWORD *)(v3 + 2228) = v4 & 0xAFFFFFFF;
      *(_DWORD *)(v5 + 364) &= ~0x20000u;
      if ((v4 & 0x50000000) == 0) {
        goto LABEL_13;
      }
    }
    else
    {
      int v6 = *(_DWORD *)(v5 + 364);
      *(_DWORD *)(v3 + 2228) = v4 & 0xAFFFFFFF;
      if ((v6 & 0x20000) != 0) {
        *(_DWORD *)(v5 + 364) = v6 & 0xFFFDFFFF;
      }
      if ((v4 & 0x50000000) == 0) {
        goto LABEL_13;
      }
    }
    unsigned int v7 = *(void (***)(void))(v5 + 32);
    if (v7)
    {
      uint64_t v8 = *v7;
      if (v8) {
        v8();
      }
    }
  }
LABEL_13:
  unsigned int v9 = *(void **)(a1 + 952);
  if (v9)
  {
    uint64_t v10 = (void *)(a1 + 952);
    do
    {
      int v12 = (void *)*v10;
      uint64_t v13 = (void *)(a1 + 952);
      if ((void *)*v10 != v9)
      {
        do
        {
          uint64_t v14 = v12;
          int v12 = (void *)v12[2];
        }
        while (v12 != v9);
        uint64_t v13 = v14 + 2;
      }
      int v11 = (void *)v9[2];
      *uint64_t v13 = v11;
      nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
      free(v9);
      unsigned int v9 = v11;
    }
    while (v11);
    int v15 = *(_DWORD *)(a1 + 96);
    *(_DWORD *)(a1 + 960) = v15;
  }
  else
  {
    int v15 = *(_DWORD *)(a1 + 96);
  }
  *(_DWORD *)(a1 + 152) = v15 + ((int)(*(_DWORD *)(a1 + 88) << 27) >> 31);
  *(_DWORD *)(a1 + 740) &= ~0x100000u;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 172) = 0;
  *(_DWORD *)(a1 + 144) = *(_DWORD *)(a1 + 148);
}

uint64_t tcp_reset_stretch_ack(uint64_t a1)
{
  *(_DWORD *)(a1 + 88) &= 0x7DFFFFFFu;
  *(void *)(a1 + 328) = 0;
  uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
  *(_DWORD *)(a1 + 324) = *(_DWORD *)(result + 316) + 100;
  *(_DWORD *)(a1 + 740) |= 2u;
  *(_WORD *)(a1 + 344) = 0;
  return result;
}

uint64_t tcp_input_ip_ecn(uint64_t result, uint64_t a2, unsigned int a3, int a4, int a5)
{
  if (a5 != 3)
  {
    if (a5 == 2)
    {
      *(_DWORD *)(result + 348) |= 0x1000000u;
      uint64_t v5 = (void *)(result + 440);
    }
    else
    {
      if (a5 != 1) {
        return result;
      }
      *(_DWORD *)(result + 348) |= 0x800000u;
      uint64_t v5 = (void *)(result + 432);
    }
    goto LABEL_13;
  }
  *(_DWORD *)(result + 416) += a4;
  *(void *)(result + 448) += a3;
  ++*(_DWORD *)(result + 352);
  uint64_t v6 = *(void *)(result + 1056);
  if (v6) {
    ++*(void *)(v6 + 856);
  }
  uint64_t v7 = *(void *)(a2 + 448);
  if (v7)
  {
    uint64_t v8 = (void *)(v7 + 184);
    uint64_t v5 = (void *)(v7 + 568);
    if ((*(unsigned char *)(a2 + 2236) & 2) == 0) {
      uint64_t v5 = v8;
    }
    a3 = 1;
LABEL_13:
    *v5 += a3;
  }
  return result;
}

void tcp_process_accecn(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, char a5)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 428))
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      unint64_t v23 = __nwlog_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        int v24 = 136446210;
        unint64_t v25 = "tcp_process_accecn";
        _os_log_impl(&dword_214653000, v23, OS_LOG_TYPE_DEBUG, "%{public}s already processed AccECN field/options for this ACK", (uint8_t *)&v24, 0xCu);
      }
    }
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 472);
    unsigned int v7 = *(unsigned __int8 *)(a2 + 32);
    if (!*(unsigned char *)(a2 + 32)) {
      goto LABEL_6;
    }
    uint64_t v8 = *(unsigned __int8 **)(a2 + 40);
    int v9 = *(unsigned __int8 *)(a2 + 48);
    uint64_t v10 = 456;
    if (!*(unsigned char *)(a2 + 48)) {
      uint64_t v10 = 464;
    }
    *(void *)(a1 + v10) += (((*v8 << 16) | (v8[1] << 8) | v8[2]) - *(void *)(a1 + v10)) & 0xFFFFFF;
    if (v7 != 1)
    {
      uint64_t v11 = (((v8[3] << 16) | (v8[4] << 8) | v8[5]) - v6) & 0xFFFFFF;
      uint64_t v12 = v6 + v11;
      *(void *)(a1 + 472) = v6 + v11;
      if (v7 >= 3)
      {
        int v19 = (v8[6] << 16) | (v8[7] << 8);
        int v20 = v8[8];
        BOOL v21 = v9 == 0;
        uint64_t v22 = 464;
        if (v21) {
          uint64_t v22 = 456;
        }
        *(void *)(a1 + v22) += ((v19 | v20) - *(void *)(a1 + v22)) & 0xFFFFFF;
      }
    }
    else
    {
LABEL_6:
      uint64_t v11 = 0;
      uint64_t v12 = v6;
    }
    int v13 = *(_DWORD *)(a1 + 420);
    unsigned int v14 = (a5 - (_BYTE)v13) & 7;
    if (a4 >= 8)
    {
      unint64_t v15 = v12 - v6;
      if (v15)
      {
        if (v15 >= (*(_DWORD *)(a1 + 196) * (a4 - (((_BYTE)a4 - (a5 - (_BYTE)v13)) & 7))) >> 1) {
          unsigned int v14 = a4 - (((_BYTE)a4 - (a5 - (_BYTE)v13)) & 7);
        }
      }
    }
    *(_DWORD *)(a1 + 420) = v14 + v13;
    *(_DWORD *)(a1 + 424) = v14;
    if (*(unsigned char *)a2)
    {
      int v16 = *(_DWORD *)(a2 + 8);
      if (v16)
      {
        if (v16 - *(_DWORD *)(a1 + 400) >= 0) {
          *(_DWORD *)(a1 + 400) = v16;
        }
      }
    }
    if (v14)
    {
      *(_DWORD *)(a1 + 348) |= 0x20u;
      *(_DWORD *)(a1 + 292) += v14;
      uint64_t v17 = *(void *)(a1 + 1056);
      if (v17) {
        *(void *)(v17 + 880) += v14;
      }
      *(void *)(a1 + 384) = v14 + v13 - 5;
    }
    BOOL v18 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)]
                                                                           + 104);
    if (v18) {
      v18(a1, a3, v11, *(unsigned int *)(a1 + 292), *(unsigned int *)(a1 + 296));
    }
    *(unsigned char *)(a1 + 428) |= 1u;
  }
}

uint64_t tcp_tfo_syn(uint64_t a1, uint64_t a2)
{
  __s1[2] = *MEMORY[0x263EF8340];
  if ((*(_DWORD *)a2 & 0xC00) == 0 || (*(unsigned char *)(sysctls + 160) & 1) == 0) {
    return 0;
  }
  if ((*(_DWORD *)a2 & 0x800) != 0)
  {
    *(unsigned char *)(a1 + 988) |= 1u;
    *(_WORD *)(a1 + 990) |= 2u;
    uint64_t v8 = *(void *)(a1 + 1056);
    if (v8)
    {
      uint64_t result = 0;
      ++*(void *)(v8 + 1088);
      return result;
    }
    return 0;
  }
  tcp_tfo_gen_cookie(*(void *)(a1 + 80), __s1);
  uint64_t v5 = *(char **)(a2 + 24);
  char v6 = *v5++;
  *(void *)(a2 + 24) = v5;
  if (memcmp(__s1, v5, (v6 - 2)))
  {
    *(unsigned char *)(a1 + 988) |= 1u;
    *(_WORD *)(a1 + 990) |= 8u;
    uint64_t v7 = *(void *)(a1 + 1056);
    if (v7)
    {
      uint64_t result = 0;
      ++*(void *)(v7 + 1096);
      return result;
    }
    return 0;
  }
  signed int v9 = atomic_fetch_add_explicit(&tcp_tfo_halfcnt, 1u, memory_order_relaxed) + 1;
  if (v9 >= *(_DWORD *)(sysctls + 156))
  {
    uint64_t result = 0;
    atomic_fetch_add_explicit(&tcp_tfo_halfcnt, 0xFFFFFFFF, memory_order_relaxed);
  }
  else
  {
    *(unsigned char *)(a1 + 988) |= 2u;
    *(_WORD *)(a1 + 990) |= 1u;
    uint64_t v10 = *(void *)(a1 + 1056);
    if (v10) {
      ++*(void *)(v10 + 1080);
    }
    return 1;
  }
  return result;
}

int64x2_t tcp_input_process_accecn_syn(int64x2_t *a1, int a2, int a3)
{
  if (a2 == 448)
  {
    __int32 v3 = a1[46].i32[1];
    if ((v3 & 0x10000000) == 0
      && ((v3 & 0x8000000) != 0 || (*(_DWORD *)(sysctls + 320) != 1 ? (BOOL v4 = tcp_do_acc_ecn == 1) : (BOOL v4 = 1), v4)))
    {
      switch(a3)
      {
        case 0:
LABEL_22:
          int v7 = a1[21].i32[3] | 0x10000;
          break;
        case 1:
LABEL_24:
          int v7 = a1[21].i32[3] | 0x20000;
          break;
        case 2:
LABEL_25:
          int v7 = a1[21].i32[3] | 0x40000;
          break;
        case 3:
LABEL_26:
          int v7 = a1[21].i32[3] | 0x80000;
          break;
        default:
LABEL_23:
          int v7 = a1[21].i32[3];
          break;
      }
      int64x2_t result = vdupq_n_s64(1uLL);
      a1[21].i32[3] = v7 | 0x200000;
      a1[27] = result;
      a1[28].i64[1] = 1;
      a1[29].i64[0] = 1;
      a1[22].i32[3] = 5;
    }
    else
    {
      a1[21].i32[3] |= 6u;
    }
  }
  else if (a2 == 192)
  {
    a1[21].i32[3] |= 6u;
    a1[22].i32[3] = 4;
  }
  else if (a2)
  {
    __int32 v5 = a1[46].i32[1];
    if ((v5 & 0x10000000) == 0)
    {
      if ((v5 & 0x8000000) != 0 || (*(_DWORD *)(sysctls + 320) != 1 ? (BOOL v6 = tcp_do_acc_ecn == 1) : (BOOL v6 = 1), v6))
      {
        switch(a3)
        {
          case 0:
            goto LABEL_22;
          case 1:
            goto LABEL_24;
          case 2:
            goto LABEL_25;
          case 3:
            goto LABEL_26;
          default:
            goto LABEL_23;
        }
      }
    }
  }
  else
  {
    a1[22].i32[3] = 3;
  }
  return result;
}

uint64_t tcp_tfo_synack(uint64_t a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  if ((*(unsigned char *)(a2 + 1) & 4) != 0)
  {
    uint64_t v11 = *(unsigned __int8 **)(a2 + 24);
    unsigned int v12 = *v11 - 2;
    if (v12 >= 0x11)
    {
      int v28 = __nwlog_obj();
      os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "tcp_tfo_synack";
      uint64_t v29 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = __nwlog_abort();
      if (result)
      {
        __break(1u);
        return result;
      }
      free(v29);
      uint64_t v11 = *(unsigned __int8 **)(a2 + 24);
    }
    *(void *)(a2 + 24) = v11 + 1;
    uint64_t v13 = *(void *)(a1 + 80);
    memset(buf, 0, 18);
    __memcpy_chk();
    buf[16] = v12;
    (*(void (**)(void, uint8_t *))(*(void *)(v13 + 2136) + 56))(*(void *)(v13 + 224), buf);
    uint64_t v14 = *(void *)(a1 + 80);
    memset(buf, 0, 18);
    __int16 v15 = *(_WORD *)(a1 + 990);
    if ((v15 & 0x40) != 0)
    {
      buf[17] = 1;
      uint8_t v16 = 9;
      if ((v15 & 0x10) == 0) {
        goto LABEL_26;
      }
    }
    else
    {
      uint8_t v16 = 8;
      if ((v15 & 0x10) == 0)
      {
LABEL_26:
        uint64_t result = (*(uint64_t (**)(void, uint8_t *))(*(void *)(v14 + 2136) + 56))(*(void *)(v14 + 224), buf);
        __int16 v22 = *(_WORD *)(a1 + 990);
        *(_WORD *)(a1 + 990) = v22 | 0x20;
        uint64_t v23 = *(void *)(a1 + 1056);
        if (v23)
        {
          ++*(void *)(v23 + 1112);
          if ((*(unsigned char *)(a1 + 988) & 8) == 0) {
            return result;
          }
          ++*(void *)(v23 + 1152);
        }
        else if ((*(unsigned char *)(a1 + 988) & 8) == 0)
        {
          return result;
        }
        *(_WORD *)(a1 + 990) = v22 | 0x220;
        return result;
      }
    }
    buf[17] = v16;
    goto LABEL_26;
  }
  if ((*(unsigned char *)(a1 + 743) & 1) != 0 || (*(unsigned char *)(a1 + 988) & 0x10) == 0)
  {
    __int16 v17 = *(_WORD *)(a1 + 990);
    if ((*(unsigned char *)(a1 + 988) & 4) != 0)
    {
      v17 |= 0x400u;
      *(_WORD *)(a1 + 990) = v17;
      uint64_t v18 = *(void *)(a1 + 1056);
      if (v18) {
        ++*(void *)(v18 + 1160);
      }
    }
    uint64_t v19 = *(void *)(a1 + 80);
    memset(buf, 0, 18);
    if ((v17 & 0x40) != 0)
    {
      buf[17] = 1;
      uint8_t v20 = 9;
      if ((v17 & 0x10) == 0) {
        return (*(uint64_t (**)(void, uint8_t *))(*(void *)(v19 + 2136) + 56))(*(void *)(v19 + 224), buf);
      }
    }
    else
    {
      uint8_t v20 = 8;
      if ((v17 & 0x10) == 0) {
        return (*(uint64_t (**)(void, uint8_t *))(*(void *)(v19 + 2136) + 56))(*(void *)(v19 + 224), buf);
      }
    }
    buf[17] = v20;
    return (*(uint64_t (**)(void, uint8_t *))(*(void *)(v19 + 2136) + 56))(*(void *)(v19 + 224), buf);
  }
  *(_WORD *)(a1 + 990) |= 0x100u;
  uint64_t v3 = *(void *)(a1 + 1056);
  if (v3) {
    ++*(void *)(v3 + 1136);
  }
  uint64_t v4 = *(void *)(a1 + 80);
  uint64_t v5 = *(void *)(v4 + 224);
  if (tcp_perf_measurement)
  {
    if (!v5 || (*(unsigned char *)(v5 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        BOOL v6 = __nwlog_tcp_log();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
        {
          int v7 = "";
          if (v5) {
            int v7 = (const char *)(v5 + 604);
          }
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "tcp_heuristic_tfo_loss";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v7;
          uint64_t v8 = v6;
          os_log_type_t v9 = OS_LOG_TYPE_DEBUG;
LABEL_40:
          _os_log_impl(&dword_214653000, v8, v9, "%{public}s %{public}s ", buf, 0x16u);
        }
      }
    }
  }
  else if (!v5 || (*(unsigned char *)(v5 + 828) & 2) == 0)
  {
    int v24 = __nwlog_tcp_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
    {
      unint64_t v25 = "";
      if (v5) {
        unint64_t v25 = (const char *)(v5 + 604);
      }
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "tcp_heuristic_tfo_loss";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v25;
      uint64_t v8 = v24;
      os_log_type_t v9 = OS_LOG_TYPE_INFO;
      goto LABEL_40;
    }
  }
  memset(buf, 0, 18);
  __int16 v26 = *(_WORD *)(a1 + 990);
  if ((v26 & 0x40) == 0)
  {
    uint8_t v27 = 16;
    if ((v26 & 0x10) == 0) {
      return (*(uint64_t (**)(void, uint8_t *))(*(void *)(v4 + 2136) + 56))(*(void *)(*(void *)(a1 + 80) + 224), buf);
    }
    goto LABEL_45;
  }
  buf[17] = 2;
  uint8_t v27 = 18;
  if ((v26 & 0x10) != 0) {
LABEL_45:
  }
    buf[17] = v27;
  return (*(uint64_t (**)(void, uint8_t *))(*(void *)(v4 + 2136) + 56))(*(void *)(*(void *)(a1 + 80) + 224), buf);
}

void tcp_tfo_rcv_probe(uint64_t a1, int a2)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  if (!a2)
  {
    *(unsigned char *)(a1 + 993) = 1;
    int v3 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 316);
    uint64_t v4 = *(unsigned int *)(a1 + 228);
    if (v4 <= (*(_DWORD *)(a1 + 208) + (*(int *)(a1 + 200) >> 3)) >> 2) {
      LODWORD(v4) = (*(_DWORD *)(a1 + 208) + (*(int *)(a1 + 200) >> 3)) >> 2;
    }
    *(_DWORD *)(a1 + 40) = v3 - *(_DWORD *)(a1 + 64) + v4;
    uint64_t v5 = *(void *)(*(void *)(a1 + 80) + 224);
    if (!v5 || (*(unsigned char *)(v5 + 828) & 2) == 0)
    {
      BOOL v6 = __nwlog_tcp_log();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = "";
        if (v5) {
          int v7 = (const char *)(v5 + 604);
        }
        int v8 = *(_DWORD *)(a1 + 40);
        unsigned int v9 = *(_DWORD *)(a1 + 1872) - 1;
        if (v9 > 2) {
          uint64_t v10 = "invalid";
        }
        else {
          uint64_t v10 = off_264217698[v9];
        }
        int v11 = *(_DWORD *)(a1 + 240);
        int v12 = *(_DWORD *)(a1 + 200);
        int v13 = *(_DWORD *)(a1 + 204);
        int v15 = *(_DWORD *)(a1 + 208);
        int v14 = *(_DWORD *)(a1 + 212);
        int v16 = 136449282;
        __int16 v17 = "tcp_tfo_rcv_probe";
        __int16 v18 = 2082;
        uint64_t v19 = v7;
        __int16 v20 = 1024;
        int v21 = v8;
        __int16 v22 = 2082;
        uint64_t v23 = v10;
        __int16 v24 = 1024;
        int v25 = v11;
        __int16 v26 = 1024;
        int v27 = v12 >> 5;
        __int16 v28 = 1024;
        int v29 = ((1000 * v12) >> 5) % 1000;
        __int16 v30 = 1024;
        int v31 = v15 >> 4;
        __int16 v32 = 1024;
        int v33 = ((1000 * v15) >> 4) % 1000;
        __int16 v34 = 1024;
        int v35 = v13 >> 5;
        __int16 v36 = 1024;
        int v37 = ((1000 * v13) >> 5) % 1000;
        __int16 v38 = 1024;
        int v39 = v14 >> 4;
        __int16 v40 = 1024;
        int v41 = ((1000 * v14) >> 4) % 1000;
        _os_log_impl(&dword_214653000, v6, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s UTCPT_KEEP: %u RTT_Cache: %{public}s, rtt_upd: %d, rtt: %u.%03ums, rtt_var: %u.%03ums rtt_nc: %u.%03ums, rtt_var_nc: %u.%03ums", (uint8_t *)&v16, 0x5Cu);
      }
    }
  }
}

uint64_t tcp_newreno_partial_ack(_DWORD *a1, uint64_t a2)
{
  int v4 = a1[25];
  unsigned int v5 = a1[36];
  a1[7] = 0;
  a1[4] = 0;
  a1[43] = 0;
  int v6 = *(_DWORD *)(a2 + 8);
  a1[25] = v6;
  a1[36] = a1[49] + v6 - a1[23];
  uint64_t result = tcp_output((uint64_t)a1);
  if (v4 - a1[25] >= 1) {
    a1[25] = v4;
  }
  unsigned int v8 = *(_DWORD *)(a2 + 8) - a1[23];
  BOOL v9 = v5 >= v8;
  unsigned int v10 = v5 - v8;
  if (!v9) {
    unsigned int v10 = 0;
  }
  a1[36] = v10 + a1[49];
  return result;
}

uint64_t tcp_reass(uint64_t a1, int *a2, uint64_t *a3, uint64_t a4, unsigned int a5, unsigned char *a6, _DWORD *a7)
{
  uint64_t v202 = *MEMORY[0x263EF8340];
  uint64_t v11 = *(void *)(*(void *)(a1 + 80) + 224);
  uint64_t v182 = *(void *)(a1 + 80);
  if (!a4)
  {
    int type = 0;
    int v184 = 0;
    BOOL v185 = 0;
    goto LABEL_10;
  }
  if (*(unsigned __int8 *)(a4 + 1076) == 255 || *(_DWORD *)(a4 + 1024) == 255)
  {
    int v12 = 1;
  }
  else
  {
    if (*(_DWORD *)(a4 + 1068) == 3)
    {
      BOOL v185 = 0;
      int type = 1;
      int v184 = 0;
      goto LABEL_10;
    }
    int v12 = 0;
    if (*(_DWORD *)(a4 + 1032) == 3)
    {
      int type = 1;
      int v184 = 0;
      BOOL v185 = 0;
      goto LABEL_10;
    }
  }
  int v184 = v12;
  int type = 0;
  BOOL v13 = *(_DWORD *)(a4 + 1064) == 2 || *(_DWORD *)(a4 + 1028) == 2;
  BOOL v185 = v13;
LABEL_10:
  uint64_t v188 = nw_tcp_access_globals(v11);
  if (a7) {
    *a7 = 0;
  }
  uint64_t v186 = *a3;
  uint64_t v190 = nw_protocol_tcp_copy_frame(v11, *a3, *a2 + a5);
  uint64_t v14 = *a3;
  uint64_t v192 = v11;
  int v191 = a2;
  if (!*a3)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v195 = "__nw_frame_is_single_ip_aggregate";
    __int16 v156 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v161 = __nwlog_obj();
      if (os_log_type_enabled(v161, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v195 = "__nw_frame_is_single_ip_aggregate";
        _os_log_impl(&dword_214653000, v161, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v156)
    {
      free(v156);
      if (!a5) {
        goto LABEL_47;
      }
LABEL_19:
      uint64_t v20 = *a3;
      if (!*a3) {
        goto LABEL_43;
      }
      goto LABEL_20;
    }
LABEL_18:
    if (!a5) {
      goto LABEL_47;
    }
    goto LABEL_19;
  }
  if ((*(_WORD *)(v14 + 204) & 0x80) == 0) {
    goto LABEL_18;
  }
  unsigned int v15 = *(unsigned __int16 *)(v14 + 196);
  BOOL v16 = v15 >= a5;
  __int16 v17 = v15 - a5;
  if (v16)
  {
    *(_WORD *)(v14 + 196) = v17;
    goto LABEL_18;
  }
  __nwlog_obj();
  int v18 = *(unsigned __int16 *)(v14 + 196);
  *(_DWORD *)long long buf = 136446722;
  uint64_t v195 = "__nw_frame_array_claim";
  __int16 v196 = 1024;
  *(_DWORD *)int v197 = v18;
  *(_WORD *)&v197[4] = 1024;
  *(_DWORD *)&v197[6] = a5;
  uint64_t v19 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    __int16 v30 = __nwlog_obj();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      int v31 = *(unsigned __int16 *)(v14 + 196);
      *(_DWORD *)long long buf = 136446722;
      uint64_t v195 = "__nw_frame_array_claim";
      __int16 v196 = 1024;
      *(_DWORD *)int v197 = v31;
      *(_WORD *)&v197[4] = 1024;
      *(_DWORD *)&v197[6] = a5;
      _os_log_impl(&dword_214653000, v30, OS_LOG_TYPE_ERROR, "%{public}s Aggregate buffer length: %u sum: %u, backtrace limit exceeded", buf, 0x18u);
    }
  }
  if (v19) {
    free(v19);
  }
  *(_WORD *)(v14 + 196) = 0;
  uint64_t v20 = *a3;
  if (!*a3)
  {
LABEL_43:
    unsigned int v21 = 0;
LABEL_44:
    if (v21 != a5)
    {
      __int16 v32 = __nwlog_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446722;
        uint64_t v195 = "__nw_frame_array_claim";
        __int16 v196 = 1024;
        *(_DWORD *)int v197 = v21;
        *(_WORD *)&v197[4] = 1024;
        *(_DWORD *)&v197[6] = a5;
        _os_log_impl(&dword_214653000, v32, OS_LOG_TYPE_ERROR, "%{public}s start_offset %u != start_bytes %u", buf, 0x18u);
      }
    }
    goto LABEL_47;
  }
LABEL_20:
  unsigned int v21 = 0;
  while (1)
  {
    int v22 = *(_DWORD *)(v20 + 52);
    int v23 = *(_DWORD *)(v20 + 56);
    int v24 = *(_DWORD *)(v20 + 60);
    unsigned int v25 = v22 - (v23 + v24);
    if (v25 >= a5 - v21) {
      unsigned int v25 = a5 - v21;
    }
    unsigned int v26 = v22 ? v25 : 0;
    int v27 = v23 + v26;
    if (v23 + v26 <= v22 - v24)
    {
      *(_DWORD *)(v20 + 56) = v27;
    }
    else
    {
      __int16 v28 = __nwlog_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        int v29 = *(_DWORD *)(v20 + 52);
        *(_DWORD *)long long buf = 136446978;
        uint64_t v195 = "__nw_frame_claim_internal";
        __int16 v196 = 1024;
        *(_DWORD *)int v197 = v27;
        *(_WORD *)&v197[4] = 1024;
        *(_DWORD *)&v197[6] = v29;
        *(_WORD *)uint64_t v198 = 1024;
        *(_DWORD *)&v198[2] = v24;
        _os_log_impl(&dword_214653000, v28, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
      }
    }
    v21 += v26;
    if (v21 == a5) {
      break;
    }
    if (v21 < a5)
    {
      uint64_t v20 = *(void *)(v20 + 32);
      if (v20) {
        continue;
      }
    }
    goto LABEL_44;
  }
LABEL_47:
  uint64_t v33 = v190;
  if (!v190)
  {
    uint64_t v39 = v192;
    if (v186)
    {
      __int16 v40 = a7;
      if ((*(_WORD *)(v186 + 204) & 0x100) == 0
        || !*MEMORY[0x263F144B8]
        || (((uint64_t (*)(uint64_t, void))*MEMORY[0x263F144B8])(v186, *(void *)(v186 + 88)) & 1) != 0)
      {
        if (!a7) {
          goto LABEL_64;
        }
        goto LABEL_63;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      uint64_t v195 = "__nw_frame_check_validity";
      __int16 v160 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        char v169 = __nwlog_obj();
        if (os_log_type_enabled(v169, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v195 = "__nw_frame_check_validity";
          _os_log_impl(&dword_214653000, v169, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
        }
      }
      if (v160) {
        free(v160);
      }
      uint64_t v39 = v192;
      __int16 v40 = a7;
    }
    *(void *)(a1 + 1056) = 0;
    if (!v40)
    {
LABEL_64:
      uint64_t v41 = *(void *)(a1 + 1056);
      if (v41) {
        ++*(void *)(v41 + 232);
      }
      if (!v39 || (*(unsigned char *)(v39 + 828) & 2) == 0)
      {
        uint64_t v42 = __nwlog_tcp_log();
        uint64_t result = os_log_type_enabled(v42, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        uint64_t v44 = "";
        if (v39) {
          uint64_t v44 = (const char *)(v39 + 604);
        }
        *(_DWORD *)long long buf = 136446466;
        uint64_t v195 = "tcp_reass";
        __int16 v196 = 2082;
        *(void *)int v197 = v44;
        _os_log_impl(&dword_214653000, v42, OS_LOG_TYPE_ERROR, "%{public}s %{public}s unable to copy frame for reassembly", buf, 0x16u);
      }
      return 0;
    }
LABEL_63:
    *__int16 v40 = 12;
    goto LABEL_64;
  }
  uint64_t v34 = v192;
  uint64_t v35 = a1;
  if ((*(_WORD *)(v190 + 204) & 0x4000) != 0)
  {
    *(_DWORD *)(a1 + 740) |= 0x4000000u;
    int v36 = *(_WORD *)(v190 + 204) & 0xBFFF | (*(unsigned __int8 *)(v190 + 206) << 16);
    *(_WORD *)(v190 + 204) &= ~0x4000u;
    *(unsigned char *)(v190 + 206) = BYTE2(v36);
  }
  if (*(void *)(v190 + 32) && (!v192 || (*(unsigned char *)(v192 + 828) & 2) == 0))
  {
    __nwlog_tcp_log();
    if (v192) {
      int v37 = (const char *)(v192 + 604);
    }
    else {
      int v37 = "";
    }
    *(_DWORD *)long long buf = 136446466;
    uint64_t v195 = "tcp_reass";
    __int16 v196 = 2082;
    *(void *)int v197 = v37;
    __int16 v38 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      unsigned int v45 = __nwlog_tcp_log();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446466;
        uint64_t v195 = "tcp_reass";
        __int16 v196 = 2082;
        *(void *)int v197 = v37;
        _os_log_impl(&dword_214653000, v45, OS_LOG_TYPE_ERROR, "%{public}s %{public}s new_frame has next, backtrace limit exceeded", buf, 0x16u);
      }
    }
    if (v38) {
      free(v38);
    }
    uint64_t v33 = v190;
  }
  uint64_t v46 = *(void *)(v33 + 112);
  if (v46)
  {
    if ((*(_WORD *)(v33 + 204) & 0x100) == 0 || !*MEMORY[0x263F144B8]) {
      goto LABEL_82;
    }
    if (((unsigned int (*)(uint64_t, void))*MEMORY[0x263F144B8])(v33, *(void *)(v33 + 88)))
    {
      uint64_t v46 = *(void *)(v33 + 112);
LABEL_82:
      uint64_t v47 = v46 + *(unsigned int *)(v33 + 56);
      goto LABEL_84;
    }
  }
  uint64_t v47 = 0;
LABEL_84:
  if ((*(_WORD *)(v33 + 204) & 0x80) != 0) {
    *(_WORD *)(v33 + 196) -= a5;
  }
  unsigned int v48 = *(_DWORD *)(v33 + 56) + a5;
  int v49 = *(_DWORD *)(v33 + 60);
  if (v48 > *(_DWORD *)(v33 + 52) - v49)
  {
    uint64_t v50 = __nwlog_obj();
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      int v51 = *(_DWORD *)(v33 + 52);
      *(_DWORD *)long long buf = 136446978;
      uint64_t v195 = "__nw_frame_claim_internal";
      __int16 v196 = 1024;
      *(_DWORD *)int v197 = v48;
      *(_WORD *)&v197[4] = 1024;
      *(_DWORD *)&v197[6] = v51;
      *(_WORD *)uint64_t v198 = 1024;
      *(_DWORD *)&v198[2] = v49;
      _os_log_impl(&dword_214653000, v50, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
    }
    if (!v192) {
      goto LABEL_93;
    }
LABEL_92:
    if ((*(unsigned char *)(v192 + 828) & 2) != 0) {
      goto LABEL_94;
    }
    goto LABEL_93;
  }
  *(_DWORD *)(v33 + 56) = v48;
  if (v192) {
    goto LABEL_92;
  }
LABEL_93:
  if (__nwlog_is_datapath_logging_enabled())
  {
    uint64_t v157 = __nwlog_tcp_log();
    if (os_log_type_enabled(v157, OS_LOG_TYPE_DEBUG))
    {
      __int16 v158 = (const char *)(v192 + 604);
      if (!v192) {
        __int16 v158 = "";
      }
      int v159 = *(_DWORD *)(v33 + 52);
      if (v159) {
        v159 -= *(_DWORD *)(v33 + 56) + *(_DWORD *)(v33 + 60);
      }
      *(_DWORD *)long long buf = 136446978;
      uint64_t v195 = "tcp_reass";
      __int16 v196 = 2082;
      *(void *)int v197 = v158;
      *(_WORD *)&v197[8] = 2048;
      *(void *)uint64_t v198 = v33;
      *(_WORD *)&v198[8] = 1024;
      *(_DWORD *)uint64_t v199 = v159;
      _os_log_impl(&dword_214653000, v157, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s queueing frame %p of length %u", buf, 0x26u);
    }
  }
LABEL_94:
  *(_DWORD *)(a1 + 88) &= 0x7DFFFFFFu;
  *(void *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 324) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 316) + 100;
  *(_DWORD *)(a1 + 740) |= 2u;
  *(_WORD *)(a1 + 344) = 0;
  *(_WORD *)(a1 + 308) = 16;
  if (*(_WORD *)(a1 + 754))
  {
    *(_WORD *)(a1 + 754) = 0;
    *(_DWORD *)(a1 + 744) = 0;
  }
  __int16 v52 = v191;
  if (*(_DWORD *)(v47 + 4) != *(_DWORD *)(a1 + 120))
  {
    unsigned int v53 = *(_DWORD *)(v192 + 492);
    if (v53 >= 0x19000) {
      unsigned int v54 = v53 >> 10;
    }
    else {
      unsigned int v54 = 100;
    }
    if (v54 >= *(_DWORD *)(sysctls + 72) >> 10) {
      LOWORD(v54) = *(_DWORD *)(sysctls + 72) >> 10;
    }
    int v55 = (unsigned __int16)v54;
    if (*(unsigned __int16 *)(a1 + 224) + 1 >= (unsigned __int16)v54)
    {
      uint64_t v72 = *(void *)(a1 + 1056);
      if (v72) {
        ++*(void *)(v72 + 232);
      }
      if ((*(unsigned char *)(v192 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          int v163 = __nwlog_tcp_log();
          if (os_log_type_enabled(v163, OS_LOG_TYPE_DEBUG))
          {
            unsigned int v164 = (const char *)(v192 + 604);
            int v165 = *(_DWORD *)(v47 + 4);
            int v166 = *(_DWORD *)(a1 + 120);
            if (!v192) {
              unsigned int v164 = "";
            }
            int v167 = *(unsigned __int16 *)(a1 + 224);
            *(_DWORD *)long long buf = 136447490;
            uint64_t v195 = "tcp_reass";
            __int16 v196 = 2082;
            *(void *)int v197 = v164;
            *(_WORD *)&v197[8] = 1024;
            *(_DWORD *)uint64_t v198 = v165;
            *(_WORD *)&v198[4] = 1024;
            *(_DWORD *)&v198[6] = v166;
            *(_WORD *)uint64_t v199 = 1024;
            *(_DWORD *)&v199[2] = v167;
            __int16 v200 = 1024;
            int v201 = v55;
            _os_log_impl(&dword_214653000, v163, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s drop due to limit: seq %u rcv_nxt %u reqssqlen %u qlimit %u", buf, 0x2Eu);
          }
        }
      }
      int v73 = *(void (**)(uint64_t, uint64_t, uint64_t))(v33 + 80);
      if (v73)
      {
        uint64_t v74 = *(void *)(v33 + 88);
        *(void *)(v33 + 80) = 0;
        *(void *)(v33 + 88) = 0;
        v73(v33, 1, v74);
      }
      else
      {
        __nwlog_obj();
        *(_DWORD *)long long buf = 136446210;
        uint64_t v195 = "__nw_frame_finalize";
        int v168 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          int v172 = __nwlog_obj();
          if (os_log_type_enabled(v172, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136446210;
            uint64_t v195 = "__nw_frame_finalize";
            _os_log_impl(&dword_214653000, v172, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
          }
        }
        if (v168) {
          free(v168);
        }
      }
      uint64_t result = 0;
      int *v191 = 0;
      return result;
    }
  }
  __int16 v56 = malloc_type_malloc(**(void **)(v188 + 48), 0xB9BAFBABuLL);
  if (!v56)
  {
    uint64_t v67 = *(void *)(a1 + 1056);
    if (v67) {
      ++*(void *)(v67 + 232);
    }
    if ((*(unsigned char *)(v192 + 828) & 2) == 0)
    {
      uint64_t v68 = __nwlog_tcp_log();
      if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
      {
        int v69 = "";
        if (v192) {
          int v69 = (const char *)(v192 + 604);
        }
        *(_DWORD *)long long buf = 136446466;
        uint64_t v195 = "tcp_reass";
        __int16 v196 = 2082;
        *(void *)int v197 = v69;
        _os_log_impl(&dword_214653000, v68, OS_LOG_TYPE_ERROR, "%{public}s %{public}s couldn't allocate memory for tcp_reass_zone", buf, 0x16u);
      }
    }
    unsigned int v70 = *(void (**)(uint64_t, uint64_t, uint64_t))(v33 + 80);
    if (v70)
    {
      uint64_t v71 = *(void *)(v33 + 88);
      *(void *)(v33 + 80) = 0;
      *(void *)(v33 + 88) = 0;
      v70(v33, 1, v71);
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      uint64_t v195 = "__nw_frame_finalize";
      __int16 v162 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        int v171 = __nwlog_obj();
        if (os_log_type_enabled(v171, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v195 = "__nw_frame_finalize";
          _os_log_impl(&dword_214653000, v171, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
        }
      }
      if (v162) {
        free(v162);
      }
    }
    return 0;
  }
  int v57 = v56;
  ++*(_WORD *)(a1 + 224);
  uint64_t v58 = *(void **)a1;
  int v59 = *(_DWORD *)(v47 + 4);
  if (!*(void *)a1)
  {
    unsigned int v64 = 0;
    int v65 = 0;
    int v187 = 1;
    uint64_t v60 = v182;
    BOOL v61 = v185;
    int v63 = type;
    int v62 = v184;
    goto LABEL_129;
  }
  uint64_t v60 = v182;
  BOOL v61 = v185;
  int v63 = type;
  int v62 = v184;
  if (*(_DWORD *)(v58[3] + 4) - v59 > 0)
  {
    unsigned int v64 = 0;
    int v65 = 0;
    int v187 = 1;
    goto LABEL_129;
  }
  do
  {
    unsigned int v64 = v58;
    uint64_t v58 = (void *)*v58;
  }
  while (v58 && *(_DWORD *)(v58[3] + 4) - v59 < 1);
  uint64_t v66 = (*((_DWORD *)v64 + 4) + *(_DWORD *)(v64[3] + 4) - v59);
  if ((int)v66 < 1)
  {
    int v187 = 0;
    int v65 = 0;
    goto LABEL_129;
  }
  if (v66 == 1)
  {
    int v65 = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 940) = v59;
    uint64_t v106 = *v191;
    if (v66 < v106) {
      LODWORD(v106) = v66;
    }
    *(_DWORD *)(a1 + 944) = v106 + v59;
    int v65 = 1;
  }
  uint64_t v107 = *v191;
  if ((int)v66 >= (int)v107)
  {
    uint64_t v113 = *(void *)(a1 + 1056);
    if (v113)
    {
      uint64_t v114 = *(void *)(v113 + 216) + v107;
      ++*(void *)(v113 + 208);
      *(void *)(v113 + 216) = v114;
    }
    __int16 v115 = *(void **)(v182 + 248);
    ++*v115;
    if (v184)
    {
      ++**(void **)(v182 + 256);
      if (!type) {
        goto LABEL_206;
      }
    }
    else if (!type)
    {
LABEL_206:
      if (!v185) {
        goto LABEL_208;
      }
      goto LABEL_207;
    }
    ++**(void **)(v182 + 264);
    if (!v185)
    {
LABEL_208:
      v115[1] += v107;
      if (v184)
      {
        *(void *)(*(void *)(v182 + 256) + 8) += v107;
        if (!type) {
          goto LABEL_210;
        }
      }
      else if (!type)
      {
LABEL_210:
        if (!v185) {
          goto LABEL_212;
        }
        goto LABEL_211;
      }
      *(void *)(*(void *)(v182 + 264) + 8) += v107;
      if (!v185)
      {
LABEL_212:
        *(_DWORD *)(a1 + 704) += v107;
        if (*(void *)(v192 + 24))
        {
          uint64_t all_stats = nw_protocol_tcp_get_all_stats();
          if (all_stats) {
            *(_DWORD *)(all_stats + 48) += *v191;
          }
        }
        if ((*(unsigned char *)(v192 + 828) & 2) == 0)
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            uint64_t v173 = __nwlog_tcp_log();
            if (os_log_type_enabled(v173, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v174 = (const char *)(v192 + 604);
              int v175 = *(_DWORD *)(v64[3] + 4);
              if (!v192) {
                uint64_t v174 = "";
              }
              int v176 = *((_DWORD *)v64 + 4);
              int v177 = *(_DWORD *)(v47 + 4);
              *(_DWORD *)long long buf = 136447234;
              uint64_t v195 = "tcp_reass";
              __int16 v196 = 2082;
              *(void *)int v197 = v174;
              *(_WORD *)&v197[8] = 1024;
              *(_DWORD *)uint64_t v198 = v175;
              *(_WORD *)&v198[4] = 1024;
              *(_DWORD *)&v198[6] = v176;
              *(_WORD *)uint64_t v199 = 1024;
              *(_DWORD *)&v199[2] = v177;
              _os_log_impl(&dword_214653000, v173, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s It's a duplicate segment: tqe_seq %u tqe_len %u th_seq %u", buf, 0x28u);
            }
          }
        }
        int v117 = *(void (**)(uint64_t, uint64_t, uint64_t))(v190 + 80);
        if (v117)
        {
          uint64_t v118 = *(void *)(v190 + 88);
          *(void *)(v190 + 80) = 0;
          *(void *)(v190 + 88) = 0;
          v117(v190, 1, v118);
        }
        else
        {
          __nwlog_obj();
          *(_DWORD *)long long buf = 136446210;
          uint64_t v195 = "__nw_frame_finalize";
          int v178 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            int v180 = __nwlog_obj();
            if (os_log_type_enabled(v180, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 136446210;
              uint64_t v195 = "__nw_frame_finalize";
              _os_log_impl(&dword_214653000, v180, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
            }
          }
          if (v178) {
            free(v178);
          }
          uint64_t v35 = a1;
        }
        free(v57);
        --*(_WORD *)(v35 + 224);
        goto LABEL_259;
      }
LABEL_211:
      *(void *)(*(void *)(v182 + 272) + 8) += v107;
      goto LABEL_212;
    }
LABEL_207:
    ++**(void **)(v182 + 272);
    goto LABEL_208;
  }
  if ((*(_WORD *)(v190 + 204) & 0x80) != 0) {
    *(_WORD *)(v190 + 196) -= v66;
  }
  unsigned int v108 = *(_DWORD *)(v190 + 56) + v66;
  int v109 = *(_DWORD *)(v190 + 60);
  if (v108 <= *(_DWORD *)(v190 + 52) - v109)
  {
    *(_DWORD *)(v190 + 56) = v108;
  }
  else
  {
    uint64_t v110 = __nwlog_obj();
    BOOL v111 = os_log_type_enabled(v110, OS_LOG_TYPE_ERROR);
    int v63 = type;
    int v62 = v184;
    BOOL v61 = v185;
    uint64_t v60 = v182;
    if (v111)
    {
      int v112 = *(_DWORD *)(v190 + 52);
      *(_DWORD *)long long buf = 136446978;
      uint64_t v195 = "__nw_frame_claim_internal";
      __int16 v196 = 1024;
      *(_DWORD *)int v197 = v108;
      *(_WORD *)&v197[4] = 1024;
      *(_DWORD *)&v197[6] = v112;
      *(_WORD *)uint64_t v198 = 1024;
      *(_DWORD *)&v198[2] = v109;
      _os_log_impl(&dword_214653000, v110, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
      int v63 = type;
      int v62 = v184;
      BOOL v61 = v185;
      uint64_t v60 = v182;
    }
  }
  int v187 = 0;
  __int16 v52 = v191;
  *v191 -= v66;
  int v59 = *(_DWORD *)(v47 + 4) + v66;
  *(_DWORD *)(v47 + 4) = v59;
  uint64_t v34 = v192;
LABEL_129:
  if (v59 != *(_DWORD *)(a1 + 120))
  {
    ++*(_DWORD *)(a1 + 996);
    uint64_t v75 = *(void *)(a1 + 1056);
    uint64_t v76 = *v52;
    if (v75)
    {
      uint64_t v77 = *(void *)(v75 + 264) + v76;
      ++*(void *)(v75 + 256);
      *(void *)(v75 + 264) = v77;
    }
    *(_DWORD *)(a1 + 708) += v76;
  }
  int v78 = *(void **)(v60 + 248);
  ++*v78;
  if (v62)
  {
    ++**(void **)(v60 + 256);
    if (!v63) {
      goto LABEL_135;
    }
  }
  else if (!v63)
  {
LABEL_135:
    if (!v61) {
      goto LABEL_137;
    }
    goto LABEL_136;
  }
  ++**(void **)(v60 + 264);
  if (v61) {
LABEL_136:
  }
    ++**(void **)(v60 + 272);
LABEL_137:
  uint64_t v79 = *v52;
  v78[1] += v79;
  if (v62)
  {
    *(void *)(*(void *)(v60 + 256) + 8) += v79;
    if (!v63) {
      goto LABEL_139;
    }
  }
  else if (!v63)
  {
LABEL_139:
    int v189 = v57;
    if (v61) {
      goto LABEL_140;
    }
    goto LABEL_147;
  }
  *(void *)(*(void *)(v60 + 264) + 8) += v79;
  int v189 = v57;
  if (v61)
  {
LABEL_140:
    *(void *)(*(void *)(v60 + 272) + 8) += v79;
    if (!*(void *)(v34 + 24)) {
      goto LABEL_150;
    }
LABEL_148:
    uint64_t v80 = nw_protocol_tcp_get_all_stats();
    if (v80) {
      *(_DWORD *)(v80 + 52) += *v52;
    }
    goto LABEL_150;
  }
LABEL_147:
  if (*(void *)(v34 + 24)) {
    goto LABEL_148;
  }
LABEL_150:
  if (v58)
  {
    if (v192) {
      uint64_t v81 = (const char *)(v192 + 604);
    }
    else {
      uint64_t v81 = "";
    }
    do
    {
      int v82 = *v191 + *(_DWORD *)(v47 + 4);
      uint64_t v83 = v58[3];
      int v84 = *(_DWORD *)(v83 + 4);
      uint64_t v85 = (v82 - v84);
      if ((int)v85 < 1) {
        break;
      }
      if (v65 || v85 == 1)
      {
        LODWORD(v86) = *((_DWORD *)v58 + 4);
      }
      else if (*(_DWORD *)(a1 + 940))
      {
        uint64_t v86 = *((int *)v58 + 4);
        if (v85 >= v86) {
          int v87 = *((_DWORD *)v58 + 4);
        }
        else {
          int v87 = v82 - v84;
        }
        *(_DWORD *)(a1 + 944) += v87;
      }
      else
      {
        *(_DWORD *)(a1 + 940) = v84;
        uint64_t v86 = *((int *)v58 + 4);
        if (v85 >= v86) {
          int v88 = *((_DWORD *)v58 + 4);
        }
        else {
          int v88 = v82 - v84;
        }
        *(_DWORD *)(a1 + 944) = v88 + v84;
      }
      if ((int)v86 > (int)v85)
      {
        *(_DWORD *)(v83 + 4) = v82;
        *((_DWORD *)v58 + 4) = v86 - v85;
        uint64_t v102 = v58[4];
        if (v102)
        {
          if ((*(_WORD *)(v102 + 204) & 0x80) != 0)
          {
            unsigned int v103 = *(unsigned __int16 *)(v102 + 196);
            if (v85 <= v103)
            {
              *(_WORD *)(v102 + 196) = v103 - v85;
            }
            else
            {
              __nwlog_obj();
              int v104 = *(unsigned __int16 *)(v102 + 196);
              *(_DWORD *)long long buf = 136446722;
              uint64_t v195 = "__nw_frame_array_claim";
              __int16 v196 = 1024;
              *(_DWORD *)int v197 = v104;
              *(_WORD *)&v197[4] = 1024;
              *(_DWORD *)&v197[6] = v85;
              os_log_type_t v105 = (void *)_os_log_send_and_compose_impl();
              if (__nwlog_fault())
              {
                __int16 v119 = __nwlog_obj();
                if (os_log_type_enabled(v119, OS_LOG_TYPE_ERROR))
                {
                  int v120 = *(unsigned __int16 *)(v102 + 196);
                  *(_DWORD *)long long buf = 136446722;
                  uint64_t v195 = "__nw_frame_array_claim";
                  __int16 v196 = 1024;
                  *(_DWORD *)int v197 = v120;
                  *(_WORD *)&v197[4] = 1024;
                  *(_DWORD *)&v197[6] = v85;
                  _os_log_impl(&dword_214653000, v119, OS_LOG_TYPE_ERROR, "%{public}s Aggregate buffer length: %u sum: %u, backtrace limit exceeded", buf, 0x18u);
                }
              }
              if (v105) {
                free(v105);
              }
              *(_WORD *)(v102 + 196) = 0;
            }
          }
        }
        else
        {
          __nwlog_obj();
          *(_DWORD *)long long buf = 136446210;
          uint64_t v195 = "__nw_frame_is_single_ip_aggregate";
          int v170 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            int v179 = __nwlog_obj();
            if (os_log_type_enabled(v179, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 136446210;
              uint64_t v195 = "__nw_frame_is_single_ip_aggregate";
              _os_log_impl(&dword_214653000, v179, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
            }
          }
          if (v170) {
            free(v170);
          }
        }
        uint64_t v121 = v58[4];
        if (v121)
        {
          unsigned int v122 = 0;
          while (1)
          {
            int v123 = *(_DWORD *)(v121 + 52);
            int v124 = *(_DWORD *)(v121 + 56);
            int v125 = *(_DWORD *)(v121 + 60);
            unsigned int v126 = v123 - (v124 + v125);
            if (v126 >= v85 - v122) {
              unsigned int v126 = v85 - v122;
            }
            unsigned int v127 = v123 ? v126 : 0;
            int v128 = v124 + v127;
            if (v124 + v127 <= v123 - v125)
            {
              *(_DWORD *)(v121 + 56) = v128;
            }
            else
            {
              uint64_t v129 = __nwlog_obj();
              if (os_log_type_enabled(v129, OS_LOG_TYPE_ERROR))
              {
                int v130 = *(_DWORD *)(v121 + 52);
                *(_DWORD *)long long buf = 136446978;
                uint64_t v195 = "__nw_frame_claim_internal";
                __int16 v196 = 1024;
                *(_DWORD *)int v197 = v128;
                *(_WORD *)&v197[4] = 1024;
                *(_DWORD *)&v197[6] = v130;
                *(_WORD *)uint64_t v198 = 1024;
                *(_DWORD *)&v198[2] = v125;
                _os_log_impl(&dword_214653000, v129, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
              }
            }
            v122 += v127;
            if (v122 == v85) {
              break;
            }
            if (v122 < v85)
            {
              uint64_t v121 = *(void *)(v121 + 32);
              if (v121) {
                continue;
              }
            }
            goto LABEL_250;
          }
        }
        else
        {
          unsigned int v122 = 0;
LABEL_250:
          uint64_t v131 = __nwlog_obj();
          if (os_log_type_enabled(v131, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136446722;
            uint64_t v195 = "__nw_frame_array_claim";
            __int16 v196 = 1024;
            *(_DWORD *)int v197 = v122;
            *(_WORD *)&v197[4] = 1024;
            *(_DWORD *)&v197[6] = v85;
            _os_log_impl(&dword_214653000, v131, OS_LOG_TYPE_ERROR, "%{public}s start_offset %u != start_bytes %u", buf, 0x18u);
          }
        }
        break;
      }
      uint64_t v89 = (void *)*v58;
      if (*v58) {
        v89[1] = v58[1];
      }
      *(void *)v58[1] = v89;
      uint64_t v90 = a1;
      if (!v192 || (*(unsigned char *)(v192 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          BOOL v97 = __nwlog_tcp_log();
          if (os_log_type_enabled(v97, OS_LOG_TYPE_DEBUG))
          {
            int v98 = *(_DWORD *)(v58[3] + 4);
            int v99 = *(_DWORD *)(v47 + 4);
            int v100 = *((_DWORD *)v58 + 4);
            int v101 = *v191;
            *(_DWORD *)long long buf = 136447490;
            uint64_t v195 = "tcp_reass";
            __int16 v196 = 2082;
            *(void *)int v197 = v81;
            *(_WORD *)&v197[8] = 1024;
            *(_DWORD *)uint64_t v198 = v98;
            *(_WORD *)&v198[4] = 1024;
            *(_DWORD *)&v198[6] = v99;
            *(_WORD *)uint64_t v199 = 1024;
            *(_DWORD *)&v199[2] = v100;
            __int16 v200 = 1024;
            int v201 = v101;
            _os_log_impl(&dword_214653000, v97, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s dropping a completely overlapping segment: tqe_seq %u th_seq %u tqe_len %u tlen %u", buf, 0x2Eu);
          }
        }
      }
      long long v91 = (void *)v58[4];
      if (v91)
      {
        do
        {
          while (1)
          {
            os_log_type_t v92 = (void (*)(void *, uint64_t, uint64_t))v91[10];
            long long v93 = (void *)v91[4];
            if (!v92) {
              break;
            }
            uint64_t v94 = v91[11];
            v91[10] = 0;
            v91[11] = 0;
            v92(v91, 1, v94);
            long long v91 = v93;
            if (!v93) {
              goto LABEL_154;
            }
          }
          __nwlog_obj();
          *(_DWORD *)long long buf = 136446210;
          uint64_t v195 = "__nw_frame_finalize";
          long long v95 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            long long v96 = __nwlog_obj();
            if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 136446210;
              uint64_t v195 = "__nw_frame_finalize";
              _os_log_impl(&dword_214653000, v96, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
            }
          }
          if (v95) {
            free(v95);
          }
          uint64_t v90 = a1;
          long long v91 = v93;
        }
        while (v93);
      }
LABEL_154:
      free(v58);
      --*(_WORD *)(v90 + 224);
      uint64_t v58 = v89;
    }
    while (v89);
  }
  *(void *)(v190 + 32) = 0;
  *(void *)(v190 + 40) = v189 + 4;
  v189[4] = v190;
  v189[5] = v190 + 32;
  v189[3] = v47;
  *((_DWORD *)v189 + 4) = *v191;
  if (v187)
  {
    uint64_t v35 = a1;
    uint64_t v132 = *(void **)a1;
    void *v189 = *(void *)a1;
    if (v132) {
      v132[1] = v189;
    }
    *(void *)a1 = v189;
    v189[1] = a1;
  }
  else
  {
    uint64_t v133 = *v64;
    void *v189 = *v64;
    uint64_t v35 = a1;
    if (v133) {
      *(void *)(*v64 + 8) = v189;
    }
    *unsigned int v64 = v189;
    v189[1] = v64;
  }
LABEL_259:
  if (*(int *)(v35 + 12) < 4) {
    return 0;
  }
  int v134 = *(void **)v35;
  if (!*(void *)v35) {
    return 0;
  }
  uint64_t v135 = v134[3];
  int v136 = *(_DWORD *)(v135 + 4);
  if (v136 != *(_DWORD *)(v35 + 120)) {
    return 0;
  }
  int v137 = *(_DWORD *)(v35 + 740);
  if ((v137 & 0x800000) != 0) {
    return 0;
  }
  *(_DWORD *)(v35 + 740) = v137 | 0x800000;
  uint64_t v138 = *(void *)(v35 + 1056);
  if (v138) {
    ++*(void *)(v138 + 1616);
  }
  int v139 = 0;
  if (v192) {
    BOOL v140 = (const char *)(v192 + 604);
  }
  else {
    BOOL v140 = "";
  }
  uint64_t v141 = a1;
  do
  {
    *(_DWORD *)(v141 + 120) = v136 + *((_DWORD *)v134 + 4);
    char v142 = *(unsigned char *)(v135 + 13);
    uint64_t v143 = *v134;
    if (*v134) {
      *(void *)(v143 + 8) = v134[1];
    }
    *(void *)v134[1] = v143;
    if ((*(_WORD *)(v192 + 376) & 0x20) == 0)
    {
      int v144 = *(_DWORD *)(a1 + 740);
      unsigned int v145 = v144 & 0xFFFFFFEF | (16 * ((*(unsigned __int8 *)(v134[3] + 13) >> 3) & 1));
      *(_DWORD *)(a1 + 740) = v145;
      if ((v144 & 0x4000000) != 0)
      {
        *(_DWORD *)(a1 + 740) = v145 & 0xFBFFFFFF;
        nw_frame_array_first();
        nw_frame_set_is_wake_packet();
        if ((*(unsigned char *)(v192 + 828) & 2) == 0)
        {
          int v146 = __nwlog_tcp_log();
          if (os_log_type_enabled(v146, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)long long buf = 136446466;
            uint64_t v195 = "tcp_reass";
            __int16 v196 = 2082;
            *(void *)int v197 = v140;
            _os_log_impl(&dword_214653000, v146, OS_LOG_TYPE_INFO, "%{public}s %{public}s reassembled segment is wake packet", buf, 0x16u);
          }
        }
      }
      uint64_t v147 = v134[4];
      if (v147)
      {
        signed int v148 = 0;
        do
        {
          int v149 = *(_DWORD *)(v147 + 52);
          if (v149) {
            v149 -= *(_DWORD *)(v147 + 56) + *(_DWORD *)(v147 + 60);
          }
          v148 += v149;
          uint64_t v147 = *(void *)(v147 + 32);
        }
        while (v147);
      }
      else
      {
        signed int v148 = 0;
      }
      if (tcp_input_sbappendstream(v192, v134 + 4, v148, 0)) {
        int v139 = 1;
      }
    }
    __int16 v150 = (void *)v134[4];
    if (v150)
    {
      do
      {
        while (1)
        {
          __int16 v151 = (void (*)(void *, uint64_t, uint64_t))v150[10];
          int v152 = (void *)v150[4];
          if (!v151) {
            break;
          }
          uint64_t v153 = v150[11];
          v150[10] = 0;
          v150[11] = 0;
          v151(v150, 1, v153);
          __int16 v150 = v152;
          if (!v152) {
            goto LABEL_294;
          }
        }
        __nwlog_obj();
        *(_DWORD *)long long buf = 136446210;
        uint64_t v195 = "__nw_frame_finalize";
        __int16 v154 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          unsigned int v155 = __nwlog_obj();
          if (os_log_type_enabled(v155, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136446210;
            uint64_t v195 = "__nw_frame_finalize";
            _os_log_impl(&dword_214653000, v155, OS_LOG_TYPE_ERROR, "%{public}s called with null frame->finalizer, backtrace limit exceeded", buf, 0xCu);
          }
        }
        if (v154) {
          free(v154);
        }
        __int16 v150 = v152;
      }
      while (v152);
    }
LABEL_294:
    free(v134);
    uint64_t v141 = a1;
    --*(_WORD *)(a1 + 224);
    int v134 = *(void **)a1;
    if (!*(void *)a1) {
      break;
    }
    uint64_t v135 = v134[3];
    int v136 = *(_DWORD *)(v135 + 4);
  }
  while (v136 == *(_DWORD *)(a1 + 120));
  uint64_t result = v142 & 1;
  *(_DWORD *)(a1 + 740) &= ~0x800000u;
  if (a6)
  {
    if (v139) {
      *a6 = 1;
    }
  }
  return result;
}

uint64_t tcp_bad_rexmt_restore_state(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 88);
  if ((~v3 & 0x180) != 0)
  {
    *(void *)(a1 + 144) = *(void *)(a1 + 504);
    if ((v3 & 0x400000) == 0)
    {
LABEL_25:
      *(_DWORD *)(a1 + 984) = 0;
      unsigned int v9 = *(_DWORD *)(a1 + 144);
      goto LABEL_26;
    }
    *(_DWORD *)(a1 + 88) = v3 | 0x200000;
    uint64_t v10 = *(void *)(a1 + 80);
    int v11 = *(_DWORD *)(v10 + 2228);
    if ((v11 & 0x40000000) != 0)
    {
      uint64_t v12 = *(void *)(v10 + 224);
      if ((v11 & 0x10000000) == 0)
      {
        int v13 = *(_DWORD *)(v12 + 364);
        *(_DWORD *)(v10 + 2228) = v11 & 0xAFFFFFFF;
        if ((v13 & 0x20000) != 0) {
          *(_DWORD *)(v12 + 364) = v13 & 0xFFFDFFFF;
        }
        if ((v11 & 0x50000000) == 0) {
          goto LABEL_18;
        }
        goto LABEL_15;
      }
      *(_DWORD *)(v10 + 2228) = v11 & 0xAFFFFFFF;
      *(_DWORD *)(v12 + 364) &= ~0x20000u;
      if ((v11 & 0x50000000) != 0)
      {
LABEL_15:
        uint64_t v14 = *(void (***)(void))(v12 + 32);
        if (v14)
        {
          unsigned int v15 = *v14;
          if (v15) {
            v15();
          }
        }
      }
    }
LABEL_18:
    BOOL v16 = *(void **)(a1 + 952);
    if (v16)
    {
      __int16 v17 = (void *)(a1 + 952);
      do
      {
        uint64_t v19 = (void *)*v17;
        uint64_t v20 = (void *)(a1 + 952);
        if ((void *)*v17 != v16)
        {
          do
          {
            unsigned int v21 = v19;
            uint64_t v19 = (void *)v19[2];
          }
          while (v19 != v16);
          uint64_t v20 = v21 + 2;
        }
        int v18 = (void *)v16[2];
        *uint64_t v20 = v18;
        nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
        free(v16);
        BOOL v16 = v18;
      }
      while (v18);
      *(_DWORD *)(a1 + 960) = *(_DWORD *)(a1 + 96);
    }
    goto LABEL_25;
  }
  int v4 = *(_DWORD *)(a2 + 8);
  int v5 = *(_DWORD *)(a1 + 96) - v4;
  unsigned int v6 = v4 - *(_DWORD *)(a1 + 92);
  *(_DWORD *)(a1 + 148) = *(_DWORD *)(a1 + 508);
  int v7 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 40);
  if (v7) {
    v7(a1);
  }
  unsigned int v8 = *(_DWORD *)(a1 + 144);
  if (v6 < v8) {
    unsigned int v8 = v6;
  }
  unsigned int v9 = v5 + v8;
LABEL_26:
  uint64_t v22 = sysctls;
  if (*(_DWORD *)(sysctls + 304))
  {
    unsigned int v23 = *(_DWORD *)(a1 + 196) * *(_DWORD *)(sysctls + 16);
    if (v9 > v23) {
      goto LABEL_34;
    }
LABEL_31:
    unsigned int v9 = v23;
    goto LABEL_34;
  }
  if (*(_DWORD *)(sysctls + 276))
  {
    unsigned int v23 = 10 * *(_DWORD *)(a1 + 196);
    if (v9 > v23) {
      goto LABEL_34;
    }
    goto LABEL_31;
  }
  if (v9 <= 0x111C) {
    unsigned int v9 = 4380;
  }
LABEL_34:
  *(_DWORD *)(a1 + 144) = v9;
  *(_DWORD *)(a1 + 152) = *(_DWORD *)(a1 + 512);
  *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 96);
  uint64_t v24 = *(void *)(*(void *)(a1 + 80) + 224);
  int v25 = *(_DWORD *)(v24 + 432);
  if ((~v25 & 0xC00) == 0)
  {
    uint64_t v26 = *(int *)(v22 + 232);
    if (v26 <= *(unsigned int *)(a1 + 148)) {
      LODWORD(v26) = *(_DWORD *)(a1 + 148);
    }
    unsigned int v27 = *(_DWORD *)(v22 + 120);
    if (v26 < v27) {
      unsigned int v27 = v26;
    }
    *(_DWORD *)(v24 + 436) = v27;
    if (*(_DWORD *)(v24 + 388) <= v27)
    {
      if (v27 <= 0x71C71C)
      {
        *(_DWORD *)(v24 + 388) = v27;
        uint64_t v28 = *(void *)(*(void *)(v24 + 456) + 24);
        if ((v25 & 4) != 0)
        {
          if (v28)
          {
            uint64_t all_stats = nw_protocol_tcp_get_all_stats();
            if (all_stats) {
              *(_DWORD *)(all_stats + 88) = *(_DWORD *)(v24 + 388);
            }
          }
        }
        else if (v28)
        {
          uint64_t v29 = nw_protocol_tcp_get_all_stats();
          if (v29) {
            *(_DWORD *)(v29 + 100) = *(_DWORD *)(v24 + 388);
          }
        }
        unsigned int v31 = *(_DWORD *)(v24 + 388);
        if (*(_DWORD *)(v24 + 392) > v31) {
          *(_DWORD *)(v24 + 392) = v31;
        }
      }
      *(_DWORD *)(v24 + 432) &= ~0x800u;
    }
  }
  int v32 = *(_DWORD *)(a1 + 740);
  if ((v32 & 0x20400020) == 0x20000020)
  {
    char v33 = *(unsigned char *)(a1 + 2069);
    if ((v33 & 0x1Fu) >= 0xF) {
      char v34 = 16;
    }
    else {
      char v34 = (v33 + 1) & 0x1F;
    }
    *(unsigned char *)(a1 + 2069) = v33 & 0xC0 | v34 | 0x20;
  }
  *(_DWORD *)(a1 + 740) = v32 | 0x40;
  uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
  *(_DWORD *)(a1 + 532) = *(_DWORD *)(result + 316);
  *(_DWORD *)(a1 + 172) = 0;
  return result;
}

void tcp_set_foreground_cc(uint64_t a1)
{
  if (*(_DWORD *)(sysctls + 20))
  {
    int v1 = 1;
  }
  else if (*(_DWORD *)(sysctls + 304))
  {
    int v1 = 2;
  }
  else
  {
    int v2 = *(_DWORD *)(*(void *)(*(void *)a1 + 240) + 740);
    if ((v2 & 0x10000000) == 0
      && ((v2 & 0x8000000) != 0 || (*(_DWORD *)(sysctls + 336) != 1 ? (BOOL v3 = tcp_do_l4s == 1) : (BOOL v3 = 1), v3)))
    {
      int v1 = 4;
    }
    else
    {
      int v1 = 3;
    }
  }
  tcp_set_new_cc(a1, v1);
}

uint64_t tcp_usr_preconnect(_DWORD *a1)
{
  uint64_t result = tcp_output(*(void *)(*(void *)a1 + 240));
  if ((a1[92] & 0x30) != 0) {
    a1[92] &= a1[92] & 0x10 ^ 0xFFFFFFDF;
  }
  return result;
}

uint64_t tcp_usr_shutdown(uint64_t a1)
{
  uint64_t v1 = *(void *)a1;
  if (!*(void *)a1 || *(_DWORD *)(v1 + 232) == 3) {
    return 22;
  }
  *(_WORD *)(a1 + 376) |= 0x10u;
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    int v5 = *(void (**)(uint64_t))(v4 + 16);
    if (v5) {
      v5(a1);
    }
  }
  uint64_t v6 = *(void *)(v1 + 240);
  if (!v6) {
    return 0;
  }
  uint64_t v7 = nw_tcp_access_globals(a1);
  calculate_tcp_clock(v7);
  uint64_t result = tcp_usrclosed(v6, v8);
  if (result)
  {
    return tcp_output(result);
  }
  return result;
}

uint64_t tcp6_connect(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a1 + 80);
  uint64_t v5 = *(void *)(v4 + 224);
  if (!*(_WORD *)(v4 + 2226))
  {
    if (*(_DWORD *)(v4 + 480) || *(_DWORD *)(v4 + 484) || *(_DWORD *)(v4 + 488) || *(_DWORD *)(v4 + 492))
    {
      uint64_t v20 = 22;
      goto LABEL_49;
    }
    int v25 = 0;
    memset(v24, 0, sizeof(v24));
    uint64_t v20 = (*(uint64_t (**)(uint64_t, void, uint64_t, void *, uint64_t))(*(void *)(v4 + 2136) + 8))(v5, 0, 28, v24, 28);
    if (v20) {
      goto LABEL_49;
    }
    if (vmaxv_u16((uint16x4_t)vmovn_s32(vtstq_s32(*(int32x4_t *)&v24[1], *(int32x4_t *)&v24[1])))) {
      *(_OWORD *)(v4 + 480) = *(_OWORD *)&v24[1];
    }
    *(_WORD *)(v4 + 2226) = WORD1(v24[0]);
  }
  if (*(unsigned char *)a2 != 28)
  {
    uint64_t v20 = 22;
    if (v5) {
      goto LABEL_44;
    }
    goto LABEL_45;
  }
  if (*(unsigned char *)(a2 + 1) != 30)
  {
    uint64_t v20 = 47;
    if (v5) {
      goto LABEL_44;
    }
LABEL_45:
    unsigned int v21 = __nwlog_tcp_log();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      uint64_t v22 = "";
      if (v5) {
        uint64_t v22 = (const char *)(v5 + 604);
      }
      LODWORD(v24[0]) = 136446466;
      *(void *)((char *)v24 + 4) = "tcp6_connect";
      WORD2(v24[1]) = 2082;
      *(void *)((char *)&v24[1] + 6) = v22;
      _os_log_impl(&dword_214653000, v21, OS_LOG_TYPE_ERROR, "%{public}s %{public}s ipv6 pcb local address lookup failed", (uint8_t *)v24, 0x16u);
    }
    goto LABEL_49;
  }
  if (!*(_WORD *)(a2 + 2))
  {
    uint64_t v20 = 49;
    if (!v5) {
      goto LABEL_45;
    }
LABEL_44:
    if ((*(unsigned char *)(v5 + 828) & 2) == 0) {
      goto LABEL_45;
    }
LABEL_49:
    tcp_drop(a1, v20);
    return v20;
  }
  *(_OWORD *)(v4 + 464) = *(_OWORD *)(a2 + 8);
  *(_WORD *)(v4 + 2224) = *(_WORD *)(a2 + 2);
  if (!*(_DWORD *)(v4 + 460))
  {
    int v6 = inp_calc_flowhash_flow_hash++;
    *(_DWORD *)(v4 + 460) = v6;
  }
  uint64_t v7 = *(int *)(sysctls + 184);
  if (v7 <= *(unsigned __int8 *)(a1 + 262)) {
    LOBYTE(v7) = *(unsigned char *)(a1 + 262);
  }
  uint64_t v8 = (int *)(sysctls + 72);
  if ((*(unsigned char *)(v5 + 537) & 2) != 0) {
    uint64_t v8 = (int *)(v5 + 492);
  }
  int v9 = *v8;
  unsigned int v10 = v7;
  if (v7 <= 0xDu && 0x10000 << v7 < v9)
  {
    do
    {
      LOBYTE(v7) = v10 + 1;
      if (v10 > 0xC) {
        break;
      }
      int v12 = 0x20000 << v10++;
    }
    while (v12 < v9);
  }
  if (v7 >= 0xEu) {
    LOBYTE(v7) = 14;
  }
  *(unsigned char *)(a1 + 262) = v7;
  *(_WORD *)(v5 + 376) = *(_WORD *)(v5 + 376) & 0xFFF1 | 4;
  uint64_t v13 = *(void *)(a1 + 1056);
  if (v13) {
    ++*(void *)(v13 + 376);
  }
  *(_DWORD *)(a1 + 12) = 2;
  if (*(void *)(v5 + 24))
  {
    uint64_t all_stats = nw_protocol_tcp_get_all_stats();
    if (all_stats) {
      *(_DWORD *)(all_stats + 136) = 2;
    }
  }
  int v15 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 316);
  int v16 = *(_DWORD *)(a1 + 680);
  if (!v16) {
    int v16 = *(_DWORD *)(sysctls + 188);
  }
  *(_DWORD *)(a1 + 40) = v16 + v15 - *(_DWORD *)(a1 + 64);
  int v17 = tcp_new_isn(a1);
  *(_DWORD *)(a1 + 112) = v17;
  *(_DWORD *)(a1 + 152) = v17;
  *(_DWORD *)(a1 + 96) = v17;
  *(_DWORD *)(a1 + 100) = v17;
  *(_DWORD *)(a1 + 92) = v17;
  if (!*(void *)(v5 + 24)) {
    return 0;
  }
  uint64_t v18 = nw_protocol_tcp_get_all_stats();
  if (v18) {
    *(_DWORD *)(v18 + 108) = *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92);
  }
  if (!*(void *)(v5 + 24)) {
    return 0;
  }
  uint64_t v19 = nw_protocol_tcp_get_all_stats();
  uint64_t v20 = 0;
  if (v19) {
    ++*(_DWORD *)(v19 + 60);
  }
  return v20;
}

uint64_t tcp_usr_rcvoob()
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v4 = "tcp_usr_rcvoob";
  uint64_t v0 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    uint64_t v1 = __nwlog_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v4 = "tcp_usr_rcvoob";
      _os_log_impl(&dword_214653000, v1, OS_LOG_TYPE_ERROR, "%{public}s currently not supported, backtrace limit exceeded", buf, 0xCu);
    }
  }
  if (v0) {
    free(v0);
  }
  return 0;
}

uint64_t tcp_usr_listen(uint64_t *a1)
{
  v8[2] = *MEMORY[0x263EF8340];
  uint64_t v1 = *a1;
  if (!*a1 || *(_DWORD *)(v1 + 232) == 3) {
    return 22;
  }
  uint64_t v4 = *(void *)(v1 + 240);
  uint64_t v5 = nw_tcp_access_globals(*(void *)(v1 + 224));
  double v6 = calculate_tcp_clock(v5);
  if (*(_WORD *)(v1 + 2226)) {
    goto LABEL_6;
  }
  if (*(_DWORD *)(v1 + 492)) {
    return 22;
  }
  v8[0] = 0;
  v8[1] = 0;
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t, void *, uint64_t, double))(*(void *)(v1 + 2136) + 8))(*(void *)(v1 + 224), 0, 16, v8, 16, v6);
  if (!result)
  {
    if (HIDWORD(v8[0])) {
      *(_DWORD *)(v1 + 492) = HIDWORD(v8[0]);
    }
    *(_WORD *)(v1 + 2226) = WORD1(v8[0]);
LABEL_6:
    *(_DWORD *)(v4 + 12) = 1;
    uint64_t result = a1[3];
    if (result)
    {
      uint64_t result = nw_protocol_tcp_get_all_stats();
      if (result)
      {
        uint64_t v7 = result;
        uint64_t result = 0;
        *(_DWORD *)(v7 + 136) = 1;
      }
    }
  }
  return result;
}

uint64_t tcp_usr_abort(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (!*a1 || *(_DWORD *)(v1 + 232) == 3) {
    return 22;
  }
  uint64_t v4 = *(void *)(v1 + 240);
  uint64_t v5 = nw_tcp_access_globals(*(void *)(v1 + 224));
  calculate_tcp_clock(v5);
  if (!v4) {
    return 0;
  }
  tcp_drop(v4, 53);
  int v6 = *((_DWORD *)a1 + 90);
  if (v6 > 0)
  {
LABEL_6:
    uint64_t result = 0;
    *((_DWORD *)a1 + 90) = v6 - 1;
    return result;
  }
  uint64_t v7 = __nwlog_obj();
  os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
  uint64_t v8 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!result)
  {
    free(v8);
    int v6 = *((_DWORD *)a1 + 90);
    goto LABEL_6;
  }
  __break(1u);
  return result;
}

uint64_t tcp6_usr_listen(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (!*a1 || *(_DWORD *)(v1 + 232) == 3) {
    return 22;
  }
  uint64_t v4 = *(void *)(v1 + 240);
  uint64_t v5 = nw_tcp_access_globals(*(void *)(v1 + 224));
  v6.n128_f64[0] = calculate_tcp_clock(v5);
  if (*(_WORD *)(v1 + 2226)) {
    goto LABEL_6;
  }
  char v8 = *(unsigned char *)(v1 + 2236);
  *(unsigned char *)(v1 + 2236) = v8 & 0xFE;
  if ((*(unsigned char *)(v1 + 2229) & 0x80) == 0) {
    *(unsigned char *)(v1 + 2236) = v8 | 1;
  }
  if (*(_DWORD *)(v1 + 480) || *(_DWORD *)(v1 + 484) || *(_DWORD *)(v1 + 488) || *(_DWORD *)(v1 + 492)) {
    return 22;
  }
  int v11 = 0;
  int32x4_t v10 = 0uLL;
  uint64_t v9 = 0;
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t *, uint64_t, __n128))(*(void *)(v1 + 2136) + 8))(*(void *)(v1 + 224), 0, 28, &v9, 28, v6);
  if (!result)
  {
    if (vmaxv_u16((uint16x4_t)vmovn_s32(vtstq_s32(v10, v10)))) {
      *(int32x4_t *)(v1 + 480) = v10;
    }
    *(_WORD *)(v1 + 2226) = WORD1(v9);
LABEL_6:
    *(_DWORD *)(v4 + 12) = 1;
    uint64_t result = a1[3];
    if (result)
    {
      uint64_t result = nw_protocol_tcp_get_all_stats();
      if (result)
      {
        uint64_t v7 = result;
        uint64_t result = 0;
        *(_DWORD *)(v7 + 136) = 1;
      }
    }
  }
  return result;
}

uint64_t tcp6_usr_connect(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)a1;
  if (!*(void *)a1) {
    return 22;
  }
  if (*(_DWORD *)(v2 + 232) == 3)
  {
    uint64_t v4 = *(unsigned __int16 *)(a1 + 378);
    if (*(_WORD *)(a1 + 378))
    {
      *(_WORD *)(a1 + 378) = 0;
      __nwlog_obj();
      uint64_t v5 = a1 + 604;
      *(_DWORD *)long long buf = 136446722;
      *(void *)int v15 = "tcp6_usr_connect";
      *(_WORD *)&v15[8] = 2082;
      *(void *)&v15[10] = a1 + 604;
      __int16 v16 = 1024;
      int v17 = v4;
      __n128 v6 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        int v12 = __nwlog_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136446722;
          *(void *)int v15 = "tcp6_usr_connect";
          *(_WORD *)&v15[8] = 2082;
          *(void *)&v15[10] = v5;
          __int16 v16 = 1024;
          int v17 = v4;
          _os_log_impl(&dword_214653000, v12, OS_LOG_TYPE_ERROR, "%{public}s %{public}s this should be handled by user_north_signal_error %{darwin.errno}d, backtrace limit exceeded", buf, 0x1Cu);
        }
      }
      if (v6) {
        free(v6);
      }
      return v4;
    }
    return 22;
  }
  uint64_t v8 = *(void *)(v2 + 240);
  if ((*(unsigned char *)(a1 + 368) & 0x10) != 0 && (*(unsigned char *)(sysctls + 160) & 2) != 0) {
    *(_DWORD *)(v8 + 740) |= 0x400000u;
  }
  uint64_t v9 = nw_tcp_access_globals(a1);
  calculate_tcp_clock(v9);
  if (*(unsigned char *)(a2 + 1) && (*(unsigned char *)(a2 + 1) != 30 || *(unsigned __int8 *)(a2 + 8) == 255)) {
    return 47;
  }
  if (!*(_DWORD *)(a2 + 8) && !*(_DWORD *)(a2 + 12) && *(_DWORD *)(a2 + 16) == -65536)
  {
    if ((*(unsigned char *)(v2 + 2229) & 0x80) == 0)
    {
      *(void *)&v15[4] = 0;
      *(_WORD *)long long buf = 528;
      *(_WORD *)&buf[2] = *(_WORD *)(a2 + 2);
      *(_DWORD *)int v15 = *(_DWORD *)(a2 + 20);
      *(unsigned char *)(v2 + 2236) = *(unsigned char *)(v2 + 2236) & 0xFC | 1;
      uint64_t v4 = tcp_connect(v8, (uint64_t)buf);
      if (!v4) {
        return tcp_connect_complete(a1);
      }
      return v4;
    }
    return 22;
  }
  *(unsigned char *)(v2 + 2236) = *(unsigned char *)(v2 + 2236) & 0xFC | 2;
  uint64_t v4 = tcp6_connect(v8, a2);
  if (v4) {
    return v4;
  }
  uint64_t v10 = *(void *)(*(void *)a1 + 240);
  (*(void (**)(void))(*(void *)(*(void *)(v10 + 80) + 2136) + 64))(*(void *)(a1 + 24));
  if ((*(unsigned char *)(a1 + 368) & 0x20) != 0)
  {
    tcp_mss(v10, -1, 0);
    uint64_t v4 = 0;
    int v13 = *(_DWORD *)(v10 + 196);
    *(_DWORD *)(v10 + 140) = v13;
    *(_DWORD *)(v10 + 252) = v13;
    return v4;
  }

  return tcp_output(v10);
}

uint64_t tcp_connect_complete(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)a1 + 240);
  (*(void (**)(void))(*(void *)(*(void *)(v2 + 80) + 2136) + 64))(*(void *)(a1 + 24));
  if ((*(unsigned char *)(a1 + 368) & 0x20) != 0)
  {
    tcp_mss(v2, -1, 0);
    int v4 = *(_DWORD *)(v2 + 196);
    *(_DWORD *)(v2 + 140) = v4;
    *(_DWORD *)(v2 + 252) = v4;
    return 0;
  }
  else
  {
    return tcp_output(v2);
  }
}

uint64_t tcp6_usr_bind(uint64_t *a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v2 = *a1;
  if (!*a1 || *(_DWORD *)(v2 + 232) == 3) {
    return 22;
  }
  uint64_t v4 = nw_tcp_access_globals(*(void *)(v2 + 224));
  v5.n128_f64[0] = calculate_tcp_clock(v4);
  if (*(unsigned char *)(a2 + 1) && (*(unsigned char *)(a2 + 1) != 30 || *(unsigned __int8 *)(a2 + 8) == 255)) {
    return 47;
  }
  char v6 = *(unsigned char *)(v2 + 2236);
  *(unsigned char *)(v2 + 2236) = v6 & 0xFC | 2;
  if ((*(unsigned char *)(v2 + 2229) & 0x80) == 0 && !*(_DWORD *)(a2 + 8) && !*(_DWORD *)(a2 + 12))
  {
    int v8 = *(_DWORD *)(a2 + 16);
    if (v8 == -65536)
    {
      v10.i64[0] = 0;
      LOWORD(v9) = 528;
      WORD1(v9) = *(_WORD *)(a2 + 2);
      HIDWORD(v9) = *(_DWORD *)(a2 + 20);
      *(unsigned char *)(v2 + 2236) = v6 & 0xFC | 1;
      return in_pcbbind(v2, &v9);
    }
    if (!v8 && !*(_DWORD *)(a2 + 20)) {
      *(unsigned char *)(v2 + 2236) = v6 | 3;
    }
  }
  if (*(_WORD *)(v2 + 2226)) {
    return 22;
  }
  if (*(_DWORD *)(v2 + 480)) {
    return 22;
  }
  if (*(_DWORD *)(v2 + 484)) {
    return 22;
  }
  if (*(_DWORD *)(v2 + 488)) {
    return 22;
  }
  if (*(_DWORD *)(v2 + 492)) {
    return 22;
  }
  uint64_t v9 = 0;
  int32x4_t v10 = 0uLL;
  int v11 = 0;
  if (*(unsigned char *)a2 != 28) {
    return 22;
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *, uint64_t, __n128))(*(void *)(v2 + 2136) + 8))(*(void *)(v2 + 224), a2, 28, &v9, 28, v5);
  if (!result)
  {
    if (vmaxv_u16((uint16x4_t)vmovn_s32(vtstq_s32(v10, v10)))) {
      *(int32x4_t *)(v2 + 480) = v10;
    }
    uint64_t result = 0;
    *(_WORD *)(v2 + 2226) = WORD1(v9);
  }
  return result;
}

void inp_flush()
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  BOOL v3 = "inp_flush";
  uint64_t v0 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    uint64_t v1 = __nwlog_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446210;
      BOOL v3 = "inp_flush";
      _os_log_impl(&dword_214653000, v1, OS_LOG_TYPE_ERROR, "%{public}s currently unsupported, backtrace limit exceeded", buf, 0xCu);
    }
  }
  if (v0) {
    free(v0);
  }
}

uint64_t tcp_setpersist(uint64_t a1)
{
  int v2 = (*(_DWORD *)(a1 + 208) + (*(int *)(a1 + 200) >> 2)) >> 1;
  if (*(_DWORD *)(a1 + 312) && !*(_DWORD *)(a1 + 36) && !*(_DWORD *)(a1 + 316)) {
    *(_DWORD *)(a1 + 316) = *(_DWORD *)(a1 + 312)
  }
                          + *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 316);
  unsigned int v3 = tcp_backoff[*(unsigned __int16 *)(a1 + 226)] * v2;
  *(_DWORD *)(a1 + 36) = v3;
  if (v3 >> 3 >= 0x271)
  {
    if (v3 < 0xEA61) {
      goto LABEL_10;
    }
    int v4 = 60000;
  }
  else
  {
    int v4 = 5000;
  }
  *(_DWORD *)(a1 + 36) = v4;
LABEL_10:
  uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 36) + *(_DWORD *)(result + 316) - *(_DWORD *)(a1 + 64);
  unsigned int v6 = *(unsigned __int16 *)(a1 + 226);
  if (v6 <= 0xB) {
    *(_WORD *)(a1 + 226) = v6 + 1;
  }
  return result;
}

uint64_t __tcp_ip_output_send_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  if (a2)
  {
    int v4 = *(_DWORD *)(a2 + 52);
    if (v4)
    {
      int v5 = v4 - (*(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60));
      if (!*(void *)(a1 + 32)) {
        return 1;
      }
    }
    else
    {
      int v5 = 0;
      if (!*(void *)(a1 + 32)) {
        return 1;
      }
    }
    uint64_t v6 = *(void *)(a2 + 112);
    uint64_t v7 = (void *)MEMORY[0x263F144B8];
    if (v6
      && ((*(_WORD *)(a2 + 204) & 0x100) == 0
       || !*MEMORY[0x263F144B8]
       || ((unsigned int (*)(uint64_t, void))*MEMORY[0x263F144B8])(a2, *(void *)(a2 + 88))
       && (uint64_t v6 = *(void *)(a2 + 112)) != 0))
    {
      int v8 = (unsigned __int16 *)(v6 + *(unsigned int *)(a2 + 56));
      uint64_t v9 = *(void *)(a1 + 40);
      if (!v9 || (*(unsigned char *)(v9 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          uint64_t v12 = __nwlog_tcp_log();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            if (v9) {
              int v13 = (const char *)(v9 + 604);
            }
            else {
              int v13 = "";
            }
            unsigned int v14 = bswap32(*v8) >> 16;
            unsigned int v15 = bswap32(v8[1]) >> 16;
            int v16 = *((unsigned __int8 *)v8 + 13);
            unsigned int v17 = bswap32(*((_DWORD *)v8 + 1));
            unsigned int v18 = bswap32(*((_DWORD *)v8 + 2));
            unsigned int v19 = bswap32(v8[7]) >> 16;
            uint64_t v20 = *(_DWORD **)(a1 + 32);
            int v21 = v20[3];
            int v24 = v20[30];
            unsigned int v25 = v18;
            int v26 = v20[23];
            uint64_t v22 = packet_service_class_to_str(*(_DWORD *)(a2 + 176));
            *(_DWORD *)long long buf = 136449282;
            uint64_t v28 = "tcp_ip_output_send_block_invoke";
            __int16 v29 = 2082;
            __int16 v30 = v13;
            __int16 v31 = 1024;
            unsigned int v32 = v14;
            __int16 v33 = 1024;
            unsigned int v34 = v15;
            __int16 v35 = 1024;
            int v36 = v5;
            __int16 v37 = 1024;
            int v38 = v16;
            __int16 v39 = 1024;
            unsigned int v40 = v17;
            __int16 v41 = 1024;
            unsigned int v42 = v25;
            __int16 v43 = 1024;
            unsigned int v44 = v19;
            __int16 v45 = 1024;
            int v46 = v21;
            __int16 v47 = 1024;
            int v48 = v24;
            __int16 v49 = 1024;
            int v50 = v26;
            __int16 v51 = 2082;
            __int16 v52 = v22;
            _os_log_impl(&dword_214653000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s sending frame, %u:%u tlen %u flags=%{network:tcp_flags}x seq=%u, ack=%u, win=%u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u svc %{public}s", buf, 0x5Cu);
          }
        }
      }
    }
    else if ((*(_WORD *)(a2 + 204) & 0x100) != 0 {
           && *v7
    }
           && (((uint64_t (*)(uint64_t, void))*v7)(a2, *(void *)(a2 + 88)) & 1) == 0)
    {
      *(void *)(*(void *)(a1 + 32) + 1056) = 0;
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v28 = "__nw_frame_unclaimed_length";
    int v11 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      unsigned int v23 = __nwlog_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v28 = "__nw_frame_unclaimed_length";
        _os_log_impl(&dword_214653000, v23, OS_LOG_TYPE_ERROR, "%{public}s called with null frame, backtrace limit exceeded", buf, 0xCu);
      }
    }
    if (v11) {
      free(v11);
    }
  }
  return 1;
}

uint64_t __tcp_ip_output_send_block_invoke_7(uint64_t a1, uint64_t a2)
{
  ++*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (a2 && *(void *)(a1 + 40))
  {
    int v4 = (void *)MEMORY[0x263F144B8];
    if (*(void *)(a2 + 112)
      && ((*(_WORD *)(a2 + 204) & 0x100) == 0
       || !*MEMORY[0x263F144B8]
       || ((unsigned int (*)(uint64_t, void))*MEMORY[0x263F144B8])(a2, *(void *)(a2 + 88))
       && *(void *)(a2 + 112)))
    {
      if (*MEMORY[0x263F144B0] != -1) {
        dispatch_once(MEMORY[0x263F144B0], &__block_literal_global_489);
      }
      if (*MEMORY[0x263F144A8] && kdebug_is_enabled()) {
        kdebug_trace();
      }
    }
    else if ((*(_WORD *)(a2 + 204) & 0x100) != 0 {
           && *v4
    }
           && (((uint64_t (*)(uint64_t, void))*v4)(a2, *(void *)(a2 + 88)) & 1) == 0)
    {
      *(void *)(*(void *)(a1 + 40) + 1056) = 0;
    }
  }
  return 1;
}

uint64_t ____nw_signpost_is_enabled_block_invoke_496()
{
  uint64_t result = networkd_settings_get_BOOL();
  *MEMORY[0x263F144A8] = result;
  return result;
}

void tcp_sack_doack(uint64_t a1, uint64_t a2, int a3, _DWORD *a4, _DWORD *a5)
{
  *(void *)&v72[28] = *MEMORY[0x263EF8340];
  if (*(unsigned char *)a2) {
    int v9 = *(_DWORD *)(a2 + 8);
  }
  else {
    int v9 = 0;
  }
  int v10 = *(_DWORD *)(a1 + 740);
  if ((v10 & 0x20400020) == 0x20000020 || *(_DWORD *)(a1 + 92) - a3 >= 0 || !*(void *)(a1 + 544))
  {
    int v11 = 0;
    uint64_t v12 = *(unsigned __int8 *)(a2 + 15);
    if (!*(unsigned char *)(a2 + 15)) {
      goto LABEL_22;
    }
  }
  else
  {
    v71[0] = *(_DWORD *)(a1 + 92);
    v71[1] = a3;
    int v11 = 1;
    uint64_t v12 = *(unsigned __int8 *)(a2 + 15);
    if (!*(unsigned char *)(a2 + 15)) {
      goto LABEL_22;
    }
  }
  int v13 = *(int8x8_t **)(a2 + 16);
  do
  {
    int8x8_t v14 = vrev32_s8(*v13);
    if (v14.i32[1] - v14.i32[0] >= 1)
    {
      int v15 = *(_DWORD *)(a1 + 92);
      if (v14.i32[0] - v15 >= 1 && v14.i32[0] - a3 >= 1)
      {
        int v17 = *(_DWORD *)(a1 + 96);
        int v18 = v14.i32[1] - v15;
        BOOL v19 = v14.i32[1] - v17 > 0 || v18 < 1;
        if (!v19 && v14.i32[0] - v17 < 0) {
          *(int8x8_t *)&v71[2 * v11++] = v14;
        }
      }
    }
    ++v13;
    --v12;
  }
  while (v12);
LABEL_22:
  if (!v11) {
    return;
  }
  if (v11 >= 6)
  {
    uint64_t v67 = __nwlog_obj();
    os_log_type_enabled(v67, OS_LOG_TYPE_ERROR);
    int v69 = 136446210;
    unsigned int v70 = "tcp_sack_doack";
    uint64_t v68 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }
    free(v68);
  }
  else if (v11 < 1)
  {
    goto LABEL_33;
  }
  uint64_t v20 = 0;
  int v21 = v72;
  uint64_t v22 = 1;
  do
  {
    uint64_t v23 = v20 + 1;
    if (v20 + 1 < (unint64_t)v11)
    {
      int v24 = &v71[2 * v20];
      unsigned int v25 = v21;
      uint64_t v26 = v11;
      do
      {
        int v27 = v24[1];
        if (v27 - *v25 >= 1)
        {
          int v28 = *v24;
          *(void *)int v24 = *(void *)(v25 - 1);
          *(v25 - 1) = v28;
          *unsigned int v25 = v27;
        }
        --v26;
        v25 += 2;
      }
      while (v22 != v26);
    }
    ++v22;
    v21 += 8;
    uint64_t v20 = v23;
  }
  while (v23 != v11);
  int v10 = *(_DWORD *)(a1 + 740);
LABEL_33:
  if ((v10 & 0x20400020) == 0x20000020)
  {
    __int16 v29 = &v71[2 * v11 - 2];
    *a5 = v29[1];
    if (v11 >= 1)
    {
      do
      {
        unint64_t v30 = *(void *)(a1 + 2000);
        if (!v30) {
          goto LABEL_37;
        }
        int v32 = *v29;
        int v31 = v29[1];
        uint64_t v33 = *(void *)(a1 + 2000);
        do
        {
          while (1)
          {
            int v34 = *(_DWORD *)(v33 + 4);
            if (v31 - v34 >= 0) {
              break;
            }
            uint64_t v33 = *(void *)(v33 + 32);
            if (!v33) {
              goto LABEL_44;
            }
          }
          if (v31 == v34)
          {
            tcp_segs_dosack_matched(a1, (int *)v33, *v29, v9, a4);
            goto LABEL_37;
          }
          uint64_t v33 = *(void *)(v33 + 40);
        }
        while (v33);
        do
        {
LABEL_44:
          unint64_t v35 = v30;
          unint64_t v30 = *(void *)(v30 + 32);
        }
        while (v30);
        do
        {
          while (1)
          {
LABEL_53:
            unint64_t v38 = v35;
            if (v31 - *(_DWORD *)(v35 + 4) < 0 && v31 - *(_DWORD *)v35 >= 1)
            {
              if (v32 - *(_DWORD *)v35 >= 1) {
                int v39 = *v29;
              }
              else {
                int v39 = *(_DWORD *)v35;
              }
              unsigned int v40 = tcp_seg_sent_insert_before(a1, v35, v39, v29[1], *(_DWORD *)(v35 + 8), *(unsigned char *)(v35 + 12));
              unsigned int v41 = *((unsigned __int8 *)v40 + 12);
              tcp_seg_mark_sacked((_DWORD *)a1, (uint64_t)v40, a4);
              tcp_rack_update_segment_acked(a1, v9, *((_DWORD *)v40 + 2), *((_DWORD *)v40 + 1), (v41 >> 3) & 1);
              int v42 = *(_DWORD *)v38;
              if (v32 != *(_DWORD *)v38)
              {
                if (v32 - *(_DWORD *)v38 >= 1)
                {
                  tcp_seg_sent_insert_before(a1, (uint64_t)v40, v42, v32, *(_DWORD *)(v38 + 8), *(unsigned char *)(v38 + 12));
                  *(_DWORD *)unint64_t v38 = v31;
                  goto LABEL_37;
                }
                uint64_t v43 = *(void *)(a1 + 2000);
                if (v43)
                {
                  while (1)
                  {
                    while (1)
                    {
                      int v44 = *(_DWORD *)(v43 + 4);
                      if (v42 - v44 >= 0) {
                        break;
                      }
                      uint64_t v43 = *(void *)(v43 + 32);
                      if (!v43) {
                        goto LABEL_59;
                      }
                    }
                    if (v42 == v44) {
                      break;
                    }
                    uint64_t v43 = *(void *)(v43 + 40);
                    if (!v43) {
                      goto LABEL_59;
                    }
                  }
                  tcp_segs_dosack_matched(a1, (int *)v43, v32, v9, a4);
                }
              }
LABEL_59:
              *(_DWORD *)unint64_t v38 = v31;
              goto LABEL_37;
            }
            unint64_t v36 = *(void *)(v35 + 40);
            if (!v36) {
              break;
            }
            do
            {
              unint64_t v35 = v36;
              unint64_t v36 = *(void *)(v36 + 32);
            }
            while (v36);
          }
          unint64_t v35 = *(void *)(v35 + 48) & 0xFFFFFFFFFFFFFFFELL;
        }
        while (v35 && *(void *)(v35 + 32) == v38);
        while (1)
        {
          unint64_t v35 = *(void *)(v38 + 48) & 0xFFFFFFFFFFFFFFFELL;
          if (!v35) {
            break;
          }
          BOOL v37 = v38 == *(void *)(v35 + 40);
          unint64_t v38 = *(void *)(v38 + 48) & 0xFFFFFFFFFFFFFFFELL;
          if (!v37) {
            goto LABEL_53;
          }
        }
LABEL_37:
        v29 -= 2;
      }
      while (v29 >= v71);
    }
    return;
  }
  if (*(void *)(a1 + 544))
  {
    int v45 = *(_DWORD *)(a1 + 560);
  }
  else
  {
    if (*(_DWORD *)(a1 + 92) - a3 <= 0) {
      int v45 = a3;
    }
    else {
      int v45 = *(_DWORD *)(a1 + 92);
    }
    *(_DWORD *)(a1 + 560) = v45;
  }
  uint64_t v46 = v11 - 1;
  __int16 v47 = &v71[2 * v46];
  if (v45 - *v47 < 0)
  {
    if (tcp_sackhole_insert(a1, v45, *v47, 0))
    {
      int v49 = v71[2 * v46 + 1];
      *(_DWORD *)(a1 + 560) = v49;
      int v50 = *v47;
      v47 -= 2;
      *a4 += v49 - v50;
    }
    else if (v11 >= 1)
    {
      int v65 = *(_DWORD *)(a1 + 560);
      while (v65 - *v47 < 0)
      {
        v47 -= 2;
        if (v47 < v71) {
          goto LABEL_81;
        }
      }
      int v66 = v47[1];
      if (v65 - v66 < 0)
      {
        *a4 += v66 - v65;
        *(_DWORD *)(a1 + 560) = v66;
      }
    }
  }
  else
  {
    int v48 = v47[1];
    if (v45 - v48 < 0)
    {
      *a4 += v48 - v45;
      *(_DWORD *)(a1 + 560) = v48;
    }
  }
LABEL_81:
  if (v47 >= v71)
  {
    uint64_t v51 = **(void **)(*(void *)(a1 + 552) + 8);
    if (v51)
    {
      do
      {
        while (1)
        {
          while (1)
          {
            int v52 = *v47;
            int v53 = *(_DWORD *)(v51 + 4);
            if (*v47 - v53 >= 0) {
              goto LABEL_104;
            }
            int v54 = v47[1];
            int v55 = *(_DWORD *)v51;
            int v56 = v54 - *(_DWORD *)v51;
            if (v56 > 0) {
              break;
            }
            uint64_t v51 = **(void **)(*(void *)(v51 + 24) + 8);
            if (!v51) {
              return;
            }
          }
          int v57 = v55 - *(_DWORD *)(v51 + 8) + *(_DWORD *)(a1 + 624);
          *(_DWORD *)(a1 + 624) = v57 & ~(v57 >> 31);
          int v58 = v54 - v53;
          if (v52 - v55 <= 0) {
            break;
          }
          if (v58 < 0)
          {
            tcp_sack_detect_reordering(a1, (_DWORD *)v51, v54, v45);
            unsigned int v64 = tcp_sackhole_insert(a1, v47[1], *(_DWORD *)(v51 + 4), v51);
            if (v64)
            {
              *a4 += v47[1] - *v47;
              int v62 = *(_DWORD *)(v51 + 8);
              if (v62 - v64[2] >= 1)
              {
                v64[2] = v62;
                *(_DWORD *)(a1 + 624) += v62 - *v64;
                int v62 = *(_DWORD *)(v51 + 8);
              }
              if (v62 - *v47 >= 0) {
                int v62 = *v47;
              }
              *(_DWORD *)(v51 + 4) = *v47;
              *(_DWORD *)(v51 + 8) = v62;
              v64[3] = *(_DWORD *)(v51 + 12);
            }
            else
            {
              int v62 = *(_DWORD *)(v51 + 8);
            }
          }
          else
          {
            *a4 += v53 - v52;
            tcp_sack_detect_reordering(a1, (_DWORD *)v51, *(_DWORD *)(v51 + 4), v45);
            int v62 = *(_DWORD *)(v51 + 8);
            if (v62 - *v47 >= 0) {
              int v62 = *v47;
            }
            *(_DWORD *)(v51 + 4) = *v47;
            *(_DWORD *)(v51 + 8) = v62;
          }
LABEL_103:
          int v63 = *(_DWORD *)v51;
          *(_DWORD *)(a1 + 624) += v62 - *(_DWORD *)v51;
          if (*v47 - v63 <= 0)
          {
            uint64_t v51 = **(void **)(*(void *)(v51 + 24) + 8);
            if (v47 < v71) {
              return;
            }
            goto LABEL_107;
          }
LABEL_104:
          v47 -= 2;
          if (v47 < v71) {
            return;
          }
LABEL_107:
          if (!v51) {
            return;
          }
        }
        if (v58 < 0)
        {
          *a4 += v56;
          tcp_sack_detect_reordering(a1, (_DWORD *)v51, v47[1], v45);
          int v62 = v47[1];
          *(_DWORD *)uint64_t v51 = v62;
          if (*(_DWORD *)(v51 + 8) - v62 > 0) {
            int v62 = *(_DWORD *)(v51 + 8);
          }
          *(_DWORD *)(v51 + 8) = v62;
          goto LABEL_103;
        }
        *a4 += v53 - v55;
        tcp_sack_detect_reordering(a1, (_DWORD *)v51, *(_DWORD *)(v51 + 4), v45);
        uint64_t v60 = *(void *)(v51 + 16);
        uint64_t v59 = *(void *)(v51 + 24);
        uint64_t v61 = **(void **)(v59 + 8);
        if (*(void *)(a1 + 616) == v51)
        {
          *(void *)(a1 + 616) = v60;
          if (!v60)
          {
LABEL_93:
            *(void *)(a1 + 552) = v59;
            goto LABEL_94;
          }
        }
        else if (!v60)
        {
          goto LABEL_93;
        }
        *(void *)(v60 + 24) = v59;
        uint64_t v59 = *(void *)(v51 + 24);
LABEL_94:
        *(void *)uint64_t v59 = v60;
        nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
        free((void *)v51);
        --*(_WORD *)(a1 + 538);
        atomic_fetch_add_explicit(tcp_sack_globalholes, 0xFFFFFFFF, memory_order_relaxed);
        uint64_t v51 = v61;
      }
      while (v61);
    }
  }
}

_DWORD *tcp_sackhole_insert(uint64_t a1, int a2, int a3, uint64_t a4)
{
  if (*(_DWORD *)(sysctls + 140) <= *(__int16 *)(a1 + 538) || tcp_sack_globalholes[0] >= *(_DWORD *)(sysctls + 144))
  {
    uint64_t v15 = *(void *)(a1 + 1056);
    int v10 = 0;
    if (v15) {
      ++*(void *)(v15 + 608);
    }
  }
  else
  {
    uint64_t v8 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224));
    int v9 = malloc_type_malloc(**(void **)(v8 + 40), 0xB9BAFBABuLL);
    int v10 = v9;
    if (v9)
    {
      *int v9 = a2;
      v9[1] = a3;
      void v9[2] = a2;
      ++*(_WORD *)(a1 + 538);
      atomic_fetch_add_explicit(tcp_sack_globalholes, 1u, memory_order_relaxed);
      v9[3] = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 316);
      if (a4)
      {
        uint64_t v12 = *(void *)(a4 + 16);
        int v11 = (void *)(a4 + 16);
        *((void *)v10 + 2) = v12;
        int v13 = (void *)(v12 + 24);
        if (v12) {
          int8x8_t v14 = v13;
        }
        else {
          int8x8_t v14 = (void *)(a1 + 552);
        }
        *int8x8_t v14 = v10 + 4;
        *int v11 = v10;
        *((void *)v10 + 3) = v11;
        if (!*(void *)(a1 + 616)) {
          goto LABEL_14;
        }
      }
      else
      {
        *((void *)v10 + 2) = 0;
        int v17 = *(void **)(a1 + 552);
        *((void *)v10 + 3) = v17;
        *int v17 = v10;
        *(void *)(a1 + 552) = v10 + 4;
        if (!*(void *)(a1 + 616)) {
LABEL_14:
        }
          *(void *)(a1 + 616) = v10;
      }
    }
  }
  return v10;
}

void tcp_sack_detect_reordering(uint64_t a1, _DWORD *a2, int a3, int a4)
{
  if (a2[1] - a4 > 0) {
    return;
  }
  if (*(_WORD *)(a1 + 226)) {
    return;
  }
  int v6 = a2[2];
  if (v6 - a3 >= 0) {
    return;
  }
  uint64_t v8 = *(void *)(a1 + 952);
  if (v8)
  {
    int v9 = a3 - 1;
    do
    {
      if (*(_DWORD *)v8 - v9 > 0) {
        break;
      }
      if (*(_DWORD *)(v8 + 4) - v9 >= 0) {
        return;
      }
      uint64_t v8 = *(void *)(v8 + 16);
    }
    while (v8);
  }
  int v10 = *(void **)(a1 + 1056);
  if (v10)
  {
    ++v10[124];
    int v11 = *(_DWORD *)(a1 + 740);
    if ((v11 & 0x2000) == 0)
    {
      *(_DWORD *)(a1 + 740) = v11 | 0x2000;
      ++v10[121];
    }
    ++v10[122];
  }
  else
  {
    int v12 = *(_DWORD *)(a1 + 740);
    if ((v12 & 0x2000) == 0) {
      *(_DWORD *)(a1 + 740) = v12 | 0x2000;
    }
  }
  ++*(_DWORD *)(a1 + 1016);
  if ((~*(_DWORD *)(a1 + 348) & 3) == 0)
  {
    uint64_t v13 = *(void *)(a1 + 80);
    uint64_t v14 = *(void *)(v13 + 448);
    if (v14)
    {
      BOOL v15 = (*(unsigned char *)(v13 + 2236) & 2) == 0;
      uint64_t v16 = 632;
      if (v15) {
        uint64_t v16 = 248;
      }
      ++*(void *)(v14 + v16);
    }
    if (v10) {
      ++v10[117];
    }
    tcp_heuristic_ecn_aggressive(a1);
    int v6 = a2[2];
  }
  if (a4 - v6 >= 0)
  {
    if (!a2[3]) {
      return;
    }
    goto LABEL_26;
  }
  BOOL v19 = __nwlog_obj();
  os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
  uint64_t v20 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort())
  {
    __break(1u);
    return;
  }
  free(v20);
  if (a2[3])
  {
LABEL_26:
    int v17 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224)) + 316) - a2[3];
    if (v17 >= 0)
    {
      if (v17 < *(unsigned __int16 *)(a1 + 536)) {
        LOWORD(v17) = *(_WORD *)(a1 + 536);
      }
      int v18 = *(_DWORD *)(a1 + 200);
      if ((uint64_t)v18 >> 6 <= (unsigned __int16)v17) {
        LOWORD(v17) = v18 >> 6;
      }
      if ((unsigned __int16)v17 <= 0xAu) {
        LOWORD(v17) = 10;
      }
      *(_WORD *)(a1 + 536) = v17;
    }
  }
}

uint64_t tcp_sack_partialack(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 100);
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 172) = 0;
  int v5 = *(_DWORD *)(a2 + 8);
  if (v4 - v5 < 0) {
    *(_DWORD *)(a1 + 100) = v5;
  }
  char v6 = (v5 - *(_DWORD *)(a1 + 92)) / *(_DWORD *)(a1 + 196) > 2;
  unsigned int v7 = (*(_DWORD *)(a1 + 196) << v6) + tcp_flight_size((_DWORD *)a1);
  int v8 = *(_DWORD *)(a1 + 152);
  if (v7 >= *(_DWORD *)(a1 + 148)) {
    unsigned int v7 = *(_DWORD *)(a1 + 148);
  }
  *(_DWORD *)(a1 + 144) = v7;
  int v9 = *(_DWORD *)(a1 + 560);
  if (v9 - v8 < 0 && v9 == *(_DWORD *)(a2 + 8) && !*(void *)(a1 + 544) && tcp_sackhole_insert(a1, v9, v8, 0)) {
    *(_DWORD *)(a1 + 560) = *(_DWORD *)(a1 + 152);
  }
  uint64_t result = tcp_output(a1);
  int v11 = *(_DWORD *)(a1 + 100);
  if ((*(unsigned char *)(a1 + 88) & 0x10) == 0)
  {
    if (v4 - v11 < 1) {
      return result;
    }
LABEL_15:
    *(_DWORD *)(a1 + 100) = v4;
    return result;
  }
  if (v11 != *(_DWORD *)(a1 + 96) - 1 && v4 - v11 > 0) {
    goto LABEL_15;
  }
  return result;
}

uint64_t tcp_cc_adjust_nonvalidated_cwnd(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 964);
  if (v1 <= *(_DWORD *)(result + 968)) {
    unsigned int v1 = *(_DWORD *)(result + 968);
  }
  if (*(_DWORD *)(result + 972) > v1) {
    unsigned int v1 = *(_DWORD *)(result + 972);
  }
  *(_DWORD *)(result + 980) = v1;
  *(void *)(result + 964) = 0;
  *(_DWORD *)(result + 972) = 0;
  *(unsigned char *)(result + 751) = 0;
  *(_DWORD *)(result + 984) = 0;
  unsigned int v2 = v1 >> 1;
  if (*(_DWORD *)(sysctls + 276))
  {
    unsigned int v3 = *(_DWORD *)(result + 196);
    if (v2 <= v3) {
      unsigned int v2 = *(_DWORD *)(result + 196);
    }
  }
  else
  {
    if (v1 <= 0x2239) {
      unsigned int v2 = 4380;
    }
    unsigned int v3 = *(_DWORD *)(result + 196);
  }
  *(_DWORD *)(result + 144) = 3 * v3 + v2;
  *(_DWORD *)(result + 740) &= ~0x100000u;
  return result;
}

uint64_t soabort(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 364);
  if ((v1 & 0x100) == 0)
  {
    uint64_t v2 = result;
    *(_DWORD *)(result + 364) = v1 | 0x100;
    uint64_t result = (**(uint64_t (***)(void))(*(void *)(result + 8) + 40))();
    if (result)
    {
      uint64_t v3 = *(void *)(v2 + 8);
      if (v3)
      {
        int v4 = *(void (**)(uint64_t, void))(v3 + 32);
        if (v4) {
          v4(v2, 0);
        }
      }
      return sofreelastref(v2);
    }
  }
  return result;
}

uint64_t sbreserve(uint64_t a1, unsigned int a2)
{
  if (a2 > 0x71C71C) {
    return 0;
  }
  *(_DWORD *)(a1 + 4) = a2;
  uint64_t v4 = *(void *)(*(void *)(a1 + 72) + 24);
  if ((*(unsigned char *)(a1 + 48) & 4) != 0)
  {
    if (v4)
    {
      uint64_t all_stats = nw_protocol_tcp_get_all_stats();
      if (all_stats) {
        *(_DWORD *)(all_stats + 88) = *(_DWORD *)(a1 + 4);
      }
    }
  }
  else if (v4)
  {
    uint64_t v5 = nw_protocol_tcp_get_all_stats();
    if (v5) {
      *(_DWORD *)(v5 + 100) = *(_DWORD *)(a1 + 4);
    }
  }
  unsigned int v7 = *(_DWORD *)(a1 + 4);
  if (*(_DWORD *)(a1 + 8) > v7) {
    *(_DWORD *)(a1 + 8) = v7;
  }
  return 1;
}

uint64_t tcp_setsockopt(uint64_t a1, int a2, int a3, int *a4)
{
  v22[0] = 1;
  v22[1] = a2;
  int v24 = a4;
  uint64_t v23 = a3;
  uint64_t v25 = 4;
  int v9 = *a4;
  (*(void (**)(uint64_t, uint64_t, uint64_t, int *))(*(void *)(a1 + 8) + 16))(a1, 1, v4, a4);
  if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) == 0 && (*(unsigned char *)(a1 + 365) & 0x20) == 0) {
    goto LABEL_3;
  }
  if (a2 != 0xFFFF)
  {
    uint64_t v10 = tcp_ctloutput(a1, (uint64_t)v22);
    goto LABEL_27;
  }
  uint64_t v10 = 42;
  if (a3 > 2047)
  {
    if (a3 >= 0x2000)
    {
      if (a3 >= 0x8000)
      {
        if (a3 != 0x8000 && a3 != 0x10000) {
          goto LABEL_27;
        }
      }
      else if (a3 != 0x2000 && a3 != 0x4000)
      {
        goto LABEL_27;
      }
      goto LABEL_9;
    }
    if ((a3 - 4097) >= 4)
    {
      if (a3 != 2048) {
        goto LABEL_27;
      }
LABEL_9:
      uint64_t v10 = 0;
      if (v9) {
        int v11 = *(_DWORD *)(a1 + 372) | a3;
      }
      else {
        int v11 = *(_DWORD *)(a1 + 372) & ~a3;
      }
      *(_DWORD *)(a1 + 372) = v11;
      goto LABEL_27;
    }
    if (v9 < 1)
    {
LABEL_3:
      uint64_t v10 = 22;
      goto LABEL_27;
    }
    if ((a3 - 4097) < 2)
    {
      if (a3 == 4097) {
        uint64_t v14 = a1 + 384;
      }
      else {
        uint64_t v14 = a1 + 488;
      }
      if (v9 <= 0x71C71C)
      {
        *(_DWORD *)(v14 + 4) = v9;
        uint64_t v18 = *(void *)(*(void *)(v14 + 72) + 24);
        if ((*(unsigned char *)(v14 + 48) & 4) != 0)
        {
          if (v18)
          {
            uint64_t all_stats = nw_protocol_tcp_get_all_stats();
            if (all_stats) {
              *(_DWORD *)(all_stats + 88) = *(_DWORD *)(v14 + 4);
            }
          }
        }
        else if (v18)
        {
          uint64_t v19 = nw_protocol_tcp_get_all_stats();
          if (v19) {
            *(_DWORD *)(v19 + 100) = *(_DWORD *)(v14 + 4);
          }
        }
        unsigned int v21 = *(_DWORD *)(v14 + 4);
        if (*(_DWORD *)(v14 + 8) > v21) {
          *(_DWORD *)(v14 + 8) = v21;
        }
        uint64_t v10 = 0;
        *(_DWORD *)(v14 + 48) = *(_DWORD *)(v14 + 48) & 0xFFFFF9FF | 0x200;
        *(_DWORD *)(v14 + 52) = v9;
      }
      else
      {
        uint64_t v10 = 55;
      }
    }
    else if (a3 == 4099)
    {
      uint64_t v10 = 0;
      unsigned int v17 = *(_DWORD *)(a1 + 388) / 3u;
      if (v9 <= *(_DWORD *)(a1 + 388) / 3) {
        unsigned int v17 = v9;
      }
      if (v17 <= 1) {
        unsigned int v17 = 1;
      }
      *(_DWORD *)(a1 + 392) = v17;
    }
    else if (a3 == 4100)
    {
      uint64_t v10 = 0;
      signed int v12 = *(_DWORD *)(a1 + 492) / 3u;
      if (v9 <= *(_DWORD *)(a1 + 492) / 3) {
        signed int v12 = v9;
      }
      if (v12 >= 0x4000) {
        signed int v12 = 0x4000;
      }
      if (v12 <= 1) {
        signed int v12 = 1;
      }
      *(_DWORD *)(a1 + 496) = v12;
    }
    else
    {
      uint64_t v10 = 0;
    }
  }
  else
  {
    if (a3 <= 127)
    {
      if ((a3 - 1) > 0x3F || ((1 << (a3 - 1)) & 0x8000000080008089) == 0) {
        goto LABEL_27;
      }
      goto LABEL_9;
    }
    if (a3 != 128)
    {
      if (a3 != 512 && a3 != 1024) {
        goto LABEL_27;
      }
      goto LABEL_9;
    }
    *(_DWORD *)(a1 + 16) = a4[1];
    int v15 = *(_DWORD *)(a1 + 372);
    uint64_t v10 = 0;
    if (*a4) {
      unsigned int v16 = v15 | 0x80;
    }
    else {
      unsigned int v16 = v15 & 0xFFFFFF7F;
    }
    *(_DWORD *)(a1 + 372) = v16;
  }
LABEL_27:
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v4);
  return v10;
}

uint64_t tcp_set_keepalive(uint64_t a1, int a2)
{
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
  if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(unsigned char *)(a1 + 365) & 0x20) != 0)
  {
    uint64_t v5 = 0;
    *(_DWORD *)(a1 + 372) = *(_DWORD *)(a1 + 372) & 0xFFFFFFF7 | (8 * (a2 != 0));
  }
  else
  {
    uint64_t v5 = 22;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v2);
  return v5;
}

uint64_t tcp_set_keepalive_idle_time(uint64_t a1, int a2)
{
  int v6 = a2;
  v7[0] = 0x600000001;
  v7[2] = &v6;
  void v7[3] = 4;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
  if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(unsigned char *)(a1 + 365) & 0x20) != 0)
  {
    v7[1] = 16;
    uint64_t v4 = tcp_ctloutput(a1, (uint64_t)v7);
  }
  else
  {
    uint64_t v4 = 22;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v2);
  return v4;
}

uint64_t tcp_set_keepalive_interval(uint64_t a1, int a2)
{
  int v6 = a2;
  v7[0] = 0x600000001;
  v7[2] = &v6;
  void v7[3] = 4;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
  if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(unsigned char *)(a1 + 365) & 0x20) != 0)
  {
    v7[1] = 257;
    uint64_t v4 = tcp_ctloutput(a1, (uint64_t)v7);
  }
  else
  {
    uint64_t v4 = 22;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v2);
  return v4;
}

uint64_t tcp_set_background_management(uint64_t a1)
{
  int v5 = 1;
  v6[0] = 0xFFFF00000001;
  v6[2] = &v5;
  v6[3] = 4;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
  if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(unsigned char *)(a1 + 365) & 0x20) != 0)
  {
    v6[1] = 4357;
    uint64_t v3 = tcp_ctloutput(a1, (uint64_t)v6);
  }
  else
  {
    uint64_t v3 = 22;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24))(a1, 1, v1);
  return v3;
}

uint64_t tcp_rack_reordering_timeout(uint64_t a1)
{
  char v8 = 0;
  uint64_t result = tcp_rack_detect_loss(a1, 0, &v8);
  if (v8)
  {
    int v3 = *(_DWORD *)(a1 + 88);
    if ((v3 & 0x200000) == 0)
    {
      if ((~v3 & 0x180) != 0)
      {
        uint64_t v6 = *(void *)(a1 + 144);
        *(_DWORD *)(a1 + 512) = *(_DWORD *)(a1 + 152);
        *(void *)(a1 + 504) = v6;
        *(_DWORD *)(a1 + 88) = v3 & 0xFFBFFFFF;
      }
      else
      {
        unsigned int v4 = *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92);
        int v5 = *(_DWORD *)(a1 + 152);
        if (v4 <= *(_DWORD *)(a1 + 148)) {
          unsigned int v4 = *(_DWORD *)(a1 + 148);
        }
        *(_DWORD *)(a1 + 508) = v4;
        *(_DWORD *)(a1 + 512) = v5;
      }
      *(_DWORD *)(a1 + 516) = (*(int *)(a1 + 200) >> 5) + 2;
      *(_DWORD *)(a1 + 524) = *(int *)(a1 + 208) >> 4;
      if ((*(_DWORD *)(a1 + 1872) & 0xFFFFFFFE) == 2)
      {
        *(_DWORD *)(a1 + 520) = (*(int *)(a1 + 204) >> 5) + 2;
        *(_DWORD *)(a1 + 528) = *(int *)(a1 + 212) >> 4;
      }
      *(_DWORD *)(a1 + 740) &= ~0x40u;
      tcp_enter_fast_recovery(a1);
    }
    uint64_t v7 = *(void *)(a1 + 1056);
    if (v7) {
      ++*(void *)(v7 + 632);
    }
    ++*(_DWORD *)(a1 + 1012);
    return tcp_output(a1);
  }
  return result;
}

const char *packet_service_class_to_str(int a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (a1 <= 2621727)
  {
    if (a1 <= 1048703)
    {
      if (!a1) {
        return "be";
      }
      if (a1 == 524432) {
        return "bk_sys";
      }
    }
    else
    {
      switch(a1)
      {
        case 1048704:
          return "bk";
        case 1572880:
          return "rd";
        case 2097184:
          return "oam";
      }
    }
  }
  else if (a1 > 3670319)
  {
    switch(a1)
    {
      case 3670320:
        return "sig";
      case 4194688:
        return "vo";
      case 4718992:
        return "ctl";
    }
  }
  else
  {
    switch(a1)
    {
      case 2621728:
        return "av";
      case 3146000:
        return "rv";
      case 3670272:
        return "vi";
    }
  }
  int v3 = __nwlog_obj();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    int v4 = 136446466;
    int v5 = "packet_service_class_to_str";
    __int16 v6 = 1024;
    int v7 = a1;
    _os_log_impl(&dword_214653000, v3, OS_LOG_TYPE_ERROR, "%{public}s invalid packet service class %d", (uint8_t *)&v4, 0x12u);
  }
  return "unknown";
}

uint64_t tcp_rexmt_save_state(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 88);
  if ((~v1 & 0x180) != 0)
  {
    uint64_t v4 = *(void *)(result + 144);
    *(_DWORD *)(result + 512) = *(_DWORD *)(result + 152);
    *(void *)(result + 504) = v4;
    if ((v1 & 0x200000) != 0) {
      unsigned int v5 = v1 | 0x400000;
    }
    else {
      unsigned int v5 = v1 & 0xFFBFFFFF;
    }
    *(_DWORD *)(result + 88) = v5;
  }
  else
  {
    unsigned int v2 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
    int v3 = *(_DWORD *)(result + 152);
    if (v2 <= *(_DWORD *)(result + 148)) {
      unsigned int v2 = *(_DWORD *)(result + 148);
    }
    *(_DWORD *)(result + 508) = v2;
    *(_DWORD *)(result + 512) = v3;
  }
  *(_DWORD *)(result + 516) = (*(int *)(result + 200) >> 5) + 2;
  *(_DWORD *)(result + 524) = *(int *)(result + 208) >> 4;
  if ((*(_DWORD *)(result + 1872) & 0xFFFFFFFE) == 2)
  {
    *(_DWORD *)(result + 520) = (*(int *)(result + 204) >> 5) + 2;
    *(_DWORD *)(result + 528) = *(int *)(result + 212) >> 4;
  }
  *(_DWORD *)(result + 740) &= ~0x40u;
  return result;
}

void tcp_pmtud_revert_segment_size(uint64_t a1)
{
  int v2 = *(unsigned __int16 *)(a1 + 698);
  if (!*(_WORD *)(a1 + 698))
  {
    uint64_t v14 = __nwlog_obj();
    os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    int v15 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      JUMPOUT(0x2146B0AD8);
    }
    free(v15);
    int v2 = *(unsigned __int16 *)(a1 + 698);
  }
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a1 + 88) & 0xDBFFFFFF | 0x4000000;
  int v3 = *(_DWORD *)(a1 + 196) - *(_DWORD *)(a1 + 156);
  *(_DWORD *)(a1 + 156) = v2;
  *(_DWORD *)(a1 + 196) = v3 + v2;
  uint64_t v4 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 40);
  if (v4) {
    v4(a1);
  }
  if (*(_DWORD *)(sysctls + 308) == 1
    && (~*(_DWORD *)(a1 + 88) & 0x180) == 0
    && (*(_DWORD *)(sysctls + 40) == 1 || (*(unsigned char *)(*(void *)(*(void *)(a1 + 80) + 224) + 369) & 0x40) != 0)
    && off_26AA46358)
  {
    off_26AA46358((_DWORD *)a1);
  }
  *(_DWORD *)(a1 + 700) = 0;
  uint64_t v5 = *(void *)(a1 + 1056);
  if (v5) {
    ++*(void *)(v5 + 1056);
  }
  uint64_t v6 = **(void **)(*(void *)(a1 + 80) + 224);
  uint64_t v7 = *(void *)(v6 + 448);
  if (v7)
  {
    uint64_t v8 = *(void *)(v6 + 240);
    if ((*(unsigned __int8 *)(v7 + 1076) == 255 || *(_DWORD *)(v7 + 1024) == 255)
      && *(int *)(v8 + 12) <= 5
      && (*(unsigned char *)(v8 + 91) & 0x20) == 0
      && (*(unsigned char *)(v7 + 9) & 0x80) != 0)
    {
      unsigned int v9 = *(_DWORD *)(v8 + 156);
      unsigned int v10 = *(_DWORD *)(v8 + 196) - v9;
      int v11 = *(unsigned __int16 *)(v7 + 72);
      if (v11 == 1200)
      {
        if (v9 <= 0x4B0) {
          goto LABEL_33;
        }
        unsigned int v12 = 1200;
      }
      else
      {
        if (v11 != 512)
        {
          if (v11) {
            goto LABEL_33;
          }
          unsigned int v12 = *(unsigned __int16 *)(v8 + 734);
          if (!*(_WORD *)(v8 + 734) || v9 >= v12) {
            goto LABEL_33;
          }
          goto LABEL_32;
        }
        if (v9 < 0x201) {
          goto LABEL_33;
        }
        unsigned int v12 = 512;
      }
      *(_WORD *)(v8 + 734) = v9;
LABEL_32:
      *(_DWORD *)(v8 + 156) = v12;
      unsigned int v9 = v12;
LABEL_33:
      *(_DWORD *)(v8 + 196) = v10 + v9;
      if (v9 == *(unsigned __int16 *)(v8 + 734)) {
        *(_WORD *)(v8 + 734) = 0;
      }
    }
  }
}

uint64_t tcp_itimer(uint64_t result, uint64_t a2)
{
  *(unsigned char *)(result + 328) |= 0x10u;
  uint64_t v4 = *(void **)(result + 104);
  if (v4)
  {
    while (1)
    {
      uint64_t v5 = (uint64_t)v4;
      uint64_t v4 = (void *)*v4;
      if (*(void *)(v5 + 240)) {
        break;
      }
LABEL_4:
      if (!v4) {
        goto LABEL_34;
      }
    }
    do
    {
      int v6 = *(_DWORD *)(v5 + 456);
      if ((_WORD)v6 == 0xFFFF) {
        goto LABEL_4;
      }
      int v7 = *(_DWORD *)(v5 + 456);
      atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(v5 + 456), (unsigned int *)&v7, v6 + 1, memory_order_relaxed, memory_order_relaxed);
    }
    while (v7 != v6);
    uint64_t v8 = *(void **)(v5 + 224);
    (*(void (**)(void *, uint64_t, uint64_t))(v8[1] + 16))(v8, 1, v2);
    if (in_pcb_checkstate(v5, 2, 1) == 0xFFFF
      || (*(unsigned char *)(a2 + 68) & 1) == 0
      || (uint64_t v9 = *(void *)(*v8 + 448)) == 0
      || (uint64_t v10 = *(void *)(*v8 + 240), *(unsigned __int8 *)(v9 + 1076) != 255) && *(_DWORD *)(v9 + 1024) != 255
      || *(int *)(v10 + 12) > 5
      || (*(unsigned char *)(v10 + 91) & 0x20) != 0
      || (*(unsigned char *)(v9 + 9) & 0x80) == 0)
    {
LABEL_3:
      uint64_t result = (*(uint64_t (**)(void *, uint64_t, uint64_t))(v8[1] + 24))(v8, 1, v2);
      goto LABEL_4;
    }
    unsigned int v11 = *(_DWORD *)(v10 + 156);
    int v12 = *(unsigned __int16 *)(v9 + 72);
    switch(v12)
    {
      case 1200:
        if (v11 <= 0x4B0) {
          goto LABEL_31;
        }
        unsigned int v13 = 1200;
        break;
      case 512:
        if (v11 < 0x201) {
          goto LABEL_31;
        }
        unsigned int v13 = 512;
        break;
      case 0:
        unsigned int v13 = *(unsigned __int16 *)(v10 + 734);
        if (*(_WORD *)(v10 + 734)) {
          BOOL v14 = v11 >= v13;
        }
        else {
          BOOL v14 = 1;
        }
        unsigned int v15 = *(_DWORD *)(v10 + 156);
        if (v14) {
          goto LABEL_32;
        }
        goto LABEL_30;
      default:
LABEL_31:
        unsigned int v15 = *(_DWORD *)(v10 + 156);
LABEL_32:
        *(_DWORD *)(v10 + 196) = *(_DWORD *)(v10 + 196) - v11 + v15;
        if (v15 == *(unsigned __int16 *)(v10 + 734)) {
          *(_WORD *)(v10 + 734) = 0;
        }
        goto LABEL_3;
    }
    *(_WORD *)(v10 + 734) = v11;
LABEL_30:
    *(_DWORD *)(v10 + 156) = v13;
    unsigned int v15 = v13;
    goto LABEL_32;
  }
LABEL_34:
  *(_DWORD *)(a2 + 68) &= ~1u;
  return result;
}

uint64_t tcp_heuristic_tfo_middlebox(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(void *)(v2 + 224);
  if (tcp_perf_measurement)
  {
    if (!v3 || (*(unsigned char *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v4 = __nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v5 = "";
          if (v3) {
            uint64_t v5 = (const char *)(v3 + 604);
          }
          *(_DWORD *)unsigned int v11 = 136446466;
          *(void *)&v11[4] = "tcp_heuristic_tfo_middlebox";
          *(_WORD *)&v11[12] = 2082;
          *(void *)&v11[14] = v5;
          int v6 = v4;
          os_log_type_t v7 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_214653000, v6, v7, "%{public}s %{public}s ", v11, 0x16u);
        }
      }
    }
  }
  else if (!v3 || (*(unsigned char *)(v3 + 828) & 2) == 0)
  {
    uint64_t v8 = __nwlog_tcp_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = "";
      if (v3) {
        uint64_t v9 = (const char *)(v3 + 604);
      }
      *(_DWORD *)unsigned int v11 = 136446466;
      *(void *)&v11[4] = "tcp_heuristic_tfo_middlebox";
      *(_WORD *)&v11[12] = 2082;
      *(void *)&v11[14] = v9;
      int v6 = v8;
      os_log_type_t v7 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }
  *(unsigned char *)(a1 + 988) |= 0x40u;
  *(void *)unsigned int v11 = 0;
  *(void *)&v11[8] = 0;
  *(_WORD *)&v11[16] = 1024;
  return (*(uint64_t (**)(void, unsigned char *))(*(void *)(v2 + 2136) + 56))(*(void *)(*(void *)(a1 + 80) + 224), v11);
}

uint64_t tcp_heuristic_tfo_rst(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(void *)(v2 + 224);
  if (tcp_perf_measurement)
  {
    if (!v3 || (*(unsigned char *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v4 = __nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v5 = "";
          if (v3) {
            uint64_t v5 = (const char *)(v3 + 604);
          }
          *(_DWORD *)unsigned int v13 = 136446466;
          *(void *)&v13[4] = "tcp_heuristic_tfo_rst";
          *(_WORD *)&v13[12] = 2082;
          *(void *)&v13[14] = v5;
          int v6 = v4;
          os_log_type_t v7 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_214653000, v6, v7, "%{public}s %{public}s ", v13, 0x16u);
        }
      }
    }
  }
  else if (!v3 || (*(unsigned char *)(v3 + 828) & 2) == 0)
  {
    uint64_t v8 = __nwlog_tcp_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = "";
      if (v3) {
        uint64_t v9 = (const char *)(v3 + 604);
      }
      *(_DWORD *)unsigned int v13 = 136446466;
      *(void *)&v13[4] = "tcp_heuristic_tfo_rst";
      *(_WORD *)&v13[12] = 2082;
      *(void *)&v13[14] = v9;
      int v6 = v8;
      os_log_type_t v7 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }
  memset(v13, 0, 18);
  __int16 v10 = *(_WORD *)(a1 + 990);
  if ((v10 & 0x40) == 0)
  {
    char v11 = 64;
    if ((v10 & 0x10) == 0) {
      return (*(uint64_t (**)(void, unsigned char *))(*(void *)(v2 + 2136) + 56))(*(void *)(*(void *)(a1 + 80) + 224), v13);
    }
    goto LABEL_20;
  }
  v13[17] = 32;
  char v11 = 96;
  if ((v10 & 0x10) != 0) {
LABEL_20:
  }
    v13[17] = v11;
  return (*(uint64_t (**)(void, unsigned char *))(*(void *)(v2 + 2136) + 56))(*(void *)(*(void *)(a1 + 80) + 224), v13);
}

uint64_t tcp_heuristic_ecn_loss(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(void *)(v2 + 224);
  if (tcp_perf_measurement)
  {
    if (!v3 || (*(unsigned char *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v4 = __nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v5 = "";
          if (v3) {
            uint64_t v5 = (const char *)(v3 + 604);
          }
          int v11 = 136446466;
          uint64_t v12 = "tcp_heuristic_ecn_loss";
          __int16 v13 = 2082;
          uint64_t v14 = v5;
          int v6 = v4;
          os_log_type_t v7 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_214653000, v6, v7, "%{public}s %{public}s ", (uint8_t *)&v11, 0x16u);
        }
      }
    }
  }
  else if (!v3 || (*(unsigned char *)(v3 + 828) & 2) == 0)
  {
    uint64_t v8 = __nwlog_tcp_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = "";
      if (v3) {
        uint64_t v9 = (const char *)(v3 + 604);
      }
      int v11 = 136446466;
      uint64_t v12 = "tcp_heuristic_ecn_loss";
      __int16 v13 = 2082;
      uint64_t v14 = v9;
      int v6 = v8;
      os_log_type_t v7 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }
  LOBYTE(v11) = 2;
  return (*(uint64_t (**)(void, int *))(*(void *)(v2 + 2136) + 24))(*(void *)(*(void *)(a1 + 80) + 224), &v11);
}

uint64_t tcp_heuristic_ecn_droprst(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(void *)(v2 + 224);
  if (tcp_perf_measurement)
  {
    if (!v3 || (*(unsigned char *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v4 = __nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v5 = "";
          if (v3) {
            uint64_t v5 = (const char *)(v3 + 604);
          }
          int v11 = 136446466;
          uint64_t v12 = "tcp_heuristic_ecn_droprst";
          __int16 v13 = 2082;
          uint64_t v14 = v5;
          int v6 = v4;
          os_log_type_t v7 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_214653000, v6, v7, "%{public}s %{public}s ", (uint8_t *)&v11, 0x16u);
        }
      }
    }
  }
  else if (!v3 || (*(unsigned char *)(v3 + 828) & 2) == 0)
  {
    uint64_t v8 = __nwlog_tcp_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = "";
      if (v3) {
        uint64_t v9 = (const char *)(v3 + 604);
      }
      int v11 = 136446466;
      uint64_t v12 = "tcp_heuristic_ecn_droprst";
      __int16 v13 = 2082;
      uint64_t v14 = v9;
      int v6 = v8;
      os_log_type_t v7 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }
  LOBYTE(v11) = 4;
  return (*(uint64_t (**)(void, int *))(*(void *)(v2 + 2136) + 24))(*(void *)(*(void *)(a1 + 80) + 224), &v11);
}

uint64_t tcp_heuristic_ecn_droprxmt(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(void *)(v2 + 224);
  if (tcp_perf_measurement)
  {
    if (!v3 || (*(unsigned char *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v4 = __nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v5 = "";
          if (v3) {
            uint64_t v5 = (const char *)(v3 + 604);
          }
          int v11 = 136446466;
          uint64_t v12 = "tcp_heuristic_ecn_droprxmt";
          __int16 v13 = 2082;
          uint64_t v14 = v5;
          int v6 = v4;
          os_log_type_t v7 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_214653000, v6, v7, "%{public}s %{public}s ", (uint8_t *)&v11, 0x16u);
        }
      }
    }
  }
  else if (!v3 || (*(unsigned char *)(v3 + 828) & 2) == 0)
  {
    uint64_t v8 = __nwlog_tcp_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = "";
      if (v3) {
        uint64_t v9 = (const char *)(v3 + 604);
      }
      int v11 = 136446466;
      uint64_t v12 = "tcp_heuristic_ecn_droprxmt";
      __int16 v13 = 2082;
      uint64_t v14 = v9;
      int v6 = v8;
      os_log_type_t v7 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }
  LOBYTE(v11) = 8;
  return (*(uint64_t (**)(void, int *))(*(void *)(v2 + 2136) + 24))(*(void *)(*(void *)(a1 + 80) + 224), &v11);
}

uint64_t tcp_heuristic_ecn_synrst(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(*(void *)(a1 + 80) + 224);
  if (tcp_perf_measurement)
  {
    if (!v2 || (*(unsigned char *)(v2 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v3 = __nwlog_tcp_log();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v4 = "";
          if (v2) {
            uint64_t v4 = (const char *)(v2 + 604);
          }
          int v11 = 136446466;
          uint64_t v12 = "tcp_heuristic_ecn_synrst";
          __int16 v13 = 2082;
          uint64_t v14 = v4;
          uint64_t v5 = v3;
          os_log_type_t v6 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_214653000, v5, v6, "%{public}s %{public}s ", (uint8_t *)&v11, 0x16u);
        }
      }
    }
  }
  else if (!v2 || (*(unsigned char *)(v2 + 828) & 2) == 0)
  {
    os_log_type_t v7 = __nwlog_tcp_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      uint64_t v8 = "";
      if (v2) {
        uint64_t v8 = (const char *)(v2 + 604);
      }
      int v11 = 136446466;
      uint64_t v12 = "tcp_heuristic_ecn_synrst";
      __int16 v13 = 2082;
      uint64_t v14 = v8;
      uint64_t v5 = v7;
      os_log_type_t v6 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }
  uint64_t v9 = *(void *)(a1 + 80);
  LOBYTE(v11) = 32;
  return (*(uint64_t (**)(void, int *))(*(void *)(v9 + 2136) + 24))(*(void *)(v9 + 224), &v11);
}

uint64_t tcp_heuristic_ecn_aggressive(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(void *)(v2 + 224);
  if (tcp_perf_measurement)
  {
    if (!v3 || (*(unsigned char *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v4 = __nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v5 = "";
          if (v3) {
            uint64_t v5 = (const char *)(v3 + 604);
          }
          int v11 = 136446466;
          uint64_t v12 = "tcp_heuristic_ecn_aggressive";
          __int16 v13 = 2082;
          uint64_t v14 = v5;
          os_log_type_t v6 = v4;
          os_log_type_t v7 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_214653000, v6, v7, "%{public}s %{public}s ", (uint8_t *)&v11, 0x16u);
        }
      }
    }
  }
  else if (!v3 || (*(unsigned char *)(v3 + 828) & 2) == 0)
  {
    uint64_t v8 = __nwlog_tcp_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = "";
      if (v3) {
        uint64_t v9 = (const char *)(v3 + 604);
      }
      int v11 = 136446466;
      uint64_t v12 = "tcp_heuristic_ecn_aggressive";
      __int16 v13 = 2082;
      uint64_t v14 = v9;
      os_log_type_t v6 = v8;
      os_log_type_t v7 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }
  LOBYTE(v11) = 16;
  return (*(uint64_t (**)(void, int *))(*(void *)(v2 + 2136) + 24))(*(void *)(*(void *)(a1 + 80) + 224), &v11);
}

void tcp_cubic_switch_cc(uint64_t a1)
{
}

uint64_t tcp_cubic_post_fr(uint64_t result, uint64_t a2)
{
  uint64_t v2 = (int *)(a2 + 8);
  if (!a2) {
    uint64_t v2 = (int *)(result + 92);
  }
  int v3 = *v2;
  int v4 = *(_DWORD *)(result + 96);
  int v5 = *(_DWORD *)(sysctls + 276);
  if (v3 - v4 <= 0)
  {
    if (!v5 || *(_DWORD *)(sysctls + 292))
    {
      unsigned int v6 = v4 - v3;
      if ((*(unsigned char *)(result + 740) & 0x20) == 0) {
        goto LABEL_28;
      }
      goto LABEL_12;
    }
    goto LABEL_5;
  }
  if (v5)
  {
LABEL_5:
    unsigned int v6 = *(_DWORD *)(result + 148);
    int v5 = 1;
    if ((*(unsigned char *)(result + 740) & 0x20) == 0) {
      goto LABEL_28;
    }
    goto LABEL_12;
  }
  unsigned int v6 = 0;
  if ((*(unsigned char *)(result + 740) & 0x20) == 0) {
    goto LABEL_28;
  }
LABEL_12:
  unsigned int v7 = *(_DWORD *)(result + 984);
  if (v7 && !v5)
  {
    uint64_t v8 = *(void *)(result + 952);
    if (v8)
    {
      unsigned int v9 = 0;
      do
      {
        unsigned int v9 = v9 + *(_DWORD *)(v8 + 4) - *(_DWORD *)v8 + 1;
        uint64_t v8 = *(void *)(v8 + 16);
      }
      while (v8);
    }
    else
    {
      unsigned int v9 = 0;
    }
    if (*(_DWORD *)(result + 980) > v7) {
      unsigned int v7 = *(_DWORD *)(result + 980);
    }
    if (v9 <= v7) {
      unsigned int v10 = v9;
    }
    else {
      unsigned int v10 = 0;
    }
    unsigned int v11 = v7 - v10;
    if (v11 >= *(_DWORD *)(result + 196) << 6) {
      unsigned int v11 = *(_DWORD *)(result + 196) << 6;
    }
    unsigned int v12 = v11 >> 1;
    if (v12 > v6) {
      unsigned int v6 = v12;
    }
  }
LABEL_28:
  unsigned int v13 = *(_DWORD *)(result + 148);
  if (v6 < v13)
  {
    unsigned int v14 = *(_DWORD *)(result + 196);
    if (v6 <= v14) {
      unsigned int v6 = *(_DWORD *)(result + 196);
    }
    unsigned int v13 = v6 + v14;
  }
  *(_DWORD *)(result + 144) = v13;
  *(_DWORD *)(*(void *)(result + 840) + 12) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 16) = 0;
  return result;
}

CCCryptorStatus CCCryptorCreate(CCOperation op, CCAlgorithm alg, CCOptions options, const void *key, size_t keyLength, const void *iv, CCCryptorRef *cryptorRef)
{
  return MEMORY[0x270ED78C8](*(void *)&op, *(void *)&alg, *(void *)&options, key, keyLength, iv, cryptorRef);
}

CCCryptorStatus CCCryptorUpdate(CCCryptorRef cryptorRef, const void *dataIn, size_t dataInLength, void *dataOut, size_t dataOutAvailable, size_t *dataOutMoved)
{
  return MEMORY[0x270ED7950](cryptorRef, dataIn, dataInLength, dataOut, dataOutAvailable, dataOutMoved);
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return MEMORY[0x270ED7B30](md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return MEMORY[0x270ED7B38](c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x270ED7B40](c, data, *(void *)&len);
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x270ED7E38]();
}

uint64_t __nw_create_backtrace_string()
{
  return MEMORY[0x270EF78E8]();
}

uint64_t __nwlog_abort()
{
  return MEMORY[0x270EF78F0]();
}

uint64_t __nwlog_fault()
{
  return MEMORY[0x270EF78F8]();
}

uint64_t __nwlog_is_datapath_logging_enabled()
{
  return MEMORY[0x270EF7908]();
}

uint64_t __nwlog_obj()
{
  return MEMORY[0x270EF7910]();
}

uint64_t __nwlog_tcp_log()
{
  return MEMORY[0x270EF7920]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x270ED8070]();
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _os_log_send_and_compose_impl()
{
  return MEMORY[0x270ED80B0]();
}

uint32_t arc4random(void)
{
  return MEMORY[0x270ED85E0]();
}

void arc4random_buf(void *__buf, size_t __nbytes)
{
}

void bzero(void *a1, size_t a2)
{
}

float cbrtf(float a1)
{
  MEMORY[0x270ED87C0](a1);
  return result;
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x270ED95A8](when, delta);
}

void free(void *a1)
{
}

uint64_t in6_pseudo()
{
  return MEMORY[0x270EF7928]();
}

uint64_t in_addword()
{
  return MEMORY[0x270EF7930]();
}

uint64_t in_finalize_cksum()
{
  return MEMORY[0x270EF7938]();
}

uint64_t in_pseudo()
{
  return MEMORY[0x270EF7940]();
}

const char *__cdecl inet_ntop(int a1, const void *a2, char *a3, socklen_t a4)
{
  return (const char *)MEMORY[0x270ED9EC0](*(void *)&a1, a2, a3, *(void *)&a4);
}

uint64_t kdebug_is_enabled()
{
  return MEMORY[0x270ED9F48]();
}

uint64_t kdebug_trace()
{
  return MEMORY[0x270ED9F50]();
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x270EDA138]();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x270EDA288](info);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA388](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA390](size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x270EDA468](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDA470](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDA488](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x270EDA498](__b, *(void *)&__c, __len);
}

uint64_t network_config_get_tcp_accurate_ecn_enabled()
{
  return MEMORY[0x270EF7968]();
}

uint64_t network_config_get_tcp_l4s_enabled()
{
  return MEMORY[0x270EF7970]();
}

uint64_t networkd_settings_get_BOOL()
{
  return MEMORY[0x270EF7980]();
}

uint64_t networkd_settings_get_int64_with_default()
{
  return MEMORY[0x270EF7988]();
}

uint64_t nw_array_append()
{
  return MEMORY[0x270EF7A50]();
}

uint64_t nw_array_create()
{
  return MEMORY[0x270EF7A78]();
}

uint64_t nw_connection_client_accurate_ecn_state_to_string()
{
  return MEMORY[0x270EF7B48]();
}

uint64_t nw_connection_server_accurate_ecn_state_to_string()
{
  return MEMORY[0x270EF7CA0]();
}

uint64_t nw_context_128k_buffer_length()
{
  return MEMORY[0x270EF7D90]();
}

uint64_t nw_context_128k_buffer_manager()
{
  return MEMORY[0x270EF7D98]();
}

uint64_t nw_context_16k_buffer_length()
{
  return MEMORY[0x270EF7DA0]();
}

uint64_t nw_context_16k_buffer_manager()
{
  return MEMORY[0x270EF7DA8]();
}

uint64_t nw_context_2k_buffer_length()
{
  return MEMORY[0x270EF7DB0]();
}

uint64_t nw_context_2k_buffer_manager()
{
  return MEMORY[0x270EF7DB8]();
}

uint64_t nw_context_64k_buffer_length()
{
  return MEMORY[0x270EF7DC0]();
}

uint64_t nw_context_64k_buffer_manager()
{
  return MEMORY[0x270EF7DC8]();
}

uint64_t nw_context_8k_buffer_length()
{
  return MEMORY[0x270EF7DD0]();
}

uint64_t nw_context_8k_buffer_manager()
{
  return MEMORY[0x270EF7DD8]();
}

uint64_t nw_context_get_globals_for_protocol()
{
  return MEMORY[0x270EF7DE8]();
}

uint64_t nw_context_get_logging_disabled()
{
  return MEMORY[0x270EF7DF0]();
}

uint64_t nw_dispatch_data_copyout_from_offset()
{
  return MEMORY[0x270EF7E48]();
}

char *__cdecl nw_endpoint_copy_address_string(nw_endpoint_t endpoint)
{
  return (char *)MEMORY[0x270EF7E50](endpoint);
}

const sockaddr *__cdecl nw_endpoint_get_address(nw_endpoint_t endpoint)
{
  return (const sockaddr *)MEMORY[0x270EF7EE8](endpoint);
}

uint16_t nw_endpoint_get_port(nw_endpoint_t endpoint)
{
  return MEMORY[0x270EF7F48](endpoint);
}

uint64_t nw_frame_array_first()
{
  return MEMORY[0x270EF8040]();
}

uint64_t nw_frame_array_foreach()
{
  return MEMORY[0x270EF8048]();
}

uint64_t nw_frame_array_is_empty()
{
  return MEMORY[0x270EF8058]();
}

uint64_t nw_frame_array_remove()
{
  return MEMORY[0x270EF8080]();
}

uint64_t nw_frame_array_unclaimed_length()
{
  return MEMORY[0x270EF8088]();
}

uint64_t nw_frame_create()
{
  return MEMORY[0x270EF80A0]();
}

uint64_t nw_frame_create_external()
{
  return MEMORY[0x270EF80A8]();
}

uint64_t nw_frame_is_wake_packet()
{
  return MEMORY[0x270EF80D8]();
}

uint64_t nw_frame_set_is_wake_packet()
{
  return MEMORY[0x270EF80F0]();
}

uint64_t nw_interface_get_subtype()
{
  return MEMORY[0x270EF8398]();
}

nw_interface_type_t nw_interface_get_type(nw_interface_t interface)
{
  return MEMORY[0x270EF83A0](interface);
}

uint64_t nw_interface_supports_ack_priority()
{
  return MEMORY[0x270EF83B0]();
}

uint64_t nw_interface_supports_carrier_aggregation()
{
  return MEMORY[0x270EF83B8]();
}

uint64_t nw_interface_supports_tx_start()
{
  return MEMORY[0x270EF83C0]();
}

uint64_t nw_ip_metadata_get_dscp_value()
{
  return MEMORY[0x270EF83D0]();
}

nw_ip_ecn_flag_t nw_ip_metadata_get_ecn_flag(nw_protocol_metadata_t metadata)
{
  return MEMORY[0x270EF83D8](metadata);
}

uint64_t nw_ip_metadata_get_fragmentation_value()
{
  return MEMORY[0x270EF83E0]();
}

nw_service_class_t nw_ip_metadata_get_service_class(nw_protocol_metadata_t metadata)
{
  return MEMORY[0x270EF83E8](metadata);
}

uint64_t nw_link_get_flow_control_status()
{
  return MEMORY[0x270EF83F8]();
}

uint64_t nw_log_ms_to_delta()
{
  return MEMORY[0x270EF8480]();
}

uint64_t nw_log_ring_append()
{
  return MEMORY[0x270EF8488]();
}

uint64_t nw_log_ring_copyout()
{
  return MEMORY[0x270EF8490]();
}

uint64_t nw_mem_buffer_allocate()
{
  return MEMORY[0x270EF84A0]();
}

uint64_t nw_mem_buffer_free()
{
  return MEMORY[0x270EF84A8]();
}

uint64_t nw_parameters_copy_context()
{
  return MEMORY[0x270EF84E8]();
}

uint64_t nw_parameters_copy_protocol_options_legacy()
{
  return MEMORY[0x270EF8508]();
}

uint64_t nw_parameters_get_discretionary()
{
  return MEMORY[0x270EF8578]();
}

uint64_t nw_parameters_get_ecn_mode()
{
  return MEMORY[0x270EF8588]();
}

BOOL nw_parameters_get_fast_open_enabled(nw_parameters_t parameters)
{
  return MEMORY[0x270EF8598](parameters);
}

uint64_t nw_parameters_get_logging_disabled()
{
  return MEMORY[0x270EF85A8]();
}

uint64_t nw_parameters_get_sensitive_redacted()
{
  return MEMORY[0x270EF85C0]();
}

uint64_t nw_parameters_get_server_mode()
{
  return MEMORY[0x270EF85C8]();
}

uint64_t nw_parameters_is_fallback()
{
  return MEMORY[0x270EF85D8]();
}

uint64_t nw_path_copy_delegate_interface()
{
  return MEMORY[0x270EF8790]();
}

uint64_t nw_path_copy_direct_interface()
{
  return MEMORY[0x270EF8798]();
}

uint64_t nw_path_copy_flow_registration()
{
  return MEMORY[0x270EF87B0]();
}

uint64_t nw_path_flow_registration_access_interface_stats()
{
  return MEMORY[0x270EF8858]();
}

uint64_t nw_path_flow_registration_fast_open_blocked()
{
  return MEMORY[0x270EF8868]();
}

uint64_t nw_path_flow_registration_get_advisory_region()
{
  return MEMORY[0x270EF8870]();
}

uint64_t nw_path_flow_registration_get_ctl_command()
{
  return MEMORY[0x270EF8878]();
}

uint64_t nw_path_flow_registration_get_nexus_instance()
{
  return MEMORY[0x270EF8880]();
}

uint64_t nw_path_flow_registration_get_partial_checksum_offload()
{
  return MEMORY[0x270EF8888]();
}

uint64_t nw_path_flow_registration_get_stats_region()
{
  return MEMORY[0x270EF8898]();
}

uint64_t nw_path_get_csum_flags()
{
  return MEMORY[0x270EF88C0]();
}

uint64_t nw_path_get_effective_traffic_class()
{
  return MEMORY[0x270EF88C8]();
}

uint64_t nw_path_get_interface_index()
{
  return MEMORY[0x270EF88E8]();
}

uint64_t nw_path_get_ipv4_network_signature()
{
  return MEMORY[0x270EF88F0]();
}

uint64_t nw_path_get_ipv6_network_signature()
{
  return MEMORY[0x270EF88F8]();
}

uint64_t nw_path_get_mtu()
{
  return MEMORY[0x270EF8900]();
}

uint64_t nw_path_get_recommended_mss()
{
  return MEMORY[0x270EF8910]();
}

uint64_t nw_path_get_rtt_values()
{
  return MEMORY[0x270EF8918]();
}

uint64_t nw_path_get_sysctls_region()
{
  return MEMORY[0x270EF8930]();
}

uint64_t nw_path_get_tso_max_segment_size_v4()
{
  return MEMORY[0x270EF8938]();
}

uint64_t nw_path_get_tso_max_segment_size_v6()
{
  return MEMORY[0x270EF8940]();
}

uint64_t nw_path_is_defunct()
{
  return MEMORY[0x270EF8998]();
}

uint64_t nw_path_is_direct()
{
  return MEMORY[0x270EF89A0]();
}

uint64_t nw_path_is_local()
{
  return MEMORY[0x270EF89C8]();
}

uint64_t nw_path_is_traffic_mgmt_background()
{
  return MEMORY[0x270EF89E0]();
}

uint64_t nw_path_is_viable()
{
  return MEMORY[0x270EF89E8]();
}

uint64_t nw_path_should_probe_connectivity()
{
  return MEMORY[0x270EF8A50]();
}

uint64_t nw_protocol_callbacks_set_add_input_handler()
{
  return MEMORY[0x270EF8A60]();
}

uint64_t nw_protocol_callbacks_set_connect()
{
  return MEMORY[0x270EF8A68]();
}

uint64_t nw_protocol_callbacks_set_connected()
{
  return MEMORY[0x270EF8A70]();
}

uint64_t nw_protocol_callbacks_set_copy_info()
{
  return MEMORY[0x270EF8A78]();
}

uint64_t nw_protocol_callbacks_set_disconnect()
{
  return MEMORY[0x270EF8A80]();
}

uint64_t nw_protocol_callbacks_set_disconnected()
{
  return MEMORY[0x270EF8A88]();
}

uint64_t nw_protocol_callbacks_set_finalize_output_frames()
{
  return MEMORY[0x270EF8A98]();
}

uint64_t nw_protocol_callbacks_set_get_input_frames()
{
  return MEMORY[0x270EF8AA0]();
}

uint64_t nw_protocol_callbacks_set_get_message_properties()
{
  return MEMORY[0x270EF8AA8]();
}

uint64_t nw_protocol_callbacks_set_get_output_frames()
{
  return MEMORY[0x270EF8AB0]();
}

uint64_t nw_protocol_callbacks_set_input_available()
{
  return MEMORY[0x270EF8AB8]();
}

uint64_t nw_protocol_callbacks_set_input_flush()
{
  return MEMORY[0x270EF8AC0]();
}

uint64_t nw_protocol_callbacks_set_link_state()
{
  return MEMORY[0x270EF8AC8]();
}

uint64_t nw_protocol_callbacks_set_output_available()
{
  return MEMORY[0x270EF8AD0]();
}

uint64_t nw_protocol_callbacks_set_output_finished()
{
  return MEMORY[0x270EF8AD8]();
}

uint64_t nw_protocol_callbacks_set_register_notification()
{
  return MEMORY[0x270EF8AE0]();
}

uint64_t nw_protocol_callbacks_set_remove_input_handler()
{
  return MEMORY[0x270EF8AE8]();
}

uint64_t nw_protocol_callbacks_set_replace_input_handler()
{
  return MEMORY[0x270EF8AF0]();
}

uint64_t nw_protocol_callbacks_set_reset()
{
  return MEMORY[0x270EF8AF8]();
}

uint64_t nw_protocol_callbacks_set_unregister_notification()
{
  return MEMORY[0x270EF8B00]();
}

uint64_t nw_protocol_callbacks_set_updated_path()
{
  return MEMORY[0x270EF8B08]();
}

uint64_t nw_protocol_callbacks_set_waiting_for_output()
{
  return MEMORY[0x270EF8B10]();
}

uint64_t nw_protocol_connect_quiet()
{
  return MEMORY[0x270EF8B18]();
}

uint64_t nw_protocol_connected()
{
  return MEMORY[0x270EF8B20]();
}

uint64_t nw_protocol_connected_quiet()
{
  return MEMORY[0x270EF8B28]();
}

uint64_t nw_protocol_copy_info_quiet()
{
  return MEMORY[0x270EF8B40]();
}

nw_protocol_definition_t nw_protocol_copy_tcp_definition(void)
{
  return (nw_protocol_definition_t)MEMORY[0x270EF8B70]();
}

BOOL nw_protocol_definition_is_equal(nw_protocol_definition_t definition1, nw_protocol_definition_t definition2)
{
  return MEMORY[0x270EF8BC8](definition1, definition2);
}

uint64_t nw_protocol_destroy()
{
  return MEMORY[0x270EF8CA8]();
}

uint64_t nw_protocol_disconnect_quiet()
{
  return MEMORY[0x270EF8CB0]();
}

uint64_t nw_protocol_disconnected()
{
  return MEMORY[0x270EF8CB8]();
}

uint64_t nw_protocol_disconnected_is_valid()
{
  return MEMORY[0x270EF8CC0]();
}

uint64_t nw_protocol_downcast()
{
  return MEMORY[0x270EF8CC8]();
}

uint64_t nw_protocol_error()
{
  return MEMORY[0x270EF8CD0]();
}

uint64_t nw_protocol_error_quiet()
{
  return MEMORY[0x270EF8CD8]();
}

uint64_t nw_protocol_establishment_report_create()
{
  return MEMORY[0x270EF8CE0]();
}

uint64_t nw_protocol_establishment_report_set_client_accurate_ecn_state()
{
  return MEMORY[0x270EF8CE8]();
}

uint64_t nw_protocol_establishment_report_set_server_accurate_ecn_state()
{
  return MEMORY[0x270EF8CF8]();
}

uint64_t nw_protocol_get_flow_id()
{
  return MEMORY[0x270EF8D00]();
}

uint64_t nw_protocol_get_identifier()
{
  return MEMORY[0x270EF8D08]();
}

uint64_t nw_protocol_get_input_frames()
{
  return MEMORY[0x270EF8D10]();
}

uint64_t nw_protocol_get_input_handler()
{
  return MEMORY[0x270EF8D18]();
}

uint64_t nw_protocol_get_local_endpoint()
{
  return MEMORY[0x270EF8D20]();
}

uint64_t nw_protocol_get_output_handler()
{
  return MEMORY[0x270EF8D28]();
}

uint64_t nw_protocol_get_parameters()
{
  return MEMORY[0x270EF8D30]();
}

uint64_t nw_protocol_get_path()
{
  return MEMORY[0x270EF8D38]();
}

uint64_t nw_protocol_get_remote_endpoint()
{
  return MEMORY[0x270EF8D40]();
}

uint64_t nw_protocol_input_available()
{
  return MEMORY[0x270EF8D50]();
}

uint64_t nw_protocol_input_available_is_valid()
{
  return MEMORY[0x270EF8D58]();
}

uint64_t nw_protocol_input_finished_quiet()
{
  return MEMORY[0x270EF8D60]();
}

uint64_t nw_protocol_input_handler_is_connection_flow()
{
  return MEMORY[0x270EF8D68]();
}

nw_protocol_definition_t nw_protocol_metadata_copy_definition(nw_protocol_metadata_t metadata)
{
  return (nw_protocol_definition_t)MEMORY[0x270EF8F08](metadata);
}

uint64_t nw_protocol_metadata_copy_identifier()
{
  return MEMORY[0x270EF8F10]();
}

BOOL nw_protocol_metadata_is_ip(nw_protocol_metadata_t metadata)
{
  return MEMORY[0x270EF8F38](metadata);
}

uint64_t nw_protocol_new()
{
  return MEMORY[0x270EF8F60]();
}

uint64_t nw_protocol_notification_type_to_string()
{
  return MEMORY[0x270EF8F68]();
}

uint64_t nw_protocol_notify_quiet()
{
  return MEMORY[0x270EF8F70]();
}

uint64_t nw_protocol_one_to_one_callbacks_new()
{
  return MEMORY[0x270EF8F78]();
}

uint64_t nw_protocol_options_get_log_id_num()
{
  return MEMORY[0x270EF8F90]();
}

uint64_t nw_protocol_options_get_log_id_str()
{
  return MEMORY[0x270EF8F98]();
}

uint64_t nw_protocol_options_is_tcp()
{
  return MEMORY[0x270EF8FA8]();
}

uint64_t nw_protocol_output_available_quiet()
{
  return MEMORY[0x270EF8FB0]();
}

uint64_t nw_protocol_release()
{
  return MEMORY[0x270EF8FC8]();
}

uint64_t nw_protocol_remove_input_handler()
{
  return MEMORY[0x270EF8FD0]();
}

uint64_t nw_protocol_remove_input_handler_is_valid()
{
  return MEMORY[0x270EF8FD8]();
}

uint64_t nw_protocol_retain()
{
  return MEMORY[0x270EF8FE8]();
}

uint64_t nw_protocol_set_flow_id_from_protocol()
{
  return MEMORY[0x270EF8FF8]();
}

uint64_t nw_protocol_set_input_handler()
{
  return MEMORY[0x270EF9000]();
}

uint64_t nw_protocol_set_output_handler()
{
  return MEMORY[0x270EF9008]();
}

uint64_t nw_protocol_supports_external_data()
{
  return MEMORY[0x270EF9058]();
}

uint64_t nw_protocol_supports_external_data_is_valid()
{
  return MEMORY[0x270EF9060]();
}

uint64_t nw_protocol_upcast()
{
  return MEMORY[0x270EF9068]();
}

uint64_t nw_protocol_updated_path()
{
  return MEMORY[0x270EF9070]();
}

uint64_t nw_protocol_updated_path_is_valid()
{
  return MEMORY[0x270EF9078]();
}

uint64_t nw_queue_activate_source()
{
  return MEMORY[0x270EF9088]();
}

uint64_t nw_queue_cancel_source()
{
  return MEMORY[0x270EF9090]();
}

uint64_t nw_queue_context_async()
{
  return MEMORY[0x270EF9098]();
}

uint64_t nw_queue_context_create_source()
{
  return MEMORY[0x270EF90A8]();
}

uint64_t nw_queue_source_set_qos_class_fallback()
{
  return MEMORY[0x270EF90C0]();
}

void nw_release(void *obj)
{
}

void *__cdecl nw_retain(void *obj)
{
  return (void *)MEMORY[0x270EF94A0](obj);
}

uint64_t nw_tcp_create_metadata()
{
  return MEMORY[0x270EF94D0]();
}

uint64_t nw_tcp_options_get_connection_timeout()
{
  return MEMORY[0x270EF94E0]();
}

uint64_t nw_tcp_options_get_disable_ack_stretching()
{
  return MEMORY[0x270EF94E8]();
}

uint64_t nw_tcp_options_get_disable_blackhole_detection()
{
  return MEMORY[0x270EF94F0]();
}

uint64_t nw_tcp_options_get_enable_background_traffic_management()
{
  return MEMORY[0x270EF94F8]();
}

uint64_t nw_tcp_options_get_enable_fast_open()
{
  return MEMORY[0x270EF9500]();
}

uint64_t nw_tcp_options_get_enable_keepalive()
{
  return MEMORY[0x270EF9508]();
}

uint64_t nw_tcp_options_get_enable_l4s()
{
  return MEMORY[0x270EF9510]();
}

uint64_t nw_tcp_options_get_fast_open_force_enable()
{
  return MEMORY[0x270EF9518]();
}

uint64_t nw_tcp_options_get_keepalive_count()
{
  return MEMORY[0x270EF9520]();
}

uint64_t nw_tcp_options_get_keepalive_idle_time()
{
  return MEMORY[0x270EF9528]();
}

uint64_t nw_tcp_options_get_keepalive_interval()
{
  return MEMORY[0x270EF9530]();
}

uint64_t nw_tcp_options_get_maximum_segment_size()
{
  return MEMORY[0x270EF9538]();
}

uint64_t nw_tcp_options_get_no_delay()
{
  return MEMORY[0x270EF9540]();
}

uint64_t nw_tcp_options_get_no_fast_open_cookie()
{
  return MEMORY[0x270EF9548]();
}

uint64_t nw_tcp_options_get_no_options()
{
  return MEMORY[0x270EF9550]();
}

uint64_t nw_tcp_options_get_no_push()
{
  return MEMORY[0x270EF9558]();
}

uint64_t nw_tcp_options_get_no_timewait()
{
  return MEMORY[0x270EF9560]();
}

uint64_t nw_tcp_options_get_persist_timeout()
{
  return MEMORY[0x270EF9568]();
}

uint64_t nw_tcp_options_get_reduce_buffering()
{
  return MEMORY[0x270EF9570]();
}

uint64_t nw_tcp_options_get_retransmit_connection_drop_time()
{
  return MEMORY[0x270EF9578]();
}

uint64_t nw_tcp_options_get_retransmit_fin_drop()
{
  return MEMORY[0x270EF9580]();
}

uint64_t nw_tcp_set_callbacks()
{
  return MEMORY[0x270EF95C0]();
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDA9D0](oslog, type);
}

uint64_t os_nexus_flow_set_wake_from_sleep()
{
  return MEMORY[0x270EDAA08]();
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x270EDB510](__str, __size, __format);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x270EDB5D8](*(void *)&__errnum);
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  return MEMORY[0x270EDBA08](uu1, uu2);
}

void uuid_generate(uuid_t out)
{
}